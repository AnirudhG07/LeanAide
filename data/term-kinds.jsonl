{"noDocExamples":[],"kind":"Lean.Parser.Term.fun","examples":[{"term":"fun C => C","name":"CategoryTheory.ShrinkHoms","doc":"We define a type alias `ShrinkHoms C` for `C`. When we have `LocallySmall.{w} C`,\nwe'll put a `Category.{w}` instance on `ShrinkHoms C`.\n","depth":1},{"term":"fun α => α","name":"Additive","doc":"If `α` carries some multiplicative structure, then `Additive α` carries the corresponding\nadditive structure. ","depth":1},{"term":"fun α => α","name":"Specialization","doc":"Type synonym for a topological space considered with its specialisation order. ","depth":1},{"term":"fun α => α","name":"AsBoolAlg","doc":"Type synonym to view a Boolean ring as a Boolean algebra. ","depth":1},{"term":"fun B => B","name":"CategoryTheory.FreeBicategory","doc":"Free bicategory over a quiver. Its objects are the same as those in the underlying quiver. ","depth":1}],"count":184576}
{"noDocExamples":[],"kind":"Lean.Parser.Term.app","examples":[{"term":"CategoryTheory.Limits.widePushoutShapeOpEquiv CategoryTheory.Limits.WalkingPair","name":"CategoryTheory.Limits.walkingSpanOpEquiv","doc":"The duality equivalence `WalkingSpanᵒᵖ ≌ WalkingCospan` ","depth":1},{"term":"CategoryTheory.Bundled Quiver","name":"CategoryTheory.QuivCat","doc":"Category of quivers. ","depth":1},{"term":"SNum.bit false","name":"SNum.bit0","doc":"Add an inactive bit at the end of a `SNum`. This mimics `ZNum.bit0`. ","depth":1},{"term":"CategoryTheory.Bundled BooleanAlgebra","name":"BoolAlgCat","doc":"The category of boolean algebras. ","depth":1},{"term":"Char.ofNat 46","name":"System.FilePath.extSeparator","doc":"File extension character ","depth":1}],"count":180283}
{"noDocExamples":[],"kind":"Lean.Parser.Term.proj","examples":[{"term":"Orientation.wrapped✝.1","name":"Orientation.volumeForm","doc":"The volume form on an oriented real inner product space, a nonvanishing top-dimensional\nalternating form uniquely defined by compatibility with the orientation and inner product structure.\n","depth":1},{"term":"wrapped✝.1","name":"Span.repr","doc":"Pick some representation of `x : span R w` as a linear combination in `w`,\nusing the axiom of choice.\n","depth":1},{"term":"Localization.wrapped✝.1","name":"Localization.zero","doc":"The zero element in a Localization is defined as `(0, 1)`.\n\nShould not be confused with `AddLocalization.zero` which is `(0, 0)`. ","depth":1},{"term":"Localization.wrapped✝.1","name":"Localization.mul","doc":"Multiplication in a `Localization` is defined as `⟨a, b⟩ * ⟨c, d⟩ = ⟨a * c, b * d⟩`. ","depth":1},{"term":"RatFunc.wrapped✝.1","name":"RatFunc.add","doc":"Addition of rational functions. ","depth":1}],"count":38626}
{"noDocExamples":[],"kind":"«term_=_»","examples":[{"term":"fun u => PNat.XgcdType.a u = PNat.XgcdType.b u","name":"PNat.XgcdType.IsReduced'","doc":"`IsReduced'` is an alternative of `IsReduced`. ","depth":4},{"term":"fun u => u.ap = u.bp","name":"PNat.XgcdType.IsReduced","doc":"`IsReduced` holds if the two entries in the vector are the\nsame.  The reduction algorithm will produce a system with this\nproperty, whose product vector is the same as for the original\nsystem. ","depth":4},{"term":"fun f => MeasureTheory.OuterMeasure.ofFunction (StieltjesFunction.length f) (_ : StieltjesFunction.length f ∅ = 0)","name":"StieltjesFunction.outer","doc":"The Stieltjes outer measure associated to a Stieltjes function. ","depth":4},{"term":"fun X => { toFun := id, map_point := (_ : id X.point = id X.point) }","name":"Pointed.Hom.id","doc":"The identity morphism of `X : Pointed`. ","depth":5},{"term":"fun X =>\n  { toFun := id, map_fst := (_ : id X.toProd.fst = id X.toProd.fst),\n    map_snd := (_ : id X.toProd.snd = id X.toProd.snd) }","name":"Bipointed.Hom.id","doc":"The identity morphism of `X : Bipointed`. ","depth":6}],"count":32222}
{"noDocExamples":[],"kind":"coeNotation","examples":[{"term":"↑Stream'.nats","name":"Stream'.Seq.nats","doc":"The sequence of natural numbers some 0, some 1, ... ","depth":2},{"term":"fun {α} => ↑[]","name":"Multiset.zero","doc":"`0 : Multiset α` is the empty set ","depth":3},{"term":"fun n => ↑(List.range n)","name":"Multiset.range","doc":"`range n` is the multiset lifted from the list `range n`,\nthat is, the set `{0, 1, ..., n-1}`. ","depth":3},{"term":"fun z => (↑z).re","name":"UpperHalfPlane.re","doc":"Real part ","depth":3},{"term":"fun a => ↑(ENNReal.toNNReal a)","name":"ENNReal.toReal","doc":"`toReal x` returns `x` if it is real, `0` otherwise. ","depth":3}],"count":28878}
{"noDocExamples":[],"kind":"Lean.Parser.Term.subst","examples":[{"term":"fun {α} {C} [∀ (a : α), Subsingleton (C (Trunc.mk a))] q f =>\n  Trunc.rec f (_ : ∀ (x b : α), (_ : Trunc.mk x = Trunc.mk b) ▸ f x = f b) q","name":"Trunc.recOnSubsingleton","doc":"A version of `Trunc.recOn` assuming the codomain is a `Subsingleton`. ","depth":11},{"term":"fun {α} [Finite α] {n} h => h ▸ Finite.equivFin α","name":"Finite.equivFinOfCardEq","doc":"Similar to `Finite.equivFin` but with control over the term used for the cardinality. ","depth":11},{"term":"fun {α} {motive} {a b} h₁ h₂ => h₁ ▸ h₂","name":"Eq.subst","doc":"The substitution principle for equality. If `a = b ` and `P a` holds,\nthen `P b` also holds. We conventionally use the name `motive` for `P` here,\nso that you can specify it explicitly using e.g.\n`Eq.subst (motive := fun x => x < 5)` if it is not otherwise inferred correctly.\n\nThis theorem is the underlying mechanism behind the `rw` tactic, which is\nessentially a fancy algorithm for finding good `motive` arguments to usefully\napply this theorem to replace occurrences of `a` with `b` in the goal or\nhypotheses.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n","depth":12},{"term":"fun {α} {r} {motive} [∀ (a : α), Subsingleton (motive (Quot.mk r a))] q f =>\n  Quot.rec (fun a => f a) (_ : ∀ (a b : α) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b) q","name":"Quot.recOnSubsingleton'","doc":"Version of `Quot.recOnSubsingleton` tagged with `elab_as_elim` ","depth":13},{"term":"fun {α} {a b} h => h ▸ rfl","name":"Eq.symm","doc":"Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n","depth":13}],"count":28702}
{"noDocExamples":[],"kind":"Lean.Parser.Term.structInst","examples":[{"term":"{ div := Rat.div }","name":"Rat.instDivRat","doc":"Division of rational numbers. Note: `div a 0 = 0`.  Written with a separate function `Rat.div`\nas a wrapper so that the definition is not unfolded at `.instance` transparency. ","depth":2},{"term":"{ div := Int.ediv }","name":"Int.instDivInt_1","doc":"Core Lean provides instances using T-rounding division, i.e. `Int.div` and `Int.mod`.\nWe override these here.\n","depth":2},{"term":"{ zero := ONote.zero }","name":"ONote.instZeroONote","doc":"Notation for 0 ","depth":2},{"term":"{ name := \"split conjunctions\", transform := Linarith.splitConjunctions.aux }","name":"Linarith.splitConjunctions","doc":"Processor that recursively replaces `P ∧ Q` hypotheses with the pair `P` and `Q`. ","depth":2},{"term":"{ name := \"removeNe\", transform := Linarith.removeNe_aux }","name":"Linarith.removeNe","doc":"`removeNe` case splits on any proof `h : a ≠ b` in the input, turning it into `a < b ∨ a > b`,\nby calling `linarith.removeNe_aux`.\nThis produces `2^n` branches when there are `n` such hypotheses in the input.\n","depth":2}],"count":28370}
{"noDocExamples":[],"kind":"Lean.Parser.Term.explicitUniv","examples":[{"term":"Ordinal.{u_1}","name":"NatOrdinal","doc":"A type synonym for ordinals with natural addition and multiplication. ","depth":0},{"term":"PUnit.{1}","name":"Unit","doc":"The unit type, the canonical type with one element, named `unit` or `()`.\nIn other words, it describes only a single value, which consists of said constructor applied\nto no arguments whatsoever.\nThe `Unit` type is similar to `void` in languages derived from C.\n\n`Unit` is actually defined as `PUnit.{0}` where `PUnit` is the universe\npolymorphic version. The `Unit` should be preferred over `PUnit` where possible to avoid\nunnecessary universe parameters.\n\nIn functional programming, `Unit` is the return type of things that \"return\nnothing\", since a type with one element conveys no additional information.\nWhen programming with monads, the type `m Unit` represents an action that has\nsome side effects but does not return a value, while `m α` would be an action\nthat has side effects and returns a value of type `α`.\n","depth":0},{"term":"ULift.{u, 0} ℕ","name":"FintypeCat.Skeleton","doc":"The \"standard\" skeleton for `FintypeCat`. This is the full subcategory of `FintypeCat`\nspanned by objects of the form `ULift (Fin n)` for `n : ℕ`. We parameterize the objects\nof `Fintype.Skeleton` directly as `ULift ℕ`, as the type `ULift (Fin m) ≃ ULift (Fin n)`\nis nonempty if and only if `n = m`. Specifying universes, `Skeleton : Type u` is a small\nskeletal category equivalent to `Fintype.{u}`.\n","depth":1},{"term":"CategoryTheory.Bundled CategoryTheory.Category.{v, u}","name":"CategoryTheory.Cat","doc":"Category of categories. ","depth":1},{"term":"fun C => CategoryTheory.Category.{u, u + 1} C","name":"CategoryTheory.LargeCategory","doc":"A `LargeCategory` has objects in one universe level higher than the universe level of\nthe morphisms. It is useful for examples such as the category of types, or the category\nof groups, etc.\n","depth":2}],"count":20664}
{"noDocExamples":[],"kind":"Lean.Parser.Term.forall","examples":[{"term":"∀ (α : Type (max u v)), Small.{v, max u v} α","name":"UnivLE","doc":"A class expressing a universe inequality. `UnivLE.{u, v}` expresses that `u ≤ v`.\n\nThere are (at least) two plausible definitions for `u ≤ v`:\n* strong: `∀ α : Type max u v, Small.{v} α`\n* weak: `∀ α : Type u, Small.{v} α`\n\nThe weak definition has the advantage of being transitive.\nHowever only under the strong definition do we have `Small.{v} ((α : Type u) → (β : Type v))`,\nwhich is essential for proving that `Type v` has `Type u`-indexed limits when `u ≤ v`.\n\nThe strong definition implies the weaker definition (see below),\nbut we can not prove the reverse implication.\nThis is because in Lean's type theory, while `max u v` is at least at big as `u` and `v`,\nit could be bigger than both!\n","depth":2},{"term":"fun R =>\n  { toLocallyRingedSpace := AlgebraicGeometry.Spec.locallyRingedSpaceObj R,\n    local_affine :=\n      (_ :\n        ∀ (x : ↑(AlgebraicGeometry.LocallyRingedSpace.toTopCat (AlgebraicGeometry.Spec.locallyRingedSpaceObj R))),\n          ∃ U R_1,\n            Nonempty\n              (AlgebraicGeometry.LocallyRingedSpace.restrict (AlgebraicGeometry.Spec.locallyRingedSpaceObj R)\n                  (_ : OpenEmbedding ↑(TopologicalSpace.Opens.inclusion U.obj)) ≅\n                AlgebraicGeometry.Spec.toLocallyRingedSpace.obj (Opposite.op R_1))) }","name":"AlgebraicGeometry.Scheme.specObj","doc":"The spectrum of a commutative ring, as a scheme.\n","depth":4},{"term":"fun {β} r => ∀ (x : β), r x x","name":"Reflexive","doc":"A reflexive relation relates every element to itself. ","depth":5},{"term":"fun n => PrimeMultiset.ofNatList (Nat.factors ↑n) (_ : ∀ {p : ℕ}, p ∈ Nat.factors ↑n → Nat.Prime p)","name":"PNat.factorMultiset","doc":"The prime factors of n, regarded as a multiset ","depth":5},{"term":"fun f c => ∀ (v : Sat.Valuation), Sat.Valuation.satisfies_fmla v f → Sat.Valuation.satisfies v c","name":"Sat.Fmla.proof","doc":"`f.proof c` asserts that `c` is derivable from `f`. ","depth":6}],"count":16513}
{"noDocExamples":[],"kind":"Lean.Parser.Term.arrow","examples":[{"term":"ℕ → Prop","name":"Sat.Valuation","doc":"A valuation is an assignment of values to all the propositional variables. ","depth":1},{"term":"fun α => α → α","name":"Function.End","doc":"The monoid of endomorphisms.\n\nNote that this is generalized by `CategoryTheory.End` to categories other than `Type u`. ","depth":2},{"term":"fun a => a → False","name":"Not","doc":"`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,\nso if your goal is `¬p` you can use `intro h` to turn the goal into\n`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n","depth":2},{"term":"Mathlib.Notation3.MatchState → Lean.PrettyPrinter.Delaborator.DelabM Mathlib.Notation3.MatchState","name":"Mathlib.Notation3.Matcher","doc":"A matcher is a delaboration function that transforms `MatchState`s. ","depth":2},{"term":"fun α => ℕ → α","name":"Stream'","doc":"A stream `Stream' α` is an infinite sequence of elements of `α`. ","depth":2}],"count":13954}
{"noDocExamples":[],"kind":"Lean.Parser.Term.hole","examples":[{"term":"fun {α} => { cobounded' := Filter.cofinite, le_cofinite' := (_ : Filter.cofinite ≤ Filter.cofinite) }","name":"Bornology.cofinite","doc":"The cofinite filter as a bornology ","depth":4},{"term":"fun ub => { rel := Nat.Up ub, wf := (_ : WellFounded (Nat.Up ub)) }","name":"Nat.upRel","doc":"A well-ordered relation for \"upwards\" induction on the natural numbers up to some bound `ub`. ","depth":4},{"term":"fun R =>\n  { toLocallyRingedSpace := AlgebraicGeometry.Spec.locallyRingedSpaceObj R,\n    local_affine :=\n      (_ :\n        ∀ (x : ↑(AlgebraicGeometry.LocallyRingedSpace.toTopCat (AlgebraicGeometry.Spec.locallyRingedSpaceObj R))),\n          ∃ U R_1,\n            Nonempty\n              (AlgebraicGeometry.LocallyRingedSpace.restrict (AlgebraicGeometry.Spec.locallyRingedSpaceObj R)\n                  (_ : OpenEmbedding ↑(TopologicalSpace.Opens.inclusion U.obj)) ≅\n                AlgebraicGeometry.Spec.toLocallyRingedSpace.obj (Opposite.op R_1))) }","name":"AlgebraicGeometry.Scheme.specObj","doc":"The spectrum of a commutative ring, as a scheme.\n","depth":4},{"term":"fun n => { val := Multiset.range n, nodup := (_ : Multiset.Nodup (Multiset.range n)) }","name":"Finset.range","doc":"`range n` is the set of natural numbers less than `n`. ","depth":4},{"term":"fun f => MeasureTheory.OuterMeasure.ofFunction (StieltjesFunction.length f) (_ : StieltjesFunction.length f ∅ = 0)","name":"StieltjesFunction.outer","doc":"The Stieltjes outer measure associated to a Stieltjes function. ","depth":4}],"count":13381}
{"noDocExamples":[],"kind":"Lean.Parser.Term.typeAscription","examples":[{"term":"fun {α} => { cobounded' := Filter.cofinite, le_cofinite' := (_ : Filter.cofinite ≤ Filter.cofinite) }","name":"Bornology.cofinite","doc":"The cofinite filter as a bornology ","depth":4},{"term":"fun ub => { rel := Nat.Up ub, wf := (_ : WellFounded (Nat.Up ub)) }","name":"Nat.upRel","doc":"A well-ordered relation for \"upwards\" induction on the natural numbers up to some bound `ub`. ","depth":4},{"term":"fun R =>\n  { toLocallyRingedSpace := AlgebraicGeometry.Spec.locallyRingedSpaceObj R,\n    local_affine :=\n      (_ :\n        ∀ (x : ↑(AlgebraicGeometry.LocallyRingedSpace.toTopCat (AlgebraicGeometry.Spec.locallyRingedSpaceObj R))),\n          ∃ U R_1,\n            Nonempty\n              (AlgebraicGeometry.LocallyRingedSpace.restrict (AlgebraicGeometry.Spec.locallyRingedSpaceObj R)\n                  (_ : OpenEmbedding ↑(TopologicalSpace.Opens.inclusion U.obj)) ≅\n                AlgebraicGeometry.Spec.toLocallyRingedSpace.obj (Opposite.op R_1))) }","name":"AlgebraicGeometry.Scheme.specObj","doc":"The spectrum of a commutative ring, as a scheme.\n","depth":4},{"term":"fun n => { val := Multiset.range n, nodup := (_ : Multiset.Nodup (Multiset.range n)) }","name":"Finset.range","doc":"`range n` is the set of natural numbers less than `n`. ","depth":4},{"term":"fun f => MeasureTheory.OuterMeasure.ofFunction (StieltjesFunction.length f) (_ : StieltjesFunction.length f ∅ = 0)","name":"StieltjesFunction.outer","doc":"The Stieltjes outer measure associated to a Stieltjes function. ","depth":4}],"count":12656}
{"noDocExamples":[],"kind":"«term_+_»","examples":[{"term":"fun a => a + 1","name":"Int.succ","doc":"Immediate successor of an integer: `succ n = n + 1` ","depth":7},{"term":"fun {α} =>\n  { val := Stream'.const none,\n    property := (_ : ∀ {x : ℕ}, Stream'.const none x = none → Stream'.const none (x + 1) = Stream'.const none (x + 1)) }","name":"Stream'.Seq.nil","doc":"The empty sequence ","depth":7},{"term":"fun {M} [Add M] =>\n  { top := { carrier := Set.univ, add_mem' := (_ : ∀ {a b : M}, a ∈ Set.univ → b ∈ Set.univ → a + b ∈ Set.univ) } }","name":"AddSubsemigroup.instTopSubsemigroup","doc":"The additive subsemigroup `M` of the magma `M`.","depth":7},{"term":"fun n =>\n  let src := Fin.addCommSemigroup n;\n  let src_1 := (_ : IsCancelAdd (Fin n));\n  AddRightCancelSemigroup.mk (_ : ∀ (a b c : Fin n), a + b = c + b → a = c)","name":"Fin.instAddRightCancelSemigroup","doc":"Note this is more general than `Fin.addCommGroup` as it applies (vacuously) to `Fin 0` too. ","depth":8},{"term":"fun o => Cardinal.aleph' (Ordinal.omega + o)","name":"Cardinal.aleph","doc":"The `aleph` function gives the infinite cardinals listed by their\nordinal index. `aleph 0 = ℵ₀`, `aleph 1 = succ ℵ₀` is the first\nuncountable cardinal, and so on. ","depth":8}],"count":12495}
{"noDocExamples":[],"kind":"«term_*_»","examples":[{"term":"fun n => HasDistribNeg.mk (_ : ∀ (x y : Fin n), -x * y = -(x * y)) (_ : ∀ (x y : Fin n), x * -y = -(x * y))","name":"Fin.instHasDistribNeg","doc":"Note this is more general than `Fin.instCommRing` as it applies (vacuously) to `Fin 0` too. ","depth":7},{"term":"fun {M} [Mul M] =>\n  { top := { carrier := Set.univ, mul_mem' := (_ : ∀ {a b : M}, a ∈ Set.univ → b ∈ Set.univ → a * b ∈ Set.univ) } }","name":"Subsemigroup.instTopSubsemigroup","doc":"The subsemigroup `M` of the magma `M`. ","depth":7},{"term":"fun X [PseudoEMetricSpace X] =>\n  { toEquiv := Equiv.refl X,\n    edist_eq' :=\n      (_ :\n        ∃ r,\n          r ≠ 0 ∧ ∀ (x y : X), edist (Equiv.toFun (Equiv.refl X) x) (Equiv.toFun (Equiv.refl X) y) = ↑r * edist x y) }","name":"DilationEquiv.refl","doc":"Identity map as a `DilationEquiv`. ","depth":8},{"term":"fun {α} [CommMonoid α] => CommGroup.mk (_ : ∀ (x x_1 : αˣ), x * x_1 = x_1 * x)","name":"Units.instCommGroupUnits","doc":"Units of a commutative monoid form a commutative group. ","depth":8},{"term":"fun M [Mul M] =>\n  { toFun := fun x => x, map_mul' := (_ : ∀ (x x_1 : M), (fun x => x) (x * x_1) = (fun x => x) (x * x_1)) }","name":"MulHom.id","doc":"The identity map from a type with multiplication to itself. ","depth":8}],"count":10767}
{"noDocExamples":[],"kind":"«term_∈_»","examples":[{"term":"fun n => PrimeMultiset.ofNatList (Nat.factors ↑n) (_ : ∀ {p : ℕ}, p ∈ Nat.factors ↑n → Nat.Prime p)","name":"PNat.factorMultiset","doc":"The prime factors of n, regarded as a multiset ","depth":5},{"term":"fun {α} [Denumerable α] => Denumerable.mk (_ : ∀ (n : ℕ), ∃ a, a ∈ Encodable.decodeList n ∧ Encodable.encodeList a = n)","name":"Denumerable.denumerableList","doc":"If `α` is denumerable, then so is `List α`. ","depth":7},{"term":"fun {α} f =>\n  { sets := f.sets, nonempty := (_ : ∃ x, x ∈ f.sets),\n    inter_sets := (_ : ∀ {x y : Set α}, x ∈ f.sets → y ∈ f.sets → ∃ z, z ∈ f.sets ∧ z ⊆ x ∩ y) }","name":"Filter.asBasis","doc":"View a filter as a filter basis. ","depth":7},{"term":"fun {n} c =>\n  { boundaries := Composition.boundaries c, zero_mem := (_ : 0 ∈ Composition.boundaries c),\n    getLast_mem := (_ : Fin.last n ∈ Composition.boundaries c) }","name":"Composition.toCompositionAsSet","doc":"To `c : Composition n`, one can associate a `CompositionAsSet n` by registering the leftmost\npoint of each block, and adding a virtual point at the right of the last block. ","depth":7},{"term":"fun {n} c =>\n  { blocks := CompositionAsSet.blocks c,\n    blocks_pos := (_ : ∀ (i : ℕ), i ∈ List.ofFn (CompositionAsSet.blocksFun c) → 0 < i),\n    blocks_sum := (_ : List.sum (CompositionAsSet.blocks c) = n) }","name":"CompositionAsSet.toComposition","doc":"Associating a `Composition n` to a `CompositionAsSet n`, by registering the sizes of the\nblocks as a list of positive integers. ","depth":7}],"count":10090}
{"noDocExamples":[],"kind":"«term_≤_»","examples":[{"term":"fun {α} => { cobounded' := Filter.cofinite, le_cofinite' := (_ : Filter.cofinite ≤ Filter.cofinite) }","name":"Bornology.cofinite","doc":"The cofinite filter as a bornology ","depth":4},{"term":"OrderEmbedding.ofMapLEIff Cardinal.lift.{u, v}\n  (_ : ∀ (x x_1 : Cardinal.{v}), Cardinal.lift.{u, v} x ≤ Cardinal.lift.{u, v} x_1 ↔ x ≤ x_1)","name":"Cardinal.liftOrderEmbedding","doc":"`Cardinal.lift` as an `OrderEmbedding`. ","depth":6},{"term":"fun α [TopologicalSpace α] =>\n  { cobounded' := Filter.cocompact α, le_cofinite' := (_ : Filter.cocompact α ≤ Filter.cofinite) }","name":"Bornology.inCompact","doc":"Sets that are contained in a compact set form a bornology. Its `cobounded` filter is\n`Filter.cocompact`. See also `Bornology.relativelyCompact` the bornology of sets with compact\nclosure. ","depth":6},{"term":"fun {α} s => Cycle.length s ≤ 1","name":"Cycle.Subsingleton","doc":"A `s : Cycle α` that is at most one element. ","depth":6},{"term":"fun r => 0 ≤ r.num","name":"Rat.Nonneg","doc":"A rational number is called nonnegative if its numerator is nonnegative. ","depth":6}],"count":7968}
{"noDocExamples":[],"kind":"Lean.Parser.Term.match","examples":[{"term":"fun x =>\n  match x with\n  | PSet.mk α A => α","name":"PSet.Type","doc":"The underlying type of a pre-set ","depth":5},{"term":"fun x =>\n  match x with\n  | WType.Natα.zero => Empty\n  | WType.Natα.succ => Unit","name":"WType.Natβ","doc":"The arity of the constructors for the naturals, `zero` takes no arguments, `succ` takes one ","depth":6},{"term":"fun x =>\n  match x with\n  | none => Part.none\n  | some n => ↑n","name":"PartENat.ofENat","doc":"Coercion from `ℕ∞` to `PartENat`. ","depth":6},{"term":"fun x =>\n  match x with\n  | true => false\n  | false => true","name":"not","doc":"`not x`, or `!x`, is the boolean \"not\" operation (not to be confused\nwith `Not : Prop → Prop`, which is the propositional connective).\n","depth":6},{"term":"fun x =>\n  match x with\n  | Ordering.lt => true\n  | x => false","name":"Ordering.isLT","doc":"Check whether the ordering is 'less than'.\n","depth":6}],"count":6665}
{"noDocExamples":[],"kind":"Lean.Parser.Term.depArrow","examples":[{"term":"fun {ι} β => (i : ι) → β i","name":"Hamming","doc":"Type synonym for a Pi type which inherits the usual algebraic instances, but is equipped with\nthe Hamming metric and norm, instead of `Pi.normedAddCommGroup` which uses the sup norm. ","depth":4},{"term":"fun {ι} H => (i : ι) → H i","name":"ModelPi","doc":"Same thing as `∀ i, H i`. We introduce it for technical reasons,\nsee note [Manifold type tags]. ","depth":4},{"term":"fun {α} r => (a : α) → Decidable (r a)","name":"DecidablePred","doc":"A decidable predicate. See `Decidable`. ","depth":5},{"term":"fun {ι} {β} => Equiv.refl ((i : ι) → β i)","name":"Hamming.toHamming","doc":"`Hamming.toHamming` is the identity function to the `Hamming` of a type.  ","depth":5},{"term":"fun p {ι} α => WithLp p ((i : ι) → α i)","name":"PiLp","doc":"A copy of a Pi type, on which we will put the `L^p` distance. Since the Pi type itself is\nalready endowed with the `L^∞` distance, we need the type synonym to avoid confusing typeclass\nresolution. Also, we let it depend on `p`, to get a whole family of type on which we can put\ndifferent distances. ","depth":6}],"count":6329}
{"noDocExamples":[],"kind":"Lean.Parser.Term.let_fun","examples":[{"term":"let_fun this := inferInstance;\nthis","name":"Stonean.instLargeCategoryStonean","doc":"Stonean spaces form a large category. ","depth":8},{"term":"fun X =>\n  let_fun this := inferInstance;\n  this","name":"Stonean.instTopologicalSpace","doc":"Stonean spaces are topological spaces. ","depth":9},{"term":"fun {G} [TopologicalSpace G] [AddGroup G] [TopologicalAddGroup G] [T2Space G] K =>\n  let_fun this := TopologicalSpace.PositiveCompacts.weaklyLocallyCompactSpace_of_addGroup K;\n  inferInstance","name":"TopologicalSpace.PositiveCompacts.locallyCompactSpace_of_addGroup","doc":"Every separated topological additive group\nin which there exists a compact set with nonempty interior is locally compact.","depth":14},{"term":"fun {G} [TopologicalSpace G] [Group G] [TopologicalGroup G] [T2Space G] K =>\n  let_fun this := TopologicalSpace.PositiveCompacts.weaklyLocallyCompactSpace_of_group K;\n  inferInstance","name":"TopologicalSpace.PositiveCompacts.locallyCompactSpace_of_group","doc":"Every separated topological group in which there exists a compact set with nonempty interior\nis locally compact. ","depth":14},{"term":"fun {α} {r} hr =>\n  WellFounded.intro\n    (let_fun this := WellFounded.isIrrefl hr;\n    fun x => Relation.acc_of_singleton fun a x => Acc.cutExpand (WellFounded.apply hr a))","name":"WellFounded.cutExpand","doc":"`CutExpand r` is well-founded when `r` is. ","depth":16}],"count":5863}
{"noDocExamples":[],"kind":"Lean.Parser.Term.explicit","examples":[{"term":"@CategoryTheory.Functor.map_isPushout","name":"CategoryTheory.IsPushout.map","doc":"**Alias** of `CategoryTheory.Functor.map_isPushout`.","depth":0},{"term":"@MeasureTheory.Memℒp.of_le","name":"MeasureTheory.Memℒp.mono","doc":"**Alias** of `MeasureTheory.Memℒp.of_le`.","depth":0},{"term":"@Left.mul_le_one","name":"mul_le_one'","doc":"**Alias** of `Left.mul_le_one`.\n\n---\n\nAssumes left covariance.\nThe lemma assuming right covariance is `Right.mul_le_one`. ","depth":0},{"term":"@CategoryTheory.Limits.isSplitMono_sigma_ι.proof_1","name":"CategoryTheory.Limits.isSplitMono_sigma_ι","doc":"In the presence of zero morphisms, coprojections into a coproduct are (split) monomorphisms. ","depth":0},{"term":"@nnnorm_le_nnnorm_add_nnnorm_sub","name":"nnnorm_le_insert","doc":"**Alias** of `nnnorm_le_nnnorm_add_nnnorm_sub`.","depth":0}],"count":5510}
{"noDocExamples":[],"kind":"«term_↔_»","examples":[{"term":"OrderEmbedding.ofMapLEIff Cardinal.lift.{u, v}\n  (_ : ∀ (x x_1 : Cardinal.{v}), Cardinal.lift.{u, v} x ≤ Cardinal.lift.{u, v} x_1 ↔ x ≤ x_1)","name":"Cardinal.liftOrderEmbedding","doc":"`Cardinal.lift` as an `OrderEmbedding`. ","depth":6},{"term":"fun α => { toFun := some, invFun := some, inv := (_ : ∀ (x x_1 : α), some x_1 = some x ↔ some x = some x_1) }","name":"PEquiv.refl","doc":"The identity map as a partial equivalence. ","depth":6},{"term":"fun {α} u => UniformSpace.mk u (_ : ∀ (x : Set α), IsOpen x ↔ IsOpen x)","name":"UniformSpace.ofCore","doc":"Construct a `UniformSpace` from a `UniformSpace.Core`. ","depth":7},{"term":"fun {a} b h [Decidable b] => decidable_of_decidable_of_iff (_ : b ↔ a)","name":"decidable_of_iff'","doc":"Transfer decidability of `b` to decidability of `a`, if the propositions are equivalent.\nThis is the same as `decidable_of_iff` but the iff is flipped. ","depth":8},{"term":"fun {α} r =>\n  { toEmbedding := Function.Embedding.refl α,\n    map_rel_iff' :=\n      (_ :\n        ∀ {a b : α},\n          r (↑(Function.Embedding.refl α) a) (↑(Function.Embedding.refl α) b) ↔\n            r (↑(Function.Embedding.refl α) a) (↑(Function.Embedding.refl α) b)) }","name":"RelEmbedding.refl","doc":"Identity map is a relation embedding. ","depth":8}],"count":4625}
{"noDocExamples":[],"kind":"«term_<_»","examples":[{"term":"fun u => { val := { val := ↑u.val, isLt := (_ : ↑u.val < UInt64.size) } }","name":"USize.toUInt64","doc":"Upcast a `USize` to a `UInt64`.\nThis is lossless because `USize.size` is either `2^32` or `2^64`.\nThis function is overridden with a native implementation.\n","depth":6},{"term":"fun {α} [DenselyNormedField α] => NontriviallyNormedField.mk (_ : ∃ x, 1 < ‖x‖)","name":"DenselyNormedField.toNontriviallyNormedField","doc":"A densely normed field is always a nontrivially normed field.\nSee note [lower instance priority]. ","depth":6},{"term":"{ n // 0 < n }","name":"PNat","doc":"`ℕ+` is the type of positive natural numbers. It is defined as a subtype,\nand the VM representation of `ℕ+` is the same as `ℕ` because the proof\nis not stored. ","depth":7},{"term":"fun {n} c =>\n  { blocks := CompositionAsSet.blocks c,\n    blocks_pos := (_ : ∀ (i : ℕ), i ∈ List.ofFn (CompositionAsSet.blocksFun c) → 0 < i),\n    blocks_sum := (_ : List.sum (CompositionAsSet.blocks c) = n) }","name":"CompositionAsSet.toComposition","doc":"Associating a `Composition n` to a `CompositionAsSet n`, by registering the sizes of the\nblocks as a list of positive integers. ","depth":7},{"term":"fun n h => { val := { val := n, isLt := (_ : n < USize.size) } }","name":"USize.ofNat32","doc":"Upcast a `Nat` less than `2^32` to a `USize`.\nThis is lossless because `USize.size` is either `2^32` or `2^64`.\nThis function is overridden with a native implementation.\n","depth":7}],"count":4415}
{"noDocExamples":[],"kind":"«term_•_»","examples":[{"term":"fun {α} =>\n  MulAction.mk (_ : ∀ (x : α), 1 • x = 1 • x)\n    (_ : ∀ (x x_1 : Function.End α) (x_2 : α), (x * x_1) • x_2 = (x * x_1) • x_2)","name":"Function.End.applyMulAction","doc":"The tautological action by `Function.End α` on `α`.\n\nThis is generalized to bundled endomorphisms by:\n* `Equiv.Perm.applyMulAction`\n* `AddMonoid.End.applyDistribMulAction`\n* `AddAut.applyDistribMulAction`\n* `MulAut.applyMulDistribMulAction`\n* `RingHom.applyDistribMulAction`\n* `LinearEquiv.applyDistribMulAction`\n* `LinearMap.applyModule`\n* `RingHom.applyMulSemiringAction`\n* `AlgEquiv.applyMulSemiringAction`\n","depth":8},{"term":"fun {R} [NonUnitalRing R] S =>\n  { toNonUnitalSubsemiring := S.toNonUnitalSubsemiring,\n    smul_mem' := (_ : ∀ (n : ℤ) (_x : R), _x ∈ S.carrier → n • _x ∈ S) }","name":"nonUnitalSubalgebraOfNonUnitalSubring","doc":"A non-unital subring is a non-unitalsubalgebra. ","depth":10},{"term":"fun {R} [NonUnitalSemiring R] S =>\n  { toNonUnitalSubsemiring := S, smul_mem' := (_ : ∀ (n : ℕ) (_x : R), _x ∈ S.carrier → n • _x ∈ S) }","name":"nonUnitalSubalgebraOfNonUnitalSubsemiring","doc":"A non-unital subsemiring is a non-unital `ℕ`-subalgebra. ","depth":10},{"term":"fun M' {X} [SMul M' X] => { toFun := id, map_smul' := (_ : ∀ (x : M') (x_1 : X), id (x • x_1) = id (x • x_1)) }","name":"MulActionHom.id","doc":"The identity map as an equivariant map. ","depth":10},{"term":"fun {𝕜} [NormedDivisionRing 𝕜] [CharZero 𝕜] [NormedAlgebra ℝ 𝕜] =>\n  NormedAlgebra.mk (_ : ∀ (q : ℚ) (x : 𝕜), ‖q • x‖ ≤ ‖q‖ * ‖x‖)","name":"normedAlgebraRat","doc":"Any normed characteristic-zero division ring that is a normed algebra over the reals is also a\nnormed algebra over the rationals.\n\nPhrased another way, if `𝕜` is a normed algebra over the reals, then `AlgebraRat` respects that\nnorm. ","depth":10}],"count":4262}
{"noDocExamples":[],"kind":"Lean.Parser.Term.let","examples":[{"term":"fun C =>\n  let x := ULift.{w, u} C;\n  C","name":"CategoryTheory.ULiftHom","doc":"`ULiftHom.{w} C` is an alias for `C`, which is endowed with a category instance\nwhose morphisms are obtained by applying `ULift.{w}` to the morphisms from `C`.\n","depth":3},{"term":"fun {α} =>\n  let src := Function.Embedding.some;\n  { toFun := WithTop.some, inj' := (_ : Function.Injective Function.Embedding.some.toFun) }","name":"Function.Embedding.coeWithTop","doc":"Embedding into `WithTop α`. ","depth":6},{"term":"fun {α} x =>\n  let a := x;\n  LazyList.cons a (Thunk.pure LazyList.nil)","name":"LazyList.singleton","doc":"The singleton lazy list.  ","depth":7},{"term":"fun n =>\n  let src := Fin.addCommSemigroup n;\n  let src_1 := (_ : IsCancelAdd (Fin n));\n  AddRightCancelSemigroup.mk (_ : ∀ (a b c : Fin n), a + b = c + b → a = c)","name":"Fin.instAddRightCancelSemigroup","doc":"Note this is more general than `Fin.addCommGroup` as it applies (vacuously) to `Fin 0` too. ","depth":8},{"term":"fun n =>\n  let src := Fin.addCommSemigroup n;\n  let src_1 := (_ : IsCancelAdd (Fin n));\n  AddLeftCancelSemigroup.mk (_ : ∀ (a b c : Fin n), a + b = a + c → b = c)","name":"Fin.instAddLeftCancelSemigroup","doc":"Note this is more general than `Fin.addCommGroup` as it applies (vacuously) to `Fin 0` too. ","depth":8}],"count":4168}
{"noDocExamples":[],"kind":"«term_-_»","examples":[{"term":"fun u => PNat.XgcdType.q u - 1","name":"PNat.XgcdType.qp","doc":"`qp = q - 1` ","depth":7},{"term":"fun i => ↑i - 1","name":"PNat.natPred","doc":"Predecessor of a `ℕ+`, as a `ℕ`. ","depth":7},{"term":"fun self => ByteArray.size self.arr - self.off","name":"ByteSliceT.size","doc":"The number of elements in the byte slice. ","depth":7},{"term":"fun a => a - 1","name":"Int.pred","doc":"Immediate predecessor of an integer: `pred n = n - 1` ","depth":7},{"term":"fun p q => ↑(padicValInt p q.num) - ↑(padicValNat p q.den)","name":"padicValRat","doc":"`padicValRat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the\nvaluation of `q.den`. If `q = 0` or `p = 1`, then `padicValRat p q` defaults to `0`. ","depth":8}],"count":4020}
{"noDocExamples":[],"kind":"«term_∧_»","examples":[{"term":"fun x y => SetTheory.PGame.Lf x y ∧ SetTheory.PGame.Lf y x","name":"SetTheory.PGame.Fuzzy","doc":"The fuzzy, confused, or incomparable relation on pre-games.\n\nIf `x ‖ 0`, then the first player can always win `x`. ","depth":6},{"term":"fun {α} [Denumerable α] => Denumerable.mk (_ : ∀ (n : ℕ), ∃ a, a ∈ Encodable.decodeList n ∧ Encodable.encodeList a = n)","name":"Denumerable.denumerableList","doc":"If `α` is denumerable, then so is `List α`. ","depth":7},{"term":"fun {α} f =>\n  { sets := f.sets, nonempty := (_ : ∃ x, x ∈ f.sets),\n    inter_sets := (_ : ∀ {x y : Set α}, x ∈ f.sets → y ∈ f.sets → ∃ z, z ∈ f.sets ∧ z ⊆ x ∩ y) }","name":"Filter.asBasis","doc":"View a filter as a filter basis. ","depth":7},{"term":"fun c => Cardinal.aleph0 ≤ c ∧ c ≤ Ordinal.cof (Cardinal.ord c)","name":"Cardinal.IsRegular","doc":"A cardinal is regular if it is infinite and it equals its own cofinality. ","depth":7},{"term":"fun {α} [TopologicalSpace α] s => Set.Nonempty s ∧ IsPreconnected s","name":"IsConnected","doc":"A connected set is one that is nonempty and where there is no non-trivial open partition. ","depth":7}],"count":3724}
{"noDocExamples":[],"kind":"«term-_»","examples":[{"term":"ℤ√(-1)","name":"GaussianInt","doc":"The Gaussian integers, defined as `ℤ√(-1)`. ","depth":5},{"term":"fun m n => Int.shiftl m (-n)","name":"Int.shiftr","doc":"`shiftr m n` produces an integer whose binary representation\nis obtained by right-shifting the binary representation of `m` by `n` places ","depth":6},{"term":"fun n => InvolutiveNeg.mk (_ : ∀ (x : Fin n), - -x = x)","name":"Fin.instInvolutiveNeg","doc":"Note this is more general than `Fin.addCommGroup` as it applies (vacuously) to `Fin 0` too. ","depth":7},{"term":"fun {d} => { star := fun z => { re := z.re, im := -z.im } }","name":"Zsqrtd.instStarZsqrtd","doc":"Conjugation in `ℤ√d`. The conjugate of `a + b √d` is `a - b √d`. ","depth":7},{"term":"fun {x} => Equiv.cast (_ : SetTheory.PGame.RightMoves x = SetTheory.PGame.LeftMoves (-x))","name":"SetTheory.PGame.toLeftMovesNeg","doc":"Turns a right move for `x` into a left move for `-x` and vice versa.\n\nEven though these types are the same (not definitionally so), this is the preferred way to convert\nbetween them. ","depth":7}],"count":3643}
{"noDocExamples":[],"kind":"«term_^_»","examples":[{"term":"2 ^ System.Platform.numBits","name":"USize.size","doc":"The size of type `UInt16`, that is, `2^System.Platform.numBits`, which may\nbe either `2^32` or `2^64` depending on the platform's architecture.\n","depth":6},{"term":"2 ^ Cardinal.aleph0","name":"Cardinal.continuum","doc":"Cardinality of continuum. ","depth":7},{"term":"fun n => n * 4 ^ n","name":"SzemerediRegularity.stepBound","doc":"Auxiliary function for Szemerédi's regularity lemma. Blowing up a partition of size `n` during\nthe induction results in a partition of size at most `stepBound n`. ","depth":8},{"term":"fun p => 2 ^ p - 1","name":"mersenne","doc":"The Mersenne numbers, 2^p - 1. ","depth":9},{"term":"fun n => (-1) ^ n * bernoulli' n","name":"bernoulli","doc":"The Bernoulli numbers are defined to be `bernoulli'` with a parity sign. ","depth":9}],"count":3553}
{"noDocExamples":[],"kind":"termℝ","examples":[{"term":"WithBot (WithTop ℝ)","name":"EReal","doc":"ereal : The type `[-∞, ∞]` ","depth":2},{"term":"MetricSpace.ofT0PseudoMetricSpace ℝ","name":"Real.metricSpace","doc":"Instantiate the reals as a metric space. ","depth":3},{"term":"Algebra.ofId ℝ ℂ","name":"Complex.ofRealAm","doc":"`ℝ`-algebra morphism version of the canonical embedding of `ℝ` in `ℂ`. ","depth":5},{"term":"Filter.Germ ↑(Filter.hyperfilter ℕ) ℝ","name":"Hyperreal","doc":"Hyperreal numbers on the ultrafilter extending the cofinite filter ","depth":5},{"term":"fun α [MeasurableSpace α] => MeasureTheory.VectorMeasure α ℝ","name":"MeasureTheory.SignedMeasure","doc":"A `SignedMeasure` is an `ℝ`-vector measure. ","depth":7}],"count":3327}
{"noDocExamples":[],"kind":"«term∃_,_»","examples":[{"term":"fun R =>\n  { toLocallyRingedSpace := AlgebraicGeometry.Spec.locallyRingedSpaceObj R,\n    local_affine :=\n      (_ :\n        ∀ (x : ↑(AlgebraicGeometry.LocallyRingedSpace.toTopCat (AlgebraicGeometry.Spec.locallyRingedSpaceObj R))),\n          ∃ U R_1,\n            Nonempty\n              (AlgebraicGeometry.LocallyRingedSpace.restrict (AlgebraicGeometry.Spec.locallyRingedSpaceObj R)\n                  (_ : OpenEmbedding ↑(TopologicalSpace.Opens.inclusion U.obj)) ≅\n                AlgebraicGeometry.Spec.toLocallyRingedSpace.obj (Opposite.op R_1))) }","name":"AlgebraicGeometry.Scheme.specObj","doc":"The spectrum of a commutative ring, as a scheme.\n","depth":4},{"term":"fun {α} [DenselyNormedField α] => NontriviallyNormedField.mk (_ : ∃ x, 1 < ‖x‖)","name":"DenselyNormedField.toNontriviallyNormedField","doc":"A densely normed field is always a nontrivially normed field.\nSee note [lower instance priority]. ","depth":6},{"term":"fun P [DecidablePred P] => { Dom := ∃ n, P n, get := Nat.find }","name":"PartENat.find","doc":"The smallest `PartENat` satisfying a (decidable) predicate `P : ℕ → Prop` ","depth":7},{"term":"fun {α} [Denumerable α] => Denumerable.mk (_ : ∀ (n : ℕ), ∃ a, a ∈ Encodable.decodeList n ∧ Encodable.encodeList a = n)","name":"Denumerable.denumerableList","doc":"If `α` is denumerable, then so is `List α`. ","depth":7},{"term":"fun {α} f =>\n  { sets := f.sets, nonempty := (_ : ∃ x, x ∈ f.sets),\n    inter_sets := (_ : ∀ {x y : Set α}, x ∈ f.sets → y ∈ f.sets → ∃ z, z ∈ f.sets ∧ z ⊆ x ∩ y) }","name":"Filter.asBasis","doc":"View a filter as a filter basis. ","depth":7}],"count":2851}
{"noDocExamples":[],"kind":"termℕ","examples":[{"term":"ℕ","name":"Task.Priority","doc":"Task priority. Tasks with higher priority will always be scheduled before ones with lower priority. ","depth":0},{"term":"ℕ","name":"SimplexCategory","doc":"The simplex category:\n* objects are natural numbers `n : ℕ`\n* morphisms from `n` to `m` are monotone functions `Fin (n+1) → Fin (m+1)`\n","depth":0},{"term":"ULift.{u, 0} ℕ","name":"FintypeCat.Skeleton","doc":"The \"standard\" skeleton for `FintypeCat`. This is the full subcategory of `FintypeCat`\nspanned by objects of the form `ULift (Fin n)` for `n : ℕ`. We parameterize the objects\nof `Fintype.Skeleton` directly as `ULift ℕ`, as the type `ULift (Fin m) ≃ ULift (Fin n)`\nis nonempty if and only if `n = m`. Specifying universes, `Skeleton : Type u` is a small\nskeletal category equivalent to `Fintype.{u}`.\n","depth":1},{"term":"ℕ → Prop","name":"Sat.Valuation","doc":"A valuation is an assignment of values to all the propositional variables. ","depth":1},{"term":"Part ℕ","name":"PartENat","doc":"Type of natural numbers with infinity (`⊤`) ","depth":1}],"count":2808}
{"noDocExamples":[],"kind":"Lean.Parser.Term.tuple","examples":[{"term":"()","name":"FirstOrder.Language.adj","doc":"The symbol representing the adjacency relation. ","depth":0},{"term":"fun α => ()","name":"Quiver.SingleObj.star","doc":"The single object in `SingleObj α`. ","depth":1},{"term":"fun {α} f => f ()","name":"dbgStackTrace","doc":"Print stack trace to stderr before evaluating given closure. Currently supported on Linux only. ","depth":3},{"term":"fun {α} fn prio => { get := fn () }","name":"Task.spawn","doc":"`spawn fn : Task α` constructs and immediately launches a new task for\nevaluating the function `fn () : α` asynchronously.\n\n`prio`, if provided, is the priority of the task.\n","depth":5},{"term":"fun {α} x => Thunk.fn x ()","name":"Thunk.get","doc":"Forces a thunk to extract the value. This will cache the result,\nso a second call to the same function will return the value in O(1)\ninstead of calling the stored getter function.\n","depth":5}],"count":2442}
{"noDocExamples":[],"kind":"«term_/_»","examples":[{"term":"fun z => Complex.sin z / Complex.cos z","name":"Complex.tan","doc":"The complex tangent function, defined as `sin z / cos z` ","depth":7},{"term":"fun z => Complex.sinh z / Complex.cosh z","name":"Complex.tanh","doc":"The complex hyperbolic tangent function, defined as `sinh z / cosh z` ","depth":7},{"term":"fun θ => Real.Angle.sin θ / Real.Angle.cos θ","name":"Real.Angle.tan","doc":"The tangent of a `Real.Angle`. ","depth":7},{"term":"fun n k => Nat.descFactorial n k / Nat.factorial k","name":"Nat.fast_choose","doc":"A faster implementation of `choose`, to be used during bytecode evaluation\nand in compiled code. ","depth":8},{"term":"fun p => p / (p - 1)","name":"Real.conjugateExponent","doc":"The conjugate exponent of `p` is `q = p/(p-1)`, so that `1/p + 1/q = 1`. ","depth":8}],"count":2362}
{"noDocExamples":[],"kind":"«term_⁻¹»","examples":[{"term":"Hyperreal.ofSeq fun n => (↑n)⁻¹","name":"Hyperreal.epsilon","doc":"A sample infinitesimal hyperreal","depth":6},{"term":"fun E [SeminormedGroup E] =>\n  { toFun := norm, map_one' := (_ : ‖1‖ = 0), mul_le' := (_ : ∀ (a b : E), ‖a * b‖ ≤ ‖a‖ + ‖b‖),\n    inv' := (_ : ∀ (a : E), ‖a⁻¹‖ = ‖a‖) }","name":"normGroupSeminorm","doc":"The norm of a seminormed group as a group seminorm. ","depth":9},{"term":"fun {α} [Monoid α] u => ↑u⁻¹","name":"Units.Simps.val_inv","doc":"See Note [custom simps projection] ","depth":9},{"term":"fun {α} [Inv α] [Sup α] => { abs := fun a => a ⊔ a⁻¹ }","name":"Inv.toHasAbs","doc":"`abs a` is the absolute value of `a`. ","depth":9},{"term":"fun x => if x ≤ 0 then 0 else rexp (-x⁻¹)","name":"expNegInvGlue","doc":"`expNegInvGlue` is the real function given by `x ↦ exp (-1/x)` for `x > 0` and `0`\nfor `x ≤ 0`. It is a basic building block to construct smooth partitions of unity. Its main property\nis that it vanishes for `x ≤ 0`, it is positive for `x > 0`, and the junction between the two\nbehaviors is flat enough to retain smoothness. The fact that this function is `C^∞` is proved in\n`expNegInvGlue.contDiff `. ","depth":9}],"count":2293}
{"noDocExamples":[],"kind":"termDepIfThenElse","examples":[{"term":"fun α => if h : Nonempty α then some (Classical.choice h) else none","name":"Option.choice","doc":"An arbitrary `some a` with `a : α` if `α` is nonempty, and otherwise `none`. ","depth":7},{"term":"fun x => if h : ∃ r, Hyperreal.IsSt x r then Classical.choose h else 0","name":"Hyperreal.st","doc":"Standard part function: like a \"round\" to ℝ instead of ℤ ","depth":9},{"term":"fun α => if h : Infinite α then PSum.inr h else PSum.inl (fintypeOfNotInfinite h)","name":"fintypeOrInfinite","doc":"Any type is (classically) either a `Fintype`, or `Infinite`.\n\nOne can obtain the relevant typeclasses via `cases fintypeOrInfinite α`.\n","depth":9},{"term":"fun {α} a [Decidable a.Dom] d => if ha : a.Dom then Part.get a ha else d","name":"Part.getOrElse","doc":"Retrieves the value of `a : Part α` if it exists, and return the provided default value\notherwise. ","depth":10},{"term":"fun {α} o [Decidable o.Dom] => if h : o.Dom then some (Part.get o h) else none","name":"Part.toOption","doc":"Convert a `Part α` with a decidable domain to an option ","depth":10}],"count":2224}
{"noDocExamples":[],"kind":"«term¬_»","examples":[{"term":"fun {α} s => ¬Set.Finite s","name":"Set.Infinite","doc":"A set is infinite if it is not finite.\n\nThis is protected so that it does not conflict with global `Infinite`. ","depth":5},{"term":"fun {β} r => ∀ (x : β), ¬r x x","name":"Irreflexive","doc":"Irreflexive means \"not reflexive\". ","depth":6},{"term":"fun {n} x y => ¬Bitvec.Slt y x","name":"Bitvec.Sle","doc":"signed less-than-or-equal-to proposition ","depth":7},{"term":"fun v x =>\n  match x with\n  | Sat.Literal.pos i => ¬v i\n  | Sat.Literal.neg i => v i","name":"Sat.Valuation.neg","doc":"`v.neg lit` asserts that literal `lit` is falsified in the valuation. ","depth":7},{"term":"fun {n} x y => ¬Bitvec.Ult y x","name":"Bitvec.Ule","doc":"unsigned less-than-or-equal-to proposition ","depth":7}],"count":2048}
{"noDocExamples":[],"kind":"«term⊤»","examples":[{"term":"fun {α} => Filter.Realizer.ofEq (_ : Filter.principal Set.univ = ⊤) (Filter.Realizer.principal Set.univ)","name":"Filter.Realizer.top","doc":"`Unit` is a realizer for the top filter ","depth":7},{"term":"fun x =>\n  match x with\n  | none => ⊤\n  | some none => ⊥\n  | some (some x) => ↑(-x)","name":"EReal.neg","doc":"negation on `EReal` ","depth":7},{"term":"fun α [Top α] => { toFun := id, map_top' := (_ : id ⊤ = id ⊤) }","name":"TopHom.id","doc":"`id` as a `TopHom`. ","depth":8},{"term":"fun {G} [Group G] [Group.IsNilpotent G] h => Group.commGroupOfCenterEqTop (_ : Subgroup.center G = ⊤)","name":"commGroupOfNilpotencyClass","doc":"Groups with nilpotency class at most one are abelian ","depth":9},{"term":"fun {α} [Preorder α] t => Ordnode.Valid' ⊥ t ⊤","name":"Ordnode.Valid","doc":"The validity predicate for an `Ordnode` subtree. This asserts that the `size` fields are\ncorrect, the tree is balanced, and the elements of the tree are organized according to the\nordering. ","depth":9}],"count":1959}
{"noDocExamples":[],"kind":"«term_≠_»","examples":[{"term":"fun l n =>\n  { val := ↑(Denumerable.raise' l n), nodup := (_ : List.Pairwise (fun a b => a ≠ b) (Denumerable.raise' l n)) }","name":"Denumerable.raise'Finset","doc":"Makes `raise' l n` into a finset. Elements are distinct thanks to `raise'_sorted`. ","depth":7},{"term":"fun c => c ≠ 0 ∧ Order.IsSuccLimit c","name":"Cardinal.IsLimit","doc":"A cardinal is a limit if it is not zero or a successor cardinal. Note that `ℵ₀` is a limit\ncardinal by this definition, but `0` isn't.\n\nUse `IsSuccLimit` if you want to include the `c = 0` case. ","depth":7},{"term":"fun {α} => List.Pairwise fun x x_1 => x ≠ x_1","name":"List.Nodup","doc":"`Nodup l` means that `l` has no duplicates, that is, any element appears at most\nonce in the List. It is defined as `Pairwise (≠)`. ","depth":7},{"term":"fun X [PseudoEMetricSpace X] =>\n  { toEquiv := Equiv.refl X,\n    edist_eq' :=\n      (_ :\n        ∃ r,\n          r ≠ 0 ∧ ∀ (x y : X), edist (Equiv.toFun (Equiv.refl X) x) (Equiv.toFun (Equiv.refl X) y) = ↑r * edist x y) }","name":"DilationEquiv.refl","doc":"Identity map as a `DilationEquiv`. ","depth":8},{"term":"fun α [PseudoEMetricSpace α] =>\n  { toFun := id, edist_eq' := (_ : ∃ r, r ≠ 0 ∧ ∀ (x y : α), edist (id x) (id y) = ↑r * edist x y) }","name":"Dilation.id","doc":"The identity is a dilation ","depth":8}],"count":1915}
{"noDocExamples":[],"kind":"«term{_}»","examples":[{"term":"fun p => {p}","name":"PrimeMultiset.ofPrime","doc":"The multiset consisting of a single prime ","depth":5},{"term":"{FirstOrder.Language.Relations.irreflexive FirstOrder.Language.adj,\n  FirstOrder.Language.Relations.symmetric FirstOrder.Language.adj}","name":"FirstOrder.Language.Theory.simpleGraph","doc":"The theory of simple graphs. ","depth":6},{"term":"fun L => {FirstOrder.Language.Sentence.cardGe L 1}","name":"FirstOrder.Language.nonemptyTheory","doc":"A theory that indicates a structure is nonempty. ","depth":6},{"term":"fun {α} => { one := {[]} }","name":"Language.instOneLanguage","doc":"`1 : Language α` contains only one element `[]`. ","depth":7},{"term":"fun {α} [One α] => { one := {1} }","name":"Set.one","doc":"The set `1 : Set α` is defined as `{1}` in locale `Pointwise`. ","depth":7}],"count":1815}
{"noDocExamples":[],"kind":"«term{_:_//_}»","examples":[{"term":"{ p // Nat.Prime p }","name":"Nat.Primes","doc":"The type of prime numbers ","depth":3},{"term":"{ o // ONote.NF o }","name":"NONote","doc":"The type of normal ordinal notations. (It would have been\nnicer to define this right in the inductive type, but `NF o`\nrequires `repr` which requires `ONote`, so all these things\nwould have to be defined at once, which messes up the VM\nrepresentation.) ","depth":3},{"term":"{ α // Nonempty α }","name":"NonemptyType","doc":"`NonemptyType.{u}` is the type of nonempty types in universe `u`.\nIt is mainly used in constant declarations where we wish to introduce a type\nand simultaneously assert that it is nonempty, but otherwise make the type\nopaque.\n","depth":3},{"term":"fun α => { f // Stream'.IsSeq f }","name":"Stream'.Seq","doc":"`Seq α` is the type of possibly infinite lists (referred here as sequences).\nIt is encoded as an infinite stream of options such that if `f n = none`, then\n`f m = none` for all `m ≥ n`. ","depth":5},{"term":"fun α => { f // IsPoly f }","name":"Poly","doc":"The type of multivariate integer polynomials ","depth":5}],"count":1730}
{"noDocExamples":[],"kind":"«term[_]»","examples":[{"term":"fun {α} => ↑[]","name":"Multiset.zero","doc":"`0 : Multiset α` is the empty set ","depth":3},{"term":"fun n => List.iotaTR.go n []","name":"List.iotaTR","doc":"Tail-recursive version of `iota`. ","depth":3},{"term":"fun n => List.range.loop n []","name":"List.range","doc":"`O(n)`. `range n` is the numbers from `0` to `n` exclusive, in increasing order.\n* `range 5 = [0, 1, 2, 3, 4]`\n","depth":3},{"term":"fun {α} => ↑[]","name":"Cycle.nil","doc":"The unique empty cycle. ","depth":3},{"term":"fun c => [c]","name":"Sat.Fmla.one","doc":"A single clause as a formula. ","depth":4}],"count":1697}
{"noDocExamples":[],"kind":"«term_∘_»","examples":[{"term":"Linarith.Linexp.vars ∘ Linarith.Comp.coeffs","name":"Linarith.Comp.vars","doc":"`c.vars` returns the list of variables that appear in the linear expression contained in `c`. ","depth":5},{"term":"some ∘ some","name":"Real.toEReal","doc":"The canonical inclusion from reals to ereals. Registered as a coercion. ","depth":5},{"term":"fun n => Option.isSome ∘ Linarith.Linexp.get n","name":"Linarith.Linexp.contains","doc":"`l.contains n` is true iff `n` is the first element of a pair in `l`.\n","depth":6},{"term":"fun {ι} f => Ordinal.sup (Order.succ ∘ f)","name":"Ordinal.lsub","doc":"The least strict upper bound of a family of ordinals. ","depth":9},{"term":"fun {α} {n} v => v ∘ Fin.succ","name":"Matrix.vecTail","doc":"`vecTail v` gives a vector consisting of all entries of `v` except the first ","depth":9}],"count":1668}
{"noDocExamples":[],"kind":"Set.«term{_|_}»","examples":[{"term":"fun p A => {y | A y ∧ p y}","name":"Class.sep","doc":"`{x ∈ A | p x}` is the class of elements in `A` satisfying `p` ","depth":7},{"term":"fun {α} {β} f => {a | (f a).Dom}","name":"PFun.Dom","doc":"The domain of a partial function ","depth":7},{"term":"fun {α} f => {x | Function.IsFixedPt f x}","name":"Function.fixedPoints","doc":"The set of fixed points of a map `f : α → α`. ","depth":7},{"term":"fun {α} => {p | p.fst = p.snd}","name":"idRel","doc":"The identity relation, or the graph of the identity function ","depth":8},{"term":"fun x => {y | ↑y ∈ x}","name":"Class.congToClass","doc":"Convert a conglomerate (a collection of classes) into a class ","depth":8}],"count":1411}
{"noDocExamples":[],"kind":"«term⊥»","examples":[{"term":"fun A => ⊥","name":"FintypeCat.botTopology","doc":"Finite types are given the discrete topology. ","depth":7},{"term":"⊥","name":"BoxIntegral.IntegrationParams.GP","doc":"The `BoxIntegral.IntegrationParams` corresponding to the generalized Perron integral. In the\ncorresponding filter, we require that the tagged partition is subordinate to a (possibly,\ndiscontinuous) positive function `r` and each tag belongs to the corresponding closed box. We also\nrequire an upper estimate on the distortion of all boxes of the partition. ","depth":7},{"term":"fun {α} [TopologicalSpace α] => { default := ⊥ }","name":"TopologicalSpace.Compacts.instInhabitedCompacts","doc":"The type of compact sets is inhabited, with default element the empty set. ","depth":7},{"term":"fun x =>\n  match x with\n  | none => ⊤\n  | some none => ⊥\n  | some (some x) => ↑(-x)","name":"EReal.neg","doc":"negation on `EReal` ","depth":7},{"term":"fun {α} [TopologicalSpace α] => { default := ⊥ }","name":"TopologicalSpace.Closeds.instInhabitedCloseds","doc":"The type of closed sets is inhabited, with default element the empty set. ","depth":8}],"count":1354}
{"noDocExamples":[],"kind":"«term‖_‖»","examples":[{"term":"fun {α} [DenselyNormedField α] => NontriviallyNormedField.mk (_ : ∃ x, 1 < ‖x‖)","name":"DenselyNormedField.toNontriviallyNormedField","doc":"A densely normed field is always a nontrivially normed field.\nSee note [lower instance priority]. ","depth":6},{"term":"fun {V} [SeminormedAddCommGroup V] => NormedAddTorsor.mk (_ : ∀ (a b : V), dist a b = ‖a - b‖)","name":"SeminormedAddCommGroup.toNormedAddTorsor","doc":"A `SeminormedAddCommGroup` is a `NormedAddTorsor` over itself. ","depth":8},{"term":"fun E [SeminormedGroup E] =>\n  { toFun := norm, map_one' := (_ : ‖1‖ = 0), mul_le' := (_ : ∀ (a b : E), ‖a * b‖ ≤ ‖a‖ + ‖b‖),\n    inv' := (_ : ∀ (a : E), ‖a⁻¹‖ = ‖a‖) }","name":"normGroupSeminorm","doc":"The norm of a seminormed group as a group seminorm. ","depth":9},{"term":"fun {α} [NormedRing α] => SeminormedRing.mk (_ : ∀ (x y : α), dist x y = ‖x - y‖) (_ : ∀ (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖)","name":"NormedRing.toSeminormedRing","doc":"A normed ring is a seminormed ring. ","depth":9},{"term":"fun {α} [NormedDivisionRing α] =>\n  NormedRing.mk (_ : ∀ (x y : α), dist x y = ‖x - y‖) (_ : ∀ (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖)","name":"NormedDivisionRing.toNormedRing","doc":"A normed division ring is a normed ring. ","depth":9}],"count":1339}
{"noDocExamples":[],"kind":"«term_::_»","examples":[{"term":"fun {α} l => l :: List.permutationsAux l []","name":"List.permutations","doc":"List of all permutations of `l`.\n\npermutations [1, 2, 3] =\n[[1, 2, 3], [2, 1, 3], [3, 2, 1],\n [2, 3, 1], [3, 1, 2], [1, 3, 2]] ","depth":6},{"term":"Nat.binaryRec [] fun b x IH => b :: IH","name":"Nat.bits","doc":"`bits n` returns a list of Bools which correspond to the binary representation of n","depth":7},{"term":"fun x =>\n  match x with\n  | b :: tail => b\n  | x => default","name":"Computability.decodeBool","doc":"A decoding function from `List Bool` to bool. ","depth":7},{"term":"fun {α} x =>\n  match x with\n  | [] => []\n  | head :: as => as","name":"List.tail","doc":"Get the tail of a nonempty list, or return `[]` for `[]`. ","depth":8},{"term":"fun {α} x =>\n  match x with\n  | [] => true\n  | head :: tail => false","name":"List.isEmpty","doc":"`O(1)`. `isEmpty l` is true if the list is empty.\n* `isEmpty [] = true`\n* `isEmpty [a] = false`\n* `isEmpty [a, b] = false`\n","depth":8}],"count":1336}
{"noDocExamples":[],"kind":"Set.term_''_","examples":[{"term":"fun α [SupSet α] => { toFun := id, map_sSup' := (_ : ∀ (s : Set α), id (sSup s) = sSup (id '' s)) }","name":"sSupHom.id","doc":"`id` as a `sSupHom`. ","depth":8},{"term":"fun α [InfSet α] => { toFun := id, map_sInf' := (_ : ∀ (s : Set α), id (sInf s) = sInf (id '' s)) }","name":"sInfHom.id","doc":"`id` as an `sInfHom`. ","depth":8},{"term":"fun {α} [TopologicalSpace α] s => sSup (nhds '' s)","name":"nhdsSet","doc":"The filter of neighborhoods of a set in a topological space. ","depth":9},{"term":"fun {α} {β} e => Equiv.toLocalEquivOfImageEq e Set.univ Set.univ (_ : ↑e '' Set.univ = Set.univ)","name":"Equiv.toLocalEquiv","doc":"Associate a `LocalEquiv` to an `Equiv`. ","depth":9},{"term":"fun {L} {L'} g T => FirstOrder.Language.LHom.onSentence g '' T","name":"FirstOrder.Language.LHom.onTheory","doc":"Maps a theory's symbols along a language map. ","depth":9}],"count":1261}
{"noDocExamples":[],"kind":"«term_⟶_»","examples":[{"term":"fun X Y => X.toLocallyRingedSpace ⟶ Y.toLocallyRingedSpace","name":"AlgebraicGeometry.Scheme.Hom","doc":"A morphism between schemes is a morphism between the underlying locally ringed spaces. ","depth":6},{"term":"fun {C} [CategoryTheory.CategoryStruct.{v, u} C] X => X ⟶ X","name":"CategoryTheory.End","doc":"Endomorphisms of an object in a category. Arguments order in multiplication agrees with\n`Function.comp`, not with `CategoryTheory.CategoryStruct.comp`. ","depth":8},{"term":"fun {U} [Quiver U] v => (u : U) × (u ⟶ v)","name":"Quiver.Costar","doc":"The `Quiver.Costar` at a vertex is the collection of arrows whose target is the vertex.\nThe type `Quiver.Costar v` is defined to be `Σ (u : U), (u ⟶ v)`. ","depth":9},{"term":"fun {C} [CategoryTheory.Bicategory C] X => X ⟶ X","name":"CategoryTheory.EndMonoidal","doc":"The endomorphisms of an object in a bicategory can be considered as a monoidal category. ","depth":9},{"term":"fun {U} [Quiver U] u => (v : U) × (u ⟶ v)","name":"Quiver.Star","doc":"The `Quiver.Star` at a vertex is the collection of arrows whose source is the vertex.\nThe type `Quiver.Star u` is defined to be `Σ (v : U), (u ⟶ v)`. ","depth":9}],"count":1256}
{"noDocExamples":[],"kind":"Lean.Parser.Term.quotedName","examples":[{"term":"[`div_div_eq_mul_div, `div_neg]","name":"CancelDenoms.deriveThms","doc":"Theorems to get expression into a form that `findCancelFactor` and `mkProdPrf`\ncan more easily handle. These are important for dividing by rationals and negative integers. ","depth":4},{"term":"Lean.ParserDescr.node `Real.termπ 1024 (Lean.ParserDescr.symbol \"π\")","name":"Real.termπ","doc":"The number π = 3.14159265... Defined here using choice as twice a zero of cos in [1,2], from\nwhich one can derive all its properties. For explicit bounds on π, see `Data.Real.Pi.Bounds`. ","depth":5},{"term":"Lean.ParserDescr.node `witt_truncateFun_tac 1024 (Lean.ParserDescr.nonReservedSymbol \"witt_truncateFun_tac\" false)","name":"witt_truncateFun_tac","doc":"A macro tactic used to prove that `truncateFun` respects ring operations. ","depth":5},{"term":"Lean.ParserDescr.node `command#find_home_ 1022\n  (Lean.ParserDescr.binary `andthen (Lean.ParserDescr.symbol \"#find_home\") (Lean.ParserDescr.const `ident))","name":"«command#find_home_»","doc":"Find locations as high as possible in the import hierarchy\nwhere the named declaration could live.\n","depth":5},{"term":"Lean.ParserDescr.node `ZNum.transfer 1024 (Lean.ParserDescr.nonReservedSymbol \"transfer\" false)","name":"ZNum.transfer","doc":"This tactic tries to prove (in)equalities about `ZNum`s by transferring them to the `Int` world and\nthen trying to call `simp`.\n```lean\nexample (n : ZNum) (m : ZNum) : n ≤ n + m * m := by\n  transfer\n  exact mul_self_nonneg _\n```\n","depth":5}],"count":1207}
{"noDocExamples":[],"kind":"termIfThenElse","examples":[{"term":"if System.Platform.isWindows = true then [Char.ofNat 92, Char.ofNat 47] else [Char.ofNat 47]","name":"System.FilePath.pathSeparators","doc":"The list of all possible separators. ","depth":7},{"term":"if System.Platform.isWindows = true then Char.ofNat 92 else Char.ofNat 47","name":"System.FilePath.pathSeparator","doc":"The character that separates directories. In the case where more than one character is possible, `pathSeparator` is the 'ideal' one. ","depth":7},{"term":"if System.Platform.isWindows = true then Char.ofNat 59 else Char.ofNat 58","name":"System.SearchPath.separator","doc":"The character that is used to separate the entries in the $PATH (or %PATH%) environment variable. ","depth":7},{"term":"fun n => if n ≤ 1 then n else Nat.sqrt.iter n (n / 2)","name":"Nat.sqrt","doc":"Integer square root function. Implemented via Newton's method.\n","depth":9},{"term":"fun a => if a.den = 1 then a.num else a.num / ↑a.den","name":"Rat.floor","doc":"The floor of a rational number `a` is the largest integer less than or equal to `a`. ","depth":9}],"count":1199}
{"noDocExamples":[],"kind":"Set.«term_⁻¹'_»","examples":[{"term":"fun {α} s => Opposite.op ⁻¹' s","name":"Set.unop","doc":"The unop of a set `s` is the set obtained by taking the unop of each member of `s`. ","depth":6},{"term":"fun {α} s => Opposite.unop ⁻¹' s","name":"Set.op","doc":"The opposite of a set `s` is the set obtained by taking the opposite of each member of `s`. ","depth":7},{"term":"fun {G} {H} [Group H] f => f ⁻¹' IsSubgroup.trivial H","name":"IsGroupHom.ker","doc":"`ker f : Set G` is the underlying subset of the kernel of a map `G → H`. ","depth":8},{"term":"fun s t => Complex.re ⁻¹' s ∩ Complex.im ⁻¹' t","name":"Complex.Set.reProdIm","doc":"The product of a set on the real axis and a set on the imaginary axis of the complex plane,\ndenoted by `s ×ℂ t`. ","depth":8},{"term":"fun {β} x V => Prod.mk x ⁻¹' V","name":"UniformSpace.ball","doc":"The ball around `(x : β)` with respect to `(V : Set (β × β))`. Intended to be\nused for `V ∈ 𝓤 β`, but this is not needed for the definition. Recovers the\nnotions of metric space ball when `V = {p | dist p.1 p.2 < r }`.  ","depth":8}],"count":1176}
{"noDocExamples":[],"kind":"«term_∩_»","examples":[{"term":"fun {α} f =>\n  { sets := f.sets, nonempty := (_ : ∃ x, x ∈ f.sets),\n    inter_sets := (_ : ∀ {x y : Set α}, x ∈ f.sets → y ∈ f.sets → ∃ z, z ∈ f.sets ∧ z ⊆ x ∩ y) }","name":"Filter.asBasis","doc":"View a filter as a filter basis. ","depth":7},{"term":"fun s t => Complex.re ⁻¹' s ∩ Complex.im ⁻¹' t","name":"Complex.Set.reProdIm","doc":"The product of a set on the real axis and a set on the imaginary axis of the complex plane,\ndenoted by `s ×ℂ t`. ","depth":8},{"term":"fun {α} g =>\n  { IsOpen := TopologicalSpace.GenerateOpen g, isOpen_univ := (_ : TopologicalSpace.GenerateOpen g Set.univ),\n    isOpen_inter :=\n      (_ :\n        ∀ (s t : Set α),\n          TopologicalSpace.GenerateOpen g s →\n            TopologicalSpace.GenerateOpen g t → TopologicalSpace.GenerateOpen g (s ∩ t)),\n    isOpen_sUnion :=\n      (_ :\n        ∀ (S : Set (Set α)),\n          (∀ (s : Set α), s ∈ S → TopologicalSpace.GenerateOpen g s) → TopologicalSpace.GenerateOpen g (⋃₀ S)) }","name":"TopologicalSpace.generateFrom","doc":"The smallest topological space containing the collection `g` of basic sets ","depth":8},{"term":"fun {α} m =>\n  MeasurableSpace.DynkinSystem.toMeasurableSpace (MeasureTheory.OuterMeasure.caratheodoryDynkin m)\n    (_ :\n      ∀ (s₁ s₂ : Set α),\n        MeasureTheory.OuterMeasure.IsCaratheodory m s₁ →\n          MeasureTheory.OuterMeasure.IsCaratheodory m s₂ → MeasureTheory.OuterMeasure.IsCaratheodory m (s₁ ∩ s₂))","name":"MeasureTheory.OuterMeasure.caratheodory","doc":"Given an outer measure `μ`, the Carathéodory-measurable space is\ndefined such that `s` is measurable if `∀t, μ t = μ (t ∩ s) + μ (t \\ s)`. ","depth":9},{"term":"fun {α} {m0} s =>\n  MeasureTheory.Measure.liftLinear (MeasureTheory.OuterMeasure.restrict s)\n    (_ :\n      ∀ (μ : MeasureTheory.Measure α) (s' : Set α),\n        MeasurableSet s' →\n          ∀ (t : Set α),\n            ↑(↑(MeasureTheory.OuterMeasure.restrict s) ↑μ) t =\n              ↑(↑(MeasureTheory.OuterMeasure.restrict s) ↑μ) (t ∩ s') +\n                ↑(↑(MeasureTheory.OuterMeasure.restrict s) ↑μ) (t \\ s'))","name":"MeasureTheory.Measure.restrictₗ","doc":"Restrict a measure `μ` to a set `s` as an `ℝ≥0∞`-linear map. ","depth":9}],"count":1148}
{"noDocExamples":[],"kind":"«term_∨_»","examples":[{"term":"fun x => Hyperreal.InfinitePos x ∨ Hyperreal.InfiniteNeg x","name":"Hyperreal.Infinite","doc":"A hyperreal number is infinite if it is infinite positive or infinite negative ","depth":4},{"term":"fun {β} r => ∀ (x y : β), r x y ∨ r y x","name":"Total","doc":"A relation is total if for all `x` and `y`, either `x ≺ y` or `y ≺ x`. ","depth":8},{"term":"fun {p} [(b : Bool) → Decidable (p b)] => decidable_of_decidable_of_iff (_ : p false ∨ p true ↔ ∃ b, p b)","name":"Bool.decidableExistsBool","doc":"If `p b` is decidable for all `b : Bool`, then `∃ b, p b` is decidable ","depth":9},{"term":"fun n => n < 55296 ∨ 57343 < n ∧ n < 1114112","name":"isValidChar","doc":"Determines if the given integer is a valid [Unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value).\n\nNote that values in `[0xd800, 0xdfff]` are reserved for [UTF-16 surrogate pairs](https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates).\n","depth":9},{"term":"fun n => n < 55296 ∨ 57343 < n ∧ n < 1114112","name":"Nat.isValidChar","doc":"A `Nat` denotes a valid unicode codepoint if it is less than `0x110000`, and\nit is also not a \"surrogate\" character (the range `0xd800` to `0xdfff` inclusive).\n","depth":9}],"count":1078}
{"noDocExamples":[],"kind":"«term_⊓_»","examples":[{"term":"fun α [Inf α] => { toFun := id, map_inf' := (_ : ∀ (x x_1 : α), id (x ⊓ x_1) = id (x ⊓ x_1)) }","name":"InfHom.id","doc":"`id` as an `InfHom`. ","depth":8},{"term":"fun {α} [TopologicalSpace α] a s => nhds a ⊓ Filter.principal s","name":"nhdsWithin","doc":"The \"neighborhood within\" filter. Elements of `𝓝[s] a` are sets containing the\nintersection of `s` and a neighborhood of `a`. ","depth":9},{"term":"fun {α} [CoheytingAlgebra α] a => a ⊓ ￢a","name":"Coheyting.boundary","doc":"The boundary of an element of a co-Heyting algebra is the intersection of its Heyting negation\nwith itself. Note that this is always `⊥` for a boolean algebra. ","depth":10},{"term":"fun {α} [TopologicalSpace α] x F => Filter.NeBot (nhds x ⊓ F)","name":"ClusterPt","doc":"A point `x` is a cluster point of a filter `F` if `𝓝 x ⊓ F ≠ ⊥`. Also known as\nan accumulation point or a limit point, but beware that terminology varies. This\nis *not* the same as asking `𝓝[≠] x ⊓ F ≠ ⊥`. See `mem_closure_iff_clusterPt` in particular. ","depth":10},{"term":"fun {α} [Inf α] [HImp α] a b => (b ⇨ a) ⊓ (a ⇨ b)","name":"bihimp","doc":"The Heyting bi-implication is `(b ⇨ a) ⊓ (a ⇨ b)`. This generalizes equivalence of\npropositions. ","depth":11}],"count":1070}
{"noDocExamples":[],"kind":"«term_⊔_»","examples":[{"term":"fun α [Sup α] => { toFun := id, map_sup' := (_ : ∀ (x x_1 : α), id (x ⊔ x_1) = id (x ⊔ x_1)) }","name":"SupHom.id","doc":"`id` as a `SupHom`. ","depth":8},{"term":"fun {α} [Neg α] [Sup α] => { abs := fun a => a ⊔ -a }","name":"Neg.toHasAbs","doc":"`abs a` is the absolute value of `a`","depth":9},{"term":"fun {α} [Inv α] [Sup α] => { abs := fun a => a ⊔ a⁻¹ }","name":"Inv.toHasAbs","doc":"`abs a` is the absolute value of `a`. ","depth":9},{"term":"fun {α} [Sup α] [SDiff α] a b => a \\ b ⊔ b \\ a","name":"symmDiff","doc":"The symmetric difference operator on a type with `⊔` and `\\` is `(A \\ B) ⊔ (B \\ A)`. ","depth":11},{"term":"fun {α} [Lattice α] a b => Set.Icc (a ⊓ b) (a ⊔ b)","name":"Set.uIcc","doc":"`uIcc a b` is the set of elements lying between `a` and `b`, with `a` and `b` included.\nNote that we define it more generally in a lattice as `Set.Icc (a ⊓ b) (a ⊔ b)`. In a product type,\n`uIcc` corresponds to the bounding box of the two elements. ","depth":11}],"count":1044}
{"noDocExamples":[],"kind":"«term_⊆_»","examples":[{"term":"fun {α} f =>\n  { sets := f.sets, nonempty := (_ : ∃ x, x ∈ f.sets),\n    inter_sets := (_ : ∀ {x y : Set α}, x ∈ f.sets → y ∈ f.sets → ∃ z, z ∈ f.sets ∧ z ⊆ x ∩ y) }","name":"Filter.asBasis","doc":"View a filter as a filter basis. ","depth":7},{"term":"fun {α} [HasSubset α] a b => b ⊆ a","name":"Superset","doc":"Superset relation: `a ⊇ b`  ","depth":8},{"term":"fun x => ∀ (y : ZFSet), y ∈ x → y ⊆ x","name":"ZFSet.IsTransitive","doc":"A transitive set is one where every element is a subset. ","depth":8},{"term":"fun {α} s hs =>\n  { sets := s, univ_sets := (_ : Set.univ ∈ s), sets_of_superset := (_ : ∀ {x y : Set α}, x ∈ s → x ⊆ y → y ∈ s),\n    inter_sets := (_ : ∀ {x y : Set α}, x ∈ s → y ∈ s → x ∩ y ∈ s) }","name":"Filter.mkOfClosure","doc":"`mk_of_closure s hs` constructs a filter on `α` whose elements set is exactly\n`s : Set (Set α)`, provided one gives the assumption `hs : (generate s).sets = s`. ","depth":9},{"term":"fun {α} g =>\n  Filter.ofCountableInter (Filter.CountableGenerateSets g)\n    (_ :\n      ∀ (x : Set (Set α)),\n        Set.Countable x →\n          (∀ (s : Set α), s ∈ x → Filter.CountableGenerateSets g s) → Filter.CountableGenerateSets g (⋂₀ x))\n    (_ : ∀ (x x_1 : Set α), Filter.CountableGenerateSets g x → x ⊆ x_1 → Filter.CountableGenerateSets g x_1)","name":"Filter.countableGenerate","doc":"`Filter.countableGenerate g` is the greatest `countableInterFilter` containing `g`.","depth":9}],"count":1025}
{"noDocExamples":[],"kind":"«term∅»","examples":[{"term":"ZFSet.mk ∅","name":"ZFSet.empty","doc":"The empty ZFC set ","depth":3},{"term":"CategoryTheory.Limits.IsInitial.ofUnique ∅","name":"AlgebraicGeometry.emptyIsInitial","doc":"The empty scheme is the initial object in the category of schemes. ","depth":4},{"term":"fun f => MeasureTheory.OuterMeasure.ofFunction (StieltjesFunction.length f) (_ : StieltjesFunction.length f ∅ = 0)","name":"StieltjesFunction.outer","doc":"The Stieltjes outer measure associated to a Stieltjes function. ","depth":4},{"term":"fun {α} => { zero := ∅ }","name":"Language.instZeroLanguage","doc":"Zero language has no elements. ","depth":6},{"term":"fun α => Equiv.equivEmpty ↑∅","name":"Equiv.Set.empty","doc":"An empty set is equivalent to the `Empty` type. ","depth":7}],"count":957}
{"noDocExamples":[],"kind":"termℤ","examples":[{"term":"Finset (ℤ × ℤ)","name":"SetTheory.PGame.Domineering.Board","doc":"A Domineering board is an arbitrary finite subset of `ℤ × ℤ`. ","depth":3},{"term":"Nat.castRingHom ℤ","name":"Int.ofNatHom","doc":"Coercion `ℕ → ℤ` as a `RingHom`. ","depth":3},{"term":"Linarith.Map Linarith.Monom ℤ","name":"Linarith.Sum","doc":"Linear combinations of monomials are represented by mapping monomials to coefficients. ","depth":3},{"term":"List (ℕ × ℤ)","name":"Linarith.Linexp","doc":"A linear expression is a list of pairs of variable indices and coefficients,\nrepresenting the sum of the products of each coefficient with its corresponding variable.\n\nSome functions on `Linexp` assume that `n : Nat` occurs at most once as the first element of a pair,\nand that the list is sorted in decreasing order of the first argument.\nThis is not enforced by the type but the operations here preserve it.\n","depth":3},{"term":"fun R [Semiring R] => AddMonoidAlgebra R ℤ","name":"LaurentPolynomial","doc":"The semiring of Laurent polynomials with coefficients in the semiring `R`.\nWe denote it by `R[T;T⁻¹]`.\nThe ring homomorphism `C : R →+* R[T;T⁻¹]` includes `R` as the constant polynomials. ","depth":5}],"count":850}
{"noDocExamples":[],"kind":"«term_×_»","examples":[{"term":"Lean.MVarId × List Lean.Expr","name":"Linarith.Branch","doc":"Some preprocessors perform branching case splits. A `Branch` is used to track one of these case\nsplits. The first component, an `MVarId`, is the goal corresponding to this branch of the split,\ngiven as a metavariable. The `List Expr` component is the list of hypotheses for `linarith`\nin this branch.\n","depth":2},{"term":"Finset (ℤ × ℤ)","name":"SetTheory.PGame.Domineering.Board","doc":"A Domineering board is an arbitrary finite subset of `ℤ × ℤ`. ","depth":3},{"term":"List (Lean.Expr × ℕ)","name":"Linarith.ExprMap","doc":"`ExprMap` is used to record atomic expressions which have been seen while processing inequality\nexpressions.\n","depth":3},{"term":"fun α => α × Stream'.Seq α","name":"Stream'.Seq1","doc":"`Seq1 α` is the type of nonempty sequences. ","depth":3},{"term":"List (ℕ × ℤ)","name":"Linarith.Linexp","doc":"A linear expression is a list of pairs of variable indices and coefficients,\nrepresenting the sum of the products of each coefficient with its corresponding variable.\n\nSome functions on `Linexp` assume that `n : Nat` occurs at most once as the first element of a pair,\nand that the list is sorted in decreasing order of the first argument.\nThis is not enforced by the type but the operations here preserve it.\n","depth":3}],"count":746}
{"noDocExamples":[],"kind":"«term_∪_»","examples":[{"term":"fun {α} s q => Semiquot.blur' q (_ : q.s ⊆ s ∪ q.s)","name":"Semiquot.blur","doc":"Replace `s` in a `q : Semiquot α` with a union `s ∪ q.s` ","depth":10},{"term":"fun {α} => { add := fun x x_1 => x ∪ x_1 }","name":"Language.instAddLanguage","doc":"The sum of two languages is their union. ","depth":10},{"term":"fun c k => Turing.PartrecToTM2.codeSupp' c k ∪ Turing.PartrecToTM2.contSupp k","name":"Turing.PartrecToTM2.codeSupp","doc":"The (finite!) set of machine states visited during the course of evaluation of `c` in\ncontinuation `k`. This is actually closed under forward simulation (see `tr_supports`), and the\nexistence of this set means that the machine constructed in this section is in fact a proper\nTuring machine, with a finite set of states. ","depth":10},{"term":"fun L [FirstOrder.Language.IsOrdered L] =>\n  FirstOrder.Language.linearOrderTheory L ∪\n    {FirstOrder.Language.noTopOrderSentence L, FirstOrder.Language.noBotOrderSentence L,\n      FirstOrder.Language.denselyOrderedSentence L}","name":"FirstOrder.Language.dlo","doc":"The theory of dense linear orders without endpoints. ","depth":10},{"term":"fun {α} t s s' => s ∩ t ∪ s' \\ t","name":"Set.ite","doc":"`ite` for sets: `Set.ite t s s' ∩ t = s ∩ t`, `Set.ite t s s' ∩ tᶜ = s' ∩ tᶜ`.\nDefined as `s ∩ t ∪ s' \\ t`. ","depth":11}],"count":732}
{"noDocExamples":[],"kind":"«term_ᶜ»","examples":[{"term":"fun {ι} f => sInf (Set.range f)ᶜ","name":"Ordinal.mex","doc":"The minimum excluded ordinal in a family of ordinals. ","depth":8},{"term":"fun {α} s =>\n  { MeasurableSet' := MeasurableSpace.GenerateMeasurable s,\n    measurableSet_empty := (_ : MeasurableSpace.GenerateMeasurable s ∅),\n    measurableSet_compl :=\n      (_ : ∀ (t : Set α), MeasurableSpace.GenerateMeasurable s t → MeasurableSpace.GenerateMeasurable s tᶜ),\n    measurableSet_iUnion :=\n      (_ :\n        ∀ (f : ℕ → Set α),\n          (∀ (n : ℕ), MeasurableSpace.GenerateMeasurable s (f n)) →\n            MeasurableSpace.GenerateMeasurable s (⋃ (i : ℕ), f i)) }","name":"MeasurableSpace.generateFrom","doc":"Construct the smallest measure space containing a collection of basic sets ","depth":8},{"term":"fun {α} s =>\n  { Has := MeasurableSpace.DynkinSystem.GenerateHas s, has_empty := (_ : MeasurableSpace.DynkinSystem.GenerateHas s ∅),\n    has_compl :=\n      (_ : ∀ {x : Set α}, MeasurableSpace.DynkinSystem.GenerateHas s x → MeasurableSpace.DynkinSystem.GenerateHas s xᶜ),\n    has_iUnion_nat :=\n      (_ :\n        ∀ {x : ℕ → Set α},\n          Pairwise (Disjoint on x) →\n            (∀ (i : ℕ), MeasurableSpace.DynkinSystem.GenerateHas s (x i)) →\n              MeasurableSpace.DynkinSystem.GenerateHas s (⋃ (i : ℕ), x i)) }","name":"MeasurableSpace.DynkinSystem.generate","doc":"The least Dynkin system containing a collection of basic sets. ","depth":8},{"term":"fun {α} [Bornology α] s => Bornology.IsCobounded sᶜ","name":"Bornology.IsBounded","doc":"`IsBounded` is the predicate that `s` is bounded relative to the ambient bornology on `α`. ","depth":9},{"term":"{ pure := fun {α} a => Ultrafilter.ofComplNotMemIff (pure a) (_ : ∀ (s : Set α), ¬sᶜ ∈ pure a ↔ s ∈ pure a) }","name":"Ultrafilter.instPureUltrafilter","doc":"The principal ultrafilter associated to a point `x`. ","depth":9}],"count":712}
{"noDocExamples":[],"kind":"«term_++_»","examples":[{"term":"fun a b => a ++ b","name":"Sat.Fmla.and","doc":"A conjunction of formulas. ","depth":8},{"term":"fun uri => String.foldl (fun s c => s ++ System.Uri.UriEscape.uriEscapeAsciiChar c) \"\" uri","name":"System.Uri.escapeUri","doc":"Replaces special characters in the given Uri with %HH Uri escapings. ","depth":12},{"term":"fun {α} => { mul := Set.image2 fun x x_1 => x ++ x_1 }","name":"Language.instMulLanguage","doc":"The product of two languages `l` and `m` is the language made of the strings `x ++ y` where\n`x ∈ l` and `y ∈ m`. ","depth":12},{"term":"fun {X} [Repr X] =>\n  {\n    reprPrec := fun o x =>\n      match o with\n      | none => Std.Format.text \"∞\"\n      | some a => Std.Format.text \"↑\" ++ repr a }","name":"instReprOnePoint","doc":"The repr uses the notation from the `OnePoint` locale. ","depth":13},{"term":"{ reprPrec := fun r x => Std.Format.text \"Real.ofCauchy \" ++ repr r.cauchy }","name":"Real.instReprReal","doc":"Show an underlying cauchy sequence for real numbers.\n\nThe representative chosen is the one passed in the VM to `Quot.mk`, so two cauchy sequences\nconverging to the same number may be printed differently.\n","depth":13}],"count":698}
{"noDocExamples":[],"kind":"«term_∣_»","examples":[{"term":"fun n => Finset.filter (fun x => x ∣ n) (Finset.Ico 1 n)","name":"Nat.properDivisors","doc":"`properDivisors n` is the `Finset` of divisors of `n`, other than `n`.\nAs a special case, `properDivisors 0 = ∅`. ","depth":9},{"term":"fun n => Finset.filter (fun x => x ∣ n) (Finset.Ico 1 (n + 1))","name":"Nat.divisors","doc":"`divisors n` is the `Finset` of divisors of `n`. As a special case, `divisors 0 = ∅`. ","depth":9},{"term":"fun n => if 2 ∣ n then 2 else Nat.minFacAux n 3","name":"Nat.minFac","doc":"Returns the smallest prime factor of `n ≠ 1`. ","depth":10},{"term":"fun R [Ring R] p [CharP R p] => ZMod.algebra' R p (_ : p ∣ p)","name":"ZMod.algebra","doc":"The `zmod p`-algebra structure on a ring of characteristic `p`. This is not an\ninstance since it creates a diamond with `algebra.id`.\nSee note [reducible non-instances]. ","depth":10},{"term":"{ gcd := Nat.gcd, lcm := Nat.lcm, gcd_dvd_left := Nat.gcd_dvd_left, gcd_dvd_right := Nat.gcd_dvd_right,\n  dvd_gcd := (_ : ∀ {a b c : ℕ}, a ∣ c → a ∣ b → a ∣ Nat.gcd c b),\n  gcd_mul_lcm := instGCDMonoidNatCancelCommMonoidWithZero.proof_1, lcm_zero_left := Nat.lcm_zero_left,\n  lcm_zero_right := Nat.lcm_zero_right }","name":"instGCDMonoidNatCancelCommMonoidWithZero","doc":"`ℕ` is a gcd_monoid. ","depth":10}],"count":640}
{"noDocExamples":[],"kind":"termℂ","examples":[{"term":"unitSphereToUnits ℂ","name":"circle.toUnits","doc":"The elements of the circle embed into the units. ","depth":3},{"term":"Submonoid.unitSphere ℂ","name":"circle","doc":"The unit circle in `ℂ`, here given the structure of a submonoid of `ℂ`. ","depth":3},{"term":"Algebra.ofId ℝ ℂ","name":"Complex.ofRealAm","doc":"`ℝ`-algebra morphism version of the canonical embedding of `ℝ` in `ℂ`. ","depth":5},{"term":"fun {G} [NormedAddCommGroup G] [InnerProductSpace ℂ G] => InnerProductSpace.isROrCToReal ℂ G","name":"InnerProductSpace.complexToReal","doc":"A complex inner product implies a real inner product ","depth":8},{"term":"fun H [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] self => self.2","name":"VonNeumannAlgebra.centralizer_centralizer'","doc":"The double commutant (a.k.a. centralizer) of a `VonNeumannAlgebra` is itself. ","depth":9}],"count":562}
{"noDocExamples":[],"kind":"«term_\\_»","examples":[{"term":"fun {α} [TopologicalSpace α] s => closure s \\ interior s","name":"frontier","doc":"The frontier of a set is the set of points between the closure and interior. ","depth":8},{"term":"fun {α} {m0} s =>\n  MeasureTheory.Measure.liftLinear (MeasureTheory.OuterMeasure.restrict s)\n    (_ :\n      ∀ (μ : MeasureTheory.Measure α) (s' : Set α),\n        MeasurableSet s' →\n          ∀ (t : Set α),\n            ↑(↑(MeasureTheory.OuterMeasure.restrict s) ↑μ) t =\n              ↑(↑(MeasureTheory.OuterMeasure.restrict s) ↑μ) (t ∩ s') +\n                ↑(↑(MeasureTheory.OuterMeasure.restrict s) ↑μ) (t \\ s'))","name":"MeasureTheory.Measure.restrictₗ","doc":"Restrict a measure `μ` to a set `s` as an `ℝ≥0∞`-linear map. ","depth":9},{"term":"fun α [CoheytingAlgebra α] =>\n  let src := TopHom.id α;\n  { toLatticeHom := LatticeHom.id α, map_top' := (_ : TopHom.toFun (TopHom.id α) ⊤ = ⊤),\n    map_sdiff' :=\n      (_ :\n        ∀ (x x_1 : α),\n          SupHom.toFun (LatticeHom.id α).toSupHom (x \\ x_1) = SupHom.toFun (LatticeHom.id α).toSupHom (x \\ x_1)) }","name":"CoheytingHom.id","doc":"`id` as a `CoheytingHom`. ","depth":10},{"term":"fun {V} {G} G' s => SimpleGraph.Subgraph.induce G' (G'.verts \\ s)","name":"SimpleGraph.Subgraph.deleteVerts","doc":"Given a subgraph and a set of vertices, delete all the vertices from the subgraph,\nif present. Any edges incident to the deleted vertices are deleted as well. ","depth":10},{"term":"fun {α} m =>\n  { Has := MeasureTheory.OuterMeasure.IsCaratheodory m,\n    has_empty := (_ : MeasureTheory.OuterMeasure.IsCaratheodory m ∅),\n    has_compl :=\n      (_ :\n        ∀ {a : Set α}, MeasureTheory.OuterMeasure.IsCaratheodory m a → MeasureTheory.OuterMeasure.IsCaratheodory m aᶜ),\n    has_iUnion_nat :=\n      (_ :\n        ∀ {f : ℕ → Set α},\n          Pairwise (Disjoint on f) →\n            (∀ (i : ℕ), MeasureTheory.OuterMeasure.IsCaratheodory m (f i)) →\n              ∀ (hn : Set α), ↑m hn = ↑m (hn ∩ ⋃ (i : ℕ), f i) + ↑m (hn \\ ⋃ (i : ℕ), f i)) }","name":"MeasureTheory.OuterMeasure.caratheodoryDynkin","doc":"The Carathéodory-measurable sets for an outer measure `m` form a Dynkin system.  ","depth":10}],"count":549}
{"noDocExamples":[],"kind":"Set.«term⋃_,_»","examples":[{"term":"fun {α} s =>\n  { MeasurableSet' := MeasurableSpace.GenerateMeasurable s,\n    measurableSet_empty := (_ : MeasurableSpace.GenerateMeasurable s ∅),\n    measurableSet_compl :=\n      (_ : ∀ (t : Set α), MeasurableSpace.GenerateMeasurable s t → MeasurableSpace.GenerateMeasurable s tᶜ),\n    measurableSet_iUnion :=\n      (_ :\n        ∀ (f : ℕ → Set α),\n          (∀ (n : ℕ), MeasurableSpace.GenerateMeasurable s (f n)) →\n            MeasurableSpace.GenerateMeasurable s (⋃ (i : ℕ), f i)) }","name":"MeasurableSpace.generateFrom","doc":"Construct the smallest measure space containing a collection of basic sets ","depth":8},{"term":"fun {α} s =>\n  { Has := MeasurableSpace.DynkinSystem.GenerateHas s, has_empty := (_ : MeasurableSpace.DynkinSystem.GenerateHas s ∅),\n    has_compl :=\n      (_ : ∀ {x : Set α}, MeasurableSpace.DynkinSystem.GenerateHas s x → MeasurableSpace.DynkinSystem.GenerateHas s xᶜ),\n    has_iUnion_nat :=\n      (_ :\n        ∀ {x : ℕ → Set α},\n          Pairwise (Disjoint on x) →\n            (∀ (i : ℕ), MeasurableSpace.DynkinSystem.GenerateHas s (x i)) →\n              MeasurableSpace.DynkinSystem.GenerateHas s (⋃ (i : ℕ), x i)) }","name":"MeasurableSpace.DynkinSystem.generate","doc":"The least Dynkin system containing a collection of basic sets. ","depth":8},{"term":"fun {α} m =>\n  { Has := MeasureTheory.OuterMeasure.IsCaratheodory m,\n    has_empty := (_ : MeasureTheory.OuterMeasure.IsCaratheodory m ∅),\n    has_compl :=\n      (_ :\n        ∀ {a : Set α}, MeasureTheory.OuterMeasure.IsCaratheodory m a → MeasureTheory.OuterMeasure.IsCaratheodory m aᶜ),\n    has_iUnion_nat :=\n      (_ :\n        ∀ {f : ℕ → Set α},\n          Pairwise (Disjoint on f) →\n            (∀ (i : ℕ), MeasureTheory.OuterMeasure.IsCaratheodory m (f i)) →\n              ∀ (hn : Set α), ↑m hn = ↑m (hn ∩ ⋃ (i : ℕ), f i) + ↑m (hn \\ ⋃ (i : ℕ), f i)) }","name":"MeasureTheory.OuterMeasure.caratheodoryDynkin","doc":"The Carathéodory-measurable sets for an outer measure `m` form a Dynkin system.  ","depth":10},{"term":"fun {α} m p h =>\n  { MeasurableSet' := p, measurableSet_empty := (_ : p ∅), measurableSet_compl := (_ : ∀ (s : Set α), p s → p sᶜ),\n    measurableSet_iUnion := (_ : ∀ (f : ℕ → Set α), (∀ (i : ℕ), p (f i)) → p (⋃ (i : ℕ), f i)) }","name":"MeasurableSpace.copy","doc":"Copy of a `MeasurableSpace` with a new `MeasurableSet` equal to the old one. Useful to fix\ndefinitional equalities. ","depth":11},{"term":"fun {α} {x} μ =>\n  { toOuterMeasure := ↑μ,\n    m_iUnion :=\n      (_ :\n        ∀ (s : ℕ → Set (MeasureTheory.NullMeasurableSpace α)),\n          (∀ (i : ℕ), MeasurableSet (s i)) → Pairwise (Disjoint on s) → ↑↑μ (⋃ (i : ℕ), s i) = ∑' (i : ℕ), ↑↑μ (s i)),\n    trimmed := (_ : MeasureTheory.OuterMeasure.trim ↑μ = ↑μ) }","name":"MeasureTheory.Measure.completion","doc":"Given a measure we can complete it to a (complete) measure on all null measurable sets. ","depth":11}],"count":531}
{"noDocExamples":[],"kind":"Lean.Parser.Term.do","examples":[{"term":"fun prf => do\n  let __do_lift ← Linarith.leftOfIneqProof prf\n  Lean.Meta.inferType __do_lift","name":"Linarith.typeOfIneqProof","doc":"If `prf` is a proof of `t R s`, `typeOfIneqProof prf` returns the type of `t`. ","depth":8},{"term":"fun e => do\n  let __do_lift ← Lean.Meta.inferType e\n  let __do_lift ← Lean.instantiateMVars __do_lift\n  Linarith.rearrangeComparison.aux e __do_lift","name":"Linarith.rearrangeComparison","doc":"`rearrangeComparison e` takes a proof `e` of an equality, inequality, or negation thereof,\nand turns it into a proof of a comparison `_ R 0`, where `R ∈ {=, ≤, <}`.\n ","depth":10},{"term":"fun f =>\n  MLList.squash fun x => do\n    let __do_lift ← IO.FS.Handle.mk f IO.FS.Mode.read\n    pure (MLList.linesFromHandle __do_lift)","name":"MLList.lines","doc":"Read lines of text from a file, as a lazy list in `IO`. ","depth":11},{"term":"fun e =>\n  Lean.Meta.mapForallTelescope\n    (fun e => do\n      let __do_lift ← Lean.Meta.mkAppM `CategoryTheory.eq_whisker' #[e]\n      Lean.Meta.simpType CategoryTheory.categorySimp __do_lift)\n    e","name":"CategoryTheory.reassocExpr","doc":"Given an equation `f = g` between morphisms `X ⟶ Y` in a category (possibly after a `∀` binder),\nproduce the equation `∀ {Z} (h : Y ⟶ Z), f ≫ h = g ≫ h`,\nbut with compositions fully right associated and identities removed.\n","depth":11},{"term":"do\n  let __do_lift ← read\n  pure __do_lift.initHeartbeats","name":"getInitHeartbeats","doc":"Return the current `initHeartbeats`. ","depth":11}],"count":516}
{"noDocExamples":[],"kind":"«term_%_»","examples":[{"term":"fun u => (u.ap + 1) % (u.bp + 1)","name":"PNat.XgcdType.r","doc":"`r = a % b`: remainder ","depth":9},{"term":"fun m n => Int.toNat (m % n)","name":"Int.natMod","doc":"The modulus of an integer by another as a natural. Uses the E-rounding convention. ","depth":9},{"term":"fun m k => PNat.modDivAux k (↑m % ↑k) (↑m / ↑k)","name":"PNat.modDiv","doc":"`mod_div m k = (m % k, m / k)`.\nWe define `m % k` and `m / k` in the same way as for `ℕ`\nexcept that when `m = n * k` we take `m % k = k` and\n`m / k = n - 1`.  This ensures that `m % k` is always positive\nand `m = (m % k) + k * (m / k)` in all cases.  Later we\ndefine a function `div_exact` which gives the usual `m / k`\nin the case where `k` divides `m`.\n","depth":10},{"term":"fun p r => r.num * Nat.gcdA r.den p % ↑p","name":"PadicInt.modPart","doc":"`modPart p r` is an integer that satisfies\n`‖(r - modPart p r : ℚ_[p])‖ < 1` when `‖(r : ℚ_[p])‖ ≤ 1`,\nsee `PadicInt.norm_sub_modPart`.\nIt is the unique non-negative integer that is `< p` with this property.\n\n(Note that this definition assumes `r : ℚ`.\nSee `PadicInt.zmodRepr` for a version that takes values in `ℕ`\nand works for arbitrary `x : ℤ_[p]`.) ","depth":10},{"term":"fun n a b => a % n = b % n","name":"Nat.ModEq","doc":"Modular equality. `n.ModEq a b`, or `a ≡ b [MOD n]`, means that `a - b` is a multiple of `n`. ","depth":11}],"count":510}
{"noDocExamples":[],"kind":"«term_+ᵥ_»","examples":[{"term":"fun {α} {β} [AddMonoid α] [AddAction α β] =>\n  AddAction.mk (_ : ∀ (s : Set β), Set.image2 (fun x x_1 => x +ᵥ x_1) {0} s = s)\n    (_ :\n      ∀ (x x_1 : Set α) (x_2 : Set β),\n        Set.image2 (fun x x_3 => x +ᵥ x_3) (Set.image2 (fun x x_3 => x + x_3) x x_1) x_2 =\n          Set.image2 (fun x x_3 => x +ᵥ x_3) x (Set.image2 (fun x x_3 => x +ᵥ x_3) x_1 x_2))","name":"Set.addAction","doc":"An additive action of an additive monoid `α` on a type `β` gives an additive action of\n`Set α` on `Set β`","depth":12},{"term":"fun {α} {β} [AddMonoid α] [AddAction α β] =>\n  AddAction.mk (_ : ∀ (f : Filter β), Filter.map (fun x => 0 +ᵥ x) f = f)\n    (_ :\n      ∀ (a b : α) (f : Filter β),\n        Filter.map (fun b_1 => a + b +ᵥ b_1) f = Filter.map (fun b => a +ᵥ b) (Filter.map (fun b_1 => b +ᵥ b_1) f))","name":"Filter.addActionFilter","doc":"An additive action of an additive monoid on a type `β` gives an additive action on\n`Filter β`.","depth":12},{"term":"fun {α} {β} [AddMonoid α] [AddAction α β] =>\n  AddAction.mk (_ : ∀ (f : Filter β), Filter.map₂ (fun x x_1 => x +ᵥ x_1) (pure 0) f = f)\n    (_ :\n      ∀ (f g : Filter α) (h : Filter β),\n        Filter.map₂ (fun x x_1 => x +ᵥ x_1) (Filter.map₂ (fun x x_1 => x + x_1) f g) h =\n          Filter.map₂ (fun x x_1 => x +ᵥ x_1) f (Filter.map₂ (fun x x_1 => x +ᵥ x_1) g h))","name":"Filter.addAction","doc":"An additive action of an additive monoid `α` on a type `β` gives an additive action\nof `Filter α` on `Filter β`","depth":12},{"term":"fun {α} {β} [AddMonoid α] [AddAction α β] =>\n  AddAction.mk (_ : ∀ (b : Set β), (fun x => 0 +ᵥ x) '' b = b)\n    (_ : ∀ (x y : α) (b : Set β), (fun x_1 => x + y +ᵥ x_1) '' b = (fun x_1 => x +ᵥ x_1) '' ((fun x => y +ᵥ x) '' b))","name":"Set.addActionSet","doc":"An additive action of an additive monoid on a type `β` gives an additive action on `Set β`.","depth":12},{"term":"fun {α} {β} [VAdd α β] => { vadd := fun a => Set.image fun x => a +ᵥ x }","name":"Set.vaddSet","doc":"The translation of set `x +ᵥ s` is defined as `{x +ᵥ y | y ∈ s}` in\nlocale `Pointwise`.","depth":13}],"count":484}
{"noDocExamples":[],"kind":"«term⨆_,_»","examples":[{"term":"fun {ι} {α} f => ⨆ (i : ι), Filter.comap (Function.eval i) (f i)","name":"Filter.coprodᵢ","doc":"Coproduct of filters. ","depth":11},{"term":"fun {α} [LT α] s => ⨆ (l : List α) (_ : l ∈ Set.subchain s), ↑(List.length l)","name":"Set.chainHeight","doc":"The maximal length of a strictly ascending sequence in a partial order. ","depth":13},{"term":"fun α [Preorder α] => ⨆ (p : StrictSeries α), ↑p.length","name":"krullDim","doc":"Krull dimension of a preordered set `α` is the supremum of the right most index of all strict\nseries of `α`. If there is no strict series `a₀ < a₁ < ... < aₙ` in `α`, then its Krull dimension\nis defined to be negative infinity; if the length of `a₀ < a₁ < ... < aₙ` is unbounded, its Krull\ndimension is defined to be positive infinity.\n","depth":13},{"term":"fun {X} [TopologicalSpace X] [NormalSpace X] c x => ⨆ (n : ℕ), Urysohns.CU.approx n c x","name":"Urysohns.CU.lim","doc":"A continuous function `f : X → ℝ` such that\n\n* `0 ≤ f x ≤ 1` for all `x`;\n* `f` equals zero on `c.C` and equals one outside of `c.U`;\n","depth":13},{"term":"fun {α} m =>\n  MeasureTheory.OuterMeasure.ofFunction (fun s => ⨆ (_ : Set.Nonempty s), m s) (_ : ⨆ (_ : Set.Nonempty ∅), m ∅ = 0)","name":"MeasureTheory.OuterMeasure.boundedBy","doc":"Given any function `m` assigning measures to sets, there is a unique maximal outer measure `μ`\nsatisfying `μ s ≤ m s` for all `s : Set α`. This is the same as `OuterMeasure.ofFunction`,\nexcept that it doesn't require `m ∅ = 0`. ","depth":13}],"count":447}
{"noDocExamples":[],"kind":"«term|___|»","examples":[{"term":"fun x => { val := |x|, property := (_ : 0 ≤ |x|) }","name":"Rat.nnabs","doc":"The absolute value on `ℚ` as a map to `ℚ≥0`. ","depth":10},{"term":"fun x =>\n  match x with\n  | none => ⊤\n  | some none => ⊤\n  | some (some x) => ENNReal.ofReal |x|","name":"EReal.abs","doc":"The absolute value from `EReal` to `ℝ≥0∞`, mapping `⊥` and `⊤` to `⊤` and\na real `x` to `|x|`. ","depth":10},{"term":"let src := AbsoluteValue.abs_isEuclidean;\n{ toIsEuclidean := AbsoluteValue.absIsAdmissible.proof_1, card := fun ε => ⌈1 / ε⌉₊,\n  exists_partition' :=\n    (_ :\n      ∀ (n : ℕ) (x : ℝ),\n        0 < x →\n          ∀ (x_1 : ℤ),\n            x_1 ≠ 0 → ∀ (A : Fin n → ℤ), ∃ t, ∀ (i₀ i₁ : Fin n), t i₀ = t i₁ → ↑|A i₁ % x_1 - A i₀ % x_1| < |x_1| • x) }","name":"AbsoluteValue.absIsAdmissible","doc":"`abs : ℤ → ℤ` is an admissible absolute value. ","depth":15},{"term":"{ toZeroHom := { toFun := fun x => { val := |x|, property := (_ : 0 ≤ |x|) }, map_zero' := Real.nnabs.proof_2 },\n  map_one' := Real.nnabs.proof_3, map_mul' := Real.nnabs.proof_4 }","name":"Real.nnabs","doc":"The absolute value on `ℝ` as a map to `ℝ≥0`. ","depth":15},{"term":"fun {K} [IsROrC K] => { toLinearMap := AlgHom.toLinearMap IsROrC.ofRealAm, norm_map' := (_ : ∀ (r : ℝ), ‖↑r‖ = |r|) }","name":"IsROrC.ofRealLi","doc":"The ℝ → K coercion, as a linear isometry ","depth":15}],"count":438}
{"noDocExamples":[],"kind":"«term⨅_,_»","examples":[{"term":"fun {α} [Preorder α] => ⨅ (a : α), Filter.principal (Set.Ici a)","name":"Filter.atTop","doc":"`atTop` is the filter representing the limit `→ ∞` on an ordered set.\nIt is generated by the collection of up-sets `{b | a ≤ b}`.\n(The preorder need not have a top element for this to be well defined,\nand indeed is trivial when a top element exists.) ","depth":9},{"term":"fun {α} [Preorder α] => ⨅ (a : α), Filter.principal (Set.Iic a)","name":"Filter.atBot","doc":"`atBot` is the filter representing the limit `→ -∞` on an ordered set.\nIt is generated by the collection of down-sets `{b | b ≤ a}`.\n(The preorder need not have a bottom element for this to be well defined,\nand indeed is trivial when a bottom element exists.) ","depth":9},{"term":"fun {ι} {α} f => ⨅ (i : ι), Filter.comap (Function.eval i) (f i)","name":"Filter.pi","doc":"The product of an indexed family of filters. ","depth":11},{"term":"fun α [TopologicalSpace α] => ⨅ (s : Set α) (_ : IsCompact s), Filter.principal sᶜ","name":"Filter.cocompact","doc":"`Filter.cocompact` is the filter generated by complements to compact sets. ","depth":12},{"term":"fun {α} {P} m s => ⨅ (h : P s), m s h","name":"MeasureTheory.extend","doc":"We can trivially extend a function defined on a subclass of objects (with codomain `ℝ≥0∞`)\nto all objects by defining it to be `∞` on the objects not in the class. ","depth":12}],"count":395}
{"noDocExamples":[],"kind":"«term_ᵐᵒᵖ»","examples":[{"term":"fun M => Mᵐᵒᵖ","name":"DomMulAct","doc":"If `M` multiplicatively acts on `α`, then `DomMulAct M` acts on `α → β` as well as some\nbundled maps from `α`. This is a type synonym for `MulOpposite M`, so this corresponds to a right\naction of `M`. ","depth":2},{"term":"fun α => (CategoryTheory.End α)ᵐᵒᵖ","name":"Monoid.Foldl","doc":"For a list, foldl f x [y₀,y₁] reduces as follows:\n\n```\ncalc  foldl f x [y₀,y₁]\n    = foldl f (f x y₀) [y₁]      : rfl\n... = foldl f (f (f x y₀) y₁) [] : rfl\n... = f (f x y₀) y₁              : rfl\n```\nwith\n```\nf : α → β → α\nx : α\n[y₀,y₁] : List β\n```\n\nWe can view the above as a composition of functions:\n```\n... = f (f x y₀) y₁              : rfl\n... = flip f y₁ (flip f y₀ x)    : rfl\n... = (flip f y₁ ∘ flip f y₀) x  : rfl\n```\n\nWe can use traverse and const to construct this composition:\n```\ncalc   const.run (traverse (λ y, const.mk' (flip f y)) [y₀,y₁]) x\n     = const.run ((::) <$> const.mk' (flip f y₀) <*> traverse (λ y, const.mk' (flip f y)) [y₁]) x\n...  = const.run ((::) <$> const.mk' (flip f y₀) <*>\n         ( (::) <$> const.mk' (flip f y₁) <*> traverse (λ y, const.mk' (flip f y)) [] )) x\n...  = const.run ((::) <$> const.mk' (flip f y₀) <*>\n         ( (::) <$> const.mk' (flip f y₁) <*> pure [] )) x\n...  = const.run ( ((::) <$> const.mk' (flip f y₁) <*> pure []) ∘\n         ((::) <$> const.mk' (flip f y₀)) ) x\n...  = const.run ( const.mk' (flip f y₁) ∘ const.mk' (flip f y₀) ) x\n...  = const.run ( flip f y₁ ∘ flip f y₀ ) x\n...  = f (f x y₀) y₁\n```\n\nAnd this is how `const` turns a monoid into an applicative functor and\nhow the monoid of endofunctions define `Foldl`.\n","depth":6},{"term":"fun {α} =>\n  { toFun := MulOpposite.op, invFun := MulOpposite.unop,\n    left_inv := (_ : ∀ (x : α), MulOpposite.unop (MulOpposite.op x) = x),\n    right_inv := (_ : ∀ (x : αᵐᵒᵖ), MulOpposite.op (MulOpposite.unop x) = x) }","name":"MulOpposite.opEquiv","doc":"The canonical bijection between `α` and `αᵐᵒᵖ`. ","depth":7},{"term":"fun M α [SMul M α] [SMul Mᵐᵒᵖ α] [self : IsCentralScalar M α] => self.1","name":"IsCentralScalar.op_smul_eq_smul","doc":"The right and left actions of `M` on `α` are equal. ","depth":9},{"term":"fun {G} [Group G] [PseudoEMetricSpace G] [IsometricSMul Gᵐᵒᵖ G] c =>\n  { toEquiv := Equiv.divRight c, isometry_toFun := (_ : ∀ (a b : G), edist (a / c) (b / c) = edist a b) }","name":"IsometryEquiv.divRight","doc":"Division `y ↦ y / x` as an `IsometryEquiv`. ","depth":11}],"count":391}
{"noDocExamples":[],"kind":"«term_ᵒᵖ»","examples":[{"term":"FrmCatᵒᵖ","name":"Locale","doc":"The category of locales. ","depth":1},{"term":"fun {α} =>\n  { toFun := Opposite.op, invFun := Opposite.unop, left_inv := (_ : ∀ (x : α), (Opposite.op x).unop = x),\n    right_inv := (_ : ∀ (x : αᵒᵖ), Opposite.op x.unop = x) }","name":"Opposite.equivToOpposite","doc":"The type-level equivalence between a type and its opposite. ","depth":7},{"term":"fun C [CategoryTheory.Category.{v, u} C] => CategoryTheory.Functor SimplexCategoryᵒᵖ C","name":"CategoryTheory.SimplicialObject","doc":"The category of simplicial objects valued in a category `C`.\nThis is the category of contravariant functors from `SimplexCategory` to `C`. ","depth":7},{"term":"fun C [CategoryTheory.Category.{v, u} C] => CategoryTheory.Functor.const SimplexCategoryᵒᵖ","name":"CategoryTheory.SimplicialObject.const","doc":"The constant simplicial object is the constant functor. ","depth":7},{"term":"fun {α} =>\n  { toFun := Set.op, invFun := Set.unop, left_inv := (_ : ∀ (s : Set α), Set.unop (Set.op s) = s),\n    right_inv := (_ : ∀ (s : Set αᵒᵖ), Set.op (Set.unop s) = s) }","name":"Set.opEquiv","doc":"Taking opposites as an equivalence of powersets. ","depth":8}],"count":390}
{"noDocExamples":[],"kind":"«term_×ˢ_»","examples":[{"term":"fun {α} [DecidableEq α] s => Finset.filter (fun a => a.fst = a.snd) (s ×ˢ s)","name":"Finset.diag","doc":"Given a finite set `s`, the diagonal, `s.diag` is the set of pairs of the form `(a, a)` for\n`a ∈ s`. ","depth":12},{"term":"fun a b => Finset.map { toFun := fun x => Tree.node () x.fst x.snd, inj' := Tree.pairwiseNode.proof_1 } (a ×ˢ b)","name":"Tree.pairwiseNode","doc":"Given two finsets, find all trees that can be formed with\nleft child in `a` and right child in `b` ","depth":13},{"term":"fun {α} [UniformSpace α] f => Filter.NeBot f ∧ f ×ˢ f ≤ uniformity α","name":"Cauchy","doc":"A filter `f` is Cauchy if for every entourage `r`, there exists an\n`s ∈ f` such that `s × s ⊆ r`. This is a generalization of Cauchy\nsequences, because if `a : ℕ → α` then the filter of sets containing\ncofinitely many of the `a n` is Cauchy iff `a` is a Cauchy sequence. ","depth":13},{"term":"fun {α} [DecidableEq α] s => Finset.filter (fun a => a.fst ≠ a.snd) (s ×ˢ s)","name":"Finset.offDiag","doc":"Given a finite set `s`, the off-diagonal, `s.offDiag` is the set of pairs `(a, b)` with `a ≠ b`\nfor `a, b ∈ s`. ","depth":13},{"term":"fun {α} {β} s t => { val := s.val ×ˢ t.val, nodup := (_ : Multiset.Nodup (s.val ×ˢ t.val)) }","name":"Finset.product","doc":"`product s t` is the set of pairs `(a, b)` such that `a ∈ s` and `b ∈ t`. ","depth":13}],"count":369}
{"noDocExamples":[],"kind":"Lean.Parser.Term.inaccessible","examples":[{"term":"fun {n} x x_1 =>\n  match x, x_1 with\n  | .(PSet.Resp.eval n f), PSet.Definable.mk f => f","name":"PSet.Definable.Resp","doc":"Turns a definable function into a function that respects equivalence. ","depth":11},{"term":"fun {n} f x x_1 =>\n  match x, x_1 with\n  | .(PSet.Resp.eval n f), (_ : PSet.Resp.eval n f = PSet.Resp.eval n f) => PSet.Definable.mk f","name":"PSet.Definable.EqMk","doc":"The evaluation of a function respecting equivalence is definable, by that same function. ","depth":15},{"term":"fun {α} {n} x x_1 x_2 =>\n  match x, x_1, x_2 with\n  | { val := val, property := property }, { val := .(val), property := property_1 },\n    Eq.refl (Vector.toList { val := .(val), property := .(property) }) => rfl","name":"Vector.eq","doc":"Vector is determined by the underlying list. ","depth":18},{"term":"fun J x x_1 x_2 =>\n  match x, x_1, x_2 with\n  | X, .(X), CategoryTheory.Limits.WidePushoutShape.Hom.id .(X) => (CategoryTheory.Limits.WidePullbackShape.Hom.id X).op\n  | .(none), .(some j), CategoryTheory.Limits.WidePushoutShape.Hom.init j =>\n    (CategoryTheory.Limits.WidePullbackShape.Hom.term j).op","name":"CategoryTheory.Limits.widePushoutShapeOpMap","doc":"The action on morphisms of the obvious functor\n`widePushoutShapeOp : WidePushoutShape J ⥤ (WidePullbackShape J)ᵒᵖ` ","depth":20},{"term":"fun J x x_1 x_2 =>\n  match x, x_1, x_2 with\n  | X, .(X), CategoryTheory.Limits.WidePullbackShape.Hom.id .(X) => (CategoryTheory.Limits.WidePushoutShape.Hom.id X).op\n  | .(some j), .(none), CategoryTheory.Limits.WidePullbackShape.Hom.term j =>\n    (CategoryTheory.Limits.WidePushoutShape.Hom.init j).op","name":"CategoryTheory.Limits.widePullbackShapeOpMap","doc":"The action on morphisms of the obvious functor\n`WidePullbackShape_op : WidePullbackShape J ⥤ (WidePushoutShape J)ᵒᵖ`","depth":20}],"count":363}
{"noDocExamples":[],"kind":"«term_-ᵥ_»","examples":[{"term":"fun {α} {β} [VSub α β] [DecidableEq α] => { vsub := Finset.image₂ fun x x_1 => x -ᵥ x_1 }","name":"Finset.vsub","doc":"The pointwise product of two finsets `s` and `t`: `s -ᵥ t = {x -ᵥ y | x ∈ s, y ∈ t}`. ","depth":13},{"term":"fun {k} {V} [Ring k] [AddCommGroup V] [Module k V] p =>\n  { carrier := ↑p,\n    smul_vsub_vadd_mem :=\n      (_ : ∀ (x : k) (x_1 x_2 x_3 : V), x_1 ∈ ↑p → x_2 ∈ ↑p → x_3 ∈ ↑p → x • (x_1 -ᵥ x_2) + x_3 ∈ p) }","name":"Submodule.toAffineSubspace","doc":"Reinterpret `p : Submodule k V` as an `AffineSubspace k V`. ","depth":17},{"term":"fun k {V} {P} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] s => Submodule.span k (s -ᵥ s)","name":"vectorSpan","doc":"The submodule spanning the differences of a (possibly empty) set of points. ","depth":17},{"term":"fun k {V} {P} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] s =>\n  { carrier := spanPoints k s,\n    smul_vsub_vadd_mem :=\n      (_ :\n        ∀ (c : k) (x x_1 x_2 : P),\n          x ∈ spanPoints k s → x_1 ∈ spanPoints k s → x_2 ∈ spanPoints k s → c • (x -ᵥ x_1) +ᵥ x_2 ∈ spanPoints k s) }","name":"affineSpan","doc":"The affine span of a set of points is the smallest affine subspace containing those points.\n(Actually defined here in terms of spans in modules.) ","depth":18},{"term":"fun {G} {P} [AddGroup G] [AddTorsor G P] p =>\n  { toFun := (fun x x_1 => x -ᵥ x_1) p, invFun := fun v => -v +ᵥ p, left_inv := (_ : ∀ (p' : P), -(p -ᵥ p') +ᵥ p = p'),\n    right_inv := (_ : ∀ (v : G), p -ᵥ (-v +ᵥ p) = v) }","name":"Equiv.constVSub","doc":"`p' ↦ p -ᵥ p'` as an equivalence. ","depth":19}],"count":261}
{"noDocExamples":[],"kind":"«term#[_,]»","examples":[{"term":"fun {α} lt => { arr := #[] }","name":"BinaryHeap.empty","doc":"`O(1)`. Build a new empty heap. ","depth":5},{"term":"fun e => Lean.Meta.mkAppM `Int.coe_nat_nonneg #[e]","name":"Linarith.mk_coe_nat_nonneg_prf","doc":"If `e : ℕ`, returns a proof of `0 ≤ (e : ℤ)`. ","depth":6},{"term":"fun {α} l => List.tailsTR.go l #[]","name":"List.tailsTR","doc":"Tail-recursive version of `tails`. ","depth":6},{"term":"fun {α} as as' => List.fillNonesTR.go as as' #[]","name":"List.fillNonesTR","doc":"Tail-recursive version of `fillNones`. ","depth":7},{"term":"fun {α} f l => List.replaceFTR.go f l #[]","name":"List.replaceFTR","doc":"Tail-recursive version of `replaceF`. ","depth":7}],"count":260}
{"noDocExamples":[],"kind":"«term∑'_,_»","examples":[{"term":"fun c f => ∑' (n : ℕ), Cardinal.cantorFunctionAux c f n","name":"Cardinal.cantorFunction","doc":"`cantorFunction c (f : ℕ → Bool)` is `Σ n, f n * c ^ n`, where `true` is interpreted as `1` and\n`false` is interpreted as `0`. It is implemented using `cantorFunctionAux`. ","depth":8},{"term":"fun m => ∑' (i : ℕ), 1 / m ^ Nat.factorial i","name":"liouvilleNumber","doc":"For a real number `m`, Liouville's constant is\n$$\n\\sum_{i=0}^\\infty\\frac{1}{m^{i!}}.\n$$\nThe series converges only for `1 < m`. However, there is no restriction on `m`, since,\nif the series does not converge, then the sum of the series is defined to be zero.\n","depth":10},{"term":"fun {α} {x} μ =>\n  { toOuterMeasure := ↑μ,\n    m_iUnion :=\n      (_ :\n        ∀ (s : ℕ → Set (MeasureTheory.NullMeasurableSpace α)),\n          (∀ (i : ℕ), MeasurableSet (s i)) → Pairwise (Disjoint on s) → ↑↑μ (⋃ (i : ℕ), s i) = ∑' (i : ℕ), ↑↑μ (s i)),\n    trimmed := (_ : MeasureTheory.OuterMeasure.trim ↑μ = ↑μ) }","name":"MeasureTheory.Measure.completion","doc":"Given a measure we can complete it to a (complete) measure on all null measurable sets. ","depth":11},{"term":"fun {α} [MeasurableSpace α] m h =>\n  MeasureTheory.Measure.ofMeasurable (fun s x => ↑m s) (_ : ↑m ∅ = 0)\n    (_ :\n      ∀ (_f : ℕ → Set α),\n        (∀ (i : ℕ), MeasurableSet (_f i)) → Pairwise (Disjoint on _f) → ↑m (⋃ (i : ℕ), _f i) = ∑' (i : ℕ), ↑m (_f i))","name":"MeasureTheory.OuterMeasure.toMeasure","doc":"Obtain a measure by giving an outer measure where all sets in the σ-algebra are\nCarathéodory measurable. ","depth":12},{"term":"fun {α} a =>\n  { measureOf := fun s => Set.indicator s (fun x => 1) a, empty := (_ : Set.indicator ∅ (fun x => 1) a = 0),\n    mono := (_ : ∀ {s t : Set α}, s ⊆ t → Set.indicator s (fun x => 1) a ≤ Set.indicator t (fun x => 1) a),\n    iUnion_nat :=\n      (_ :\n        ∀ (s : ℕ → Set α),\n          (fun s => Set.indicator s (fun x => 1) a) (⋃ (i : ℕ), s i) ≤\n            ∑' (i : ℕ), (fun s => Set.indicator s (fun x => 1) a) (s i)) }","name":"MeasureTheory.OuterMeasure.dirac","doc":"The dirac outer measure. ","depth":14}],"count":256}
{"noDocExamples":[],"kind":"Set.«term⋂_,_»","examples":[{"term":"fun {α} f => ⋂ (s : Set α) (_ : s ∈ f), s","name":"Filter.ker","doc":"The *kernel* of a filter is the intersection of all its sets. ","depth":12},{"term":"fun 𝕜 {E} [SeminormedRing 𝕜] [SMul 𝕜 E] s => ⋂ (r : 𝕜) (_ : 1 ≤ ‖r‖), r • s","name":"balancedCoreAux","doc":"Helper definition to prove `balanced_core_eq_iInter`","depth":16},{"term":"fun {τ} {α} {β} [TopologicalSpace β] f ϕ s => ⋂ (u : Set τ) (_ : u ∈ f), closure (Set.image2 ϕ u s)","name":"omegaLimit","doc":"The ω-limit of a set `s` under `ϕ` with respect to a filter `f` is\n⋂ u ∈ f, cl (ϕ u s). ","depth":18},{"term":"fun {J} [CategoryTheory.Category.{u_1, u} J] F j => ⋂ (i : J) (f : i ⟶ j), Set.range (F.map f)","name":"CategoryTheory.Functor.eventualRange","doc":"The eventual range of the functor `F : J ⥤ Type v` at index `j : J` is the intersection\nof the ranges of all maps `F.map f` with `i : J` and `f : i ⟶ j`. ","depth":19},{"term":"fun {G} [Group G] [TopologicalSpace G] [TopologicalGroup G] K₀ K =>\n  Classical.choose\n    (_ :\n      Set.Nonempty\n        (MeasureTheory.Measure.haar.haarProduct ↑K₀ ∩\n          ⋂ (V : TopologicalSpace.OpenNhdsOf 1), MeasureTheory.Measure.haar.clPrehaar (↑K₀) V))\n    K","name":"MeasureTheory.Measure.haar.chaar","doc":"This is the \"limit\" of `prehaar K₀ U K` as `U` becomes a smaller and smaller open\nneighborhood of `(1 : G)`. More precisely, it is defined to be an arbitrary element\nin the intersection of all the sets `clPrehaar K₀ V` in `haarProduct K₀`.\nThis is roughly equal to the Haar measure on compact sets,\nbut it can differ slightly. We do know that\n`haarMeasure K₀ (interior K) ≤ chaar K₀ K ≤ haarMeasure K₀ K`. ","depth":22}],"count":236}
{"noDocExamples":[],"kind":"«term⁅_,_⁆»","examples":[{"term":"fun G [Group G] => ⁅⊤, ⊤⁆","name":"commutator","doc":"The commutator subgroup of a group G is the normal subgroup\ngenerated by the commutators [p,q]=`p*q*p⁻¹*q⁻¹`. ","depth":9},{"term":"fun {A} [Ring A] =>\n  LieRing.mk (_ : ∀ (x x_1 x_2 : A), ⁅x + x_1, x_2⁆ = ⁅x, x_2⁆ + ⁅x_1, x_2⁆)\n    (_ : ∀ (x x_1 x_2 : A), ⁅x, x_1 + x_2⁆ = ⁅x, x_1⁆ + ⁅x, x_2⁆) (_ : ∀ (a : A), a * a - a * a = 0)\n    (_ : ∀ (x x_1 x_2 : A), ⁅x, ⁅x_1, x_2⁆⁆ = ⁅⁅x, x_1⁆, x_2⁆ + ⁅x_1, ⁅x, x_2⁆⁆)","name":"LieRing.ofAssociativeRing","doc":"An associative ring gives rise to a Lie ring by taking the bracket to be the ring commutator. ","depth":10},{"term":"fun {A} [Ring A] {R} [CommRing R] [Algebra R A] => LieAlgebra.mk (_ : ∀ (t : R) (x y : A), ⁅x, t • y⁆ = t • ⁅x, y⁆)","name":"LieAlgebra.ofAssociativeAlgebra","doc":"An associative algebra gives rise to a Lie algebra by taking the bracket to be the ring\ncommutator. ","depth":12},{"term":"fun G [Group G] => {g | ∃ g₁ g₂, ⁅g₁, g₂⁆ = g}","name":"commutatorSet","doc":"The set of commutator elements `⁅g₁, g₂⁆` in `G`. ","depth":15},{"term":"fun L [LieRing L] =>\n  let_fun this :=\n    let src := inferInstance;\n    NonUnitalNonAssocSemiring.mk (_ : ∀ (x m n : L), ⁅x, m + n⁆ = ⁅x, m⁆ + ⁅x, n⁆)\n      (_ : ∀ (x y m : L), ⁅x + y, m⁆ = ⁅x, m⁆ + ⁅y, m⁆) (_ : ∀ (m : L), ⁅0, m⁆ = 0) (_ : ∀ (x : L), ⁅x, 0⁆ = 0);\n  this","name":"instNonUnitalNonAssocSemiringCommutatorRing","doc":"A `LieRing` can be regarded as a `NonUnitalNonAssocSemiring` by turning its\n`Bracket` (denoted `⁅, ⁆`) into a `Mul` (denoted `*`). ","depth":17}],"count":232}
{"noDocExamples":[],"kind":"Lean.Parser.Term.type","examples":[{"term":"Type (max u v)","name":"TypeMax","doc":"An alias for `Type max u v`, to deal around unification issues. ","depth":0},{"term":"Type u_3","name":"PartialFun","doc":"The category of types equipped with partial functions. ","depth":0},{"term":"Type u","name":"CategoryTheory.RelCat","doc":"A type synonym for `Type`, which carries the category instance for which\nmorphisms are binary relations. ","depth":0},{"term":"CategoryTheory.SimplicialObject.Augmented (Type u)","name":"SSet.Augmented","doc":"The category of augmented simplicial sets, as a particular case of\naugmented simplicial objects. ","depth":2},{"term":"∀ (α : Type (max u v)), Small.{v, max u v} α","name":"UnivLE","doc":"A class expressing a universe inequality. `UnivLE.{u, v}` expresses that `u ≤ v`.\n\nThere are (at least) two plausible definitions for `u ≤ v`:\n* strong: `∀ α : Type max u v, Small.{v} α`\n* weak: `∀ α : Type u, Small.{v} α`\n\nThe weak definition has the advantage of being transitive.\nHowever only under the strong definition do we have `Small.{v} ((α : Type u) → (β : Type v))`,\nwhich is essential for proving that `Type v` has `Type u`-indexed limits when `u ≤ v`.\n\nThe strong definition implies the weaker definition (see below),\nbut we can not prove the reverse implication.\nThis is because in Lean's type theory, while `max u v` is at least at big as `u` and `v`,\nit could be bigger than both!\n","depth":2}],"count":229}
{"noDocExamples":[],"kind":"«term_<$>_»","examples":[{"term":"fun {α} [Encodable α] =>\n  { encode := Encodable.encodeMultiset, decode := Encodable.decodeMultiset,\n    encodek :=\n      (_ :\n        ∀ (s : Multiset α),\n          Multiset.ofList <$> Encodable.decode (Encodable.encode (Multiset.sort Encodable.enle s)) = some s) }","name":"Multiset.encodable","doc":"If `α` is encodable, then so is `Multiset α`. ","depth":7},{"term":"fun {α} [Encodable α] n => Multiset.ofList <$> Encodable.decode n","name":"Encodable.decodeMultiset","doc":"Explicit decoding function for `Multiset α` ","depth":9},{"term":"fun {α} s => (fun a' => (a', Stream'.Seq.tail s)) <$> Stream'.Seq.get? s 0","name":"Stream'.Seq.destruct","doc":"Destructor for a sequence, resulting in either `none` (for `nil`) or\n`some (a, s)` (for `cons a s`). ","depth":9},{"term":"List.map Lean.Expr.fvar <$> Mathlib.Deriving.Traversable.getFVarIdsNotImplementationDetails","name":"Mathlib.Deriving.Traversable.getFVarsNotImplementationDetails","doc":"Get `Expr`s of `FVarId`s which is not implementation details in the current context. ","depth":10},{"term":"fun p enter => Prod.snd <$> StateT.run (System.FilePath.walkDir.go enter p) #[]","name":"System.FilePath.walkDir","doc":"Return all filesystem entries of a preorder traversal of all directories satisfying `enter`, starting at `p`.\nSymbolic links are visited as well by default. ","depth":10}],"count":227}
{"noDocExamples":[],"kind":"Lean.Parser.Term.prop","examples":[{"term":"ℕ → Prop","name":"Sat.Valuation","doc":"A valuation is an assignment of values to all the propositional variables. ","depth":1},{"term":"fun _p => Prop","name":"SlimCheck.Decorations.DecorationsOf","doc":"`DecorationsOf p` is used as a hint to `mk_decorations` to specify\nthat the goal should be satisfied with a proposition equivalent to `p`\nwith added annotations. ","depth":1},{"term":"fun α β => α → β → Prop","name":"Rel","doc":"A relation on `α` and `β`, aka a set-valued function, aka a partial multifunction ","depth":4},{"term":"⦃X Y : AlgebraicGeometry.Scheme⦄ → (X ⟶ Y) → [inst : AlgebraicGeometry.IsAffine Y] → Prop","name":"AlgebraicGeometry.AffineTargetMorphismProperty","doc":"An `AffineTargetMorphismProperty` is a class of morphisms from an arbitrary scheme into an\naffine scheme. ","depth":9},{"term":"fun l => ∀ (x : Prop), x ∈ l → ∀ (y : Prop), y ∈ l → (x ↔ y)","name":"List.TFAE","doc":"TFAE: The Following (propositions) Are Equivalent.\n\nThe `tfae_have` and `tfae_finish` tactics can be useful in proofs with `TFAE` goals.\n","depth":10}],"count":225}
{"noDocExamples":[],"kind":"«term_^[_]»","examples":[{"term":"fun {σ} f a => { steps := 0, evals_in_steps := (_ : (flip bind f)^[0] (some a) = (flip bind f)^[0] (some a)) }","name":"Turing.EvalsTo.refl","doc":"Reflexivity of `EvalsTo` in 0 steps. ","depth":9},{"term":"fun {α} f n x => Function.IsFixedPt f^[n] x","name":"Function.IsPeriodicPt","doc":"A point `x` is a periodic point of `f : α → α` of period `n` if `f^[n] x = x`.\nNote that we do not require `0 < n` in this definition. Many theorems about periodic points\nneed this assumption. ","depth":9},{"term":"fun {α} f x => ↑(List.map (fun n => f^[n] x) (List.range (Function.minimalPeriod f x)))","name":"Function.periodicOrbit","doc":"The orbit of a periodic point `x` of `f` is the cycle `[x, f x, f (f x), ...]`. Its length is\nthe minimal period of `x`.\n\nIf `x` is not a periodic point, then this is the empty (aka nil) cycle. ","depth":11},{"term":"fun n => ((fun p => (p.snd, p.fst + p.snd))^[n] (0, 1)).fst","name":"Nat.fib","doc":"Implementation of the fibonacci sequence satisfying\n`fib 0 = 0, fib 1 = 1, fib (n + 2) = fib n + fib (n + 1)`.\n\n*Note:* We use a stream iterator for better performance when compared to the naive recursive\nimplementation.\n","depth":13},{"term":"fun {α} {M} [AddCommMonoid M] f g n x => Finset.sum (Finset.range n) fun k => g (f^[k] x)","name":"birkhoffSum","doc":"The sum of values of `g` on the first `n` points of the orbit of `x` under `f`. ","depth":14}],"count":224}
{"noDocExamples":[],"kind":"«term_⧸_»","examples":[{"term":"fun G [Group G] => G ⧸ commutator G","name":"Abelianization","doc":"The abelianization of G is the quotient of G by its commutator subgroup. ","depth":7},{"term":"fun {α} rels => FreeGroup α ⧸ Subgroup.normalClosure rels","name":"PresentedGroup","doc":"Given a set of relations, `rels`, over a type `α`, `PresentedGroup` constructs the group with\ngenerators `x : α` and relations `rels` as a quotient of `FreeGroup α`. ","depth":8},{"term":"fun {G} [AddGroup G] H => Nat.card (G ⧸ H)","name":"AddSubgroup.index","doc":"The index of a subgroup as a natural number,\nand returns 0 if the index is infinite.","depth":9},{"term":"fun {G} [Group G] H => Nat.card (G ⧸ H)","name":"Subgroup.index","doc":"The index of a subgroup as a natural number, and returns 0 if the index is infinite. ","depth":9},{"term":"fun R [CommRing R] [LocalRing R] => R ⧸ LocalRing.maximalIdeal R","name":"LocalRing.ResidueField","doc":"The residue field of a local ring is the quotient of the ring by its maximal ideal. ","depth":10}],"count":220}
{"noDocExamples":[],"kind":"CategoryTheory.Iso.«term_≪≫_»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] {X} =>\n  CategoryTheory.MonoOver.liftIso\n      (_ :\n        ∀ (g : CategoryTheory.MonoOver X),\n          CategoryTheory.Mono\n            (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoOver.arrow g) (CategoryTheory.CategoryStruct.id X)))\n      (_ : ∀ (f : CategoryTheory.MonoOver X), CategoryTheory.Mono f.obj.hom) CategoryTheory.Over.mapId ≪≫\n    CategoryTheory.MonoOver.liftId","name":"CategoryTheory.MonoOver.mapId","doc":"`MonoOver.map` preserves the identity (up to a natural isomorphism). ","depth":17},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] {A} [CategoryTheory.Limits.HasFiniteProducts C]\n    [CategoryTheory.Exponentiable A] {I} t =>\n  CategoryTheory.Limits.prod.braiding I A ≪≫ CategoryTheory.zeroMul t","name":"CategoryTheory.mulZero","doc":"If an initial object `0` exists in a CCC, then `0 ⨯ A ≅ 0`. ","depth":18},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] =>\n  { fst := CategoryTheory.MonoidalCategory.tensorUnit C,\n    snd :=\n      CategoryTheory.HalfBraiding.mk fun U =>\n        CategoryTheory.MonoidalCategory.leftUnitor U ≪≫ (CategoryTheory.MonoidalCategory.rightUnitor U).symm }","name":"CategoryTheory.Center.tensorUnit","doc":"Auxiliary definition for the `MonoidalCategory` instance on `Center C`. ","depth":18},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] {X} [CategoryTheory.Limits.HasPullbacks C] =>\n  CategoryTheory.MonoOver.liftIso\n      (_ : ∀ (g : CategoryTheory.MonoOver X), CategoryTheory.Mono CategoryTheory.Limits.pullback.snd)\n      (_ : ∀ (f : CategoryTheory.MonoOver X), CategoryTheory.Mono f.obj.hom) CategoryTheory.Over.pullbackId ≪≫\n    CategoryTheory.MonoOver.liftId","name":"CategoryTheory.MonoOver.pullbackId","doc":"pullback preserves the identity (up to a natural isomorphism) ","depth":18},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasZeroMorphisms C] X Y\n    [CategoryTheory.Limits.HasBinaryBiproduct X Y] =>\n  CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso\n      (CategoryTheory.Limits.limit.isLimit (CategoryTheory.Limits.pair X Y))\n      (CategoryTheory.Limits.BinaryBiproduct.isLimit X Y) ≪≫\n    CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso (CategoryTheory.Limits.BinaryBiproduct.isColimit X Y)\n      (CategoryTheory.Limits.colimit.isColimit (CategoryTheory.Limits.pair X Y))","name":"CategoryTheory.Limits.biprodIso","doc":"The isomorphism between the specified binary product and the specified binary coproduct for\na pair for a binary biproduct.\n","depth":19}],"count":218}
{"noDocExamples":[],"kind":"Filter.«term∀ᶠ_In_,_»","examples":[{"term":"fun {α} p f => ¬∀ᶠ (x : α) in f, ¬p x","name":"Filter.Frequently","doc":"`f.Frequently p` or `∃ᶠ x in f, p x` mean that `{x | ¬p x} ∉ f`. E.g., `∃ᶠ x in atTop, p x`\nmeans that there exist arbitrarily large `x` for which `p` holds true. ","depth":9},{"term":"fun {α} r f => ∃ b, ∀ᶠ (x : α) in f, r x b","name":"Filter.IsBounded","doc":"`f.IsBounded (≺)`: the filter `f` is eventually bounded w.r.t. the relation `≺`, i.e.\neventually, it is bounded by some uniform bound.\n`r` will be usually instantiated with `≤` or `≥`. ","depth":10},{"term":"fun {α} {β} l f g => ∀ᶠ (x : α) in l, f x = g x","name":"Filter.EventuallyEq","doc":"Two functions `f` and `g` are *eventually equal* along a filter `l` if the set of `x` such that\n`f x = g x` belongs to `l`. ","depth":11},{"term":"fun {α} r f => ∃ b, ∀ (a : α), (∀ᶠ (x : α) in f, r x a) → r b a","name":"Filter.IsCobounded","doc":"`IsCobounded (≺) f` states that the filter `f` does not tend to infinity w.r.t. `≺`. This is\nalso called frequently bounded. Will be usually instantiated with `≤` or `≥`.\n\nThere is a subtlety in this definition: we want `f.IsCobounded` to hold for any `f` in the case of\ncomplete lattices. This will be relevant to deduce theorems on complete lattices from their\nversions on conditionally complete lattices with additional assumptions. We have to be careful in\nthe edge case of the trivial filter containing the empty set: the other natural definition\n  `¬ ∀ a, ∀ᶠ n in f, a ≤ n`\nwould not work as well in this case.\n","depth":12},{"term":"fun {α} {β} {l} p f =>\n  Filter.Germ.liftOn f (fun f => ∀ᶠ (x : α) in l, p (f x))\n    (_ :\n      ∀ (_f _g : α → β), _f =ᶠ[l] _g → (fun f => ∀ᶠ (x : α) in l, p (f x)) _f = (fun f => ∀ᶠ (x : α) in l, p (f x)) _g)","name":"Filter.Germ.LiftPred","doc":"Lift a predicate on `β` to `Germ l β`. ","depth":13}],"count":213}
{"noDocExamples":[],"kind":"termRexp","examples":[{"term":"fun x => if x ≤ 0 then 0 else rexp (-x⁻¹)","name":"expNegInvGlue","doc":"`expNegInvGlue` is the real function given by `x ↦ exp (-1/x)` for `x > 0` and `0`\nfor `x ≤ 0`. It is a basic building block to construct smooth partitions of unity. Its main property\nis that it vanishes for `x ≤ 0`, it is positive for `x > 0`, and the junction between the two\nbehaviors is flat enough to retain smoothness. The fact that this function is `C^∞` is proved in\n`expNegInvGlue.contDiff `. ","depth":9},{"term":"fun s => ∫ (x : ℝ) in Set.Ioi 0, ↑(rexp (-x)) * ↑x ^ (s - 1)","name":"Complex.GammaIntegral","doc":"Euler's integral for the `Γ` function (of a complex variable `s`), defined as\n`∫ x in Ioi 0, exp (-x) * x ^ (s - 1)`.\n\nSee `Complex.GammaIntegral_convergent` for a proof of the convergence of the integral for\n`0 < re s`. ","depth":11},{"term":"StrictMono.orderIsoOfSurjective (Set.codRestrict rexp (Real.lt 0) Real.exp_pos) Real.expOrderIso.proof_1\n  Real.expOrderIso.proof_2","name":"Real.expOrderIso","doc":"`Real.exp` as an order isomorphism between `ℝ` and `(0, +∞)`. ","depth":11},{"term":"fun n => ↑(Nat.factorial n) / (Real.sqrt (2 * ↑n) * (↑n / rexp 1) ^ n)","name":"Stirling.stirlingSeq","doc":"Define `stirlingSeq n` as $\\frac{n!}{\\sqrt{2n}(\\frac{n}{e})^n}$.\nStirling's formula states that this sequence has limit $\\sqrt(π)$.\n","depth":12},{"term":"fun t => ∑' (n : ℕ), ↑(rexp (-Real.pi * t * (↑n + 1) ^ 2))","name":"zetaKernel₁","doc":"Function whose Mellin transform is `π ^ (-s) * Γ(s) * zeta (2 * s)`, for `1 / 2 < Re s`. ","depth":14}],"count":212}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫⁻_,_∂_»","examples":[{"term":"fun {α} {m} μ ν => (fun f => ∫⁻ (x : α), f x ∂μ) '' MeasureTheory.Measure.LebesgueDecomposition.measurableLE μ ν","name":"MeasureTheory.Measure.LebesgueDecomposition.measurableLEEval","doc":"`measurableLEEval μ ν` is the set of `∫⁻ x, f x ∂μ` for all `f ∈ measurableLE μ ν`. ","depth":11},{"term":"fun {α} [MeasurableSpace α] m =>\n  MeasureTheory.Measure.ofMeasurable (fun s x => ∫⁻ (μ : MeasureTheory.Measure α), ↑↑μ s ∂m)\n    (_ : ∫⁻ (x : MeasureTheory.Measure α), ↑↑x ∅ ∂m = 0)\n    (_ :\n      ∀ ⦃f : ℕ → Set α⦄ (hf : ∀ (i : ℕ), MeasurableSet (f i)),\n        Pairwise (Disjoint on f) →\n          (fun s x => ∫⁻ (μ : MeasureTheory.Measure α), ↑↑μ s ∂m) (⋃ (i : ℕ), f i)\n              (_ : MeasurableSet (⋃ (b : ℕ), f b)) =\n            ∑' (i : ℕ), (fun s x => ∫⁻ (μ : MeasureTheory.Measure α), ↑↑μ s ∂m) (f i) (_ : MeasurableSet (f i)))","name":"MeasureTheory.Measure.join","doc":"Monadic join on `Measure` in the category of measurable spaces and measurable\nfunctions. ","depth":15},{"term":"fun {α} {β} [NormedAddCommGroup β] {x} f μ => ∫⁻ (a : α), ↑‖f a‖₊ ∂μ < ⊤","name":"MeasureTheory.HasFiniteIntegral","doc":"`HasFiniteIntegral f μ` means that the integral `∫⁻ a, ‖f a‖ ∂μ` is finite.\n`HasFiniteIntegral f` means `HasFiniteIntegral f volume`. ","depth":17},{"term":"fun {α} [MeasurableSpace α] f p μ a => f a * ((∫⁻ (c : α), f c ^ p ∂μ) ^ (1 / p))⁻¹","name":"ENNReal.funMulInvSnorm","doc":"Function multiplied by the inverse of its p-seminorm `(∫⁻ f^p ∂μ) ^ 1/p`","depth":18},{"term":"fun {α} {m0} μ f => ∫⁻ (x : α), f x ∂(↑↑μ Set.univ)⁻¹ • μ","name":"MeasureTheory.laverage","doc":"Average value of an `ℝ≥0∞`-valued function `f` w.r.t. a measure `μ`, notation: `⨍⁻ x, f x ∂μ`.\nIt is defined as `μ univ⁻¹ * ∫⁻ x, f x ∂μ`, so it is equal to zero if `μ` is an infinite measure. If\n`μ` is a probability measure, then the average of any function is equal to its integral.\n\nFor the average on a set, use `⨍⁻ x in s, f x ∂μ` (defined as `⨍⁻ x, f x ∂(μ.restrict s)`). For\naverage w.r.t. the volume, one can omit `∂volume`. ","depth":19}],"count":209}
{"noDocExamples":[],"kind":"«term‖_‖₊»","examples":[{"term":"fun {ι} {π} [Fintype ι] [(i : ι) → NonUnitalSeminormedRing (π i)] =>\n  let src := Pi.seminormedAddCommGroup;\n  let src_1 := Pi.nonUnitalRing;\n  NonUnitalSeminormedRing.mk (_ : ∀ (x y : (i : ι) → π i), dist x y = ‖x - y‖)\n    (_ :\n      ∀ (x y : (i : ι) → π i),\n        ↑(Finset.sup Finset.univ fun i => ‖x i * y i‖₊) ≤\n          ↑((Finset.sup Finset.univ fun i => ‖x i‖₊) * Finset.sup Finset.univ fun i => ‖y i‖₊))","name":"Pi.nonUnitalSeminormedRing","doc":"Non-unital seminormed ring structure on the product of finitely many non-unital seminormed\nrings, using the sup norm. ","depth":16},{"term":"fun {α} {F} [NormedAddCommGroup F] {x} f μ => essSup (fun x => ↑‖f x‖₊) μ","name":"MeasureTheory.snormEssSup","doc":"seminorm for `ℒ∞`, equal to the essential supremum of `‖f‖`. ","depth":16},{"term":"fun {α} {β} [NormedAddCommGroup β] {x} f μ => ∫⁻ (a : α), ↑‖f a‖₊ ∂μ < ⊤","name":"MeasureTheory.HasFiniteIntegral","doc":"`HasFiniteIntegral f μ` means that the integral `∫⁻ a, ‖f a‖ ∂μ` is finite.\n`HasFiniteIntegral f` means `HasFiniteIntegral f volume`. ","depth":17},{"term":"fun {α} [NormedDivisionRing α] =>\n  { toZeroHom := { toFun := fun x => ‖x‖₊, map_zero' := (_ : ‖0‖₊ = 0) }, map_one' := (_ : ‖1‖₊ = 1),\n    map_mul' := (_ : ∀ (a b : α), ‖a * b‖₊ = ‖a‖₊ * ‖b‖₊) }","name":"nnnormHom","doc":"`nnnorm` as a `MonoidWithZeroHom`. ","depth":17},{"term":"fun {α} [TopologicalSpace α] f =>\n  BoundedContinuousFunction.comp (fun x => ‖x‖₊) BoundedContinuousFunction.nnnorm.proof_1 f","name":"BoundedContinuousFunction.nnnorm","doc":"The absolute value of a bounded continuous `ℝ`-valued function as a bounded\ncontinuous `ℝ≥0`-valued function. ","depth":17}],"count":197}
{"noDocExamples":[],"kind":"«term_×__1»","examples":[{"term":"fun α => (b : Bool) × Lists' α b","name":"Lists","doc":"Hereditarily finite list, aka ZFA list. A ZFA list is either an \"atom\" (`b = false`),\ncorresponding to an element of `α`, or a \"proper\" ZFA list, inductively defined from the empty ZFA\nlist and from appending a ZFA list to a proper ZFA list. ","depth":5},{"term":"fun P => (x : P.A) × PFunctor.B P x","name":"PFunctor.IdxCat","doc":"`Idx` identifies a location inside the application of a pfunctor.\nFor `F : PFunctor`, `x : F.obj α` and `i : F.Idx`, `i` can designate\none part of `x` or is invalid, if `i.1 ≠ x.1` ","depth":5},{"term":"fun P α => (x : P.A) × (PFunctor.B P x → α)","name":"PFunctor.Obj","doc":"Applying `P` to an object of `Type` ","depth":7},{"term":"fun J [CategoryTheory.Category.{v₁, u₁} J] => (j : CategoryTheory.ConnectedComponents J) × CategoryTheory.Component j","name":"CategoryTheory.Decomposed","doc":"The disjoint union of `J`s connected components, written explicitly as a sigma-type with the\ncategory structure.\nThis category is equivalent to `J`.\n","depth":7},{"term":"fun L => (l : ℕ) × FirstOrder.Language.Functions L l ⊕ (l : ℕ) × FirstOrder.Language.Relations L l","name":"FirstOrder.Language.Symbols","doc":"The type of symbols in a given language. ","depth":7}],"count":195}
{"noDocExamples":[],"kind":"«term_⊕_»","examples":[{"term":"fun L => (l : ℕ) × FirstOrder.Language.Functions L l ⊕ (l : ℕ) × FirstOrder.Language.Relations L l","name":"FirstOrder.Language.Symbols","doc":"The type of symbols in a given language. ","depth":7},{"term":"fun V W =>\n  SimpleGraph.Coloring.mk (fun v => Sum.isRight v)\n    (_ :\n      ∀ {v w : V ⊕ W},\n        SimpleGraph.Adj (completeBipartiteGraph V W) v w → (fun v => Sum.isRight v) v ≠ (fun v => Sum.isRight v) w)","name":"SimpleGraph.CompleteBipartiteGraph.bicoloring","doc":"The bicoloring of a complete bipartite graph using whether a vertex\nis on the left or on the right. ","depth":9},{"term":"fun {n} [NeZero n] => Fintype.ofEquiv (ZMod n ⊕ ZMod n) DihedralGroup.fintypeHelper","name":"DihedralGroup.instFintypeDihedralGroup","doc":"If `0 < n`, then `DihedralGroup n` is a finite group.\n","depth":9},{"term":"fun {α} {β} [Fintype (α ⊕ β)] => Fintype.ofInjective Sum.inr (_ : Function.Injective Sum.inr)","name":"Fintype.sumRight","doc":"Given that `α ⊕ β` is a fintype, `β` is also a fintype. This is non-computable as it uses\nthat `Sum.inr` is an injection, but there's no clear inverse if `β` is empty. ","depth":9},{"term":"fun L L' =>\n  { Functions := fun n => FirstOrder.Language.Functions L n ⊕ FirstOrder.Language.Functions L' n,\n    Relations := fun n => FirstOrder.Language.Relations L n ⊕ FirstOrder.Language.Relations L' n }","name":"FirstOrder.Language.sum","doc":"The sum of two languages consists of the disjoint union of their symbols. ","depth":9}],"count":192}
{"noDocExamples":[],"kind":"«term_>_»","examples":[{"term":"fun α [LT α] => IsWellFounded α fun x x_1 => x > x_1","name":"WellFoundedGT","doc":"A class for a well founded relation `>`. ","depth":9},{"term":"fun {α} [LT α] [WellFoundedGT α] => IsWellFounded.toWellFoundedRelation fun x x_1 => x > x_1","name":"WellFoundedGT.toWellFoundedRelation","doc":"Derive a `WellFoundedRelation` instance from a `WellFoundedGT` instance. ","depth":11},{"term":"fun {α} [LT α] [WellFoundedGT α] => IsWellFounded.apply fun x x_1 => x > x_1","name":"WellFoundedGT.apply","doc":"All values are accessible under the well-founded `>`. ","depth":11},{"term":"fun {α} f => {x | ∃ n, n > 0 ∧ Function.IsPeriodicPt f n x}","name":"Function.periodicPts","doc":"The set of periodic points of a map `f : α → α`. ","depth":12},{"term":"fun a =>\n  if h : a.num < 0 then Rat.mk' (-↑a.den) (Int.natAbs a.num)\n  else if h : a.num > 0 then Rat.mk' (↑a.den) (Int.natAbs a.num) else a","name":"Rat.inv","doc":"The inverse of a rational number. Note: `inv 0 = 0`. (This definition is `@[irreducible]`\nbecause you don't want to unfold it. Use `Rat.inv_def` instead.)\n","depth":13}],"count":172}
{"noDocExamples":[],"kind":"«term_ᵒᵈ»","examples":[{"term":"fun {α} => Equiv.refl αᵒᵈ","name":"OrderDual.ofDual","doc":"`ofDual` is the identity function from the `OrderDual` of a linear order.  ","depth":3},{"term":"fun {α} => Equiv.refl (WithBot αᵒᵈ)","name":"WithBot.ofDual","doc":"`WithBot.ofDual` is the equivalence sending `⊥` to `⊤` and any `a : αᵒᵈ` to `ofDual a : α`.\nSee `WithBot.ofDual_top_equiv` for the related order-iso.\n","depth":4},{"term":"fun {α} => Equiv.refl (WithTop αᵒᵈ)","name":"WithTop.ofDual","doc":"`WithTop.ofDual` is the equivalence sending `⊤` to `⊥` and any `a : αᵒᵈ` to `ofDual a : α`.\nSee `WithTop.toDualBotEquiv` for the related order-iso.\n","depth":4},{"term":"fun {α} [LE α] => OrderIso.refl (WithTop αᵒᵈ)","name":"WithTop.toDualBotEquiv","doc":"Taking the dual then adding `⊤` is the same as adding `⊥` then taking the dual.\nThis is the order iso form of `WithTop.ofDual`, as proven by `coe_toDualBotEquiv_eq`. ","depth":6},{"term":"fun {α} [LE α] => OrderIso.refl (WithBot αᵒᵈ)","name":"WithBot.toDualTopEquiv","doc":"Taking the dual then adding `⊥` is the same as adding `⊤` then taking the dual.\nThis is the order iso form of `WithBot.ofDual`, as proven by `coe_toDualTopEquiv_eq`.\n","depth":6}],"count":170}
{"noDocExamples":[],"kind":"boolIfThenElse","examples":[{"term":"fun b => bif b then PosNum.bit1 else PosNum.bit0","name":"PosNum.bit","doc":"`bit b n` appends the bit `b` to the end of `n`, where `bit tt x = x1` and `bit ff x = x0`. ","depth":6},{"term":"fun b => bif b then Num.bit1 else Num.bit0","name":"Num.bit","doc":"`bit b n` appends the bit `b` to the end of `n`, where `bit tt x = x1` and `bit ff x = x0`. ","depth":6},{"term":"fun b => bif b then 1 else 0","name":"Bool.toNat","doc":"convert a `Bool` to a `ℕ`, `false -> 0`, `true -> 1` ","depth":6},{"term":"fun b => bif b then bit1 else bit0","name":"Int.bit","doc":"`bit b` appends the digit `b` to the binary representation of\nits integer input. ","depth":7},{"term":"fun b => bif b then bit1 else bit0","name":"Nat.bit","doc":"`bit b` appends the digit `b` to the binary representation of\nits natural number input. ","depth":7}],"count":169}
{"noDocExamples":[],"kind":"«term⅟_»","examples":[{"term":"fun {α} [Monoid α] a [Invertible a] => { val := a, inv := ⅟a, val_inv := (_ : a * ⅟a = 1), inv_val := (_ : ⅟a * a = 1) }","name":"unitOfInvertible","doc":"An `Invertible` element is a unit. ","depth":14},{"term":"fun {α} [One α] [Mul α] {a} [Invertible a] =>\n  { invOf := a, invOf_mul_self := (_ : a * ⅟a = 1), mul_invOf_self := (_ : ⅟a * a = 1) }","name":"invertibleInvOf","doc":"`a` is the inverse of `⅟a`. ","depth":14},{"term":"fun {α} [MulOneClass α] {r} hr s hs => Invertible.copy' hr s (⅟r) hs (_ : ⅟r = ⅟r)","name":"Invertible.copy","doc":"If `r` is invertible and `s = r`, then `s` is invertible. ","depth":15},{"term":"fun {α} [Mul α] [One α] [HasDistribNeg α] a [Invertible a] =>\n  { invOf := -⅟a, invOf_mul_self := (_ : -⅟a * -a = 1), mul_invOf_self := (_ : -a * -⅟a = 1) }","name":"invertibleNeg","doc":"`-⅟a` is the inverse of `-a` ","depth":16},{"term":"fun {α} [Monoid α] a b [Invertible a] [Invertible b] =>\n  { invOf := ⅟b * ⅟a, invOf_mul_self := (_ : ⅟b * ⅟a * (a * b) = 1), mul_invOf_self := (_ : a * b * (⅟b * ⅟a) = 1) }","name":"invertibleMul","doc":"`⅟b * ⅟a` is the inverse of `a * b` ","depth":18}],"count":166}
{"noDocExamples":[],"kind":"Rat.termℚ","examples":[{"term":"ℚ","name":"CompareReals.Q","doc":"Type wrapper around ℚ to make sure the absolute value uniform space instance is picked up\ninstead of the metric space one. We proved in rat.uniform_space_eq that they are equal,\nbut they are not definitionaly equal, so it would confuse the type class system (and probably\nalso human readers). ","depth":0},{"term":"fun p => CauSeq ℚ (padicNorm p)","name":"PadicSeq","doc":"The type of Cauchy sequences of rationals with respect to the `p`-adic norm. ","depth":7},{"term":"fun R [Nontrivial R] [Ring R] [Algebra ℚ R] => CharP.charP_to_charZero R","name":"algebraRat.charZero","doc":"A nontrivial `ℚ`-algebra has characteristic zero.\n\nThis cannot be a (local) instance because it would immediately form a loop with the\ninstance `algebraRat`. It's probably easier to go the other way: prove `CharZero R` and\nautomatically receive an `Algebra ℚ R` instance.\n","depth":9},{"term":"fun k x => Polynomial.eval x (Polynomial.map (algebraMap ℚ ℝ) (Polynomial.bernoulli k))","name":"bernoulliFun","doc":"The function `x ↦ Bₖ(x) : ℝ → ℝ`. ","depth":10},{"term":"fun {𝕜} [NormedDivisionRing 𝕜] [CharZero 𝕜] [NormedAlgebra ℝ 𝕜] =>\n  NormedAlgebra.mk (_ : ∀ (q : ℚ) (x : 𝕜), ‖q • x‖ ≤ ‖q‖ * ‖x‖)","name":"normedAlgebraRat","doc":"Any normed characteristic-zero division ring that is a normed algebra over the reals is also a\nnormed algebra over the rationals.\n\nPhrased another way, if `𝕜` is a normed algebra over the reals, then `AlgebraRat` respects that\nnorm. ","depth":10}],"count":164}
{"noDocExamples":[],"kind":"«term_ᵃᵒᵖ»","examples":[{"term":"fun M => Mᵃᵒᵖ","name":"DomAddAct","doc":"If `M` additively acts on `α`, then `DomAddAct M` acts on `α → β` as\nwell as some bundled maps from `α`. This is a type synonym for `AddOpposite M`, so this corresponds\nto a right action of `M`.","depth":2},{"term":"fun {α} =>\n  { toFun := AddOpposite.op, invFun := AddOpposite.unop,\n    left_inv := (_ : ∀ (x : α), AddOpposite.unop (AddOpposite.op x) = x),\n    right_inv := (_ : ∀ (x : αᵃᵒᵖ), AddOpposite.op (AddOpposite.unop x) = x) }","name":"AddOpposite.opEquiv","doc":"The canonical bijection between `α` and `αᵃᵒᵖ`.","depth":7},{"term":"fun M α [VAdd M α] [VAdd Mᵃᵒᵖ α] [self : IsCentralVAdd M α] => self.1","name":"IsCentralVAdd.op_vadd_eq_vadd","doc":"The right and left actions of `M` on `α` are equal. ","depth":9},{"term":"fun {G} [AddGroup G] [PseudoEMetricSpace G] [IsometricVAdd Gᵃᵒᵖ G] c =>\n  { toEquiv := Equiv.addRight c, isometry_toFun := (_ : ∀ (a b : G), edist (a + c) (b + c) = edist a b) }","name":"IsometryEquiv.addRight","doc":"Addition `y ↦ y + x` as an `IsometryEquiv`.","depth":11},{"term":"fun {G} [AddGroup G] [PseudoEMetricSpace G] [IsometricVAdd Gᵃᵒᵖ G] c =>\n  { toEquiv := Equiv.subRight c, isometry_toFun := (_ : ∀ (a b : G), edist (a - c) (b - c) = edist a b) }","name":"IsometryEquiv.subRight","doc":"Subtraction `y ↦ y - x` as an `IsometryEquiv`.","depth":11}],"count":162}
{"noDocExamples":[],"kind":"«term_→₀_»","examples":[{"term":"fun σ R => (σ →₀ ℕ) → R","name":"MvPowerSeries","doc":"Multivariate formal power series, where `σ` is the index set of the variables\nand `R` is the coefficient ring.","depth":6},{"term":"fun k G [Semiring k] => G →₀ k","name":"MonoidAlgebra","doc":"The monoid algebra over a semiring `k` generated by the monoid `G`.\nIt is the type of finite formal `k`-linear combinations of terms of `G`,\nendowed with the convolution product.\n","depth":7},{"term":"fun k G [Semiring k] => G →₀ k","name":"AddMonoidAlgebra","doc":"The monoid algebra over a semiring `k` generated by the additive monoid `G`.\nIt is the type of finite formal `k`-linear combinations of terms of `G`,\nendowed with the convolution product.\n","depth":7},{"term":"fun σ R [CommSemiring R] => AddMonoidAlgebra R (σ →₀ ℕ)","name":"MvPolynomial","doc":"Multivariate polynomial, where `σ` is the index set of the variables and\n`R` is the coefficient ring ","depth":8},{"term":"fun R σ [CommSemiring R] => AddMonoidAlgebra.of R (σ →₀ ℕ)","name":"MvPolynomial.monomialOneHom","doc":"`fun s ↦ monomial s 1` as a homomorphism. ","depth":9}],"count":155}
{"noDocExamples":[],"kind":"Complex.termCexp","examples":[{"term":"fun x => (cexp ↑x).re","name":"Real.exp","doc":"The real exponential function, defined as the real part of the complex exponential ","depth":4},{"term":"fun z => (cexp z + cexp (-z)) / 2","name":"Complex.cosh","doc":"The complex hyperbolic cosine function, defined via `exp` ","depth":9},{"term":"fun z => (cexp z - cexp (-z)) / 2","name":"Complex.sinh","doc":"The complex hyperbolic sine function, defined via `exp` ","depth":9},{"term":"fun z => (cexp (z * Complex.I) + cexp (-z * Complex.I)) / 2","name":"Complex.cos","doc":"The complex cosine function, defined via `exp` ","depth":12},{"term":"fun x y => if x = 0 then if y = 0 then 1 else 0 else cexp (Complex.log x * y)","name":"Complex.cpow","doc":"The complex power function `x ^ y`, given by `x ^ y = exp(y log x)` (where `log` is the\nprincipal determination of the logarithm), unless `x = 0` where one sets `0 ^ 0 = 1` and\n`0 ^ y = 0` for `y ≠ 0`. ","depth":12}],"count":152}
{"noDocExamples":[],"kind":"«term_≈_»","examples":[{"term":"fun f hf => Quotient.map f (_ : ∀ (α β : Type u), α ≈ β → (fun x x_1 => x ≈ x_1) (f α) (f β))","name":"Cardinal.map","doc":"Lift a function between `Type*`s to a function between `Cardinal`s. ","depth":8},{"term":"fun {α} {β} f => Quotient.map (Prod.map f f) (_ : ∀ ⦃a b : α × α⦄, a ≈ b → Prod.map f f a ≈ Prod.map f f b)","name":"Sym2.map","doc":"The functor `Sym2` is functorial, and this function constructs the induced maps.\n","depth":11},{"term":"fun {α} {n} a =>\n  Quotient.map (Vector.cons a) (_ : ∀ (x x_1 : Vector α n), x ≈ x_1 → (fun x x_2 => x ≈ x_2) (a ::ᵥ x) (a ::ᵥ x_1))","name":"Sym.cons'","doc":"This is `cons` but for the alternative `Sym'` definition.\n","depth":11},{"term":"{ inv := fun x => if x ≈ 0 then 0 else if 0 < x then SetTheory.PGame.inv' x else -SetTheory.PGame.inv' (-x) }","name":"SetTheory.PGame.instInvPGame","doc":"The inverse of a pre-game in terms of the inverse on positive pre-games. ","depth":12},{"term":"fun f hf =>\n  Quotient.map₂ f (_ : ∀ (α β : Type u), α ≈ β → ∀ (γ δ : Type v), γ ≈ δ → (fun x x_1 => x ≈ x_1) (f α γ) (f β δ))","name":"Cardinal.map₂","doc":"Lift a binary operation `Type* → Type* → Type*` to a binary operation on `Cardinal`s. ","depth":12}],"count":152}
{"noDocExamples":[],"kind":"Filter.«term_=ᶠ[_]_»","examples":[{"term":"fun {α} {β} [Zero β] {_m} f μ => ↑f =ᶠ[MeasureTheory.Measure.cofinite μ] 0","name":"MeasureTheory.SimpleFunc.FinMeasSupp","doc":"A `SimpleFunc` has finite measure support if it is equal to `0` outside of a set of finite\nmeasure. ","depth":12},{"term":"fun {α} {β} {l} p f =>\n  Filter.Germ.liftOn f (fun f => ∀ᶠ (x : α) in l, p (f x))\n    (_ :\n      ∀ (_f _g : α → β), _f =ᶠ[l] _g → (fun f => ∀ᶠ (x : α) in l, p (f x)) _f = (fun f => ∀ᶠ (x : α) in l, p (f x)) _g)","name":"Filter.Germ.LiftPred","doc":"Lift a predicate on `β` to `Germ l β`. ","depth":13},{"term":"fun {α} {β} {l} f lb =>\n  Filter.Germ.liftOn f (fun f => Filter.Tendsto f l lb)\n    (_ : ∀ (_f _g : α → β), _f =ᶠ[l] _g → (fun f => Filter.Tendsto f l lb) _f = (fun f => Filter.Tendsto f l lb) _g)","name":"Filter.Germ.Tendsto","doc":"A germ at `l` of maps from `α` to `β` tends to `lb : Filter β` if it is represented by a map\nwhich tends to `lb` along `l`. ","depth":13},{"term":"fun {α} {β} [TopologicalSpace β] {x} f μ => ∃ g, MeasureTheory.StronglyMeasurable g ∧ f =ᶠ[MeasureTheory.Measure.ae μ] g","name":"MeasureTheory.AEStronglyMeasurable","doc":"A function is `AEStronglyMeasurable` with respect to a measure `μ` if it is almost everywhere\nequal to the limit of a sequence of simple functions. ","depth":15},{"term":"fun {α} {β} [MeasurableSpace β] {_m} f μ => ∃ g, Measurable g ∧ f =ᶠ[MeasureTheory.Measure.ae μ] g","name":"AEMeasurable","doc":"A function is almost everywhere measurable if it coincides almost everywhere with a measurable\nfunction. ","depth":15}],"count":149}
{"noDocExamples":[],"kind":"Multiset.«term_::ₘ_»","examples":[{"term":"fun {α} a s h => { val := a ::ₘ s.val, nodup := (_ : Multiset.Nodup (a ::ₘ s.val)) }","name":"Finset.cons","doc":"`cons a s h` is the set `{a} ∪ s` containing `a` and the elements of `s`. It is the same as\n`insert a s` when it is defined, but unlike `insert a s` it does not require `DecidableEq α`,\nand the union is guaranteed to be disjoint. ","depth":10},{"term":"fun {α} {a} s [Fintype ↑s] h =>\n  Fintype.ofFinset { val := a ::ₘ (Set.toFinset s).val, nodup := (_ : Multiset.Nodup (a ::ₘ (Set.toFinset s).val)) }\n    (_ :\n      ∀ (a_1 : α),\n        a_1 ∈\n            Finset.cons a { val := (Set.toFinset s).val, nodup := (_ : Multiset.Nodup (Set.toFinset s).val) }\n              (_ : ¬a ∈ (Set.toFinset s).val) ↔\n          a_1 ∈ insert a s)","name":"Set.fintypeInsertOfNotMem","doc":"A `Fintype` structure on `insert a s` when inserting a new element. ","depth":14},{"term":"fun {α} {δ} [DecidableEq α] s a b f a' h => Multiset.Pi.cons s.val a b f a' (_ : a' ∈ a ::ₘ s.val)","name":"Finset.Pi.cons","doc":"Given a function `f` defined on a finset `s`, define a new function on the finset `s ∪ {a}`,\nequal to `f` on `s` and sending `a` to a given value `b`. This function is denoted\n`s.Pi.cons a b f`. If `a` already belongs to `s`, the new function takes the value `b` at `a`\nanyway. ","depth":21},{"term":"fun {α} [DecidableEq α] {β} m t =>\n  Multiset.recOn m {Multiset.Pi.empty β}\n    (fun a m p => Multiset.bind (t a) fun b => Multiset.map (Multiset.Pi.cons m a b) p)\n    (_ :\n      ∀ (a a' : α) (m : Multiset α) (n : Multiset ((a : α) → a ∈ m → β a)),\n        HEq\n          (Multiset.bind (t a) fun b =>\n            Multiset.map (Multiset.Pi.cons (a' ::ₘ m) a b)\n              (Multiset.bind (t a') fun b => Multiset.map (Multiset.Pi.cons m a' b) n))\n          (Multiset.bind (t a') fun b =>\n            Multiset.map (Multiset.Pi.cons (a ::ₘ m) a' b)\n              (Multiset.bind (t a) fun b => Multiset.map (Multiset.Pi.cons m a b) n)))","name":"Multiset.pi","doc":"`pi m t` constructs the Cartesian product over `t` indexed by `m`. ","depth":23},{"term":"fun {α} {n} a s => { val := a ::ₘ ↑s, property := (_ : ↑Multiset.card (a ::ₘ ↑s) = Nat.succ n) }","name":"Sym.cons","doc":"Inserts an element into the term of `Sym α n`, increasing the length by one.\n","depth":29}],"count":142}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫_,_∂_»","examples":[{"term":"fun {Ω} {m} X p μ => ∫ (x : Ω), (X ^ p) x ∂μ","name":"ProbabilityTheory.moment","doc":"Moment of a real random variable, `μ[X ^ p]`. ","depth":16},{"term":"fun {Ω} {m} X μ t => ∫ (x : Ω), (fun ω => rexp (t * X ω)) x ∂μ","name":"ProbabilityTheory.mgf","doc":"Moment generating function of a real random variable `X`: `fun t => μ[exp(t*X)]`. ","depth":16},{"term":"fun {E} [NormedAddCommGroup E] [NormedSpace ℝ E] [HasContDiffBump E] [MeasurableSpace E] {c} f μ x =>\n  ↑f x / ∫ (x : E), ↑f x ∂μ","name":"ContDiffBump.normed","doc":"A bump function normed so that `∫ x, f.normed μ x ∂μ = 1`. ","depth":19},{"term":"fun {Ω} {x} X μ => ∫⁻ (ω : Ω), ↑‖X ω - ∫ (x : Ω), X x ∂μ‖₊ ^ 2 ∂μ","name":"ProbabilityTheory.evariance","doc":"The `ℝ≥0∞`-valued variance of a real-valued random variable defined as the Lebesgue integral of\n`(X - 𝔼[X])^2`. ","depth":20},{"term":"fun {Ω} {m} X p μ =>\n  let_fun m_1 := fun x => ∫ (x : Ω), X x ∂μ;\n  ∫ (x : Ω), ((X - m_1) ^ p) x ∂μ","name":"ProbabilityTheory.centralMoment","doc":"Central moment of a real random variable, `μ[(X - μ[X]) ^ p]`. ","depth":20}],"count":138}
{"noDocExamples":[],"kind":"«term_==_»","examples":[{"term":"fun a => a.den == 1","name":"Rat.isInt","doc":"Is this rational number integral? ","depth":5},{"term":"fun {α} as => as.start == as.stop","name":"Subarray.isEmpty","doc":"Check whether a subarray is empty.\n","depth":6},{"term":"fun {α} [BEq α] a => List.findIdxs fun x => x == a","name":"List.indexesOf","doc":"`indexesOf a l` is the list of all indexes of `a` in `l`. For example:\n```\nindexesOf a [a, b, a, a] = [0, 2, 3]\n```\n","depth":9},{"term":"fun {α} [BEq α] a b => !a == b","name":"bne","doc":"`x != y` is boolean not-equal. It is the negation of `x == y` which is supplied by\nthe `BEq` typeclass.\n\nUnlike `x ≠ y` (which is notation for `Ne x y`), this is `Bool` valued instead of\n`Prop` valued. It is mainly intended for programming applications.\n","depth":9},{"term":"fun {α} [BEq α] a => List.countP fun x => x == a","name":"List.count","doc":"`count a l` is the number of occurrences of `a` in `l`. ","depth":9}],"count":131}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫_In_,_∂_»","examples":[{"term":"fun {E} [NormedAddCommGroup E] [NormedSpace ℝ E] f a b μ =>\n  ∫ (x : ℝ) in Set.Ioc a b, f x ∂μ - ∫ (x : ℝ) in Set.Ioc b a, f x ∂μ","name":"intervalIntegral","doc":"The interval integral `∫ x in a..b, f x ∂μ` is defined\nas `∫ x in Ioc a b, f x ∂μ - ∫ x in Ioc b a, f x ∂μ`. If `a ≤ b`, then it equals\n`∫ x in Ioc a b, f x ∂μ`, otherwise it equals `-∫ x in Ioc b a, f x ∂μ`. ","depth":16},{"term":"fun {α} {E} [NormedAddCommGroup E] [NormedSpace ℝ E] {m} μ f =>\n  if hf : MeasureTheory.Integrable f then\n    { measureOf' := fun s => if MeasurableSet s then ∫ (x : α) in s, f x ∂μ else 0,\n      empty' := (_ : (if MeasurableSet ∅ then ∫ (x : α) in ∅, f x ∂μ else 0) = 0),\n      not_measurable' :=\n        (_ : ∀ (s : Set α), ¬MeasurableSet s → (if MeasurableSet s then ∫ (x : α) in s, f x ∂μ else 0) = 0),\n      m_iUnion' :=\n        (_ :\n          ∀ (s : ℕ → Set α),\n            (∀ (i : ℕ), MeasurableSet (s i)) →\n              Pairwise (Disjoint on s) →\n                HasSum (fun i => (fun s => if MeasurableSet s then ∫ (x : α) in s, f x ∂μ else 0) (s i))\n                  ((fun s => if MeasurableSet s then ∫ (x : α) in s, f x ∂μ else 0) (⋃ (i : ℕ), s i))) }\n  else 0","name":"MeasureTheory.Measure.withDensityᵥ","doc":"Given a measure `μ` and an integrable function `f`, `μ.withDensityᵥ f` is\nthe vector measure which maps the set `s` to `∫ₛ f ∂μ`. ","depth":25},{"term":"fun {α} {E} {m0} [NormedAddCommGroup E] [NormedSpace ℝ E] [CompleteSpace E] {μ} {t} {f} {C} [StrictConvexSpace ℝ E] ht\n    h_le =>\n  Eq.mpr\n    (id\n      (Eq.symm (MeasureTheory.Measure.restrict_apply_univ t) ▸\n        Eq.refl\n          (f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ t)]\n              Function.const α (⨍ (x : α) in t, f x ∂μ) ∨\n            ‖∫ (x : α) in t, f x ∂μ‖ < ENNReal.toReal (↑↑μ t) * C)))\n    (ae_eq_const_or_norm_integral_lt_of_norm_le_const h_le)","name":"ae_eq_const_or_norm_set_integral_lt_of_norm_le_const","doc":"If `E` is a strictly convex normed space and `f : α → E` is a function such that `‖f x‖ ≤ C`\na.e. on a set `t` of finite measure, then either this function is a.e. equal to its average value on\n`t`, or the norm of its integral over `t` is strictly less than `(μ t).toReal * C`. ","depth":35},{"term":"fun {f g} {a b} {μ} hab hfi hgi hle hlt =>\n  Eq.mpr (id (Eq.symm (propext sub_pos) ▸ Eq.refl (∫ (x : ℝ) in a..b, f x ∂μ < ∫ (x : ℝ) in a..b, g x ∂μ)))\n    (Eq.mpr\n      (id\n        (Eq.symm (intervalIntegral.integral_sub hgi hfi) ▸\n          Eq.refl (0 < ∫ (x : ℝ) in a..b, g x ∂μ - ∫ (x : ℝ) in a..b, f x ∂μ)))\n      (Eq.mpr (id (intervalIntegral.integral_of_le hab ▸ Eq.refl (0 < ∫ (x : ℝ) in a..b, g x - f x ∂μ)))\n        (Eq.mpr\n          (id\n            (propext\n                (MeasureTheory.integral_pos_iff_support_of_nonneg_ae\n                  (Filter.Eventually.mono hle fun x => sub_nonneg.mpr)\n                  (MeasureTheory.Integrable.sub hgi.left hfi.left)) ▸\n              Eq.refl (0 < ∫ (x : ℝ) in Set.Ioc a b, g x - f x ∂μ)))\n          (Iff.mpr pos_iff_ne_zero\n            (mt (MeasureTheory.measure_mono_null fun x hx => LT.lt.ne' (Iff.mpr sub_pos (Membership.mem.out hx)))\n              hlt)))))","name":"intervalIntegral.integral_lt_integral_of_ae_le_of_measure_setOf_lt_ne_zero","doc":"If `f` and `g` are two functions that are interval integrable on `a..b`, `a ≤ b`,\n`f x ≤ g x` for a.e. `x ∈ Set.Ioc a b`, and `f x < g x` on a subset of `Set.Ioc a b`\nof nonzero measure, then `∫ x in a..b, f x ∂μ < ∫ x in a..b, g x ∂μ`. ","depth":37},{"term":"fun {α} {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {m} {μ} {ι} {f} hf {l} {s} hs =>\n  Eq.mpr\n    (id\n      (propext tendsto_zero_iff_norm_tendsto_zero ▸\n        Eq.refl (Filter.Tendsto (fun i => ∫ (x : α) in s i, f x ∂μ) l (nhds 0))))\n    (id\n      (Eq.mpr\n        (id\n          (congrArg (Filter.Tendsto (fun x => ↑‖∫ (x : α) in s x, f x ∂μ‖₊) l)\n            (congrArg nhds Mathlib.MeasureTheory.Integral.Bochner._auxLemma.15)))\n        (Eq.mpr (id Mathlib.MeasureTheory.Integral.Bochner._auxLemma.16)\n          (Eq.mpr (id Mathlib.MeasureTheory.Integral.Bochner._auxLemma.17)\n            (id\n              (tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds\n                (MeasureTheory.tendsto_set_lintegral_zero (ne_of_lt hf) hs)\n                (fun i => zero_le ↑‖∫ (x : α) in s i, f x ∂μ‖₊) fun i =>\n                MeasureTheory.ennnorm_integral_le_lintegral_ennnorm fun x => f x))))))","name":"MeasureTheory.HasFiniteIntegral.tendsto_set_integral_nhds_zero","doc":"If `f` has finite integral, then `∫ x in s, f x ∂μ` is absolutely continuous in `s`: it tends\nto zero as `μ s` tends to zero. ","depth":37}],"count":131}
{"noDocExamples":[],"kind":"«term_ˣ»","examples":[{"term":"fun {α} [CommMonoid α] => CommGroup.mk (_ : ∀ (x x_1 : αˣ), x * x_1 = x_1 * x)","name":"Units.instCommGroupUnits","doc":"Units of a commutative monoid form a commutative group. ","depth":8},{"term":"fun {R} [Semiring R] => DistribMulAction.toAddAut Rˣ R","name":"AddAut.mulLeft","doc":"Left multiplication by a unit of a semiring as an additive automorphism. ","depth":11},{"term":"fun M [Monoid M] =>\n  { toOneHom := { toFun := Units.val, map_one' := (_ : ↑1 = 1) }, map_mul' := (_ : ∀ (a b : Mˣ), ↑(a * b) = ↑a * ↑b) }","name":"Units.coeHom","doc":"Coercion `Mˣ → M` as a monoid homomorphism. ","depth":12},{"term":"fun n R [DecidableEq n] [Fintype n] [CommRing R] => (Matrix n n R)ˣ","name":"Matrix.GeneralLinearGroup","doc":"`GL n R` is the group of `n` by `n` `R`-matrices with unit determinant.\nDefined as a subtype of matrices","depth":14},{"term":"fun α [Monoid α] =>\n  { toOneHom := { toFun := fun x => (↑x, MulOpposite.op ↑x⁻¹), map_one' := (_ : (1, MulOpposite.op ↑1⁻¹) = 1) },\n    map_mul' :=\n      (_ : ∀ (x y : αˣ), (↑x * ↑y, MulOpposite.op ↑(x * y)⁻¹) = (↑x * ↑y, MulOpposite.op ↑x⁻¹ * MulOpposite.op ↑y⁻¹)) }","name":"Units.embedProduct","doc":"Canonical homomorphism of monoids from `αˣ` into `α × αᵐᵒᵖ`.\nUsed mainly to define the natural topology of `αˣ`. ","depth":15}],"count":131}
{"noDocExamples":[],"kind":"Matrix.vecNotation","examples":[{"term":"fun {L} {α} f t => FirstOrder.Language.func f ![t]","name":"FirstOrder.Language.Functions.apply₁","doc":"Applies a unary function to a term. ","depth":11},{"term":"fun {α} [CommSemiring α] => { order := 2, coeffs := ![1, 1] }","name":"fibRec","doc":"The recurrence relation satisfied by the Fibonacci sequence. ","depth":11},{"term":"fun {L} {α} r t => FirstOrder.Language.Relations.formula r ![t]","name":"FirstOrder.Language.Relations.formula₁","doc":"Applies a unary relation to a term as a formula. ","depth":11},{"term":"fun {L} {α} r t₁ t₂ => FirstOrder.Language.Relations.formula r ![t₁, t₂]","name":"FirstOrder.Language.Relations.formula₂","doc":"Applies a binary relation to two terms as a formula. ","depth":13},{"term":"{ toFun := ![false, true], invFun := fun b => Bool.casesOn b 0 1, left_inv := finTwoEquiv.proof_2,\n  right_inv := finTwoEquiv.proof_3 }","name":"finTwoEquiv","doc":"Equivalence between `Fin 2` and `Bool`. ","depth":13}],"count":129}
{"noDocExamples":[],"kind":"term!_","examples":[{"term":"Nat.bitwise' fun a b => a && !b","name":"Nat.ldiff'","doc":"`ldiff' a b` performs bitwise set difference. For each corresponding\npair of bits taken as booleans, say `aᵢ` and `bᵢ`, it applies the\nboolean operation `aᵢ ∧ bᵢ` to obtain the `iᵗʰ` bit of the result.","depth":5},{"term":"fun x =>\n  match x with\n  | Int.ofNat n => Nat.bodd n\n  | Int.negSucc n => !Nat.bodd n","name":"Int.bodd","doc":"`bodd n` returns `true` if `n` is odd","depth":6},{"term":"fun {α} [BEq α] a as => !List.elem a as","name":"List.notElem","doc":"`notElem a l` is `!(elem a l)`. ","depth":9},{"term":"fun {α} [BEq α] a b => !a == b","name":"bne","doc":"`x != y` is boolean not-equal. It is the negation of `x == y` which is supplied by\nthe `BEq` typeclass.\n\nUnlike `x ≠ y` (which is notation for `Ne x y`), this is `Bool` valued instead of\n`Prop` valued. It is mainly intended for programming applications.\n","depth":9},{"term":"fun x x_1 =>\n  match x, x_1 with\n  | Int.ofNat m, n => Nat.testBit m n\n  | Int.negSucc m, n => !Nat.testBit m n","name":"Int.testBit","doc":"`testBit m n` returns whether the `(n+1)ˢᵗ` least significant bit is `1` or `0`","depth":9}],"count":119}
{"noDocExamples":[],"kind":"Int.«term⌊_⌋»","examples":[{"term":"fun {α} [LinearOrderedRing α] [FloorRing α] a => a - ↑⌊a⌋","name":"Int.fract","doc":"`Int.fract a`, the fractional part of `a`, is `a` minus its floor. ","depth":12},{"term":"fun {K} [LinearOrderedField K] [FloorRing K] v => { b := ⌊v⌋, fr := Int.fract v }","name":"GeneralizedContinuedFraction.IntFractPair.of","doc":"Creates the integer and fractional part of a value `v`, i.e. `⟨⌊v⌋, v - ⌊v⌋⟩`. ","depth":12},{"term":"fun {α} [LinearOrderedRing α] [FloorRing α] x => if 2 * Int.fract x < 1 then ⌊x⌋ else ⌈x⌉","name":"round","doc":"`round` rounds a number to the nearest integer. `round (1 / 2) = 1` ","depth":20},{"term":"fun {K} [LinearOrderedField K] [FloorRing K] {v} =>\n  of_eq_true\n    (Eq.trans (congrFun (congrArg Eq GeneralizedContinuedFraction.of_h_eq_intFractPair_seq1_fst_b) ↑⌊v⌋) (eq_self ↑⌊v⌋))","name":"GeneralizedContinuedFraction.of_h_eq_floor","doc":"The head term of the gcf of `v` is `⌊v⌋`. ","depth":20},{"term":"fun {K} [LinearOrderedField K] [FloorRing K] a n =>\n  Nat.rec\n    (GeneralizedContinuedFraction.IntFractPair.stream_eq_none_of_fr_eq_zero\n      (GeneralizedContinuedFraction.IntFractPair.stream_zero ↑a)\n      (of_eq_true\n        (Eq.trans\n          (congrFun\n            (congrArg Eq\n              (congrArg GeneralizedContinuedFraction.IntFractPair.fr\n                (congrArg (GeneralizedContinuedFraction.IntFractPair.mk ⌊↑a⌋) (Int.fract_intCast a))))\n            0)\n          (eq_self 0))))\n    (fun n ih => Iff.mpr GeneralizedContinuedFraction.IntFractPair.succ_nth_stream_eq_none_iff (Or.inl ih)) n","name":"GeneralizedContinuedFraction.IntFractPair.stream_succ_of_int","doc":"The stream of `IntFractPair`s of an integer stops after the first term.\n","depth":30}],"count":102}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫⁻_In_,_∂_»","examples":[{"term":"fun {α} {m} μ f =>\n  MeasureTheory.Measure.ofMeasurable (fun s x => ∫⁻ (a : α) in s, f a ∂μ) (_ : ∫⁻ (a : α) in ∅, f a ∂μ = 0)\n    (_ :\n      ∀ (s : ℕ → Set α),\n        (∀ (i : ℕ), MeasurableSet (s i)) →\n          Pairwise (Disjoint on s) → ∫⁻ (a : α) in ⋃ (i : ℕ), s i, f a ∂μ = ∑' (i : ℕ), ∫⁻ (a : α) in s i, f a ∂μ)","name":"MeasureTheory.Measure.withDensity","doc":"Given a measure `μ : Measure α` and a function `f : α → ℝ≥0∞`, `μ.withDensity f` is the\nmeasure such that for a measurable set `s` we have `μ.withDensity f s = ∫⁻ a in s, f a ∂μ`. ","depth":15},{"term":"fun {α} {m} μ ν => {f | Measurable f ∧ ∀ (A : Set α), MeasurableSet A → ∫⁻ (x : α) in A, f x ∂μ ≤ ↑↑ν A}","name":"MeasureTheory.Measure.LebesgueDecomposition.measurableLE","doc":"Given two measures `μ` and `ν`, `measurableLE μ ν` is the set of measurable\nfunctions `f`, such that, for all measurable sets `A`, `∫⁻ x in A, f x ∂μ ≤ ν A`.\n\nThis is useful for the Lebesgue decomposition theorem. ","depth":19},{"term":"fun {α} {mα} ρ [MeasureTheory.IsFiniteMeasure ρ] r {s} hs =>\n  let_fun this := Filter.mp_mem (ProbabilityTheory.ofReal_condCdf_ae_eq ρ r) (Filter.univ_mem' (id fun a ha x => ha));\n  Eq.mpr\n    (id\n      (MeasureTheory.set_lintegral_congr_fun hs this ▸\n        Eq.refl\n          (∫⁻ (a : α) in s, ENNReal.ofReal (↑(ProbabilityTheory.condCdf ρ a) ↑r) ∂MeasureTheory.Measure.fst ρ =\n            ↑↑ρ (s ×ˢ Set.Iic ↑r))))\n    (Eq.mpr\n      (id\n        (ProbabilityTheory.set_lintegral_preCdf_fst ρ r hs ▸\n          Eq.refl\n            (∫⁻ (x : α) in s, ProbabilityTheory.preCdf ρ r x ∂MeasureTheory.Measure.fst ρ = ↑↑ρ (s ×ˢ Set.Iic ↑r))))\n      (MeasureTheory.Measure.IicSnd_apply ρ (↑r) hs))","name":"ProbabilityTheory.set_lintegral_condCdf_rat","doc":"Auxiliary lemma for `set_lintegral_cond_cdf`. ","depth":34},{"term":"fun {α} {m m0} {μ} {s} hm {f g} hf hfi hg hgi hgf hs hμs =>\n  Eq.mpr\n    (id\n      (Eq.symm (MeasureTheory.ofReal_integral_norm_eq_lintegral_nnnorm hfi) ▸\n        Eq.refl (∫⁻ (x : α) in s, ↑‖g x‖₊ ∂μ ≤ ∫⁻ (x : α) in s, ↑‖f x‖₊ ∂μ)))\n    (Eq.mpr\n      (id\n        (Eq.symm (MeasureTheory.ofReal_integral_norm_eq_lintegral_nnnorm hgi) ▸\n          Eq.refl (∫⁻ (x : α) in s, ↑‖g x‖₊ ∂μ ≤ ENNReal.ofReal (∫ (x : α) in s, ‖f x‖ ∂μ))))\n      (Eq.mpr\n        (id\n          (propext (ENNReal.ofReal_le_ofReal_iff (MeasureTheory.integral_nonneg fun x => norm_nonneg (f x))) ▸\n            Eq.refl (ENNReal.ofReal (∫ (x : α) in s, ‖g x‖ ∂μ) ≤ ENNReal.ofReal (∫ (x : α) in s, ‖f x‖ ∂μ))))\n        (MeasureTheory.integral_norm_le_of_forall_fin_meas_integral_eq hm hf hfi hg hgi hgf hs hμs)))","name":"MeasureTheory.lintegral_nnnorm_le_of_forall_fin_meas_integral_eq","doc":"Let `m` be a sub-σ-algebra of `m0`, `f` an `m0`-measurable function and `g` an `m`-measurable\nfunction, such that their integrals coincide on `m`-measurable sets with finite measure.\nThen `∫⁻ x in s, ‖g x‖₊ ∂μ ≤ ∫⁻ x in s, ‖f x‖₊ ∂μ` on all `m`-measurable sets with finite\nmeasure. ","depth":40},{"term":"fun {α} {m0} μ {f} h_mf =>\n  Measurable.ennreal_induction\n    (fun c ⦃s⦄ h_ms =>\n      of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg Eq\n              (Eq.trans\n                (Eq.trans (MeasureTheory.lintegral_indicator (fun x => c) (of_eq_true (eq_true h_ms)))\n                  (MeasureTheory.lintegral_const c))\n                (congrArg (HMul.hMul c)\n                  (Eq.trans\n                    (Eq.trans\n                      (MeasureTheory.Measure.restrict_apply\n                        (of_eq_true Mathlib.MeasureTheory.MeasurableSpaceDef._auxLemma.3))\n                      (congrArg (↑↑(MeasureTheory.Measure.withDensity μ f)) (Set.univ_inter s)))\n                    (MeasureTheory.withDensity_apply f (of_eq_true (eq_true h_ms)))))))\n            (Eq.trans\n              (Eq.trans\n                (congrArg (MeasureTheory.lintegral μ)\n                  (funext fun a =>\n                    Eq.trans (Mathlib.MeasureTheory.Integral.Lebesgue._auxLemma.47 s f fun x => c)\n                      (congrFun\n                        (congrArg (Set.indicator s)\n                          (funext fun a => (fun x_0 => (fun x_0 => mul_comm x_0 c) x_0) (f a)))\n                        a)))\n                (MeasureTheory.lintegral_indicator (fun a => c * f a) (of_eq_true (eq_true h_ms))))\n              (MeasureTheory.lintegral_const_mul c (of_eq_true (eq_true h_mf)))))\n          (eq_self (c * ∫⁻ (a : α) in s, f a ∂μ))))\n    (fun ⦃g h⦄ a h_mea_g a h_ind_g h_ind_h =>\n      of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg Eq\n              (Eq.trans (MeasureTheory.lintegral_add_left (of_eq_true (eq_true h_mea_g)) fun a => h a)\n                (congr (congrArg HAdd.hAdd h_ind_g) h_ind_h)))\n            (Eq.trans (congrArg (MeasureTheory.lintegral μ) (funext fun a => mul_add (f a) (g a) (h a)))\n              (MeasureTheory.lintegral_add_left\n                (of_eq_true\n                  (Mathlib.MeasureTheory.Integral.Lebesgue._auxLemma.48 (of_eq_true (eq_true h_mf))\n                    (of_eq_true (eq_true h_mea_g))))\n                fun a => f a * h a)))\n          (eq_self (∫⁻ (a : α), f a * g a ∂μ + ∫⁻ (a : α), f a * h a ∂μ))))\n    fun ⦃g⦄ h_mea_g h_mono_g h_ind =>\n    let_fun this := fun m n hmn x => mul_le_mul_left' (h_mono_g hmn x) (f x);\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (MeasureTheory.lintegral_iSup\n                (of_eq_true\n                  (Eq.trans (forall_congr fun n => (fun n => eq_true (h_mea_g n)) n) (Std.Logic._auxLemma.32 ℕ)))\n                (of_eq_true (eq_true h_mono_g)))\n              (congrArg iSup (funext fun n => (fun n => h_ind n) n))))\n          (Eq.trans (congrArg (MeasureTheory.lintegral μ) (funext fun a => ENNReal.mul_iSup))\n            (MeasureTheory.lintegral_iSup\n              (of_eq_true\n                (Eq.trans\n                  (forall_congr fun n => (fun x_0 => eq_true ((fun x_0 => Measurable.mul h_mf (h_mea_g x_0)) x_0)) n)\n                  (Std.Logic._auxLemma.32 ℕ)))\n              (of_eq_true (eq_true this)))))\n        (eq_self (⨆ (n : ℕ), ∫⁻ (a : α), f a * g n a ∂μ)))","name":"MeasureTheory.lintegral_withDensity_eq_lintegral_mul","doc":"This is Exercise 1.2.1 from [tao2010]. It allows you to express integration of a measurable\nfunction with respect to `(μ.withDensity f)` as an integral with respect to `μ`, called the base\nmeasure. `μ` is often the Lebesgue measure, and in this circumstance `f` is the probability density\nfunction, and `(μ.withDensity f)` represents any continuous random variable as a\nprobability measure, such as the uniform distribution between 0 and 1, the Gaussian distribution,\nthe exponential distribution, the Beta distribution, or the Cauchy distribution (see Section 2.4\nof [wasserman2004]). Thus, this method shows how to one can calculate expectations, variances,\nand other moments as a function of the probability density function.\n ","depth":41}],"count":101}
{"noDocExamples":[],"kind":"«term_≥_»","examples":[{"term":"fun c elimedGE =>\n  decide\n    (Std.RBSet.size c.history ≤\n      1 + Std.RBSet.size (Std.RBSet.union (Std.RBSet.filter c.implicit fun x => decide (x ≥ elimedGE)) c.effective))","name":"Linarith.PComp.maybeMinimal","doc":"Any comparison whose history is not minimal is redundant,\nand need not be included in the new set of comparisons.\n`elimedGE : ℕ` is a natural number such that all variables with index ≥ `elimedGE` have been\nremoved from the system.\n\nThis test is an overapproximation to minimality. It gives necessary but not sufficient conditions.\nIf the history of `c` is minimal, then `c.maybeMinimal` is true,\nbut `c.maybeMinimal` may also be true for some `c` with non-minimal history.\nThus, if `c.maybeMinimal` is false, `c` is known not to be minimal and must be redundant.\nSee https://doi.org/10.1016/B978-0-444-88771-9.50019-2 (Theorem 13).\nThe condition described there considers only implicitly eliminated variables that have been\nofficially eliminated from the system. This is not the case for every implicitly eliminated\nvariable. Consider eliminating `z` from `{x + y + z < 0, x - y - z < 0}`. The result is the set\n`{2*x < 0}`; `y` is implicitly but not officially eliminated.\n\nThis implementation of Fourier-Motzkin elimination processes variables in decreasing order of\nindices. Immediately after a step that eliminates variable `k`, variable `k'` has been eliminated\niff `k' ≥ k`. Thus we can compute the intersection of officially and implicitly eliminated variables\nby taking the set of implicitly eliminated variables with indices ≥ `elimedGE`.\n","depth":17},{"term":"WellFounded.fix Nat.log2.proof_1 fun n a => if h : n ≥ 2 then a (n / 2) (_ : n / 2 < n) + 1 else 0","name":"Nat.log2","doc":"Computes `⌊max 0 (log₂ n)⌋`.\n\n`log2 0 = log2 1 = 0`, `log2 2 = 1`, ..., `log2 (2^i) = i`, etc.\n","depth":17},{"term":"fun {α} {β} [LinearOrderedField α] [Ring β] abv [IsAbsoluteValue abv] x =>\n  { val := fun x_1 => x,\n    property := (_ : ∀ (ε : α), ε > 0 → ∃ i, ∀ (j : ℕ), j ≥ i → abv ((fun x_1 => x) j - (fun x_1 => x) i) < ε) }","name":"CauSeq.const","doc":"The constant Cauchy sequence. ","depth":17},{"term":"fun {P} [SemilatticeSup P] [IsDirected P fun x x_1 => x ≥ x_1] =>\n  {\n    inf := fun I J =>\n      { toLowerSet := I.toLowerSet ⊓ J.toLowerSet, nonempty' := (_ : Set.Nonempty (↑I ∩ ↑J)),\n        directed' :=\n          (_ :\n            ∀ (x : P),\n              x ∈ (I.toLowerSet ⊓ J.toLowerSet).carrier →\n                ∀ (y : P),\n                  y ∈ (I.toLowerSet ⊓ J.toLowerSet).carrier →\n                    ∃ z,\n                      z ∈ (I.toLowerSet ⊓ J.toLowerSet).carrier ∧\n                        (fun x x_1 => x ≤ x_1) x z ∧ (fun x x_1 => x ≤ x_1) y z) } }","name":"Order.Ideal.instInfIdealToLEToPreorderToPartialOrder","doc":"The infimum of two ideals of a co-directed order is their intersection. ","depth":18},{"term":"fun tac stx threshold => do\n  let __do_lift ← heartbeatsPercent\n  if __do_lift ≥ threshold then\n      Lean.logInfoAt stx\n        ((Lean.MessageData.ofFormat ∘ Std.format)\n            (toString \"`\" ++ toString tac ++ toString \"` stopped because it was running out of time.\\n\") ++\n          (Lean.MessageData.ofFormat ∘ Std.format) \"You may get better results using `set_option maxHeartbeats 0`.\")\n    else pure PUnit.unit","name":"reportOutOfHeartbeats","doc":"Log a message if it looks like we ran out of time. ","depth":19}],"count":97}
{"noDocExamples":[],"kind":"«term_→ₗ[_]_»","examples":[{"term":"fun R M [Semiring R] [AddCommMonoid M] [Module R M] => M →ₗ[R] M","name":"Module.End","doc":"Linear endomorphisms of a module, with associated ring structure\n`Module.End.semiring` and algebra structure `Module.End.algebra`. ","depth":16},{"term":"fun R M [CommSemiring R] [AddCommMonoid M] [Module R M] => M →ₗ[R] R","name":"Module.Dual","doc":"The dual space of an R-module M is the R-module of linear maps `M → R`. ","depth":16},{"term":"fun R M [Semiring R] [AddCommMonoid M] [Module R M] => (M →ₗ[R] M)ˣ","name":"LinearMap.GeneralLinearGroup","doc":"The group of invertible linear maps from `M` to itself ","depth":18},{"term":"fun R A [CommSemiring R] [Semiring A] [Algebra R A] =>\n  LinearMap.toSpanSingleton A (Polynomial R →ₗ[R] Polynomial A) (AlgHom.toLinearMap (Polynomial.aeval Polynomial.X))","name":"PolyEquivTensor.toFunBilinear","doc":"(Implementation detail).\nThe function underlying `A ⊗[R] R[X] →ₐ[R] A[X]`,\nas a bilinear function of two arguments.\n","depth":22},{"term":"fun k G V [CommSemiring k] [Monoid G] [AddCommMonoid V] [Module k V] => G →* V →ₗ[k] V","name":"Representation","doc":"A representation of `G` on the `k`-module `V` is a homomorphism `G →* (V →ₗ[k] V)`.\n","depth":23}],"count":97}
{"noDocExamples":[],"kind":"«termC(_,_)»","examples":[{"term":"fun {α} {β} [TopologicalSpace α] [UniformSpace β] =>\n  UniformSpace.mk\n    { uniformity := ContinuousMap.compactConvergenceUniformity,\n      refl := (_ : Filter.principal idRel ≤ ContinuousMap.compactConvergenceUniformity),\n      symm :=\n        (_ :\n          Filter.Tendsto Prod.swap ContinuousMap.compactConvergenceUniformity\n            ContinuousMap.compactConvergenceUniformity),\n      comp :=\n        (_ :\n          ∀ (X : Set (C(α, β) × C(α, β))),\n            X ∈ ContinuousMap.compactConvergenceUniformity →\n              X ∈ Filter.lift' ContinuousMap.compactConvergenceUniformity fun s => compRel s s) }\n    (_ :\n      ∀ (s : Set C(α, β)),\n        IsOpen s ↔\n          ∀ (x : C(α, β)),\n            x ∈ s →\n              {p | p.fst = x → p.snd ∈ s} ∈\n                { uniformity := ContinuousMap.compactConvergenceUniformity,\n                    refl := (_ : Filter.principal idRel ≤ ContinuousMap.compactConvergenceUniformity),\n                    symm :=\n                      (_ :\n                        Filter.Tendsto Prod.swap ContinuousMap.compactConvergenceUniformity\n                          ContinuousMap.compactConvergenceUniformity),\n                    comp :=\n                      (_ :\n                        ∀ (X : Set (C(α, β) × C(α, β))),\n                          X ∈ ContinuousMap.compactConvergenceUniformity →\n                            X ∈\n                              Filter.lift' ContinuousMap.compactConvergenceUniformity fun s =>\n                                compRel s s) }.uniformity)","name":"ContinuousMap.compactConvergenceUniformSpace","doc":"Note that we ensure the induced topology is definitionally the compact-open topology. ","depth":15},{"term":"fun α β [TopologicalSpace α] [CompactSpace α] [MetricSpace β] =>\n  { toFun := BoundedContinuousFunction.mkOfCompact, invFun := BoundedContinuousFunction.toContinuousMap,\n    left_inv := (_ : ∀ (f : C(α, β)), (BoundedContinuousFunction.mkOfCompact f).toContinuousMap = f),\n    right_inv :=\n      (_ : ∀ (f : BoundedContinuousFunction α β), BoundedContinuousFunction.mkOfCompact f.toContinuousMap = f) }","name":"ContinuousMap.equivBoundedOfCompact","doc":"When `α` is compact, the bounded continuous maps `α →ᵇ β` are\nequivalent to `C(α, β)`.\n","depth":16},{"term":"fun α β [TopologicalSpace α] [CompactSpace α] [MetricSpace β] =>\n  { toEquiv := ContinuousMap.equivBoundedOfCompact α β,\n    isometry_toFun :=\n      (_ :\n        ∀ (x x_1 : C(α, β)),\n          edist (Equiv.toFun (ContinuousMap.equivBoundedOfCompact α β) x)\n              (Equiv.toFun (ContinuousMap.equivBoundedOfCompact α β) x_1) =\n            edist (Equiv.toFun (ContinuousMap.equivBoundedOfCompact α β) x)\n              (Equiv.toFun (ContinuousMap.equivBoundedOfCompact α β) x_1)) }","name":"ContinuousMap.isometryEquivBoundedOfCompact","doc":"When `α` is compact, and `β` is a metric space, the bounded continuous maps `α →ᵇ β` are\nisometric to `C(α, β)`.\n","depth":17},{"term":"fun {α} {β} [TopologicalSpace α] [TopologicalSpace β] {γ} [TopologicalSpace γ] [MulOneClass γ] [ContinuousMul γ] g =>\n  { toOneHom := { toFun := fun f => ContinuousMap.comp f g, map_one' := (_ : ContinuousMap.comp 1 g = 1) },\n    map_mul' :=\n      (_ : ∀ (f₁ f₂ : C(β, γ)), ContinuousMap.comp (f₁ * f₂) g = ContinuousMap.comp f₁ g * ContinuousMap.comp f₂ g) }","name":"ContinuousMap.compMonoidHom'","doc":"Composition on the right as a `MonoidHom`. Similar to `MonoidHom.compHom'`. ","depth":22},{"term":"fun {α} {β} [TopologicalSpace α] [TopologicalSpace β] {γ} [TopologicalSpace γ] [AddZeroClass γ] [ContinuousAdd γ] g =>\n  { toZeroHom := { toFun := fun f => ContinuousMap.comp f g, map_zero' := (_ : ContinuousMap.comp 0 g = 0) },\n    map_add' :=\n      (_ : ∀ (f₁ f₂ : C(β, γ)), ContinuousMap.comp (f₁ + f₂) g = ContinuousMap.comp f₁ g + ContinuousMap.comp f₂ g) }","name":"ContinuousMap.compAddMonoidHom'","doc":"Composition on the right as an `AddMonoidHom`. Similar to `AddMonoidHom.compHom'`.","depth":22}],"count":95}
{"noDocExamples":[],"kind":"TensorProduct.«term_⊗ₜ[_]_»","examples":[{"term":"fun R [CommSemiring R] A [Semiring A] [Algebra R A] n [DecidableEq n] [Fintype n] M =>\n  Finset.sum Finset.univ fun p => M p.fst p.snd ⊗ₜ[R] Matrix.stdBasisMatrix p.fst p.snd 1","name":"MatrixEquivTensor.invFun","doc":"(Implementation detail.)\n\nThe bare function `Matrix n n A → A ⊗[R] Matrix n n R`.\n(We don't need to show that it's an algebra map, thankfully --- just that it's an inverse.)\n","depth":23},{"term":"fun R A [CommSemiring R] [Semiring A] [Algebra R A] =>\n  Algebra.TensorProduct.algHomOfLinearMapTensorProduct (PolyEquivTensor.toFunLinear R A)\n    (_ :\n      ∀ (a₁ a₂ : A) (p₁ p₂ : Polynomial R),\n        ↑(PolyEquivTensor.toFunLinear R A) ((a₁ * a₂) ⊗ₜ[R] (p₁ * p₂)) =\n          ↑(PolyEquivTensor.toFunLinear R A) (a₁ ⊗ₜ[R] p₁) * ↑(PolyEquivTensor.toFunLinear R A) (a₂ ⊗ₜ[R] p₂))\n    (_ : ∀ (r : R), ↑(PolyEquivTensor.toFunLinear R A) (↑(algebraMap R A) r ⊗ₜ[R] 1) = ↑(algebraMap R (Polynomial A)) r)","name":"PolyEquivTensor.toFunAlgHom","doc":"(Implementation detail).\nThe algebra homomorphism `A ⊗[R] R[X] →ₐ[R] A[X]`.\n","depth":24},{"term":"fun R [CommSemiring R] A [Semiring A] [Algebra R A] =>\n  Algebra.TensorProduct.algEquivOfLinearEquivTensorProduct (TensorProduct.lid R A)\n    (_ :\n      ∀ (a₁ a₂ : R) (b₁ b₂ : A),\n        ↑(TensorProduct.lid R A) ((a₁ * a₂) ⊗ₜ[R] (b₁ * b₂)) =\n          ↑(TensorProduct.lid R A) (a₁ ⊗ₜ[R] b₁) * ↑(TensorProduct.lid R A) (a₂ ⊗ₜ[R] b₂))\n    (_ : ∀ (a : R), a • 1 = ↑(algebraMap R A) a)","name":"Algebra.TensorProduct.lid","doc":"The base ring is a left identity for the tensor product of algebra, up to algebra isomorphism.\n","depth":24},{"term":"fun R {α} {β} {l} {m} {n} {p} [CommSemiring R] [AddCommMonoid α] [AddCommMonoid β] [Module R α] [Module R β] =>\n  Matrix.kroneckerMap fun x x_1 => x ⊗ₜ[R] x_1","name":"Matrix.kroneckerTMul","doc":"The Kronecker tensor product. This is just a shorthand for `kroneckerMap (⊗ₜ)`.\nPrefer the notation `⊗ₖₜ` rather than this definition. ","depth":26},{"term":"fun R [CommSemiring R] A [Semiring A] [Algebra R A] n [DecidableEq n] [Fintype n] =>\n  Algebra.TensorProduct.algHomOfLinearMapTensorProduct (MatrixEquivTensor.toFunLinear R A n)\n    (_ :\n      ∀ (a₁ a₂ : A) (b₁ b₂ : Matrix n n R),\n        ↑(MatrixEquivTensor.toFunLinear R A n) ((a₁ * a₂) ⊗ₜ[R] (b₁ * b₂)) =\n          ↑(MatrixEquivTensor.toFunLinear R A n) (a₁ ⊗ₜ[R] b₁) * ↑(MatrixEquivTensor.toFunLinear R A n) (a₂ ⊗ₜ[R] b₂))\n    (_ :\n      ∀ (r : R),\n        ↑(MatrixEquivTensor.toFunLinear R A n) (↑(algebraMap R A) r ⊗ₜ[R] 1) = ↑(algebraMap R (Matrix n n A)) r)","name":"MatrixEquivTensor.toFunAlgHom","doc":"The function `(A ⊗[R] Matrix n n R) →ₐ[R] Matrix n n A`, as an algebra homomorphism.\n","depth":27}],"count":90}
{"noDocExamples":[],"kind":"«term_⇨_»","examples":[{"term":"fun α [HeytingAlgebra α] =>\n  let src := BotHom.id α;\n  { toLatticeHom := LatticeHom.id α, map_bot' := (_ : BotHom.toFun (BotHom.id α) ⊥ = ⊥),\n    map_himp' :=\n      (_ :\n        ∀ (x x_1 : α),\n          SupHom.toFun (LatticeHom.id α).toSupHom (x ⇨ x_1) = SupHom.toFun (LatticeHom.id α).toSupHom (x ⇨ x_1)) }","name":"HeytingHom.id","doc":"`id` as a `HeytingHom`. ","depth":10},{"term":"fun {α} [Inf α] [HImp α] a b => (b ⇨ a) ⊓ (a ⇨ b)","name":"bihimp","doc":"The Heyting bi-implication is `(b ⇨ a) ⊓ (a ⇨ b)`. This generalizes equivalence of\npropositions. ","depth":11},{"term":"fun α [BiheytingAlgebra α] =>\n  let src := HeytingHom.id α;\n  let src := CoheytingHom.id α;\n  { toLatticeHom := LatticeHom.id α,\n    map_himp' :=\n      (_ :\n        ∀ (a b : α),\n          SupHom.toFun (HeytingHom.id α).toLatticeHom.toSupHom (a ⇨ b) =\n            SupHom.toFun (HeytingHom.id α).toLatticeHom.toSupHom a ⇨\n              SupHom.toFun (HeytingHom.id α).toLatticeHom.toSupHom b),\n    map_sdiff' :=\n      (_ :\n        ∀ (a b : α),\n          SupHom.toFun (CoheytingHom.id α).toLatticeHom.toSupHom (a \\ b) =\n            SupHom.toFun (CoheytingHom.id α).toLatticeHom.toSupHom a \\\n              SupHom.toFun (CoheytingHom.id α).toLatticeHom.toSupHom b) }","name":"BiheytingHom.id","doc":"`id` as a `BiheytingHom`. ","depth":12},{"term":"fun {F} {α} {β} [BooleanAlgebra α] [BooleanAlgebra β] [inst_2 : BoundedLatticeHomClass F α β] =>\n  let src := inst_2;\n  BiheytingHomClass.mk (_ : ∀ (f : F) (a b : α), ↑f (a ⇨ b) = ↑f a ⇨ ↑f b)\n    (_ : ∀ (f : F) (a b : α), ↑f (a \\ b) = ↑f a \\ ↑f b)","name":"BoundedLatticeHomClass.toBiheytingHomClass","doc":"This can't be an instance because of typeclass loops. ","depth":20},{"term":"fun {α} {β} [HeytingAlgebra α] [HeytingAlgebra β] f f' h =>\n  {\n    toLatticeHom :=\n      { toSupHom := { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) },\n        map_inf' :=\n          (_ :\n            ∀ (a b : α),\n              SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) } (a ⊓ b) =\n                SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) } a ⊓\n                  SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) } b) },\n    map_bot' :=\n      (_ :\n        SupHom.toFun\n            { toSupHom := { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) },\n                map_inf' :=\n                  (_ :\n                    ∀ (a b : α),\n                      SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) } (a ⊓ b) =\n                        SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) } a ⊓\n                          SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) }\n                            b) }.toSupHom\n            ⊥ =\n          ⊥),\n    map_himp' :=\n      (_ :\n        ∀ (a b : α),\n          SupHom.toFun\n              { toSupHom := { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) },\n                  map_inf' :=\n                    (_ :\n                      ∀ (a b : α),\n                        SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) } (a ⊓ b) =\n                          SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) } a ⊓\n                            SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) }\n                              b) }.toSupHom\n              (a ⇨ b) =\n            SupHom.toFun\n                { toSupHom := { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) },\n                    map_inf' :=\n                      (_ :\n                        ∀ (a b : α),\n                          SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) }\n                              (a ⊓ b) =\n                            SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) } a ⊓\n                              SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) }\n                                b) }.toSupHom\n                a ⇨\n              SupHom.toFun\n                { toSupHom := { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) },\n                    map_inf' :=\n                      (_ :\n                        ∀ (a b : α),\n                          SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) }\n                              (a ⊓ b) =\n                            SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) } a ⊓\n                              SupHom.toFun { toFun := f', map_sup' := (_ : ∀ (a b : α), f' (a ⊔ b) = f' a ⊔ f' b) }\n                                b) }.toSupHom\n                b) }","name":"HeytingHom.copy","doc":"Copy of a `HeytingHom` with a new `toFun` equal to the old one. Useful to fix definitional\nequalities. ","depth":24}],"count":83}
{"noDocExamples":[],"kind":"Set.«term⋃₀_»","examples":[{"term":"fun x => ⋃₀ Class.classToCong x","name":"Class.sUnion","doc":"The union of a class is the class of all members of ZFC sets in the class ","depth":3},{"term":"fun {α} r => ⋃₀ setOf (ChainClosure r)","name":"maxChain","doc":"An explicit maximal chain. `maxChain` is taken to be the union of all sets in `ChainClosure`.\n","depth":6},{"term":"fun {α} g =>\n  { IsOpen := TopologicalSpace.GenerateOpen g, isOpen_univ := (_ : TopologicalSpace.GenerateOpen g Set.univ),\n    isOpen_inter :=\n      (_ :\n        ∀ (s t : Set α),\n          TopologicalSpace.GenerateOpen g s →\n            TopologicalSpace.GenerateOpen g t → TopologicalSpace.GenerateOpen g (s ∩ t)),\n    isOpen_sUnion :=\n      (_ :\n        ∀ (S : Set (Set α)),\n          (∀ (s : Set α), s ∈ S → TopologicalSpace.GenerateOpen g s) → TopologicalSpace.GenerateOpen g (⋃₀ S)) }","name":"TopologicalSpace.generateFrom","doc":"The smallest topological space containing the collection `g` of basic sets ","depth":8},{"term":"fun α [Preorder α] =>\n  { IsOpen := IsUpperSet, isOpen_univ := (_ : IsUpperSet Set.univ),\n    isOpen_inter := (_ : ∀ (x x_1 : Set α), IsUpperSet x → IsUpperSet x_1 → IsUpperSet (x ∩ x_1)),\n    isOpen_sUnion := (_ : ∀ (x : Set (Set α)), (∀ (t : Set α), t ∈ x → IsUpperSet t) → IsUpperSet (⋃₀ x)) }","name":"upperSetTopology'","doc":"The set of upper sets forms a topology. In general the upper set topology does not coincide with the\nupper topology.\n","depth":9},{"term":"fun α [Preorder α] =>\n  { IsOpen := IsLowerSet, isOpen_univ := (_ : IsLowerSet Set.univ),\n    isOpen_inter := (_ : ∀ (x x_1 : Set α), IsLowerSet x → IsLowerSet x_1 → IsLowerSet (x ∩ x_1)),\n    isOpen_sUnion := (_ : ∀ (x : Set (Set α)), (∀ (t : Set α), t ∈ x → IsLowerSet t) → IsLowerSet (⋃₀ x)) }","name":"lowerSetTopology'","doc":"The set of lower sets forms a topology. In general the lower set topology does not coincide with the\nlower topology.\n","depth":9}],"count":79}
{"noDocExamples":[],"kind":"«term_&&_»","examples":[{"term":"fun b₁ b₂ => b₁ && b₂","name":"strictAnd","doc":"`strictAnd` is the same as `and`, but it does not use short-circuit evaluation semantics:\nboth sides are evaluated, even if the first value is `false`.\n","depth":4},{"term":"Nat.bitwise' fun a b => a && !b","name":"Nat.ldiff'","doc":"`ldiff' a b` performs bitwise set difference. For each corresponding\npair of bits taken as booleans, say `aᵢ` and `bᵢ`, it applies the\nboolean operation `aᵢ ∧ bᵢ` to obtain the `iᵗʰ` bit of the result.","depth":5},{"term":"fun c => List.isEmpty c.coeffs && decide (c.str = Linarith.Ineq.lt)","name":"Linarith.Comp.isContr","doc":"A `Comp` represents a contradiction if its expression has no coefficients and its strength is <,\nthat is, it represents the fact `0 < 0`.\n ","depth":7},{"term":"fun x y c => x && y || x && c || y && c","name":"Bool.carry","doc":"`carry x y c` is `x && y || x && c || y && c`. ","depth":9},{"term":"fun {α} l p => List.foldr (fun a r => p a && r) true l","name":"List.all","doc":"`O(|l|)`. Returns true if `p` is true for every element of `l`.\n* `all p [a, b, c] = p a && p b && p c`\n","depth":11}],"count":76}
{"noDocExamples":[],"kind":"«term__[_]»","examples":[{"term":"fun {α} a i h => a[USize.toNat i]","name":"Array.uget","doc":"Low-level version of `fget` which is as fast as a C array read.\n`Fin` values are represented as tag pointers in the Lean runtime. Thus,\n`fget` may be slightly slower than `uget`. ","depth":15},{"term":"fun l => (i : Fin (List.length l)) → DihedralGroup l[i]","name":"DihedralGroup.Product","doc":"A finite product of Dihedral groups. ","depth":16},{"term":"fun {α} [BEq α] t x =>\n  {\n    toArray :=\n      Array.push t.toArray\n        (x,\n          ↑(Array.PrefixTable.step t x\n              { val := Array.PrefixTable.size t,\n                isLt := (_ : Array.PrefixTable.size t < Nat.succ (Array.PrefixTable.size t)) })),\n    valid :=\n      (_ :\n        ∀ {i : ℕ}\n          (x_1 :\n            i <\n              Array.size\n                (Array.push t.toArray\n                  (x,\n                    ↑(Array.PrefixTable.step t x\n                        { val := Array.PrefixTable.size t,\n                          isLt := (_ : Array.PrefixTable.size t < Nat.succ (Array.PrefixTable.size t)) })))),\n          (Array.push t.toArray\n                  (x,\n                    ↑(Array.PrefixTable.step t x\n                        { val := Array.PrefixTable.size t,\n                          isLt := (_ : Array.PrefixTable.size t < Nat.succ (Array.PrefixTable.size t)) })))[i].snd ≤\n            i) }","name":"Array.PrefixTable.extend","doc":"Extend a prefix table by one element\n\nIf `t` is the prefix table for `xs` then `t.extend x` is the prefix table for `xs.push x`.\n","depth":19},{"term":"fun {α} {β} {δ} [AddZeroClass δ] [Min δ] C xs ys =>\n  match suffixLevenshtein C xs ys with\n  | { val := r, property := w } => r[0]","name":"levenshtein","doc":"`levenshtein C xs ys` computes the Levenshtein distance\n(using the cost functions provided by a `C : Cost α β δ`)\nfrom the list `xs` to the list `ys`.\n\nNote that if the cost functions do not satisfy the inequalities\n* `C.delete a + C.insert b ≥ C.substitute a b`\n* `C.substitute a b + C.substitute b c ≥ C.substitute a c`\n(or if any values are negative)\nthen the edit distance calculated here may not agree with the general\ngeodesic distance on the edit graph.\n","depth":22},{"term":"fun {α} self k => do\n  let r ←\n    let col := { start := 0, stop := Array.size self, step := 1 };\n      forIn' col { fst := none, snd := PUnit.unit } fun i h r =>\n        let r := r.snd;\n        match self[i] with\n        | (k', vs) => do\n          let __do_lift ← Lean.Meta.isDefEq k' k\n          if __do_lift = true then pure (ForInStep.done { fst := some (i, vs), snd := PUnit.unit })\n            else do\n              pure PUnit.unit\n              pure (ForInStep.yield { fst := none, snd := PUnit.unit })\n  let __do_jp : PUnit.{1} → Lean.MetaM (ℕ × List α) := fun y => pure (Array.size self, [])\n  match r.fst with\n    | none => do\n      let y ← pure PUnit.unit\n      __do_jp y\n    | some a => pure a","name":"Linarith.ExprMultiMap.find","doc":"Retrieves the list of values at a key, as well as the index of the key for later modification.\n(If the key is not in the map it returns `self.size` as the index.) ","depth":28}],"count":74}
{"noDocExamples":[],"kind":"List.«term_~_»","examples":[{"term":"fun {α} [SizeOf α] s => Quot.liftOn s sizeOf (_ : ∀ (x x_1 : List α), x ~ x_1 → sizeOf x = sizeOf x_1)","name":"Multiset.sizeOf","doc":"defines a size for a multiset by referring to the size of the underlying list ","depth":10},{"term":"fun {α} a s =>\n  Quot.liftOn s (fun l => a ∈ l) (_ : ∀ (l₁ l₂ : List α), l₁ ~ l₂ → (fun l => a ∈ l) l₁ = (fun l => a ∈ l) l₂)","name":"Multiset.Mem","doc":"`a ∈ s` means that `a` has nonzero multiplicity in `s`. ","depth":11},{"term":"fun {α} p [DecidablePred p] s =>\n  Quot.liftOn s (List.countP fun b => decide (p b))\n    (_ :\n      ∀ (_l₁ _l₂ : List α),\n        _l₁ ~ _l₂ → List.countP (fun x => decide (p x)) _l₁ = List.countP (fun x => decide (p x)) _l₂)","name":"Multiset.countP","doc":"`countP p s` counts the number of elements of `s` (with multiplicity) that\nsatisfy `p`. ","depth":12},{"term":"fun α [Subsingleton α] =>\n  { toFun := Multiset.ofList, invFun := Quot.lift id (_ : ∀ (a b : List α), a ~ b → a = b),\n    left_inv :=\n      (_ :\n        ∀ (x : List α),\n          Quot.lift id (_ : ∀ (a b : List α), a ~ b → a = b) ↑x =\n            Quot.lift id (_ : ∀ (a b : List α), a ~ b → a = b) ↑x),\n    right_inv := (_ : ∀ (m : Multiset α), ↑(Quot.lift id (_ : ∀ (a b : List α), a ~ b → a = b) m) = m) }","name":"Multiset.subsingletonEquiv","doc":"The equivalence between lists and multisets of a subsingleton type. ","depth":12},{"term":"fun {α} =>\n  {\n    toZeroHom :=\n      {\n        toFun := fun s =>\n          Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂),\n        map_zero' :=\n          (_ :\n            (fun s =>\n                  Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂))\n                0 =\n              (fun s =>\n                  Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂))\n                0) },\n    map_add' :=\n      (_ :\n        ∀ (s t : Multiset α),\n          ZeroHom.toFun\n              {\n                toFun := fun s =>\n                  Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂),\n                map_zero' :=\n                  (_ :\n                    (fun s =>\n                          Quot.liftOn s List.length\n                            (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂))\n                        0 =\n                      (fun s =>\n                          Quot.liftOn s List.length\n                            (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂))\n                        0) }\n              (s + t) =\n            ZeroHom.toFun\n                {\n                  toFun := fun s =>\n                    Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂),\n                  map_zero' :=\n                    (_ :\n                      (fun s =>\n                            Quot.liftOn s List.length\n                              (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂))\n                          0 =\n                        (fun s =>\n                            Quot.liftOn s List.length\n                              (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂))\n                          0) }\n                s +\n              ZeroHom.toFun\n                {\n                  toFun := fun s =>\n                    Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂),\n                  map_zero' :=\n                    (_ :\n                      (fun s =>\n                            Quot.liftOn s List.length\n                              (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂))\n                          0 =\n                        (fun s =>\n                            Quot.liftOn s List.length\n                              (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂))\n                          0) }\n                t) }","name":"Multiset.card","doc":"The cardinality of a multiset is the sum of the multiplicities\nof all its elements, or simply the length of the underlying list. ","depth":13}],"count":74}
{"noDocExamples":[],"kind":"«term∫_In_.._,_»","examples":[{"term":"fun s X => ∫ (x : ℝ) in 0 ..X, ↑(rexp (-x)) * ↑x ^ (s - 1)","name":"Complex.partialGamma","doc":"The indefinite version of the `Γ` function, `Γ(s, X) = ∫ x ∈ 0..X, exp(-x) x ^ (s - 1)`. ","depth":15},{"term":"fun u v => ∫ (x : ℝ) in 0 ..1, ↑x ^ (u - 1) * (1 - ↑x) ^ (v - 1)","name":"Complex.betaIntegral","doc":"The Beta function `Β (u, v)`, defined as `∫ x:ℝ in 0..1, x ^ (u - 1) * (1 - x) ^ (v - 1)`. ","depth":16},{"term":"fun b c T =>\n  ∫ (y : ℝ) in 0 ..c, Complex.I * (cexp (-b * (↑T + ↑y * Complex.I) ^ 2) - cexp (-b * (↑T - ↑y * Complex.I) ^ 2))","name":"GaussianFourier.verticalIntegral","doc":"The integral of the Gaussian function over the vertical edges of a rectangle\nwith vertices at `(±T, 0)` and `(±T, c)`.  ","depth":22},{"term":"fun {E} [NormedAddCommGroup E] [NormedSpace ℝ E] {v} f =>\n  { toFun := fun t => v.x₀ + ∫ (τ : ℝ) in ↑v.t₀..↑t, PicardLindelof.FunSpace.vComp f τ,\n    map_t₀' := (_ : v.x₀ + ∫ (x : ℝ) in ↑v.t₀..↑v.t₀, PicardLindelof.FunSpace.vComp f x = v.x₀),\n    lipschitz' := (_ : LipschitzWith v.C fun t => v.x₀ + ∫ (τ : ℝ) in ↑v.t₀..↑t, PicardLindelof.FunSpace.vComp f τ) }","name":"PicardLindelof.FunSpace.next","doc":"The Picard-Lindelöf operator. This is a contracting map on `PicardLindelof.FunSpace v` such\nthat the fixed point of this map is the solution of the corresponding ODE.\n\nMore precisely, some iteration of this map is a contracting map. ","depth":23},{"term":"fun {T} {g} hg h_int h₀ hT =>\n  Filter.tendsto_atBot_mono (Function.Periodic.integral_le_sSup_add_zsmul_of_pos hg h_int hT)\n    (Filter.tendsto_atBot_add_const_left Filter.atBot (sSup ((fun t => ∫ (x : ℝ) in 0 ..t, g x) '' Set.Icc 0 T))\n      (Filter.Tendsto.atBot_zsmul_const h₀\n        (Filter.Tendsto.comp tendsto_floor_atBot\n          (Filter.Tendsto.atBot_mul_const (Iff.mpr inv_pos hT) Filter.tendsto_id))))","name":"Function.Periodic.tendsto_atBot_intervalIntegral_of_pos","doc":"If `g : ℝ → ℝ` is periodic with period `T > 0` and `0 < ∫ x in 0..T, g x`, then\n`t ↦ ∫ x in 0..t, g x` tends to `-∞` as `t` tends to `-∞`. ","depth":27}],"count":72}
{"noDocExamples":[],"kind":"Function.term_On_","examples":[{"term":"fun {α} s =>\n  { Has := MeasurableSpace.DynkinSystem.GenerateHas s, has_empty := (_ : MeasurableSpace.DynkinSystem.GenerateHas s ∅),\n    has_compl :=\n      (_ : ∀ {x : Set α}, MeasurableSpace.DynkinSystem.GenerateHas s x → MeasurableSpace.DynkinSystem.GenerateHas s xᶜ),\n    has_iUnion_nat :=\n      (_ :\n        ∀ {x : ℕ → Set α},\n          Pairwise (Disjoint on x) →\n            (∀ (i : ℕ), MeasurableSpace.DynkinSystem.GenerateHas s (x i)) →\n              MeasurableSpace.DynkinSystem.GenerateHas s (⋃ (i : ℕ), x i)) }","name":"MeasurableSpace.DynkinSystem.generate","doc":"The least Dynkin system containing a collection of basic sets. ","depth":8},{"term":"fun {α} m =>\n  { Has := MeasureTheory.OuterMeasure.IsCaratheodory m,\n    has_empty := (_ : MeasureTheory.OuterMeasure.IsCaratheodory m ∅),\n    has_compl :=\n      (_ :\n        ∀ {a : Set α}, MeasureTheory.OuterMeasure.IsCaratheodory m a → MeasureTheory.OuterMeasure.IsCaratheodory m aᶜ),\n    has_iUnion_nat :=\n      (_ :\n        ∀ {f : ℕ → Set α},\n          Pairwise (Disjoint on f) →\n            (∀ (i : ℕ), MeasureTheory.OuterMeasure.IsCaratheodory m (f i)) →\n              ∀ (hn : Set α), ↑m hn = ↑m (hn ∩ ⋃ (i : ℕ), f i) + ↑m (hn \\ ⋃ (i : ℕ), f i)) }","name":"MeasureTheory.OuterMeasure.caratheodoryDynkin","doc":"The Carathéodory-measurable sets for an outer measure `m` form a Dynkin system.  ","depth":10},{"term":"fun {α} {β} f r => { r := Setoid.Rel r on f, iseqv := (_ : Equivalence (Setoid.r on f)) }","name":"Setoid.comap","doc":"Given a function `f : α → β`, an equivalence relation `r` on `β` induces an equivalence\nrelation on `α` defined by '`x ≈ y` iff `f(x)` is related to `f(y)` by `r`'.\n\nSee note [reducible non-instances]. ","depth":11},{"term":"fun {α} {x} μ =>\n  { toOuterMeasure := ↑μ,\n    m_iUnion :=\n      (_ :\n        ∀ (s : ℕ → Set (MeasureTheory.NullMeasurableSpace α)),\n          (∀ (i : ℕ), MeasurableSet (s i)) → Pairwise (Disjoint on s) → ↑↑μ (⋃ (i : ℕ), s i) = ∑' (i : ℕ), ↑↑μ (s i)),\n    trimmed := (_ : MeasureTheory.OuterMeasure.trim ↑μ = ↑μ) }","name":"MeasureTheory.Measure.completion","doc":"Given a measure we can complete it to a (complete) measure on all null measurable sets. ","depth":11},{"term":"fun {ι} [Fintype ι] I =>\n  { boxes := Finset.map (BoxIntegral.Box.splitCenterBoxEmb I) Finset.univ,\n    le_of_mem' :=\n      (_ : ∀ (a : BoxIntegral.Box ι), a ∈ Finset.map (BoxIntegral.Box.splitCenterBoxEmb I) Finset.univ → a ≤ I),\n    pairwiseDisjoint :=\n      (_ :\n        Set.Pairwise (↑(Finset.map (BoxIntegral.Box.splitCenterBoxEmb I) Finset.univ))\n          (Disjoint on BoxIntegral.Box.toSet)) }","name":"BoxIntegral.Prepartition.splitCenter","doc":"Split a box in `ℝⁿ` into `2 ^ n` boxes by hyperplanes passing through its center. ","depth":11}],"count":69}
{"noDocExamples":[],"kind":"MeasureTheory.«term∀ᵐ_∂_,_»","examples":[{"term":"fun {α} {m0} {μ} {s t} hst {p} =>\n  of_eq_true\n    (Eq.trans\n      (implies_congr\n        (congrArg (Filter.Eventually fun x => p x)\n          (congrArg MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict_congr_set hst)))\n        (Eq.refl (∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ t, p x)))\n      Std.Logic._auxLemma.5)","name":"MeasureTheory.ae_restrict_of_ae_eq_of_ae_restrict","doc":"If two measurable sets are ae_eq then any proposition that is almost everywhere true on one\nis almost everywhere true on the other ","depth":22},{"term":"fun {Ω} {ι} {m} [Preorder ι] {E} [Zero E] [TopologicalSpace E] f ℱ μ =>\n  if h :\n      ∃ g,\n        MeasureTheory.StronglyMeasurable g ∧\n          ∀ᵐ (ω : Ω) ∂μ, Filter.Tendsto (fun n => f n ω) Filter.atTop (nhds (g ω)) then\n    Classical.choose h\n  else 0","name":"MeasureTheory.Filtration.limitProcess","doc":"Given a process `f` and a filtration `ℱ`, if `f` converges to some `g` almost everywhere and\n`g` is `⨆ n, ℱ n`-measurable, then `limitProcess f ℱ μ` chooses said `g`, else it returns 0.\n\nThis definition is used to phrase the a.e. martingale convergence theorem\n`Submartingale.ae_tendsto_limitProcess` where an L¹-bounded submartingale `f` adapted to `ℱ`\nconverges to `limitProcess f ℱ μ` `μ`-almost everywhere. ","depth":28},{"term":"fun {f} {s} hf hs =>\n  Eq.mpr\n    (id\n      (propext (MeasureTheory.ae_restrict_iff' hs) ▸\n        Eq.refl (∀ᵐ (x : ℝ) ∂MeasureTheory.Measure.restrict MeasureTheory.volume s, DifferentiableWithinAt ℝ f s x)))\n    (MonotoneOn.ae_differentiableWithinAt_of_mem hf)","name":"MonotoneOn.ae_differentiableWithinAt","doc":"A real function which is monotone on a set is differentiable Lebesgue-almost everywhere on\nthis set. This version assumes that `s` is measurable and uses `volume.restrict s`.\nFor a formulation without measurability assumption,\nsee `MonotoneOn.ae_differentiableWithinAt_of_mem`. ","depth":29},{"term":"fun {V} [NormedAddCommGroup V] [NormedSpace ℝ V] [FiniteDimensional ℝ V] {f} {s} h hs =>\n  Eq.mpr\n    (id\n      (propext (MeasureTheory.ae_restrict_iff' hs) ▸\n        Eq.refl (∀ᵐ (x : ℝ) ∂MeasureTheory.Measure.restrict MeasureTheory.volume s, DifferentiableWithinAt ℝ f s x)))\n    (LocallyBoundedVariationOn.ae_differentiableWithinAt_of_mem h)","name":"LocallyBoundedVariationOn.ae_differentiableWithinAt","doc":"A real function into a finite dimensional real vector space with bounded variation on a set\nis differentiable almost everywhere in this set. ","depth":33},{"term":"fun {α} {m} μ ν [MeasureTheory.SigmaFinite μ] =>\n  let_fun this := fun n =>\n    Eq.mpr\n      (id\n        (Eq.symm (propext (MeasureTheory.ae_restrict_iff' (MeasureTheory.measurable_spanningSets μ n))) ▸\n          Eq.refl (∀ᵐ (x : α) ∂ν, x ∈ MeasureTheory.spanningSets μ n → MeasureTheory.Measure.rnDeriv μ ν x < ⊤)))\n      (MeasureTheory.ae_lt_top (MeasureTheory.Measure.measurable_rnDeriv μ ν)\n        (LT.lt.ne\n          (MeasureTheory.Measure.lintegral_rnDeriv_lt_top_of_measure_ne_top ν\n            (LT.lt.ne (MeasureTheory.measure_spanningSets_lt_top μ n)))));\n  Filter.mp_mem (Iff.mpr MeasureTheory.ae_all_iff this)\n    (Filter.univ_mem'\n      (id fun a hx => hx (MeasureTheory.spanningSetsIndex μ a) (MeasureTheory.mem_spanningSetsIndex μ a)))","name":"MeasureTheory.Measure.rnDeriv_lt_top","doc":"The Radon-Nikodym derivative of a sigma-finite measure `μ` with respect to another\nmeasure `ν` is `ν`-almost everywhere finite. ","depth":34}],"count":67}
{"noDocExamples":[],"kind":"Lean.Parser.Term.nomatch","examples":[{"term":"fun {C} a => nomatch a","name":"PEmpty.elim","doc":"Ex falso, the nondependent eliminator for the `PEmpty` type. ","depth":5},{"term":"fun {C} a => nomatch a","name":"Empty.elim","doc":"Ex falso, the nondependent eliminator for the `Empty` type. ","depth":5},{"term":"fun {C} a => nomatch a","name":"Fin2.elim0","doc":"Ex falso. The dependent eliminator for the empty `Fin2 0` type. ","depth":9},{"term":"fun {α} a => nomatch a","name":"Vector3.nil","doc":"The empty vector ","depth":9},{"term":"fun {α} {l} =>\n  (fun {α} {l} =>\n      {\n        mp := fun h =>\n          match l, h with\n          | [], h => rfl\n          | head :: tail, h => nomatch h (List.Mem.head tail),\n        mpr := fun x =>\n          match [], x with\n          | .(l), Eq.refl l => List.Subset.refl l }).mp","name":"List.eq_nil_of_subset_nil","doc":"**Alias** of the forward direction of `List.subset_nil`.","depth":22}],"count":67}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term⊤__»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasTerminal C] ι X =>\n  CategoryTheory.Limits.WidePullbackShape.wideCospan (⊤_ C) (fun x => X) fun x => CategoryTheory.Limits.terminal.from X","name":"CategoryTheory.CechNerveTerminalFrom.wideCospan","doc":"The diagram `Option ι ⥤ C` sending `none` to the terminal object and `some j` to `X`. ","depth":11},{"term":"fun X =>\n  equivOfSubsingletonOfSubsingleton (fun h => Equiv.unique (CategoryTheory.Limits.terminalIsoIsTerminal h).symm.toEquiv)\n    fun x =>\n    CategoryTheory.Limits.IsTerminal.ofIso CategoryTheory.Limits.terminalIsTerminal\n      (Equiv.toIso (Equiv.equivOfUnique (⊤_ Type u) X))","name":"CategoryTheory.Limits.Types.isTerminalEquivUnique","doc":"A type is terminal if and only if it contains exactly one element. ","depth":12},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] {D} [CategoryTheory.Category.{v₂, u₂} D] G\n    [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) G] =>\n  CategoryTheory.Limits.IsTerminal.isTerminalObj G (⊤_ C) CategoryTheory.Limits.terminalIsTerminal","name":"CategoryTheory.Limits.isLimitOfHasTerminalOfPreservesLimit","doc":"If `G` preserves the terminal object and `C` has a terminal object, then the image of the terminal\nobject is terminal.\n","depth":15},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasTerminal C] P\n    [CategoryTheory.Limits.HasBinaryProduct P (⊤_ C)] =>\n  CategoryTheory.Iso.mk CategoryTheory.Limits.prod.fst\n    (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id P) (CategoryTheory.Limits.terminal.from P))","name":"CategoryTheory.Limits.prod.rightUnitor","doc":"The right unitor isomorphism for binary products with the terminal object. ","depth":16},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] {D} [CategoryTheory.Category.{v₂, u₂} D] G\n    [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Limits.HasTerminal D] =>\n  CategoryTheory.Limits.terminal.from (G.obj (⊤_ C))","name":"CategoryTheory.Limits.terminalComparison","doc":"The comparison morphism from the image of a terminal object to the terminal object in the target\ncategory.\nThis is an isomorphism iff `G` preserves terminal objects, see\n`CategoryTheory.Limits.PreservesTerminal.ofIsoComparison`.\n","depth":16}],"count":66}
{"noDocExamples":[],"kind":"Vector.«term_::ᵥ_»","examples":[{"term":"fun x =>\n  match x with\n  | 0 => Vector.nil\n  | Nat.succ n => Vector.append (Vector.replicate n false) (true ::ᵥ Vector.nil)","name":"Bitvec.one","doc":"Create a bitvector of length `n` whose `n-1`st entry is 1 and other entries are 0. ","depth":10},{"term":"fun {α} {n} xs x => Vector.append xs (x ::ᵥ Vector.nil)","name":"Vector.snoc","doc":"Append a single element to the end of a vector ","depth":11},{"term":"fun {α} {n} a =>\n  Quotient.map (Vector.cons a) (_ : ∀ (x x_1 : Vector α n), x ≈ x_1 → (fun x x_2 => x ≈ x_2) (a ::ᵥ x) (a ::ᵥ x_1))","name":"Sym.cons'","doc":"This is `cons` but for the alternative `Sym'` definition.\n","depth":11},{"term":"fun x x_1 x_2 =>\n  match x, x_1, x_2 with\n  | 0, x, x_3 => Vector.nil\n  | Nat.succ n, x, i => Vector.head x ::ᵥ Vector.shiftRightFill (Vector.tail x) i (Vector.head x)","name":"Bitvec.sshr","doc":"signed shift right ","depth":14},{"term":"fun {n} x y c =>\n  let f := fun x y c => (Bool.carry x y c, Bool.xor3 x y c);\n  match Vector.mapAccumr₂ f x y c with\n  | (c, z) => c ::ᵥ z","name":"Bitvec.adc","doc":"Add with carry (no overflow) ","depth":16}],"count":65}
{"noDocExamples":[],"kind":"«term_>>=_»","examples":[{"term":"fun {α} c => c >>= id","name":"Computation.join","doc":"Flatten a computation of computations into a single computation. ","depth":8},{"term":"fun {α} {m} {β} [Bind m] f ma => ma >>= f","name":"Bind.bindLeft","doc":"Same as `Bind.bind` but with arguments swapped. ","depth":12},{"term":"fun {α} x => SlimCheck.Gen.arrayOf x >>= pure ∘ Array.toList","name":"SlimCheck.Gen.listOf","doc":"Create a `List` of examples using `x`. The size is controlled\nby the size parameter of `Gen`. ","depth":13},{"term":"fun {α} {m} {β γ} [Bind m] f₁ f₂ a => f₁ a >>= f₂","name":"Bind.kleisliRight","doc":"Left-to-right composition of Kleisli arrows. ","depth":14},{"term":"fun {α} {m} {β γ} [Bind m] f₂ f₁ a => f₁ a >>= f₂","name":"Bind.kleisliLeft","doc":"Right-to-left composition of Kleisli arrows. ","depth":14}],"count":65}
{"noDocExamples":[],"kind":"«termΠ₀_,_»","examples":[{"term":"fun ι β [(i : ι) → AddCommMonoid (β i)] => Π₀ (i : ι), β i","name":"DirectSum","doc":"`DirectSum β` is the direct sum of a family of additive commutative monoids `β i`.\n\nNote: `open DirectSum` will enable the notation `⨁ i, β i` for `DirectSum β`. ","depth":11},{"term":"fun {ι} {M} [DecidableEq ι] [Zero M] [(m : M) → Decidable (m ≠ 0)] =>\n  { toFun := Finsupp.toDFinsupp, invFun := DFinsupp.toFinsupp,\n    left_inv := (_ : ∀ (f : ι →₀ M), DFinsupp.toFinsupp (Finsupp.toDFinsupp f) = f),\n    right_inv := (_ : ∀ (f : Π₀ (x : ι), M), Finsupp.toDFinsupp (DFinsupp.toFinsupp f) = f) }","name":"finsuppEquivDFinsupp","doc":"`Finsupp.toDFinsupp` and `DFinsupp.toFinsupp` together form an equiv. ","depth":15},{"term":"fun {α} [DecidableEq α] =>\n  AddMonoidHom.toAddEquiv Multiset.toDFinsupp DFinsupp.toMultiset\n    (_ : AddMonoidHom.comp DFinsupp.toMultiset Multiset.toDFinsupp = AddMonoidHom.id (Multiset α))\n    (_ : AddMonoidHom.comp Multiset.toDFinsupp DFinsupp.toMultiset = AddMonoidHom.id (Π₀ (x : α), ℕ))","name":"Multiset.equivDFinsupp","doc":"`Multiset.toDFinsupp` as an `AddEquiv`. ","depth":15},{"term":"fun {ι} {α} [(i : ι) → Zero (α i)] [(i : ι) → LE (α i)] =>\n  { toEmbedding := { toFun := FunLike.coe, inj' := (_ : Function.Injective fun f => ↑f) },\n    map_rel_iff' :=\n      (_ :\n        ∀ {a b : Π₀ (i : ι), α i},\n          ↑{ toFun := FunLike.coe, inj' := (_ : Function.Injective fun f => ↑f) } a ≤\n              ↑{ toFun := FunLike.coe, inj' := (_ : Function.Injective fun f => ↑f) } b ↔\n            ↑{ toFun := FunLike.coe, inj' := (_ : Function.Injective fun f => ↑f) } a ≤\n              ↑{ toFun := FunLike.coe, inj' := (_ : Function.Injective fun f => ↑f) } b) }","name":"DFinsupp.orderEmbeddingToFun","doc":"The order on `DFinsupp`s over a partial order embeds into the order on functions ","depth":18},{"term":"fun {ι} β [(i : ι) → AddZeroClass (β i)] p [DecidablePred p] =>\n  { toZeroHom := { toFun := DFinsupp.filter p, map_zero' := (_ : DFinsupp.filter p 0 = 0) },\n    map_add' := (_ : ∀ (f g : Π₀ (i : ι), β i), DFinsupp.filter p (f + g) = DFinsupp.filter p f + DFinsupp.filter p g) }","name":"DFinsupp.filterAddMonoidHom","doc":"`DFinsupp.filter` as an `AddMonoidHom`. ","depth":20}],"count":62}
{"noDocExamples":[],"kind":"«term∑ᶠ_,_»","examples":[{"term":"fun {ι} {X} [TopologicalSpace X] {s} f =>\n  PartitionOfUnity.mk s (fun i => ContinuousMap.mk (BumpCovering.toPOUFun f i))\n    (_ : LocallyFinite fun i => Function.support ↑((fun i => ContinuousMap.mk (BumpCovering.toPOUFun f i)) i))\n    (_ : ∀ (i : ι) (x : X), 0 ≤ ↑(↑f i) x * ∏ᶠ (j : ι) (_ : WellOrderingRel j i), (1 - ↑(↑f j) x))\n    (_ : ∀ (x : X), x ∈ s → ∑ᶠ (i : ι), ↑((fun i => ContinuousMap.mk (BumpCovering.toPOUFun f i)) i) x = 1)\n    (_ : ∀ (x : X), ∑ᶠ (i : ι), ↑((fun i => ContinuousMap.mk (BumpCovering.toPOUFun f i)) i) x ≤ 1)","name":"BumpCovering.toPartitionOfUnity","doc":"The partition of unity defined by a `BumpCovering`.\n\nThe partition of unity is given by the formula `g i x = f i x * ∏ᶠ j < i, (1 - f j x)`. In other\nwords, `g i x = ∏ᶠ j < i, (1 - f j x) - ∏ᶠ j ≤ i, (1 - f j x)`, so\n`∑ᶠ i, g i x = 1 - ∏ᶠ j, (1 - f j x)`. If `x ∈ s`, then one of `f j x` equals one, hence the product\nof `1 - f j x` vanishes, and `∑ᶠ i, g i x = 1`.\n\nIn order to avoid an assumption `LinearOrder ι`, we use `WellOrderingRel` instead of `(<)`. ","depth":19},{"term":"fun {Γ} {R} [PartialOrder Γ] [AddCommMonoid R] {α} s =>\n  { coeff := fun g => ∑ᶠ (i : α), HahnSeries.coeff (↑s i) g,\n    isPwo_support' := (_ : Set.IsPwo (Function.support fun g => ∑ᶠ (i : α), HahnSeries.coeff (↑s i) g)) }","name":"HahnSeries.SummableFamily.hsum","doc":"The infinite sum of a `SummableFamily` of Hahn series. ","depth":24},{"term":"fun {α} {M} [AddCommMonoid M] {f} {s} hf =>\n  Eq.mpr (id (Eq.symm (finsum_mem_zero s) ▸ Eq.refl (∑ᶠ (i : α) (_ : i ∈ s), f i = 0))) (finsum_mem_congr rfl hf)","name":"finsum_mem_of_eqOn_zero","doc":"If a function `f` equals `0` on a set `s`, then the product of `f i` over `i ∈ s`\nequals `0`.","depth":28},{"term":"fun {α} {M} [AddCommMonoid M] {f} {a} =>\n  Eq.mpr (id (Eq.symm (Finset.coe_singleton a) ▸ Eq.refl (∑ᶠ (i : α) (_ : i ∈ {a}), f i = f a)))\n    (Eq.mpr (id (finsum_mem_coe_finset (fun i => f i) {a} ▸ Eq.refl (∑ᶠ (i : α) (_ : i ∈ ↑{a}), f i = f a)))\n      (Eq.mpr (id (Finset.sum_singleton ▸ Eq.refl ((Finset.sum {a} fun i => f i) = f a))) (Eq.refl (f a))))","name":"finsum_mem_singleton","doc":"The sum of `f i` over `i ∈ {a}` equals `f a`.","depth":29},{"term":"fun {α} {β} {M} [AddCommMonoid M] {f} {g} hg =>\n  Eq.mpr (id (Eq.symm Set.image_univ ▸ Eq.refl (∑ᶠ (i : α) (_ : i ∈ Set.range g), f i = ∑ᶠ (j : β), f (g j))))\n    (Eq.mpr\n      (id\n        (finsum_mem_image'\n            (Eq.mpr\n              (id\n                (Set.univ_inter (Function.support ((fun i => f i) ∘ g)) ▸\n                  Eq.refl (Set.InjOn g (Set.univ ∩ Function.support ((fun i => f i) ∘ g)))))\n              hg) ▸\n          Eq.refl (∑ᶠ (i : α) (_ : i ∈ g '' Set.univ), f i = ∑ᶠ (j : β), f (g j))))\n      (Eq.mpr\n        (id\n          ((finsum_mem_univ fun j => f (g j)) ▸ Eq.refl (∑ᶠ (j : β) (_ : j ∈ Set.univ), f (g j) = ∑ᶠ (j : β), f (g j))))\n        (Eq.refl (∑ᶠ (i : β), f (g i)))))","name":"finsum_mem_range'","doc":"The sum of `f y` over `y ∈ Set.range g` equals the sum of `f (g i)` over all `i`\nprovided that `g` is injective on `support (f ∘ g)`.","depth":31}],"count":61}
{"noDocExamples":[],"kind":"«term_||_»","examples":[{"term":"fun b₁ b₂ => b₁ || b₂","name":"strictOr","doc":"`strictOr` is the same as `or`, but it does not use short-circuit evaluation semantics:\nboth sides are evaluated, even if the first value is `true`.\n","depth":4},{"term":"fun x y c => x && y || x && c || y && c","name":"Bool.carry","doc":"`carry x y c` is `x && y || x && c || y && c`. ","depth":9},{"term":"fun {α} l p => List.foldr (fun a r => p a || r) false l","name":"List.any","doc":"`O(|l|)`. Returns true if `p` is true for any element of `l`.\n* `any p [a, b, c] = p a || p b || p c`\n","depth":11},{"term":"fun {n} x =>\n  let f := fun y c => (y || c, xor y c);\n  (Vector.mapAccumr f x false).snd","name":"Bitvec.neg","doc":"`neg x` is the two's complement of `x`. ","depth":11},{"term":"fun env n =>\n  Lean.Environment.contains env (Lean.Name.str n \"_cstage2\") ||\n    Lean.SMap.contains (Lean.ScopedEnvExtension.getState Lean.Compiler.CSimp.ext env).map n","name":"Mathlib.Util.isCompiled","doc":"Returns true if the given declaration has already been compiled, either directly or via a\n`@[csimp]` lemma. ","depth":12}],"count":60}
{"noDocExamples":[{"term":"fun {α} [GeneralizedCoheytingAlgebra α] a =>\n  Eq.mpr (id (symmDiff._eq_1 a a ▸ Eq.refl (a ∆ a = ⊥)))\n    (Eq.mpr (id (sup_idem ▸ Eq.refl (a \\ a ⊔ a \\ a = ⊥))) (Eq.mpr (id (sdiff_self ▸ Eq.refl (a \\ a = ⊥))) (Eq.refl ⊥)))","name":"symmDiff_self","depth":23},{"term":"fun {α} [GeneralizedCoheytingAlgebra α] a =>\n  Eq.mpr (id (symmDiff_comm ⊥ a ▸ Eq.refl (⊥ ∆ a = a))) (Eq.mpr (id (symmDiff_bot a ▸ Eq.refl (a ∆ ⊥ = a))) (Eq.refl a))","name":"bot_symmDiff","depth":24}],"kind":"«term_∆_»","examples":[{"term":"fun α [BooleanRing α] =>\n  let src := ofBoolRing.trans ofBoolAlg;\n  {\n    toEquiv :=\n      { toFun := src.toFun, invFun := src.invFun,\n        left_inv := (_ : Function.LeftInverse (ofBoolRing.trans ofBoolAlg).invFun (ofBoolRing.trans ofBoolAlg).toFun),\n        right_inv :=\n          (_ : Function.RightInverse (ofBoolRing.trans ofBoolAlg).invFun (ofBoolRing.trans ofBoolAlg).toFun) },\n    map_mul' :=\n      (_ :\n        ∀ (_a _b : AsBoolRing (AsBoolAlg α)),\n          Equiv.toFun\n              { toFun := (ofBoolRing.trans ofBoolAlg).toFun, invFun := (ofBoolRing.trans ofBoolAlg).invFun,\n                left_inv :=\n                  (_ : Function.LeftInverse (ofBoolRing.trans ofBoolAlg).invFun (ofBoolRing.trans ofBoolAlg).toFun),\n                right_inv :=\n                  (_ : Function.RightInverse (ofBoolRing.trans ofBoolAlg).invFun (ofBoolRing.trans ofBoolAlg).toFun) }\n              (_a * _b) =\n            Equiv.toFun\n              { toFun := (ofBoolRing.trans ofBoolAlg).toFun, invFun := (ofBoolRing.trans ofBoolAlg).invFun,\n                left_inv :=\n                  (_ : Function.LeftInverse (ofBoolRing.trans ofBoolAlg).invFun (ofBoolRing.trans ofBoolAlg).toFun),\n                right_inv :=\n                  (_ : Function.RightInverse (ofBoolRing.trans ofBoolAlg).invFun (ofBoolRing.trans ofBoolAlg).toFun) }\n              (_a * _b)),\n    map_add' := (_ : ∀ (a b : AsBoolAlg α), ↑ofBoolAlg (a ∆ b) = ↑ofBoolAlg a + ↑ofBoolAlg b) }","name":"RingEquiv.asBoolRingAsBoolAlg","doc":"Ring isomorphism between `α` considered as a Boolean algebra considered as a Boolean ring and\n`α`. ","depth":17},{"term":"fun {α} {β} [BooleanAlgebra α] [BooleanAlgebra β] f =>\n  {\n    toMonoidHom :=\n      { toOneHom := { toFun := ↑toBoolRing ∘ ↑f ∘ ↑ofBoolRing, map_one' := (_ : SupHom.toFun f.toSupHom ⊤ = ⊤) },\n        map_mul' :=\n          (_ : ∀ (a b : α), SupHom.toFun f.toSupHom (a ⊓ b) = SupHom.toFun f.toSupHom a ⊓ SupHom.toFun f.toSupHom b) },\n    map_zero' := (_ : SupHom.toFun f.toSupHom ⊥ = ⊥), map_add' := (_ : ∀ (a b : α), ↑f (a ∆ b) = ↑f a ∆ ↑f b) }","name":"BoundedLatticeHom.asBoolRing","doc":"Turn a bounded lattice homomorphism from Boolean algebras `α` to `β` into a ring homomorphism\nfrom `α` to `β` considered as Boolean rings. ","depth":36},{"term":"fun {F} {α} {β} [BooleanAlgebra α] [BooleanAlgebra β] [BoundedLatticeHomClass F α β] f a b =>\n  Eq.mpr (id (symmDiff._eq_1 a b ▸ Eq.refl (↑f (a ∆ b) = ↑f a ∆ ↑f b)))\n    (Eq.mpr (id (symmDiff._eq_1 (↑f a) (↑f b) ▸ Eq.refl (↑f (a \\ b ⊔ b \\ a) = ↑f a ∆ ↑f b)))\n      (Eq.mpr (id (map_sup f (a \\ b) (b \\ a) ▸ Eq.refl (↑f (a \\ b ⊔ b \\ a) = ↑f a \\ ↑f b ⊔ ↑f b \\ ↑f a)))\n        (Eq.mpr (id (map_sdiff' f a b ▸ Eq.refl (↑f (a \\ b) ⊔ ↑f (b \\ a) = ↑f a \\ ↑f b ⊔ ↑f b \\ ↑f a)))\n          (Eq.mpr (id (map_sdiff' f b a ▸ Eq.refl (↑f a \\ ↑f b ⊔ ↑f (b \\ a) = ↑f a \\ ↑f b ⊔ ↑f b \\ ↑f a)))\n            (Eq.refl (↑f a \\ ↑f b ⊔ ↑f b \\ ↑f a))))))","name":"map_symmDiff'","doc":"Special case of `map_symmDiff` for boolean algebras. ","depth":48}],"count":60}
{"noDocExamples":[],"kind":"Nat.«term_≡_[MOD_]»","examples":[{"term":"fun {m n} co a b => Nat.chineseRemainder' (_ : a ≡ b [MOD Nat.gcd n m])","name":"Nat.chineseRemainder","doc":"The natural number less than `n*m` congruent to `a` mod `n` and `b` mod `m` ","depth":11},{"term":"fun {n a b} m => Eq.rec (motive := fun x h => a ≡ b [MOD x] → a ≡ b [MOD n]) (Nat.ModEq.of_mul_left m) (mul_comm m n)","name":"Nat.ModEq.of_mul_right","doc":"Cancel right multiplication in the modulus.\n\nFor cancelling right multiplication on both sides of the `≡`, see `nat.modeq.mul_right_cancel'`. ","depth":19},{"term":"fun {n a b} m h =>\n  Eq.mpr (id (propext Nat.modEq_iff_dvd ▸ Eq.refl (a ≡ b [MOD n])))\n    (Dvd.dvd.trans (dvd_mul_left ↑n ↑m) (Eq.mp (propext Nat.modEq_iff_dvd ▸ Eq.refl (a ≡ b [MOD m * n])) h))","name":"Nat.ModEq.of_mul_left","doc":"Cancel left multiplication in the modulus.\n\nFor cancelling left multiplication on both sides of the `≡`, see `nat.modeq.mul_left_cancel'`. ","depth":25},{"term":"fun {n a b} h =>\n  Eq.mpr (id (propext Nat.modEq_iff_dvd ▸ Eq.refl (a ≡ b [MOD n] ↔ n ∣ b - a)))\n    (Eq.mpr (id (Eq.symm (propext Int.coe_nat_dvd) ▸ Eq.refl (↑n ∣ ↑b - ↑a ↔ n ∣ b - a)))\n      (Eq.mpr (id (Int.ofNat_sub h ▸ Eq.refl (↑n ∣ ↑b - ↑a ↔ ↑n ∣ ↑(b - a)))) Iff.rfl))","name":"Nat.modEq_iff_dvd'","doc":"A variant of `modEq_iff_dvd` with `Nat` divisibility ","depth":25},{"term":"fun {m n a b} h =>\n  if hn : n = 0 then { val := a, property := (_ : a ≡ a [MOD n] ∧ a ≡ b [MOD m]) }\n  else\n    if hm : m = 0 then { val := b, property := (_ : b ≡ a [MOD n] ∧ b ≡ b [MOD m]) }\n    else\n      {\n        val :=\n          match Nat.xgcd n m with\n          | (c, d) => Int.toNat ((↑n * c * ↑b + ↑m * d * ↑a) / ↑(Nat.gcd n m) % ↑(Nat.lcm n m)),\n        property :=\n          (_ :\n            (match Nat.xgcd n m with\n                | (c, d) => Int.toNat ((↑n * c * ↑b + ↑m * d * ↑a) / ↑(Nat.gcd n m) % ↑(Nat.lcm n m))) ≡\n                a [MOD n] ∧\n              (match Nat.xgcd n m with\n                | (c, d) => Int.toNat ((↑n * c * ↑b + ↑m * d * ↑a) / ↑(Nat.gcd n m) % ↑(Nat.lcm n m))) ≡\n                b [MOD m]) }","name":"Nat.chineseRemainder'","doc":"The natural number less than `lcm n m` congruent to `a` mod `n` and `b` mod `m` ","depth":29}],"count":55}
{"noDocExamples":[],"kind":"Nat.«term⌊_⌋₊»","examples":[{"term":"fun s => Complex.GammaAux ⌊1 - s.re⌋₊ s","name":"Complex.Gamma","doc":"The `Γ` function (of a complex variable `s`). ","depth":10},{"term":"fun N => ⌊↑N ^ (1 / ↑(Behrend.nValue N)) / 2⌋₊","name":"Behrend.dValue","doc":"The (almost) optimal value of `d` in `Behrend.bound_aux`. ","depth":11},{"term":"fun ε l =>\n  SzemerediRegularity.stepBound^[⌊↑4 / ε ^ 5⌋₊] (SzemerediRegularity.initialBound ε l) *\n    16 ^ SzemerediRegularity.stepBound^[⌊↑4 / ε ^ 5⌋₊] (SzemerediRegularity.initialBound ε l)","name":"SzemerediRegularity.bound","doc":"An explicit bound on the size of the equipartition whose existence is given by Szemerédi's\nregularity lemma. ","depth":14},{"term":"fun ε l => max 7 (max l (⌊Real.log (↑100 / ε ^ 5) / Real.log 4⌋₊ + 1))","name":"SzemerediRegularity.initialBound","doc":"Auxiliary function for Szemerédi's regularity lemma. The size of the partition by which we start\nblowing. ","depth":17},{"term":"fun {R} [LinearOrderedSemifield R] [FloorSemiring R] b r => if 1 ≤ r then ↑(Nat.clog b ⌈r⌉₊) else -↑(Nat.log b ⌊r⁻¹⌋₊)","name":"Int.clog","doc":"The least power of `b` such that `r ≤ b ^ log b r`. ","depth":19}],"count":54}
{"noDocExamples":[],"kind":"«term_⊂_»","examples":[{"term":"fun {α} [HasSSubset α] a b => b ⊂ a","name":"SSuperset","doc":"Strict superset relation: `a ⊃ b`  ","depth":8},{"term":"fun {α} r s t => IsChain r t ∧ s ⊂ t","name":"SuperChain","doc":"`SuperChain s t` means that `t` is a chain that strictly includes `s`. ","depth":10},{"term":"fun {α} [DecidableEq α] {s} {p} [(t : Finset α) → (h : t ⊂ s) → Decidable (p t h)] =>\n  decidable_of_iff (∀ (t : Finset α) (h : t ∈ Finset.ssubsets s), p t (_ : t ⊂ s))\n    (_ : (∀ (t : Finset α) (h : t ∈ Finset.ssubsets s), p t (_ : t ⊂ s)) ↔ ∀ (t : Finset α) (h : t ⊂ s), p t h)","name":"Finset.decidableForallOfDecidableSSubsets","doc":"For predicate `p` decidable on ssubsets, it is decidable whether `p` holds for every ssubset. ","depth":17},{"term":"fun {α} [DecidableEq α] {s} {p} [(t : Finset α) → (h : t ⊂ s) → Decidable (p t h)] =>\n  decidable_of_iff (∃ t hs, p t (_ : t ⊂ s)) (_ : (∃ t hs, p t (_ : t ⊂ s)) ↔ ∃ t h, p t h)","name":"Finset.decidableExistsOfDecidableSSubsets","doc":"For predicate `p` decidable on ssubsets, it is decidable whether `p` holds for any ssubset. ","depth":19},{"term":"fun {α} [LinearOrder α] [DecidableEq α] {p} s h0 step =>\n  Finset.strongInductionOn s fun s ihs =>\n    Or.casesOn (Finset.eq_empty_or_nonempty s)\n      (fun h => Eq.ndrec (motive := fun s => (∀ (t : Finset α), t ⊂ s → p t) → p s) (fun ihs => h0) (Eq.symm h) ihs)\n      fun hne =>\n      let_fun H := Finset.max'_mem s hne;\n      Eq.mpr (id (Eq.symm (Finset.insert_erase H) ▸ Eq.refl (p s)))\n        (step (Finset.max' s hne) (Finset.erase s (Finset.max' s hne)) (fun x => Finset.lt_max'_of_mem_erase_max' s hne)\n          (ihs (Finset.erase s (Finset.max' s hne)) (Finset.erase_ssubset H)))","name":"Finset.induction_on_max","doc":"Induction principle for `Finset`s in a linearly ordered type: a predicate is true on all\n`s : Finset α` provided that:\n\n* it is true on the empty `Finset`,\n* for every `s : Finset α` and an element `a` strictly greater than all elements of `s`, `p s`\n  implies `p (insert a s)`. ","depth":30}],"count":53}
{"noDocExamples":[],"kind":"«term_≃_»","examples":[{"term":"fun α => α ≃ α","name":"Equiv.Perm","doc":"`Perm α` is the type of bijections from `α` to itself. ","depth":3},{"term":"fun α [Small.{w, v} α] => Nonempty.some (_ : Nonempty (α ≃ Classical.choose (_ : ∃ S, Nonempty (α ≃ S))))","name":"equivShrink","doc":"The noncomputable equivalence between a `w`-small type and a model.\n","depth":7},{"term":"{ r := fun α β => Nonempty (α ≃ β), iseqv := Cardinal.isEquivalent.proof_1 }","name":"Cardinal.isEquivalent","doc":"The equivalence relation on types given by equivalence (bijective correspondence) of types.\nQuotienting by this equivalence relation gives the cardinal numbers.\n","depth":7},{"term":"fun α [Small.{w, v} α] => Classical.choose (_ : ∃ S, Nonempty (α ≃ S))","name":"Shrink","doc":"An arbitrarily chosen model in `Type w` for a `w`-small type.\n","depth":8},{"term":"fun {α} => Nonempty.some (_ : Nonempty (Quotient.out (Cardinal.mk α) ≃ α))","name":"Cardinal.outMkEquiv","doc":"The representative of the cardinal of a type is equivalent to the original type. ","depth":8}],"count":52}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term_⨯_»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v, u} C] {A} [CategoryTheory.Limits.HasFiniteProducts C]\n    [CategoryTheory.Exponentiable A] {I} t =>\n  CategoryTheory.Iso.mk CategoryTheory.Limits.prod.snd (CategoryTheory.Limits.IsInitial.to t (A ⨯ I))","name":"CategoryTheory.zeroMul","doc":"If an initial object `I` exists in a CCC, then `A ⨯ I ≅ I`. ","depth":19},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] {A} hA [CategoryTheory.Limits.HasBinaryProduct A A] =>\n  {\n    out :=\n      Exists.intro CategoryTheory.Limits.prod.fst\n        {\n          left :=\n            of_eq_true\n              (Eq.trans\n                (congrFun\n                  (congrArg Eq\n                    (CategoryTheory.Limits.limit.lift_π\n                      (CategoryTheory.Limits.BinaryFan.mk (CategoryTheory.CategoryStruct.id A)\n                        (CategoryTheory.CategoryStruct.id A))\n                      { as := CategoryTheory.Limits.WalkingPair.left }))\n                  (CategoryTheory.CategoryStruct.id A))\n                (eq_self (CategoryTheory.CategoryStruct.id A))),\n          right :=\n            Eq.mpr\n              (id\n                (congrFun\n                  (congrArg Eq\n                    (Eq.trans\n                      (CategoryTheory.Limits.prod.comp_lift CategoryTheory.Limits.prod.fst\n                        (CategoryTheory.CategoryStruct.id A) (CategoryTheory.CategoryStruct.id A))\n                      (congr\n                        (congrArg CategoryTheory.Limits.prod.lift\n                          (CategoryTheory.Category.comp_id CategoryTheory.Limits.prod.fst))\n                        (CategoryTheory.Category.comp_id CategoryTheory.Limits.prod.fst))))\n                  (CategoryTheory.CategoryStruct.id (A ⨯ A))))\n              (CategoryTheory.Limits.prod.hom_ext\n                (of_eq_true\n                  (Eq.trans\n                    (congr\n                      (congrArg Eq\n                        (CategoryTheory.Limits.limit.lift_π\n                          (CategoryTheory.Limits.BinaryFan.mk CategoryTheory.Limits.prod.fst\n                            CategoryTheory.Limits.prod.fst)\n                          { as := CategoryTheory.Limits.WalkingPair.left }))\n                      (CategoryTheory.Category.id_comp CategoryTheory.Limits.prod.fst))\n                    (eq_self CategoryTheory.Limits.prod.fst)))\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (CategoryTheory.Limits.limit.lift_π\n                          (CategoryTheory.Limits.BinaryFan.mk CategoryTheory.Limits.prod.fst\n                            CategoryTheory.Limits.prod.fst)\n                          { as := CategoryTheory.Limits.WalkingPair.right }))\n                      (CategoryTheory.Category.id_comp CategoryTheory.Limits.prod.snd)))\n                  (Eq.mp (propext CategoryTheory.IsSubterminal.def ▸ Eq.refl (CategoryTheory.IsSubterminal A)) hA\n                    CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd))) } }","name":"CategoryTheory.IsSubterminal.isIso_diag","doc":"If `A` is subterminal, its diagonal morphism is an isomorphism.\nThe converse of `isSubterminal_of_isIso_diag`.\n","depth":35},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasBinaryProducts C] =>\n  CategoryTheory.Functor.mk\n    {\n      obj := fun X =>\n        CategoryTheory.Functor.mk\n          { obj := fun Y => X ⨯ Y,\n            map := fun {Y Z} => CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X) },\n      map := fun {X Y} f =>\n        CategoryTheory.NatTrans.mk fun T => CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id T) }","name":"CategoryTheory.Limits.prod.functor","doc":"The binary product functor. ","depth":44},{"term":"fun C [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasTerminal C]\n    [CategoryTheory.Limits.HasBinaryProducts C] =>\n  CategoryTheory.MonoidalCategory.ofTensorHom (fun X Y => X ⨯ Y)\n    (fun {X₁ Y₁ X₂ Y₂} f g => CategoryTheory.Limits.prod.map f g)\n    (fun X x x_1 f =>\n      (fun {X₁ Y₁ X₂ Y₂} f g => CategoryTheory.Limits.prod.map f g) (CategoryTheory.CategoryStruct.id X) f)\n    (fun {X₁ X₂} f Y =>\n      (fun {X₁ Y₁ X₂ Y₂} f g => CategoryTheory.Limits.prod.map f g) f (CategoryTheory.CategoryStruct.id Y))\n    (⊤_ C) CategoryTheory.Limits.prod.associator (fun P => CategoryTheory.Limits.prod.leftUnitor P) fun P =>\n    CategoryTheory.Limits.prod.rightUnitor P","name":"CategoryTheory.monoidalOfHasFiniteProducts","doc":"A category with a terminal object and binary products has a natural monoidal structure. ","depth":45},{"term":"fun {C} {D} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.Category.{v₁, u₂} D] i\n    [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Reflective i] [CategoryTheory.CartesianClosed C]\n    [CategoryTheory.Limits.HasFiniteProducts D] [CategoryTheory.ExponentialIdeal i] A B X =>\n  Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (Trans.trans\n                      (CategoryTheory.Adjunction.homEquiv (CategoryTheory.Adjunction.ofRightAdjoint i) (A ⨯ B) X)\n                      (CategoryTheory.Iso.homCongr (CategoryTheory.Limits.prod.braiding A B)\n                        (CategoryTheory.Iso.refl (i.obj X))))\n                    (CategoryTheory.Adjunction.homEquiv (CategoryTheory.exp.adjunction B) A (i.obj X)))\n                  (CategoryTheory.unitCompPartialBijective A (_ : (B ⟹ i.obj X) ∈ CategoryTheory.Functor.essImage i)))\n                (CategoryTheory.Adjunction.homEquiv (CategoryTheory.exp.adjunction B)\n                    (i.obj ((CategoryTheory.leftAdjoint i).obj A)) (i.obj X)).symm)\n              (CategoryTheory.Iso.homCongr\n                (CategoryTheory.Limits.prod.braiding B (i.obj ((CategoryTheory.leftAdjoint i).obj A)))\n                (CategoryTheory.Iso.refl (i.obj X))))\n            (CategoryTheory.Adjunction.homEquiv\n              (CategoryTheory.exp.adjunction (i.obj ((CategoryTheory.leftAdjoint i).obj A))) B (i.obj X)))\n          (CategoryTheory.unitCompPartialBijective B\n            (_ : (i.obj ((CategoryTheory.leftAdjoint i).obj A) ⟹ i.obj X) ∈ CategoryTheory.Functor.essImage i)))\n        (CategoryTheory.Adjunction.homEquiv\n            (CategoryTheory.exp.adjunction (i.obj ((CategoryTheory.leftAdjoint i).obj A)))\n            (i.obj ((CategoryTheory.leftAdjoint i).obj B)) (i.obj X)).symm)\n      (CategoryTheory.Iso.homCongr\n        (CategoryTheory.Limits.PreservesLimitPair.iso i ((CategoryTheory.leftAdjoint i).obj A)\n            ((CategoryTheory.leftAdjoint i).obj B)).symm\n        (CategoryTheory.Iso.refl (i.obj X))))\n    (CategoryTheory.equivOfFullyFaithful i).symm","name":"CategoryTheory.bijection","doc":"We construct a bijection between morphisms `L(A ⨯ B) ⟶ X` and morphisms `LA ⨯ LB ⟶ X`.\nThis bijection has two key properties:\n* It is natural in `X`: See `bijection_natural`.\n* When `X = LA ⨯ LB`, then the backwards direction sends the identity morphism to the product\n  comparison morphism: See `bijection_symm_apply_id`.\n\nTogether these help show that `L` preserves binary products. This should be considered\n*internal implementation* towards `preservesBinaryProductsOfExponentialIdeal`.\n","depth":49}],"count":51}
{"noDocExamples":[],"kind":"«term∃!_,_»","examples":[{"term":"fun {α} [Fintype α] p [DecidablePred p] hp =>\n  { val := Finset.choose p Finset.univ (_ : ∃! a, a ∈ Finset.univ ∧ p a),\n    property := (_ : p (Finset.choose p Finset.univ (_ : ∃! a, a ∈ Finset.univ ∧ p a))) }","name":"Fintype.chooseX","doc":"Given a fintype `α` and a predicate `p`, associate to a proof that there is a unique element of\n`α` satisfying `p` this unique element, as an element of the corresponding subtype. ","depth":12},{"term":"fun {V} {G} M => ∀ ⦃v : V⦄, v ∈ M.verts → ∃! w, SimpleGraph.Subgraph.Adj M v w","name":"SimpleGraph.Subgraph.IsMatching","doc":"The subgraph `M` of `G` is a matching if every vertex of `M` is incident to exactly one edge in `M`.\nWe say that the vertices in `M.support` are *matched* or *saturated*.\n","depth":12},{"term":"fun x y f => f ⊆ ZFSet.prod x y ∧ ∀ (z : ZFSet), z ∈ x → ∃! w, ZFSet.pair z w ∈ f","name":"ZFSet.IsFunc","doc":"`isFunc x y f` is the assertion that `f` is a subset of `x × y` which relates to each element\nof `x` a unique element of `y`, so that we can consider `f` as a ZFC function `x → y`. ","depth":13},{"term":"fun {α} =>\n  {\n    le := fun x y =>\n      Setoid.mkClasses ↑x (_ : ∀ (a : α), ∃! b x, a ∈ b) ≤ Setoid.mkClasses ↑y (_ : ∀ (a : α), ∃! b x, a ∈ b) }","name":"Setoid.Partition.le","doc":"Defining `≤` on partitions as the `≤` defined on their induced equivalence relations. ","depth":13},{"term":"fun R [NonAssocSemiring R] => Classical.choose (_ : ∃! p, CharP R p)","name":"ringChar","doc":"Noncomputable function that outputs the unique characteristic of a semiring. ","depth":14}],"count":50}
{"noDocExamples":[],"kind":"Set.«term⋂₀_»","examples":[{"term":"fun x => ⋂₀ Class.classToCong x","name":"Class.sInter","doc":"The intersection of a class is the class of all members of ZFC sets in the class ","depth":3},{"term":"fun α [UniformSpace α] => ⋂₀ (uniformity α).sets","name":"separationRel","doc":"The separation relation is the intersection of all entourages.\nTwo points which are related by the separation relation are \"indistinguishable\"\naccording to the uniform structure. ","depth":7},{"term":"fun {α} g =>\n  Filter.ofCountableInter (Filter.CountableGenerateSets g)\n    (_ :\n      ∀ (x : Set (Set α)),\n        Set.Countable x →\n          (∀ (s : Set α), s ∈ x → Filter.CountableGenerateSets g s) → Filter.CountableGenerateSets g (⋂₀ x))\n    (_ : ∀ (x x_1 : Set α), Filter.CountableGenerateSets g x → x ⊆ x_1 → Filter.CountableGenerateSets g x_1)","name":"Filter.countableGenerate","doc":"`Filter.countableGenerate g` is the greatest `countableInterFilter` containing `g`.","depth":9},{"term":"fun {α} [TopologicalSpace α] s => ⋂₀ {t | IsClosed t ∧ s ⊆ t}","name":"closure","doc":"The closure of `s` is the smallest closed set containing `s`. ","depth":12},{"term":"fun {R} [CommRing R] =>\n  TopologicalSpace.ofClosed (Set.range PrimeSpectrum.zeroLocus) (_ : ∃ y, PrimeSpectrum.zeroLocus y = ∅)\n    (_ :\n      ∀ (Zs : Set (Set (PrimeSpectrum R))),\n        Zs ⊆ Set.range PrimeSpectrum.zeroLocus → ⋂₀ Zs ∈ Set.range PrimeSpectrum.zeroLocus)\n    (_ :\n      ∀ (A : Set (PrimeSpectrum R)),\n        A ∈ Set.range PrimeSpectrum.zeroLocus →\n          ∀ (B : Set (PrimeSpectrum R)),\n            B ∈ Set.range PrimeSpectrum.zeroLocus → A ∪ B ∈ Set.range PrimeSpectrum.zeroLocus)","name":"PrimeSpectrum.zariskiTopology","doc":"The Zariski topology on the prime spectrum of a commutative ring is defined via the closed sets\nof the topology: they are exactly those sets that are the zero locus of a subset of the ring. ","depth":12}],"count":50}
{"noDocExamples":[],"kind":"«term∏ᶠ_,_»","examples":[{"term":"fun {ι} {X} [TopologicalSpace X] {s} f =>\n  PartitionOfUnity.mk s (fun i => ContinuousMap.mk (BumpCovering.toPOUFun f i))\n    (_ : LocallyFinite fun i => Function.support ↑((fun i => ContinuousMap.mk (BumpCovering.toPOUFun f i)) i))\n    (_ : ∀ (i : ι) (x : X), 0 ≤ ↑(↑f i) x * ∏ᶠ (j : ι) (_ : WellOrderingRel j i), (1 - ↑(↑f j) x))\n    (_ : ∀ (x : X), x ∈ s → ∑ᶠ (i : ι), ↑((fun i => ContinuousMap.mk (BumpCovering.toPOUFun f i)) i) x = 1)\n    (_ : ∀ (x : X), ∑ᶠ (i : ι), ↑((fun i => ContinuousMap.mk (BumpCovering.toPOUFun f i)) i) x ≤ 1)","name":"BumpCovering.toPartitionOfUnity","doc":"The partition of unity defined by a `BumpCovering`.\n\nThe partition of unity is given by the formula `g i x = f i x * ∏ᶠ j < i, (1 - f j x)`. In other\nwords, `g i x = ∏ᶠ j < i, (1 - f j x) - ∏ᶠ j ≤ i, (1 - f j x)`, so\n`∑ᶠ i, g i x = 1 - ∏ᶠ j, (1 - f j x)`. If `x ∈ s`, then one of `f j x` equals one, hence the product\nof `1 - f j x` vanishes, and `∑ᶠ i, g i x = 1`.\n\nIn order to avoid an assumption `LinearOrder ι`, we use `WellOrderingRel` instead of `(<)`. ","depth":19},{"term":"fun {α} {M} [CommMonoid M] {f} {s} hf =>\n  Eq.mpr (id (Eq.symm (finprod_mem_one s) ▸ Eq.refl (∏ᶠ (i : α) (_ : i ∈ s), f i = 1))) (finprod_mem_congr rfl hf)","name":"finprod_mem_of_eqOn_one","doc":"If a function `f` equals `1` on a set `s`, then the product of `f i` over `i ∈ s` equals `1`. ","depth":28},{"term":"fun {ι} {X} [TopologicalSpace X] {s} f i x => ↑(↑f i) x * ∏ᶠ (j : ι) (_ : WellOrderingRel j i), (1 - ↑(↑f j) x)","name":"BumpCovering.toPOUFun","doc":"Partition of unity defined by a `BumpCovering`. We use this auxiliary definition to prove some\nproperties of the new family of functions before bundling it into a `PartitionOfUnity`. Do not use\nthis definition, use `BumpCovering.toPartitionOfUnity` instead.\n\nThe partition of unity is given by the formula `g i x = f i x * ∏ᶠ j < i, (1 - f j x)`. In other\nwords, `g i x = ∏ᶠ j < i, (1 - f j x) - ∏ᶠ j ≤ i, (1 - f j x)`, so\n`∑ᶠ i, g i x = 1 - ∏ᶠ j, (1 - f j x)`. If `x ∈ s`, then one of `f j x` equals one, hence the product\nof `1 - f j x` vanishes, and `∑ᶠ i, g i x = 1`.\n\nIn order to avoid an assumption `LinearOrder ι`, we use `WellOrderingRel` instead of `(<)`. ","depth":28},{"term":"fun {α} {M} [CommMonoid M] {f} {a} =>\n  Eq.mpr (id (Eq.symm (Finset.coe_singleton a) ▸ Eq.refl (∏ᶠ (i : α) (_ : i ∈ {a}), f i = f a)))\n    (Eq.mpr (id (finprod_mem_coe_finset (fun i => f i) {a} ▸ Eq.refl (∏ᶠ (i : α) (_ : i ∈ ↑{a}), f i = f a)))\n      (Eq.mpr (id (Finset.prod_singleton ▸ Eq.refl ((Finset.prod {a} fun i => f i) = f a))) (Eq.refl (f a))))","name":"finprod_mem_singleton","doc":"The product of `f i` over `i ∈ {a}` equals `f a`. ","depth":29},{"term":"fun {α} {M} [CommMonoid M] {f} {a b} h =>\n  Eq.mpr\n    (id\n      (finprod_mem_insert (fun i => f i) h (Set.finite_singleton b) ▸\n        Eq.refl (∏ᶠ (i : α) (_ : i ∈ {a, b}), f i = f a * f b)))\n    (Eq.mpr (id (finprod_mem_singleton ▸ Eq.refl (f a * ∏ᶠ (i : α) (_ : i ∈ {b}), f i = f a * f b)))\n      (Eq.refl (f a * f b)))","name":"finprod_mem_pair","doc":"The product of `f i` over `i ∈ {a, b}`, `a ≠ b`, is equal to `f a * f b`. ","depth":31}],"count":49}
{"noDocExamples":[{"term":"fun {α} [LinearOrderedRing α] [FloorRing α] =>\n  { floor := fun a => Int.toNat ⌊a⌋, ceil := fun a => Int.toNat ⌈a⌉,\n    floor_of_neg := (_ : ∀ {a : α}, a < 0 → Int.toNat ⌊a⌋ = 0),\n    gc_floor := (_ : ∀ {a : α} {n : ℕ}, 0 ≤ a → (n ≤ (fun a => Int.toNat ⌊a⌋) a ↔ ↑n ≤ a)),\n    gc_ceil := (_ : ∀ (a : α) (n : ℕ), (fun a => Int.toNat ⌈a⌉) a ≤ n ↔ a ≤ ↑n) }","name":"FloorRing.toFloorSemiring","depth":14},{"term":"fun f x => Trans.trans (CircleDeg1Lift.monotone f (Int.le_ceil x)) (CircleDeg1Lift.map_int_of_map_zero f ⌈x⌉)","name":"CircleDeg1Lift.map_le_of_map_zero","depth":19},{"term":"{\n  isCompact_closedBall := fun x r =>\n    Eq.mpr (id (Int.closedBall_eq_Icc x r ▸ Eq.refl (IsCompact (Metric.closedBall x r))))\n      (Set.Finite.isCompact (Set.finite_Icc ⌈↑x - r⌉ ⌊↑x + r⌋)) }","name":"Int.instProperSpaceIntToPseudoMetricSpaceInstMetricSpaceInt.proof_1","depth":19}],"kind":"Int.«term⌈_⌉»","examples":[{"term":"fun {α} [LinearOrderedRing α] [FloorRing α] x => if 2 * Int.fract x < 1 then ⌊x⌋ else ⌈x⌉","name":"round","doc":"`round` rounds a number to the nearest integer. `round (1 / 2) = 1` ","depth":20},{"term":"fun ξ =>\n  let f := fun q => (q.num, q.den);\n  let s := {q | |ξ - q| < 1 / ↑q.den ^ 2};\n  Eq.mpr\n    (id\n      ((let_fun this := rfl;\n        this) ▸\n        Eq.refl (Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2})))\n    (let_fun hinj := fun ⦃a b⦄ hab =>\n      Eq.mpr (id (Eq.symm (Rat.num_div_den a) ▸ Eq.refl (a = b)))\n        (Eq.mpr (id (Eq.symm (Rat.num_div_den b) ▸ Eq.refl (↑a.num / ↑a.den = b)))\n          (Eq.mpr\n            (id\n              ((Eq.mp Mathlib.NumberTheory.DiophantineApproximation._auxLemma.4 hab).left ▸\n                Eq.refl (↑a.num / ↑a.den = ↑b.num / ↑b.den)))\n            (Eq.mpr\n              (id\n                ((Eq.mp Mathlib.NumberTheory.DiophantineApproximation._auxLemma.4 hab).right ▸\n                  Eq.refl (↑b.num / ↑a.den = ↑b.num / ↑b.den)))\n              (Eq.refl (↑b.num / ↑b.den)))));\n    let_fun H := fun ⦃xy⦄ hxy =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans (congrArg (Membership.mem xy) (Set.image_congr fun a a_1 => Eq.refl (a.num, a.den)))\n              (Mathlib.NumberTheory.DiophantineApproximation._auxLemma.5 (fun a => (a.num, a.den))\n                {q | |ξ - q| < 1 / ↑q.den ^ 2} xy))\n            (congrArg Exists\n              (funext fun x =>\n                congrFun (congrArg And Mathlib.NumberTheory.DiophantineApproximation._auxLemma.6)\n                  ((x.num, x.den) = xy))))\n          hxy)\n        fun q h =>\n        And.casesOn h fun hq₁ hq₂ =>\n          And.casesOn (Rat.den_le_and_le_num_le_of_sub_lt_one_div_den_sq hq₁) fun hd hn =>\n            Eq.mpr\n              (id\n                (Eq.trans Mathlib.NumberTheory.DiophantineApproximation._auxLemma.7\n                  (congrArg Exists (funext fun i => Mathlib.NumberTheory.DiophantineApproximation._auxLemma.7))))\n              (Exists.intro q.den\n                (Exists.intro (Iff.mpr Set.mem_Ioc { left := Rat.pos q, right := hd })\n                  (Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans (congrArg (Membership.mem xy) Set.prod_singleton)\n                          (Mathlib.NumberTheory.DiophantineApproximation._auxLemma.5 (fun a => (a, q.den))\n                            (Set.Icc (⌈ξ * ↑q.den⌉ - 1) (⌊ξ * ↑q.den⌋ + 1)) xy))\n                        (congrArg Exists\n                          (funext fun x =>\n                            congrFun (congrArg And Mathlib.NumberTheory.DiophantineApproximation._auxLemma.8)\n                              ((x, q.den) = xy)))))\n                    (Exists.intro q.num { left := hn, right := hq₂ }))));\n    Set.Finite.of_finite_image\n      (Set.Finite.subset\n        (Set.Finite.biUnion (Set.finite_Ioc 0 ξ.den) fun x x_1 =>\n          Set.Finite.prod (Set.finite_Icc (⌈ξ * ↑x⌉ - 1) (⌊ξ * ↑x⌋ + 1)) (Set.finite_singleton x))\n        H)\n      (Set.injOn_of_injective hinj s))","name":"Rat.finite_rat_abs_sub_lt_one_div_den_sq","doc":"A rational number has only finitely many good rational approximations. ","depth":48}],"count":46}
{"noDocExamples":[],"kind":"CategoryTheory.«term_≅_»","examples":[{"term":"fun R =>\n  { toLocallyRingedSpace := AlgebraicGeometry.Spec.locallyRingedSpaceObj R,\n    local_affine :=\n      (_ :\n        ∀ (x : ↑(AlgebraicGeometry.LocallyRingedSpace.toTopCat (AlgebraicGeometry.Spec.locallyRingedSpaceObj R))),\n          ∃ U R_1,\n            Nonempty\n              (AlgebraicGeometry.LocallyRingedSpace.restrict (AlgebraicGeometry.Spec.locallyRingedSpaceObj R)\n                  (_ : OpenEmbedding ↑(TopologicalSpace.Opens.inclusion U.obj)) ≅\n                AlgebraicGeometry.Spec.toLocallyRingedSpace.obj (Opposite.op R_1))) }","name":"AlgebraicGeometry.Scheme.specObj","doc":"The spectrum of a commutative ring, as a scheme.\n","depth":4},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] X => X ≅ X","name":"CategoryTheory.Aut","doc":"Automorphisms of an object in a category.\n\nThe order of arguments in multiplication agrees with\n`Function.comp`, not with `CategoryTheory.CategoryStruct.comp`.\n","depth":7},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] X Y => Nonempty (X ≅ Y)","name":"CategoryTheory.IsIsomorphic","doc":"An object `X` is isomorphic to an object `Y`, if `X ≅ Y` is not empty. ","depth":9},{"term":"fun {X Y} =>\n  { toFun := CompHaus.homeoOfIso, invFun := CompHaus.isoOfHomeo,\n    left_inv := (_ : ∀ (f : X ≅ Y), CompHaus.isoOfHomeo (CompHaus.homeoOfIso f) = f),\n    right_inv := (_ : ∀ (f : ↑X.toTop ≃ₜ ↑Y.toTop), CompHaus.homeoOfIso (CompHaus.isoOfHomeo f) = f) }","name":"CompHaus.isoEquivHomeo","doc":"The equivalence between isomorphisms in `CompHaus` and homeomorphisms\nof topological spaces. ","depth":13},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] P => ∀ ⦃X Y : C⦄ (e : X ≅ Y), P e.hom → P e.inv","name":"CategoryTheory.MorphismProperty.StableUnderInverse","doc":"A morphism property is `StableUnderInverse` if the inverse of a morphism satisfying\nthe property still falls in the class. ","depth":13}],"count":45}
{"noDocExamples":[],"kind":"Nat.«term⌈_⌉₊»","examples":[{"term":"fun N => ⌈Real.sqrt (Real.log ↑N)⌉₊","name":"Behrend.nValue","doc":"The (almost) optimal value of `n` in `Behrend.bound_aux`. ","depth":7},{"term":"let src := AbsoluteValue.abs_isEuclidean;\n{ toIsEuclidean := AbsoluteValue.absIsAdmissible.proof_1, card := fun ε => ⌈1 / ε⌉₊,\n  exists_partition' :=\n    (_ :\n      ∀ (n : ℕ) (x : ℝ),\n        0 < x →\n          ∀ (x_1 : ℤ),\n            x_1 ≠ 0 → ∀ (A : Fin n → ℤ), ∃ t, ∀ (i₀ i₁ : Fin n), t i₀ = t i₁ → ↑|A i₁ % x_1 - A i₀ % x_1| < |x_1| • x) }","name":"AbsoluteValue.absIsAdmissible","doc":"`abs : ℤ → ℤ` is an admissible absolute value. ","depth":15},{"term":"fun {R} [LinearOrderedSemifield R] [FloorSemiring R] b r => if 1 ≤ r then ↑(Nat.clog b ⌈r⌉₊) else -↑(Nat.log b ⌊r⁻¹⌋₊)","name":"Int.clog","doc":"The least power of `b` such that `r ≤ b ^ log b r`. ","depth":19},{"term":"fun {R} [LinearOrderedSemifield R] [FloorSemiring R] b r => if 1 ≤ r then ↑(Nat.log b ⌊r⌋₊) else -↑(Nat.clog b ⌈r⁻¹⌉₊)","name":"Int.log","doc":"The greatest power of `b` such that `b ^ log b r ≤ r`. ","depth":19},{"term":"fun {Fq} [Fintype Fq] [Field Fq] =>\n  let src := (_ : AbsoluteValue.IsEuclidean Polynomial.cardPowDegree);\n  { toIsEuclidean := (_ : AbsoluteValue.IsEuclidean Polynomial.cardPowDegree),\n    card := fun ε => Fintype.card Fq ^ ⌈-Real.log ε / Real.log ↑(Fintype.card Fq)⌉₊,\n    exists_partition' :=\n      (_ :\n        ∀ (n : ℕ) (x : ℝ),\n          0 < x →\n            ∀ (x_1 : Polynomial Fq),\n              x_1 ≠ 0 →\n                ∀ (A : Fin n → Polynomial Fq),\n                  ∃ t,\n                    ∀ (i₀ i₁ : Fin n),\n                      t i₀ = t i₁ →\n                        ↑(↑Polynomial.cardPowDegree (A i₁ % x_1 - A i₀ % x_1)) < ↑Polynomial.cardPowDegree x_1 • x) }","name":"Polynomial.cardPowDegreeIsAdmissible","doc":"`fun p => Fintype.card Fq ^ degree p` is an admissible absolute value.\nWe set `q ^ degree 0 = 0`. ","depth":23}],"count":44}
{"noDocExamples":[],"kind":"CategoryTheory.termβ_","examples":[{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] [CategoryTheory.BraidedCategory C] X =>\n  { fst := X, snd := CategoryTheory.HalfBraiding.mk fun Y => β_ X Y }","name":"CategoryTheory.Center.ofBraidedObj","doc":"Auxiliary construction for `ofBraided`. ","depth":16},{"term":"fun C [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] [CategoryTheory.BraidedCategory C] X Y =>\n  CategoryTheory.CategoryStruct.comp\n    (CategoryTheory.MonoidalCategory.associator X.fst X.snd (CategoryTheory.MonoidalCategory.tensorObj Y.fst Y.snd)).hom\n    (CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X.fst)\n        (CategoryTheory.MonoidalCategory.associator X.snd Y.fst Y.snd).inv)\n      (CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X.fst)\n          (CategoryTheory.MonoidalCategory.tensorHom (β_ X.snd Y.fst).hom (CategoryTheory.CategoryStruct.id Y.snd)))\n        (CategoryTheory.CategoryStruct.comp\n          (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X.fst)\n            (CategoryTheory.MonoidalCategory.associator Y.fst X.snd Y.snd).hom)\n          (CategoryTheory.MonoidalCategory.associator X.fst Y.fst\n              (CategoryTheory.MonoidalCategory.tensorObj X.snd Y.snd)).inv)))","name":"CategoryTheory.tensor_μ","doc":"The strength of the tensor product functor from `C × C` to `C`. ","depth":24},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.MonoidalCategory C] P\n    [CategoryTheory.MonoidalCategory.MonoidalPredicate P] [CategoryTheory.BraidedCategory C] =>\n  CategoryTheory.braidedCategoryOfFaithful (CategoryTheory.MonoidalCategory.fullMonoidalSubcategoryInclusion P)\n    (fun X Y => CategoryTheory.Iso.mk (β_ X.obj Y.obj).hom (β_ X.obj Y.obj).inv)\n    (_ :\n      ∀ (X Y : CategoryTheory.FullSubcategory P),\n        CategoryTheory.CategoryStruct.comp\n            (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategory.tensorObj X.obj Y.obj))\n            (β_ X.obj Y.obj).hom =\n          CategoryTheory.CategoryStruct.comp (β_ X.obj Y.obj).hom\n            (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategory.tensorObj Y.obj X.obj)))","name":"CategoryTheory.MonoidalCategory.fullBraidedSubcategory","doc":"The braided structure on a full subcategory inherited by the braided structure on `C`.\n","depth":24},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] {D} [CategoryTheory.Category.{v₂, u₂} D]\n    [CategoryTheory.MonoidalCategory D] [CategoryTheory.BraidedCategory D] =>\n  CategoryTheory.BraidedCategory.mk fun F G => CategoryTheory.NatIso.ofComponents fun X => β_ (F.obj X) (G.obj X)","name":"CategoryTheory.Monoidal.functorCategoryBraided","doc":"When `C` is any category, and `D` is a braided monoidal category,\nthe natural pointwise monoidal structure on the functor category `C ⥤ D`\nis also braided.\n","depth":25},{"term":"fun {R} [CommRing R] M N P =>\n  { toFun := fun f => LinearMap.compr₂ (TensorProduct.mk R ↑N ↑M) (CategoryTheory.CategoryStruct.comp (β_ N M).hom f),\n    invFun := fun f => CategoryTheory.CategoryStruct.comp (β_ M N).hom (TensorProduct.lift f),\n    left_inv :=\n      (_ :\n        ∀ (f : (CategoryTheory.MonoidalCategory.tensorLeft M).obj N ⟶ P),\n          (fun f => CategoryTheory.CategoryStruct.comp (β_ M N).hom (TensorProduct.lift f))\n              ((fun f =>\n                  LinearMap.compr₂ (TensorProduct.mk R ↑N ↑M) (CategoryTheory.CategoryStruct.comp (β_ N M).hom f))\n                f) =\n            f),\n    right_inv :=\n      (_ :\n        ∀ (f : N ⟶ ((CategoryTheory.linearCoyoneda R (ModuleCat R)).obj (Opposite.op M)).obj P),\n          (fun f => LinearMap.compr₂ (TensorProduct.mk R ↑N ↑M) (CategoryTheory.CategoryStruct.comp (β_ N M).hom f))\n              ((fun f => CategoryTheory.CategoryStruct.comp (β_ M N).hom (TensorProduct.lift f)) f) =\n            (fun f => LinearMap.compr₂ (TensorProduct.mk R ↑N ↑M) (CategoryTheory.CategoryStruct.comp (β_ N M).hom f))\n              ((fun f => CategoryTheory.CategoryStruct.comp (β_ M N).hom (TensorProduct.lift f)) f)) }","name":"ModuleCat.monoidalClosedHomEquiv","doc":"Auxiliary definition for the `MonoidalClosed` instance on `Module R`.\n(This is only a separate definition in order to speed up typechecking. )\n","depth":32}],"count":44}
{"noDocExamples":[],"kind":"Submodule.«term_ᗮ»","examples":[{"term":"fun {𝕜} {E} [IsROrC 𝕜] [NormedAddCommGroup E] [InnerProductSpace 𝕜 E] U V => U ≤ Vᗮ","name":"Submodule.IsOrtho","doc":"The proposition that two submodules are orthogonal. Has notation `U ⟂ V`. ","depth":25},{"term":"fun {𝕜} {E} [IsROrC 𝕜] [NormedAddCommGroup E] [InnerProductSpace 𝕜 E] {K} [HasOrthogonalProjection Kᗮ] {v} hv =>\n  orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero (Submodule.le_orthogonal_orthogonal K hv)","name":"orthogonalProjection_mem_subspace_orthogonal_precomplement_eq_zero","doc":"The orthogonal projection onto `Kᗮ` of an element of `K` is zero. ","depth":25},{"term":"fun {𝕜} {E} [IsROrC 𝕜] [NormedAddCommGroup E] [InnerProductSpace 𝕜 E] K [HasOrthogonalProjection K] v =>\n  Exists.choose (_ : ∃ w, w ∈ K ∧ v - w ∈ Kᗮ)","name":"orthogonalProjectionFn","doc":"The orthogonal projection onto a complete subspace, as an\nunbundled function.  This definition is only intended for use in\nsetting up the bundled version `orthogonalProjection` and should not\nbe used once that is defined. ","depth":29},{"term":"fun {V} {P} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n} s i =>\n  AffineSubspace.mk' (Affine.Simplex.points s i)\n      (AffineSubspace.direction (affineSpan ℝ (s.points '' ↑(Finset.erase Finset.univ i))))ᗮ ⊓\n    affineSpan ℝ (Set.range s.points)","name":"Affine.Simplex.altitude","doc":"An altitude of a simplex is the line that passes through a vertex\nand is orthogonal to the opposite face. ","depth":31},{"term":"fun {V} {P} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] s\n    [Nonempty { x // x ∈ s }] [HasOrthogonalProjection (AffineSubspace.direction s)] p =>\n  Classical.choose (_ : ∃ p_1, ↑s ∩ ↑(AffineSubspace.mk' p (AffineSubspace.direction s)ᗮ) = {p_1})","name":"EuclideanGeometry.orthogonalProjectionFn","doc":"The orthogonal projection of a point onto a nonempty affine\nsubspace, whose direction is complete, as an unbundled function. This\ndefinition is only intended for use in setting up the bundled version\n`orthogonalProjection` and should not be used once that is\ndefined. ","depth":31}],"count":44}
{"noDocExamples":[],"kind":"«term_→L[_]_»","examples":[{"term":"fun 𝕜 [NontriviallyNormedField 𝕜] E [SeminormedAddCommGroup E] [NormedSpace 𝕜 E] => E →L[𝕜] 𝕜","name":"NormedSpace.Dual","doc":"The topological dual of a seminormed space `E`. ","depth":22},{"term":"fun {𝕜} [NontriviallyNormedField 𝕜] {E} [SeminormedAddCommGroup E] [NormedSpace 𝕜 E] => LinearEquiv.refl 𝕜 (E →L[𝕜] 𝕜)","name":"NormedSpace.Dual.toWeakDual","doc":"For normed spaces `E`, there is a canonical map `Dual 𝕜 E → WeakDual 𝕜 E` (the \"identity\"\nmapping). It is a linear equivalence. ","depth":28},{"term":"fun R [Ring R] M [TopologicalSpace M] [AddCommGroup M] [Module R M] =>\n  {\n    toEquiv :=\n      { toFun := ContinuousLinearEquiv.ofUnit, invFun := ContinuousLinearEquiv.toUnit,\n        left_inv := (_ : ∀ (f : (M →L[R] M)ˣ), ContinuousLinearEquiv.toUnit (ContinuousLinearEquiv.ofUnit f) = f),\n        right_inv := (_ : ∀ (f : M ≃L[R] M), ContinuousLinearEquiv.ofUnit (ContinuousLinearEquiv.toUnit f) = f) },\n    map_mul' :=\n      (_ :\n        ∀ (x y : (M →L[R] M)ˣ),\n          Equiv.toFun\n              { toFun := ContinuousLinearEquiv.ofUnit, invFun := ContinuousLinearEquiv.toUnit,\n                left_inv :=\n                  (_ : ∀ (f : (M →L[R] M)ˣ), ContinuousLinearEquiv.toUnit (ContinuousLinearEquiv.ofUnit f) = f),\n                right_inv :=\n                  (_ : ∀ (f : M ≃L[R] M), ContinuousLinearEquiv.ofUnit (ContinuousLinearEquiv.toUnit f) = f) }\n              (x * y) =\n            Equiv.toFun\n                { toFun := ContinuousLinearEquiv.ofUnit, invFun := ContinuousLinearEquiv.toUnit,\n                  left_inv :=\n                    (_ : ∀ (f : (M →L[R] M)ˣ), ContinuousLinearEquiv.toUnit (ContinuousLinearEquiv.ofUnit f) = f),\n                  right_inv :=\n                    (_ : ∀ (f : M ≃L[R] M), ContinuousLinearEquiv.ofUnit (ContinuousLinearEquiv.toUnit f) = f) }\n                x *\n              Equiv.toFun\n                { toFun := ContinuousLinearEquiv.ofUnit, invFun := ContinuousLinearEquiv.toUnit,\n                  left_inv :=\n                    (_ : ∀ (f : (M →L[R] M)ˣ), ContinuousLinearEquiv.toUnit (ContinuousLinearEquiv.ofUnit f) = f),\n                  right_inv :=\n                    (_ : ∀ (f : M ≃L[R] M), ContinuousLinearEquiv.ofUnit (ContinuousLinearEquiv.toUnit f) = f) }\n                y) }","name":"ContinuousLinearEquiv.unitsEquiv","doc":"The units of the algebra of continuous `R`-linear endomorphisms of `M` is multiplicatively\nequivalent to the type of continuous linear equivalences between `M` and itself. ","depth":30},{"term":"fun {𝕜} {E} [NormedAddCommGroup E] [NontriviallyNormedField 𝕜] [NormedSpace 𝕜 E] =>\n  let src := ContinuousLinearMap.toNormedAddCommGroup;\n  let src_1 := ContinuousLinearMap.toSemiNormedRing;\n  NormedRing.mk (_ : ∀ (x y : E →L[𝕜] E), dist x y = ‖x - y‖) (_ : ∀ (a b : E →L[𝕜] E), ‖a * b‖ ≤ ‖a‖ * ‖b‖)","name":"ContinuousLinearMap.toNormedRing","doc":"Continuous linear maps form a normed ring with respect to the operator norm. ","depth":31},{"term":"fun {𝕜} {E} [SeminormedAddCommGroup E] [NontriviallyNormedField 𝕜] [NormedSpace 𝕜 E] =>\n  let src := ContinuousLinearMap.algebra;\n  NormedAlgebra.mk (_ : ∀ (c : 𝕜) (f : E →L[𝕜] E), ‖c • f‖ ≤ ‖c‖ * ‖f‖)","name":"ContinuousLinearMap.toNormedAlgebra","doc":"For a normed space `E`, continuous linear endomorphisms form a normed algebra with\nrespect to the operator norm. ","depth":34}],"count":43}
{"noDocExamples":[],"kind":"«term_⋖_»","examples":[{"term":"fun {α} [LT α] a => ∀ (b : α), ¬b ⋖ a","name":"Order.IsSuccLimit","doc":"A successor limit is a value that doesn't cover any other.\n\nIt's so named because in a successor order, a successor limit can't be the successor of anything\nsmaller. ","depth":9},{"term":"fun {α} [LT α] a => ∀ (b : α), ¬a ⋖ b","name":"Order.IsPredLimit","doc":"A predecessor limit is a value that isn't covered by any other.\n\nIt's so named because in a predecessor order, a predecessor limit can't be the predecessor of\nanything greater. ","depth":9},{"term":"fun α [Preorder α] => SimpleGraph.mk fun a b => a ⋖ b ∨ b ⋖ a","name":"SimpleGraph.hasse","doc":"The Hasse diagram of an order as a simple graph. The graph of the covering relation. ","depth":14},{"term":"fun {α} [Preorder α] n [GradeOrder (Fin n) α] =>\n  GradeOrder.liftLeft Fin.val (_ : StrictMono Fin.val) (_ : ∀ (x x_1 : Fin n), x ⋖ x_1 → ↑x ⋖ ↑x_1)","name":"GradeOrder.finToNat","doc":"A `Fin n`-graded order is also `ℕ`-graded. We do not mark this an instance because `n` is not\ninferrable. ","depth":15},{"term":"fun {α} [Preorder α] n [GradeMinOrder (Fin n) α] =>\n  GradeMinOrder.liftLeft Fin.val (_ : StrictMono Fin.val) (_ : ∀ (x x_1 : Fin n), x ⋖ x_1 → ↑x ⋖ ↑x_1)\n    (_ : ∀ (a : Fin n), IsMin a → IsMin ↑a)","name":"GradeMinOrder.finToNat","doc":"A `Fin n`-graded order is also `ℕ`-graded. We do not mark this an instance because `n` is not\ninferrable. ","depth":16}],"count":41}
{"noDocExamples":[{"term":"fun {m} [Monad m] => CategoryTheory.CategoryStruct.mk (fun x x_1 => pure x_1) fun {X Y Z} f g => f >=> g","name":"CategoryTheory.KleisliCat.categoryStruct","depth":16},{"term":"Lean.PrettyPrinter.Delaborator.whenPPOption Lean.getPPNotation do\n  let e ← Lean.PrettyPrinter.Delaborator.SubExpr.getExpr\n  let s ←\n    (Mathlib.Notation3.matchVar `r >=>\n          Mathlib.Notation3.matchScoped `r `f\n              (Mathlib.Notation3.fnArgMatcher 7 (Mathlib.Notation3.matchConst `MeasureTheory.average)\n                #[(5,\n                    Mathlib.Notation3.fnArgMatcher 2 (Mathlib.Notation3.matchConst `MeasureTheory.MeasureSpace.volume)\n                      #[]),\n                  (6, Mathlib.Notation3.matchVar `f)]) >=>\n            pure)\n        Mathlib.Notation3.MatchState.empty\n  let binders ←\n    do\n      let info ← Lean.MonadRef.mkInfoFromRefPos\n      let _ ← Lean.getCurrMacroScope\n      let _ ← Lean.getMainModule\n      pure\n          {\n            raw :=\n              Lean.Syntax.node1 info `Std.ExtendedBinder.extBinders\n                (Lean.Syntax.node1 info `Std.ExtendedBinder.extBinderCollection\n                  (Lean.Syntax.node info `null\n                    (Array.append #[] (Lean.TSyntaxArray.raw (Mathlib.Notation3.MatchState.getBinders s))))) }\n  let r ← Mathlib.Notation3.MatchState.delabVar s `r (some e)\n  let info ← Lean.MonadRef.mkInfoFromRefPos\n  let _ ← Lean.getCurrMacroScope\n  let _ ← Lean.getMainModule\n  pure\n      {\n        raw :=\n          Lean.Syntax.node4 info `MeasureTheory.term⨍_,_ (Lean.Syntax.atom info \"⨍ \") binders.raw\n            (Lean.Syntax.atom info \", \") r.raw }","name":"MeasureTheory.«term⨍_,_».delab","depth":27},{"term":"Lean.PrettyPrinter.Delaborator.whenPPOption Lean.getPPNotation do\n  let e ← Lean.PrettyPrinter.Delaborator.SubExpr.getExpr\n  let s ←\n    (Mathlib.Notation3.matchVar `r >=>\n          Mathlib.Notation3.matchScoped `r `f\n              (Mathlib.Notation3.fnArgMatcher 4 (Mathlib.Notation3.matchConst `finprod)\n                #[(3, Mathlib.Notation3.matchVar `f)]) >=>\n            pure)\n        Mathlib.Notation3.MatchState.empty\n  let binders ←\n    do\n      let info ← Lean.MonadRef.mkInfoFromRefPos\n      let _ ← Lean.getCurrMacroScope\n      let _ ← Lean.getMainModule\n      pure\n          {\n            raw :=\n              Lean.Syntax.node1 info `Std.ExtendedBinder.extBinders\n                (Lean.Syntax.node1 info `Std.ExtendedBinder.extBinderCollection\n                  (Lean.Syntax.node info `null\n                    (Array.append #[] (Lean.TSyntaxArray.raw (Mathlib.Notation3.MatchState.getBinders s))))) }\n  let r ← Mathlib.Notation3.MatchState.delabVar s `r (some e)\n  let info ← Lean.MonadRef.mkInfoFromRefPos\n  let _ ← Lean.getCurrMacroScope\n  let _ ← Lean.getMainModule\n  pure\n      {\n        raw :=\n          Lean.Syntax.node4 info `term∏ᶠ_,_ (Lean.Syntax.atom info \"∏ᶠ \") binders.raw (Lean.Syntax.atom info \", \")\n            r.raw }","name":"«term∏ᶠ_,_».delab","depth":27},{"term":"Lean.PrettyPrinter.Delaborator.whenPPOption Lean.getPPNotation do\n  let e ← Lean.PrettyPrinter.Delaborator.SubExpr.getExpr\n  let s ←\n    (Mathlib.Notation3.matchVar `r >=>\n          Mathlib.Notation3.matchScoped `r `f\n              (Mathlib.Notation3.fnArgMatcher 3 (Mathlib.Notation3.matchConst `Set.iUnion)\n                #[(2, Mathlib.Notation3.matchVar `f)]) >=>\n            pure)\n        Mathlib.Notation3.MatchState.empty\n  let binders ←\n    do\n      let info ← Lean.MonadRef.mkInfoFromRefPos\n      let _ ← Lean.getCurrMacroScope\n      let _ ← Lean.getMainModule\n      pure\n          {\n            raw :=\n              Lean.Syntax.node1 info `Std.ExtendedBinder.extBinders\n                (Lean.Syntax.node1 info `Std.ExtendedBinder.extBinderCollection\n                  (Lean.Syntax.node info `null\n                    (Array.append #[] (Lean.TSyntaxArray.raw (Mathlib.Notation3.MatchState.getBinders s))))) }\n  let r ← Mathlib.Notation3.MatchState.delabVar s `r (some e)\n  let info ← Lean.MonadRef.mkInfoFromRefPos\n  let _ ← Lean.getCurrMacroScope\n  let _ ← Lean.getMainModule\n  pure\n      {\n        raw :=\n          Lean.Syntax.node4 info `Set.term⋃_,_ (Lean.Syntax.atom info \"⋃ \") binders.raw (Lean.Syntax.atom info \", \")\n            r.raw }","name":"Set.«term⋃_,_».delab","depth":27},{"term":"Lean.PrettyPrinter.Delaborator.whenPPOption Lean.getPPNotation do\n  let e ← Lean.PrettyPrinter.Delaborator.SubExpr.getExpr\n  let s ←\n    (Mathlib.Notation3.matchVar `r >=>\n          Mathlib.Notation3.matchScoped `r `f\n              (Mathlib.Notation3.fnArgMatcher 4 (Mathlib.Notation3.matchConst `finsum)\n                #[(3, Mathlib.Notation3.matchVar `f)]) >=>\n            pure)\n        Mathlib.Notation3.MatchState.empty\n  let binders ←\n    do\n      let info ← Lean.MonadRef.mkInfoFromRefPos\n      let _ ← Lean.getCurrMacroScope\n      let _ ← Lean.getMainModule\n      pure\n          {\n            raw :=\n              Lean.Syntax.node1 info `Std.ExtendedBinder.extBinders\n                (Lean.Syntax.node1 info `Std.ExtendedBinder.extBinderCollection\n                  (Lean.Syntax.node info `null\n                    (Array.append #[] (Lean.TSyntaxArray.raw (Mathlib.Notation3.MatchState.getBinders s))))) }\n  let r ← Mathlib.Notation3.MatchState.delabVar s `r (some e)\n  let info ← Lean.MonadRef.mkInfoFromRefPos\n  let _ ← Lean.getCurrMacroScope\n  let _ ← Lean.getMainModule\n  pure\n      {\n        raw :=\n          Lean.Syntax.node4 info `term∑ᶠ_,_ (Lean.Syntax.atom info \"∑ᶠ \") binders.raw (Lean.Syntax.atom info \", \")\n            r.raw }","name":"«term∑ᶠ_,_».delab","depth":27}],"kind":"«term_>=>_»","examples":[],"count":41}
{"noDocExamples":[],"kind":"«term￢_»","examples":[{"term":"fun {α} [CoheytingAlgebra α] a => a ⊓ ￢a","name":"Coheyting.boundary","doc":"The boundary of an element of a co-Heyting algebra is the intersection of its Heyting negation\nwith itself. Note that this is always `⊥` for a boolean algebra. ","depth":10},{"term":"fun {α} [CoheytingAlgebra α] a b =>\n  id\n    (Eq.mpr (id (hnot_inf_distrib a b ▸ Eq.refl (a ⊓ b ⊓ ￢(a ⊓ b) = a ⊓ ￢a ⊓ b ⊔ a ⊓ (b ⊓ ￢b))))\n      (Eq.mpr (id (inf_sup_left ▸ Eq.refl (a ⊓ b ⊓ (￢a ⊔ ￢b) = a ⊓ ￢a ⊓ b ⊔ a ⊓ (b ⊓ ￢b))))\n        (Eq.mpr (id (inf_right_comm a b (￢a) ▸ Eq.refl (a ⊓ b ⊓ ￢a ⊔ a ⊓ b ⊓ ￢b = a ⊓ ￢a ⊓ b ⊔ a ⊓ (b ⊓ ￢b))))\n          (Eq.mpr (id (Eq.symm inf_assoc ▸ Eq.refl (a ⊓ ￢a ⊓ b ⊔ a ⊓ b ⊓ ￢b = a ⊓ ￢a ⊓ b ⊔ a ⊓ (b ⊓ ￢b))))\n            (Eq.refl (a ⊓ ￢a ⊓ b ⊔ a ⊓ b ⊓ ￢b))))))","name":"Coheyting.boundary_inf","doc":"**Leibniz rule** for the co-Heyting boundary. ","depth":32},{"term":"fun {α} {β} [Sup α] [Inf α] [inst_2 : Top α] [Bot α] [inst_4 : HNot α] [SDiff α] [CoheytingAlgebra β] f hf map_sup\n    map_inf map_top map_bot map_hnot map_sdiff =>\n  let src := Function.Injective.generalizedCoheytingAlgebra f hf map_sup map_inf map_bot map_sdiff;\n  let src_1 := inst_2;\n  let src_2 := inst_4;\n  CoheytingAlgebra.mk (_ : ∀ (a : α), f a ≤ f ⊤) (_ : ∀ (a : α), ⊤ \\ a = ￢a)","name":"Function.Injective.coheytingAlgebra","doc":"Pullback a `CoheytingAlgebra` along an injection. ","depth":38},{"term":"fun {α} [CoheytingAlgebra α] {a b} =>\n  (fun {α} [CoheytingAlgebra α] {a b} =>\n      Eq.mpr (id (Eq.symm (top_sdiff' a) ▸ Eq.refl (￢a ≤ b ↔ Codisjoint a b)))\n        (Eq.mpr (id (propext sdiff_le_iff ▸ Eq.refl (⊤ \\ a ≤ b ↔ Codisjoint a b)))\n          (Eq.mpr (id (propext codisjoint_iff_le_sup ▸ Eq.refl (⊤ ≤ a ⊔ b ↔ Codisjoint a b))) Iff.rfl))).mpr","name":"Codisjoint.hnot_le_right","doc":"**Alias** of the reverse direction of `hnot_le_iff_codisjoint_right`.","depth":38},{"term":"fun {α} {β} [Sup α] [Inf α] [Top α] [Bot α] [HasCompl α] [HNot α] [HImp α] [SDiff α] [BiheytingAlgebra β] f hf map_sup\n    map_inf map_top map_bot map_compl map_hnot map_himp map_sdiff =>\n  let src := Function.Injective.heytingAlgebra f hf map_sup map_inf map_top map_bot map_compl map_himp;\n  let src_1 := Function.Injective.coheytingAlgebra f hf map_sup map_inf map_top map_bot map_hnot map_sdiff;\n  BiheytingAlgebra.mk (_ : ∀ (a b c : α), a \\ b ≤ c ↔ a ≤ b ⊔ c) (_ : ∀ (a : α), ⊤ \\ a = ￢a)","name":"Function.Injective.biheytingAlgebra","doc":"Pullback a `BiheytingAlgebra` along an injection. ","depth":42}],"count":37}
{"noDocExamples":[],"kind":"«term_→ₐ[_]_»","examples":[{"term":"fun K [Field K] [NumberField K] A [Field A] [CharZero A] => Fintype.ofEquiv (K →ₐ[ℚ] A) RingHom.equivRatAlgHom.symm","name":"NumberField.Embeddings.instFintypeRingHomToNonAssocSemiringToSemiringToDivisionSemiringToSemifieldToNonAssocSemiringToSemiringToDivisionSemiringToSemifield","doc":"There are finitely many embeddings of a number field. ","depth":18},{"term":"fun F K L [Field F] [Field K] [Field L] [Algebra F K] [Algebra F L] => ⨆ (f : K →ₐ[F] L), AlgHom.fieldRange f","name":"normalClosure","doc":"The normal closure of `K` in `L`. ","depth":19},{"term":"fun {R} {S} [Ring R] [Ring S] [Algebra ℚ R] [Algebra ℚ S] =>\n  { toFun := RingHom.toRatAlgHom, invFun := AlgHom.toRingHom,\n    left_inv := (_ : ∀ (f : R →+* S), ↑(RingHom.toRatAlgHom f) = f),\n    right_inv := (_ : ∀ (f : R →ₐ[ℚ] S), RingHom.toRatAlgHom ↑f = f) }","name":"RingHom.equivRatAlgHom","doc":"The equivalence between `RingHom` and `ℚ`-algebra homomorphisms. ","depth":19},{"term":"fun {R} {A} [CommRing R] [Ring A] [Algebra R A] {c₁ c₂} =>\n  { toFun := QuaternionAlgebra.Basis.liftHom,\n    invFun := QuaternionAlgebra.Basis.compHom (QuaternionAlgebra.Basis.self R),\n    left_inv :=\n      (_ :\n        ∀ (q : QuaternionAlgebra.Basis A c₁ c₂),\n          QuaternionAlgebra.Basis.compHom (QuaternionAlgebra.Basis.self R) (QuaternionAlgebra.Basis.liftHom q) = q),\n    right_inv :=\n      (_ :\n        ∀ (F : QuaternionAlgebra R c₁ c₂ →ₐ[R] A),\n          QuaternionAlgebra.Basis.liftHom (QuaternionAlgebra.Basis.compHom (QuaternionAlgebra.Basis.self R) F) = F) }","name":"QuaternionAlgebra.lift","doc":"A quaternionic basis on `A` is equivalent to a map from the quaternion algebra to `A`. ","depth":23},{"term":"fun K L [Field K] [Field L] [Algebra K L] ha =>\n  {\n    toEquiv :=\n      { toFun := fun ϕ => ↑ϕ, invFun := fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ),\n        left_inv :=\n          (_ : ∀ (x : L ≃ₐ[K] L), (fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ)) ((fun ϕ => ↑ϕ) x) = x),\n        right_inv :=\n          (_ :\n            ∀ (x : L →ₐ[K] L), (fun ϕ => ↑ϕ) ((fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ)) x) = x) },\n    map_mul' :=\n      (_ :\n        ∀ (x x_1 : L ≃ₐ[K] L),\n          Equiv.toFun\n              { toFun := fun ϕ => ↑ϕ, invFun := fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ),\n                left_inv :=\n                  (_ :\n                    ∀ (x : L ≃ₐ[K] L),\n                      (fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ)) ((fun ϕ => ↑ϕ) x) = x),\n                right_inv :=\n                  (_ :\n                    ∀ (x : L →ₐ[K] L),\n                      (fun ϕ => ↑ϕ) ((fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ)) x) = x) }\n              (x * x_1) =\n            Equiv.toFun\n              { toFun := fun ϕ => ↑ϕ, invFun := fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ),\n                left_inv :=\n                  (_ :\n                    ∀ (x : L ≃ₐ[K] L),\n                      (fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ)) ((fun ϕ => ↑ϕ) x) = x),\n                right_inv :=\n                  (_ :\n                    ∀ (x : L →ₐ[K] L),\n                      (fun ϕ => ↑ϕ) ((fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ)) x) = x) }\n              (x * x_1)) }","name":"Algebra.IsAlgebraic.algEquivEquivAlgHom","doc":"Bijection between algebra equivalences and algebra homomorphisms ","depth":23}],"count":37}
{"noDocExamples":[],"kind":"«term_→*_»","examples":[{"term":"fun M [MulOneClass M] => M →* M","name":"Monoid.End","doc":"The monoid of endomorphisms. ","depth":6},{"term":"fun M N [Monoid M] [Monoid N] => M →* N","name":"MonCat.AssocMonoidHom","doc":"`MonoidHom` doesn't actually assume associativity. This alias is needed to make the category\ntheory machinery work. ","depth":8},{"term":"fun R [AddMonoid R] R' [CommMonoid R'] => Multiplicative R →* R'","name":"AddChar","doc":"Define `AddChar R R'` as `(Multiplicative R) →* R'`.\nThe definition works for an additive monoid `R` and a monoid `R'`,\nbut we will restrict to the case that both are commutative rings below.\nWe assume right away that `R'` is commutative, so that `AddChar R R'` carries\na structure of commutative monoid.\nThe trivial additive character (sending everything to `1`) is `(1 : AddChar R R').` ","depth":9},{"term":"fun {M} {N} [MulOneClass M] [CommMonoid N] => MonoidHom.flip (MonoidHom.id (M →* N))","name":"MonoidHom.eval","doc":"Evaluation of a `MonoidHom` at a point as a monoid homomorphism. See also `MonoidHom.apply`\nfor the evaluation of any function at a point. ","depth":15},{"term":"fun {R} [CommMonoid R] {R'} [CommMonoidWithZero R'] =>\n  { toFun := MulChar.toUnitHom, invFun := MulChar.ofUnitHom,\n    left_inv := (_ : ∀ (χ : MulChar R R'), MulChar.ofUnitHom (MulChar.toUnitHom χ) = χ),\n    right_inv := (_ : ∀ (f : Rˣ →* R'ˣ), MulChar.toUnitHom (MulChar.ofUnitHom f) = f) }","name":"MulChar.equivToUnitHom","doc":"The equivalence between multiplicative characters and homomorphisms of unit groups. ","depth":16}],"count":37}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term⊥__»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasStrictInitialObjects C]\n    [CategoryTheory.Limits.HasInitial C] X [CategoryTheory.Limits.HasBinaryProduct X (⊥_ C)] =>\n  CategoryTheory.Limits.mulIsInitial X CategoryTheory.Limits.initialIsInitial","name":"CategoryTheory.Limits.mulInitial","doc":"The product of `X` with an initial object in a category with strict initial objects is itself\ninitial.\nThis is the generalisation of the fact that `X × Empty ≃ Empty` for types (or `n * 0 = 0`).\n","depth":13},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasStrictInitialObjects C]\n    [CategoryTheory.Limits.HasInitial C] X [CategoryTheory.Limits.HasBinaryProduct (⊥_ C) X] =>\n  CategoryTheory.Limits.isInitialMul X CategoryTheory.Limits.initialIsInitial","name":"CategoryTheory.Limits.initialMul","doc":"The product of `X` with an initial object in a category with strict initial objects is itself\ninitial.\nThis is the generalisation of the fact that `Empty × X ≃ Empty` for types (or `0 * n = 0`).\n","depth":13},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] {D} [CategoryTheory.Category.{v₂, u₂} D] G\n    [CategoryTheory.Limits.HasInitial C] [CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) G] =>\n  CategoryTheory.Limits.IsInitial.isInitialObj G (⊥_ C) CategoryTheory.Limits.initialIsInitial","name":"CategoryTheory.Limits.isColimitOfHasInitialOfPreservesColimit","doc":"If `G` preserves the initial object and `C` has an initial object, then the image of the initial\nobject is initial.\n","depth":15},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] {D} [CategoryTheory.Category.{v₂, u₂} D] G\n    [CategoryTheory.Limits.HasInitial C] [CategoryTheory.Limits.HasInitial D] =>\n  CategoryTheory.Limits.initial.to (G.obj (⊥_ C))","name":"CategoryTheory.Limits.initialComparison","doc":"The comparison morphism from the initial object in the target category to the image of the initial\nobject.\n","depth":16},{"term":"fun {C} {D} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.Category.{v₂, u₂} D] G\n    [∀ (A : C), CategoryTheory.Limits.HasInitial (CategoryTheory.StructuredArrow A G)] =>\n  CategoryTheory.Adjunction.adjunctionOfEquivLeft (CategoryTheory.leftAdjointOfStructuredArrowInitialsAux G)\n    (_ :\n      ∀ (x : C) (x_1 a : D) (a_1 : x_1 ⟶ a) (a_2 : (⊥_ CategoryTheory.StructuredArrow x G).right ⟶ x_1),\n        CategoryTheory.CategoryStruct.comp (⊥_ CategoryTheory.StructuredArrow x G).hom\n            (G.map (CategoryTheory.CategoryStruct.comp a_2 a_1)) =\n          CategoryTheory.CategoryStruct.comp\n            (CategoryTheory.CategoryStruct.comp (⊥_ CategoryTheory.StructuredArrow x G).hom (G.map a_2)) (G.map a_1))","name":"CategoryTheory.adjunctionOfStructuredArrowInitials","doc":"If each structured arrow category on `G` has an initial object, we have a constructed left adjoint\nto `G`.\n","depth":20}],"count":36}
{"noDocExamples":[],"kind":"Filter.«term∃ᶠ_In_,_»","examples":[{"term":"fun p x => ∃ C, ∃ᶠ (n : ℕ) in Filter.atTop, ∃ m, x ≠ ↑m / ↑n ∧ |x - ↑m / ↑n| < C / ↑n ^ p","name":"LiouvilleWith","doc":"We say that a real number `x` is a Liouville number with exponent `p : ℝ` if there exists a real\nnumber `C` such that for infinitely many denominators `n` there exists a numerator `m` such that\n`x ≠ m / n` and `|x - m / n| < C / n ^ p`.\n\nA number is a Liouville number in the sense of `Liouville` if it is `LiouvilleWith` any real\nexponent. ","depth":20},{"term":"fun {α} [TopologicalSpace α] {f} =>\n  Eq.mpr\n    (id\n      (congrArg IsClosed\n        (Eq.trans\n          (congrArg setOf\n            (funext fun x =>\n              Eq.trans Mathlib.Topology.Basic._auxLemma.44\n                (forall_congr fun {p} => Mathlib.Topology.Basic._auxLemma.10)))\n          (Set.setOf_forall fun i x => (¬∀ᶠ (x : α) in nhds x, i x) ∨ ∃ᶠ (x : α) in f, i x))))\n    (isClosed_iInter fun p =>\n      IsClosed.union (Iff.mpr isClosed_compl_iff isOpen_setOf_eventually_nhds)\n        (Iff.mpr isClosed_compl_iff isOpen_const))","name":"isClosed_setOf_clusterPt","doc":"The set of cluster points of a filter is closed. In particular, the set of limit points\nof a sequence is closed. ","depth":23},{"term":"fun {α} [TopologicalSpace α] {s} =>\n  Eq.mpr\n    (id\n      (Eq.symm (propext closure_subset_iff_isClosed) ▸\n        Eq.refl (IsClosed s ↔ ∀ (x : α), (∃ᶠ (y : α) in nhds x, y ∈ s) → x ∈ s)))\n    (forall_congr' fun x =>\n      Eq.mpr\n        (id\n          (propext mem_closure_iff_frequently ▸\n            Eq.refl (x ∈ closure s → x ∈ s ↔ (∃ᶠ (y : α) in nhds x, y ∈ s) → x ∈ s)))\n        Iff.rfl)","name":"isClosed_iff_frequently","doc":"A set `s` is closed iff for every point `x`, if there is a point `y` close to `x` that belongs\nto `s` then `x` is in `s`. ","depth":26},{"term":"fun {α} [TopologicalSpace α] x C =>\n  of_eq_true\n    (Eq.trans\n      (congrFun\n        (congrArg Iff\n          (Eq.trans (Eq.trans (Mathlib.Topology.Basic._auxLemma.46 x C) Mathlib.Topology.Basic._auxLemma.47)\n            (congrFun\n              (congrArg Filter.Frequently\n                (funext fun y =>\n                  Eq.trans\n                    (Eq.trans (Mathlib.Data.Set.Basic._auxLemma.84 y)\n                      (congrArg (And (y ∈ C)) (congrArg Not Mathlib.Data.Set.Basic._auxLemma.44)))\n                    Mathlib.Topology.Basic._auxLemma.48))\n              (nhds x))))\n        (∃ᶠ (y : α) in nhds x, ¬y = x ∧ y ∈ C))\n      (iff_self (∃ᶠ (y : α) in nhds x, ¬y = x ∧ y ∈ C)))","name":"accPt_iff_frequently","doc":"`x` is an accumulation point of a set `C` iff\nthere are points near `x` in `C` and different from `x`.","depth":29},{"term":"fun {τ} {α} {β} [TopologicalSpace β] f ϕ s y =>\n  Eq.mpr\n    (id\n      (congrFun (congrArg Iff (Mathlib.Dynamics.OmegaLimit._auxLemma.4 f ϕ s y))\n        (∀ (n : Set β), n ∈ nhds y → ∃ᶠ (t : τ) in f, Set.Nonempty (ϕ t '' s ∩ n))))\n    (of_eq_true\n      (Eq.trans\n        (congrArg (Iff (∀ (n : Set β), n ∈ nhds y → ∃ᶠ (t : τ) in f, Set.Nonempty (s ∩ ϕ t ⁻¹' n)))\n          (forall_congr fun n =>\n            implies_congr (Eq.refl (n ∈ nhds y))\n              (congrFun (congrArg Filter.Frequently (funext fun t => Mathlib.Dynamics.OmegaLimit._auxLemma.5)) f)))\n        (iff_self (∀ (n : Set β), n ∈ nhds y → ∃ᶠ (t : τ) in f, Set.Nonempty (s ∩ ϕ t ⁻¹' n)))))","name":"mem_omegaLimit_iff_frequently₂","doc":"An element `y` is in the ω-limit set of `s` w.r.t. `f` if the\nforward images of `s` frequently (w.r.t. `f`) intersect arbitrary\nneighbourhoods of `y`. ","depth":30}],"count":36}
{"noDocExamples":[],"kind":"«term_→+_»","examples":[{"term":"fun A [AddZeroClass A] => A →+ A","name":"AddMonoid.End","doc":"The monoid of endomorphisms. ","depth":6},{"term":"fun M N [AddMonoid M] [AddMonoid N] => M →+ N","name":"AddMonCat.AssocAddMonoidHom","doc":"`AddMonoidHom` doesn't actually assume associativity. This alias is needed to make\nthe category theory machinery work. ","depth":8},{"term":"fun {M} {N} [AddZeroClass M] [AddCommMonoid N] => AddMonoidHom.flip (AddMonoidHom.id (M →+ N))","name":"AddMonoidHom.eval","doc":"Evaluation of an `AddMonoidHom` at a point as an additive monoid homomorphism.\nSee also `AddMonoidHom.apply` for the evaluation of any function at a point.","depth":15},{"term":"fun A [AddMonoid A] =>\n  {\n    toFun := fun x =>\n      { toZeroHom := { toFun := fun n => n • x, map_zero' := (_ : 0 • x = 0) },\n        map_add' := (_ : ∀ (x_1 x_2 : ℕ), (x_1 + x_2) • x = x_1 • x + x_2 • x) },\n    invFun := fun f => ↑f 1, left_inv := (_ : ∀ (a : A), 1 • a = a),\n    right_inv :=\n      (_ :\n        ∀ (f : ℕ →+ A),\n          (fun x =>\n                { toZeroHom := { toFun := fun n => n • x, map_zero' := (_ : 0 • x = 0) },\n                  map_add' := (_ : ∀ (x_1 x_2 : ℕ), (x_1 + x_2) • x = x_1 • x + x_2 • x) })\n              ((fun f => ↑f 1) f) =\n            f) }","name":"multiplesHom","doc":"Additive homomorphisms from `ℕ` are defined by the image of `1`. ","depth":20},{"term":"fun A [AddGroup A] =>\n  {\n    toFun := fun x =>\n      { toZeroHom := { toFun := fun n => n • x, map_zero' := (_ : 0 • x = 0) },\n        map_add' := (_ : ∀ (x_1 x_2 : ℤ), (x_1 + x_2) • x = x_1 • x + x_2 • x) },\n    invFun := fun f => ↑f 1, left_inv := (_ : ∀ (a : A), 1 • a = a),\n    right_inv :=\n      (_ :\n        ∀ (f : ℤ →+ A),\n          (fun x =>\n                { toZeroHom := { toFun := fun n => n • x, map_zero' := (_ : 0 • x = 0) },\n                  map_add' := (_ : ∀ (x_1 x_2 : ℤ), (x_1 + x_2) • x = x_1 • x + x_2 • x) })\n              ((fun f => ↑f 1) f) =\n            f) }","name":"zmultiplesHom","doc":"Additive homomorphisms from `ℤ` are defined by the image of `1`. ","depth":21}],"count":36}
{"noDocExamples":[],"kind":"Asymptotics.«term_=O[_]_»","examples":[{"term":"fun {α} {β} [Norm β] l f => f =O[l] 1","name":"Filter.BoundedAtFilter","doc":"If `l` is a filter on `α`, then a function `f: α → β` is `BoundedAtFilter l`\nif `f =O[l] 1`. ","depth":13},{"term":"fun {α} {E} {F} [Norm E] [Norm F] l f g => f =O[l] g ∧ g =O[l] f","name":"Asymptotics.IsTheta","doc":"We say that `f` is `Θ(g)` along a filter `l` (notation: `f =Θ[l] g`) if `f =O[l] g` and\n`g =O[l] f`. ","depth":18},{"term":"fun {α} {E} {F} [Norm E] [Norm F] {f} {g} {l} =>\n  Eq.mpr (id (Asymptotics.IsBigO_def l f g ▸ Eq.refl (f =O[l] g ↔ ∃ c, Asymptotics.IsBigOWith c l f g))) Iff.rfl","name":"Asymptotics.isBigO_iff_isBigOWith","doc":"Definition of `IsBigO` in terms of `IsBigOWith`. We record it in a lemma as `IsBigO` is\nirreducible. ","depth":30},{"term":"fun f g hfg =>\n  id\n    (Eq.mpr (id (congrArg (Eq (∑' (n : ℤ), ↑f ↑n)) (congrArg tsum (funext fun n => congrFun (Eq.symm hfg) ↑n))))\n      (Eq.mpr\n        (id\n          (Real.tsum_eq_tsum_fourierIntegral_of_rpow_decay (SchwartzMap.continuous f) one_lt_two\n              (SchwartzMap.isBigO_cocompact_rpow f (-2))\n              (Eq.mpr (id (hfg ▸ Eq.refl (Real.fourierIntegral ↑f =O[Filter.cocompact ℝ] fun x => |x| ^ (-2))))\n                (SchwartzMap.isBigO_cocompact_rpow g (-2))) ▸\n            Eq.refl (∑' (n : ℤ), ↑f ↑n = ∑' (n : ℤ), Real.fourierIntegral ↑f ↑n)))\n        (Eq.refl (∑' (n : ℤ), Real.fourierIntegral ↑f ↑n))))","name":"SchwartzMap.tsum_eq_tsum_fourierIntegral","doc":"**Poisson's summation formula** for Schwartz functions. ","depth":36},{"term":"fun {α} {E} {E'''} [Norm E] [SeminormedAddGroup E'''] {f} {l} {g} =>\n  {\n    mp := fun h =>\n      Exists.casesOn (Eq.mp (propext Asymptotics.isBigO_iff ▸ Eq.refl (f =O[l] g)) h) fun c hc =>\n        Exists.intro (max c 1)\n          { left := LT.lt.trans_le zero_lt_one (le_max_right c 1),\n            right :=\n              Filter.mp_mem hc\n                (Filter.univ_mem'\n                  (id fun x hx => LE.le.trans hx (mul_le_mul_of_nonneg_right (le_max_left c 1) (norm_nonneg (g x))))) },\n    mpr := fun h =>\n      Eq.mpr (id (propext Asymptotics.isBigO_iff ▸ Eq.refl (f =O[l] g)))\n        (Exists.casesOn h fun c h => And.casesOn h fun left hc => Exists.intro c hc) }","name":"Asymptotics.isBigO_iff'","doc":"Definition of `IsBigO` in terms of filters, with a positive constant. ","depth":38}],"count":35}
{"noDocExamples":[],"kind":"«term⨁_,_»","examples":[{"term":"fun {ι} [DecidableEq ι] {α} {δ} [(i : ι) → (j : α i) → AddCommMonoid (δ i j)] =>\n  { toZeroHom := { toFun := DFinsupp.sigmaCurry, map_zero' := (_ : DFinsupp.sigmaCurry 0 = 0) },\n    map_add' :=\n      (_ :\n        ∀ (f g : ⨁ (i : (_i : ι) × α _i), δ i.fst i.snd),\n          DFinsupp.sigmaCurry (f + g) = DFinsupp.sigmaCurry f + DFinsupp.sigmaCurry g) }","name":"DirectSum.sigmaCurry","doc":"The natural map between `⨁ (i : Σ i, α i), δ i.1 i.2` and `⨁ i (j : α i), δ i j`.","depth":24},{"term":"fun {R} {M} [CommSemiring R] [AddCommMonoid M] [Module R M] =>\n  AlgEquiv.ofAlgHom TensorAlgebra.toDirectSum TensorAlgebra.ofDirectSum\n    (_ : AlgHom.comp TensorAlgebra.toDirectSum TensorAlgebra.ofDirectSum = AlgHom.id R (⨁ (n : ℕ), TensorPower R n M))\n    (_ : AlgHom.comp TensorAlgebra.ofDirectSum TensorAlgebra.toDirectSum = AlgHom.id R (TensorAlgebra R M))","name":"TensorAlgebra.equivDirectSum","doc":"The tensor algebra is isomorphic to a direct sum of tensor powers. ","depth":25},{"term":"fun R [Semiring R] M ι [AddCommMonoid M] [Module R M] [Unique ι] =>\n  let src := DirectSum.id M ι;\n  let src_1 := DirectSum.toModule R ι M fun x => LinearMap.id;\n  {\n    toLinearMap :=\n      { toAddHom := src_1.toAddHom,\n        map_smul' :=\n          (_ :\n            ∀ (r : R) (x : ⨁ (i : ι), M),\n              AddHom.toFun (DirectSum.toModule R ι M fun x => LinearMap.id).toAddHom (r • x) =\n                ↑(RingHom.id R) r • AddHom.toFun (DirectSum.toModule R ι M fun x => LinearMap.id).toAddHom x) },\n    invFun := src.invFun,\n    left_inv := (_ : Function.LeftInverse (DirectSum.id M ι).toEquiv.invFun (DirectSum.id M ι).toEquiv.toFun),\n    right_inv := (_ : Function.RightInverse (DirectSum.id M ι).toEquiv.invFun (DirectSum.id M ι).toEquiv.toFun) }","name":"DirectSum.lid","doc":"The natural linear equivalence between `⨁ _ : ι, M` and `M` when `Unique ι`. ","depth":27},{"term":"fun M ι [AddCommMonoid M] [Unique ι] =>\n  let src := DirectSum.toAddMonoid fun x => AddMonoidHom.id M;\n  {\n    toEquiv :=\n      { toFun := ↑(DirectSum.toAddMonoid fun x => AddMonoidHom.id M), invFun := ↑(DirectSum.of (fun x => M) default),\n        left_inv :=\n          (_ :\n            ∀ (x : ⨁ (x : ι), M),\n              ↑(DirectSum.of (fun x => M) default) (↑(DirectSum.toAddMonoid fun x => AddMonoidHom.id M) x) = x),\n        right_inv :=\n          (_ :\n            ∀ (x : M),\n              ↑(DirectSum.toAddMonoid fun x => AddMonoidHom.id M) (↑(DirectSum.of (fun x => M) default) x) =\n                ↑(AddMonoidHom.id M) x) },\n    map_add' :=\n      (_ :\n        ∀ (x y : ⨁ (i : ι), M),\n          ZeroHom.toFun (↑(DirectSum.toAddMonoid fun x => AddMonoidHom.id M)) (x + y) =\n            ZeroHom.toFun (↑(DirectSum.toAddMonoid fun x => AddMonoidHom.id M)) x +\n              ZeroHom.toFun (↑(DirectSum.toAddMonoid fun x => AddMonoidHom.id M)) y) }","name":"DirectSum.id","doc":"The natural equivalence between `⨁ _ : ι, M` and `M` when `Unique ι`. ","depth":28},{"term":"fun R [Semiring R] {ι} [DecidableEq ι] {α} {δ} [(i : ι) → (j : α i) → AddCommMonoid (δ i j)]\n    [(i : ι) → (j : α i) → Module R (δ i j)] =>\n  let src := DirectSum.sigmaCurry;\n  {\n    toAddHom :=\n      { toFun := src.toFun,\n        map_add' :=\n          (_ :\n            ∀ (x y : ⨁ (i : (_i : ι) × α _i), δ i.fst i.snd),\n              ZeroHom.toFun (↑DirectSum.sigmaCurry) (x + y) =\n                ZeroHom.toFun (↑DirectSum.sigmaCurry) x + ZeroHom.toFun (↑DirectSum.sigmaCurry) y) },\n    map_smul' :=\n      (_ :\n        ∀ (r : R) (x : ⨁ (i : (i : ι) × α i), δ i.fst i.snd),\n          AddHom.toFun\n              { toFun := (↑DirectSum.sigmaCurry).toFun,\n                map_add' :=\n                  (_ :\n                    ∀ (x y : ⨁ (i : (_i : ι) × α _i), δ i.fst i.snd),\n                      ZeroHom.toFun (↑DirectSum.sigmaCurry) (x + y) =\n                        ZeroHom.toFun (↑DirectSum.sigmaCurry) x + ZeroHom.toFun (↑DirectSum.sigmaCurry) y) }\n              (r • x) =\n            ↑(RingHom.id R) r •\n              AddHom.toFun\n                { toFun := (↑DirectSum.sigmaCurry).toFun,\n                  map_add' :=\n                    (_ :\n                      ∀ (x y : ⨁ (i : (_i : ι) × α _i), δ i.fst i.snd),\n                        ZeroHom.toFun (↑DirectSum.sigmaCurry) (x + y) =\n                          ZeroHom.toFun (↑DirectSum.sigmaCurry) x + ZeroHom.toFun (↑DirectSum.sigmaCurry) y) }\n                x) }","name":"DirectSum.sigmaLcurry","doc":"`curry` as a linear map. ","depth":29}],"count":35}
{"noDocExamples":[{"term":"fun {C} [CategoryTheory.Category.{u_2, u_1} C] {X₁ X₂} [CategoryTheory.Limits.HasBinaryCoproduct X₁ X₂]\n    [CategoryTheory.Limits.CoproductDisjoint X₁ X₂] =>\n  CategoryTheory.Limits.CoproductDisjoint.mono_inl (X₁ ⨿ X₂) CategoryTheory.Limits.coprod.inl\n    CategoryTheory.Limits.coprod.inr (CategoryTheory.Limits.coprodIsCoprod X₁ X₂)","name":"CategoryTheory.Limits.instMonoCoprodInl.proof_1","depth":15},{"term":"fun {C} [CategoryTheory.Category.{u_2, u_1} C] {X₁ X₂} [CategoryTheory.Limits.HasBinaryCoproduct X₁ X₂]\n    [CategoryTheory.Limits.CoproductDisjoint X₁ X₂] =>\n  CategoryTheory.Limits.CoproductDisjoint.mono_inr (X₁ ⨿ X₂) CategoryTheory.Limits.coprod.inl\n    CategoryTheory.Limits.coprod.inr (CategoryTheory.Limits.coprodIsCoprod X₁ X₂)","name":"CategoryTheory.Limits.instMonoCoprodInr.proof_1","depth":15},{"term":"fun {C} [CategoryTheory.Category.{u_1, u_2} C] [CategoryTheory.Limits.HasBinaryCoproducts C] P Q R =>\n  CategoryTheory.Limits.hasColimitOfHasColimitsOfShape (CategoryTheory.Limits.pair P (Q ⨿ R))","name":"CategoryTheory.Limits.coprod.associator.proof_4","depth":15}],"kind":"CategoryTheory.Limits.«term_⨿_»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasBinaryCoproducts C] =>\n  CategoryTheory.Functor.mk\n    {\n      obj := fun X =>\n        CategoryTheory.Functor.mk\n          { obj := fun Y => X ⨿ Y,\n            map := fun {Y Z} => CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id X) },\n      map := fun {X Y} f =>\n        CategoryTheory.NatTrans.mk fun T => CategoryTheory.Limits.coprod.map f (CategoryTheory.CategoryStruct.id T) }","name":"CategoryTheory.Limits.coprod.functor","doc":"The binary coproduct functor. ","depth":44},{"term":"fun C [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasInitial C]\n    [CategoryTheory.Limits.HasBinaryCoproducts C] =>\n  CategoryTheory.MonoidalCategory.ofTensorHom (fun X Y => X ⨿ Y)\n    (fun {X₁ Y₁ X₂ Y₂} f g => CategoryTheory.Limits.coprod.map f g)\n    (fun X x x_1 f =>\n      (fun {X₁ Y₁ X₂ Y₂} f g => CategoryTheory.Limits.coprod.map f g) (CategoryTheory.CategoryStruct.id X) f)\n    (fun {X₁ X₂} f Y =>\n      (fun {X₁ Y₁ X₂ Y₂} f g => CategoryTheory.Limits.coprod.map f g) f (CategoryTheory.CategoryStruct.id Y))\n    (⊥_ C) CategoryTheory.Limits.coprod.associator CategoryTheory.Limits.coprod.leftUnitor\n    CategoryTheory.Limits.coprod.rightUnitor","name":"CategoryTheory.monoidalOfHasFiniteCoproducts","doc":"A category with an initial object and binary coproducts has a natural monoidal structure. ","depth":45}],"count":34}
{"noDocExamples":[],"kind":"Lean.Parser.Term.namedPattern","examples":[{"term":"fun {α} x =>\n  match x with\n  | [] => [[]]\n  | l@h:(head :: tail) => List.dropLast (List.zipWith (fun x x_1 => x ++ x_1) (List.tails l) (List.inits l))","name":"List.cyclicPermutations","doc":"List of all cyclic permutations of `l`.\nThe `cyclicPermutations` of a nonempty list `l` will always contain `List.length l` elements.\nThis implies that under certain conditions, there are duplicates in `List.cyclicPermutations l`.\nThe `n`th entry is equal to `l.rotate n`, proven in `List.nthLe_cyclicPermutations`.\nThe proof that every cyclic permutant of `l` is in the list is `List.mem_cyclicPermutations_iff`.\n\n     cyclicPermutations [1, 2, 3, 2, 4] =\n       [[1, 2, 3, 2, 4], [2, 3, 2, 4, 1], [3, 2, 4, 1, 2],\n        [2, 4, 1, 2, 3], [4, 1, 2, 3, 2]] ","depth":20},{"term":"fun e n o =>\n  match o with\n  | ONote.zero => ONote.oadd e n 0\n  | o'@h:(ONote.oadd e' n' a') =>\n    match ONote.cmp e e' with\n    | Ordering.lt => o'\n    | Ordering.eq => ONote.oadd e (n + n') a'\n    | Ordering.gt => ONote.oadd e n o'","name":"ONote.addAux","doc":"Auxiliary definition for `add` ","depth":20},{"term":"fun x x_1 =>\n  match x, x_1 with\n  | 0, x => x\n  | n@h:(Nat.succ n_1), x => if ZMod.val x ≤ n / 2 then ↑(ZMod.val x) else ↑(ZMod.val x) - ↑n","name":"ZMod.valMinAbs","doc":"`valMinAbs x` returns the integer in the same equivalence class as `x` that is closest to `0`,\nThe result will be in the interval `(-n/2, n/2]`. ","depth":23},{"term":"fun o₂ o₁ =>\n  match o₁ with\n  | (ONote.zero, 0) => if o₂ = 0 then 1 else 0\n  | (ONote.zero, 1) => 1\n  | (ONote.zero, Nat.succ m) =>\n    match ONote.split' o₂ with\n    | (b', k) => ONote.oadd b' (Nat.succPNat m ^ k) 0\n  | (a@h:(ONote.oadd a0 a_1 a_2), m) =>\n    match ONote.split o₂ with\n    | (b, 0) => ONote.oadd (a0 * b) 1 0\n    | (b, Nat.succ k) =>\n      let eb := a0 * b;\n      ONote.scale (eb + ONote.mulNat a0 k) a + ONote.opowAux eb a0 (ONote.mulNat a m) k m","name":"ONote.opowAux2","doc":"Auxiliary definition to compute the ordinal notation for the ordinal\nexponentiation in `opow` ","depth":23},{"term":"fun x =>\n  match x with\n  | [] => pure q(0)\n  | L@h_1:(h :: tail) => do\n    let __discr ← Qq.inferTypeQ' h\n    match __discr with\n      | { fst := fst, snd := { fst := α, snd := snd } } => do\n        let inst ← Qq.synthInstanceQ q(AddMonoid «$α»)\n        pure (Linarith.addExprs' inst L)","name":"Linarith.addExprs","doc":"`addExprs L` creates an `Expr` representing the sum of the elements of `L`, associated left. ","depth":24}],"count":34}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term∐_»","examples":[{"term":"fun {C} [CategoryTheory.Category.{u_2, u_1} C] N Δ [CategoryTheory.Limits.HasFiniteCoproducts C] =>\n  ∐ SimplicialObject.Splitting.summand N Δ","name":"SimplicialObject.Splitting.coprod","doc":"The coproduct of the family `summand N Δ` ","depth":11},{"term":"fun {C} [CategoryTheory.Category.{v, u₁} C] D [CategoryTheory.Limits.HasCoproduct D.U] => ∐ D.U","name":"CategoryTheory.GlueData.sigmaOpens","doc":"(Implementation) The disjoint union of `U i`. ","depth":12},{"term":"fun {C} [CategoryTheory.Category.{u_2, u_1} C] [CategoryTheory.Preadditive C] K Δ\n    [CategoryTheory.Limits.HasFiniteCoproducts C] =>\n  ∐ fun A => AlgebraicTopology.DoldKan.Γ₀.Obj.summand K Δ A","name":"AlgebraicTopology.DoldKan.Γ₀.Obj.obj₂","doc":"The functor `Γ₀` sends a chain complex `K` to the simplicial object which\nsends `Δ` to the direct sum of the objects `summand K Δ A` for all `A : Splitting.IndexSet Δ` ","depth":15},{"term":"fun β C [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasCoproducts C] =>\n  CategoryTheory.Functor.mk\n    { obj := fun X => ∐ fun i => X i, map := fun {X Y} f => CategoryTheory.Limits.Sigma.map fun i => f i }","name":"CategoryTheory.GradedObject.total","doc":"The total object of a graded object is the coproduct of the graded components.\n","depth":19},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] {ι} f g [∀ (i : ι), CategoryTheory.Limits.HasCoproduct (g i)]\n    [CategoryTheory.Limits.HasCoproduct fun i => ∐ g i] =>\n  CategoryTheory.Iso.mk\n    (CategoryTheory.Limits.Sigma.desc fun i =>\n      CategoryTheory.Limits.Sigma.desc fun x =>\n        CategoryTheory.Limits.Sigma.ι (fun p => g p.fst p.snd) { fst := i, snd := x })\n    (CategoryTheory.Limits.Sigma.desc fun x =>\n      match x with\n      | { fst := i, snd := x } =>\n        CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (g i) x)\n          (CategoryTheory.Limits.Sigma.ι (fun i => ∐ g i) i))","name":"CategoryTheory.Limits.sigmaSigmaIso","doc":"An iterated coproduct is a coproduct over a sigma type. ","depth":28}],"count":34}
{"noDocExamples":[{"term":"fun {n a b} m => Eq.rec (motive := fun x h => a ≡ b [ZMOD x] → a ≡ b [ZMOD n]) (Int.ModEq.of_mul_left m) (mul_comm m n)","name":"Int.ModEq.of_mul_right","depth":19}],"kind":"Int.«term_≡_[ZMOD_]»","examples":[{"term":"fun {n a b} =>\n  (fun {n a b} =>\n      Eq.mpr (id (Int.ModEq._eq_1 n a b ▸ Eq.refl (a ≡ b [ZMOD n] ↔ n ∣ b - a)))\n        (Eq.mpr (id (propext eq_comm ▸ Eq.refl (a % n = b % n ↔ n ∣ b - a)))\n          (of_eq_true\n            (Eq.trans\n              (congr (congrArg Iff Mathlib.Data.Int.ModEq._auxLemma.1) (Mathlib.Data.Int.ModEq._auxLemma.2 n (b - a)))\n              (iff_self ((b - a) % n = 0)))))).mp","name":"Int.ModEq.dvd","doc":"**Alias** of the forward direction of `Int.modEq_iff_dvd`.","depth":31},{"term":"fun {n a b} =>\n  (fun {n a b} =>\n      Eq.mpr (id (Int.ModEq._eq_1 n a b ▸ Eq.refl (a ≡ b [ZMOD n] ↔ n ∣ b - a)))\n        (Eq.mpr (id (propext eq_comm ▸ Eq.refl (a % n = b % n ↔ n ∣ b - a)))\n          (of_eq_true\n            (Eq.trans\n              (congr (congrArg Iff Mathlib.Data.Int.ModEq._auxLemma.1) (Mathlib.Data.Int.ModEq._auxLemma.2 n (b - a)))\n              (iff_self ((b - a) % n = 0)))))).mpr","name":"Int.modEq_of_dvd","doc":"**Alias** of the reverse direction of `Int.modEq_iff_dvd`.","depth":31},{"term":"fun {m a b c} hm h =>\n  let_fun hmd := Int.gcd_dvd_left m c;\n  let_fun hcd := Int.gcd_dvd_right m c;\n  (let d := Int.gcd m c;\n    fun hmd hcd =>\n    Eq.mpr (id (propext Int.modEq_iff_dvd ▸ Eq.refl (a ≡ b [ZMOD m / ↑(Int.gcd m c)])))\n      (Int.dvd_of_dvd_mul_right_of_gcd_one\n        (Eq.mpr (id (mul_comm (c / ↑d) (b - a) ▸ Eq.refl (m / ↑d ∣ c / ↑d * (b - a))))\n          (Eq.mpr (id (Eq.symm (Int.mul_ediv_assoc (b - a) hcd) ▸ Eq.refl (m / ↑d ∣ (b - a) * (c / ↑d))))\n            (Eq.mpr (id (sub_mul b a c ▸ Eq.refl (m / ↑d ∣ (b - a) * c / ↑(Int.gcd m c))))\n              (Int.ediv_dvd_ediv hmd (Eq.mp (propext Int.modEq_iff_dvd ▸ Eq.refl (a * c ≡ b * c [ZMOD m])) h)))))\n        (Eq.mpr (id (Int.gcd_div hmd hcd ▸ Eq.refl (Int.gcd (m / ↑(Int.gcd m c)) (c / ↑d) = 1)))\n          (Eq.mpr (id (Int.natAbs_ofNat (Int.gcd m c) ▸ Eq.refl (Int.gcd m c / Int.natAbs ↑(Int.gcd m c) = 1)))\n            (Eq.mpr\n              (id\n                (Nat.div_self (Int.gcd_pos_of_ne_zero_left c (LT.lt.ne' hm)) ▸ Eq.refl (Int.gcd m c / Int.gcd m c = 1)))\n              (Eq.refl 1))))))\n    hmd hcd","name":"Int.ModEq.cancel_right_div_gcd","doc":"To cancel a common factor `c` from a `ModEq` we must divide the modulus `m` by `gcd m c`. ","depth":43},{"term":"fun p [Fact (Nat.Prime p)] x =>\n  Exists.casesOn (ZMod.sq_add_sq p ↑x) fun a h =>\n    Exists.casesOn h fun b hx =>\n      Exists.intro (Int.natAbs (ZMod.valMinAbs a))\n        (Exists.intro (Int.natAbs (ZMod.valMinAbs b))\n          { left := ZMod.natAbs_valMinAbs_le a,\n            right :=\n              { left := ZMod.natAbs_valMinAbs_le b,\n                right :=\n                  Eq.mpr\n                    (id\n                      (congrFun\n                        (congrArg (Int.ModEq ↑p)\n                          (congr\n                            (congrArg HAdd.hAdd (congrFun (congrArg HPow.hPow (Int.coe_natAbs (ZMod.valMinAbs a))) 2))\n                            (congrFun (congrArg HPow.hPow (Int.coe_natAbs (ZMod.valMinAbs b))) 2)))\n                        x))\n                    (Eq.mpr\n                      (id\n                        (sq_abs (ZMod.valMinAbs a) ▸\n                          Eq.refl (|ZMod.valMinAbs a| ^ 2 + |ZMod.valMinAbs b| ^ 2 ≡ x [ZMOD ↑p])))\n                      (Eq.mpr\n                        (id\n                          (sq_abs (ZMod.valMinAbs b) ▸\n                            Eq.refl (ZMod.valMinAbs a ^ 2 + |ZMod.valMinAbs b| ^ 2 ≡ x [ZMOD ↑p])))\n                        (Eq.mpr\n                          (id\n                            (Eq.symm\n                                (propext\n                                  (ZMod.int_cast_eq_int_cast_iff (ZMod.valMinAbs a ^ 2 + ZMod.valMinAbs b ^ 2) x p)) ▸\n                              Eq.refl (ZMod.valMinAbs a ^ 2 + ZMod.valMinAbs b ^ 2 ≡ x [ZMOD ↑p])))\n                          (cast\n                            (Eq.trans\n                              (Eq.trans\n                                (congrFun\n                                  (congrArg Eq\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HAdd.hAdd\n                                          (Mathlib.Algebra.GroupPower.Lemmas._auxLemma.12 (ZMod.valMinAbs a) 2))\n                                        (Mathlib.Algebra.GroupPower.Lemmas._auxLemma.12 (ZMod.valMinAbs b) 2))\n                                      (Mathlib.Data.Int.Cast.Basic._auxLemma.7 (ZMod.valMinAbs a ^ 2)\n                                        (ZMod.valMinAbs b ^ 2))))\n                                  ↑x)\n                                (congrFun\n                                  (congrArg Eq\n                                    (Eq.trans\n                                      (Eq.trans (Int.cast_add (ZMod.valMinAbs a ^ 2) (ZMod.valMinAbs b ^ 2))\n                                        (congr\n                                          (congrArg HAdd.hAdd\n                                            (Eq.trans (Int.cast_pow (ZMod.valMinAbs a) 2)\n                                              (congrFun (congrArg HPow.hPow (ZMod.coe_valMinAbs a)) 2)))\n                                          (Eq.trans (Int.cast_pow (ZMod.valMinAbs b) 2)\n                                            (congrFun (congrArg HPow.hPow (ZMod.coe_valMinAbs b)) 2))))\n                                      (Eq.symm\n                                        (Eq.trans (Int.cast_add (ZMod.valMinAbs a ^ 2) (ZMod.valMinAbs b ^ 2))\n                                          (congr\n                                            (congrArg HAdd.hAdd\n                                              (Eq.trans (Int.cast_pow (ZMod.valMinAbs a) 2)\n                                                (congrFun (congrArg HPow.hPow (ZMod.coe_valMinAbs a)) 2)))\n                                            (Eq.trans (Int.cast_pow (ZMod.valMinAbs b) 2)\n                                              (congrFun (congrArg HPow.hPow (ZMod.coe_valMinAbs b)) 2)))))))\n                                  ↑x))\n                              (Eq.symm\n                                (congrFun\n                                  (congrArg Eq\n                                    (Eq.trans\n                                      (Eq.trans (Int.cast_add (ZMod.valMinAbs a ^ 2) (ZMod.valMinAbs b ^ 2))\n                                        (congr\n                                          (congrArg HAdd.hAdd\n                                            (Eq.trans (Int.cast_pow (ZMod.valMinAbs a) 2)\n                                              (congrFun (congrArg HPow.hPow (ZMod.coe_valMinAbs a)) 2)))\n                                          (Eq.trans (Int.cast_pow (ZMod.valMinAbs b) 2)\n                                            (congrFun (congrArg HPow.hPow (ZMod.coe_valMinAbs b)) 2))))\n                                      (Eq.symm\n                                        (Eq.trans (Int.cast_add (ZMod.valMinAbs a ^ 2) (ZMod.valMinAbs b ^ 2))\n                                          (congr\n                                            (congrArg HAdd.hAdd\n                                              (Eq.trans (Int.cast_pow (ZMod.valMinAbs a) 2)\n                                                (congrFun (congrArg HPow.hPow (ZMod.coe_valMinAbs a)) 2)))\n                                            (Eq.trans (Int.cast_pow (ZMod.valMinAbs b) 2)\n                                              (congrFun (congrArg HPow.hPow (ZMod.coe_valMinAbs b)) 2)))))))\n                                  ↑x)))\n                            (Eq.mp (Eq.symm (ZMod.coe_valMinAbs b) ▸ Eq.refl (↑(ZMod.valMinAbs a) ^ 2 + b ^ 2 = ↑x))\n                              (Eq.mp (Eq.symm (ZMod.coe_valMinAbs a) ▸ Eq.refl (a ^ 2 + b ^ 2 = ↑x)) hx)))))) } })","name":"Nat.sq_add_sq_zmodEq","doc":"If `p` is a prime natural number and `x` is an integer number, then there exist natural numbers\n`a ≤ p / 2` and `b ≤ p / 2` such that `a ^ 2 + b ^ 2 ≡ x [ZMOD p]`. This is a version of\n`ZMod.sq_add_sq` with estimates on `a` and `b`. ","depth":47}],"count":33}
{"noDocExamples":[],"kind":"FirstOrder.Language.«term_⊨__1»","examples":[{"term":"fun {L} T M [FirstOrder.Language.Structure L M] [M ⊨ T] [Nonempty M] => FirstOrder.Language.Theory.ModelType.mk M","name":"FirstOrder.Language.Theory.ModelType.of","doc":"The object in the category of R-algebras associated to a type equipped with the appropriate\ntypeclasses. ","depth":12},{"term":"fun {L} T M [FirstOrder.Language.Structure L M] [Nonempty M] [M ⊨ T] α =>\n  Set.range (FirstOrder.Language.Theory.typeOf T)","name":"FirstOrder.Language.Theory.realizedTypes","doc":"A complete type `p` is realized in a particular structure when there is some\ntuple `v` whose type is `p`. ","depth":15},{"term":"fun V [FirstOrder.Language.Structure FirstOrder.Language.graph V] [V ⊨ FirstOrder.Language.Theory.simpleGraph] =>\n  SimpleGraph.mk fun x y => FirstOrder.Language.Structure.RelMap FirstOrder.Language.adj ![x, y]","name":"FirstOrder.Language.simpleGraphOfStructure","doc":"Any model of the theory of simple graphs represents a simple graph. ","depth":16},{"term":"fun L M [FirstOrder.Language.Structure L M] N [FirstOrder.Language.Structure L N]\n    [FirstOrder.Language.Structure (FirstOrder.Language.withConstants L M) N]\n    [FirstOrder.Language.LHom.IsExpansionOn (FirstOrder.Language.lhomWithConstants L M) N]\n    [N ⊨ FirstOrder.Language.elementaryDiagram L M] =>\n  FirstOrder.Language.ElementaryEmbedding.mk (FirstOrder.Language.constantMap ∘ Sum.inr)","name":"FirstOrder.Language.ElementaryEmbedding.ofModelsElementaryDiagram","doc":"The canonical elementary embedding of an `L`-structure into any model of its elementary diagram\n","depth":17},{"term":"fun {L} T {α} {M} [FirstOrder.Language.Structure L M] [Nonempty M] [M ⊨ T] v =>\n  { toTheory := FirstOrder.Language.completeTheory (FirstOrder.Language.withConstants L α) M,\n    subset' :=\n      (_ :\n        FirstOrder.Language.LHom.onTheory (FirstOrder.Language.lhomWithConstants L α) T ⊆\n          FirstOrder.Language.completeTheory (FirstOrder.Language.withConstants L α) M),\n    isMaximal' :=\n      (_ :\n        FirstOrder.Language.Theory.IsMaximal\n          (FirstOrder.Language.completeTheory (FirstOrder.Language.withConstants L α) M)) }","name":"FirstOrder.Language.Theory.typeOf","doc":"The set of all formulas true at a tuple in a structure forms a complete type. ","depth":17}],"count":33}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term∏_»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] P {X} R => ∏ fun f => P.obj (Opposite.op f.fst)","name":"CategoryTheory.Equalizer.FirstObj","doc":"The middle object of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram\nof <https://stacks.math.columbia.edu/tag/00VM>.\n","depth":21},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] {A} [CategoryTheory.Category.{v₂, u₂} A] {U} R P\n    [CategoryTheory.Limits.HasProducts A] =>\n  ∏ fun f => P.obj (Opposite.op f.fst)","name":"CategoryTheory.Presheaf.firstObj","doc":"The middle object of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram\nof <https://stacks.math.columbia.edu/tag/00VM>.\n","depth":24},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasProducts C] {ι} {B} hB =>\n  Exists.intro (∏ B) fun X =>\n    Nonempty.intro\n      (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π B (Exists.choose (hB X)))\n        (Nonempty.some (Exists.choose_spec (hB X))))","name":"CategoryTheory.has_weakly_initial_of_weakly_initial_set_and_hasProducts","doc":"If `C` has (small) products and a small weakly initial set of objects, then it has a weakly initial\nobject.\n","depth":25},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasProducts C] {X} F {ι} U =>\n  ∏ fun i => F.obj (Opposite.op (U i))","name":"TopCat.Presheaf.SheafConditionEqualizerProducts.piOpens","doc":"The product of the sections of a presheaf over a family of open sets. ","depth":27},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasProducts C] {X} F {ι} U =>\n  ∏ fun p => F.obj (Opposite.op (U p.fst ⊓ U p.snd))","name":"TopCat.Presheaf.SheafConditionEqualizerProducts.piInters","doc":"The product of the sections of a presheaf over the pairwise intersections of\na family of open sets.\n","depth":27}],"count":32}
{"noDocExamples":[],"kind":"Polynomial.«term_/ₘ_»","examples":[{"term":"fun {R} [Field R] p q =>\n  ↑Polynomial.C (Polynomial.leadingCoeff q)⁻¹ * (p /ₘ (q * ↑Polynomial.C (Polynomial.leadingCoeff q)⁻¹))","name":"Polynomial.div","doc":"Division of polynomials. See `Polynomial.divByMonic` for more details.","depth":26},{"term":"fun {K} [Field K] f =>\n  Polynomial.map (AdjoinRoot.of (Polynomial.factor f)) f /ₘ\n    (Polynomial.X - ↑Polynomial.C (AdjoinRoot.root (Polynomial.factor f)))","name":"Polynomial.removeFactor","doc":"Divide a polynomial f by `X - C r` where `r` is a root of `f` in a bigger field extension. ","depth":29},{"term":"fun {R} [CommRing R] {p q} hmonic hdegree =>\n  Mathlib.Tactic.Nontriviality.subsingleton_or_nontrivial_elim\n    (fun [anonymous] =>\n      of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg Eq\n              (Polynomial.Monic.leadingCoeff\n                (of_eq_true (Mathlib.Data.Polynomial.Degree.Definitions._auxLemma.1 (p /ₘ q)))))\n            (Polynomial.Monic.leadingCoeff (of_eq_true (Mathlib.Data.Polynomial.Degree.Definitions._auxLemma.1 p))))\n          (eq_self 1)))\n    fun [anonymous] =>\n    let_fun h :=\n      Eq.mpr\n        (id\n          (Eq.trans\n            (Eq.trans\n              (congrFun\n                (congrArg Ne\n                  (Eq.trans\n                    (congrFun (congrArg HMul.hMul (Polynomial.Monic.leadingCoeff hmonic))\n                      (Polynomial.leadingCoeff (p /ₘ q)))\n                    (one_mul (Polynomial.leadingCoeff (p /ₘ q)))))\n                0)\n              (congrArg Not\n                (Eq.trans Mathlib.Data.Polynomial.Degree.Definitions._auxLemma.10\n                  ((fun x_0 => propext ((fun x_0 => Polynomial.divByMonic_eq_zero_iff hmonic) x_0)) p))))\n            Mathlib.Init.Order.Defs._auxLemma.1))\n        hdegree;\n    Eq.mpr\n      (id\n        (Eq.symm (Polynomial.modByMonic_add_div p hmonic) ▸\n          Eq.refl (Polynomial.leadingCoeff (p /ₘ q) = Polynomial.leadingCoeff p)))\n      (Eq.mpr\n        (id\n          (Polynomial.leadingCoeff_add_of_degree_lt\n              (Eq.mpr\n                (id\n                  (Polynomial.degree_mul' h ▸ Eq.refl (Polynomial.degree (p %ₘ q) < Polynomial.degree (q * (p /ₘ q)))))\n                (Eq.mpr\n                  (id\n                    (Polynomial.degree_add_divByMonic hmonic hdegree ▸\n                      Eq.refl (Polynomial.degree (p %ₘ q) < Polynomial.degree q + Polynomial.degree (p /ₘ q))))\n                  (LT.lt.trans_le (Polynomial.degree_modByMonic_lt p hmonic) hdegree))) ▸\n            Eq.refl (Polynomial.leadingCoeff (p /ₘ q) = Polynomial.leadingCoeff (p %ₘ q + q * (p /ₘ q)))))\n        (Eq.mpr\n          (id\n            (Polynomial.leadingCoeff_monic_mul hmonic ▸\n              Eq.refl (Polynomial.leadingCoeff (p /ₘ q) = Polynomial.leadingCoeff (q * (p /ₘ q)))))\n          (Eq.refl (Polynomial.leadingCoeff (p /ₘ q)))))","name":"Polynomial.leadingCoeff_divByMonic_of_monic","doc":"Division by a monic polynomial doesn't change the leading coefficient. ","depth":39},{"term":"fun {R} [CommRing R] {n} hpos =>\n  Mathlib.Tactic.Nontriviality.subsingleton_or_nontrivial_elim\n    (fun [anonymous] =>\n      of_eq_true\n        (Mathlib.Logic.Unique._auxLemma.1 (Polynomial.cyclotomic n R)\n          ((Polynomial.X ^ n - 1) /ₘ Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R)))\n    fun [anonymous] =>\n    Eq.mpr\n      (id\n        (Eq.symm (Polynomial.prod_cyclotomic_eq_X_pow_sub_one hpos R) ▸\n          Eq.refl\n            (Polynomial.cyclotomic n R =\n              (Polynomial.X ^ n - 1) /ₘ Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R)))\n      (Eq.mpr\n        (id\n          (Eq.symm (Nat.cons_self_properDivisors (LT.lt.ne' hpos)) ▸\n            Eq.refl\n              (Polynomial.cyclotomic n R =\n                (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic i R) /ₘ\n                  Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R)))\n        (Eq.mpr\n          (id\n            (Finset.prod_cons Nat.properDivisors.not_self_mem ▸\n              Eq.refl\n                (Polynomial.cyclotomic n R =\n                  (Finset.prod (Finset.cons n (Nat.properDivisors n) Nat.properDivisors.not_self_mem) fun i =>\n                      Polynomial.cyclotomic i R) /ₘ\n                    Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R)))\n          (let_fun prod_monic :=\n            Polynomial.monic_prod_of_monic (Nat.properDivisors n) (fun i => Polynomial.cyclotomic i R) fun i a =>\n              Polynomial.cyclotomic.monic i R;\n          Eq.mpr\n            (id\n              ((Polynomial.div_modByMonic_unique (Polynomial.cyclotomic n R) 0 prod_monic\n                    (Eq.mpr\n                      (id\n                        (congrFun\n                          (congrArg And\n                            (congrFun\n                              (congrArg Eq\n                                (zero_add\n                                  ((Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R) *\n                                    Polynomial.cyclotomic n R)))\n                              (Polynomial.cyclotomic n R *\n                                Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R)))\n                          (⊥ <\n                            Polynomial.degree (Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R))))\n                      {\n                        left :=\n                          Eq.mpr\n                            (id\n                              (mul_comm (Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R)\n                                  (Polynomial.cyclotomic n R) ▸\n                                Eq.refl\n                                  ((Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R) *\n                                      Polynomial.cyclotomic n R =\n                                    Polynomial.cyclotomic n R *\n                                      Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R)))\n                            (Eq.refl\n                              (Polynomial.cyclotomic n R *\n                                Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R)),\n                        right :=\n                          Eq.mpr\n                            (id\n                              (propext bot_lt_iff_ne_bot ▸\n                                Eq.refl\n                                  (⊥ <\n                                    Polynomial.degree\n                                      (Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R))))\n                            fun h => Polynomial.Monic.ne_zero prod_monic (Iff.mp Polynomial.degree_eq_bot h) })).left ▸\n                Eq.refl\n                  (Polynomial.cyclotomic n R =\n                    (Polynomial.cyclotomic n R *\n                        Finset.prod (Nat.properDivisors n) fun x => Polynomial.cyclotomic x R) /ₘ\n                      Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R)))\n            (Eq.refl (Polynomial.cyclotomic n R)))))","name":"Polynomial.cyclotomic_eq_X_pow_sub_one_div","doc":"We have\n`cyclotomic n R = (X ^ k - 1) /ₘ (∏ i in Nat.properDivisors k, cyclotomic i K)`. ","depth":45},{"term":"fun {K} [CommRing K] [IsDomain K] {ζ} {n} hpos h =>\n  Eq.mpr\n    (id\n      (Eq.symm (Polynomial.prod_cyclotomic'_eq_X_pow_sub_one hpos h) ▸\n        Eq.refl\n          (Polynomial.cyclotomic' n K =\n            (Polynomial.X ^ n - 1) /ₘ Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K)))\n    (Eq.mpr\n      (id\n        (Eq.symm (Nat.cons_self_properDivisors (LT.lt.ne' hpos)) ▸\n          Eq.refl\n            (Polynomial.cyclotomic' n K =\n              (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic' i K) /ₘ\n                Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K)))\n      (Eq.mpr\n        (id\n          (Finset.prod_cons Nat.properDivisors.not_self_mem ▸\n            Eq.refl\n              (Polynomial.cyclotomic' n K =\n                (Finset.prod (Finset.cons n (Nat.properDivisors n) Nat.properDivisors.not_self_mem) fun i =>\n                    Polynomial.cyclotomic' i K) /ₘ\n                  Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K)))\n        (let_fun prod_monic :=\n          Polynomial.monic_prod_of_monic (Nat.properDivisors n) (fun i => Polynomial.cyclotomic' i K) fun i a =>\n            Polynomial.cyclotomic'.monic i K;\n        Eq.mpr\n          (id\n            ((Polynomial.div_modByMonic_unique (Polynomial.cyclotomic' n K) 0 prod_monic\n                  (Eq.mpr\n                    (id\n                      (congrFun\n                        (congrArg And\n                          (congrFun\n                            (congrArg Eq\n                              (zero_add\n                                ((Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K) *\n                                  Polynomial.cyclotomic' n K)))\n                            (Polynomial.cyclotomic' n K *\n                              Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K)))\n                        (⊥ <\n                          Polynomial.degree (Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K))))\n                    {\n                      left :=\n                        Eq.mpr\n                          (id\n                            (mul_comm (Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K)\n                                (Polynomial.cyclotomic' n K) ▸\n                              Eq.refl\n                                ((Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K) *\n                                    Polynomial.cyclotomic' n K =\n                                  Polynomial.cyclotomic' n K *\n                                    Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K)))\n                          (Eq.refl\n                            (Polynomial.cyclotomic' n K *\n                              Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K)),\n                      right :=\n                        Eq.mpr\n                          (id\n                            (propext bot_lt_iff_ne_bot ▸\n                              Eq.refl\n                                (⊥ <\n                                  Polynomial.degree\n                                    (Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K))))\n                          fun h => Polynomial.Monic.ne_zero prod_monic (Iff.mp Polynomial.degree_eq_bot h) })).left ▸\n              Eq.refl\n                (Polynomial.cyclotomic' n K =\n                  (Polynomial.cyclotomic' n K *\n                      Finset.prod (Nat.properDivisors n) fun x => Polynomial.cyclotomic' x K) /ₘ\n                    Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K)))\n          (Eq.refl (Polynomial.cyclotomic' n K)))))","name":"Polynomial.cyclotomic'_eq_X_pow_sub_one_div","doc":"If there is a primitive `n`-th root of unity in `K`, then\n`cyclotomic' n K = (X ^ k - 1) /ₘ (∏ i in Nat.properDivisors k, cyclotomic' i K)`. ","depth":46}],"count":32}
{"noDocExamples":[],"kind":"«term_→o_»","examples":[{"term":"fun α [Preorder α] => ℕ →o α","name":"OmegaCompletePartialOrder.Chain","doc":"A chain is a monotone sequence.\n\nSee the definition on page 114 of [gunter1992]. ","depth":7},{"term":"fun {α} [Preorder α] [Subsingleton α] =>\n  { toInhabited := { default := OrderHom.id }, uniq := (_ : ∀ (x : α →o α), x = default) }","name":"OrderHom.unique","doc":"There is a unique monotone map from a subsingleton to itself. ","depth":11},{"term":"fun a b => Fin (SimplexCategory.len a + 1) →o Fin (SimplexCategory.len b + 1)","name":"SimplexCategory.Hom","doc":"Morphisms in the `SimplexCategory`. ","depth":13},{"term":"fun {α} {β} [Preorder α] [Preorder β] =>\n  { toFun := fun f => ↑f, monotone' := (_ : ∀ (x x_1 : α →o β), x ≤ x_1 → x ≤ x_1) }","name":"OrderHom.coeFnHom","doc":"The \"forgetful functor\" from `α →o β` to `α → β` that takes the underlying function,\nis monotone. ","depth":19},{"term":"fun α β [Preorder α] [Preorder β] =>\n  { toEquiv := OrderHom.dual.trans OrderDual.toDual,\n    map_rel_iff' :=\n      (_ :\n        ∀ {a b : α →o β},\n          ↑(OrderHom.dual.trans OrderDual.toDual) a ≤ ↑(OrderHom.dual.trans OrderDual.toDual) b ↔\n            ↑(OrderHom.dual.trans OrderDual.toDual) a ≤ ↑(OrderHom.dual.trans OrderDual.toDual) b) }","name":"OrderHom.dualIso","doc":"`OrderHom.dual` as an order isomorphism. ","depth":20}],"count":32}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term⨁_»","examples":[{"term":"fun {J} [Fintype J] {K} [Fintype K] {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasZeroMorphisms C]\n    [CategoryTheory.Limits.HasFiniteBiproducts C] {f} {g} =>\n  { toFun := CategoryTheory.Limits.biproduct.components, invFun := CategoryTheory.Limits.biproduct.matrix,\n    left_inv :=\n      (_ :\n        ∀ (m : ⨁ f ⟶ ⨁ g),\n          (CategoryTheory.Limits.biproduct.matrix fun j k => CategoryTheory.Limits.biproduct.components m j k) = m),\n    right_inv :=\n      (_ :\n        ∀ (m : (j : J) → (k : K) → f j ⟶ g k),\n          CategoryTheory.Limits.biproduct.components (CategoryTheory.Limits.biproduct.matrix m) = m) }","name":"CategoryTheory.Limits.biproduct.matrixEquiv","doc":"Morphisms between direct sums are matrices. ","depth":26},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.Preadditive C] {D} [CategoryTheory.Category.{v₁, u₁} D]\n    [CategoryTheory.Preadditive D] [CategoryTheory.Limits.HasFiniteBiproducts D] F\n    [CategoryTheory.Functor.Additive F] =>\n  CategoryTheory.Functor.mk\n    { obj := fun X => ⨁ fun i => F.obj (CategoryTheory.Mat_.X X i),\n      map := fun {X Y} f => CategoryTheory.Limits.biproduct.matrix fun i j => F.map (f i j) }","name":"CategoryTheory.Mat_.lift","doc":"Any additive functor `C ⥤ D` to a category `D` with finite biproducts extends to\na functor `Mat_ C ⥤ D`. ","depth":29},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasZeroMorphisms C] {K} [Fintype K]\n    [CategoryTheory.Limits.HasFiniteBiproducts C] f p =>\n  {\n    cone :=\n      CategoryTheory.Limits.KernelFork.ofι (CategoryTheory.Limits.biproduct.fromSubtype f pᶜ)\n        (_ :\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f pᶜ)\n              (CategoryTheory.Limits.biproduct.toSubtype f p) =\n            0),\n    isLimit :=\n      CategoryTheory.Limits.KernelFork.IsLimit.ofι (CategoryTheory.Limits.biproduct.fromSubtype f pᶜ)\n        (_ :\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f pᶜ)\n              (CategoryTheory.Limits.biproduct.toSubtype f p) =\n            0)\n        (fun {W} g x => CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.biproduct.toSubtype f pᶜ))\n        (_ :\n          ∀ {W' : C} (g' : W' ⟶ ⨁ f)\n            (w : CategoryTheory.CategoryStruct.comp g' (CategoryTheory.Limits.biproduct.toSubtype f p) = 0),\n            CategoryTheory.CategoryStruct.comp\n                ((fun {W} g x => CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.biproduct.toSubtype f pᶜ))\n                  g' w)\n                (CategoryTheory.Limits.biproduct.fromSubtype f pᶜ) =\n              g')\n        (_ :\n          ∀ {W' : C} (g' : W' ⟶ ⨁ f)\n            (eq' : CategoryTheory.CategoryStruct.comp g' (CategoryTheory.Limits.biproduct.toSubtype f p) = 0)\n            (m : W' ⟶ ⨁ Subtype.restrict pᶜ f),\n            CategoryTheory.CategoryStruct.comp m (CategoryTheory.Limits.biproduct.fromSubtype f pᶜ) = g' →\n              m =\n                (fun {W} g x => CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.biproduct.toSubtype f pᶜ))\n                  g' eq') }","name":"CategoryTheory.Limits.kernelForkBiproductToSubtype","doc":"The limit cone exhibiting `⨁ Subtype.restrict pᶜ f` as the kernel of\n`biproduct.toSubtype f p` ","depth":30},{"term":"fun {C} [CategoryTheory.Category.{v, u_1} C] [CategoryTheory.Preadditive C]\n    [CategoryTheory.Limits.HasFiniteBiproducts C] {J} [Finite J] F =>\n  CategoryTheory.Limits.Bicone.mk\n    (CategoryTheory.Idempotents.Karoubi.mk (⨁ fun j => (F j).X) (CategoryTheory.Limits.biproduct.map fun j => (F j).p))\n    (fun j =>\n      CategoryTheory.Idempotents.Karoubi.Hom.mk\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map fun j => (F j).p)\n          (CategoryTheory.Limits.Bicone.π (CategoryTheory.Limits.biproduct.bicone fun j => (F j).X) j)))\n    fun j =>\n    CategoryTheory.Idempotents.Karoubi.Hom.mk\n      (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι (fun j => (F j).X) j)\n        (CategoryTheory.Limits.biproduct.map fun j => (F j).p))","name":"CategoryTheory.Idempotents.Karoubi.Biproducts.bicone","doc":"The `Bicone` used in order to obtain the existence of\nthe biproduct of a functor `J ⥤ Karoubi C` when the category `C` is additive. ","depth":31},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasZeroMorphisms C] {K} [Fintype K]\n    [CategoryTheory.Limits.HasFiniteBiproducts C] f p =>\n  {\n    cocone :=\n      CategoryTheory.Limits.CokernelCofork.ofπ (CategoryTheory.Limits.biproduct.toSubtype f pᶜ)\n        (_ :\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p)\n              (CategoryTheory.Limits.biproduct.toSubtype f pᶜ) =\n            0),\n    isColimit :=\n      CategoryTheory.Limits.CokernelCofork.IsColimit.ofπ (CategoryTheory.Limits.biproduct.toSubtype f pᶜ)\n        (_ :\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p)\n              (CategoryTheory.Limits.biproduct.toSubtype f pᶜ) =\n            0)\n        (fun {W} g x => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f pᶜ) g)\n        (_ :\n          ∀ {W : C} (g' : ⨁ f ⟶ W)\n            (w : CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) g' = 0),\n            CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f pᶜ)\n                ((fun {W} g x =>\n                    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f pᶜ) g)\n                  g' w) =\n              g')\n        (_ :\n          ∀ {Z' : C} (g' : ⨁ f ⟶ Z')\n            (eq' : CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) g' = 0)\n            (m : ⨁ Subtype.restrict pᶜ f ⟶ Z'),\n            CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f pᶜ) m = g' →\n              m =\n                (fun {W} g x => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f pᶜ) g)\n                  g' eq') }","name":"CategoryTheory.Limits.cokernelCoforkBiproductFromSubtype","doc":"The colimit cocone exhibiting `⨁ Subtype.restrict pᶜ f` as the cokernel of\n`biproduct.fromSubtype f p` ","depth":32}],"count":31}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term_⊞_»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasZeroMorphisms C]\n    [CategoryTheory.Limits.HasBinaryBiproducts C] X =>\n  ¬CategoryTheory.Limits.IsZero X ∧\n    ∀ (Y Z : C), (X ≅ Y ⊞ Z) → CategoryTheory.Limits.IsZero Y ∨ CategoryTheory.Limits.IsZero Z","name":"CategoryTheory.Indecomposable","doc":"An object is indecomposable if it cannot be written as the biproduct of two nonzero objects. ","depth":17},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasZeroMorphisms C]\n    [CategoryTheory.Limits.HasBinaryBiproducts C] P Q =>\n  of_eq_true\n    (Eq.trans\n      (congrFun (congrArg Eq (CategoryTheory.Limits.biprod.symmetry' P Q)) (CategoryTheory.CategoryStruct.id (P ⊞ Q)))\n      (eq_self (CategoryTheory.CategoryStruct.id (P ⊞ Q))))","name":"CategoryTheory.Limits.biprod.symmetry","doc":"The braiding isomorphism is symmetric. ","depth":30},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasBinaryBiproducts C]\n    {X₁ X₂ Y₁ Y₂} f\n    [CategoryTheory.IsIso\n        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl\n          (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst))] =>\n  let this :=\n    CategoryTheory.Biprod.gaussian'\n      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl\n        (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst))\n      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl\n        (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd))\n      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr\n        (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst))\n      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr\n        (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd));\n  Eq.mp\n    (_ :\n      ((L : X₁ ⊞ X₂ ≅ X₁ ⊞ X₂) ×'\n          (R : Y₁ ⊞ Y₂ ≅ Y₁ ⊞ Y₂) ×'\n            (g₂₂ : X₂ ⟶ Y₂) ×'\n              CategoryTheory.CategoryStruct.comp L.hom\n                  (CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.Biprod.ofComponents\n                      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl\n                        (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst))\n                      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl\n                        (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd))\n                      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr\n                        (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst))\n                      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr\n                        (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd)))\n                    R.hom) =\n                CategoryTheory.Limits.biprod.map\n                  (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl\n                    (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst))\n                  g₂₂) =\n        ((L : X₁ ⊞ X₂ ≅ X₁ ⊞ X₂) ×'\n          (R : Y₁ ⊞ Y₂ ≅ Y₁ ⊞ Y₂) ×'\n            (g₂₂ : X₂ ⟶ Y₂) ×'\n              CategoryTheory.CategoryStruct.comp L.hom (CategoryTheory.CategoryStruct.comp f R.hom) =\n                CategoryTheory.Limits.biprod.map\n                  (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl\n                    (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst))\n                  g₂₂))\n    this","name":"CategoryTheory.Biprod.gaussian","doc":"If `f` is a morphism `X₁ ⊞ X₂ ⟶ Y₁ ⊞ Y₂` whose `X₁ ⟶ Y₁` entry is an isomorphism,\nthen we can construct isomorphisms `L : X₁ ⊞ X₂ ≅ X₁ ⊞ X₂` and `R : Y₁ ⊞ Y₂ ≅ Y₁ ⊞ Y₂`\nso that `L.hom ≫ g ≫ R.hom` is diagonal (with `X₁ ⟶ Y₁` component still `f`),\nvia Gaussian elimination.\n","depth":43},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Abelian C] {P} Q f =>\n  {\n    mp := fun x =>\n      match x with\n      | Exists.intro R (Exists.intro p (Exists.intro q (Exists.intro ep (Exists.intro w comm)))) =>\n        CategoryTheory.Limits.zero_of_epi_comp p\n          (of_eq_true\n            (Eq.trans (congrFun (congrArg Eq (Eq.trans comm CategoryTheory.Limits.comp_zero)) 0) (eq_self 0))),\n    mpr := fun hf =>\n      Exists.intro (f.left ⊞ Q)\n        (Exists.intro CategoryTheory.Limits.biprod.fst\n          (Exists.intro CategoryTheory.Limits.biprod.snd\n            (Exists.intro inferInstance\n              (Exists.intro inferInstance\n                (Eq.mpr\n                  (id\n                    (hf ▸\n                      Eq.refl\n                        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst f.hom =\n                          CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd\n                            (CategoryTheory.Over.mk 0).hom)))\n                  (Eq.mpr\n                    (id\n                      (CategoryTheory.Over.coe_hom 0 ▸\n                        Eq.refl\n                          (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst 0 =\n                            CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd\n                              (CategoryTheory.Over.mk 0).hom)))\n                    (Eq.mpr\n                      (id\n                        (CategoryTheory.Limits.HasZeroMorphisms.comp_zero CategoryTheory.Limits.biprod.fst\n                            ((CategoryTheory.Functor.fromPUnit P).obj f.right) ▸\n                          Eq.refl\n                            (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst 0 =\n                              CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd 0)))\n                      (Eq.mpr\n                        (id\n                          (CategoryTheory.Limits.HasZeroMorphisms.comp_zero CategoryTheory.Limits.biprod.snd\n                              ((CategoryTheory.Functor.fromPUnit P).obj (CategoryTheory.Over.mk 0).right) ▸\n                            Eq.refl (0 = CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd 0)))\n                        (Eq.refl 0))))))))) }","name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero_aux","doc":"The arrows pseudo-equal to a zero morphism are precisely the zero morphisms. ","depth":45},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Preadditive C] {X Y}\n    [CategoryTheory.Limits.HasBinaryBiproduct X Y] =>\n  CategoryTheory.Limits.biprod.hom_ext'\n    (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.inl +\n      CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.inr)\n    (CategoryTheory.CategoryStruct.id (X ⊞ Y))\n    (CategoryTheory.Limits.biprod.hom_ext\n      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl\n        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.inl +\n          CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.inr))\n      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.id (X ⊞ Y)))\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg Eq\n              (Eq.trans\n                (congrFun\n                  (congrArg CategoryTheory.CategoryStruct.comp\n                    (Eq.trans\n                      (Eq.trans\n                        (CategoryTheory.Preadditive.comp_add X (X ⊞ Y) (X ⊞ Y) CategoryTheory.Limits.biprod.inl\n                          (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst\n                            CategoryTheory.Limits.biprod.inl)\n                          (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd\n                            CategoryTheory.Limits.biprod.inr))\n                        (congr\n                          (congrArg HAdd.hAdd\n                            (CategoryTheory.Limits.BinaryBicone.inl_fst_assoc\n                              (CategoryTheory.Limits.BinaryBiproduct.bicone X Y) CategoryTheory.Limits.biprod.inl))\n                          (Eq.trans\n                            (CategoryTheory.Limits.BinaryBicone.inl_snd_assoc\n                              (CategoryTheory.Limits.BinaryBiproduct.bicone X Y) CategoryTheory.Limits.biprod.inr)\n                            CategoryTheory.Limits.zero_comp)))\n                      (add_zero CategoryTheory.Limits.biprod.inl)))\n                  CategoryTheory.Limits.biprod.fst)\n                (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).inl_fst))\n            (Eq.trans\n              (congrFun\n                (congrArg CategoryTheory.CategoryStruct.comp\n                  (CategoryTheory.Category.comp_id CategoryTheory.Limits.biprod.inl))\n                CategoryTheory.Limits.biprod.fst)\n              (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).inl_fst))\n          (eq_self (CategoryTheory.CategoryStruct.id X))))\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg Eq\n              (Eq.trans\n                (congrFun\n                  (congrArg CategoryTheory.CategoryStruct.comp\n                    (Eq.trans\n                      (Eq.trans\n                        (CategoryTheory.Preadditive.comp_add X (X ⊞ Y) (X ⊞ Y) CategoryTheory.Limits.biprod.inl\n                          (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst\n                            CategoryTheory.Limits.biprod.inl)\n                          (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd\n                            CategoryTheory.Limits.biprod.inr))\n                        (congr\n                          (congrArg HAdd.hAdd\n                            (CategoryTheory.Limits.BinaryBicone.inl_fst_assoc\n                              (CategoryTheory.Limits.BinaryBiproduct.bicone X Y) CategoryTheory.Limits.biprod.inl))\n                          (Eq.trans\n                            (CategoryTheory.Limits.BinaryBicone.inl_snd_assoc\n                              (CategoryTheory.Limits.BinaryBiproduct.bicone X Y) CategoryTheory.Limits.biprod.inr)\n                            CategoryTheory.Limits.zero_comp)))\n                      (add_zero CategoryTheory.Limits.biprod.inl)))\n                  CategoryTheory.Limits.biprod.snd)\n                (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).inl_snd))\n            (Eq.trans\n              (congrFun\n                (congrArg CategoryTheory.CategoryStruct.comp\n                  (CategoryTheory.Category.comp_id CategoryTheory.Limits.biprod.inl))\n                CategoryTheory.Limits.biprod.snd)\n              (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).inl_snd))\n          (eq_self 0))))\n    (CategoryTheory.Limits.biprod.hom_ext\n      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr\n        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.inl +\n          CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.inr))\n      (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.id (X ⊞ Y)))\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg Eq\n              (Eq.trans\n                (congrFun\n                  (congrArg CategoryTheory.CategoryStruct.comp\n                    (Eq.trans\n                      (Eq.trans\n                        (CategoryTheory.Preadditive.comp_add Y (X ⊞ Y) (X ⊞ Y) CategoryTheory.Limits.biprod.inr\n                          (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst\n                            CategoryTheory.Limits.biprod.inl)\n                          (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd\n                            CategoryTheory.Limits.biprod.inr))\n                        (congr\n                          (congrArg HAdd.hAdd\n                            (Eq.trans\n                              (CategoryTheory.Limits.BinaryBicone.inr_fst_assoc\n                                (CategoryTheory.Limits.BinaryBiproduct.bicone X Y) CategoryTheory.Limits.biprod.inl)\n                              CategoryTheory.Limits.zero_comp))\n                          (CategoryTheory.Limits.BinaryBicone.inr_snd_assoc\n                            (CategoryTheory.Limits.BinaryBiproduct.bicone X Y) CategoryTheory.Limits.biprod.inr)))\n                      (zero_add CategoryTheory.Limits.biprod.inr)))\n                  CategoryTheory.Limits.biprod.fst)\n                (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).inr_fst))\n            (Eq.trans\n              (congrFun\n                (congrArg CategoryTheory.CategoryStruct.comp\n                  (CategoryTheory.Category.comp_id CategoryTheory.Limits.biprod.inr))\n                CategoryTheory.Limits.biprod.fst)\n              (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).inr_fst))\n          (eq_self 0)))\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg Eq\n              (Eq.trans\n                (congrFun\n                  (congrArg CategoryTheory.CategoryStruct.comp\n                    (Eq.trans\n                      (Eq.trans\n                        (CategoryTheory.Preadditive.comp_add Y (X ⊞ Y) (X ⊞ Y) CategoryTheory.Limits.biprod.inr\n                          (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst\n                            CategoryTheory.Limits.biprod.inl)\n                          (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd\n                            CategoryTheory.Limits.biprod.inr))\n                        (congr\n                          (congrArg HAdd.hAdd\n                            (Eq.trans\n                              (CategoryTheory.Limits.BinaryBicone.inr_fst_assoc\n                                (CategoryTheory.Limits.BinaryBiproduct.bicone X Y) CategoryTheory.Limits.biprod.inl)\n                              CategoryTheory.Limits.zero_comp))\n                          (CategoryTheory.Limits.BinaryBicone.inr_snd_assoc\n                            (CategoryTheory.Limits.BinaryBiproduct.bicone X Y) CategoryTheory.Limits.biprod.inr)))\n                      (zero_add CategoryTheory.Limits.biprod.inr)))\n                  CategoryTheory.Limits.biprod.snd)\n                (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).inr_snd))\n            (Eq.trans\n              (congrFun\n                (congrArg CategoryTheory.CategoryStruct.comp\n                  (CategoryTheory.Category.comp_id CategoryTheory.Limits.biprod.inr))\n                CategoryTheory.Limits.biprod.snd)\n              (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).inr_snd))\n          (eq_self (CategoryTheory.CategoryStruct.id Y)))))","name":"CategoryTheory.Limits.biprod.total","doc":"In any preadditive category, any binary biproduct satsifies\n`biprod.fst ≫ biprod.inl + biprod.snd ≫ biprod.inr = 𝟙 (X ⊞ Y)`.\n","depth":48}],"count":31}
{"noDocExamples":[],"kind":"Set.termΙ","examples":[{"term":"fun {E} [NormedAddCommGroup E] {f} {a b} {μ} =>\n  Eq.mpr (id (Set.uIoc_eq_union ▸ Eq.refl (IntervalIntegrable f μ a b ↔ MeasureTheory.IntegrableOn f (Ι a b))))\n    (Eq.mpr\n      (id\n        (propext MeasureTheory.integrableOn_union ▸\n          Eq.refl (IntervalIntegrable f μ a b ↔ MeasureTheory.IntegrableOn f (Set.Ioc a b ∪ Set.Ioc b a))))\n      (Eq.mpr\n        (id\n          (IntervalIntegrable._eq_1 f μ a b ▸\n            Eq.refl\n              (IntervalIntegrable f μ a b ↔\n                MeasureTheory.IntegrableOn f (Set.Ioc a b) ∧ MeasureTheory.IntegrableOn f (Set.Ioc b a))))\n        Iff.rfl))","name":"intervalIntegrable_iff","doc":"A function is interval integrable with respect to a given measure `μ` on `a..b` if and\nonly if it is integrable on `uIoc a b` with respect to `μ`. This is an equivalent\ndefinition of `IntervalIntegrable`. ","depth":32},{"term":"fun {f} {a b} hfi hpos hab =>\n  let_fun hsupp := fun x hx =>\n    { left := Iff.mpr Function.mem_support (LT.lt.ne' (hpos x hx)), right := Set.Ioo_subset_Ioc_self hx };\n  let_fun h₀ :=\n    Eq.mpr\n      (id\n        (Filter.EventuallyLE._eq_1\n            (MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict MeasureTheory.volume (Ι a b))) 0 f ▸\n          Eq.refl (0 ≤ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict MeasureTheory.volume (Ι a b))] f)))\n      (Eq.mpr\n        (id\n          (Set.uIoc_of_le (LT.lt.le hab) ▸\n            Eq.refl (∀ᵐ (x : ℝ) ∂MeasureTheory.Measure.restrict MeasureTheory.volume (Ι a b), OfNat.ofNat 0 x ≤ f x)))\n        (MeasureTheory.ae_restrict_of_ae_eq_of_ae_restrict MeasureTheory.Ioo_ae_eq_Ioc\n          (Iff.mpr (MeasureTheory.ae_restrict_iff' measurableSet_Ioo)\n            (MeasureTheory.ae_of_all MeasureTheory.volume fun x hx => LT.lt.le (hpos x hx)))));\n  Eq.mpr\n    (id\n      (propext (intervalIntegral.integral_pos_iff_support_of_nonneg_ae' h₀ hfi) ▸ Eq.refl (0 < ∫ (x : ℝ) in a..b, f x)))\n    { left := hab,\n      right :=\n        LT.lt.trans_le (Iff.mpr (MeasureTheory.Measure.measure_Ioo_pos MeasureTheory.volume) hab)\n          (MeasureTheory.measure_mono hsupp) }","name":"intervalIntegral.intervalIntegral_pos_of_pos_on","doc":"If `f : ℝ → ℝ` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\nof the interval, then its integral over `a..b` is strictly positive. ","depth":34},{"term":"fun {α} {m0} {μ} [LinearOrder α] {a b} {P} =>\n  Eq.mpr\n    (id\n      (MeasureTheory.ae_restrict_uIoc_eq a b ▸\n        Eq.refl\n          ((∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ (Ι a b), P x) ↔\n            (∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ (Set.Ioc a b), P x) ∧\n              ∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ (Set.Ioc b a), P x)))\n    (Eq.mpr\n      (id\n        (propext Filter.eventually_sup ▸\n          Eq.refl\n            ((∀ᶠ (x : α) in\n                MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ (Set.Ioc a b)) ⊔\n                  MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ (Set.Ioc b a)),\n                P x) ↔\n              (∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ (Set.Ioc a b), P x) ∧\n                ∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ (Set.Ioc b a), P x)))\n      Iff.rfl)","name":"MeasureTheory.ae_restrict_uIoc_iff","doc":"See also `MeasureTheory.ae_uIoc_iff`. ","depth":34},{"term":"fun {a b} n =>\n  Or.casesOn (motive := fun t => le_or_lt a b = t → ∫ (x : ℝ) in Ι a b, |x - a| ^ n = |b - a| ^ (n + 1) / (↑n + 1))\n    (le_or_lt a b)\n    (fun hab h =>\n      Eq.symm h ▸\n        Trans.trans\n          (Trans.trans\n            (Eq.mpr\n              (id (Set.uIoc_of_le hab ▸ Eq.refl (∫ (x : ℝ) in Ι a b, |x - a| ^ n = ∫ (x : ℝ) in a..b, |x - a| ^ n)))\n              (Eq.mpr\n                (id\n                  (Eq.symm (intervalIntegral.integral_of_le hab) ▸\n                    Eq.refl (∫ (x : ℝ) in Set.Ioc a b, |x - a| ^ n = ∫ (x : ℝ) in a..b, |x - a| ^ n)))\n                (Eq.refl (∫ (x : ℝ) in a..b, |x - a| ^ n))))\n            (Eq.mpr\n              (id\n                (congrFun\n                  (congrArg Eq\n                    (Eq.trans\n                      ((fun x_0 x_1 d =>\n                          (fun x_0 x_1 => intervalIntegral.integral_comp_sub_right fun x => |x| ^ n) x_0 x_1 d)\n                        a b a)\n                      (congrFun (congrFun (congrArg (intervalIntegral fun x => |x| ^ n) (sub_self a)) (b - a))\n                        MeasureTheory.volume)))\n                  (∫ (x : ℝ) in 0 ..b - a, x ^ n)))\n              (intervalIntegral.integral_congr fun x hx =>\n                congr_arg₂ Pow.pow\n                  (abs_of_nonneg\n                    (Eq.mp (Set.uIcc_of_le (Iff.mpr sub_nonneg hab) ▸ Eq.refl (x ∈ Set.uIcc 0 (b - a))) hx).left)\n                  rfl)))\n          (of_eq_true\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (integral_pow n)\n                    (congrFun\n                      (congrArg HDiv.hDiv\n                        (Eq.trans\n                          (congrArg (HSub.hSub ((b - a) ^ (n + 1)))\n                            (zero_pow' (n + 1)\n                              (of_eq_true\n                                (Eq.trans\n                                  (congrArg Not\n                                    (Eq.trans\n                                      (Eq.trans Mathlib.Algebra.Group.Units._auxLemma.20\n                                        (congrArg (And (n = 0)) (eq_false_of_decide (Eq.refl false))))\n                                      (and_false (n = 0))))\n                                  not_false_eq_true))))\n                          (sub_zero ((b - a) ^ (n + 1)))))\n                      (↑n + 1))))\n                (congrFun\n                  (congrArg HDiv.hDiv (congrFun (congrArg HPow.hPow (abs_of_nonneg (Iff.mpr sub_nonneg hab))) (n + 1)))\n                  (↑n + 1)))\n              (eq_self ((b - a) ^ (n + 1) / (↑n + 1))))))\n    (fun hab h =>\n      Eq.symm h ▸\n        Trans.trans\n          (Trans.trans\n            (Eq.mpr\n              (id (Set.uIoc_of_lt hab ▸ Eq.refl (∫ (x : ℝ) in Ι a b, |x - a| ^ n = ∫ (x : ℝ) in b..a, |x - a| ^ n)))\n              (Eq.mpr\n                (id\n                  (Eq.symm (intervalIntegral.integral_of_le (LT.lt.le hab)) ▸\n                    Eq.refl (∫ (x : ℝ) in Set.Ioc b a, |x - a| ^ n = ∫ (x : ℝ) in b..a, |x - a| ^ n)))\n                (Eq.refl (∫ (x : ℝ) in b..a, |x - a| ^ n))))\n            (Eq.mpr\n              (id\n                (congrFun\n                  (congrArg Eq\n                    (Eq.trans\n                      ((fun x_0 x_1 d =>\n                          (fun x_0 x_1 => intervalIntegral.integral_comp_sub_right fun x => |x| ^ n) x_0 x_1 d)\n                        b a a)\n                      (congrFun (congrArg (intervalIntegral (fun x => |x| ^ n) (b - a)) (sub_self a))\n                        MeasureTheory.volume)))\n                  (∫ (x : ℝ) in b - a..0, (-x) ^ n)))\n              (intervalIntegral.integral_congr fun x hx =>\n                congr_arg₂ Pow.pow\n                  (abs_of_nonpos\n                    (Eq.mp (Set.uIcc_of_le (Iff.mpr sub_nonpos (LT.lt.le hab)) ▸ Eq.refl (x ∈ Set.uIcc (b - a) 0))\n                        hx).right)\n                  rfl)))\n          (of_eq_true\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans\n                    (Eq.trans\n                      (Eq.trans\n                        ((fun x_0 x_1 => (fun x_0 x_1 => intervalIntegral.integral_comp_neg fun x => x ^ n) x_0 x_1)\n                          (b - a) 0)\n                        (congrFun (congr (congrArg (intervalIntegral fun x => x ^ n) neg_zero) (neg_sub b a))\n                          MeasureTheory.volume))\n                      (integral_pow n))\n                    (congrFun\n                      (congrArg HDiv.hDiv\n                        (Eq.trans\n                          (congrArg (HSub.hSub ((a - b) ^ (n + 1)))\n                            (zero_pow' (n + 1)\n                              (of_eq_true\n                                (Eq.trans\n                                  (congrArg Not\n                                    (Eq.trans\n                                      (Eq.trans Mathlib.Algebra.Group.Units._auxLemma.20\n                                        (congrArg (And (n = 0)) (eq_false_of_decide (Eq.refl false))))\n                                      (and_false (n = 0))))\n                                  not_false_eq_true))))\n                          (sub_zero ((a - b) ^ (n + 1)))))\n                      (↑n + 1))))\n                (congrFun\n                  (congrArg HDiv.hDiv\n                    (congrFun (congrArg HPow.hPow (Eq.trans (abs_of_neg (Iff.mpr sub_neg hab)) (neg_sub b a))) (n + 1)))\n                  (↑n + 1)))\n              (eq_self ((a - b) ^ (n + 1) / (↑n + 1))))))\n    (Eq.refl (le_or_lt a b))","name":"integral_pow_abs_sub_uIoc","doc":"Integral of `|x - a| ^ n` over `Ι a b`. This integral appears in the proof of the\nPicard-Lindelöf/Cauchy-Lipschitz theorem. ","depth":47},{"term":"fun {E} [NormedAddCommGroup E] {f} {c} {R} [NormedSpace ℂ E] hf =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrFun\n          (congrFun\n            (congrFun\n              (congrArg IntervalIntegrable\n                (funext fun θ => congrFun (congrArg HSMul.hSMul (deriv_circleMap c R θ)) (f (circleMap c R θ))))\n              MeasureTheory.volume)\n            0)\n          (2 * Real.pi))\n        Mathlib.MeasureTheory.Integral.CircleIntegral._auxLemma.10))\n    (MeasureTheory.Integrable.mono'\n      (MeasureTheory.Integrable.const_mul\n        (MeasureTheory.Integrable.norm (Eq.mp Mathlib.MeasureTheory.Integral.CircleIntegral._auxLemma.10 hf)) |R|)\n      (MeasureTheory.AEStronglyMeasurable.smul\n        (MeasureTheory.AEStronglyMeasurable.mul_const (Continuous.aestronglyMeasurable (continuous_circleMap 0 R))\n          Complex.I)\n        (MeasureTheory.Integrable.aestronglyMeasurable\n          (Eq.mp Mathlib.MeasureTheory.Integral.CircleIntegral._auxLemma.10 hf)))\n      (of_eq_true\n        (Eq.trans\n          (congrFun\n            (congrArg Filter.Eventually\n              (funext fun a =>\n                Eq.trans\n                  (congrFun\n                    (congrArg LE.le\n                      (Eq.trans (norm_smul (circleMap 0 R a * Complex.I) (f (circleMap c R a)))\n                        (congrFun\n                          (congrArg HMul.hMul\n                            (Eq.trans\n                              (Eq.trans (norm_mul (circleMap 0 R a) Complex.I)\n                                (congr (congrArg HMul.hMul (abs_circleMap_zero R a)) Complex.abs_I))\n                              (mul_one |R|)))\n                          ‖f (circleMap c R a)‖)))\n                    (|R| * ‖f (circleMap c R a)‖))\n                  (Mathlib.Order.Basic._auxLemma.1 (|R| * ‖f (circleMap c R a)‖))))\n            (MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict MeasureTheory.volume (Ι 0 (2 * Real.pi)))))\n          (Mathlib.Order.Filter.Basic._auxLemma.67\n            (MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict MeasureTheory.volume (Ι 0 (2 * Real.pi))))))))","name":"CircleIntegrable.out","doc":"The function we actually integrate over `[0, 2π]` in the definition of `circleIntegral` is\nintegrable. ","depth":50}],"count":30}
{"noDocExamples":[],"kind":"OreLocalization.«term_/ₒ_»","examples":[{"term":"fun {R} [Ring R] {S} [OreLocalization.OreSet S] =>\n  OreLocalization.liftExpand (fun r s => -r /ₒ s)\n    (_ :\n      ∀ (r t : R) (s : { x // x ∈ S }) (ht : ↑s * t ∈ S),\n        (fun r s => -r /ₒ s) r s = (fun r s => -r /ₒ s) (r * t) { val := ↑s * t, property := ht })","name":"OreLocalization.neg","doc":"Negation on the Ore localization is defined via negation on the numerator. ","depth":22},{"term":"fun {R} [Monoid R] {S} [OreLocalization.OreSet S] s =>\n  { val := ↑s /ₒ 1, inv := 1 /ₒ s, val_inv := (_ : ↑s /ₒ 1 * (↑1 /ₒ s) = 1), inv_val := (_ : ↑1 /ₒ s * (↑s /ₒ 1) = 1) }","name":"OreLocalization.numeratorUnit","doc":"The fraction `s /ₒ 1` as a unit in `R[S⁻¹]`, where `s : S`. ","depth":24},{"term":"fun {R} [Monoid R] {S} [OreLocalization.OreSet S] =>\n  { toOneHom := { toFun := fun r => r /ₒ 1, map_one' := (_ : (fun r => r /ₒ 1) 1 = (fun r => r /ₒ 1) 1) },\n    map_mul' := (_ : ∀ (x x_1 : R), x * x_1 /ₒ 1 = x /ₒ 1 * (x_1 /ₒ 1)) }","name":"OreLocalization.numeratorHom","doc":"The multiplicative homomorphism from `R` to `R[S⁻¹]`, mapping `r : R` to the\nfraction `r /ₒ 1`. ","depth":24},{"term":"fun {R} [Ring R] [Nontrivial R] [OreLocalization.OreSet (nonZeroDivisors R)] [NoZeroDivisors R] =>\n  OreLocalization.liftExpand\n    (fun r s => if hr : r = 0 then 0 else ↑s /ₒ { val := r, property := (_ : ∀ (x : R), x * r = 0 → x = 0) })\n    (_ :\n      ∀ (r t : R) (s : { x // x ∈ nonZeroDivisors R }) (hst : ↑s * t ∈ nonZeroDivisors R),\n        (fun r s => if hr : r = 0 then 0 else ↑s /ₒ { val := r, property := (_ : ∀ (x : R), x * r = 0 → x = 0) }) r s =\n          (fun r s => if hr : r = 0 then 0 else ↑s /ₒ { val := r, property := (_ : ∀ (x : R), x * r = 0 → x = 0) })\n            (r * t) { val := ↑s * t, property := hst })","name":"OreLocalization.inv","doc":"The inversion of Ore fractions for a ring without zero divisors, satisying `0⁻¹ = 0` and\n`(r /ₒ r')⁻¹ = r' /ₒ r` for `r ≠ 0`. ","depth":28},{"term":"fun {R} [Monoid R] {S} [OreLocalization.OreSet S] r₁ r₂ s₁ s₂ =>\n  { fst := OreLocalization.oreNum r₂ s₁,\n    snd :=\n      { fst := OreLocalization.oreDenom r₂ s₁,\n        snd :=\n          (_ :\n            r₂ * ↑(OreLocalization.oreDenom r₂ s₁) = ↑s₁ * OreLocalization.oreNum r₂ s₁ ∧\n              r₁ /ₒ s₁ * (r₂ /ₒ s₂) = r₁ * OreLocalization.oreNum r₂ s₁ /ₒ (s₂ * OreLocalization.oreDenom r₂ s₁)) } }","name":"OreLocalization.oreDivMulChar'","doc":"Another characterization lemma for the multiplication on the Ore localizaion delivering\nOre witnesses and conditions bundled in a sigma type. ","depth":34}],"count":28}
{"noDocExamples":[{"term":"fun {E} [NormedAddCommGroup E] [NormedSpace ℝ E] {f} {μ} {a} {n} hint =>\n  Eq.mpr\n    (id\n      (Eq.symm Nat.Ico_zero_eq_range ▸\n        Eq.refl\n          ((Finset.sum (Finset.range n) fun k => ∫ (x : ℝ) in a k..a (k + 1), f x ∂μ) =\n            ∫ (x : ℝ) in a 0 ..a n, f x ∂μ)))\n    (intervalIntegral.sum_integral_adjacent_intervals_Ico (zero_le n) fun k hk => hint k hk.right)","name":"intervalIntegral.sum_integral_adjacent_intervals","depth":31},{"term":"fun {f} {a b} {μ} hab hf hfi =>\n  Eq.mpr\n    (id\n      (intervalIntegral.integral_of_le hab ▸\n        Eq.refl\n          (∫ (x : ℝ) in a..b, f x ∂μ = 0 ↔\n            f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ (Set.Ioc a b))] 0)))\n    (Eq.mpr\n      (id\n        (propext (MeasureTheory.integral_eq_zero_iff_of_nonneg_ae hf hfi.left) ▸\n          Eq.refl\n            (∫ (x : ℝ) in Set.Ioc a b, f x ∂μ = 0 ↔\n              f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ (Set.Ioc a b))] 0)))\n      Iff.rfl)","name":"intervalIntegral.integral_eq_zero_iff_of_le_of_nonneg_ae","depth":31}],"kind":"«term∫_In_.._,_∂_»","examples":[{"term":"fun {E} [NormedAddCommGroup E] [CompleteSpace E] [NormedSpace ℝ E] {a b} {μ} [MeasureTheory.IsFiniteMeasure μ] c =>\n  Eq.mpr\n    (id\n      (congrArg (Eq (∫ (x : ℝ) in a..b, c ∂μ))\n        (Eq.trans (sub_smul (ENNReal.toReal (↑↑μ (Set.Iic b))) (ENNReal.toReal (↑↑μ (Set.Iic a))) c)\n          (congr (congrArg HSub.hSub (Mathlib.MeasureTheory.Integral.IntervalIntegral._auxLemma.19 c))\n            (Mathlib.MeasureTheory.Integral.IntervalIntegral._auxLemma.19 c)))))\n    (Eq.symm\n      (intervalIntegral.integral_Iic_sub_Iic\n        (of_eq_true\n          (Eq.trans\n            (Eq.trans Mathlib.MeasureTheory.Integral.IntervalIntegral._auxLemma.2\n              (congrArg (Or (c = 0)) (Mathlib.MeasureTheory.Integral.IntervalIntegral._auxLemma.20 μ (Set.Iic a))))\n            (Mathlib.MeasureTheory.Integral.IntervalIntegral._auxLemma.21 (c = 0))))\n        (of_eq_true\n          (Eq.trans\n            (Eq.trans Mathlib.MeasureTheory.Integral.IntervalIntegral._auxLemma.2\n              (congrArg (Or (c = 0)) (Mathlib.MeasureTheory.Integral.IntervalIntegral._auxLemma.20 μ (Set.Iic b))))\n            (Mathlib.MeasureTheory.Integral.IntervalIntegral._auxLemma.21 (c = 0))))))","name":"intervalIntegral.integral_const_of_cdf","doc":"If `μ` is a finite measure then `∫ x in a..b, c ∂μ = (μ (Iic b) - μ (Iic a)) • c`. ","depth":36},{"term":"fun {f g} {a b} {μ} hab hfi hgi hle hlt =>\n  Eq.mpr (id (Eq.symm (propext sub_pos) ▸ Eq.refl (∫ (x : ℝ) in a..b, f x ∂μ < ∫ (x : ℝ) in a..b, g x ∂μ)))\n    (Eq.mpr\n      (id\n        (Eq.symm (intervalIntegral.integral_sub hgi hfi) ▸\n          Eq.refl (0 < ∫ (x : ℝ) in a..b, g x ∂μ - ∫ (x : ℝ) in a..b, f x ∂μ)))\n      (Eq.mpr (id (intervalIntegral.integral_of_le hab ▸ Eq.refl (0 < ∫ (x : ℝ) in a..b, g x - f x ∂μ)))\n        (Eq.mpr\n          (id\n            (propext\n                (MeasureTheory.integral_pos_iff_support_of_nonneg_ae\n                  (Filter.Eventually.mono hle fun x => sub_nonneg.mpr)\n                  (MeasureTheory.Integrable.sub hgi.left hfi.left)) ▸\n              Eq.refl (0 < ∫ (x : ℝ) in Set.Ioc a b, g x - f x ∂μ)))\n          (Iff.mpr pos_iff_ne_zero\n            (mt (MeasureTheory.measure_mono_null fun x hx => LT.lt.ne' (Iff.mpr sub_pos (Membership.mem.out hx)))\n              hlt)))))","name":"intervalIntegral.integral_lt_integral_of_ae_le_of_measure_setOf_lt_ne_zero","doc":"If `f` and `g` are two functions that are interval integrable on `a..b`, `a ≤ b`,\n`f x ≤ g x` for a.e. `x ∈ Set.Ioc a b`, and `f x < g x` on a subset of `Set.Ioc a b`\nof nonzero measure, then `∫ x in a..b, f x ∂μ < ∫ x in a..b, g x ∂μ`. ","depth":37},{"term":"fun {E} [NormedAddCommGroup E] [NormedSpace ℝ E] {f g} {μ} {a b} h =>\n  Or.casesOn (motive := fun t => le_total a b = t → ∫ (x : ℝ) in a..b, f x ∂μ = ∫ (x : ℝ) in a..b, g x ∂μ)\n    (le_total a b)\n    (fun hab h_1 =>\n      Eq.symm h_1 ▸\n        Eq.mpr\n          (id\n            (congr (congrArg Eq (intervalIntegral.integral_of_le (of_eq_true (eq_true hab))))\n              (intervalIntegral.integral_of_le (of_eq_true (eq_true hab)))))\n          (Eq.mp\n            (congr\n              (congrArg Eq\n                (congrFun\n                  (congrArg MeasureTheory.integral\n                    (congrArg (MeasureTheory.Measure.restrict μ)\n                      (congr\n                        (congrArg Set.Ioc\n                          (inf_of_le_left (of_eq_true (Eq.trans Mathlib.Order.Basic._auxLemma.4 (eq_true hab)))))\n                        (sup_of_le_right (of_eq_true (Eq.trans Mathlib.Order.Basic._auxLemma.4 (eq_true hab)))))))\n                  fun x => f x))\n              (congrFun\n                (congrArg MeasureTheory.integral\n                  (congrArg (MeasureTheory.Measure.restrict μ)\n                    (congr\n                      (congrArg Set.Ioc\n                        (inf_of_le_left (of_eq_true (Eq.trans Mathlib.Order.Basic._auxLemma.4 (eq_true hab)))))\n                      (sup_of_le_right (of_eq_true (Eq.trans Mathlib.Order.Basic._auxLemma.4 (eq_true hab)))))))\n                fun x => g x))\n            (MeasureTheory.set_integral_congr measurableSet_Ioc (Set.EqOn.mono Set.Ioc_subset_Icc_self h))))\n    (fun hab h_1 =>\n      Eq.symm h_1 ▸\n        Eq.mpr\n          (id\n            (Eq.trans\n              (congr (congrArg Eq (intervalIntegral.integral_of_ge (of_eq_true (eq_true hab))))\n                (intervalIntegral.integral_of_ge (of_eq_true (eq_true hab))))\n              Mathlib.Algebra.Group.Basic._auxLemma.14))\n          (Eq.mp\n            (congr\n              (congrArg Eq\n                (congrFun\n                  (congrArg MeasureTheory.integral\n                    (congrArg (MeasureTheory.Measure.restrict μ)\n                      (congr\n                        (congrArg Set.Ioc\n                          (inf_of_le_right (of_eq_true (Eq.trans Mathlib.Order.Basic._auxLemma.4 (eq_true hab)))))\n                        (sup_of_le_left (of_eq_true (Eq.trans Mathlib.Order.Basic._auxLemma.4 (eq_true hab)))))))\n                  fun x => f x))\n              (congrFun\n                (congrArg MeasureTheory.integral\n                  (congrArg (MeasureTheory.Measure.restrict μ)\n                    (congr\n                      (congrArg Set.Ioc\n                        (inf_of_le_right (of_eq_true (Eq.trans Mathlib.Order.Basic._auxLemma.4 (eq_true hab)))))\n                      (sup_of_le_left (of_eq_true (Eq.trans Mathlib.Order.Basic._auxLemma.4 (eq_true hab)))))))\n                fun x => g x))\n            (MeasureTheory.set_integral_congr measurableSet_Ioc (Set.EqOn.mono Set.Ioc_subset_Icc_self h))))\n    (Eq.refl (le_total a b))","name":"intervalIntegral.integral_congr","doc":"If two functions are equal in the relevant interval, their interval integrals are also equal. ","depth":44}],"count":28}
{"noDocExamples":[],"kind":"«term_≃ₐ[_]_»","examples":[{"term":"fun {F} [Field F] p => Polynomial.SplittingField p ≃ₐ[F] Polynomial.SplittingField p","name":"Polynomial.Gal","doc":"The Galois group of a polynomial. ","depth":14},{"term":"fun K {L} [Field K] [Field L] [Algebra K L] A => MulAction.stabilizer (L ≃ₐ[K] L) A","name":"ValuationSubring.decompositionSubgroup","doc":"The decomposition subgroup defined as the stabilizer of the action\non the type of all valuation subrings of the field. ","depth":19},{"term":"fun K L [Field K] [Field L] [Algebra K L] =>\n  { toFilterBasis := galBasis K L, one' := (_ : ∀ {U : Set (L ≃ₐ[K] L)}, U ∈ (galBasis K L).sets → 1 ∈ U),\n    mul' := (_ : ∀ {U : Set (L ≃ₐ[K] L)}, U ∈ (galBasis K L).sets → ∃ V, V ∈ (galBasis K L).sets ∧ V * V ⊆ U),\n    inv' :=\n      (_ : ∀ {U : Set (L ≃ₐ[K] L)}, U ∈ (galBasis K L).sets → ∃ V, V ∈ (galBasis K L).sets ∧ V ⊆ (fun x => x⁻¹) ⁻¹' U),\n    conj' :=\n      (_ :\n        ∀ (σ : L ≃ₐ[K] L) {U : Set (L ≃ₐ[K] L)},\n          U ∈ (galBasis K L).sets → ∃ V, V ∈ (galBasis K L).sets ∧ V ⊆ (fun x => σ * x * σ⁻¹) ⁻¹' U) }","name":"galGroupBasis","doc":"For a field extension `L/K`, `galGroupBasis K L` is the group filter basis on `L ≃ₐ[K] L`\nwhose sets are `Gal(L/E)` for finite subextensions `E/K` ","depth":20},{"term":"fun K L [Field K] [Field L] [Algebra K L] ha =>\n  {\n    toEquiv :=\n      { toFun := fun ϕ => ↑ϕ, invFun := fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ),\n        left_inv :=\n          (_ : ∀ (x : L ≃ₐ[K] L), (fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ)) ((fun ϕ => ↑ϕ) x) = x),\n        right_inv :=\n          (_ :\n            ∀ (x : L →ₐ[K] L), (fun ϕ => ↑ϕ) ((fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ)) x) = x) },\n    map_mul' :=\n      (_ :\n        ∀ (x x_1 : L ≃ₐ[K] L),\n          Equiv.toFun\n              { toFun := fun ϕ => ↑ϕ, invFun := fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ),\n                left_inv :=\n                  (_ :\n                    ∀ (x : L ≃ₐ[K] L),\n                      (fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ)) ((fun ϕ => ↑ϕ) x) = x),\n                right_inv :=\n                  (_ :\n                    ∀ (x : L →ₐ[K] L),\n                      (fun ϕ => ↑ϕ) ((fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ)) x) = x) }\n              (x * x_1) =\n            Equiv.toFun\n              { toFun := fun ϕ => ↑ϕ, invFun := fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ),\n                left_inv :=\n                  (_ :\n                    ∀ (x : L ≃ₐ[K] L),\n                      (fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ)) ((fun ϕ => ↑ϕ) x) = x),\n                right_inv :=\n                  (_ :\n                    ∀ (x : L →ₐ[K] L),\n                      (fun ϕ => ↑ϕ) ((fun ϕ => AlgEquiv.ofBijective ϕ (_ : Function.Bijective ↑ϕ)) x) = x) }\n              (x * x_1)) }","name":"Algebra.IsAlgebraic.algEquivEquivAlgHom","doc":"Bijection between algebra equivalences and algebra homomorphisms ","depth":23},{"term":"fun {F} [Field F] {E} [Field E] [Algebra F E] K => fixingSubgroup (E ≃ₐ[F] E) ↑K","name":"IntermediateField.fixingSubgroup","doc":"The subgroup fixing an intermediate field ","depth":24}],"count":28}
{"noDocExamples":[],"kind":"«term_→+*_»","examples":[{"term":"fun M N [Semiring M] [Semiring N] => M →+* N","name":"SemiRingCat.AssocRingHom","doc":"`RingHom` doesn't actually assume associativity. This alias is needed to make the category\ntheory machinery work. We use the same trick in `MonCat.AssocMonoidHom`. ","depth":8},{"term":"fun {R} [NonAssocSemiring R] =>\n  { toInhabited := { default := Nat.castRingHom R }, uniq := (_ : ∀ (f : ℕ →+* R), f = Nat.castRingHom R) }","name":"Nat.uniqueRingHom","doc":"We don't use `RingHomClass` here, since that might cause type-class slowdown for\n`Subsingleton`","depth":10},{"term":"fun {K} [Field K] =>\n  Subtype.map NumberField.InfinitePlace.mk\n    (_ :\n      ∀ (φ : K →+* ℂ),\n        ¬NumberField.ComplexEmbedding.IsReal φ →\n          ∃ φ_1,\n            ¬NumberField.ComplexEmbedding.IsReal φ_1 ∧\n              NumberField.InfinitePlace.mk φ_1 = NumberField.InfinitePlace.mk φ)","name":"NumberField.InfinitePlace.mkComplex","doc":"The map from nonreal embeddings to complex infinite places ","depth":15},{"term":"fun {R} {S} [Ring R] [Ring S] [Algebra ℚ R] [Algebra ℚ S] =>\n  { toFun := RingHom.toRatAlgHom, invFun := AlgHom.toRingHom,\n    left_inv := (_ : ∀ (f : R →+* S), ↑(RingHom.toRatAlgHom f) = f),\n    right_inv := (_ : ∀ (f : R →ₐ[ℚ] S), RingHom.toRatAlgHom ↑f = f) }","name":"RingHom.equivRatAlgHom","doc":"The equivalence between `RingHom` and `ℚ`-algebra homomorphisms. ","depth":19},{"term":"fun P =>\n  ∀ ⦃R S T : Type u⦄ [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : CommRing T] (f : R →+* S) (g : S →+* T),\n    P f → P g → P (RingHom.comp g f)","name":"RingHom.StableUnderComposition","doc":"A property is `StableUnderComposition` if the composition of two such morphisms\nstill falls in the class. ","depth":21}],"count":28}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫_In_,_»","examples":[{"term":"fun s => ∫ (x : ℝ) in Set.Ioi 0, ↑(rexp (-x)) * ↑x ^ (s - 1)","name":"Complex.GammaIntegral","doc":"Euler's integral for the `Γ` function (of a complex variable `s`), defined as\n`∫ x in Ioi 0, exp (-x) * x ^ (s - 1)`.\n\nSee `Complex.GammaIntegral_convergent` for a proof of the convergence of the integral for\n`0 < re s`. ","depth":11},{"term":"fun {E} [NormedAddCommGroup E] [NormedSpace ℂ E] f s => ∫ (t : ℝ) in Set.Ioi 0, ↑t ^ (s - 1) • f t","name":"mellin","doc":"The Mellin transform of a function `f` (for a complex exponent `s`), defined as the integral of\n`t ^ (s - 1) • f` over `Ioi 0`. ","depth":22},{"term":"fun {n} {E} [NormedAddCommGroup E] [NormedSpace ℂ E] f c R =>\n  ∫ (θ : Fin n → ℝ) in Set.Icc 0 fun x => 2 * Real.pi,\n    (Finset.prod Finset.univ fun i => ↑(R i) * cexp (↑(θ i) * Complex.I) * Complex.I) • f (torusMap c R θ)","name":"torusIntegral","doc":"The definition of the integral over a generalized torus with center `c ∈ ℂⁿ` and radius `R ∈ ℝⁿ`\nas the `•`-product of the derivative of `torusMap` and `f (torusMap c R θ)`","depth":24},{"term":"funext fun s =>\n  of_eq_true\n    (Eq.trans\n      (congrFun\n        (congrArg Eq\n          (congrArg (MeasureTheory.integral (MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Ioi 0)))\n            (funext fun x => mul_comm (↑(rexp (-x))) (↑x ^ (s - 1)))))\n        (∫ (t : ℝ) in Set.Ioi 0, ↑t ^ (s - 1) * ↑(rexp (-t))))\n      (eq_self (∫ (x : ℝ) in Set.Ioi 0, ↑x ^ (s - 1) * ↑(rexp (-x)))))","name":"Complex.GammaIntegral_eq_mellin","doc":"Rewrite the Gamma integral as an example of a Mellin transform. ","depth":26},{"term":"fun {f f' g} {a} hf hft hff' hg_cont hg1 hg2 =>\n  let_fun hg2' :=\n    id\n      (Eq.mp\n        (congrFun\n          (congrFun (congrArg MeasureTheory.IntegrableOn (funext fun x => mul_comm (g (f x)) (f' x))) (Set.Ici a))\n          MeasureTheory.volume)\n        hg2);\n  Eq.mpr\n    (id\n      (congrFun\n        (congrArg Eq\n          (congrArg (MeasureTheory.integral (MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Ioi a)))\n            (funext fun x => mul_comm (g (f x)) (f' x))))\n        (∫ (u : ℝ) in Set.Ioi (f a), g u)))\n    (MeasureTheory.integral_comp_smul_deriv_Ioi hf hft hff' hg_cont hg1 hg2')","name":"MeasureTheory.integral_comp_mul_deriv_Ioi","doc":"Change-of-variables formula for `Ioi` integrals of scalar-valued functions ","depth":32}],"count":26}
{"noDocExamples":[{"term":"fun {α} {E} {F'} {G'} [Norm E] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G'] {l} =>\n  { trans := (_ : ∀ {a : α → E} {b : α → F'} {c : α → G'}, a =o[l] b → b =Θ[l] c → a =o[l] c) }","name":"Asymptotics.instTransForAllForAllForAllIsLittleOToNormIsThetaToNormIsLittleO","depth":18}],"kind":"Asymptotics.«term_=o[_]_»","examples":[{"term":"fun {α} {β} [NormedAddCommGroup β] l u v => (u - v) =o[l] v","name":"Asymptotics.IsEquivalent","doc":"Two functions `u` and `v` are said to be asymptotically equivalent along a filter `l` when\n`u x - v x = o(v x)` as `x` converges along `l`. ","depth":19},{"term":"fun {α} {E} {F} [Norm E] [Norm F] {f} {g} {l} =>\n  Eq.mpr\n    (id (Asymptotics.IsLittleO_def l f g ▸ Eq.refl (f =o[l] g ↔ ∀ ⦃c : ℝ⦄, 0 < c → Asymptotics.IsBigOWith c l f g)))\n    Iff.rfl","name":"Asymptotics.isLittleO_iff_forall_isBigOWith","doc":"Definition of `IsLittleO` in terms of `IsBigOWith`. ","depth":30},{"term":"fun {α} {E} {F} [Norm E] [Norm F] {f} {g} {l} =>\n  (fun {α} {E} {F} [Norm E] [Norm F] {f} {g} {l} =>\n      Eq.mpr\n        (id (Asymptotics.IsLittleO_def l f g ▸ Eq.refl (f =o[l] g ↔ ∀ ⦃c : ℝ⦄, 0 < c → Asymptotics.IsBigOWith c l f g)))\n        Iff.rfl).mp","name":"Asymptotics.IsLittleO.forall_isBigOWith","doc":"**Alias** of the forward direction of `Asymptotics.isLittleO_iff_forall_isBigOWith`.\n\n---\n\nDefinition of `IsLittleO` in terms of `IsBigOWith`. ","depth":47},{"term":"fun {α} {E} {F} [Norm E] [Norm F] {f} {g} {l} =>\n  (fun {α} {E} {F} [Norm E] [Norm F] {f} {g} {l} =>\n      Eq.mpr\n        (id (Asymptotics.IsLittleO_def l f g ▸ Eq.refl (f =o[l] g ↔ ∀ ⦃c : ℝ⦄, 0 < c → Asymptotics.IsBigOWith c l f g)))\n        Iff.rfl).mpr","name":"Asymptotics.IsLittleO.of_isBigOWith","doc":"**Alias** of the reverse direction of `Asymptotics.isLittleO_iff_forall_isBigOWith`.\n\n---\n\nDefinition of `IsLittleO` in terms of `IsBigOWith`. ","depth":47}],"count":25}
{"noDocExamples":[{"term":"fun {L} {M} {N} [FirstOrder.Language.Structure L M] [FirstOrder.Language.Structure L N] =>\n  of_eq_true\n    (Eq.trans\n      (congrFun (congrArg Iff Mathlib.ModelTheory.Semantics._auxLemma.53)\n        (∀ (φ : FirstOrder.Language.Sentence L), M ⊨ φ ↔ N ⊨ φ))\n      (iff_self (∀ (x : FirstOrder.Language.Sentence L), M ⊨ x ↔ N ⊨ x)))","name":"FirstOrder.Language.elementarilyEquivalent_iff","depth":23},{"term":"fun {L} {M} [FirstOrder.Language.Structure L M] {T T'} h h' =>\n  Eq.mpr\n    (id\n      (Eq.trans (Mathlib.ModelTheory.Semantics._auxLemma.54 (T ∪ T'))\n        (forall_congr fun φ => implies_congr (Mathlib.ModelTheory.Semantics._auxLemma.56 φ T T') (Eq.refl (M ⊨ φ)))))\n    fun φ hφ =>\n    Or.elim hφ (Eq.mp (Mathlib.ModelTheory.Semantics._auxLemma.54 T) h φ)\n      (Eq.mp (Mathlib.ModelTheory.Semantics._auxLemma.54 T') h' φ)","name":"FirstOrder.Language.Theory.Model.union","depth":26},{"term":"fun {M} [Preorder M] =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (Eq.trans\n            (Mathlib.ModelTheory.Order._auxLemma.2\n              {FirstOrder.Language.Relations.reflexive FirstOrder.Language.leSymb,\n                FirstOrder.Language.Relations.transitive FirstOrder.Language.leSymb})\n            (forall_congr fun φ =>\n              implies_congr\n                (Eq.trans Mathlib.ModelTheory.Order._auxLemma.3\n                  (congrArg (Or (φ = FirstOrder.Language.Relations.reflexive FirstOrder.Language.leSymb))\n                    Mathlib.ModelTheory.Order._auxLemma.4))\n                (Eq.refl (M ⊨ φ))))\n          Mathlib.ModelTheory.Order._auxLemma.5)\n        (congr (congrArg And Mathlib.ModelTheory.Order._auxLemma.6)\n          (Eq.trans Mathlib.ModelTheory.Order._auxLemma.7 Mathlib.ModelTheory.Order._auxLemma.8))))\n    { left := le_refl, right := fun x x_1 x_2 => le_trans }","name":"FirstOrder.Language.model_preorder.proof_1","depth":26},{"term":"fun {L} {M} [FirstOrder.Language.Structure L M] {φ} =>\n  of_eq_true\n    (Eq.trans\n      (congrFun\n        (congrArg Iff\n          (Eq.trans\n            (Eq.trans (Mathlib.ModelTheory.Semantics._auxLemma.54 {φ})\n              (forall_congr fun φ_1 => implies_congr Mathlib.Data.Set.Basic._auxLemma.44 (Eq.refl (M ⊨ φ_1))))\n            Std.Logic._auxLemma.33))\n        (M ⊨ φ))\n      (iff_self (M ⊨ φ)))","name":"FirstOrder.Language.Theory.model_singleton_iff","depth":27}],"kind":"FirstOrder.Language.«term_⊨_»","examples":[{"term":"fun L M [FirstOrder.Language.Structure L M] => {φ | M ⊨ φ}","name":"FirstOrder.Language.completeTheory","doc":"The complete theory of a structure `M` is the set of all sentences `M` satisfies. ","depth":9}],"count":24}
{"noDocExamples":[{"term":"fun {α} {γ} [MeasurableSpace α] {μ} [TopologicalSpace γ] {𝕜} [Monoid 𝕜] [MulAction 𝕜 γ] [ContinuousConstSMul 𝕜 γ] =>\n  Function.Injective.mulAction MeasureTheory.AEEqFun.toGerm (_ : Function.Injective MeasureTheory.AEEqFun.toGerm)\n    (_ : ∀ (c : 𝕜) (f : α →ₘ[μ] γ), MeasureTheory.AEEqFun.toGerm (c • f) = c • MeasureTheory.AEEqFun.toGerm f)","name":"MeasureTheory.AEEqFun.instMulAction","depth":22}],"kind":"MeasureTheory.«term_→ₘ[_]_»","examples":[{"term":"fun {α} {γ} [MeasurableSpace α] {μ} [TopologicalSpace γ] [Monoid γ] [ContinuousMul γ] =>\n  { toOneHom := { toFun := MeasureTheory.AEEqFun.toGerm, map_one' := (_ : MeasureTheory.AEEqFun.toGerm 1 = 1) },\n    map_mul' :=\n      (_ :\n        ∀ (f g : α →ₘ[μ] γ),\n          MeasureTheory.AEEqFun.toGerm (f * g) = MeasureTheory.AEEqFun.toGerm f * MeasureTheory.AEEqFun.toGerm g) }","name":"MeasureTheory.AEEqFun.toGermMonoidHom","doc":"`AEEqFun.toGerm` as a `MonoidHom`. ","depth":22},{"term":"fun {α} {γ} [MeasurableSpace α] {μ} [TopologicalSpace γ] [AddMonoid γ] [ContinuousAdd γ] =>\n  { toZeroHom := { toFun := MeasureTheory.AEEqFun.toGerm, map_zero' := (_ : MeasureTheory.AEEqFun.toGerm 0 = 0) },\n    map_add' :=\n      (_ :\n        ∀ (f g : α →ₘ[μ] γ),\n          MeasureTheory.AEEqFun.toGerm (f + g) = MeasureTheory.AEEqFun.toGerm f + MeasureTheory.AEEqFun.toGerm g) }","name":"MeasureTheory.AEEqFun.toGermAddMonoidHom","doc":"`AEEqFun.toGerm` as an `AddMonoidHom`.","depth":22},{"term":"fun {α} E {m} [NormedAddCommGroup E] p μ =>\n  {\n    toAddSubmonoid :=\n      {\n        toAddSubsemigroup :=\n          { carrier := {f | MeasureTheory.snorm (↑f) p μ < ⊤},\n            add_mem' :=\n              (_ :\n                ∀ {f g : α →ₘ[μ] E},\n                  f ∈ {f | MeasureTheory.snorm (↑f) p μ < ⊤} →\n                    g ∈ {f | MeasureTheory.snorm (↑f) p μ < ⊤} → MeasureTheory.snorm (↑(f + g)) p μ < ⊤) },\n        zero_mem' := (_ : MeasureTheory.snorm (↑0) p μ < ⊤) },\n    neg_mem' :=\n      (_ :\n        ∀ {f : α →ₘ[μ] E},\n          f ∈\n              {\n                    toAddSubsemigroup :=\n                      { carrier := {f | MeasureTheory.snorm (↑f) p μ < ⊤},\n                        add_mem' :=\n                          (_ :\n                            ∀ {f g : α →ₘ[μ] E},\n                              f ∈ {f | MeasureTheory.snorm (↑f) p μ < ⊤} →\n                                g ∈ {f | MeasureTheory.snorm (↑f) p μ < ⊤} → MeasureTheory.snorm (↑(f + g)) p μ < ⊤) },\n                    zero_mem' := (_ : MeasureTheory.snorm (↑0) p μ < ⊤) }.toAddSubsemigroup.carrier →\n            -f ∈\n              {\n                    toAddSubsemigroup :=\n                      { carrier := {f | MeasureTheory.snorm (↑f) p μ < ⊤},\n                        add_mem' :=\n                          (_ :\n                            ∀ {f g : α →ₘ[μ] E},\n                              f ∈ {f | MeasureTheory.snorm (↑f) p μ < ⊤} →\n                                g ∈ {f | MeasureTheory.snorm (↑f) p μ < ⊤} → MeasureTheory.snorm (↑(f + g)) p μ < ⊤) },\n                    zero_mem' := (_ : MeasureTheory.snorm (↑0) p μ < ⊤) }.toAddSubsemigroup.carrier) }","name":"MeasureTheory.Lp","doc":"Lp space ","depth":26},{"term":"fun {α} E {m0} p μ [NormedAddCommGroup E] 𝕜 [NormedRing 𝕜] [Module 𝕜 E] [BoundedSMul 𝕜 E] =>\n  let src := MeasureTheory.Lp E p;\n  { toAddSubmonoid := src.toAddSubmonoid,\n    smul_mem' :=\n      (_ :\n        ∀ (c : 𝕜) (f : α →ₘ[μ] E),\n          f ∈ (MeasureTheory.Lp E p).toAddSubmonoid.toAddSubsemigroup.carrier →\n            c • f ∈ (MeasureTheory.Lp E p).toAddSubmonoid.toAddSubsemigroup.carrier) }","name":"MeasureTheory.Lp.LpSubmodule","doc":"The `𝕜`-submodule of elements of `α →ₘ[μ] E` whose `Lp` norm is finite.  This is `Lp E p μ`,\nwith extra structure. ","depth":26}],"count":24}
{"noDocExamples":[],"kind":"Polynomial.«term_%ₘ_»","examples":[{"term":"fun {R} [CommRing R] q =>\n  {\n    toAddHom :=\n      { toFun := fun p => p %ₘ q, map_add' := (_ : ∀ (p₁ p₂ : Polynomial R), (p₁ + p₂) %ₘ q = p₁ %ₘ q + p₂ %ₘ q) },\n    map_smul' := (_ : ∀ (c : R) (p : Polynomial R), c • p %ₘ q = c • (p %ₘ q)) }","name":"Polynomial.modByMonicHom","doc":"`_ %ₘ q` as an `R`-linear map. ","depth":21},{"term":"fun {R} [CommRing R] {q} p hq => decidable_of_iff (p %ₘ q = 0) (_ : p %ₘ q = 0 ↔ q ∣ p)","name":"Polynomial.decidableDvdMonic","doc":"An algorithm for deciding polynomial divisibility.\nThe algorithm is \"compute `p %ₘ q` and compare to `0`\".\nSee `polynomial.modByMonic` for the algorithm that computes `%ₘ`.\n","depth":23},{"term":"fun {R} {S} [CommRing R] [Ring S] {f} [Algebra R S] h =>\n  {\n    toAddHom :=\n      { toFun := fun x => IsAdjoinRoot.repr h.toIsAdjoinRoot x %ₘ f,\n        map_add' :=\n          (_ :\n            ∀ (x y : S),\n              (fun x => IsAdjoinRoot.repr h.toIsAdjoinRoot x %ₘ f) (x + y) =\n                (fun x => IsAdjoinRoot.repr h.toIsAdjoinRoot x %ₘ f) x +\n                  (fun x => IsAdjoinRoot.repr h.toIsAdjoinRoot x %ₘ f) y) },\n    map_smul' :=\n      (_ :\n        ∀ (c : R) (x : S),\n          AddHom.toFun\n              { toFun := fun x => IsAdjoinRoot.repr h.toIsAdjoinRoot x %ₘ f,\n                map_add' :=\n                  (_ :\n                    ∀ (x y : S),\n                      (fun x => IsAdjoinRoot.repr h.toIsAdjoinRoot x %ₘ f) (x + y) =\n                        (fun x => IsAdjoinRoot.repr h.toIsAdjoinRoot x %ₘ f) x +\n                          (fun x => IsAdjoinRoot.repr h.toIsAdjoinRoot x %ₘ f) y) }\n              (c • x) =\n            ↑(RingHom.id R) c •\n              AddHom.toFun\n                { toFun := fun x => IsAdjoinRoot.repr h.toIsAdjoinRoot x %ₘ f,\n                  map_add' :=\n                    (_ :\n                      ∀ (x y : S),\n                        (fun x => IsAdjoinRoot.repr h.toIsAdjoinRoot x %ₘ f) (x + y) =\n                          (fun x => IsAdjoinRoot.repr h.toIsAdjoinRoot x %ₘ f) x +\n                            (fun x => IsAdjoinRoot.repr h.toIsAdjoinRoot x %ₘ f) y) }\n                x) }","name":"IsAdjoinRootMonic.modByMonicHom","doc":"`IsAdjoinRoot.modByMonicHom` sends the equivalence class of `f` mod `g` to `f %ₘ g`. ","depth":24},{"term":"fun {R} [Field R] p q => p %ₘ (q * ↑Polynomial.C (Polynomial.leadingCoeff q)⁻¹)","name":"Polynomial.mod","doc":"Remainder of polynomial division. See `Polynomial.modByMonic` for more details. ","depth":25},{"term":"fun {R} [CommRing R] {p q} hmonic hdegree =>\n  Mathlib.Tactic.Nontriviality.subsingleton_or_nontrivial_elim\n    (fun [anonymous] =>\n      of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg Eq\n              (Polynomial.Monic.leadingCoeff\n                (of_eq_true (Mathlib.Data.Polynomial.Degree.Definitions._auxLemma.1 (p /ₘ q)))))\n            (Polynomial.Monic.leadingCoeff (of_eq_true (Mathlib.Data.Polynomial.Degree.Definitions._auxLemma.1 p))))\n          (eq_self 1)))\n    fun [anonymous] =>\n    let_fun h :=\n      Eq.mpr\n        (id\n          (Eq.trans\n            (Eq.trans\n              (congrFun\n                (congrArg Ne\n                  (Eq.trans\n                    (congrFun (congrArg HMul.hMul (Polynomial.Monic.leadingCoeff hmonic))\n                      (Polynomial.leadingCoeff (p /ₘ q)))\n                    (one_mul (Polynomial.leadingCoeff (p /ₘ q)))))\n                0)\n              (congrArg Not\n                (Eq.trans Mathlib.Data.Polynomial.Degree.Definitions._auxLemma.10\n                  ((fun x_0 => propext ((fun x_0 => Polynomial.divByMonic_eq_zero_iff hmonic) x_0)) p))))\n            Mathlib.Init.Order.Defs._auxLemma.1))\n        hdegree;\n    Eq.mpr\n      (id\n        (Eq.symm (Polynomial.modByMonic_add_div p hmonic) ▸\n          Eq.refl (Polynomial.leadingCoeff (p /ₘ q) = Polynomial.leadingCoeff p)))\n      (Eq.mpr\n        (id\n          (Polynomial.leadingCoeff_add_of_degree_lt\n              (Eq.mpr\n                (id\n                  (Polynomial.degree_mul' h ▸ Eq.refl (Polynomial.degree (p %ₘ q) < Polynomial.degree (q * (p /ₘ q)))))\n                (Eq.mpr\n                  (id\n                    (Polynomial.degree_add_divByMonic hmonic hdegree ▸\n                      Eq.refl (Polynomial.degree (p %ₘ q) < Polynomial.degree q + Polynomial.degree (p /ₘ q))))\n                  (LT.lt.trans_le (Polynomial.degree_modByMonic_lt p hmonic) hdegree))) ▸\n            Eq.refl (Polynomial.leadingCoeff (p /ₘ q) = Polynomial.leadingCoeff (p %ₘ q + q * (p /ₘ q)))))\n        (Eq.mpr\n          (id\n            (Polynomial.leadingCoeff_monic_mul hmonic ▸\n              Eq.refl (Polynomial.leadingCoeff (p /ₘ q) = Polynomial.leadingCoeff (q * (p /ₘ q)))))\n          (Eq.refl (Polynomial.leadingCoeff (p /ₘ q)))))","name":"Polynomial.leadingCoeff_divByMonic_of_monic","doc":"Division by a monic polynomial doesn't change the leading coefficient. ","depth":39}],"count":23}
{"noDocExamples":[{"term":"fun {α} {β} [Preorder β] {l} => { trans := (_ : ∀ {a b c : α → β}, a =ᶠ[l] b → b ≤ᶠ[l] c → a ≤ᶠ[l] c) }","name":"Filter.instTransForAllEventuallyEqEventuallyLEToLE","depth":15},{"term":"fun {α} {β} [Preorder β] {l} => { trans := (_ : ∀ {a b c : α → β}, a ≤ᶠ[l] b → b =ᶠ[l] c → a ≤ᶠ[l] c) }","name":"Filter.instTransForAllEventuallyLEToLEEventuallyEq","depth":16}],"kind":"Filter.«term_≤ᶠ[_]_»","examples":[{"term":"fun {Ω} {E} {ι} [Preorder ι] {m0} [NormedAddCommGroup E] [NormedSpace ℝ E] [CompleteSpace E] [LE E] f ℱ μ =>\n  MeasureTheory.Adapted ℱ f ∧\n    (∀ (i j : ι), i ≤ j → f i ≤ᶠ[MeasureTheory.Measure.ae μ] MeasureTheory.condexp (↑ℱ i) μ (f j)) ∧\n      ∀ (i : ι), MeasureTheory.Integrable (f i)","name":"MeasureTheory.Submartingale","doc":"A family of integrable functions `f : ι → Ω → E` is a submartingale with respect to a\nfiltration `ℱ` if `f` is adapted with respect to `ℱ` and for all `i ≤ j`,\n`f i ≤ᵐ[μ] μ[f j | ℱ.le i]`. ","depth":29},{"term":"fun {Ω} {E} {ι} [Preorder ι] {m0} [NormedAddCommGroup E] [NormedSpace ℝ E] [CompleteSpace E] [LE E] f ℱ μ =>\n  MeasureTheory.Adapted ℱ f ∧\n    (∀ (i j : ι), i ≤ j → MeasureTheory.condexp (↑ℱ i) μ (f j) ≤ᶠ[MeasureTheory.Measure.ae μ] f i) ∧\n      ∀ (i : ι), MeasureTheory.Integrable (f i)","name":"MeasureTheory.Supermartingale","doc":"A family of integrable functions `f : ι → Ω → E` is a supermartingale with respect to a\nfiltration `ℱ` if `f` is adapted with respect to `ℱ` and for all `i ≤ j`,\n`μ[f j | ℱ.le i] ≤ᵐ[μ] f i`. ","depth":30},{"term":"fun {f} {a b} hfi hpos hab =>\n  let_fun hsupp := fun x hx =>\n    { left := Iff.mpr Function.mem_support (LT.lt.ne' (hpos x hx)), right := Set.Ioo_subset_Ioc_self hx };\n  let_fun h₀ :=\n    Eq.mpr\n      (id\n        (Filter.EventuallyLE._eq_1\n            (MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict MeasureTheory.volume (Ι a b))) 0 f ▸\n          Eq.refl (0 ≤ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict MeasureTheory.volume (Ι a b))] f)))\n      (Eq.mpr\n        (id\n          (Set.uIoc_of_le (LT.lt.le hab) ▸\n            Eq.refl (∀ᵐ (x : ℝ) ∂MeasureTheory.Measure.restrict MeasureTheory.volume (Ι a b), OfNat.ofNat 0 x ≤ f x)))\n        (MeasureTheory.ae_restrict_of_ae_eq_of_ae_restrict MeasureTheory.Ioo_ae_eq_Ioc\n          (Iff.mpr (MeasureTheory.ae_restrict_iff' measurableSet_Ioo)\n            (MeasureTheory.ae_of_all MeasureTheory.volume fun x hx => LT.lt.le (hpos x hx)))));\n  Eq.mpr\n    (id\n      (propext (intervalIntegral.integral_pos_iff_support_of_nonneg_ae' h₀ hfi) ▸ Eq.refl (0 < ∫ (x : ℝ) in a..b, f x)))\n    { left := hab,\n      right :=\n        LT.lt.trans_le (Iff.mpr (MeasureTheory.Measure.measure_Ioo_pos MeasureTheory.volume) hab)\n          (MeasureTheory.measure_mono hsupp) }","name":"intervalIntegral.intervalIntegral_pos_of_pos_on","doc":"If `f : ℝ → ℝ` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\nof the interval, then its integral over `a..b` is strictly positive. ","depth":34}],"count":23}
{"noDocExamples":[{"term":"fun {α} [Lattice α] [Group α] a h =>\n  Eq.mpr (id (LatticeOrderedGroup.neg_eq_pos_inv a ▸ Eq.refl (a⁻ = a⁻¹))) (LatticeOrderedGroup.pos_of_one_le a⁻¹ h)","name":"LatticeOrderedGroup.neg_of_one_le_inv","depth":23},{"term":"fun {α} [Lattice α] [AddGroup α] a h =>\n  Eq.mpr (id (LatticeOrderedGroup.neg_eq_pos_neg a ▸ Eq.refl (a⁻ = -a))) (LatticeOrderedGroup.pos_of_nonneg (-a) h)","name":"LatticeOrderedGroup.neg_of_inv_nonneg","depth":23},{"term":"fun {α} [Lattice α] [Group α] a =>\n  Eq.mpr (id (LatticeOrderedGroup.neg_eq_pos_inv a⁻¹ ▸ Eq.refl (a⁺ = a⁻¹⁻)))\n    (Eq.mpr (id (inv_inv a ▸ Eq.refl (a⁺ = a⁻¹⁻¹⁺))) (Eq.refl a⁺))","name":"LatticeOrderedGroup.pos_eq_neg_inv","depth":25},{"term":"fun {α} [Lattice α] [AddGroup α] a =>\n  Eq.mpr (id (LatticeOrderedGroup.neg_eq_pos_neg (-a) ▸ Eq.refl (a⁺ = (-a)⁻)))\n    (Eq.mpr (id (neg_neg a ▸ Eq.refl (a⁺ = (- -a)⁺))) (Eq.refl a⁺))","name":"LatticeOrderedGroup.pos_eq_neg_neg","depth":25},{"term":"fun {α} [Lattice α] [AddGroup α] =>\n  Eq.mpr (id (LatticeOrderedGroup.neg_part_def 0 ▸ Eq.refl (0⁻ = 0)))\n    (Eq.mpr (id (neg_zero ▸ Eq.refl (-0 ⊔ 0 = 0))) (Eq.mpr (id (sup_idem ▸ Eq.refl (0 ⊔ 0 = 0))) (Eq.refl 0)))","name":"LatticeOrderedGroup.neg_zero","depth":26}],"kind":"«term_⁻»","examples":[],"count":22}
{"noDocExamples":[],"kind":"«termℤ√_»","examples":[{"term":"ℤ√(-1)","name":"GaussianInt","doc":"The Gaussian integers, defined as `ℤ√(-1)`. ","depth":5},{"term":"fun d => { x // x ∈ unitary (ℤ√d) }","name":"Pell.Solution₁","doc":"`Pell.Solution₁ d` is the type of solutions to the Pell equation `x^2 - d*y^2 = 1`.\nWe define this in terms of elements of `ℤ√d` of norm one.\n","depth":13},{"term":"fun {d} =>\n  { toOneHom := { toFun := Zsqrtd.norm, map_one' := (_ : Zsqrtd.norm 1 = 1) },\n    map_mul' := (_ : ∀ (n m : ℤ√d), Zsqrtd.norm (n * m) = Zsqrtd.norm n * Zsqrtd.norm m) }","name":"Zsqrtd.normMonoidHom","doc":"`norm` as a `MonoidHom`. ","depth":13},{"term":"fun {d} x y prop => { val := { re := x, im := y }, property := (_ : { re := x, im := y } ∈ unitary (ℤ√d)) }","name":"Pell.Solution₁.mk","doc":"Construct a solution from `x`, `y` and a proof that the equation is satisfied. ","depth":18},{"term":"fun {d} {a} =>\n  Eq.mpr (id (propext unitary.mem_iff_self_mul_star ▸ Eq.refl (Zsqrtd.norm a = 1 ↔ a ∈ unitary (ℤ√d))))\n    (Eq.mpr (id (Eq.symm (Zsqrtd.norm_eq_mul_conj a) ▸ Eq.refl (Zsqrtd.norm a = 1 ↔ a * star a = 1)))\n      (Eq.mpr\n        (id\n          (Eq.trans\n            (Eq.trans\n              (congr (congrArg Iff (congrArg (Eq (Zsqrtd.norm a)) (Eq.symm Nat.cast_one)))\n                (congrArg (Eq ↑(Zsqrtd.norm a)) (Eq.symm Nat.cast_one)))\n              (congrArg (Iff (Zsqrtd.norm a = ↑1))\n                (Eq.trans\n                  (congrArg (Eq ↑(Zsqrtd.norm a))\n                    (Eq.trans Nat.cast_one (Eq.symm (Eq.trans (congrArg Int.cast Nat.cast_one) Int.cast_one))))\n                  Mathlib.Data.Int.CharZero._auxLemma.2)))\n            (congr (congrArg Iff (congrArg (Eq (Zsqrtd.norm a)) Nat.cast_one))\n              (congrArg (Eq (Zsqrtd.norm a)) Nat.cast_one))))\n        Iff.rfl))","name":"Zsqrtd.norm_eq_one_iff_mem_unitary","doc":"An element of `ℤ√d` has norm equal to `1` if and only if it is contained in the submonoid\nof unitary elements. ","depth":28}],"count":22}
{"noDocExamples":[],"kind":"TypeVec.«term_:::__1»","examples":[{"term":"fun {n} {F} [MvFunctor F] [MvQPF F] {α} => MvQPF.Fix.rec (MvFunctor.map (TypeVec.id ::: MvQPF.Fix.mk))","name":"MvQPF.Fix.dest","doc":"Destructor for `Fix F` ","depth":18},{"term":"fun {n} P {α} => MvPFunctor.M.corec P fun i => MvFunctor.map (TypeVec.id ::: MvPFunctor.M.dest P) i","name":"MvPFunctor.M.mk","doc":"Constructor for M-types ","depth":19},{"term":"fun {n} {F} [MvFunctor F] [MvQPF F] {α} =>\n  MvQPF.Cofix.corec fun x => MvFunctor.map (TypeVec.id ::: fun i => MvQPF.Cofix.dest i) x","name":"MvQPF.Cofix.mk","doc":"constructor for `Cofix F` ","depth":20},{"term":"fun {n} {F} [MvFunctor F] [MvQPF F] {α} x =>\n  Quot.mk Setoid.r (MvPFunctor.wMk' (MvQPF.P F) (MvFunctor.map (TypeVec.id ::: MvQPF.fixToW) (MvQPF.repr x)))","name":"MvQPF.Fix.mk","doc":"Constructor for `Fix F` ","depth":25},{"term":"fun {n} {F} [MvFunctor F] [MvQPF F] {α} =>\n  Quot.lift (fun x => MvFunctor.map (TypeVec.id ::: Quot.mk MvQPF.Mcongr) (MvQPF.abs (MvPFunctor.M.dest (MvQPF.P F) x)))\n    (_ :\n      ∀ (x y : MvPFunctor.M (MvQPF.P F) α),\n        MvQPF.Mcongr x y →\n          (fun x => MvFunctor.map (TypeVec.id ::: Quot.mk MvQPF.Mcongr) (MvQPF.abs (MvPFunctor.M.dest (MvQPF.P F) x)))\n              x =\n            (fun x => MvFunctor.map (TypeVec.id ::: Quot.mk MvQPF.Mcongr) (MvQPF.abs (MvPFunctor.M.dest (MvQPF.P F) x)))\n              y)","name":"MvQPF.Cofix.dest","doc":"Destructor for `Cofix F` ","depth":26}],"count":22}
{"noDocExamples":[],"kind":"Function.«term_↪_»","examples":[{"term":"fun {σ} => Classical.choice (_ : Nonempty (σ ↪ Cardinal.{u}))","name":"embeddingToCardinal","doc":"An embedding of any type to the set of cardinals. ","depth":5},{"term":"{ le := fun q₁ q₂ => Quotient.liftOn₂ q₁ q₂ (fun α β => Nonempty (α ↪ β)) Cardinal.instLECardinal.proof_1 }","name":"Cardinal.instLECardinal","doc":"We define the order on cardinal numbers by `#α ≤ #β` if and only if\nthere exists an embedding (injective function) from α to β. ","depth":12},{"term":"fun {V} G {α} {β} [Fintype α] [Fintype β] hn => SimpleGraph.recolorOfEmbedding G (Nonempty.some (_ : Nonempty (α ↪ β)))","name":"SimpleGraph.recolorOfCardLE","doc":"There is a noncomputable embedding of `α`-colorings to `β`-colorings if\n`β` has at least as large a cardinality as `α`. ","depth":14},{"term":"fun α β =>\n  { toFun := fun f => { toFun := ↑f, inj' := (_ : Function.Injective ↑f) },\n    invFun := fun f => { val := ↑f, property := (_ : Function.Injective ↑f) },\n    left_inv :=\n      (_ :\n        ∀ (x : { f // Function.Injective f }),\n          (fun f => { val := ↑f, property := (_ : Function.Injective ↑f) })\n              ((fun f => { toFun := ↑f, inj' := (_ : Function.Injective ↑f) }) x) =\n            (fun f => { val := ↑f, property := (_ : Function.Injective ↑f) })\n              ((fun f => { toFun := ↑f, inj' := (_ : Function.Injective ↑f) }) x)),\n    right_inv :=\n      (_ :\n        ∀ (x : α ↪ β),\n          (fun f => { toFun := ↑f, inj' := (_ : Function.Injective ↑f) })\n              ((fun f => { val := ↑f, property := (_ : Function.Injective ↑f) }) x) =\n            (fun f => { toFun := ↑f, inj' := (_ : Function.Injective ↑f) })\n              ((fun f => { val := ↑f, property := (_ : Function.Injective ↑f) }) x)) }","name":"Equiv.subtypeInjectiveEquivEmbedding","doc":"The type of embeddings `α ↪ β` is equivalent to\nthe subtype of all injective functions `α → β`. ","depth":16},{"term":"fun {α} {β} [Unique α] =>\n  { toFun := fun f => ↑f default,\n    invFun := fun x =>\n      { toFun := fun x_1 => x, inj' := (_ : ∀ (x_1 x_2 : α), (fun x_3 => x) x_1 = (fun x_3 => x) x_2 → x_1 = x_2) },\n    left_inv :=\n      (_ :\n        ∀ (x : α ↪ β),\n          (fun x =>\n                { toFun := fun x_1 => x,\n                  inj' := (_ : ∀ (x_1 x_2 : α), (fun x_3 => x) x_1 = (fun x_3 => x) x_2 → x_1 = x_2) })\n              ((fun f => ↑f default) x) =\n            x),\n    right_inv := (_ : ∀ (x : β), x = x) }","name":"Equiv.uniqueEmbeddingEquivResult","doc":"Embeddings from a single-member type are equivalent to members of the target type. ","depth":17}],"count":21}
{"noDocExamples":[{"term":"fun {α} [Lattice α] [Group α] a =>\n  Eq.mpr (id (LatticeOrderedGroup.neg_eq_pos_inv a⁻¹ ▸ Eq.refl (a⁺ = a⁻¹⁻)))\n    (Eq.mpr (id (inv_inv a ▸ Eq.refl (a⁺ = a⁻¹⁻¹⁺))) (Eq.refl a⁺))","name":"LatticeOrderedGroup.pos_eq_neg_inv","depth":25},{"term":"fun {α} [Lattice α] [AddGroup α] a =>\n  Eq.mpr (id (LatticeOrderedGroup.neg_eq_pos_neg (-a) ▸ Eq.refl (a⁺ = (-a)⁻)))\n    (Eq.mpr (id (neg_neg a ▸ Eq.refl (a⁺ = (- -a)⁺))) (Eq.refl a⁺))","name":"LatticeOrderedGroup.pos_eq_neg_neg","depth":25},{"term":"fun {α} [Lattice α] [AddGroup α] {a} =>\n  Eq.mpr (id (LatticeOrderedGroup.pos_part_def a ▸ Eq.refl (a⁺ ≤ 0 ↔ a ≤ 0)))\n    (Eq.mpr (id (propext sup_le_iff ▸ Eq.refl (a ⊔ 0 ≤ 0 ↔ a ≤ 0)))\n      (Eq.mpr (id (propext (and_iff_left le_rfl) ▸ Eq.refl (a ≤ 0 ∧ 0 ≤ 0 ↔ a ≤ 0))) Iff.rfl))","name":"LatticeOrderedGroup.pos_nonpos_iff","depth":28}],"kind":"«term_⁺»","examples":[{"term":"fun {α} [Lattice α] [Group α] a h =>\n  Eq.mpr (id (LatticeOrderedGroup.m_pos_part_def a ▸ Eq.refl (a⁺ = a))) (sup_of_le_left h)","name":"LatticeOrderedGroup.pos_of_one_le","doc":"If `a` is positive, then it is equal to its positive component `a⁺`. ","depth":22},{"term":"fun {α} [Lattice α] [AddGroup α] a h =>\n  Eq.mpr (id (LatticeOrderedGroup.pos_part_def a ▸ Eq.refl (a⁺ = a))) (sup_of_le_left h)","name":"LatticeOrderedGroup.pos_of_nonneg","doc":"If `a` is positive, then it is equal to its positive component `a⁺`.","depth":22}],"count":19}
{"noDocExamples":[{"term":"fun {β} {M} {α} [SMul M α] [Zero β] => SMulZeroClass.mk (_ : ∀ (x : Mᵈᵐᵃ), x • 0 = x • 0)","name":"DomMulAct.instSMulZeroClassDomMulActForAllInstZero","depth":11},{"term":"fun {M} {α} {A} [SMul M α] [AddZeroClass A] =>\n  DistribSMul.mk (_ : ∀ (x : Mᵈᵐᵃ) (x_1 x_2 : α → A), x • (x_1 + x_2) = x • (x_1 + x_2))","name":"DomMulAct.instDistribSMulDomMulActForAllAddZeroClass","depth":12},{"term":"fun {β} {M} {α} [Monoid M] [MulAction M α] =>\n  MulAction.mk (_ : ∀ (f : α → β), 1 • f = f) (_ : ∀ (x x_1 : Mᵈᵐᵃ) (f : α → β), (x * x_1) • f = x • x_1 • f)","name":"DomMulAct.instMulActionDomMulActForAllInstMonoidDomMulActMonoid","depth":13},{"term":"fun {M} {α} {A} [Monoid M] [MulAction M α] [AddMonoid A] =>\n  DistribMulAction.mk (_ : ∀ (x : Mᵈᵐᵃ), x • 0 = x • 0)\n    (_ : ∀ (x : Mᵈᵐᵃ) (x_1 x_2 : α → A), x • (x_1 + x_2) = x • (x_1 + x_2))","name":"DomMulAct.instDistribMulActionDomMulActForAllInstMonoidDomMulActMonoidAddMonoid","depth":14},{"term":"fun {M} {A} {B} [Monoid M] [AddMonoid A] [DistribMulAction M A] [AddCommMonoid B] =>\n  Function.Injective.distribMulAction (AddMonoidHom.coeFn A B) (_ : Function.Injective fun f => ↑f)\n    (_ : ∀ (x : Mᵈᵐᵃ) (x_1 : A →+ B), ↑(AddMonoidHom.coeFn A B) (x • x_1) = ↑(AddMonoidHom.coeFn A B) (x • x_1))","name":"DomMulAct.instDistribMulActionDomMulActAddMonoidHomToAddZeroClassToAddZeroClassToAddMonoidInstMonoidDomMulActMonoidToAddMonoidAddCommMonoid","depth":20}],"kind":"«term_ᵈᵐᵃ»","examples":[],"count":19}
{"noDocExamples":[{"term":"fun a b => { val := a.val >>> (USize.modn b System.Platform.numBits).val }","name":"USize.shiftRight","depth":10},{"term":"fun {n} => { shiftRight := fun x y => x >>> Bitvec.toNat y }","name":"instShiftRightBitvec","depth":11}],"kind":"«term_>>>_»","examples":[{"term":"fun m n => Nat.bodd (m >>> n)","name":"Nat.testBit","doc":"`testBit m n` returns whether the `(n+1)ˢᵗ` least significant bit is `1` or `0`","depth":9},{"term":"fun m e =>\n  let s := Nat.log2 m - 63;\n  let m := Nat.toUInt64 (m >>> s);\n  let e := e + Int.ofNat s;\n  Float.scaleB (UInt64.toFloat m) e","name":"Float.ofBinaryScientific","doc":"Computes `m * 2^e`. ","depth":11},{"term":"fun x x_1 =>\n  match x, x_1 with\n  | Int.ofNat m, Int.ofNat n => ↑(Nat.shiftLeft' false m n)\n  | Int.ofNat m, Int.negSucc n => ↑(m >>> Nat.succ n)\n  | Int.negSucc m, Int.ofNat n => Int.negSucc (Nat.shiftLeft' true m n)\n  | Int.negSucc m, Int.negSucc n => Int.negSucc (m >>> Nat.succ n)","name":"Int.shiftl","doc":"`shiftl m n` produces an integer whose binary representation\nis obtained by left-shifting the binary representation of `m` by `n` places ","depth":14}],"count":19}
{"noDocExamples":[],"kind":"CategoryTheory.ExactPairing.termη_","examples":[{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X Y Y'}\n    [CategoryTheory.ExactPairing X Y'] i =>\n  CategoryTheory.ExactPairing.mk\n    (CategoryTheory.CategoryStruct.comp (η_ X Y')\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) i.inv))\n    (CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom i.hom (CategoryTheory.CategoryStruct.id X)) (ε_ X Y'))","name":"CategoryTheory.exactPairingCongrRight","doc":"Transport an exact pairing across an isomorphism in the second argument. ","depth":22},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X X' Y}\n    [CategoryTheory.ExactPairing X' Y] i =>\n  CategoryTheory.ExactPairing.mk\n    (CategoryTheory.CategoryStruct.comp (η_ X' Y)\n      (CategoryTheory.MonoidalCategory.tensorHom i.inv (CategoryTheory.CategoryStruct.id Y)))\n    (CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) i.hom) (ε_ X' Y))","name":"CategoryTheory.exactPairingCongrLeft","doc":"Transport an exact pairing across an isomorphism in the first argument. ","depth":22},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X Y} [CategoryTheory.HasLeftDual X]\n    [CategoryTheory.HasLeftDual Y] f =>\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor ᘁY).inv\n    (CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (η_ (ᘁX) X) (CategoryTheory.CategoryStruct.id ᘁY))\n      (CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.MonoidalCategory.tensorHom\n          (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id ᘁX) f)\n          (CategoryTheory.CategoryStruct.id ᘁY))\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator (ᘁX) Y ᘁY).hom\n          (CategoryTheory.CategoryStruct.comp\n            (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id ᘁX) (ε_ (ᘁY) Y))\n            (CategoryTheory.MonoidalCategory.rightUnitor ᘁX).hom))))","name":"CategoryTheory.leftAdjointMate","doc":"The left adjoint mate `ᘁf : ᘁY ⟶ ᘁX` of a morphism `f : X ⟶ Y`. ","depth":25},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] X Y Y' Z\n    [CategoryTheory.ExactPairing Y Y'] =>\n  {\n    toFun := fun f =>\n      CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor X).inv\n        (CategoryTheory.CategoryStruct.comp\n          (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (η_ Y Y'))\n          (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y Y').inv\n            (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Y')))),\n    invFun := fun f =>\n      CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Y))\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Z Y' Y).hom\n          (CategoryTheory.CategoryStruct.comp\n            (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Z) (ε_ Y Y'))\n            (CategoryTheory.MonoidalCategory.rightUnitor Z).hom)),\n    left_inv :=\n      (_ :\n        ∀ (f : CategoryTheory.MonoidalCategory.tensorObj X Y ⟶ Z),\n          (fun f =>\n                CategoryTheory.CategoryStruct.comp\n                  (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Y))\n                  (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Z Y' Y).hom\n                    (CategoryTheory.CategoryStruct.comp\n                      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Z) (ε_ Y Y'))\n                      (CategoryTheory.MonoidalCategory.rightUnitor Z).hom)))\n              ((fun f =>\n                  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor X).inv\n                    (CategoryTheory.CategoryStruct.comp\n                      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (η_ Y Y'))\n                      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y Y').inv\n                        (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Y')))))\n                f) =\n            f),\n    right_inv :=\n      (_ :\n        ∀ (f : X ⟶ CategoryTheory.MonoidalCategory.tensorObj Z Y'),\n          (fun f =>\n                CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor X).inv\n                  (CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (η_ Y Y'))\n                    (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y Y').inv\n                      (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Y')))))\n              ((fun f =>\n                  CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Y))\n                    (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Z Y' Y).hom\n                      (CategoryTheory.CategoryStruct.comp\n                        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Z) (ε_ Y Y'))\n                        (CategoryTheory.MonoidalCategory.rightUnitor Z).hom)))\n                f) =\n            f) }","name":"CategoryTheory.tensorRightHomEquiv","doc":"Given an exact pairing on `Y Y'`,\nwe get a bijection on hom-sets `(X ⊗ Y ⟶ Z) ≃ (X ⟶ Z ⊗ Y')`\nby \"pulling the string on the right\" up or down.\n","depth":27},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] X Y Y' Z\n    [CategoryTheory.ExactPairing Y Y'] =>\n  {\n    toFun := fun f =>\n      CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).inv\n        (CategoryTheory.CategoryStruct.comp\n          (CategoryTheory.MonoidalCategory.tensorHom (η_ Y Y') (CategoryTheory.CategoryStruct.id X))\n          (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y Y' X).hom\n            (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) f))),\n    invFun := fun f =>\n      CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y') f)\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y' Y Z).inv\n          (CategoryTheory.CategoryStruct.comp\n            (CategoryTheory.MonoidalCategory.tensorHom (ε_ Y Y') (CategoryTheory.CategoryStruct.id Z))\n            (CategoryTheory.MonoidalCategory.leftUnitor Z).hom)),\n    left_inv :=\n      (_ :\n        ∀ (f : CategoryTheory.MonoidalCategory.tensorObj Y' X ⟶ Z),\n          (fun f =>\n                CategoryTheory.CategoryStruct.comp\n                  (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y') f)\n                  (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y' Y Z).inv\n                    (CategoryTheory.CategoryStruct.comp\n                      (CategoryTheory.MonoidalCategory.tensorHom (ε_ Y Y') (CategoryTheory.CategoryStruct.id Z))\n                      (CategoryTheory.MonoidalCategory.leftUnitor Z).hom)))\n              ((fun f =>\n                  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).inv\n                    (CategoryTheory.CategoryStruct.comp\n                      (CategoryTheory.MonoidalCategory.tensorHom (η_ Y Y') (CategoryTheory.CategoryStruct.id X))\n                      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y Y' X).hom\n                        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) f))))\n                f) =\n            f),\n    right_inv :=\n      (_ :\n        ∀ (f : X ⟶ CategoryTheory.MonoidalCategory.tensorObj Y Z),\n          (fun f =>\n                CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).inv\n                  (CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.MonoidalCategory.tensorHom (η_ Y Y') (CategoryTheory.CategoryStruct.id X))\n                    (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y Y' X).hom\n                      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) f))))\n              ((fun f =>\n                  CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y') f)\n                    (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y' Y Z).inv\n                      (CategoryTheory.CategoryStruct.comp\n                        (CategoryTheory.MonoidalCategory.tensorHom (ε_ Y Y') (CategoryTheory.CategoryStruct.id Z))\n                        (CategoryTheory.MonoidalCategory.leftUnitor Z).hom)))\n                f) =\n            f) }","name":"CategoryTheory.tensorLeftHomEquiv","doc":"Given an exact pairing on `Y Y'`,\nwe get a bijection on hom-sets `(Y' ⊗ X ⟶ Z) ≃ (X ⟶ Y ⊗ Z)`\nby \"pulling the string on the left\" up or down.\n\nThis gives the adjunction `tensorLeftAdjunction Y Y' : tensorLeft Y' ⊣ tensorLeft Y`.\n\nThis adjunction is often referred to as \"Frobenius reciprocity\" in the\nfusion categories / planar algebras / subfactors literature.\n","depth":27}],"count":18}
{"noDocExamples":[{"term":"fun {α} [DecidableEq α] l l' =>\n  decidable_of_iff' (l' ∈ List.map (List.rotate l) (List.range (List.length l + 1)))\n    (_ : l ~r l' ↔ l' ∈ List.map (List.rotate l) (List.range (List.length l + 1)))","name":"List.isRotatedDecidable","depth":17},{"term":"fun {α} {l l'} =>\n  of_eq_true\n    (Eq.trans\n      (congrFun\n        (congrArg Iff\n          (Eq.trans Mathlib.Data.List.Rotate._auxLemma.18 (congrArg (List.IsRotated l) (List.reverse_reverse l'))))\n        (l ~r l'))\n      (iff_self (l ~r l')))","name":"List.isRotated_reverse_iff","depth":18}],"kind":"List.«term_~r_»","examples":[{"term":"fun {α} s => Quot.map List.reverse (_ : ∀ (x x_1 : List α), x ~r x_1 → List.reverse x ~r List.reverse x_1) s","name":"Cycle.reverse","doc":"Reverse a `s : Cycle α` by reversing the underlying `List`. ","depth":12},{"term":"fun {α} [DecidableEq α] s =>\n  Quotient.hrecOn (motive := fun x => Cycle.Nodup x → Equiv.Perm α) s (fun l x => List.formPerm l)\n    (_ : ∀ (l₁ l₂ : List α), l₁ ~r l₂ → HEq (fun x => List.formPerm l₁) fun x => List.formPerm l₂)","name":"Cycle.formPerm","doc":"A cycle `s : Cycle α`, given `Nodup s` can be interpreted as an `Equiv.Perm α`\nwhere each element in the list is permuted to the next one, defined as `formPerm`.\n","depth":13},{"term":"fun {α} {β} f => Quotient.map' (List.map f) (_ : ∀ (x x_1 : List α), Setoid.r x x_1 → List.map f x ~r List.map f x_1)","name":"Cycle.map","doc":"The lift of `list.map`. ","depth":13}],"count":18}
{"noDocExamples":[],"kind":"CategoryTheory.ExactPairing.termε_","examples":[{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X Y Y'}\n    [CategoryTheory.ExactPairing X Y'] i =>\n  CategoryTheory.ExactPairing.mk\n    (CategoryTheory.CategoryStruct.comp (η_ X Y')\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) i.inv))\n    (CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom i.hom (CategoryTheory.CategoryStruct.id X)) (ε_ X Y'))","name":"CategoryTheory.exactPairingCongrRight","doc":"Transport an exact pairing across an isomorphism in the second argument. ","depth":22},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X X' Y}\n    [CategoryTheory.ExactPairing X' Y] i =>\n  CategoryTheory.ExactPairing.mk\n    (CategoryTheory.CategoryStruct.comp (η_ X' Y)\n      (CategoryTheory.MonoidalCategory.tensorHom i.inv (CategoryTheory.CategoryStruct.id Y)))\n    (CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) i.hom) (ε_ X' Y))","name":"CategoryTheory.exactPairingCongrLeft","doc":"Transport an exact pairing across an isomorphism in the first argument. ","depth":22},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X Y} [CategoryTheory.HasLeftDual X]\n    [CategoryTheory.HasLeftDual Y] f =>\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor ᘁY).inv\n    (CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (η_ (ᘁX) X) (CategoryTheory.CategoryStruct.id ᘁY))\n      (CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.MonoidalCategory.tensorHom\n          (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id ᘁX) f)\n          (CategoryTheory.CategoryStruct.id ᘁY))\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator (ᘁX) Y ᘁY).hom\n          (CategoryTheory.CategoryStruct.comp\n            (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id ᘁX) (ε_ (ᘁY) Y))\n            (CategoryTheory.MonoidalCategory.rightUnitor ᘁX).hom))))","name":"CategoryTheory.leftAdjointMate","doc":"The left adjoint mate `ᘁf : ᘁY ⟶ ᘁX` of a morphism `f : X ⟶ Y`. ","depth":25},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] X Y Y' Z\n    [CategoryTheory.ExactPairing Y Y'] =>\n  {\n    toFun := fun f =>\n      CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor X).inv\n        (CategoryTheory.CategoryStruct.comp\n          (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (η_ Y Y'))\n          (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y Y').inv\n            (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Y')))),\n    invFun := fun f =>\n      CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Y))\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Z Y' Y).hom\n          (CategoryTheory.CategoryStruct.comp\n            (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Z) (ε_ Y Y'))\n            (CategoryTheory.MonoidalCategory.rightUnitor Z).hom)),\n    left_inv :=\n      (_ :\n        ∀ (f : CategoryTheory.MonoidalCategory.tensorObj X Y ⟶ Z),\n          (fun f =>\n                CategoryTheory.CategoryStruct.comp\n                  (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Y))\n                  (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Z Y' Y).hom\n                    (CategoryTheory.CategoryStruct.comp\n                      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Z) (ε_ Y Y'))\n                      (CategoryTheory.MonoidalCategory.rightUnitor Z).hom)))\n              ((fun f =>\n                  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor X).inv\n                    (CategoryTheory.CategoryStruct.comp\n                      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (η_ Y Y'))\n                      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y Y').inv\n                        (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Y')))))\n                f) =\n            f),\n    right_inv :=\n      (_ :\n        ∀ (f : X ⟶ CategoryTheory.MonoidalCategory.tensorObj Z Y'),\n          (fun f =>\n                CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor X).inv\n                  (CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (η_ Y Y'))\n                    (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y Y').inv\n                      (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Y')))))\n              ((fun f =>\n                  CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Y))\n                    (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Z Y' Y).hom\n                      (CategoryTheory.CategoryStruct.comp\n                        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Z) (ε_ Y Y'))\n                        (CategoryTheory.MonoidalCategory.rightUnitor Z).hom)))\n                f) =\n            f) }","name":"CategoryTheory.tensorRightHomEquiv","doc":"Given an exact pairing on `Y Y'`,\nwe get a bijection on hom-sets `(X ⊗ Y ⟶ Z) ≃ (X ⟶ Z ⊗ Y')`\nby \"pulling the string on the right\" up or down.\n","depth":27},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] X Y Y' Z\n    [CategoryTheory.ExactPairing Y Y'] =>\n  {\n    toFun := fun f =>\n      CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).inv\n        (CategoryTheory.CategoryStruct.comp\n          (CategoryTheory.MonoidalCategory.tensorHom (η_ Y Y') (CategoryTheory.CategoryStruct.id X))\n          (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y Y' X).hom\n            (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) f))),\n    invFun := fun f =>\n      CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y') f)\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y' Y Z).inv\n          (CategoryTheory.CategoryStruct.comp\n            (CategoryTheory.MonoidalCategory.tensorHom (ε_ Y Y') (CategoryTheory.CategoryStruct.id Z))\n            (CategoryTheory.MonoidalCategory.leftUnitor Z).hom)),\n    left_inv :=\n      (_ :\n        ∀ (f : CategoryTheory.MonoidalCategory.tensorObj Y' X ⟶ Z),\n          (fun f =>\n                CategoryTheory.CategoryStruct.comp\n                  (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y') f)\n                  (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y' Y Z).inv\n                    (CategoryTheory.CategoryStruct.comp\n                      (CategoryTheory.MonoidalCategory.tensorHom (ε_ Y Y') (CategoryTheory.CategoryStruct.id Z))\n                      (CategoryTheory.MonoidalCategory.leftUnitor Z).hom)))\n              ((fun f =>\n                  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).inv\n                    (CategoryTheory.CategoryStruct.comp\n                      (CategoryTheory.MonoidalCategory.tensorHom (η_ Y Y') (CategoryTheory.CategoryStruct.id X))\n                      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y Y' X).hom\n                        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) f))))\n                f) =\n            f),\n    right_inv :=\n      (_ :\n        ∀ (f : X ⟶ CategoryTheory.MonoidalCategory.tensorObj Y Z),\n          (fun f =>\n                CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).inv\n                  (CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.MonoidalCategory.tensorHom (η_ Y Y') (CategoryTheory.CategoryStruct.id X))\n                    (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y Y' X).hom\n                      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) f))))\n              ((fun f =>\n                  CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y') f)\n                    (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y' Y Z).inv\n                      (CategoryTheory.CategoryStruct.comp\n                        (CategoryTheory.MonoidalCategory.tensorHom (ε_ Y Y') (CategoryTheory.CategoryStruct.id Z))\n                        (CategoryTheory.MonoidalCategory.leftUnitor Z).hom)))\n                f) =\n            f) }","name":"CategoryTheory.tensorLeftHomEquiv","doc":"Given an exact pairing on `Y Y'`,\nwe get a bijection on hom-sets `(Y' ⊗ X ⟶ Z) ≃ (X ⟶ Y ⊗ Z)`\nby \"pulling the string on the left\" up or down.\n\nThis gives the adjunction `tensorLeftAdjunction Y Y' : tensorLeft Y' ⊣ tensorLeft Y`.\n\nThis adjunction is often referred to as \"Frobenius reciprocity\" in the\nfusion categories / planar algebras / subfactors literature.\n","depth":27}],"count":18}
{"noDocExamples":[],"kind":"«term_/ₚ_»","examples":[{"term":"fun {R} [Ring R] u => PowerSeries.mk fun n => 1 /ₚ u ^ (n + 1)","name":"PowerSeries.invUnitsSub","doc":"The power series for `1 / (u - x)`. ","depth":19},{"term":"fun {R} [CommRing R] h =>\n  RingHom.toAlgebra\n    {\n      toMonoidHom :=\n        { toOneHom := { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) },\n          map_mul' :=\n            (_ :\n              ∀ (a b : ℚ),\n                OneHom.toFun { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) } (a * b) =\n                  OneHom.toFun { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) } a *\n                    OneHom.toFun { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) } b) },\n      map_zero' := (_ : ↑0 * ↑(↑1)⁻¹ = 0),\n      map_add' :=\n        (_ :\n          ∀ (a b : ℚ),\n            OneHom.toFun\n                (↑{ toOneHom := { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) },\n                    map_mul' :=\n                      (_ :\n                        ∀ (a b : ℚ),\n                          OneHom.toFun { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) }\n                              (a * b) =\n                            OneHom.toFun\n                                { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) } a *\n                              OneHom.toFun\n                                { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) } b) })\n                (a + b) =\n              OneHom.toFun\n                  (↑{ toOneHom := { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) },\n                      map_mul' :=\n                        (_ :\n                          ∀ (a b : ℚ),\n                            OneHom.toFun\n                                { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) }\n                                (a * b) =\n                              OneHom.toFun\n                                  { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) } a *\n                                OneHom.toFun\n                                  { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) } b) })\n                  a +\n                OneHom.toFun\n                  (↑{ toOneHom := { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) },\n                      map_mul' :=\n                        (_ :\n                          ∀ (a b : ℚ),\n                            OneHom.toFun\n                                { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) }\n                                (a * b) =\n                              OneHom.toFun\n                                  { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) } a *\n                                OneHom.toFun\n                                  { toFun := fun x => ↑x.num /ₚ ↑(Rat.pnatDen x), map_one' := (_ : ↑1 /ₚ ↑1 = 1) } b) })\n                  b) }","name":"EqualCharZero.algebraRat","doc":"Equal characteristic implies `ℚ`-algebra. ","depth":20},{"term":"fun {α} [Monoid α] u => Eq.mpr (id (one_divp u ▸ Eq.refl (↑u⁻¹ = 1 /ₚ u))) (Eq.refl ↑u⁻¹)","name":"inv_eq_one_divp","doc":"Used for `field_simp` to deal with inverses of units. ","depth":21},{"term":"fun {α} [Monoid α] u =>\n  Eq.mpr (id (one_div u ▸ Eq.refl (↑(1 / u) = 1 /ₚ u)))\n    (Eq.mpr (id (one_divp u ▸ Eq.refl (↑u⁻¹ = 1 /ₚ u))) (Eq.refl ↑u⁻¹))","name":"inv_eq_one_divp'","doc":"Used for `field_simp` to deal with inverses of units. This form of the lemma\nis essential since `field_simp` likes to use `inv_eq_one_div` to rewrite\n`↑u⁻¹ = ↑(1 / u)`.\n","depth":27},{"term":"fun {α} [Monoid α] u₁ u₂ =>\n  Eq.mpr (id (divp._eq_1 (↑u₁) u₂ ▸ Eq.refl (↑(u₁ / u₂) = ↑u₁ /ₚ u₂)))\n    (Eq.mpr (id (division_def u₁ u₂ ▸ Eq.refl (↑(u₁ / u₂) = ↑u₁ * ↑u₂⁻¹)))\n      (Eq.mpr (id (Units.val_mul u₁ u₂⁻¹ ▸ Eq.refl (↑(u₁ * u₂⁻¹) = ↑u₁ * ↑u₂⁻¹))) (Eq.refl (↑u₁ * ↑u₂⁻¹))))","name":"val_div_eq_divp","doc":"`field_simp` moves division inside `αˣ` to the right, and this lemma\nlifts the calculation to `α`.\n","depth":30}],"count":17}
{"noDocExamples":[],"kind":"TypeVec.«term_:::_»","examples":[{"term":"fun {n} F α β => F (β ::: α)","name":"TypeVec.Curry","doc":"given `F : TypeVec.{u} (n+1) → Type u`, `curry F : Type u → TypeVec.{u} → Type u`,\ni.e. its first argument can be fed in separately from the rest of the vector of arguments ","depth":10},{"term":"fun {n} {C} H γ => Eq.mpr (_ : C γ = C (TypeVec.drop γ ::: TypeVec.last γ)) (H (TypeVec.drop γ) (TypeVec.last γ))","name":"TypeVec.append1Cases","doc":"cases on `(n+1)-length` vectors ","depth":12},{"term":"fun {n} {α} => TypeVec.Arrow.mp (_ : TypeVec.drop α ::: TypeVec.last α = α)","name":"TypeVec.fromAppend1DropLast","doc":"stitch two bits of a vector back together ","depth":12},{"term":"fun {n} {α} => TypeVec.Arrow.mpr (_ : TypeVec.drop α ::: TypeVec.last α = α)","name":"TypeVec.toAppend1DropLast","doc":"decompose a vector into its prefix appended with its last element ","depth":12},{"term":"fun n {β} f v => cast (_ : β (TypeVec.drop v ::: TypeVec.last v) = β v) (f (TypeVec.last v) (TypeVec.drop v))","name":"TypeVec.casesCons","doc":"cases distinction for (n+1)-length type vector ","depth":13}],"count":16}
{"noDocExamples":[{"term":"fun {α} [GeneralizedHeytingAlgebra α] a =>\n  Eq.mpr (id (bihimp_comm ⊤ a ▸ Eq.refl (⊤ ⇔ a = a))) (Eq.mpr (id (bihimp_top a ▸ Eq.refl (a ⇔ ⊤ = a))) (Eq.refl a))","name":"top_bihimp","depth":23},{"term":"fun {α} [GeneralizedHeytingAlgebra α] a =>\n  Eq.mpr (id (bihimp._eq_1 a a ▸ Eq.refl (a ⇔ a = ⊤)))\n    (Eq.mpr (id (inf_idem ▸ Eq.refl ((a ⇨ a) ⊓ (a ⇨ a) = ⊤)))\n      (Eq.mpr (id (himp_self ▸ Eq.refl (a ⇨ a = ⊤))) (Eq.refl ⊤)))","name":"bihimp_self","depth":23},{"term":"fun {α} [GeneralizedHeytingAlgebra α] a =>\n  Eq.mpr (id (bihimp._eq_1 a ⊤ ▸ Eq.refl (a ⇔ ⊤ = a)))\n    (Eq.mpr (id (himp_top ▸ Eq.refl ((⊤ ⇨ a) ⊓ (a ⇨ ⊤) = a)))\n      (Eq.mpr (id (top_himp ▸ Eq.refl ((⊤ ⇨ a) ⊓ ⊤ = a))) (Eq.mpr (id (inf_top_eq ▸ Eq.refl (a ⊓ ⊤ = a))) (Eq.refl a))))","name":"bihimp_top","depth":24},{"term":"fun {α} [GeneralizedHeytingAlgebra α] {a b} h =>\n  Eq.mpr (id (bihimp._eq_1 a b ▸ Eq.refl (a ⇔ b = b ⇨ a)))\n    (Eq.mpr (id (Iff.mpr himp_eq_top_iff h ▸ Eq.refl ((b ⇨ a) ⊓ (a ⇨ b) = b ⇨ a)))\n      (Eq.mpr (id (inf_top_eq ▸ Eq.refl ((b ⇨ a) ⊓ ⊤ = b ⇨ a))) (Eq.refl (b ⇨ a))))","name":"bihimp_of_le","depth":26},{"term":"fun {α} [GeneralizedHeytingAlgebra α] {a b} h =>\n  Eq.mpr (id (bihimp._eq_1 a b ▸ Eq.refl (a ⇔ b = a ⇨ b)))\n    (Eq.mpr (id (Iff.mpr himp_eq_top_iff h ▸ Eq.refl ((b ⇨ a) ⊓ (a ⇨ b) = a ⇨ b)))\n      (Eq.mpr (id (top_inf_eq ▸ Eq.refl (⊤ ⊓ (a ⇨ b) = a ⇨ b))) (Eq.refl (a ⇨ b))))","name":"bihimp_of_ge","depth":26}],"kind":"«term_⇔_»","examples":[],"count":16}
{"noDocExamples":[{"term":"fun {α} {E} {m0} [NormedAddCommGroup E] [NormedSpace ℝ E] μ =>\n  Eq.mpr (id ((MeasureTheory.average._eq_1 μ fun x => 0) ▸ Eq.refl (⨍ (x : α), 0 ∂μ = 0)))\n    (Eq.mpr (id (MeasureTheory.integral_zero α E ▸ Eq.refl (∫ (x : α), 0 ∂(↑↑μ Set.univ)⁻¹ • μ = 0))) (Eq.refl 0))","name":"MeasureTheory.average_zero","depth":34}],"kind":"MeasureTheory.«term⨍_,_∂_»","examples":[{"term":"fun {α} {m0} {μ} {f} [MeasureTheory.IsFiniteMeasure μ] hμ hf =>\n  Eq.mp\n    (congrArg (LT.lt 0)\n      (congrArg (↑↑μ)\n        (congrArg setOf\n          (funext fun x =>\n            Eq.trans\n              (congr (congrArg And (Mathlib.Data.Set.Basic._auxLemma.14 x))\n                (congrArg (LE.le (f x))\n                  (congrFun (congrArg MeasureTheory.average MeasureTheory.Measure.restrict_univ) fun a => f a)))\n              (true_and (f x ≤ ⨍ (a : α), f a ∂μ))))))\n    (MeasureTheory.measure_le_setAverage_pos (Iff.mpr MeasureTheory.Measure.measure_univ_ne_zero hμ)\n      (MeasureTheory.measure_ne_top μ Set.univ) (MeasureTheory.Integrable.integrableOn hf))","name":"MeasureTheory.measure_le_average_pos","doc":"**First moment method**. An integrable function is smaller than its mean on a set of positive\nmeasure. ","depth":28},{"term":"fun {α} {m0} {μ} {f} [MeasureTheory.IsFiniteMeasure μ] hμ hf =>\n  Eq.mp\n    (congrArg (LT.lt 0)\n      (congrArg (↑↑μ)\n        (congrArg setOf\n          (funext fun x =>\n            Eq.trans\n              (congr (congrArg And (Mathlib.Data.Set.Basic._auxLemma.14 x))\n                (congrFun\n                  (congrArg LE.le\n                    (congrFun (congrArg MeasureTheory.average MeasureTheory.Measure.restrict_univ) fun a => f a))\n                  (f x)))\n              (true_and (⨍ (a : α), f a ∂μ ≤ f x))))))\n    (MeasureTheory.measure_setAverage_le_pos (Iff.mpr MeasureTheory.Measure.measure_univ_ne_zero hμ)\n      (MeasureTheory.measure_ne_top μ Set.univ) (MeasureTheory.Integrable.integrableOn hf))","name":"MeasureTheory.measure_average_le_pos","doc":"**First moment method**. An integrable function is greater than its mean on a set of positive\nmeasure. ","depth":30},{"term":"fun {α} {m0} {μ} {N} {f} [MeasureTheory.IsFiniteMeasure μ] hμ hf hN =>\n  let_fun this := MeasureTheory.measure_le_average_pos hμ hf;\n  Exists.casesOn\n    (MeasureTheory.nonempty_of_measure_ne_zero\n      (LT.lt.ne'\n        (Eq.mp (Eq.symm (MeasureTheory.measure_diff_null hN) ▸ Eq.refl (0 < ↑↑μ {x | f x ≤ ⨍ (a : α), f a ∂μ})) this)))\n    fun x h => And.casesOn h fun hx hxN => Exists.intro x { left := hxN, right := hx }","name":"MeasureTheory.exists_not_mem_null_le_average","doc":"**First moment method**. The minimum of an integrable function is smaller than its mean, while\navoiding a null set. ","depth":37},{"term":"fun {α} {E} {m0} [NormedAddCommGroup E] [NormedSpace ℝ E] [CompleteSpace E] {μ} {s} {f} {g}\n    [MeasureTheory.IsFiniteMeasure μ] hg hgc hsc hfs hfi hgi =>\n  Eq.mp\n    (congrArg (Or ((fun x => f x) =ᶠ[MeasureTheory.Measure.ae μ] Function.const α (⨍ (x : α), f x ∂μ)))\n      (Eq.trans (congrArg (LT.lt (-g (⨍ (x : α), f x ∂μ))) (MeasureTheory.average_neg μ fun x => g (f x)))\n        Mathlib.Analysis.Convex.Integral._auxLemma.5))\n    (StrictConvexOn.ae_eq_const_or_map_average_lt (StrictConcaveOn.neg hg) (ContinuousOn.neg hgc) hsc hfs hfi\n      (MeasureTheory.Integrable.neg hgi))","name":"StrictConcaveOn.ae_eq_const_or_lt_map_average","doc":"**Jensen's inequality**, strict version: if an integrable function `f : α → E` takes values in a\nconvex closed set `s`, and `g : E → ℝ` is continuous and strictly concave on `s`, then\neither `f` is a.e. equal to its average value, or `⨍ x, g (f x) ∂μ < g (⨍ x, f x ∂μ)`. ","depth":40}],"count":16}
{"noDocExamples":[],"kind":"«term_⁻¹'o_»","examples":[{"term":"fun {σ} => ↑embeddingToCardinal ⁻¹'o fun x x_1 => x < x_1","name":"WellOrderingRel","doc":"Any type can be endowed with a well order, obtained by pulling back the well order over\ncardinals by some embedding. ","depth":11},{"term":"fun {α} {β} f s => { toFun := f, map_rel' := (_ : ∀ {a b : α}, (f ⁻¹'o s) a b → (f ⁻¹'o s) a b) }","name":"RelHom.preimage","doc":"A function is a relation homomorphism from the preimage relation of `s` to `s`. ","depth":12},{"term":"fun o => Quotient.liftOn o (fun w => Ordinal.type (ULift.down ⁻¹'o w.r)) Ordinal.lift.proof_2","name":"Ordinal.lift","doc":"The universe lift operation for ordinals, which embeds `Ordinal.{u}` as\na proper initial segment of `Ordinal.{v}` for `v > u`. For the initial segment version,\nsee `lift.initialSeg`. ","depth":12},{"term":"fun {α} r p => Subtype.val ⁻¹'o r","name":"Subrel","doc":"`Subrel r p` is the inherited relation on a subset. ","depth":12},{"term":"fun α [Fintype α] [Encodable α] => Finset.sort (↑(Encodable.encode' α) ⁻¹'o fun x x_1 => x ≤ x_1) Finset.univ","name":"Encodable.sortedUniv","doc":"The elements of a `Fintype` as a sorted list. ","depth":23}],"count":16}
{"noDocExamples":[],"kind":"«termℤ_[_]»","examples":[{"term":"fun {p} [Fact (Nat.Prime p)] =>\n  PadicInt.toZModHom p PadicInt.zmodRepr (_ : ∀ (x : ℤ_[p]), x - ↑(PadicInt.zmodRepr x) ∈ Ideal.span {↑p})\n    (_ : ∀ (x : ℤ_[p]) (a b : ℕ), x - ↑a ∈ Ideal.span {↑p} → x - ↑b ∈ Ideal.span {↑p} → ↑a = ↑b)","name":"PadicInt.toZMod","doc":"`toZMod` is a ring hom from `ℤ_[p]` to `ZMod p`,\nwith the equality `toZMod x = (zmodRepr x : ZMod p)`.\n","depth":8},{"term":"fun {p} [Fact (Nat.Prime p)] n =>\n  PadicInt.toZModHom (p ^ n) (fun x => PadicInt.appr x n)\n    (_ : ∀ (x : ℤ_[p]), x - ↑((fun x => PadicInt.appr x n) x) ∈ Ideal.span {↑(p ^ n)})\n    (_ : ∀ (x : ℤ_[p]) (a b : ℕ), x - ↑a ∈ Ideal.span {↑(p ^ n)} → x - ↑b ∈ Ideal.span {↑(p ^ n)} → ↑a = ↑b)","name":"PadicInt.toZModPow","doc":"A ring hom from `ℤ_[p]` to `ZMod (p^n)`, with underlying function `PadicInt.appr n`. ","depth":13},{"term":"fun {p} [Fact (Nat.Prime p)] x => Classical.choose (_ : ∃ n, n < p ∧ x - ↑n ∈ LocalRing.maximalIdeal ℤ_[p])","name":"PadicInt.zmodRepr","doc":"`zmod_repr x` is the unique natural number smaller than `p`\nsatisfying `‖(x - zmod_repr x : ℤ_[p])‖ < 1`.\n","depth":21},{"term":"fun {p} [Fact (Nat.Prime p)] v f f_spec f_congr =>\n  {\n    toMonoidHom :=\n      { toOneHom := { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) },\n        map_mul' :=\n          (_ :\n            ∀ (x y : ℤ_[p]),\n              OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } (x * y) =\n                OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } x *\n                  OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } y) },\n    map_zero' :=\n      (_ :\n        OneHom.toFun\n            (↑{ toOneHom := { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) },\n                map_mul' :=\n                  (_ :\n                    ∀ (x y : ℤ_[p]),\n                      OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } (x * y) =\n                        OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } x *\n                          OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } y) })\n            0 =\n          0),\n    map_add' :=\n      (_ :\n        ∀ (x y : ℤ_[p]),\n          OneHom.toFun\n              (↑{ toOneHom := { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) },\n                  map_mul' :=\n                    (_ :\n                      ∀ (x y : ℤ_[p]),\n                        OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } (x * y) =\n                          OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } x *\n                            OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } y) })\n              (x + y) =\n            OneHom.toFun\n                (↑{ toOneHom := { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) },\n                    map_mul' :=\n                      (_ :\n                        ∀ (x y : ℤ_[p]),\n                          OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } (x * y) =\n                            OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } x *\n                              OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } y) })\n                x +\n              OneHom.toFun\n                (↑{ toOneHom := { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) },\n                    map_mul' :=\n                      (_ :\n                        ∀ (x y : ℤ_[p]),\n                          OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } (x * y) =\n                            OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } x *\n                              OneHom.toFun { toFun := fun x => ↑(f x), map_one' := (_ : (fun x => ↑(f x)) 1 = 1) } y) })\n                y) }","name":"PadicInt.toZModHom","doc":"`toZModHom` is an auxiliary constructor for creating ring homs from `ℤ_[p]` to `ZMod v`.\n","depth":25},{"term":"fun p [Fact (Nat.Prime p)] =>\n  {\n    toEquiv :=\n      { toFun := ↑(WittVector.toPadicInt p), invFun := ↑(WittVector.fromPadicInt p),\n        left_inv :=\n          (_ :\n            ∀ (x : WittVector p (ZMod p)),\n              ↑(RingHom.comp (WittVector.fromPadicInt p) (WittVector.toPadicInt p)) x =\n                ↑(RingHom.id (WittVector p (ZMod p))) x),\n        right_inv :=\n          (_ :\n            ∀ (x : ℤ_[p]),\n              ↑(RingHom.comp (WittVector.toPadicInt p) (WittVector.fromPadicInt p)) x = ↑(RingHom.id ℤ_[p]) x) },\n    map_mul' :=\n      (_ :\n        ∀ (a b : WittVector p (ZMod p)),\n          ↑(WittVector.toPadicInt p) (a * b) = ↑(WittVector.toPadicInt p) a * ↑(WittVector.toPadicInt p) b),\n    map_add' :=\n      (_ :\n        ∀ (a b : WittVector p (ZMod p)),\n          ↑(WittVector.toPadicInt p) (a + b) = ↑(WittVector.toPadicInt p) a + ↑(WittVector.toPadicInt p) b) }","name":"WittVector.equiv","doc":"The ring of Witt vectors over `ZMod p` is isomorphic to the ring of `p`-adic integers. This\nequivalence is witnessed by `WittVector.toPadicInt` with inverse `WittVector.fromPadicInt`.\n","depth":28}],"count":16}
{"noDocExamples":[{"term":"fun a b => { val := a.val <<< (USize.modn b System.Platform.numBits).val }","name":"USize.shiftLeft","depth":10}],"kind":"«term_<<<_»","examples":[{"term":"fun bs =>\n  if (ByteArray.size bs == 8) = true then\n    UInt8.toUInt64 (ByteArray.get! bs 0) <<< 56 ||| UInt8.toUInt64 (ByteArray.get! bs 1) <<< 48 |||\n                UInt8.toUInt64 (ByteArray.get! bs 2) <<< 40 |||\n              UInt8.toUInt64 (ByteArray.get! bs 3) <<< 32 |||\n            UInt8.toUInt64 (ByteArray.get! bs 4) <<< 24 |||\n          UInt8.toUInt64 (ByteArray.get! bs 5) <<< 16 |||\n        UInt8.toUInt64 (ByteArray.get! bs 6) <<< 8 |||\n      UInt8.toUInt64 (ByteArray.get! bs 7)\n  else\n    panicWithPosWithDecl \"Init.Data.ByteArray.Basic\" \"ByteArray.toUInt64LE!\" 198 2\n      (\"assertion violation: \" ++ \"bs.size == 8\\n  \")","name":"ByteArray.toUInt64LE!","doc":"Interpret a `ByteArray` of size 8 as a little-endian `UInt64`. ","depth":25},{"term":"fun bs =>\n  if (ByteArray.size bs == 8) = true then\n    UInt8.toUInt64 (ByteArray.get! bs 7) <<< 56 ||| UInt8.toUInt64 (ByteArray.get! bs 6) <<< 48 |||\n                UInt8.toUInt64 (ByteArray.get! bs 5) <<< 40 |||\n              UInt8.toUInt64 (ByteArray.get! bs 4) <<< 32 |||\n            UInt8.toUInt64 (ByteArray.get! bs 3) <<< 24 |||\n          UInt8.toUInt64 (ByteArray.get! bs 2) <<< 16 |||\n        UInt8.toUInt64 (ByteArray.get! bs 1) <<< 8 |||\n      UInt8.toUInt64 (ByteArray.get! bs 0)\n  else\n    panicWithPosWithDecl \"Init.Data.ByteArray.Basic\" \"ByteArray.toUInt64BE!\" 210 2\n      (\"assertion violation: \" ++ \"bs.size == 8\\n  \")","name":"ByteArray.toUInt64BE!","doc":"Interpret a `ByteArray` of size 8 as a big-endian `UInt64`. ","depth":25},{"term":"fun {α} =>\n  WellFounded.fix (_ : WellFounded (invImage (fun a => List.length a) instWellFoundedRelation).1) fun a a_1 =>\n    (match (motive :=\n        (x : List α) →\n          ((y : List α) →\n              (invImage (fun a => List.length a) instWellFoundedRelation).1 y x → Ordnode α → ℕ → Ordnode α) →\n            Ordnode α → ℕ → Ordnode α)\n        a with\n      | [] => fun x t x => t\n      | x :: xs => fun x_1 l s =>\n        match Ordnode.ofAscListAux₁ xs s with\n        | (r, { val := ys, property := h }) =>\n          let_fun this := (_ : List.length ys < Nat.succ (List.length xs));\n          x_1 ys (_ : (invImage (fun a => List.length a) instWellFoundedRelation).1 ys (x :: xs)) (Ordnode.link l x r)\n            (s <<< 1))\n      a_1","name":"Ordnode.ofAscListAux₂","doc":"Auxiliary definition for `ofAscList`. ","depth":35},{"term":"fun {α} =>\n  WellFounded.fix (_ : WellFounded (invImage (fun a => List.length a) instWellFoundedRelation).1) fun l a =>\n    (match (motive :=\n        (x : List α) →\n          ((y : List α) →\n              (invImage (fun a => List.length a) instWellFoundedRelation).1 y x →\n                ℕ → Ordnode α × { l' // List.length l' ≤ List.length y }) →\n            ℕ → Ordnode α × { l' // List.length l' ≤ List.length x })\n        l with\n      | [] => fun x x => (Ordnode.nil, { val := [], property := (_ : List.length [] ≤ List.length []) })\n      | x :: xs => fun x_1 s =>\n        if h : s = 1 then\n          (Ordnode.singleton x, { val := xs, property := (_ : List.length xs ≤ Nat.succ (List.length xs)) })\n        else\n          match x_1 xs (_ : List.length (x :: xs) > List.length xs) (s <<< 1) with\n          | (t, { val := [], property := property }) => (t, { val := [], property := (_ : 0 ≤ List.length (x :: xs)) })\n          | (l, { val := y :: ys, property := h }) =>\n            let_fun this := (_ : List.length (y :: ys) ≤ Nat.succ (List.length xs));\n            match x_1 ys (_ : (invImage (fun a => List.length a) instWellFoundedRelation).1 ys (x :: xs)) (s <<< 1) with\n            | (r, { val := zs, property := h' }) =>\n              (Ordnode.link l y r, { val := zs, property := (_ : List.length zs ≤ List.length (x :: xs)) }))\n      a","name":"Ordnode.ofAscListAux₁","doc":"Auxiliary definition for `ofAscList`.\n\n**Note:** This function is defined by well founded recursion, so it will probably not compute\nin the kernel, meaning that you probably can't prove things like\n`ofAscList [1, 2, 3] = {1, 2, 3}` by `rfl`.\nThis implementation is optimized for VM evaluation. ","depth":38}],"count":16}
{"noDocExamples":[],"kind":"«term_×'_»","examples":[{"term":"fun α => (s : α → Prop) ×' ∃ a, (fun b => a = b) = s","name":"Erased","doc":"`Erased α` is the same as `α`, except that the elements\nof `Erased α` are erased in the VM in the same way as types\nand proofs. This can be used to track data without storing it\nliterally. ","depth":11},{"term":"fun {α} [Fintype α] {P} [DecidablePred P] h => truncOfNonemptyFintype ((a : α) ×' P a)","name":"truncSigmaOfExists","doc":"By iterating over the elements of a fintype, we can lift an existential statement `∃ a, P a`\nto `Trunc (Σ' a, P a)`, containing data.\n","depth":11},{"term":"fun {α} β =>\n  { toFun := fun a => { fst := a.fst, snd := a.snd }, invFun := fun a => { fst := a.fst, snd := a.snd },\n    left_inv :=\n      (_ :\n        ∀ (x : (i : α) ×' β i),\n          (fun a => { fst := a.fst, snd := a.snd }) ((fun a => { fst := a.fst, snd := a.snd }) x) =\n            (fun a => { fst := a.fst, snd := a.snd }) ((fun a => { fst := a.fst, snd := a.snd }) x)),\n    right_inv :=\n      (_ :\n        ∀ (x : (i : α) × β i),\n          (fun a => { fst := a.fst, snd := a.snd }) ((fun a => { fst := a.fst, snd := a.snd }) x) =\n            (fun a => { fst := a.fst, snd := a.snd }) ((fun a => { fst := a.fst, snd := a.snd }) x)) }","name":"Equiv.psigmaEquivSigma","doc":"A `PSigma`-type is equivalent to the corresponding `Sigma`-type. ","depth":13},{"term":"fun {α} P =>\n  { toFun := fun x => { val := x.fst, property := (_ : P x.fst) }, invFun := fun x => { fst := ↑x, snd := (_ : P ↑x) },\n    left_inv :=\n      (_ :\n        ∀ (x : (i : α) ×' P i),\n          (fun x => { fst := ↑x, snd := (_ : P ↑x) }) ((fun x => { val := x.fst, property := (_ : P x.fst) }) x) =\n            (fun x => { fst := ↑x, snd := (_ : P ↑x) }) ((fun x => { val := x.fst, property := (_ : P x.fst) }) x)),\n    right_inv :=\n      (_ :\n        ∀ (x : Subtype P),\n          (fun x => { val := x.fst, property := (_ : P x.fst) }) ((fun x => { fst := ↑x, snd := (_ : P ↑x) }) x) =\n            (fun x => { val := x.fst, property := (_ : P x.fst) }) ((fun x => { fst := ↑x, snd := (_ : P ↑x) }) x)) }","name":"Equiv.psigmaEquivSubtype","doc":"A `PSigma` with `Prop` fibers is equivalent to the subtype.  ","depth":13},{"term":"fun R [CommRing R] R' [Field R'] => (n : ℕ+) × (char : AddChar R (CyclotomicField n R')) ×' AddChar.IsPrimitive char","name":"AddChar.PrimitiveAddChar","doc":"Definition for a primitive additive character on a finite ring `R` into a cyclotomic extension\nof a field `R'`. It records which cyclotomic extension it is, the character, and the\nfact that the character is primitive. ","depth":16}],"count":16}
{"noDocExamples":[{"term":"fun {p} [Fact (Nat.Prime p)] => SubringClass.addSubgroupClass (Subring ℚ_[p]) ℚ_[p]","name":"PadicInt.instSubPadicInt.proof_1","depth":11},{"term":"fun {p} [Fact (Nat.Prime p)] => SubringClass.addSubgroupClass (Subring ℚ_[p]) ℚ_[p]","name":"PadicInt.instNegPadicInt.proof_1","depth":11}],"kind":"«termℚ_[_]»","examples":[{"term":"fun {p} [Fact (Nat.Prime p)] =>\n  AddValuation.of Padic.addValuationDef (_ : Padic.addValuationDef 0 = ⊤) (_ : Padic.addValuationDef 1 = 0)\n    (_ : ∀ (x y : ℚ_[p]), min (Padic.addValuationDef x) (Padic.addValuationDef y) ≤ Padic.addValuationDef (x + y))\n    (_ : ∀ (x y : ℚ_[p]), Padic.addValuationDef (x * y) = Padic.addValuationDef x + Padic.addValuationDef y)","name":"Padic.addValuation","doc":"The additive `p`-adic valuation on `ℚ_[p]`, as an `addValuation`. ","depth":13},{"term":"fun {p} [Fact (Nat.Prime p)] =>\n  {\n    toMulHom :=\n      { toFun := Quotient.lift PadicSeq.norm (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g),\n        map_mul' :=\n          (_ :\n            ∀ (q r : ℚ_[p]),\n              Quotient.lift PadicSeq.norm (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g)\n                  (q * r) =\n                Quotient.lift PadicSeq.norm (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g) q *\n                  Quotient.lift PadicSeq.norm (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g)\n                    r) },\n    nonneg' :=\n      (_ :\n        ∀ (q : ℚ_[p]),\n          0 ≤\n            MulHom.toFun\n              {\n                toFun :=\n                  Quotient.lift PadicSeq.norm (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g),\n                map_mul' :=\n                  (_ :\n                    ∀ (q r : ℚ_[p]),\n                      Quotient.lift PadicSeq.norm (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g)\n                          (q * r) =\n                        Quotient.lift PadicSeq.norm\n                            (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g) q *\n                          Quotient.lift PadicSeq.norm\n                            (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g) r) }\n              q),\n    eq_zero' :=\n      (_ :\n        ∀ (q : ℚ_[p]),\n          MulHom.toFun\n                {\n                  toFun :=\n                    Quotient.lift PadicSeq.norm (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g),\n                  map_mul' :=\n                    (_ :\n                      ∀ (q r : ℚ_[p]),\n                        Quotient.lift PadicSeq.norm\n                            (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g) (q * r) =\n                          Quotient.lift PadicSeq.norm\n                              (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g) q *\n                            Quotient.lift PadicSeq.norm\n                              (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g) r) }\n                q =\n              0 ↔\n            q = 0),\n    add_le' :=\n      (_ :\n        ∀ (q r : ℚ_[p]),\n          MulHom.toFun\n              {\n                toFun :=\n                  Quotient.lift PadicSeq.norm (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g),\n                map_mul' :=\n                  (_ :\n                    ∀ (q r : ℚ_[p]),\n                      Quotient.lift PadicSeq.norm (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g)\n                          (q * r) =\n                        Quotient.lift PadicSeq.norm\n                            (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g) q *\n                          Quotient.lift PadicSeq.norm\n                            (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g) r) }\n              (q + r) ≤\n            MulHom.toFun\n                {\n                  toFun :=\n                    Quotient.lift PadicSeq.norm (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g),\n                  map_mul' :=\n                    (_ :\n                      ∀ (q r : ℚ_[p]),\n                        Quotient.lift PadicSeq.norm\n                            (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g) (q * r) =\n                          Quotient.lift PadicSeq.norm\n                              (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g) q *\n                            Quotient.lift PadicSeq.norm\n                              (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g) r) }\n                q +\n              MulHom.toFun\n                {\n                  toFun :=\n                    Quotient.lift PadicSeq.norm (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g),\n                  map_mul' :=\n                    (_ :\n                      ∀ (q r : ℚ_[p]),\n                        Quotient.lift PadicSeq.norm\n                            (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g) (q * r) =\n                          Quotient.lift PadicSeq.norm\n                              (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g) q *\n                            Quotient.lift PadicSeq.norm\n                              (_ : ∀ {f g : PadicSeq p}, f ≈ g → PadicSeq.norm f = PadicSeq.norm g) r) }\n                r) }","name":"padicNormE","doc":"The rational-valued `p`-adic norm on `ℚ_[p]` is lifted from the norm on Cauchy sequences. The\ncanonical form of this function is the normed space instance, with notation `‖ ‖`. ","depth":19},{"term":"fun p [Fact (Nat.Prime p)] =>\n  {\n    toSubsemiring :=\n      {\n        toSubmonoid :=\n          {\n            toSubsemigroup :=\n              { carrier := {x | ‖x‖ ≤ 1},\n                mul_mem' := (_ : ∀ {a b : ℚ_[p]}, a ∈ {x | ‖x‖ ≤ 1} → b ∈ {x | ‖x‖ ≤ 1} → ‖a * b‖ ≤ 1) },\n            one_mem' := (_ : ‖1‖ ≤ 1) },\n        add_mem' :=\n          (_ :\n            ∀ {a b : ℚ_[p]},\n              a ∈\n                  {\n                        toSubsemigroup :=\n                          { carrier := {x | ‖x‖ ≤ 1},\n                            mul_mem' := (_ : ∀ {a b : ℚ_[p]}, a ∈ {x | ‖x‖ ≤ 1} → b ∈ {x | ‖x‖ ≤ 1} → ‖a * b‖ ≤ 1) },\n                        one_mem' := (_ : ‖1‖ ≤ 1) }.toSubsemigroup.carrier →\n                b ∈\n                    {\n                          toSubsemigroup :=\n                            { carrier := {x | ‖x‖ ≤ 1},\n                              mul_mem' := (_ : ∀ {a b : ℚ_[p]}, a ∈ {x | ‖x‖ ≤ 1} → b ∈ {x | ‖x‖ ≤ 1} → ‖a * b‖ ≤ 1) },\n                          one_mem' := (_ : ‖1‖ ≤ 1) }.toSubsemigroup.carrier →\n                  ‖a + b‖ ≤ 1),\n        zero_mem' := (_ : ‖0‖ ≤ 1) },\n    neg_mem' :=\n      (_ :\n        ∀ {x : ℚ_[p]},\n          x ∈\n              {\n                      toSubmonoid :=\n                        {\n                          toSubsemigroup :=\n                            { carrier := {x | ‖x‖ ≤ 1},\n                              mul_mem' := (_ : ∀ {a b : ℚ_[p]}, a ∈ {x | ‖x‖ ≤ 1} → b ∈ {x | ‖x‖ ≤ 1} → ‖a * b‖ ≤ 1) },\n                          one_mem' := (_ : ‖1‖ ≤ 1) },\n                      add_mem' :=\n                        (_ :\n                          ∀ {a b : ℚ_[p]},\n                            a ∈\n                                {\n                                      toSubsemigroup :=\n                                        { carrier := {x | ‖x‖ ≤ 1},\n                                          mul_mem' :=\n                                            (_ :\n                                              ∀ {a b : ℚ_[p]}, a ∈ {x | ‖x‖ ≤ 1} → b ∈ {x | ‖x‖ ≤ 1} → ‖a * b‖ ≤ 1) },\n                                      one_mem' := (_ : ‖1‖ ≤ 1) }.toSubsemigroup.carrier →\n                              b ∈\n                                  {\n                                        toSubsemigroup :=\n                                          { carrier := {x | ‖x‖ ≤ 1},\n                                            mul_mem' :=\n                                              (_ :\n                                                ∀ {a b : ℚ_[p]}, a ∈ {x | ‖x‖ ≤ 1} → b ∈ {x | ‖x‖ ≤ 1} → ‖a * b‖ ≤ 1) },\n                                        one_mem' := (_ : ‖1‖ ≤ 1) }.toSubsemigroup.carrier →\n                                ‖a + b‖ ≤ 1),\n                      zero_mem' := (_ : ‖0‖ ≤ 1) }.toSubmonoid.toSubsemigroup.carrier →\n            ‖-x‖ ≤ 1) }","name":"PadicInt.subring","doc":"The `p`-adic integers as a subring of `ℚ_[p]`. ","depth":20}],"count":15}
{"noDocExamples":[],"kind":"«term_[Λ^_]→L[_]_»","examples":[{"term":"fun {R} {M} {N} {ι} [Semiring R] [AddCommMonoid M] [Module R M] [TopologicalSpace M] [AddCommMonoid N] [Module R N]\n    [TopologicalSpace N] [ContinuousAdd N] =>\n  {\n    toZeroHom :=\n      { toFun := fun f => f.toContinuousMultilinearMap,\n        map_zero' := (_ : (fun f => f.toContinuousMultilinearMap) 0 = (fun f => f.toContinuousMultilinearMap) 0) },\n    map_add' :=\n      (_ :\n        ∀ (x x_1 : M[Λ^ι]→L[R]N),\n          ZeroHom.toFun\n              { toFun := fun f => f.toContinuousMultilinearMap,\n                map_zero' :=\n                  (_ : (fun f => f.toContinuousMultilinearMap) 0 = (fun f => f.toContinuousMultilinearMap) 0) }\n              (x + x_1) =\n            ZeroHom.toFun\n              { toFun := fun f => f.toContinuousMultilinearMap,\n                map_zero' :=\n                  (_ : (fun f => f.toContinuousMultilinearMap) 0 = (fun f => f.toContinuousMultilinearMap) 0) }\n              (x + x_1)) }","name":"ContinuousAlternatingMap.toMultilinearAddHom","doc":"Projection to `ContinuousMultilinearMap`s as a bundled `AddMonoidHom`. ","depth":33},{"term":"fun {R} {M} {ι} [Semiring R] [AddCommMonoid M] [Module R M] [TopologicalSpace M] {ι'} {N}\n    [(i : ι') → AddCommMonoid (N i)] [(i : ι') → TopologicalSpace (N i)] [(i : ι') → Module R (N i)] =>\n  { toFun := ContinuousAlternatingMap.pi,\n    invFun := fun f i => ContinuousLinearMap.compContinuousAlternatingMap (ContinuousLinearMap.proj i) f,\n    left_inv :=\n      (_ :\n        ∀ (f : (i : ι') → M[Λ^ι]→L[R]N i),\n          (fun f i => ContinuousLinearMap.compContinuousAlternatingMap (ContinuousLinearMap.proj i) f)\n              (ContinuousAlternatingMap.pi f) =\n            f),\n    right_inv :=\n      (_ :\n        ∀ (f : M[Λ^ι]→L[R]((i : ι') → N i)),\n          ContinuousAlternatingMap.pi\n              ((fun f i => ContinuousLinearMap.compContinuousAlternatingMap (ContinuousLinearMap.proj i) f) f) =\n            f) }","name":"ContinuousAlternatingMap.piEquiv","doc":"`ContinuousAlternatingMap.pi` as an `Equiv`. ","depth":34},{"term":"fun {R} {A} {M} {N} {ι} [Semiring R] [Semiring A] [AddCommMonoid M] [AddCommMonoid N] [TopologicalSpace M]\n    [TopologicalSpace N] [ContinuousAdd N] [Module A M] [Module A N] [Module R N] [ContinuousConstSMul R N]\n    [SMulCommClass A R N] =>\n  {\n    toAddHom :=\n      { toFun := ContinuousAlternatingMap.toContinuousMultilinearMap,\n        map_add' :=\n          (_ : ∀ (x x_1 : M[Λ^ι]→L[A]N), (x + x_1).toContinuousMultilinearMap = (x + x_1).toContinuousMultilinearMap) },\n    map_smul' :=\n      (_ :\n        ∀ (x : R) (x_1 : M[Λ^ι]→L[A]N),\n          AddHom.toFun\n              { toFun := ContinuousAlternatingMap.toContinuousMultilinearMap,\n                map_add' :=\n                  (_ :\n                    ∀ (x x_2 : M[Λ^ι]→L[A]N),\n                      (x + x_2).toContinuousMultilinearMap = (x + x_2).toContinuousMultilinearMap) }\n              (x • x_1) =\n            AddHom.toFun\n              { toFun := ContinuousAlternatingMap.toContinuousMultilinearMap,\n                map_add' :=\n                  (_ :\n                    ∀ (x x_2 : M[Λ^ι]→L[A]N),\n                      (x + x_2).toContinuousMultilinearMap = (x + x_2).toContinuousMultilinearMap) }\n              (x • x_1)) }","name":"ContinuousAlternatingMap.toContinuousMultilinearMapLinear","doc":"Linear map version of the map `toMultilinearMap` associating to a continuous alternating map\nthe corresponding multilinear map. ","depth":38},{"term":"fun {R} {M} {N} {N'} {ι} [Semiring R] [AddCommMonoid M] [Module R M] [TopologicalSpace M] [AddCommMonoid N] [Module R N]\n    [TopologicalSpace N] [AddCommMonoid N'] [Module R N'] [TopologicalSpace N'] e =>\n  { toFun := ContinuousLinearMap.compContinuousAlternatingMap ↑e,\n    invFun := ContinuousLinearMap.compContinuousAlternatingMap ↑(ContinuousLinearEquiv.symm e),\n    left_inv :=\n      (_ :\n        ∀ (f : M[Λ^ι]→L[R]N),\n          ContinuousLinearMap.compContinuousAlternatingMap (↑(ContinuousLinearEquiv.symm e))\n              (ContinuousLinearMap.compContinuousAlternatingMap (↑e) f) =\n            f),\n    right_inv :=\n      (_ :\n        ∀ (f : M[Λ^ι]→L[R]N'),\n          ContinuousLinearMap.compContinuousAlternatingMap (↑e)\n              (ContinuousLinearMap.compContinuousAlternatingMap (↑(ContinuousLinearEquiv.symm e)) f) =\n            f) }","name":"ContinuousLinearEquiv.compContinuousAlternatingMap","doc":"A continuous linear equivalence of codomains defines an equivalence between continuous\nalternating maps. ","depth":38},{"term":"fun {R} {M} {N} {ι} [Semiring R] [AddCommMonoid M] [Module R M] [TopologicalSpace M] [AddCommMonoid N] [Module R N]\n    [TopologicalSpace N] [ContinuousAdd N] v =>\n  { toZeroHom := { toFun := fun f => ↑f v, map_zero' := (_ : (fun f => ↑f v) 0 = (fun f => ↑f v) 0) },\n    map_add' :=\n      (_ :\n        ∀ (x x_1 : M[Λ^ι]→L[R]N),\n          ZeroHom.toFun { toFun := fun f => ↑f v, map_zero' := (_ : (fun f => ↑f v) 0 = (fun f => ↑f v) 0) } (x + x_1) =\n            ZeroHom.toFun { toFun := fun f => ↑f v, map_zero' := (_ : (fun f => ↑f v) 0 = (fun f => ↑f v) 0) }\n              (x + x_1)) }","name":"ContinuousAlternatingMap.applyAddHom","doc":"Evaluation of a `ContinuousAlternatingMap` at a vector as an `AddMonoidHom`. ","depth":38}],"count":15}
{"noDocExamples":[{"term":"fun {α} [AddCommGroup α] {p a b} =>\n  of_eq_true\n    (Eq.trans\n      (congrFun\n        (congrArg Iff (Eq.trans Mathlib.Algebra.ModEq._auxLemma.17 (congrArg (AddCommGroup.ModEq p a) (zero_add b))))\n        (a ≡ b [PMOD p]))\n      (iff_self (a ≡ b [PMOD p])))","name":"AddCommGroup.sub_modEq_zero","depth":26}],"kind":"AddCommGroup.«term_≡_[PMOD_]»","examples":[{"term":"fun {α} [LinearOrderedAddCommGroup α] [Archimedean α] {p} hp {a b c} =>\n  Eq.mpr (id (congrFun (congrArg Iff (Mathlib.Algebra.Order.ToIntervalMod._auxLemma.3 hp)) (a ≡ b [PMOD p])))\n    (Eq.mpr (id (congrArg (Iff (∃ n, b - a = n • p)) Mathlib.Algebra.Order.ToIntervalMod._auxLemma.4))\n      (of_eq_true\n        (Eq.trans\n          (congrFun (congrArg Iff (congrArg Exists (funext fun n => Mathlib.Algebra.Order.ToIntervalMod._auxLemma.5)))\n            (∃ z, b = a + z • p))\n          (iff_self (∃ n, b = a + n • p)))))","name":"toIcoMod_inj","doc":"If `a` and `b` fall within the same cycle WRT `c`, then they are congruent modulo `p`. ","depth":33},{"term":"fun {α} [AddCommGroupWithOne α] [CharZero α] {a b n} =>\n  (fun {α} [AddCommGroupWithOne α] [CharZero α] {a b n} =>\n      Eq.mpr (id (congrArg (Iff (↑a ≡ ↑b [PMOD ↑n])) Mathlib.Algebra.ModEq._auxLemma.33))\n        (Eq.mpr (id (congrArg (Iff (↑a ≡ ↑b [PMOD ↑n])) Mathlib.Algebra.ModEq._auxLemma.34))\n          (Eq.mpr\n            (id\n              (congrArg (Iff (↑a ≡ ↑b [PMOD ↑n])) fun [AddCommGroupWithOne α] [CharZero α] {a b z} =>\n                Eq.symm (propext AddCommGroup.int_cast_modEq_int_cast)))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Iff (↑a ≡ ↑b [PMOD ↑n]))\n                  (congr (congr (congrArg AddCommGroup.ModEq (Int.cast_ofNat n)) (Int.cast_ofNat a))\n                    (Int.cast_ofNat b)))\n                (iff_self (↑a ≡ ↑b [PMOD ↑n]))))))).mpr","name":"AddCommGroup.ModEq.nat_cast","doc":"**Alias** of the reverse direction of `AddCommGroup.nat_cast_modEq_nat_cast`.","depth":46},{"term":"fun {α} [AddCommGroupWithOne α] [CharZero α] {a b n} =>\n  (fun {α} [AddCommGroupWithOne α] [CharZero α] {a b n} =>\n      Eq.mpr (id (congrArg (Iff (↑a ≡ ↑b [PMOD ↑n])) Mathlib.Algebra.ModEq._auxLemma.33))\n        (Eq.mpr (id (congrArg (Iff (↑a ≡ ↑b [PMOD ↑n])) Mathlib.Algebra.ModEq._auxLemma.34))\n          (Eq.mpr\n            (id\n              (congrArg (Iff (↑a ≡ ↑b [PMOD ↑n])) fun [AddCommGroupWithOne α] [CharZero α] {a b z} =>\n                Eq.symm (propext AddCommGroup.int_cast_modEq_int_cast)))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Iff (↑a ≡ ↑b [PMOD ↑n]))\n                  (congr (congr (congrArg AddCommGroup.ModEq (Int.cast_ofNat n)) (Int.cast_ofNat a))\n                    (Int.cast_ofNat b)))\n                (iff_self (↑a ≡ ↑b [PMOD ↑n]))))))).mp","name":"Nat.ModEq.of_nat_cast","doc":"**Alias** of the forward direction of `AddCommGroup.nat_cast_modEq_nat_cast`.","depth":46},{"term":"fun {α} [LinearOrderedAddCommGroup α] [Archimedean α] {p} hp {a b c} =>\n  ((fun {α} [LinearOrderedAddCommGroup α] [Archimedean α] {p} hp {a b c} =>\n        Eq.mpr (id (congrFun (congrArg Iff (Mathlib.Algebra.Order.ToIntervalMod._auxLemma.3 hp)) (a ≡ b [PMOD p])))\n          (Eq.mpr (id (congrArg (Iff (∃ n, b - a = n • p)) Mathlib.Algebra.Order.ToIntervalMod._auxLemma.4))\n            (of_eq_true\n              (Eq.trans\n                (congrFun\n                  (congrArg Iff (congrArg Exists (funext fun n => Mathlib.Algebra.Order.ToIntervalMod._auxLemma.5)))\n                  (∃ z, b = a + z • p))\n                (iff_self (∃ n, b = a + n • p))))))\n      hp).mpr","name":"AddCommGroup.ModEq.toIcoMod_eq_toIcoMod","doc":"**Alias** of the reverse direction of `toIcoMod_inj`.\n\n---\n\nIf `a` and `b` fall within the same cycle WRT `c`, then they are congruent modulo `p`. ","depth":50}],"count":14}
{"noDocExamples":[{"term":"fun {F} [Field F] {E} [Field E] [Algebra F E] =>\n  {\n    exists_sSup_eq := fun s =>\n      Exists.intro ((fun x => F⟮x⟯) '' ↑s)\n        {\n          left := fun t a =>\n            Exists.casesOn a fun x h =>\n              And.casesOn h fun left right => right ▸ IntermediateField.adjoin_simple_isCompactElement x,\n          right :=\n            Eq.trans sSup_image\n              (le_antisymm (iSup_le fun i => iSup_le fun hi => Iff.mpr IntermediateField.adjoin_simple_le_iff hi)\n                fun x hx =>\n                Iff.mp IntermediateField.adjoin_simple_le_iff (le_iSup_of_le x (le_iSup_of_le hx le_rfl))) } }","name":"IntermediateField.instIsCompactlyGeneratedIntermediateFieldInstCompleteLatticeIntermediateField.proof_1","depth":33}],"kind":"IntermediateField.«term_⟮_,,⟯»","examples":[{"term":"fun F [Field F] {E} [Field E] [Algebra F E] α => { val := α, property := (_ : α ∈ F⟮α⟯) }","name":"IntermediateField.AdjoinSimple.gen","doc":"generator of `F⟮α⟯` ","depth":21},{"term":"fun {F} [Field F] {E} [Field E] [Algebra F E] S =>\n  let_fun key :=\n    le_antisymm\n      (Iff.mpr IntermediateField.adjoin_le_iff fun x hx =>\n        Iff.mpr SetLike.mem_coe\n          (Iff.mp IntermediateField.adjoin_simple_le_iff (le_iSup_of_le x (Iff.mpr le_iSup_iff fun E1 hE1 => hE1 hx))))\n      (iSup_le fun x =>\n        iSup_le fun hx => Iff.mpr IntermediateField.adjoin_simple_le_iff (IntermediateField.subset_adjoin F (↑S) hx));\n  Eq.mpr (id (key ▸ Eq.refl (CompleteLattice.IsCompactElement (IntermediateField.adjoin F ↑S))))\n    (Eq.mpr\n      (id\n        (Eq.symm (Finset.sup_eq_iSup S fun x => F⟮x⟯) ▸\n          Eq.refl (CompleteLattice.IsCompactElement (⨆ (x : E) (_ : x ∈ S), F⟮x⟯))))\n      (CompleteLattice.finset_sup_compact_of_compact S fun x x_1 => IntermediateField.adjoin_simple_isCompactElement x))","name":"IntermediateField.adjoin_finset_isCompactElement","doc":"Adjoining a finite subset is compact in the lattice of intermediate fields. ","depth":35},{"term":"fun F E [Field F] [Field E] [Algebra F E] [FiniteDimensional F E] [IsSeparable F E] =>\n  let α := Exists.choose (_ : ∃ α, F⟮α⟯ = ⊤);\n  let pb := IntermediateField.adjoin.powerBasis (_ : IsIntegral F (Exists.choose (_ : ∃ α, F⟮α⟯ = ⊤)));\n  let_fun e := (_ : F⟮Exists.choose (_ : ∃ α, F⟮α⟯ = ⊤)⟯ = ⊤);\n  PowerBasis.map pb (AlgEquiv.trans (IntermediateField.equivOfEq e) IntermediateField.topEquiv)","name":"Field.powerBasisOfFiniteOfSeparable","doc":"Alternative phrasing of primitive element theorem:\na finite separable field extension has a basis `1, α, α^2, ..., α^n`.\n\nSee also `exists_primitive_element`. ","depth":38},{"term":"fun F [Field F] E [Field E] [Algebra F E] [Finite E] =>\n  Exists.casesOn IsCyclic.exists_generator fun α hα =>\n    Exists.intro (↑α)\n      (Iff.mpr eq_top_iff fun ⦃x⦄ a =>\n        if hx : x = 0 then Eq.mpr (id (hx ▸ Eq.refl (x ∈ F⟮↑α⟯))) (IntermediateField.zero_mem F⟮↑α⟯)\n        else\n          Exists.casesOn (Iff.mp Set.mem_range (hα (Units.mk0 x hx))) fun n hn =>\n            Eq.mpr\n              (id\n                ((let_fun this :=\n                    Eq.mpr (id (hn ▸ Eq.refl (x = ↑(α ^ n))))\n                      (Eq.mpr (id (Units.val_mk0 hx ▸ Eq.refl (x = ↑(Units.mk0 x hx)))) (Eq.refl x));\n                  this) ▸\n                  Eq.refl (x ∈ F⟮↑α⟯)))\n              (Eq.mpr (id (Units.val_zpow_eq_zpow_val α n ▸ Eq.refl (↑(α ^ n) ∈ F⟮↑α⟯)))\n                (zpow_mem (IntermediateField.mem_adjoin_simple_self F ↑α) n)))","name":"Field.exists_primitive_element_of_finite_top","doc":"**Primitive element theorem** assuming E is finite. ","depth":50}],"count":14}
{"noDocExamples":[],"kind":"«term_→SL[_]_»","examples":[{"term":"fun {𝕜} {𝕜₂} {E} {F} [NormedAddCommGroup E] [NormedAddCommGroup F] [NontriviallyNormedField 𝕜]\n    [NontriviallyNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂} [RingHomIsometric σ₁₂] =>\n  NormedAddCommGroup.ofSeparation (_ : ∀ (f : E →SL[σ₁₂] F), ‖f‖ = 0 → f = 0)","name":"ContinuousLinearMap.toNormedAddCommGroup","doc":"Continuous linear maps themselves form a normed space with respect to\nthe operator norm. ","depth":32},{"term":"fun {𝕜₁} [NontriviallyNormedField 𝕜₁] {𝕜₂} [NontriviallyNormedField 𝕜₂] σ {B} E₁ [(x : B) → AddCommGroup (E₁ x)]\n    [(x : B) → Module 𝕜₁ (E₁ x)] E₂ [(x : B) → AddCommGroup (E₂ x)] [(x : B) → Module 𝕜₂ (E₂ x)]\n    [(x : B) → TopologicalSpace (E₁ x)] [(x : B) → TopologicalSpace (E₂ x)] x =>\n  E₁ x →SL[σ] E₂ x","name":"Bundle.ContinuousLinearMap","doc":"A reducible type synonym for the bundle of continuous (semi)linear maps. For some reason, it\nhelps with instance search.\n\nPorting note: after the port is done, we may want to remove this definition.\n","depth":32},{"term":"fun {𝕜} {𝕜₂} {E} {F} [SeminormedAddCommGroup E] [SeminormedAddCommGroup F] [NontriviallyNormedField 𝕜]\n    [NontriviallyNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂} [RingHomIsometric σ₁₂] =>\n  AddGroupSeminorm.toSeminormedAddCommGroup\n    { toFun := norm, map_zero' := (_ : ‖0‖ = 0), add_le' := (_ : ∀ (f g : E →SL[σ₁₂] F), ‖f + g‖ ≤ ‖f‖ + ‖g‖),\n      neg' := (_ : ∀ (f : E →SL[σ₁₂] F), ‖-f‖ = ‖f‖) }","name":"ContinuousLinearMap.tmpSeminormedAddCommGroup","doc":"Continuous linear maps themselves form a seminormed space with respect to\nthe operator norm. This is only a temporary definition because we want to replace the topology\nwith `ContinuousLinearMap.topologicalSpace` to avoid diamond issues.\nSee Note [forgetful inheritance] ","depth":37},{"term":"fun {R} {R₃} {S₃} [Semiring R] [Semiring R₃] [Semiring S₃] {M} [TopologicalSpace M] [AddCommMonoid M] [Module R M] {M₃}\n    [TopologicalSpace M₃] [AddCommMonoid M₃] [Module R₃ M₃] [Module S₃ M₃] [SMulCommClass R₃ S₃ M₃]\n    [ContinuousConstSMul S₃ M₃] σ₁₃ [ContinuousAdd M₃] =>\n  {\n    toAddHom :=\n      { toFun := ContinuousLinearMap.toLinearMap, map_add' := (_ : ∀ (f g : M →SL[σ₁₃] M₃), ↑(f + g) = ↑f + ↑g) },\n    map_smul' := (_ : ∀ (c : S₃) (f : M →SL[σ₁₃] M₃), ↑(c • f) = c • ↑f) }","name":"ContinuousLinearMap.coeLMₛₗ","doc":"The coercion from `M →SL[σ] M₂` to `M →ₛₗ[σ] M₂`, as a linear map. ","depth":42},{"term":"fun {𝕜} {𝕜₂} {E} F [SeminormedAddCommGroup E] [SeminormedAddCommGroup F] [NontriviallyNormedField 𝕜]\n    [NontriviallyNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] σ₁₂ [RingHomIsometric σ₁₂] =>\n  ContinuousLinearMap.flip (ContinuousLinearMap.id 𝕜₂ (E →SL[σ₁₂] F))","name":"ContinuousLinearMap.apply'","doc":"The continuous semilinear map obtained by applying a continuous semilinear map at a given\nvector.\n\nThis is the continuous version of `LinearMap.applyₗ`. ","depth":46}],"count":14}
{"noDocExamples":[],"kind":"«term_→ᵃ[_]_»","examples":[{"term":"fun {k} {V1} {P1} [Ring k] [AddCommGroup V1] [Module k V1] [AddTorsor V1 P1] =>\n  { toOneHom := { toFun := AffineMap.linear, map_one' := (_ : 1.linear = 1.linear) },\n    map_mul' :=\n      (_ :\n        ∀ (x x_1 : P1 →ᵃ[k] P1),\n          OneHom.toFun { toFun := AffineMap.linear, map_one' := (_ : 1.linear = 1.linear) } (x * x_1) =\n            OneHom.toFun { toFun := AffineMap.linear, map_one' := (_ : 1.linear = 1.linear) } (x * x_1)) }","name":"AffineMap.linearHom","doc":"`AffineMap.linear` on endomorphisms is a `MonoidHom`. ","depth":28},{"term":"fun {R} {k} {V1} {P1} {V2} [Ring k] [AddCommGroup V1] [AddTorsor V1 P1] [AddCommGroup V2] [Module k V1] [Module k V2]\n    [Monoid R] [DistribMulAction R V2] [SMulCommClass k R V2] =>\n  DistribMulAction.mk (_ : ∀ (_c : R), _c • 0 = 0)\n    (_ : ∀ (_c : R) (_f _g : P1 →ᵃ[k] V2), _c • (_f + _g) = _c • _f + _c • _g)","name":"AffineMap.distribMulAction","doc":"The space of affine maps to a module inherits an `R`-action from the action on its codomain. ","depth":34},{"term":"fun {k} {V1} {P1} {V2} [Ring k] [AddCommGroup V1] [Module k V1] [AddTorsor V1 P1] [AddCommGroup V2] [Module k V2] =>\n  Function.Injective.addCommGroup FunLike.coe (_ : Function.Injective FunLike.coe) (_ : ↑0 = 0)\n    (_ : ∀ (f g : P1 →ᵃ[k] V2), ↑(f + g) = ↑f + ↑g) (_ : ∀ (f : P1 →ᵃ[k] V2), ↑(-f) = -↑f)\n    (_ : ∀ (f g : P1 →ᵃ[k] V2), ↑(f - g) = ↑f - ↑g) (_ : ∀ (x : P1 →ᵃ[k] V2) (x_1 : ℕ), ↑(x_1 • x) = x_1 • ↑x)\n    (_ : ∀ (x : P1 →ᵃ[k] V2) (x_1 : ℤ), ↑(x_1 • x) = x_1 • ↑x)","name":"AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup","doc":"The set of affine maps to a vector space is an additive commutative group. ","depth":39},{"term":"fun {k} {V1} {P1} [CommRing k] [AddCommGroup V1] [AddTorsor V1 P1] [Module k V1] c =>\n  { toFun := AffineMap.homothety c,\n    linear := ↑(LinearMap.flip (LinearMap.lsmul k (P1 →ᵃ[k] V1))) (AffineMap.id k P1 -ᵥ AffineMap.const k P1 c),\n    map_vadd' :=\n      (_ :\n        ∀ (y x : k),\n          AffineMap.homothety c (x +ᵥ y) =\n            ↑(↑(LinearMap.flip (LinearMap.lsmul k (P1 →ᵃ[k] V1))) (AffineMap.id k P1 -ᵥ AffineMap.const k P1 c)) x +ᵥ\n              AffineMap.homothety c y) }","name":"AffineMap.homothetyAffine","doc":"`homothety` as an affine map. ","depth":40},{"term":"fun {k} {V1} {P1} {V2} [Ring k] [AddCommGroup V1] [Module k V1] [AddTorsor V1 P1] [AddCommGroup V2] [Module k V2] {R}\n    [Monoid R] [DistribMulAction R V2] [SMulCommClass k R V2] =>\n  MulAction.mk (_ : ∀ (f : P1 →ᵃ[k] V2), 1 • f = f) (_ : ∀ (c₁ c₂ : R) (f : P1 →ᵃ[k] V2), (c₁ * c₂) • f = c₁ • c₂ • f)","name":"AffineMap.mulAction","doc":"The space of affine maps to a module inherits an `R`-action from the action on its codomain. ","depth":41}],"count":14}
{"noDocExamples":[{"term":"fun {V} [Quiver V] =>\n  id\n    (Eq.symm\n      (CategoryTheory.Groupoid.Free.lift_unique (𝟭q V ⋙q CategoryTheory.Groupoid.Free.of V)\n        (CategoryTheory.Functor.id (CategoryTheory.FreeGroupoid V))\n        (Eq.refl\n          (CategoryTheory.Groupoid.Free.of V ⋙q\n            (CategoryTheory.Functor.id (CategoryTheory.FreeGroupoid V)).toPrefunctor))))","name":"CategoryTheory.Groupoid.Free.freeGroupoidFunctor_id","depth":16}],"kind":"Prefunctor.«term_⋙q_»","examples":[{"term":"fun {V} [Quiver V] {V'} [Quiver V'] φ => CategoryTheory.Groupoid.Free.lift (φ ⋙q CategoryTheory.Groupoid.Free.of V')","name":"CategoryTheory.freeGroupoidFunctor","doc":"The functor of free groupoid induced by a prefunctor of quivers ","depth":15},{"term":"CategoryTheory.Adjunction.mkOfHomEquiv\n  (CategoryTheory.Adjunction.CoreHomEquiv.mk fun V C =>\n    { toFun := fun F => CategoryTheory.Paths.of ⋙q F.toPrefunctor, invFun := fun F => CategoryTheory.QuivCat.lift F,\n      left_inv :=\n        (_ :\n          ∀ (F : CategoryTheory.Cat.free.obj V ⟶ C),\n            (fun F => CategoryTheory.QuivCat.lift F) ((fun F => CategoryTheory.Paths.of ⋙q F.toPrefunctor) F) = F),\n      right_inv :=\n        (_ :\n          ∀ (x : V ⟶ CategoryTheory.QuivCat.forget.obj C),\n            (fun F => CategoryTheory.Paths.of ⋙q F.toPrefunctor) ((fun F => CategoryTheory.QuivCat.lift F) x) = x) })","name":"CategoryTheory.QuivCat.adj","doc":"The adjunction between forming the free category on a quiver, and forgetting a category to a quiver.\n","depth":26},{"term":"fun {B} [Quiver B] [(a b : B) → Quiver (a ⟶ b)] {C} [Quiver C] [(a b : C) → Quiver (a ⟶ b)] {D} [Quiver D]\n    [(a b : D) → Quiver (a ⟶ b)] F G =>\n  let src := ↑F ⋙q ↑G;\n  { toPrefunctor := { obj := src.obj, map := fun {X Y} => src.map },\n    map₂ := fun {a b} {f g} η => CategoryTheory.PrelaxFunctor.map₂ G (CategoryTheory.PrelaxFunctor.map₂ F η) }","name":"CategoryTheory.PrelaxFunctor.comp","doc":"Composition of prelax functors. ","depth":38},{"term":"fun {V} [Quiver V] {V'} [Quiver V'] [Quiver.HasReverse V'] φ Φ hΦ hΦinv =>\n  hΦ ▸\n    Prefunctor.ext (fun X => Eq.refl (Φ.obj X)) fun X Y f =>\n      Sum.casesOn (motive := fun t =>\n        f = t →\n          Φ.map f =\n            Eq.recOn (Eq.symm (Eq.refl (Φ.obj Y)))\n              (Eq.recOn (Eq.symm (Eq.refl (Φ.obj X))) ((Quiver.Symmetrify.lift (Quiver.Symmetrify.of ⋙q Φ)).map f)))\n        f (fun val h => Eq.symm h ▸ Eq.refl (Φ.map (Sum.inl val))) (fun val h => Eq.symm h ▸ hΦinv (Sum.inl val))\n        (Eq.refl f)","name":"Quiver.Symmetrify.lift_unique","doc":"`lift φ` is the only prefunctor extending `φ` and preserving reverses. ","depth":47}],"count":13}
{"noDocExamples":[],"kind":"CategoryTheory.NatTrans.«term_◫_»","examples":[{"term":"fun C [CategoryTheory.Category.{u_2, u_1} C] [CategoryTheory.Preadditive C] n =>\n  AlgebraicTopology.DoldKan.natTransPInfty C ◫\n    CategoryTheory.CategoryStruct.id (HomologicalComplex.eval C (ComplexShape.down ℕ) n)","name":"AlgebraicTopology.DoldKan.natTransPInfty_f","doc":"The natural transformation in each degree that is induced by `natTransPInfty`. ","depth":22},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] {D} [CategoryTheory.Category.{v₂, u₂} D] {E}\n    [CategoryTheory.Category.{u_2, u_1} E] {F G} H [CategoryTheory.Full H] [CategoryTheory.Faithful H] =>\n  { toFun := fun α => α ◫ CategoryTheory.CategoryStruct.id H, invFun := CategoryTheory.natTransOfCompFullyFaithful H,\n    left_inv :=\n      (_ :\n        ∀ (x : F ⟶ G),\n          CategoryTheory.natTransOfCompFullyFaithful H ((fun α => α ◫ CategoryTheory.CategoryStruct.id H) x) = x),\n    right_inv :=\n      (_ :\n        ∀ (x : CategoryTheory.Functor.comp F H ⟶ CategoryTheory.Functor.comp G H),\n          (fun α => α ◫ CategoryTheory.CategoryStruct.id H) (CategoryTheory.natTransOfCompFullyFaithful H x) = x) }","name":"CategoryTheory.NatTrans.equivOfCompFullyFaithful","doc":"Horizontal composition with a fully faithful functor induces a bijection on\nnatural transformations. ","depth":28},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] {D} [CategoryTheory.Category.{v₂, u₂} D] {E}\n    [CategoryTheory.Category.{v₃, u₃} E] {F G} {H I} α β =>\n  CategoryTheory.Iso.mk (α.hom ◫ β.hom) (α.inv ◫ β.inv)","name":"CategoryTheory.NatIso.hcomp","doc":"Horizontal composition of natural isomorphisms. ","depth":28},{"term":"fun C [CategoryTheory.Category.{v, u} C] =>\n  CategoryTheory.MonoidalCategory.mk (fun F G => CategoryTheory.Functor.comp F G)\n    (fun X x x_1 F => CategoryTheory.whiskerLeft X F) (fun {X₁ X₂} F X => CategoryTheory.whiskerRight F X)\n    (fun {X₁ Y₁ X₂ Y₂} α β => α ◫ β) (CategoryTheory.Functor.id C)\n    (fun F G H => CategoryTheory.Functor.associator F G H) (fun F => CategoryTheory.Functor.leftUnitor F) fun F =>\n    CategoryTheory.Functor.rightUnitor F","name":"CategoryTheory.endofunctorMonoidalCategory","doc":"The category of endofunctors of any category is a monoidal category,\nwith tensor product given by composition of functors\n(and horizontal composition of natural transformations).\n","depth":35},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {D}\n    [CategoryTheory.Category.{v₂, u₂} D] [CategoryTheory.MonoidalCategory D] {E} [CategoryTheory.Category.{v₃, u₃} E]\n    [CategoryTheory.MonoidalCategory E] {F G} {H K} α β =>\n  let src := α.toNatTrans ◫ β.toNatTrans;\n  CategoryTheory.MonoidalNatTrans.mk (CategoryTheory.NatTrans.mk src.app)","name":"CategoryTheory.MonoidalNatTrans.hcomp","doc":"Horizontal composition of monoidal natural transformations. ","depth":35}],"count":13}
{"noDocExamples":[],"kind":"TopCat.Presheaf.«term__*_»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v, u} C] {X Y} f {F} h =>\n  Eq.mpr\n    (id\n      (propext (TopCat.Presheaf.isSheaf_iff_isSheafPairwiseIntersections (f _* F)) ▸\n        Eq.refl (TopCat.Presheaf.IsSheaf (f _* F))))\n    (TopCat.Presheaf.SheafConditionPairwiseIntersections.pushforward_sheaf_of_sheaf f\n      (Eq.mp\n        (propext (TopCat.Presheaf.isSheaf_iff_isSheafPairwiseIntersections F) ▸ Eq.refl (TopCat.Presheaf.IsSheaf F)) h))","name":"TopCat.Sheaf.pushforward_sheaf_of_sheaf","doc":"The pushforward of a sheaf (by a continuous map) is a sheaf.\n","depth":24},{"term":"fun {R S} f p =>\n  CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toOpen ↑S ⊤)\n    (TopCat.Presheaf.germ (AlgebraicGeometry.Spec.topMap f _* (AlgebraicGeometry.Spec.structureSheaf ↑S).val)\n      { val := p, property := trivial })","name":"AlgebraicGeometry.StructureSheaf.toPushforwardStalk","doc":"For an algebra `f : R →+* S`, this is the ring homomorphism `S →+* (f∗ 𝒪ₛ)ₚ` for a `p : Spec R`.\nThis is shown to be the localization at `p` in `isLocalizedModule_toPushforwardStalkAlgHom`.\n","depth":28},{"term":"fun {C} [CategoryTheory.Category.{u_2, u_1} C] X =>\n  { base := (TopologicalSpace.Opens.inclusionTopIso ↑X).inv,\n    c :=\n      CategoryTheory.eqToHom\n        (_ :\n          (AlgebraicGeometry.PresheafedSpace.restrict X\n                (_ : OpenEmbedding ↑(TopologicalSpace.Opens.inclusion ⊤))).presheaf =\n            (TopologicalSpace.Opens.inclusionTopIso ↑X).inv _* X.presheaf) }","name":"AlgebraicGeometry.PresheafedSpace.toRestrictTop","doc":"The map to the restriction of a presheafed space along the canonical inclusion from the top\nsubspace.\n","depth":33},{"term":"fun {C} [CategoryTheory.Category.{v, u} C] {X Y} f =>\n  CategoryTheory.Functor.mk\n    { obj := fun ℱ => { val := f _* ℱ.val, cond := (_ : TopCat.Presheaf.IsSheaf (f _* ℱ.val)) },\n      map := fun {x x_1} g => { val := TopCat.Presheaf.pushforwardMap f g.val } }","name":"TopCat.Sheaf.pushforward","doc":"The pushforward functor.\n","depth":34},{"term":"fun {C} [CategoryTheory.Category.{u_3, u_1} C] {D} [CategoryTheory.Category.{u_4, u_2} D] {F G} α =>\n  CategoryTheory.NatTrans.mk fun X =>\n    { base := CategoryTheory.CategoryStruct.id ↑((CategoryTheory.Functor.mapPresheaf G).obj X),\n      c :=\n        CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft X.presheaf α)\n          (CategoryTheory.eqToHom\n            (_ :\n              CategoryTheory.Functor.comp X.presheaf G =\n                CategoryTheory.CategoryStruct.id ↑X _* CategoryTheory.Functor.comp X.presheaf G)) }","name":"CategoryTheory.NatTrans.onPresheaf","doc":"A natural transformation induces a natural transformation between the `map_presheaf` functors.\n","depth":34}],"count":13}
{"noDocExamples":[{"term":"fun {α} [PartialOrder α] [SuccOrder α] {a b} h =>\n  Or.casesOn (Wcovby.covby_or_eq h) (fun h => Eq.ge (Covby.succ_eq h)) fun h_1 =>\n    Eq.ndrec (motive := fun {b} => a ⩿ b → b ≤ Order.succ a) (fun h => Order.le_succ a) h_1 h","name":"Wcovby.le_succ","depth":21},{"term":"fun {α} [PartialOrder α] [PredOrder α] {a b} h =>\n  Or.casesOn (Wcovby.covby_or_eq h) (fun h => Eq.le (Covby.pred_eq h)) fun h_1 =>\n    Eq.ndrec (motive := fun {b} => a ⩿ b → Order.pred b ≤ a) (fun h => Order.pred_le a) h_1 h","name":"Wcovby.pred_le","depth":22},{"term":"fun {α} [PartialOrder α] {a b} =>\n  Eq.mpr (id (propext le_antisymm_iff ▸ Eq.refl (a ⩿ b ↔ a ⋖ b ∨ a = b)))\n    (Eq.mpr (id (propext wcovby_iff_covby_or_le_and_le ▸ Eq.refl (a ⩿ b ↔ a ⋖ b ∨ a ≤ b ∧ b ≤ a))) Iff.rfl)","name":"wcovby_iff_covby_or_eq","depth":25}],"kind":"«term_⩿_»","examples":[{"term":"fun {K} {V} [DivisionRing K] [AddCommGroup V] [Module K V] {n} b =>\n  Flag.rangeFin (Basis.flag b) (_ : Basis.flag b 0 = ⊥) (_ : Basis.flag b (Fin.last n) = ⊤)\n    (_ : ∀ (i : Fin n), Basis.flag b (Fin.castSucc i) ⩿ Basis.flag b (Fin.succ i))","name":"Basis.toFlag","doc":"Range of `Basis.flag` as a `Flag`. ","depth":23},{"term":"fun {α} [PartialOrder α] {a b} =>\n  (fun {α} [PartialOrder α] {a b} =>\n      Eq.mpr (id (propext le_antisymm_iff ▸ Eq.refl (a ⩿ b ↔ a ⋖ b ∨ a = b)))\n        (Eq.mpr (id (propext wcovby_iff_covby_or_le_and_le ▸ Eq.refl (a ⩿ b ↔ a ⋖ b ∨ a ≤ b ∧ b ≤ a))) Iff.rfl)).mp","name":"Wcovby.covby_or_eq","doc":"**Alias** of the forward direction of `wcovby_iff_covby_or_eq`.","depth":34}],"count":13}
{"noDocExamples":[{"term":"fun {α} [DecidableEq α] x x_1 =>\n  decidable_of_iff (∀ (x_2 : α), x_2 ∈ x → List.count x_2 x ≤ List.count x_2 x_1)\n    (_ : (∀ (x_2 : α), x_2 ∈ x → List.count x_2 x ≤ List.count x_2 x_1) ↔ x <+~ x_1)","name":"List.decidableSubperm","depth":19},{"term":"fun {α} [DecidableEq α] a l =>\n  if h : a ∈ l then List.Perm.subperm (List.perm_cons_erase h)\n  else\n    Eq.mpr (id (List.erase_of_not_mem h ▸ Eq.refl (l <+~ a :: List.erase l a)))\n      (List.Sublist.subperm (List.sublist_cons a l))","name":"List.subperm_cons_erase","depth":26},{"term":"fun {α} s =>\n  Quotient.inductionOn s fun l =>\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (LE.le ↑(List.map singleton l)) (Multiset.powerset_coe l))\n          Mathlib.Data.Multiset.Powerset._auxLemma.4))\n      (let_fun this :=\n        Eq.mpr\n          (id\n            (Eq.symm (List.map_map Multiset.ofList List.ret l) ▸\n              Eq.refl (List.map (Multiset.ofList ∘ List.ret) l <+~ List.map Multiset.ofList (List.sublists l))))\n          (List.Sublist.subperm (List.Sublist.map Multiset.ofList (List.map_ret_sublist_sublists l)));\n      this)","name":"Multiset.map_single_le_powerset","depth":26},{"term":"fun {α} [DecidableEq α] a b l =>\n  if h : a = b then\n    h ▸\n      Eq.mpr (id (List.erase_cons_head a l ▸ Eq.refl (List.erase (a :: l) a <+~ a :: List.erase l a)))\n        (List.subperm_cons_erase a l)\n  else\n    Eq.mpr (id (List.erase_cons_tail l h ▸ Eq.refl (List.erase (a :: l) b <+~ a :: List.erase l b)))\n      (List.Subperm.refl (a :: List.erase l b))","name":"List.erase_cons_subperm_cons_erase","depth":31}],"kind":"List.«term_<+~_»","examples":[{"term":"fun {α} s t =>\n  Quotient.liftOn₂ s t (fun x x_1 => x <+~ x_1)\n    (_ : ∀ (x x_1 x_2 x_3 : List α), x ≈ x_2 → x_1 ≈ x_3 → (x <+~ x_1) = (x_2 <+~ x_3))","name":"Multiset.Le","doc":"`s ≤ t` means that `s` is a sublist of `t` (up to permutation).\nEquivalently, `s ≤ t` means that `count a s ≤ count a t` for all `a`. ","depth":13}],"count":13}
{"noDocExamples":[{"term":"fun {α} {m0} {μ} {f} hf =>\n  Or.casesOn (eq_or_ne μ 0)\n    (fun h =>\n      Eq.ndrec (motive := fun {μ} => ∫⁻ (x : α), f x ∂μ ≠ ⊤ → ⨍⁻ (x : α), f x ∂μ < ⊤)\n        (fun hf =>\n          of_eq_true\n            (Eq.trans (congrFun (congrArg LT.lt (MeasureTheory.laverage_zero_measure fun x => f x)) ⊤)\n              (eq_true_of_decide (Eq.refl true))))\n        (Eq.symm h) hf)\n    fun hμ =>\n    Eq.mpr (id ((MeasureTheory.laverage_eq μ fun x => f x) ▸ Eq.refl (⨍⁻ (x : α), f x ∂μ < ⊤)))\n      (ENNReal.div_lt_top hf (Iff.mpr MeasureTheory.Measure.measure_univ_ne_zero hμ))","name":"MeasureTheory.laverage_lt_top","depth":29}],"kind":"MeasureTheory.«term⨍⁻_,_∂_»","examples":[{"term":"fun {α} {m0} {μ} {f} [MeasureTheory.IsFiniteMeasure μ] hμ hf =>\n  Eq.mp\n    (congrArg (LT.lt 0)\n      (congrArg (↑↑μ)\n        (congrArg setOf\n          (funext fun x =>\n            Eq.trans\n              (congr (congrArg And (Mathlib.Data.Set.Basic._auxLemma.14 x))\n                (congrArg (LE.le (f x))\n                  (congrFun (congrArg MeasureTheory.laverage MeasureTheory.Measure.restrict_univ) fun a => f a)))\n              (true_and (f x ≤ ⨍⁻ (a : α), f a ∂μ))))))\n    (MeasureTheory.measure_le_setLaverage_pos (Iff.mpr MeasureTheory.Measure.measure_univ_ne_zero hμ)\n      (MeasureTheory.measure_ne_top μ Set.univ) (AEMeasurable.restrict hf))","name":"MeasureTheory.measure_le_laverage_pos","doc":"**First moment method**. A measurable function is smaller than its mean on a set of positive\nmeasure. ","depth":30},{"term":"fun {α} {m0} {μ} {f} hμ hint =>\n  Eq.mp\n    (Eq.trans\n      (implies_congr\n        (Eq.trans\n          (Eq.trans\n            (congrFun\n              (congrArg Ne\n                (congrFun (congrArg MeasureTheory.lintegral MeasureTheory.Measure.restrict_univ) fun a => f a))\n              ⊤)\n            (congrArg Not (eq_false hint)))\n          not_false_eq_true)\n        (congrArg (LT.lt 0)\n          (congrArg (↑↑μ)\n            (congrArg setOf\n              (funext fun x =>\n                Eq.trans\n                  (congr (congrArg And (Mathlib.Data.Set.Basic._auxLemma.14 x))\n                    (congrFun\n                      (congrArg LE.le\n                        (congrFun (congrArg MeasureTheory.laverage MeasureTheory.Measure.restrict_univ) fun a => f a))\n                      (f x)))\n                  (true_and (⨍⁻ (a : α), f a ∂μ ≤ f x)))))))\n      (Mathlib.Logic.Basic._auxLemma.48 fun x => 0 < ↑↑μ {x | ⨍⁻ (a : α), f a ∂μ ≤ f x}))\n    (MeasureTheory.measure_setLaverage_le_pos (Iff.mpr MeasureTheory.Measure.measure_univ_ne_zero hμ)\n      MeasureTheory.nullMeasurableSet_univ)","name":"MeasureTheory.measure_laverage_le_pos","doc":"**First moment method**. A measurable function is greater than its mean on a set of positive\nmeasure. ","depth":32},{"term":"fun {α} {m0} {μ} {N} {f} hμ hint hN =>\n  let_fun this := MeasureTheory.measure_laverage_le_pos hμ hint;\n  Exists.casesOn\n    (MeasureTheory.nonempty_of_measure_ne_zero\n      (LT.lt.ne'\n        (Eq.mp (Eq.symm (MeasureTheory.measure_diff_null hN) ▸ Eq.refl (0 < ↑↑μ {x | ⨍⁻ (a : α), f a ∂μ ≤ f x})) this)))\n    fun x h => And.casesOn h fun hx hxN => Exists.intro x { left := hxN, right := hx }","name":"MeasureTheory.exists_not_mem_null_laverage_le","doc":"**First moment method**. The maximum of a measurable function is greater than its mean, while\navoiding a null set. ","depth":38},{"term":"fun {α} {m0} {μ} {N} {f} [MeasureTheory.IsFiniteMeasure μ] hμ hf hN =>\n  let_fun this := MeasureTheory.measure_le_laverage_pos hμ hf;\n  Exists.casesOn\n    (MeasureTheory.nonempty_of_measure_ne_zero\n      (LT.lt.ne'\n        (Eq.mp (Eq.symm (MeasureTheory.measure_diff_null hN) ▸ Eq.refl (0 < ↑↑μ {x | f x ≤ ⨍⁻ (a : α), f a ∂μ})) this)))\n    fun x h => And.casesOn h fun hx hxN => Exists.intro x { left := hxN, right := hx }","name":"MeasureTheory.exists_not_mem_null_le_laverage","doc":"**First moment method**. The minimum of a measurable function is smaller than its mean, while\navoiding a null set. ","depth":39}],"count":13}
{"noDocExamples":[{"term":"fun {C} [CategoryTheory.Category.{u_2, u_1} C] [CategoryTheory.Limits.HasFiniteProducts C]\n    [CategoryTheory.CartesianClosed C] =>\n  CategoryTheory.ExponentialIdeal.mk' (CategoryTheory.subterminalInclusion C) fun B A =>\n    Exists.intro\n      { obj := A ⟹ B.obj,\n        property := fun Z g h =>\n          CategoryTheory.CartesianClosed.uncurry_injective\n            (CategoryTheory.FullSubcategory.property B (CategoryTheory.CartesianClosed.uncurry g)\n              (CategoryTheory.CartesianClosed.uncurry h)) }\n      (Nonempty.intro\n        (CategoryTheory.Iso.refl\n          ((CategoryTheory.subterminalInclusion C).obj\n            { obj := A ⟹ B.obj,\n              property := fun Z g h =>\n                CategoryTheory.CartesianClosed.uncurry_injective\n                  (CategoryTheory.FullSubcategory.property B (CategoryTheory.CartesianClosed.uncurry g)\n                    (CategoryTheory.CartesianClosed.uncurry h)) })))","name":"CategoryTheory.instExponentialIdealSubterminalsInstCategorySubterminalsSubterminalInclusion.proof_1","depth":31}],"kind":"CategoryTheory.exp.«term_⟹_»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v, u} C] {X} [CategoryTheory.Limits.HasFiniteProducts C]\n    [CategoryTheory.Exponentiable (⊤_ C)] =>\n  CategoryTheory.Yoneda.ext ((⊤_ C) ⟹ X) X\n    (fun {Y} f =>\n      CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor Y).inv\n        (CategoryTheory.CartesianClosed.uncurry f))\n    (fun {Y} f =>\n      CategoryTheory.CartesianClosed.curry\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor Y).hom f))\n    (_ :\n      ∀ {Z : C} (g : Z ⟶ (⊤_ C) ⟹ X),\n        (fun {Y} f =>\n              CategoryTheory.CartesianClosed.curry\n                (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor Y).hom f))\n            ((fun {Y} f =>\n                CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor Y).inv\n                  (CategoryTheory.CartesianClosed.uncurry f))\n              g) =\n          g)\n    (_ :\n      ∀ {Z : C} (g : Z ⟶ X),\n        CategoryTheory.CategoryStruct.comp\n            (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.terminal.from Z)\n              (CategoryTheory.CategoryStruct.id Z))\n            (CategoryTheory.CartesianClosed.uncurry\n              (CategoryTheory.CartesianClosed.curry\n                (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd g))) =\n          g)\n    (_ :\n      ∀ {Z Z' : C} (f : Z' ⟶ Z) (g : Z ⟶ (⊤_ C) ⟹ X),\n        (fun {Y} f =>\n              CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor Y).inv\n                (CategoryTheory.CartesianClosed.uncurry f))\n            (CategoryTheory.CategoryStruct.comp f g) =\n          CategoryTheory.CategoryStruct.comp f\n            ((fun {Y} f =>\n                CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor Y).inv\n                  (CategoryTheory.CartesianClosed.uncurry f))\n              g))","name":"CategoryTheory.expTerminalIsoSelf","doc":"Show that the exponential of the terminal object is isomorphic to itself, i.e. `X^1 ≅ X`.\n\nThe typeclass argument is explicit: any instance can be used.\n","depth":24},{"term":"fun {C} {D} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.Category.{v₁, u₂} D] i\n    [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.CartesianClosed C] [CategoryTheory.Reflective i] h =>\n  CategoryTheory.ExponentialIdeal.mk' i fun B A =>\n    Exists.intro ((CategoryTheory.leftAdjoint i).obj (A ⟹ i.obj B)) (Nonempty.intro ((h A).app B))","name":"CategoryTheory.ExponentialIdeal.mk_of_iso","doc":"Given a natural isomorphism `i ⋙ exp A ⋙ leftAdjoint i ⋙ i ≅ i ⋙ exp A`, we can show `i`\nis an exponential ideal.\n","depth":31},{"term":"fun {C} {D} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.Category.{v₁, u₂} D] i\n    [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.CartesianClosed C] A [CategoryTheory.Reflective i]\n    [CategoryTheory.ExponentialIdeal i] =>\n  (CategoryTheory.NatIso.ofComponents fun X =>\n      CategoryTheory.asIso\n        (CategoryTheory.NatTrans.app (CategoryTheory.Adjunction.ofRightAdjoint i).unit (A ⟹ i.obj X))).symm","name":"CategoryTheory.exponentialIdealReflective","doc":"If `D` is a reflective subcategory, the property of being an exponential ideal is equivalent to\nthe presence of a natural isomorphism `i ⋙ exp A ⋙ leftAdjoint i ⋙ i ≅ i ⋙ exp A`, that is:\n`(A ⟹ iB) ≅ i L (A ⟹ iB)`, naturally in `B`.\nThe converse is given in `ExponentialIdeal.mk_of_iso`.\n","depth":31},{"term":"fun {C} {D} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.Category.{v₁, u₂} D] i\n    [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Reflective i] [CategoryTheory.CartesianClosed C]\n    [CategoryTheory.Limits.HasFiniteProducts D] [CategoryTheory.ExponentialIdeal i] A B X =>\n  Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (Trans.trans\n                      (CategoryTheory.Adjunction.homEquiv (CategoryTheory.Adjunction.ofRightAdjoint i) (A ⨯ B) X)\n                      (CategoryTheory.Iso.homCongr (CategoryTheory.Limits.prod.braiding A B)\n                        (CategoryTheory.Iso.refl (i.obj X))))\n                    (CategoryTheory.Adjunction.homEquiv (CategoryTheory.exp.adjunction B) A (i.obj X)))\n                  (CategoryTheory.unitCompPartialBijective A (_ : (B ⟹ i.obj X) ∈ CategoryTheory.Functor.essImage i)))\n                (CategoryTheory.Adjunction.homEquiv (CategoryTheory.exp.adjunction B)\n                    (i.obj ((CategoryTheory.leftAdjoint i).obj A)) (i.obj X)).symm)\n              (CategoryTheory.Iso.homCongr\n                (CategoryTheory.Limits.prod.braiding B (i.obj ((CategoryTheory.leftAdjoint i).obj A)))\n                (CategoryTheory.Iso.refl (i.obj X))))\n            (CategoryTheory.Adjunction.homEquiv\n              (CategoryTheory.exp.adjunction (i.obj ((CategoryTheory.leftAdjoint i).obj A))) B (i.obj X)))\n          (CategoryTheory.unitCompPartialBijective B\n            (_ : (i.obj ((CategoryTheory.leftAdjoint i).obj A) ⟹ i.obj X) ∈ CategoryTheory.Functor.essImage i)))\n        (CategoryTheory.Adjunction.homEquiv\n            (CategoryTheory.exp.adjunction (i.obj ((CategoryTheory.leftAdjoint i).obj A)))\n            (i.obj ((CategoryTheory.leftAdjoint i).obj B)) (i.obj X)).symm)\n      (CategoryTheory.Iso.homCongr\n        (CategoryTheory.Limits.PreservesLimitPair.iso i ((CategoryTheory.leftAdjoint i).obj A)\n            ((CategoryTheory.leftAdjoint i).obj B)).symm\n        (CategoryTheory.Iso.refl (i.obj X))))\n    (CategoryTheory.equivOfFullyFaithful i).symm","name":"CategoryTheory.bijection","doc":"We construct a bijection between morphisms `L(A ⨯ B) ⟶ X` and morphisms `LA ⨯ LB ⟶ X`.\nThis bijection has two key properties:\n* It is natural in `X`: See `bijection_natural`.\n* When `X = LA ⨯ LB`, then the backwards direction sends the identity morphism to the product\n  comparison morphism: See `bijection_symm_apply_id`.\n\nTogether these help show that `L` preserves binary products. This should be considered\n*internal implementation* towards `preservesBinaryProductsOfExponentialIdeal`.\n","depth":49}],"count":12}
{"noDocExamples":[{"term":"fun {C} [CategoryTheory.Category.{u_1, u_2} C] [CategoryTheory.MonoidalCategory C] {X₁ X₂ Y} p₁ p₂ =>\n  Eq.mpr\n    (id\n      (Eq.symm CategoryTheory.comp_leftAdjointMate ▸\n        Eq.refl\n          (CategoryTheory.CategoryStruct.comp (ᘁCategoryTheory.CategoryStruct.id Y)\n              (ᘁCategoryTheory.CategoryStruct.id Y) =\n            CategoryTheory.CategoryStruct.id X₁)))\n    (Eq.mpr\n      (id\n        (CategoryTheory.Category.comp_id (CategoryTheory.CategoryStruct.id Y) ▸\n          Eq.refl\n            ((ᘁCategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Y)\n                  (CategoryTheory.CategoryStruct.id Y)) =\n              CategoryTheory.CategoryStruct.id X₁)))\n      (Eq.mpr\n        (id\n          (CategoryTheory.leftAdjointMate_id ▸\n            Eq.refl ((ᘁCategoryTheory.CategoryStruct.id Y) = CategoryTheory.CategoryStruct.id X₁)))\n        (Eq.refl (CategoryTheory.CategoryStruct.id ᘁY))))","name":"CategoryTheory.leftDualIso.proof_1","depth":31},{"term":"fun {C} [CategoryTheory.Category.{u_1, u_2} C] [CategoryTheory.MonoidalCategory C] {X₁ X₂ Y} p₁ p₂ =>\n  Eq.mpr\n    (id\n      (Eq.symm CategoryTheory.comp_leftAdjointMate ▸\n        Eq.refl\n          (CategoryTheory.CategoryStruct.comp (ᘁCategoryTheory.CategoryStruct.id Y)\n              (ᘁCategoryTheory.CategoryStruct.id Y) =\n            CategoryTheory.CategoryStruct.id X₂)))\n    (Eq.mpr\n      (id\n        (CategoryTheory.Category.comp_id (CategoryTheory.CategoryStruct.id Y) ▸\n          Eq.refl\n            ((ᘁCategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Y)\n                  (CategoryTheory.CategoryStruct.id Y)) =\n              CategoryTheory.CategoryStruct.id X₂)))\n      (Eq.mpr\n        (id\n          (CategoryTheory.leftAdjointMate_id ▸\n            Eq.refl ((ᘁCategoryTheory.CategoryStruct.id Y) = CategoryTheory.CategoryStruct.id X₂)))\n        (Eq.refl (CategoryTheory.CategoryStruct.id ᘁY))))","name":"CategoryTheory.leftDualIso.proof_2","depth":31}],"kind":"CategoryTheory.«termᘁ_»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] Y [CategoryTheory.HasLeftDual Y] =>\n  {\n    isAdj :=\n      { right := CategoryTheory.MonoidalCategory.tensorLeft ᘁY, adj := CategoryTheory.tensorLeftAdjunction (ᘁY) Y } }","name":"CategoryTheory.closedOfHasLeftDual","doc":"If `Y` has a left dual `ᘁY`, then it is a closed object, with the internal hom functor `Y ⟶[C] -`\ngiven by left tensoring by `ᘁY`.\nThis has to be a definition rather than an instance to avoid diamonds, for example between\n`category_theory.monoidal_closed.functor_closed` and\n`category_theory.monoidal.functor_has_left_dual`. Moreover, in concrete applications there is often\na more useful definition of the internal hom object than `ᘁY ⊗ X`, in which case the closed\nstructure shouldn't come from `has_left_dual` (e.g. in the category `FinVect k`, it is more\nconvenient to define the internal hom as `Y →ₗ[k] X` rather than `ᘁY ⊗ X` even though these are\nnaturally isomorphic).\n","depth":15},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X Y} [CategoryTheory.HasLeftDual X]\n    [CategoryTheory.HasLeftDual Y] f =>\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor ᘁY).inv\n    (CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (η_ (ᘁX) X) (CategoryTheory.CategoryStruct.id ᘁY))\n      (CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.MonoidalCategory.tensorHom\n          (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id ᘁX) f)\n          (CategoryTheory.CategoryStruct.id ᘁY))\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator (ᘁX) Y ᘁY).hom\n          (CategoryTheory.CategoryStruct.comp\n            (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id ᘁX) (ε_ (ᘁY) Y))\n            (CategoryTheory.MonoidalCategory.rightUnitor ᘁX).hom))))","name":"CategoryTheory.leftAdjointMate","doc":"The left adjoint mate `ᘁf : ᘁY ⟶ ᘁX` of a morphism `f : X ⟶ Y`. ","depth":25},{"term":"fun {C} {D} [CategoryTheory.Category.{u_3, u_1} C] [CategoryTheory.Category.{u_4, u_2} D]\n    [CategoryTheory.MonoidalCategory C] [CategoryTheory.MonoidalCategory D] F [CategoryTheory.IsEquivalence F.toFunctor]\n    X [CategoryTheory.HasLeftDual (F.obj X)] =>\n  CategoryTheory.HasLeftDual.mk ((CategoryTheory.Functor.inv F.toFunctor).obj ᘁ(F.obj X))","name":"CategoryTheory.hasLeftDualOfEquivalence","doc":"Pull back a left dual along an equivalence. ","depth":32}],"count":12}
{"noDocExamples":[{"term":"fun x =>\n  Eq.mpr (id (Eq.symm (Real.log_abs x) ▸ Eq.refl (Real.log (-x) = Real.log x)))\n    (Eq.mpr (id (Eq.symm (Real.log_abs (-x)) ▸ Eq.refl (Real.log (-x) = Real.log |x|)))\n      (Eq.mpr (id (abs_neg x ▸ Eq.refl (Real.log |(-x)| = Real.log |x|))) (Eq.refl (Real.log |x|))))","name":"Real.log_neg_eq_log","depth":21},{"term":"fun {b} x =>\n  Eq.mpr (id (Eq.symm (Real.logb_abs x) ▸ Eq.refl (Real.logb b (-x) = Real.logb b x)))\n    (Eq.mpr (id (Eq.symm (Real.logb_abs (-x)) ▸ Eq.refl (Real.logb b (-x) = Real.logb b |x|)))\n      (Eq.mpr (id (abs_neg x ▸ Eq.refl (Real.logb b |(-x)| = Real.logb b |x|))) (Eq.refl (Real.logb b |x|))))","name":"Real.logb_neg_eq_logb","depth":22},{"term":"fun x =>\n  match x with\n  | some none => rfl\n  | none => rfl\n  | some (some x) =>\n    Eq.mpr (id (EReal.abs_def x ▸ Eq.refl (EReal.abs (-↑x) = EReal.abs ↑x)))\n      (Eq.mpr (id (Eq.symm (EReal.coe_neg x) ▸ Eq.refl (EReal.abs (-↑x) = ENNReal.ofReal |x|)))\n        (Eq.mpr (id (EReal.abs_def (-x) ▸ Eq.refl (EReal.abs ↑(-x) = ENNReal.ofReal |x|)))\n          (Eq.mpr (id (abs_neg x ▸ Eq.refl (ENNReal.ofReal |(-x)| = ENNReal.ofReal |x|)))\n            (Eq.refl (ENNReal.ofReal |x|)))))","name":"EReal.abs_neg","depth":24},{"term":"let_fun this := fun a n =>\n  Eq.mpr (id (Int.abs_eq_natAbs (a / ↑n) ▸ Eq.refl (|a / ↑n| ≤ |a|)))\n    (Eq.mpr (id (Int.abs_eq_natAbs a ▸ Eq.refl (↑(Int.natAbs (a / ↑n)) ≤ |a|)))\n      (Int.ofNat_le_ofNat_of_le\n        (match a, n with\n        | Int.ofNat m, n => Nat.div_le_self m n\n        | Int.negSucc m, 0 => Nat.zero_le (Int.natAbs (Int.negSucc m))\n        | Int.negSucc m, Nat.succ n => Nat.succ_le_succ (Nat.div_le_self m (Nat.succ (Nat.add n 0))))));\nfun a b =>\nmatch b, Int.eq_nat_or_neg b with\n| .(↑n), Exists.intro n (Or.inl (Eq.refl ↑n)) => this a n\n| .(-↑n), Exists.intro n (Or.inr (Eq.refl (-↑n))) =>\n  Eq.mpr (id (Int.ediv_neg a ↑n ▸ Eq.refl (|a / -↑n| ≤ |a|)))\n    (Eq.mpr (id (abs_neg (a / ↑n) ▸ Eq.refl (|(-(a / ↑n))| ≤ |a|))) (this a n))","name":"Int.abs_ediv_le_abs","depth":28},{"term":"fun x =>\n  if h : x = 0 then\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (Eq.trans (congrArg Real.log (Eq.trans (congrArg abs h) abs_zero)) Real.log_zero))\n          (Eq.trans (congrArg Real.log h) Real.log_zero))\n        (eq_self 0))\n  else\n    Eq.mpr (id (Eq.symm (propext Real.exp_eq_exp) ▸ Eq.refl (Real.log |x| = Real.log x)))\n      (Eq.mpr (id (Real.exp_log_eq_abs h ▸ Eq.refl (rexp (Real.log |x|) = rexp (Real.log x))))\n        (Eq.mpr (id (Real.exp_log_eq_abs (LT.lt.ne' (Iff.mpr abs_pos h)) ▸ Eq.refl (rexp (Real.log |x|) = |x|)))\n          (Eq.mpr (id (abs_abs x ▸ Eq.refl (|(|x|)| = |x|))) (Eq.refl |x|))))","name":"Real.log_abs","depth":28}],"kind":"Lean.Parser.Term.paren","examples":[],"count":12}
{"noDocExamples":[{"term":"Cardinal.mk_denumerable ℕ+","name":"Cardinal.mk_pNat","depth":2}],"kind":"«termℕ+»","examples":[{"term":"{ toEquiv := Equiv.pnatEquivNat, map_rel_iff' := (_ : ∀ {a b : ℕ+}, PNat.natPred a ≤ PNat.natPred b ↔ a ≤ b) }","name":"OrderIso.pnatIsoNat","doc":"The order isomorphism between ℕ and ℕ+ given by `succ`. ","depth":14},{"term":"fun R [CommRing R] R' [Field R'] => (n : ℕ+) × (char : AddChar R (CyclotomicField n R')) ×' AddChar.IsPrimitive char","name":"AddChar.PrimitiveAddChar","doc":"Definition for a primitive additive character on a finite ring `R` into a cyclotomic extension\nof a field `R'`. It records which cyclotomic extension it is, the character, and the\nfact that the character is primitive. ","depth":16},{"term":"fun A B [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension ∅ A B] =>\n  Eq.mpr (id Mathlib.NumberTheory.Cyclotomic.Basic._auxLemma.2)\n    (Eq.mp\n      (Eq.trans\n        (Eq.trans (Mathlib.NumberTheory.Cyclotomic.Basic._auxLemma.1 ∅ A B)\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun {n} =>\n                  Eq.trans (implies_congr (Mathlib.Data.Set.Basic._auxLemma.8 n) (Eq.refl (∃ r, IsPrimitiveRoot r ↑n)))\n                    Mathlib.Logic.IsEmpty._auxLemma.1)\n                (Std.Logic._auxLemma.32 ℕ+)))\n            (forall_congr fun x =>\n              congrArg (Membership.mem x)\n                (Eq.trans\n                  (congrArg (Algebra.adjoin A)\n                    (congrArg setOf\n                      (funext fun b =>\n                        Eq.trans\n                          (congrArg Exists\n                            (funext fun n =>\n                              Eq.trans (congrFun (congrArg And (Mathlib.Data.Set.Basic._auxLemma.8 n)) (b ^ ↑n = 1))\n                                (false_and (b ^ ↑n = 1))))\n                          Std.Logic._auxLemma.31)))\n                  (Algebra.adjoin_empty A B)))))\n        (true_and (∀ (x : B), x ∈ ⊥)))\n      h)","name":"IsCyclotomicExtension.empty","doc":"If `IsCyclotomicExtension ∅ A B`, then the image of `A` in `B` equals `B`. ","depth":45},{"term":"fun {p} a hz hi =>\n  PNat.strongInductionOn a fun k =>\n    Subtype.casesOn (motive := fun x => ((m : ℕ+) → m < x → p m) → p x) k fun k kprop hk =>\n      Nat.casesOn (motive := fun t => k = t → p { val := k, property := kprop }) k\n        (fun h =>\n          Eq.ndrec (motive := fun k =>\n            (kprop : 0 < k) →\n              ((m : ℕ+) → m < { val := k, property := kprop } → p m) → p { val := k, property := kprop })\n            (fun kprop hk => False.elim (_ : False)) (_ : Nat.zero = k) kprop hk)\n        (fun k_1 h =>\n          Eq.ndrec (motive := fun k =>\n            (kprop : 0 < k) →\n              ((m : ℕ+) → m < { val := k, property := kprop } → p m) → p { val := k, property := kprop })\n            (fun kprop hk =>\n              Nat.casesOn (motive := fun t => k_1 = t → p { val := Nat.succ k_1, property := kprop }) k_1\n                (fun h =>\n                  Eq.ndrec (motive := fun k =>\n                    (kprop : 0 < Nat.succ k) →\n                      ((m : ℕ+) → m < { val := Nat.succ k, property := kprop } → p m) →\n                        p { val := Nat.succ k, property := kprop })\n                    (fun kprop hk => hz) (_ : Nat.zero = k_1) kprop hk)\n                (fun k h =>\n                  Eq.ndrec (motive := fun k =>\n                    (kprop : 0 < Nat.succ k) →\n                      ((m : ℕ+) → m < { val := Nat.succ k, property := kprop } → p m) →\n                        p { val := Nat.succ k, property := kprop })\n                    (fun kprop hk =>\n                      hi { val := Nat.succ k, property := (_ : 0 < Nat.succ k) } fun m hm =>\n                        hk m (_ : (fun a => ↑a) m < Nat.succ (k + 1)))\n                    (_ : Nat.succ k = k_1) kprop hk)\n                (_ : k_1 = k_1))\n            (_ : Nat.succ k_1 = k) kprop hk)\n        (_ : k = k)","name":"PNat.caseStrongInductionOn","doc":"Strong induction on `ℕ+`, with `n = 1` treated separately. ","depth":46}],"count":12}
{"noDocExamples":[],"kind":"«term__[_]_?»","examples":[{"term":"fun x x args => pure (Array.map some (Array.push args (Option.getD args[0]? default)))","name":"Simps.copyFirst","doc":"Find arguments by duplicating the first argument. Used for `pow`. ","depth":19},{"term":"fun x x args => pure (Array.map some (Array.push args (Option.getD args[1]? default)))","name":"Simps.copySecond","doc":"Find arguments by duplicating the first argument. Used for `smul`. ","depth":19},{"term":"fun x x args => pure #[some (Option.getD args[0]? default), some (Lean.mkRawNatLit 1)]","name":"Simps.findOneArgs","doc":"Find arguments for the `One` class. ","depth":21},{"term":"fun x x args => pure #[some (Option.getD args[0]? default), some (Lean.mkRawNatLit 0)]","name":"Simps.findZeroArgs","doc":"Find arguments for the `Zero` class. ","depth":21},{"term":"fun x x args => pure (Array.map some (#[Lean.Expr.const `Nat [], Option.getD args[0]? default] ++ args))","name":"Simps.nsmulArgs","doc":"Find arguments by prepending `ℕ` and duplicating the first argument. Used for `nsmul`. ","depth":24}],"count":12}
{"noDocExamples":[],"kind":"«term_≃*_»","examples":[{"term":"fun M [Mul M] => M ≃* M","name":"MulAut","doc":"The group of multiplicative automorphisms. ","depth":6},{"term":"fun {M} {N} [Unique M] [Unique N] [Mul M] [Mul N] =>\n  { toInhabited := { default := MulEquiv.mulEquivOfUnique }, uniq := (_ : ∀ (x : M ≃* N), x = default) }","name":"MulEquiv.instUniqueMulEquiv","doc":"There is a unique monoid homomorphism between two monoids with a unique element. ","depth":15},{"term":"fun {M} [Monoid M] =>\n  MulDistribMulAction.mk (_ : ∀ (f : M ≃* M) (x y : M), ↑f (x * y) = ↑f x * ↑f y) (_ : ∀ (h : M ≃* M), ↑h 1 = 1)","name":"MulAut.applyMulDistribMulAction","doc":"The tautological action by `MulAut M` on `M`.\n\nThis generalizes `Function.End.applyMulAction`. ","depth":27},{"term":"fun {G} {H} [AddZeroClass G] [MulOneClass H] =>\n  {\n    toFun := fun f =>\n      {\n        toEquiv :=\n          { toFun := ↑(↑AddMonoidHom.toMultiplicative'' (AddEquiv.toAddMonoidHom f)),\n            invFun := ↑(↑AddMonoidHom.toMultiplicative' (AddEquiv.toAddMonoidHom (AddEquiv.symm f))),\n            left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n            right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n        map_mul' :=\n          (_ : ∀ (x y : G), Equiv.toFun f.toEquiv (x + y) = Equiv.toFun f.toEquiv x + Equiv.toFun f.toEquiv y) },\n    invFun := fun f =>\n      {\n        toEquiv :=\n          { toFun := ↑(MulEquiv.toMonoidHom f), invFun := ↑(MulEquiv.toMonoidHom (MulEquiv.symm f)),\n            left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n            right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n        map_add' :=\n          (_ :\n            ∀ (x y : Multiplicative G),\n              Equiv.toFun f.toEquiv (x * y) = Equiv.toFun f.toEquiv x * Equiv.toFun f.toEquiv y) },\n    left_inv :=\n      (_ :\n        ∀ (x : G ≃+ Additive H),\n          (fun f =>\n                {\n                  toEquiv :=\n                    { toFun := ↑(MulEquiv.toMonoidHom f), invFun := ↑(MulEquiv.toMonoidHom (MulEquiv.symm f)),\n                      left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n                      right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n                  map_add' :=\n                    (_ :\n                      ∀ (x y : Multiplicative G),\n                        Equiv.toFun f.toEquiv (x * y) = Equiv.toFun f.toEquiv x * Equiv.toFun f.toEquiv y) })\n              ((fun f =>\n                  {\n                    toEquiv :=\n                      { toFun := ↑(↑AddMonoidHom.toMultiplicative'' (AddEquiv.toAddMonoidHom f)),\n                        invFun := ↑(↑AddMonoidHom.toMultiplicative' (AddEquiv.toAddMonoidHom (AddEquiv.symm f))),\n                        left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n                        right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n                    map_mul' :=\n                      (_ :\n                        ∀ (x y : G),\n                          Equiv.toFun f.toEquiv (x + y) = Equiv.toFun f.toEquiv x + Equiv.toFun f.toEquiv y) })\n                x) =\n            x),\n    right_inv :=\n      (_ :\n        ∀ (x : Multiplicative G ≃* H),\n          (fun f =>\n                {\n                  toEquiv :=\n                    { toFun := ↑(↑AddMonoidHom.toMultiplicative'' (AddEquiv.toAddMonoidHom f)),\n                      invFun := ↑(↑AddMonoidHom.toMultiplicative' (AddEquiv.toAddMonoidHom (AddEquiv.symm f))),\n                      left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n                      right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n                  map_mul' :=\n                    (_ :\n                      ∀ (x y : G), Equiv.toFun f.toEquiv (x + y) = Equiv.toFun f.toEquiv x + Equiv.toFun f.toEquiv y) })\n              ((fun f =>\n                  {\n                    toEquiv :=\n                      { toFun := ↑(MulEquiv.toMonoidHom f), invFun := ↑(MulEquiv.toMonoidHom (MulEquiv.symm f)),\n                        left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n                        right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n                    map_add' :=\n                      (_ :\n                        ∀ (x y : Multiplicative G),\n                          Equiv.toFun f.toEquiv (x * y) = Equiv.toFun f.toEquiv x * Equiv.toFun f.toEquiv y) })\n                x) =\n            x) }","name":"AddEquiv.toMultiplicative''","doc":"Reinterpret `G ≃+ Additive H` as `Multiplicative G ≃* H`. ","depth":31},{"term":"fun {G} {H} [AddZeroClass G] [AddZeroClass H] =>\n  {\n    toFun := fun f =>\n      {\n        toEquiv :=\n          { toFun := ↑(↑AddMonoidHom.toMultiplicative (AddEquiv.toAddMonoidHom f)),\n            invFun := ↑(↑AddMonoidHom.toMultiplicative (AddEquiv.toAddMonoidHom (AddEquiv.symm f))),\n            left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n            right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n        map_mul' :=\n          (_ : ∀ (x y : G), Equiv.toFun f.toEquiv (x + y) = Equiv.toFun f.toEquiv x + Equiv.toFun f.toEquiv y) },\n    invFun := fun f =>\n      {\n        toEquiv :=\n          { toFun := ↑(MulEquiv.toMonoidHom f), invFun := ↑(MulEquiv.toMonoidHom (MulEquiv.symm f)),\n            left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n            right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n        map_add' :=\n          (_ :\n            ∀ (x y : Multiplicative G),\n              Equiv.toFun f.toEquiv (x * y) = Equiv.toFun f.toEquiv x * Equiv.toFun f.toEquiv y) },\n    left_inv :=\n      (_ :\n        ∀ (x : G ≃+ H),\n          (fun f =>\n                {\n                  toEquiv :=\n                    { toFun := ↑(MulEquiv.toMonoidHom f), invFun := ↑(MulEquiv.toMonoidHom (MulEquiv.symm f)),\n                      left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n                      right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n                  map_add' :=\n                    (_ :\n                      ∀ (x y : Multiplicative G),\n                        Equiv.toFun f.toEquiv (x * y) = Equiv.toFun f.toEquiv x * Equiv.toFun f.toEquiv y) })\n              ((fun f =>\n                  {\n                    toEquiv :=\n                      { toFun := ↑(↑AddMonoidHom.toMultiplicative (AddEquiv.toAddMonoidHom f)),\n                        invFun := ↑(↑AddMonoidHom.toMultiplicative (AddEquiv.toAddMonoidHom (AddEquiv.symm f))),\n                        left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n                        right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n                    map_mul' :=\n                      (_ :\n                        ∀ (x y : G),\n                          Equiv.toFun f.toEquiv (x + y) = Equiv.toFun f.toEquiv x + Equiv.toFun f.toEquiv y) })\n                x) =\n            x),\n    right_inv :=\n      (_ :\n        ∀ (x : Multiplicative G ≃* Multiplicative H),\n          (fun f =>\n                {\n                  toEquiv :=\n                    { toFun := ↑(↑AddMonoidHom.toMultiplicative (AddEquiv.toAddMonoidHom f)),\n                      invFun := ↑(↑AddMonoidHom.toMultiplicative (AddEquiv.toAddMonoidHom (AddEquiv.symm f))),\n                      left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n                      right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n                  map_mul' :=\n                    (_ :\n                      ∀ (x y : G), Equiv.toFun f.toEquiv (x + y) = Equiv.toFun f.toEquiv x + Equiv.toFun f.toEquiv y) })\n              ((fun f =>\n                  {\n                    toEquiv :=\n                      { toFun := ↑(MulEquiv.toMonoidHom f), invFun := ↑(MulEquiv.toMonoidHom (MulEquiv.symm f)),\n                        left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n                        right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n                    map_add' :=\n                      (_ :\n                        ∀ (x y : Multiplicative G),\n                          Equiv.toFun f.toEquiv (x * y) = Equiv.toFun f.toEquiv x * Equiv.toFun f.toEquiv y) })\n                x) =\n            x) }","name":"AddEquiv.toMultiplicative","doc":"Reinterpret `G ≃+ H` as `Multiplicative G ≃* Multiplicative H`. ","depth":31}],"count":12}
{"noDocExamples":[],"kind":"«term_→ₛₗ[_]_»","examples":[{"term":"fun {R} {R₂} {M} {M₂} [Semiring R] [Semiring R₂] [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module R₂ M₂]\n    {σ₁₂} =>\n  { toZeroHom := { toFun := LinearMap.toAddMonoidHom, map_zero' := (_ : LinearMap.toAddMonoidHom 0 = 0) },\n    map_add' :=\n      (_ :\n        ∀ (x y : M →ₛₗ[σ₁₂] M₂),\n          ZeroHom.toFun { toFun := LinearMap.toAddMonoidHom, map_zero' := (_ : LinearMap.toAddMonoidHom 0 = 0) }\n              (x + y) =\n            ZeroHom.toFun { toFun := LinearMap.toAddMonoidHom, map_zero' := (_ : LinearMap.toAddMonoidHom 0 = 0) } x +\n              ZeroHom.toFun { toFun := LinearMap.toAddMonoidHom, map_zero' := (_ : LinearMap.toAddMonoidHom 0 = 0) }\n                y) }","name":"LinearMap.toAddMonoidHom'","doc":"`LinearMap.toAddMonoidHom` promoted to a `AddMonoidHom` ","depth":32},{"term":"fun {R₁} {R₂} {M} {M₂} [Semiring R₁] [Semiring R₂] [AddCommMonoid M] [AddCommMonoid M₂] [Module R₁ M] [Module R₂ M₂]\n    {σ₁₂} =>\n  Function.Injective.addCommMonoid (fun f => ↑f) (_ : Function.Injective fun f => ↑f) (_ : ↑0 = ↑0)\n    (_ : ∀ (x x_1 : M →ₛₗ[σ₁₂] M₂), ↑(x + x_1) = ↑(x + x_1))\n    (_ : ∀ (x : M →ₛₗ[σ₁₂] M₂) (x_1 : ℕ), ↑(x_1 • x) = ↑(x_1 • x))","name":"LinearMap.addCommMonoid","doc":"The type of linear maps is an additive monoid. ","depth":33},{"term":"fun {R} {R₂} {M} {M₂} [Semiring R] [Semiring R₂] [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module R₂ M₂] {σ₁₂}\n    a =>\n  { toZeroHom := { toFun := fun f => ↑f a, map_zero' := (_ : (fun f => ↑f a) 0 = (fun f => ↑f a) 0) },\n    map_add' := (_ : ∀ (f g : M →ₛₗ[σ₁₂] M₂), ↑(f + g) a = ↑f a + ↑g a) }","name":"LinearMap.evalAddMonoidHom","doc":"Evaluation of a `σ₁₂`-linear map at a fixed `a`, as an `AddMonoidHom`. ","depth":34},{"term":"fun {R₁} {R₂} {M} {N₂} [Semiring R₁] [Semiring R₂] [AddCommMonoid M] [AddCommGroup N₂] [Module R₁ M] [Module R₂ N₂]\n    {σ₁₂} =>\n  Function.Injective.addCommGroup (fun f => ↑f) (_ : Function.Injective fun f => ↑f) (_ : ↑0 = ↑0)\n    (_ : ∀ (x x_1 : M →ₛₗ[σ₁₂] N₂), ↑(x + x_1) = ↑(x + x_1)) (_ : ∀ (x : M →ₛₗ[σ₁₂] N₂), ↑(-x) = ↑(-x))\n    (_ : ∀ (x x_1 : M →ₛₗ[σ₁₂] N₂), ↑(x - x_1) = ↑(x - x_1))\n    (_ : ∀ (x : M →ₛₗ[σ₁₂] N₂) (x_1 : ℕ), ↑(x_1 • x) = ↑(x_1 • x))\n    (_ : ∀ (x : M →ₛₗ[σ₁₂] N₂) (x_1 : ℤ), ↑(x_1 • x) = ↑(x_1 • x))","name":"LinearMap.addCommGroup","doc":"The type of linear maps is an additive group. ","depth":39},{"term":"fun {R} [CommSemiring R] {R₂} [CommSemiring R₂] {R₃} [CommSemiring R₃] {M} {N} {P} [AddCommMonoid M] [AddCommMonoid N]\n    [AddCommMonoid P] [Module R M] [Module R₂ N] [Module R₃ P] {σ₂₃} {σ₁₃} =>\n  {\n    toAddHom :=\n      { toFun := LinearMap.flip,\n        map_add' := (_ : ∀ (x x_1 : M →ₛₗ[σ₁₃] N →ₛₗ[σ₂₃] P), LinearMap.flip (x + x_1) = LinearMap.flip (x + x_1)) },\n    map_smul' :=\n      (_ :\n        ∀ (x : R₃) (x_1 : M →ₛₗ[σ₁₃] N →ₛₗ[σ₂₃] P),\n          AddHom.toFun\n              { toFun := LinearMap.flip,\n                map_add' :=\n                  (_ : ∀ (x x_2 : M →ₛₗ[σ₁₃] N →ₛₗ[σ₂₃] P), LinearMap.flip (x + x_2) = LinearMap.flip (x + x_2)) }\n              (x • x_1) =\n            AddHom.toFun\n              { toFun := LinearMap.flip,\n                map_add' :=\n                  (_ : ∀ (x x_2 : M →ₛₗ[σ₁₃] N →ₛₗ[σ₂₃] P), LinearMap.flip (x + x_2) = LinearMap.flip (x + x_2)) }\n              (x • x_1)) }","name":"LinearMap.lflip","doc":"Given a linear map from `M` to linear maps from `N` to `P`, i.e., a bilinear map `M → N → P`,\nchange the order of variables and get a linear map from `N` to linear maps from `M` to `P`. ","depth":45}],"count":11}
{"noDocExamples":[{"term":"fun {C} [CategoryTheory.Category.{u_1, u_2} C] [CategoryTheory.MonoidalCategory C] {X Y₁ Y₂} p₁ p₂ =>\n  Eq.mpr\n    (id\n      (Eq.symm CategoryTheory.comp_rightAdjointMate ▸\n        Eq.refl\n          (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Xᘁ)\n              (CategoryTheory.CategoryStruct.id Xᘁ) =\n            CategoryTheory.CategoryStruct.id Y₂)))\n    (Eq.mpr\n      (id\n        (CategoryTheory.Category.comp_id (CategoryTheory.CategoryStruct.id X) ▸\n          Eq.refl\n            (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X)\n                  (CategoryTheory.CategoryStruct.id X)ᘁ =\n              CategoryTheory.CategoryStruct.id Y₂)))\n      (Eq.mpr\n        (id\n          (CategoryTheory.rightAdjointMate_id ▸\n            Eq.refl (CategoryTheory.CategoryStruct.id Xᘁ = CategoryTheory.CategoryStruct.id Y₂)))\n        (Eq.refl (CategoryTheory.CategoryStruct.id Xᘁ))))","name":"CategoryTheory.rightDualIso.proof_2","depth":31},{"term":"fun {C} [CategoryTheory.Category.{u_1, u_2} C] [CategoryTheory.MonoidalCategory C] {X Y₁ Y₂} p₁ p₂ =>\n  Eq.mpr\n    (id\n      (Eq.symm CategoryTheory.comp_rightAdjointMate ▸\n        Eq.refl\n          (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Xᘁ)\n              (CategoryTheory.CategoryStruct.id Xᘁ) =\n            CategoryTheory.CategoryStruct.id Y₁)))\n    (Eq.mpr\n      (id\n        (CategoryTheory.Category.comp_id (CategoryTheory.CategoryStruct.id X) ▸\n          Eq.refl\n            (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X)\n                  (CategoryTheory.CategoryStruct.id X)ᘁ =\n              CategoryTheory.CategoryStruct.id Y₁)))\n      (Eq.mpr\n        (id\n          (CategoryTheory.rightAdjointMate_id ▸\n            Eq.refl (CategoryTheory.CategoryStruct.id Xᘁ = CategoryTheory.CategoryStruct.id Y₁)))\n        (Eq.refl (CategoryTheory.CategoryStruct.id Xᘁ))))","name":"CategoryTheory.rightDualIso.proof_1","depth":31},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X Y} [CategoryTheory.HasRightDual X]\n    [CategoryTheory.HasRightDual Y] f =>\n  Equiv.injective (CategoryTheory.tensorLeftHomEquiv (CategoryTheory.MonoidalCategory.tensorUnit C) Y Yᘁ Xᘁ).symm\n    (of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (CategoryTheory.tensorLeftHomEquiv_symm_coevaluation_comp_id_tensor (fᘁ)))\n          (CategoryTheory.tensorLeftHomEquiv_symm_coevaluation_comp_tensor_id f))\n        (eq_self (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor Yᘁ).hom (fᘁ)))))","name":"CategoryTheory.coevaluation_comp_rightAdjointMate","depth":35}],"kind":"CategoryTheory.«term_ᘁ»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X Y} [CategoryTheory.HasRightDual X]\n    [CategoryTheory.HasRightDual Y] f =>\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor Yᘁ).inv\n    (CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Yᘁ) (η_ X Xᘁ))\n      (CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Yᘁ)\n          (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Xᘁ)))\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Yᘁ Y Xᘁ).inv\n          (CategoryTheory.CategoryStruct.comp\n            (CategoryTheory.MonoidalCategory.tensorHom (ε_ Y Yᘁ) (CategoryTheory.CategoryStruct.id Xᘁ))\n            (CategoryTheory.MonoidalCategory.leftUnitor Xᘁ).hom))))","name":"CategoryTheory.rightAdjointMate","doc":"The right adjoint mate `fᘁ : Xᘁ ⟶ Yᘁ` of a morphism `f : X ⟶ Y`. ","depth":27},{"term":"fun {C} {D} [CategoryTheory.Category.{u_3, u_1} C] [CategoryTheory.Category.{u_4, u_2} D]\n    [CategoryTheory.MonoidalCategory C] [CategoryTheory.MonoidalCategory D] F [CategoryTheory.IsEquivalence F.toFunctor]\n    X [CategoryTheory.HasRightDual (F.obj X)] =>\n  CategoryTheory.HasRightDual.mk ((CategoryTheory.Functor.inv F.toFunctor).obj (F.obj X)ᘁ)","name":"CategoryTheory.hasRightDualOfEquivalence","doc":"Pull back a right dual along an equivalence. ","depth":31}],"count":11}
{"noDocExamples":[{"term":"fun {R} [Ring R] {E} [AddCommGroup E] [Module R E] {F} [AddCommGroup F] [Module R F] =>\n  AddSemigroup.mk (_ : ∀ (f g h : E →ₗ.[R] F), f + g + h = f + (g + h))","name":"LinearPMap.instAddSemigroup","depth":19},{"term":"fun {R} [Ring R] {E} [AddCommGroup E] [Module R E] {F} [AddCommGroup F] [Module R F] =>\n  InvolutiveNeg.mk (_ : ∀ (f : E →ₗ.[R] F), - -f = f)","name":"LinearPMap.instInvolutiveNeg","depth":19},{"term":"fun {R} [Ring R] {E} [AddCommGroup E] [Module R E] {F} [AddCommGroup F] [Module R F] =>\n  AddCommMonoid.mk (_ : ∀ (f g : E →ₗ.[R] F), f + g = g + f)","name":"LinearPMap.instAddCommMonoid","depth":19},{"term":"fun {R} [Ring R] {E} [AddCommGroup E] [Module R E] {F} [AddCommGroup F] [Module R F] =>\n  OrderBot.mk\n    (_ :\n      ∀ (f : E →ₗ.[R] F),\n        ⊥.domain ≤ f.domain ∧ ∀ ⦃x : { x // x ∈ ⊥.domain }⦄ ⦃y : { x // x ∈ f.domain }⦄, ↑x = ↑y → ↑⊥ x = ↑f y)","name":"LinearPMap.orderBot","depth":21},{"term":"fun {R} [Ring R] {E} [AddCommGroup E] [Module R E] {F} [AddCommGroup F] [Module R F] =>\n  AddZeroClass.mk (_ : ∀ (f : E →ₗ.[R] F), 0 + f = f) (_ : ∀ (f : E →ₗ.[R] F), f + 0 = f)","name":"LinearPMap.instAddZeroClass","depth":21}],"kind":"«term_→ₗ.[_]_»","examples":[],"count":11}
{"noDocExamples":[],"kind":"«term_≃ₗ[_]_»","examples":[{"term":"fun R M [Semiring R] [AddCommMonoid M] [Module R M] =>\n  {\n    toEquiv :=\n      { toFun := LinearMap.GeneralLinearGroup.toLinearEquiv, invFun := LinearMap.GeneralLinearGroup.ofLinearEquiv,\n        left_inv :=\n          (_ :\n            ∀ (f : LinearMap.GeneralLinearGroup R M),\n              LinearMap.GeneralLinearGroup.ofLinearEquiv (LinearMap.GeneralLinearGroup.toLinearEquiv f) = f),\n        right_inv :=\n          (_ :\n            ∀ (f : M ≃ₗ[R] M),\n              LinearMap.GeneralLinearGroup.toLinearEquiv (LinearMap.GeneralLinearGroup.ofLinearEquiv f) = f) },\n    map_mul' :=\n      (_ :\n        ∀ (x y : LinearMap.GeneralLinearGroup R M),\n          Equiv.toFun\n              { toFun := LinearMap.GeneralLinearGroup.toLinearEquiv,\n                invFun := LinearMap.GeneralLinearGroup.ofLinearEquiv,\n                left_inv :=\n                  (_ :\n                    ∀ (f : LinearMap.GeneralLinearGroup R M),\n                      LinearMap.GeneralLinearGroup.ofLinearEquiv (LinearMap.GeneralLinearGroup.toLinearEquiv f) = f),\n                right_inv :=\n                  (_ :\n                    ∀ (f : M ≃ₗ[R] M),\n                      LinearMap.GeneralLinearGroup.toLinearEquiv (LinearMap.GeneralLinearGroup.ofLinearEquiv f) = f) }\n              (x * y) =\n            Equiv.toFun\n                { toFun := LinearMap.GeneralLinearGroup.toLinearEquiv,\n                  invFun := LinearMap.GeneralLinearGroup.ofLinearEquiv,\n                  left_inv :=\n                    (_ :\n                      ∀ (f : LinearMap.GeneralLinearGroup R M),\n                        LinearMap.GeneralLinearGroup.ofLinearEquiv (LinearMap.GeneralLinearGroup.toLinearEquiv f) = f),\n                  right_inv :=\n                    (_ :\n                      ∀ (f : M ≃ₗ[R] M),\n                        LinearMap.GeneralLinearGroup.toLinearEquiv (LinearMap.GeneralLinearGroup.ofLinearEquiv f) = f) }\n                x *\n              Equiv.toFun\n                { toFun := LinearMap.GeneralLinearGroup.toLinearEquiv,\n                  invFun := LinearMap.GeneralLinearGroup.ofLinearEquiv,\n                  left_inv :=\n                    (_ :\n                      ∀ (f : LinearMap.GeneralLinearGroup R M),\n                        LinearMap.GeneralLinearGroup.ofLinearEquiv (LinearMap.GeneralLinearGroup.toLinearEquiv f) = f),\n                  right_inv :=\n                    (_ :\n                      ∀ (f : M ≃ₗ[R] M),\n                        LinearMap.GeneralLinearGroup.toLinearEquiv (LinearMap.GeneralLinearGroup.ofLinearEquiv f) = f) }\n                y) }","name":"LinearMap.GeneralLinearGroup.generalLinearEquiv","doc":"The general linear group on `R` and `M` is multiplicatively equivalent to the type of linear\nequivalences between `M` and itself. ","depth":27},{"term":"fun {K} V V' [Ring K] [StrongRankCondition K] [AddCommGroup V] [Module K V] [Module.Free K V] [AddCommGroup V']\n    [Module K V'] [Module.Free K V'] cond =>\n  Classical.choice (_ : Nonempty (V ≃ₗ[K] V'))","name":"LinearEquiv.ofLiftRankEq","doc":"Two vector spaces are isomorphic if they have the same dimension. ","depth":28},{"term":"fun {K} V V₁ [Ring K] [StrongRankCondition K] [AddCommGroup V] [Module K V] [Module.Free K V] [AddCommGroup V₁]\n    [Module K V₁] [Module.Free K V₁] cond =>\n  Classical.choice (_ : Nonempty (V ≃ₗ[K] V₁))","name":"LinearEquiv.ofRankEq","doc":"Two vector spaces are isomorphic if they have the same dimension. ","depth":28},{"term":"fun {R} {M} {N} [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N] [IsNoetherian R M] f i =>\n  Nonempty.some (_ : Nonempty (N ≃ₗ[R] PUnit.{w + 1}))","name":"IsNoetherian.equivPUnitOfProdInjective","doc":"If `M ⊕ N` embeds into `M`, for `M` noetherian over `R`, then `N` is trivial.\n","depth":28},{"term":"fun {R} M N [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M]\n    [AddCommGroup N] [Module R N] [Module.Free R N] [Module.Finite R N] cond =>\n  Classical.choice (_ : Nonempty (M ≃ₗ[R] N))","name":"LinearEquiv.ofFinrankEq","doc":"Two finite and free modules are isomorphic if they have the same (finite) rank. ","depth":30}],"count":11}
{"noDocExamples":[{"term":"fun {α} {m0} {μ} {s} {f} hf hf₀ =>\n  Eq.mp\n    (congrArg (Eq (ENNReal.ofReal (⨍ (x : α) in s, f x ∂μ)))\n      (congrArg (HDiv.hDiv (∫⁻ (x : α) in s, ENNReal.ofReal (f x) ∂μ))\n        (Eq.trans\n          (MeasureTheory.Measure.restrict_apply (of_eq_true Mathlib.MeasureTheory.MeasurableSpaceDef._auxLemma.3))\n          (congrArg (↑↑μ) (Set.univ_inter s)))))\n    (MeasureTheory.ofReal_average hf hf₀)","name":"MeasureTheory.ofReal_setAverage","depth":23}],"kind":"MeasureTheory.«term⨍_In_,_∂_»","examples":[{"term":"fun {α} {E} {m0} [NormedAddCommGroup E] [NormedSpace ℝ E] [CompleteSpace E] {μ} {t} {f} {C} [StrictConvexSpace ℝ E] ht\n    h_le =>\n  Eq.mpr\n    (id\n      (Eq.symm (MeasureTheory.Measure.restrict_apply_univ t) ▸\n        Eq.refl\n          (f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ t)]\n              Function.const α (⨍ (x : α) in t, f x ∂μ) ∨\n            ‖∫ (x : α) in t, f x ∂μ‖ < ENNReal.toReal (↑↑μ t) * C)))\n    (ae_eq_const_or_norm_integral_lt_of_norm_le_const h_le)","name":"ae_eq_const_or_norm_set_integral_lt_of_norm_le_const","doc":"If `E` is a strictly convex normed space and `f : α → E` is a function such that `‖f x‖ ≤ C`\na.e. on a set `t` of finite measure, then either this function is a.e. equal to its average value on\n`t`, or the norm of its integral over `t` is strictly less than `(μ t).toReal * C`. ","depth":35},{"term":"fun {α} {E} {m0} [NormedAddCommGroup E] [NormedSpace ℝ E] [CompleteSpace E] {μ} {s} {t} {f}\n    [MeasureTheory.IsFiniteMeasure μ] hs h0 hfs hfi ht =>\n  if h0' : ↑↑μ (MeasureTheory.toMeasurable μ t)ᶜ = 0 then\n    Eq.mp (MeasureTheory.Measure.restrict_univ ▸ Eq.refl (⨍ (x : α) in Set.univ, f x ∂μ ∈ interior s))\n      (Eq.mp\n        (MeasureTheory.Measure.restrict_congr_set\n            (Eq.mp (Eq.symm (propext MeasureTheory.ae_eq_univ) ▸ Eq.refl (↑↑μ (MeasureTheory.toMeasurable μ t)ᶜ = 0))\n              h0') ▸\n          Eq.refl (⨍ (x : α) in MeasureTheory.toMeasurable μ t, f x ∂μ ∈ interior s))\n        (Eq.mp\n          (Eq.symm (MeasureTheory.Measure.restrict_toMeasurable (MeasureTheory.measure_ne_top μ t)) ▸\n            Eq.refl (⨍ (x : α) in t, f x ∂μ ∈ interior s))\n          ht))\n  else\n    Convex.openSegment_interior_closure_subset_interior hs\n      (Eq.mp\n        (Eq.symm (MeasureTheory.Measure.restrict_toMeasurable (MeasureTheory.measure_ne_top μ t)) ▸\n          Eq.refl (⨍ (x : α) in t, f x ∂μ ∈ interior s))\n        ht)\n      (Convex.set_average_mem_closure hs h0' (MeasureTheory.measure_ne_top μ (MeasureTheory.toMeasurable μ t)ᶜ)\n        (MeasureTheory.ae_restrict_of_ae hfs) (MeasureTheory.Integrable.integrableOn hfi))\n      (MeasureTheory.average_mem_openSegment_compl_self\n        (MeasurableSet.nullMeasurableSet (MeasureTheory.measurableSet_toMeasurable μ t))\n        (Eq.mp (Eq.symm (MeasureTheory.measure_toMeasurable t) ▸ Eq.refl (↑↑μ t ≠ 0)) h0) h0' hfi)","name":"Convex.average_mem_interior_of_set","doc":"If an integrable function `f : α → E` takes values in a convex set `s` and for some set `t` of\npositive measure, the average value of `f` over `t` belongs to the interior of `s`, then the average\nof `f` over the whole space belongs to the interior of `s`. ","depth":41},{"term":"fun {α} {E} {m0} [NormedAddCommGroup E] [NormedSpace ℝ E] [CompleteSpace E] {μ} {s} {t} {f} {g} hg hgc hsc h0 ht hfs hfi\n    hgi =>\n  id\n    (Eq.mp\n      (Eq.trans\n        (congrFun\n          (congrArg Membership.mem\n            (congrArg (Prod.mk (⨍ (x : α) in t, f x ∂μ))\n              (MeasureTheory.average_neg (MeasureTheory.Measure.restrict μ t) fun x => g (f x))))\n          {p | p.fst ∈ s ∧ -g p.fst ≤ p.snd})\n        (congrArg (And (⨍ (x : α) in t, f x ∂μ ∈ s)) Mathlib.Analysis.Convex.Integral._auxLemma.4))\n      (ConvexOn.set_average_mem_epigraph (ConcaveOn.neg hg) (ContinuousOn.neg hgc) hsc h0 ht hfs hfi\n        (MeasureTheory.Integrable.neg hgi)))","name":"ConcaveOn.set_average_mem_hypograph","doc":"**Jensen's inequality**: if a function `g : E → ℝ` is concave and continuous on a convex closed\nset `s`, `μ` is a finite non-zero measure on `α`, and `f : α → E` is a function sending\n`μ`-a.e. points of a set `t` to `s`, then the average value of `g ∘ f` over `t` is less than or\nequal to the value of `g` at the average value of `f` over `t` provided that both `f` and `g ∘ f`\nare integrable. ","depth":45},{"term":"fun {α} {m0} {μ} {s} {f} hμ hμ₁ hf =>\n  Iff.mpr pos_iff_ne_zero fun H =>\n    Eq.not_gt (MeasureTheory.integral_sub_average (MeasureTheory.Measure.restrict μ s) f)\n      (Iff.mpr\n        (MeasureTheory.set_integral_pos_iff_support_of_nonneg_ae\n          (eq_bot_mono\n            (MeasureTheory.measure_mono fun x hx =>\n              LT.lt.le\n                (Eq.mp\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg (Membership.mem x)\n                        (congrArg compl\n                          (congrArg setOf (funext fun x => Mathlib.MeasureTheory.Integral.Average._auxLemma.8))))\n                      (Mathlib.MeasureTheory.Integral.Average._auxLemma.9 {x | ⨍ (a : α) in s, f a ∂μ ≤ f x} x))\n                    Mathlib.MeasureTheory.Integral.Average._auxLemma.10)\n                  hx))\n            (Eq.mpr\n              (id\n                (MeasureTheory.Measure.restrict_apply₀\n                    (MeasureTheory.AEStronglyMeasurable.nullMeasurableSet_le hf.left\n                      MeasureTheory.aestronglyMeasurable_const) ▸\n                  Eq.refl (↑↑(MeasureTheory.Measure.restrict μ s) {x | f x ≤ ⨍ (a : α) in s, f a ∂μ} = 0)))\n              (Eq.mpr\n                (id\n                  (Set.inter_comm {x | f x ≤ ⨍ (a : α) in s, f a ∂μ} s ▸\n                    Eq.refl (↑↑μ ({x | f x ≤ ⨍ (a : α) in s, f a ∂μ} ∩ s) = 0)))\n                H)))\n          (MeasureTheory.Integrable.sub hf\n            (Iff.mpr MeasureTheory.integrableOn_const (Or.inr (Iff.mpr lt_top_iff_ne_top hμ₁)))))\n        (Eq.mpr\n          (id\n            (propext pos_iff_ne_zero ▸\n              Eq.refl (0 < ↑↑μ ((Function.support fun x => f x - ⨍ (a : α) in s, f a ∂μ) ∩ s))))\n          (Eq.mpr\n            (id\n              (Set.inter_comm (Function.support fun x => f x - ⨍ (a : α) in s, f a ∂μ) s ▸\n                Eq.refl (↑↑μ ((Function.support fun x => f x - ⨍ (a : α) in s, f a ∂μ) ∩ s) ≠ 0)))\n            (Eq.mpr\n              (id\n                (Eq.symm Set.diff_compl ▸\n                  Eq.refl (↑↑μ (s ∩ Function.support fun x => f x - ⨍ (a : α) in s, f a ∂μ) ≠ 0)))\n              (Eq.mpr\n                (id\n                  (Eq.symm Set.diff_inter_self_eq_diff ▸\n                    Eq.refl (↑↑μ (s \\ (Function.support fun x => f x - ⨍ (a : α) in s, f a ∂μ)ᶜ) ≠ 0)))\n                (Eq.mpr\n                  (id\n                    (MeasureTheory.measure_diff_null\n                        (eq_bot_mono\n                          (MeasureTheory.measure_mono\n                            (Set.inter_subset_inter_left s fun a ha => Eq.le (Iff.mp sub_eq_zero (of_not_not ha))))\n                          (MeasureTheory.Measure.measure_inter_eq_zero_of_restrict\n                            (Eq.mpr\n                              (id\n                                (MeasureTheory.Measure.restrict_apply₀\n                                    (MeasureTheory.AEStronglyMeasurable.nullMeasurableSet_le hf.left\n                                      MeasureTheory.aestronglyMeasurable_const) ▸\n                                  Eq.refl\n                                    (↑↑(MeasureTheory.Measure.restrict μ s) {x | f x ≤ ⨍ (a : α) in s, f a ∂μ} = 0)))\n                              (Eq.mpr\n                                (id\n                                  (Set.inter_comm {x | f x ≤ ⨍ (a : α) in s, f a ∂μ} s ▸\n                                    Eq.refl (↑↑μ ({x | f x ≤ ⨍ (a : α) in s, f a ∂μ} ∩ s) = 0)))\n                                H)))) ▸\n                      Eq.refl (↑↑μ (s \\ ((Function.support fun x => f x - ⨍ (a : α) in s, f a ∂μ)ᶜ ∩ s)) ≠ 0)))\n                  hμ))))))","name":"MeasureTheory.measure_le_setAverage_pos","doc":"**First moment method**. An integrable function is smaller than its mean on a set of positive\nmeasure. ","depth":49}],"count":11}
{"noDocExamples":[],"kind":"«term_→ₙ*_»","examples":[{"term":"fun {M} {N} [Mul M] [Mul N] =>\n  MulHomClass.mk\n    (_ : ∀ (self : M →ₙ* N) (x y : M), MulHom.toFun self (x * y) = MulHom.toFun self x * MulHom.toFun self y)","name":"MulHom.mulHomClass","doc":"`MulHom` is a type of multiplication-preserving homomorphisms ","depth":15},{"term":"fun α β [Mul α] [CommSemigroup β] =>\n  { toFun := fun g => ↑g, map_mul' := (_ : ∀ (x x_1 : α →ₙ* β), (fun g => ↑g) (x * x_1) = (fun g => ↑g) (x * x_1)) }","name":"MulHom.coeFn","doc":"Coercion of a `MulHom` into a function is itself a `MulHom`.\n\nSee also `MulHom.eval`. ","depth":19},{"term":"fun {α} {β} [Mul β] =>\n  {\n    toFun := fun f =>\n      { toFun := FreeMagma.liftAux f,\n        map_mul' := (_ : ∀ (x y : FreeMagma α), FreeMagma.liftAux f (x * y) = FreeMagma.liftAux f (x * y)) },\n    invFun := fun F => ↑F ∘ FreeMagma.of,\n    left_inv :=\n      (_ :\n        ∀ (f : α → β),\n          (fun F => ↑F ∘ FreeMagma.of)\n              ((fun f =>\n                  { toFun := FreeMagma.liftAux f,\n                    map_mul' :=\n                      (_ : ∀ (x y : FreeMagma α), FreeMagma.liftAux f (x * y) = FreeMagma.liftAux f (x * y)) })\n                f) =\n            (fun F => ↑F ∘ FreeMagma.of)\n              ((fun f =>\n                  { toFun := FreeMagma.liftAux f,\n                    map_mul' :=\n                      (_ : ∀ (x y : FreeMagma α), FreeMagma.liftAux f (x * y) = FreeMagma.liftAux f (x * y)) })\n                f)),\n    right_inv :=\n      (_ :\n        ∀ (F : FreeMagma α →ₙ* β),\n          (fun f =>\n                { toFun := FreeMagma.liftAux f,\n                  map_mul' := (_ : ∀ (x y : FreeMagma α), FreeMagma.liftAux f (x * y) = FreeMagma.liftAux f (x * y)) })\n              ((fun F => ↑F ∘ FreeMagma.of) F) =\n            F) }","name":"FreeMagma.lift","doc":"The universal property of the free magma expressing its adjointness. ","depth":22},{"term":"fun {α} {β} [Semigroup β] =>\n  {\n    toFun := fun f =>\n      { toFun := fun x => List.foldl (fun a b => a * f b) (f x.head) x.tail,\n        map_mul' :=\n          (_ :\n            ∀ (x y : FreeSemigroup α),\n              List.foldl (fun a b => a * f b) (f x.head) (x.tail ++ y.head :: y.tail) =\n                List.foldl (fun x y => x * f y) (f x.head) x.tail *\n                  List.foldl (fun x y => x * f y) (f y.head) y.tail) },\n    invFun := fun f => ↑f ∘ FreeSemigroup.of,\n    left_inv :=\n      (_ :\n        ∀ (f : α → β),\n          (fun f => ↑f ∘ FreeSemigroup.of)\n              ((fun f =>\n                  { toFun := fun x => List.foldl (fun a b => a * f b) (f x.head) x.tail,\n                    map_mul' :=\n                      (_ :\n                        ∀ (x y : FreeSemigroup α),\n                          List.foldl (fun a b => a * f b) (f x.head) (x.tail ++ y.head :: y.tail) =\n                            List.foldl (fun x y => x * f y) (f x.head) x.tail *\n                              List.foldl (fun x y => x * f y) (f y.head) y.tail) })\n                f) =\n            (fun f => ↑f ∘ FreeSemigroup.of)\n              ((fun f =>\n                  { toFun := fun x => List.foldl (fun a b => a * f b) (f x.head) x.tail,\n                    map_mul' :=\n                      (_ :\n                        ∀ (x y : FreeSemigroup α),\n                          List.foldl (fun a b => a * f b) (f x.head) (x.tail ++ y.head :: y.tail) =\n                            List.foldl (fun x y => x * f y) (f x.head) x.tail *\n                              List.foldl (fun x y => x * f y) (f y.head) y.tail) })\n                f)),\n    right_inv :=\n      (_ :\n        ∀ (f : FreeSemigroup α →ₙ* β),\n          (fun f =>\n                { toFun := fun x => List.foldl (fun a b => a * f b) (f x.head) x.tail,\n                  map_mul' :=\n                    (_ :\n                      ∀ (x y : FreeSemigroup α),\n                        List.foldl (fun a b => a * f b) (f x.head) (x.tail ++ y.head :: y.tail) =\n                          List.foldl (fun x y => x * f y) (f x.head) x.tail *\n                            List.foldl (fun x y => x * f y) (f y.head) y.tail) })\n              ((fun f => ↑f ∘ FreeSemigroup.of) f) =\n            f) }","name":"FreeSemigroup.lift","doc":"Lifts a function `α → β` to a semigroup homomorphism `FreeSemigroup α → β` given\na semigroup `β`. ","depth":22},{"term":"fun {α} [Mul α] {β} [Semigroup β] =>\n  {\n    toFun := fun f =>\n      { toFun := fun x => Quot.liftOn x ↑f (_ : ∀ (a b : α), Magma.AssocRel α a b → ↑f a = ↑f b),\n        map_mul' :=\n          (_ :\n            ∀ (x y : Magma.AssocQuotient α),\n              (fun x => Quot.liftOn x ↑f (_ : ∀ (a b : α), Magma.AssocRel α a b → ↑f a = ↑f b)) (x * y) =\n                (fun x => Quot.liftOn x ↑f (_ : ∀ (a b : α), Magma.AssocRel α a b → ↑f a = ↑f b)) x *\n                  (fun x => Quot.liftOn x ↑f (_ : ∀ (a b : α), Magma.AssocRel α a b → ↑f a = ↑f b)) y) },\n    invFun := fun f => MulHom.comp f Magma.AssocQuotient.of,\n    left_inv :=\n      (_ :\n        ∀ (f : α →ₙ* β),\n          (fun f => MulHom.comp f Magma.AssocQuotient.of)\n              ((fun f =>\n                  { toFun := fun x => Quot.liftOn x ↑f (_ : ∀ (a b : α), Magma.AssocRel α a b → ↑f a = ↑f b),\n                    map_mul' :=\n                      (_ :\n                        ∀ (x y : Magma.AssocQuotient α),\n                          (fun x => Quot.liftOn x ↑f (_ : ∀ (a b : α), Magma.AssocRel α a b → ↑f a = ↑f b)) (x * y) =\n                            (fun x => Quot.liftOn x ↑f (_ : ∀ (a b : α), Magma.AssocRel α a b → ↑f a = ↑f b)) x *\n                              (fun x => Quot.liftOn x ↑f (_ : ∀ (a b : α), Magma.AssocRel α a b → ↑f a = ↑f b)) y) })\n                f) =\n            f),\n    right_inv :=\n      (_ :\n        ∀ (f : Magma.AssocQuotient α →ₙ* β),\n          (fun f =>\n                { toFun := fun x => Quot.liftOn x ↑f (_ : ∀ (a b : α), Magma.AssocRel α a b → ↑f a = ↑f b),\n                  map_mul' :=\n                    (_ :\n                      ∀ (x y : Magma.AssocQuotient α),\n                        (fun x => Quot.liftOn x ↑f (_ : ∀ (a b : α), Magma.AssocRel α a b → ↑f a = ↑f b)) (x * y) =\n                          (fun x => Quot.liftOn x ↑f (_ : ∀ (a b : α), Magma.AssocRel α a b → ↑f a = ↑f b)) x *\n                            (fun x => Quot.liftOn x ↑f (_ : ∀ (a b : α), Magma.AssocRel α a b → ↑f a = ↑f b)) y) })\n              ((fun f => MulHom.comp f Magma.AssocQuotient.of) f) =\n            f) }","name":"Magma.AssocQuotient.lift","doc":"Lifts a magma homomorphism `α → β` to a semigroup homomorphism `Magma.AssocQuotient α → β`\ngiven a semigroup `β`. ","depth":26}],"count":10}
{"noDocExamples":[{"term":"fun {α} {l₁ l₂} =>\n  Eq.mpr (id (Eq.symm (propext List.reverse_suffix) ▸ Eq.refl (List.reverse l₁ <+: List.reverse l₂ ↔ l₁ <:+ l₂)))\n    (of_eq_true\n      (Eq.trans\n        (congrFun (congrArg Iff (congr (congrArg List.isSuffix (List.reverse_reverse l₁)) (List.reverse_reverse l₂)))\n          (l₁ <:+ l₂))\n        (iff_self (l₁ <:+ l₂))))","name":"List.reverse_prefix","depth":20},{"term":"fun {α} p l =>\n  Eq.mpr (id (Eq.symm (propext List.reverse_suffix) ▸ Eq.refl (List.rdropWhile p l <+: l)))\n    (Eq.mpr (id (List.rdropWhile._eq_1 p l ▸ Eq.refl (List.reverse (List.rdropWhile p l) <:+ List.reverse l)))\n      (Eq.mpr\n        (id\n          (List.reverse_reverse (List.dropWhile p (List.reverse l)) ▸\n            Eq.refl (List.reverse (List.reverse (List.dropWhile p (List.reverse l))) <:+ List.reverse l)))\n        (List.dropWhile_suffix p)))","name":"List.rdropWhile_prefix","depth":22},{"term":"fun {α} p l =>\n  Eq.mpr (id (Eq.symm (propext List.reverse_prefix) ▸ Eq.refl (List.rtakeWhile p l <:+ l)))\n    (Eq.mpr (id (List.rtakeWhile._eq_1 p l ▸ Eq.refl (List.reverse (List.rtakeWhile p l) <+: List.reverse l)))\n      (Eq.mpr\n        (id\n          (List.reverse_reverse (List.takeWhile p (List.reverse l)) ▸\n            Eq.refl (List.reverse (List.reverse (List.takeWhile p (List.reverse l))) <+: List.reverse l)))\n        (List.takeWhile_prefix p)))","name":"List.rtakeWhile_suffix","depth":22},{"term":"fun {α} a l₁ b l₂ h =>\n  Eq.mpr (id (Eq.symm h ▸ Eq.refl (l₁ <+: l₂ ↔ a :: l₁ <+: b :: l₂)))\n    (Eq.mpr (id (propext (List.prefix_cons_inj a) ▸ Eq.refl (l₁ <+: l₂ ↔ a :: l₁ <+: a :: l₂))) Iff.rfl)","name":"List.decidablePrefix.proof_3","depth":23}],"kind":"List.«term_<+:_»","examples":[{"term":"fun {α} {l₁ l₂} =>\n  (fun {α} {l₁ l₂} =>\n      Eq.mpr (id (Eq.symm (propext List.reverse_suffix) ▸ Eq.refl (List.reverse l₁ <+: List.reverse l₂ ↔ l₁ <:+ l₂)))\n        (of_eq_true\n          (Eq.trans\n            (congrFun\n              (congrArg Iff (congr (congrArg List.isSuffix (List.reverse_reverse l₁)) (List.reverse_reverse l₂)))\n              (l₁ <:+ l₂))\n            (iff_self (l₁ <:+ l₂))))).mpr","name":"List.isSuffix.reverse","doc":"**Alias** of the reverse direction of `List.reverse_prefix`.","depth":27}],"count":10}
{"noDocExamples":[],"kind":"«term_≃+_»","examples":[{"term":"fun M [Add M] => M ≃+ M","name":"AddAut","doc":"The group of additive automorphisms.","depth":6},{"term":"fun {M} {N} [Unique M] [Unique N] [Add M] [Add N] =>\n  { toInhabited := { default := AddEquiv.addEquivOfUnique }, uniq := (_ : ∀ (x : M ≃+ N), x = default) }","name":"AddEquiv.instUniqueAddEquiv","doc":"There is a unique additive monoid homomorphism between two additive monoids with\na unique element.","depth":15},{"term":"fun {α} {β} [Add α] [Add β] =>\n  { toFun := fun f => AddEquiv.trans (AddEquiv.symm MulOpposite.opAddEquiv) (AddEquiv.trans f MulOpposite.opAddEquiv),\n    invFun := fun f => AddEquiv.trans MulOpposite.opAddEquiv (AddEquiv.trans f (AddEquiv.symm MulOpposite.opAddEquiv)),\n    left_inv :=\n      (_ :\n        ∀ (x : α ≃+ β),\n          (fun f => AddEquiv.trans MulOpposite.opAddEquiv (AddEquiv.trans f (AddEquiv.symm MulOpposite.opAddEquiv)))\n              ((fun f =>\n                  AddEquiv.trans (AddEquiv.symm MulOpposite.opAddEquiv) (AddEquiv.trans f MulOpposite.opAddEquiv))\n                x) =\n            (fun f => AddEquiv.trans MulOpposite.opAddEquiv (AddEquiv.trans f (AddEquiv.symm MulOpposite.opAddEquiv)))\n              ((fun f =>\n                  AddEquiv.trans (AddEquiv.symm MulOpposite.opAddEquiv) (AddEquiv.trans f MulOpposite.opAddEquiv))\n                x)),\n    right_inv :=\n      (_ :\n        ∀ (x : αᵐᵒᵖ ≃+ βᵐᵒᵖ),\n          (fun f => AddEquiv.trans (AddEquiv.symm MulOpposite.opAddEquiv) (AddEquiv.trans f MulOpposite.opAddEquiv))\n              ((fun f =>\n                  AddEquiv.trans MulOpposite.opAddEquiv (AddEquiv.trans f (AddEquiv.symm MulOpposite.opAddEquiv)))\n                x) =\n            (fun f => AddEquiv.trans (AddEquiv.symm MulOpposite.opAddEquiv) (AddEquiv.trans f MulOpposite.opAddEquiv))\n              ((fun f =>\n                  AddEquiv.trans MulOpposite.opAddEquiv (AddEquiv.trans f (AddEquiv.symm MulOpposite.opAddEquiv)))\n                x)) }","name":"AddEquiv.mulOp","doc":"An iso `α ≃+ β` can equivalently be viewed as an iso `αᵐᵒᵖ ≃+ βᵐᵒᵖ`. ","depth":18},{"term":"fun {A} [AddMonoid A] =>\n  DistribMulAction.mk (_ : ∀ (h : A ≃+ A), ↑h 0 = 0) (_ : ∀ (f : A ≃+ A) (x y : A), ↑f (x + y) = ↑f x + ↑f y)","name":"AddAut.applyDistribMulAction","doc":"The tautological action by `AddAut A` on `A`.\n\nThis generalizes `Function.End.applyMulAction`. ","depth":27},{"term":"fun {G} {H} [AddZeroClass G] [MulOneClass H] =>\n  {\n    toFun := fun f =>\n      {\n        toEquiv :=\n          { toFun := ↑(↑AddMonoidHom.toMultiplicative'' (AddEquiv.toAddMonoidHom f)),\n            invFun := ↑(↑AddMonoidHom.toMultiplicative' (AddEquiv.toAddMonoidHom (AddEquiv.symm f))),\n            left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n            right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n        map_mul' :=\n          (_ : ∀ (x y : G), Equiv.toFun f.toEquiv (x + y) = Equiv.toFun f.toEquiv x + Equiv.toFun f.toEquiv y) },\n    invFun := fun f =>\n      {\n        toEquiv :=\n          { toFun := ↑(MulEquiv.toMonoidHom f), invFun := ↑(MulEquiv.toMonoidHom (MulEquiv.symm f)),\n            left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n            right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n        map_add' :=\n          (_ :\n            ∀ (x y : Multiplicative G),\n              Equiv.toFun f.toEquiv (x * y) = Equiv.toFun f.toEquiv x * Equiv.toFun f.toEquiv y) },\n    left_inv :=\n      (_ :\n        ∀ (x : G ≃+ Additive H),\n          (fun f =>\n                {\n                  toEquiv :=\n                    { toFun := ↑(MulEquiv.toMonoidHom f), invFun := ↑(MulEquiv.toMonoidHom (MulEquiv.symm f)),\n                      left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n                      right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n                  map_add' :=\n                    (_ :\n                      ∀ (x y : Multiplicative G),\n                        Equiv.toFun f.toEquiv (x * y) = Equiv.toFun f.toEquiv x * Equiv.toFun f.toEquiv y) })\n              ((fun f =>\n                  {\n                    toEquiv :=\n                      { toFun := ↑(↑AddMonoidHom.toMultiplicative'' (AddEquiv.toAddMonoidHom f)),\n                        invFun := ↑(↑AddMonoidHom.toMultiplicative' (AddEquiv.toAddMonoidHom (AddEquiv.symm f))),\n                        left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n                        right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n                    map_mul' :=\n                      (_ :\n                        ∀ (x y : G),\n                          Equiv.toFun f.toEquiv (x + y) = Equiv.toFun f.toEquiv x + Equiv.toFun f.toEquiv y) })\n                x) =\n            x),\n    right_inv :=\n      (_ :\n        ∀ (x : Multiplicative G ≃* H),\n          (fun f =>\n                {\n                  toEquiv :=\n                    { toFun := ↑(↑AddMonoidHom.toMultiplicative'' (AddEquiv.toAddMonoidHom f)),\n                      invFun := ↑(↑AddMonoidHom.toMultiplicative' (AddEquiv.toAddMonoidHom (AddEquiv.symm f))),\n                      left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n                      right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n                  map_mul' :=\n                    (_ :\n                      ∀ (x y : G), Equiv.toFun f.toEquiv (x + y) = Equiv.toFun f.toEquiv x + Equiv.toFun f.toEquiv y) })\n              ((fun f =>\n                  {\n                    toEquiv :=\n                      { toFun := ↑(MulEquiv.toMonoidHom f), invFun := ↑(MulEquiv.toMonoidHom (MulEquiv.symm f)),\n                        left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n                        right_inv := (_ : Function.RightInverse f.invFun f.toFun) },\n                    map_add' :=\n                      (_ :\n                        ∀ (x y : Multiplicative G),\n                          Equiv.toFun f.toEquiv (x * y) = Equiv.toFun f.toEquiv x * Equiv.toFun f.toEquiv y) })\n                x) =\n            x) }","name":"AddEquiv.toMultiplicative''","doc":"Reinterpret `G ≃+ Additive H` as `Multiplicative G ≃* H`. ","depth":31}],"count":10}
{"noDocExamples":[{"term":"fun {α} {E} {F'} {G'} [Norm E] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G'] {l} =>\n  { trans := (_ : ∀ {a : α → E} {b : α → F'} {c : α → G'}, a =o[l] b → b =Θ[l] c → a =o[l] c) }","name":"Asymptotics.instTransForAllForAllForAllIsLittleOToNormIsThetaToNormIsLittleO","depth":18},{"term":"fun {α} {β} {β₂} [NormedAddCommGroup β] [Norm β₂] {l} =>\n  { trans := (_ : ∀ {a : α → β₂} {b c : α → β}, a =Θ[l] b → Asymptotics.IsEquivalent l b c → a =Θ[l] c) }","name":"Asymptotics.transIsThetaIsEquivalent","depth":19},{"term":"fun {α} {E} {F} [Norm E] [Norm F] {l} =>\n  { trans := (_ : ∀ {a : α → E} {b c : α → F}, a =Θ[l] b → b =ᶠ[l] c → a =Θ[l] c) }","name":"Asymptotics.instTransForAllForAllIsThetaEventuallyEq","depth":19},{"term":"fun {α} {β} {β₂} [NormedAddCommGroup β] [Norm β₂] {l} =>\n  { trans := (_ : ∀ {a b : α → β} {c : α → β₂}, Asymptotics.IsEquivalent l a b → b =Θ[l] c → a =Θ[l] c) }","name":"Asymptotics.transIsEquivalentIsTheta","depth":19},{"term":"fun {α} {E} {F} [Norm E] [Norm F] {l} =>\n  { trans := (_ : ∀ {a b : α → E} {c : α → F}, a =ᶠ[l] b → b =Θ[l] c → a =Θ[l] c) }","name":"Asymptotics.instTransForAllForAllEventuallyEqIsTheta","depth":19}],"kind":"Asymptotics.«term_=Θ[_]_»","examples":[],"count":10}
{"noDocExamples":[{"term":"fun {F} [NormedAddCommGroup F] [NormedSpace ℝ F] [CompleteSpace F] g a =>\n  Eq.mp\n    (congrFun\n      (congrArg Eq\n        (congrArg (MeasureTheory.integral MeasureTheory.volume) (funext fun x => congrArg g (mul_comm a⁻¹ x))))\n      (|a| • ∫ (y : ℝ), g y))\n    (MeasureTheory.Measure.integral_comp_inv_mul_left g a)","name":"MeasureTheory.Measure.integral_comp_inv_mul_right","depth":26},{"term":"fun {F} [NormedAddCommGroup F] [NormedSpace ℝ F] [CompleteSpace F] g a =>\n  Eq.mpr\n    (id\n      (congrFun\n        (congrArg Eq\n          (congrArg (MeasureTheory.integral MeasureTheory.volume) (funext fun x => congrArg g (mul_comm x a))))\n        (|a⁻¹| • ∫ (y : ℝ), g y)))\n    (MeasureTheory.Measure.integral_comp_mul_left g a)","name":"MeasureTheory.Measure.integral_comp_mul_right","depth":28}],"kind":"MeasureTheory.«term∫_,_»","examples":[{"term":"fun {Ω} [MeasureTheory.MeasureSpace Ω] [MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {p} hp hp' X hℒp hindep\n    hident =>\n  let_fun hmeas := fun i => Iff.mpr (ProbabilityTheory.IdentDistrib.aestronglyMeasurable_iff (hident i)) hℒp.left;\n  let_fun hint := MeasureTheory.Memℒp.integrable hp hℒp;\n  let_fun havg := fun n =>\n    Eq.mpr\n      (id\n        (congrFun\n          (congrArg MeasureTheory.AEStronglyMeasurable\n            (funext fun ω => div_eq_mul_inv (Finset.sum (Finset.range n) fun i => X i ω) ↑n))\n          MeasureTheory.volume))\n      (MeasureTheory.AEStronglyMeasurable.mul_const\n        (Finset.aestronglyMeasurable_sum (Finset.range n) fun i x => hmeas i) (↑n)⁻¹);\n  MeasureTheory.tendsto_Lp_of_tendstoInMeasure MeasureTheory.volume hp hp' havg\n    (MeasureTheory.memℒp_const (∫ (a : Ω), X 0 a))\n    (Eq.mpr\n      (id\n        ((funext fun n =>\n            funext fun ω =>\n              of_eq_true\n                (Eq.trans\n                  (congrArg (Eq ((Finset.sum (Finset.range n) fun i => X i ω) / ↑n))\n                    (congrFun (congrArg HDiv.hDiv (Finset.sum_apply ω (Finset.range n) fun c => X c)) ↑n))\n                  (eq_self ((Finset.sum (Finset.range n) fun i => X i ω) / ↑n)))) ▸\n          Eq.refl\n            (MeasureTheory.UnifIntegrable (fun n ω => (Finset.sum (Finset.range n) fun i => X i ω) / ↑n) p\n              MeasureTheory.volume)))\n      (MeasureTheory.uniformIntegrable_average hp\n            (ProbabilityTheory.Memℒp.uniformIntegrable_of_identDistrib hp hp' hℒp hident)).right.left)\n    (MeasureTheory.tendstoInMeasure_of_tendsto_ae havg\n      (ProbabilityTheory.strong_law_ae (fun i x => X i x) hint hindep hident))","name":"ProbabilityTheory.strong_law_Lp","doc":"**Strong law of large numbers**, Lᵖ version: if `X n` is a sequence of independent\nidentically distributed real-valued random variables in Lᵖ, then `∑ i in range n, X i / n`\nconverges in Lᵖ to `𝔼[X 0]`. ","depth":46},{"term":"fun T [Fact (0 < T)] {E} [NormedAddCommGroup E] [NormedSpace ℝ E] t f =>\n  Eq.mpr\n    (id\n      (intervalIntegral.integral_of_le\n          (le_of_not_gt fun a =>\n            Linarith.lt_irrefl\n              (Eq.mp\n                (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf t) (Mathlib.Tactic.Ring.atom_pf T)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (t ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (T ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf t)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul t (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero t (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (T ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                      (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf T)\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul T (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero T (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)) ▸\n                  Eq.refl (t + T - t + -T < 0))\n                (Left.add_neg (sub_neg_of_lt a) (neg_neg_of_pos Fact.out)))) ▸\n        Eq.refl (∫ (a : ℝ) in t..t + T, f ↑a = ∫ (b : AddCircle T), f b)))\n    (Eq.mpr\n      (id\n        (AddCircle.integral_preimage T t f ▸ Eq.refl (∫ (x : ℝ) in Set.Ioc t (t + T), f ↑x = ∫ (b : AddCircle T), f b)))\n      (Eq.refl (∫ (b : AddCircle T), f b)))","name":"AddCircle.intervalIntegral_preimage","doc":"The integral of an almost-everywhere strongly measurable function over `AddCircle T` is equal\nto the integral over an interval (t, t + T] in `ℝ` of its lift to `ℝ`. ","depth":47},{"term":"fun {b} hb =>\n  Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.mpr\n            (id\n              (pow_two (∫ (x : ℝ), cexp (-b * ↑x ^ 2)) ▸\n                Eq.refl\n                  ((∫ (x : ℝ), cexp (-b * ↑x ^ 2)) ^ 2 =\n                    ∫ (p : ℝ × ℝ), cexp (-b * ↑p.fst ^ 2) * cexp (-b * ↑p.snd ^ 2))))\n            (Eq.mpr\n              (id\n                (Eq.symm (MeasureTheory.integral_prod_mul (fun x => cexp (-b * ↑x ^ 2)) fun x => cexp (-b * ↑x ^ 2)) ▸\n                  Eq.refl\n                    ((∫ (x : ℝ), cexp (-b * ↑x ^ 2)) * ∫ (x : ℝ), cexp (-b * ↑x ^ 2) =\n                      ∫ (p : ℝ × ℝ), cexp (-b * ↑p.fst ^ 2) * cexp (-b * ↑p.snd ^ 2))))\n              (Eq.refl\n                (∫ (z : ℝ × ℝ),\n                  cexp (-b * ↑z.fst ^ 2) *\n                    cexp (-b * ↑z.snd ^ 2) ∂MeasureTheory.Measure.prod MeasureTheory.volume MeasureTheory.volume))))\n          ((fun {α G} [NormedAddCommGroup G] [NormedSpace ℝ G] {x} μ μ_1 e_μ =>\n              Eq.rec (motive := fun μ_2 e_μ =>\n                ∀ (f f_1 : α → G), f = f_1 → MeasureTheory.integral μ f = MeasureTheory.integral μ_2 f_1)\n                (fun f f_1 e_f => e_f ▸ Eq.refl (MeasureTheory.integral μ f)) e_μ)\n            MeasureTheory.volume MeasureTheory.volume (Eq.refl MeasureTheory.volume)\n            (fun p => cexp (-b * ↑p.fst ^ 2) * cexp (-b * ↑p.snd ^ 2)) (fun p => cexp (-b * (↑p.fst ^ 2 + ↑p.snd ^ 2)))\n            (funext fun p =>\n              Eq.mpr\n                (id\n                  (Eq.symm (Complex.exp_add (-b * ↑p.fst ^ 2) (-b * ↑p.snd ^ 2)) ▸\n                    Eq.refl (cexp (-b * ↑p.fst ^ 2) * cexp (-b * ↑p.snd ^ 2) = cexp (-b * (↑p.fst ^ 2 + ↑p.snd ^ 2)))))\n                (Eq.mpr\n                  (id\n                    (mul_add (-b) (↑p.fst ^ 2) (↑p.snd ^ 2) ▸\n                      Eq.refl (cexp (-b * ↑p.fst ^ 2 + -b * ↑p.snd ^ 2) = cexp (-b * (↑p.fst ^ 2 + ↑p.snd ^ 2)))))\n                  (Eq.refl (cexp (-b * ↑p.fst ^ 2 + -b * ↑p.snd ^ 2)))))))\n        (Eq.mpr\n          (id\n            (Eq.symm (integral_comp_polarCoord_symm fun p => cexp (-b * (↑p.fst ^ 2 + ↑p.snd ^ 2))) ▸\n              Eq.refl\n                (∫ (p : ℝ × ℝ), cexp (-b * (↑p.fst ^ 2 + ↑p.snd ^ 2)) =\n                  ∫ (p : ℝ × ℝ) in polarCoord.target,\n                    p.fst • cexp (-b * ((↑p.fst * Complex.cos ↑p.snd) ^ 2 + (↑p.fst * Complex.sin ↑p.snd) ^ 2)))))\n          (of_eq_true\n            (Eq.trans\n              (congrFun\n                (congrArg Eq\n                  (congrArg\n                    (MeasureTheory.integral (MeasureTheory.Measure.restrict MeasureTheory.volume polarCoord.target))\n                    (funext fun p =>\n                      congrArg (HSMul.hSMul p.fst)\n                        (congrArg cexp\n                          (congrArg (HMul.hMul (-b))\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (congrFun\n                                  (congrArg HPow.hPow\n                                    (Eq.trans (Complex.ofReal_mul p.fst (Real.cos p.snd))\n                                      (congrArg (HMul.hMul ↑p.fst) (Complex.ofReal_cos p.snd))))\n                                  2))\n                              (congrFun\n                                (congrArg HPow.hPow\n                                  (Eq.trans (Complex.ofReal_mul p.fst (Real.sin p.snd))\n                                    (congrArg (HMul.hMul ↑p.fst) (Complex.ofReal_sin p.snd))))\n                                2)))))))\n                (∫ (p : ℝ × ℝ) in polarCoord.target,\n                  p.fst • cexp (-b * ((↑p.fst * Complex.cos ↑p.snd) ^ 2 + (↑p.fst * Complex.sin ↑p.snd) ^ 2))))\n              (eq_self\n                (∫ (p : ℝ × ℝ) in polarCoord.target,\n                  p.fst • cexp (-b * ((↑p.fst * Complex.cos ↑p.snd) ^ 2 + (↑p.fst * Complex.sin ↑p.snd) ^ 2))))))))\n      (Eq.mpr\n        (id\n          (Eq.symm\n              (MeasureTheory.set_integral_prod_mul (fun r => ↑r * cexp (-b * ↑r ^ 2)) (fun θ => 1) (Set.Ioi 0)\n                (Set.Ioo (-Real.pi) Real.pi)) ▸\n            Eq.refl\n              (∫ (p : ℝ × ℝ) in polarCoord.target,\n                  p.fst • cexp (-b * ((↑p.fst * Complex.cos ↑p.snd) ^ 2 + (↑p.fst * Complex.sin ↑p.snd) ^ 2)) =\n                (∫ (r : ℝ) in Set.Ioi 0, ↑r * cexp (-b * ↑r ^ 2)) * ∫ (θ : ℝ) in Set.Ioo (-Real.pi) Real.pi, 1)))\n        ((fun {α G} [NormedAddCommGroup G] [NormedSpace ℝ G] {x} μ μ_1 e_μ =>\n            Eq.rec (motive := fun μ_2 e_μ =>\n              ∀ (f f_1 : α → G), f = f_1 → MeasureTheory.integral μ f = MeasureTheory.integral μ_2 f_1)\n              (fun f f_1 e_f => e_f ▸ Eq.refl (MeasureTheory.integral μ f)) e_μ)\n          (MeasureTheory.Measure.restrict MeasureTheory.volume polarCoord.target)\n          (MeasureTheory.Measure.restrict (MeasureTheory.Measure.prod MeasureTheory.volume MeasureTheory.volume)\n            (Set.Ioi 0 ×ˢ Set.Ioo (-Real.pi) Real.pi))\n          ((fun {α} {_m0} μ μ_1 e_μ =>\n              Eq.rec (motive := fun μ_2 e_μ =>\n                ∀ (s s_1 : Set α),\n                  s = s_1 → MeasureTheory.Measure.restrict μ s = MeasureTheory.Measure.restrict μ_2 s_1)\n                (fun s s_1 e_s => e_s ▸ Eq.refl (MeasureTheory.Measure.restrict μ s)) e_μ)\n            MeasureTheory.volume (MeasureTheory.Measure.prod MeasureTheory.volume MeasureTheory.volume)\n            (fun {α} [MeasureTheory.MeasureSpace α] => Eq.refl MeasureTheory.volume) polarCoord.target\n            (Set.Ioi 0 ×ˢ Set.Ioo (-Real.pi) Real.pi) (Eq.refl polarCoord.target))\n          (fun p => p.fst • cexp (-b * ((↑p.fst * Complex.cos ↑p.snd) ^ 2 + (↑p.fst * Complex.sin ↑p.snd) ^ 2)))\n          (fun z => ↑z.fst * cexp (-b * ↑z.fst ^ 2) * 1)\n          (funext fun p =>\n            Eq.mpr\n              (id\n                (mul_one (↑p.fst * cexp (-b * ↑p.fst ^ 2)) ▸\n                  Eq.refl\n                    (p.fst • cexp (-b * ((↑p.fst * Complex.cos ↑p.snd) ^ 2 + (↑p.fst * Complex.sin ↑p.snd) ^ 2)) =\n                      ↑p.fst * cexp (-b * ↑p.fst ^ 2) * 1)))\n              ((fun {α β} {γ} [HSMul α β γ] a a_1 e_a =>\n                  Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a • a_3 = a_2 • a_4)\n                    (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a • a_2)) e_a)\n                p.fst (↑p.fst).re ((fun {α β} self self_1 e_self => e_self ▸ Eq.refl self.fst) p p (Eq.refl p))\n                (cexp (-b * ((↑p.fst * Complex.cos ↑p.snd) ^ 2 + (↑p.fst * Complex.sin ↑p.snd) ^ 2)))\n                (cexp (-b * ↑p.fst ^ 2))\n                ((fun z z_1 e_z => e_z ▸ Eq.refl (cexp z))\n                  (-b * ((↑p.fst * Complex.cos ↑p.snd) ^ 2 + (↑p.fst * Complex.sin ↑p.snd) ^ 2)) (-b * ↑p.fst ^ 2)\n                  ((fun {α β} {γ} [HMul α β γ] a a_1 e_a =>\n                      Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n                        (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n                    (-b) (-b) (Eq.refl (-b)) ((↑p.fst * Complex.cos ↑p.snd) ^ 2 + (↑p.fst * Complex.sin ↑p.snd) ^ 2)\n                    (↑p.fst ^ 2)\n                    (Eq.mpr\n                      (id\n                        ((fun {α} a a_1 e_a =>\n                            Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : α), a_3 = a_4 → (a = a_3) = (a_2 = a_4))\n                              (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a = a_2)) e_a)\n                          ((↑p.fst * Complex.cos ↑p.snd) ^ 2 + (↑p.fst * Complex.sin ↑p.snd) ^ 2)\n                          ((↑p.fst * Complex.cos ↑p.snd) ^ 2 + (↑p.fst * Complex.sin ↑p.snd) ^ 2)\n                          (Eq.refl ((↑p.fst * Complex.cos ↑p.snd) ^ 2 + (↑p.fst * Complex.sin ↑p.snd) ^ 2)) (↑p.fst ^ 2)\n                          ((Complex.sin ↑p.snd ^ 2 + Complex.cos ↑p.snd ^ 2) * ↑p.fst ^ 2)\n                          (Eq.trans (Eq.symm (one_mul (↑p.fst ^ 2)) ▸ Eq.refl (↑p.fst ^ 2))\n                            (Eq.trans (Eq.symm (Complex.sin_sq_add_cos_sq ↑p.snd) ▸ Eq.refl (1 * ↑p.fst ^ 2))\n                              (Eq.refl ((Complex.sin ↑p.snd ^ 2 + Complex.cos ↑p.snd ^ 2) * ↑p.fst ^ 2))))))\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf ↑p.fst)\n                              (Mathlib.Tactic.Ring.atom_pf (Complex.cos ↑p.snd))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (↑p.fst) (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.mul_pf_right (Complex.cos ↑p.snd) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                                  (Mathlib.Tactic.Ring.mul_zero (↑p.fst ^ Nat.rawCast 1 * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    (↑p.fst ^ Nat.rawCast 1 * (Complex.cos ↑p.snd ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                                      0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Complex.cos ↑p.snd ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  (↑p.fst ^ Nat.rawCast 1 * (Complex.cos ↑p.snd ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                    (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2)))))\n                              (Mathlib.Tactic.Ring.pow_zero\n                                (↑p.fst ^ Nat.rawCast 1 * (Complex.cos ↑p.snd ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (↑p.fst) (Nat.rawCast 2)\n                                    (Mathlib.Tactic.Ring.mul_pf_left (Complex.cos ↑p.snd) (Nat.rawCast 2)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    (↑p.fst ^ Nat.rawCast 2 * (Complex.cos ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    (↑p.fst ^ Nat.rawCast 2 * (Complex.cos ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1) +\n                                      0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  (↑p.fst ^ Nat.rawCast 2 * (Complex.cos ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1) +\n                                    0)))))\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf ↑p.fst)\n                              (Mathlib.Tactic.Ring.atom_pf (Complex.sin ↑p.snd))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (↑p.fst) (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.mul_pf_right (Complex.sin ↑p.snd) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                                  (Mathlib.Tactic.Ring.mul_zero (↑p.fst ^ Nat.rawCast 1 * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    (↑p.fst ^ Nat.rawCast 1 * (Complex.sin ↑p.snd ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                                      0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Complex.sin ↑p.snd ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  (↑p.fst ^ Nat.rawCast 1 * (Complex.sin ↑p.snd ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                    (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2)))))\n                              (Mathlib.Tactic.Ring.pow_zero\n                                (↑p.fst ^ Nat.rawCast 1 * (Complex.sin ↑p.snd ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (↑p.fst) (Nat.rawCast 2)\n                                    (Mathlib.Tactic.Ring.mul_pf_left (Complex.sin ↑p.snd) (Nat.rawCast 2)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    (↑p.fst ^ Nat.rawCast 2 * (Complex.sin ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    (↑p.fst ^ Nat.rawCast 2 * (Complex.sin ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1) +\n                                      0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  (↑p.fst ^ Nat.rawCast 2 * (Complex.sin ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1) +\n                                    0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (↑p.fst ^ Nat.rawCast 2 * (Complex.cos ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (↑p.fst ^ Nat.rawCast 2 * (Complex.sin ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1) + 0))))\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (Complex.sin ↑p.snd))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.pow_add\n                                (Mathlib.Tactic.Ring.single_pow\n                                  (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                    (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                (Mathlib.Tactic.Ring.pow_zero (Complex.sin ↑p.snd ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_left (Complex.sin ↑p.snd) (Nat.rawCast 2)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Complex.sin ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Complex.sin ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    (Complex.sin ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                            (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (Complex.cos ↑p.snd))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.pow_add\n                                (Mathlib.Tactic.Ring.single_pow\n                                  (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                    (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                (Mathlib.Tactic.Ring.pow_zero (Complex.cos ↑p.snd ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_left (Complex.cos ↑p.snd) (Nat.rawCast 2)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Complex.cos ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Complex.cos ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    (Complex.cos ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Complex.cos ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (Complex.sin ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf ↑p.fst)\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                              (Mathlib.Tactic.Ring.pow_zero (↑p.fst ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (↑p.fst) (Nat.rawCast 2)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (↑p.fst ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (↑p.fst ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (↑p.fst ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right (↑p.fst) (Nat.rawCast 2)\n                                (Mathlib.Tactic.Ring.mul_pf_left (Complex.cos ↑p.snd) (Nat.rawCast 2)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                              (Mathlib.Tactic.Ring.mul_zero (Complex.cos ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (↑p.fst ^ Nat.rawCast 2 * (Complex.cos ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1) + 0)))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right (↑p.fst) (Nat.rawCast 2)\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Complex.sin ↑p.snd) (Nat.rawCast 2)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                                (Mathlib.Tactic.Ring.mul_zero (Complex.sin ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  (↑p.fst ^ Nat.rawCast 2 * (Complex.sin ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1) + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (↑p.fst ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (↑p.fst ^ Nat.rawCast 2 * (Complex.sin ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1) + 0)))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt\n                              (↑p.fst ^ Nat.rawCast 2 * (Complex.cos ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (↑p.fst ^ Nat.rawCast 2 * (Complex.sin ↑p.snd ^ Nat.rawCast 2 * Nat.rawCast 1) +\n                                  0))))))))))))))\n    (let_fun this :=\n      le_of_not_gt fun a =>\n        Linarith.lt_irrefl\n          (Eq.mp\n            (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf Real.pi)\n                    (Mathlib.Tactic.Ring.atom_pf Real.pi)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf Real.pi (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)\n                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf Real.pi)\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul Real.pi (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right Real.pi (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2)))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          (Real.pi ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 2) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (Real.pi ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (Real.pi ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 2) + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero Real.pi (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 2)) (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)) ▸\n              Eq.refl (Real.pi + Real.pi + 2 * -Real.pi < 0))\n            (Left.add_neg (lt_zero_of_zero_gt a)\n              (Linarith.mul_neg (neg_neg_of_pos Real.pi_pos)\n                (of_eq_true\n                  (eq_true\n                    (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))));\n    Eq.mpr\n      (id\n        (congrFun\n          (congrArg Eq\n            (congrArg (HMul.hMul (∫ (r : ℝ) in Set.Ioi 0, ↑r * cexp (-b * ↑r ^ 2)))\n              (Eq.trans (MeasureTheory.integral_const 1)\n                (congrFun\n                  (congrArg HSMul.hSMul\n                    (Eq.trans\n                      (congrArg ENNReal.toReal\n                        (Eq.trans\n                          (Eq.trans\n                            (Eq.trans\n                              (MeasureTheory.Measure.restrict_apply'\n                                (of_eq_true Mathlib.Analysis.SpecialFunctions.Gaussian._auxLemma.9))\n                              (congrArg (↑↑MeasureTheory.volume) (Set.univ_inter (Set.Ioo (-Real.pi) Real.pi))))\n                            Real.volume_Ioo)\n                          (congrArg ENNReal.ofReal (sub_neg_eq_add Real.pi Real.pi))))\n                      (ENNReal.toReal_ofReal (of_eq_true (eq_true this)))))\n                  1))))\n          (↑Real.pi / b)))\n      (Eq.mpr\n        (id\n          (Eq.symm (two_mul Real.pi) ▸\n            Eq.refl ((∫ (r : ℝ) in Set.Ioi 0, ↑r * cexp (-b * ↑r ^ 2)) * (Real.pi + Real.pi) • 1 = ↑Real.pi / b)))\n        (Eq.mpr\n          (id\n            (Complex.real_smul ▸\n              Eq.refl ((∫ (r : ℝ) in Set.Ioi 0, ↑r * cexp (-b * ↑r ^ 2)) * (2 * Real.pi) • 1 = ↑Real.pi / b)))\n          (Eq.mpr\n            (id\n              (mul_one ↑(2 * Real.pi) ▸\n                Eq.refl ((∫ (r : ℝ) in Set.Ioi 0, ↑r * cexp (-b * ↑r ^ 2)) * (↑(2 * Real.pi) * 1) = ↑Real.pi / b)))\n            (Eq.mpr\n              (id\n                (Complex.ofReal_mul 2 Real.pi ▸\n                  Eq.refl ((∫ (r : ℝ) in Set.Ioi 0, ↑r * cexp (-b * ↑r ^ 2)) * ↑(2 * Real.pi) = ↑Real.pi / b)))\n              (Eq.mpr\n                (id\n                  (Complex.ofReal_ofNat 2 ▸\n                    Eq.refl ((∫ (r : ℝ) in Set.Ioi 0, ↑r * cexp (-b * ↑r ^ 2)) * (↑2 * ↑Real.pi) = ↑Real.pi / b)))\n                (Eq.mpr\n                  (id\n                    (integral_mul_cexp_neg_mul_sq hb ▸\n                      Eq.refl ((∫ (r : ℝ) in Set.Ioi 0, ↑r * cexp (-b * ↑r ^ 2)) * (2 * ↑Real.pi) = ↑Real.pi / b)))\n                  (Eq.mpr\n                    (id\n                      (Eq.trans\n                        (Eq.trans\n                          (Eq.trans\n                            (congrFun\n                              (congrArg Eq\n                                (Eq.trans\n                                  (Eq.trans (congrFun (congrArg HMul.hMul (inv_eq_one_div (2 * b))) (2 * ↑Real.pi))\n                                    (div_mul_eq_mul_div 1 (2 * b) (2 * ↑Real.pi)))\n                                  (congrFun (congrArg HDiv.hDiv (one_mul (2 * ↑Real.pi))) (2 * b))))\n                              (↑Real.pi / b))\n                            (Mathlib.Algebra.GroupWithZero.Units.Lemmas._auxLemma.2\n                              (of_eq_true\n                                (Eq.trans\n                                  (congrArg Not\n                                    (eq_false\n                                      (Mathlib.Tactic.Contrapose.mtr\n                                        (Eq.mpr\n                                          (id\n                                            (implies_congr (Mathlib.Tactic.PushNeg.not_ne_eq b 0)\n                                              (Mathlib.Tactic.PushNeg.not_lt_eq 0 b.re)))\n                                          fun hb =>\n                                          Eq.mpr (id (hb ▸ Eq.refl (b.re ≤ 0)))\n                                            (Eq.mpr (id (Complex.zero_re ▸ Eq.refl (0.re ≤ 0))) (le_refl 0)))\n                                        hb)))\n                                  not_false_eq_true))))\n                          (congrFun (congrArg Eq (div_mul_eq_mul_div (2 * ↑Real.pi) (2 * b) b)) ↑Real.pi))\n                        (Mathlib.Algebra.GroupWithZero.Units.Lemmas._auxLemma.1\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg Not\n                                (Mathlib.Algebra.GroupWithZero.Basic._auxLemma.1\n                                  (Mathlib.Meta.NormNum.isNat_eq_false (Mathlib.Meta.NormNum.isNat_ofNat ℂ (Eq.refl 2))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℂ Nat.cast_zero) (Eq.refl false))\n                                  (of_eq_true\n                                    (Eq.trans\n                                      (congrArg Not\n                                        (eq_false\n                                          (Mathlib.Tactic.Contrapose.mtr\n                                            (Eq.mpr\n                                              (id\n                                                (implies_congr (Mathlib.Tactic.PushNeg.not_ne_eq b 0)\n                                                  (Mathlib.Tactic.PushNeg.not_lt_eq 0 b.re)))\n                                              fun hb =>\n                                              Eq.mpr (id (hb ▸ Eq.refl (b.re ≤ 0)))\n                                                (Eq.mpr (id (Complex.zero_re ▸ Eq.refl (0.re ≤ 0))) (le_refl 0)))\n                                            hb)))\n                                      not_false_eq_true))))\n                              not_false_eq_true)))))\n                    (Mathlib.Tactic.Ring.of_eq\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℂ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf ↑Real.pi)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right (↑Real.pi) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (↑Real.pi ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (↑Real.pi ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (↑Real.pi ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf b)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (↑Real.pi) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.mul_pf_right b (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (↑Real.pi ^ Nat.rawCast 1 * Nat.rawCast 2))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (↑Real.pi ^ Nat.rawCast 1 * (b ^ Nat.rawCast 1 * Nat.rawCast 2) + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (↑Real.pi ^ Nat.rawCast 1 * (b ^ Nat.rawCast 1 * Nat.rawCast 2) + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf ↑Real.pi)\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℂ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf b)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right b (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (↑Real.pi) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.mul_pf_right b (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (↑Real.pi ^ Nat.rawCast 1 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (↑Real.pi ^ Nat.rawCast 1 * (b ^ Nat.rawCast 1 * Nat.rawCast 2) + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (b ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (↑Real.pi ^ Nat.rawCast 1 * (b ^ Nat.rawCast 1 * Nat.rawCast 2) + 0)))))))))))))","name":"integral_gaussian_sq_complex","doc":"The *square* of the Gaussian integral `∫ x:ℝ, exp (-b * x^2)` is equal to `π / b`. ","depth":50}],"count":10}
{"noDocExamples":[{"term":"fun X [IrreducibleSpace ↑↑X.toPresheafedSpace] x =>\n  RingHom.toAlgebra (TopCat.Presheaf.stalkSpecializes X.presheaf (_ : genericPoint ↑↑X.toPresheafedSpace ⤳ x))","name":"AlgebraicGeometry.stalkFunctionFieldAlgebra","depth":16}],"kind":"«term_⤳_»","examples":[{"term":"fun {R} [CommRing R] => OrderEmbedding.ofMapLEIff nhds (_ : ∀ (a b : PrimeSpectrum R), a ⤳ b ↔ a ≤ b)","name":"PrimeSpectrum.nhdsOrderEmbedding","doc":"`nhds` as an order embedding. ","depth":10},{"term":"fun {X} p₀ [(U : TopologicalSpace.Opens ↑X) → Decidable (p₀ ∈ U)] {C} [CategoryTheory.Category.{u, v} C]\n    [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Limits.HasColimits C] =>\n  CategoryTheory.NatTrans.mk fun c => (skyscraperPresheafStalkOfSpecializes p₀ c (_ : p₀ ⤳ p₀)).hom","name":"StalkSkyscraperPresheafAdjunctionAuxs.counit","doc":"The counit in `presheaf.stalk ⊣ skyscraper_presheaf_functor`\n","depth":25},{"term":"fun {X} [TopologicalSpace X] x y =>\n  List.tfae_of_cycle\n    (List.Chain.cons (fun h => LE.le.trans (pure_le_nhds x) h)\n      (List.Chain.cons (fun h s hso hy => h (IsOpen.mem_nhds hso hy))\n        (List.Chain.cons (fun h s hsc hx => of_not_not fun hy => h sᶜ IsClosed.isOpen_compl hy hx)\n          (List.Chain.cons (fun h => h (closure {x}) isClosed_closure (subset_closure (Set.mem_singleton x)))\n            (List.Chain.cons\n              (fun h => Iff.mpr (Iff.trans (IsClosed.closure_subset_iff isClosed_closure) Set.singleton_subset_iff) h)\n              (List.Chain.cons\n                (fun h =>\n                  Iff.mp\n                    (Eq.mpr (id (propext mem_closure_iff_clusterPt ▸ Eq.refl (y ∈ closure {x} ↔ ClusterPt y (pure x))))\n                      (Eq.mpr\n                        (id\n                          (Filter.principal_singleton x ▸\n                            Eq.refl (ClusterPt y (Filter.principal {x}) ↔ ClusterPt y (pure x))))\n                        Iff.rfl))\n                    (Iff.mp (Iff.trans (IsClosed.closure_subset_iff isClosed_closure) Set.singleton_subset_iff) h))\n                List.Chain.nil))))))\n    fun h =>\n    Iff.mpr (Filter.HasBasis.ge_iff (nhds_basis_opens y)) fun s a =>\n      And.casesOn a fun hy ho =>\n        Exists.casesOn\n          (Iff.mp mem_closure_iff\n            (Iff.mpr\n              (Eq.mpr (id (propext mem_closure_iff_clusterPt ▸ Eq.refl (y ∈ closure {x} ↔ ClusterPt y (pure x))))\n                (Eq.mpr\n                  (id\n                    (Filter.principal_singleton x ▸\n                      Eq.refl (ClusterPt y (Filter.principal {x}) ↔ ClusterPt y (pure x))))\n                  Iff.rfl))\n              h)\n            s ho hy)\n          fun z h_1 =>\n          And.casesOn h_1 fun hxs right =>\n            Eq.ndrec (motive := fun x =>\n              (x ⤳ y → pure x ≤ nhds y) →\n                (pure x ≤ nhds y → ∀ (s : Set X), IsOpen s → y ∈ s → x ∈ s) →\n                  ((∀ (s : Set X), IsOpen s → y ∈ s → x ∈ s) → ∀ (s : Set X), IsClosed s → x ∈ s → y ∈ s) →\n                    ((∀ (s : Set X), IsClosed s → x ∈ s → y ∈ s) → y ∈ closure {x}) →\n                      (closure {y} ⊆ closure {x} ↔ y ∈ closure {x}) →\n                        (y ∈ closure {x} ↔ ClusterPt y (pure x)) → y ∈ closure {x} → s ∈ nhds x)\n              (fun tfae_1_to_2 tfae_2_to_3 tfae_3_to_4 tfae_4_to_5 tfae_6_iff_5 tfae_5_iff_7 h =>\n                IsOpen.mem_nhds ho hxs)\n              right (LE.le.trans (pure_le_nhds x)) (fun h s hso hy => h (IsOpen.mem_nhds hso hy))\n              (fun h s hsc hx => of_not_not fun hy => h sᶜ IsClosed.isOpen_compl hy hx)\n              (fun h => h (closure {x}) isClosed_closure (subset_closure (Set.mem_singleton x)))\n              (Iff.trans (IsClosed.closure_subset_iff isClosed_closure) Set.singleton_subset_iff)\n              (Eq.mpr (id (propext mem_closure_iff_clusterPt ▸ Eq.refl (y ∈ closure {x} ↔ ClusterPt y (pure x))))\n                (Eq.mpr\n                  (id\n                    (Filter.principal_singleton x ▸\n                      Eq.refl (ClusterPt y (Filter.principal {x}) ↔ ClusterPt y (pure x))))\n                  Iff.rfl))\n              (Iff.mpr\n                (Eq.mpr (id (propext mem_closure_iff_clusterPt ▸ Eq.refl (y ∈ closure {x} ↔ ClusterPt y (pure x))))\n                  (Eq.mpr\n                    (id\n                      (Filter.principal_singleton x ▸\n                        Eq.refl (ClusterPt y (Filter.principal {x}) ↔ ClusterPt y (pure x))))\n                    Iff.rfl))\n                h)","name":"specializes_TFAE","doc":"A collection of equivalent definitions of `x ⤳ y`. The public API is given by `iff` lemmas\nbelow. ","depth":44},{"term":"fun {𝕜} {𝕜₂} {E} {F} {𝓕} [SeminormedAddCommGroup E] [SeminormedAddCommGroup F] [NontriviallyNormedField 𝕜]\n    [NontriviallyNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂} [SemilinearMapClass 𝓕 σ₁₂ E F] f hf {x}\n    hx =>\n  Eq.mpr (id (Eq.symm (propext mem_closure_zero_iff_norm) ▸ Eq.refl (‖↑f x‖ = 0)))\n    (Eq.mpr (id (Eq.symm (propext specializes_iff_mem_closure) ▸ Eq.refl (↑f x ∈ closure {0})))\n      (Eq.mpr (id (Eq.symm (map_zero f) ▸ Eq.refl (0 ⤳ ↑f x)))\n        (Specializes.map\n          (Eq.mp (Eq.symm (propext specializes_iff_mem_closure) ▸ Eq.refl (x ∈ closure {0}))\n            (Eq.mp (Eq.symm (propext mem_closure_zero_iff_norm) ▸ Eq.refl (‖x‖ = 0)) hx))\n          hf)))","name":"norm_image_of_norm_zero","doc":"If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. ","depth":50}],"count":10}
{"noDocExamples":[{"term":"fun {α} [Unique α] => Unique.mk' αˢʸᵐ","name":"SymAlg.instUniqueSymAlg","depth":7},{"term":"fun {α} [AddCommGroup α] =>\n  let src := SymAlg.addCommMonoid;\n  let src := SymAlg.addGroup;\n  AddCommGroup.mk (_ : ∀ (a b : αˢʸᵐ), a + b = b + a)","name":"SymAlg.addCommGroup","depth":11},{"term":"fun {α} [AddCommSemigroup α] =>\n  Function.Injective.addCommSemigroup ↑SymAlg.unsym (_ : Function.Injective ↑SymAlg.unsym)\n    (_ : ∀ (a b : αˢʸᵐ), ↑SymAlg.unsym (a + b) = ↑SymAlg.unsym a + ↑SymAlg.unsym b)","name":"SymAlg.addCommSemigroup","depth":13}],"kind":"«term_ˢʸᵐ»","examples":[{"term":"fun {α} => Equiv.refl αˢʸᵐ","name":"SymAlg.unsym","doc":"The element of `α` represented by `x : αˢʸᵐ`. ","depth":3},{"term":"fun {α} [Ring α] [Invertible 2] =>\n  let src := SymAlg.nonAssocSemiring;\n  let src_1 := SymAlg.addCommGroup;\n  NonAssocRing.mk (_ : ∀ (a : αˢʸᵐ), 1 * a = a) (_ : ∀ (a : αˢʸᵐ), a * 1 = a)","name":"SymAlg.instNonAssocRingSymAlg","doc":"The symmetrization of a real (unital, associative) algebra is a non-associative ring. ","depth":33}],"count":10}
{"noDocExamples":[{"term":"fun {α} l => Eq.mpr (id (Eq.symm (List.drop_one l) ▸ Eq.refl (List.tail l <:+ l))) (List.drop_suffix 1 l)","name":"List.tail_suffix","depth":16},{"term":"fun {α} {l₁ l₂} =>\n  Eq.mpr (id (Eq.symm (propext List.reverse_suffix) ▸ Eq.refl (List.reverse l₁ <+: List.reverse l₂ ↔ l₁ <:+ l₂)))\n    (of_eq_true\n      (Eq.trans\n        (congrFun (congrArg Iff (congr (congrArg List.isSuffix (List.reverse_reverse l₁)) (List.reverse_reverse l₂)))\n          (l₁ <:+ l₂))\n        (iff_self (l₁ <:+ l₂))))","name":"List.reverse_prefix","depth":20},{"term":"fun {α} p l =>\n  Eq.mpr (id (Eq.symm (propext List.reverse_suffix) ▸ Eq.refl (List.rdropWhile p l <+: l)))\n    (Eq.mpr (id (List.rdropWhile._eq_1 p l ▸ Eq.refl (List.reverse (List.rdropWhile p l) <:+ List.reverse l)))\n      (Eq.mpr\n        (id\n          (List.reverse_reverse (List.dropWhile p (List.reverse l)) ▸\n            Eq.refl (List.reverse (List.reverse (List.dropWhile p (List.reverse l))) <:+ List.reverse l)))\n        (List.dropWhile_suffix p)))","name":"List.rdropWhile_prefix","depth":22},{"term":"fun {α} p l =>\n  Eq.mpr (id (Eq.symm (propext List.reverse_prefix) ▸ Eq.refl (List.rtakeWhile p l <:+ l)))\n    (Eq.mpr (id (List.rtakeWhile._eq_1 p l ▸ Eq.refl (List.reverse (List.rtakeWhile p l) <+: List.reverse l)))\n      (Eq.mpr\n        (id\n          (List.reverse_reverse (List.takeWhile p (List.reverse l)) ▸\n            Eq.refl (List.reverse (List.reverse (List.takeWhile p (List.reverse l))) <+: List.reverse l)))\n        (List.takeWhile_prefix p)))","name":"List.rtakeWhile_suffix","depth":22}],"kind":"List.«term_<:+_»","examples":[{"term":"fun {α} {l₁ l₂} =>\n  (fun {α} {l₁ l₂} =>\n      Eq.mpr (id (Eq.symm (propext List.reverse_suffix) ▸ Eq.refl (List.reverse l₁ <+: List.reverse l₂ ↔ l₁ <:+ l₂)))\n        (of_eq_true\n          (Eq.trans\n            (congrFun\n              (congrArg Iff (congr (congrArg List.isSuffix (List.reverse_reverse l₁)) (List.reverse_reverse l₂)))\n              (l₁ <:+ l₂))\n            (iff_self (l₁ <:+ l₂))))).mpr","name":"List.isSuffix.reverse","doc":"**Alias** of the reverse direction of `List.reverse_prefix`.","depth":27}],"count":9}
{"noDocExamples":[],"kind":"«term__[_]_!»","examples":[{"term":"fun all numMotives =>\n  if numMotives ≤ List.length all then List.map Lean.mkRecName all\n  else\n    let main := all[0]!;\n    List.map Lean.mkRecName all ++\n      List.map (fun i => Lean.Name.str main (toString \"rec_\" ++ toString (i + 1) ++ toString \"\"))\n        (List.range (numMotives - List.length all))","name":"Mathlib.Util.mkRecNames","doc":"Returns the names of the recursors for a nested or mutual inductive,\nusing the `all` and `numMotives` arguments from `RecursorVal`. ","depth":19},{"term":"fun {α} [Inhabited α] x x_1 =>\n  match x, x_1 with\n  | a, [] => a\n  | a, i :: is => Array.cyclicPermute!.cyclicPermuteAux a is a[i]! i","name":"Array.cyclicPermute!","doc":"Permute the array using a sequence of indices defining a cyclic permutation.\nIf the list of indices `l = [i₁, i₂, ..., iₙ]` are all distinct then\n`(cyclicPermute! a l)[iₖ₊₁] = a[iₖ]` and `(cyclicPermute! a l)[i₀] = a[iₙ]` ","depth":22},{"term":"fun x className args => do\n  let __do_lift ← Lean.getEnv\n  let __discr : Option Lean.ConstantInfo := Lean.Environment.find? __do_lift className\n  match __discr with\n    | some classExpr =>\n      let arity := Lean.Expr.forallArity (Lean.ConstantInfo.type classExpr);\n      if (arity == Array.size args) = true then pure (Array.map some args)\n      else\n        if (Array.size args == 1) = true then pure (mkArray arity (some args[0]!))\n        else\n          Lean.throwError\n            (Lean.toMessageData \"initialize_simps_projections cannot automatically find arguments for class \" ++\n                Lean.toMessageData className ++\n              Lean.toMessageData \"\")\n    | x =>\n      Lean.throwError (Lean.toMessageData \"no such class \" ++ Lean.toMessageData className ++ Lean.toMessageData \"\")","name":"Simps.defaultfindArgs","doc":"Find arguments for a notation class ","depth":28},{"term":"fun declNames => do\n  let ctx ← Lean.Elab.Deriving.mkContext \"toExpr\" declNames[0]!\n  let __do_lift ← Mathlib.Deriving.ToExpr.mkMutualBlock ctx\n  let __do_lift_1 ← Mathlib.Deriving.ToExpr.mkInstanceCmds ctx declNames\n  let cmds : Array Lean.Syntax := #[__do_lift] ++ Lean.TSyntaxArray.raw __do_lift_1\n  let cls : Lean.Name := `Elab.Deriving.toExpr\n  let __do_lift ← Lean.isTracingEnabledFor cls\n  let __do_jp : Unit → Lean.Elab.TermElabM (Array Lean.Syntax) := fun y => pure cmds\n  if __do_lift = true then do\n      let y ← Lean.addTrace cls (Lean.toMessageData \"\\n\" ++ Lean.toMessageData cmds ++ Lean.toMessageData \"\")\n      __do_jp y\n    else do\n      let y ← pure PUnit.unit\n      __do_jp y","name":"Mathlib.Deriving.ToExpr.mkToExprInstanceCmds","doc":"Returns all the commands generated by `mkMutualBlock` and `mkInstanceCmds`. ","depth":31},{"term":"fun ctors decorateSum =>\n  let types := #[];\n  let patts := #[];\n  do\n  let r ←\n    let col := { start := 0, stop := Array.size ctors, step := 1 };\n      forIn col { fst := patts, snd := types } fun i r =>\n        let patts := r.fst;\n        let types := r.snd;\n        match ctors[i]! with\n        | (_ctorName, ty, patt) =>\n          let types := Array.push types ty;\n          do\n          let __do_lift ← Mathlib.ProxyType.defaultMkProxyType.wrapSumAccess i (Array.size ctors) patt\n          let patts : Array Lean.Term := Array.push patts __do_lift\n          pure PUnit.unit\n          pure (ForInStep.yield { fst := patts, snd := types })\n  match r with\n    | { fst := patts, snd := types } => do\n      let __discr ← Mathlib.ProxyType.defaultMkProxyType.mkCType decorateSum (Array.toList types)\n      match __discr with\n        | (type, pf) => pure (type, patts, pf)","name":"Mathlib.ProxyType.defaultMkProxyType","doc":"Create a `Sum` of types, mildly optimized to not have a trailing `Empty`.\n\nThe `decorateSum` function is to wrap the `Sum` a decorator such as `Lex`.\nIt should yield a definitionally equal type. ","depth":31}],"count":9}
{"noDocExamples":[{"term":"fun {L} {T} h {φ} hφ =>\n  Or.resolve_right (FirstOrder.Language.Theory.IsMaximal.mem_or_not_mem h φ) fun con =>\n    Eq.mp\n      (Set.insert_eq_of_mem con ▸\n        Eq.refl ¬FirstOrder.Language.Theory.IsSatisfiable (insert (FirstOrder.Language.Formula.not φ) T))\n      (Eq.mp\n        (Set.union_singleton ▸\n          Eq.refl ¬FirstOrder.Language.Theory.IsSatisfiable (T ∪ {FirstOrder.Language.Formula.not φ}))\n        (Eq.mp (propext (FirstOrder.Language.Theory.models_iff_not_satisfiable φ) ▸ Eq.refl (T ⊨ᵇ φ)) hφ))\n      h.left","name":"FirstOrder.Language.Theory.IsMaximal.mem_of_models","depth":27},{"term":"fun {L} {T} h φ M [FirstOrder.Language.Structure L M] [M ⊨ T] [Nonempty M] =>\n  Or.casesOn (motive := fun t => And.right h φ = t → (M ⊨ φ ↔ T ⊨ᵇ φ)) (And.right h φ)\n    (fun hφ h_1 => Eq.symm h_1 ▸ iff_of_true (FirstOrder.Language.Theory.ModelsBoundedFormula.realize_sentence hφ M) hφ)\n    (fun hφn h_1 =>\n      Eq.symm h_1 ▸\n        iff_of_false\n          (Iff.mp (FirstOrder.Language.Sentence.realize_not M)\n            (FirstOrder.Language.Theory.ModelsBoundedFormula.realize_sentence hφn M))\n          (Iff.mp (FirstOrder.Language.Theory.IsComplete.models_not_iff h φ) hφn))\n    (Eq.refl (And.right h φ))","name":"FirstOrder.Language.Theory.IsComplete.realize_sentence_iff","depth":28},{"term":"fun {L} {T} {α} φ =>\n  Eq.mpr\n    (id\n      (propext (FirstOrder.Language.Theory.models_iff_not_satisfiable φ) ▸\n        Eq.refl\n          ({p | φ ∈ p} = Set.univ ↔\n            FirstOrder.Language.LHom.onTheory (FirstOrder.Language.lhomWithConstants L α) T ⊨ᵇ φ)))\n    (Eq.mpr\n      (id\n        (Eq.symm (propext Set.compl_empty_iff) ▸\n          Eq.refl\n            ({p | φ ∈ p} = Set.univ ↔\n              ¬FirstOrder.Language.Theory.IsSatisfiable\n                  (FirstOrder.Language.LHom.onTheory (FirstOrder.Language.lhomWithConstants L α) T ∪\n                    {FirstOrder.Language.Formula.not φ}))))\n      (Eq.mpr\n        (id\n          (FirstOrder.Language.Theory.CompleteType.compl_setOf_mem ▸\n            Eq.refl\n              ({p | φ ∈ p}ᶜ = ∅ ↔\n                ¬FirstOrder.Language.Theory.IsSatisfiable\n                    (FirstOrder.Language.LHom.onTheory (FirstOrder.Language.lhomWithConstants L α) T ∪\n                      {FirstOrder.Language.Formula.not φ}))))\n        (Eq.mpr\n          (id\n            (Eq.symm\n                (propext\n                  (FirstOrder.Language.Theory.CompleteType.setOf_subset_eq_empty_iff\n                    {FirstOrder.Language.Formula.not φ})) ▸\n              Eq.refl\n                ({p | FirstOrder.Language.Formula.not φ ∈ p} = ∅ ↔\n                  ¬FirstOrder.Language.Theory.IsSatisfiable\n                      (FirstOrder.Language.LHom.onTheory (FirstOrder.Language.lhomWithConstants L α) T ∪\n                        {FirstOrder.Language.Formula.not φ}))))\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Iff ({p | FirstOrder.Language.Formula.not φ ∈ p} = ∅))\n                (congrFun\n                  (congrArg Eq\n                    (congrArg setOf\n                      (funext fun p =>\n                        Eq.trans Mathlib.Data.Set.Basic._auxLemma.48 Mathlib.Data.SetLike.Basic._auxLemma.2)))\n                  ∅))\n              (iff_self ({p | FirstOrder.Language.Formula.not φ ∈ p} = ∅)))))))","name":"FirstOrder.Language.Theory.CompleteType.setOf_mem_eq_univ_iff","depth":33}],"kind":"FirstOrder.Language.Theory.«term_⊨ᵇ_»","examples":[{"term":"fun {L} T =>\n  FirstOrder.Language.Theory.IsSatisfiable T ∧\n    ∀ (φ : FirstOrder.Language.Sentence L), T ⊨ᵇ φ ∨ T ⊨ᵇ FirstOrder.Language.Formula.not φ","name":"FirstOrder.Language.Theory.IsComplete","doc":"A theory is complete when it is satisfiable and models each sentence or its negation. ","depth":11},{"term":"fun {L} {α} {n} T φ ψ => T ⊨ᵇ FirstOrder.Language.BoundedFormula.iff φ ψ","name":"FirstOrder.Language.Theory.SemanticallyEquivalent","doc":"Two (bounded) formulas are semantically equivalent over a theory `T` when they have the same\ninterpretation in every model of `T`. (This is also known as logical equivalence, which also has a\nproof-theoretic definition.) ","depth":12}],"count":9}
{"noDocExamples":[],"kind":"«term∮_InC(_,_),_»","examples":[{"term":"fun {E} [NormedAddCommGroup E] [NormedSpace ℂ E] r f z =>\n  (2 * ↑Real.pi * Complex.I)⁻¹ • ∮ (w : ℂ) in C(z, r), ((w - z) ^ 2)⁻¹ • f w","name":"Complex.cderiv","doc":"A circle integral which coincides with `deriv f z` whenever one can apply the Cauchy formula for\nthe derivative. It is useful in the proof that locally uniform limits of holomorphic functions are\nholomorphic, because it depends continuously on `f` for the uniform topology. ","depth":26},{"term":"fun {E} [NormedAddCommGroup E] [NormedSpace ℂ E] f c R n =>\n  ContinuousMultilinearMap.mkPiField ℂ (Fin n)\n    ((2 * ↑Real.pi * Complex.I)⁻¹ • ∮ (z : ℂ) in C(c, R), (z - c)⁻¹ ^ n • (z - c)⁻¹ • f z)","name":"cauchyPowerSeries","doc":"The power series that is equal to\n$\\sum_{n=0}^{\\infty} \\oint_{|z-c|=R} \\left(\\frac{w-c}{z - c}\\right)^n \\frac{1}{z-c}f(z)\\,dz$ at\n`w - c`. The coefficients of this power series depend only on `f ∘ circleMap c R`, and the power\nseries converges to `f w` if `f` is differentiable on the closed ball `Metric.closedBall c R` and\n`w` belongs to the corresponding open ball. For any circle integrable function `f`, this power\nseries converges to the Cauchy integral for `f`. ","depth":29},{"term":"fun {E} [NormedAddCommGroup E] [NormedSpace ℂ E] {f} {c} {R} {w} hf hw =>\n  Eq.mpr\n    (id\n      (congrFun (congrArg HasSum (funext fun n => cauchyPowerSeries_apply f c R n w))\n        ((2 * ↑Real.pi * Complex.I)⁻¹ • ∮ (z : ℂ) in C(c, R), (z - (c + w))⁻¹ • f z)))\n    (HasSum.const_smul (2 * ↑Real.pi * Complex.I)⁻¹ (hasSum_two_pi_I_cauchyPowerSeries_integral hf hw))","name":"hasSum_cauchyPowerSeries_integral","doc":"For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\nconverges to the Cauchy integral `(2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), (z - w)⁻¹ • f z` on the open\ndisc `Metric.ball c R`. ","depth":43},{"term":"fun {E} [NormedAddCommGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f f'} {c} {R} h =>\n  if hi : CircleIntegrable f' c R then\n    Eq.mpr\n      (id\n        (Eq.symm (Iff.mpr sub_eq_zero (Function.Periodic.eq (Function.Periodic.comp (periodic_circleMap c R) f))) ▸\n          Eq.refl ((∮ (z : ℂ) in C(c, R), f' z) = 0)))\n      (intervalIntegral.integral_eq_sub_of_hasDerivAt\n        (fun θ x =>\n          HasDerivWithinAt.scomp_hasDerivAt θ (h (circleMap c R θ) (circleMap_mem_sphere' c R θ))\n            (DifferentiableAt.hasDerivAt (differentiable_circleMap c R θ)) (circleMap_mem_sphere' c R))\n        (CircleIntegrable.out hi))\n  else circleIntegral.integral_undef hi","name":"circleIntegral.integral_eq_zero_of_hasDerivWithinAt'","doc":"If `f' : ℂ → E` is a derivative of a complex differentiable function on the circle\n`Metric.sphere c |R|`, then `∮ z in C(c, R), f' z = 0`. ","depth":43},{"term":"fun {E} [NormedAddCommGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R} h0 {f} {c} {s} hs hc hd =>\n  Or.casesOn (LE.le.eq_or_lt h0)\n    (fun h =>\n      Eq.ndrec (motive := fun {R} =>\n        0 ≤ R →\n          ContinuousOn f (Metric.closedBall c R) →\n            (∀ (z : ℂ), z ∈ Metric.ball c R \\ s → DifferentiableAt ℂ f z) → (∮ (z : ℂ) in C(c, R), f z) = 0)\n        (fun h0 hc hd => circleIntegral.integral_radius_zero (fun z => f z) c) h h0 hc hd)\n    fun h0 =>\n    Trans.trans\n      (Trans.trans (Eq.symm (circleIntegral.integral_sub_inv_smul_sub_smul (fun z => f z) c c R))\n        (Complex.circleIntegral_sub_center_inv_smul_of_differentiable_on_off_countable h0 hs\n          (ContinuousOn.smul (ContinuousOn.sub continuousOn_id continuousOn_const) hc) fun z hz =>\n          DifferentiableAt.smul (DifferentiableAt.sub_const differentiableAt_id c) (hd z hz)))\n      (Eq.mpr (id (sub_self c ▸ Eq.refl ((2 * ↑Real.pi * Complex.I) • (c - c) • f c = 0)))\n        (Eq.mpr (id (zero_smul ℂ (f c) ▸ Eq.refl ((2 * ↑Real.pi * Complex.I) • 0 • f c = 0)))\n          (Eq.mpr (id (smul_zero (2 * ↑Real.pi * Complex.I) ▸ Eq.refl ((2 * ↑Real.pi * Complex.I) • 0 = 0)))\n            (Eq.refl 0))))","name":"Complex.circleIntegral_eq_zero_of_differentiable_on_off_countable","doc":"**Cauchy-Goursat theorem** for a disk: if `f : ℂ → E` is continuous on a closed disk\n`{z | ‖z - c‖ ≤ R}` and is complex differentiable at all but countably many points of its interior,\nthen the integral $\\oint_{|z-c|=R}f(z)\\,dz$ equals zero. ","depth":44}],"count":9}
{"noDocExamples":[{"term":"fun R S [CommRing R] [CommRing S] [Algebra R S] => smulCommClass_self R (Ω[S⁄R])","name":"KaehlerDifferential.endEquiv.proof_11","depth":19},{"term":"fun R S [CommRing R] [CommRing S] [Algebra R S] => smulCommClass_self R (Ω[S⁄R])","name":"KaehlerDifferential.linearMapEquivDerivation.proof_5","depth":19}],"kind":"«termΩ[_⁄_]»","examples":[{"term":"fun R S [CommRing R] [CommRing S] [Algebra R S] =>\n  let src :=\n    Submodule.liftQ (KaehlerDifferential.kerTotal R S) (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S))\n      (_ : KaehlerDifferential.kerTotal R S ≤ LinearMap.ker (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S)));\n  {\n    toLinearMap :=\n      { toAddHom := src.toAddHom,\n        map_smul' :=\n          (_ :\n            ∀ (r : S) (x : (S →₀ S) ⧸ KaehlerDifferential.kerTotal R S),\n              AddHom.toFun\n                  (Submodule.liftQ (KaehlerDifferential.kerTotal R S)\n                      (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S))\n                      (_ :\n                        KaehlerDifferential.kerTotal R S ≤\n                          LinearMap.ker (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S)))).toAddHom\n                  (r • x) =\n                ↑(RingHom.id S) r •\n                  AddHom.toFun\n                    (Submodule.liftQ (KaehlerDifferential.kerTotal R S)\n                        (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S))\n                        (_ :\n                          KaehlerDifferential.kerTotal R S ≤\n                            LinearMap.ker (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S)))).toAddHom\n                    x) },\n    invFun := ↑(Derivation.liftKaehlerDifferential (KaehlerDifferential.derivationQuotKerTotal R S)),\n    left_inv :=\n      (_ :\n        ∀ (x : (S →₀ S) ⧸ KaehlerDifferential.kerTotal R S),\n          ↑(Derivation.liftKaehlerDifferential (KaehlerDifferential.derivationQuotKerTotal R S))\n              (AddHom.toFun\n                {\n                    toAddHom :=\n                      (Submodule.liftQ (KaehlerDifferential.kerTotal R S)\n                          (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S))\n                          (_ :\n                            KaehlerDifferential.kerTotal R S ≤\n                              LinearMap.ker (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S)))).toAddHom,\n                    map_smul' :=\n                      (_ :\n                        ∀ (r : S) (x : (S →₀ S) ⧸ KaehlerDifferential.kerTotal R S),\n                          AddHom.toFun\n                              (Submodule.liftQ (KaehlerDifferential.kerTotal R S)\n                                  (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S))\n                                  (_ :\n                                    KaehlerDifferential.kerTotal R S ≤\n                                      LinearMap.ker (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S)))).toAddHom\n                              (r • x) =\n                            ↑(RingHom.id S) r •\n                              AddHom.toFun\n                                (Submodule.liftQ (KaehlerDifferential.kerTotal R S)\n                                    (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S))\n                                    (_ :\n                                      KaehlerDifferential.kerTotal R S ≤\n                                        LinearMap.ker\n                                          (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S)))).toAddHom\n                                x) }.toAddHom\n                x) =\n            x),\n    right_inv :=\n      (_ :\n        ∀ (x : Ω[S⁄R]),\n          AddHom.toFun\n              {\n                  toAddHom :=\n                    (Submodule.liftQ (KaehlerDifferential.kerTotal R S)\n                        (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S))\n                        (_ :\n                          KaehlerDifferential.kerTotal R S ≤\n                            LinearMap.ker (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S)))).toAddHom,\n                  map_smul' :=\n                    (_ :\n                      ∀ (r : S) (x : (S →₀ S) ⧸ KaehlerDifferential.kerTotal R S),\n                        AddHom.toFun\n                            (Submodule.liftQ (KaehlerDifferential.kerTotal R S)\n                                (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S))\n                                (_ :\n                                  KaehlerDifferential.kerTotal R S ≤\n                                    LinearMap.ker (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S)))).toAddHom\n                            (r • x) =\n                          ↑(RingHom.id S) r •\n                            AddHom.toFun\n                              (Submodule.liftQ (KaehlerDifferential.kerTotal R S)\n                                  (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S))\n                                  (_ :\n                                    KaehlerDifferential.kerTotal R S ≤\n                                      LinearMap.ker (Finsupp.total S (Ω[S⁄R]) S ↑(KaehlerDifferential.D R S)))).toAddHom\n                              x) }.toAddHom\n              (↑(Derivation.liftKaehlerDifferential (KaehlerDifferential.derivationQuotKerTotal R S)) x) =\n            x) }","name":"KaehlerDifferential.quotKerTotalEquiv","doc":"`Ω[S⁄R]` is isomorphic to `S` copies of `S` with kernel `KaehlerDifferential.kerTotal`. ","depth":31},{"term":"fun R S [CommRing R] [CommRing S] [Algebra R S] {M} [AddCommGroup M] [Module R M] [Module S M] [IsScalarTower R S M] =>\n  let src := ↑(LinearMap.flip Derivation.llcomp) (KaehlerDifferential.D R S);\n  {\n    toLinearMap :=\n      { toAddHom := src.toAddHom,\n        map_smul' :=\n          (_ :\n            ∀ (r : S) (x : Ω[S⁄R] →ₗ[S] M),\n              AddHom.toFun (↑(LinearMap.flip Derivation.llcomp) (KaehlerDifferential.D R S)).toAddHom (r • x) =\n                ↑(RingHom.id S) r •\n                  AddHom.toFun (↑(LinearMap.flip Derivation.llcomp) (KaehlerDifferential.D R S)).toAddHom x) },\n    invFun := Derivation.liftKaehlerDifferential,\n    left_inv :=\n      (_ :\n        ∀ (x : Ω[S⁄R] →ₗ[S] M),\n          Derivation.liftKaehlerDifferential\n              (AddHom.toFun\n                { toAddHom := (↑(LinearMap.flip Derivation.llcomp) (KaehlerDifferential.D R S)).toAddHom,\n                    map_smul' :=\n                      (_ :\n                        ∀ (r : S) (x : Ω[S⁄R] →ₗ[S] M),\n                          AddHom.toFun (↑(LinearMap.flip Derivation.llcomp) (KaehlerDifferential.D R S)).toAddHom\n                              (r • x) =\n                            ↑(RingHom.id S) r •\n                              AddHom.toFun (↑(LinearMap.flip Derivation.llcomp) (KaehlerDifferential.D R S)).toAddHom\n                                x) }.toAddHom\n                x) =\n            x),\n    right_inv :=\n      (_ :\n        ∀ (D : Derivation R S M),\n          ↑(LinearMap.compDer (Derivation.liftKaehlerDifferential D)) (KaehlerDifferential.D R S) = D) }","name":"KaehlerDifferential.linearMapEquivDerivation","doc":"The `S`-linear maps from `Ω[S⁄R]` to `M` are (`S`-linearly) equivalent to `R`-derivations\nfrom `S` to `M`.  ","depth":42},{"term":"fun R [CommRing R] A B [CommRing A] [CommRing B] [Algebra R A] [Algebra R B] [Algebra A B] [IsScalarTower R A B] =>\n  IsBaseChange.lift (_ : IsBaseChange B (↑(TensorProduct.mk A B (Ω[A⁄R])) 1)) (KaehlerDifferential.map R R A B)","name":"KaehlerDifferential.mapBaseChange","doc":"The lift of the map `Ω[A⁄R] →ₗ[A] Ω[B⁄R]` to the base change along `A → B`.\nThis is the first map in the exact sequence `B ⊗[A] Ω[A⁄R] → Ω[B⁄R] → Ω[B⁄A] → 0`. ","depth":46}],"count":9}
{"noDocExamples":[],"kind":"«term_!=_»","examples":[{"term":"fun s name checkNot? =>\n  Mathlib.Notation3.MatchState.withVar s name\n    (let __do_jp := fun y => Lean.PrettyPrinter.Delaborator.delab;\n    match checkNot? with\n    | some checkNot => do\n      let __do_lift ← Lean.PrettyPrinter.Delaborator.SubExpr.getExpr\n      let y ← guard ((checkNot != __do_lift) = true)\n      __do_jp y\n    | x => do\n      let y ← pure PUnit.unit\n      __do_jp y)","name":"Mathlib.Notation3.MatchState.delabVar","doc":"Delaborate the given variable's value. Fails if the variable has no value.\nIf `checkNot` is provided, then checks that the expression being delaborated is not\nthe given one (this is used to prevent infinite loops). ","depth":21},{"term":"fun uri =>\n  Id.run\n    (if (!String.startsWith uri \"file://\") = true then none\n    else\n      let p := String.drop (System.Uri.unescapeUri uri) (String.length \"file://\");\n      let p := String.dropWhile p fun c => c != Char.ofNat 47;\n      let __do_jp := fun p y => some { toString := p };\n      if\n          (System.Platform.isWindows && decide (String.length p ≥ 2) && String.get p 0 == Char.ofNat 47 &&\n                Char.isAlpha (String.get p { byteIdx := 1 }) &&\n              String.get p { byteIdx := 2 } == Char.ofNat 58) =\n            true then\n        let p := String.modify (String.drop p 1) 0 Char.toUpper;\n        do\n        let y ← pure PUnit.unit\n        __do_jp p y\n      else do\n        let y ← pure PUnit.unit\n        __do_jp p y)","name":"System.Uri.fileUriToPath?","doc":"Convert the given uri to a FilePath stripping the 'file://' prefix,\nignoring the optional host name. ","depth":25},{"term":"fun src tgt f => do\n  let srcFields ← f src\n  let tgtFields ← f tgt\n  let __do_jp : PUnit.{1} → Lean.CoreM Unit := fun y => do\n    let col := Array.zip srcFields tgtFields;\n      forIn col PUnit.unit fun x r =>\n        match x with\n        | (srcField, tgtField) =>\n          if (srcField != tgtField) = true then do\n            ToAdditive.insertTranslation (src ++ srcField) (tgt ++ tgtField) true\n            pure (ForInStep.yield PUnit.unit)\n          else\n            let cls := `to_additive;\n            do\n            let __do_lift ← Lean.isTracingEnabledFor cls\n            if __do_lift = true then do\n                Lean.addTrace cls\n                    (Lean.toMessageData \"Translation \" ++ Lean.toMessageData (src ++ srcField) ++\n                          Lean.toMessageData \" ↦ \" ++\n                        Lean.toMessageData (tgt ++ tgtField) ++\n                      Lean.toMessageData \" is automatic.\")\n                pure (ForInStep.yield PUnit.unit)\n              else do\n                pure PUnit.unit\n                pure (ForInStep.yield PUnit.unit)\n    pure PUnit.unit\n  if (Array.size srcFields != Array.size tgtFields) = true then do\n      let y ←\n        Lean.throwError\n            (Lean.toMessageData \"Failed to map fields of \" ++ Lean.toMessageData src ++ Lean.toMessageData \", \" ++\n                        Lean.toMessageData tgt ++\n                      Lean.toMessageData \" with \" ++\n                    Lean.toMessageData srcFields ++\n                  Lean.toMessageData \" ↦ \" ++\n                Lean.toMessageData tgtFields ++\n              Lean.toMessageData \"\")\n      __do_jp y\n    else do\n      let y ← pure PUnit.unit\n      __do_jp y","name":"ToAdditive.proceedFieldsAux","doc":"if `f src = #[a_1, ..., a_n]` and `f tgt = #[b_1, ... b_n]` then `proceedFieldsAux src tgt f`\nwill insert translations from `src.a_i` to `tgt.b_i`. ","depth":41},{"term":"fun e => do\n  let env ← Lean.getEnv\n  let reorderFn : Lean.Name → List (List ℕ) := fun nm =>\n    Option.getD (Lean.NameMapExtension.find? ToAdditive.reorderAttr env nm) []\n  let e₂ ←\n    Lean.Meta.transform e\n        (fun e =>\n          let e0 := Lean.Expr.getAppFn e;\n          let es := Lean.Expr.getAppArgs e;\n          let __discr := Lean.Expr.constName? e0;\n          match __discr with\n          | some e0n =>\n            let reorder := reorderFn e0n;\n            let __do_jp := fun y =>\n              let needed_n := List.foldr Nat.max 0 (List.join reorder) + 1;\n              if (decide (needed_n ≤ Array.size es) || Array.size es == 0) = true then pure Lean.TransformStep.continue\n              else do\n                let e' ← ToAdditive.etaExpandN (needed_n - Array.size es) e\n                let cls : Lean.Name := `to_additive_detail\n                let __do_lift ← Lean.isTracingEnabledFor cls\n                let __do_jp : Unit → Lean.MetaM Lean.TransformStep := fun y =>\n                  pure (Lean.TransformStep.continue (some e'))\n                if __do_lift = true then do\n                    let y ←\n                      Lean.addTrace cls\n                          (Lean.toMessageData \"expanded \" ++ Lean.toMessageData e ++ Lean.toMessageData \" to \" ++\n                              Lean.toMessageData e' ++\n                            Lean.toMessageData \"\")\n                    __do_jp y\n                  else do\n                    let y ← pure PUnit.unit\n                    __do_jp y;\n            if List.isEmpty reorder = true then pure Lean.TransformStep.continue\n            else do\n              let y ← pure PUnit.unit\n              __do_jp y\n          | x => pure Lean.TransformStep.continue)\n        fun e => pure (Lean.TransformStep.done e)\n  let __do_jp : Unit → Lean.MetaM Lean.Expr := fun y => pure e₂\n  if (e != e₂) = true then\n      let cls := `to_additive_detail;\n      do\n      let __do_lift ← Lean.isTracingEnabledFor cls\n      if __do_lift = true then do\n          let y ←\n            Lean.addTrace cls\n                (Lean.toMessageData \"expand:\\nBefore: \" ++ Lean.toMessageData e ++ Lean.toMessageData \"\\nAfter:  \" ++\n                    Lean.toMessageData e₂ ++\n                  Lean.toMessageData \"\")\n          __do_jp y\n        else do\n          let y ← pure PUnit.unit\n          __do_jp y\n    else do\n      let y ← pure PUnit.unit\n      __do_jp y","name":"ToAdditive.expand","doc":"`e.expand` eta-expands all expressions that have as head a constant `n` in\n`reorder`. They are expanded until they are applied to one more argument than the maximum in\n`reorder.find n`. ","depth":44},{"term":"fun cfg src =>\n  let __discr := src;\n  match __discr with\n  | Lean.Name.str pre s =>\n    let cls := `to_additive_detail;\n    do\n    let __do_lift ← Lean.isTracingEnabledFor cls\n    let __do_jp : Unit → Lean.CoreM Lean.Name := fun y =>\n      let tgt_auto := ToAdditive.guessName s;\n      let depth := Lean.Name.getNumParts cfg.tgt;\n      do\n      let __do_lift ← Lean.getEnv\n      let pre : Lean.Name := Lean.Name.mapPrefix (ToAdditive.findTranslation? __do_lift) pre\n      match Lean.Name.splitAt pre (depth - 1) with\n        | (pre1, pre2) =>\n          let __do_jp := fun y =>\n            let res := if (cfg.tgt == Lean.Name.anonymous) = true then Lean.Name.str pre tgt_auto else pre1 ++ cfg.tgt;\n            let __do_jp := fun y =>\n              let __do_jp := fun y => pure res;\n              if (cfg.tgt != Lean.Name.anonymous) = true then\n                let cls := `to_additive_detail;\n                do\n                let __do_lift ← Lean.isTracingEnabledFor cls\n                if __do_lift = true then do\n                    let y ←\n                      Lean.addTrace cls\n                          (Lean.toMessageData \"The automatically generated name would be \" ++\n                              Lean.toMessageData (Lean.Name.str pre tgt_auto) ++\n                            Lean.toMessageData \"\")\n                    __do_jp y\n                  else do\n                    let y ← pure PUnit.unit\n                    __do_jp y\n              else do\n                let y ← pure PUnit.unit\n                __do_jp y;\n            if (res == src && cfg.tgt != src) = true then do\n              let y ←\n                Lean.throwError\n                    (Lean.toMessageData \"to_additive: can't transport \" ++ Lean.toMessageData src ++\n                      Lean.toMessageData \" to itself.\")\n              __do_jp y\n            else do\n              let y ← pure PUnit.unit\n              __do_jp y;\n          if (cfg.tgt == Lean.Name.str pre2 tgt_auto && !cfg.allowAutoName && cfg.tgt != src) = true then do\n            let y ←\n              Lean.Linter.logLintIf ToAdditive.linter.toAdditiveGenerateName cfg.ref\n                  (Lean.toMessageData \"to_additive correctly autogenerated target name for \" ++\n                              Lean.toMessageData src ++\n                            Lean.toMessageData \". \" ++\n                          Lean.toMessageData \"\\n\" ++\n                        Lean.toMessageData \"You may remove the explicit argument \" ++\n                      Lean.toMessageData cfg.tgt ++\n                    Lean.toMessageData \".\")\n            __do_jp y\n          else do\n            let y ← pure PUnit.unit\n            __do_jp y\n    if __do_lift = true then do\n        let y ←\n          Lean.addTrace cls\n              (Lean.toMessageData \"The name \" ++ Lean.toMessageData s ++ Lean.toMessageData \" splits as \" ++\n                  Lean.toMessageData (String.splitCase s 0) ++\n                Lean.toMessageData \"\")\n        __do_jp y\n      else do\n        let y ← pure PUnit.unit\n        __do_jp y\n  | x =>\n    Lean.throwError\n      (Lean.toMessageData \"to_additive: can't transport \" ++ Lean.toMessageData src ++ Lean.toMessageData \"\")","name":"ToAdditive.targetName","doc":"Return the provided target name or autogenerate one if one was not provided. ","depth":44}],"count":9}
{"noDocExamples":[{"term":"fun {𝕜} {V} {W} [NormedAddCommGroup V] [NormedAddCommGroup W] [NontriviallyNormedField 𝕜] [NormedSpace 𝕜 V]\n    [NormedSpace 𝕜 W] =>\n  NormedSpace.mk (_ : ∀ (t : 𝕜) (f : V →A[𝕜] W), ‖t • f‖ ≤ ‖t‖ * ‖f‖)","name":"ContinuousAffineMap.instNormedSpaceContinuousAffineMapToRingToNormedRingToNormedCommRingToNormedFieldToAddCommGroupToModuleToSeminormedAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddTorsorToNormedAddTorsorToAddCommGroupToModuleToSeminormedAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddTorsorToNormedAddTorsorToSeminormedAddCommGroupInstNormedAddCommGroupContinuousAffineMapToRingToNormedRingToNormedCommRingToNormedFieldToAddCommGroupToModuleToSeminormedAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddTorsorToNormedAddTorsorToAddCommGroupToModuleToSeminormedAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddTorsorToNormedAddTorsor","depth":29},{"term":"fun {R} {V} {W} {P} {Q} [Ring R] [AddCommGroup V] [Module R V] [TopologicalSpace P] [AddTorsor V P] [AddCommGroup W]\n    [Module R W] [TopologicalSpace Q] [AddTorsor W Q] =>\n  ContinuousMapClass.mk (_ : ∀ (self : P →A[R] Q), Continuous self.toFun)","name":"ContinuousAffineMap.instContinuousMapClassContinuousAffineMap","depth":36},{"term":"fun {R} {V} {W} {P} [Ring R] [AddCommGroup V] [Module R V] [TopologicalSpace P] [AddTorsor V P] [AddCommGroup W]\n    [Module R W] {S} [TopologicalSpace W] [Monoid S] [DistribMulAction S W] [SMulCommClass R S W]\n    [ContinuousConstSMul S W] =>\n  Function.Injective.mulAction FunLike.coe (_ : Function.Injective FunLike.coe)\n    (_ : ∀ (t : S) (f : P →A[R] W), ↑(t • f) = t • ↑f)","name":"ContinuousAffineMap.instMulActionContinuousAffineMapAddGroupIsAddTorsorToAddGroup","depth":41},{"term":"fun {𝕜} {V} {W} [NormedAddCommGroup V] [NormedAddCommGroup W] [NontriviallyNormedField 𝕜] [NormedSpace 𝕜 V]\n    [NormedSpace 𝕜 W] =>\n  AddGroupNorm.toNormedAddCommGroup\n    {\n      toAddGroupSeminorm :=\n        { toFun := fun f => max ‖↑f 0‖ ‖ContinuousAffineMap.contLinear f‖, map_zero' := (_ : max ‖↑0 0‖ ‖0‖ = 0),\n          add_le' :=\n            (_ :\n              ∀ (f g : V →A[𝕜] W),\n                (fun f => max ‖↑f 0‖ ‖ContinuousAffineMap.contLinear f‖) (f + g) ≤\n                  (fun f => max ‖↑f 0‖ ‖ContinuousAffineMap.contLinear f‖) f +\n                    (fun f => max ‖↑f 0‖ ‖ContinuousAffineMap.contLinear f‖) g),\n          neg' :=\n            (_ :\n              ∀ (f : V →A[𝕜] W),\n                max ‖↑(-f) 0‖ ‖-ContinuousAffineMap.contLinear f‖ = max ‖↑f 0‖ ‖ContinuousAffineMap.contLinear f‖) },\n      eq_zero_of_map_eq_zero' :=\n        (_ :\n          ∀ (f : V →A[𝕜] W),\n            AddGroupSeminorm.toFun\n                  { toFun := fun f => max ‖↑f 0‖ ‖ContinuousAffineMap.contLinear f‖,\n                    map_zero' := (_ : max ‖↑0 0‖ ‖0‖ = 0),\n                    add_le' :=\n                      (_ :\n                        ∀ (f g : V →A[𝕜] W),\n                          (fun f => max ‖↑f 0‖ ‖ContinuousAffineMap.contLinear f‖) (f + g) ≤\n                            (fun f => max ‖↑f 0‖ ‖ContinuousAffineMap.contLinear f‖) f +\n                              (fun f => max ‖↑f 0‖ ‖ContinuousAffineMap.contLinear f‖) g),\n                    neg' :=\n                      (_ :\n                        ∀ (f : V →A[𝕜] W),\n                          max ‖↑(-f) 0‖ ‖-ContinuousAffineMap.contLinear f‖ =\n                            max ‖↑f 0‖ ‖ContinuousAffineMap.contLinear f‖) }\n                  f =\n                0 →\n              f = 0) }","name":"ContinuousAffineMap.instNormedAddCommGroupContinuousAffineMapToRingToNormedRingToNormedCommRingToNormedFieldToAddCommGroupToModuleToSeminormedAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddTorsorToNormedAddTorsorToAddCommGroupToModuleToSeminormedAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddTorsorToNormedAddTorsor","depth":42}],"kind":"«term_→A[_]_»","examples":[{"term":"fun 𝕜 V W [NormedAddCommGroup V] [NormedAddCommGroup W] [NontriviallyNormedField 𝕜] [NormedSpace 𝕜 V]\n    [NormedSpace 𝕜 W] =>\n  {\n    toLinearEquiv :=\n      {\n        toLinearMap :=\n          {\n            toAddHom :=\n              { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                map_add' :=\n                  (_ :\n                    ∀ (x x_1 : V →A[𝕜] W),\n                      (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1) =\n                        (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1)) },\n            map_smul' :=\n              (_ :\n                ∀ (x : 𝕜) (x_1 : V →A[𝕜] W),\n                  AddHom.toFun\n                      { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                        map_add' :=\n                          (_ :\n                            ∀ (x x_2 : V →A[𝕜] W),\n                              (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                      (x • x_1) =\n                    AddHom.toFun\n                      { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                        map_add' :=\n                          (_ :\n                            ∀ (x x_2 : V →A[𝕜] W),\n                              (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                      (x • x_1)) },\n        invFun := fun p => ContinuousLinearMap.toContinuousAffineMap p.snd + ContinuousAffineMap.const 𝕜 V p.fst,\n        left_inv :=\n          (_ :\n            ∀ (f : V →A[𝕜] W),\n              (fun p => ContinuousLinearMap.toContinuousAffineMap p.snd + ContinuousAffineMap.const 𝕜 V p.fst)\n                  (AddHom.toFun\n                    {\n                        toAddHom :=\n                          { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                            map_add' :=\n                              (_ :\n                                ∀ (x x_1 : V →A[𝕜] W),\n                                  (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1) =\n                                    (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1)) },\n                        map_smul' :=\n                          (_ :\n                            ∀ (x : 𝕜) (x_1 : V →A[𝕜] W),\n                              AddHom.toFun\n                                  { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                    map_add' :=\n                                      (_ :\n                                        ∀ (x x_2 : V →A[𝕜] W),\n                                          (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                            (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                  (x • x_1) =\n                                AddHom.toFun\n                                  { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                    map_add' :=\n                                      (_ :\n                                        ∀ (x x_2 : V →A[𝕜] W),\n                                          (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                            (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                  (x • x_1)) }.toAddHom\n                    f) =\n                f),\n        right_inv :=\n          (_ :\n            ∀ (x : W × (V →L[𝕜] W)),\n              AddHom.toFun\n                  {\n                      toAddHom :=\n                        { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                          map_add' :=\n                            (_ :\n                              ∀ (x x_1 : V →A[𝕜] W),\n                                (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1) =\n                                  (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1)) },\n                      map_smul' :=\n                        (_ :\n                          ∀ (x : 𝕜) (x_1 : V →A[𝕜] W),\n                            AddHom.toFun\n                                { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                  map_add' :=\n                                    (_ :\n                                      ∀ (x x_2 : V →A[𝕜] W),\n                                        (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                          (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                (x • x_1) =\n                              AddHom.toFun\n                                { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                  map_add' :=\n                                    (_ :\n                                      ∀ (x x_2 : V →A[𝕜] W),\n                                        (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                          (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                (x • x_1)) }.toAddHom\n                  ((fun p => ContinuousLinearMap.toContinuousAffineMap p.snd + ContinuousAffineMap.const 𝕜 V p.fst) x) =\n                x) },\n    norm_map' :=\n      (_ :\n        ∀ (f : V →A[𝕜] W),\n          ‖↑{\n                    toLinearMap :=\n                      {\n                        toAddHom :=\n                          { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                            map_add' :=\n                              (_ :\n                                ∀ (x x_1 : V →A[𝕜] W),\n                                  (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1) =\n                                    (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1)) },\n                        map_smul' :=\n                          (_ :\n                            ∀ (x : 𝕜) (x_1 : V →A[𝕜] W),\n                              AddHom.toFun\n                                  { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                    map_add' :=\n                                      (_ :\n                                        ∀ (x x_2 : V →A[𝕜] W),\n                                          (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                            (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                  (x • x_1) =\n                                AddHom.toFun\n                                  { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                    map_add' :=\n                                      (_ :\n                                        ∀ (x x_2 : V →A[𝕜] W),\n                                          (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                            (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                  (x • x_1)) },\n                    invFun := fun p =>\n                      ContinuousLinearMap.toContinuousAffineMap p.snd + ContinuousAffineMap.const 𝕜 V p.fst,\n                    left_inv :=\n                      (_ :\n                        ∀ (f : V →A[𝕜] W),\n                          (fun p =>\n                                ContinuousLinearMap.toContinuousAffineMap p.snd + ContinuousAffineMap.const 𝕜 V p.fst)\n                              (AddHom.toFun\n                                {\n                                    toAddHom :=\n                                      { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                        map_add' :=\n                                          (_ :\n                                            ∀ (x x_1 : V →A[𝕜] W),\n                                              (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1) =\n                                                (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1)) },\n                                    map_smul' :=\n                                      (_ :\n                                        ∀ (x : 𝕜) (x_1 : V →A[𝕜] W),\n                                          AddHom.toFun\n                                              { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                                map_add' :=\n                                                  (_ :\n                                                    ∀ (x x_2 : V →A[𝕜] W),\n                                                      (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                                        (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                              (x • x_1) =\n                                            AddHom.toFun\n                                              { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                                map_add' :=\n                                                  (_ :\n                                                    ∀ (x x_2 : V →A[𝕜] W),\n                                                      (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                                        (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                              (x • x_1)) }.toAddHom\n                                f) =\n                            f),\n                    right_inv :=\n                      (_ :\n                        ∀ (x : W × (V →L[𝕜] W)),\n                          AddHom.toFun\n                              {\n                                  toAddHom :=\n                                    { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                      map_add' :=\n                                        (_ :\n                                          ∀ (x x_1 : V →A[𝕜] W),\n                                            (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1) =\n                                              (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1)) },\n                                  map_smul' :=\n                                    (_ :\n                                      ∀ (x : 𝕜) (x_1 : V →A[𝕜] W),\n                                        AddHom.toFun\n                                            { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                              map_add' :=\n                                                (_ :\n                                                  ∀ (x x_2 : V →A[𝕜] W),\n                                                    (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                                      (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                            (x • x_1) =\n                                          AddHom.toFun\n                                            { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                              map_add' :=\n                                                (_ :\n                                                  ∀ (x x_2 : V →A[𝕜] W),\n                                                    (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                                      (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                            (x • x_1)) }.toAddHom\n                              ((fun p =>\n                                  ContinuousLinearMap.toContinuousAffineMap p.snd + ContinuousAffineMap.const 𝕜 V p.fst)\n                                x) =\n                            x) }\n                f‖ =\n            ‖↑{\n                    toLinearMap :=\n                      {\n                        toAddHom :=\n                          { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                            map_add' :=\n                              (_ :\n                                ∀ (x x_1 : V →A[𝕜] W),\n                                  (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1) =\n                                    (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1)) },\n                        map_smul' :=\n                          (_ :\n                            ∀ (x : 𝕜) (x_1 : V →A[𝕜] W),\n                              AddHom.toFun\n                                  { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                    map_add' :=\n                                      (_ :\n                                        ∀ (x x_2 : V →A[𝕜] W),\n                                          (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                            (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                  (x • x_1) =\n                                AddHom.toFun\n                                  { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                    map_add' :=\n                                      (_ :\n                                        ∀ (x x_2 : V →A[𝕜] W),\n                                          (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                            (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                  (x • x_1)) },\n                    invFun := fun p =>\n                      ContinuousLinearMap.toContinuousAffineMap p.snd + ContinuousAffineMap.const 𝕜 V p.fst,\n                    left_inv :=\n                      (_ :\n                        ∀ (f : V →A[𝕜] W),\n                          (fun p =>\n                                ContinuousLinearMap.toContinuousAffineMap p.snd + ContinuousAffineMap.const 𝕜 V p.fst)\n                              (AddHom.toFun\n                                {\n                                    toAddHom :=\n                                      { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                        map_add' :=\n                                          (_ :\n                                            ∀ (x x_1 : V →A[𝕜] W),\n                                              (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1) =\n                                                (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1)) },\n                                    map_smul' :=\n                                      (_ :\n                                        ∀ (x : 𝕜) (x_1 : V →A[𝕜] W),\n                                          AddHom.toFun\n                                              { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                                map_add' :=\n                                                  (_ :\n                                                    ∀ (x x_2 : V →A[𝕜] W),\n                                                      (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                                        (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                              (x • x_1) =\n                                            AddHom.toFun\n                                              { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                                map_add' :=\n                                                  (_ :\n                                                    ∀ (x x_2 : V →A[𝕜] W),\n                                                      (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                                        (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                              (x • x_1)) }.toAddHom\n                                f) =\n                            f),\n                    right_inv :=\n                      (_ :\n                        ∀ (x : W × (V →L[𝕜] W)),\n                          AddHom.toFun\n                              {\n                                  toAddHom :=\n                                    { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                      map_add' :=\n                                        (_ :\n                                          ∀ (x x_1 : V →A[𝕜] W),\n                                            (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1) =\n                                              (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_1)) },\n                                  map_smul' :=\n                                    (_ :\n                                      ∀ (x : 𝕜) (x_1 : V →A[𝕜] W),\n                                        AddHom.toFun\n                                            { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                              map_add' :=\n                                                (_ :\n                                                  ∀ (x x_2 : V →A[𝕜] W),\n                                                    (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                                      (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                            (x • x_1) =\n                                          AddHom.toFun\n                                            { toFun := fun f => (↑f 0, ContinuousAffineMap.contLinear f),\n                                              map_add' :=\n                                                (_ :\n                                                  ∀ (x x_2 : V →A[𝕜] W),\n                                                    (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2) =\n                                                      (fun f => (↑f 0, ContinuousAffineMap.contLinear f)) (x + x_2)) }\n                                            (x • x_1)) }.toAddHom\n                              ((fun p =>\n                                  ContinuousLinearMap.toContinuousAffineMap p.snd + ContinuousAffineMap.const 𝕜 V p.fst)\n                                x) =\n                            x) }\n                f‖) }","name":"ContinuousAffineMap.toConstProdContinuousLinearMap","doc":"The space of affine maps between two normed spaces is linearly isometric to the product of the\ncodomain with the space of linear maps, by taking the value of the affine map at `(0 : V)` and the\nlinear part. ","depth":44}],"count":8}
{"noDocExamples":[{"term":"fun {α} s =>\n  Eq.mpr\n    (id\n      (Stream'.cons_append_stream (Stream'.head s) [] (Stream'.tail s) ▸\n        Eq.refl ([Stream'.head s] ++ₛ Stream'.tail s = s)))\n    (Eq.mpr\n      (id\n        (Stream'.nil_append_stream (Stream'.tail s) ▸\n          Eq.refl (Stream'.cons (Stream'.head s) ([] ++ₛ Stream'.tail s) = s)))\n      (Eq.mpr (id (Stream'.eta s ▸ Eq.refl (Stream'.cons (Stream'.head s) (Stream'.tail s) = s))) (Eq.refl s)))","name":"Stream'.append_stream_head_tail","depth":20},{"term":"fun {α} l s =>\n  List.rec (of_eq_true (Eq.trans (congrArg (Eq ↑s) (Stream'.Seq.nil_append ↑s)) (eq_self ↑s)))\n    (fun head tail tail_ih =>\n      of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg Eq\n              (Eq.trans (Stream'.Seq.ofStream_cons head (tail ++ₛ s)) (congrArg (Stream'.Seq.cons head) tail_ih)))\n            (Eq.trans (congrFun (congrArg Stream'.Seq.append (Stream'.Seq.ofList_cons head tail)) ↑s)\n              (Stream'.Seq.cons_append head ↑tail ↑s)))\n          (eq_self (Stream'.Seq.cons head (Stream'.Seq.append ↑tail ↑s)))))\n    l","name":"Stream'.Seq.ofStream_append","depth":24},{"term":"fun {α} n =>\n  Nat.rec (motive := fun n => ∀ (s : Stream' α), Stream'.take n s ++ₛ Stream'.drop n s = s)\n    (fun s => Eq.refl (Stream'.take Nat.zero s ++ₛ Stream'.drop Nat.zero s))\n    (fun n' ih s =>\n      Eq.mpr (id (Stream'.take_succ n' s ▸ Eq.refl (Stream'.take (Nat.succ n') s ++ₛ Stream'.drop (Nat.succ n') s = s)))\n        (Eq.mpr\n          (id\n            (Stream'.drop_succ n' s ▸\n              Eq.refl (Stream'.head s :: Stream'.take n' (Stream'.tail s) ++ₛ Stream'.drop (Nat.succ n') s = s)))\n          (Eq.mpr\n            (id\n              (Stream'.cons_append_stream (Stream'.head s) (Stream'.take n' (Stream'.tail s))\n                  (Stream'.drop n' (Stream'.tail s)) ▸\n                Eq.refl (Stream'.head s :: Stream'.take n' (Stream'.tail s) ++ₛ Stream'.drop n' (Stream'.tail s) = s)))\n            (Eq.mpr\n              (id\n                (ih (Stream'.tail s) ▸\n                  Eq.refl\n                    (Stream'.cons (Stream'.head s)\n                        (Stream'.take n' (Stream'.tail s) ++ₛ Stream'.drop n' (Stream'.tail s)) =\n                      s)))\n              (Eq.mpr (id (Stream'.eta s ▸ Eq.refl (Stream'.cons (Stream'.head s) (Stream'.tail s) = s)))\n                (Eq.refl s))))))\n    n","name":"Stream'.append_take_drop","depth":28},{"term":"fun {α} s =>\n  Stream'.ext fun n =>\n    Eq.mpr\n      (id\n        (Stream'.nth_zip Stream'.appendStream' n (Stream'.inits s) (Stream'.tails s) ▸\n          Eq.refl\n            (Stream'.nth (Stream'.zip Stream'.appendStream' (Stream'.inits s) (Stream'.tails s)) n =\n              Stream'.nth (Stream'.const s) n)))\n      (Eq.mpr\n        (id\n          (Stream'.nth_inits n s ▸\n            Eq.refl\n              (Stream'.nth (Stream'.inits s) n ++ₛ Stream'.nth (Stream'.tails s) n = Stream'.nth (Stream'.const s) n)))\n        (Eq.mpr\n          (id\n            (Stream'.nth_tails n s ▸\n              Eq.refl\n                (Stream'.take (Nat.succ n) s ++ₛ Stream'.nth (Stream'.tails s) n = Stream'.nth (Stream'.const s) n)))\n          (Eq.mpr\n            (id\n              (Stream'.nth_const n s ▸\n                Eq.refl\n                  (Stream'.take (Nat.succ n) s ++ₛ Stream'.drop n (Stream'.tail s) = Stream'.nth (Stream'.const s) n)))\n            (Eq.mpr\n              (id\n                (Stream'.take_succ n s ▸ Eq.refl (Stream'.take (Nat.succ n) s ++ₛ Stream'.drop n (Stream'.tail s) = s)))\n              (Eq.mpr\n                (id\n                  (Stream'.cons_append_stream (Stream'.head s) (Stream'.take n (Stream'.tail s))\n                      (Stream'.drop n (Stream'.tail s)) ▸\n                    Eq.refl\n                      (Stream'.head s :: Stream'.take n (Stream'.tail s) ++ₛ Stream'.drop n (Stream'.tail s) = s)))\n                (Eq.mpr\n                  (id\n                    (Stream'.append_take_drop n (Stream'.tail s) ▸\n                      Eq.refl\n                        (Stream'.cons (Stream'.head s)\n                            (Stream'.take n (Stream'.tail s) ++ₛ Stream'.drop n (Stream'.tail s)) =\n                          s)))\n                  (Eq.mpr (id (Stream'.eta s ▸ Eq.refl (Stream'.cons (Stream'.head s) (Stream'.tail s) = s)))\n                    (Eq.refl s))))))))","name":"Stream'.zip_inits_tails","depth":28},{"term":"fun {α} a =>\n  Stream'.coinduction rfl fun β fr ch =>\n    Eq.mpr\n      (id\n        (Stream'.cycle_eq [a]\n            (of_eq_true (Eq.trans (congrArg Not (eq_false' fun h => List.noConfusion h)) not_false_eq_true)) ▸\n          Eq.refl\n            (fr\n                (Stream'.tail\n                  (Stream'.cycle [a]\n                    (of_eq_true (Eq.trans (congrArg Not (eq_false' fun h => List.noConfusion h)) not_false_eq_true)))) =\n              fr (Stream'.tail (Stream'.const a)))))\n      (Eq.mpr\n        (id\n          (Stream'.const_eq a ▸\n            Eq.refl\n              (fr\n                  (Stream'.tail\n                    ([a] ++ₛ\n                      Stream'.cycle [a]\n                        (of_eq_true\n                          (Eq.trans (congrArg Not (eq_false' fun h => List.noConfusion h)) not_false_eq_true)))) =\n                fr (Stream'.tail (Stream'.const a)))))\n        ch)","name":"Stream'.cycle_singleton","depth":35}],"kind":"Stream'.«term_++ₛ_»","examples":[],"count":8}
{"noDocExamples":[{"term":"fun {α} {β} {G} {H} x [Fintype ↑(SimpleGraph.neighborSet G x.fst)] [Fintype ↑(SimpleGraph.neighborSet H x.snd)] =>\n  Fintype.ofEquiv\n    { x_1 //\n      x_1 ∈\n        Finset.disjUnion (SimpleGraph.neighborFinset G x.fst ×ˢ {x.snd}) ({x.fst} ×ˢ SimpleGraph.neighborFinset H x.snd)\n          (_ :\n            Disjoint (SimpleGraph.neighborFinset G x.fst ×ˢ {x.snd}) ({x.fst} ×ˢ SimpleGraph.neighborFinset H x.snd)) }\n    (Equiv.subtypeEquiv (Equiv.refl (α × β))\n      (_ :\n        ∀ (y : α × β),\n          y ∈\n              Finset.disjUnion (SimpleGraph.neighborFinset G x.fst ×ˢ {x.snd})\n                ({x.fst} ×ˢ SimpleGraph.neighborFinset H x.snd)\n                (_ :\n                  Disjoint (SimpleGraph.neighborFinset G x.fst ×ˢ {x.snd})\n                    ({x.fst} ×ˢ SimpleGraph.neighborFinset H x.snd)) ↔\n            ↑(Equiv.refl (α × β)) y ∈ SimpleGraph.neighborSet (G □ H) x))","name":"SimpleGraph.boxProdFintypeNeighborSet","depth":24},{"term":"fun {α} {β} {G} {H} x =>\n  Set.ext fun x_1 =>\n    Prod.casesOn x_1 fun a' b' =>\n      Eq.mpr\n        (id\n          (congr\n            (congrArg Iff\n              (Eq.trans (Mathlib.Combinatorics.SimpleGraph.Prod._auxLemma.7 (G □ H) x (a', b'))\n                Mathlib.Combinatorics.SimpleGraph.Prod._auxLemma.5))\n            (Eq.trans\n              (Mathlib.Combinatorics.SimpleGraph.Prod._auxLemma.8 (a', b') (SimpleGraph.neighborSet G x.fst ×ˢ {x.snd})\n                ({x.fst} ×ˢ SimpleGraph.neighborSet H x.snd))\n              (congr\n                (congrArg Or\n                  (Eq.trans Mathlib.Combinatorics.SimpleGraph.Prod._auxLemma.9\n                    (congr (congrArg And (Mathlib.Combinatorics.SimpleGraph.Prod._auxLemma.7 G x.fst a'))\n                      Mathlib.Combinatorics.SimpleGraph.Prod._auxLemma.10)))\n                (Eq.trans Mathlib.Combinatorics.SimpleGraph.Prod._auxLemma.9\n                  (congr (congrArg And Mathlib.Combinatorics.SimpleGraph.Prod._auxLemma.10)\n                    (Mathlib.Combinatorics.SimpleGraph.Prod._auxLemma.7 H x.snd b')))))))\n        (of_eq_true\n          (Eq.trans\n            (congr\n              (congrArg Iff\n                (congr\n                  (congrArg Or\n                    (Eq.trans\n                      (congrArg (And (SimpleGraph.Adj G x.fst a')) Mathlib.Combinatorics.SimpleGraph.Prod._auxLemma.3)\n                      Mathlib.Combinatorics.SimpleGraph.Prod._auxLemma.1))\n                  (Eq.trans\n                    (congrArg (And (SimpleGraph.Adj H x.snd b')) Mathlib.Combinatorics.SimpleGraph.Prod._auxLemma.3)\n                    Mathlib.Combinatorics.SimpleGraph.Prod._auxLemma.1)))\n              (congrFun (congrArg Or Mathlib.Combinatorics.SimpleGraph.Prod._auxLemma.1)\n                (a' = x.fst ∧ SimpleGraph.Adj H x.snd b')))\n            (iff_self (b' = x.snd ∧ SimpleGraph.Adj G x.fst a' ∨ a' = x.fst ∧ SimpleGraph.Adj H x.snd b'))))","name":"SimpleGraph.boxProd_neighborSet","depth":32}],"kind":"SimpleGraph.«term_□_»","examples":[{"term":"fun {α} {β} G H b =>\n  {\n    toEmbedding :=\n      { toFun := fun a => (a, b),\n        inj' :=\n          (_ :\n            ∀ (x x_1 : α),\n              (fun a => (a, b)) x = (fun a => (a, b)) x_1 → ((fun a => (a, b)) x).fst = ((fun a => (a, b)) x_1).fst) },\n    map_rel_iff' := (_ : ∀ {x x_1 : α}, SimpleGraph.Adj (G □ H) (x, b) (x_1, b) ↔ SimpleGraph.Adj G x x_1) }","name":"SimpleGraph.boxProdLeft","doc":"The embedding of `G` into `G □ H` given by `b`. ","depth":15},{"term":"fun {α} {β} G H a =>\n  { toEmbedding := { toFun := Prod.mk a, inj' := (_ : ∀ (x x_1 : β), (a, x) = (a, x_1) → (a, x).snd = (a, x_1).snd) },\n    map_rel_iff' := (_ : ∀ {x x_1 : β}, SimpleGraph.Adj (G □ H) (a, x) (a, x_1) ↔ SimpleGraph.Adj H x x_1) }","name":"SimpleGraph.boxProdRight","doc":"The embedding of `H` into `G □ H` given by `a`. ","depth":15},{"term":"fun {α} {β} {γ} G H I =>\n  { toEquiv := Equiv.prodAssoc α β γ,\n    map_rel_iff' :=\n      (_ :\n        ∀ {x y : (α × β) × γ},\n          SimpleGraph.Adj (G □ (H □ I)) (x.fst.fst, x.fst.snd, x.snd) (y.fst.fst, y.fst.snd, y.snd) ↔\n            SimpleGraph.Adj (G □ H □ I) x y) }","name":"SimpleGraph.boxProdAssoc","doc":"The box product is associative up to isomorphism. `Equiv.prodAssoc` as a graph isomorphism. ","depth":17}],"count":8}
{"noDocExamples":[{"term":"fun {α} {n} a v =>\n  Subtype.casesOn (motive := fun t => v = t → Sym.ofVector (a ::ᵥ v) = a ::ₛ Sym.ofVector v) v\n    (fun val property h => Eq.symm h ▸ Eq.refl (Sym.ofVector (a ::ᵥ { val := val, property := property }))) (Eq.refl v)","name":"Sym.ofVector_cons","depth":23},{"term":"fun {n k} s =>\n  of_eq_true\n    (Eq.trans\n      (congrFun\n        (congrArg Eq\n          (Sym.erase_cons_head s 0 ((fun s => { val := 0 ::ₛ s, property := Sym.mem_cons_self 0 s }) s).property))\n        s)\n      (eq_self s))","name":"Sym.e1.proof_4","depth":33},{"term":"fun {α} {n} a v =>\n  Subtype.ext\n    (Subtype.casesOn (motive := fun t => v = t → ↑(a ::ₛ Sym.ofVector v) = ↑(Sym.ofVector (a ::ᵥ v))) v\n      (fun val property h => Eq.symm h ▸ Eq.refl ↑(a ::ₛ Sym.ofVector { val := val, property := property }))\n      (Eq.refl v))","name":"Sym.cons_of_coe_eq","depth":39}],"kind":"Sym.«term_::ₛ_»","examples":[{"term":"fun {α} {n} x =>\n  match x with\n  | Sum.inl s => none ::ₛ s\n  | Sum.inr s => Sym.map (↑Function.Embedding.some) s","name":"SymOptionSuccEquiv.decode","doc":"Inverse of `Sym_option_succ_equiv.decode`. ","depth":15},{"term":"fun {n k} =>\n  { toFun := fun s => Sym.erase (↑s) 0 (_ : 0 ∈ ↑s),\n    invFun := fun s => { val := 0 ::ₛ s, property := (_ : 0 ∈ 0 ::ₛ s) },\n    left_inv :=\n      (_ :\n        ∀ (s : { s // 0 ∈ s }),\n          { val := 0 ::ₛ (fun s => Sym.erase (↑s) 0 (_ : 0 ∈ ↑s)) s,\n              property := (_ : 0 ∈ 0 ::ₛ (fun s => Sym.erase (↑s) 0 (_ : 0 ∈ ↑s)) s) } =\n            s),\n    right_inv :=\n      (_ :\n        ∀ (s : Sym (Fin (Nat.succ n)) k),\n          Sym.erase (0 ::ₛ s) 0 (_ : 0 ∈ ↑((fun s => { val := 0 ::ₛ s, property := (_ : 0 ∈ 0 ::ₛ s) }) s)) = s) }","name":"Sym.e1","doc":"Over `Fin (n + 1)`, the multisets of size `k + 1` containing `0` are equivalent to those of size\n`k`, as demonstrated by respectively erasing or appending `0`. ","depth":26}],"count":8}
{"noDocExamples":[{"term":"fun {ι₂} R [CommSemiring R] M [AddCommMonoid M] [Module R M] => smulCommClass_self R (⨂[R] (i : ι₂), M)","name":"PiTensorProduct.reindex.proof_2","depth":18},{"term":"fun {ι} R [CommSemiring R] M [AddCommMonoid M] [Module R M] => smulCommClass_self R (⨂[R] (i : ι), M)","name":"PiTensorProduct.reindex.proof_3","depth":18},{"term":"fun {ι} {R} [CommSemiring R] s [(i : ι) → AddCommMonoid (s i)] [(i : ι) → Module R (s i)] =>\n  let src := AddCon.addMonoid (addConGen (PiTensorProduct.Eqv R s));\n  AddCommMonoid.mk (_ : ∀ (x y : ⨂[R] (i : ι), s i), x + y = y + x)","name":"PiTensorProduct.instAddCommMonoidPiTensorProduct","depth":30}],"kind":"«term⨂[_]_,_»","examples":[{"term":"fun R n M [CommSemiring R] [AddCommMonoid M] [Module R M] => ⨂[R] (x : Fin n), M","name":"TensorPower","doc":"Homogenous tensor powers $M^{\\otimes n}$. `⨂[R]^n M` is a shorthand for\n`⨂[R] (i : Fin n), M`. ","depth":13},{"term":"fun {ι} {R} [CommSemiring R] {s} [(i : ι) → AddCommMonoid (s i)] [(i : ι) → Module R (s i)] {E} [AddCommMonoid E]\n    [Module R E] =>\n  {\n    toLinearMap :=\n      {\n        toAddHom :=\n          {\n            toFun := fun φ =>\n              let src := PiTensorProduct.liftAux φ;\n              {\n                toAddHom :=\n                  { toFun := src.toFun,\n                    map_add' :=\n                      (_ :\n                        ∀ (x y : ⨂[R] (i : ι), s i),\n                          ZeroHom.toFun (↑(PiTensorProduct.liftAux φ)) (x + y) =\n                            ZeroHom.toFun (↑(PiTensorProduct.liftAux φ)) x +\n                              ZeroHom.toFun (↑(PiTensorProduct.liftAux φ)) y) },\n                map_smul' :=\n                  (_ :\n                    ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                      ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) },\n            map_add' :=\n              (_ :\n                ∀ (φ₁ φ₂ : MultilinearMap R s E),\n                  (fun φ =>\n                        let src := PiTensorProduct.liftAux φ;\n                        {\n                          toAddHom :=\n                            { toFun := src.toFun,\n                              map_add' :=\n                                (_ :\n                                  ∀ (x y : ⨂[R] (i : ι), s i),\n                                    ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                          map_smul' :=\n                            (_ :\n                              ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) })\n                      (φ₁ + φ₂) =\n                    (fun φ =>\n                          let src := PiTensorProduct.liftAux φ;\n                          {\n                            toAddHom :=\n                              { toFun := src.toFun,\n                                map_add' :=\n                                  (_ :\n                                    ∀ (x y : ⨂[R] (i : ι), s i),\n                                      ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                            map_smul' :=\n                              (_ :\n                                ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                  ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) })\n                        φ₁ +\n                      (fun φ =>\n                          let src := PiTensorProduct.liftAux φ;\n                          {\n                            toAddHom :=\n                              { toFun := src.toFun,\n                                map_add' :=\n                                  (_ :\n                                    ∀ (x y : ⨂[R] (i : ι), s i),\n                                      ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                            map_smul' :=\n                              (_ :\n                                ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                  ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) })\n                        φ₂) },\n        map_smul' :=\n          (_ :\n            ∀ (r : R) (φ₂ : MultilinearMap R s E),\n              AddHom.toFun\n                  {\n                    toFun := fun φ =>\n                      let src := PiTensorProduct.liftAux φ;\n                      {\n                        toAddHom :=\n                          { toFun := src.toFun,\n                            map_add' :=\n                              (_ :\n                                ∀ (x y : ⨂[R] (i : ι), s i),\n                                  ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                        map_smul' :=\n                          (_ :\n                            ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                              ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) },\n                    map_add' :=\n                      (_ :\n                        ∀ (φ₁ φ₂ : MultilinearMap R s E),\n                          (fun φ =>\n                                let src := PiTensorProduct.liftAux φ;\n                                {\n                                  toAddHom :=\n                                    { toFun := src.toFun,\n                                      map_add' :=\n                                        (_ :\n                                          ∀ (x y : ⨂[R] (i : ι), s i),\n                                            ZeroHom.toFun (↑src) (x + y) =\n                                              ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                  map_smul' :=\n                                    (_ :\n                                      ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                        ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) })\n                              (φ₁ + φ₂) =\n                            (fun φ =>\n                                  let src := PiTensorProduct.liftAux φ;\n                                  {\n                                    toAddHom :=\n                                      { toFun := src.toFun,\n                                        map_add' :=\n                                          (_ :\n                                            ∀ (x y : ⨂[R] (i : ι), s i),\n                                              ZeroHom.toFun (↑src) (x + y) =\n                                                ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                    map_smul' :=\n                                      (_ :\n                                        ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                          ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) })\n                                φ₁ +\n                              (fun φ =>\n                                  let src := PiTensorProduct.liftAux φ;\n                                  {\n                                    toAddHom :=\n                                      { toFun := src.toFun,\n                                        map_add' :=\n                                          (_ :\n                                            ∀ (x y : ⨂[R] (i : ι), s i),\n                                              ZeroHom.toFun (↑src) (x + y) =\n                                                ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                    map_smul' :=\n                                      (_ :\n                                        ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                          ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) })\n                                φ₂) }\n                  (r • φ₂) =\n                ↑(RingHom.id R) r •\n                  AddHom.toFun\n                    {\n                      toFun := fun φ =>\n                        let src := PiTensorProduct.liftAux φ;\n                        {\n                          toAddHom :=\n                            { toFun := src.toFun,\n                              map_add' :=\n                                (_ :\n                                  ∀ (x y : ⨂[R] (i : ι), s i),\n                                    ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                          map_smul' :=\n                            (_ :\n                              ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) },\n                      map_add' :=\n                        (_ :\n                          ∀ (φ₁ φ₂ : MultilinearMap R s E),\n                            (fun φ =>\n                                  let src := PiTensorProduct.liftAux φ;\n                                  {\n                                    toAddHom :=\n                                      { toFun := src.toFun,\n                                        map_add' :=\n                                          (_ :\n                                            ∀ (x y : ⨂[R] (i : ι), s i),\n                                              ZeroHom.toFun (↑src) (x + y) =\n                                                ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                    map_smul' :=\n                                      (_ :\n                                        ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                          ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) })\n                                (φ₁ + φ₂) =\n                              (fun φ =>\n                                    let src := PiTensorProduct.liftAux φ;\n                                    {\n                                      toAddHom :=\n                                        { toFun := src.toFun,\n                                          map_add' :=\n                                            (_ :\n                                              ∀ (x y : ⨂[R] (i : ι), s i),\n                                                ZeroHom.toFun (↑src) (x + y) =\n                                                  ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                      map_smul' :=\n                                        (_ :\n                                          ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                            ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                              r • ↑(PiTensorProduct.liftAux φ) x) })\n                                  φ₁ +\n                                (fun φ =>\n                                    let src := PiTensorProduct.liftAux φ;\n                                    {\n                                      toAddHom :=\n                                        { toFun := src.toFun,\n                                          map_add' :=\n                                            (_ :\n                                              ∀ (x y : ⨂[R] (i : ι), s i),\n                                                ZeroHom.toFun (↑src) (x + y) =\n                                                  ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                      map_smul' :=\n                                        (_ :\n                                          ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                            ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                              r • ↑(PiTensorProduct.liftAux φ) x) })\n                                  φ₂) }\n                    φ₂) },\n    invFun := fun φ' => LinearMap.compMultilinearMap φ' (PiTensorProduct.tprod R),\n    left_inv :=\n      (_ :\n        ∀ (φ : MultilinearMap R s E),\n          (fun φ' => LinearMap.compMultilinearMap φ' (PiTensorProduct.tprod R))\n              (AddHom.toFun\n                {\n                    toAddHom :=\n                      {\n                        toFun := fun φ =>\n                          let src := PiTensorProduct.liftAux φ;\n                          {\n                            toAddHom :=\n                              { toFun := src.toFun,\n                                map_add' :=\n                                  (_ :\n                                    ∀ (x y : ⨂[R] (i : ι), s i),\n                                      ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                            map_smul' :=\n                              (_ :\n                                ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                  ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) },\n                        map_add' :=\n                          (_ :\n                            ∀ (φ₁ φ₂ : MultilinearMap R s E),\n                              (fun φ =>\n                                    let src := PiTensorProduct.liftAux φ;\n                                    {\n                                      toAddHom :=\n                                        { toFun := src.toFun,\n                                          map_add' :=\n                                            (_ :\n                                              ∀ (x y : ⨂[R] (i : ι), s i),\n                                                ZeroHom.toFun (↑src) (x + y) =\n                                                  ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                      map_smul' :=\n                                        (_ :\n                                          ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                            ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                              r • ↑(PiTensorProduct.liftAux φ) x) })\n                                  (φ₁ + φ₂) =\n                                (fun φ =>\n                                      let src := PiTensorProduct.liftAux φ;\n                                      {\n                                        toAddHom :=\n                                          { toFun := src.toFun,\n                                            map_add' :=\n                                              (_ :\n                                                ∀ (x y : ⨂[R] (i : ι), s i),\n                                                  ZeroHom.toFun (↑src) (x + y) =\n                                                    ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                        map_smul' :=\n                                          (_ :\n                                            ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                              ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                                r • ↑(PiTensorProduct.liftAux φ) x) })\n                                    φ₁ +\n                                  (fun φ =>\n                                      let src := PiTensorProduct.liftAux φ;\n                                      {\n                                        toAddHom :=\n                                          { toFun := src.toFun,\n                                            map_add' :=\n                                              (_ :\n                                                ∀ (x y : ⨂[R] (i : ι), s i),\n                                                  ZeroHom.toFun (↑src) (x + y) =\n                                                    ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                        map_smul' :=\n                                          (_ :\n                                            ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                              ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                                r • ↑(PiTensorProduct.liftAux φ) x) })\n                                    φ₂) },\n                    map_smul' :=\n                      (_ :\n                        ∀ (r : R) (φ₂ : MultilinearMap R s E),\n                          AddHom.toFun\n                              {\n                                toFun := fun φ =>\n                                  let src := PiTensorProduct.liftAux φ;\n                                  {\n                                    toAddHom :=\n                                      { toFun := src.toFun,\n                                        map_add' :=\n                                          (_ :\n                                            ∀ (x y : ⨂[R] (i : ι), s i),\n                                              ZeroHom.toFun (↑src) (x + y) =\n                                                ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                    map_smul' :=\n                                      (_ :\n                                        ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                          ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) },\n                                map_add' :=\n                                  (_ :\n                                    ∀ (φ₁ φ₂ : MultilinearMap R s E),\n                                      (fun φ =>\n                                            let src := PiTensorProduct.liftAux φ;\n                                            {\n                                              toAddHom :=\n                                                { toFun := src.toFun,\n                                                  map_add' :=\n                                                    (_ :\n                                                      ∀ (x y : ⨂[R] (i : ι), s i),\n                                                        ZeroHom.toFun (↑src) (x + y) =\n                                                          ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                              map_smul' :=\n                                                (_ :\n                                                  ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                                    ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                                      r • ↑(PiTensorProduct.liftAux φ) x) })\n                                          (φ₁ + φ₂) =\n                                        (fun φ =>\n                                              let src := PiTensorProduct.liftAux φ;\n                                              {\n                                                toAddHom :=\n                                                  { toFun := src.toFun,\n                                                    map_add' :=\n                                                      (_ :\n                                                        ∀ (x y : ⨂[R] (i : ι), s i),\n                                                          ZeroHom.toFun (↑src) (x + y) =\n                                                            ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                                map_smul' :=\n                                                  (_ :\n                                                    ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                                      ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                                        r • ↑(PiTensorProduct.liftAux φ) x) })\n                                            φ₁ +\n                                          (fun φ =>\n                                              let src := PiTensorProduct.liftAux φ;\n                                              {\n                                                toAddHom :=\n                                                  { toFun := src.toFun,\n                                                    map_add' :=\n                                                      (_ :\n                                                        ∀ (x y : ⨂[R] (i : ι), s i),\n                                                          ZeroHom.toFun (↑src) (x + y) =\n                                                            ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                                map_smul' :=\n                                                  (_ :\n                                                    ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                                      ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                                        r • ↑(PiTensorProduct.liftAux φ) x) })\n                                            φ₂) }\n                              (r • φ₂) =\n                            ↑(RingHom.id R) r •\n                              AddHom.toFun\n                                {\n                                  toFun := fun φ =>\n                                    let src := PiTensorProduct.liftAux φ;\n                                    {\n                                      toAddHom :=\n                                        { toFun := src.toFun,\n                                          map_add' :=\n                                            (_ :\n                                              ∀ (x y : ⨂[R] (i : ι), s i),\n                                                ZeroHom.toFun (↑src) (x + y) =\n                                                  ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                      map_smul' :=\n                                        (_ :\n                                          ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                            ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                              r • ↑(PiTensorProduct.liftAux φ) x) },\n                                  map_add' :=\n                                    (_ :\n                                      ∀ (φ₁ φ₂ : MultilinearMap R s E),\n                                        (fun φ =>\n                                              let src := PiTensorProduct.liftAux φ;\n                                              {\n                                                toAddHom :=\n                                                  { toFun := src.toFun,\n                                                    map_add' :=\n                                                      (_ :\n                                                        ∀ (x y : ⨂[R] (i : ι), s i),\n                                                          ZeroHom.toFun (↑src) (x + y) =\n                                                            ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                                map_smul' :=\n                                                  (_ :\n                                                    ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                                      ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                                        r • ↑(PiTensorProduct.liftAux φ) x) })\n                                            (φ₁ + φ₂) =\n                                          (fun φ =>\n                                                let src := PiTensorProduct.liftAux φ;\n                                                {\n                                                  toAddHom :=\n                                                    { toFun := src.toFun,\n                                                      map_add' :=\n                                                        (_ :\n                                                          ∀ (x y : ⨂[R] (i : ι), s i),\n                                                            ZeroHom.toFun (↑src) (x + y) =\n                                                              ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                                  map_smul' :=\n                                                    (_ :\n                                                      ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                                        ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                                          r • ↑(PiTensorProduct.liftAux φ) x) })\n                                              φ₁ +\n                                            (fun φ =>\n                                                let src := PiTensorProduct.liftAux φ;\n                                                {\n                                                  toAddHom :=\n                                                    { toFun := src.toFun,\n                                                      map_add' :=\n                                                        (_ :\n                                                          ∀ (x y : ⨂[R] (i : ι), s i),\n                                                            ZeroHom.toFun (↑src) (x + y) =\n                                                              ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                                  map_smul' :=\n                                                    (_ :\n                                                      ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                                        ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                                          r • ↑(PiTensorProduct.liftAux φ) x) })\n                                              φ₂) }\n                                φ₂) }.toAddHom\n                φ) =\n            φ),\n    right_inv :=\n      (_ :\n        ∀ (φ : (⨂[R] (i : ι), s i) →ₗ[R] E),\n          AddHom.toFun\n              {\n                  toAddHom :=\n                    {\n                      toFun := fun φ =>\n                        let src := PiTensorProduct.liftAux φ;\n                        {\n                          toAddHom :=\n                            { toFun := src.toFun,\n                              map_add' :=\n                                (_ :\n                                  ∀ (x y : ⨂[R] (i : ι), s i),\n                                    ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                          map_smul' :=\n                            (_ :\n                              ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) },\n                      map_add' :=\n                        (_ :\n                          ∀ (φ₁ φ₂ : MultilinearMap R s E),\n                            (fun φ =>\n                                  let src := PiTensorProduct.liftAux φ;\n                                  {\n                                    toAddHom :=\n                                      { toFun := src.toFun,\n                                        map_add' :=\n                                          (_ :\n                                            ∀ (x y : ⨂[R] (i : ι), s i),\n                                              ZeroHom.toFun (↑src) (x + y) =\n                                                ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                    map_smul' :=\n                                      (_ :\n                                        ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                          ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) })\n                                (φ₁ + φ₂) =\n                              (fun φ =>\n                                    let src := PiTensorProduct.liftAux φ;\n                                    {\n                                      toAddHom :=\n                                        { toFun := src.toFun,\n                                          map_add' :=\n                                            (_ :\n                                              ∀ (x y : ⨂[R] (i : ι), s i),\n                                                ZeroHom.toFun (↑src) (x + y) =\n                                                  ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                      map_smul' :=\n                                        (_ :\n                                          ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                            ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                              r • ↑(PiTensorProduct.liftAux φ) x) })\n                                  φ₁ +\n                                (fun φ =>\n                                    let src := PiTensorProduct.liftAux φ;\n                                    {\n                                      toAddHom :=\n                                        { toFun := src.toFun,\n                                          map_add' :=\n                                            (_ :\n                                              ∀ (x y : ⨂[R] (i : ι), s i),\n                                                ZeroHom.toFun (↑src) (x + y) =\n                                                  ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                      map_smul' :=\n                                        (_ :\n                                          ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                            ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                              r • ↑(PiTensorProduct.liftAux φ) x) })\n                                  φ₂) },\n                  map_smul' :=\n                    (_ :\n                      ∀ (r : R) (φ₂ : MultilinearMap R s E),\n                        AddHom.toFun\n                            {\n                              toFun := fun φ =>\n                                let src := PiTensorProduct.liftAux φ;\n                                {\n                                  toAddHom :=\n                                    { toFun := src.toFun,\n                                      map_add' :=\n                                        (_ :\n                                          ∀ (x y : ⨂[R] (i : ι), s i),\n                                            ZeroHom.toFun (↑src) (x + y) =\n                                              ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                  map_smul' :=\n                                    (_ :\n                                      ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                        ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) },\n                              map_add' :=\n                                (_ :\n                                  ∀ (φ₁ φ₂ : MultilinearMap R s E),\n                                    (fun φ =>\n                                          let src := PiTensorProduct.liftAux φ;\n                                          {\n                                            toAddHom :=\n                                              { toFun := src.toFun,\n                                                map_add' :=\n                                                  (_ :\n                                                    ∀ (x y : ⨂[R] (i : ι), s i),\n                                                      ZeroHom.toFun (↑src) (x + y) =\n                                                        ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                            map_smul' :=\n                                              (_ :\n                                                ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                                  ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                                    r • ↑(PiTensorProduct.liftAux φ) x) })\n                                        (φ₁ + φ₂) =\n                                      (fun φ =>\n                                            let src := PiTensorProduct.liftAux φ;\n                                            {\n                                              toAddHom :=\n                                                { toFun := src.toFun,\n                                                  map_add' :=\n                                                    (_ :\n                                                      ∀ (x y : ⨂[R] (i : ι), s i),\n                                                        ZeroHom.toFun (↑src) (x + y) =\n                                                          ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                              map_smul' :=\n                                                (_ :\n                                                  ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                                    ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                                      r • ↑(PiTensorProduct.liftAux φ) x) })\n                                          φ₁ +\n                                        (fun φ =>\n                                            let src := PiTensorProduct.liftAux φ;\n                                            {\n                                              toAddHom :=\n                                                { toFun := src.toFun,\n                                                  map_add' :=\n                                                    (_ :\n                                                      ∀ (x y : ⨂[R] (i : ι), s i),\n                                                        ZeroHom.toFun (↑src) (x + y) =\n                                                          ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                              map_smul' :=\n                                                (_ :\n                                                  ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                                    ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                                      r • ↑(PiTensorProduct.liftAux φ) x) })\n                                          φ₂) }\n                            (r • φ₂) =\n                          ↑(RingHom.id R) r •\n                            AddHom.toFun\n                              {\n                                toFun := fun φ =>\n                                  let src := PiTensorProduct.liftAux φ;\n                                  {\n                                    toAddHom :=\n                                      { toFun := src.toFun,\n                                        map_add' :=\n                                          (_ :\n                                            ∀ (x y : ⨂[R] (i : ι), s i),\n                                              ZeroHom.toFun (↑src) (x + y) =\n                                                ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                    map_smul' :=\n                                      (_ :\n                                        ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                          ↑(PiTensorProduct.liftAux φ) (r • x) = r • ↑(PiTensorProduct.liftAux φ) x) },\n                                map_add' :=\n                                  (_ :\n                                    ∀ (φ₁ φ₂ : MultilinearMap R s E),\n                                      (fun φ =>\n                                            let src := PiTensorProduct.liftAux φ;\n                                            {\n                                              toAddHom :=\n                                                { toFun := src.toFun,\n                                                  map_add' :=\n                                                    (_ :\n                                                      ∀ (x y : ⨂[R] (i : ι), s i),\n                                                        ZeroHom.toFun (↑src) (x + y) =\n                                                          ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                              map_smul' :=\n                                                (_ :\n                                                  ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                                    ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                                      r • ↑(PiTensorProduct.liftAux φ) x) })\n                                          (φ₁ + φ₂) =\n                                        (fun φ =>\n                                              let src := PiTensorProduct.liftAux φ;\n                                              {\n                                                toAddHom :=\n                                                  { toFun := src.toFun,\n                                                    map_add' :=\n                                                      (_ :\n                                                        ∀ (x y : ⨂[R] (i : ι), s i),\n                                                          ZeroHom.toFun (↑src) (x + y) =\n                                                            ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                                map_smul' :=\n                                                  (_ :\n                                                    ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                                      ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                                        r • ↑(PiTensorProduct.liftAux φ) x) })\n                                            φ₁ +\n                                          (fun φ =>\n                                              let src := PiTensorProduct.liftAux φ;\n                                              {\n                                                toAddHom :=\n                                                  { toFun := src.toFun,\n                                                    map_add' :=\n                                                      (_ :\n                                                        ∀ (x y : ⨂[R] (i : ι), s i),\n                                                          ZeroHom.toFun (↑src) (x + y) =\n                                                            ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                                                map_smul' :=\n                                                  (_ :\n                                                    ∀ (r : R) (x : ⨂[R] (i : ι), s i),\n                                                      ↑(PiTensorProduct.liftAux φ) (r • x) =\n                                                        r • ↑(PiTensorProduct.liftAux φ) x) })\n                                            φ₂) }\n                              φ₂) }.toAddHom\n              ((fun φ' => LinearMap.compMultilinearMap φ' (PiTensorProduct.tprod R)) φ) =\n            φ) }","name":"PiTensorProduct.lift","doc":"Constructing a linear map `(⨂[R] i, s i) → E` given a `MultilinearMap R s E` with the\nproperty that its composition with the canonical `MultilinearMap R s E` is\nthe given multilinear map `φ`. ","depth":36}],"count":8}
{"noDocExamples":[{"term":"fun {R} [Ring R] {M} [AddCommGroup M] [Module R M] {x y} =>\n  Eq.mpr (id (propext SModEq.def ▸ Eq.refl (x ≡ y [SMOD ⊥] ↔ x = y)))\n    (Eq.mpr\n      (id (propext (Submodule.Quotient.eq ⊥) ▸ Eq.refl (Submodule.Quotient.mk x = Submodule.Quotient.mk y ↔ x = y)))\n      (Eq.mpr (id (propext (Submodule.mem_bot R) ▸ Eq.refl (x - y ∈ ⊥ ↔ x = y)))\n        (Eq.mpr (id (propext sub_eq_zero ▸ Eq.refl (x - y = 0 ↔ x = y))) Iff.rfl)))","name":"SModEq.bot","depth":32},{"term":"fun {R} [Ring R] {M} [AddCommGroup M] [Module R M] {U} {x} =>\n  Eq.mpr (id (propext SModEq.def ▸ Eq.refl (x ≡ 0 [SMOD U] ↔ x ∈ U)))\n    (Eq.mpr\n      (id (propext (Submodule.Quotient.eq U) ▸ Eq.refl (Submodule.Quotient.mk x = Submodule.Quotient.mk 0 ↔ x ∈ U)))\n      (Eq.mpr (id (sub_zero x ▸ Eq.refl (x - 0 ∈ U ↔ x ∈ U))) Iff.rfl))","name":"SModEq.zero","depth":32},{"term":"fun {R} [Ring R] {M} [AddCommGroup M] [Module R M] {U} {x y} =>\n  Eq.mpr (id (propext SModEq.def ▸ Eq.refl (x ≡ y [SMOD U] ↔ x - y ∈ U)))\n    (Eq.mpr\n      (id (propext (Submodule.Quotient.eq U) ▸ Eq.refl (Submodule.Quotient.mk x = Submodule.Quotient.mk y ↔ x - y ∈ U)))\n      Iff.rfl)","name":"SModEq.sub_mem","depth":32},{"term":"fun {R} [Ring R] {M} [AddCommGroup M] [Module R M] {U} {x y} hxy c =>\n  Eq.mpr (id (propext SModEq.def ▸ Eq.refl (c • x ≡ c • y [SMOD U])))\n    (id\n      (of_eq_true\n        (Eq.trans\n          (congrFun (congrArg Eq (congrArg (HSMul.hSMul c) (Eq.mp (propext SModEq.def ▸ Eq.refl (x ≡ y [SMOD U])) hxy)))\n            (c • Submodule.Quotient.mk y))\n          (eq_self (c • Submodule.Quotient.mk y)))))","name":"SModEq.smul","depth":38},{"term":"fun {R} [CommRing R] M [AddCommGroup M] [Module R M] =>\n  {\n    prec' := fun f x =>\n      Exists.intro 0 fun n =>\n        Eq.mpr (id (Ideal.top_pow R n ▸ Eq.refl (f n ≡ 0 [SMOD ⊤ ^ n • ⊤])))\n          (Eq.mpr (id (Submodule.top_smul ⊤ ▸ Eq.refl (f n ≡ 0 [SMOD ⊤ • ⊤]))) SModEq.top) }","name":"IsPrecomplete.top.proof_1","depth":39}],"kind":"«term_≡_[SMOD_]»","examples":[],"count":8}
{"noDocExamples":[{"term":"fun {C} [CategoryTheory.Category.{u_1, u_2} C] [CategoryTheory.MonoidalCategory C] {X₁ X₂ Y} p₁ p₂ =>\n  Eq.mpr\n    (id\n      (Eq.symm CategoryTheory.comp_leftAdjointMate ▸\n        Eq.refl\n          (CategoryTheory.CategoryStruct.comp (ᘁCategoryTheory.CategoryStruct.id Y)\n              (ᘁCategoryTheory.CategoryStruct.id Y) =\n            CategoryTheory.CategoryStruct.id X₁)))\n    (Eq.mpr\n      (id\n        (CategoryTheory.Category.comp_id (CategoryTheory.CategoryStruct.id Y) ▸\n          Eq.refl\n            ((ᘁCategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Y)\n                  (CategoryTheory.CategoryStruct.id Y)) =\n              CategoryTheory.CategoryStruct.id X₁)))\n      (Eq.mpr\n        (id\n          (CategoryTheory.leftAdjointMate_id ▸\n            Eq.refl ((ᘁCategoryTheory.CategoryStruct.id Y) = CategoryTheory.CategoryStruct.id X₁)))\n        (Eq.refl (CategoryTheory.CategoryStruct.id ᘁY))))","name":"CategoryTheory.leftDualIso.proof_1","depth":31},{"term":"fun {C} [CategoryTheory.Category.{u_1, u_2} C] [CategoryTheory.MonoidalCategory C] {X₁ X₂ Y} p₁ p₂ =>\n  Eq.mpr\n    (id\n      (Eq.symm CategoryTheory.comp_leftAdjointMate ▸\n        Eq.refl\n          (CategoryTheory.CategoryStruct.comp (ᘁCategoryTheory.CategoryStruct.id Y)\n              (ᘁCategoryTheory.CategoryStruct.id Y) =\n            CategoryTheory.CategoryStruct.id X₂)))\n    (Eq.mpr\n      (id\n        (CategoryTheory.Category.comp_id (CategoryTheory.CategoryStruct.id Y) ▸\n          Eq.refl\n            ((ᘁCategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Y)\n                  (CategoryTheory.CategoryStruct.id Y)) =\n              CategoryTheory.CategoryStruct.id X₂)))\n      (Eq.mpr\n        (id\n          (CategoryTheory.leftAdjointMate_id ▸\n            Eq.refl ((ᘁCategoryTheory.CategoryStruct.id Y) = CategoryTheory.CategoryStruct.id X₂)))\n        (Eq.refl (CategoryTheory.CategoryStruct.id ᘁY))))","name":"CategoryTheory.leftDualIso.proof_2","depth":31},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X Y} [CategoryTheory.HasLeftDual X]\n    [CategoryTheory.HasLeftDual Y] f =>\n  Equiv.injective (CategoryTheory.tensorRightHomEquiv (CategoryTheory.MonoidalCategory.tensorUnit C) (ᘁY) Y ᘁX).symm\n    (of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (CategoryTheory.tensorRightHomEquiv_symm_coevaluation_comp_tensor_id (ᘁf)))\n          (CategoryTheory.tensorRightHomEquiv_symm_coevaluation_comp_id_tensor f))\n        (eq_self (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor ᘁY).hom (ᘁf)))))","name":"CategoryTheory.coevaluation_comp_leftAdjointMate","depth":35},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X Y} [CategoryTheory.HasLeftDual X]\n    [CategoryTheory.HasLeftDual Y] f =>\n  Equiv.injective (CategoryTheory.tensorLeftHomEquiv (ᘁY) (ᘁX) X (CategoryTheory.MonoidalCategory.tensorUnit C))\n    (of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (CategoryTheory.tensorLeftHomEquiv_id_tensor_comp_evaluation (ᘁf)))\n          (CategoryTheory.tensorLeftHomEquiv_tensor_id_comp_evaluation f))\n        (eq_self (CategoryTheory.CategoryStruct.comp (ᘁf) (CategoryTheory.MonoidalCategory.rightUnitor ᘁX).inv))))","name":"CategoryTheory.leftAdjointMate_comp_evaluation","depth":35}],"kind":"CategoryTheory.«termᘁ__1»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X₁ X₂ Y} p₁ p₂ =>\n  CategoryTheory.Iso.mk (ᘁCategoryTheory.CategoryStruct.id Y) (ᘁCategoryTheory.CategoryStruct.id Y)","name":"CategoryTheory.leftDualIso","doc":"Left duals are isomorphic. ","depth":21}],"count":7}
{"noDocExamples":[{"term":"fun {C} [CategoryTheory.Category.{u_1, u_2} C] [CategoryTheory.MonoidalCategory C] {X Y₁ Y₂} p₁ p₂ =>\n  Eq.mpr\n    (id\n      (Eq.symm CategoryTheory.comp_rightAdjointMate ▸\n        Eq.refl\n          (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Xᘁ)\n              (CategoryTheory.CategoryStruct.id Xᘁ) =\n            CategoryTheory.CategoryStruct.id Y₂)))\n    (Eq.mpr\n      (id\n        (CategoryTheory.Category.comp_id (CategoryTheory.CategoryStruct.id X) ▸\n          Eq.refl\n            (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X)\n                  (CategoryTheory.CategoryStruct.id X)ᘁ =\n              CategoryTheory.CategoryStruct.id Y₂)))\n      (Eq.mpr\n        (id\n          (CategoryTheory.rightAdjointMate_id ▸\n            Eq.refl (CategoryTheory.CategoryStruct.id Xᘁ = CategoryTheory.CategoryStruct.id Y₂)))\n        (Eq.refl (CategoryTheory.CategoryStruct.id Xᘁ))))","name":"CategoryTheory.rightDualIso.proof_2","depth":31},{"term":"fun {C} [CategoryTheory.Category.{u_1, u_2} C] [CategoryTheory.MonoidalCategory C] {X Y₁ Y₂} p₁ p₂ =>\n  Eq.mpr\n    (id\n      (Eq.symm CategoryTheory.comp_rightAdjointMate ▸\n        Eq.refl\n          (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Xᘁ)\n              (CategoryTheory.CategoryStruct.id Xᘁ) =\n            CategoryTheory.CategoryStruct.id Y₁)))\n    (Eq.mpr\n      (id\n        (CategoryTheory.Category.comp_id (CategoryTheory.CategoryStruct.id X) ▸\n          Eq.refl\n            (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X)\n                  (CategoryTheory.CategoryStruct.id X)ᘁ =\n              CategoryTheory.CategoryStruct.id Y₁)))\n      (Eq.mpr\n        (id\n          (CategoryTheory.rightAdjointMate_id ▸\n            Eq.refl (CategoryTheory.CategoryStruct.id Xᘁ = CategoryTheory.CategoryStruct.id Y₁)))\n        (Eq.refl (CategoryTheory.CategoryStruct.id Xᘁ))))","name":"CategoryTheory.rightDualIso.proof_1","depth":31},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X Y} [CategoryTheory.HasRightDual X]\n    [CategoryTheory.HasRightDual Y] f =>\n  Equiv.injective (CategoryTheory.tensorLeftHomEquiv (CategoryTheory.MonoidalCategory.tensorUnit C) Y Yᘁ Xᘁ).symm\n    (of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (CategoryTheory.tensorLeftHomEquiv_symm_coevaluation_comp_id_tensor (fᘁ)))\n          (CategoryTheory.tensorLeftHomEquiv_symm_coevaluation_comp_tensor_id f))\n        (eq_self (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor Yᘁ).hom (fᘁ)))))","name":"CategoryTheory.coevaluation_comp_rightAdjointMate","depth":35},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X Y} [CategoryTheory.HasRightDual X]\n    [CategoryTheory.HasRightDual Y] f =>\n  Equiv.injective (CategoryTheory.tensorRightHomEquiv Yᘁ X Xᘁ (CategoryTheory.MonoidalCategory.tensorUnit C))\n    (of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (CategoryTheory.tensorRightHomEquiv_tensor_id_comp_evaluation (fᘁ)))\n          (CategoryTheory.tensorRightHomEquiv_id_tensor_comp_evaluation f))\n        (eq_self (CategoryTheory.CategoryStruct.comp (fᘁ) (CategoryTheory.MonoidalCategory.leftUnitor Xᘁ).inv))))","name":"CategoryTheory.rightAdjointMate_comp_evaluation","depth":36}],"kind":"CategoryTheory.«term_ᘁ_1»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {X Y₁ Y₂} p₁ p₂ =>\n  CategoryTheory.Iso.mk (CategoryTheory.CategoryStruct.id Xᘁ) (CategoryTheory.CategoryStruct.id Xᘁ)","name":"CategoryTheory.rightDualIso","doc":"Right duals are isomorphic. ","depth":21}],"count":7}
{"noDocExamples":[],"kind":"«term_≃+*_»","examples":[{"term":"fun R [Mul R] [Add R] => R ≃+* R","name":"RingAut","doc":"The group of ring automorphisms. ","depth":9},{"term":"fun P =>\n  (∀ {R S T : Type u} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : CommRing T] (f : R →+* S) (e : S ≃+* T),\n      P f → P (RingHom.comp (RingEquiv.toRingHom e) f)) ∧\n    ∀ {R S T : Type u} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : CommRing T] (f : S →+* T) (e : R ≃+* S),\n      P f → P (RingHom.comp f (RingEquiv.toRingHom e))","name":"RingHom.RespectsIso","doc":"A property `RespectsIso` if it still holds when composed with an isomorphism ","depth":22},{"term":"fun {α} {β} [Add α] [Mul α] [Add β] [Mul β] =>\n  {\n    toFun := fun f =>\n      let src := ↑AddEquiv.mulOp (RingEquiv.toAddEquiv f);\n      let src_1 := ↑MulEquiv.op (RingEquiv.toMulEquiv f);\n      { toEquiv := src.toEquiv,\n        map_mul' :=\n          (_ :\n            ∀ (x y : αᵐᵒᵖ),\n              Equiv.toFun (↑MulEquiv.op (RingEquiv.toMulEquiv f)).toEquiv (x * y) =\n                Equiv.toFun (↑MulEquiv.op (RingEquiv.toMulEquiv f)).toEquiv x *\n                  Equiv.toFun (↑MulEquiv.op (RingEquiv.toMulEquiv f)).toEquiv y),\n        map_add' :=\n          (_ :\n            ∀ (x y : αᵐᵒᵖ),\n              Equiv.toFun (↑AddEquiv.mulOp (RingEquiv.toAddEquiv f)).toEquiv (x + y) =\n                Equiv.toFun (↑AddEquiv.mulOp (RingEquiv.toAddEquiv f)).toEquiv x +\n                  Equiv.toFun (↑AddEquiv.mulOp (RingEquiv.toAddEquiv f)).toEquiv y) },\n    invFun := fun f =>\n      let src := ↑AddEquiv.mulOp.symm (RingEquiv.toAddEquiv f);\n      let src_1 := ↑MulEquiv.op.symm (RingEquiv.toMulEquiv f);\n      { toEquiv := src.toEquiv,\n        map_mul' :=\n          (_ :\n            ∀ (x y : α), Equiv.toFun src_1.toEquiv (x * y) = Equiv.toFun src_1.toEquiv x * Equiv.toFun src_1.toEquiv y),\n        map_add' :=\n          (_ : ∀ (x y : α), Equiv.toFun src.toEquiv (x + y) = Equiv.toFun src.toEquiv x + Equiv.toFun src.toEquiv y) },\n    left_inv :=\n      (_ :\n        ∀ (f : α ≃+* β),\n          (fun f =>\n                let src := ↑AddEquiv.mulOp.symm (RingEquiv.toAddEquiv f);\n                let src_1 := ↑MulEquiv.op.symm (RingEquiv.toMulEquiv f);\n                { toEquiv := src.toEquiv,\n                  map_mul' :=\n                    (_ :\n                      ∀ (x y : α),\n                        Equiv.toFun src_1.toEquiv (x * y) = Equiv.toFun src_1.toEquiv x * Equiv.toFun src_1.toEquiv y),\n                  map_add' :=\n                    (_ :\n                      ∀ (x y : α),\n                        Equiv.toFun src.toEquiv (x + y) = Equiv.toFun src.toEquiv x + Equiv.toFun src.toEquiv y) })\n              ((fun f =>\n                  let src := ↑AddEquiv.mulOp (RingEquiv.toAddEquiv f);\n                  let src_1 := ↑MulEquiv.op (RingEquiv.toMulEquiv f);\n                  { toEquiv := src.toEquiv,\n                    map_mul' :=\n                      (_ :\n                        ∀ (x y : αᵐᵒᵖ),\n                          Equiv.toFun src_1.toEquiv (x * y) =\n                            Equiv.toFun src_1.toEquiv x * Equiv.toFun src_1.toEquiv y),\n                    map_add' :=\n                      (_ :\n                        ∀ (x y : αᵐᵒᵖ),\n                          Equiv.toFun src.toEquiv (x + y) = Equiv.toFun src.toEquiv x + Equiv.toFun src.toEquiv y) })\n                f) =\n            f),\n    right_inv :=\n      (_ :\n        ∀ (f : αᵐᵒᵖ ≃+* βᵐᵒᵖ),\n          (fun f =>\n                let src := ↑AddEquiv.mulOp (RingEquiv.toAddEquiv f);\n                let src_1 := ↑MulEquiv.op (RingEquiv.toMulEquiv f);\n                { toEquiv := src.toEquiv,\n                  map_mul' :=\n                    (_ :\n                      ∀ (x y : αᵐᵒᵖ),\n                        Equiv.toFun src_1.toEquiv (x * y) = Equiv.toFun src_1.toEquiv x * Equiv.toFun src_1.toEquiv y),\n                  map_add' :=\n                    (_ :\n                      ∀ (x y : αᵐᵒᵖ),\n                        Equiv.toFun src.toEquiv (x + y) = Equiv.toFun src.toEquiv x + Equiv.toFun src.toEquiv y) })\n              ((fun f =>\n                  let src := ↑AddEquiv.mulOp.symm (RingEquiv.toAddEquiv f);\n                  let src_1 := ↑MulEquiv.op.symm (RingEquiv.toMulEquiv f);\n                  { toEquiv := src.toEquiv,\n                    map_mul' :=\n                      (_ :\n                        ∀ (x y : α),\n                          Equiv.toFun src_1.toEquiv (x * y) =\n                            Equiv.toFun src_1.toEquiv x * Equiv.toFun src_1.toEquiv y),\n                    map_add' :=\n                      (_ :\n                        ∀ (x y : α),\n                          Equiv.toFun src.toEquiv (x + y) = Equiv.toFun src.toEquiv x + Equiv.toFun src.toEquiv y) })\n                f) =\n            f) }","name":"RingEquiv.op","doc":"A ring iso `α ≃+* β` can equivalently be viewed as a ring iso `αᵐᵒᵖ ≃+* βᵐᵒᵖ`. ","depth":25},{"term":"fun {R} [Semiring R] =>\n  MulSemiringAction.mk (_ : ∀ (f : R ≃+* R), ↑f 1 = 1) (_ : ∀ (e : R ≃+* R) (x y : R), ↑e (x * y) = ↑e x * ↑e y)","name":"RingAut.applyMulSemiringAction","doc":"The tautological action by the group of automorphism of a ring `R` on `R`.","depth":34},{"term":"fun {m n} h =>\n  Nat.casesOn (motive := fun t => m = t → ZMod m ≃+* ZMod n) m\n    (fun h_1 =>\n      Eq.ndrec (motive := fun {m} => m = n → ZMod m ≃+* ZMod n)\n        (fun h =>\n          Nat.casesOn (motive := fun t => n = t → ZMod Nat.zero ≃+* ZMod n) n\n            (fun h_2 =>\n              Eq.ndrec (motive := fun {n} => Nat.zero = n → ZMod Nat.zero ≃+* ZMod n)\n                (fun h => RingEquiv.refl (ZMod Nat.zero)) (_ : Nat.zero = n) h)\n            (fun n_1 h_2 =>\n              Eq.ndrec (motive := fun {n} => Nat.zero = n → ZMod Nat.zero ≃+* ZMod n) (fun h => False.elim (_ : False))\n                (_ : Nat.succ n_1 = n) h)\n            (_ : n = n))\n        (_ : Nat.zero = m) h)\n    (fun m_1 h_1 =>\n      Eq.ndrec (motive := fun {m} => m = n → ZMod m ≃+* ZMod n)\n        (fun h =>\n          Nat.casesOn (motive := fun t => n = t → ZMod (Nat.succ m_1) ≃+* ZMod n) n\n            (fun h_2 =>\n              Eq.ndrec (motive := fun {n} => Nat.succ m_1 = n → ZMod (Nat.succ m_1) ≃+* ZMod n)\n                (fun h => False.elim (_ : False)) (_ : Nat.zero = n) h)\n            (fun n_1 h_2 =>\n              Eq.ndrec (motive := fun {n} => Nat.succ m_1 = n → ZMod (Nat.succ m_1) ≃+* ZMod n)\n                (fun h =>\n                  let src := Fin.castIso h;\n                  { toEquiv := src.toEquiv,\n                    map_mul' :=\n                      (_ :\n                        ∀ (a b : ZMod (Nat.succ m_1)),\n                          Equiv.toFun (Fin.castIso h).toEquiv (a * b) =\n                            Equiv.toFun (Fin.castIso h).toEquiv a * Equiv.toFun (Fin.castIso h).toEquiv b),\n                    map_add' :=\n                      (_ :\n                        ∀ (a b : ZMod (Nat.succ m_1)),\n                          Equiv.toFun (Fin.castIso h).toEquiv (a + b) =\n                            Equiv.toFun (Fin.castIso h).toEquiv a + Equiv.toFun (Fin.castIso h).toEquiv b) })\n                (_ : Nat.succ n_1 = n) h)\n            (_ : n = n))\n        (_ : Nat.succ m_1 = m) h)\n    (_ : m = m)","name":"ZMod.ringEquivCongr","doc":"The identity between `ZMod m` and `ZMod n` when `m = n`, as a ring isomorphism. ","depth":36}],"count":7}
{"noDocExamples":[{"term":"fun {α} {β} {γ} {δ} [Function.HasUncurry β γ δ] => { uncurry := fun f p => (↿(f p.fst)) p.snd }","name":"Function.hasUncurryInduction","depth":14}],"kind":"Function.«term↿_»","examples":[{"term":"fun {α} {β} {ι} [UniformSpace β] {F} {p} {p'} {c} =>\n  Eq.mpr\n    (id\n      (congrFun (congrArg Iff (congrArg (Filter.Tendsto (↿F) (p ×ˢ p')) nhds_eq_comap_uniformity))\n        (TendstoUniformlyOnFilter F (fun x => c) p p')))\n    (Eq.mpr\n      (id\n        (congrFun (congrArg Iff Mathlib.Topology.UniformSpace.UniformConvergence._auxLemma.6)\n          (TendstoUniformlyOnFilter F (fun x => c) p p')))\n      Iff.rfl)","name":"tendsto_prod_filter_iff","doc":"Uniform convergence on a filter `p'` to a constant function is equivalent to convergence in\n`p ×ˢ p'`. ","depth":28},{"term":"fun {α} {β} {ι} [UniformSpace β] {F} {p} {c} =>\n  Eq.mpr\n    (id\n      (propext tendstoUniformly_iff_tendstoUniformlyOnFilter ▸\n        Eq.refl (Filter.Tendsto (↿F) (p ×ˢ ⊤) (nhds c) ↔ TendstoUniformly F (fun x => c) p)))\n    tendsto_prod_filter_iff","name":"tendsto_prod_top_iff","doc":"Uniform convergence to a constant function is equivalent to convergence in `p ×ˢ ⊤`. ","depth":29},{"term":"fun {α} {β} {ι} [UniformSpace β] {F} {s} {p} {c} =>\n  Eq.mpr\n    (id\n      (propext tendstoUniformlyOn_iff_tendstoUniformlyOnFilter ▸\n        Eq.refl (Filter.Tendsto (↿F) (p ×ˢ Filter.principal s) (nhds c) ↔ TendstoUniformlyOn F (fun x => c) p s)))\n    tendsto_prod_filter_iff","name":"tendsto_prod_principal_iff","doc":"Uniform convergence on a set `s` to a constant function is equivalent to convergence in\n`p ×ˢ 𝓟 s`. ","depth":30},{"term":"fun {α} {β} {G₀} [GroupWithZero G₀] [TopologicalSpace G₀] [HasContinuousInv₀ G₀] [ContinuousMul G₀] [TopologicalSpace α]\n    [TopologicalSpace β] {a} {f g} h hf hg hh h2h =>\n  let_fun this :=\n    if hga : g a = 0 then\n      Eq.mpr\n        (id\n          (ContinuousAt._eq_1 (↿h ∘ fun x => (x, f x / g x)) a ▸\n            Eq.refl (ContinuousAt (↿h ∘ fun x => (x, f x / g x)) a)))\n        (id\n          (Eq.mpr\n            (id\n              (congrArg (Filter.Tendsto (↿h ∘ fun x => (x, f x / g x)) (nhds a))\n                (congrArg nhds (congrArg (↿h) (congrArg (Prod.mk a) (congrArg (HDiv.hDiv (f a)) hga))))))\n            (Eq.mpr\n              (id\n                (congrArg (Filter.Tendsto (↿h ∘ fun x => (x, f x / g x)) (nhds a))\n                  (congrArg nhds (congrArg (↿h) (congrArg (Prod.mk a) (div_zero (f a)))))))\n              (Filter.Tendsto.comp (h2h hga) (Filter.Tendsto.prod_mk continuousAt_id Filter.tendsto_top)))))\n    else ContinuousAt.comp (hh hga) (ContinuousAt.prod continuousAt_id (ContinuousAt.div hf hg hga));\n  this","name":"ContinuousAt.comp_div_cases","doc":"The function `f x / g x` is discontinuous when `g x = 0`. However, under appropriate\nconditions, `h x (f x / g x)` is still continuous.  The condition is that if `g a = 0` then `h x y`\nmust tend to `h a 0` when `x` tends to `a`, with no information about `y`. This is represented by\nthe `⊤` filter.  Note: `tendsto_prod_top_iff` characterizes this convergence in uniform spaces.  See\nalso `Filter.prod_top` and `Filter.mem_prod_top`. ","depth":43}],"count":7}
{"noDocExamples":[{"term":"fun {C} {X Y X' Y'} [CategoryTheory.Category.{v, u} C] [CategoryTheory.MonoidalCategory C] f g => Eq.refl (f ⊗ g).inv","name":"CategoryTheory.tensorIso_inv","depth":20}],"kind":"CategoryTheory.«term_⊗_»","examples":[{"term":"fun k G [CommRing k] [Group G] n =>\n  (Rep.linearization k G).toLaxMonoidalFunctor.mapIso (GroupCohomology.Resolution.actionDiagonalSucc G n) ≪≫\n    (CategoryTheory.asIso\n          (CategoryTheory.LaxMonoidalFunctor.μ (Rep.linearization k G).toLaxMonoidalFunctor (Action.leftRegular G)\n            { V := Fin n → G, ρ := 1 })).symm ≪≫\n      (CategoryTheory.Iso.refl ((Rep.linearization k G).toLaxMonoidalFunctor.toFunctor.obj (Action.leftRegular G)) ⊗\n        Rep.linearizationTrivialIso k G (Fin n → G))","name":"GroupCohomology.Resolution.diagonalSucc","doc":"An isomorphism of `k`-linear representations of `G` from `k[Gⁿ⁺¹]` to `k[G] ⊗ₖ k[Gⁿ]` (on\nwhich `G` acts by `ρ(g₁)(g₂ ⊗ x) = (g₁ * g₂) ⊗ x`) sending `(g₀, ..., gₙ)` to\n`g₀ ⊗ (g₀⁻¹g₁, g₁⁻¹g₂, ..., gₙ₋₁⁻¹gₙ)`. The inverse sends `g₀ ⊗ (g₁, ..., gₙ)` to\n`(g₀, g₀g₁, ..., g₀g₁...gₙ)`. ","depth":31},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] X Y =>\n  { fst := CategoryTheory.MonoidalCategory.tensorObj X.fst Y.fst,\n    snd :=\n      CategoryTheory.HalfBraiding.mk fun U =>\n        CategoryTheory.MonoidalCategory.associator X.fst Y.fst U ≪≫\n          (CategoryTheory.Iso.refl X.fst ⊗ CategoryTheory.HalfBraiding.β Y.snd U) ≪≫\n            (CategoryTheory.MonoidalCategory.associator X.fst U Y.fst).symm ≪≫\n              (CategoryTheory.HalfBraiding.β X.snd U ⊗ CategoryTheory.Iso.refl Y.fst) ≪≫\n                CategoryTheory.MonoidalCategory.associator U X.fst Y.fst }","name":"CategoryTheory.Center.tensorObj","doc":"Auxiliary definition for the `MonoidalCategory` instance on `Center C`. ","depth":32},{"term":"fun G [Group G] x =>\n  Nat.brecOn x fun x f =>\n    (match (motive :=\n        (x : ℕ) →\n          Nat.below x →\n            (Action.diagonal G (x + 1) ≅\n              CategoryTheory.MonoidalCategory.tensorObj (Action.leftRegular G) { V := Fin x → G, ρ := 1 }))\n        x with\n      | 0 => fun x =>\n        Action.diagonalOneIsoLeftRegular G ≪≫\n          (CategoryTheory.MonoidalCategory.rightUnitor (Action.leftRegular G)).symm ≪≫\n            (CategoryTheory.Iso.refl (Action.leftRegular G) ⊗\n              Action.tensorUnitIso (Equiv.toIso (Equiv.equivOfUnique PUnit.{u + 1} (Fin 0 → G))))\n      | Nat.succ n => fun x =>\n        Action.diagonalSucc G (n + 1) ≪≫\n          (CategoryTheory.Iso.refl (Action.leftRegular G) ⊗ x.fst.fst) ≪≫\n            Action.leftRegularTensorIso G\n                (CategoryTheory.MonoidalCategory.tensorObj (Action.leftRegular G) { V := Fin n → G, ρ := 1 }) ≪≫\n              (CategoryTheory.Iso.refl (Action.leftRegular G) ⊗\n                Action.mkIso (Equiv.toIso (Equiv.piFinSuccAboveEquiv (fun x => G) 0).symm)))\n      f","name":"GroupCohomology.Resolution.actionDiagonalSucc","doc":"An isomorphism of `G`-sets `Gⁿ⁺¹ ≅ G × Gⁿ`, where `G` acts by left multiplication on `Gⁿ⁺¹` and\n`G` but trivially on `Gⁿ`. The map sends `(g₀, ..., gₙ) ↦ (g₀, (g₀⁻¹g₁, g₁⁻¹g₂, ..., gₙ₋₁⁻¹gₙ))`,\nand the inverse is `(g₀, (g₁, ..., gₙ)) ↦ (g₀, g₀g₁, g₀g₁g₂, ..., g₀g₁...gₙ).` ","depth":42},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {D}\n    [CategoryTheory.Category.{v₂, u₂} D] e =>\n  CategoryTheory.MonoidalCategory.mk\n    (fun X Y => e.functor.obj (CategoryTheory.MonoidalCategory.tensorObj (e.inverse.obj X) (e.inverse.obj Y)))\n    (fun X x x_1 f => e.functor.map (CategoryTheory.MonoidalCategory.whiskerLeft (e.inverse.obj X) (e.inverse.map f)))\n    (fun {X₁ X₂} f X =>\n      e.functor.map (CategoryTheory.MonoidalCategory.whiskerRight (e.inverse.map f) (e.inverse.obj X)))\n    (fun {X₁ Y₁ X₂ Y₂} f g =>\n      e.functor.map (CategoryTheory.MonoidalCategory.tensorHom (e.inverse.map f) (e.inverse.map g)))\n    (e.functor.obj (CategoryTheory.MonoidalCategory.tensorUnit C))\n    (fun X Y Z =>\n      e.functor.mapIso\n        (((e.unitIso.app (CategoryTheory.MonoidalCategory.tensorObj (e.inverse.obj X) (e.inverse.obj Y))).symm ⊗\n            CategoryTheory.Iso.refl (e.inverse.obj Z)) ≪≫\n          CategoryTheory.MonoidalCategory.associator (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) ≪≫\n            (CategoryTheory.Iso.refl (e.inverse.obj X) ⊗\n              e.unitIso.app (CategoryTheory.MonoidalCategory.tensorObj (e.inverse.obj Y) (e.inverse.obj Z)))))\n    (fun X =>\n      e.functor.mapIso\n          (((e.unitIso.app (CategoryTheory.MonoidalCategory.tensorUnit C)).symm ⊗\n              CategoryTheory.Iso.refl (e.inverse.obj X)) ≪≫\n            CategoryTheory.MonoidalCategory.leftUnitor (e.inverse.obj X)) ≪≫\n        e.counitIso.app X)\n    fun X =>\n    e.functor.mapIso\n        ((CategoryTheory.Iso.refl (e.inverse.obj X) ⊗\n            (e.unitIso.app (CategoryTheory.MonoidalCategory.tensorUnit C)).symm) ≪≫\n          CategoryTheory.MonoidalCategory.rightUnitor (e.inverse.obj X)) ≪≫\n      e.counitIso.app X","name":"CategoryTheory.Monoidal.transport","doc":"Transport a monoidal structure along an equivalence of (plain) categories.\n","depth":46}],"count":7}
{"noDocExamples":[{"term":"fun {α} s₁ s₂ =>\n  Eq.mpr\n    (id\n      (Stream'.interleave_eq s₁ s₂ ▸\n        Eq.refl (Stream'.tail s₁ ⋈ Stream'.tail s₂ = Stream'.tail (Stream'.tail (s₁ ⋈ s₂)))))\n    (Eq.refl (Stream'.tail s₁ ⋈ Stream'.tail s₂))","name":"Stream'.interleave_tail_tail","depth":19},{"term":"fun {α} {a} {s₁} s₂ x =>\n  match x with\n  | Exists.intro n h =>\n    Exists.intro (2 * n)\n      (Eq.mpr (id (h ▸ Eq.refl ((fun b => a = b) (Stream'.nth (s₁ ⋈ s₂) (2 * n)))))\n        (Eq.mpr\n          (id\n            (Stream'.nth_interleave_left n s₁ s₂ ▸\n              Eq.refl ((fun b => Stream'.nth s₁ n = b) (Stream'.nth (s₁ ⋈ s₂) (2 * n)))))\n          (Eq.refl (Stream'.nth s₁ n))))","name":"Stream'.mem_interleave_left","depth":28},{"term":"fun {α} s₁ =>\n  Stream'.eq_of_bisim (fun s' s => s' = Stream'.even s ⋈ Stream'.odd s)\n    (fun s' s h =>\n      Eq.mpr\n        (id\n          (h ▸\n            Eq.refl\n              (Stream'.head s' = Stream'.head s ∧\n                (fun s' s => s' = Stream'.even s ⋈ Stream'.odd s) (Stream'.tail s') (Stream'.tail s))))\n        { left := Eq.refl (Stream'.head (Stream'.even s ⋈ Stream'.odd s)),\n          right :=\n            of_eq_true\n              (Eq.trans\n                (congrFun\n                  (congrArg Eq\n                    (Eq.trans (Stream'.tail_interleave (Stream'.even s) (Stream'.even (Stream'.tail s)))\n                      (congrArg (Stream'.interleave (Stream'.even (Stream'.tail s))) (Stream'.tail_even s))))\n                  (Stream'.even (Stream'.tail s) ⋈ Stream'.even (Stream'.tail (Stream'.tail s))))\n                (eq_self (Stream'.even (Stream'.tail s) ⋈ Stream'.even (Stream'.tail (Stream'.tail s))))) })\n    rfl","name":"Stream'.interleave_even_odd","depth":29},{"term":"fun {α} {a} {s₁} s₂ x =>\n  match x with\n  | Exists.intro n h =>\n    Exists.intro (2 * n + 1)\n      (Eq.mpr (id (h ▸ Eq.refl ((fun b => a = b) (Stream'.nth (s₁ ⋈ s₂) (2 * n + 1)))))\n        (Eq.mpr\n          (id\n            (Stream'.nth_interleave_right n s₁ s₂ ▸\n              Eq.refl ((fun b => Stream'.nth s₂ n = b) (Stream'.nth (s₁ ⋈ s₂) (2 * n + 1)))))\n          (Eq.refl (Stream'.nth s₂ n))))","name":"Stream'.mem_interleave_right","depth":30},{"term":"fun {α} s₁ s₂ =>\n  let t := Stream'.tail s₁ ⋈ Stream'.tail s₂;\n  let_fun this :=\n    id\n      (id\n        (Eq.mpr\n          (id\n            (Stream'.corec_eq\n                (fun x =>\n                  match x with\n                  | (s₁, snd) => Stream'.head s₁)\n                (fun x =>\n                  match x with\n                  | (s₁, s₂) => (s₂, Stream'.tail s₁))\n                (s₁, s₂) ▸\n              Eq.refl\n                (Stream'.corec\n                    (fun x =>\n                      match x with\n                      | (s₁, snd) => Stream'.head s₁)\n                    (fun x =>\n                      match x with\n                      | (s₁, s₂) => (s₂, Stream'.tail s₁))\n                    (s₁, s₂) =\n                  Stream'.cons (Stream'.head s₁) (Stream'.cons (Stream'.head s₂) t))))\n          (id\n            (Eq.mpr\n              (id\n                (Stream'.corec_eq (fun x => Stream'.head x.fst) (fun x => (x.snd, Stream'.tail x.fst))\n                    (s₂, Stream'.tail s₁) ▸\n                  Eq.refl\n                    (Stream'.cons (Stream'.head s₁)\n                        (Stream'.corec (fun x => Stream'.head x.fst) (fun x => (x.snd, Stream'.tail x.fst))\n                          (s₂, Stream'.tail s₁)) =\n                      Stream'.cons (Stream'.head s₁)\n                        (Stream'.cons (Stream'.head s₂) (Stream'.tail s₁ ⋈ Stream'.tail s₂)))))\n              (Eq.refl\n                (Stream'.cons (Stream'.head s₁)\n                  (Stream'.cons (Stream'.head (s₂, Stream'.tail s₁).fst)\n                    (Stream'.corec (fun x => Stream'.head x.fst) (fun x => (x.snd, Stream'.tail x.fst))\n                      ((s₂, Stream'.tail s₁).snd, Stream'.tail (s₂, Stream'.tail s₁).fst)))))))));\n  this","name":"Stream'.interleave_eq","depth":32}],"kind":"Stream'.«term_⋈_»","examples":[],"count":6}
{"noDocExamples":[{"term":"fun α β [OmegaCompletePartialOrder α] [OmegaCompletePartialOrder β] =>\n  PartialOrder.lift (fun f => f.toFun) (_ : ∀ ⦃a₁ a₂ : α →𝒄 β⦄, (fun f => f.toFun) a₁ = (fun f => f.toFun) a₂ → a₁ = a₂)","name":"OmegaCompletePartialOrder.instPartialOrderContinuousHom","depth":13},{"term":"fun α β [OmegaCompletePartialOrder α] [OmegaCompletePartialOrder β] =>\n  RelHomClass.mk (_ : ∀ (f : α →𝒄 β) (x x_1 : α), x ≤ x_1 → ↑f.toOrderHom x ≤ ↑f.toOrderHom x_1)","name":"OmegaCompletePartialOrder.instOrderHomClassContinuousHomToLEToPreorderToPartialOrderToLEToPreorderToPartialOrder","depth":17},{"term":"fun {α} {β} [OmegaCompletePartialOrder α] [OmegaCompletePartialOrder β] =>\n  OmegaCompletePartialOrder.lift OmegaCompletePartialOrder.ContinuousHom.toMono\n    OmegaCompletePartialOrder.ContinuousHom.ωSup\n    (_ :\n      ∀ (x x_1 : α →𝒄 β),\n        ↑OmegaCompletePartialOrder.ContinuousHom.toMono x ≤ ↑OmegaCompletePartialOrder.ContinuousHom.toMono x_1 →\n          ↑OmegaCompletePartialOrder.ContinuousHom.toMono x ≤ ↑OmegaCompletePartialOrder.ContinuousHom.toMono x_1)\n    (_ :\n      ∀ (x : OmegaCompletePartialOrder.Chain (α →𝒄 β)),\n        ↑OmegaCompletePartialOrder.ContinuousHom.toMono (OmegaCompletePartialOrder.ContinuousHom.ωSup x) =\n          ↑OmegaCompletePartialOrder.ContinuousHom.toMono (OmegaCompletePartialOrder.ContinuousHom.ωSup x))","name":"OmegaCompletePartialOrder.ContinuousHom.instOmegaCompletePartialOrderContinuousHom","depth":30}],"kind":"OmegaCompletePartialOrder.«term_→𝒄_»","examples":[{"term":"fun {α} {β} [OmegaCompletePartialOrder α] [OmegaCompletePartialOrder β] =>\n  { toFun := fun f => ↑f, monotone' := (_ : ∀ (x x_1 : α →𝒄 β), x ≤ x_1 → x ≤ x_1) }","name":"OmegaCompletePartialOrder.ContinuousHom.toMono","doc":"The map from continuous functions to monotone functions is itself a monotone function. ","depth":18},{"term":"fun {α} {β} [OmegaCompletePartialOrder α] [OmegaCompletePartialOrder β] =>\n  {\n    toOrderHom :=\n      { toFun := fun f => ↑f.fst f.snd,\n        monotone' := (_ : ∀ (x y : (α →𝒄 β) × α), x ≤ y → (fun f => ↑f.fst f.snd) x ≤ (fun f => ↑f.fst f.snd) y) },\n    cont :=\n      (_ :\n        ∀ (c : OmegaCompletePartialOrder.Chain ((α →𝒄 β) × α)),\n          ↑{ toFun := fun f => ↑f.fst f.snd,\n                  monotone' :=\n                    (_ : ∀ (x y : (α →𝒄 β) × α), x ≤ y → (fun f => ↑f.fst f.snd) x ≤ (fun f => ↑f.fst f.snd) y) }\n              (OmegaCompletePartialOrder.ωSup c) =\n            OmegaCompletePartialOrder.ωSup\n              (OmegaCompletePartialOrder.Chain.map c\n                { toFun := fun f => ↑f.fst f.snd,\n                  monotone' :=\n                    (_ : ∀ (x y : (α →𝒄 β) × α), x ≤ y → (fun f => ↑f.fst f.snd) x ≤ (fun f => ↑f.fst f.snd) y) })) }","name":"OmegaCompletePartialOrder.ContinuousHom.Prod.apply","doc":"The application of continuous functions as a continuous function.  ","depth":24}],"count":6}
{"noDocExamples":[{"term":"fun {α} =>\n  Eq.mpr (id (Filter.smallSets._eq_1 ⊤ ▸ Eq.refl (Filter.smallSets ⊤ = ⊤)))\n    (Eq.mpr (id (Filter.lift'_top Set.powerset ▸ Eq.refl (Filter.lift' ⊤ Set.powerset = ⊤)))\n      (Eq.mpr (id (Set.powerset_univ ▸ Eq.refl (Filter.principal (𝒫 Set.univ) = ⊤)))\n        (Eq.mpr (id (Filter.principal_univ ▸ Eq.refl (Filter.principal Set.univ = ⊤))) (Eq.refl ⊤))))","name":"Filter.smallSets_top","depth":19}],"kind":"Set.term𝒫_","examples":[{"term":"fun x => Class.congToClass (𝒫 x)","name":"Class.powerset","doc":"The power class of a class is the class of all subclasses that are ZFC sets ","depth":4},{"term":"fun {α} S =>\n  { toFun := fun x => Subtype.val ⁻¹' ↑x,\n    invFun := fun x => { val := Subtype.val '' x, property := (_ : ∀ ⦃a : α⦄, a ∈ Subtype.val '' x → a ∈ S) },\n    left_inv :=\n      (_ :\n        ∀ (x : ↑(𝒫 S)),\n          (fun x => { val := Subtype.val '' x, property := (_ : ∀ ⦃a : α⦄, a ∈ Subtype.val '' x → a ∈ S) })\n              ((fun x => Subtype.val ⁻¹' ↑x) x) =\n            x),\n    right_inv :=\n      (_ :\n        ∀ (x : Set ↑S),\n          (fun x => Subtype.val ⁻¹' ↑x)\n              ((fun x => { val := Subtype.val '' x, property := (_ : ∀ ⦃a : α⦄, a ∈ Subtype.val '' x → a ∈ S) }) x) =\n            x) }","name":"Equiv.Set.powerset","doc":"The set `𝒫 S := {x | x ⊆ S}` is equivalent to the type `Set S`. ","depth":19},{"term":"fun {α} x =>\n  Set.ext fun y =>\n    Eq.mpr (id (propext (Set.mem_powerset_iff y {x}) ▸ Eq.refl (y ∈ 𝒫{x} ↔ y ∈ {∅, {x}})))\n      (Eq.mpr (id (propext Set.subset_singleton_iff_eq ▸ Eq.refl (y ⊆ {x} ↔ y ∈ {∅, {x}})))\n        (Eq.mpr (id (propext Set.mem_insert_iff ▸ Eq.refl (y = ∅ ∨ y = {x} ↔ y ∈ {∅, {x}})))\n          (Eq.mpr (id (propext Set.mem_singleton_iff ▸ Eq.refl (y = ∅ ∨ y = {x} ↔ y = ∅ ∨ y ∈ {{x}}))) Iff.rfl)))","name":"Set.powerset_singleton","doc":"The powerset of a singleton contains only `∅` and the singleton itself. ","depth":25},{"term":"fun {α} s a =>\n  Set.ext fun t =>\n    Eq.mpr (id (congrArg (Iff (t ∈ 𝒫 insert a s)) (Mathlib.Data.Set.Image._auxLemma.18 t (𝒫 s) (insert a '' 𝒫 s))))\n      (Eq.mpr\n        (id\n          (congrArg (Iff (t ∈ 𝒫 insert a s))\n            (congrArg (Or (t ∈ 𝒫 s)) (Mathlib.Data.Set.Image._auxLemma.2 (insert a) (𝒫 s) t))))\n        (Eq.mpr\n          (id\n            (congr (congrArg Iff (Mathlib.Data.Set.Image._auxLemma.19 t (insert a s)))\n              (congr (congrArg Or (Mathlib.Data.Set.Image._auxLemma.19 t s))\n                (congrArg Exists\n                  (funext fun x =>\n                    congrFun (congrArg And (Mathlib.Data.Set.Image._auxLemma.19 x s)) (insert a x = t))))))\n          {\n            mp := fun h =>\n              if hs : a ∈ t then\n                Or.inr\n                  (Exists.intro (t \\ {a})\n                    { left := Eq.mpr (id (propext Set.diff_singleton_subset_iff ▸ Eq.refl (t \\ {a} ⊆ s))) h,\n                      right :=\n                        Eq.mpr (id (Set.insert_diff_singleton ▸ Eq.refl (insert a (t \\ {a}) = t)))\n                          (Eq.mpr (id (Set.insert_eq_of_mem hs ▸ Eq.refl (insert a t = t))) (Eq.refl t)) })\n              else Or.inl (Iff.mp (Set.subset_insert_iff_of_not_mem hs) h),\n            mpr := fun a_1 =>\n              Or.casesOn a_1 (fun h => subset_trans h (Set.subset_insert a s)) fun h =>\n                Exists.casesOn h fun s' h => And.casesOn h fun h₁ right => right ▸ Set.insert_subset_insert h₁ }))","name":"Set.powerset_insert","doc":"The powerset of `{a} ∪ s` is `𝒫 s` together with `{a} ∪ t` for each `t ∈ 𝒫 s`. ","depth":35}],"count":6}
{"noDocExamples":[{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {D}\n    [CategoryTheory.Category.{v₂, u₂} D] [CategoryTheory.MonoidalCategory D] {E} [CategoryTheory.Category.{v₃, u₃} E]\n    [CategoryTheory.MonoidalCategory E] F G =>\n  Eq.refl (F ⊗⋙ G).toFunctor","name":"CategoryTheory.LaxMonoidalFunctor.comp_toFunctor","depth":24},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {D}\n    [CategoryTheory.Category.{v₂, u₂} D] [CategoryTheory.MonoidalCategory D] {E} [CategoryTheory.Category.{v₃, u₃} E]\n    [CategoryTheory.MonoidalCategory E] F G =>\n  Eq.refl (F ⊗⋙ G).ε","name":"CategoryTheory.LaxMonoidalFunctor.comp_ε","depth":34}],"kind":"CategoryTheory.LaxMonoidalFunctor.«term_⊗⋙_»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {D}\n    [CategoryTheory.Category.{v₂, u₂} D] [CategoryTheory.MonoidalCategory D] {E} [CategoryTheory.Category.{v₃, u₃} E]\n    [CategoryTheory.MonoidalCategory E] F G =>\n  (CategoryTheory.MonoidalFunctor.diag C).toLaxMonoidalFunctor ⊗⋙ CategoryTheory.LaxMonoidalFunctor.prod F G","name":"CategoryTheory.LaxMonoidalFunctor.prod'","doc":"The cartesian product of two lax monoidal functors starting from the same monoidal category `C`\nis lax monoidal. ","depth":26},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {D}\n    [CategoryTheory.Category.{v₂, u₂} D] [CategoryTheory.MonoidalCategory D] {E} [CategoryTheory.Category.{v₃, u₃} E]\n    [CategoryTheory.MonoidalCategory E] F G =>\n  let src := F.toLaxMonoidalFunctor ⊗⋙ G.toLaxMonoidalFunctor;\n  CategoryTheory.MonoidalFunctor.mk (CategoryTheory.LaxMonoidalFunctor.mk src.toFunctor src.ε src.μ)","name":"CategoryTheory.MonoidalFunctor.comp","doc":"The composition of two monoidal functors is again monoidal. ","depth":34},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] [CategoryTheory.BraidedCategory C] {D}\n    [CategoryTheory.Category.{v₂, u₂} D] [CategoryTheory.MonoidalCategory D] [CategoryTheory.BraidedCategory D] {E}\n    [CategoryTheory.Category.{v₃, u₃} E] [CategoryTheory.MonoidalCategory E] [CategoryTheory.BraidedCategory E] F G =>\n  let src := F.toLaxMonoidalFunctor ⊗⋙ G.toLaxMonoidalFunctor;\n  CategoryTheory.LaxBraidedFunctor.mk (CategoryTheory.LaxMonoidalFunctor.mk src.toFunctor src.ε src.μ)","name":"CategoryTheory.LaxBraidedFunctor.comp","doc":"The composition of lax braided monoidal functors. ","depth":36}],"count":6}
{"noDocExamples":[{"term":"fun {α} {β} {r} {s} => RelHomClass.mk (_ : ∀ (f : r ≃r s) (x x_1 : α), r x x_1 → s (↑f x) (↑f x_1))","name":"RelIso.instRelHomClassRelIso","depth":21},{"term":"fun {α} {r} => Group.mk (_ : ∀ (f : r ≃r r), f⁻¹ * f = 1)","name":"RelIso.instGroupRelIso","depth":34}],"kind":"«term_≃r_»","examples":[{"term":"fun {V} {W} G G' => G.Adj ≃r G'.Adj","name":"SimpleGraph.Iso","doc":"A graph isomorphism is a bijective map on vertex sets that respects adjacency relations.\n\nThe notation `G ≃g G'` represents the type of graph isomorphisms.\n","depth":8},{"term":"fun α β [LE α] [LE β] => (fun x x_1 => x ≤ x_1) ≃r fun x x_1 => x ≤ x_1","name":"OrderIso","doc":"An order isomorphism is an equivalence such that `a ≤ b ↔ (f a) ≤ (f b)`.\nThis definition is an abbreviation of `RelIso (≤) (≤)`. ","depth":12},{"term":"{\n  r := fun x x_1 =>\n    match x with\n    | { α := α, r := r, wo := wo } =>\n      match x_1 with\n      | { α := α_1, r := s, wo := wo } => Nonempty (r ≃r s),\n  iseqv := Ordinal.isEquivalent.proof_1 }","name":"Ordinal.isEquivalent","doc":"Equivalence relation on well orders on arbitrary types in universe `u`, given by order\nisomorphism. ","depth":17}],"count":5}
{"noDocExamples":[{"term":"fun {R} {A} {B} [Monoid R] [NonUnitalNonAssocSemiring A] [DistribMulAction R A] [NonUnitalNonAssocSemiring B]\n    [DistribMulAction R B] =>\n  { coe := fun f => f.toFun,\n    coe_injective' := (_ : ∀ ⦃a₁ a₂ : A →ₙₐ[R] B⦄, (fun f => f.toFun) a₁ = (fun f => f.toFun) a₂ → a₁ = a₂) }","name":"NonUnitalAlgHom.instFunLikeNonUnitalAlgHom","depth":22},{"term":"fun {R} {A} {B} [Monoid R] [NonUnitalNonAssocSemiring A] [DistribMulAction R A] [NonUnitalNonAssocSemiring B]\n    [DistribMulAction R B] =>\n  NonUnitalAlgHomClass.mk\n    (_ :\n      ∀ (f : A →ₙₐ[R] B) (x y : A),\n        MulActionHom.toFun f.toMulActionHom (x * y) =\n          MulActionHom.toFun f.toMulActionHom x * MulActionHom.toFun f.toMulActionHom y)","name":"NonUnitalAlgHom.instNonUnitalAlgHomClassNonUnitalAlgHom","depth":30}],"kind":"«term_→ₙₐ[_]_»","examples":[{"term":"fun {R} {A} {B} {C} [Monoid R] [NonUnitalNonAssocSemiring A] [DistribMulAction R A] [NonUnitalNonAssocSemiring B]\n    [DistribMulAction R B] [NonUnitalNonAssocSemiring C] [DistribMulAction R C] =>\n  { toFun := fun f => NonUnitalAlgHom.prod f.fst f.snd,\n    invFun := fun f =>\n      (NonUnitalAlgHom.comp (NonUnitalAlgHom.fst R B C) f, NonUnitalAlgHom.comp (NonUnitalAlgHom.snd R B C) f),\n    left_inv :=\n      (_ :\n        ∀ (x : (A →ₙₐ[R] B) × (A →ₙₐ[R] C)),\n          (fun f =>\n                (NonUnitalAlgHom.comp (NonUnitalAlgHom.fst R B C) f,\n                  NonUnitalAlgHom.comp (NonUnitalAlgHom.snd R B C) f))\n              ((fun f => NonUnitalAlgHom.prod f.fst f.snd) x) =\n            (fun f =>\n                (NonUnitalAlgHom.comp (NonUnitalAlgHom.fst R B C) f,\n                  NonUnitalAlgHom.comp (NonUnitalAlgHom.snd R B C) f))\n              ((fun f => NonUnitalAlgHom.prod f.fst f.snd) x)),\n    right_inv :=\n      (_ :\n        ∀ (x : A →ₙₐ[R] B × C),\n          (fun f => NonUnitalAlgHom.prod f.fst f.snd)\n              ((fun f =>\n                  (NonUnitalAlgHom.comp (NonUnitalAlgHom.fst R B C) f,\n                    NonUnitalAlgHom.comp (NonUnitalAlgHom.snd R B C) f))\n                x) =\n            (fun f => NonUnitalAlgHom.prod f.fst f.snd)\n              ((fun f =>\n                  (NonUnitalAlgHom.comp (NonUnitalAlgHom.fst R B C) f,\n                    NonUnitalAlgHom.comp (NonUnitalAlgHom.snd R B C) f))\n                x)) }","name":"NonUnitalAlgHom.prodEquiv","doc":"Taking the product of two maps with the same domain is equivalent to taking the product of\ntheir codomains. ","depth":30},{"term":"fun {R} {A} [CommSemiring R] [NonUnitalSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A] {C}\n    [Semiring C] [Algebra R C] =>\n  { toFun := NonUnitalAlgHom.toAlgHom,\n    invFun := fun φ => NonUnitalAlgHom.comp (↑φ) (Unitization.inrNonUnitalAlgHom R A),\n    left_inv :=\n      (_ :\n        ∀ (φ : A →ₙₐ[R] C),\n          (fun φ => NonUnitalAlgHom.comp (↑φ) (Unitization.inrNonUnitalAlgHom R A)) (NonUnitalAlgHom.toAlgHom φ) = φ),\n    right_inv :=\n      (_ :\n        ∀ (φ : Unitization R A →ₐ[R] C),\n          NonUnitalAlgHom.toAlgHom ((fun φ => NonUnitalAlgHom.comp (↑φ) (Unitization.inrNonUnitalAlgHom R A)) φ) = φ) }","name":"Unitization.lift","doc":"Non-unital algebra homomorphisms from `A` into a unital `R`-algebra `C` lift uniquely to\n`Unitization R A →ₐ[R] C`. This is the universal property of the unitization. ","depth":33},{"term":"fun k {G} [Semiring k] [Mul G] {A} [NonUnitalNonAssocSemiring A] [Module k A] [IsScalarTower k A A]\n    [SMulCommClass k A A] =>\n  {\n    toFun := fun f =>\n      let src := ↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x);\n      {\n        toDistribMulActionHom :=\n          {\n            toMulActionHom :=\n              { toFun := fun a => Finsupp.sum a fun m t => t • ↑f m,\n                map_smul' :=\n                  (_ :\n                    ∀ (t' : k) (a : MonoidAlgebra k G),\n                      (fun a => Finsupp.sum a fun m t => t • ↑f m) (t' • a) =\n                        t' • (fun a => Finsupp.sum a fun m t => t • ↑f m) a) },\n            map_zero' :=\n              (_ : ZeroHom.toFun (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x))) 0 = 0),\n            map_add' :=\n              (_ :\n                ∀ (x y : G →₀ k),\n                  ZeroHom.toFun (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x))) (x + y) =\n                    ZeroHom.toFun (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x))) x +\n                      ZeroHom.toFun (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x))) y) },\n        map_mul' :=\n          (_ :\n            ∀ (a₁ a₂ : MonoidAlgebra k G),\n              MulActionHom.toFun\n                  {\n                      toMulActionHom :=\n                        { toFun := fun a => Finsupp.sum a fun m t => t • ↑f m,\n                          map_smul' :=\n                            (_ :\n                              ∀ (t' : k) (a : MonoidAlgebra k G),\n                                (fun a => Finsupp.sum a fun m t => t • ↑f m) (t' • a) =\n                                  t' • (fun a => Finsupp.sum a fun m t => t • ↑f m) a) },\n                      map_zero' :=\n                        (_ :\n                          ZeroHom.toFun (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x)))\n                              0 =\n                            0),\n                      map_add' :=\n                        (_ :\n                          ∀ (x y : G →₀ k),\n                            ZeroHom.toFun (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x)))\n                                (x + y) =\n                              ZeroHom.toFun\n                                  (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x))) x +\n                                ZeroHom.toFun\n                                  (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x)))\n                                  y) }.toMulActionHom\n                  (a₁ * a₂) =\n                MulActionHom.toFun\n                    {\n                        toMulActionHom :=\n                          { toFun := fun a => Finsupp.sum a fun m t => t • ↑f m,\n                            map_smul' :=\n                              (_ :\n                                ∀ (t' : k) (a : MonoidAlgebra k G),\n                                  (fun a => Finsupp.sum a fun m t => t • ↑f m) (t' • a) =\n                                    t' • (fun a => Finsupp.sum a fun m t => t • ↑f m) a) },\n                        map_zero' :=\n                          (_ :\n                            ZeroHom.toFun (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x)))\n                                0 =\n                              0),\n                        map_add' :=\n                          (_ :\n                            ∀ (x y : G →₀ k),\n                              ZeroHom.toFun\n                                  (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x)))\n                                  (x + y) =\n                                ZeroHom.toFun\n                                    (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x))) x +\n                                  ZeroHom.toFun\n                                    (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x)))\n                                    y) }.toMulActionHom\n                    a₁ *\n                  MulActionHom.toFun\n                    {\n                        toMulActionHom :=\n                          { toFun := fun a => Finsupp.sum a fun m t => t • ↑f m,\n                            map_smul' :=\n                              (_ :\n                                ∀ (t' : k) (a : MonoidAlgebra k G),\n                                  (fun a => Finsupp.sum a fun m t => t • ↑f m) (t' • a) =\n                                    t' • (fun a => Finsupp.sum a fun m t => t • ↑f m) a) },\n                        map_zero' :=\n                          (_ :\n                            ZeroHom.toFun (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x)))\n                                0 =\n                              0),\n                        map_add' :=\n                          (_ :\n                            ∀ (x y : G →₀ k),\n                              ZeroHom.toFun\n                                  (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x)))\n                                  (x + y) =\n                                ZeroHom.toFun\n                                    (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x))) x +\n                                  ZeroHom.toFun\n                                    (↑(↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x)))\n                                    y) }.toMulActionHom\n                    a₂) },\n    invFun := fun F => MulHom.comp (NonUnitalAlgHom.toMulHom F) (MonoidAlgebra.ofMagma k G),\n    left_inv :=\n      (_ :\n        ∀ (f : G →ₙ* A),\n          (fun F => MulHom.comp (NonUnitalAlgHom.toMulHom F) (MonoidAlgebra.ofMagma k G))\n              ((fun f =>\n                  let src := ↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x);\n                  {\n                    toDistribMulActionHom :=\n                      {\n                        toMulActionHom :=\n                          { toFun := fun a => Finsupp.sum a fun m t => t • ↑f m,\n                            map_smul' :=\n                              (_ :\n                                ∀ (t' : k) (a : MonoidAlgebra k G),\n                                  (fun a => Finsupp.sum a fun m t => t • ↑f m) (t' • a) =\n                                    t' • (fun a => Finsupp.sum a fun m t => t • ↑f m) a) },\n                        map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                        map_add' :=\n                          (_ :\n                            ∀ (x y : G →₀ k),\n                              ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                    map_mul' :=\n                      (_ :\n                        ∀ (a₁ a₂ : MonoidAlgebra k G),\n                          MulActionHom.toFun\n                              {\n                                  toMulActionHom :=\n                                    { toFun := fun a => Finsupp.sum a fun m t => t • ↑f m,\n                                      map_smul' :=\n                                        (_ :\n                                          ∀ (t' : k) (a : MonoidAlgebra k G),\n                                            (fun a => Finsupp.sum a fun m t => t • ↑f m) (t' • a) =\n                                              t' • (fun a => Finsupp.sum a fun m t => t • ↑f m) a) },\n                                  map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                                  map_add' :=\n                                    (_ :\n                                      ∀ (x y : G →₀ k),\n                                        ZeroHom.toFun (↑src) (x + y) =\n                                          ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) }.toMulActionHom\n                              (a₁ * a₂) =\n                            MulActionHom.toFun\n                                {\n                                    toMulActionHom :=\n                                      { toFun := fun a => Finsupp.sum a fun m t => t • ↑f m,\n                                        map_smul' :=\n                                          (_ :\n                                            ∀ (t' : k) (a : MonoidAlgebra k G),\n                                              (fun a => Finsupp.sum a fun m t => t • ↑f m) (t' • a) =\n                                                t' • (fun a => Finsupp.sum a fun m t => t • ↑f m) a) },\n                                    map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                                    map_add' :=\n                                      (_ :\n                                        ∀ (x y : G →₀ k),\n                                          ZeroHom.toFun (↑src) (x + y) =\n                                            ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) }.toMulActionHom\n                                a₁ *\n                              MulActionHom.toFun\n                                {\n                                    toMulActionHom :=\n                                      { toFun := fun a => Finsupp.sum a fun m t => t • ↑f m,\n                                        map_smul' :=\n                                          (_ :\n                                            ∀ (t' : k) (a : MonoidAlgebra k G),\n                                              (fun a => Finsupp.sum a fun m t => t • ↑f m) (t' • a) =\n                                                t' • (fun a => Finsupp.sum a fun m t => t • ↑f m) a) },\n                                    map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                                    map_add' :=\n                                      (_ :\n                                        ∀ (x y : G →₀ k),\n                                          ZeroHom.toFun (↑src) (x + y) =\n                                            ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) }.toMulActionHom\n                                a₂) })\n                f) =\n            f),\n    right_inv :=\n      (_ :\n        ∀ (F : MonoidAlgebra k G →ₙₐ[k] A),\n          (fun f =>\n                let src := ↑Finsupp.liftAddHom fun x => ↑(AddMonoidHom.flip (smulAddHom k A)) (↑f x);\n                {\n                  toDistribMulActionHom :=\n                    {\n                      toMulActionHom :=\n                        { toFun := fun a => Finsupp.sum a fun m t => t • ↑f m,\n                          map_smul' :=\n                            (_ :\n                              ∀ (t' : k) (a : MonoidAlgebra k G),\n                                (fun a => Finsupp.sum a fun m t => t • ↑f m) (t' • a) =\n                                  t' • (fun a => Finsupp.sum a fun m t => t • ↑f m) a) },\n                      map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                      map_add' :=\n                        (_ :\n                          ∀ (x y : G →₀ k),\n                            ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) },\n                  map_mul' :=\n                    (_ :\n                      ∀ (a₁ a₂ : MonoidAlgebra k G),\n                        MulActionHom.toFun\n                            {\n                                toMulActionHom :=\n                                  { toFun := fun a => Finsupp.sum a fun m t => t • ↑f m,\n                                    map_smul' :=\n                                      (_ :\n                                        ∀ (t' : k) (a : MonoidAlgebra k G),\n                                          (fun a => Finsupp.sum a fun m t => t • ↑f m) (t' • a) =\n                                            t' • (fun a => Finsupp.sum a fun m t => t • ↑f m) a) },\n                                map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                                map_add' :=\n                                  (_ :\n                                    ∀ (x y : G →₀ k),\n                                      ZeroHom.toFun (↑src) (x + y) =\n                                        ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) }.toMulActionHom\n                            (a₁ * a₂) =\n                          MulActionHom.toFun\n                              {\n                                  toMulActionHom :=\n                                    { toFun := fun a => Finsupp.sum a fun m t => t • ↑f m,\n                                      map_smul' :=\n                                        (_ :\n                                          ∀ (t' : k) (a : MonoidAlgebra k G),\n                                            (fun a => Finsupp.sum a fun m t => t • ↑f m) (t' • a) =\n                                              t' • (fun a => Finsupp.sum a fun m t => t • ↑f m) a) },\n                                  map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                                  map_add' :=\n                                    (_ :\n                                      ∀ (x y : G →₀ k),\n                                        ZeroHom.toFun (↑src) (x + y) =\n                                          ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) }.toMulActionHom\n                              a₁ *\n                            MulActionHom.toFun\n                              {\n                                  toMulActionHom :=\n                                    { toFun := fun a => Finsupp.sum a fun m t => t • ↑f m,\n                                      map_smul' :=\n                                        (_ :\n                                          ∀ (t' : k) (a : MonoidAlgebra k G),\n                                            (fun a => Finsupp.sum a fun m t => t • ↑f m) (t' • a) =\n                                              t' • (fun a => Finsupp.sum a fun m t => t • ↑f m) a) },\n                                  map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                                  map_add' :=\n                                    (_ :\n                                      ∀ (x y : G →₀ k),\n                                        ZeroHom.toFun (↑src) (x + y) =\n                                          ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) }.toMulActionHom\n                              a₂) })\n              ((fun F => MulHom.comp (NonUnitalAlgHom.toMulHom F) (MonoidAlgebra.ofMagma k G)) F) =\n            F) }","name":"MonoidAlgebra.liftMagma","doc":"The functor `G ↦ MonoidAlgebra k G`, from the category of magmas to the category of non-unital,\nnon-associative algebras over `k` is adjoint to the forgetful functor in the other direction. ","depth":41}],"count":5}
{"noDocExamples":[{"term":"fun a b =>\n  Eq.mp\n    (congrArg (Eq (frontier (Set.Ici a ×ℂ Set.Ici b)))\n      (congr (congrArg Union.union (congr (congrArg Complex.Set.reProdIm (closure_Ici a)) frontier_Ici))\n        (congr (congrArg Complex.Set.reProdIm frontier_Ici) (closure_Ici b))))\n    (Complex.frontier_reProdIm (Set.Ici a) (Set.Ici b))","name":"Complex.frontier_setOf_le_re_and_le_im","depth":22},{"term":"fun a b =>\n  Eq.mp\n    (congrArg (Eq (frontier (Set.Ici a ×ℂ Set.Iic b)))\n      (congr (congrArg Union.union (congr (congrArg Complex.Set.reProdIm (closure_Ici a)) frontier_Iic))\n        (congr (congrArg Complex.Set.reProdIm frontier_Ici) (closure_Iic b))))\n    (Complex.frontier_reProdIm (Set.Ici a) (Set.Iic b))","name":"Complex.frontier_setOf_le_re_and_im_le","depth":22},{"term":"fun s t =>\n  Eq.mpr (id (Complex.Set.reProdIm._eq_1 s t ▸ Eq.refl (interior (s ×ℂ t) = interior s ×ℂ interior t)))\n    (Eq.mpr\n      (id\n        (Complex.Set.reProdIm._eq_1 (interior s) (interior t) ▸\n          Eq.refl (interior (Complex.re ⁻¹' s ∩ Complex.im ⁻¹' t) = interior s ×ℂ interior t)))\n      (Eq.mpr\n        (id\n          (interior_inter ▸\n            Eq.refl\n              (interior (Complex.re ⁻¹' s ∩ Complex.im ⁻¹' t) = Complex.re ⁻¹' interior s ∩ Complex.im ⁻¹' interior t)))\n        (Eq.mpr\n          (id\n            (Complex.interior_preimage_re s ▸\n              Eq.refl\n                (interior (Complex.re ⁻¹' s) ∩ interior (Complex.im ⁻¹' t) =\n                  Complex.re ⁻¹' interior s ∩ Complex.im ⁻¹' interior t)))\n          (Eq.mpr\n            (id\n              (Complex.interior_preimage_im t ▸\n                Eq.refl\n                  (Complex.re ⁻¹' interior s ∩ interior (Complex.im ⁻¹' t) =\n                    Complex.re ⁻¹' interior s ∩ Complex.im ⁻¹' interior t)))\n            (Eq.refl (Complex.re ⁻¹' interior s ∩ Complex.im ⁻¹' interior t))))))","name":"Complex.interior_reProdIm","depth":28},{"term":"fun s t =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        ((fun x_0 x_1 =>\n            Eq.symm\n              (propext\n                ((fun x_0 x_1 =>\n                    Set.preimage_eq_preimage\n                      (Homeomorph.surjective\n                        (ContinuousLinearEquiv.toHomeomorph (ContinuousLinearEquiv.symm Complex.equivRealProdClm))))\n                  x_0 x_1)))\n          (frontier (s ×ℂ t)) (closure s ×ℂ frontier t ∪ frontier s ×ℂ closure t))\n        (congrFun\n          (congrArg Eq\n            ((fun s =>\n                Homeomorph.preimage_frontier\n                  (ContinuousLinearEquiv.toHomeomorph (ContinuousLinearEquiv.symm Complex.equivRealProdClm)) s)\n              (s ×ℂ t)))\n          (↑(ContinuousLinearEquiv.toHomeomorph (ContinuousLinearEquiv.symm Complex.equivRealProdClm)) ⁻¹'\n            (closure s ×ℂ frontier t ∪ frontier s ×ℂ closure t)))))\n    (frontier_prod_eq s t)","name":"Complex.frontier_reProdIm","depth":38},{"term":"fun s t =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        ((fun x_0 x_1 =>\n            Eq.symm\n              (propext\n                ((fun x_0 x_1 =>\n                    Set.preimage_eq_preimage\n                      (Homeomorph.surjective\n                        (ContinuousLinearEquiv.toHomeomorph (ContinuousLinearEquiv.symm Complex.equivRealProdClm))))\n                  x_0 x_1)))\n          (closure (s ×ℂ t)) (closure s ×ℂ closure t))\n        (congrFun\n          (congrArg Eq\n            ((fun s =>\n                Homeomorph.preimage_closure\n                  (ContinuousLinearEquiv.toHomeomorph (ContinuousLinearEquiv.symm Complex.equivRealProdClm)) s)\n              (s ×ℂ t)))\n          (↑(ContinuousLinearEquiv.toHomeomorph (ContinuousLinearEquiv.symm Complex.equivRealProdClm)) ⁻¹'\n            (closure s ×ℂ closure t)))))\n    closure_prod_eq","name":"Complex.closure_reProdIm","depth":38}],"kind":"Complex.«term_×ℂ_»","examples":[],"count":5}
{"noDocExamples":[{"term":"fun V [Quiver V] => { default := 𝟭q V }","name":"Prefunctor.instInhabitedPrefunctor","depth":8},{"term":"fun V [Quiver V] X => Eq.refl ((𝟭q V).obj X)","name":"Prefunctor.id_obj","depth":10},{"term":"fun V [Quiver V] {X Y} f => Eq.refl ((𝟭q V).map f)","name":"Prefunctor.id_map","depth":14},{"term":"fun {V} [Quiver V] =>\n  id\n    (Eq.symm\n      (CategoryTheory.Groupoid.Free.lift_unique (𝟭q V ⋙q CategoryTheory.Groupoid.Free.of V)\n        (CategoryTheory.Functor.id (CategoryTheory.FreeGroupoid V))\n        (Eq.refl\n          (CategoryTheory.Groupoid.Free.of V ⋙q\n            (CategoryTheory.Functor.id (CategoryTheory.FreeGroupoid V)).toPrefunctor))))","name":"CategoryTheory.Groupoid.Free.freeGroupoidFunctor_id","depth":16}],"kind":"Prefunctor.«term𝟭q»","examples":[{"term":"fun B [Quiver B] [(a b : B) → Quiver (a ⟶ b)] =>\n  let src := 𝟭q B;\n  { toPrefunctor := { obj := src.obj, map := fun {X Y} => src.map }, map₂ := fun {a b} {f g} η => η }","name":"CategoryTheory.PrelaxFunctor.id","doc":"The identity prelax functor. ","depth":18}],"count":5}
{"noDocExamples":[{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {D}\n    [CategoryTheory.Category.{v₂, u₂} D] [CategoryTheory.MonoidalCategory D] {E} [CategoryTheory.Category.{v₃, u₃} E]\n    [CategoryTheory.MonoidalCategory E] F G =>\n  Eq.refl (F ⊗⋙ G).toLaxMonoidalFunctor","name":"CategoryTheory.MonoidalFunctor.comp_toLaxMonoidalFunctor","depth":24}],"kind":"CategoryTheory.MonoidalFunctor.«term_⊗⋙_»","examples":[{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] {D}\n    [CategoryTheory.Category.{v₂, u₂} D] [CategoryTheory.MonoidalCategory D] {E} [CategoryTheory.Category.{v₃, u₃} E]\n    [CategoryTheory.MonoidalCategory E] F G =>\n  CategoryTheory.MonoidalFunctor.diag C ⊗⋙ CategoryTheory.MonoidalFunctor.prod F G","name":"CategoryTheory.MonoidalFunctor.prod'","doc":"The cartesian product of two monoidal functors starting from the same monoidal category `C`\nis monoidal. ","depth":26},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] [CategoryTheory.MonoidalCategory C] [CategoryTheory.BraidedCategory C] {D}\n    [CategoryTheory.Category.{v₂, u₂} D] [CategoryTheory.MonoidalCategory D] [CategoryTheory.BraidedCategory D] {E}\n    [CategoryTheory.Category.{v₃, u₃} E] [CategoryTheory.MonoidalCategory E] [CategoryTheory.BraidedCategory E] F G =>\n  let src := F.toMonoidalFunctor ⊗⋙ G.toMonoidalFunctor;\n  CategoryTheory.BraidedFunctor.mk (CategoryTheory.MonoidalFunctor.mk src.toLaxMonoidalFunctor)","name":"CategoryTheory.BraidedFunctor.comp","doc":"The composition of braided monoidal functors. ","depth":30},{"term":"fun {M} [Monoid M] {N} [Monoid N] {K} [Monoid K] F G =>\n  CategoryTheory.Iso.mk\n    (CategoryTheory.MonoidalNatTrans.mk\n      (CategoryTheory.NatTrans.mk fun X =>\n        CategoryTheory.CategoryStruct.id\n          ((CategoryTheory.Discrete.monoidalFunctor F ⊗⋙\n                    CategoryTheory.Discrete.monoidalFunctor G).toLaxMonoidalFunctor.toFunctor.obj\n            X)))\n    (CategoryTheory.MonoidalNatTrans.mk\n      (CategoryTheory.NatTrans.mk fun X =>\n        CategoryTheory.CategoryStruct.id\n          ((CategoryTheory.Discrete.monoidalFunctor (MonoidHom.comp G F)).toLaxMonoidalFunctor.toFunctor.obj X)))","name":"CategoryTheory.Discrete.monoidalFunctorComp","doc":"The monoidal natural isomorphism corresponding to composing two multiplicative morphisms.\n","depth":36},{"term":"fun {M} [AddMonoid M] {N} [AddMonoid N] {K} [AddMonoid K] F G =>\n  CategoryTheory.Iso.mk\n    (CategoryTheory.MonoidalNatTrans.mk\n      (CategoryTheory.NatTrans.mk fun X =>\n        CategoryTheory.CategoryStruct.id\n          ((CategoryTheory.Discrete.addMonoidalFunctor F ⊗⋙\n                    CategoryTheory.Discrete.addMonoidalFunctor G).toLaxMonoidalFunctor.toFunctor.obj\n            X)))\n    (CategoryTheory.MonoidalNatTrans.mk\n      (CategoryTheory.NatTrans.mk fun X =>\n        CategoryTheory.CategoryStruct.id\n          ((CategoryTheory.Discrete.addMonoidalFunctor (AddMonoidHom.comp G F)).toLaxMonoidalFunctor.toFunctor.obj X)))","name":"CategoryTheory.Discrete.addMonoidalFunctorComp","doc":"The monoidal natural isomorphism corresponding to\ncomposing two additive morphisms.","depth":36}],"count":5}
{"noDocExamples":[{"term":"fun C [CategoryTheory.Category.{v, u} C] [CategoryTheory.EssentiallySmall C] =>\n  Classical.choose (_ : ∃ x, Nonempty (C ≌ Classical.choose (_ : ∃ S x, Nonempty (C ≌ S))))","name":"CategoryTheory.smallCategorySmallModel","depth":20},{"term":"fun X [TopologicalSpace X] =>\n  Eq.mpr\n    (id\n      (propext (simply_connected_def X) ▸\n        Eq.refl (SimplyConnectedSpace X ↔ Nonempty X ∧ ∀ (x y : X), Nonempty (Unique (Path.Homotopic.Quotient x y)))))\n    (Eq.mpr\n      (id\n        (propext (CategoryTheory.equiv_punit_iff_unique (FundamentalGroupoid X)) ▸\n          Eq.refl\n            (Nonempty (FundamentalGroupoid X ≌ CategoryTheory.Discrete Unit) ↔\n              Nonempty X ∧ ∀ (x y : X), Nonempty (Unique (Path.Homotopic.Quotient x y)))))\n      Iff.rfl)","name":"simply_connected_iff_unique_homotopic","depth":23}],"kind":"CategoryTheory.«term_≌_»","examples":[{"term":"fun C [CategoryTheory.Category.{v, u} C] [CategoryTheory.EssentiallySmall C] =>\n  Nonempty.some (_ : Nonempty (C ≌ Classical.choose (_ : ∃ S x, Nonempty (C ≌ S))))","name":"CategoryTheory.equivSmallModel","doc":"The (noncomputable) categorical equivalence between\nan essentially small category and its small model.\n","depth":11},{"term":"fun C [CategoryTheory.Category.{v, u} C] [CategoryTheory.EssentiallySmall C] =>\n  Classical.choose (_ : ∃ S x, Nonempty (C ≌ S))","name":"CategoryTheory.SmallModel","doc":"An arbitrarily chosen small model for an essentially small category.\n","depth":13},{"term":"fun {C} [CategoryTheory.Category.{v₁, u₁} C] e x =>\n  Nat.brecOn x fun x f =>\n    (match (motive := (x : ℕ) → Nat.below x → (C ≌ C)) x with\n      | 0 => fun x => CategoryTheory.Equivalence.refl\n      | 1 => fun x => e\n      | Nat.succ (Nat.succ n) => fun x => CategoryTheory.Equivalence.trans e x.fst.fst)\n      f","name":"CategoryTheory.Equivalence.powNat","doc":"Natural number powers of an auto-equivalence.  Use `(^)` instead. ","depth":31}],"count":5}
{"noDocExamples":[{"term":"fun {α} l₁ l₂ l₃ =>\n  Eq.mpr (id (Eq.symm (List.append_assoc l₁ l₂ l₃) ▸ Eq.refl (l₂ <:+: l₁ ++ (l₂ ++ l₃)))) (List.infix_append l₁ l₂ l₃)","name":"List.infix_append'","depth":23},{"term":"fun {α} p ⦃l₁ l₂⦄ h =>\n  Exists.casesOn h fun xs h =>\n    Exists.casesOn h fun ys h =>\n      h ▸\n        Eq.mpr (id (List.filter_append (xs ++ l₁) ys ▸ Eq.refl (List.filter p l₁ <:+: List.filter p (xs ++ l₁ ++ ys))))\n          (Eq.mpr\n            (id\n              (List.filter_append xs l₁ ▸ Eq.refl (List.filter p l₁ <:+: List.filter p (xs ++ l₁) ++ List.filter p ys)))\n            (List.infix_append (List.filter p xs) (List.filter p l₁) (List.filter p ys)))","name":"List.isInfix.filter","depth":36},{"term":"fun {α} {l₁} {a} {l₂} =>\n  {\n    mp := fun a_1 =>\n      Exists.casesOn a_1 fun w h =>\n        List.casesOn (motive := fun x => (∃ t, x ++ l₁ ++ t = a :: l₂) → l₁ <+: a :: l₂ ∨ l₁ <:+: l₂) w\n          (fun h => Exists.casesOn h fun t hl₃ => Or.inl (Exists.intro t hl₃))\n          (fun head tail h =>\n            Exists.casesOn h fun t hl₃ =>\n              List.noConfusion hl₃ fun head_eq hl₄ => Or.inr (Exists.intro tail (Exists.intro t hl₄)))\n          h,\n    mpr := fun a_1 => Or.casesOn a_1 (fun h => List.isPrefix.isInfix h) fun hl₁ => List.infix_cons hl₁ }","name":"List.infix_cons_iff","depth":39},{"term":"fun {α} x =>\n  List.brecOn x fun x f =>\n    (match (motive := ∀ (x : List α), List.below x → List.Chain' (fun x_2 y => [x_2, y] <:+: x) x) x with\n      | [] => fun x => List.chain'_nil\n      | [a] => fun x => List.chain'_singleton a\n      | a :: b :: l => fun x =>\n        Iff.mpr List.chain'_cons\n          { left := Exists.intro [] (Exists.intro l (of_eq_true (eq_self (a :: b :: l)))),\n            right :=\n              List.Chain'.imp\n                (fun x y h =>\n                  List.isInfix.trans h\n                    (Exists.intro [a]\n                      (Exists.intro []\n                        (of_eq_true\n                          (Eq.trans (congrFun (congrArg Eq (List.append_nil (a :: b :: l))) (a :: b :: l))\n                            (eq_self (a :: b :: l)))))))\n                x.fst.fst })\n      f","name":"List.chain'_isInfix","depth":40},{"term":"fun {α} {l} x x_1 =>\n  List.brecOn (motive := fun x => l ∈ x → l <:+: List.join x) x\n    (fun x f x_2 =>\n      (match (motive :=\n          ∀ (x : List (List α)),\n            l ∈ x → List.below (motive := fun x => l ∈ x → l <:+: List.join x) x → l <:+: List.join x)\n          x, x_2 with\n        | l' :: tail, h => fun x =>\n          match l', h with\n          | .(l), List.Mem.head .(tail) => List.infix_append [] l (List.join tail)\n          | l', List.Mem.tail .(l') hlMemL =>\n            List.isInfix.trans (PProd.fst x.fst hlMemL)\n              (List.isSuffix.isInfix (List.suffix_append l' (List.join tail))))\n        f)\n    x_1","name":"List.infix_of_mem_join","depth":44}],"kind":"List.«term_<:+:_»","examples":[],"count":5}
{"noDocExamples":[{"term":"fun {α} {m0} μ f s =>\n  Eq.mpr\n    (id\n      ((MeasureTheory.laverage_eq (MeasureTheory.Measure.restrict μ s) fun x => f x) ▸\n        Eq.refl (⨍⁻ (x : α) in s, f x ∂μ = (∫⁻ (x : α) in s, f x ∂μ) / ↑↑μ s)))\n    (Eq.mpr\n      (id\n        (MeasureTheory.Measure.restrict_apply_univ s ▸\n          Eq.refl\n            ((∫⁻ (x : α) in s, f x ∂μ) / ↑↑(MeasureTheory.Measure.restrict μ s) Set.univ =\n              (∫⁻ (x : α) in s, f x ∂μ) / ↑↑μ s)))\n      (Eq.refl ((∫⁻ (x : α) in s, f x ∂μ) / ↑↑μ s)))","name":"MeasureTheory.setLaverage_eq","depth":26},{"term":"fun {α} {m0} {μ} {s} {f} [MeasureTheory.IsFiniteMeasure μ] hs hs₀ hsc₀ =>\n  Eq.mp\n    (congrFun\n      (congrArg Membership.mem\n        (congrFun\n          (congrArg MeasureTheory.laverage\n            (Eq.trans (congrArg (MeasureTheory.Measure.restrict μ) (Set.union_compl_self s))\n              MeasureTheory.Measure.restrict_univ))\n          fun x => f x))\n      (openSegment ENNReal (⨍⁻ (x : α) in s, f x ∂μ) (⨍⁻ (x : α) in sᶜ, f x ∂μ)))\n    (MeasureTheory.laverage_union_mem_openSegment MeasureTheory.aedisjoint_compl_right\n      (MeasureTheory.NullMeasurableSet.compl hs) hs₀ hsc₀ (MeasureTheory.measure_ne_top μ s)\n      (MeasureTheory.measure_ne_top μ sᶜ))","name":"MeasureTheory.laverage_mem_openSegment_compl_self","depth":29},{"term":"fun {α} {m0} {μ} {s} f h =>\n  let_fun this := { out := Ne.lt_top h };\n  Eq.mpr\n    (id\n      (Eq.symm (MeasureTheory.measure_mul_laverage (MeasureTheory.Measure.restrict μ s) fun x => f x) ▸\n        Eq.refl (↑↑μ s * ⨍⁻ (x : α) in s, f x ∂μ = ∫⁻ (x : α) in s, f x ∂μ)))\n    (Eq.mpr\n      (id\n        (MeasureTheory.Measure.restrict_apply_univ s ▸\n          Eq.refl\n            (↑↑μ s * ⨍⁻ (x : α) in s, f x ∂μ =\n              ↑↑(MeasureTheory.Measure.restrict μ s) Set.univ * ⨍⁻ (x : α) in s, f x ∂μ)))\n      (Eq.refl (↑↑μ s * ⨍⁻ (x : α) in s, f x ∂μ)))","name":"MeasureTheory.measure_mul_setLaverage","depth":31},{"term":"fun {α} {m0} {μ} {s t} {f} hd ht =>\n  Eq.mpr\n    (id\n      (MeasureTheory.Measure.restrict_union₀ hd ht ▸\n        Eq.refl\n          (⨍⁻ (x : α) in s ∪ t, f x ∂μ =\n            ↑↑μ s / (↑↑μ s + ↑↑μ t) * ⨍⁻ (x : α) in s, f x ∂μ + ↑↑μ t / (↑↑μ s + ↑↑μ t) * ⨍⁻ (x : α) in t, f x ∂μ)))\n    (Eq.mpr\n      (id\n        (MeasureTheory.laverage_add_measure ▸\n          Eq.refl\n            (⨍⁻ (x : α), f x ∂(MeasureTheory.Measure.restrict μ s + MeasureTheory.Measure.restrict μ t) =\n              ↑↑μ s / (↑↑μ s + ↑↑μ t) * ⨍⁻ (x : α) in s, f x ∂μ + ↑↑μ t / (↑↑μ s + ↑↑μ t) * ⨍⁻ (x : α) in t, f x ∂μ)))\n      (Eq.mpr\n        (id\n          (MeasureTheory.Measure.restrict_apply_univ s ▸\n            Eq.refl\n              (↑↑(MeasureTheory.Measure.restrict μ s) Set.univ /\n                      (↑↑(MeasureTheory.Measure.restrict μ s) Set.univ +\n                        ↑↑(MeasureTheory.Measure.restrict μ t) Set.univ) *\n                    ⨍⁻ (x : α) in s, f x ∂μ +\n                  ↑↑(MeasureTheory.Measure.restrict μ t) Set.univ /\n                      (↑↑(MeasureTheory.Measure.restrict μ s) Set.univ +\n                        ↑↑(MeasureTheory.Measure.restrict μ t) Set.univ) *\n                    ⨍⁻ (x : α) in t, f x ∂μ =\n                ↑↑μ s / (↑↑μ s + ↑↑μ t) * ⨍⁻ (x : α) in s, f x ∂μ + ↑↑μ t / (↑↑μ s + ↑↑μ t) * ⨍⁻ (x : α) in t, f x ∂μ)))\n        (Eq.mpr\n          (id\n            (MeasureTheory.Measure.restrict_apply_univ t ▸\n              Eq.refl\n                (↑↑μ s / (↑↑μ s + ↑↑(MeasureTheory.Measure.restrict μ t) Set.univ) * ⨍⁻ (x : α) in s, f x ∂μ +\n                    ↑↑(MeasureTheory.Measure.restrict μ t) Set.univ /\n                        (↑↑μ s + ↑↑(MeasureTheory.Measure.restrict μ t) Set.univ) *\n                      ⨍⁻ (x : α) in t, f x ∂μ =\n                  ↑↑μ s / (↑↑μ s + ↑↑μ t) * ⨍⁻ (x : α) in s, f x ∂μ +\n                    ↑↑μ t / (↑↑μ s + ↑↑μ t) * ⨍⁻ (x : α) in t, f x ∂μ)))\n          (Eq.refl\n            (↑↑μ s / (↑↑μ s + ↑↑μ t) * ⨍⁻ (x : α) in s, f x ∂μ + ↑↑μ t / (↑↑μ s + ↑↑μ t) * ⨍⁻ (x : α) in t, f x ∂μ)))))","name":"MeasureTheory.laverage_union","depth":40},{"term":"fun {α} {m0} {μ} {s t} {f} hd ht hsμ htμ =>\n  if hs₀ : ↑↑μ s = 0 then\n    Eq.mpr\n      (id\n        (MeasureTheory.Measure.restrict_congr_set\n            (Filter.EventuallyEq.union (Eq.mp (Eq.symm (propext MeasureTheory.ae_eq_empty) ▸ Eq.refl (↑↑μ s = 0)) hs₀)\n              Filter.EventuallyEq.rfl) ▸\n          Eq.refl (⨍⁻ (x : α) in s ∪ t, f x ∂μ ∈ segment ENNReal (⨍⁻ (x : α) in s, f x ∂μ) (⨍⁻ (x : α) in t, f x ∂μ))))\n      (Eq.mpr\n        (id\n          (Set.empty_union t ▸\n            Eq.refl\n              (⨍⁻ (x : α) in ∅ ∪ t, f x ∂μ ∈ segment ENNReal (⨍⁻ (x : α) in s, f x ∂μ) (⨍⁻ (x : α) in t, f x ∂μ))))\n        (right_mem_segment ENNReal (⨍⁻ (x : α) in s, f x ∂μ) (⨍⁻ (x : α) in t, f x ∂μ)))\n  else\n    Exists.intro (↑↑μ s / (↑↑μ s + ↑↑μ t))\n      (Exists.intro (↑↑μ t / (↑↑μ s + ↑↑μ t))\n        (Exists.intro (zero_le (↑↑μ s / (↑↑μ s + ↑↑μ t)))\n          (Exists.intro (zero_le (↑↑μ t / (↑↑μ s + ↑↑μ t)))\n            (Exists.intro\n              (Eq.mpr (id (Eq.symm ENNReal.add_div ▸ Eq.refl (↑↑μ s / (↑↑μ s + ↑↑μ t) + ↑↑μ t / (↑↑μ s + ↑↑μ t) = 1)))\n                (Eq.mpr\n                  (id\n                    (ENNReal.div_self (Iff.mpr (Iff.not add_eq_zero) fun h => hs₀ h.left)\n                        (Iff.mpr ENNReal.add_ne_top { left := hsμ, right := htμ }) ▸\n                      Eq.refl ((↑↑μ s + ↑↑μ t) / (↑↑μ s + ↑↑μ t) = 1)))\n                  (Eq.refl 1)))\n              (Eq.symm (MeasureTheory.laverage_union hd ht))))))","name":"MeasureTheory.laverage_union_mem_segment","depth":46}],"kind":"MeasureTheory.«term⨍⁻_In_,_∂_»","examples":[],"count":5}
{"noDocExamples":[{"term":"fun {R} {A} [Monoid R] [NonUnitalNonAssocSemiring A] [DistribMulAction R A] [StarAddMonoid A] =>\n  let src := inferInstanceAs (Monoid (A →⋆ₙₐ[R] A));\n  let src_1 := inferInstanceAs (Zero (A →⋆ₙₐ[R] A));\n  MonoidWithZero.mk (_ : ∀ (x : A →⋆ₙₐ[R] A), 0 * x = 0) (_ : ∀ (f : A →⋆ₙₐ[R] A), f * 0 = 0)","name":"NonUnitalStarAlgHom.instMonoidWithZeroNonUnitalStarAlgHomToStarToInvolutiveStarToAddMonoidToAddCommMonoid","depth":31},{"term":"fun {R} {A} [Monoid R] [NonUnitalNonAssocSemiring A] [DistribMulAction R A] [Star A] =>\n  Monoid.mk (_ : ∀ (f : A →⋆ₙₐ[R] A), NonUnitalStarAlgHom.comp (NonUnitalStarAlgHom.id R A) f = f)\n    (_ : ∀ (f : A →⋆ₙₐ[R] A), NonUnitalStarAlgHom.comp f (NonUnitalStarAlgHom.id R A) = f) npowRec","name":"NonUnitalStarAlgHom.instMonoidNonUnitalStarAlgHom","depth":32},{"term":"fun {R} {A} {B} [Monoid R] [NonUnitalNonAssocSemiring A] [DistribMulAction R A] [Star A] [NonUnitalNonAssocSemiring B]\n    [DistribMulAction R B] [Star B] =>\n  NonUnitalStarAlgHomClass.mk\n    (_ :\n      ∀ (f : A →⋆ₙₐ[R] B) (a : A),\n        MulActionHom.toFun f.toMulActionHom (star a) = star (MulActionHom.toFun f.toMulActionHom a))","name":"NonUnitalStarAlgHom.instNonUnitalStarAlgHomClassNonUnitalStarAlgHom","depth":36}],"kind":"«term_→⋆ₙₐ[_]_»","examples":[{"term":"fun {R} {A} {B} {C} [Monoid R] [NonUnitalNonAssocSemiring A] [DistribMulAction R A] [Star A]\n    [NonUnitalNonAssocSemiring B] [DistribMulAction R B] [Star B] [NonUnitalNonAssocSemiring C] [DistribMulAction R C]\n    [Star C] =>\n  { toFun := fun f => NonUnitalStarAlgHom.prod f.fst f.snd,\n    invFun := fun f =>\n      (NonUnitalStarAlgHom.comp (NonUnitalStarAlgHom.fst R B C) f,\n        NonUnitalStarAlgHom.comp (NonUnitalStarAlgHom.snd R B C) f),\n    left_inv :=\n      (_ :\n        ∀ (f : (A →⋆ₙₐ[R] B) × (A →⋆ₙₐ[R] C)),\n          (fun f =>\n                (NonUnitalStarAlgHom.comp (NonUnitalStarAlgHom.fst R B C) f,\n                  NonUnitalStarAlgHom.comp (NonUnitalStarAlgHom.snd R B C) f))\n              ((fun f => NonUnitalStarAlgHom.prod f.fst f.snd) f) =\n            f),\n    right_inv :=\n      (_ :\n        ∀ (f : A →⋆ₙₐ[R] B × C),\n          (fun f => NonUnitalStarAlgHom.prod f.fst f.snd)\n              ((fun f =>\n                  (NonUnitalStarAlgHom.comp (NonUnitalStarAlgHom.fst R B C) f,\n                    NonUnitalStarAlgHom.comp (NonUnitalStarAlgHom.snd R B C) f))\n                f) =\n            f) }","name":"NonUnitalStarAlgHom.prodEquiv","doc":"Taking the product of two maps with the same domain is equivalent to taking the product of\ntheir codomains. ","depth":36},{"term":"fun {R} {A} {C} [CommSemiring R] [StarRing R] [NonUnitalSemiring A] [StarRing A] [Module R A] [SMulCommClass R A A]\n    [IsScalarTower R A A] [Semiring C] [Algebra R C] [StarRing C] [StarModule R C] =>\n  {\n    toFun := fun φ =>\n      { toAlgHom := ↑Unitization.lift φ.toNonUnitalAlgHom,\n        map_star' :=\n          (_ :\n            ∀ (x : Unitization R A),\n              OneHom.toFun (↑↑↑(↑Unitization.lift φ.toNonUnitalAlgHom)) (star x) =\n                star (OneHom.toFun (↑↑↑(↑Unitization.lift φ.toNonUnitalAlgHom)) x)) },\n    invFun := fun φ =>\n      NonUnitalStarAlgHom.comp (StarAlgHom.toNonUnitalStarAlgHom φ) (Unitization.inrNonUnitalStarAlgHom R A),\n    left_inv :=\n      (_ :\n        ∀ (φ : A →⋆ₙₐ[R] C),\n          (fun φ =>\n                NonUnitalStarAlgHom.comp (StarAlgHom.toNonUnitalStarAlgHom φ) (Unitization.inrNonUnitalStarAlgHom R A))\n              ((fun φ =>\n                  { toAlgHom := ↑Unitization.lift φ.toNonUnitalAlgHom,\n                    map_star' :=\n                      (_ :\n                        ∀ (x : Unitization R A),\n                          OneHom.toFun (↑↑↑(↑Unitization.lift φ.toNonUnitalAlgHom)) (star x) =\n                            star (OneHom.toFun (↑↑↑(↑Unitization.lift φ.toNonUnitalAlgHom)) x)) })\n                φ) =\n            φ),\n    right_inv :=\n      (_ :\n        ∀ (φ : Unitization R A →⋆ₐ[R] C),\n          (fun φ =>\n                { toAlgHom := ↑Unitization.lift φ.toNonUnitalAlgHom,\n                  map_star' :=\n                    (_ :\n                      ∀ (x : Unitization R A),\n                        OneHom.toFun (↑↑↑(↑Unitization.lift φ.toNonUnitalAlgHom)) (star x) =\n                          star (OneHom.toFun (↑↑↑(↑Unitization.lift φ.toNonUnitalAlgHom)) x)) })\n              ((fun φ =>\n                  NonUnitalStarAlgHom.comp (StarAlgHom.toNonUnitalStarAlgHom φ)\n                    (Unitization.inrNonUnitalStarAlgHom R A))\n                φ) =\n            φ) }","name":"Unitization.starLift","doc":"Non-unital star algebra homomorphisms from `A` into a unital star `R`-algebra `C` lift uniquely\nto `Unitization R A →⋆ₐ[R] C`. This is the universal property of the unitization. ","depth":42}],"count":5}
{"noDocExamples":[{"term":"fun {ι} {α} [Preorder ι] [(i : ι) → Preorder (α i)] =>\n  let src := PSigma.Lex.le;\n  let src_1 := PSigma.Lex.lt;\n  Preorder.mk (_ : ∀ (x : Σₗ' (i : ι), α i), x ≤ x) (_ : ∀ (a b c : Σₗ' (i : ι), α i), a ≤ b → b ≤ c → a ≤ c)","name":"PSigma.Lex.preorder","depth":18}],"kind":"PSigma.«termΣₗ'_,_»","examples":[{"term":"fun {ι} {α} [PartialOrder ι] [(i : ι) → PartialOrder (α i)] =>\n  let src := PSigma.Lex.preorder;\n  PartialOrder.mk (_ : ∀ (a b : Σₗ' (i : ι), α i), a ≤ b → b ≤ a → a = b)","name":"PSigma.Lex.partialOrder","doc":"Dictionary / lexicographic partial_order for dependent pairs. ","depth":18},{"term":"fun {ι} {α} [PartialOrder ι] [OrderTop ι] [(i : ι) → Preorder (α i)] [OrderTop (α ⊤)] =>\n  OrderTop.mk (_ : ∀ (x : Σₗ' (i : ι), α i), x ≤ ⊤)","name":"PSigma.Lex.orderTop","doc":"The lexicographical linear order on a sigma type. ","depth":22},{"term":"fun {ι} {α} [PartialOrder ι] [OrderBot ι] [(i : ι) → Preorder (α i)] [OrderBot (α ⊥)] =>\n  OrderBot.mk (_ : ∀ (x : Σₗ' (i : ι), α i), ⊥ ≤ x)","name":"PSigma.Lex.orderBot","doc":"The lexicographical linear order on a sigma type. ","depth":22},{"term":"fun {ι} {α} [LinearOrder ι] [(i : ι) → LinearOrder (α i)] =>\n  let src := PSigma.Lex.partialOrder;\n  LinearOrder.mk (_ : ∀ (a b : Σₗ' (i : ι), α i), a ≤ b ∨ b ≤ a)\n    (PSigma.Lex.decidable (fun x x_1 => x < x_1) fun x x_1 x_2 => x_1 ≤ x_2) PSigma.decidableEq\n    (PSigma.Lex.decidable (fun x x_1 => x < x_1) fun x x_1 x_2 => x_1 < x_2)","name":"PSigma.Lex.linearOrder","doc":"Dictionary / lexicographic linear_order for pairs. ","depth":42}],"count":5}
{"noDocExamples":[{"term":"fun {α} {β} {r} {s} => RelHomClass.mk (_ : ∀ (f : r ↪r s) (a b : α), r a b → s (↑f a) (↑f b))","name":"RelEmbedding.instRelHomClassRelEmbedding","depth":15},{"term":"fun {α} {r} [IsStrictOrder α r] f =>\n  Eq.mpr (id (propext RelEmbedding.wellFounded_iff_no_descending_seq ▸ Eq.refl ¬WellFounded r))\n    (Eq.mpr (id (propext not_isEmpty_iff ▸ Eq.refl ¬IsEmpty ((fun x x_1 => x > x_1) ↪r r))) (Nonempty.intro f))","name":"RelEmbedding.not_wellFounded_of_decreasing_seq","depth":25}],"kind":"«term_↪r_»","examples":[{"term":"fun {V} {W} G G' => G.Adj ↪r G'.Adj","name":"SimpleGraph.Embedding","doc":"A graph embedding is an embedding `f` such that for vertices `v w : V`,\n`G.Adj (f v) (f w) ↔ G.Adj v w `. Its image is an induced subgraph of G'.\n\nThe notation `G ↪g G'` represents the type of graph embeddings. ","depth":8},{"term":"fun α β [LE α] [LE β] => (fun x x_1 => x ≤ x_1) ↪r fun x x_1 => x ≤ x_1","name":"OrderEmbedding","doc":"An order embedding is an embedding `f : α ↪ β` such that `a ≤ b ↔ (f a) ≤ (f b)`.\nThis definition is an abbreviation of `RelEmbedding (≤) (≤)`. ","depth":12}],"count":4}
{"noDocExamples":[],"kind":"Sigma.Lex.«termΣₗ_,_»","examples":[{"term":"fun {ι} {α} [Preorder ι] [(i : ι) → Preorder (α i)] =>\n  let src := Sigma.Lex.LE;\n  let src_1 := Sigma.Lex.LT;\n  Preorder.mk (_ : ∀ (x : Σₗ (i : ι), α i), x ≤ x)\n    (_ :\n      ∀ (x x_1 x_2 : Σₗ (i : ι), α i),\n        Sigma.Lex (fun x x_3 => x < x_3) (fun x x_3 x_4 => x_3 ≤ x_4) x x_1 →\n          Sigma.Lex (fun x x_3 => x < x_3) (fun x x_3 x_4 => x_3 ≤ x_4) x_1 x_2 →\n            Sigma.Lex (fun x x_3 => x < x_3) (fun x x_3 x_4 => x_3 ≤ x_4) x x_2)","name":"Sigma.Lex.preorder","doc":"The lexicographical preorder on a sigma type. ","depth":18},{"term":"fun {ι} {α} [Preorder ι] [(i : ι) → PartialOrder (α i)] =>\n  let src := Sigma.Lex.preorder;\n  PartialOrder.mk\n    (_ :\n      ∀ (x x_1 : Σₗ (i : ι), α i),\n        Sigma.Lex (fun x x_2 => x < x_2) (fun x x_2 x_3 => x_2 ≤ x_3) x x_1 →\n          Sigma.Lex (fun x x_2 => x < x_2) (fun x x_2 x_3 => x_2 ≤ x_3) x_1 x → x = x_1)","name":"Sigma.Lex.partialOrder","doc":"The lexicographical partial order on a sigma type. ","depth":18},{"term":"fun {ι} {α} [PartialOrder ι] [OrderBot ι] [(i : ι) → Preorder (α i)] [OrderBot (α ⊥)] =>\n  OrderBot.mk (_ : ∀ (x : Σₗ (i : ι), α i), ⊥ ≤ x)","name":"Sigma.Lex.orderBot","doc":"The lexicographical linear order on a sigma type. ","depth":22},{"term":"fun {ι} {α} [PartialOrder ι] [OrderTop ι] [(i : ι) → Preorder (α i)] [OrderTop (α ⊤)] =>\n  OrderTop.mk (_ : ∀ (x : Σₗ (i : ι), α i), x ≤ ⊤)","name":"Sigma.Lex.orderTop","doc":"The lexicographical linear order on a sigma type. ","depth":22}],"count":4}
{"noDocExamples":[],"kind":"«term_→._»","examples":[{"term":"fun {α} {β} =>\n  { toFun := fun f => { fst := fun a => (f a).Dom, snd := PFun.asSubtype f },\n    invFun := fun f x => { Dom := Sigma.fst f x, get := fun h => Sigma.snd f { val := x, property := h } },\n    left_inv :=\n      (_ :\n        ∀ (f : α →. β),\n          (fun f x => { Dom := Sigma.fst f x, get := fun h => Sigma.snd f { val := x, property := h } })\n              ((fun f => { fst := fun a => (f a).Dom, snd := PFun.asSubtype f }) f) =\n            f),\n    right_inv :=\n      (_ :\n        ∀ (x : (p : α → Prop) × (Subtype p → β)),\n          (fun f => { fst := fun a => (f a).Dom, snd := PFun.asSubtype f })\n              ((fun f x => { Dom := Sigma.fst f x, get := fun h => Sigma.snd f { val := x, property := h } }) x) =\n            x) }","name":"PFun.equivSubtype","doc":"The type of partial functions `α →. β` is equivalent to\nthe type of pairs `(p : α → Prop, f : Subtype p → β)`. ","depth":19},{"term":"fun x =>\n  Turing.ToPartrec.Cont.brecOn x fun x f =>\n    (match (motive := (x : Turing.ToPartrec.Cont) → Turing.ToPartrec.Cont.below x → List ℕ →. List ℕ) x with\n      | Turing.ToPartrec.Cont.halt => fun x => pure\n      | Turing.ToPartrec.Cont.cons₁ fs as k => fun x v => do\n        let ns ← Turing.ToPartrec.Code.eval fs as\n        PProd.fst x.fst (List.headI v :: ns)\n      | Turing.ToPartrec.Cont.cons₂ ns k => fun x v => PProd.fst x.fst (List.headI ns :: v)\n      | Turing.ToPartrec.Cont.comp f k => fun x v => Turing.ToPartrec.Code.eval f v >>= x.fst.fst\n      | Turing.ToPartrec.Cont.fix f k => fun x v =>\n        if List.headI v = 0 then PProd.fst x.fst (List.tail v)\n        else Turing.ToPartrec.Code.eval (Turing.ToPartrec.Code.fix f) (List.tail v) >>= x.fst.fst)\n      f","name":"Turing.ToPartrec.Cont.eval","doc":"The semantics of a continuation. ","depth":40},{"term":"fun x =>\n  Turing.ToPartrec.Code.brecOn x fun x f =>\n    (match (motive := (x : Turing.ToPartrec.Code) → Turing.ToPartrec.Code.below x → List ℕ →. List ℕ) x with\n      | Turing.ToPartrec.Code.zero' => fun x v => pure (0 :: v)\n      | Turing.ToPartrec.Code.succ => fun x v => pure [Nat.succ (List.headI v)]\n      | Turing.ToPartrec.Code.tail => fun x v => pure (List.tail v)\n      | Turing.ToPartrec.Code.cons f fs => fun x v => do\n        let n ← PProd.fst x.fst v\n        let ns ← PProd.fst x.snd.fst v\n        pure (List.headI n :: ns)\n      | Turing.ToPartrec.Code.comp f g => fun x v => PProd.fst x.snd.fst v >>= x.fst.fst\n      | Turing.ToPartrec.Code.case f g => fun x v =>\n        Nat.rec (PProd.fst x.fst (List.tail v)) (fun y x_1 => PProd.fst x.snd.fst (y :: List.tail v)) (List.headI v)\n      | Turing.ToPartrec.Code.fix f => fun x =>\n        PFun.fix fun v =>\n          Part.map (fun v => if List.headI v = 0 then Sum.inl (List.tail v) else Sum.inr (List.tail v))\n            (PProd.fst x.fst v))\n      f","name":"Turing.ToPartrec.Code.eval","doc":"The semantics of the `Code` primitives, as partial functions `List ℕ →. List ℕ`. By convention\nwe functions that return a single result return a singleton `[n]`, or in some cases `n :: v` where\n`v` will be ignored by a subsequent function.\n\n* `zero'` appends a `0` to the input. That is, `zero' v = 0 :: v`.\n* `succ` returns the successor of the head of the input, defaulting to zero if there is no head:\n  * `succ [] = [1]`\n  * `succ (n :: v) = [n + 1]`\n* `tail` returns the tail of the input\n  * `tail [] = []`\n  * `tail (n :: v) = v`\n* `cons f fs` calls `f` and `fs` on the input and conses the results:\n  * `cons f fs v = (f v).head :: fs v`\n* `comp f g` calls `f` on the output of `g`:\n  * `comp f g v = f (g v)`\n* `case f g` cases on the head of the input, calling `f` or `g` depending on whether it is zero or\n  a successor (similar to `Nat.casesOn`).\n  * `case f g [] = f []`\n  * `case f g (0 :: v) = f v`\n  * `case f g (n+1 :: v) = g (n :: v)`\n* `fix f` calls `f` repeatedly, using the head of the result of `f` to decide whether to call `f`\n  again or finish:\n  * `fix f v = []` if `f v = []`\n  * `fix f v = w` if `f v = 0 :: w`\n  * `fix f v = fix f w` if `f v = n+1 :: w` (the exact value of `n` is discarded)\n","depth":44},{"term":"fun x =>\n  Nat.Partrec.Code.brecOn x fun x f =>\n    (match (motive := (x : Nat.Partrec.Code) → Nat.Partrec.Code.below x → ℕ →. ℕ) x with\n      | Nat.Partrec.Code.zero => fun x => pure 0\n      | Nat.Partrec.Code.succ => fun x => ↑Nat.succ\n      | Nat.Partrec.Code.left => fun x => ↑fun n => (Nat.unpair n).fst\n      | Nat.Partrec.Code.right => fun x => ↑fun n => (Nat.unpair n).snd\n      | Nat.Partrec.Code.pair cf cg => fun x n =>\n        Seq.seq (Nat.pair <$> PProd.fst x.fst n) fun x_1 => PProd.fst x.snd.fst n\n      | Nat.Partrec.Code.comp cf cg => fun x n => PProd.fst x.snd.fst n >>= x.fst.fst\n      | Nat.Partrec.Code.prec cf cg => fun x =>\n        Nat.unpaired fun a n =>\n          Nat.rec (PProd.fst x.fst a)\n            (fun y IH => do\n              let i ← IH\n              PProd.fst x.snd.fst (Nat.pair a (Nat.pair y i)))\n            n\n      | Nat.Partrec.Code.rfind' cf => fun x =>\n        Nat.unpaired fun a m =>\n          Part.map (fun x => x + m)\n            (Nat.rfind fun n => (fun m => decide (m = 0)) <$> PProd.fst x.fst (Nat.pair a (n + m))))\n      f","name":"Nat.Partrec.Code.eval","doc":"The interpretation of a `Nat.Partrec.Code` as a partial function.\n* `Nat.Partrec.Code.zero`: The constant zero function.\n* `Nat.Partrec.Code.succ`: The successor function.\n* `Nat.Partrec.Code.left`: Left unpairing of a pair of ℕ (encoded by `Nat.pair`)\n* `Nat.Partrec.Code.right`: Right unpairing of a pair of ℕ (encoded by `Nat.pair`)\n* `Nat.Partrec.Code.pair`: Pairs the outputs of argument codes using `Nat.pair`.\n* `Nat.Partrec.Code.comp`: Composition of two argument codes.\n* `Nat.Partrec.Code.prec`: Primitive recursion. Given an argument of the form `Nat.pair a n`:\n  * If `n = 0`, returns `eval cf a`.\n  * If `n = succ k`, returns `eval cg (pair a (pair k (eval (prec cf cg) (pair a k))))`\n* `Nat.Partrec.Code.rfind'`: Minimization. For `f` an argument of the form `Nat.pair a m`,\n  `rfind' f m` returns the least `a` such that `f a m = 0`, if one exists and `f b m` terminates\n  for `b < a`\n","depth":45}],"count":4}
{"noDocExamples":[{"term":"fun {α} {β} => { coe := PEquiv.toFun, coe_injective' := (_ : ∀ ⦃a₁ a₂ : α ≃. β⦄, a₁.toFun = a₂.toFun → a₁ = a₂) }","name":"PEquiv.instFunLikePEquivOption","depth":9},{"term":"fun {α} {β} =>\n  let src := PEquiv.instBotPEquiv;\n  OrderBot.mk (_ : ∀ (x : α ≃. β) (x_1 : α) (x_2 : β), x_2 ∈ ↑⊥ x_1 → x_2 ∈ ↑x x_1)","name":"PEquiv.instOrderBotPEquivToLEToPreorderInstPartialOrderPEquiv","depth":11},{"term":"fun {α} {β} => PartialOrder.mk (_ : ∀ (f g : α ≃. β), f ≤ g → g ≤ f → f = g)","name":"PEquiv.instPartialOrderPEquiv","depth":26},{"term":"fun {α} {β} [DecidableEq α] [DecidableEq β] =>\n  let src := PEquiv.instPartialOrderPEquiv;\n  SemilatticeInf.mk (_ : ∀ (x x_1 : α ≃. β) (x_2 : α) (x_3 : β), x_3 ∈ ↑(x ⊓ x_1) x_2 → x_3 ∈ ↑x x_2)\n    (_ : ∀ (x x_1 : α ≃. β) (x_2 : α) (x_3 : β), x_3 ∈ ↑(x ⊓ x_1) x_2 → x_3 ∈ ↑x_1 x_2)\n    (_ : ∀ (f g h : α ≃. β), f ≤ g → f ≤ h → ∀ (a : α) (b : β), b ∈ ↑f a → b ∈ ↑(g ⊓ h) a)","name":"PEquiv.instSemilatticeInfPEquiv","depth":31}],"kind":"«term_≃._»","examples":[],"count":4}
{"noDocExamples":[{"term":"fun {α} {G} {n} =>\n  Eq.mpr (id (Eq.symm (propext not_iff_not) ▸ Eq.refl (SimpleGraph.CliqueFree G n ↔ IsEmpty (⊤ ↪g G))))\n    (Eq.mpr\n      (id (propext (SimpleGraph.not_cliqueFree_iff n) ▸ Eq.refl (¬SimpleGraph.CliqueFree G n ↔ ¬IsEmpty (⊤ ↪g G))))\n      (Eq.mpr (id (propext not_isEmpty_iff ▸ Eq.refl (Nonempty (⊤ ↪g G) ↔ ¬IsEmpty (⊤ ↪g G)))) Iff.rfl))","name":"SimpleGraph.cliqueFree_iff","depth":27},{"term":"fun {V} {G} {α} {s} h [Fintype α] C =>\n  let_fun f := SimpleGraph.Embedding.comap (Function.Embedding.subtype fun x => x ∈ s) G;\n  Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → HEq e'_3 x → HEq (a ≤ a_1) (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), HEq e_3 (Eq.refl a) → HEq (a ≤ a_1) (a' ≤ a_1))\n                (fun e_3 h => Eq.symm (eq_of_heq h) ▸ HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℕ instLENat (Finset.card s) (Fintype.card ↑↑s)\n        (of_eq_true (Eq.trans (congrArg (Eq (Finset.card s)) (Fintype.card_coe s)) (eq_self (Finset.card s))))\n        (Fintype.card α)))\n    (id\n      (Fintype.card_le_of_injective\n        (↑(SimpleGraph.Hom.comp C\n            (SimpleGraph.Embedding.toHom\n              (Eq.mp\n                (Eq.mp (propext (SimpleGraph.isClique_iff_induce_eq G) ▸ Eq.refl (SimpleGraph.IsClique G ↑s)) h ▸\n                  Eq.refl (SimpleGraph.induce (↑s) G ↪g G))\n                f))))\n        (SimpleGraph.Hom.injective_of_top_hom\n          (SimpleGraph.Hom.comp C\n            (SimpleGraph.Embedding.toHom\n              (Eq.mp\n                (Eq.mp (propext (SimpleGraph.isClique_iff_induce_eq G) ▸ Eq.refl (SimpleGraph.IsClique G ↑s)) h ▸\n                  Eq.refl (SimpleGraph.induce (↑s) G ↪g G))\n                f))))))","name":"SimpleGraph.IsClique.card_le_of_coloring","depth":47}],"kind":"SimpleGraph.«term_↪g_»","examples":[{"term":"fun {α} {G} {n} [Fintype α] hc =>\n  Classical.byContradiction fun h =>\n    Nat.lt_le_antisymm hc\n      (Eq.mp (congrFun (congrArg LE.le (Fintype.card_fin n)) (Fintype.card α))\n        (Fintype.card_le_of_embedding\n          (Nonempty.some\n              (Eq.mp (propext not_isEmpty_iff ▸ Eq.refl ¬IsEmpty (⊤ ↪g G))\n                (Eq.mp (propext SimpleGraph.cliqueFree_iff ▸ Eq.refl ¬SimpleGraph.CliqueFree G n) h))).toEmbedding))","name":"SimpleGraph.cliqueFree_of_card_lt","doc":"See `SimpleGraph.cliqueFree_of_chromaticNumber_lt` for a tighter bound. ","depth":32},{"term":"fun {n} {ι} [Fintype ι] V hc =>\n  Eq.mpr\n    (id\n      (propext SimpleGraph.cliqueFree_iff ▸\n        Eq.refl (SimpleGraph.CliqueFree (SimpleGraph.completeMultipartiteGraph V) n)))\n    (Eq.mpr (id (propext isEmpty_iff ▸ Eq.refl (IsEmpty (⊤ ↪g SimpleGraph.completeMultipartiteGraph V)))) fun f =>\n      Exists.casesOn\n        (Fintype.exists_ne_map_eq_of_card_lt (Sigma.fst ∘ ↑f)\n          (of_eq_true (Eq.trans (congrArg (LT.lt (Fintype.card ι)) (Fintype.card_fin n)) (eq_true hc))))\n        fun v h =>\n        Exists.casesOn h fun w h =>\n          And.casesOn h fun hn he =>\n            absurd he\n              (Eq.mp\n                (propext (SimpleGraph.top_adj (↑f v).fst (↑f w).fst) ▸\n                  Eq.refl (SimpleGraph.Adj ⊤ (↑f v).fst (↑f w).fst))\n                (Eq.mp\n                  (SimpleGraph.comap_Adj Sigma.fst ⊤ (↑f v) (↑f w) ▸\n                    Eq.refl (SimpleGraph.Adj (SimpleGraph.completeMultipartiteGraph V) (↑f v) (↑f w)))\n                  (Eq.mp (Eq.symm (propext (SimpleGraph.Embedding.map_adj_iff f)) ▸ Eq.refl (SimpleGraph.Adj ⊤ v w))\n                    (Eq.mp (Eq.symm (propext (SimpleGraph.top_adj v w)) ▸ Eq.refl (v ≠ w)) hn)))))","name":"SimpleGraph.cliqueFree_completeMultipartiteGraph","doc":"A complete `r`-partite graph has no `n`-cliques for `r < n`. ","depth":48}],"count":4}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫⁻_In_,_»","examples":[{"term":"fun {α} [MeasurableSpace α] {f} μ [MeasureTheory.SigmaFinite μ] f_nn f_mble =>\n  Eq.mpr\n    (id\n      (MeasureTheory.lintegral_eq_lintegral_meas_le μ f_nn f_mble ▸\n        Eq.refl (∫⁻ (ω : α), ENNReal.ofReal (f ω) ∂μ = ∫⁻ (t : ℝ) in Set.Ioi 0, ↑↑μ {a | t < f a})))\n    (MeasureTheory.lintegral_congr_ae\n      (Filter.mp_mem\n        (Measure.meas_le_ae_eq_meas_lt μ (MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Ioi 0)) f_mble)\n        (Filter.univ_mem'\n          (id fun t ht =>\n            Eq.mpr (id (ht ▸ Eq.refl (↑↑μ {a | t ≤ f a} = ↑↑μ {a | t < f a}))) (Eq.refl (↑↑μ {a | t < f a}))))))","name":"lintegral_eq_lintegral_meas_lt","doc":"The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a sigma-finite measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `∫⁻ f ∂μ = ∫⁻ t in (0).. ∞, μ {ω | f(ω) > t}`.\n\nSee `lintegral_eq_lintegral_meas_le` for a version with sets of the form `{ω | f(ω) ≥ t}`\ninstead. ","depth":40},{"term":"fun {α} [MeasurableSpace α] {f} μ [MeasureTheory.SigmaFinite μ] f_nn f_mble {p} p_pos =>\n  Eq.mpr\n    (id\n      (MeasureTheory.lintegral_rpow_eq_lintegral_meas_le_mul μ f_nn f_mble p_pos ▸\n        Eq.refl\n          (∫⁻ (ω : α), ENNReal.ofReal (f ω ^ p) ∂μ =\n            ENNReal.ofReal p * ∫⁻ (t : ℝ) in Set.Ioi 0, ↑↑μ {a | t < f a} * ENNReal.ofReal (t ^ (p - 1)))))\n    (congr_arg (fun z => ENNReal.ofReal p * z)\n      (MeasureTheory.lintegral_congr_ae\n        (Filter.mp_mem\n          (Measure.meas_le_ae_eq_meas_lt μ (MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Ioi 0)) f_mble)\n          (Filter.univ_mem'\n            (id fun t ht =>\n              Eq.mpr\n                (id\n                  (ht ▸\n                    Eq.refl\n                      (↑↑μ {a | t ≤ f a} * ENNReal.ofReal (t ^ (p - 1)) =\n                        ↑↑μ {a | t < f a} * ENNReal.ofReal (t ^ (p - 1)))))\n                (Eq.refl (↑↑μ {a | t < f a} * ENNReal.ofReal (t ^ (p - 1)))))))))","name":"lintegral_rpow_eq_lintegral_meas_lt_mul","doc":"An application of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a sigma-finite measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `∫⁻ f^p ∂μ = p * ∫⁻ t in (0).. ∞, t^(p-1) * μ {ω | f(ω) > t}`.\n\nSee `lintegral_rpow_eq_lintegral_meas_le_mul` for a version with sets of the form `{ω | f(ω) ≥ t}`\ninstead. ","depth":43},{"term":"fun {α} [MeasurableSpace α] {f} {g} μ [MeasureTheory.SigmaFinite μ] f_nn f_mble g_intble g_nn =>\n  Eq.mpr\n    (id\n      (MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul μ f_nn f_mble g_intble g_nn ▸\n        Eq.refl\n          (∫⁻ (ω : α), ENNReal.ofReal (∫ (t : ℝ) in 0 ..f ω, g t) ∂μ =\n            ∫⁻ (t : ℝ) in Set.Ioi 0, ↑↑μ {a | t < f a} * ENNReal.ofReal (g t))))\n    (MeasureTheory.lintegral_congr_ae\n      (Filter.mp_mem\n        (Measure.meas_le_ae_eq_meas_lt μ (MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Ioi 0)) f_mble)\n        (Filter.univ_mem'\n          (id fun t ht =>\n            Eq.mpr\n              (id (ht ▸ Eq.refl (↑↑μ {a | t ≤ f a} * ENNReal.ofReal (g t) = ↑↑μ {a | t < f a} * ENNReal.ofReal (g t))))\n              (Eq.refl (↑↑μ {a | t < f a} * ENNReal.ofReal (g t)))))))","name":"lintegral_comp_eq_lintegral_meas_lt_mul","doc":"The layer cake formula / Cavalieri's principle / tail probability formula:\n\nLet `f` be a non-negative measurable function on a sigma-finite measure space. Let `G` be an\nincreasing absolutely continuous function on the positive real line, vanishing at the origin,\nwith derivative `G' = g`. Then the integral of the composition `G ∘ f` can be written as\nthe integral over the positive real line of the \"tail measures\" `μ {ω | f(ω) > t}` of `f`\nweighted by `g`.\n\nRoughly speaking, the statement is: `∫⁻ (G ∘ f) ∂μ = ∫⁻ t in (0).. ∞, g(t) * μ {ω | f(ω) > t}`.\n\nSee `lintegral_comp_eq_lintegral_meas_le_mul` for a version with sets of the form `{ω | f(ω) ≥ t}`\ninstead. ","depth":43},{"term":"fun {α} [MeasurableSpace α] {f} μ [MeasureTheory.SigmaFinite μ] f_nn f_mble =>\n  let cst := fun x => 1;\n  let_fun cst_intble := fun x x_1 => intervalIntegrable_const;\n  let_fun key :=\n    MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul μ f_nn f_mble cst_intble\n      (Filter.eventually_of_forall fun x => zero_le_one);\n  Eq.mpr\n    (id\n      (Eq.symm\n          (Eq.mp\n            (congrArg (Eq (∫⁻ (ω : α), ENNReal.ofReal (∫ (t : ℝ) in 0 ..f ω, 1) ∂μ))\n              (congrArg (MeasureTheory.lintegral (MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Ioi 0)))\n                (funext fun t => mul_one (↑↑μ {a | t ≤ f a}))))\n            (Eq.mp\n              (congrArg (Eq (∫⁻ (ω : α), ENNReal.ofReal (∫ (t : ℝ) in 0 ..f ω, 1) ∂μ))\n                (congrArg (MeasureTheory.lintegral (MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Ioi 0)))\n                  (funext fun t => congrArg (HMul.hMul (↑↑μ {a | t ≤ f a})) ENNReal.ofReal_one)))\n              key)) ▸\n        Eq.refl (∫⁻ (ω : α), ENNReal.ofReal (f ω) ∂μ = ∫⁻ (t : ℝ) in Set.Ioi 0, ↑↑μ {a | t ≤ f a})))\n    ((fun {α} {x} μ μ_1 e_μ =>\n        Eq.rec (motive := fun μ_2 e_μ =>\n          ∀ (f f_1 : α → ENNReal), f = f_1 → MeasureTheory.lintegral μ f = MeasureTheory.lintegral μ_2 f_1)\n          (fun f f_1 e_f => e_f ▸ Eq.refl (MeasureTheory.lintegral μ f)) e_μ)\n      μ μ (Eq.refl μ) (fun ω => ENNReal.ofReal (f ω)) (fun ω => ENNReal.ofReal (∫ (t : ℝ) in 0 ..f ω, 1))\n      (funext fun ω =>\n        of_eq_true\n          (Eq.trans\n            (congrArg (Eq (ENNReal.ofReal (f ω)))\n              (congrArg ENNReal.ofReal\n                (Eq.trans\n                  (Eq.trans (intervalIntegral.integral_const 1) (congrFun (congrArg HSMul.hSMul (sub_zero (f ω))) 1))\n                  (mul_one (f ω)))))\n            (eq_self (ENNReal.ofReal (f ω))))))","name":"MeasureTheory.lintegral_eq_lintegral_meas_le","doc":"The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a sigma-finite measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `∫⁻ f ∂μ = ∫⁻ t in (0).. ∞, μ {ω | f(ω) ≥ t}`.\n\nSee `lintegral_eq_lintegral_meas_lt` for a version with sets of the form `{ω | f(ω) > t}`\ninstead. ","depth":46}],"count":4}
{"noDocExamples":[{"term":"fun {R} {A} [CommSemiring R] [Semiring A] [Algebra R A] [Star A] =>\n  Monoid.mk (_ : ∀ (f : A →⋆ₐ[R] A), StarAlgHom.comp (StarAlgHom.id R A) f = f)\n    (_ : ∀ (f : A →⋆ₐ[R] A), StarAlgHom.comp f (StarAlgHom.id R A) = f) npowRec","name":"StarAlgHom.instMonoidStarAlgHom","depth":32},{"term":"fun {R} {A} {B} [CommSemiring R] [Semiring A] [Algebra R A] [Star A] [Semiring B] [Algebra R B] [Star B] =>\n  StarAlgHomClass.mk\n    (_ : ∀ (f : A →⋆ₐ[R] B) (x : A), OneHom.toFun (↑↑↑f.toAlgHom) (star x) = star (OneHom.toFun (↑↑↑f.toAlgHom) x))","name":"StarAlgHom.instStarAlgHomClassStarAlgHom","depth":39}],"kind":"«term_→⋆ₐ[_]_»","examples":[{"term":"fun {R} {A} {B} {C} [CommSemiring R] [Semiring A] [Algebra R A] [Star A] [Semiring B] [Algebra R B] [Star B]\n    [Semiring C] [Algebra R C] [Star C] =>\n  { toFun := fun f => StarAlgHom.prod f.fst f.snd,\n    invFun := fun f => (StarAlgHom.comp (StarAlgHom.fst R B C) f, StarAlgHom.comp (StarAlgHom.snd R B C) f),\n    left_inv :=\n      (_ :\n        ∀ (f : (A →⋆ₐ[R] B) × (A →⋆ₐ[R] C)),\n          (fun f => (StarAlgHom.comp (StarAlgHom.fst R B C) f, StarAlgHom.comp (StarAlgHom.snd R B C) f))\n              ((fun f => StarAlgHom.prod f.fst f.snd) f) =\n            f),\n    right_inv :=\n      (_ :\n        ∀ (f : A →⋆ₐ[R] B × C),\n          (fun f => StarAlgHom.prod f.fst f.snd)\n              ((fun f => (StarAlgHom.comp (StarAlgHom.fst R B C) f, StarAlgHom.comp (StarAlgHom.snd R B C) f)) f) =\n            f) }","name":"StarAlgHom.prodEquiv","doc":"Taking the product of two maps with the same domain is equivalent to taking the product of\ntheir codomains. ","depth":36},{"term":"fun {R} {A} {C} [CommSemiring R] [StarRing R] [NonUnitalSemiring A] [StarRing A] [Module R A] [SMulCommClass R A A]\n    [IsScalarTower R A A] [Semiring C] [Algebra R C] [StarRing C] [StarModule R C] =>\n  {\n    toFun := fun φ =>\n      { toAlgHom := ↑Unitization.lift φ.toNonUnitalAlgHom,\n        map_star' :=\n          (_ :\n            ∀ (x : Unitization R A),\n              OneHom.toFun (↑↑↑(↑Unitization.lift φ.toNonUnitalAlgHom)) (star x) =\n                star (OneHom.toFun (↑↑↑(↑Unitization.lift φ.toNonUnitalAlgHom)) x)) },\n    invFun := fun φ =>\n      NonUnitalStarAlgHom.comp (StarAlgHom.toNonUnitalStarAlgHom φ) (Unitization.inrNonUnitalStarAlgHom R A),\n    left_inv :=\n      (_ :\n        ∀ (φ : A →⋆ₙₐ[R] C),\n          (fun φ =>\n                NonUnitalStarAlgHom.comp (StarAlgHom.toNonUnitalStarAlgHom φ) (Unitization.inrNonUnitalStarAlgHom R A))\n              ((fun φ =>\n                  { toAlgHom := ↑Unitization.lift φ.toNonUnitalAlgHom,\n                    map_star' :=\n                      (_ :\n                        ∀ (x : Unitization R A),\n                          OneHom.toFun (↑↑↑(↑Unitization.lift φ.toNonUnitalAlgHom)) (star x) =\n                            star (OneHom.toFun (↑↑↑(↑Unitization.lift φ.toNonUnitalAlgHom)) x)) })\n                φ) =\n            φ),\n    right_inv :=\n      (_ :\n        ∀ (φ : Unitization R A →⋆ₐ[R] C),\n          (fun φ =>\n                { toAlgHom := ↑Unitization.lift φ.toNonUnitalAlgHom,\n                  map_star' :=\n                    (_ :\n                      ∀ (x : Unitization R A),\n                        OneHom.toFun (↑↑↑(↑Unitization.lift φ.toNonUnitalAlgHom)) (star x) =\n                          star (OneHom.toFun (↑↑↑(↑Unitization.lift φ.toNonUnitalAlgHom)) x)) })\n              ((fun φ =>\n                  NonUnitalStarAlgHom.comp (StarAlgHom.toNonUnitalStarAlgHom φ)\n                    (Unitization.inrNonUnitalStarAlgHom R A))\n                φ) =\n            φ) }","name":"Unitization.starLift","doc":"Non-unital star algebra homomorphisms from `A` into a unital star `R`-algebra `C` lift uniquely\nto `Unitization R A →⋆ₐ[R] C`. This is the universal property of the unitization. ","depth":42}],"count":4}
{"noDocExamples":[{"term":"fun {N} {G} [Group N] [Group G] {φ} => Group.mk (_ : ∀ (a : N ⋊[φ] G), a⁻¹ * a = 1)","name":"SemidirectProduct.instGroupSemidirectProduct","depth":32}],"kind":"«term_⋊[_]_»","examples":[{"term":"fun {N} {G} [Group N] [Group G] {φ} =>\n  { toOneHom := { toFun := SemidirectProduct.right, map_one' := (_ : 1.right = 1.right) },\n    map_mul' :=\n      (_ :\n        ∀ (x x_1 : N ⋊[φ] G),\n          OneHom.toFun { toFun := SemidirectProduct.right, map_one' := (_ : 1.right = 1.right) } (x * x_1) =\n            OneHom.toFun { toFun := SemidirectProduct.right, map_one' := (_ : 1.right = 1.right) } (x * x_1)) }","name":"SemidirectProduct.rightHom","doc":"The canonical projection map `N ⋊[φ] G →* G`, as a group hom. ","depth":21},{"term":"fun {N} {G} {H} [Group N] [Group G] [Group H] {φ} f₁ f₂ h =>\n  { toOneHom := { toFun := fun a => ↑f₁ a.left * ↑f₂ a.right, map_one' := (_ : ↑f₁ 1 * ↑f₂ 1 = 1) },\n    map_mul' :=\n      (_ :\n        ∀ (a b : N ⋊[φ] G),\n          ↑f₁ (a.left * ↑(↑φ a.right) b.left) * ↑f₂ (a.right * b.right) =\n            ↑f₁ a.left * ↑f₂ a.right * (↑f₁ b.left * ↑f₂ b.right)) }","name":"SemidirectProduct.lift","doc":"Define a group hom `N ⋊[φ] G →* H`, by defining maps `N →* H` and `G →* H`  ","depth":38},{"term":"fun {N} {G} [Group N] [Group G] {φ} {N₁} {G₁} [Group N₁] [Group G₁] {φ₁} f₁ f₂ h =>\n  {\n    toOneHom :=\n      { toFun := fun x => { left := ↑f₁ x.left, right := ↑f₂ x.right },\n        map_one' := (_ : { left := ↑f₁ 1, right := ↑f₂ 1 } = 1) },\n    map_mul' :=\n      (_ :\n        ∀ (x y : N ⋊[φ] G),\n          OneHom.toFun\n              { toFun := fun x => { left := ↑f₁ x.left, right := ↑f₂ x.right },\n                map_one' := (_ : { left := ↑f₁ 1, right := ↑f₂ 1 } = 1) }\n              (x * y) =\n            OneHom.toFun\n                { toFun := fun x => { left := ↑f₁ x.left, right := ↑f₂ x.right },\n                  map_one' := (_ : { left := ↑f₁ 1, right := ↑f₂ 1 } = 1) }\n                x *\n              OneHom.toFun\n                { toFun := fun x => { left := ↑f₁ x.left, right := ↑f₂ x.right },\n                  map_one' := (_ : { left := ↑f₁ 1, right := ↑f₂ 1 } = 1) }\n                y) }","name":"SemidirectProduct.map","doc":"Define a map from `N ⋊[φ] G` to `N₁ ⋊[φ₁] G₁` given maps `N →* N₁` and `G →* G₁` that\nsatisfy a commutativity condition `∀ n g, f₁ (φ g n) = φ₁ (f₂ g) (f₁ n)`.  ","depth":39}],"count":4}
{"noDocExamples":[{"term":"fun {B} E {B'} f [(x : B) → TopologicalSpace (E x)] x =>\n  Eq.mpr (_ : TopologicalSpace ((f *ᵖ E) x) = TopologicalSpace (E (f x))) inferInstance","name":"instForAllTopologicalSpacePullback","depth":16},{"term":"fun {B} E {B'} f x => id (Bundle.Pullback._eq_1 f E x ▸ Eq.refl (TopologicalSpace ((f *ᵖ E) x)))","name":"instForAllTopologicalSpacePullback.proof_1","depth":19},{"term":"fun {B} F E {B'} [TopologicalSpace B'] [TopologicalSpace (Bundle.TotalSpace F E)] [TopologicalSpace F]\n    [TopologicalSpace B] [(x : B) → TopologicalSpace (E x)] [FiberBundle F E] {f} {x} =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrFun\n            (congrArg\n              (@Continuous ((f *ᵖ E) x) (Bundle.TotalSpace F (f *ᵖ E)) (instForAllTopologicalSpacePullback E f x))\n              (pullbackTopology_def F E f))\n            (Bundle.TotalSpace.mk x))\n          Mathlib.Topology.FiberBundle.Constructions._auxLemma.3)\n        (congrArg (LE.le (instForAllTopologicalSpacePullback E f x))\n          (Eq.trans\n            (Eq.trans induced_inf (congr (congrArg Inf.inf (Eq.trans induced_compose induced_const)) induced_compose))\n            top_inf_eq))))\n    (le_of_eq (totalSpaceMk_inducing F E (f x)).induced)","name":"Pullback.continuous_totalSpaceMk","depth":39}],"kind":"Bundle.«term_*ᵖ_»","examples":[{"term":"fun {B} {F} {E} {B'} [TopologicalSpace B'] [TopologicalSpace (Bundle.TotalSpace F E)] [TopologicalSpace F]\n    [TopologicalSpace B] [(_b : B) → Zero (E _b)] {K} [ContinuousMapClass K B' B] e f =>\n  {\n    toLocalHomeomorph :=\n      {\n        toLocalEquiv :=\n          { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n            invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n            source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n            map_source' :=\n              (_ :\n                ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                  x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                    (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n            map_target' :=\n              (_ :\n                ∀ (y : B' × F),\n                  y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                    (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                      Bundle.Pullback.lift ↑f ⁻¹' e.source),\n            left_inv' :=\n              (_ :\n                ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                  x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                    (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                        ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                      x),\n            right_inv' :=\n              (_ :\n                ∀ (x : B' × F),\n                  x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                    (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                        ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                      x) },\n        open_source :=\n          (_ :\n            IsOpen\n              { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                  invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                  source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                  map_source' :=\n                    (_ :\n                      ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                        x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                          (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                            (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                  map_target' :=\n                    (_ :\n                      ∀ (y : B' × F),\n                        y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                          (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                            Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                  left_inv' :=\n                    (_ :\n                      ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                        x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                          (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                              ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                            x),\n                  right_inv' :=\n                    (_ :\n                      ∀ (x : B' × F),\n                        x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                          (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                              ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                            x) }.source),\n        open_target := (_ : IsOpen ((↑f ⁻¹' e.baseSet) ×ˢ Set.univ)),\n        continuous_toFun :=\n          (_ :\n            ContinuousOn (fun x => (x.proj, (↑e (Bundle.Pullback.lift (↑f) x)).snd))\n              { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                  invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                  source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                  map_source' :=\n                    (_ :\n                      ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                        x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                          (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                            (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                  map_target' :=\n                    (_ :\n                      ∀ (y : B' × F),\n                        y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                          (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                            Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                  left_inv' :=\n                    (_ :\n                      ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                        x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                          (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                              ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                            x),\n                  right_inv' :=\n                    (_ :\n                      ∀ (x : B' × F),\n                        x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                          (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                              ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                            x) }.source),\n        continuous_invFun :=\n          (_ :\n            ContinuousOn\n              { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                  invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                  source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                  map_source' :=\n                    (_ :\n                      ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                        x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                          (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                            (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                  map_target' :=\n                    (_ :\n                      ∀ (y : B' × F),\n                        y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                          (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                            Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                  left_inv' :=\n                    (_ :\n                      ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                        x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                          (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                              ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                            x),\n                  right_inv' :=\n                    (_ :\n                      ∀ (x : B' × F),\n                        x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                          (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                              ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                            x) }.invFun\n              { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                  invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                  source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                  map_source' :=\n                    (_ :\n                      ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                        x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                          (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                            (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                  map_target' :=\n                    (_ :\n                      ∀ (y : B' × F),\n                        y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                          (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                            Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                  left_inv' :=\n                    (_ :\n                      ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                        x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                          (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                              ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                            x),\n                  right_inv' :=\n                    (_ :\n                      ∀ (x : B' × F),\n                        x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                          (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                              ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                            x) }.target) },\n    baseSet := ↑f ⁻¹' e.baseSet, open_baseSet := (_ : IsOpen (↑f ⁻¹' e.baseSet)),\n    source_eq :=\n      (_ :\n        {\n                toLocalEquiv :=\n                  { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                    invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                    source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                    map_source' :=\n                      (_ :\n                        ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                          x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                            (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                              (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                    map_target' :=\n                      (_ :\n                        ∀ (y : B' × F),\n                          y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                            (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                              Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                    left_inv' :=\n                      (_ :\n                        ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                          x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                            (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                              x),\n                    right_inv' :=\n                      (_ :\n                        ∀ (x : B' × F),\n                          x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                            (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                              x) },\n                open_source :=\n                  (_ :\n                    IsOpen\n                      { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                          invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                          source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                          map_source' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                    (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                          map_target' :=\n                            (_ :\n                              ∀ (y : B' × F),\n                                y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                    Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                          left_inv' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                      ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                    x),\n                          right_inv' :=\n                            (_ :\n                              ∀ (x : B' × F),\n                                x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                      ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                    x) }.source),\n                open_target := (_ : IsOpen ((↑f ⁻¹' e.baseSet) ×ˢ Set.univ)),\n                continuous_toFun :=\n                  (_ :\n                    ContinuousOn (fun x => (x.proj, (↑e (Bundle.Pullback.lift (↑f) x)).snd))\n                      { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                          invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                          source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                          map_source' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                    (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                          map_target' :=\n                            (_ :\n                              ∀ (y : B' × F),\n                                y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                    Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                          left_inv' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                      ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                    x),\n                          right_inv' :=\n                            (_ :\n                              ∀ (x : B' × F),\n                                x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                      ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                    x) }.source),\n                continuous_invFun :=\n                  (_ :\n                    ContinuousOn\n                      { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                          invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                          source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                          map_source' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                    (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                          map_target' :=\n                            (_ :\n                              ∀ (y : B' × F),\n                                y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                    Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                          left_inv' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                      ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                    x),\n                          right_inv' :=\n                            (_ :\n                              ∀ (x : B' × F),\n                                x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                      ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                    x) }.invFun\n                      { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                          invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                          source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                          map_source' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                    (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                          map_target' :=\n                            (_ :\n                              ∀ (y : B' × F),\n                                y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                    Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                          left_inv' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                      ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                    x),\n                          right_inv' :=\n                            (_ :\n                              ∀ (x : B' × F),\n                                x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                      ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                    x) }.target) }.toLocalEquiv.source =\n          Bundle.TotalSpace.proj ⁻¹' (↑f ⁻¹' e.baseSet)),\n    target_eq :=\n      (_ :\n        {\n                toLocalEquiv :=\n                  { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                    invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                    source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                    map_source' :=\n                      (_ :\n                        ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                          x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                            (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                              (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                    map_target' :=\n                      (_ :\n                        ∀ (y : B' × F),\n                          y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                            (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                              Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                    left_inv' :=\n                      (_ :\n                        ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                          x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                            (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                              x),\n                    right_inv' :=\n                      (_ :\n                        ∀ (x : B' × F),\n                          x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                            (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                              x) },\n                open_source :=\n                  (_ :\n                    IsOpen\n                      { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                          invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                          source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                          map_source' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                    (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                          map_target' :=\n                            (_ :\n                              ∀ (y : B' × F),\n                                y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                    Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                          left_inv' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                      ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                    x),\n                          right_inv' :=\n                            (_ :\n                              ∀ (x : B' × F),\n                                x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                      ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                    x) }.source),\n                open_target := (_ : IsOpen ((↑f ⁻¹' e.baseSet) ×ˢ Set.univ)),\n                continuous_toFun :=\n                  (_ :\n                    ContinuousOn (fun x => (x.proj, (↑e (Bundle.Pullback.lift (↑f) x)).snd))\n                      { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                          invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                          source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                          map_source' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                    (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                          map_target' :=\n                            (_ :\n                              ∀ (y : B' × F),\n                                y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                    Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                          left_inv' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                      ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                    x),\n                          right_inv' :=\n                            (_ :\n                              ∀ (x : B' × F),\n                                x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                      ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                    x) }.source),\n                continuous_invFun :=\n                  (_ :\n                    ContinuousOn\n                      { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                          invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                          source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                          map_source' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                    (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                          map_target' :=\n                            (_ :\n                              ∀ (y : B' × F),\n                                y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                    Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                          left_inv' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                      ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                    x),\n                          right_inv' :=\n                            (_ :\n                              ∀ (x : B' × F),\n                                x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                      ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                    x) }.invFun\n                      { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                          invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                          source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                          map_source' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                    (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                          map_target' :=\n                            (_ :\n                              ∀ (y : B' × F),\n                                y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                    Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                          left_inv' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                      ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                    x),\n                          right_inv' :=\n                            (_ :\n                              ∀ (x : B' × F),\n                                x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                      ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                    x) }.target) }.toLocalEquiv.target =\n          {\n                toLocalEquiv :=\n                  { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                    invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                    source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                    map_source' :=\n                      (_ :\n                        ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                          x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                            (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                              (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                    map_target' :=\n                      (_ :\n                        ∀ (y : B' × F),\n                          y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                            (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                              Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                    left_inv' :=\n                      (_ :\n                        ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                          x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                            (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                              x),\n                    right_inv' :=\n                      (_ :\n                        ∀ (x : B' × F),\n                          x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                            (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                              x) },\n                open_source :=\n                  (_ :\n                    IsOpen\n                      { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                          invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                          source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                          map_source' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                    (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                          map_target' :=\n                            (_ :\n                              ∀ (y : B' × F),\n                                y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                    Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                          left_inv' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                      ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                    x),\n                          right_inv' :=\n                            (_ :\n                              ∀ (x : B' × F),\n                                x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                      ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                    x) }.source),\n                open_target := (_ : IsOpen ((↑f ⁻¹' e.baseSet) ×ˢ Set.univ)),\n                continuous_toFun :=\n                  (_ :\n                    ContinuousOn (fun x => (x.proj, (↑e (Bundle.Pullback.lift (↑f) x)).snd))\n                      { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                          invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                          source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                          map_source' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                    (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                          map_target' :=\n                            (_ :\n                              ∀ (y : B' × F),\n                                y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                    Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                          left_inv' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                      ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                    x),\n                          right_inv' :=\n                            (_ :\n                              ∀ (x : B' × F),\n                                x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                      ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                    x) }.source),\n                continuous_invFun :=\n                  (_ :\n                    ContinuousOn\n                      { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                          invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                          source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                          map_source' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                    (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                          map_target' :=\n                            (_ :\n                              ∀ (y : B' × F),\n                                y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                    Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                          left_inv' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                      ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                    x),\n                          right_inv' :=\n                            (_ :\n                              ∀ (x : B' × F),\n                                x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                      ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                    x) }.invFun\n                      { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                          invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                          source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                          map_source' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                    (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                          map_target' :=\n                            (_ :\n                              ∀ (y : B' × F),\n                                y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                    Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                          left_inv' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                      ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                    x),\n                          right_inv' :=\n                            (_ :\n                              ∀ (x : B' × F),\n                                x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                      ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                    x) }.target) }.toLocalEquiv.target),\n    proj_toFun :=\n      (_ :\n        ∀ (y : Bundle.TotalSpace F (↑f *ᵖ E)),\n          y ∈\n              {\n                    toLocalEquiv :=\n                      { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                        invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                        source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                        map_source' :=\n                          (_ :\n                            ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                              x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                  (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                        map_target' :=\n                          (_ :\n                            ∀ (y : B' × F),\n                              y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                  Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                        left_inv' :=\n                          (_ :\n                            ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                              x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                    ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                  x),\n                        right_inv' :=\n                          (_ :\n                            ∀ (x : B' × F),\n                              x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                    ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                  x) },\n                    open_source :=\n                      (_ :\n                        IsOpen\n                          { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                              invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                              source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                              map_source' :=\n                                (_ :\n                                  ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                    x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                      (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                        (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                              map_target' :=\n                                (_ :\n                                  ∀ (y : B' × F),\n                                    y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                      (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                        Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                              left_inv' :=\n                                (_ :\n                                  ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                    x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                      (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                          ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                        x),\n                              right_inv' :=\n                                (_ :\n                                  ∀ (x : B' × F),\n                                    x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                      (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                          ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                            x) =\n                                        x) }.source),\n                    open_target := (_ : IsOpen ((↑f ⁻¹' e.baseSet) ×ˢ Set.univ)),\n                    continuous_toFun :=\n                      (_ :\n                        ContinuousOn (fun x => (x.proj, (↑e (Bundle.Pullback.lift (↑f) x)).snd))\n                          { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                              invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                              source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                              map_source' :=\n                                (_ :\n                                  ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                    x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                      (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                        (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                              map_target' :=\n                                (_ :\n                                  ∀ (y : B' × F),\n                                    y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                      (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                        Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                              left_inv' :=\n                                (_ :\n                                  ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                    x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                      (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                          ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                        x),\n                              right_inv' :=\n                                (_ :\n                                  ∀ (x : B' × F),\n                                    x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                      (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                          ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                            x) =\n                                        x) }.source),\n                    continuous_invFun :=\n                      (_ :\n                        ContinuousOn\n                          { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                              invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                              source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                              map_source' :=\n                                (_ :\n                                  ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                    x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                      (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                        (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                              map_target' :=\n                                (_ :\n                                  ∀ (y : B' × F),\n                                    y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                      (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                        Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                              left_inv' :=\n                                (_ :\n                                  ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                    x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                      (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                          ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                        x),\n                              right_inv' :=\n                                (_ :\n                                  ∀ (x : B' × F),\n                                    x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                      (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                          ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                            x) =\n                                        x) }.invFun\n                          { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                              invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                              source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                              map_source' :=\n                                (_ :\n                                  ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                    x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                      (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                        (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                              map_target' :=\n                                (_ :\n                                  ∀ (y : B' × F),\n                                    y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                      (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                        Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                              left_inv' :=\n                                (_ :\n                                  ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                    x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                      (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                          ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                        x),\n                              right_inv' :=\n                                (_ :\n                                  ∀ (x : B' × F),\n                                    x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                      (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                          ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                            x) =\n                                        x) }.target) }.toLocalEquiv.source →\n            (↑{\n                      toLocalEquiv :=\n                        { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                          invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                          source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                          map_source' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                    (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                          map_target' :=\n                            (_ :\n                              ∀ (y : B' × F),\n                                y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                    Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                          left_inv' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                      ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                    x),\n                          right_inv' :=\n                            (_ :\n                              ∀ (x : B' × F),\n                                x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                      ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                    x) },\n                      open_source :=\n                        (_ :\n                          IsOpen\n                            { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                                invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                                source := Bundle.Pullback.lift ↑f ⁻¹' e.source,\n                                target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                                map_source' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                          (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                                map_target' :=\n                                  (_ :\n                                    ∀ (y : B' × F),\n                                      y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                          Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                                left_inv' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                            ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                          x),\n                                right_inv' :=\n                                  (_ :\n                                    ∀ (x : B' × F),\n                                      x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                            ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                              x) =\n                                          x) }.source),\n                      open_target := (_ : IsOpen ((↑f ⁻¹' e.baseSet) ×ˢ Set.univ)),\n                      continuous_toFun :=\n                        (_ :\n                          ContinuousOn (fun x => (x.proj, (↑e (Bundle.Pullback.lift (↑f) x)).snd))\n                            { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                                invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                                source := Bundle.Pullback.lift ↑f ⁻¹' e.source,\n                                target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                                map_source' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                          (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                                map_target' :=\n                                  (_ :\n                                    ∀ (y : B' × F),\n                                      y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                          Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                                left_inv' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                            ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                          x),\n                                right_inv' :=\n                                  (_ :\n                                    ∀ (x : B' × F),\n                                      x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                            ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                              x) =\n                                          x) }.source),\n                      continuous_invFun :=\n                        (_ :\n                          ContinuousOn\n                            { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                                invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                                source := Bundle.Pullback.lift ↑f ⁻¹' e.source,\n                                target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                                map_source' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                          (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                                map_target' :=\n                                  (_ :\n                                    ∀ (y : B' × F),\n                                      y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                          Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                                left_inv' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                            ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                          x),\n                                right_inv' :=\n                                  (_ :\n                                    ∀ (x : B' × F),\n                                      x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                            ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                              x) =\n                                          x) }.invFun\n                            { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                                invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                                source := Bundle.Pullback.lift ↑f ⁻¹' e.source,\n                                target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                                map_source' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                          (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                                map_target' :=\n                                  (_ :\n                                    ∀ (y : B' × F),\n                                      y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                          Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                                left_inv' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                            ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                          x),\n                                right_inv' :=\n                                  (_ :\n                                    ∀ (x : B' × F),\n                                      x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                            ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                              x) =\n                                          x) }.target) }\n                  y).fst =\n              (↑{\n                      toLocalEquiv :=\n                        { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                          invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                          source := Bundle.Pullback.lift ↑f ⁻¹' e.source, target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                          map_source' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                    (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                          map_target' :=\n                            (_ :\n                              ∀ (y : B' × F),\n                                y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                    Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                          left_inv' :=\n                            (_ :\n                              ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                  (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                      ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                    x),\n                          right_inv' :=\n                            (_ :\n                              ∀ (x : B' × F),\n                                x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                  (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                      ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) x) =\n                                    x) },\n                      open_source :=\n                        (_ :\n                          IsOpen\n                            { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                                invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                                source := Bundle.Pullback.lift ↑f ⁻¹' e.source,\n                                target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                                map_source' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                          (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                                map_target' :=\n                                  (_ :\n                                    ∀ (y : B' × F),\n                                      y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                          Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                                left_inv' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                            ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                          x),\n                                right_inv' :=\n                                  (_ :\n                                    ∀ (x : B' × F),\n                                      x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                            ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                              x) =\n                                          x) }.source),\n                      open_target := (_ : IsOpen ((↑f ⁻¹' e.baseSet) ×ˢ Set.univ)),\n                      continuous_toFun :=\n                        (_ :\n                          ContinuousOn (fun x => (x.proj, (↑e (Bundle.Pullback.lift (↑f) x)).snd))\n                            { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                                invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                                source := Bundle.Pullback.lift ↑f ⁻¹' e.source,\n                                target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                                map_source' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                          (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                                map_target' :=\n                                  (_ :\n                                    ∀ (y : B' × F),\n                                      y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                          Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                                left_inv' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                            ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                          x),\n                                right_inv' :=\n                                  (_ :\n                                    ∀ (x : B' × F),\n                                      x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                            ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                              x) =\n                                          x) }.source),\n                      continuous_invFun :=\n                        (_ :\n                          ContinuousOn\n                            { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                                invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                                source := Bundle.Pullback.lift ↑f ⁻¹' e.source,\n                                target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                                map_source' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                          (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                                map_target' :=\n                                  (_ :\n                                    ∀ (y : B' × F),\n                                      y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                          Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                                left_inv' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                            ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                          x),\n                                right_inv' :=\n                                  (_ :\n                                    ∀ (x : B' × F),\n                                      x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                            ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                              x) =\n                                          x) }.invFun\n                            { toFun := fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd),\n                                invFun := fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd },\n                                source := Bundle.Pullback.lift ↑f ⁻¹' e.source,\n                                target := (↑f ⁻¹' e.baseSet) ×ˢ Set.univ,\n                                map_source' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x ∈\n                                          (↑f ⁻¹' e.baseSet) ×ˢ Set.univ),\n                                map_target' :=\n                                  (_ :\n                                    ∀ (y : B' × F),\n                                      y ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd }) y ∈\n                                          Bundle.Pullback.lift ↑f ⁻¹' e.source),\n                                left_inv' :=\n                                  (_ :\n                                    ∀ (x : Bundle.TotalSpace F (↑f *ᵖ E)),\n                                      x ∈ Bundle.Pullback.lift ↑f ⁻¹' e.source →\n                                        (fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                            ((fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd)) x) =\n                                          x),\n                                right_inv' :=\n                                  (_ :\n                                    ∀ (x : B' × F),\n                                      x ∈ (↑f ⁻¹' e.baseSet) ×ˢ Set.univ →\n                                        (fun z => (z.proj, (↑e (Bundle.Pullback.lift (↑f) z)).snd))\n                                            ((fun y => { proj := y.fst, snd := Trivialization.symm e (↑f y.fst) y.snd })\n                                              x) =\n                                          x) }.target) }\n                  y).fst) }","name":"Trivialization.pullback","doc":"A fiber bundle trivialization can be pulled back to a trivialization on the pullback bundle. ","depth":47}],"count":4}
{"noDocExamples":[{"term":"fun {α} {β} [TopologicalSpace α] [TopologicalSpace β] =>\n  { coe := fun h => ↑h.toEquiv, inv := fun h => ↑h.symm,\n    left_inv := (_ : ∀ (h : α ≃ₜ β), Function.LeftInverse h.invFun h.toFun),\n    right_inv := (_ : ∀ (h : α ≃ₜ β), Function.RightInverse h.invFun h.toFun),\n    coe_injective' :=\n      (_ :\n        ∀ (x x_1 : α ≃ₜ β),\n          (fun h => ↑h.toEquiv) x = (fun h => ↑h.toEquiv) x_1 →\n            (fun h => ↑h.symm) x = (fun h => ↑h.symm) x_1 → x = x_1) }","name":"Homeomorph.instEquivLikeHomeomorph","depth":17}],"kind":"«term_≃ₜ_»","examples":[{"term":"fun {X Y} =>\n  { toFun := CompHaus.homeoOfIso, invFun := CompHaus.isoOfHomeo,\n    left_inv := (_ : ∀ (f : X ≅ Y), CompHaus.isoOfHomeo (CompHaus.homeoOfIso f) = f),\n    right_inv := (_ : ∀ (f : ↑X.toTop ≃ₜ ↑Y.toTop), CompHaus.homeoOfIso (CompHaus.isoOfHomeo f) = f) }","name":"CompHaus.isoEquivHomeo","doc":"The equivalence between isomorphisms in `CompHaus` and homeomorphisms\nof topological spaces. ","depth":13},{"term":"fun {X Y} =>\n  { toFun := Profinite.homeoOfIso, invFun := Profinite.isoOfHomeo,\n    left_inv := (_ : ∀ (f : X ≅ Y), Profinite.isoOfHomeo (Profinite.homeoOfIso f) = f),\n    right_inv :=\n      (_ : ∀ (f : ↑X.toCompHaus.toTop ≃ₜ ↑Y.toCompHaus.toTop), Profinite.homeoOfIso (Profinite.isoOfHomeo f) = f) }","name":"Profinite.isoEquivHomeo","doc":"The equivalence between isomorphisms in `Profinite` and homeomorphisms\nof topological spaces. ","depth":14},{"term":"fun {X Y} =>\n  { toFun := Stonean.homeoOfIso, invFun := Stonean.isoOfHomeo,\n    left_inv := (_ : ∀ (f : X ≅ Y), Stonean.isoOfHomeo (Stonean.homeoOfIso f) = f),\n    right_inv := (_ : ∀ (f : CoeSort.coe X ≃ₜ CoeSort.coe Y), Stonean.homeoOfIso (Stonean.isoOfHomeo f) = f) }","name":"Stonean.isoEquivHomeo","doc":"The equivalence between isomorphisms in `Stonean` and homeomorphisms\nof topological spaces. ","depth":15}],"count":4}
{"noDocExamples":[{"term":"fun {X Y} {U} hU f [CategoryTheory.IsIso f] => AlgebraicGeometry.isAffineOfIso (f ∣_ U)","name":"AlgebraicGeometry.IsAffineOpen.map_isIso","depth":35},{"term":"fun {X Y} f {U V} e => e ▸ Eq.refl (CategoryTheory.Arrow.mk (f ∣_ U))","name":"AlgebraicGeometry.morphismRestrictEq.proof_5","depth":40}],"kind":"AlgebraicGeometry.«term_∣__»","examples":[{"term":"fun P {X Y} f => ∀ (U : ↑(AlgebraicGeometry.Scheme.affineOpens Y)), P (f ∣_ ↑U)","name":"AlgebraicGeometry.targetAffineLocally","doc":"For a `P : AffineTargetMorphismProperty`, `targetAffineLocally P` holds for\n`f : X ⟶ Y` whenever `P` holds for the restriction of `f` on every affine open subset of `Y`. ","depth":33},{"term":"fun {X Y} f {U V} e => CategoryTheory.eqToIso (_ : CategoryTheory.Arrow.mk (f ∣_ U) = CategoryTheory.Arrow.mk (f ∣_ V))","name":"AlgebraicGeometry.morphismRestrictEq","doc":"The restrictions onto two equal open sets are isomorphic. This currently has bad defeqs when\nunfolded, but it should not matter for now. Replace this definition if better defeqs are needed. ","depth":36}],"count":4}
{"noDocExamples":[{"term":"fun {α} {β} [MeasurableSpace α] [MeasurableSpace β] =>\n  { coe := fun e => ↑e.toEquiv, inv := fun e => ↑e.symm,\n    left_inv := (_ : ∀ (e : α ≃ᵐ β), Function.LeftInverse e.invFun e.toFun),\n    right_inv := (_ : ∀ (e : α ≃ᵐ β), Function.RightInverse e.invFun e.toFun),\n    coe_injective' :=\n      (_ :\n        ∀ (x x_1 : α ≃ᵐ β),\n          (fun e => ↑e.toEquiv) x = (fun e => ↑e.toEquiv) x_1 →\n            (fun e => ↑e.symm) x = (fun e => ↑e.symm) x_1 → x = x_1) }","name":"MeasurableEquiv.instEquivLike","depth":17},{"term":"fun {α} {β} [MeasurableSpace α] [MeasurableSpace β] ⦃a₁⦄ =>\n  MeasurableEquiv.casesOn (motive := fun x => ∀ ⦃a₂ : α ≃ᵐ β⦄, x.toEquiv = a₂.toEquiv → x = a₂) a₁\n    fun e₁ measurable_toFun measurable_invFun ⦃a₂⦄ =>\n    MeasurableEquiv.casesOn (motive := fun x =>\n      { toEquiv := e₁, measurable_toFun := measurable_toFun, measurable_invFun := measurable_invFun }.toEquiv =\n          x.toEquiv →\n        { toEquiv := e₁, measurable_toFun := measurable_toFun, measurable_invFun := measurable_invFun } = x)\n      a₂ fun e₂ measurable_toFun_1 measurable_invFun_1 a =>\n      Eq.ndrec (motive := fun e₂ =>\n        ∀ (measurable_toFun_2 : Measurable ↑e₂) (measurable_invFun_2 : Measurable ↑e₂.symm),\n          { toEquiv := e₁, measurable_toFun := measurable_toFun, measurable_invFun := measurable_invFun } =\n            { toEquiv := e₂, measurable_toFun := measurable_toFun_2, measurable_invFun := measurable_invFun_2 })\n        (fun measurable_toFun_2 measurable_invFun_2 =>\n          Eq.refl { toEquiv := e₁, measurable_toFun := measurable_toFun, measurable_invFun := measurable_invFun })\n        a measurable_toFun_1 measurable_invFun_1","name":"MeasurableEquiv.toEquiv_injective","depth":33}],"kind":"«term_≃ᵐ_»","examples":[{"term":"fun {α} [TopologicalSpace α] [PolishSpace α] [MeasurableSpace α] [BorelSpace α] h =>\n  Nonempty.some (_ : Nonempty (α ≃ᵐ (ℕ → Bool)))","name":"PolishSpace.measurableEquivNatBoolOfNotCountable","doc":"Any uncountable Polish space is Borel isomorphic to the Cantor space `ℕ → Bool`.","depth":13},{"term":"fun α [TopologicalSpace α] [MeasurableSpace α] [PolishSpace α] [BorelSpace α] =>\n  if hα : Countable α then\n    Or.casesOn (motive := fun t => finite_or_infinite α = t → ∃ s, MeasurableSet s ∧ Nonempty (α ≃ᵐ ↑s))\n      (finite_or_infinite α)\n      (fun h h_1 =>\n        Eq.symm h_1 ▸\n          Exists.casesOn (MeasureTheory.exists_nat_measurableEquiv_range_coe_fin_of_finite α) fun n h_nonempty_equiv =>\n            Exists.intro (Set.range fun x => ↑↑x)\n              {\n                left :=\n                  MeasurableEmbedding.measurableSet_range\n                    (Continuous.measurableEmbedding continuous_of_discreteTopology\n                      (Function.Injective.comp Nat.cast_injective Fin.val_injective)),\n                right := h_nonempty_equiv })\n      (fun h h_1 =>\n        Eq.symm h_1 ▸\n          Exists.intro (Set.range Nat.cast)\n            {\n              left :=\n                MeasurableEmbedding.measurableSet_range\n                  (Continuous.measurableEmbedding continuous_of_discreteTopology Nat.cast_injective),\n              right := MeasureTheory.measurableEquiv_range_coe_nat_of_infinite_of_countable α })\n      (Eq.refl (finite_or_infinite α))\n  else\n    Exists.intro Set.univ\n      { left := MeasurableSet.univ,\n        right :=\n          Nonempty.intro\n            (PolishSpace.measurableEquivOfNotCountable hα\n              (Eq.mpr (id (propext Set.countable_coe_iff ▸ Eq.refl ¬Countable ↑Set.univ))\n                Cardinal.not_countable_real)) }","name":"MeasureTheory.exists_subset_real_measurableEquiv","doc":"Any Polish Borel space is measurably equivalent to a subset of the reals. ","depth":39}],"count":4}
{"noDocExamples":[{"term":"fun {X} {Y} [PseudoEMetricSpace X] [PseudoEMetricSpace Y] =>\n  DilationEquivClass.mk\n    (_ :\n      ∀ (f : X ≃ᵈ Y),\n        ∃ r, r ≠ 0 ∧ ∀ (x y : X), edist (Equiv.toFun f.toEquiv x) (Equiv.toFun f.toEquiv y) = ↑r * edist x y)","name":"DilationEquiv.instDilationEquivClassDilationEquiv","depth":19},{"term":"fun {X} [PseudoEMetricSpace X] =>\n  Group.mk (_ : ∀ (e : X ≃ᵈ X), DilationEquiv.trans e (DilationEquiv.symm e) = DilationEquiv.refl X)","name":"DilationEquiv.instGroupDilationEquiv","depth":34}],"kind":"«term_≃ᵈ_»","examples":[{"term":"fun {X} [PseudoEMetricSpace X] =>\n  { toOneHom := { toFun := fun e => e.toEquiv, map_one' := (_ : (fun e => e.toEquiv) 1 = (fun e => e.toEquiv) 1) },\n    map_mul' :=\n      (_ :\n        ∀ (x x_1 : X ≃ᵈ X),\n          OneHom.toFun\n              { toFun := fun e => e.toEquiv, map_one' := (_ : (fun e => e.toEquiv) 1 = (fun e => e.toEquiv) 1) }\n              (x * x_1) =\n            OneHom.toFun\n              { toFun := fun e => e.toEquiv, map_one' := (_ : (fun e => e.toEquiv) 1 = (fun e => e.toEquiv) 1) }\n              (x * x_1)) }","name":"DilationEquiv.toPerm","doc":"`DilationEquiv.toEquiv` as a monoid homomorphism. ","depth":17},{"term":"fun {X} [PseudoEMetricSpace X] =>\n  { toOneHom := { toFun := Dilation.ratio, map_one' := (_ : Dilation.ratio (DilationEquiv.refl X) = 1) },\n    map_mul' :=\n      (_ :\n        ∀ (x x_1 : X ≃ᵈ X),\n          Dilation.ratio (DilationEquiv.trans x_1 x) =\n            OneHom.toFun { toFun := Dilation.ratio, map_one' := (_ : Dilation.ratio (DilationEquiv.refl X) = 1) } x *\n              OneHom.toFun { toFun := Dilation.ratio, map_one' := (_ : Dilation.ratio (DilationEquiv.refl X) = 1) }\n                x_1) }","name":"DilationEquiv.ratioHom","doc":"`Dilation.ratio` as a monoid homomorphism. ","depth":17}],"count":4}
{"noDocExamples":[{"term":"fun {β} {M} {α} [AddMonoid M] [AddAction M α] =>\n  AddAction.mk (_ : ∀ (f : α → β), 0 +ᵥ f = f) (_ : ∀ (x x_1 : Mᵈᵃᵃ) (f : α → β), x + x_1 +ᵥ f = x +ᵥ (x_1 +ᵥ f))","name":"DomAddAct.instAddActionDomAddActForAllInstAddMonoidDomAddActAddMonoid","depth":13},{"term":"fun {M} {α} {β} [MeasurableSpace M] [MeasurableSpace α] {μ} [TopologicalSpace β] [AddMonoid M] [AddAction M α]\n    [MeasurableVAdd M α] [MeasureTheory.VAddInvariantMeasure M α μ] =>\n  AddAction.mk (_ : ∀ (x : α →ₘ[μ] β), 0 +ᵥ x = x)\n    (_ : ∀ (y y_1 : Mᵈᵃᵃ) (b : α →ₘ[μ] β), y + y_1 +ᵥ b = y +ᵥ (y_1 +ᵥ b))","name":"DomAddAct.instAddActionDomAddActAEEqFunInstAddMonoidDomAddActAddMonoid","depth":24},{"term":"fun {M} {α} {E} [MeasurableSpace M] [MeasurableSpace α] [NormedAddCommGroup E] {μ} {p} [AddMonoid M] [AddAction M α]\n    [MeasureTheory.VAddInvariantMeasure M α μ] [MeasurableVAdd M α] =>\n  Function.Injective.addAction Subtype.val (_ : Function.Injective Subtype.val)\n    (_ : ∀ (x : Mᵈᵃᵃ) (x_1 : { x // x ∈ MeasureTheory.Lp E p }), ↑(x +ᵥ x_1) = ↑(x +ᵥ x_1))","name":"DomAddAct.instAddActionDomAddActSubtypeAEEqFunToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddAddCommGroupMemAddAddSubgroupInstAddAddGroupToAddAddGroupToNormedAddAddGroupToTopologicalAddAddGroupInstMembershipInstSetLikeAddAddSubgroupLpInstAddMonoidDomAddActAddMonoid","depth":36}],"kind":"«term_ᵈᵃᵃ»","examples":[],"count":3}
{"noDocExamples":[{"term":"fun {𝕜} {E} [IsROrC 𝕜] [NormedAddCommGroup E] [InnerProductSpace 𝕜 E] {ι} {U} {V} =>\n  Iff.trans Submodule.isOrtho_comm\n    (Iff.trans Submodule.isOrtho_iSup_left\n      (of_eq_true\n        (Eq.trans\n          (congrFun (congrArg Iff (forall_congr fun i => Mathlib.Analysis.InnerProductSpace.Orthogonal._auxLemma.16))\n            (∀ (i : ι), U ⟂ V i))\n          (iff_self (∀ (i : ι), U ⟂ V i)))))","name":"Submodule.isOrtho_iSup_right","depth":32},{"term":"fun {𝕜} {E} [IsROrC 𝕜] [NormedAddCommGroup E] [InnerProductSpace 𝕜 E] {U} {V} =>\n  Iff.trans Submodule.isOrtho_comm\n    (Iff.trans Submodule.isOrtho_sSup_left\n      (of_eq_true\n        (Eq.trans\n          (congrFun\n            (congrArg Iff\n              (forall_congr fun Uᵢ =>\n                implies_congr (Eq.refl (Uᵢ ∈ V)) Mathlib.Analysis.InnerProductSpace.Orthogonal._auxLemma.16))\n            (∀ (Vᵢ : Submodule 𝕜 E), Vᵢ ∈ V → U ⟂ Vᵢ))\n          (iff_self (∀ (Uᵢ : Submodule 𝕜 E), Uᵢ ∈ V → U ⟂ Uᵢ)))))","name":"Submodule.isOrtho_sSup_right","depth":38}],"kind":"Submodule.«term_⟂_»","examples":[{"term":"fun {V} {P} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n} s i =>\n  Eq.mpr\n    (id\n      (Affine.Simplex.direction_altitude s i ▸\n        Eq.refl\n          (vectorSpan ℝ (s.points '' ↑(Finset.erase Finset.univ i)) ⟂\n            AffineSubspace.direction (Affine.Simplex.altitude s i))))\n    (Submodule.IsOrtho.mono_right inf_le_left\n      (Submodule.isOrtho_orthogonal_right (vectorSpan ℝ (s.points '' ↑(Finset.erase Finset.univ i)))))","name":"Affine.Simplex.vectorSpan_isOrtho_altitude_direction","doc":"The vector span of the opposite face lies in the direction\northogonal to an altitude. ","depth":38}],"count":3}
{"noDocExamples":[{"term":"fun {α} {β} {r} {s} => EmbeddingLike.mk (_ : ∀ (f : r ≼i s), Function.Injective f.toFun)","name":"InitialSeg.instEmbeddingLikeInitialSeg","depth":16},{"term":"fun {S} hS s hs =>\n  Exists.intro (sSup {a | Ordinal.enumOrd S a ≤ s})\n    (le_antisymm\n      (Eq.mpr\n        (id\n          (Ordinal.enumOrd_def (sSup {a | Ordinal.enumOrd S a ≤ s}) ▸\n            Eq.refl (Ordinal.enumOrd S (sSup {a | Ordinal.enumOrd S a ≤ s}) ≤ s)))\n        (csInf_le'\n          { left := hs,\n            right := fun a ha =>\n              let_fun this := Eq.mpr (id (Ordinal.enumOrd_zero ▸ Eq.refl (Ordinal.enumOrd S 0 ≤ s))) (csInf_le' hs);\n              Exists.casesOn (flip exists_lt_of_lt_csSup ha (Exists.intro 0 this)) fun b h =>\n                And.casesOn h fun hb hab => LT.lt.trans_le (Ordinal.enumOrd_strictMono hS hab) hb }))\n      (Decidable.byContradiction fun h =>\n        LE.le.not_lt\n          (le_csSup\n            (Exists.intro s fun a =>\n              LE.le.trans (WellFounded.self_le_of_strictMono Ordinal.lt_wf (Ordinal.enumOrd_strictMono hS) a))\n            (Ordinal.enumOrd_succ_le hS hs\n              (Eq.mp (Mathlib.Tactic.PushNeg.not_le_eq s (Ordinal.enumOrd S (sSup {a | Ordinal.enumOrd S a ≤ s}))) h)))\n          (Order.lt_succ\n            (sSup fun a =>\n              Quot.lift\n                (fun a₁ =>\n                  Quotient.lift\n                    ((fun x x_1 =>\n                        match x with\n                        | { α := α, r := r, wo := wo } =>\n                          match x_1 with\n                          | { α := α_1, r := s, wo := wo } => Nonempty (r ≼i s))\n                      a₁)\n                    (Quotient.lift₂.proof_1\n                      (fun x x_1 =>\n                        match x with\n                        | { α := α, r := r, wo := wo } =>\n                          match x_1 with\n                          | { α := α_1, r := s, wo := wo } => Nonempty (r ≼i s))\n                      Ordinal.partialOrder.proof_1 a₁)\n                    s)\n                (Quotient.lift₂.proof_2\n                  (fun x x_1 =>\n                    match x with\n                    | { α := α, r := r, wo := wo } =>\n                      match x_1 with\n                      | { α := α_1, r := s, wo := wo } => Nonempty (r ≼i s))\n                  Ordinal.partialOrder.proof_1 s)\n                (Ordinal.enumOrd S a)))))","name":"Ordinal.enumOrd_surjective","depth":43}],"kind":"«term_≼i_»","examples":[{"term":"fun {α β} h =>\n  let_fun this :=\n    WellOrder.casesOn (motive := fun t =>\n      Quotient.out α = t →\n        Quotient.mk Ordinal.isEquivalent (Quotient.out α) ≤ Quotient.mk Ordinal.isEquivalent (Quotient.out β) →\n          (Quotient.out α).r ≼i (Quotient.out β).r)\n      (Quotient.out α)\n      (fun α_1 r wo h =>\n        Eq.ndrec (motive := fun x =>\n          Quotient.mk Ordinal.isEquivalent x ≤ Quotient.mk Ordinal.isEquivalent (Quotient.out β) →\n            x.r ≼i (Quotient.out β).r)\n          (WellOrder.casesOn (motive := fun t =>\n            Quotient.out β = t →\n              Quotient.mk Ordinal.isEquivalent { α := α_1, r := r, wo := wo } ≤\n                  Quotient.mk Ordinal.isEquivalent (Quotient.out β) →\n                { α := α_1, r := r, wo := wo }.r ≼i (Quotient.out β).r)\n            (Quotient.out β)\n            (fun α r_1 wo_1 h =>\n              Eq.ndrec (motive := fun x =>\n                Quotient.mk Ordinal.isEquivalent { α := α_1, r := r, wo := wo } ≤ Quotient.mk Ordinal.isEquivalent x →\n                  { α := α_1, r := r, wo := wo }.r ≼i x.r)\n                Classical.choice (_ : { α := α, r := r_1, wo := wo_1 } = Quotient.out β))\n            (_ : Quotient.out β = Quotient.out β))\n          (_ : { α := α_1, r := r, wo := wo } = Quotient.out α))\n      (_ : Quotient.out α = Quotient.out α)\n      (_ : Quotient.mk Ordinal.isEquivalent (Quotient.out α) ≤ Quotient.mk Ordinal.isEquivalent (Quotient.out β));\n  this","name":"Ordinal.initialSegOut","doc":"Given two ordinals `α ≤ β`, then `initialSegOut α β` is the initial segment embedding\nof `α` to `β`, as map from a model type for `α` to a model type for `β`. ","depth":35}],"count":3}
{"noDocExamples":[{"term":"fun {α} [Primcodable α] [Inhabited α] {β} [Primcodable β] [Inhabited β] p q =>\n  of_eq_true\n    (Eq.trans\n      (congrFun\n        (congrArg Iff\n          (congr (congrArg And Mathlib.Computability.Reduce._auxLemma.4) Mathlib.Computability.Reduce._auxLemma.4))\n        (p ≤₀ q ∧ q ≤₀ p))\n      (iff_self (p ≤₀ q ∧ q ≤₀ p)))","name":"manyOneEquiv_toNat","depth":27}],"kind":"«term_≤₀_»","examples":[{"term":"{ le := fun d₁ d₂ => ManyOneDegree.liftOn₂ d₁ d₂ (fun x x_1 => x ≤₀ x_1) ManyOneDegree.instLE.proof_1 }","name":"ManyOneDegree.instLE","doc":"For many-one degrees `d₁` and `d₂`, `d₁ ≤ d₂` if the sets in `d₁` are many-one reducible to the\nsets in `d₂`.\n","depth":13},{"term":"fun {α} {β} [Primcodable α] [Primcodable β] p q => p ≤₀ q ∧ q ≤₀ p","name":"ManyOneEquiv","doc":"`p` and `q` are many-one equivalent if each one is many-one reducible to the other. ","depth":14}],"count":3}
{"noDocExamples":[{"term":"fun {R} {L₁} {L₂} [CommRing R] [LieRing L₁] [LieAlgebra R L₁] [LieRing L₂] [LieAlgebra R L₂] =>\n  { coe := fun f => f.toFun,\n    coe_injective' := (_ : ∀ (x y : L₁ →ₗ⁅R⁆ L₂), (fun f => f.toFun) x = (fun f => f.toFun) y → x = y) }","name":"LieHom.instFunLikeLieHom","depth":25}],"kind":"«term_→ₗ⁅_⁆_»","examples":[{"term":"fun R L [CommRing R] [LieRing L] [LieAlgebra R L] => L →ₗ⁅R⁆ R","name":"LieAlgebra.LieCharacter","doc":"A character of a Lie algebra is a morphism to the scalars. ","depth":13},{"term":"fun R {X} [CommRing R] {L} [LieRing L] [LieAlgebra R L] =>\n  {\n    toFun := fun f =>\n      {\n        toLinearMap :=\n          {\n            toAddHom :=\n              {\n                toFun := fun c =>\n                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                    (_ :\n                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                        FreeLieAlgebra.Rel R X a b → ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                map_add' :=\n                  (_ :\n                    ∀ (x y : FreeLieAlgebra R X),\n                      (fun c =>\n                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                              (_ :\n                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                  FreeLieAlgebra.Rel R X a b →\n                                    ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                          (x + y) =\n                        (fun c =>\n                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                (_ :\n                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                    FreeLieAlgebra.Rel R X a b →\n                                      ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                            x +\n                          (fun c =>\n                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                (_ :\n                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                    FreeLieAlgebra.Rel R X a b →\n                                      ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                            y) },\n            map_smul' :=\n              (_ :\n                ∀ (t : R) (x : FreeLieAlgebra R X),\n                  AddHom.toFun\n                      {\n                        toFun := fun c =>\n                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                            (_ :\n                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                FreeLieAlgebra.Rel R X a b →\n                                  ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                        map_add' :=\n                          (_ :\n                            ∀ (x y : FreeLieAlgebra R X),\n                              (fun c =>\n                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                      (_ :\n                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                          FreeLieAlgebra.Rel R X a b →\n                                            ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                  (x + y) =\n                                (fun c =>\n                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                        (_ :\n                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                            FreeLieAlgebra.Rel R X a b →\n                                              ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                    x +\n                                  (fun c =>\n                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                        (_ :\n                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                            FreeLieAlgebra.Rel R X a b →\n                                              ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                    y) }\n                      (t • x) =\n                    ↑(RingHom.id R) t •\n                      AddHom.toFun\n                        {\n                          toFun := fun c =>\n                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                              (_ :\n                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                  FreeLieAlgebra.Rel R X a b →\n                                    ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                          map_add' :=\n                            (_ :\n                              ∀ (x y : FreeLieAlgebra R X),\n                                (fun c =>\n                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                        (_ :\n                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                            FreeLieAlgebra.Rel R X a b →\n                                              ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                    (x + y) =\n                                  (fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                      x +\n                                    (fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                      y) }\n                        x) },\n        map_lie' :=\n          (_ :\n            ∀ {x y : FreeLieAlgebra R X},\n              AddHom.toFun\n                  {\n                      toAddHom :=\n                        {\n                          toFun := fun c =>\n                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                              (_ :\n                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                  FreeLieAlgebra.Rel R X a b →\n                                    ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                          map_add' :=\n                            (_ :\n                              ∀ (x y : FreeLieAlgebra R X),\n                                (fun c =>\n                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                        (_ :\n                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                            FreeLieAlgebra.Rel R X a b →\n                                              ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                    (x + y) =\n                                  (fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                      x +\n                                    (fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                      y) },\n                      map_smul' :=\n                        (_ :\n                          ∀ (t : R) (x : FreeLieAlgebra R X),\n                            AddHom.toFun\n                                {\n                                  toFun := fun c =>\n                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                      (_ :\n                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                          FreeLieAlgebra.Rel R X a b →\n                                            ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                  map_add' :=\n                                    (_ :\n                                      ∀ (x y : FreeLieAlgebra R X),\n                                        (fun c =>\n                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                (_ :\n                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                    FreeLieAlgebra.Rel R X a b →\n                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                        ↑(FreeLieAlgebra.liftAux R f) b))\n                                            (x + y) =\n                                          (fun c =>\n                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                  (_ :\n                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                      FreeLieAlgebra.Rel R X a b →\n                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                          ↑(FreeLieAlgebra.liftAux R f) b))\n                                              x +\n                                            (fun c =>\n                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                  (_ :\n                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                      FreeLieAlgebra.Rel R X a b →\n                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                          ↑(FreeLieAlgebra.liftAux R f) b))\n                                              y) }\n                                (t • x) =\n                              ↑(RingHom.id R) t •\n                                AddHom.toFun\n                                  {\n                                    toFun := fun c =>\n                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                        (_ :\n                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                            FreeLieAlgebra.Rel R X a b →\n                                              ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                    map_add' :=\n                                      (_ :\n                                        ∀ (x y : FreeLieAlgebra R X),\n                                          (fun c =>\n                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                  (_ :\n                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                      FreeLieAlgebra.Rel R X a b →\n                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                          ↑(FreeLieAlgebra.liftAux R f) b))\n                                              (x + y) =\n                                            (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                x +\n                                              (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                y) }\n                                  x) }.toAddHom\n                  ⁅x, y⁆ =\n                ⁅AddHom.toFun\n                    {\n                        toAddHom :=\n                          {\n                            toFun := fun c =>\n                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                (_ :\n                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                    FreeLieAlgebra.Rel R X a b →\n                                      ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                            map_add' :=\n                              (_ :\n                                ∀ (x y : FreeLieAlgebra R X),\n                                  (fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                      (x + y) =\n                                    (fun c =>\n                                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                            (_ :\n                                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                FreeLieAlgebra.Rel R X a b →\n                                                  ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                        x +\n                                      (fun c =>\n                                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                            (_ :\n                                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                FreeLieAlgebra.Rel R X a b →\n                                                  ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                        y) },\n                        map_smul' :=\n                          (_ :\n                            ∀ (t : R) (x : FreeLieAlgebra R X),\n                              AddHom.toFun\n                                  {\n                                    toFun := fun c =>\n                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                        (_ :\n                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                            FreeLieAlgebra.Rel R X a b →\n                                              ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                    map_add' :=\n                                      (_ :\n                                        ∀ (x y : FreeLieAlgebra R X),\n                                          (fun c =>\n                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                  (_ :\n                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                      FreeLieAlgebra.Rel R X a b →\n                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                          ↑(FreeLieAlgebra.liftAux R f) b))\n                                              (x + y) =\n                                            (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                x +\n                                              (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                y) }\n                                  (t • x) =\n                                ↑(RingHom.id R) t •\n                                  AddHom.toFun\n                                    {\n                                      toFun := fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                      map_add' :=\n                                        (_ :\n                                          ∀ (x y : FreeLieAlgebra R X),\n                                            (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                (x + y) =\n                                              (fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b))\n                                                  x +\n                                                (fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b))\n                                                  y) }\n                                    x) }.toAddHom\n                    x,\n                  AddHom.toFun\n                    {\n                        toAddHom :=\n                          {\n                            toFun := fun c =>\n                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                (_ :\n                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                    FreeLieAlgebra.Rel R X a b →\n                                      ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                            map_add' :=\n                              (_ :\n                                ∀ (x y : FreeLieAlgebra R X),\n                                  (fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                      (x + y) =\n                                    (fun c =>\n                                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                            (_ :\n                                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                FreeLieAlgebra.Rel R X a b →\n                                                  ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                        x +\n                                      (fun c =>\n                                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                            (_ :\n                                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                FreeLieAlgebra.Rel R X a b →\n                                                  ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                        y) },\n                        map_smul' :=\n                          (_ :\n                            ∀ (t : R) (x : FreeLieAlgebra R X),\n                              AddHom.toFun\n                                  {\n                                    toFun := fun c =>\n                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                        (_ :\n                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                            FreeLieAlgebra.Rel R X a b →\n                                              ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                    map_add' :=\n                                      (_ :\n                                        ∀ (x y : FreeLieAlgebra R X),\n                                          (fun c =>\n                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                  (_ :\n                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                      FreeLieAlgebra.Rel R X a b →\n                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                          ↑(FreeLieAlgebra.liftAux R f) b))\n                                              (x + y) =\n                                            (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                x +\n                                              (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                y) }\n                                  (t • x) =\n                                ↑(RingHom.id R) t •\n                                  AddHom.toFun\n                                    {\n                                      toFun := fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                      map_add' :=\n                                        (_ :\n                                          ∀ (x y : FreeLieAlgebra R X),\n                                            (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                (x + y) =\n                                              (fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b))\n                                                  x +\n                                                (fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b))\n                                                  y) }\n                                    x) }.toAddHom\n                    y⁆) },\n    invFun := fun F => ↑F ∘ FreeLieAlgebra.of R,\n    left_inv :=\n      (_ :\n        ∀ (f : X → L),\n          (fun F => ↑F ∘ FreeLieAlgebra.of R)\n              ((fun f =>\n                  {\n                    toLinearMap :=\n                      {\n                        toAddHom :=\n                          {\n                            toFun := fun c =>\n                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                (_ :\n                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                    FreeLieAlgebra.Rel R X a b →\n                                      ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                            map_add' :=\n                              (_ :\n                                ∀ (x y : FreeLieAlgebra R X),\n                                  (fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                      (x + y) =\n                                    (fun c =>\n                                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                            (_ :\n                                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                FreeLieAlgebra.Rel R X a b →\n                                                  ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                        x +\n                                      (fun c =>\n                                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                            (_ :\n                                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                FreeLieAlgebra.Rel R X a b →\n                                                  ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                        y) },\n                        map_smul' :=\n                          (_ :\n                            ∀ (t : R) (x : FreeLieAlgebra R X),\n                              AddHom.toFun\n                                  {\n                                    toFun := fun c =>\n                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                        (_ :\n                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                            FreeLieAlgebra.Rel R X a b →\n                                              ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                    map_add' :=\n                                      (_ :\n                                        ∀ (x y : FreeLieAlgebra R X),\n                                          (fun c =>\n                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                  (_ :\n                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                      FreeLieAlgebra.Rel R X a b →\n                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                          ↑(FreeLieAlgebra.liftAux R f) b))\n                                              (x + y) =\n                                            (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                x +\n                                              (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                y) }\n                                  (t • x) =\n                                ↑(RingHom.id R) t •\n                                  AddHom.toFun\n                                    {\n                                      toFun := fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                      map_add' :=\n                                        (_ :\n                                          ∀ (x y : FreeLieAlgebra R X),\n                                            (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                (x + y) =\n                                              (fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b))\n                                                  x +\n                                                (fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b))\n                                                  y) }\n                                    x) },\n                    map_lie' :=\n                      (_ :\n                        ∀ {x y : FreeLieAlgebra R X},\n                          AddHom.toFun\n                              {\n                                  toAddHom :=\n                                    {\n                                      toFun := fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                      map_add' :=\n                                        (_ :\n                                          ∀ (x y : FreeLieAlgebra R X),\n                                            (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                (x + y) =\n                                              (fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b))\n                                                  x +\n                                                (fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b))\n                                                  y) },\n                                  map_smul' :=\n                                    (_ :\n                                      ∀ (t : R) (x : FreeLieAlgebra R X),\n                                        AddHom.toFun\n                                            {\n                                              toFun := fun c =>\n                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                  (_ :\n                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                      FreeLieAlgebra.Rel R X a b →\n                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                          ↑(FreeLieAlgebra.liftAux R f) b),\n                                              map_add' :=\n                                                (_ :\n                                                  ∀ (x y : FreeLieAlgebra R X),\n                                                    (fun c =>\n                                                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                            (_ :\n                                                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                FreeLieAlgebra.Rel R X a b →\n                                                                  ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                    ↑(FreeLieAlgebra.liftAux R f) b))\n                                                        (x + y) =\n                                                      (fun c =>\n                                                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                              (_ :\n                                                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                  FreeLieAlgebra.Rel R X a b →\n                                                                    ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                      ↑(FreeLieAlgebra.liftAux R f) b))\n                                                          x +\n                                                        (fun c =>\n                                                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                              (_ :\n                                                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                  FreeLieAlgebra.Rel R X a b →\n                                                                    ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                      ↑(FreeLieAlgebra.liftAux R f) b))\n                                                          y) }\n                                            (t • x) =\n                                          ↑(RingHom.id R) t •\n                                            AddHom.toFun\n                                              {\n                                                toFun := fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b),\n                                                map_add' :=\n                                                  (_ :\n                                                    ∀ (x y : FreeLieAlgebra R X),\n                                                      (fun c =>\n                                                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                              (_ :\n                                                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                  FreeLieAlgebra.Rel R X a b →\n                                                                    ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                      ↑(FreeLieAlgebra.liftAux R f) b))\n                                                          (x + y) =\n                                                        (fun c =>\n                                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                (_ :\n                                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                    FreeLieAlgebra.Rel R X a b →\n                                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                        ↑(FreeLieAlgebra.liftAux R f) b))\n                                                            x +\n                                                          (fun c =>\n                                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                (_ :\n                                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                    FreeLieAlgebra.Rel R X a b →\n                                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                        ↑(FreeLieAlgebra.liftAux R f) b))\n                                                            y) }\n                                              x) }.toAddHom\n                              ⁅x, y⁆ =\n                            ⁅AddHom.toFun\n                                {\n                                    toAddHom :=\n                                      {\n                                        toFun := fun c =>\n                                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                            (_ :\n                                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                FreeLieAlgebra.Rel R X a b →\n                                                  ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                        map_add' :=\n                                          (_ :\n                                            ∀ (x y : FreeLieAlgebra R X),\n                                              (fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b))\n                                                  (x + y) =\n                                                (fun c =>\n                                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                        (_ :\n                                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                            FreeLieAlgebra.Rel R X a b →\n                                                              ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                ↑(FreeLieAlgebra.liftAux R f) b))\n                                                    x +\n                                                  (fun c =>\n                                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                        (_ :\n                                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                            FreeLieAlgebra.Rel R X a b →\n                                                              ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                ↑(FreeLieAlgebra.liftAux R f) b))\n                                                    y) },\n                                    map_smul' :=\n                                      (_ :\n                                        ∀ (t : R) (x : FreeLieAlgebra R X),\n                                          AddHom.toFun\n                                              {\n                                                toFun := fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b),\n                                                map_add' :=\n                                                  (_ :\n                                                    ∀ (x y : FreeLieAlgebra R X),\n                                                      (fun c =>\n                                                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                              (_ :\n                                                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                  FreeLieAlgebra.Rel R X a b →\n                                                                    ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                      ↑(FreeLieAlgebra.liftAux R f) b))\n                                                          (x + y) =\n                                                        (fun c =>\n                                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                (_ :\n                                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                    FreeLieAlgebra.Rel R X a b →\n                                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                        ↑(FreeLieAlgebra.liftAux R f) b))\n                                                            x +\n                                                          (fun c =>\n                                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                (_ :\n                                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                    FreeLieAlgebra.Rel R X a b →\n                                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                        ↑(FreeLieAlgebra.liftAux R f) b))\n                                                            y) }\n                                              (t • x) =\n                                            ↑(RingHom.id R) t •\n                                              AddHom.toFun\n                                                {\n                                                  toFun := fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b),\n                                                  map_add' :=\n                                                    (_ :\n                                                      ∀ (x y : FreeLieAlgebra R X),\n                                                        (fun c =>\n                                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                (_ :\n                                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                    FreeLieAlgebra.Rel R X a b →\n                                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                        ↑(FreeLieAlgebra.liftAux R f) b))\n                                                            (x + y) =\n                                                          (fun c =>\n                                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                  (_ :\n                                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                      FreeLieAlgebra.Rel R X a b →\n                                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                          ↑(FreeLieAlgebra.liftAux R f) b))\n                                                              x +\n                                                            (fun c =>\n                                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                  (_ :\n                                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                      FreeLieAlgebra.Rel R X a b →\n                                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                          ↑(FreeLieAlgebra.liftAux R f) b))\n                                                              y) }\n                                                x) }.toAddHom\n                                x,\n                              AddHom.toFun\n                                {\n                                    toAddHom :=\n                                      {\n                                        toFun := fun c =>\n                                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                            (_ :\n                                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                FreeLieAlgebra.Rel R X a b →\n                                                  ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                        map_add' :=\n                                          (_ :\n                                            ∀ (x y : FreeLieAlgebra R X),\n                                              (fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b))\n                                                  (x + y) =\n                                                (fun c =>\n                                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                        (_ :\n                                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                            FreeLieAlgebra.Rel R X a b →\n                                                              ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                ↑(FreeLieAlgebra.liftAux R f) b))\n                                                    x +\n                                                  (fun c =>\n                                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                        (_ :\n                                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                            FreeLieAlgebra.Rel R X a b →\n                                                              ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                ↑(FreeLieAlgebra.liftAux R f) b))\n                                                    y) },\n                                    map_smul' :=\n                                      (_ :\n                                        ∀ (t : R) (x : FreeLieAlgebra R X),\n                                          AddHom.toFun\n                                              {\n                                                toFun := fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b),\n                                                map_add' :=\n                                                  (_ :\n                                                    ∀ (x y : FreeLieAlgebra R X),\n                                                      (fun c =>\n                                                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                              (_ :\n                                                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                  FreeLieAlgebra.Rel R X a b →\n                                                                    ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                      ↑(FreeLieAlgebra.liftAux R f) b))\n                                                          (x + y) =\n                                                        (fun c =>\n                                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                (_ :\n                                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                    FreeLieAlgebra.Rel R X a b →\n                                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                        ↑(FreeLieAlgebra.liftAux R f) b))\n                                                            x +\n                                                          (fun c =>\n                                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                (_ :\n                                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                    FreeLieAlgebra.Rel R X a b →\n                                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                        ↑(FreeLieAlgebra.liftAux R f) b))\n                                                            y) }\n                                              (t • x) =\n                                            ↑(RingHom.id R) t •\n                                              AddHom.toFun\n                                                {\n                                                  toFun := fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b),\n                                                  map_add' :=\n                                                    (_ :\n                                                      ∀ (x y : FreeLieAlgebra R X),\n                                                        (fun c =>\n                                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                (_ :\n                                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                    FreeLieAlgebra.Rel R X a b →\n                                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                        ↑(FreeLieAlgebra.liftAux R f) b))\n                                                            (x + y) =\n                                                          (fun c =>\n                                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                  (_ :\n                                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                      FreeLieAlgebra.Rel R X a b →\n                                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                          ↑(FreeLieAlgebra.liftAux R f) b))\n                                                              x +\n                                                            (fun c =>\n                                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                  (_ :\n                                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                      FreeLieAlgebra.Rel R X a b →\n                                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                          ↑(FreeLieAlgebra.liftAux R f) b))\n                                                              y) }\n                                                x) }.toAddHom\n                                y⁆) })\n                f) =\n            f),\n    right_inv :=\n      (_ :\n        ∀ (F : FreeLieAlgebra R X →ₗ⁅R⁆ L),\n          (fun f =>\n                {\n                  toLinearMap :=\n                    {\n                      toAddHom :=\n                        {\n                          toFun := fun c =>\n                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                              (_ :\n                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                  FreeLieAlgebra.Rel R X a b →\n                                    ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                          map_add' :=\n                            (_ :\n                              ∀ (x y : FreeLieAlgebra R X),\n                                (fun c =>\n                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                        (_ :\n                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                            FreeLieAlgebra.Rel R X a b →\n                                              ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                    (x + y) =\n                                  (fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                      x +\n                                    (fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b))\n                                      y) },\n                      map_smul' :=\n                        (_ :\n                          ∀ (t : R) (x : FreeLieAlgebra R X),\n                            AddHom.toFun\n                                {\n                                  toFun := fun c =>\n                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                      (_ :\n                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                          FreeLieAlgebra.Rel R X a b →\n                                            ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                  map_add' :=\n                                    (_ :\n                                      ∀ (x y : FreeLieAlgebra R X),\n                                        (fun c =>\n                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                (_ :\n                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                    FreeLieAlgebra.Rel R X a b →\n                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                        ↑(FreeLieAlgebra.liftAux R f) b))\n                                            (x + y) =\n                                          (fun c =>\n                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                  (_ :\n                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                      FreeLieAlgebra.Rel R X a b →\n                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                          ↑(FreeLieAlgebra.liftAux R f) b))\n                                              x +\n                                            (fun c =>\n                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                  (_ :\n                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                      FreeLieAlgebra.Rel R X a b →\n                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                          ↑(FreeLieAlgebra.liftAux R f) b))\n                                              y) }\n                                (t • x) =\n                              ↑(RingHom.id R) t •\n                                AddHom.toFun\n                                  {\n                                    toFun := fun c =>\n                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                        (_ :\n                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                            FreeLieAlgebra.Rel R X a b →\n                                              ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                    map_add' :=\n                                      (_ :\n                                        ∀ (x y : FreeLieAlgebra R X),\n                                          (fun c =>\n                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                  (_ :\n                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                      FreeLieAlgebra.Rel R X a b →\n                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                          ↑(FreeLieAlgebra.liftAux R f) b))\n                                              (x + y) =\n                                            (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                x +\n                                              (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                y) }\n                                  x) },\n                  map_lie' :=\n                    (_ :\n                      ∀ {x y : FreeLieAlgebra R X},\n                        AddHom.toFun\n                            {\n                                toAddHom :=\n                                  {\n                                    toFun := fun c =>\n                                      Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                        (_ :\n                                          ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                            FreeLieAlgebra.Rel R X a b →\n                                              ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                    map_add' :=\n                                      (_ :\n                                        ∀ (x y : FreeLieAlgebra R X),\n                                          (fun c =>\n                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                  (_ :\n                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                      FreeLieAlgebra.Rel R X a b →\n                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                          ↑(FreeLieAlgebra.liftAux R f) b))\n                                              (x + y) =\n                                            (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                x +\n                                              (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                y) },\n                                map_smul' :=\n                                  (_ :\n                                    ∀ (t : R) (x : FreeLieAlgebra R X),\n                                      AddHom.toFun\n                                          {\n                                            toFun := fun c =>\n                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                (_ :\n                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                    FreeLieAlgebra.Rel R X a b →\n                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                        ↑(FreeLieAlgebra.liftAux R f) b),\n                                            map_add' :=\n                                              (_ :\n                                                ∀ (x y : FreeLieAlgebra R X),\n                                                  (fun c =>\n                                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                          (_ :\n                                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                              FreeLieAlgebra.Rel R X a b →\n                                                                ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                  ↑(FreeLieAlgebra.liftAux R f) b))\n                                                      (x + y) =\n                                                    (fun c =>\n                                                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                            (_ :\n                                                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                FreeLieAlgebra.Rel R X a b →\n                                                                  ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                    ↑(FreeLieAlgebra.liftAux R f) b))\n                                                        x +\n                                                      (fun c =>\n                                                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                            (_ :\n                                                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                FreeLieAlgebra.Rel R X a b →\n                                                                  ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                    ↑(FreeLieAlgebra.liftAux R f) b))\n                                                        y) }\n                                          (t • x) =\n                                        ↑(RingHom.id R) t •\n                                          AddHom.toFun\n                                            {\n                                              toFun := fun c =>\n                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                  (_ :\n                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                      FreeLieAlgebra.Rel R X a b →\n                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                          ↑(FreeLieAlgebra.liftAux R f) b),\n                                              map_add' :=\n                                                (_ :\n                                                  ∀ (x y : FreeLieAlgebra R X),\n                                                    (fun c =>\n                                                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                            (_ :\n                                                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                FreeLieAlgebra.Rel R X a b →\n                                                                  ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                    ↑(FreeLieAlgebra.liftAux R f) b))\n                                                        (x + y) =\n                                                      (fun c =>\n                                                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                              (_ :\n                                                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                  FreeLieAlgebra.Rel R X a b →\n                                                                    ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                      ↑(FreeLieAlgebra.liftAux R f) b))\n                                                          x +\n                                                        (fun c =>\n                                                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                              (_ :\n                                                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                  FreeLieAlgebra.Rel R X a b →\n                                                                    ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                      ↑(FreeLieAlgebra.liftAux R f) b))\n                                                          y) }\n                                            x) }.toAddHom\n                            ⁅x, y⁆ =\n                          ⁅AddHom.toFun\n                              {\n                                  toAddHom :=\n                                    {\n                                      toFun := fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                      map_add' :=\n                                        (_ :\n                                          ∀ (x y : FreeLieAlgebra R X),\n                                            (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                (x + y) =\n                                              (fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b))\n                                                  x +\n                                                (fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b))\n                                                  y) },\n                                  map_smul' :=\n                                    (_ :\n                                      ∀ (t : R) (x : FreeLieAlgebra R X),\n                                        AddHom.toFun\n                                            {\n                                              toFun := fun c =>\n                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                  (_ :\n                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                      FreeLieAlgebra.Rel R X a b →\n                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                          ↑(FreeLieAlgebra.liftAux R f) b),\n                                              map_add' :=\n                                                (_ :\n                                                  ∀ (x y : FreeLieAlgebra R X),\n                                                    (fun c =>\n                                                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                            (_ :\n                                                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                FreeLieAlgebra.Rel R X a b →\n                                                                  ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                    ↑(FreeLieAlgebra.liftAux R f) b))\n                                                        (x + y) =\n                                                      (fun c =>\n                                                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                              (_ :\n                                                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                  FreeLieAlgebra.Rel R X a b →\n                                                                    ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                      ↑(FreeLieAlgebra.liftAux R f) b))\n                                                          x +\n                                                        (fun c =>\n                                                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                              (_ :\n                                                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                  FreeLieAlgebra.Rel R X a b →\n                                                                    ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                      ↑(FreeLieAlgebra.liftAux R f) b))\n                                                          y) }\n                                            (t • x) =\n                                          ↑(RingHom.id R) t •\n                                            AddHom.toFun\n                                              {\n                                                toFun := fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b),\n                                                map_add' :=\n                                                  (_ :\n                                                    ∀ (x y : FreeLieAlgebra R X),\n                                                      (fun c =>\n                                                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                              (_ :\n                                                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                  FreeLieAlgebra.Rel R X a b →\n                                                                    ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                      ↑(FreeLieAlgebra.liftAux R f) b))\n                                                          (x + y) =\n                                                        (fun c =>\n                                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                (_ :\n                                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                    FreeLieAlgebra.Rel R X a b →\n                                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                        ↑(FreeLieAlgebra.liftAux R f) b))\n                                                            x +\n                                                          (fun c =>\n                                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                (_ :\n                                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                    FreeLieAlgebra.Rel R X a b →\n                                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                        ↑(FreeLieAlgebra.liftAux R f) b))\n                                                            y) }\n                                              x) }.toAddHom\n                              x,\n                            AddHom.toFun\n                              {\n                                  toAddHom :=\n                                    {\n                                      toFun := fun c =>\n                                        Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                          (_ :\n                                            ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                              FreeLieAlgebra.Rel R X a b →\n                                                ↑(FreeLieAlgebra.liftAux R f) a = ↑(FreeLieAlgebra.liftAux R f) b),\n                                      map_add' :=\n                                        (_ :\n                                          ∀ (x y : FreeLieAlgebra R X),\n                                            (fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b))\n                                                (x + y) =\n                                              (fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b))\n                                                  x +\n                                                (fun c =>\n                                                    Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                      (_ :\n                                                        ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                          FreeLieAlgebra.Rel R X a b →\n                                                            ↑(FreeLieAlgebra.liftAux R f) a =\n                                                              ↑(FreeLieAlgebra.liftAux R f) b))\n                                                  y) },\n                                  map_smul' :=\n                                    (_ :\n                                      ∀ (t : R) (x : FreeLieAlgebra R X),\n                                        AddHom.toFun\n                                            {\n                                              toFun := fun c =>\n                                                Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                  (_ :\n                                                    ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                      FreeLieAlgebra.Rel R X a b →\n                                                        ↑(FreeLieAlgebra.liftAux R f) a =\n                                                          ↑(FreeLieAlgebra.liftAux R f) b),\n                                              map_add' :=\n                                                (_ :\n                                                  ∀ (x y : FreeLieAlgebra R X),\n                                                    (fun c =>\n                                                          Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                            (_ :\n                                                              ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                FreeLieAlgebra.Rel R X a b →\n                                                                  ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                    ↑(FreeLieAlgebra.liftAux R f) b))\n                                                        (x + y) =\n                                                      (fun c =>\n                                                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                              (_ :\n                                                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                  FreeLieAlgebra.Rel R X a b →\n                                                                    ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                      ↑(FreeLieAlgebra.liftAux R f) b))\n                                                          x +\n                                                        (fun c =>\n                                                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                              (_ :\n                                                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                  FreeLieAlgebra.Rel R X a b →\n                                                                    ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                      ↑(FreeLieAlgebra.liftAux R f) b))\n                                                          y) }\n                                            (t • x) =\n                                          ↑(RingHom.id R) t •\n                                            AddHom.toFun\n                                              {\n                                                toFun := fun c =>\n                                                  Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                    (_ :\n                                                      ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                        FreeLieAlgebra.Rel R X a b →\n                                                          ↑(FreeLieAlgebra.liftAux R f) a =\n                                                            ↑(FreeLieAlgebra.liftAux R f) b),\n                                                map_add' :=\n                                                  (_ :\n                                                    ∀ (x y : FreeLieAlgebra R X),\n                                                      (fun c =>\n                                                            Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                              (_ :\n                                                                ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                  FreeLieAlgebra.Rel R X a b →\n                                                                    ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                      ↑(FreeLieAlgebra.liftAux R f) b))\n                                                          (x + y) =\n                                                        (fun c =>\n                                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                (_ :\n                                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                    FreeLieAlgebra.Rel R X a b →\n                                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                        ↑(FreeLieAlgebra.liftAux R f) b))\n                                                            x +\n                                                          (fun c =>\n                                                              Quot.liftOn c ↑(FreeLieAlgebra.liftAux R f)\n                                                                (_ :\n                                                                  ∀ (a b : FreeNonUnitalNonAssocAlgebra R X),\n                                                                    FreeLieAlgebra.Rel R X a b →\n                                                                      ↑(FreeLieAlgebra.liftAux R f) a =\n                                                                        ↑(FreeLieAlgebra.liftAux R f) b))\n                                                            y) }\n                                              x) }.toAddHom\n                              y⁆) })\n              ((fun F => ↑F ∘ FreeLieAlgebra.of R) F) =\n            F) }","name":"FreeLieAlgebra.lift","doc":"The functor `X ↦ FreeLieAlgebra R X` from the category of types to the category of Lie\nalgebras over `R` is adjoint to the forgetful functor in the other direction. ","depth":39}],"count":3}
{"noDocExamples":[{"term":"fun {α} {β} [PseudoEMetricSpace α] [PseudoEMetricSpace β] =>\n  DilationClass.mk\n    (_ : ∀ (f : α →ᵈ β), ∃ r, r ≠ 0 ∧ ∀ (x y : α), edist (Dilation.toFun f x) (Dilation.toFun f y) = ↑r * edist x y)","name":"Dilation.toDilationClass","depth":15},{"term":"fun {α} [PseudoEMetricSpace α] =>\n  Monoid.mk (_ : ∀ (f : α →ᵈ α), Dilation.comp (Dilation.id α) f = f)\n    (_ : ∀ (f : α →ᵈ α), Dilation.comp f (Dilation.id α) = f) npowRec","name":"Dilation.instMonoidDilation","depth":24}],"kind":"«term_→ᵈ_»","examples":[{"term":"fun {α} [PseudoEMetricSpace α] =>\n  { toOneHom := { toFun := Dilation.ratio, map_one' := (_ : Dilation.ratio 1 = 1) },\n    map_mul' := (_ : ∀ (f g : α →ᵈ α), Dilation.ratio (f * g) = Dilation.ratio f * Dilation.ratio g) }","name":"Dilation.ratioHom","doc":"`Dilation.ratio` as a monoid homomorphism from `α →ᵈ α` to `ℝ≥0`. ","depth":15}],"count":3}
{"noDocExamples":[{"term":"fun {x y z} hy hz =>\n  Or.casesOn (ZFSet.eq_empty_or_nonempty x)\n    (fun h =>\n      Eq.ndrec (motive := fun {x} => y ∈ ⋂₀ x → z ∈ x → y ∈ z) (fun hy hz => False.elim (ZFSet.not_mem_empty z hz))\n        (Eq.symm h) hy hz)\n    fun hx => Iff.mp (ZFSet.mem_sInter hx) hy z hz","name":"ZFSet.mem_of_mem_sInter","depth":22},{"term":"fun {x} h =>\n  Set.ext fun x_1 =>\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (Mathlib.SetTheory.ZFC.Basic._auxLemma.9 x_1 (⋂₀ x))\n              ((fun x_0 => propext ((fun x_0 => ZFSet.mem_sInter h) x_0)) x_1)))\n          (Eq.trans\n            (Eq.trans\n              (congrArg (Membership.mem x_1)\n                (Eq.trans (Set.sInter_image ZFSet.toSet (ZFSet.toSet x))\n                  (congrArg Set.iInter\n                    (funext fun x_2 =>\n                      Set.iInter_congr_Prop (Iff.of_eq (Mathlib.SetTheory.ZFC.Basic._auxLemma.9 x_2 x)) fun x =>\n                        Eq.refl (ZFSet.toSet x_2)))))\n              Mathlib.Data.Set.Lattice._auxLemma.4)\n            (forall_congr fun i =>\n              Eq.trans Mathlib.Data.Set.Lattice._auxLemma.4\n                (implies_congr (Eq.refl (i ∈ x)) (Mathlib.SetTheory.ZFC.Basic._auxLemma.9 x_1 i)))))\n        (iff_self (∀ (z : ZFSet), z ∈ x → x_1 ∈ z)))","name":"ZFSet.toSet_sInter","depth":28},{"term":"fun {x y} h =>\n  Eq.mpr (id (ZFSet.sInter._eq_1 x ▸ Eq.refl (y ∈ ⋂₀ x ↔ ∀ (z : ZFSet), z ∈ x → y ∈ z)))\n    (Eq.mpr\n      (id\n        (dif_pos h ▸\n          Eq.refl\n            ((y ∈\n                if h : ZFSet.Nonempty x then ZFSet.sep (fun y => ∀ (z : ZFSet), z ∈ x → y ∈ z) (Set.Nonempty.some h)\n                else ∅) ↔\n              ∀ (z : ZFSet), z ∈ x → y ∈ z)))\n      (Eq.mpr\n        (id\n          (Eq.trans (congrFun (congrArg Iff Mathlib.SetTheory.ZFC.Basic._auxLemma.23) (∀ (z : ZFSet), z ∈ x → y ∈ z))\n            Mathlib.SetTheory.ZFC.Basic._auxLemma.26))\n        fun H => H (Set.Nonempty.some h) (Set.Nonempty.some_mem h)))","name":"ZFSet.mem_sInter","depth":30}],"kind":"ZFSet.«term⋂₀_»","examples":[],"count":3}
{"noDocExamples":[{"term":"fun x y H =>\n  let this := congr_arg ZFSet.sUnion H;\n  Eq.mp (ZFSet.sUnion_singleton ▸ Eq.refl (x = ⋃₀ {y}))\n    (Eq.mp (ZFSet.sUnion_singleton ▸ Eq.refl (⋃₀ {x} = ⋃₀ {y})) this)","name":"ZFSet.singleton_injective","depth":21},{"term":"fun x =>\n  Set.ext fun x_1 =>\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (Mathlib.SetTheory.ZFC.Basic._auxLemma.9 x_1 (⋃₀ x)) Mathlib.SetTheory.ZFC.Basic._auxLemma.25))\n          (Eq.trans\n            (Eq.trans\n              (congrArg (Membership.mem x_1)\n                (Eq.trans (Set.sUnion_image ZFSet.toSet (ZFSet.toSet x))\n                  (congrArg Set.iUnion\n                    (funext fun x_2 =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Mathlib.SetTheory.ZFC.Basic._auxLemma.9 x_2 x)) fun x =>\n                        Eq.refl (ZFSet.toSet x_2)))))\n              Mathlib.Data.Set.Lattice._auxLemma.3)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans\n                  (Eq.trans Mathlib.Data.Set.Lattice._auxLemma.3\n                    (exists_prop_congr' (fun h => Iff.of_eq (Mathlib.SetTheory.ZFC.Basic._auxLemma.9 x_1 i))\n                      (Iff.of_eq (Eq.refl (i ∈ x)))))\n                  Std.Logic._auxLemma.51))))\n        (iff_self (∃ z, z ∈ x ∧ x_1 ∈ z)))","name":"ZFSet.toSet_sUnion","depth":27}],"kind":"ZFSet.«term⋃₀_»","examples":[{"term":"fun x y => ⋃₀ {x, y}","name":"ZFSet.union","doc":"The binary union operation ","depth":8}],"count":3}
{"noDocExamples":[{"term":"fun {α} {β} [CommMonoid α] [CommMonoid β] {A} {n} =>\n  { coe := FreimanHom.toFun, coe_injective' := (_ : ∀ (f g : A →*[n] β), f.toFun = g.toFun → f = g) }","name":"FreimanHom.funLike","depth":17}],"kind":"«FreimanHomLocal≺»","examples":[{"term":"fun {α} {β} [CommMonoid α] [CommMonoid β] {A} {n} => CommMonoid.mk (_ : ∀ (a b : A →*[n] β), a * b = b * a)","name":"FreimanHom.commMonoid","doc":"`A →*[n] β` is a `CommMonoid`. ","depth":24},{"term":"fun {α} [CommMonoid α] {A} {n} {β} [CommGroup β] =>\n  let src := FreimanHom.commMonoid;\n  CommGroup.mk (_ : ∀ (a b : A →*[n] β), a * b = b * a)","name":"FreimanHom.commGroup","doc":"If `β` is a commutative group, then `A →*[n] β` is a commutative group too. ","depth":28}],"count":3}
{"noDocExamples":[{"term":"fun {V} {G} {x y} h ⦃v w⦄ h_1 =>\n  Subtype.ext\n    (Eq.mp\n      (propext Subtype.mk_eq_mk ▸\n        Eq.refl\n          (RelHomClass.toFunLike.1\n              { toFun := fun v => { val := ↑v, property := SimpleGraph.Subgraph.inclusion.proof_1 h v },\n                map_rel' := @SimpleGraph.Subgraph.inclusion.proof_2 V G x y h }\n              v =\n            RelHomClass.toFunLike.1\n              { toFun := fun v => { val := ↑v, property := SimpleGraph.Subgraph.inclusion.proof_1 h v },\n                map_rel' := @SimpleGraph.Subgraph.inclusion.proof_2 V G x y h }\n              w))\n      (Eq.mp\n        (FunLike.coe._eq_1 (SimpleGraph.Subgraph.coe x →g SimpleGraph.Subgraph.coe y) ▸\n          Eq.refl\n            (↑{ toFun := fun v => { val := ↑v, property := SimpleGraph.Subgraph.inclusion.proof_1 h v },\n                    map_rel' := @SimpleGraph.Subgraph.inclusion.proof_2 V G x y h }\n                v =\n              ↑{ toFun := fun v => { val := ↑v, property := SimpleGraph.Subgraph.inclusion.proof_1 h v },\n                    map_rel' := @SimpleGraph.Subgraph.inclusion.proof_2 V G x y h }\n                w))\n        (Eq.mp\n          (SimpleGraph.Subgraph.inclusion._eq_1 h ▸\n            Eq.refl (↑(SimpleGraph.Subgraph.inclusion h) v = ↑(SimpleGraph.Subgraph.inclusion h) w))\n          h_1)))","name":"SimpleGraph.Subgraph.inclusion.injective","depth":39}],"kind":"SimpleGraph.«term_→g_»","examples":[{"term":"fun {V} G α => G →g ⊤","name":"SimpleGraph.Coloring","doc":"An `α`-coloring of a simple graph `G` is a homomorphism of `G` into the complete graph on `α`.\nThis is also known as a proper coloring.\n","depth":10},{"term":"fun {V} {W} {G} G' F => SimpleGraph.Subgraph.coe ↑G' →g F","name":"SimpleGraph.FinsubgraphHom","doc":"A graph homomorphism from a finite subgraph of G to F. ","depth":18}],"count":3}
{"noDocExamples":[{"term":"fun {a} h =>\n  LE.le.antisymm (Iff.mpr Cardinal.powerlt_le fun c x => Cardinal.zero_power_le c)\n    (Eq.mpr (id (Eq.symm Cardinal.power_zero ▸ Eq.refl (1 ≤ 0 ^< a)))\n      (Cardinal.le_powerlt 0 (Iff.mpr pos_iff_ne_zero h)))","name":"Cardinal.zero_powerlt","depth":19},{"term":"fun c =>\n  Or.casesOn (motive := fun t => le_or_lt Cardinal.aleph0 c = t → c ^< Cardinal.aleph0 ≤ max c Cardinal.aleph0)\n    (le_or_lt Cardinal.aleph0 c)\n    (fun h h_1 =>\n      Eq.symm h_1 ▸\n        Eq.mpr (id (Cardinal.powerlt_aleph0 h ▸ Eq.refl (c ^< Cardinal.aleph0 ≤ max c Cardinal.aleph0)))\n          (le_max_left c Cardinal.aleph0))\n    (fun h h_1 =>\n      Eq.symm h_1 ▸\n        Eq.mpr (id (propext Cardinal.powerlt_le ▸ Eq.refl (c ^< Cardinal.aleph0 ≤ max c Cardinal.aleph0))) fun c' hc' =>\n          LE.le.trans (LT.lt.le (Cardinal.power_lt_aleph0 h hc')) (le_max_right c Cardinal.aleph0))\n    (Eq.refl (le_or_lt Cardinal.aleph0 c))","name":"Cardinal.powerlt_aleph0_le","depth":25},{"term":"fun {a b c} =>\n  Eq.mpr (id (Cardinal.powerlt._eq_1 a b ▸ Eq.refl (a ^< b ≤ c ↔ ∀ (x : Cardinal.{u}), x < b → a ^ x ≤ c)))\n    (Eq.mpr\n      (id\n        (propext\n            (ciSup_le_iff'\n              (Eq.mpr\n                (id\n                  (Eq.symm (Set.image_eq_range (HPow.hPow a) (Set.Iio b)) ▸\n                    Eq.refl (BddAbove (Set.range fun c => a ^ ↑c))))\n                (Cardinal.bddAbove_image (HPow.hPow a) bddAbove_Iio))) ▸\n          Eq.refl (⨆ (c : ↑(Set.Iio b)), a ^ ↑c ≤ c ↔ ∀ (x : Cardinal.{u}), x < b → a ^ x ≤ c)))\n      (of_eq_true\n        (Eq.trans\n          (congrFun\n            (congrArg Iff\n              (Eq.trans Mathlib.Data.Subtype._auxLemma.1\n                (forall_congr fun a_1 =>\n                  implies_congr Mathlib.Data.Set.Intervals.Basic._auxLemma.3 (Eq.refl (a ^ a_1 ≤ c)))))\n            (∀ (x : Cardinal.{u}), x < b → a ^ x ≤ c))\n          (iff_self (∀ (a_1 : Cardinal.{u}), a_1 < b → a ^ a_1 ≤ c)))))","name":"Cardinal.powerlt_le","depth":33}],"kind":"Cardinal.«term_^<_»","examples":[],"count":3}
{"noDocExamples":[{"term":"fun {α} {β} [NonUnitalNonAssocSemiring α] [NonUnitalNonAssocSemiring β] =>\n  NonUnitalRingHomClass.mk\n    (_ :\n      ∀ (self : α →ₙ+* β) (x y : α),\n        MulHom.toFun self.toMulHom (x + y) = MulHom.toFun self.toMulHom x + MulHom.toFun self.toMulHom y)\n    (_ : ∀ (self : α →ₙ+* β), MulHom.toFun self.toMulHom 0 = 0)","name":"NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom","depth":18},{"term":"fun {α} [NonUnitalNonAssocSemiring α] =>\n  MonoidWithZero.mk (_ : ∀ (f : α →ₙ+* α), NonUnitalRingHom.comp 0 f = 0)\n    (_ : ∀ (g : α →ₙ+* α), NonUnitalRingHom.comp g 0 = 0)","name":"NonUnitalRingHom.instMonoidWithZeroNonUnitalRingHom","depth":28}],"kind":"«term_→ₙ+*_»","examples":[{"term":"fun {α} {β} [NonUnitalNonAssocSemiring α] [NonUnitalNonAssocSemiring β] =>\n  {\n    toFun := fun f =>\n      let src := ↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f);\n      let src_1 := ↑MulHom.op f.toMulHom;\n      {\n        toMulHom :=\n          { toFun := src.toFun,\n            map_mul' :=\n              (_ :\n                ∀ (x y : αᵐᵒᵖ),\n                  MulHom.toFun (↑MulHom.op f.toMulHom) (x * y) =\n                    MulHom.toFun (↑MulHom.op f.toMulHom) x * MulHom.toFun (↑MulHom.op f.toMulHom) y) },\n        map_zero' := (_ : ZeroHom.toFun (↑(↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f))) 0 = 0),\n        map_add' :=\n          (_ :\n            ∀ (x y : αᵐᵒᵖ),\n              ZeroHom.toFun (↑(↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f))) (x + y) =\n                ZeroHom.toFun (↑(↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f))) x +\n                  ZeroHom.toFun (↑(↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f))) y) },\n    invFun := fun f =>\n      let src := ↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f);\n      let src_1 := ↑MulHom.unop f.toMulHom;\n      {\n        toMulHom :=\n          { toFun := src.toFun,\n            map_mul' :=\n              (_ :\n                ∀ (x y : α),\n                  MulHom.toFun (↑MulHom.unop f.toMulHom) (x * y) =\n                    MulHom.toFun (↑MulHom.unop f.toMulHom) x * MulHom.toFun (↑MulHom.unop f.toMulHom) y) },\n        map_zero' := (_ : ZeroHom.toFun (↑(↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f))) 0 = 0),\n        map_add' :=\n          (_ :\n            ∀ (x y : α),\n              ZeroHom.toFun (↑(↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f))) (x + y) =\n                ZeroHom.toFun (↑(↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f))) x +\n                  ZeroHom.toFun (↑(↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f))) y) },\n    left_inv :=\n      (_ :\n        ∀ (x : α →ₙ+* β),\n          (fun f =>\n                let src := ↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f);\n                let src_1 := ↑MulHom.unop f.toMulHom;\n                {\n                  toMulHom :=\n                    { toFun := src.toFun,\n                      map_mul' :=\n                        (_ : ∀ (x y : α), MulHom.toFun src_1 (x * y) = MulHom.toFun src_1 x * MulHom.toFun src_1 y) },\n                  map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                  map_add' :=\n                    (_ : ∀ (x y : α), ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) })\n              ((fun f =>\n                  let src := ↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f);\n                  let src_1 := ↑MulHom.op f.toMulHom;\n                  {\n                    toMulHom :=\n                      { toFun := src.toFun,\n                        map_mul' :=\n                          (_ :\n                            ∀ (x y : αᵐᵒᵖ), MulHom.toFun src_1 (x * y) = MulHom.toFun src_1 x * MulHom.toFun src_1 y) },\n                    map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                    map_add' :=\n                      (_ :\n                        ∀ (x y : αᵐᵒᵖ),\n                          ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) })\n                x) =\n            (fun f =>\n                let src := ↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f);\n                let src_1 := ↑MulHom.unop f.toMulHom;\n                {\n                  toMulHom :=\n                    { toFun := src.toFun,\n                      map_mul' :=\n                        (_ : ∀ (x y : α), MulHom.toFun src_1 (x * y) = MulHom.toFun src_1 x * MulHom.toFun src_1 y) },\n                  map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                  map_add' :=\n                    (_ : ∀ (x y : α), ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) })\n              ((fun f =>\n                  let src := ↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f);\n                  let src_1 := ↑MulHom.op f.toMulHom;\n                  {\n                    toMulHom :=\n                      { toFun := src.toFun,\n                        map_mul' :=\n                          (_ :\n                            ∀ (x y : αᵐᵒᵖ), MulHom.toFun src_1 (x * y) = MulHom.toFun src_1 x * MulHom.toFun src_1 y) },\n                    map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                    map_add' :=\n                      (_ :\n                        ∀ (x y : αᵐᵒᵖ),\n                          ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) })\n                x)),\n    right_inv :=\n      (_ :\n        ∀ (x : αᵐᵒᵖ →ₙ+* βᵐᵒᵖ),\n          (fun f =>\n                let src := ↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f);\n                let src_1 := ↑MulHom.op f.toMulHom;\n                {\n                  toMulHom :=\n                    { toFun := src.toFun,\n                      map_mul' :=\n                        (_ :\n                          ∀ (x y : αᵐᵒᵖ), MulHom.toFun src_1 (x * y) = MulHom.toFun src_1 x * MulHom.toFun src_1 y) },\n                  map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                  map_add' :=\n                    (_ :\n                      ∀ (x y : αᵐᵒᵖ), ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) })\n              ((fun f =>\n                  let src := ↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f);\n                  let src_1 := ↑MulHom.unop f.toMulHom;\n                  {\n                    toMulHom :=\n                      { toFun := src.toFun,\n                        map_mul' :=\n                          (_ : ∀ (x y : α), MulHom.toFun src_1 (x * y) = MulHom.toFun src_1 x * MulHom.toFun src_1 y) },\n                    map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                    map_add' :=\n                      (_ :\n                        ∀ (x y : α), ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) })\n                x) =\n            (fun f =>\n                let src := ↑AddMonoidHom.mulOp (NonUnitalRingHom.toAddMonoidHom f);\n                let src_1 := ↑MulHom.op f.toMulHom;\n                {\n                  toMulHom :=\n                    { toFun := src.toFun,\n                      map_mul' :=\n                        (_ :\n                          ∀ (x y : αᵐᵒᵖ), MulHom.toFun src_1 (x * y) = MulHom.toFun src_1 x * MulHom.toFun src_1 y) },\n                  map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                  map_add' :=\n                    (_ :\n                      ∀ (x y : αᵐᵒᵖ), ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) })\n              ((fun f =>\n                  let src := ↑AddMonoidHom.mulUnop (NonUnitalRingHom.toAddMonoidHom f);\n                  let src_1 := ↑MulHom.unop f.toMulHom;\n                  {\n                    toMulHom :=\n                      { toFun := src.toFun,\n                        map_mul' :=\n                          (_ : ∀ (x y : α), MulHom.toFun src_1 (x * y) = MulHom.toFun src_1 x * MulHom.toFun src_1 y) },\n                    map_zero' := (_ : ZeroHom.toFun (↑src) 0 = 0),\n                    map_add' :=\n                      (_ :\n                        ∀ (x y : α), ZeroHom.toFun (↑src) (x + y) = ZeroHom.toFun (↑src) x + ZeroHom.toFun (↑src) y) })\n                x)) }","name":"NonUnitalRingHom.op","doc":"A non-unital ring hom `α →ₙ+* β` can equivalently be viewed as a non-unital ring hom\n`αᵐᵒᵖ →+* βᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. ","depth":25}],"count":3}
{"noDocExamples":[{"term":"fun {k} {P₁} {P₂} {V₁} {V₂} [Ring k] [AddCommGroup V₁] [Module k V₁] [AddTorsor V₁ P₁] [AddCommGroup V₂] [Module k V₂]\n    [AddTorsor V₂ P₂] =>\n  { coe := fun f => f.toFun, inv := fun f => f.invFun,\n    left_inv := (_ : ∀ (f : P₁ ≃ᵃ[k] P₂), Function.LeftInverse f.invFun f.toFun),\n    right_inv := (_ : ∀ (f : P₁ ≃ᵃ[k] P₂), Function.RightInverse f.invFun f.toFun),\n    coe_injective' :=\n      (_ :\n        ∀ (x x_1 : P₁ ≃ᵃ[k] P₂),\n          (fun f => f.toFun) x = (fun f => f.toFun) x_1 → (fun f => f.invFun) x = (fun f => f.invFun) x_1 → x = x_1) }","name":"AffineEquiv.equivLike","depth":32}],"kind":"«term_≃ᵃ[_]_»","examples":[{"term":"fun {k} {P₁} {V₁} [Ring k] [AddCommGroup V₁] [Module k V₁] [AddTorsor V₁ P₁] =>\n  { toOneHom := { toFun := AffineEquiv.linear, map_one' := (_ : 1.linear = 1.linear) },\n    map_mul' :=\n      (_ :\n        ∀ (x x_1 : P₁ ≃ᵃ[k] P₁),\n          OneHom.toFun { toFun := AffineEquiv.linear, map_one' := (_ : 1.linear = 1.linear) } (x * x_1) =\n            OneHom.toFun { toFun := AffineEquiv.linear, map_one' := (_ : 1.linear = 1.linear) } (x * x_1)) }","name":"AffineEquiv.linearHom","doc":"`AffineEquiv.linear` on automorphisms is a `MonoidHom`. ","depth":31},{"term":"fun {k} {P₁} {V₁} [Ring k] [AddCommGroup V₁] [Module k V₁] [AddTorsor V₁ P₁] =>\n  {\n    toEquiv :=\n      {\n        toFun := fun e =>\n          { val := ↑e, inv := ↑(AffineEquiv.symm e),\n            val_inv := (_ : ↑(AffineEquiv.trans (AffineEquiv.symm e) e) = ↑(AffineEquiv.refl k P₁)),\n            inv_val := (_ : ↑(AffineEquiv.trans e (AffineEquiv.symm e)) = ↑(AffineEquiv.refl k P₁)) },\n        invFun := fun u =>\n          {\n            toEquiv :=\n              { toFun := ↑↑u, invFun := ↑↑u⁻¹, left_inv := (_ : ∀ (x : P₁), ↑(↑u⁻¹ * ↑u) x = ↑1 x),\n                right_inv := (_ : ∀ (x : P₁), ↑(↑u * ↑u⁻¹) x = ↑1 x) },\n            linear := ↑(LinearMap.GeneralLinearGroup.generalLinearEquiv k V₁) (↑(Units.map AffineMap.linearHom) u),\n            map_vadd' := (_ : ∀ (x : P₁) (x_1 : V₁), ↑↑u (x_1 +ᵥ x) = ↑(↑u).linear x_1 +ᵥ ↑↑u x) },\n        left_inv :=\n          (_ :\n            ∀ (x : P₁ ≃ᵃ[k] P₁),\n              (fun u =>\n                    {\n                      toEquiv :=\n                        { toFun := ↑↑u, invFun := ↑↑u⁻¹, left_inv := (_ : ∀ (x : P₁), ↑(↑u⁻¹ * ↑u) x = ↑1 x),\n                          right_inv := (_ : ∀ (x : P₁), ↑(↑u * ↑u⁻¹) x = ↑1 x) },\n                      linear :=\n                        ↑(LinearMap.GeneralLinearGroup.generalLinearEquiv k V₁) (↑(Units.map AffineMap.linearHom) u),\n                      map_vadd' := (_ : ∀ (x : P₁) (x_1 : V₁), ↑↑u (x_1 +ᵥ x) = ↑(↑u).linear x_1 +ᵥ ↑↑u x) })\n                  ((fun e =>\n                      { val := ↑e, inv := ↑(AffineEquiv.symm e),\n                        val_inv := (_ : ↑(AffineEquiv.trans (AffineEquiv.symm e) e) = ↑(AffineEquiv.refl k P₁)),\n                        inv_val := (_ : ↑(AffineEquiv.trans e (AffineEquiv.symm e)) = ↑(AffineEquiv.refl k P₁)) })\n                    x) =\n                x),\n        right_inv :=\n          (_ :\n            ∀ (x : (P₁ →ᵃ[k] P₁)ˣ),\n              (fun e =>\n                    { val := ↑e, inv := ↑(AffineEquiv.symm e),\n                      val_inv := (_ : ↑(AffineEquiv.trans (AffineEquiv.symm e) e) = ↑(AffineEquiv.refl k P₁)),\n                      inv_val := (_ : ↑(AffineEquiv.trans e (AffineEquiv.symm e)) = ↑(AffineEquiv.refl k P₁)) })\n                  ((fun u =>\n                      {\n                        toEquiv :=\n                          { toFun := ↑↑u, invFun := ↑↑u⁻¹, left_inv := (_ : ∀ (x : P₁), ↑(↑u⁻¹ * ↑u) x = ↑1 x),\n                            right_inv := (_ : ∀ (x : P₁), ↑(↑u * ↑u⁻¹) x = ↑1 x) },\n                        linear :=\n                          ↑(LinearMap.GeneralLinearGroup.generalLinearEquiv k V₁) (↑(Units.map AffineMap.linearHom) u),\n                        map_vadd' := (_ : ∀ (x : P₁) (x_1 : V₁), ↑↑u (x_1 +ᵥ x) = ↑(↑u).linear x_1 +ᵥ ↑↑u x) })\n                    x) =\n                x) },\n    map_mul' :=\n      (_ :\n        ∀ (x x_1 : P₁ ≃ᵃ[k] P₁),\n          Equiv.toFun\n              {\n                toFun := fun e =>\n                  { val := ↑e, inv := ↑(AffineEquiv.symm e),\n                    val_inv := (_ : ↑(AffineEquiv.trans (AffineEquiv.symm e) e) = ↑(AffineEquiv.refl k P₁)),\n                    inv_val := (_ : ↑(AffineEquiv.trans e (AffineEquiv.symm e)) = ↑(AffineEquiv.refl k P₁)) },\n                invFun := fun u =>\n                  {\n                    toEquiv :=\n                      { toFun := ↑↑u, invFun := ↑↑u⁻¹, left_inv := (_ : ∀ (x : P₁), ↑(↑u⁻¹ * ↑u) x = ↑1 x),\n                        right_inv := (_ : ∀ (x : P₁), ↑(↑u * ↑u⁻¹) x = ↑1 x) },\n                    linear :=\n                      ↑(LinearMap.GeneralLinearGroup.generalLinearEquiv k V₁) (↑(Units.map AffineMap.linearHom) u),\n                    map_vadd' := (_ : ∀ (x : P₁) (x_2 : V₁), ↑↑u (x_2 +ᵥ x) = ↑(↑u).linear x_2 +ᵥ ↑↑u x) },\n                left_inv :=\n                  (_ :\n                    ∀ (x : P₁ ≃ᵃ[k] P₁),\n                      (fun u =>\n                            {\n                              toEquiv :=\n                                { toFun := ↑↑u, invFun := ↑↑u⁻¹, left_inv := (_ : ∀ (x : P₁), ↑(↑u⁻¹ * ↑u) x = ↑1 x),\n                                  right_inv := (_ : ∀ (x : P₁), ↑(↑u * ↑u⁻¹) x = ↑1 x) },\n                              linear :=\n                                ↑(LinearMap.GeneralLinearGroup.generalLinearEquiv k V₁)\n                                  (↑(Units.map AffineMap.linearHom) u),\n                              map_vadd' := (_ : ∀ (x : P₁) (x_2 : V₁), ↑↑u (x_2 +ᵥ x) = ↑(↑u).linear x_2 +ᵥ ↑↑u x) })\n                          ((fun e =>\n                              { val := ↑e, inv := ↑(AffineEquiv.symm e),\n                                val_inv := (_ : ↑(AffineEquiv.trans (AffineEquiv.symm e) e) = ↑(AffineEquiv.refl k P₁)),\n                                inv_val :=\n                                  (_ : ↑(AffineEquiv.trans e (AffineEquiv.symm e)) = ↑(AffineEquiv.refl k P₁)) })\n                            x) =\n                        x),\n                right_inv :=\n                  (_ :\n                    ∀ (x : (P₁ →ᵃ[k] P₁)ˣ),\n                      (fun e =>\n                            { val := ↑e, inv := ↑(AffineEquiv.symm e),\n                              val_inv := (_ : ↑(AffineEquiv.trans (AffineEquiv.symm e) e) = ↑(AffineEquiv.refl k P₁)),\n                              inv_val := (_ : ↑(AffineEquiv.trans e (AffineEquiv.symm e)) = ↑(AffineEquiv.refl k P₁)) })\n                          ((fun u =>\n                              {\n                                toEquiv :=\n                                  { toFun := ↑↑u, invFun := ↑↑u⁻¹, left_inv := (_ : ∀ (x : P₁), ↑(↑u⁻¹ * ↑u) x = ↑1 x),\n                                    right_inv := (_ : ∀ (x : P₁), ↑(↑u * ↑u⁻¹) x = ↑1 x) },\n                                linear :=\n                                  ↑(LinearMap.GeneralLinearGroup.generalLinearEquiv k V₁)\n                                    (↑(Units.map AffineMap.linearHom) u),\n                                map_vadd' := (_ : ∀ (x : P₁) (x_2 : V₁), ↑↑u (x_2 +ᵥ x) = ↑(↑u).linear x_2 +ᵥ ↑↑u x) })\n                            x) =\n                        x) }\n              (x * x_1) =\n            Equiv.toFun\n              {\n                toFun := fun e =>\n                  { val := ↑e, inv := ↑(AffineEquiv.symm e),\n                    val_inv := (_ : ↑(AffineEquiv.trans (AffineEquiv.symm e) e) = ↑(AffineEquiv.refl k P₁)),\n                    inv_val := (_ : ↑(AffineEquiv.trans e (AffineEquiv.symm e)) = ↑(AffineEquiv.refl k P₁)) },\n                invFun := fun u =>\n                  {\n                    toEquiv :=\n                      { toFun := ↑↑u, invFun := ↑↑u⁻¹, left_inv := (_ : ∀ (x : P₁), ↑(↑u⁻¹ * ↑u) x = ↑1 x),\n                        right_inv := (_ : ∀ (x : P₁), ↑(↑u * ↑u⁻¹) x = ↑1 x) },\n                    linear :=\n                      ↑(LinearMap.GeneralLinearGroup.generalLinearEquiv k V₁) (↑(Units.map AffineMap.linearHom) u),\n                    map_vadd' := (_ : ∀ (x : P₁) (x_2 : V₁), ↑↑u (x_2 +ᵥ x) = ↑(↑u).linear x_2 +ᵥ ↑↑u x) },\n                left_inv :=\n                  (_ :\n                    ∀ (x : P₁ ≃ᵃ[k] P₁),\n                      (fun u =>\n                            {\n                              toEquiv :=\n                                { toFun := ↑↑u, invFun := ↑↑u⁻¹, left_inv := (_ : ∀ (x : P₁), ↑(↑u⁻¹ * ↑u) x = ↑1 x),\n                                  right_inv := (_ : ∀ (x : P₁), ↑(↑u * ↑u⁻¹) x = ↑1 x) },\n                              linear :=\n                                ↑(LinearMap.GeneralLinearGroup.generalLinearEquiv k V₁)\n                                  (↑(Units.map AffineMap.linearHom) u),\n                              map_vadd' := (_ : ∀ (x : P₁) (x_2 : V₁), ↑↑u (x_2 +ᵥ x) = ↑(↑u).linear x_2 +ᵥ ↑↑u x) })\n                          ((fun e =>\n                              { val := ↑e, inv := ↑(AffineEquiv.symm e),\n                                val_inv := (_ : ↑(AffineEquiv.trans (AffineEquiv.symm e) e) = ↑(AffineEquiv.refl k P₁)),\n                                inv_val :=\n                                  (_ : ↑(AffineEquiv.trans e (AffineEquiv.symm e)) = ↑(AffineEquiv.refl k P₁)) })\n                            x) =\n                        x),\n                right_inv :=\n                  (_ :\n                    ∀ (x : (P₁ →ᵃ[k] P₁)ˣ),\n                      (fun e =>\n                            { val := ↑e, inv := ↑(AffineEquiv.symm e),\n                              val_inv := (_ : ↑(AffineEquiv.trans (AffineEquiv.symm e) e) = ↑(AffineEquiv.refl k P₁)),\n                              inv_val := (_ : ↑(AffineEquiv.trans e (AffineEquiv.symm e)) = ↑(AffineEquiv.refl k P₁)) })\n                          ((fun u =>\n                              {\n                                toEquiv :=\n                                  { toFun := ↑↑u, invFun := ↑↑u⁻¹, left_inv := (_ : ∀ (x : P₁), ↑(↑u⁻¹ * ↑u) x = ↑1 x),\n                                    right_inv := (_ : ∀ (x : P₁), ↑(↑u * ↑u⁻¹) x = ↑1 x) },\n                                linear :=\n                                  ↑(LinearMap.GeneralLinearGroup.generalLinearEquiv k V₁)\n                                    (↑(Units.map AffineMap.linearHom) u),\n                                map_vadd' := (_ : ∀ (x : P₁) (x_2 : V₁), ↑↑u (x_2 +ᵥ x) = ↑(↑u).linear x_2 +ᵥ ↑↑u x) })\n                            x) =\n                        x) }\n              (x * x_1)) }","name":"AffineEquiv.equivUnitsAffineMap","doc":"The group of `AffineEquiv`s are equivalent to the group of units of `AffineMap`.\n\nThis is the affine version of `LinearMap.GeneralLinearGroup.generalLinearEquiv`. ","depth":46}],"count":3}
{"noDocExamples":[{"term":"fun {α} {β} [AddCommMonoid α] [AddCommMonoid β] {A} {n} =>\n  { coe := AddFreimanHom.toFun, coe_injective' := (_ : ∀ (f g : A →+[n] β), f.toFun = g.toFun → f = g) }","name":"AddFreimanHom.funLike","depth":17}],"kind":"«AddFreimanHomLocal≺»","examples":[{"term":"fun {α} {β} [AddCommMonoid α] [AddCommMonoid β] {A} {n} => AddCommMonoid.mk (_ : ∀ (a b : A →+[n] β), a + b = b + a)","name":"AddFreimanHom.addCommMonoid","doc":"`α →+[n] β` is an `AddCommMonoid`.","depth":24},{"term":"fun {α} [AddCommMonoid α] {A} {n} {β} [AddCommGroup β] =>\n  let src := AddFreimanHom.addCommMonoid;\n  AddCommGroup.mk (_ : ∀ (a b : A →+[n] β), a + b = b + a)","name":"AddFreimanHom.addCommGroup","doc":"If `β` is an additive commutative group, then `A →*[n] β` is an additive commutative\ngroup too.","depth":28}],"count":3}
{"noDocExamples":[{"term":"fun f a b =>\n  Eq.mpr\n    (id\n      (interval_average_eq (fun x => f x) a b ▸ Eq.refl (⨍ (x : ℝ) in a..b, f x = (∫ (x : ℝ) in a..b, f x) / (b - a))))\n    (Eq.mpr (id (smul_eq_mul ℝ ▸ Eq.refl ((b - a)⁻¹ • ∫ (x : ℝ) in a..b, f x = (∫ (x : ℝ) in a..b, f x) / (b - a))))\n      (Eq.mpr\n        (id\n          (div_eq_inv_mul (∫ (x : ℝ) in a..b, f x) (b - a) ▸\n            Eq.refl ((b - a)⁻¹ * ∫ (x : ℝ) in a..b, f x = (∫ (x : ℝ) in a..b, f x) / (b - a))))\n        (Eq.refl ((b - a)⁻¹ * ∫ (x : ℝ) in a..b, f x))))","name":"interval_average_eq_div","depth":32},{"term":"fun {E} [NormedAddCommGroup E] [NormedSpace ℝ E] f a b =>\n  Eq.mpr\n    (id\n      (MeasureTheory.setAverage_eq MeasureTheory.volume (fun x => f x) (Ι a b) ▸\n        Eq.refl (⨍ (x : ℝ) in a..b, f x = ⨍ (x : ℝ) in b..a, f x)))\n    (Eq.mpr\n      (id\n        (MeasureTheory.setAverage_eq MeasureTheory.volume (fun x => f x) (Ι b a) ▸\n          Eq.refl\n            ((ENNReal.toReal (↑↑MeasureTheory.volume (Ι a b)))⁻¹ • ∫ (x : ℝ) in Ι a b, f x = ⨍ (x : ℝ) in b..a, f x)))\n      (Eq.mpr\n        (id\n          (Set.uIoc_comm a b ▸\n            Eq.refl\n              ((ENNReal.toReal (↑↑MeasureTheory.volume (Ι a b)))⁻¹ • ∫ (x : ℝ) in Ι a b, f x =\n                (ENNReal.toReal (↑↑MeasureTheory.volume (Ι b a)))⁻¹ • ∫ (x : ℝ) in Ι b a, f x)))\n        (Eq.refl ((ENNReal.toReal (↑↑MeasureTheory.volume (Ι b a)))⁻¹ • ∫ (x : ℝ) in Ι b a, f x))))","name":"interval_average_symm","depth":35},{"term":"fun {E} [NormedAddCommGroup E] [NormedSpace ℝ E] f a b =>\n  Or.casesOn (motive := fun t => le_or_lt a b = t → ⨍ (x : ℝ) in a..b, f x = (b - a)⁻¹ • ∫ (x : ℝ) in a..b, f x)\n    (le_or_lt a b)\n    (fun h h_1 =>\n      Eq.symm h_1 ▸\n        Eq.mpr\n          (id\n            (MeasureTheory.setAverage_eq MeasureTheory.volume (fun x => f x) (Ι a b) ▸\n              Eq.refl (⨍ (x : ℝ) in a..b, f x = (b - a)⁻¹ • ∫ (x : ℝ) in a..b, f x)))\n          (Eq.mpr\n            (id\n              (Set.uIoc_of_le h ▸\n                Eq.refl\n                  ((ENNReal.toReal (↑↑MeasureTheory.volume (Ι a b)))⁻¹ • ∫ (x : ℝ) in Ι a b, f x =\n                    (b - a)⁻¹ • ∫ (x : ℝ) in a..b, f x)))\n            (Eq.mpr\n              (id\n                (Real.volume_Ioc ▸\n                  Eq.refl\n                    ((ENNReal.toReal (↑↑MeasureTheory.volume (Set.Ioc a b)))⁻¹ • ∫ (x : ℝ) in Set.Ioc a b, f x =\n                      (b - a)⁻¹ • ∫ (x : ℝ) in a..b, f x)))\n              (Eq.mpr\n                (id\n                  (intervalIntegral.integral_of_le h ▸\n                    Eq.refl\n                      ((ENNReal.toReal (ENNReal.ofReal (b - a)))⁻¹ • ∫ (x : ℝ) in Set.Ioc a b, f x =\n                        (b - a)⁻¹ • ∫ (x : ℝ) in a..b, f x)))\n                (Eq.mpr\n                  (id\n                    (ENNReal.toReal_ofReal (Iff.mpr sub_nonneg h) ▸\n                      Eq.refl\n                        ((ENNReal.toReal (ENNReal.ofReal (b - a)))⁻¹ • ∫ (x : ℝ) in Set.Ioc a b, f x =\n                          (b - a)⁻¹ • ∫ (x : ℝ) in Set.Ioc a b, f x)))\n                  (Eq.refl ((b - a)⁻¹ • ∫ (x : ℝ) in Set.Ioc a b, f x)))))))\n    (fun h h_1 =>\n      Eq.symm h_1 ▸\n        Eq.mpr\n          (id\n            (MeasureTheory.setAverage_eq MeasureTheory.volume (fun x => f x) (Ι a b) ▸\n              Eq.refl (⨍ (x : ℝ) in a..b, f x = (b - a)⁻¹ • ∫ (x : ℝ) in a..b, f x)))\n          (Eq.mpr\n            (id\n              (Set.uIoc_of_lt h ▸\n                Eq.refl\n                  ((ENNReal.toReal (↑↑MeasureTheory.volume (Ι a b)))⁻¹ • ∫ (x : ℝ) in Ι a b, f x =\n                    (b - a)⁻¹ • ∫ (x : ℝ) in a..b, f x)))\n            (Eq.mpr\n              (id\n                (Real.volume_Ioc ▸\n                  Eq.refl\n                    ((ENNReal.toReal (↑↑MeasureTheory.volume (Set.Ioc b a)))⁻¹ • ∫ (x : ℝ) in Set.Ioc b a, f x =\n                      (b - a)⁻¹ • ∫ (x : ℝ) in a..b, f x)))\n              (Eq.mpr\n                (id\n                  (intervalIntegral.integral_of_ge (LT.lt.le h) ▸\n                    Eq.refl\n                      ((ENNReal.toReal (ENNReal.ofReal (a - b)))⁻¹ • ∫ (x : ℝ) in Set.Ioc b a, f x =\n                        (b - a)⁻¹ • ∫ (x : ℝ) in a..b, f x)))\n                (Eq.mpr\n                  (id\n                    (ENNReal.toReal_ofReal (Iff.mpr sub_nonneg (LT.lt.le h)) ▸\n                      Eq.refl\n                        ((ENNReal.toReal (ENNReal.ofReal (a - b)))⁻¹ • ∫ (x : ℝ) in Set.Ioc b a, f x =\n                          (b - a)⁻¹ • -∫ (x : ℝ) in Set.Ioc b a, f x)))\n                  (Eq.mpr\n                    (id\n                      (smul_neg (b - a)⁻¹ (∫ (x : ℝ) in Set.Ioc b a, f x) ▸\n                        Eq.refl\n                          ((a - b)⁻¹ • ∫ (x : ℝ) in Set.Ioc b a, f x = (b - a)⁻¹ • -∫ (x : ℝ) in Set.Ioc b a, f x)))\n                    (Eq.mpr\n                      (id\n                        (Eq.symm (neg_smul (b - a)⁻¹ (∫ (x : ℝ) in Set.Ioc b a, f x)) ▸\n                          Eq.refl\n                            ((a - b)⁻¹ • ∫ (x : ℝ) in Set.Ioc b a, f x = -((b - a)⁻¹ • ∫ (x : ℝ) in Set.Ioc b a, f x))))\n                      (Eq.mpr\n                        (id\n                          (Eq.symm inv_neg ▸\n                            Eq.refl\n                              ((a - b)⁻¹ • ∫ (x : ℝ) in Set.Ioc b a, f x = -(b - a)⁻¹ • ∫ (x : ℝ) in Set.Ioc b a, f x)))\n                        (Eq.mpr\n                          (id\n                            (neg_sub b a ▸\n                              Eq.refl\n                                ((a - b)⁻¹ • ∫ (x : ℝ) in Set.Ioc b a, f x =\n                                  (-(b - a))⁻¹ • ∫ (x : ℝ) in Set.Ioc b a, f x)))\n                          (Eq.refl ((a - b)⁻¹ • ∫ (x : ℝ) in Set.Ioc b a, f x)))))))))))\n    (Eq.refl (le_or_lt a b))","name":"interval_average_eq","depth":50}],"kind":"«term⨍_In_.._,_»","examples":[],"count":3}
{"noDocExamples":[{"term":"fun {R} {L} {M} {N} [CommRing R] [LieRing L] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]\n    [LieRingModule L M] [LieRingModule L N] =>\n  { coe := fun f => f.toFun,\n    coe_injective' := (_ : ∀ (x y : M →ₗ⁅R,L⁆ N), (fun f => f.toFun) x = (fun f => f.toFun) y → x = y) }","name":"LieModuleHom.instFunLikeLieModuleHom","depth":30},{"term":"fun {R} {L} {M} {N} [CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [AddCommGroup N] [Module R M]\n    [Module R N] [LieRingModule L M] [LieRingModule L N] [LieModule R L N] =>\n  Function.Injective.module R\n    { toZeroHom := { toFun := fun f => f.toFun, map_zero' := (_ : (fun f => f.toFun) 0 = (fun f => f.toFun) 0) },\n      map_add' := (_ : ∀ (f g : M →ₗ⁅R,L⁆ N), ↑(f + g) = ↑f + ↑g) }\n    (_ : Function.Injective FunLike.coe) (_ : ∀ (t : R) (f : M →ₗ⁅R,L⁆ N), ↑(t • f) = t • ↑f)","name":"LieModuleHom.instModuleLieModuleHomToSemiringToCommSemiringToAddCommMonoidInstAddCommGroupLieModuleHom","depth":40},{"term":"fun {R} {L} {M} {N} [CommRing R] [LieRing L] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]\n    [LieRingModule L M] [LieRingModule L N] =>\n  Function.Injective.addCommGroup FunLike.coe (_ : Function.Injective FunLike.coe) (_ : ↑0 = 0)\n    (_ : ∀ (f g : M →ₗ⁅R,L⁆ N), ↑(f + g) = ↑f + ↑g) (_ : ∀ (f : M →ₗ⁅R,L⁆ N), ↑(-f) = -↑f)\n    (_ : ∀ (f g : M →ₗ⁅R,L⁆ N), ↑(f - g) = ↑f - ↑g) (_ : ∀ (x : M →ₗ⁅R,L⁆ N) (x_1 : ℕ), ↑(x_1 • x) = x_1 • ↑x)\n    (_ : ∀ (x : M →ₗ⁅R,L⁆ N) (x_1 : ℤ), ↑(x_1 • x) = x_1 • ↑x)","name":"LieModuleHom.instAddCommGroupLieModuleHom","depth":41}],"kind":"«term_→ₗ⁅_,_⁆_»","examples":[],"count":3}
{"noDocExamples":[],"kind":"termℙ","examples":[{"term":"fun {K} {V} [Field K] [AddCommGroup V] [Module K V] =>\n  {\n    sInf := fun A =>\n      { carrier := sInf (SetLike.coe '' A),\n        mem_add' :=\n          (_ :\n            ∀ (v w : V) (hv : v ≠ 0) (hw : w ≠ 0) (hvw : v + w ≠ 0),\n              Projectivization.mk K v hv ∈ sInf (SetLike.coe '' A) →\n                Projectivization.mk K w hw ∈ sInf (SetLike.coe '' A) →\n                  ∀ (t : Set (ℙ K V)), t ∈ SetLike.coe '' A → Projectivization.mk K (v + w) hvw ∈ t) } }","name":"Projectivization.Subspace.instInfSet","doc":"Infimums of arbitrary collections of subspaces exist. ","depth":20},{"term":"fun {K} {V} [Field K] [AddCommGroup V] [Module K V] =>\n  { choice := fun S _hS => Projectivization.Subspace.span S,\n    gc := (_ : ∀ (A : Set (ℙ K V)) (B : Projectivization.Subspace K V), Projectivization.Subspace.span A ≤ B ↔ A ≤ ↑B),\n    le_l_u := (_ : ∀ (S : Projectivization.Subspace K V), ↑S ⊆ ↑(Projectivization.Subspace.span ↑S)),\n    choice_eq :=\n      (_ :\n        ∀ (x : Set (ℙ K V)) (x_1 : ↑(Projectivization.Subspace.span x) ≤ x),\n          (fun S _hS => Projectivization.Subspace.span S) x x_1 =\n            (fun S _hS => Projectivization.Subspace.span S) x x_1) }","name":"Projectivization.Subspace.gi","doc":"The span of a set of points is a Galois insertion between sets of points of a projective space\nand subspaces of the projective space. ","depth":27}],"count":2}
{"noDocExamples":[],"kind":"«term_⊕'_»","examples":[{"term":"fun α β =>\n  { toFun := fun s => PSum.casesOn s Sum.inl Sum.inr, invFun := Sum.elim PSum.inl PSum.inr,\n    left_inv := (_ : ∀ (s : α ⊕' β), Sum.elim PSum.inl PSum.inr ((fun s => PSum.casesOn s Sum.inl Sum.inr) s) = s),\n    right_inv := (_ : ∀ (s : α ⊕ β), (fun s => PSum.casesOn s Sum.inl Sum.inr) (Sum.elim PSum.inl PSum.inr s) = s) }","name":"Equiv.psumEquivSum","doc":"`PSum` is equivalent to `Sum`. ","depth":14},{"term":"fun {α} {β} {γ} {δ} e₁ e₂ =>\n  { toFun := fun x => PSum.casesOn x (PSum.inl ∘ ↑e₁) (PSum.inr ∘ ↑e₂),\n    invFun := fun x => PSum.casesOn x (PSum.inl ∘ ↑e₁.symm) (PSum.inr ∘ ↑e₂.symm),\n    left_inv :=\n      (_ :\n        ∀ (x : α ⊕' γ),\n          (fun x => PSum.casesOn x (PSum.inl ∘ ↑e₁.symm) (PSum.inr ∘ ↑e₂.symm))\n              ((fun x => PSum.casesOn x (PSum.inl ∘ ↑e₁) (PSum.inr ∘ ↑e₂)) x) =\n            x),\n    right_inv :=\n      (_ :\n        ∀ (x : β ⊕' δ),\n          (fun x => PSum.casesOn x (PSum.inl ∘ ↑e₁) (PSum.inr ∘ ↑e₂))\n              ((fun x => PSum.casesOn x (PSum.inl ∘ ↑e₁.symm) (PSum.inr ∘ ↑e₂.symm)) x) =\n            x) }","name":"Equiv.psumCongr","doc":"If `α ≃ α'` and `β ≃ β'`, then `PSum α β ≃ PSum α' β'`. ","depth":21}],"count":2}
{"noDocExamples":[{"term":"fun {n} => Unique.mk' (Fin n ≃o Fin n)","name":"Fin.orderIsoUnique","depth":11},{"term":"fun {α} {β} [LE α] [LE β] => OrderIsoClass.mk (_ : ∀ (f : α ≃o β) (x x_1 : α), ↑f.toEquiv x ≤ ↑f.toEquiv x_1 ↔ x ≤ x_1)","name":"OrderIso.instOrderIsoClassOrderIso","depth":22}],"kind":"«term_≃o_»","examples":[],"count":2}
{"noDocExamples":[{"term":"fun M' X [SMul M' X] Y [SMul M' Y] =>\n  SMulHomClass.mk\n    (_ : ∀ (self : X →[M'] Y) (m : M') (x : X), MulActionHom.toFun self (m • x) = m • MulActionHom.toFun self x)","name":"instSMulHomClassMulActionHom","depth":18},{"term":"fun {M} {α} {N} {β} [Monoid M] [MulAction M α] [SMul N α] [SMulCommClass M N α] [SMul N β] =>\n  Function.Injective.mulAction (fun f => ↑f) (_ : Function.Injective fun f => ↑f)\n    (_ : ∀ (x : Mᵈᵐᵃ) (x_1 : α →[N] β), ↑(x • x_1) = ↑(x • x_1))","name":"DomMulAct.instMulActionDomMulActMulActionHomInstMonoidDomMulActMonoid","depth":27}],"kind":"«MulActionHomLocal≺»","examples":[],"count":2}
{"noDocExamples":[{"term":"fun stx nmStx => do\n  let nm ← Lean.Elab.resolveGlobalConstNoOverloadWithInfo nmStx.raw\n  let const ← Lean.getConstInfo nm\n  let __do_lift ←\n    pure !Lean.Expr.isAppOfArity' (Lean.ConstantInfo.type const) `ProofWidgets.Component 1 <||>\n        pure !Lean.Expr.isConstOf (Lean.Expr.appArg!' (Lean.ConstantInfo.type const)) `ProofWidgets.PanelWidgetProps\n  let __do_jp : Unit → Lean.CoreM Unit := fun y => do\n    let __do_lift ← Lean.getEnv\n    let __do_jp : Unit → Lean.CoreM Unit := fun y => ProofWidgets.savePanelWidgetInfo stx nm (pure Lean.Json.null)\n    if\n          (!Lean.MapDeclarationExtension.contains Lean.Widget.userWidgetRegistry __do_lift\n                (nm ++ ProofWidgets.widgetDefPostfix)) =\n            true then\n        do\n        let y ←\n          Lean.logWarningAt nmStx.raw\n              (Lean.toMessageData \"panel widget\" ++ Lean.toMessageData (Lean.indentExpr (Lean.mkConst nm)) ++\n                Lean.toMessageData \"\\nwas not registered with `@[widget_module]`\")\n        __do_jp y\n      else do\n        let y ← pure PUnit.unit\n        __do_jp y\n  if __do_lift = true then\n      let expType := Lean.Expr.app (Lean.mkConst `ProofWidgets.Component) (Lean.mkConst `ProofWidgets.PanelWidgetProps);\n      do\n      let y ←\n        Lean.logWarningAt nmStx.raw\n            (Lean.toMessageData \"unexpected panel widget type, got\" ++\n                    Lean.toMessageData (Lean.indentExpr (Lean.ConstantInfo.type const)) ++\n                  Lean.toMessageData \"\\nbut expected\" ++\n                Lean.toMessageData (Lean.indentExpr expType) ++\n              Lean.toMessageData \"\")\n      __do_jp y\n    else do\n      let y ← pure PUnit.unit\n      __do_jp y","name":"ProofWidgets.processIdent","depth":27}],"kind":"«term_<||>_»","examples":[{"term":"fun pkg => do\n  let __do_lift ← Lean.findSysroot \"lean\"\n  let sp ← Lean.initSrcSearchPath __do_lift ∅\n  let root? ←\n    List.findM?\n        (fun p =>\n          liftM (System.FilePath.isDir (p / { toString := pkg })) <||>\n            liftM (System.FilePath.pathExists (System.FilePath.withExtension (p / { toString := pkg }) \"lean\")))\n        sp\n  let __do_jp : PUnit.{1} → IO System.FilePath := fun y =>\n    throw\n      (IO.userError\n        (toString \"Could not find \" ++ toString pkg ++ toString \" directory. \" ++ toString \"\" ++\n          toString \"Make sure the LEAN_SRC_PATH environment variable is set correctly.\"))\n  match root? with\n    | some root => pure root\n    | x => do\n      let y ← pure PUnit.unit\n      __do_jp y","name":"Mathlib.getPackageDir","doc":"Returns the root directory which contains the package root file, e.g. `Mathlib.lean`. ","depth":23}],"count":2}
{"noDocExamples":[{"term":"fun {α} {β} {r} {s} =>\n  RelHomClass.mk (_ : ∀ (self : r →r s) {a b : α}, r a b → s (RelHom.toFun self a) (RelHom.toFun self b))","name":"RelHom.instRelHomClassRelHom","depth":15}],"kind":"«term_→r_»","examples":[{"term":"fun {V} {W} G G' => G.Adj →r G'.Adj","name":"SimpleGraph.Hom","doc":"A graph homomorphism is a map on vertex sets that respects adjacency relations.\n\nThe notation `G →g G'` represents the type of graph homomorphisms. ","depth":8}],"count":2}
{"noDocExamples":[{"term":"fun {𝕜} {V} {V₂} {P} {P₂} [NormedField 𝕜] [SeminormedAddCommGroup V] [SeminormedAddCommGroup V₂] [NormedSpace 𝕜 V]\n    [NormedSpace 𝕜 V₂] [PseudoMetricSpace P] [PseudoMetricSpace P₂] [NormedAddTorsor V P] [NormedAddTorsor V₂ P₂] =>\n  { coe := fun f => f.toFun,\n    coe_injective' := (_ : ∀ (f g : P →ᵃⁱ[𝕜] P₂), (fun f => f.toFun) f = (fun f => f.toFun) g → f = g) }","name":"AffineIsometry.instFunLikeAffineIsometry","depth":33},{"term":"fun {𝕜} {V} {P} [NormedField 𝕜] [SeminormedAddCommGroup V] [NormedSpace 𝕜 V] [PseudoMetricSpace P]\n    [NormedAddTorsor V P] =>\n  Monoid.mk (_ : ∀ (f : P →ᵃⁱ[𝕜] P), AffineIsometry.comp AffineIsometry.id f = f)\n    (_ : ∀ (f : P →ᵃⁱ[𝕜] P), AffineIsometry.comp f AffineIsometry.id = f) npowRec","name":"AffineIsometry.instMonoidAffineIsometry","depth":42}],"kind":"«term_→ᵃⁱ[_]_»","examples":[],"count":2}
{"noDocExamples":[{"term":"fun {R} {S} {M} {M₂} [Semiring R] [Semiring S] [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂] {σ} {σ'}\n    [RingHomInvPair σ σ'] [RingHomInvPair σ' σ] =>\n  SemilinearEquivClass.mk\n    (_ : ∀ (x : M ≃ₛₗ[σ] M₂) (r : R) (x_1 : M), AddHom.toFun x.toAddHom (r • x_1) = ↑σ r • AddHom.toFun x.toAddHom x_1)","name":"LinearEquiv.instSemilinearEquivClassLinearEquiv","depth":45}],"kind":"«term_≃ₛₗ[_]_»","examples":[{"term":"fun {R} {R₂} {M} {M₂} [Semiring R] [Semiring R₂] [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module R₂ M₂] {σ₁₂}\n    {σ₂₁} [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂] [Subsingleton M] [Subsingleton M₂] =>\n  { toInhabited := { default := 0 }, uniq := (_ : ∀ (x : M ≃ₛₗ[σ₁₂] M₂), x = default) }","name":"LinearEquiv.instUniqueLinearEquiv","doc":"Between two zero modules, the zero map is the only equivalence. ","depth":37}],"count":2}
{"noDocExamples":[{"term":"fun {α} {β} [PseudoEMetricSpace α] [PseudoEMetricSpace β] =>\n  { coe := fun e => ↑e.toEquiv, inv := fun e => ↑e.symm,\n    left_inv := (_ : ∀ (e : α ≃ᵢ β), Function.LeftInverse e.invFun e.toFun),\n    right_inv := (_ : ∀ (e : α ≃ᵢ β), Function.RightInverse e.invFun e.toFun),\n    coe_injective' :=\n      (_ :\n        ∀ (x x_1 : α ≃ᵢ β),\n          (fun e => ↑e.toEquiv) x = (fun e => ↑e.toEquiv) x_1 →\n            (fun e => ↑e.symm) x = (fun e => ↑e.symm) x_1 → x = x_1) }","name":"IsometryEquiv.instEquivLikeIsometryEquiv","depth":17}],"kind":"«term_≃ᵢ_»","examples":[{"term":"fun {α} [PseudoEMetricSpace α] => Group.mk (_ : ∀ (e : α ≃ᵢ α), e⁻¹ * e = 1)","name":"IsometryEquiv.instGroupIsometryEquiv","doc":"The group of isometries. ","depth":34}],"count":2}
{"noDocExamples":[{"term":"fun {α} {β} f s =>\n  id\n    (Eq.mpr\n      (id\n        (Stream'.WSeq.map_comp f Stream'.WSeq.ret s ▸\n          Eq.refl (Stream'.WSeq.join (Stream'.WSeq.map (Stream'.WSeq.ret ∘ f) s) ~ʷ Stream'.WSeq.map f s)))\n      (Stream'.WSeq.join_map_ret (Stream'.WSeq.map f s)))","name":"Stream'.WSeq.bind_ret","depth":25},{"term":"fun {α} {β} {γ} s f g =>\n  Eq.mpr\n    (id\n      (congrFun\n        (congrArg Stream'.WSeq.Equiv (congrArg Stream'.WSeq.join (Stream'.WSeq.map_join g (Stream'.WSeq.map f s))))\n        (Stream'.WSeq.join (Stream'.WSeq.map (fun x => Stream'.WSeq.join (Stream'.WSeq.map g (f x))) s))))\n    (Eq.mpr\n      (id\n        (Eq.symm (Stream'.WSeq.map_comp f (Stream'.WSeq.map g) s) ▸\n          Eq.refl\n            (Stream'.WSeq.join (Stream'.WSeq.join (Stream'.WSeq.map (Stream'.WSeq.map g) (Stream'.WSeq.map f s))) ~ʷ\n              Stream'.WSeq.join (Stream'.WSeq.map (fun x => Stream'.WSeq.join (Stream'.WSeq.map g (f x))) s))))\n      (Eq.mpr\n        (id\n          (Stream'.WSeq.map_comp (Stream'.WSeq.map g ∘ f) Stream'.WSeq.join s ▸\n            Eq.refl\n              (Stream'.WSeq.join (Stream'.WSeq.join (Stream'.WSeq.map (Stream'.WSeq.map g ∘ f) s)) ~ʷ\n                Stream'.WSeq.join (Stream'.WSeq.map (fun x => Stream'.WSeq.join (Stream'.WSeq.map g (f x))) s))))\n        (Stream'.WSeq.join_join (Stream'.WSeq.map (Stream'.WSeq.map g ∘ f) s))))","name":"Stream'.WSeq.bind_assoc","depth":29}],"kind":"Stream'.WSeq.«term_~ʷ_»","examples":[],"count":2}
{"noDocExamples":[{"term":"fun {x} =>\n  {\n    mp := fun hip =>\n      {\n        left :=\n          Iff.mpr Hyperreal.infinitesimal_def fun r hr =>\n            { left := lt_trans (Iff.mpr Hyperreal.coe_lt_coe (neg_neg_of_pos hr)) (Iff.mpr inv_pos (hip 0)),\n              right :=\n                Iff.mp (inv_lt (Iff.mpr Hyperreal.coe_lt_coe hr) (hip 0))\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α self a a' e'_3 a_1 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → HEq e'_3 x → HEq (a < a_1) (a' < a_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a = a'), HEq e_3 (Eq.refl a) → HEq (a < a_1) (a' < a_1))\n                                (fun e_3 h => Eq.symm (eq_of_heq h) ▸ HEq.refl (a < a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a') (HEq.refl e'_3))\n                        ℝ* Preorder.toLT (↑r)⁻¹ (↑r⁻¹) (Eq.refl (↑r)⁻¹) x))\n                    (id (hip r⁻¹))) },\n        right := Iff.mpr inv_pos (hip 0) },\n    mpr := fun x_1 r =>\n      match x_1 with\n      | { left := hi, right := hp } =>\n        by_cases (fun h => Eq.substr h (Iff.mp inv_pos hp)) fun h =>\n          lt_of_le_of_lt (Iff.mpr Hyperreal.coe_le_coe (le_abs_self r))\n            (Iff.mp (inv_lt_inv (Iff.mp inv_pos hp) (Iff.mpr Hyperreal.coe_lt_coe (Iff.mpr abs_pos h)))\n              (Iff.mp Hyperreal.infinitesimal_def hi |r|⁻¹ (Iff.mpr inv_pos (Iff.mpr abs_pos h))).right) }","name":"Hyperreal.infinitePos_iff_infinitesimal_inv_pos","depth":48},{"term":"fun {x y} hip hnin r =>\n  Exists.casesOn (motive := fun t => Iff.mp not_forall hnin = t → ↑r < x + y) (Iff.mp not_forall hnin)\n    (fun r₂ hr₂ h =>\n      Eq.symm h ▸\n        Eq.mpr\n          (eq_of_heq\n            ((fun α self a a' e'_3 a_1 =>\n                Eq.casesOn (motive := fun a_2 x => a' = a_2 → HEq e'_3 x → HEq (a < a_1) (a' < a_1)) e'_3\n                  (fun h =>\n                    Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), HEq e_3 (Eq.refl a) → HEq (a < a_1) (a' < a_1))\n                      (fun e_3 h => Eq.symm (eq_of_heq h) ▸ HEq.refl (a < a_1)) (Eq.symm h) e'_3)\n                  (Eq.refl a') (HEq.refl e'_3))\n              ℝ* Preorder.toLT (↑r) (↑(r + -r₂) + ↑r₂)\n              (of_eq_true (Eq.trans (congrArg (Eq ↑r) (neg_add_cancel_right ↑r ↑r₂)) (eq_self ↑r))) (x + y)))\n          (id (add_lt_add_of_lt_of_le (hip (r + -r₂)) (Iff.mp not_lt hr₂))))\n    (Eq.refl (Iff.mp not_forall hnin))","name":"Hyperreal.infinitePos_add_not_infiniteNeg","depth":50}],"kind":"Hyperreal.«termℝ*»","examples":[],"count":2}
{"noDocExamples":[{"term":"fun {n} {α} {f} {r} =>\n  id\n    (Eq.mpr (id (congrFun (congrArg Iff Mathlib.Data.List.Sort._auxLemma.5) (((fun x x_1 => x < x_1) ⇒ r) f f)))\n      (Eq.mpr\n        (id\n          (congrFun\n            (congrArg Iff\n              (forall_congr fun i =>\n                forall_congr fun j =>\n                  implies_congr (Eq.refl (i < j)) (congr (congrArg r (List.get_ofFn f i)) (List.get_ofFn f j))))\n            (((fun x x_1 => x < x_1) ⇒ r) f f)))\n        (id\n          (Iff.symm\n            (Function.Surjective.forall₂\n              (OrderIso.surjective\n                (Fin.castIso (of_eq_true (Eq.trans (congrFun (congrArg Eq (List.length_ofFn f)) n) (eq_self n))))))))))","name":"List.sorted_ofFn_iff","depth":46}],"kind":"Relator.«term_⇒_»","examples":[{"term":"fun {α} {β} [Preorder α] [Preorder β] f =>\n  { toFun := Quotient.map' ↑f (_ : (Setoid.r ⇒ Setoid.r) ↑f ↑f),\n    monotone' :=\n      (_ :\n        ∀ (a b : Antisymmetrization α fun x x_1 => x ≤ x_1),\n          a ≤ b →\n            Quotient.map' ↑f (_ : (Setoid.r ⇒ Setoid.r) ↑f ↑f) a ≤\n              Quotient.map' ↑f (_ : (Setoid.r ⇒ Setoid.r) ↑f ↑f) b) }","name":"OrderHom.antisymmetrization","doc":"Turns an order homomorphism from `α` to `β` into one from `Antisymmetrization α` to\n`Antisymmetrization β`. `Antisymmetrization` is actually a functor. See `Preorder_to_PartialOrder`.\n","depth":21}],"count":2}
{"noDocExamples":[],"kind":"«term_|||_»","examples":[{"term":"fun bs =>\n  if (ByteArray.size bs == 8) = true then\n    UInt8.toUInt64 (ByteArray.get! bs 0) <<< 56 ||| UInt8.toUInt64 (ByteArray.get! bs 1) <<< 48 |||\n                UInt8.toUInt64 (ByteArray.get! bs 2) <<< 40 |||\n              UInt8.toUInt64 (ByteArray.get! bs 3) <<< 32 |||\n            UInt8.toUInt64 (ByteArray.get! bs 4) <<< 24 |||\n          UInt8.toUInt64 (ByteArray.get! bs 5) <<< 16 |||\n        UInt8.toUInt64 (ByteArray.get! bs 6) <<< 8 |||\n      UInt8.toUInt64 (ByteArray.get! bs 7)\n  else\n    panicWithPosWithDecl \"Init.Data.ByteArray.Basic\" \"ByteArray.toUInt64LE!\" 198 2\n      (\"assertion violation: \" ++ \"bs.size == 8\\n  \")","name":"ByteArray.toUInt64LE!","doc":"Interpret a `ByteArray` of size 8 as a little-endian `UInt64`. ","depth":25},{"term":"fun bs =>\n  if (ByteArray.size bs == 8) = true then\n    UInt8.toUInt64 (ByteArray.get! bs 7) <<< 56 ||| UInt8.toUInt64 (ByteArray.get! bs 6) <<< 48 |||\n                UInt8.toUInt64 (ByteArray.get! bs 5) <<< 40 |||\n              UInt8.toUInt64 (ByteArray.get! bs 4) <<< 32 |||\n            UInt8.toUInt64 (ByteArray.get! bs 3) <<< 24 |||\n          UInt8.toUInt64 (ByteArray.get! bs 2) <<< 16 |||\n        UInt8.toUInt64 (ByteArray.get! bs 1) <<< 8 |||\n      UInt8.toUInt64 (ByteArray.get! bs 0)\n  else\n    panicWithPosWithDecl \"Init.Data.ByteArray.Basic\" \"ByteArray.toUInt64BE!\" 210 2\n      (\"assertion violation: \" ++ \"bs.size == 8\\n  \")","name":"ByteArray.toUInt64BE!","doc":"Interpret a `ByteArray` of size 8 as a big-endian `UInt64`. ","depth":25}],"count":2}
{"noDocExamples":[{"term":"Eq.mpr (id (Class.sInter._eq_1 ∅ ▸ Eq.refl (⋂₀ ∅ = Class.univ)))\n  (Eq.mpr (id (Class.classToCong_empty ▸ Eq.refl (⋂₀ Class.classToCong ∅ = Class.univ)))\n    (Eq.mpr (id (Set.sInter_empty ▸ Eq.refl (⋂₀ ∅ = Class.univ)))\n      (Eq.mpr (id (Class.univ._eq_1 ▸ Eq.refl (Set.univ = Class.univ))) (Eq.refl Set.univ))))","name":"Class.sInter_empty","depth":18},{"term":"fun {x y} h =>\n  { mp := fun hy z => Class.mem_of_mem_sInter hy,\n    mpr := fun H =>\n      Eq.mpr (id (Mathlib.SetTheory.ZFC.Basic._auxLemma.64 y (⋂₀ x)))\n        (Eq.mpr\n          (id (congrArg Exists (funext fun x_1 => congrArg (And (↑x_1 = y)) Mathlib.SetTheory.ZFC.Basic._auxLemma.65)))\n          (Exists.casesOn h fun z hz =>\n            Exists.casesOn (H (↑z) (Iff.mpr Class.coe_mem hz)) fun y_1 h =>\n              And.casesOn h fun left right =>\n                Eq.ndrec (motive := fun {y} =>\n                  (∀ (z : Class), z ∈ x → y ∈ z) → ∃ x_1, ↑x_1 = y ∧ ∀ (z : ZFSet), x z → x_1 ∈ z)\n                  (fun H =>\n                    Exists.intro y_1\n                      { left := rfl,\n                        right := fun w hxw =>\n                          Eq.mp\n                            (Eq.trans Mathlib.SetTheory.ZFC.Basic._auxLemma.51 Mathlib.SetTheory.ZFC.Basic._auxLemma.52)\n                            (H (↑w) (Iff.mpr Class.coe_mem hxw)) })\n                  left H)) }","name":"Class.mem_sInter","depth":37}],"kind":"Class.«term⋂₀_»","examples":[],"count":2}
{"noDocExamples":[{"term":"fun M [Monoid M] A [AddMonoid A] [DistribMulAction M A] B [AddMonoid B] [DistribMulAction M B] =>\n  DistribMulActionHomClass.mk\n    (_ :\n      ∀ (self : A →+[M] B) (x y : A),\n        MulActionHom.toFun self.toMulActionHom (x + y) =\n          MulActionHom.toFun self.toMulActionHom x + MulActionHom.toFun self.toMulActionHom y)\n    (_ : ∀ (self : A →+[M] B), MulActionHom.toFun self.toMulActionHom 0 = 0)","name":"DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom","depth":28},{"term":"fun {M} {A} {N} {B} [Monoid M] [AddMonoid A] [DistribMulAction M A] [Monoid N] [AddMonoid B] [DistribMulAction N A]\n    [SMulCommClass M N A] [DistribMulAction N B] =>\n  Function.Injective.mulAction (fun f => ↑f) (_ : Function.Injective fun f => ↑f)\n    (_ : ∀ (x : Mᵈᵐᵃ) (x_1 : A →+[N] B), ↑(x • x_1) = ↑(x • x_1))","name":"DomMulAct.instMulActionDomMulActDistribMulActionHomInstMonoidDomMulActMonoid","depth":37}],"kind":"«DistribMulActionHomLocal≺»","examples":[],"count":2}
{"noDocExamples":[{"term":"fun {n} {E} [NormedAddCommGroup E] [NormedSpace ℂ E] {f g} {c} {R} hf hg =>\n  Eq.mpr\n    (id\n      (congr\n        (congrArg Eq (congrFun (congrFun (congrArg torusIntegral (funext fun x => sub_eq_add_neg (f x) (g x))) c) R))\n        (Eq.trans (sub_eq_add_neg (∯ (x : Fin n → ℂ) in T(c, R), f x) (∯ (x : Fin n → ℂ) in T(c, R), g x))\n          (congrArg (HAdd.hAdd (∯ (x : Fin n → ℂ) in T(c, R), f x))\n            (Mathlib.MeasureTheory.Integral.TorusIntegral._auxLemma.4 (fun x => g x) c R)))))\n    (torusIntegral_add hf (TorusIntegrable.neg hg))","name":"torusIntegral_sub","depth":35}],"kind":"«term∯_InT(_,_),_»","examples":[{"term":"fun {n} {E} [NormedAddCommGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f} {c} {R} hf =>\n  Eq.mp\n    (congrArg (Eq (∯ (x : Fin (n + 1) → ℂ) in T(c, R), f x))\n      (congrFun\n        (congrFun\n          (congrArg circleIntegral\n            (funext fun x =>\n              congrFun\n                (congrFun (congrArg torusIntegral (funext fun y => congrArg f (Fin.insertNth_zero' x y)))\n                  (c ∘ Fin.succ))\n                (R ∘ Fin.succ)))\n          (c 0))\n        (R 0)))\n    (torusIntegral_succAbove hf 0)","name":"torusIntegral_succ","doc":"Recurrent formula for `torusIntegral`, see also `torusIntegral_succAbove`. ","depth":43}],"count":2}
{"noDocExamples":[{"term":"fun {E} [NormedAddCommGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E] [MeasureTheory.MeasureSpace E] [BorelSpace E]\n    [MeasureTheory.Measure.IsAddHaarMeasure MeasureTheory.volume] {r} hnr =>\n  { left := Measurable.aestronglyMeasurable (Measurable.pow_const (Measurable.const_add measurable_norm 1) (-r)),\n    right :=\n      let_fun this :=\n        MeasureTheory.lintegral_nnnorm_eq_of_nonneg fun x =>\n          Real.rpow_nonneg_of_nonneg\n            (le_of_lt\n              (lt_add_of_pos_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                  (Eq.refl (Nat.ble 1 1)))\n                (norm_nonneg x)))\n            (-r);\n      Eq.mpr\n        (id\n          (propext (MeasureTheory.hasFiniteIntegral_def (fun x => (1 + ‖x‖) ^ (-r)) MeasureTheory.volume) ▸\n            Eq.refl (MeasureTheory.HasFiniteIntegral fun x => (1 + ‖x‖) ^ (-r))))\n        (Eq.mpr (id (this ▸ Eq.refl (∫⁻ (a : E), ↑‖(1 + ‖a‖) ^ (-r)‖₊ < ⊤))) (finite_integral_one_add_norm hnr)) }","name":"integrable_one_add_norm","depth":38},{"term":"fun {Ω} {m} {ℙ} [MeasureTheory.IsFiniteMeasure ℙ] {X} {f} {g} hg hgi =>\n  Eq.mpr\n    (id\n      (propext\n          (MeasureTheory.hasFiniteIntegral_def (fun x => f x * ENNReal.toReal (MeasureTheory.pdf X ℙ x))\n            MeasureTheory.volume) ▸\n        Eq.refl (MeasureTheory.HasFiniteIntegral fun x => f x * ENNReal.toReal (MeasureTheory.pdf X ℙ x))))\n    (let_fun this :=\n      MeasureTheory.ae_eq_trans\n        (Filter.EventuallyEq.mul (MeasureTheory.ae_eq_refl fun x => ↑‖f x‖₊)\n          (MeasureTheory.ae_eq_trans (Filter.EventuallyEq.symm hg)\n            (Filter.EventuallyEq.symm MeasureTheory.pdf.ofReal_toReal_ae_eq)))\n        (id\n          (Eq.mpr\n            (id\n              (congrArg\n                (Filter.EventuallyEq (MeasureTheory.Measure.ae MeasureTheory.volume) fun x =>\n                  ↑‖f x‖₊ • ENNReal.ofReal (ENNReal.toReal (MeasureTheory.pdf X ℙ x)))\n                (funext fun x => congrArg ENNReal.some (nnnorm_smul (f x) (ENNReal.toReal (MeasureTheory.pdf X ℙ x))))))\n            (Eq.mpr\n              (id\n                (congrArg\n                  (Filter.EventuallyEq (MeasureTheory.Measure.ae MeasureTheory.volume) fun x =>\n                    ↑‖f x‖₊ • ENNReal.ofReal (ENNReal.toReal (MeasureTheory.pdf X ℙ x)))\n                  (funext fun x => ENNReal.coe_mul)))\n              (id\n                (Filter.EventuallyEq.mul (MeasureTheory.ae_eq_refl fun x => ↑‖f x‖₊)\n                  (of_eq_true\n                    (Eq.trans\n                      (congrArg\n                        (Filter.EventuallyEq (MeasureTheory.Measure.ae MeasureTheory.volume) fun x =>\n                          ENNReal.ofReal (ENNReal.toReal (MeasureTheory.pdf X ℙ x)))\n                        (funext fun x =>\n                          (fun x_0 => (fun x_0 => Real.ennnorm_eq_ofReal ENNReal.toReal_nonneg) x_0)\n                            (MeasureTheory.pdf X ℙ x)))\n                      (Mathlib.Probability.Density._auxLemma.2 fun x =>\n                        ENNReal.ofReal (ENNReal.toReal (MeasureTheory.pdf X ℙ x))))))))));\n    Eq.mpr\n      (id (propext lt_top_iff_ne_top ▸ Eq.refl (∫⁻ (a : ℝ), ↑‖f a * ENNReal.toReal (MeasureTheory.pdf X ℙ a)‖₊ < ⊤)))\n      (Eq.mpr\n        (id\n          (Eq.symm (MeasureTheory.lintegral_congr_ae this) ▸\n            Eq.refl (∫⁻ (a : ℝ), ↑‖f a * ENNReal.toReal (MeasureTheory.pdf X ℙ a)‖₊ ≠ ⊤)))\n        hgi))","name":"MeasureTheory.pdf.hasFiniteIntegral_mul","depth":44}],"kind":"MeasureTheory.«term∫⁻_,_»","examples":[],"count":2}
{"noDocExamples":[{"term":"fun {R} {E} [Semiring R] [SeminormedAddCommGroup E] [Module R E] =>\n  Monoid.mk (_ : ∀ (f : E →ₗᵢ[R] E), LinearIsometry.comp LinearIsometry.id f = f)\n    (_ : ∀ (f : E →ₗᵢ[R] E), LinearIsometry.comp f LinearIsometry.id = f) npowRec","name":"LinearIsometry.instMonoidLinearIsometryIdToNonAssocSemiring","depth":34}],"kind":"«term_→ₗᵢ[_]_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun M [Monoid M] R [Semiring R] [MulSemiringAction M R] S [Semiring S] [MulSemiringAction M S] =>\n  MulSemiringActionHomClass.mk\n    (_ :\n      ∀ (self : R →+*[M] S) (x y : R),\n        MulActionHom.toFun self.toMulActionHom (x * y) =\n          MulActionHom.toFun self.toMulActionHom x * MulActionHom.toFun self.toMulActionHom y)\n    (_ : ∀ (self : R →+*[M] S), MulActionHom.toFun self.toMulActionHom 1 = 1)","name":"MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction","depth":32}],"kind":"«MulSemiringActionHomLocal≺»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {α} {β} [Preorder α] [Preorder β] [MulZeroOneClass α] [MulZeroOneClass β] =>\n  OrderMonoidWithZeroHomClass.mk (_ : ∀ (f : α →*₀o β), Monotone f.toFun)","name":"OrderMonoidWithZeroHom.instOrderMonoidWithZeroHomClassOrderMonoidWithZeroHom","depth":26}],"kind":"«term_→*₀o_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {α} {β} [TopologicalSpace α] [Preorder α] [TopologicalSpace β] [Preorder β] =>\n  ContinuousOrderHomClass.mk (_ : ∀ (f : α →Co β), Monotone f.toFun)","name":"ContinuousOrderHom.instContinuousOrderHomClassContinuousOrderHom","depth":21}],"kind":"«term_→Co_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {α α'} {β} {β'} {f} {f'} hα h =>\n  Eq.ndrec (motive := fun {α'} =>\n    ∀ {β' : α' → Sort v} {f' : (a : α') → β' a}, (∀ (a : α) (a' : α'), HEq a a' → HEq (f a) (f' a')) → HEq f f')\n    (fun {β'} {f'} h =>\n      let_fun this := fun a => h a a (HEq.refl a);\n      let_fun this_1 := funext fun a => type_eq_of_heq (this a);\n      Eq.ndrec (motive := fun {β'} =>\n        ∀ {f' : (a : α) → β' a},\n          (∀ (a a' : α), HEq a a' → HEq (f a) (f' a')) → (∀ (a : α), HEq (f a) (f' a)) → HEq f f')\n        (fun {f'} h this => heq_of_eq (funext fun a => eq_of_heq (this a))) this_1 h this)\n    hα h","name":"Function.hfunext","depth":41}],"kind":"Lean.Parser.Term.sort","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {α} [SemilatticeInf α] s t =>\n  let_fun this :=\n    of_eq_true\n      (Eq.trans\n        (congrFun (congrArg Eq (Set.image_uncurry_prod (fun x x_1 => x ⊓ x_1) s t))\n          (Set.image2 (fun x x_1 => x ⊓ x_1) s t))\n        (eq_self (Set.image2 (fun x x_1 => x ⊓ x_1) s t)));\n  Eq.mpr (id (Eq.symm this ▸ Eq.refl (Set.image2 (fun x x_1 => x ⊓ x_1) s t = s ⊼ t)))\n    (Set.image_uncurry_prod (fun x x_1 => x ⊓ x_1) s t)","name":"Set.image_inf_prod","depth":30}],"kind":"«term_⊼_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {R} {A} {B} [Add A] [Add B] [Mul A] [Mul B] [SMul R A] [SMul R B] [Star A] [Star B] =>\n  StarAlgEquivClass.mk\n    (_ : ∀ (self : A ≃⋆ₐ[R] B) (a : A), Equiv.toFun self.toEquiv (star a) = star (Equiv.toFun self.toEquiv a))\n    (_ : ∀ (self : A ≃⋆ₐ[R] B) (r : R) (a : A), Equiv.toFun self.toEquiv (r • a) = r • Equiv.toFun self.toEquiv a)","name":"StarAlgEquiv.instStarAlgEquivClassStarAlgEquiv","depth":38}],"kind":"«term_≃⋆ₐ[_]_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {𝕜} {V} {V₂} {P} {P₂} [NormedField 𝕜] [SeminormedAddCommGroup V] [SeminormedAddCommGroup V₂] [NormedSpace 𝕜 V]\n    [NormedSpace 𝕜 V₂] [PseudoMetricSpace P] [PseudoMetricSpace P₂] [NormedAddTorsor V P] [NormedAddTorsor V₂ P₂] =>\n  { coe := fun f => f.toFun, inv := fun f => f.invFun,\n    left_inv := (_ : ∀ (f : P ≃ᵃⁱ[𝕜] P₂), Function.LeftInverse f.invFun f.toFun),\n    right_inv := (_ : ∀ (f : P ≃ᵃⁱ[𝕜] P₂), Function.RightInverse f.invFun f.toFun),\n    coe_injective' :=\n      (_ :\n        ∀ (f g : P ≃ᵃⁱ[𝕜] P₂),\n          (fun f => f.toFun) f = (fun f => f.toFun) g → (fun f => f.invFun) f = (fun f => f.invFun) g → f = g) }","name":"AffineIsometryEquiv.instEquivLikeAffineIsometryEquiv","depth":37}],"kind":"«term_≃ᵃⁱ[_]_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {α} {β} [UniformSpace α] [UniformSpace β] =>\n  { coe := fun h => ↑h.toEquiv, inv := fun h => ↑h.symm,\n    left_inv := (_ : ∀ (h : α ≃ᵤ β), Function.LeftInverse h.invFun h.toFun),\n    right_inv := (_ : ∀ (h : α ≃ᵤ β), Function.RightInverse h.invFun h.toFun),\n    coe_injective' :=\n      (_ :\n        ∀ (x x_1 : α ≃ᵤ β),\n          (fun h => ↑h.toEquiv) x = (fun h => ↑h.toEquiv) x_1 →\n            (fun h => ↑h.symm) x = (fun h => ↑h.symm) x_1 → x = x_1) }","name":"UniformEquiv.instEquivLikeUniformEquiv","depth":17}],"kind":"«term_≃ᵤ_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {R} {R₂} {E} {E₂} [Semiring R] [Semiring R₂] {σ₁₂} [SeminormedAddCommGroup E] [SeminormedAddCommGroup E₂]\n    [Module R E] [Module R₂ E₂] =>\n  SemilinearIsometryClass.mk (_ : ∀ (f : E →ₛₗᵢ[σ₁₂] E₂) (x : E), ‖↑f.toLinearMap x‖ = ‖x‖)","name":"LinearIsometry.instSemilinearIsometryClassLinearIsometry","depth":38}],"kind":"«term_→ₛₗᵢ[_]_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {α} {β} [Preorder α] [Preorder β] [MulOneClass α] [MulOneClass β] =>\n  OrderMonoidHomClass.mk (_ : ∀ (f : α →*o β), Monotone f.toFun)","name":"OrderMonoidHom.instOrderMonoidHomClassOrderMonoidHom","depth":24}],"kind":"«term_→*o_»","examples":[],"count":1}
{"noDocExamples":[],"kind":"Prefunctor.«term_⥤q_»","examples":[{"term":"fun {α} {β} =>\n  { toFun := fun f => { obj := id, map := fun {X Y} => f }, invFun := fun f a => f.map (↑Quiver.SingleObj.toHom a),\n    left_inv :=\n      (_ :\n        ∀ (x : α → β),\n          (fun f a => f.map (↑Quiver.SingleObj.toHom a)) ((fun f => { obj := id, map := fun {X Y} => f }) x) =\n            (fun f a => f.map (↑Quiver.SingleObj.toHom a)) ((fun f => { obj := id, map := fun {X Y} => f }) x)),\n    right_inv :=\n      (_ :\n        ∀ (x : Quiver.SingleObj α ⥤q Quiver.SingleObj β),\n          (fun f => { obj := id, map := fun {X Y} => f }) ((fun f a => f.map (↑Quiver.SingleObj.toHom a)) x) =\n            (fun f => { obj := id, map := fun {X Y} => f }) ((fun f a => f.map (↑Quiver.SingleObj.toHom a)) x)) }","name":"Quiver.SingleObj.toPrefunctor","doc":"Prefunctors between two `SingleObj` quivers correspond to functions between the corresponding\narrows types.\n","depth":20}],"count":1}
{"noDocExamples":[{"term":"fun x =>\n  Set.ext fun x_1 =>\n    of_eq_true\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (Mathlib.SetTheory.ZFC.Basic._auxLemma.1 x_1 (⋃₀ x)) Mathlib.SetTheory.ZFC.Basic._auxLemma.7))\n          (Eq.trans\n            (Eq.trans\n              (congrArg (Membership.mem x_1)\n                (Eq.trans (Set.sUnion_image PSet.toSet (PSet.toSet x))\n                  (congrArg Set.iUnion\n                    (funext fun x_2 =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Mathlib.SetTheory.ZFC.Basic._auxLemma.1 x_2 x)) fun x =>\n                        Eq.refl (PSet.toSet x_2)))))\n              Mathlib.Data.Set.Lattice._auxLemma.3)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans\n                  (Eq.trans Mathlib.Data.Set.Lattice._auxLemma.3\n                    (exists_prop_congr' (fun h => Iff.of_eq (Mathlib.SetTheory.ZFC.Basic._auxLemma.1 x_1 i))\n                      (Iff.of_eq (Eq.refl (i ∈ x)))))\n                  Std.Logic._auxLemma.51))))\n        (iff_self (∃ z, z ∈ x ∧ x_1 ∈ z)))","name":"PSet.toSet_sUnion","depth":27}],"kind":"PSet.«term⋃₀_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {L} {L'} [FirstOrder.Language.IsAlgebraic L] [FirstOrder.Language.IsRelational L] =>\n  { toInhabited := { default := FirstOrder.Language.LHom.ofIsEmpty L L' }, uniq := (_ : ∀ (x : L →ᴸ L'), x = default) }","name":"FirstOrder.Language.LHom.instUniqueLHom","depth":11}],"kind":"FirstOrder.Language.«term_→ᴸ_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {M} {N} [MulZeroOneClass M] [MulZeroOneClass N] =>\n  MonoidWithZeroHomClass.mk (_ : ∀ (f : M →*₀ N), ZeroHom.toFun (↑f) 0 = 0)","name":"MonoidWithZeroHom.monoidWithZeroHomClass","depth":19}],"kind":"«term_→*₀_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {α} {β} [Preorder α] [Preorder β] [AddZeroClass α] [AddZeroClass β] =>\n  OrderAddMonoidHomClass.mk (_ : ∀ (f : α →+o β), Monotone f.toFun)","name":"OrderAddMonoidHom.instOrderAddMonoidHomClassOrderAddMonoidHom","depth":24}],"kind":"«term_→+o_»","examples":[],"count":1}
{"noDocExamples":[],"kind":"«term_≤₁_»","examples":[{"term":"fun {α} {β} [Primcodable α] [Primcodable β] p q => p ≤₁ q ∧ q ≤₁ p","name":"OneOneEquiv","doc":"`p` and `q` are one-one equivalent if each one is one-one reducible to the other. ","depth":14}],"count":1}
{"noDocExamples":[{"term":"fun {α} {β} [NonAssocSemiring α] [Preorder α] [NonAssocSemiring β] [Preorder β] =>\n  OrderRingHomClass.mk (_ : ∀ (f : α →+*o β), Monotone f.toFun)","name":"OrderRingHom.instOrderRingHomClassOrderRingHom","depth":28}],"kind":"«term_→+*o_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {α} {m} {μ} {f g} hg hfi h_le h =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_lt_eq (∫⁻ (x : α), f x ∂μ) (∫⁻ (x : α), g x ∂μ))\n          (Eq.refl ¬∃ᵐ (x : α) ∂μ, f x ≠ g x)))\n      fun h =>\n      Eq.mpr\n        (id\n          (Eq.trans Mathlib.MeasureTheory.Integral.Lebesgue._auxLemma.28\n            (congrFun\n              (congrArg Filter.Eventually (funext fun x => Mathlib.MeasureTheory.Integral.Lebesgue._auxLemma.27))\n              (MeasureTheory.Measure.ae μ))))\n        (MeasureTheory.ae_eq_of_ae_le_of_lintegral_le h_le hfi hg h))\n    h","name":"MeasureTheory.lintegral_strict_mono_of_ae_le_of_frequently_ae_lt","depth":31}],"kind":"MeasureTheory.«term∃ᵐ_∂_,_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {ι} {ι₂} R [CommSemiring R] M [AddCommMonoid M] [Module R M] =>\n  PiTensorProduct.ext\n    (MultilinearMap.ext fun x =>\n      let_fun this :=\n        Eq.mpr\n          (id\n            (congrFun\n              (congrArg Eq\n                (Eq.trans (congrArg (↑PiTensorProduct.tmul) (PiTensorProduct.tmulSymm_apply fun i => x i))\n                  (PiTensorProduct.tmul_apply (fun i => x (Sum.inl i)) fun i => x (Sum.inr i))))\n              (↑(PiTensorProduct.tprod R) x)))\n          (Eq.mpr\n            (id\n              (Sum.elim_comp_inl_inr x ▸\n                Eq.refl\n                  ((⨂ₜ[R] (i : ι ⊕ ι₂), Sum.elim (fun i => x (Sum.inl i)) (fun i => x (Sum.inr i)) i) =\n                    ↑(PiTensorProduct.tprod R) x)))\n            (Eq.refl (⨂ₜ[R] (i : ι ⊕ ι₂), x i)));\n      this)","name":"PiTensorProduct.tmulEquiv.proof_2","depth":47}],"kind":"PiTensorProduct.«term⨂ₜ[_]_,_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {α} {β} [TopologicalSpace α] [TopologicalSpace β] =>\n  ContinuousOpenMapClass.mk (_ : ∀ (f : α →CO β), IsOpenMap f.toFun)","name":"ContinuousOpenMap.instContinuousOpenMapClassContinuousOpenMap","depth":17}],"kind":"«term_→CO_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {R} {L} {M} {N} [CommRing R] [LieRing L] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]\n    [LieRingModule L M] [LieRingModule L N] =>\n  { coe := fun f => f.toFun, inv := fun f => f.invFun,\n    left_inv := (_ : ∀ (f : M ≃ₗ⁅R,L⁆ N), Function.LeftInverse f.invFun f.toFun),\n    right_inv := (_ : ∀ (f : M ≃ₗ⁅R,L⁆ N), Function.RightInverse f.invFun f.toFun),\n    coe_injective' :=\n      (_ :\n        ∀ (f g : M ≃ₗ⁅R,L⁆ N),\n          (fun f => f.toFun) f = (fun f => f.toFun) g → (fun f => f.invFun) f = (fun f => f.invFun) g → f = g) }","name":"LieModuleEquiv.instEquivLikeLieModuleEquiv","depth":34}],"kind":"«term_≃ₗ⁅_,_⁆_»","examples":[],"count":1}
{"noDocExamples":[],"kind":"«term_⊇_»","examples":[{"term":"fun {α} [TopologicalSpace α] {ι} [hι : Nonempty ι] Z hZd hZn hZc hZcl =>\n  let i₀ := Nonempty.some hι;\n  let_fun this :=\n    Eq.mpr (id Mathlib.Topology.SubsetProperties._auxLemma.13)\n      (mt (IsCompact.elim_directed_family_closed (hZc i₀) Z hZcl)\n        (Eq.mpr\n          (id\n            (Eq.trans (Mathlib.Tactic.PushNeg.not_implies_eq (Directed (fun x x_1 => x ⊇ x_1) Z) (∃ i, Z i₀ ∩ Z i = ∅))\n              (congrArg (And (Directed (fun x x_1 => x ⊇ x_1) Z))\n                (Mathlib.Tactic.PushNeg.not_exists_eq fun i => Z i₀ ∩ Z i = ∅))))\n          (Eq.mpr\n            (id\n              (congrArg (And (Directed (fun x x_1 => x ⊇ x_1) Z))\n                (forall_congr fun i => Mathlib.Topology.SubsetProperties._auxLemma.14)))\n            { left := hZd,\n              right := fun i =>\n                Exists.casesOn (hZd i₀ i) fun j h =>\n                  And.casesOn h fun hji₀ hji =>\n                    Set.Nonempty.mono (Set.subset_inter hji₀ hji)\n                      (Eq.mp (forall_congr fun i => Mathlib.Topology.SubsetProperties._auxLemma.14)\n                        (Eq.mp (forall_congr fun i => Mathlib.Topology.SubsetProperties._auxLemma.13) hZn) j) })));\n  Eq.mp\n    (Iff.mpr Set.inter_eq_right_iff_subset (Set.iInter_subset Z i₀) ▸ Eq.refl (Set.Nonempty (Z i₀ ∩ ⋂ (i : ι), Z i)))\n    this","name":"IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed","doc":"Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. ","depth":36}],"count":1}
{"noDocExamples":[],"kind":"Class.«term⋃₀_»","examples":[{"term":"fun A => ⋃₀ {x | ∀ (y : ZFSet), A y ↔ y = x}","name":"Class.iota","doc":"The definite description operator, which is `{x}` if `{y | A y} = {x}` and `∅` otherwise. ","depth":9}],"count":1}
{"noDocExamples":[],"kind":"«term_≺i_»","examples":[{"term":"fun {α β} h =>\n  let_fun this :=\n    WellOrder.casesOn (motive := fun t =>\n      Quotient.out α = t →\n        Quotient.mk Ordinal.isEquivalent (Quotient.out α) < Quotient.mk Ordinal.isEquivalent (Quotient.out β) →\n          (Quotient.out α).r ≺i (Quotient.out β).r)\n      (Quotient.out α)\n      (fun α_1 r wo h =>\n        Eq.ndrec (motive := fun x =>\n          Quotient.mk Ordinal.isEquivalent x < Quotient.mk Ordinal.isEquivalent (Quotient.out β) →\n            x.r ≺i (Quotient.out β).r)\n          (WellOrder.casesOn (motive := fun t =>\n            Quotient.out β = t →\n              Quotient.mk Ordinal.isEquivalent { α := α_1, r := r, wo := wo } <\n                  Quotient.mk Ordinal.isEquivalent (Quotient.out β) →\n                { α := α_1, r := r, wo := wo }.r ≺i (Quotient.out β).r)\n            (Quotient.out β)\n            (fun α r_1 wo_1 h =>\n              Eq.ndrec (motive := fun x =>\n                Quotient.mk Ordinal.isEquivalent { α := α_1, r := r, wo := wo } < Quotient.mk Ordinal.isEquivalent x →\n                  { α := α_1, r := r, wo := wo }.r ≺i x.r)\n                Classical.choice (_ : { α := α, r := r_1, wo := wo_1 } = Quotient.out β))\n            (_ : Quotient.out β = Quotient.out β))\n          (_ : { α := α_1, r := r, wo := wo } = Quotient.out α))\n      (_ : Quotient.out α = Quotient.out α)\n      (_ : Quotient.mk Ordinal.isEquivalent (Quotient.out α) < Quotient.mk Ordinal.isEquivalent (Quotient.out β));\n  this","name":"Ordinal.principalSegOut","doc":"Given two ordinals `α < β`, then `principalSegOut α β` is the principal segment embedding\nof `α` to `β`, as map from a model type for `α` to a model type for `β`. ","depth":35}],"count":1}
{"noDocExamples":[{"term":"fun {R} {L₁} {L₂} [CommRing R] [LieRing L₁] [LieRing L₂] [LieAlgebra R L₁] [LieAlgebra R L₂] =>\n  { coe := fun f => f.toFun, inv := fun f => f.invFun,\n    left_inv := (_ : ∀ (f : L₁ ≃ₗ⁅R⁆ L₂), Function.LeftInverse f.invFun f.toFun),\n    right_inv := (_ : ∀ (f : L₁ ≃ₗ⁅R⁆ L₂), Function.RightInverse f.invFun f.toFun),\n    coe_injective' :=\n      (_ :\n        ∀ (f g : L₁ ≃ₗ⁅R⁆ L₂),\n          (fun f => f.toFun) f = (fun f => f.toFun) g → (fun f => f.invFun) f = (fun f => f.invFun) g → f = g) }","name":"LieEquiv.instEquivLikeLieEquiv","depth":28}],"kind":"«term_≃ₗ⁅_⁆_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {α} {β} [Mul α] [Add α] [LE α] [Mul β] [Add β] [LE β] =>\n  OrderRingIsoClass.mk (_ : ∀ (f : α ≃+*o β) (x x_1 : α), Equiv.toFun f.toEquiv x ≤ Equiv.toFun f.toEquiv x_1 ↔ x ≤ x_1)","name":"OrderRingIso.instOrderRingIsoClassOrderRingIso","depth":31}],"kind":"«term_≃+*o_»","examples":[],"count":1}
{"noDocExamples":[],"kind":"Matrix.termGL","examples":[{"term":"fun {n} [DecidableEq n] [Fintype n] {R} [CommRing R] =>\n  {\n    toOneHom :=\n      {\n        toFun := fun A =>\n          { val := Matrix.det ↑A, inv := Matrix.det ↑A⁻¹, val_inv := (_ : Matrix.det ↑A * Matrix.det ↑A⁻¹ = 1),\n            inv_val := (_ : Matrix.det ↑A⁻¹ * Matrix.det ↑A = 1) },\n        map_one' :=\n          (_ :\n            (fun A =>\n                  { val := Matrix.det ↑A, inv := Matrix.det ↑A⁻¹, val_inv := (_ : Matrix.det ↑A * Matrix.det ↑A⁻¹ = 1),\n                    inv_val := (_ : Matrix.det ↑A⁻¹ * Matrix.det ↑A = 1) })\n                1 =\n              1) },\n    map_mul' :=\n      (_ :\n        ∀ (A B : GL n R),\n          OneHom.toFun\n              {\n                toFun := fun A =>\n                  { val := Matrix.det ↑A, inv := Matrix.det ↑A⁻¹, val_inv := (_ : Matrix.det ↑A * Matrix.det ↑A⁻¹ = 1),\n                    inv_val := (_ : Matrix.det ↑A⁻¹ * Matrix.det ↑A = 1) },\n                map_one' :=\n                  (_ :\n                    (fun A =>\n                          { val := Matrix.det ↑A, inv := Matrix.det ↑A⁻¹,\n                            val_inv := (_ : Matrix.det ↑A * Matrix.det ↑A⁻¹ = 1),\n                            inv_val := (_ : Matrix.det ↑A⁻¹ * Matrix.det ↑A = 1) })\n                        1 =\n                      1) }\n              (A * B) =\n            OneHom.toFun\n                {\n                  toFun := fun A =>\n                    { val := Matrix.det ↑A, inv := Matrix.det ↑A⁻¹,\n                      val_inv := (_ : Matrix.det ↑A * Matrix.det ↑A⁻¹ = 1),\n                      inv_val := (_ : Matrix.det ↑A⁻¹ * Matrix.det ↑A = 1) },\n                  map_one' :=\n                    (_ :\n                      (fun A =>\n                            { val := Matrix.det ↑A, inv := Matrix.det ↑A⁻¹,\n                              val_inv := (_ : Matrix.det ↑A * Matrix.det ↑A⁻¹ = 1),\n                              inv_val := (_ : Matrix.det ↑A⁻¹ * Matrix.det ↑A = 1) })\n                          1 =\n                        1) }\n                A *\n              OneHom.toFun\n                {\n                  toFun := fun A =>\n                    { val := Matrix.det ↑A, inv := Matrix.det ↑A⁻¹,\n                      val_inv := (_ : Matrix.det ↑A * Matrix.det ↑A⁻¹ = 1),\n                      inv_val := (_ : Matrix.det ↑A⁻¹ * Matrix.det ↑A = 1) },\n                  map_one' :=\n                    (_ :\n                      (fun A =>\n                            { val := Matrix.det ↑A, inv := Matrix.det ↑A⁻¹,\n                              val_inv := (_ : Matrix.det ↑A * Matrix.det ↑A⁻¹ = 1),\n                              inv_val := (_ : Matrix.det ↑A⁻¹ * Matrix.det ↑A = 1) })\n                          1 =\n                        1) }\n                B) }","name":"Matrix.GeneralLinearGroup.det","doc":"The determinant of a unit matrix is itself a unit. ","depth":29}],"count":1}
{"noDocExamples":[],"kind":"«term_≃L[_]_»","examples":[{"term":"fun R [Ring R] M [TopologicalSpace M] [AddCommGroup M] [Module R M] =>\n  {\n    toEquiv :=\n      { toFun := ContinuousLinearEquiv.ofUnit, invFun := ContinuousLinearEquiv.toUnit,\n        left_inv := (_ : ∀ (f : (M →L[R] M)ˣ), ContinuousLinearEquiv.toUnit (ContinuousLinearEquiv.ofUnit f) = f),\n        right_inv := (_ : ∀ (f : M ≃L[R] M), ContinuousLinearEquiv.ofUnit (ContinuousLinearEquiv.toUnit f) = f) },\n    map_mul' :=\n      (_ :\n        ∀ (x y : (M →L[R] M)ˣ),\n          Equiv.toFun\n              { toFun := ContinuousLinearEquiv.ofUnit, invFun := ContinuousLinearEquiv.toUnit,\n                left_inv :=\n                  (_ : ∀ (f : (M →L[R] M)ˣ), ContinuousLinearEquiv.toUnit (ContinuousLinearEquiv.ofUnit f) = f),\n                right_inv :=\n                  (_ : ∀ (f : M ≃L[R] M), ContinuousLinearEquiv.ofUnit (ContinuousLinearEquiv.toUnit f) = f) }\n              (x * y) =\n            Equiv.toFun\n                { toFun := ContinuousLinearEquiv.ofUnit, invFun := ContinuousLinearEquiv.toUnit,\n                  left_inv :=\n                    (_ : ∀ (f : (M →L[R] M)ˣ), ContinuousLinearEquiv.toUnit (ContinuousLinearEquiv.ofUnit f) = f),\n                  right_inv :=\n                    (_ : ∀ (f : M ≃L[R] M), ContinuousLinearEquiv.ofUnit (ContinuousLinearEquiv.toUnit f) = f) }\n                x *\n              Equiv.toFun\n                { toFun := ContinuousLinearEquiv.ofUnit, invFun := ContinuousLinearEquiv.toUnit,\n                  left_inv :=\n                    (_ : ∀ (f : (M →L[R] M)ˣ), ContinuousLinearEquiv.toUnit (ContinuousLinearEquiv.ofUnit f) = f),\n                  right_inv :=\n                    (_ : ∀ (f : M ≃L[R] M), ContinuousLinearEquiv.ofUnit (ContinuousLinearEquiv.toUnit f) = f) }\n                y) }","name":"ContinuousLinearEquiv.unitsEquiv","doc":"The units of the algebra of continuous `R`-linear endomorphisms of `M` is multiplicatively\nequivalent to the type of continuous linear equivalences between `M` and itself. ","depth":30}],"count":1}
{"noDocExamples":[{"term":"fun {α} [SemilatticeSup α] s t =>\n  let_fun this :=\n    of_eq_true\n      (Eq.trans\n        (congrFun (congrArg Eq (Set.image_uncurry_prod (fun x x_1 => x ⊔ x_1) s t))\n          (Set.image2 (fun x x_1 => x ⊔ x_1) s t))\n        (eq_self (Set.image2 (fun x x_1 => x ⊔ x_1) s t)));\n  Eq.mpr (id (Eq.symm this ▸ Eq.refl (Set.image2 (fun x x_1 => x ⊔ x_1) s t = s ⊻ t)))\n    (Set.image_uncurry_prod (fun x x_1 => x ⊔ x_1) s t)","name":"Set.image_sup_prod","depth":30}],"kind":"«term_⊻_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {R} {R₂} {E} {E₂} [Semiring R] [Semiring R₂] {σ₁₂} {σ₂₁} [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂]\n    [SeminormedAddCommGroup E] [SeminormedAddCommGroup E₂] [Module R E] [Module R₂ E₂] =>\n  SemilinearIsometryEquivClass.mk (_ : ∀ (e : E ≃ₛₗᵢ[σ₁₂] E₂) (x : E), ‖↑e.toLinearEquiv x‖ = ‖x‖)","name":"LinearIsometryEquiv.instSemilinearIsometryEquivClassLinearIsometryEquiv","depth":47}],"kind":"«term_≃ₛₗᵢ[_]_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun x h y yx =>\n  id\n    (Eq.mpr (id (ZFSet.map_fval yx ▸ Eq.refl (↑(ZFSet.map (fun y => Classical.epsilon fun z => z ∈ y) x) ′ ↑y ∈ ↑y)))\n      (Eq.mpr (id (propext Class.coe_mem ▸ Eq.refl (↑(Classical.epsilon fun z => z ∈ y) ∈ ↑y)))\n        (Eq.mpr (id (propext Class.coe_apply ▸ Eq.refl (↑y (Classical.epsilon fun z => z ∈ y))))\n          (ZFSet.choice_mem_aux x h y yx))))","name":"ZFSet.choice_mem","depth":31}],"kind":"Class.«term_′_»","examples":[],"count":1}
{"noDocExamples":[{"term":"fun {𝕜} [IsROrC 𝕜] {E'} [NormedAddCommGroup E'] [InnerProductSpace 𝕜 E'] => smulCommClass_self 𝕜 (E' →L⋆[𝕜] 𝕜)","name":"ContinuousLinearMap.toSesqForm.proof_14","depth":33}],"kind":"«term_→L⋆[_]_»","examples":[],"count":1}
{"noDocExamples":[],"kind":"Functor.«term_$>_»","examples":[{"term":"fun {α} {m} [Alternative m] tac => List.firstM fun a => tac a $> a","name":"List.findM","doc":"`findM tac l` returns the first element of `l` on which `tac` succeeds, and\nfails otherwise. ","depth":14}],"count":1}
