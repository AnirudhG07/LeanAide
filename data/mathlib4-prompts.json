[{"type":
  "{R : Type u_1} →\n  {S : Type u_2} → [inst : Mul R] → [inst_1 : Mul S] → [inst_2 : Add R] → [inst_3 : Add S] → R ≃+* S → R ≃ S",
  "name": "RingEquiv.toEquiv",
  "kind": "def",
  "doc_string":
  "The \"plain\" equivalence of types underlying an equivalence of (semi)rings. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {F : Type u_3} →\n      {G : Type u_4} →\n        [inst : NonAssocSemiring R] →\n          [inst_1 : NonAssocSemiring S] →\n            [inst_2 : RingHomClass F R S] →\n              [inst_3 : RingHomClass G S R] →\n                (hom : F) →\n                  (inv : G) → RingHom.comp ↑inv ↑hom = RingHom.id R → RingHom.comp ↑hom ↑inv = RingHom.id S → R ≃+* S",
  "name": "RingEquiv.ofHomInv",
  "kind": "def",
  "doc_string":
  "Construct an equivalence of rings from unital homomorphisms in both directions, which are inverses.\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (x : M), AddSemiconjBy 0 x x",
  "name": "AddSemiconjBy.zero_left",
  "kind": "theorem",
  "doc_string": "Zero semiconjugates any element to itself.",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : AddGroup G] → G → G ≃ G",
  "name": "Equiv.subLeft",
  "kind": "def",
  "doc_string":
  "A version of `equiv.add_left a (-b)` that is defeq to `a - b`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddCommSemigroup α] [inst_1 : PartialOrder α] [inst_2 : ExistsAddOfLE α]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_4 : Sub α] [inst_5 : OrderedSub α]\n  {a b c : α} [inst_6 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1], b ≤ a → c ≤ a → (a - b < a - c ↔ c < b)",
  "name": "tsub_lt_tsub_iff_left_of_le_of_le",
  "kind": "theorem",
  "doc_string":
  "See `tsub_lt_tsub_iff_left_of_le` for a stronger statement in a linear order. ",
  "args": ""},
 {"type": "Mathlib.Tactic.LinearCombination.Config → Bool",
  "name": "Mathlib.Tactic.LinearCombination.Config.twoGoals",
  "kind": "def",
  "doc_string":
  "whether to make separate subgoals for both sides or just one for `lhs - rhs = 0` ",
  "args": ""},
 {"type": "(A : Type y) → [inst : AddCommMonoid A] → A ≃+ (ℕ →+ A)",
  "name": "multiplesAddHom",
  "kind": "def",
  "doc_string":
  "If `M` is commutative, `multiplesHom` is an additive equivalence. ",
  "args": ""},
 {"type": "Lean.Name → Lean.ImportM Mathlib.Meta.NormNum.NormNumExt",
  "name": "Mathlib.Meta.NormNum.mkNormNumExt",
  "kind": "def",
  "doc_string":
  "Read a `norm_num` extension from a declaration of the right type. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : HasInf α] → [inst : HImp α] → α → α → α",
  "name": "bihimp",
  "kind": "def",
  "doc_string":
  "The Heyting bi-implication is `(b ⇨ a) ⊓ (a ⇨ b)`. This generalizes equivalence of\npropositions. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → List α",
  "name": "List.eraseP",
  "kind": "def",
  "doc_string":
  "`eraseP p l` removes the first element of `l` satisfying the predicate `p`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_4} {β : Type u_5} {γ : Type u_3} {f : α → β → γ} {a : Option α} {b : Option β} {δ : Type u_1}\n  {β' : Type u_2} {g : γ → δ} {f' : β' → α → δ} {g' : β → β'},\n  (∀ (a : α) (b : β), g (f a b) = f' (g' b) a) → Option.map g (Option.map₂ f a b) = Option.map₂ f' (Option.map g' b) a",
  "name": "Option.map_map₂_antidistrib_left",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Option.map₂_map_left_anticomm`. ",
  "args": ""},
 {"type": "Lean.Expr → optParam Bool false → Lean.MetaM Lean.Meta.Simp.Result",
  "name": "Mathlib.Meta.NormNum.eval",
  "kind": "def",
  "doc_string":
  "Run each registered `norm_num` extension on an expression,\nreturning a `Simp.Result`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : AddCommGroup α] → AddCommGroup.TotalPositiveCone α → AddCommGroup.PositiveCone α",
  "name": "AddCommGroup.TotalPositiveCone.toPositiveCone",
  "kind": "def",
  "doc_string": "Forget that a `TotalPositiveCone` is total. ",
  "args": ""},
 {"type":
  "(ι : Type u_1) → (π : ι → Type u_2) → ((i : ι) → π i) ≃ { f // ∀ (i : ι), (f i).fst = i }",
  "name": "Equiv.piEquivSubtypeSigma",
  "kind": "def",
  "doc_string":
  "The `Pi`-type `∀ i, π i` is equivalent to the type of sections `f : ι → Σ i, π i` of the\n`Sigma` type such that for all `i` we have `(f i).fst = i`. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀], (fun x => x * 0) = Function.const M₀ 0",
  "name": "mul_zero_eq_const",
  "kind": "theorem",
  "doc_string": "To match `mul_one_eq_id`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : PredOrder α] [inst_2 : IsPredArchimedean α] (r : α → α → Prop)\n  {n m : α},\n  (∀ (i : α), i ∈ Set.Ioc m n → r i (Order.pred i)) →\n    (∀ (i : α), i ∈ Set.Ioc n m → r (Order.pred i) i) → n ≠ m → Relation.TransGen r n m",
  "name": "transGen_of_pred_of_ne",
  "kind": "theorem",
  "doc_string":
  "For `n ≠ m`, `(n, m)` is in the transitive closure of a relation `~` if `i ~ pred i` and\n`pred i ~ i` for all `i` between `n` and `m`. ",
  "args": ""},
 {"type": "Simps.Config → Bool",
  "name": "Simps.Config.fullyApplied",
  "kind": "def",
  "doc_string":
  "Generated lemmas that are fully applied, i.e. generates equalities between applied functions.\nSet this to `false` to generate equalities between functions. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {f g : M →+ N},\n  f = g ↔ ∀ (x : M), ↑f x = ↑g x",
  "name": "AddMonoidHom.ext_iff",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.ext_iff` instead.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.tacticClassical_",
  "kind": "def",
  "doc_string":
  "`classical tacs` runs `tacs` in a scope where `Classical.propDecidable` is a low priority\nlocal instance. It differs from `classical!` in that `classical!` uses a local variable,\nwhich has high priority:\n```\nnoncomputable def foo : Bool := by\n  classical!\n  have := ∀ p, decide p -- uses the classical instance\n  exact decide (0 < 1) -- uses the classical instance even though `0 < 1` is decidable\n\ndef bar : Bool := by\n  classical\n  have := ∀ p, decide p -- uses the classical instance\n  exact decide (0 < 1) -- uses the decidable instance\n```\nNote that (unlike lean 3) `classical` is a scoping tactic - it adds the instance only within the\nscope of the tactic.\n",
  "args": ""},
 {"type": "∀ {a b k : ℕ}, Nat.coprime a b → k ∣ a → k ∣ b → k = 1",
  "name": "Nat.eq_one_of_dvd_coprimes",
  "kind": "theorem",
  "doc_string": "If `k:ℕ` divides coprime `a` and `b` then `k = 1` ",
  "args": ""},
 {"type": "Lean.Expr → Lean.Expr",
  "name": "SlimCheck.Decorations.addDecorations",
  "kind": "opaque",
  "doc_string":
  "Traverse the syntax of a proposition to find universal quantifiers\nquantifiers and add `NamedBinder` annotations next to them. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Monoid M] (u : Mˣ) (a : M), IsUnit (↑u * a) ↔ IsUnit a",
  "name": "Units.isUnit_units_mul",
  "kind": "theorem",
  "doc_string":
  "Multiplication by a `u : Mˣ` on the left doesn't affect `IsUnit`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Mul R] {c : R}, IsRegular c → IsRightRegular c",
  "name": "IsRegular.right",
  "kind": "def",
  "doc_string": "A regular element `c` is right-regular ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (p q : α → Prop) → (∀ (x : α), p x → q x) → { x // p x } ↪ { x // q x }",
  "name": "Subtype.impEmbedding",
  "kind": "def",
  "doc_string":
  "A subtype `{x // p x}` can be injectively sent to into a subtype `{x // q x}`,\nif `p x → q x` for all `x : α`. ",
  "args": ""},
 {"type":
  "(G : Type u_1) → Type u_2 → [inst : AddMonoid G] → Type (max u_1 u_2)",
  "name": "AddAction",
  "kind": "inductive",
  "doc_string": "Type class for additive monoid actions. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → [inst : AddZeroClass M] → GaloisInsertion AddSubmonoid.closure SetLike.coe",
  "name": "AddSubmonoid.gi",
  "kind": "def",
  "doc_string": "`closure` forms a Galois insertion with the coercion to set.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 3",
  "name": "three_pos",
  "kind": "theorem",
  "doc_string": "**Alias** of `zero_lt_three`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ 1 → b ≤ 1 → a * b ≤ 1",
  "name": "mul_le_one'",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.mul_le_one`.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CompleteDistribLattice",
  "kind": "inductive",
  "doc_string":
  "A completely distributive lattice is a complete lattice whose `⊔` and `⊓` respectively\ndistribute over `⨅` and `⨆`. ",
  "args": ""},
 {"type": "{p : Prop} → Decidable p → Bool",
  "name": "toBoolUsing",
  "kind": "def",
  "doc_string": "Similar to `decide`, but uses an explicit instance ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tacticFconstructor",
  "kind": "def",
  "doc_string":
  "`fconstructor` is like `constructor`\n(it calls `apply` using the first matching constructor of an inductive datatype)\nexcept that it does not reorder goals.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ↪r s → α → β",
  "name": "RelEmbedding.Simps.apply",
  "kind": "def",
  "doc_string":
  "See Note [custom simps projection]. We need to specify this projection explicitly in this case,\nbecause it is a composition of multiple projections. ",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} → {α : Type u_1} → [inst : Monad m] → ForInStep α → (α → m (ForInStep α)) → m (ForInStep α)",
  "name": "ForInStep.bind",
  "kind": "def",
  "doc_string":
  "This is similar to a monadic `bind` operator, except that the two type parameters have to be\nthe same, which prevents putting a monad instance on `ForInStepT m α := m (ForInStep α)`.\n",
  "args": ""},
 {"type": "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2",
  "name": "Nat.Prime.mod_two_eq_one_iff_ne_two",
  "kind": "theorem",
  "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : Monoid M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [inst : SubmonoidClass A M] → (S : A) → Monoid { x // x ∈ S }",
  "name": "SubmonoidClass.toMonoid",
  "kind": "def",
  "doc_string": "A submonoid of a monoid inherits a monoid structure. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {Z Z' : C → Prop} → (∀ ⦃X : C⦄, Z X → Z' X) → CategoryTheory.FullSubcategory Z ⥤ CategoryTheory.FullSubcategory Z'",
  "name": "CategoryTheory.FullSubcategory.map",
  "kind": "def",
  "doc_string":
  "An implication of predicates `Z → Z'` induces a functor between full subcategories. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "HasSSubset",
  "kind": "inductive",
  "doc_string": "Notation type class for the strict subset relation `⊂`. ",
  "args": ""},
 {"type": "(α : Type u_1) → α × Empty ≃ Empty",
  "name": "Equiv.prodEmpty",
  "kind": "def",
  "doc_string":
  "`Empty` type is a right absorbing element for type product up to an equivalence. ",
  "args": ""},
 {"type": "Linarith.Ineq → String",
  "name": "Linarith.Ineq.toString",
  "kind": "def",
  "doc_string": "Prints an `Ineq` as the corresponding infix symbol. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a : Q(ℕ)} →\n        {b : Q(«$α»)} →\n          Mathlib.Tactic.Ring.ExSum Mathlib.Tactic.Ring.sℕ a →\n            Mathlib.Tactic.Ring.ExSum sα b →\n              Mathlib.Tactic.Ring.RingM (Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExSum sα) q(«$a» • «$b»))",
  "name": "Mathlib.Tactic.Ring.evalNSMul",
  "kind": "def",
  "doc_string":
  "Constructs the scalar multiplication `n • a`, where both `n : ℕ` and `a : α` are normalized\npolynomial expressions.\n\n* `a • b = a * b` if `α = ℕ`\n* `a • b = ↑a * b` otherwise\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → Equiv.Perm α → Equiv.Perm β → Equiv.Perm (α ⊕ β)",
  "name": "Equiv.Perm.sumCongr",
  "kind": "def",
  "doc_string":
  "Combine a permutation of `α` and of `β` into a permutation of `α ⊕ β`. ",
  "args": ""},
 {"type":
  "∀ (α : Type u) [inst : OrderedCommGroup α], ContravariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1",
  "name": "OrderedCommGroup.to_contravariantClass_left_le",
  "kind": "def",
  "doc_string": "A choice-free shortcut instance. ",
  "args": ""},
 {"type":
  "{β : Type v} → {m : Type v → Type w} → [inst : Monad m] → FloatArray → β → (Float → β → m (ForInStep β)) → m β",
  "name": "FloatArray.forInUnsafe",
  "kind": "def",
  "doc_string":
  "We claim this unsafe implementation is correct because an array cannot have more than `usizeSz` elements in our runtime.\nThis is similar to the `Array` version.\n",
  "args": ""},
 {"type": "String → List String → List String",
  "name": "ToAdditive.capitalizeFirstLike",
  "kind": "def",
  "doc_string":
  "Capitalize First element of a list like `s`.\nNote that we need to capitalize multiple characters in some cases,\nin examples like `HMul` or `hAdd`. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → α ⊕ β → Bool",
  "name": "Sum.isLeft",
  "kind": "def",
  "doc_string": "Check if a sum is `inl`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (f : α → β) → (s : Set α) → Set.InjOn f s → ↑s ≃ ↑(f '' s)",
  "name": "Equiv.Set.imageOfInjOn",
  "kind": "def",
  "doc_string":
  "If a function `f` is injective on a set `s`, then `s` is equivalent to `f '' s`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u} [self : AddCommGroupWithOne R] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "name": "AddCommGroupWithOne.natCast_succ",
  "kind": "def",
  "doc_string": "The canonical map `ℕ → R` is a homomorphism. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {a : α} {s : Set α}, infₛ s ⊔ a ≤ ⨅ b, ⨅ h, b ⊔ a",
  "name": "infₛ_sup_le_infᵢ_sup",
  "kind": "theorem",
  "doc_string": "This is a weaker version of `infₛ_sup_eq` ",
  "args": ""},
 {"type":
  "{m n a b : ℕ} → a ≡ b [MOD Nat.gcd n m] → { k // k ≡ a [MOD n] ∧ k ≡ b [MOD m] }",
  "name": "Nat.chineseRemainder'",
  "kind": "def",
  "doc_string":
  "The natural number less than `lcm n m` congruent to `a` mod `n` and `b` mod `m` ",
  "args": ""},
 {"type": "Type",
  "name": "Aesop.NodeState",
  "kind": "inductive",
  "doc_string":
  "At each point during the search, every node of the tree (goal, rapp or mvar\ncluster) is in one of these states:\n\n- `proven`: the node is proven.\n- `unprovable`: the node is unprovable, i.e. it will never be proven regardless\n  of any future expansions that might be performed.\n- `unknown`: neither of the above.\n\nEvery node starts in the `unknown` state and may later become either `proven` or\n`unprovable`. After this, the state does not change any more.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.casesM",
  "kind": "def",
  "doc_string":
  "* `casesm p` applies the `cases` tactic to a hypothesis `h : type`\n  if `type` matches the pattern `p`.\n* `casesm p_1, ..., p_n` applies the `cases` tactic to a hypothesis `h : type`\n  if `type` matches one of the given patterns.\n* `casesm* p` is a more efficient and compact version of `· repeat casesm p`.\n  It is more efficient because the pattern is compiled once.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current context.\n```\ncasesm* _ ∨ _, _ ∧ _\n```\n",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : MulOneClass M] → Top (Submonoid M)",
  "name": "Submonoid.instTopSubmonoid",
  "kind": "def",
  "doc_string": "The submonoid `M` of the monoid `M`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, IsTop a → a = ⊤",
  "name": "IsTop.eq_top",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `isTop_iff_eq_top`.",
  "args": ""},
 {"type": "{α : Sort u} → (α → Prop) → Prop",
  "name": "Exists",
  "kind": "inductive",
  "doc_string":
  "Existential quantification. If `p : α → Prop` is a predicate, then `∃ x : α, p x`\nasserts that there is some `x` of type `α` such that `p x` holds.\nTo create an existential proof, use the `exists` tactic,\nor the anonymous constructor notation `⟨x, h⟩`.\nTo unpack an existential, use `cases h` where `h` is a proof of `∃ x : α, p x`,\nor `let ⟨x, hx⟩ := h` where `.\n\nBecause Lean has proof irrelevance, any two proofs of an existential are\ndefinitionally equal. One consequence of this is that it is impossible to recover the\nwitness of an existential from the mere fact of its existence.\nFor example, the following does not compile:\n```\nexample (h : ∃ x : Nat, x = x) : Nat :=\n  let ⟨x, _⟩ := h  -- fail, because the goal is `Nat : Type`\n  x\n```\nThe error message `recursor 'Exists.casesOn' can only eliminate into Prop` means\nthat this only works when the current goal is another proposition:\n```\nexample (h : ∃ x : Nat, x = x) : True :=\n  let ⟨x, _⟩ := h  -- ok, because the goal is `True : Prop`\n  trivial\n```\n",
  "args": ""},
 {"type":
  "∀ {P : ℕ → Prop} {m : ℕ}, P m → (∀ (n : ℕ), m ≤ n → P n → P (n + 1)) → ∀ (n : ℕ), m ≤ n → P n",
  "name": "Nat.le_induction",
  "kind": "theorem",
  "doc_string":
  "Induction principle starting at a non-zero number. For maps to a `Sort*` see `le_rec_on`. ",
  "args": ""},
 {"type": "{L : Type u_1} → {M : Type u_2} → [self : Bracket L M] → L → M → M",
  "name": "Bracket.bracket",
  "kind": "def",
  "doc_string":
  "`⁅x, y⁆` is the result of a bracket operation on elements `x` and `y`.\nIt is supported by the `Bracket` typeclass. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : DistribLattice α] →\n    [inst_1 : BoundedOrder α] → (hnot : α → α) → (∀ (a b c : α), a ⊓ hnot b ≤ c ↔ a ≤ b ⊔ c) → CoheytingAlgebra α",
  "name": "CoheytingAlgebra.ofHNot",
  "kind": "def",
  "doc_string":
  "Construct a co-Heyting algebra from the difference and Heyting negation alone. ",
  "args": ""},
 {"type": "{α : Type u} → [self : Add α] → α → α → α",
  "name": "Add.add",
  "kind": "def",
  "doc_string": "`a + b` computes the sum of `a` and `b`. See `HAdd`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : OrderedAddCommGroup α] →\n    {β : Type u_2} →\n      [inst_1 : Zero β] →\n        [inst_2 : Add β] →\n          [inst_3 : Neg β] →\n            [inst_4 : Sub β] →\n              [inst_5 : SMul ℕ β] →\n                [inst_6 : SMul ℤ β] →\n                  (f : β → α) →\n                    Function.Injective f →\n                      f 0 = 0 →\n                        (∀ (x y : β), f (x + y) = f x + f y) →\n                          (∀ (x : β), f (-x) = -f x) →\n                            (∀ (x y : β), f (x - y) = f x - f y) →\n                              (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : β) (n : ℤ), f (n • x) = n • f x) → OrderedAddCommGroup β",
  "name": "Function.Injective.orderedAddCommGroup",
  "kind": "def",
  "doc_string": "Pullback an `OrderedAddCommGroup` under an injective map.",
  "args": ""},
 {"type": "∀ {M : Type u} [self : LeftCancelMonoid M] (a : M), 1 * a = a",
  "name": "LeftCancelMonoid.one_mul",
  "kind": "def",
  "doc_string": "One is a left neutral element for multiplication ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] (a : α), infₛ {a} = a",
  "name": "cinfₛ_singleton",
  "kind": "theorem",
  "doc_string": "The infimum of a singleton is the element of the singleton",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Add M] → [inst_1 : Add N] → (f : AddHom M N) → (∀ (x y : M), AddCommute (↑f x) (↑f y)) → AddHom M Nᵃᵒᵖ",
  "name": "AddHom.toOpposite",
  "kind": "def",
  "doc_string":
  "An additive semigroup homomorphism `f : AddHom M N` such that `f x` additively\ncommutes with `f y` for all `x, y` defines an additive semigroup homomorphism to `Sᵃᵒᵖ`.",
  "args": ""},
 {"type": "∀ {G : Type u_1} [inst : DivInvMonoid G] (a b : G), a / b = a * b⁻¹",
  "name": "div_eq_mul_inv",
  "kind": "theorem",
  "doc_string":
  "Dividing by an element is the same as multiplying by its inverse.\n\nThis is a duplicate of `DivInvMonoid.div_eq_mul_inv` ensuring that the types unfold better.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : OrderedSemiring α] (a b c : α), a ≤ b → 0 ≤ c → a * c ≤ b * c",
  "name": "OrderedSemiring.mul_le_mul_of_nonneg_right",
  "kind": "def",
  "doc_string":
  "In an ordered semiring, we can multiply an inequality `a ≤ b` on the right\nby a non-negative element `0 ≤ c` to obtain `a * c ≤ b * c`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : BEq α] [self : LawfulBEq α] {a b : α}, (a == b) = true → a = b",
  "name": "LawfulBEq.eq_of_beq",
  "kind": "def",
  "doc_string":
  "If `a == b` evaluates to `true`, then `a` and `b` are equal in the logic. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_<|_»",
  "kind": "def",
  "doc_string":
  "Haskell-like pipe operator `<|`. `f <| x` means the same as the same as `f x`,\nexcept that it parses `x` with lower precedence, which means that `f <| g <| x`\nis interpreted as `f (g x)` rather than `(f g) x`.\n",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} {inst : NonAssocSemiring α} {inst_1 : NonAssocSemiring β}\n  [self : RingHomClass F α β] (f : F), ↑f 0 = 0",
  "name": "RingHomClass.map_zero",
  "kind": "def",
  "doc_string": "The proposition that the function preserves 0 ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {l : α → β} →\n          {u : β → α} →\n            Monotone u → Monotone l → (∀ (b : β), l (u b) ≤ b) → (∀ (a : α), u (l a) = a) → GaloisCoinsertion l u",
  "name": "GaloisCoinsertion.monotoneIntro",
  "kind": "def",
  "doc_string":
  "A constructor for a Galois coinsertion with the trivial `choice` function. ",
  "args": ""},
 {"type":
  "{M : Type u} → [inst : AddMonoid M] → (x : M) → (n : ℕ) → n • x = 0 → n ≠ 0 → AddUnits M",
  "name": "AddUnits.ofSMulEqZero",
  "kind": "def",
  "doc_string": "If `n • x = 0`, `n ≠ 0`, then `x` is an additive unit.",
  "args": ""},
 {"type":
  "{α : Type u} → {m : Type u → Type v} → [inst : Functor m] → (α → Prop) → m α → Prop",
  "name": "SatisfiesM",
  "kind": "def",
  "doc_string":
  "`SatisfiesM p (x : m α)` lifts propositions over a monad. It asserts that `x` may as well\nhave the type `x : m {a // p a}`, because there exists some `m {a // p a}` whose image is `x`.\nSo `p` is the postcondition of the monadic value.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : NonUnitalNonAssocRing α] (a b c : α), a * (b - c) = a * b - a * c",
  "name": "mul_sub",
  "kind": "theorem",
  "doc_string": "**Alias** of `mul_sub_left_distrib`.",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {F F' : C ⥤ D} → [inst_2 : CategoryTheory.Full F] → (F ≅ F') → CategoryTheory.Full F'",
  "name": "CategoryTheory.Full.ofIso",
  "kind": "def",
  "doc_string":
  "If `F` is full, and naturally isomorphic to some `F'`, then `F'` is also full. ",
  "args": ""},
 {"type": "{α : Sort u} → [inst : Nonempty α] → α",
  "name": "Classical.ofNonempty",
  "kind": "def",
  "doc_string":
  "A variation on `Classical.choice` that uses typeclass inference to\ninfer the proof of `Nonempty α`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : AddCommSemigroup α] → AddHom (α × α) α",
  "name": "addAddHom",
  "kind": "def",
  "doc_string": "Addition as an additive homomorphism.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedCommMonoidWithZero α] → [inst_1 : LinearOrderedCommMonoidWithZero β] → Mul (α →*₀o β)",
  "name":
  "OrderMonoidWithZeroHom.instMulOrderMonoidWithZeroHomToPreorderToPartialOrderToOrderedCommMonoidToLinearOrderedCommMonoidToPreorderToPartialOrderToOrderedCommMonoidToLinearOrderedCommMonoidToMulZeroOneClassToMonoidWithZeroToCommMonoidWithZeroToMulZeroOneClassToMonoidWithZeroToCommMonoidWithZero",
  "kind": "def",
  "doc_string":
  "For two ordered monoid morphisms `f` and `g`, their product is the ordered monoid morphism\nsending `a` to `f a * g a`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} [inst : Preorder N] [inst_1 : CovariantClass M N μ fun x x_1 => x ≤ x_1]\n  (m : M), Monotone (μ m)",
  "name": "Covariant.monotone_of_const",
  "kind": "theorem",
  "doc_string":
  "The partial application of a constant to a covariant operator is monotone. ",
  "args": ""},
 {"type": "∀ (n : ℕ), ∃ p, n ≤ p ∧ Nat.Prime p",
  "name": "Nat.exists_infinite_primes",
  "kind": "theorem",
  "doc_string":
  "Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p ≥ n`. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : One M₁] →\n        [inst_2 : Pow M₁ ℕ] →\n          [inst_3 : Inv M₁] →\n            [inst_4 : Div M₁] →\n              [inst_5 : Pow M₁ ℤ] →\n                [inst_6 : Group M₂] →\n                  (f : M₁ → M₂) →\n                    Function.Injective f →\n                      f 1 = 1 →\n                        (∀ (x y : M₁), f (x * y) = f x * f y) →\n                          (∀ (x : M₁), f x⁻¹ = (f x)⁻¹) →\n                            (∀ (x y : M₁), f (x / y) = f x / f y) →\n                              (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                (∀ (x : M₁) (n : ℤ), f (x ^ n) = f x ^ n) → Group M₁",
  "name": "Function.Injective.group",
  "kind": "def",
  "doc_string":
  "A type endowed with `1`, `*` and `⁻¹` is a group, if it admits an injective map that preserves\n`1`, `*` and `⁻¹` to a group. See note [reducible non-instances]. ",
  "args": ""},
 {"type": "(α : Type u) → Lean.Name → TypeName α",
  "name": "TypeName.mk",
  "kind": "def",
  "doc_string":
  "Creates a `TypeName` instance.\n\nFor safety, it is required that the constant `typeName` is definitionally equal\nto `α`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → α → WithBot α",
  "name": "WithBot.some",
  "kind": "def",
  "doc_string": "The canonical map from `α` into `WithBot α` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : NonAssocSemiring α] → [inst_1 : NonAssocSemiring β] → (α →+* β) → α →*₀ β",
  "name": "RingHom.toMonoidWithZeroHom",
  "kind": "def",
  "doc_string":
  "Reinterpret a ring homomorphism `f : α →+* β` as a monoid with zero homomorphism `α →*₀ β`.\nThe `simp`-normal form is `(f : α →*₀ β)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Sort u_2} [inst : ConditionallyCompleteLattice α] {f : ι → α},\n  BddBelow (Set.range f) → ∀ (c : ι), infᵢ f ≤ f c",
  "name": "cinfᵢ_le",
  "kind": "theorem",
  "doc_string":
  "The indexed infimum of a function is bounded above by the value taken at one point",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddMonoid M] → [inst_1 : Subsingleton M] → Unique (AddUnits M)",
  "name": "instUniqueAddUnits",
  "kind": "def",
  "doc_string": "A subsingleton `AddMonoid` has a unique additive unit.",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → [self : CoeTC α β] → α → β",
  "name": "CoeTC.coe",
  "kind": "def",
  "doc_string":
  "Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α}, a < b + c → a - b < c",
  "name": "sub_left_lt_of_lt_add",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `sub_lt_iff_lt_add'`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Ring α] → (self : Ring.TotalPositiveCone α) → DecidablePred self.toPositiveCone_1.toPositiveCone.nonneg",
  "name": "Ring.TotalPositiveCone.nonnegDecidable",
  "kind": "def",
  "doc_string": "For any `a` the proposition `nonneg a` is decidable ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : LinearOrder α] → (a b : α) → a ≤ b → α → ↑(Set.Icc a b)",
  "name": "Set.projIcc",
  "kind": "def",
  "doc_string": "Projection of `α` to the closed interval `[a, b]`. ",
  "args": ""},
 {"type":
  "{α : Type u} → (r : α → α → Prop) → [inst : IsStrictOrder α r] → PartialOrder α",
  "name": "partialOrderOfSO",
  "kind": "def",
  "doc_string":
  "Construct a partial order from a `isStrictOrder` relation.\n\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1],\n  Monotone f → Monotone g → Monotone fun x => f x * g x",
  "name": "Monotone.mul'",
  "kind": "theorem",
  "doc_string": "The product of two monotone functions is monotone. ",
  "args": ""},
 {"type":
  "{β : Sort u_1} → {α : Sort u_2} → {p : β → Prop} → (e : α ≃ β) → { a // p (↑e a) } ≃ { b // p b }",
  "name": "Equiv.subtypeEquivOfSubtype",
  "kind": "def",
  "doc_string":
  "If `α ≃ β`, then for any predicate `p : β → Prop` the subtype `{a // p (e a)}` is equivalent\nto the subtype `{b // p b}`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : LT α] →\n    [inst_1 : WellFoundedGT α] → {C : α → Sort u_1} → ((x : α) → ((y : α) → x < y → C y) → C x) → (x : α) → C x",
  "name": "WellFoundedGT.fix",
  "kind": "def",
  "doc_string":
  "Creates data, given a way to generate a value from all that compare as greater. See also\n`WellFoundedGT.fix_eq`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {A : Type u_2} →\n    {B : Type u_3} →\n      [inst : AddZeroClass A] →\n        [inst_1 : DistribSMul M A] →\n          [inst_2 : AddZeroClass B] →\n            [inst_3 : SMul M B] →\n              (f : A →+ B) → Function.Surjective ↑f → (∀ (c : M) (x : A), ↑f (c • x) = c • ↑f x) → DistribSMul M B",
  "name": "Function.Surjective.distribSMul",
  "kind": "def",
  "doc_string":
  "Pushforward a distributive scalar multiplication along a surjective additive monoid\nhomomorphism.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {t : Type u → Type u} [inst : Traversable t] [self : IsLawfulTraversable t] {F G : Type u → Type u}\n  [inst_1 : Applicative F] [inst_2 : Applicative G] [inst_3 : LawfulApplicative F] [inst_4 : LawfulApplicative G]\n  (η : ApplicativeTransformation F G) {α β : Type u} (f : α → F β) (x : t α),\n  (fun {α} => ApplicativeTransformation.app η α) (traverse f x) =\n    traverse ((fun {α} => ApplicativeTransformation.app η α) ∘ f) x",
  "name": "IsLawfulTraversable.naturality",
  "kind": "def",
  "doc_string":
  "The naturality axiom explaining how lawful traversable functors should play with\nlawful applicative functors. ",
  "args": ""},
 {"type": "{α : Type u_1} → Array α → Array (α × ℕ)",
  "name": "Array.zipWithIndex",
  "kind": "def",
  "doc_string": "Turns `#[a, b]` into `#[(a, 0), (b, 1)]`. ",
  "args": ""},
 {"type":
  "{R : Type x} →\n  {S : Type u_1} →\n    [inst : Mul R] →\n      [inst_1 : Add R] →\n        [inst_2 : Distrib S] →\n          (f : R → S) →\n            Function.Injective f →\n              (∀ (x y : R), f (x + y) = f x + f y) → (∀ (x y : R), f (x * y) = f x * f y) → Distrib R",
  "name": "Function.Injective.distrib",
  "kind": "def",
  "doc_string":
  "Pullback a `Distrib` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → [self : CoeHTC α β] → α → β",
  "name": "CoeHTC.coe",
  "kind": "def",
  "doc_string":
  "Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.AbelNF.Config → Lean.Meta.TransparencyMode",
  "name": "Mathlib.Tactic.Abel.AbelNF.Config.red",
  "kind": "def",
  "doc_string":
  "the reducibility setting to use when comparing atoms for defeq ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {A : Type u_2} → [inst : Mul M] → [inst_1 : SetLike A M] → [hA : MulMemClass A M] → (S' : A) → { x // x ∈ S' } →ₙ* M",
  "name": "MulMemClass.subtype",
  "kind": "def",
  "doc_string":
  "The natural semigroup hom from a subsemigroup of semigroup `M` to `M`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Preorder α] → [inst_1 : Subsingleton α] → Unique (α →o α)",
  "name": "OrderHom.unique",
  "kind": "def",
  "doc_string":
  "There is a unique monotone map from a subsingleton to itself. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Add M] →\n      [inst_1 : Add N] →\n        (e : M ≃+ N) →\n          (S : AddSubsemigroup M) → { x // x ∈ S } ≃+ { x // x ∈ AddSubsemigroup.map (AddEquiv.toAddHom e) S }",
  "name": "AddEquiv.subsemigroupMap",
  "kind": "def",
  "doc_string":
  "An `AddEquiv` `φ` between two additive semigroups `M` and `N` induces an `add_equiv`\nbetween a subsemigroup `S ≤ M` and the subsemigroup `φ(S) ≤ N`.\nSee `AddHom.addSubsemigroupMap` for a variant for `AddHom`s.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedCommGroup α] (a b : α), a ≤ b ∨ b ≤ a",
  "name": "LinearOrderedCommGroup.le_total",
  "kind": "def",
  "doc_string": "A linear order is total. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : SuccOrder α] [inst_2 : Preorder β] {f : α → β},\n  Monotone f → Pairwise (Disjoint on fun n => Set.Ioo (f n) (f (Order.succ n)))",
  "name": "Monotone.pairwise_disjoint_on_Ioo_succ",
  "kind": "theorem",
  "doc_string":
  "If `α` is a linear succ order, `β` is a preorder, and `f : α → β` is a monotone function, then\nthe intervals `Set.Ioo (f n) (f (Order.succ n))` are pairwise disjoint. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HPow α β γ] → α → β → γ",
  "name": "HPow.hPow",
  "kind": "def",
  "doc_string":
  "`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Nontrivial β] {f : α → β}, Function.Surjective f → Nontrivial α",
  "name": "Function.Surjective.nontrivial",
  "kind": "theorem",
  "doc_string":
  "Pullback a `nontrivial` instance along a surjective function. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term⁅_,_⁆»",
  "kind": "def",
  "doc_string":
  "`⁅x, y⁆` is the result of a bracket operation on elements `x` and `y`.\nIt is supported by the `Bracket` typeclass. ",
  "args": ""},
 {"type": "{M : Type u} → [self : Monoid M] → ℕ → M → M",
  "name": "Monoid.npow",
  "kind": "def",
  "doc_string": "Raising to the power of a natural number. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Functor.Const α β → α",
  "name": "Functor.Const.run",
  "kind": "def",
  "doc_string": "Extract the element of `α` from the `Const` functor. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  [inst : Monoid R] → {S : Submonoid R} → [inst_1 : OreLocalization.OreSet S] → R → { x // x ∈ S } → { x // x ∈ S }",
  "name": "OreLocalization.oreDenom",
  "kind": "def",
  "doc_string": "The Ore denominator of a fraction. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Semigroup α] [inst_1 : HasDistribNeg α] (a b : α), -a ∣ b ↔ a ∣ b",
  "name": "neg_dvd",
  "kind": "theorem",
  "doc_string":
  "The negation of an element a of a semigroup with a distributive negation divides\nanother element b iff a divides b. ",
  "args": ""},
 {"type":
  "{m : Type → Type} →\n  {α : Type} →\n    [inst : Monad m] →\n      [inst : Lean.MonadEnv m] →\n        [inst : Lean.MonadLog m] →\n          [inst : Lean.MonadOptions m] →\n            [inst : MonadLiftT BaseIO m] → [inst : MonadExcept Lean.Exception m] → Mathlib.Tactic.Cache α → m α",
  "name": "Mathlib.Tactic.Cache.get",
  "kind": "def",
  "doc_string":
  "Access the cache.\nCalling this function for the first time\nwill initialize the cache with the function\nprovided in the constructor.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] {a b : α} [inst_1 : IsRefl α fun x x_1 => x ⊆ x_1], a = b → a ⊆ b",
  "name": "Eq.subset'",
  "kind": "theorem",
  "doc_string": "**Alias** of `subset_of_eq`.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Set.«term[[_,_]]»",
  "kind": "def",
  "doc_string":
  "`[[a, b]]` denotes the set of elements lying between `a` and `b`, inclusive. ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : One M] → OneHom M M",
  "name": "OneHom.id",
  "kind": "def",
  "doc_string": "The identity map from a type with 1 to itself. ",
  "args": ""},
 {"type": "{α σ : Type u} → σ → DoResultSBC α σ",
  "name": "DoResultSBC.continue",
  "kind": "def",
  "doc_string":
  "`continue s` means that `continue` was called, meaning that we should continue\nto the next iteration of the containing loop ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Preorder α] → [inst_1 : OrderBot α] → ↑(Set.Ici ⊥) ≃o α",
  "name": "OrderIso.IciBot",
  "kind": "def",
  "doc_string":
  "Order isomorphism between `Ici (⊥ : α)` and `α` when `α` has a bottom element ",
  "args": ""},
 {"type":
  "∀ {G : Type u} [self : DivInvMonoid G] (a : G), DivInvMonoid.zpow 0 a = 1",
  "name": "DivInvMonoid.zpow_zero'",
  "kind": "def",
  "doc_string": "`a ^ 0 = 1` ",
  "args": ""},
 {"type": "∀ {α : Sort u} (a : α), { down := a }.down = a",
  "name": "PLift.down_up",
  "kind": "theorem",
  "doc_string": "Bijection between `α` and `PLift α` ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "GeneralizedCoheytingAlgebra",
  "kind": "inductive",
  "doc_string":
  "A generalized co-Heyting algebra is a lattice with an additional binary\ndifference operation `\\` such that `\\ a` is right adjoint to `⊔ a`.\n\nThis generalizes `CoheytingAlgebra` by not requiring a top element. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "RightCancelMonoid",
  "kind": "inductive",
  "doc_string": "A monoid in which multiplication is right-cancellative. ",
  "args": ""},
 {"type": "ℕ × ℕ ≃ ℕ",
  "name": "Nat.mkpairEquiv",
  "kind": "def",
  "doc_string": "An equivalence between `ℕ × ℕ` and `ℕ`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LT α] [inst_1 : WellFoundedLT α] {C : α → Sort u_1} (F : (x : α) → ((y : α) → y < x → C y) → C x)\n  (x : α), WellFoundedLT.fix F x = F x fun y x => WellFoundedLT.fix F y",
  "name": "WellFoundedLT.fix_eq",
  "kind": "theorem",
  "doc_string":
  "The value from `WellFoundedLT.fix` is built from the previous ones as specified. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {o p : Part α}, (o.Dom ↔ p.Dom) → (∀ (h₁ : o.Dom) (h₂ : p.Dom), Part.get o h₁ = Part.get p h₂) → o = p",
  "name": "Part.ext'",
  "kind": "theorem",
  "doc_string": "`Part` extensionality ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {A : Type u_2} {B : Type u_3} {inst : Mul A} {inst_1 : Mul B} [self : MulEquivClass F A B] (f : F)\n  (a b : A), ↑f (a * b) = ↑f a * ↑f b",
  "name": "MulEquivClass.map_mul",
  "kind": "def",
  "doc_string": "Preserves multiplication. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : HasSup α] → [inst : SDiff α] → α → α → α",
  "name": "symmDiff",
  "kind": "def",
  "doc_string":
  "The symmetric difference operator on a type with `⊔` and `\\` is `(A \\ B) ⊔ (B \\ A)`. ",
  "args": ""},
 {"type": "{α : Type u_1} → ℕ → List α → List (ℕ × α)",
  "name": "List.enumFromTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `enumFrom`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.constructorM",
  "kind": "def",
  "doc_string":
  "* `constructorm p_1, ..., p_n` applies the `constructor` tactic to the main goal\n  if `type` matches one of the given patterns.\n* `constructorm* p` is a more efficient and compact version of `· repeat constructorm p`.\n  It is more efficient because the pattern is compiled once.\n\nExample: The following tactic proves any theorem like `True ∧ (True ∨ True)` consisting of\nand/or/true:\n```\nconstructorm* _ ∨ _, _ ∧ _, True\n```\n",
  "args": ""},
 {"type": "∀ {a b : Prop}, b → a ∨ b",
  "name": "Or.inr",
  "kind": "def",
  "doc_string":
  "`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a ∨ b`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → Set α → Prop",
  "name": "IsAntichain",
  "kind": "def",
  "doc_string":
  "An antichain is a set such that no two distinct elements are related. ",
  "args": ""},
 {"type": "ℤ → ℚ",
  "name": "Rat.ofInt",
  "kind": "def",
  "doc_string": "Embedding of `Int` in the rational numbers. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] {s : Set M} {p : M → Prop} {x : M},\n  x ∈ AddSubmonoid.closure s → (∀ (x : M), x ∈ s → p x) → p 0 → (∀ (x y : M), p x → p y → p (x + y)) → p x",
  "name": "AddSubmonoid.closure_induction",
  "kind": "theorem",
  "doc_string":
  "An induction principle for additive closure membership. If `p` holds for `0` and all\nelements of `s`, and is preserved under addition, then `p` holds for all elements of the\nadditive closure of `s`.",
  "args": ""},
 {"type":
  "∀ {C : Type u_2} [inst : CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y},\n  f = g → ∀ {Z : C} (h : Y ⟶ Z), f ≫ h = g ≫ h",
  "name": "CategoryTheory.eq_whisker'",
  "kind": "theorem",
  "doc_string":
  "A variant of `eq_whisker` with a more convenient argument order for use in tactics.  ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} (self : r ≼i s) (a : α) (b : β),\n  s b (↑self.toRelEmbedding.toEmbedding a) → ∃ a', ↑self.toRelEmbedding.toEmbedding a' = b",
  "name": "InitialSeg.init",
  "kind": "def",
  "doc_string": "The order embedding is an initial segment ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : One M] [inst_1 : One N] (self : OneHom M N), ↑self 1 = 1",
  "name": "OneHom.map_one'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves 1 ",
  "args": ""},
 {"type": "Type",
  "name": "Aesop.RuleTacOutput",
  "kind": "inductive",
  "doc_string":
  "The result of a rule tactic contains:\n\n- `applications`: a list of rule applications.\n- `postBranchState?`: an updated branch state. `none` signals that there were\n  no changes to the branch state, in which case the input branch state is\n  copied to all subgoals.\n",
  "args": ""},
 {"type": "ℕ → ℕ → ℤ",
  "name": "Nat.gcdB",
  "kind": "def",
  "doc_string":
  "The extended GCD `b` value in the equation `gcd x y = x * a + y * b`. ",
  "args": ""},
 {"type":
  "∀ {I : Type u} {β : Type u_1} [inst : DecidableEq I] [inst_1 : One β] (i : I) (x : β) (i' : I),\n  Pi.mulSingle i x i' = if i' = i then x else 1",
  "name": "Pi.mulSingle_apply",
  "kind": "theorem",
  "doc_string":
  "On non-dependent functions, `Pi.mulSingle` can be expressed as an `ite` ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_≃o_»",
  "kind": "def",
  "doc_string": "Notation for an `OrderIso`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → List (List α)",
  "name": "List.splitOnP",
  "kind": "def",
  "doc_string":
  "Split a list at every element satisfying a predicate. The separators are not in the result.\n```\n[1, 1, 2, 3, 2, 4, 4].splitOnP (· == 2) = [[1, 1], [3], [4, 4]]\n```\n",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : Mul G] → G → G → G",
  "name": "leftMul",
  "kind": "def",
  "doc_string": "`leftMul g` denotes left multiplication by `g` ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → Array α → β → (α → β → m (ForInStep β)) → m β",
  "name": "Array.forIn",
  "kind": "def",
  "doc_string": "Reference implementation for `forIn` ",
  "args": ""},
 {"type":
  "(α : Type u_1) →\n  [inst : CanonicallyOrderedAddMonoid α] →\n    [inst_1 : Sub α] →\n      [inst_2 : OrderedSub α] →\n        [inst : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] → AddCancelCommMonoid α",
  "name": "CanonicallyOrderedAddMonoid.toAddCancelCommMonoid",
  "kind": "def",
  "doc_string":
  "A `CanonicallyOrderedAddMonoid` with ordered subtraction and order-reflecting addition is\ncancellative. This is not an instance at it would form a typeclass loop.\n\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → {S : Type u_2} → [inst : CommSemiring R] → [inst : CommSemiring S] → CommSemiring (R × S)",
  "name": "Prod.instCommSemiringProd",
  "kind": "def",
  "doc_string":
  "Product of two commutative semirings is a commutative semiring. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Monoid M] →\n      [inst_1 : Monoid N] →\n        {s : Set M} →\n          (f : M → N) → Submonoid.closure s = ⊤ → f 1 = 1 → (∀ (x y : M), y ∈ s → f (x * y) = f x * f y) → M →* N",
  "name": "MonoidHom.ofClosureMEqTopRight",
  "kind": "def",
  "doc_string":
  "Let `s` be a subset of a monoid `M` such that the closure of `s` is the whole monoid.\nThen `MonoidHom.ofClosureEqTopRight` defines a monoid homomorphism from `M` asking for\na proof of `f (x * y) = f x * f y` only for `y ∈ s`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → (β → α) → Prop",
  "name": "GaloisConnection",
  "kind": "def",
  "doc_string":
  "A Galois connection is a pair of functions `l` and `u` satisfying\n`l a ≤ b ↔ a ≤ u b`. They are special cases of adjoint functors in category theory,\n  but do not depend on the category theory library in mathlib. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Conv.«command#whnfR_»",
  "kind": "def",
  "doc_string":
  "The command `#whnfR e` evaluates `e` to Weak Head Normal Form with Reducible transparency,\nthat is, it uses `whnf` but only unfolding reducible definitions.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Mul α] [inst_1 : LT α]\n  [inst_2 : ContravariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b c : α}, a * b < a * c → b < c",
  "name": "OrderedCommGroup.lt_of_mul_lt_mul_left",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_mul_lt_mul_left'`.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Tactic.NormCast.tacticExact_mod_cast_",
  "kind": "def",
  "doc_string":
  "Normalize the goal and the given expression, then close the goal with exact.\n",
  "args": ""},
 {"type": "Mathlib.Tactic.Sat.Clause → Lean.Expr",
  "name": "Mathlib.Tactic.Sat.Clause.expr",
  "kind": "def",
  "doc_string": "The clause expression of type `Clause` ",
  "args": ""},
 {"type":
  "(M : Type u_1) → [inst : Monoid M] → (R : Type v) → [inst_1 : Semiring R] → [inst : MulSemiringAction M R] → M → R →+* R",
  "name": "MulSemiringAction.toRingHom",
  "kind": "def",
  "doc_string": "Each element of the monoid defines a semiring homomorphism. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : HasSSubset α]\n  [inst_2 : IsNonstrictStrictOrder α (fun x x_1 => x ⊆ x_1) fun x x_1 => x ⊂ x_1] {a b c : α}\n  [inst_3 : IsTrans α fun x x_1 => x ⊆ x_1], a ⊂ b → b ⊆ c → a ⊂ c",
  "name": "HasSSubset.SSubset.trans_subset",
  "kind": "theorem",
  "doc_string": "**Alias** of `ssubset_of_ssubset_of_subset`.",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Mul α] → [inst_1 : MulOneClass β] → (α →ₙ* β) ≃ (WithOne α →* β)",
  "name": "WithOne.lift",
  "kind": "def",
  "doc_string":
  "Lift a semigroup homomorphism `f` to a bundled monoid homorphism. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : PredOrder α] [inst_2 : IsPredArchimedean α] (r : α → α → Prop)\n  {n m : α}, (∀ (i : α), i ∈ Set.Ioc n m → r (Order.pred i) i) → n < m → Relation.TransGen r n m",
  "name": "transGen_of_pred_of_lt",
  "kind": "theorem",
  "doc_string":
  "For `n < m`, `(n, m)` is in the transitive closure of a relation `~` for `n ≠ m` if `pred i ~ i`\nfor all `i` between `n` and `m`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Semigroup α] {a b : α} (c : α), a * c = b → a ∣ b",
  "name": "dvd_of_mul_right_eq",
  "kind": "theorem",
  "doc_string": "**Alias** of `Dvd.intro`.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Add",
  "kind": "inductive",
  "doc_string":
  "The homogeneous version of `HAdd`: `a + b : α` where `a b : α`. ",
  "args": ""},
 {"type":
  "∀ {α β γ : Type u_1} (f : α → β → γ) (a : Option α) (b : Option β), Option.map₂ f a b = Seq.seq (f <$> a) fun x => b",
  "name": "Option.map₂_def",
  "kind": "theorem",
  "doc_string":
  "`Option.map₂` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : OrderedSemiring S] {R : Type u_2} [inst_1 : Semiring R] {f : R → S} [self : IsAbsoluteValue f]\n  {x : R}, f x = 0 ↔ x = 0",
  "name": "IsAbsoluteValue.abv_eq_zero",
  "kind": "def",
  "doc_string": "The absolute value is positive definitive ",
  "args": ""},
 {"type":
  "{G : Type u_1} → {M : Type u_2} → [inst : AddGroup G] → [inst_1 : AddMonoid M] → (G →+ M) → G →+ AddUnits M",
  "name": "AddMonoidHom.toHomAddUnits",
  "kind": "def",
  "doc_string":
  "If `f` is a homomorphism from an additive group `G` to an additive monoid `M`,\nthen its image lies in the `AddUnits` of `M`,\nand `f.toHomUnits` is the corresponding homomorphism from `G` to `AddUnits M`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {n : ℤ} {a b : α}, n ≠ 0 → (n • a = n • b ↔ a = b)",
  "name": "zsmul_eq_zsmul_iff'",
  "kind": "theorem",
  "doc_string":
  "Alias of `zsmul_right_inj`, for ease of discovery alongside\n`zsmul_le_zsmul_iff'` and `zsmul_lt_zsmul_iff'`.",
  "args": ""},
 {"type": "{α : Type u_1} → Array α → ℕ → α → Array α",
  "name": "Array.setD",
  "kind": "def",
  "doc_string":
  "Set an element in an array, or do nothing if the index is out of bounds.\n\nThis will perform the update destructively provided that `a` has a reference\ncount of 1 when called.\n",
  "args": ""},
 {"type":
  "∀ {t : Type u → Type u} [inst : Traversable t] [self : IsLawfulTraversable t] {F G : Type u → Type u}\n  [inst_1 : Applicative F] [inst_2 : Applicative G] [inst_3 : LawfulApplicative F] [inst_4 : LawfulApplicative G]\n  {α β γ : Type u} (f : β → F γ) (g : α → G β) (x : t α),\n  traverse (Functor.Comp.mk ∘ Functor.map f ∘ g) x = Functor.Comp.mk (traverse f <$> traverse g x)",
  "name": "IsLawfulTraversable.comp_traverse",
  "kind": "def",
  "doc_string":
  "`traverse` plays well with composition of applicative functors. ",
  "args": ""},
 {"type":
  "(G : Type u_1) → [inst : AddZeroClass G] → Additive (Multiplicative G) ≃+ G",
  "name": "AddEquiv.additiveMultiplicative",
  "kind": "def",
  "doc_string": "`Additive (Multiplicative G)` is just `G`. ",
  "args": ""},
 {"type": "Lean.Parsec ℕ",
  "name": "Mathlib.Tactic.Sat.Parser.parseNat",
  "kind": "def",
  "doc_string": "Parse a natural number ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Preorder α] → LowerAdjoint id",
  "name": "LowerAdjoint.id",
  "kind": "def",
  "doc_string": "The identity function as a lower adjoint to itself. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : HasSup α] →\n      [inst_1 : HasInf α] →\n        [inst_2 : SupSet α] →\n          [inst_3 : InfSet α] →\n            [inst_4 : Top α] →\n              [inst_5 : Bot α] →\n                [inst_6 : Order.Coframe β] →\n                  (f : α → β) →\n                    Function.Injective f →\n                      (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) →\n                        (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) →\n                          (∀ (s : Set α), f (supₛ s) = ⨆ a, ⨆ h, f a) →\n                            (∀ (s : Set α), f (infₛ s) = ⨅ a, ⨅ h, f a) → f ⊤ = ⊤ → f ⊥ = ⊥ → Order.Coframe α",
  "name": "Function.Injective.coframe",
  "kind": "def",
  "doc_string": "Pullback an `Order.Coframe` along an injection. ",
  "args": ""},
 {"type": "{α : Type u_1} → α → WithTop α → α",
  "name": "WithTop.untop'",
  "kind": "def",
  "doc_string":
  "Specialization of `Option.get_or_else` to values in `WithTop α` that respects API boundaries.\n",
  "args": ""},
 {"type":
  "{α : Sort u₁} →\n  {β : Sort u₂} → {φ : Sort u₃} → {δ : Sort u₄} → {ζ : Sort u₁} → (α → β → φ) → (φ → δ → ζ) → (α → β → δ) → α → β → ζ",
  "name": "Function.combine",
  "kind": "def",
  "doc_string":
  "Given functions `f : α → β → φ`, `g : α → β → δ` and a binary operator `op : φ → δ → ζ`,\nproduce a function `α → β → ζ` that applies `f` and `g` on each argument and then applies\n`op` to the results.\n",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → optParam ℕ 0 → Option ℕ",
  "name": "List.findIdx?",
  "kind": "def",
  "doc_string":
  "Return the index of the first occurrence of an element satisfying `p`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddLeftCancelMonoid",
  "kind": "inductive",
  "doc_string":
  "An additive monoid in which addition is left-cancellative.\nMain examples are `ℕ` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `AddLeftCancelSemigroup` is not enough. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "ConditionallyCompleteLinearOrderBot",
  "kind": "inductive",
  "doc_string":
  "A conditionally complete linear order with `Bot` is a linear order with least element, in which\nevery nonempty subset which is bounded above has a supremum, and every nonempty subset (necessarily\nbounded below) has an infimum.  A typical example is the natural numbers.\n\nTo differentiate the statements from the corresponding statements in (unconditional)\ncomplete linear orders, we prefix `infₛ` and `supₛ` by a c everywhere. The same statements should\nhold in both worlds, sometimes with additional assumptions of nonemptiness or\nboundedness.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : PartialOrder α] → [inst_1 : PartialOrder β] → ((fun x x_1 => x < x_1) ↪r fun x x_1 => x < x_1) → α ↪o β",
  "name": "RelEmbedding.orderEmbeddingOfLTEmbedding",
  "kind": "def",
  "doc_string":
  "Embeddings of partial orders that preserve `<` also preserve `≤`. ",
  "args": ""},
 {"type": "∀ {n m : ℕ}, Nat.le n m → Nat.le n (Nat.succ m)",
  "name": "Nat.le.step",
  "kind": "def",
  "doc_string": "If `n ≤ m`, then `n ≤ m + 1`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), a * -1 = -a",
  "name": "mul_neg_one",
  "kind": "theorem",
  "doc_string":
  "An element of a ring multiplied by the additive inverse of one is the element's additive\ninverse. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LE α] → WithBot αᵒᵈ ≃o (WithTop α)ᵒᵈ",
  "name": "WithBot.toDualTopEquiv",
  "kind": "def",
  "doc_string":
  "Taking the dual then adding `⊥` is the same as adding `⊤` then taking the dual.\nThis is the order iso form of `WithBot.ofDual`, as proven by `coe_toDualTopEquiv_eq`.\n",
  "args": ""},
 {"type": "∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n",
  "name": "Nat.minFac_sq_le_self",
  "kind": "theorem",
  "doc_string":
  "The square of the smallest prime factor of a composite number `n` is at most `n`.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«command#helpTactic+__»",
  "kind": "def",
  "doc_string":
  "The command `#help tactic` shows all tactics that have been defined in the current environment.\nSee `#help cat` for more information.\n",
  "args": ""},
 {"type":
  "Sort u_1 → (α : outParam (Sort u_2)) → outParam (α → Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "name": "FunLike",
  "kind": "inductive",
  "doc_string":
  "The class `FunLike F α β` expresses that terms of type `F` have an\ninjective coercion to functions from `α` to `β`.\n\nThis typeclass is used in the definition of the homomorphism typeclasses,\nsuch as `ZeroHomClass`, `MulHomClass`, `MonoidHomClass`, ....\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Mul α] → [inst_1 : Mul β] → (α →ₙ* β) → (I : Type u_3) → (I → α) →ₙ* I → β",
  "name": "MulHom.compLeft",
  "kind": "def",
  "doc_string":
  "Semigroup homomorphism between the function spaces `I → α` and `I → β`, induced by a semigroup\nhomomorphism `f` between `α` and `β`. ",
  "args": ""},
 {"type":
  "∀ (R : Type u_2) {M : Type u_1} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (n : ℤ) (b : M),\n  n • b = ↑n • b",
  "name": "zsmul_eq_smul_cast",
  "kind": "theorem",
  "doc_string": "`zsmul` is equal to any other module structure via a cast. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : GCDMonoid α] {m n k : α},\n  k ∣ m * n → ∃ d₁ d₂, d₁ ∣ m ∧ d₂ ∣ n ∧ k = d₁ * d₂",
  "name": "exists_dvd_and_dvd_of_dvd_mul",
  "kind": "theorem",
  "doc_string":
  "Represent a divisor of `m * n` as a product of a divisor of `m` and a divisor of `n`.\n\nIn other words, the nonzero elements of a `GCDMonoid` form a decomposition monoid\n(more widely known as a pre-Schreier domain in the context of rings).\n\nNote: In general, this representation is highly non-unique.\n\nSee `Nat.prodDvdAndDvdOfDvdProd` for a constructive version on `ℕ`.  ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : One M] → [inst_1 : One N] → OneHom M N → OneHom (WithBot M) (WithBot N)",
  "name": "OneHom.withBotMap",
  "kind": "def",
  "doc_string": "A version of `WithBot.map` for `OneHom`s. ",
  "args": ""},
 {"type":
  "(S : Type u_1) → (M : outParam (Type u_2)) → [inst : MulOneClass M] → [inst : SetLike S M] → Prop",
  "name": "SubmonoidClass",
  "kind": "inductive",
  "doc_string":
  "`SubmonoidClass S M` says `S` is a type of subsets `s ≤ M` that contain `1`\nand are closed under `(*)` ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → β ↪ α ⊕ β",
  "name": "Function.Embedding.inr",
  "kind": "def",
  "doc_string": "The embedding of `β` into the sum `α ⊕ β`. ",
  "args": ""},
 {"type": "Lean.Option Bool",
  "name": "Mathlib.Tactic.PushNeg.push_neg.use_distrib",
  "kind": "opaque",
  "doc_string":
  "Make `push_neg` use `not_and_distrib` rather than the default `not_and`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddMonoid α] (self : AddUnits α), self.neg + ↑self = 0",
  "name": "AddUnits.neg_val",
  "kind": "def",
  "doc_string":
  "`neg` is the left additive inverse of `val` in the base `AddMonoid`. ",
  "args": ""},
 {"type": "(α : Type u_1) → (α → α → Bool) → Type u_1",
  "name": "BinaryHeap",
  "kind": "inductive",
  "doc_string": "A max-heap data structure. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : MulOneClass M] → Submonoid M → Subsemigroup M",
  "name": "Submonoid.toSubsemigroup",
  "kind": "def",
  "doc_string":
  "A submonoid of a monoid `M` can be considered as a subsemigroup of that monoid. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → Set α → Prop",
  "name": "IsStrongAntichain",
  "kind": "def",
  "doc_string":
  "A strong (upward) antichain is a set such that no two distinct elements are related to a common\nelement. ",
  "args": ""},
 {"type":
  "∀ {R₁ : Type u_1} {R₂ : Type u_2} {R₃ : Type u_3} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Semiring R₃]\n  {σ₁₂ : R₁ →+* R₂} {σ₂₃ : R₂ →+* R₃} {σ₁₃ : R₁ →+* R₃} [inst_3 : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃]\n  [inst_4 : RingHomSurjective σ₁₂] [inst_5 : RingHomSurjective σ₂₃], RingHomSurjective σ₁₃",
  "name": "RingHomSurjective.comp",
  "kind": "theorem",
  "doc_string":
  "This cannot be an instance as there is no way to infer `σ₁₂` and `σ₂₃`. ",
  "args": ""},
 {"type": "∀ {A : Type u_1} [inst : AddMonoid A], FaithfulSMul (AddAut A) A",
  "name": "AddAut.apply_faithfulSMul",
  "kind": "def",
  "doc_string": "`AddAut.applyDistribMulAction` is faithful. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, -a ≤ -b → b ≤ a",
  "name": "le_of_neg_le_neg",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `neg_le_neg_iff`.",
  "args": ""},
 {"type":
  "{F : Type u → Type w} →\n  {G : Type v → Type u} →\n    [inst : Functor F] → [inst : Functor G] → {α β : Type v} → (α → β) → Functor.Comp F G α → Functor.Comp F G β",
  "name": "Functor.Comp.map",
  "kind": "def",
  "doc_string":
  "The map operation for the composition `Comp F G` of functors `F` and `G`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {a : α} {s : Set α}, (⨆ b, ⨆ h, b ⊓ a) ≤ supₛ s ⊓ a",
  "name": "supᵢ_inf_le_supₛ_inf",
  "kind": "theorem",
  "doc_string": "This is a weaker version of `supₛ_inf_eq` ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M), S = ⊥ ∨ ∃ x, x ∈ S ∧ x ≠ 1",
  "name": "Submonoid.bot_or_exists_ne_one",
  "kind": "theorem",
  "doc_string":
  "A submonoid is either the trivial submonoid or contains a nonzero element. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "LinearOrderedAddCommMonoidWithTop",
  "kind": "inductive",
  "doc_string":
  "A linearly ordered commutative monoid with an additively absorbing `⊤` element.\nInstances should include number systems with an infinite element adjoined.` ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : CommRing R] {x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ : R},\n  (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 + x₅ ^ 2 + x₆ ^ 2 + x₇ ^ 2 + x₈ ^ 2) *\n      (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 + y₅ ^ 2 + y₆ ^ 2 + y₇ ^ 2 + y₈ ^ 2) =\n    (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄ - x₅ * y₅ - x₆ * y₆ - x₇ * y₇ - x₈ * y₈) ^ 2 +\n                  (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃ + x₅ * y₆ - x₆ * y₅ - x₇ * y₈ + x₈ * y₇) ^ 2 +\n                (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂ + x₅ * y₇ + x₆ * y₈ - x₇ * y₅ - x₈ * y₆) ^ 2 +\n              (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁ + x₅ * y₈ - x₆ * y₇ + x₇ * y₆ - x₈ * y₅) ^ 2 +\n            (x₁ * y₅ - x₂ * y₆ - x₃ * y₇ - x₄ * y₈ + x₅ * y₁ + x₆ * y₂ + x₇ * y₃ + x₈ * y₄) ^ 2 +\n          (x₁ * y₆ + x₂ * y₅ - x₃ * y₈ + x₄ * y₇ - x₅ * y₂ + x₆ * y₁ - x₇ * y₄ + x₈ * y₃) ^ 2 +\n        (x₁ * y₇ + x₂ * y₈ + x₃ * y₅ - x₄ * y₆ - x₅ * y₃ + x₆ * y₄ + x₇ * y₁ - x₈ * y₂) ^ 2 +\n      (x₁ * y₈ - x₂ * y₇ + x₃ * y₆ + x₄ * y₅ - x₅ * y₄ - x₆ * y₃ + x₇ * y₂ + x₈ * y₁) ^ 2",
  "name": "sum_eight_sq_mul_sum_eight_sq",
  "kind": "theorem",
  "doc_string":
  "Degen's eight squares identity, see <https://en.wikipedia.org/wiki/Degen%27s_eight-square_identity>.\n\nThis sign choice here corresponds to the signs obtained by multiplying two octonions.\n",
  "args": ""},
 {"type": "ℤ → ZNum",
  "name": "ZNum.ofInt'",
  "kind": "def",
  "doc_string": "Converts an `Int` to a `ZNum`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α},\n  a < 1 → b ≤ 1 → a * b < 1",
  "name": "Right.mul_lt_one_of_lt_of_le",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one_of_lt_of_le`. ",
  "args": ""},
 {"type":
  "(α : Type u) →\n  (β : Type v) → [inst : Group α] → [inst_1 : AddMonoid β] → [inst_2 : DistribMulAction α β] → α →* AddAut β",
  "name": "DistribMulAction.toAddAut",
  "kind": "def",
  "doc_string":
  "Each element of the group defines an additive monoid isomorphism.\n\nThis is a stronger version of `MulAction.toPermHom`. ",
  "args": ""},
 {"type":
  "Lean.Expr → Lean.Expr → Simps.Config → Lean.MetaM (Array (Lean.Expr × ProjectionData))",
  "name": "simpsGetProjectionExprs",
  "kind": "def",
  "doc_string":
  "Get the projections of a structure used by `@[simps]` applied to the appropriate arguments.\nReturns a list of tuples\n```\n(corresponding right-hand-side, given projection name, projection Expression,\n  future projection numbers, used by default, is prefix)\n```\n(where all fields except the first are packed in a `ProjectionData` structure)\none for each projection. The given projection name is the name for the projection used by the user\nused to generate (and parse) projection names. For example, in the structure\n\nExample 1: ``simpsGetProjectionExprs env `(α × β) `(⟨x, y⟩)`` will give the output\n```\n  [(`(x), `fst, `(@Prod.fst.{u v} α β), [], true, false),\n   (`(y), `snd, `(@Prod.snd.{u v} α β), [], true, false)]\n```\n\nExample 2: ``simpsGetProjectionExprs env `(α ≃ α) `(⟨id, id, fun _ ↦ rfl, fun _ ↦ rfl⟩)``\nwill give the output\n```\n  [(`(id), `apply, (Equiv.toFun), [], true, false),\n   (`(id), `symm_apply, (fun e ↦ e.symm.toFun), [], true, false),\n   ...,\n   ...]\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} {s : Set α} [inst : LinearOrder α] [inst_1 : LinearOrder β] {f : α → β},\n  ¬MonotoneOn f s ∧ ¬AntitoneOn f s ↔ ∃ a x b x c x, a < b ∧ b < c ∧ (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c)",
  "name": "Set.not_monotoneOn_not_antitoneOn_iff_exists_lt_lt",
  "kind": "theorem",
  "doc_string":
  "A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. ",
  "args": ""},
 {"type": "ℕ+ → ℕ+ → ℕ+",
  "name": "PNat.gcd",
  "kind": "def",
  "doc_string":
  "The greatest common divisor (gcd) of two positive natural numbers,\nviewed as positive natural number. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (r : α → α → Prop) → (s : β → β → Prop) → r ≼i Sum.Lex r s",
  "name": "InitialSeg.leAdd",
  "kind": "def",
  "doc_string":
  "Initial segment embedding of an order `r` into the disjoint union of `r` and `s`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : PartialOrder α] → (f : α → α) → (∀ (x : α), x ≤ f x) → (∀ ⦃x y : α⦄, x ≤ f y → f x ≤ f y) → ClosureOperator α",
  "name": "ClosureOperator.mk₂",
  "kind": "def",
  "doc_string":
  "Convenience constructor for a closure operator using the weaker minimality axiom:\n`x ≤ f y → f x ≤ f y`, which is sometimes easier to prove in practice. ",
  "args": ""},
 {"type": "{α : Type u} → α → α → α → α → α → α → α → α → Array α",
  "name": "Array.mkArray8",
  "kind": "def",
  "doc_string": "Create array `#[a₁, a₂, a₃, a₄, a₅, a₆, a₇, a₈]` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulMono α],\n  1 < a → 1 ≤ b → 0 ≤ a → 1 < a * b",
  "name": "Left.lt_mul_of_lt_of_one_le_of_nonneg",
  "kind": "theorem",
  "doc_string": "Assumes left covariance. ",
  "args": ""},
 {"type": "{K : Type u_1} → (ℚ → K) → [inst : Mul K] → ℚ → K → K",
  "name": "qsmulRec",
  "kind": "def",
  "doc_string":
  "The default definition of the scalar multiplication `(a : ℚ) • (x : K)` for a division ring `K`\nis given by `a • x = (↑ a) * x`.\nUse `(a : ℚ) • (x : K)` instead of `qsmulRec` for better definitional behaviour.\n",
  "args": ""},
 {"type": "{α : Type u} → Multiplicative α ≃ α",
  "name": "Multiplicative.toAdd",
  "kind": "def",
  "doc_string": "Reinterpret `x : Multiplicative α` as an element of `α`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → List α → α → List α",
  "name": "List.eraseTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `erase`. ",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α α_1 : Type u_1} {p₁ : (α → α_1) → Prop} {f : m (α → α_1)} {p₂ : α → Prop}\n  [inst : Applicative m] [inst_1 : LawfulApplicative m] {x : m α},\n  SatisfiesM p₁ f → SatisfiesM p₂ x → SatisfiesM (fun c => ∃ f a, p₁ f ∧ p₂ a ∧ c = f a) (Seq.seq f fun x_1 => x)",
  "name": "SatisfiesM.seq_post",
  "kind": "theorem",
  "doc_string":
  "`SatisfiesM` distributes over `<*>`, strongest postcondition version. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddCommGroup α] (self : AddCommGroup.TotalPositiveCone α) (a : α),\n  AddCommGroup.PositiveCone.nonneg self.toPositiveCone a ∨ AddCommGroup.PositiveCone.nonneg self.toPositiveCone (-a)",
  "name": "AddCommGroup.TotalPositiveCone.nonneg_total",
  "kind": "def",
  "doc_string": "Either `a` or `-a` is `nonneg` ",
  "args": ""},
 {"type": "{α : Type u_1} → [self : CompleteLinearOrder α] → DecidableEq α",
  "name": "CompleteLinearOrder.decidable_eq",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "(α : Type u_1) → (β : Type u_2) → α ⊕' β ≃ α ⊕ β",
  "name": "Equiv.psumEquivSum",
  "kind": "def",
  "doc_string": "`PSum` is equivalent to `Sum`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : HasSup α] [inst_1 : HasInf α] (sup_comm : ∀ (a b : α), a ⊔ b = b ⊔ a)\n  (sup_assoc : ∀ (a b c : α), a ⊔ b ⊔ c = a ⊔ (b ⊔ c)) (sup_idem : ∀ (a : α), a ⊔ a = a)\n  (inf_comm : ∀ (a b : α), a ⊓ b = b ⊓ a) (inf_assoc : ∀ (a b c : α), a ⊓ b ⊓ c = a ⊓ (b ⊓ c))\n  (inf_idem : ∀ (a : α), a ⊓ a = a),\n  (∀ (a b : α), a ⊔ a ⊓ b = a) →\n    (∀ (a b : α), a ⊓ (a ⊔ b) = a) → SemilatticeSup.toPartialOrder = SemilatticeInf.toPartialOrder",
  "name": "semilatticeSup_mk'_partialOrder_eq_semilatticeInf_mk'_partialOrder",
  "kind": "theorem",
  "doc_string":
  "The partial orders from `SemilatticeSup_mk'` and `SemilatticeInf_mk'` agree\nif `sup` and `inf` satisfy the lattice absorption laws `sup_inf_self` (`a ⊔ a ⊓ b = a`)\nand `inf_sup_self` (`a ⊓ (a ⊔ b) = a`). ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedMonoid α] (a b : α), a ≤ a * b",
  "name": "CanonicallyOrderedMonoid.le_self_mul",
  "kind": "def",
  "doc_string": "For any `a` and `b`, `a ≤ a * b` ",
  "args": ""},
 {"type":
  "{M₀ : Type u_1} →\n  {M₀' : Type u_2} →\n    [inst : MulZeroOneClass M₀] →\n      [inst_1 : Mul M₀'] →\n        [inst_2 : Zero M₀'] →\n          [inst_3 : One M₀'] →\n            (f : M₀ → M₀') →\n              Function.Surjective f → f 0 = 0 → f 1 = 1 → (∀ (a b : M₀), f (a * b) = f a * f b) → MulZeroOneClass M₀'",
  "name": "Function.Surjective.mulZeroOneClass",
  "kind": "def",
  "doc_string":
  "Pushforward a `MulZeroOneClass` instance along an surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {t : Set α},\n  AntitoneOn f t → ∀ {a : α}, IsLeast t a → IsGreatest (f '' t) (f a)",
  "name": "AntitoneOn.map_isLeast",
  "kind": "theorem",
  "doc_string":
  "An antitone map sends a least element of a set to a greatest element of its image. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {A : Type u_2} [inst : Monoid M] [inst_1 : Monoid A] [self : MulDistribMulAction M A] (r : M),\n  r • 1 = 1",
  "name": "MulDistribMulAction.smul_one",
  "kind": "def",
  "doc_string": "Multiplying `1` by a scalar gives `1` ",
  "args": ""},
 {"type": "List Lean.Expr → Lean.Expr",
  "name": "Mathlib.Tactic.MkIff.mkAndList",
  "kind": "def",
  "doc_string":
  "`mkAndList [x1, x2, ...]` is defined as `x1 ∧ (x2 ∧ ...)`, or `True` if the list is empty. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List (List α)",
  "name": "List.permutations'",
  "kind": "def",
  "doc_string":
  "List of all permutations of `l`. This version of `permutations` is less efficient but has\nsimpler definitional equations. The permutations are in a different order,\nbut are equal up to permutation, as shown by `list.permutations_perm_permutations'`.\n\n     permutations [1, 2, 3] =\n       [[1, 2, 3], [2, 1, 3], [2, 3, 1],\n        [1, 3, 2], [3, 1, 2], [3, 2, 1]] ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (self : M ≃* N) (x y : M),\n  Equiv.toFun self.toEquiv (x * y) = Equiv.toFun self.toEquiv x * Equiv.toFun self.toEquiv y",
  "name": "MulEquiv.map_mul'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves multiplication ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {F : C ⥤ D}\n  [self : CategoryTheory.Full F] {X Y : C} (f : Prefunctor.obj F.toPrefunctor X ⟶ Prefunctor.obj F.toPrefunctor Y),\n  Prefunctor.map F.toPrefunctor (CategoryTheory.Full.preimage f) = f",
  "name": "CategoryTheory.Full.witness",
  "kind": "def",
  "doc_string":
  "The property that `Full.preimage f` of maps to `f` via `F.map`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "LinearOrderedAddCommGroup",
  "kind": "inductive",
  "doc_string":
  "A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → (f : β → α) → Function.Surjective f → α ↪ β",
  "name": "Function.Embedding.ofSurjective",
  "kind": "def",
  "doc_string":
  "A right inverse `surjInv` of a surjective function as an `Embedding`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {F : Type u_3}\n  [mc : MonoidHomClass F M N] (f : F) (s : Set M), Submonoid.map f (Submonoid.closure s) = Submonoid.closure (↑f '' s)",
  "name": "MonoidHom.map_mclosure",
  "kind": "theorem",
  "doc_string":
  "The image under a monoid hom of the submonoid generated by a set equals the submonoid generated\nby the image of the set. ",
  "args": ""},
 {"type":
  "{V : Type u_1} → [inst : Quiver V] → WideSubquiver V ≃ Set (Quiver.Total V)",
  "name": "Quiver.wideSubquiverEquivSetTotal",
  "kind": "def",
  "doc_string":
  "A wide subquiver of `G` can equivalently be viewed as a total set of arrows. ",
  "args": ""},
 {"type": "Num → PosNum",
  "name": "Num.succ'",
  "kind": "def",
  "doc_string": "The successor of a `Num` as a `PosNum`. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.Context → Lean.Expr",
  "name": "Mathlib.Tactic.Abel.Context.α",
  "kind": "def",
  "doc_string":
  "The type of the ambient additive commutative group or monoid. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₂] →\n      [inst_1 : Zero M₂] →\n        [inst_2 : SMul ℕ M₂] →\n          [inst_3 : Neg M₂] →\n            [inst_4 : Sub M₂] →\n              [inst_5 : SMul ℤ M₂] →\n                [inst_6 : AddGroup M₁] →\n                  (f : M₁ → M₂) →\n                    Function.Surjective f →\n                      f 0 = 0 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁), f (-x) = -f x) →\n                            (∀ (x y : M₁), f (x - y) = f x - f y) →\n                              (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) → AddGroup M₂",
  "name": "Function.Surjective.addGroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `0` and `+` is an additive group, if it admits a\nsurjective map that preserves `0` and `+` to an additive group.",
  "args": ""},
 {"type": "Prop",
  "name": "False",
  "kind": "inductive",
  "doc_string":
  "`False` is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. `False` elimination rule, `False.rec`,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : LT α] → [inst : DecidableRel fun x x_1 => x < x_1] → α → α → Ordering",
  "name": "cmp",
  "kind": "def",
  "doc_string":
  "Construct an `Ordering` from a type with a decidable `LT` instance,\nassuming that incomparable terms are `Ordering.eq`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Add α] →\n    [inst_1 : LinearOrder α] → [inst : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] → α → α ↪o α",
  "name": "OrderEmbedding.addLeft",
  "kind": "def",
  "doc_string":
  "The order embedding sending `b` to `a + b`, for some fixed `a`.\nSee also `OrderIso.addLeft` when working in an additive ordered group.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a : α), abs a = a ∧ 0 ≤ a ∨ abs a = -a ∧ a < 0",
  "name": "abs_cases",
  "kind": "theorem",
  "doc_string":
  "For an element `a` of a linear ordered ring, either `abs a = a` and `0 ≤ a`,\nor `abs a = -a` and `a < 0`.\nUse cases on this lemma to automate linarith in inequalities ",
  "args": ""},
 {"type": "(Type u₀ → Type u₁) → Type (max (u₀ + 1) u₁)",
  "name": "EquivFunctor",
  "kind": "inductive",
  "doc_string":
  "An `EquivFunctor` is only functorial with respect to equivalences.\n\nTo construct an `EquivFunctor`, it suffices to supply just the function `f α → f β` from\nan equivalence `α ≃ β`, and then prove the functor laws. It's then a consequence that\nthis function is part of an equivalence, provided by `EquivFunctor.mapEquiv`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α],\n  (∀ (c : Set α), IsChain (fun x x_1 => x ≤ x_1) c → Set.Nonempty c → ¬⊥ ∈ c → ∃ x x_1, x ∈ lowerBounds c) → IsAtomic α",
  "name": "IsAtomic.of_isChain_bounded",
  "kind": "theorem",
  "doc_string":
  "**Zorn's lemma**: A partial order is atomic if every nonempty chain `c`, `⊥ ∉ c`, has an lower\nbound not equal to `⊥`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : IsLowerModularLattice α] {a b : α}, b ⋖ a ⊔ b → a ⊓ b ⋖ a",
  "name": "Covby.inf_of_sup_right",
  "kind": "theorem",
  "doc_string": "**Alias** of `inf_covby_of_covby_sup_right`.",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : AddGroup G] [inst_1 : SubtractionMonoid H]\n  [inst_2 : AddMonoidHomClass F G H] (f : F) (n : ℤ) (g : G), ↑f (n • g) = n • ↑f g",
  "name": "map_zsmul",
  "kind": "theorem",
  "doc_string": "Additive group homomorphisms preserve integer scaling.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b : α}, 0 < b → a - b < a",
  "name": "sub_lt_self",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `sub_lt_self_iff`.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} →\n      {Q : Type u_4} →\n        [inst : AddZeroClass M] →\n          [inst_1 : AddZeroClass N] →\n            [inst_2 : AddCommMonoid P] → [inst_3 : AddCommMonoid Q] → M ≃+ N → P ≃+ Q → (M →+ P) ≃+ (N →+ Q)",
  "name": "AddEquiv.addMonoidHomCongr",
  "kind": "def",
  "doc_string":
  "An additive analogue of `Equiv.arrowCongr`,\nfor additive maps from an additive monoid to a commutative additive monoid.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Ring.tacticRing1!",
  "kind": "def",
  "doc_string":
  "Tactic for solving equations of *commutative* (semi)rings,\nallowing variables in the exponent.\n\n* This version of `ring` fails if the target is not an equality.\n* The variant `ring1!` will use a more aggressive reducibility setting\n  to determine equality of atoms.\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M →+ N) {x y : M},\n  x = y → ↑f x = ↑f y",
  "name": "AddMonoidHom.congr_arg",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.congr_arg` instead.",
  "args": ""},
 {"type":
  "{α : Sort uA} →\n  {β : Sort uB} →\n    {s₁ : Setoid α} →\n      {s₂ : Setoid β} →\n        {motive : Quotient s₁ → Quotient s₂ → Sort uC} →\n          [s : ∀ (a : α) (b : β), Subsingleton (motive (Quotient.mk s₁ a) (Quotient.mk s₂ b))] →\n            (q₁ : Quotient s₁) →\n              (q₂ : Quotient s₂) → ((a : α) → (b : β) → motive (Quotient.mk s₁ a) (Quotient.mk s₂ b)) → motive q₁ q₂",
  "name": "Quotient.recOnSubsingleton₂",
  "kind": "def",
  "doc_string": "Lift a binary function to a quotient on both arguments. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] {a : α}, Order.IsSuccLimit a → Order.IsPredLimit (↑OrderDual.toDual a)",
  "name": "Order.isSuccLimit.dual",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Order.isPredLimit_toDual_iff`.",
  "args": ""},
 {"type":
  "{a : Lean.Level} →\n  {arg : Q(Type a)} → {sα : Q(CommSemiring «$arg»)} → {a_1 : Q(«$arg»)} → Mathlib.Tactic.Ring.ExBase sα a_1 → Bool",
  "name": "Mathlib.Tactic.Ring.ExBase.isAtom",
  "kind": "def",
  "doc_string": "True if this represents an atomic expression. ",
  "args": ""},
 {"type":
  "∀ (α : Type u) [inst : Preorder α] [inst_1 : Nonempty α] [inst_2 : NoMaxOrder α], ∃ f, StrictMono f",
  "name": "Nat.exists_strictMono",
  "kind": "theorem",
  "doc_string":
  "If `α` is a nonempty preorder with no maximal elements, then there exists a strictly monotone\nfunction `ℕ → α`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddCommMonoid M] → (S : AddSubmonoid M) → AddCommMonoid { x // x ∈ S }",
  "name": "AddSubmonoid.toAddCommMonoid",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of an `AddCommMonoid` is an `AddCommMonoid`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_4} {β : Type u_5} {γ : Type u_3} {a : Option α} {b : Option β} {β' : Type u_1} {δ : Type u_2}\n  {f : α → β' → γ} {g : β → β'} {f' : α → β → δ} {g' : δ → γ},\n  (∀ (a : α) (b : β), f a (g b) = g' (f' a b)) → Option.map₂ f a (Option.map g b) = Option.map g' (Option.map₂ f' a b)",
  "name": "Option.map_map₂_right_comm",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Option.map_map₂_distrib_right`. ",
  "args": ""},
 {"type": "∀ {m n : ℕ+}, ↑m = ↑n ↔ m = n",
  "name": "PNat.coe_inj",
  "kind": "theorem",
  "doc_string":
  "We now define a long list of structures on `ℕ+` induced by\nsimilar structures on `ℕ`. Most of these behave in a completely\nobvious way, but there are a few things to be said about\nsubtraction, division and powers.\n",
  "args": ""},
 {"type":
  "Bool →\n  (Lean.Name → Option Lean.Name) →\n    (Lean.Name → Option (List ℕ)) → (Lean.Name → Option Bool) → Lean.Name → Lean.Expr → Bool",
  "name": "ToAdditive.shouldTranslateNumeral",
  "kind": "def",
  "doc_string": "Checks whether a numeral should be translated. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop}, (∀ (a : α), ¬p a) → IsEmpty (Subtype p)",
  "name": "Subtype.isEmpty_of_false",
  "kind": "theorem",
  "doc_string": "subtypes by an all-false predicate are false. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "name": "LinearOrderedCommGroupWithZero.mul_inv_cancel",
  "kind": "def",
  "doc_string": "Every nonzero element of a group with zero is invertible. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Mul M] → Set M → Subsemigroup M",
  "name": "Subsemigroup.closure",
  "kind": "def",
  "doc_string": "The `Subsemigroup` generated by a set. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : Add α] → [inst_1 : Mul α] → [inst_2 : Add β] → [inst_3 : Mul β] → αᵐᵒᵖ ≃+* βᵐᵒᵖ ≃ (α ≃+* β)",
  "name": "RingEquiv.unop",
  "kind": "def",
  "doc_string":
  "The 'unopposite' of a ring iso `αᵐᵒᵖ ≃+* βᵐᵒᵖ`. Inverse to `RingEquiv.op`. ",
  "args": ""},
 {"type": "∀ {α : Sort u} {p : Prop}, Nonempty α → (α → p) → p",
  "name": "Nonempty.elim",
  "kind": "def",
  "doc_string":
  "The elimination principle for `Nonempty α`. If `Nonempty α`, and we can\nprove `p` given any element `x : α`, then `p` holds. Note that it is essential\nthat `p` is a `Prop` here; the version with `p` being a `Sort u` is equivalent\nto `Classical.choice`.\n",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.Context → Lean.Name → Lean.Expr → Array Lean.Expr → Lean.Expr",
  "name": "Mathlib.Tactic.Abel.Context.app",
  "kind": "def",
  "doc_string":
  "Apply the function `n : ∀ {α} [inst : AddWhatever α], _` to the\nimplicit parameters in the context, and the given list of arguments. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_>_»",
  "kind": "def",
  "doc_string": "`a > b` is an abbreviation for `b < a`. ",
  "args": ""},
 {"type":
  "Lean.Name → Lean.ConstantInfo → optParam (List ℕ) [] → Lean.MetaM Lean.ConstantInfo",
  "name": "ToAdditive.updateDecl",
  "kind": "def",
  "doc_string":
  "Run applyReplacementFun on the given `srcDecl` to make a new declaration with name `tgt` ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : MulOneClass M] → Type u_1",
  "name": "Submonoid",
  "kind": "inductive",
  "doc_string":
  "A submonoid of a monoid `M` is a subset containing 1 and closed under multiplication. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b c : α} [inst : LinearOrder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α]\n  [inst_3 : OrderedSub α], a - c < b - c → a < b",
  "name": "lt_of_tsub_lt_tsub_right",
  "kind": "theorem",
  "doc_string":
  "See `lt_of_tsub_lt_tsub_right_of_le` for a weaker statement in a partial order. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Ring.State → Array Lean.Expr",
  "name": "Mathlib.Tactic.Ring.State.atoms",
  "kind": "def",
  "doc_string":
  "The list of atoms-up-to-defeq encountered thus far, used for atom sorting. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} {F : Type u_3} [inst : MulOneClass R] [inst_1 : Monoid S]\n  [inst_2 : MonoidHomClass F R S] (f : F) (r : R) [inst_3 : Invertible r] [ifr : Invertible (↑f r)], ↑f ⅟r = ⅟(↑f r)",
  "name": "map_invOf",
  "kind": "theorem",
  "doc_string":
  "Note that the `invertible (f r)` argument can be satisfied by using `letI := invertible.map f r`\nbefore applying this lemma. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] {a : α}, IsTop a → IsBot (↑OrderDual.toDual a)",
  "name": "IsTop.toDual",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `isBot_toDual_iff`.",
  "args": ""},
 {"type":
  "{p q : Prop} → [inst : Decidable p] → {α : Sort u} → p ∨ q → (p → α) → (q → α) → α",
  "name": "Or.by_cases",
  "kind": "def",
  "doc_string":
  "Construct a non-Prop by cases on an `Or`, when the left conjunct is decidable. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : LinearOrder α] → (x y : α) → {P : Sort u_1} → (x < y → P) → (x = y → P) → (y < x → P) → P",
  "name": "lt_by_cases",
  "kind": "def",
  "doc_string":
  "Perform a case-split on the ordering of `x` and `y` in a decidable linear order. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Add M] →\n      [inst_1 : Add N] → (f : AddHom M N) → {g : N → M} → Function.LeftInverse g ↑f → M ≃+ { x // x ∈ AddHom.srange f }",
  "name": "AddEquiv.ofLeftInverse",
  "kind": "def",
  "doc_string":
  "An additive semigroup homomorphism `f : M →+ N` with a left-inverse\n`g : N → M` defines an additive equivalence between `M` and `f.srange`.\nThis is a bidirectional version of `AddHom.srangeRestrict`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddCommSemigroup α] [inst_1 : PartialOrder α] [inst_2 : ExistsAddOfLE α]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_4 : Sub α] [inst_5 : OrderedSub α]\n  {a b c : α} [inst_6 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1], c ≤ a → a - b < a - c → c < b",
  "name": "lt_of_tsub_lt_tsub_left_of_le",
  "kind": "theorem",
  "doc_string":
  "See `lt_of_tsub_lt_tsub_left` for a stronger statement in a linear order. ",
  "args": ""},
 {"type": "(V : Type u_1) → [inst : Quiver V] → Prop",
  "name": "Quiver.IsPreconnected",
  "kind": "def",
  "doc_string":
  "A quiver is preconnected iff there exists a path between any pair of\nvertices.\nNote that if `V` doesn't `HasReverse`, then the definition is stronger than\nsimply having a preconnected underlying `simple_graph`, since a path in one\ndirection doesn't induce one in the other.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} (n : ℕ) (a : α) (l : List α), List.length (List.leftpad n a l) = max n (List.length l)",
  "name": "List.leftpad_length",
  "kind": "theorem",
  "doc_string":
  "The length of the List returned by `List.leftpad n a l` is equal\nto the larger of `n` and `l.length` ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : AddGroup α] → [inst : AddAction α β] → α → Equiv.Perm β",
  "name": "AddAction.toPerm",
  "kind": "def",
  "doc_string":
  "Given an action of an additive group `α` on `β`, each `g : α` defines a permutation of `β`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → Rel α β → Rel β γ → Rel α γ",
  "name": "Rel.comp",
  "kind": "def",
  "doc_string":
  "Composition of relation; note that it follows the `CategoryTheory/` order of arguments. ",
  "args": ""},
 {"type":
  "{t t' : Type u → Type u} → ((α : Type u) → t α ≃ t' α) → [inst : Functor t] → Functor t'",
  "name": "Equiv.functor",
  "kind": "def",
  "doc_string":
  "The function `Equiv.map` transfers the functoriality of `t` to\n`t'` using the equivalences `eqv`.  ",
  "args": ""},
 {"type": "{α : Type u_1} → α → WithTop α",
  "name": "WithTop.some",
  "kind": "def",
  "doc_string": "The canonical map from `α` into `WithTop α` ",
  "args": ""},
 {"type": "Type",
  "name": "PNat",
  "kind": "def",
  "doc_string":
  "`ℕ+` is the type of positive natural numbers. It is defined as a subtype,\nand the VM representation of `ℕ+` is the same as `ℕ` because the proof\nis not stored. ",
  "args": ""},
 {"type": "∀ {G : Type u_1} [inst : Group G], MulAction.IsPretransitive Gᵐᵒᵖ G",
  "name": "MulAction.OppositeRegular.isPretransitive",
  "kind": "def",
  "doc_string": "The right regular action of a group on itself is transitive. ",
  "args": ""},
 {"type": "∀ {α : Sort u} {a b : α}, a = b → b = a",
  "name": "Eq.symm",
  "kind": "theorem",
  "doc_string":
  "Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
  "args": ""},
 {"type":
  "{R : Type u_1} → [inst : Nontrivial R] → [hR : CommRing R] → (∀ (a : R), IsUnit a ∨ a = 0) → Field R",
  "name": "fieldOfIsUnitOrEqZero",
  "kind": "def",
  "doc_string":
  "Constructs a `Field` structure on a `CommRing` consisting only of units and 0.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{G : Type u_1} → [inst : GroupWithZero G] → (a : G) → a ≠ 0 → Equiv.Perm G",
  "name": "Equiv.mulRight₀",
  "kind": "def",
  "doc_string":
  "Right multiplication by a nonzero element in a `GroupWithZero` is a permutation of the\nunderlying type. ",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ → Prop",
  "name": "Nat.Up",
  "kind": "def",
  "doc_string":
  "A well-ordered relation for \"upwards\" induction on the natural numbers up to some bound `ub`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (α → α → Bool) → (a : Array α) → Fin (Array.size a) → { a' // Array.size a' = Array.size a }",
  "name": "BinaryHeap.heapifyDown",
  "kind": "def",
  "doc_string":
  "Core operation for binary heaps, expressed directly on arrays.\nGiven an array which is a max-heap, push item `i` down to restore the max-heap property. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLinearOrder α] {s : Set α} [hs : Set.OrdConnected s] ⦃t : Set ↑s⦄,\n  Set.Nonempty t → BddAbove t → supₛ (Subtype.val '' t) ∈ s",
  "name": "supₛ_within_of_ordConnected",
  "kind": "theorem",
  "doc_string":
  "The `supₛ` function on a nonempty `OrdConnected` set `s` in a conditionally complete linear\norder takes values within `s`, for all nonempty bounded-above subsets of `s`. ",
  "args": ""},
 {"type": "{n : ℕ} → ℕ → Option (Fin2 n)",
  "name": "Fin2.optOfNat",
  "kind": "def",
  "doc_string": "Converts a natural into a `Fin2` if it is in range ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MulOneClass M] {p : M → Prop} (x : M) {s : Set M},\n  Submonoid.closure s = ⊤ → (∀ (x : M), x ∈ s → p x) → p 1 → (∀ (x y : M), p x → p y → p (x * y)) → p x",
  "name": "Submonoid.dense_induction",
  "kind": "theorem",
  "doc_string":
  "If `s` is a dense set in a monoid `M`, `Submonoid.closure s = ⊤`, then in order to prove that\nsome predicate `p` holds for all `x : M` it suffices to verify `p x` for `x ∈ s`, verify `p 1`,\nand verify that `p x` and `p y` imply `p (x * y)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  AntitoneOn f s → MonotoneOn (f ∘ ↑OrderDual.ofDual) s",
  "name": "AntitoneOn.dual_left",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `monotoneOn_comp_ofDual_iff`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → (¬a ⩿ b ↔ ∃ c, a < c ∧ c < b)",
  "name": "not_wcovby_iff",
  "kind": "theorem",
  "doc_string":
  "If `a ≤ b`, then `b` does not cover `a` iff there's an element in between. ",
  "args": ""},
 {"type": "∀ {p : Prop}, Erased p → p",
  "name": "Erased.out_proof",
  "kind": "theorem",
  "doc_string": "Extracts the erased value, if it is a proof. ",
  "args": ""},
 {"type":
  "List (Lean.Elab.TermElabM Lean.Expr) → Lean.Elab.TermElabM (List Lean.Expr) → ℕ → Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Tactic.SolveByElim.solveByElimAux",
  "kind": "def",
  "doc_string":
  "Attempt to solve the given metavariable by repeating applying a list of facts. ",
  "args": ""},
 {"type":
  "{α : Sort u} →\n  {β : Sort v} →\n    {ra : α → α → Prop} →\n      {rb : β → β → Prop} → (e : α ≃ β) → (∀ (a₁ a₂ : α), ra a₁ a₂ ↔ rb (↑e a₁) (↑e a₂)) → Quot ra ≃ Quot rb",
  "name": "Quot.congr",
  "kind": "def",
  "doc_string":
  "An equivalence `e : α ≃ β` generates an equivalence between quotient spaces,\nif `ra a₁ a₂ ↔ rb (e a₁) (e a₂). ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {s₁ : Setoid α} {p : Quotient s₁ → Prop} (q : Quotient s₁), (∀ (a : α), p (Quotient.mk'' a)) → p q",
  "name": "Quotient.inductionOn'",
  "kind": "theorem",
  "doc_string":
  "A version of `Quotient.inductionOn` taking `{s : Setoid α}` as an implicit argument instead\nof an instance argument. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Mod",
  "kind": "inductive",
  "doc_string":
  "The homogeneous version of `HMod`: `a % b : α` where `a b : α`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : OrderedAddCommMonoid M] → (S : AddSubmonoid M) → OrderedAddCommMonoid { x // x ∈ S }",
  "name": "AddSubmonoid.toOrderedAddCommMonoid",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of an `OrderedAddCommMonoid` is an `OrderedAddCommMonoid`.",
  "args": ""},
 {"type": "∀ (a : ℤ), ↑(Int.natAbs a) ≤ a ^ 2",
  "name": "Int.natAbs_le_self_pow_two",
  "kind": "theorem",
  "doc_string": "**Alias** of `Int.natAbs_le_self_sq`.",
  "args": ""},
 {"type":
  "Lean.Level →\n  Lean.Expr → Lean.Expr → Lean.Expr → List Lean.Expr → Lean.Expr × Lean.Expr → Lean.MetaM (Lean.Expr × Lean.Expr)",
  "name": "Mathlib.Tactic.Choose.mk_sometimes",
  "kind": "def",
  "doc_string":
  "Given `α : Sort u`, `nonemp : Nonempty α`, `p : α → Prop`, a context of free variables\n`ctx`, and a pair of an element `val : α` and `spec : p val`,\n`mk_sometimes u α nonemp p ctx (val, spec)` produces another pair `val', spec'`\nsuch that `val'` does not have any free variables from elements of `ctx` whose types are\npropositions. This is done by applying `Function.sometimes` to abstract over all the propositional\narguments. ",
  "args": ""},
 {"type": "∀ {M₀ : Type u} [self : MulZeroOneClass M₀] (a : M₀), a * 0 = 0",
  "name": "MulZeroOneClass.mul_zero",
  "kind": "def",
  "doc_string": "Zero is a right absorbing element for multiplication ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → Aesop.UnorderedArraySet α",
  "name": "Aesop.UnorderedArraySet.empty",
  "kind": "def",
  "doc_string": "O(1) ",
  "args": ""},
 {"type": "{α : Type u_1} → α → Semiquot α",
  "name": "Semiquot.pure",
  "kind": "def",
  "doc_string":
  "`pure a` is `a` reinterpreted as an unspecified element of `{a}`. ",
  "args": ""},
 {"type":
  "Lean.MVarId → List Lean.Name → List Lean.Expr → List Mathlib.Tactic.MkIff.Shape → Lean.FVarId → Lean.MetaM Unit",
  "name": "Mathlib.Tactic.MkIff.toInductive",
  "kind": "def",
  "doc_string":
  "Proves the right to left direction of a generated iff theorem.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "name": "LE.le.trans",
  "kind": "theorem",
  "doc_string": "**Alias** of `le_trans`.",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.shiftr",
  "kind": "def",
  "doc_string":
  "`shiftr n m` performs returns the `m`-step right shift operation on `n` and\nreturns the resultant number. This is equivalent to performing `⌊n/2ᵐ⌋`",
  "args": ""},
 {"type": "ℕ+ → ℕ+ → ℕ+",
  "name": "PNat.divExact",
  "kind": "def",
  "doc_string":
  "If `h : k | m`, then `k * (div_exact m k) = m`. Note that this is not equal to `m / k`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (zα : Q(Zero «$α»)) →\n      (pα : Q(PartialOrder «$α»)) → (e : Q(«$α»)) → Lean.MetaM (Mathlib.Meta.Positivity.Strictness zα pα e)",
  "name": "Mathlib.Meta.Positivity.core",
  "kind": "def",
  "doc_string":
  "Run each registered `positivity` extension on an expression, returning a `NormNum.Result`. ",
  "args": ""},
 {"type": "∀ {α : Type u_1}, List.Sublist [] []",
  "name": "List.Sublist.slnil",
  "kind": "def",
  "doc_string": "the base case: `[]` is a sublist of `[]` ",
  "args": ""},
 {"type":
  "{M₀ : Type u_1} →\n  {M₀' : Type u_2} →\n    [inst : Zero M₀'] →\n      [inst_1 : Mul M₀'] →\n        [inst_2 : One M₀'] →\n          [inst_3 : Pow M₀' ℕ] →\n            [inst_4 : MonoidWithZero M₀] →\n              (f : M₀ → M₀') →\n                Function.Surjective f →\n                  f 0 = 0 →\n                    f 1 = 1 →\n                      (∀ (x y : M₀), f (x * y) = f x * f y) →\n                        (∀ (x : M₀) (n : ℕ), f (x ^ n) = f x ^ n) → MonoidWithZero M₀'",
  "name": "Function.Surjective.monoidWithZero",
  "kind": "def",
  "doc_string":
  "Pushforward a `MonoidWithZero` along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Sort u} → (α → α → Prop) → Sort (max 1 u)",
  "name": "DecidableRel",
  "kind": "def",
  "doc_string": "A decidable relation. See `Decidable`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : Mul α] → [inst_1 : CommSemigroup β] → (α →ₙ* β) →ₙ* α → β",
  "name": "MulHom.coeFn",
  "kind": "def",
  "doc_string":
  "Coercion of a `MulHom` into a function is itself a `MulHom`.\n\nSee also `MulHom.eval`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] → [inst_1 : Preorder β] → [inst_2 : MulOneClass α] → [inst_3 : MulOneClass β] → One (α →*o β)",
  "name": "OrderMonoidHom.instOneOrderMonoidHom",
  "kind": "def",
  "doc_string": "`1` is the homomorphism sending all elements to `1`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "commandRestate_axiom__",
  "kind": "def",
  "doc_string":
  "__DEPRECATED__: `restate_axiom` was necessary in Lean 3 but is no longer needed for Lean 4.\nIt is still present for backwards compatibility but will probably be removed in the future.\n\n# Original Docstring\n\n`restate_axiom` makes a new copy of a structure field, first definitionally simplifying the type.\nThis is useful to remove `auto_param` or `opt_param` from the statement.\n\nAs an example, we have:\n```lean\nstructure A :=\n(x : ℕ)\n(a' : x = 1 . skip)\n\nexample (z : A) : z.x = 1 := by rw A.a' -- rewrite tactic failed, lemma is not an equality nor a iff\n\nrestate_axiom A.a'\nexample (z : A) : z.x = 1 := by rw A.a\n```\n\nBy default, `restate_axiom` names the new lemma by removing a trailing `'`, or otherwise appending\n`_lemma` if there is no trailing `'`. You can also give `restate_axiom` a second argument to\nspecify the new name, as in\n```lean\nrestate_axiom A.a f\nexample (z : A) : z.x = 1 := by rw A.f\n```\n",
  "args": ""},
 {"type": "∀ {a c b d : Prop}, (a ↔ c) → (b ↔ d) → (a ∨ b ↔ c ∨ d)",
  "name": "Iff.or",
  "kind": "theorem",
  "doc_string": "**Alias** of `or_congr`.",
  "args": ""},
 {"type": "(V : Type u) → [inst : Quiver V] → Prop",
  "name": "Quiver.IsThin",
  "kind": "def",
  "doc_string": "A quiver is thin if it has no parallel arrows. ",
  "args": ""},
 {"type":
  "{f : Type u → Type v} → [self : SeqRight f] → {α β : Type u} → f α → (Unit → f β) → f β",
  "name": "SeqRight.seqRight",
  "kind": "def",
  "doc_string":
  "If `x : F α` and `y : F β`, then `x *> y` evaluates `x`, then `y`,\nand returns the result of `y`.\n\nTo avoid surprising evaluation semantics, `y` is taken \"lazily\", using a\n`Unit → f β` function. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Prop",
  "name": "LeftOrdContinuous",
  "kind": "def",
  "doc_string":
  "A function `f` between preorders is left order continuous if it preserves all suprema.  We\ndefine it using `is_lub` instead of `Sup` so that the proof works both for complete lattices and\nconditionally complete lattices. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : HasSup α] →\n    [inst_1 : HasInf α] →\n      (∀ (a b : α), a ⊔ b = b ⊔ a) →\n        (∀ (a b c : α), a ⊔ b ⊔ c = a ⊔ (b ⊔ c)) →\n          (∀ (a b : α), a ⊓ b = b ⊓ a) →\n            (∀ (a b c : α), a ⊓ b ⊓ c = a ⊓ (b ⊓ c)) →\n              (∀ (a b : α), a ⊔ a ⊓ b = a) → (∀ (a b : α), a ⊓ (a ⊔ b) = a) → Lattice α",
  "name": "Lattice.mk'",
  "kind": "def",
  "doc_string":
  "A type with a pair of commutative and associative binary operations which satisfy two absorption\nlaws relating the two operations has the structure of a lattice.\n\nThe partial order is defined so that `a ≤ b` unfolds to `a ⊔ b = b`; cf. `sup_eq_right`.\n",
  "args": ""},
 {"type": "ByteSlice → String",
  "name": "ByteSlice.toString",
  "kind": "def",
  "doc_string":
  "Convert a byte slice into a string. This does not handle non-ASCII characters correctly:\nevery byte will become a unicode character with codepoint < 256. ",
  "args": ""},
 {"type": "(m : Type u → Type v) → [inst : Applicative m] → Prop",
  "name": "CommApplicative",
  "kind": "inductive",
  "doc_string":
  "A `CommApplicative` functor `m` is a (lawful) applicative functor which behaves identically on\n`α × β` and `β × α`, so computations can occur in either order. ",
  "args": ""},
 {"type": "Linarith.LinarithM Unit",
  "name": "Linarith.elimAllVarsM",
  "kind": "def",
  "doc_string":
  "`elimAllVarsM` eliminates all variables from the linarith state, leaving it with a set of\nground comparisons. If this succeeds without exception, the original `linarith` state is consistent.\n",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → α ≃ β → β → α",
  "name": "Equiv.Simps.symm_apply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [inst : Monoid M] →\n        [inst_1 : MulAction M α] →\n          [inst_2 : SMul M β] →\n            (f : α → β) → Function.Surjective f → (∀ (c : M) (x : α), f (c • x) = c • f x) → MulAction M β",
  "name": "Function.Surjective.mulAction",
  "kind": "def",
  "doc_string":
  "Pushforward a multiplicative action along a surjective map respecting `•`.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : One M] → [inst_1 : One N] → OneHom M N → OneHom (WithTop M) (WithTop N)",
  "name": "OneHom.withTopMap",
  "kind": "def",
  "doc_string": "A version of `WithTop.map` for `OneHom`s. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "attrTo_additive!?_",
  "kind": "def",
  "doc_string": "The `to_additive` attribute. ",
  "args": ""},
 {"type": "ToAdditive.Config → Bool",
  "name": "ToAdditive.Config.trace",
  "kind": "def",
  "doc_string":
  "View the trace of the to_additive procedure.\nEquivalent to `set_option trace.to_additive true`. ",
  "args": ""},
 {"type": "∀ {α : Sort u} {a : α}, HEq a a",
  "name": "HEq.rfl",
  "kind": "def",
  "doc_string": "A version of `HEq.refl` with an implicit argument. ",
  "args": ""},
 {"type": "∀ (α : Type u), IsEquiv α fun x x_1 => x = x_1",
  "name": "eq_isEquiv",
  "kind": "def",
  "doc_string": "Equality is an equivalence relation. ",
  "args": ""},
 {"type":
  "Type u_1 →\n  (α : outParam (Type u_2)) →\n    (β : outParam (Type u_3)) →\n      [inst : Preorder α] →\n        [inst : Preorder β] → [inst : AddZeroClass α] → [inst : AddZeroClass β] → Type (max (max u_1 u_2) u_3)",
  "name": "OrderAddMonoidHomClass",
  "kind": "inductive",
  "doc_string":
  "`OrderAddMonoidHomClass F α β` states that `F` is a type of ordered monoid homomorphisms.\n\nYou should also extend this typeclass when you extend `OrderAddMonoidHom`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → Option α × BinaryHeap α lt",
  "name": "BinaryHeap.extractMax",
  "kind": "def",
  "doc_string":
  "`O(log n)`. Return and remove the maximum element from a `BinaryHeap`. ",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} →\n  [inst : Applicative m] → {α : Type u_3} → {β : Type u_1} → (α → m β) → Option α → m (Option β)",
  "name": "Option.mapA",
  "kind": "def",
  "doc_string": "Like `Option.mapM` but for applicative functors. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → { a // p a } ⊕ { a // ¬p a } ≃ α",
  "name": "Equiv.sumCompl",
  "kind": "def",
  "doc_string":
  "For any predicate `p` on `α`,\nthe sum of the two subtypes `{a // p a}` and its complement `{a // ¬ p a}`\nis naturally equivalent to `α`.\n\nSee `subtypeOrEquiv` for sum types over subtypes `{x // p x}` and `{x // q x}`\nthat are not necessarily `IsCompl p q`.  ",
  "args": ""},
 {"type": "ZNum → ZNum → ZNum",
  "name": "ZNum.div",
  "kind": "def",
  "doc_string": "Division of `ZNum`, where `x / 0 = 0`. ",
  "args": ""},
 {"type": "ZNum → Option PosNum",
  "name": "PosNum.ofZNum'",
  "kind": "def",
  "doc_string":
  "Converts a `ZNum` to `Option PosNum`, where it is `some` if the `ZNum` was positive and `none`\notherwise. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} → [inst : Mul M] → [inst_1 : Mul N] → [inst_2 : Mul P] → (N →ₙ* P) → (M →ₙ* N) → M →ₙ* P",
  "name": "MulHom.comp",
  "kind": "def",
  "doc_string": "Composition of `MulHom`s as a `MulHom`. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : One M₁] →\n        [inst_2 : Pow M₁ ℕ] →\n          [inst_3 : CancelMonoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 1 = 1 →\n                  (∀ (x y : M₁), f (x * y) = f x * f y) → (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) → CancelMonoid M₁",
  "name": "Function.Injective.cancelMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `1` and `*` is a cancel monoid, if it admits an injective map that preserves\n`1` and `*` to a cancel monoid. See note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → [inst : CommMonoid R] → (S : Submonoid R) → OreLocalization.OreSet S",
  "name": "OreLocalization.oreSetComm",
  "kind": "def",
  "doc_string": "Every submonoid of a commutative monoid is an Ore set. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {s₁ : Setoid α} →\n      {s₂ : Setoid β} →\n        {φ : Quotient s₁ → Quotient s₂ → Sort u_3} →\n          [inst : ∀ (a : α) (b : β), Subsingleton (φ (Quotient.mk s₁ a) (Quotient.mk s₂ b))] →\n            (q₁ : Quotient s₁) →\n              (q₂ : Quotient s₂) → ((a₁ : α) → (a₂ : β) → φ (Quotient.mk'' a₁) (Quotient.mk'' a₂)) → φ q₁ q₂",
  "name": "Quotient.recOnSubsingleton₂'",
  "kind": "def",
  "doc_string":
  "A version of `Quotient.recOnSubsingleton₂` taking `{s₁ : Setoid α} {s₂ : Setoid α}`\nas implicit arguments instead of instance arguments. ",
  "args": ""},
 {"type": "∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c",
  "name": "Or.elim",
  "kind": "theorem",
  "doc_string":
  "Proof by cases on an `Or`. If `a ∨ b`, and both `a` and `b` imply\nproposition `c`, then `c` is true.\n",
  "args": ""},
 {"type": "Lean.Name → Lean.Name → Lean.Syntax → Lean.MetaM Unit",
  "name": "Mathlib.Tactic.MkIff.mkIffOfInductivePropImpl",
  "kind": "def",
  "doc_string":
  "Implementation for both `mk_iff` and `mk_iff_of_inductive_prop`.y\n",
  "args": ""},
 {"type":
  "∀ (α : Type u) [inst : Preorder α] [inst_1 : Nonempty α] [inst_2 : NoMinOrder α] [inst_3 : NoMaxOrder α],\n  ∃ f, StrictAnti f",
  "name": "Int.exists_strictAnti",
  "kind": "theorem",
  "doc_string":
  "If `α` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly\nantitone function `f : ℤ → α`. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} → [inst_1 : CategoryTheory.Category D] → C ⥤ D → Type (max (max u₁ v₁) v₂)",
  "name": "CategoryTheory.Full",
  "kind": "inductive",
  "doc_string":
  "A functor `F : C ⥤ D` is full if for each `X Y : C`, `F.map` is surjective.\nIn fact, we use a constructive definition, so the `Full F` typeclass contains data,\nspecifying a particular preimage of each `f : F.obj X ⟶ F.obj Y`.\n\nSee <https://stacks.math.columbia.edu/tag/001C>.\n",
  "args": ""},
 {"type":
  "∀ (α : Type u) [inst : OrderedCommGroup α],\n  ContravariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1",
  "name": "OrderedCommGroup.to_contravariantClass_right_le",
  "kind": "def",
  "doc_string": "A choice-free shortcut instance. ",
  "args": ""},
 {"type": "{ε σ α : Type u} → α → σ → EStateM.Result ε σ α",
  "name": "EStateM.Result.ok",
  "kind": "def",
  "doc_string": "A success value of type `α`, and a new state `σ`. ",
  "args": ""},
 {"type": "{β : Sort v} → (β → β → Prop) → Prop",
  "name": "Reflexive",
  "kind": "def",
  "doc_string": "A reflexive relation relates every element to itself. ",
  "args": ""},
 {"type": "ℕ+ → ℕ",
  "name": "PNat.natPred",
  "kind": "def",
  "doc_string": "Predecessor of a `ℕ+`, as a `ℕ`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddCommSemigroup α] [inst_1 : PartialOrder α] [inst_2 : ExistsAddOfLE α]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_4 : Sub α] [inst : OrderedSub α]\n  {a b c : α}, c ≤ b → a - c < b - c → a < b",
  "name": "lt_of_tsub_lt_tsub_right_of_le",
  "kind": "theorem",
  "doc_string":
  "See `lt_of_tsub_lt_tsub_right` for a stronger statement in a linear order. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u₃} → [inst_2 : CategoryTheory.Category E] → {G H : C ⥤ D} → (G ≅ H) → (F : D ⥤ E) → G ⋙ F ≅ H ⋙ F",
  "name": "CategoryTheory.isoWhiskerRight",
  "kind": "def",
  "doc_string":
  "If `α : G ≅ H` then\n`iso_whisker_right α F : (G ⋙ F) ≅ (H ⋙ F)` has components `F.map_iso (α.app X)`.\n",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (a : G₀), GroupWithZero.zpow 0 a = 1",
  "name": "GroupWithZero.zpow_zero'",
  "kind": "def",
  "doc_string": "`a ^ 0 = 1` ",
  "args": ""},
 {"type":
  "{α₂ : Type u_1} → {α₁ : Type u_2} → {β : α₂ → Type u_3} → (e : α₁ ≃ α₂) → (a : α₁) × β (↑e a) ≃ (a : α₂) × β a",
  "name": "Equiv.sigmaCongrLeft",
  "kind": "def",
  "doc_string":
  "An equivalence `f : α₁ ≃ α₂` generates an equivalence between `Σ a, β (f a)` and `Σ a, β a`. ",
  "args": ""},
 {"type": "{p : ℕ → Prop} → (x : Nat.Upto p) → ¬p ↑x → Nat.Upto p",
  "name": "Nat.Upto.succ",
  "kind": "def",
  "doc_string":
  "The successor of `n` is in `Nat.Upto p` provided that `n` doesn't satisfy `p`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (t : Set β) {f : α → β},\n  Function.Bijective f → Function.Bijective (Set.restrictPreimage t f)",
  "name": "Function.Bijective.restrictPreimage",
  "kind": "theorem",
  "doc_string": "**Alias** of `Set.restrictPreimage_bijective`.",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {G : Type u_2} {N : Type u_3} [inst : SubtractionMonoid G] [inst_1 : AddMonoid N]\n  [inst_2 : AddMonoidHomClass F G N] {x : G}, IsAddUnit x → ∀ (f g : F), ↑f x = ↑g x → ↑f (-x) = ↑g (-x)",
  "name": "IsAddUnit.eq_on_neg",
  "kind": "theorem",
  "doc_string":
  "If two homomorphisms from a subtraction monoid to an additive monoid are equal at an\nadditive unit `x`, then they are equal at `-x`.",
  "args": ""},
 {"type":
  "{f : Type u → Type v} → [self : Functor f] → {α β : Type u} → α → f β → f α",
  "name": "Functor.mapConst",
  "kind": "def",
  "doc_string":
  "The special case `const a <$> x`, which can sometimes be implemented more\nefficiently. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a < 0 → b ≤ 0 → a + b < 0",
  "name": "add_neg_of_neg_of_nonpos",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.add_neg_of_neg_of_nonpos`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Monoid α] {a b u : α}, IsUnit u → (a * u ∣ b ↔ a ∣ b)",
  "name": "IsUnit.mul_right_dvd",
  "kind": "theorem",
  "doc_string":
  "In a monoid, an element a divides an element b iff all associates of `a` divide `b`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : DecidableEq α] (i j : α), Function.Involutive ((fun x x_1 => x * x_1) (Equiv.swap i j))",
  "name": "Equiv.swap_mul_involutive",
  "kind": "theorem",
  "doc_string": "A stronger version of `mul_right_injective` ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → [inst : IsEmpty α] → (β : α → Sort v) → Unique ((a : α) → β a)",
  "name": "Pi.uniqueOfIsEmpty",
  "kind": "def",
  "doc_string": "There is a unique function on an empty domain. ",
  "args": ""},
 {"type": "Bool → PosNum → PosNum",
  "name": "PosNum.bit",
  "kind": "def",
  "doc_string":
  "`bit b n` appends the bit `b` to the end of `n`, where `bit tt x = x1` and `bit ff x = x0`. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} {l : List α}, 0 < List.length l → l ≠ []",
  "name": "List.ne_nil_of_length_pos",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `List.length_pos`.",
  "args": ""},
 {"type": "(α : Sort u_1) → [s : Setoid α] → Quotient s ↪ α",
  "name": "Function.Embedding.quotientOut",
  "kind": "def",
  "doc_string": "`Quotient.out` as an embedding. ",
  "args": ""},
 {"type": "{α : Type u₁} → {β : Type u₂} → (α → β → Prop) → Prop",
  "name": "Relator.RightTotal",
  "kind": "def",
  "doc_string":
  "A relation is \"right total\" if every element appears on the right. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : CoheytingAlgebra α] → α → α",
  "name": "Coheyting.boundary",
  "kind": "def",
  "doc_string":
  "The boundary of an element of a co-Heyting algebra is the intersection of its Heyting negation\nwith itself. Note that this is always `⊥` for a boolean algebra. ",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (n : ℕ) (a : G₀),\n  GroupWithZero.zpow (Int.ofNat (Nat.succ n)) a = a * GroupWithZero.zpow (Int.ofNat n) a",
  "name": "GroupWithZero.zpow_succ'",
  "kind": "def",
  "doc_string": "`a ^ (n + 1) = a * a ^ n` ",
  "args": ""},
 {"type": "∀ {α : Type u_1} (f : α → Set α), ¬Function.Surjective f",
  "name": "Function.cantor_surjective",
  "kind": "theorem",
  "doc_string":
  "**Cantor's diagonal argument** implies that there are no surjective functions from `α`\nto `Set α`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : Preorder β] {a : α} {f : α → β},\n  MonotoneOn f (Set.Iic a) → MonotoneOn f (Set.Ici a) → Monotone f",
  "name": "MonotoneOn.Iic_union_Ici",
  "kind": "theorem",
  "doc_string":
  "If `f` is monotone both on `(-∞, a]` and `[a, ∞)`, then it is monotone on the whole line. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : BEq α] → List α → List α → List α",
  "name": "List.removeAll",
  "kind": "def",
  "doc_string":
  "`O(|xs|)`. Computes the \"set difference\" of lists,\nby filtering out all elements of `xs` which are also in `ys`.\n* `removeAll [1, 1, 5, 1, 2, 4, 5] [1, 2, 2] = [5, 4, 5]`\n ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsStrictWeakOrder",
  "kind": "inductive",
  "doc_string":
  "`IsStrictWeakOrder X lt` means that the binary relation `lt` on `X` is a strict weak order,\nthat is, `IsStrictOrder X lt` and `IsIncompTrans X lt`. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_2} [inst : DecidableEq α] {β : Sort u_1} {v : α → β} {i j : α},\n  v i = v j → ∀ (k : α), v (↑(Equiv.swap i j) k) = v k",
  "name": "Equiv.apply_swap_eq_self",
  "kind": "theorem",
  "doc_string":
  "A function is invariant to a swap if it is equal at both elements ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : LE α] → (α → Set β) → α → Set β",
  "name": "Set.Accumulate",
  "kind": "def",
  "doc_string": "`Accumulate s` is the union of `s y` for `y ≤ x`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → {S : Type u_2} → [inst : NonAssocSemiring R] → [inst : NonAssocSemiring S] → NonAssocSemiring (R × S)",
  "name": "Prod.instNonAssocSemiringProd",
  "kind": "def",
  "doc_string": "Product of two `NonAssocSemiring`s is a `NonAssocSemiring`. ",
  "args": ""},
 {"type": "{α : Type u_1} → Set α → Semiquot α → Semiquot α",
  "name": "Semiquot.blur",
  "kind": "def",
  "doc_string": "Replace `s` in a `q : Semiquot α` with a union `s ∪ q.s` ",
  "args": ""},
 {"type": "{V : Type u} → [inst : Quiver V] → V → Prop",
  "name": "Quiver.RootedConnected",
  "kind": "inductive",
  "doc_string":
  "`RootedConnected r` means that there is a path from `r` to any other vertex. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ infₛ s",
  "name": "CompleteBooleanAlgebra.le_infₛ",
  "kind": "def",
  "doc_string": "Any lower bound is less than the set infimum. ",
  "args": ""},
 {"type": "{α : Type u} → LazyList (LazyList α) → LazyList α",
  "name": "LazyList.join",
  "kind": "def",
  "doc_string": "The monadic join operation for lazy lists. ",
  "args": ""},
 {"type": "List (Lean.Expr × ℕ) → Lean.MetaM Lean.Expr",
  "name": "Linarith.mkLTZeroProof",
  "kind": "def",
  "doc_string":
  "`mkLTZeroProof coeffs pfs` takes a list of proofs of the form `tᵢ Rᵢ 0`,\npaired with coefficients `cᵢ`.\nIt produces a proof that `∑cᵢ * tᵢ R 0`, where `R` is as strong as possible.\n",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : LinearOrderedCommMonoidWithZero α], 0 ≤ 1",
  "name": "LinearOrderedCommMonoidWithZero.zero_le_one",
  "kind": "def",
  "doc_string": "`0 ≤ 1` in any linearly ordered commutative monoid. ",
  "args": ""},
 {"type": "{α : Sort u_1} → [h : Nonempty α] → Inhabited α",
  "name": "Classical.inhabited_of_nonempty'",
  "kind": "def",
  "doc_string":
  "Using `Classical.choice`, lifts a (`Prop`-valued) `Nonempty` instance to a (`Type`-valued)\n`Inhabited` instance. `Classical.inhabited_of_nonempty` already exists, in\n`Init/Classical.lean`, but the assumption is not a type class argument,\nwhich makes it unsuitable for some applications. ",
  "args": ""},
 {"type": "Sort u → Prop",
  "name": "Countable",
  "kind": "inductive",
  "doc_string":
  "A type `α` is countable if there exists an injective map `α → ℕ`. ",
  "args": ""},
 {"type": "∀ {G : Type u_1} [inst : DivInvMonoid G] (a b : G), a / b = a * b⁻¹",
  "name": "division_def",
  "kind": "theorem",
  "doc_string": "**Alias** of `div_eq_mul_inv`.",
  "args": ""},
 {"type": "{a : Prop} → (b : Bool) → (b = true ↔ a) → Decidable a",
  "name": "decidable_of_bool",
  "kind": "def",
  "doc_string":
  "Prove that `a` is decidable by constructing a boolean `b` and a proof that `b ↔ a`.\n(This is sometimes taken as an alternate definition of decidability.) ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : MulOneClass α] → [inst_1 : MulOneClass β] → (α →* β) ≃ (Additive α →+ Additive β)",
  "name": "MonoidHom.toAdditive",
  "kind": "def",
  "doc_string": "Reinterpret `α →* β` as `Additive α →+ Additive β`. ",
  "args": ""},
 {"type": "∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a",
  "name": "Commute.refl",
  "kind": "theorem",
  "doc_string": "Any element commutes with itself. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : AddLeftCancelSemigroup M₂] →\n        (f : M₁ → M₂) → Function.Injective f → (∀ (x y : M₁), f (x + y) = f x + f y) → AddLeftCancelSemigroup M₁",
  "name": "Function.Injective.addLeftCancelSemigroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `+` is an additive left cancel\nsemigroup, if it admits an injective map that preserves `+` to an additive left cancel semigroup.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] {a b : αᵒᵈ}, b < a → ↑OrderDual.ofDual a < ↑OrderDual.ofDual b",
  "name": "LT.lt.ofDual",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `OrderDual.ofDual_lt_ofDual`.",
  "args": ""},
 {"type":
  "(R : Type u_1) → (S : Type u_2) → [inst : NonAssocSemiring R] → [inst_1 : NonAssocSemiring S] → R × S →+* R",
  "name": "RingHom.fst",
  "kind": "def",
  "doc_string":
  "Given semirings `R`, `S`, the natural projection homomorphism from `R × S` to `R`.",
  "args": ""},
 {"type": "∀ {α : Type u} [self : BooleanAlgebra α] (a : α), a ≤ ⊤",
  "name": "BooleanAlgebra.le_top",
  "kind": "def",
  "doc_string": "`⊤` is the greatest element ",
  "args": ""},
 {"type": "{β : Sort v} → (β → β → Prop) → Prop",
  "name": "Total",
  "kind": "def",
  "doc_string":
  "A relation is total if for all `x` and `y`, either `x ≺ y` or `y ≺ x`. ",
  "args": ""},
 {"type": "∀ {α : Type u} (v : Vector α 0), v = Vector.nil",
  "name": "Vector.eq_nil",
  "kind": "theorem",
  "doc_string": "A vector of length `0` is a `nil` vector. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : OrderedSemiring S] {R : Type u_2} [inst_1 : Semiring R] {f : R → S} [self : IsAbsoluteValue f]\n  (x : R), 0 ≤ f x",
  "name": "IsAbsoluteValue.abv_nonneg",
  "kind": "def",
  "doc_string": "The absolute value is nonnegative ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] {f g : M →ₙ* N}, f = g → ∀ (x : M), ↑f x = ↑g x",
  "name": "MulHom.congr_fun",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.congr_fun` instead. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → List α → List β → List (α × Option β)",
  "name": "List.zipLeft",
  "kind": "def",
  "doc_string":
  "Left-biased version of `List.zip`. `zipLeft as bs` returns the list of pairs\n`(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, the\nremaining `aᵢ` are paired with `none`.\n```\nzipLeft [1, 2] ['a'] = [(1, some 'a'), (2, none)]\nzipLeft [1] ['a', 'b'] = [(1, some 'a')]\nzipLeft = zipWithLeft prod.mk\n```\n",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Set α → Set β → Prop",
  "name": "Set.SurjOn",
  "kind": "def",
  "doc_string":
  "`f` is surjective from `a` to `b` if `b` is contained in the image of `a`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {α : Type u_3} [inst : Preorder α] [inst_1 : Preorder N] {f : N → α}\n  [inst_2 : CovariantClass M N μ fun x x_1 => x ≤ x_1], Monotone f → ∀ (m : M), Monotone fun n => f (μ m n)",
  "name": "Monotone.covariant_of_const",
  "kind": "theorem",
  "doc_string":
  "A monotone function remains monotone when composed with the partial application\nof a covariant operator. E.g., `∀ (m : ℕ), monotone f → monotone (λ n, f (m + n))`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : MulOneClass M] → CompleteLattice (Submonoid M)",
  "name": "Submonoid.instCompleteLatticeSubmonoid",
  "kind": "def",
  "doc_string": "Submonoids of a monoid form a complete lattice. ",
  "args": ""},
 {"type": "{α : Type u} → Array α → Array α → Array α",
  "name": "Array.appendCore",
  "kind": "def",
  "doc_string": "Slower `Array.append` used in quotations. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : Preorder β] {a : α} {f : α → β},\n  StrictMonoOn f (Set.Iic a) → StrictMonoOn f (Set.Ici a) → StrictMono f",
  "name": "StrictMonoOn.Iic_union_Ici",
  "kind": "theorem",
  "doc_string":
  "If `f` is strictly monotone both on `(-∞, a]` and `[a, ∞)`, then it is strictly monotone on the\nwhole line. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "DivisionSemiring",
  "kind": "inductive",
  "doc_string":
  "A `DivisionSemiring` is a `Semiring` with multiplicative inverses for nonzero elements. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → List (α × β) → List α × List β",
  "name": "List.unzip",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. Separates a list of pairs into two lists containing the first components and second components.\n* `unzip [(x₁, y₁), (x₂, y₂), (x₃, y₃)] = ([x₁, x₂, x₃], [y₁, y₂, y₃])`\n",
  "args": ""},
 {"type":
  "(α : Type u) → (β : Type v) → [inst : EmptyCollection β] → [inst : Insert α β] → [inst : Singleton α β] → Prop",
  "name": "IsLawfulSingleton",
  "kind": "inductive",
  "doc_string": "`insert x ∅ = {x}` ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«binderTerm∈_»",
  "kind": "def",
  "doc_string": "Declare `∃ x ∈ y, ...` as syntax for `∃ x, x ∈ y ∧ ...` ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_2} {σ : α → Sort u_1} (P : Prop) [inst : Decidable P] (f g : (a : α) → σ a) (a : α),\n  ite P f g a = if P then f a else g a",
  "name": "ite_apply",
  "kind": "theorem",
  "doc_string":
  "A 'ite' producing a `Pi` type `Π a, σ a`, applied to a value `a : α` is a `ite` that applies\neither branch to `a`. ",
  "args": ""},
 {"type":
  "{α : Type} → (xs : Array (SlimCheck.Gen α)) → autoParam (0 < Array.size xs) _auto✝ → SlimCheck.Gen α",
  "name": "SlimCheck.Gen.oneOf",
  "kind": "def",
  "doc_string":
  "Given a list of example generators, choose one to create an example. ",
  "args": ""},
 {"type": "ℕ → Type",
  "name": "Fin2",
  "kind": "inductive",
  "doc_string":
  "An alternate definition of `Fin n` defined as an inductive type instead of a subtype of `ℕ`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term∅»",
  "kind": "def",
  "doc_string":
  "`∅` or `{}` is the empty set or empty collection.\nIt is supported by the `EmptyCollection` typeclass. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : BiheytingAlgebra α] (a : α), ⊤ \\ a = ￢a",
  "name": "BiheytingAlgebra.top_sdiff",
  "kind": "def",
  "doc_string": "`⊤ \\ a` is `￢a` ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} [inst : Subsingleton α], Function.Surjective f → Subsingleton β",
  "name": "Function.Surjective.subsingleton",
  "kind": "theorem",
  "doc_string":
  "If the domain of a surjective function is a subsingleton, then the codomain is a subsingleton as\nwell. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Abel.abel1",
  "kind": "def",
  "doc_string":
  "Tactic for solving equations in the language of\n*additive*, commutative monoids and groups.\nThis version of `abel` fails if the target is not an equality\nthat is provable by the axioms of commutative monoids/groups.\n\n`abel1!` will use a more aggressive reducibility setting to identify atoms.\nThis can prove goals that `abel` cannot, but is more expensive.\n",
  "args": ""},
 {"type":
  "{α : Sort u} →\n  {s : Setoid α} →\n    {motive : Quotient s → Sort v} →\n      (q : Quotient s) →\n        (f : (a : α) → motive (Quotient.mk s a)) →\n          (∀ (a b : α) (p : a ≈ b), (_ : Quotient.mk s a = Quotient.mk s b) ▸ f a = f b) → motive q",
  "name": "Quotient.recOn",
  "kind": "def",
  "doc_string":
  "The analogue of `Quot.recOn` for `Quotient`. See `Quot.recOn`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a : Q(«$α»)} →\n        Mathlib.Tactic.Ring.ExSum sα a →\n          (n : Q(ℕ)) → Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExSum sα) q(«$a» ^ «$n»)",
  "name": "Mathlib.Tactic.Ring.evalPowNat",
  "kind": "opaque",
  "doc_string":
  "The main case of exponentiation of ring expressions is when `va` is a polynomial and `n` is a\nnonzero literal expression, like `(x + y)^5`. In this case we work out the polynomial completely\ninto a sum of monomials.\n\n* `x ^ 1 = x`\n* `x ^ (2*n) = x ^ n * x ^ n`\n* `x ^ (2*n+1) = x ^ n * x ^ n * x`\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Monoid α] {a b : α} {u : αˣ}, a ∣ b * ↑u ↔ a ∣ b",
  "name": "Units.dvd_mul_right",
  "kind": "theorem",
  "doc_string":
  "In a monoid, an element `a` divides an element `b` iff `a` divides all\nassociates of `b`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedSemifield α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "name": "LinearOrderedSemifield.mul_inv_cancel",
  "kind": "def",
  "doc_string": "Every nonzero element of a group with zero is invertible. ",
  "args": ""},
 {"type":
  "Linarith.LinarithConfig → Option (List Linarith.GlobalBranchingPreprocessor)",
  "name": "Linarith.LinarithConfig.preprocessors",
  "kind": "def",
  "doc_string": "Override the list of preprocessors. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (P : Prop) [inst : Decidable P] (x : P → α) (y : ¬P → α),\n  f (dite P x y) = if h : P then f (x h) else f (y h)",
  "name": "apply_dite",
  "kind": "theorem",
  "doc_string":
  "A function applied to a `dite` is a `dite` of that function applied to each of the branches. ",
  "args": ""},
 {"type": "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a",
  "name": "sq",
  "kind": "theorem",
  "doc_string": "**Alias** of `pow_two`.",
  "args": ""},
 {"type":
  "(α : Type u) →\n  [inst : Lattice α] →\n    [inst_1 : DecidableEq α] →\n      [inst_2 : DecidableRel fun x x_1 => x ≤ x_1] →\n        [inst_3 : DecidableRel fun x x_1 => x < x_1] → [inst : IsTotal α fun x x_1 => x ≤ x_1] → LinearOrder α",
  "name": "Lattice.toLinearOrder",
  "kind": "def",
  "doc_string":
  "A lattice with total order is a linear order.\n\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddCommGroup",
  "kind": "inductive",
  "doc_string":
  "An additive commutative group is an additive group with commutative `(+)`. ",
  "args": ""},
 {"type": "(α : Type u) → [inst : Preorder α] → Type (max 1 u)",
  "name": "BoundedRandom",
  "kind": "inductive",
  "doc_string":
  "`BoundedRandom α` gives us machinery to generate values of type `α` between certain bounds ",
  "args": ""},
 {"type":
  "{e : Type v} → {α : Type u_1} → {β : Type u_2} → e ⊕ α → (α → e ⊕ β) → e ⊕ β",
  "name": "Sum.bind",
  "kind": "def",
  "doc_string": "The monadic `bind` operation for `Sum`. ",
  "args": ""},
 {"type": "{p : Prop} → ℕ → SlimCheck.TestResult p → SlimCheck.TestResult p",
  "name": "SlimCheck.giveUp",
  "kind": "def",
  "doc_string": "Count the number of times the test procedure gave up. ",
  "args": ""},
 {"type": "{R : Type u} → [self : NatCast R] → ℕ → R",
  "name": "NatCast.natCast",
  "kind": "def",
  "doc_string": "The canonical map `Nat → R`. ",
  "args": ""},
 {"type": "∀ (α : Type u_1) [inst : LeftCancelMonoid α], FaithfulSMul αᵐᵒᵖ α",
  "name": "LeftCancelMonoid.toFaithfulSMul_opposite",
  "kind": "def",
  "doc_string":
  "`Monoid.toOppositeMulAction` is faithful on cancellative monoids. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "name": "congr_fun",
  "kind": "theorem",
  "doc_string": "**Alias** of `congrFun`.",
  "args": ""},
 {"type": "(R : Type u_1) → [inst : Mul R] → [inst : Add R] → Type",
  "name": "LeftDistribClass",
  "kind": "inductive",
  "doc_string":
  "A typeclass stating that multiplication is left distributive over addition. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : CancelCommMonoidWithZero α] →\n    [inst_1 : NormalizationMonoid α] →\n      [inst_2 : DecidableEq α] →\n        (lcm : α → α → α) →\n          (∀ (a b : α), a ∣ lcm a b) →\n            (∀ (a b : α), b ∣ lcm a b) →\n              (∀ {a b c : α}, c ∣ a → b ∣ a → lcm c b ∣ a) →\n                (∀ (a b : α), ↑normalize (lcm a b) = lcm a b) → NormalizedGCDMonoid α",
  "name": "normalizedGCDMonoidOfLCM",
  "kind": "def",
  "doc_string":
  "Define `NormalizedGCDMonoid` on a structure just from the `lcm` and its properties. ",
  "args": ""},
 {"type": "∀ {a b : ℕ}, a ∣ b → b < a → b = 0",
  "name": "Nat.eq_zero_of_dvd_of_lt",
  "kind": "theorem",
  "doc_string":
  "If a small natural number is divisible by a larger natural number,\nthe small number is zero. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Mul M] {s : Set M} {S : Subsemigroup M}, Subsemigroup.closure s ≤ S ↔ s ⊆ ↑S",
  "name": "Subsemigroup.closure_le",
  "kind": "theorem",
  "doc_string":
  "A subsemigroup `S` includes `closure s` if and only if it includes `s`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {A : Type u_2} →\n    {B : Type u_3} →\n      [inst : Zero A] →\n        [inst_1 : SMulZeroClass M A] →\n          [inst_2 : Zero B] →\n            [inst_3 : SMul M B] → (f : ZeroHom A B) → (∀ (c : M) (x : A), ↑f (c • x) = c • ↑f x) → SMulZeroClass M B",
  "name": "ZeroHom.smulZeroClass",
  "kind": "def",
  "doc_string":
  "Pushforward a zero-preserving scalar multiplication along a zero-preserving map.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {α : ι → Type u_2} → [inst : LT ι] → [inst : (i : ι) → LT (α i)] → LT (Lex ((i : ι) ×' α i))",
  "name": "PSigma.Lex.lt",
  "kind": "def",
  "doc_string": "The lexicographical `<` on a sigma type. ",
  "args": ""},
 {"type": "(α : Type u) → [inst : Random α] → SlimCheck.Gen α",
  "name": "SlimCheck.Gen.chooseAny",
  "kind": "def",
  "doc_string": "Lift `Random.random` to the `Gen` monad. ",
  "args": ""},
 {"type": "(A : Type u_1) → [inst : Add A] → Group (AddAut A)",
  "name": "AddAut.group",
  "kind": "def",
  "doc_string":
  "The group operation on additive automorphisms is defined by `g h => AddEquiv.trans h g`.\nThis means that multiplication agrees with composition, `(g*h)(x) = g (h x)`.\n",
  "args": ""},
 {"type":
  "{I : Type u} → (f : I → Type v) → [inst : (i : I) → Add (f i)] → (i : I) → AddHom ((i : I) → f i) (f i)",
  "name": "Pi.evalAddHom",
  "kind": "def",
  "doc_string":
  "Evaluation of functions into an indexed collection of additive semigroups at a point is an\nadditive semigroup homomorphism. This is `Function.eval i` as an `AddHom`.",
  "args": ""},
 {"type": "{α : Type u} → List α → α → List α",
  "name": "List.concat",
  "kind": "def",
  "doc_string":
  "`l.concat a` appends `a` at the *end* of `l`, that is, `l ++ [a]`. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "SubNegZeroMonoid",
  "kind": "inductive",
  "doc_string": "A `SubNegMonoid` where `-0 = 0`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_→+_»",
  "kind": "def",
  "doc_string":
  "`M →+ N` denotes the type of additive monoid homomorphisms from `M` to `N`. ",
  "args": ""},
 {"type": "{α β σ : Type u} → β → σ → DoResultPR α β σ",
  "name": "DoResultPR.return",
  "kind": "def",
  "doc_string":
  "`return (b : β) s` means that the block exited via a `return b` early-exit command ",
  "args": ""},
 {"type":
  "{P : ℕ → Sort u_1} → P 0 → ((n : ℕ) → P n → P (2 * n)) → ((n : ℕ) → P n → P (2 * n + 1)) → (n : ℕ) → P n",
  "name": "Nat.evenOddRec",
  "kind": "def",
  "doc_string":
  "Recursion principle on even and odd numbers: if we have `P 0`, and for all `i : ℕ` we can\nextend from `P i` to both `P (2 * i)` and `P (2 * i + 1)`, then we have `P n` for all `n : ℕ`.\nThis is nothing more than a wrapper around `Nat.binaryRec`, to avoid having to switch to\ndealing with `bit0` and `bit1`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Abel.abelNF",
  "kind": "def",
  "doc_string":
  "Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n",
  "args": ""},
 {"type": "ℤ → ℤ → ℚ",
  "name": "Rat.divInt",
  "kind": "def",
  "doc_string": "Form the quotient `n / d` where `n d : Int`. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} {inst : Preorder α} {inst_1 : Preorder β} {inst_2 : MulZeroOneClass α}\n  {inst_3 : MulZeroOneClass β} [self : OrderMonoidWithZeroHomClass F α β] (f : F), Monotone ↑f",
  "name": "OrderMonoidWithZeroHomClass.monotone",
  "kind": "def",
  "doc_string": "An `OrderMonoidWithZeroHom` is a monotone function. ",
  "args": ""},
 {"type": "{α : Type} → Lean.MetaM α → IO (Mathlib.Tactic.Cache α)",
  "name": "Mathlib.Tactic.Cache.mk",
  "kind": "def",
  "doc_string": "Creates a cache with an initialization function. ",
  "args": ""},
 {"type": "{α : Sort u} → PLift α ≃ α",
  "name": "Equiv.plift",
  "kind": "def",
  "doc_string": "`PLift α` is equivalent to `α`. ",
  "args": ""},
 {"type":
  "{P : ℤ → Prop} →\n  [inst : DecidablePred P] → (b : ℤ) → (∀ (z : ℤ), P z → z ≤ b) → (∃ z, P z) → { ub // P ub ∧ ∀ (z : ℤ), P z → z ≤ ub }",
  "name": "Int.greatestOfBdd",
  "kind": "def",
  "doc_string":
  "A computable version of `exists_greatest_of_bdd`: given a decidable predicate on the\nintegers, with an explicit upper bound and a proof that it is somewhere true, return\nthe greatest value for which the predicate is true. ",
  "args": ""},
 {"type": "{α : Type u_1} → α → List α → List (List α)",
  "name": "List.permutations'Aux",
  "kind": "def",
  "doc_string":
  "`permutations'Aux t ts` inserts `t` into every position in `ts`, including the last.\nThis function is intended for use in specifications, so it is simpler than `permutationsAux2`,\nwhich plays roughly the same role in `permutations`.\n\nNote that `(permutationsAux2 t [] [] ts id).2` is similar to this function, but skips the last\nposition:\n\n    permutations'Aux 10 [1, 2, 3] =\n      [[10, 1, 2, 3], [1, 10, 2, 3], [1, 2, 10, 3], [1, 2, 3, 10]]\n    (permutationsAux2 10 [] [] [1, 2, 3] id).2 =\n      [[10, 1, 2, 3], [1, 10, 2, 3], [1, 2, 10, 3]] ",
  "args": ""},
 {"type":
  "Option Lean.Syntax.Tactic → Option Lean.Term → optParam Bool false → Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Tactic.LinearCombination.elabLinearCombination",
  "kind": "def",
  "doc_string":
  "Implementation of `linear_combination` and `linear_combination2`. ",
  "args": ""},
 {"type": "∀ (R : Type u) [inst : Semifield R], IsField R",
  "name": "Semifield.toIsField",
  "kind": "theorem",
  "doc_string": "Transferring from `Semifield` to `IsField`. ",
  "args": ""},
 {"type": "Type",
  "name": "ProjectionData",
  "kind": "inductive",
  "doc_string": "Projection data for a single projection of a structure ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b c : α}, a * b ≤ c → b ≤ a⁻¹ * c",
  "name": "le_inv_mul_of_mul_le",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `le_inv_mul_iff_mul_le`.",
  "args": ""},
 {"type": "(p : Prop) → Decidable p",
  "name": "Classical.dec",
  "kind": "def",
  "doc_string":
  "Any prop `p` is decidable classically. A shorthand for `classical.prop_decidable`. ",
  "args": ""},
 {"type": "Linarith.LinarithConfig → Lean.Elab.Tactic.TacticM Unit",
  "name": "Linarith.LinarithConfig.discharger",
  "kind": "def",
  "doc_string":
  "Discharger to prove that a candidate linear combination of hypothesis is zero. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Set.«term_×ˢ_»",
  "kind": "def",
  "doc_string":
  "The cartesian product `s ×ˢ t` is the set of `(a, b)` such that `a ∈ s` and `b ∈ t`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : GeneralizedCoheytingAlgebra α] (a b c : α), a \\ b ≤ c ↔ a ≤ b ⊔ c",
  "name": "GeneralizedCoheytingAlgebra.sdiff_le_iff",
  "kind": "def",
  "doc_string": "`\\ a` is right adjoint to `⊔ a` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  StrictMonoOn f s → StrictAntiOn (↑OrderDual.toDual ∘ f) s",
  "name": "StrictMonoOn.dual_right",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `strictAntiOn_toDual_comp_iff`.",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  {H : Type u_2} → [inst : AddZeroClass G] → [inst_1 : AddZeroClass H] → G ≃+ H ≃ (Multiplicative G ≃* Multiplicative H)",
  "name": "AddEquiv.toMultiplicative",
  "kind": "def",
  "doc_string":
  "Reinterpret `G ≃+ H` as `Multiplicative G ≃* Multiplicative H`. ",
  "args": ""},
 {"type":
  "{σ : Type u} →\n  {F : Type u → Type u} → [inst : Applicative F] → {α : Type u_1} → {β : Type u} → (α → F β) → σ ⊕ α → F (σ ⊕ β)",
  "name": "Sum.traverse",
  "kind": "def",
  "doc_string":
  "Defines a `traverse` function on the second component of a sum type.\nThis is used to give a `traversable` instance for the functor `σ ⊕ -`. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {r : α → α → Prop} {a bot : α},\n  Acc r a → ∀ {C : α → Prop}, (∀ (b : α), b ≠ bot → C b → ∃ c, r c b ∧ C c) → C a → C bot",
  "name": "Acc.induction_bot",
  "kind": "theorem",
  "doc_string":
  "Let `r` be a relation on `α`, let `C : α → Prop` and let `bot : α`.\nThis induction principle shows that `C bot` holds, given that\n* some `a` that is accessible by `r` satisfies `C a`, and\n* for each `b ≠ bot` such that `C b` holds, there is `c` satisfying `r c b` and `C c`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulZeroOneClass M] [inst_1 : MulZeroOneClass N] ⦃f g : M →*₀ N⦄, ↑f = ↑g → f = g",
  "name": "MonoidWithZeroHom.coe_inj",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.coe_injective` instead. ",
  "args": ""},
 {"type": "{α : Type u} → (α → Type v) → Type (max u v)",
  "name": "Sigma",
  "kind": "inductive",
  "doc_string":
  "`Sigma β`, also denoted `Σ a : α, β a` or `(a : α) × β a`, is the type of dependent pairs\nwhose first component is `a : α` and whose second component is `b : β a`\n(so the type of the second component can depend on the value of the first component).\nIt is sometimes known as the dependent sum type, since it is the type level version\nof an indexed summation.\n",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type u_1} →\n    [inst : OrderedCommSemiring α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Pow β ℕ] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : NatCast β] →\n                    (f : β → α) →\n                      Function.Injective f →\n                        f 0 = 0 →\n                          f 1 = 1 →\n                            (∀ (x y : β), f (x + y) = f x + f y) →\n                              (∀ (x y : β), f (x * y) = f x * f y) →\n                                (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                  (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                    (∀ (n : ℕ), f ↑n = ↑n) → OrderedCommSemiring β",
  "name": "Function.Injective.orderedCommSemiring",
  "kind": "def",
  "doc_string": "Pullback an `OrderedCommSemiring` under an injective map. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : NonUnitalRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : Add β] →\n          [inst_3 : Mul β] →\n            [inst_4 : Neg β] →\n              [inst_5 : Sub β] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : SMul ℤ β] →\n                    (f : β → α) →\n                      Function.Injective f →\n                        f 0 = 0 →\n                          (∀ (x y : β), f (x + y) = f x + f y) →\n                            (∀ (x y : β), f (x * y) = f x * f y) →\n                              (∀ (x : β), f (-x) = -f x) →\n                                (∀ (x y : β), f (x - y) = f x - f y) →\n                                  (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                    (∀ (x : β) (n : ℤ), f (n • x) = n • f x) → NonUnitalRing β",
  "name": "Function.Injective.nonUnitalRing",
  "kind": "def",
  "doc_string":
  "Pullback a `NonUnitalRing` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Option α → Type u_2} → ((a : Option α) → β a) ≃ β none × ((a : α) → β (some a))",
  "name": "Equiv.piOptionEquivProd",
  "kind": "def",
  "doc_string":
  "The product over `Option α` of `β a` is the binary product of the\nproduct over `α` of `β (some α)` and `β none` ",
  "args": ""},
 {"type": "∀ {α : Sort u_1} (x : α), (∀ (y : α), y = x) → Subsingleton α",
  "name": "subsingleton_of_forall_eq",
  "kind": "theorem",
  "doc_string":
  "If all points are equal to a given point `x`, then `α` is a subsingleton. ",
  "args": ""},
 {"type": "String → String",
  "name": "ToAdditive.guessName",
  "kind": "def",
  "doc_string":
  "Autogenerate additive name.\nThis runs in several steps:\n1) Split according to capitalisation rule and at `_`.\n2) Apply word-by-word translation rules.\n3) Fix up abbreviations that are not word-by-word translations, like \"addComm\" or \"Nonneg\".\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteLinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "name": "CompleteLinearOrder.le_total",
  "kind": "def",
  "doc_string": "A linear order is total. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⁺»",
  "kind": "def",
  "doc_string": "The positive part function. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → (A : Type u_3) → [inst : AddZeroClass A] → [inst_1 : DistribSMul M A] → (N → M) → DistribSMul N A",
  "name": "DistribSMul.compFun",
  "kind": "def",
  "doc_string":
  "Compose a `DistribSMul` with a function, with scalar multiplication `f r' • m`.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "CategoryTheory.NatTrans.«term_◫_»",
  "kind": "def",
  "doc_string":
  "Notation for horizontal composition of natural transformations. ",
  "args": ""},
 {"type":
  "∀ {M : Type uM} [inst : AddCommGroup M] (z : ℤ) (m : M), ↑↑z m = z • m",
  "name": "AddMonoid.End.int_cast_apply",
  "kind": "theorem",
  "doc_string": "See also `AddMonoid.End.intCast_def`. ",
  "args": ""},
 {"type": "{p : Prop} → [dp : Decidable p] → Decidable ¬p",
  "name": "Not.decidable",
  "kind": "def",
  "doc_string": "**Alias** of `instDecidableNot`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : OrderedCommMonoid α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b",
  "name": "OrderedCommMonoid.mul_le_mul_left",
  "kind": "def",
  "doc_string": "Multiplication is monotone in an `OrderedCommMonoid`. ",
  "args": ""},
 {"type": "∀ (m n : ℕ), m - Nat.succ n = m - n - 1",
  "name": "Nat.sub_succ'",
  "kind": "theorem",
  "doc_string":
  "A version of `Nat.sub_succ` in the form `_ - 1` instead of `Nat.pred _`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → {f : α → β} → [inst : DecidableEq β] → Function.Injective f → DecidableEq α",
  "name": "Function.Injective.decidableEq",
  "kind": "def",
  "doc_string":
  "If the co-domain `β` of an injective function `f : α → β` has decidable equality, then\nthe domain `α` also has decidable equality. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Sat.LClause → Array ℤ",
  "name": "Mathlib.Tactic.Sat.LClause.lits",
  "kind": "def",
  "doc_string": "The list of literals as read from the input file ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Monoid M] → [inst_1 : Subsingleton M] → Unique Mˣ",
  "name": "instUniqueUnits",
  "kind": "def",
  "doc_string": "A subsingleton `Monoid` has a unique unit. ",
  "args": ""},
 {"type":
  "{a : Prop} → (b : Prop) → (a ↔ b) → [inst : Decidable b] → Decidable a",
  "name": "decidable_of_iff'",
  "kind": "def",
  "doc_string":
  "Transfer decidability of `b` to decidability of `a`, if the propositions are equivalent.\nThis is the same as `decidable_of_iff` but the iff is flipped. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 ↔ b * a = 0",
  "name": "mul_eq_zero_comm",
  "kind": "theorem",
  "doc_string":
  "If `α` has no zero divisors, then for elements `a, b : α`, `a * b` equals zero iff so is\n`b * a`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Mul α] → [inst : LE α] → α → Prop",
  "name": "MulLECancellable",
  "kind": "def",
  "doc_string":
  "An element `a : α` is `MulLECancellable` if `x ↦ a * x` is order-reflecting.\nWe will make a separate version of many lemmas that require `[ContravariantClass α α (*) (≤)]` with\n`MulLECancellable` assumptions instead. These lemmas can then be instantiated to specific types,\nlike `ENNReal`, where we can replace the assumption `AddLECancellable x` by `x ≠ ∞`.\n",
  "args": ""},
 {"type":
  "∀ {I : Type u} {β : Type u_1} [inst : DecidableEq I] [inst_1 : Zero β] (i : I) (x : β) (i' : I),\n  Pi.single i x i' = Pi.single i' x i",
  "name": "Pi.single_comm",
  "kind": "theorem",
  "doc_string":
  "On non-dependent functions, `Pi.single` is symmetric in the two indices.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → Monotone (WithTop.map f)",
  "name": "Monotone.withTop_map",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `WithTop.monotone_map_iff`.",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {π : ι → Type u_2} → [inst : (i : ι) → Preorder (π i)] → (i : ι) → ((j : ι) → π j) →o π i",
  "name": "Pi.evalOrderHom",
  "kind": "def",
  "doc_string":
  "Evaluation of an unbundled function at a point (`Function.eval`) as a `OrderHom`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : LE α] → Prop",
  "name": "NoTopOrder",
  "kind": "inductive",
  "doc_string": "Order without top elements. ",
  "args": ""},
 {"type":
  "{v : Type} → Lean.Meta.TransparencyMode → List (Lean.Expr × v) → Lean.Expr → Lean.MetaM v",
  "name": "List.findDefeq",
  "kind": "def",
  "doc_string":
  "`findDefeq red m e` looks for a key in `m` that is defeq to `e` (up to transparency `red`),\nand returns the value associated with this key if it exists.\nOtherwise, it fails.\n",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : LE α] → α ≃o α",
  "name": "OrderIso.refl",
  "kind": "def",
  "doc_string": "Identity order isomorphism. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s t : Set α},\n  AntitoneOn f t → s ⊆ t → Set.Nonempty (lowerBounds s ∩ t) → BddAbove (f '' s)",
  "name": "AntitoneOn.map_bddBelow",
  "kind": "theorem",
  "doc_string":
  "The image under an antitone function of a set which is bounded below is bounded above. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    [inst : NonUnitalNonAssocSemiring R] →\n      [inst_1 : NonUnitalNonAssocSemiring S] → (f : R →ₙ+* S) → (∀ (x y : R), Commute (↑f x) (↑f y)) → Rᵐᵒᵖ →ₙ+* S",
  "name": "NonUnitalRingHom.fromOpposite",
  "kind": "def",
  "doc_string":
  "A non-unital ring homomorphism `f : R →ₙ* S` such that `f x` commutes with `f y` for all `x, y`\ndefines a non-unital ring homomorphism from `Rᵐᵒᵖ`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : HasSSubset α]\n  [inst_2 : IsNonstrictStrictOrder α (fun x x_1 => x ⊆ x_1) fun x x_1 => x ⊂ x_1] {a b c : α}\n  [inst_3 : IsTrans α fun x x_1 => x ⊆ x_1], a ⊆ b → b ⊂ c → a ⊂ c",
  "name": "HasSubset.Subset.trans_ssubset",
  "kind": "theorem",
  "doc_string": "**Alias** of `ssubset_of_subset_of_ssubset`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → {r : α → α → Prop} → {s : β → β → Prop} → {t : γ → γ → Prop} → r ≃r s → s ≺i t → r ≺i t",
  "name": "PrincipalSeg.equivLT",
  "kind": "def",
  "doc_string":
  "Composition of an order isomorphism with a principal segment, as a principal segment ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : BooleanAlgebra α] (x y : α), x \\ y = x ⊓ yᶜ",
  "name": "BooleanAlgebra.sdiff_eq",
  "kind": "def",
  "doc_string": "`x \\ y` is equal to `x ⊓ yᶜ` ",
  "args": ""},
 {"type":
  "∀ (α : Type u) (r : α → α → Prop) [inst : IsSymm α r], IsSymmOp α Prop r",
  "name": "isSymmOp_of_isSymm",
  "kind": "def",
  "doc_string": "The opposite of a symmetric relation is symmetric. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → {x : AddZeroClass M} → [inst : AddCommMonoid N] → Add (M →+ N)",
  "name": "AddMonoidHom.add",
  "kind": "def",
  "doc_string":
  "Given two additive monoid morphisms `f`, `g` to an additive commutative monoid,\n`f + g` is the additive monoid morphism sending `x` to `f x + g x`. ",
  "args": ""},
 {"type": "(α : Type u_1) → PEmpty × α ≃ PEmpty",
  "name": "Equiv.pemptyProd",
  "kind": "def",
  "doc_string":
  "`PEmpty` type is a left absorbing element for type product up to an equivalence. ",
  "args": ""},
 {"type": "ℕ+ ≃o ℕ",
  "name": "OrderIso.pnatIsoNat",
  "kind": "def",
  "doc_string": "The order isomorphism between ℕ and ℕ+ given by `succ`. ",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.minFacAux",
  "kind": "def",
  "doc_string":
  "If `n < k * k`, then `minFacAux n k = n`, if `k | n`, then `minFacAux n k = k`.\nOtherwise, `minFacAux n k = minFacAux n (k+2)` using well-founded recursion.\nIf `n` is odd and `1 < n`, then then `minFacAux n 3` is the smallest prime factor of `n`. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CommGroupWithZero",
  "kind": "inductive",
  "doc_string":
  "A type `G₀` is a commutative “group with zero”\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`. ",
  "args": ""},
 {"type": "∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y",
  "name": "IsField.exists_pair_ne",
  "kind": "def",
  "doc_string":
  "For a semiring to be a field, it must have two distinct elements. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {x y : α}, x < y ∨ y < x ↔ x ≠ y",
  "name": "lt_or_lt_iff_ne",
  "kind": "theorem",
  "doc_string": "A version of `ne_iff_lt_or_gt` with LHS and RHS reversed. ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {F G : C ⥤ D}\n  (self : CategoryTheory.NatTrans F G) ⦃X Y : C⦄ (f : X ⟶ Y),\n  Prefunctor.map F.toPrefunctor f ≫ CategoryTheory.NatTrans.app self Y =\n    CategoryTheory.NatTrans.app self X ≫ Prefunctor.map G.toPrefunctor f",
  "name": "CategoryTheory.NatTrans.naturality",
  "kind": "def",
  "doc_string": "The naturality square for a given morphism. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] [inst_1 : OrderTop α] {a b : α}, a < b → a ≠ ⊤",
  "name": "LT.lt.ne_top",
  "kind": "theorem",
  "doc_string": "**Alias** of `ne_top_of_lt`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    (r : α → α → Prop) →\n      (s : β → β → Prop) → [inst : IsRefl α r] → [inst : IsRefl β s] → [inst : Unique α] → [inst : Unique β] → r ≃r s",
  "name": "RelIso.relIsoOfUniqueOfRefl",
  "kind": "def",
  "doc_string": "Two reflexive relations on a unique type are isomorphic. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [inst_3 : OrderedSub α] {a b c : α}\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], a + b - c ≤ a - c + b",
  "name": "add_tsub_le_tsub_add",
  "kind": "theorem",
  "doc_string": "See `tsub_add_eq_add_tsub` for the equality. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tactic__",
  "kind": "def",
  "doc_string":
  "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → {r : α → α → Prop} → {s : β → β → Prop} → {t : γ → γ → Prop} → r ≺i s → s ≼i t → r ≺i t",
  "name": "PrincipalSeg.ltLe",
  "kind": "def",
  "doc_string":
  "Composition of a principal segment with an initial segment, as a principal segment ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] {f g : M ≃+ N}, (∀ (x : M), ↑f x = ↑g x) → f = g",
  "name": "AddEquiv.ext",
  "kind": "theorem",
  "doc_string":
  "Two additive isomorphisms agree if they are defined by the same underlying function.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Lattice α] [self : IsModularLattice α] {x : α} (y : α) {z : α}, x ≤ z → (x ⊔ y) ⊓ z ≤ x ⊔ y ⊓ z",
  "name": "IsModularLattice.sup_inf_le_assoc_of_le",
  "kind": "def",
  "doc_string":
  "Whenever `x ≤ z`, then for any `y`, `(x ⊔ y) ⊓ z ≤ x ⊔ (y ⊓ z)`  ",
  "args": ""},
 {"type":
  "Type u_1 →\n  (α : outParam (Type u_2)) →\n    (β : outParam (Type u_3)) → [inst : Add α] → [inst : Add β] → [inst : LE β] → Type (max (max u_1 u_2) u_3)",
  "name": "SubadditiveHomClass",
  "kind": "inductive",
  "doc_string":
  "`SubadditiveHomClass F α β` states that `F` is a type of subadditive morphisms. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M), S = ⊥ ∨ Nontrivial { x // x ∈ S }",
  "name": "Submonoid.bot_or_nontrivial",
  "kind": "theorem",
  "doc_string": "A submonoid is either the trivial submonoid or nontrivial. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Sat.LClause",
  "kind": "inductive",
  "doc_string":
  "A localized clause reference.\nIt is the same as `Clause` except that the proof is now a local variable. ",
  "args": ""},
 {"type":
  "Type u_1 →\n  (α : outParam (Type u_2)) →\n    (β : outParam (Type u_3)) → [inst : Mul α] → [inst : Add β] → [inst : LE β] → Type (max (max u_1 u_2) u_3)",
  "name": "MulLEAddHomClass",
  "kind": "inductive",
  "doc_string":
  "`MulLEAddHomClass F α β` states that `F` is a type of subadditive morphisms. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → Option β → γ) → List α → List β → List γ",
  "name": "List.zipWithLeftTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `zipWithLeft`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u} {R : Type v} [inst : Monoid M] [inst_1 : Semiring R] [self : MulSemiringAction M R] (g : M) (x y : R),\n  g • (x * y) = g • x * g • y",
  "name": "MulSemiringAction.smul_mul",
  "kind": "def",
  "doc_string": "Scalara multiplication distributes across multiplication ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {f : α → α} {x : α}, StrictMono f → f x < x → StrictAnti fun n => Nat.iterate f n x",
  "name": "StrictMono.strictAnti_iterate_of_map_lt",
  "kind": "theorem",
  "doc_string":
  "If `f` is a strictly antitone map and `f x < x` at some point `x`, then the iterates `f^[n] x`\nform a strictly antitone sequence. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "SubtractionMonoid",
  "kind": "inductive",
  "doc_string":
  "A `SubtractionMonoid` is a `SubNegMonoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 → -a = b`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Monoid α] → Invertible 1",
  "name": "invertibleOne",
  "kind": "def",
  "doc_string": "`1` is the inverse of itself ",
  "args": ""},
 {"type":
  "∀ {α : Type u} (r : α → α → Prop) [inst : IsSymm α r] {a b : α}, r a b ↔ r b a",
  "name": "comm_of",
  "kind": "theorem",
  "doc_string":
  "A version of `comm` with `r` explicit.\n\nThis lemma matches the lemmas from lean core in `Init.Algebra.Classes`, but is missing there.  ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} →\n        {φ : Quot r → Quot s → Sort u_3} →\n          [h : ∀ (a : α) (b : β), Subsingleton (φ (Quot.mk r a) (Quot.mk s b))] →\n            (q₁ : Quot r) → (q₂ : Quot s) → ((a : α) → (b : β) → φ (Quot.mk r a) (Quot.mk s b)) → φ q₁ q₂",
  "name": "Quot.recOnSubsingleton₂",
  "kind": "def",
  "doc_string": "A binary version of `Quot.recOnSubsingleton`. ",
  "args": ""},
 {"type": "Lean.Expr → Option (Lean.Name × Lean.Expr)",
  "name": "Linarith.getContrLemma",
  "kind": "def",
  "doc_string":
  "If `e` is a comparison `a R b` or the negation of a comparison `¬ a R b`, found in the target,\n`getContrLemma e` returns the name of a lemma that will change the goal to an\nimplication, along with the type of `a` and `b`.\n\nFor example, if `e` is `(a : ℕ) < b`, returns ``(`lt_of_not_ge, ℕ)``.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : OrderedSemiring α] → [inst_1 : CharZero α] → ℕ ↪o α",
  "name": "Nat.castOrderEmbedding",
  "kind": "def",
  "doc_string": "`Nat.cast : ℕ → α` as an `OrderEmbedding` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} {a : α} {b : β},\n  Acc rα a → Acc rβ b → Acc (Prod.GameAdd rα rβ) (a, b)",
  "name": "Acc.prod_gameAdd",
  "kind": "theorem",
  "doc_string":
  "If `a` is accessible under `rα` and `b` is accessible under `rβ`, then `(a, b)` is\naccessible under `Prod.GameAdd rα rβ`. Notice that `Prod.lexAccessible` requires the\nstronger condition `∀ b, Acc rβ b`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → α ≃ β → α ≃. β",
  "name": "Equiv.toPEquiv",
  "kind": "def",
  "doc_string": "Turns an `Equiv` into a `PEquiv` of the whole type. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → AddHomClass (AddHom M N) M N",
  "name": "AddHom.addHomClass",
  "kind": "def",
  "doc_string": "`AddHom` is a type of addition-preserving homomorphisms",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  (n : Q(ℕ)) →\n    (a : Q(ℤ)) →\n      (b : Q(ℕ)) →\n        (p : Q(Sort u)) → Lean.MetaM (Q(Mathlib.Tactic.ModCases.OnModCases «$n» «$a» «$b» «$p») × List Lean.MVarId)",
  "name": "Mathlib.Tactic.ModCases.proveOnModCases",
  "kind": "opaque",
  "doc_string":
  "Proves an expression of the form `OnModCases n a b p` where `n` and `b` are raw nat literals\nand `b ≤ n`. Returns the list of subgoals `?gi : a ≡ i [ZMOD n] → p`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β]\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {f g : β → α},\n  Antitone f → StrictAnti g → StrictAnti fun x => f x * g x",
  "name": "Antitone.mul_strict_anti'",
  "kind": "theorem",
  "doc_string":
  "The product of a antitone function and a strictly antitone function is strictly antitone. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {α : Type u_2} [inst : VAdd M α] [inst_1 : VAdd Mᵃᵒᵖ α] [self : IsCentralVAdd M α] (m : M) (a : α),\n  { unop := m } +ᵥ a = m +ᵥ a",
  "name": "IsCentralVAdd.op_vadd_eq_vadd",
  "kind": "def",
  "doc_string": "The right and left actions of `M` on `α` are equal. ",
  "args": ""},
 {"type": "Lean.Macro",
  "name": "Mathlib.Tactic.expandLemma",
  "kind": "def",
  "doc_string":
  "Implementation of the `lemma` command, by macro expansion to `theorem`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : Preorder γ] {f : α → β → γ}\n  {s : Set α} {t : Set β},\n  (∀ (b : β), Monotone (Function.swap f b)) →\n    (∀ (a : α), Monotone (f a)) → BddBelow s → BddBelow t → BddBelow (Set.image2 f s t)",
  "name": "BddBelow.image2",
  "kind": "theorem",
  "doc_string": "See also `Monotone.map_bddBelow`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  0 < a → 0 < b → 0 < a + b",
  "name": "Right.add_pos'",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos'`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosMono α],\n  1 ≤ a → 1 < b → 0 ≤ b → 1 < a * b",
  "name": "Right.one_lt_mul_of_le_of_lt_of_nonneg",
  "kind": "theorem",
  "doc_string": "Assumes right covariance. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → ℕ → List α → ℕ → Array α → List α",
  "name": "List.dropSliceTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `dropSliceTR`: `dropSliceTR.go l m xs n acc = acc.toList ++ dropSlice n m xs`\nunless `n ≥ length xs`, in which case it is `l`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : EmptyCollection β] [inst_1 : Insert α β] [inst_2 : Singleton α β]\n  [self : IsLawfulSingleton α β] (x : α), insert x ∅ = {x}",
  "name": "IsLawfulSingleton.insert_emptyc_eq",
  "kind": "def",
  "doc_string": "`insert x ∅ = {x}` ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (self : M →ₙ* N) (x y : M),\n  ↑self (x * y) = ↑self x * ↑self y",
  "name": "MulHom.map_mul'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves multiplication ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} [inst : IsWellOrder β s], Subsingleton (r ≺i s)",
  "name": "PrincipalSeg.instSubsingletonPrincipalSeg",
  "kind": "def",
  "doc_string":
  "Given a well order `s`, there is a most one principal segment embedding of `r` into `s`. ",
  "args": ""},
 {"type":
  "{S : Type u_1} →\n  [inst : OrderedSemiring S] →\n    {R : Type u_2} → [inst_1 : Semiring R] → (abv : R → S) → [inst_2 : IsAbsoluteValue abv] → AbsoluteValue R S",
  "name": "IsAbsoluteValue.toAbsoluteValue",
  "kind": "def",
  "doc_string":
  "Convert an unbundled `IsAbsoluteValue` to a bundled `AbsoluteValue`. ",
  "args": ""},
 {"type": "∀ {G : Type u_1} [inst : AddGroup G] {a b : G}, a = b → a - b = 0",
  "name": "sub_eq_zero_of_eq",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `sub_eq_zero`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : HasSup α] →\n      [inst_1 : HasInf α] →\n        [inst_2 : Top α] →\n          [inst_3 : HImp α] →\n            [inst_4 : GeneralizedHeytingAlgebra β] →\n              (f : α → β) →\n                Function.Injective f →\n                  (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) →\n                    (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) →\n                      f ⊤ = ⊤ → (∀ (a b : α), f (a ⇨ b) = f a ⇨ f b) → GeneralizedHeytingAlgebra α",
  "name": "Function.Injective.generalizedHeytingAlgebra",
  "kind": "def",
  "doc_string": "Pullback a `GeneralizedHeytingAlgebra` along an injection. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  a ≤ 1 → b < 1 → a * b < 1",
  "name": "Right.mul_lt_one_of_le_of_lt",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one_of_le_of_lt`. ",
  "args": ""},
 {"type": "{M : Type u_1} → Set M → [inst : Add M] → Set M",
  "name": "Set.addCentralizer",
  "kind": "def",
  "doc_string": "The centralizer of a subset of an additive magma. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Field",
  "kind": "inductive",
  "doc_string":
  "A `Field` is a `CommRing` with multiplicative inverses for nonzero elements.\n\nAn instance of `Field K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nIf the field has positive characteristic p, we define `ratCast (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `ratCast` and `qsmul` are needed to implement the\n`algebraRat [DivisionRing K] : Algebra ℚ K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also Note [forgetful inheritance].\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : LinearOrderedCommGroupWithZero α], 1 ≤ a → 1 ≤ b → 1 ≤ a * b",
  "name": "one_le_mul₀",
  "kind": "theorem",
  "doc_string": "Alias of `one_le_mul'` for unification. ",
  "args": ""},
 {"type":
  "∀ (α : Type u_1) [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], 0 < 1",
  "name": "zero_lt_one'",
  "kind": "theorem",
  "doc_string": "See `zero_lt_one` for a version with the type implicit. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : Setoid α} {f : α → β} (h : Setoid.ker f ≤ r) (hf : Function.Surjective f),\n  Setoid.map r f = Setoid.mapOfSurjective r f h hf",
  "name": "Setoid.mapOfSurjective_eq_map",
  "kind": "theorem",
  "doc_string":
  "A special case of the equivalence closure of an equivalence relation r equalling r. ",
  "args": ""},
 {"type": "Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Tactic.Tauto.tautology",
  "kind": "def",
  "doc_string": "Implementation of the `tauto` tactic. ",
  "args": ""},
 {"type": "{α : Type u} → (α → Bool) → List α → List α",
  "name": "List.filterTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `List.filter`. ",
  "args": ""},
 {"type": "Lean.Elab.Command.CommandElab",
  "name": "Mathlib.Prelude.Rename.elabAlign",
  "kind": "def",
  "doc_string": "Elaborate an `#align` command. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.Expr → Lean.Expr → ℕ → Lean.Expr × Lean.Expr",
  "name": "Mathlib.Tactic.Sat.buildReify",
  "kind": "def",
  "doc_string":
  "Build the type and value of the reified theorem. This rewrites all the SAT definitions\ninto standard operators on `Prop`, for example if the formula is `[[1, 2], [-1, 2], [-2]]` then\nthis produces a proof of `⊢ ∀ a b : Prop, (a ∧ b) ∨ (¬a ∧ b) ∨ ¬b`. We use the input `nvars` to\ndecide how many quantifiers to use.\n\nMost of the proof is under `2 * nvars + 1` quantifiers\n`a1 .. an : Prop, v : Valuation, h1 : v 0 ↔ a1, ... hn : v (n-1) ↔ an ⊢ ...`, and we do the index\narithmetic by hand.\n\n  1. First, we call `reifyFormula ctx'` which returns `a` and `pr : reify v ctx' a`\n  2. Then we build `fun (v : Valuation) (h1 : v 0 ↔ a1) ... (hn : v (n-1) ↔ an) ↦ pr`\n  3. We have to lower expression `a` from step 1 out of the quantifiers by lowering all variable\n     indices by `nvars+1`. This is okay because `v` and `h1..hn` do not appear in `a`.\n  4. We construct the expression `ps`, which is `a1 .. an : Prop ⊢ [a1, ..., an] : List Prop`\n  5. `refute ctx (hf : ctx.proof []) (fun v h1 .. hn ↦ pr) : a` forces some definitional unfolding\n     since `fun h1 .. hn ↦ pr` should have type `implies v (reify v ctx a) [a1, ..., an] a`,\n     which involves unfolding `implies` n times as well as `ctx ↦ ctx'`.\n  6. Finally, we `intro a1 ... an` so that we have a proof of `∀ a1 ... an, a`.\n",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : MulOneClass β] → β →* α → β",
  "name": "Pi.constMonoidHom",
  "kind": "def",
  "doc_string": "`Function.const` as a `MonoidHom`. ",
  "args": ""},
 {"type": "(R : Type u_1) → [inst : NonUnitalCommSemiring R] → R ≃+* Rᵐᵒᵖ",
  "name": "RingEquiv.toOpposite",
  "kind": "def",
  "doc_string": "A non-unital commutative ring is isomorphic to its opposite. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {A : Type u_2} →\n    {B : Type u_3} →\n      [inst : Zero A] →\n        [inst_1 : SMulZeroClass M A] →\n          [inst_2 : Zero B] →\n            [inst_3 : SMul M B] →\n              (f : ZeroHom B A) → Function.Injective ↑f → (∀ (c : M) (x : B), ↑f (c • x) = c • ↑f x) → SMulZeroClass M B",
  "name": "Function.Injective.smulZeroClass",
  "kind": "def",
  "doc_string":
  "Pullback a zero-preserving scalar multiplication along an injective zero-preserving map.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : OrderedCancelAddCommMonoid α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "name": "OrderedCancelAddCommMonoid.add_le_add_left",
  "kind": "def",
  "doc_string":
  "Addition is monotone in an ordered cancellative additive commutative monoid. ",
  "args": ""},
 {"type": "Prop → Type",
  "name": "SlimCheck.TestResult",
  "kind": "inductive",
  "doc_string":
  "Result of trying to disprove `p`\nThe constructors are:\n  *  `success : (PSum Unit p) → TestResult p`\n     succeed when we find another example satisfying `p`\n     In `success h`, `h` is an optional proof of the proposition.\n     Without the proof, all we know is that we found one example\n     where `p` holds. With a proof, the one test was sufficient to\n     prove that `p` holds and we do not need to keep finding examples.\n   * `gaveUp : ℕ → TestResult p`\n     give up when a well-formed example cannot be generated.\n     `gaveUp n` tells us that `n` invalid examples were tried.\n     Above 100, we give up on the proposition and report that we\n     did not find a way to properly test it.\n   * `failure : ¬ p → (List String) → ℕ → TestResult p`\n     a counter-example to `p`; the strings specify values for the relevant variables.\n     `failure h vs n` also carries a proof that `p` does not hold. This way, we can\n     guarantee that there will be no false positive. The last component, `n`,\n     is the number of times that the counter-example was shrunk.\n",
  "args": ""},
 {"type": "{α : Type u_1} → ℕ → List α → List α",
  "name": "List.takeTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `take`. ",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  {M : Type u_2} →\n    [inst : Group G] →\n      [inst_1 : Monoid M] →\n        [inst_2 : MulDistribMulAction G M] →\n          [inst_3 : SMulCommClass G M M] → [inst_4 : IsScalarTower G M M] → MulDistribMulAction G Mˣ",
  "name": "Units.mulDistribMulAction'",
  "kind": "def",
  "doc_string": "A stronger form of `Units.mul_action'`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (as : Array α) → Fin (Array.size as + 1) → α → Array α",
  "name": "Array.insertAt",
  "kind": "def",
  "doc_string": "Insert element `a` at position `i`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Array",
  "kind": "inductive",
  "doc_string":
  "`Array α` is the type of [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array)\nwith elements from `α`. This type has special support in the runtime.\n\nAn array has a size and a capacity; the size is `Array.size` but the capacity\nis not observable from lean code. Arrays perform best when unshared; as long\nas they are used \"linearly\" all updates will be performed destructively on the\narray, so it has comparable performance to mutable arrays in imperative\nprogramming languages.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : PredOrder α] {a b : α} [inst_2 : NoMinOrder α],\n  Order.pred a ≤ Order.pred b → a ≤ b",
  "name": "Order.le_of_pred_le_pred",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `Order.pred_le_pred_iff`.",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → (Q(«$α») → Type) → Q(«$α») → Type",
  "name": "Mathlib.Tactic.Ring.Result",
  "kind": "inductive",
  "doc_string":
  "The result of evaluating an (unnormalized) expression `e` into the type family `E`\n(one of `ExSum`, `ExProd`, `ExBase`) is a (normalized) element `e'`\nand a representation `E e'` for it, and a proof of `e = e'`.\n",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → (α → β) → List α → List β",
  "name": "List.mapTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `List.map`. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : AddZeroClass M] → [inst : AddZeroClass N] → Type (max u_1 u_2)",
  "name": "AddMonoidHom",
  "kind": "inductive",
  "doc_string":
  "`M →+ N` is the type of functions `M → N` that preserve the `AddZeroClass` structure.\n\n`AddMonoidHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M →+ N)`,\nyou should parametrize over `(F : Type*) [AddMonoidHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `AddMonoidHomClass`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → (f : α →o β) → (f' : α → β) → f' = ↑f → α →o β",
  "name": "OrderHom.copy",
  "kind": "def",
  "doc_string":
  "Copy of an `OrderHom` with a new `toFun` equal to the old one. Useful to fix definitional\nequalities. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.RingNF.Config",
  "kind": "inductive",
  "doc_string": "Configuration for `ring_nf`. ",
  "args": ""},
 {"type": "{α : Sort u_1} → (p : α → Prop) → Subtype p ↪ α",
  "name": "Function.Embedding.subtype",
  "kind": "def",
  "doc_string": "Embedding of a `Subtype`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] {a : α}, IsMin a → IsMax (↑OrderDual.toDual a)",
  "name": "IsMin.toDual",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `isMax_toDual_iff`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : NonAssocRing α] [inst_1 : NonAssocRing β] (f : α →+* β) (x y : α),\n  ↑f (x - y) = ↑f x - ↑f y",
  "name": "RingHom.map_sub",
  "kind": "theorem",
  "doc_string": "Ring homomorphisms preserve subtraction. ",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α α_1 : Type u_1} {p₁ : (α → α_1) → Prop} {f : m (α → α_1)} {p₂ : α → Prop}\n  {q : α_1 → Prop} [inst : Applicative m] [inst_1 : LawfulApplicative m] {x : m α},\n  SatisfiesM p₁ f →\n    SatisfiesM p₂ x → (∀ {f : α → α_1} {a : α}, p₁ f → p₂ a → q (f a)) → SatisfiesM q (Seq.seq f fun x_1 => x)",
  "name": "SatisfiesM.seq",
  "kind": "theorem",
  "doc_string": "`SatisfiesM` distributes over `<*>`, general version. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddMonoid R] (a : AddUnits R), IsAddRegular ↑a",
  "name": "AddUnits.isAddRegular",
  "kind": "theorem",
  "doc_string":
  "If `R` is an additive monoid, an element in `add_units R` is add-regular.",
  "args": ""},
 {"type": "{α : Type u_1} → α → ℕ → List α",
  "name": "List.repeat",
  "kind": "def",
  "doc_string":
  "List consisting of an element `a` repeated a specified number of times. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α :\n      let u := u;\n      Q(Type u)} →\n    Q(AddMonoid «$α») → Q(«$α») → List Q(«$α») → Q(«$α»)",
  "name": "Linarith.addExprs'.go",
  "kind": "def",
  "doc_string": "Inner loop for `addExprs'`. ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} {D : Type u₂} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] (F : C ⥤ D)\n  [inst_2 : CategoryTheory.Faithful F], CategoryTheory.Faithful (CategoryTheory.Functor.toEssImage F)",
  "name": "CategoryTheory.Faithful.toEssImage",
  "kind": "def",
  "doc_string": "The induced functor of a faithful functor is faithful ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddCommSemigroup α] [inst_1 : PartialOrder α] [inst_2 : ExistsAddOfLE α]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_4 : Sub α] [inst_5 : OrderedSub α]\n  {a b : α} [inst : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], a ≤ b → b - (b - a) = a",
  "name": "tsub_tsub_cancel_of_le",
  "kind": "theorem",
  "doc_string": "See `tsub_tsub_le` for an inequality. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → {δ : Type u_4} → (α ↪ β) → (γ ↪ δ) → α ⊕ γ ↪ β ⊕ δ",
  "name": "Function.Embedding.sumMap",
  "kind": "def",
  "doc_string": "If `e₁` and `e₂` are embeddings, then so is `sum.map e₁ e₂`. ",
  "args": ""},
 {"type":
  "{C : ℤ → Sort u_1} → (b : ℤ) → C b → ((k : ℤ) → k ≤ b → C k → C (k - 1)) → (n : ℕ) → C (b + Int.negSucc n)",
  "name": "Int.inductionOn'.neg",
  "kind": "def",
  "doc_string": "The negative case of `Int.inductionOn'`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tacticDecreasing_with_",
  "kind": "def",
  "doc_string":
  "Constructs a proof of decreasing along a well founded relation, by applying\nlexicographic order lemmas and using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} {s t : Set α}, s = t → s ⊆ t",
  "name": "Eq.subset",
  "kind": "theorem",
  "doc_string":
  "Duplicate of `eq.subset'`, which currently has elaboration problems. ",
  "args": ""},
 {"type":
  "{α : Sort u} →\n  {s : Setoid α} →\n    {motive : Quotient s → Sort v} →\n      [h : ∀ (a : α), Subsingleton (motive (Quotient.mk s a))] →\n        (q : Quotient s) → ((a : α) → motive (Quotient.mk s a)) → motive q",
  "name": "Quotient.recOnSubsingleton",
  "kind": "def",
  "doc_string":
  "The analogue of `Quot.recOnSubsingleton` for `Quotient`. See `Quot.recOnSubsingleton`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : HasSSubset α]\n  [inst_2 : IsNonstrictStrictOrder α (fun x x_1 => x ⊆ x_1) fun x x_1 => x ⊂ x_1] {a b : α}, a ⊆ b → ¬b ⊆ a → a ⊂ b",
  "name": "HasSubset.Subset.ssubset_of_not_subset",
  "kind": "theorem",
  "doc_string": "**Alias** of `ssubset_of_subset_not_subset`.",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : Zero α] → [inst : Sub α] → List α → List α → List α",
  "name": "List.Func.sub",
  "kind": "def",
  "doc_string":
  "Pointwise subtraction on lists. If lists are different lengths, use zero. ",
  "args": ""},
 {"type": "ℤ → ℤ → ℤ",
  "name": "Int.gcdA",
  "kind": "def",
  "doc_string":
  "The extended GCD `a` value in the equation `gcd x y = x * a + y * b`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β},\n  Function.Surjective f → ∀ (s : Set β), Set.Subsingleton (f ⁻¹' s) → Set.Subsingleton s",
  "name": "Set.subsingleton_of_preimage",
  "kind": "theorem",
  "doc_string":
  "If the preimage of a set under an surjective map is a subsingleton,\nthe set is a subsingleton. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → Option β → γ) → List α → List β → List γ × List β",
  "name": "List.zipWithLeft'",
  "kind": "def",
  "doc_string":
  "Left-biased version of `List.zipWith`. `zipWithLeft' f as bs` applies `f` to each\npair of elements `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, `f` is\napplied to `none` for the remaining `aᵢ`. Returns the results of the `f`\napplications and the remaining `bs`.\n```\nzipWithLeft' prod.mk [1, 2] ['a'] = ([(1, some 'a'), (2, none)], [])\nzipWithLeft' prod.mk [1] ['a', 'b'] = ([(1, some 'a')], ['b'])\n```\n",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "DistribLattice",
  "kind": "inductive",
  "doc_string":
  "A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ (y ⊓ z)`. To prove distributivity\nfrom the dual law, use `DistribLattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → (M →ₙ* N) → M → N",
  "name": "MulHom.Simps.apply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : One M] → [inst_1 : One N] → OneHom M N → M → N",
  "name": "OneHom.Simps.apply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type": "Lean.Name → Lean.Name → Lean.CoreM Unit",
  "name": "ToAdditive.proceedFields",
  "kind": "def",
  "doc_string":
  "Add the structure fields of `src` to the translations dictionary\nso that future uses of `to_additive` will map them to the corresponding `tgt` fields. ",
  "args": ""},
 {"type": "ℕ → List ℕ",
  "name": "List.range",
  "kind": "def",
  "doc_string":
  "`O(n)`. `range n` is the numbers from `0` to `n` exclusive, in increasing order.\n* `range 5 = [0, 1, 2, 3, 4]`\n",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {zα : Q(Zero «$α»)} →\n      {pα : Q(PartialOrder «$α»)} →\n        {e : Q(«$α»)} →\n          Lean.MetaM (Mathlib.Meta.Positivity.Strictness zα pα e) →\n            Lean.MetaM (Mathlib.Meta.Positivity.Strictness zα pα e)",
  "name": "Mathlib.Meta.Positivity.catchNone",
  "kind": "def",
  "doc_string":
  "Converts a `MetaM Strictness` which can fail\ninto one that never fails and returns `.none` instead. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Sort u_2} → (α → β) → (β → Option α) → Prop",
  "name": "Function.IsPartialInv",
  "kind": "def",
  "doc_string":
  "`g` is a partial inverse to `f` (an injective but not necessarily\nsurjective function) if `g y = some x` implies `f x = y`, and `g y = none`\nimplies that `y` is not in the range of `f`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} {a : α} {l : List α}, (∃ x, x ∈ a :: l ∧ p x) → p a ∨ ∃ x, x ∈ l ∧ p x",
  "name": "List.or_exists_of_exists_mem_cons",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `List.exists_mem_cons`.",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → (Mᵐᵒᵖ →ₙ* Nᵐᵒᵖ) ≃ (M →ₙ* N)",
  "name": "MulHom.unop",
  "kind": "def",
  "doc_string":
  "The 'unopposite' of a semigroup homomorphism `Mᵐᵒᵖ →ₙ* Nᵐᵒᵖ`. Inverse to `MulHom.op`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : IsTrans α fun x x_1 => x ⊆ x_1] {a b c : α}, a ⊆ b → b ⊆ c → a ⊆ c",
  "name": "HasSubset.Subset.trans",
  "kind": "theorem",
  "doc_string": "**Alias** of `subset_trans`.",
  "args": ""},
 {"type": "ℤ → Linarith.Sum",
  "name": "Linarith.scalar",
  "kind": "def",
  "doc_string":
  "A scalar `z` is represented by a `sum` with coefficient `z` and monomial `one` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Mul M] →\n      [inst_1 : Mul N] →\n        {f : M →ₙ* N} → Function.Injective ↑f → GaloisCoinsertion (Subsemigroup.map f) (Subsemigroup.comap f)",
  "name": "Subsemigroup.gciMapComap",
  "kind": "def",
  "doc_string":
  "`map f` and `comap f` form a `GaloisCoinsertion` when `f` is injective. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : SemilatticeSup α] {f : α → β} {r : β → β → Prop},\n  (∀ ⦃i j : α⦄, i ≤ j → r (f i) (f j)) → Directed r f",
  "name": "directed_of_sup",
  "kind": "theorem",
  "doc_string": "A monotone function on a sup-semilattice is directed. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹",
  "name": "map_inv",
  "kind": "theorem",
  "doc_string": "Group homomorphisms preserve inverse. ",
  "args": ""},
 {"type":
  "{ρ : Type u} → {m : Type u → Type v} → [self : MonadReader ρ m] → m ρ",
  "name": "MonadReader.read",
  "kind": "def",
  "doc_string": "`(← read) : ρ` reads the state out of monad `m`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "name": "List.isPrefix",
  "kind": "def",
  "doc_string":
  "`isPrefix l₁ l₂`, or `l₁ <+: l₂`, means that `l₁` is a prefix of `l₂`,\nthat is, `l₂` has the form `l₁ ++ t` for some `t`.\n",
  "args": ""},
 {"type": "{α : Type u} → ℕ → List α → List (ℕ × α)",
  "name": "List.enumFrom",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `enumFrom n l` is like `enum` but it allows you to specify the initial index.\n* `enumFrom 5 [a, b, c] = [(5, a), (6, b), (7, c)]`\n",
  "args": ""},
 {"type": "ByteSliceT → ℕ",
  "name": "ByteSliceT.size",
  "kind": "def",
  "doc_string": "The number of elements in the byte slice. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "LinearOrderedAddCommGroupWithTop",
  "kind": "inductive",
  "doc_string":
  "A linearly ordered commutative monoid with an additively absorbing `⊤` element.\nInstances should include number systems with an infinite element adjoined.` ",
  "args": ""},
 {"type":
  "{a : Lean.Level} →\n  {arg : Q(Type a)} →\n    {sα : Q(CommSemiring «$arg»)} →\n      {a_1 b : Q(«$arg»)} → Mathlib.Tactic.Ring.ExSum sα a_1 → Mathlib.Tactic.Ring.ExSum sα b → Ordering",
  "name": "Mathlib.Tactic.Ring.ExSum.cmp",
  "kind": "opaque",
  "doc_string":
  "A total order on normalized expressions.\nThis is not an `Ord` instance because it is heterogeneous.\n",
  "args": ""},
 {"type":
  "IO.Ref Mathlib.Tactic.Ring.State → Mathlib.Tactic.RingNF.Config → Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Tactic.RingNF.ringNFTarget",
  "kind": "def",
  "doc_string": "Use `ring_nf` to rewrite the main goal. ",
  "args": ""},
 {"type":
  "{R₁ : Type u_1} → {R₂ : Type u_2} → [inst : Semiring R₁] → [inst_1 : Semiring R₂] → (R₁ →+* R₂) → Prop",
  "name": "RingHomSurjective",
  "kind": "inductive",
  "doc_string":
  "Class expressing the fact that a `RingHom` is surjective. This is needed in the context\nof semilinear maps, where some lemmas require this. ",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α β : Type u_1} {p : α → Prop} {x : m α} {q : β → Prop} [inst : Monad m]\n  [inst_1 : LawfulMonad m] {f : α → m β},\n  SatisfiesM p x → (∀ (a : α), p a → SatisfiesM q (f a)) → SatisfiesM q (x >>= f)",
  "name": "SatisfiesM.bind",
  "kind": "theorem",
  "doc_string": "`SatisfiesM` distributes over `>>=`, general version. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, Function.Injective f → Function.Injective (Option.map f)",
  "name": "Option.map_injective",
  "kind": "theorem",
  "doc_string": "`Option.map f` is injective if `f` is injective. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  MonotoneOn f s → AntitoneOn (f ∘ ↑OrderDual.ofDual) s",
  "name": "MonotoneOn.dual_left",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `antitoneOn_comp_ofDual_iff`.",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Ring.Context",
  "kind": "inductive",
  "doc_string": "The context (read-only state) of the `RingM` monad. ",
  "args": ""},
 {"type": "ℚ → Bool",
  "name": "Rat.isInt",
  "kind": "def",
  "doc_string": "Is this rational number integral? ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} → [inst : Add M] → [inst_1 : Add N] → [inst_2 : Add P] → AddHom M N → AddHom M P → AddHom M (N × P)",
  "name": "AddHom.prod",
  "kind": "def",
  "doc_string":
  "Combine two `AddMonoidHom`s `f : AddHom M N`, `g : AddHom M P` into\n`f.prod g : AddHom M (N × P)` given by `(f.prod g) x = (f x, g x)`",
  "args": ""},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "name": "Seq",
  "kind": "inductive",
  "doc_string":
  "The typeclass which supplies the `<*>` \"seq\" function. See `Applicative`. ",
  "args": ""},
 {"type": "∀ {p : Prop}, (¬p → False) → p",
  "name": "Classical.by_contradiction",
  "kind": "theorem",
  "doc_string": "**Alias** of `Classical.byContradiction`.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {M' : Type u_3} →\n      {N' : Type u_4} →\n        [inst : Add M] →\n          [inst_1 : Add N] →\n            [inst_2 : Add M'] → [inst_3 : Add N'] → AddHom M M' → AddHom N N' → AddHom (M × N) (M' × N')",
  "name": "AddHom.prodMap",
  "kind": "def",
  "doc_string": "`prod.map` as an `AddMonoidHom`",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} {D : Type u₂} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {F F' : C ⥤ D},\n  (F ≅ F') → CategoryTheory.Functor.essImage F = CategoryTheory.Functor.essImage F'",
  "name": "CategoryTheory.Functor.essImage_eq_of_natIso",
  "kind": "theorem",
  "doc_string": "Isomorphic functors have equal essential images. ",
  "args": ""},
 {"type": "Substring → String.Pos → String.Pos",
  "name": "Substring.next",
  "kind": "def",
  "doc_string":
  "Given an offset of a codepoint into the substring,\nreturn the offset there of the next codepoint. ",
  "args": ""},
 {"type": "∀ (p : Prop), p ∨ ¬p",
  "name": "em",
  "kind": "theorem",
  "doc_string": "**Alias** of `Classical.em`.",
  "args": ""},
 {"type": "∀ (n : ℕ), Nat.choose n 2 = n * (n - 1) / 2",
  "name": "Nat.choose_two_right",
  "kind": "theorem",
  "doc_string": "`choose n 2` is the `n`-th triangle number. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] → (f : M →+ N) → (∀ (x y : M), AddCommute (↑f x) (↑f y)) → Mᵃᵒᵖ →+ N",
  "name": "AddMonoidHom.fromOpposite",
  "kind": "def",
  "doc_string":
  "An additive monoid homomorphism `f : M →+ N` such that `f x` additively commutes\nwith `f y` for all `x`, `y` defines an additive monoid homomorphism from `Mᵃᵒᵖ`.",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : LinearOrder α] → [inst : LinearOrder β] → LinearOrder (Lex (α × β))",
  "name": "Prod.Lex.linearOrder",
  "kind": "def",
  "doc_string": "Dictionary / lexicographic linear order for pairs. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a : Q(«$α»)} →\n        (rα : Q(Ring «$α»)) →\n          Mathlib.Tactic.Ring.ExSum sα a → Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExSum sα) q(-«$a»)",
  "name": "Mathlib.Tactic.Ring.evalNeg",
  "kind": "def",
  "doc_string":
  "Negates a polynomial `va` to get another polynomial.\n\n* `-0 = 0` (for `c` coefficient)\n* `-(a₁ + a₂) = -a₁ + -a₂`\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α}, a - b < c → a < b + c",
  "name": "lt_add_of_sub_left_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `sub_lt_iff_lt_add'`.",
  "args": ""},
 {"type": "{e : Q(ℕ)} → Mathlib.Tactic.Ring.ExtractCoeff e → Q(ℕ)",
  "name": "Mathlib.Tactic.Ring.ExtractCoeff.k",
  "kind": "def",
  "doc_string": "A raw natural number literal. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, a ≤ 0 → b < 0 → a + b < 0",
  "name": "Left.add_neg_of_nonpos_of_neg",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_neg_of_nonpos_of_neg`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddSemigroup α] (x y : α), ((fun x_1 => x + x_1) ∘ fun x => y + x) = fun x_1 => x + y + x_1",
  "name": "comp_add_left",
  "kind": "theorem",
  "doc_string":
  "Composing two additions on the left by `y` then `x`\nis equal to a addition on the left by `x + y`.",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → Q(Zero «$α») → Q(PartialOrder «$α») → Q(«$α») → Type",
  "name": "Mathlib.Meta.Positivity.Strictness",
  "kind": "inductive",
  "doc_string":
  "The result of `positivity` running on an expression `e` of type `α`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a : α}, 1 ≤ a⁻¹ ↔ a ≤ 1",
  "name": "Right.one_le_inv_iff",
  "kind": "theorem",
  "doc_string": "Uses `right` co(ntra)variant. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} {l : List α}, l ≠ [] → 0 < List.length l",
  "name": "List.length_pos_of_ne_nil",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `List.length_pos`.",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] → {D : Type u₂} → [inst_1 : CategoryTheory.Category D] → C ⥤ D → C ⥤q D",
  "name": "CategoryTheory.Functor.toPrefunctor",
  "kind": "def",
  "doc_string": "The prefunctor between the underlying quivers. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : PredOrder α] [inst_2 : Preorder β] {f : α → β},\n  Monotone f → Pairwise (Disjoint on fun n => Set.Ioc (f (Order.pred n)) (f n))",
  "name": "Monotone.pairwise_disjoint_on_Ioc_pred",
  "kind": "theorem",
  "doc_string":
  "If `α` is a linear pred order, `β` is a preorder, and `f : α → β` is a monotone function, then\nthe intervals `Set.Ioc (f Order.pred n) (f n)` are pairwise disjoint. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : CancelCommMonoidWithZero α] →\n    [inst_1 : DecidableEq α] → (∀ (a b : α), ∃ c, ∀ (d : α), a ∣ d ∧ b ∣ d ↔ c ∣ d) → GCDMonoid α",
  "name": "gcdMonoidOfExistsLCM",
  "kind": "def",
  "doc_string":
  "Define a `GCDMonoid` structure on a monoid just from the existence of an `lcm`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r : α → α → Prop} {s : Setoid α}, (∀ (x y : α), r x y → Setoid.Rel s x y) → EqvGen.Setoid r ≤ s",
  "name": "Setoid.eqvGen_le",
  "kind": "theorem",
  "doc_string":
  "The equivalence closure of a binary relation r is contained in any equivalence\nrelation containing r. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : CanonicallyLinearOrderedSemifield α] → ℤ → α → α",
  "name": "CanonicallyLinearOrderedSemifield.zpow",
  "kind": "def",
  "doc_string":
  "The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) ",
  "args": ""},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [self : MonadState σ m] → m σ",
  "name": "MonadState.get",
  "kind": "def",
  "doc_string": "`(← get) : σ` gets the state out of a monad `m`. ",
  "args": ""},
 {"type": "Erased (Sort u) → Sort u",
  "name": "Erased.OutType",
  "kind": "def",
  "doc_string":
  "Extracts the erased value, if it is a type.\n\nNote: `(mk a).OutType` is not definitionally equal to `a`.\n",
  "args": ""},
 {"type":
  "∀ (G : Type u) [inst : CommSemigroup G] [inst_1 : IsLeftCancelMul G], IsRightCancelMul G",
  "name": "CommSemigroup.IsLeftCancelMul.toIsRightCancelMul",
  "kind": "theorem",
  "doc_string":
  "Any `CommSemigroup G` that satisfies `IsLeftCancelMul G` also satisfies\n`IsRightCancelMul G`. ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → [self : Coe α β] → α → β",
  "name": "Coe.coe",
  "kind": "def",
  "doc_string":
  "Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddSemigroup M] → AddCommSemigroup { x // x ∈ AddSubsemigroup.center M }",
  "name":
  "AddSubsemigroup.instAddCommSemigroupSubtypeMemSubsemigroupToAddInstMembershipInstSetLikeSubsemigroupCenter",
  "kind": "def",
  "doc_string": "The center of an additive semigroup is commutative.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "TwoPointing",
  "kind": "inductive",
  "doc_string":
  "Two-pointing of a type. This is a Type-valued termed `Nontrivial`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "termDepIfThenElse",
  "kind": "def",
  "doc_string":
  "\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h => t(h)) (fun h => e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr ⟨i, h⟩` expects a proof `h : i < arr.size` in order to\navoid a bounds check, so you can write `if h : i < arr.size then arr.get ⟨i, h⟩ else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i < arr.size` from some other proposition that we are checking in the `if`.)\n",
  "args": ""},
 {"type":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : Quot r → Sort v} →\n      [h : ∀ (a : α), Subsingleton (motive (Quot.mk r a))] → (q : Quot r) → ((a : α) → motive (Quot.mk r a)) → motive q",
  "name": "Quot.recOnSubsingleton",
  "kind": "def",
  "doc_string":
  "Dependent induction principle for a quotient, when the target type is a `Subsingleton`.\nIn this case the quotient's side condition is trivial so any function can be lifted.\n",
  "args": ""},
 {"type": "(M₀ : Type u) → [inst : Mul M₀] → [inst : Zero M₀] → Prop",
  "name": "IsRightCancelMulZero",
  "kind": "inductive",
  "doc_string":
  "A mixin for right cancellative multiplication by nonzero elements. ",
  "args": ""},
 {"type": "{G₀ : Type u_1} → [self : CommGroupWithZero G₀] → ℤ → G₀ → G₀",
  "name": "CommGroupWithZero.zpow",
  "kind": "def",
  "doc_string":
  "The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) ",
  "args": ""},
 {"type": "(p : Prop) → [h : Decidable p] → Bool",
  "name": "Decidable.decide",
  "kind": "def",
  "doc_string":
  "Convert a decidable proposition into a boolean value.\n\nIf `p : Prop` is decidable, then `decide p : Bool` is the boolean value\nwhich is `true` if `p` is true and `false` if `p` is false.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} {f : α → β} {g : β → α},\n  Function.Injective f → Function.Injective g → ∃ h, Function.Bijective h",
  "name": "Function.Embedding.schroeder_bernstein",
  "kind": "theorem",
  "doc_string":
  "**The Schröder-Bernstein Theorem**:\nGiven injections `α → β` and `β → α`, we can get a bijection `α → β`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 < a → 0 < b → 0 < a + b",
  "name": "add_pos'",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.add_pos'`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {s : Set α}, Set.Nontrivial s → Set.Nonempty (Set.offDiag s)",
  "name": "Set.Subsingleton.offDiag_eq_empty",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `Set.offDiag_nonempty`.",
  "args": ""},
 {"type":
  "∀ {I : Type u} {f : I → Type v} [inst : DecidableEq I] [inst_1 : (i : I) → MulOneClass (f i)] (x : (i : I) → f i)\n  (i j : I), Commute (Pi.mulSingle i (x i)) (Pi.mulSingle j (x j))",
  "name": "Pi.mulSingle_apply_commute",
  "kind": "theorem",
  "doc_string": "The injection into a pi group with the same values commutes. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} {α : Type u_3} [inst : VAdd M N] [inst_1 : VAdd N α] [inst_2 : VAdd M α]\n  [self : VAddAssocClass M N α] (x : M) (y : N) (z : α), x +ᵥ y +ᵥ z = x +ᵥ (y +ᵥ z)",
  "name": "VAddAssocClass.vadd_assoc",
  "kind": "def",
  "doc_string": "Associativity of `+ᵥ` ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.rename'",
  "kind": "def",
  "doc_string":
  "`rename' h => hnew` renames the hypothesis named `h` to `hnew`.\nTo rename several hypothesis, use `rename' h₁ => h₁new, h₂ => h₂new`.\nYou can use `rename' a => b, b => a` to swap two variables. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_2} (g : β → γ) (f : α → β) (s : Set α),\n  g '' (f '' s) = (fun x => g (f x)) '' s",
  "name": "Set.image_image",
  "kind": "theorem",
  "doc_string": "A variant of `image_comp`, useful for rewriting ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : α → Type u_2} → (p : α → Prop) → ((x : α) → β x) → (x : Subtype p) → β ↑x",
  "name": "Subtype.restrict",
  "kind": "def",
  "doc_string": "Restrict a (dependent) function to a subtype ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → [inst : IsTrans β s] → Coe (r ≺i s) (r ≼i s)",
  "name": "PrincipalSeg.hasCoeInitialSeg",
  "kind": "def",
  "doc_string": "A principal segment is in particular an initial segment. ",
  "args": ""},
 {"type": "{α : Type u_1} → [self : Fintype α] → Finset α",
  "name": "Fintype.elems",
  "kind": "def",
  "doc_string": "The `Finset` of elements of a `Fintype`. ",
  "args": ""},
 {"type":
  "∀ (α : Type u_1) [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [inst_3 : ZeroLEOneClass α], 0 ≤ 1",
  "name": "zero_le_one'",
  "kind": "theorem",
  "doc_string": "`zero_le_one` with the type argument explicit. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : BEq α] [self : LawfulBEq α] {a : α}, (a == a) = true",
  "name": "LawfulBEq.rfl",
  "kind": "def",
  "doc_string": "`==` is reflexive, that is, `(a == a) = true`. ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Semiring R] → Module Rᵐᵒᵖ R",
  "name": "Semiring.toOppositeModule",
  "kind": "def",
  "doc_string": "Like `Semiring.toModule`, but multiplies on the right. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«command#helpCat+___»",
  "kind": "def",
  "doc_string":
  "The command `#help cat C` shows all syntaxes that have been defined in syntax category `C` in the\ncurrent environment.\nEach syntax has a format like:\n```\nsyntax \"first\"... [Parser.tactic.first]\n  `first | tac | ...` runs each `tac` until one succeeds, or else fails.\n```\nThe quoted string is the leading token of the syntax, if applicable. It is followed by the full\nname of the syntax (which you can also click to go to the definition), and the documentation.\n\n* The form `#help cat C id` will show only attributes that begin with `id`.\n* The form `#help cat+ C` will also show information about any `macro`s and `elab`s\n  associated to the listed syntaxes.\n",
  "args": ""},
 {"type":
  "{I : Type u} → (f : I → Type v) → [inst : (i : I) → NonAssocSemiring (f i)] → (i : I) → ((i : I) → f i) →+* f i",
  "name": "Pi.evalRingHom",
  "kind": "def",
  "doc_string":
  "Evaluation of functions into an indexed collection of rings at a point is a ring\nhomomorphism. This is `Function.eval` as a `RingHom`. ",
  "args": ""},
 {"type":
  "{I : Type u} → {f : I → Type v₁} → [inst : DecidableEq I] → [inst : (i : I) → One (f i)] → (i : I) → f i → (j : I) → f j",
  "name": "Pi.mulSingle",
  "kind": "def",
  "doc_string":
  "The function supported at `i`, with value `x` there, and `1` elsewhere. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Ring.State",
  "kind": "inductive",
  "doc_string": "The mutable state of the `RingM` monad. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → [inst : AddMonoidWithOne R] → [inst : CharZero R] → ℕ ↪ R",
  "name": "Nat.castEmbedding",
  "kind": "def",
  "doc_string":
  "`Nat.cast` as an embedding into monoids of characteristic `0`. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Additive",
  "kind": "def",
  "doc_string":
  "If `α` carries some multiplicative structure, then `Additive α` carries the corresponding\nadditive structure. ",
  "args": ""},
 {"type": "ParsedProjectionData → Option Lean.Expr",
  "name": "ParsedProjectionData.expr?",
  "kind": "def",
  "doc_string": "projection expression ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : MulZeroClass R] [nR : Nontrivial R], ¬IsLeftRegular 0",
  "name": "not_isLeftRegular_zero",
  "kind": "theorem",
  "doc_string":
  "In a non-trivial ring, the element `0` is not left-regular -- with typeclasses. ",
  "args": ""},
 {"type": "{α : Sort u_1} → {β : Sort u_2} → (α ↪ β) → α → β",
  "name": "Function.Embedding.toFun",
  "kind": "def",
  "doc_string": "An embedding as a function. Use coercion instead. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : CanonicallyOrderedAddMonoid α] → CanonicallyOrderedAddMonoid (WithZero α)",
  "name": "WithZero.canonicallyOrderedAddMonoid",
  "kind": "def",
  "doc_string":
  "Adding a new zero to a canonically ordered additive monoid produces another one. ",
  "args": ""},
 {"type": "{α : Type u_1} → Array α → (α → α → Bool) → Array α",
  "name": "Array.heapSort",
  "kind": "def",
  "doc_string": "`O(n log n)`. Sort an array using a `BinaryHeap`. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → M × N →+ M",
  "name": "AddMonoidHom.fst",
  "kind": "def",
  "doc_string":
  "Given additive monoids `A`, `B`, the natural projection homomorphism\nfrom `A × B` to `A`",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (f : α → β) → (s : Set α) → Function.Injective f → ↑s ≃ ↑(f '' s)",
  "name": "Equiv.Set.image",
  "kind": "def",
  "doc_string":
  "If `f` is an injective function, then `s` is equivalent to `f '' s`. ",
  "args": ""},
 {"type":
  "{V : Type u_1} → [inst : Quiver V] → (H : WideSubquiver V) → Quiver (WideSubquiver.toType V H)",
  "name": "WideSubquiver.quiver",
  "kind": "def",
  "doc_string": "A wide subquiver viewed as a quiver on its own. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      {x : NonAssocSemiring α} →\n        {x_1 : NonAssocSemiring β} → {x_2 : NonAssocSemiring γ} → (β →+* γ) → (α →+* β) → α →+* γ",
  "name": "RingHom.comp",
  "kind": "def",
  "doc_string": "Composition of ring homomorphisms is a ring homomorphism. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : GroupWithZero α] → (a b : α) → [inst_1 : Invertible a] → [inst_2 : Invertible b] → Invertible (a / b)",
  "name": "invertibleDiv",
  "kind": "def",
  "doc_string": "`b / a` is the inverse of `a / b` ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [inst_2 : Unique N] → M × N ≃+ M",
  "name": "AddEquiv.prodUnique",
  "kind": "def",
  "doc_string":
  "Multiplying by the trivial monoid doesn't change the structure.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        {M' : Type u_3} →\n          {N' : Type u_4} →\n            [inst_2 : AddZeroClass M'] → [inst_3 : AddZeroClass N'] → (M →+ M') → (N →+ N') → M × N →+ M' × N'",
  "name": "AddMonoidHom.prodMap",
  "kind": "def",
  "doc_string": "`prod.map` as an `AddHonoidHom`",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : PartialOrder β] (r : α → α → Prop) [inst_1 : IsSymm α r] {f : α → β},\n  (∀ (a b : α), r a b → f a ≤ f b) → ∀ {a b : α}, r a b → f a = f b",
  "name": "rel_imp_eq_of_rel_imp_le",
  "kind": "theorem",
  "doc_string":
  "A symmetric relation implies two values are equal, when it implies they're less-equal.  ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {l : α → β} →\n          {u : β → α} →\n            Monotone u → Monotone l → (∀ (a : α), a ≤ u (l a)) → (∀ (b : β), l (u b) = b) → GaloisInsertion l u",
  "name": "GaloisInsertion.monotoneIntro",
  "kind": "def",
  "doc_string":
  "A constructor for a Galois insertion with the trivial `choice` function. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a : α}, 1 < a⁻¹ ↔ a < 1",
  "name": "Right.one_lt_inv_iff",
  "kind": "theorem",
  "doc_string": "Uses `right` co(ntra)variant. ",
  "args": ""},
 {"type": "outParam (Type u) → Type u → Type u",
  "name": "EStateM.Backtrackable",
  "kind": "inductive",
  "doc_string":
  "Auxiliary instance for saving/restoring the \"backtrackable\" part of the state.\nHere `σ` is the state, and `δ` is some subpart of it, and we have a\ngetter and setter for it (a \"lens\" in the Haskell terminology).\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → α × β →o β",
  "name": "OrderHom.snd",
  "kind": "def",
  "doc_string": "`Prod.snd` as a `OrderHom`. ",
  "args": ""},
 {"type": "{α : Sort u_1} → (p : α → α → Prop) → DecidableRel p",
  "name": "Classical.decRel",
  "kind": "def",
  "doc_string": "Any relation `p` is decidable classically. ",
  "args": ""},
 {"type":
  "∀ {a b c m : ℕ}, 0 < m → c * a ≡ c * b [MOD m] → a ≡ b [MOD m / Nat.gcd m c]",
  "name": "Nat.ModEq.modEq_cancel_left_div_gcd",
  "kind": "theorem",
  "doc_string":
  "To cancel a common factor `c` from a `ModEq` we must divide the modulus `m` by `gcd m c` ",
  "args": ""},
 {"type": "{α : Type u} → α → ForInStep α",
  "name": "ForInStep.done",
  "kind": "def",
  "doc_string":
  "`.done a` means that we should early-exit the loop.\n`.done` is produced by calls to `break` or `return` in the loop. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : NormalizationMonoid α] {a b : α},\n  a ≠ 0 → b ≠ 0 → normUnit (a * b) = normUnit a * normUnit b",
  "name": "NormalizationMonoid.normUnit_mul",
  "kind": "def",
  "doc_string":
  "The proposition that `normUnit` respects multiplication of non-zero elements. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Set α → Prop",
  "name": "MonotoneOn",
  "kind": "def",
  "doc_string":
  "A function `f` is monotone on `s` if, for all `a, b ∈ s`, `a ≤ b` implies `f a ≤ f b`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Semigroup M] →\n      [inst_1 : Semigroup N] →\n        {s : Set M} → (f : M → N) → Subsemigroup.closure s = ⊤ → (∀ (x y : M), y ∈ s → f (x * y) = f x * f y) → M →ₙ* N",
  "name": "MulHom.ofDense",
  "kind": "def",
  "doc_string":
  "Let `s` be a subset of a semigroup `M` such that the closure of `s` is the whole semigroup.\nThen `MulHom.ofDense` defines a mul homomorphism from `M` asking for a proof\nof `f (x * y) = f x * f y` only for `y ∈ s`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.LinearCombination.normStx",
  "kind": "def",
  "doc_string":
  "The `(norm := $tac)` syntax says to use `tac` as a normalization postprocessor for\n`linear_combination`. The default normalizer is `ring1`, but you can override it with `ring_nf`\nto get subgoals from `linear_combination` or with `skip` to disable normalization.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : Preorder β] {a : α} {f : α → β},\n  AntitoneOn f (Set.Iic a) → AntitoneOn f (Set.Ici a) → Antitone f",
  "name": "AntitoneOn.Iic_union_Ici",
  "kind": "theorem",
  "doc_string":
  "If `f` is antitone both on `(-∞, a]` and `[a, ∞)`, then it is antitone on the whole line. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = a → a ≤ b",
  "name": "le_of_inf_eq",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `inf_eq_left`.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LT α] → α → Prop",
  "name": "Order.IsSuccLimit",
  "kind": "def",
  "doc_string":
  "A successor limit is a value that doesn't cover any other.\n\nIt's so named because in a successor order, a successor limit can't be the successor of anything\nsmaller. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : StrictOrderedRing α] (a b : α), 0 < a → 0 < b → 0 < a * b",
  "name": "StrictOrderedRing.mul_pos",
  "kind": "def",
  "doc_string": "The product of two positive elements is positive. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c d : α},\n  a < b → c < d → a + c < b + d",
  "name": "add_lt_add",
  "kind": "theorem",
  "doc_string": "**Alias** of `add_lt_add_of_lt_of_lt`.",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {e : Q(«$α»)} →\n        Mathlib.Meta.NormNum.Result e → Option (Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExSum sα) e)",
  "name": "Mathlib.Tactic.Ring.evalCast",
  "kind": "def",
  "doc_string":
  "Converts a proof by `norm_num` that `e` is a numeral, into a normalization as a monomial:\n\n* `e = 0` if `norm_num` returns `IsNat e 0`\n* `e = Nat.rawCast n + 0` if `norm_num` returns `IsNat e n`\n* `e = Int.rawCast n + 0` if `norm_num` returns `IsInt e n`\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α}, b < c - a → a + b < c",
  "name": "add_lt_of_lt_sub_left",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `lt_sub_iff_add_lt'`.",
  "args": ""},
 {"type": "(ℕ → Bool) → ℕ → Bool",
  "name": "Nat.all",
  "kind": "def",
  "doc_string":
  "`all f n = true` iff every `i in [0, n-1]` satisfies `f i = true` ",
  "args": ""},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [self : MonadStateOf σ m] → {α : Type u} → (σ → α × σ) → m α",
  "name": "MonadStateOf.modifyGet",
  "kind": "def",
  "doc_string":
  "`modifyGet (f : σ → α × σ)` applies `f` to the current state, replaces\nthe state with the return value, and returns a computed value.\n\nIt is equivalent to `do let (a, s) := f (← get); put s; pure a`, but\n`modifyGet f` may be preferable because the former does not use the state\nlinearly (without sufficient inlining). ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsLeftRegular a → IsLeftRegular b → IsLeftRegular (a * b)",
  "name": "IsLeftRegular.mul",
  "kind": "theorem",
  "doc_string":
  "In a semigroup, the product of left-regular elements is left-regular. ",
  "args": ""},
 {"type":
  "IO.Ref Mathlib.Tactic.Ring.State → Mathlib.Tactic.RingNF.Config → Lean.FVarId → Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Tactic.RingNF.ringNFLocalDecl",
  "kind": "def",
  "doc_string": "Use `ring_nf` to rewrite hypothesis `h`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {a b : α}, a < 0 → b < 0 → (1 / a < 1 / b ↔ b < a)",
  "name": "one_div_lt_one_div_of_neg",
  "kind": "theorem",
  "doc_string":
  "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and\n`lt_of_one_div_lt_one_div` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {A : Type u_2} →\n    {B : Type u_3} →\n      [inst : Monoid M] →\n        [inst_1 : AddMonoid A] →\n          [inst_2 : DistribMulAction M A] →\n            [inst_3 : AddMonoid B] →\n              [inst_4 : SMul M B] →\n                (f : A →+ B) →\n                  Function.Surjective ↑f → (∀ (c : M) (x : A), ↑f (c • x) = c • ↑f x) → DistribMulAction M B",
  "name": "Function.Surjective.distribMulAction",
  "kind": "def",
  "doc_string":
  "Pushforward a distributive multiplicative action along a surjective additive monoid\nhomomorphism.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {s s' : Set α} {t t' : Set β},\n  s ⊆ s' → t ⊆ t' → Set.image2 f s t ⊆ Set.image2 f s' t'",
  "name": "Set.image2_subset",
  "kind": "theorem",
  "doc_string": "image2 is monotone with respect to `⊆`. ",
  "args": ""},
 {"type": "∀ (M : Type u) [inst : AddCancelMonoid M], IsCancelAdd M",
  "name": "AddCancelMonoid.toIsCancelAdd",
  "kind": "def",
  "doc_string": "Any `AddCancelMonoid G` satisfies `IsCancelAdd G`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : Order.Frame α] (a : α) (s : Set α), a ⊓ supₛ s ≤ ⨆ b, ⨆ h, a ⊓ b",
  "name": "Order.Frame.inf_supₛ_le_supᵢ_inf",
  "kind": "def",
  "doc_string": "In a frame, `⊓` distributes over `⨆`. ",
  "args": ""},
 {"type": "∀ {M : Type u} [self : LeftCancelMonoid M] (a : M), a * 1 = a",
  "name": "LeftCancelMonoid.mul_one",
  "kind": "def",
  "doc_string": "One is a right neutral element for multiplication ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : AddMonoidWithOne α] → ℕ →+ α",
  "name": "Nat.castAddMonoidHom",
  "kind": "def",
  "doc_string": "`Nat.cast : ℕ → α` as an `AddMonoidHom`. ",
  "args": ""},
 {"type": "{α : Sort u_1} → (p : α → Prop) → DecidablePred p",
  "name": "Classical.decPred",
  "kind": "def",
  "doc_string": "Any predicate `p` is decidable classically. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] [self : NoTopOrder α] (a : α), ∃ b, ¬b ≤ a",
  "name": "NoTopOrder.exists_not_le",
  "kind": "def",
  "doc_string":
  "For each term `a`, there is some `b` which is either incomparable or strictly larger. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.tacticAssumption'",
  "kind": "def",
  "doc_string":
  "Try calling `assumption` on all goals; succeeds if it closes at least one goal. ",
  "args": ""},
 {"type": "ℕ → Linarith.Linexp → ℤ",
  "name": "Linarith.Linexp.zfind",
  "kind": "def",
  "doc_string":
  "`l.zfind n` returns the value associated with key `n` if there is one, and 0 otherwise.\n",
  "args": ""},
 {"type":
  "{α : Type} → String → α → (Lean.Name → Lean.ConstantInfo → α → Lean.MetaM α) → IO (Mathlib.Tactic.DeclCache α)",
  "name": "Mathlib.Tactic.DeclCache.mk",
  "kind": "def",
  "doc_string":
  "Creates a `DeclCache`.\nThe cached structure `α` is initialized with `empty`,\nand then `addDecl` is called for every constant in the environment.\nCalls to `addDecl` for imported constants are cached.\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_≃._»",
  "kind": "def",
  "doc_string":
  "A `PEquiv` is a partial equivalence, a representation of a bijection between a subset\n  of `α` and a subset of `β`. See also `LocalEquiv` for a version that requires `toFun` and\n`invFun` to be globally defined functions and has `source` and `target` sets as extra fields. ",
  "args": ""},
 {"type": "Num → Num",
  "name": "Num.size",
  "kind": "def",
  "doc_string":
  "The number of bits required to represent a `Num`, as a `Num`. `size 0` is defined to be `0`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → {sα : Q(CommSemiring «$α»)} → {e : Q(«$α»)} → ℤ → Mathlib.Tactic.Ring.ExProd sα e",
  "name": "Mathlib.Tactic.Ring.ExProd.const",
  "kind": "def",
  "doc_string":
  "A coefficient `value`, which must not be `0`. `e` is a raw int cast. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → ∀ {a : α} {s : Set α}, IsGreatest s a → IsGreatest (f '' s) (f a)",
  "name": "Monotone.map_isGreatest",
  "kind": "theorem",
  "doc_string":
  "A monotone map sends a greatest element of a set to a greatest element of its image. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_<*_»",
  "kind": "def",
  "doc_string":
  "If `x : F α` and `y : F β`, then `x <* y` evaluates `x`, then `y`,\nand returns the result of `x`.\n\nTo avoid surprising evaluation semantics, `y` is taken \"lazily\", using a\n`Unit → f β` function. ",
  "args": ""},
 {"type":
  "{m : Type u → Type v} → {n : Type u → Type w} → [self : MonadLift m n] → {α : Type u} → m α → n α",
  "name": "MonadLift.monadLift",
  "kind": "def",
  "doc_string": "Lifts a value from monad `m` into monad `n`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List (Option α) → List α → List α",
  "name": "List.fillNonesTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `fillNones`. ",
  "args": ""},
 {"type":
  "Type u_1 →\n  (α : outParam (Type u_2)) →\n    (β : outParam (Type u_3)) →\n      [inst : Preorder α] →\n        [inst : Preorder β] → [inst : MulOneClass α] → [inst : MulOneClass β] → Type (max (max u_1 u_2) u_3)",
  "name": "OrderMonoidHomClass",
  "kind": "inductive",
  "doc_string":
  "`OrderMonoidHomClass F α β` states that `F` is a type of ordered monoid homomorphisms.\n\nYou should also extend this typeclass when you extend `OrderMonoidHom`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Antitone f → ∀ {a : α} {s : Set α}, IsGreatest s a → IsLeast (f '' s) (f a)",
  "name": "Antitone.map_isGreatest",
  "kind": "theorem",
  "doc_string":
  "An antitone map sends a greatest element of a set to a least element of its image. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : CancelCommMonoidWithZero α] → [self : GCDMonoid α] → α → α → α",
  "name": "GCDMonoid.gcd",
  "kind": "def",
  "doc_string": "The greatest common divisor between two elements. ",
  "args": ""},
 {"type":
  "{ρ : Type u} → {m : Type u → Type v} → [self : MonadWithReader ρ m] → {α : Type u} → (ρ → ρ) → m α → m α",
  "name": "MonadWithReader.withReader",
  "kind": "def",
  "doc_string":
  "`withReader (f : ρ → ρ) (x : m α) : m α`  runs the inner `x : m α` inside\na modified context after applying the function `f : ρ → ρ`.",
  "args": ""},
 {"type":
  "{R : Type u_1} → {S : Type u_2} → [inst : NonAssocSemiring R] → [inst_1 : NonAssocSemiring S] → R ≃+* S → R →* S",
  "name": "RingEquiv.toMonoidHom",
  "kind": "def",
  "doc_string": "Reinterpret a ring equivalence as a monoid homomorphism. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, a⁻¹ ≤ b → b⁻¹ ≤ a",
  "name": "inv_le_of_inv_le'",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `inv_le'`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedAddCommMonoidWithTop α] (x : α), ⊤ + x = ⊤",
  "name": "LinearOrderedAddCommMonoidWithTop.top_add'",
  "kind": "def",
  "doc_string":
  "In a `LinearOrderedAddCommMonoidWithTop`, the `⊤` element is invariant under addition. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [inst_3 : OrderedSub α]\n  {a b c d : α} [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  a + b - (c + d) ≤ a - c + (b - d)",
  "name": "add_tsub_add_le_tsub_add_tsub",
  "kind": "theorem",
  "doc_string": "See `tsub_add_tsub_comm` for the equality. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "CategoryTheory.«term_=≫_»",
  "kind": "def",
  "doc_string":
  "Notation for whiskering an equation by a morphism (on the right).\nIf `f g : X ⟶ Y` and `w : f = g` and `h : Y ⟶ Z`, then `w =≫ h : f ≫ h = g ≫ h`.\n",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Inv M₂] →\n      [inst_1 : InvolutiveInv M₁] →\n        (f : M₁ → M₂) → Function.Surjective f → (∀ (x : M₁), f x⁻¹ = (f x)⁻¹) → InvolutiveInv M₂",
  "name": "Function.Surjective.involutiveInv",
  "kind": "def",
  "doc_string":
  "A type has an involutive inversion if it admits a surjective map that preserves `⁻¹` to a type\nwhich has an involutive inversion. See note [reducible non-instances] ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → (α → Bool) → Aesop.UnorderedArraySet α → Aesop.UnorderedArraySet α",
  "name": "Aesop.UnorderedArraySet.filter",
  "kind": "def",
  "doc_string": "O(n) ",
  "args": ""},
 {"type":
  "∀ (G : Type u) [inst : CommSemigroup G] [inst_1 : IsRightCancelMul G], IsCancelMul G",
  "name": "CommSemigroup.IsRightCancelMul.toIsCancelMul",
  "kind": "theorem",
  "doc_string":
  "Any `CommSemigroup G` that satisfies `IsRightCancelMul G` also satisfies\n`IsCancelMul G`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] {a : αᵒᵈ}, IsMax a → IsMin (↑OrderDual.ofDual a)",
  "name": "IsMax.ofDual",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `isMin_ofDual_iff`.",
  "args": ""},
 {"type": "{α : Type u} → LazyList α → Thunk (LazyList α) → LazyList α",
  "name": "LazyList.append",
  "kind": "def",
  "doc_string": "Appends two lazy lists.  ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Mul M] ⦃s t : Set M⦄, s ⊆ t → Subsemigroup.closure s ≤ Subsemigroup.closure t",
  "name": "Subsemigroup.closure_mono",
  "kind": "theorem",
  "doc_string":
  "subsemigroup closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : NonAssocSemiring α] → [inst_1 : NonAssocSemiring β] → (α →+* β) → α →* β",
  "name": "RingHom.toMonoidHom",
  "kind": "def",
  "doc_string":
  "Reinterpret a ring homomorphism `f : α →+* β` as a monoid homomorphism `α →* β`.\nThe `simp`-normal form is `(f : α →* β)`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → List α → Array α → List α",
  "name": "List.erasePTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `erasePTR`: `erasePTR.go p l xs acc = acc.toList ++ eraseP p xs`,\nunless `xs` does not contain any elements satisfying `p`, where it returns `l`. ",
  "args": ""},
 {"type":
  "{F : Type u → Type u} → [inst : Functor F] → {α : Type u} → (α → Prop) → F α → Prop",
  "name": "Functor.Liftp",
  "kind": "def",
  "doc_string":
  "If we consider `x : F α` to, in some sense, contain values of type `α`,\npredicate `Liftp p x` holds iff every value contained by `x` satisfies `p`. ",
  "args": ""},
 {"type": "∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1",
  "name": "Field.zpow_zero'",
  "kind": "def",
  "doc_string": "`a ^ 0 = 1` ",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : AddGroup G] → G ≃+ AddUnits G",
  "name": "toAddUnits",
  "kind": "def",
  "doc_string":
  "An additive group is isomorphic to its group of additive units",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a",
  "name": "LinearOrderedSemifield.zpow_succ'",
  "kind": "def",
  "doc_string": "`a ^ (n + 1) = a * a ^ n` ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Pi.«Πₗ_,_»",
  "kind": "def",
  "doc_string":
  "The notation `Πₗ i, α i` refers to a pi type equipped with the lexicographic order. ",
  "args": ""},
 {"type": "{α : Type} → Mathlib.Tactic.DeclCache α → Lean.MetaM α",
  "name": "Mathlib.Tactic.DeclCache.get",
  "kind": "def",
  "doc_string":
  "Access the cache.\nCalling this function for the first time\nwill initialize the cache with the function\nprovided in the constructor.\n",
  "args": ""},
 {"type":
  "{C : Type u₁} → {D : Type u₂} → [inst : CategoryTheory.Category C] → [inst_1 : CategoryTheory.Category D] → C ⥤ D → Prop",
  "name": "CategoryTheory.EssSurj",
  "kind": "inductive",
  "doc_string":
  "A functor `F : C ⥤ D` is essentially surjective if every object of `D` is in the essential\nimage of `F`. In other words, for every `Y : D`, there is some `X : C` with `F.obj X ≅ Y`.\n\nSee <https://stacks.math.columbia.edu/tag/001C>.\n",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : MulOneClass M] → [inst : MulOneClass N] → Type (max u_1 u_2)",
  "name": "MonoidHom",
  "kind": "inductive",
  "doc_string":
  "`M →* N` is the type of functions `M → N` that preserve the `Monoid` structure.\n`MonoidHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M →+ N)`,\nyou should parametrize over `(F : Type*) [MonoidHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `MonoidHomClass`.\n",
  "args": ""},
 {"type": "∀ {M : Type u} [self : RightCancelMonoid M] (a : M), a * 1 = a",
  "name": "RightCancelMonoid.mul_one",
  "kind": "def",
  "doc_string": "One is a right neutral element for multiplication ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.inferOptParam",
  "kind": "def",
  "doc_string":
  "Close a goal of the form `optParam α a` or `autoParam α stx` by using `a`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddSemigroup M] →\n      [inst_1 : AddSemigroup N] →\n        {s : Set M} →\n          (f : M → N) → AddSubsemigroup.closure s = ⊤ → (∀ (x y : M), y ∈ s → f (x + y) = f x + f y) → AddHom M N",
  "name": "AddHom.ofDense",
  "kind": "def",
  "doc_string":
  "Let `s` be a subset of an additive semigroup `M` such that the closure of `s` is the whole\nsemigroup.  Then `AddHom.ofDense` defines an additive homomorphism from `M` asking for a proof\nof `f (x + y) = f x + f y` only for `y ∈ s`. ",
  "args": ""},
 {"type": "Q(Prop) → Lean.MetaM Bool",
  "name": "Mathlib.Tactic.Tauto.coreConstructorMatcher",
  "kind": "def",
  "doc_string":
  "Matches propositions where we want to apply the `constructor` tactic\nin the core loop of `tauto`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : MulOneClass α] → [inst_1 : CommMonoid β] → (α →* β) →* α → β",
  "name": "MonoidHom.coeFn",
  "kind": "def",
  "doc_string":
  "Coercion of a `MonoidHom` into a function is itself a `MonoidHom`.\n\nSee also `MonoidHom.eval`. ",
  "args": ""},
 {"type": "∀ {a b : Prop}, (a ↔ b) → a = b",
  "name": "propext",
  "kind": "axiom",
  "doc_string":
  "The axiom of **propositional extensionality**. It asserts that if propositions\n`a` and `b` are logically equivalent (i.e. we can prove `a` from `b` and vice versa),\nthen `a` and `b` are *equal*, meaning that we can replace `a` with `b` in all\ncontexts.\n\nFor simple expressions like `a ∧ c ∨ d → e` we can prove that because all the logical\nconnectives respect logical equivalence, we can replace `a` with `b` in this expression\nwithout using `propext`. However, for higher order expressions like `P a` where\n`P : Prop → Prop` is unknown, or indeed for `a = b` itself, we cannot replace `a` with `b`\nwithout an axiom which says exactly this.\n\nThis is a relatively uncontroversial axiom, which is intuitionistically valid.\nIt does however block computation when using `#reduce` to reduce proofs directly\n(which is not recommended), meaning that canonicity,\nthe property that all closed terms of type `Nat` normalize to numerals,\nfails to hold when this (or any) axiom is used:\n```\nset_option pp.proofs true\n\ndef foo : Nat := by\n  have : (True → True) ↔ True := ⟨λ _ => trivial, λ _ _ => trivial⟩\n  have := propext this ▸ (2 : Nat)\n  exact this\n\n#reduce foo\n-- propext { mp := fun x x => True.intro, mpr := fun x => True.intro } ▸ 2\n\n#eval foo -- 2\n```\n`#eval` can evaluate it to a numeral because the compiler erases casts and\ndoes not evaluate proofs, so `propext`, whose return type is a proposition,\ncan never block it.\n",
  "args": ""},
 {"type":
  "{g : Type} →\n  (α : Type u) →\n    [inst : Preorder α] →\n      [inst_1 : BoundedRandom α] → (lo hi : α) → lo ≤ hi → [inst_2 : RandomGen g] → RandG g { a // lo ≤ a ∧ a ≤ hi }",
  "name": "Random.randBound",
  "kind": "def",
  "doc_string":
  "Generate a random value of type `α` between `x` and `y` inclusive. ",
  "args": ""},
 {"type":
  "{A : Type u_1} → [inst : AddMonoid A] → DistribMulAction (AddAut A) A",
  "name": "AddAut.applyDistribMulAction",
  "kind": "def",
  "doc_string":
  "The tautological action by `AddAut A` on `A`.\n\nThis generalizes `Function.End.applyMulAction`. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_2} {α : Type u_1} [inst : MonoidWithZero α] [inst_1 : MonoidWithZeroHomClass F ℤ α] {f g : F},\n  ↑f (-1) = ↑g (-1) → (∀ (n : ℕ), 0 < n → ↑f ↑n = ↑g ↑n) → f = g",
  "name": "ext_int'",
  "kind": "theorem",
  "doc_string":
  "If two `MonoidWithZeroHom`s agree on `-1` and the _positive_ naturals then they are equal. ",
  "args": ""},
 {"type": "Bool",
  "name": "Bool.false",
  "kind": "def",
  "doc_string":
  "The boolean value `false`, not to be confused with the proposition `False`. ",
  "args": ""},
 {"type":
  "{p : ℕ → Sort u} → ((n : ℕ) → ((m : ℕ) → m < n → p m) → p n) → (n : ℕ) → p n",
  "name": "Nat.strongRec'",
  "kind": "def",
  "doc_string": "Recursion principle based on `<`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : LT α] → [hwo : IsWellOrder α fun x x_1 => x < x_1] → WellFoundedRelation α",
  "name": "IsWellOrder.toHasWellFounded",
  "kind": "def",
  "doc_string":
  "Derive a `WellFoundedRelation` instance from a `IsWellOrder` instance. ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : NonAssocSemiring R] → Unique (ℕ →+* R)",
  "name": "Nat.uniqueRingHom",
  "kind": "def",
  "doc_string":
  "We don't use `RingHomClass` here, since that might cause type-class slowdown for\n`Subsingleton`",
  "args": ""},
 {"type":
  "{M : Type uM} → {N : Type uN} → [inst : MulOneClass M] → [inst_1 : CommMonoid N] → M →* (M →* N) →* N",
  "name": "MonoidHom.eval",
  "kind": "def",
  "doc_string":
  "Evaluation of a `MonoidHom` at a point as a monoid homomorphism. See also `MonoidHom.apply`\nfor the evaluation of any function at a point. ",
  "args": ""},
 {"type":
  "∀ {obj : Type u} [self : CategoryTheory.Category obj] {X Y : obj} (f : X ⟶ Y), f ≫ 𝟙 Y = f",
  "name": "CategoryTheory.Category.comp_id",
  "kind": "def",
  "doc_string": "Identity morphisms are right identities for composition. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {A : Type u_2} [inst : Monoid M] [inst_1 : Monoid A] [self : MulDistribMulAction M A] (r : M)\n  (x y : A), r • (x * y) = r • x * r • y",
  "name": "MulDistribMulAction.smul_mul",
  "kind": "def",
  "doc_string": "Distributivity of `•` across `*` ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → {γ : Sort u_3} → {δ : Sort u_4} → α ≃ β → γ ≃ δ → (α ↪ γ) ≃ (β ↪ δ)",
  "name": "Equiv.embeddingCongr",
  "kind": "def",
  "doc_string":
  "If `α₁ ≃ α₂` and `β₁ ≃ β₂`, then the type of embeddings `α₁ ↪ β₁`\nis equivalent to the type of embeddings `α₂ ↪ β₂`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → α × β → β × α",
  "name": "Prod.swap",
  "kind": "def",
  "doc_string": "Swap the factors of a product. `swap (a, b) = (b, a)` ",
  "args": ""},
 {"type": "Type u_1 → (A : Type u_2) → [inst : Zero A] → Type (max u_1 u_2)",
  "name": "SMulZeroClass",
  "kind": "inductive",
  "doc_string":
  "Typeclass for scalar multiplication that preserves `0` on the right. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (β → α → m β) → β → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → m β",
  "name": "Array.foldlMUnsafe",
  "kind": "def",
  "doc_string": "See comment at `forInUnsafe` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {M' : Type u_3} →\n      {N' : Type u_4} →\n        [inst : Mul M] →\n          [inst_1 : Mul N] → [inst_2 : Mul M'] → [inst_3 : Mul N'] → (M →ₙ* M') → (N →ₙ* N') → M × N →ₙ* M' × N'",
  "name": "MulHom.prodMap",
  "kind": "def",
  "doc_string": "`Prod.map` as a `MonoidHom`. ",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : CanonicallyLinearOrderedAddMonoid α], ⊥ = 0",
  "name": "bot_eq_zero'",
  "kind": "theorem",
  "doc_string":
  "In a linearly ordered monoid, we are happy for `bot_eq_zero` to be a `@[simp]` lemma",
  "args": ""},
 {"type":
  "Mathlib.Prelude.Rename.RenameMap → Mathlib.Prelude.Rename.NameEntry → Mathlib.Prelude.Rename.RenameMap",
  "name": "Mathlib.Prelude.Rename.RenameMap.insert",
  "kind": "def",
  "doc_string": "Insert a name entry into the `RenameMap`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MulOneClass M] {s : Set M} {S : Submonoid M}, Submonoid.closure s ≤ S ↔ s ⊆ ↑S",
  "name": "Submonoid.closure_le",
  "kind": "theorem",
  "doc_string":
  "A submonoid `S` includes `closure s` if and only if it includes `s`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "nlinarith",
  "kind": "def",
  "doc_string":
  "An extension of `linarith` with some preprocessing to allow it to solve some nonlinear arithmetic\nproblems. (Based on Coq's `nra` tactic.) See `linarith` for the available syntax of options,\nwhich are inherited by `nlinarith`; that is, `nlinarith!` and `nlinarith only [h1, h2]` all work as\nin `linarith`. The preprocessing is as follows:\n\n* For every subterm `a ^ 2` or `a * a` in a hypothesis or the goal,\n  the assumption `0 ≤ a ^ 2` or `0 ≤ a * a` is added to the context.\n* For every pair of hypotheses `a1 R1 b1`, `a2 R2 b2` in the context, `R1, R2 ∈ {<, ≤, =}`,\n  the assumption `0 R' (b1 - a1) * (b2 - a2)` is added to the context (non-recursively),\n  where `R ∈ {<, ≤, =}` is the appropriate comparison derived from `R1, R2`.\n",
  "args": ""},
 {"type": "{α : Sort u} → PLift α → α",
  "name": "PLift.down",
  "kind": "def",
  "doc_string": "Extract a value from `PLift α` ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → List α → List β → List (α × β)",
  "name": "List.zip",
  "kind": "def",
  "doc_string":
  "`O(min |xs| |ys|)`. Combines the two lists into a list of pairs, with one element from each list.\nThe longer list is truncated to match the shorter list.\n* `zip [x₁, x₂, x₃] [y₁, y₂, y₃, y₄] = [(x₁, y₁), (x₂, y₂), (x₃, y₃)]`\n",
  "args": ""},
 {"type":
  "(A : outParam (Type u)) → {B : Type v} → [inst : HasQuotient A B] → B → Type (max u v)",
  "name": "HasQuotient.Quotient",
  "kind": "def",
  "doc_string":
  "`HasQuotient.Quotient A b` (with notation `A ⧸ b`) is the quotient\nof the type `A` by `b`.\n\nThis differs from `HasQuotient.quotient'` in that the `A` argument is\nexplicit, which is necessary to make Lean show the notation in the\ngoal state.\n",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ [inst : Subsingleton β], Subsingleton α",
  "name": "Function.Injective.subsingleton",
  "kind": "theorem",
  "doc_string":
  "If the codomain of an injective function is a subsingleton, then the domain\nis a subsingleton as well. ",
  "args": ""},
 {"type":
  "{B : Type u_1} → {E : B → Type u_2} → {B' : Type u_3} → (f : B' → B) → Bundle.TotalSpace (f *ᵖ E) → Bundle.TotalSpace E",
  "name": "Bundle.Pullback.lift",
  "kind": "def",
  "doc_string":
  "The base map `f : B' → B` lifts to a canonical map on the total spaces. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HXor α β γ] → α → β → γ",
  "name": "HXor.hXor",
  "kind": "def",
  "doc_string":
  "`a ^^^ b` computes the bitwise XOR of `a` and `b`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} → [inst : PartialOrder α] → [inst_1 : CompleteLattice β] → GaloisCoinsertion l u → CompleteLattice α",
  "name": "GaloisCoinsertion.liftCompleteLattice",
  "kind": "def",
  "doc_string": "Lift all suprema and infima along a Galois coinsertion ",
  "args": ""},
 {"type":
  "{m : Type → Type u_1} →\n  {α : Type u_2} → [inst : Monad m] → Array α → (α → m Mathlib.Tactic.Polyrith.Poly) → m Mathlib.Tactic.Polyrith.Poly",
  "name": "Mathlib.Tactic.Polyrith.Poly.sumM",
  "kind": "def",
  "doc_string":
  "Constructs a sum from a monadic function supplying the monomials. ",
  "args": ""},
 {"type":
  "Bool → (Lean.Name → Option Lean.Name) → (Lean.Name → Option (List ℕ)) → Lean.Expr → Bool",
  "name": "ToAdditive.additiveTest",
  "kind": "def",
  "doc_string":
  "`additiveTest e` tests whether the expression `e` contains no constant\n`nm` that is not applied to any arguments, and such that `translations.find?[nm] = none`.\nThis is used in `@[to_additive]` for deciding which subexpressions to transform: we only transform\nconstants if `additiveTest` applied to their first argument returns `true`.\nThis means we will replace expression applied to e.g. `α` or `α × β`, but not when applied to\ne.g. `Nat` or `ℝ × α`.\nWe ignore all arguments specified by the `ignore` `NameMap`.\nIf `replaceAll` is `true` the test always returns `true`.\n",
  "args": ""},
 {"type":
  "Type u_1 →\n  (M : outParam (Type u_2)) →\n    (N : outParam (Type u_3)) → [inst : MulOneClass M] → [inst : MulOneClass N] → Type (max (max u_1 u_2) u_3)",
  "name": "MonoidHomClass",
  "kind": "inductive",
  "doc_string":
  "`MonoidHomClass F M N` states that `F` is a type of `Monoid`-preserving homomorphisms.\nYou should also extend this typeclass when you extend `MonoidHom`. ",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α β : Type u_1} {q : β → Prop} {x : m α} [inst : Monad m] [inst_1 : LawfulMonad m]\n  {f : α → m β}, SatisfiesM (fun a => SatisfiesM q (f a)) x → SatisfiesM q (x >>= f)",
  "name": "SatisfiesM.bind_pre",
  "kind": "theorem",
  "doc_string":
  "`SatisfiesM` distributes over `>>=`, weakest precondition version. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : SemilatticeInf β] {f g : α → β} {s : Set α},\n  MonotoneOn f s → MonotoneOn g s → MonotoneOn (f ⊓ g) s",
  "name": "MonotoneOn.inf",
  "kind": "theorem",
  "doc_string":
  "Pointwise infimum of two monotone functions is a monotone function. ",
  "args": ""},
 {"type":
  "{a : Lean.Level} →\n  {arg : Q(Type a)} →\n    {sα : Q(CommSemiring «$arg»)} →\n      {a_1 : Q(«$arg»)} →\n        {a_2 : Lean.Level} →\n          {arg_1 : Q(Type a_2)} →\n            {sβ : Q(CommSemiring «$arg_1»)} →\n              Mathlib.Tactic.Ring.ExProd sα a_1 → (a : Q(«$arg_1»)) × Mathlib.Tactic.Ring.ExProd sβ a",
  "name": "Mathlib.Tactic.Ring.ExProd.cast",
  "kind": "opaque",
  "doc_string":
  "Converts `ExProd sα` to `ExProd sβ`, assuming `sα` and `sβ` are defeq. ",
  "args": ""},
 {"type": "Num → Num",
  "name": "Num.bit0",
  "kind": "def",
  "doc_string":
  "`bit0 n` appends a `0` to the end of `n`, where `bit0 n = n0`. ",
  "args": ""},
 {"type": "Sort u → Lean.Syntax → Sort u",
  "name": "autoParam",
  "kind": "def",
  "doc_string":
  "Gadget for automatic parameter support. This is similar to the `optParam` gadget, but it uses\nthe given tactic.\nLike `optParam`, this gadget only affects elaboration.\nFor example, the tactic will *not* be invoked during type class resolution. ",
  "args": ""},
 {"type": "Type",
  "name": "SlimCheck.Configuration",
  "kind": "inductive",
  "doc_string": "Configuration for testing a property. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : LinearOrder β] {f g : α → β} {s : Set α},\n  AntitoneOn f s → AntitoneOn g s → AntitoneOn (fun x => max (f x) (g x)) s",
  "name": "AntitoneOn.max",
  "kind": "theorem",
  "doc_string":
  "Pointwise maximum of two antitone functions is a antitone function. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s t : Set α},\n  BddBelow s → BddBelow t → Set.Nonempty (s ∩ t) → infₛ s ⊔ infₛ t ≤ infₛ (s ∩ t)",
  "name": "le_cinfₛ_inter",
  "kind": "theorem",
  "doc_string":
  "The infimum of an intersection of two sets is bounded below by the maximum of the\ninfima of each set, if all sets are bounded below and nonempty.",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → PLift (α → β) → (Unit → PLift α) → PLift β",
  "name": "PLift.seq",
  "kind": "def",
  "doc_string": "Applicative sequencing. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "CategoryTheory.Iso.«term_≪≫_»",
  "kind": "def",
  "doc_string": "Notation for composition of isomorphisms. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → ℕ → ℕ",
  "name": "List.lengthTRAux",
  "kind": "def",
  "doc_string": "Auxiliary function for `List.lengthTR`. ",
  "args": ""},
 {"type":
  "{X : Type u} →\n  {m₁ : X → X → X} →\n    {e₁ : X} →\n      EckmannHilton.IsUnital m₁ e₁ →\n        [h : AddZeroClass X] → (∀ (a b c d : X), m₁ (a + b) (c + d) = m₁ a c + m₁ b d) → AddCommMonoid X",
  "name": "EckmannHilton.addCommMonoid",
  "kind": "def",
  "doc_string":
  "If a type carries a unital additive magma structure that distributes over a unital binary\noperation, then the additive magma structure is a commutative additive monoid.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : CancelCommMonoidWithZero α] →\n    [inst_1 : DecidableEq α] →\n      (gcd : α → α → α) →\n        (∀ (a b : α), gcd a b ∣ a) →\n          (∀ (a b : α), gcd a b ∣ b) → (∀ {a b c : α}, a ∣ c → a ∣ b → a ∣ gcd c b) → GCDMonoid α",
  "name": "gcdMonoidOfGCD",
  "kind": "def",
  "doc_string":
  "Define `GCDMonoid` on a structure just from the `gcd` and its properties. ",
  "args": ""},
 {"type":
  "{M : Type u} → [inst : AddMonoid M] → (u : AddUnits M) → (x : M) → {n : ℕ} → n ≠ 0 → n • x = ↑u → AddUnits M",
  "name": "AddUnits.ofSMul",
  "kind": "def",
  "doc_string":
  "If a natural multiple of `x` is an additive unit, then `x` is an additive unit.",
  "args": ""},
 {"type":
  "{I : Type u} →\n  {f : I → Type v} →\n    {γ : Type w} →\n      [inst : (i : I) → AddZeroClass (f i)] → [inst_1 : AddZeroClass γ] → ((i : I) → γ →+ f i) → γ →+ (i : I) → f i",
  "name": "Pi.addMonoidHom",
  "kind": "def",
  "doc_string":
  "A family of additive monoid homomorphisms `f a : γ →+ β a` defines a monoid homomorphism\n`Pi.addMonoidHom f : γ →+ Π a, β a` given by `Pi.addMonoidHom f x b = f b x`.",
  "args": ""},
 {"type":
  "(V : Type u) → [inst : Quiver V] → Sort u_2 → Sort (imax (u + 1) (u + 1) u_1 u_2)",
  "name": "Quiver.Labelling",
  "kind": "def",
  "doc_string":
  "An `L`-labelling of a quiver assigns to every arrow an element of `L`. ",
  "args": ""},
 {"type": "∀ {K : Type u} [self : DivisionRing K] (a : K), a ≠ 0 → a * a⁻¹ = 1",
  "name": "DivisionRing.mul_inv_cancel",
  "kind": "def",
  "doc_string": "For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedField α] (n : ℕ) (a : α),\n  LinearOrderedField.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedField.zpow (Int.ofNat n) a",
  "name": "LinearOrderedField.zpow_succ'",
  "kind": "def",
  "doc_string": "`a ^ (n + 1) = a * a ^ n` ",
  "args": ""},
 {"type": "Lean.TagAttribute",
  "name": "Mathlib.Prelude.Rename.binportTag",
  "kind": "opaque",
  "doc_string":
  "The `@[binport]` attribute should not be added manually, it is added automatically by mathport\nto definitions that it created based on a lean 3 definition (as opposed to pre-existing\ndefinitions). ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Sort u_2} [inst : CompleteLattice α] (f : ι → α), (⨆ i, f ↑i) = ⨆ i, f i",
  "name": "supᵢ_ne_bot_subtype",
  "kind": "theorem",
  "doc_string":
  "When taking the supremum of `f : ι → α`, the elements of `ι` on which `f` gives `⊥` can be\ndropped, without changing the result. ",
  "args": ""},
 {"type": "∀ {S₀ : Type u} [self : SemigroupWithZero S₀] (a : S₀), 0 * a = 0",
  "name": "SemigroupWithZero.zero_mul",
  "kind": "def",
  "doc_string": "Zero is a left absorbing element for multiplication ",
  "args": ""},
 {"type":
  "(R : Type u_1) →\n  {M : Type u_2} →\n    {M₂ : Type u_3} →\n      [inst : Semiring R] →\n        [inst_1 : AddCommMonoid M] →\n          [inst_2 : Module R M] →\n            [inst_3 : AddCommMonoid M₂] →\n              [inst_4 : SMul R M₂] →\n                (f : M₂ →+ M) → Function.Injective ↑f → (∀ (c : R) (x : M₂), ↑f (c • x) = c • ↑f x) → Module R M₂",
  "name": "Function.Injective.module",
  "kind": "def",
  "doc_string":
  "Pullback a `Module` structure along an injective additive monoid homomorphism.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    (r : α → α → Prop) →\n      (s : β → β → Prop) →\n        (f : α → β → Prop) →\n          (ha : ∀ (a : α) (b₁ b₂ : β), s b₁ b₂ → f a b₁ = f a b₂) →\n            (hb : ∀ (a₁ a₂ : α) (b : β), r a₁ a₂ → f a₁ b = f a₂ b) →\n              [hf : (a : α) → DecidablePred (f a)] → (q₁ : Quot r) → DecidablePred (Quot.lift₂ f ha hb q₁)",
  "name": "Quot.lift₂.decidablePred",
  "kind": "def",
  "doc_string":
  "Note that this provides `DecidableRel (Quot.Lift₂ f ha hb)` when `α = β`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] [inst_1 : NoMinOrder α] (a : α), ∃ f, StrictAnti f ∧ f 0 = a",
  "name": "Nat.exists_strictAnti'",
  "kind": "theorem",
  "doc_string":
  "If `α` is a preorder with no maximal elements, then there exists a strictly antitone function\n`ℕ → α` with any prescribed value of `f 0`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {a b c d : α} [inst : Preorder α], c ≤ a → b ≤ d → a ≤ b → c ≤ d",
  "name": "le_implies_le_of_le_of_le",
  "kind": "theorem",
  "doc_string": "monotonicity of `≤` with respect to `→` ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Monoid M] {a : Mˣ} {x y : M}, SemiconjBy (↑a) x y → SemiconjBy (↑a⁻¹) y x",
  "name": "SemiconjBy.units_inv_symm_left",
  "kind": "theorem",
  "doc_string":
  "If a unit `a` semiconjugates `x` to `y`, then `a⁻¹` semiconjugates `y` to `x`. ",
  "args": ""},
 {"type": "{α : Type u} → [self : AndOp α] → α → α → α",
  "name": "AndOp.and",
  "kind": "def",
  "doc_string": "The implementation of `a &&& b : α`. See `HAnd`. ",
  "args": ""},
 {"type": "{α : Type u} → [self : Min α] → α → α → α",
  "name": "Min.min",
  "kind": "def",
  "doc_string": "The minimum operation: `min x y`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : LT α] → Prop",
  "name": "NoMinOrder",
  "kind": "inductive",
  "doc_string":
  "Order without minimal elements. Sometimes called coinitial or dense. ",
  "args": ""},
 {"type":
  "{U : Type u_1} → [inst : Quiver U] → {u v u' v' : U} → u = u' → v = v' → (u ⟶ v) → (u' ⟶ v')",
  "name": "Quiver.Hom.cast",
  "kind": "def",
  "doc_string": "Change the endpoints of an arrow using equalities. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, Function.Injective f → ∀ (s : Set α), Set.InjOn f s",
  "name": "Function.Injective.injOn",
  "kind": "theorem",
  "doc_string": "**Alias** of `Set.injOn_of_injective`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CanonicallyLinearOrderedAddMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α] {a b c : α}\n  [inst_3 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], b ≤ a → (a - b < a - c ↔ c < b)",
  "name": "tsub_lt_tsub_iff_left_of_le",
  "kind": "theorem",
  "doc_string":
  "See `lt_tsub_iff_left_of_le_of_le` for a weaker statement in a partial order. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "name": "CovariantClass",
  "kind": "inductive",
  "doc_string":
  "Given an action `μ` of a Type `M` on a Type `N` and a relation `r` on `N`, informally, the\n`CovariantClass` says that \"the action `μ` preserves the relation `r`.\"\n\nMore precisely, the `CovariantClass` is a class taking two Types `M N`, together with an \"action\"\n`μ : M → N → N` and a relation `r : N → N → Prop`.  Its unique field `elim` is the assertion that\nfor all `m ∈ M` and all elements `n₁, n₂ ∈ N`, if the relation `r` holds for the pair\n`(n₁, n₂)`, then, the relation `r` also holds for the pair `(μ m n₁, μ m n₂)`,\nobtained from `(n₁, n₂)` by acting upon it by `m`.\n\nIf `m : M` and `h : r n₁ n₂`, then `CovariantClass.elim m h : r (μ m n₁) (μ m n₂)`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : StrictOrderedCommRing α] (a b : α), a * b = b * a",
  "name": "StrictOrderedCommRing.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, -a < 0 ↔ 0 < a",
  "name": "Left.neg_neg_iff",
  "kind": "theorem",
  "doc_string": "Uses `left` co(ntra)variant.",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {f : α → β} {r : Setoid β}, Setoid.comap f r = Setoid.ker (Quotient.mk'' ∘ f)",
  "name": "Setoid.comap_eq",
  "kind": "theorem",
  "doc_string":
  "Given a map `f : N → M` and an equivalence relation `r` on `β`, the equivalence relation\ninduced on `α` by `f` equals the kernel of `r`'s quotient map composed with `f`. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_3} {G : Type u_1} {H : Type u_2} [inst : AddGroup G] [inst_1 : AddZeroClass H]\n  [inst_2 : AddMonoidHomClass F G H] (f : F), Function.Injective ↑f ↔ ∀ (a : G), ↑f a = 0 ↔ a = 0",
  "name": "injective_iff_map_eq_zero'",
  "kind": "theorem",
  "doc_string":
  "A homomorphism from an additive group to an additive monoid is injective iff its\nkernel is trivial, stated as an iff on the triviality of the kernel. For the implication, see\n`injective_iff_map_eq_zero`.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MulOneClass M] {s : Set M}, s ⊆ ↑(Submonoid.closure s)",
  "name": "Submonoid.subset_closure",
  "kind": "theorem",
  "doc_string": "The submonoid generated by a set includes the set. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : PredOrder α] [inst_2 : IsPredArchimedean α] {P : α → Prop} {m : α},\n  P m → (∀ (n : α), n ≤ m → P n → P (Order.pred n)) → ∀ ⦃n : α⦄, n ≤ m → P n",
  "name": "Pred.rec",
  "kind": "theorem",
  "doc_string":
  "Induction principle on a type with a `PredOrder` for all elements below a given element `m`. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {Z : ι → Type u_2} → [inst : (i : ι) → OrderedCommMonoid (Z i)] → OrderedCommMonoid ((i : ι) → Z i)",
  "name": "Pi.orderedCommMonoid",
  "kind": "def",
  "doc_string":
  "The product of a family of ordered commutative monoids is an ordered commutative monoid. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«tacticPick_goal-_»",
  "kind": "def",
  "doc_string":
  "`pick_goal n` will move the `n`-th goal to the front.\n\n`pick_goal -n` will move the `n`-th goal (counting from the bottom) to the front.\n\nSee also `Tactic.rotate_goals`, which moves goals from the front to the back and vice-versa.\n",
  "args": ""},
 {"type": "Div ℚ",
  "name": "Rat.instDivRat",
  "kind": "def",
  "doc_string": "Division of rational numbers. Note: `div a 0 = 0`. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {α : ι → Type u_2} → [inst : (i : ι) → LE (α i)] → (i : ι) × α i → (i : ι) × α i → Prop",
  "name": "Sigma.le",
  "kind": "inductive",
  "doc_string":
  "Disjoint sum of orders. `⟨i, a⟩ ≤ ⟨j, b⟩` iff `i = j` and `a ≤ b`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "IntCast",
  "kind": "inductive",
  "doc_string": "Type class for the canonical homomorphism `ℤ → R`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} → [inst : Mul M] → [inst_1 : Mul N] → [inst_2 : Mul P] → (M →ₙ* N) → (M →ₙ* P) → M →ₙ* N × P",
  "name": "MulHom.prod",
  "kind": "def",
  "doc_string":
  "Combine two `MonoidHom`s `f : M →ₙ* N`, `g : M →ₙ* P` into\n`f.prod g : M →ₙ* (N × P)` given by `(f.prod g) x = (f x, g x)`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "name": "List.Perm",
  "kind": "inductive",
  "doc_string":
  "`Perm l₁ l₂` or `l₁ ~ l₂` asserts that `l₁` and `l₂` are Permutations\nof each other. This is defined by induction using pairwise swaps. ",
  "args": ""},
 {"type":
  "{I : Type u} →\n  (f : I → Type v) → [inst : DecidableEq I] → [inst : (i : I) → MulZeroClass (f i)] → (i : I) → f i →ₙ* (i : I) → f i",
  "name": "MulHom.single",
  "kind": "def",
  "doc_string":
  "The multiplicative homomorphism including a single `MulZeroClass`\ninto a dependent family of `MulZeroClass`es, as functions supported at a point.\n\nThis is the `MulHom` version of `Pi.single`. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {α : ι → Type u_2} →\n    [inst : PartialOrder ι] →\n      [inst_1 : OrderBot ι] →\n        [inst_2 : (i : ι) → Preorder (α i)] → [inst_3 : OrderBot (α ⊥)] → OrderBot (Lex ((i : ι) × α i))",
  "name": "Sigma.Lex.orderBot",
  "kind": "def",
  "doc_string": "The lexicographical linear order on a sigma type. ",
  "args": ""},
 {"type":
  "∀ {I : Type u} {f : I → Type v₁} [inst : DecidableEq I] [inst_1 : (i : I) → One (f i)] {i i' : I},\n  i ≠ i' → ∀ (x : f i), Pi.mulSingle i x i' = 1",
  "name": "Pi.mulSingle_eq_of_ne'",
  "kind": "theorem",
  "doc_string":
  "Abbreviation for `mulSingle_eq_of_ne h.symm`, for ease of use by `simp`. ",
  "args": ""},
 {"type": "ℕ+ → Prop",
  "name": "PNat.Prime",
  "kind": "def",
  "doc_string":
  "Primality predicate for `ℕ+`, defined in terms of `Nat.Prime`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {T : Type u_3} →\n      [inst : NonUnitalNonAssocSemiring R] →\n        [inst_1 : NonUnitalNonAssocSemiring S] →\n          [inst_2 : NonUnitalNonAssocSemiring T] → (R →ₙ+* S) → (R →ₙ+* T) → R →ₙ+* S × T",
  "name": "NonUnitalRingHom.prod",
  "kind": "def",
  "doc_string":
  "Combine two non-unital ring homomorphisms `f : R →ₙ+* S`, `g : R →ₙ+* T` into\n`f.prod g : R →ₙ+* S × T` given by `(f.prod g) x = (f x, g x)` ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "List",
  "kind": "inductive",
  "doc_string":
  "`List α` is the type of ordered lists with elements of type `α`.\nIt is implemented as a linked list.\n\n`List α` is isomorphic to `Array α`, but they are useful for different things:\n* `List α` is easier for reasoning, and\n  `Array α` is modeled as a wrapper around `List α`\n* `List α` works well as a persistent data structure, when many copies of the\n  tail are shared. When the value is not shared, `Array α` will have better\n  performance because it can do destructive updates.\n",
  "args": ""},
 {"type":
  "{X : Type u_1} → {Y : Type u_2} → [inst : Preorder X] → [inst_1 : Preorder Y] → X ↪o Y → X →o Y",
  "name": "OrderEmbedding.toOrderHom",
  "kind": "def",
  "doc_string": "Convert an `OrderEmbedding` to a `OrderHom`. ",
  "args": ""},
 {"type":
  "ℕ → (chars : List Char) → 0 < List.length chars → SlimCheck.SampleableExt Char",
  "name": "SlimCheck.Char.sampleable",
  "kind": "def",
  "doc_string":
  "This can be specialized into customized `SampleableExt Char` instances.\nThe resulting instance has `1 / length` chances of making an unrestricted choice of characters\nand it otherwise chooses a character from `chars` with uniform probabilities.  ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  a ≤ 1 → b ≤ 1 → a * b ≤ 1",
  "name": "Right.mul_le_one",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_le_one`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} →\n      [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [inst_2 : AddZeroClass P] → (N →+ P) → (M →+ N) → M →+ P",
  "name": "AddMonoidHom.comp",
  "kind": "def",
  "doc_string":
  "Composition of additive monoid morphisms as an additive monoid morphism. ",
  "args": ""},
 {"type": "HeytingAlgebra Prop",
  "name": "Prop.heytingAlgebra",
  "kind": "def",
  "doc_string":
  "Propositions form a Heyting algebra with implication as Heyting implication and negation as\ncomplement. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u₃} → [inst_2 : CategoryTheory.Category E] → (F : C ⥤ D) → {G H : D ⥤ E} → (G ≅ H) → (F ⋙ G ≅ F ⋙ H)",
  "name": "CategoryTheory.isoWhiskerLeft",
  "kind": "def",
  "doc_string":
  "If `α : G ≅ H` is a natural isomorphism then\n`iso_whisker_left F α : (F ⋙ G) ≅ (F ⋙ H)` has components `α.app (F.obj X)`.\n",
  "args": ""},
 {"type":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} → {x : NonAssocSemiring α} → {x_1 : NonAssocSemiring β} → [inst : RingHomClass F α β] → F → α →+* β",
  "name": "RingHomClass.toRingHom",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `RingHomClass F α β` into an actual\n`RingHom`. This is declared as the default coercion from `F` to `α →+* β`. ",
  "args": ""},
 {"type":
  "{M : Type uM} →\n  {N : Type uN} →\n    {P : Type uP} → {mM : AddZeroClass M} → {mN : AddZeroClass N} → {mP : AddCommMonoid P} → (M →+ N →+ P) → N →+ M →+ P",
  "name": "AddMonoidHom.flip",
  "kind": "def",
  "doc_string": "`flip` arguments of `f : M →+ N →+ P`",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Add R] → R → Prop",
  "name": "IsAddLeftRegular",
  "kind": "def",
  "doc_string":
  "An add-left-regular element is an element `c` such that addition\non the left by `c` is injective.",
  "args": ""},
 {"type":
  "∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y Z : C} (f : X ⟶ Y) {g h : Y ⟶ Z}, g = h → f ≫ g = f ≫ h",
  "name": "CategoryTheory.whisker_eq",
  "kind": "theorem",
  "doc_string": "precompose an equation between morphisms by another morphism ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → β → γ) → Option α → Option β → Option γ",
  "name": "Option.map₂",
  "kind": "def",
  "doc_string":
  "The image of a binary function `f : α → β → γ` as a function `Option α → Option β → Option γ`.\nMathematically this should be thought of as the image of the corresponding function `α × β → γ`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "precMax",
  "kind": "def",
  "doc_string":
  "Maximum precedence used in term parsers, in particular for terms in\nfunction position (`ident`, `paren`, ...)\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Preorder M] [inst_1 : Add M] [inst_2 : Sub M] [inst_3 : OrderedSub M]\n  [inst_4 : PartialOrder N] [inst_5 : Add N] [inst_6 : Sub N] [inst_7 : OrderedSub N] (e : M ≃o N),\n  (∀ (a b : M),\n      ↑(RelIso.toRelEmbedding e).toEmbedding (a + b) =\n        ↑(RelIso.toRelEmbedding e).toEmbedding a + ↑(RelIso.toRelEmbedding e).toEmbedding b) →\n    ∀ (a b : M),\n      ↑(RelIso.toRelEmbedding e).toEmbedding (a - b) =\n        ↑(RelIso.toRelEmbedding e).toEmbedding a - ↑(RelIso.toRelEmbedding e).toEmbedding b",
  "name": "OrderIso.map_tsub",
  "kind": "theorem",
  "doc_string":
  "An order isomorphism between types with ordered subtraction preserves subtraction provided that\nit preserves addition. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, 1 < a → 1 < b → 1 < a * b",
  "name": "Left.one_lt_mul'",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul'`. ",
  "args": ""},
 {"type": "{α : Type u} → Set α → Set α → Set α → Set α",
  "name": "Set.ite",
  "kind": "def",
  "doc_string":
  "`ite` for sets: `Set.ite t s s' ∩ t = s ∩ t`, `Set.ite t s s' ∩ tᶜ = s' ∩ tᶜ`.\nDefined as `s ∩ t ∪ s' \\ t`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HAndThen α β γ] → α → (Unit → β) → γ",
  "name": "HAndThen.hAndThen",
  "kind": "def",
  "doc_string":
  "`a >> b` executes `a`, ignores the result, and then executes `b`.\nIf `a` fails then `b` is not executed. Because `b` is not always executed, it\nis passed as a thunk so it can be forced only when needed.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type": "Type → Type u_1 → Type u_1",
  "name": "RandG",
  "kind": "def",
  "doc_string":
  "A monad to generate random objects using the generic generator type `g` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (β : α → Type u_2) → (i : α) ×' β i ≃ (i : α) × β i",
  "name": "Equiv.psigmaEquivSigma",
  "kind": "def",
  "doc_string":
  "A `PSigma`-type is equivalent to the corresponding `Sigma`-type. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} {o p : Part α}, (∀ (a : α), a ∈ o ↔ a ∈ p) → o = p",
  "name": "Part.ext",
  "kind": "theorem",
  "doc_string": "`Part` extensionality ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → (sα : Q(CommSemiring «$α»)) → ℕ → (e : Q(«$α»)) × Mathlib.Tactic.Ring.ExProd sα e",
  "name": "Mathlib.Tactic.Ring.ExProd.mkNat",
  "kind": "def",
  "doc_string":
  "Constructs the expression corresponding to `.const n`.\n(The `.const` constructor does not check that the expression is correct.)\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → (ℕ → α → m β) → List α → Array β → m (List β)",
  "name": "List.mapIdxM.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `mapIdxM`:\n`mapIdxM.go as f acc = acc.toList ++ [← f acc.size a₀, ← f (acc.size + 1) a₁, ...]` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → {δ : Type u_4} → (γ → δ) → (α → β → γ) → α → β → δ",
  "name": "Function.bicompr",
  "kind": "def",
  "doc_string": "Compose an unary function `f` with a binary function `g`. ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.GeneralizeProofs.State → List (Lean.TSyntax `Lean.binderIdent)",
  "name": "Mathlib.Tactic.GeneralizeProofs.State.nextIdx",
  "kind": "def",
  "doc_string": "The user provided names, may be anonymous ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : GeneralizedHeytingAlgebra α] (a : α), a ≤ ⊤",
  "name": "GeneralizedHeytingAlgebra.le_top",
  "kind": "def",
  "doc_string": "`⊤` is a greatest element ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} → [inst : MulOneClass α] → [inst_1 : AddZeroClass β] → (α →* Multiplicative β) ≃ (Additive α →+ β)",
  "name": "MonoidHom.toAdditive'",
  "kind": "def",
  "doc_string": "Reinterpret `α →* Multiplicative β` as `Additive α →+ β`. ",
  "args": ""},
 {"type":
  "{t : Type u → Type u} →\n  [self : Traversable t] → {m : Type u → Type u} → [inst : Applicative m] → {α β : Type u} → (α → m β) → t α → m (t β)",
  "name": "Traversable.traverse",
  "kind": "def",
  "doc_string":
  "The function commuting a traversable functor `t` with an arbitrary applicative functor `m`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] {a b : α}, a < b → (¬a ⋖ b ↔ ∃ c, a < c ∧ c < b)",
  "name": "not_covby_iff",
  "kind": "theorem",
  "doc_string":
  "If `a < b`, then `b` does not cover `a` iff there's an element in between. ",
  "args": ""},
 {"type":
  "∀ {ι : Type u_3} {M : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → SMul M (α i)] (i : ι)\n  [inst_1 : FaithfulSMul M (α i)], FaithfulSMul M ((i : ι) × α i)",
  "name": "Sigma.FaithfulSMul'",
  "kind": "theorem",
  "doc_string": "This is not an instance because `i` becomes a metavariable. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      {r : α → α → Prop} →\n        {s : β → β → Prop} →\n          {t : γ → γ → Prop} → [inst : IsWellOrder β s] → [inst : IsTrans γ t] → r ≼i s → s ≺i t → r ≺i t",
  "name": "InitialSeg.leLT",
  "kind": "def",
  "doc_string":
  "Composition of an initial segment taking values in a well order and a principal segment. ",
  "args": ""},
 {"type": "ℚ → ℕ",
  "name": "Rat.den",
  "kind": "def",
  "doc_string": "The denominator of the rational number is a natural number. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      [inst : Preorder α] → [inst_1 : Preorder β] → [inst_2 : Preorder γ] → (α →o β × γ) ≃o (α →o β) × (α →o γ)",
  "name": "OrderHom.prodIso",
  "kind": "def",
  "doc_string":
  "Order isomorphism between the space of monotone maps to `β × γ` and the product of the spaces\nof monotone maps to `β` and `γ`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → α → α × BinaryHeap α lt",
  "name": "BinaryHeap.insertExtractMax",
  "kind": "def",
  "doc_string":
  "`O(log n)`. Equivalent to `extractMax (self.insert x)`, except that extraction cannot fail. ",
  "args": ""},
 {"type":
  "∀ {I : Type u} {α : Type u_1} {β : Type u_2} [inst : Monoid α] [inst_1 : AddMonoid β] [inst_2 : DistribMulAction α β]\n  [inst_3 : DecidableEq I] (i : I) (r : α) (x : β), Pi.single i (r • x) = r • Pi.single i x",
  "name": "Pi.single_smul'",
  "kind": "theorem",
  "doc_string":
  "A version of `Pi.single_smul` for non-dependent functions. It is useful in cases where Lean\nfails to apply `Pi.single_smul`. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : MulOneClass M] → Submonoid M → Set M",
  "name": "Submonoid.Simps.coe",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type": "PosNum → PosNum → Ordering",
  "name": "PosNum.cmp",
  "kind": "def",
  "doc_string": "Ordering of `PosNum`s. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (n : ℕ) (a : α),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹",
  "name": "LinearOrderedCommGroupWithZero.zpow_neg'",
  "kind": "def",
  "doc_string": "`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` ",
  "args": ""},
 {"type": "(A : Type u_1) → [inst : Add A] → AddAut A →* Equiv.Perm A",
  "name": "AddAut.toPerm",
  "kind": "def",
  "doc_string":
  "Monoid hom from the group of multiplicative automorphisms to the group of permutations. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "CategoryTheory.«term𝟙»",
  "kind": "def",
  "doc_string": "Notation for the identity morphism in a category. ",
  "args": ""},
 {"type":
  "{p q : Prop} → SlimCheck.TestResult p → SlimCheck.TestResult q → SlimCheck.TestResult (p ∨ q)",
  "name": "SlimCheck.TestResult.or",
  "kind": "def",
  "doc_string":
  "Combine the test result for properties `p` and `q` to create a test for their disjunction. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} → [inst : NonUnitalCommSemiring R] → [inst : NonUnitalCommSemiring S] → NonUnitalCommSemiring (R × S)",
  "name": "Prod.instNonUnitalCommSemiringProd",
  "kind": "def",
  "doc_string":
  "Product of two `NonUnitalCommSemiring`s is a `NonUnitalCommSemiring`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "termIfThenElse",
  "kind": "def",
  "doc_string":
  "`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false.\n\nBecause lean uses a strict (call-by-value) evaluation strategy, the signature of this\nfunction is problematic in that it would require `t` and `e` to be evaluated before\ncalling the `ite` function, which would cause both sides of the `if` to be evaluated.\nEven if the result is discarded, this would be a big performance problem,\nand is undesirable for users in any case. To resolve this, `ite` is marked as\n`@[macro_inline]`, which means that it is unfolded during code generation, and\nthe definition of the function uses `fun _ => t` and `fun _ => e` so this recovers\nthe expected \"lazy\" behavior of `if`: the `t` and `e` arguments delay evaluation\nuntil `c` is known.\n",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} →\n  {β : Type u_1} →\n    {ρ : Type u_3} →\n      {α : Type u_4} →\n        [inst : Monad m] → [inst : ForM (StateT β (ExceptT β m)) ρ α] → ρ → β → (α → β → m (ForInStep β)) → m β",
  "name": "ForM.forIn",
  "kind": "def",
  "doc_string": "Adapter to create a ForIn instance from a ForM instance ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α},\n  a < 0 → b ≤ 0 → a + b < 0",
  "name": "Right.add_neg_of_neg_of_nonpos",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg_of_neg_of_nonpos`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [self : PredOrder α] {a : α}, a ≤ PredOrder.pred a → IsMin a",
  "name": "PredOrder.min_of_le_pred",
  "kind": "def",
  "doc_string": "Proof of interaction between `pred` and minimal element",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        (F : C → D) → [inst_2 : CategoryTheory.Functorial F] → {X Y : C} → (X ⟶ Y) → (F X ⟶ F Y)",
  "name": "CategoryTheory.map",
  "kind": "def",
  "doc_string":
  "If `F : C → D` (just a function) has `[Functorial F]`,\nwe can write `map F f : F X ⟶ F Y` for the action of `F` on a morphism `f : X ⟶ Y`.\n",
  "args": ""},
 {"type": "(α : Type v) → [inst : Small α] → Type w",
  "name": "Shrink",
  "kind": "def",
  "doc_string":
  "An arbitrarily chosen model in `Type w` for a `w`-small type.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  StrictMono f → StrictAnti (↑OrderDual.toDual ∘ f)",
  "name": "StrictMono.dual_right",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `strictAnti_toDual_comp_iff`.",
  "args": ""},
 {"type":
  "∀ {G : Type u} [inst : Mul G] [self : IsRightCancelMul G] (a b c : G), a * b = c * b → a = c",
  "name": "IsRightCancelMul.mul_right_cancel",
  "kind": "def",
  "doc_string": "Multiplication is right cancellative. ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.Context →\n  Lean.Expr × ℤ → Lean.Expr → Mathlib.Tactic.Abel.NormalExpr → Mathlib.Tactic.Abel.NormalExpr",
  "name": "Mathlib.Tactic.Abel.NormalExpr.term'",
  "kind": "def",
  "doc_string": "Construct the normal form representing a single term. ",
  "args": ""},
 {"type":
  "{α₁ : Type u_1} → {α₂ : Sort u_2} → {β₁ : Type u_3} → {β₂ : Sort u_4} → α₁ ≃ α₂ → β₁ ≃ β₂ → α₁ ⊕ β₁ ≃ α₂ ⊕' β₂",
  "name": "Equiv.sumPSum",
  "kind": "def",
  "doc_string":
  "Combine two `Equiv`s using `Sum` in the domain and `PSum` in the codomain. ",
  "args": ""},
 {"type":
  "∀ {G : Type u} [self : DivInvMonoid G] (n : ℕ) (a : G),\n  DivInvMonoid.zpow (Int.negSucc n) a = (DivInvMonoid.zpow (↑(Nat.succ n)) a)⁻¹",
  "name": "DivInvMonoid.zpow_neg'",
  "kind": "def",
  "doc_string": "`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CompleteSemilatticeInf",
  "kind": "inductive",
  "doc_string":
  "Note that we rarely use `CompleteSemilatticeInf`\n(in fact, any such object is always a `CompleteLattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions.\n",
  "args": ""},
 {"type": "∀ (p : True → Prop), (∃ x, p x) ↔ p True.intro",
  "name": "exists_true_left",
  "kind": "theorem",
  "doc_string": "See `IsEmpty.exists_iff` for the `false` version. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  (p₁ : α → Prop) →\n    [s₁ : Setoid α] →\n      [s₂ : Setoid (Subtype p₁)] →\n        (p₂ : Quotient s₁ → Prop) →\n          (∀ (a : α), p₁ a ↔ p₂ (Quotient.mk s₁ a)) →\n            (∀ (x y : Subtype p₁), Setoid.r x y ↔ ↑x ≈ ↑y) → { x // p₂ x } ≃ Quotient s₂",
  "name": "Equiv.subtypeQuotientEquivQuotientSubtype",
  "kind": "def",
  "doc_string":
  "Subtype of the quotient is equivalent to the quotient of the subtype. Let `α` be a setoid with\nequivalence relation `~`. Let `p₂` be a predicate on the quotient type `α/~`, and `p₁` be the lift\nof this predicate to `α`: `p₁ a ↔ p₂ ⟦a⟧`. Let `~₂` be the restriction of `~` to `{x // p₁ x}`.\nThen `{x // p₂ x}` is equivalent to the quotient of `{x // p₁ x}` by `~₂`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "DivisionRing",
  "kind": "inductive",
  "doc_string":
  "A `DivisionRing` is a `Ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionRing K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nIf the division ring has positive characteristic p, we define `ratCast (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `ratCast` and `qsmul` are needed to implement the\n`algebraRat [DivisionRing K] : Algebra ℚ K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also Note [forgetful inheritance].\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Lattice",
  "kind": "inductive",
  "doc_string":
  "A lattice is a join-semilattice which is also a meet-semilattice. ",
  "args": ""},
 {"type": "ℕ+ → ℕ+ → Prop",
  "name": "PNat.Coprime",
  "kind": "def",
  "doc_string": "Two pnats are coprime if their gcd is 1. ",
  "args": ""},
 {"type":
  "{I : Type u} →\n  {f : I → Type v} →\n    {γ : Type w} →\n      [inst : (i : I) → NonUnitalNonAssocSemiring (f i)] →\n        [inst_1 : NonUnitalNonAssocSemiring γ] → ((i : I) → γ →ₙ+* f i) → γ →ₙ+* (i : I) → f i",
  "name": "Pi.nonUnitalRingHom",
  "kind": "def",
  "doc_string":
  "A family of non-unital ring homomorphisms `f a : γ →ₙ+* β a` defines a non-unital ring\nhomomorphism `Pi.nonUnitalRingHom f : γ →+* Π a, β a` given by\n`Pi.nonUnitalRingHom f x b = f b x`. ",
  "args": ""},
 {"type": "∀ {m n k : ℕ}, m % k = n % k → (m - n) % k = 0",
  "name": "Nat.sub_mod_eq_zero_of_mod_eq",
  "kind": "theorem",
  "doc_string": "If `m` and `n` are equal mod `k`, `m - n` is zero mod `k`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} {δ : Type u_1} {g g' : α → β → γ → δ} {s : Set α} {t : Set β}\n  {u : Set γ}, (∀ (a : α) (b : β) (c : γ), g a b c = g' a b c) → Set.image3 g s t u = Set.image3 g' s t u",
  "name": "Set.image3_congr'",
  "kind": "theorem",
  "doc_string": "A common special case of `image3_congr` ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : Mul M] → [inst_1 : Mul N] → M × N →ₙ* M",
  "name": "MulHom.fst",
  "kind": "def",
  "doc_string":
  "Given magmas `M`, `N`, the natural projection homomorphism from `M × N` to `M`.",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  [inst : AddGroup G] →\n    {H : Type u_2} → [inst_1 : AddGroup H] → (f : G → H) → (∀ (a b : G), f (a + -b) = f a + -f b) → G →+ H",
  "name": "AddMonoidHom.ofMapAddNeg",
  "kind": "def",
  "doc_string":
  "Makes an additive group homomorphism from a proof that the map preserves\nthe operation `fun a b => a + -b`. See also `AddMonoidHom.ofMapSub` for a version using\n`fun a b => a - b`.",
  "args": ""},
 {"type":
  "∀ {R : Type u_2} {G : Type u_1} [inst : Group G] [inst_1 : MulAction G R] (g : G), IsSMulRegular R g",
  "name": "isSMulRegular_of_group",
  "kind": "theorem",
  "doc_string":
  "An element of a group acting on a Type is regular. This relies on the availability\nof the inverse given by groups, since there is no `LeftCancelSMul` typeclass. ",
  "args": ""},
 {"type": "(Bool → Bool → Bool) → ℕ → ℕ → ℕ",
  "name": "Nat.bitwise'",
  "kind": "def",
  "doc_string":
  "`Nat.bitwise'` (different from `Nat.bitwise` in Lean 4 core)\napplies the function `f` to pairs of bits in the same position in\nthe binary representations of its inputs. ",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → {s : Setoid α} → (f : α → β) → (∀ (a b : α), a ≈ b → f a = f b) → Quotient s → β",
  "name": "Quotient.lift",
  "kind": "def",
  "doc_string":
  "The analogue of `Quot.lift`: if `f : α → β` respects the equivalence relation `≈`,\nthen it lifts to a function on `Quotient s` such that `lift f h (mk a) = f a`.\n",
  "args": ""},
 {"type": "{C : Fin2 0 → Sort u} → (i : Fin2 0) → C i",
  "name": "Fin2.elim0",
  "kind": "def",
  "doc_string":
  "Ex falso. The dependent eliminator for the empty `Fin2 0` type. ",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableRel fun x x_1 => x ≤ x_1",
  "name": "LinearOrderedSemiring.decidable_le",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "{α : Type u} → List α → List (ℕ × α)",
  "name": "List.enum",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `enum l` pairs up each element with its index in the list.\n* `enum [a, b, c] = [(0, a), (1, b), (2, c)]`\n",
  "args": ""},
 {"type": "∀ {M : Type u} [self : MulOneClass M] (a : M), a * 1 = a",
  "name": "MulOneClass.mul_one",
  "kind": "def",
  "doc_string": "One is a right neutral element for multiplication ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {R' : Type u_2} →\n    {S : Type u_3} →\n      {S' : Type u_4} →\n        [inst : NonAssocSemiring R] →\n          [inst_1 : NonAssocSemiring S] →\n            [inst_2 : NonAssocSemiring R'] →\n              [inst_3 : NonAssocSemiring S'] → (R →+* R') → (S →+* S') → R × S →+* R' × S'",
  "name": "RingHom.prodMap",
  "kind": "def",
  "doc_string": "`Prod.map` as a `RingHom`. ",
  "args": ""},
 {"type": "{α : Type v} → (P : α → Prop) → (i : α) ×' P i ≃ Subtype P",
  "name": "Equiv.psigmaEquivSubtype",
  "kind": "def",
  "doc_string": "A `PSigma` with `Prop` fibers is equivalent to the subtype.  ",
  "args": ""},
 {"type": "∀ {a b c : Prop}, (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c",
  "name": "or_and_right",
  "kind": "theorem",
  "doc_string": "`∧` distributes over `∨` (on the right). ",
  "args": ""},
 {"type": "∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ (x : α), r x x",
  "name": "Equivalence.refl",
  "kind": "def",
  "doc_string": "An equivalence relation is reflexive: `x ~ x` ",
  "args": ""},
 {"type": "Lean.Elab.Command.CommandElab",
  "name": "Tactic.Alias.elabAliasLR",
  "kind": "def",
  "doc_string": "Elaborates an `alias ↔` command. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] {a b : α} [inst_1 : DenselyOrdered α], ¬a ⋖ b",
  "name": "not_covby",
  "kind": "theorem",
  "doc_string": "In a dense order, nothing covers anything. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : Add α] → [inst_1 : Add β] → AddHom α β → (I : Type u_3) → AddHom (I → α) (I → β)",
  "name": "AddHom.compLeft",
  "kind": "def",
  "doc_string":
  "Additive semigroup homomorphism between the function spaces `I → α` and `I → β`, induced by\nan additive semigroup homomorphism `f` between `α` and `β`",
  "args": ""},
 {"type":
  "∀ (b : ℕ), 2 ≤ b → ∀ (f n e : ℕ), n < b ^ e → 0 < e → List.length (Nat.toDigitsCore b f n []) ≤ e",
  "name": "Nat.to_digits_core_length",
  "kind": "theorem",
  "doc_string":
  "The String representation produced by toDigitsCore has the proper length relative to\nthe number of digits in `n < e` for some base `b`. Since this works with any base greater\nthan one, it can be used for binary, decimal, and hex. ",
  "args": ""},
 {"type":
  "(ε : Type u) → {m : Type v → Type w} → [inst : MonadExceptOf ε m] → {α : Type v} → ε → m α",
  "name": "throwThe",
  "kind": "def",
  "doc_string":
  "This is the same as `throw`, but allows specifying the particular error type\nin case the monad supports throwing more than one type of error.\n",
  "args": ""},
 {"type": "Lean.Elab.Tactic.Tactic",
  "name": "Mathlib.Tactic.Abel.elabAbelNFConv",
  "kind": "def",
  "doc_string": "Elaborator for the `abel_nf` tactic. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  {D : Type u₂} →\n    [inst : CategoryTheory.Category C] →\n      [inst_1 : CategoryTheory.Category D] → (F : C ⥤ D) → CategoryTheory.Functor.EssImageSubcategory F ⥤ D",
  "name": "CategoryTheory.Functor.essImageInclusion",
  "kind": "def",
  "doc_string":
  "The essential image as a subcategory has a fully faithful inclusion into the target category. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b c : α} [inst : LinearOrder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α]\n  [inst_3 : OrderedSub α] [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  a - b < a - c → c < b",
  "name": "lt_of_tsub_lt_tsub_left",
  "kind": "theorem",
  "doc_string":
  "See `lt_of_tsub_lt_tsub_left_of_le` for a weaker statement in a partial order. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {ι : Type u_1} [inst : Nonempty ι] (s : Set α) (f : α → ι),\n  (Set.Pairwise s fun x y => f x = f y) ↔ ∃ z, ∀ (x : α), x ∈ s → f x = z",
  "name": "Set.pairwise_eq_iff_exists_eq",
  "kind": "theorem",
  "doc_string":
  "A function `f : α → ι` with nonempty codomain takes pairwise equal values on a set `s` if and\nonly if for some `z` in the codomain, `f` takes value `z` on all `x ∈ s`. See also\n`Set.Nonempty.pairwise_eq_iff_exists_eq` for a version that assumes `Set.Nonempty s` instead of\n`[Nonempty ι]`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → α → α → Prop",
  "name": "Wcovby",
  "kind": "def",
  "doc_string":
  "`Wcovby a b` means that `a = b` or `b` covers `a`.\nThis means that `a ≤ b` and there is no element in between.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_3} [inst : Lattice α] [inst_1 : IsModularLattice α] {β : Type u_1} {γ : Type u_2}\n  [inst_2 : PartialOrder β] [inst_3 : Preorder γ],\n  (WellFounded fun x x_1 => x < x_1) →\n    (WellFounded fun x x_1 => x < x_1) →\n      ∀ (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ),\n        GaloisCoinsertion f₁ f₂ →\n          GaloisInsertion g₂ g₁ →\n            (∀ (a : α), f₁ (f₂ a) = a ⊓ K) → (∀ (a : α), g₁ (g₂ a) = a ⊔ K) → WellFounded fun x x_1 => x < x_1",
  "name": "wellFounded_lt_exact_sequence",
  "kind": "theorem",
  "doc_string":
  "A generalization of the theorem that if `N` is a submodule of `M` and\n`N` and `M / N` are both Artinian, then `M` is Artinian. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] {a : αᵒᵈ}, IsBot a → IsTop (↑OrderDual.ofDual a)",
  "name": "IsBot.ofDual",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `isTop_ofDual_iff`.",
  "args": ""},
 {"type": "ZNum → ZNum",
  "name": "ZNum.bitm1",
  "kind": "def",
  "doc_string":
  "`bitm1 x` appends a `1` to the end of `x`, mapping `x` to `2 * x - 1`. ",
  "args": ""},
 {"type": "Lean.Elab.Tactic.Tactic",
  "name": "Mathlib.Tactic.elabNormNumConv",
  "kind": "def",
  "doc_string": "Elaborator for `norm_num` conv tactic. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : AddMonoid M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [inst : AddSubmonoidClass A M] → (S : A) → AddMonoid { x // x ∈ S }",
  "name": "AddSubmonoidClass.toAddMonoid",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of an `AddMonoid` inherits an `AddMonoid` structure.",
  "args": ""},
 {"type": "{α : Type u_1} → α ≃ αᵒᵈ",
  "name": "OrderDual.toDual",
  "kind": "def",
  "doc_string":
  "`toDual` is the identity function to the `OrderDual` of a linear order.  ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : AddZeroClass α]\n  [inst_3 : AddZeroClass β] (self : α →+o β), Monotone ↑↑self.toAddMonoidHom",
  "name": "OrderAddMonoidHom.monotone'",
  "kind": "def",
  "doc_string": "An `OrderAddMonoidHom` is a monotone function. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "boolIfThenElse",
  "kind": "def",
  "doc_string":
  "`cond b x y` is the same as `if b then x else y`, but optimized for a\nboolean condition. It can also be written as `bif b then x else y`.\nThis is `@[macro_inline]` because `x` and `y` should not\nbe eagerly evaluated (see `ite`).\n",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a",
  "name": "Commute.symm",
  "kind": "theorem",
  "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ 1 → b ≤ 1 → a * b ≤ 1",
  "name": "Left.mul_le_one",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_le_one`. ",
  "args": ""},
 {"type": "{α : Type u_1} → PartialOrder (Part α)",
  "name": "Part.instPartialOrderPart",
  "kind": "def",
  "doc_string":
  "We give `Part α` the order where everything is greater than `none`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CompleteLattice α] [self : IsCoatomistic α] (b : α),\n  ∃ s, b = infₛ s ∧ ∀ (a : α), a ∈ s → IsCoatom a",
  "name": "IsCoatomistic.eq_infₛ_coatoms",
  "kind": "def",
  "doc_string": "Every element is a `infₛ` of a set of coatoms. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (r : Setoid α) → { f // r ≤ Setoid.ker f } ≃ (Quotient r → β)",
  "name": "Setoid.liftEquiv",
  "kind": "def",
  "doc_string":
  "Equivalence between functions `α → β` such that `r x y → f x = f y` and functions\n`quotient r → β`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → α → α → Set α",
  "name": "Set.Ico",
  "kind": "def",
  "doc_string": "Left-closed right-open interval ",
  "args": ""},
 {"type": "{α : Type u_1} → (p : Prop) → (o : Part α) → (p → o.Dom) → Part α",
  "name": "Part.restrict",
  "kind": "def",
  "doc_string":
  "`restrict p o h` replaces the domain of `o` with `p`, and is well defined when\n`p` implies `o` is defined. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Mul α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {b c : α}, b < c → ∀ (a : α), a * b < a * c",
  "name": "OrderedCommGroup.mul_lt_mul_left'",
  "kind": "theorem",
  "doc_string": "**Alias** of `mul_lt_mul_left'`.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Option",
  "kind": "inductive",
  "doc_string":
  "`Option α` is the type of values which are either `some a` for some `a : α`,\nor `none`. In functional programming languages, this type is used to represent\nthe possibility of failure, or sometimes nullability.\n\nFor example, the function `HashMap.find? : HashMap α β → α → Option β` looks up\na specified key `a : α` inside the map. Because we do not know in advance\nwhether the key is actually in the map, the return type is `Option β`, where\n`none` means the value was not in the map, and `some b` means that the value\nwas found and `b` is the value retrieved.\n\nTo extract a value from an `Option α`, we use pattern matching:\n```\ndef map (f : α → β) (x : Option α) : Option β :=\n  match x with\n  | some a => some (f a)\n  | none => none\n```\nWe can also use `if let` to pattern match on `Option` and get the value\nin the branch:\n```\ndef map (f : α → β) (x : Option α) : Option β :=\n  if let some a := x then\n    some (f a)\n  else\n    none\n```\n",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → (β → δ) → (α → β) → α → δ",
  "name": "Function.comp",
  "kind": "def",
  "doc_string":
  "Function composition is the act of pipelining the result of one function, to the input of another, creating an entirely new function.\nExample:\n```\n#eval Function.comp List.reverse (List.drop 2) [3, 2, 4, 1]\n-- [1, 4]\n```\nYou can use the notation `f ∘ g` as shorthand for `Function.comp f g`.\n```\n#eval (List.reverse ∘ List.drop 2) [3, 2, 4, 1]\n-- [1, 4]\n```\nA simpler way of thinking about it, is that `List.reverse ∘ List.drop 2`\nis equivalent to `fun xs => List.reverse (List.drop 2 xs)`,\nthe benefit is that the meaning of composition is obvious,\nand the representation is compact.\n",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (e : Q(«$α»)) →\n      (_inst : autoParam Q(AddMonoidWithOne «$α») _auto✝) →\n        Lean.MetaM ((lit : Q(ℕ)) × Q(Mathlib.Meta.NormNum.IsNat «$e» «$lit»))",
  "name": "Mathlib.Meta.NormNum.deriveNat",
  "kind": "def",
  "doc_string":
  "Run each registered `norm_num` extension on a typed expression `e : α`,\nreturning a typed expression `lit : ℕ`, and a proof of `isNat e lit`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {a b : α}, 0 < a → 0 < b → (a⁻¹ < b ↔ b⁻¹ < a)",
  "name": "inv_lt",
  "kind": "theorem",
  "doc_string":
  "In a linear ordered field, for positive `a` and `b` we have `a⁻¹ < b ↔ b⁻¹ < a`.\nSee also `inv_lt_of_inv_lt` for a one-sided implication with one fewer assumption. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddMonoid R] {a b : R}, b + a = 0 → IsAddLeftRegular a",
  "name": "isAddLeftRegular_of_add_eq_zero",
  "kind": "theorem",
  "doc_string":
  "An element admitting a left additive opposite is add-left-regular.",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "List.«term_<:+__1»",
  "kind": "def",
  "doc_string": "Notation for `List.isSuffix`\n",
  "args": ""},
 {"type":
  "Lean.MVarId →\n  Lean.Meta.Simp.Context →\n    Array Lean.FVarId → optParam Bool true → optParam Bool true → Lean.MetaM (Option (Array Lean.FVarId × Lean.MVarId))",
  "name": "Mathlib.Meta.NormNum.normNumAt",
  "kind": "def",
  "doc_string":
  "The core of `norm_num` as a tactic in `MetaM`.\n\n* `g`: The goal to simplify\n* `ctx`: The simp context, constructed by `mkSimpContext` and\n  containing any additional simp rules we want to use\n* `fvarIdsToSimp`: The selected set of hypotheses used in the location argument\n* `simplifyTarget`: true if the target is selected in the location argument\n* `useSimp`: true if we used `norm_num` instead of `norm_num1`\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} (r s : α → α → Prop) [inst : IsNonstrictStrictOrder α r s] {a b : α}, s a b ↔ r a b ∧ ¬r b a",
  "name": "right_iff_left_not_left_of",
  "kind": "theorem",
  "doc_string":
  "A version of `right_iff_left_not_left` with explicit `r` and `s`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Mul α] → [inst_1 : Mul β] → α ≃* β ≃ (αᵐᵒᵖ ≃* βᵐᵒᵖ)",
  "name": "MulEquiv.op",
  "kind": "def",
  "doc_string":
  "A iso `α ≃* β` can equivalently be viewed as an iso `αᵐᵒᵖ ≃* βᵐᵒᵖ`. ",
  "args": ""},
 {"type": "Lean.Name → String → Bool → Lean.Name",
  "name": "updateName",
  "kind": "def",
  "doc_string":
  "`updateName nm s is_prefix` adds `s` to the last component of `nm`,\neither as prefix or as suffix (specified by `isPrefix`), separated by `_`.\nUsed by `simps_add_projections`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : LT α] →\n    [inst_1 : WellFoundedLT α] → {C : α → Sort u_1} → ((x : α) → ((y : α) → y < x → C y) → C x) → (x : α) → C x",
  "name": "WellFoundedLT.fix",
  "kind": "def",
  "doc_string":
  "Creates data, given a way to generate a value from all that compare as lesser. See also\n`WellFoundedLT.fix_eq`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "to_additiveRest",
  "kind": "def",
  "doc_string": "Remaining arguments of `to_additive`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Zero R] [inst_1 : Zero M] [inst_2 : SMul R M] [self : NoZeroSMulDivisors R M]\n  {c : R} {x : M}, c • x = 0 → c = 0 ∨ x = 0",
  "name": "NoZeroSMulDivisors.eq_zero_or_eq_zero_of_smul_eq_zero",
  "kind": "def",
  "doc_string":
  "If scalar multiplication yields zero, either the scalar or the vector was zero. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.tacticReplace_",
  "kind": "def",
  "doc_string":
  "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {xs : List α} {ys : List β} {x : α} {y : β}, (x, y) ∈ xs ×ˢ ys ↔ x ∈ xs ∧ y ∈ ys",
  "name": "List.pair_mem_product",
  "kind": "theorem",
  "doc_string":
  "List.prod satisfies a specification of cartesian product on lists. ",
  "args": ""},
 {"type":
  "{C : Type u} → [inst : CategoryTheory.Category C] → {X Y : C} → (X ≅ Y) → (Y ⟶ X)",
  "name": "CategoryTheory.Iso.inv",
  "kind": "def",
  "doc_string": "The backwards direction of an isomorphism. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [inst : Preorder α] {a : α}, Nonempty ↑(Set.Ici a)",
  "name": "Set.nonempty_Ici_subtype",
  "kind": "def",
  "doc_string": "An interval `Ici a` is nonempty. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {n m : ℕ} (v : Vector α n) (w : Vector α m),\n  Vector.toList (Vector.append v w) = Vector.toList v ++ Vector.toList w",
  "name": "Vector.toList_append",
  "kind": "theorem",
  "doc_string":
  "Appending of vectors corresponds under `toList` to appending of lists. ",
  "args": ""},
 {"type": "Linarith.LinarithConfig → Lean.Meta.TransparencyMode",
  "name": "Linarith.LinarithConfig.transparency",
  "kind": "def",
  "doc_string":
  "Transparency mode for identifying atomic expressions in comparisons. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : AddMonoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 0 = 0 →\n                  (∀ (x y : M₁), f (x + y) = f x + f y) → (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) → AddMonoid M₁",
  "name": "Function.Injective.addMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `0` and `+` is an additive monoid, if it admits an\ninjective map that preserves `0` and `+` to an additive monoid. See note\n[reducible non-instances].",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a : Q(«$α»)} →\n        {b : Q(ℕ)} →\n          Mathlib.Tactic.Ring.ExSum sα a →\n            Mathlib.Tactic.Ring.ExSum Mathlib.Tactic.Ring.sℕ b →\n              Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExSum sα) q(«$a» ^ «$b»)",
  "name": "Mathlib.Tactic.Ring.evalPow",
  "kind": "def",
  "doc_string":
  "Exponentiates two polynomials `va, vb`.\n\n* `a ^ 0 = 1`\n* `a ^ (b₁ + b₂) = a ^ b₁ * a ^ b₂`\n",
  "args": ""},
 {"type": "{gen : Type u} → [inst : RandomGen gen] → gen → ℕ → ℕ → ℕ × gen",
  "name": "randNat",
  "kind": "def",
  "doc_string": "Generate a random natural number in the interval [lo, hi]. ",
  "args": ""},
 {"type":
  "{p q : Prop} → [inst : Decidable p] → [inst : Decidable q] → Decidable (p ↔ q)",
  "name": "Iff.decidable",
  "kind": "def",
  "doc_string": "**Alias** of `instDecidableIff`.",
  "args": ""},
 {"type":
  "(R : Type u_1) →\n  (S : Type u_2) → [inst : NonUnitalNonAssocSemiring R] → [inst_1 : NonUnitalNonAssocSemiring S] → R × S →ₙ+* R",
  "name": "NonUnitalRingHom.fst",
  "kind": "def",
  "doc_string":
  "Given non-unital semirings `R`, `S`, the natural projection homomorphism from `R × S` to `R`.",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Add M] → { x // x ∈ ⊤ } ≃+ M",
  "name": "AddSubsemigroup.topEquiv",
  "kind": "def",
  "doc_string":
  "The top additive subsemigroup is isomorphic to the additive semigroup.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      {δ : Type u_4} →\n        {r : α → α → Prop} →\n          {s : β → β → Prop} →\n            {t : γ → γ → Prop} → {u : δ → δ → Prop} → r ↪r s → t ↪r u → Sum.LiftRel r t ↪r Sum.LiftRel s u",
  "name": "RelEmbedding.sumLiftRelMap",
  "kind": "def",
  "doc_string":
  "`Sum.map` as a relation embedding between `Sum.LiftRel` relations. ",
  "args": ""},
 {"type": "(V : Type u_1) → [inst : Quiver V] → Type (max u_1 v)",
  "name": "Quiver.HasReverse",
  "kind": "inductive",
  "doc_string":
  "A quiver `HasReverse` if we can reverse an arrow `p` from `a` to `b` to get an arrow\n`p.reverse` from `b` to `a`.",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a : Q(«$α»)} →\n        {b : Q(ℕ)} →\n          Mathlib.Tactic.Ring.ExSum sα a →\n            Mathlib.Tactic.Ring.ExProd Mathlib.Tactic.Ring.sℕ b →\n              Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExSum sα) q(«$a» ^ «$b»)",
  "name": "Mathlib.Tactic.Ring.evalPow₁",
  "kind": "opaque",
  "doc_string":
  "Exponentiates a polynomial `va` by a monomial `vb`, including several special cases.\n\n* `a ^ 1 = a`\n* `0 ^ e = 0` if `0 < e`\n* `(a + 0) ^ b = a ^ b` computed using `evalPowProd`\n* `a ^ b = (a ^ b') ^ k` if `b = b' * k` and `k > 1`\n\nOtherwise `a ^ b` is just encoded as `a ^ b * 1 + 0` using `evalPowAtom`.\n",
  "args": ""},
 {"type":
  "∀ {M : Type u} [self : AddMonoid M] (x : M), AddMonoid.nsmul 0 x = 0",
  "name": "AddMonoid.nsmul_zero",
  "kind": "def",
  "doc_string": "Multiplication by `(0 : ℕ)` gives `0`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : NonUnitalNonAssocRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : Add β] →\n          [inst_3 : Mul β] →\n            [inst_4 : Neg β] →\n              [inst_5 : Sub β] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : SMul ℤ β] →\n                    (f : β → α) →\n                      Function.Injective f →\n                        f 0 = 0 →\n                          (∀ (x y : β), f (x + y) = f x + f y) →\n                            (∀ (x y : β), f (x * y) = f x * f y) →\n                              (∀ (x : β), f (-x) = -f x) →\n                                (∀ (x y : β), f (x - y) = f x - f y) →\n                                  (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                    (∀ (x : β) (n : ℤ), f (n • x) = n • f x) → NonUnitalNonAssocRing β",
  "name": "Function.Injective.nonUnitalNonAssocRing",
  "kind": "def",
  "doc_string":
  "Pullback a `NonUnitalNonAssocRing` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u} → (ℕ → α → α) → ℕ → α → α",
  "name": "Nat.foldTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `Nat.fold`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        {S : Type u_3} →\n          [inst_2 : SetLike S N] →\n            [inst_3 : AddSubmonoidClass S N] → (f : M →+ N) → (s : S) → (∀ (x : M), ↑f x ∈ s) → M →+ { x // x ∈ s }",
  "name": "AddMonoidHom.codRestrict",
  "kind": "def",
  "doc_string":
  "Restriction of an `AddMonoid` hom to an `AddSubmonoid` of the codomain.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : NonUnitalNonAssocSemiring α] [inst_1 : NonUnitalNonAssocSemiring β]\n  (self : α →ₙ+* β) (x y : α), ↑self.toMulHom (x + y) = ↑self.toMulHom x + ↑self.toMulHom y",
  "name": "NonUnitalRingHom.map_add'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves addition ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → List (ℕ × α)",
  "name": "List.indexesValues",
  "kind": "def",
  "doc_string":
  "Returns the elements of `l` that satisfy `p` together with their indexes in\n`l`. The returned list is ordered by index.\n",
  "args": ""},
 {"type": "{σ : Type u} → σ → DoResultBC σ",
  "name": "DoResultBC.continue",
  "kind": "def",
  "doc_string":
  "`continue s` means that `continue` was called, meaning that we should continue\nto the next iteration of the containing loop ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_≃*_»",
  "kind": "def",
  "doc_string": "Notation for a `MulEquiv`. ",
  "args": ""},
 {"type": "{ι : Type u_1} → ComplexShape ι → ComplexShape ι",
  "name": "ComplexShape.symm",
  "kind": "def",
  "doc_string": "The reverse of a `ComplexShape`.\n",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (P : Prop) [inst : Decidable P] (x y : α),\n  f (if P then x else y) = if P then f x else f y",
  "name": "apply_ite",
  "kind": "theorem",
  "doc_string":
  "A function applied to a `ite` is a `ite` of that function applied to each of the branches. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} {inst : Add α} {inst_1 : LinearOrder β}\n  [self : NonarchimedeanHomClass F α β] (f : F) (a b : α), ↑f (a + b) ≤ max (↑f a) (↑f b)",
  "name": "NonarchimedeanHomClass.map_add_le_max",
  "kind": "def",
  "doc_string":
  "the image of a sum is less or equal than the maximum of the images. ",
  "args": ""},
 {"type": "ℕ → ℕ",
  "name": "Nat.size",
  "kind": "def",
  "doc_string":
  "`size n` : Returns the size of a natural number in\nbits i.e. the length of its binary representation ",
  "args": ""},
 {"type":
  "∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y Z : C} {f g : X ⟶ Y}, f = g → ∀ (h : Y ⟶ Z), f ≫ h = g ≫ h",
  "name": "CategoryTheory.eq_whisker",
  "kind": "theorem",
  "doc_string":
  "postcompose an equation between morphisms by another morphism ",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  {A : Type u_2} →\n    {H : Type u_3} → [inst : Group G] → [inst_1 : MulAction G A] → [inst_2 : Monoid H] → G →* MulAut (A → H)",
  "name": "mulAutArrow",
  "kind": "def",
  "doc_string":
  "Given groups `G H` with `G` acting on `A`, `G` acts by\nmultiplicative automorphisms on `A → H`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α ↪ β) → Equiv.Perm α →* Equiv.Perm β",
  "name": "Equiv.Perm.viaEmbeddingHom",
  "kind": "def",
  "doc_string": "`viaEmbedding` as a group homomorphism ",
  "args": ""},
 {"type": "(α : Sort u) → α → Sort v → Sort (max 1 v)",
  "name": "CoeT",
  "kind": "inductive",
  "doc_string":
  "`CoeT` is the core typeclass which is invoked by Lean to resolve a type error.\nIt can also be triggered explicitly with the notation `↑x` or by double type\nascription `((x : α) : β)`.\n\nA `CoeT` chain has the grammar `CoeHead? CoeOut* Coe* CoeTail? | CoeDep`.\n",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} → [inst_1 : CategoryTheory.Category D] → (F : C → D) → [I : CategoryTheory.Functorial F] → C ⥤ D",
  "name": "CategoryTheory.Functor.of",
  "kind": "def",
  "doc_string": "Bundle a functorial function as a functor.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → α → Prop) → (β → β → Prop) → Type (max u_1 u_2)",
  "name": "RelEmbedding",
  "kind": "inductive",
  "doc_string":
  "A relation embedding with respect to a given pair of relations `r` and `s`\nis an embedding `f : α ↪ β` such that `r a b ↔ s (f a) (f b)`. ",
  "args": ""},
 {"type":
  "∀ (M₀ : Type u_1) [inst : MulZeroOneClass M₀] [inst_1 : Nontrivial M₀], NeZero 1",
  "name": "NeZero.one",
  "kind": "def",
  "doc_string":
  "In a nontrivial monoid with zero, zero and one are different. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (r : α → α → Prop) → (s : β → β → Prop) → [inst : IsEmpty α] → r ≼i s",
  "name": "InitialSeg.ofIsEmpty",
  "kind": "def",
  "doc_string": "Initial segment from an empty type. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [hM : CommMonoid M] → (∀ (a : M), IsUnit a) → CommGroup M",
  "name": "commGroupOfIsUnit",
  "kind": "def",
  "doc_string":
  "Constructs a `CommGroup` structure on a `CommMonoid` consisting only of units. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ≃r s → Function.swap r ≃r Function.swap s",
  "name": "RelIso.swap",
  "kind": "def",
  "doc_string":
  "a relation isomorphism is also a relation isomorphism between dual relations. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, -a ≤ 0 ↔ 0 ≤ a",
  "name": "Right.neg_nonpos_iff",
  "kind": "theorem",
  "doc_string": "Uses `right` co(ntra)variant.",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Rel α β → Set β → Set α",
  "name": "Rel.core",
  "kind": "def",
  "doc_string":
  "Core of a set `s : Set β` w.r.t `r : Rel α β` is the set of `x : α` that are related *only*\nto elements of `s`. Other generalization of `Function.preimage`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : NonUnitalNonAssocSemiring α] → α →ₙ+* α",
  "name": "NonUnitalRingHom.id",
  "kind": "def",
  "doc_string":
  "The identity non-unital ring homomorphism from a non-unital semiring to itself. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Semigroup α] → Trans Dvd.dvd Dvd.dvd Dvd.dvd",
  "name": "instTransDvdSemigroupDvd",
  "kind": "def",
  "doc_string": "Transitivity of `|` for use in `calc` blocks ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Mul M] → Group (MulAut M)",
  "name": "MulAut.instGroupMulAut",
  "kind": "def",
  "doc_string":
  "The group operation on multiplicative automorphisms is defined by `g h => MulEquiv.trans h g`.\nThis means that multiplication agrees with composition, `(g*h)(x) = g (h x)`.\n",
  "args": ""},
 {"type": "{R : Type u} → [inst : NatCast R] → [inst : Neg R] → ℤ → R",
  "name": "Int.castDef",
  "kind": "def",
  "doc_string": "Default value for `IntCast.intCast` in an `AddGroupWithOne`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type u_1} →\n    [inst : StrictOrderedRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Neg β] →\n                [inst_6 : Sub β] →\n                  [inst_7 : SMul ℕ β] →\n                    [inst_8 : SMul ℤ β] →\n                      [inst_9 : Pow β ℕ] →\n                        [inst_10 : NatCast β] →\n                          [inst_11 : IntCast β] →\n                            (f : β → α) →\n                              Function.Injective f →\n                                f 0 = 0 →\n                                  f 1 = 1 →\n                                    (∀ (x y : β), f (x + y) = f x + f y) →\n                                      (∀ (x y : β), f (x * y) = f x * f y) →\n                                        (∀ (x : β), f (-x) = -f x) →\n                                          (∀ (x y : β), f (x - y) = f x - f y) →\n                                            (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                              (∀ (x : β) (n : ℤ), f (n • x) = n • f x) →\n                                                (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                  (∀ (n : ℕ), f ↑n = ↑n) → (∀ (n : ℤ), f ↑n = ↑n) → StrictOrderedRing β",
  "name": "Function.Injective.strictOrderedRing",
  "kind": "def",
  "doc_string": "Pullback a `StrictOrderedRing` under an injective map. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α], 0⁻¹ = 0",
  "name": "LinearOrderedCommGroupWithZero.inv_zero",
  "kind": "def",
  "doc_string": "The inverse of `0` in a group with zero is `0`. ",
  "args": ""},
 {"type":
  "(R : Type u) → (M : Type v) → [inst : Semiring R] → [inst : AddCommMonoid M] → Type (max u v)",
  "name": "Module",
  "kind": "inductive",
  "doc_string":
  "A module is a generalization of vector spaces to a scalar semiring.\nIt consists of a scalar semiring `R` and an additive monoid of \"vectors\" `M`,\nconnected by a \"scalar multiplication\" operation `r • x : M`\n(where `r : R` and `x : M`) with some natural associativity and\ndistributivity axioms similar to those on a ring. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Sigma.Lex.«Σₗ_,_»",
  "kind": "def",
  "doc_string":
  "The notation `Σₗ i, α i` refers to a sigma type equipped with the lexicographic order. ",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.multichoose",
  "kind": "def",
  "doc_string":
  "`multichoose n k` is the number of multisets of cardinality `k` from a type of cardinality `n`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (s : Set (α × β)) → ↑s ≃ (x : α) × ↑{ y | (x, y) ∈ s }",
  "name": "Equiv.setProdEquivSigma",
  "kind": "def",
  "doc_string":
  "A set `s` in `α × β` is equivalent to the sigma-type `Σ x, {y | (x, y) ∈ s}`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "MulOneClass",
  "kind": "inductive",
  "doc_string":
  "Typeclass for expressing that a type `M` with multiplication and a one satisfies\n`1 * a = a` and `a * 1 = a` for all `a : M`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : NormalizationMonoid α] (u : αˣ), normUnit ↑u = u⁻¹",
  "name": "NormalizationMonoid.normUnit_coe_units",
  "kind": "def",
  "doc_string":
  "The proposition that `normUnit` maps units to their inverses. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] {a b : α} [inst_1 : IsRefl α fun x x_1 => x ⊆ x_1], a = b → b ⊆ a",
  "name": "Eq.superset",
  "kind": "theorem",
  "doc_string": "**Alias** of `superset_of_eq`.",
  "args": ""},
 {"type":
  "∀ {K : Type u} [self : DivisionRing K] (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.coprime (Int.natAbs a) b),\n  ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹",
  "name": "DivisionRing.ratCast_mk",
  "kind": "def",
  "doc_string":
  "However `ratCast` is defined, propositionally it must be equal to `a * b⁻¹`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → α → α → Prop",
  "name": "Relation.ReflGen",
  "kind": "inductive",
  "doc_string": "`ReflGen r`: reflexive closure of `r` ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : LE α] → [inst_1 : LE β] → (α ⊕ β)ᵒᵈ ≃o αᵒᵈ ⊕ βᵒᵈ",
  "name": "OrderIso.sumDualDistrib",
  "kind": "def",
  "doc_string":
  "`orderDual` is distributive over `⊕` up to an order isomorphism. ",
  "args": ""},
 {"type": "ℕ ≃ ℕ ⊕ PUnit",
  "name": "Equiv.natEquivNatSumPUnit",
  "kind": "def",
  "doc_string": "The set of natural numbers is equivalent to `ℕ ⊕ PUnit`. ",
  "args": ""},
 {"type": "Lean.Elab.Tactic.Tactic",
  "name": "Mathlib.Tactic.elabNormNum1Conv",
  "kind": "def",
  "doc_string": "Elaborator for `norm_num1` conv tactic. ",
  "args": ""},
 {"type":
  "{A : Type u_1} → [inst : Add A] → AddSubsemigroup A ≃o Subsemigroup (Multiplicative A)",
  "name": "AddSubsemigroup.toSubsemigroup",
  "kind": "def",
  "doc_string":
  "Additive subsemigroups of an additive semigroup `A` are isomorphic to\nmultiplicative subsemigroups of `Multiplicative A`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u} [self : LeftCancelMonoid M] (x : M), LeftCancelMonoid.npow 0 x = 1",
  "name": "LeftCancelMonoid.npow_zero",
  "kind": "def",
  "doc_string": "Raising to the power `(0 : ℕ)` gives `1`. ",
  "args": ""},
 {"type": "ℤ → ℤ → ℤ",
  "name": "Int.shiftl",
  "kind": "def",
  "doc_string":
  "`shiftl m n` produces a integer whose binary representation\nis obtained by left-shifting the binary representation of `m` by `n` places ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LE α] → WithBot α ≃o Lex (PUnit ⊕ α)",
  "name": "WithBot.orderIsoPUnitSumLex",
  "kind": "def",
  "doc_string":
  "`WithBot α` is order-isomorphic to `PUnit ⊕ₗ α`, by sending `⊥` to `unit` and `↑a` to\n`a`. ",
  "args": ""},
 {"type": "(a b : Bool) → Decidable (a = b)",
  "name": "Bool.decEq",
  "kind": "def",
  "doc_string": "Decidable equality for Bool ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Add M] → Bot (AddSubsemigroup M)",
  "name": "AddSubsemigroup.instBotSubsemigroup",
  "kind": "def",
  "doc_string": "The trivial `AddSubsemigroup` `∅` of an additive magma `M`.",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : AddGroup α] →\n    [inst_1 : LE α] → [inst : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] → α → α ≃o α",
  "name": "OrderIso.addLeft",
  "kind": "def",
  "doc_string":
  "`Equiv.addLeft` as an `OrderIso`. See also `OrderEmbedding.addLeft`.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → Aesop.UnorderedArraySet α → Bool",
  "name": "Aesop.UnorderedArraySet.isEmpty",
  "kind": "def",
  "doc_string": "O(1) ",
  "args": ""},
 {"type": "{α : Type u} → α → αᵐᵒᵖ",
  "name": "MulOpposite.op",
  "kind": "def",
  "doc_string": "The element of `MulOpposite α` that represents `x : α`. ",
  "args": ""},
 {"type": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), 0 * a = 0",
  "name": "MulZeroClass.zero_mul",
  "kind": "def",
  "doc_string": "Zero is a left absorbing element for multiplication ",
  "args": ""},
 {"type":
  "IO.Ref Mathlib.Tactic.Ring.State →\n  Mathlib.Tactic.RingNF.Config → Mathlib.Tactic.RingNF.Context → Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "name": "Mathlib.Tactic.RingNF.M.run.evalAtom",
  "kind": "opaque",
  "doc_string":
  "The atom evaluator calls either `RingNF.rewrite` recursively,\nor nothing depending on `cfg.recursive`. ",
  "args": ""},
 {"type": "Lean.Name → Lean.Name",
  "name": "Mathlib.Prelude.Rename.removeX",
  "kind": "def",
  "doc_string":
  "Removes all occurrences of `ₓ` from the name.\nThis is the same processing used by mathport to generate name references,\nand declarations with `ₓ` are used to align declarations that do not defeq match the originals.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ≺i s → β",
  "name": "PrincipalSeg.top",
  "kind": "def",
  "doc_string": "The supremum of the principal segment ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : AddZeroClass α] → [inst_1 : AddZeroClass β] → (αᵐᵒᵖ →+ βᵐᵒᵖ) ≃ (α →+ β)",
  "name": "AddMonoidHom.mulUnop",
  "kind": "def",
  "doc_string":
  "The 'unopposite' of an additive monoid hom `αᵐᵒᵖ →+ βᵐᵒᵖ`. Inverse to\n`AddMonoidHom.mul_op`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LT α] {a : α} (as : List α) {b : α} (bs : List α), a < b → List.lt (a :: as) (b :: bs)",
  "name": "List.lt.head",
  "kind": "def",
  "doc_string": "If `a < b` then `a::as < b::bs`. ",
  "args": ""},
 {"type":
  "List Lean.Expr → Lean.MetaM (Std.HashMap Lean.Expr (List Lean.Expr))",
  "name": "Linarith.partitionByType",
  "kind": "def",
  "doc_string":
  "`partitionByType l` takes a list `l` of proofs of comparisons. It sorts these proofs by\nthe type of the variables in the comparison, e.g. `(a : ℚ) < 1` and `(b : ℤ) > c` will be separated.\nReturns a map from a type to a list of comparisons over that type.\n",
  "args": ""},
 {"type": "(V : Type u) → [inst : Quiver V] → Type (max u v)",
  "name": "Quiver.Arborescence",
  "kind": "inductive",
  "doc_string":
  "A quiver is an arborescence when there is a unique path from the default vertex\nto every other vertex. ",
  "args": ""},
 {"type": "Linarith.Preprocessor → Lean.Expr → Lean.MetaM (List Lean.Expr)",
  "name": "Linarith.Preprocessor.transform",
  "kind": "def",
  "doc_string":
  "Replace a hypothesis by a list of hypotheses. These expressions are the proof terms. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.AbelMode",
  "name": "Mathlib.Tactic.Abel.AbelMode.raw",
  "kind": "def",
  "doc_string": "Raw form: the representation `abel` uses internally. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α}, 1 ≤ a → 1 < b → 1 < a * b",
  "name": "one_lt_mul_of_le_of_lt'",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.one_lt_mul_of_le_of_lt`.",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → (α → β → γ) → List α → List β → List γ",
  "name": "List.zipWith",
  "kind": "def",
  "doc_string":
  "`O(min |xs| |ys|)`. Applies `f` to the two lists in parallel, stopping at the shorter list.\n* `zipWith f [x₁, x₂, x₃] [y₁, y₂, y₃, y₄] = [f x₁ y₁, f x₂ y₂, f x₃ y₃]`\n",
  "args": ""},
 {"type":
  "{K : Type u_1} →\n  [inst : Field K] →\n    {K' : Type u_2} →\n      [inst_1 : Zero K'] →\n        [inst_2 : Mul K'] →\n          [inst_3 : Add K'] →\n            [inst_4 : Neg K'] →\n              [inst_5 : Sub K'] →\n                [inst_6 : One K'] →\n                  [inst_7 : Inv K'] →\n                    [inst_8 : Div K'] →\n                      [inst_9 : SMul ℕ K'] →\n                        [inst_10 : SMul ℤ K'] →\n                          [inst_11 : SMul ℚ K'] →\n                            [inst_12 : Pow K' ℕ] →\n                              [inst_13 : Pow K' ℤ] →\n                                [inst_14 : NatCast K'] →\n                                  [inst_15 : IntCast K'] →\n                                    [inst_16 : RatCast K'] →\n                                      (f : K' → K) →\n                                        Function.Injective f →\n                                          f 0 = 0 →\n                                            f 1 = 1 →\n                                              (∀ (x y : K'), f (x + y) = f x + f y) →\n                                                (∀ (x y : K'), f (x * y) = f x * f y) →\n                                                  (∀ (x : K'), f (-x) = -f x) →\n                                                    (∀ (x y : K'), f (x - y) = f x - f y) →\n                                                      (∀ (x : K'), f x⁻¹ = (f x)⁻¹) →\n                                                        (∀ (x y : K'), f (x / y) = f x / f y) →\n                                                          (∀ (x : K') (n : ℕ), f (n • x) = n • f x) →\n                                                            (∀ (x : K') (n : ℤ), f (n • x) = n • f x) →\n                                                              (∀ (x : K') (n : ℚ), f (n • x) = n • f x) →\n                                                                (∀ (x : K') (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                                  (∀ (x : K') (n : ℤ), f (x ^ n) = f x ^ n) →\n                                                                    (∀ (n : ℕ), f ↑n = ↑n) →\n                                                                      (∀ (n : ℤ), f ↑n = ↑n) →\n                                                                        (∀ (n : ℚ), f ↑n = ↑n) → Field K'",
  "name": "Function.Injective.field",
  "kind": "def",
  "doc_string":
  "Pullback a `Field` along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Nonempty β] → ((α → β) → α → β) → α → β",
  "name": "memoFix",
  "kind": "opaque",
  "doc_string":
  "Takes the fixpoint of `f` with caching of values that have been seen before.\nHashing makes use of a pointer hash.\n\nThis is useful for implementing tree traversal functions where\nsubtrees may be referenced in multiple places.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (f : α → β) → Quotient (Setoid.ker f) ≃ ↑(Set.range f)",
  "name": "Setoid.quotientKerEquivRange",
  "kind": "def",
  "doc_string":
  "The first isomorphism theorem for sets: the quotient of α by the kernel of a function f\nbijects with f's image. ",
  "args": ""},
 {"type": "{α : Type u_1} → WithBot αᵒᵈ ≃ WithTop α",
  "name": "WithBot.ofDual",
  "kind": "def",
  "doc_string":
  "`WithBot.ofDual` is the equivalence sending `⊥` to `⊤` and any `a : αᵒᵈ` to `ofDual a : α`.\nSee `WithBot.ofDual_top_equiv` for the related order-iso.\n",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : AddGroup α] →\n    [inst_1 : LE α] → [inst : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] → α → α ≃o α",
  "name": "OrderIso.addRight",
  "kind": "def",
  "doc_string":
  "`Equiv.addRight` as an `OrderIso`. See also `OrderEmbedding.addRight`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : SemilatticeSup α] {β : Type u_1} [inst_1 : Preorder β] {f g : α → β},\n  Monotone f → Antitone g → f ≤ g → ∀ (m n : α), f m ≤ g n",
  "name": "Monotone.forall_le_of_antitone",
  "kind": "theorem",
  "doc_string":
  "If `f` is monotone, `g` is antitone, and `f ≤ g`, then for all `a`, `b` we have `f a ≤ g b`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddRightCancelSemigroup",
  "kind": "inductive",
  "doc_string":
  "An `AddRightCancelSemigroup` is an additive semigroup such that\n`a + b = c + b` implies `a = c`. ",
  "args": ""},
 {"type": "{R : Type u} → [inst : Ring R] → IsField R → Field R",
  "name": "IsField.toField",
  "kind": "def",
  "doc_string": "Transferring from `IsField` to `Field`. ",
  "args": ""},
 {"type":
  "{I : Type u} →\n  {f : I → Type v} →\n    {γ : Type w} →\n      [inst : (i : I) → MulOneClass (f i)] → [inst_1 : MulOneClass γ] → ((i : I) → γ →* f i) → γ →* (i : I) → f i",
  "name": "Pi.monoidHom",
  "kind": "def",
  "doc_string":
  "A family of monoid homomorphisms `f a : γ →* β a` defines a monoid homomorphism\n`Pi.monoidHom f : γ →* Π a, β a` given by `Pi.monoidHom f x b = f b x`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α}, R a b → List.Chain R b l → List.Chain R a (b :: l)",
  "name": "List.Chain.cons",
  "kind": "def",
  "doc_string":
  "If `a` relates to `b` and `b::l` is a chain, then `a :: b :: l` is also a chain. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → {S : Type u_2} → [inst : Ring R] → [inst : Ring S] → Ring (R × S)",
  "name": "Prod.instRingProd",
  "kind": "def",
  "doc_string": "Product of two rings is a ring. ",
  "args": ""},
 {"type":
  "∀ (m : Type u → Type v) [inst : Monad m],\n  (∀ {α : Type u} (x : m α), id <$> x = x) →\n    (∀ {α β : Type u} (x : α) (f : α → m β), pure x >>= f = f x) →\n      (∀ {α β γ : Type u} (x : m α) (f : α → m β) (g : β → m γ), x >>= f >>= g = x >>= fun x => f x >>= g) →\n        autoParam (∀ {α β : Type u} (x : α) (y : m β), Functor.mapConst x y = Function.const β x <$> y) _auto✝ →\n          autoParam\n              (∀ {α β : Type u} (x : m α) (y : m β),\n                (SeqLeft.seqLeft x fun x => y) = do\n                  let a ← x\n                  let _ ← y\n                  pure a)\n              _auto✝¹ →\n            autoParam\n                (∀ {α β : Type u} (x : m α) (y : m β),\n                  (SeqRight.seqRight x fun x => y) = do\n                    let _ ← x\n                    y)\n                _auto✝² →\n              autoParam\n                  (∀ {α β : Type u} (f : α → β) (x : m α),\n                    (do\n                        let y ← x\n                        pure (f y)) =\n                      f <$> x)\n                  _auto✝³ →\n                autoParam\n                    (∀ {α β : Type u} (f : m (α → β)) (x : m α),\n                      (do\n                          let x_1 ← f\n                          x_1 <$> x) =\n                        Seq.seq f fun x_1 => x)\n                    _auto✝⁴ →\n                  LawfulMonad m",
  "name": "LawfulMonad.mk'",
  "kind": "theorem",
  "doc_string":
  "An alternative constructor for `LawfulMonad` which has more\ndefaultable fields in the common case.\n",
  "args": ""},
 {"type": "{α : Type u} → ℕ → List α → List α",
  "name": "List.take",
  "kind": "def",
  "doc_string":
  "`O(min n |xs|)`. Returns the first `n` elements of `xs`, or the whole list if `n` is too large.\n* `take 0 [a, b, c, d, e] = []`\n* `take 3 [a, b, c, d, e] = [a, b, c]`\n* `take 6 [a, b, c, d, e] = [a, b, c, d, e]`\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : LinearOrderedCancelAddCommMonoid M] → (S : AddSubmonoid M) → LinearOrderedCancelAddCommMonoid { x // x ∈ S }",
  "name": "AddSubmonoid.toLinearOrderedCancelAddCommMonoid",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of a `LinearOrderedCancelAddCommMonoid` is\na `LinearOrderedCancelAddCommMonoid`.",
  "args": ""},
 {"type": "{α : Type u} → [inst : Monoid α] → Inv αˣ",
  "name": "Units.instInvUnits",
  "kind": "def",
  "doc_string": "The inverse of a unit in a `Monoid`. ",
  "args": ""},
 {"type":
  "{α₁ : Type u_1} →\n  {α₂ : Type u_2} →\n    {β₁ : Type u_3} →\n      {β₂ : Type u_4} →\n        {r₁ : α₁ → α₁ → Prop} →\n          {r₂ : α₂ → α₂ → Prop} →\n            {s₁ : β₁ → β₁ → Prop} → {s₂ : β₂ → β₂ → Prop} → r₁ ≃r s₁ → r₂ ≃r s₂ → Prod.Lex r₁ r₂ ≃r Prod.Lex s₁ s₂",
  "name": "RelIso.prodLexCongr",
  "kind": "def",
  "doc_string":
  "Given relation isomorphisms `r₁ ≃r s₁` and `r₂ ≃r s₂`, construct a relation isomorphism for the\nlexicographic orders on the product.\n",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  {A : Type u_2} → {B : Type u_3} → [inst : DivisionMonoid G] → [inst_1 : MulAction G A] → MulAction G (A → B)",
  "name": "arrowAction",
  "kind": "def",
  "doc_string":
  "If `G` acts on `A`, then it acts also on `A → B`, by `(g • F) a = F (g⁻¹ • a)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_4} {β' : Type u_3} {γ : Type u_1} {δ : Type u_5} {s : Set α} {t : Set β} {f : α → β' → γ}\n  {g : β → β'} {f' : α → β → δ} {g' : δ → γ},\n  (∀ (a : α) (b : β), f a (g b) = g' (f' a b)) → Set.image2 f s (g '' t) = g' '' Set.image2 f' s t",
  "name": "Set.image_image2_right_comm",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Set.image_image2_distrib_right`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : Lattice α] → (∀ (a b c : α), a ⊓ (b ⊔ c) ≤ a ⊓ b ⊔ a ⊓ c) → DistribLattice α",
  "name": "DistribLattice.ofInfSupLe",
  "kind": "def",
  "doc_string":
  "Prove distributivity of an existing lattice from the dual distributive law. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → List α → List β → List (α × β)",
  "name": "List.productTR",
  "kind": "def",
  "doc_string": "Optimized version of `product`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r : α → α → Prop} {a b c : α},\n  (∀ (a b c : α), r a b → r a c → ∃ d, Relation.ReflGen r b d ∧ Relation.ReflTransGen r c d) →\n    Relation.ReflTransGen r a b → Relation.ReflTransGen r a c → Relation.Join (Relation.ReflTransGen r) b c",
  "name": "Relation.church_rosser",
  "kind": "theorem",
  "doc_string": "A sufficient condition for the Church-Rosser property. ",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrderedAddCommGroup α] → DecidableRel fun x x_1 => x ≤ x_1",
  "name": "LinearOrderedAddCommGroup.decidable_le",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "ℕ → PosNum",
  "name": "PosNum.ofNatSucc",
  "kind": "def",
  "doc_string": "`ofNatSucc n` is the `PosNum` corresponding to `n + 1`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {n : ℕ} (a : α) (v : Vector α n), Vector.toList (Vector.cons a v) = a :: Vector.toList v",
  "name": "Vector.toList_cons",
  "kind": "theorem",
  "doc_string":
  "`toList` of `cons` of a vector and an element is\nthe `cons` of the list obtained by `toList` and the element ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Mul α] [self : HasDistribNeg α] (x y : α), -x * y = -(x * y)",
  "name": "HasDistribNeg.neg_mul",
  "kind": "def",
  "doc_string": "Negation is left distributive over multiplication ",
  "args": ""},
 {"type":
  "{α₁ : Type u_1} → {β₁ : Type u_2} → {β₂ : Type u_3} → (α₁ → β₁ ≃ β₂) → β₁ × α₁ ≃ β₂ × α₁",
  "name": "Equiv.prodCongrLeft",
  "kind": "def",
  "doc_string":
  "A family of equivalences `∀ (a : α₁), β₁ ≃ β₂` generates an equivalence\nbetween `β₁ × α₁` and `β₂ × α₁`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {a b : Set α} (f : α → β), a ⊆ b → f '' a ⊆ f '' b",
  "name": "Set.image_subset",
  "kind": "theorem",
  "doc_string":
  "Image is monotone with respect to `⊆`. See `Set.monotone_image` for the statement in\nterms of `≤`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] → [inst_1 : MulOneClass N] → (f : M →* N) → (∀ (x y : M), Commute (↑f x) (↑f y)) → M →* Nᵐᵒᵖ",
  "name": "MonoidHom.toOpposite",
  "kind": "def",
  "doc_string":
  "A monoid homomorphism `f : M →* N` such that `f x` commutes with `f y` for all `x, y` defines\na monoid homomorphism to `Nᵐᵒᵖ`. ",
  "args": ""},
 {"type": "{α : Sort u} → (α → α → Prop) → (α → α → Prop) → Prop",
  "name": "Subrelation",
  "kind": "def",
  "doc_string":
  "`Subrelation q r` means that `q ⊆ r` or `∀ x y, q x y → r x y`.\nIt is the analogue of the subset relation on relations.\n",
  "args": ""},
 {"type":
  "{C : ℚ → Sort u} →\n  (a : ℚ) → ((n : ℤ) → (d : ℕ) → (nz : d ≠ 0) → (red : Nat.coprime (Int.natAbs n) d) → C (Rat.mk' n d)) → C a",
  "name": "Rat.numDenCasesOn''",
  "kind": "def",
  "doc_string":
  "Define a (dependent) function or prove `∀ r : ℚ, p r` by dealing with rational\nnumbers of the form `mk' n d` with `d ≠ 0`. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {α : ι → Type u_2} →\n    [inst : PartialOrder ι] →\n      [inst_1 : OrderTop ι] →\n        [inst_2 : (i : ι) → Preorder (α i)] → [inst_3 : OrderTop (α ⊤)] → OrderTop (Lex ((i : ι) ×' α i))",
  "name": "PSigma.Lex.orderTop",
  "kind": "def",
  "doc_string": "The lexicographical linear order on a sigma type. ",
  "args": ""},
 {"type": "∀ {α : Type u} {s : Set α}, Set.Nonempty s → s ≠ ∅",
  "name": "Set.Nonempty.ne_empty",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `Set.nonempty_iff_ne_empty`.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CompleteLinearOrder",
  "kind": "inductive",
  "doc_string":
  "A complete linear order is a linear order whose lattice structure is complete. ",
  "args": ""},
 {"type": "{α : Type u} → α × List α × α × List α → α",
  "name": "Stream'.cycleF",
  "kind": "def",
  "doc_string": "An auxiliary definition for `Stream'.cycle` corecursive def ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α}\n  (self : GaloisCoinsertion l u) (a : β) (h : a ≤ l (u a)), GaloisCoinsertion.choice self a h = u a",
  "name": "GaloisCoinsertion.choice_eq",
  "kind": "def",
  "doc_string": "Property of the choice function. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "calcTactic",
  "kind": "def",
  "doc_string":
  "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n\n`calc` has term mode and tactic mode variants. This is the tactic mode variant,\nwhich supports an additional feature: it works even if the goal is `a = z'`\nfor some other `z'`; in this case it will not close the goal but will instead\nleave a subgoal proving `z = z'`.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Linarith.mkNegOneLtZeroProof",
  "kind": "def",
  "doc_string":
  "`mkNegOneLtZeroProof tp` returns a proof of `-1 < 0`,\nwhere the numerals are natively of type `tp`.\n",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Polyrith.Poly",
  "kind": "inductive",
  "doc_string":
  "A datatype representing the semantics of multivariable polynomials.\nEach `poly` can be converted into a string.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_3} {α' : Type u_5} {β : Type u_4} {γ : Type u_2} {δ : Type u_1} {f : α → β → γ} {s : Set α} {t : Set β}\n  {g : γ → δ} {f' : β → α' → δ} {g' : α → α'},\n  (∀ (a : α) (b : β), g (f a b) = f' b (g' a)) → g '' Set.image2 f s t = Set.image2 f' t (g' '' s)",
  "name": "Set.image_image2_antidistrib_right",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Set.image_image2_right_anticomm`. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → List α → (α → List β) → List β",
  "name": "List.bind",
  "kind": "def",
  "doc_string":
  "`bind xs f` is the bind operation of the list monad. It applies `f` to each element of `xs`\nto get a list of lists, and then concatenates them all together.\n* `[2, 3, 2].bind range = [0, 1, 0, 1, 2, 0, 1]`\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.normNum1",
  "kind": "def",
  "doc_string": "Basic version of `norm_num` that does not call `simp`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (zα : Q(Zero «$α»)) →\n      (pα : Q(PartialOrder «$α»)) → (e : Q(«$α»)) → Lean.MetaM (Mathlib.Meta.Positivity.Strictness zα pα e)",
  "name": "Mathlib.Meta.Positivity.normNumPositivity",
  "kind": "def",
  "doc_string":
  "Attempts to prove a `Strictness` result when `e` evaluates to a literal number. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.tacticExpect_failure_msg__",
  "kind": "def",
  "doc_string":
  "`expect_failure_msg msg tacs` succeeds iff `tacs` fails with `msg` as the error message. ",
  "args": ""},
 {"type": "(n : ℕ) → WellFoundedRelation (Fin n)",
  "name": "Fin.upRel",
  "kind": "def",
  "doc_string":
  "A well-ordered relation for \"upwards\" induction on `Fin n`. ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {E : Type u₃}\n  [inst_2 : CategoryTheory.Category E] {F : C ⥤ D} {G : D ⥤ E} {H : C ⥤ E} [inst_3 : CategoryTheory.Faithful H],\n  (F ⋙ G ≅ H) → CategoryTheory.Faithful F",
  "name": "CategoryTheory.Iso.faithful_of_comp",
  "kind": "theorem",
  "doc_string": "**Alias** of `CategoryTheory.Faithful.of_comp_iso`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → (α → α → Bool) → (a : Array α) → { a' // Array.size a' = Array.size a }",
  "name": "BinaryHeap.mkHeap",
  "kind": "def",
  "doc_string":
  "Core operation for binary heaps, expressed directly on arrays.\nConstruct a heap from an unsorted array, by heapifying all the elements. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : PartialOrder α] →\n      [inst_1 : PartialOrder β] → {u : β → α} → (l : LowerAdjoint u) → α → ↑(LowerAdjoint.closed l)",
  "name": "LowerAdjoint.toClosed",
  "kind": "def",
  "doc_string":
  "Send an `x` to an element of the set of closed elements (by taking the closure). ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → {P : Type u_3} → [inst : Add M] → [inst_1 : Add N] → [inst_2 : Add P] → M ≃+ N → N ≃+ P → M ≃+ P",
  "name": "AddEquiv.trans",
  "kind": "def",
  "doc_string": "Transitivity of addition-preserving isomorphisms",
  "args": ""},
 {"type": "Type → Type",
  "name": "Mathlib.Tactic.DeclCache",
  "kind": "def",
  "doc_string":
  "Cached fold over the environment's declarations,\nwhere a given function is applied to `α` for every constant.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : MulZeroClass R], IsRegular 0 ↔ Subsingleton R",
  "name": "isRegular_iff_subsingleton",
  "kind": "theorem",
  "doc_string": "The element `0` is regular if and only if `R` is trivial. ",
  "args": ""},
 {"type":
  "{V : Type u} → [inst : Quiver V] → (r : V) → [inst_1 : Quiver.RootedConnected r] → WideSubquiver V",
  "name": "Quiver.geodesicSubtree",
  "kind": "def",
  "doc_string": "A subquiver which by construction is an arborescence. ",
  "args": ""},
 {"type": "{α : Type u_1} → WithTop αᵒᵈ ≃ WithBot α",
  "name": "WithTop.ofDual",
  "kind": "def",
  "doc_string":
  "`WithTop.ofDual` is the equivalence sending `⊤` to `⊥` and any `a : αᵒᵈ` to `ofDual a : α`.\nSee `WithTop.toDualBotEquiv` for the related order-iso.\n",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} → {α β : Type u_1} → [inst : Monad m] → m (Option α) → m β → (α → m β) → m β",
  "name": "Option.elimM",
  "kind": "def",
  "doc_string": "A monadic analogue of `Option.elim`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (t : Set β) {f : α → β},\n  Function.Injective f → Function.Injective (Set.restrictPreimage t f)",
  "name": "Function.Injective.restrictPreimage",
  "kind": "theorem",
  "doc_string": "**Alias** of `Set.restrictPreimage_injective`.",
  "args": ""},
 {"type":
  "Type u_1 →\n  (α : outParam (Type u_2)) →\n    (β : outParam (Type u_3)) → [inst : Add α] → [inst : LinearOrder β] → Type (max (max u_1 u_2) u_3)",
  "name": "NonarchimedeanHomClass",
  "kind": "inductive",
  "doc_string":
  "`NonarchimedeanHomClass F α β` states that `F` is a type of non-archimedean morphisms. ",
  "args": ""},
 {"type":
  "{m : Type u → Type v} → {α β : Type u} → [inst : MonadFinally m] → [inst : Functor m] → m α → m β → m α",
  "name": "tryFinally",
  "kind": "def",
  "doc_string":
  "Execute `x` and then execute `finalizer` even if `x` threw an exception ",
  "args": ""},
 {"type": "Mathlib.Meta.Positivity.PositivityExt",
  "name": "Mathlib.Meta.Positivity.evalAdd",
  "kind": "def",
  "doc_string":
  "The `positivity` extension which identifies expressions of the form `a + b`,\nsuch that `positivity` successfully recognises both `a` and `b`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → Preorder (α →o β)",
  "name": "OrderHom.instPreorderOrderHom",
  "kind": "def",
  "doc_string":
  "The preorder structure of `α →o β` is pointwise inequality: `f ≤ g ↔ ∀ a, f a ≤ g a`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] → {F : Type u_3} → [mc : AddMonoidHomClass F M N] → F → AddSubmonoid N",
  "name": "AddMonoidHom.mrange",
  "kind": "def",
  "doc_string": "The range of an `AddMonoidHom` is an `AddSubmonoid`.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Mul M] (S : Subsemigroup M) {x y : M}, x ∈ S → y ∈ S → x * y ∈ S",
  "name": "Subsemigroup.mul_mem",
  "kind": "theorem",
  "doc_string": "A subsemigroup is closed under multiplication. ",
  "args": ""},
 {"type":
  "{m : Type u → Type v} →\n  {n : Type u → Type w} → [self : MonadFunctorT m n] → {α : Type u} → ({β : Type u} → m β → m β) → n α → n α",
  "name": "MonadFunctorT.monadMap",
  "kind": "def",
  "doc_string":
  "Lifts a monad morphism `f : {β : Type u} → m β → m β` to\n`monadMap f : {α : Type u} → n α → n α`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⊕'_»",
  "kind": "def",
  "doc_string":
  "`PSum α β`, or `α ⊕' β`, is the disjoint union of types `α` and `β`.\nIt differs from `α ⊕ β` in that it allows `α` and `β` to have arbitrary sorts\n`Sort u` and `Sort v`, instead of restricting to `Type u` and `Type v`. This means\nthat it can be used in situations where one side is a proposition, like `True ⊕' Nat`.\n\nThe reason this is not the default is that this type lives in the universe `Sort (max 1 u v)`,\nwhich can cause problems for universe level unification,\nbecause the equation `max 1 u v = ?u + 1` has no solution in level arithmetic.\n`PSum` is usually only used in automation that constructs sums of arbitrary types.\n",
  "args": ""},
 {"type": "{α : Type u_1} → List α → Prop",
  "name": "List.Nodup",
  "kind": "def",
  "doc_string":
  "`Nodup l` means that `l` has no duplicates, that is, any element appears at most\nonce in the List. It is defined as `Pairwise (≠)`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (f : AddHom M N) {x y : M}, x = y → ↑f x = ↑f y",
  "name": "AddHom.congr_arg",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.congr_arg` instead.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (self : AddHom M N) (x y : M),\n  ↑self (x + y) = ↑self x + ↑self y",
  "name": "AddHom.map_add'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves addition ",
  "args": ""},
 {"type": "{α : Type u_1} → List (List α) → List α",
  "name": "List.joinTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `join`. ",
  "args": ""},
 {"type":
  "{m : Type u → Type v} → [self : MonadFinally m] → {α β : Type u} → m α → (Option α → m β) → m (α × β)",
  "name": "MonadFinally.tryFinally'",
  "kind": "def",
  "doc_string":
  "`tryFinally' x f` runs `x` and then the \"finally\" computation `f`.\nWhen `x` succeeds with `a : α`, `f (some a)` is returned. If `x` fails\nfor `m`'s definition of failure, `f none` is returned. Hence `tryFinally'`\ncan be thought of as performing the same role as a `finally` block in\nan imperative programming language. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : RightCancelSemigroup M₂] →\n        (f : M₁ → M₂) → Function.Injective f → (∀ (x y : M₁), f (x * y) = f x * f y) → RightCancelSemigroup M₁",
  "name": "Function.Injective.rightCancelSemigroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `*` is a right cancel semigroup, if it admits an injective map that\npreserves `*` to a right cancel semigroup.  See note [reducible non-instances]. ",
  "args": ""},
 {"type": "(α : Type u_1) → (β : Type u_2) → α ⊕ β ≃ β ⊕ α",
  "name": "Equiv.sumComm",
  "kind": "def",
  "doc_string":
  "Sum of types is commutative up to an equivalence. This is `Sum.swap` as an equivalence. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b = c → a < c",
  "name": "LT.lt.trans_eq",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_lt_of_eq`.",
  "args": ""},
 {"type": "{α : Type u} → [self : Xor α] → α → α → α",
  "name": "Xor.xor",
  "kind": "def",
  "doc_string": "The implementation of `a ^^^ b : α`. See `HXor`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : LE α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → α → α",
  "name": "minDefault",
  "kind": "def",
  "doc_string": "Default definition of `min`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a < 0 → b < 0 → a + b < 0",
  "name": "Left.add_neg'",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_neg'`.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Monoid M] {F : Type v} [inst_1 : DivisionRing F] [inst_2 : MulSemiringAction M F] (x : M)\n  (m : F), x • m⁻¹ = (x • m)⁻¹",
  "name": "smul_inv''",
  "kind": "theorem",
  "doc_string":
  "Note that `smul_inv'` refers to the group case, and `smul_inv` has an additional inverse\non `x`. ",
  "args": ""},
 {"type": "ℤ → ℤ",
  "name": "Int.succ",
  "kind": "def",
  "doc_string": "Immediate successor of an integer: `succ n = n + 1` ",
  "args": ""},
 {"type": "Lean.MVarId → ℕ → Lean.MetaM Unit",
  "name": "Mathlib.Tactic.MkIff.splitThenConstructor",
  "kind": "def",
  "doc_string":
  "Splits the goal `n` times via `refine ⟨?_,?_⟩`, and then applies `constructor` to\nclose the resulting subgoals.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedCommGroup α] {n : ℤ} {a b : α}, n ≠ 0 → (a ^ n = b ^ n ↔ a = b)",
  "name": "zpow_eq_zpow_iff'",
  "kind": "theorem",
  "doc_string":
  "Alias of `zsmul_right_inj`, for ease of discovery alongside `zsmul_le_zsmul_iff'` and\n`zsmul_lt_zsmul_iff'`. ",
  "args": ""},
 {"type": "{p : Prop} → ¬p → Decidable p",
  "name": "Decidable.isFalse",
  "kind": "def",
  "doc_string": "Prove that `p` is decidable by supplying a proof of `¬p` ",
  "args": ""},
 {"type":
  "{p : Prop} → {q : Sort u} → [dec : Decidable p] → (p → q) → (¬p → q) → q",
  "name": "Decidable.byCases",
  "kind": "def",
  "doc_string":
  "Synonym for `dite` (dependent if-then-else). We can construct an element `q`\n(of any sort, not just a proposition) by cases on whether `p` is true or false,\nprovided `p` is decidable.\n",
  "args": ""},
 {"type":
  "{R : Type u_1} → [inst : Monoid R] → {S : Submonoid R} → [self : OreLocalization.OreSet S] → R → { x // x ∈ S } → R",
  "name": "OreLocalization.OreSet.oreNum",
  "kind": "def",
  "doc_string": "The Ore numerator of a fraction. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {W : α → Sort w} → {Z : β → Sort z} → (h₁ : α ≃ β) → ((a : α) → W a ≃ Z (↑h₁ a)) → ((a : α) → W a) ≃ ((b : β) → Z b)",
  "name": "Equiv.piCongr",
  "kind": "def",
  "doc_string":
  "Transport dependent functions through\nan equivalence of the base spaces and a family\nof equivalences of the matching fibers.\n",
  "args": ""},
 {"type": "(V : Type u_1) → [inst : Quiver V] → Setoid V",
  "name": "Quiver.zigzagSetoid",
  "kind": "def",
  "doc_string":
  "Two vertices are related in the zigzag setoid if there is a\nzigzag of arrows from one to the other. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α] (a b : α), max a b = if a ≤ b then b else a",
  "name": "CanonicallyLinearOrderedSemifield.max_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `maxOfLe`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Add M] {s : Set M} {S : AddSubsemigroup M}, AddSubsemigroup.closure s ≤ S ↔ s ⊆ ↑S",
  "name": "AddSubsemigroup.closure_le",
  "kind": "theorem",
  "doc_string":
  "An additive subsemigroup `S` includes `closure s` if and only if it includes `s`",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : AddCommMonoid α] → (a b : α) → a + b = 0 → AddUnits α",
  "name": "AddUnits.mkOfAddEqZero",
  "kind": "def",
  "doc_string":
  "For `a, b` in an `AddCommMonoid` such that `a + b = 0`, makes an add_unit out of `a`.",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : LE α] [self : OrderBot α] (a : α), ⊥ ≤ a",
  "name": "OrderBot.bot_le",
  "kind": "def",
  "doc_string": "`⊥` is the least element ",
  "args": ""},
 {"type": "∀ {x k l : ℕ}, 1 < x → (x ^ k ∣ x ^ l ↔ k ≤ l)",
  "name": "Nat.pow_dvd_pow_iff_le_right",
  "kind": "theorem",
  "doc_string":
  "If `1 < x`, then `x^k` divides `x^l` if and only if `k` is at most `l`. ",
  "args": ""},
 {"type": "List Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Linarith.addExprs",
  "kind": "def",
  "doc_string":
  "`addExprs L` creates an `Expr` representing the sum of the elements of `L`, associated left. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (r : α → α → Prop) → [inst : IsPreorder α r] → α → Antisymmetrization α r",
  "name": "toAntisymmetrization",
  "kind": "def",
  "doc_string": "Turn an element into its antisymmetrization. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSSubset α] [inst_1 : IsIrrefl α fun x x_1 => x ⊂ x_1] {a b : α}, a ⊂ b → b ≠ a",
  "name": "HasSSubset.SSubset.ne'",
  "kind": "theorem",
  "doc_string": "**Alias** of `ne_of_ssuperset`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β), Function.Injective (Quotient.lift f (_ : ∀ (x x_1 : α), x ≈ x_1 → x ≈ x_1))",
  "name": "Setoid.ker_lift_injective",
  "kind": "theorem",
  "doc_string":
  "Given a map f from α to β, the natural map from the quotient of α by the kernel of f is\ninjective. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_5} {β : Type u_4} {γ : Type u_3} {a : Option α} {b : Option β} {α' : Type u_1} {δ : Type u_2}\n  {f : α' → β → γ} {g : α → α'} {f' : α → β → δ} {g' : δ → γ},\n  (∀ (a : α) (b : β), f (g a) b = g' (f' a b)) → Option.map₂ f (Option.map g a) b = Option.map g' (Option.map₂ f' a b)",
  "name": "Option.map₂_map_left_comm",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Option.map_map₂_distrib_left`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a : α), a * 0 = 0",
  "name": "NonUnitalNonAssocSemiring.mul_zero",
  "kind": "def",
  "doc_string": "Zero is a right absorbing element for multiplication ",
  "args": ""},
 {"type":
  "{β : Type v} → {m : Type v → Type w} → [inst : Monad m] → FloatArray → β → (Float → β → m (ForInStep β)) → m β",
  "name": "FloatArray.forIn",
  "kind": "def",
  "doc_string": "Reference implementation for `forIn` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (f : α ↪ β) → (x : β) → ¬x ∈ Set.range ↑f → Option α ↪ β",
  "name": "Function.Embedding.optionElim",
  "kind": "def",
  "doc_string":
  "Given an embedding `f : α ↪ β` and a point outside of `Set.range f`, construct an embedding\n`Option α ↪ β`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : Lattice α] (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "name": "Lattice.le_inf",
  "kind": "def",
  "doc_string": "The infimum is the *greatest* lower bound ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "termIfLet",
  "kind": "def",
  "doc_string":
  "`if let pat := d then t else e` is a shorthand syntax for:\n```\nmatch d with\n| pat => t\n| _ => e\n```\nIt matches `d` against the pattern `pat` and the bindings are available in `t`.\nIf the pattern does not match, it returns `e` instead.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → List α → (ℕ → α → m β) → m (List β)",
  "name": "List.mapIdxM",
  "kind": "def",
  "doc_string": "Monadic variant of `mapIdx`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {a : α}, 1 < a → ∀ (n : ℕ), ↑n ≤ (a ^ n - 1) / (a - 1)",
  "name": "Nat.cast_le_pow_sub_div_sub",
  "kind": "theorem",
  "doc_string": "Bernoulli's inequality reformulated to estimate `(n : α)`. ",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.PComp",
  "kind": "inductive",
  "doc_string":
  "A `PComp` stores a linear comparison `Σ cᵢ*xᵢ R 0`,\nalong with information about how this comparison was derived.\nThe original expressions fed into `linarith` are each assigned a unique natural number label.\nThe *historical set* `PComp.history` stores the labels of expressions\nthat were used in deriving the current `PComp`.\nVariables are also indexed by natural numbers. The sets `PComp.effective`, `PComp.implicit`,\nand `PComp.vars` contain variable indices.\n* `PComp.vars` contains the variables that appear in any inequality in the historical set.\n* `PComp.effective` contains the variables that have been effectively eliminated from `PComp`.\n  A variable `n` is said to be *effectively eliminated* in `p : PComp` if the elimination of `n`\n  produced at least one of the ancestors of `p` (or `p` itself).\n* `PComp.implicit` contains the variables that have been implicitly eliminated from `PComp`.\n  A variable `n` is said to be *implicitly eliminated* in `p` if it satisfies the following\n  properties:\n  - `n` appears in some inequality in the historical set (i.e. in `p.vars`).\n  - `n` does not appear in `p.c.vars` (i.e. it has been eliminated).\n  - `n` was not effectively eliminated.\n\nWe track these sets in order to compute whether the history of a `PComp` is *minimal*.\nChecking this directly is expensive, but effective approximations can be defined in terms of these\nsets. During the variable elimination process, a `PComp` with non-minimal history can be discarded.\n",
  "args": ""},
 {"type": "{α : Type u_1} → [self : Semifield α] → ℤ → α → α",
  "name": "Semifield.zpow",
  "kind": "def",
  "doc_string":
  "The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term__[_]»",
  "kind": "def",
  "doc_string":
  "The syntax `arr[i]` gets the `i`'th element of the collection `arr`.\nIf there are proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\nThe actual behavior of this class is type-dependent,\nbut here are some important implementations:\n* `arr[i] : α` where `arr : Array α` and `i : Nat` or `i : USize`:\n  does array indexing with no bounds check and a proof side goal `i < arr.size`.\n* `l[i] : α` where `l : List α` and `i : Nat`: index into a list,\n  with proof side goal `i < l.length`.\n* `stx[i] : Syntax` where `stx : Syntax` and `i : Nat`: get a syntax argument,\n  no side goal (returns `.missing` out of range)\n\nThere are other variations on this syntax:\n* `arr[i]`: proves the proof side goal by `get_elem_tactic`\n* `arr[i]!`: panics if the side goal is false\n* `arr[i]?`: returns `none` if the side goal is false\n* `arr[i]'h`: uses `h` to prove the side goal\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Add R] {c : R}, IsAddRegular c → IsAddRightRegular c",
  "name": "IsAddRegular.right",
  "kind": "def",
  "doc_string": "An add-regular element `c` is right-regular ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      [inst : Preorder α] → [inst_1 : Preorder β] → [inst_2 : Preorder γ] → (α →o β) →o (α →o γ) →o α →o β × γ",
  "name": "OrderHom.prodₘ",
  "kind": "def",
  "doc_string":
  "Given two bundled monotone maps `f`, `g`, `f.prod g` is the map `x ↦ (f x, g x)` bundled as a\n`OrderHom`. This is a fully bundled version. ",
  "args": ""},
 {"type":
  "List (Lean.Elab.TermElabM Lean.Expr) → Lean.Elab.TermElabM (List Lean.Expr) → Lean.MetaM (List Lean.Expr)",
  "name": "Mathlib.Tactic.SolveByElim.elabContextLemmas",
  "kind": "def",
  "doc_string": "Elaborate the context and the list of lemmas ",
  "args": ""},
 {"type": "ℕ → LazyList ℕ",
  "name": "LazyList.iota",
  "kind": "def",
  "doc_string": "The infinite lazy list `[i, i+1, i+2, ...]` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {F : Type u_3} [inst : NonAssocSemiring α] [inst_1 : NonAssocSemiring β]\n  [inst_2 : AddHomClass F α β] (f : F) (a : α), ↑f (bit0 a) = bit0 (↑f a)",
  "name": "map_bit0",
  "kind": "theorem",
  "doc_string": "Additive homomorphisms preserve `bit0`. ",
  "args": ""},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "name": "CoeOTC",
  "kind": "inductive",
  "doc_string":
  "Auxiliary class implementing `CoeOut* Coe*`.\nUsers should generally not implement this directly.\n",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Monoid R] → Submonoid R → Type u_1",
  "name": "OreLocalization.OreSet",
  "kind": "inductive",
  "doc_string":
  "A submonoid `S` of a monoid `R` is (right) Ore if common factors on the left can be turned\ninto common factors on the right, and if each pair of `r : R` and `s : S` admits an Ore numerator\n`v : R` and an Ore denominator `u : S` such that `r * u = s * v`. ",
  "args": ""},
 {"type":
  "(Type u → Type v) → (Type u → Type w) → Type (max (max (u + 1) v) w)",
  "name": "MonadLift",
  "kind": "inductive",
  "doc_string":
  "A function for lifting a computation from an inner `Monad` to an outer `Monad`.\nLike Haskell's [`MonadTrans`], but `n` does not have to be a monad transformer.\nAlternatively, an implementation of [`MonadLayer`] without `layerInvmap` (so far).\n\n  [`MonadTrans`]: https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html\n  [`MonadLayer`]: https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLayer\n",
  "args": ""},
 {"type": "Lean.MVarId → Lean.FVarId → Lean.Name → Lean.Name → Lean.MetaM Unit",
  "name": "Mathlib.Tactic.renameBVarHyp",
  "kind": "def",
  "doc_string": "Renames a bound variable in a hypothesis. ",
  "args": ""},
 {"type":
  "∀ {R : Type u} [self : EuclideanDomain R], WellFounded EuclideanDomain.r",
  "name": "EuclideanDomain.r_wellFounded",
  "kind": "def",
  "doc_string":
  "The relation `r` must be well-founded.\nThis ensures that the GCD algorithm always terminates. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\n  1 • x = x",
  "name": "Module.Core.one_smul",
  "kind": "def",
  "doc_string": "Scalar multiplication by one is the identity. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : CanonicallyLinearOrderedMonoid α] → DecidableRel fun x x_1 => x ≤ x_1",
  "name": "CanonicallyLinearOrderedMonoid.decidable_le",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → (self : BinaryHeap α lt) → Fin (BinaryHeap.size self) → α → BinaryHeap α lt",
  "name": "BinaryHeap.decreaseKey",
  "kind": "def",
  "doc_string":
  "`O(log n)`. Replace the value at index `i` by `x`. Assumes that `x ≤ self.get i`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → M ≃+ N → M → N",
  "name": "AddEquiv.Simps.apply",
  "kind": "def",
  "doc_string": "See Note custom simps projection",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} {fa : α → α} {fb : β → β} {g : α → β},\n  Function.Semiconj g fa fb → Set.MapsTo g (Function.fixedPoints fa) (Function.fixedPoints fb)",
  "name": "Function.Semiconj.mapsTo_fixedPoints",
  "kind": "theorem",
  "doc_string":
  "If `g` semiconjugates `fa` to `fb`, then it sends fixed points of `fa` to fixed points\nof `fb`. ",
  "args": ""},
 {"type":
  "Lean.SimpleScopedEnvExtension (Lean.Name × Array (Lean.Meta.DiscrTree.Key true)) (Lean.Meta.DiscrTree Lean.Name true)",
  "name": "Mathlib.Tactic.reflExt",
  "kind": "opaque",
  "doc_string": "Environment extensions for `refl` lemmas ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_ᵐᵒᵖ»",
  "kind": "def",
  "doc_string": "Multiplicative opposite of a type. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : AddCommMonoid α] → AddCommGroup (AddUnits α)",
  "name": "AddUnits.instAddCommGroupAddUnitsToAddMonoid",
  "kind": "def",
  "doc_string":
  "Additive units of an additive commutative monoid form\nan additive commutative group.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [s : Setoid α] {r : α → α → Prop} {H : ∀ (a₁ b₁ a₂ b₂ : α), a₁ ≈ a₂ → b₁ ≈ b₂ → r a₁ b₁ = r a₂ b₂},\n  WellFounded (Quotient.lift₂ r H) ↔ WellFounded r",
  "name": "wellFounded_lift₂_iff",
  "kind": "theorem",
  "doc_string": "A relation is well founded iff its lift to a quotient is. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} (as : List α), (List.toArray as).data = as",
  "name": "List.toArray_data",
  "kind": "theorem",
  "doc_string": "**Alias** of `Array.data_toArray`.",
  "args": ""},
 {"type":
  "∀ {γ : Type w} [inst : SemilatticeInf γ] {a₁ a₂ : γ} {s t : Set γ}, IsGLB s a₁ → IsGLB t a₂ → IsGLB (s ∪ t) (a₁ ⊓ a₂)",
  "name": "IsGLB.union",
  "kind": "theorem",
  "doc_string":
  "If `a` is the greatest lower bound of `s` and `b` is the greatest lower bound of `t`,\nthen `a ⊓ b` is the greatest lower bound of `s ∪ t`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : LinearOrder α] →\n    (pred : α → α) →\n      (∀ {a : α}, ¬IsMin a → ∀ (b : α), b ≤ pred a ↔ b < a) → (∀ (a : α), IsMin a → pred a = a) → PredOrder α",
  "name": "PredOrder.ofCore",
  "kind": "def",
  "doc_string": "A constructor for `PredOrder α` for `α` a linear order. ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "name": "LinearOrder.le_total",
  "kind": "def",
  "doc_string": "A linear order is total. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {s : Set (Setoid α)}, Setoid.Rel (infₛ s) = infₛ (Setoid.Rel '' s)",
  "name": "Setoid.infₛ_def",
  "kind": "theorem",
  "doc_string":
  "The underlying binary operation of the infimum of a set of equivalence relations\nis the infimum of the set's image under the map to the underlying binary operation. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : CommRing R] {x₁ x₂ y₁ y₂ : R},\n  (x₁ ^ 2 + x₂ ^ 2) * (y₁ ^ 2 + y₂ ^ 2) = (x₁ * y₁ - x₂ * y₂) ^ 2 + (x₁ * y₂ + x₂ * y₁) ^ 2",
  "name": "sq_add_sq_mul_sq_add_sq",
  "kind": "theorem",
  "doc_string":
  "Brahmagupta-Fibonacci identity or Diophantus identity, see\n<https://en.wikipedia.org/wiki/Brahmagupta%E2%80%93Fibonacci_identity>.\n\nThis sign choice here corresponds to the signs obtained by multiplying two complex numbers.\n",
  "args": ""},
 {"type":
  "{U : Type u_1} →\n  [inst : Quiver U] →\n    {V : Type u_3} → [inst_1 : Quiver V] → {W : Type u_5} → [inst_2 : Quiver W] → U ⥤q V → V ⥤q W → U ⥤q W",
  "name": "Prefunctor.comp",
  "kind": "def",
  "doc_string": "Composition of morphisms between quivers. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Lattice α] → [inst_1 : IsModularLattice α] → (a b : α) → ↑(Set.Ioo (a ⊓ b) a) ≃o ↑(Set.Ioo b (a ⊔ b))",
  "name": "infIooOrderIsoIooSup",
  "kind": "def",
  "doc_string":
  "The diamond isomorphism between the intervals `]a ⊓ b, a[` and `}b, a ⊔ b[`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β} {f : α → β} (h : Set.MapsTo f s t),\n  Set.MapsTo.restrict f s t h = Set.codRestrict (Set.restrict s f) t (_ : ∀ (x : ↑s), f ↑x ∈ t)",
  "name": "Set.MapsTo.restrict_eq_codRestrict",
  "kind": "theorem",
  "doc_string": "Reverse of `Set.codRestrict_restrict`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.normNumCmd",
  "kind": "def",
  "doc_string":
  "The basic usage is `#norm_num e`, where `e` is an expression,\nwhich will print the `norm_num` form of `e`.\n\nSyntax: `#norm_num` (`only`)? (`[` simp lemma list `]`)? `:`? expression\n\nThis accepts the same options as the `#simp` command.\nYou can specify additional simp lemmas as usual, for example using `#norm_num [f, g] : e`.\n(The colon is optional but helpful for the parser.)\nThe `only` restricts `norm_num` to using only the provided lemmas, and so\n`#norm_num only : e` behaves similarly to `norm_num1`.\n\nUnlike `norm_num`, this command does not fail when no simplifications are made.\n\n`#norm_num` understands local variables, so you can use them to introduce parameters.\n",
  "args": ""},
 {"type": "{α : Type u} → (ℕ → α → α) → ℕ → α → α",
  "name": "Nat.fold",
  "kind": "def",
  "doc_string":
  "`Nat.fold` evaluates `f` on the numbers up to `n` exclusive, in increasing order:\n* `Nat.fold f 3 init = init |> f 0 |> f 1 |> f 2`\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Preorder",
  "kind": "inductive",
  "doc_string":
  "A preorder is a reflexive, transitive relation `≤` with `a < b` defined in the obvious way. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.RingNF.ring",
  "kind": "def",
  "doc_string":
  "Tactic for evaluating expressions in *commutative* (semi)rings, allowing for variables in the\nexponent.\n\n* `ring!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `ring1` fails if the target is not an equality.\n\nFor example:\n```\nexample (n : ℕ) (m : ℤ) : 2^(n+1) * m = 2 * 2^n * m := by ring\nexample (a b : ℤ) (n : ℕ) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring\nexample (x y : ℕ) : x + id y = y + id x := by ring!\n```\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "RightCancelSemigroup",
  "kind": "inductive",
  "doc_string":
  "A `RightCancelSemigroup` is a semigroup such that `a * b = c * b` implies `a = c`. ",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.descFactorial",
  "kind": "def",
  "doc_string":
  "`n.descFactorial k = n! / (n - k)!` (as seen in `Nat.descFactorial_eq_div`), but\nimplemented recursively to allow for \"quick\" computation when using `norm_num`. This is closely\nrelated to `pochhammer`, but much less general. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] → {F : Type u_3} → [mc : MonoidHomClass F M N] → F → Submonoid M → Submonoid N",
  "name": "Submonoid.map",
  "kind": "def",
  "doc_string":
  "The image of a submonoid along a monoid homomorphism is a submonoid. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] (a b c : α), (a + b) * c = a * c + b * c",
  "name": "CanonicallyOrderedCommSemiring.right_distrib",
  "kind": "def",
  "doc_string": "Multiplication is right distributive over addition ",
  "args": ""},
 {"type": "(M : Type u) → [inst : Monoid M] → Mˣ →* M",
  "name": "Units.coeHom",
  "kind": "def",
  "doc_string": "Coercion `Mˣ → M` as a monoid homomorphism. ",
  "args": ""},
 {"type": "{α : Type u_1} → CompleteLattice (Setoid α)",
  "name": "Setoid.completeLattice",
  "kind": "def",
  "doc_string":
  "The complete lattice of equivalence relations on a type, with bottom element `=`\nand top element the trivial equivalence relation. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → α → Aesop.UnorderedArraySet α → Aesop.UnorderedArraySet α",
  "name": "Aesop.UnorderedArraySet.erase",
  "kind": "def",
  "doc_string": "O(n) ",
  "args": ""},
 {"type": "ℕ → Type",
  "name": "Fin",
  "kind": "inductive",
  "doc_string":
  "`Fin n` is a natural number `i` with the constraint that `0 ≤ i < n`.\nIt is the \"canonical type with `n` elements\".\n",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.RingNF.Context",
  "kind": "inductive",
  "doc_string": "The read-only state of the `RingNF` monad. ",
  "args": ""},
 {"type": "PUnit",
  "name": "PUnit.unit",
  "kind": "def",
  "doc_string":
  "`PUnit.unit : PUnit` is the canonical element of the unit type. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] (a : α), a * 1 = a",
  "name": "CanonicallyOrderedCommSemiring.mul_one",
  "kind": "def",
  "doc_string": "One is a right neutral element for multiplication ",
  "args": ""},
 {"type":
  "Type u_1 →\n  (α : outParam (Type u_2)) →\n    (β : outParam (Type u_3)) → [inst : Mul α] → [inst : Mul β] → [inst : LE β] → Type (max (max u_1 u_2) u_3)",
  "name": "SubmultiplicativeHomClass",
  "kind": "inductive",
  "doc_string":
  "`SubmultiplicativeHomClass F α β` states that `F` is a type of submultiplicative morphisms. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : α → Type u_2} →\n    (((a : α) → Part (β a)) → (a : α) → Part (β a)) →\n      {p : ℕ → Prop} → (i : Nat.Upto p) → ((j : Nat.Upto p) → i < j → (a : α) → Part (β a)) → (a : α) → Part (β a)",
  "name": "Part.fixAux",
  "kind": "def",
  "doc_string": "loop body for finding the fixed point of `f` ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "BiheytingAlgebra",
  "kind": "inductive",
  "doc_string":
  "A bi-Heyting algebra is a Heyting algebra that is also a co-Heyting algebra. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} {β : Type u_2}, Function.Injective Option.map",
  "name": "Option.map_injective'",
  "kind": "theorem",
  "doc_string": "`Option.map` as a function between functions is injective. ",
  "args": ""},
 {"type":
  "(R : Type u_1) → (M : Type u_2) → [inst : Semiring R] → [inst : AddCommGroup M] → Type (max u_1 u_2)",
  "name": "Module.Core",
  "kind": "inductive",
  "doc_string":
  "A structure containing most informations as in a module, except the fields `zero_smul`\nand `smul_zero`. As these fields can be deduced from the other ones when `M` is an `AddCommGroup`,\nthis provides a way to construct a module structure by checking less properties, in\n`Module.ofCore`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Max",
  "kind": "inductive",
  "doc_string":
  "`Max α` is the typeclass which supports the operation `max x y` where `x y : α`.",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} (r : α → α → Prop), Function.Surjective (Quot.mk r)",
  "name": "surjective_quot_mk",
  "kind": "theorem",
  "doc_string": "`Quot.mk r` is a surjective function. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : PartialOrder α] →\n    [inst_1 : BoundedOrder α] → [inst : IsSimpleOrder α] → [inst : DecidableEq α] → LinearOrder α",
  "name": "IsSimpleOrder.linearOrder",
  "kind": "def",
  "doc_string":
  "A simple partial ordered `BoundedOrder` induces a linear order.\nThis is not an instance to prevent loops. ",
  "args": ""},
 {"type": "∀ {α : Sort u} [self : Countable α], ∃ f, Function.Injective f",
  "name": "Countable.exists_injective_nat'",
  "kind": "def",
  "doc_string":
  "A type `α` is countable if there exists an injective map `α → ℕ`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LT α] [inst_1 : WellFoundedGT α] {C : α → Sort u_1} (F : (x : α) → ((y : α) → x < y → C y) → C x)\n  (x : α), WellFoundedGT.fix F x = F x fun y x => WellFoundedGT.fix F y",
  "name": "WellFoundedGT.fix_eq",
  "kind": "theorem",
  "doc_string":
  "The value from `WellFoundedGT.fix` is built from the successive ones as specified. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_||_»",
  "kind": "def",
  "doc_string":
  "`or x y`, or `x || y`, is the boolean \"or\" operation (not to be confused\nwith `Or : Prop → Prop → Prop`, which is the propositional connective).\nIt is `@[macro_inline]` because it has C-like short-circuiting behavior:\nif `x` is true then `y` is not evaluated.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} (S : Set (Setoid α)), supₛ S = EqvGen.Setoid fun x y => ∃ r, r ∈ S ∧ Setoid.Rel r x y",
  "name": "Setoid.supₛ_eq_eqvGen",
  "kind": "theorem",
  "doc_string":
  "The supremum of a set S of equivalence relations is the equivalence closure of the binary\nrelation `there exists r ∈ S relating x and y`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 ≤ a → 0 ≤ b → 0 ≤ a + b",
  "name": "add_nonneg",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.add_nonneg`.",
  "args": ""},
 {"type": "Num → Num → Num",
  "name": "Num.gcd",
  "kind": "def",
  "doc_string": "Greatest Common Divisor (GCD) of two `Num`s. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : StrictOrderedRing α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → OrderedRing α",
  "name": "StrictOrderedRing.toOrderedRing'",
  "kind": "def",
  "doc_string":
  "A choice-free version of `StrictOrderedRing.toOrderedRing` to avoid using choice in basic\n`Int` lemmas. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] (self : Flag α) ⦃s : Set α⦄,\n  IsChain (fun x x_1 => x ≤ x_1) s → self.carrier ⊆ s → self.carrier = s",
  "name": "Flag.max_chain'",
  "kind": "def",
  "doc_string": "By definition, a flag is a maximal chain ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [inst : Monoid α] {a : α} {u : αˣ}, ↑u ∣ a",
  "name": "Units.coe_dvd",
  "kind": "theorem",
  "doc_string":
  "Elements of the unit group of a monoid represented as elements of the monoid\ndivide any element of the monoid. ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Semiring R] → Rˣ →* AddAut R",
  "name": "AddAut.mulLeft",
  "kind": "def",
  "doc_string":
  "Left multiplication by a unit of a semiring as an additive automorphism. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LT α] → Ordering → α → α → Prop",
  "name": "Ordering.Compares",
  "kind": "def",
  "doc_string":
  "`Compares o a b` means that `a` and `b` have the ordering relation `o` between them, assuming\nthat the relation `a < b` is defined. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsLeftCancelMulZero M₀] {a b c : M₀},\n  a ≠ 0 → a * b = a * c → b = c",
  "name": "IsLeftCancelMulZero.mul_left_cancel_of_ne_zero",
  "kind": "def",
  "doc_string": "Multiplicatin by a nonzero element is left cancellative. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {S' : Type u_3} →\n      [inst : Mul R] →\n        [inst_1 : Mul S] →\n          [inst_2 : Add R] → [inst_3 : Add S] → [inst_4 : Mul S'] → [inst_5 : Add S'] → R ≃+* S → S ≃+* S' → R ≃+* S'",
  "name": "RingEquiv.trans",
  "kind": "def",
  "doc_string": "Transitivity of `RingEquiv`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddMonoid α] (self : AddUnits α), ↑self + self.neg = 0",
  "name": "AddUnits.val_neg",
  "kind": "def",
  "doc_string":
  "`neg` is the right additive inverse of `val` in the base `AddMonoid`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [self : InfSet α] → Set α → α",
  "name": "InfSet.infₛ",
  "kind": "def",
  "doc_string": "Infimum of a set ",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a : α}, a ≤ a",
  "name": "le_rfl",
  "kind": "theorem",
  "doc_string": "A version of `le_refl` where the argument is implicit ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α) (a : α), a ∈ s → a ≤ supₛ s",
  "name": "CompleteBooleanAlgebra.le_supₛ",
  "kind": "def",
  "doc_string": "Any element of a set is less than the set supremum. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Semigroup R] {a : R} (b : R), IsRightRegular a → (IsRightRegular (b * a) ↔ IsRightRegular b)",
  "name": "mul_isRightRegular_iff",
  "kind": "theorem",
  "doc_string":
  "An element is right-regular if and only if multiplying it on the right with a right-regular\nelement is right-regular. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : PartialOrder α] →\n    (f : α → α) → Monotone f → (∀ (x : α), x ≤ f x) → (∀ (x : α), f (f x) ≤ f x) → ClosureOperator α",
  "name": "ClosureOperator.mk'",
  "kind": "def",
  "doc_string":
  "Constructor for a closure operator using the weaker idempotency axiom: `f (f x) ≤ f x`. ",
  "args": ""},
 {"type":
  "∀ (α : Type u) [inst : OrderedAddCommGroup α],\n  ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "name": "OrderedAddCommGroup.to_contravariantClass_right_le",
  "kind": "def",
  "doc_string": "A choice-free shortcut instance.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} → [inst : IsWellOrder β s] → (f : r ↪r s) → (a : α) → { b // ¬s (↑f.toEmbedding a) b }",
  "name": "RelEmbedding.collapseF",
  "kind": "def",
  "doc_string":
  "Given an order embedding into a well order, collapse the order embedding by filling the\ngaps, to obtain an initial segment. Here, we construct the collapsed order embedding pointwise,\nbut the proof of the fact that it is an initial segment will be given in `collapse`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] (a b : α), min a b = a ∧ a ≤ b ∨ min a b = b ∧ b < a",
  "name": "min_cases",
  "kind": "theorem",
  "doc_string":
  "For elements `a` and `b` of a linear order, either `min a b = a` and `a ≤ b`,\nor `min a b = b` and `b < a`.\nUse cases on this lemma to automate linarith in inequalities ",
  "args": ""},
 {"type":
  "∀ {M : Type u} [inst : Monoid M] {x y : M}, x ∣ y → ∀ {n : ℕ}, n ≠ 0 → x ∣ y ^ n",
  "name": "Dvd.dvd.pow",
  "kind": "theorem",
  "doc_string": "**Alias** of `dvd_pow`.",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : AddCommGroup M] → Unique (Module ℤ M)",
  "name": "AddCommGroup.intModule.unique",
  "kind": "def",
  "doc_string":
  "All `ℤ`-module structures are equal. Not an instance since in mathlib all `AddCommGroup`\nshould normally have exactly one `ℤ`-module structure by design. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α] (a b : α), min a b = if a ≤ b then a else b",
  "name": "CanonicallyLinearOrderedSemifield.min_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `minOfLe`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "List.«term_<:+_»",
  "kind": "def",
  "doc_string":
  "`isSuffix l₁ l₂`, or `l₁ <:+ l₂`, means that `l₁` is a suffix of `l₂`,\nthat is, `l₂` has the form `t ++ l₁` for some `t`.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Add M] →\n      [inst_1 : Add N] →\n        (s : AddSubsemigroup M) →\n          (t : AddSubsemigroup N) → { x // x ∈ AddSubsemigroup.prod s t } ≃+ { x // x ∈ s } × { x // x ∈ t }",
  "name": "AddSubsemigroup.prodEquiv",
  "kind": "def",
  "doc_string":
  "The product of additive subsemigroups is isomorphic to their product as additive semigroups",
  "args": ""},
 {"type": "{α : Type u} → Option α",
  "name": "Option.none",
  "kind": "def",
  "doc_string": "No value. ",
  "args": ""},
 {"type": "PosNum → PosNum",
  "name": "PosNum.succ",
  "kind": "def",
  "doc_string": "The successor of a `PosNum`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} → {f : α → β} → [inst : Inhabited α] → [inst : Subsingleton β] → Function.Injective f → Unique α",
  "name": "Function.Injective.unique",
  "kind": "def",
  "doc_string":
  "If `α` is inhabited and admits an injective map to a subsingleton type, then `α` is `Unique`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddMonoid M] → AddUnits Mᵃᵒᵖ ≃+ (AddUnits M)ᵃᵒᵖ",
  "name": "AddUnits.opEquiv",
  "kind": "def",
  "doc_string":
  "The additive units of the additive opposites are equivalent to the additive opposites\nof the additive units.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [s : Setoid α] →\n    {r : α → α → Prop} → (H : ∀ (a₁ b₁ a₂ b₂ : α), a₁ ≈ a₂ → b₁ ≈ b₂ → r a₁ b₁ = r a₂ b₂) → Quotient.lift₂ r H ↪r r",
  "name": "Quotient.outRelEmbedding",
  "kind": "def",
  "doc_string":
  "`Quotient.out` as a relation embedding between the lift of a relation and the relation. ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → [self : CoeHead α β] → α → β",
  "name": "CoeHead.coe",
  "kind": "def",
  "doc_string":
  "Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Monoid M] → M → Prop",
  "name": "IsUnit",
  "kind": "def",
  "doc_string":
  "An element `a : M` of a `Monoid` is a unit if it has a two-sided inverse.\nThe actual definition says that `a` is equal to some `u : Mˣ`, where\n`Mˣ` is a bundled version of `IsUnit`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} → {e : Q(«$α»)} → Mathlib.Meta.NormNum.Result e → ℤ × (e' : Q(«$α»)) × Q(«$e» = «$e'»)",
  "name": "Mathlib.Meta.NormNum.Result.toRawEq",
  "kind": "def",
  "doc_string":
  "Given a `NormNum.Result e` (which uses `IsNat` or `IsInt` to express equality to an integer\nnumeral), converts it to an equality `e = Nat.rawCast n` or `e = Int.rawCast n` to a raw cast\nexpression, so it can be used for rewriting.\n",
  "args": ""},
 {"type":
  "∀ {G : Type u_2} {H : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : OrderedAddCommGroup H] {f : G → H},\n  (∀ (x : G), f (-x) = -f x) → StrictMonoOn f (Set.Ici 0) → StrictMono f",
  "name": "strictMono_of_odd_strictMono_on_nonneg",
  "kind": "theorem",
  "doc_string":
  "An odd function on a linear ordered additive commutative group is strictly monotone on the whole\ngroup provided that it is strictly monotone on `Set.Ici 0`. ",
  "args": ""},
 {"type":
  "{F : Type u → Type v} → [inst : Applicative F] → {α₁ α₂ φ : Type u} → (α₁ → α₂ → F φ) → List α₁ → List α₂ → F (List φ)",
  "name": "zipWithM",
  "kind": "def",
  "doc_string":
  "A generalization of `List.zipWith` which combines list elements with an `Applicative`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : IsUpperModularLattice α] {a b : α}, a ⊓ b ⋖ a → b ⋖ a ⊔ b",
  "name": "Covby.sup_of_inf_left",
  "kind": "theorem",
  "doc_string": "**Alias** of `covby_sup_of_inf_covby_left`.",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {α : ι → Type u_2} →\n    [inst : LinearOrder ι] → [inst : (i : ι) → LinearOrder (α i)] → LinearOrder (Lex ((i : ι) ×' α i))",
  "name": "PSigma.Lex.linearOrder",
  "kind": "def",
  "doc_string": "Dictionary / lexicographic linear_order for pairs. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Monoid M] (u : Mˣ) (x : M), SemiconjBy (↑u) x (↑u * x * ↑u⁻¹)",
  "name": "Units.mk_semiconjBy",
  "kind": "theorem",
  "doc_string": "`a` semiconjugates `x` to `a * x * a⁻¹`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Type u_2} → (p : Set β) → (f : α ↪ β) → (∀ (a : α), ↑f a ∈ p) → α ↪ ↑p",
  "name": "Function.Embedding.codRestrict",
  "kind": "def",
  "doc_string": "Restrict the codomain of an embedding. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : AddCommMonoid M] → Unique (Module ℕ M)",
  "name": "AddCommMonoid.natModule.unique",
  "kind": "def",
  "doc_string":
  "All `ℕ`-module structures are equal. Not an instance since in mathlib all `AddCommMonoid`\nshould normally have exactly one `ℕ`-module structure by design. ",
  "args": ""},
 {"type": "Bool → Lean.Expr → Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Tactic.Alias.mkIffMpApp",
  "kind": "def",
  "doc_string":
  "Given a possibly forall-quantified iff expression `prf`, produce a value for one\nof the implication directions (determined by `mp`).\n",
  "args": ""},
 {"type": "{α : Type u_1} → Option α → Part α",
  "name": "Part.ofOption",
  "kind": "def",
  "doc_string": "Converts an `Option α` into a `Part α`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedMonoid α] {a b : α}, a ≤ b → ∃ c, b = a * c",
  "name": "CanonicallyOrderedMonoid.exists_mul_of_le",
  "kind": "def",
  "doc_string": "For `a ≤ b`, there is a `c` so `b = a * c`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : AddMonoid α] → AddZeroClass (AddUnits α)",
  "name": "AddUnits.instAddZeroClassAddUnits",
  "kind": "def",
  "doc_string":
  "Additive units of an additive monoid have an addition and an additive identity.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Monoid M] {x : M} (m : ℕ) {n : ℕ}, x ^ n = 1 → x ^ m = x ^ (m % n)",
  "name": "pow_eq_pow_mod",
  "kind": "theorem",
  "doc_string": "If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α},\n  a + b < c → a < c - b",
  "name": "lt_sub_right_of_add_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `lt_sub_iff_add_lt`.",
  "args": ""},
 {"type": "Linarith.LinarithM Linarith.PCompSet",
  "name": "Linarith.getPCompSet",
  "kind": "def",
  "doc_string": "Return the current comparison set. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemigroup α] {a b : α} (c : α), c * a = b → a ∣ b",
  "name": "dvd_of_mul_left_eq",
  "kind": "theorem",
  "doc_string": "**Alias** of `Dvd.intro_left`.",
  "args": ""},
 {"type": "Sat.Fmla → Sat.Fmla → Prop",
  "name": "Sat.Fmla.subsumes",
  "kind": "inductive",
  "doc_string":
  "Formula `f` subsumes `f'` if all the clauses in `f'` are in `f`.\nWe use this to prove that all clauses in the formula are subsumed by it. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : LT α] → [inst : WellFoundedGT α] → WellFoundedRelation α",
  "name": "WellFoundedGT.toWellFoundedRelation",
  "kind": "def",
  "doc_string":
  "Derive a `WellFoundedRelation` instance from a `WellFoundedGT` instance. ",
  "args": ""},
 {"type": "{α : Type u} → [self : Append α] → α → α → α",
  "name": "Append.append",
  "kind": "def",
  "doc_string":
  "`a ++ b` is the result of concatenation of `a` and `b`. See `HAppend`. ",
  "args": ""},
 {"type": "Type u → ℕ → Type u",
  "name": "Vector",
  "kind": "def",
  "doc_string":
  "`Vector α n` is the type of lists of length `n` with elements of type `α`. ",
  "args": ""},
 {"type": "ℤ → ℤ → ℤ",
  "name": "Int.ediv",
  "kind": "def",
  "doc_string":
  "Integer division. This version of `Int.div` uses the E-rounding convention\n(euclidean division), in which `Int.emod x y` satisfies `0 ≤ mod x y < natAbs y` for `y ≠ 0`\nand `Int.ediv` is the unique function satisfying `emod x y + (ediv x y) * y = x`.\n",
  "args": ""},
 {"type":
  "{t t' : Type u → Type u} →\n  (eqv : (α : Type u) → t α ≃ t' α) → [inst : Traversable t] → [inst_1 : IsLawfulTraversable t] → IsLawfulTraversable t'",
  "name": "Equiv.isLawfulTraversable",
  "kind": "def",
  "doc_string":
  "The fact that `t` is a lawful traversable functor carries over the\nequivalences to `t'`, with the traversable functor structure given by\n`Equiv.traversable`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] →\n        {S : Type u_3} →\n          [inst_2 : SetLike S N] →\n            [inst_3 : SubmonoidClass S N] → (f : M →* N) → (s : S) → (∀ (x : M), ↑f x ∈ s) → M →* { x // x ∈ s }",
  "name": "MonoidHom.codRestrict",
  "kind": "def",
  "doc_string": "Restriction of a monoid hom to a submonoid of the codomain. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] (a : α), a * 0 = 0",
  "name": "CanonicallyOrderedCommSemiring.mul_zero",
  "kind": "def",
  "doc_string": "Zero is a right absorbing element for multiplication ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Polyrith.Poly → Mathlib.Tactic.Polyrith.Poly → Mathlib.Tactic.Polyrith.Poly",
  "name": "Mathlib.Tactic.Polyrith.Poly.mul'",
  "kind": "def",
  "doc_string":
  "Multiplies two polynomials, performing some simple simplifications for presentation like\n`1 * a = a`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Conv.dischargeConv",
  "kind": "def",
  "doc_string":
  "* `discharge => tac` is a conv tactic which rewrites target `p` to `True` if `tac` is a tactic\n  which proves the goal `⊢ p`.\n* `discharge` without argument returns `⊢ p` as a subgoal.\n",
  "args": ""},
 {"type": "{α : Type u_1} → α ↪ WithTop α",
  "name": "Function.Embedding.coeWithTop",
  "kind": "def",
  "doc_string": "Embedding into `WithTop α`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : PartialOrder α] [inst_1 : Preorder β] {ψ : α → β} [inst_2 : SuccOrder α]\n  [inst_3 : IsSuccArchimedean α] {n : α}, (∀ (m : α), m < n → ψ m < ψ (Order.succ m)) → StrictMonoOn ψ (Set.Iic n)",
  "name": "strictMonoOn_Iic_of_lt_succ",
  "kind": "theorem",
  "doc_string":
  "A function `ψ` on a `SuccOrder` is strictly monotone before some `n` if for all `m` such that\n`m < n`, we have `ψ m < ψ (succ m)`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {s₁ : Setoid α} →\n        {s₂ : Setoid β} →\n          {s₃ : Setoid γ} →\n            (f : α → β → γ) →\n              Relator.LiftFun Setoid.r (Setoid.r ⇒ Setoid.r) f f → Quotient s₁ → Quotient s₂ → Quotient s₃",
  "name": "Quotient.map₂'",
  "kind": "def",
  "doc_string":
  "A version of `Quotient.map₂` using curly braces and unification. ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {F G : C ⥤ D}\n  (α : F ⟶ G) [inst_2 : ∀ (X : C), CategoryTheory.Epi (CategoryTheory.NatTrans.app α X)], CategoryTheory.Epi α",
  "name": "CategoryTheory.NatTrans.epi_of_epi_app",
  "kind": "theorem",
  "doc_string":
  "A natural transformation is an epimorphism if each component is. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : ConditionallyCompleteLattice α] (s : Set α) (a : α),\n  Set.Nonempty s → a ∈ upperBounds s → supₛ s ≤ a",
  "name": "ConditionallyCompleteLattice.csupₛ_le",
  "kind": "def",
  "doc_string": "`supₛ s ≤ a` for all `a ∈ upperBounds s`. ",
  "args": ""},
 {"type": "{α σ : Type u} → σ → DoResultSBC α σ",
  "name": "DoResultSBC.break",
  "kind": "def",
  "doc_string":
  "`break s` means that `break` was called, meaning that we should exit\nfrom the containing loop ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → (e : Q(«$α»)) → Mathlib.Meta.NormNum.Result e",
  "name": "Mathlib.Meta.NormNum.Result.ofRawNat",
  "kind": "def",
  "doc_string":
  "Constructs a `Result` out of a raw nat cast. Assumes `e` is a raw nat cast expression. ",
  "args": ""},
 {"type":
  "{C : ℕ → Sort u_1} → C 0 → ((b : Bool) → (n : ℕ) → (n = 0 → b = true) → C n → C (Nat.bit b n)) → (n : ℕ) → C n",
  "name": "Nat.binaryRec'",
  "kind": "def",
  "doc_string":
  "The same as `binaryRec`, but the induction step can assume that if `n=0`,\nthe bit being appended is `true`",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Fintype",
  "kind": "inductive",
  "doc_string":
  "`Fintype α` means that `α` is finite, i.e. there are only\nfinitely many distinct elements of type `α`. The evidence of this\nis a finset `elems` (a list up to permutation without duplicates),\ntogether with a proof that everything of type `α` is in the list. ",
  "args": ""},
 {"type": "Linarith.Comp → Linarith.Linexp",
  "name": "Linarith.Comp.coeffs",
  "kind": "def",
  "doc_string":
  "The coefficients of the comparison, stored as list of pairs `(i, a)`,\nwhere `i` is the index of a recorded atom, and `a` is the coefficient. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Zero M₂] →\n      [inst_1 : One M₂] →\n        [inst_2 : Add M₂] →\n          [inst_3 : SMul ℕ M₂] →\n            [inst_4 : NatCast M₂] →\n              [inst_5 : AddMonoidWithOne M₁] →\n                (f : M₁ → M₂) →\n                  Function.Surjective f →\n                    f 0 = 0 →\n                      f 1 = 1 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) → (∀ (n : ℕ), f ↑n = ↑n) → AddMonoidWithOne M₂",
  "name": "Function.Surjective.addMonoidWithOne",
  "kind": "def",
  "doc_string":
  "A type endowed with `0`, `1` and `+` is an additive monoid with one, if it admits a surjective\nmap that preserves `0`, `1` and `*` from an additive monoid with one. See note\n[reducible non-instances]. ",
  "args": ""},
 {"type":
  "{C : Type u} → [inst : CategoryTheory.Category C] → {X Y : C} → (f : X ⟶ Y) → [I : CategoryTheory.IsIso f] → Y ⟶ X",
  "name": "CategoryTheory.inv",
  "kind": "def",
  "doc_string": "The inverse of a morphism `f` when we have `[IsIso f]`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {s : Set α} {b : α},\n  (∀ (a : α), a ∈ s → b ≤ a) → (∀ (w : α), b < w → ∃ a, a ∈ s ∧ a < w) → infₛ s = b",
  "name": "infₛ_eq_of_forall_ge_of_forall_gt_exists_lt",
  "kind": "theorem",
  "doc_string":
  "Introduction rule to prove that `b` is the infimum of `s`: it suffices to check that `b`\nis smaller than all elements of `s`, and that this is not the case of any `w > b`.\nSee `cinfₛ_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in conditionally complete\nlattices. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {φ : Sort u_2} → {s₁ : Setoid α} → Quotient s₁ → (f : α → φ) → (∀ (a b : α), Setoid.r a b → f a = f b) → φ",
  "name": "Quotient.liftOn'",
  "kind": "def",
  "doc_string":
  "A version of `Quotient.liftOn` taking `{s : Setoid α}` as an implicit argument instead of an\ninstance argument. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Mul α] →\n    [inst_1 : LinearOrder α] → [inst : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] → α → α ↪o α",
  "name": "OrderEmbedding.mulLeft",
  "kind": "def",
  "doc_string":
  "The order embedding sending `b` to `a * b`, for some fixed `a`.\nSee also `OrderIso.mulLeft` when working in an ordered group. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} (M : Type u_2) [inst : Monoid R] [inst_1 : MulAction R M] (a : Rˣ), IsSMulRegular M ↑a",
  "name": "Units.isSMulRegular",
  "kind": "theorem",
  "doc_string": "Any element in `Rˣ` is `M`-regular. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → List α → α → List α → Array α → List α",
  "name": "List.eraseTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `eraseTR`: `eraseTR.go l a xs acc = acc.toList ++ erase xs a`,\nunless `a` is not present in which case it returns `l` ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term{_:_//_}»",
  "kind": "def",
  "doc_string":
  "`Subtype p`, usually written as `{x : α // p x}`, is a type which\nrepresents all the elements `x : α` for which `p x` is true. It is structurally\na pair-like type, so if you have `x : α` and `h : p x` then\n`⟨x, h⟩ : {x // p x}`. An element `s : {x // p x}` will coerce to `α` but\nyou can also make it explicit using `s.1` or `s.val`.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : MulZeroClass R], IsLeftRegular 0 → Subsingleton R",
  "name": "IsLeftRegular.subsingleton",
  "kind": "theorem",
  "doc_string":
  "The element `0` is left-regular if and only if `R` is trivial. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : HasSSubset α]\n  [inst_2 : IsNonstrictStrictOrder α (fun x x_1 => x ⊆ x_1) fun x x_1 => x ⊂ x_1] {a b : α}\n  [inst_3 : IsAntisymm α fun x x_1 => x ⊆ x_1], a ⊆ b → a ≠ b → a ⊂ b",
  "name": "HasSubset.Subset.ssubset_of_ne",
  "kind": "theorem",
  "doc_string": "**Alias** of `ssubset_of_subset_of_ne`.",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type u_1} →\n    [inst : LinearOrderedRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Neg β] →\n                [inst_6 : Sub β] →\n                  [inst_7 : SMul ℕ β] →\n                    [inst_8 : SMul ℤ β] →\n                      [inst_9 : Pow β ℕ] →\n                        [inst_10 : NatCast β] →\n                          [inst_11 : IntCast β] →\n                            [inst_12 : HasSup β] →\n                              [inst_13 : HasInf β] →\n                                (f : β → α) →\n                                  Function.Injective f →\n                                    f 0 = 0 →\n                                      f 1 = 1 →\n                                        (∀ (x y : β), f (x + y) = f x + f y) →\n                                          (∀ (x y : β), f (x * y) = f x * f y) →\n                                            (∀ (x : β), f (-x) = -f x) →\n                                              (∀ (x y : β), f (x - y) = f x - f y) →\n                                                (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                                  (∀ (x : β) (n : ℤ), f (n • x) = n • f x) →\n                                                    (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                      (∀ (n : ℕ), f ↑n = ↑n) →\n                                                        (∀ (n : ℤ), f ↑n = ↑n) →\n                                                          (∀ (x y : β), f (x ⊔ y) = max (f x) (f y)) →\n                                                            (∀ (x y : β), f (x ⊓ y) = min (f x) (f y)) →\n                                                              LinearOrderedRing β",
  "name": "Function.Injective.linearOrderedRing",
  "kind": "def",
  "doc_string": "Pullback a `LinearOrderedRing` under an injective map. ",
  "args": ""},
 {"type": "Simps.Config → Bool",
  "name": "Simps.Config.simpRhs",
  "kind": "def",
  "doc_string":
  "simplify the right-hand side of generated simp-lemmas using `dsimp, simp`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Add M] {S T : AddSubsemigroup M}, (∀ (x : M), x ∈ S ↔ x ∈ T) → S = T",
  "name": "AddSubsemigroup.ext",
  "kind": "theorem",
  "doc_string":
  "Two `AddSubsemigroup`s are equal if they have the same elements.",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : NonAssocRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Neg β] →\n                [inst_6 : Sub β] →\n                  [inst_7 : SMul ℕ β] →\n                    [inst_8 : SMul ℤ β] →\n                      [inst_9 : NatCast β] →\n                        [inst_10 : IntCast β] →\n                          (f : α → β) →\n                            Function.Surjective f →\n                              f 0 = 0 →\n                                f 1 = 1 →\n                                  (∀ (x y : α), f (x + y) = f x + f y) →\n                                    (∀ (x y : α), f (x * y) = f x * f y) →\n                                      (∀ (x : α), f (-x) = -f x) →\n                                        (∀ (x y : α), f (x - y) = f x - f y) →\n                                          (∀ (x : α) (n : ℕ), f (n • x) = n • f x) →\n                                            (∀ (x : α) (n : ℤ), f (n • x) = n • f x) →\n                                              (∀ (n : ℕ), f ↑n = ↑n) → (∀ (n : ℤ), f ↑n = ↑n) → NonAssocRing β",
  "name": "Function.Surjective.nonAssocRing",
  "kind": "def",
  "doc_string":
  "Pushforward a `NonAssocRing` instance along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Num → Num",
  "name": "Num.pred",
  "kind": "def",
  "doc_string": "The predecessor of a `Num` as a `Num`, where `pred 0 = 0`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Monoid M] → [inst_1 : Monoid N] → [inst_2 : MulAction M N] → [inst_3 : IsScalarTower M N N] → M →* N",
  "name": "smulOneHom",
  "kind": "def",
  "doc_string":
  "If the multiplicative action of `M` on `N` is compatible with multiplication on `N`, then\n`fun x => x • 1` is a monoid homomorphism from `M` to `N`. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ},\n  Function.Bijective g → Function.Bijective ((fun x x_1 => x ∘ x_1) g)",
  "name": "Function.Bijective.comp_left",
  "kind": "theorem",
  "doc_string":
  "Composition by an bijective function on the left is itself bijective. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Linarith.mk_coe_nat_nonneg_prf",
  "kind": "def",
  "doc_string": "If `e : ℕ`, returns a proof of `0 ≤ (e : ℤ)`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : NonUnitalNonAssocSemiring α] → [inst_1 : NonUnitalNonAssocSemiring β] → (α →ₙ+* β) → α →ₙ* β",
  "name": "NonUnitalRingHom.toMulHom",
  "kind": "def",
  "doc_string":
  "Reinterpret a non-unital ring homomorphism `f : α →ₙ+* β` as a semigroup\nhomomorphism `α →ₙ* β`. The `simp`-normal form is `(f : α →ₙ* β)`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → {S : Type u_2} → [inst : NonAssocSemiring R] → [inst_1 : NonAssocSemiring S] → R ≃+* S → R →+ S",
  "name": "RingEquiv.toAddMonoidHom",
  "kind": "def",
  "doc_string":
  "Reinterpret a ring equivalence as an `AddMonoid` homomorphism. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tacticEconstructor",
  "kind": "def",
  "doc_string":
  "`econstructor` is like `constructor`\n(it calls `apply` using the first matching constructor of an inductive datatype)\nexcept only non-dependent premises are added as new goals.\n",
  "args": ""},
 {"type": "Num → Num",
  "name": "Num.succ",
  "kind": "def",
  "doc_string": "The successor of a `Num` as a `Num`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α] (a b c : α), a < b → 0 < c → c * a < c * b",
  "name": "CanonicallyLinearOrderedSemifield.mul_lt_mul_of_pos_left",
  "kind": "def",
  "doc_string":
  "Left multiplication by a positive element is strictly monotone. ",
  "args": ""},
 {"type":
  "{V : Type u_1} → [inst : Quiver V] → WideSubquiver (Quiver.Symmetrify V) → WideSubquiver V",
  "name": "Quiver.wideSubquiverSymmetrify",
  "kind": "def",
  "doc_string":
  "A wide subquiver `H` of `Symmetrify V` determines a wide subquiver of `V`, containing an\nan arrow `e` if either `e` or its reversal is in `H`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : One M] [inst_1 : One N] (f : OneHom M N) {x y : M}, x = y → ↑f x = ↑f y",
  "name": "OneHom.congr_arg",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.congr_arg` instead. ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.Context →\n  (Lean.Expr → Lean.MetaM (Mathlib.Tactic.Abel.NormalExpr × Lean.Expr)) →\n    Bool → Lean.Expr → Lean.Expr → Lean.Expr → Lean.MetaM (Mathlib.Tactic.Abel.NormalExpr × Lean.Expr)",
  "name": "Mathlib.Tactic.Abel.evalSMul'",
  "kind": "def",
  "doc_string":
  "Normalize a term `orig` of the form `smul e₁ e₂` or `smulg e₁ e₂`.\nNormalized terms use `smul` for monoids and `smulg` for groups,\nso there are actually four cases to handle:\n* Using `smul` in a monoid just simplifies the pieces using `subst_into_smul`\n* Using `smulg` in a group just simplifies the pieces using `subst_into_smulg`\n* Using `smul a b` in a group requires converting `a` from a nat to an int and\n  then simplifying `smulg ↑a b` using `subst_into_smul_upcast`\n* Using `smulg` in a monoid is impossible (or at least out of scope),\n  because you need a group argument to write a `smulg` term ",
  "args": ""},
 {"type": "{α : Sort u_1} → Nonempty α → Erased α",
  "name": "Erased.choice",
  "kind": "def",
  "doc_string":
  "Computably produce an erased value from a proof of nonemptiness. ",
  "args": ""},
 {"type": "(α : Type u_1) → (β : Type u_2) → [inst : Unique β] → α × β ≃ α",
  "name": "Equiv.prodUnique",
  "kind": "def",
  "doc_string":
  "Any `Unique` type is a right identity for type product up to equivalence. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : LinearOrder α] →\n    (succ : α → α) →\n      (∀ {a : α}, ¬IsMax a → ∀ (b : α), a < b ↔ succ a ≤ b) → (∀ (a : α), IsMax a → succ a = a) → SuccOrder α",
  "name": "SuccOrder.ofCore",
  "kind": "def",
  "doc_string": "A constructor for `SuccOrder α` for `α` a linear order. ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : AddMonoid M] → AddAction M M",
  "name": "AddMonoid.toAddAction",
  "kind": "def",
  "doc_string":
  "The regular action of a monoid on itself by left addition.\n\nThis is promoted to an `AddTorsor` by `addGroup_is_addTorsor`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {s t : Set α} → [inst : DecidablePred fun x => x ∈ s] → s ∩ t ⊆ ∅ → ↑(s ∪ t) ≃ ↑s ⊕ ↑t",
  "name": "Equiv.Set.union",
  "kind": "def",
  "doc_string":
  "If sets `s` and `t` are disjoint, then `s ∪ t` is equivalent to `s ⊕ t`. ",
  "args": ""},
 {"type":
  "Option (Lean.Syntax.TSepArray `Lean.Parser.Tactic.simpStar \",\") →\n  Lean.Expr → Lean.Expr → Lean.Elab.Tactic.TacticM (Lean.Expr × Lean.Expr)",
  "name": "Mathlib.Tactic.Zify.zifyProof",
  "kind": "def",
  "doc_string": "Translate a proof and the proposition into a zified form. ",
  "args": ""},
 {"type":
  "(α : Type u_1) →\n  [H1 : PartialOrder α] →\n    [H2 : SupSet α] →\n      (∀ (a b : α), BddAbove {a, b}) →\n        (∀ (a b : α), BddBelow {a, b}) →\n          (∀ (s : Set α), BddAbove s → Set.Nonempty s → IsLUB s (supₛ s)) → ConditionallyCompleteLattice α",
  "name": "conditionallyCompleteLatticeOfSupₛ",
  "kind": "def",
  "doc_string":
  "Create a `ConditionallyCompleteLattice` from a `PartialOrder` and `sup` function\nthat returns the least upper bound of a nonempty set which is bounded above. Usually this\nconstructor provides poor definitional equalities.  If other fields are known explicitly, they\nshould be provided; for example, if `inf` is known explicitly, construct the\n`ConditionallyCompleteLattice` instance as\n```\ninstance : ConditionallyCompleteLattice my_T :=\n{ inf := better_inf,\n  le_inf := ...,\n  inf_le_right := ...,\n  inf_le_left := ...\n  -- don't care to fix sup, infₛ\n  ..conditionallyCompleteLatticeOfSupₛ my_T _ }\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulMono α],\n  a ≤ 1 → b ≤ 1 → 0 ≤ a → a * b ≤ 1",
  "name": "Left.mul_le_one_of_le_of_le",
  "kind": "theorem",
  "doc_string": "Assumes left covariance. ",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (n : ℕ) (a : G₀),\n  GroupWithZero.zpow (Int.negSucc n) a = (GroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹",
  "name": "GroupWithZero.zpow_neg'",
  "kind": "def",
  "doc_string": "`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` ",
  "args": ""},
 {"type": "(α : Type u_1) → (β : Type u_2) → α × β ≃ β × α",
  "name": "Equiv.prodComm",
  "kind": "def",
  "doc_string":
  "Type product is commutative up to an equivalence: `α × β ≃ β × α`. This is `Prod.swap` as an\nequivalence.",
  "args": ""},
 {"type": "Mathlib.Meta.NormNum.NormNumExt",
  "name": "Mathlib.Meta.NormNum.evalOfNat",
  "kind": "def",
  "doc_string":
  "The `norm_num` extension which identifies an expression `OfNat.ofNat n`, returning `n`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Monoid",
  "kind": "inductive",
  "doc_string":
  "A `Monoid` is a `Semigroup` with an element `1` such that `1 * a = a * 1 = a`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : CanonicallyLinearOrderedAddMonoid α] → DecidableRel fun x x_1 => x < x_1",
  "name": "CanonicallyLinearOrderedAddMonoid.decidable_lt",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "Array ℤ → Lean.Expr",
  "name": "Mathlib.Tactic.Sat.buildClause",
  "kind": "def",
  "doc_string":
  "Construct the clause expression from the input list. For example `[1, -2]` is translated to\n`Clause.cons (Literal.pos 1) (Clause.cons (Literal.neg 2) Clause.nil)`. ",
  "args": ""},
 {"type": "Ring ℤ",
  "name": "Mathlib.Meta.NormNum.instRingInt",
  "kind": "def",
  "doc_string":
  "A shortcut (non)instance for `Ring ℤ` to shrink generated proofs. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → {β : Type u_2} → (b : β) → Function.Surjective (Function.const α b) → Unique β",
  "name": "Function.Surjective.uniqueOfSurjectiveConst",
  "kind": "def",
  "doc_string":
  "If a constant function is surjective, then the codomain is a singleton. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (e : M ≃+ N) (x : M), ↑(AddEquiv.symm e) (↑e x) = x",
  "name": "AddEquiv.symm_apply_apply",
  "kind": "theorem",
  "doc_string":
  "`e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`.",
  "args": ""},
 {"type":
  "Option (Lean.Syntax.TSepArray `Lean.Parser.Tactic.simpStar \",\") →\n  Lean.Elab.Tactic.TacticM Lean.Elab.Tactic.MkSimpContextResult",
  "name": "Mathlib.Tactic.Zify.mkZifyContext",
  "kind": "def",
  "doc_string": "The `Simp.Context` generated by `zify`. ",
  "args": ""},
 {"type": "Linarith.CompSource → String",
  "name": "Linarith.CompSource.toString",
  "kind": "def",
  "doc_string": "Formats a `CompSource` for printing. ",
  "args": ""},
 {"type": "∀ {n : ℕ} (self : Fin n), ↑self < n",
  "name": "Fin.isLt",
  "kind": "def",
  "doc_string": "If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    [inst : Semiring R] → [inst_1 : Semiring S] → (f : R →+* S) → (∀ (x y : R), Commute (↑f x) (↑f y)) → R →+* Sᵐᵒᵖ",
  "name": "RingHom.toOpposite",
  "kind": "def",
  "doc_string":
  "A ring homomorphism `f : R →+* S` such that `f x` commutes with `f y` for all `x, y` defines\na ring homomorphism to `Sᵐᵒᵖ`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Monoid α] → (u : αˣ) → Invertible ↑u",
  "name": "Units.invertible",
  "kind": "def",
  "doc_string": "Units are invertible in their associated monoid. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1],\n  StrictMonoOn f s → StrictMonoOn g s → StrictMonoOn (fun x => f x * g x) s",
  "name": "StrictMonoOn.mul'",
  "kind": "theorem",
  "doc_string":
  "The product of two strictly monotone functions is strictly monotone. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] (f : M →* N) {x y : M},\n  x = y → ↑f x = ↑f y",
  "name": "MonoidHom.congr_arg",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.congr_arg` instead. ",
  "args": ""},
 {"type": "{α : Type u} → Array α",
  "name": "Array.mkArray0",
  "kind": "def",
  "doc_string": "Create array `#[]` ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) → IsRegular (b * a) → IsRegular a ∧ IsRegular b",
  "name": "IsRegular.and_of_mul_of_mul",
  "kind": "theorem",
  "doc_string":
  "The \"most used\" implication of `mul_and_mul_iff`, with split hypotheses, instead of `∧`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} →\n      [inst : Mul M] → [inst_1 : Mul N] → [inst_2 : CommSemigroup P] → (M →ₙ* P) → (N →ₙ* P) → M × N →ₙ* P",
  "name": "MulHom.coprod",
  "kind": "def",
  "doc_string":
  "Coproduct of two `MulHom`s with the same codomain:\n`f.coprod g (p : M × N) = f p.1 * g p.2`. ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] (self : C ⥤ D)\n  {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z),\n  Prefunctor.map self.toPrefunctor (f ≫ g) = Prefunctor.map self.toPrefunctor f ≫ Prefunctor.map self.toPrefunctor g",
  "name": "CategoryTheory.Functor.map_comp",
  "kind": "def",
  "doc_string": "A functor preserves composition. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Distrib",
  "kind": "inductive",
  "doc_string":
  "A typeclass stating that multiplication is left and right distributive\nover addition. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, b < c → a < b → a < c",
  "name": "LT.lt.trans'",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_trans'`.",
  "args": ""},
 {"type":
  "Type u_1 →\n  (M : outParam (Type u_2)) → (N : outParam (Type u_3)) → [inst : One M] → [inst : One N] → Type (max (max u_1 u_2) u_3)",
  "name": "OneHomClass",
  "kind": "inductive",
  "doc_string":
  "`OneHomClass F M N` states that `F` is a type of one-preserving homomorphisms.\nYou should extend this typeclass when you extend `OneHom`.\n",
  "args": ""},
 {"type": "PosNum → PosNum",
  "name": "PosNum.pred",
  "kind": "def",
  "doc_string":
  "The predecessor of a `PosNum` as a `PosNum`. This means that `pred 1 = 1`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Antitone f → Monotone (f ∘ ↑OrderDual.ofDual)",
  "name": "Antitone.dual_left",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `monotone_comp_ofDual_iff`.",
  "args": ""},
 {"type": "ℕ → PosNum",
  "name": "PosNum.ofNat",
  "kind": "def",
  "doc_string":
  "`ofNat n` is the `PosNum` corresponding to `n`, except for `ofNat 0 = 1`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : LE α] → Type u_1",
  "name": "Flag",
  "kind": "inductive",
  "doc_string": "The type of flags, aka maximal chains, of an order. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Preorder α] → Set α → α → Prop",
  "name": "IsLUB",
  "kind": "def",
  "doc_string":
  "`a` is a least upper bound of a set `s`; for a partial order, it is unique if exists. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.RingNF.tacticRing1_nf!_",
  "kind": "def",
  "doc_string":
  "Tactic for solving equations of *commutative* (semi)rings, allowing variables in the exponent.\n\n* This version of `ring1` uses `ring_nf` to simplify in atoms.\n* The variant `ring1_nf!` will use a more aggressive reducibility setting\n  to determine equality of atoms.\n",
  "args": ""},
 {"type":
  "∀ {φ : Type w₁} {σ : Type w₂} {α : Type u_1} {β : Type u_2} (f : α → β → σ → σ × φ) (x : List α) (y : List β) (c : σ),\n  List.length (List.mapAccumr₂ f x y c).snd = min (List.length x) (List.length y)",
  "name": "List.length_mapAccumr₂",
  "kind": "theorem",
  "doc_string": "Length of a list obtained using `mapAccumr₂`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] → {F : Type u_3} → [mc : AddMonoidHomClass F M N] → F → AddSubmonoid N → AddSubmonoid M",
  "name": "AddSubmonoid.comap",
  "kind": "def",
  "doc_string":
  "The preimage of an `AddSubmonoid` along an `AddMonoid` homomorphism is an `AddSubmonoid`.",
  "args": ""},
 {"type": "{α : Type u} → [inst : AddMonoid α] → α →+ WithTop α",
  "name": "WithTop.addHom",
  "kind": "def",
  "doc_string": "Coercion from `α` to `WithTop α` as an `AddMonoidHom`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddMonoid M] → (u : AddUnits M) → (a b : M) → a + b = ↑u → AddCommute a b → AddUnits M",
  "name": "AddUnits.rightOfAdd",
  "kind": "def",
  "doc_string":
  "If the sum of two commuting elements is an additive unit, then the right summand\nis an additive unit.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : InfSet α] → {ι : Sort u_2} → (ι → α) → α",
  "name": "infᵢ",
  "kind": "def",
  "doc_string": "Indexed infimum ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "name": "le_trans",
  "kind": "theorem",
  "doc_string": "The relation `≤` on a preorder is transitive. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "WithBot",
  "kind": "def",
  "doc_string": "Attach `⊥` to a type. ",
  "args": ""},
 {"type":
  "∀ {β : Type u_1} [inst : ConditionallyCompleteLattice β] {s : Set (WithTop β)}, BddBelow s → IsGLB s (infₛ s)",
  "name": "WithTop.isGLB_infₛ'",
  "kind": "theorem",
  "doc_string":
  "The `infₛ` of a bounded-below set is its greatest lower bound for a conditionally\ncomplete lattice with a top. ",
  "args": ""},
 {"type":
  "∀ (G : Type u) [inst : AddCommSemigroup G] [inst_1 : IsLeftCancelAdd G], IsCancelAdd G",
  "name": "AddCommSemigroup.IsLeftCancelAdd.toIsCancelAdd",
  "kind": "theorem",
  "doc_string":
  "Any\n`AddCommSemigroup G` that satisfies `IsLeftCancelAdd G` also satisfies\n`IsCancelAdd G`.",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → α → β",
  "name": "unsafeCast",
  "kind": "def",
  "doc_string":
  "This function will cast a value of type `α` to type `β`, and is a no-op in the\ncompiler. This function is **extremely dangerous** because there is no guarantee\nthat types `α` and `β` have the same data representation, and this can lead to\nmemory unsafety. It is also logically unsound, since you could just cast\n`True` to `False`. For all those reasons this function is marked as `unsafe`.\n\nIt is implemented by lifting both `α` and `β` into a common universe, and then\nusing `cast (lcProof : ULift (PLift α) = ULift (PLift β))` to actually perform\nthe cast. All these operations are no-ops in the compiler.\n\nUsing this function correctly requires some knowledge of the data representation\nof the source and target types. Some general classes of casts which are safe in\nthe current runtime:\n\n* `Array α` to `Array β` where `α` and `β` have compatible representations,\n  or more generally for other inductive types.\n* `Quot α r` and `α`.\n* `@Subtype α p` and `α`, or generally any structure containing only one\n  non-`Prop` field of type `α`.\n* Casting `α` to/from `NonScalar` when `α` is a boxed generic type\n  (i.e. a function that accepts an arbitrary type `α` and is not specialized to\n  a scalar type like `UInt8`).\n",
  "args": ""},
 {"type":
  "∀ {X : Type u} {m₁ m₂ : X → X → X} {e₁ e₂ : X},\n  EckmannHilton.IsUnital m₁ e₁ →\n    EckmannHilton.IsUnital m₂ e₂ → (∀ (a b c d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) → IsCommutative X m₂",
  "name": "EckmannHilton.mul_comm",
  "kind": "theorem",
  "doc_string":
  "If a type carries two unital binary operations that distribute over each other,\nthen these operations are commutative.\n\nIn fact, they give a commutative monoid structure, see `eckmann_hilton.CommMonoid`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      [inst : NonUnitalNonAssocSemiring α] →\n        [inst_1 : NonUnitalNonAssocSemiring β] → {x : NonUnitalNonAssocSemiring γ} → (β →ₙ+* γ) → (α →ₙ+* β) → α →ₙ+* γ",
  "name": "NonUnitalRingHom.comp",
  "kind": "def",
  "doc_string":
  "Composition of non-unital ring homomorphisms is a non-unital ring homomorphism. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} {M : Type u_2} {inst : Add M} {inst_1 : SetLike S M} [self : AddMemClass S M] {s : S} {a b : M},\n  a ∈ s → b ∈ s → a + b ∈ s",
  "name": "AddMemClass.add_mem",
  "kind": "def",
  "doc_string":
  "A substructure satisfying `AddMemClass` is closed under addition. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Lattice α] → [inst_1 : IsModularLattice α] → (a b : α) → ↑(Set.Icc (a ⊓ b) a) ≃o ↑(Set.Icc b (a ⊔ b))",
  "name": "infIccOrderIsoIccSup",
  "kind": "def",
  "doc_string":
  "The diamond isomorphism between the intervals `[a ⊓ b, a]` and `[b, a ⊔ b]` ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : LE α] → [inst : LE β] → Type (max u_1 u_2)",
  "name": "OrderEmbedding",
  "kind": "def",
  "doc_string":
  "An order embedding is an embedding `f : α ↪ β` such that `a ≤ b ↔ (f a) ≤ (f b)`.\nThis definition is an abbreviation of `RelEmbedding (≤) (≤)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {P : (l₁ l₂ : List α) → l₁ ~ l₂ → Prop} {l₁ l₂ : List α} (p : l₁ ~ l₂),\n  P [] [] (_ : [] ~ []) →\n    (∀ (x : α) (l₁ l₂ : List α) (h : l₁ ~ l₂), P l₁ l₂ h → P (x :: l₁) (x :: l₂) (_ : x :: l₁ ~ x :: l₂)) →\n      (∀ (x y : α) (l₁ l₂ : List α) (h : l₁ ~ l₂),\n          P l₁ l₂ h → P (y :: x :: l₁) (x :: y :: l₂) (_ : y :: x :: l₁ ~ x :: y :: l₂)) →\n        (∀ (l₁ l₂ l₃ : List α) (h₁ : l₁ ~ l₂) (h₂ : l₂ ~ l₃), P l₁ l₂ h₁ → P l₂ l₃ h₂ → P l₁ l₃ (_ : l₁ ~ l₃)) →\n          P l₁ l₂ p",
  "name": "List.perm_induction_on",
  "kind": "theorem",
  "doc_string":
  "The way Lean 4 computes the motive with `elab_as_elim` has changed\nrelative to the behaviour of `elab_as_eliminator` in Lean 3.\nSee\nhttps://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Potential.20elaboration.20bug.20with.20.60elabAsElim.60/near/299573172\nfor an explanation of the change made here relative to mathlib3.\n",
  "args": ""},
 {"type": "{α : Type u_1} → List α → ℕ → α → List α",
  "name": "List.setTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `erase`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {C : WithZero α → Sort u_1} → C 0 → ((a : α) → C ↑a) → (n : WithZero α) → C n",
  "name": "WithZero.recZeroCoe",
  "kind": "def",
  "doc_string":
  "Recursor for `WithZero` using the preferred forms `0` and `↑a`.",
  "args": ""},
 {"type": "{α : Type u} → [inst : Monoid α] → [inst_1 : Repr α] → Repr αˣ",
  "name": "Units.instReprUnits",
  "kind": "def",
  "doc_string":
  "Units of a monoid have a representation of the base value in the `Monoid`. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → a * b = b * a",
  "name": "Commute.eq",
  "kind": "theorem",
  "doc_string": "Equality behind `Commute a b`; useful for rewriting. ",
  "args": ""},
 {"type": "{p : ℕ → Prop} → [inst : DecidablePred p] → (∃ n, p n) → ℕ",
  "name": "Nat.find",
  "kind": "def",
  "doc_string":
  "If `p` is a (decidable) predicate on `ℕ` and `hp : ∃ (n : ℕ), p n` is a proof that\nthere exists some natural number satisfying `p`, then `Nat.find hp` is the\nsmallest natural number satisfying `p`. Note that `Nat.find` is protected,\nmeaning that you can't just write `find`, even if the `Nat` namespace is open.\n\nThe API for `Nat.find` is:\n\n* `Nat.find_spec` is the proof that `Nat.find hp` satisfies `p`.\n* `Nat.find_min` is the proof that if `m < Nat.find hp` then `m` does not satisfy `p`.\n* `Nat.find_min'` is the proof that if `m` does satisfy `p` then `Nat.find hp ≤ m`.\n",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → {γ : Sort u_3} → {δ : Sort u_4} → α ≃ β → γ ≃ δ → PProd α γ ≃ PProd β δ",
  "name": "Equiv.pprodCongr",
  "kind": "def",
  "doc_string":
  "Product of two equivalences, in terms of `PProd`. If `α ≃ β` and `γ ≃ δ`, then\n`PProd α γ ≃ PProd β δ`. ",
  "args": ""},
 {"type": "Type",
  "name": "Sat.Fmla",
  "kind": "def",
  "doc_string":
  "A formula is a list of clauses, thought of as a conjunction like `(a ∨ b) ∧ c ∧ (¬c ∨ ¬d)`. ",
  "args": ""},
 {"type": "{ε σ α : Type u} → α → EStateM ε σ α",
  "name": "EStateM.pure",
  "kind": "def",
  "doc_string": "The `pure` operation of the `EStateM` monad. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1],\n  StrictAnti f → Antitone g → StrictAnti fun x => f x * g x",
  "name": "StrictAnti.mul_antitone'",
  "kind": "theorem",
  "doc_string":
  "The product of a strictly antitone function and a antitone function is strictly antitone. ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsWellOrder",
  "kind": "inductive",
  "doc_string": "A well order is a well-founded linear order. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        {M' : Type u_3} →\n          {N' : Type u_4} →\n            [inst_2 : AddZeroClass M'] → [inst_3 : AddZeroClass N'] → M ≃+ M' → N ≃+ N' → M × N ≃+ M' × N'",
  "name": "AddEquiv.prodCongr",
  "kind": "def",
  "doc_string":
  "Product of additive isomorphisms; the maps come from `equiv.prodCongr`.",
  "args": ""},
 {"type": "Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Tactic.PushNeg.pushNegTarget",
  "kind": "def",
  "doc_string": "Execute main loop of `push_neg` at the main goal. ",
  "args": ""},
 {"type": "{β : Type u_1} → {ι : Sort u_2} → (f : ι → β) → ι → ↑(Set.range f)",
  "name": "Set.rangeFactorization",
  "kind": "def",
  "doc_string":
  "Any map `f : ι → β` factors through a map `rangeFactorization f : ι → range f`. ",
  "args": ""},
 {"type":
  "List Linarith.GlobalBranchingPreprocessor → Lean.MVarId → List Lean.Expr → Lean.MetaM (List Linarith.Branch)",
  "name": "Linarith.preprocess",
  "kind": "def",
  "doc_string":
  "`preprocess pps l` takes a list `l` of proofs of propositions.\nIt maps each preprocessor `pp ∈ pps` over this list.\nThe preprocessors are run sequentially: each receives the output of the previous one.\nNote that a preprocessor may produce multiple or no expressions from each input expression,\nso the size of the list may change.\n",
  "args": ""},
 {"type":
  "{p : Bool → Prop} → [inst : (b : Bool) → Decidable (p b)] → Decidable (∃ b, p b)",
  "name": "Bool.decidableExistsBool",
  "kind": "def",
  "doc_string":
  "If `p b` is decidable for all `b : bool`, then `∃ b, p b` is decidable ",
  "args": ""},
 {"type": "{R : Type u_1} → (M : Type u_2) → [inst : SMul R M] → R → Prop",
  "name": "IsSMulRegular",
  "kind": "def",
  "doc_string":
  "An `M`-regular element is an element `c` such that multiplication on the left by `c` is an\ninjective map `M → M`. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.LinearCombination.Config",
  "kind": "inductive",
  "doc_string": "A configuration object for `linear_combination`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun x x_1 => x < x_1",
  "name": "LinearOrder.decidable_lt",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "LeftCancelSemigroup",
  "kind": "inductive",
  "doc_string":
  "A `LeftCancelSemigroup` is a semigroup such that `a * b = a * c` implies `b = c`. ",
  "args": ""},
 {"type":
  "{V : Type u} → [inst : Quiver V] → {W : Type u₂} → (V → W) → W → W → Type (max u u₂ v)",
  "name": "Quiver.PushQuiver",
  "kind": "inductive",
  "doc_string":
  "The quiver structure obtained by pushing arrows of `V` along the map `σ : V → W` ",
  "args": ""},
 {"type":
  "{n : ℕ} → (m : Fin (Nat.succ n)) → List { y // WellFoundedRelation.rel y m }",
  "name": "SlimCheck.Fin.shrink",
  "kind": "def",
  "doc_string":
  "`Fin.shrink` works like `Nat.shrink` but instead operates on `Fin`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → (α → β) → Set α → Prop",
  "name": "Set.EqOn",
  "kind": "def",
  "doc_string":
  "Two functions `f₁ f₂ : α → β` are equal on `s`\nif `f₁ x = f₂ x` for all `x ∈ s`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 2",
  "name": "zero_lt_two",
  "kind": "theorem",
  "doc_string": "See `zero_lt_two'` for a version with the type explicit. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → (p : α → Prop) → (q : Subtype p → Prop) → Subtype q ≃ { a // ∃ h, q { val := a, property := h } }",
  "name": "Equiv.subtypeSubtypeEquivSubtypeExists",
  "kind": "def",
  "doc_string":
  "A subtype of a subtype is equivalent to the subtype of elements satisfying both predicates. This\nversion allows the “inner” predicate to depend on `h : p a`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.casesType!",
  "kind": "def",
  "doc_string":
  "* `cases_type I` applies the `cases` tactic to a hypothesis `h : (I ...)`\n* `cases_type I_1 ... I_n` applies the `cases` tactic to a hypothesis\n  `h : (I_1 ...)` or ... or `h : (I_n ...)`\n* `cases_type* I` is shorthand for `· repeat cases_type I`\n* `cases_type! I` only applies `cases` if the number of resulting subgoals is <= 1.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current goal.\n```\ncases_type* Or And\n```\n",
  "args": ""},
 {"type":
  "∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} [self : CategoryTheory.IsIso f],\n  ∃ inv, f ≫ inv = 𝟙 X ∧ inv ≫ f = 𝟙 Y",
  "name": "CategoryTheory.IsIso.out",
  "kind": "def",
  "doc_string": "The existence of an inverse morphism. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Prelude.Rename.align",
  "kind": "def",
  "doc_string":
  "`#align lean_3.def_name Lean4.defName` will record an \"alignment\" from the lean 3 name\nto the corresponding lean 4 name. This information is used by the\n[mathport](https://github.com/leanprover-community/mathport) utility to translate later uses of\nthe definition.\n\nIf there is no alignment for a given definition, mathport will attempt to convert\nfrom the lean 3 `snake_case` style to `UpperCamelCase` for namespaces and types and\n`lowerCamelCase` for definitions, and `snake_case` for theorems. But for various reasons,\nit may fail either to determine whether it is a type, definition, or theorem, or to determine\nthat a specific definition is in fact being called. Or a specific definition may need a different\nname altogether because the existing name is already taken in lean 4 for something else. For\nthese reasons, you should use `#align` on any theorem that needs to be renamed from the default.\n",
  "args": ""},
 {"type": "{α : Type u} → [inst : Group α] → GroupWithZero (WithZero α)",
  "name": "WithZero.groupWithZero",
  "kind": "def",
  "doc_string": "if `G` is a group then `WithZero G` is a group with zero. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → Set.Iio a ⊆ Set.Iio b",
  "name": "Set.Iio_subset_Iio",
  "kind": "theorem",
  "doc_string":
  "If `a ≤ b`, then `(-∞, a) ⊆ (-∞, b)`. In preorders, this is just an implication. If you need\nthe equivalence in linear orders, use `Iio_subset_Iio_iff`. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : DivisionSemiring α], 0⁻¹ = 0",
  "name": "DivisionSemiring.inv_zero",
  "kind": "def",
  "doc_string": "The inverse of `0` in a group with zero is `0`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (s t : Set α) → s ⊆ t → ↑s ↪ ↑t",
  "name": "Set.embeddingOfSubset",
  "kind": "def",
  "doc_string": "The injection map is an embedding between subsets. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : LinearOrderedCommMonoid M] →\n    {A : Type u_2} →\n      [inst_1 : SetLike A M] → [inst : SubmonoidClass A M] → (S : A) → LinearOrderedCommMonoid { x // x ∈ S }",
  "name": "SubmonoidClass.toLinearOrderedCommMonoid",
  "kind": "def",
  "doc_string":
  "A submonoid of a `LinearOrderedCommMonoid` is a `LinearOrderedCommMonoid`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_4} {β : Type u_5} {γ : Type u_3} {a : Option α} {b : Option β} {β' : Type u_1} {δ : Type u_2}\n  {f : α → β' → γ} {g : β → β'} {f' : β → α → δ} {g' : δ → γ},\n  (∀ (a : α) (b : β), f a (g b) = g' (f' b a)) → Option.map₂ f a (Option.map g b) = Option.map g' (Option.map₂ f' b a)",
  "name": "Option.map_map₂_right_anticomm",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Option.map_map₂_antidistrib_right`. ",
  "args": ""},
 {"type": "{α β : Sort u} → α = β → α → β",
  "name": "cast",
  "kind": "def",
  "doc_string":
  "Cast across a type equality. If `h : α = β` is an equality of types, and\n`a : α`, then `a : β` will usually not typecheck directly, but this function\nwill allow you to work around this and embed `a` in type `β` as `cast h a : β`.\n\nIt is best to avoid this function if you can, because it is more complicated\nto reason about terms containing casts, but if the types don't match up\ndefinitionally sometimes there isn't anything better you can do.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] →\n        {F : Type u_3} →\n          [mc : MonoidHomClass F M N] →\n            {f : F} → Function.Surjective ↑f → GaloisInsertion (Submonoid.map f) (Submonoid.comap f)",
  "name": "Submonoid.giMapComap",
  "kind": "def",
  "doc_string":
  "`map f` and `comap f` form a `GaloisInsertion` when `f` is surjective. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "PartialOrder",
  "kind": "inductive",
  "doc_string":
  "A partial order is a reflexive, transitive, antisymmetric relation `≤`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LT α] [inst_1 : WellFoundedLT α] {C : α → Prop} (a : α),\n  (∀ (x : α), (∀ (y : α), y < x → C y) → C x) → C a",
  "name": "WellFoundedLT.induction",
  "kind": "theorem",
  "doc_string": "Inducts on a well-founded `<` relation. ",
  "args": ""},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "name": "CoeTail",
  "kind": "inductive",
  "doc_string":
  "`CoeTail α β` is for coercions that can only appear at the end of a\nsequence of coercions. That is, `α` can be further coerced via `Coe σ α` and\n`CoeHead τ σ` instances but `β` will only be the expected type of the expression.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Sort u_2} [inst : CompleteLattice α] {f : ι → α} {b : α},\n  (∀ (i : ι), b ≤ f i) → (∀ (w : α), b < w → ∃ i, f i < w) → (⨅ i, f i) = b",
  "name": "infᵢ_eq_of_forall_ge_of_forall_gt_exists_lt",
  "kind": "theorem",
  "doc_string":
  "Introduction rule to prove that `b` is the infimum of `f`: it suffices to check that `b`\nis smaller than `f i` for all `i`, and that this is not the case of any `w>b`.\nSee `cinfᵢ_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in conditionally complete\nlattices. ",
  "args": ""},
 {"type":
  "{A : Type u_1} → [inst : AddZeroClass A] → AddSubmonoid A ≃o Submonoid (Multiplicative A)",
  "name": "AddSubmonoid.toSubmonoid",
  "kind": "def",
  "doc_string":
  "Additive submonoids of an additive monoid `A` are isomorphic to\nmultiplicative submonoids of `Multiplicative A`. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} (P : Prop) [inst : Decidable P] (a b : α), (if x : P then a else b) = if P then a else b",
  "name": "dite_eq_ite",
  "kind": "theorem",
  "doc_string":
  "A `dite` whose results do not actually depend on the condition may be reduced to an `ite`. ",
  "args": ""},
 {"type": "{α : Type u} → List α → (α → Bool) → Bool",
  "name": "List.any",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. Returns true if `p` is true for any element of `l`.\n* `any p [a, b, c] = p a || p b || p c`\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a < 0 → b < 0 → a + b < 0",
  "name": "add_neg'",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.add_neg'`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {f : α → α}, id ≤ f → ∀ (n : ℕ), id ≤ f^[n]",
  "name": "Function.id_le_iterate_of_id_le",
  "kind": "theorem",
  "doc_string":
  "If $x ≤ f x$ for all $x$ (we write this as `id ≤ f`), then the same is true for any iterate\n`f^[n]` of `f`. ",
  "args": ""},
 {"type": "ℕ → Lean.Expr → Lean.Expr × Lean.Expr",
  "name": "Mathlib.Tactic.Sat.buildReify.reifyFmla",
  "kind": "opaque",
  "doc_string": "Returns `a` and `pr : reify v f a` given a formula `f` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → β → Prop) → Option α → Option β → Prop",
  "name": "Option.Rel",
  "kind": "inductive",
  "doc_string":
  "Lifts a relation `α → β → Prop` to a relation `Option α → Option β → Prop` by just adding\n`none ~ none`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M) {x y : M}, x ∈ S → y ∈ S → x * y ∈ S",
  "name": "Submonoid.mul_mem",
  "kind": "theorem",
  "doc_string": "A submonoid is closed under multiplication. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "name": "MulPosReflectLT",
  "kind": "def",
  "doc_string":
  "`MulPosReflectLT α` is an abbreviation for `ContravariantClas α≥0 α (λ x y, y * x) (<)`,\nexpressing that multiplication by nonnegative elements on the right is strictly reverse monotone. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} (r : Setoid α), EqvGen.Setoid Setoid.r = r",
  "name": "Setoid.eqvGen_of_setoid",
  "kind": "theorem",
  "doc_string": "The equivalence closure of an equivalence relation r is r. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : CommMonoidWithZero M] → {n : ℕ} → 0 < n → M →*₀ M",
  "name": "powMonoidWithZeroHom",
  "kind": "def",
  "doc_string":
  "We define `x ↦ x^n` (for positive `n : ℕ`) as a `MonoidWithZeroHom` ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_>>_»",
  "kind": "def",
  "doc_string":
  "`a >> b` executes `a`, ignores the result, and then executes `b`.\nIf `a` fails then `b` is not executed. Because `b` is not always executed, it\nis passed as a thunk so it can be forced only when needed.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type": "∀ {M : Type u_1} [inst : MulOneClass M] (a : M), SemiconjBy a 1 1",
  "name": "SemiconjBy.one_right",
  "kind": "theorem",
  "doc_string": "Any element semiconjugates `1` to `1`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [s : Setoid α] {r : α → α → Prop} {H : ∀ (a₁ b₁ a₂ b₂ : α), a₁ ≈ a₂ → b₁ ≈ b₂ → r a₁ b₁ = r a₂ b₂},\n  WellFounded (Quotient.lift₂ r H) → WellFounded r",
  "name": "RelEmbedding.WellFounded.of_quotient_lift₂",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `wellFounded_lift₂_iff`.",
  "args": ""},
 {"type": "∀ {α : Sort u_1} {a b : α}, a = b → HEq a b",
  "name": "Eq.heq",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `heq_iff_eq`.",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : MulOneClass M] → (S : Submonoid M) → MulOneClass { x // x ∈ S }",
  "name": "Submonoid.toMulOneClass",
  "kind": "def",
  "doc_string":
  "A submonoid of a unital magma inherits a unital magma structure. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  (p q : α → Prop) → [inst : DecidablePred p] → Disjoint p q → { x // p x ∨ q x } ≃ { x // p x } ⊕ { x // q x }",
  "name": "subtypeOrEquiv",
  "kind": "def",
  "doc_string":
  "A subtype `{x // p x ∨ q x}` over a disjunction of `p q : α → Prop` is equivalent to a sum of\nsubtypes `{x // p x} ⊕ {x // q x}` such that `¬ p x` is sent to the right, when\n`Disjoint p q`.\n\nSee also `Equiv.sumCompl`, for when `IsCompl p q`.  ",
  "args": ""},
 {"type":
  "∀ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R]\n  [inst_2 : DivisionRing S] [inst_3 : Module R E] [inst_4 : Module S E] (n : ℤ) (x : E), (↑n)⁻¹ • x = (↑n)⁻¹ • x",
  "name": "inv_int_cast_smul_eq",
  "kind": "theorem",
  "doc_string":
  "If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\nagree on inverses of integer numbers in `R` and `S`. ",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.lxor'",
  "kind": "def",
  "doc_string": "`lxor'` computes the bitwise `xor` of two natural numbers",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedCancelCommMonoid α] (a b : α), max a b = if a ≤ b then b else a",
  "name": "LinearOrderedCancelCommMonoid.max_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `maxOfLe`. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} (a b c : α), TC r a b → TC r b c → TC r a c",
  "name": "TC.trans",
  "kind": "def",
  "doc_string": "The transitive closure is transitive. ",
  "args": ""},
 {"type": "{α β σ : Type u} → σ → DoResultPRBC α β σ",
  "name": "DoResultPRBC.continue",
  "kind": "def",
  "doc_string":
  "`continue s` means that `continue` was called, meaning that we should continue\nto the next iteration of the containing loop ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulStrictMono α],\n  1 ≤ a → 1 < b → 0 < a → 1 < a * b",
  "name": "Left.one_lt_mul_of_le_of_lt_of_pos",
  "kind": "theorem",
  "doc_string": "Assumes left covariance. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "NonUnitalNonAssocSemiring",
  "kind": "inductive",
  "doc_string":
  "A not-necessarily-unital, not-necessarily-associative semiring. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {R' : Type u_2} →\n    (M : Type u_3) →\n      [inst : MonoidWithZero R] →\n        [inst_1 : MonoidWithZero R'] →\n          [inst_2 : Zero M] → [inst_3 : MulActionWithZero R M] → (R' →*₀ R) → MulActionWithZero R' M",
  "name": "MulActionWithZero.compHom",
  "kind": "def",
  "doc_string":
  "Compose a `MulActionWithZero` with a `MonoidWithZeroHom`, with action `f r' • m` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} →\n      [inst : AddZeroClass M] →\n        [inst_1 : AddZeroClass N] → [inst_2 : AddCommMonoid P] → (M →+ P) → (N →+ P) → M × N →+ P",
  "name": "AddMonoidHom.coprod",
  "kind": "def",
  "doc_string":
  "Coproduct of two `AddMonoidHom`s with the same codomain:\n`f.coprod g (p : M × N) = f p.1 + g p.2`.",
  "args": ""},
 {"type": "{α : Sort u} → [self : HasEquiv α] → α → α → Sort v",
  "name": "HasEquiv.Equiv",
  "kind": "def",
  "doc_string":
  "`x ≈ y` says that `x` and `y` are equivalent. Because this is a typeclass,\nthe notion of equivalence is type-dependent. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "LinearOrderedCommRing",
  "kind": "inductive",
  "doc_string":
  "A `LinearOrderedCommRing` is a commutative ring with a linear order such that addition is\nmonotone and multiplication by a positive number is strictly monotone. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α] (a b : α), a ≤ b ∨ b ≤ a",
  "name": "CanonicallyLinearOrderedSemifield.le_total",
  "kind": "def",
  "doc_string": "A linear order is total. ",
  "args": ""},
 {"type":
  "{ε : Type u} → {m : Type v → Type w} → [inst : MonadExcept ε m] → {α : Type v} → m α → (Unit → m α) → m α",
  "name": "MonadExcept.orElse",
  "kind": "def",
  "doc_string":
  "A `MonadExcept` can implement `t₁ <|> t₂` as `try t₁ catch _ => t₂`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Lattice α] → [inst_1 : BoundedOrder α] → [inst : IsSimpleOrder α] → CompleteLattice α",
  "name": "IsSimpleOrder.completeLattice",
  "kind": "def",
  "doc_string": "A simple `BoundedOrder` is also complete. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → α → Prop) → (β → β → Prop) → α × β → α × β → Prop",
  "name": "Prod.GameAdd",
  "kind": "inductive",
  "doc_string":
  "The \"addition of games\" relation in combinatorial game theory, on the product type: if\n`rα a' a` means that `a ⟶ a'` is a valid move in game `α`, and `rβ b' b` means that `b ⟶ b'`\nis a valid move in game `β`, then `GameAdd rα rβ` specifies the valid moves in the juxtaposition\nof `α` and `β`: the player is free to choose one of the games and make a move in it,\nwhile leaving the other game unchanged. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] (c : ClosureOperator α) (x : α), x ≤ ↑c.toOrderHom x",
  "name": "ClosureOperator.le_closure",
  "kind": "theorem",
  "doc_string":
  "Every element is less than its closure. This property is sometimes referred to as extensivity or\ninflationarity. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "AddCommMonoidWithOne",
  "kind": "inductive",
  "doc_string":
  "An `AddCommMonoidWithOne` is an `AddMonoidWithOne` satisfying `a + b = b + a`.  ",
  "args": ""},
 {"type": "(ℕ → Bool) → ℕ → Bool",
  "name": "Nat.any",
  "kind": "def",
  "doc_string":
  "`any f n = true` iff there is `i in [0, n-1]` s.t. `f i = true` ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → α → α ⊕' β",
  "name": "PSum.inl",
  "kind": "def",
  "doc_string":
  "Left injection into the sum type `α ⊕' β`. If `a : α` then `.inl a : α ⊕' β`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → (α →o α →o β) → α →o β",
  "name": "OrderHom.onDiag",
  "kind": "def",
  "doc_string": "Restriction of `f : α →o α →o β` to the diagonal. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] {a b c : α}, c ≠ 0 → (a * c ∣ b * c ↔ a ∣ b)",
  "name": "mul_dvd_mul_iff_right",
  "kind": "theorem",
  "doc_string":
  "Given two elements `a`, `b` of a commutative `CancelMonoidWithZero` and a nonzero\nelement `c`, `a*c` divides `b*c` iff `a` divides `b`. ",
  "args": ""},
 {"type": "Linarith.Monom → Linarith.Sum",
  "name": "Linarith.SumOfMonom",
  "kind": "def",
  "doc_string": "`SumOfMonom m` lifts `m` to a sum with coefficient `1`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulMono α],\n  0 ≤ a → 0 ≤ b → 0 ≤ a * b",
  "name": "mul_nonneg",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.mul_nonneg`.",
  "args": ""},
 {"type": "{α : Sort u_1} → {β : Sort u_2} → (α → β) → Trunc α → Trunc β",
  "name": "Trunc.map",
  "kind": "def",
  "doc_string":
  "A function `f : α → β` defines a function `map f : Trunc α → Trunc β`. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Polyrith.SageSuccess",
  "kind": "inductive",
  "doc_string": "The result of a sage call in the success case. ",
  "args": ""},
 {"type":
  "(α : Type u_1) →\n  [H1 : Lattice α] →\n    [inst : InfSet α] → (∀ (s : Set α), BddBelow s → Set.Nonempty s → IsGLB s (infₛ s)) → ConditionallyCompleteLattice α",
  "name": "conditionallyCompleteLatticeOfLatticeOfInfₛ",
  "kind": "def",
  "doc_string":
  "A version of `conditionallyCompleteLatticeOfInfₛ` when we already know that `α` is a lattice.\n\nThis should only be used when it is both hard and unnecessary to provide `sup` explicitly. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} [inst : IsEmpty α] (p : α → Prop), IsEmpty (Subtype p)",
  "name": "instIsEmptySubtype",
  "kind": "def",
  "doc_string": "subtypes of an empty type are empty ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → AddHom M N → AddSubsemigroup N → AddSubsemigroup M",
  "name": "AddSubsemigroup.comap",
  "kind": "def",
  "doc_string":
  "The preimage of an `AddSubsemigroup` along an `AddSemigroup` homomorphism is an\n`AddSubsemigroup`.",
  "args": ""},
 {"type": "{α : Sort u_1} → [s : Setoid α] → Quotient s → α",
  "name": "Quotient.out",
  "kind": "def",
  "doc_string":
  "Choose an element of the equivalence class using the axiom of choice.\nSound but noncomputable. ",
  "args": ""},
 {"type":
  "Type u_1 →\n  (A : outParam (Type u_2)) → (B : outParam (Type u_3)) → [inst : Add A] → [inst : Add B] → Type (max (max u_1 u_2) u_3)",
  "name": "AddEquivClass",
  "kind": "inductive",
  "doc_string":
  "`AddEquivClass F A B` states that `F` is a type of addition-preserving morphisms.\nYou should extend this class when you extend `AddEquiv`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : LeftCancelSemigroup R] (g : R), IsLeftRegular g",
  "name": "isLeftRegular_of_leftCancelSemigroup",
  "kind": "theorem",
  "doc_string": "Elements of a left cancel semigroup are left regular. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddCommGroupWithOne",
  "kind": "inductive",
  "doc_string":
  "An `AddCommGroupWithOne` is an `AddGroupWithOne` satisfying `a + b = b + a`. ",
  "args": ""},
 {"type": "Linarith.Comp → ℕ → Linarith.PComp",
  "name": "Linarith.PComp.assump",
  "kind": "def",
  "doc_string":
  "`PComp.assump c n` creates a `PComp` whose comparison is `c` and whose source is\n`CompSource.assump n`, that is, `c` is derived from the `n`th hypothesis.\nThe history is the singleton set `{n}`.\nNo variables have been eliminated (effectively or implicitly).\n",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Polyrith.Source",
  "kind": "inductive",
  "doc_string": "The possible hypothesis sources for a polyrith proof. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : AddCommSemigroup M₂] →\n        (f : M₁ → M₂) → Function.Injective f → (∀ (x y : M₁), f (x + y) = f x + f y) → AddCommSemigroup M₁",
  "name": "Function.Injective.addCommSemigroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `+` is an additive commutative semigroup,if it admits\nan injective map that preserves `+` to an additive commutative semigroup.",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ},\n  Function.Surjective g → Function.Surjective ((fun x x_1 => x ∘ x_1) g)",
  "name": "Function.Surjective.comp_left",
  "kind": "theorem",
  "doc_string":
  "Composition by an surjective function on the left is itself surjective. ",
  "args": ""},
 {"type": "Type (u + 1) → Type (u + 1)",
  "name": "CategoryTheory.LargeCategory",
  "kind": "def",
  "doc_string":
  "A `LargeCategory` has objects in one universe level higher than the universe level of\nthe morphisms. It is useful for examples such as the category of types, or the category\nof groups, etc.\n",
  "args": ""},
 {"type":
  "∀ {E : Sort u_1} {α : Sort u_2} {β : Sort u_3} [self : EquivLike E α β] (e : E),\n  Function.LeftInverse (EquivLike.inv e) (EquivLike.coe e)",
  "name": "EquivLike.left_inv",
  "kind": "def",
  "doc_string": "The coercions are left inverses. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        (s : AddSubmonoid M) →\n          (t : AddSubmonoid N) → { x // x ∈ AddSubmonoid.prod s t } ≃+ { x // x ∈ s } × { x // x ∈ t }",
  "name": "AddSubmonoid.prodEquiv",
  "kind": "def",
  "doc_string":
  "The product of additive submonoids is isomorphic to their product as additive monoids",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → β → Prop) → (β → γ → Prop) → α → γ → Prop",
  "name": "Relation.Comp",
  "kind": "def",
  "doc_string":
  "The composition of two relations, yielding a new relation.  The result\nrelates a term of `α` and a term of `γ` if there is an intermediate\nterm of `β` related to both.\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_>>>_»",
  "kind": "def",
  "doc_string":
  "`a >>> b` computes `a` shifted to the right by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat` and fixed width unsigned types like `UInt8`,\n  this is equivalent to `a / 2 ^ b`. ",
  "args": ""},
 {"type": "{V : Type u_1} → [inst : Quiver V] → {X Y : V} → (X ⟶ Y) → (Y ⟶ X)",
  "name": "Quiver.Hom.toNeg",
  "kind": "def",
  "doc_string":
  "Shorthand for the \"backward\" arrow corresponding to `f` in `symmetrify V` ",
  "args": ""},
 {"type": "Mathlib.Meta.NormNum.NormNumExt",
  "name": "Mathlib.Meta.NormNum.evalNatCast",
  "kind": "def",
  "doc_string":
  "The `norm_num` extension which identifies an expression `Nat.cast n`, returning `n`. ",
  "args": ""},
 {"type":
  "Bool →\n  Array Lean.Expr →\n    Lean.Expr →\n      Mathlib.Tactic.Ring.RingM\n        (Lean.Expr ×\n          Array (Mathlib.Tactic.Polyrith.Source × Mathlib.Tactic.Polyrith.Poly) × Mathlib.Tactic.Polyrith.Poly)",
  "name": "Mathlib.Tactic.Polyrith.parseContext",
  "kind": "def",
  "doc_string":
  "The first half of `polyrith` produces a list of arguments to be sent to Sage. ",
  "args": ""},
 {"type":
  "∀ {ι : Type u_1} (self : ComplexShape ι) {i i' j : ι}, ComplexShape.Rel self i j → ComplexShape.Rel self i' j → i = i'",
  "name": "ComplexShape.prev_eq",
  "kind": "def",
  "doc_string": "There is at most one nonzero differential to `X j`. ",
  "args": ""},
 {"type": "{α : Sort u_1} → {β : Sort u_2} → [inst : IsEmpty α] → α ↪ β",
  "name": "Function.Embedding.ofIsEmpty",
  "kind": "def",
  "doc_string": "There is always an embedding from an empty type. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.SolveByElim.applyAssumption",
  "kind": "def",
  "doc_string":
  "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\n[todo] not yet implemented:\nIf this fails, `apply_assumption` will call `symmetry` and try again.\n\n[todo] not yet implemented:\nIf this also fails, `apply_assumption` will call `exfalso` and try again,\nso that if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\n[todo] not yet implemented:\nOptional arguments:\n- `lemmas`: a list of expressions to apply, instead of the local constants\n- `tac`: a tactic to run on each subgoal after applying an assumption; if\n  this tactic fails, the corresponding assumption will be rejected and\n  the next one will be attempted.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α], Subsingleton (SuccOrder α)",
  "name": "Order.instSubsingletonSuccOrderToPreorder",
  "kind": "def",
  "doc_string":
  "There is at most one way to define the successors in a `PartialOrder`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → β ⊕ γ) → List α → Array β → Array γ → List β × List γ",
  "name": "List.partitionMap.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `partitionMap`:\n`partitionMap.go f l acc₁ acc₂ = (acc₁.toList ++ left, acc₂.toList ++ right)`\nif `partitionMap f l = (left, right)`. ",
  "args": ""},
 {"type": "Linarith.PComp → Linarith.PComp → Ordering",
  "name": "Linarith.PComp.cmp",
  "kind": "def",
  "doc_string":
  "The `src : CompSource` field is ignored when comparing `PComp`s. Two `PComp`s proving the same\ncomparison, with different sources, are considered equivalent.\n",
  "args": ""},
 {"type": "Tactic.Alias.Target → String",
  "name": "Tactic.Alias.Target.toString",
  "kind": "def",
  "doc_string": "The docstring for an alias. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {p q : α → Prop} → (∀ (x : α), p x ↔ q x) → { x // p x } ≃ { x // q x }",
  "name": "Equiv.subtypeEquivRight",
  "kind": "def",
  "doc_string":
  "If two predicates `p` and `q` are pointwise equivalent, then `{x // p x}` is equivalent to\n`{x // q x}`. ",
  "args": ""},
 {"type":
  "∀ {G : Type u} [inst : Add G] [self : IsLeftCancelAdd G] (a b c : G), a + b = a + c → b = c",
  "name": "IsLeftCancelAdd.add_left_cancel",
  "kind": "def",
  "doc_string": "Addition is left cancellative. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (a : M), AddSemiconjBy a 0 0",
  "name": "AddSemiconjBy.zero_right",
  "kind": "theorem",
  "doc_string": "Any element semiconjugates `0` to `0`.",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "name": "Tactic.NormCast.numeralToCoe",
  "kind": "def",
  "doc_string":
  "If possible, rewrite `(n : α)` to `(Nat.cast n : α)` where `n` is a numeral and `α ≠ ℕ`.\nReturns a pair of the new expression and proof that they are equal.\n",
  "args": ""},
 {"type": "Prop → Prop → Prop",
  "name": "Or",
  "kind": "inductive",
  "doc_string":
  "`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n",
  "args": ""},
 {"type": "Type u → Type (u + 1)",
  "name": "CategoryTheory.SmallCategory",
  "kind": "def",
  "doc_string":
  "A `SmallCategory` has objects and morphisms in the same universe level.\n",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : AddSemigroup S], Transitive fun a b => ∃ c, AddSemiconjBy c a b",
  "name": "AddSemiconjBy.transitive",
  "kind": "theorem",
  "doc_string":
  "The relation “there exists an element that semiconjugates `a` to `b`” on an additive\nsemigroup is transitive.",
  "args": ""},
 {"type":
  "{M₀ : Type u_1} →\n  {M₀' : Type u_2} →\n    [inst : CancelMonoidWithZero M₀] →\n      [inst_1 : Zero M₀'] →\n        [inst_2 : Mul M₀'] →\n          [inst_3 : One M₀'] →\n            [inst_4 : Pow M₀' ℕ] →\n              (f : M₀' → M₀) →\n                Function.Injective f →\n                  f 0 = 0 →\n                    f 1 = 1 →\n                      (∀ (x y : M₀'), f (x * y) = f x * f y) →\n                        (∀ (x : M₀') (n : ℕ), f (x ^ n) = f x ^ n) → CancelMonoidWithZero M₀'",
  "name": "Function.Injective.cancelMonoidWithZero",
  "kind": "def",
  "doc_string":
  "Pullback a `CancelMonoidWithZero` along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (List α → α → List α → β) → List α → List α → List β",
  "name": "List.mapWithPrefixSuffixAux",
  "kind": "def",
  "doc_string": "An auxiliary function for `List.mapWithPrefixSuffix`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {A : Type u_2} →\n    [inst : Add M] → [inst_1 : SetLike A M] → [hA : AddMemClass A M] → (S' : A) → AddHom { x // x ∈ S' } M",
  "name": "AddMemClass.subtype",
  "kind": "def",
  "doc_string":
  "The natural semigroup hom from an `AddSubsemigroup` of\n`AddSubsemigroup` `M` to `M`.",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : RightCancelSemigroup R] (g : R), IsRightRegular g",
  "name": "isRightRegular_of_rightCancelSemigroup",
  "kind": "theorem",
  "doc_string": "Elements of a right cancel semigroup are right regular. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α], NatCast.natCast 0 = 0",
  "name": "CanonicallyOrderedCommSemiring.natCast_zero",
  "kind": "def",
  "doc_string": "The canonical map `ℕ → R` sends `0 : ℕ` to `0 : R`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {F : Type u_3} →\n      [inst : MulOneClass R] →\n        [inst_1 : MulOneClass S] →\n          [inst_2 : MonoidHomClass F R S] → (f : F) → (r : R) → [inst_3 : Invertible r] → Invertible (↑f r)",
  "name": "Invertible.map",
  "kind": "def",
  "doc_string": "Monoid homs preserve invertibility. ",
  "args": ""},
 {"type": "∀ {α : Sort u_1}, Finite α → ¬Infinite α",
  "name": "Finite.not_infinite",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `not_infinite_iff_finite`.",
  "args": ""},
 {"type":
  "∀ {F : Type u_3} {G : Type u_1} {H : Type u_2} [inst : AddGroup G] [inst_1 : AddZeroClass H]\n  [inst_2 : AddMonoidHomClass F G H] (f : F), Function.Injective ↑f ↔ ∀ (a : G), ↑f a = 0 → a = 0",
  "name": "injective_iff_map_eq_zero",
  "kind": "theorem",
  "doc_string":
  "A homomorphism from an additive group to an additive monoid is injective iff\nits kernel is trivial. For the iff statement on the triviality of the kernel,\nsee `injective_iff_map_eq_zero'`.",
  "args": ""},
 {"type": "Bool",
  "name": "Bool.true",
  "kind": "def",
  "doc_string":
  "The boolean value `true`, not to be confused with the proposition `True`. ",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : LeftCancelSemigroup G] → G → G ↪ G",
  "name": "mulLeftEmbedding",
  "kind": "def",
  "doc_string":
  "The embedding of a left cancellative semigroup into itself\nby left multiplication by a fixed element.\n ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → α → List α → List (List α)",
  "name": "List.splitOn",
  "kind": "def",
  "doc_string":
  "Split a list at every occurrence of a separator element. The separators are not in the result.\n```\n[1, 1, 2, 3, 2, 4, 4].splitOn 2 = [[1, 1], [3], [4, 4]]\n```\n",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "InvolutiveNeg",
  "kind": "inductive",
  "doc_string": "Auxiliary typeclass for types with an involutive `Neg`. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Prelude.Rename.RenameMap",
  "kind": "inductive",
  "doc_string":
  "This structure keeps track of alignments from lean 3 names to lean 4 names and vice versa. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : PredOrder α] [inst_2 : IsPredArchimedean α] (r : α → α → Prop)\n  {n m : α},\n  (∀ (i : α), i ∈ Set.Ioc m n → r i (Order.pred i)) →\n    (∀ (i : α), i ∈ Set.Ioc n m → r (Order.pred i) i) → Relation.ReflTransGen r n m",
  "name": "reflTransGen_of_pred",
  "kind": "theorem",
  "doc_string":
  "`(n, m)` is in the reflexive-transitive closure of `~` if `i ~ pred i` and `pred i ~ i`\nfor all `i` between `n` and `m`. ",
  "args": ""},
 {"type":
  "{V : Type u_1} → [inst : Quiver V] → [inst_1 : Quiver.HasReverse V] → {a b : V} → (a ⟶ b) → (b ⟶ a)",
  "name": "Quiver.reverse",
  "kind": "def",
  "doc_string": "Reverse the direction of an arrow. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : StrictOrderedCommSemiring α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → OrderedCommSemiring α",
  "name": "StrictOrderedCommSemiring.toOrderedCommSemiring'",
  "kind": "def",
  "doc_string":
  "A choice-free version of `StrictOrderedCommSemiring.toOrderedCommSemiring'` to avoid using\nchoice in basic `Nat` lemmas. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "ConditionallyCompleteLinearOrder",
  "kind": "inductive",
  "doc_string":
  "A conditionally complete linear order is a linear order in which\nevery nonempty subset which is bounded above has a supremum, and\nevery nonempty subset which is bounded below has an infimum.\nTypical examples are real numbers or natural numbers.\n\nTo differentiate the statements from the corresponding statements in (unconditional)\ncomplete linear orders, we prefix infₛ and supₛ by a c everywhere. The same statements should\nhold in both worlds, sometimes with additional assumptions of nonemptiness or\nboundedness.",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g",
  "name": "funext",
  "kind": "theorem",
  "doc_string":
  "**Function extensionality** is the statement that if two functions take equal values\nevery point, then the functions themselves are equal: `(∀ x, f x = g x) → f = g`.\nIt is called \"extensionality\" because it talks about how to prove two objects are equal\nbased on the properties of the object (compare with set extensionality,\nwhich is `(∀ x, x ∈ s ↔ x ∈ t) → s = t`).\n\nThis is often an axiom in dependent type theory systems, because it cannot be proved\nfrom the core logic alone. However in lean's type theory this follows from the existence\nof quotient types (note the `Quot.sound` in the proof, as well as the `show` line\nwhich makes use of the definitional equality `Quot.lift f h (Quot.mk x) = f x`).\n",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {G : Type u_2} {N : Type u_3} [inst : DivisionMonoid G] [inst_1 : Monoid N]\n  [inst_2 : MonoidHomClass F G N] {x : G}, IsUnit x → ∀ (f g : F), ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹",
  "name": "IsUnit.eq_on_inv",
  "kind": "theorem",
  "doc_string":
  "If two homomorphisms from a division monoid to a monoid are equal at a unit `x`, then they are\nequal at `x⁻¹`. ",
  "args": ""},
 {"type": "{α : Type u} → (α → α) → ℕ → α → α",
  "name": "Nat.repeatTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `Nat.repeat`. ",
  "args": ""},
 {"type":
  "{P : ℤ → Prop} →\n  [inst : DecidablePred P] → (b : ℤ) → (∀ (z : ℤ), P z → b ≤ z) → (∃ z, P z) → { lb // P lb ∧ ∀ (z : ℤ), P z → lb ≤ z }",
  "name": "Int.leastOfBdd",
  "kind": "def",
  "doc_string":
  "A computable version of `exists_least_of_bdd`: given a decidable predicate on the\nintegers, with an explicit lower bound and a proof that it is somewhere true, return\nthe least value for which the predicate is true. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_3} {N : Type u_4} {α : Type u_2} {β : Type u_1} [inst : SMul M α] [inst_1 : SMul β α]\n  [inst_2 : SMulCommClass M β α] (g : N → M), SMulCommClass N β α",
  "name": "SMul.comp.smulCommClass",
  "kind": "theorem",
  "doc_string":
  "This cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables.\n",
  "args": ""},
 {"type": "Lean.Elab.Command.CommandElab",
  "name": "Mathlib.Prelude.Rename.elabLookup3",
  "kind": "def",
  "doc_string": "Elaborate a `#lookup3` command. ",
  "args": ""},
 {"type": "{α : Type u} → {n : ℕ} → Vector α n → List α",
  "name": "Vector.toList",
  "kind": "def",
  "doc_string": "The list obtained from a vector. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Mul M] → Subsemigroup M → Set M",
  "name": "Subsemigroup.Simps.coe",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Add M] → (S : AddSubsemigroup M) → (s : Set M) → s = ↑S → AddSubsemigroup M",
  "name": "AddSubsemigroup.copy",
  "kind": "def",
  "doc_string":
  "Copy an additive subsemigroup replacing `carrier` with a set that is equal to it.",
  "args": ""},
 {"type": "{α : Sort u} → {β : α → Sort v} → PSigma β → α",
  "name": "PSigma.fst",
  "kind": "def",
  "doc_string":
  "The first component of a dependent pair. If `p : @Sigma α β` then `p.1 : α`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LinearOrder α] → α → α → Set α",
  "name": "Set.intervalOC",
  "kind": "def",
  "doc_string": "The open-closed interval with unordered bounds. ",
  "args": ""},
 {"type":
  "∀ {γ : Type w} [inst : SemilatticeSup γ] {s t : Set γ}, BddAbove (s ∪ t) ↔ BddAbove s ∧ BddAbove t",
  "name": "bddAbove_union",
  "kind": "theorem",
  "doc_string":
  "The union of two sets is bounded above if and only if each of the sets is. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : HeytingAlgebra α] {a b : α}, a ≤ bᶜ ↔ b ≤ aᶜ",
  "name": "le_compl_iff_le_compl",
  "kind": "theorem",
  "doc_string": "**Alias** of `le_compl_comm`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, a < 1 → b < 1 → a * b < 1",
  "name": "Left.mul_lt_one'",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one'`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Rat.«term_/._»",
  "kind": "def",
  "doc_string": "Form the quotient `n / d` where `n d : Int`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosStrictMono α],\n  1 < a → 1 < b → 0 < b → 1 < a * b",
  "name": "Right.one_lt_mul_of_lt_of_lt",
  "kind": "theorem",
  "doc_string": "Assumes right covariance. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Mul α] →\n      [inst_1 : HasDistribNeg α] →\n        [inst_2 : Neg β] →\n          [inst_3 : Mul β] →\n            (f : β → α) →\n              Function.Injective f → (∀ (a : β), f (-a) = -f a) → (∀ (a b : β), f (a * b) = f a * f b) → HasDistribNeg β",
  "name": "Function.Injective.hasDistribNeg",
  "kind": "def",
  "doc_string":
  "A type endowed with `-` and `*` has distributive negation, if it admits an injective map that\npreserves `-` and `*` to a type which has distributive negation. ",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HMod",
  "kind": "inductive",
  "doc_string":
  "The notation typeclass for heterogeneous modulo / remainder.\nThis enables the notation `a % b : γ` where `a : α`, `b : β`.\n",
  "args": ""},
 {"type":
  "{G₀ : Type u_1} →\n  {G₀' : Type u_2} →\n    [inst : CommGroupWithZero G₀] →\n      [inst_1 : Zero G₀'] →\n        [inst_2 : Mul G₀'] →\n          [inst_3 : One G₀'] →\n            [inst_4 : Inv G₀'] →\n              [inst_5 : Div G₀'] →\n                [inst_6 : Pow G₀' ℕ] →\n                  [inst_7 : Pow G₀' ℤ] →\n                    (f : G₀' → G₀) →\n                      Function.Injective f →\n                        f 0 = 0 →\n                          f 1 = 1 →\n                            (∀ (x y : G₀'), f (x * y) = f x * f y) →\n                              (∀ (x : G₀'), f x⁻¹ = (f x)⁻¹) →\n                                (∀ (x y : G₀'), f (x / y) = f x / f y) →\n                                  (∀ (x : G₀') (n : ℕ), f (x ^ n) = f x ^ n) →\n                                    (∀ (x : G₀') (n : ℤ), f (x ^ n) = f x ^ n) → CommGroupWithZero G₀'",
  "name": "Function.Injective.commGroupWithZero",
  "kind": "def",
  "doc_string":
  "Pullback a `CommGroupWithZero` along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Preorder α] → [inst : OrderBot α] → α → Prop",
  "name": "IsAtom",
  "kind": "def",
  "doc_string":
  "An atom of an `OrderBot` is an element with no other element between it and `⊥`,\nwhich is not `⊥`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  a < 0 → b < 0 → a + b < 0",
  "name": "Right.add_neg'",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg'`.",
  "args": ""},
 {"type": "Lean.Elab.Command.CommandElab",
  "name": "Tactic.Alias.elabAlias",
  "kind": "def",
  "doc_string": "Elaborates an `alias ←` command. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1],\n  StrictAntiOn f s → AntitoneOn g s → StrictAntiOn (fun x => f x + g x) s",
  "name": "StrictAntiOn.add_antitone",
  "kind": "theorem",
  "doc_string":
  "The sum of a strictly antitone function and a antitone function is\nstrictly antitone.",
  "args": ""},
 {"type": "Type",
  "name": "Aesop.GoalState",
  "kind": "inductive",
  "doc_string":
  "A refinement of the `NodeState`, distinguishing between goals proven during\nnormalisation and goals proven by a child rule application.\n",
  "args": ""},
 {"type":
  "{R : Type u_1} → {M : Type u_2} → [inst : Semiring R] → [inst_1 : AddCommGroup M] → Module.Core R M → Module R M",
  "name": "Module.ofCore",
  "kind": "def",
  "doc_string":
  "Define `Module` without proving `zero_smul` and `smul_zero` by using an auxiliary\nstructure `Module.Core`, when the underlying space is an `AddCommGroup`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : SemilatticeSup β] {f g : α → β},\n  Antitone f → Antitone g → Antitone (f ⊔ g)",
  "name": "Antitone.sup",
  "kind": "theorem",
  "doc_string":
  "Pointwise supremum of two monotone functions is a monotone function. ",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : Group G] → G →* MulAut G",
  "name": "MulAut.conj",
  "kind": "def",
  "doc_string":
  "Group conjugation, `MulAut.conj g h = g * h * g⁻¹`, as a monoid homomorphism\nmapping multiplication in `G` into multiplication in the automorphism group `MulAut G`.\nSee also the type `ConjAct G` for any group `G`, which has a `MulAction (ConjAct G) G` instance\nwhere `conj G` acts on `G` by conjugation. ",
  "args": ""},
 {"type": "{α : Type u_1} → α → Functor.Const α PUnit",
  "name": "Functor.Const.mk'",
  "kind": "def",
  "doc_string":
  "`Const.mk'` is `Const.mk` but specialized to map `α` to\n`Const α PUnit`, where `PUnit` is the terminal object in `Type*`. ",
  "args": ""},
 {"type": "Lean.Name → Lean.MetaM ℕ",
  "name": "ToAdditive.firstMultiplicativeArg",
  "kind": "def",
  "doc_string":
  "Find the first argument of `nm` that has a multiplicative type-class on it.\nReturns 1 if there are no types with a multiplicative class as arguments.\nE.g. `Prod.Group` returns 1, and `Pi.One` returns 2.\n",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {sα : Q(CommSemiring «$α»)} →\n      {a : Q(«$α»)} →\n        {b : Q(ℕ)} →\n          Mathlib.Tactic.Ring.ExBase sα a →\n            Mathlib.Tactic.Ring.ExProd Mathlib.Tactic.Ring.sℕ b →\n              Mathlib.Tactic.Ring.ExProd sα q(«$a» ^ «$b» * Nat.rawCast 1)",
  "name": "Mathlib.Tactic.Ring.ExBase.toProd",
  "kind": "def",
  "doc_string":
  "Embed an exponent (a `ExBase, ExProd` pair) as a `ExProd` by multiplying by 1. ",
  "args": ""},
 {"type":
  "Std.HashMap ℕ Mathlib.Tactic.Sat.Clause → Array ℤ → Array ℤ → Lean.Expr → Lean.Expr → Except String Lean.Expr",
  "name": "Mathlib.Tactic.Sat.buildProofStep",
  "kind": "def",
  "doc_string":
  "Construct an individual proof step `⊢ ctx.proof c`.\n\n* `db`: the current global context\n* `ns`, `clause`: the new clause\n* `pf`: the LRAT proof trace\n* `ctx`: the main formula\n\nThe proof has three steps:\n\n1. Introduce local assumptions `have h1 : ctx.proof c1 := p1` for each clause `c1`\n   referenced in the proof. We actually do all the introductions at once,\n   as in `(fun h1 h2 h3 ↦ ...) p1 p2 p3`, because we want `p_i` to not be under any binders\n   to avoid the cost of `instantiate` during typechecking and get the benefits of dag-like\n   sharing in the `pi` (which are themselves previous proof steps which may be large terms).\n   The hypotheses are in `gctx`, keyed on the clause ID.\n\n2. Unfold `⊢ ctx.proof [a, b, c]` to\n   `∀ v, v.satisfies_fmla ctx → v.neg a → v.neg b → v.neg c → False` and `intro v hv ha hb hc`,\n   storing each `ha : v.neg a` in `lctx`, keyed on the literal `a`.\n\n3. For each LRAT step `hc : ctx.proof [x, y]`, `hc v hv : v.neg x → v.neg y → False`.\n   We look for a literal that is not falsified in the clause. Since it is a unit propagation\n   step, there can be at most one such literal.\n   * If `x` is the non-falsified clause, let `x'` denote the negated literal of `x`.\n     Then `x'.negate` reduces to `x`, so `hnx : v.neg x'.negate |- hc v hv hnx hy : False`,\n     so we construct the term\n       `by_cases (fun hnx : v.neg x'.negate ↦ hc v hv hnx hy) (fun hx : v.neg x ↦ ...)`\n     and `hx` is added to the local context.\n   * If all clauses are falsified, then we are done: `hc v hv hx hy : False`.\n",
  "args": ""},
 {"type": "Lean.Parsec (ℕ × Array (Array ℤ))",
  "name": "Mathlib.Tactic.Sat.Parser.parseDimacs",
  "kind": "def",
  "doc_string":
  "Parse a DIMACS format `.cnf` file.\nThis is not very robust; we assume the file has had comments stripped. ",
  "args": ""},
 {"type": "ℕ → ℤ → ℕ → Sort u_1 → Sort (imax 1 u_1)",
  "name": "Mathlib.Tactic.ModCases.OnModCases",
  "kind": "def",
  "doc_string":
  "`OnModCases n a lb p` represents a partial proof by cases that\nthere exists `0 ≤ z < n` such that `a ≡ z (mod n)`.\nIt asserts that if `∃ z, lb ≤ z < n ∧ a ≡ z (mod n)` holds, then `p`\n(where `p` is the current goal).\n",
  "args": ""},
 {"type": "∀ {G : Type u} [self : AddCommSemigroup G] (a b : G), a + b = b + a",
  "name": "AddCommSemigroup.add_comm",
  "kind": "def",
  "doc_string":
  "Addition is commutative in an additive commutative semigroup. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddMonoid M] → [inst_1 : AddMonoid N] → (f : M →+ N) → (∀ (x : M), IsAddUnit (↑f x)) → M →+ AddUnits N",
  "name": "IsAddUnit.liftRight",
  "kind": "def",
  "doc_string":
  "If a homomorphism `f : M →+ N` sends each element to an `IsAddUnit`, then it can be\nlifted to `f : M →+ AddUnits N`. See also `AddUnits.liftRight` for a computable version.",
  "args": ""},
 {"type":
  "{α₁ : Sort u_1} → {α₂ : Type u_2} → {β₁ : Sort u_3} → {β₂ : Type u_4} → α₁ ≃ α₂ → β₁ ≃ β₂ → α₁ ⊕' β₁ ≃ α₂ ⊕ β₂",
  "name": "Equiv.psumSum",
  "kind": "def",
  "doc_string":
  "Combine two `Equiv`s using `PSum` in the domain and `Sum` in the codomain. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : PartialOrder α] → ClosureOperator α → Set α",
  "name": "ClosureOperator.closed",
  "kind": "def",
  "doc_string":
  "An element `x` is closed for the closure operator `c` if it is a fixed point for it. ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Ring.Context → Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "name": "Mathlib.Tactic.Ring.Context.evalAtom",
  "kind": "def",
  "doc_string":
  "A simplification to apply to atomic expressions when they are encountered,\nbefore interning them in the atom list. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ≃r s → r ≼i s",
  "name": "InitialSeg.ofIso",
  "kind": "def",
  "doc_string": "An order isomorphism is an initial segment ",
  "args": ""},
 {"type": "∀ {m n : ℕ}, m ≤ n → ↑m ≤ ↑n",
  "name": "Int.ofNat_le_ofNat_of_le",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `Int.ofNat_le`.",
  "args": ""},
 {"type": "Dvd ℕ",
  "name": "Nat.instDvdNat",
  "kind": "def",
  "doc_string":
  "Divisibility of natural numbers. `a ∣ b` (typed as `\\|`) says that\nthere is some `c` such that `b = a * c`.\n",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.NormalExpr → Lean.Expr",
  "name": "Mathlib.Tactic.Abel.NormalExpr.e",
  "kind": "def",
  "doc_string": "Extract the expression from a normal form. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : HasInf α] →\n      [inst_1 : SemilatticeInf β] →\n        (f : α → β) → Function.Injective f → (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) → SemilatticeInf α",
  "name": "Function.Injective.semilatticeInf",
  "kind": "def",
  "doc_string":
  "A type endowed with `⊓` is a `SemilatticeInf`, if it admits an injective map that\npreserves `⊓` to a `SemilatticeInf`.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Preorder α] →\n    {ι : Type u_2} →\n      {π : ι → Type u_3} → [inst_1 : (i : ι) → Preorder (π i)] → (α →o (i : ι) → π i) ≃o ((i : ι) → α →o π i)",
  "name": "OrderHom.piIso",
  "kind": "def",
  "doc_string":
  "Order isomorphism between bundled monotone maps `α →o Π i, π i` and families of bundled monotone\nmaps `Π i, α →o π i`. ",
  "args": ""},
 {"type":
  "Type u_1 →\n  (α : outParam (Type u_2)) →\n    (β : outParam (Type u_3)) → [inst : NonAssocSemiring α] → [inst : NonAssocSemiring β] → Type (max (max u_1 u_2) u_3)",
  "name": "RingHomClass",
  "kind": "inductive",
  "doc_string":
  "`RingHomClass F α β` states that `F` is a type of (semi)ring homomorphisms.\nYou should extend this class when you extend `RingHom`.\n\nThis extends from both `MonoidHomClass` and `MonoidWithZeroHomClass` in\norder to put the fields in a sensible order, even though\n`MonoidWithZeroHomClass` already extends `MonoidHomClass`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        (f : M →+ N) → (M' : AddSubmonoid M) → { x // x ∈ M' } →+ { x // x ∈ AddSubmonoid.map f M' }",
  "name": "AddMonoidHom.addSubmonoidMap",
  "kind": "def",
  "doc_string":
  "the `AddMonoidHom` from an additive submonoid to its image. See\n`AddEquiv.AddSubmonoidMap` for a variant for `AddEquiv`s.",
  "args": ""},
 {"type":
  "{a : Lean.Level} →\n  {arg : Q(Type a)} →\n    {sα : Q(CommSemiring «$arg»)} →\n      {a_1 b : Q(«$arg»)} → Mathlib.Tactic.Ring.ExProd sα a_1 → Mathlib.Tactic.Ring.ExProd sα b → Bool",
  "name": "Mathlib.Tactic.Ring.ExProd.eq",
  "kind": "opaque",
  "doc_string":
  "Equality test for expressions. This is not a `BEq` instance because it is heterogeneous. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Add M] {s : Set M} {p : M → Prop} {x : M},\n  x ∈ AddSubsemigroup.closure s → (∀ (x : M), x ∈ s → p x) → (∀ (x y : M), p x → p y → p (x + y)) → p x",
  "name": "AddSubsemigroup.closure_induction",
  "kind": "theorem",
  "doc_string":
  "An induction principle for additive closure membership. If `p`\nholds for all elements of `s`, and is preserved under addition, then `p` holds for all\nelements of the additive closure of `s`.",
  "args": ""},
 {"type": "∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M), 1 ∈ S",
  "name": "Submonoid.one_mem",
  "kind": "theorem",
  "doc_string": "A submonoid contains the monoid's 1. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → {u : β → α} → LowerAdjoint u → α → β",
  "name": "LowerAdjoint.toFun",
  "kind": "def",
  "doc_string": "The underlying function ",
  "args": ""},
 {"type":
  "∀ (α : Type u_1) [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 3",
  "name": "zero_lt_three'",
  "kind": "theorem",
  "doc_string": "See `zero_lt_three` for a version with the type implicit. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {α : Type u_2} [inst : SMul M α] [self : MulAction.IsPretransitive M α] (x y : α), ∃ g, g • x = y",
  "name": "MulAction.IsPretransitive.exists_smul_eq",
  "kind": "def",
  "doc_string": "There is `g` such that `g • x = y`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : GCDMonoid α] (a b : α), gcd a b ∣ b",
  "name": "GCDMonoid.gcd_dvd_right",
  "kind": "def",
  "doc_string": "The GCD is a divisor of the second element. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  {D : Type u₂} →\n    [inst : CategoryTheory.Category C] →\n      [inst_1 : CategoryTheory.Category D] →\n        (F : C ⥤ D) → [inst_2 : CategoryTheory.Full F] → CategoryTheory.Full (CategoryTheory.Functor.toEssImage F)",
  "name": "CategoryTheory.Full.toEssImage",
  "kind": "def",
  "doc_string": "The induced functor of a full functor is full ",
  "args": ""},
 {"type": "Lean.Elab.Command.CommandElab",
  "name": "timeCmdElab",
  "kind": "def",
  "doc_string":
  "Time the elaboration of a command, and print the result (in milliseconds).\n\nExample usage:\n```\nset_option maxRecDepth 100000 in\n#time example : (List.range 500).length = 500 := rfl\n```\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Zero M] [inst_1 : Zero N] (self : ZeroHom M N), ↑self 0 = 0",
  "name": "ZeroHom.map_zero'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves 0 ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Nontriviality.Parser.Attr.nontriviality",
  "kind": "def",
  "doc_string":
  "The `@[nontriviality]` simp set is used by the `nontriviality` tactic to automatically\ndischarge theorems about the trivial case (where we know `Subsingleton α` and many theorems\nin e.g. groups are trivially true). ",
  "args": ""},
 {"type":
  "{t t' : Type u → Type u} →\n  ((α : Type u) → t α ≃ t' α) →\n    [inst : Traversable t] →\n      {m : Type u → Type u} → [inst : Applicative m] → {α β : Type u} → (α → m β) → t' α → m (t' β)",
  "name": "Equiv.traverse",
  "kind": "def",
  "doc_string":
  "Like `Equiv.map`, a function `t' : Type u → Type u` can be given\nthe structure of a traversable functor using a traversable functor\n`t'` and equivalences `t α ≃ t' α` for all α. See `Equiv.traversable`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Inhabited α] → LazyList α → α",
  "name": "LazyList.headI",
  "kind": "def",
  "doc_string":
  "Returns the first element of the lazy list,\nor `default` if the lazy list is empty.\n",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List (List α)",
  "name": "List.sublists'",
  "kind": "def",
  "doc_string":
  "`sublists' l` is the list of all (non-contiguous) sublists of `l`.\nIt differs from `sublists` only in the order of appearance of the sublists;\n`sublists'` uses the first element of the list as the MSB,\n`sublists` uses the first element of the list as the LSB.\n```\nsublists' [1, 2, 3] = [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]\n```\n",
  "args": ""},
 {"type": "{α : Type u} → (α → α → Prop) → Setoid α",
  "name": "EqvGen.Setoid",
  "kind": "def",
  "doc_string":
  "`EqvGen.Setoid r` is the setoid generated by a relation `r`.\n\nThe motivation for this definition is that `Quot r` behaves like `Quotient (EqvGen.Setoid r)`,\nsee for example `Quot.exact` and `Quot.EqvGen_sound`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, 1 ≤ a → 1 ≤ b → 1 ≤ a * b",
  "name": "Left.one_le_mul",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_le_mul`. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {G₀ : Type u_2} {G₀' : Type u_3} [inst : GroupWithZero G₀] [inst_1 : GroupWithZero G₀']\n  [inst_2 : MonoidWithZeroHomClass F G₀ G₀'] (f : F) (x : G₀) (n : ℤ), ↑f (x ^ n) = ↑f x ^ n",
  "name": "map_zpow₀",
  "kind": "theorem",
  "doc_string":
  "If a monoid homomorphism `f` between two `GroupWithZero`s maps `0` to `0`, then it maps `x^n`,\n`n : ℤ`, to `(f x)^n`. ",
  "args": ""},
 {"type": "Type",
  "name": "Dynamic",
  "kind": "def",
  "doc_string":
  "Type-tagged union that can store any type with a `TypeName` instance.\n\nThis is roughly equivalent to `(α : Type) × TypeName α × α` but without the\nuniverse bump.\n",
  "args": ""},
 {"type":
  "{G₀ : Type u_1} →\n  {G₀' : Type u_2} →\n    [inst : GroupWithZero G₀] →\n      [inst_1 : Zero G₀'] →\n        [inst_2 : Mul G₀'] →\n          [inst_3 : One G₀'] →\n            [inst_4 : Inv G₀'] →\n              [inst_5 : Div G₀'] →\n                [inst_6 : Pow G₀' ℕ] →\n                  [inst_7 : Pow G₀' ℤ] →\n                    (f : G₀' → G₀) →\n                      Function.Injective f →\n                        f 0 = 0 →\n                          f 1 = 1 →\n                            (∀ (x y : G₀'), f (x * y) = f x * f y) →\n                              (∀ (x : G₀'), f x⁻¹ = (f x)⁻¹) →\n                                (∀ (x y : G₀'), f (x / y) = f x / f y) →\n                                  (∀ (x : G₀') (n : ℕ), f (x ^ n) = f x ^ n) →\n                                    (∀ (x : G₀') (n : ℤ), f (x ^ n) = f x ^ n) → GroupWithZero G₀'",
  "name": "Function.Injective.groupWithZero",
  "kind": "def",
  "doc_string":
  "Pullback a `GroupWithZero` along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HShiftRight",
  "kind": "inductive",
  "doc_string":
  "The typeclass behind the notation `a >>> b : γ` where `a : α`, `b : β`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {t : α → Set β} → (∀ (i j : α), i ≠ j → Disjoint (t i) (t j)) → ↑(Set.unionᵢ fun i => t i) ≃ (i : α) × ↑(t i)",
  "name": "Set.unionEqSigmaOfDisjoint",
  "kind": "def",
  "doc_string": "Equivalence between a disjoint union and a dependent sum. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → {x : AddZeroClass M} → {x_1 : AddZeroClass N} → Coe (M →+ N) (AddHom M N)",
  "name": "AddMonoidHom.coeToAddHom",
  "kind": "def",
  "doc_string":
  "`AddMonoidHom` down-cast to an `AddHom`, forgetting the 0-preserving property.",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : LT α] → Prop",
  "name": "WellFoundedLT",
  "kind": "def",
  "doc_string": "A class for a well founded relation `<`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "termWithout_expected_type_",
  "kind": "def",
  "doc_string":
  "`without_expected_type t` instructs Lean to elaborate `t` without an expected type.\nRecall that terms such as `match ... with ...` and `⟨...⟩` will postpone elaboration until\nexpected type is known. So, `without_expected_type` is not effective in this case.\n",
  "args": ""},
 {"type": "∀ {α : Sort u_1} {p : α → Prop} (x : Subtype p), p ↑x",
  "name": "Subtype.prop",
  "kind": "theorem",
  "doc_string":
  "A version of `x.property` or `x.2` where `p` is syntactically applied to the coercion of `x`\ninstead of `x.1`. A similar result is `Subtype.mem` in `Data.Set.Basic`. ",
  "args": ""},
 {"type": "Lean.Name → Lean.Name → Lean.Name",
  "name": "Tactic.Alias.appendNamespace",
  "kind": "def",
  "doc_string":
  "Like `++`, except that if the right argument starts with `_root_` the namespace will be\nignored.\n```\nappendNamespace `a.b `c.d = `a.b.c.d\nappendNamespace `a.b `_root_.c.d = `c.d\n```\n\nTODO: Move this declaration to a more central location.\n",
  "args": ""},
 {"type": "{α : Sort u} → α → PLift α",
  "name": "PLift.up",
  "kind": "def",
  "doc_string": "Lift a value into `PLift α` ",
  "args": ""},
 {"type": "Lean.Name → Lean.Name → Lean.CoreM Unit",
  "name": "ToAdditive.insertTranslation",
  "kind": "def",
  "doc_string":
  "Add a (multiplicative → additive) name translation to the translations map. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ {x y z : α}, r x y → r y z → r x z",
  "name": "Equivalence.trans",
  "kind": "def",
  "doc_string":
  "An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "CommMonoid",
  "kind": "inductive",
  "doc_string": "A commutative monoid is a monoid with commutative `(*)`. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → α × β → β",
  "name": "Prod.snd",
  "kind": "def",
  "doc_string":
  "The second projection out of a pair. if `p : α × β` then `p.2 : β`. ",
  "args": ""},
 {"type": "{K : Type u_1} → [inst : LinearOrderedField K] → ℚ ↪o K",
  "name": "Rat.castOrderEmbedding",
  "kind": "def",
  "doc_string": "Coercion from `ℚ` as an order embedding. ",
  "args": ""},
 {"type": "{α β : Type u} → MProd α β → β",
  "name": "MProd.snd",
  "kind": "def",
  "doc_string":
  "The second projection out of a pair. if `p : MProd α β` then `p.2 : β`. ",
  "args": ""},
 {"type": "Sat.Valuation → Prop → List Prop → ℕ → Prop",
  "name": "Sat.Valuation.implies",
  "kind": "def",
  "doc_string":
  "`v.implies p [a, b, c] 0` definitionally unfolds to `(v 0 ↔ a) → (v 1 ↔ b) → (v 2 ↔ c) → p`.\nThis is used to introduce assumptions about the first `n` values of `v` during reification. ",
  "args": ""},
 {"type": "Lean.Elab.Term.TermElab",
  "name": "Mathlib.RunCmd.elabRunElab",
  "kind": "def",
  "doc_string": "Elaborator for `by_elab`. ",
  "args": ""},
 {"type": "Type u_1 → Type u_2 → Type (max u_1 u_2)",
  "name": "Rel",
  "kind": "def",
  "doc_string":
  "A relation on `α` and `β`, aka a set-valued function, aka a partial multifunction ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {a b c d : α},\n  c ≠ 0 → d ≠ 0 → (a * d - b * c) / (c * d) < 0 → a / c < b / d",
  "name": "div_lt_div_of_mul_sub_mul_div_neg",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `mul_sub_mul_div_mul_neg_iff`.",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : AddGroup G] → G → Equiv.Perm G",
  "name": "Equiv.addRight",
  "kind": "def",
  "doc_string":
  "Right addition in an `AddGroup` is a permutation of the underlying type.",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (f : α → β) → (s : β → β → Prop) → f ⁻¹'o s →r s",
  "name": "RelHom.preimage",
  "kind": "def",
  "doc_string":
  "A function is a relation homomorphism from the preimage relation of `s` to `s`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Zero M] → [inst_1 : Zero N] → ZeroHom M N → ZeroHom (WithBot M) (WithBot N)",
  "name": "ZeroHom.withBotMap",
  "kind": "def",
  "doc_string": "A version of `WithBot.map` for `ZeroHom`s",
  "args": ""},
 {"type":
  "∀ (α : Type u) [inst : OrderedAddCommGroup α], ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "name": "OrderedAddCommGroup.to_contravariantClass_left_le",
  "kind": "def",
  "doc_string": "A choice-free shortcut instance.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : CancelCommMonoidWithZero α] →\n    [inst_1 : NormalizationMonoid α] →\n      [inst_2 : DecidableEq α] → (∀ (a b : α), ∃ c, ∀ (d : α), a ∣ d ∧ b ∣ d ↔ c ∣ d) → NormalizedGCDMonoid α",
  "name": "normalizedGCDMonoidOfExistsLCM",
  "kind": "def",
  "doc_string":
  "Define a `NormalizedGCDMonoid` structure on a monoid just from the existence of an `lcm`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  [inst : CancelMonoidWithZero R] →\n    {S : Submonoid R} →\n      (oreNum : R → { x // x ∈ S } → R) →\n        (oreDenom : R → { x // x ∈ S } → { x // x ∈ S }) →\n          (∀ (r : R) (s : { x // x ∈ S }), r * ↑(oreDenom r s) = ↑s * oreNum r s) → OreLocalization.OreSet S",
  "name": "OreLocalization.oreSetOfCancelMonoidWithZero",
  "kind": "def",
  "doc_string":
  "Cancellability in monoids with zeros can act as a replacement for the `ore_left_cancel`\ncondition of an ore set. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) → WithTop α →o WithTop β",
  "name": "OrderHom.withTopMap",
  "kind": "def",
  "doc_string":
  "Lift an order homomorphism `f : α →o β` to an order homomorphism `WithTop α →o WithTop β`. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → [self : Singleton α β] → α → β",
  "name": "Singleton.singleton",
  "kind": "def",
  "doc_string":
  "`singleton x` is a collection with the single element `x` (notation: `{x}`). ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tacticGet_elem_tactic_trivial",
  "kind": "def",
  "doc_string":
  "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith`\n(for doing linear arithmetic in the index).\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0",
  "name": "mul_self_add_mul_self_eq_zero",
  "kind": "theorem",
  "doc_string": "The sum of two squares is zero iff both elements are zero. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : LinearOrderedSemifield α] → (a : α) → 0 < a → α ≃o α",
  "name": "OrderIso.mulRight₀",
  "kind": "def",
  "doc_string": "`Equiv.mulRight₀` as an order_iso. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Preorder α] → (s t : Set α) → s = t → ↑s ≃o ↑t",
  "name": "OrderIso.setCongr",
  "kind": "def",
  "doc_string": "Order isomorphism between two equal sets. ",
  "args": ""},
 {"type":
  "Bool →\n  List Lean.Expr →\n    optParam Linarith.LinarithConfig\n        {\n          discharger := do\n            let __do_lift ←\n              do\n                let info ← Lean.MonadRef.mkInfoFromRefPos\n                let _ ← Lean.getCurrMacroScope\n                let _ ← Lean.getMainModule\n                pure { raw := Lean.Syntax.node1 info `Mathlib.Tactic.RingNF.ring (Lean.Syntax.atom info \"ring\") }\n            Lean.Elab.Tactic.evalTactic __do_lift.raw,\n          exfalso := true, transparency := Lean.Meta.TransparencyMode.reducible, split_hypotheses := true,\n          split_ne := false, preprocessors := none, oracle := none } →\n      Lean.MVarId → Lean.MetaM Unit",
  "name": "Linarith.linarith",
  "kind": "opaque",
  "doc_string":
  "`linarith only_on hyps cfg` tries to close the goal using linear arithmetic. It fails\nif it does not succeed at doing this.\n\n* `hyps` is a list of proofs of comparisons to include in the search.\n* If `only_on` is true, the search will be restricted to `hyps`. Otherwise it will use all\n  comparisons in the local context.\n* If `cfg.transparency := semireducible`,\n  it will unfold semireducible definitions when trying to match atomic expressions.\n",
  "args": ""},
 {"type": "{α : Type u} → [self : BEq α] → α → α → Bool",
  "name": "BEq.beq",
  "kind": "def",
  "doc_string": "Boolean equality, notated as `a == b`. ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Mul R] → R → Prop",
  "name": "IsLeftRegular",
  "kind": "def",
  "doc_string":
  "A left-regular element is an element `c` such that multiplication on the left by `c`\nis injective. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → AddHom M N ≃ AddHom Mᵐᵒᵖ Nᵐᵒᵖ",
  "name": "AddHom.mulOp",
  "kind": "def",
  "doc_string":
  "An additive semigroup homomorphism `AddHom M N` can equivalently be viewed as an additive\nhomomorphism `AddHom Mᵐᵒᵖ Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on\nmorphisms. ",
  "args": ""},
 {"type": "{K : Type u} → [self : RatCast K] → ℚ → K",
  "name": "RatCast.ratCast",
  "kind": "def",
  "doc_string": "The canonical homomorphism `ℚ → K`. ",
  "args": ""},
 {"type": "∀ {n a b : ℕ}, a ≤ b → (a ≡ b [MOD n] ↔ n ∣ b - a)",
  "name": "Nat.modEq_iff_dvd'",
  "kind": "theorem",
  "doc_string": "A variant of `modEq_iff_dvd` with `nat` divisibility ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrder α] → [inst_1 : Preorder β] → (f : α → β) → StrictMono f → Function.Surjective f → α ≃o β",
  "name": "StrictMono.orderIsoOfSurjective",
  "kind": "def",
  "doc_string":
  "A strictly monotone surjective function from a linear order is an order isomorphism. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : AddZeroClass M] → Top (AddSubmonoid M)",
  "name": "AddSubmonoid.instTopAddSubmonoid",
  "kind": "def",
  "doc_string": "The additive submonoid `M` of the `AddMonoid M`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} {n : ℕ} (v : Vector α n), List.length (Vector.toList v) = n",
  "name": "Vector.toList_length",
  "kind": "theorem",
  "doc_string":
  "The length of the list to which a vector of length `n` maps is `n`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Ring α] (self : Ring.PositiveCone α) (a b : α),\n  AddCommGroup.PositiveCone.pos self.toPositiveCone a →\n    AddCommGroup.PositiveCone.pos self.toPositiveCone b → AddCommGroup.PositiveCone.pos self.toPositiveCone (a * b)",
  "name": "Ring.PositiveCone.mul_pos",
  "kind": "def",
  "doc_string":
  "In a positive cone, if `a` and `b` are `pos` then so is `a * b` ",
  "args": ""},
 {"type":
  "{V : Type u_1} → [inst : Quiver V] → V → Quiver.WeaklyConnectedComponent V",
  "name": "Quiver.WeaklyConnectedComponent.mk",
  "kind": "def",
  "doc_string": "The weakly connected component corresponding to a vertex. ",
  "args": ""},
 {"type":
  "Mathlib.Prelude.Rename.RenameMap → Lean.NameMap (String × Lean.Name)",
  "name": "Mathlib.Prelude.Rename.RenameMap.toLean4",
  "kind": "def",
  "doc_string":
  "This maps `n3 ↦ (dubious, n4)` where `n3` is the lean 3 name and `n4` is the corresponding\nlean 4 name. `dubious` is either empty, or a warning message to be displayed when `n3` is\ntranslated, which indicates that the translation from `n3` to `n4` is approximate and may cause\ndownstream errors. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {a b c d : α},\n  c ≠ 0 → d ≠ 0 → a / c ≤ b / d → (a * d - b * c) / (c * d) ≤ 0",
  "name": "mul_sub_mul_div_mul_nonpos",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `mul_sub_mul_div_mul_nonpos_iff`.",
  "args": ""},
 {"type":
  "{V : Type u} → [inst : Quiver V] → (r : V) → [inst_1 : Quiver.RootedConnected r] → (b : V) → Quiver.Path r b",
  "name": "Quiver.shortestPath",
  "kind": "def",
  "doc_string": "A path from `r` of minimal length. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {p q : α → Prop} →\n    [inst : DecidablePred p] →\n      [inst : DecidablePred q] → { x // p x } ≃ { x // q x } → { x // ¬p x } ≃ { x // ¬q x } → Equiv.Perm α",
  "name": "Equiv.subtypeCongr",
  "kind": "def",
  "doc_string":
  "Combines an `Equiv` between two subtypes with an `Equiv` between their complements to form a\npermutation. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → AddHom M N ≃ AddHom Mᵃᵒᵖ Nᵃᵒᵖ",
  "name": "AddHom.op",
  "kind": "def",
  "doc_string":
  "An additive semigroup homomorphism `AddHom M N` can equivalently be viewed as an\nadditive semigroup homomorphism `AddHom Mᵃᵒᵖ Nᵃᵒᵖ`. This is the action of the\n(fully faithful)`ᵃᵒᵖ`-functor on morphisms.",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → List α → (α → List β) → List β",
  "name": "List.bindTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `bind`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : SemilatticeInf β] {f g : α → β},\n  Monotone f → Monotone g → Monotone (f ⊓ g)",
  "name": "Monotone.inf",
  "kind": "theorem",
  "doc_string":
  "Pointwise infimum of two monotone functions is a monotone function. ",
  "args": ""},
 {"type": "Mathlib.Tactic.LinearCombination.Config → Lean.Syntax.Tactic",
  "name": "Mathlib.Tactic.LinearCombination.Config.normTac",
  "kind": "def",
  "doc_string":
  "the tactic used for normalization when checking\nif the weighted sum is equivalent to the goal (when `normalize` is `true`). ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Tactic.NormCast.tacticApply_mod_cast_",
  "kind": "def",
  "doc_string":
  "Normalize the goal and the given expression, then apply the expression to the goal.\n",
  "args": ""},
 {"type": "ℕ → Num",
  "name": "Num.ofNat'",
  "kind": "def",
  "doc_string": "Converts a `Nat` to a `Num`. ",
  "args": ""},
 {"type":
  "Type u_1 →\n  (M : outParam (Type u_2)) →\n    (N : outParam (Type u_3)) → [inst : Zero M] → [inst : Zero N] → Type (max (max u_1 u_2) u_3)",
  "name": "ZeroHomClass",
  "kind": "inductive",
  "doc_string":
  "`ZeroHomClass F M N` states that `F` is a type of zero-preserving homomorphisms.\n\nYou should extend this typeclass when you extend `ZeroHom`.\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "List.«term_×ˢ_»",
  "kind": "def",
  "doc_string": "Notation for calculating the product of a `List`\n",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {α : Type u_2} → {β : Type u_3} → [inst : Preorder α] → [inst : Preorder β] → (ι → α) → (ι → β) → Prop",
  "name": "Antivary",
  "kind": "def",
  "doc_string": "`f` antivaries with `g` if `g i < g j` implies `f j ≤ f i`. ",
  "args": ""},
 {"type": "Linarith.Monom",
  "name": "Linarith.one",
  "kind": "def",
  "doc_string": "The unit monomial `one` is represented by the empty RBMap. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : OrderedAddCommMonoid α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "name": "OrderedAddCommMonoid.add_le_add_left",
  "kind": "def",
  "doc_string": "Addition is monotone in an `OrderedAddCommMonoid`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«command#helpAttrAttribute_»",
  "kind": "def",
  "doc_string":
  "The command `#help attribute` (or the short form `#help attr`) shows all attributes that have been\ndefined in the current environment.\nEach option has a format like:\n```\n[inline]: mark definition to always be inlined\n```\nThis says that `inline` is an attribute that can be placed on definitions like\n`@[inline] def foo := 1`. (Individual attributes may have restrictions on where they can be\napplied; see the attribute's documentation for details.) Both the attribute's `descr` field as well\nas the docstring will be displayed here.\n\nThe form `#help attr id` will show only attributes that begin with `id`.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R ≃+* S), ↑f 0 = 0",
  "name": "RingEquiv.map_zero",
  "kind": "theorem",
  "doc_string": "A ring isomorphism sends zero to zero. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] (x : α), CanonicallyOrderedCommSemiring.npow 0 x = 1",
  "name": "CanonicallyOrderedCommSemiring.npow_zero",
  "kind": "def",
  "doc_string": "Raising to the power `(0 : ℕ)` gives `1`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ) (l₁ : List α) (l₂ : List β),\n  List.length (List.map₂ f l₁ l₂) = min (List.length l₁) (List.length l₂)",
  "name": "List.length_map₂",
  "kind": "theorem",
  "doc_string":
  "Length of the list obtained by `map₂` on a pair of lists\nis the length of the shorter of the two. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (e : M ≃* N) (x : M), ↑(MulEquiv.symm e) (↑e x) = x",
  "name": "MulEquiv.symm_apply_apply",
  "kind": "theorem",
  "doc_string":
  "`e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "StrictOrderedCommSemiring",
  "kind": "inductive",
  "doc_string":
  "A `StrictOrderedCommSemiring` is a commutative semiring with a partial order such that\naddition is strictly monotone and multiplication by a positive number is strictly monotone. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisCoinsertion l u → ∀ (x : α), u (l x) ≤ x",
  "name": "GaloisCoinsertion.u_l_le",
  "kind": "def",
  "doc_string": "Main property of a Galois coinsertion. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {A : Type u_2} → [inst : Mul M] → [inst_1 : SetLike A M] → [hA : MulMemClass A M] → (S' : A) → Mul { x // x ∈ S' }",
  "name": "MulMemClass.mul",
  "kind": "def",
  "doc_string": "A submagma of a magma inherits a multiplication. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedCommGroup α] (a b : α), min a b = if a ≤ b then a else b",
  "name": "LinearOrderedCommGroup.min_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `minOfLe`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {M : Type u_3} →\n      [inst : Monoid R] →\n        [inst_1 : MulAction R M] →\n          [inst_2 : Monoid S] →\n            [inst_3 : SMul S M] →\n              (f : R →* S) → Function.Surjective ↑f → (∀ (c : R) (x : M), ↑f c • x = c • x) → MulAction S M",
  "name": "Function.Surjective.mulActionLeft",
  "kind": "def",
  "doc_string":
  "Push forward the action of `R` on `M` along a compatible surjective map `f : R →* S`.\n\nSee also `Function.Surjective.distribMulActionLeft` and `Function.Surjective.moduleLeft`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Semigroup α] {a b c : α}, a ∣ b → b ∣ c → a ∣ c",
  "name": "Dvd.dvd.trans",
  "kind": "theorem",
  "doc_string": "**Alias** of `dvd_trans`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] → {l : α → β} → {u : β → α} → GaloisInsertion l u → (x : α) → u (l x) ≤ x → β",
  "name": "GaloisInsertion.choice",
  "kind": "def",
  "doc_string": "A contructive choice function for images of `l`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Monoid α] (m : α), (∃ c, m = c ^ 2) → IsSquare m",
  "name": "isSquare_of_exists_sq",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `isSquare_iff_exists_sq`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, 0 < a → 0 < b → 0 < a + b",
  "name": "Left.add_pos",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_pos`.",
  "args": ""},
 {"type": "{α : Sort u} → (s : Setoid α) → α → Quotient s",
  "name": "Quotient.mk",
  "kind": "def",
  "doc_string": "The canonical quotient map into a `Quotient`. ",
  "args": ""},
 {"type": "Function.Injective fun x x_1 => x ∣ x_1",
  "name": "Nat.dvd_left_injective",
  "kind": "theorem",
  "doc_string": "`dvd` is injective in the left argument ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) → α → β",
  "name": "OrderHom.toFun",
  "kind": "def",
  "doc_string": "The underlying funcrion of an `OrderHom`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} (self : r ≃r s) {a b : α},\n  s (↑self.toEquiv a) (↑self.toEquiv b) ↔ r a b",
  "name": "RelIso.map_rel_iff'",
  "kind": "def",
  "doc_string":
  "Elements are related iff they are related after apply a `RelIso` ",
  "args": ""},
 {"type": "ℤ →*₀ ℕ",
  "name": "Int.natAbsHom",
  "kind": "def",
  "doc_string": "`Int.natAbs` as a bundled monoid with zero hom. ",
  "args": ""},
 {"type": "{α : Type u_1} → InfSet (Setoid α)",
  "name": "Setoid.instInfSetSetoid",
  "kind": "def",
  "doc_string": "The infimum of a set of equivalence relations. ",
  "args": ""},
 {"type": "Lean.MVarId → Lean.MetaM (Lean.HashSet Lean.MVarId)",
  "name": "Mathlib.Tactic.getUnassignedGoalMVarDependencies",
  "kind": "def",
  "doc_string":
  "Get all metavariables which `mvarId` depends on. These are the metavariables\nwhich occur in the target or local context or delayed assignment (if any) of\n`mvarId`, plus the metvariables which occur in these metavariables, etc.\n",
  "args": ""},
 {"type": "{α : Type u₁} → {β : Type u₂} → (α → β → Prop) → Prop",
  "name": "Relator.RightUnique",
  "kind": "def",
  "doc_string":
  "A relation is \"right unique\" if every element on the left is paired with at\nmost one element on the right. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → {x : MulZeroOneClass M} → {x_1 : MulZeroOneClass N} → Coe (M →*₀ N) (M →* N)",
  "name": "MonoidWithZeroHom.coeToMonoidHom",
  "kind": "def",
  "doc_string":
  "`MonoidWithZeroHom` down-cast to a `MonoidHom`, forgetting the 0-preserving property. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → β → γ) → List α → List β → List γ",
  "name": "List.zipWithTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `zipWith`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "OrderedCancelCommMonoid",
  "kind": "inductive",
  "doc_string":
  "An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Mul M] {S T : Subsemigroup M}, (∀ (x : M), x ∈ S ↔ x ∈ T) → S = T",
  "name": "Subsemigroup.ext",
  "kind": "theorem",
  "doc_string": "Two subsemigroups are equal if they have the same elements. ",
  "args": ""},
 {"type": "Simps.Config → Bool",
  "name": "Simps.Config.isSimp",
  "kind": "def",
  "doc_string": "Make generated lemmas simp lemmas ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → {α : Type u_3} → [inst : VAdd M α] → (N → M) → N → α → α",
  "name": "VAdd.comp.vadd",
  "kind": "def",
  "doc_string":
  "Auxiliary definition for `VAdd.comp`, `AddAction.compHom`, etc. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : OrderedCommMonoid α] →\n    {β : Type u_1} →\n      [inst_1 : One β] →\n        [inst_2 : Mul β] →\n          [inst_3 : Pow β ℕ] →\n            (f : β → α) →\n              Function.Injective f →\n                f 1 = 1 →\n                  (∀ (x y : β), f (x * y) = f x * f y) → (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) → OrderedCommMonoid β",
  "name": "Function.Injective.orderedCommMonoid",
  "kind": "def",
  "doc_string":
  "Pullback an `OrderedCommMonoid` under an injective map.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α] {x y : α}, IsCompl x y → Codisjoint x y",
  "name": "IsCompl.Codisjoint",
  "kind": "def",
  "doc_string":
  "If `x` and `y` are to be complementary in an order, they should be codisjoint. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a : α} [inst_1 : NoMinOrder α], Nonempty ↑(Set.Iio a)",
  "name": "Set.nonempty_Iio_subtype",
  "kind": "def",
  "doc_string":
  "In an order without minimal elements, the intervals `Iio` are nonempty. ",
  "args": ""},
 {"type": "Lean.Name → Lean.Name → Lean.CoreM Unit",
  "name": "ToAdditive.copyAttributes",
  "kind": "def",
  "doc_string": "Copy attributes to the additive name. ",
  "args": ""},
 {"type":
  "∀ {R : Type u₁} [inst : NonUnitalNonAssocSemiring R], IsScalarTower ℕ R R",
  "name": "NonUnitalNonAssocSemiring.nat_isScalarTower",
  "kind": "def",
  "doc_string":
  "Note that `AddCommMonoid.nat_isScalarTower` requires stronger assumptions on `R`. ",
  "args": ""},
 {"type": "LE Prop",
  "name": "Prop.le",
  "kind": "def",
  "doc_string":
  "Propositions form a complete boolean algebra, where the `≤` relation is given by implication. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → {γ : Sort u_3} → {δ : Sort u_4} → (α ↪ β) → (γ ↪ δ) → PProd α γ ↪ PProd β δ",
  "name": "Function.Embedding.pprodMap",
  "kind": "def",
  "doc_string":
  "If `e₁` and `e₂` are embeddings, then so is `λ ⟨a, b⟩, ⟨e₁ a, e₂ b⟩ : pprod α γ → pprod β δ`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_<$>_»",
  "kind": "def",
  "doc_string": "If `f : α → β` and `x : F α` then `f <$> x : F β`. ",
  "args": ""},
 {"type": "{p : Prop} → ¬p → p ≃ PEmpty",
  "name": "Equiv.propEquivPEmpty",
  "kind": "def",
  "doc_string":
  "The `Sort` of proofs of a false proposition is equivalent to `PEmpty`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) →o α → β",
  "name": "OrderHom.coeFnHom",
  "kind": "def",
  "doc_string":
  "The \"forgetful functor\" from `α →o β` to `α → β` that takes the underlying function,\nis monotone. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Set α → Set β",
  "name": "Set.kernImage",
  "kind": "def",
  "doc_string": "`kernImage f s` is the set of `y` such that `f ⁻¹ y ⊆ s`. ",
  "args": ""},
 {"type": "∀ {a b : Prop}, (a → b) → ¬b → ¬a",
  "name": "Function.mt",
  "kind": "theorem",
  "doc_string":
  "Provide modus tollens (`mt`) as dot notation for implications. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CommMonoid α] (a b u : α), IsUnit u → (a ∣ u * b ↔ a ∣ b)",
  "name": "IsUnit.dvd_mul_left",
  "kind": "theorem",
  "doc_string":
  "In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left\nassociates of `b`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⋖_»",
  "kind": "def",
  "doc_string": "Notation for `Covby a b`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List (Option α) → List α → List α",
  "name": "List.fillNones",
  "kind": "def",
  "doc_string":
  "`fillNones xs ys` replaces the `none`s in `xs` with elements of `ys`. If there\nare not enough `ys` to replace all the `none`s, the remaining `none`s are\ndropped from `xs`.\n```\nfillNones [none, some 1, none, none] [2, 3] = [2, 1, 3]\n```\n",
  "args": ""},
 {"type":
  "{β : Type v} →\n  [inst : Zero β] →\n    [inst_1 : Add β] →\n      [inst_2 : Mul β] →\n        [inst_3 : SMul ℕ β] →\n          {α : Type u} →\n            [inst_4 : NonUnitalSemiring α] →\n              (f : β → α) →\n                Function.Injective f →\n                  f 0 = 0 →\n                    (∀ (x y : β), f (x + y) = f x + f y) →\n                      (∀ (x y : β), f (x * y) = f x * f y) →\n                        (∀ (x : β) (n : ℕ), f (n • x) = n • f x) → NonUnitalSemiring β",
  "name": "Function.Injective.nonUnitalSemiring",
  "kind": "def",
  "doc_string":
  "Pullback a `NonUnitalSemiring` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → List α → Array α → List α",
  "name": "List.takeWhileTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `takeWhile`: `takeWhile.go p l xs acc = acc.toList ++ takeWhile p xs`,\nunless no element satisfying `p` is found in `xs` in which case it returns `l`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → CoeFun (α →o β) fun x => α → β",
  "name": "OrderHom.instCoeFunOrderHomForAll",
  "kind": "def",
  "doc_string":
  "Helper instance for when there's too many metavariables to apply the coercion via `FunLike`\ndirectly. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrder α] {s : Set α}, ¬BddAbove s ↔ ∀ (x : α), ∃ y, y ∈ s ∧ x < y",
  "name": "not_bddAbove_iff",
  "kind": "theorem",
  "doc_string":
  "A set `s` is not bounded above if and only if for each `x` there exists `y ∈ s` that is greater\nthan `x`. A version for preorders is called `not_bddAbove_iff'`. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Monoid M] → {a : M} → IsUnit a → Mˣ",
  "name": "IsUnit.unit",
  "kind": "def",
  "doc_string":
  "The element of the group of units, corresponding to an element of a monoid which is a unit. When\n`α` is a `DivisionMonoid`, use `IsUnit.unit'` instead. ",
  "args": ""},
 {"type": "ℕ → Prop",
  "name": "Nat.Prime",
  "kind": "def",
  "doc_string":
  "`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`. ",
  "args": ""},
 {"type": "ℕ",
  "name": "Nat.zero",
  "kind": "def",
  "doc_string":
  "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [inst_3 : OrderedSub α] {a b : α},\n  b - (b - a) ≤ a",
  "name": "tsub_tsub_le",
  "kind": "theorem",
  "doc_string": "See `tsub_tsub_cancel_of_le` for the equality. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {α : Type u_2} [inst : VAdd M α] [self : AddAction.IsPretransitive M α] (x y : α), ∃ g, g +ᵥ x = y",
  "name": "AddAction.IsPretransitive.exists_vadd_eq",
  "kind": "def",
  "doc_string": "There is `g` such that `g +ᵥ x = y`. ",
  "args": ""},
 {"type": "Type",
  "name": "Aesop.SingleRuleTac",
  "kind": "def",
  "doc_string":
  "A `RuleTac` which generates only a single `RuleApplication` and does not use\nbranch state.\n",
  "args": ""},
 {"type": "Sort u → Type u",
  "name": "PLift",
  "kind": "inductive",
  "doc_string": "Universe lifting operation from `Sort u` to `Type u`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → M ≃* N → N ≃* M",
  "name": "MulEquiv.symm",
  "kind": "def",
  "doc_string": "The inverse of an isomorphism is an isomorphism. ",
  "args": ""},
 {"type": "{α : Sort u} → [self : Hashable α] → α → UInt64",
  "name": "Hashable.hash",
  "kind": "def",
  "doc_string": "Hashes the value `a : α` into a `UInt64`. ",
  "args": ""},
 {"type": "(α : Type u_1) → (β : Type u_2) → [inst : Unique β] → β × α ≃ α",
  "name": "Equiv.uniqueProd",
  "kind": "def",
  "doc_string":
  "Any `Unique` type is a left identity for type product up to equivalence. ",
  "args": ""},
 {"type": "Type",
  "name": "Nat.Primes",
  "kind": "def",
  "doc_string": "The type of prime numbers ",
  "args": ""},
 {"type": "(α : Type u) → [inst : LT α] → Prop",
  "name": "DenselyOrdered",
  "kind": "inductive",
  "doc_string":
  "An order is dense if there is an element between any pair of distinct comparable elements. ",
  "args": ""},
 {"type": "{R : Type u} → [self : EuclideanDomain R] → R → R → R",
  "name": "EuclideanDomain.remainder",
  "kind": "def",
  "doc_string":
  "A remainder function (denoted `%`) on `R`.\nThis satisfies the property `b * (a / b) + a % b = a`, where `/` denotes `quotient`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ≃+* S),\n  RingHom.toAddMonoidHom ↑f = AddEquiv.toAddMonoidHom ↑f",
  "name": "RingEquiv.toAddMonoidMom_commutes",
  "kind": "theorem",
  "doc_string":
  "The two paths coercion can take to an `AddMonoidHom` are equivalent ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : OrderedSemiring S] (self : AbsoluteValue R S) (x : R),\n  ↑self.toMulHom x = 0 ↔ x = 0",
  "name": "AbsoluteValue.eq_zero'",
  "kind": "def",
  "doc_string": "The absolute value is positive definitive ",
  "args": ""},
 {"type": "∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] (a : G₀), a / a * a = a",
  "name": "div_self_mul_self",
  "kind": "theorem",
  "doc_string":
  "Dividing `a` by itself and then multiplying by itself results in `a`, whether or not `a` is\nzero. ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Mul M] → MulAut M →* Equiv.Perm M",
  "name": "MulAut.toPerm",
  "kind": "def",
  "doc_string":
  "Monoid hom from the group of multiplicative automorphisms to the group of permutations. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_<<<_»",
  "kind": "def",
  "doc_string":
  "`a <<< b` computes `a` shifted to the left by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat`, this is equivalent to `a * 2 ^ b`.\n* On `UInt8` and other fixed width unsigned types, this is the same but\n  truncated to the bit width. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "PSigma.«Σₗ'_,_»",
  "kind": "def",
  "doc_string":
  "The notation `Σₗ' i, α i` refers to a sigma type which is locall equipped with the\nlexicographic order.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] {a b : α} [inst_1 : IsAntisymm α fun x x_1 => x ⊆ x_1], a ⊆ b → b ⊆ a → b = a",
  "name": "HasSubset.Subset.antisymm'",
  "kind": "theorem",
  "doc_string": "**Alias** of `superset_antisymm`.",
  "args": ""},
 {"type": "Bool → Bool",
  "name": "not",
  "kind": "def",
  "doc_string":
  "`not x`, or `!x`, is the boolean \"not\" operation (not to be confused\nwith `Not : Prop → Prop`, which is the propositional connective).\n",
  "args": ""},
 {"type": "ℤ → Sat.Literal",
  "name": "Sat.Literal.ofInt",
  "kind": "def",
  "doc_string":
  "Construct a literal. Positive numbers are translated to positive literals,\nand negative numbers become negative literals. The input is assumed to be nonzero. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : CanonicallyLinearOrderedMonoid α] → DecidableEq α",
  "name": "CanonicallyLinearOrderedMonoid.decidable_eq",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : GeneralizedCoheytingAlgebra α] (a : α), ⊥ ≤ a",
  "name": "GeneralizedCoheytingAlgebra.bot_le",
  "kind": "def",
  "doc_string": "`⊥` is a least element ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : SuccOrder α] [inst_2 : IsSuccArchimedean α] (r : α → α → Prop)\n  {n m : α}, (∀ (i : α), i ∈ Set.Ico m n → r (Order.succ i) i) → m ≤ n → Relation.ReflTransGen r n m",
  "name": "reflTransGen_of_succ_of_ge",
  "kind": "theorem",
  "doc_string":
  "For `m ≤ n`, `(n, m)` is in the reflexive-transitive closure of `~` if `succ i ~ i`\nfor all `i` between `n` and `m`. ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsSymm",
  "kind": "inductive",
  "doc_string":
  "`IsSymm X r` means the binary relation `r` on `X` is symmetric. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Add M] →\n      [inst_1 : Add N] →\n        {f : AddHom M N} → Function.Injective ↑f → GaloisCoinsertion (AddSubsemigroup.map f) (AddSubsemigroup.comap f)",
  "name": "AddSubsemigroup.gciMapComap",
  "kind": "def",
  "doc_string":
  "`map f` and `comap f` form a `GaloisCoinsertion` when `f` is injective. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "WithOne",
  "kind": "def",
  "doc_string": "Add an extra element `1` to a type ",
  "args": ""},
 {"type": "{α : Sort u} → (x : α) → {β : Sort v} → [self : CoeDep α x β] → β",
  "name": "CoeDep.coe",
  "kind": "def",
  "doc_string":
  "The resulting value of type `β`. The input `x : α` is a parameter to\nthe type class, so the value of type `β` may possibly depend on additional\ntypeclasses on `x`. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u_1} →\n          [inst_2 : CategoryTheory.Category E] →\n            {F G : C ⥤ D} →\n              (H : D ⥤ E) →\n                [inst_3 : CategoryTheory.Full H] → [inst_4 : CategoryTheory.Faithful H] → (F ≅ G) ≃ (F ⋙ H ≅ G ⋙ H)",
  "name": "CategoryTheory.NatIso.equivOfCompFullyFaithful",
  "kind": "def",
  "doc_string":
  "Horizontal composition with a fully faithful functor induces a bijection on\nnatural isomorphisms. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddMonoid R] {a b : R}, a + b = 0 → IsAddRightRegular a",
  "name": "isAddRightRegular_of_add_eq_zero",
  "kind": "theorem",
  "doc_string":
  "An element admitting a right additive opposite is add-right-regular.",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : Fintype α] (x : α), x ∈ Fintype.elems",
  "name": "Fintype.complete",
  "kind": "def",
  "doc_string":
  "The proof that every term of the type is contained in the `Finset` of elements. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → Array (List α) → Array (List α)",
  "name": "List.sectionsTR.go",
  "kind": "def",
  "doc_string":
  "`go : List α → Array (List α) → Array (List α)` inserts one list into the accumulated\nlist of sections `acc`: `go [a, b] #[l₁, l₂] = [a::l₁, b::l₁, a::l₂, b::l₂]`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α),\n  (∀ (a₁ : α), a₁ ≠ a₂ → Option.isSome (PEquiv.toFun f a₁) = true) → Function.Injective f.toFun",
  "name": "PEquiv.injective_of_forall_ne_isSome",
  "kind": "theorem",
  "doc_string":
  "If the domain of a `PEquiv` is `α` except a point, its forward direction is injective. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HAppend α β γ] → α → β → γ",
  "name": "HAppend.hAppend",
  "kind": "def",
  "doc_string":
  "`a ++ b` is the result of concatenation of `a` and `b`, usually read \"append\".\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {α : ι → Type u_2} → Set ι → ((i : ι) → Set (α i)) → Set ((i : ι) × α i)",
  "name": "Set.Sigma",
  "kind": "def",
  "doc_string":
  "Indexed sum of sets. `s.sigma t` is the set of dependent pairs `⟨i, a⟩` such that `i ∈ s` and\n`a ∈ t i`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [inst_3 : ZeroLEOneClass α], 0 ≤ 1",
  "name": "zero_le_one",
  "kind": "theorem",
  "doc_string": "`zero_le_one` with the type argument implicit. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → β ⊕ γ) → List α → List β × List γ",
  "name": "List.partitionMap",
  "kind": "def",
  "doc_string":
  "Given a function `f : α → β ⊕ γ`, `partitionMap f l` maps the list by `f`\nwhilst partitioning the result it into a pair of lists, `List β × List γ`,\npartitioning the `.inl _` into the left list, and the `.inr _` into the right List.\n```\npartitionMap (id : Nat ⊕ Nat → Nat ⊕ Nat) [inl 0, inr 1, inl 2] = ([0, 2], [1])\n```\n",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsStrictTotalOrder",
  "kind": "inductive",
  "doc_string":
  "`IsStrictTotalOrder X lt` means that the binary relation `lt` on `X` is a strict total order,\nthat is, `IsTrichotomous X lt` and `IsStrictOrder X lt`. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Mul M] → Top (Subsemigroup M)",
  "name": "Subsemigroup.instTopSubsemigroup",
  "kind": "def",
  "doc_string": "The subsemigroup `M` of the magma `M`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Zero M] → [inst_1 : Zero N] → ZeroHom M N → ZeroHom (WithTop M) (WithTop N)",
  "name": "ZeroHom.withTopMap",
  "kind": "def",
  "doc_string": "A version of `WithTop.map` for `ZeroHom`s",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Set.«⋂_,_»",
  "kind": "def",
  "doc_string":
  "Notation for `Set.interᵢ`. Indexed intersection of a family of sets ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s t : Set α},\n  MonotoneOn f t → s ⊆ t → Set.Nonempty (lowerBounds s ∩ t) → BddBelow (f '' s)",
  "name": "MonotoneOn.map_bddBelow",
  "kind": "theorem",
  "doc_string":
  "The image under a monotone function on a set `t` of a subset which has a lower bound in `t`\nis bounded below. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "ToAdditive.expand",
  "kind": "def",
  "doc_string":
  "`e.expand` eta-expands all expressions that have as head a constant `n` in\n`reorder`. They are expanded until they are applied to one more argument than the maximum in\n`reorder.find n`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] →\n        (f : M →* N) → {g : N → M} → Function.LeftInverse g ↑f → M ≃* { x // x ∈ MonoidHom.mrange f }",
  "name": "MulEquiv.ofLeftInverse'",
  "kind": "def",
  "doc_string":
  "A monoid homomorphism `f : M →* N` with a left-inverse `g : N → M` defines a multiplicative\nequivalence between `M` and `f.mrange`.\nThis is a bidirectional version of `MonoidHom.mrange_restrict`. ",
  "args": ""},
 {"type": "∀ {a b : Prop} [inst : Decidable a], (¬a → b) → ¬b → a",
  "name": "Not.decidable_imp_symm",
  "kind": "theorem",
  "doc_string": "**Alias** of `Decidable.not_imp_symm`.",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrderedCancelAddCommMonoid α] → DecidableRel fun x x_1 => x < x_1",
  "name": "LinearOrderedCancelAddCommMonoid.decidable_lt",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, a ≤ 0 → b < 0 → a + b < 0",
  "name": "add_neg_of_nonpos_of_neg",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.add_neg_of_nonpos_of_neg`.",
  "args": ""},
 {"type": "Type u → Type u → Type u → Type u",
  "name": "EStateM",
  "kind": "def",
  "doc_string":
  "`EStateM ε σ` is a combined error and state monad, equivalent to\n`ExceptT ε (StateM σ)` but more efficient.\n",
  "args": ""},
 {"type":
  "∀ {obj : Type u} [self : CategoryTheory.Category obj] {X Y : obj} (f : X ⟶ Y), 𝟙 X ≫ f = f",
  "name": "CategoryTheory.Category.id_comp",
  "kind": "def",
  "doc_string": "Identity morphisms are left identities for composition. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : BEq α] →\n    {m : Type u_2 → Type u_3} →\n      {σ : Type u_2} → [inst_1 : Monad m] → (σ → α → m σ) → σ → Aesop.UnorderedArraySet α → m σ",
  "name": "Aesop.UnorderedArraySet.foldM",
  "kind": "def",
  "doc_string": "O(n) ",
  "args": ""},
 {"type":
  "Lean.Expr → Lean.Expr → Lean.Meta.Simp.Result → Lean.MetaM (Lean.Expr × Lean.Expr)",
  "name": "Mathlib.Tactic.Zify.applySimpResultToProp'",
  "kind": "def",
  "doc_string":
  "A variant of `applySimpResultToProp` that cannot close the goal, but does not need a meta\nvariable and returns a tuple of a proof and the corresponding simplified proposition. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 4",
  "name": "four_pos",
  "kind": "theorem",
  "doc_string": "**Alias** of `zero_lt_four`.",
  "args": ""},
 {"type": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "name": "Subtype",
  "kind": "inductive",
  "doc_string":
  "`Subtype p`, usually written as `{x : α // p x}`, is a type which\nrepresents all the elements `x : α` for which `p x` is true. It is structurally\na pair-like type, so if you have `x : α` and `h : p x` then\n`⟨x, h⟩ : {x // p x}`. An element `s : {x // p x}` will coerce to `α` but\nyou can also make it explicit using `s.1` or `s.val`.\n",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {x : Q(«$α»)} →\n      (inst : autoParam Q(AddMonoidWithOne «$α») _auto✝) →\n        (lit : Q(ℕ)) → Q(Mathlib.Meta.NormNum.IsNat «$x» «$lit») → Mathlib.Meta.NormNum.Result x",
  "name": "Mathlib.Meta.NormNum.Result.isNat",
  "kind": "def",
  "doc_string":
  "The result is `lit : ℕ` (a raw nat literal) and `proof : isNat x lit`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Mul α] →\n      [inst_1 : HasDistribNeg α] →\n        [inst_2 : Neg β] →\n          [inst_3 : Mul β] →\n            (f : α → β) →\n              Function.Surjective f →\n                (∀ (a : α), f (-a) = -f a) → (∀ (a b : α), f (a * b) = f a * f b) → HasDistribNeg β",
  "name": "Function.Surjective.hasDistribNeg",
  "kind": "def",
  "doc_string":
  "A type endowed with `-` and `*` has distributive negation, if it admits a surjective map that\npreserves `-` and `*` from a type which has distributive negation. ",
  "args": ""},
 {"type":
  "(ρ : Type u) → {m : Type u → Type v} → [inst : MonadWithReaderOf ρ m] → {α : Type u} → (ρ → ρ) → m α → m α",
  "name": "withTheReader",
  "kind": "def",
  "doc_string":
  "Like `withReader`, but with `ρ` explicit. This is useful if a monad supports\n`MonadWithReaderOf` for multiple different types `ρ`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  1 ≤ a → 1 < b → 1 < a * b",
  "name": "Right.one_lt_mul_of_le_of_lt",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul_of_le_of_lt`. ",
  "args": ""},
 {"type": "(α : Type u_1) → ↑∅ ≃ Empty",
  "name": "Equiv.Set.empty",
  "kind": "def",
  "doc_string": "An empty set is equivalent to the `Empty` type. ",
  "args": ""},
 {"type":
  "{m : Type u → Type u_1} → [inst : Monad m] → {α : Type u} → Option (m α) → m (Option α)",
  "name": "Option.sequence",
  "kind": "def",
  "doc_string":
  "If you maybe have a monadic computation in a `[Monad m]` which produces a term of type `α`, then\nthere is a naturally associated way to always perform a computation in `m` which maybe produces a\nresult.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {f : ℕ → α},\n  Antitone f → ∀ (n : ℕ) {x : α}, f (n + 1) < x → x < f n → ∀ (a : ℕ), f a ≠ x",
  "name": "Antitone.ne_of_lt_of_lt_nat",
  "kind": "theorem",
  "doc_string":
  "If `f` is an antitone function from `ℕ` to a preorder such that `x` lies between `f (n + 1)` and\n`f n`, then `x` doesn't lie in the range of `f`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → [inst : AddMonoid R] → [inst : One R] → AddMonoidWithOne R",
  "name": "AddMonoidWithOne.binary",
  "kind": "def",
  "doc_string": "`AddMonoidWithOne` implementation using binary recursion. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Parser.Attr.zify_simps",
  "kind": "def",
  "doc_string":
  "The simpset `zify_simps` is used by the tactic `zify` to moved expression from `ℕ` to `ℤ`\nwhich gives a well-behaved substraction. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "calc",
  "kind": "def",
  "doc_string":
  "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n\n`calc` has term mode and tactic mode variants. This is the term mode variant.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.clog",
  "kind": "def",
  "doc_string":
  "`clog b n`, is the upper logarithm of natural number `n` in base `b`. It returns the smallest\n`k : ℕ` such that `n ≤ b^k`, so if `b^k = n`, it returns exactly `k`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "NonUnitalCommSemiring",
  "kind": "inductive",
  "doc_string":
  "A non-unital commutative semiring is a `NonUnitalSemiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`AddCommMonoid`), commutative semigroup (`CommSemigroup`), distributive laws (`Distrib`), and\nmultiplication by zero law (`MulZeroClass`). ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CommMonoid α] {a b : α} {u : αˣ}, ↑u * a ∣ b ↔ a ∣ b",
  "name": "Units.mul_left_dvd",
  "kind": "theorem",
  "doc_string":
  "In a commutative monoid, an element `a` divides an element `b` iff all\nleft associates of `a` divide `b`.",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} (P : Prop) [inst : Decidable P] (x y : α), (if ¬P then x else y) = if P then y else x",
  "name": "ite_not",
  "kind": "theorem",
  "doc_string":
  "Negation of the condition `P : Prop` in a `ite` is the same as swapping the branches. ",
  "args": ""},
 {"type": "{C : Type u} → [inst : CategoryTheory.Category C] → C → C → Type v",
  "name": "CategoryTheory.Iso",
  "kind": "inductive",
  "doc_string":
  "An isomorphism (a.k.a. an invertible morphism) between two objects of a category.\nThe inverse morphism is bundled.\n\nSee also `CategoryTheory.Core` for the category with the same objects and isomorphisms playing\nthe role of morphisms.\n\nSee <https://stacks.math.columbia.edu/tag/0017>.\n",
  "args": ""},
 {"type": "Num → Num → Num",
  "name": "Num.add",
  "kind": "def",
  "doc_string": "Addition of two `Num`s. ",
  "args": ""},
 {"type": "∀ {α : Sort u_1} {β : Sort u_2}, α ≃ β → (IsEmpty α ↔ IsEmpty β)",
  "name": "Equiv.isEmpty_congr",
  "kind": "theorem",
  "doc_string":
  "If `α` is equivalent to `β`, then `IsEmpty α` is equivalent to `IsEmpty β`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (r : α → α → Prop) → [inst : IsPreorder α r] → Antisymmetrization α r → α",
  "name": "ofAntisymmetrization",
  "kind": "def",
  "doc_string": "Get a representative from the antisymmetrization. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Sat.Clause",
  "kind": "inductive",
  "doc_string": "The representation of a global clause. ",
  "args": ""},
 {"type":
  "∀ {G : Type u} [inst : Add G] [self : IsRightCancelAdd G] (a b c : G), a + b = c + b → a = c",
  "name": "IsRightCancelAdd.add_right_cancel",
  "kind": "def",
  "doc_string": "Addition is right cancellative. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddCommSemigroup α] [inst_1 : PartialOrder α] [inst_2 : ExistsAddOfLE α]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_4 : Sub α] [inst_5 : OrderedSub α]\n  {b c : α} [inst_6 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  c ≤ b → ∀ (a : α), a + b - c = a + (b - c)",
  "name": "add_tsub_assoc_of_le",
  "kind": "theorem",
  "doc_string": "See `add_tsub_le_assoc` for an inequality. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : LE α] → [inst_1 : LE β] → α ≃o β → β ≃o α",
  "name": "OrderIso.symm",
  "kind": "def",
  "doc_string": "Inverse of an order isomorphism. ",
  "args": ""},
 {"type": "{α : Type u_1} → Set (Set α) → Set α",
  "name": "Set.interₛ",
  "kind": "def",
  "doc_string": "Intersection of a set of sets. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    (M : Type u_3) →\n      [inst : Semiring R] →\n        [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → [inst_3 : Semiring S] → (S →+* R) → Module S M",
  "name": "Module.compHom",
  "kind": "def",
  "doc_string":
  "Compose a `Module` with a `RingHom`, with action `f s • m`.\n\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : Semifield α], 0⁻¹ = 0",
  "name": "Semifield.inv_zero",
  "kind": "def",
  "doc_string": "The inverse of `0` in a group with zero is `0`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "DoResultBC",
  "kind": "inductive",
  "doc_string":
  "Auxiliary type used to compile `do` notation. It is an optimization of\n`DoResultPRBC PEmpty PEmpty σ` to remove the impossible cases,\nused when neither `pure` nor `return` are possible exit paths.\n",
  "args": ""},
 {"type":
  "{V : Type u} → [inst : Quiver V] → {a b : V} → Quiver.Path a b → List V",
  "name": "Quiver.Path.toList",
  "kind": "def",
  "doc_string":
  "Turn a path into a list. The list contains `a` at its head, but not `b` a priori. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {F G : C ⥤ D} → (F ≅ G) → (X : C) → Prefunctor.obj F.toPrefunctor X ≅ Prefunctor.obj G.toPrefunctor X",
  "name": "CategoryTheory.Iso.app",
  "kind": "def",
  "doc_string":
  "The application of a natural isomorphism to an object. We put this definition in a different\nnamespace, so that we can use `α.app` ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → (Mᵃᵒᵖ →+ Nᵃᵒᵖ) ≃ (M →+ N)",
  "name": "AddMonoidHom.unop",
  "kind": "def",
  "doc_string":
  "The 'unopposite' of an additive monoid homomorphism `Mᵃᵒᵖ →+ Nᵃᵒᵖ`. Inverse to\n`AddMonoidHom.op`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} (r s : Setoid α), r ⊔ s = EqvGen.Setoid fun x y => Setoid.Rel r x y ∨ Setoid.Rel s x y",
  "name": "Setoid.sup_eq_eqvGen",
  "kind": "theorem",
  "doc_string":
  "The supremum of two equivalence relations r and s is the equivalence closure of the binary\nrelation `x is related to y by r or s`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : OrderedSemiring S] (self : AbsoluteValue R S) (x : R),\n  0 ≤ ↑self.toMulHom x",
  "name": "AbsoluteValue.nonneg'",
  "kind": "def",
  "doc_string": "The absolute value is nonnegative ",
  "args": ""},
 {"type":
  "∀ {R : Type u₁} [inst : NonUnitalNonAssocRing R], IsScalarTower ℤ R R",
  "name": "NonUnitalNonAssocRing.int_isScalarTower",
  "kind": "def",
  "doc_string":
  "Note that `AddCommGroup.int_isScalarTower` requires stronger assumptions on `R`. ",
  "args": ""},
 {"type": "ℕ → Lean.Expr → Lean.Expr × Lean.Expr",
  "name": "Mathlib.Tactic.Sat.buildReify.reifyClause",
  "kind": "def",
  "doc_string": "Returns `a` and `pr : reify v c a` given a clause `c` ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₂] →\n      [inst_1 : Zero M₂] →\n        [inst_2 : SMul ℕ M₂] →\n          [inst_3 : Neg M₂] →\n            [inst_4 : Sub M₂] →\n              [inst_5 : SMul ℤ M₂] →\n                [inst_6 : AddCommGroup M₁] →\n                  (f : M₁ → M₂) →\n                    Function.Surjective f →\n                      f 0 = 0 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁), f (-x) = -f x) →\n                            (∀ (x y : M₁), f (x - y) = f x - f y) →\n                              (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) → AddCommGroup M₂",
  "name": "Function.Surjective.addCommGroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `0` and `+` is an additive commutative group, if it\nadmits a surjective map that preserves `0` and `+` to an additive commutative group.",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β₁ : α → Type u_2} → {β₂ : α → Type u_3} → ((a : α) → β₁ a ≃ β₂ a) → (a : α) × β₁ a ≃ (a : α) × β₂ a",
  "name": "Equiv.sigmaCongrRight",
  "kind": "def",
  "doc_string":
  "A family of equivalences `Π a, β₁ a ≃ β₂ a` generates an equivalence between `Σ a, β₁ a` and\n`Σ a, β₂ a`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (r : α → α → Prop) → (s : β → β → Prop) → s ↪r Sum.LiftRel r s",
  "name": "RelEmbedding.sumLiftRelInr",
  "kind": "def",
  "doc_string": "`Sum.inr` as a relation embedding into `Sum.LiftRel r s`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Multiset",
  "kind": "def",
  "doc_string":
  "`Multiset α` is the quotient of `List α` by list permutation. The result\nis a type of finite sets with duplicates allowed.  ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] ⦃f g : M →ₙ* N⦄, ↑f = ↑g → f = g",
  "name": "MulHom.coe_inj",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.coe_injective` instead. ",
  "args": ""},
 {"type":
  "{α : Type u} → {n m : ℕ} → Vector α n → Vector α m → Vector α (n + m)",
  "name": "Vector.append",
  "kind": "def",
  "doc_string": "Appending a vector to another. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Sort u_2} → Option α → β → (α → β) → β",
  "name": "Option.elim",
  "kind": "def",
  "doc_string":
  "An elimination principle for `Option`. It is a nondependent version of `Option.recOn`. ",
  "args": ""},
 {"type": "(α : Type u_1) → Type u_2 → [inst : Ord α] → Type (max u_1 u_2)",
  "name": "Linarith.Map",
  "kind": "def",
  "doc_string":
  "A local abbreviation for `RBMap` so we don't need to write `Ord.compare` each time. ",
  "args": ""},
 {"type": "{α : Type u} → Set α → Prop",
  "name": "Set.Subsingleton",
  "kind": "def",
  "doc_string": "A set `s` is a `Subsingleton` if it has at most one element. ",
  "args": ""},
 {"type":
  "∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → Preorder (π i)] {a b c : (i : ι) → π i},\n  StrongLT a b → b ≤ c → StrongLT a c",
  "name": "StrongLT.trans_le",
  "kind": "theorem",
  "doc_string": "**Alias** of `strongLT_of_strongLT_of_le`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} →\n        (p : Set β) → (f : r ≼i s) → (∀ (a : α), (fun x => ↑f.toRelEmbedding.toEmbedding x) a ∈ p) → r ≼i Subrel s p",
  "name": "InitialSeg.codRestrict",
  "kind": "def",
  "doc_string": "Restrict the codomain of an initial segment ",
  "args": ""},
 {"type":
  "{α : Type u} → (lt : α → α → Prop) → [inst : DecidableRel lt] → α → α → Ordering",
  "name": "cmpUsing",
  "kind": "def",
  "doc_string":
  "Lift a decidable relation to an `Ordering`,\nassuming that incomparable terms are `Ordering.eq`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_5} {β : Type u_4} {γ : Type u_3} {a : Option α} {b : Option β} {α' : Type u_1} {δ : Type u_2}\n  {f : α' → β → γ} {g : α → α'} {f' : β → α → δ} {g' : δ → γ},\n  (∀ (a : α) (b : β), f (g a) b = g' (f' b a)) → Option.map₂ f (Option.map g a) b = Option.map g' (Option.map₂ f' b a)",
  "name": "Option.map₂_map_left_anticomm",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Option.map_map₂_antidistrib_left`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_2} [inst : Add M] {N : Type u_1} [inst_1 : Add N] (f : AddHom M N),\n  Function.Surjective ↑f → AddHom.srange f = ⊤",
  "name": "AddHom.srange_top_of_surjective",
  "kind": "theorem",
  "doc_string":
  "The range of a surjective `add_semigroup` hom is the whole of the codomain.",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : StrictOrderedCommRing α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → OrderedCommRing α",
  "name": "StrictOrderedCommRing.toOrderedCommRing'",
  "kind": "def",
  "doc_string":
  "A choice-free version of `StrictOrderedCommRing.toOrderedCommRing` to avoid using\nchoice in basic `Int` lemmas. ",
  "args": ""},
 {"type": "∀ {α : Sort u_1} [self : Infinite α], ¬Finite α",
  "name": "Infinite.not_finite",
  "kind": "def",
  "doc_string": "assertion that `α` is `¬Finite`",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α], 0 ≤ 1",
  "name": "CanonicallyLinearOrderedSemifield.zero_le_one",
  "kind": "def",
  "doc_string": "In a strict ordered semiring, `0 ≤ 1`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → α → Aesop.UnorderedArraySet α → Aesop.UnorderedArraySet α",
  "name": "Aesop.UnorderedArraySet.insert",
  "kind": "def",
  "doc_string": "O(n) ",
  "args": ""},
 {"type": "Bool → Bool → Bool",
  "name": "and",
  "kind": "def",
  "doc_string":
  "`and x y`, or `x && y`, is the boolean \"and\" operation (not to be confused\nwith `And : Prop → Prop → Prop`, which is the propositional connective).\nIt is `@[macro_inline]` because it has C-like short-circuiting behavior:\nif `x` is false then `y` is not evaluated.\n",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → {γ : Sort w} → {δ : Sort x} → α ≃ β → γ ≃ δ → (α ↪ γ) → β ↪ δ",
  "name": "Function.Embedding.congr",
  "kind": "def",
  "doc_string": "Transfer an embedding along a pair of equivalences. ",
  "args": ""},
 {"type": "{α : Type u_1} → {n : ℕ} → (Fin n → α) → ℕ → Array α → Array α",
  "name": "Array.ofFn.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `ofFn`. `ofFn.go f i acc = acc ++ #[f i, ..., f(n - 1)]` ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsRightCancelMulZero M₀] {a b c : M₀},\n  b ≠ 0 → a * b = c * b → a = c",
  "name": "IsRightCancelMulZero.mul_right_cancel_of_ne_zero",
  "kind": "def",
  "doc_string": "Multiplicatin by a nonzero element is right cancellative. ",
  "args": ""},
 {"type":
  "{p : ℕ+ → Sort u_1} → (n : ℕ+) → ((k : ℕ+) → ((m : ℕ+) → m < k → p m) → p k) → p n",
  "name": "PNat.strongInductionOn",
  "kind": "def",
  "doc_string": "Strong induction on `ℕ+`. ",
  "args": ""},
 {"type": "∀ (p : True → Prop), (∀ (x : True), p x) ↔ p True.intro",
  "name": "forall_true_left",
  "kind": "theorem",
  "doc_string": "See `IsEmpty.forall_iff` for the `false` version. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : CompleteLattice α] (a : α) (f : β → α), (⨆ o, Option.elim o a f) = a ⊔ ⨆ b, f b",
  "name": "supᵢ_option_elim",
  "kind": "theorem",
  "doc_string":
  "A version of `supᵢ_option` useful for rewriting right-to-left. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α] (a : α), CanonicallyLinearOrderedSemifield.zpow 0 a = 1",
  "name": "CanonicallyLinearOrderedSemifield.zpow_zero'",
  "kind": "def",
  "doc_string": "`a ^ 0 = 1` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β} {s t : Set α} {c : α},\n  AntitoneOn f s → AntitoneOn f t → IsGreatest s c → IsLeast t c → AntitoneOn f (s ∪ t)",
  "name": "AntitoneOn.union_right",
  "kind": "theorem",
  "doc_string":
  "If `f` is antitone both on `s` and `t`, with `s` to the left of `t` and the center\npoint belonging to both `s` and `t`, then `f` is antitone on `s ∪ t` ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Prelude.Rename.NameEntry",
  "kind": "inductive",
  "doc_string": "An `olean` entry for the rename extension. ",
  "args": ""},
 {"type": "ℤ → ℤ → ℤ",
  "name": "Int.ldiff'",
  "kind": "def",
  "doc_string":
  "`ldiff' a b` performs bitwise set difference. For each corresponding\npair of bits taken as booleans, say `aᵢ` and `bᵢ`, it applies the\nboolean operation `aᵢ ∧ bᵢ` to obtain the `iᵗʰ` bit of the result.",
  "args": ""},
 {"type": "∀ (f : Bool → Bool) (x : Bool), f (f (f x)) = f x",
  "name": "Bool.apply_apply_apply",
  "kind": "theorem",
  "doc_string": "**Kaminski's Equation** ",
  "args": ""},
 {"type":
  "(M : Type u_1) → [inst : Mul M] → GaloisInsertion Subsemigroup.closure SetLike.coe",
  "name": "Subsemigroup.gi",
  "kind": "def",
  "doc_string": "`closure` forms a Galois insertion with the coercion to set. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : SemilatticeSup β] {f g : α → β},\n  Monotone f → Monotone g → Monotone (f ⊔ g)",
  "name": "Monotone.sup",
  "kind": "theorem",
  "doc_string":
  "Pointwise supremum of two monotone functions is a monotone function. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, 0 ≤ -a ↔ a ≤ 0",
  "name": "Right.nonneg_neg_iff",
  "kind": "theorem",
  "doc_string": "Uses `right` co(ntra)variant.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        [inst_2 : AddZeroClass α] → [inst_3 : AddZeroClass β] → (f : α →+o β) → (f' : α → β) → f' = ↑f → α →+o β",
  "name": "OrderAddMonoidHom.copy",
  "kind": "def",
  "doc_string":
  "Copy of an `OrderMonoidHom` with a new `toFun` equal to the old one. Useful to fix\ndefinitional equalities.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a b : α}, BddAbove s → a ∈ s → b < a → b < supₛ s",
  "name": "lt_csupₛ_of_lt",
  "kind": "theorem",
  "doc_string":
  "`b < supₛ s` when there is an element `a` in `s` with `b < a`, when `s` is bounded above.\nThis is essentially an iff, except that the assumptions for the two implications are\nslightly different (one needs boundedness above for one direction, nonemptiness and linear\norder for the other one), so we formulate separately the two implications, contrary to\nthe `CompleteLattice` case.",
  "args": ""},
 {"type": "Lean.Expr → Option (ℤ × ℕ)",
  "name": "Mathlib.Meta.NormNum.isRatLit",
  "kind": "def",
  "doc_string":
  "Extract the numerator `n : ℤ` and denomination `d : ℕ` if the expression is either\nan integer literal, or the division of one integer literal by another. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : NonAssocSemiring α] → ℕ →+* α",
  "name": "Nat.castRingHom",
  "kind": "def",
  "doc_string": "`Nat.cast : ℕ → α` as a `RingHom` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : Semifield α] (a : α), Semifield.zpow 0 a = 1",
  "name": "Semifield.zpow_zero'",
  "kind": "def",
  "doc_string": "`a ^ 0 = 1` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → β → γ) → List α → List β → Array γ → List γ",
  "name": "List.zipWithTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `zipWith`: `zipWith.go f as bs acc = acc.toList ++ zipWith f as bs` ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} →\n        [inst : PartialOrder α] →\n          [inst_1 : Preorder β] → [inst_2 : BoundedOrder β] → GaloisCoinsertion l u → BoundedOrder α",
  "name": "GaloisCoinsertion.liftBoundedOrder",
  "kind": "def",
  "doc_string":
  "Lift the top, bottom, suprema, and infima along a Galois coinsertion ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AsLinearOrder",
  "kind": "def",
  "doc_string":
  "Type synonym to create an instance of `LinearOrder` from a `PartialOrder` and `IsTotal α (≤)` ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : HasSup α] →\n      [inst_1 : HasInf α] →\n        [inst_2 : DistribLattice β] →\n          (f : α → β) →\n            Function.Injective f →\n              (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) → (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) → DistribLattice α",
  "name": "Function.Injective.distribLattice",
  "kind": "def",
  "doc_string":
  "A type endowed with `⊔` and `⊓` is a `DistribLattice`, if it admits an injective map that\npreserves `⊔` and `⊓` to a `DistribLattice`.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {n m : ℕ} (v : Vector α m), Vector.toList (Vector.take n v) = List.take n (Vector.toList v)",
  "name": "Vector.toList_take",
  "kind": "theorem",
  "doc_string":
  "`take` of vectors corresponds under `toList` to `take` of lists. ",
  "args": ""},
 {"type": "∀ {α : Sort u_1} {β : Sort u_2}, (α → β) → Nonempty α → Nonempty β",
  "name": "Nonempty.map",
  "kind": "theorem",
  "doc_string":
  "Given `f : α → β`, if `α` is nonempty then `β` is also nonempty.\n`Nonempty` cannot be a `functor`, because `Functor` is restricted to `Type`. ",
  "args": ""},
 {"type": "{α : Sort u} → [self : Inhabited α] → α",
  "name": "Inhabited.default",
  "kind": "def",
  "doc_string":
  "`default` is a function that produces a \"default\" element of any\n`Inhabited` type. This element does not have any particular specified\nproperties, but it is often an all-zeroes value. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {a : α}, 1 < a → ∀ (n : ℕ), ↑n ≤ a ^ n / (a - 1)",
  "name": "Nat.cast_le_pow_div_sub",
  "kind": "theorem",
  "doc_string":
  "For any `a > 1` and a natural `n` we have `n ≤ a ^ n / (a - 1)`. See also\n`nat.cast_le_pow_sub_div_sub` for a stronger inequality with `a ^ n - 1` in the numerator. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} → [inst : AddZeroClass α] → [inst_1 : MulOneClass β] → (Multiplicative α →* β) ≃ (α →+ Additive β)",
  "name": "MonoidHom.toAdditive''",
  "kind": "def",
  "doc_string": "Reinterpret `Multiplicative α →* β` as `α →+ Additive β`. ",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.LinarithConfig",
  "kind": "inductive",
  "doc_string": "A configuration object for `linarith`. ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsAntisymm",
  "kind": "inductive",
  "doc_string":
  "`IsAntisymm X r` means the binary relation `r` on `X` is antisymmetric. ",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrderedCancelCommMonoid α] → DecidableEq α",
  "name": "LinearOrderedCancelCommMonoid.decidable_eq",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  [inst : SlimCheck.SampleableExt α] →\n    {β : α → Prop} →\n      [inst_1 : (x : α) → SlimCheck.Testable (β x)] →\n        SlimCheck.Configuration →\n          String →\n            (x : SlimCheck.SampleableExt.proxy α) →\n              SlimCheck.TestResult (β (SlimCheck.SampleableExt.interp x)) →\n                SlimCheck.Gen\n                  ((x : SlimCheck.SampleableExt.proxy α) × SlimCheck.TestResult (β (SlimCheck.SampleableExt.interp x)))",
  "name": "SlimCheck.Testable.minimize",
  "kind": "def",
  "doc_string":
  "Once a property fails to hold on an example, look for smaller counter-examples\nto show the user. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM (List Lean.Expr)",
  "name": "Linarith.splitConjunctions.aux",
  "kind": "opaque",
  "doc_string": "Implementation of the `splitConjunctions` preprocessor. ",
  "args": ""},
 {"type": "∀ (α : Type u_1), Subsingleton α ∨ Nontrivial α",
  "name": "subsingleton_or_nontrivial",
  "kind": "theorem",
  "doc_string": "A type is either a subsingleton or nontrivial. ",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrderedCancelCommMonoid α] → DecidableRel fun x x_1 => x < x_1",
  "name": "LinearOrderedCancelCommMonoid.decidable_lt",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "{α : Type u} → [self : LinearOrder α] → DecidableEq α",
  "name": "LinearOrder.decidable_eq",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "Type",
  "name": "Aesop.Options",
  "kind": "inductive",
  "doc_string":
  "Options that modify Aesop's behaviour. Available options are:\n\n- `strategy`: the search strategy to use.\n- `maxRuleApplicationDepth`: maximum number of rule applications in any branch\n  of the search tree, aka maximum search depth. When a branch exceeds this\n  limit, it is considered unprovable; other branches may still be explored. 0\n  means no limit.\n- `maxRuleApplications`: maximum number of rule applications in the search tree.\n  When this limit is exceeded, the search ends. 0 means no limit.\n- `maxGoals`: maximum number of goals in the search tree. When this limit is\n  exceeded, the search ends. 0 means no limit.\n- `maxNormIterations`: maximum number of norm rules applied to a *single* goal.\n  When this limit is exceeded, normalisation is likely stuck in an infinite loop\n  so Aesop fails. 0 means no limit.\n- `introsTransparency?`: if `true`, the builtin `intros` rule unfolds the goal's\n  target with the given transparency to discover `∀` binders. For example, with\n  `def T := ∀ x y : Nat, x = y`, `introsTransparency? := some .default` and goal\n  `⊢ T`, the `intros` rule produces the goal `x, y : Nat ⊢ x = y`. With\n  `introsTransparency? := some .reducible`, it produces `⊢ T`. With\n  `introsTransparency? := none`, it only introduces arguments which are\n  syntactically bound by `∀` binders, so it also produces `⊢ T`.\n- `terminal`: if `true`, Aesop succeeds only if it proves the goal. If `false`,\n  Aesop always succeeds and reports the goals remaining after safe rules were\n  applied.\n- `warnOnNonterminal`: print a warning when Aesop does not prove the goal.\n- `traceScript`: print a tactic script as a `Try this:` suggestion.\n",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → {F : Sort u_1} → [inst : EquivLike F α β] → CoeTC F (α ≃ β)",
  "name": "instCoeTCEquiv",
  "kind": "def",
  "doc_string":
  "Any type satisfying `EquivLike` can be cast into `Equiv` via `EquivLike.toEquiv`. ",
  "args": ""},
 {"type": "Linarith.Comp → Linarith.Comp → ℕ → Option (ℕ × ℕ)",
  "name": "Linarith.elimVar",
  "kind": "def",
  "doc_string":
  "If `c1` and `c2` both contain variable `a` with opposite coefficients,\nproduces `v1` and `v2` such that `a` has been cancelled in `v1*c1 + v2*c2`. ",
  "args": ""},
 {"type": "Type",
  "name": "Aesop.GoalOrigin",
  "kind": "inductive",
  "doc_string":
  "A goal `G` can be added to the tree for three reasons:\n\n1. `G` was produced by its parent rule as a subgoal. This is the most common\n   reason.\n2. `G` was copied because it contains some metavariables which were assigned by\n   its parent rule. In this case, we record goal of which `G` is a copy. We also\n   record the representative of the equivalence class of goals which are copies\n   of each other. E.g. if goal `1` is copied to goal `2` and goal `2` is copied\n   to goal `3`, they are all part of the equivalence class with representative\n   `1`.\n",
  "args": ""},
 {"type": "ℕ → List ℕ",
  "name": "List.iota",
  "kind": "def",
  "doc_string":
  "`O(n)`. `iota n` is the numbers from `1` to `n` inclusive, in decreasing order.\n* `iota 5 = [5, 4, 3, 2, 1]`\n",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : Group G] → G → Equiv.Perm G",
  "name": "Equiv.mulRight",
  "kind": "def",
  "doc_string":
  "Right multiplication in a `Group` is a permutation of the underlying type. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : DivisionSemiring α] (a b : α), a / b = a * b⁻¹",
  "name": "DivisionSemiring.div_eq_mul_inv",
  "kind": "def",
  "doc_string": "`a / b := a * b⁻¹` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → {x : MulOneClass M} → {x_1 : MulOneClass N} → (f : M →* N) → (f' : M → N) → f' = ↑f → M →* N",
  "name": "MonoidHom.copy",
  "kind": "def",
  "doc_string":
  "Copy of a `MonoidHom` with a new `toFun` equal to the old one. Useful to fix\ndefinitional equalities. ",
  "args": ""},
 {"type": "{α : Sort u_1} → {p : α → Prop} → (∃ a, p a) → α",
  "name": "Exists.choose",
  "kind": "def",
  "doc_string":
  "Extract an element from a existential statement, using `Classical.choose`. ",
  "args": ""},
 {"type": "Mathlib.Meta.NormNum.NormNumExt → Bool",
  "name": "Mathlib.Meta.NormNum.NormNumExt.pre",
  "kind": "def",
  "doc_string":
  "The extension should be run in the `pre` phase when used as simp plugin. ",
  "args": ""},
 {"type":
  "{V : Type u} → [inst : Quiver V] → {a b c : V} → Quiver.Path a b → Quiver.Path b c → Quiver.Path a c",
  "name": "Quiver.Path.comp",
  "kind": "def",
  "doc_string": "Composition of paths. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_↪o_»",
  "kind": "def",
  "doc_string": "Notation for an `OrderEmbedding`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] (f : M →* N), ↑f 1 = 1",
  "name": "MonoidHom.map_one",
  "kind": "theorem",
  "doc_string": "If `f` is a monoid homomorphism then `f 1 = 1`. ",
  "args": ""},
 {"type":
  "Type u_1 →\n  {α : outParam (Type u_2)} →\n    {β : outParam (Type u_3)} → outParam (α → α → Prop) → outParam (β → β → Prop) → Type (max (max u_1 u_2) u_3)",
  "name": "RelHomClass",
  "kind": "inductive",
  "doc_string":
  "`RelHomClass F r s` asserts that `F` is a type of functions such that all `f : F`\nsatisfy `r a b → s (f a) (f b)`.\n\nThe relations `r` and `s` are `outParam`s since figuring them out from a goal is a higher-order\nmatching problem that Lean usually can't do unaided.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddMonoid α], FaithfulSMul (AddMonoid.End α) α",
  "name": "AddMonoid.End.applyFaithfulSMul",
  "kind": "def",
  "doc_string": "`AddMonoid.End.applyDistribMulAction` is faithful. ",
  "args": ""},
 {"type":
  "{A : Type u₁} →\n  [inst : CategoryTheory.Category A] →\n    {B : Type u₂} →\n      [inst_1 : CategoryTheory.Category B] →\n        {C : Type u₃} →\n          [inst_2 : CategoryTheory.Category C] →\n            {D : Type u₄} →\n              [inst_3 : CategoryTheory.Category D] → (F : A ⥤ B) → (G : B ⥤ C) → (H : C ⥤ D) → (F ⋙ G) ⋙ H ≅ F ⋙ G ⋙ H",
  "name": "CategoryTheory.Functor.associator",
  "kind": "def",
  "doc_string":
  "The associator for functors, a natural isomorphism `((F ⋙ G) ⋙ H) ≅ (F ⋙ (G ⋙ H))`.\n\n(In fact, `iso.refl _` will work here, but it tends to make Lean slow later,\nand it's usually best to insert explicit associators.)\n",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Mul R] → R → Prop",
  "name": "IsRightRegular",
  "kind": "def",
  "doc_string":
  "A right-regular element is an element `c` such that multiplication on the right by `c`\nis injective. ",
  "args": ""},
 {"type": "{α : Type u_1} → (x : WithTop α) → x ≠ ⊤ → α",
  "name": "WithTop.untop",
  "kind": "def",
  "doc_string":
  "Deconstruct a `x : WithTop α` to the underlying value in `α`, given a proof that `x ≠ ⊤`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : PartialOrder α] →\n      [inst_1 : Preorder β] → {l : α → β} → {u : β → α} → GaloisConnection l u → ClosureOperator α",
  "name": "GaloisConnection.closureOperator",
  "kind": "def",
  "doc_string":
  "Every Galois connection induces a closure operator given by the composition. This is the partial\norder version of the statement that every adjunction induces a monad. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {f g : β → α},\n  MonotoneOn f s → StrictMonoOn g s → StrictMonoOn (fun x => f x + g x) s",
  "name": "MonotoneOn.add_strict_mono",
  "kind": "theorem",
  "doc_string":
  "The sum of a monotone function and a strictly monotone function is\nstrictly monotone.",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} → [inst : Mul R] → [inst_1 : Mul S] → [inst_2 : Add R] → [inst_3 : Add S] → R ≃+* S → R → S",
  "name": "RingEquiv.Simps.apply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type":
  "∀ {v : Sat.Valuation} {l : Sat.Literal} {a : Prop},\n  Sat.Literal.reify v l a → Sat.Clause.reify v (Sat.Clause.cons l Sat.Clause.nil) a",
  "name": "Sat.Clause.reify_one",
  "kind": "theorem",
  "doc_string": "The reification of a singleton clause `¬⟦l⟧_v ≡ ¬⟦l⟧_v`. ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : StrictOrderedRing α], 0 ≤ 1",
  "name": "StrictOrderedRing.zero_le_one",
  "kind": "def",
  "doc_string": "In a strict ordered ring, `0 ≤ 1`. ",
  "args": ""},
 {"type":
  "{β : Type v} →\n  [inst : Zero β] →\n    [inst_1 : Add β] →\n      [inst_2 : Mul β] →\n        [inst_3 : SMul ℕ β] →\n          {α : Type u} →\n            [inst_4 : NonUnitalNonAssocSemiring α] →\n              (f : β → α) →\n                Function.Injective f →\n                  f 0 = 0 →\n                    (∀ (x y : β), f (x + y) = f x + f y) →\n                      (∀ (x y : β), f (x * y) = f x * f y) →\n                        (∀ (x : β) (n : ℕ), f (n • x) = n • f x) → NonUnitalNonAssocSemiring β",
  "name": "Function.Injective.nonUnitalNonAssocSemiring",
  "kind": "def",
  "doc_string":
  "Pullback a `NonUnitalNonAssocRing` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HAdd α β γ] → α → β → γ",
  "name": "HAdd.hAdd",
  "kind": "def",
  "doc_string":
  "`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Mul M] (self : Subsemigroup M) {a b : M},\n  a ∈ self.carrier → b ∈ self.carrier → a * b ∈ self.carrier",
  "name": "Subsemigroup.mul_mem'",
  "kind": "def",
  "doc_string":
  "The product of two elements of a subsemigroup belongs to the subsemigroup. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {s₁ : Setoid α} →\n    {φ : Quotient s₁ → Sort u_2} →\n      [inst : ∀ (a : α), Subsingleton (φ (Quotient.mk s₁ a))] →\n        (q : Quotient s₁) → ((a : α) → φ (Quotient.mk'' a)) → φ q",
  "name": "Quotient.recOnSubsingleton'",
  "kind": "def",
  "doc_string":
  "A version of `Quotient.recOnSubsingleton` taking `{s₁ : Setoid α}` as an implicit argument\ninstead of an instance argument. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Monoid M] → [inst_1 : Monoid N] → (M × N)ˣ ≃* Mˣ × Nˣ",
  "name": "MulEquiv.prodUnits",
  "kind": "def",
  "doc_string":
  "The monoid equivalence between units of a product of two monoids, and the product of the\nunits of each monoid. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {σ : Type u_2} →\n    [inst : Add M] →\n      {N : Type u_3} →\n        [inst_1 : Add N] →\n          [inst_2 : SetLike σ M] → [inst_3 : AddMemClass σ M] → AddHom M N → (S : σ) → AddHom { x // x ∈ S } N",
  "name": "AddHom.restrict",
  "kind": "def",
  "doc_string":
  "Restriction of an AddSemigroup hom to an `AddSubsemigroup` of the domain.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedCommRing α] (a b : α), a * b = b * a",
  "name": "LinearOrderedCommRing.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : AddMonoid α] → AddUnits α → α",
  "name": "AddUnits.neg",
  "kind": "def",
  "doc_string": "The additive inverse value of `val` in the base `AddMonoid`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → α → α → Prop",
  "name": "AntisymmRel",
  "kind": "def",
  "doc_string": "The antisymmetrization relation. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : α → Set β} {x : α},\n  x ∈ s → (Set.interᵢ fun x => Set.interᵢ fun h => t x) ⊆ t x",
  "name": "Set.binterᵢ_subset_of_mem",
  "kind": "theorem",
  "doc_string": "A specialization of `interᵢ₂_subset`. ",
  "args": ""},
 {"type": "{α : Type u_1} → Semiquot α → Trunc α",
  "name": "Semiquot.toTrunc",
  "kind": "def",
  "doc_string": "Convert a `Semiquot α` to a `Trunc α`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⩿_»",
  "kind": "def",
  "doc_string": "Notation for `Wcovby a b`. ",
  "args": ""},
 {"type":
  "{M₀ : Type u_1} →\n  {M₀' : Type u_2} →\n    [inst : MulZeroClass M₀] →\n      [inst_1 : Mul M₀'] →\n        [inst_2 : Zero M₀'] →\n          (f : M₀' → M₀) → Function.Injective f → f 0 = 0 → (∀ (a b : M₀'), f (a * b) = f a * f b) → MulZeroClass M₀'",
  "name": "Function.Injective.mulZeroClass",
  "kind": "def",
  "doc_string":
  "Pullback a `MulZeroClass` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : Monoid α] → [inst_1 : HasDistribNeg α] → Neg αˣ",
  "name": "Units.instNegUnits",
  "kind": "def",
  "doc_string":
  "Each element of the group of units of a ring has an additive inverse. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → Array α → Aesop.UnorderedArraySet α",
  "name": "Aesop.UnorderedArraySet.ofDeduplicatedArray",
  "kind": "def",
  "doc_string": "Precondition: `xs` contains no duplicates. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : HasSup α] →\n      [inst_1 : HasInf α] →\n        [inst_2 : SupSet α] →\n          [inst_3 : InfSet α] →\n            [inst_4 : Top α] →\n              [inst_5 : Bot α] →\n                [inst_6 : CompleteLattice β] →\n                  (f : α → β) →\n                    Function.Injective f →\n                      (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) →\n                        (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) →\n                          (∀ (s : Set α), f (supₛ s) = ⨆ a, ⨆ h, f a) →\n                            (∀ (s : Set α), f (infₛ s) = ⨅ a, ⨅ h, f a) → f ⊤ = ⊤ → f ⊥ = ⊥ → CompleteLattice α",
  "name": "Function.Injective.completeLattice",
  "kind": "def",
  "doc_string": "Pullback a `CompleteLattice` along an injection. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} →\n      [inst : MulZeroOneClass M] →\n        [inst_1 : MulZeroOneClass N] → [inst_2 : MulZeroOneClass P] → (N →*₀ P) → (M →*₀ N) → M →*₀ P",
  "name": "MonoidWithZeroHom.comp",
  "kind": "def",
  "doc_string":
  "Composition of `MonoidWithZeroHom`s as a `MonoidWithZeroHom`. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  {D : Type u₂} → [inst : CategoryTheory.Category D] → (F : C → D) → CategoryTheory.InducedCategory D F ⥤ D",
  "name": "CategoryTheory.inducedFunctor",
  "kind": "def",
  "doc_string":
  "The forgetful functor from an induced category to the original category,\nforgetting the extra data.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] (P Q : Module R M),\n  (∀ (r : R) (m : M), r • m = r • m) → P = Q",
  "name": "Module.ext'",
  "kind": "theorem",
  "doc_string": "A variant of `Module.ext` that's convenient for term-mode. ",
  "args": ""},
 {"type": "∀ {p : ℕ}, Prime p → Nat.Prime p",
  "name": "Prime.nat_prime",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `Nat.prime_iff`.",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : MulOneClass M] → HasInf (Submonoid M)",
  "name": "Submonoid.instHasInfSubmonoid",
  "kind": "def",
  "doc_string": "The inf of two submonoids is their intersection. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} (self : TwoPointing α), self.toProd.fst ≠ self.toProd.snd",
  "name": "TwoPointing.fst_ne_snd",
  "kind": "def",
  "doc_string": "`fst` and `snd` are distinct terms ",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → {γ : Sort w} → [inst : Inhabited γ] → (α ↪ β) → (α → γ) ↪ β → γ",
  "name": "Function.Embedding.arrowCongrLeft",
  "kind": "def",
  "doc_string":
  "An embedding `e : α ↪ β` defines an embedding `(α → γ) ↪ (β → γ)` for any inhabited type `γ`.\nThis embedding sends each `f : α → γ` to a function `g : β → γ` such that `g ∘ e = f` and\n`g y = default` whenever `y ∉ range e`. ",
  "args": ""},
 {"type":
  "{β : Type v} →\n  [inst : Zero β] →\n    [inst_1 : Add β] →\n      [inst_2 : Mul β] →\n        [inst_3 : SMul ℕ β] →\n          {α : Type u} →\n            [inst_4 : NonUnitalSemiring α] →\n              (f : α → β) →\n                Function.Surjective f →\n                  f 0 = 0 →\n                    (∀ (x y : α), f (x + y) = f x + f y) →\n                      (∀ (x y : α), f (x * y) = f x * f y) →\n                        (∀ (x : α) (n : ℕ), f (n • x) = n • f x) → NonUnitalSemiring β",
  "name": "Function.Surjective.nonUnitalSemiring",
  "kind": "def",
  "doc_string":
  "Pushforward a `NonUnitalSemiring` instance along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Unit",
  "name": "Unit.unit",
  "kind": "def",
  "doc_string":
  "`Unit.unit : Unit` is the canonical element of the unit type.\nIt can also be written as `()`.\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "List.Func.«term_{_↦_}»",
  "kind": "def",
  "doc_string":
  "Update element of a list by index. If the index is out of range, extend the list with default\nelements\n",
  "args": ""},
 {"type":
  "∀ {K : Type u} [self : Field K] (n : ℕ) (a : K), Field.zpow (Int.negSucc n) a = (Field.zpow (↑(Nat.succ n)) a)⁻¹",
  "name": "Field.zpow_neg'",
  "kind": "def",
  "doc_string": "`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` ",
  "args": ""},
 {"type":
  "{α₁ : Type u_1} → {β₁ : Type u_2} → {β₂ : Type u_3} → (α₁ → β₁ ≃ β₂) → α₁ × β₁ ≃ α₁ × β₂",
  "name": "Equiv.prodCongrRight",
  "kind": "def",
  "doc_string":
  "A family of equivalences `∀ (a : α₁), β₁ ≃ β₂` generates an equivalence\nbetween `α₁ × β₁` and `α₁ × β₂`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, 1 < a → 1 ≤ b → 1 < a * b",
  "name": "one_lt_mul_of_lt_of_le'",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.one_lt_mul_of_lt_of_le`.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CanonicallyOrderedMonoid",
  "kind": "inductive",
  "doc_string":
  "A canonically ordered monoid is an ordered commutative monoid\nin which the ordering coincides with the divisibility relation,\nwhich is to say, `a ≤ b` iff there exists `c` with `b = a * c`.\nExamples seem rare; it seems more likely that the `OrderDual`\nof a naturally-occurring lattice satisfies this than the lattice\nitself (for example, dual of the lattice of ideals of a PID or\nDedekind domain satisfy this; collections of all things ≤ 1 seem to\nbe more natural that collections of all things ≥ 1).\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Tauto.tauto",
  "kind": "def",
  "doc_string":
  "`tauto` breaks down assumptions of the form `_ ∧ _`, `_ ∨ _`, `_ ↔ _` and `∃ _, _`\nand splits a goal of the form `_ ∧ _`, `_ ↔ _` or `∃ _, _` until it can be discharged\nusing `reflexivity` or `solve_by_elim`.\nThis is a finishing tactic: it either closes the goal or raises an error.\n\nThe Lean 3 version of this tactic by default attempted to avoid classical reasoning\nwhere possible. This Lean 4 version makes no such attempt. The `itauto` tactic\nis designed for that purpose.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (r : α → α → Prop) → (s : β → β → Prop) → [inst : IsEmpty α] → r ↪r s",
  "name": "RelEmbedding.ofIsEmpty",
  "kind": "def",
  "doc_string": "A relation embedding from an empty type. ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {F : C ⥤ D}\n  [self : CategoryTheory.Faithful F] {X Y : C}, Function.Injective (Prefunctor.map F.toPrefunctor)",
  "name": "CategoryTheory.Faithful.map_injective",
  "kind": "def",
  "doc_string": "`F.map` is injective for each `X Y : C`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Bundle.«term_*ᵖ_»",
  "kind": "def",
  "doc_string":
  "The pullback of a bundle `E` over a base `B` under a map `f : B' → B`, denoted by `Pullback f E`\nor `f *ᵖ E`,  is the bundle over `B'` whose fiber over `b'` is `E (f b')`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : LinearOrderedSemifield α] → (a : α) → 0 < a → α ≃o α",
  "name": "OrderIso.mulLeft₀",
  "kind": "def",
  "doc_string": "`Equiv.mulLeft₀` as an order_iso. ",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.GlobalBranchingPreprocessor",
  "kind": "inductive",
  "doc_string":
  "Some preprocessors perform branching case splits.\nA `GlobalBranchingPreprocessor` produces a list of branches to run.\nEach branch is independent, so hypotheses that appear in multiple branches should be duplicated.\nThe preprocessor is responsible for making sure that each branch contains the correct goal\nmetavariable.\n",
  "args": ""},
 {"type": "List Lean.Expr → Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Mathlib.Tactic.MkIff.mkExistsList",
  "kind": "def",
  "doc_string":
  "Generates an expression of the form `∃(args), inner`. `args` is assumed to be a list of fvars.\nWhen possible, `p ∧ q` is used instead of `∃(_ : p), q`. ",
  "args": ""},
 {"type":
  "{f : Type u₀ → Type u₁} → [self : EquivFunctor f] → {α β : Type u₀} → α ≃ β → f α → f β",
  "name": "EquivFunctor.map",
  "kind": "def",
  "doc_string": "The action of `f` on isomorphisms. ",
  "args": ""},
 {"type": "Type u → Type v → Type (max u v)",
  "name": "Pow",
  "kind": "inductive",
  "doc_string":
  "The homogeneous version of `HPow`: `a ^ b : α` where `a : α`, `b : β`.\n(The right argument is not the same as the left since we often want this even\nin the homogeneous case.)\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddCommGroup α] (n : ℤ) (x a : α), Mathlib.Tactic.Abel.termg n x a = n • x + a",
  "name": "Mathlib.Tactic.Abel.termg_eq",
  "kind": "theorem",
  "doc_string":
  "A type synonym used by `abel` to represent `n • x + a` in an additive commutative group. ",
  "args": ""},
 {"type":
  "(B : Type u_1) → (F : Type u_2) → Bundle.TotalSpace (Bundle.Trivial B F) → F",
  "name": "Bundle.Trivial.projSnd",
  "kind": "def",
  "doc_string":
  "The trivial bundle, unlike other bundles, has a canonical projection on the fiber. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {H : Type u_2} {M : Type u_3} [inst : SMul G H] [inst_1 : Group G] [inst_2 : Group H]\n  [inst_3 : Monoid M] [inst_4 : MulAction G M] [inst_5 : SMulCommClass G M M] [inst_6 : MulAction H M]\n  [inst_7 : SMulCommClass H M M] [inst_8 : IsScalarTower G M M] [inst_9 : IsScalarTower H M M]\n  [inst_10 : IsScalarTower G H M], IsScalarTower G H Mˣ",
  "name": "Units.isScalarTower'",
  "kind": "def",
  "doc_string": "Transfer `IsScalarTower G H M` to `IsScalarTower G H Mˣ` ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Quiver.Symmetrify",
  "kind": "def",
  "doc_string":
  "A type synonym for the symmetrized quiver (with an arrow both ways for each original arrow).\nNB: this does not work for `Prop`-valued quivers. It requires `[Quiver.{v+1} V]`. ",
  "args": ""},
 {"type": "Type u → Type",
  "name": "ReprAtom",
  "kind": "inductive",
  "doc_string":
  "Auxiliary class for marking types that should be considered atomic by `Repr` methods.\nWe use it at `Repr (List α)` to decide whether `bracketFill` should be used or not. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α},\n  a < b + c → a - c < b",
  "name": "sub_right_lt_of_lt_add",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `sub_lt_iff_lt_add`.",
  "args": ""},
 {"type":
  "{γ : Type u_1} →\n  {q p : Prop} →\n    [inst : Repr γ] →\n      String → γ → (q → p) → SlimCheck.TestResult p → optParam (Unit ⊕' (p → q)) (PSum.inl ()) → SlimCheck.TestResult q",
  "name": "SlimCheck.TestResult.addVarInfo",
  "kind": "def",
  "doc_string":
  "Add some formatting to the information recorded by `addInfo`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddSemigroup R] {a b : R},\n  IsAddRegular (a + b) → IsAddRegular (b + a) → IsAddRegular a ∧ IsAddRegular b",
  "name": "IsAddRegular.and_of_add_of_add",
  "kind": "theorem",
  "doc_string":
  "The \"most used\" implication of `add_and_add_iff`, with split\nhypotheses, instead of `∧`.",
  "args": ""},
 {"type":
  "{M₂ : Type u_1} →\n  {M₁ : Type u_2} →\n    [inst : Zero M₁] →\n      [inst_1 : One M₁] →\n        [inst_2 : Add M₁] →\n          [inst_3 : SMul ℕ M₁] →\n            [inst_4 : NatCast M₁] →\n              [inst_5 : AddMonoidWithOne M₂] →\n                (f : M₁ → M₂) →\n                  Function.Injective f →\n                    f 0 = 0 →\n                      f 1 = 1 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) → (∀ (n : ℕ), f ↑n = ↑n) → AddMonoidWithOne M₁",
  "name": "Function.Injective.addMonoidWithOne",
  "kind": "def",
  "doc_string":
  "A type endowed with `0`, `1` and `+` is an additive monoid with one,\nif it admits an injective map that preserves `0`, `1` and `+` to an additive monoid with one.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "ZNum → Option Num",
  "name": "Num.ofZNum'",
  "kind": "def",
  "doc_string":
  "Converts a `ZNum` to an `Option Num`, where `ofZNum' p = none` if `p < 0`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Ring α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Neg β] →\n                [inst_6 : Sub β] →\n                  [inst_7 : SMul ℕ β] →\n                    [inst_8 : SMul ℤ β] →\n                      [inst_9 : Pow β ℕ] →\n                        [inst_10 : NatCast β] →\n                          [inst_11 : IntCast β] →\n                            (f : α → β) →\n                              Function.Surjective f →\n                                f 0 = 0 →\n                                  f 1 = 1 →\n                                    (∀ (x y : α), f (x + y) = f x + f y) →\n                                      (∀ (x y : α), f (x * y) = f x * f y) →\n                                        (∀ (x : α), f (-x) = -f x) →\n                                          (∀ (x y : α), f (x - y) = f x - f y) →\n                                            (∀ (x : α) (n : ℕ), f (n • x) = n • f x) →\n                                              (∀ (x : α) (n : ℤ), f (n • x) = n • f x) →\n                                                (∀ (x : α) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                  (∀ (n : ℕ), f ↑n = ↑n) → (∀ (n : ℤ), f ↑n = ↑n) → Ring β",
  "name": "Function.Surjective.ring",
  "kind": "def",
  "doc_string":
  "Pushforward a `Ring` instance along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.clear!",
  "kind": "def",
  "doc_string":
  "A variant of `clear` which clears not only the given hypotheses but also any other hypotheses\ndepending on them ",
  "args": ""},
 {"type": "(α : Type u_1) → (β : Type u_2) → [inst : Mul β] → β →ₙ* α → β",
  "name": "Pi.constMulHom",
  "kind": "def",
  "doc_string": "`Function.const` as a `MulHom`. ",
  "args": ""},
 {"type": "TwoPointing Prop",
  "name": "TwoPointing.prop",
  "kind": "def",
  "doc_string": "The `False`, `True` two-pointing of `Prop`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "name": "CanonicallyOrderedCommSemiring.natCast_succ",
  "kind": "def",
  "doc_string": "The canonical map `ℕ → R` is a homomorphism. ",
  "args": ""},
 {"type": "{α : Type u_1} → WithTop α ≃ WithBot αᵒᵈ",
  "name": "WithTop.toDual",
  "kind": "def",
  "doc_string":
  "`WithTop.toDual` is the equivalence sending `⊤` to `⊥` and any `a : α` to `toDual a : αᵒᵈ`.\nSee `WithTop.toDualBotEquiv` for the related order-iso.\n",
  "args": ""},
 {"type": "∀ {α : Sort u} (a : α), HEq a a",
  "name": "HEq.refl",
  "kind": "def",
  "doc_string": "Reflexivity of heterogeneous equality. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] → {F : Type u_3} → [mc : AddMonoidHomClass F M N] → F → AddSubmonoid M",
  "name": "AddMonoidHom.mker",
  "kind": "def",
  "doc_string":
  "The additive kernel of an `AddMonoid` hom is the `AddSubmonoid` of\nelements such that `f x = 0`",
  "args": ""},
 {"type": "∀ {α : Type u} {s : Set α}, Set.Nontrivial s → ¬Set.Subsingleton s",
  "name": "Set.Nontrivial.not_subsingleton",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Set.not_subsingleton_iff`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLinearOrder α] {s : Set α} {b : α},\n  Set.Nonempty s → b < supₛ s → ∃ a, a ∈ s ∧ b < a",
  "name": "exists_lt_of_lt_csupₛ",
  "kind": "theorem",
  "doc_string":
  "When `b < supₛ s`, there is an element `a` in `s` with `b < a`, if `s` is nonempty and the order\nis a linear order. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "List.«term_<+:__1»",
  "kind": "def",
  "doc_string": "Notation for `List.isPrefix`\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Mul M] (S : Subsemigroup M), Subsemigroup.closure ↑S = S",
  "name": "Subsemigroup.closure_eq",
  "kind": "theorem",
  "doc_string": "Closure of a subsemigroup `S` equals `S`. ",
  "args": ""},
 {"type": "Type",
  "name": "Empty",
  "kind": "inductive",
  "doc_string":
  "The empty type. It has no constructors. The `Empty.rec`\neliminator expresses the fact that anything follows from the empty type.\n",
  "args": ""},
 {"type":
  "{q p : Prop} → [inst : Decidable q] → {α : Sort u} → p ∨ q → (p → α) → (q → α) → α",
  "name": "Or.by_cases'",
  "kind": "def",
  "doc_string":
  "Construct a non-Prop by cases on an `Or`, when the right conjunct is decidable. ",
  "args": ""},
 {"type": "Linarith.LinarithConfig → Bool → Linarith.LinarithConfig",
  "name": "Linarith.LinarithConfig.updateReducibility",
  "kind": "def",
  "doc_string":
  "`cfg.updateReducibility reduce_default` will change the transparency setting of `cfg` to\n`default` if `reduce_default` is true. In this case, it also sets the discharger to `ring!`,\nsince this is typically needed when using stronger unification.\n",
  "args": ""},
 {"type": "{α : Type u} → [inst : Mul α] → [inst : One α] → α → Type u",
  "name": "Invertible",
  "kind": "inductive",
  "doc_string":
  "`Invertible a` gives a two-sided multiplicative inverse of `a`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_\\/_»",
  "kind": "def",
  "doc_string":
  "`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), a ∈ s → a ≤ supₛ s",
  "name": "CompleteSemilatticeSup.le_supₛ",
  "kind": "def",
  "doc_string": "Any element of a set is less than the set supremum. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Sort u_3} → (α → γ) → (β → γ) → α ⊕ β → γ",
  "name": "Sum.elim",
  "kind": "def",
  "doc_string":
  "Define a function on `α ⊕ β` by giving separate definitions on `α` and `β`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {a b : α}, a < 0 → b < 0 → (1 / a ≤ 1 / b ↔ b ≤ a)",
  "name": "one_div_le_one_div_of_neg",
  "kind": "theorem",
  "doc_string":
  "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_neg_of_lt` and\n`lt_of_one_div_lt_one_div` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ≃r s → s ≃r r",
  "name": "RelIso.symm",
  "kind": "def",
  "doc_string":
  "Inverse map of a relation isomorphism is a relation isomorphism. ",
  "args": ""},
 {"type": "ℚ → ℚ → ℚ",
  "name": "Rat.mul",
  "kind": "def",
  "doc_string": "Multiplication of rational numbers. ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsTrichotomous",
  "kind": "inductive",
  "doc_string":
  "`IsTrichotomous X lt` means that the binary relation `lt` on `X` is trichotomous, that is,\neither `lt a b` or `a = b` or `lt b a` for any `a` and `b`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«tacticOn_goal-_=>_»",
  "kind": "def",
  "doc_string":
  "`on_goal n => tacSeq` creates a block scope for the `n`-th goal and tries the sequence\nof tactics `tacSeq` on it.\n\n`on_goal -n => tacSeq` does the same, but the `n`-th goal is chosen by counting from the\nbottom.\n\nThe goal is not required to be solved and any resulting subgoals are inserted back into the\nlist of goals, replacing the chosen goal.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → (R : α → α → Prop) → [inst : DecidableRel R] → List α → List α",
  "name": "List.pwFilter",
  "kind": "def",
  "doc_string":
  "`pwFilter R l` is a maximal sublist of `l` which is `Pairwise R`.\n`pwFilter (·≠·)` is the erase duplicates function (cf. `eraseDup`), and `pwFilter (·<·)` finds\na maximal increasing subsequence in `l`. For example,\n```\npwFilter (·<·) [0, 1, 5, 2, 6, 3, 4] = [0, 1, 2, 3, 4]\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {a b : α}, 0 < a → 0 < b → (1 / a ≤ 1 / b ↔ b ≤ a)",
  "name": "one_div_le_one_div",
  "kind": "theorem",
  "doc_string":
  "For the single implications with fewer assumptions, see `one_div_le_one_div_of_le` and\n`le_of_one_div_le_one_div` ",
  "args": ""},
 {"type": "{α : Type u} → Stream' α → Stream' α",
  "name": "Stream'.odd",
  "kind": "def",
  "doc_string": "Elements of a stream with odd indices. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "NonUnitalSemiring",
  "kind": "inductive",
  "doc_string": "An associative but not-necessarily unital semiring. ",
  "args": ""},
 {"type":
  "(Type u → Type v) → (Type u → Type w) → Type (max (max (u + 1) v) w)",
  "name": "MonadFunctor",
  "kind": "inductive",
  "doc_string":
  "A functor in the category of monads. Can be used to lift monad-transforming functions.\nBased on [`MFunctor`] from the `pipes` Haskell package, but not restricted to\nmonad transformers. Alternatively, an implementation of [`MonadTransFunctor`].\n\n  [`MFunctor`]: https://hackage.haskell.org/package/pipes-2.4.0/docs/Control-MFunctor.html\n  [`MonadTransFunctor`]: http://duairc.netsoc.ie/layers-docs/Control-Monad-Layer.html#t:MonadTransFunctor\n",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} → {α : Type u_3} → [inst : Monad m] → (α → α → m PUnit) → List α → m PUnit",
  "name": "List.forDiagM",
  "kind": "def",
  "doc_string":
  "`forDiagM f l` calls `f` on all elements in the upper triangular part of `l × l`.\nThat is, for each `e ∈ l`, it will run `f e e` and then `f e e'`\nfor each `e'` that appears after `e` in `l`.\n```\nforDiagM f [1, 2, 3] = do f 1 1; f 1 2; f 1 3; f 2 2; f 2 3; f 3 3\n```\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → (f : M →ₙ* N) → (∀ (x y : M), Commute (↑f x) (↑f y)) → M →ₙ* Nᵐᵒᵖ",
  "name": "MulHom.toOpposite",
  "kind": "def",
  "doc_string":
  "A semigroup homomorphism `f : M →ₙ* N` such that `f x` commutes with `f y` for all `x, y`\ndefines a semigroup homomorphism to `Nᵐᵒᵖ`. ",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HShiftLeft",
  "kind": "inductive",
  "doc_string":
  "The typeclass behind the notation `a <<< b : γ` where `a : α`, `b : β`. ",
  "args": ""},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "name": "Monad",
  "kind": "inductive",
  "doc_string":
  "A [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) is a\nstructure which abstracts the concept of sequential control flow.\nIt mainly consists of two operations:\n\n* `pure : α → F α`\n* `bind : F α → (α → F β) → F β` (written as `>>=`)\n\nLike many functional programming languages, Lean makes extensive use of monads\nfor structuring programs. In particular, the `do` notation is a very powerful\nsyntax over monad operations, and it depends on a `Monad` instance.\n\nSee [the `do` notation](https://leanprover.github.io/lean4/doc/do.html)\nchapter of the manual for details.\n",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β → β) → β → List α → List β",
  "name": "List.scanr",
  "kind": "def",
  "doc_string":
  "Fold a function `f` over the list from the right, returning the list of partial results.\n```\nscanr (+) 0 [1, 2, 3] = [6, 5, 3, 0]\n```\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : BEq α] →\n    (α → Bool) → (s : Aesop.UnorderedArraySet α) → optParam ℕ 0 → optParam ℕ (Aesop.UnorderedArraySet.size s) → Bool",
  "name": "Aesop.UnorderedArraySet.any",
  "kind": "def",
  "doc_string": "O(n) ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  [inst : Ring R] →\n    [inst_1 : NoZeroDivisors R] →\n      {S : Submonoid R} →\n        (oreNum : R → { x // x ∈ S } → R) →\n          (oreDenom : R → { x // x ∈ S } → { x // x ∈ S }) →\n            (∀ (r : R) (s : { x // x ∈ S }), r * ↑(oreDenom r s) = ↑s * oreNum r s) → OreLocalization.OreSet S",
  "name": "OreLocalization.oreSetOfNoZeroDivisors",
  "kind": "def",
  "doc_string":
  "In rings without zero divisors, the first (cancellability) condition is always fulfilled,\nit suffices to give a proof for the Ore condition itself. ",
  "args": ""},
 {"type": "(V : Type u) → [inst : Quiver V] → Sort (max (u + 1) v)",
  "name": "Quiver.Total",
  "kind": "inductive",
  "doc_string": "`Total V` is the type of _all_ arrows of `V`. ",
  "args": ""},
 {"type":
  "{I : Type u} →\n  (f : I → Type v) → [inst : DecidableEq I] → [inst : (i : I) → MulOneClass (f i)] → (i : I) → f i →* (i : I) → f i",
  "name": "MonoidHom.single",
  "kind": "def",
  "doc_string":
  "The monoid homomorphism including a single monoid into a dependent family of additive monoids,\nas functions supported at a point.\n\nThis is the `MonoidHom` version of `Pi.mulSingle`. ",
  "args": ""},
 {"type": "{σ : Type u} → σ → DoResultBC σ",
  "name": "DoResultBC.break",
  "kind": "def",
  "doc_string":
  "`break s` means that `break` was called, meaning that we should exit\nfrom the containing loop ",
  "args": ""},
 {"type":
  "{M : Type uM} →\n  {N : Type uN} →\n    {P : Type uP} →\n      [inst : AddZeroClass M] → [inst_1 : AddCommMonoid N] → [inst_2 : AddCommMonoid P] → (N →+ P) →+ (M →+ N) →+ M →+ P",
  "name": "AddMonoidHom.compHom",
  "kind": "def",
  "doc_string":
  "Composition of additive monoid morphisms (`AddMonoidHom.comp`) as an additive\nmonoid morphism.\n\nNote that unlike `AddMonoidHom.comp_hom'` this requires commutativity of `N`.\n\nThis also exists in a `LinearMap` version, `LinearMap.llcomp`.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "attrTo_additive?!_",
  "kind": "def",
  "doc_string": "The `to_additive` attribute. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Lattice α] → [inst_1 : BoundedOrder α] → [inst : IsSimpleOrder α] → CompleteBooleanAlgebra α",
  "name": "IsSimpleOrder.completeBooleanAlgebra",
  "kind": "def",
  "doc_string": "A simple `BoundedOrder` is also a `CompleteBooleanAlgebra`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : One M] [inst_1 : One N] ⦃f g : OneHom M N⦄, ↑f = ↑g → f = g",
  "name": "OneHom.coe_inj",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.coe_injective` instead. ",
  "args": ""},
 {"type": "ProjectionRule → Bool",
  "name": "ProjectionRule.asPrefix",
  "kind": "def",
  "doc_string":
  "Either rule can optionally be followed by `as_prefix` to write the projection as prefix.\nThis is uncommon for hiding rules, but not completely useless, since if a user manually wants\nto generate such a projection, it will be written using a prefix. ",
  "args": ""},
 {"type": "∀ {M : Type u} [inst : AddMonoid M] (a : M), 2 • a = a + a",
  "name": "two_nsmul",
  "kind": "theorem",
  "doc_string": "",
  "args": ""},
 {"type":
  "Lean.Syntax →\n  List Lean.Name → Lean.Name → Lean.Expr → Lean.Expr → Lean.Expr → Array Lean.Expr → Simps.Config → Lean.MetaM Unit",
  "name": "simpsAddProjection",
  "kind": "def",
  "doc_string":
  "Add a lemma with `nm` stating that `lhs = rhs`. `type` is the type of both `lhs` and `rhs`,\n`args` is the list of local constants occurring, and `univs` is the list of universe variables. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : SupSet α] → {ι : Sort u_2} → (ι → α) → α",
  "name": "supᵢ",
  "kind": "def",
  "doc_string": "Indexed supremum ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {A : Type u_2} [inst : Monoid M] [inst_1 : AddMonoid A] [self : DistribMulAction M A] (a : M),\n  a • 0 = 0",
  "name": "DistribMulAction.smul_zero",
  "kind": "def",
  "doc_string": "Multiplying `0` by a scalar gives `0` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} →\n      [inst : MulOneClass M] → [inst_1 : MulOneClass N] → [inst_2 : CommMonoid P] → (M →* P) → (N →* P) → M × N →* P",
  "name": "MonoidHom.coprod",
  "kind": "def",
  "doc_string":
  "Coproduct of two `MonoidHom`s with the same codomain:\n`f.coprod g (p : M × N) = f p.1 * g p.2`. ",
  "args": ""},
 {"type": "{α : Type u_1} → ℕ → List α → α → List α × List α",
  "name": "List.splitAtD",
  "kind": "def",
  "doc_string":
  "Split a list at an index. Ensures the left list always has the specified length\nby right padding with the provided default element.\n```\nsplitAtD 2 [a, b, c] x = ([a, b], [c])\nsplitAtD 4 [a, b, c] x = ([a, b, c, x], [])\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Sort u_2} {s : Set α} {t : ι → Set α} (i : ι), s ⊆ t i → s ⊆ Set.unionᵢ fun i => t i",
  "name": "Set.subset_unionᵢ_of_subset",
  "kind": "theorem",
  "doc_string":
  "This rather trivial consequence of `subset_unionᵢ`is convenient with `apply`, and has `i`\nexplicit for this purpose. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} {α : Type u_3} [inst : SMul M α] [inst_1 : SMul N α] [self : SMulCommClass M N α]\n  (m : M) (n : N) (a : α), m • n • a = n • m • a",
  "name": "SMulCommClass.smul_comm",
  "kind": "def",
  "doc_string": "`•` is left commutative ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List (List α)",
  "name": "List.permutations",
  "kind": "def",
  "doc_string":
  "List of all permutations of `l`.\n\npermutations [1, 2, 3] =\n[[1, 2, 3], [2, 1, 3], [3, 2, 1],\n [2, 3, 1], [3, 1, 2], [1, 3, 2]] ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β},\n  (α →+* β) → ∀ [inst : Nontrivial β], Nontrivial α",
  "name": "RingHom.domain_nontrivial",
  "kind": "theorem",
  "doc_string":
  "If there is a homomorphism `f : α →+* β` and `β` is nontrivial, then `α` is nontrivial. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Mul M] →\n      [inst_1 : Mul N] →\n        (f : M →ₙ* N) → (N' : Subsemigroup N) → { x // x ∈ Subsemigroup.comap f N' } →ₙ* { x // x ∈ N' }",
  "name": "MulHom.subsemigroupComap",
  "kind": "def",
  "doc_string": "The `MulHom` from the preimage of a subsemigroup to itself. ",
  "args": ""},
 {"type": "Mathlib.Meta.NormNum.NormNumExt",
  "name": "Mathlib.Meta.NormNum.evalOne",
  "kind": "def",
  "doc_string":
  "The `norm_num` extension which identifies the expression `One.one`, returning `1`. ",
  "args": ""},
 {"type": "ByteSlice → ByteArray",
  "name": "ByteSlice.toArray",
  "kind": "def",
  "doc_string":
  "Convert a byte slice into an array, by copying the data if necessary. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a : α}, a⁻¹ < 1 ↔ 1 < a",
  "name": "Right.inv_lt_one_iff",
  "kind": "theorem",
  "doc_string": "Uses `right` co(ntra)variant. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] (self : ClosureOperator α) (x : α), x ≤ ↑self.toOrderHom x",
  "name": "ClosureOperator.le_closure'",
  "kind": "def",
  "doc_string": "An element is less than or equal its closure ",
  "args": ""},
 {"type":
  "∀ {v : Sat.Valuation} {a : Prop} {n : ℕ}, (v n ↔ a) → Sat.Literal.reify v (Sat.Literal.pos n) ¬a",
  "name": "Sat.Literal.reify_pos",
  "kind": "theorem",
  "doc_string": "The reification of a positive literal `¬⟦a⟧_v ≡ ¬a`. ",
  "args": ""},
 {"type":
  "{ε σ δ : Type u} →\n  [inst : EStateM.Backtrackable δ σ] → {α : Type u} → EStateM ε σ α → (ε → EStateM ε σ α) → EStateM ε σ α",
  "name": "EStateM.tryCatch",
  "kind": "def",
  "doc_string":
  "Implementation of `tryCatch` for `EStateM` where the state is `Backtrackable`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.casesType",
  "kind": "def",
  "doc_string":
  "* `cases_type I` applies the `cases` tactic to a hypothesis `h : (I ...)`\n* `cases_type I_1 ... I_n` applies the `cases` tactic to a hypothesis\n  `h : (I_1 ...)` or ... or `h : (I_n ...)`\n* `cases_type* I` is shorthand for `· repeat cases_type I`\n* `cases_type! I` only applies `cases` if the number of resulting subgoals is <= 1.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current goal.\n```\ncases_type* Or And\n```\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Mul R] {c : R}, IsRegular c → IsLeftRegular c",
  "name": "IsRegular.left",
  "kind": "def",
  "doc_string": "A regular element `c` is left-regular ",
  "args": ""},
 {"type":
  "(cont : Type u) → (idx : Type v) → outParam (Type w) → outParam (cont → idx → Prop) → Type (max (max u v) w)",
  "name": "GetElem",
  "kind": "inductive",
  "doc_string":
  "The class `GetElem cont idx elem dom` implements the `xs[i]` notation.\nWhen you write this, given `xs : cont` and `i : idx`, lean looks for an instance\nof `GetElem cont idx elem dom`. Here `elem` is the type of `xs[i]`, while\n`dom` is whatever proof side conditions are required to make this applicable.\nFor example, the instance for arrays looks like\n`GetElem (Array α) Nat α (fun xs i => i < xs.size)`.\n\nThe proof side-condition `dom xs i` is automatically dispatched by the\n`get_elem_tactic` tactic, which can be extended by adding more clauses to\n`get_elem_tactic_trivial`.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u} [self : Ring R] (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)",
  "name": "Ring.intCast_negSucc",
  "kind": "def",
  "doc_string":
  "The canonical homorphism `ℤ → R` for negative values is just the negation of the values\nof the canonical homomorphism `ℕ → R`. ",
  "args": ""},
 {"type": "(α : Type u_1) → (β : Type u_2) → (_ : α) × β ≃ α × β",
  "name": "Equiv.sigmaEquivProd",
  "kind": "def",
  "doc_string":
  "`Sigma` type with a constant fiber is equivalent to the product. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "precArg",
  "kind": "def",
  "doc_string": "Precedence used for application arguments (`do`, `by`, ...). ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {num : ℤ} {denom : ℕ} (self : Mathlib.Meta.NormNum.IsRat a num denom),\n  a = ↑num * ↑⅟denom",
  "name": "Mathlib.Meta.NormNum.IsRat.eq",
  "kind": "def",
  "doc_string":
  "The element is equal to the fraction with the specified numerator and denominator. ",
  "args": ""},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "name": "Functor",
  "kind": "inductive",
  "doc_string":
  "In functional programming, a \"functor\" is a function on types `F : Type u → Type v`\nequipped with an operator called `map` or `<$>` such that if `f : α → β` then\n`map f : F α → F β`, so `f <$> x : F β` if `x : F α`. This corresponds to the\ncategory-theory notion of [functor](https://en.wikipedia.org/wiki/Functor) in\nthe special case where the category is the category of types and functions\nbetween them, except that this class supplies only the operations and not the\nlaws (see `LawfulFunctor`).\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulZeroOneClass M] [inst_1 : MulZeroOneClass N] (self : M →*₀ N), ↑↑self 1 = 1",
  "name": "MonoidWithZeroHom.map_one'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves 1 ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [inst : Preorder α] {a : α}, Nonempty ↑(Set.Iic a)",
  "name": "Set.nonempty_Iic_subtype",
  "kind": "def",
  "doc_string": "An interval `Iic a` is nonempty. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a : α}, a⁻¹ < 1 ↔ 1 < a",
  "name": "inv_lt_one_iff_one_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.inv_lt_one_iff`.",
  "args": ""},
 {"type": "{α : Type u_1} → ℕ → ℕ → List α → List α",
  "name": "List.dropSliceTR",
  "kind": "def",
  "doc_string": "Optimized version of `dropSlice`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "SDiff",
  "kind": "inductive",
  "doc_string": "Notation type class for the set difference `\\`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → M ≃+ N → M →+ N",
  "name": "AddEquiv.toAddMonoidHom",
  "kind": "def",
  "doc_string":
  "Extract the forward direction of an additive equivalence\nas an addition-preserving function.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedAddCommMonoidWithTop α] (x : α), x ≤ ⊤",
  "name": "LinearOrderedAddCommMonoidWithTop.le_top",
  "kind": "def",
  "doc_string":
  "In a `LinearOrderedAddCommMonoidWithTop`, the `⊤` element is larger than any other element.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α},\n  (∀ (a' : α), a' ∈ l → R a a') → List.Pairwise R l → List.Pairwise R (a :: l)",
  "name": "List.Pairwise.cons",
  "kind": "def",
  "doc_string":
  "`a :: l` is `Pairwise R` if `a` `R`-relates to every element of `l`,\nand `l` is `Pairwise R`. ",
  "args": ""},
 {"type":
  "(p : Sort u_1) → (n : ℕ) → (a : ℤ) → Mathlib.Tactic.ModCases.OnModCases n a n p",
  "name": "Mathlib.Tactic.ModCases.onModCases_stop",
  "kind": "def",
  "doc_string":
  "The end point is that once we have reduced to `∃ z, n ≤ z < n ∧ a ≡ z (mod n)`\nthere are no more cases to consider.\n",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : AddMonoid M] → AddSubmonoid M",
  "name": "IsAddUnit.addSubmonoid",
  "kind": "def",
  "doc_string":
  "The additive submonoid consisting of the additive units of an additive monoid",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → (M →ₙ* N) → Subsemigroup N",
  "name": "MulHom.srange",
  "kind": "def",
  "doc_string":
  "The range of a semigroup homomorphism is a subsemigroup. See Note [range copy pattern]. ",
  "args": ""},
 {"type":
  "(f : Type u → Type v) → [inst : Functor f] → [inst : LawfulFunctor f] → {α β : Type u} → α ≃ β → f α ≃ f β",
  "name": "Functor.map_equiv",
  "kind": "def",
  "doc_string": "Apply a functor to an `Equiv`. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {M : Type u_2} {α : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MulAction G M]\n  [inst_3 : SMul M α] [inst_4 : SMul G α] [inst_5 : SMulCommClass G M M] [inst_6 : IsScalarTower G M M]\n  [inst_7 : IsScalarTower G M α], IsScalarTower G Mˣ α",
  "name": "Units.isScalarTower'_left",
  "kind": "def",
  "doc_string": "Transfer `IsScalarTower G M α` to `IsScalarTower G Mˣ α` ",
  "args": ""},
 {"type": "List Prop → Sat.Valuation",
  "name": "Sat.Valuation.mk",
  "kind": "def",
  "doc_string":
  "`Valuation.mk [a, b, c]` is a valuation which is `a` at 0, `b` at 1 and `c` at 2, and false\neverywhere else. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1],\n  StrictAntiOn f s → StrictAntiOn g s → StrictAntiOn (fun x => f x + g x) s",
  "name": "StrictAntiOn.add",
  "kind": "theorem",
  "doc_string":
  "The sum of two strictly antitone functions is strictly antitone.",
  "args": ""},
 {"type": "∀ {α : Type u} [self : NonAssocSemiring α], NatCast.natCast 0 = 0",
  "name": "NonAssocSemiring.natCast_zero",
  "kind": "def",
  "doc_string": "The canonical map `ℕ → R` sends `0 : ℕ` to `0 : R`. ",
  "args": ""},
 {"type":
  "∀ (M : Type u_2) {α : Type u_1} [inst : AddMonoid M] [inst_1 : AddAction M α] (a₁ a₂ : M),\n  (fun x x_1 => x +ᵥ x_1) a₁ ∘ (fun x x_1 => x +ᵥ x_1) a₂ = (fun x x_1 => x +ᵥ x_1) (a₁ + a₂)",
  "name": "comp_vadd_left",
  "kind": "theorem",
  "doc_string": "`VAdd` version of `comp_add_left`",
  "args": ""},
 {"type": "∀ (self : ℚ), self.den ≠ 0",
  "name": "Rat.den_nz",
  "kind": "def",
  "doc_string": "The denominator is nonzero. ",
  "args": ""},
 {"type": "{α : Type u} → (α → α → Prop) → Set α → Prop",
  "name": "Set.Unbounded",
  "kind": "def",
  "doc_string": "An unbounded or cofinal set. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {f g : β → α},\n  MonotoneOn f s → StrictMonoOn g s → StrictMonoOn (fun x => f x * g x) s",
  "name": "MonotoneOn.mul_strict_mono'",
  "kind": "theorem",
  "doc_string":
  "The product of a monotone function and a strictly monotone function is strictly monotone. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  (c : Lattice α) →\n    (le : α → α → Prop) →\n      le = LE.le → (sup : α → α → α) → sup = HasSup.sup → (inf : α → α → α) → inf = HasInf.inf → Lattice α",
  "name": "Lattice.copy",
  "kind": "def",
  "doc_string":
  "A function to create a provable equal copy of a lattice\nwith possibly different definitional equalities. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set α} [self : Set.OrdConnected s] ⦃x : α⦄,\n  x ∈ s → ∀ ⦃y : α⦄, y ∈ s → Set.Icc x y ⊆ s",
  "name": "Set.OrdConnected.out'",
  "kind": "def",
  "doc_string":
  "`s : Set α` is `OrdConnected` if for all `x y ∈ s` it includes the interval `[[x, y]]`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α",
  "name": "List.init",
  "kind": "def",
  "doc_string":
  "Initial segment of a list, i.e., with the last element dropped. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → Equiv.Perm α × Equiv.Perm β →* Equiv.Perm (α ⊕ β)",
  "name": "Equiv.Perm.sumCongrHom",
  "kind": "def",
  "doc_string":
  "`Equiv.Perm.sumCongr` as a `MonoidHom`, with its two arguments bundled into a single `prod`.\n\nThis is particularly useful for its `MonoidHom.range` projection, which is the subgroup of\npermutations which do not exchange elements between `α` and `β`. ",
  "args": ""},
 {"type":
  "(R : Type u_1) →\n  (S : Type u_2) → [inst : NonUnitalNonAssocSemiring R] → [inst_1 : NonUnitalNonAssocSemiring S] → R × S →ₙ+* S",
  "name": "NonUnitalRingHom.snd",
  "kind": "def",
  "doc_string":
  "Given non-unital semirings `R`, `S`, the natural projection homomorphism from `R × S` to `S`.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → [inst : PredOrder α] → α → α",
  "name": "Order.pred",
  "kind": "def",
  "doc_string":
  "The predecessor of an element. If `a` is not minimal, then `pred a` is the greatest element less\nthan `a`. If `a` is minimal, then `pred a = a`. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u₃} → [inst_2 : CategoryTheory.Category E] → {G H : C ⥤ D} → (G ⟶ H) → (F : D ⥤ E) → G ⋙ F ⟶ H ⋙ F",
  "name": "CategoryTheory.whiskerRight",
  "kind": "def",
  "doc_string":
  "If `α : G ⟶ H` then\n`whisker_right α F : (G ⋙ F) ⟶ (G ⋙ F)` has components `F.map (α.app X)`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, 0 < a → 0 < b → 0 < a + b",
  "name": "add_pos",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.add_pos`.",
  "args": ""},
 {"type": "∀ {a b : Prop}, a ∧ b → a",
  "name": "And.left",
  "kind": "def",
  "doc_string":
  "Extract the left conjunct from a conjunction. `h : a ∧ b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. ",
  "args": ""},
 {"type": "Lean.Syntax → Lean.Elab.Command.CommandElabM ProjectionRule",
  "name": "elabSimpsRule",
  "kind": "def",
  "doc_string":
  "Parse a rule for `initialize_simps_projections`. It is either `<name>→<name>` or `-<name>`,\npossibly following by `as_prefix`.",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → {r : α → α → Prop} → Quot r → (f : α → β) → (∀ (a b : α), r a b → f a = f b) → β",
  "name": "Quot.liftOn",
  "kind": "def",
  "doc_string":
  "`Quot.liftOn q f h` is the same as `Quot.lift f h q`. It just reorders\nthe argument `q : Quot r` to be first.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (f : α → β) → (g : β → α) → Function.RightInverse g f → Quotient (Setoid.ker f) ≃ β",
  "name": "Setoid.quotientKerEquivOfRightInverse",
  "kind": "def",
  "doc_string":
  "If `f` has a computable right-inverse, then the quotient by its kernel is equivalent to its\ndomain. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β' γ' : Type v} →\n    {m' : Type v → Type w} → [inst : Monad m'] → (α → β' → m' (β' × γ')) → β' → List α → m' (β' × List γ')",
  "name": "List.mapAccumRM",
  "kind": "def",
  "doc_string":
  "Takes a value `β` and `List α` and accumulates pairs according to a monadic function `f`.\nAccumulation occurs from the right (i.e., starting from the tail of the list). ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : Neg M₁] →\n            [inst_4 : Sub M₁] →\n              [inst_5 : SMul ℤ M₁] →\n                [inst_6 : SubNegMonoid M₂] →\n                  (f : M₁ → M₂) →\n                    Function.Injective f →\n                      f 0 = 0 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁), f (-x) = -f x) →\n                            (∀ (x y : M₁), f (x - y) = f x - f y) →\n                              (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) → SubNegMonoid M₁",
  "name": "Function.Injective.subNegMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `0`, `+`, unary `-`, and binary `-` is a\n`SubNegMonoid` if it admits an injective map that preserves `0`, `+`, unary `-`, and binary `-` to\na `SubNegMonoid`. This version takes custom `nsmul` and `zsmul` as `[SMul ℕ M₁]` and `[SMul ℤ M₁]`\narguments.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Semigroup",
  "kind": "inductive",
  "doc_string": "A semigroup is a type with an associative `(*)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : LinearOrder β] {f g : α → β} {s : Set α},\n  MonotoneOn f s → MonotoneOn g s → MonotoneOn (fun x => max (f x) (g x)) s",
  "name": "MonotoneOn.max",
  "kind": "theorem",
  "doc_string":
  "Pointwise maximum of two monotone functions is a monotone function. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "SlimCheck.Gen",
  "kind": "def",
  "doc_string":
  "Monad to generate random examples to test properties with.\nIt has a `Nat` parameter so that the caller can decide on the\nsize of the examples. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "PosPart",
  "kind": "inductive",
  "doc_string":
  "The positive part of an element admiting a decomposition into positive and negative parts.\n",
  "args": ""},
 {"type": "LinearOrder Char",
  "name": "instLinearOrderChar",
  "kind": "def",
  "doc_string":
  "Provides a `LinearOrder` instance on `Char`. `Char` is the type of Unicode scalar values.\n",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {F : C → D}\n  [self : CategoryTheory.Functorial F] (X : C), CategoryTheory.Functorial.map' (𝟙 X) = 𝟙 (F X)",
  "name": "CategoryTheory.Functorial.map_id'",
  "kind": "def",
  "doc_string": "A functorial map preserves identities. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β} {f : α → β}, f '' s ⊆ t ↔ s ⊆ f ⁻¹' t",
  "name": "Set.image_subset_iff",
  "kind": "theorem",
  "doc_string": "image and preimage are a Galois connection ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a : α} {s t p : Set α}, IsGLB s a → IsGLB p a → s ⊆ t → t ⊆ p → IsGLB t a",
  "name": "IsGLB.of_subset_of_superset",
  "kind": "theorem",
  "doc_string":
  "If `a` is a greatest lower bound for sets `s` and `p`, then it is a greater lower bound for any\nset `t`, `s ⊆ t ⊆ p`. ",
  "args": ""},
 {"type": "SlimCheck.Gen ℕ",
  "name": "SlimCheck.Gen.getSize",
  "kind": "def",
  "doc_string": "Get access to the size parameter of the `Gen` monad. ",
  "args": ""},
 {"type": "∀ {α : Sort u} {a b c : α}, a ≠ b → b = c → a ≠ c",
  "name": "Ne.trans_eq",
  "kind": "theorem",
  "doc_string": "**Alias** of `ne_of_ne_of_eq`.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] →\n        {F : Type u_3} →\n          [mc : MonoidHomClass F M N] →\n            {f : F} → Function.Injective ↑f → GaloisCoinsertion (Submonoid.map f) (Submonoid.comap f)",
  "name": "Submonoid.gciMapComap",
  "kind": "def",
  "doc_string":
  "`map f` and `comap f` form a `GaloisCoinsertion` when `f` is injective. ",
  "args": ""},
 {"type": "ℕ → Array ℤ → Array ℤ → Mathlib.Tactic.Sat.LRATStep",
  "name": "Mathlib.Tactic.Sat.LRATStep.add",
  "kind": "def",
  "doc_string":
  "An addition step, with the clause ID, the clause literal list, and the proof trace ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  StrictAntiOn f s → StrictMonoOn (↑OrderDual.toDual ∘ f) s",
  "name": "StrictAntiOn.dual_right",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `strictMonoOn_toDual_comp_iff`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a b c : α), a * (b + c) = a * b + a * c",
  "name": "NonUnitalNonAssocRing.left_distrib",
  "kind": "def",
  "doc_string": "Multiplication is left distributive over addition ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Mul α] → [inst : One α] → List α → α",
  "name": "List.prod",
  "kind": "def",
  "doc_string": "Product of a list.\n\n`prod [a, b, c] = ((1 * a) * b) * c` ",
  "args": ""},
 {"type":
  "Lean.MVarId →\n  Bool →\n    Option Lean.Expr →\n      Lean.TSyntax `Lean.binderIdent → Lean.Elab.TermElabM (Mathlib.Tactic.Choose.ElimStatus × Lean.MVarId)",
  "name": "Mathlib.Tactic.Choose.choose1WithInfo",
  "kind": "def",
  "doc_string":
  "A wrapper around `choose1` that parses identifiers and adds variable info to new variables. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α},\n  a < c - b → a + b < c",
  "name": "add_lt_of_lt_sub_right",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `lt_sub_iff_add_lt`.",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → {x : MulOneClass M} → {x_1 : MulOneClass N} → Coe (M →* N) (M →ₙ* N)",
  "name": "MonoidHom.coeToMulHom",
  "kind": "def",
  "doc_string":
  "`MonoidHom` down-cast to a `MulHom`, forgetting the 1-preserving property. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r : α → α → Prop}, Reflexive r → ∀ {x y : α}, x ≠ y → r x y ↔ r x y",
  "name": "Reflexive.ne_imp_iff",
  "kind": "theorem",
  "doc_string":
  "If a reflexive relation `r : α → α → Prop` holds over `x y : α`,\nthen it holds whether or not `x ≠ y`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] → {F : Type u_3} → [mc : MonoidHomClass F M N] → F → Submonoid N → Submonoid M",
  "name": "Submonoid.comap",
  "kind": "def",
  "doc_string":
  "The preimage of a submonoid along a monoid homomorphism is a submonoid. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] {a b : α} {o : Ordering},\n  Ordering.Compares o b a → Ordering.Compares (Ordering.swap o) a b",
  "name": "Ordering.Compares.swap",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Ordering.compares_swap`.",
  "args": ""},
 {"type": "outParam (Type u) → Type v → Type (max (u + 1) (v + 1))",
  "name": "HasQuotient",
  "kind": "inductive",
  "doc_string":
  "`HasQuotient A B` is a notation typeclass that allows us to write `A ⧸ b` for `b : B`.\nThis allows the usual notation for quotients of algebraic structures,\nsuch as groups, modules and rings.\n\n`A` is a parameter, despite being unused in the definition below, so it appears in the notation.\n",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Rel α β",
  "name": "Function.graph",
  "kind": "def",
  "doc_string": "The graph of a function as a relation. ",
  "args": ""},
 {"type":
  "{p : ℕ+ → Prop} → [inst : DecidablePred p] → (∃ n, p n) → { n // p n ∧ ∀ (m : ℕ+), m < n → ¬p m }",
  "name": "PNat.findX",
  "kind": "def",
  "doc_string": "The `PNat` version of `Nat.findX` ",
  "args": ""},
 {"type": "Linarith.Comp → Bool",
  "name": "Linarith.Comp.isContr",
  "kind": "def",
  "doc_string":
  "A `Comp` represents a contradiction if its expression has no coefficients and its strength is <,\nthat is, it represents the fact `0 < 0`.\n ",
  "args": ""},
 {"type": "Simps.Config → Lean.Meta.TransparencyMode",
  "name": "Simps.Config.rhsMd",
  "kind": "def",
  "doc_string":
  "TransparencyMode used to reduce the right-hand side in order to detect whether it is a\nconstructor. Note: was `none` in Lean 3 ",
  "args": ""},
 {"type": "Num → ZNum",
  "name": "Num.toZNum",
  "kind": "def",
  "doc_string": "Converts a `Num` to a `ZNum`. ",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] (a : G₀), a / (a / a) = a",
  "name": "div_div_self",
  "kind": "theorem",
  "doc_string":
  "Dividing `a` by the result of dividing `a` by itself results in\n`a` (whether or not `a` is zero). ",
  "args": ""},
 {"type": "Lean.Expr → Lean.Meta.SimpM Lean.Meta.Simp.Step",
  "name": "Mathlib.Tactic.PushNeg.transformNegation",
  "kind": "opaque",
  "doc_string":
  "Recursively push negations at the top level of the current expression. This is needed\nto handle e.g. triple negation. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] {a : α}, Order.IsPredLimit a → Order.IsSuccLimit (↑OrderDual.toDual a)",
  "name": "Order.isPredLimit.dual",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Order.isSuccLimit_toDual_iff`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s t : Set α},\n  Set.Nonempty s →\n    Set.Nonempty t → (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ t → x ≤ y) → Set.Nonempty (upperBounds s ∩ lowerBounds t)",
  "name": "exists_between_of_forall_le",
  "kind": "theorem",
  "doc_string":
  "If all elements of a nonempty set `s` are less than or equal to all elements\nof a nonempty set `t`, then there exists an element between these sets. ",
  "args": ""},
 {"type": "{a : Prop} → {b : Sort v} → a → ¬a → b",
  "name": "absurd",
  "kind": "def",
  "doc_string":
  "Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : ¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
  "args": ""},
 {"type": "{g : Type} → [inst : RandomGen g] → RandG g ℕ",
  "name": "Rand.next",
  "kind": "def",
  "doc_string": "Generate one more `Nat` ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → ℕ → ℕ",
  "name": "List.findIdx.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `findIdx`: `findIdx.go p l n = findIdx p l + n` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → Option β → γ) → List α → List β → List γ",
  "name": "List.map₂Left",
  "kind": "def",
  "doc_string":
  "Left-biased version of `List.map₂`. `map₂Left f as bs` applies `f` to each pair\n`aᵢ ∈ as` and `bᵢ ‌∈ bs`. If `bs` is shorter than `as`, `f` is applied to `none`\nfor the remaining `aᵢ`.\n\n```\nmap₂Left Prod.mk [1, 2] ['a'] = [(1, some 'a'), (2, none)]\n\nmap₂Left Prod.mk [1] ['a', 'b'] = [(1, some 'a')]\n\nmap₂Left f as bs = (map₂Left' f as bs).fst\n```\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.MkIff.mkIffOfInductiveProp",
  "kind": "def",
  "doc_string":
  "`mk_iff_of_inductive_prop i r` makes an `iff` rule for the inductively-defined proposition `i`.\nThe new rule `r` has the shape `∀ps is, i as ↔ ⋁_j, ∃cs, is = cs`, where `ps` are the type\nparameters, `is` are the indices, `j` ranges over all possible constructors, the `cs` are the\nparameters for each of the constructors, and the equalities `is = cs` are the instantiations for\neach constructor for each of the indices to the inductive type `i`.\n\nIn each case, we remove constructor parameters (i.e. `cs`) when the corresponding equality would\nbe just `c = i` for some index `i`.\n\nFor example, `mk_iff_of_inductive_prop` on `List.Chain` produces:\n\n```lean\n∀ { α : Type _} (R : α → α → Prop) (a : α) (l : List α),\n  Chain R a l ↔ l = [] ∨ ∃(b : α) (l' : List α), R a b ∧ Chain R b l ∧ l = b :: l'\n```\n\nSee also the `mk_iff` user attribute.\n",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsTrans",
  "kind": "inductive",
  "doc_string":
  "`IsTrans X r` means the binary relation `r` on `X` is transitive. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] (a : α), 0 * a = 0",
  "name": "CanonicallyOrderedCommSemiring.zero_mul",
  "kind": "def",
  "doc_string": "Zero is a left absorbing element for multiplication ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α},\n  BddBelow s → Set.Nonempty s → infₛ (insert a s) = a ⊓ infₛ s",
  "name": "cinfₛ_insert",
  "kind": "theorem",
  "doc_string":
  "The infimum of `insert a s` is the minimum of `a` and the infimum of `s`, if `s` is\nnonempty and bounded below.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Add M] →\n      [inst_1 : Add N] →\n        (f : AddHom M N) → (g : AddHom N M) → AddHom.comp g f = AddHom.id M → AddHom.comp f g = AddHom.id N → M ≃+ N",
  "name": "AddHom.toAddEquiv",
  "kind": "def",
  "doc_string":
  "Given a pair of additive homomorphisms `f`, `g` such that `g.comp f = id` and\n`f.comp g = id`, returns an additive equivalence with `toFun = f` and `invFun = g`. This\nconstructor is useful if the underlying type(s) have specialized `ext` lemmas for additive\nhomomorphisms.",
  "args": ""},
 {"type":
  "∀ {R : Type u} [self : EuclideanDomain R] (a b : R),\n  b * EuclideanDomain.quotient a b + EuclideanDomain.remainder a b = a",
  "name": "EuclideanDomain.quotient_mul_add_remainder_eq",
  "kind": "def",
  "doc_string":
  "The property that links the quotient and remainder functions.\nThis allows us to compute GCDs and LCMs. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] [self : NoMaxOrder α] (a : α), ∃ b, a < b",
  "name": "NoMaxOrder.exists_gt",
  "kind": "def",
  "doc_string": "For each term `a`, there is some strictly greater `b`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {γ : Type u_2} → {β : Type u_3} → {f : α → γ} → {g : β → γ} → ((c : γ) → { a // f a = c } ≃ { b // g b = c }) → α ≃ β",
  "name": "Equiv.ofFiberEquiv",
  "kind": "def",
  "doc_string":
  "A family of equivalences between fibers gives an equivalence between domains. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → α → Prop) → (β → β → Prop) → (α → β) → Prop",
  "name": "Relation.Fibration",
  "kind": "def",
  "doc_string":
  "A function `f : α → β` is a fibration between the relation `rα` and `rβ` if for all\n`a : α` and `b : β`, whenever `b : β` and `f a` are related by `rβ`, `b` is the image\nof some `a' : α` under `f`, and `a'` and `a` are related by `rα`. ",
  "args": ""},
 {"type":
  "Type u_1 → outParam (Type u_2) → outParam (Type u_3) → Type (max (max u_1 u_2) u_3)",
  "name": "Function.HasUncurry",
  "kind": "inductive",
  "doc_string":
  "Records a way to turn an element of `α` into a function from `β` to `γ`. The most generic use\nis to recursively uncurry. For instance `f : α → β → γ → δ` will be turned into\n`↿f : α × β × γ → δ`. One can also add instances for bundled maps. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "HeytingAlgebra",
  "kind": "inductive",
  "doc_string":
  "A Heyting algebra is a bounded lattice with an additional binary operation `⇨` called Heyting\nimplication such that `a ⇨` is right adjoint to `a ⊓`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  [inst : Monoid R] →\n    {S : Submonoid R} →\n      [inst_1 : OreLocalization.OreSet S] →\n        (r : R) → (s : { x // x ∈ S }) → (r' : R) ×' (s' : { x // x ∈ S }) ×' r * ↑s' = ↑s * r'",
  "name": "OreLocalization.oreCondition",
  "kind": "def",
  "doc_string":
  "The Ore condition bundled in a sigma type. This is useful in situations where we want to obtain\nboth witnesses and the condition for a given fraction. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_/ₚ_»",
  "kind": "def",
  "doc_string":
  "Partial division. It is defined when the\nsecond argument is invertible, and unlike the division operator\nin `DivisionRing` it is not totalized at zero. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.RingNF.tacticRing!",
  "kind": "def",
  "doc_string":
  "Tactic for evaluating expressions in *commutative* (semi)rings, allowing for variables in the\nexponent.\n\n* `ring!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `ring1` fails if the target is not an equality.\n\nFor example:\n```\nexample (n : ℕ) (m : ℤ) : 2^(n+1) * m = 2 * 2^n * m := by ring\nexample (a b : ℤ) (n : ℕ) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring\nexample (x y : ℕ) : x + id y = y + id x := by ring!\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : NonAssocSemiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "name": "NonAssocSemiring.natCast_succ",
  "kind": "def",
  "doc_string": "The canonical map `ℕ → R` is a homomorphism. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : ConditionallyCompleteLattice α] (s : Set α) (a : α), BddAbove s → a ∈ s → a ≤ supₛ s",
  "name": "ConditionallyCompleteLattice.le_csupₛ",
  "kind": "def",
  "doc_string": "`a ≤ supₛ s` for all `a ∈ s`. ",
  "args": ""},
 {"type": "{α : Type u_1} → α ≃ αᵃᵒᵖ",
  "name": "AddOpposite.opEquiv",
  "kind": "def",
  "doc_string": "The canonical bijection between `α` and `αᵃᵒᵖ`.",
  "args": ""},
 {"type": "{α : Type u_1} → List (Option α) → List α",
  "name": "List.reduceOption",
  "kind": "def",
  "doc_string":
  "Drop `none`s from a list, and replace each remaining `some a` with `a`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Quotient.«term⟦_⟧»",
  "kind": "def",
  "doc_string": "The canonical quotient map into a `Quotient`. ",
  "args": ""},
 {"type": "{α : Type u} → [self : ShiftLeft α] → α → α → α",
  "name": "ShiftLeft.shiftLeft",
  "kind": "def",
  "doc_string": "The implementation of `a <<< b : α`. See `HShiftLeft`. ",
  "args": ""},
 {"type":
  "∀ {P : ℤ → Prop} [inst : DecidablePred P],\n  (∃ b, ∀ (z : ℤ), P z → b ≤ z) → (∃ z, P z) → ∃ lb, P lb ∧ ∀ (z : ℤ), P z → lb ≤ z",
  "name": "Int.exists_least_of_bdd",
  "kind": "theorem",
  "doc_string":
  "If `P : ℤ → Prop` is a predicate such that the set `{m : P m}` is bounded below and nonempty,\nthen this set has the least element. This lemma uses classical logic to avoid assumption\n`[DecidablePred P]`. See `Int.leastOfBdd` for a constructive counterpart. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → {r : α → α → Prop} → {s : β → β → Prop} → {t : γ → γ → Prop} → r ≃r s → s ≃r t → r ≃r t",
  "name": "RelIso.trans",
  "kind": "def",
  "doc_string":
  "Composition of two relation isomorphisms is a relation isomorphism. ",
  "args": ""},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (β → α) → (α → β) → Prop",
  "name": "Function.RightInverse",
  "kind": "def",
  "doc_string":
  "`RightInverse g f` means that g is a right inverse to f. That is, `f ∘ g = id`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Min α] → List α → Option α",
  "name": "List.minimum?",
  "kind": "def",
  "doc_string":
  "Returns the smallest element of the list, if it is not empty.\n* `[].maximum? = none`\n* `[4].maximum? = some 4`\n* `[1, 4, 2, 10, 6].maximum? = some 1`\n",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → [inst : SuccOrder α] → α → α",
  "name": "Order.succ",
  "kind": "def",
  "doc_string":
  "The successor of an element. If `a` is not maximal, then `succ a` is the least element greater\nthan `a`. If `a` is maximal, then `succ a = a`. ",
  "args": ""},
 {"type": "Lean.MVarId → Mathlib.Tactic.Ring.RingM Unit",
  "name": "Mathlib.Tactic.Ring.proveEq",
  "kind": "def",
  "doc_string":
  "Frontend of `ring1`: attempt to close a goal `g`, assuming it is an equation of semirings. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → (f : α → β) → Function.Bijective f → α ≃ β",
  "name": "Equiv.ofBijective",
  "kind": "def",
  "doc_string":
  "If `f` is a bijective function, then its domain is equivalent to its codomain. ",
  "args": ""},
 {"type":
  "{α : Type u₁} → {β : Type u₂} → {φ : Type u₃} → (α → β → φ) → α × β → φ",
  "name": "Function.uncurry",
  "kind": "def",
  "doc_string":
  "Interpret a function with two arguments as a function on `α × β` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 4",
  "name": "zero_lt_four",
  "kind": "theorem",
  "doc_string": "See `zero_lt_four'` for a version with the type explicit. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_2} {σ : α → Sort u_1} (P : Prop) [inst : Decidable P] (f : P → (a : α) → σ a) (g : ¬P → (a : α) → σ a)\n  (a : α), dite P f g a = if h : P then f h a else g h a",
  "name": "dite_apply",
  "kind": "theorem",
  "doc_string":
  "A 'dite' producing a `Pi` type `Π a, σ a`, applied to a value `a : α` is a `dite` that applies\neither branch to `a`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Inhabited α] → ℕ → List α → α",
  "name": "List.Func.get",
  "kind": "def",
  "doc_string":
  "Get element of a list by index. If the index is out of range, return the default element ",
  "args": ""},
 {"type": "ℕ → Linarith.PComp → Linarith.PCompSet → Linarith.PCompSet",
  "name": "Linarith.elimWithSet",
  "kind": "def",
  "doc_string":
  "`elimWithSet a p comps` collects the result of calling `pelimVar p p' a`\nfor every `p' ∈ comps`.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : MulOneClass M] →\n    {N : Type u_2} → [inst_1 : MulOneClass N] → (f : M →* N) → M →* { x // x ∈ MonoidHom.mrange f }",
  "name": "MonoidHom.mrangeRestrict",
  "kind": "def",
  "doc_string":
  "Restriction of a monoid hom to its range interpreted as a submonoid. ",
  "args": ""},
 {"type":
  "(p : Prop) →\n  [inst : SlimCheck.Testable p] → SlimCheck.Configuration → SlimCheck.TestResult p → ℕ → Rand (SlimCheck.TestResult p)",
  "name": "SlimCheck.Testable.runSuiteAux",
  "kind": "def",
  "doc_string": "Try `n` times to find a counter-example for `p`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → α → α → Prop",
  "name": "Relation.Join",
  "kind": "def",
  "doc_string":
  "The join of a relation on a single type is a new relation for which\npairs of terms are related if there is a third term they are both\nrelated to.  For example, if `r` is a relation representing rewrites\nin a term rewriting system, then *confluence* is the property that if\n`a` rewrites to both `b` and `c`, then `join r` relates `b` and `c`\n(see `relation.church_rosser`).\n",
  "args": ""},
 {"type": "Type u_1 → Type u_2 → Type (max u_1 u_2)",
  "name": "SMul",
  "kind": "inductive",
  "doc_string":
  "Typeclass for types with a scalar multiplication operation, denoted `•` (`\\bu`) ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → (M →+ N) → (M →+ N) → AddSubmonoid M",
  "name": "AddMonoidHom.eqLocusM",
  "kind": "def",
  "doc_string":
  "The additive submonoid of elements `x : M` such that `f x = g x`",
  "args": ""},
 {"type":
  "∀ {V : Type u} [inst : Quiver V] (r : V) [inst_1 : Quiver.RootedConnected r] {a : V} (p : Quiver.Path r a),\n  Quiver.Path.length (Quiver.shortestPath r a) ≤ Quiver.Path.length p",
  "name": "Quiver.shortest_path_spec",
  "kind": "theorem",
  "doc_string":
  "The length of a path is at least the length of the shortest path ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : AddSemigroup S] {a x y x' y' : S},\n  AddSemiconjBy a x y → AddSemiconjBy a x' y' → AddSemiconjBy a (x + x') (y + y')",
  "name": "AddSemiconjBy.add_right",
  "kind": "theorem",
  "doc_string":
  "If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x + x'` to `y + y'`.",
  "args": ""},
 {"type":
  "{ε : Type u} → {m : Type v → Type w} → [self : MonadExceptOf ε m] → {α : Type v} → m α → (ε → m α) → m α",
  "name": "MonadExceptOf.tryCatch",
  "kind": "def",
  "doc_string":
  "`tryCatch (body : m α) (handler : ε → m α) : m α` will catch any errors in\n`body` and pass the resulting error to `handler`.\nErrors in `handler` will not be caught. ",
  "args": ""},
 {"type": "∀ {a b : Prop}, a → b → a ∧ b",
  "name": "And.intro",
  "kind": "def",
  "doc_string":
  "`And.intro : a → b → a ∧ b` is the constructor for the And operation. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : OrderedSemiring α] {a b : α}, 1 ≤ a → 1 < b → 1 < a * b",
  "name": "one_lt_mul",
  "kind": "theorem",
  "doc_string": "**Alias** of `one_lt_mul_of_le_of_lt`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : AddGroup α] [inst_1 : SubtractionMonoid β] (f : α →+ β) (g h : α),\n  ↑f (g + -h) = ↑f g + -↑f h",
  "name": "AddMonoidHom.map_add_neg",
  "kind": "theorem",
  "doc_string": "Additive group homomorphisms preserve subtraction.",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.Context → Lean.Name → Array Lean.Expr → Lean.Expr",
  "name": "Mathlib.Tactic.Abel.Context.iapp",
  "kind": "def",
  "doc_string":
  "Apply the function `n : ∀ {α} [AddComm{Monoid,Group} α]` to the given list of arguments.\n\nWill use the `AddComm{Monoid,Group}` instance that has been cached in the context.\n",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : CompleteLattice α] → Prop",
  "name": "IsAtomistic",
  "kind": "inductive",
  "doc_string":
  "A lattice is atomistic iff every element is a `supₛ` of a set of atoms. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {sα : Q(CommSemiring «$α»)} →\n      {x : Q(«$α»)} →\n        {e : Q(ℕ)} →\n          {b : Q(«$α»)} →\n            Mathlib.Tactic.Ring.ExBase sα x →\n              Mathlib.Tactic.Ring.ExProd Mathlib.Tactic.Ring.sℕ e →\n                Mathlib.Tactic.Ring.ExProd sα b → Mathlib.Tactic.Ring.ExProd sα q(«$x» ^ «$e» * «$b»)",
  "name": "Mathlib.Tactic.Ring.ExProd.mul",
  "kind": "def",
  "doc_string":
  "A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is a `ExBase`\nand `e` is a `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\na polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) ",
  "args": ""},
 {"type": "Mathlib.Tactic.MkIff.Shape → Option ℕ",
  "name": "Mathlib.Tactic.MkIff.Shape.neqs",
  "kind": "def",
  "doc_string":
  "The number of equalities, or `none` in the case when we've reduced something\nof the form `p ∧ True` to just `p`.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → (M →* N) ≃ (Mᵐᵒᵖ →* Nᵐᵒᵖ)",
  "name": "MonoidHom.op",
  "kind": "def",
  "doc_string":
  "A monoid homomorphism `M →* N` can equivalently be viewed as a monoid homomorphism\n`Mᵐᵒᵖ →* Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. ",
  "args": ""},
 {"type": "{α : Type u} → α → ForInStep α",
  "name": "ForInStep.yield",
  "kind": "def",
  "doc_string":
  "`.yield a` means that we should continue the loop.\n`.yield` is produced by `continue` and reaching the bottom of the loop body. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Complement",
  "kind": "inductive",
  "doc_string": "The typeclass behind the notation `~~~a : α` where `a : α`. ",
  "args": ""},
 {"type":
  "{V : Type u_1} → [inst : Quiver V] → {X Y : Vᵒᵖ} → (X ⟶ Y) → (Opposite.unop Y ⟶ Opposite.unop X)",
  "name": "Quiver.Hom.unop",
  "kind": "def",
  "doc_string":
  "Given an arrow in `Vᵒᵖ`, we can take the \"unopposite\" back in `V`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [inst : ConditionallyCompleteLattice α] [inst_1 : SemilatticeSup β] {f g : β → α},\n  Monotone f → Antitone g → f ≤ g → (⨆ n, f n) ∈ Set.interᵢ fun n => Set.Icc (f n) (g n)",
  "name": "Monotone.csupᵢ_mem_Inter_Icc_of_antitone",
  "kind": "theorem",
  "doc_string":
  "Nested intervals lemma: if `f` is a monotone sequence, `g` is an antitone sequence, and\n`f n ≤ g n` for all `n`, then `⨆ n, f n` belongs to all the intervals `[f n, g n]`. ",
  "args": ""},
 {"type": "Lean.NameMapExtension Bool",
  "name": "ToAdditive.fixedNumeralAttr",
  "kind": "opaque",
  "doc_string":
  "An attribute that stores all the declarations that deal with numeric literals on fixed types.\n*  `@[to_additive_fixed_numeral]` should be added to all functions that take a numeral as argument\n  that should never be changed by `@[to_additive]` (because it represents a numeral in a fixed\n  type).\n* `@[to_additive_fixed_numeral?]` should be added to all functions that take a numeral as argument\n  that should only be changed if `additiveTest` succeeds on the first argument, i.e. when the\n  numeral is only translated if the first argument is a variable (or consists of variables).\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddCommSemigroup α] [inst_1 : PartialOrder α] [inst_2 : ExistsAddOfLE α]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_4 : Sub α] [inst_5 : OrderedSub α]\n  {a b c : α} [inst_6 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  c ≤ b → (a < b - c ↔ c + a < b)",
  "name": "lt_tsub_iff_left_of_le",
  "kind": "theorem",
  "doc_string":
  "See `lt_tsub_iff_left` for a stronger statement in a linear order. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "prioDefault",
  "kind": "def",
  "doc_string":
  "The default priority `default = 1000`, which is used when no priority is set. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_2} {M₀ : Type u_1} [inst : MonoidWithZero M₀] [inst_1 : MonoidWithZeroHomClass F ℚ M₀] {f g : F},\n  (∀ (m : ℤ), ↑f ↑m = ↑g ↑m) → f = g",
  "name": "MonoidWithZeroHom.ext_rat'",
  "kind": "theorem",
  "doc_string":
  "If `f` and `g` agree on the integers then they are equal `φ`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddMonoidWithOne",
  "kind": "inductive",
  "doc_string":
  "An `AddMonoidWithOne` is an `AddMonoid` with a `1`.\nIt also contains data for the unique homomorphism `ℕ → R`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → AddHom M N → AddSubsemigroup M → AddSubsemigroup N",
  "name": "AddSubsemigroup.map",
  "kind": "def",
  "doc_string":
  "The image of an `AddSubsemigroup` along an `AddSemigroup` homomorphism is\nan `AddSubsemigroup`.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.PushNeg.pushNeg",
  "kind": "def",
  "doc_string":
  "The syntax is `#push_neg e`, where `e` is an expression,\nwhich will print the `push_neg` form of `e`.\n\n`#push_neg` understands local variables, so you can use them to introduce parameters.\n",
  "args": ""},
 {"type": "(ℕ → Bool) → ℕ × ℕ → Bool",
  "name": "Prod.allI",
  "kind": "def",
  "doc_string":
  "`(start, stop).allI f a` returns true if `f` is true for all natural numbers\nfrom `start` (inclusive) to `stop` (exclusive):\n* `(5, 8).anyI f = f 5 && f 6 && f 7`\n",
  "args": ""},
 {"type": "Lean.NameMapExtension (List ℕ)",
  "name": "ToAdditive.ignoreArgsAttr",
  "kind": "opaque",
  "doc_string":
  "An attribute that tells `@[to_additive]` that certain arguments of this definition are not\ninvolved when using `@[to_additive]`.\nThis helps the heuristic of `@[to_additive]` by also transforming definitions if `ℕ` or another\nfixed type occurs as one of these arguments.\n",
  "args": ""},
 {"type":
  "{a : Lean.Level} →\n  {arg : Q(Type a)} → {sα : Q(CommSemiring «$arg»)} → {a_1 : Q(«$arg»)} → Mathlib.Tactic.Ring.ExSum sα a_1 → Bool",
  "name": "Mathlib.Tactic.Ring.ExSum.isAtom",
  "kind": "def",
  "doc_string": "True if this represents an atomic expression. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Monoid α] (x y : α) (u : αˣ), x * (y /ₚ u) = x * y /ₚ u",
  "name": "divp_assoc'",
  "kind": "theorem",
  "doc_string":
  "`field_simp` needs the reverse direction of `divp_assoc` to move all `/ₚ` to the right. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : CancelCommMonoidWithZero α] →\n    [inst_1 : DecidableEq α] → (∀ (a b : α), ∃ c, ∀ (d : α), d ∣ a ∧ d ∣ b ↔ d ∣ c) → GCDMonoid α",
  "name": "gcdMonoidOfExistsGCD",
  "kind": "def",
  "doc_string":
  "Define a `GCDMonoid` structure on a monoid just from the existence of a `gcd`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (e a b : Q(«$α»)) →\n      Mathlib.Meta.NormNum.Result a → Mathlib.Meta.NormNum.Result b → Option (Mathlib.Meta.NormNum.Result e)",
  "name": "Mathlib.Meta.NormNum.evalAdd.core",
  "kind": "def",
  "doc_string": "Main part of `evalAdd`. ",
  "args": ""},
 {"type": "(α : Type u_1) → Type u_2 → [inst : Monoid α] → Type (max u_1 u_2)",
  "name": "MulAction",
  "kind": "inductive",
  "doc_string":
  "Typeclass for multiplicative actions by monoids. This generalizes group actions. ",
  "args": ""},
 {"type":
  "∀ {X : Type u} {m₁ m₂ : X → X → X} {e₁ e₂ : X},\n  EckmannHilton.IsUnital m₁ e₁ →\n    EckmannHilton.IsUnital m₂ e₂ → (∀ (a b c d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) → e₁ = e₂",
  "name": "EckmannHilton.one",
  "kind": "theorem",
  "doc_string":
  "If a type carries two unital binary operations that distribute over each other,\nthen they have the same unit elements.\n\nIn fact, the two operations are the same, and give a commutative monoid structure,\nsee `eckmann_hilton.CommMonoid`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "prioMid",
  "kind": "def",
  "doc_string":
  "The standardized \"medium\" priority `med = 1000`. This is lower than `default`, and higher than `low`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : MulPosStrictMono α],\n  0 < a → 0 < b → 0 < a * b",
  "name": "Right.mul_pos",
  "kind": "theorem",
  "doc_string": "Assumes right covariance. ",
  "args": ""},
 {"type": "Sat.Valuation → Sat.Fmla → Prop",
  "name": "Sat.Valuation.satisfies_fmla",
  "kind": "inductive",
  "doc_string":
  "`v.satisfies_fmla f` asserts that formula `f` is satisfied by the valuation.\nA formula is satisfied if all clauses in it are satisfied. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : BEq α] → Prop",
  "name": "PartialEquivBEq",
  "kind": "inductive",
  "doc_string":
  "`PartialEquivBEq α` says that the `BEq` implementation is a\npartial equivalence relation, that is:\n* it is symmetric: `a == b → b == a`\n* it is transitive: `a == b → b == c → a == c`.\n",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Mul M] → M → Prop",
  "name": "IsIdempotentElem",
  "kind": "def",
  "doc_string": "An element `p` is said to be idempotent if `p * p = p`\n",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : Neg M₁] →\n            [inst_4 : Sub M₁] →\n              [inst_5 : SMul ℤ M₁] →\n                [inst_6 : SubtractionMonoid M₂] →\n                  (f : M₁ → M₂) →\n                    Function.Injective f →\n                      f 0 = 0 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁), f (-x) = -f x) →\n                            (∀ (x y : M₁), f (x - y) = f x - f y) →\n                              (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) → SubtractionMonoid M₁",
  "name": "Function.Injective.subtractionMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `0`, `+`, unary `-`, and binary `-`\nis a `SubtractionMonoid` if it admits an injective map that preserves `0`, `+`, unary `-`, and\nbinary `-` to a `SubtractionMonoid`. This version takes custom `nsmul` and `zsmul` as `[SMul ℕ M₁]`\nand `[SMul ℤ M₁]` arguments.",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List (List α)",
  "name": "List.tails",
  "kind": "def",
  "doc_string":
  "`tails l` is the list of terminal segments of `l`.\n```\ntails [1, 2, 3] = [[1, 2, 3], [2, 3], [3], []]\n```\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Monoid M] {f g : ℤ →* M},\n  ↑f (-1) = ↑g (-1) → MonoidHom.comp f ↑Int.ofNatHom = MonoidHom.comp g ↑Int.ofNatHom → f = g",
  "name": "MonoidHom.ext_int",
  "kind": "theorem",
  "doc_string":
  "If two `MonoidHom`s agree on `-1` and the naturals then they are equal. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Zero M] [inst_1 : Zero N] {f g : ZeroHom M N}, f = g → ∀ (x : M), ↑f x = ↑g x",
  "name": "ZeroHom.congr_fun",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.congr_fun` instead.",
  "args": ""},
 {"type": "{α : Type u} → αᵐᵒᵖ → α",
  "name": "MulOpposite.unop",
  "kind": "def",
  "doc_string": "The element of `α` represented by `x : αᵐᵒᵖ`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedField α] (a b : α), a / b = a * b⁻¹",
  "name": "LinearOrderedField.div_eq_mul_inv",
  "kind": "def",
  "doc_string": "`a / b := a * b⁻¹` ",
  "args": ""},
 {"type": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "name": "Function.Embedding",
  "kind": "inductive",
  "doc_string": "`α ↪ β` is a bundled injective function. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : LinearOrder α] → (pred : α → α) → (∀ {a b : α}, a ≤ pred b ↔ a < b) → PredOrder α",
  "name": "PredOrder.ofLePredIff",
  "kind": "def",
  "doc_string":
  "A constructor for `PredOrder α` usable when `α` is a linear order with no minimal element. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} → [inst_1 : CategoryTheory.Category D] → C ⥤ D → C ⥤ D → Type (max u₁ v₂)",
  "name": "CategoryTheory.NatTrans",
  "kind": "inductive",
  "doc_string":
  "`NatTrans F G` represents a natural transformation between functors `F` and `G`.\n\nThe field `app` provides the components of the natural transformation.\n\nNaturality is expressed by `α.naturality`.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} [inst : MonoidWithZero R] [inst_1 : Zero M] [inst_2 : MulActionWithZero R M],\n  ¬IsSMulRegular M 0 ↔ Nontrivial M",
  "name": "IsSMulRegular.not_zero_iff",
  "kind": "theorem",
  "doc_string": "The `0` element is not `M`-regular, on a non-trivial module. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (s : Set α) → (t : Set β) → ↑(s ×ˢ t) ≃ ↑s × ↑t",
  "name": "Equiv.Set.prod",
  "kind": "def",
  "doc_string":
  "The set product of two sets is equivalent to the type product of their coercions to types. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α] [self : IsAtomic α] (b : α),\n  b = ⊥ ∨ ∃ a, IsAtom a ∧ a ≤ b",
  "name": "IsAtomic.eq_bot_or_exists_atom_le",
  "kind": "def",
  "doc_string": "Every element other than `⊥` has an atom below it. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {s : Set β},\n  Set.Subsingleton s → ∀ {f : α → β}, Function.Injective f → Set.Subsingleton (f ⁻¹' s)",
  "name": "Set.Subsingleton.preimage",
  "kind": "theorem",
  "doc_string":
  "The preimage of a subsingleton under an injective map is a subsingleton. ",
  "args": ""},
 {"type":
  "(α : Type u_1) →\n  (β : Type u_2) →\n    [inst : Preorder α] → [inst : Preorder β] → [inst : MulOneClass α] → [inst : MulOneClass β] → Type (max u_1 u_2)",
  "name": "OrderMonoidHom",
  "kind": "inductive",
  "doc_string":
  "`α →*o β` is the type of functions `α → β` that preserve the `OrderedCommMonoid` structure.\n\n`OrderMonoidHom` is also used for ordered group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →*o β)`,\nyou should parametrize over `(F : Type*) [OrderMonoidHomClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderMonoidHomClass`. ",
  "args": ""},
 {"type":
  "{C : Type u} → [inst : CategoryTheory.Category C] → {X Y : C} → (X ≅ Y) → (X ⟶ Y)",
  "name": "CategoryTheory.Iso.hom",
  "kind": "def",
  "doc_string": "The forward direction of an isomorphism. ",
  "args": ""},
 {"type": "{α : Type u_1} → ℕ → List α → ℕ → List α × List (List α)",
  "name": "List.toChunksAux",
  "kind": "def",
  "doc_string":
  "Auxliary definition used to define `toChunks`.\n`toChunksAux n xs i` returns `(xs.take i, (xs.drop i).toChunks (n+1))`,\nthat is, the first `i` elements of `xs`, and the remaining elements chunked into\nsublists of length `n+1`. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Sat.LRATStep",
  "kind": "inductive",
  "doc_string": "An LRAT step is either an addition or a deletion step. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LE α] → WithTop αᵒᵈ ≃o (WithBot α)ᵒᵈ",
  "name": "WithTop.toDualBotEquiv",
  "kind": "def",
  "doc_string":
  "Taking the dual then adding `⊤` is the same as adding `⊥` then taking the dual.\nThis is the order iso form of `WithTop.ofDual`, as proven by `coe_toDualBotEquiv_eq`. ",
  "args": ""},
 {"type": "Sat.Clause → Sat.Fmla",
  "name": "Sat.Fmla.one",
  "kind": "def",
  "doc_string": "A single clause as a formula. ",
  "args": ""},
 {"type":
  "{α₁ : Type u_1} →\n  {α₂ : Type u_2} →\n    {β₁ : α₁ → Type u_3} → {β₂ : α₂ → Type u_4} → (f₁ : α₁ → α₂) → ((a : α₁) → β₁ a → β₂ (f₁ a)) → Sigma β₁ → Sigma β₂",
  "name": "Sigma.map",
  "kind": "def",
  "doc_string": "Map the left and right components of a sigma ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a : α}, a⁻¹ ≤ 1 → 1 ≤ a",
  "name": "one_le_of_inv_le_one",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `Left.inv_le_one_iff`.",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Set α → Prop",
  "name": "Set.InjOn",
  "kind": "def",
  "doc_string":
  "`f` is injective on `a` if the restriction of `f` to `a` is injective. ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : Lattice α] (a b : α), a ⊓ b ≤ b",
  "name": "Lattice.inf_le_right",
  "kind": "def",
  "doc_string": "The infimum is a lower bound on the second argument ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → ULift (α → β) → (Unit → ULift α) → ULift β",
  "name": "ULift.seq",
  "kind": "def",
  "doc_string": "Applicative sequencing. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {α : ι → Type u_2} → [inst : LT ι] → [inst : (i : ι) → LT (α i)] → LT (Lex ((i : ι) × α i))",
  "name": "Sigma.Lex.LT",
  "kind": "def",
  "doc_string": "The lexicographical `<` on a sigma type. ",
  "args": ""},
 {"type": "outParam (Type u) → Type v → Type (max u v)",
  "name": "Singleton",
  "kind": "inductive",
  "doc_string":
  "Type class for the `singleton` operation.\nUsed to implement the `{ a, b, c }` syntax.\n",
  "args": ""},
 {"type":
  "(α : Sort u) → [h₁ : Inhabited α] → [inst : Subsingleton α] → Unique α",
  "name": "Unique.mk'",
  "kind": "def",
  "doc_string":
  "Construct `Unique` from `Inhabited` and `Subsingleton`. Making this an instance would create\na loop in the class inheritance graph. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] ⦃f g : AddHom M N⦄, ↑f = ↑g → f = g",
  "name": "AddHom.coe_inj",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.coe_injective` instead.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LT α] [inst_1 : WellFoundedLT α] (a : α), Acc (fun x x_1 => x < x_1) a",
  "name": "WellFoundedLT.apply",
  "kind": "theorem",
  "doc_string": "All values are accessible under the well-founded `<`. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → (α → β) → Set β → Set α",
  "name": "Set.preimage",
  "kind": "def",
  "doc_string":
  "The preimage of `s : Set β` by `f : α → β`, written `f ⁻¹' s`,\nis the set of `x : α` such that `f x ∈ s`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} → [inst : NonUnitalNonAssocSemiring R] → [inst_1 : NonUnitalNonAssocSemiring S] → R ≃+* S → R →ₙ+* S",
  "name": "RingEquiv.toNonUnitalRingHom",
  "kind": "def",
  "doc_string":
  "Reinterpret a ring equivalence as a non-unital ring homomorphism. ",
  "args": ""},
 {"type": "Mathlib.Tactic.RingNF.Config → Bool",
  "name": "Mathlib.Tactic.RingNF.Config.recursive",
  "kind": "def",
  "doc_string":
  "if true, atoms inside ring expressions will be reduced recursively ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {a : R} [inst : Monoid R] (n : ℕ), IsRightRegular a → IsRightRegular (a ^ n)",
  "name": "IsRightRegular.pow",
  "kind": "theorem",
  "doc_string": "Any power of a right-regular element is right-regular. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → Option β → γ) → List α → List β → List γ × List β",
  "name": "List.map₂Left'",
  "kind": "def",
  "doc_string":
  "Left-biased version of `List.map₂`. `map₂Left' f as bs` applies `f` to each\npair of elements `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, `f` is\napplied to `none` for the remaining `aᵢ`. Returns the results of the `f`\napplications and the remaining `bs`.\n\n```\nmap₂Left' prod.mk [1, 2] ['a'] = ([(1, some 'a'), (2, none)], [])\n\nmap₂Left' prod.mk [1] ['a', 'b'] = ([(1, some 'a')], ['b'])\n```\n",
  "args": ""},
 {"type": "{α : Type u} → [inst : Monoid α] → α → α → Prop",
  "name": "IsConj",
  "kind": "def",
  "doc_string":
  "We say that `a` is conjugate to `b` if for some unit `c` we have `c * a * c⁻¹ = b`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Add M] ⦃s t : Set M⦄, s ⊆ t → AddSubsemigroup.closure s ≤ AddSubsemigroup.closure t",
  "name": "AddSubsemigroup.closure_mono",
  "kind": "theorem",
  "doc_string":
  "Additive subsemigroup closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`",
  "args": ""},
 {"type": "ℚ → ℕ+",
  "name": "Rat.pnatDen",
  "kind": "def",
  "doc_string": "Denominator as `ℕ+`. ",
  "args": ""},
 {"type": "Linarith.GlobalPreprocessor → Linarith.GlobalBranchingPreprocessor",
  "name": "Linarith.GlobalPreprocessor.branching",
  "kind": "def",
  "doc_string":
  "A `GlobalPreprocessor` lifts to a `GlobalBranchingPreprocessor` by producing only one branch.\n",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → ↑Set.univ ≃o α",
  "name": "OrderIso.Set.univ",
  "kind": "def",
  "doc_string": "Order isomorphism between `univ : Set α` and `α`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "name": "MulPosStrictMono",
  "kind": "def",
  "doc_string":
  "`MulPosStrictMono α` is an abbreviation for `CovariantClass α>0 α (λ x y, y * x) (<)`,\nexpressing that multiplication by positive elements on the right is strictly monotone. ",
  "args": ""},
 {"type": "(α : Type v) → [inst : Small α] → α ≃ Shrink α",
  "name": "equivShrink",
  "kind": "def",
  "doc_string":
  "The noncomputable equivalence between a `w`-small type and a model.\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "StrictOrderedSemiring",
  "kind": "inductive",
  "doc_string":
  "A `StrictOrderedSemiring` is a nontrivial semiring with a partial order such that addition is\nstrictly monotone and multiplication by a positive number is strictly monotone. ",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (a b : G₀), a / b = a * b⁻¹",
  "name": "GroupWithZero.div_eq_mul_inv",
  "kind": "def",
  "doc_string": "`a / b := a * b⁻¹` ",
  "args": ""},
 {"type":
  "{α₁ : Type u_1} →\n  {α₂ : Type u_2} →\n    {β₁ : Type u_3} →\n      {β₂ : Type u_4} →\n        {r₁ : α₁ → α₁ → Prop} →\n          {r₂ : α₂ → α₂ → Prop} →\n            {s₁ : β₁ → β₁ → Prop} → {s₂ : β₂ → β₂ → Prop} → r₁ ≃r s₁ → r₂ ≃r s₂ → Sum.Lex r₁ r₂ ≃r Sum.Lex s₁ s₂",
  "name": "RelIso.sumLexCongr",
  "kind": "def",
  "doc_string":
  "Given relation isomorphisms `r₁ ≃r s₁` and `r₂ ≃r s₂`, construct a relation isomorphism for the\nlexicographic orders on the sum.\n",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : Mul M] → [inst : Mul N] → Type (max u_1 u_2)",
  "name": "MulEquiv",
  "kind": "inductive",
  "doc_string":
  "`MulEquiv α β` is the type of an equiv `α ≃ β` which preserves multiplication. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : CompleteLattice α] → (α →o α) →o α",
  "name": "OrderHom.gfp",
  "kind": "def",
  "doc_string": "Greatest fixed point of a monotone function ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {F G : C ⥤ D}\n  (α : F ⟶ G) [inst_2 : CategoryTheory.IsIso α] (X : C), CategoryTheory.IsIso (CategoryTheory.NatTrans.app α X)",
  "name": "CategoryTheory.NatIso.isIso_app_of_isIso",
  "kind": "def",
  "doc_string": "The components of a natural isomorphism are isomorphisms.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → (l : List α) → (∃ a, a ∈ l ∧ p a) → α",
  "name": "List.choose",
  "kind": "def",
  "doc_string":
  "Given a decidable predicate `p` and a proof of existence of `a ∈ l` such that `p a`,\nchoose the first element with this property. This version returns `a : α`, and properties\nare given by `choose_mem` and `choose_property`. ",
  "args": ""},
 {"type":
  "{R : Type u} → [inst : EuclideanDomain R] → [inst : DecidableEq R] → R → R → R",
  "name": "EuclideanDomain.lcm",
  "kind": "def",
  "doc_string":
  "`lcm a b` is a (non-unique) element such that `a ∣ lcm a b` `b ∣ lcm a b`, and for\nany element `c` such that `a ∣ c` and `b ∣ c`, then `lcm a b ∣ c` ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : MulOneClass M] → M →* M",
  "name": "MonoidHom.id",
  "kind": "def",
  "doc_string": "The identity map from a monoid to itself. ",
  "args": ""},
 {"type": "Linarith.Sum",
  "name": "Linarith.Sum.one",
  "kind": "def",
  "doc_string":
  "`1` is represented as the singleton sum of the monomial `Monom.one` with coefficient 1. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → {r : α → α → Prop} → {s : β → β → Prop} → {t : γ → γ → Prop} → r ≼i s → s ≼i t → r ≼i t",
  "name": "InitialSeg.trans",
  "kind": "def",
  "doc_string": "Composition of functions shows that `≼i` is transitive ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β} {f : α → β} (h : ∀ (x : ↑s), f ↑x ∈ t),\n  Set.codRestrict (Set.restrict s f) t h =\n    Set.MapsTo.restrict f s t (_ : ∀ (x : α) (hx : x ∈ s), f ↑{ val := x, property := hx } ∈ t)",
  "name": "Set.codRestrict_restrict",
  "kind": "theorem",
  "doc_string":
  "Restricting the domain and then the codomain is the same as `MapsTo.restrict`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a = b → b < c → a < c",
  "name": "Eq.trans_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_eq_of_lt`.",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.Context → Lean.Name → Lean.Name → Array Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Mathlib.Tactic.Abel.Context.mkApp",
  "kind": "def",
  "doc_string":
  "Apply the function `n : ∀ {α} [inst α], _` to the implicit parameters in the\ncontext, and the given list of arguments.\n\nCompared to `context.app`, this takes the name of the typeclass, rather than an\ninferred typeclass instance.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} {n m : ℕ} (v : Vector α m), Vector.toList (Vector.drop n v) = List.drop n (Vector.toList v)",
  "name": "Vector.toList_drop",
  "kind": "theorem",
  "doc_string":
  "`drop` of vectors corresponds under `toList` to `drop` of lists. ",
  "args": ""},
 {"type": "{α : Type u} → Part α → Prop",
  "name": "Part.Dom",
  "kind": "def",
  "doc_string": "The domain of a partial value ",
  "args": ""},
 {"type":
  "∀ {α : Type v} [inst : LinearOrder α] {x₁ x₂ y₁ y₂ : α},\n  Disjoint (Set.Ico x₁ x₂) (Set.Ico y₁ y₂) → x₁ < x₂ → x₂ ∈ Set.Ico y₁ y₂ → y₁ = x₂",
  "name": "Set.eq_of_Ico_disjoint",
  "kind": "theorem",
  "doc_string":
  "If two half-open intervals are disjoint and the endpoint of one lies in the other,\nthen it must be equal to the endpoint of the other. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → {x : One M} → {x_1 : One N} → (f : OneHom M N) → (f' : M → N) → f' = ↑f → OneHom M N",
  "name": "OneHom.copy",
  "kind": "def",
  "doc_string":
  "Copy of a `OneHom` with a new `toFun` equal to the old one. Useful to fix definitional\nequalities. ",
  "args": ""},
 {"type": "(α : Type u_1) → Set (α × α)",
  "name": "Set.diagonal",
  "kind": "def",
  "doc_string":
  "`diagonal α` is the set of `α × α` consisting of all pairs of the form `(a, a)`. ",
  "args": ""},
 {"type":
  "∀ {A : Type u_1} {B : Type u_2} [self : SetLike A B], Function.Injective SetLike.coe",
  "name": "SetLike.coe_injective'",
  "kind": "def",
  "doc_string":
  "The coercion from a term of a `SetLike` to its corresponding `Set` is injective. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (ℕ → α → β) → List α → Array β → List β",
  "name": "List.mapIdx.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `mapIdx`:\n`mapIdx.go [a₀, a₁, ...] acc = acc.toList ++ [f acc.size a₀, f (acc.size + 1) a₁, ...]` ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«command#helpOption_»",
  "kind": "def",
  "doc_string":
  "The command `#help option` shows all options that have been defined in the current environment.\nEach option has a format like:\n```\noption pp.all : Bool := false\n  (pretty printer) display coercions, implicit parameters, proof terms, fully qualified names,\n  universe, and disable beta reduction and notations during pretty printing\n```\nThis says that `pp.all` is an option which can be set to a `Bool` value, and the default value is\n`false`. If an option has been modified from the default using e.g. `set_option pp.all true`,\nit will appear as a `(currently: true)` note next to the option.\n\nThe form `#help option id` will show only options that begin with `id`.\n",
  "args": ""},
 {"type":
  "Linarith.LinarithConfig → Lean.MVarId → List (List Lean.Expr) → Lean.MetaM Lean.Expr",
  "name": "Linarith.findLinarithContradiction",
  "kind": "def",
  "doc_string":
  "Given a list `ls` of lists of proofs of comparisons, `findLinarithContradiction cfg ls` will try to\nprove `false` by calling `linarith` on each list in succession. It will stop at the first proof of\n`false`, and fail if no contradiction is found with any list.\n",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → M × N →* M",
  "name": "MonoidHom.fst",
  "kind": "def",
  "doc_string":
  "Given monoids `M`, `N`, the natural projection homomorphism from `M × N` to `M`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] ⦃s t : Set α⦄, s ⊆ t → BddBelow t → BddBelow s",
  "name": "BddBelow.mono",
  "kind": "theorem",
  "doc_string": "If `s ⊆ t` and `t` is bounded below, then so is `s`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} {F : Type u_3} {x : MulOneClass M} {x_1 : MulOneClass N} [inst : MonoidHomClass F M N]\n  (f : F) {x_2 : M}, (∃ y, y * x_2 = 1) → ∃ y, y * ↑f x_2 = 1",
  "name": "MonoidHom.map_exists_left_inv",
  "kind": "theorem",
  "doc_string":
  "Given a monoid homomorphism `f : M →* N` and an element `x : M`, if `x` has a left inverse,\nthen `f x` has a left inverse too. For elements invertible on both sides see `IsUnit.map`. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → ¬IsMax a",
  "name": "LT.lt.not_isMax",
  "kind": "theorem",
  "doc_string": "**Alias** of `not_isMax_of_lt`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : GeneralizedBooleanAlgebra α] (a b : α), a ⊓ b ⊔ a \\ b = a",
  "name": "GeneralizedBooleanAlgebra.sup_inf_sdiff",
  "kind": "def",
  "doc_string": "For any `a`, `b`, `(a ⊓ b) ⊔ (a / b) = a` ",
  "args": ""},
 {"type":
  "{R : Type u_1} → [inst : AddMonoid R] → [inst : One R] → AddMonoidWithOne R",
  "name": "AddMonoidWithOne.unary",
  "kind": "def",
  "doc_string": "`AddMonoidWithOne` implementation using unary recursion. ",
  "args": ""},
 {"type":
  "∀ {γ : Type w} [inst : Preorder γ] [inst_1 : OrderTop γ] (s : Set γ), BddAbove s",
  "name": "OrderTop.bddAbove",
  "kind": "theorem",
  "doc_string": "When there is a global maximum, every set is bounded above. ",
  "args": ""},
 {"type":
  "{t t' : Type u → Type u} → ((α : Type u) → t α ≃ t' α) → [inst : Functor t] → {α β : Type u} → (α → β) → t' α → t' β",
  "name": "Equiv.map",
  "kind": "def",
  "doc_string":
  "Given a functor `t`, a function `t' : Type u → Type u`, and\nequivalences `t α ≃ t' α` for all `α`, then every function `α → β` can\nbe mapped to a function `t' α → t' β` functorially (see\n`Equiv.functor`). ",
  "args": ""},
 {"type":
  "∀ {α : Type u} (r : α → α → Prop) [inst : IsWellFounded α r] (a : α), Acc r a",
  "name": "IsWellFounded.apply",
  "kind": "theorem",
  "doc_string": "All values are accessible under the well-founded relation. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {R : Type u_2} {S : Type u_3} {inst : Mul R} {inst_1 : Add R} {inst_2 : Mul S} {inst_3 : Add S}\n  [self : RingEquivClass F R S] (f : F) (a b : R), ↑f (a + b) = ↑f a + ↑f b",
  "name": "RingEquivClass.map_add",
  "kind": "def",
  "doc_string":
  "By definition, a ring isomorphism preserves the additive structure. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → {γ : Sort u_3} → {δ : Sort u_4} → α ≃ β → γ ≃ δ → α ⊕' γ ≃ β ⊕' δ",
  "name": "Equiv.psumCongr",
  "kind": "def",
  "doc_string": "If `α ≃ α'` and `β ≃ β'`, then `PSum α β ≃ PSum α' β'`. ",
  "args": ""},
 {"type": "{n : ℕ} → Fin2 n → (k : ℕ) → Fin2 (n + k)",
  "name": "Fin2.add",
  "kind": "def",
  "doc_string": "`i + k : Fin2 (n + k)` when `i : Fin2 n` and `k : ℕ` ",
  "args": ""},
 {"type": "∀ (a : Prop), a = True ∨ a = False",
  "name": "Classical.prop_complete",
  "kind": "theorem",
  "doc_string": "**Alias** of `Classical.propComplete`.",
  "args": ""},
 {"type": "{α : Sort u_1} → (α → α) → Prop",
  "name": "Function.Involutive",
  "kind": "def",
  "doc_string": "A function is involutive, if `f ∘ f = id`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddMonoid M] →\n      [inst_1 : AddMonoid N] →\n        {s : Set M} →\n          (f : M → N) → AddSubmonoid.closure s = ⊤ → f 0 = 0 → (∀ (x y : M), y ∈ s → f (x + y) = f x + f y) → M →+ N",
  "name": "AddMonoidHom.ofClosureMEqTopRight",
  "kind": "def",
  "doc_string":
  "Let `s` be a subset of an additive monoid `M` such that the closure of `s` is\nthe whole monoid. Then `AddMonoidHom.ofClosureEqTopRight` defines an additive monoid\nhomomorphism from `M` asking for a proof of `f (x + y) = f x + f y` only for `y ∈ s`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Lattice α] →\n    [inst_1 : BoundedOrder α] → [inst_2 : IsModularLattice α] → {a b : α} → IsCompl a b → ↑(Set.Iic a) ≃o ↑(Set.Ici b)",
  "name": "IsCompl.IicOrderIsoIci",
  "kind": "def",
  "doc_string":
  "The diamond isomorphism between the intervals `set.Iic a` and `set.Ici b`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → Equiv.Perm α → (α ↪ β) → Equiv.Perm β",
  "name": "Equiv.Perm.viaEmbedding",
  "kind": "def",
  "doc_string":
  "Noncomputable version of `Equiv.Perm.viaFintypeEmbedding` that does not assume `Fintype` ",
  "args": ""},
 {"type": "{α : Type u_1} → Set α ≃ Set αᵒᵖ",
  "name": "Set.opEquiv",
  "kind": "def",
  "doc_string": "Taking opposites as an equivalence of powersets. ",
  "args": ""},
 {"type":
  "Type u_1 →\n  (R : outParam (Type u_2)) →\n    (S : outParam (Type u_3)) →\n      [inst : Mul R] → [inst : Add R] → [inst : Mul S] → [inst : Add S] → Type (max (max u_1 u_2) u_3)",
  "name": "RingEquivClass",
  "kind": "inductive",
  "doc_string":
  "`RingEquivClass F R S` states that `F` is a type of ring structure preserving equivalences.\nYou should extend this class when you extend `RingEquiv`. ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : AddSemigroup M] → AddSubsemigroup M",
  "name": "AddSubsemigroup.center",
  "kind": "def",
  "doc_string":
  "The center of a semigroup `M` is the set of elements that commute with everything in `M`",
  "args": ""},
 {"type": "{α : Type u} → α → WithZero α",
  "name": "WithZero.coe",
  "kind": "def",
  "doc_string": "The canonical map from `α` into `WithZero α`",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≠ a → a < b",
  "name": "LE.le.lt_of_ne'",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_le_of_ne'`.",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : Group G] → G ≃* Gˣ",
  "name": "toUnits",
  "kind": "def",
  "doc_string": "A group is isomorphic to its group of units. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {hα : OrderedCommGroup α} →\n      {hβ : OrderedCommGroup β} → (f : α → β) → Monotone f → (∀ (a b : α), f (a * b) = f a * f b) → α →*o β",
  "name": "OrderMonoidHom.mk'",
  "kind": "def",
  "doc_string":
  "Makes an ordered group homomorphism from a proof that the map preserves multiplication. ",
  "args": ""},
 {"type": "Lean.Parsec ℤ",
  "name": "Mathlib.Tactic.Sat.Parser.parseInt",
  "kind": "def",
  "doc_string": "Parse an integer ",
  "args": ""},
 {"type": "∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1",
  "name": "PNat.exists_eq_succ_of_ne_one",
  "kind": "theorem",
  "doc_string":
  "If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : CompleteLinearOrder α] → DecidableRel fun x x_1 => x ≤ x_1",
  "name": "CompleteLinearOrder.decidable_le",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)",
  "name": "Mathlib.Tactic.PushNeg.transformNegationStep",
  "kind": "def",
  "doc_string": "Push negations at the top level of the current expression. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : Monoid α] → [inst_1 : DecidableEq α] → DecidableEq αˣ",
  "name": "Units.instDecidableEqUnits",
  "kind": "def",
  "doc_string":
  "Units have decidable equality if the base `Monoid` has deciable equality. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ {x y : α}, r x y → r y x",
  "name": "Equivalence.symm",
  "kind": "def",
  "doc_string":
  "An equivalence relation is symmetric: `x ~ y` implies `y ~ x` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → {δ : Type u_4} → (α → β → γ → δ) → List α → List β → List γ → List δ",
  "name": "List.zipWith₃",
  "kind": "def",
  "doc_string": "Ternary version of `List.zipWith`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {C : WithTop α → Sort u_2} → C ⊤ → ((a : α) → C ↑a) → (n : WithTop α) → C n",
  "name": "WithTop.recTopCoe",
  "kind": "def",
  "doc_string":
  "Recursor for `WithTop` using the preferred forms `⊤` and `↑a`. ",
  "args": ""},
 {"type": "Lean.Expr → Mathlib.Tactic.GeneralizeProofs.M Lean.Expr",
  "name": "Mathlib.Tactic.GeneralizeProofs.visit",
  "kind": "opaque",
  "doc_string": "Recursively generalize proofs occuring in e ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Add α] →\n    [inst_1 : LinearOrder α] →\n      [inst : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] → α → α ↪o α",
  "name": "OrderEmbedding.addRight",
  "kind": "def",
  "doc_string":
  "The order embedding sending `b` to `b + a`, for some fixed `a`.\nSee also `OrderIso.addRight` when working in an additive ordered group.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] → [inst_1 : MulOneClass N] → {F : Type u_3} → [mc : MonoidHomClass F M N] → F → Submonoid N",
  "name": "MonoidHom.mrange",
  "kind": "def",
  "doc_string":
  "The range of a monoid homomorphism is a submonoid. See Note [range copy pattern]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a b : α), a / b = a * b⁻¹",
  "name": "LinearOrderedCommGroupWithZero.div_eq_mul_inv",
  "kind": "def",
  "doc_string": "`a / b := a * b⁻¹` ",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} {p₁ : α → Prop} {a : Type u_1} {p₂ : a → Prop} {y : m a} {q : α → Prop}\n  [inst : Applicative m] [inst_1 : LawfulApplicative m] {x : m α},\n  SatisfiesM p₁ x →\n    SatisfiesM p₂ y → (∀ {a_1 : α} {b : a}, p₁ a_1 → p₂ b → q a_1) → SatisfiesM q (SeqLeft.seqLeft x fun x => y)",
  "name": "SatisfiesM.seqLeft",
  "kind": "theorem",
  "doc_string": "`SatisfiesM` distributes over `<*`, general version. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a b : Q(«$α»)} →\n        Mathlib.Tactic.Ring.ExSum sα a →\n          Mathlib.Tactic.Ring.ExSum sα b → Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExSum sα) q(«$a» + «$b»)",
  "name": "Mathlib.Tactic.Ring.evalAdd",
  "kind": "opaque",
  "doc_string":
  "Adds two polynomials `va, vb` together to get a normalized result polynomial.\n\n* `0 + b = 0`\n* `a + 0 = 0`\n* `a * x + a * y = a * (x + y)` (for `x`, `y` coefficients; uses `evalAddOverlap`)\n* `(a₁ + a₂) + (b₁ + b₂) = a₁ + (a₂ + (b₁ + b₂))` (if `a₁.lt b₁`)\n* `(a₁ + a₂) + (b₁ + b₂) = b₁ + ((a₁ + a₂) + b₂)` (if not `a₁.lt b₁`)\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedCommMonoidWithZero α] (a : α), 0 * a = 0",
  "name": "LinearOrderedCommMonoidWithZero.zero_mul",
  "kind": "def",
  "doc_string": "Zero is a left absorbing element for multiplication ",
  "args": ""},
 {"type": "ToAdditive.Config → List ℕ",
  "name": "ToAdditive.Config.reorder",
  "kind": "def",
  "doc_string": "The arguments that should be reordered by `to_additive` ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → α ⊕ β → Bool",
  "name": "Sum.isRight",
  "kind": "def",
  "doc_string": "Check if a sum is `inr`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] →\n        {M' : Type u_3} →\n          {N' : Type u_4} → [inst_2 : MulOneClass M'] → [inst_3 : MulOneClass N'] → M ≃* M' → N ≃* N' → M × N ≃* M' × N'",
  "name": "MulEquiv.prodCongr",
  "kind": "def",
  "doc_string":
  "Product of multiplicative isomorphisms; the maps come from `equiv.prodCongr`.",
  "args": ""},
 {"type": "ℕ → ℕ → Type",
  "name": "Fin2.IsLT",
  "kind": "inductive",
  "doc_string":
  "This is a simple type class inference prover for proof obligations\nof the form `m < n` where `m n : ℕ`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] ⦃f g : M →* N⦄, ↑f = ↑g → f = g",
  "name": "MonoidHom.coe_inj",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.coe_injective` instead. ",
  "args": ""},
 {"type":
  "{C : Type u} → [inst : CategoryTheory.Category C] → {X Y : C} → (f : X ⟶ Y) → [inst_1 : CategoryTheory.IsIso f] → X ≅ Y",
  "name": "CategoryTheory.asIso",
  "kind": "def",
  "doc_string":
  "Reinterpret a morphism `f` with an `IsIso f` instance as an `Iso`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1],\n  AntitoneOn f s → AntitoneOn g s → AntitoneOn (fun x => f x * g x) s",
  "name": "AntitoneOn.mul'",
  "kind": "theorem",
  "doc_string": "The product of two antitone functions is antitone. ",
  "args": ""},
 {"type": "Type u → Type v → Type (max u v)",
  "name": "Prod",
  "kind": "inductive",
  "doc_string":
  "Product type (aka pair). You can use `α × β` as notation for `Prod α β`.\nGiven `a : α` and `b : β`, `Prod.mk a b : Prod α β`. You can use `(a, b)`\nas notation for `Prod.mk a b`. Moreover, `(a, b, c)` is notation for\n`Prod.mk a (Prod.mk b c)`.\nGiven `p : Prod α β`, `p.1 : α` and `p.2 : β`. They are short for `Prod.fst p`\nand `Prod.snd p` respectively. You can also write `p.fst` and `p.snd`.\nFor more information: [Constructors with Arguments](https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html?highlight=Prod#constructors-with-arguments)\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddSemigroup R] {a b : R}, IsAddLeftRegular a → IsAddLeftRegular b → IsAddLeftRegular (a + b)",
  "name": "IsAddLeftRegular.add",
  "kind": "theorem",
  "doc_string":
  "In an additive semigroup, the sum of add-left-regular elements is add-left.regular.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddCommMonoid",
  "kind": "inductive",
  "doc_string":
  "An additive commutative monoid is an additive monoid with commutative `(+)`. ",
  "args": ""},
 {"type":
  "{p q : Prop} → [dp : Decidable p] → [dq : Decidable q] → Decidable (p ∨ q)",
  "name": "Or.decidable",
  "kind": "def",
  "doc_string": "**Alias** of `instDecidableOr`.",
  "args": ""},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "name": "Function.HasLeftInverse",
  "kind": "def",
  "doc_string":
  "`HasLeftInverse f` means that `f` has an unspecified left inverse. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Preorder α] → (Antisymmetrization α fun x x_1 => x ≤ x_1) ↪o α",
  "name": "OrderEmbedding.ofAntisymmetrization",
  "kind": "def",
  "doc_string": "`ofAntisymmetrization` as an order embedding. ",
  "args": ""},
 {"type":
  "{V : Type u_1} →\n  [inst : Quiver V] →\n    {V' : Type u_2} → [inst_1 : Quiver V'] → [inst_2 : Quiver.HasReverse V'] → V ⥤q V' → Quiver.Symmetrify V ⥤q V'",
  "name": "Quiver.Symmetrify.lift",
  "kind": "def",
  "doc_string":
  "Given a quiver `V'` with reversible arrows, a prefunctor to `V'` can be lifted to one from\n`Symmetrify V` to `V'` ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → (M →+ N) ≃ (Mᵃᵒᵖ →+ Nᵃᵒᵖ)",
  "name": "AddMonoidHom.op",
  "kind": "def",
  "doc_string":
  "An additive monoid homomorphism `M →+ N` can equivalently be viewed as an\nadditive monoid homomorphism `Mᵃᵒᵖ →+ Nᵃᵒᵖ`. This is the action of the (fully faithful)\n`ᵃᵒᵖ`-functor on morphisms.",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  (M : ι → Type u_2) → [inst : (j : ι) → Mul (M j)] → [inst_1 : Subsingleton ι] → (i : ι) → ((j : ι) → M j) ≃* M i",
  "name": "MulEquiv.piSubsingleton",
  "kind": "def",
  "doc_string":
  "A family indexed by a nonempty subsingleton type is equivalent to the element at the single\nindex. ",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  {H : Type u_2} → [inst : AddZeroClass G] → [inst_1 : MulOneClass H] → G ≃+ Additive H ≃ (Multiplicative G ≃* H)",
  "name": "AddEquiv.toMultiplicative''",
  "kind": "def",
  "doc_string": "Reinterpret `G ≃+ Additive H` as `Multiplicative G ≃* H`. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : One M₁] →\n        [inst_2 : Pow M₁ ℕ] →\n          [inst_3 : Monoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 1 = 1 → (∀ (x y : M₁), f (x * y) = f x * f y) → (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) → Monoid M₁",
  "name": "Function.Injective.monoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `1` and `*` is a monoid, if it admits an injective map that preserves `1`\nand `*` to a monoid.  See note [reducible non-instances]. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«stx_,+»",
  "kind": "def",
  "doc_string":
  "`p,+` is shorthand for `sepBy(p, \",\")`. It parses 1 or more occurrences of\n`p` separated by `,`, that is: `p | p,p | p,p,p | ...`.\n\nIt produces a `nullNode` containing a `SepArray` with the interleaved parser\nresults. It has arity 1, and auto-groups its component parser if needed.\n",
  "args": ""},
 {"type": "Lean.Expr → optParam (List ℕ) [] → Lean.MetaM Lean.Expr",
  "name": "ToAdditive.reorderForall",
  "kind": "def",
  "doc_string":
  "Reorder pi-binders. See doc of `reorderAttr` for the interpretation of the argument ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "convertTo",
  "kind": "def",
  "doc_string":
  "`convert_to g using n` attempts to change the current goal to `g`, but unlike `change`,\nit will generate equality proof obligations using `congr n` to resolve discrepancies.\n`convert_to g` defaults to using `congr 1`.\n`convert_to` is similar to `convert`, but `convert_to` takes a type (the desired subgoal) while\n`convert` takes a proof term.\nThat is, `convert_to g using n` is equivalent to `convert (?_ : g) using n`.\n",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), ↑f (a / b) = ↑f a / ↑f b",
  "name": "map_div",
  "kind": "theorem",
  "doc_string": "Group homomorphisms preserve division. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Monoid M] → Mˣ → Equiv.Perm M",
  "name": "Units.mulRight",
  "kind": "def",
  "doc_string":
  "Right multiplication by a unit of a monoid is a permutation of the underlying type. ",
  "args": ""},
 {"type": "∀ (G : Type u) [inst : RightCancelSemigroup G], IsRightCancelMul G",
  "name": "RightCancelSemigroup.toIsRightCancelMul",
  "kind": "def",
  "doc_string": "Any `RightCancelSemigroup` satisfies `IsRightCancelMul`. ",
  "args": ""},
 {"type":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [inst : Mul α] →\n        [inst_1 : Add α] → [inst_2 : Mul β] → [inst_3 : Add β] → [inst_4 : RingEquivClass F α β] → F → α ≃+* β",
  "name": "RingEquivClass.toRingEquiv",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `RingEquivClass F α β` into an actual\n`RingEquiv`. This is declared as the default coercion from `F` to `α ≃+* β`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {ra : α → α → Prop} → {rb : β → β → Prop} → (f : α → β) → Relator.LiftFun ra rb f f → Quot ra → Quot rb",
  "name": "Quot.map",
  "kind": "def",
  "doc_string":
  "Map a function `f : α → β` such that `ra x y` implies `rb (f x) (f y)`\nto a map `Quot ra → Quot rb`. ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.Context → Mathlib.Tactic.Abel.NormalExpr → Lean.MetaM (Mathlib.Tactic.Abel.NormalExpr × Lean.Expr)",
  "name": "Mathlib.Tactic.Abel.evalNeg",
  "kind": "def",
  "doc_string": "Interpret a negated expression in `abel`'s normal form.\n",
  "args": ""},
 {"type":
  "∀ (α : Type u) [inst : Preorder α] [inst_1 : Nonempty α] [inst_2 : NoMinOrder α], ∃ f, StrictAnti f",
  "name": "Nat.exists_strictAnti",
  "kind": "theorem",
  "doc_string":
  "If `α` is a nonempty preorder with no minimal elements, then there exists a strictly antitone\nfunction `ℕ → α`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : CommRing α] →\n      [inst_1 : IsDomain α] →\n        [inst_2 : CommRing β] → (f : β →+ α) → (∀ (x : β), ↑f (x * x) = ↑f x * ↑f x) → 2 ≠ 0 → ↑f 1 = 1 → β →+* α",
  "name": "AddMonoidHom.mkRingHomOfMulSelfOfTwoNeZero",
  "kind": "def",
  "doc_string":
  "Make a ring homomorphism from an additive group homomorphism from a commutative ring to an\nintegral domain that commutes with self multiplication, assumes that two is nonzero and `1` is sent\nto `1`. ",
  "args": ""},
 {"type":
  "{α : Sort u} →\n  {s : Setoid α} →\n    {motive : Quotient s → Sort v} →\n      (f : (a : α) → motive (Quotient.mk s a)) →\n        (∀ (a b : α) (p : a ≈ b), (_ : Quotient.mk s a = Quotient.mk s b) ▸ f a = f b) → (q : Quotient s) → motive q",
  "name": "Quotient.rec",
  "kind": "def",
  "doc_string": "The analogue of `Quot.rec` for `Quotient`. See `Quot.rec`. ",
  "args": ""},
 {"type": "(α : Type u) → [inst : BEq α] → Prop",
  "name": "LawfulBEq",
  "kind": "inductive",
  "doc_string":
  "`LawfulBEq α` is a typeclass which asserts that the `BEq α` implementation\n(which supplies the `a == b` notation) coincides with logical equality `a = b`.\nIn other words, `a == b` implies `a = b`, and `a == a` is true.\n",
  "args": ""},
 {"type": "Type u_1 → Type u_2 → Type (max u_1 u_2)",
  "name": "VAdd",
  "kind": "inductive",
  "doc_string": "Type class for the `+ᵥ` notation. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {t : Set α},\n  MonotoneOn f t → ∀ {a : α}, IsLeast t a → IsLeast (f '' t) (f a)",
  "name": "MonotoneOn.map_isLeast",
  "kind": "theorem",
  "doc_string":
  "A monotone map sends a least element of a set to a least element of its image. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "GroupWithZero",
  "kind": "inductive",
  "doc_string":
  "A type `G₀` is a “group with zero” if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory.",
  "args": ""},
 {"type":
  "(S : Type u_1) → (M : outParam (Type u_2)) → [inst : Add M] → [inst : SetLike S M] → Prop",
  "name": "AddMemClass",
  "kind": "inductive",
  "doc_string":
  "`AddMemClass S M` says `S` is a type of sets `s : Set M` that are closed under `(+)` ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [inst : Monoid α] {a u : α}, IsUnit u → u ∣ a",
  "name": "IsUnit.dvd",
  "kind": "theorem",
  "doc_string": "Units of a monoid divide any element of the monoid. ",
  "args": ""},
 {"type": "ℕ → ℕ",
  "name": "Nat.minFac",
  "kind": "def",
  "doc_string": "Returns the smallest prime factor of `n ≠ 1`. ",
  "args": ""},
 {"type":
  "Lean.Meta.TransparencyMode →\n  Lean.Expr →\n    Linarith.ExprMap →\n      Linarith.Map Linarith.Monom ℕ → Lean.MetaM (Linarith.Comp × Linarith.ExprMap × Linarith.Map Linarith.Monom ℕ)",
  "name": "Linarith.toComp",
  "kind": "def",
  "doc_string":
  "`toComp red e e_map monom_map` converts an expression of the form `t < 0`, `t ≤ 0`, or `t = 0`\ninto a `comp` object.\n\n`e_map` maps atomic expressions to indices; `monom_map` maps monomials to indices.\nBoth of these are updated during processing and returned.\n",
  "args": ""},
 {"type": "{g : Type} → [inst : RandomGen g] → RandG g g",
  "name": "Rand.split",
  "kind": "def",
  "doc_string":
  "Create a new random number generator distinct from the one stored in the state ",
  "args": ""},
 {"type": "Num → Num",
  "name": "Num.div2",
  "kind": "def",
  "doc_string": "Divides a `Num` by `2` ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "name": "PosMulReflectLT",
  "kind": "def",
  "doc_string":
  "`PosMulReflectLT α` is an abbreviation for `ContravariantClas α≥0 α (λ x y, x * y) (<)`,\nexpressing that multiplication by nonnegative elements on the left is strictly reverse monotone. ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → α → β",
  "name": "lcCast",
  "kind": "axiom",
  "doc_string":
  "Auxiliary unsafe constant used by the Compiler when erasing casts.\n",
  "args": ""},
 {"type":
  "∀ (R : Type u) [inst : Ring R], IsField R → ∀ (x : R), x ≠ 0 → ∃! y, x * y = 1",
  "name": "uniq_inv_of_isField",
  "kind": "theorem",
  "doc_string":
  "For each field, and for each nonzero element of said field, there is a unique inverse.\nSince `IsField` doesn't remember the data of an `inv` function and as such,\na lemma that there is a unique inverse could be useful.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), a ≤ b ∨ b ≤ a",
  "name": "LinearOrderedRing.le_total",
  "kind": "def",
  "doc_string": "A linear order is total. ",
  "args": ""},
 {"type":
  "{t : Type u → Type u} →\n  {α : Type u} → {f : Type u → Type u} → [inst : Applicative f] → [inst : Traversable t] → t (f α) → f (t α)",
  "name": "sequence",
  "kind": "def",
  "doc_string":
  "A traversable functor commutes with all applicative functors. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {f g : M →* N},\n  f = g → ∀ (x : M), ↑f x = ↑g x",
  "name": "MonoidHom.congr_fun",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.congr_fun` instead. ",
  "args": ""},
 {"type":
  "(F : Type u → Type v) → [inst : Applicative F] → (G : Type u → Type w) → [inst : Applicative G] → Type (max (u + 1) v w)",
  "name": "ApplicativeTransformation",
  "kind": "inductive",
  "doc_string":
  "A transformation between applicative functors.  It is a natural\ntransformation such that `app` preserves the `Pure.pure` and\n`Functor.map` (`<*>`) operations. See\n`ApplicativeTransformation.preserves_map` for naturality. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [inst : Monoid M] →\n        [inst_1 : MulAction M α] →\n          [inst_2 : SMul M β] →\n            (f : β → α) → Function.Injective f → (∀ (c : M) (x : β), f (c • x) = c • f x) → MulAction M β",
  "name": "Function.Injective.mulAction",
  "kind": "def",
  "doc_string":
  "Pullback a multiplicative action along an injective map respecting `•`.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Linarith.LinarithM ℕ",
  "name": "Linarith.getMaxVar",
  "kind": "def",
  "doc_string": "Returns the current max variable. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Mul M] →\n      [inst_1 : Mul N] → (f : M →ₙ* N) → {g : N → M} → Function.LeftInverse g ↑f → M ≃* { x // x ∈ MulHom.srange f }",
  "name": "MulEquiv.ofLeftInverse",
  "kind": "def",
  "doc_string":
  "A semigroup homomorphism `f : M →ₙ* N` with a left-inverse `g : N → M` defines a multiplicative\nequivalence between `M` and `f.srange`.\n\nThis is a bidirectional version of `MulHom.srangeRestrict`. ",
  "args": ""},
 {"type": "ℤ → ℤ → ℤ",
  "name": "Int.emod",
  "kind": "def",
  "doc_string":
  "Integer modulus. This version of `Int.mod` uses the E-rounding convention\n(euclidean division), in which `Int.emod x y` satisfies `0 ≤ emod x y < natAbs y` for `y ≠ 0`\nand `Int.ediv` is the unique function satisfying `emod x y + (ediv x y) * y = x`.\n",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Monoid α] (u : αˣ), ↑(1 / u) = 1 /ₚ u",
  "name": "inv_eq_one_divp'",
  "kind": "theorem",
  "doc_string":
  "Used for `field_simp` to deal with inverses of units. This form of the lemma\nis essential since `field_simp` likes to use `inv_eq_one_div` to rewrite\n`↑u⁻¹ = ↑(1 / u)`.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_2} {M : Type u_1} [inst : MonoidWithZero R] [inst_1 : Zero M] [inst_2 : MulActionWithZero R M]\n  [sM : Subsingleton M], IsSMulRegular M 0",
  "name": "IsSMulRegular.zero",
  "kind": "theorem",
  "doc_string": "The element `0` is `M`-regular when `M` is trivial. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive Gᵃᵒᵖ G",
  "name": "AddAction.OppositeRegular.isPretransitive",
  "kind": "def",
  "doc_string":
  "The right regular action of an additive group on itself is transitive.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddMonoid M] (u : AddUnits M) (a : M), IsAddUnit (↑u + a) ↔ IsAddUnit a",
  "name": "AddUnits.isAddUnit_addUnits_add",
  "kind": "theorem",
  "doc_string":
  "Addition of a `u : add_units M` on the left doesn't affect `IsAddUnit`.",
  "args": ""},
 {"type": "ZNum → Num",
  "name": "ZNum.abs",
  "kind": "def",
  "doc_string": "The absolute value of a `ZNum` as a `Num`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} (r : α → α → Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r",
  "name": "Setoid.eqvGen_idem",
  "kind": "theorem",
  "doc_string": "Equivalence closure is idempotent. ",
  "args": ""},
 {"type":
  "{I : Type u} →\n  (f : I → Type v) → [inst : DecidableEq I] → [inst : (i : I) → One (f i)] → (i : I) → OneHom (f i) ((i : I) → f i)",
  "name": "OneHom.single",
  "kind": "def",
  "doc_string":
  "The one-preserving homomorphism including a single value\ninto a dependent family of values, as functions supported at a point.\n\nThis is the `OneHom` version of `Pi.mulSingle`. ",
  "args": ""},
 {"type": "¬BddAbove { p | Nat.Prime p }",
  "name": "Nat.not_bddAbove_setOf_prime",
  "kind": "theorem",
  "doc_string":
  "A version of `Nat.exists_infinite_primes` using the `BddAbove` predicate. ",
  "args": ""},
 {"type": "ℕ → Linarith.Linexp → Option ℤ",
  "name": "Linarith.Linexp.get",
  "kind": "def",
  "doc_string":
  "`l.get n` returns the value in `l` associated with key `n`, if it exists, and `none` otherwise.\nThis function assumes that `l` is sorted in decreasing order of the first argument,\nthat is, it will return `none` as soon as it finds a key smaller than `n`.\n",
  "args": ""},
 {"type": "{α : Type u} → α → Stream' α → Stream' α",
  "name": "Stream'.cons",
  "kind": "def",
  "doc_string": "Prepend an element to a stream. ",
  "args": ""},
 {"type": "{n : ℕ} → Fin2 n → Fin2 (Nat.succ n)",
  "name": "Fin2.fs",
  "kind": "def",
  "doc_string": "`n` as a member of `Fin (succ n)` ",
  "args": ""},
 {"type": "{α : Type u_1} → {n : ℕ} → (Fin n → α) → List α",
  "name": "List.ofFn",
  "kind": "def",
  "doc_string":
  "`ofFn f` with `f : fin n → α` returns the list whose ith element is `f i`\n```\nofFn f = [f 0, f 1, ... , f(n - 1)]\n```\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop} [self : CovariantClass M N μ r], Covariant M N μ r",
  "name": "CovariantClass.elim",
  "kind": "def",
  "doc_string":
  "For all `m ∈ M` and all elements `n₁, n₂ ∈ N`, if the relation `r` holds for the pair\n`(n₁, n₂)`, then, the relation `r` also holds for the pair `(μ m n₁, μ m n₂)` ",
  "args": ""},
 {"type": "{ε σ α : Type u} → EStateM ε σ α → σ → Option α",
  "name": "EStateM.run'",
  "kind": "def",
  "doc_string":
  "Execute an `EStateM` on initial state `s` for the returned value `α`.\nIf the monadic action throws an exception, returns `none` instead.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {ι : Sort u_1} [inst : ConditionallyCompleteLinearOrder α] {a : α} [inst_1 : Nonempty ι] {f : ι → α},\n  infᵢ f < a → ∃ i, f i < a",
  "name": "exists_lt_of_cinfᵢ_lt",
  "kind": "theorem",
  "doc_string":
  "Indexed version of the above lemma `exists_lt_of_cinfₛ_lt`\nWhen `infᵢ f < a`, there is an element `i` such that `f i < a`.\n",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Mul M] → Type u_1",
  "name": "MulAut",
  "kind": "def",
  "doc_string": "The group of multiplicative automorphisms. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → [inst : IsWellOrder β s] → r ≼i s → s ≼i r → r ≃r s",
  "name": "InitialSeg.antisymm",
  "kind": "def",
  "doc_string":
  "If we have order embeddings between `α` and `β` whose images are initial segments, and `β`\nis a well-order then `α` and `β` are order-isomorphic. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Monoid M] → (x : M) → [h : Decidable (∃ u, ↑u = x)] → Decidable (IsUnit x)",
  "name": "IsUnit.instDecidableIsUnit",
  "kind": "def",
  "doc_string":
  "`IsUnit x` is decidable if we can decide if `x` comes from `Mˣ`. ",
  "args": ""},
 {"type": "Linarith.PComp → ℕ → Bool",
  "name": "Linarith.PComp.maybeMinimal",
  "kind": "def",
  "doc_string":
  "Any comparison whose history is not minimal is redundant,\nand need not be included in the new set of comparisons.\n`elimedGE : ℕ` is a natural number such that all variables with index ≥ `elimedGE` have been\nremoved from the system.\n\nThis test is an overapproximation to minimality. It gives necessary but not sufficient conditions.\nIf the history of `c` is minimal, then `c.maybeMinimal` is true,\nbut `c.maybeMinimal` may also be true for some `c` with non-minimal history.\nThus, if `c.maybeMinimal` is false, `c` is known not to be minimal and must be redundant.\nSee https://doi.org/10.1016/B978-0-444-88771-9.50019-2 (Theorem 13).\nThe condition described there considers only implicitly eliminated variables that have been\nofficially eliminated from the system. This is not the case for every implicitly eliminated\nvariable. Consider eliminating `z` from `{x + y + z < 0, x - y - z < 0}`. The result is the set\n`{2*x < 0}`; `y` is implicitly but not officially eliminated.\n\nThis implementation of Fourier-Motzkin elimination processes variables in decreasing order of\nindices. Immediately after a step that eliminates variable `k`, variable `k'` has been eliminated\niff `k' ≥ k`. Thus we can compute the intersection of officially and implicitly eliminated variables\nby taking the set of implicitly eliminated variables with indices ≥ `elimedGE`.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Sat.commandLrat_proof_Example__",
  "kind": "def",
  "doc_string":
  "A macro for producing SAT proofs from CNF / LRAT files.\nThese files are commonly used in the SAT community for writing proofs.\n\nThe input to the `lrat_proof` command is the name of the theorem to define,\nand the statement (written in CNF format) and the proof (in LRAT format).\nFor example:\n```\nlrat_proof foo\n  \"p cnf 2 4  1 2 0  -1 2 0  1 -2 0  -1 -2 0\"\n  \"5 -2 0 4 3 0  5 d 3 4 0  6 1 0 5 1 0  6 d 1 0  7 0 5 2 6 0\"\n```\nproduces a theorem:\n```\nfoo : ∀ (a a_1 : Prop), (¬a ∧ ¬a_1 ∨ a ∧ ¬a_1) ∨ ¬a ∧ a_1 ∨ a ∧ a_1\n```\n\n* You can see the theorem statement by hovering over the word `foo`.\n* You can use the `example` keyword in place of `foo` to avoid generating a theorem.\n* You can use the `include_str` macro in place of the two strings\n  to load CNF / LRAT files from disk.\n",
  "args": ""},
 {"type": "∀ {G₀ : Type u} [self : GroupWithZero G₀], 0⁻¹ = 0",
  "name": "GroupWithZero.inv_zero",
  "kind": "def",
  "doc_string": "The inverse of `0` in a group with zero is `0`. ",
  "args": ""},
 {"type": "Simps.Config → List Lean.Name",
  "name": "Simps.Config.attrs",
  "kind": "def",
  "doc_string": "[TODO] Other attributes to apply to generated lemmas ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β → β) → β → List α → β",
  "name": "List.foldrTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `foldr`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    (p : α → Prop) →\n      [inst : DecidablePred p] → (x₀ : { a // p a } → β) → { x // x ∘ Subtype.val = x₀ } ≃ ({ a // ¬p a } → β)",
  "name": "Equiv.subtypePreimage",
  "kind": "def",
  "doc_string":
  "For a fixed function `x₀ : {a // p a} → β` defined on a subtype of `α`,\nthe subtype of functions `x : α → β` that agree with `x₀` on the subtype `{a // p a}`\nis naturally equivalent to the type of functions `{a // ¬ p a} → β`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} (o : Part α), { Dom := o.Dom, get := fun h => Part.get o h } = o",
  "name": "Part.eta",
  "kind": "theorem",
  "doc_string": "`Part` eta expansion ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "CategoryTheory.«term_⥤_»",
  "kind": "def",
  "doc_string": "Notation for a functor between categories. ",
  "args": ""},
 {"type": "{α : Type u_1} → List (Option α) → Option (List α)",
  "name": "List.allSome",
  "kind": "def",
  "doc_string":
  "If all elements of `xs` are `some xᵢ`, `allSome xs` returns the `xᵢ`. Otherwise\nit returns `none`.\n```\nallSome [some 1, some 2] = some [1, 2]\nallSome [some 1, none  ] = none\n```\n",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α) → ℕ → List α → List α",
  "name": "List.modifyNthTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `modifyNth`. ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.AbelNF.Config → Lean.FVarId → Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Tactic.Abel.abelNFLocalDecl",
  "kind": "def",
  "doc_string": "Use `abel_nf` to rewrite hypothesis `h`. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Polyrith.SageError → String",
  "name": "Mathlib.Tactic.Polyrith.SageError.name",
  "kind": "def",
  "doc_string": "The error kind ",
  "args": ""},
 {"type": "∀ {K : Type u} [self : Field K], 0⁻¹ = 0",
  "name": "Field.inv_zero",
  "kind": "def",
  "doc_string": "We define the inverse of `0` to be `0`. ",
  "args": ""},
 {"type":
  "{β : Type v} →\n  {m : Type v → Type w} →\n    [inst : Monad m] → (β → Float → m β) → β → (as : FloatArray) → optParam ℕ 0 → optParam ℕ (FloatArray.size as) → m β",
  "name": "FloatArray.foldlMUnsafe",
  "kind": "def",
  "doc_string": "See comment at `forInUnsafe` ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {F : Type u_3} →\n      [inst : Add R] →\n        [inst_1 : Add S] →\n          [inst_2 : Mul R] →\n            [inst_3 : Mul S] →\n              [inst_4 : AddEquivClass F R S] → (f : F) → (∀ (x y : R), ↑f (x * y) = ↑f x * ↑f y) → R ≃+* S",
  "name": "AddEquiv.toRingEquiv",
  "kind": "def",
  "doc_string":
  "Gives a `RingEquiv` from an element of an `AddEquivClass` preserving addition.",
  "args": ""},
 {"type":
  "(C : Type u₁) →\n  [inst : CategoryTheory.Category C] →\n    (D : Type u₂) →\n      [inst_1 : CategoryTheory.Category D] →\n        (E : Type u₃) → [inst_2 : CategoryTheory.Category E] → (C ⥤ D) ⥤ (D ⥤ E) ⥤ C ⥤ E",
  "name": "CategoryTheory.whiskeringLeft",
  "kind": "def",
  "doc_string":
  "Left-composition gives a functor `(C ⥤ D) ⥤ ((D ⥤ E) ⥤ (C ⥤ E))`.\n\n`(whiskeringLeft.obj F).obj G` is `F ⋙ G`, and\n`(whiskeringLeft.obj F).map α` is `whiskerLeft F α`.\n",
  "args": ""},
 {"type":
  "(S : Type u_1) → (M : outParam (Type u_2)) → [inst : AddZeroClass M] → [inst : SetLike S M] → Prop",
  "name": "AddSubmonoidClass",
  "kind": "inductive",
  "doc_string":
  "`AddSubmonoidClass S M` says `S` is a type of subsets `s ≤ M` that contain `0`\nand are closed under `(+)` ",
  "args": ""},
 {"type": "{m : Type → Type v} → [inst : Monad m] → List (m Bool) → m Bool",
  "name": "List.orM",
  "kind": "def",
  "doc_string":
  "`orM xs` runs the actions in `xs`, returning true if any of them returns\ntrue. `orM` short-circuits, so if an action returns true, later actions are\nnot run. ",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "name": "LT.lt.le",
  "kind": "theorem",
  "doc_string": "**Alias** of `le_of_lt`.",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → Erased α → (α → Erased β) → Erased β",
  "name": "Erased.bind",
  "kind": "def",
  "doc_string":
  "`(>>=)` operation on `Erased`.\n\nThis is a separate definition because `α` and `β` can live in different\nuniverses (the universe is fixed in `Monad`).\n",
  "args": ""},
 {"type": "∀ {p : Prop}, (¬p → False) → p",
  "name": "by_contra",
  "kind": "theorem",
  "doc_string": "**Alias** of `by_contradiction`.",
  "args": ""},
 {"type": "∀ {b : Prop} (a : Prop), b → a ∨ b",
  "name": "Or.intro_right",
  "kind": "theorem",
  "doc_string": "Alias for `Or.inr`. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : CompleteLattice α] (x : α), x ≤ ⊤",
  "name": "CompleteLattice.le_top",
  "kind": "def",
  "doc_string": "Any element is less than the top one. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Ring α] → α → ℤ → ℕ → Type",
  "name": "Mathlib.Meta.NormNum.IsRat",
  "kind": "inductive",
  "doc_string":
  "Assert that an element of a ring is equal to `num / denom`\n(and `denom` is invertible so that this makes sense).\nWe will usually also have `num` and `denom` coprime,\nalthough this is not part of the definition.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r : α → α → Prop} {s : Set α}, IsChain r s → IsChain (flip r) s",
  "name": "IsChain.symm",
  "kind": "theorem",
  "doc_string":
  "This can be used to turn `IsChain (≥)` into `IsChain (≤)` and vice-versa. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Antitone f → ∀ {s : Set α}, BddBelow s → BddAbove (f '' s)",
  "name": "Antitone.map_bddBelow",
  "kind": "theorem",
  "doc_string":
  "The image under an antitone function of a set which is bounded below is bounded above. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : CommRing R] (a b : R), (a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2",
  "name": "sub_pow_two",
  "kind": "theorem",
  "doc_string": "**Alias** of `sub_sq`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : DecidableEq α] → (i : α) → (β : Type u_2) → (α → β) ≃ β × ({ j // j ≠ i } → β)",
  "name": "Equiv.funSplitAt",
  "kind": "def",
  "doc_string":
  "A product of copies of a type can be split as the binary product of one copy and the product\nof all the remaining copies. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop},\n  Function.Injective fun f => ↑(RelIso.toRelEmbedding f).toEmbedding",
  "name": "RelIso.coe_fn_injective",
  "kind": "theorem",
  "doc_string":
  "The map `coe_fn : (r ≃r s) → (α → β)` is injective. Lean fails to parse\n`function.injective (λ e : r ≃r s, (e : α → β))`, so we use a trick to say the same. ",
  "args": ""},
 {"type": "{α : Type u_1} → Array α → ℕ → α → α",
  "name": "Array.getD",
  "kind": "def",
  "doc_string":
  "Access an element from an array, or return `v₀` if the index is out of bounds. ",
  "args": ""},
 {"type": "{α : Type v} → (P : α → Prop) → (i : α) × PLift (P i) ≃ Subtype P",
  "name": "Equiv.sigmaPLiftEquivSubtype",
  "kind": "def",
  "doc_string": "A `Sigma` with `PLift` fibers is equivalent to the subtype. ",
  "args": ""},
 {"type": "{α : Type u} → List α → (α → Bool) → Bool",
  "name": "List.all",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. Returns true if `p` is true for every element of `l`.\n* `any p [a, b, c] = p a && p b && p c`\n",
  "args": ""},
 {"type": "∀ {α : Type u} [self : SemilatticeInf α] (a b : α), a ⊓ b ≤ b",
  "name": "SemilatticeInf.inf_le_right",
  "kind": "def",
  "doc_string": "The infimum is a lower bound on the second argument ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, b ≤ c → a = b → a ≤ c",
  "name": "LE.le.trans_eq'",
  "kind": "theorem",
  "doc_string": "**Alias** of `le_of_le_of_eq'`.",
  "args": ""},
 {"type":
  "(α : Type u_1) → [H1 : PartialOrder α] → [H2 : InfSet α] → (∀ (s : Set α), IsGLB s (infₛ s)) → CompleteLattice α",
  "name": "completeLatticeOfInf",
  "kind": "def",
  "doc_string":
  "Create a `CompleteLattice` from a `PartialOrder` and `InfSet`\nthat returns the greatest lower bound of a set. Usually this constructor provides\npoor definitional equalities.  If other fields are known explicitly, they should be\nprovided; for example, if `inf` is known explicitly, construct the `CompleteLattice`\ninstance as\n```\ninstance : CompleteLattice my_T :=\n{ inf := better_inf,\n  le_inf := ...,\n  inf_le_right := ...,\n  inf_le_left := ...\n  -- don't care to fix sup, supₛ, bot, top\n  ..completeLatticeOfInf my_T _ }\n```\n",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : LeftCancelSemigroup M₂] →\n        (f : M₁ → M₂) → Function.Injective f → (∀ (x y : M₁), f (x * y) = f x * f y) → LeftCancelSemigroup M₁",
  "name": "Function.Injective.leftCancelSemigroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `*` is a left cancel semigroup, if it admits an injective map that\npreserves `*` to a left cancel semigroup.  See note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {V : Type u} [inst : Quiver V] {a b : V} (p : Quiver.Path a b) {c : V} (q : Quiver.Path b c),\n  Quiver.Path.toList (Quiver.Path.comp p q) = Quiver.Path.toList q ++ Quiver.Path.toList p",
  "name": "Quiver.Path.toList_comp",
  "kind": "theorem",
  "doc_string":
  "`Quiver.Path.toList` is a contravariant functor. The inversion comes from `Quiver.Path` and\n`List` having different preferred directions for adding elements. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Add M] {p : M → Prop} (x : M) {s : Set M},\n  AddSubsemigroup.closure s = ⊤ → (∀ (x : M), x ∈ s → p x) → (∀ (x y : M), p x → p y → p (x + y)) → p x",
  "name": "AddSubsemigroup.dense_induction",
  "kind": "theorem",
  "doc_string":
  "If `s` is a dense set in an additive monoid `M`,\n`AddSubsemigroup.closure s = ⊤`, then in order to prove that some predicate `p` holds\nfor all `x : M` it suffices to verify `p x` for `x ∈ s`, and verify that `p x` and `p y` imply\n`p (x + y)`.",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : RightCancelMonoid α], FaithfulSMul α α",
  "name": "RightCancelMonoid.faithfulSMul",
  "kind": "def",
  "doc_string": "`Monoid.toMulAction` is faithful on cancellative monoids. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r : α → α → Prop} {s : Set α} [inst : IsRefl α r],\n  Set.Pairwise s r → ∀ ⦃a : α⦄, a ∈ s → ∀ ⦃b : α⦄, b ∈ s → r a b",
  "name": "Set.Pairwise.of_refl",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `Set.pairwise_iff_of_refl`.",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → {x : AddZeroClass M} → {x_1 : AddZeroClass N} → Coe (M →+ N) (ZeroHom M N)",
  "name": "AddMonoidHom.coeToZeroHom",
  "kind": "def",
  "doc_string":
  "`AddMonoidHom` down-cast to a `ZeroHom`, forgetting the additive property",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Conv.«command#whnf_»",
  "kind": "def",
  "doc_string":
  "The command `#whnf e` evaluates `e` to Weak Head Normal Form, which means that the \"head\"\nof the expression is reduced to a primitive - a lambda or forall, or an axiom or inductive type.\nIt is similar to `#reduce e`, but it does not reduce the expression completely,\nonly until the first constructor is exposed. For example:\n```\nopen Nat List\nset_option pp.notation false\n#whnf [1, 2, 3].map succ\n-- cons (succ 1) (map succ (cons 2 (cons 3 nil)))\n#reduce [1, 2, 3].map succ\n-- cons 2 (cons 3 (cons 4 nil))\n```\nThe head of this expression is the `List.cons` constructor,\nso we can see from this much that the list is not empty,\nbut the subterms `Nat.succ 1` and `List.map Nat.succ (List.cons 2 (List.cons 3 List.nil))` are\nstill unevaluated. `#reduce` is equivalent to using `#whnf` on every subexpression.\n",
  "args": ""},
 {"type": "String → optParam String.Pos 0 → String → String",
  "name": "ToAdditive.capitalizeLikeAux",
  "kind": "opaque",
  "doc_string": "Helper for `capitalizeLike`. ",
  "args": ""},
 {"type": "∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n",
  "name": "Nat.not_exists_sq",
  "kind": "theorem",
  "doc_string": "There are no perfect squares strictly between m² and (m+1)² ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Monoid α] → αˣ →* α × αᵐᵒᵖ",
  "name": "Units.embedProduct",
  "kind": "def",
  "doc_string":
  "Canonical homomorphism of monoids from `αˣ` into `α × αᵐᵒᵖ`.\nUsed mainly to define the natural topology of `αˣ`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : PartialOrder α] → [inst_1 : PartialOrder β] → ((fun x x_1 => x < x_1) ≃r fun x x_1 => x < x_1) → α ≃o β",
  "name": "OrderIso.ofRelIsoLT",
  "kind": "def",
  "doc_string": "Converts a `RelIso (<) (<)` into an `OrderIso`. ",
  "args": ""},
 {"type":
  "{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right",
  "name": "Quiver.Total.hom",
  "kind": "def",
  "doc_string": "an arrow ",
  "args": ""},
 {"type": "{α : Type u} → {ι : Sort w} → (α → α → Prop) → (ι → α) → Prop",
  "name": "Directed",
  "kind": "def",
  "doc_string":
  "A family of elements of α is directed (with respect to a relation `≼` on α)\nif there is a member of the family `≼`-above any pair in the family.  ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {A : Type u_2} →\n    {B : Type u_3} →\n      [inst : AddZeroClass A] →\n        [inst_1 : DistribSMul M A] →\n          [inst_2 : AddZeroClass B] →\n            [inst_3 : SMul M B] →\n              (f : B →+ A) → Function.Injective ↑f → (∀ (c : M) (x : B), ↑f (c • x) = c • ↑f x) → DistribSMul M B",
  "name": "Function.Injective.distribSMul",
  "kind": "def",
  "doc_string":
  "Pullback a distributive scalar multiplication along an injective additive monoid\nhomomorphism.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : MulZeroClass R], IsRightRegular 0 ↔ Subsingleton R",
  "name": "isRightRegular_zero_iff_subsingleton",
  "kind": "theorem",
  "doc_string":
  "The element `0` is right-regular if and only if `R` is trivial. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Util.includeStr",
  "kind": "def",
  "doc_string":
  "A term macro that includes the content of a file, as a string. ",
  "args": ""},
 {"type": "(R : Type u_1) → [inst : MonoidWithZero R] → MulActionWithZero R R",
  "name": "MonoidWithZero.toMulActionWithZero",
  "kind": "def",
  "doc_string": "See also `Semiring.toModule` ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "OrElse",
  "kind": "inductive",
  "doc_string":
  "The homogeneous version of `HOrElse`: `a <|> b : α` where `a b : α`.\nBecause `b` is \"lazy\" in this notation, it is passed as `Unit → α` to the\nimplementation so it can decide when to evaluate it.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : PredOrder α] [inst_2 : IsPredArchimedean α] (r : α → α → Prop)\n  {n m : α}, (∀ (i : α), i ∈ Set.Ioc n m → r (Order.pred i) i) → n ≤ m → Relation.ReflTransGen r n m",
  "name": "reflTransGen_of_pred_of_le",
  "kind": "theorem",
  "doc_string":
  "For `n ≤ m`, `(n, m)` is in the reflexive-transitive closure of `~` if `pred i ~ i`\nfor all `i` between `n` and `m`. ",
  "args": ""},
 {"type": "∀ {M : Type u} [self : AddMonoid M] (a : M), a + 0 = a",
  "name": "AddMonoid.add_zero",
  "kind": "def",
  "doc_string": "Zero is a right neutral element for addition ",
  "args": ""},
 {"type": "Linarith.Ineq → Linarith.Ineq → Ordering",
  "name": "Linarith.Ineq.cmp",
  "kind": "def",
  "doc_string": "`Ineq` is ordered `eq < le < lt`. ",
  "args": ""},
 {"type":
  "∀ {σ : Type w₂} {α : Type u_1} {β : Type u_2} (f : α → σ → σ × β) (x : List α) (s : σ),\n  List.length (List.mapAccumr f x s).snd = List.length x",
  "name": "List.length_mapAccumr",
  "kind": "theorem",
  "doc_string": "Length of the list obtained by `mapAccumr`. ",
  "args": ""},
 {"type": "∀ {K : Type u} [self : DivisionRing K] (a b : K), a / b = a * b⁻¹",
  "name": "DivisionRing.div_eq_mul_inv",
  "kind": "def",
  "doc_string": "`a / b := a * b⁻¹` ",
  "args": ""},
 {"type":
  "{P : ℕ → ℕ → Sort u_1} →\n  ((a : ℕ) → P a 0) →\n    ((b : ℕ) → P 0 b) →\n      ((x y : ℕ) → P x (Nat.succ y) → P (Nat.succ x) y → P (Nat.succ x) (Nat.succ y)) → (n m : ℕ) → P n m",
  "name": "Nat.pincerRecursion",
  "kind": "def",
  "doc_string":
  "Given `P : ℕ → ℕ → Sort*`, if we have `P i 0` and `P 0 i` for all `i : ℕ`,\nand for any `x y : ℕ` we can extend `P` from `(x,y+1)` and `(x+1,y)` to `(x+1,y+1)`\nthen we have `P n m` for all `n m : ℕ`.\nNote that for non-`Prop` output it is preferable to use the equation compiler directly if possible,\nsince this produces equation lemmas. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} (s : Set α) (r : α → α → Prop), Set.Pairwise s r → Pairwise fun x y => r ↑x ↑y",
  "name": "Set.Pairwise.subtype",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `pairwise_subtype_iff_pairwise_set`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {s : Set β},\n  Set.Nontrivial s → ∀ {f : α → β}, Function.Surjective f → Set.Nontrivial (f ⁻¹' s)",
  "name": "Set.Nontrivial.preimage",
  "kind": "theorem",
  "doc_string":
  "The preimage of a nontrivial set under a surjective map is nontrivial. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1],\n  StrictMonoOn f s → StrictMonoOn g s → StrictMonoOn (fun x => f x + g x) s",
  "name": "StrictMonoOn.add",
  "kind": "theorem",
  "doc_string":
  "The sum of two strictly monotone functions is strictly monotone.",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → (α → m β) → Array α → m (Array β)",
  "name": "Array.mapMUnsafe",
  "kind": "def",
  "doc_string": "See comment at `forInUnsafe` ",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u_1} [self : CommGroupWithZero G₀] (a b : G₀), a / b = a * b⁻¹",
  "name": "CommGroupWithZero.div_eq_mul_inv",
  "kind": "def",
  "doc_string": "`a / b := a * b⁻¹` ",
  "args": ""},
 {"type": "Linarith.Sum → ℕ → Linarith.Sum",
  "name": "Linarith.Sum.pow",
  "kind": "def",
  "doc_string":
  "The `n`th power of `s : Sum` is the `n`-fold product of `s`, with `s.pow 0 = Sum.one`. ",
  "args": ""},
 {"type":
  "∀ {v : Sat.Valuation} {l : Sat.Literal},\n  (Sat.Valuation.neg v (Sat.Literal.negate l) → False) → (Sat.Valuation.neg v l → False) → False",
  "name": "Sat.Valuation.by_cases",
  "kind": "theorem",
  "doc_string":
  "The core unit-propagation step.\n\nWe have a local context of assumptions `¬l'` (sometimes called an assignment)\nand we wish to add `¬l` to the context, that is, we want to prove `l` is also falsified.\nThis is because there is a clause `a ∨ b ∨ ¬l` in the global context\nsuch that all literals in the clause are falsified except for `¬l`;\nso in the context `h₁` where we suppose that `¬l` is falsified,\nthe clause itself is falsified so we can prove `False`.\nWe continue the proof in `h₂`, with the assumption that `l` is falsified. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : SuccOrder α] [inst_2 : Preorder β] {f : α → β},\n  Antitone f → Pairwise (Disjoint on fun n => Set.Ioc (f (Order.succ n)) (f n))",
  "name": "Antitone.pairwise_disjoint_on_Ioc_succ",
  "kind": "theorem",
  "doc_string":
  "If `α` is a linear succ order, `β` is a preorder, and `f : α → β` is an antitone function, then\nthe intervals `Set.Ioc (f (Order.succ n)) (f n)` are pairwise disjoint. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {F : Type u_3} → [inst : Zero M] → [inst_1 : Zero N] → [inst_2 : ZeroHomClass F M N] → CoeTC F (ZeroHom M N)",
  "name": "instCoeTCZeroHom",
  "kind": "def",
  "doc_string":
  "Any type satisfying `ZeroHomClass` can be cast into `ZeroHom` via\n`ZeroHomClass.toZeroHom`. ",
  "args": ""},
 {"type":
  "∀ {P : ℤ → Prop} {m : ℤ}, P m → (∀ (n : ℤ), m ≤ n → P n → P (n + 1)) → ∀ (n : ℤ), m ≤ n → P n",
  "name": "Int.le_induction",
  "kind": "theorem",
  "doc_string": "See `Int.inductionOn'` for an induction in both directions. ",
  "args": ""},
 {"type": "NonScalar → ℕ",
  "name": "NonScalar.val",
  "kind": "def",
  "doc_string": "You should not use this function ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : LinearOrderedCommMonoid M] → (S : Submonoid M) → LinearOrderedCommMonoid { x // x ∈ S }",
  "name": "Submonoid.toLinearOrderedCommMonoid",
  "kind": "def",
  "doc_string":
  "A submonoid of a `LinearOrderedCommMonoid` is a `LinearOrderedCommMonoid`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : BEq α] → α → α → Bool",
  "name": "bne",
  "kind": "def",
  "doc_string":
  "`x != y` is boolean not-equal. It is the negation of `x == y` which is supplied by\nthe `BEq` typeclass.\n\nUnlike `x ≠ y` (which is notation for `Ne x y`), this is `Bool` valued instead of\n`Prop` valued. It is mainly intended for programming applications.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (r : α → α → Prop) (s : β → β → Prop) [inst : IsTrichotomous α r] [inst : IsIrrefl β s]\n  (f : α → β), (∀ {x y : α}, r x y → s (f x) (f y)) → Function.Injective f",
  "name": "injective_of_increasing",
  "kind": "theorem",
  "doc_string": "An increasing function is injective ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MulOneClass M], Reflexive fun a b => ∃ c, SemiconjBy c a b",
  "name": "SemiconjBy.reflexive",
  "kind": "theorem",
  "doc_string":
  "The relation “there exists an element that semiconjugates `a` to `b`” on a monoid (or, more\ngenerally, on `MulOneClass` type) is reflexive. ",
  "args": ""},
 {"type":
  "{V : Type u_1} → [inst : Quiver V] → {X Y : V} → (X ⟶ Y) → (Opposite.op Y ⟶ Opposite.op X)",
  "name": "Quiver.Hom.op",
  "kind": "def",
  "doc_string": "The opposite of an arrow in `V`.\n",
  "args": ""},
 {"type": "ℕ → ℕ",
  "name": "Nat.sqrt",
  "kind": "def",
  "doc_string":
  "Integer square root function. Implemented via Newton's method.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : MulZeroClass R], ¬IsLeftRegular 0 ↔ Nontrivial R",
  "name": "not_isLeftRegular_zero_iff",
  "kind": "theorem",
  "doc_string":
  "In a non-trivial `MulZeroClass`, the `0` element is not left-regular. ",
  "args": ""},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "name": "infᵢ.unexpander",
  "kind": "def",
  "doc_string": "Unexpander for the indexed infimum notation.",
  "args": ""},
 {"type": "Sort u → Sort (max 1 u)",
  "name": "SizeOf",
  "kind": "inductive",
  "doc_string":
  "`SizeOf` is a typeclass automatically derived for every inductive type,\nwhich equips the type with a \"size\" function to `Nat`.\nThe default instance defines each constructor to be `1` plus the sum of the\nsizes of all the constructor fields.\n\nThis is used for proofs by well-founded induction, since every field of the\nconstructor has a smaller size than the constructor itself,\nand in many cases this will suffice to do the proof that a recursive function\nis only called on smaller values.\nIf the default proof strategy fails, it is recommended to supply a custom\nsize measure using the `termination_by` argument on the function definition.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b c : α}, b ≤ a⁻¹ * c → a * b ≤ c",
  "name": "mul_le_of_le_inv_mul",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `le_inv_mul_iff_mul_le`.",
  "args": ""},
 {"type": "∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n",
  "name": "Nat.dvd_left_iff_eq",
  "kind": "theorem",
  "doc_string":
  "Two natural numbers are equal if and only if they have the same divisors. ",
  "args": ""},
 {"type": "ℕ",
  "name": "Nat.Linear.fixedVar",
  "kind": "def",
  "doc_string":
  "When encoding polynomials. We use `fixedVar` for encoding numerals.\nThe denotation of `fixedVar` is always `1`. ",
  "args": ""},
 {"type": "(p : ℕ → Prop) → Nat.Upto p → Nat.Upto p → Prop",
  "name": "Nat.Upto.GT",
  "kind": "def",
  "doc_string":
  "Lift the \"greater than\" relation on natural numbers to `Nat.Upto`. ",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.LinarithData",
  "kind": "inductive",
  "doc_string":
  "The state for the elimination monad.\n* `maxVar`: the largest variable index that has not been eliminated.\n* `comps`: a set of comparisons\n\nThe elimination procedure proceeds by eliminating variable `v` from `comps` progressively\nin decreasing order.\n",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → α → α → Prop",
  "name": "Relation.TransGen",
  "kind": "inductive",
  "doc_string": "`TransGen r`: transitive closure of `r` ",
  "args": ""},
 {"type":
  "∀ {t : Type u → Type u} [inst : Traversable t] [self : IsLawfulTraversable t] {α : Type u} (x : t α),\n  traverse pure x = x",
  "name": "IsLawfulTraversable.id_traverse",
  "kind": "def",
  "doc_string": "`traverse` plays well with `pure` of the identity monad",
  "args": ""},
 {"type":
  "(f : Type u₀ → Type u₁) → [inst : EquivFunctor f] → {α β : Type u₀} → α ≃ β → f α ≃ f β",
  "name": "EquivFunctor.mapEquiv",
  "kind": "def",
  "doc_string": "An `EquivFunctor` in fact takes every equiv to an equiv. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → {γ : Type u_3} → [inst : LE α] → [inst_1 : LE β] → [inst_2 : LE γ] → α ≃o β → β ≃o γ → α ≃o γ",
  "name": "OrderIso.trans",
  "kind": "def",
  "doc_string":
  "Composition of two order isomorphisms is an order isomorphism. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "WithTop",
  "kind": "def",
  "doc_string": "Attach `⊤` to a type. ",
  "args": ""},
 {"type": "ℕ → Lean.Expr → Lean.Expr × Lean.Expr",
  "name": "Mathlib.Tactic.Sat.buildReify.reifyClause1",
  "kind": "opaque",
  "doc_string":
  "Returns `a` and `pr : reify v c a` given a nonempty clause `c` ",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrderedCommGroup α] → DecidableRel fun x x_1 => x ≤ x_1",
  "name": "LinearOrderedCommGroup.decidable_le",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Semiquot α → Semiquot β",
  "name": "Semiquot.map",
  "kind": "def",
  "doc_string":
  "Apply a function to the unknown value stored in a `Semiquot α`. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : LinearOrderedField α], 0⁻¹ = 0",
  "name": "LinearOrderedField.inv_zero",
  "kind": "def",
  "doc_string": "We define the inverse of `0` to be `0`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : OrderedCommMonoid M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [inst : SubmonoidClass A M] → (S : A) → OrderedCommMonoid { x // x ∈ S }",
  "name": "SubmonoidClass.toOrderedCommMonoid",
  "kind": "def",
  "doc_string":
  "A submonoid of an `OrderedCommMonoid` is an `OrderedCommMonoid`. ",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HXor",
  "kind": "inductive",
  "doc_string":
  "The typeclass behind the notation `a ^^^ b : γ` where `a : α`, `b : β`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Semigroup M] → CommSemigroup { x // x ∈ Subsemigroup.center M }",
  "name":
  "Subsemigroup.instCommSemigroupSubtypeMemSubsemigroupToMulInstMembershipInstSetLikeSubsemigroupCenter",
  "kind": "def",
  "doc_string": "The center of a semigroup is commutative. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → [inst_2 : Unique N] → N × M ≃* M",
  "name": "MulEquiv.uniqueProd",
  "kind": "def",
  "doc_string":
  "Multiplying by the trivial monoid doesn't change the structure.",
  "args": ""},
 {"type": "(t : Type u → Type u) → [inst : Traversable t] → Type (u + 1)",
  "name": "IsLawfulTraversable",
  "kind": "inductive",
  "doc_string":
  "A traversable functor is lawful if its `traverse` satisfies a\nnumber of additional properties.  It must send `pure : α → Id α` to `pure`,\nsend the composition of applicative functors to the composition of the\n`traverse` of each, send each function `f` to `λ x, f <$> x`, and\nsatisfy a naturality condition with respect to applicative\ntransformations. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Monoid α] {p : α}, Irreducible p → ∀ (a b : α), p = a * b → IsUnit a ∨ IsUnit b",
  "name": "Irreducible.isUnit_or_isUnit'",
  "kind": "def",
  "doc_string": "if `p` factors then one factor is a unit ",
  "args": ""},
 {"type": "List ProjectionData → String → Lean.Name → Lean.MessageData",
  "name": "projectionsInfo",
  "kind": "def",
  "doc_string": "Returns the projection information of a structure. ",
  "args": ""},
 {"type": "(α : Type u_1) → Empty × α ≃ Empty",
  "name": "Equiv.emptyProd",
  "kind": "def",
  "doc_string":
  "`Empty` type is a left absorbing element for type product up to an equivalence. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«command#helpTerm+__»",
  "kind": "def",
  "doc_string":
  "The command `#help term` shows all term syntaxes that have been defined in the current environment.\nSee `#help cat` for more information.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.normNum",
  "kind": "def",
  "doc_string":
  "Normalize numerical expressions. Supports the operations `+` `-` `*` `/` `^` and `%`\nover numerical types such as `ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,\nand can prove goals of the form `A = B`, `A ≠ B`, `A < B` and `A ≤ B`, where `A` and `B` are\nnumerical expressions. It also has a relatively simple primality prover.\n",
  "args": ""},
 {"type": "{β : Sort v} → (β → β → Prop) → Prop",
  "name": "AntiSymmetric",
  "kind": "def",
  "doc_string":
  "A relation is antisymmetric if `x ≺ y` and `y ≺ x` together imply that `x = y`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : SemilatticeInf α] {r : β → β → Prop} {f : α → β},\n  (∀ (a₁ a₂ : α), a₁ ≤ a₂ → r (f a₂) (f a₁)) → Directed r f",
  "name": "directed_of_inf",
  "kind": "theorem",
  "doc_string": "An antitone function on an inf-semilattice is directed. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Preorder α] → Set α → Set α",
  "name": "upperBounds",
  "kind": "def",
  "doc_string": "The set of upper bounds of a set. ",
  "args": ""},
 {"type":
  "∀ {R : Type u} [self : AddCommGroupWithOne R] (n : ℕ), IntCast.intCast ↑n = ↑n",
  "name": "AddCommGroupWithOne.intCast_ofNat",
  "kind": "def",
  "doc_string":
  "The canonical homorphism `ℤ → R` agrees with the one from `ℕ → R` on `ℕ`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    [inst : Semiring R] →\n      [inst_1 : OrderedRing S] → AbsoluteValue R S → [inst_2 : IsDomain S] → [inst_3 : Nontrivial R] → R →*₀ S",
  "name": "AbsoluteValue.toMonoidWithZeroHom",
  "kind": "def",
  "doc_string":
  "Absolute values from a nontrivial `R` to a linear ordered ring preserve `*`, `0` and `1`. ",
  "args": ""},
 {"type": "ℕ → PNonScalar",
  "name": "PNonScalar.mk",
  "kind": "def",
  "doc_string": "You should not use this function ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {n : ℕ} (v : Vector α (Nat.succ n)), Vector.cons (Vector.head v) (Vector.tail v) = v",
  "name": "Vector.cons_head_tail",
  "kind": "theorem",
  "doc_string":
  "Prepending the head of a vector to its tail gives the vector. ",
  "args": ""},
 {"type": "∀ {α : Sort u}, α → Nonempty α",
  "name": "Nonempty.intro",
  "kind": "def",
  "doc_string": "If `val : α`, then `α` is nonempty. ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsTotalPreorder",
  "kind": "inductive",
  "doc_string":
  "`IsTotalPreorder X r` means that the binary relation `r` on `X` is total and a preorder. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α",
  "name": "Mathlib.Tactic.MkIff.List.init",
  "kind": "def",
  "doc_string": "Drops the final element of a list. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : BEq α] → List α → List α → Bool",
  "name": "List.beq",
  "kind": "def",
  "doc_string":
  "The equality relation on lists asserts that they have the same length\nand they are pairwise `BEq`.\n",
  "args": ""},
 {"type":
  "{ε : Type u} → {m : Type v → Type w} → [self : MonadExceptOf ε m] → {α : Type v} → ε → m α",
  "name": "MonadExceptOf.throw",
  "kind": "def",
  "doc_string":
  "`throw : ε → m α` \"throws an error\" of type `ε` to the nearest enclosing\ncatch block. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {r : (x : α) → β x → Prop}, (∀ (x : α), ∃ y, r x y) → ∃ f, ∀ (x : α), r x (f x)",
  "name": "Classical.axiom_of_choice",
  "kind": "theorem",
  "doc_string": "**Alias** of `Classical.axiomOfChoice`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [inst_3 : OrderedSub α] {a b c : α}\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], a + b - (a + c) ≤ b - c",
  "name": "add_tsub_add_le_tsub_left",
  "kind": "theorem",
  "doc_string": "See `add_tsub_add_eq_tsub_left` for the equality. ",
  "args": ""},
 {"type": "Linarith.LinarithM Unit",
  "name": "Linarith.validate",
  "kind": "def",
  "doc_string":
  "Throws an exception if a contradictory `PComp` is contained in the current state. ",
  "args": ""},
 {"type": "ℕ → ℕ → Bool",
  "name": "Nat.testBit",
  "kind": "def",
  "doc_string":
  "`testBit m n` returns whether the `(n+1)ˢᵗ` least significant bit is `1` or `0`",
  "args": ""},
 {"type":
  "∀ {ι : Type u_3} {M : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → VAdd M (α i)] (i : ι)\n  [inst_1 : FaithfulVAdd M (α i)], FaithfulVAdd M ((i : ι) × α i)",
  "name": "Sigma.FaithfulVAdd'",
  "kind": "theorem",
  "doc_string": "This is not an instance because `i` becomes a metavariable.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Sort u_2} [inst : ConditionallyCompleteLattice α] {f : ι → α},\n  BddAbove (Set.range f) → ∀ (c : ι), f c ≤ supᵢ f",
  "name": "le_csupᵢ",
  "kind": "theorem",
  "doc_string":
  "The indexed supremum of a function is bounded below by the value taken at one point",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Preorder α] → {a b : α} → a ≤ b → OrderBot ↑(Set.Icc a b)",
  "name": "Set.Icc.orderBot",
  "kind": "def",
  "doc_string": "`Icc a b` has a bottom element whenever `a ≤ b`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : LE α] → [inst_1 : BoundedOrder α] → [inst : IsSimpleOrder α] → Preorder α",
  "name": "IsSimpleOrder.preorder",
  "kind": "def",
  "doc_string":
  "A simple `BoundedOrder` induces a preorder. This is not an instance to prevent loops. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (e : M ≃* N) (y : N), ↑e (↑(MulEquiv.symm e) y) = y",
  "name": "MulEquiv.apply_symm_apply",
  "kind": "theorem",
  "doc_string":
  "`e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`. ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Polyrith.Poly → Mathlib.Tactic.Polyrith.Poly → Mathlib.Tactic.Polyrith.Poly",
  "name": "Mathlib.Tactic.Polyrith.Poly.add'",
  "kind": "def",
  "doc_string":
  "Adds two polynomials, performing some simple simplifications for presentation like\n`a + -b = a - b`. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Meta.NormNum.Result'",
  "kind": "inductive",
  "doc_string":
  "The result of `norm_num` running on an expression `x` of type `α`.\nUntyped version of `Result`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {p : α → Prop} → (f : Equiv.Perm α) → (∀ (x : α), p x ↔ p (↑f x)) → Equiv.Perm { x // p x }",
  "name": "Equiv.Perm.subtypePerm",
  "kind": "def",
  "doc_string":
  "If the permutation `f` fixes the subtype `{x // p x}`, then this returns the permutation\non `{x // p x}` induced by `f`. ",
  "args": ""},
 {"type": "Prop → Prop → Prop",
  "name": "And",
  "kind": "inductive",
  "doc_string":
  "`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α), max a 0 - max (-a) 0 = a",
  "name": "max_zero_sub_eq_self",
  "kind": "theorem",
  "doc_string": "**Alias** of `max_zero_sub_max_neg_zero_eq_self`.",
  "args": ""},
 {"type": "{α : Type u_1} → List (Option α) → List α → Array α → List α",
  "name": "List.fillNonesTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `fillNonesTR`: `fillNonesTR.go as as' acc = acc.toList ++ fillNones as as'`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} → [inst : Mul R] → [inst_1 : Mul S] → [inst_2 : Add R] → [inst_3 : Add S] → R ≃+* S → R ≃* S",
  "name": "RingEquiv.toMulEquiv",
  "kind": "def",
  "doc_string":
  "The equivalence of multiplicative monoids underlying an equivalence of (semi)rings. ",
  "args": ""},
 {"type":
  "{α : Type u} → (r : α → α → Prop) → [inst : IsWellOrder α r] → LinearOrder α",
  "name": "IsWellOrder.linearOrder",
  "kind": "def",
  "doc_string":
  "Construct a decidable linear order from a well-founded linear order. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Append",
  "kind": "inductive",
  "doc_string":
  "The homogeneous version of `HAppend`: `a ++ b : α` where `a b : α`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [self : PredOrder α] {a b : α}, PredOrder.pred a < b → a ≤ b",
  "name": "PredOrder.le_of_pred_lt",
  "kind": "def",
  "doc_string":
  "Proof that `pred` satifies ordering invariants betweeen `LE` and `LT`",
  "args": ""},
 {"type":
  "{a b : Prop} → {α : Sort u_1} → ((a → b) → (b → a) → α) → (a ↔ b) → α",
  "name": "Iff.elim",
  "kind": "def",
  "doc_string": "Non-dependent eliminator for `Iff`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulZeroOneClass M] [inst_1 : MulZeroOneClass N] {f g : M →*₀ N},\n  f = g ↔ ∀ (x : M), ↑f x = ↑g x",
  "name": "MonoidWithZeroHom.ext_iff",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.ext_iff` instead. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {α : Type u_2} [inst : SMul M α] [self : FaithfulSMul M α] {m₁ m₂ : M},\n  (∀ (a : α), m₁ • a = m₂ • a) → m₁ = m₂",
  "name": "FaithfulSMul.eq_of_smul_eq_smul",
  "kind": "def",
  "doc_string":
  "Two elements `m₁` and `m₂` are equal whenever they act in the same way on all points. ",
  "args": ""},
 {"type": "∀ {m n : ℕ} [self : Fin2.IsLT m n], m < n",
  "name": "Fin2.IsLT.h",
  "kind": "def",
  "doc_string": "The unique field of `Fin2.IsLT`, a proof that `m < n`. ",
  "args": ""},
 {"type":
  "{I : Type u} →\n  (f : I → Type v) → [inst : (i : I) → NonUnitalNonAssocSemiring (f i)] → (i : I) → ((i : I) → f i) →ₙ+* f i",
  "name": "Pi.evalNonUnitalRingHom",
  "kind": "def",
  "doc_string":
  "Evaluation of functions into an indexed collection of non-unital rings at a point is a\nnon-unital ring homomorphism. This is `Function.eval` as a `NonUnitalRingHom`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → (f : M →ₙ* N) → (∀ (x y : M), Commute (↑f x) (↑f y)) → Mᵐᵒᵖ →ₙ* N",
  "name": "MulHom.fromOpposite",
  "kind": "def",
  "doc_string":
  "A semigroup homomorphism `f : M →ₙ* N` such that `f x` commutes with `f y` for all `x, y`\ndefines a semigroup homomorphism from `Mᵐᵒᵖ`. ",
  "args": ""},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [self : MonadState σ m] → {α : Type u} → (σ → α × σ) → m α",
  "name": "MonadState.modifyGet",
  "kind": "def",
  "doc_string":
  "`modifyGet (f : σ → α × σ)` applies `f` to the current state, replaces\nthe state with the return value, and returns a computed value.\n\nIt is equivalent to `do let (a, s) := f (← get); put s; pure a`, but\n`modifyGet f` may be preferable because the former does not use the state\nlinearly (without sufficient inlining). ",
  "args": ""},
 {"type": "ℕ → Linarith.LinarithM Unit",
  "name": "Linarith.elimVarM",
  "kind": "def",
  "doc_string":
  "`elimVarM a` performs one round of Fourier-Motzkin elimination, eliminating the variable `a`\nfrom the `linarith` state.\n",
  "args": ""},
 {"type": "∀ {α : Type u} [self : SemilatticeSup α] (a b : α), a ≤ a ⊔ b",
  "name": "SemilatticeSup.le_sup_left",
  "kind": "def",
  "doc_string": "The supremum is an upper bound on the first argument ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} → [inst : PartialOrder β] → [inst_1 : SemilatticeInf α] → GaloisInsertion l u → SemilatticeInf β",
  "name": "GaloisInsertion.liftSemilatticeInf",
  "kind": "def",
  "doc_string": "Lift the infima along a Galois insertion ",
  "args": ""},
 {"type": "ℚ → ℚ → ℚ",
  "name": "Rat.add",
  "kind": "def",
  "doc_string": "Addition of rational numbers. ",
  "args": ""},
 {"type": "ℤ → ℤ → ℤ",
  "name": "Int.fdiv",
  "kind": "def",
  "doc_string":
  "Integer division. This version of `Int.div` uses the F-rounding convention\n(flooring division), in which `Int.fdiv x y` satisfies `fdiv x y = floor (x / y)`\nand `Int.fmod` is the unique function satisfying `fmod x y + (fdiv x y) * y = x`.\n",
  "args": ""},
 {"type":
  "{M₀ : Type u_1} →\n  {M₀' : Type u_2} →\n    [inst : MulZeroClass M₀] →\n      [inst_1 : Mul M₀'] →\n        [inst_2 : Zero M₀'] →\n          (f : M₀ → M₀') → Function.Surjective f → f 0 = 0 → (∀ (a b : M₀), f (a * b) = f a * f b) → MulZeroClass M₀'",
  "name": "Function.Surjective.mulZeroClass",
  "kind": "def",
  "doc_string":
  "Pushforward a `MulZeroClass` instance along an surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : LinearOrderedCommMonoidWithZero α] →\n    {β : Type u_2} →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Mul β] →\n            [inst_4 : Pow β ℕ] →\n              [inst_5 : HasSup β] →\n                [inst_6 : HasInf β] →\n                  (f : β → α) →\n                    Function.Injective f →\n                      f 0 = 0 →\n                        f 1 = 1 →\n                          (∀ (x y : β), f (x * y) = f x * f y) →\n                            (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                              (∀ (x y : β), f (x ⊔ y) = max (f x) (f y)) →\n                                (∀ (x y : β), f (x ⊓ y) = min (f x) (f y)) → LinearOrderedCommMonoidWithZero β",
  "name": "Function.Injective.linearOrderedCommMonoidWithZero",
  "kind": "def",
  "doc_string":
  "Pullback a `LinearOrderedCommMonoidWithZero` under an injective map.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.RingNF.ringConv",
  "kind": "def",
  "doc_string":
  "The tactic `ring` evaluates expressions in *commutative* (semi)rings.\nThis is the conv tactic version, which rewrites a target which is a ring equality to `True`.\n\nSee also the `ring` tactic.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : MulPosMono α],\n  0 ≤ a → 0 ≤ b → 0 ≤ a * b",
  "name": "Right.mul_nonneg",
  "kind": "theorem",
  "doc_string": "Assumes right covariance. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : AddZeroClass α] → [inst_1 : AddZeroClass β] → (α →+ β) → (I : Type u_3) → (I → α) →+ I → β",
  "name": "AddMonoidHom.compLeft",
  "kind": "def",
  "doc_string":
  "Additive monoid homomorphism between the function spaces `I → α` and `I → β`, induced by an\nadditive monoid homomorphism `f` between `α` and `β`",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : NormalizationMonoid α], normUnit 0 = 1",
  "name": "NormalizationMonoid.normUnit_zero",
  "kind": "def",
  "doc_string": "The proposition that `normUnit` maps `0` to the identity. ",
  "args": ""},
 {"type":
  "{M : Type uM} →\n  {N : Type uN} →\n    {P : Type uP} → {mM : MulOneClass M} → {mN : MulOneClass N} → {mP : CommMonoid P} → (M →* N →* P) → N →* M →* P",
  "name": "MonoidHom.flip",
  "kind": "def",
  "doc_string": "`flip` arguments of `f : M →* N →* P` ",
  "args": ""},
 {"type": "{u : Lean.Level} → (α : Q(Type u)) → Lean.MetaM Q(Semiring «$α»)",
  "name": "Mathlib.Meta.NormNum.inferSemiring",
  "kind": "def",
  "doc_string":
  "Helper functor to synthesize a typed `Semiring α` expression. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Choose.ElimStatus",
  "kind": "inductive",
  "doc_string":
  "Results of searching for nonempty instances,\nto eliminate dependencies on propositions (`choose!`).\n`success` means we found at least one instance;\n`failure ts` means we didn't find instances for any `t ∈ ts`.\n(`failure []` means we didn't look for instances at all.)\n\nRationale:\n`choose!` means we are expected to succeed at least once\nin eliminating dependencies on propositions.\n",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "SupSet",
  "kind": "inductive",
  "doc_string": "class for the `supₛ` operator ",
  "args": ""},
 {"type": "∀ {p : Prop} [inst : Decidable p], ¬¬p ↔ p",
  "name": "Decidable.not_not_iff",
  "kind": "theorem",
  "doc_string": "**Alias** of `Decidable.not_not`.",
  "args": ""},
 {"type": "Type u_1 → Prop",
  "name": "Nontrivial",
  "kind": "inductive",
  "doc_string":
  "Predicate typeclass for expressing that a type is not reduced to a single element. In rings,\nthis is equivalent to `0 ≠ 1`. In vector spaces, this is equivalent to positive dimension. ",
  "args": ""},
 {"type": "{α : Sort u} → α → PLift α",
  "name": "PLift.pure",
  "kind": "def",
  "doc_string": "Embedding of pure values. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → MulHomClass (M →ₙ* N) M N",
  "name": "MulHom.mulHomClass",
  "kind": "def",
  "doc_string": "`MulHom` is a type of multiplication-preseving homomorphisms ",
  "args": ""},
 {"type": "∀ {G : Type u} [self : CommSemigroup G] (a b : G), a * b = b * a",
  "name": "CommSemigroup.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → M ≃* N → M →* N",
  "name": "MulEquiv.toMonoidHom",
  "kind": "def",
  "doc_string":
  "Extract the forward direction of a multiplicative equivalence\nas a multiplication-preserving function.\n",
  "args": ""},
 {"type": "∀ {α : Type u} [self : SemilatticeSup α] (a b : α), b ≤ a ⊔ b",
  "name": "SemilatticeSup.le_sup_right",
  "kind": "def",
  "doc_string": "The supremum is an upper bound on the second argument ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_4} {α : Type u_3} {β : Type u_2} [inst : VAdd M α] [inst_1 : VAdd M β] [inst_2 : VAdd α β]\n  [inst_3 : VAddAssocClass M α β] (g : N → M), VAddAssocClass N α β",
  "name": "VAdd.comp.isScalarTower",
  "kind": "theorem",
  "doc_string":
  "Given a tower of additive actions `M → α → β`, if we use `SMul.comp` to pull back both of\n`M`'s actions by a map `g : N → M`, then we obtain a new tower of scalar actions `N → α → β`.\n\nThis cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), S = ⊥ ∨ ∃ x, x ∈ S ∧ x ≠ 0",
  "name": "AddSubmonoid.bot_or_exists_ne_zero",
  "kind": "theorem",
  "doc_string":
  "An additive submonoid is either the trivial additive submonoid or contains a nonzero\nelement.",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : Nontrivial α], ∃ x y, x ≠ y",
  "name": "Nontrivial.exists_pair_ne",
  "kind": "def",
  "doc_string": "In a nontrivial type, there exists a pair of distinct terms. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {f : ℤ → α},\n  Antitone f → ∀ (n : ℤ) {x : α}, f (n + 1) < x → x < f n → ∀ (a : ℤ), f a ≠ x",
  "name": "Antitone.ne_of_lt_of_lt_int",
  "kind": "theorem",
  "doc_string":
  "If `f` is an antitone function from `ℤ` to a preorder and `x` lies between `f (n + 1)` and\n`f n`, then `x` doesn't lie in the range of `f`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : CompleteLattice α] → Prop",
  "name": "IsCoatomistic",
  "kind": "inductive",
  "doc_string":
  "A lattice is coatomistic iff every element is an `infₛ` of a set of coatoms. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → (f : α → β) → (r : Setoid β) → Quotient (Setoid.comap f r) ≃ ↑(Set.range (Quotient.mk'' ∘ f))",
  "name": "Setoid.comapQuotientEquiv",
  "kind": "def",
  "doc_string": "The second isomorphism theorem for sets. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] (u : M₀ˣ), Ring.inverse ↑u = ↑u⁻¹",
  "name": "Ring.inverse_unit",
  "kind": "theorem",
  "doc_string": "By definition, if `x` is invertible then `inverse x = x⁻¹`. ",
  "args": ""},
 {"type": "{α : Type u_1} → Part α",
  "name": "Part.none",
  "kind": "def",
  "doc_string":
  "The `none` value in `Part` has a `False` domain and an empty function. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} (self : α ≃. β) (a : α) (b : β), a ∈ PEquiv.invFun self b ↔ b ∈ PEquiv.toFun self a",
  "name": "PEquiv.inv",
  "kind": "def",
  "doc_string": "`invFun` is the partial inverse of `toFun`  ",
  "args": ""},
 {"type": "{α : Type u} → Stream' α → Stream' (Stream' α)",
  "name": "Stream'.tails",
  "kind": "def",
  "doc_string": "Tails of a stream, starting with `Stream'.tail s`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedMonoid α] (a b : α), min a b = if a ≤ b then a else b",
  "name": "CanonicallyLinearOrderedMonoid.min_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `minOfLe`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : SuccOrder α] {a b : α} [inst_2 : NoMaxOrder α],\n  a ≠ b → Order.succ a ≠ Order.succ b",
  "name": "Order.succ_ne_succ",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Order.succ_ne_succ_iff`.",
  "args": ""},
 {"type": "∀ {α : Type u_1} {r : α → α → Prop}, IsMaxChain r (maxChain r)",
  "name": "maxChain_spec",
  "kind": "theorem",
  "doc_string":
  "**Hausdorff's maximality principle**\n\nThere exists a maximal totally ordered set of `α`.\nNote that we do not require `α` to be partially ordered by `r`. ",
  "args": ""},
 {"type": "∀ {α : Sort u} [self : Subsingleton α] (a b : α), a = b",
  "name": "Subsingleton.allEq",
  "kind": "def",
  "doc_string": "Any two elements of a subsingleton are equal. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} → (sα : Q(CommSemiring «$α»)) → Q(Ring «$α») → ℕ → (e : Q(«$α»)) × Mathlib.Tactic.Ring.ExProd sα e",
  "name": "Mathlib.Tactic.Ring.ExProd.mkNegNat",
  "kind": "def",
  "doc_string":
  "Constructs the expression corresponding to `.const (-n)`.\n(The `.const` constructor does not check that the expression is correct.)\n",
  "args": ""},
 {"type":
  "{α : Type u} → (β : Type v) → [inst : Group α] → [inst_1 : Monoid β] → [inst : MulDistribMulAction α β] → α → β ≃* β",
  "name": "MulDistribMulAction.toMulEquiv",
  "kind": "def",
  "doc_string":
  "Each element of the group defines a multiplicative monoid isomorphism.\n\nThis is a stronger version of `MulAction.toPerm`. ",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} → {α : Type u_1} → [inst : Monad m] → m (Option α) → m α → m α",
  "name": "Option.getDM",
  "kind": "def",
  "doc_string": "A monadic analogue of `Option.getD`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, IsAtom a → ⊥ ⋖ a",
  "name": "IsAtom.bot_covby",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `bot_covby_iff`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r₁ r₂ : Setoid α}, r₁ = r₂ ↔ Setoid.Rel r₁ = Setoid.Rel r₂",
  "name": "Setoid.eq_iff_rel_eq",
  "kind": "theorem",
  "doc_string":
  "Two equivalence relations are equal iff their underlying binary operations are equal. ",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.ldiff'",
  "kind": "def",
  "doc_string":
  "`ldiff' a b` performs bitwise set difference. For each corresponding\npair of bits taken as booleans, say `aᵢ` and `bᵢ`, it applies the\nboolean operation `aᵢ  ∧ bᵢ` to obtain the `iᵗʰ` bit of the result.",
  "args": ""},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "name": "insertUnexpander",
  "kind": "def",
  "doc_string": "Unexpander for the `{ x, y, ... }` notation. ",
  "args": ""},
 {"type": "{M₀ : Type u_1} → [inst : MonoidWithZero M₀] → M₀ → M₀",
  "name": "Ring.inverse",
  "kind": "def",
  "doc_string":
  "Introduce a function `inverse` on a monoid with zero `M₀`, which sends `x` to `x⁻¹` if `x` is\ninvertible and to `0` otherwise.  This definition is somewhat ad hoc, but one needs a fully (rather\nthan partially) defined inverse function for some purposes, including for calculus.\n\nNote that while this is in the `Ring` namespace for brevity, it requires the weaker assumption\n`MonoidWithZero M₀` instead of `Ring M₀`. ",
  "args": ""},
 {"type": "{α : Sort u} → IsEmpty α → {p : α → Sort u_1} → (a : α) → p a",
  "name": "IsEmpty.elim",
  "kind": "def",
  "doc_string":
  "Eliminate out of a type that `IsEmpty` (using projection notation). ",
  "args": ""},
 {"type": "PosNum → Num",
  "name": "PosNum.pred'",
  "kind": "def",
  "doc_string": "The predecessor of a `PosNum` as a `Num`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : CanonicallyLinearOrderedAddMonoid α] → DecidableRel fun x x_1 => x ≤ x_1",
  "name": "CanonicallyLinearOrderedAddMonoid.decidable_le",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "CommGroup",
  "kind": "inductive",
  "doc_string": "A commutative group is a group with commutative `(*)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, b < a → 0 < a - b",
  "name": "sub_pos_of_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `sub_pos`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → α → List α → List β → List α → (List α → β) → List α × List β",
  "name": "List.permutationsAux2",
  "kind": "def",
  "doc_string":
  "An auxiliary function for defining `permutations`. `permutationsAux2 t ts r ys f` is equal to\n`(ys ++ ts, (insert_left ys t ts).map f ++ r)`, where `insert_left ys t ts` (not explicitly\ndefined) is the list of lists of the form `insert_nth n t (ys ++ ts)` for `0 ≤ n < length ys`.\n\n    permutations_aux2 10 [4, 5, 6] [] [1, 2, 3] id =\n      ([1, 2, 3, 4, 5, 6],\n       [[10, 1, 2, 3, 4, 5, 6],\n        [1, 10, 2, 3, 4, 5, 6],\n        [1, 2, 10, 3, 4, 5, 6]]) ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a : α}, a⁻¹ < 1 ↔ 1 < a",
  "name": "inv_lt_one'",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.inv_lt_one_iff`.",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → (α : Type u_3) → [inst : SMul M α] → (N → M) → SMul N α",
  "name": "SMul.comp",
  "kind": "def",
  "doc_string":
  "An action of `M` on `α` and a function `N → M` induces an action of `N` on `α`.\n\nSee note [reducible non-instances]. Since this is reducible, we make sure to go via\n`SMul.comp.smul` to prevent typeclass inference unfolding too far. ",
  "args": ""},
 {"type":
  "∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → Preorder (π i)] {a b : (i : ι) → π i}, StrongLT a b → a ≤ b",
  "name": "StrongLT.le",
  "kind": "theorem",
  "doc_string": "**Alias** of `le_of_strongLT`.",
  "args": ""},
 {"type":
  "(Type u → Type v) → Type w₁ → outParam (Type w₂) → Type (max (max (max (u + 1) v) w₁) w₂)",
  "name": "ForM",
  "kind": "inductive",
  "doc_string":
  "Typeclass for the polymorphic `forM` operation described in the \"do unchained\" paper.\nRemark:\n- `γ` is a \"container\" type of elements of type `α`.\n- `α` is treated as an output parameter by the typeclass resolution procedure.\n  That is, it tries to find an instance using only `m` and `γ`.\n",
  "args": ""},
 {"type": "List Linarith.GlobalBranchingPreprocessor",
  "name": "Linarith.defaultPreprocessors",
  "kind": "def",
  "doc_string":
  "The default list of preprocessors, in the order they should typically run.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : HasInf α] →\n    (∀ (a b : α), a ⊓ b = b ⊓ a) → (∀ (a b c : α), a ⊓ b ⊓ c = a ⊓ (b ⊓ c)) → (∀ (a : α), a ⊓ a = a) → SemilatticeInf α",
  "name": "SemilatticeInf.mk'",
  "kind": "def",
  "doc_string":
  "A type with a commutative, associative and idempotent binary `inf` operation has the structure of a\nmeet-semilattice.\n\nThe partial order is defined so that `a ≤ b` unfolds to `b ⊓ a = a`; cf. `inf_eq_right`.\n",
  "args": ""},
 {"type": "{α : Type s} → ULift α → α",
  "name": "ULift.down",
  "kind": "def",
  "doc_string": "Extract a value from `ULift α` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : LinearOrderedCommSemiring α] → DecidableRel fun x x_1 => x < x_1",
  "name": "LinearOrderedCommSemiring.decidable_lt",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : HasSSubset α]\n  [inst_2 : IsNonstrictStrictOrder α (fun x x_1 => x ⊆ x_1) fun x x_1 => x ⊂ x_1] {a b : α}\n  [inst_3 : IsAntisymm α fun x x_1 => x ⊆ x_1], a ≠ b → a ⊆ b → a ⊂ b",
  "name": "Ne.ssubset_of_subset",
  "kind": "theorem",
  "doc_string": "**Alias** of `ssubset_of_ne_of_subset`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteDistribLattice α] (a : α) (s : Set α), (⨅ b, ⨅ h, a ⊔ b) ≤ a ⊔ infₛ s",
  "name": "CompleteDistribLattice.infᵢ_sup_le_sup_infₛ",
  "kind": "def",
  "doc_string":
  "In a completely distributive lattice, `⊔` distributes over `⨅`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : AddSemigroup M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [inst : AddMemClass A M] → (S : A) → AddSemigroup { x // x ∈ S }",
  "name": "AddMemClass.toAddSemigroup",
  "kind": "def",
  "doc_string":
  "An `AddSubsemigroup` of an `AddSemigroup` inherits an `AddSemigroup` structure.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "SubNegMonoid",
  "kind": "inductive",
  "doc_string":
  "A `SubNegMonoid` is an `AddMonoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : ∀ a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `∀ X, Sub (Foo X)` instance but no\n`∀ X, Neg (Foo X)`. Suppose we also have an instance\n`∀ X [Cromulent X], AddGroup (Foo X)`. Then the `(-)` coming from\n`AddGroup.sub` cannot be definitionally equal to the `(-)` coming from\n`Foo.Sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `AddMonoid` and Note [forgetful inheritance] for more\nexplanations on this.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {F : αᵐᵒᵖ → Sort v} → ((X : α) → F { unop := X }) → (X : αᵐᵒᵖ) → F X",
  "name": "MulOpposite.rec'",
  "kind": "def",
  "doc_string":
  "A recursor for `MulOpposite`. Use as `induction x using MulOpposite.rec'`. ",
  "args": ""},
 {"type": "{α : Type u} → α → List α",
  "name": "List.pure",
  "kind": "def",
  "doc_string": "`pure x = [x]` is the `pure` operation of the list monad. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), max a b = if a ≤ b then b else a",
  "name": "LinearOrderedSemiring.max_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `maxOfLe`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {r : α → α → Prop} → WellFounded r → (s : Set α) → Set.Bounded r s → α",
  "name": "WellFounded.sup",
  "kind": "def",
  "doc_string": "The supremum of a bounded, well-founded order ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Array.tacticArray_get_dec",
  "kind": "def",
  "doc_string":
  "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Zero M] → [inst_1 : Zero N] → ZeroHom M N → M → N",
  "name": "ZeroHom.toFun",
  "kind": "def",
  "doc_string": "The underlying function ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.scopedNS",
  "kind": "def",
  "doc_string":
  "`scoped[NS]` is similar to the `scoped` modifier on attributes and notations,\nbut it scopes the syntax in the specified namespace instead of the current namespace.\n```\nscoped[Matrix] infixl:75 \" ⬝ \" => Matrix.mul\n-- declares `⬝` as a notation for matrix multiplication\n-- which is only accessible if you `open Matrix` or `open scoped Matrix`.\n\nnamespace Nat\n\nscoped[Nat.Count] attribute [instance] CountSet.fintype\n-- make the definition Nat.CountSet.fintype an instance,\n-- but only if `Nat.Count` is open\n```\n",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₂] →\n      [inst_1 : Semigroup M₁] →\n        (f : M₁ → M₂) → Function.Surjective f → (∀ (x y : M₁), f (x * y) = f x * f y) → Semigroup M₂",
  "name": "Function.Surjective.semigroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `*` is a semigroup, if it admits a surjective map that preserves `*` from a\nsemigroup. See note [reducible non-instances]. ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : Semiring α] (a : α), a * 1 = a",
  "name": "Semiring.mul_one",
  "kind": "def",
  "doc_string": "One is a right neutral element for multiplication ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : OrderedAddCommMonoid α] → [inst_1 : OrderedAddCommMonoid β] → Add (α →+o β)",
  "name":
  "OrderAddMonoidHom.instAddOrderAddMonoidHomToPreorderToPartialOrderToPreorderToPartialOrderToAddZeroClassToAddMonoidToAddCommMonoidToAddZeroClassToAddMonoidToAddCommMonoid",
  "kind": "def",
  "doc_string":
  "For two ordered additive monoid morphisms `f` and `g`, their product is the ordered\nadditive monoid morphism sending `a` to `f a + g a`.",
  "args": ""},
 {"type": "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → ℕ",
  "name": "BinaryHeap.size",
  "kind": "def",
  "doc_string": "`O(1)`. Get the number of elements in a `BinaryHeap`. ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Monoid M] → Submonoid M",
  "name": "IsUnit.submonoid",
  "kind": "def",
  "doc_string": "The submonoid consisting of the units of a monoid ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b → a = b ∨ a < b",
  "name": "LE.le.eq_or_lt_dec",
  "kind": "theorem",
  "doc_string": "**Alias** of `Decidable.eq_or_lt_of_le`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (f : α ≃ β) → (s : β → β → Prop) → ↑f ⁻¹'o s ≃r s",
  "name": "RelIso.preimage",
  "kind": "def",
  "doc_string":
  "Any equivalence lifts to a relation isomorphism between `s` and its preimage. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "SlimCheck.Shrinkable",
  "kind": "inductive",
  "doc_string":
  "Given an example `x : α`, `Shrinkable α` gives us a way to shrink it\nand suggest simpler examples. ",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] (a : G₀), a * a⁻¹ * a = a",
  "name": "mul_inv_mul_self",
  "kind": "theorem",
  "doc_string":
  "Multiplying `a` by its inverse and then by itself results in `a`\n(whether or not `a` is zero). ",
  "args": ""},
 {"type": "{α : Type u_1} → [self : Dvd α] → α → α → Prop",
  "name": "Dvd.dvd",
  "kind": "def",
  "doc_string":
  "Divisibility. `a ∣ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Monoid M] → [inst_1 : Monoid N] → M ≃* N → Mˣ ≃* Nˣ",
  "name": "Units.mapEquiv",
  "kind": "def",
  "doc_string":
  "A multiplicative equivalence of monoids defines a multiplicative equivalence\nof their groups of units. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Abel.abelNFConv",
  "kind": "def",
  "doc_string":
  "Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_→r_»",
  "kind": "def",
  "doc_string":
  "A relation homomorphism with respect to a given pair of relations `r` and `s`\nis a function `f : α → β` such that `r a b → s (f a) (f b)`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Squash",
  "kind": "def",
  "doc_string":
  "`Squash α` is the quotient of `α` by the always true relation.\nIt is empty if `α` is empty, otherwise it is a singleton.\n(Thus it is unconditionally a `Subsingleton`.)\nIt is the \"universal `Subsingleton`\" mapped from `α`.\n\nIt is similar to `Nonempty α`, which has the same properties, but unlike\n`Nonempty` this is a `Type u`, that is, it is \"data\", and the compiler\nrepresents an element of `Squash α` the same as `α` itself\n(as compared to `Nonempty α`, whose elements are represented by a dummy value).\n\n`Squash.lift` will extract a value in any subsingleton `β` from a function on `α`,\nwhile `Nonempty.rec` can only do the same when `β` is a proposition.\n",
  "args": ""},
 {"type": "Mathlib.Meta.NormNum.NormNumExt",
  "name": "Mathlib.Meta.NormNum.evalNeg",
  "kind": "def",
  "doc_string":
  "The `norm_num` extension which identifies expressions of the form `-a`,\nsuch that `norm_num` successfully recognises `a`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : HasSup α] →\n      [inst_1 : HasInf α] →\n        [inst_2 : SupSet α] →\n          [inst_3 : InfSet α] →\n            [inst_4 : Top α] →\n              [inst_5 : Bot α] →\n                [inst_6 : Order.Frame β] →\n                  (f : α → β) →\n                    Function.Injective f →\n                      (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) →\n                        (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) →\n                          (∀ (s : Set α), f (supₛ s) = ⨆ a, ⨆ h, f a) →\n                            (∀ (s : Set α), f (infₛ s) = ⨅ a, ⨅ h, f a) → f ⊤ = ⊤ → f ⊥ = ⊥ → Order.Frame α",
  "name": "Function.Injective.frame",
  "kind": "def",
  "doc_string": "Pullback an `Order.Frame` along an injection. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosReflectLT α],\n  b * a < c * a → 0 ≤ a → b < c",
  "name": "lt_of_mul_lt_mul_of_nonneg_right",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_mul_lt_mul_right`.",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : Add M] → [inst_1 : Add N] → AddHom (M × N) N",
  "name": "AddHom.snd",
  "kind": "def",
  "doc_string":
  "Given additive magmas `A`, `B`, the natural projection homomorphism\nfrom `A × B` to `B`",
  "args": ""},
 {"type": "{α : Type u} → α → List α → List α",
  "name": "List.intersperse",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `intersperse sep l` alternates `sep` and the elements of `l`:\n* `intersperse sep [] = []`\n* `intersperse sep [a] = [a]`\n* `intersperse sep [a, b] = [a, sep, b]`\n* `intersperse sep [a, b, c] = [a, sep, b, sep, c]`\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {s : Set α} → {t : Set β} → (f : α → β) → Set.BijOn f s t → ↑s ≃ ↑t",
  "name": "Set.BijOn.equiv",
  "kind": "def",
  "doc_string":
  "If a function is a bijection between two sets `s` and `t`, then it induces an\nequivalence between the types `↥s` and `↥t`. ",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : Group G] → G → G ≃ G",
  "name": "Equiv.divRight",
  "kind": "def",
  "doc_string":
  "A version of `Equiv.mulRight a⁻¹ b` that is defeq to `b / a`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : LE α] → [inst : BoundedOrder α] → Prop",
  "name": "IsSimpleOrder",
  "kind": "inductive",
  "doc_string":
  "An order is simple iff it has exactly two elements, `⊥` and `⊤`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, 0 ≤ a → 0 < b → 0 < a + b",
  "name": "Left.add_pos_of_nonneg_of_pos",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_pos_of_nonneg_of_pos`.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Neg α] → [inst : HasSup α] → Abs α",
  "name": "Neg.toHasAbs",
  "kind": "def",
  "doc_string": "`abs a` is the absolute value of `a`",
  "args": ""},
 {"type":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : DecidableEq ι] [inst_1 : (i : ι) → LinearOrder (α i)]\n  (x y z : (i : ι) → α i),\n  (Set.Icc x z \\ Set.pi Set.univ fun i => Set.Ioc (y i) (z i)) ⊆\n    Set.unionᵢ fun i => Set.Icc x (Function.update z i (y i))",
  "name": "Set.Icc_diff_pi_univ_Ioc_subset",
  "kind": "theorem",
  "doc_string":
  "If `x`, `y`, `z` are functions `Π i : ι, α i`, then\nthe set difference between the box `[x, z]` and the product of the intervals `(y i, z i]`\nis covered by the union of the boxes `[x, update z i (y i)]`.\n\nE.g., if `x = y`, then this lemma states that the difference between a closed box\n`[x, y]` and the product of half-open intervals `{z | ∀ i, x i < z i ≤ y i}` is covered by the union\nof the faces of `[x, y]` adjacent to `x`. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.Expr → Ordering",
  "name": "Linarith.Expr.compare",
  "kind": "def",
  "doc_string": "Ordering on `Expr`. ",
  "args": ""},
 {"type": "Sort u_1 → Prop",
  "name": "Finite",
  "kind": "inductive",
  "doc_string":
  "A type is `Finite` if it is in bijective correspondence to some\n`Fin n`.\n\nWhile this could be defined as `NonEmpty (Fintype α)`, it is defined\nin this way to allow there to be `Finite` instances for propositions.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} {r : α → α → Prop} [self : IsWellFounded α r], WellFounded r",
  "name": "IsWellFounded.wf",
  "kind": "def",
  "doc_string": "The relation is `WellFounded`, as a proposition. ",
  "args": ""},
 {"type": "{R : Type u} → [self : EuclideanDomain R] → R → R → Prop",
  "name": "EuclideanDomain.r",
  "kind": "def",
  "doc_string":
  "A well-founded relation on `R`, satisfying `r (a % b) b`.\nThis ensures that the GCD algorithm always terminates. ",
  "args": ""},
 {"type": "Lean.Expr → List Lean.Expr",
  "name": "Linarith.getNatComparisons",
  "kind": "opaque",
  "doc_string":
  "`getNatComparisons e` returns a list of all subexpressions of `e` of the form `((t : ℕ) : ℤ)`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1],\n  StrictMono f → Monotone g → StrictMono fun x => f x * g x",
  "name": "StrictMono.mul_monotone'",
  "kind": "theorem",
  "doc_string":
  "The product of a strictly monotone function and a monotone function is strictly monotone. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {s t : Set α}, BddBelow s → BddBelow (s ∩ t)",
  "name": "BddBelow.inter_of_left",
  "kind": "theorem",
  "doc_string": "If `s` is bounded, then so is `s ∩ t` ",
  "args": ""},
 {"type": "ℕ → ℕ × ℕ",
  "name": "Nat.unpair",
  "kind": "def",
  "doc_string": "Unpairing function for the natural numbers. ",
  "args": ""},
 {"type":
  "(α : Type u_1) →\n  (β : Type u_2) → (γ : Type u_3) → [inst : LE α] → [inst_1 : LE β] → [inst_2 : LE γ] → (α ⊕ β) ⊕ γ ≃o α ⊕ β ⊕ γ",
  "name": "OrderIso.sumAssoc",
  "kind": "def",
  "doc_string": "`Equiv.sumAssoc` promoted to an order isomorphism. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  1 ≤ a → 1 ≤ b → 1 ≤ a * b",
  "name": "Right.one_le_mul",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_le_mul`. ",
  "args": ""},
 {"type": "{α : Type u} → (α → Bool) → List α → List α",
  "name": "List.dropWhile",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `dropWhile p l` removes elements from the list until it finds the first element\nfor which `p` returns false; this element and everything after it is returned.\n```\ndropWhile (· < 4) [1, 3, 2, 4, 2, 7, 4] = [4, 2, 7, 4]\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : Semifield α] (n : ℕ) (a : α),\n  Semifield.zpow (Int.ofNat (Nat.succ n)) a = a * Semifield.zpow (Int.ofNat n) a",
  "name": "Semifield.zpow_succ'",
  "kind": "def",
  "doc_string": "`a ^ (n + 1) = a * a ^ n` ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} → [inst : Mul R] → [inst_1 : Mul S] → [inst_2 : Add R] → [inst_3 : Add S] → R ≃+* S → R ≃+ S",
  "name": "RingEquiv.toAddEquiv",
  "kind": "def",
  "doc_string":
  "The equivalence of additive monoids underlying an equivalence of (semi)rings. ",
  "args": ""},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [self : MonadStateOf σ m] → m σ",
  "name": "MonadStateOf.get",
  "kind": "def",
  "doc_string": "`(← get) : σ` gets the state out of a monad `m`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → {r : α → α → Prop} → {s : β → β → Prop} → {t : γ → γ → Prop} → s →r t → r →r s → r →r t",
  "name": "RelHom.comp",
  "kind": "def",
  "doc_string":
  "Composition of two relation homomorphisms is a relation homomorphism. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.tacticSwap",
  "kind": "def",
  "doc_string":
  "`swap` is a shortcut for `pick_goal 2`, which interchanges the 1st and 2nd goals. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → α → α ⊕ β",
  "name": "Sum.inl",
  "kind": "def",
  "doc_string":
  "Left injection into the sum type `α ⊕ β`. If `a : α` then `.inl a : α ⊕ β`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«prec(_)»",
  "kind": "def",
  "doc_string": "Parentheses are used for grouping precedence expressions. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] {a b : α} [inst_1 : IsAntisymm α fun x x_1 => x ⊆ x_1], a ⊆ b → b ⊆ a → a = b",
  "name": "HasSubset.Subset.antisymm",
  "kind": "theorem",
  "doc_string": "**Alias** of `subset_antisymm`.",
  "args": ""},
 {"type": "{α : Type u} → [inst : Preorder α] → Set α → α → Prop",
  "name": "IsGLB",
  "kind": "def",
  "doc_string":
  "`a` is a greatest lower bound of a set `s`; for a partial order, it is unique if exists. ",
  "args": ""},
 {"type":
  "{α : Type u} → {α' : Type w} → {β : Type v} → {β' : Type x} → (α → α') → (β → β') → α ⊕ β → α' ⊕ β'",
  "name": "Sum.map",
  "kind": "def",
  "doc_string":
  "Map `α ⊕ β` to `α' ⊕ β'` sending `α` to `α'` and `β` to `β'`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → α → Set α",
  "name": "Set.Ici",
  "kind": "def",
  "doc_string": "Left-closed right-infinite interval ",
  "args": ""},
 {"type":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : Quot r → Sort v} →\n      (q : Quot r) →\n        (f : (a : α) → motive (Quot.mk r a)) →\n          (∀ (a b : α) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b) → motive q",
  "name": "Quot.recOn",
  "kind": "def",
  "doc_string":
  "Dependent recursion principle for `Quot`. This constructor can be tricky to use,\nso you should consider the simpler versions if they apply:\n* `Quot.lift`, for nondependent functions\n* `Quot.ind`, for theorems / proofs of propositions about quotients\n* `Quot.recOnSubsingleton`, when the target type is a `Subsingleton`\n* `Quot.hrecOn`, which uses `HEq (f a) (f b)` instead of a `sound p ▸ f a = f b` assummption\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : PartialOrder α] [inst_1 : PartialOrder β] {u : β → α} (l : LowerAdjoint u),\n  LowerAdjoint.closed l = Set.range (u ∘ l.toFun)",
  "name": "LowerAdjoint.closed_eq_range_close",
  "kind": "theorem",
  "doc_string": "The set of closed elements for `l` is the range of `u ∘ l`. ",
  "args": ""},
 {"type":
  "∀ (α : Type u_1) [inst : CancelMonoidWithZero α] [inst_1 : Nontrivial α], FaithfulSMul αᵐᵒᵖ α",
  "name": "CancelMonoidWithZero.toFaithfulSMul_opposite",
  "kind": "def",
  "doc_string":
  "`Monoid.toOppositeMulAction` is faithful on nontrivial cancellative monoids with zero. ",
  "args": ""},
 {"type": "{α : Sort u_1} → α → α → Prop",
  "name": "Eq",
  "kind": "inductive",
  "doc_string":
  "The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
  "args": ""},
 {"type":
  "{A : Type u₁} →\n  [inst : CategoryTheory.Category A] → {B : Type u₂} → [inst_1 : CategoryTheory.Category B] → (F : A ⥤ B) → F ⋙ 𝟭 B ≅ F",
  "name": "CategoryTheory.Functor.rightUnitor",
  "kind": "def",
  "doc_string": "The right unitor, a natural isomorphism `(F ⋙ (𝟭 B)) ≅ F`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  AntitoneOn f s → AntitoneOn g s → AntitoneOn (fun x => f x + g x) s",
  "name": "AntitoneOn.add",
  "kind": "theorem",
  "doc_string": "The sum of two antitone functions is antitone.",
  "args": ""},
 {"type": "Dvd ℤ",
  "name": "Int.instDvdInt",
  "kind": "def",
  "doc_string":
  "Divisibility of integers. `a ∣ b` (typed as `\\|`) says that\nthere is some `c` such that `b = a * c`.\n",
  "args": ""},
 {"type":
  "∀ {F : Type u_3} {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : MulOneClass H] [inst_2 : MonoidHomClass F G H]\n  (f : F), Function.Injective ↑f ↔ ∀ (a : G), ↑f a = 1 ↔ a = 1",
  "name": "injective_iff_map_eq_one'",
  "kind": "theorem",
  "doc_string":
  "A homomorphism from a group to a monoid is injective iff its kernel is trivial,\nstated as an iff on the triviality of the kernel.\nFor the implication, see `injective_iff_map_eq_one`. ",
  "args": ""},
 {"type": "∀ {α : Type u_1}, FaithfulSMul (Function.End α) α",
  "name": "Function.End.apply_FaithfulSMul",
  "kind": "def",
  "doc_string": "`Function.End.applyMulAction` is faithful. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : MulOneClass M] → (S : Submonoid M) → { x // x ∈ S } →* M",
  "name": "Submonoid.subtype",
  "kind": "def",
  "doc_string":
  "The natural monoid hom from a submonoid of monoid `M` to `M`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Choose.tacticChoose!__Using_",
  "kind": "def",
  "doc_string":
  "* `choose a b h h' using hyp` takes a hypothesis `hyp` of the form\n  `∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b ∧ Q x y a b`\n  for some `P Q : X → Y → A → B → Prop` and outputs\n  into context a function `a : X → Y → A`, `b : X → Y → B` and two assumptions:\n  `h : ∀ (x : X) (y : Y), P x y (a x y) (b x y)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x y) (b x y)`. It also works with dependent versions.\n\n* `choose! a b h h' using hyp` does the same, except that it will remove dependency of\n  the functions on propositional arguments if possible. For example if `Y` is a proposition\n  and `A` and `B` are nonempty in the above example then we will instead get\n  `a : X → A`, `b : X → B`, and the assumptions\n  `h : ∀ (x : X) (y : Y), P x y (a x) (b x)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x) (b x)`.\n\nThe `using hyp` part can be ommited,\nwhich will effectively cause `choose` to start with an `intro hyp`.\n\nExamples:\n\n```\nexample (h : ∀ n m : ℕ, ∃ i j, m = n + i ∨ m + j = n) : True := by\n  choose i j h using h\n  guard_hyp i : ℕ → ℕ → ℕ\n  guard_hyp j : ℕ → ℕ → ℕ\n  guard_hyp h : ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n\n  trivial\n```\n\n```\nexample (h : ∀ i : ℕ, i < 7 → ∃ j, i < j ∧ j < i+i) : True := by\n  choose! f h h' using h\n  guard_hyp f : ℕ → ℕ\n  guard_hyp h : ∀ (i : ℕ), i < 7 → i < f i\n  guard_hyp h' : ∀ (i : ℕ), i < 7 → f i < i + i\n  trivial\n```\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : LinearOrder α] → [inst_1 : Preorder β] → (f : α → β) → StrictMono f → α ↪o β",
  "name": "OrderEmbedding.ofStrictMono",
  "kind": "def",
  "doc_string":
  "A strictly monotone map from a linear order is an order embedding. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {G : Type u_2} → [inst : MulOneClass M] → [inst_1 : CommGroup G] → Div (M →* G)",
  "name":
  "MonoidHom.instDivMonoidHomToMulOneClassToMonoidToDivInvMonoidToGroup",
  "kind": "def",
  "doc_string":
  "If `f` and `g` are monoid homomorphisms to a commutative group, then `f / g` is the homomorphism\nsending `x` to `(f x) / (g x)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddMonoid α] (m : α), Even m → ∃ c, m = 2 • c",
  "name": "Even.exists_two_nsmul",
  "kind": "theorem",
  "doc_string":
  "Alias of the forwards direction of\n`even_iff_exists_two_nsmul`.",
  "args": ""},
 {"type": "{p : Prop} → p → Decidable p",
  "name": "Decidable.isTrue",
  "kind": "def",
  "doc_string": "Prove that `p` is decidable by supplying a proof of `p` ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddLeftCancelSemigroup",
  "kind": "inductive",
  "doc_string":
  "An `AddLeftCancelSemigroup` is an additive semigroup such that\n`a + b = a + c` implies `b = c`. ",
  "args": ""},
 {"type": "{α : Type u_1} → α → List α → List α",
  "name": "List.intersperseTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `intersperse`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : MulOneClass M] → (S : Submonoid M) → (s : Set M) → s = ↑S → Submonoid M",
  "name": "Submonoid.copy",
  "kind": "def",
  "doc_string":
  "Copy a submonoid replacing `carrier` with a set that is equal to it. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  StrictMono f → StrictMono (WithTop.map f)",
  "name": "StrictMono.withTop_map",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `WithTop.strictMono_map_iff`.",
  "args": ""},
 {"type": "{α : Type u_1} → {n : ℕ} → (Fin n → α) → Array α",
  "name": "Array.ofFn",
  "kind": "def",
  "doc_string":
  "`ofFn f` with `f : Fin n → α` returns the list whose ith element is `f i`.\n```\nofFn f = #[f 0, f 1, ... , f(n - 1)]\n``` ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Add α] → α → Prop",
  "name": "Even",
  "kind": "def",
  "doc_string":
  "An element `a` of a type `α` with addition satisfies `Even a` if `a = r + r`,\nfor some `r : α`.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulZeroOneClass M] [inst_1 : MulZeroOneClass N] {f g : M →*₀ N},\n  f = g → ∀ (x : M), ↑f x = ↑g x",
  "name": "MonoidWithZeroHom.congr_fun",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.congr_fun` instead. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.splitIfs",
  "kind": "def",
  "doc_string":
  "Splits all if-then-else-expressions into multiple goals.\nGiven a goal of the form `g (if p then x else y)`, `split_ifs` will produce\ntwo goals: `p ⊢ g x` and `¬p ⊢ g y`.\nIf there are multiple ite-expressions, then `split_ifs` will split them all,\nstarting with a top-most one whose condition does not contain another\nite-expression.\n`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.\n`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.\n",
  "args": ""},
 {"type": "{α : Type u} → [inst : BEq α] → List α → List α → Bool",
  "name": "List.isSuffixOf",
  "kind": "def",
  "doc_string":
  "`isSuffixOf l₁ l₂` returns `true` Iff `l₁` is a suffix of `l₂`.\nThat is, there exists a `t` such that `l₂ == t ++ l₁`. ",
  "args": ""},
 {"type": "{α : Type u} → {n : ℕ} → (i : ℕ) → Vector α n → Vector α (min i n)",
  "name": "Vector.take",
  "kind": "def",
  "doc_string":
  "Take `i` elements from a vector of length `n`; we can have `i > n`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1],\n  StrictMono f → StrictMono g → StrictMono fun x => f x * g x",
  "name": "StrictMono.mul'",
  "kind": "theorem",
  "doc_string":
  "The product of two strictly monotone functions is strictly monotone. ",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrderedRing α] → DecidableRel fun x x_1 => x < x_1",
  "name": "LinearOrderedRing.decidable_lt",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "Lean.Name → Array ProjectionRule → Lean.CoreM (Array ParsedProjectionData)",
  "name": "simpsApplyProjectionRules",
  "kind": "def",
  "doc_string":
  "Auxilliary function for `simpsGetRawProjections` that executes the projection renaming.\n\nFigure out projections, including renamings. The information for a projection is (before we\nfigure out the `expr` of the projection):\n`(original name, given name, is default, is prefix)`.\nThe first projections are always the actual projections of the structure, but `rules` could\nspecify custom projections that are compositions of multiple projections. ",
  "args": ""},
 {"type": "{p : Prop} → p → Unique p",
  "name": "uniqueProp",
  "kind": "def",
  "doc_string":
  "Every provable proposition is unique, as all proofs are equal. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} {F : Type u_3} {x : MulOneClass M} {x_1 : MulOneClass N} [inst : MonoidHomClass F M N]\n  (f : F) {x_2 : M}, (∃ y, x_2 * y = 1) → ∃ y, ↑f x_2 * y = 1",
  "name": "MonoidHom.map_exists_right_inv",
  "kind": "theorem",
  "doc_string":
  "Given a monoid homomorphism `f : M →* N` and an element `x : M`, if `x` has a right inverse,\nthen `f x` has a right inverse too. For elements invertible on both sides see `IsUnit.map`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (r : α → α → Prop) → [inst : IsPreorder α r] → Setoid α",
  "name": "AntisymmRel.setoid",
  "kind": "def",
  "doc_string": "The antisymmetrization relation as an equivalence relation. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "name": "CategoryTheory.categorySimp",
  "kind": "def",
  "doc_string": "Simplify an expression using only the axioms of a category. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_≺i_»",
  "kind": "def",
  "doc_string":
  "If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≺i s` is an order\nembedding whose range is an open interval `(-∞, top)` for some element `top` of `β`. Such order\nembeddings are called principal segments ",
  "args": ""},
 {"type":
  "{C : ℕ → Sort u} → C 0 → ((b : Bool) → (n : ℕ) → C n → C (Nat.bit b n)) → (n : ℕ) → C n",
  "name": "Nat.binaryRec",
  "kind": "def",
  "doc_string":
  "A recursion principle for `bit` representations of natural numbers.\nFor a predicate `C : Nat → Sort _`, if instances can be\nconstructed for natural numbers of the form `bit b n`,\nthey can be constructed for all natural numbers. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, 1 < a → 1 ≤ b → 1 < a * b",
  "name": "Left.one_lt_mul_of_lt_of_le",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul_of_lt_of_le`. ",
  "args": ""},
 {"type": "Array Lean.Term → Mathlib.Tactic.Polyrith.Poly → Lean.Term",
  "name": "Mathlib.Tactic.Polyrith.Poly.toSyntax",
  "kind": "def",
  "doc_string":
  "Converts a `Poly` expression into a `Syntax` suitable as an input to `linear_combination`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → [self : Function.HasUncurry α β γ] → α → β → γ",
  "name": "Function.HasUncurry.uncurry",
  "kind": "def",
  "doc_string":
  "Uncurrying operator. The most generic use is to recursively uncurry. For instance\n`f : α → β → γ → δ` will be turned into `↿f : α × β × γ → δ`. One can also add instances\nfor bundled maps.",
  "args": ""},
 {"type":
  "{V : Type u} → [inst : Quiver V] → [self : Quiver.Arborescence V] → V",
  "name": "Quiver.Arborescence.root",
  "kind": "def",
  "doc_string": "The root of the arborescence. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    [sa : Setoid α] →\n      [sb : Setoid β] →\n        {γ : Sort u_3} →\n          [sc : Setoid γ] →\n            (f : α → β → γ) →\n              Relator.LiftFun (fun x x_1 => x ≈ x_1) ((fun x x_1 => x ≈ x_1) ⇒ fun x x_1 => x ≈ x_1) f f →\n                Quotient sa → Quotient sb → Quotient sc",
  "name": "Quotient.map₂",
  "kind": "def",
  "doc_string":
  "Map a function `f : α → β → γ` that sends equivalent elements to equivalent elements\nto a function `f : Quotient sa → Quotient sb → Quotient sc`.\nUseful to define binary operations on quotients. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : SuccOrder α] [inst_2 : Preorder β] {f : α → β},\n  Monotone f → Pairwise (Disjoint on fun n => Set.Ico (f n) (f (Order.succ n)))",
  "name": "Monotone.pairwise_disjoint_on_Ico_succ",
  "kind": "theorem",
  "doc_string":
  "If `α` is a linear succ order, `β` is a preorder, and `f : α → β` is a monotone function, then\nthe intervals `Set.Ico (f n) (f (Order.succ n))` are pairwise disjoint. ",
  "args": ""},
 {"type": "{α : Type u} → {s t : Set α} → s = t → ↑s ≃ ↑t",
  "name": "Equiv.Set.ofEq",
  "kind": "def",
  "doc_string":
  "Equal sets are equivalent.\n\nTODO: this is the same as `Equiv.setCongr`! ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Group α] → (WithZero α)ˣ ≃* α",
  "name": "WithZero.unitsWithZeroEquiv",
  "kind": "def",
  "doc_string":
  "Any group is isomorphic to the units of itself adjoined with `0`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : CanonicallyOrderedCommSemiring α] → ℕ → α → α",
  "name": "CanonicallyOrderedCommSemiring.npow",
  "kind": "def",
  "doc_string": "Raising to the power of a natural number. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.RingNF.ringNF",
  "kind": "def",
  "doc_string":
  "Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `ring_nf at h` can be used to rewrite in a hypothesis.\n",
  "args": ""},
 {"type": "Sub ℕ+",
  "name": "PNat.instSubPNat",
  "kind": "def",
  "doc_string":
  "Subtraction a - b is defined in the obvious way when\na > b, and by a - b = 1 if a ≤ b.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, 0 < a - b → b < a",
  "name": "lt_of_sub_pos",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `sub_pos`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : LinearOrderedCommGroupWithZero α] → {a : α} → a ≠ 0 → α ≃o α",
  "name": "OrderIso.mulRight₀'",
  "kind": "def",
  "doc_string":
  "`Equiv.mulRight₀` as an `OrderIso` on a `LinearOrderedCommGroupWithZero.`.\n\nNote that `OrderIso.mulRight₀` refers to the `LinearOrderedField` version. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s t : Set α},\n  BddAbove s → Set.Nonempty s → BddAbove t → Set.Nonempty t → supₛ (s ∪ t) = supₛ s ⊔ supₛ t",
  "name": "csupₛ_union",
  "kind": "theorem",
  "doc_string":
  "The `supₛ` of a union of two sets is the max of the suprema of each subset, under the\nassumptions that all sets are bounded above and nonempty.",
  "args": ""},
 {"type": "Lean.Name → Lean.Name",
  "name": "Mathlib.Tactic.Abel.add_g",
  "kind": "def",
  "doc_string":
  "Add the letter \"g\" to the end of the name, e.g. turning `term` into `termg`.\n\nThis is used to choose between declarations taking `AddCommMonoid` and those\ntaking `AddCommGroup` instances.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α}, a < b⁻¹ → b < a⁻¹",
  "name": "lt_inv_of_lt_inv",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `lt_inv'`.",
  "args": ""},
 {"type":
  "{α : Type} → Lean.Meta.TransparencyMode → Mathlib.Tactic.Ring.RingM α → Lean.MetaM α",
  "name": "Mathlib.Tactic.Ring.RingM.run",
  "kind": "def",
  "doc_string": "Run a computation in the `RingM` monad. ",
  "args": ""},
 {"type": "{V : Type u} → [inst : Quiver V] → Quiver.Total V → V",
  "name": "Quiver.Total.right",
  "kind": "def",
  "doc_string": "the target vertex of an arrow ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a : α}, a⁻¹ ≤ 1 ↔ 1 ≤ a",
  "name": "Left.inv_le_one_iff",
  "kind": "theorem",
  "doc_string": "Uses `left` co(ntra)variant. ",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Subsingleton α] {s : Set α}, Subsingleton ↑s",
  "name": "Set.subsingleton_coe_of_subsingleton",
  "kind": "def",
  "doc_string":
  "The `coe_sort` of a set `s` in a subsingleton type is a subsingleton.\nFor the corresponding result for `subtype`, see `subtype.subsingleton`. ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsPartialOrder",
  "kind": "inductive",
  "doc_string":
  "`IsPartialOrder X r` means that the binary relation `r` on `X` is a partial order, that is,\n`IsPreorder X r` and `IsAntisymm X r`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Antitone f → ∀ {s : Set α}, BddAbove s → BddBelow (f '' s)",
  "name": "Antitone.map_bddAbove",
  "kind": "theorem",
  "doc_string":
  "The image under an antitone function of a set which is bounded above is bounded below. ",
  "args": ""},
 {"type": "∀ (G : Type u) [inst : AddLeftCancelSemigroup G], IsLeftCancelAdd G",
  "name": "AddLeftCancelSemigroup.toIsLeftCancelAdd",
  "kind": "def",
  "doc_string": "Any `AddLeftCancelSemigroup` satisfies\n`IsLeftCancelAdd`.",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → {sα : Q(CommSemiring «$α»)} → Mathlib.Tactic.Ring.ExSum sα q(0)",
  "name": "Mathlib.Tactic.Ring.ExSum.zero",
  "kind": "def",
  "doc_string": "Zero is a polynomial. `e` is the expression `0`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α}, a⁻¹ < b⁻¹ → b < a",
  "name": "lt_of_inv_lt_inv",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `inv_lt_inv_iff`.",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«stx_*»",
  "kind": "def",
  "doc_string":
  "`p*` is shorthand for `many(p)`. It uses parser `p` 0 or more times, and produces a\n`nullNode` containing the array of parsed results. This parser has arity 1.\n\nIf `p` has arity more than 1, it is auto-grouped in the items generated by the parser.\n",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Dvd",
  "kind": "inductive",
  "doc_string":
  "Notation typeclass for the `∣` operation (typed as `\\|`), which represents divisibility. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "name": "MulPosMonoRev",
  "kind": "def",
  "doc_string":
  "`MulPosMonoRev α` is an abbreviation for `ContravariantClas α>0 α (λ x y, y * x) (≤)`,\nexpressing that multiplication by positive elements on the right is reverse monotone. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : CommRing R] (a b : R), a ^ 2 - b ^ 2 = (a + b) * (a - b)",
  "name": "pow_two_sub_pow_two",
  "kind": "theorem",
  "doc_string": "**Alias** of `sq_sub_sq`.",
  "args": ""},
 {"type": "∀ {α : Sort u_1}, IsEmpty { _a // False }",
  "name": "Subtype.isEmpty_false",
  "kind": "def",
  "doc_string": "subtypes by false are false. ",
  "args": ""},
 {"type":
  "Lean.Syntax → Lean.Elab.TermElabM Mathlib.Tactic.LinearCombination.Config",
  "name": "Mathlib.Tactic.LinearCombination.elabConfig",
  "kind": "def",
  "doc_string": "Function elaborating `LinearCombination.Config` ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₂] →\n      [inst_1 : Zero M₂] →\n        [inst_2 : SMul ℕ M₂] →\n          [inst_3 : AddMonoid M₁] →\n            (f : M₁ → M₂) →\n              Function.Surjective f →\n                f 0 = 0 →\n                  (∀ (x y : M₁), f (x + y) = f x + f y) → (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) → AddMonoid M₂",
  "name": "Function.Surjective.addMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `0` and `+` is an additive monoid, if it admits a\nsurjective map that preserves `0` and `+` to an additive monoid. This version takes a custom `nsmul`\nas a `[SMul ℕ M₂]` argument.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  Monotone f → Monotone g → Monotone fun x => f x + g x",
  "name": "Monotone.add",
  "kind": "theorem",
  "doc_string": "The sum of two monotone functions is monotone.",
  "args": ""},
 {"type": "Lean.Expr → Lean.Meta.SimpM (Option Lean.Expr)",
  "name": "Tactic.NormCast.prove",
  "kind": "def",
  "doc_string":
  "Discharging function used during simplification in the \"squash\" step.\n\nTODO: normCast takes a list of expressions to use as lemmas for the discharger\nTODO: a tactic to print the results the discharger fails to proove\n",
  "args": ""},
 {"type":
  "(p : Prop) →\n  optParam SlimCheck.Configuration\n      { numInst := 100, maxSize := 100, numRetries := 10, traceDiscarded := false, traceSuccesses := false,\n        traceShrink := false, traceShrinkCandidates := false, randomSeed := none, quiet := false } →\n    (p' : autoParam (SlimCheck.Decorations.DecorationsOf p) _auto✝) → [inst : SlimCheck.Testable p'] → IO PUnit",
  "name": "SlimCheck.Testable.check",
  "kind": "def",
  "doc_string":
  "Run a test suite for `p` and throw an exception if `p` does not not hold.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] → [inst_1 : Preorder β] → [inst_2 : AddZeroClass α] → [inst_3 : AddZeroClass β] → Zero (α →+o β)",
  "name": "OrderAddMonoidHom.instZeroOrderAddMonoidHom",
  "kind": "def",
  "doc_string": "`0` is the homomorphism sending all elements to `0`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → (α → Bool) → List α → List α → Array α → Option α × List α",
  "name": "List.extractP.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `extractP`:\n`extractP.go p l xs acc = (some a, acc.toList ++ out)` if `extractP p xs = (some a, out)`,\nand `extractP.go p l xs acc = (none, l)` if `extractP p xs = (none, _)`. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Tauto.Config",
  "kind": "inductive",
  "doc_string":
  "Config for the `tauto` tactic. Currently empty. TODO: add `closer` option. ",
  "args": ""},
 {"type":
  "Lean.Meta.Simp.Context → optParam Bool true → Lean.Meta.Simp.Methods",
  "name": "Mathlib.Meta.NormNum.methods",
  "kind": "opaque",
  "doc_string": "A `Methods` implementation which calls `norm_num`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : AddZeroClass M] →\n    {N : Type u_2} →\n      {S : Type u_3} →\n        [inst_1 : AddZeroClass N] →\n          [inst_2 : SetLike S M] → [inst_3 : AddSubmonoidClass S M] → (M →+ N) → (s : S) → { x // x ∈ s } →+ N",
  "name": "AddMonoidHom.restrict",
  "kind": "def",
  "doc_string":
  "Restriction of an `AddMonoid` hom to an `AddSubmonoid` of the domain.",
  "args": ""},
 {"type": "∀ {G : Type u} [self : CommGroup G] (a b : G), a * b = b * a",
  "name": "CommGroup.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : BooleanAlgebra α] (x : α), x ⊓ xᶜ ≤ ⊥",
  "name": "BooleanAlgebra.inf_compl_le_bot",
  "kind": "def",
  "doc_string": "The infimum of `x` and `xᶜ` is at most `⊥` ",
  "args": ""},
 {"type": "{α : Type u} → {n : ℕ} → Vector α n → Fin n → α",
  "name": "Vector.nth",
  "kind": "def",
  "doc_string": "nth element of a vector, indexed by a `Fin` type. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Nontrivial α] {f : α → β}, Function.Injective f → Nontrivial β",
  "name": "Function.Injective.nontrivial",
  "kind": "theorem",
  "doc_string":
  "Pushforward a `nontrivial` instance along an injective function. ",
  "args": ""},
 {"type": "Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Tactic.Tauto.distribNot",
  "kind": "def",
  "doc_string":
  "Tries to apply de-Morgan-like rules on all hypotheses.\nAlways succeeds, regardless of whether any progress was actually made.\n",
  "args": ""},
 {"type":
  "∀ {K : Type u} [self : DivisionRing K] (n : ℕ) (a : K),\n  DivisionRing.zpow (Int.ofNat (Nat.succ n)) a = a * DivisionRing.zpow (Int.ofNat n) a",
  "name": "DivisionRing.zpow_succ'",
  "kind": "def",
  "doc_string": "`a ^ (n + 1) = a * a ^ n` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → [inst : AddMonoid M] → [inst_1 : AddMonoid N] → AddUnits (M × N) ≃+ AddUnits M × AddUnits N",
  "name": "AddEquiv.prodAddUnits",
  "kind": "def",
  "doc_string":
  "The additive monoid equivalence between additive units of a product\nof two additive monoids, and the product of the additive units of each additive monoid.",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HOr α β γ] → α → β → γ",
  "name": "HOr.hOr",
  "kind": "def",
  "doc_string":
  "`a ||| b` computes the bitwise OR of `a` and `b`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type": "(M : Type u_1) → (α : Type u_2) → [inst : SMul M α] → Prop",
  "name": "MulAction.IsPretransitive",
  "kind": "inductive",
  "doc_string":
  "`M` acts pretransitively on `α` if for any `x y` there is `g` such that `g • x = y`.\nA transitive action should furthermore have `α` nonempty. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {M : Type u_3} →\n      [inst : AddMonoid R] →\n        [inst_1 : AddAction R M] →\n          [inst_2 : AddMonoid S] →\n            [inst_3 : VAdd S M] →\n              (f : R →+ S) → Function.Surjective ↑f → (∀ (c : R) (x : M), ↑f c +ᵥ x = c +ᵥ x) → AddAction S M",
  "name": "Function.Surjective.addActionLeft",
  "kind": "def",
  "doc_string":
  "Push forward the action of `R` on `M` along a compatible\nsurjective map `f : R →+ S`.",
  "args": ""},
 {"type": "Num → ℕ",
  "name": "Num.natSize",
  "kind": "def",
  "doc_string":
  "The number of bits required to represent a `Num`, as a `Nat`. `size 0` is defined to be `0`. ",
  "args": ""},
 {"type": "ℕ → Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "ToAdditive.etaExpandN",
  "kind": "def",
  "doc_string": "Eta expands `e` at most `n` times.",
  "args": ""},
 {"type": "Linarith.PComp → Linarith.PComp → ℕ → Option Linarith.PComp",
  "name": "Linarith.pelimVar",
  "kind": "def",
  "doc_string":
  "`pelimVar p1 p2` calls `elimVar` on the `Comp` components of `p1` and `p2`.\nIf this returns `v1` and `v2`, it creates a new `PComp` equal to `v1*p1 + v2*p2`,\nand tracks this in the `CompSource`.\n",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  {D : Type u₂} →\n    [inst : CategoryTheory.Category C] →\n      [inst_1 : CategoryTheory.Category D] →\n        {F : C ⥤ D} →\n          {Y : D} →\n            (h : Y ∈ CategoryTheory.Functor.essImage F) →\n              Prefunctor.obj F.toPrefunctor (CategoryTheory.Functor.essImage.witness h) ≅ Y",
  "name": "CategoryTheory.Functor.essImage.getIso",
  "kind": "def",
  "doc_string":
  "Extract the isomorphism between `F.obj h.witness` and `Y` itself. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (zα : Q(Zero «$α»)) →\n      (pα : Q(PartialOrder «$α»)) →\n        (lo e : Q(«$α»)) → Q(«$lo» ≤ «$e») → Lean.MetaM (Mathlib.Meta.Positivity.Strictness zα pα e)",
  "name": "Mathlib.Meta.Positivity.compareHypLE",
  "kind": "def",
  "doc_string":
  "A variation on `assumption` when the hypothesis is `lo ≤ e` where `lo` is a numeral. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    {M' : Type u_3} →\n      [inst : Zero R] →\n        [inst_1 : Zero M] →\n          [inst_2 : SMulWithZero R M] →\n            [inst_3 : Zero M'] →\n              [inst_4 : SMul R M'] →\n                (f : ZeroHom M' M) →\n                  Function.Injective ↑f → (∀ (a : R) (b : M'), ↑f (a • b) = a • ↑f b) → SMulWithZero R M'",
  "name": "Function.Injective.smulWithZero",
  "kind": "def",
  "doc_string":
  "Pullback a `SMulWithZero` structure along an injective zero-preserving homomorphism.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → Monotone (WithBot.map f)",
  "name": "Monotone.withBot_map",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `WithBot.monotone_map_iff`.",
  "args": ""},
 {"type":
  "{M₀ : Type u_1} →\n  {M₀' : Type u_2} →\n    [inst : MulZeroOneClass M₀] →\n      [inst_1 : Mul M₀'] →\n        [inst_2 : Zero M₀'] →\n          [inst_3 : One M₀'] →\n            (f : M₀' → M₀) →\n              Function.Injective f → f 0 = 0 → f 1 = 1 → (∀ (a b : M₀'), f (a * b) = f a * f b) → MulZeroOneClass M₀'",
  "name": "Function.Injective.mulZeroOneClass",
  "kind": "def",
  "doc_string":
  "Pullback a `MulZeroOneClass` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α}, Set.Subsingleton s → ∀ (f : α → β), Set.Subsingleton (f '' s)",
  "name": "Set.Subsingleton.image",
  "kind": "theorem",
  "doc_string": "The image of a subsingleton is a subsingleton. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (p : Option α → Type v) → (p none → False) → (x : Option α) × p x ≃ (x : α) × p (some x)",
  "name": "Equiv.sigmaOptionEquivOfSome",
  "kind": "def",
  "doc_string":
  "A sigma type over an `Option` is equivalent to the sigma set over the original type,\nif the fiber is empty at none. ",
  "args": ""},
 {"type":
  "ℕ → optParam Bool false → Lean.Elab.Tactic.TacticM (Lean.MVarId × List Lean.MVarId × List Lean.MVarId)",
  "name": "Mathlib.Tactic.splitGoalsAndGetNth",
  "kind": "def",
  "doc_string":
  "If the current goals are `g₁ ⋯ gᵢ ⋯ gₙ`, `splitGoalsAndGetNth i` returns\n`(gᵢ, [g₁, ⋯, gᵢ₋₁], [gᵢ₊₁, ⋯, gₙ])`.\n\nIf `reverse` is passed as `true`, the `i`-th goal is picked by counting backwards.\nFor instance, `splitGoalsAndGetNth 1 true` puts the last goal in the first component\nof the returned term.\n",
  "args": ""},
 {"type": "{α : Type u_1} → (r : α → α → Prop) → r ↪r r",
  "name": "RelEmbedding.refl",
  "kind": "def",
  "doc_string": "Identity map is a relation embedding. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → M × N ≃* N × M",
  "name": "MulEquiv.prodComm",
  "kind": "def",
  "doc_string":
  "The equivalence between `M × N` and `N × M` given by swapping the components\nis multiplicative. ",
  "args": ""},
 {"type": "{α : Type u} → α → Stream' α",
  "name": "Stream'.const",
  "kind": "def",
  "doc_string": "The constant stream: `Stream'.nth n (Stream'.const a) = a`. ",
  "args": ""},
 {"type":
  "{b : Prop} → (a : Prop) → (a ↔ b) → [inst : Decidable a] → Decidable b",
  "name": "decidable_of_iff",
  "kind": "def",
  "doc_string":
  "Transfer decidability of `a` to decidability of `b`, if the propositions are equivalent.\n**Important**: this function should be used instead of `rw` on `decidable b`, because the\nkernel will get stuck reducing the usage of `propext` otherwise,\nand `dec_trivial` will not work. ",
  "args": ""},
 {"type": "ℚ → ℤ",
  "name": "Rat.floor",
  "kind": "def",
  "doc_string":
  "The floor of a rational number `a` is the largest integer less than or equal to `a`. ",
  "args": ""},
 {"type":
  "{α : Sort u} → {γ : α → Sort v} → [self : CoeFun α γ] → (f : α) → γ f",
  "name": "CoeFun.coe",
  "kind": "def",
  "doc_string":
  "Coerces a value `f : α` to type `γ f`, which should be either be a\nfunction type or another `CoeFun` type, in order to resolve a mistyped\napplication `f x`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : LinearOrderedAddCommGroup α] →\n    {β : Type u_2} →\n      [inst_1 : Zero β] →\n        [inst_2 : Add β] →\n          [inst_3 : Neg β] →\n            [inst_4 : Sub β] →\n              [inst_5 : SMul ℕ β] →\n                [inst_6 : SMul ℤ β] →\n                  [inst_7 : HasSup β] →\n                    [inst_8 : HasInf β] →\n                      (f : β → α) →\n                        Function.Injective f →\n                          f 0 = 0 →\n                            (∀ (x y : β), f (x + y) = f x + f y) →\n                              (∀ (x : β), f (-x) = -f x) →\n                                (∀ (x y : β), f (x - y) = f x - f y) →\n                                  (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                    (∀ (x : β) (n : ℤ), f (n • x) = n • f x) →\n                                      (∀ (x y : β), f (x ⊔ y) = max (f x) (f y)) →\n                                        (∀ (x y : β), f (x ⊓ y) = min (f x) (f y)) → LinearOrderedAddCommGroup β",
  "name": "Function.Injective.linearOrderedAddCommGroup",
  "kind": "def",
  "doc_string":
  "Pullback a `LinearOrderedAddCommGroup` under an injective map.",
  "args": ""},
 {"type": "{α : Type u_1} → List (List α) → List (List α)",
  "name": "List.transpose",
  "kind": "def",
  "doc_string":
  "Transpose of a list of lists, treated as a matrix.\n```\ntranspose [[1, 2], [3, 4], [5, 6]] = [[1, 3, 5], [2, 4, 6]]\n```\n",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {F G H : C ⥤ D} → CategoryTheory.NatTrans F G → CategoryTheory.NatTrans G H → CategoryTheory.NatTrans F H",
  "name": "CategoryTheory.NatTrans.vcomp",
  "kind": "def",
  "doc_string":
  "`vcomp α β` is the vertical compositions of natural transformations. ",
  "args": ""},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [inst : MonadState σ m] → [inst : Monad m] → (σ → σ) → m σ",
  "name": "getModify",
  "kind": "def",
  "doc_string":
  "`getModify f` gets the state, applies function `f`, and returns the old value\nof the state. It is equivalent to `get <* modify f` but may be more efficient.\n",
  "args": ""},
 {"type":
  "Type u_1 →\n  outParam (Type u_2) → (β : outParam (Type u_3)) → [inst : Zero β] → [inst : LE β] → Type (max (max u_1 u_2) u_3)",
  "name": "NonnegHomClass",
  "kind": "inductive",
  "doc_string":
  "`NonnegHomClass F α β` states that `F` is a type of nonnegative morphisms. ",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.lor'",
  "kind": "def",
  "doc_string":
  "`lor'` takes two natural numbers and returns their bitwise `or`",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "LinearExtension",
  "kind": "def",
  "doc_string":
  "A type alias for `α`, intended to extend a partial order on `α` to a linear order. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : α → Type u_2} →\n    (γ : (a : α) → β a → Type u_3) → ((x : (i : α) × β i) → γ x.fst x.snd) ≃ ((a : α) → (b : β a) → γ a b)",
  "name": "Equiv.piCurry",
  "kind": "def",
  "doc_string":
  "Dependent `curry` equivalence: the type of dependent functions on `Σ i, β i` is equivalent\nto the type of dependent functions of two arguments (i.e., functions to the space of functions).\n\nThis is `Sigma.curry` and `Sigma.uncurry` together as an equiv. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : One M] → [inst_1 : One N] → One (OneHom M N)",
  "name": "instOneOneHom",
  "kind": "def",
  "doc_string": "`1` is the homomorphism sending all elements to `1`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List ℕ → List (List α) × List α",
  "name": "List.takeList",
  "kind": "def",
  "doc_string":
  "`takeList as ns` extracts successive sublists from `as`. For `ns = n₁ ... nₘ`,\nit first takes the `n₁` initial elements from `as`, then the next `n₂` ones,\netc. It returns the sublists of `as` -- one for each `nᵢ` -- and the remaining\nelements of `as`. If `as` does not have at least as many elements as the sum of\nthe `nᵢ`, the corresponding sublists will have less than `nᵢ` elements.\n```\ntakeList ['a', 'b', 'c', 'd', 'e'] [2, 1, 1] = ([['a', 'b'], ['c'], ['d']], ['e'])\ntakeList ['a', 'b'] [3, 1] = ([['a', 'b'], []], [])\n```\n",
  "args": ""},
 {"type": "∀ {α : Sort u_1} {s₁ : Setoid α}, Function.Surjective Quotient.mk''",
  "name": "Quotient.surjective_Quotient_mk''",
  "kind": "theorem",
  "doc_string": "`Quotient.mk''` is a surjective function. ",
  "args": ""},
 {"type": "(A : Type y) → [inst : AddMonoid A] → A ≃ (ℕ →+ A)",
  "name": "multiplesHom",
  "kind": "def",
  "doc_string":
  "Additive homomorphisms from `ℕ` are defined by the image of `1`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → β → α) → List β → α → Array α → List α",
  "name": "List.scanlTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `scanlTR`: `scanlTR.go f l a acc = acc.toList ++ scanl f a l`. ",
  "args": ""},
 {"type": "∀ {n : ℕ}, Fin n → 0 < n",
  "name": "Fin.size_positive",
  "kind": "theorem",
  "doc_string":
  "If you actually have an element of `Fin n`, then the `n` is always positive ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Mul M] {s : Set M}, s ⊆ ↑(Subsemigroup.closure s)",
  "name": "Subsemigroup.subset_closure",
  "kind": "theorem",
  "doc_string": "The subsemigroup generated by a set includes the set. ",
  "args": ""},
 {"type": "{V : Type u} → [inst : Quiver V] → V → V → Sort (max (u + 1) v)",
  "name": "Quiver.Path",
  "kind": "inductive",
  "doc_string":
  "`Path a b` is the type of paths from `a` to `b` through the arrows of `G`. ",
  "args": ""},
 {"type":
  "{R : Type u} → [inst : EuclideanDomain R] → [inst : DecidableEq R] → R → R → R",
  "name": "EuclideanDomain.gcdB",
  "kind": "def",
  "doc_string":
  "The extended GCD `b` value in the equation `gcd x y = x * a + y * b`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [self : LinearOrderedField α] → ℤ → α → α",
  "name": "LinearOrderedField.zpow",
  "kind": "def",
  "doc_string":
  "The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α}, a + b < c → b < c - a",
  "name": "lt_sub_left_of_add_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `lt_sub_iff_add_lt'`.",
  "args": ""},
 {"type": "ProjectionData → Lean.Name",
  "name": "ProjectionData.name",
  "kind": "def",
  "doc_string": "The name used in the generated `simp` lemmas ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {l : α → β} →\n          {u : β → α} →\n            GaloisCoinsertion l u →\n              GaloisInsertion (↑OrderDual.toDual ∘ u ∘ ↑OrderDual.ofDual) (↑OrderDual.toDual ∘ l ∘ ↑OrderDual.ofDual)",
  "name": "GaloisCoinsertion.dual",
  "kind": "def",
  "doc_string":
  "Make a `GaloisInsertion` between `αᵒᵈ` and `βᵒᵈ` from a `GaloisCoinsertion` between `α` and\n`β`. ",
  "args": ""},
 {"type":
  "∀ {γ : Type w} [inst : SemilatticeInf γ] {s t : Set γ}, BddBelow (s ∪ t) ↔ BddBelow s ∧ BddBelow t",
  "name": "bddBelow_union",
  "kind": "theorem",
  "doc_string":
  "The union of two sets is bounded above if and only if each of the sets is.",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {n : ℕ} → {σ : Type} → (α → σ → σ × β) → Vector α n → σ → σ × Vector β n",
  "name": "Vector.mapAccumr",
  "kind": "def",
  "doc_string":
  "Runs a function over a vector returning the intermediate results and a\na final result.\n",
  "args": ""},
 {"type": "(Bool → Bool → Bool) → ℤ → ℤ → ℤ",
  "name": "Int.bitwise",
  "kind": "def",
  "doc_string":
  "`Int.bitwise` applies the function `f` to pairs of bits in the same position in\nthe binary representations of its inputs. ",
  "args": ""},
 {"type": "∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n",
  "name": "Nat.dvd_right_iff_eq",
  "kind": "theorem",
  "doc_string":
  "Two natural numbers are equal if and only if they have the same multiples. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  (c : Order.Coframe α) →\n    (le : α → α → Prop) →\n      le = LE.le →\n        (top : α) →\n          top = ⊤ →\n            (bot : α) →\n              bot = ⊥ →\n                (sup : α → α → α) →\n                  sup = HasSup.sup →\n                    (inf : α → α → α) →\n                      inf = HasInf.inf →\n                        (Sup : Set α → α) → Sup = supₛ → (Inf : Set α → α) → Inf = infₛ → Order.Coframe α",
  "name": "Coframe.copy",
  "kind": "def",
  "doc_string":
  "A function to create a provable equal copy of a coframe with possibly different definitional\nequalities. ",
  "args": ""},
 {"type":
  "∀ {α' : Sort w} [inst : DecidableEq α'] {α : Sort u_1} {β : Sort u_2} (g : α' → β) {f : α → α'} {i : α'} (a : β),\n  (∀ (x : α), f x ≠ i) → Function.update g i a ∘ f = g ∘ f",
  "name": "Function.update_comp_eq_of_forall_ne",
  "kind": "theorem",
  "doc_string":
  "Non-dependent version of `Function.update_comp_eq_of_forall_ne'` ",
  "args": ""},
 {"type": "ByteSliceT → ByteSlice",
  "name": "ByteSliceT.toSlice",
  "kind": "def",
  "doc_string": "Convert a terminal byte slice into a regular byte slice. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a : α}, 1 ≤ a⁻¹ ↔ a ≤ 1",
  "name": "Left.one_le_inv_iff",
  "kind": "theorem",
  "doc_string": "Uses `left` co(ntra)variant. ",
  "args": ""},
 {"type": "{α β : Sort u} → α = β → β → α",
  "name": "Eq.mpr",
  "kind": "def",
  "doc_string":
  "If `h : α = β` is a proof of type equality, then `h.mpr : β → α` is the induced\n\"cast\" operation in the reverse direction, mapping elements of `β` to elements of `α`.\n\nYou can prove theorems about the resulting element by induction on `h`, since\n`rfl.mpr` is definitionally the identity function.\n",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} {p : α → Prop} {α_1 : Type u_1} {q : α_1 → Prop} {f : α → α_1}\n  [inst : Functor m] [inst_1 : LawfulFunctor m] {x : m α},\n  SatisfiesM p x → (∀ {a : α}, p a → q (f a)) → SatisfiesM q (f <$> x)",
  "name": "SatisfiesM.map",
  "kind": "theorem",
  "doc_string": "`SatisfiesM` distributes over `<$>`, general version. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [inst : AddMonoid M] →\n        [inst_1 : AddAction M α] →\n          [inst_2 : VAdd M β] →\n            (f : α → β) → Function.Surjective f → (∀ (c : M) (x : α), f (c +ᵥ x) = c +ᵥ f x) → AddAction M β",
  "name": "Function.Surjective.addAction",
  "kind": "def",
  "doc_string":
  "Pushforward an additive action along a surjective map respecting `+ᵥ`.",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {P : Type u_2} [inst : AddMonoid G] [self : AddAction G P] (g₁ g₂ : G) (p : P),\n  g₁ + g₂ +ᵥ p = g₁ +ᵥ (g₂ +ᵥ p)",
  "name": "AddAction.add_vadd",
  "kind": "def",
  "doc_string": "Associativity of `+` and `+ᵥ` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : OrderedRing α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "name": "OrderedRing.add_le_add_left",
  "kind": "def",
  "doc_string":
  "Addition is monotone in a ordered additive commutative group. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    {M' : Type u_3} →\n      [inst : MonoidWithZero R] →\n        [inst_1 : Zero M] →\n          [inst_2 : MulActionWithZero R M] →\n            [inst_3 : Zero M'] →\n              [inst_4 : SMul R M'] →\n                (f : ZeroHom M' M) →\n                  Function.Injective ↑f → (∀ (a : R) (b : M'), ↑f (a • b) = a • ↑f b) → MulActionWithZero R M'",
  "name": "Function.Injective.mulActionWithZero",
  "kind": "def",
  "doc_string":
  "Pullback a `MulActionWithZero` structure along an injective zero-preserving homomorphism.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Lex α → Sort u_2} → ((a : α) → β (↑toLex a)) → (a : Lex α) → β a",
  "name": "Lex.rec",
  "kind": "def",
  "doc_string": "A recursor for `Lex`. Use as `induction x using Lex.rec`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {u : α → Set β} {x : α},\n  x ∈ s → u x ⊆ Set.unionᵢ fun x => Set.unionᵢ fun h => u x",
  "name": "Set.subset_bunionᵢ_of_mem",
  "kind": "theorem",
  "doc_string": "A specialization of `subset_unionᵢ₂`. ",
  "args": ""},
 {"type":
  "{C : ℤ → Sort u_1} → (z b : ℤ) → C b → ((k : ℤ) → b ≤ k → C k → C (k + 1)) → ((k : ℤ) → k ≤ b → C k → C (k - 1)) → C z",
  "name": "Int.inductionOn'",
  "kind": "def",
  "doc_string":
  "Inductively define a function on `ℤ` by defining it at `b`, for the `succ` of a number greater\nthan `b`, and the `pred` of a number less than `b`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : SubtractionCommMonoid α] → ℤ → α →+ α",
  "name": "zsmulAddGroupHom",
  "kind": "def",
  "doc_string":
  "Multiplication by an integer `n` on a commutative additive group, considered as an\nadditive group homomorphism.",
  "args": ""},
 {"type":
  "∀ {M : Type uM} [inst : AddCommMonoid M] (n : ℕ) (m : M), ↑↑n m = n • m",
  "name": "AddMonoid.End.natCast_apply",
  "kind": "theorem",
  "doc_string": "See also `AddMonoid.End.natCast_def`. ",
  "args": ""},
 {"type":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} → [inst : Mul α] → [inst_1 : Mul β] → [inst_2 : MulEquivClass F α β] → CoeTC F (α ≃* β)",
  "name": "instCoeTCMulEquiv",
  "kind": "def",
  "doc_string":
  "Any type satisfying `MulEquivClass` can be cast into `MulEquiv` via\n`MulEquivClass.toMulEquiv`. ",
  "args": ""},
 {"type":
  "Linarith.LinarithConfig → Option Lean.Expr → Lean.MVarId → List Lean.Expr → Lean.MetaM Unit",
  "name": "Linarith.runLinarith",
  "kind": "def",
  "doc_string":
  "Given a list `hyps` of proofs of comparisons, `runLinarith cfg hyps pref_type`\npreprocesses `hyps` according to the list of preprocessors in `cfg`.\nThis results in a list of branches (typically only one),\neach of which must succeed in order to close the goal.\n\nIn each branch, we partition the list of hypotheses by type, and run `linarith` on each class\nin the partition; one of these must succeed in order for `linarith` to succeed on this branch.\nIf `pref_type` is given, it will first use the class of proofs of comparisons over that type.\n",
  "args": ""},
 {"type": "{α : Type u} → [inst : Preorder α] → Set α → α → Prop",
  "name": "IsLeast",
  "kind": "def",
  "doc_string":
  "`a` is a least element of a set `s`; for a partial order, it is unique if exists. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → β) → List α → optParam ℕ 1024 → List β",
  "name": "List.mapAsyncChunked",
  "kind": "def",
  "doc_string": "Asynchronous version of `List.map`.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u₁} [inst : StrictOrderedSemiring R] {a : R},\n  0 ≤ a * a → 0 ≤ (1 + a) * (1 + a) → 0 ≤ 2 + a → ∀ (n : ℕ), 1 + ↑n * a ≤ (1 + a) ^ n",
  "name": "one_add_mul_le_pow'",
  "kind": "theorem",
  "doc_string":
  "Bernoulli's inequality. This version works for semirings but requires\nadditional hypotheses `0 ≤ a * a` and `0 ≤ (1 + a) * (1 + a)`. ",
  "args": ""},
 {"type":
  "Lean.SimpleScopedEnvExtension (Lean.Name × Array (Lean.Meta.DiscrTree.Key true)) (Lean.Meta.DiscrTree Lean.Name true)",
  "name": "Mathlib.Tactic.symmExt",
  "kind": "opaque",
  "doc_string": "Environment extensions for symm lemmas ",
  "args": ""},
 {"type":
  "{F : Type u_1} →\n  {α : Type u_2} → {β : Type u_3} → [inst : Add α] → [inst_1 : Add β] → [inst_2 : AddEquivClass F α β] → F → α ≃+ β",
  "name": "AddEquivClass.toAddEquiv",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `AddEquivClass F α β` into an actual\n`AddEquiv`. This is declared as the default coercion from `F` to `α ≃+ β`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : PartialOrder α] → [inst : OrderBot α] → α → α → Prop",
  "name": "Disjoint",
  "kind": "def",
  "doc_string":
  "Two elements of a lattice are disjoint if their inf is the bottom element.\n  (This generalizes disjoint sets, viewed as members of the subset lattice.)\n\nNote that we define this without reference to `⊓`, as this allows us to talk about orders where\nthe infimum is not unique, or where implementing `HasInf` would require additional `Decidable`\narguments. ",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : LE α] [self : OrderTop α] (a : α), a ≤ ⊤",
  "name": "OrderTop.le_top",
  "kind": "def",
  "doc_string": "`⊤` is the greatest element ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Inhabited α] → Nontrivial α ⊕' Unique α",
  "name": "nontrivialPSumUnique",
  "kind": "def",
  "doc_string":
  "An inhabited type is either nontrivial, or has a unique element. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → α → BinaryHeap α lt",
  "name": "BinaryHeap.insert",
  "kind": "def",
  "doc_string":
  "`O(log n)`. Insert an element into a `BinaryHeap`, preserving the max-heap property. ",
  "args": ""},
 {"type":
  "∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] (e : R₁ ≃+* R₂),\n  RingHomInvPair ↑e ↑(RingEquiv.symm e)",
  "name": "RingHomInvPair.of_ringEquiv",
  "kind": "theorem",
  "doc_string":
  "Construct a `RingHomInvPair` from both directions of a ring equiv.\n\nThis is not an instance, as for equivalences that are involutions, a better instance\nwould be `RingHomInvPair e e`. Indeed, this declaration is not currently used in mathlib.\n\nSee note [reducible non-instances].\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r₁ r₂ : R)\n  (s : { x // x ∈ S }), ↑s * r₁ = ↑s * r₂ → ∃ s', r₁ * ↑s' = r₂ * ↑s'",
  "name": "OreLocalization.ore_left_cancel",
  "kind": "theorem",
  "doc_string":
  "Common factors on the left can be turned into common factors on the right, a weak form of\ncancellability. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} (r : α → α → Prop) [inst : IsAntisymm α r] {a b : α}, r a b → r b a → b = a",
  "name": "antisymm_of'",
  "kind": "theorem",
  "doc_string":
  "A version of `antisymm'` with `r` explicit.\n\nThis lemma matches the lemmas from lean core in `Init.Algebra.Classes`, but is missing there.  ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : Semiring α] →\n    {β : Type v} →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Pow β ℕ] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : NatCast β] →\n                    (f : α → β) →\n                      Function.Surjective f →\n                        f 0 = 0 →\n                          f 1 = 1 →\n                            (∀ (x y : α), f (x + y) = f x + f y) →\n                              (∀ (x y : α), f (x * y) = f x * f y) →\n                                (∀ (x : α) (n : ℕ), f (n • x) = n • f x) →\n                                  (∀ (x : α) (n : ℕ), f (x ^ n) = f x ^ n) → (∀ (n : ℕ), f ↑n = ↑n) → Semiring β",
  "name": "Function.Surjective.semiring",
  "kind": "def",
  "doc_string":
  "Pushforward a `Semiring` instance along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Lean.Expr → Bool",
  "name": "Linarith.filterComparisons.aux",
  "kind": "def",
  "doc_string": "Implementation of the `filterComparisons` preprocessor. ",
  "args": ""},
 {"type": "Lean.Environment → Lean.Name → Option Lean.Name",
  "name": "ToAdditive.findTranslation?",
  "kind": "def",
  "doc_string":
  "Get the multiplicative → additive translation for the given name. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] (self : α →o β), Monotone ↑self",
  "name": "OrderHom.monotone'",
  "kind": "def",
  "doc_string": "The underlying function of an `OrderHom` is monotone. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteLattice α] (s : Set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ infₛ s",
  "name": "CompleteLattice.le_infₛ",
  "kind": "def",
  "doc_string": "Any lower bound is less than the set infimum. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Type u_3} {β : Type u_2} {S : ι → Set α} {f : (i : ι) → ↑(S i) → β}\n  {hf :\n    ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j),\n      f i { val := x, property := hxi } = f j { val := x, property := hxj }}\n  {T : Set α} {hT : T ⊆ Set.unionᵢ S} (c : ↑T) (ci : (i : ι) → ↑(S i)),\n  (∀ (i : ι), ↑(ci i) = ↑c) → ∀ (cβ : β), (∀ (i : ι), f i (ci i) = cβ) → Set.unionᵢLift S f hf T hT c = cβ",
  "name": "Set.unionᵢLift_const",
  "kind": "theorem",
  "doc_string":
  "`unionᵢLift_const` is useful for proving that `unionᵢLift` is a homomorphism\nof algebraic structures when defined on the Union of algebraic subobjects.\nFor example, it could be used to prove that the lift of a collection\nof group homomorphisms on a union of subgroups preserves `1`. ",
  "args": ""},
 {"type": "{α : Type} → SlimCheck.Gen α → SlimCheck.Gen (List α)",
  "name": "SlimCheck.Gen.listOf",
  "kind": "def",
  "doc_string":
  "Create an `List` of examples using `x`. The size is controlled\nby the size parameter of `Gen`. ",
  "args": ""},
 {"type":
  "∀ {F : Sort u_2} {β : Sort u_1} {γ : Sort u_3} [iF : EquivLike F β γ] [inst : Subsingleton β], Subsingleton F",
  "name": "EquivLike.subsingleton_dom",
  "kind": "theorem",
  "doc_string":
  "This is not an instance to avoid slowing down every single `Subsingleton` typeclass search.",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → Option α × List α",
  "name": "List.extractP",
  "kind": "def",
  "doc_string":
  "`extractP p l` returns a pair of an element `a` of `l` satisfying the predicate\n`p`, and `l`, with `a` removed. If there is no such element `a` it returns `(none, l)`.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term-_»",
  "kind": "def",
  "doc_string":
  "`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type": "{α : Type u_1} → α → ℕ → List α → Array α → List α × List α",
  "name": "List.splitAtD.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `splitAtD`: `splitAtD.go dflt n l acc = (acc.toList ++ left, right)`\nif `splitAtD n l dflt = (left, right)`. ",
  "args": ""},
 {"type":
  "Linarith.GlobalBranchingPreprocessor → Lean.MVarId → List Lean.Expr → Lean.MetaM (List Linarith.Branch)",
  "name": "Linarith.GlobalBranchingPreprocessor.transform",
  "kind": "def",
  "doc_string":
  "Given a goal, and a list of hypotheses,\nproduce a list of pairs (consisting of a goal and list of hypotheses). ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_4} {α : Type u_3} {β : Type u_2} [inst : SMul M α] [inst_1 : SMul M β] [inst_2 : SMul α β]\n  [inst_3 : IsScalarTower M α β] (g : N → M), IsScalarTower N α β",
  "name": "SMul.comp.isScalarTower",
  "kind": "theorem",
  "doc_string":
  "Given a tower of scalar actions `M → α → β`, if we use `SMul.comp`\nto pull back both of `M`'s actions by a map `g : N → M`, then we obtain a new\ntower of scalar actions `N → α → β`.\n\nThis cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables.\n",
  "args": ""},
 {"type": "∀ (x y : ℤ), ↑(Int.gcd x y) = x * Int.gcdA x y + y * Int.gcdB x y",
  "name": "Int.gcd_eq_gcd_ab",
  "kind": "theorem",
  "doc_string": "**Bézout's lemma** ",
  "args": ""},
 {"type":
  "{β : Type u_1} →\n  {α : Type u_2} →\n    {c : α → α → Ordering} → [inst : Add β] → [inst : Zero β] → [inst : DecidableEq β] → Add (Std.RBMap α β c)",
  "name": "instAddRBMap",
  "kind": "def",
  "doc_string":
  "We introduce a local instance allowing addition of `RBMap`s,\nremoving any keys with value zero.\nWe don't need to prove anything about this addition, as it is only used in meta code.\n",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → {e : Q(«$α»)} → Mathlib.Meta.NormNum.Result e → Lean.MetaM Lean.Meta.Simp.Result",
  "name": "Mathlib.Meta.NormNum.Result.toSimpResult",
  "kind": "def",
  "doc_string": "Convert a `Result` to a `Simp.Result`. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CoheytingAlgebra",
  "kind": "inductive",
  "doc_string":
  "A co-Heyting algebra is a bounded  lattice with an additional binary difference operation `\\`\nsuch that `\\ a` is right adjoint to `⊔ a`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : Group α] →\n    [inst_1 : LE α] → [inst : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] → α → α ≃o α",
  "name": "OrderIso.mulRight",
  "kind": "def",
  "doc_string":
  "`Equiv.mulRight` as an `OrderIso`. See also `OrderEmbedding.mulRight`. ",
  "args": ""},
 {"type": "ℕ → NonScalar",
  "name": "NonScalar.mk",
  "kind": "def",
  "doc_string": "You should not use this function ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "SemilatticeInf",
  "kind": "inductive",
  "doc_string":
  "A `SemilatticeInf` is a meet-semilattice, that is, a partial order\nwith a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n`⊓` which is the greatest element smaller than both factors. ",
  "args": ""},
 {"type": "(α : Type u) → [inst : SlimCheck.SampleableExt α] → SlimCheck.Gen α",
  "name": "SlimCheck.SampleableExt.interpSample",
  "kind": "def",
  "doc_string":
  "First samples a proxy value and interprets it. Especially useful if\nthe proxy and target type are the same. ",
  "args": ""},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "name": "CoeHTC",
  "kind": "inductive",
  "doc_string":
  "Auxiliary class implementing `CoeHead CoeOut* Coe*`.\nUsers should generally not implement this directly.\n",
  "args": ""},
 {"type": "{α β σ : Type u} → α → σ → DoResultPRBC α β σ",
  "name": "DoResultPRBC.pure",
  "kind": "def",
  "doc_string":
  "`pure (a : α) s` means that the block exited normally with return value `a` ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {α : Type u_2} [inst : SMul M α] [inst_1 : SMul Mᵐᵒᵖ α] [self : IsCentralScalar M α] (m : M) (a : α),\n  { unop := m } • a = m • a",
  "name": "IsCentralScalar.op_smul_eq_smul",
  "kind": "def",
  "doc_string": "The right and left actions of `M` on `α` are equal. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : CommRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Neg β] →\n                [inst_6 : Sub β] →\n                  [inst_7 : SMul ℕ β] →\n                    [inst_8 : SMul ℤ β] →\n                      [inst_9 : Pow β ℕ] →\n                        [inst_10 : NatCast β] →\n                          [inst_11 : IntCast β] →\n                            (f : β → α) →\n                              Function.Injective f →\n                                f 0 = 0 →\n                                  f 1 = 1 →\n                                    (∀ (x y : β), f (x + y) = f x + f y) →\n                                      (∀ (x y : β), f (x * y) = f x * f y) →\n                                        (∀ (x : β), f (-x) = -f x) →\n                                          (∀ (x y : β), f (x - y) = f x - f y) →\n                                            (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                              (∀ (x : β) (n : ℤ), f (n • x) = n • f x) →\n                                                (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                  (∀ (n : ℕ), f ↑n = ↑n) → (∀ (n : ℤ), f ↑n = ↑n) → CommRing β",
  "name": "Function.Injective.commRing",
  "kind": "def",
  "doc_string":
  "Pullback a `CommRing` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u_1} → Array (Option α) → Array α",
  "name": "Array.reduceOption",
  "kind": "def",
  "doc_string":
  "Drop `none`s from a Array, and replace each remaining `some a` with `a`. ",
  "args": ""},
 {"type": "(α : Sort u) → [i : α] → α",
  "name": "inferInstanceAs",
  "kind": "def",
  "doc_string":
  "`inferInstanceAs α` synthesizes a value of any target type by typeclass\ninference. This is just like `inferInstance` except that `α` is given\nexplicitly instead of being inferred from the target type. It is especially\nuseful when the target type is some `α'` which is definitionally equal to `α`,\nbut the instance we are looking for is only registered for `α` (because\ntypeclass search does not unfold most definitions, but definitional equality\ndoes.) Example:\n```\n#check inferInstanceAs (Inhabited Nat) -- Inhabited Nat\n```\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddSemigroup R] {a : R} (b : R),\n  IsAddRightRegular a → (IsAddRightRegular (b + a) ↔ IsAddRightRegular b)",
  "name": "add_isAddRightRegular_iff",
  "kind": "theorem",
  "doc_string":
  "An element is add-right-regular if and only if adding it on the right to\na add-right-regular element is add-right-regular.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : SubtractionCommMonoid α] → α →+ α",
  "name": "negAddMonoidHom",
  "kind": "def",
  "doc_string":
  "Negation on a commutative additive group, considered as an additive monoid\nhomomorphism.",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (r : R)\n  (x y : M), r • (x + y) = r • x + r • y",
  "name": "Module.Core.smul_add",
  "kind": "def",
  "doc_string":
  "Scalar multiplication distributes over addition from the left. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CancelMonoidWithZero",
  "kind": "inductive",
  "doc_string":
  "A type `M` is a `CancelMonoidWithZero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term‹_›»",
  "kind": "def",
  "doc_string":
  "`‹t›` resolves to an (arbitrary) hypothesis of type `t`.\nIt is useful for referring to hypotheses without accessible names.\n`t` may contain holes that are solved by unification with the expected type;\nin particular, `‹_›` is a shortcut for `by assumption`.\n",
  "args": ""},
 {"type": "Type u_1 → Type u_2 → Type u_1",
  "name": "Functor.AddConst",
  "kind": "def",
  "doc_string":
  "`AddConst α` is a synonym for constant functor `Const α`, mapping\nevery type to `α`. When `α` has a additive monoid structure,\n`AddConst α` has an `Applicative` instance. (If `α` has a\nmultiplicative monoid structure, see `Functor.Const`.) ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    [inst : NonUnitalNonAssocSemiring R] →\n      [inst_1 : NonUnitalNonAssocSemiring S] → (f : R →ₙ+* S) → (∀ (x y : R), Commute (↑f x) (↑f y)) → R →ₙ+* Sᵐᵒᵖ",
  "name": "NonUnitalRingHom.toOpposite",
  "kind": "def",
  "doc_string":
  "A non-unital ring homomorphism `f : R →ₙ+* S` such that `f x` commutes with `f y` for all `x, y`\ndefines a non-unital ring homomorphism to `Sᵐᵒᵖ`. ",
  "args": ""},
 {"type": "∀ {α : Type u} {s t : Set α}, Disjoint s t → s ⊆ tᶜ",
  "name": "Disjoint.subset_compl_right",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Set.subset_compl_iff_disjoint_right`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : LinearOrder β] {f : α → β},\n  ¬Monotone f ∧ ¬Antitone f ↔ ∃ a b c, a < b ∧ b < c ∧ (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c)",
  "name": "not_monotone_not_antitone_iff_exists_lt_lt",
  "kind": "theorem",
  "doc_string":
  "A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. ",
  "args": ""},
 {"type":
  "{V : Type u} →\n  [inst : Quiver V] →\n    (r : V) →\n      (height : V → ℕ) →\n        (∀ ⦃a b : V⦄, (a ⟶ b) → height a < height b) →\n          (∀ ⦃a b c : V⦄ (e : a ⟶ c) (f : b ⟶ c), a = b ∧ HEq e f) →\n            (∀ (b : V), b = r ∨ ∃ a, Nonempty (a ⟶ b)) → Quiver.Arborescence V",
  "name": "Quiver.arborescenceMk",
  "kind": "def",
  "doc_string":
  "To show that `[Quiver V]` is an arborescence with root `r : V`, it suffices to\n- provide a height function `V → ℕ` such that every arrow goes from a\n  lower vertex to a higher vertex,\n- show that every vertex has at most one arrow to it, and\n- show that every vertex other than `r` has an arrow to it. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {f g : M →* N},\n  f = g ↔ ∀ (x : M), ↑f x = ↑g x",
  "name": "MonoidHom.ext_iff",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.ext_iff` instead. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Part",
  "kind": "inductive",
  "doc_string":
  "`Part α` is the type of \"partial values\" of type `α`. It\nis similar to `Option α` except the domain condition can be an\narbitrary proposition, not necessarily decidable. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → [self : PredOrder α] → α → α",
  "name": "PredOrder.pred",
  "kind": "def",
  "doc_string": "Predecessor function",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.applyFun",
  "kind": "def",
  "doc_string":
  "Apply a function to an equality or inequality in either a local hypothesis or the goal.\n\n* If we have `h : a = b`, then `apply_fun f at h` will replace this with `h : f a = f b`.\n* If we have `h : a ≤ b`, then `apply_fun f at h` will replace this with `h : f a ≤ f b`,\n  and create a subsidiary goal `monotone f`.\n  `apply_fun` will automatically attempt to discharge this subsidiary goal using `mono`,\n  or an explicit solution can be provided with `apply_fun f at h using P`, where `P : monotone f`.\n* If the goal is `a ≠ b`, `apply_fun f` will replace this with `f a ≠ f b`.\n* If the goal is `a = b`, `apply_fun f` will replace this with `f a = f b`,\n  and create a subsidiary goal `injective f`.\n  `apply_fun` will automatically attempt to discharge this subsidiary goal using local hypotheses,\n  or if `f` is actually an `equiv`,\n  or an explicit solution can be provided with `apply_fun f using P`, where `P : Injective f`.\n* If the goal is `a ≤ b` (or similarly for `a < b`), and `f` is actually an `OrderIso`,\n  `apply_fun f` will replace the goal with `f a ≤ f b`.\n  If `f` is anything else (e.g. just a function, or an `equiv`), `apply_fun` will fail.\n\n\nTypical usage is:\n```lean\nopen Function\n\nexample (X Y Z : Type) (f : X → Y) (g : Y → Z) (H : Injective <| g ∘ f) :\n    Injective f := by\n  intros x x' h\n  apply_fun g at h\n  exact H h\n```\n ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {f : α → α} {x : α}, Monotone f → x ≤ f x → Monotone fun n => Nat.iterate f n x",
  "name": "Monotone.monotone_iterate_of_le_map",
  "kind": "theorem",
  "doc_string":
  "If `f` is a monotone map and `x ≤ f x` at some point `x`, then the iterates `f^[n] x` form\na monotone sequence. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "HasSup",
  "kind": "inductive",
  "doc_string": "Typeclass for the `⊔` (`\\lub`) notation ",
  "args": ""},
 {"type": "{α : Type u} → LazyList α → LazyList α",
  "name": "LazyList.tail",
  "kind": "def",
  "doc_string": "Removes the first element of the lazy list.\n",
  "args": ""},
 {"type":
  "(M : Type u_1) →\n  (A : Type u_2) → [inst : Monoid M] → [inst_1 : AddMonoid A] → [inst_2 : DistribMulAction M A] → M →* AddMonoid.End A",
  "name": "DistribMulAction.toAddMonoidEnd",
  "kind": "def",
  "doc_string":
  "Each element of the monoid defines an additive monoid homomorphism. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CanonicallyLinearOrderedAddMonoid",
  "kind": "inductive",
  "doc_string":
  "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\nwhose ordering is a linear order. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {s : Set (Setoid α)}, supₛ s = EqvGen.Setoid (supₛ (Setoid.Rel '' s))",
  "name": "Setoid.supₛ_def",
  "kind": "theorem",
  "doc_string":
  "The supremum of a set of equivalence relations is the equivalence closure of the\nsupremum of the set's image under the map to the underlying binary operation. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Lattice α] [self : IsUpperModularLattice α] {a b : α}, a ⊓ b ⋖ a → b ⋖ a ⊔ b",
  "name": "IsUpperModularLattice.covby_sup_of_inf_covby",
  "kind": "def",
  "doc_string":
  "`a ⊔ b` covers `a` and `b` if either `a` or `b` covers `a ⊓ b` ",
  "args": ""},
 {"type": "{α : Type u} → α → α → α → α → α → Array α",
  "name": "Array.mkArray5",
  "kind": "def",
  "doc_string": "Create array `#[a₁, a₂, a₃, a₄, a₅]` ",
  "args": ""},
 {"type":
  "∀ {m : Type u → Type v} [inst : Applicative m] [self : CommApplicative m] {α β : Type u} (a : m α) (b : m β),\n  (Seq.seq (Prod.mk <$> a) fun x => b) = Seq.seq ((fun b a => (a, b)) <$> b) fun x => a",
  "name": "CommApplicative.commutative_prod",
  "kind": "def",
  "doc_string":
  "Computations performed first on `a : α` and then on `b : β` are equal to those performed in\nthe reverse order. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {hα : OrderedAddCommGroup α} →\n      {hβ : OrderedAddCommGroup β} → (f : α → β) → Monotone f → (∀ (a b : α), f (a + b) = f a + f b) → α →+o β",
  "name": "OrderAddMonoidHom.mk'",
  "kind": "def",
  "doc_string":
  "Makes an ordered additive group homomorphism from a proof that the map preserves\naddition.",
  "args": ""},
 {"type":
  "{C : Type u} → [inst : CategoryTheory.Category C] → {X Y : C} → (X ⟶ Y) → Prop",
  "name": "CategoryTheory.Mono",
  "kind": "inductive",
  "doc_string":
  "A morphism `f` is a monomorphism if it can be cancelled when postcomposed:\n`g ≫ f = h ≫ f` implies `g = h`.\n\nSee <https://stacks.math.columbia.edu/tag/003B>.\n",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : AddLeftCancelMonoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 0 = 0 →\n                  (∀ (x y : M₁), f (x + y) = f x + f y) →\n                    (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) → AddLeftCancelMonoid M₁",
  "name": "Function.Injective.addLeftCancelMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `0` and `+` is an additive left cancel monoid, if it\nadmits an injective map that preserves `0` and `+` to an additive left cancel monoid.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Abel.abel1!",
  "kind": "def",
  "doc_string":
  "Tactic for solving equations in the language of\n*additive*, commutative monoids and groups.\nThis version of `abel` fails if the target is not an equality\nthat is provable by the axioms of commutative monoids/groups.\n\n`abel1!` will use a more aggressive reducibility setting to identify atoms.\nThis can prove goals that `abel` cannot, but is more expensive.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«command#helpCommand+__»",
  "kind": "def",
  "doc_string":
  "The command `#help command` shows all commands that have been defined in the current environment.\nSee `#help cat` for more information.\n",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : AddZeroClass M] → Set M → AddSubmonoid M",
  "name": "AddSubmonoid.closure",
  "kind": "def",
  "doc_string": "The `add_submonoid` generated by a set",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        {F : Type u_3} →\n          [mc : AddMonoidHomClass F M N] →\n            {f : F} → Function.Injective ↑f → GaloisCoinsertion (AddSubmonoid.map f) (AddSubmonoid.comap f)",
  "name": "AddSubmonoid.gciMapComap",
  "kind": "def",
  "doc_string":
  "`map f` and `comap f` form a `GaloisCoinsertion` when `f` is injective. ",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u_1} [self : CommGroupWithZero G₀] (n : ℕ) (a : G₀),\n  CommGroupWithZero.zpow (Int.ofNat (Nat.succ n)) a = a * CommGroupWithZero.zpow (Int.ofNat n) a",
  "name": "CommGroupWithZero.zpow_succ'",
  "kind": "def",
  "doc_string": "`a ^ (n + 1) = a * a ^ n` ",
  "args": ""},
 {"type": "Q(CommSemiring ℕ)",
  "name": "Mathlib.Tactic.Ring.sℕ",
  "kind": "def",
  "doc_string":
  "A typed expression of type `CommSemiring ℕ` used when we are working on\nring subexpressions of type `ℕ`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrder α] → [inst_1 : Preorder β] → (f : α → β) → (s : Set α) → StrictMonoOn f s → ↑s ≃o ↑(f '' s)",
  "name": "StrictMonoOn.orderIso",
  "kind": "def",
  "doc_string":
  "If a function `f` is strictly monotone on a set `s`, then it defines an order isomorphism\nbetween `s` and its image. ",
  "args": ""},
 {"type": "PosNum → PosNum",
  "name": "PosNum.size",
  "kind": "def",
  "doc_string": "The number of bits of a `PosNum`, as a `PosNum`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {f : ℕ → α},\n  Monotone f → ∀ (n : ℕ) {x : α}, f n < x → x < f (n + 1) → ∀ (a : ℕ), f a ≠ x",
  "name": "Monotone.ne_of_lt_of_lt_nat",
  "kind": "theorem",
  "doc_string":
  "If `f` is a monotone function from `ℕ` to a preorder such that `x` lies between `f n` and\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddZeroClass M] → AddSubmonoid M → AddSubsemigroup M",
  "name": "AddSubmonoid.toAddSubsemigroup",
  "kind": "def",
  "doc_string":
  "An additive submonoid of an additive monoid `M` can be considered as an\nadditive subsemigroup of that additive monoid. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (e : Q(«$α»)) →\n      (_inst : autoParam Q(Ring «$α») _auto✝) → Lean.MetaM ((lit : Q(ℤ)) × Q(Mathlib.Meta.NormNum.IsInt «$e» «$lit»))",
  "name": "Mathlib.Meta.NormNum.deriveInt",
  "kind": "def",
  "doc_string":
  "Run each registered `norm_num` extension on a typed expression `e : α`,\nreturning a typed expression `lit : ℤ`, and a proof of `isInt e lit`. ",
  "args": ""},
 {"type": "PUnit ≃ PUnit",
  "name": "Equiv.punitEquivPUnit",
  "kind": "def",
  "doc_string": "`PUnit` sorts in any two universes are equivalent. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → (α ≃. β) → (β ≃. γ) → α ≃. γ",
  "name": "PEquiv.trans",
  "kind": "def",
  "doc_string":
  "Composition of partial equivalences `f : α ≃. β` and `g : β ≃. γ`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_4} {α' : Type u_2} {β : Type u_3} {γ : Type u_1} {δ : Type u_5} {s : Set α} {t : Set β} {f : α' → β → γ}\n  {g : α → α'} {f' : β → α → δ} {g' : δ → γ},\n  (∀ (a : α) (b : β), f (g a) b = g' (f' b a)) → Set.image2 f (g '' s) t = g' '' Set.image2 f' t s",
  "name": "Set.image2_image_left_anticomm",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Set.image_image2_antidistrib_left`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] {a : αᵒᵈ}, IsMin a → IsMax (↑OrderDual.ofDual a)",
  "name": "IsMin.ofDual",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `isMax_ofDual_iff`.",
  "args": ""},
 {"type": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
  "name": "Iff.intro",
  "kind": "def",
  "doc_string": "If `a → b` and `b → a` then `a` and `b` are equivalent. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} (r : α → α → Prop) [inst : IsPartialOrder α r], ∃ s x, r ≤ s",
  "name": "extend_partial_order",
  "kind": "theorem",
  "doc_string": "Any partial order can be extended to a linear order.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedSemifield α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Pow β ℕ] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : NatCast β] →\n                    [inst_8 : Inv β] →\n                      [inst_9 : Div β] →\n                        [inst_10 : Pow β ℤ] →\n                          [inst_11 : HasSup β] →\n                            [inst_12 : HasInf β] →\n                              (f : β → α) →\n                                Function.Injective f →\n                                  f 0 = 0 →\n                                    f 1 = 1 →\n                                      (∀ (x y : β), f (x + y) = f x + f y) →\n                                        (∀ (x y : β), f (x * y) = f x * f y) →\n                                          (∀ (x : β), f x⁻¹ = (f x)⁻¹) →\n                                            (∀ (x y : β), f (x / y) = f x / f y) →\n                                              (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                                (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                  (∀ (x : β) (n : ℤ), f (x ^ n) = f x ^ n) →\n                                                    (∀ (n : ℕ), f ↑n = ↑n) →\n                                                      (∀ (x y : β), f (x ⊔ y) = max (f x) (f y)) →\n                                                        (∀ (x y : β), f (x ⊓ y) = min (f x) (f y)) →\n                                                          LinearOrderedSemifield β",
  "name": "Function.Injective.linearOrderedSemifield",
  "kind": "def",
  "doc_string": "Pullback a `LinearOrderedSemifield` under an injective map. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α], 0⁻¹ = 0",
  "name": "CanonicallyLinearOrderedSemifield.inv_zero",
  "kind": "def",
  "doc_string": "The inverse of `0` in a group with zero is `0`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → {α : Type u_3} → [inst : SMul M α] → (N → M) → N → α → α",
  "name": "SMul.comp.smul",
  "kind": "def",
  "doc_string":
  "Auxiliary definition for `SMul.comp`, `MulAction.compHom`,\n`DistribMulAction.compHom`, `Module.compHom`, etc. ",
  "args": ""},
 {"type": "{α : Type u} → (α → α) → ℕ → α → α",
  "name": "Nat.repeat",
  "kind": "def",
  "doc_string":
  "`Nat.repeat f n a` is `f^(n) a`; that is, it iterates `f` `n` times on `a`.\n* `Nat.repeat f 3 a = f <| f <| f <| a`\n",
  "args": ""},
 {"type": "{α : Type u} → ℕ → LazyList α → List α",
  "name": "LazyList.approx",
  "kind": "def",
  "doc_string": "The list containing the first `n` elements of a lazy list.  ",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.Context → Lean.Expr",
  "name": "Mathlib.Tactic.Abel.Context.α0",
  "kind": "def",
  "doc_string": "The expression representing `0 : α`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Setoid α → (α → β) → Setoid β",
  "name": "Setoid.map",
  "kind": "def",
  "doc_string":
  "Given a function `f : α → β` and equivalence relation `r` on `α`, the equivalence\nclosure of the relation on `f`'s image defined by '`x ≈ y` iff the elements of `f⁻¹(x)` are\nrelated to the elements of `f⁻¹(y)` by `r`.' ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Add α] → VAdd αᵃᵒᵖ α",
  "name": "Add.toHasOppositeVAdd",
  "kind": "def",
  "doc_string":
  "Like `Add.toVAdd`, but adds on the right.\n\nSee also `AddMonoid.to_OppositeAddAction`.",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} [inst : MonoidWithZero R] [inst_1 : Zero M] [self : MulActionWithZero R M] (r : R),\n  r • 0 = 0",
  "name": "MulActionWithZero.smul_zero",
  "kind": "def",
  "doc_string": "Scalar multiplication by any element send `0` to `0`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → Set.Iio a ⊆ Set.Iic b",
  "name": "Set.Iio_subset_Iic",
  "kind": "theorem",
  "doc_string":
  "If `a ≤ b`, then `(-∞, a) ⊆ (-∞, b]`. In preorders, this is just an implication. If you need\nthe equivalence in dense linear orders, use `Iio_subset_Iic_iff`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : Setoid α} (f : α → β) (H : ∀ (x y : α), Setoid.Rel r x y → f x = f y),\n  Function.Injective (Quotient.lift f H) → Setoid.ker f = r",
  "name": "Setoid.ker_eq_lift_of_injective",
  "kind": "theorem",
  "doc_string":
  "Given a map f from α to β, the kernel of f is the unique equivalence relation on α whose\ninduced map from the quotient of α to β is injective. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Inhabited α] → List α → α",
  "name": "List.headI",
  "kind": "def",
  "doc_string":
  "The head of a list, or the default element of the type is the list is `nil`. ",
  "args": ""},
 {"type": "PosNum → Num → Num → Num × Num",
  "name": "PosNum.divModAux",
  "kind": "def",
  "doc_string": "Auxiliary definition for `PosNum.divMod`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  (α : Q(Type u)) → (_sα : Q(AddMonoidWithOne «$α»)) → (lit : Q(ℕ)) → Lean.MetaM ((a' : Q(«$α»)) × Q(↑«$lit» = «$a'»))",
  "name": "Mathlib.Meta.NormNum.mkOfNat",
  "kind": "def",
  "doc_string":
  "Constructs an `ofNat` application `a'` with the canonical instance, together with a proof that\nthe instance is equal to the result of `Nat.cast` on the given `AddMonoidWithOne` instance.\n\nThis function is performance-critical, as many higher level tactics have to construct numerals.\nSo rather than using typeclass search we hardcode the (relatively small) set of solutions\nto the typeclass problem.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : IsWeakUpperModularLattice α] {a b : α}, a ⊓ b ⋖ a → a ⊓ b ⋖ b → a ⋖ a ⊔ b",
  "name": "Covby.sup_of_inf_of_inf_left",
  "kind": "theorem",
  "doc_string": "**Alias** of `covby_sup_of_inf_covby_of_inf_covby_left`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  StrictAnti f → StrictMono (↑OrderDual.toDual ∘ f)",
  "name": "StrictAnti.dual_right",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `strictMono_toDual_comp_iff`.",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} {a b : R} [inst : CommSemigroup R] [inst_1 : SMul R M] [inst_2 : IsScalarTower R R M],\n  IsSMulRegular M (a * b) ↔ IsSMulRegular M a ∧ IsSMulRegular M b",
  "name": "IsSMulRegular.mul_iff",
  "kind": "theorem",
  "doc_string": "A product is `M`-regular if and only if the factors are. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Mul M] → {S T : Subsemigroup M} → S = T → { x // x ∈ S } ≃* { x // x ∈ T }",
  "name": "MulEquiv.subsemigroupCongr",
  "kind": "def",
  "doc_string":
  "Makes the identity isomorphism from a proof that two subsemigroups of a multiplicative\nsemigroup are equal. ",
  "args": ""},
 {"type": "Div ℤ",
  "name": "Int.instDivInt_1",
  "kind": "def",
  "doc_string":
  "Core Lean provides instances using T-rounding division, i.e. `Int.div` and `Int.mod`.\nWe override these here.\n",
  "args": ""},
 {"type":
  "{G : Type u_1} → {M : Type u_2} → [inst : Group G] → [inst_1 : Monoid M] → (G →* M) → G →* Mˣ",
  "name": "MonoidHom.toHomUnits",
  "kind": "def",
  "doc_string":
  "If `f` is a homomorphism from a group `G` to a monoid `M`,\nthen its image lies in the units of `M`,\nand `f.toHomUnits` is the corresponding monoid homomorphism from `G` to `Mˣ`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : MulZeroOneClass M] → [inst_1 : MulZeroOneClass N] → (M →*₀ N) → M → N",
  "name": "MonoidWithZeroHom.Simps.apply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type": "{c : Type u → Type v} → CategoryTheory.Bundled c → Type u",
  "name": "CategoryTheory.Bundled.α",
  "kind": "def",
  "doc_string": "The underlying type of the bundled type ",
  "args": ""},
 {"type":
  "{cont : Type u} →\n  {idx : Type v} →\n    {elem : Type w} →\n      {dom : cont → idx → Prop} → [self : GetElem cont idx elem dom] → (xs : cont) → (i : idx) → dom xs i → elem",
  "name": "GetElem.getElem",
  "kind": "def",
  "doc_string":
  "The syntax `arr[i]` gets the `i`'th element of the collection `arr`.\nIf there are proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\nThe actual behavior of this class is type-dependent,\nbut here are some important implementations:\n* `arr[i] : α` where `arr : Array α` and `i : Nat` or `i : USize`:\n  does array indexing with no bounds check and a proof side goal `i < arr.size`.\n* `l[i] : α` where `l : List α` and `i : Nat`: index into a list,\n  with proof side goal `i < l.length`.\n* `stx[i] : Syntax` where `stx : Syntax` and `i : Nat`: get a syntax argument,\n  no side goal (returns `.missing` out of range)\n\nThere are other variations on this syntax:\n* `arr[i]`: proves the proof side goal by `get_elem_tactic`\n* `arr[i]!`: panics if the side goal is false\n* `arr[i]?`: returns `none` if the side goal is false\n* `arr[i]'h`: uses `h` to prove the side goal\n",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "headStructureEtaReduce",
  "kind": "opaque",
  "doc_string":
  "Perform head-structure-eta-reduction on expression `e`. That is, if `e` is of the form\n`⟨f.1, f.2, ..., f.n⟩` with `f` definitionally equal to `e`, then\n`headStructureEtaReduce e = headStructureEtaReduce f` and `headStructureEtaReduce e = e` otherwise.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r →r s → α → β",
  "name": "RelHom.Simps.apply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α}, 1 ≤ a → 1 < b → 1 < a * b",
  "name": "Left.one_lt_mul_of_le_of_lt",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul_of_le_of_lt`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedSemifield α] (a : α), LinearOrderedSemifield.zpow 0 a = 1",
  "name": "LinearOrderedSemifield.zpow_zero'",
  "kind": "def",
  "doc_string": "`a ^ 0 = 1` ",
  "args": ""},
 {"type":
  "{α : Sort u} → (c : Prop) → [h : Decidable c] → (c → α) → (¬c → α) → α",
  "name": "dite",
  "kind": "def",
  "doc_string":
  "\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h => t(h)) (fun h => e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr ⟨i, h⟩` expects a proof `h : i < arr.size` in order to\navoid a bounds check, so you can write `if h : i < arr.size then arr.get ⟨i, h⟩ else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i < arr.size` from some other proposition that we are checking in the `if`.)\n",
  "args": ""},
 {"type": "{α : Type u} → [self : AndThen α] → α → (Unit → α) → α",
  "name": "AndThen.andThen",
  "kind": "def",
  "doc_string": "The implementation of `a >> b : α`. See `HAndThen`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : MulZeroClass R], IsLeftRegular 0 ↔ Subsingleton R",
  "name": "isLeftRegular_zero_iff_subsingleton",
  "kind": "theorem",
  "doc_string":
  "The element `0` is left-regular if and only if `R` is trivial. ",
  "args": ""},
 {"type": "CategoryTheory.LargeCategory CategoryTheory.RelCat",
  "name": "CategoryTheory.rel",
  "kind": "def",
  "doc_string": "The category of types with binary relations as morphisms. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_*>_»",
  "kind": "def",
  "doc_string":
  "If `x : F α` and `y : F β`, then `x *> y` evaluates `x`, then `y`,\nand returns the result of `y`.\n\nTo avoid surprising evaluation semantics, `y` is taken \"lazily\", using a\n`Unit → f β` function. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "MulZeroClass",
  "kind": "inductive",
  "doc_string":
  "Typeclass for expressing that a type `M₀` with multiplication and a zero satisfies\n`0 * a = 0` and `a * 0 = 0` for all `a : M₀`. ",
  "args": ""},
 {"type": "String → IO System.FilePath",
  "name": "Mathlib.getPackageDir",
  "kind": "def",
  "doc_string":
  "Returns the root directory which contains the package root file, e.g. `Mathlib.lean`. ",
  "args": ""},
 {"type": "{α : Sort u} → (α → Sort v) → Sort (max (max 1 u) v)",
  "name": "PSigma",
  "kind": "inductive",
  "doc_string":
  "`PSigma β`, also denoted `Σ' a : α, β a` or `(a : α) ×' β a`, is the type of dependent pairs\nwhose first component is `a : α` and whose second component is `b : β a`\n(so the type of the second component can depend on the value of the first component).\nIt differs from `Σ a : α, β a` in that it allows `α` and `β` to have arbitrary sorts\n`Sort u` and `Sort v`, instead of restricting to `Type u` and `Type v`. This means\nthat it can be used in situations where one side is a proposition, like `(p : Nat) ×' p = p`.\n\nThe reason this is not the default is that this type lives in the universe `Sort (max 1 u v)`,\nwhich can cause problems for universe level unification,\nbecause the equation `max 1 u v = ?u + 1` has no solution in level arithmetic.\n`PSigma` is usually only used in automation that constructs pairs of arbitrary types.\n",
  "args": ""},
 {"type": "Lean.Syntax → Lean.Elab.TermElabM Lean.Meta.ApplyConfig",
  "name": "Mathlib.Tactic.elabApplyConfig",
  "kind": "def",
  "doc_string":
  "An elaborator for translating a `Syntax` to an `ApplyConfig`. ",
  "args": ""},
 {"type": "Sat.Valuation → Sat.Literal → Prop → Prop",
  "name": "Sat.Literal.reify",
  "kind": "inductive",
  "doc_string": "Asserts that `¬⟦l⟧_v` implies `p`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u} [self : AddCommGroupWithOne R], NatCast.natCast 0 = 0",
  "name": "AddCommGroupWithOne.natCast_zero",
  "kind": "def",
  "doc_string": "The canonical map `ℕ → R` sends `0 : ℕ` to `0 : R`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : One α] {a : α} [self : Invertible a], ⅟a * a = 1",
  "name": "Invertible.invOf_mul_self",
  "kind": "def",
  "doc_string": "`invOf a` is a left inverse of `a` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : SemilatticeSup β] {f g : α → β} {s : Set α},\n  MonotoneOn f s → MonotoneOn g s → MonotoneOn (f ⊔ g) s",
  "name": "MonotoneOn.sup",
  "kind": "theorem",
  "doc_string":
  "Pointwise supremum of two monotone functions is a monotone function. ",
  "args": ""},
 {"type":
  "{ε σ α β : Type u} → EStateM ε σ α → (Unit → EStateM ε σ β) → EStateM ε σ β",
  "name": "EStateM.seqRight",
  "kind": "def",
  "doc_string": "The `seqRight` operation of the `EStateM` monad. ",
  "args": ""},
 {"type": "outParam (Type u) → (Type u → Type v) → Type v",
  "name": "MonadReader",
  "kind": "inductive",
  "doc_string":
  "Similar to `MonadReaderOf`, but `ρ` is an `outParam` for convenience. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "MonoidWithZero",
  "kind": "inductive",
  "doc_string":
  "A type `M₀` is a “monoid with zero” if it is a monoid with zero element, and `0` is left\nand right absorbing. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : SemilatticeInf β] {f g : α → β} {s : Set α},\n  AntitoneOn f s → AntitoneOn g s → AntitoneOn (f ⊓ g) s",
  "name": "AntitoneOn.inf",
  "kind": "theorem",
  "doc_string":
  "Pointwise infimum of two antitone functions is a antitone function. ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Semiring R] → Rˣ → AddAut R",
  "name": "AddAut.mulRight",
  "kind": "def",
  "doc_string":
  "Right multiplication by a unit of a semiring as an additive automorphism. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : LT α] → List α → List α → Prop",
  "name": "List.le",
  "kind": "def",
  "doc_string": "The lexicographic order on lists. ",
  "args": ""},
 {"type":
  "(ρ : Type u) → {m : Type u → Type v} → [inst : MonadReaderOf ρ m] → m ρ",
  "name": "readThe",
  "kind": "def",
  "doc_string":
  "Like `read`, but with `ρ` explicit. This is useful if a monad supports\n`MonadReaderOf` for multiple different types `ρ`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → (R : α → α → Prop) → [inst : DecidableRel R] → α → List α → List α",
  "name": "List.destutter'",
  "kind": "def",
  "doc_string":
  "Greedily create a sublist of `a :: l` such that, for every two adjacent elements `a, b`,\n`R a b` holds. Mostly used with ≠; for example, `destutter' (≠) 1 [2, 2, 1, 1] = [1, 2, 1]`,\n`destutter' (≠) 1, [2, 3, 3] = [1, 2, 3]`, `destutter' (<) 1 [2, 5, 2, 3, 4, 9] = [1, 2, 5, 9]`. ",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : Group G] → G → G ≃ G",
  "name": "Equiv.divLeft",
  "kind": "def",
  "doc_string": "A version of `Equiv.mulLeft a b⁻¹` that is defeq to `a / b`. ",
  "args": ""},
 {"type": "(α : Type u) → [inst : Mul α] → [inst : LE α] → Prop",
  "name": "ExistsMulOfLE",
  "kind": "inductive",
  "doc_string":
  "An `OrderCommMonoid` with one-sided 'division' in the sense that\nif `a ≤ b`, there is some `c` for which `a * c = b`. This is a weaker version\nof the condition on canonical orderings defined by `CanonicallyOrderedMonoid`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddRightCancelSemigroup R] (g : R), IsAddRightRegular g",
  "name": "isAddRightRegular_of_addRightCancelSemigroup",
  "kind": "theorem",
  "doc_string":
  "Elements of an add right cancel semigroup are add-right-regular",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Nonempty α] → (α → β) → Set α → β → α",
  "name": "Function.invFunOn",
  "kind": "def",
  "doc_string":
  "Construct the inverse for a function `f` on domain `s`. This function is a right inverse of `f`\non `f '' s`. For a computable version, see `Function.Injective.inv_of_mem_range`. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {α : ι → Type u_2} → (ι → ι → Prop) → ((i : ι) → α i → α i → Prop) → (i : ι) × α i → (i : ι) × α i → Prop",
  "name": "Sigma.Lex",
  "kind": "inductive",
  "doc_string":
  "The lexicographical order on a sigma type. It takes in a relation on the index type and a\nrelation for each summand. `a` is related to `b` iff their summands are related or they are in the\nsame summand and are related through the summand's relation. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : DistribLattice α] (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z",
  "name": "DistribLattice.le_sup_inf",
  "kind": "def",
  "doc_string": "The infimum distributes over the supremum ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Inhabited α] → List α → ℕ → α",
  "name": "List.getI",
  "kind": "def",
  "doc_string":
  "\"Inhabited\" `get` function: returns `default` instead of `none` in the case\nthat the index is out of bounds. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {F : Type u_3} →\n      {G : Type u_4} →\n        [inst : NonUnitalNonAssocSemiring R] →\n          [inst_1 : NonUnitalNonAssocSemiring S] →\n            [inst_2 : NonUnitalRingHomClass F R S] →\n              [inst_3 : NonUnitalRingHomClass G S R] →\n                (hom : F) →\n                  (inv : G) →\n                    NonUnitalRingHom.comp ↑inv ↑hom = NonUnitalRingHom.id R →\n                      NonUnitalRingHom.comp ↑hom ↑inv = NonUnitalRingHom.id S → R ≃+* S",
  "name": "RingEquiv.ofHomInv'",
  "kind": "def",
  "doc_string":
  "Construct an equivalence of rings from homomorphisms in both directions, which are inverses.\n",
  "args": ""},
 {"type":
  "{m : Type → Type u_1} → [inst : Monad m] → {α : Type u_2} → (α → α → m Unit) → List α → m Unit",
  "name": "List.mapDiagM'",
  "kind": "def",
  "doc_string":
  "`mapDiagM' f l` calls `f` on all elements in the upper triangular part of `l × l`.\nThat is, for each `e ∈ l`, it will run `f e e` and then `f e e'`\nfor each `e'` that appears after `e` in `l`.\n\nExample: suppose `l = [1, 2, 3]`. `mapDiagM' f l` will evaluate, in this order,\n`f 1 1`, `f 1 2`, `f 1 3`, `f 2 2`, `f 2 3`, `f 3 3`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : CancelCommMonoidWithZero α] → [inst_1 : NormalizationMonoid α] → α →*₀ α",
  "name": "normalize",
  "kind": "def",
  "doc_string":
  "Chooses an element of each associate class, by multiplying by `normUnit` ",
  "args": ""},
 {"type": "(α : Sort u) → (β : Sort u_1) → [inst : Unique α] → (α → β) ≃ β",
  "name": "Equiv.funUnique",
  "kind": "def",
  "doc_string":
  "If `α` has a unique term, then the type of function `α → β` is equivalent to `β`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : CancelCommMonoidWithZero α] → [self : NormalizationMonoid α] → α → αˣ",
  "name": "NormalizationMonoid.normUnit",
  "kind": "def",
  "doc_string":
  "`normUnit` assigns to each element of the monoid a unit of the monoid. ",
  "args": ""},
 {"type": "Substring → String.Pos",
  "name": "Substring.startPos",
  "kind": "def",
  "doc_string": "The byte position of the start of the string slice. ",
  "args": ""},
 {"type": "ZNum → ZNum → Ordering",
  "name": "ZNum.cmp",
  "kind": "def",
  "doc_string": "Ordering on `ZNum`s. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {F : Type u_3} →\n      [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [inst_2 : AddMonoidHomClass F M N] → F → M →+ N",
  "name": "AddMonoidHomClass.toAddMonoidHom",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `AddMonoidHomClass F M N` into an\nactual `MonoidHom`. This is declared as the default coercion from `F` to `M →+ N`.",
  "args": ""},
 {"type": "BoundedOrder Prop",
  "name": "Prop.boundedOrder",
  "kind": "def",
  "doc_string": "Propositions form a bounded order. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → (γ : Type u_3) → (γ → α × β) ≃ (γ → α) × (γ → β)",
  "name": "Equiv.arrowProdEquivProdArrow",
  "kind": "def",
  "doc_string":
  "The type of functions to a product `α × β` is equivalent to the type of pairs of functions\n`γ → α` and `γ → β`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {n : ℕ} → (α → β) → Vector α n → Vector β n",
  "name": "Vector.map",
  "kind": "def",
  "doc_string": "Map a vector under a function. ",
  "args": ""},
 {"type": "{α : Type u} → [self : ShiftRight α] → α → α → α",
  "name": "ShiftRight.shiftRight",
  "kind": "def",
  "doc_string": "The implementation of `a >>> b : α`. See `HShiftRight`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, IsCoatom a → a ⋖ ⊤",
  "name": "IsCoatom.covby_top",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `covby_top_iff`.",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : One M] → [inst_1 : One N] → OneHom M N → M → N",
  "name": "OneHom.toFun",
  "kind": "def",
  "doc_string": "The underlying function ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {G : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddCommGroup G] → Neg (M →+ G)",
  "name":
  "AddMonoidHom.instNegAddMonoidHomToAddZeroClassToAddMonoidToSubNegAddMonoidToAddGroup",
  "kind": "def",
  "doc_string":
  "If `f` is an additive monoid homomorphism to an additive commutative group, then `-f` is the\nhomomorphism sending `x` to `-(f x)`. ",
  "args": ""},
 {"type":
  "{C : Type u} → [inst : CategoryTheory.Category C] → {X Y : C} → (X ⟶ Y) → Prop",
  "name": "CategoryTheory.IsIso",
  "kind": "inductive",
  "doc_string": "`IsIso` typeclass expressing that a morphism is invertible. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM (Linarith.Ineq × Lean.Expr)",
  "name": "Linarith.parseCompAndExpr",
  "kind": "def",
  "doc_string":
  "`parseCompAndExpr e` checks if `e` is of the form `t < 0`, `t ≤ 0`, or `t = 0`.\nIf it is, it returns the comparison along with `t`.\n",
  "args": ""},
 {"type": "(R : Type u_1) → [inst : Mul R] → [inst_1 : Add R] → R ≃+* R",
  "name": "RingEquiv.refl",
  "kind": "def",
  "doc_string": "The identity map is a ring isomorphism. ",
  "args": ""},
 {"type":
  "{α : Sort u} → (β : α → Sort u_1) → [inst : Subsingleton α] → (a : α) → ((a' : α) → β a') ≃ β a",
  "name": "Equiv.piSubsingleton",
  "kind": "def",
  "doc_string":
  "If `α` is `Subsingleton` and `a : α`, then the type of dependent functions `Π (i : α), β i`\nis equivalent to `β a`. ",
  "args": ""},
 {"type": "Num → Num → Ordering",
  "name": "Num.cmp",
  "kind": "def",
  "doc_string": "Ordering of `Num`s. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Conv.withReducible",
  "kind": "def",
  "doc_string":
  "`with_reducible tacs` excutes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α},\n  a - c < b → a < b + c",
  "name": "lt_add_of_sub_right_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `sub_lt_iff_lt_add`.",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : CommRing R] {a b : R}, a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)",
  "name": "pow_four_add_four_mul_pow_four",
  "kind": "theorem",
  "doc_string":
  "Sophie Germain's identity, see <https://www.cut-the-knot.org/blue/SophieGermainIdentity.shtml>.\n",
  "args": ""},
 {"type": "∀ (r n : ℕ), Nat.choose n r ≤ Nat.choose n (n / 2)",
  "name": "Nat.choose_le_middle",
  "kind": "theorem",
  "doc_string": "`choose n r` is maximised when `r` is `n/2`. ",
  "args": ""},
 {"type": "ProjectionData → List ℕ",
  "name": "ProjectionData.projNrs",
  "kind": "def",
  "doc_string":
  "A list of natural numbers, which is the projection number(s) that have to be applied to the\nExpression. For example the list `[0, 1]` corresponds to applying the first projection of the\nstructure, and then the second projection of the resulting structure (this assumes that the\ntarget of the first projection is a structure with at least two projections).\nThe composition of these projections is required to be definitionally equal to the provided\nExpression. ",
  "args": ""},
 {"type": "(M₀ : Type u) → [inst : Mul M₀] → [inst : Zero M₀] → Prop",
  "name": "IsCancelMulZero",
  "kind": "inductive",
  "doc_string": "A mixin for cancellative multiplication by nonzero elements. ",
  "args": ""},
 {"type":
  "{α : Sort u} → {β₁ : α → Sort u_1} → {β₂ : α → Sort u_2} → ((a : α) → β₁ a ≃ β₂ a) → (a : α) ×' β₁ a ≃ (a : α) ×' β₂ a",
  "name": "Equiv.psigmaCongrRight",
  "kind": "def",
  "doc_string":
  "A family of equivalences `Π a, β₁ a ≃ β₂ a` generates an equivalence between `Σ' a, β₁ a` and\n`Σ' a, β₂ a`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Classical.«tacticBy_cases_:_»",
  "kind": "def",
  "doc_string":
  "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
  "args": ""},
 {"type":
  "{p : Prop} → Rand (SlimCheck.TestResult p) → ℕ → Rand (SlimCheck.TestResult p)",
  "name": "SlimCheck.retry",
  "kind": "def",
  "doc_string":
  "Execute `cmd` and repeat every time the result is `gave_up` (at most `n` times). ",
  "args": ""},
 {"type": "{α : Sort u} → [h : Nonempty α] → (α → Prop) → α",
  "name": "Classical.epsilon",
  "kind": "def",
  "doc_string": "the Hilbert epsilon Function ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {γ : Type w} →\n    [inst : NonUnitalCommSemiring α] →\n      [inst_1 : Zero γ] →\n        [inst_2 : Add γ] →\n          [inst_3 : Mul γ] →\n            [inst_4 : SMul ℕ γ] →\n              (f : γ → α) →\n                Function.Injective f →\n                  f 0 = 0 →\n                    (∀ (x y : γ), f (x + y) = f x + f y) →\n                      (∀ (x y : γ), f (x * y) = f x * f y) →\n                        (∀ (x : γ) (n : ℕ), f (n • x) = n • f x) → NonUnitalCommSemiring γ",
  "name": "Function.Injective.nonUnitalCommSemiring",
  "kind": "def",
  "doc_string":
  "Pullback a `NonUnitalCommSemiring` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u} → CoeSort (Set α) (Type u)",
  "name": "Set.instCoeSortSetType",
  "kind": "def",
  "doc_string": "Coercion from a set to the corresponding subtype. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {α : ι → Type u_2} → Set ι → ((i : ι) → Set (α i)) → Set ((i : ι) → α i)",
  "name": "Set.pi",
  "kind": "def",
  "doc_string":
  "Given an index set `ι` and a family of sets `t : Π i, set (α i)`, `pi s t`\nis the set of dependent functions `f : Πa, π a` such that `f a` belongs to `t a`\nwhenever `a ∈ s`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α},\n  1 < a → 1 < b → 1 < a * b",
  "name": "Right.one_lt_mul",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul`. ",
  "args": ""},
 {"type":
  "Type u_1 →\n  (α : outParam (Type u_2)) →\n    (β : outParam (Type u_3)) →\n      [inst : Preorder α] →\n        [inst : Preorder β] → [inst : MulZeroOneClass α] → [inst : MulZeroOneClass β] → Type (max (max u_1 u_2) u_3)",
  "name": "OrderMonoidWithZeroHomClass",
  "kind": "inductive",
  "doc_string":
  "`OrderMonoidWithZeroHomClass F α β` states that `F` is a type of\nordered monoid with zero homomorphisms.\n\nYou should also extend this typeclass when you extend `OrderMonoidWithZeroHom`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] {f : α → α} {p : α → Prop} {hf : ∀ (x : α), x ≤ f x} {hfp : ∀ (x : α), p (f x)}\n  {hmin : ∀ ⦃x y : α⦄, x ≤ y → p y → f x ≤ y} {x y : α},\n  x ≤ y → p y → ↑(ClosureOperator.mk₃ f p hf hfp hmin).toOrderHom x ≤ y",
  "name": "ClosureOperator.closure_le_mk₃_iff",
  "kind": "theorem",
  "doc_string":
  "Analogue of `closure_le_closed_iff_le` but with the `p` that was fed into the `mk₃` constructor.\n",
  "args": ""},
 {"type": "(α : Type u_1) → Dynamic → [inst : TypeName α] → Option α",
  "name": "Dynamic.get?",
  "kind": "opaque",
  "doc_string":
  "Retrieves the value stored in the `Dynamic`.\nReturns `some a` if the value has the right type, and `none` otherwise.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → {F : Type u_3} → [inst : One M] → [inst_1 : One N] → [inst_2 : OneHomClass F M N] → F → OneHom M N",
  "name": "OneHomClass.toOneHom",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `OneHomClass F M N` into an actual\n`OneHom`. This is declared as the default coercion from `F` to `OneHom M N`. ",
  "args": ""},
 {"type":
  "(R : Type u_1) →\n  (M : Type u_2) → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → R →+* AddMonoid.End M",
  "name": "Module.toAddMonoidEnd",
  "kind": "def",
  "doc_string":
  "`(•)` as an `AddMonoidHom`.\n\nThis is a stronger version of `DistribMulAction.toAddMonoidEnd` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, a < b → a - b < 0",
  "name": "sub_neg_of_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `sub_neg`.",
  "args": ""},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "name": "CoeTC",
  "kind": "inductive",
  "doc_string":
  "Auxiliary class implementing `Coe*`.\nUsers should generally not implement this directly.\n",
  "args": ""},
 {"type": "{α : Sort u_1} → {p q : α → Prop} → p = q → Subtype p ≃ Subtype q",
  "name": "Equiv.subtypeEquivProp",
  "kind": "def",
  "doc_string":
  "If two predicates are equal, then the corresponding subtypes are equivalent. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → [inst : Semiring R] → MulSemiringAction (RingAut R) R",
  "name": "RingAut.applyMulSemiringAction",
  "kind": "def",
  "doc_string":
  "The tautological action by the group of automorphism of a ring `R` on `R`.",
  "args": ""},
 {"type": "{α : Type u} → α → Array α",
  "name": "Array.mkArray1",
  "kind": "def",
  "doc_string": "Create array `#[a₁]` ",
  "args": ""},
 {"type": "ℚ → ℚ",
  "name": "Rat.sqrt",
  "kind": "def",
  "doc_string":
  "Square root function on rational numbers, defined by taking the (integer) square root of the\nnumerator and the square root (on natural numbers) of the denominator. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        [inst_2 : MulZeroOneClass α] → [inst_3 : MulZeroOneClass β] → (f : α →*₀o β) → (f' : α → β) → f' = ↑f → α →*o β",
  "name": "OrderMonoidWithZeroHom.copy",
  "kind": "def",
  "doc_string":
  "Copy of an `OrderMonoidWithZeroHom` with a new `toFun` equal to the old one. Useful to fix\ndefinitional equalities. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → Q(CommSemiring «$α») → Q(«$α») → Type",
  "name": "Mathlib.Tactic.Ring.ExSum",
  "kind": "inductive",
  "doc_string": "A polynomial expression, which is a sum of monomials. ",
  "args": ""},
 {"type":
  "∀ {R : Type u} [self : AddCommGroupWithOne R] (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)",
  "name": "AddCommGroupWithOne.intCast_negSucc",
  "kind": "def",
  "doc_string":
  "The canonical homorphism `ℤ → R` for negative values is just the negation of the values\nof the canonical homomorphism `ℕ → R`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {A : Type u_2} → [inst : Add M] → [inst_1 : SetLike A M] → [hA : AddMemClass A M] → (S' : A) → Add { x // x ∈ S' }",
  "name": "AddMemClass.add",
  "kind": "def",
  "doc_string":
  "An additive submagma of an additive magma inherits an addition.",
  "args": ""},
 {"type": "∀ {a b : Prop}, a ∧ b → b",
  "name": "And.right",
  "kind": "def",
  "doc_string":
  "Extract the right conjunct from a conjunction. `h : a ∧ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : TypeName α] → Lean.Name",
  "name": "TypeName.typeName",
  "kind": "opaque",
  "doc_string": "Returns a declaration name of the type.\n",
  "args": ""},
 {"type": "ByteArray → UInt64",
  "name": "ByteArray.toUInt64LE!",
  "kind": "def",
  "doc_string":
  "Interpret a `ByteArray` of size 8 as a little-endian `UInt64`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Rel α β → Set α → Set β",
  "name": "Rel.image",
  "kind": "def",
  "doc_string": "Image of a set under a relation ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → {x : MulZeroOneClass M} → {x_1 : MulZeroOneClass N} → Coe (M →*₀ N) (ZeroHom M N)",
  "name": "MonoidWithZeroHom.coeToZeroHom",
  "kind": "def",
  "doc_string":
  "`MonoidWithZeroHom` down-cast to a `ZeroHom`, forgetting the monoidal property. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : NonUnitalSemiring α] (a b c : α), a * b * c = a * (b * c)",
  "name": "NonUnitalSemiring.mul_assoc",
  "kind": "def",
  "doc_string": "Multiplication is associative ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 ≤ a → 0 ≤ b → 0 ≤ a + b",
  "name": "Left.add_nonneg",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_nonneg`.",
  "args": ""},
 {"type":
  "{M : Type u} → [inst : Monoid M] → (u : Mˣ) → (x : M) → {n : ℕ} → n ≠ 0 → x ^ n = ↑u → Mˣ",
  "name": "Units.ofPow",
  "kind": "def",
  "doc_string": "If a natural power of `x` is a unit, then `x` is a unit. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "EmptyCollection",
  "kind": "inductive",
  "doc_string":
  "`EmptyCollection α` is the typeclass which supports the notation `∅`, also written as `{}`. ",
  "args": ""},
 {"type":
  "∀ {a p k : ℕ}, Nat.Prime p → ¬a ∣ p ^ k → a ∣ p ^ (k + 1) → a = p ^ (k + 1)",
  "name": "Nat.eq_prime_pow_of_dvd_least_prime_pow",
  "kind": "theorem",
  "doc_string":
  "If `p` is prime,\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\nthen `a = p^(k+1)`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [self : PredOrder α] {a b : α}, a < b → a ≤ PredOrder.pred b",
  "name": "PredOrder.le_pred_of_lt",
  "kind": "def",
  "doc_string":
  "Proof that `pred` satifies ordering invariants betweeen `LT` and `LE`",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} (rα : α → α → Prop) (rβ : β → β → Prop), Prod.GameAdd rα rβ ≤ Prod.Lex rα rβ",
  "name": "Prod.gameAdd_le_lex",
  "kind": "theorem",
  "doc_string": "`GameAdd` is a subrelation of `Prod.Lex`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : NonUnitalRing α] (a b c : α), a * b * c = a * (b * c)",
  "name": "NonUnitalRing.mul_assoc",
  "kind": "def",
  "doc_string": "Multiplication is associative ",
  "args": ""},
 {"type":
  "(α : Type u_1) →\n  (β : Type u_2) →\n    [inst : Preorder α] →\n      [inst : Preorder β] → [inst : MulZeroOneClass α] → [inst : MulZeroOneClass β] → Type (max u_1 u_2)",
  "name": "OrderMonoidWithZeroHom",
  "kind": "inductive",
  "doc_string":
  "`OrderMonoidWithZeroHom α β` is the type of functions `α → β` that preserve\nthe `MonoidWithZero` structure.\n\n`OrderMonoidWithZeroHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →+ β)`,\nyou should parametrize over `(F : Type*) [OrderMonoidWithZeroHomClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderMonoidWithZeroHomClass`. ",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : Add G] → G → G → G",
  "name": "leftAdd",
  "kind": "def",
  "doc_string": "`left_add g` denotes left addition by `g`",
  "args": ""},
 {"type": "{α : Sort u} → {β : α → Sort v} → (self : PSigma β) → β self.fst",
  "name": "PSigma.snd",
  "kind": "def",
  "doc_string":
  "The second component of a dependent pair. If `p : Sigma β` then `p.2 : β p.1`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} →\n        (f : α → β) → [inst : IsAntisymm α r] → [inst : IsRefl β s] → (∀ (a b : α), s (f a) (f b) ↔ r a b) → r ↪r s",
  "name": "RelEmbedding.ofMapRelIff",
  "kind": "def",
  "doc_string":
  "To define an relation embedding from an antisymmetric relation `r` to a reflexive relation `s`\nit suffices to give a function together with a proof that it satisfies `s (f a) (f b) ↔ r a b`.\n",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : Monoid α] → (a : α) → [inst_1 : Invertible a] → αˣ",
  "name": "unitOfInvertible",
  "kind": "def",
  "doc_string": "An `invertible` element is a unit. ",
  "args": ""},
 {"type": "{α : Sort u_1} → Trunc α → α",
  "name": "Trunc.out",
  "kind": "def",
  "doc_string":
  "Noncomputably extract a representative of `Trunc α` (using the axiom of choice). ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "convert",
  "kind": "def",
  "doc_string":
  "The `exact e` and `refine e` tactics require a term `e` whose type is\ndefinitionally equal to the goal. `convert e` is similar to `refine e`,\nbut the type of `e` is not required to exactly match the\ngoal. Instead, new goals are created for differences between the type\nof `e` and the goal. For example, in the proof state\n\n```lean\nn : ℕ,\ne : prime (2 * n + 1)\n⊢ prime (n + n + 1)\n```\n\nthe tactic `convert e` will change the goal to\n\n```lean\n⊢ n + n = 2 * n\n```\n\nIn this example, the new goal can be solved using `ring`.\n\nThe `convert` tactic applies congruence lemmas eagerly before reducing,\ntherefore it can fail in cases where `exact` succeeds:\n```lean\ndef p (n : ℕ) := true\nexample (h : p 0) : p 1 := by exact h -- succeeds\nexample (h : p 0) : p 1 := by convert h -- fails, with leftover goal `1 = 0`\n```\n\nIf `x y : t`, and an instance `Subsingleton t` is in scope, then any goals of the form\n`x = y` are solved automatically.\n\nThe syntax `convert ← e` will reverse the direction of the new goals\n(producing `⊢ 2 * n = n + n` in this example).\n\nInternally, `convert e` works by creating a new goal asserting that\nthe goal equals the type of `e`, then simplifying it using\n`congr'`. The syntax `convert e using n` can be used to control the\ndepth of matching (like `congr' n`). In the example, `convert e using\n1` would produce a new goal `⊢ n + n + 1 = 2 * n + 1`.\n",
  "args": ""},
 {"type": "Q(Prop) → Lean.MetaM Bool",
  "name": "Mathlib.Tactic.Tauto.casesMatcher",
  "kind": "def",
  "doc_string":
  "Matches propositions where we want to apply the `cases` tactic\nin the core loop of `tauto`. ",
  "args": ""},
 {"type": "Bool → Num → Num",
  "name": "Num.bit",
  "kind": "def",
  "doc_string":
  "`bit b n` appends the bit `b` to the end of `n`, where `bit tt x = x1` and `bit ff x = x0`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [inst : AddMonoid M] →\n        [inst_1 : AddAction M α] →\n          [inst_2 : VAdd M β] →\n            (f : β → α) → Function.Injective f → (∀ (c : M) (x : β), f (c +ᵥ x) = c +ᵥ f x) → AddAction M β",
  "name": "Function.Injective.addAction",
  "kind": "def",
  "doc_string":
  "Pullback an additive action along an injective map respecting `+ᵥ`.",
  "args": ""},
 {"type": "∀ {v : Sat.Valuation}, Sat.Clause.reify v Sat.Clause.nil True",
  "name": "Sat.Clause.reify_zero",
  "kind": "theorem",
  "doc_string":
  "The reification of the empty clause is `True`: `¬⟦⊥⟧_v ≡ True`. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Polyrith.Poly → Lean.Format",
  "name": "Mathlib.Tactic.Polyrith.Poly.format",
  "kind": "def",
  "doc_string":
  "This converts a poly object into a string representing it. The string\nmaintains the semantic structure of the poly object.\n\nThe output of this function must be valid Python syntax, and it assumes the variables `varN` from\n`scripts/polyrith.py.`\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (f : AddHom M N) (s : Set M),\n  AddSubsemigroup.map f (AddSubsemigroup.closure s) = AddSubsemigroup.closure (↑f '' s)",
  "name": "AddHom.map_mclosure",
  "kind": "theorem",
  "doc_string":
  "The image under an `AddSemigroup` hom of the `AddSubsemigroup` generated by a set\nequals the `AddSubsemigroup` generated by the image of the set.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Sort u_2} [inst : ConditionallyCompleteLattice α] {f g : ι → α},\n  BddAbove (Set.range g) → (∀ (x : ι), f x ≤ g x) → supᵢ f ≤ supᵢ g",
  "name": "csupᵢ_mono",
  "kind": "theorem",
  "doc_string":
  "The indexed supremum of two functions are comparable if the functions are pointwise comparable",
  "args": ""},
 {"type":
  "∀ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : One M] [inst_1 : One N] [inst_2 : One P]\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f)",
  "name": "OneHom.comp_assoc",
  "kind": "theorem",
  "doc_string": "Composition of monoid homomorphisms is associative. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {p q : Prop} {s : p → q → α}, (⨆ h₁, ⨆ h₂, s h₁ h₂) = ⨆ h, s (_ : p) (_ : q)",
  "name": "supᵢ_and'",
  "kind": "theorem",
  "doc_string":
  "The symmetric case of `supᵢ_and`, useful for rewriting into a supremum over a conjunction ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.RingNF.Context → Lean.Meta.Simp.Result → Lean.Meta.SimpM Lean.Meta.Simp.Result",
  "name": "Mathlib.Tactic.RingNF.Context.simp",
  "kind": "def",
  "doc_string":
  "A cleanup routine, which simplifies normalized polynomials to a more human-friendly\nformat. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "CategoryTheory.reassoc",
  "kind": "def",
  "doc_string":
  "Given an equation `f = g` between morphisms `X ⟶ Y` in a category (possibly after a `∀` binder),\nproduce the equation `∀ {Z} (h : Y ⟶ Z), f ≫ h = g ≫ h`,\nbut with compositions fully right associated and identities removed.\n",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  (M : ι → Type u_2) → [inst : (j : ι) → Add (M j)] → [inst_1 : Subsingleton ι] → (i : ι) → ((j : ι) → M j) ≃+ M i",
  "name": "AddEquiv.piSubsingleton",
  "kind": "def",
  "doc_string":
  "A family indexed by a nonempty subsingleton type is\nequivalent to the element at the single index.",
  "args": ""},
 {"type": "{α : Sort u_1} → Nonempty α → α",
  "name": "Nonempty.some",
  "kind": "def",
  "doc_string":
  "Using `Classical.choice`, extracts a term from a `Nonempty` type. ",
  "args": ""},
 {"type": "∀ {M : Type u} [self : AddZeroClass M] (a : M), 0 + a = a",
  "name": "AddZeroClass.zero_add",
  "kind": "def",
  "doc_string": "Zero is a left neutral element for addition ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        (F : C ⥤ D) →\n          [inst_2 : CategoryTheory.Full F] →\n            [inst_3 : CategoryTheory.Faithful F] →\n              {X Y : C} → (Prefunctor.obj F.toPrefunctor X ≅ Prefunctor.obj F.toPrefunctor Y) → (X ≅ Y)",
  "name": "CategoryTheory.Functor.preimageIso",
  "kind": "def",
  "doc_string":
  "If `F : C ⥤ D` is fully faithful, every isomorphism `F.obj X ≅ F.obj Y` has a preimage. ",
  "args": ""},
 {"type":
  "∀ {A : Type u_2} {B : Type u_1} [i : SetLike A B] {p q : A}, (∀ (x : B), x ∈ p ↔ x ∈ q) → p = q",
  "name": "SetLike.ext",
  "kind": "theorem",
  "doc_string":
  "Note: implementers of `SetLike` must copy this lemma in order to tag it with `@[ext]`. ",
  "args": ""},
 {"type": "{α : Type u} → {s : Set α} → Set.Nontrivial s → α × α",
  "name": "Set.Nontrivial.choose",
  "kind": "def",
  "doc_string":
  "Extract witnesses from s.nontrivial. This function might be used instead of case analysis on the\nargument. Note that it makes a proof depend on the classical.choice axiom. ",
  "args": ""},
 {"type": "∀ {α : Type u} {s : Set α}, Set.Nonempty s ↔ s ≠ ∅",
  "name": "Set.nonempty_iff_ne_empty",
  "kind": "theorem",
  "doc_string": "See also `Set.not_nonempty_iff_eq_empty`. ",
  "args": ""},
 {"type": "{α : Type u_1} → α → (β : Type u_2) → β ↪ α × β",
  "name": "Function.Embedding.sectr",
  "kind": "def",
  "doc_string": "Fixing an element `a : α` gives an embedding `β ↪ α × β`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop}, Function.Injective fun f => ↑f",
  "name": "RelHom.coe_fn_injective",
  "kind": "theorem",
  "doc_string": "The map `coe_fn : (r →r s) → (α → β)` is injective. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Zify.zify",
  "kind": "def",
  "doc_string":
  "The `zify` tactic is used to shift propositions from `ℕ` to `ℤ`.\nThis is often useful since `ℤ` has well-behaved subtraction.\n```\nexample (a b c x y z : ℕ) (h : ¬ x*y*z < 0) : c < a + 3*b := by\n  zify\n  zify at h\n  /-\n  h : ¬↑x * ↑y * ↑z < 0\n  ⊢ ↑c < ↑a + 3 * ↑b\n  -/\n```\n`zify` can be given extra lemmas to use in simplification. This is especially useful in the\npresence of nat subtraction: passing `≤` arguments will allow `push_cast` to do more work.\n```\nexample (a b c : ℕ) (h : a - b < c) (hab : b ≤ a) : false := by\n  zify [hab] at h\n  /- h : ↑a - ↑b < ↑c -/\n```\n`zify` makes use of the `@[zify_simps]` attribute to move propositions,\nand the `push_cast` tactic to simplify the `ℤ`-valued expressions.\n`zify` is in some sense dual to the `lift` tactic. `lift (z : ℤ) to ℕ` will change the type of an\ninteger `z` (in the supertype) to `ℕ` (the subtype), given a proof that `z ≥ 0`;\npropositions concerning `z` will still be over `ℤ`. `zify` changes propositions about `ℕ` (the\nsubtype) to propositions about `ℤ` (the supertype), without changing the type of any variable.\n",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Order.Frame",
  "kind": "inductive",
  "doc_string":
  "A frame, aka complete Heyting algebra, is a complete lattice whose `⊓` distributes over `⨆`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → (s : β → β → Prop) → {a : α} → ¬r a a → s ↪r Prod.Lex r s",
  "name": "RelEmbedding.prodLexMkLeft",
  "kind": "def",
  "doc_string": "`λ b, Prod.mk a b` as a relation embedding. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {p : β → Prop} → [inst : DecidablePred p] → α ≃ Subtype p → Equiv.Perm α →* Equiv.Perm β",
  "name": "Equiv.Perm.extendDomainHom",
  "kind": "def",
  "doc_string": "`extendDomain` as a group homomorphism ",
  "args": ""},
 {"type": "∀ {α : Type u_1} {R : α → α → Prop} {a : α}, List.Chain R a []",
  "name": "List.Chain.nil",
  "kind": "def",
  "doc_string": "A chain of length 1 is trivially a chain. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_∧_»",
  "kind": "def",
  "doc_string":
  "`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n",
  "args": ""},
 {"type":
  "(α : Type u_1) →\n  [i₁ : LinearOrder α] →\n    [i₂ : OrderBot α] → [h : IsWellOrder α fun x x_1 => x < x_1] → ConditionallyCompleteLinearOrderBot α",
  "name": "IsWellOrder.conditionallyCompleteLinearOrderBot",
  "kind": "def",
  "doc_string":
  "A well founded linear order is conditionally complete, with a bottom element. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → WithTop α → WithTop β",
  "name": "WithTop.map",
  "kind": "def",
  "doc_string":
  "Lift a map `f : α → β` to `WithTop α → WithTop β`. Implemented using `Option.map`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : Monoid α] → (a b : α) → [inst_1 : Invertible a] → [inst_2 : Invertible b] → Invertible (a * b)",
  "name": "invertibleMul",
  "kind": "def",
  "doc_string": "`⅟b * ⅟a` is the inverse of `a * b` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Mul M] →\n      [inst_1 : Mul N] → (f : M →ₙ* N) → (M' : Subsemigroup M) → { x // x ∈ M' } →ₙ* { x // x ∈ Subsemigroup.map f M' }",
  "name": "MulHom.subsemigroupMap",
  "kind": "def",
  "doc_string":
  "The `MulHom` from a subsemigroup to its image.\nSee `MulEquiv.subsemigroupMap` for a variant for `MulEquiv`s. ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Mul M] → M ≃* M",
  "name": "MulEquiv.refl",
  "kind": "def",
  "doc_string": "The identity map is a multiplicative isomorphism. ",
  "args": ""},
 {"type": "{α : Type u_1} → (r : α → α → Prop) → r ≼i r",
  "name": "InitialSeg.refl",
  "kind": "def",
  "doc_string": "The identity function shows that `≼i` is reflexive ",
  "args": ""},
 {"type": "PosNum → PosNum → PosNum",
  "name": "PosNum.add",
  "kind": "def",
  "doc_string": "Addition of two `PosNum`s. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Add α] → VAdd α α",
  "name": "Add.toVAdd",
  "kind": "def",
  "doc_string": "See also `AddMonoid.toAddAction`",
  "args": ""},
 {"type": "Linarith.LinarithConfig → Bool",
  "name": "Linarith.LinarithConfig.exfalso",
  "kind": "def",
  "doc_string":
  "Prove goals which are not linear comparisons by first calling `exfalso`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] {a b : α}, a < b → ¬a ⋖ b → ∃ c, a < c ∧ c < b",
  "name": "LT.lt.exists_lt_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of `exists_lt_lt_of_not_covby`.",
  "args": ""},
 {"type": "List String → List String",
  "name": "ToAdditive.fixAbbreviation",
  "kind": "def",
  "doc_string":
  "There are a few abbreviations we use. For example \"Nonneg\" instead of \"ZeroLE\"\nor \"addComm\" instead of \"commAdd\".\nNote: The input to this function is case sensitive!\nTodo: A lot of abbreviations here are manual fixes and there might be room to\n      improve the naming logic to reduce the size of `fixAbbreviation`.\n",
  "args": ""},
 {"type":
  "{ρ : Type u} → {m : Type u → Type v} → [self : MonadReaderOf ρ m] → m ρ",
  "name": "MonadReaderOf.read",
  "kind": "def",
  "doc_string": "`(← read) : ρ` reads the state out of monad `m`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α},\n  1 < a → 1 ≤ b → 1 < a * b",
  "name": "Right.one_lt_mul_of_lt_of_le",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul_of_lt_of_le`. ",
  "args": ""},
 {"type": "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
  "name": "Function.isFixedPt_id",
  "kind": "theorem",
  "doc_string": "Every point is a fixed point of `id`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Xor",
  "kind": "inductive",
  "doc_string":
  "The homogeneous version of `HXor`: `a ^^^ b : α` where `a b : α`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    {M' : Type u_3} →\n      [inst : MonoidWithZero R] →\n        [inst_1 : Zero M] →\n          [inst_2 : MulActionWithZero R M] →\n            [inst_3 : Zero M'] →\n              [inst_4 : SMul R M'] →\n                (f : ZeroHom M M') →\n                  Function.Surjective ↑f → (∀ (a : R) (b : M), ↑f (a • b) = a • ↑f b) → MulActionWithZero R M'",
  "name": "Function.Surjective.mulActionWithZero",
  "kind": "def",
  "doc_string":
  "Pushforward a `MulActionWithZero` structure along a surjective zero-preserving homomorphism.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ},\n  Function.Injective2 f → ∀ [inst : Nonempty β], Function.Injective f",
  "name": "Function.Injective2.left'",
  "kind": "theorem",
  "doc_string":
  "As a map from the left argument to a unary function, `f` is injective. ",
  "args": ""},
 {"type":
  "∀ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R]\n  [inst_2 : DivisionRing S] [inst_3 : Module R E] [inst_4 : Module S E] (n : ℕ) (x : E), (↑n)⁻¹ • x = (↑n)⁻¹ • x",
  "name": "inv_nat_cast_smul_eq",
  "kind": "theorem",
  "doc_string":
  "If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\nagree on inverses of natural numbers in `R` and `S`. ",
  "args": ""},
 {"type": "(n : ℕ) → List { y // WellFoundedRelation.rel y n }",
  "name": "SlimCheck.Nat.shrink",
  "kind": "def",
  "doc_string":
  "`Nat.shrink' n` creates a list of smaller natural numbers by\nsuccessively dividing `n` by 2 . For example, `Nat.shrink 5 = [2, 1, 0]`. ",
  "args": ""},
 {"type":
  "{R : Type x} →\n  {S : Type u_1} →\n    [inst : Distrib R] →\n      [inst_1 : Add S] →\n        [inst_2 : Mul S] →\n          (f : R → S) →\n            Function.Surjective f →\n              (∀ (x y : R), f (x + y) = f x + f y) → (∀ (x y : R), f (x * y) = f x * f y) → Distrib S",
  "name": "Function.Surjective.distrib",
  "kind": "def",
  "doc_string":
  "Pushforward a `Distrib` instance along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type u_1} →\n    [inst : StrictOrderedSemiring α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Pow β ℕ] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : NatCast β] →\n                    (f : β → α) →\n                      Function.Injective f →\n                        f 0 = 0 →\n                          f 1 = 1 →\n                            (∀ (x y : β), f (x + y) = f x + f y) →\n                              (∀ (x y : β), f (x * y) = f x * f y) →\n                                (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                  (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                    (∀ (n : ℕ), f ↑n = ↑n) → StrictOrderedSemiring β",
  "name": "Function.Injective.strictOrderedSemiring",
  "kind": "def",
  "doc_string": "Pullback a `StrictOrderedSemiring` under an injective map. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : α → Type u_2} → (s : (a : α) → Set (β a)) → ↑(Set.pi Set.univ s) ≃ ((a : α) → ↑(s a))",
  "name": "Equiv.Set.univPi",
  "kind": "def",
  "doc_string": "The set `Set.pi Set.univ s` is equivalent to `Π a, s a`. ",
  "args": ""},
 {"type":
  "{α : Type u} → (s : Set α) → (t : α → Prop) → ↑{ x | x ∈ s ∧ t x } ≃ ↑{ x | t ↑x }",
  "name": "Equiv.Set.sep",
  "kind": "def",
  "doc_string":
  "The set `{x ∈ s | t x}` is equivalent to the set of `x : s` such that `t x`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {n : ℤ}, n ≠ 0 → Function.Injective fun x => n • x",
  "name": "zsmul_right_injective",
  "kind": "theorem",
  "doc_string":
  "See also `smul_right_injective`. TODO: provide a `NoZeroSMulDivisors` instance. We can't do\nthat here because importing that definition would create import cycles.",
  "args": ""},
 {"type":
  "Mathlib.Meta.NormNum.NormNumExt →\n  {u : Lean.Level} → {α : Q(Type u)} → (e : Q(«$α»)) → Lean.MetaM (Mathlib.Meta.NormNum.Result e)",
  "name": "Mathlib.Meta.NormNum.NormNumExt.eval",
  "kind": "def",
  "doc_string":
  "Attempts to prove an expression is equal to some explicit number of the relevant type. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {W : α → Sort w} →\n      {Z : β → Sort z} → (h₁ : α ≃ β) → ((b : β) → W (↑(Equiv.symm h₁) b) ≃ Z b) → ((a : α) → W a) ≃ ((b : β) → Z b)",
  "name": "Equiv.piCongr'",
  "kind": "def",
  "doc_string":
  "Transport dependent functions through\nan equivalence of the base spaces and a family\nof equivalences of the matching fibres.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : IsUpperModularLattice α] {a b : α}, a ⊓ b ⋖ b → a ⋖ a ⊔ b",
  "name": "Covby.sup_of_inf_right",
  "kind": "theorem",
  "doc_string": "**Alias** of `covby_sup_of_inf_covby_right`.",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Sort u_2} → (α → β) → β → Option α",
  "name": "Function.partialInv",
  "kind": "def",
  "doc_string":
  "We can use choice to construct explicitly a partial inverse for\na given injective function `f`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → α → α → Set α",
  "name": "Set.Ioc",
  "kind": "def",
  "doc_string": "Left-open right-closed interval ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, Codisjoint a a → a = ⊤",
  "name": "Codisjoint.eq_top_of_self",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `codisjoint_self`.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CommMonoidWithZero",
  "kind": "inductive",
  "doc_string":
  "A type `M` is a commutative “monoid with zero” if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : AddMonoid α] → DistribMulAction (AddMonoid.End α) α",
  "name": "AddMonoid.End.applyDistribMulAction",
  "kind": "def",
  "doc_string":
  "The tautological action by `AddMonoid.End α` on `α`.\n\nThis generalizes `Function.End.applyMulAction`. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} {a b : α} {l : List α}, a ∈ b :: l → a = b ∨ a ∈ l",
  "name": "List.eq_or_mem_of_mem_cons",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `List.mem_cons`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} {f : α → α} {x : α}, Function.IsFixedPt f x → f x = x",
  "name": "Function.IsFixedPt.eq",
  "kind": "theorem",
  "doc_string":
  "If `x` is a fixed point of `f`, then `f x = x`. This is useful, e.g., for `rw` or `simp`.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : LinearOrderedAddCommMonoid M] →\n    {A : Type u_2} →\n      [inst_1 : SetLike A M] → [inst : AddSubmonoidClass A M] → (S : A) → LinearOrderedAddCommMonoid { x // x ∈ S }",
  "name": "AddSubmonoidClass.toLinearOrderedAddCommMonoid",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of a `LinearOrderedAddCommMonoid` is a `LinearOrderedAddCommMonoid`.",
  "args": ""},
 {"type": "{α : Type} → (xs : List α) → 0 < List.length xs → SlimCheck.Gen α",
  "name": "SlimCheck.Gen.elements",
  "kind": "def",
  "doc_string": "Given a list of examples, choose one to create an example. ",
  "args": ""},
 {"type": "{α : Type u} → [self : LinearOrderedCommGroup α] → DecidableEq α",
  "name": "LinearOrderedCommGroup.decidable_eq",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "{e : Q(ℕ)} → Mathlib.Tactic.Ring.ExtractCoeff e → Q(ℕ)",
  "name": "Mathlib.Tactic.Ring.ExtractCoeff.e'",
  "kind": "def",
  "doc_string":
  "The result of extracting the coefficient is a monic monomial. ",
  "args": ""},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "name": "CoeOut",
  "kind": "inductive",
  "doc_string":
  "`CoeOut α β` is for coercions that are applied from left-to-right.\n",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} {inst : Zero β} {inst_1 : LE β} [self : NonnegHomClass F α β] (f : F)\n  (a : α), 0 ≤ ↑f a",
  "name": "NonnegHomClass.map_nonneg",
  "kind": "def",
  "doc_string": "the image of any element is non negative. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : MulZeroOneClass M] → [inst : MulZeroOneClass N] → Type (max u_1 u_2)",
  "name": "MonoidWithZeroHom",
  "kind": "inductive",
  "doc_string":
  "`M →*₀ N` is the type of functions `M → N` that preserve\nthe `MonoidWithZero` structure.\n\n`MonoidWithZeroHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M →*₀ N)`,\nyou should parametrize over `(F : Type*) [MonoidWithZeroHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `MonoidWithZeroHomClass`.\n",
  "args": ""},
 {"type":
  "∀ {t : Type u → Type u} [inst : Traversable t] [self : IsLawfulTraversable t] {α β : Type u} (f : α → β) (x : t α),\n  traverse (pure ∘ f) x = id.mk (f <$> x)",
  "name": "IsLawfulTraversable.traverse_eq_map_id",
  "kind": "def",
  "doc_string": "An axiom for `traverse` involving `pure : β → Id β`. ",
  "args": ""},
 {"type":
  "(Type u₁ → Type u₂) →\n  (ρ : Type u) → (α : outParam (Type v)) → outParam (Membership α ρ) → Type (max (max (max u (u₁ + 1)) u₂) v)",
  "name": "ForIn'",
  "kind": "inductive",
  "doc_string":
  "`ForIn' m ρ α d` is a variation on the `ForIn m ρ α` typeclass which supports the\n`for h : x in xs` notation. It is the same as `for x in xs` except that `h : x ∈ xs`\nis provided as an additional argument to the body of the for-loop.\n",
  "args": ""},
 {"type":
  "Lean.Meta.TransparencyMode → Linarith.ExprMap → Lean.Expr → Lean.MetaM (Linarith.ExprMap × Linarith.Sum)",
  "name": "Linarith.linearFormOfExpr",
  "kind": "opaque",
  "doc_string":
  "`linearFormOfExpr red map e` computes the linear form of `e`.\n\n`map` is a lookup map from atomic expressions to variable numbers.\nIf a new atomic expression is encountered, it is added to the map with a new number.\nIt matches atomic expressions up to reducibility given by `red`.\n\nBecause it matches up to definitional equality, this function must be in the `MetaM` monad,\nand forces some functions that call it into `MetaM` as well.\n",
  "args": ""},
 {"type": "∀ {α : Type u} [self : Semiring α] (a : α), 1 * a = a",
  "name": "Semiring.one_mul",
  "kind": "def",
  "doc_string": "One is a left neutral element for multiplication ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : DistribLattice α] →\n    [inst_1 : BoundedOrder α] → (himp : α → α → α) → (∀ (a b c : α), a ≤ himp b c ↔ a ⊓ b ≤ c) → HeytingAlgebra α",
  "name": "HeytingAlgebra.ofHImp",
  "kind": "def",
  "doc_string":
  "Construct a Heyting algebra from the lattice structure and Heyting implication alone. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : Preorder α] → [inst : Preorder β] → Type (max u_1 u_2)",
  "name": "OrderHom",
  "kind": "inductive",
  "doc_string": "Bundled monotone (aka, increasing) function ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "BooleanAlgebra",
  "kind": "inductive",
  "doc_string":
  "A Boolean algebra is a bounded distributive lattice with a complement operator `ᶜ` such that\n`x ⊓ xᶜ = ⊥` and `x ⊔ xᶜ = ⊤`. For convenience, it must also provide a set difference operation `\\`\nand a Heyting implication `⇨` satisfying `x \\ y = x ⊓ yᶜ` and `x ⇨ y = y ⊔ xᶜ`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `BoundedOrder`, `OrderBot`, and `OrderTop` are mixins that require `LE`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `Bot` and `Top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `BoundedOrder` is provided.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        (f : M →+ N) → (N' : AddSubmonoid N) → { x // x ∈ AddSubmonoid.comap f N' } →+ { x // x ∈ N' }",
  "name": "AddMonoidHom.addSubmonoidComap",
  "kind": "def",
  "doc_string":
  "the `AddMonoidHom` from the preimage of an additive submonoid to itself.",
  "args": ""},
 {"type": "Type",
  "name": "Num",
  "kind": "inductive",
  "doc_string":
  "The type of nonnegative binary numbers, using `PosNum`.\n\n13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one))) ",
  "args": ""},
 {"type": "∀ {α : Type u_1} (f : Set α → α), ¬Function.Injective f",
  "name": "Function.cantor_injective",
  "kind": "theorem",
  "doc_string":
  "**Cantor's diagonal argument** implies that there are no injective functions from `Set α`\nto `α`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : PredOrder α] [inst_2 : Preorder β] {f : α → β},\n  Antitone f → Pairwise (Disjoint on fun n => Set.Ioc (f n) (f (Order.pred n)))",
  "name": "Antitone.pairwise_disjoint_on_Ioc_pred",
  "kind": "theorem",
  "doc_string":
  "If `α` is a linear pred order, `β` is a preorder, and `f : α → β` is an antitone function, then\nthe intervals `Set.Ioc (f n) (f (Order.pred n))` are pairwise disjoint. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : Mul S] {a x y : S}, SemiconjBy a x y → a * x = y * a",
  "name": "SemiconjBy.eq",
  "kind": "theorem",
  "doc_string": "Equality behind `SemiconjBy a x y`; useful for rewriting. ",
  "args": ""},
 {"type":
  "∀ {V : Type u_1} [inst : Quiver V] [self : Quiver.HasInvolutiveReverse V] {a b : V} (f : a ⟶ b),\n  Quiver.reverse (Quiver.reverse f) = f",
  "name": "Quiver.HasInvolutiveReverse.inv'",
  "kind": "def",
  "doc_string": "`reverse` is involutive ",
  "args": ""},
 {"type": "{α : Type u_1} → Lex α ≃ α",
  "name": "ofLex",
  "kind": "def",
  "doc_string": "`ofLex` is the identity function from the `lex` of a type.  ",
  "args": ""},
 {"type": "{α : Type u_1} → α → Multiset α → Prop",
  "name": "Multiset.Mem",
  "kind": "def",
  "doc_string": "`a ∈ s` means that `a` has nonzero multiplicity in `s`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Option α → β → (α → β) → β",
  "name": "Option.casesOn'",
  "kind": "def",
  "doc_string":
  "Given an element of `a : option α`, a default element `b : β` and a function `α → β`, apply this\nfunction to `a` if it comes from `α`, and return `b` otherwise. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : LinearOrderedCommGroupWithZero α] → ℤ → α → α",
  "name": "LinearOrderedCommGroupWithZero.zpow",
  "kind": "def",
  "doc_string":
  "The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) ",
  "args": ""},
 {"type":
  "∀ {R : Type x} [inst : NonUnitalNonAssocRing R] {a b : R}, Commute a b → a * a - b * b = (a + b) * (a - b)",
  "name": "Commute.mul_self_sub_mul_self_eq",
  "kind": "theorem",
  "doc_string":
  "Representation of a difference of two squares of commuting elements as a product. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (f : α → β) → (y : β) × { x // f x = y } ≃ α",
  "name": "Equiv.sigmaFiberEquiv",
  "kind": "def",
  "doc_string":
  "`sigmaFiberEquiv f` for `f : α → β` is the natural equivalence between\nthe type of all fibres of `f` and the total space `α`. ",
  "args": ""},
 {"type":
  "{M : Type u} → [inst : Monoid M] → (x : M) → (n : ℕ) → x ^ n = 1 → n ≠ 0 → Invertible x",
  "name": "invertibleOfPowEqOne",
  "kind": "def",
  "doc_string": "If `x ^ n = 1` then `x` has an inverse, `x^(n - 1)`. ",
  "args": ""},
 {"type": "(α : Type u_1) → { x // Option.isSome x = true } ≃ α",
  "name": "Equiv.optionIsSomeEquiv",
  "kind": "def",
  "doc_string":
  "The set of `x : Option α` such that `isSome x` is equivalent to `α`. ",
  "args": ""},
 {"type": "∀ {α : Type u} (b : ULift α), { down := b.down } = b",
  "name": "ULift.up_down",
  "kind": "theorem",
  "doc_string": "Bijection between `α` and `ULift.{v} α` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → AddSubmonoid M → AddSubmonoid N → AddSubmonoid (M × N)",
  "name": "AddSubmonoid.prod",
  "kind": "def",
  "doc_string":
  "Given `AddSubmonoid`s `s`, `t` of `AddMonoid`s `A`, `B` respectively, `s × t`\nas an `AddSubmonoid` of `A × B`.",
  "args": ""},
 {"type":
  "∀ (M : Type u_2) {α : Type u_1} [inst : AddMonoid M] [inst_1 : AddAction M α], (fun x x_1 => x +ᵥ x_1) 0 = id",
  "name": "zero_vadd_eq_id",
  "kind": "theorem",
  "doc_string": "`VAdd` version of `zero_add_eq_id`",
  "args": ""},
 {"type":
  "∀ {M : Type u} [inst : Monoid M] (x : M) (n : ℕ), { unop := x ^ n } = { unop := x } ^ n",
  "name": "MulOpposite.op_pow",
  "kind": "theorem",
  "doc_string": "Moving to the opposite monoid commutes with taking powers. ",
  "args": ""},
 {"type": "Type",
  "name": "ZNum",
  "kind": "inductive",
  "doc_string":
  "Representation of integers using trichotomy around zero.\n\n13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one)))\n-13 = -1101(base 2) = neg (bit1 (bit0 (bit1 one))) ",
  "args": ""},
 {"type": "∀ {R : Type u} [self : CommSemiring R] (a b : R), a * b = b * a",
  "name": "CommSemiring.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type": "Sort u_1 → Prop",
  "name": "IsEmpty",
  "kind": "inductive",
  "doc_string": "`IsEmpty α` expresses that `α` is empty. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1],\n  Antitone f → Antitone g → Antitone fun x => f x * g x",
  "name": "Antitone.mul'",
  "kind": "theorem",
  "doc_string": "The product of two antitone functions is antitone. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : PartialOrder α] →\n    [inst_1 : SuccOrder α] →\n      {C : α → Sort u_2} →\n        (b : α) → ((a : α) → ¬IsMax a → C (Order.succ a)) → ((a : α) → Order.IsSuccLimit a → C a) → C b",
  "name": "Order.isSuccLimitRecOn",
  "kind": "def",
  "doc_string":
  "A value can be built by building it on successors and successor limits. ",
  "args": ""},
 {"type":
  "{ε σ α δ : Type u} → [inst : EStateM.Backtrackable δ σ] → EStateM ε σ α → (Unit → EStateM ε σ α) → EStateM ε σ α",
  "name": "EStateM.orElse",
  "kind": "def",
  "doc_string":
  "Implementation of `orElse` for `EStateM` where the state is `Backtrackable`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (lt : α → α → Bool) → BinaryHeap α lt",
  "name": "BinaryHeap.empty",
  "kind": "def",
  "doc_string": "`O(1)`. Build a new empty heap. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\n  (x y : R), ↑e (x + y) = ↑e x + ↑e y",
  "name": "RingEquiv.map_add",
  "kind": "theorem",
  "doc_string": "A ring isomorphism preserves addition. ",
  "args": ""},
 {"type":
  "{C : Type u₁} → [inst : CategoryTheory.Category C] → (Z : C → Prop) → CategoryTheory.FullSubcategory Z ⥤ C",
  "name": "CategoryTheory.fullSubcategoryInclusion",
  "kind": "def",
  "doc_string":
  "The forgetful functor from a full subcategory into the original category\n(\"forgetting\" the condition).\n",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "name": "congrArg",
  "kind": "theorem",
  "doc_string":
  "Congruence in the function argument: if `a₁ = a₂` then `f a₁ = f a₂` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`<something containing a₁> = <something containing a₂>`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
  "args": ""},
 {"type": "Simps.Config → List Lean.Name",
  "name": "Simps.Config.notRecursive",
  "kind": "def",
  "doc_string":
  "List of types in which we are not recursing to generate simplification lemmas.\nE.g. if we write `@[simps] def e : α × β ≃ β × α := ...` we will generate `e_apply` and not\n`e_apply_fst`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Monoid α] → MulAction αᵐᵒᵖ α",
  "name": "Monoid.toOppositeMulAction",
  "kind": "def",
  "doc_string": "Like `Monoid.toMulAction`, but multiplies on the right. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (Option α → β → γ) → List α → List β → List γ",
  "name": "List.zipWithRight",
  "kind": "def",
  "doc_string":
  "Right-biased version of `List.zipWith`. `zipWithRight f as bs` applies `f` to each\npair `aᵢ ∈ as` and `bᵢ ‌∈ bs`. If `as` is shorter than `bs`, `f` is applied to\n`none` for the remaining `bᵢ`.\n```\nzipWithRight prod.mk [1, 2] ['a'] = [(some 1, 'a')]\nzipWithRight prod.mk [1] ['a', 'b'] = [(some 1, 'a'), (none, 'b')]\nzipWithRight f as bs = (zipWithRight' f as bs).fst\n```\n",
  "args": ""},
 {"type":
  "{C : Type u₁} → {Z : C → Prop} → CategoryTheory.FullSubcategory Z → C",
  "name": "CategoryTheory.FullSubcategory.obj",
  "kind": "def",
  "doc_string": "The category of which this is a full subcategory",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} → {γ : Type w} → [inst : Inhabited α] → [inst : Inhabited β] → (α → β → γ) → List α → List β → List γ",
  "name": "List.Func.pointwise",
  "kind": "def",
  "doc_string":
  "Pointwise operations on lists. If lists are different lengths, use the default element. ",
  "args": ""},
 {"type": "PosNum → Bool",
  "name": "PosNum.isOne",
  "kind": "def",
  "doc_string": "Returns a boolean for whether the `PosNum` is `one`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Mul α] [inst_1 : LE α]\n  [inst_2 : ContravariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b c : α}, a * b ≤ a * c → b ≤ c",
  "name": "OrderedCommGroup.le_of_mul_le_mul_left",
  "kind": "theorem",
  "doc_string": "**Alias** of `le_of_mul_le_mul_left'`.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "termMax_prec",
  "kind": "def",
  "doc_string":
  "`max:prec` as a term. It is equivalent to `eval_prec max` for `eval_prec` defined at `Meta.lean`.\nWe use `max_prec` to workaround bootstrapping issues.\n",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Function.End",
  "kind": "def",
  "doc_string":
  "The monoid of endomorphisms.\n\nNote that this is generalized by `CategoryTheory.End` to categories other than `Type u`. ",
  "args": ""},
 {"type": "ParsedProjectionData → Bool",
  "name": "ParsedProjectionData.isPrefix",
  "kind": "def",
  "doc_string": "is the projection name a prefix? ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} {M : Type u_2} {inst : One M} {inst_1 : SetLike S M} [self : OneMemClass S M] (s : S), 1 ∈ s",
  "name": "OneMemClass.one_mem",
  "kind": "def",
  "doc_string":
  "By definition, if we have `OneMemClass S M`, we have `1 ∈ s` for all `s : S`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {F : Type u_3} →\n      [inst : Add M] → [inst_1 : Add N] → [inst_2 : AddHomClass F M N] → (f : F) → Function.Bijective ↑f → M ≃+ N",
  "name": "AddEquiv.ofBijective",
  "kind": "def",
  "doc_string": "A bijective `AddSemigroup` homomorphism is an isomorphism",
  "args": ""},
 {"type": "{R : Type u} → [inst : Semiring R] → IsField R → Semifield R",
  "name": "IsField.toSemifield",
  "kind": "def",
  "doc_string": "Transferring from `IsField` to `Semifield`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (β → α) → (α → β) → Set α → Set β → Prop",
  "name": "Set.InvOn",
  "kind": "def",
  "doc_string": "`g` is an inverse to `f` viewed as a map from `a` to `b` ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HVAdd α β γ] → α → β → γ",
  "name": "HVAdd.hVAdd",
  "kind": "def",
  "doc_string":
  "`a +ᵥ b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ≃+* S),\n  (↑f).toEquiv = (↑f).toEquiv",
  "name": "RingEquiv.toEquiv_commutes",
  "kind": "theorem",
  "doc_string": "The two paths coercion can take to an `Equiv` are equivalent ",
  "args": ""},
 {"type": "{α : Type u} → [self : Neg α] → α → α",
  "name": "Neg.neg",
  "kind": "def",
  "doc_string":
  "`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : CancelMonoidWithZero α] [inst_1 : Nontrivial α], FaithfulSMul α α",
  "name": "CancelMonoidWithZero.faithfulSMul",
  "kind": "def",
  "doc_string":
  "`Monoid.toMulAction` is faithful on nontrivial cancellative monoids with zero. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "List.tacticSizeOf_list_dec",
  "kind": "def",
  "doc_string":
  "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
  "args": ""},
 {"type": "{α : Type u_1} → Array (Array α) → Array α",
  "name": "Array.flatten",
  "kind": "def",
  "doc_string":
  "Turns `#[#[a₁, a₂, ⋯], #[b₁, b₂, ⋯], ⋯]` into `#[a₁, a₂, ⋯, b₁, b₂, ⋯]` ",
  "args": ""},
 {"type":
  "Lean.MVarId → (Lean.Expr → Lean.MetaM Bool) → optParam Bool false → Lean.MetaM (List Lean.MVarId)",
  "name": "Mathlib.Tactic.constructorMatching",
  "kind": "def",
  "doc_string":
  "Core tactic for `constructorm`. Calls `constructor` on all subgoals for which\n`matcher ldecl.type` returns true.\n* `recursive`: if true, it calls itself repeatedly on the resulting subgoals\n",
  "args": ""},
 {"type": "∀ {n m : ℕ}, n < m → ↑n < ↑m",
  "name": "Int.ofNat_lt_ofNat_of_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `Int.ofNat_lt`.",
  "args": ""},
 {"type": "Lean.Expr → Lean.Elab.Tactic.TacticM Unit → Lean.MetaM Lean.Expr",
  "name": "synthesizeUsing",
  "kind": "def",
  "doc_string":
  "`synthesizeUsing type tac` synthesizes an element of `type` using tactic `tac`.\n\nThe tactic `tac` may leave goals open, these remain as metavariables in the returned expression.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 0 = 0",
  "name": "RingHom.map_zero",
  "kind": "theorem",
  "doc_string": "Ring homomorphisms map zero to zero. ",
  "args": ""},
 {"type": "ℕ → Linarith.Sum",
  "name": "Linarith.var",
  "kind": "def",
  "doc_string":
  "A single variable `n` is represented by a sum with coefficient `1` and monomial `n`. ",
  "args": ""},
 {"type": "∀ {R : Type u_1} [inst : AddZeroClass R], IsAddRegular 0",
  "name": "isAddRegular_zero",
  "kind": "theorem",
  "doc_string": "If adding `0` on either side is the identity, `0` is regular.",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_*_»",
  "kind": "def",
  "doc_string":
  "`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → {S : Type u_2} → [inst : CommRing R] → [inst : CommRing S] → CommRing (R × S)",
  "name": "Prod.instCommRingProd",
  "kind": "def",
  "doc_string": "Product of two commutative rings is a commutative ring. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_ˣ»",
  "kind": "def",
  "doc_string":
  "Units of a `Monoid`, bundled version. Notation: `αˣ`.\n\nAn element of a `Monoid` is a unit if it has a two-sided inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `IsUnit`. ",
  "args": ""},
 {"type": "Type u",
  "name": "PNonScalar",
  "kind": "inductive",
  "doc_string":
  "`PNonScalar` is a type that is not a scalar value in our runtime.\nIt is used as a stand-in for an arbitrary boxed value to avoid excessive\nmonomorphization, and it is only created using `unsafeCast`. It is somewhat\nanalogous to C `void*` in usage, but the type itself is not special.\n\nThis is the universe-polymorphic version of `PNonScalar`; it is preferred to use\n`NonScalar` instead where applicable.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«tacticRename_bvar_→___»",
  "kind": "def",
  "doc_string":
  "* `rename_bvar old new` renames all bound variables named `old` to `new` in the target.\n* `rename_bvar old new at h` does the same in hypothesis `h`.\n\n```lean\nexample (P : ℕ →  ℕ → Prop) (h : ∀ n, ∃ m, P n m) : ∀ l, ∃ m, P l m :=\nbegin\n  rename_bvar n q at h, -- h is now ∀ (q : ℕ), ∃ (m : ℕ), P q m,\n  rename_bvar m n, -- target is now ∀ (l : ℕ), ∃ (n : ℕ), P k n,\n  exact h -- Lean does not care about those bound variable names\nend\n```\nNote: name clashes are resolved automatically.\n",
  "args": ""},
 {"type": "(G : Type u_1) → [inst : DivisionCommMonoid G] → G ≃* G",
  "name": "MulEquiv.inv",
  "kind": "def",
  "doc_string":
  "In a `DivisionCommMonoid`, `Equiv.inv` is a `MulEquiv`. There is a variant of this\n`MulEquiv.inv' G : G ≃* Gᵐᵒᵖ` for the non-commutative case. ",
  "args": ""},
 {"type": "{α : Sort u} → (β : Sort v) → α → β → α",
  "name": "Function.const",
  "kind": "def",
  "doc_string":
  "The constant function. If `a : α`, then `Function.const β a : β → α` is the\n\"constant function with value `a`\", that is, `Function.const β a b = a`.\n```\nexample (b : Bool) : Function.const Bool 10 b = 10 :=\n  rfl\n\n#check Function.const Bool 10\n-- Bool → Nat\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Semigroup α] (x y : α), ((fun x_1 => x * x_1) ∘ fun x => y * x) = fun x_1 => x * y * x_1",
  "name": "comp_mul_left",
  "kind": "theorem",
  "doc_string":
  "Composing two multiplications on the left by `y` then `x`\nis equal to a multiplication on the left by `x * y`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Monoid α] {p : α}, Irreducible p → ¬IsUnit p",
  "name": "Irreducible.not_unit",
  "kind": "def",
  "doc_string": "`p` is not a unit ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : LinearOrderedCommSemiring α] → DecidableEq α",
  "name": "LinearOrderedCommSemiring.decidable_eq",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "∀ {a b c : Prop}, a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c",
  "name": "and_or_left",
  "kind": "theorem",
  "doc_string": "`∧` distributes over `∨` (on the left). ",
  "args": ""},
 {"type": "Simps.Config → Option Lean.Name",
  "name": "Simps.Config.addAdditive",
  "kind": "def",
  "doc_string":
  "[TODO] Add `@[to_additive]` to all generated lemmas. This can be set by marking the\ndeclaration with the `@[to_additive]` attribute before the `@[simps]` attribute ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ},\n  Function.Injective2 f → ∀ [inst : Nonempty α], Function.Injective fun b a => f a b",
  "name": "Function.Injective2.right'",
  "kind": "theorem",
  "doc_string":
  "As a map from the right argument to a unary function, `f` is injective. ",
  "args": ""},
 {"type":
  "{α : Type u} → (s t : Set α) → [inst : DecidablePred fun x => x ∈ s] → ↑(s ∪ t) ⊕ ↑(s ∩ t) ≃ ↑s ⊕ ↑t",
  "name": "Equiv.Set.unionSumInter",
  "kind": "def",
  "doc_string":
  "If `s` is a set with decidable membership, then the sum of `s ∪ t` and `s ∩ t` is equivalent\nto `s ⊕ t`. ",
  "args": ""},
 {"type":
  "{B : Type u_1} → {B' : Type u_2} → (B' → B) → (B → Type u_3) → B' → Type u_3",
  "name": "Bundle.Pullback",
  "kind": "def",
  "doc_string":
  "The pullback of a bundle `E` over a base `B` under a map `f : B' → B`, denoted by `Pullback f E`\nor `f *ᵖ E`,  is the bundle over `B'` whose fiber over `b'` is `E (f b')`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {δ : Type w} → (α → β → δ) → LazyList α → LazyList β → LazyList δ",
  "name": "LazyList.map₂",
  "kind": "def",
  "doc_string":
  "Maps a binary function over two lazy list.\nLike `lazy_list.zip`, the result is only as long as the smaller input.\n",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {M : Type u_2} {N : Type u_3} {inst : MulOneClass M} {inst_1 : MulOneClass N}\n  [self : MonoidHomClass F M N] (f : F), ↑f 1 = 1",
  "name": "MonoidHomClass.map_one",
  "kind": "def",
  "doc_string": "The proposition that the function preserves 1 ",
  "args": ""},
 {"type": "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c",
  "name": "Eq.trans",
  "kind": "theorem",
  "doc_string":
  "Equality is transitive: if `a = b` and `b = c` then `a = c`.\n\nBecause this is in the `Eq` namespace, if you variables or expressions\n`h₁ : a = b` and `h₂ : b = c`, you can use `h₁.trans h₂ : a = c` as shorthand\nfor `Eq.trans h₁ h₂`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
  "args": ""},
 {"type": "Sort u → Sort (max 1 u)",
  "name": "Erased",
  "kind": "def",
  "doc_string":
  "`Erased α` is the same as `α`, except that the elements\nof `Erased α` are erased in the VM in the same way as types\nand proofs. This can be used to track data without storing it\nliterally. ",
  "args": ""},
 {"type": "∀ {α : Type u} {s : Set α}, Set.Nontrivial s → Nontrivial ↑s",
  "name": "Set.Nontrivial.coe_sort",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Set.nontrivial_coe_sort`.",
  "args": ""},
 {"type": "{α : Type u} → [inst : NonUnitalNonAssocSemiring α] → ULift α ≃+* α",
  "name": "ULift.ringEquiv",
  "kind": "def",
  "doc_string": "The ring equivalence between `ULift α` and `α`.",
  "args": ""},
 {"type": "Type",
  "name": "Bool",
  "kind": "inductive",
  "doc_string":
  "`Bool` is the type of boolean values, `true` and `false`. Classically,\nthis is equivalent to `Prop` (the type of propositions), but the distinction\nis important for programming, because values of type `Prop` are erased in the\ncode generator, while `Bool` corresponds to the type called `bool` or `boolean`\nin most programming languages.\n",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.Context → Lean.Level",
  "name": "Mathlib.Tactic.Abel.Context.univ",
  "kind": "def",
  "doc_string": "The universe level for `α`. ",
  "args": ""},
 {"type":
  "(H : Type u_1) → [inst : MulOneClass H] → Multiplicative (Additive H) ≃* H",
  "name": "MulEquiv.multiplicativeAdditive",
  "kind": "def",
  "doc_string": "`Multiplicative (Additive H)` is just `H`. ",
  "args": ""},
 {"type":
  "Lean.Meta.TransparencyMode →\n  Linarith.ExprMap →\n    List Lean.Expr →\n      Linarith.Map Linarith.Monom ℕ → Lean.MetaM (List Linarith.Comp × Linarith.ExprMap × Linarith.Map Linarith.Monom ℕ)",
  "name": "Linarith.toCompFold",
  "kind": "def",
  "doc_string":
  "`toCompFold red e_map exprs monom_map` folds `toComp` over `exprs`,\nupdating `e_map` and `monom_map` as it goes.\n ",
  "args": ""},
 {"type": "{α : Type u_1} → [self : SupSet α] → Set α → α",
  "name": "SupSet.supₛ",
  "kind": "def",
  "doc_string": "Supremum of a set ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u₃} →\n          [inst_2 : CategoryTheory.Category E] →\n            (F : C → D) →\n              [inst_3 : CategoryTheory.Functorial F] →\n                (G : D → E) → [inst_4 : CategoryTheory.Functorial G] → CategoryTheory.Functorial (G ∘ F)",
  "name": "CategoryTheory.functorial_comp",
  "kind": "def",
  "doc_string": "`G ∘ F` is a functorial if both `F` and `G` are.\n",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : NonUnitalNonAssocSemiring R] → R → R →+ R",
  "name": "AddMonoidHom.mulRight",
  "kind": "def",
  "doc_string":
  "Right multiplication by an element of a (semi)ring is an `AddMonoidHom` ",
  "args": ""},
 {"type":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} → [inst : Preorder α] → [inst_1 : Preorder β] → [inst_2 : OrderHomClass F α β] → F → α →o β",
  "name": "OrderHomClass.toOrderHom",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `OrderHomClass F α β` into an actual\n`OrderHomClass`. This is declared as the default coercion from `F` to `α →o β`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α}, IsGLB s a → BddBelow s",
  "name": "IsGLB.bddBelow",
  "kind": "theorem",
  "doc_string": "If `s` has a greatest lower bound, then it is bounded below. ",
  "args": ""},
 {"type": "Sat.Fmla → Sat.Clause → Prop",
  "name": "Sat.Fmla.proof",
  "kind": "def",
  "doc_string": "`f.proof c` asserts that `c` is derivable from `f`. ",
  "args": ""},
 {"type": "{α : Sort u_1} → [inst : DecidableEq α] → α → α → Equiv.Perm α",
  "name": "Equiv.swap",
  "kind": "def",
  "doc_string":
  "`swap a b` is the permutation that swaps `a` and `b` and\nleaves other values as is. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → b = a",
  "name": "LE.le.antisymm'",
  "kind": "theorem",
  "doc_string": "**Alias** of `ge_antisymm`.",
  "args": ""},
 {"type": "Lean.Elab.Tactic.Tactic",
  "name": "Mathlib.Tactic.evalNthRewriteSeq",
  "kind": "def",
  "doc_string":
  "`nth_rewrite` is a variant of `rewrite` that only changes the nth occurrence of the expression\nto be rewritten.\n\nNote: The occurrences are counted beginning with `1` and not `0`, this is different than in\nmathlib3. The translation will be handled by mathport. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {A : Type u_2} →\n    {B : Type u_3} →\n      [inst : Monoid M] →\n        [inst_1 : Monoid A] →\n          [inst_2 : MulDistribMulAction M A] →\n            [inst_3 : Monoid B] →\n              [inst_4 : SMul M B] →\n                (f : A →* B) →\n                  Function.Surjective ↑f → (∀ (c : M) (x : A), ↑f (c • x) = c • ↑f x) → MulDistribMulAction M B",
  "name": "Function.Surjective.mulDistribMulAction",
  "kind": "def",
  "doc_string":
  "Pushforward a multiplicative distributive multiplicative action along a surjective monoid\nhomomorphism.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] {a b : α}, a ⋖ b → ↑OrderDual.toDual b ⋖ ↑OrderDual.toDual a",
  "name": "Covby.toDual",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `toDual_covby_toDual_iff`.",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : AddMonoid α] → AddAction αᵃᵒᵖ α",
  "name": "AddMonoid.toOppositeAddAction",
  "kind": "def",
  "doc_string": "Like `AddMonoid.toAddAction`, but adds on the right.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Parser.Attr.field_simps",
  "kind": "def",
  "doc_string":
  "The simpset `field_simps` is used by the tactic `field_simp` to\nreduce an expression in a field to an expression of the form `n / d` where `n` and `d` are\ndivision-free. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : PredOrder α] [inst_2 : Preorder β] {f : α → β},\n  Monotone f → Pairwise (Disjoint on fun n => Set.Ioo (f (Order.pred n)) (f n))",
  "name": "Monotone.pairwise_disjoint_on_Ioo_pred",
  "kind": "theorem",
  "doc_string":
  "If `α` is a linear pred order, `β` is a preorder, and `f : α → β` is a monotone function, then\nthe intervals `Set.Ioo (f Order.pred n) (f n)` are pairwise disjoint. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Monoid M] →\n      [inst_1 : Monoid N] →\n        {s : Set M} →\n          (f : M → N) →\n            Submonoid.closure s = ⊤ → f 1 = 1 → (∀ (x : M), x ∈ s → ∀ (y : M), f (x * y) = f x * f y) → M →* N",
  "name": "MonoidHom.ofClosureMEqTopLeft",
  "kind": "def",
  "doc_string":
  "Let `s` be a subset of a monoid `M` such that the closure of `s` is the whole monoid.\nThen `MonoidHom.ofClosureEqTopLeft` defines a monoid homomorphism from `M` asking for\na proof of `f (x * y) = f x * f y` only for `x ∈ s`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : IsEmpty α] → Unique (Set α)",
  "name": "Set.uniqueEmpty",
  "kind": "def",
  "doc_string": "There is exactly one set of a type that is empty. ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → {γ : Sort w} → α ≃ β → β ≃ γ → α ≃ γ",
  "name": "Equiv.trans",
  "kind": "def",
  "doc_string": "Composition of equivalences `e₁ : α ≃ β` and `e₂ : β ≃ γ`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Set.termΙ",
  "kind": "def",
  "doc_string":
  "`Ι a b` denotes the open-closed interval with unordered bounds. Here, `Ι` is a capital iota,\ndistinguished from a capital `i`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : DecidableEq α] → List α → List α → List α",
  "name": "List.union",
  "kind": "def",
  "doc_string":
  "Constructs the union of two lists, by inserting the elements of `l₁` in reverse order to `l₂`.\nAs a result, `l₂` will always be a suffix, but only the last occurrence of each element in `l₁`\nwill be retained (but order will otherwise be preserved).\n",
  "args": ""},
 {"type": "{α : Sort u} → α → α → Prop",
  "name": "EmptyRelation",
  "kind": "def",
  "doc_string": "An empty relation does not relate any elements. ",
  "args": ""},
 {"type": "Bool × ℕ ≃ ℕ",
  "name": "Equiv.boolProdNatEquivNat",
  "kind": "def",
  "doc_string":
  "An equivalence between `Bool × ℕ` and `ℕ`, by mapping `(true, x)` to `2 * x + 1` and\n`(false, x)` to `2 * x`. ",
  "args": ""},
 {"type":
  "{G : Type u_1} → [inst : One G] → [inst : Mul G] → [inst : Inv G] → List G → G",
  "name": "List.alternatingProd",
  "kind": "def",
  "doc_string": "The alternating product of a list. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    (α : Type u_3) → [inst : Monoid M] → [inst_1 : MulAction M α] → [inst_2 : Monoid N] → (N →* M) → MulAction N α",
  "name": "MulAction.compHom",
  "kind": "def",
  "doc_string":
  "A multiplicative action of `M` on `α` and a monoid homomorphism `N → M` induce\na multiplicative action of `N` on `α`.\n\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → {β : Type u_2} → [inst : Zero β] → Function.Surjective 0 → Unique β",
  "name": "uniqueOfSurjectiveZero",
  "kind": "def",
  "doc_string": "If the zero function is surjective, the codomain is trivial.",
  "args": ""},
 {"type": "Type u → Type u → Type u → Type u",
  "name": "EStateM.Result",
  "kind": "inductive",
  "doc_string":
  "`Result ε σ α` is equivalent to `Except ε α × σ`, but using a single\ncombined inductive yields a more efficient data representation.\n",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {s₁ : Setoid α} {s₂ : Setoid β} {s₃ : Setoid γ}\n  {p : Quotient s₁ → Quotient s₂ → Quotient s₃ → Prop} (q₁ : Quotient s₁) (q₂ : Quotient s₂) (q₃ : Quotient s₃),\n  (∀ (a₁ : α) (a₂ : β) (a₃ : γ), p (Quotient.mk'' a₁) (Quotient.mk'' a₂) (Quotient.mk'' a₃)) → p q₁ q₂ q₃",
  "name": "Quotient.inductionOn₃'",
  "kind": "theorem",
  "doc_string":
  "A version of `Quotient.inductionOn₃` taking `{s₁ : Setoid α} {s₂ : Setoid β} {s₃ : Setoid γ}`\nas implicit arguments instead of instance arguments. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α) → List α → List α",
  "name": "List.modifyLast",
  "kind": "def",
  "doc_string": "Apply `f` to the last element of `l`, if it exists. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] (self : M →* N) (x y : M),\n  ↑↑self (x * y) = ↑↑self x * ↑↑self y",
  "name": "MonoidHom.map_mul'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves multiplication ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Option α ≃ Option β → α ≃ β",
  "name": "Equiv.removeNone",
  "kind": "def",
  "doc_string":
  "Given an equivalence between two `Option` types, eliminate `none` from that equivalence by\nmapping `e.symm none` to `e none`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → [inst : NonUnitalNonAssocSemiring R] → R →+ AddMonoid.End R",
  "name": "AddMonoid.End.mulRight",
  "kind": "def",
  "doc_string":
  "The right multiplication map: `(a, b) ↦ b * a`. See also `AddMonoidHom.mulRight`. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_2} {M₀ : Type u_1} [inst : MonoidWithZero M₀] [inst_1 : MonoidWithZeroHomClass F ℚ M₀] {f g : F},\n  ↑f (-1) = ↑g (-1) → (∀ (n : ℕ), 0 < n → ↑f ↑n = ↑g ↑n) → f = g",
  "name": "MonoidWithZeroHom.ext_rat_on_pnat",
  "kind": "theorem",
  "doc_string":
  "Positive integer values of a morphism `φ` and its value on `-1` completely determine `φ`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : LinearOrderedCommRing R] (a b : R), 2 * a * b ≤ a ^ 2 + b ^ 2",
  "name": "two_mul_le_add_pow_two",
  "kind": "theorem",
  "doc_string": "**Alias** of `two_mul_le_add_sq`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 < a → 0 < b → 0 < a + b",
  "name": "Left.add_pos'",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_pos'`.",
  "args": ""},
 {"type": "Mathlib.Tactic.RingNF.Context → Lean.Meta.Simp.Context",
  "name": "Mathlib.Tactic.RingNF.Context.ctx",
  "kind": "def",
  "doc_string":
  "A basically empty simp context, passed to the `simp` traversal in `RingNF.rewrite`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        (f : M →+ N) → {g : N → M} → Function.LeftInverse g ↑f → M ≃+ { x // x ∈ AddMonoidHom.mrange f }",
  "name": "AddEquiv.ofLeftInverse'",
  "kind": "def",
  "doc_string":
  "An additive monoid homomorphism `f : M →+ N` with a left-inverse `g : N → M`\ndefines an additive equivalence between `M` and `f.mrange`.\nThis is a bidirectional version of `AddMonoidHom.mrange_restrict`. ",
  "args": ""},
 {"type": "{α β : Sort u_1} → α = β → α ≃ β",
  "name": "Equiv.cast",
  "kind": "def",
  "doc_string": "Equivalence between equal types. ",
  "args": ""},
 {"type": "ParsedProjectionData → Bool",
  "name": "ParsedProjectionData.isChanged",
  "kind": "def",
  "doc_string": "is this a projection that is changed by the user? ",
  "args": ""},
 {"type":
  "{M₀ : Type u_1} →\n  {M₀' : Type u_2} →\n    [inst : CancelCommMonoidWithZero M₀] →\n      [inst_1 : Zero M₀'] →\n        [inst_2 : Mul M₀'] →\n          [inst_3 : One M₀'] →\n            [inst_4 : Pow M₀' ℕ] →\n              (f : M₀' → M₀) →\n                Function.Injective f →\n                  f 0 = 0 →\n                    f 1 = 1 →\n                      (∀ (x y : M₀'), f (x * y) = f x * f y) →\n                        (∀ (x : M₀') (n : ℕ), f (x ^ n) = f x ^ n) → CancelCommMonoidWithZero M₀'",
  "name": "Function.Injective.cancelCommMonoidWithZero",
  "kind": "def",
  "doc_string":
  "Pullback a `CancelCommMonoidWithZero` along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Antitone f → Monotone (↑OrderDual.toDual ∘ f)",
  "name": "Antitone.dual_right",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `monotone_toDual_comp_iff`.",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → [self : CoeSort α β] → α → β",
  "name": "CoeSort.coe",
  "kind": "def",
  "doc_string":
  "Coerces a value of type `α` to `β`, which must be a universe. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α}, 1 < a → 1 < b → 1 < a * b",
  "name": "one_lt_mul'",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.one_lt_mul`.",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → List α",
  "name": "List.erasePTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `eraseP`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : α → Sort v} → {p : (a : α) → β a → Prop} → { f // ∀ (a : α), p a (f a) } ≃ ((a : α) → { b // p a b })",
  "name": "Equiv.subtypePiEquivPi",
  "kind": "def",
  "doc_string":
  "The type of functions `f : ∀ a, β a` such that for all `a` we have `p a (f a)` is equivalent\nto the type of functions `∀ a, {b : β a // p a b}`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → {β : Type u_2} → (bs : Set β) → { f // ∀ (a : α), ↑f a ∈ bs } ≃ (α ↪ ↑bs)",
  "name": "Equiv.codRestrict",
  "kind": "def",
  "doc_string":
  "Embeddings whose range lies within a set are equivalent to embeddings to that set.\nThis is `Function.Embedding.codRestrict` as an equiv. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → (M →ₙ* N) ≃ (Mᵐᵒᵖ →ₙ* Nᵐᵒᵖ)",
  "name": "MulHom.op",
  "kind": "def",
  "doc_string":
  "A semigroup homomorphism `M →ₙ* N` can equivalently be viewed as a semigroup homomorphism\n`Mᵐᵒᵖ →ₙ* Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β} {f : α → β} {f' : β → α},\n  Set.InvOn f' f s t → Set.MapsTo f s t → Set.MapsTo f' t s → Set.BijOn f s t",
  "name": "Set.InvOn.bijOn",
  "kind": "theorem",
  "doc_string":
  "If functions `f'` and `f` are inverse on `s` and `t`, `f` maps `s` into `t`, and `f'` maps `t`\ninto `s`, then `f` is a bijection between `s` and `t`. The `maps_to` arguments can be deduced from\n`surj_on` statements using `left_inv_on.maps_to` and `right_inv_on.maps_to`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_++_»",
  "kind": "def",
  "doc_string":
  "`a ++ b` is the result of concatenation of `a` and `b`, usually read \"append\".\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → [self : SuccOrder α] → α → α",
  "name": "SuccOrder.succ",
  "kind": "def",
  "doc_string": "Successor function",
  "args": ""},
 {"type": "Linarith.Comp → ℕ → Linarith.Comp",
  "name": "Linarith.Comp.scale",
  "kind": "def",
  "doc_string": "`c.scale n` scales the coefficients of `c` by `n`. ",
  "args": ""},
 {"type": "{α β σ : Type u} → β → σ → DoResultPRBC α β σ",
  "name": "DoResultPRBC.return",
  "kind": "def",
  "doc_string":
  "`return (b : β) s` means that the block exited via a `return b` early-exit command ",
  "args": ""},
 {"type": "ℤ → ℤ → ℤ",
  "name": "Int.lxor'",
  "kind": "def",
  "doc_string": "`lxor'` computes the bitwise `xor` of two natural numbers",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {ra ra' : α → α → Prop} → (∀ (a₁ a₂ : α), ra a₁ a₂ → ra' a₁ a₂) → Quot ra → Quot ra'",
  "name": "Quot.mapRight",
  "kind": "def",
  "doc_string":
  "If `ra` is a subrelation of `ra'`, then we have a natural map `Quot ra → Quot ra'`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {r : α → α → Prop} {s : Set α}, DirectedOn r s → Directed r Subtype.val",
  "name": "DirectedOn.directed_val",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `directedOn_iff_directed`.",
  "args": ""},
 {"type":
  "{α : Type u} →\n  (c : DistribLattice α) →\n    (le : α → α → Prop) →\n      le = LE.le → (sup : α → α → α) → sup = HasSup.sup → (inf : α → α → α) → inf = HasInf.inf → DistribLattice α",
  "name": "DistribLattice.copy",
  "kind": "def",
  "doc_string":
  "A function to create a provable equal copy of a distributive lattice\nwith possibly different definitional equalities. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : BoundedOrder α] [self : IsSimpleOrder α] (a : α), a = ⊥ ∨ a = ⊤",
  "name": "IsSimpleOrder.eq_bot_or_eq_top",
  "kind": "def",
  "doc_string": "Every element is either `⊥` or `⊤` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} {s : Set α} [inst : LinearOrder α] [inst_1 : LinearOrder β] {f : α → β},\n  ¬MonotoneOn f s ∧ ¬AntitoneOn f s ↔ ∃ a x b x c x, a ≤ b ∧ b ≤ c ∧ (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c)",
  "name": "Set.not_monotoneOn_not_antitoneOn_iff_exists_le_le",
  "kind": "theorem",
  "doc_string":
  "A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {p : α → Prop} → {q : β → Prop} → (f : α ↪ β) → (∀ ⦃x : α⦄, p x → q (↑f x)) → { x // p x } ↪ { y // q y }",
  "name": "Function.Embedding.subtypeMap",
  "kind": "def",
  "doc_string": "Restrict both domain and codomain of an embedding. ",
  "args": ""},
 {"type":
  "∀ (R : Type u_2) [inst : Semiring R] (M : Type u_1) [inst_1 : AddCommMonoidWithOne M] [inst_2 : CharZero M]\n  [inst_3 : Module R M], CharZero R",
  "name": "CharZero.of_module",
  "kind": "theorem",
  "doc_string":
  "If `M` is an `R`-module with one and `M` has characteristic zero, then `R` has characteristic\nzero as well. Usually `M` is an `R`-algebra. ",
  "args": ""},
 {"type": "List Lean.Expr → Lean.MetaM (List Lean.Expr)",
  "name": "Linarith.addNegEqProofs",
  "kind": "def",
  "doc_string":
  "`addNegEqProofs l` inspects the list of proofs `l` for proofs of the form `t = 0`. For each such\nproof, it adds a proof of `-t = 0` to the list.\n",
  "args": ""},
 {"type":
  "{C : Type u} → [inst : CategoryTheory.Category C] → {X Y : C} → (X ≅ Y) → (Y ≅ X)",
  "name": "CategoryTheory.Iso.symm",
  "kind": "def",
  "doc_string": "Inverse isomorphism. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedAddCommGroup α] (a b : α), a ≤ b ∨ b ≤ a",
  "name": "LinearOrderedAddCommGroup.le_total",
  "kind": "def",
  "doc_string": "A linear order is total. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → List α",
  "name": "List.after",
  "kind": "def",
  "doc_string":
  "`after p xs` is the suffix of `xs` after the first element that satisfies\n`p`, not including that element.\n```lean\nafter      (· == 1) [0, 1, 2, 3] = [2, 3]\ndrop_while (· != 1) [0, 1, 2, 3] = [1, 2, 3]\n```\n",
  "args": ""},
 {"type": "∀ {m n : ℕ}, ↑m ≤ ↑n → m ≤ n",
  "name": "Int.le_of_ofNat_le_ofNat",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `Int.ofNat_le`.",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Option α ≃ Option β → α → β",
  "name": "Equiv.removeNone_aux",
  "kind": "def",
  "doc_string":
  "If we have a value on one side of an `Equiv` of `Option`\nwe also have a value on the other side of the equivalence\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_≈_»",
  "kind": "def",
  "doc_string":
  "`x ≈ y` says that `x` and `y` are equivalent. Because this is a typeclass,\nthe notion of equivalence is type-dependent. ",
  "args": ""},
 {"type": "∀ {a b c : ℤ}, a % b = c → b ∣ a - c",
  "name": "Int.dvd_sub_of_emod_eq",
  "kind": "theorem",
  "doc_string": "If `a % b = c` then `b` divides `a - c`. ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} {Z : C → Prop} (self : CategoryTheory.FullSubcategory Z), Z self.obj",
  "name": "CategoryTheory.FullSubcategory.property",
  "kind": "def",
  "doc_string": "The predicate satisfied by all objects in this subcategory",
  "args": ""},
 {"type": "ℕ → ℕ+",
  "name": "Nat.succPNat",
  "kind": "def",
  "doc_string": "Write a successor as an element of `ℕ+`. ",
  "args": ""},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "name": "singletonUnexpander",
  "kind": "def",
  "doc_string": "Unexpander for the `{ x }` notation. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : LE α] →\n      [inst_1 : Bot α] →\n        [inst_2 : LE β] → [inst_3 : OrderBot β] → (f : α → β) → (∀ (a b : α), f a ≤ f b → a ≤ b) → f ⊥ = ⊥ → OrderBot α",
  "name": "OrderBot.lift",
  "kind": "def",
  "doc_string": "Pullback an `OrderBot`. ",
  "args": ""},
 {"type": "{u : Lean.Level} → (α : Q(Type u)) → Lean.MetaM Q(Ring «$α»)",
  "name": "Mathlib.Meta.NormNum.inferRing",
  "kind": "def",
  "doc_string": "Helper functor to synthesize a typed `Ring α` expression. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → (γ : Type u_3) → (α ⊕ β) ⊕ γ ≃ α ⊕ β ⊕ γ",
  "name": "Equiv.sumAssoc",
  "kind": "def",
  "doc_string": "Sum of types is associative up to an equivalence. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Inhabited α] → α → List α → ℕ → List α",
  "name": "List.Func.set",
  "kind": "def",
  "doc_string":
  "Update element of a list by index. If the index is out of range, extend the list with default\nelements\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : PredOrder α] [inst_2 : IsPredArchimedean α] (r : α → α → Prop)\n  {n m : α}, (∀ (i : α), i ∈ Set.Ioc m n → r i (Order.pred i)) → m < n → Relation.TransGen r n m",
  "name": "transGen_of_pred_of_gt",
  "kind": "theorem",
  "doc_string":
  "For `m < n`, `(n, m)` is in the transitive closure of a relation `~` for `n ≠ m` if `i ~ pred i`\nfor all `i` between `n` and `m`. ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : Semiring α] (x : α), Semiring.npow 0 x = 1",
  "name": "Semiring.npow_zero",
  "kind": "def",
  "doc_string": "Raising to the power `(0 : ℕ)` gives `1`. ",
  "args": ""},
 {"type": "{α : Type u_1} → ℕ → α → List α → List α",
  "name": "List.insertNthTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `insertNth`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MulOneClass M] ⦃s t : Set M⦄, s ⊆ t → Submonoid.closure s ≤ Submonoid.closure t",
  "name": "Submonoid.closure_mono",
  "kind": "theorem",
  "doc_string":
  "Submonoid closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → α → Option α",
  "name": "Option.guard",
  "kind": "def",
  "doc_string":
  "`guard p a` returns `some a` if `p a` holds, otherwise `none`. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (α : Type u_2) → [inst : SMul M α] → [inst : SMul Mᵐᵒᵖ α] → Prop",
  "name": "IsCentralScalar",
  "kind": "inductive",
  "doc_string":
  "A typeclass indicating that the right (aka `MulOpposite`) and left actions by `M` on `α` are\nequal, that is that `M` acts centrally on `α`. This can be thought of as a version of commutativity\nfor `•`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Stream'",
  "kind": "def",
  "doc_string":
  "A stream `Stream' α` is an infinite sequence of elements of `α`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddZeroClass M] → {S T : AddSubmonoid M} → S = T → { x // x ∈ S } ≃+ { x // x ∈ T }",
  "name": "AddEquiv.addSubmonoidCongr",
  "kind": "def",
  "doc_string":
  "Makes the identity additive isomorphism from a proof two\nsubmonoids of an additive monoid are equal.",
  "args": ""},
 {"type": "{ε σ α : Type u} → ε → σ → EStateM.Result ε σ α",
  "name": "EStateM.Result.error",
  "kind": "def",
  "doc_string": "A failure value of type `ε`, and a new state `σ`. ",
  "args": ""},
 {"type":
  "{M₀ : Type u_1} →\n  {M₀' : Type u_2} →\n    [inst : Zero M₀'] →\n      [inst_1 : Mul M₀'] →\n        [inst_2 : One M₀'] →\n          [inst_3 : Pow M₀' ℕ] →\n            [inst_4 : CommMonoidWithZero M₀] →\n              (f : M₀' → M₀) →\n                Function.Injective f →\n                  f 0 = 0 →\n                    f 1 = 1 →\n                      (∀ (x y : M₀'), f (x * y) = f x * f y) →\n                        (∀ (x : M₀') (n : ℕ), f (x ^ n) = f x ^ n) → CommMonoidWithZero M₀'",
  "name": "Function.Injective.commMonoidWithZero",
  "kind": "def",
  "doc_string":
  "Pullback a `CommMonoidWithZero` along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.GlobalPreprocessor",
  "kind": "inductive",
  "doc_string":
  "Some preprocessors need to examine the full list of hypotheses instead of working item by item.\nAs with `Preprocessor`, the input to a `GlobalPreprocessor` is replaced by, not added to, its\noutput.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Add α] → [inst_1 : Add β] → α ≃+ β ≃ (αᵐᵒᵖ ≃+ βᵐᵒᵖ)",
  "name": "AddEquiv.mulOp",
  "kind": "def",
  "doc_string":
  "A iso `α ≃+ β` can equivalently be viewed as an iso `αᵐᵒᵖ ≃+ βᵐᵒᵖ`. ",
  "args": ""},
 {"type":
  "{M : Type uM} →\n  {N : Type uN} →\n    {P : Type uP} →\n      {Q : Type uQ} →\n        [inst : AddZeroClass M] →\n          [inst_1 : AddZeroClass N] →\n            [inst_2 : AddCommMonoid P] → [inst_3 : AddZeroClass Q] → (M →+ N →+ P) → (Q →+ N) → M →+ Q →+ P",
  "name": "AddMonoidHom.compl₂",
  "kind": "def",
  "doc_string":
  "The expression `λ m q, f m (g q)` as an `AddMonoidHom`.\n\nNote that the expression `λ q n, f (g q) n` is simply `AddMonoidHom.comp`.\n\nThis also exists as a `LinearMap` version, `LinearMap.compl₂`",
  "args": ""},
 {"type":
  "Lean.Syntax →\n  List Lean.Name →\n    Lean.Name →\n      Lean.Expr →\n        Lean.Expr →\n          Lean.Expr →\n            Array Lean.Expr → Bool → Simps.Config → List (String × Lean.Syntax) → List ℕ → Lean.MetaM (Array Lean.Name)",
  "name": "simpsAddProjections",
  "kind": "opaque",
  "doc_string":
  "Derive lemmas specifying the projections of the declaration.\n`nm`: name of the lemma\nIf `todo` is non-empty, it will generate exactly the names in `todo`.\n`toApply` is non-empty after a custom projection that is a composition of multiple projections\nwas just used. In that case we need to apply these projections before we continue changing `lhs`.\n`simpLemmas`: names of the simp lemmas added so far.(simpLemmas : Array Name)\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 ≤ a - b → b ≤ a",
  "name": "le_of_sub_nonneg",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `sub_nonneg`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r s : Setoid α}, Setoid.Rel (r ⊓ s) = Setoid.Rel r ⊓ Setoid.Rel s",
  "name": "Setoid.inf_def",
  "kind": "theorem",
  "doc_string":
  "The infimum of 2 equivalence relations r and s is the same relation as the infimum\nof the underlying binary operations. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {G : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddCommGroup G] → Sub (M →+ G)",
  "name":
  "AddMonoidHom.instSubAddMonoidHomToAddZeroClassToAddMonoidToSubNegAddMonoidToAddGroup",
  "kind": "def",
  "doc_string":
  "If `f` and `g` are monoid homomorphisms to an additive commutative group, then `f - g`\nis the homomorphism sending `x` to `(f x) - (g x)`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {α : Type u_2} → [inst : Monoid M] → [inst_1 : MulAction M α] → M →* Function.End α",
  "name": "MulAction.toEndHom",
  "kind": "def",
  "doc_string":
  "The monoid hom representing a monoid action.\n\nWhen `M` is a group, see `MulAction.toPermHom`. ",
  "args": ""},
 {"type": "outParam (Type u) → (Type u → Type v) → Type (max (u + 1) v)",
  "name": "MonadState",
  "kind": "inductive",
  "doc_string":
  "Similar to `MonadStateOf`, but `σ` is an `outParam` for convenience. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : OrderedSemiring S] {R : Type u_2} [inst_1 : Semiring R] {f : R → S} [self : IsAbsoluteValue f]\n  (x y : R), f (x * y) = f x * f y",
  "name": "IsAbsoluteValue.abv_mul",
  "kind": "def",
  "doc_string": "The absolute value is multiplicative ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] (a b c : α), a * (b + c) = a * b + a * c",
  "name": "CanonicallyOrderedCommSemiring.left_distrib",
  "kind": "def",
  "doc_string": "Multiplication is left distributive over addition ",
  "args": ""},
 {"type":
  "{α : Type u} → {m : Type u_1 → Type u_2} → {β γ : Type u_1} → [inst : Bind m] → (α → m β) → (β → m γ) → α → m γ",
  "name": "Bind.kleisliRight",
  "kind": "def",
  "doc_string": "Left-to-right composition of Kleisli arrows. ",
  "args": ""},
 {"type": "Sort u → Sort (max 1 u)",
  "name": "Inhabited",
  "kind": "inductive",
  "doc_string":
  "`Inhabited α` is a typeclass that says that `α` has a designated element,\ncalled `(default : α)`. This is sometimes referred to as a \"pointed type\".\n\nThis class is used by functions that need to return a value of the type\nwhen called \"out of domain\". For example, `Array.get! arr i : α` returns\na value of type `α` when `arr : Array α`, but if `i` is not in range of\nthe array, it reports a panic message, but this does not halt the program,\nso it must still return a value of type `α` (and in fact this is required\nfor logical consistency), so in this case it returns `default`.\n",
  "args": ""},
 {"type": "ℕ → Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Linarith.mulExpr",
  "kind": "def",
  "doc_string":
  "`mulExpr n e` creates an `Expr` representing `n*e`.\nWhen elaborated, the coefficient will be a native numeral of the same type as `e`.\n",
  "args": ""},
 {"type":
  "∀ {N : Type u_1} {α : Type u_2} [inst : Preorder α] [inst_1 : Preorder N] {f : N → α} {μ : N → N → N}\n  [inst_2 : CovariantClass N N (Function.swap μ) fun x x_1 => x ≤ x_1],\n  Monotone f → ∀ (m : N), Monotone fun n => f (μ n m)",
  "name": "Monotone.covariant_of_const'",
  "kind": "theorem",
  "doc_string":
  "Same as `monotone.covariant_of_const`, but with the constant on the other side of\nthe operator.  E.g., `∀ (m : ℕ), monotone f → monotone (λ n, f (n + m))`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⇨_»",
  "kind": "def",
  "doc_string": "Heyting implication ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    [inst : Semiring R] →\n      [inst_1 : OrderedRing S] → AbsoluteValue R S → [inst_2 : IsDomain S] → [inst_3 : Nontrivial R] → R →* S",
  "name": "AbsoluteValue.toMonoidHom",
  "kind": "def",
  "doc_string":
  "Absolute values from a nontrivial `R` to a linear ordered ring preserve `*` and `1`. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_2} {H : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : OrderedAddCommGroup H] {f : G → H},\n  (∀ (x : G), f (-x) = -f x) → AntitoneOn f (Set.Ici 0) → Antitone f",
  "name": "antitone_of_odd_of_monotone_on_nonneg",
  "kind": "theorem",
  "doc_string":
  "An odd function on a linear ordered additive commutative group is antitone on the whole group\nprovided that it is monotone on `Set.Ici 0`. ",
  "args": ""},
 {"type": "∀ {R : Type u_1} [inst : LinearOrderedRing R] (a : R), 0 ≤ a ^ 2",
  "name": "pow_two_nonneg",
  "kind": "theorem",
  "doc_string": "**Alias** of `sq_nonneg`.",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_<*>_»",
  "kind": "def",
  "doc_string":
  "If `mf : F (α → β)` and `mx : F α`, then `mf <*> mx : F β`.\nIn a monad this is the same as `do let f ← mf; x ← mx; pure (f x)`:\nit evaluates first the function, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a\n`Unit → f α` function. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_>>=_»",
  "kind": "def",
  "doc_string":
  "If `x : m α` and `f : α → m β`, then `x >>= f : m β` represents the\nresult of executing `x` to get a value of type `α` and then passing it to `f`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Unique M] →\n      [inst : Unique N] → [inst : Add M] → [inst_1 : Mul M] → [inst_2 : Add N] → [inst_3 : Mul N] → M ≃+* N",
  "name": "RingEquiv.ringEquivOfUnique",
  "kind": "def",
  "doc_string": "The `RingEquiv` between two semirings with a unique element. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsFixedPt (f^[n]) x",
  "name": "Function.IsFixedPt.iterate",
  "kind": "theorem",
  "doc_string":
  "If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. ",
  "args": ""},
 {"type": "ℕ+ →* ℕ",
  "name": "PNat.coeMonoidHom",
  "kind": "def",
  "doc_string": "`PNat.coe` promoted to a `MonoidHom`. ",
  "args": ""},
 {"type": "Sort u_1 → Prop",
  "name": "Infinite",
  "kind": "inductive",
  "doc_string":
  "A type is said to be infinite if it is not finite. Note that `Infinite α` is equivalent to\n`IsEmpty (Fintype α)` or `IsEmpty (Finite α)`. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Sat.LClause → ℕ",
  "name": "Mathlib.Tactic.Sat.LClause.depth",
  "kind": "def",
  "doc_string":
  "The bound variable index of the hypothesis asserting `⊢ ctx.proof c`,\n_counting from the outside and 1-based_. (We use this numbering because we will need to\nreference the variable from multiple binder depths.) ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Bundle.termπ",
  "kind": "def",
  "doc_string": "The canonical projection defining a bundle. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Set (α → β) → Prop",
  "name": "Set.SeparatesPoints",
  "kind": "def",
  "doc_string":
  "A set of functions \"separates points\"\nif for each pair of distinct points there is a function taking different values on them. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {E : Type u_2} (R : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R] [inst_2 : Monoid α]\n  [inst_3 : Module R E] [inst_4 : DistribMulAction α E] (n : ℕ) (s : α) (x : E), (↑n)⁻¹ • s • x = s • (↑n)⁻¹ • x",
  "name": "inv_nat_cast_smul_comm",
  "kind": "theorem",
  "doc_string":
  "If `E` is a vector space over a division rings `R` and has a monoid action by `α`, then that\naction commutes by scalar multiplication of inverses of natural numbers in `R`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : CompleteLattice α] → (f : α →o α) → CompleteLattice ↑(Function.fixedPoints ↑f)",
  "name": "fixedPoints.completeLattice",
  "kind": "def",
  "doc_string":
  "**Knaster-Tarski Theorem**: The fixed points of `f` form a complete lattice. ",
  "args": ""},
 {"type":
  "{c : Type u → Type v} → (self : CategoryTheory.Bundled c) → c self.α",
  "name": "CategoryTheory.Bundled.str",
  "kind": "def",
  "doc_string": "The corresponding instance of the bundled type class ",
  "args": ""},
 {"type":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      {x : NonAssocSemiring α} → {x_1 : NonAssocSemiring β} → [inst : RingHomClass F α β] → CoeTC F (α →+* β)",
  "name": "instCoeTCRingHom",
  "kind": "def",
  "doc_string":
  "Any type satisfying `RingHomClass` can be cast into `RingHom` via `RingHomClass.toRingHom`. ",
  "args": ""},
 {"type": "optParam (Array ℕ) #[] → Lean.Parsec (Array ℕ)",
  "name": "Mathlib.Tactic.Sat.Parser.parseNats",
  "kind": "opaque",
  "doc_string": "Parse a list of natural numbers terminated by 0 ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x y : G),\n  ↑h (x / y) = ↑h x / ↑h y",
  "name": "MulEquiv.map_div",
  "kind": "theorem",
  "doc_string": "A multiplicative equivalence of groups preserves division. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → α ≃ β → List α ≃ List β",
  "name": "Equiv.listEquivOfEquiv",
  "kind": "def",
  "doc_string":
  "An equivalence between `α` and `β` generates an equivalence between `List α` and `List β`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] → [inst_1 : Preorder β] → (e : α ≃ β) → Monotone ↑e → Monotone ↑(Equiv.symm e) → α ≃o β",
  "name": "Equiv.toOrderIso",
  "kind": "def",
  "doc_string":
  "If `e` is an equivalence with monotone forward and inverse maps, then `e` is an\norder isomorphism. ",
  "args": ""},
 {"type": "Substring → Substring → Option Substring",
  "name": "Substring.dropPrefix?",
  "kind": "def",
  "doc_string":
  "If `pre` is a prefix of `s`, i.e. `s = pre ++ t`, return the remainder `t`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → Antitone (f ∘ ↑OrderDual.ofDual)",
  "name": "Monotone.dual_left",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `antitone_comp_ofDual_iff`.",
  "args": ""},
 {"type": "{α : Type u} → [self : LinearOrderedAddCommGroup α] → DecidableEq α",
  "name": "LinearOrderedAddCommGroup.decidable_eq",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → (α : Type u_3) → [inst : SMul M N] → [inst : SMul N α] → [inst : SMul M α] → Prop",
  "name": "IsScalarTower",
  "kind": "inductive",
  "doc_string":
  "An instance of `IsScalarTower M N α` states that the multiplicative\naction of `M` on `α` is determined by the multiplicative actions of `M` on `N`\nand `N` on `α`. ",
  "args": ""},
 {"type": "Type u → Type v → Type (max u v)",
  "name": "Sum",
  "kind": "inductive",
  "doc_string":
  "`Sum α β`, or `α ⊕ β`, is the disjoint union of types `α` and `β`.\nAn element of `α ⊕ β` is either of the form `.inl a` where `a : α`,\nor `.inr b` where `b : β`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ⊔ b = b → a ≤ b",
  "name": "le_of_sup_eq",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `sup_eq_right`.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] → {F : Type u_3} → [mc : AddMonoidHomClass F M N] → F → AddSubmonoid M → AddSubmonoid N",
  "name": "AddSubmonoid.map",
  "kind": "def",
  "doc_string":
  "The image of an `AddSubmonoid` along an `AddMonoid` homomorphism is an `AddSubmonoid`.",
  "args": ""},
 {"type": "Lean.Syntax → Lean.Elab.TermElabM Mathlib.Tactic.Abel.AbelNF.Config",
  "name": "Mathlib.Tactic.Abel.elabAbelNFConfig",
  "kind": "def",
  "doc_string": "Function elaborating `AbelNF.Config`. ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.GeneralizeProofs.State → Array Lean.Meta.GeneralizeArg",
  "name": "Mathlib.Tactic.GeneralizeProofs.State.curIdx",
  "kind": "def",
  "doc_string": "The generalizations made so far ",
  "args": ""},
 {"type": "Lean.ParametricAttribute (Array Lean.Name)",
  "name": "simpsAttr",
  "kind": "opaque",
  "doc_string": "`simps` attribute. ",
  "args": ""},
 {"type": "(M : Type u) → [inst : Monoid M] → M ≃ (Multiplicative ℕ →* M)",
  "name": "powersHom",
  "kind": "def",
  "doc_string":
  "Monoid homomorphisms from `Multiplicative ℕ` are defined by the image\nof `Multiplicative.ofAdd 1`. ",
  "args": ""},
 {"type": "{B : Type u_1} → (B → Type u_2) → Type (max u_1 u_2)",
  "name": "Bundle.TotalSpace",
  "kind": "def",
  "doc_string":
  "`Bundle.TotalSpace E` is the total space of the bundle `Σ x, E x`.\nThis type synonym is used to avoid conflicts with general sigma types.\n",
  "args": ""},
 {"type": "∀ {G : Type u_1} [inst : Group G] {a b : G}, a = b → a / b = 1",
  "name": "div_eq_one_of_eq",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `div_eq_one`.",
  "args": ""},
 {"type":
  "Lean.Expr → Lean.Expr → Lean.Expr → Lean.Expr → Lean.MetaM (Lean.Expr × Lean.Expr)",
  "name": "Mathlib.Tactic.getExplicitRelArgCore",
  "kind": "def",
  "doc_string":
  "refining `tgt ← mkAppM' rel #[x, z]` dropping more arguments if possible ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (List α → α → List α → β) → List α → List β",
  "name": "List.mapWithPrefixSuffix",
  "kind": "def",
  "doc_string":
  "`List.mapWithPrefixSuffix f l` maps `f` across a list `l`.\nFor each `a ∈ l` with `l = pref ++ [a] ++ suff`, `a` is mapped to `f pref a suff`.\nExample: if `f : list Nat → Nat → list Nat → β`,\n`List.mapWithPrefixSuffix f [1, 2, 3]` will produce the list\n`[f [] 1 [2, 3], f [1] 2 [3], f [1, 2] 3 []]`.\n",
  "args": ""},
 {"type": "{C : Sort u} → False → C",
  "name": "False.elim",
  "kind": "def",
  "doc_string":
  "`False.elim : False → C` says that from `False`, any desired proposition\n`C` holds. Also known as ex falso quodlibet (EFQ) or the principle of explosion.\n\nThe target type is actually `C : Sort u` which means it works for both\npropositions and types. When executed, this acts like an \"unreachable\"\ninstruction: it is **undefined behavior** to run, but it will probably print\n\"unreachable code\". (You would need to construct a proof of false to run it\nanyway, which you can only do using `sorry` or unsound axioms.)\n",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.AbelNF.Config → Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "name": "Mathlib.Tactic.Abel.abelNFCore",
  "kind": "def",
  "doc_string":
  "The core of `abel_nf`, which rewrites the expression `e` into `abel` normal form.\n\n* `cfg`: the configuration options\n* `e`: the expression to rewrite\n",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (zα : Q(Zero «$α»)) →\n      (pα : Q(PartialOrder «$α»)) →\n        (lo e : Q(«$α»)) → Q(«$lo» < «$e») → Lean.MetaM (Mathlib.Meta.Positivity.Strictness zα pα e)",
  "name": "Mathlib.Meta.Positivity.compareHypLT",
  "kind": "def",
  "doc_string":
  "A variation on `assumption` when the hypothesis is `lo < e` where `lo` is a numeral. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ≃+* S), ↑↑f = ↑f",
  "name": "RingEquiv.toNonUnitalRingHom_commutes",
  "kind": "theorem",
  "doc_string":
  "The two paths coercion can take to a `NonUnitalRingEquiv` are equivalent ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β} {s t : Set α} {c : α},\n  StrictMonoOn f s → StrictMonoOn f t → IsGreatest s c → IsLeast t c → StrictMonoOn f (s ∪ t)",
  "name": "StrictMonoOn.union",
  "kind": "theorem",
  "doc_string":
  "If `f` is strictly monotone both on `s` and `t`, with `s` to the left of `t` and the center\npoint belonging to both `s` and `t`, then `f` is strictly monotone on `s ∪ t` ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → α → α → Prop",
  "name": "Relation.ReflTransGen",
  "kind": "inductive",
  "doc_string": "`ReflTransGen r`: reflexive transitive closure of `r` ",
  "args": ""},
 {"type": "Lean.Expr → Option ℤ",
  "name": "Mathlib.Meta.NormNum.isIntLit",
  "kind": "def",
  "doc_string":
  "Extract the integer `i` if the expression is either a natural number literal\nor the negation of one. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r s : α → α → Prop} [self : IsNonstrictStrictOrder α r s] (a b : α), s a b ↔ r a b ∧ ¬r b a",
  "name": "IsNonstrictStrictOrder.right_iff_left_not_left",
  "kind": "def",
  "doc_string":
  "The relation `r` is the nonstrict relation corresponding to the strict relation `s`. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : NonAssocRing α] (a : α), a * 1 = a",
  "name": "NonAssocRing.mul_one",
  "kind": "def",
  "doc_string": "One is a right neutral element for multiplication ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → α → Aesop.UnorderedArraySet α → Bool",
  "name": "Aesop.UnorderedArraySet.contains",
  "kind": "def",
  "doc_string": "O(n) ",
  "args": ""},
 {"type": "{α : Type u} → α ≃ Multiplicative α",
  "name": "Multiplicative.ofAdd",
  "kind": "def",
  "doc_string": "Reinterpret `x : α` as an element of `Multiplicative α`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : OrderedCommGroup α] →\n    {β : Type u_2} →\n      [inst_1 : One β] →\n        [inst_2 : Mul β] →\n          [inst_3 : Inv β] →\n            [inst_4 : Div β] →\n              [inst_5 : Pow β ℕ] →\n                [inst_6 : Pow β ℤ] →\n                  (f : β → α) →\n                    Function.Injective f →\n                      f 1 = 1 →\n                        (∀ (x y : β), f (x * y) = f x * f y) →\n                          (∀ (x : β), f x⁻¹ = (f x)⁻¹) →\n                            (∀ (x y : β), f (x / y) = f x / f y) →\n                              (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                (∀ (x : β) (n : ℤ), f (x ^ n) = f x ^ n) → OrderedCommGroup β",
  "name": "Function.Injective.orderedCommGroup",
  "kind": "def",
  "doc_string":
  "Pullback an `OrderedCommGroup` under an injective map.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Simps.Config → Lean.Meta.TransparencyMode",
  "name": "Simps.Config.typeMd",
  "kind": "def",
  "doc_string":
  "TransparencyMode used to reduce the type in order to detect whether it is a structure. ",
  "args": ""},
 {"type": "Linarith.Linexp → Linarith.Linexp → Linarith.Linexp",
  "name": "Linarith.Linexp.add",
  "kind": "opaque",
  "doc_string":
  "Add two `Linexp`s together componentwise.\nPreserves sorting and uniqueness of the first argument.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "name": "StrictOrderedSemiring.add_le_add_left",
  "kind": "def",
  "doc_string":
  "Addition is monotone in an ordered cancellative additive commutative monoid. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Set.«term⋃₀_»",
  "kind": "def",
  "doc_string": "Notation for Set.unionₛ`. Union of a set of sets. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosMono α],\n  a ≤ 1 → b ≤ 1 → 0 ≤ b → a * b ≤ 1",
  "name": "Right.mul_le_one_of_le_of_le",
  "kind": "theorem",
  "doc_string": "Assumes right covariance. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : OrderedRing α] (a b : α), 0 ≤ a → 0 ≤ b → 0 ≤ a * b",
  "name": "OrderedRing.mul_nonneg",
  "kind": "def",
  "doc_string": "The product of non-negative elements is non-negative. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β}\n  {x_2 : NonAssocSemiring γ} {δ : Type u_1} {x_3 : NonAssocSemiring δ} (f : α →+* β) (g : β →+* γ) (h : γ →+* δ),\n  RingHom.comp (RingHom.comp h g) f = RingHom.comp h (RingHom.comp g f)",
  "name": "RingHom.comp_assoc",
  "kind": "theorem",
  "doc_string": "Composition of semiring homomorphisms is associative. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : OrderedSemiring S] {R : Type u_2} [inst_1 : Semiring R] (abv : AbsoluteValue R S),\n  IsAbsoluteValue ↑abv",
  "name": "AbsoluteValue.isAbsoluteValue",
  "kind": "def",
  "doc_string": "A bundled absolute value is an absolute value. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Option α) → List α → List α",
  "name": "List.replaceF",
  "kind": "def",
  "doc_string":
  "Replaces the first element of the list for which `f` returns `some` with the returned value. ",
  "args": ""},
 {"type":
  "∀ {ι : Sort u_2} {M : Type u_1} [inst : Add M] (S : ι → AddSubsemigroup M) {C : (x : M) → (x ∈ ⨆ i, S i) → Prop},\n  (∀ (i : ι) (x : M) (hxS : x ∈ S i), C x (_ : x ∈ ⨆ i, S i)) →\n    (∀ (x y : M) (hx : x ∈ ⨆ i, S i) (hy : y ∈ ⨆ i, S i), C x hx → C y hy → C (x + y) (_ : x + y ∈ ⨆ i, S i)) →\n      ∀ {x₁ : M} (hx₁ : x₁ ∈ ⨆ i, S i), C x₁ hx₁",
  "name": "AddSubsemigroup.supᵢ_induction'",
  "kind": "theorem",
  "doc_string": "A dependent version of `AddSubsemigroup.supᵢ_induction`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      {r : α → α → Prop} → {s : β → β → Prop} → {t : γ → γ → Prop} → [inst : IsTrans γ t] → r ≺i s → s ≺i t → r ≺i t",
  "name": "PrincipalSeg.trans",
  "kind": "def",
  "doc_string": "Composition of two principal segments as a principal segment ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → Option β) → List α → Array β → List β",
  "name": "List.filterMapTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `filterMap`: `filterMap.go f l = acc.toList ++ filterMap f l` ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : StrictOrderedSemiring α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → OrderedSemiring α",
  "name": "StrictOrderedSemiring.toOrderedSemiring'",
  "kind": "def",
  "doc_string":
  "A choice-free version of `StrictOrderedSemiring.toOrderedSemiring` to avoid using choice in\nbasic `Nat` lemmas. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddMonoid M] →\n      [inst_1 : AddMonoid N] →\n        {s : Set M} →\n          (f : M → N) →\n            AddSubmonoid.closure s = ⊤ → f 0 = 0 → (∀ (x : M), x ∈ s → ∀ (y : M), f (x + y) = f x + f y) → M →+ N",
  "name": "AddMonoidHom.ofClosureMEqTopLeft",
  "kind": "def",
  "doc_string":
  "Let `s` be a subset of an additive monoid `M` such that the closure of `s` is\nthe whole monoid. Then `AddMonoidHom.ofClosureEqTopLeft` defines an additive monoid\nhomomorphism from `M` asking for a proof of `f (x + y) = f x + f y` only for `x ∈ s`. ",
  "args": ""},
 {"type":
  "{α : Sort u} → {r : α → α → Prop} → {β : Sort v} → (f : α → β) → (∀ (a b : α), r a b → f a = f b) → Quot r → β",
  "name": "Quot.lift",
  "kind": "def",
  "doc_string":
  "Given a type `α`, any binary relation `r` on `α`, a function `f : α → β`, and a proof `h`\nthat `f` respects the relation `r`, then `Quot.lift f h` is the corresponding function on `Quot r`.\n\nThe idea is that for each element `a` in `α`, the function `Quot.lift f h` maps `Quot.mk r a`\n(the `r`-class containing `a`) to `f a`, wherein `h` shows that this function is well defined.\nIn fact, the computation principle is declared as a reduction rule.\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Add M] (S : AddSubsemigroup M) {x y : M}, x ∈ S → y ∈ S → x + y ∈ S",
  "name": "AddSubsemigroup.add_mem",
  "kind": "theorem",
  "doc_string": "An `AddSubsemigroup` is closed under addition.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "CommSemigroup",
  "kind": "inductive",
  "doc_string":
  "A commutative semigroup is a type with an associative commutative `(*)`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → [inst : Monoid M] → [inst_1 : Monoid N] → (f : M →* N) → (∀ (x : M), IsUnit (↑f x)) → M →* Nˣ",
  "name": "IsUnit.liftRight",
  "kind": "def",
  "doc_string":
  "If a homomorphism `f : M →* N` sends each element to an `IsUnit`, then it can be lifted\nto `f : M →* Nˣ`. See also `Units.liftRight` for a computable version. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HSMul α β γ] → α → β → γ",
  "name": "HSMul.hSMul",
  "kind": "def",
  "doc_string":
  "`a • b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → (β → α) → Prop",
  "name": "IsOrderRightAdjoint",
  "kind": "def",
  "doc_string":
  "We say that `g : β → α` is an order right adjoint function for `f : α → β` if it sends each `y`\nto a least upper bound for `{x | f x ≤ y}`. If `α` is a partial order, and `f : α → β` has\na right adjoint, then this right adjoint is unique. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_≃r_»",
  "kind": "def",
  "doc_string":
  "A relation isomorphism is an equivalence that is also a relation embedding. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α), Set.Nontrivial (f '' s) → Set.Nontrivial s",
  "name": "Set.nontrivial_of_image",
  "kind": "theorem",
  "doc_string": "If the image of a set is nontrivial, the set is nontrivial. ",
  "args": ""},
 {"type":
  "{α' : Type u_1} → {β' : Type u_2} → α' ≃ β' → Equiv.Perm α' ≃ Equiv.Perm β'",
  "name": "Equiv.permCongr",
  "kind": "def",
  "doc_string":
  "If `α` is equivalent to `β`, then `Perm α` is equivalent to `Perm β`. ",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HAndThen",
  "kind": "inductive",
  "doc_string":
  "The typeclass behind the notation `a >> b : γ` where `a : α`, `b : β`.\nBecause `b` is \"lazy\" in this notation, it is passed as `Unit → β` to the\nimplementation so it can decide when to evaluate it.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (Option α → β → γ) → List α → List β → List γ × List α",
  "name": "List.zipWithRight'",
  "kind": "def",
  "doc_string":
  "Right-biased version of `List.zipWith`. `zipWithRight' f as bs` applies `f` to each\npair of elements `aᵢ ∈ as` and `bᵢ ∈ bs`. If `as` is shorter than `bs`, `f` is\napplied to `none` for the remaining `bᵢ`. Returns the results of the `f`\napplications and the remaining `as`.\n```\nzipWithRight' prod.mk [1] ['a', 'b'] = ([(some 1, 'a'), (none, 'b')], [])\nzipWithRight' prod.mk [1, 2] ['a'] = ([(some 1, 'a')], [2])\n```\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : LT α] → [inst : LT β] → α × β → α × β → Prop",
  "name": "Prod.lexLt",
  "kind": "def",
  "doc_string": "Lexicographical order for products ",
  "args": ""},
 {"type": "{K : Type u} → [self : Field K] → ℚ → K → K",
  "name": "Field.qsmul",
  "kind": "def",
  "doc_string": "Multiplication by a rational number. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : NonUnitalNonAssocSemiring α] →\n      [inst_1 : NonUnitalNonAssocSemiring β] → (α →ₙ+* β) → (I : Type u_3) → (I → α) →ₙ+* I → β",
  "name": "NonUnitalRingHom.compLeft",
  "kind": "def",
  "doc_string":
  "Non-unital ring homomorphism between the function spaces `I → α` and `I → β`, induced by a\nnon-unital ring homomorphism `f` between `α` and `β`. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} {s t : Set α}, s ≤ t → s ⊆ t",
  "name": "LE.le.subset",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `Set.le_iff_subset`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedField α] (a : α), LinearOrderedField.zpow 0 a = 1",
  "name": "LinearOrderedField.zpow_zero'",
  "kind": "def",
  "doc_string": "`a ^ 0 = 1` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : LE α] → [inst : DecidableRel LE.le] → Max α",
  "name": "maxOfLe",
  "kind": "def",
  "doc_string": "Implementation of the `max` operation using `≤`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → List α",
  "name": "List.takeWhileTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `takeWhile`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.GeneralizeProofs.generalizeProofs",
  "kind": "def",
  "doc_string":
  "Generalize proofs in the goal, naming them with the provided list.\n\nFor example:\n```lean\nexample : list.nth_le [1, 2] 1 dec_trivial = 2 := by\n  -- ⊢ [1, 2].nth_le 1 _ = 2\n  generalize_proofs h,\n  -- h : 1 < [1, 2].length\n  -- ⊢ [1, 2].nth_le 1 h = 2\n```\n",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] (x : M₀), ¬IsUnit x → Ring.inverse x = 0",
  "name": "Ring.inverse_non_unit",
  "kind": "theorem",
  "doc_string":
  "By definition, if `x` is not invertible then `inverse x = 0`. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CancelCommMonoidWithZero",
  "kind": "inductive",
  "doc_string":
  "A type `M` is a `CancelCommMonoidWithZero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.ModCases.«tacticMod_cases_:_%_»",
  "kind": "def",
  "doc_string":
  "* The tactic `mod_cases h : e % 3` will perform a case disjunction on `e : ℤ` and yield subgoals\n  containing the assumptions `h : e ≡ 0 [ZMOD 3]`, `h : e ≡ 1 [ZMOD 3]`, `h : e ≡ 2 [ZMOD 3]`\n  respectively.\n* In general, `mod_cases h : e % n` works\n  when `n` is a positive numeral and `e` is an expression of type `ℤ`.\n* If `h` is omitted as in `mod_cases e % n`, it will be default-named `H`.\n",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.MkIff.Shape",
  "kind": "inductive",
  "doc_string":
  "Auxiliary data associated with a single constructor of an inductive declaration.\n",
  "args": ""},
 {"type": "Lean.Name → String → Lean.Syntax → Lean.MetaM (Lean.Expr × Array ℕ)",
  "name": "getCompositeOfProjections",
  "kind": "def",
  "doc_string":
  "Given a structure `str` and a projection `proj`, that could be multiple nested projections\n(separated by `_`), returns an Expression that is the composition of these projections and a\nlist of natural numbers, that are the projection numbers of the applied projections. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {n : ℕ} (v : List α) (P : List.length v = n), Vector.toList { val := v, property := P } = v",
  "name": "Vector.toList_mk",
  "kind": "theorem",
  "doc_string":
  "Vector of length from a list `v`\nwith witness that `v` has length `n` maps to `v` under `toList`.  ",
  "args": ""},
 {"type":
  "{M : Type u} → {N : Type v} → [inst : Monoid M] → [inst_1 : Monoid N] → (M →* N) → Mˣ →* Nˣ",
  "name": "Units.map",
  "kind": "def",
  "doc_string": "The group homomorphism on units induced by a `MonoidHom`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : NonAssocRing α] (n : ℕ), IntCast.intCast ↑n = ↑n",
  "name": "NonAssocRing.intCast_ofNat",
  "kind": "def",
  "doc_string":
  "The canonical homorphism `ℤ → R` agrees with the one from `ℕ → R` on `ℕ`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → α → List α → ℕ",
  "name": "List.count",
  "kind": "def",
  "doc_string": "`count a l` is the number of occurrences of `a` in `l`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → β → Prop}, Option.rel r none none",
  "name": "Option.rel.none",
  "kind": "def",
  "doc_string": "`none ~ none` ",
  "args": ""},
 {"type": "ℕ → Lean.Expr → Lean.MetaM (Linarith.Ineq × Lean.Expr)",
  "name": "Linarith.mkSingleCompZeroOf",
  "kind": "def",
  "doc_string":
  "`mkSingleCompZeroOf c h` assumes that `h` is a proof of `t R 0`.\nIt produces a pair `(R', h')`, where `h'` is a proof of `c*t R' 0`.\nTypically `R` and `R'` will be the same, except when `c = 0`, in which case `R'` is `=`.\nIf `c = 1`, `h'` is the same as `h` -- specifically, it does *not* change the type to `1*t R 0`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : HeytingAlgebra α] {a b : α}, Disjoint b a → a ≤ bᶜ",
  "name": "Disjoint.le_compl_left",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `le_compl_iff_disjoint_left`.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] → [inst_1 : MulOneClass N] → (f : M →* N) → (∀ (x y : M), Commute (↑f x) (↑f y)) → Mᵐᵒᵖ →* N",
  "name": "MonoidHom.fromOpposite",
  "kind": "def",
  "doc_string":
  "A monoid homomorphism `f : M →* N` such that `f x` commutes with `f y` for all `x, y` defines\na monoid homomorphism from `Mᵐᵒᵖ`. ",
  "args": ""},
 {"type": "{p : Prop} → ℕ → SlimCheck.TestResult p → SlimCheck.TestResult p",
  "name": "SlimCheck.Testable.addShrinks",
  "kind": "def",
  "doc_string": "Increase the number of shrinking steps in a test result.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [inst_3 : OrderedSub α] {a b c : α}\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], a + c - (b + c) ≤ a - b",
  "name": "add_tsub_add_le_tsub_right",
  "kind": "theorem",
  "doc_string": "See `add_tsub_add_eq_tsub_right` for the equality. ",
  "args": ""},
 {"type": "AddMonoidWithOne ℕ",
  "name": "Mathlib.Meta.NormNum.instAddMonoidWithOneNat",
  "kind": "def",
  "doc_string":
  "A shortcut (non)instance for `AddMonoidWithOne ℕ` to shrink generated proofs. ",
  "args": ""},
 {"type":
  "{α : Sort u} → {r r' : Setoid α} → (∀ (a₁ a₂ : α), Setoid.r a₁ a₂ ↔ Setoid.r a₁ a₂) → Quotient r ≃ Quotient r'",
  "name": "Quotient.congrRight",
  "kind": "def",
  "doc_string":
  "Quotients are congruent on equivalences under equality of their relation.\nAn alternative is just to use rewriting with `eq`, but then computational proofs get stuck. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_=<<_»",
  "kind": "def",
  "doc_string": "Same as `Bind.bind` but with arguments swapped. ",
  "args": ""},
 {"type": "{α : Type u} → {n : ℕ} → (i : ℕ) → Vector α n → Vector α (n - i)",
  "name": "Vector.drop",
  "kind": "def",
  "doc_string":
  "Drop `i` elements from a vector of length `n`; we can have `i > n`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Add α] → [inst : LE α] → α → Prop",
  "name": "AddLECancellable",
  "kind": "def",
  "doc_string":
  "An element `a : α` is `AddLECancellable` if `x ↦ a + x` is order-reflecting.\nWe will make a separate version of many lemmas that require `[ContravariantClass α α (+) (≤)]` with\n`AddLECancellable` assumptions instead. These lemmas can then be instantiated to specific types,\nlike `ENNReal`, where we can replace the assumption `AddLECancellable x` by `x ≠ ∞`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (xs : List α) (ys : List β) (x : α) (y : β), (x, y) ∈ xs ×ˢ ys ↔ x ∈ xs ∧ y ∈ ys",
  "name": "List.product_spec",
  "kind": "theorem",
  "doc_string":
  "List.prod satisfies a specification of cartesian product on lists.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.applyRulesElab",
  "kind": "def",
  "doc_string":
  "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by calling `assumption`.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\n\nYou may include attributes amongst the lemmas:\n`apply_rules` will include all lemmas marked with these attributes.\n\nYou can bound the iteration depth using the syntax `apply_rules lemmas n`.\nThe default bound is 50.\n\nYou can pass a further configuration `cfg : ApplyConfig` via the syntax `apply_rules cfg lemmas`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n\nTODO: add support for attributes\nTODO: copy the other tests/examples from Lean 3\n",
  "args": ""},
 {"type": "Lean.MVarId → List Lean.Expr → Lean.MetaM Bool",
  "name": "Mathlib.Tactic.LibrarySearch.librarySearch.checkRequired",
  "kind": "def",
  "doc_string":
  "Verify that the instantiated goal contains each `Expr` in `required` as a sub-expression.\n(Make sure to not reset the state before calling.) ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : One M] [inst_1 : One N] {f g : OneHom M N}, f = g → ∀ (x : M), ↑f x = ↑g x",
  "name": "OneHom.congr_fun",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.congr_fun` instead. ",
  "args": ""},
 {"type":
  "∀ {R : Type u} [inst : EuclideanDomain R] [inst_1 : DecidableEq R] (a b : R),\n  EuclideanDomain.gcd a b = a * EuclideanDomain.gcdA a b + b * EuclideanDomain.gcdB a b",
  "name": "EuclideanDomain.gcd_eq_gcd_ab",
  "kind": "theorem",
  "doc_string":
  "An explicit version of **Bézout's lemma** for Euclidean domains. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} {α : Type u_3} [inst : SMul M N] [inst_1 : SMul N α] [inst_2 : SMul M α]\n  [self : IsScalarTower M N α] (x : M) (y : N) (z : α), (x • y) • z = x • y • z",
  "name": "IsScalarTower.smul_assoc",
  "kind": "def",
  "doc_string": "Associativity of `•` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : α → Sort u_2} → [inst : CoeFun α β] → CoeFun (Additive α) fun a => β (↑Additive.toMul a)",
  "name": "Additive.coeToFun",
  "kind": "def",
  "doc_string":
  "If `α` has some multiplicative structure and coerces to a function,\nthen `Additive α` should also coerce to the same function.\n\nThis allows `Additive` to be used on bundled function types with a multiplicative structure, which\nis often used for composition, without affecting the behavior of the function itself.\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_∈_»",
  "kind": "def",
  "doc_string":
  "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : HeytingAlgebra α] → Heyting.Regular α → α",
  "name": "Heyting.Regular.val",
  "kind": "def",
  "doc_string": "The coercion `Regular α → α` ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → α → Prop} →\n        {s : β → β → Prop} →\n          (f : α → β → γ) →\n            (∀ (a : α) (b₁ b₂ : β), s b₁ b₂ → f a b₁ = f a b₂) →\n              (∀ (a₁ a₂ : α) (b : β), r a₁ a₂ → f a₁ b = f a₂ b) → Quot r → Quot s → γ",
  "name": "Quot.lift₂",
  "kind": "def",
  "doc_string":
  "Descends a function `f : α → β → γ` to quotients of `α` and `β`. ",
  "args": ""},
 {"type": "{α : Type u} → List α",
  "name": "List.nil",
  "kind": "def",
  "doc_string": "`[]` is the empty list. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {G : Type u_2} → [inst : MulOneClass M] → [inst_1 : CommGroup G] → Inv (M →* G)",
  "name":
  "MonoidHom.instInvMonoidHomToMulOneClassToMonoidToDivInvMonoidToGroup",
  "kind": "def",
  "doc_string":
  "If `f` is a monoid homomorphism to a commutative group, then `f⁻¹` is the homomorphism sending\n`x` to `(f x)⁻¹`. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Monoid M] → Mᵐᵒᵖˣ ≃* Mˣᵐᵒᵖ",
  "name": "Units.opEquiv",
  "kind": "def",
  "doc_string":
  "The units of the opposites are equivalent to the opposites of the units. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : PartialOrder α] → (c : ClosureOperator α) → GaloisInsertion (ClosureOperator.toClosed c) Subtype.val",
  "name": "ClosureOperator.gi",
  "kind": "def",
  "doc_string":
  "The set of closed elements has a Galois insertion to the underlying type. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CanonicallyOrderedCommSemiring",
  "kind": "inductive",
  "doc_string":
  "A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. ",
  "args": ""},
 {"type":
  "(Type u₁ → Type u₂) → Type u → outParam (Type v) → Type (max (max (max u (u₁ + 1)) u₂) v)",
  "name": "ForIn",
  "kind": "inductive",
  "doc_string":
  "`ForIn m ρ α` is the typeclass which supports `for x in xs` notation.\nHere `xs : ρ` is the type of the collection to iterate over, `x : α`\nis the element type which is made available inside the loop, and `m` is the monad\nfor the encompassing `do` block.\n",
  "args": ""},
 {"type": "ToAdditive.Config → Bool",
  "name": "ToAdditive.Config.allowAutoName",
  "kind": "def",
  "doc_string":
  "If `allowAutoName` is `false` (default) then\n`@[to_additive]` will check whether the given name can be auto-generated. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → Q(CommSemiring «$α») → Q(«$α») → Type",
  "name": "Mathlib.Tactic.Ring.ExProd",
  "kind": "inductive",
  "doc_string":
  "A monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddMonoid M] → [inst_1 : AddMonoid N] → [inst_2 : AddAction M N] → [inst_3 : VAddAssocClass M N N] → M →+ N",
  "name": "vaddZeroHom",
  "kind": "def",
  "doc_string":
  "If the additive action of `M` on `N` is compatible with addition on `N`, then\n`fun x => x +ᵥ 0` is an additive monoid homomorphism from `M` to `N`.",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_|||_»",
  "kind": "def",
  "doc_string":
  "`a ||| b` computes the bitwise OR of `a` and `b`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_→*o_»",
  "kind": "def",
  "doc_string": "Infix notation for `OrderMonoidHom`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "precMin",
  "kind": "def",
  "doc_string": "Minimum precedence used in term parsers. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.tacticExpect_failure_",
  "kind": "def",
  "doc_string":
  "`expect_failure tacs` succeeds iff `tacs` fails.\n\n`expect_failure` is similar to `success_if_failure` from core, except that `success_if_failure`\nomits `withoutRecover`. When this is fixed, `expect_failure` can be deprecated or turned into a\nmacro.\n",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    {M' : Type u_3} →\n      [inst : Zero R] →\n        [inst_1 : Zero M] →\n          [inst_2 : SMulWithZero R M] →\n            [inst_3 : Zero M'] →\n              [inst_4 : SMul R M'] →\n                (f : ZeroHom M M') →\n                  Function.Surjective ↑f → (∀ (a : R) (b : M), ↑f (a • b) = a • ↑f b) → SMulWithZero R M'",
  "name": "Function.Surjective.smulWithZero",
  "kind": "def",
  "doc_string":
  "Pushforward a `SMulWithZero` structure along a surjective zero-preserving homomorphism.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {M : Type u_2} {N : Type u_3} {inst : Mul M} {inst_1 : Mul N} [self : MulHomClass F M N] (f : F)\n  (x y : M), ↑f (x * y) = ↑f x * ↑f y",
  "name": "MulHomClass.map_mul",
  "kind": "def",
  "doc_string": "The proposition that the function preserves multiplication ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → Submonoid M → Submonoid N → Submonoid (M × N)",
  "name": "Submonoid.prod",
  "kind": "def",
  "doc_string":
  "Given submonoids `s`, `t` of monoids `M`, `N` respectively, `s × t` as a submonoid\nof `M × N`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → List (α × β) → (cmp : α → α → Ordering) → Std.RBMap α β cmp",
  "name": "List.toRBMap",
  "kind": "def",
  "doc_string":
  "`O(n log n)`. Build a tree from an unsorted list by inserting them one at a time. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], 0 < 1",
  "name": "one_pos",
  "kind": "theorem",
  "doc_string": "**Alias** of `zero_lt_one`.",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {G : Type u_3} →\n      [inst : MulOneClass R] →\n        [inst_1 : MulOneClass S] →\n          [inst_2 : MonoidHomClass G S R] →\n            (f : R → S) → (g : G) → (r : R) → Function.LeftInverse (↑g) f → [inst_3 : Invertible (f r)] → Invertible r",
  "name": "Invertible.ofLeftInverse",
  "kind": "def",
  "doc_string":
  "If a function `f : R → S` has a left-inverse that is a monoid hom,\nthen `r : R` is invertible if `f r` is.\n\nThe inverse is computed as `g (⅟(f r))` ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {M : Type u_3} →\n      [inst : Zero M] →\n        [inst_1 : SMulZeroClass R M] →\n          [inst_2 : SMul S M] →\n            (f : R → S) → Function.Surjective f → (∀ (c : R) (x : M), f c • x = c • x) → SMulZeroClass S M",
  "name": "Function.Surjective.smulZeroClassLeft",
  "kind": "def",
  "doc_string":
  "Push forward the multiplication of `R` on `M` along a compatible surjective map `f : R → S`.\n\nSee also `Function.Surjective.distribMulActionLeft`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → (s : Set α) → [inst : SupSet α] → [inst : Inhabited ↑s] → SupSet ↑s",
  "name": "subsetSupSet",
  "kind": "def",
  "doc_string":
  "`SupSet` structure on a nonempty subset `s` of an object with `SupSet`. This definition is\nnon-canonical (it uses `default s`); it should be used only as here, as an auxiliary instance in the\nconstruction of the `ConditionallyCompleteLinearOrder` structure. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "guardGoalNums",
  "kind": "def",
  "doc_string":
  "`guard_goal_nums n` succeeds if there are exactly `n` goals and fails otherwise. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : SuccOrder α] [inst_2 : IsSuccArchimedean α] (r : α → α → Prop)\n  {n m : α},\n  (∀ (i : α), i ∈ Set.Ico n m → r i (Order.succ i)) →\n    (∀ (i : α), i ∈ Set.Ico m n → r (Order.succ i) i) → n ≠ m → Relation.TransGen r n m",
  "name": "transGen_of_succ_of_ne",
  "kind": "theorem",
  "doc_string":
  "For `n ≠ m`,`(n, m)` is in the transitive closure of a relation `~` if `i ~ succ i` and\n`succ i ~ i` for all `i` between `n` and `m`. ",
  "args": ""},
 {"type": "{α : Sort u_1} → Unique (Unique α) ≃ Unique α",
  "name": "uniqueUniqueEquiv",
  "kind": "def",
  "doc_string": "`Unique (Unique α)` is equivalent to `Unique α`. ",
  "args": ""},
 {"type": "Type u → (Type u → Type v) → Type (max (u + 1) v)",
  "name": "MonadStateOf",
  "kind": "inductive",
  "doc_string":
  "An implementation of [`MonadState`]. In contrast to the Haskell implementation,\nwe use overlapping instances to derive instances automatically from `monadLift`.\n\n  [`MonadState`]: https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : PredOrder α] [self : IsPredArchimedean α] {a b : α},\n  a ≤ b → ∃ n, Nat.iterate Order.pred n b = a",
  "name": "IsPredArchimedean.exists_pred_iterate_of_le",
  "kind": "def",
  "doc_string":
  "If `a ≤ b` then one can get to `b` from `a` by iterating `pred` ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → (α : Type u_3) → [inst : SMul M α] → [inst : SMul N α] → Prop",
  "name": "SMulCommClass",
  "kind": "inductive",
  "doc_string":
  "A typeclass mixin saying that two multiplicative actions on the same space commute. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {α : Type u_2} → [inst : Monoid M] → (M →* Function.End α) → MulAction M α",
  "name": "MulAction.ofEndHom",
  "kind": "def",
  "doc_string":
  "The monoid action induced by a monoid hom to `Function.End α`\n\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : AddGroup G] → G → G ≃ G",
  "name": "Equiv.subRight",
  "kind": "def",
  "doc_string":
  "A version of `equiv.add_right (-a) b` that is defeq to `b - a`. ",
  "args": ""},
 {"type":
  "∀ {K : Type u} [self : Field K] (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.coprime (Int.natAbs a) b),\n  ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹",
  "name": "Field.ratCast_mk",
  "kind": "def",
  "doc_string":
  "However `ratCast` is defined, propositionally it must be equal to `a * b⁻¹`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : BoundedOrder α] [inst_2 : IsSimpleOrder α] {a b : α}, a < b → b = ⊤",
  "name": "IsSimpleOrder.LT.lt.eq_top",
  "kind": "theorem",
  "doc_string": "**Alias** of `IsSimpleOrder.eq_top_of_lt`.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "HasCompl",
  "kind": "inductive",
  "doc_string": "Set / lattice complement ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddLeftCancelSemigroup R] (g : R), IsAddLeftRegular g",
  "name": "isAddLeftRegular_of_addLeftCancelSemigroup",
  "kind": "theorem",
  "doc_string":
  "Elements of an add left cancel semigroup are add-left-regular.",
  "args": ""},
 {"type":
  "∀ (α : Type u_1) [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 2",
  "name": "zero_lt_two'",
  "kind": "theorem",
  "doc_string": "See `zero_lt_two` for a version with the type implicit. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderTop α],\n  (∀ (c : Set α), IsChain (fun x x_1 => x ≤ x_1) c → Set.Nonempty c → ¬⊤ ∈ c → ∃ x x_1, x ∈ upperBounds c) →\n    IsCoatomic α",
  "name": "IsCoatomic.of_isChain_bounded",
  "kind": "theorem",
  "doc_string":
  "**Zorn's lemma**: A partial order is coatomic if every nonempty chain `c`, `⊤ ∉ c`, has an upper\nbound not equal to `⊤`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] (a b : α), a * b = b * a",
  "name": "CanonicallyOrderedCommSemiring.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Mul α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b c d : α},\n  a < b → c < d → a * c < b * d",
  "name": "Right.mul_lt_mul",
  "kind": "theorem",
  "doc_string": "Only assumes right strict covariance. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : SuccOrder α] {a b : α} [inst_2 : NoMaxOrder α],\n  a < b → Order.succ a < Order.succ b",
  "name": "Order.succ_lt_succ",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Order.succ_lt_succ_iff`.",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddZeroClass M] → (S : AddSubmonoid M) → Zero { x // x ∈ S }",
  "name": "AddSubmonoid.zero",
  "kind": "def",
  "doc_string": "An `AddSubmonoid` of an `AddMonoid` inherits a zero.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedCommMonoidWithZero α] (a : α), a * 0 = 0",
  "name": "LinearOrderedCommMonoidWithZero.mul_zero",
  "kind": "def",
  "doc_string": "Zero is a right absorbing element for multiplication ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«stx_,*»",
  "kind": "def",
  "doc_string":
  "`p,*` is shorthand for `sepBy(p, \",\")`. It parses 0 or more occurrences of\n`p` separated by `,`, that is: `empty | p | p,p | p,p,p | ...`.\n\nIt produces a `nullNode` containing a `SepArray` with the interleaved parser\nresults. It has arity 1, and auto-groups its component parser if needed.\n",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] → {l : α → β} → {u : β → α} → GaloisCoinsertion l u → (x : β) → x ≤ l (u x) → α",
  "name": "GaloisCoinsertion.choice",
  "kind": "def",
  "doc_string": "A contructive choice function for images of `u`. ",
  "args": ""},
 {"type": "{α : Type u} → List α → List (List α) → List α",
  "name": "List.intercalate",
  "kind": "def",
  "doc_string":
  "`O(|xs|)`. `intercalate sep xs` alternates `sep` and the elements of `xs`:\n* `intercalate sep [] = []`\n* `intercalate sep [a] = a`\n* `intercalate sep [a, b] = a ++ sep ++ b`\n* `intercalate sep [a, b, c] = a ++ sep ++ b ++ sep ++ c`\n",
  "args": ""},
 {"type": "Sat.Valuation → Sat.Literal → Prop",
  "name": "Sat.Valuation.neg",
  "kind": "def",
  "doc_string":
  "`v.neg lit` asserts that literal `lit` is falsified in the valuation. ",
  "args": ""},
 {"type": "ℤ → ℕ → ℚ",
  "name": "mkRat",
  "kind": "def",
  "doc_string":
  "Construct a rational number from a numerator and denominator.\nThis is a \"smart constructor\" that divides the numerator and denominator by\nthe gcd to ensure that the resulting rational number is normalized, and returns\nzero if `den` is zero.\n",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → (α → β) → ULift α → ULift β",
  "name": "ULift.map",
  "kind": "def",
  "doc_string": "Functorial action. ",
  "args": ""},
 {"type": "UInt32 → Prop",
  "name": "isValidChar",
  "kind": "def",
  "doc_string":
  "Determines if the given integer is a valid [Unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value).\n\nNote that values in `[0xd800, 0xdfff]` are reserved for [UTF-16 surrogate pairs](https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates).\n",
  "args": ""},
 {"type": "{α : Sort u_1} → {r : α → α → Prop} → Quot r → α",
  "name": "Quot.unquot",
  "kind": "def",
  "doc_string":
  "Unwrap the VM representation of a quotient to obtain an element of the equivalence class.\nComputable but unsound. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.replace'",
  "kind": "def",
  "doc_string":
  "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\nThen after `replace h : β` the state will be:\n\n```lean\ncase h\nf : α → β\nh : α\n⊢ β\n\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h : β` would result in:\n\n```lean\ncase h\nf : α → β\nh : α\n⊢ β\n\nf : α → β\nh✝ : α\nh : β\n⊢ goal\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisInsertion l u → GaloisConnection l u",
  "name": "GaloisInsertion.gc",
  "kind": "def",
  "doc_string": "The Galois connection associated to a Galois insertion. ",
  "args": ""},
 {"type": "Linarith.CompSource → Std.HashMap ℕ ℕ",
  "name": "Linarith.CompSource.flatten",
  "kind": "def",
  "doc_string":
  "Given a `CompSource` `cs`, `cs.flatten` maps an assumption index\nto the number of copies of that assumption that appear in the history of `cs`.\n\nFor example, suppose `cs` is produced by scaling assumption 2 by 5,\nand adding to that the sum of assumptions 1 and 2.\n`cs.flatten` maps `1 ↦ 1, 2 ↦ 6`.\n ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Option α) → List α → Array α → List α",
  "name": "List.lookmap.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `lookmap`: `lookmap.go f l acc = acc.toList ++ lookmap f l`. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Add M] → AddSubsemigroup M → Set M",
  "name": "AddSubsemigroup.carrier",
  "kind": "def",
  "doc_string": "The carrier of an additive subsemigroup. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] →\n        (e : M ≃* N) → (S : Submonoid M) → { x // x ∈ S } ≃* { x // x ∈ Submonoid.map (MulEquiv.toMonoidHom e) S }",
  "name": "MulEquiv.submonoidMap",
  "kind": "def",
  "doc_string":
  "A `MulEquiv` `φ` between two monoids `M` and `N` induces a `MulEquiv` between\na submonoid `S ≤ M` and the submonoid `φ(S) ≤ N`.\nSee `MonoidHom.submonoidMap` for a variant for `MonoidHom`s. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} (M : Type u_2) {a : R} [inst : Monoid R] [inst_1 : MulAction R M], IsUnit a → IsSMulRegular M a",
  "name": "IsUnit.isSMulRegular",
  "kind": "theorem",
  "doc_string": "A unit is `M`-regular. ",
  "args": ""},
 {"type": "Ordering → Ordering → Ordering",
  "name": "Ordering.orElse",
  "kind": "def",
  "doc_string": "Combine two `Ordering`s lexicographically. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : Add M] → [inst : Add N] → Type (max u_1 u_2)",
  "name": "AddHom",
  "kind": "inductive",
  "doc_string":
  "`AddHom M N` is the type of functions `M → N` that preserve addition.\n\nWhen possible, instead of parametrizing results over `(f : AddHom M N)`,\nyou should parametrize over `(F : Type*) [AddHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `AddHomClass`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : NonAssocRing α] [inst_1 : NonAssocRing β] (f : α →+* β) (x : α), ↑f (-x) = -↑f x",
  "name": "RingHom.map_neg",
  "kind": "theorem",
  "doc_string": "Ring homomorphisms preserve additive inverse. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {X Y : C} →\n          (F : C ⥤ D) →\n            [inst_2 : CategoryTheory.Full F] →\n              (Prefunctor.obj F.toPrefunctor X ⟶ Prefunctor.obj F.toPrefunctor Y) → (X ⟶ Y)",
  "name": "CategoryTheory.Functor.preimage",
  "kind": "def",
  "doc_string": "The specified preimage of a morphism under a full functor. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → [ord : Ord α] → [inst_1 : Inhabited α] → Array α → Aesop.UnorderedArraySet α",
  "name": "Aesop.UnorderedArraySet.ofArray",
  "kind": "def",
  "doc_string": "O(n*log(n)) ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {b : α},\n  Set.Nonempty s → (∀ (a : α), a ∈ s → a ≤ b) → (∀ (w : α), w < b → ∃ a, a ∈ s ∧ w < a) → supₛ s = b",
  "name": "csupₛ_eq_of_forall_le_of_forall_lt_exists_gt",
  "kind": "theorem",
  "doc_string":
  "Introduction rule to prove that `b` is the supremum of `s`: it suffices to check that `b`\nis larger than all elements of `s`, and that this is not the case of any `w<b`.\nSee `supₛ_eq_of_forall_le_of_forall_lt_exists_gt` for a version in complete lattices. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → α × β → (_ : α) × β",
  "name": "Prod.toSigma",
  "kind": "def",
  "doc_string": "Convert a product type to a Σ-type. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [ord : Ord α] → Array α → Array α → (α → α → α) → Array α",
  "name": "Array.mergeSortedMergingDuplicates",
  "kind": "def",
  "doc_string":
  "Merge arrays `xs` and `ys`, which must be sorted according to `compare` and must\nnot contain duplicates. The result is sorted as well. Equal elements are merged\nusing `merge`. If `xs` and `ys` do not contain duplicates according to\n`compare`, then neither does the result.\n",
  "args": ""},
 {"type":
  "{α : Prop} → {p : α → Prop} → {C : Sort u_1} → C → ((a : α) → p a → C) → C",
  "name": "Classical.existsCases",
  "kind": "def",
  "doc_string":
  "Construct a function from a default value `H0`, and a function to use if there exists a value\nsatisfying the predicate. ",
  "args": ""},
 {"type": "{C : Sort u_1} → Empty → C",
  "name": "Empty.elim",
  "kind": "def",
  "doc_string": "Ex falso, the nondependent eliminator for the `Empty` type. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α) → ℕ → List α → List α",
  "name": "List.modifyNth",
  "kind": "def",
  "doc_string": "Apply `f` to the nth element of the list, if it exists. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m n : ℕ}, ↑(m / n) ≤ ↑m / ↑n",
  "name": "Nat.cast_div_le",
  "kind": "theorem",
  "doc_string": "Natural division is always less than division in the field. ",
  "args": ""},
 {"type": "{α : Type u_1} → (x : WithBot α) → x ≠ ⊥ → α",
  "name": "WithBot.unbot",
  "kind": "def",
  "doc_string":
  "Deconstruct a `x : WithBot α` to the underlying value in `α`, given a proof that `x ≠ ⊥`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y",
  "name": "RingEquiv.map_mul",
  "kind": "theorem",
  "doc_string": "A ring isomorphism preserves multiplication. ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → [self : CoeTail α β] → α → β",
  "name": "CoeTail.coe",
  "kind": "def",
  "doc_string":
  "Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. ",
  "args": ""},
 {"type": "Lean.Expr → Mathlib.Tactic.Ring.RingM ℕ",
  "name": "Mathlib.Tactic.Ring.addAtom",
  "kind": "def",
  "doc_string":
  "Get the index corresponding to an atomic expression, if it has already been encountered, or\nput it in the list of atoms and return the new index, otherwise. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⁻¹'o_»",
  "kind": "def",
  "doc_string":
  "Given a relation `R` on `β` and a function `f : α → β`, the preimage relation on `α` is defined\nby `x ≤ y ↔ f x ≤ f y`. It is the unique relation on `α` making `f` a `RelEmbedding` (assuming `f`\nis injective). ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {x dx y dy : α},\n  dy < dx → 0 < dx → Nonempty ↑(Set.Ico x (x + dx) \\ Set.Ico y (y + dy))",
  "name": "Set.nonempty_Ico_sdiff",
  "kind": "theorem",
  "doc_string":
  "If we remove a smaller interval from a larger, the result is nonempty ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] ⦃f g : M →+ N⦄, ↑f = ↑g → f = g",
  "name": "AddMonoidHom.coe_inj",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.coe_injective` instead.",
  "args": ""},
 {"type":
  "∀ {M : Type u} [self : AddLeftCancelMonoid M] (n : ℕ) (x : M),\n  AddLeftCancelMonoid.nsmul (n + 1) x = x + AddLeftCancelMonoid.nsmul n x",
  "name": "AddLeftCancelMonoid.nsmul_succ",
  "kind": "def",
  "doc_string": "Multiplication by `(n + 1 : ℕ)` behaves as expected. ",
  "args": ""},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "name": "Bind",
  "kind": "inductive",
  "doc_string":
  "The typeclass which supplies the `>>=` \"bind\" function. See `Monad`. ",
  "args": ""},
 {"type":
  "Type u_1 →\n  (M : outParam (Type u_2)) → (N : outParam (Type u_3)) → [inst : Add M] → [inst : Add N] → Type (max (max u_1 u_2) u_3)",
  "name": "AddHomClass",
  "kind": "inductive",
  "doc_string":
  "`AddHomClass F M N` states that `F` is a type of addition-preserving homomorphisms.\nYou should declare an instance of this typeclass when you extend `AddHom`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → Setoid α → Setoid β → Setoid (α × β)",
  "name": "Setoid.prod",
  "kind": "def",
  "doc_string":
  "Given types `α`, `β`, the product of two equivalence relations `r` on `α` and `s` on `β`:\n`(x₁, x₂), (y₁, y₂) ∈ α × β` are related by `r.prod s` iff `x₁` is related to `y₁`\nby `r` and `x₂` is related to `y₂` by `s`. ",
  "args": ""},
 {"type":
  "(Type u → Type v) → (Type u → Type w) → Type (max (max (u + 1) v) w)",
  "name": "MonadFunctorT",
  "kind": "inductive",
  "doc_string":
  "The reflexive-transitive closure of `MonadFunctor`.\n`monadMap` is used to transitively lift `Monad` morphisms. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), (∀ (b : α), b ∈ s → b ≤ a) → supₛ s ≤ a",
  "name": "CompleteSemilatticeSup.supₛ_le",
  "kind": "def",
  "doc_string": "Any upper bound is more than the set supremum. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Preorder α] → [inst_1 : MulOneClass α] → α →*o α",
  "name": "OrderMonoidHom.id",
  "kind": "def",
  "doc_string": "The identity map as an ordered monoid homomorphism. ",
  "args": ""},
 {"type":
  "{p q : Prop} → SlimCheck.TestResult p → SlimCheck.TestResult q → SlimCheck.TestResult (p ∧ q)",
  "name": "SlimCheck.TestResult.and",
  "kind": "def",
  "doc_string":
  "Combine the test result for properties `p` and `q` to create a test for their conjunction. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → M × N →+ N",
  "name": "AddMonoidHom.snd",
  "kind": "def",
  "doc_string":
  "Given additive monoids `A`, `B`, the natural projection homomorphism\nfrom `A × B` to `B`",
  "args": ""},
 {"type": "ZNum → Num",
  "name": "Num.ofZNum",
  "kind": "def",
  "doc_string":
  "Converts a `ZNum` to an `Option Num`, where `ofZNum p = 0` if `p < 0`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {r : α → α → Prop} → WellFounded r → α → α",
  "name": "WellFounded.succ",
  "kind": "def",
  "doc_string":
  "A successor of an element `x` in a well-founded order is a minimal element `y` such that\n`x < y` if one exists. Otherwise it is `x` itself. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : DivisionMonoid α] {a : α}, IsSquare a → IsSquare a⁻¹",
  "name": "IsSquare.inv",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `isSquare_inv`.",
  "args": ""},
 {"type": "ℤ",
  "name": "Int.zero",
  "kind": "def",
  "doc_string": "The number `0 : ℤ`, as a standalone definition. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] (l₁ l₂ : List α), (l₁ ≤ l₂) = ¬l₂ < l₁",
  "name": "List.le_eq_not_gt",
  "kind": "theorem",
  "doc_string": "`≤` implies not `>` for lists. ",
  "args": ""},
 {"type": "Lean.MVarId → List Mathlib.Tactic.MkIff.Shape → Lean.MetaM Unit",
  "name": "Mathlib.Tactic.MkIff.toCases",
  "kind": "def",
  "doc_string":
  "Proves the left to right direction of a generated iff theorem.\n`shape` is the output of a call to `constrToProp`.\n",
  "args": ""},
 {"type":
  "Lean.PersistentEnvExtension Mathlib.Meta.Positivity.Entry\n  (Mathlib.Meta.Positivity.Entry × Mathlib.Meta.Positivity.PositivityExt)\n  (List Mathlib.Meta.Positivity.Entry × Lean.Meta.DiscrTree Mathlib.Meta.Positivity.PositivityExt true)",
  "name": "Mathlib.Meta.Positivity.positivityExt",
  "kind": "opaque",
  "doc_string": "Environment extensions for `positivity` declarations ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "prioLow",
  "kind": "def",
  "doc_string":
  "The standardized \"low\" priority `low = 100`, for things that should be lower than default priority. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → List α → Option α × List α",
  "name": "List.extractp",
  "kind": "def",
  "doc_string":
  "`extractp p l` returns a pair of an element `a` of `l` satisfying the predicate\n`p`, and `l`, with `a` removed. If there is no such element `a` it returns `(none, l)`. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Mul M] → { x // x ∈ ⊤ } ≃* M",
  "name": "Subsemigroup.topEquiv",
  "kind": "def",
  "doc_string": "The top subsemigroup is isomorphic to the semigroup. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] (a b c : α), a * b * c = a * (b * c)",
  "name": "CanonicallyOrderedCommSemiring.mul_assoc",
  "kind": "def",
  "doc_string": "Multiplication is associative ",
  "args": ""},
 {"type":
  "∀ {R : Type u} [self : EuclideanDomain R] (a : R), EuclideanDomain.quotient a 0 = 0",
  "name": "EuclideanDomain.quotient_zero",
  "kind": "def",
  "doc_string": "Division by zero should always give zero by convention. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : AddZeroClass M] → Bot (AddSubmonoid M)",
  "name": "AddSubmonoid.instBotAddSubmonoid",
  "kind": "def",
  "doc_string": "The trivial `AddSubmonoid` `{0}` of an `AddMonoid` `M`.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulZeroOneClass M] [inst_1 : MulZeroOneClass N] (f : M →*₀ N) {x y : M},\n  x = y → ↑f x = ↑f y",
  "name": "MonoidWithZeroHom.congr_arg",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.congr_arg` instead. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : ConditionallyCompleteLinearOrderBot α], supₛ ∅ = ⊥",
  "name": "ConditionallyCompleteLinearOrderBot.csupₛ_empty",
  "kind": "def",
  "doc_string": "The supremum of the empty set is `⊥` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → {x : Zero M} → {x_1 : Zero N} → (f : ZeroHom M N) → (f' : M → N) → f' = ↑f → ZeroHom M N",
  "name": "ZeroHom.copy",
  "kind": "def",
  "doc_string":
  "Copy of a `ZeroHom` with a new `toFun` equal to the old one. Useful to fix\ndefinitional equalities.",
  "args": ""},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → List α → ℕ",
  "name": "List.findIndex",
  "kind": "def",
  "doc_string": "Find index of element with given property. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → [inst : Unique M] → [inst : Unique N] → [inst : Add M] → [inst_1 : Add N] → Unique (M ≃+ N)",
  "name": "AddEquiv.instUniqueAddEquiv",
  "kind": "def",
  "doc_string":
  "There is a unique additive monoid homomorphism between two additive monoids with\na unique element.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.introv",
  "kind": "def",
  "doc_string":
  "The tactic `introv` allows the user to automatically introduce the variables of a theorem and\nexplicitly name the non-dependent hypotheses.\nAny dependent hypotheses are assigned their default names.\n\nExamples:\n```\nexample : ∀ a b : Nat, a = b → b = a := by\n  introv h,\n  exact h.symm\n```\nThe state after `introv h` is\n```\na b : ℕ,\nh : a = b\n⊢ b = a\n```\n\n```\nexample : ∀ a b : Nat, a = b → ∀ c, b = c → a = c := by\n  introv h₁ h₂,\n  exact h₁.trans h₂\n```\nThe state after `introv h₁ h₂` is\n```\na b : ℕ,\nh₁ : a = b,\nc : ℕ,\nh₂ : b = c\n⊢ a = c\n```\n",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "LinearOrderedCommGroupWithZero",
  "kind": "inductive",
  "doc_string": "A linearly ordered commutative group with a zero element. ",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  {H : Type u_2} → [inst : MulOneClass G] → [inst_1 : AddZeroClass H] → G ≃* Multiplicative H ≃ (Additive G ≃+ H)",
  "name": "MulEquiv.toAdditive'",
  "kind": "def",
  "doc_string": "Reinterpret `G ≃* Multiplicative H` as `Additive G ≃+ H` as. ",
  "args": ""},
 {"type": "{α : Type u_1} → α ≃ Lex α",
  "name": "toLex",
  "kind": "def",
  "doc_string": "`toLex` is the identity function to the `Lex` of a type.  ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Top",
  "kind": "inductive",
  "doc_string": "Typeclass for the `⊤` (`\\top`) notation ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : AddCommMonoid α] → α × α →+ α",
  "name": "addAddMonoidHom",
  "kind": "def",
  "doc_string": "Addition as an additive monoid homomorphism.",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Thunk α → Thunk β",
  "name": "Thunk.map",
  "kind": "def",
  "doc_string": "Map a function over a thunk. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → [inst : Add M] → GaloisInsertion AddSubsemigroup.closure SetLike.coe",
  "name": "AddSubsemigroup.gi",
  "kind": "def",
  "doc_string": "`closure` forms a Galois insertion with the coercion to set.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : HasSup α] →\n      [inst_1 : HasInf α] →\n        [inst_2 : Top α] →\n          [inst_3 : Bot α] →\n            [inst_4 : HNot α] →\n              [inst_5 : SDiff α] →\n                [inst_6 : CoheytingAlgebra β] →\n                  (f : α → β) →\n                    Function.Injective f →\n                      (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) →\n                        (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) →\n                          f ⊤ = ⊤ →\n                            f ⊥ = ⊥ →\n                              (∀ (a : α), f (￢a) = ￢f a) → (∀ (a b : α), f (a \\ b) = f a \\ f b) → CoheytingAlgebra α",
  "name": "Function.Injective.coheytingAlgebra",
  "kind": "def",
  "doc_string": "Pullback a `CoheytingAlgebra` along an injection. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  (p : α → Sort u_1) → {f : α → α} → ((a : α) → p a → p (f a)) → {a : α} → p a → (n : ℕ) → p (Nat.iterate f n a)",
  "name": "Function.Iterate.rec",
  "kind": "def",
  "doc_string": "A recursor for the iterate of a function. ",
  "args": ""},
 {"type": "Linarith.Linexp → List ℕ",
  "name": "Linarith.Linexp.vars",
  "kind": "def",
  "doc_string": "`l.vars` returns the list of variables that occur in `l`. ",
  "args": ""},
 {"type": "{α : Type u} → α → αᵃᵒᵖ",
  "name": "AddOpposite.op",
  "kind": "def",
  "doc_string": "The element of `αᵃᵒᵖ` that represents `x : α`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (Option α → β → γ) → List α → List β → List γ",
  "name": "List.map₂Right",
  "kind": "def",
  "doc_string":
  "Right-biased version of `List.map₂`. `map₂Right f as bs` applies `f` to each\npair `aᵢ ∈ as` and `bᵢ ‌∈ bs`. If `as` is shorter than `bs`, `f` is applied to\n`none` for the remaining `bᵢ`.\n\n```\nmap₂Right Prod.mk [1, 2] ['a'] = [(some 1, 'a')]\n\nmap₂Right Prod.mk [1] ['a', 'b'] = [(some 1, 'a'), (none, 'b')]\n\nmap₂Right f as bs = (map₂Right' f as bs).fst\n```\n",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Mul M] → Subsemigroup M ≃o AddSubsemigroup (Additive M)",
  "name": "Subsemigroup.toAddSubsemigroup",
  "kind": "def",
  "doc_string":
  "Subsemigroups of semigroup `M` are isomorphic to additive subsemigroups of `Additive M`. ",
  "args": ""},
 {"type": "{α : Type u_1} → α → WithBot α → α",
  "name": "WithBot.unbot'",
  "kind": "def",
  "doc_string":
  "Specialization of `Option.get_or_else` to values in `WithBot α` that respects API boundaries.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Add α] → [inst_1 : Add β] → α ≃+ β ≃ (αᵃᵒᵖ ≃+ βᵃᵒᵖ)",
  "name": "AddEquiv.op",
  "kind": "def",
  "doc_string":
  "A iso `α ≃+ β` can equivalently be viewed as an iso `αᵃᵒᵖ ≃+ βᵃᵒᵖ`.",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → α ≃ β → α → β",
  "name": "Equiv.Simps.apply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : CancelCommMonoidWithZero α] →\n    [inst_1 : NormalizationMonoid α] →\n      [inst_2 : DecidableEq α] → (∀ (a b : α), ∃ c, ∀ (d : α), d ∣ a ∧ d ∣ b ↔ d ∣ c) → NormalizedGCDMonoid α",
  "name": "normalizedGCDMonoidOfExistsGCD",
  "kind": "def",
  "doc_string":
  "Define a `NormalizedGCDMonoid` structure on a monoid just from the existence of a `gcd`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : CompleteLinearOrder α] → DecidableRel fun x x_1 => x < x_1",
  "name": "CompleteLinearOrder.decidable_lt",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {s₁ : Setoid α} {s₂ : Setoid β} {p : Quotient s₁ → Quotient s₂ → Prop}\n  (q₁ : Quotient s₁) (q₂ : Quotient s₂), (∀ (a₁ : α) (a₂ : β), p (Quotient.mk'' a₁) (Quotient.mk'' a₂)) → p q₁ q₂",
  "name": "Quotient.inductionOn₂'",
  "kind": "theorem",
  "doc_string":
  "A version of `Quotient.inductionOn₂` taking `{s₁ : Setoid α} {s₂ : Setoid β}` as implicit\narguments instead of instance arguments. ",
  "args": ""},
 {"type": "ZNum → PosNum",
  "name": "PosNum.ofZNum",
  "kind": "def",
  "doc_string":
  "Converts a `ZNum` to a `PosNum`, mapping all out of range values to `1`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_$__»",
  "kind": "def",
  "doc_string":
  "Alternative syntax for `<|`. `f $ x` means the same as the same as `f x`,\nexcept that it parses `x` with lower precedence, which means that `f $ g $ x`\nis interpreted as `f (g x)` rather than `(f g) x`.\n",
  "args": ""},
 {"type":
  "∀ {M : Type u} [self : LeftCancelMonoid M] (n : ℕ) (x : M),\n  LeftCancelMonoid.npow (n + 1) x = x * LeftCancelMonoid.npow n x",
  "name": "LeftCancelMonoid.npow_succ",
  "kind": "def",
  "doc_string": "Raising to the power `(n + 1 : ℕ)` behaves as expected. ",
  "args": ""},
 {"type": "∀ {p : Prop} [self : Fact p], p",
  "name": "Fact.out",
  "kind": "def",
  "doc_string":
  "`Fact.out` contains the unwrapped witness for the fact represented by the instance of\n`Fact p`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : NonAssocSemiring α] → [inst_1 : NonAssocSemiring β] → (α →+* β) → α →ₙ+* β",
  "name": "RingHom.toNonUnitalRingHom",
  "kind": "def",
  "doc_string":
  "Reinterpret a ring homomorphism `f : α →+* β` as a non-unital ring homomorphism `α →ₙ+* β`. The\n`simp`-normal form is `(f : α →ₙ+* β)`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Option α) → List α → List α",
  "name": "List.lookmap",
  "kind": "def",
  "doc_string":
  "`lookmap` is a combination of `lookup` and `filterMap`.\n`lookmap f l` will apply `f : α → Option α` to each element of the list,\nreplacing `a → b` at the first value `a` in the list such that `f a = some b`.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → {P : Type u_3} → [inst : Mul M] → [inst_1 : Mul N] → [inst_2 : Mul P] → M ≃* N → N ≃* P → M ≃* P",
  "name": "MulEquiv.trans",
  "kind": "def",
  "doc_string": "Transitivity of multiplication-preserving isomorphisms ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  a ≤ 0 → b < 0 → a + b < 0",
  "name": "Right.add_neg_of_nonpos_of_neg",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg_of_nonpos_of_neg`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : SemilatticeSup α] (a b c : α), a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "name": "SemilatticeSup.sup_le",
  "kind": "def",
  "doc_string": "The supremum is the *least* upper bound ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : PartialOrder α] →\n      [inst_1 : Preorder β] → [inst_2 : OrderTop β] → {l : α → β} → {u : β → α} → GaloisConnection l u → OrderTop α",
  "name": "GaloisConnection.liftOrderTop",
  "kind": "def",
  "doc_string": "Lift the top along a Galois connection ",
  "args": ""},
 {"type": "Num → ZNum",
  "name": "Num.toZNumNeg",
  "kind": "def",
  "doc_string": "Converts `x : Num` to `-x : ZNum`. ",
  "args": ""},
 {"type": "Lean.Expr → Option Lean.Expr",
  "name": "Linarith.isNatIntCoe",
  "kind": "def",
  "doc_string":
  "If `e` is of the form `((n : ℕ) : ℤ)`, `isNatIntCoe e` returns `n : ℕ`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → β → Prop} {a : α} {b : β}, r a b → Option.Rel r (some a) (some b)",
  "name": "Option.Rel.some",
  "kind": "def",
  "doc_string": "If `a ~ b`, then `some a ~ some b` ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Prop",
  "name": "StrictMono",
  "kind": "def",
  "doc_string":
  "A function `f` is strictly monotone if `a < b` implies `f a < f b`. ",
  "args": ""},
 {"type": "ℕ+ → ℕ+ → ℕ+",
  "name": "PNat.mod",
  "kind": "def",
  "doc_string":
  "We define `m % k` in the same way as for `ℕ`\nexcept that when `m = n * k` we take `m % k = k` This ensures that `m % k` is always positive.\n",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        (F : C ⥤ D) → (∀ (X Y : C), Function.Surjective (Prefunctor.map F.toPrefunctor)) → CategoryTheory.Full F",
  "name": "CategoryTheory.Functor.fullOfSurjective",
  "kind": "def",
  "doc_string":
  "Deduce that `F` is full from surjectivity of `F.map`, using choice. ",
  "args": ""},
 {"type": "{σ : Type u} → EStateM.Backtrackable PUnit σ",
  "name": "EStateM.nonBacktrackable",
  "kind": "def",
  "doc_string":
  "Dummy default instance. This makes every `σ` trivially \"backtrackable\"\nby doing nothing on backtrack. Because this is the first declared instance\nof `Backtrackable _ σ`, it will be picked only if there are no other\n`Backtrackable _ σ` instances registered.\n",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.Monom",
  "kind": "def",
  "doc_string":
  "Variables (represented by natural numbers) map to their power. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : LE α] → OrderBot α ⊕' NoBotOrder α",
  "name": "botOrderOrNoBotOrder",
  "kind": "def",
  "doc_string":
  "An order is (noncomputably) either an `OrderBot` or a `NoBotOrder`. Use as\n`casesI botOrderOrNoBotOrder α`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → {S : Type u_2} → [inst : Semiring R] → [inst : Semiring S] → Semiring (R × S)",
  "name": "Prod.instSemiringProd",
  "kind": "def",
  "doc_string": "Product of two semirings is a semiring. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set α},\n  Set.OrdConnected s ↔ ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → Set.Icc x y ⊆ s",
  "name": "Set.ordConnected_iff",
  "kind": "theorem",
  "doc_string": "It suffices to prove `[[x, y]] ⊆ s` for `x y ∈ s`, `x ≤ y`. ",
  "args": ""},
 {"type": "∀ (n b : ℕ), (n + 1) / (b + 2) < n + 1",
  "name": "Nat.div_lt_self'",
  "kind": "theorem",
  "doc_string":
  "A version of `Nat.div_lt_self` using successors, rather than additional hypotheses. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {F : Type u_3} →\n      [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [inst_2 : AddMonoidHomClass F M N] → CoeTC F (M →+ N)",
  "name": "instCoeTCAddMonoidHom",
  "kind": "def",
  "doc_string":
  "Any type satisfying `AddMonoidHomClass` can be cast into `AddMonoidHom` via\n`AddMonoidHomClass.toAddMonoidHom`.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] →\n        (S : Submonoid M) → (f : M →* N) → Function.Injective ↑f → { x // x ∈ S } ≃* { x // x ∈ Submonoid.map f S }",
  "name": "Submonoid.equivMapOfInjective",
  "kind": "def",
  "doc_string":
  "A submonoid is isomorphic to its image under an injective function ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} →\n      [inst : Add M] → [inst_1 : Add N] → [inst_2 : AddCommSemigroup P] → AddHom M P → AddHom N P → AddHom (M × N) P",
  "name": "AddHom.coprod",
  "kind": "def",
  "doc_string":
  "Coproduct of two `AddHom`s with the same codomain:\n`f.coprod g (p : M × N) = f p.1 + g p.2`.",
  "args": ""},
 {"type":
  "∀ {G : Type u} [self : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)",
  "name": "AddSemigroup.add_assoc",
  "kind": "def",
  "doc_string": "Addition is associative ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Abel.AbelNF.Config",
  "kind": "inductive",
  "doc_string": "Configuration for `abel_nf`. ",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] (a : G₀), a⁻¹ * a * a = a",
  "name": "inv_mul_mul_self",
  "kind": "theorem",
  "doc_string":
  "Multiplying `a⁻¹` by `a` twice results in `a` (whether or not `a`\nis zero). ",
  "args": ""},
 {"type": "∀ {α : Type u_1} {s t : Set α}, s < t → s ⊂ t",
  "name": "LT.lt.ssubset",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `Set.lt_iff_ssubset`.",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : OrderedAddCommMonoid α] → (∀ (a : α), 0 ≤ a) → OrderedAddCommMonoid (WithZero α)",
  "name": "WithZero.orderedAddCommMonoid",
  "kind": "def",
  "doc_string":
  "If `0` is the least element in `α`, then `WithZero α` is an `OrderedAddCommMonoid`.\nSee note [reducible non-instances].\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedCancelAddCommMonoid α] (a b : α), min a b = if a ≤ b then a else b",
  "name": "LinearOrderedCancelAddCommMonoid.min_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `minOfLe`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLinearOrder α] {s : Set α} [hs : Set.OrdConnected s] ⦃t : Set ↑s⦄,\n  Set.Nonempty t → BddBelow t → infₛ (Subtype.val '' t) ∈ s",
  "name": "infₛ_within_of_ordConnected",
  "kind": "theorem",
  "doc_string":
  "The `infₛ` function on a nonempty `OrdConnected` set `s` in a conditionally complete linear\norder takes values within `s`, for all nonempty bounded-below subsets of `s`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} (rα : α → α → Prop) (rβ : β → β → Prop),\n  Prod.RProd rα rβ ≤ Relation.TransGen (Prod.GameAdd rα rβ)",
  "name": "Prod.rprod_le_transGen_gameAdd",
  "kind": "theorem",
  "doc_string":
  "`Prod.RProd` is a subrelation of the transitive closure of `GameAdd`. ",
  "args": ""},
 {"type": "{α : Type u} → α → (n : ℕ) → Vector α n",
  "name": "Vector.repeat",
  "kind": "def",
  "doc_string": "Vector obtained by repeating an element. ",
  "args": ""},
 {"type": "∀ {α : Type u} {s : Set α}, Set.univ ⊆ s → s = Set.univ",
  "name": "Set.eq_univ_of_univ_subset",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `Set.univ_subset_iff`.",
  "args": ""},
 {"type": "Type u → ℕ → Type u",
  "name": "OfNat",
  "kind": "inductive",
  "doc_string":
  "The class `OfNat α n` powers the numeric literal parser. If you write\n`37 : α`, lean will attempt to synthesize `OfNat α 37`, and will generate\nthe term `(OfNat.ofNat 37 : α)`.\n\nThere is a bit of infinite regress here since the desugaring apparently\nstill contains a literal `37` in it. The type of expressions contains a\nprimitive constructor for \"raw natural number literals\", which you can directly\naccess using the macro `nat_lit 37`. Raw number literals are always of type `Nat`.\nSo it would be more correct to say that lean looks for an instance of\n`OfNat α (nat_lit 37)`, and it generates the term `(OfNat.ofNat (nat_lit 37) : α)`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : OrderedAddCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "name": "OrderedAddCommGroup.add_le_add_left",
  "kind": "def",
  "doc_string":
  "Addition is monotone in a ordered additive commutative group. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : CommMonoid M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [inst : SubmonoidClass A M] → (S : A) → CommMonoid { x // x ∈ S }",
  "name": "SubmonoidClass.toCommMonoid",
  "kind": "def",
  "doc_string": "A submonoid of a `CommMonoid` is a `CommMonoid`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : NonUnitalNonAssocSemiring α] → [inst_1 : NonUnitalNonAssocSemiring β] → (α →ₙ+* β) ≃ (αᵐᵒᵖ →ₙ+* βᵐᵒᵖ)",
  "name": "NonUnitalRingHom.op",
  "kind": "def",
  "doc_string":
  "A non-unital ring hom `α →ₙ+* β` can equivalently be viewed as a non-unital ring hom\n`αᵐᵒᵖ →+* βᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. ",
  "args": ""},
 {"type": "{α : Type v} → ULift α ≃ α",
  "name": "Equiv.ulift",
  "kind": "def",
  "doc_string": "`ULift α` is equivalent to `α`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : LT α] → [inst : LE β] → LE (Lex (α × β))",
  "name": "Prod.Lex.instLE",
  "kind": "def",
  "doc_string": "Dictionary / lexicographic ordering on pairs.  ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisCoinsertion l u → GaloisConnection l u",
  "name": "GaloisCoinsertion.gc",
  "kind": "def",
  "doc_string": "The Galois connection associated to a Galois coinsertion. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : α → Set β} {x : α} {y : β},\n  x ∈ s → y ∈ t x → y ∈ Set.unionᵢ fun x => Set.unionᵢ fun h => t x",
  "name": "Set.mem_bunionᵢ",
  "kind": "theorem",
  "doc_string": "A specialization of `mem_unionᵢ₂`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (ℕ → ℕ) → SlimCheck.Gen α → SlimCheck.Gen α",
  "name": "SlimCheck.Gen.resize",
  "kind": "def",
  "doc_string": "Apply a function to the size parameter. ",
  "args": ""},
 {"type": "{α : Sort u} → α → α → Prop",
  "name": "Ne",
  "kind": "def",
  "doc_string":
  "`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α}, a < 1 → b < 1 → a * b < 1",
  "name": "Left.mul_lt_one",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "LazyList",
  "kind": "inductive",
  "doc_string":
  "Lazy list.\nAll elements (except the first) are computed lazily.\n",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.Context →\n  Mathlib.Tactic.Abel.NormalExpr →\n    Mathlib.Tactic.Abel.NormalExpr → Lean.MetaM (Mathlib.Tactic.Abel.NormalExpr × Lean.Expr)",
  "name": "Mathlib.Tactic.Abel.evalAdd",
  "kind": "opaque",
  "doc_string":
  "Intepret the sum of two expressions in `abel`'s normal form.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Substs.substs",
  "kind": "def",
  "doc_string":
  "Applies the `subst` tactic to all given hypotheses from left to right.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : AddCommMonoid α] [inst_2 : Sub α] [inst_3 : OrderedSub α] {a b : α},\n  a ≤ b → a - b ≤ 0",
  "name": "tsub_nonpos_of_le",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `tsub_nonpos`.",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : AddCommMonoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 0 = 0 →\n                  (∀ (x y : M₁), f (x + y) = f x + f y) → (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) → AddCommMonoid M₁",
  "name": "Function.Injective.addCommMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `0` and `+` is an additive commutative monoid, if it\nadmits an injective map that preserves `0` and `+` to an additive commutative monoid.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term￢_»",
  "kind": "def",
  "doc_string": "Heyting negation ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : DecidableEq α] → List α → List α",
  "name": "List.dedup",
  "kind": "def",
  "doc_string":
  "`dedup l` removes duplicates from `l` (taking only the last occurrence).\nDefined as `pwFilter (≠)`.\n\n   dedup [1, 0, 2, 2, 1] = [0, 2, 1] ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → Set α → Prop",
  "name": "IsMaxChain",
  "kind": "def",
  "doc_string":
  "A chain `s` is a maximal chain if there does not exists a chain strictly including `s`. ",
  "args": ""},
 {"type": "(p : ℕ) → Decidable (Nat.Prime p)",
  "name": "Nat.decidablePrime1",
  "kind": "def",
  "doc_string":
  "This instance is slower than the instance `decidablePrime` defined below,\nbut has the advantage that it works in the kernel for small values.\n\nIf you need to prove that a particular number is prime, in any case\nyou should not use `by decide`, but rather `by norm_num`, which is\nmuch faster.\n",
  "args": ""},
 {"type":
  "∀ {v : Sat.Valuation} {l : Sat.Literal} {a : Prop} {c : Sat.Clause} {b : Prop},\n  Sat.Literal.reify v l a → Sat.Clause.reify v c b → Sat.Clause.reify v (Sat.Clause.cons l c) (a ∧ b)",
  "name": "Sat.Clause.reify_and",
  "kind": "theorem",
  "doc_string":
  "Negation turns OR into AND, so `¬⟦l ∨ c⟧_v ≡ ¬⟦l⟧_v ∧ ¬⟦c⟧_v`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} → [inst : MulOneClass α] → [inst_1 : AddZeroClass β] → (Additive α →+ β) ≃ (α →* Multiplicative β)",
  "name": "AddMonoidHom.toMultiplicative'",
  "kind": "def",
  "doc_string": "Reinterpret `Additive α →+ β` as `α →* Multiplicative β`. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {a b : α}, r a b → Quot.mk r a = Quot.mk r b",
  "name": "Quot.sound",
  "kind": "axiom",
  "doc_string":
  "The **quotient axiom**, or at least the nontrivial part of the quotient\naxiomatization. Quotient types are introduced by the `init_quot` command\nin `Init.Prelude` which introduces the axioms:\n\n```\nopaque Quot {α : Sort u} (r : α → α → Prop) : Sort u\n\nopaque Quot.mk {α : Sort u} (r : α → α → Prop) (a : α) : Quot r\n\nopaque Quot.lift {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β) :\n  (∀ a b : α, r a b → f a = f b) → Quot r → β\n\nopaque Quot.ind {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop} :\n  (∀ a : α, β (Quot.mk r a)) → ∀ q : Quot r, β q\n```\nAll of these axioms are true if we assume `Quot α r = α` and `Quot.mk` and\n`Quot.lift` are identity functions, so they do not add much. However this axiom\ncannot be explained in that way (it is false for that interpretation), so the\nreal power of quotient types come from this axiom.\n\nIt says that the quotient by `r` maps elements which are related by `r` to equal\nvalues in the quotient. Together with `Quot.lift` which says that functions\nwhich respect `r` can be lifted to functions on the quotient, we can deduce that\n`Quot α r` exactly consists of the equivalence classes with respect to `r`.\n\nIt is important to note that `r` need not be an equivalence relation in this axiom.\nWhen `r` is not an equivalence relation, we are actually taking a quotient with\nrespect to the equivalence relation generated by `r`.\n",
  "args": ""},
 {"type": "(α : Sort u_1) → (False → α) ≃ PUnit",
  "name": "Equiv.falseArrowEquivPUnit",
  "kind": "def",
  "doc_string": "The sort of maps from `False` is equivalent to `PUnit`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : DivisionMonoid β] (f : α →* β) (g h : α),\n  ↑f (g * h⁻¹) = ↑f g * (↑f h)⁻¹",
  "name": "MonoidHom.map_mul_inv",
  "kind": "theorem",
  "doc_string": "Group homomorphisms preserve division. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α},\n  0 < a → 0 ≤ b → 0 < a + b",
  "name": "Right.add_pos_of_pos_of_nonneg",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos_of_pos_of_nonneg`.",
  "args": ""},
 {"type":
  "{β : Type v} →\n  [inst : Zero β] →\n    [inst_1 : Add β] →\n      [inst_2 : Mul β] →\n        [inst_3 : SMul ℕ β] →\n          {α : Type u} →\n            [inst_4 : NonUnitalNonAssocSemiring α] →\n              (f : α → β) →\n                Function.Surjective f →\n                  f 0 = 0 →\n                    (∀ (x y : α), f (x + y) = f x + f y) →\n                      (∀ (x y : α), f (x * y) = f x * f y) →\n                        (∀ (x : α) (n : ℕ), f (n • x) = n • f x) → NonUnitalNonAssocSemiring β",
  "name": "Function.Surjective.nonUnitalNonAssocSemiring",
  "kind": "def",
  "doc_string":
  "Pushforward a `NonUnitalNonAssocSemiring` instance along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Type u → (Type v → Type w) → Type (max (max u (v + 1)) w)",
  "name": "MonadExceptOf",
  "kind": "inductive",
  "doc_string":
  "An implementation of Haskell's [`MonadError`] class. A `MonadError ε m` is a\nmonad `m` with two operations:\n\n* `throw : ε → m α` \"throws an error\" of type `ε` to the nearest enclosing\n  catch block\n* `tryCatch (body : m α) (handler : ε → m α) : m α` will catch any errors in\n  `body` and pass the resulting error to `handler`.\n  Errors in `handler` will not be caught.\n\nThe `try ... catch e => ...` syntax inside `do` blocks is sugar for the\n`tryCatch` operation.\n\n  [`MonadError`]: https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html#t:MonadError\n",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsAsymm",
  "kind": "inductive",
  "doc_string":
  "`IsAsymm X r` means that the binary relation `r` on `X` is asymmetric, that is,\n`r a b → ¬ r b a`. ",
  "args": ""},
 {"type": "{α : Sort u} → (c : Prop) → [h : Decidable c] → α → α → α",
  "name": "ite",
  "kind": "def",
  "doc_string":
  "`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false.\n\nBecause lean uses a strict (call-by-value) evaluation strategy, the signature of this\nfunction is problematic in that it would require `t` and `e` to be evaluated before\ncalling the `ite` function, which would cause both sides of the `if` to be evaluated.\nEven if the result is discarded, this would be a big performance problem,\nand is undesirable for users in any case. To resolve this, `ite` is marked as\n`@[macro_inline]`, which means that it is unfolded during code generation, and\nthe definition of the function uses `fun _ => t` and `fun _ => e` so this recovers\nthe expected \"lazy\" behavior of `if`: the `t` and `e` arguments delay evaluation\nuntil `c` is known.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : LinearOrder β] {f g : α → β} {s : Set α},\n  AntitoneOn f s → AntitoneOn g s → AntitoneOn (fun x => min (f x) (g x)) s",
  "name": "AntitoneOn.min",
  "kind": "theorem",
  "doc_string":
  "Pointwise minimum of two antitone functions is a antitone function. ",
  "args": ""},
 {"type": "ℤ → ℤ → ℤ → Prop",
  "name": "Int.ModEq",
  "kind": "def",
  "doc_string": "`a ≡ b [ZMOD n]` when `a % n = b % n`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (s : Set α) → ↑(Set.op s) ≃ ↑s",
  "name": "Set.opEquiv_self",
  "kind": "def",
  "doc_string":
  "The members of the opposite of a set are in bijection with the members of the set itself. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {s : Set α} {b : α},\n  (∀ (a : α), a ∈ s → a ≤ b) → (∀ (w : α), w < b → ∃ a, a ∈ s ∧ w < a) → supₛ s = b",
  "name": "supₛ_eq_of_forall_le_of_forall_lt_exists_gt",
  "kind": "theorem",
  "doc_string":
  "Introduction rule to prove that `b` is the supremum of `s`: it suffices to check that `b`\nis larger than all elements of `s`, and that this is not the case of any `w < b`.\nSee `csupₛ_eq_of_forall_le_of_forall_lt_exists_gt` for a version in conditionally complete\nlattices. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : CancelCommMonoidWithZero α] →\n    [inst_1 : DecidableEq α] →\n      (f : Associates α →* α) → Function.RightInverse (↑f) Associates.mk → NormalizationMonoid α",
  "name": "normalizationMonoidOfMonoidHomRightInverse",
  "kind": "def",
  "doc_string":
  "Define `NormalizationMonoid` on a structure from a `MonoidHom` inverse to `Associates.mk`. ",
  "args": ""},
 {"type": "{n : ℕ} → Fin2 n → Fin2 n → Fin2 n",
  "name": "Fin2.insertPerm",
  "kind": "def",
  "doc_string":
  "`insertPerm a` is a permutation of `Fin2 n` with the following properties:\n* `insertPerm a i = i+1` if `i < a`\n* `insertPerm a a = 0`\n* `insertPerm a i = i` if `i > a` ",
  "args": ""},
 {"type": "ℕ → Linarith.PCompSet → Linarith.LinarithM Unit",
  "name": "Linarith.update",
  "kind": "def",
  "doc_string":
  "Updates the current state with a new max variable and comparisons,\nand calls `validate` to check for a contradiction.\n",
  "args": ""},
 {"type": "{α : Type u₁} → {β : Type u₂} → (α → β → Prop) → Prop",
  "name": "Relator.LeftTotal",
  "kind": "def",
  "doc_string":
  "A relation is \"left total\" if every element appears on the left. ",
  "args": ""},
 {"type":
  "{α : Type u} → (p : α → Prop) → [inst : DecidablePred p] → LazyList α → LazyList α",
  "name": "LazyList.filter",
  "kind": "def",
  "doc_string":
  "The lazy list of all elements satisfying the predicate.\nIf the lazy list is infinite and none of the elements satisfy the predicate,\nthen this function will not terminate.\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "SubtractionCommMonoid",
  "kind": "inductive",
  "doc_string": "Commutative `SubtractionMonoid`. ",
  "args": ""},
 {"type": "{α : Type u} → (α → α) → α → Prop",
  "name": "Function.IsFixedPt",
  "kind": "def",
  "doc_string": "A point `x` is a fixed point of `f : α → α` if `f x = x`. ",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → {γ : Sort w} → {δ : Sort u_1} → α ≃ β → γ ≃ δ → α ≃ γ ≃ (β ≃ δ)",
  "name": "Equiv.equivCongr",
  "kind": "def",
  "doc_string":
  "If `α` is equivalent to `β` and `γ` is equivalent to `δ`, then the type of equivalences `α ≃ γ`\nis equivalent to the type of equivalences `β ≃ δ`. ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.Context → Lean.Expr → Lean.Expr → Lean.Expr → Lean.Expr",
  "name": "Mathlib.Tactic.Abel.Context.mkTerm",
  "kind": "def",
  "doc_string":
  "Evaluate a term with coefficient `n`, atom `x` and successor terms `a`. ",
  "args": ""},
 {"type": "{ε σ α ε' : Type u} → (ε → ε') → EStateM ε σ α → EStateM ε' σ α",
  "name": "EStateM.adaptExcept",
  "kind": "def",
  "doc_string":
  "Map the exception type of a `EStateM ε σ α` by a function `f : ε → ε'`. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {F G : C ⥤ D} →\n          (app : (X : C) → Prefunctor.obj F.toPrefunctor X ≅ Prefunctor.obj G.toPrefunctor X) →\n            (∀ {X Y : C} (f : X ⟶ Y),\n                Prefunctor.map F.toPrefunctor f ≫ (app Y).hom = (app X).hom ≫ Prefunctor.map G.toPrefunctor f) →\n              (F ≅ G)",
  "name": "CategoryTheory.NatIso.ofComponents",
  "kind": "def",
  "doc_string":
  "Construct a natural isomorphism between functors by giving object level isomorphisms,\nand checking naturality only in the forward direction.\n",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List (List α)",
  "name": "List.sublists",
  "kind": "def",
  "doc_string":
  "`sublists l` is the list of all (non-contiguous) sublists of `l`; cf. `sublists'`\nfor a different ordering.\n```\nsublists [1, 2, 3] = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n```\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_≃+_»",
  "kind": "def",
  "doc_string": "Notation for an `AddEquiv`. ",
  "args": ""},
 {"type": "Type u → Type u → Type u → Type u",
  "name": "DoResultPRBC",
  "kind": "inductive",
  "doc_string":
  "Auxiliary type used to compile `do` notation. It is used when compiling a do block\nnested inside a combinator like `tryCatch`. It encodes the possible ways the\nblock can exit:\n* `pure (a : α) s` means that the block exited normally with return value `a`.\n* `return (b : β) s` means that the block exited via a `return b` early-exit command.\n* `break s` means that `break` was called, meaning that we should exit\n  from the containing loop.\n* `continue s` means that `continue` was called, meaning that we should continue\n  to the next iteration of the containing loop.\n\nAll cases return a value `s : σ` which bundles all the mutable variables of the do-block.\n",
  "args": ""},
 {"type": "∀ (α : Sort u_1) [inst : Infinite α] [inst : Finite α], False",
  "name": "not_finite",
  "kind": "theorem",
  "doc_string": "`Infinite α` is not `Finite`",
  "args": ""},
 {"type":
  "Linarith.GlobalPreprocessor → List Lean.Expr → Lean.MetaM (List Lean.Expr)",
  "name": "Linarith.GlobalPreprocessor.transform",
  "kind": "def",
  "doc_string":
  "Replace the collection of all hypotheses with new hypotheses.\nThese expressions are proof terms. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«command#helpCats_»",
  "kind": "def",
  "doc_string":
  "The command `#help cats` shows all syntax categories that have been defined in the\ncurrent environment.\nEach syntax has a format like:\n```\ncategory command [Lean.Parser.initFn✝]\n```\nThe name of the syntax category in this case is `command`, and `Lean.Parser.initFn✝` is the\nname of the declaration that introduced it. (It is often an anonymous declaration like this,\nbut you can click to go to the definition.) It also shows the doc string if available.\n\nThe form `#help cats id` will show only syntax categories that begin with `id`.\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Prefunctor.«term_⋙q_»",
  "kind": "def",
  "doc_string": "Notation for composition of prefunctors. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {a : α} →\n        {b : β} →\n          {c : γ} →\n            {r : α → β → Sort u} →\n              {s : β → γ → Sort v} → {t : outParam (α → γ → Sort w)} → [inst : Trans r s t] → r a b → s b c → t a c",
  "name": "Trans.het",
  "kind": "def",
  "doc_string": "Composition using the `Trans` class in the general case. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : SemilatticeInf β] {f g : α → β},\n  Antitone f → Antitone g → Antitone (f ⊓ g)",
  "name": "Antitone.inf",
  "kind": "theorem",
  "doc_string":
  "Pointwise infimum of two monotone functions is a monotone function. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : DenselyOrdered α] {s : Set α} [hs : Set.OrdConnected s],\n  DenselyOrdered ↑s",
  "name": "Set.instDenselyOrderedElemLtToLTMemSetInstMembershipSet",
  "kind": "def",
  "doc_string":
  "In a dense order `α`, the subtype from an `OrdConnected` set is also densely ordered. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_3} {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : MulOneClass H] [inst_2 : MonoidHomClass F G H]\n  (f : F), Function.Injective ↑f ↔ ∀ (a : G), ↑f a = 1 → a = 1",
  "name": "injective_iff_map_eq_one",
  "kind": "theorem",
  "doc_string":
  "A homomorphism from a group to a monoid is injective iff its kernel is trivial.\nFor the iff statement on the triviality of the kernel, see `injective_iff_map_eq_one'`.  ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c)",
  "name": "AddCommute.add_right",
  "kind": "theorem",
  "doc_string":
  "If `a` commutes with both `b` and `c`, then it commutes with their sum.",
  "args": ""},
 {"type": "optParam (Array ℤ) #[] → Lean.Parsec (Array ℤ)",
  "name": "Mathlib.Tactic.Sat.Parser.parseInts",
  "kind": "opaque",
  "doc_string": "Parse a list of integers terminated by 0 ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : Semigroup S] {a b x y z : S}, SemiconjBy a y z → SemiconjBy b x y → SemiconjBy (a * b) x z",
  "name": "SemiconjBy.mul_left",
  "kind": "theorem",
  "doc_string":
  "If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a * b`\nsemiconjugates `x` to `z`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {f g : α → α}, Monotone f → f ≤ g → ∀ (n : ℕ), f^[n] ≤ g^[n]",
  "name": "Monotone.iterate_le_of_le",
  "kind": "theorem",
  "doc_string": "If `f ≤ g` and `f` is monotone, then `f^[n] ≤ g^[n]`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_∣_»",
  "kind": "def",
  "doc_string":
  "Divisibility. `a ∣ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Set.term_''_",
  "kind": "def",
  "doc_string":
  "`f '' s` denotes the image of `s : Set α` under the function `f : α → β`. ",
  "args": ""},
 {"type":
  "{R : Type u} → [inst : EuclideanDomain R] → [inst : DecidableEq R] → R → R → R",
  "name": "EuclideanDomain.gcd",
  "kind": "def",
  "doc_string":
  "`gcd a b` is a (non-unique) element such that `gcd a b ∣ a` `gcd a b ∣ b`, and for\nany element `c` such that `c ∣ a` and `c ∣ b`, then `c ∣ gcd a b` ",
  "args": ""},
 {"type":
  "{R : Type u_1} → {S : Type u_2} → [inst : Distrib R] → [inst : Distrib S] → Distrib (R × S)",
  "name": "Prod.instDistribProd",
  "kind": "def",
  "doc_string": "Product of two distributive types is distributive. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → α → Functor.Const α β",
  "name": "Functor.Const.mk",
  "kind": "def",
  "doc_string":
  "`Const.mk` is the canonical map `α → Const α β` (the identity), and\nit can be used as a pattern to extract this value. ",
  "args": ""},
 {"type":
  "{A : Type u_1} → [inst : Add A] → Subsemigroup (Multiplicative A) ≃o AddSubsemigroup A",
  "name": "Subsemigroup.toAddSubsemigroup'",
  "kind": "def",
  "doc_string":
  "Subsemigroups of a semigroup `Multiplicative A` are isomorphic to additive subsemigroups\nof `A`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : GCDMonoid α] (a : α), lcm a 0 = 0",
  "name": "GCDMonoid.lcm_zero_right",
  "kind": "def",
  "doc_string": "`0` is right-absorbing. ",
  "args": ""},
 {"type": "Prop",
  "name": "True",
  "kind": "inductive",
  "doc_string":
  "`True` is a proposition and has only an introduction rule, `True.intro : True`.\nIn other words, `True` is simply true, and has a canonical proof, `True.intro`\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
  "args": ""},
 {"type": "Substring → ℕ",
  "name": "Substring.bsize",
  "kind": "def",
  "doc_string": "The byte length of the substring. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → List α → α → α → List α → Array α → List α",
  "name": "List.replaceTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `replace`: `replace.go l b c xs acc = acc.toList ++ replace xs b c`,\nunless `b` is not found in `xs` in which case it returns `l`. ",
  "args": ""},
 {"type": "∀ {a b c : Prop}, a ∨ b ∨ c → b ∨ c ∨ a",
  "name": "Or.rotate",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `or_rotate`.",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Prop) → List α → Prop",
  "name": "List.All₂",
  "kind": "def",
  "doc_string":
  "`l.all₂ p` is equivalent to `∀ a ∈ l, p a`, but unfolds directly to a conjunction, i.e.\n`list.all₂ p [0, 1, 2] = p 0 ∧ p 1 ∧ p 2`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1],\n  MonotoneOn f s → MonotoneOn g s → MonotoneOn (fun x => f x * g x) s",
  "name": "MonotoneOn.mul'",
  "kind": "theorem",
  "doc_string": "The product of two monotone functions is monotone. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Mul",
  "kind": "inductive",
  "doc_string":
  "The homogeneous version of `HMul`: `a * b : α` where `a b : α`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    [sa : Setoid α] →\n      [sb : Setoid β] →\n        (f : α → β → Prop) →\n          (h : ∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) →\n            [hf : (a : α) → DecidablePred (f a)] → (q₁ : Quotient sa) → DecidablePred (Quotient.lift₂ f h q₁)",
  "name": "Quotient.lift₂.decidablePred",
  "kind": "def",
  "doc_string":
  "Note that this provides `DecidableRel (Quotient.lift₂ f h)` when `α = β`. ",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u_1} [self : CommGroupWithZero G₀] (a : G₀), CommGroupWithZero.zpow 0 a = 1",
  "name": "CommGroupWithZero.zpow_zero'",
  "kind": "def",
  "doc_string": "`a ^ 0 = 1` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedField α] (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.coprime (Int.natAbs a) b),\n  ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹",
  "name": "LinearOrderedField.ratCast_mk",
  "kind": "def",
  "doc_string":
  "However `ratCast` is defined, propositionally it must be equal to `a * b⁻¹`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  (p : α → Prop) →\n    (β : α → Type u_2) →\n      [inst : DecidablePred p] → ((i : α) → β i) ≃ ((i : { x // p x }) → β ↑i) × ((i : { x // ¬p x }) → β ↑i)",
  "name": "Equiv.piEquivPiSubtypeProd",
  "kind": "def",
  "doc_string":
  "The type `∀ (i : α), β i` can be split as a product by separating the indices in `α`\ndepending on whether they satisfy a predicate `p` or not. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      [inst : Preorder α] → [inst_1 : Preorder β] → [inst_2 : Preorder γ] → (β →o γ) →o (α →o β) →o α →o γ",
  "name": "OrderHom.compₘ",
  "kind": "def",
  "doc_string":
  "The composition of two bundled monotone functions, a fully bundled version. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Monoid α] → αˣ → α",
  "name": "Units.inv",
  "kind": "def",
  "doc_string": "The inverse value of `val` in the base `Monoid`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → α →o α",
  "name": "OrderHom.id",
  "kind": "def",
  "doc_string": "The identity function as bundled monotone function. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : AddCancelCommMonoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 0 = 0 →\n                  (∀ (x y : M₁), f (x + y) = f x + f y) →\n                    (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) → AddCancelCommMonoid M₁",
  "name": "Function.Injective.addCancelCommMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `0` and `+` is an additive cancel commutative monoid,\nif it admits an injective map that preserves `0` and `+` to an additive cancel commutative monoid.",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → (M →ₙ* N) → M → N",
  "name": "MulHom.toFun",
  "kind": "def",
  "doc_string": "The underlying function ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Add α] → AddHom α (WithZero α)",
  "name": "WithZero.coeAddHom",
  "kind": "def",
  "doc_string": "`WithZero.coe` as a bundled morphism",
  "args": ""},
 {"type":
  "∀ {R : Type x} [inst : Ring R] [inst_1 : NoZeroDivisors R] (u : Rˣ), u⁻¹ = u ↔ u = 1 ∨ u = -1",
  "name": "Units.inv_eq_self_iff",
  "kind": "theorem",
  "doc_string":
  "In the unit group of an integral domain, a unit is its own inverse iff the unit is one or\none's additive inverse. ",
  "args": ""},
 {"type": "{α : Sort u} → Setoid α → Sort u",
  "name": "Quotient",
  "kind": "def",
  "doc_string":
  "`Quotient α s` is the same as `Quot α r`, but it is specialized to a setoid `s`\n(that is, an equivalence relation) instead of an arbitrary relation.\nPrefer `Quotient` over `Quot` if your relation is actually an equivalence relation.\n",
  "args": ""},
 {"type":
  "∀ {I : Type u_2} {f : I → Type u_1} (i' : I) [inst : ∀ (i : I), Nonempty (f i)] [inst : Nontrivial (f i')],\n  Nontrivial ((i : I) → f i)",
  "name": "Pi.nontrivial_at",
  "kind": "theorem",
  "doc_string":
  "A pi type is nontrivial if it's nonempty everywhere and nontrivial somewhere. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} → [inst : AddZeroClass α] → [inst_1 : MulOneClass β] → (α →+ Additive β) ≃ (Multiplicative α →* β)",
  "name": "AddMonoidHom.toMultiplicative''",
  "kind": "def",
  "doc_string": "Reinterpret `α →+ Additive β` as `Multiplicative α →* β`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : SuccOrder α] [self : IsSuccArchimedean α] {a b : α},\n  a ≤ b → ∃ n, Nat.iterate Order.succ n a = b",
  "name": "IsSuccArchimedean.exists_succ_iterate_of_le",
  "kind": "def",
  "doc_string":
  "If `a ≤ b` then one can get to `a` from `b` by iterating `succ` ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u₃} →\n          [inst_2 : CategoryTheory.Category E] →\n            (F : C ⥤ D) →\n              (G : D ⥤ E) →\n                [inst_3 : CategoryTheory.Full (F ⋙ G)] → [inst_4 : CategoryTheory.Faithful G] → CategoryTheory.Full F",
  "name": "CategoryTheory.Full.ofCompFaithful",
  "kind": "def",
  "doc_string": "If `F ⋙ G` is full and `G` is faithful, then `F` is full. ",
  "args": ""},
 {"type": "Type",
  "name": "ParsedProjectionData",
  "kind": "inductive",
  "doc_string":
  "Temporary projection data parsed from `initialize_simps_projections` before the Expression\nmatching this projection has been found. Only used internally in `simpsGetRawProjections`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {ι : Sort u_1} [inst : ConditionallyCompleteLattice α] {b : α} [inst_1 : Nonempty ι] {f : ι → α},\n  (∀ (i : ι), f i ≤ b) → (∀ (w : α), w < b → ∃ i, w < f i) → (⨆ i, f i) = b",
  "name": "csupᵢ_eq_of_forall_le_of_forall_lt_exists_gt",
  "kind": "theorem",
  "doc_string":
  "Introduction rule to prove that `b` is the supremum of `f`: it suffices to check that `b`\nis larger than `f i` for all `i`, and that this is not the case of any `w<b`.\nSee `supᵢ_eq_of_forall_le_of_forall_lt_exists_gt` for a version in complete lattices. ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Add M] → Type u_1",
  "name": "AddSubsemigroup",
  "kind": "inductive",
  "doc_string":
  "An additive subsemigroup of an additive magma `M` is a subset closed under addition. ",
  "args": ""},
 {"type":
  "{F : Sort u_1} → {α : Sort u_2} → {β : α → Sort u_3} → [self : FunLike F α β] → F → (a : α) → β a",
  "name": "FunLike.coe",
  "kind": "def",
  "doc_string": "The coercion from `F` to a function. ",
  "args": ""},
 {"type": "Mathlib.Prelude.Rename.NameEntry → String",
  "name": "Mathlib.Prelude.Rename.NameEntry.dubious",
  "kind": "def",
  "doc_string":
  "A dubious translation is one where there is a type mismatch\nfrom the translated lean 3 definition to a pre-existing lean 4 definition.\nType errors are likely in downstream theorems.\nThe string stored here is printed in the event that `n3` is encountered by synport. ",
  "args": ""},
 {"type":
  "{g : Type} → (α : Type u) → [inst : Random α] → [inst : RandomGen g] → RandG g α",
  "name": "Random.rand",
  "kind": "def",
  "doc_string": "Generate a random value of type `α`. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Mul M] → CompleteLattice (Subsemigroup M)",
  "name": "Subsemigroup.instCompleteLatticeSubsemigroup",
  "kind": "def",
  "doc_string": "subsemigroups of a monoid form a complete lattice. ",
  "args": ""},
 {"type": "ℕ → WellFoundedRelation ℕ",
  "name": "Nat.upRel",
  "kind": "def",
  "doc_string":
  "A well-ordered relation for \"upwards\" induction on the natural numbers up to some bound `ub`. ",
  "args": ""},
 {"type": "∀ {a : Prop} (b : Prop), a → a ∨ b",
  "name": "Or.intro_left",
  "kind": "theorem",
  "doc_string": "Alias for `Or.inl`. ",
  "args": ""},
 {"type": "Linarith.LinarithConfig → Bool",
  "name": "Linarith.LinarithConfig.split_hypotheses",
  "kind": "def",
  "doc_string": "Split conjunctions in hypotheses. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, 0 < -a ↔ a < 0",
  "name": "Left.neg_pos_iff",
  "kind": "theorem",
  "doc_string": "Uses `left` co(ntra)variant.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α}\n  (self : GaloisInsertion l u) (a : α) (h : u (l a) ≤ a), GaloisInsertion.choice self a h = l a",
  "name": "GaloisInsertion.choice_eq",
  "kind": "def",
  "doc_string": "Property of the choice function. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Monoid α] →\n      [inst_1 : MulOneClass β] →\n        [inst_2 : MulAction α β] → [inst_3 : IsScalarTower α β β] → [inst_4 : SMulCommClass α β β] → α × β →* β",
  "name": "smulMonoidHom",
  "kind": "def",
  "doc_string": "Scalar multiplication as a monoid homomorphism. ",
  "args": ""},
 {"type":
  "{G₀ : Type u_1} →\n  {G₀' : Type u_2} →\n    [inst : GroupWithZero G₀] →\n      [inst_1 : Zero G₀'] →\n        [inst_2 : Mul G₀'] →\n          [inst_3 : One G₀'] →\n            [inst_4 : Inv G₀'] →\n              [inst_5 : Div G₀'] →\n                [inst_6 : Pow G₀' ℕ] →\n                  [inst_7 : Pow G₀' ℤ] →\n                    0 ≠ 1 →\n                      (f : G₀ → G₀') →\n                        Function.Surjective f →\n                          f 0 = 0 →\n                            f 1 = 1 →\n                              (∀ (x y : G₀), f (x * y) = f x * f y) →\n                                (∀ (x : G₀), f x⁻¹ = (f x)⁻¹) →\n                                  (∀ (x y : G₀), f (x / y) = f x / f y) →\n                                    (∀ (x : G₀) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                      (∀ (x : G₀) (n : ℤ), f (x ^ n) = f x ^ n) → GroupWithZero G₀'",
  "name": "Function.Surjective.groupWithZero",
  "kind": "def",
  "doc_string":
  "Pushforward a `GroupWithZero` along an surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{n : ℕ} → Fin2 n → ℕ",
  "name": "Fin2.toNat",
  "kind": "def",
  "doc_string": "Converts a `Fin2` into a natural. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : MulOneClass α]\n  [inst_3 : MulOneClass β] (self : α →*o β), Monotone ↑↑self.toMonoidHom",
  "name": "OrderMonoidHom.monotone'",
  "kind": "def",
  "doc_string": "An `OrderMonoidHom` is a monotone function. ",
  "args": ""},
 {"type":
  "{α : Sort u} →\n  {s : Setoid α} →\n    {motive : Quotient s → Sort v} →\n      (q : Quotient s) → (f : (a : α) → motive (Quotient.mk s a)) → (∀ (a b : α), a ≈ b → HEq (f a) (f b)) → motive q",
  "name": "Quotient.hrecOn",
  "kind": "def",
  "doc_string":
  "The analogue of `Quot.hrecOn` for `Quotient`. See `Quot.hrecOn`. ",
  "args": ""},
 {"type": "∀ {a : Prop} (h₁ h₂ : a), h₁ = h₂",
  "name": "proof_irrel",
  "kind": "theorem",
  "doc_string": "**Alias** of `proofIrrel`.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CanonicallyOrderedAddMonoid",
  "kind": "inductive",
  "doc_string":
  "A canonically ordered additive monoid is an ordered commutative additive monoid\nin which the ordering coincides with the subtractibility relation,\nwhich is to say, `a ≤ b` iff there exists `c` with `b = a + c`.\nThis is satisfied by the natural numbers, for example, but not\nthe integers or other nontrivial `OrderedAddCommGroup`s. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedCommGroup α] (a b : α), max a b = if a ≤ b then b else a",
  "name": "LinearOrderedCommGroup.max_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `maxOfLe`. ",
  "args": ""},
 {"type": "{α : Type u} → {n : ℕ} → (Fin n → α) → Vector α n",
  "name": "Vector.ofFn",
  "kind": "def",
  "doc_string": "Vector of length `n` from a function on `Fin n`. ",
  "args": ""},
 {"type":
  "∀ {ι : Sort u_2} {M : Type u_1} [inst : Mul M] (S : ι → Subsemigroup M) {C : (x : M) → (x ∈ ⨆ i, S i) → Prop},\n  (∀ (i : ι) (x : M) (hxS : x ∈ S i), C x (_ : x ∈ ⨆ i, S i)) →\n    (∀ (x y : M) (hx : x ∈ ⨆ i, S i) (hy : y ∈ ⨆ i, S i), C x hx → C y hy → C (x * y) (_ : x * y ∈ ⨆ i, S i)) →\n      ∀ {x₁ : M} (hx₁ : x₁ ∈ ⨆ i, S i), C x₁ hx₁",
  "name": "Subsemigroup.supᵢ_induction'",
  "kind": "theorem",
  "doc_string": "A dependent version of `Subsemigroup.supᵢ_induction`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : HeytingAlgebra α] {a b : α}, a ≤ bᶜ → b ≤ aᶜ",
  "name": "le_compl_of_le_compl",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `le_compl_comm`.",
  "args": ""},
 {"type": "Type",
  "name": "Substring",
  "kind": "inductive",
  "doc_string":
  "A `Substring` is a view into some subslice of a `String`.\nThe actual string slicing is deferred because this would require copying the\nstring; here we only store a reference to the original string for\ngarbage collection purposes.\n",
  "args": ""},
 {"type":
  "∀ {b : ℕ}, 1 < b → ∀ {x y : ℕ}, y ≠ 0 → (b ^ x ≤ y ↔ x ≤ Nat.log b y)",
  "name": "Nat.pow_le_iff_le_log",
  "kind": "theorem",
  "doc_string":
  "`pow b` and `log b` (almost) form a Galois connection. See also `Nat.pow_le_of_le_log` and\n`Nat.le_log_of_pow_le` for individual implications under weaker assumptions. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ},\n  Function.Injective2 f → ∀ (b : β), Function.Injective fun a => f a b",
  "name": "Function.Injective2.left",
  "kind": "theorem",
  "doc_string":
  "A binary injective function is injective when only the left argument varies. ",
  "args": ""},
 {"type":
  "∀ {F : Type u → Type v} [inst : Applicative F] {G : Type u → Type w} [inst_1 : Applicative G]\n  (self : ApplicativeTransformation F G) {α : Type u} (x : α), ApplicativeTransformation.app self α (pure x) = pure x",
  "name": "ApplicativeTransformation.preserves_pure'",
  "kind": "def",
  "doc_string": "An `ApplicativeTransformation` preserves `pure`. ",
  "args": ""},
 {"type": "ℚ → ℚ",
  "name": "Rat.neg",
  "kind": "def",
  "doc_string": "Negation of rational numbers. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : LinearOrder α] → (succ : α → α) → (∀ {a b : α}, succ a ≤ b ↔ a < b) → SuccOrder α",
  "name": "SuccOrder.ofSuccLeIff",
  "kind": "def",
  "doc_string":
  "A constructor for `SuccOrder α` usable when `α` is a linear order with no maximal element. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "List.«term_<+:_»",
  "kind": "def",
  "doc_string":
  "`isPrefix l₁ l₂`, or `l₁ <+: l₂`, means that `l₁` is a prefix of `l₂`,\nthat is, `l₂` has the form `l₁ ++ t` for some `t`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α}, ¬BddAbove s ↔ ∀ (x : α), ∃ y, y ∈ s ∧ ¬y ≤ x",
  "name": "not_bddAbove_iff'",
  "kind": "theorem",
  "doc_string":
  "A set `s` is not bounded above if and only if for each `x` there exists `y ∈ s` such that `x`\nis not greater than or equal to `y`. This version only assumes `Preorder` structure and uses\n`¬(y ≤ x)`. A version for linear orders is called `not_bddAbove_iff`. ",
  "args": ""},
 {"type": "{ε : Type u_1} → {α : Type u_2} → Except ε α → String",
  "name": "Mathlib.Tactic.SolveByElim.exceptEmoji",
  "kind": "def",
  "doc_string": "Visualize an `Except` using a checkmark or a cross. ",
  "args": ""},
 {"type": "{α σ : Type u} → α → σ → DoResultSBC α σ",
  "name": "DoResultSBC.pureReturn",
  "kind": "def",
  "doc_string":
  "This encodes either `pure (a : α)` or `return (a : α)`:\n* `pure (a : α) s` means that the block exited normally with return value `a`\n* `return (b : β) s` means that the block exited via a `return b` early-exit command\n\nThe one that is actually encoded depends on the context of use. ",
  "args": ""},
 {"type":
  "∀ {G : Type u} [inst : Mul G] [self : IsLeftCancelMul G] (a b c : G), a * b = a * c → b = c",
  "name": "IsLeftCancelMul.mul_left_cancel",
  "kind": "def",
  "doc_string": "Multiplication is left cancellative. ",
  "args": ""},
 {"type": "Type",
  "name": "Simps.Config",
  "kind": "inductive",
  "doc_string": "Configuration options for `@[simps]` ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddCommGroup M] (h : Module ℤ M) (n : ℤ) (x : M), SMul.smul n x = n • x",
  "name": "int_smul_eq_zsmul",
  "kind": "theorem",
  "doc_string":
  "Convert back any exotic `ℤ`-smul to the canonical instance. This should not be needed since in\nmathlib all `AddCommGroup`s should normally have exactly one `ℤ`-module structure by design. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "SemigroupWithZero",
  "kind": "inductive",
  "doc_string":
  "A type `S₀` is a \"semigroup with zero” if it is a semigroup with zero element, and `0` is left\nand right absorbing. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "name": "Tactic.NormCast.derive",
  "kind": "def",
  "doc_string": "The core simplification routine of `normCast`.\n",
  "args": ""},
 {"type": "{α : Type} → SlimCheck.Gen α → SlimCheck.Gen (Array α)",
  "name": "SlimCheck.Gen.arrayOf",
  "kind": "def",
  "doc_string":
  "Create an `Array` of examples using `x`. The size is controlled\nby the size parameter of `Gen`. ",
  "args": ""},
 {"type":
  "∀ (G : Type u) [inst : AddCommSemigroup G] [inst_1 : IsLeftCancelAdd G], IsRightCancelAdd G",
  "name": "AddCommSemigroup.IsLeftCancelAdd.toIsRightCancelAdd",
  "kind": "theorem",
  "doc_string":
  "Any\n`AddCommSemigroup G` that satisfies `IsLeftCancelAdd G` also satisfies\n`IsRightCancelAdd G`.",
  "args": ""},
 {"type": "Num → Num → Num",
  "name": "Num.mul",
  "kind": "def",
  "doc_string": "Multiplication of two `Num`s. ",
  "args": ""},
 {"type":
  "{α : Sort u} →\n  {β : Sort v} →\n    {ra : Setoid α} →\n      {rb : Setoid β} →\n        (e : α ≃ β) → (∀ (a₁ a₂ : α), Setoid.r a₁ a₂ ↔ Setoid.r (↑e a₁) (↑e a₂)) → Quotient ra ≃ Quotient rb",
  "name": "Quotient.congr",
  "kind": "def",
  "doc_string":
  "An equivalence `e : α ≃ β` generates an equivalence between quotient spaces,\nif `ra a₁ a₂ ↔ rb (e a₁) (e a₂). ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → (f : α → β) → (∀ (a b : α), f a = f b) → Trunc α → β",
  "name": "Trunc.lift",
  "kind": "def",
  "doc_string":
  "Any constant function lifts to a function out of the truncation ",
  "args": ""},
 {"type":
  "∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → Preorder (π i)] {a b c : (i : ι) → π i},\n  a ≤ b → StrongLT b c → StrongLT a c",
  "name": "LE.le.trans_strongLT",
  "kind": "theorem",
  "doc_string": "**Alias** of `strongLT_of_le_of_strongLT`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : CanonicallyLinearOrderedSemifield α] → DecidableRel fun x x_1 => x < x_1",
  "name": "CanonicallyLinearOrderedSemifield.decidable_lt",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "Array Lean.Term → Lean.Elab.TermElabM (Array Lean.Meta.AbstractMVarsResult)",
  "name": "Mathlib.Tactic.elabPatterns",
  "kind": "def",
  "doc_string":
  "Elaborate a list of terms with holes into a list of patterns. ",
  "args": ""},
 {"type": "Sort u_1 → Sort (max 1 u_1)",
  "name": "Equiv.Perm",
  "kind": "def",
  "doc_string": "`Perm α` is the type of bijections from `α` to itself. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type u_1} →\n    [inst : StrictOrderedCommSemiring α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Pow β ℕ] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : NatCast β] →\n                    (f : β → α) →\n                      Function.Injective f →\n                        f 0 = 0 →\n                          f 1 = 1 →\n                            (∀ (x y : β), f (x + y) = f x + f y) →\n                              (∀ (x y : β), f (x * y) = f x * f y) →\n                                (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                  (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                    (∀ (n : ℕ), f ↑n = ↑n) → StrictOrderedCommSemiring β",
  "name": "Function.Injective.strictOrderedCommSemiring",
  "kind": "def",
  "doc_string":
  "Pullback a `strictOrderedCommSemiring` under an injective map. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {f : α → α},\n  Function.Involutive f → ∀ (P : Prop) [inst : Decidable P] (x : α), f (if P then x else f x) = if ¬P then x else f x",
  "name": "Function.Involutive.ite_not",
  "kind": "theorem",
  "doc_string":
  "Involuting an `ite` of an involuted value `x : α` negates the `Prop` condition in the `ite`. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₂] →\n      [inst_1 : Zero M₂] →\n        [inst_2 : SMul ℕ M₂] →\n          [inst_3 : Neg M₂] →\n            [inst_4 : Sub M₂] →\n              [inst_5 : SMul ℤ M₂] →\n                [inst_6 : SubNegMonoid M₁] →\n                  (f : M₁ → M₂) →\n                    Function.Surjective f →\n                      f 0 = 0 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁), f (-x) = -f x) →\n                            (∀ (x y : M₁), f (x - y) = f x - f y) →\n                              (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) → SubNegMonoid M₂",
  "name": "Function.Surjective.subNegMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `0`, `+`, unary `-`, and binary `-` is a\n`SubNegMonoid` if it admits a surjective map that preserves `0`, `+`, unary `-`, and binary `-` to\na `SubNegMonoid`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → β → Prop} {a : α} {b : β}, r a b → Option.rel r (some a) (some b)",
  "name": "Option.rel.some",
  "kind": "def",
  "doc_string": "If `a ~ b`, then `some a ~ some b` ",
  "args": ""},
 {"type": "{α : Sort u_1} → Erased (Erased α) → Erased α",
  "name": "Erased.join",
  "kind": "def",
  "doc_string": "Collapses two levels of erasure.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Add M] →\n      [inst_1 : Add N] →\n        (f : AddHom M N) → (M' : AddSubsemigroup M) → AddHom { x // x ∈ M' } { x // x ∈ AddSubsemigroup.map f M' }",
  "name": "AddHom.subsemigroupMap",
  "kind": "def",
  "doc_string":
  "the `AddHom` from an additive subsemigroup to its image. See\n`AddEquiv.addSubsemigroupMap` for a variant for `AddEquiv`s.",
  "args": ""},
 {"type":
  "∀ {R₁ : Type u_1} {R₂ : Type u_2} {R₃ : Type u_3} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Semiring R₃]\n  {σ₁₂ : R₁ →+* R₂} {σ₂₃ : R₂ →+* R₃} {σ₁₃ : R₁ →+* R₃} [self : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃],\n  RingHom.comp σ₂₃ σ₁₂ = σ₁₃",
  "name": "RingHomCompTriple.comp_eq",
  "kind": "def",
  "doc_string": "The morphisms form a commutative triangle ",
  "args": ""},
 {"type": "Linarith.Comp → Linarith.Comp → Linarith.Comp",
  "name": "Linarith.Comp.add",
  "kind": "def",
  "doc_string":
  "`Comp.add c1 c2` adds the expressions represented by `c1` and `c2`.\nThe coefficient of variable `a` in `c1.add c2`\nis the sum of the coefficients of `a` in `c1` and `c2`.\n ",
  "args": ""},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (β → α) → (α → β) → Prop",
  "name": "Function.LeftInverse",
  "kind": "def",
  "doc_string":
  "`LeftInverse g f` means that g is a left inverse to f. That is, `g ∘ f = id`. ",
  "args": ""},
 {"type":
  "{α : Type u} → (σ : Type u) → {m : Type u → Type v} → [inst : MonadStateOf σ m] → (σ → α × σ) → m α",
  "name": "modifyGetThe",
  "kind": "def",
  "doc_string":
  "Like `modifyGet`, but with `σ` explicit. This is useful if a monad supports\n`MonadStateOf` for multiple different types `σ`.\n",
  "args": ""},
 {"type": "{M : Type u} → [self : AddRightCancelMonoid M] → ℕ → M → M",
  "name": "AddRightCancelMonoid.nsmul",
  "kind": "def",
  "doc_string": "Multiplication by a natural number. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : OrderedCancelAddCommMonoid α] (a b c : α), a + b ≤ a + c → b ≤ c",
  "name": "OrderedCancelAddCommMonoid.le_of_add_le_add_left",
  "kind": "def",
  "doc_string":
  "Additive cancellation is compatible with the order in an ordered cancellative additive\ncommutative monoid. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a b : α),\n  ↑f (a + b) = ↑f a + ↑f b",
  "name": "RingHom.map_add",
  "kind": "theorem",
  "doc_string": "Ring homomorphisms preserve addition. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : NonAssocSemiring α] → α →+* α",
  "name": "RingHom.id",
  "kind": "def",
  "doc_string": "The identity ring homomorphism from a semiring to itself. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : CompleteLattice α] → ConditionallyCompleteLattice α",
  "name": "CompleteLattice.toConditionallyCompleteLattice",
  "kind": "def",
  "doc_string":
  "A complete lattice is a conditionally complete lattice, as there are no restrictions\non the properties of infₛ and supₛ in a complete lattice.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → {x : AddZeroClass M} → {x_1 : AddZeroClass N} → (f : M →+ N) → (f' : M → N) → f' = ↑f → M →+ N",
  "name": "AddMonoidHom.copy",
  "kind": "def",
  "doc_string":
  "Copy of an `AddMonoidHom` with a new `toFun` equal to the old one. Useful to fix\ndefinitional equalities.",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Polyrith.SageSuccess → Option (Array Mathlib.Tactic.Polyrith.Poly)",
  "name": "Mathlib.Tactic.Polyrith.SageSuccess.data",
  "kind": "def",
  "doc_string":
  "The main result of the function call is an array of polynomials\nparallel to the input list of hypotheses. ",
  "args": ""},
 {"type": "{α : Type u_1} → (a : Part α) → [inst : Decidable a.Dom] → α → α",
  "name": "Part.getOrElse",
  "kind": "def",
  "doc_string":
  "Retrieves the value of `a : part α` if it exists, and return the provided default value\notherwise. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → α ≃ β → Set α ≃ Set β",
  "name": "Equiv.Set.congr",
  "kind": "def",
  "doc_string":
  "If `α` is equivalent to `β`, then `Set α` is equivalent to `Set β`. ",
  "args": ""},
 {"type": "∀ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive G G",
  "name": "AddAction.Regular.isPretransitive",
  "kind": "def",
  "doc_string": "The regular action of a group on itself is transitive.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, b < c → a = b → a < c",
  "name": "LT.lt.trans_eq'",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_lt_of_eq'`.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : CommMonoid α] → α × α →* α",
  "name": "mulMonoidHom",
  "kind": "def",
  "doc_string": "Multiplication as a monoid homomorphism. ",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α α_1 : Type u_1} {p : α_1 → Prop} {f : α → α_1} [inst : Functor m]\n  [inst_1 : LawfulFunctor m] {x : m α}, SatisfiesM (fun a => p (f a)) x → SatisfiesM p (f <$> x)",
  "name": "SatisfiesM.map_pre",
  "kind": "theorem",
  "doc_string":
  "`SatisfiesM` distributes over `<$>`, weakest precondition version.\n(Use this for reasoning backward from the goal.)\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (e : α ≃ β) → (s : Set α) → ↑s ≃ ↑(↑e '' s)",
  "name": "Equiv.image",
  "kind": "def",
  "doc_string": "A set is equivalent to its image under an equivalence.\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Inv",
  "kind": "inductive",
  "doc_string": "Class of types that have an inversion operation. ",
  "args": ""},
 {"type": "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableEq α",
  "name": "LinearOrderedSemiring.decidable_eq",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "{α : Type u} → (α → α) → α → LazyList α",
  "name": "LazyList.iterates",
  "kind": "def",
  "doc_string":
  "The infinite lazy list `[x, f x, f (f x), ...]` of iterates of a function.\nThis definition is meta because it creates an infinite list.\n",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CompleteSemilatticeSup",
  "kind": "inductive",
  "doc_string":
  "Note that we rarely use `CompleteSemilatticeSup`\n(in fact, any such object is always a `CompleteLattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : SemilatticeInf α] {S : Set α},\n  (∀ ⦃i j : α⦄, i ∈ S → j ∈ S → i ⊓ j ∈ S) → DirectedOn (fun x x_1 => x ≥ x_1) S",
  "name": "directedOn_of_inf_mem",
  "kind": "theorem",
  "doc_string": "A set stable by infimum is `≥`-directed. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : LE α] → [inst_1 : LE β] → α ⊕ β ≃o β ⊕ α",
  "name": "OrderIso.sumComm",
  "kind": "def",
  "doc_string": "`Equiv.sumComm` promoted to an order isomorphism. ",
  "args": ""},
 {"type":
  "∀ {M : Type u} [self : RightCancelMonoid M] (n : ℕ) (x : M),\n  RightCancelMonoid.npow (n + 1) x = x * RightCancelMonoid.npow n x",
  "name": "RightCancelMonoid.npow_succ",
  "kind": "def",
  "doc_string": "Raising to the power `(n + 1 : ℕ)` behaves as expected. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CommMonoid α] {a b : α} {u : αˣ}, a ∣ ↑u * b ↔ a ∣ b",
  "name": "Units.dvd_mul_left",
  "kind": "theorem",
  "doc_string":
  "In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left\nassociates of `b`. ",
  "args": ""},
 {"type": "Mathlib.Tactic.MkIff.Shape → List Bool",
  "name": "Mathlib.Tactic.MkIff.Shape.variablesKept",
  "kind": "def",
  "doc_string":
  "For each forall-bound variable in the type of the constructor, minus\nthe \"params\" that apply to the entire inductive type, this list contains `true`\nif that variable has been kept after `compactRelation`.\n\nFor example, `List.Chain.nil` has type\n```lean\n  ∀ {α : Type u_1} {R : α → α → Prop} {a : α}, List.Chain R a []`\n```\nand the first two variables `α` and `R` are \"params\", while the `a : α` gets\neliminated in a `compactRelation`, so `variablesKept = [false].\n\n`List.Chain.cons` has type\n```lean\n  ∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α},\n     R a b → List.Chain R b l → List.Chain R a (b :: l)\n```\nand the `a : α` gets eliminated, so `compactRelation = [false,true,true,true,true]`.\n ",
  "args": ""},
 {"type": "∀ {a b c : ℤ}, a ∣ b * c → Int.gcd a c = 1 → a ∣ b",
  "name": "Int.dvd_of_dvd_mul_left_of_gcd_one",
  "kind": "theorem",
  "doc_string":
  "Euclid's lemma: if `a ∣ b * c` and `gcd a c = 1` then `a ∣ b`.\nCompare with `IsCoprime.dvd_of_dvd_mul_left` and\n`UniqueFactorizationMonoid.dvd_of_dvd_mul_left_of_no_prime_factors` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] →\n        (s : Submonoid M) → (t : Submonoid N) → { x // x ∈ Submonoid.prod s t } ≃* { x // x ∈ s } × { x // x ∈ t }",
  "name": "Submonoid.prodEquiv",
  "kind": "def",
  "doc_string":
  "The product of submonoids is isomorphic to their product as monoids. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {T : Type u_3} →\n      [inst : NonAssocSemiring R] →\n        [inst_1 : NonAssocSemiring S] → [inst_2 : NonAssocSemiring T] → (R →+* S) → (R →+* T) → R →+* S × T",
  "name": "RingHom.prod",
  "kind": "def",
  "doc_string":
  "Combine two ring homomorphisms `f : R →+* S`, `g : R →+* T` into `f.prod g : R →+* S × T`\ngiven by `(f.prod g) x = (f x, g x)` ",
  "args": ""},
 {"type":
  "{N : Type u_1} → [inst : AddMonoid N] → {a : N} → IsAddUnit a → AddUnits N",
  "name": "IsAddUnit.addUnit",
  "kind": "def",
  "doc_string":
  "\"The element of the additive group of additive units, corresponding to an element of\nan additive monoid which is an additive unit. When `α` is a `SubtractionMonoid`, use\n`IsAddUnit.addUnit'` instead. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α}, IsLeast s a → BddBelow s",
  "name": "IsLeast.bddBelow",
  "kind": "theorem",
  "doc_string": "If `s` has a least element, then it is bounded below. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  MonotoneOn f s → AntitoneOn (↑OrderDual.toDual ∘ f) s",
  "name": "MonotoneOn.dual_right",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `antitoneOn_toDual_comp_iff`.",
  "args": ""},
 {"type":
  "(α : Type u) → (β : Type v) → [inst : Group α] → [inst_1 : MulAction α β] → α →* Equiv.Perm β",
  "name": "MulAction.toPermHom",
  "kind": "def",
  "doc_string":
  "Given an action of a group `α` on a set `β`, each `g : α` defines a permutation of `β`. ",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} {p : α → Prop} [inst : Applicative m] [inst_1 : LawfulApplicative m]\n  {x : m α}, (∀ (a : α), p a) → SatisfiesM p x",
  "name": "SatisfiesM.of_true",
  "kind": "theorem",
  "doc_string": "If `p` is always true, then every `x` satisfies it. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} (r : α → α → Prop) [inst : IsTrichotomous α r] [inst : IsIrrefl α r] {a b : α},\n  (∀ (x : α), r x a ↔ r x b) → a = b",
  "name": "extensional_of_trichotomous_of_irrefl",
  "kind": "theorem",
  "doc_string":
  "In a trichotomous irreflexive order, every element is determined by the set of predecessors. ",
  "args": ""},
 {"type": "{α : Sort u} → [s : Setoid α] → α → Quotient s",
  "name": "Quotient.mk'",
  "kind": "def",
  "doc_string":
  "The canonical quotient map into a `Quotient`.\n(This synthesizes the setoid by typeclass inference.)\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → (r s : Setoid α) → (h : r ≤ s) → Quotient (Setoid.ker (Quot.mapRight h)) ≃ Quotient s",
  "name": "Setoid.quotientQuotientEquivQuotient",
  "kind": "def",
  "doc_string": "The third isomorphism theorem for sets. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → List α → α → α → List α",
  "name": "List.replaceTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `replace`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {sα : Q(CommSemiring «$α»)} → {e : Q(«$α»)} → Mathlib.Tactic.Ring.ExSum sα e → Mathlib.Tactic.Ring.ExBase sα e",
  "name": "Mathlib.Tactic.Ring.ExBase.sum",
  "kind": "def",
  "doc_string": "A sum of monomials.  ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.AbelNF.Config →\n  Lean.Meta.Simp.Context →\n    (Lean.Meta.Simp.Result → Lean.Meta.SimpM Lean.Meta.Simp.Result) → Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "name": "Mathlib.Tactic.Abel.abelNFCore.evalAtom",
  "kind": "opaque",
  "doc_string":
  "The `evalAtom` implementation passed to `eval` calls `go` if `cfg.recursive` is true,\nand does nothing otherwise. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u₃} →\n          [inst_2 : CategoryTheory.Category E] → {F G : C ⥤ D} → {H I : D ⥤ E} → (F ⟶ G) → (H ⟶ I) → (F ⋙ H ⟶ G ⋙ I)",
  "name": "CategoryTheory.NatTrans.hcomp",
  "kind": "def",
  "doc_string":
  "`hcomp α β` is the horizontal composition of natural transformations. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {s : β → β → Prop} → (r : α → α → Prop) → {b : β} → ¬s b b → r ↪r Prod.Lex r s",
  "name": "RelEmbedding.prodLexMkRight",
  "kind": "def",
  "doc_string": "`λ a, Prod.mk a b` as a relation embedding. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedCancelAddCommMonoid α] (a b : α), a ≤ b ∨ b ≤ a",
  "name": "LinearOrderedCancelAddCommMonoid.le_total",
  "kind": "def",
  "doc_string": "A linear order is total. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "CategoryTheory.«term_≫=_»",
  "kind": "def",
  "doc_string":
  "Notation for whiskering an equation by a morphism (on the left).\nIf `g h : Y ⟶ Z` and `w : g = h` and `h : X ⟶ Y`, then `f ≫= w : f ≫ g = f ≫ h`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a b c : α), (a + b) * c = a * c + b * c",
  "name": "NonUnitalNonAssocRing.right_distrib",
  "kind": "def",
  "doc_string": "Multiplication is right distributive over addition ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«termα>0»",
  "kind": "def",
  "doc_string":
  "Local notation for the positive elements of a type `α`. TODO: actually make local. ",
  "args": ""},
 {"type": "{α : Type u} → α → WithOne α",
  "name": "WithOne.coe",
  "kind": "def",
  "doc_string": "The canonical map from `α` into `WithOne α` ",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HOrElse",
  "kind": "inductive",
  "doc_string":
  "The typeclass behind the notation `a <|> b : γ` where `a : α`, `b : β`.\nBecause `b` is \"lazy\" in this notation, it is passed as `Unit → β` to the\nimplementation so it can decide when to evaluate it.\n",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : CoheytingAlgebra α] (a : α), a ≤ ⊤",
  "name": "CoheytingAlgebra.le_top",
  "kind": "def",
  "doc_string": "`⊤` is a greatest element ",
  "args": ""},
 {"type": "Substring → String.Pos",
  "name": "Substring.stopPos",
  "kind": "def",
  "doc_string": "The byte position of the end of the string slice. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Preorder α] → [inst_1 : OrderTop α] → ↑(Set.Iic ⊤) ≃o α",
  "name": "OrderIso.IicTop",
  "kind": "def",
  "doc_string":
  "Order isomorphism between `Iic (⊤ : α)` and `α` when `α` has a top element ",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (a : G₀), a ≠ 0 → a * a⁻¹ = 1",
  "name": "GroupWithZero.mul_inv_cancel",
  "kind": "def",
  "doc_string": "Every nonzero element of a group with zero is invertible. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : PartialOrder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisConnection l u → ∀ (a : α), (∃ b, a = u b) ↔ a = u (l a)",
  "name": "GaloisConnection.exists_eq_u",
  "kind": "theorem",
  "doc_string":
  "If there exists a `b` such that `a = u a`, then `b = l a` is one such element. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → One (M →* N)",
  "name": "instOneMonoidHom",
  "kind": "def",
  "doc_string": "`1` is the monoid homomorphism sending all elements to `1`. ",
  "args": ""},
 {"type":
  "{R₁ : Type u_1} →\n  {R₂ : Type u_2} →\n    {R₃ : Type u_3} →\n      [inst : Semiring R₁] →\n        [inst_1 : Semiring R₂] → [inst_2 : Semiring R₃] → (R₁ →+* R₂) → (R₂ →+* R₃) → outParam (R₁ →+* R₃) → Prop",
  "name": "RingHomCompTriple",
  "kind": "inductive",
  "doc_string":
  "Class that expresses the fact that three ring homomorphisms form a composition triple. This is\nused to handle composition of semilinear maps. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} {inst : Mul α} {inst_1 : Add β} {inst_2 : LE β}\n  [self : MulLEAddHomClass F α β] (f : F) (a b : α), ↑f (a * b) ≤ ↑f a + ↑f b",
  "name": "MulLEAddHomClass.map_mul_le_add",
  "kind": "def",
  "doc_string":
  "the image of a product is less or equal than the sum of the images. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : DivisionMonoid β] (f : α →* β) (g : α) (n : ℤ),\n  ↑f (g ^ n) = ↑f g ^ n",
  "name": "MonoidHom.map_zpow",
  "kind": "theorem",
  "doc_string": "Group homomorphisms preserve integer power. ",
  "args": ""},
 {"type":
  "∀ {F : Type u → Type v} [inst : Applicative F] {G : Type u → Type w} [inst_1 : Applicative G]\n  (self : ApplicativeTransformation F G) {α β : Type u} (x : F (α → β)) (y : F α),\n  ApplicativeTransformation.app self β (Seq.seq x fun x => y) =\n    Seq.seq (ApplicativeTransformation.app self (α → β) x) fun x => ApplicativeTransformation.app self α y",
  "name": "ApplicativeTransformation.preserves_seq'",
  "kind": "def",
  "doc_string": "An `ApplicativeTransformation` intertwines `seq`. ",
  "args": ""},
 {"type": "{α : Type u} → LazyList α → List α",
  "name": "LazyList.toList",
  "kind": "def",
  "doc_string":
  "Converts a lazy list to a list.\nIf the lazy list is infinite,\nthen this function does not terminate.\n",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Mul α] → [inst_1 : Mul β] → α ≃* β → WithOne α ≃* WithOne β",
  "name": "MulEquiv.withOneCongr",
  "kind": "def",
  "doc_string": "A version of `Equiv.optionCongr` for `WithOne`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {s t : Set α} → s ⊆ t → ↑s → ↑t",
  "name": "Set.inclusion",
  "kind": "def",
  "doc_string":
  "`inclusion` is the \"identity\" function between two subsets `s` and `t`, where `s ⊆ t` ",
  "args": ""},
 {"type": "{n : ℕ} → Fin n → ℕ",
  "name": "Fin.val",
  "kind": "def",
  "doc_string":
  "If `i : Fin n`, then `i.val : ℕ` is the described number. It can also be\nwritten as `i.1` or just `i` when the target type is known. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {n : ℕ} (a : α) (v : Vector α n), Vector.tail (Vector.cons a v) = v",
  "name": "Vector.tail_cons",
  "kind": "theorem",
  "doc_string":
  "The tail of a vector obtained by prepending is the vector prepended. to ",
  "args": ""},
 {"type":
  "{m : Type → Type} → [inst : Lean.MonadMCtx m] → Lean.MVarId → (Lean.Expr → Lean.Expr) → m Unit",
  "name": "Mathlib.Tactic.modifyTarget",
  "kind": "def",
  "doc_string":
  "`modifyTarget mvarId f` updates the target of the metavariable `mvarId` with\n`f`. For any `e`, `f e` must be defeq to `e`. If `mvarId` does not refer to\na declared metvariable, nothing happens.\n",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u_1} →\n          [inst_2 : CategoryTheory.Category E] →\n            {F G : C ⥤ D} →\n              (H : D ⥤ E) →\n                [inst_3 : CategoryTheory.Full H] → [inst_4 : CategoryTheory.Faithful H] → (F ⟶ G) ≃ (F ⋙ H ⟶ G ⋙ H)",
  "name": "CategoryTheory.NatTrans.equivOfCompFullyFaithful",
  "kind": "def",
  "doc_string":
  "Horizontal composition with a fully faithful functor induces a bijection on\nnatural transformations. ",
  "args": ""},
 {"type": "ByteArray → ByteSliceT",
  "name": "ByteArray.toSliceT",
  "kind": "def",
  "doc_string": "Convert a byte array into a terminal slice. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → α → Prop) → (β → β → Prop) → Type (max u_1 u_2)",
  "name": "RelIso",
  "kind": "inductive",
  "doc_string":
  "A relation isomorphism is an equivalence that is also a relation embedding. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α → ℕ → Array α → List α",
  "name": "List.eraseIdxTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `eraseIdxTR`: `eraseIdxTR.go l n xs acc = acc.toList ++ eraseIdx xs a`,\nunless `a` is not present in which case it returns `l` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Sub α] → [inst : Zero α] → WithTop α → WithTop α → WithTop α",
  "name": "WithTop.sub",
  "kind": "def",
  "doc_string":
  "If `α` has subtraction and `0`, we can extend the subtraction to `WithTop α`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a b : Q(«$α»)} →\n        Mathlib.Tactic.Ring.ExProd sα a →\n          Mathlib.Tactic.Ring.ExProd sα b → Option (Mathlib.Tactic.Ring.Overlap sα q(«$a» + «$b»))",
  "name": "Mathlib.Tactic.Ring.evalAddOverlap",
  "kind": "def",
  "doc_string":
  "Given monomials `va, vb`, attempts to add them together to get another monomial.\nIf the monomials are not compatible, returns `none`.\nFor example, `xy + 2xy = 3xy` is a `.nonzero` overlap, while `xy + xz` returns `none`\nand `xy + -xy = 0` is a `.zero` overlap.\n",
  "args": ""},
 {"type": "ParsedProjectionData → Array ℕ",
  "name": "ParsedProjectionData.projNrs",
  "kind": "def",
  "doc_string":
  "the list of projection numbers this expression corresponds to ",
  "args": ""},
 {"type": "(G : Type u_1) → [inst : DivisionMonoid G] → G ≃* Gᵐᵒᵖ",
  "name": "MulEquiv.inv'",
  "kind": "def",
  "doc_string":
  "Inversion on a group is a `MulEquiv` to the opposite group. When `G` is commutative, there is\n`MulEquiv.inv`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_-_»",
  "kind": "def",
  "doc_string":
  "`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. ",
  "args": ""},
 {"type":
  "Lean.SimpleScopedEnvExtension (Lean.Name × Array (Lean.Meta.DiscrTree.Key true)) (Lean.Meta.DiscrTree Lean.Name true)",
  "name": "Mathlib.Tactic.transExt",
  "kind": "opaque",
  "doc_string": "Environment extension storing transitivity lemmas ",
  "args": ""},
 {"type": "∀ {α : Type v} [self : Small α], ∃ S, Nonempty (α ≃ S)",
  "name": "Small.equiv_small",
  "kind": "def",
  "doc_string":
  "If a type is `Small.{w}`, then there exists an equivalence with some `S : Type w` ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : AddGroup G] [inst_1 : SubtractionMonoid H]\n  [inst_2 : AddMonoidHomClass F G H] (f : F) (a b : G), ↑f (a - b) = ↑f a - ↑f b",
  "name": "map_sub",
  "kind": "theorem",
  "doc_string": "Additive group homomorphisms preserve subtraction.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "coeNotation",
  "kind": "def",
  "doc_string":
  "`↑x` represents a coercion, which converts `x` of type `α` to type `β`, using\ntypeclasses to resolve a suitable conversion function. You can often leave the\n`↑` off entirely, since coercion is triggered implicitly whenever there is a\ntype error, but in ambiguous cases it can be useful to use `↑` to disambiguate\nbetween e.g. `↑x + ↑y` and `↑(x + y)`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : BEq α] →\n    {m : Type → Type u_2} →\n      [inst_1 : Monad m] →\n        (α → m Bool) →\n          (s : Aesop.UnorderedArraySet α) → optParam ℕ 0 → optParam ℕ (Aesop.UnorderedArraySet.size s) → m Bool",
  "name": "Aesop.UnorderedArraySet.allM",
  "kind": "def",
  "doc_string": "O(n) ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 ≠ 1 ∨ ∀ (a : M₀), a = 0",
  "name": "zero_ne_one_or_forall_eq_0",
  "kind": "theorem",
  "doc_string":
  "In a monoid with zero, either zero and one are nonequal, or zero is the only element. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      (α → β → Sort u) →\n        (β → γ → Sort v) → outParam (α → γ → Sort w) → Sort (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)",
  "name": "Trans",
  "kind": "inductive",
  "doc_string":
  "Transitive chaining of proofs, used e.g. by `calc`.\n\nIt takes two relations `r` and `s` as \"input\", and produces an \"output\"\nrelation `t`, with the property that `r a b` and `s b c` implies `t a c`.\nThe `calc` tactic uses this so that when it sees a chain with `a ≤ b` and `b < c`\nit knows that this should be a proof of `a < c` because there is an instance\n`Trans (·≤·) (·<·) (·<·)`.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Contrapose.contrapose!",
  "kind": "def",
  "doc_string":
  "Transforms the goal into its contrapositive and uses pushes negations inside `P` and `Q`.\nUsage matches `contrapose`\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (r s : R)\n  (x : M), (r * s) • x = r • s • x",
  "name": "Module.Core.mul_smul",
  "kind": "def",
  "doc_string":
  "Scalar multiplication distributes over multiplication from the right. ",
  "args": ""},
 {"type": "∀ {M : Type u_1} [inst : Monoid M], FaithfulSMul (MulAut M) M",
  "name": "MulAut.apply_faithfulSMul",
  "kind": "def",
  "doc_string": "`MulAut.applyDistribMulAction` is faithful. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₂] →\n      [inst_1 : One M₂] →\n        [inst_2 : Pow M₂ ℕ] →\n          [inst_3 : Monoid M₁] →\n            (f : M₁ → M₂) →\n              Function.Surjective f →\n                f 1 = 1 → (∀ (x y : M₁), f (x * y) = f x * f y) → (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) → Monoid M₂",
  "name": "Function.Surjective.monoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `1` and `*` is a monoid, if it admits a surjective map that preserves `1`\nand `*` to a monoid. See note [reducible non-instances]. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "CategoryTheory.aesop_cat",
  "kind": "def",
  "doc_string":
  "A thin wrapper for `aesop`,\nwhich adds the `CategoryTheory` rule set,\nand allows `aesop` look through semireducible definitions when calling `intros`. ",
  "args": ""},
 {"type": "ℚ → ℚ → Bool",
  "name": "Rat.blt",
  "kind": "def",
  "doc_string": "Rational number strictly less than relation, as a `Bool`. ",
  "args": ""},
 {"type": "Substring → String.Pos → Char",
  "name": "Substring.get",
  "kind": "def",
  "doc_string": "Return the codepoint at the given offset into the substring. ",
  "args": ""},
 {"type":
  "{ε : Type u_1} →\n  {p : ε → Prop} → [inst : DecidablePred p] → Equiv.Perm { a // p a } → Equiv.Perm { a // ¬p a } → Equiv.Perm ε",
  "name": "Equiv.Perm.subtypeCongr",
  "kind": "def",
  "doc_string":
  "Combining permutations on `ε` that permute only inside or outside the subtype\nsplit induced by `p : ε → Prop` constructs a permutation on `ε`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : SuccOrder α] [inst_2 : IsSuccArchimedean α] (r : α → α → Prop)\n  {n m : α},\n  (∀ (i : α), i ∈ Set.Ico n m → r i (Order.succ i)) →\n    (∀ (i : α), i ∈ Set.Ico m n → r (Order.succ i) i) → Relation.ReflTransGen r n m",
  "name": "reflTransGen_of_succ",
  "kind": "theorem",
  "doc_string":
  "`(n, m)` is in the reflexive-transitive closure of `~` if `i ~ succ i` and `succ i ~ i`\nfor all `i` between `n` and `m`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] {f g : M →ₙ* N}, f = g ↔ ∀ (x : M), ↑f x = ↑g x",
  "name": "MulHom.ext_iff",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.ext_iff` instead. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Set.«term⋂₀_»",
  "kind": "def",
  "doc_string": "Notation for `Set.interₛ` Intersection of a set of sets. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (α → β → m β) → β → (as : Array α) → optParam ℕ (Array.size as) → optParam ℕ 0 → m β",
  "name": "Array.foldrM",
  "kind": "def",
  "doc_string": "Reference implementation for `foldrM` ",
  "args": ""},
 {"type": "{α : Type u_1} → (lt : α → α → Bool) → Array α → BinaryHeap α lt",
  "name": "Array.toBinaryHeap",
  "kind": "def",
  "doc_string": "`O(n)`. Convert an unsorted array to a `BinaryHeap`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → (M →ₙ* N) → (M →ₙ* N) → Subsemigroup M",
  "name": "MulHom.eqLocus",
  "kind": "def",
  "doc_string": "The subsemigroup of elements `x : M` such that `f x = g x` ",
  "args": ""},
 {"type": "{gen : Type u} → [inst : RandomGen gen] → gen → Bool × gen",
  "name": "randBool",
  "kind": "def",
  "doc_string": "Generate a random Boolean. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : NonUnitalNonAssocRing α] {a b c d e : α}, a * e + c = b * e + d ↔ (a - b) * e + c = d",
  "name": "mul_add_eq_mul_add_iff_sub_mul_add_eq",
  "kind": "theorem",
  "doc_string":
  "An iff statement following from right distributivity in rings and the definition\nof subtraction. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedCancelAddCommMonoid α] (a b : α), max a b = if a ≤ b then b else a",
  "name": "LinearOrderedCancelAddCommMonoid.max_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `maxOfLe`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a : α}, a⁻¹ < 1 → 1 < a",
  "name": "one_lt_of_inv_lt_one",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `Left.inv_lt_one_iff`.",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "name": "List.Disjoint",
  "kind": "def",
  "doc_string":
  "`disjoint l₁ l₂` means that `l₁` and `l₂` have no elements in common. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Membership α β] {s t : β} {a : α}, a ∈ s → ¬a ∈ t → s ≠ t",
  "name": "Membership.Mem.ne_of_not_mem'",
  "kind": "theorem",
  "doc_string": "**Alias** of `ne_of_mem_of_not_mem'`.",
  "args": ""},
 {"type":
  "∀ {γ : Type w} [inst : SemilatticeSup γ] {a b : γ} {s t : Set γ}, IsLUB s a → IsLUB t b → IsLUB (s ∪ t) (a ⊔ b)",
  "name": "IsLUB.union",
  "kind": "theorem",
  "doc_string":
  "If `a` is the least upper bound of `s` and `b` is the least upper bound of `t`,\nthen `a ⊔ b` is the least upper bound of `s ∪ t`. ",
  "args": ""},
 {"type": "Linarith.Preprocessor → String",
  "name": "Linarith.Preprocessor.name",
  "kind": "def",
  "doc_string": "The name of the preprocessor, used in trace output. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«tacticSwap_var__,,»",
  "kind": "def",
  "doc_string":
  "`swap_var swap_rule₁, swap_rule₂, ⋯` applies `swap_rule₁` then `swap_rule₂` then `⋯`.\n\nA *swap_rule* is of the form `x y` or `x ↔ y`, and \"applying it\" means swapping the variable name\n`x` by `y` and vice-versa on all hypotheses and the goal.\n\n```lean\nexample {P Q : Prop} (q : P) (p : Q) : P ∧ Q := by\n  swap_var p ↔ q\n  exact ⟨p, q⟩\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∀ (x : α), p x → b) → (∃ x, p x) → b",
  "name": "not_exists_of_forall_not",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `exists_imp`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) [inst : Nontrivial β],\n  ↑f 1 ≠ 0",
  "name": "RingHom.map_one_ne_zero",
  "kind": "theorem",
  "doc_string": "`f : α →+* β` doesn't map `1` to `0` if `β` is nontrivial ",
  "args": ""},
 {"type": "PosNum → PosNum → Num × Num",
  "name": "PosNum.divMod",
  "kind": "def",
  "doc_string": "`divMod x y = (y / x, y % x)`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddCancelMonoid",
  "kind": "inductive",
  "doc_string":
  "An additive monoid in which addition is cancellative on both sides.\nMain examples are `ℕ` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `AddRightCancelMonoid` is not enough. ",
  "args": ""},
 {"type":
  "∀ {M : Type u} [self : AddLeftCancelMonoid M] (x : M), AddLeftCancelMonoid.nsmul 0 x = 0",
  "name": "AddLeftCancelMonoid.nsmul_zero",
  "kind": "def",
  "doc_string": "Multiplication by `(0 : ℕ)` gives `0`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → Set.Ioi b ⊆ Set.Ici a",
  "name": "Set.Ioi_subset_Ici",
  "kind": "theorem",
  "doc_string":
  "If `a ≤ b`, then `(b, +∞) ⊆ [a, +∞)`. In preorders, this is just an implication. If you need\nthe equivalence in dense linear orders, use `Ioi_subset_Ici_iff`. ",
  "args": ""},
 {"type": "{α : Type u} → Additive α ≃ α",
  "name": "Additive.toMul",
  "kind": "def",
  "doc_string": "Reinterpret `x : Additive α` as an element of `α`. ",
  "args": ""},
 {"type": "Type u → Type u → Type u",
  "name": "DoResultSBC",
  "kind": "inductive",
  "doc_string":
  "Auxiliary type used to compile `do` notation. It is an optimization of\neither `DoResultPRBC α PEmpty σ` or `DoResultPRBC PEmpty α σ` to remove the\nimpossible case, used when either `pure` or `return` is never used.\n",
  "args": ""},
 {"type": "ByteSlice → ℕ → UInt8",
  "name": "ByteSlice.getOp",
  "kind": "def",
  "doc_string":
  "Index into a byte slice. The `getOp` function allows the use of the `buf[i]` notation. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term¬_»",
  "kind": "def",
  "doc_string":
  "`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,\nso if your goal is `¬p` you can use `intro h` to turn the goal into\n`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
  "args": ""},
 {"type": "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self",
  "name": "Subtype.property",
  "kind": "def",
  "doc_string":
  "If `s : {x // p x}` then `s.2` or `s.property` is the assertion that\n`p s.1`, that is, that `s` is in fact an element for which `p` holds. ",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.CompSource",
  "kind": "inductive",
  "doc_string":
  "`CompSource` tracks the source of a comparison.\nThe atomic source of a comparison is an assumption, indexed by a natural number.\nTwo comparisons can be added to produce a new comparison,\nand one comparison can be scaled by a natural number to produce a new comparison.\n ",
  "args": ""},
 {"type":
  "{I : Type u} → {f : I → Type v₁} → {g : I → Type v₂} → ((i : I) → f i) → ((i : I) → g i) → (i : I) → f i × g i",
  "name": "Pi.prod",
  "kind": "def",
  "doc_string":
  "The mapping into a product type built from maps into each component. ",
  "args": ""},
 {"type": "ℕ → Array ℕ",
  "name": "Array.range",
  "kind": "def",
  "doc_string": "The array `#[0, 1, ..., n - 1]`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → ℕ → α → List α",
  "name": "List.set",
  "kind": "def",
  "doc_string":
  "`l.set n a` sets the value of list `l` at (zero-based) index `n` to `a`:\n`[a, b, c, d].set 1 b' = [a, b', c, d]`\n",
  "args": ""},
 {"type":
  "(α : Type u) →\n  [inst : Preorder α] → [inst_1 : BoundedRandom α] → (lo hi : α) → lo ≤ hi → SlimCheck.Gen { a // lo ≤ a ∧ a ≤ hi }",
  "name": "SlimCheck.Gen.choose",
  "kind": "def",
  "doc_string": "Lift `BoundedRandom.randomR` to the `Gen` monad. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {M : Type u_3} →\n      [inst : Semiring R] →\n        [inst_1 : AddCommMonoid M] →\n          [inst_2 : Module R M] →\n            [inst_3 : Semiring S] →\n              [inst_4 : SMul S M] →\n                (f : R →+* S) → Function.Surjective ↑f → (∀ (c : R) (x : M), ↑f c • x = c • x) → Module S M",
  "name": "Function.Surjective.moduleLeft",
  "kind": "def",
  "doc_string":
  "Push forward the action of `R` on `M` along a compatible surjective map `f : R →+* S`.\n\nSee also `Function.Surjective.mulActionLeft` and `Function.Surjective.distribMulActionLeft`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : LE α] → [inst : DecidableRel LE.le] → Min α",
  "name": "minOfLe",
  "kind": "def",
  "doc_string": "Implementation of the `min` operation using `≤`. ",
  "args": ""},
 {"type": "ByteArray → UInt64",
  "name": "ByteArray.toUInt64BE!",
  "kind": "def",
  "doc_string": "Interpret a `ByteArray` of size 8 as a big-endian `UInt64`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α] (a b c : α), a + b ≤ a + c → b ≤ c",
  "name": "CanonicallyLinearOrderedSemifield.le_of_add_le_add_left",
  "kind": "def",
  "doc_string":
  "Additive cancellation is compatible with the order in an ordered cancellative additive\ncommutative monoid. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c : α}, a - b ≤ c → a ≤ b + c",
  "name": "le_add_of_sub_left_le",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `sub_le_iff_le_add'`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsLeast s a → infₛ s = a",
  "name": "IsLeast.cinfₛ_eq",
  "kind": "theorem",
  "doc_string": "A least element of a set is the infimum of this set. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a b c : α), (a + b) * c = a * c + b * c",
  "name": "NonUnitalNonAssocSemiring.right_distrib",
  "kind": "def",
  "doc_string": "Multiplication is right distributive over addition ",
  "args": ""},
 {"type":
  "∀ {γ : Type w} [inst : SemilatticeSup γ] (a : γ) {s : Set γ}, BddAbove (insert a s) ↔ BddAbove s",
  "name": "bddAbove_insert",
  "kind": "theorem",
  "doc_string": "Adding a point to a set preserves its boundedness above. ",
  "args": ""},
 {"type":
  "{ε : Type u} → {m : Type v → Type w} → [self : MonadExcept ε m] → {α : Type v} → m α → (ε → m α) → m α",
  "name": "MonadExcept.tryCatch",
  "kind": "def",
  "doc_string":
  "`tryCatch (body : m α) (handler : ε → m α) : m α` will catch any errors in\n`body` and pass the resulting error to `handler`.\nErrors in `handler` will not be caught. ",
  "args": ""},
 {"type": "{α : Type u} → Stream' α → Stream' α",
  "name": "Stream'.tail",
  "kind": "def",
  "doc_string": "Tail of a stream: `Stream'.tail (h :: t) = t`. ",
  "args": ""},
 {"type": "{α : Sort u} → {r : α → α → Prop} → Quot r → α",
  "name": "Quot.lcInv",
  "kind": "axiom",
  "doc_string":
  "Unsafe auxiliary constant used by the compiler to erase `Quot.lift`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : SuccOrder α] {a : α}, ¬Order.IsSuccLimit a → a ∈ Set.range Order.succ",
  "name": "Order.mem_range_succ_of_not_isSuccLimit",
  "kind": "theorem",
  "doc_string":
  "See `not_isSuccLimit_iff` for a version that states that `a` is a successor of a value other\nthan itself. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} {M : Type u_2} {inst : Mul M} {inst_1 : SetLike S M} [self : MulMemClass S M] {s : S} {a b : M},\n  a ∈ s → b ∈ s → a * b ∈ s",
  "name": "MulMemClass.mul_mem",
  "kind": "def",
  "doc_string":
  "A substructure satisfying `MulMemClass` is closed under multiplication. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} → (p : Set β) → (f : r ↪r s) → (∀ (a : α), ↑f.toEmbedding a ∈ p) → r ↪r Subrel s p",
  "name": "RelEmbedding.codRestrict",
  "kind": "def",
  "doc_string": "Restrict the codomain of a relation embedding. ",
  "args": ""},
 {"type":
  "(α : Type u) →\n  [inst : AddGroup α] →\n    [inst_1 : LE α] →\n      [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] →\n        [inst : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] → α ≃o αᵒᵈ",
  "name": "OrderIso.neg",
  "kind": "def",
  "doc_string": "`x ↦ -x` as an order-reversing equivalence.",
  "args": ""},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "name": "Function.Surjective",
  "kind": "def",
  "doc_string":
  "A function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. ",
  "args": ""},
 {"type": "{α : Type u_1} → α ↪ Option α",
  "name": "Function.Embedding.some",
  "kind": "def",
  "doc_string": "Embedding into `Option α` using `some`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} (r : α → α → Prop) [inst : IsWellFounded α r] {C : α → Prop} (a : α),\n  (∀ (x : α), (∀ (y : α), r y x → C y) → C x) → C a",
  "name": "IsWellFounded.induction",
  "kind": "theorem",
  "doc_string": "Induction on a well-founded relation. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α}, IsGreatest s a → BddAbove s",
  "name": "IsGreatest.bddAbove",
  "kind": "theorem",
  "doc_string": "If `s` has a greatest element, then it is bounded above. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} → {Q : Type u_4} → [inst : Mul P] → [inst_1 : Mul Q] → M ≃ N → P ≃* Q → (M → P) ≃* (N → Q)",
  "name": "MulEquiv.arrowCongr",
  "kind": "def",
  "doc_string":
  "A multiplicative analogue of `Equiv.arrowCongr`,\nwhere the equivalence between the targets is multiplicative.\n",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} → {α : Type u_1} → [inst : Monad m] → Array α → (α → m α) → m (Array α)",
  "name": "Array.mapMonoM",
  "kind": "def",
  "doc_string":
  "Monomorphic `Array.mapM`. The internal implementation uses pointer equality, and does not allocate a new array\nif the result of each `f a` is a pointer equal value `a`.\n",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Mul M] → Subsemigroup M → Set M",
  "name": "Subsemigroup.carrier",
  "kind": "def",
  "doc_string": "The carrier of a subsemigroup. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tacticNlinarith!_",
  "kind": "def",
  "doc_string":
  "An extension of `linarith` with some preprocessing to allow it to solve some nonlinear arithmetic\nproblems. (Based on Coq's `nra` tactic.) See `linarith` for the available syntax of options,\nwhich are inherited by `nlinarith`; that is, `nlinarith!` and `nlinarith only [h1, h2]` all work as\nin `linarith`. The preprocessing is as follows:\n\n* For every subterm `a ^ 2` or `a * a` in a hypothesis or the goal,\n  the assumption `0 ≤ a ^ 2` or `0 ≤ a * a` is added to the context.\n* For every pair of hypotheses `a1 R1 b1`, `a2 R2 b2` in the context, `R1, R2 ∈ {<, ≤, =}`,\n  the assumption `0 R' (b1 - a1) * (b2 - a2)` is added to the context (non-recursively),\n  where `R ∈ {<, ≤, =}` is the appropriate comparison derived from `R1, R2`.\n",
  "args": ""},
 {"type": "(α : Type u_1) → (α → α → Prop) → Prop",
  "name": "IsDirected",
  "kind": "inductive",
  "doc_string":
  "`IsDirected α r` states that for any elements `a`, `b` there exists an element `c` such that\n`r a c` and `r b c`. ",
  "args": ""},
 {"type": "{σ α : Type u_1} → StateM σ α → σ → Stream' α",
  "name": "Stream'.corecState",
  "kind": "def",
  "doc_string": "Use a state monad to generate a stream through corecursion ",
  "args": ""},
 {"type": "{α : Type u} → (α → Bool) → List α → List α",
  "name": "List.filter",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `filter f l` returns the list of elements in `l` for which `f` returns true.\n```\nfilter (· > 2) [1, 2, 5, 2, 7, 7] = [5, 7, 7]\n```\n",
  "args": ""},
 {"type":
  "{M : Type u_1} → Set M → [inst : AddSemigroup M] → AddSubsemigroup M",
  "name": "AddSubsemigroup.centralizer",
  "kind": "def",
  "doc_string": "The centralizer of a subset of an additive semigroup.",
  "args": ""},
 {"type": "Linarith.PComp → Std.RBSet ℕ compare",
  "name": "Linarith.PComp.vars",
  "kind": "def",
  "doc_string":
  "The union of all variables appearing in those original assumptions\nwhich appear in the `history` set. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {a : α} {s : Set α}, (⨆ b, ⨆ h, a ⊓ b) ≤ a ⊓ supₛ s",
  "name": "supᵢ_inf_le_inf_supₛ",
  "kind": "theorem",
  "doc_string": "This is a weaker version of `inf_supₛ_eq` ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → α → List α → Option ℕ",
  "name": "List.indexOf?",
  "kind": "def",
  "doc_string": "Return the index of the first occurrence of `a` in the list. ",
  "args": ""},
 {"type": "{α : Type u} → [self : Inter α] → α → α → α",
  "name": "Inter.inter",
  "kind": "def",
  "doc_string": "`a ∩ b` is the intersection of`a` and `b`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {s₁ : Setoid α} →\n    {φ : Quotient s₁ → Sort u_2} →\n      (qa : Quotient s₁) → (f : (a : α) → φ (Quotient.mk'' a)) → (∀ (a₁ a₂ : α), a₁ ≈ a₂ → HEq (f a₁) (f a₂)) → φ qa",
  "name": "Quotient.hrecOn'",
  "kind": "def",
  "doc_string":
  "Recursion on a `Quotient` argument `a`, result type depends on `⟦a⟧`. ",
  "args": ""},
 {"type":
  "{X : Type u} →\n  {m₁ : X → X → X} →\n    {e₁ : X} →\n      EckmannHilton.IsUnital m₁ e₁ →\n        [G : Group X] → (∀ (a b c d : X), m₁ (a * b) (c * d) = m₁ a c * m₁ b d) → CommGroup X",
  "name": "EckmannHilton.commGroup",
  "kind": "def",
  "doc_string":
  "If a type carries a group structure that distributes over a unital binary operation,\nthen the group is commutative. ",
  "args": ""},
 {"type": "(G : Type u_1) → (P : Type u_2) → [inst : VAdd G P] → Prop",
  "name": "FaithfulVAdd",
  "kind": "inductive",
  "doc_string": "Typeclass for faithful actions. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : GCDMonoid α] (a b : α),\n  Associated (gcd a b * lcm a b) (a * b)",
  "name": "GCDMonoid.gcd_mul_lcm",
  "kind": "def",
  "doc_string":
  "The product of two elements is `Associated` with the product of their GCD and LCM. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  (r : α → α → Prop) →\n    [inst : IsWellFounded α r] → {C : α → Sort u_1} → ((x : α) → ((y : α) → r y x → C y) → C x) → (x : α) → C x",
  "name": "IsWellFounded.fix",
  "kind": "def",
  "doc_string":
  "Creates data, given a way to generate a value from all that compare as less under a well-founded\nrelation. See also `IsWellFounded.fix_eq`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → ℕ → List α",
  "name": "List.removeNthTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `removeNth`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α}, ¬BddBelow s ↔ ∀ (x : α), ∃ y, y ∈ s ∧ ¬x ≤ y",
  "name": "not_bddBelow_iff'",
  "kind": "theorem",
  "doc_string":
  "A set `s` is not bounded below if and only if for each `x` there exists `y ∈ s` such that `x`\nis not less than or equal to `y`. This version only assumes `Preorder` structure and uses\n`¬(x ≤ y)`. A version for linear orders is called `not_bddBelow_iff`. ",
  "args": ""},
 {"type": "Lean.MVarId → Lean.MetaM Unit",
  "name": "Mathlib.Tactic.Nontriviality.nontrivialityByAssumption",
  "kind": "def",
  "doc_string":
  "Tries to generate a `nontrivial α` instance using `nontrivial_of_ne` or `nontrivial_of_lt`\nand local hypotheses.\n",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 → Subsingleton M₀",
  "name": "subsingleton_of_zero_eq_one",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `subsingleton_iff_zero_eq_one`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (x : Option α) → ((a : α) → a ∈ x → Option β) → Option β",
  "name": "Option.pbind",
  "kind": "def",
  "doc_string":
  "Partial bind. If for some `x : Option α`, `f : Π (a : α), a ∈ x → Option β` is a\npartial function defined on `a : α` giving an `Option β`, where `some a = x`,\nthen `pbind x f h` is essentially the same as `bind x f`\nbut is defined only when all `x = some a`, using the proof to apply `f`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop}, (Set.range fun x => ↑x) = { x | p x }",
  "name": "Subtype.range_coe_subtype",
  "kind": "theorem",
  "doc_string":
  "We make this the simp lemma instead of `range_coe`. The reason is that if we write\nfor `s : Set α` the function `coe : s → α`, then the inferred implicit arguments of `coe` are\n`coe α (λ x, x ∈ s)`.\n\nTODO: Port this docstring to mathlib4 as `coe` is something else now.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a + b ≤ a + c → b ≤ c",
  "name": "StrictOrderedSemiring.le_of_add_le_add_left",
  "kind": "def",
  "doc_string":
  "Additive cancellation is compatible with the order in an ordered cancellative additive\ncommutative monoid. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : BEq α] [self : PartialEquivBEq α] {a b c : α},\n  (a == b) = true → (b == c) = true → (a == c) = true",
  "name": "PartialEquivBEq.trans",
  "kind": "def",
  "doc_string":
  "Transitivity for `BEq`. If `a == b` and `b == c` then `a == c`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : SemilatticeSup α] [inst_1 : OrderTop α] [inst_2 : SemilatticeSup β]\n  [inst_3 : OrderTop β] {a b : α} (f : α ≃o β),\n  Codisjoint a b → Codisjoint (↑(RelIso.toRelEmbedding f).toEmbedding a) (↑(RelIso.toRelEmbedding f).toEmbedding b)",
  "name": "Codisjoint.map_orderIso",
  "kind": "theorem",
  "doc_string":
  "Note that this goal could also be stated `(Codisjoint on f) a b` ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tacticSimp_wf",
  "kind": "def",
  "doc_string":
  "Unfold definitions commonly used in well founded relation definitions.\nThis is primarily intended for internal use in `decreasing_tactic`. ",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.Branch",
  "kind": "def",
  "doc_string":
  "Some preprocessors perform branching case splits. A `Branch` is used to track one of these case\nsplits. The first component, an `MVarId`, is the goal corresponding to this branch of the split,\ngiven as a metavariable. The `List Expr` component is the list of hypotheses for `linarith`\nin this branch.\n",
  "args": ""},
 {"type":
  "{α : Sort u_1} → [inst : DecidableEq α] → {β : Sort u_2} → α ≃ β → α → β → α ≃ β",
  "name": "Equiv.setValue",
  "kind": "def",
  "doc_string": "Augment an equivalence with a prescribed mapping `f a = b` ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → Set α",
  "name": "maxChain",
  "kind": "def",
  "doc_string":
  "An explicit maximal chain. `maxChain` is taken to be the union of all sets in `ChainClosure`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : DecidableEq α] → [inst : PartialOrder α] → [inst_1 : BoundedOrder α] → [inst_2 : IsSimpleOrder α] → α ≃o Bool",
  "name": "IsSimpleOrder.orderIsoBool",
  "kind": "def",
  "doc_string":
  "Every simple lattice over a partial order is order-isomorphic to `Bool`. ",
  "args": ""},
 {"type": "Mathlib.Meta.NormNum.NormNumExt",
  "name": "Mathlib.Meta.NormNum.evalAdd",
  "kind": "def",
  "doc_string":
  "The `norm_num` extension which identifies expressions of the form `a + b`,\nsuch that `norm_num` successfully recognises both `a` and `b`. ",
  "args": ""},
 {"type": "(α : Type u_1) → ↑∅ ≃ PEmpty",
  "name": "Equiv.Set.pempty",
  "kind": "def",
  "doc_string": "An empty set is equivalent to a `PEmpty` type. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Inter",
  "kind": "inductive",
  "doc_string": "Notation type class for the intersection operation `∩`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → List α → List β → List (Option α × β)",
  "name": "List.zipRight",
  "kind": "def",
  "doc_string":
  "Right-biased version of `List.zip`. `zipRight as bs` returns the list of pairs\n`(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `as` is shorter than `bs`, the\nremaining `bᵢ` are paired with `none`.\n```\nzipRight [1, 2] ['a'] = [(some 1, 'a')]\nzipRight [1] ['a', 'b'] = [(some 1, 'a'), (none, 'b')]\nzipRight = zipWithRight prod.mk\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : HasSSubset α]\n  [inst_2 : IsNonstrictStrictOrder α (fun x x_1 => x ⊆ x_1) fun x x_1 => x ⊂ x_1] {a b : α}, a ⊂ b → ¬b ⊆ a",
  "name": "HasSSubset.SSubset.not_subset",
  "kind": "theorem",
  "doc_string": "**Alias** of `not_subset_of_ssubset`.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "LinearOrderedCommGroup",
  "kind": "inductive",
  "doc_string":
  "A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone. ",
  "args": ""},
 {"type": "(V : Type u_1) → [inst : Quiver V] → Type (max u_1 v)",
  "name": "WideSubquiver",
  "kind": "def",
  "doc_string":
  "A wide subquiver `H` of `G` picks out a set `H a b` of arrows from `a` to `b`\nfor every pair of vertices `a b`.\n\nNB: this does not work for `Prop`-valued quivers. It requires `G : Quiver.{v+1} V`. ",
  "args": ""},
 {"type": "ℕ → ℕ",
  "name": "Nat.div2",
  "kind": "def",
  "doc_string": "`div2 n = ⌊n/2⌋` the greatest integer smaller than `n/2`",
  "args": ""},
 {"type":
  "∀ {β : Type u_1} [inst : ConditionallyCompleteLattice β] {s : Set (WithTop β)}, Set.Nonempty s → IsLUB s (supₛ s)",
  "name": "WithTop.isLUB_supₛ'",
  "kind": "theorem",
  "doc_string":
  "The `supₛ` of a non-empty set is its least upper bound for a conditionally\ncomplete lattice with a top. ",
  "args": ""},
 {"type": "Mathlib.Meta.Positivity.PositivityExt",
  "name": "Mathlib.Meta.Positivity.evalPowZero",
  "kind": "def",
  "doc_string":
  "The `positivity` extension which identifies expressions of the form `a ^ 0`.\nThis extension is run in addition to the general `a ^ b` extension (they are overlapping). ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term%[_|_]»",
  "kind": "def",
  "doc_string":
  "Auxiliary syntax for implementing `[$elem,*]` list literal syntax.\nThe syntax `%[a,b,c|tail]` constructs a value equivalent to `a::b::c::tail`.\nIt uses binary partitioning to construct a tree of intermediate let bindings as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "LE",
  "kind": "inductive",
  "doc_string":
  "`LE α` is the typeclass which supports the notation `x ≤ y` where `x y : α`.",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.CertificateOracle",
  "kind": "def",
  "doc_string":
  "A `CertificateOracle` is a function\n`produceCertificate : List Comp → Nat → MetaM (HashMap Nat Nat)`.\n`produceCertificate hyps max_var` tries to derive a contradiction from the comparisons in `hyps`\nby eliminating all variables ≤ `max_var`.\nIf successful, it returns a map `coeff : Nat → Nat` as a certificate.\nThis map represents that we can find a contradiction by taking the sum  `∑ (coeff i) * hyps[i]`.\n\nThe default `CertificateOracle` used by `linarith` is\n`Linarith.FourierMotzkin.produceCertificate`.\n",
  "args": ""},
 {"type":
  "Array ParsedProjectionData →\n  Lean.Name → Array Lean.Expr → Lean.Expr → List Lean.Level → Lean.MetaM (Array ParsedProjectionData)",
  "name": "simpsResolveNotationClass",
  "kind": "def",
  "doc_string":
  "Auxilliary function for `simpsGetRawProjections`.\nResolve a single notation class in `simpsFindAutomaticProjections`. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {β : ι → Type u_2} →\n    [inst : LinearOrder ι] →\n      [inst : IsWellOrder ι fun x x_1 => x < x_1] →\n        [inst : (a : ι) → LinearOrder (β a)] → LinearOrder (Lex ((i : ι) → β i))",
  "name": "Pi.instLinearOrderLexForAll",
  "kind": "def",
  "doc_string":
  "`Πₗ i, α i` is a linear order if the original order is well-founded. ",
  "args": ""},
 {"type": "Lean.Name → Lean.Name → Lean.CoreM Lean.Name",
  "name": "Mathlib.Tactic.Choose.mkFreshNameFrom",
  "kind": "def",
  "doc_string":
  "`mkFreshNameFrom orig base` returns `mkFreshUserName base` if ``orig = `_``\nand `orig` otherwise. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {r : α → α → Prop},\n  WellFounded r → ∀ {a bot : α} {C : α → Prop}, (∀ (b : α), b ≠ bot → C b → ∃ c, r c b ∧ C c) → C a → C bot",
  "name": "WellFounded.induction_bot",
  "kind": "theorem",
  "doc_string":
  "Let `r` be a well-founded relation on `α`, let `C : α → Prop`, and let `bot : α`.\nThis induction principle shows that `C bot` holds, given that\n* some `a` satisfies `C a`, and\n* for each `b` that satisfies `C b`, there is `c` satisfying `r c b` and `C c`.\n\nThe naming is inspired by the fact that when `r` is transitive, it follows that `bot` is\nthe smallest element w.r.t. `r` that satisfies `C`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α) → List α → List α",
  "name": "List.modifyHead",
  "kind": "def",
  "doc_string": "Apply `f` to the head of the list, if it exists. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : MulOneClass M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [inst : SubmonoidClass A M] → (S : A) → MulOneClass { x // x ∈ S }",
  "name": "SubmonoidClass.toMulOneClass",
  "kind": "def",
  "doc_string":
  "A submonoid of a unital magma inherits a unital magma structure. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → {F : Type u_3} → [inst : Add M] → [inst_1 : Add N] → [inst_2 : AddHomClass F M N] → F → AddHom M N",
  "name": "AddHomClass.toAddHom",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `AddHomClass F M N` into an actual\n`AddHom`. This is declared as the default coercion from `F` to `M →ₙ+ N`.",
  "args": ""},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "name": "supᵢ.unexpander",
  "kind": "def",
  "doc_string": "Unexpander for the indexed supremum notation.",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.Context → Bool",
  "name": "Mathlib.Tactic.Abel.Context.is_group",
  "kind": "def",
  "doc_string":
  "Specify whether we are in an additive commutative group or an additive commutative monoid. ",
  "args": ""},
 {"type": "{α : Sort u} → α",
  "name": "lcUnreachable",
  "kind": "axiom",
  "doc_string":
  "Auxiliary unsafe constant used by the Compiler to mark unreachable code.\n\nLike `lcProof`, this is an `unsafe axiom`, which means that even though it is\nnot sound, the kernel will not let us use it for regular proofs.\n\nExecuting this expression to actually synthesize a value of type `α` causes\n**immediate undefined behavior**, and the compiler does take advantage of this\nto optimize the code assuming that it is not called. If it is not optimized out,\nit is likely to appear as a print message saying \"unreachable code\", but this\nbehavior is not guaranteed or stable in any way.\n",
  "args": ""},
 {"type": "Sort u → Sort u",
  "name": "outParam",
  "kind": "def",
  "doc_string":
  "Gadget for marking output parameters in type classes.\n\nFor example, the `Membership` class is defined as:\n```\nclass Membership (α : outParam (Type u)) (γ : Type v)\n```\nThis means that whenever a typeclass goal of the form `Membership ?α ?γ` comes\nup, lean will wait to solve it until `?γ` is known, but then it will run\ntypeclass inference, and take the first solution it finds, for any value of `?α`,\nwhich thereby determines what `?α` should be.\n\nThis expresses that in a term like `a ∈ s`, `s` might be a `Set α` or\n`List α` or some other type with a membership operation, and in each case\nthe \"member\" type `α` is determined by looking at the container type.\n",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : AddMonoid α] → (u : AddUnits α) → (val : α) → val = ↑u → (inv : α) → inv = ↑(-u) → AddUnits α",
  "name": "AddUnits.copy",
  "kind": "def",
  "doc_string": "Copy an `AddUnit`, adjusting definitional equalities.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "StrictOrderedRing",
  "kind": "inductive",
  "doc_string":
  "A `StrictOrderedRing` is a ring with a partial order such that addition is strictly monotone\nand multiplication by a positive number is strictly monotone. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β} {s t : Set α} {c : α},\n  MonotoneOn f s → MonotoneOn f t → IsGreatest s c → IsLeast t c → MonotoneOn f (s ∪ t)",
  "name": "MonotoneOn.union_right",
  "kind": "theorem",
  "doc_string":
  "If `f` is monotone both on `s` and `t`, with `s` to the left of `t` and the center\npoint belonging to both `s` and `t`, then `f` is monotone on `s ∪ t` ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Preorder α] → Type u_1",
  "name": "SuccOrder",
  "kind": "inductive",
  "doc_string": "Order equipped with a sensible successor function. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (α : Type u_2) → [inst : VAdd M α] → [inst : VAdd Mᵃᵒᵖ α] → Prop",
  "name": "IsCentralVAdd",
  "kind": "inductive",
  "doc_string":
  "A typeclass indicating that the right (aka `AddOpposite`) and left actions by `M` on `α` are\nequal, that is that `M` acts centrally on `α`. This can be thought of as a version of commutativity\nfor `+ᵥ`. ",
  "args": ""},
 {"type":
  "Lean.MVarId → String → Mathlib.Tactic.Ring.RingM (Option Lean.MVarId × Lean.Syntax)",
  "name": "Mathlib.Tactic.Polyrith.polyrith.byRing",
  "kind": "def",
  "doc_string":
  "Try to prove the goal by `ring` and fail with the given message otherwise. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β} {s t : Set α} {c : α},\n  StrictAntiOn f s → StrictAntiOn f t → IsGreatest s c → IsLeast t c → StrictAntiOn f (s ∪ t)",
  "name": "StrictAntiOn.union",
  "kind": "theorem",
  "doc_string":
  "If `f` is strictly antitone both on `s` and `t`, with `s` to the left of `t` and the center\npoint belonging to both `s` and `t`, then `f` is strictly antitone on `s ∪ t` ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → β → Lex (α ⊕ β)",
  "name": "Sum.inrₗ",
  "kind": "def",
  "doc_string": "Lexicographical `sum.inr`. Only used for pattern matching. ",
  "args": ""},
 {"type": "Sort u → Sort (max 1 u)",
  "name": "DecidableEq",
  "kind": "def",
  "doc_string":
  "Asserts that `α` has decidable equality, that is, `a = b` is decidable\nfor all `a b : α`. See `Decidable`.\n",
  "args": ""},
 {"type": "Mathlib.Meta.NormNum.NormNumExt",
  "name": "Mathlib.Meta.NormNum.evalMul",
  "kind": "def",
  "doc_string":
  "The `norm_num` extension which identifies expressions of the form `a * b`,\nsuch that `norm_num` successfully recognises both `a` and `b`. ",
  "args": ""},
 {"type": "Nat.Primes → ℕ+",
  "name": "Nat.Primes.toPNat",
  "kind": "def",
  "doc_string": "The canonical map from `Nat.Primes` to `ℕ+` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (q : Semiquot α) → (f : α → β) → (∀ (a : α), a ∈ q → ∀ (b : α), b ∈ q → f a = f b) → β",
  "name": "Semiquot.liftOn",
  "kind": "def",
  "doc_string":
  "If `f` is a constant on `q.s`, then `q.liftOn f` is the value of `f`\nat any point of `q`. ",
  "args": ""},
 {"type": "Lean.Expr → Bool",
  "name": "Linarith.isStrictIntComparison",
  "kind": "def",
  "doc_string":
  "`isStrictIntComparison tp` is true iff `tp` is a strict inequality between integers\nor the negation of a weak inequality between integers.\n",
  "args": ""},
 {"type": "∀ (n : ℕ), Nat.pred (1 + n) = n",
  "name": "Nat.pred_one_add",
  "kind": "theorem",
  "doc_string": "This ensures that `simp` succeeds on `pred (n + 1) = n`. ",
  "args": ""},
 {"type":
  "∀ {K : Type u} [self : DivisionRing K] (a : K), DivisionRing.zpow 0 a = 1",
  "name": "DivisionRing.zpow_zero'",
  "kind": "def",
  "doc_string": "`a ^ 0 = 1` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c : α}, b ≤ c - a → a + b ≤ c",
  "name": "add_le_of_le_sub_left",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `le_sub_iff_add_le'`.",
  "args": ""},
 {"type": "{g : Type u} → [self : RandomGen g] → g → ℕ × ℕ",
  "name": "RandomGen.range",
  "kind": "def",
  "doc_string":
  "`range` returns the range of values returned by\nthe generator. ",
  "args": ""},
 {"type":
  "{β : Type v} →\n  {m : Type v → Type w} →\n    [inst : Monad m] → (β → Float → m β) → β → (as : FloatArray) → optParam ℕ 0 → optParam ℕ (FloatArray.size as) → m β",
  "name": "FloatArray.foldlM",
  "kind": "def",
  "doc_string": "Reference implementation for `foldlM` ",
  "args": ""},
 {"type": "Lean.Elab.Tactic.TacticM Unit → Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Linarith.proveEqZeroUsing",
  "kind": "def",
  "doc_string":
  "`proveEqZeroUsing tac e` tries to use `tac` to construct a proof of `e = 0`.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : MulZeroClass R] {a : R} [inst_1 : Nontrivial R], IsLeftRegular a → a ≠ 0",
  "name": "IsLeftRegular.ne_zero",
  "kind": "theorem",
  "doc_string":
  "A left-regular element of a `Nontrivial` `MulZeroClass` is non-zero. ",
  "args": ""},
 {"type": "List Linarith.Comp → ℕ → Linarith.LinarithData",
  "name": "Linarith.mkLinarithData",
  "kind": "def",
  "doc_string":
  "`mkLinarithData hyps vars` takes a list of hypotheses and the largest variable present in\nthose hypotheses. It produces an initial state for the elimination monad.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSSubset α] [inst_1 : IsAsymm α fun x x_1 => x ⊂ x_1] {a b : α}, a ⊂ b → ¬b ⊂ a",
  "name": "HasSSubset.SSubset.asymm",
  "kind": "theorem",
  "doc_string": "**Alias** of `ssubset_asymm`.",
  "args": ""},
 {"type":
  "∀ {X : Type u} {m₁ m₂ : X → X → X} {e₁ e₂ : X},\n  EckmannHilton.IsUnital m₁ e₁ →\n    EckmannHilton.IsUnital m₂ e₂ → (∀ (a b c d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) → IsAssociative X m₂",
  "name": "EckmannHilton.mul_assoc",
  "kind": "theorem",
  "doc_string":
  "If a type carries two unital binary operations that distribute over each other,\nthen these operations are associative.\n\nIn fact, they give a commutative monoid structure, see `eckmann_hilton.CommMonoid`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≤ b → ¬b ≤ a → a < b",
  "name": "LE.le.lt_of_not_le",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_le_not_le`.",
  "args": ""},
 {"type": "ℕ → ℕ → Prop",
  "name": "Nat.le",
  "kind": "inductive",
  "doc_string":
  "An inductive definition of the less-equal relation on natural numbers,\ncharacterized as the least relation `≤` such that `n ≤ n` and `n ≤ m → n ≤ m + 1`.\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddOpposite",
  "kind": "inductive",
  "doc_string":
  "Additive opposite of a type. This type inherits all multiplicative structures on\n`α` and reverses left and right in addition. ",
  "args": ""},
 {"type": "List Bool → Bool",
  "name": "List.bor",
  "kind": "def",
  "doc_string": "Big or of a list of Booleans. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddZeroClass M] → {S T : AddSubmonoid M} → S ≤ T → { x // x ∈ S } →+ { x // x ∈ T }",
  "name": "AddSubmonoid.inclusion",
  "kind": "def",
  "doc_string": "The `AddMonoid` hom associated to an inclusion of submonoids.",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] (a : G₀), a * a * a⁻¹ = a",
  "name": "mul_self_mul_inv",
  "kind": "theorem",
  "doc_string":
  "Multiplying `a` by itself and then by its inverse results in `a`\n(whether or not `a` is zero). ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_3} {γ : Type u_1} {f f' : α → β → γ} {s : Set α} {t : Set β},\n  (∀ (a : α) (b : β), f a b = f' a b) → Set.image2 f s t = Set.image2 f' s t",
  "name": "Set.image2_congr'",
  "kind": "theorem",
  "doc_string": "A common special case of `image2_congr` ",
  "args": ""},
 {"type": "∀ {α : Type u}, Subsingleton (Option α) ↔ IsEmpty α",
  "name": "Option.subsingleton_iff_isEmpty",
  "kind": "theorem",
  "doc_string": "`Option α` is a `Subsingleton` if and only if `α` is empty. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {G : Type u_2} →\n    [inst : AddGroup G] → [inst_1 : AddZeroClass M] → (f : M → G) → (∀ (a b : M), f (a + b) = f a + f b) → M →+ G",
  "name": "AddMonoidHom.mk'",
  "kind": "def",
  "doc_string":
  "Makes an additive group homomorphism from a proof that the map preserves addition.",
  "args": ""},
 {"type": "Lean.Syntax → Lean.Elab.TermElabM Mathlib.Tactic.Tauto.Config",
  "name": "Mathlib.Tactic.Tauto.elabConfig",
  "kind": "def",
  "doc_string": "Function elaborating `Config`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : LE α] → [inst : LE β] → LE (Lex (α ⊕ β))",
  "name": "Sum.Lex.LE",
  "kind": "def",
  "doc_string": "The linear/lexicographical `≤` on a sum. ",
  "args": ""},
 {"type": "(G : Type u) → [inst : Add G] → Prop",
  "name": "IsCancelAdd",
  "kind": "inductive",
  "doc_string": "A mixin for cancellative addition. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : PredOrder α] {a b : α} [inst_2 : NoMinOrder α],\n  a < b → Order.pred a < Order.pred b",
  "name": "Order.pred_lt_pred",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Order.pred_lt_pred_iff`.",
  "args": ""},
 {"type":
  "∀ {R : Type u_2} {S : Type u_1} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ≃+* S), ↑f 1 = 1",
  "name": "RingEquiv.map_one",
  "kind": "theorem",
  "doc_string": "A ring isomorphism sends one to one. ",
  "args": ""},
 {"type": "{α : Type u_1} → [ord : Ord α] → Array α → Array α → Array α",
  "name": "Array.mergeSortedPreservingDuplicates",
  "kind": "def",
  "doc_string":
  "Merge arrays `xs` and `ys`, which must be sorted according to `compare`. The\nresult is sorted as well. If two (or more) elements are equal according to\n`compare`, they are preserved.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a < b ∨ a = b",
  "name": "LE.le.lt_or_eq",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_or_eq_of_le`.",
  "args": ""},
 {"type":
  "(M : Type u_1) → (A : Type u_2) → [inst : Monoid M] → [inst : Monoid A] → Type (max u_1 u_2)",
  "name": "MulDistribMulAction",
  "kind": "inductive",
  "doc_string":
  "Typeclass for multiplicative actions on multiplicative structures. This generalizes\nconjugation actions. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ⩿ b ↔ a ≤ b ∧ ∀ (c : α), a ≤ c → c ≤ b → c = a ∨ c = b",
  "name": "wcovby_iff_le_and_eq_or_eq",
  "kind": "theorem",
  "doc_string":
  "An `iff` version of `Wcovby.eq_or_eq` and `wcovby_of_eq_or_eq`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M), Submonoid.closure ↑S = S",
  "name": "Submonoid.closure_eq",
  "kind": "theorem",
  "doc_string": "Closure of a submonoid `S` equals `S`. ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a : α), a * 0 = 0",
  "name": "NonUnitalNonAssocRing.mul_zero",
  "kind": "def",
  "doc_string": "Zero is a right absorbing element for multiplication ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : ConditionallyCompleteLinearOrder α] → DecidableEq α",
  "name": "ConditionallyCompleteLinearOrder.decidable_eq",
  "kind": "def",
  "doc_string":
  "In a `ConditionallyCompleteLinearOrder`, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : PredOrder α] [inst_2 : IsPredArchimedean α] (r : α → α → Prop)\n  {n m : α},\n  Reflexive r →\n    (∀ (i : α), i ∈ Set.Ioc m n → r i (Order.pred i)) →\n      (∀ (i : α), i ∈ Set.Ioc n m → r (Order.pred i) i) → Relation.TransGen r n m",
  "name": "transGen_of_pred_of_reflexive",
  "kind": "theorem",
  "doc_string":
  "`(n, m)` is in the transitive closure of a reflexive relation `~` if `i ~ pred i` and\n`pred i ~ i` for all `i` between `n` and `m`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {f : α → α} {x : α}, Monotone f → f x ≤ x → Antitone fun n => Nat.iterate f n x",
  "name": "Monotone.antitone_iterate_of_map_le",
  "kind": "theorem",
  "doc_string":
  "If `f` is a monotone map and `f x ≤ x` at some point `x`, then the iterates `f^[n] x` form\na antitone sequence. ",
  "args": ""},
 {"type":
  "(R : Type u_1) → (S : Type u_2) → [inst : Mul R] → [inst : Mul S] → [inst : Add R] → [inst : Add S] → Type (max u_1 u_2)",
  "name": "RingEquiv",
  "kind": "inductive",
  "doc_string":
  "An equivalence between two (non-unital non-associative semi)rings that preserves the\nalgebraic structure. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.Expr → Lean.Expr → Mathlib.Meta.NormNum.Result'",
  "name": "Mathlib.Meta.NormNum.Result'.isNegNat",
  "kind": "def",
  "doc_string": "Untyped version of `Result.isNegNat`. ",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : RightCancelSemigroup G] → G → G ↪ G",
  "name": "mulRightEmbedding",
  "kind": "def",
  "doc_string":
  "The embedding of a right cancellative semigroup into itself\nby right multiplication by a fixed element.\n ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : PartialOrder α] → {a b : α} → a < b → OrderTop ↑(Set.Ioc a b)",
  "name": "Set.Ioc.orderTop",
  "kind": "def",
  "doc_string": "`Ioc a b` has a top element whenever `a < b`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Functor.«term_$>_»",
  "kind": "def",
  "doc_string":
  "If `f` is a functor, if `fb : f β` and `a : α`, then `mapConstRev fb a` is the result of\napplying `f.map` to the constant function `β → α` sending everything to `a`, and then\nevaluating at `fb`. In other words it's `const a <$> fb`. ",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → (β → β → Prop) → (α → β) → α → α → Prop",
  "name": "InvImage",
  "kind": "def",
  "doc_string":
  "The inverse image of `r : β → β → Prop` by a function `α → β` is the relation\n`s : α → α → Prop` defined by `s a b = r (f a) (f b)`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → List α → ℕ → α → List α",
  "name": "List.updateNth",
  "kind": "def",
  "doc_string": "Update the nth element of a list. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "name": "PosMulMonoRev",
  "kind": "def",
  "doc_string":
  "`PosMulMonoRev α` is an abbreviation for `ContravariantClas α>0 α (λ x y, x * y) (≤)`,\nexpressing that multiplication by positive elements on the left is reverse monotone. ",
  "args": ""},
 {"type": "{α : Type u} → (α → α → Prop) → Set α → Prop",
  "name": "Set.Bounded",
  "kind": "def",
  "doc_string":
  "A bounded or final set. Not to be confused with `Metric.bounded`. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Ring.Cache q(ℕ)",
  "name": "Mathlib.Tactic.Ring.Cache.nat",
  "kind": "def",
  "doc_string": "A precomputed `Cache` for `ℕ`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] [inst_1 : OrderBot α] {a b : α}, a < b → b ≠ ⊥",
  "name": "LT.lt.ne_bot",
  "kind": "theorem",
  "doc_string": "**Alias** of `ne_bot_of_gt`.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "BEq",
  "kind": "inductive",
  "doc_string":
  "`BEq α` is a typeclass for supplying a boolean-valued equality relation on\n`α`, notated as `a == b`. Unlike `DecidableEq α` (which uses `a = b`), this\nis `Bool` valued instead of `Prop` valued, and it also does not have any\naxioms like being reflexive or agreeing with `=`. It is mainly intended for\nprogramming applications. See `LawfulBEq` for a version that requires that\n`==` and `=` coincide.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] {a b : α} {o : Ordering},\n  Ordering.Compares (Ordering.swap o) a b → Ordering.Compares o b a",
  "name": "Ordering.Compares.of_swap",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `Ordering.compares_swap`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedCommSemiring α] (a b : α), a ≤ b ∨ b ≤ a",
  "name": "LinearOrderedCommSemiring.le_total",
  "kind": "def",
  "doc_string": "A linear order is total. ",
  "args": ""},
 {"type": "Lean.Name → Bool",
  "name": "ToAdditive.isInternal'",
  "kind": "def",
  "doc_string":
  "Lean 4 makes declarations which are not internal\n(that is, head string starts with `_`) but which should be transformed.\ne.g. `proof_1` in `Lean.Meta.mkAuxDefinitionFor` this might be better fixed in core.\nThis method is polyfill for that.\nNote: this declaration also occurs as `shouldIgnore` in the Lean 4 file `test/lean/run/printDecls`.\n",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "InvOneClass",
  "kind": "inductive",
  "doc_string": "Typeclass for expressing that `1⁻¹ = 1`. ",
  "args": ""},
 {"type":
  "{M₀ : Type u_1} →\n  {M₀' : Type u_2} →\n    [inst : SemigroupWithZero M₀] →\n      [inst_1 : Zero M₀'] →\n        [inst_2 : Mul M₀'] →\n          (f : M₀ → M₀') →\n            Function.Surjective f → f 0 = 0 → (∀ (x y : M₀), f (x * y) = f x * f y) → SemigroupWithZero M₀'",
  "name": "Function.Surjective.semigroupWithZero",
  "kind": "def",
  "doc_string":
  "Pushforward a `SemigroupWithZero` along an surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u_1} → (l : List α) → (n : ℕ) → n < List.length l → α",
  "name": "List.nthLe",
  "kind": "def",
  "doc_string": "nth element of a list `l` given `n < l.length`. ",
  "args": ""},
 {"type": "{α : Sort u_1} → {β : Sort u_2} → Trunc α → (α → Trunc β) → Trunc β",
  "name": "Trunc.bind",
  "kind": "def",
  "doc_string": "The `bind` operator for the `Trunc` monad. ",
  "args": ""},
 {"type": "Lean.FVarId → Mathlib.Tactic.Polyrith.Source",
  "name": "Mathlib.Tactic.Polyrith.Source.fvar",
  "kind": "def",
  "doc_string": "`fvar h` refers to hypothesis `h` from the local context. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → [inst : IsWellOrder β s] → r ↪r s → r ≼i s",
  "name": "RelEmbedding.collapse",
  "kind": "def",
  "doc_string":
  "Construct an initial segment from an order embedding into a well order, by collapsing it\nto fill the gaps. ",
  "args": ""},
 {"type":
  "(ε : Type u) → {m : Type v → Type w} → [inst : MonadExceptOf ε m] → {α : Type v} → m α → (ε → m α) → m α",
  "name": "tryCatchThe",
  "kind": "def",
  "doc_string":
  "This is the same as `tryCatch`, but allows specifying the particular error type\nin case the monad supports throwing more than one type of error.\n",
  "args": ""},
 {"type": "{α : Type u_1} → ℕ → List α → List α × List α",
  "name": "List.splitAt",
  "kind": "def",
  "doc_string":
  "Split a list at an index.\n```\nsplitAt 2 [a, b, c] = ([a, b], [c])\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Mul α] [self : HasDistribNeg α] (x y : α), x * -y = -(x * y)",
  "name": "HasDistribNeg.mul_neg",
  "kind": "def",
  "doc_string": "Negation is right distributive over multiplication ",
  "args": ""},
 {"type": "{M : Type u} → [self : RightCancelMonoid M] → ℕ → M → M",
  "name": "RightCancelMonoid.npow",
  "kind": "def",
  "doc_string": "Raising to the power of a natural number. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Inv α] → [inst : HasSup α] → Abs α",
  "name": "Inv.toHasAbs",
  "kind": "def",
  "doc_string": "`abs a` is the absolute value of `a`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → {δ : Type u_4} → (α → β → γ → δ) → Set α → Set β → Set γ → Set δ",
  "name": "Set.image3",
  "kind": "def",
  "doc_string":
  "The image of a ternary function `f : α → β → γ → δ` as a function\n`Set α → Set β → Set γ → set δ`. Mathematically this should be thought of as the image of the\ncorresponding function `α × β × γ → δ`.\n",
  "args": ""},
 {"type":
  "∀ (α : Type u_1) [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 4",
  "name": "zero_lt_four'",
  "kind": "theorem",
  "doc_string": "See `zero_lt_four` for a version with the type implicit. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "HImp",
  "kind": "inductive",
  "doc_string": "Syntax typeclass for Heyting implication `⇨`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : MulZeroClass R] {a : R} [inst_1 : Nontrivial R], IsRightRegular a → a ≠ 0",
  "name": "IsRightRegular.ne_zero",
  "kind": "theorem",
  "doc_string":
  "A right-regular element of a `Nontrivial` `MulZeroClass` is non-zero. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : DecidableEq α] → [inst : PartialOrder α] → [inst_1 : BoundedOrder α] → [inst : IsSimpleOrder α] → Lattice α",
  "name": "IsSimpleOrder.lattice",
  "kind": "def",
  "doc_string":
  "A simple partial ordered `BoundedOrder` induces a lattice.\nThis is not an instance to prevent loops ",
  "args": ""},
 {"type":
  "{m : Type → Type} → [inst : Lean.MonadMCtx m] → Lean.MVarId → (Lean.MetavarDecl → Lean.MetavarDecl) → m Unit",
  "name": "Mathlib.Tactic.modifyMetavarDecl",
  "kind": "def",
  "doc_string":
  "`modifyMetavarDecl mvarId f` updates the `MetavarDecl` for `mvarId` with `f`.\nConditions on `f`:\n\n- The target of `f mdecl` is defeq to the target of `mdecl`.\n- The local context of `f mdecl` must contain the same fvars as the local\n  context of `mdecl`. For each fvar in the local context of `f mdecl`, the type\n  (and value, if any) of the fvar must be defeq to the corresponding fvar in\n  the local context of `mdecl`.\n\nIf `mvarId` does not refer to a declared metavariable, nothing happens.\n",
  "args": ""},
 {"type":
  "(p : Sort u_1) → (a : ℤ) → (n : ℕ) → Nat.ble 1 n = true → Mathlib.Tactic.ModCases.OnModCases n a 0 p → p",
  "name": "Mathlib.Tactic.ModCases.onModCases_start",
  "kind": "def",
  "doc_string":
  "The first theorem we apply says that `∃ z, 0 ≤ z < n ∧ a ≡ z (mod n)`.\nThe actual mathematical content of the proof is here.\n",
  "args": ""},
 {"type": "CommSemiring ℕ",
  "name": "Mathlib.Tactic.Ring.instCommSemiringNat",
  "kind": "def",
  "doc_string": "A shortcut instance for `CommSemiring ℕ` used by ring. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Functor.AddConst α β → α",
  "name": "Functor.AddConst.run",
  "kind": "def",
  "doc_string": "Extract the element of `α` from the constant functor. ",
  "args": ""},
 {"type": "ℤ → ℕ → Bool",
  "name": "Int.testBit",
  "kind": "def",
  "doc_string":
  "`testBit m n` returns whether the `(n+1)ˢᵗ` least significant bit is `1` or `0`",
  "args": ""},
 {"type": "Type u → Type (max 1 u)",
  "name": "Random",
  "kind": "inductive",
  "doc_string": "`Random α` gives us machinery to generate values of type `α` ",
  "args": ""},
 {"type": "Sort u → Sort (max u (v + 2))",
  "name": "SlimCheck.SampleableExt",
  "kind": "inductive",
  "doc_string":
  "`SampleableExt` can be used in two ways. The first (and most common)\nis to simply generate values of a type directly using the `Gen` monad,\nif this is what you want to do then `SampleableExt.mkSelfContained` is\nthe way to go.\n\nFurthermore it makes it possible to express generators for types that\ndo not lend themselves to introspection, such as `ℕ → ℕ`.\nIf we test a quantification over functions the\ncounter-examples cannot be shrunken or printed meaningfully.\nFor that purpose, `SampleableExt` provides a proxy representation\n`proxy` that can be printed and shrunken as well\nas interpreted (using `interp`) as an object of the right type. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : AddMonoidWithOne α] → ℕ → α",
  "name": "Nat.rawCast",
  "kind": "def",
  "doc_string":
  "A \"raw nat cast\" is an expression of the form `(Nat.rawCast lit : α)` where `lit` is a raw\nnatural number literal. These expressions are used by tactics like `ring` to decrease the number\nof typeclass arguments required in each use of a number literal at type `α`.\n",
  "args": ""},
 {"type":
  "{R : Type u_1} → [inst : LinearOrderedCommSemiring R] → LinearOrderedCancelCommMonoid { x // 0 < x }",
  "name": "Positive.linearOrderedCancelCommMonoid",
  "kind": "def",
  "doc_string":
  "If `R` is a nontrivial linear ordered commutative semiring, then `{x : R // 0 < x}` is a linear\nordered cancellative commutative monoid. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : NonAssocSemiring α] →\n    {β : Type v} →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : SMul ℕ β] →\n                [inst_6 : NatCast β] →\n                  (f : α → β) →\n                    Function.Surjective f →\n                      f 0 = 0 →\n                        f 1 = 1 →\n                          (∀ (x y : α), f (x + y) = f x + f y) →\n                            (∀ (x y : α), f (x * y) = f x * f y) →\n                              (∀ (x : α) (n : ℕ), f (n • x) = n • f x) → (∀ (n : ℕ), f ↑n = ↑n) → NonAssocSemiring β",
  "name": "Function.Surjective.nonAssocSemiring",
  "kind": "def",
  "doc_string":
  "Pushforward a `NonAssocSemiring` instance along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a : Q(ℕ)} →\n        Mathlib.Tactic.Ring.ExSum Mathlib.Tactic.Ring.sℕ a →\n          Mathlib.Tactic.Ring.RingM (Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExSum sα) q(↑«$a»))",
  "name": "Mathlib.Tactic.Ring.ExSum.evalNatCast",
  "kind": "opaque",
  "doc_string":
  "Applies `Nat.cast` to a nat polynomial to produce a polynomial in `α`.\n\n* `↑0 = 0`\n* `↑(a + b) = ↑a + ↑b`\n",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → α →o α × α",
  "name": "OrderHom.diag",
  "kind": "def",
  "doc_string": "Diagonal embedding of `α` into `α × α` as a `OrderHom`. ",
  "args": ""},
 {"type": "Substring → Substring → String.Pos → String.Pos → Option Substring",
  "name": "Substring.dropPrefix?.go",
  "kind": "def",
  "doc_string": "Auxiliary definition for `dropPrefix?`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : Monoid α] → {a : α} → IsUnit a → Invertible a",
  "name": "IsUnit.invertible",
  "kind": "def",
  "doc_string":
  "Convert `IsUnit` to `Invertible` using `Classical.choice`.\n\nPrefer `casesI h.nonempty_invertible` over `letI := h.invertible` if you want to avoid choice. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : CancelCommMonoidWithZero α] → Type u_1",
  "name": "GCDMonoid",
  "kind": "inductive",
  "doc_string":
  "GCD monoid: a `CancelCommMonoidWithZero` with `gcd` (greatest common divisor) and\n`lcm` (least common multiple) operations, determined up to a unit. The type class focuses on `gcd`\nand we derive the corresponding `lcm` facts from `gcd`.\n",
  "args": ""},
 {"type":
  "(α : Type u) →\n  [inst : Group α] →\n    [inst_1 : LE α] →\n      [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] →\n        [inst : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] → α ≃o αᵒᵈ",
  "name": "OrderIso.inv",
  "kind": "def",
  "doc_string": "`x ↦ x⁻¹` as an order-reversing equivalence. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.lemma",
  "kind": "def",
  "doc_string":
  "`lemma` means the same as `theorem`. It is used to denote \"less important\" theorems ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : Group α] →\n    [inst_1 : LE α] → [inst : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] → α → α ≃o α",
  "name": "OrderIso.mulLeft",
  "kind": "def",
  "doc_string":
  "`Equiv.mulLeft` as an `OrderIso`. See also `OrderEmbedding.mulLeft`. ",
  "args": ""},
 {"type":
  "∀ (M : Type u_1) (N : Type u_2) (α : Type u_3) [inst : VAdd M α] [inst_1 : VAdd N α] [inst_2 : VAddCommClass M N α],\n  VAddCommClass N M α",
  "name": "VAddCommClass.symm",
  "kind": "theorem",
  "doc_string":
  "Commutativity of additive actions is a symmetric relation. This lemma can't be an instance\nbecause this would cause a loop in the instance search graph. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      [inst : Preorder α] → [inst_1 : Preorder β] → [inst_2 : Preorder γ] → (α →o β) → (α →o γ) → α →o β × γ",
  "name": "OrderHom.prod",
  "kind": "def",
  "doc_string":
  "Given two bundled monotone maps `f`, `g`, `f.prod g` is the map `x ↦ (f x, g x)` bundled as a\n`OrderHom`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (o : Part α) → [inst : Decidable o.Dom] → Option α",
  "name": "Part.toOption",
  "kind": "def",
  "doc_string": "Convert a `Part α` with a decidable domain to an option ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : AddRightCancelSemigroup α] → [inst : One α] → ComplexShape α",
  "name": "ComplexShape.up",
  "kind": "def",
  "doc_string":
  "The `ComplexShape` appropriate for cohomology, so `d : X i ⟶ X j` only when `j = i + 1`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : NormalizedGCDMonoid α] (a b : α),\n  ↑normalize (gcd a b) = gcd a b",
  "name": "NormalizedGCDMonoid.normalize_gcd",
  "kind": "def",
  "doc_string": "The GCD is normalized to itself. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.LinearCombination.linearCombination",
  "kind": "def",
  "doc_string":
  "`linear_combination` attempts to simplify the target by creating a linear combination\n  of a list of equalities and subtracting it from the target.\n  The tactic will create a linear\n  combination by adding the equalities together from left to right, so the order\n  of the input hypotheses does matter.  If the `normalize` field of the\n  configuration is set to false, then the tactic will simply set the user up to\n  prove their target using the linear combination instead of normalizing the subtraction.\n\nNote: The left and right sides of all the equalities should have the same\n  type, and the coefficients should also have this type.  There must be\n  instances of `Mul` and `AddGroup` for this type.\n\n* The input `e` in `linear_combination e` is a linear combination of proofs of equalities,\n  given as a sum/difference of coefficients multiplied by expressions.\n  The coefficients may be arbitrary expressions.\n  The expressions can be arbitrary proof terms proving equalities.\n  Most commonly they are hypothesis names `h1, h2, ...`.\n* `linear_combination (norm := tac) e` runs the \"normalization tactic\" `tac`\n  on the subgoal(s) after constructing the linear combination.\n  * The default normalization tactic is `ring1`, which closes the goal or fails.\n  * To get a subgoal in the case that it is not immediately provable, use\n    `ring_nf` as the normalization tactic.\n  * To avoid normalization entirely, use `skip` as the normalization tactic.\n* `linear_combination2 e` is the same as `linear_combination e` but it produces two\n  subgoals instead of one: rather than proving that `(a - b) - (a' - b') = 0` where\n  `a' = b'` is the linear combination from `e` and `a = b` is the goal,\n  it instead attempts to prove `a = a'` and `b = b'`.\n  Because it does not use subtraction, this form is applicable also to semirings.\n  * Note that a goal which is provable by `linear_combination e` may not be provable\n    by `linear_combination2 e`; in general you may need to add a coefficient to `e`\n    to make both sides match, as in `linear_combination2 e + c`.\n  * You can also reverse equalities using `← h`, so for example if `h₁ : a = b`\n    then `2 * (← h)` is a proof of `2 * b = 2 * a`.\n\nExample Usage:\n```\nexample (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by\n  linear_combination 1*h1 - 2*h2\n\nexample (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by\n  linear_combination h1 - 2*h2\n\nexample (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by\n  linear_combination (norm := ring_nf) -2*h2\n  /- Goal: x * y + x * 2 - 1 = 0 -/\n\nexample (x y z : ℝ) (ha : x + 2*y - z = 4) (hb : 2*x + y + z = -2)\n    (hc : x + 2*y + z = 2) :\n    -3*x - 3*y - 4*z = 2 := by\n  linear_combination ha - hb - 2*hc\n\nexample (x y : ℚ) (h1 : x + y = 3) (h2 : 3*x = 7) :\n    x*x*y + y*x*y + 6*x = 3*x*y + 14 := by\n  linear_combination x*y*h1 + 2*h2\n\nexample (x y : ℤ) (h1 : x = -3) (h2 : y = 10) : 2*x = -6 := by\n  linear_combination (norm := skip) 2*h1\n  simp\n\naxiom qc : ℚ\naxiom hqc : qc = 2*qc\n\nexample (a b : ℚ) (h : ∀ p q : ℚ, p = q) : 3*a + qc = 3*b + 2*qc := by\n  linear_combination 3 * h a b + hqc\n```\n",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : HeytingAlgebra α] (a : α), ⊥ ≤ a",
  "name": "HeytingAlgebra.bot_le",
  "kind": "def",
  "doc_string": "`⊥` is a least element ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : LinearOrderedCommGroupWithZero α] → {a : α} → a ≠ 0 → α ≃o α",
  "name": "OrderIso.mulLeft₀'",
  "kind": "def",
  "doc_string":
  "`Equiv.mulLeft₀` as an `OrderIso` on a `LinearOrderedCommGroupWithZero.`.\n\nNote that `OrderIso.mulLeft₀` refers to the `LinearOrderedField` version. ",
  "args": ""},
 {"type":
  "{M : Type uM} →\n  {N : Type uN} →\n    {P : Type uP} →\n      [inst : MulOneClass M] → [inst_1 : MulOneClass N] → [inst_2 : CommMonoid P] → (M →* N) → (N →* P) →* M →* P",
  "name": "MonoidHom.compHom'",
  "kind": "def",
  "doc_string":
  "The expression `λ g m, g (f m)` as a `MonoidHom`.\nEquivalently, `(λ g, MonoidHom.comp g f)` as a `MonoidHom`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} → [inst : AddZeroClass α] → [inst_1 : AddZeroClass β] → (α →+ β) ≃ (Multiplicative α →* Multiplicative β)",
  "name": "AddMonoidHom.toMultiplicative",
  "kind": "def",
  "doc_string":
  "Reinterpret `α →+ β` as `Multiplicative α →* Multiplicative β`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : Lattice α] →\n    {P : α → Prop} → (∀ ⦃x y : α⦄, P x → P y → P (x ⊔ y)) → (∀ ⦃x y : α⦄, P x → P y → P (x ⊓ y)) → Lattice { x // P x }",
  "name": "Subtype.lattice",
  "kind": "def",
  "doc_string":
  "A subtype forms a lattice if `⊔` and `⊓` preserve the property.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {R' : Type u_2} →\n    (M : Type u_3) →\n      [inst : Zero R] →\n        [inst_1 : Zero M] → [inst_2 : SMulWithZero R M] → [inst_3 : Zero R'] → ZeroHom R' R → SMulWithZero R' M",
  "name": "SMulWithZero.compHom",
  "kind": "def",
  "doc_string":
  "Compose a `SMulWithZero` with a `ZeroHom`, with action `f r' • m` ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "CategoryTheory.Functor.«term_⋙_»",
  "kind": "def",
  "doc_string": "Notation for composition of functors. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → α ⊕ β → Option α",
  "name": "Sum.getLeft",
  "kind": "def",
  "doc_string": "Check if a sum is `inl` and if so, retrieve its contents. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {ι : Type u_1} {f : ι → α}, Function.Injective f → Pairwise ((fun x x_1 => x ≠ x_1) on f)",
  "name": "Function.Injective.pairwise_ne",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `Function.injective_iff_pairwise_ne`.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {F : Type u_3}\n  [mc : MonoidHomClass F M N] (f : F), Function.Surjective ↑f → MonoidHom.mrange f = ⊤",
  "name": "MonoidHom.mrange_top_of_surjective",
  "kind": "theorem",
  "doc_string":
  "The range of a surjective monoid hom is the whole of the codomain. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → Mathlib.Tactic.Ring.Cache α → Option Q(Ring «$α»)",
  "name": "Mathlib.Tactic.Ring.Cache.rα",
  "kind": "def",
  "doc_string": "A ring instance on `α`, if available. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type u_1} →\n    [inst : LinearOrderedCommRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Neg β] →\n                [inst_6 : Sub β] →\n                  [inst_7 : Pow β ℕ] →\n                    [inst_8 : SMul ℕ β] →\n                      [inst_9 : SMul ℤ β] →\n                        [inst_10 : NatCast β] →\n                          [inst_11 : IntCast β] →\n                            [inst_12 : HasSup β] →\n                              [inst_13 : HasInf β] →\n                                (f : β → α) →\n                                  Function.Injective f →\n                                    f 0 = 0 →\n                                      f 1 = 1 →\n                                        (∀ (x y : β), f (x + y) = f x + f y) →\n                                          (∀ (x y : β), f (x * y) = f x * f y) →\n                                            (∀ (x : β), f (-x) = -f x) →\n                                              (∀ (x y : β), f (x - y) = f x - f y) →\n                                                (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                                  (∀ (x : β) (n : ℤ), f (n • x) = n • f x) →\n                                                    (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                      (∀ (n : ℕ), f ↑n = ↑n) →\n                                                        (∀ (n : ℤ), f ↑n = ↑n) →\n                                                          (∀ (x y : β), f (x ⊔ y) = max (f x) (f y)) →\n                                                            (∀ (x y : β), f (x ⊓ y) = min (f x) (f y)) →\n                                                              LinearOrderedCommRing β",
  "name": "Function.Injective.linearOrderedCommRing",
  "kind": "def",
  "doc_string": "Pullback a `LinearOrderedCommRing` under an injective map. ",
  "args": ""},
 {"type": "{M : Type u_1} → Set M → [inst : Semigroup M] → Subsemigroup M",
  "name": "Subsemigroup.centralizer",
  "kind": "def",
  "doc_string": "The centralizer of a subset of a semigroup `M`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : MulOneClass α] → {r : α} → Invertible r → (s : α) → s = r → Invertible s",
  "name": "Invertible.copy",
  "kind": "def",
  "doc_string": "If `r` is invertible and `s = r`, then `s` is invertible. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddSemigroup",
  "kind": "inductive",
  "doc_string": "An additive semigroup is a type with an associative `(+)`. ",
  "args": ""},
 {"type": "ℚ → ℚ → ℚ",
  "name": "Rat.sub",
  "kind": "def",
  "doc_string": "Subtraction of rational numbers. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {F : Type u_3} → [inst : Zero M] → [inst_1 : Zero N] → [inst_2 : ZeroHomClass F M N] → F → ZeroHom M N",
  "name": "ZeroHomClass.toZeroHom",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `ZeroHomClass F M N` into an actual\n`ZeroHom`. This is declared as the default coercion from `F` to `ZeroHom M N`.",
  "args": ""},
 {"type":
  "∀ {M : Type u_3} {N : Type u_4} {α : Type u_2} {β : Type u_1} [inst : SMul M α] [inst_1 : SMul β α]\n  [inst_2 : SMulCommClass β M α] (g : N → M), SMulCommClass β N α",
  "name": "SMul.comp.smulCommClass'",
  "kind": "theorem",
  "doc_string":
  "This cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables.\n",
  "args": ""},
 {"type":
  "{f : Type u → Type v} → [self : Functor f] → {α β : Type u} → (α → β) → f α → f β",
  "name": "Functor.map",
  "kind": "def",
  "doc_string": "If `f : α → β` and `x : F α` then `f <$> x : F β`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  (c : Order.Frame α) →\n    (le : α → α → Prop) →\n      le = LE.le →\n        (top : α) →\n          top = ⊤ →\n            (bot : α) →\n              bot = ⊥ →\n                (sup : α → α → α) →\n                  sup = HasSup.sup →\n                    (inf : α → α → α) →\n                      inf = HasInf.inf → (Sup : Set α → α) → Sup = supₛ → (Inf : Set α → α) → Inf = infₛ → Order.Frame α",
  "name": "Frame.copy",
  "kind": "def",
  "doc_string":
  "A function to create a provable equal copy of a frame with possibly different definitional\nequalities. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {A : Type u_2} →\n    {B : Type u_3} →\n      [inst : Monoid M] →\n        [inst_1 : Monoid A] →\n          [inst_2 : MulDistribMulAction M A] →\n            [inst_3 : Monoid B] →\n              [inst_4 : SMul M B] →\n                (f : B →* A) →\n                  Function.Injective ↑f → (∀ (c : M) (x : B), ↑f (c • x) = c • ↑f x) → MulDistribMulAction M B",
  "name": "Function.Injective.mulDistribMulAction",
  "kind": "def",
  "doc_string":
  "Pullback a multiplicative distributive multiplicative action along an injective monoid\nhomomorphism.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a < 0 → b ≤ 0 → a + b < 0",
  "name": "Left.add_neg_of_neg_of_nonpos",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_neg_of_neg_of_nonpos`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  Antitone f → Antitone g → Antitone fun x => f x + g x",
  "name": "Antitone.add",
  "kind": "theorem",
  "doc_string": "The sum of two antitone functions is antitone.",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_!=_»",
  "kind": "def",
  "doc_string":
  "`x != y` is boolean not-equal. It is the negation of `x == y` which is supplied by\nthe `BEq` typeclass.\n\nUnlike `x ≠ y` (which is notation for `Ne x y`), this is `Bool` valued instead of\n`Prop` valued. It is mainly intended for programming applications.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Add M] → {S T : AddSubsemigroup M} → S ≤ T → AddHom { x // x ∈ S } { x // x ∈ T }",
  "name": "AddSubsemigroup.inclusion",
  "kind": "def",
  "doc_string":
  "The `AddSemigroup` hom associated to an inclusion of subsemigroups.",
  "args": ""},
 {"type": "Linarith.LinarithConfig → Option Linarith.CertificateOracle",
  "name": "Linarith.LinarithConfig.oracle",
  "kind": "def",
  "doc_string":
  "Specify an oracle for identifying candidate contradictions.\nThe only implementation here is Fourier-Motzkin elimination. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} →\n        [inst : IsTrichotomous α r] → [inst : IsAsymm β s] → (f : α → β) → (∀ (a b : α), r a b → s (f a) (f b)) → r ↪r s",
  "name": "RelEmbedding.ofMonotone",
  "kind": "def",
  "doc_string":
  "It suffices to prove `f` is monotone between strict relations\nto show it is a relation embedding. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : PartialOrder α] → [inst : BoundedOrder α] → α → α → Prop",
  "name": "IsCompl",
  "kind": "inductive",
  "doc_string":
  "Two elements `x` and `y` are complements of each other if `x ⊔ y = ⊤` and `x ⊓ y = ⊥`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_∘_»",
  "kind": "def",
  "doc_string":
  "Function composition is the act of pipelining the result of one function, to the input of another, creating an entirely new function.\nExample:\n```\n#eval Function.comp List.reverse (List.drop 2) [3, 2, 4, 1]\n-- [1, 4]\n```\nYou can use the notation `f ∘ g` as shorthand for `Function.comp f g`.\n```\n#eval (List.reverse ∘ List.drop 2) [3, 2, 4, 1]\n-- [1, 4]\n```\nA simpler way of thinking about it, is that `List.reverse ∘ List.drop 2`\nis equivalent to `fun xs => List.reverse (List.drop 2 xs)`,\nthe benefit is that the meaning of composition is obvious,\nand the representation is compact.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} [inst : EuclideanDomain R] [inst_1 : OrderedSemiring S] {abv : AbsoluteValue R S},\n  AbsoluteValue.IsEuclidean abv → ∀ {x y : R}, ↑abv x < ↑abv y ↔ EuclideanDomain.r x y",
  "name": "AbsoluteValue.IsEuclidean.map_lt_map_iff'",
  "kind": "def",
  "doc_string":
  "The requirement of a Euclidean absolute value\nthat `abv` is monotone with respect to `≺` ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → M ≃+ N → N → M",
  "name": "AddEquiv.Simps.symmApply",
  "kind": "def",
  "doc_string": "See Note custom simps projection",
  "args": ""},
 {"type": "(α : Type u_1) → α × PEmpty ≃ PEmpty",
  "name": "Equiv.prodPEmpty",
  "kind": "def",
  "doc_string":
  "`PEmpty` type is a right absorbing element for type product up to an equivalence. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : AddMonoid α] → CoeHead (AddUnits α) α",
  "name": "AddUnits.instCoeHeadAddUnits",
  "kind": "def",
  "doc_string":
  "An additive unit can be interpreted as a term in the base `AddMonoid`.",
  "args": ""},
 {"type":
  "Type u_1 →\n  (M : outParam (Type u_2)) →\n    (N : outParam (Type u_3)) → [inst : AddZeroClass M] → [inst : AddZeroClass N] → Type (max (max u_1 u_2) u_3)",
  "name": "AddMonoidHomClass",
  "kind": "inductive",
  "doc_string":
  "`AddMonoidHomClass F M N` states that `F` is a type of `AddZeroClass`-preserving\nhomomorphisms.\n\nYou should also extend this typeclass when you extend `AddMonoidHom`.\n",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type u_1} →\n    [inst : StrictOrderedCommRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Neg β] →\n                [inst_6 : Sub β] →\n                  [inst_7 : Pow β ℕ] →\n                    [inst_8 : SMul ℕ β] →\n                      [inst_9 : SMul ℤ β] →\n                        [inst_10 : NatCast β] →\n                          [inst_11 : IntCast β] →\n                            (f : β → α) →\n                              Function.Injective f →\n                                f 0 = 0 →\n                                  f 1 = 1 →\n                                    (∀ (x y : β), f (x + y) = f x + f y) →\n                                      (∀ (x y : β), f (x * y) = f x * f y) →\n                                        (∀ (x : β), f (-x) = -f x) →\n                                          (∀ (x y : β), f (x - y) = f x - f y) →\n                                            (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                              (∀ (x : β) (n : ℤ), f (n • x) = n • f x) →\n                                                (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                  (∀ (n : ℕ), f ↑n = ↑n) →\n                                                    (∀ (n : ℤ), f ↑n = ↑n) → StrictOrderedCommRing β",
  "name": "Function.Injective.strictOrderedCommRing",
  "kind": "def",
  "doc_string": "Pullback a `StrictOrderedCommRing` under an injective map. ",
  "args": ""},
 {"type": "{α : Type u} → {β : α → Type v} → Sigma β → α",
  "name": "Sigma.fst",
  "kind": "def",
  "doc_string":
  "The first component of a dependent pair. If `p : @Sigma α β` then `p.1 : α`. ",
  "args": ""},
 {"type": "{α : Type u} → List α → List α → List α",
  "name": "List.append",
  "kind": "def",
  "doc_string":
  "`O(|xs|)`: append two lists. `[1, 2, 3] ++ [4, 5] = [1, 2, 3, 4, 5]`.\nIt takes time proportional to the first list.\n",
  "args": ""},
 {"type": "Type u → Type (max u (v + 1))",
  "name": "CategoryTheory.Category",
  "kind": "inductive",
  "doc_string":
  "The typeclass `Category C` describes morphisms associated to objects of type `C`.\nThe universe levels of the objects and morphisms are unconstrained, and will often need to be\nspecified explicitly, as `Category.{v} C`. (See also `LargeCategory` and `SmallCategory`.)\n\nSee <https://stacks.math.columbia.edu/tag/0014>.\n",
  "args": ""},
 {"type": "{R : Type u} → [inst : CommSemiring R] → R → R → Prop",
  "name": "IsCoprime",
  "kind": "def",
  "doc_string":
  "The proposition that `x` and `y` are coprime, defined to be the existence of `a` and `b` such\nthat `a * x + b * y = 1`. Note that elements with no common divisors are not necessarily coprime,\ne.g., the multivariate polynomials `x₁` and `x₂` are not coprime. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a - b ≤ 0 → a ≤ b",
  "name": "le_of_sub_nonpos",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `sub_nonpos`.",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (β → α) → (α → β) → Set α → Prop",
  "name": "Set.LeftInvOn",
  "kind": "def",
  "doc_string":
  "`g` is a left inverse to `f` on `a` means that `g (f x) = x` for all `x ∈ a`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → α → List α → List ℕ",
  "name": "List.indexesOf",
  "kind": "def",
  "doc_string":
  "`indexesOf a l` is the list of all indexes of `a` in `l`. For example:\n```\nindexesOf a [a, b, a, a] = [0, 2, 3]\n```\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Ring α] → Ring.TotalPositiveCone α → AddCommGroup.TotalPositiveCone α",
  "name": "Ring.TotalPositiveCone.toTotalPositiveCone",
  "kind": "def",
  "doc_string":
  "Forget that a `TotalPositiveCone` in a ring respects the multiplicative structure. ",
  "args": ""},
 {"type": "{R : Type u} → [inst : NatCast R] → ℕ → R",
  "name": "Nat.cast",
  "kind": "def",
  "doc_string":
  "Canonical homomorphism from `Nat` to a additive monoid `R` with a `1`.\nThis is just the bare function in order to aid in creating instances of `AddMonoidWithOne`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun x x_1 => x ≤ x_1",
  "name": "LinearOrder.decidable_le",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "Type u_1 → Type u_2 → Type (max u_1 u_2)",
  "name": "Bracket",
  "kind": "inductive",
  "doc_string":
  "The `Bracket` class has three intended uses:\n1. for certain binary operations on structures, like the product `⁅x, y⁆` of two elements\n  `x`, `y` in a Lie algebra or the commutator of two elements `x` and `y` in a group.\n2. for certain actions of one structure on another, like the action `⁅x, m⁆` of an element `x`\n  of a Lie algebra on an element `m` in one of its modules (analogous to `SMul` in the\n  associative setting).\n3. for binary operations on substructures, like the commutator `⁅H, K⁆` of two subgroups `H` and\n   `K` of a group. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), min a b = if a ≤ b then a else b",
  "name": "LinearOrderedRing.min_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `minOfLe`. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.RingNF.RingMode",
  "kind": "inductive",
  "doc_string": "The normalization style for `ring_nf`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddSemigroup R] {a b : R}, IsAddLeftRegular (a + b) → IsAddLeftRegular b",
  "name": "IsAddLeftRegular.of_add",
  "kind": "theorem",
  "doc_string":
  "If an element `b` becomes add-left-regular after adding to it on the left\na add-left-regular element, then `b` is add-left-regular.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Semiring α] {a : α}, Odd a → ∃ b, a = bit1 b",
  "name": "Odd.exists_bit1",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `odd_iff_exists_bit1`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : AddGroup α] [inst_1 : SubtractionMonoid β] (f : α →+ β) (a : α), ↑f (-a) = -↑f a",
  "name": "AddMonoidHom.map_neg",
  "kind": "theorem",
  "doc_string": "Additive group homomorphisms preserve negation.",
  "args": ""},
 {"type":
  "{m : Type → Type} → [inst : Lean.MonadMCtx m] → Lean.MVarId → (Lean.LocalContext → Lean.LocalContext) → m Unit",
  "name": "Mathlib.Tactic.modifyLocalContext",
  "kind": "def",
  "doc_string":
  "`modifyLocalContext mvarId f` updates the local context of the metavariable\n`mvarId` with `f`. The new local context must contain the same fvars as the old\nlocal context and the types (and values, if any) of the fvars in the new local\ncontext must be defeq to their equivalents in the old local context.\n\nIf `mvarId` does not refer to a declared metavariable, nothing happens.\n",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.land'",
  "kind": "def",
  "doc_string": "`land'` takes two naturals numbers and returns their `and`",
  "args": ""},
 {"type": "∀ {M : Type u} [self : RightCancelMonoid M] (a : M), 1 * a = a",
  "name": "RightCancelMonoid.one_mul",
  "kind": "def",
  "doc_string": "One is a left neutral element for multiplication ",
  "args": ""},
 {"type":
  "Type u_1 →\n  (M : outParam (Type u_2)) → (N : outParam (Type u_3)) → [inst : Mul M] → [inst : Mul N] → Type (max (max u_1 u_2) u_3)",
  "name": "MulHomClass",
  "kind": "inductive",
  "doc_string":
  "`MulHomClass F M N` states that `F` is a type of multiplication-preserving homomorphisms.\n\nYou should declare an instance of this typeclass when you extend `MulHom`.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] →\n        (f : M →* N) → (N' : Submonoid N) → { x // x ∈ Submonoid.comap f N' } →* { x // x ∈ N' }",
  "name": "MonoidHom.submonoidComap",
  "kind": "def",
  "doc_string": "The `MonoidHom` from the preimage of a submonoid to itself. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s t : Set α},\n  BddAbove s → BddAbove t → Set.Nonempty (s ∩ t) → supₛ (s ∩ t) ≤ supₛ s ⊓ supₛ t",
  "name": "csupₛ_inter_le",
  "kind": "theorem",
  "doc_string":
  "The supremum of an intersection of two sets is bounded by the minimum of the suprema of each\nset, if all sets are bounded above and nonempty.",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} → {u : β → α} → [inst : PartialOrder α] → [inst_1 : Lattice β] → GaloisCoinsertion l u → Lattice α",
  "name": "GaloisCoinsertion.liftLattice",
  "kind": "def",
  "doc_string": "Lift the suprema and infima along a Galois coinsertion ",
  "args": ""},
 {"type":
  "{f : Type u → Type v} → [inst : Functor f] → {α β : Type u} → f β → α → f α",
  "name": "Functor.mapConstRev",
  "kind": "def",
  "doc_string":
  "If `f` is a functor, if `fb : f β` and `a : α`, then `mapConstRev fb a` is the result of\napplying `f.map` to the constant function `β → α` sending everything to `a`, and then\nevaluating at `fb`. In other words it's `const a <$> fb`. ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} {D : Type u₂} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] (F : D ⥤ C)\n  (Y : D), Prefunctor.obj F.toPrefunctor Y ∈ CategoryTheory.Functor.essImage F",
  "name": "CategoryTheory.Functor.obj_mem_essImage",
  "kind": "theorem",
  "doc_string": "An object in the image is in the essential image. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α] (n : ℕ) (a : α),\n  CanonicallyLinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a =\n    a * CanonicallyLinearOrderedSemifield.zpow (Int.ofNat n) a",
  "name": "CanonicallyLinearOrderedSemifield.zpow_succ'",
  "kind": "def",
  "doc_string": "`a ^ (n + 1) = a * a ^ n` ",
  "args": ""},
 {"type":
  "(α : Type u) → (β : Type v) → [inst : PartialOrder α] → [inst : PartialOrder β] → PartialOrder (α × β)",
  "name": "Prod.instPartialOrderProd",
  "kind": "def",
  "doc_string":
  "The pointwise partial order on a product.\n(The lexicographic ordering is defined in `Order.Lexicographic`, and the instances are\navailable via the type synonym `α ×ₗ β = α × β`.) ",
  "args": ""},
 {"type":
  "∀ (G : Type u) [inst : CommSemigroup G] [inst_1 : IsRightCancelMul G], IsLeftCancelMul G",
  "name": "CommSemigroup.IsRightCancelMul.toIsLeftCancelMul",
  "kind": "theorem",
  "doc_string":
  "Any `CommSemigroup G` that satisfies `IsRightCancelMul G` also satisfies\n`IsLeftCancelMul G`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : StrictOrderedSemiring α] {a b c d : α} [inst_1 : ExistsAddOfLE α],\n  a ≤ b → c ≤ d → a * d + b * c ≤ a * c + b * d",
  "name": "mul_add_mul_le_mul_add_mul",
  "kind": "theorem",
  "doc_string": "Binary **rearrangement inequality**. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M →+ N) (a b : M),\n  ↑f (a + b) = ↑f a + ↑f b",
  "name": "AddMonoidHom.map_add",
  "kind": "theorem",
  "doc_string":
  "If `f` is an additive monoid homomorphism then `f (a + b) = f a + f b`. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → {γ : Type u_1} → β → α ⊕ β ⊕ γ",
  "name": "Sum3.in₁",
  "kind": "def",
  "doc_string": "The map from the second summand into a ternary sum. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r : α → α → Prop} [inst : IsRefl α r] [inst : IsAntisymm α r] {a b : α}, AntisymmRel r a b → a = b",
  "name": "AntisymmRel.eq",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `antisymmRel_iff_eq`.",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {φ : α → Sort v} {a a' : α} (h : a = a') (p : φ a), HEq (Eq.recOn h p) p",
  "name": "eq_rec_heq",
  "kind": "theorem",
  "doc_string": "**Alias** of `eqRec_heq`.",
  "args": ""},
 {"type": "Mathlib.Tactic.Polyrith.Poly → Option Mathlib.Tactic.Polyrith.Poly",
  "name": "Mathlib.Tactic.Polyrith.Poly.unNeg?",
  "kind": "def",
  "doc_string":
  "Removes an initial `-` sign from a polynomial with negative leading coefficient. ",
  "args": ""},
 {"type": "Sort u → Sort (max 1 u)",
  "name": "Unique",
  "kind": "inductive",
  "doc_string":
  "`Unique α` expresses that `α` is a type with a unique term `default`.\n\nThis is implemented as a type, rather than a `Prop`-valued predicate,\nfor good definitional properties of the default term. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Zero M] [inst_1 : Zero N] ⦃f g : ZeroHom M N⦄, ↑f = ↑g → f = g",
  "name": "ZeroHom.coe_inj",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.coe_injective` instead.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β},\n  Function.Injective f → ∀ (s : Set β), Set.Nontrivial (f ⁻¹' s) → Set.Nontrivial s",
  "name": "Set.nontrivial_of_preimage",
  "kind": "theorem",
  "doc_string":
  "If the preimage of a set under an injective map is nontrivial, the set is nontrivial. ",
  "args": ""},
 {"type":
  "{V : Type u₁} →\n  [inst : Quiver V] →\n    {W : Type u₂} →\n      [inst_1 : Quiver W] →\n        (F : V ⥤q W) → {a b : V} → Quiver.Path a b → Quiver.Path (Prefunctor.obj F a) (Prefunctor.obj F b)",
  "name": "Prefunctor.mapPath",
  "kind": "def",
  "doc_string": "The image of a path under a prefunctor. ",
  "args": ""},
 {"type": "Stream' ℕ",
  "name": "Stream'.nats",
  "kind": "def",
  "doc_string":
  "The stream of natural numbers: `Stream'.nth n Stream'.nats = n`. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] [inst_1 : SubtractionMonoid H] (h : G ≃+ H) (x y : G),\n  ↑h (x - y) = ↑h x - ↑h y",
  "name": "AddEquiv.map_sub",
  "kind": "theorem",
  "doc_string":
  "An additive equivalence of additive groups preserves subtractions.",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → α ≃ β → Option α ≃ Option β",
  "name": "Equiv.optionCongr",
  "kind": "def",
  "doc_string":
  "A universe-polymorphic version of `EquivFunctor.mapEquiv Option e`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Set α → Set β → Set (α × β)",
  "name": "Set.prod",
  "kind": "def",
  "doc_string":
  "The cartesian product `prod s t` is the set of `(a, b)` such that `a ∈ s` and `b ∈ t`. ",
  "args": ""},
 {"type": "Linarith.Monom → Linarith.Monom → Bool",
  "name": "Linarith.Monom.lt",
  "kind": "def",
  "doc_string":
  "Compare monomials by first comparing their keys and then their powers. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] {a b : α}, b ≤ a → ↑OrderDual.toDual a ≤ ↑OrderDual.toDual b",
  "name": "LE.le.dual",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `OrderDual.toDual_le_toDual`.",
  "args": ""},
 {"type":
  "∀ {p : Prop} {ps : List Prop} (f : Sat.Fmla),\n  Sat.Fmla.proof f [] → (∀ (v : Sat.Valuation), Sat.Valuation.implies v (Sat.Fmla.reify v f p) ps 0) → p",
  "name": "Sat.Fmla.refute",
  "kind": "theorem",
  "doc_string":
  "If `f` is unsatisfiable, and every `v` which agrees with `ps` implies `¬⟦f⟧_v → p`, then `p`.\nEquivalently, there exists a valuation `v` which agrees with `ps`,\nand every such valuation yields `¬⟦f⟧_v` because `f` is unsatisfiable. ",
  "args": ""},
 {"type":
  "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [self : Module R M] (x : M), 0 • x = 0",
  "name": "Module.zero_smul",
  "kind": "def",
  "doc_string": "Scalar multiplication by zero gives zero. ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Semigroup M] → Subsemigroup M",
  "name": "Subsemigroup.center",
  "kind": "def",
  "doc_string":
  "The center of a semigroup `M` is the set of elements that commute with everything in `M` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → {u : β → α} → LowerAdjoint u → α → β",
  "name": "LowerAdjoint.Simps.apply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : IsWeakLowerModularLattice α] {a b : α}, a ⋖ a ⊔ b → b ⋖ a ⊔ b → a ⊓ b ⋖ b",
  "name": "Covby.inf_of_sup_of_sup_right",
  "kind": "theorem",
  "doc_string": "**Alias** of `inf_covby_of_covby_sup_of_covby_sup_right`.",
  "args": ""},
 {"type": "{α : Type u} → [inst : AddMonoid α] → AddUnits α → α",
  "name": "AddUnits.val",
  "kind": "def",
  "doc_string": "The underlying value in the base `AddMonoid`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_>=>_»",
  "kind": "def",
  "doc_string": "Left-to-right composition of Kleisli arrows. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {f g : β → α},\n  AntitoneOn f s → StrictAntiOn g s → StrictAntiOn (fun x => f x + g x) s",
  "name": "AntitoneOn.add_strict_anti",
  "kind": "theorem",
  "doc_string":
  "The sum of a antitone function and a strictly antitone function is\nstrictly antitone.",
  "args": ""},
 {"type":
  "{α : Type} →\n  [inst : BEq α] →\n    {m : Type → Type u_1} →\n      [inst_1 : Monad m] → (α → m Bool) → Aesop.UnorderedArraySet α → m (Aesop.UnorderedArraySet α)",
  "name": "Aesop.UnorderedArraySet.filterM",
  "kind": "def",
  "doc_string": "O(n) ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : MonoidWithZero α] (x : α) [inst_1 : Invertible x], Ring.inverse x = ⅟x",
  "name": "Ring.inverse_invertible",
  "kind": "theorem",
  "doc_string": "A variant of `Ring.inverse_unit`. ",
  "args": ""},
 {"type":
  "∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} (self : X ≅ Y), self.hom ≫ self.inv = 𝟙 X",
  "name": "CategoryTheory.Iso.hom_inv_id",
  "kind": "def",
  "doc_string":
  "Composition of the two directions of an isomorphism is the identity on the source. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : MulZeroClass R] [nR : Nontrivial R], ¬IsRightRegular 0",
  "name": "not_isRightRegular_zero",
  "kind": "theorem",
  "doc_string":
  "In a non-trivial ring, the element `0` is not right-regular -- with typeclasses. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {C : List α → List α → Sort v} →\n    ((is : List α) → C [] is) →\n      ((t : α) → (ts is : List α) → C ts (t :: is) → C is [] → C (t :: ts) is) → (l₁ l₂ : List α) → C l₁ l₂",
  "name": "List.permutationsAux.rec",
  "kind": "def",
  "doc_string":
  "A recursor for pairs of lists. To have `C l₁ l₂` for all `l₁`, `l₂`, it suffices to have it for\n`l₂ = []` and to be able to pour the elements of `l₁` into `l₂`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, a < 0 → b < 0 → a + b < 0",
  "name": "Left.add_neg",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_neg`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLinearOrderBot α] {s : Set α}, BddAbove s → ↑(supₛ s) = ⨆ a, ⨆ h, ↑a",
  "name": "WithTop.coe_supₛ",
  "kind": "theorem",
  "doc_string":
  "A version of `WithTop.coe_supₛ'` with a more convenient but less general statement. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {M : Type u_2} {N : Type u_3} {inst : AddZeroClass M} {inst_1 : AddZeroClass N}\n  [self : AddMonoidHomClass F M N] (f : F), ↑f 0 = 0",
  "name": "AddMonoidHomClass.map_zero",
  "kind": "def",
  "doc_string": "The proposition that the function preserves 0 ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : LinearOrderedCancelCommMonoid M] → (S : Submonoid M) → LinearOrderedCancelCommMonoid { x // x ∈ S }",
  "name": "Submonoid.toLinearOrderedCancelCommMonoid",
  "kind": "def",
  "doc_string":
  "A submonoid of a `LinearOrderedCancelCommMonoid` is a `LinearOrderedCancelCommMonoid`.\n",
  "args": ""},
 {"type":
  "∀ (G : Type u) [inst : AddCommSemigroup G] [inst_1 : IsRightCancelAdd G], IsCancelAdd G",
  "name": "AddCommSemigroup.IsRightCancelAdd.toIsCancelAdd",
  "kind": "theorem",
  "doc_string":
  "Any\n`AddCommSemigroup G` that satisfies `IsRightCancelAdd G` also satisfies\n`IsCancelAdd G`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {s s₁ : Set α} {t t₁ : Set β}, s ×ˢ t ⊆ s₁ ×ˢ t₁ ↔ s ⊆ s₁ ∧ t ⊆ t₁ ∨ s = ∅ ∨ t = ∅",
  "name": "Set.prod_subset_prod_iff",
  "kind": "theorem",
  "doc_string":
  "A product set is included in a product set if and only factors are included, or a factor of the\nfirst set is empty. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  StrictMonoOn f s → StrictMono (Set.restrict s f)",
  "name": "StrictMonoOn.restrict",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `strictMono_restrict`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_4} {α' : Type u_2} {β : Type u_3} {γ : Type u_1} {δ : Type u_5} {s : Set α} {t : Set β} {f : α' → β → γ}\n  {g : α → α'} {f' : α → β → δ} {g' : δ → γ},\n  (∀ (a : α) (b : β), f (g a) b = g' (f' a b)) → Set.image2 f (g '' s) t = g' '' Set.image2 f' s t",
  "name": "Set.image2_image_left_comm",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Set.image_image2_distrib_left`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b c : α}, [[a, c]] ⊆ [[a, b]] ∪ [[b, c]]",
  "name": "Set.interval_subset_interval_union_interval",
  "kind": "theorem",
  "doc_string": "A sort of triangle inequality. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Abs",
  "kind": "inductive",
  "doc_string":
  "Absolute value is a unary operator with properties similar to the absolute value of a real number.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : PredOrder α] [inst_2 : Preorder β] {f : α → β},\n  Antitone f → Pairwise (Disjoint on fun n => Set.Ioo (f n) (f (Order.pred n)))",
  "name": "Antitone.pairwise_disjoint_on_Ioo_pred",
  "kind": "theorem",
  "doc_string":
  "If `α` is a linear pred order, `β` is a preorder, and `f : α → β` is an antitone function, then\nthe intervals `Set.Ioo (f n) (f (Order.pred n))` are pairwise disjoint. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      {δ : Type u_4} →\n        {ε : Type u_5} → {ζ : Type u_6} → (α → β → γ → δ → ε → ζ) → List α → List β → List γ → List δ → List ε → List ζ",
  "name": "List.zipWith₅",
  "kind": "def",
  "doc_string": "Quinary version of `List.zipWith`. ",
  "args": ""},
 {"type": "Lean.Syntax → Lean.Elab.TermElabM Linarith.LinarithConfig",
  "name": "elabLinarithConfig",
  "kind": "def",
  "doc_string": "Allow elaboration of `LinarithConfig` arguments to tactics.\n",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] {p : (g : G₀) → g ≠ 0 → Prop}, (∃ g hg, p g hg) ↔ ∃ g, p ↑g (_ : ↑g ≠ 0)",
  "name": "Units.exists0'",
  "kind": "theorem",
  "doc_string":
  "An alternative version of `Units.exists0`. This one is useful if Lean cannot\nfigure out `p` when using `Units.exists0` from right to left. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : PartialOrder β] {l : α → β} {u : β → α},\n  GaloisConnection l u → ∀ (b : β), (∃ a, b = l a) ↔ b = l (u b)",
  "name": "GaloisConnection.exists_eq_l",
  "kind": "theorem",
  "doc_string":
  "If there exists an `a` such that `b = l a`, then `a = u b` is one such element. ",
  "args": ""},
 {"type":
  "{B : Type u_1} → {E : B → Type u_2} → (b : B) → E b → Bundle.TotalSpace E",
  "name": "Bundle.totalSpaceMk",
  "kind": "def",
  "doc_string": "Constructor for the total space of a bundle. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : AddRightCancelSemigroup α] → [inst : One α] → ComplexShape α",
  "name": "ComplexShape.down",
  "kind": "def",
  "doc_string":
  "The `ComplexShape` appropriate for homology, so `d : X i ⟶ X j` only when `i = j + 1`.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Mul M] → (S : Subsemigroup M) → (s : Set M) → s = ↑S → Subsemigroup M",
  "name": "Subsemigroup.copy",
  "kind": "def",
  "doc_string":
  "Copy a subsemigroup replacing `carrier` with a set that is equal to it. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Add α] → α ≃+ αᵐᵒᵖ",
  "name": "MulOpposite.opAddEquiv",
  "kind": "def",
  "doc_string": "The function `MulOpposite.op` is an additive equivalence. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "NonUnitalRing",
  "kind": "inductive",
  "doc_string": "An associative but not-necessarily unital ring. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosMono α],\n  a ≤ 1 → b < 1 → 0 ≤ b → a * b < 1",
  "name": "Right.mul_lt_one_of_le_of_lt_of_nonneg",
  "kind": "theorem",
  "doc_string": "Assumes right covariance. ",
  "args": ""},
 {"type": "∀ (n e : ℕ), 0 < e → n < 10 ^ e → String.length (Nat.repr n) ≤ e",
  "name": "Nat.repr_length",
  "kind": "theorem",
  "doc_string":
  "The core implementation of `Nat.repr` returns a String with length less than or equal to the\nnumber of digits in the decimal number (represented by `e`). For example, the decimal string\nrepresentation of any number less than 1000 (10 ^ 3) has a length less than or equal to 3. ",
  "args": ""},
 {"type":
  "(R : Type u_1) → (M : Type u_2) → [inst : MonoidWithZero R] → [inst : Zero M] → Type (max u_1 u_2)",
  "name": "MulActionWithZero",
  "kind": "inductive",
  "doc_string":
  "An action of a monoid with zero `R` on a Type `M`, also with `0`, extends `MulAction` and\nis compatible with `0` (both in `R` and in `M`), with `1 ∈ R`, and with associativity of\nmultiplication on the monoid `M`. ",
  "args": ""},
 {"type": "{α : Type u_1} → α ≃ αᵐᵒᵖ",
  "name": "MulOpposite.opEquiv",
  "kind": "def",
  "doc_string": "The canonical bijection between `α` and `αᵐᵒᵖ`. ",
  "args": ""},
 {"type":
  "Array (Array ℤ) →\n  Lean.Expr →\n    ℕ →\n      ℕ →\n        Lean.Expr →\n          Lean.Expr → ℕ × Std.HashMap ℕ Mathlib.Tactic.Sat.Clause → ℕ × Std.HashMap ℕ Mathlib.Tactic.Sat.Clause",
  "name": "Mathlib.Tactic.Sat.buildClauses",
  "kind": "opaque",
  "doc_string":
  "Constructs the proofs of `⊢ ctx.proof c` for each clause `c` in `ctx`.\nThe proofs are stashed in a `HashMap` keyed on the clause ID. ",
  "args": ""},
 {"type": "ℤ → Option ℕ",
  "name": "Int.toNat'",
  "kind": "def",
  "doc_string":
  "* If `n : Nat`, then `int.toNat' n = some n`\n* If `n : Int` is negative, then `int.toNat' n = none`.\n",
  "args": ""},
 {"type": "∀ {α : Type u_1} [inst : Ring α] {a b : α}, a ∣ a + b ↔ a ∣ b",
  "name": "dvd_add_self_left",
  "kind": "theorem",
  "doc_string":
  "An element a divides the sum a + b if and only if a divides b.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : DistribLattice α] →\n    [inst_1 : BoundedOrder α] → (compl : α → α) → (∀ (a b c : α), a ≤ compl b ⊔ c ↔ a ⊓ b ≤ c) → HeytingAlgebra α",
  "name": "HeytingAlgebra.ofCompl",
  "kind": "def",
  "doc_string":
  "Construct a Heyting algebra from the lattice structure and complement operator alone. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a : α}, a < 1 → 1 < a⁻¹",
  "name": "one_lt_inv_of_inv",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `Left.one_lt_inv_iff`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : GCDMonoid α] (a : α), lcm 0 a = 0",
  "name": "GCDMonoid.lcm_zero_left",
  "kind": "def",
  "doc_string": "`0` is left-absorbing. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  {D : Type u₂} →\n    [inst : CategoryTheory.Category C] →\n      [inst_1 : CategoryTheory.Category D] →\n        (F : C ⥤ D) →\n          [inst_2 : CategoryTheory.EssSurj F] →\n            (Y : D) → Prefunctor.obj F.toPrefunctor (CategoryTheory.Functor.objPreimage F Y) ≅ Y",
  "name": "CategoryTheory.Functor.objObjPreimageIso",
  "kind": "def",
  "doc_string":
  "Applying an essentially surjective functor to a preimage of `Y` yields an object that is\nisomorphic to `Y`. ",
  "args": ""},
 {"type":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [inst : NonUnitalNonAssocSemiring α] →\n        [inst_1 : NonUnitalNonAssocSemiring β] → [inst_2 : NonUnitalRingHomClass F α β] → CoeTC F (α →ₙ+* β)",
  "name": "instCoeTCNonUnitalRingHom",
  "kind": "def",
  "doc_string":
  "Any type satisfying `NonUnitalRingHomClass` can be cast into `NonUnitalRingHom` via\n`NonUnitalRingHomClass.toNonUnitalRingHom`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1],\n  StrictAnti f → StrictAnti g → StrictAnti fun x => f x + g x",
  "name": "StrictAnti.add",
  "kind": "theorem",
  "doc_string":
  "The sum of two strictly antitone functions is strictly antitone.",
  "args": ""},
 {"type": "TwoPointing Bool",
  "name": "TwoPointing.bool",
  "kind": "def",
  "doc_string": "The `false`, `true` two-pointing of `Bool`. ",
  "args": ""},
 {"type": "{p q : Prop} → [inst : Decidable p] → (p ↔ q) → Decidable q",
  "name": "decidable_of_decidable_of_iff",
  "kind": "def",
  "doc_string":
  "Transfer a decidability proof across an equivalence of propositions. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] (a : α), supₛ {a} = a",
  "name": "csupₛ_singleton",
  "kind": "theorem",
  "doc_string": "The supremum of a singleton is the element of the singleton",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Add α] → [inst_1 : Add β] → αᵃᵒᵖ ≃+ βᵃᵒᵖ ≃ (α ≃+ β)",
  "name": "AddEquiv.unop",
  "kind": "def",
  "doc_string":
  "The 'unopposite' of an iso `αᵃᵒᵖ ≃+ βᵃᵒᵖ`. Inverse to `AddEquiv.op`.",
  "args": ""},
 {"type": "{α : Type u} → [self : Inv α] → α → α",
  "name": "Inv.inv",
  "kind": "def",
  "doc_string": "Invert an element of α. ",
  "args": ""},
 {"type": "ℤ → ℤ → ℤ",
  "name": "Int.land",
  "kind": "def",
  "doc_string": "`land` takes two integers and returns their bitwise `and`",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : MulOneClass M] → (S : Submonoid M) → Mul { x // x ∈ S }",
  "name": "Submonoid.mul",
  "kind": "def",
  "doc_string": "A submonoid of a monoid inherits a multiplication. ",
  "args": ""},
 {"type": "{α : Type u_1} → Set αᵒᵖ → Set α",
  "name": "Set.unop",
  "kind": "def",
  "doc_string":
  "The unop of a set `s` is the set obtained by taking the unop of each member of `s`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type u_1} →\n    [inst : LinearOrderedSemiring α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Pow β ℕ] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : NatCast β] →\n                    [inst_8 : HasSup β] →\n                      [inst_9 : HasInf β] →\n                        (f : β → α) →\n                          Function.Injective f →\n                            f 0 = 0 →\n                              f 1 = 1 →\n                                (∀ (x y : β), f (x + y) = f x + f y) →\n                                  (∀ (x y : β), f (x * y) = f x * f y) →\n                                    (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                      (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                        (∀ (n : ℕ), f ↑n = ↑n) →\n                                          (∀ (x y : β), f (x ⊔ y) = max (f x) (f y)) →\n                                            (∀ (x y : β), f (x ⊓ y) = min (f x) (f y)) → LinearOrderedSemiring β",
  "name": "Function.Injective.linearOrderedSemiring",
  "kind": "def",
  "doc_string": "Pullback a `LinearOrderedSemiring` under an injective map. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} [inst : Group G] (a x : G), SemiconjBy a x (a * x * a⁻¹)",
  "name": "SemiconjBy.conj_mk",
  "kind": "theorem",
  "doc_string": "`a` semiconjugates `x` to `a * x * a⁻¹`. ",
  "args": ""},
 {"type": "{K : Type u_1} → [inst : RatCast K] → CoeTC ℚ K",
  "name": "Rat.castCoe",
  "kind": "def",
  "doc_string":
  "Construct the canonical injection from `ℚ` into an arbitrary\ndivision ring. If the field has positive characteristic `p`,\nwe define `1 / p = 1 / 0 = 0` for consistency with our\ndivision by zero convention. ",
  "args": ""},
 {"type": "∀ {M : Type u} [self : Monoid M] (a : M), 1 * a = a",
  "name": "Monoid.one_mul",
  "kind": "def",
  "doc_string": "One is a left neutral element for multiplication ",
  "args": ""},
 {"type":
  "{α₁ : Type u_1} →\n  {α₂ : Type u_2} → {β : α₁ → Type u_3} → (f : α₁ ≃ α₂) → (a : α₁) × β a ≃ (a : α₂) × β (↑(Equiv.symm f) a)",
  "name": "Equiv.sigmaCongrLeft'",
  "kind": "def",
  "doc_string": "Transporting a sigma type through an equivalence of the base ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⊂_»",
  "kind": "def",
  "doc_string": "Strict subset relation: `a ⊂ b`  ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Tactic.Alias.alias",
  "kind": "def",
  "doc_string": "Adds some copies of a theorem or definition. ",
  "args": ""},
 {"type":
  "∀ (R : Type u_1) (M : Type u_2) [inst : Semiring R] [inst_1 : Nontrivial M] [inst_2 : AddCommMonoid M]\n  [inst : Module R M], Nontrivial R",
  "name": "Module.nontrivial",
  "kind": "theorem",
  "doc_string":
  "A semiring is `Nontrivial` provided that there exists a nontrivial module over this semiring. ",
  "args": ""},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "name": "SeqLeft",
  "kind": "inductive",
  "doc_string":
  "The typeclass which supplies the `<*` \"seqLeft\" function. See `Applicative`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«tacticExistsi_,,»",
  "kind": "def",
  "doc_string":
  "`existsi e₁, e₂, ⋯` applies the tactic `refine ⟨e₁, e₂, ⋯, ?_⟩`. It's purpose is to instantiate\nexistential quantifiers.\n\nExamples:\n\n```lean\nexample : ∃ x : Nat, x = x := by\n  existsi 42\n  rfl\n\nexample : ∃ x : Nat, ∃ y : Nat, x = y := by\n  existsi 42, 42\n  rfl\n```\n",
  "args": ""},
 {"type":
  "(α : Type u_1) →\n  (β : Type u_2) →\n    (γ : Type u_3) → [inst : LE α] → [inst_1 : LE β] → [inst_2 : LE γ] → Lex (Lex (α ⊕ β) ⊕ γ) ≃o Lex (α ⊕ Lex (β ⊕ γ))",
  "name": "OrderIso.sumLexAssoc",
  "kind": "def",
  "doc_string": "`Equiv.SumAssoc` promoted to an order isomorphism. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "name": "LE.le.lt_of_ne",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_le_of_ne`.",
  "args": ""},
 {"type": "(Type u → Type v) → Type (u + 1)",
  "name": "CategoryTheory.KleisliCat",
  "kind": "def",
  "doc_string":
  "The Kleisli category on the (type-)monad `m`. Note that the monad is not assumed to be lawful\nyet. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      (e : Q(«$α»)) → Mathlib.Tactic.Ring.RingM (Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExSum sα) e)",
  "name": "Mathlib.Tactic.Ring.evalAtom",
  "kind": "def",
  "doc_string":
  "Evaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n",
  "args": ""},
 {"type": "{α : Type u} → [inst : Monoid α] → α → Set α",
  "name": "conjugatesOf",
  "kind": "def",
  "doc_string":
  "Given an element `a`, `conjugatesOf a` is the set of conjugates. ",
  "args": ""},
 {"type": "{α : Type u} → [self : LinearOrderedRing α] → DecidableEq α",
  "name": "LinearOrderedRing.decidable_eq",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Inhabited α] → List α → α",
  "name": "List.ilast",
  "kind": "def",
  "doc_string": "The last element of a list, with the default if list empty ",
  "args": ""},
 {"type": "Sort u → outParam (Sort v) → Sort (max (max 1 u) v)",
  "name": "CoeSort",
  "kind": "inductive",
  "doc_string":
  "`CoeSort α β` is a coercion to a sort. `β` must be a universe, and if\n`a : α` appears in a place where a type is expected, like `(x : a)` or `a → a`,\nthen it will be turned into `(x : CoeSort.coe a)`.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u₁} [inst : LinearOrderedRing R] {a : R}, -2 ≤ a → ∀ (n : ℕ), 1 + ↑n * a ≤ (1 + a) ^ n",
  "name": "one_add_mul_le_pow",
  "kind": "theorem",
  "doc_string": "Bernoulli's inequality for `n : ℕ`, `-2 ≤ a`. ",
  "args": ""},
 {"type": "(B : Type u_1) → Type u_2 → B → Type u_2",
  "name": "Bundle.Trivial",
  "kind": "def",
  "doc_string":
  "`Bundle.Trivial B F` is the trivial bundle over `B` of fiber `F`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → AddHom M N → AddHom (WithTop M) (WithTop N)",
  "name": "AddHom.withTopMap",
  "kind": "def",
  "doc_string": "A version of `WithTop.map` for `AddHom`s. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Mul M] {s : Set M} {p : M → Prop} {x : M},\n  x ∈ Subsemigroup.closure s → (∀ (x : M), x ∈ s → p x) → (∀ (x y : M), p x → p y → p (x * y)) → p x",
  "name": "Subsemigroup.closure_induction",
  "kind": "theorem",
  "doc_string":
  "An induction principle for closure membership. If `p` holds for all elements of `s`, and\nis preserved under multiplication, then `p` holds for all elements of the closure of `s`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {ι : Type u_2} →\n    {β : Type u_3} →\n      (S : ι → Set α) →\n        (f : (i : ι) → ↑(S i) → β) →\n          (∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j),\n              f i { val := x, property := hxi } = f j { val := x, property := hxj }) →\n            (T : Set α) → T ⊆ Set.unionᵢ S → ↑T → β",
  "name": "Set.unionᵢLift",
  "kind": "def",
  "doc_string":
  "Given a union of sets `unionᵢ S`, define a function on the Union by defining\nit on each component, and proving that it agrees on the intersections. ",
  "args": ""},
 {"type": "ZNum → ZNum → ZNum",
  "name": "ZNum.mul",
  "kind": "def",
  "doc_string": "Multiplication of `ZNum`s. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → M →* M × N",
  "name": "MonoidHom.inl",
  "kind": "def",
  "doc_string":
  "Given monoids `M`, `N`, the natural inclusion homomorphism from `M` to `M × N`. ",
  "args": ""},
 {"type":
  "{f : Type u → Type v} → [self : Seq f] → {α β : Type u} → f (α → β) → (Unit → f α) → f β",
  "name": "Seq.seq",
  "kind": "def",
  "doc_string":
  "If `mf : F (α → β)` and `mx : F α`, then `mf <*> mx : F β`.\nIn a monad this is the same as `do let f ← mf; x ← mx; pure (f x)`:\nit evaluates first the function, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a\n`Unit → f α` function. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {ι : Sort u_1} [inst : ConditionallyCompleteLattice α] [inst_1 : Nonempty ι] {f : ι → α} {c : α},\n  (∀ (x : ι), c ≤ f x) → c ≤ infᵢ f",
  "name": "le_cinfᵢ",
  "kind": "theorem",
  "doc_string":
  "The indexed minimum of a function is bounded below by a uniform lower bound",
  "args": ""},
 {"type": "{α : Type u} → [inst : AddMonoid α] → Neg (AddUnits α)",
  "name": "AddUnits.instNegAddUnits",
  "kind": "def",
  "doc_string": "The additive inverse of an additive unit in an `AddMonoid`.",
  "args": ""},
 {"type": "Sat.Literal → Sat.Literal",
  "name": "Sat.Literal.negate",
  "kind": "def",
  "doc_string": "Swap the polarity of a literal. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "commandSudoSet_option__",
  "kind": "def",
  "doc_string":
  "The command `sudo set_option name val` is similar to `set_option name val`,\nbut it also allows to set undeclared options.\n",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₂] →\n      [inst_1 : One M₂] →\n        [inst_2 : Pow M₂ ℕ] →\n          [inst_3 : Inv M₂] →\n            [inst_4 : Div M₂] →\n              [inst_5 : Pow M₂ ℤ] →\n                [inst_6 : CommGroup M₁] →\n                  (f : M₁ → M₂) →\n                    Function.Surjective f →\n                      f 1 = 1 →\n                        (∀ (x y : M₁), f (x * y) = f x * f y) →\n                          (∀ (x : M₁), f x⁻¹ = (f x)⁻¹) →\n                            (∀ (x y : M₁), f (x / y) = f x / f y) →\n                              (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                (∀ (x : M₁) (n : ℤ), f (x ^ n) = f x ^ n) → CommGroup M₂",
  "name": "Function.Surjective.commGroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `1`, `*`, `⁻¹`, and `/` is a commutative group, if it admits a surjective\nmap that preserves `1`, `*`, `⁻¹`, and `/` from a commutative group. See note\n[reducible non-instances]. ",
  "args": ""},
 {"type":
  "{M : Type u → Type v} → [inst : Monad M] → {ω : Type u} → ω → (ω → ω → ω) → Monad (WriterT ω M)",
  "name": "WriterT.monad",
  "kind": "def",
  "doc_string":
  "Creates an instance of Monad, with an explicitly given empty and append operation.\n\nPreviously, this would have used an instance of `[Monoid ω]` as input.\nIn practice, however, WriterT is used for logging and creating lists so restricting to\nmonoids with `Mul` and `One` can make `WriterT` cumbersome to use.\n\nThis is used to derive instances for both `[EmptyCollection ω] [Append ω]` and `[Monoid ω]`.\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_→*₀_»",
  "kind": "def",
  "doc_string":
  "`M →*₀ N` denotes the type of zero-preserving monoid homomorphisms from `M` to `N`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b⁻¹ → b ≤ a⁻¹",
  "name": "le_inv_of_le_inv",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `le_inv'`.",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Monoid M] → (S : Submonoid M) → Monoid { x // x ∈ S }",
  "name": "Submonoid.toMonoid",
  "kind": "def",
  "doc_string": "A submonoid of a monoid inherits a monoid structure. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} {a : R} [inst : Monoid R] [inst_1 : MulAction R M] {n : ℕ},\n  0 < n → (IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a)",
  "name": "IsSMulRegular.pow_iff",
  "kind": "theorem",
  "doc_string":
  "An element `a` is `M`-regular if and only if a positive power of `a` is `M`-regular. ",
  "args": ""},
 {"type":
  "{α : Sort u} →\n  {β : Sort v} → {r : α → α → Prop} → (e : α ≃ β) → Quot r ≃ Quot fun b b' => r (↑(Equiv.symm e) b) (↑(Equiv.symm e) b')",
  "name": "Quot.congrLeft",
  "kind": "def",
  "doc_string":
  "An equivalence `e : α ≃ β` generates an equivalence between the quotient space of `α`\nby a relation `ra` and the quotient space of `β` by the image of this relation under `e`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedAddMonoid α] {a b : α}, a ≤ b → ∃ c, b = a + c",
  "name": "CanonicallyOrderedAddMonoid.exists_add_of_le",
  "kind": "def",
  "doc_string": "For `a ≤ b`, there is a `c` so `b = a + c`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Preorder α] → (cmp : α → α → Ordering) → (∀ (a b : α), Ordering.Compares (cmp a b) a b) → LinearOrder α",
  "name": "linearOrderOfCompares",
  "kind": "def",
  "doc_string":
  "Generate a linear order structure from a preorder and `cmp` function. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Type u_2} {s : Set α},\n  Set.Nonempty s → ∀ {f : α → ι}, (Set.Pairwise s fun x y => f x = f y) ↔ ∃ z, ∀ (x : α), x ∈ s → f x = z",
  "name": "Set.Nonempty.pairwise_eq_iff_exists_eq",
  "kind": "theorem",
  "doc_string":
  "For a nonempty set `s`, a function `f` takes pairwise equal values on `s` if and only if\nfor some `z` in the codomain, `f` takes value `z` on all `x ∈ s`. See also\n`Set.pairwise_eq_iff_exists_eq` for a version that assumes `[Nonempty ι]` instead of\n`Set.Nonempty s`. ",
  "args": ""},
 {"type": "{α : Type u} → [self : EmptyCollection α] → α",
  "name": "EmptyCollection.emptyCollection",
  "kind": "def",
  "doc_string":
  "`∅` or `{}` is the empty set or empty collection.\nIt is supported by the `EmptyCollection` typeclass. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → {γ : Type u_3} → {δ : Type u_4} → {ε : Type u_5} → (γ → δ → ε) → (α → γ) → (β → δ) → α → β → ε",
  "name": "Function.bicompl",
  "kind": "def",
  "doc_string":
  "Compose a binary function `f` with a pair of unary functions `g` and `h`.\nIf both arguments of `f` have the same type and `g = h`, then `bicompl f g g = f on g`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {α : Type u_3} [inst : Preorder α] [inst_1 : Preorder N] {f : N → α}\n  [inst_2 : CovariantClass M N μ fun x x_1 => x ≤ x_1], Antitone f → ∀ (m : M), Antitone fun n => f (μ m n)",
  "name": "Antitone.covariant_of_const",
  "kind": "theorem",
  "doc_string": "Dual of `monotone.covariant_of_const` ",
  "args": ""},
 {"type":
  "{G₀ : Type u_1} → [inst : GroupWithZero G₀] → (a : G₀) → a ≠ 0 → G₀ˣ",
  "name": "Units.mk0",
  "kind": "def",
  "doc_string":
  "Embed a non-zero element of a `GroupWithZero` into the unit group.\nBy combining this function with the operations on units,\nor the `/ₚ` operation, it is possible to write a division\nas a partial function with three arguments. ",
  "args": ""},
 {"type": "{p q : Prop} → [inst : Decidable p] → p = q → Decidable q",
  "name": "decidable_of_decidable_of_eq",
  "kind": "def",
  "doc_string":
  "Transfer a decidability proof across an equality of propositions. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α),\n  Set.MapsTo f (Function.fixedPoints (g ∘ f)) (Function.fixedPoints (f ∘ g))",
  "name": "Function.mapsTo_fixedPoints_comp",
  "kind": "theorem",
  "doc_string":
  "Any map `f` sends fixed points of `g ∘ f` to fixed points of `f ∘ g`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, IsMax a → a = ⊤",
  "name": "IsMax.eq_top",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `isMax_iff_eq_top`.",
  "args": ""},
 {"type":
  "∀ {f : Type u₀ → Type u₁} [self : EquivFunctor f] (α : Type u₀), EquivFunctor.map (Equiv.refl α) = id",
  "name": "EquivFunctor.map_refl'",
  "kind": "def",
  "doc_string": "`map` of `f` preserves the identity morphism. ",
  "args": ""},
 {"type": "Linarith.PComp → ℕ → Linarith.PComp",
  "name": "Linarith.PComp.scale",
  "kind": "def",
  "doc_string":
  "`PComp.scale c n` scales the coefficients of `c` by `n` and notes this in the `CompSource`. ",
  "args": ""},
 {"type":
  "(n : ℕ+) → {p : ℕ+ → Sort u_1} → p 1 → ((n : ℕ+) → p n → p (n + 1)) → p n",
  "name": "PNat.recOn",
  "kind": "def",
  "doc_string":
  "An induction principle for `ℕ+`: it takes values in `Sort*`, so it applies also to Types,\nnot only to `Prop`. ",
  "args": ""},
 {"type": "(G : Type u_1) → [inst : SubtractionCommMonoid G] → G ≃+ G",
  "name": "AddEquiv.neg",
  "kind": "def",
  "doc_string":
  "When the `AddGroup` is commutative, `Equiv.neg` is an `AddEquiv`.",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "name": "ContravariantClass",
  "kind": "inductive",
  "doc_string":
  "Given an action `μ` of a Type `M` on a Type `N` and a relation `r` on `N`, informally, the\n`ContravariantClass` says that \"if the result of the action `μ` on a pair satisfies the\nrelation `r`, then the initial pair satisfied the relation `r`.\"\n\nMore precisely, the `ContravariantClass` is a class taking two Types `M N`, together with an\n\"action\" `μ : M → N → N` and a relation `r : N → N → Prop`.  Its unique field `elim` is the\nassertion that for all `m ∈ M` and all elements `n₁, n₂ ∈ N`, if the relation `r` holds for the\npair `(μ m n₁, μ m n₂)` obtained from `(n₁, n₂)` by acting upon it by `m`, then, the relation\n`r` also holds for the pair `(n₁, n₂)`.\n\nIf `m : M` and `h : r (μ m n₁) (μ m n₂)`, then `ContravariantClass.elim m h : r n₁ n₂`.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term⅟_»",
  "kind": "def",
  "doc_string": "The inverse of an `Invertible` element ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α → Id (List α × List α)",
  "name": "List.transpose.pop",
  "kind": "def",
  "doc_string":
  "`pop : List α → StateM (List α) (List α)` transforms the input list `old`\nby taking the head of the current state and pushing it on the head of `old`.\nIf the state list is empty, then `old` is left unchanged. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {l : List α}, List.Nodup (List.attach l) → List.Nodup l",
  "name": "List.Nodup.of_attach",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `List.nodup_attach`.",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : MulOneClass M] → {S T : Submonoid M} → S ≤ T → { x // x ∈ S } →* { x // x ∈ T }",
  "name": "Submonoid.inclusion",
  "kind": "def",
  "doc_string": "The monoid hom associated to an inclusion of submonoids. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β),\n  0 = 1 ↔ ∀ (x_2 : α), ↑f x_2 = 0",
  "name": "RingHom.codomain_trivial_iff_range_trivial",
  "kind": "theorem",
  "doc_string":
  "`f : α →+* β` has a trivial codomain iff it has a trivial range. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ c → (a ∣ b + c ↔ a ∣ b)",
  "name": "dvd_add_left",
  "kind": "theorem",
  "doc_string":
  "If an element a divides another element c in a commutative ring, a divides the sum of another\nelement b with c iff a divides b. ",
  "args": ""},
 {"type": "(α : Type u_1) → Option α ≃ α ⊕ PUnit",
  "name": "Equiv.optionEquivSumPUnit",
  "kind": "def",
  "doc_string": "`Option α` is equivalent to `α ⊕ punit` ",
  "args": ""},
 {"type": "(α : Type u) → [inst : Add α] → [inst : LE α] → Prop",
  "name": "ExistsAddOfLE",
  "kind": "inductive",
  "doc_string":
  "An `OrderAddCommMonoid` with one-sided 'subtraction' in the sense that\nif `a ≤ b`, then there is some `c` for which `a + c = b`. This is a weaker version\nof the condition on canonical orderings defined by `CanonicallyOrderedAddMonoid`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} → [inst : NonUnitalCommRing R] → [inst : NonUnitalCommRing S] → NonUnitalCommRing (R × S)",
  "name": "Prod.instNonUnitalCommRingProd",
  "kind": "def",
  "doc_string":
  "Product of two `NonUnitalCommRing`s is a `NonUnitalCommRing`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_ᵒᵈ»",
  "kind": "def",
  "doc_string":
  "Type synonym to equip a type with the dual order: `≤` means `≥` and `<` means `>`. `αᵒᵈ` is\nnotation for `OrderDual α`. ",
  "args": ""},
 {"type": "(α β : Type u) → α ⊕ β ≃ (b : Bool) × bif b then α else β",
  "name": "Equiv.sumEquivSigmaBool",
  "kind": "def",
  "doc_string":
  "`α ⊕ β` is equivalent to a `Sigma`-type over `Bool`. Note that this definition assumes `α` and\n`β` to be types from the same universe, so it cannot by used directly to transfer theorems about\nsigma types to theorems about sum types. In many cases one can use `ulift` to work around this\ndifficulty. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : PartialOrder α] →\n    (f : α → α) →\n      (p : α → Prop) →\n        (∀ (x : α), x ≤ f x) → (∀ (x : α), p (f x)) → (∀ ⦃x y : α⦄, x ≤ y → p y → f x ≤ y) → ClosureOperator α",
  "name": "ClosureOperator.mk₃",
  "kind": "def",
  "doc_string":
  "Expanded out version of `mk₂`. `p` implies being closed. This constructor should be used when\nyou already know a sufficient condition for being closed and using `mem_mk₃_closed` will avoid you\nthe (slight) hassle of having to prove it both inside and outside the constructor. ",
  "args": ""},
 {"type": "(α : Type u_1) → (Bool → α) ≃ α × α",
  "name": "Equiv.boolArrowEquivProd",
  "kind": "def",
  "doc_string": "The function type `Bool → α` is equivalent to `α × α`. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a",
  "name": "AddCommute.symm",
  "kind": "theorem",
  "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`.",
  "args": ""},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "name": "Coe",
  "kind": "inductive",
  "doc_string":
  "`Coe α β` is the typeclass for coercions from `α` to `β`. It can be transitively\nchained with other `Coe` instances, and coercion is automatically used when\n`x` has type `α` but it is used in a context where `β` is expected.\nYou can use the `↑x` operator to explicitly trigger coercion.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → List α → List β → List (α × Option β) × List β",
  "name": "List.zipLeft'",
  "kind": "def",
  "doc_string":
  "Left-biased version of `List.zip`. `zipLeft' as bs` returns the list of\npairs `(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, the\nremaining `aᵢ` are paired with `none`. Also returns the remaining `bs`.\n```\nzipLeft' [1, 2] ['a'] = ([(1, some 'a'), (2, none)], [])\nzipLeft' [1] ['a', 'b'] = ([(1, some 'a')], ['b'])\nzipLeft' = zipWithLeft' prod.mk\n```\n",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.Comp",
  "kind": "inductive",
  "doc_string":
  "The main datatype for FM elimination.\nVariables are represented by natural numbers, each of which has an integer coefficient.\nIndex 0 is reserved for constants, i.e. `coeffs.find 0` is the coefficient of 1.\nThe represented term is `coeffs.sum (λ ⟨k, v⟩, v * Var[k])`.\nstr determines the strength of the comparison -- is it < 0, ≤ 0, or = 0?\n",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Mul M] → AddSubsemigroup (Additive M) ≃o Subsemigroup M",
  "name": "AddSubsemigroup.toSubsemigroup'",
  "kind": "def",
  "doc_string":
  "Additive subsemigroups of an additive semigroup `Additive M` are isomorphic to subsemigroups\nof `M`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Monoid α] {a b : α} {u : αˣ}, a * ↑u ∣ b ↔ a ∣ b",
  "name": "Units.mul_right_dvd",
  "kind": "theorem",
  "doc_string":
  "In a monoid, an element `a` divides an element `b` iff all associates of `a` divide `b`. ",
  "args": ""},
 {"type":
  "{α β : Type u} → {r : α → α → Prop} → {s : β → β → Prop} → α = β → HEq r s → r ≃r s",
  "name": "RelIso.cast",
  "kind": "def",
  "doc_string":
  "A relation isomorphism between equal relations on equal types. ",
  "args": ""},
 {"type": "ℤ → ℤ",
  "name": "Int.lnot",
  "kind": "def",
  "doc_string":
  "`lnot` flips all the bits in the binary representation of its input ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Ring α] → [inst_1 : Nontrivial α] → Ring.PositiveCone α → StrictOrderedRing α",
  "name": "StrictOrderedRing.mkOfPositiveCone",
  "kind": "def",
  "doc_string":
  "Construct a `StrictOrderedRing` by designating a positive cone in an existing `Ring`. ",
  "args": ""},
 {"type": "{α : Sort u} → α ≃ αᵒᵖ",
  "name": "Opposite.equivToOpposite",
  "kind": "def",
  "doc_string": "The type-level equivalence between a type and its opposite. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosMono α],\n  1 ≤ a → 1 ≤ b → 0 ≤ b → 1 ≤ a * b",
  "name": "Right.one_le_mul_of_le_of_le",
  "kind": "theorem",
  "doc_string": "Assumes right covariance. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, 0 ≤ a → -a ≤ a",
  "name": "neg_le_self",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.neg_le_self`.",
  "args": ""},
 {"type": "(α : Type u) → [inst : LE α] → Type u",
  "name": "OrderBot",
  "kind": "inductive",
  "doc_string":
  "An order is an `OrderBot` if it has a least element.\nWe state this using a data mixin, holding the value of `⊥` and the least element constraint. ",
  "args": ""},
 {"type": "Type",
  "name": "StdGen",
  "kind": "inductive",
  "doc_string": "\"Standard\" random number generator. ",
  "args": ""},
 {"type": "{α : Type u} → [self : Div α] → α → α → α",
  "name": "Div.div",
  "kind": "def",
  "doc_string":
  "`a / b` computes the result of dividing `a` by `b`. See `HDiv`. ",
  "args": ""},
 {"type": "{α : Type u_1} → Option (Option α) → Option α",
  "name": "Option.join",
  "kind": "def",
  "doc_string":
  "Flatten an `Option` of `Option`, a specialization of `joinM`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : SemilatticeSup β] {f g : α → β} {s : Set α},\n  AntitoneOn f s → AntitoneOn g s → AntitoneOn (f ⊔ g) s",
  "name": "AntitoneOn.sup",
  "kind": "theorem",
  "doc_string":
  "Pointwise supremum of two antitone functions is a antitone function. ",
  "args": ""},
 {"type":
  "∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\n  [self : RingHomSurjective σ], Function.Surjective ↑σ",
  "name": "RingHomSurjective.is_surjective",
  "kind": "def",
  "doc_string": "The ring homomorphism is surjective ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRightRegular (b * a) → IsRightRegular b",
  "name": "IsRightRegular.of_mul",
  "kind": "theorem",
  "doc_string":
  "If an element `b` becomes right-regular after multiplying it on the right by a right-regular\nelement, then `b` is right-regular. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [inst_3 : OrderedSub α] {a b : α},\n  a + b - a ≤ b",
  "name": "add_tsub_le_left",
  "kind": "theorem",
  "doc_string":
  "See `add_tsub_cancel_left` for the equality if `ContravariantClass α α (+) (≤)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] {a : α}, IsBot a → IsTop (↑OrderDual.toDual a)",
  "name": "IsBot.toDual",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `isTop_toDual_iff`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : DivisionSemiring α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "name": "DivisionSemiring.mul_inv_cancel",
  "kind": "def",
  "doc_string": "Every nonzero element of a group with zero is invertible. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} (self : r ↪r s) {a b : α},\n  s (↑self.toEmbedding a) (↑self.toEmbedding b) ↔ r a b",
  "name": "RelEmbedding.map_rel_iff'",
  "kind": "def",
  "doc_string":
  "Elements are related iff they are related after apply a `RelEmbedding` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {ι : Sort u_1} [inst : ConditionallyCompleteLinearOrder α] {b : α} [inst_1 : Nonempty ι] {f : ι → α},\n  b < supᵢ f → ∃ i, b < f i",
  "name": "exists_lt_of_lt_csupᵢ",
  "kind": "theorem",
  "doc_string":
  "Indexed version of the above lemma `exists_lt_of_lt_csupₛ`.\nWhen `b < supᵢ f`, there is an element `i` such that `b < f i`.\n",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {R : Type u_2} → {M : Type u_3} → [inst : SMul R M] → SMul R (ι → M)",
  "name": "Function.hasSMul",
  "kind": "def",
  "doc_string":
  "Non-dependent version of `Pi.smul`. Lean gets confused by the dependent instance if this\nis not present. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Meta.NormNum.NormNumExt",
  "kind": "inductive",
  "doc_string": "A extension for `norm_num`.\n",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : Add α] → [inst_1 : AddCommSemigroup β] → AddHom (AddHom α β) (α → β)",
  "name": "AddHom.coeFn",
  "kind": "def",
  "doc_string":
  "Coercion of an `AddHom` into a function is itself an `AddHom`.\n\nSee also `AddHom.eval`. ",
  "args": ""},
 {"type":
  "Lean.MVarId →\n  Lean.Meta.Simp.Context →\n    Option Lean.Meta.Simp.Discharge →\n      Bool → List (Lean.TSyntax `Lean.binderIdent) → Lean.Elab.TermElabM (Option Lean.MVarId)",
  "name": "Mathlib.Tactic.simpIntroCore",
  "kind": "opaque",
  "doc_string":
  "Main loop of the `simp_intro` tactic.\n* `g`: the original goal\n* `ctx`: the simp context, which is extended with local variables as we enter the binders\n* `discharge?`: the discharger\n* `more`: if true, we will keep introducing binders as long as we can\n* `ids`: the list of binder identifiers\n",
  "args": ""},
 {"type": "∀ {α : Type u} [self : NonAssocSemiring α] (a : α), a * 1 = a",
  "name": "NonAssocSemiring.mul_one",
  "kind": "def",
  "doc_string": "One is a right neutral element for multiplication ",
  "args": ""},
 {"type": "ToAdditive.Config → Option String",
  "name": "ToAdditive.Config.doc",
  "kind": "def",
  "doc_string": "An optional doc string.",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : Neg M₁] →\n            [inst_4 : Sub M₁] →\n              [inst_5 : SMul ℤ M₁] →\n                [inst_6 : SubtractionCommMonoid M₂] →\n                  (f : M₁ → M₂) →\n                    Function.Injective f →\n                      f 0 = 0 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁), f (-x) = -f x) →\n                            (∀ (x y : M₁), f (x - y) = f x - f y) →\n                              (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) → SubtractionCommMonoid M₁",
  "name": "Function.Injective.subtractionCommMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `0`, `+`, unary `-`, and binary\n`-` is a `SubtractionCommMonoid` if it admits an injective map that preserves `0`, `+`, unary `-`,\nand binary `-` to a `SubtractionCommMonoid`. This version takes custom `nsmul` and `zsmul` as\n`[SMul ℕ M₁]` and `[SMul ℤ M₁]` arguments.",
  "args": ""},
 {"type": "{u : Lean.Level} → {α : Q(Type u)} → Q(«$α») → Type",
  "name": "Mathlib.Meta.NormNum.Result",
  "kind": "def",
  "doc_string":
  "The result of `norm_num` running on an expression `x` of type `α`. ",
  "args": ""},
 {"type": "(V : Type u_1) → [inst : Quiver V] → Type u_1",
  "name": "Quiver.WeaklyConnectedComponent",
  "kind": "def",
  "doc_string":
  "The type of weakly connected components of a directed graph. Two vertices are\nin the same weakly connected component if there is a zigzag of arrows from one\nto the other. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_→ₙ*_»",
  "kind": "def",
  "doc_string":
  "`M →ₙ* N` denotes the type of multiplication-preserving maps from `M` to `N`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      Mathlib.Tactic.Ring.Cache α →\n        (e : Q(«$α»)) → Mathlib.Tactic.Ring.RingM (Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExSum sα) e)",
  "name": "Mathlib.Tactic.Ring.eval",
  "kind": "opaque",
  "doc_string":
  "Evaluates expression `e` of type `α` into a normalized representation as a polynomial.\nThis is the main driver of `ring`, which calls out to `evalAdd`, `evalMul` etc.\n",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 ↔ Subsingleton M₀",
  "name": "subsingleton_iff_zero_eq_one",
  "kind": "theorem",
  "doc_string":
  "In a monoid with zero, zero equals one if and only if all elements of that semiring\nare equal. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.RingNF.ringNFConv",
  "kind": "def",
  "doc_string":
  "Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `ring_nf at h` can be used to rewrite in a hypothesis.\n",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a b : Q(«$α»)} →\n        Mathlib.Tactic.Ring.ExSum sα a →\n          Mathlib.Tactic.Ring.ExSum sα b → Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExSum sα) q(«$a» * «$b»)",
  "name": "Mathlib.Tactic.Ring.evalMul",
  "kind": "def",
  "doc_string":
  "Multiplies two polynomials `va, vb` together to get a normalized result polynomial.\n\n* `0 * b = 0`\n* `(a₁ + a₂) * b = (a₁ * b) + (a₂ * b)`\n",
  "args": ""},
 {"type":
  "{ρ : Type u} → {m : Type u → Type v} → [self : MonadWithReaderOf ρ m] → {α : Type u} → (ρ → ρ) → m α → m α",
  "name": "MonadWithReaderOf.withReader",
  "kind": "def",
  "doc_string":
  "`withReader (f : ρ → ρ) (x : m α) : m α`  runs the inner `x : m α` inside\na modified context after applying the function `f : ρ → ρ`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : HasSup α] →\n      [inst_1 : HasInf α] →\n        [inst_2 : Bot α] →\n          [inst_3 : SDiff α] →\n            [inst_4 : GeneralizedCoheytingAlgebra β] →\n              (f : α → β) →\n                Function.Injective f →\n                  (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) →\n                    (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) →\n                      f ⊥ = ⊥ → (∀ (a b : α), f (a \\ b) = f a \\ f b) → GeneralizedCoheytingAlgebra α",
  "name": "Function.Injective.generalizedCoheytingAlgebra",
  "kind": "def",
  "doc_string": "Pullback a `GeneralizedCoheytingAlgebra` along an injection. ",
  "args": ""},
 {"type":
  "Lean.Expr → Option Lean.Expr → Lean.FVarId → Lean.MVarId → Lean.MetaM (List Lean.MVarId)",
  "name": "Mathlib.Tactic.applyFunHyp",
  "kind": "def",
  "doc_string": "Apply a function to a hypothesis. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : MonoidWithZero α] →\n      [inst_1 : MulZeroOneClass β] →\n        [inst_2 : MulActionWithZero α β] → [inst_3 : IsScalarTower α β β] → [inst_4 : SMulCommClass α β β] → α × β →*₀ β",
  "name": "smulMonoidWithZeroHom",
  "kind": "def",
  "doc_string": "Scalar multiplication as a monoid homomorphism with zero. ",
  "args": ""},
 {"type": "Lean.NameMapExtension (List Lean.Name × Array ProjectionData)",
  "name": "simpsStructure",
  "kind": "opaque",
  "doc_string":
  "The `simpsStructure` environment extension specifies the preferred projections of the given\nstructure, used by the `@[simps]` attribute.\n- You can generate this with the command `initialize_simps_projections`.\n- If not generated, the `@[simps]` attribute will generate this automatically.\n- To change the default value, see Note [custom simps projection].\n- The first argument is the list of names of the universe variables used in the structure\n- The second argument is an array that consists of the projection data for each projection.\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "LinearOrderedRing",
  "kind": "inductive",
  "doc_string":
  "A `LinearOrderedRing` is a ring with a linear order such that addition is monotone and\nmultiplication by a positive number is strictly monotone. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_&&&_»",
  "kind": "def",
  "doc_string":
  "`a &&& b` computes the bitwise AND of `a` and `b`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosStrictMono α],\n  1 < a → 1 ≤ b → 0 < b → 1 < a * b",
  "name": "Right.one_lt_mul_of_lt_of_le_of_pos",
  "kind": "theorem",
  "doc_string": "Assumes right covariance. ",
  "args": ""},
 {"type":
  "(R : Type u_1) → (M : Type u_2) → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → R →+ M →+ M",
  "name": "smulAddHom",
  "kind": "def",
  "doc_string":
  "A convenience alias for `Module.toAddMonoidEnd` as an `AddMonoidHom`, usually to allow the\nuse of `AddMonoidHom.flip`. ",
  "args": ""},
 {"type": "ℕ+ → ℕ+ → ℕ+",
  "name": "PNat.lcm",
  "kind": "def",
  "doc_string":
  "The least common multiple (lcm) of two positive natural numbers,\nviewed as positive natural number. ",
  "args": ""},
 {"type":
  "Sort u_1 → outParam (Sort u_2) → outParam (Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "name": "EquivLike",
  "kind": "inductive",
  "doc_string":
  "The class `EquivLike E α β` expresses that terms of type `E` have an\ninjective coercion to bijections between `α` and `β`.\n\nThis typeclass is used in the definition of the homomorphism typeclasses,\nsuch as `ZeroEquivClass`, `MulEquivClass`, `MonoidEquivClass`, ....\n",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.mkpair",
  "kind": "def",
  "doc_string": "Pairing function for the natural numbers. ",
  "args": ""},
 {"type": "{u : Lean.Level} → Q(Type u) → Type",
  "name": "Mathlib.Tactic.Ring.Cache",
  "kind": "inductive",
  "doc_string":
  "This cache contains data required by the `ring` tactic during execution. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Sort u_2} {s : ι → Set α} {t : Set α} (i : ι), s i ⊆ t → (Set.interᵢ fun i => s i) ⊆ t",
  "name": "Set.interᵢ_subset_of_subset",
  "kind": "theorem",
  "doc_string":
  "This rather trivial consequence of `interᵢ_subset`is convenient with `apply`, and has `i`\nexplicit for this purpose. ",
  "args": ""},
 {"type": "{α : Type u} → Stream' α → Stream' (List α)",
  "name": "Stream'.inits",
  "kind": "def",
  "doc_string": "Nonempty initial segments of a stream. ",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] {p : G₀ˣ → Prop}, (∃ g, p g) ↔ ∃ g hg, p (Units.mk0 g hg)",
  "name": "Units.exists0",
  "kind": "theorem",
  "doc_string":
  "In a group with zero, an existential over a unit can be rewritten in terms of `Units.mk0`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Monoid α] → α → αˣ → α",
  "name": "divp",
  "kind": "def",
  "doc_string":
  "Partial division. It is defined when the\nsecond argument is invertible, and unlike the division operator\nin `DivisionRing` it is not totalized at zero. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Quiver.Empty",
  "kind": "def",
  "doc_string": "A type synonym for a quiver with no arrows. ",
  "args": ""},
 {"type": "(α : Type u) → [inst : AddMonoid α] → Type u",
  "name": "AddUnits",
  "kind": "inductive",
  "doc_string":
  "Units of an `AddMonoid`, bundled version.\n\nAn element of an `AddMonoid` is a unit if it has a two-sided additive inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `isAddUnit`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : StrictOrderedRing α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "name": "StrictOrderedRing.add_le_add_left",
  "kind": "def",
  "doc_string":
  "Addition is monotone in a ordered additive commutative group. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Abel.tacticAbel!",
  "kind": "def",
  "doc_string":
  "Tactic for evaluating expressions in abelian groups.\n\n* `abel!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `abel1` fails if the target is not an equality.\n\nFor example:\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrderedCancelAddCommMonoid α] → DecidableEq α",
  "name": "LinearOrderedCancelAddCommMonoid.decidable_eq",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "{β : Type u_1} → {ι : Sort u_2} → (ι → Set β) → Set β",
  "name": "Set.interᵢ",
  "kind": "def",
  "doc_string": "Indexed intersection of a family of sets ",
  "args": ""},
 {"type": "∀ {α : Sort u} {a b c : α}, a = b → b ≠ c → a ≠ c",
  "name": "Eq.trans_ne",
  "kind": "theorem",
  "doc_string": "**Alias** of `ne_of_eq_of_ne`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → Array α → List α → List (List α) → Array α → List α",
  "name": "List.intercalateTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `intercalateTR`:\n`intercalateTR.go sep x xs acc = acc.toList ++ intercalate sep.toList (x::xs)` ",
  "args": ""},
 {"type": "Type u → Type u → Type u → Type u",
  "name": "DoResultPR",
  "kind": "inductive",
  "doc_string":
  "Auxiliary type used to compile `do` notation. It is the same as\n`DoResultPRBC α β σ` except that `break` and `continue` are not available\nbecause we are not in a loop context.\n",
  "args": ""},
 {"type": "{α : Type u} → List α → List α → (α → α → Bool) → Bool",
  "name": "List.isEqv",
  "kind": "def",
  "doc_string":
  "`O(min |as| |bs|)`. Returns true if `as` and `bs` have the same length,\nand they are pairwise related by `eqv`.\n",
  "args": ""},
 {"type": "{V : Type u_1} → [inst : Quiver V] → Quiver Vᵒᵖ",
  "name": "Quiver.opposite",
  "kind": "def",
  "doc_string": "`Vᵒᵖ` reverses the direction of all arrows of `V`. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : AddRightCancelSemigroup M₂] →\n        (f : M₁ → M₂) → Function.Injective f → (∀ (x y : M₁), f (x + y) = f x + f y) → AddRightCancelSemigroup M₁",
  "name": "Function.Injective.addRightCancelSemigroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `+` is an additive right\ncancel semigroup, if it admits an injective map that preserves `+` to an additive right cancel\nsemigroup.",
  "args": ""},
 {"type": "Type u → Type v → Type (max u v)",
  "name": "Except",
  "kind": "inductive",
  "doc_string":
  "`Except ε α` is a type which represents either an error of type `ε`, or an \"ok\"\nvalue of type `α`. The error type is listed first because\n`Except ε : Type → Type` is a `Monad`: the pure operation is `ok` and the bind\noperation returns the first encountered `error`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → Set.Ioi b ⊆ Set.Ioi a",
  "name": "Set.Ioi_subset_Ioi",
  "kind": "theorem",
  "doc_string":
  "If `a ≤ b`, then `(b, +∞) ⊆ (a, +∞)`. In preorders, this is just an implication. If you need\nthe equivalence in linear orders, use `Ioi_subset_Ioi_iff`. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → (α → β → α) → α → List β → α",
  "name": "List.foldl",
  "kind": "def",
  "doc_string":
  "Folds a function over a list from the left:\n`foldl f z [a, b, c] = f (f (f z a) b) c`\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (p : α → β → Prop) → { x // p x.fst x.snd } ≃ (a : α) × { b // p a b }",
  "name": "Equiv.subtypeProdEquivSigmaSubtype",
  "kind": "def",
  "doc_string":
  "A subtype of a `Prod` is equivalent to a sigma type whose fibers are subtypes. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⟶_»",
  "kind": "def",
  "doc_string":
  "Notation for the type of edges/arrows/morphisms between a given source and target\nin a quiver or category.\n",
  "args": ""},
 {"type": "Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Tactic.Tauto.tautoCore",
  "kind": "def",
  "doc_string":
  "The core loop of the `tauto` tactic. Repeatedly tries to break down propositions\nuntil no more progress can be made. Tries `assumption` and `contradiction` at every\nstep, to discharge goals as soon as possible. Does not do anything that requires\nbacktracking.\n\nTODO: The Lean 3 version uses more-powerful versions of `contradiction` and `assumption`\nthat additionally apply `symm` and use a fancy union-find data structure to avoid\nduplicated work.\n",
  "args": ""},
 {"type": "∀ {a : Prop}, ¬¬¬a → ¬a",
  "name": "not_of_not_not_not",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `not_not_not`.",
  "args": ""},
 {"type": "{α : Type u} → List α → List α → List α",
  "name": "List.appendTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `List.append`. ",
  "args": ""},
 {"type": "{V : Type u_1} → [inst : Quiver V] → V ⥤q Quiver.Symmetrify V",
  "name": "Quiver.Symmetrify.of",
  "kind": "def",
  "doc_string": "The inclusion of a quiver in its symmetrification ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : AddMonoid M] → M → Prop",
  "name": "IsAddUnit",
  "kind": "def",
  "doc_string":
  "An element `a : M` of an `AddMonoid` is an `AddUnit` if it has a two-sided additive inverse.\nThe actual definition says that `a` is equal to some `u : AddUnits M`,\nwhere `AddUnits M` is a bundled version of `IsAddUnit`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r →r s → Function.swap r →r Function.swap s",
  "name": "RelHom.swap",
  "kind": "def",
  "doc_string":
  "A relation homomorphism is also a relation homomorphism between dual relations. ",
  "args": ""},
 {"type": "{α : Type u_1} → (self : Semiquot α) → Trunc ↑self.s",
  "name": "Semiquot.val",
  "kind": "def",
  "doc_string": "Assertion of non-emptiness via `Trunc`",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α},\n  BddAbove s → Set.Nonempty s → supₛ (insert a s) = a ⊔ supₛ s",
  "name": "csupₛ_insert",
  "kind": "theorem",
  "doc_string":
  "The supremum of `insert a s` is the maximum of `a` and the supremum of `s`, if `s` is\nnonempty and bounded above.",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Add M] → {S T : AddSubsemigroup M} → S = T → { x // x ∈ S } ≃+ { x // x ∈ T }",
  "name": "AddEquiv.subsemigroupCongr",
  "kind": "def",
  "doc_string":
  "Makes the identity additive isomorphism from a proof two\nsubsemigroups of an additive semigroup are equal.",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a : Q(«$α»)} →\n        (rα : Q(Ring «$α»)) →\n          Mathlib.Tactic.Ring.ExProd sα a → Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExProd sα) q(-«$a»)",
  "name": "Mathlib.Tactic.Ring.evalNegProd",
  "kind": "def",
  "doc_string":
  "Negates a monomial `va` to get another monomial.\n\n* `-c = (-c)` (for `c` coefficient)\n* `-(a₁ * a₂) = a₁ * -a₂`\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Monoid α] [inst_1 : HasDistribNeg α] (u : αˣ), ↑(-u) = -↑u",
  "name": "Units.val_neg",
  "kind": "theorem",
  "doc_string":
  "Representing an element of a ring's unit group as an element of the ring commutes with\nmapping this element to its additive inverse. ",
  "args": ""},
 {"type": "Num → Num → Option Num",
  "name": "Num.psub",
  "kind": "def",
  "doc_string": "Subtraction of two `Num`s, producing an `Option Num`. ",
  "args": ""},
 {"type":
  "{n : ℕ} →\n  {C : Fin2 (Nat.succ n) → Sort u} → C Fin2.fz → ((n_1 : Fin2 n) → C (Fin2.fs n_1)) → (i : Fin2 (Nat.succ n)) → C i",
  "name": "Fin2.cases'",
  "kind": "def",
  "doc_string":
  "Define a dependent function on `Fin2 (succ n)` by giving its value at\nzero (`H1`) and by giving a dependent function on the rest (`H2`). ",
  "args": ""},
 {"type": "Linarith.GlobalBranchingPreprocessor → String",
  "name": "Linarith.GlobalBranchingPreprocessor.name",
  "kind": "def",
  "doc_string":
  "The name of the global branching preprocessor, used in trace output. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → {x : MulOneClass M} → [inst : CommMonoid N] → Mul (M →* N)",
  "name": "MonoidHom.mul",
  "kind": "def",
  "doc_string":
  "Given two monoid morphisms `f`, `g` to a commutative monoid, `f * g` is the monoid morphism\nsending `x` to `f x * g x`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a : α}, 1 < a⁻¹ ↔ a < 1",
  "name": "one_lt_inv'",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.one_lt_inv_iff`.",
  "args": ""},
 {"type": "OfScientific Float",
  "name": "instOfScientificFloat",
  "kind": "def",
  "doc_string":
  "The `OfScientific Float` must have priority higher than `mid` since\nthe default instance `Neg Int` has `mid` priority.\n```\n#check -42.0 -- must be Float\n```\n",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c",
  "name": "Commute.mul_left",
  "kind": "theorem",
  "doc_string":
  "If both `a` and `b` commute with `c`, then their product commutes with `c`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "CancelMonoid",
  "kind": "inductive",
  "doc_string": "A monoid in which multiplication is cancellative. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : GeneralizedHeytingAlgebra α] {a b : α}, a ⇨ b = ⊤ ↔ a ≤ b",
  "name": "himp_eq_top_iff",
  "kind": "theorem",
  "doc_string":
  "The **deduction theorem** in the Heyting algebra model of intuitionistic logic:\nan implication holds iff the conclusion follows from the hypothesis. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α}, a ≤ 1 → b < 1 → a * b < 1",
  "name": "Left.mul_lt_one_of_le_of_lt",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one_of_le_of_lt`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → AddHom M N → AddHom M N → AddSubsemigroup M",
  "name": "AddHom.eqLocus",
  "kind": "def",
  "doc_string":
  "The additive subsemigroup of elements `x : M` such that `f x = g x`",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "name": "List.isInfix",
  "kind": "def",
  "doc_string":
  "`isInfix l₁ l₂`, or `l₁ <:+: l₂`, means that `l₁` is a contiguous\nsubstring of `l₂`, that is, `l₂` has the form `s ++ l₁ ++ t` for some `s, t`.\n",
  "args": ""},
 {"type": "{α : Type u₁} → {β : Type u₂} → (α → β → Prop) → Prop",
  "name": "Relator.BiTotal",
  "kind": "def",
  "doc_string":
  "A relation is \"bi-total\" if it is both right total and left total. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : DecidableEq α] (i j : α) (σ : Equiv.Perm α), σ * Equiv.swap i j * Equiv.swap i j = σ",
  "name": "Equiv.mul_swap_mul_self",
  "kind": "theorem",
  "doc_string":
  "Right-multiplying a permutation with `swap i j` twice gives the original permutation.\n\nThis specialization of `swap_mul_self` is useful when using cosets of permutations.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : GeneralizedCoheytingAlgebra α] (a b : α), a ⊔ b \\ a = a ⊔ b",
  "name": "sup_sdiff_self_right",
  "kind": "theorem",
  "doc_string": "**Alias** of `sup_sdiff_self`.",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        (oi : α ≃o β) →\n          GaloisInsertion ↑(RelIso.toRelEmbedding oi).toEmbedding\n            ↑(RelIso.toRelEmbedding (OrderIso.symm oi)).toEmbedding",
  "name": "OrderIso.toGaloisInsertion",
  "kind": "def",
  "doc_string": "Makes a Galois insertion from an order-preserving bijection. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a : α), 0 * a = 0",
  "name": "NonUnitalNonAssocSemiring.zero_mul",
  "kind": "def",
  "doc_string": "Zero is a left absorbing element for multiplication ",
  "args": ""},
 {"type": "(ι : Type u_1) → ComplexShape ι",
  "name": "ComplexShape.refl",
  "kind": "def",
  "doc_string":
  "The complex shape where only differentials from each `X.i` to itself are allowed.\n\nThis is mostly only useful so we can describe the relation of \"related in `k` steps\" below.\n",
  "args": ""},
 {"type": "{α : Type u_1} → (r : α → α → Prop) → (p : Set α) → Subrel r p ↪r r",
  "name": "Subrel.relEmbedding",
  "kind": "def",
  "doc_string":
  "The relation embedding from the inherited relation on a subset. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_<=<_»",
  "kind": "def",
  "doc_string": "Right-to-left composition of Kleisli arrows. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : Preorder γ] {f : α → β → γ}\n  {s : Set α} {t : Set β},\n  (∀ (b : β), Monotone (Function.swap f b)) →\n    (∀ (a : α), Monotone (f a)) → BddAbove s → BddAbove t → BddAbove (Set.image2 f s t)",
  "name": "BddAbove.image2",
  "kind": "theorem",
  "doc_string": "See also `Monotone.map_bddAbove`. ",
  "args": ""},
 {"type": "PosNum → PosNum → Num",
  "name": "PosNum.div'",
  "kind": "def",
  "doc_string": "Division of `PosNum`, ",
  "args": ""},
 {"type": "Linarith.PComp → Bool",
  "name": "Linarith.PComp.isContr",
  "kind": "def",
  "doc_string":
  "A `PComp` represents a contradiction if its `Comp` field represents a contradiction.\n",
  "args": ""},
 {"type": "∀ {R : Type u_1} [inst : Field R] (n : ℕ), ↑(-↑n) = -↑n",
  "name": "Int.cast_neg_natCast",
  "kind": "theorem",
  "doc_string":
  "Auxiliary lemma for norm_cast to move the cast `-↑n` upwards to `↑-↑n`.\n\n(The restriction to `Field` is necessary, otherwise this would also apply in the case where\n`R = ℤ` and cause nontermination.)\n",
  "args": ""},
 {"type": "{α : Type u} → {n : ℕ} → Fin n → Vector α n → Vector α (n - 1)",
  "name": "Vector.removeNth",
  "kind": "def",
  "doc_string":
  "Remove the element at position `i` from a vector of length `n`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : BooleanAlgebra α] → α ≃o αᵒᵈ",
  "name": "OrderIso.compl",
  "kind": "def",
  "doc_string":
  "Taking complements as an order isomorphism to the order dual. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {t : Set α},\n  MonotoneOn f t → ∀ {a : α}, IsGreatest t a → IsGreatest (f '' t) (f a)",
  "name": "MonotoneOn.map_isGreatest",
  "kind": "theorem",
  "doc_string":
  "A monotone map sends a greatest element of a set to a greatest element of its image. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → List β) → List α → Array β → List β",
  "name": "List.bindTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `bind`: `bind.go f as = acc.toList ++ bind f as` ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddMonoid R] {a : R}, IsAddUnit a → IsAddRegular a",
  "name": "IsAddUnit.isAddRegular",
  "kind": "theorem",
  "doc_string": "An additive unit in an additive monoid is add-regular.",
  "args": ""},
 {"type": "{α : Type u} → Bool → α → α → α",
  "name": "cond",
  "kind": "def",
  "doc_string":
  "`cond b x y` is the same as `if b then x else y`, but optimized for a\nboolean condition. It can also be written as `bif b then x else y`.\nThis is `@[macro_inline]` because `x` and `y` should not\nbe eagerly evaluated (see `ite`).\n",
  "args": ""},
 {"type":
  "{a : Q(ℕ)} → Mathlib.Tactic.Ring.ExSum Mathlib.Tactic.Ring.sℕ a → Option Q(0 < «$a»)",
  "name": "Mathlib.Tactic.Ring.ExSum.evalPos",
  "kind": "opaque",
  "doc_string":
  "Attempts to prove that a polynomial expression in `ℕ` is positive.\n\n* `0 < 0` fails\n* `0 < a + b` if `0 < a` or `0 < b`\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : AddCommMonoid M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [inst : AddSubmonoidClass A M] → (S : A) → AddCommMonoid { x // x ∈ S }",
  "name": "AddSubmonoidClass.toAddCommMonoid",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of an `AddCommMonoid` is an `AddCommMonoid`.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "LinearOrderedSemifield",
  "kind": "inductive",
  "doc_string":
  "A linear ordered semifield is a field with a linear order respecting the operations. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r →r s → α → β",
  "name": "RelHom.toFun",
  "kind": "def",
  "doc_string": "The underlying function of a `RelHom` ",
  "args": ""},
 {"type":
  "{M : Type uM} →\n  {N : Type uN} →\n    {P : Type uP} → {x : MulOneClass M} → {x_1 : MulOneClass N} → {x_2 : CommMonoid P} → (M →* N →* P) →* N →* M →* P",
  "name": "MonoidHom.flipHom",
  "kind": "def",
  "doc_string":
  "Flipping arguments of monoid morphisms (`MonoidHom.flip`) as a monoid morphism. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α",
  "name": "List.tail",
  "kind": "def",
  "doc_string": "Get the tail of a nonempty list, or return `[]` for `[]`. ",
  "args": ""},
 {"type":
  "{var : String} →\n  {β : Prop → Prop} →\n    [inst : (b : Bool) → SlimCheck.Testable (β (b = true))] →\n      SlimCheck.Testable (SlimCheck.NamedBinder var (∀ (p : Prop), β p))",
  "name": "SlimCheck.Testable.propVarTestable",
  "kind": "def",
  "doc_string": "Test a universal property about propositions ",
  "args": ""},
 {"type": "{ε : Type u} → {α : Type u_1} → Except ε α → Bool",
  "name": "Except.toBool",
  "kind": "def",
  "doc_string": "Returns true if the value is `Except.ok`, false otherwise. ",
  "args": ""},
 {"type": "∀ {R : Type u_1} [inst : Monoid R] {a : R}, IsUnit a → IsRegular a",
  "name": "IsUnit.isRegular",
  "kind": "theorem",
  "doc_string": "A unit in a monoid is regular. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term[_]»",
  "kind": "def",
  "doc_string":
  "The syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Sort u_2} {κ : ι → Sort u_3} {s : (i : ι) → κ i → Set α} {t : Set α} (i : ι) (j : κ i),\n  s i j ⊆ t → (Set.interᵢ fun i => Set.interᵢ fun j => s i j) ⊆ t",
  "name": "Set.interᵢ₂_subset_of_subset",
  "kind": "theorem",
  "doc_string":
  "This rather trivial consequence of `interᵢ₂_subset` is convenient with `apply`, and has `i` and\n`j` explicit for this purpose. ",
  "args": ""},
 {"type": "{α : Type u} → α → Option α",
  "name": "Option.some",
  "kind": "def",
  "doc_string": "Some value of type `α`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Monoid α] → α → α → Prop",
  "name": "Associated",
  "kind": "def",
  "doc_string":
  "Two elements of a `Monoid` are `Associated` if one of them is another one\nmultiplied by a unit on the right. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Monoid α] → Setoid α",
  "name": "Associated.setoid",
  "kind": "def",
  "doc_string":
  "The setoid of the relation `x ~ᵤ y` iff there is a unit `u` such that `x * u = y` ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β → α) → α → List β → List α",
  "name": "List.scanl",
  "kind": "def",
  "doc_string":
  "Fold a function `f` over the list from the left, returning the list of partial results.\n```\nscanl (+) 0 [1, 2, 3] = [0, 1, 3, 6]\n```\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (r : α → α → Prop) → (s : β → β → Prop) → s ↪r Sum.Lex r s",
  "name": "RelEmbedding.sumLexInr",
  "kind": "def",
  "doc_string": "`Sum.inr` as a relation embedding into `Sum.Lex r s`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, b ≤ a → a ⊓ b = b",
  "name": "inf_of_le_right",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `inf_eq_right`.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → AddSubsemigroup M → AddSubsemigroup N → AddSubsemigroup (M × N)",
  "name": "AddSubsemigroup.prod",
  "kind": "def",
  "doc_string":
  "Given `AddSubsemigroup`s `s`, `t` of `AddSemigroup`s `A`, `B` respectively,\n`s × t` as an `AddSubsemigroup` of `A × B`.",
  "args": ""},
 {"type":
  "Lean.Name → Lean.Name → optParam Lean.AttributeKind Lean.AttributeKind.global → Lean.CoreM Unit",
  "name": "ToAdditive.hackyAddAttribute",
  "kind": "def",
  "doc_string":
  "A hack to add an attribute to a declaration.\nWe use the `missing` for the syntax, so this only works for certain attributes.\nIt seems to work for `refl`, `symm`, `trans`, `ext` and `coe`.\nThis does not work for most attributes where the syntax has optional arguments.\nTODO: have a proper implementation once we have the infrastructure for this. ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.Context → Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "name": "Mathlib.Tactic.Abel.Context.evalAtom",
  "kind": "def",
  "doc_string":
  "A simplification to apply to atomic expressions when they are encountered,\nbefore operating on them as atoms. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (e : Q(«$α»)) →\n      Lean.MetaM ((_inst : Q(AddMonoidWithOne «$α»)) × (lit : Q(ℕ)) × Q(Mathlib.Meta.NormNum.IsNat «$e» «$lit»))",
  "name": "Mathlib.Meta.NormNum.deriveNat'",
  "kind": "def",
  "doc_string":
  "Run each registered `norm_num` extension on a typed expression `e : α`,\nreturning a typed expression `lit : ℕ`, and a proof of `isNat e lit`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a b : α),\n  ↑f (a * b) = ↑f a * ↑f b",
  "name": "RingHom.map_mul",
  "kind": "theorem",
  "doc_string": "Ring homomorphisms preserve multiplication. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b c : α}, a ≤ b * c → b⁻¹ * a ≤ c",
  "name": "inv_mul_le_of_le_mul",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `inv_mul_le_iff_le_mul`.",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : AddZeroClass M] → Type u_1",
  "name": "AddSubmonoid",
  "kind": "inductive",
  "doc_string":
  "An additive submonoid of an additive monoid `M` is a subset containing 0 and\nclosed under addition. ",
  "args": ""},
 {"type": "{α : Type u} → List α → LazyList α",
  "name": "LazyList.ofList",
  "kind": "def",
  "doc_string": "Constructs a lazy list from a list. ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Mul M] → Type u_1",
  "name": "Subsemigroup",
  "kind": "inductive",
  "doc_string":
  "A subsemigroup of a magma `M` is a subset closed under multiplication. ",
  "args": ""},
 {"type": "{α : Type u} → LazyList α → ℕ → Option α",
  "name": "LazyList.nth",
  "kind": "def",
  "doc_string":
  "The nth element of a lazy list as an option (like `list.nth`). ",
  "args": ""},
 {"type":
  "List Lean.Level → List Lean.Expr → List Lean.Expr → Lean.Name → Lean.MetaM (Mathlib.Tactic.MkIff.Shape × Lean.Expr)",
  "name": "Mathlib.Tactic.MkIff.constrToProp",
  "kind": "def",
  "doc_string":
  "Converts an inductive constructor `c` into a `Shape` that will be used later in\nwhile proving the iff theorem, and a proposition representing the constructor.\n",
  "args": ""},
 {"type":
  "(F : Type u → Type u) → [inst : Applicative F] → [inst_1 : LawfulApplicative F] → ApplicativeTransformation Id F",
  "name": "Traversable.PureTransformation",
  "kind": "def",
  "doc_string":
  "The natural applicative transformation from the identity functor\nto `F`, defined by `pure : Π {α}, α → F α`. ",
  "args": ""},
 {"type": "{α : Type u} → Array α",
  "name": "Array.empty",
  "kind": "def",
  "doc_string": "Construct a new empty array. ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : OrderedSemiring α], 0 ≤ 1",
  "name": "OrderedSemiring.zero_le_one",
  "kind": "def",
  "doc_string": "`0 ≤ 1` in any ordered semiring. ",
  "args": ""},
 {"type": "∀ {M : Type u} [self : AddRightCancelMonoid M] (a : M), 0 + a = a",
  "name": "AddRightCancelMonoid.zero_add",
  "kind": "def",
  "doc_string": "Zero is a left neutral element for addition ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  StrictAnti f → StrictMono (f ∘ ↑OrderDual.ofDual)",
  "name": "StrictAnti.dual_left",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `strictMono_comp_ofDual_iff`.",
  "args": ""},
 {"type": "Linarith.Comp → List ℕ",
  "name": "Linarith.Comp.vars",
  "kind": "def",
  "doc_string":
  "`c.vars` returns the list of variables that appear in the linear expression contained in `c`. ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} {D : Type u₂} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {F : C ⥤ D}\n  [self : CategoryTheory.EssSurj F] (Y : D), Y ∈ CategoryTheory.Functor.essImage F",
  "name": "CategoryTheory.EssSurj.mem_essImage",
  "kind": "def",
  "doc_string":
  "All the objects of the target category are in the essential image. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → LazyList α → LazyList β → LazyList (α × β)",
  "name": "LazyList.zip",
  "kind": "def",
  "doc_string": "Zips two lazy lists. ",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrderedCancelCommMonoid α] → DecidableRel fun x x_1 => x ≤ x_1",
  "name": "LinearOrderedCancelCommMonoid.decidable_le",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "∀ (R : Type u_2) {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (n : ℕ) (b : M),\n  n • b = ↑n • b",
  "name": "nsmul_eq_smul_cast",
  "kind": "theorem",
  "doc_string": "`nsmul` is equal to any other module structure via a cast. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {f : α → α → α},\n  Commutative f → (∀ (a b c : α), f (f a b) c ≤ f a (f b c)) → Associative f",
  "name": "associative_of_commutative_of_le",
  "kind": "theorem",
  "doc_string":
  "To prove associativity of a commutative binary operation `○`, we only to check\n`(a ○ b) ○ c ≤ a ○ (b ○ c)` for all `a`, `b`, `c`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : Preorder β] {a : α} {f : α → β},\n  StrictAntiOn f (Set.Iic a) → StrictAntiOn f (Set.Ici a) → StrictAnti f",
  "name": "StrictAntiOn.Iic_union_Ici",
  "kind": "theorem",
  "doc_string":
  "If `f` is strictly antitone both on `(-∞, a]` and `[a, ∞)`, then it is strictly antitone on the\nwhole line. ",
  "args": ""},
 {"type":
  "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [self : Module R M] (r s : R) (x : M),\n  (r + s) • x = r • x + s • x",
  "name": "Module.add_smul",
  "kind": "def",
  "doc_string":
  "Scalar multiplication distributes over addition from the right. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Monoid M] → (u : Mˣ) → (a b : M) → a * b = ↑u → Commute a b → Mˣ",
  "name": "Units.rightOfMul",
  "kind": "def",
  "doc_string":
  "If the product of two commuting elements is a unit, then the right multiplier is a unit. ",
  "args": ""},
 {"type": "List Bool → Bool",
  "name": "List.band",
  "kind": "def",
  "doc_string": "Big and of a list of Booleans. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_3} {β : Type u_4} {β' : Type u_5} {γ : Type u_2} {δ : Type u_1} {f : α → β → γ} {s : Set α} {t : Set β}\n  {g : γ → δ} {f' : α → β' → δ} {g' : β → β'},\n  (∀ (a : α) (b : β), g (f a b) = f' a (g' b)) → g '' Set.image2 f s t = Set.image2 f' s (g' '' t)",
  "name": "Set.image_image2_distrib_right",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Set.image_image2_right_comm`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → (l : List α) → (∃ a, a ∈ l ∧ p a) → { a // a ∈ l ∧ p a }",
  "name": "List.chooseX",
  "kind": "def",
  "doc_string":
  "Given a decidable predicate `p` and a proof of existence of `a ∈ l` such that `p a`,\nchoose the first element with this property. This version returns both `a` and proofs\nof `a ∈ l` and `p a`. ",
  "args": ""},
 {"type": "Type s → Type (max s r)",
  "name": "ULift",
  "kind": "inductive",
  "doc_string":
  "Universe lifting operation from a lower `Type` universe to a higher one.\nTo express this using level variables, the input is `Type s` and the output is\n`Type (max s r)`, so if `s ≤ r` then the latter is (definitionally) `Type r`.\n\nThe universe variable `r` is written first so that `ULift.{r} α` can be used\nwhen `s` can be inferred from the type of `α`.\n",
  "args": ""},
 {"type": "{α : Sort u} → [i : α] → α",
  "name": "inferInstance",
  "kind": "def",
  "doc_string":
  "`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : α]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`α` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : LinearOrderedAddCommMonoid α] →\n    {β : Type u_1} →\n      [inst_1 : Zero β] →\n        [inst_2 : Add β] →\n          [inst_3 : SMul ℕ β] →\n            [inst_4 : HasSup β] →\n              [inst_5 : HasInf β] →\n                (f : β → α) →\n                  Function.Injective f →\n                    f 0 = 0 →\n                      (∀ (x y : β), f (x + y) = f x + f y) →\n                        (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                          (∀ (x y : β), f (x ⊔ y) = max (f x) (f y)) →\n                            (∀ (x y : β), f (x ⊓ y) = min (f x) (f y)) → LinearOrderedAddCommMonoid β",
  "name": "Function.Injective.linearOrderedAddCommMonoid",
  "kind": "def",
  "doc_string": "Pullback an `OrderedAddCommMonoid` under an injective map.",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {F G : C ⥤ D} →\n          CategoryTheory.NatTrans F G → (X : C) → Prefunctor.obj F.toPrefunctor X ⟶ Prefunctor.obj G.toPrefunctor X",
  "name": "CategoryTheory.NatTrans.app",
  "kind": "def",
  "doc_string": "The component of a natural transformation. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : LinearOrderedCancelCommMonoid α] →\n    {β : Type u_1} →\n      [inst_1 : One β] →\n        [inst_2 : Mul β] →\n          [inst_3 : Pow β ℕ] →\n            [inst_4 : HasSup β] →\n              [inst_5 : HasInf β] →\n                (f : β → α) →\n                  Function.Injective f →\n                    f 1 = 1 →\n                      (∀ (x y : β), f (x * y) = f x * f y) →\n                        (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                          (∀ (x y : β), f (x ⊔ y) = max (f x) (f y)) →\n                            (∀ (x y : β), f (x ⊓ y) = min (f x) (f y)) → LinearOrderedCancelCommMonoid β",
  "name": "Function.Injective.linearOrderedCancelCommMonoid",
  "kind": "def",
  "doc_string":
  "Pullback a `LinearOrderedCancelCommMonoid` under an injective map.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → Array (List α) → List (List α)",
  "name": "List.tailsTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `tailsTR`: `tailsTR.go l acc = acc.toList ++ tails l`. ",
  "args": ""},
 {"type": "(α : Type u_1) → MulAction (Equiv.Perm α) α",
  "name": "Equiv.Perm.applyMulAction",
  "kind": "def",
  "doc_string":
  "The tautological action by `Equiv.Perm α` on `α`.\n\nThis generalizes `Function.End.applyMulAction`.",
  "args": ""},
 {"type": "(α : Sort v) → [inst : IsEmpty α] → α ≃ PEmpty",
  "name": "Equiv.equivPEmpty",
  "kind": "def",
  "doc_string":
  "If `α` is an empty type, then it is equivalent to the `PEmpty` type in any universe. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Monoid α] → [inst_1 : LinearOrder α] → αˣ ↪o α",
  "name": "Units.orderEmbeddingVal",
  "kind": "def",
  "doc_string": "`val : αˣ → α` as an order embedding. ",
  "args": ""},
 {"type":
  "{α : Type u} → {p : α → Prop} → [inst : LE α] → [inst_1 : BoundedOrder α] → p ⊥ → p ⊤ → BoundedOrder (Subtype p)",
  "name": "Subtype.boundedOrder",
  "kind": "def",
  "doc_string":
  "A subtype remains a bounded order if the property holds at `⊥` and `⊤`. ",
  "args": ""},
 {"type": "ShareCommon.StateFactory → NonemptyType",
  "name": "ShareCommon.StatePointed",
  "kind": "opaque",
  "doc_string":
  "Internally `State` is implemented as a pair `ObjectMap` and `ObjectSet` ",
  "args": ""},
 {"type":
  "{M₀ : Type u_1} →\n  {M₀' : Type u_2} →\n    [inst : Zero M₀'] →\n      [inst_1 : Mul M₀'] →\n        [inst_2 : One M₀'] →\n          [inst_3 : Pow M₀' ℕ] →\n            [inst_4 : CommMonoidWithZero M₀] →\n              (f : M₀ → M₀') →\n                Function.Surjective f →\n                  f 0 = 0 →\n                    f 1 = 1 →\n                      (∀ (x y : M₀), f (x * y) = f x * f y) →\n                        (∀ (x : M₀) (n : ℕ), f (x ^ n) = f x ^ n) → CommMonoidWithZero M₀'",
  "name": "Function.Surjective.commMonoidWithZero",
  "kind": "def",
  "doc_string":
  "Pushforward a `CommMonoidWithZero` along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α}, a ≤ 1 → b < 1 → a * b < 1",
  "name": "mul_lt_one_of_le_of_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.mul_lt_one_of_le_of_lt`.",
  "args": ""},
 {"type":
  "(α : Type u) →\n  (β : Type v) → [inst : Group α] → [inst_1 : Monoid β] → [inst_2 : MulDistribMulAction α β] → α →* MulAut β",
  "name": "MulDistribMulAction.toMulAut",
  "kind": "def",
  "doc_string":
  "Each element of the group defines an multiplicative monoid isomorphism.\n\nThis is a stronger version of `MulAction.toPermHom`. ",
  "args": ""},
 {"type": "{ι : Type u_1} → ComplexShape ι → ι → ι → Prop",
  "name": "ComplexShape.Rel",
  "kind": "def",
  "doc_string":
  "Nonzero differentials `X i ⟶ X j` shall be allowed\non homological complexes when `Rel i j` holds. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → (self : BinaryHeap α lt) → Fin (BinaryHeap.size self) → α",
  "name": "BinaryHeap.get",
  "kind": "def",
  "doc_string": "`O(1)`. Get an element in the heap by index. ",
  "args": ""},
 {"type":
  "Lean.MVarId → (Lean.Expr → Lean.MetaM Bool) → optParam Bool false → optParam Bool true → Lean.MetaM (List Lean.MVarId)",
  "name": "Mathlib.Tactic.casesMatching",
  "kind": "def",
  "doc_string":
  "Core tactic for `casesm` and `cases_type`. Calls `cases` on all fvars in `g` for which\n`matcher ldecl.type` returns true.\n* `recursive`: if true, it calls itself repeatedly on the resulting subgoals\n* `allowSplit`: if false, it will skip any hypotheses where `cases` returns more than one subgoal.\n",
  "args": ""},
 {"type": "(α : Sort u) → [inst : Unique α] → α ≃ PUnit",
  "name": "Equiv.equivPUnit",
  "kind": "def",
  "doc_string":
  "If `α` has a unique element, then it is equivalent to any `PUnit`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → α → Prop} →\n        {s : β → β → Prop} →\n          {t : γ → γ → Prop} →\n            (f : α → β → γ) →\n              (∀ (a : α) (b₁ b₂ : β), s b₁ b₂ → t (f a b₁) (f a b₂)) →\n                (∀ (a₁ a₂ : α) (b : β), r a₁ a₂ → t (f a₁ b) (f a₂ b)) → Quot r → Quot s → Quot t",
  "name": "Quot.map₂",
  "kind": "def",
  "doc_string":
  "Descends a function `f : α → β → γ` to quotients of `α` and `β` wih values in a quotient of\n`γ`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : HasSup α] →\n      [inst_1 : HasInf α] →\n        [inst_2 : SupSet α] →\n          [inst_3 : InfSet α] →\n            [inst_4 : Top α] →\n              [inst_5 : Bot α] →\n                [inst_6 : HasCompl α] →\n                  [inst_7 : SDiff α] →\n                    [inst_8 : CompleteBooleanAlgebra β] →\n                      (f : α → β) →\n                        Function.Injective f →\n                          (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) →\n                            (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) →\n                              (∀ (s : Set α), f (supₛ s) = ⨆ a, ⨆ h, f a) →\n                                (∀ (s : Set α), f (infₛ s) = ⨅ a, ⨅ h, f a) →\n                                  f ⊤ = ⊤ →\n                                    f ⊥ = ⊥ →\n                                      (∀ (a : α), f (aᶜ) = f aᶜ) →\n                                        (∀ (a b : α), f (a \\ b) = f a \\ f b) → CompleteBooleanAlgebra α",
  "name": "Function.Injective.completeBooleanAlgebra",
  "kind": "def",
  "doc_string": "Pullback a `CompleteBooleanAlgebra` along an injection. ",
  "args": ""},
 {"type":
  "{α : Sort u} → {r r' : α → α → Prop} → (∀ (a₁ a₂ : α), r a₁ a₂ ↔ r' a₁ a₂) → Quot r ≃ Quot r'",
  "name": "Quot.congrRight",
  "kind": "def",
  "doc_string":
  "Quotients are congruent on equivalences under equality of their relation.\nAn alternative is just to use rewriting with `eq`, but then computational proofs get stuck. ",
  "args": ""},
 {"type": "Linarith.LinarithData → ℕ",
  "name": "Linarith.LinarithData.maxVar",
  "kind": "def",
  "doc_string":
  "The largest variable index that has not been (officially) eliminated. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "RatCast",
  "kind": "inductive",
  "doc_string": "Type class for the canonical homomorphism `ℚ → K`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α) → List α → Array α → List α",
  "name": "List.modifyLast.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `modifyLast`: `modifyLast.go f l acc = acc.toList ++ modifyLast f l`. ",
  "args": ""},
 {"type": "{α : Type u} → α → α → α → α → Array α",
  "name": "Array.mkArray4",
  "kind": "def",
  "doc_string": "Create array `#[a₁, a₂, a₃, a₄]` ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_→+o_»",
  "kind": "def",
  "doc_string": "Infix notation for `OrderAddMonoidHom`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Group",
  "kind": "inductive",
  "doc_string":
  "A `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "term!_",
  "kind": "def",
  "doc_string":
  "`not x`, or `!x`, is the boolean \"not\" operation (not to be confused\nwith `Not : Prop → Prop`, which is the propositional connective).\n",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.min",
  "kind": "def",
  "doc_string":
  "`Nat.min a b` is the minimum of `a` and `b`:\n* if `a ≤ b` then `Nat.min a b = a`\n* if `b ≤ a` then `Nat.min a b = b`\n",
  "args": ""},
 {"type": "{α : Type u} → [self : HasInf α] → α → α → α",
  "name": "HasInf.inf",
  "kind": "def",
  "doc_string": "Greatest lower bound (`\\glb` notation) ",
  "args": ""},
 {"type":
  "{α : Type u} → (β : Type v) → [inst : Group α] → [inst_1 : AddMonoid β] → [inst : DistribMulAction α β] → α → β ≃+ β",
  "name": "DistribMulAction.toAddEquiv",
  "kind": "def",
  "doc_string":
  "Each element of the group defines an additive monoid isomorphism.\n\nThis is a stronger version of `MulAction.toPerm`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a b : Q(«$α»)} →\n        Mathlib.Tactic.Ring.ExProd sα a →\n          Mathlib.Tactic.Ring.ExSum sα b → Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExSum sα) q(«$a» * «$b»)",
  "name": "Mathlib.Tactic.Ring.evalMul₁",
  "kind": "def",
  "doc_string":
  "Multiplies a monomial `va` to a polynomial `vb` to get a normalized result polynomial.\n\n* `a * 0 = 0`\n* `a * (b₁ + b₂) = (a * b₁) + (a * b₂)`\n",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  {A : Type u_2} →\n    {B : Type u_3} → [inst : Group G] → [inst_1 : MulAction G A] → [inst_2 : Monoid B] → MulDistribMulAction G (A → B)",
  "name": "arrowMulDistribMulAction",
  "kind": "def",
  "doc_string":
  "When `B` is a monoid, `ArrowAction` is additionally a `MulDistribMulAction`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b c : α}, a < b * c → b⁻¹ * a < c",
  "name": "inv_mul_lt_of_lt_mul",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `inv_mul_lt_iff_lt_mul`.",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → {x : MulOneClass M} → {x_1 : MulOneClass N} → Coe (M →* N) (OneHom M N)",
  "name": "MonoidHom.coeToOneHom",
  "kind": "def",
  "doc_string":
  "`MonoidHom` down-cast to a `OneHom`, forgetting the multiplicative property. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : HeytingAlgebra α] → (∀ (a : α), Heyting.IsRegular (a ⊔ aᶜ)) → BooleanAlgebra α",
  "name": "BooleanAlgebra.ofRegular",
  "kind": "def",
  "doc_string":
  "A Heyting algebra with regular excluded middle is a boolean algebra. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : NonAssocSemiring α] → [inst_1 : NonAssocSemiring β] → (α →+* β) ≃ (αᵐᵒᵖ →+* βᵐᵒᵖ)",
  "name": "RingHom.op",
  "kind": "def",
  "doc_string":
  "A ring hom `α →+* β` can equivalently be viewed as a ring hom `αᵐᵒᵖ →+* βᵐᵒᵖ`. This is the\naction of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Monoid M] → MulDistribMulAction (MulAut M) M",
  "name": "MulAut.applyMulDistribMulAction",
  "kind": "def",
  "doc_string":
  "The tautological action by `MulAut M` on `M`.\n\nThis generalizes `Function.End.applyMulAction`. ",
  "args": ""},
 {"type":
  "{α₁ : Type u_1} → {β₁ : Type u_2} → {β₂ : Type u_3} → {α₂ : Type u_4} → α₁ ≃ α₂ → (α₁ → β₁ ≃ β₂) → α₁ × β₁ ≃ α₂ × β₂",
  "name": "Equiv.prodShear",
  "kind": "def",
  "doc_string":
  "A variation on `Equiv.prodCongr` where the equivalence in the second component can depend\non the first component. A typical example is a shear mapping, explaining the name of this\ndeclaration. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b c : α}, b⁻¹ * a < c → a < b * c",
  "name": "lt_mul_of_inv_mul_lt",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `inv_mul_lt_iff_lt_mul`.",
  "args": ""},
 {"type": "∀ {α : Type u} {s : Set α}, Set.Subsingleton s → ¬Set.Nontrivial s",
  "name": "Set.Subsingleton.not_nontrivial",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Set.not_nontrivial_iff`.",
  "args": ""},
 {"type": "∀ {α : Type u} {s : Set α}, Nontrivial ↑s → Nontrivial α",
  "name": "Set.nontrivial_of_nontrivial_coe",
  "kind": "theorem",
  "doc_string":
  "A type with a set `s` whose `coe_sort` is a nontrivial type is nontrivial.\nFor the corresponding result for `Subtype`, see `Subtype.nontrivial_iff_exists_ne`. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [inst : Ring α] {a b : α}, a ∣ b + a ↔ a ∣ b",
  "name": "dvd_add_self_right",
  "kind": "theorem",
  "doc_string":
  "An element a divides the sum b + a if and only if a divides b.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : OrderedSemiring α] (a b c : α), a ≤ b → 0 ≤ c → c * a ≤ c * b",
  "name": "OrderedSemiring.mul_le_mul_of_nonneg_left",
  "kind": "def",
  "doc_string":
  "In an ordered semiring, we can multiply an inequality `a ≤ b` on the left\nby a non-negative element `0 ≤ c` to obtain `c * a ≤ c * b`. ",
  "args": ""},
 {"type": "{α : Type u} → [self : HasSubset α] → α → α → Prop",
  "name": "HasSubset.Subset",
  "kind": "def",
  "doc_string": "Subset relation: `a ⊆ b`  ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Conv.«command#conv_=>_»",
  "kind": "def",
  "doc_string":
  "The command `#conv tac => e` will run a conv tactic `tac` on `e`, and display the resulting\nexpression (discarding the proof).\nFor example, `#conv rw [true_and] => True ∧ False` displays `False`.\nThere are also shorthand commands for several common conv tactics:\n\n* `#whnf e` is short for `#conv whnf => e`\n* `#simp e` is short for `#conv simp => e`\n* `#norm_num e` is short for `#conv norm_num => e`\n* `#push_neg e` is short for `#conv push_neg => e`\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Lattice α] [self : IsWeakUpperModularLattice α] {a b : α}, a ⊓ b ⋖ a → a ⊓ b ⋖ b → a ⋖ a ⊔ b",
  "name": "IsWeakUpperModularLattice.covby_sup_of_inf_covby_covby",
  "kind": "def",
  "doc_string":
  "`a ⊔ b` covers `a` and `b` if `a` and `b` both cover `a ⊓ b`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (r s : α → α → Prop) → (∀ (x y : α), r x y → s x y) → Quot r → Quot s",
  "name": "Quot.factor",
  "kind": "def",
  "doc_string":
  "Weaken the relation of a quotient. This is the same as `Quot.map id`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : IsWeakLowerModularLattice α] {a b : α}, a ⋖ a ⊔ b → b ⋖ a ⊔ b → a ⊓ b ⋖ a",
  "name": "Covby.inf_of_sup_of_sup_left",
  "kind": "theorem",
  "doc_string": "**Alias** of `inf_covby_of_covby_sup_of_covby_sup_left`.",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HPow",
  "kind": "inductive",
  "doc_string":
  "The notation typeclass for heterogeneous exponentiation.\nThis enables the notation `a ^ b : γ` where `a : α`, `b : β`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : OrderedAddCommMonoid α] → OrderedAddCommGroup (AddUnits α)",
  "name": "AddUnits.orderedAddCommGroup",
  "kind": "def",
  "doc_string":
  "The units of an ordered commutative additive monoid form an ordered commutative\nadditive group.",
  "args": ""},
 {"type": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, b < a → ¬IsMin a",
  "name": "LT.lt.not_isMin",
  "kind": "theorem",
  "doc_string": "**Alias** of `not_isMin_of_lt`.",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} {inst : Add α} {inst_1 : Add β} {inst_2 : LE β}\n  [self : SubadditiveHomClass F α β] (f : F) (a b : α), ↑f (a + b) ≤ ↑f a + ↑f b",
  "name": "SubadditiveHomClass.map_add_le_add",
  "kind": "def",
  "doc_string":
  "the image of a sum is less or equal than the sum of the images. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {M : Type u_2} {N : Type u_3} {inst : Zero M} {inst_1 : Zero N} [self : ZeroHomClass F M N] (f : F),\n  ↑f 0 = 0",
  "name": "ZeroHomClass.map_zero",
  "kind": "def",
  "doc_string": "The proposition that the function preserves 0 ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {G : Type u_2} [inst : CompleteLattice α] [inst_1 : Group G] (f₁ f₂ : G →* α ≃o α) (g : G),\n  Function.Semiconj\n    (fun x => ⨆ g', ↑(RelIso.toRelEmbedding (↑f₁ g')⁻¹).toEmbedding (↑(RelIso.toRelEmbedding (↑f₂ g')).toEmbedding x))\n    ↑(RelIso.toRelEmbedding (↑f₂ g)).toEmbedding ↑(RelIso.toRelEmbedding (↑f₁ g)).toEmbedding",
  "name": "Function.supₛ_div_semiconj",
  "kind": "theorem",
  "doc_string":
  "Consider two actions `f₁ f₂ : G → α → α` of a group on a complete lattice by order\nisomorphisms. Then the map `x ↦ ⨆ g : G, (f₁ g)⁻¹ (f₂ g x)` semiconjugates each `f₁ g'` to `f₂ g'`.\n\nThis is a version of Proposition 5.4 from [Étienne Ghys, Groupes d'homéomorphismes du cercle et\ncohomologie bornée][ghys87:groupes]. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {s : Setoid α} {a b : α}, a ≈ b → Quotient.mk s a = Quotient.mk s b",
  "name": "Quotient.sound",
  "kind": "def",
  "doc_string":
  "The analogue of `Quot.sound`: If `a` and `b` are related by the equivalence relation,\nthen they have equal equivalence classes.\n",
  "args": ""},
 {"type": "{α : Sort u} → {p : α → Prop} → Subtype p → α",
  "name": "Subtype.val",
  "kind": "def",
  "doc_string":
  "If `s : {x // p x}` then `s.val : α` is the underlying element in the base\ntype. You can also write this as `s.1`, or simply as `s` when the type is\nknown from context. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : Semifield α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "name": "Semifield.mul_inv_cancel",
  "kind": "def",
  "doc_string": "Every nonzero element of a group with zero is invertible. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LT α] [inst_1 : WellFoundedGT α] {C : α → Prop} (a : α),\n  (∀ (x : α), (∀ (y : α), x < y → C y) → C x) → C a",
  "name": "WellFoundedGT.induction",
  "kind": "theorem",
  "doc_string": "Inducts on a well-founded `>` relation. ",
  "args": ""},
 {"type":
  "(R : Type u_1) → [inst : Mul R] → [inst_1 : Add R] → Group (RingAut R)",
  "name": "RingAut.instGroupRingAut",
  "kind": "def",
  "doc_string":
  "The group operation on automorphisms of a ring is defined by\n`fun g h => RingEquiv.trans h g`.\nThis means that multiplication agrees with composition, `(g*h)(x) = g (h x)`.\n",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {α : ι → Type u_2} →\n    [inst : PartialOrder ι] →\n      [inst_1 : BoundedOrder ι] →\n        [inst_2 : (i : ι) → Preorder (α i)] →\n          [inst_3 : OrderBot (α ⊥)] → [inst_4 : OrderTop (α ⊤)] → BoundedOrder (Lex ((i : ι) × α i))",
  "name": "Sigma.Lex.boundedOrder",
  "kind": "def",
  "doc_string": "The lexicographical linear order on a sigma type. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : ConditionallyCompleteLinearOrder α] → DecidableRel fun x x_1 => x < x_1",
  "name": "ConditionallyCompleteLinearOrder.decidable_lt",
  "kind": "def",
  "doc_string":
  "In a `ConditionallyCompleteLinearOrder`, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → (β → α) → Type (max u_1 u_2)",
  "name": "GaloisInsertion",
  "kind": "inductive",
  "doc_string":
  "A Galois insertion is a Galois connection where `l ∘ u = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual\nto `GaloisCoinsertion` ",
  "args": ""},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "name": "unexpandExistsUnique",
  "kind": "def",
  "doc_string":
  "Pretty-printing for `ExistsUnique`, following the same pattern as pretty printing\nfor `Exists`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] → (f : M →* N) → (M' : Submonoid M) → { x // x ∈ M' } →* { x // x ∈ Submonoid.map f M' }",
  "name": "MonoidHom.submonoidMap",
  "kind": "def",
  "doc_string":
  "The `MonoidHom` from a submonoid to its image.\nSee `MulEquiv.SubmonoidMap` for a variant for `MulEquiv`s. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α) → (α → α) → Prop",
  "name": "Function.Commute",
  "kind": "def",
  "doc_string":
  "Two maps `f g : α → α` commute if `f (g x) = g (f x)` for all `x : α`.\nGiven `h : function.commute f g` and `a : α`, we have `h a : f (g a) = g (f a)` and\n`h.comp_eq : f ∘ g = g ∘ f`.\n",
  "args": ""},
 {"type": "{C : Sort u_1} → PEmpty → C",
  "name": "PEmpty.elim",
  "kind": "def",
  "doc_string": "Ex falso, the nondependent eliminator for the `PEmpty` type. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Inhabited α] → List α → List α → Prop",
  "name": "List.Func.Equiv",
  "kind": "def",
  "doc_string":
  "Pointwise equality of lists. If lists are different lengths, compare with the default\nelement.\n",
  "args": ""},
 {"type": "{α : Type u} → {β : α → Type v} → (self : Sigma β) → β self.fst",
  "name": "Sigma.snd",
  "kind": "def",
  "doc_string":
  "The second component of a dependent pair. If `p : Sigma β` then `p.2 : β p.1`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → α → Set α",
  "name": "Set.Ioi",
  "kind": "def",
  "doc_string": "Left-open right-infinite interval ",
  "args": ""},
 {"type": "{α : Type u_1} → αᵒᵈ ≃ α",
  "name": "OrderDual.ofDual",
  "kind": "def",
  "doc_string":
  "`ofDual` is the identity function from the `OrderDual` of a linear order.  ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → M ≃* N → N → M",
  "name": "MulEquiv.Simps.symmApply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type":
  "{M₂ : Type u_1} →\n  {M₁ : Type u_2} →\n    [inst : Zero M₁] →\n      [inst_1 : One M₁] →\n        [inst_2 : Add M₁] →\n          [inst_3 : SMul ℕ M₁] →\n            [inst_4 : Neg M₁] →\n              [inst_5 : Sub M₁] →\n                [inst_6 : SMul ℤ M₁] →\n                  [inst_7 : NatCast M₁] →\n                    [inst_8 : IntCast M₁] →\n                      [inst_9 : AddGroupWithOne M₂] →\n                        (f : M₁ → M₂) →\n                          Function.Injective f →\n                            f 0 = 0 →\n                              f 1 = 1 →\n                                (∀ (x y : M₁), f (x + y) = f x + f y) →\n                                  (∀ (x : M₁), f (-x) = -f x) →\n                                    (∀ (x y : M₁), f (x - y) = f x - f y) →\n                                      (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                        (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) →\n                                          (∀ (n : ℕ), f ↑n = ↑n) → (∀ (n : ℤ), f ↑n = ↑n) → AddGroupWithOne M₁",
  "name": "Function.Injective.addGroupWithOne",
  "kind": "def",
  "doc_string":
  "A type endowed with `0`, `1` and `+` is an additive group with one, if it admits an injective\nmap that preserves `0`, `1` and `+` to an additive group with one.  See note\n[reducible non-instances]. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        {F : Type u_3} →\n          [mc : AddMonoidHomClass F M N] →\n            {f : F} → Function.Surjective ↑f → GaloisInsertion (AddSubmonoid.map f) (AddSubmonoid.comap f)",
  "name": "AddSubmonoid.giMapComap",
  "kind": "def",
  "doc_string":
  "`map f` and `comap f` form a `GaloisInsertion` when `f` is surjective. ",
  "args": ""},
 {"type":
  "{m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadEnv m] → [inst : Lean.MonadError m] → Lean.Name → m Unit",
  "name": "Mathlib.Prelude.Rename.ensureUnused",
  "kind": "def",
  "doc_string":
  "Checks that `id` has not already been `#align`ed or `#noalign`ed. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {a b c d : α},\n  c ≠ 0 → d ≠ 0 → (a * d - b * c) / (c * d) ≤ 0 → a / c ≤ b / d",
  "name": "div_le_div_of_mul_sub_mul_div_nonpos",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `mul_sub_mul_div_mul_nonpos_iff`.",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : AddGroup G] [inst_1 : SubtractionMonoid H]\n  [inst_2 : AddMonoidHomClass F G H] (f : F) (a b : G), ↑f (a + -b) = ↑f a + -↑f b",
  "name": "map_add_neg",
  "kind": "theorem",
  "doc_string": "Additive group homomorphisms preserve subtraction.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {G : Type u_2} [inst : ConditionallyCompleteLattice α] [inst_1 : Group G] (f₁ f₂ : G →* α ≃o α),\n  (∀ (x : α),\n      BddAbove\n        (Set.range fun g =>\n          ↑(RelIso.toRelEmbedding (↑f₁ g)⁻¹).toEmbedding (↑(RelIso.toRelEmbedding (↑f₂ g)).toEmbedding x))) →\n    ∀ (g : G),\n      Function.Semiconj\n        (fun x =>\n          ⨆ g', ↑(RelIso.toRelEmbedding (↑f₁ g')⁻¹).toEmbedding (↑(RelIso.toRelEmbedding (↑f₂ g')).toEmbedding x))\n        ↑(RelIso.toRelEmbedding (↑f₂ g)).toEmbedding ↑(RelIso.toRelEmbedding (↑f₁ g)).toEmbedding",
  "name": "Function.csupₛ_div_semiconj",
  "kind": "theorem",
  "doc_string":
  "Consider two actions `f₁ f₂ : G → α → α` of a group on a conditionally complete lattice by order\nisomorphisms. Suppose that each set $s(x)=\\{f_1(g)^{-1} (f_2(g)(x)) | g \\in G\\}$ is bounded above.\nThen the map `x ↦ supₛ s(x)` semiconjugates each `f₁ g'` to `f₂ g'`.\n\nThis is a version of Proposition 5.4 from [Étienne Ghys, Groupes d'homéomorphismes du cercle et\ncohomologie bornée][ghys87:groupes]. ",
  "args": ""},
 {"type": "{α : Type u} → List α → ℕ → List α",
  "name": "List.eraseIdx",
  "kind": "def",
  "doc_string":
  "`O(i)`. `eraseIdx l i` removes the `i`'th element of the list `l`.\n* `erase [a, b, c, d, e] 0 = [b, c, d, e]`\n* `erase [a, b, c, d, e] 1 = [a, c, d, e]`\n* `erase [a, b, c, d, e] 5 = [a, b, c, d, e]`\n",
  "args": ""},
 {"type": "ZNum → ZNum",
  "name": "ZNum.bit1",
  "kind": "def",
  "doc_string":
  "`bit1 x` appends a `1` to the end of `x`, mapping `x` to `2 * x + 1`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (self : R ≃+* S)\n  (x y : R), Equiv.toFun self.toEquiv (x * y) = Equiv.toFun self.toEquiv x * Equiv.toFun self.toEquiv y",
  "name": "RingEquiv.map_mul'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves multiplication ",
  "args": ""},
 {"type":
  "{X : Type u_1} → (r : X → X → Prop) → (p : X → Prop) → Subtype.val ⁻¹'o r ↪r r",
  "name": "Subtype.relEmbedding",
  "kind": "def",
  "doc_string":
  "The induced relation on a subtype is an embedding under the natural inclusion. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {p q : α → Prop} → (∀ {x : α}, q x → p x) → { x // q ↑x } ≃ Subtype q",
  "name": "Equiv.subtypeSubtypeEquivSubtype",
  "kind": "def",
  "doc_string":
  "If the outer subtype has more restrictive predicate than the inner one,\nthen we can drop the latter. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.tacticTrans___",
  "kind": "def",
  "doc_string":
  "`trans` applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation,\nthat is, a relation which has a transitivity lemma tagged with the attribute [trans].\n\n* `trans s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`.\n* If `s` is omitted, then a metavariable is used instead.\n",
  "args": ""},
 {"type": "{α : Sort u} → [self : SizeOf α] → α → ℕ",
  "name": "SizeOf.sizeOf",
  "kind": "def",
  "doc_string":
  "The \"size\" of an element, a natural number which decreases on fields of\neach inductive type. ",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HAnd",
  "kind": "inductive",
  "doc_string":
  "The typeclass behind the notation `a &&& b : γ` where `a : α`, `b : β`. ",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  {H : Type u_2} → [inst : MulOneClass G] → [inst_1 : MulOneClass H] → G ≃* H ≃ (Additive G ≃+ Additive H)",
  "name": "MulEquiv.toAdditive",
  "kind": "def",
  "doc_string": "Reinterpret `G ≃* H` as `Additive G ≃+ Additive H`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Max α] → List α → Option α",
  "name": "List.maximum?",
  "kind": "def",
  "doc_string":
  "Returns the largest element of the list, if it is not empty.\n* `[].maximum? = none`\n* `[4].maximum? = some 4`\n* `[1, 4, 2, 10, 6].maximum? = some 10`\n",
  "args": ""},
 {"type": "{α : Type u} → α → α → α → α → α → α → Array α",
  "name": "Array.mkArray6",
  "kind": "def",
  "doc_string": "Create array `#[a₁, a₂, a₃, a₄, a₅, a₆]` ",
  "args": ""},
 {"type":
  "{p : Prop} → {q : Sort u} → [dec : Decidable p] → (p → q) → (¬p → q) → q",
  "name": "Decidable.by_cases",
  "kind": "def",
  "doc_string": "**Alias** of `Decidable.byCases`.",
  "args": ""},
 {"type": "∀ {α : Type u} [self : BooleanAlgebra α] (x : α), ⊤ ≤ x ⊔ xᶜ",
  "name": "BooleanAlgebra.top_le_sup_compl",
  "kind": "def",
  "doc_string": "The supremum of `x` and `xᶜ` is at least `⊤` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a : α}, a⁻¹ ≤ 1 ↔ 1 ≤ a",
  "name": "Right.inv_le_one_iff",
  "kind": "theorem",
  "doc_string": "Uses `right` co(ntra)variant. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b ≤ a → a ⊔ b = a",
  "name": "sup_of_le_left",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `sup_eq_left`.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Mul M] {s : Set M} {p : M → M → Prop} {x y : M},\n  x ∈ Subsemigroup.closure s →\n    y ∈ Subsemigroup.closure s →\n      (∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → p x y) →\n        (∀ (x y z : M), p x z → p y z → p (x * y) z) → (∀ (x y z : M), p z x → p z y → p z (x * y)) → p x y",
  "name": "Subsemigroup.closure_induction₂",
  "kind": "theorem",
  "doc_string":
  "An induction principle for closure membership for predicates with two arguments.  ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} [inst : GroupWithZero R] [inst_1 : AddMonoid M] [inst_2 : DistribMulAction R M],\n  NoZeroSMulDivisors R M",
  "name": "GroupWithZero.toNoZeroSMulDivisors",
  "kind": "def",
  "doc_string":
  "This instance applies to `DivisionSemiring`s, in particular `nnreal` and `nnrat`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → M ≃* N → M → N",
  "name": "MulEquiv.Simps.apply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c : α},\n  a + b ≤ c → a ≤ c - b",
  "name": "le_sub_right_of_add_le",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `le_sub_iff_add_le`.",
  "args": ""},
 {"type": "ZNum → ZNum → ZNum",
  "name": "ZNum.add",
  "kind": "def",
  "doc_string": "Addition of `ZNum`s. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Monoid α] → αˣ → α",
  "name": "Units.val",
  "kind": "def",
  "doc_string": "The underlying value in the base `Monoid`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a : α} [inst_1 : NoMaxOrder α], Nonempty ↑(Set.Ioi a)",
  "name": "Set.nonempty_Ioi_subtype",
  "kind": "def",
  "doc_string":
  "In an order without maximal elements, the intervals `Ioi` are nonempty. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {a : R} [inst : Monoid R] {n : ℕ}, 0 < n → (IsRightRegular (a ^ n) ↔ IsRightRegular a)",
  "name": "IsRightRegular.pow_iff",
  "kind": "theorem",
  "doc_string":
  "An element `a` is right-regular if and only if a positive power of `a` is right-regular. ",
  "args": ""},
 {"type":
  "{I : Type u} → (f : I → Type v) → [inst : (i : I) → Mul (f i)] → (i : I) → ((i : I) → f i) →ₙ* f i",
  "name": "Pi.evalMulHom",
  "kind": "def",
  "doc_string":
  "Evaluation of functions into an indexed collection of semigroups at a point is a semigroup\nhomomorphism.\nThis is `Function.eval i` as a `MulHom`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "OfScientific",
  "kind": "inductive",
  "doc_string":
  "For decimal and scientific numbers (e.g., `1.23`, `3.12e10`).\nExamples:\n- `OfScientific.ofScientific 123 true 2`    represents `1.23`\n- `OfScientific.ofScientific 121 false 100` represents `121e100`\n",
  "args": ""},
 {"type":
  "Type u_1 →\n  (α : outParam (Type u_2)) → (β : outParam (Type u_3)) → [inst : LE α] → [inst : LE β] → Type (max (max u_1 u_2) u_3)",
  "name": "OrderHomClass",
  "kind": "def",
  "doc_string":
  "`OrderHomClass F α b` asserts that `F` is a type of `≤`-preserving morphisms. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {α : ι → Type u_2} →\n    [inst : PartialOrder ι] →\n      [inst_1 : BoundedOrder ι] →\n        [inst_2 : (i : ι) → Preorder (α i)] →\n          [inst_3 : OrderBot (α ⊥)] → [inst_4 : OrderTop (α ⊤)] → BoundedOrder (Lex ((i : ι) ×' α i))",
  "name": "PSigma.Lex.boundedOrder",
  "kind": "def",
  "doc_string": "The lexicographical linear order on a sigma type. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {α : ι → Type u_2} →\n    [inst : PartialOrder ι] → [inst : (i : ι) → PartialOrder (α i)] → PartialOrder (Lex ((i : ι) ×' α i))",
  "name": "PSigma.Lex.partialOrder",
  "kind": "def",
  "doc_string":
  "Dictionary / lexicographic partial_order for dependent pairs. ",
  "args": ""},
 {"type": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "name": "Iff.mp",
  "kind": "def",
  "doc_string":
  "Modus ponens for if and only if. If `a ↔ b` and `a`, then `b`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : HasSSubset α]\n  [inst_2 : IsNonstrictStrictOrder α (fun x x_1 => x ⊆ x_1) fun x x_1 => x ⊂ x_1] {a b : α}, a ⊂ b → a ⊆ b",
  "name": "HasSSubset.SSubset.subset",
  "kind": "theorem",
  "doc_string": "**Alias** of `subset_of_ssubset`.",
  "args": ""},
 {"type": "{α : Type u_1} → List α → Option α",
  "name": "List.last'",
  "kind": "def",
  "doc_string":
  "`last' xs` returns the last element of `xs` if `xs` is non-empty; it returns `none` otherwise.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.RingNF.ring1NF",
  "kind": "def",
  "doc_string":
  "Tactic for solving equations of *commutative* (semi)rings, allowing variables in the exponent.\n\n* This version of `ring1` uses `ring_nf` to simplify in atoms.\n* The variant `ring1_nf!` will use a more aggressive reducibility setting\n  to determine equality of atoms.\n",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} [inst : Group G] (a : G), ↑(Equiv.symm (Equiv.mulRight a)) = fun x => x * a⁻¹",
  "name": "Equiv.mulRight_symm_apply",
  "kind": "theorem",
  "doc_string":
  "Extra simp lemma that `dsimp` can use. `simp` will never use this. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ⩿ b → a ⋖ b ∨ a = b",
  "name": "Wcovby.covby_or_eq",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `wcovby_iff_covby_or_eq`.",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {M : Type u_3} →\n      [inst : AddZeroClass M] →\n        [inst_1 : DistribSMul R M] →\n          [inst_2 : SMul S M] →\n            (f : R → S) → Function.Surjective f → (∀ (c : R) (x : M), f c • x = c • x) → DistribSMul S M",
  "name": "Function.Surjective.distribSMulLeft",
  "kind": "def",
  "doc_string":
  "Push forward the multiplication of `R` on `M` along a compatible surjective map `f : R → S`.\n\nSee also `Function.Surjective.distribMulActionLeft`.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : CancelMonoidWithZero R] {a : R}, a ≠ 0 → IsRegular a",
  "name": "isRegular_of_ne_zero",
  "kind": "theorem",
  "doc_string": "Non-zero elements of an integral domain are regular. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : NonAssocSemiring α] →\n    {β : Type v} →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Mul β] →\n            [inst_4 : Add β] →\n              [inst_5 : SMul ℕ β] →\n                [inst_6 : NatCast β] →\n                  (f : β → α) →\n                    Function.Injective f →\n                      f 0 = 0 →\n                        f 1 = 1 →\n                          (∀ (x y : β), f (x + y) = f x + f y) →\n                            (∀ (x y : β), f (x * y) = f x * f y) →\n                              (∀ (x : β) (n : ℕ), f (n • x) = n • f x) → (∀ (n : ℕ), f ↑n = ↑n) → NonAssocSemiring β",
  "name": "Function.Injective.nonAssocSemiring",
  "kind": "def",
  "doc_string":
  "Pullback a `NonAssocSemiring` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Array String → IO Mathlib.Tactic.Polyrith.SageResult",
  "name": "Mathlib.Tactic.Polyrith.sageOutput",
  "kind": "def",
  "doc_string":
  "This tactic calls python from the command line with the args in `arg_list`.\nThe output printed to the console is parsed as a `Json`.\nIt assumes that `python3` is available on the path.\n",
  "args": ""},
 {"type": "ℤ → ℤ → ℤ",
  "name": "Int.lor",
  "kind": "def",
  "doc_string": "`lor` takes two integers and returns their bitwise `or`",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort u_1} → [inst : Nonempty α] → (α → β) → β → α",
  "name": "Function.invFun",
  "kind": "def",
  "doc_string":
  "The inverse of a function (which is a left inverse if `f` is injective\nand a right inverse if `f` is surjective). ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : AddZeroClass M₂] →\n          (f : M₁ → M₂) → Function.Injective f → f 0 = 0 → (∀ (x y : M₁), f (x + y) = f x + f y) → AddZeroClass M₁",
  "name": "Function.Injective.addZeroClass",
  "kind": "def",
  "doc_string":
  "A type endowed with `0` and `+` is an `AddZeroClass`, if it admits an\ninjective map that preserves `0` and `+` to an `AddZeroClass`.",
  "args": ""},
 {"type": "{α : Type u_1} → HasInf (Setoid α)",
  "name": "Setoid.instHasInfSetoid",
  "kind": "def",
  "doc_string": "The infimum of two equivalence relations. ",
  "args": ""},
 {"type": "{β : Sort v} → (β → β → Prop) → Prop",
  "name": "Symmetric",
  "kind": "def",
  "doc_string": "A relation is symmetric if `x ≺ y` implies `y ≺ x`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a : Q(ℕ)} →\n        Mathlib.Tactic.Ring.ExBase Mathlib.Tactic.Ring.sℕ a →\n          Mathlib.Tactic.Ring.RingM (Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExBase sα) q(↑«$a»))",
  "name": "Mathlib.Tactic.Ring.ExBase.evalNatCast",
  "kind": "opaque",
  "doc_string":
  "Applies `Nat.cast` to a nat polynomial to produce a polynomial in `α`.\n\n* An atom `e` causes `↑e` to be allocated as a new atom.\n* A sum delegates to `ExSum.evalNatCast`.\n",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HMul α β γ] → α → β → γ",
  "name": "HMul.hMul",
  "kind": "def",
  "doc_string":
  "`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "{q p : Prop} →\n  String → (q → p) → SlimCheck.TestResult p → optParam (Unit ⊕' (p → q)) (PSum.inl ()) → SlimCheck.TestResult q",
  "name": "SlimCheck.TestResult.addInfo",
  "kind": "def",
  "doc_string":
  "When we assign a value to a universally quantified variable,\nwe record that value using this function so that our counter-examples\ncan be informative. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {α : Type u_2} → {β : Type u_3} → [inst : Preorder α] → [inst : Preorder β] → (ι → α) → (ι → β) → Set ι → Prop",
  "name": "MonovaryOn",
  "kind": "def",
  "doc_string":
  "`f` monovaries with `g` on `s` if `g i < g j` implies `f i ≤ f j` for all `i, j ∈ s`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u} [self : EuclideanDomain R] (a : R) {b : R}, b ≠ 0 → EuclideanDomain.r (EuclideanDomain.remainder a b) b",
  "name": "EuclideanDomain.remainder_lt",
  "kind": "def",
  "doc_string": "The relation `r` satisfies `r (a % b) b`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        (oi : α ≃o β) →\n          GaloisCoinsertion ↑(RelIso.toRelEmbedding oi).toEmbedding\n            ↑(RelIso.toRelEmbedding (OrderIso.symm oi)).toEmbedding",
  "name": "OrderIso.toGaloisCoinsertion",
  "kind": "def",
  "doc_string":
  "Makes a Galois coinsertion from an order-preserving bijection. ",
  "args": ""},
 {"type":
  "(α : Sort u_1) → (β : Sort u_2) → [inst : IsEmpty α] → (α → β) ≃ PUnit",
  "name": "Equiv.arrowPUnitOfIsEmpty",
  "kind": "def",
  "doc_string":
  "The sort of maps from a type that `IsEmpty` is equivalent to `PUnit`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → Array α → Aesop.UnorderedArraySet α",
  "name": "Aesop.UnorderedArraySet.ofArraySlow",
  "kind": "def",
  "doc_string": "O(n^2) ",
  "args": ""},
 {"type":
  "List Lean.Expr →\n  List (Lean.Expr × Lean.Expr) → List (Option Lean.Expr) × List (Lean.Expr × Lean.Expr) × (Lean.Expr → Lean.Expr)",
  "name": "Mathlib.Tactic.MkIff.compactRelation",
  "kind": "opaque",
  "doc_string":
  "`compactRelation bs as_ps`: Produce a relation of the form:\n```lean\nR := λ as ∃ bs, Λ_i a_i = p_i[bs]\n```\nThis relation is user-visible, so we compact it by removing each `b_j` where a `p_i = b_j`, and\nhence `a_i = b_j`. We need to take care when there are `p_i` and `p_j` with `p_i = p_j = b_k`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : DivisionMonoid β] (f : α →* β) (g h : α),\n  ↑f (g / h) = ↑f g / ↑f h",
  "name": "MonoidHom.map_div",
  "kind": "theorem",
  "doc_string": "Group homomorphisms preserve division. ",
  "args": ""},
 {"type":
  "Lean.Name → Array ParsedProjectionData → Lean.Expr → List Lean.Level → Lean.CoreM (Array ParsedProjectionData)",
  "name": "simpsFindAutomaticProjections",
  "kind": "def",
  "doc_string":
  "Auxilliary function for `simpsGetRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from algebraic notation classes, like `+`. ",
  "args": ""},
 {"type": "Sort u → Sort (max u (v + 1))",
  "name": "HasEquiv",
  "kind": "inductive",
  "doc_string":
  "`HasEquiv α` is the typeclass which supports the notation `x ≈ y` where `x y : α`.",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Preorder α] (a : α), a ≤ a",
  "name": "le_refl",
  "kind": "theorem",
  "doc_string": "The relation `≤` on a preorder is reflexive. ",
  "args": ""},
 {"type": "{ε σ α : Type u} → ε → EStateM ε σ α",
  "name": "EStateM.throw",
  "kind": "def",
  "doc_string": "The `throw` operation of the `EStateM` monad. ",
  "args": ""},
 {"type": "Type",
  "name": "ToAdditive.Config",
  "kind": "inductive",
  "doc_string":
  "`Config` is the type of the arguments that can be provided to `to_additive`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : LE α] → [inst_1 : LE β] → (Lex (α ⊕ β))ᵒᵈ ≃o Lex (βᵒᵈ ⊕ αᵒᵈ)",
  "name": "OrderIso.sumLexDualAntidistrib",
  "kind": "def",
  "doc_string":
  "`OrderDual` is antidistributive over `⊕ₗ` up to an order isomorphism. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → {p : α → Prop} → (e : α ≃ β) → { a // p a } ≃ { b // p (↑(Equiv.symm e) b) }",
  "name": "Equiv.subtypeEquivOfSubtype'",
  "kind": "def",
  "doc_string":
  "If `α ≃ β`, then for any predicate `p : α → Prop` the subtype `{a // p a}` is equivalent\nto the subtype `{b // p (e.symm b)}`. This version is used by `equiv_rw`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "linarith",
  "kind": "def",
  "doc_string":
  "`linarith` attempts to find a contradiction between hypotheses that are linear (in)equalities.\nEquivalently, it can prove a linear inequality by assuming its negation and proving `false`.\n\nIn theory, `linarith` should prove any goal that is true in the theory of linear arithmetic over\nthe rationals. While there is some special handling for non-dense orders like `nat` and `int`,\nthis tactic is not complete for these theories and will not prove every true goal. It will solve\ngoals over arbitrary types that instantiate `LinearOrderedCommRing`.\n\nAn example:\n```lean\nexample (x y z : ℚ) (h1 : 2*x  < 3*y) (h2 : -4*x + 2*z < 0)\n        (h3 : 12*y - 4* z < 0)  : false :=\nby linarith\n```\n\n`linarith` will use all appropriate hypotheses and the negation of the goal, if applicable.\n\n`linarith [t1, t2, t3]` will additionally use proof terms `t1, t2, t3`.\n\n`linarith only [h1, h2, h3, t1, t2, t3]` will use only the goal (if relevant), local hypotheses\n`h1`, `h2`, `h3`, and proofs `t1`, `t2`, `t3`. It will ignore the rest of the local context.\n\n`linarith!` will use a stronger reducibility setting to try to identify atoms. For example,\n```lean\nexample (x : ℚ) : id x ≥ x :=\nby linarith\n```\nwill fail, because `linarith` will not identify `x` and `id x`. `linarith!` will.\nThis can sometimes be expensive.\n\n`linarith (config := { .. })` takes a config object with five\noptional arguments:\n* `discharger` specifies a tactic to be used for reducing an algebraic equation in the\n  proof stage. The default is `ring`. Other options include `simp` for basic\n  problems.\n* `transparency` controls how hard `linarith` will try to match atoms to each other. By default\n  it will only unfold `reducible` definitions.\n* If `split_hypotheses` is true, `linarith` will split conjunctions in the context into separate\n  hypotheses.\n* If `exfalso` is false, `linarith` will fail when the goal is neither an inequality nor `false`.\n  (True by default.)\n* `restrict_type` (not yet implemented in mathlib4)\n  will only use hypotheses that are inequalities over `tp`. This is useful\n  if you have e.g. both integer and rational valued inequalities in the local context, which can\n  sometimes confuse the tactic.\n\nA variant, `nlinarith`, does some basic preprocessing to handle some nonlinear goals.\n\nThe option `set_option trace.linarith true` will trace certain intermediate stages of the `linarith`\nroutine.\n",
  "args": ""},
 {"type": "(a : Prop) → Decidable a",
  "name": "Classical.propDecidable",
  "kind": "def",
  "doc_string": "All propositions are `Decidable`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : SuccOrder α] [inst_2 : IsSuccArchimedean α] {P : α → Prop} {m : α},\n  P m → (∀ (n : α), m ≤ n → P n → P (Order.succ n)) → ∀ ⦃n : α⦄, m ≤ n → P n",
  "name": "Succ.rec",
  "kind": "theorem",
  "doc_string":
  "Induction principle on a type with a `SuccOrder` for all elements above a given element `m`. ",
  "args": ""},
 {"type":
  "Lean.Name →\n  optParam Bool false →\n    optParam (Array ProjectionRule) #[] → optParam Bool false → Lean.CoreM (List Lean.Name × Array ProjectionData)",
  "name": "simpsGetRawProjections",
  "kind": "def",
  "doc_string":
  "Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in a parameter of the attribute `@[simpsStructure]`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nattribute instead. See the documentation for this attribute for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``simpsGetRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has the attribute `@[simpsStructure]`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedField α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "name": "LinearOrderedField.mul_inv_cancel",
  "kind": "def",
  "doc_string": "For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {α : ι → Type u_2} → [inst : Preorder ι] → [inst : (i : ι) → PartialOrder (α i)] → PartialOrder (Lex ((i : ι) × α i))",
  "name": "Sigma.Lex.partialOrder",
  "kind": "def",
  "doc_string": "The lexicographical partial order on a sigma type. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Union",
  "kind": "inductive",
  "doc_string": "Notation type class for the union operation `∪`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : AddMonoid α] → AddGroup (AddUnits α)",
  "name": "AddUnits.instAddGroupAddUnits",
  "kind": "def",
  "doc_string": "Additive units of an additive monoid form an additive group.",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : LinearOrder α], IsIdempotent α max",
  "name": "max_idem",
  "kind": "def",
  "doc_string": "An instance asserting that `max a a = a` ",
  "args": ""},
 {"type": "Bool → ℕ",
  "name": "Bool.toNat",
  "kind": "def",
  "doc_string": "convert a `bool` to a `ℕ`, `false -> 0`, `true -> 1` ",
  "args": ""},
 {"type": "{p : Prop} → p → p ≃ PUnit",
  "name": "Equiv.propEquivPUnit",
  "kind": "def",
  "doc_string":
  "The `Sort` of proofs of a true proposition is equivalent to `PUnit`. ",
  "args": ""},
 {"type": "∀ {a b : Prop}, ¬(a ∧ b) ↔ ¬a ∨ ¬b",
  "name": "not_and_or",
  "kind": "theorem",
  "doc_string":
  "One of de Morgan's laws: the negation of a conjunction is logically equivalent to the\ndisjunction of the negations. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "DivisionMonoid",
  "kind": "inductive",
  "doc_string":
  "A `DivisionMonoid` is a `DivInvMonoid` with involutive inversion and such that\n`(a * b)⁻¹ = b⁻¹ * a⁻¹` and `a * b = 1 → a⁻¹ = b`.\n\nThis is the immediate common ancestor of `Group` and `GroupWithZero`. ",
  "args": ""},
 {"type": "(G : Type u) → [inst : Mul G] → Prop",
  "name": "IsCancelMul",
  "kind": "inductive",
  "doc_string": "A mixin for cancellative multiplication. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → [inst : Zero R] → [inst : One R] → [inst : Add R] → ℕ → R",
  "name": "Nat.binCast",
  "kind": "def",
  "doc_string":
  "Computationally friendlier cast than `Nat.unaryCast`, using binary representation. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_4} {β : Type u_5} {γ : Type u_3} {f : α → β → γ} {a : Option α} {b : Option β} {δ : Type u_1}\n  {β' : Type u_2} {g : γ → δ} {f' : α → β' → δ} {g' : β → β'},\n  (∀ (a : α) (b : β), g (f a b) = f' a (g' b)) → Option.map g (Option.map₂ f a b) = Option.map₂ f' a (Option.map g' b)",
  "name": "Option.map_map₂_distrib_right",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Option.map_map₂_right_comm`. ",
  "args": ""},
 {"type": "Mathlib.Prelude.Rename.NameEntry → Lean.Name",
  "name": "Mathlib.Prelude.Rename.NameEntry.n4",
  "kind": "def",
  "doc_string": "The lean 4 name, or `.anonymous` for a `#noalign`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : One α] → [inst : Add α] → [inst : Zero α] → Num → α",
  "name": "castNum",
  "kind": "def",
  "doc_string":
  "`castNum` casts a `Num` into any type which has `0`, `1` and `+`. ",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → {F : Sort u_1} → [inst : EquivLike F α β] → F → α ≃ β",
  "name": "EquivLike.toEquiv",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `EquivLike F α β` into an actual\n`Equiv`. This is declared as the default coercion from `F` to `α ≃ β`. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → (α → β) → List α → List β",
  "name": "List.map",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `map f l` applies `f` to each element of the list.\n* `map f [a, b, c] = [f a, f b, f c]`\n",
  "args": ""},
 {"type": "Lean.Elab.Tactic.Tactic",
  "name": "Mathlib.Tactic.Conv.elabDischargeConv",
  "kind": "def",
  "doc_string": "Elaborator for the `discharge` tactic. ",
  "args": ""},
 {"type":
  "{F : Type u → Type v} →\n  [inst : Applicative F] →\n    {G : Type u → Type w} →\n      [inst_1 : Applicative G] →\n        {H : Type u → Type s} →\n          [inst_2 : Applicative H] →\n            ApplicativeTransformation G H → ApplicativeTransformation F G → ApplicativeTransformation F H",
  "name": "ApplicativeTransformation.comp",
  "kind": "def",
  "doc_string": "The composition of applicative transformations. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Div",
  "kind": "inductive",
  "doc_string":
  "The homogeneous version of `HDiv`: `a / b : α` where `a b : α`. ",
  "args": ""},
 {"type":
  "Lean.Syntax →\n  Bool →\n    Lean.FVarId →\n      optParam Lean.Occurrences Lean.Occurrences.all →\n        optParam Lean.Meta.Rewrite.Config\n            { transparency := Lean.Meta.TransparencyMode.reducible, offsetCnstrs := true } →\n          Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Tactic.rewriteLocalDecl'",
  "kind": "def",
  "doc_string":
  "Variant of `rewriteLocalDecl` that allows to use `Occurrences`.\n\nThis def should be in Core. ",
  "args": ""},
 {"type": "{α : Type u} → [self : HasSup α] → α → α → α",
  "name": "HasSup.sup",
  "kind": "def",
  "doc_string": "Least upper bound (`\\lub` notation) ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β]\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {f g : β → α},\n  Monotone f → StrictMono g → StrictMono fun x => f x * g x",
  "name": "Monotone.mul_strict_mono'",
  "kind": "theorem",
  "doc_string":
  "The product of a monotone function and a strictly monotone function is strictly monotone. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : αᵒᵈ}, b ⩿ a → ↑OrderDual.ofDual a ⩿ ↑OrderDual.ofDual b",
  "name": "Wcovby.ofDual",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `ofDual_wcovby_ofDual_iff`.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Monoid α] → α → ConjClasses α",
  "name": "ConjClasses.mk",
  "kind": "def",
  "doc_string":
  "The canonical quotient map from a monoid `α` into the `ConjClasses` of `α` ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] (self : C ⥤ D)\n  (X : C), Prefunctor.map self.toPrefunctor (𝟙 X) = 𝟙 (Prefunctor.obj self.toPrefunctor X)",
  "name": "CategoryTheory.Functor.map_id",
  "kind": "def",
  "doc_string": "A functor preserves identity morphisms. ",
  "args": ""},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "name": "CoeHead",
  "kind": "inductive",
  "doc_string":
  "`CoeHead α β` is for coercions that are applied from left-to-right at most once\nat beginning of the coercion chain.\n",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Mul M] → M →ₙ* M",
  "name": "MulHom.id",
  "kind": "def",
  "doc_string": "The identity map from a type with multiplication to itself. ",
  "args": ""},
 {"type": "{α : Type u} → (α → Bool) → List α → List α",
  "name": "List.takeWhile",
  "kind": "def",
  "doc_string":
  "`O(|xs|)`. Returns the longest initial segment of `xs` for which `p` returns true.\n* `takeWhile (· > 5) [7, 6, 4, 8] = [7, 6]`\n* `takeWhile (· > 5) [7, 6, 6, 8] = [7, 6, 6, 8]`\n",
  "args": ""},
 {"type":
  "{m : Type u₁ → Type u₂} →\n  {ρ : Type u} →\n    {α : Type v} →\n      {d : Membership α ρ} →\n        [self : ForIn' m ρ α d] →\n          {β : Type u₁} → [inst : Monad m] → (x : ρ) → β → ((a : α) → a ∈ x → β → m (ForInStep β)) → m β",
  "name": "ForIn'.forIn'",
  "kind": "def",
  "doc_string":
  "`forIn' x b f : m β` runs a for-loop in the monad `m` with additional state `β`.\nThis traverses over the \"contents\" of `x`, and passes the elements `a : α` along\nwith a proof that `a ∈ x` to `f : (a : α) → a ∈ x → β → m (ForInStep β)`.\n`b : β` is the initial state, and the return value\nof `f` is the new state as well as a directive `.done` or `.yield`\nwhich indicates whether to abort early or continue iteration. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : AddRightCancelMonoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 0 = 0 →\n                  (∀ (x y : M₁), f (x + y) = f x + f y) →\n                    (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) → AddRightCancelMonoid M₁",
  "name": "Function.Injective.addRightCancelMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `0` and `+` is an additive left cancel monoid,if it\nadmits an injective map that preserves `0` and `+` to an additive left cancel monoid.",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_→ₙ+*_»",
  "kind": "def",
  "doc_string":
  "`α →ₙ+* β` denotes the type of non-unital ring homomorphisms from `α` to `β`. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        (P : D → Prop) →\n          (F : C ⥤ D) → (∀ (X : C), P (Prefunctor.obj F.toPrefunctor X)) → C ⥤ CategoryTheory.FullSubcategory P",
  "name": "CategoryTheory.FullSubcategory.lift",
  "kind": "def",
  "doc_string":
  "A functor which maps objects to objects satisfying a certain property induces a lift through\nthe full subcategory of objects satisfying that property. ",
  "args": ""},
 {"type": "{M : Type u} → [inst : AddCommMonoid M] → ℕ → M →+ M",
  "name": "nsmulAddMonoidHom",
  "kind": "def",
  "doc_string":
  "Multiplication by a natural `n` on a commutative additive\nmonoid, considered as a morphism of additive monoids.",
  "args": ""},
 {"type":
  "(R : Type u_1) → [inst : Mul R] → [inst_1 : Add R] → RingAut R →* MulAut R",
  "name": "RingAut.toMulAut",
  "kind": "def",
  "doc_string":
  "Monoid homomorphism from ring automorphisms to multiplicative automorphisms. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedAddCommGroup α] (a b : α), max a b = if a ≤ b then b else a",
  "name": "LinearOrderedAddCommGroup.max_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `maxOfLe`. ",
  "args": ""},
 {"type": "∀ {α : Type u} {s : Set α}, Set.Nonempty s → Nonempty ↑s",
  "name": "Set.Nonempty.coe_sort",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Set.nonempty_coe_sort`.",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → (M →+ N) → M → N",
  "name": "AddMonoidHom.Simps.apply",
  "kind": "def",
  "doc_string": "See Note custom simps projection",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r : α → α → Prop} [inst : IsRefl α r] {x y : α}, x ≠ y → r x y ↔ r x y",
  "name": "reflexive_ne_imp_iff",
  "kind": "theorem",
  "doc_string":
  "If a reflexive relation `r : α → α → Prop` holds over `x y : α`,\nthen it holds whether or not `x ≠ y`. Unlike `Reflexive.ne_imp_iff`, this uses `[IsRefl α r]`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Setoid β → Setoid α",
  "name": "Setoid.comap",
  "kind": "def",
  "doc_string":
  "Given a function `f : α → β`, an equivalence relation `r` on `β` induces an equivalence\nrelation on `α` defined by '`x ≈ y` iff `f(x)` is related to `f(y)` by `r`'.\n\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {x : Q(«$α»)} →\n      (inst : autoParam Q(Ring «$α») _auto✝) →\n        ℚ → (n : Q(ℤ)) → (d : Q(ℕ)) → Q(Mathlib.Meta.NormNum.IsRat «$x» «$n» «$d») → Mathlib.Meta.NormNum.Result x",
  "name": "Mathlib.Meta.NormNum.Result.isRat",
  "kind": "def",
  "doc_string":
  "The result is `proof : isRat x n d`, where `n` is either `.ofNat lit` or `.negOfNat lit`\nwith `lit` a raw nat literal and `d` is a raw nat literal (not 0 or 1),\nand `q` is the value of `n / d`. ",
  "args": ""},
 {"type": "∀ {M : Type u} [self : AddLeftCancelMonoid M] (a : M), 0 + a = a",
  "name": "AddLeftCancelMonoid.zero_add",
  "kind": "def",
  "doc_string": "Zero is a left neutral element for addition ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_ᶜ»",
  "kind": "def",
  "doc_string": "Set / lattice complement ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] {u : β → α} (self : LowerAdjoint u),\n  GaloisConnection self.toFun u",
  "name": "LowerAdjoint.gc'",
  "kind": "def",
  "doc_string": "The underlying function is a lower adjoint. ",
  "args": ""},
 {"type":
  "Lean.Expr →\n  Lean.MetaM\n    ((u : Lean.Level) ×\n      (α :\n        let u := u;\n        Q(Type u)) ×\n        Q(«$α»))",
  "name": "Qq.inferTypeQ'",
  "kind": "def",
  "doc_string":
  "Analogue of `inferTypeQ`, but that gets universe levels right for our application. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] {f : α → α} {p : α → Prop} {hf : ∀ (x : α), x ≤ f x} {hfp : ∀ (x : α), p (f x)}\n  {hmin : ∀ ⦃x y : α⦄, x ≤ y → p y → f x ≤ y} {x : α},\n  p x → x ∈ ClosureOperator.closed (ClosureOperator.mk₃ f p hf hfp hmin)",
  "name": "ClosureOperator.mem_mk₃_closed",
  "kind": "theorem",
  "doc_string":
  "The property `p` fed into the `mk₃` constructor implies being closed. ",
  "args": ""},
 {"type": "{M : Type u} → [self : LeftCancelMonoid M] → ℕ → M → M",
  "name": "LeftCancelMonoid.npow",
  "kind": "def",
  "doc_string": "Raising to the power of a natural number. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → List ℕ",
  "name": "List.findIdxs",
  "kind": "def",
  "doc_string":
  "`findIdxs p l` is the list of indexes of elements of `l` that satisfy `p`. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} [inst : AddGroup G] (a : G), ↑(Equiv.symm (Equiv.addLeft a)) = fun x => -a + x",
  "name": "Equiv.addLeft_symm_apply",
  "kind": "theorem",
  "doc_string":
  "Extra simp lemma that `dsimp` can use. `simp` will never use this.",
  "args": ""},
 {"type":
  "∀ {A : Type u_2} {F : Type u_1} [inst : MulZeroOneClass A] [inst_1 : MonoidWithZeroHomClass F ℕ A] (f g : F),\n  (∀ {n : ℕ}, 0 < n → ↑f n = ↑g n) → f = g",
  "name": "ext_nat''",
  "kind": "theorem",
  "doc_string":
  "If two `MonoidWithZeroHom`s agree on the positive naturals they are equal. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "InvolutiveInv",
  "kind": "inductive",
  "doc_string": "Auxiliary typeclass for types with an involutive `Inv`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Set α → Set β → Prop",
  "name": "Set.BijOn",
  "kind": "def",
  "doc_string":
  "`f` is bijective from `s` to `t` if `f` is injective on `s` and `f '' s = t`. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "LinearOrderedAddCommMonoid",
  "kind": "inductive",
  "doc_string": "A linearly ordered additive commutative monoid. ",
  "args": ""},
 {"type": "Linarith.CertificateOracle",
  "name": "Linarith.FourierMotzkin.produceCertificate",
  "kind": "def",
  "doc_string":
  "`produceCertificate hyps vars` tries to derive a contradiction from the comparisons in `hyps`\nby eliminating all variables ≤ `maxVar`.\nIf successful, it returns a map `coeff : ℕ → ℕ` as a certificate.\nThis map represents that we can find a contradiction by taking the sum  `∑ (coeff i) * hyps[i]`.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«tacticSimp_intro_____..Only_»",
  "kind": "def",
  "doc_string":
  "The `simp_intro` tactic is a combination of `simp` and `intro`: it will simplify the types of\nvariables as it introduces them and uses the new variables to simplify later arguments\nand the goal.\n* `simp_intro x y z` introduces variables named `x y z`\n* `simp_intro x y z ..` introduces variables named `x y z` and then keeps introducing `_` binders\n* `simp_intro (config := cfg) (discharger := tac) x y .. only [h₁, h₂]`:\n  `simp_intro` takes the same options as `simp` (see `simp`)\n```\nexample : x + 0 = y → x = z := by\n  simp_intro h\n  -- h: x = y ⊢ y = z\n  sorry\n```\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {σ : α → Type u_2} → List α → ((a : α) → List (σ a)) → List ((a : α) × σ a)",
  "name": "List.sigmaTR",
  "kind": "def",
  "doc_string": "Optimized version of `sigma`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : IsWeakUpperModularLattice α] {a b : α}, a ⊓ b ⋖ a → a ⊓ b ⋖ b → b ⋖ a ⊔ b",
  "name": "Covby.sup_of_inf_of_inf_right",
  "kind": "theorem",
  "doc_string": "**Alias** of `covby_sup_of_inf_covby_of_inf_covby_right`.",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → M × N →* N",
  "name": "MonoidHom.snd",
  "kind": "def",
  "doc_string":
  "Given monoids `M`, `N`, the natural projection homomorphism from `M × N` to `N`.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : CommMonoidWithZero α] → α → α → Prop",
  "name": "DvdNotUnit",
  "kind": "def",
  "doc_string":
  "`DvdNotUnit a b` expresses that `a` divides `b` \"strictly\", i.e. that `b` divided by `a`\nis not a unit. ",
  "args": ""},
 {"type": "{ε : Type u} → {α : Type v} → α → Except ε α",
  "name": "Except.ok",
  "kind": "def",
  "doc_string": "A success value of type `α` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → b ≤ a → a ⩿ b",
  "name": "LE.le.wcovby_of_le",
  "kind": "theorem",
  "doc_string": "**Alias** of `wcovby_of_le_of_le`.",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Type u_2} → (f : α → β) → Function.Injective f → α ≃ ↑(Set.range f)",
  "name": "Equiv.ofInjective",
  "kind": "def",
  "doc_string":
  "If `f : α → β` is an injective function, then domain `α` is equivalent to the range of `f`. ",
  "args": ""},
 {"type": "∀ {R : Type u_1} [inst : MulOneClass R], IsRegular 1",
  "name": "isRegular_one",
  "kind": "theorem",
  "doc_string":
  "If multiplying by `1` on either side is the identity, `1` is regular. ",
  "args": ""},
 {"type":
  "{I : Type u} →\n  (f : I → Type v) → [inst : DecidableEq I] → [inst : (i : I) → Zero (f i)] → (i : I) → ZeroHom (f i) ((i : I) → f i)",
  "name": "ZeroHom.single",
  "kind": "def",
  "doc_string":
  "The zero-preserving homomorphism including a single value into a dependent family of values,\nas functions supported at a point.\n\nThis is the `ZeroHom` version of `Pi.single`.",
  "args": ""},
 {"type": "(M₀ : Type u) → [inst : Mul M₀] → [inst : Zero M₀] → Prop",
  "name": "IsLeftCancelMulZero",
  "kind": "inductive",
  "doc_string":
  "A mixin for left cancellative multiplication by nonzero elements. ",
  "args": ""},
 {"type": "∀ (p : Prop) [inst : Decidable p], p ∨ ¬p",
  "name": "dec_em",
  "kind": "theorem",
  "doc_string": "**Alias** of `Decidable.em`.",
  "args": ""},
 {"type":
  "{α : Type u} →\n  (c : CompleteDistribLattice α) →\n    (le : α → α → Prop) →\n      le = LE.le →\n        (top : α) →\n          top = ⊤ →\n            (bot : α) →\n              bot = ⊥ →\n                (sup : α → α → α) →\n                  sup = HasSup.sup →\n                    (inf : α → α → α) →\n                      inf = HasInf.inf →\n                        (Sup : Set α → α) → Sup = supₛ → (Inf : Set α → α) → Inf = infₛ → CompleteDistribLattice α",
  "name": "CompleteDistribLattice.copy",
  "kind": "def",
  "doc_string":
  "A function to create a provable equal copy of a complete distributive lattice\nwith possibly different definitional equalities. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Preorder α] → Set α → Set α",
  "name": "lowerBounds",
  "kind": "def",
  "doc_string": "The set of lower bounds of a set. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → (α : ι → Type u_2) → (β : ι → Type u_3) → (i : ι) × (α i ⊕ β i) ≃ (i : ι) × α i ⊕ (i : ι) × β i",
  "name": "Equiv.sigmaSumDistrib",
  "kind": "def",
  "doc_string":
  "An indexed sum of disjoint sums of types is equivalent to the sum of the indexed sums. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : Preorder α] → [inst : Preorder β] → Preorder (Lex (α × β))",
  "name": "Prod.Lex.preorder",
  "kind": "def",
  "doc_string": "Dictionary / lexicographic preorder for pairs. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → {x : Add M} → {x_1 : Add N} → (f : AddHom M N) → (f' : M → N) → f' = ↑f → AddHom M N",
  "name": "AddHom.copy",
  "kind": "def",
  "doc_string":
  "Copy of an `AddHom` with a new `toFun` equal to the old one. Useful to fix\ndefinitional equalities.",
  "args": ""},
 {"type":
  "∀ {M : Type u} [self : AddCancelCommMonoid M] (a b : M), a + b = b + a",
  "name": "AddCancelCommMonoid.add_comm",
  "kind": "def",
  "doc_string":
  "Addition is commutative in an additive commutative semigroup. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  (c : CompleteLattice α) →\n    (le : α → α → Prop) →\n      le = LE.le →\n        (top : α) →\n          top = ⊤ →\n            (bot : α) →\n              bot = ⊥ →\n                (sup : α → α → α) →\n                  sup = HasSup.sup →\n                    (inf : α → α → α) →\n                      inf = HasInf.inf →\n                        (Sup : Set α → α) → Sup = supₛ → (Inf : Set α → α) → Inf = infₛ → CompleteLattice α",
  "name": "CompleteLattice.copy",
  "kind": "def",
  "doc_string":
  "A function to create a provable equal copy of a complete lattice\nwith possibly different definitional equalities. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ≃r s → α → β",
  "name": "RelIso.Simps.apply",
  "kind": "def",
  "doc_string":
  "See Note [custom simps projection]. We need to specify this projection explicitly in this case,\nbecause it is a composition of multiple projections. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Monoid R] [inst_1 : HasDistribNeg R], (-1) ^ 2 = 1",
  "name": "neg_one_pow_two",
  "kind": "theorem",
  "doc_string": "**Alias** of `neg_one_sq`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} {n : ℕ} (a1 a2 : Vector α n), Vector.toList a1 = Vector.toList a2 → a1 = a2",
  "name": "Vector.eq",
  "kind": "theorem",
  "doc_string": "Vector is determined by the underlying list. ",
  "args": ""},
 {"type":
  "ℕ → Lean.MVarId → Lean.FVarId → Lean.MetaM (Lean.MVarId × List Lean.FVarId)",
  "name": "Mathlib.Tactic.MkIff.nCasesProd",
  "kind": "def",
  "doc_string":
  "Calls `cases` on `h` (assumed to be a binary product) `n` times, and returns\nthe resulting subgoal and the new hypotheses.\n",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Monoid M] → MulAction M M",
  "name": "Monoid.toMulAction",
  "kind": "def",
  "doc_string":
  "The regular action of a monoid on itself by left multiplication.\n\nThis is promoted to a module by `Semiring.toModule`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u} [self : EuclideanDomain R] (a : R) {b : R}, b ≠ 0 → ¬EuclideanDomain.r (a * b) a",
  "name": "EuclideanDomain.mul_left_not_lt",
  "kind": "def",
  "doc_string": "An additional constraint on `r`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Zero M] [inst_1 : Zero N] {f g : ZeroHom M N}, f = g ↔ ∀ (x : M), ↑f x = ↑g x",
  "name": "ZeroHom.ext_iff",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.ext_iff` instead.",
  "args": ""},
 {"type":
  "∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt f x → Function.LeftInverse g f → Function.IsFixedPt g x",
  "name": "Function.IsFixedPt.to_leftInverse",
  "kind": "theorem",
  "doc_string":
  "If `x` is a fixed point of `f` and `g` is a left inverse of `f`, then `x` is a fixed\npoint of `g`. ",
  "args": ""},
 {"type":
  "{C : ℕ → Sort u_1} → {n m : ℕ} → n ≤ m → (⦃k : ℕ⦄ → n ≤ k → C k → C (k + 1)) → C n → C m",
  "name": "Nat.leRecOn'",
  "kind": "def",
  "doc_string":
  "Recursion starting at a non-zero number: given a map `C k → C (k+1)` for each `k ≥ n`,\nthere is a map from `C n` to each `C m`, `n ≤ m`. ",
  "args": ""},
 {"type": "∀ {α : Type u} {s : Set α}, ¬Set.Nonempty s ↔ s = ∅",
  "name": "Set.not_nonempty_iff_eq_empty",
  "kind": "theorem",
  "doc_string": "See also `Set.nonempty_iff_ne_empty`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : CommRing α] → [inst : NoZeroDivisors α] → CancelCommMonoidWithZero α",
  "name": "NoZeroDivisors.toCancelCommMonoidWithZero",
  "kind": "def",
  "doc_string":
  "A commutative ring with no zero divisors is a `CancelCommMonoidWithZero`.\n\nNote this is not an instance as it forms a typeclass loop. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Preorder α] → {a b : α} → a ≤ b → OrderTop ↑(Set.Icc a b)",
  "name": "Set.Icc.orderTop",
  "kind": "def",
  "doc_string": "`Icc a b` has a top element whenever `a ≤ b`. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "WithZero",
  "kind": "def",
  "doc_string": "Add an extra element `0` to a type",
  "args": ""},
 {"type": "(G : Type w) → [inst : Group G] → G ≃ (Multiplicative ℤ →* G)",
  "name": "zpowersHom",
  "kind": "def",
  "doc_string":
  "Monoid homomorphisms from `Multiplicative ℤ` are defined by the image\nof `Multiplicative.ofAdd 1`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → {δ : Type u_4} → {ε : Type u_5} → (α → β → γ → δ → ε) → List α → List β → List γ → List δ → List ε",
  "name": "List.zipWith4",
  "kind": "def",
  "doc_string": "Quaternary version of `list.zipWith`. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.NormalExpr → Bool",
  "name": "Mathlib.Tactic.Abel.NormalExpr.isAtom",
  "kind": "def",
  "doc_string": "True if this represents an atomic expression. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "LeftCancelMonoid",
  "kind": "inductive",
  "doc_string": "A monoid in which multiplication is left-cancellative. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {f g : α → α},\n  Function.Commute f g → Set.BijOn f (Function.fixedPoints (f ∘ g)) (Function.fixedPoints (f ∘ g))",
  "name": "Function.Commute.left_bijOn_fixedPoints_comp",
  "kind": "theorem",
  "doc_string":
  "If self-maps `f` and `g` commute, then `f` is bijective on the set of fixed points of `f ∘ g`.\nThis is a particular case of `Function.bijOn_fixedPoints_comp`. ",
  "args": ""},
 {"type":
  "{P : ℕ → Sort u_1} → (n : ℕ) → ((n : ℕ) → ((m : ℕ) → m < n → P m) → P n) → P n",
  "name": "Nat.strongRecOn'",
  "kind": "def",
  "doc_string":
  "Recursion principle based on `<` applied to some natural number. ",
  "args": ""},
 {"type": "Type",
  "name": "NonScalar",
  "kind": "inductive",
  "doc_string":
  "`NonScalar` is a type that is not a scalar value in our runtime.\nIt is used as a stand-in for an arbitrary boxed value to avoid excessive\nmonomorphization, and it is only created using `unsafeCast`. It is somewhat\nanalogous to C `void*` in usage, but the type itself is not special.\n",
  "args": ""},
 {"type": "ℕ → List ℕ",
  "name": "List.iotaTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `iota`. ",
  "args": ""},
 {"type": "{α : Sort u_1} → {r : α → α → Prop} → Quot r → α",
  "name": "Quot.out",
  "kind": "def",
  "doc_string":
  "Choose an element of the equivalence class using the axiom of choice.\nSound but noncomputable. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {F : αᵃᵒᵖ → Sort v} → ((X : α) → F { unop := X }) → (X : αᵃᵒᵖ) → F X",
  "name": "AddOpposite.rec'",
  "kind": "def",
  "doc_string":
  "A recursor for `AddOpposite`. Use as `induction x using AddOpposite.rec`.",
  "args": ""},
 {"type": "∀ {r n : ℕ}, r < n / 2 → Nat.choose n r ≤ Nat.choose n (r + 1)",
  "name": "Nat.choose_le_succ_of_lt_half_left",
  "kind": "theorem",
  "doc_string":
  "Show that `Nat.choose` is increasing for small values of the right argument. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α",
  "name": "List.dropLastTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `dropLast`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ≃+* S),\n  ↑↑f = MulEquiv.toMonoidHom ↑f",
  "name": "RingEquiv.toMonoidHom_commutes",
  "kind": "theorem",
  "doc_string":
  "The two paths coercion can take to an `MonoidHom` are equivalent ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → β → (α → β) → Option α → β",
  "name": "Option.elim'",
  "kind": "def",
  "doc_string":
  "An elimination principle for `Option`. It is a nondependent version of `Option.rec`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → {r : α → α → Prop} → {s : β → β → Prop} → {t : γ → γ → Prop} → r ↪r s → s ↪r t → r ↪r t",
  "name": "RelEmbedding.trans",
  "kind": "def",
  "doc_string":
  "Composition of two relation embeddings is a relation embedding. ",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HAppend",
  "kind": "inductive",
  "doc_string":
  "The notation typeclass for heterogeneous append.\nThis enables the notation `a ++ b : γ` where `a : α`, `b : β`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (t : α → Set β) → (i : α) × ↑(t i) → ↑(Set.unionᵢ fun i => t i)",
  "name": "Set.sigmaToUnionᵢ",
  "kind": "def",
  "doc_string":
  "If `t` is an indexed family of sets, then there is a natural map from `Σ i, t i` to `⋃ i, t i`\nsending `⟨i, x⟩` to `x`. ",
  "args": ""},
 {"type": "Type → Type",
  "name": "Mathlib.Tactic.RingNF.M",
  "kind": "def",
  "doc_string":
  "The monad for `RingNF` contains, in addition to the `RingM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → Option β) → List α → List β",
  "name": "List.filterMapTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `filterMap`. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Ring.Context → Lean.Meta.TransparencyMode",
  "name": "Mathlib.Tactic.Ring.Context.red",
  "kind": "def",
  "doc_string": "The reducibility setting for definitional equality of atoms ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.GeneralizeProofs.State",
  "kind": "inductive",
  "doc_string":
  "State for the generalize proofs tactic, contains the remaining names to be used and the\nlist of generalizations so far ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → α → Prop} →\n        {s : β → β → Prop} →\n          Quot r →\n            Quot s →\n              (f : α → β → γ) →\n                (∀ (a : α) (b₁ b₂ : β), s b₁ b₂ → f a b₁ = f a b₂) →\n                  (∀ (a₁ a₂ : α) (b : β), r a₁ a₂ → f a₁ b = f a₂ b) → γ",
  "name": "Quot.liftOn₂",
  "kind": "def",
  "doc_string":
  "Descends a function `f : α → β → γ` to quotients of `α` and `β` and applies it. ",
  "args": ""},
 {"type":
  "{F : Type u_1} →\n  {R : Type u_2} →\n    {S : Type u_3} →\n      [inst : NonUnitalNonAssocSemiring R] →\n        [inst_1 : NonUnitalNonAssocSemiring S] →\n          [inst_2 : NonUnitalRingHomClass F R S] → (f : F) → Function.Bijective ↑f → R ≃+* S",
  "name": "RingEquiv.ofBijective",
  "kind": "def",
  "doc_string":
  "Produce a ring isomorphism from a bijective ring homomorphism. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : DecidableEq α] (i j : α) (σ : Equiv.Perm α), Equiv.swap i j * (Equiv.swap i j * σ) = σ",
  "name": "Equiv.swap_mul_self_mul",
  "kind": "theorem",
  "doc_string":
  "Left-multiplying a permutation with `swap i j` twice gives the original permutation.\n\nThis specialization of `swap_mul_self` is useful when using cosets of permutations.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c",
  "name": "LE.le.trans_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_le_of_lt`.",
  "args": ""},
 {"type": "ℚ → ℚ",
  "name": "Rat.inv",
  "kind": "def",
  "doc_string": "The inverse of a rational number. Note: `inv 0 = 0`. ",
  "args": ""},
 {"type":
  "{A : Type u_1} → {B : Type u_2} → [inst : Add A] → [inst_1 : Add B] → A ≃+ B → A ≃ B",
  "name": "AddEquiv.toEquiv",
  "kind": "def",
  "doc_string": "The `Equiv` underlying an `AddEquiv`. ",
  "args": ""},
 {"type":
  "∀ {S : Set ℕ}, 0 ∈ S → (∀ (k : ℕ), k ∈ S → k + 1 ∈ S) → ∀ (n : ℕ), n ∈ S",
  "name": "Nat.set_induction",
  "kind": "theorem",
  "doc_string":
  "A subset of `ℕ` containing zero and closed under `Nat.succ` contains all of `ℕ`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : NonUnitalCommRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : Add β] →\n          [inst_3 : Mul β] →\n            [inst_4 : Neg β] →\n              [inst_5 : Sub β] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : SMul ℤ β] →\n                    (f : α → β) →\n                      Function.Surjective f →\n                        f 0 = 0 →\n                          (∀ (x y : α), f (x + y) = f x + f y) →\n                            (∀ (x y : α), f (x * y) = f x * f y) →\n                              (∀ (x : α), f (-x) = -f x) →\n                                (∀ (x y : α), f (x - y) = f x - f y) →\n                                  (∀ (x : α) (n : ℕ), f (n • x) = n • f x) →\n                                    (∀ (x : α) (n : ℤ), f (n • x) = n • f x) → NonUnitalCommRing β",
  "name": "Function.Surjective.nonUnitalCommRing",
  "kind": "def",
  "doc_string":
  "Pushforward a `NonUnitalCommRing` instance along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "NegZeroClass",
  "kind": "inductive",
  "doc_string": "Typeclass for expressing that `-0 = 0`. ",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  [inst : Group G] → {H : Type u_2} → [inst_1 : Group H] → (f : G → H) → (∀ (x y : G), f (x / y) = f x / f y) → G →* H",
  "name": "MonoidHom.ofMapDiv",
  "kind": "def",
  "doc_string":
  "Define a morphism of additive groups given a map which respects ratios. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] {a b : αᵒᵈ}, b ≤ a → ↑OrderDual.ofDual a ≤ ↑OrderDual.ofDual b",
  "name": "LE.le.ofDual",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `OrderDual.ofDual_le_ofDual`.",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⊇_»",
  "kind": "def",
  "doc_string": "Superset relation: `a ⊇ b`  ",
  "args": ""},
 {"type": "Lean.NameMapExtension Unit",
  "name": "notationClassAttr",
  "kind": "opaque",
  "doc_string": "`@[notation_class]` attribute ",
  "args": ""},
 {"type":
  "{M : Type uM} → {N : Type uN} → [inst : AddZeroClass M] → [inst_1 : AddCommMonoid N] → M →+ (M →+ N) →+ N",
  "name": "AddMonoidHom.eval",
  "kind": "def",
  "doc_string":
  "Evaluation of an `AddMonoidHom` at a point as an additive monoid homomorphism.\nSee also `AddMonoidHom.apply` for the evaluation of any function at a point.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CanonicallyLinearOrderedSemifield",
  "kind": "inductive",
  "doc_string":
  "A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, b = c → a ≤ b → a ≤ c",
  "name": "Eq.trans_ge",
  "kind": "theorem",
  "doc_string": "**Alias** of `le_of_eq_of_le'`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Preorder α] → [inst : OrderTop α] → α → Prop",
  "name": "IsCoatom",
  "kind": "def",
  "doc_string":
  "A coatom of an `OrderTop` is an element with no other element between it and `⊤`,\nwhich is not `⊤`. ",
  "args": ""},
 {"type": "∀ {G : Type u} [self : AddCommGroup G] (a b : G), a + b = b + a",
  "name": "AddCommGroup.add_comm",
  "kind": "def",
  "doc_string":
  "Addition is commutative in an additive commutative semigroup. ",
  "args": ""},
 {"type":
  "∀ {γ : Type w} [inst : Preorder γ] [inst_1 : OrderBot γ] (s : Set γ), BddBelow s",
  "name": "OrderBot.bddBelow",
  "kind": "theorem",
  "doc_string": "When there is a global minimum, every set is bounded below. ",
  "args": ""},
 {"type": "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a",
  "name": "pow_two",
  "kind": "theorem",
  "doc_string":
  "Note that most of the lemmas about powers of two refer to it as `sq`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {α' : Type u_2} →\n    {β : α → Type u_3} →\n      {β' : α' → Type u_4} → (f : α ↪ α') → ((a : α) → β a ↪ β' (↑f a)) → (a : α) × β a ↪ (a' : α') × β' a'",
  "name": "Function.Embedding.sigmaMap",
  "kind": "def",
  "doc_string":
  "If `f : α ↪ α'` is an embedding and `g : Π a, β α ↪ β' (f α)` is a family\nof embeddings, then `Sigma.map f g` is an embedding. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Ring α] [inst_1 : IsDomain α] [inst_2 : Ring β] (f : β →+* α),\n  Function.Injective ↑f → IsDomain β",
  "name": "Function.Injective.isDomain",
  "kind": "theorem",
  "doc_string": "Pullback `IsDomain` instance along an injective function. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {lt : α → α → Bool} → (self : BinaryHeap α lt) → { a' // BinaryHeap.size a' = BinaryHeap.size self - 1 }",
  "name": "BinaryHeap.popMaxAux",
  "kind": "def",
  "doc_string": "Auxiliary for `popMax`. ",
  "args": ""},
 {"type":
  "(R : Type u_1) → (S : Type u_2) → [inst : NonAssocSemiring R] → [inst_1 : NonAssocSemiring S] → R × S →+* S",
  "name": "RingHom.snd",
  "kind": "def",
  "doc_string":
  "Given semirings `R`, `S`, the natural projection homomorphism from `R × S` to `S`.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Prefunctor.«term𝟭q»",
  "kind": "def",
  "doc_string": "Notation for the identity prefunctor on a quiver. ",
  "args": ""},
 {"type":
  "{α : Sort uA} →\n  {β : Sort uB} →\n    {φ : Sort uC} →\n      {s₁ : Setoid α} →\n        {s₂ : Setoid β} →\n          (f : α → β → φ) →\n            (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) →\n              Quotient s₁ → Quotient s₂ → φ",
  "name": "Quotient.lift₂",
  "kind": "def",
  "doc_string": "Lift a binary function to a quotient on both arguments. ",
  "args": ""},
 {"type": "Type",
  "name": "Rat",
  "kind": "inductive",
  "doc_string":
  "Rational numbers, implemented as a pair of integers `num / den` such that the\ndenominator is positive and the numerator and denominator are coprime.\n",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u₃} → [inst_2 : CategoryTheory.Category E] → (F : C ⥤ D) → {G H : D ⥤ E} → (G ⟶ H) → (F ⋙ G ⟶ F ⋙ H)",
  "name": "CategoryTheory.whiskerLeft",
  "kind": "def",
  "doc_string":
  "If `α : G ⟶ H` then\n`whiskerLeft F α : (F ⋙ G) ⟶ (F ⋙ H)` has components `α.app (F.obj X)`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : GeneralizedCoheytingAlgebra α] (a b : α), b \\ a ⊔ a = b ⊔ a",
  "name": "sup_sdiff_self_left",
  "kind": "theorem",
  "doc_string": "**Alias** of `sdiff_sup_self`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → [inst : Preorder α] → [inst_1 : Preorder β] → [inst_2 : Preorder γ] → (β →o γ) → (α →o β) → α →o γ",
  "name": "OrderHom.comp",
  "kind": "def",
  "doc_string": "The composition of two bundled monotone functions. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [self : ZeroLEOneClass α], 0 ≤ 1",
  "name": "ZeroLEOneClass.zero_le_one",
  "kind": "def",
  "doc_string": "Zero is less than or equal to one. ",
  "args": ""},
 {"type":
  "{M : Type u} → [inst : Monoid M] → (x : M) → (n : ℕ) → x ^ n = 1 → n ≠ 0 → Mˣ",
  "name": "Units.ofPowEqOne",
  "kind": "def",
  "doc_string": "If `x ^ n = 1`, `n ≠ 0`, then `x` is a unit. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : HasSSubset α]\n  [inst_2 : IsNonstrictStrictOrder α (fun x x_1 => x ⊆ x_1) fun x x_1 => x ⊂ x_1] {a b : α}\n  [inst_3 : IsAntisymm α fun x x_1 => x ⊆ x_1], a ⊆ b → a ⊂ b ∨ a = b",
  "name": "HasSubset.Subset.ssubset_or_eq",
  "kind": "theorem",
  "doc_string": "**Alias** of `ssubset_or_eq_of_subset`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α] (k : α), (∀ (x : α), k * x = 0 → x = 0) → IsLeftRegular k",
  "name": "isLeftRegular_of_non_zero_divisor",
  "kind": "theorem",
  "doc_string":
  "Left `Mul` by a `k : α` over `[Ring α]` is injective, if `k` is not a zero divisor.\nThe typeclass that restricts all terms of `α` to have this property is `NoZeroDivisors`. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₂] →\n      [inst_1 : One M₂] →\n        [inst_2 : Pow M₂ ℕ] →\n          [inst_3 : Inv M₂] →\n            [inst_4 : Div M₂] →\n              [inst_5 : Pow M₂ ℤ] →\n                [inst_6 : DivInvMonoid M₁] →\n                  (f : M₁ → M₂) →\n                    Function.Surjective f →\n                      f 1 = 1 →\n                        (∀ (x y : M₁), f (x * y) = f x * f y) →\n                          (∀ (x : M₁), f x⁻¹ = (f x)⁻¹) →\n                            (∀ (x y : M₁), f (x / y) = f x / f y) →\n                              (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                (∀ (x : M₁) (n : ℤ), f (x ^ n) = f x ^ n) → DivInvMonoid M₂",
  "name": "Function.Surjective.divInvMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `1`, `*`, `⁻¹`, and `/` is a `DivInvMonoid` if it admits a surjective map\nthat preserves `1`, `*`, `⁻¹`, and `/` to a `DivInvMonoid`. See note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type u_1} →\n    [inst : LinearOrderedCommSemiring α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Pow β ℕ] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : NatCast β] →\n                    [inst_8 : HasSup β] →\n                      [inst_9 : HasInf β] →\n                        (f : β → α) →\n                          Function.Injective f →\n                            f 0 = 0 →\n                              f 1 = 1 →\n                                (∀ (x y : β), f (x + y) = f x + f y) →\n                                  (∀ (x y : β), f (x * y) = f x * f y) →\n                                    (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                      (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                        (∀ (n : ℕ), f ↑n = ↑n) →\n                                          (∀ (x y : β), f (x ⊔ y) = max (f x) (f y)) →\n                                            (∀ (x y : β), f (x ⊓ y) = min (f x) (f y)) → LinearOrderedCommSemiring β",
  "name": "Function.Injective.linearOrderedCommSemiring",
  "kind": "def",
  "doc_string": "Pullback a `LinearOrderedSemiring` under an injective map. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → α ↪ α ⊕ β",
  "name": "Function.Embedding.inl",
  "kind": "def",
  "doc_string": "The embedding of `α` into the sum `α ⊕ β`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Add M] →\n      [inst_1 : Add N] →\n        (S : AddSubsemigroup M) →\n          (f : AddHom M N) → Function.Injective ↑f → { x // x ∈ S } ≃+ { x // x ∈ AddSubsemigroup.map f S }",
  "name": "AddSubsemigroup.equivMapOfInjective",
  "kind": "def",
  "doc_string":
  "An additive subsemigroup is isomorphic to its image under an injective function",
  "args": ""},
 {"type":
  "{α : Sort u} →\n  {β : Sort v} → [inst : DecidableEq β] → (f : α → β) → {P : Sort w} → {x y : α} → x = y → noConfusionTypeEnum f P x y",
  "name": "noConfusionEnum",
  "kind": "def",
  "doc_string":
  "Auxiliary definition for generating compact `noConfusion` for enumeration types ",
  "args": ""},
 {"type": "{p : ℕ+ → Prop} → [inst : DecidablePred p] → (∃ n, p n) → ℕ+",
  "name": "PNat.find",
  "kind": "def",
  "doc_string":
  "If `p` is a (decidable) predicate on `ℕ+` and `hp : ∃ (n : ℕ+), p n` is a proof that\nthere exists some positive natural number satisfying `p`, then `PNat.find hp` is the\nsmallest positive natural number satisfying `p`. Note that `PNat.find` is protected,\nmeaning that you can't just write `find`, even if the `PNat` namespace is open.\n\nThe API for `PNat.find` is:\n\n* `PNat.find_spec` is the proof that `PNat.find hp` satisfies `p`.\n* `PNat.find_min` is the proof that if `m < PNat.find hp` then `m` does not satisfy `p`.\n* `PNat.find_min'` is the proof that if `m` does satisfy `p` then `PNat.find hp ≤ m`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : SubtractionMonoid α] → {a : α} → IsAddUnit a → AddUnits α",
  "name": "IsAddUnit.addUnit'",
  "kind": "def",
  "doc_string":
  "The element of the additive group of additive units, corresponding to an element of\nan additive monoid which is an additive unit. As opposed to `IsAddUnit.addUnit`, the negation is\ncomputable and comes from the negation on `α`. This is useful to transfer properties of negation\nin `AddUnits α` to `α`. See also `toAddUnits`.",
  "args": ""},
 {"type": "Sort u → Sort u",
  "name": "Trunc",
  "kind": "def",
  "doc_string":
  "`Trunc α` is the quotient of `α` by the always-true relation. This\nis related to the propositional truncation in HoTT, and is similar\nin effect to `Nonempty α`, but unlike `Nonempty α`, `Trunc α` is data,\nso the VM representation is the same as `α`, and so this can be used to\nmaintain computability. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {C : αᵒᵈ → Sort u_2} → ((a : α) → C (↑OrderDual.toDual a)) → (a : αᵒᵈ) → C a",
  "name": "OrderDual.rec",
  "kind": "def",
  "doc_string": "Recursor for `αᵒᵈ`. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} {inst : LE α} {inst_1 : LE β} [self : OrderIsoClass F α β] (f : F)\n  {a b : α}, ↑f a ≤ ↑f b ↔ a ≤ b",
  "name": "OrderIsoClass.map_le_map_iff",
  "kind": "def",
  "doc_string": "An order isomorphism respects `≤`. ",
  "args": ""},
 {"type": "IO System.FilePath",
  "name": "Mathlib.getMathlibDir",
  "kind": "def",
  "doc_string": "Returns the mathlib root directory. ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : Semiring α], NatCast.natCast 0 = 0",
  "name": "Semiring.natCast_zero",
  "kind": "def",
  "doc_string": "The canonical map `ℕ → R` sends `0 : ℕ` to `0 : R`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedAddMonoid α] (a b : α), a ≤ a + b",
  "name": "CanonicallyOrderedAddMonoid.le_self_add",
  "kind": "def",
  "doc_string": "For any `a` and `b`, `a ≤ a + b` ",
  "args": ""},
 {"type": "ℕ → Lean.Expr",
  "name": "Mathlib.Tactic.Sat.buildReify.v",
  "kind": "def",
  "doc_string": "The `v` variable under the `a1 ... an, v, h1 ... hn` context ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Ring α] (self : Ring.TotalPositiveCone α) (a : α),\n  AddCommGroup.PositiveCone.nonneg self.toPositiveCone_1.toPositiveCone a ∨\n    AddCommGroup.PositiveCone.nonneg self.toPositiveCone_1.toPositiveCone (-a)",
  "name": "Ring.TotalPositiveCone.nonneg_total",
  "kind": "def",
  "doc_string": "Either `a` or `-a` is `nonneg` ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : DecidableEq α] → [inst : Lattice α] → [inst_1 : BoundedOrder α] → [inst : IsSimpleOrder α] → BooleanAlgebra α",
  "name": "IsSimpleOrder.booleanAlgebra",
  "kind": "def",
  "doc_string": "A simple `BoundedOrder` is also a `BooleanAlgebra`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, 0 ≤ a → 0 < b → 0 < a + b",
  "name": "add_pos_of_nonneg_of_pos",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.add_pos_of_nonneg_of_pos`.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddRightCancelMonoid",
  "kind": "inductive",
  "doc_string":
  "An additive monoid in which addition is right-cancellative.\nMain examples are `ℕ` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `AddRightCancelSemigroup` is not enough. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} {F : Type u_3} {x : AddZeroClass M} {x_1 : AddZeroClass N}\n  [inst : AddMonoidHomClass F M N] (f : F) {x_2 : M}, (∃ y, x_2 + y = 0) → ∃ y, ↑f x_2 + y = 0",
  "name": "AddMonoidHom.map_exists_right_neg",
  "kind": "theorem",
  "doc_string":
  "Given an AddMonoid homomorphism `f : M →+ N` and an element `x : M`, if `x` has\na right inverse, then `f x` has a right inverse too.",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : LE α] → [inst_1 : OrderBot α] → [inst_2 : LE β] → OrderBot (Lex (α ⊕ β))",
  "name": "Sum.Lex.orderBot",
  "kind": "def",
  "doc_string":
  "The lexicographical bottom of a sum is the bottom of the left component. ",
  "args": ""},
 {"type": "(G : Type w) → [inst : CommGroup G] → G ≃* (Multiplicative ℤ →* G)",
  "name": "zpowersMulHom",
  "kind": "def",
  "doc_string":
  "If `M` is commutative, `zpowersHom` is a multiplicative equivalence. ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Monoid R] → OreLocalization.OreSet ⊥",
  "name": "OreLocalization.oreSetBot",
  "kind": "def",
  "doc_string": "The trivial submonoid is an Ore set. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : CompleteLattice α] (a : α) (f : β → α), (⨅ o, Option.elim o a f) = a ⊓ ⨅ b, f b",
  "name": "infᵢ_option_elim",
  "kind": "theorem",
  "doc_string":
  "A version of `infᵢ_option` useful for rewriting right-to-left. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → Trunc α → (f : α → β) → (∀ (a b : α), f a = f b) → β",
  "name": "Trunc.liftOn",
  "kind": "def",
  "doc_string": "Lift a constant function on `q : Trunc α`. ",
  "args": ""},
 {"type":
  "{m : Type u → Type v} →\n  {n : Type u → Type w} → [self : MonadFunctor m n] → {α : Type u} → ({β : Type u} → m β → m β) → n α → n α",
  "name": "MonadFunctor.monadMap",
  "kind": "def",
  "doc_string":
  "Lifts a monad morphism `f : {β : Type u} → m β → m β` to\n`monadMap f : {α : Type u} → n α → n α`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → {p : α → Prop} → {q : β → Prop} → { c // p c.fst ∧ q c.snd } ≃ { a // p a } × { b // q b }",
  "name": "Equiv.subtypeProdEquivProd",
  "kind": "def",
  "doc_string":
  "A subtype of a product defined by componentwise conditions\nis equivalent to a product of subtypes. ",
  "args": ""},
 {"type": "(n : ℕ) → autoParam (0 < n) _auto✝ → ℕ+",
  "name": "Nat.toPNat",
  "kind": "def",
  "doc_string":
  "Convert a natural number to a positive natural number. The\npositivity assumption is inferred by `dec_trivial`. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  {D : Type u₂} →\n    [inst : CategoryTheory.Category C] →\n      [inst_1 : CategoryTheory.Category D] → (F : C ⥤ D) → [inst : CategoryTheory.EssSurj F] → D → C",
  "name": "CategoryTheory.Functor.objPreimage",
  "kind": "def",
  "doc_string":
  "Given an essentially surjective functor, we can find a preimage for every object `Y` in the\ncodomain. Applying the functor to this preimage will yield an object isomorphic to `Y`, see\n`obj_obj_preimage_iso`. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {α : ι → Type u_2} → [inst : LT ι] → [inst : (i : ι) → LE (α i)] → LE (Lex ((i : ι) × α i))",
  "name": "Sigma.Lex.LE",
  "kind": "def",
  "doc_string": "The lexicographical `≤` on a sigma type. ",
  "args": ""},
 {"type": "{α : Type u} → α → Squash α",
  "name": "Squash.mk",
  "kind": "def",
  "doc_string": "The canonical quotient map into `Squash α`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → (M →ₙ* N) → Subsemigroup M → Subsemigroup N",
  "name": "Subsemigroup.map",
  "kind": "def",
  "doc_string":
  "The image of a subsemigroup along a semigroup homomorphism is a subsemigroup. ",
  "args": ""},
 {"type": "{α : Type u_1} → α → ℕ → List α → Array α → List α",
  "name": "List.insertNthTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `insertNthTR`: `insertNthTR.go a n l acc = acc.toList ++ insertNth n a l`. ",
  "args": ""},
 {"type": "(α : Type u) → [inst : LE α] → Type u",
  "name": "BoundedOrder",
  "kind": "inductive",
  "doc_string":
  "A bounded order describes an order `(≤)` with a top and bottom element,\ndenoted `⊤` and `⊥` respectively. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Mul M] (s : Set M) {p : (x : M) → x ∈ Subsemigroup.closure s → Prop},\n  (∀ (x : M) (h : x ∈ s), p x (_ : x ∈ ↑(Subsemigroup.closure s))) →\n    (∀ (x : M) (hx : x ∈ Subsemigroup.closure s) (y : M) (hy : y ∈ Subsemigroup.closure s),\n        p x hx → p y hy → p (x * y) (_ : x * y ∈ Subsemigroup.closure s)) →\n      ∀ {x : M} (hx : x ∈ Subsemigroup.closure s), p x hx",
  "name": "Subsemigroup.closure_induction'",
  "kind": "theorem",
  "doc_string": "A dependent version of `Subsemigroup.closure_induction`.  ",
  "args": ""},
 {"type":
  "Linarith.LinarithConfig → Lean.MVarId → List Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Linarith.proveFalseByLinarith",
  "kind": "def",
  "doc_string":
  "`proveFalseByLinarith` is the main workhorse of `linarith`.\nGiven a list `l` of proofs of `tᵢ Rᵢ 0`,\nit tries to derive a contradiction from `l` and use this to produce a proof of `False`.\n\nAn oracle is used to search for a certificate of unsatisfiability.\nIn the current implementation, this is the Fourier Motzkin elimination routine in\n`Elimination.lean`, but other oracles could easily be swapped in.\n\nThe returned certificate is a map `m` from hypothesis indices to natural number coefficients.\nIf our set of hypotheses has the form  `{tᵢ Rᵢ 0}`,\nthen the elimination process should have guaranteed that\n1.\\ `∑ (m i)*tᵢ = 0`,\nwith at least one `i` such that `m i > 0` and `Rᵢ` is `<`.\n\nWe have also that\n2.\\ `∑ (m i)*tᵢ < 0`,\nsince for each `i`, `(m i)*tᵢ ≤ 0` and at least one is strictly negative.\nSo we conclude a contradiction `0 < 0`.\n\nIt remains to produce proofs of (1) and (2). (1) is verified by calling the `discharger` tactic\nof the `LinarithConfig` object, which is typically `ring`. We prove (2) by folding over the\nset of hypotheses.\n",
  "args": ""},
 {"type": "(α : Type u_1) → (β : Type u_2) → [inst : IsEmpty β] → α ⊕ β ≃ α",
  "name": "Equiv.sumEmpty",
  "kind": "def",
  "doc_string": "Sum with `IsEmpty` is equivalent to the original type. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_3} [inst : Lattice α] [inst_1 : IsModularLattice α] {β : Type u_1} {γ : Type u_2} [inst_2 : Preorder β]\n  [inst_3 : PartialOrder γ],\n  (WellFounded fun x x_1 => x > x_1) →\n    (WellFounded fun x x_1 => x > x_1) →\n      ∀ (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ),\n        GaloisCoinsertion f₁ f₂ →\n          GaloisInsertion g₂ g₁ →\n            (∀ (a : α), f₁ (f₂ a) = a ⊓ K) → (∀ (a : α), g₁ (g₂ a) = a ⊔ K) → WellFounded fun x x_1 => x > x_1",
  "name": "wellFounded_gt_exact_sequence",
  "kind": "theorem",
  "doc_string":
  "A generalization of the theorem that if `N` is a submodule of `M` and\n`N` and `M / N` are both Noetherian, then `M` is Noetherian.  ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [self : OreLocalization.OreSet S] (r : R) (s : { x // x ∈ S }),\n  r * ↑(OreLocalization.OreSet.oreDenom r s) = ↑s * OreLocalization.OreSet.oreNum r s",
  "name": "OreLocalization.OreSet.ore_eq",
  "kind": "def",
  "doc_string":
  "The Ore condition of a fraction, expressed in terms of `oreNum` and `oreDenom`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : LT α] → α → α → Prop",
  "name": "GT.gt",
  "kind": "def",
  "doc_string": "`a > b` is an abbreviation for `b < a`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : AddZeroClass M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [hA : AddSubmonoidClass A M] → (S' : A) → { x // x ∈ S' } →+ M",
  "name": "AddSubmonoidClass.Subtype",
  "kind": "def",
  "doc_string":
  "The natural monoid hom from an `AddSubmonoid` of `AddMonoid` `M` to `M`.",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HOr",
  "kind": "inductive",
  "doc_string":
  "The typeclass behind the notation `a ||| b : γ` where `a : α`, `b : β`. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → (α → Option β) → List α → List β",
  "name": "List.filterMap",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `filterMap f l` takes a function `f : α → Option β` and applies it to each element of `l`;\nthe resulting non-`none` values are collected to form the output list.\n```\nfilterMap\n  (fun x => if x > 2 then some (2 * x) else none)\n  [1, 2, 5, 2, 7, 7]\n= [10, 14, 14]\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] {u : β → α} (l : LowerAdjoint u) (x : α),\n  x ≤ u (LowerAdjoint.toFun l x)",
  "name": "LowerAdjoint.le_closure",
  "kind": "theorem",
  "doc_string":
  "Every element is less than its closure. This property is sometimes referred to as extensivity or\ninflationarity. ",
  "args": ""},
 {"type": "Array ℕ → Mathlib.Tactic.Sat.LRATStep",
  "name": "Mathlib.Tactic.Sat.LRATStep.del",
  "kind": "def",
  "doc_string":
  "A (multiple) deletion step, which deletes all the listed clause IDs from the context ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  ℕ →\n    {α :\n        let u := u;\n        Q(Type u)} →\n      Q(Semiring «$α») → Q(«$α») → Q(«$α»)",
  "name": "Linarith.mulExpr'",
  "kind": "def",
  "doc_string": "A typesafe version of `mulExpr`. ",
  "args": ""},
 {"type": "{α : Sort u} → (x : α) → {β : Sort v} → [self : CoeT α x β] → β",
  "name": "CoeT.coe",
  "kind": "def",
  "doc_string":
  "The resulting value of type `β`. The input `x : α` is a parameter to\nthe type class, so the value of type `β` may possibly depend on additional\ntypeclasses on `x`. ",
  "args": ""},
 {"type":
  "{α : Type} → [inst : Lean.ToMessageData α] → α → List Lean.Expr → Lean.MetaM Unit",
  "name": "Linarith.linarithTraceProofs",
  "kind": "def",
  "doc_string":
  "A shorthand for tracing the types of a list of proof terms\nwhen the `trace.linarith` option is set to true.\n",
  "args": ""},
 {"type": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "name": "Iff.mpr",
  "kind": "def",
  "doc_string":
  "Modus ponens for if and only if, reversed. If `a ↔ b` and `b`, then `a`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Mul α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b c d : α},\n  a < b → c < d → a * c < b * d",
  "name": "Left.mul_lt_mul",
  "kind": "theorem",
  "doc_string": "Only assumes left strict covariance. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : HeytingAlgebra α] → Type u_1",
  "name": "Heyting.Regular",
  "kind": "def",
  "doc_string": "The boolean algebra of Heyting regular elements. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Rand",
  "kind": "def",
  "doc_string":
  "A monad to generate random objects using the generator type `Rng` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Zero α] → [inst : One α] → [inst : Add α] → [inst : Neg α] → ZNum → α",
  "name": "castZNum",
  "kind": "def",
  "doc_string":
  "`castZNum` casts a `ZNum` into any type which has `0`, `1`, `+` and `neg` ",
  "args": ""},
 {"type": "{β : Sort v} → (β → β → Prop) → Prop",
  "name": "Transitive",
  "kind": "def",
  "doc_string":
  "A relation is transitive if `x ≺ y` and `y ≺ z` together imply `x ≺ z`. ",
  "args": ""},
 {"type":
  "{V : Type u} →\n  [inst : Quiver V] → [self : Quiver.Arborescence V] → (b : V) → Unique (Quiver.Path Quiver.Arborescence.root b)",
  "name": "Quiver.Arborescence.uniquePath",
  "kind": "def",
  "doc_string": "There is a unique path from the root to any other vertex. ",
  "args": ""},
 {"type":
  "(R : Type u_1) → [inst : Mul R] → [inst_1 : Add R] → RingAut R →* Equiv.Perm R",
  "name": "RingAut.toPerm",
  "kind": "def",
  "doc_string": "Monoid homomorphism from ring automorphisms to permutations. ",
  "args": ""},
 {"type": "{α β σ : Type u} → α → σ → DoResultPR α β σ",
  "name": "DoResultPR.pure",
  "kind": "def",
  "doc_string":
  "`pure (a : α) s` means that the block exited normally with return value `a` ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_3} {β : Sort u_1} {γ : Sort u_2} {g : β → γ},\n  Function.Injective g → Function.Injective ((fun x x_1 => x ∘ x_1) g)",
  "name": "Function.Injective.comp_left",
  "kind": "theorem",
  "doc_string":
  "Composition by an injective function on the left is itself injective. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} {M : Type u_2} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S), 0 ∈ s",
  "name": "ZeroMemClass.zero_mem",
  "kind": "def",
  "doc_string":
  "By definition, if we have `ZeroMemClass S M`, we have `0 ∈ s` for all `s : S`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → Antitone (↑OrderDual.toDual ∘ f)",
  "name": "Monotone.dual_right",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `antitone_toDual_comp_iff`.",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {M : Type u_2} {N : Type u_3} {inst : Add M} {inst_1 : Add N} [self : AddHomClass F M N] (f : F)\n  (x y : M), ↑f (x + y) = ↑f x + ↑f y",
  "name": "AddHomClass.map_add",
  "kind": "def",
  "doc_string": "The proposition that the function preserves addition ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, 0 < -a ↔ a < 0",
  "name": "Right.neg_pos_iff",
  "kind": "theorem",
  "doc_string": "Uses `right` co(ntra)variant.",
  "args": ""},
 {"type": "(α : Sort u_1) → (True → α) ≃ α",
  "name": "Equiv.trueArrowEquiv",
  "kind": "def",
  "doc_string": "The sort of maps from `True` is equivalent to the codomain. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_×_»",
  "kind": "def",
  "doc_string":
  "Product type (aka pair). You can use `α × β` as notation for `Prod α β`.\nGiven `a : α` and `b : β`, `Prod.mk a b : Prod α β`. You can use `(a, b)`\nas notation for `Prod.mk a b`. Moreover, `(a, b, c)` is notation for\n`Prod.mk a (Prod.mk b c)`.\nGiven `p : Prod α β`, `p.1 : α` and `p.2 : β`. They are short for `Prod.fst p`\nand `Prod.snd p` respectively. You can also write `p.fst` and `p.snd`.\nFor more information: [Constructors with Arguments](https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html?highlight=Prod#constructors-with-arguments)\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} [inst : IsTrichotomous α r] [inst : IsIrrefl β s]\n  (f : r →r s), Function.Injective ↑f",
  "name": "RelHom.injective_of_increasing",
  "kind": "theorem",
  "doc_string": "An increasing function is injective ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [inst : Nontrivial α], Nonempty α",
  "name": "Nontrivial.to_nonempty",
  "kind": "def",
  "doc_string":
  "See Note [lower instance priority]\n\nNote that since this and `nonempty_of_inhabited` are the most \"obvious\" way to find a nonempty\ninstance if no direct instance can be found, we give this a higher priority than the usual `100`.\n",
  "args": ""},
 {"type": "String → List String → ℕ → String",
  "name": "SlimCheck.Testable.formatFailure",
  "kind": "def",
  "doc_string": "Format the counter-examples found in a test failure.\n",
  "args": ""},
 {"type":
  "∀ (α : Sort u_1) [s : Setoid α], Function.Surjective (Quotient.mk s)",
  "name": "surjective_quotient_mk",
  "kind": "theorem",
  "doc_string": "`Quotient.mk` is a surjective function. ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsStrictOrder",
  "kind": "inductive",
  "doc_string":
  "`IsStrictOrder X r` means that the binary relation `r` on `X` is a strict order, that is,\n`IsIrrefl X r` and `IsTrans X r`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : CancelCommMonoidWithZero α] → Type u_1",
  "name": "NormalizationMonoid",
  "kind": "inductive",
  "doc_string":
  "Normalization monoid: multiplying with `normUnit` gives a normal form for associated\nelements. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.WhatsNew.commandWhatsnewIn__",
  "kind": "def",
  "doc_string":
  "`whatsnew in $command` executes the command and then prints the\ndeclarations that were added to the environment. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → BinaryHeap α lt",
  "name": "BinaryHeap.popMax",
  "kind": "def",
  "doc_string":
  "`O(log n)`. Remove the maximum element from a `BinaryHeap`.\nCall `max` first to actually retrieve the maximum element. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddMonoid M] → (S : AddSubmonoid M) → AddMonoid { x // x ∈ S }",
  "name": "AddSubmonoid.toAddMonoid",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of an `AddMonoid` inherits an `AddMonoid` structure.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {a b : α}, 0 < a → 0 < b → (1 / a < 1 / b ↔ b < a)",
  "name": "one_div_lt_one_div",
  "kind": "theorem",
  "doc_string":
  "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and\n`lt_of_one_div_lt_one_div` ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Sat.termFrom_lrat__",
  "kind": "def",
  "doc_string":
  "A macro for producing SAT proofs from CNF / LRAT files.\nThese files are commonly used in the SAT community for writing proofs.\n\nThe input to the `from_lrat` term syntax is two string expressions with\nthe statement (written in CNF format) and the proof (in LRAT format).\nFor example:\n```\ndef foo := from_lrat\n  \"p cnf 2 4  1 2 0  -1 2 0  1 -2 0  -1 -2 0\"\n  \"5 -2 0 4 3 0  5 d 3 4 0  6 1 0 5 1 0  6 d 1 0  7 0 5 2 6 0\"\n```\nproduces a theorem:\n```\nfoo : ∀ (a a_1 : Prop), (¬a ∧ ¬a_1 ∨ a ∧ ¬a_1) ∨ ¬a ∧ a_1 ∨ a ∧ a_1\n```\n\n* You can use this term after `have :=` or in `def foo :=` to produce the term\n  without constraining the type.\n* You can use it when a specific type is expected, but it currently does not\n  pay any attention to the shape of the goal and always produces the same theorem,\n  so you can only use this to do alpha renaming.\n* You can use the `include_str` macro in place of the two strings\n  to load CNF / LRAT files from disk.\n",
  "args": ""},
 {"type": "Num → Num → ZNum",
  "name": "Num.sub'",
  "kind": "def",
  "doc_string": "Subtraction of two `Num`s, producing a `ZNum`. ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : BooleanAlgebra α] (a : α), ⊥ ≤ a",
  "name": "BooleanAlgebra.bot_le",
  "kind": "def",
  "doc_string": "`⊥` is the least element ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] → [inst_2 : MulZeroOneClass α] → [inst_3 : MulZeroOneClass β] → (α →*₀o β) → α →*o β",
  "name": "OrderMonoidWithZeroHom.toOrderMonoidHom",
  "kind": "def",
  "doc_string":
  "Reinterpret an ordered monoid with zero homomorphism as an order monoid homomorphism. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Preorder α] →\n    (pred : α → α) → (∀ {a b : α}, a ≤ pred b ↔ a < b) → (∀ {a b : α}, pred a < b → a ≤ b) → PredOrder α",
  "name": "PredOrder.ofLePredIffOfPredLePred",
  "kind": "def",
  "doc_string":
  "A constructor for `PredOrder α` usable when `α` has no minimal element. ",
  "args": ""},
 {"type": "{α : Type u} → {x : WithZero α} → x ≠ 0 → α",
  "name": "WithZero.unzero",
  "kind": "def",
  "doc_string":
  "Deconstruct a `x : WithZero α` to the underlying value in `α`, given a proof that `x ≠ 0`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : PredOrder α] [inst_2 : IsPredArchimedean α] (r : α → α → Prop)\n  {n m : α}, (∀ (i : α), i ∈ Set.Ioc m n → r i (Order.pred i)) → m ≤ n → Relation.ReflTransGen r n m",
  "name": "reflTransGen_of_pred_of_ge",
  "kind": "theorem",
  "doc_string":
  "For `m ≤ n`, `(n, m)` is in the reflexive-transitive closure of `~` if `i ~ pred i`\nfor all `i` between `n` and `m`. ",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} →\n  {β : Type u_1} → [inst : Monad m] → (UInt8 → β → m (ForInStep β)) → ByteArray → ℕ → ℕ → ℕ → β → m β",
  "name": "ByteSlice.forIn.loop",
  "kind": "def",
  "doc_string":
  "The inner loop of the `forIn` implementation for byte slices. ",
  "args": ""},
 {"type": "{α : Type u_1} → (Set α → Option α) → Set α → ℕ → Option α",
  "name": "Set.enumerate",
  "kind": "def",
  "doc_string":
  "Given a choice function `sel`, enumerates the elements of a set in the order\n`a 0 = sel s`, `a 1 = sel (s \\ {a 0})`, `a 2 = sel (s \\ {a 0, a 1})`, ... and stops when\n`sel (s \\ {a 0, ..., a n}) = none`. Note that we don't require `sel` to be a choice function. ",
  "args": ""},
 {"type": "(a b : ℕ) → a < b ⊕' a = b ⊕' b < a",
  "name": "Nat.sum_trichotomy",
  "kind": "def",
  "doc_string": "Strong case analysis on `a < b ∨ a = b ∨ b < a` ",
  "args": ""},
 {"type":
  "{M : Type u_1} → (A : Type u_2) → [inst : AddZeroClass A] → [inst_1 : DistribSMul M A] → M → A →+ A",
  "name": "DistribSMul.toAddMonoidHom",
  "kind": "def",
  "doc_string":
  "Each element of the scalars defines a additive monoid homomorphism. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_∆_»",
  "kind": "def",
  "doc_string": "Notation for symmDiff ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Min",
  "kind": "inductive",
  "doc_string":
  "`Min α` is the typeclass which supports the operation `min x y` where `x y : α`.",
  "args": ""},
 {"type":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [inst : Mul α] →\n        [inst_1 : Add α] → [inst_2 : Mul β] → [inst_3 : Add β] → [inst_4 : RingEquivClass F α β] → CoeTC F (α ≃+* β)",
  "name": "instCoeTCRingEquiv",
  "kind": "def",
  "doc_string":
  "Any type satisfying `RingEquivClass` can be cast into `RingEquiv` via\n`RingEquivClass.toRingEquiv`. ",
  "args": ""},
 {"type": "{α : Type u} → (o : Option α) → Option.isSome o = true → α",
  "name": "Option.get",
  "kind": "def",
  "doc_string":
  "Extracts the value `a` from an option that is known to be `some a` for some `a`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → List α → List β → List (Option α × β) × List α",
  "name": "List.zipRight'",
  "kind": "def",
  "doc_string":
  "Right-biased version of `List.zip`. `zipRight' as bs` returns the list of\npairs `(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `as` is shorter than `bs`, the\nremaining `bᵢ` are paired with `none`. Also returns the remaining `as`.\n```\nzipRight' [1] ['a', 'b'] = ([(some 1, 'a'), (none, 'b')], [])\nzipRight' [1, 2] ['a'] = ([(some 1, 'a')], [2])\nzipRight' = zipWithRight' prod.mk\n```\n",
  "args": ""},
 {"type": "{α : Type u} → [inst : CommMonoid α] → (a b : α) → a * b = 1 → αˣ",
  "name": "Units.mkOfMulEqOne",
  "kind": "def",
  "doc_string":
  "For `a, b` in a `CommMonoid` such that `a * b = 1`, makes a unit out of `a`. ",
  "args": ""},
 {"type": "ℕ → ℕ → List ℕ",
  "name": "List.range'",
  "kind": "def",
  "doc_string":
  "`range' s n` is the list of numbers `[s, s+1, ..., s+n-1]`.\nIt is intended mainly for proving properties of `range` and `iota`. ",
  "args": ""},
 {"type": "{ε σ α β : Type u} → (α → β) → EStateM ε σ α → EStateM ε σ β",
  "name": "EStateM.map",
  "kind": "def",
  "doc_string": "The `map` operation of the `EStateM` monad. ",
  "args": ""},
 {"type": "Lean.Name → ToAdditive.Config → Lean.AttrM Unit",
  "name": "ToAdditive.addToAdditiveAttr",
  "kind": "def",
  "doc_string":
  "`addToAdditiveAttr src cfg` adds a `@[to_additive]` attribute to `src` with configuration `cfg`.\nSee the attribute implementation for more details. ",
  "args": ""},
 {"type": "{f : Type u → Type v} → [self : Pure f] → {α : Type u} → α → f α",
  "name": "Pure.pure",
  "kind": "def",
  "doc_string":
  "If `a : α`, then `pure a : f α` represents a monadic action that does\nnothing and returns `a`. ",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HSMul",
  "kind": "inductive",
  "doc_string":
  "The notation typeclass for heterogeneous scalar multiplication.\nThis enables the notation `a • b : γ` where `a : α`, `b : β`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : DivisionSemiring α] (a : α), DivisionSemiring.zpow 0 a = 1",
  "name": "DivisionSemiring.zpow_zero'",
  "kind": "def",
  "doc_string": "`a ^ 0 = 1` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : NonUnitalNonAssocRing α] (a b c : α), (a - b) * c = a * c - b * c",
  "name": "sub_mul",
  "kind": "theorem",
  "doc_string": "**Alias** of `mul_sub_right_distrib`.",
  "args": ""},
 {"type":
  "{A : Type u_1} →\n  {B : Type u_2} →\n    [inst : AddMonoid A] →\n      [inst_1 : AddMonoid B] →\n        (f : A →+ B) → (g : B → A) → Function.LeftInverse g ↑f → Function.RightInverse g ↑f → B →+ A",
  "name": "AddMonoidHom.inverse",
  "kind": "def",
  "doc_string":
  "The inverse of a bijective `AddMonoidHom` is an `AddMonoidHom`.",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort u_1} → {γ : Sort u_2} → (α → β) → (α → γ) → (β → γ) → β → γ",
  "name": "Function.extend",
  "kind": "def",
  "doc_string":
  "`extend f g e'` extends a function `g : α → γ`\nalong a function `f : α → β` to a function `β → γ`,\nby using the values of `g` on the range of `f`\nand the values of an auxiliary function `e' : β → γ` elsewhere.\n\nMostly useful when `f` is injective, or more generally when `g.factors_through f` ",
  "args": ""},
 {"type":
  "{β : Type v} → {m : Type v → Type w} → [inst : Monad m] → ByteArray → β → (UInt8 → β → m (ForInStep β)) → m β",
  "name": "ByteArray.forInUnsafe",
  "kind": "def",
  "doc_string":
  "We claim this unsafe implementation is correct because an array cannot have more than `usizeSz` elements in our runtime.\nThis is similar to the `Array` version.\n\nTODO: avoid code duplication in the future after we improve the compiler.\n",
  "args": ""},
 {"type":
  "{C : ℕ → Sort u} → {n m : ℕ} → n ≤ m → ({k : ℕ} → C k → C (k + 1)) → C n → C m",
  "name": "Nat.leRecOn",
  "kind": "def",
  "doc_string":
  "Recursion starting at a non-zero number: given a map `C k → C (k+1)` for each `k`,\nthere is a map from `C n` to each `C m`, `n ≤ m`. For a version where the assumption is only made\nwhen `k ≥ n`, see `leRecOn`. ",
  "args": ""},
 {"type": "Neg ℤ",
  "name": "Int.instNegInt",
  "kind": "def",
  "doc_string":
  "The `Neg Int` default instance must have priority higher than `low` since\nthe default instance `OfNat Nat n` has `low` priority.\n```\n#check -42\n```\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Repr α] → [inst : SlimCheck.Shrinkable α] → SlimCheck.Gen α → SlimCheck.SampleableExt α",
  "name": "SlimCheck.SampleableExt.mkSelfContained",
  "kind": "def",
  "doc_string":
  "Use to generate instance whose purpose is to simply generate values\nof a type directly using the `Gen` monad ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Sort u_2} → [inst : Subsingleton β] → Squash α → (α → β) → β",
  "name": "Squash.lift",
  "kind": "def",
  "doc_string":
  "If `β` is a subsingleton, then a function `α → β` lifts to `Squash α → β`. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "ComplexShape",
  "kind": "inductive",
  "doc_string":
  "A `c : ComplexShape ι` describes the shape of a chain complex,\nwith chain groups indexed by `ι`.\nTypically `ι` will be `ℕ`, `ℤ`, or `Fin n`.\n\nThere is a relation `Rel : ι → ι → Prop`,\nand we will only allow a non-zero differential from `i` to `j` when `Rel i j`.\n\nThere are axioms which imply `{ j // c.Rel i j }` and `{ i // c.Rel i j }` are subsingletons.\nThis means that the shape consists of some union of lines, rays, intervals, and circles.\n\nBelow we define `c.next` and `c.prev` which provide these related elements.\n",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} [inst : Applicative m] [inst_1 : LawfulApplicative m] {x : m α},\n  SatisfiesM (fun x => True) x",
  "name": "SatisfiesM.trivial",
  "kind": "theorem",
  "doc_string":
  "If `p` is always true, then every `x` satisfies it.\n(This is the strongest postcondition version of `of_true`.)\n",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → N →+ M × N",
  "name": "AddMonoidHom.inr",
  "kind": "def",
  "doc_string":
  "Given additive monoids `A`, `B`, the natural inclusion homomorphism\nfrom `B` to `A × B`.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "LinearOrderedCancelAddCommMonoid",
  "kind": "inductive",
  "doc_string":
  "A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone. ",
  "args": ""},
 {"type": "{α : Type u} → (ℕ → α → α) → ℕ → α → α",
  "name": "Nat.foldRev",
  "kind": "def",
  "doc_string":
  "`Nat.foldRev` evaluates `f` on the numbers up to `n` exclusive, in decreasing order:\n* `Nat.foldRev f 3 init = f 0 <| f 1 <| f 2 <| init`\n",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LT α] → α → Prop",
  "name": "Order.IsPredLimit",
  "kind": "def",
  "doc_string":
  "A predecessor limit is a value that isn't covered by any other.\n\nIt's so named because in a predecessor order, a predecessor limit can't be the predecessor of\nanything greater. ",
  "args": ""},
 {"type": "{α : Sort u} → (r : α → α → Prop) → α → Quot r",
  "name": "Quot.mk",
  "kind": "def",
  "doc_string":
  "Given a type `α` and any binary relation `r` on `α`, `Quot.mk` maps `α` to `Quot r`.\nSo that if `r : α → α → Prop` and `a : α`, then `Quot.mk r a` is an element of `Quot r`.\n\nSee `Quot`.\n",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {γ : Type w} →\n    [inst : CommSemiring α] →\n      [inst_1 : Zero γ] →\n        [inst_2 : One γ] →\n          [inst_3 : Add γ] →\n            [inst_4 : Mul γ] →\n              [inst_5 : SMul ℕ γ] →\n                [inst_6 : NatCast γ] →\n                  [inst_7 : Pow γ ℕ] →\n                    (f : α → γ) →\n                      Function.Surjective f →\n                        f 0 = 0 →\n                          f 1 = 1 →\n                            (∀ (x y : α), f (x + y) = f x + f y) →\n                              (∀ (x y : α), f (x * y) = f x * f y) →\n                                (∀ (x : α) (n : ℕ), f (n • x) = n • f x) →\n                                  (∀ (x : α) (n : ℕ), f (x ^ n) = f x ^ n) → (∀ (n : ℕ), f ↑n = ↑n) → CommSemiring γ",
  "name": "Function.Surjective.commSemiring",
  "kind": "def",
  "doc_string":
  "Pushforward a `CommSemiring` instance along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u} → Vector α 0",
  "name": "Vector.nil",
  "kind": "def",
  "doc_string": "The empty vector with elements of type `α` ",
  "args": ""},
 {"type":
  "{a : Lean.Level} →\n  {arg : Q(Type a)} →\n    {sα : Q(CommSemiring «$arg»)} →\n      {a_1 b : Q(«$arg»)} → Mathlib.Tactic.Ring.ExProd sα a_1 → Mathlib.Tactic.Ring.ExProd sα b → Ordering",
  "name": "Mathlib.Tactic.Ring.ExProd.cmp",
  "kind": "opaque",
  "doc_string":
  "A total order on normalized expressions.\nThis is not an `Ord` instance because it is heterogeneous.\n",
  "args": ""},
 {"type": "Lean.Option Bool",
  "name": "Mathlib.Prelude.Rename.align.precheck",
  "kind": "opaque",
  "doc_string":
  "Check that the referenced lean 4 definition exists in an `#align` directive. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b c : α}, b < a⁻¹ * c → a * b < c",
  "name": "mul_lt_of_lt_inv_mul",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `lt_inv_mul_iff_mul_lt`.",
  "args": ""},
 {"type": "Lean.NameMapExtension ℕ",
  "name": "ToAdditive.relevantArgAttr",
  "kind": "opaque",
  "doc_string":
  "An attribute that is automatically added to declarations tagged with `@[to_additive]`, if needed.\n\nThis attribute tells which argument is the type where this declaration uses the multiplicative\nstructure. If there are multiple argument, we typically tag the first one.\nIf this argument contains a fixed type, this declaration will note be additivized.\nSee the Heuristics section of `to_additive.attr` for more details.\n\nIf a declaration is not tagged, it is presumed that the first argument is relevant.\n`@[to_additive]` uses the function `to_additive.first_multiplicative_arg` to automatically tag\ndeclarations. It is ok to update it manually if the automatic tagging made an error.\n\nImplementation note: we only allow exactly 1 relevant argument, even though some declarations\n(like `prod.group`) have multiple arguments with a multiplicative structure on it.\nThe reason is that whether we additivize a declaration is an all-or-nothing decision, and if\nwe will not be able to additivize declarations that (e.g.) talk about multiplication on `ℕ × α`\nanyway.\n\nWarning: adding `@[to_additive_reorder]` with an equal or smaller number than the number in this\nattribute is currently not supported.\n",
  "args": ""},
 {"type": "Lean.Elab.Tactic.Tactic",
  "name": "Mathlib.Tactic.PushNeg.elabPushNegConv",
  "kind": "def",
  "doc_string": "Execute `push_neg` as a conv tactic. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CoheytingAlgebra α] {a b : α}, Codisjoint b a → ￢a ≤ b",
  "name": "Codisjoint.hnot_le_left",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `hnot_le_iff_codisjoint_left`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : DivisionMonoid β] (f : α →* β) (a : α), ↑f a⁻¹ = (↑f a)⁻¹",
  "name": "MonoidHom.map_inv",
  "kind": "theorem",
  "doc_string": "Group homomorphisms preserve inverse. ",
  "args": ""},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α : Type u} → (α → m (ULift Bool)) → List α → m (Option α)",
  "name": "List.findM?'",
  "kind": "def",
  "doc_string":
  "`findM? p l` returns the first element `a` of `l` for which `p a` returns\ntrue. `findM?` short-circuits, so `p` is not necessarily run on every `a` in\n`l`. This is a monadic version of `List.find`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {r : α → α → Sort u_2} → {a b c : α} → [inst : Trans r r r] → r a b → r b c → r a c",
  "name": "Trans.simple",
  "kind": "def",
  "doc_string": "Composition using the `Trans` class in the homogeneous case. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Nontrivial M] → [hM : MonoidWithZero M] → (∀ (a : M), IsUnit a ∨ a = 0) → GroupWithZero M",
  "name": "groupWithZeroOfIsUnitOrEqZero",
  "kind": "def",
  "doc_string":
  "Constructs a `GroupWithZero` structure on a `MonoidWithZero`\nconsisting only of units and 0. ",
  "args": ""},
 {"type": "Sat.Valuation → Sat.Clause → Prop",
  "name": "Sat.Valuation.satisfies",
  "kind": "def",
  "doc_string":
  "`v.satisfies c` asserts that clause `c` satisfied by the valuation.\nIt is written in a negative way: A clause like `a ∨ ¬b ∨ c` is rewritten as\n`¬a → b → ¬c → False`, so we are asserting that it is not the case that\nall literals in the clause are falsified. ",
  "args": ""},
 {"type": "{α : Type u_1} → ℕ → List α → List (List α)",
  "name": "List.toChunks",
  "kind": "def",
  "doc_string":
  "`xs.toChunks n` splits the list into sublists of size at most `n`,\nsuch that `(xs.toChunks n).join = xs`.\n```\n[1, 2, 3, 4, 5, 6, 7, 8].toChunks 10 = [[1, 2, 3, 4, 5, 6, 7, 8]]\n[1, 2, 3, 4, 5, 6, 7, 8].toChunks 3 = [[1, 2, 3], [4, 5, 6], [7, 8]]\n[1, 2, 3, 4, 5, 6, 7, 8].toChunks 2 = [[1, 2], [3, 4], [5, 6], [7, 8]]\n[1, 2, 3, 4, 5, 6, 7, 8].toChunks 0 = [[1, 2, 3, 4, 5, 6, 7, 8]]\n```\n",
  "args": ""},
 {"type": "(α : Sort u) → outParam (α → Sort v) → Sort (max (max 1 u) v)",
  "name": "CoeFun",
  "kind": "inductive",
  "doc_string":
  "`CoeFun α (γ : α → Sort v)` is a coercion to a function. `γ a` should be a\n(coercion-to-)function type, and this is triggered whenever an element\n`f : α` appears in an application like `f x` which would not make sense since\n`f` does not have a function type. This is automatically turned into `CoeFun.coe f x`.\n",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} → [inst_1 : CategoryTheory.Category D] → CategoryTheory.Category (C ⥤ D)",
  "name": "CategoryTheory.Functor.category",
  "kind": "def",
  "doc_string":
  "`Functor.category C D` gives the category structure on functors and natural transformations\nbetween categories `C` and `D`.\n\nNotice that if `C` and `D` are both small categories at the same universe level,\nthis is another small category at that level.\nHowever if `C` and `D` are both large categories at the same universe level,\nthis is a small category at the next higher level.\n",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Set α → Prop",
  "name": "AntitoneOn",
  "kind": "def",
  "doc_string":
  "A function `f` is antitone on `s` if, for all `a, b ∈ s`, `a ≤ b` implies `f b ≤ f a`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : MulOneClass M] → AddSubmonoid (Additive M) ≃o Submonoid M",
  "name": "AddSubmonoid.toSubmonoid'",
  "kind": "def",
  "doc_string":
  "Additive submonoids of an additive monoid `Additive M` are isomorphic to submonoids of `M`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {b : α},\n  Set.Nonempty s → (∀ (a : α), a ∈ s → a ≤ b) → (∀ (ub : α), (∀ (a : α), a ∈ s → a ≤ ub) → b ≤ ub) → supₛ s = b",
  "name": "csupₛ_eq_of_is_forall_le_of_forall_le_imp_ge",
  "kind": "theorem",
  "doc_string":
  "Introduction rule to prove that `b` is the supremum of `s`: it suffices to check that\n1) `b` is an upper bound\n2) every other upper bound `b'` satisfies `b ≤ b'`.",
  "args": ""},
 {"type": "ℕ → ℕ → List ℕ",
  "name": "List.range'TR",
  "kind": "def",
  "doc_string": "Optimized version of `range'`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : LE α] → [inst : Add α] → [inst : Sub α] → Type",
  "name": "OrderedSub",
  "kind": "inductive",
  "doc_string":
  "`OrderedSub α` means that `α` has a subtraction characterized by `a - b ≤ c ↔ a ≤ c + b`.\nIn other words, `a - b` is the least `c` such that `a ≤ b + c`.\n\nThis is satisfied both by the subtraction in additive ordered groups and by truncated subtraction\nin canonically ordered monoids on many specific types.\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_↔_»",
  "kind": "def",
  "doc_string":
  "If and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Subsingleton α] (e : Equiv.Perm α), ↑e = id",
  "name": "Equiv.Perm.coe_subsingleton",
  "kind": "theorem",
  "doc_string":
  "This cannot be a `simp` lemmas as it incorrectly matches against `e : α ≃ synonym α`, when\n`synonym α` is semireducible. This makes a mess of `multiplicative.of_add` etc. ",
  "args": ""},
 {"type": "{α : Type u} → {β : α → Type v} → (fst : α) → β fst → Sigma β",
  "name": "Sigma.mk",
  "kind": "def",
  "doc_string":
  "Constructor for a dependent pair. If `a : α` and `b : β a` then `⟨a, b⟩ : Sigma β`.\n(This will usually require a type ascription to determine `β`\nsince it is not determined from `a` and `b` alone.) ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  a ≤ 0 → b ≤ 0 → a + b ≤ 0",
  "name": "Right.add_nonpos",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_nonpos`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {s : Set α} {t : Set β},\n  (∀ (b : β), b ∈ t → Function.Injective fun a => f a b) →\n    ((Set.PairwiseDisjoint t fun b => (fun a => f a b) '' s) ↔ Set.InjOn (fun p => f p.fst p.snd) (s ×ˢ t))",
  "name": "Set.pairwiseDisjoint_image_left_iff",
  "kind": "theorem",
  "doc_string":
  "The partial images of a binary function `f` whose partial evaluations are injective are pairwise\ndisjoint iff `f` is injective . ",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.shiftl",
  "kind": "def",
  "doc_string":
  "`shiftl m n` produces a natural number whose binary representation\nis obtained by left-shifting the binary representation of `m` by `n` places ",
  "args": ""},
 {"type": "∀ {a c b d : Prop}, (a ↔ c) → (b ↔ d) → ((a ↔ b) ↔ (c ↔ d))",
  "name": "Iff.iff",
  "kind": "theorem",
  "doc_string": "**Alias** of `iff_congr`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} {p : α → Prop} (f : Equiv.Perm α) (hf : ∀ (x : α), p x ↔ p (↑f⁻¹ x)),\n  Equiv.Perm.subtypePerm f⁻¹ hf = (Equiv.Perm.subtypePerm f (_ : ∀ (x : α), p x ↔ p (↑f x)))⁻¹",
  "name": "Equiv.Perm.subtypePerm_inv",
  "kind": "theorem",
  "doc_string": "See `Equiv.Perm.inv_subtypePerm`",
  "args": ""},
 {"type": "{V : Type u_1} → [inst : Quiver V] → {X Y : V} → (X ⟶ Y) → (X ⟶ Y)",
  "name": "Quiver.Hom.toPos",
  "kind": "def",
  "doc_string":
  "Shorthand for the \"forward\" arrow corresponding to `f` in `symmetrify V` ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AndThen",
  "kind": "inductive",
  "doc_string":
  "The homogeneous version of `HAndThen`: `a >> b : α` where `a b : α`.\nBecause `b` is \"lazy\" in this notation, it is passed as `Unit → α` to the\nimplementation so it can decide when to evaluate it.\n",
  "args": ""},
 {"type":
  "{β : Sort u_1} → {α : Sort u_2} → {p : β → Prop} → α ≃ Subtype p → α ↪ β",
  "name": "Equiv.asEmbedding",
  "kind": "def",
  "doc_string":
  "Given an equivalence to a subtype, produce an embedding to the elements of the corresponding\nset. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} [inst : MonoidWithZero R] [inst_1 : Zero M] [self : MulActionWithZero R M] (m : M),\n  0 • m = 0",
  "name": "MulActionWithZero.zero_smul",
  "kind": "def",
  "doc_string": "Scalar multiplication by the scalar `0` is `0`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : OrderedCancelCommMonoid α] →\n    {β : Type u_1} →\n      [inst_1 : One β] →\n        [inst_2 : Mul β] →\n          [inst_3 : Pow β ℕ] →\n            (f : β → α) →\n              Function.Injective f →\n                f 1 = 1 →\n                  (∀ (x y : β), f (x * y) = f x * f y) →\n                    (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) → OrderedCancelCommMonoid β",
  "name": "Function.Injective.orderedCancelCommMonoid",
  "kind": "def",
  "doc_string":
  "Pullback an `OrderedCancelCommMonoid` under an injective map.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "(R : Type u_1) →\n  (S : Type u_2) → [inst : NonAssocSemiring R] → [inst_1 : NonAssocSemiring S] → [inst_2 : Subsingleton S] → R ≃+* R × S",
  "name": "RingEquiv.prodZeroRing",
  "kind": "def",
  "doc_string":
  "A ring `R` is isomorphic to `R × S` when `S` is the zero ring ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D]\n  [inst_2 : Quiver.IsThin C], Quiver.IsThin (D ⥤ C)",
  "name": "CategoryTheory.functor_thin",
  "kind": "def",
  "doc_string": "If `C` is a thin category, then `D ⥤ C` is a thin category. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {f g : α → α},\n  Function.Commute f g → Set.InvOn f g (Function.fixedPoints (f ∘ g)) (Function.fixedPoints (f ∘ g))",
  "name": "Function.Commute.invOn_fixedPoints_comp",
  "kind": "theorem",
  "doc_string":
  "If self-maps `f` and `g` commute, then they are inverse of each other on the set of fixed points\nof `f ∘ g`. This is a particular case of `Function.invOn_fixedPoints_comp`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c : α},\n  a ≤ c - b → a + b ≤ c",
  "name": "add_le_of_le_sub_right",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `le_sub_iff_add_le`.",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → AddHom Mᵃᵒᵖ Nᵃᵒᵖ ≃ AddHom M N",
  "name": "AddHom.unop",
  "kind": "def",
  "doc_string":
  "The 'unopposite' of an additive semigroup homomorphism `Mᵃᵒᵖ →ₙ+ Nᵃᵒᵖ`. Inverse\nto `AddHom.op`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteLattice α] (s : Set α) (a : α), a ∈ s → a ≤ supₛ s",
  "name": "CompleteLattice.le_supₛ",
  "kind": "def",
  "doc_string": "Any element of a set is less than the set supremum. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₂] →\n      [inst_1 : One M₂] →\n        [inst_2 : Pow M₂ ℕ] →\n          [inst_3 : CommMonoid M₁] →\n            (f : M₁ → M₂) →\n              Function.Surjective f →\n                f 1 = 1 →\n                  (∀ (x y : M₁), f (x * y) = f x * f y) → (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) → CommMonoid M₂",
  "name": "Function.Surjective.commMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `1` and `*` is a commutative monoid, if it admits a surjective map that\npreserves `1` and `*` from a commutative monoid. See note [reducible non-instances]. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Preorder α] → [inst : SuccOrder α] → Prop",
  "name": "IsSuccArchimedean",
  "kind": "inductive",
  "doc_string":
  "A `SuccOrder` is succ-archimedean if one can go from any two comparable elements by iterating\n`succ` ",
  "args": ""},
 {"type": "{α : Sort u} → α → α → Prop",
  "name": "emptyRelation",
  "kind": "def",
  "doc_string":
  "The empty relation is the relation on `α` which is always `False`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Contrapose.contrapose",
  "kind": "def",
  "doc_string":
  "Transforms the goal into its contrapositive.\n* `contrapose`     turns a goal `P → Q` into `¬ Q → ¬ P`\n* `contrapose h`   first reverts the local assumption `h`, and then uses `contrapose` and `intro h`\n* `contrapose h with new_h` uses the name `new_h` for the introduced hypothesis\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : GroupWithZero M], Set.center Mˣ = Units.val ⁻¹' Set.center M",
  "name": "Set.center_units_eq",
  "kind": "theorem",
  "doc_string":
  "In a group with zero, the center of the units is the preimage of the center. ",
  "args": ""},
 {"type": "ℕ+ → ℕ → ℕ → ℕ+ × ℕ",
  "name": "PNat.modDivAux",
  "kind": "def",
  "doc_string":
  "We define `m % k` and `m / k` in the same way as for `ℕ`\nexcept that when `m = n * k` we take `m % k = k` and\n`m / k = n - 1`.  This ensures that `m % k` is always positive\nand `m = (m % k) + k * (m / k)` in all cases.  Later we\ndefine a function `div_exact` which gives the usual `m / k`\nin the case where `k` divides `m`.\n",
  "args": ""},
 {"type": "{ε σ α : Type u} → EStateM ε σ α → σ → EStateM.Result ε σ α",
  "name": "EStateM.run",
  "kind": "def",
  "doc_string": "Execute an `EStateM` on initial state `s` to get a `Result`. ",
  "args": ""},
 {"type":
  "Linarith.Sum → Linarith.Map Linarith.Monom ℕ → Linarith.Map Linarith.Monom ℕ × Linarith.Map ℕ ℤ",
  "name": "Linarith.elimMonom",
  "kind": "def",
  "doc_string":
  "`elimMonom s map` eliminates the monomial level of the `Sum` `s`.\n\n`map` is a lookup map from monomials to variable numbers.\nThe output `RBMap ℕ ℤ` has the same structure as `s : Sum`,\nbut each monomial key is replaced with its index according to `map`.\nIf any new monomials are encountered, they are assigned variable numbers and `map` is updated.\n ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β → α) → α → List β → List α",
  "name": "List.scanlTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `scanl`. ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → [inst : Unique β] → α ≃ β → Unique α",
  "name": "Equiv.unique",
  "kind": "def",
  "doc_string": "If `α ≃ β` and `β` is a singleton type, then so is `α`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Group α] → [inst : MulAction α β] → α → Equiv.Perm β",
  "name": "MulAction.toPerm",
  "kind": "def",
  "doc_string":
  "Given an action of a group `α` on `β`, each `g : α` defines a permutation of `β`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : LinearOrderedCancelAddCommMonoid M] →\n    {A : Type u_2} →\n      [inst_1 : SetLike A M] →\n        [inst : AddSubmonoidClass A M] → (S : A) → LinearOrderedCancelAddCommMonoid { x // x ∈ S }",
  "name": "AddSubmonoidClass.toLinearOrderedCancelAddCommMonoid",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of a `LinearOrderedCancelAddCommMonoid` is\na `LinearOrderedCancelAddCommMonoid`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedCancelCommMonoid α] (a b : α), min a b = if a ≤ b then a else b",
  "name": "LinearOrderedCancelCommMonoid.min_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `minOfLe`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Add M] →\n      [inst_1 : Add N] →\n        (f : AddHom M N) → (N' : AddSubsemigroup N) → AddHom { x // x ∈ AddSubsemigroup.comap f N' } { x // x ∈ N' }",
  "name": "AddHom.subsemigroupComap",
  "kind": "def",
  "doc_string":
  "the `AddHom` from the preimage of an additive subsemigroup to itself.",
  "args": ""},
 {"type": "∀ {m n k : ℕ}, n * k < m → m < n * (k + 1) → ¬n ∣ m",
  "name": "Nat.not_dvd_of_between_consec_multiples",
  "kind": "theorem",
  "doc_string":
  "`m` is not divisible by `n` if it is between `n * k` and `n * (k + 1)` for some `k`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term{}»",
  "kind": "def",
  "doc_string":
  "`∅` or `{}` is the empty set or empty collection.\nIt is supported by the `EmptyCollection` typeclass. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Add M] → CompleteLattice (AddSubsemigroup M)",
  "name": "AddSubsemigroup.instCompleteLatticeSubsemigroup",
  "kind": "def",
  "doc_string":
  "The `AddSubsemigroup`s of an `AddMonoid` form a complete lattice.",
  "args": ""},
 {"type":
  "∀ {R : Type u} [self : AddGroupWithOne R] (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)",
  "name": "AddGroupWithOne.intCast_negSucc",
  "kind": "def",
  "doc_string":
  "The canonical homorphism `ℤ → R` for negative values is just the negation of the values\nof the canonical homomorphism `ℕ → R`. ",
  "args": ""},
 {"type": "{S : Type u_1} → [inst : Add S] → S → S → Prop",
  "name": "AddCommute",
  "kind": "def",
  "doc_string": "Two elements additively commute if `a + b = b + a`",
  "args": ""},
 {"type":
  "{a : Lean.Level} →\n  {arg : Q(Type a)} →\n    {sα : Q(CommSemiring «$arg»)} →\n      {a_1 b : Q(«$arg»)} → Mathlib.Tactic.Ring.ExBase sα a_1 → Mathlib.Tactic.Ring.ExBase sα b → Bool",
  "name": "Mathlib.Tactic.Ring.ExBase.eq",
  "kind": "opaque",
  "doc_string":
  "Equality test for expressions. This is not a `BEq` instance because it is heterogeneous. ",
  "args": ""},
 {"type":
  "{α' : Type u_1} →\n  {β' : Type u_2} → Equiv.Perm α' → {p : β' → Prop} → [inst : DecidablePred p] → α' ≃ Subtype p → Equiv.Perm β'",
  "name": "Equiv.Perm.extendDomain",
  "kind": "def",
  "doc_string":
  "Extend the domain of `e : Equiv.Perm α` to one that is over `β` via `f : α → Subtype p`,\nwhere `p : β → Prop`, permuting only the `b : β` that satisfy `p b`.\nThis can be used to extend the domain across a function `f : α → β`,\nkeeping everything outside of `Set.range f` fixed. For this use-case `Equiv` given by `f` can\nbe constructed by `Equiv.of_leftInverse'` or `Equiv.of_leftInverse` when there is a known\ninverse, or `Equiv.ofInjective` in the general case.`.\n",
  "args": ""},
 {"type": "ℕ → List Bool",
  "name": "Nat.bits",
  "kind": "def",
  "doc_string":
  "`bits n` returns a list of Bools which correspond to the binary representation of n",
  "args": ""},
 {"type": "∀ {α : Type u_1} {s t : Set α}, s ⊆ t → s ≤ t",
  "name": "HasSubset.Subset.le",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `Set.le_iff_subset`.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "HasInf",
  "kind": "inductive",
  "doc_string": "Typeclass for the `⊓` (`\\glb`) notation ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] (c : ClosureOperator α),\n  c =\n    ClosureOperator.mk₃ (↑c.toOrderHom) (ClosureOperator.closed c) (_ : ∀ (x : α), x ≤ ↑c.toOrderHom x)\n      (_ : ∀ (x : α), ↑c.toOrderHom x ∈ ClosureOperator.closed c)\n      (_ : ∀ (x y : α), x ≤ y → ClosureOperator.closed c y → ↑c.toOrderHom x ≤ y)",
  "name": "ClosureOperator.eq_mk₃_closed",
  "kind": "theorem",
  "doc_string":
  "A closure operator is equal to the closure operator obtained by feeding `c.closed` into the\n`mk₃` constructor. ",
  "args": ""},
 {"type":
  "∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x",
  "name": "IsField.mul_comm",
  "kind": "def",
  "doc_string": "Fields are commutative. ",
  "args": ""},
 {"type": "ℕ+ ≃ ℕ",
  "name": "Equiv.pnatEquivNat",
  "kind": "def",
  "doc_string":
  "An equivalence between `ℕ+` and `ℕ` given by `PNat.natPred` and `Nat.succPNat`. ",
  "args": ""},
 {"type": "{g : Type u} → [self : RandomGen g] → g → ℕ × g",
  "name": "RandomGen.next",
  "kind": "def",
  "doc_string":
  "`next` operation returns a natural number that is uniformly distributed\n the range returned by `range` (including both end points),\nand a new generator. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {s : Set α} {t : Set β},\n  (∀ (a : α), a ∈ s → Function.Injective (f a)) →\n    ((Set.PairwiseDisjoint s fun a => f a '' t) ↔ Set.InjOn (fun p => f p.fst p.snd) (s ×ˢ t))",
  "name": "Set.pairwiseDisjoint_image_right_iff",
  "kind": "theorem",
  "doc_string":
  "The partial images of a binary function `f` whose partial evaluations are injective are pairwise\ndisjoint iff `f` is injective . ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {F : C ⥤ D} →\n          [self : CategoryTheory.Full F] →\n            {X Y : C} → (Prefunctor.obj F.toPrefunctor X ⟶ Prefunctor.obj F.toPrefunctor Y) → (X ⟶ Y)",
  "name": "CategoryTheory.Full.preimage",
  "kind": "def",
  "doc_string": "The data of a preimage for every `f : F.obj X ⟶ F.obj Y`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → Rel α β → (s : Set α) → Rel { x // x ∈ s } β",
  "name": "Rel.restrictDomain",
  "kind": "def",
  "doc_string": "Restrict the domain of a relation to a subtype. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ↪r s → Function.swap r ↪r Function.swap s",
  "name": "RelEmbedding.swap",
  "kind": "def",
  "doc_string":
  "A relation embedding is also a relation embedding between dual relations. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : SuccOrder α] [inst_2 : IsSuccArchimedean α] (r : α → α → Prop)\n  {n m : α}, (∀ (i : α), i ∈ Set.Ico n m → r i (Order.succ i)) → n < m → Relation.TransGen r n m",
  "name": "transGen_of_succ_of_lt",
  "kind": "theorem",
  "doc_string":
  "For `n < m`, `(n, m)` is in the transitive closure of a relation `~` if `i ~ succ i`\nfor all `i` between `n` and `m`. ",
  "args": ""},
 {"type": "List Bool → Bool",
  "name": "List.and",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. Returns true if every element of `l` is the value `true`.\n* `and [a, b, c] = a && b && c`\n",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List (α × α)",
  "name": "List.revzip",
  "kind": "def",
  "doc_string":
  "`revzip l` returns a list of pairs of the elements of `l` paired\nwith the elements of `l` in reverse order.\n```\nrevzip [1, 2, 3, 4, 5] = [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)]\n```\n",
  "args": ""},
 {"type":
  "∀ (n : ℕ) {a : ℕ}, 0 < a → ((∃ k, a * k < n ∧ n < a * (k + 1)) ↔ ¬a ∣ n)",
  "name": "Nat.not_dvd_iff_between_consec_multiples",
  "kind": "theorem",
  "doc_string":
  "`n` is not divisible by `a` iff it is between `a * k` and `a * (k + 1)` for some `k`. ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → α) → outParam α → Prop",
  "name": "IsLeftId",
  "kind": "inductive",
  "doc_string": "A binary operation with a left identity. ",
  "args": ""},
 {"type": "∀ {G : Type u_1} [inst : SubNegMonoid G] (a b : G), a - b = a + -b",
  "name": "sub_eq_add_neg",
  "kind": "theorem",
  "doc_string":
  "Subtracting an element is the same as adding by its negative.\nThis is a duplicate of `SubNegMonoid.sub_eq_mul_neg` ensuring that the types unfold better.",
  "args": ""},
 {"type": "(α : Sort u) → α → Sort v → Sort (max 1 v)",
  "name": "CoeDep",
  "kind": "inductive",
  "doc_string":
  "`CoeDep α (x : α) β` is a typeclass for dependent coercions, that is, the type `β`\ncan depend on `x` (or rather, the value of `x` is available to typeclass search\nso an instance that relates `β` to `x` is allowed).\n\nDependent coercions do not participate in the transitive chaining process of\nregular coercions: they must exactly match the type mismatch on both sides.\n",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Multiplicative",
  "kind": "def",
  "doc_string":
  "If `α` carries some additive structure, then `Multiplicative α` carries the corresponding\nmultiplicative structure. ",
  "args": ""},
 {"type":
  "Bool →\n  (Lean.Name → Option Lean.Name) →\n    (Lean.Name → List ℕ) →\n      (Lean.Name → Option (List ℕ)) → (Lean.Name → Option Bool) → (Lean.Name → ℕ → Bool) → Lean.Expr → Lean.Expr",
  "name": "ToAdditive.applyReplacementFun.aux",
  "kind": "def",
  "doc_string": "Implementation of `applyReplacementFun`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → (α → β) → [inst : LT β] → (WellFounded fun x x_1 => x < x_1) → (s : Set α) → Set.Nonempty s → α",
  "name": "Function.argminOn",
  "kind": "def",
  "doc_string":
  "Given a function `f : α → β` where `β` carries a well-founded `<`, and a non-empty subset `s`\nof `α`, this is an element of `s` whose image under `f` is minimal in the sense of\n`Function.not_lt_argminOn`. ",
  "args": ""},
 {"type":
  "{S : Type u_1} →\n  [inst : OrderedRing S] →\n    {R : Type u_2} →\n      [inst_1 : Semiring R] →\n        (abv : R → S) → [inst_2 : IsAbsoluteValue abv] → [inst_3 : IsDomain S] → [inst_4 : Nontrivial R] → R →*₀ S",
  "name": "IsAbsoluteValue.abvHom",
  "kind": "def",
  "doc_string": "`abv` as a `MonoidWithZeroHom`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_+_»",
  "kind": "def",
  "doc_string":
  "`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "(u : Lean.Level) →\n  (α : Q(Type u)) →\n    Q(CommSemiring «$α») →\n      Mathlib.Tactic.Ring.Cache α →\n        Mathlib.Tactic.Polyrith.Source →\n          Lean.Expr →\n            Array (Mathlib.Tactic.Polyrith.Source × Mathlib.Tactic.Polyrith.Poly) →\n              Mathlib.Tactic.Ring.RingM (Array (Mathlib.Tactic.Polyrith.Source × Mathlib.Tactic.Polyrith.Poly))",
  "name": "Mathlib.Tactic.Polyrith.parseContext.processHyp",
  "kind": "def",
  "doc_string": "Parses a hypothesis and adds it to the `out` list. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, b < c → a ≤ b → a < c",
  "name": "LT.lt.trans_le'",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_lt_of_le'`.",
  "args": ""},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "name": "Function.Injective",
  "kind": "def",
  "doc_string":
  "A function `f : α → β` is called injective if `f x = f y` implies `x = y`. ",
  "args": ""},
 {"type": "{α : Type u} → Stream' α → Stream' α → Stream' α",
  "name": "Stream'.interleave",
  "kind": "def",
  "doc_string": "Interleave two streams. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : NonUnitalNonAssocSemiring α] → [inst_1 : NonUnitalNonAssocSemiring β] → (α →ₙ+* β) → α → β",
  "name": "NonUnitalRingHom.Simps.apply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → (M →+ N) → WithBot M →+ WithBot N",
  "name": "AddMonoidHom.withBotMap",
  "kind": "def",
  "doc_string": "A version of `WithBot.map` for `AddMonoidHom`s. ",
  "args": ""},
 {"type": "{S : Type u_1} → [inst : Mul S] → S → S → Prop",
  "name": "Commute",
  "kind": "def",
  "doc_string": "Two elements commute if `a * b = b * a`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : SuccOrder α] {a : α}, ¬IsMax a → a < Order.succ a",
  "name": "Order.lt_succ_of_not_isMax",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Order.lt_succ_iff_not_isMax`.",
  "args": ""},
 {"type":
  "{R : Type u_1} → {S : Type u_2} → [inst : EuclideanDomain R] → [inst_1 : OrderedSemiring S] → AbsoluteValue R S → Prop",
  "name": "AbsoluteValue.IsEuclidean",
  "kind": "inductive",
  "doc_string":
  "An absolute value `abv : R → S` is Euclidean if it is compatible with the\n`EuclideanDomain` structure on `R`, namely `abv` is strictly monotone with respect to the well\nfounded relation `≺` on `R`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → AddHom M N → M → N",
  "name": "AddHom.toFun",
  "kind": "def",
  "doc_string": "The underlying function ",
  "args": ""},
 {"type": "Type v → Prop",
  "name": "Small",
  "kind": "inductive",
  "doc_string":
  "A type is `Small.{w}` if there exists an equivalence to some `S : Type w`.\n",
  "args": ""},
 {"type": "{α : Type u} → ℕ → Stream' α → List α",
  "name": "Stream'.take",
  "kind": "def",
  "doc_string":
  "`take n s` returns a list of the `n` first elements of stream `s` ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {M : Type u_2} {N : Type u_3} {inst : MulZeroOneClass M} {inst_1 : MulZeroOneClass N}\n  [self : MonoidWithZeroHomClass F M N] (f : F), ↑f 0 = 0",
  "name": "MonoidWithZeroHomClass.map_zero",
  "kind": "def",
  "doc_string": "The proposition that the function preserves 0 ",
  "args": ""},
 {"type":
  "∀ {I : Type u} {f : I → Type v} [inst : DecidableEq I] [inst_1 : (i : I) → AddZeroClass (f i)] (x : (i : I) → f i)\n  (i j : I), AddCommute (Pi.single i (x i)) (Pi.single j (x j))",
  "name": "Pi.single_apply_commute",
  "kind": "theorem",
  "doc_string":
  "The injection into an additive pi group with the same values commutes.",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {ι : Sort u_1} [inst : ConditionallyCompleteLattice α] {b : α} [inst_1 : Nonempty ι] {f : ι → α},\n  (∀ (i : ι), b ≤ f i) → (∀ (w : α), b < w → ∃ i, f i < w) → (⨅ i, f i) = b",
  "name": "cinfᵢ_eq_of_forall_ge_of_forall_gt_exists_lt",
  "kind": "theorem",
  "doc_string":
  "Introduction rule to prove that `b` is the infimum of `f`: it suffices to check that `b`\nis smaller than `f i` for all `i`, and that this is not the case of any `w>b`.\nSee `infᵢ_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in complete lattices. ",
  "args": ""},
 {"type": "ℕ → ℕ",
  "name": "Nat.succ",
  "kind": "def",
  "doc_string":
  "The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. ",
  "args": ""},
 {"type":
  "Lean.Meta.ApplyConfig → ℕ → List Lean.Expr → Lean.MVarId → Lean.MetaM (List Lean.MVarId)",
  "name": "Mathlib.Tactic.applyRules",
  "kind": "def",
  "doc_string": "Implementation of the `apply_rules` tactic.\n",
  "args": ""},
 {"type": "Lean.Syntax → Lean.Elab.TermElabM Mathlib.Tactic.RingNF.Config",
  "name": "Mathlib.Tactic.RingNF.elabConfig",
  "kind": "def",
  "doc_string": "Function elaborating `RingNF.Config`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : DivisionRing α] → [inst_1 : CharZero α] → ℚ →+* α",
  "name": "Rat.castHom",
  "kind": "def",
  "doc_string": "Coercion `ℚ → α` as a `RingHom`. ",
  "args": ""},
 {"type": "{α : Type u_1} → Trunc α → Semiquot α",
  "name": "Semiquot.ofTrunc",
  "kind": "def",
  "doc_string": "Convert a `Trunc α` to a `Semiquot α`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → PProd α β ≃ α × β",
  "name": "Equiv.pprodEquivProd",
  "kind": "def",
  "doc_string": "`PProd α β` is equivalent to `α × β` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {a b c d : α},\n  c ≠ 0 → d ≠ 0 → a / c < b / d → (a * d - b * c) / (c * d) < 0",
  "name": "mul_sub_mul_div_mul_neg",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `mul_sub_mul_div_mul_neg_iff`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [self : SuccOrder α] (a : α), a ≤ SuccOrder.succ a",
  "name": "SuccOrder.le_succ",
  "kind": "def",
  "doc_string": "Proof of basic ordering with respect to `succ`",
  "args": ""},
 {"type": "Ordering → Ordering → Ordering",
  "name": "Ordering.then",
  "kind": "def",
  "doc_string":
  "If `o₁` and `o₂` are `Ordering`, then `o₁.then o₂` returns `o₁` unless it is `.eq`,\nin which case it returns `o₂`. Additionally, it has \"short-circuiting\" semantics similar to\nboolean `x && y`: if `o₁` is not `.eq` then the expression for `o₂` is not evaluated.\nThis is a useful primitive for constructing lexicographic comparator functions:\n```\nstructure Person where\n  name : String\n  age : Nat\n\ninstance : Ord Person where\n  compare a b := (compare a.name b.name).then (compare b.age a.age)\n```\nThis example will sort people first by name (in ascending order) and will sort people with\nthe same name by age (in descending order). (If all fields are sorted ascending and in the same\norder as they are listed in the structure, you can also use `deriving Ord` on the structure\ndefinition for the same effect.)\n",
  "args": ""},
 {"type": "{ι : Type u_1} → ComplexShape ι → ι → ι",
  "name": "ComplexShape.next",
  "kind": "def",
  "doc_string":
  "An arbitary choice of index `j` such that `Rel i j`, if such exists.\nReturns `i` otherwise.\n",
  "args": ""},
 {"type": "∀ {R : Type u_1} [inst : Semiring R], FaithfulSMul (R →+* R) R",
  "name": "RingHom.applyFaithfulSMul",
  "kind": "def",
  "doc_string": "`RingHom.applyDistribMulAction` is faithful. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α] (a b c : α), a < b → 0 < c → a * c < b * c",
  "name": "CanonicallyLinearOrderedSemifield.mul_lt_mul_of_pos_right",
  "kind": "def",
  "doc_string":
  "Right multiplication by a positive element is strictly monotone. ",
  "args": ""},
 {"type":
  "(A : Type u_1) → (B : Type u_2) → [inst : Add A] → [inst : Add B] → Type (max u_1 u_2)",
  "name": "AddEquiv",
  "kind": "inductive",
  "doc_string":
  "`AddEquiv α β` is the type of an equiv `α ≃ β` which preserves addition. ",
  "args": ""},
 {"type": "{M : Type u} → [self : AddMonoid M] → ℕ → M → M",
  "name": "AddMonoid.nsmul",
  "kind": "def",
  "doc_string": "Multiplication by a natural number. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : ConditionallyCompleteLattice α] (s : Set α) (a : α), BddBelow s → a ∈ s → infₛ s ≤ a",
  "name": "ConditionallyCompleteLattice.cinfₛ_le",
  "kind": "def",
  "doc_string": "`infₛ s ≤ a` for all `a ∈ s`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 3",
  "name": "zero_lt_three",
  "kind": "theorem",
  "doc_string": "See `zero_lt_three'` for a version with the type explicit. ",
  "args": ""},
 {"type":
  "{R₁ : Type u_1} →\n  {R₂ : Type u_2} → [inst : Semiring R₁] → [inst_1 : Semiring R₂] → (R₁ →+* R₂) → outParam (R₂ →+* R₁) → Prop",
  "name": "RingHomInvPair",
  "kind": "inductive",
  "doc_string":
  "Class that expresses the fact that two ring homomorphisms are inverses of each other. This is\nused to handle `symm` for semilinear equivalences. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} {fa : α → α} {fb : β → β} {x : α},\n  Function.IsFixedPt fa x → ∀ {g : α → β}, Function.Semiconj g fa fb → Function.IsFixedPt fb (g x)",
  "name": "Function.IsFixedPt.map",
  "kind": "theorem",
  "doc_string":
  "If `g` (semi)conjugates `fa` to `fb`, then it sends fixed points of `fa` to fixed points\nof `fb`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : PartialOrder α] → {a b : α} → a < b → OrderBot ↑(Set.Ico a b)",
  "name": "Set.Ico.orderBot",
  "kind": "def",
  "doc_string": "`Ico a b` has a bottom element whenever `a < b`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α}, 1 < a → 1 < b → 1 < a * b",
  "name": "Left.one_lt_mul",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → {x : Mul M} → {x_1 : Mul N} → (f : M →ₙ* N) → (f' : M → N) → f' = ↑f → M →ₙ* N",
  "name": "MulHom.copy",
  "kind": "def",
  "doc_string":
  "Copy of a `MulHom` with a new `toFun` equal to the old one. Useful to fix definitional\nequalities. ",
  "args": ""},
 {"type": "{α : Sort u} → α → {β : Sort u} → β → Prop",
  "name": "HEq",
  "kind": "inductive",
  "doc_string":
  "Heterogeneous equality. `HEq a b` asserts that `a` and `b` have the same\ntype, and casting `a` across the equality yields `b`, and vice versa.\n\nYou should avoid using this type if you can. Heterogeneous equality does not\nhave all the same properties as `Eq`, because the assumption that the types of\n`a` and `b` are equal is often too weak to prove theorems of interest. One\nimportant non-theorem is the analogue of `congr`: If `HEq f g` and `HEq x y`\nand `f x` and `g y` are well typed it does not follow that `HEq (f x) (g y)`.\n(This does follow if you have `f = g` instead.) However if `a` and `b` have\nthe same type then `a = b` and `HEq a b` ae equivalent.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Lattice α] → [inst_1 : BoundedOrder α] → [inst : IsSimpleOrder α] → DistribLattice α",
  "name": "IsSimpleOrder.distribLattice",
  "kind": "def",
  "doc_string":
  "A lattice that is a `BoundedOrder` is a distributive lattice.\nThis is not an instance to prevent loops ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {a b : α}, 0 < a → 0 < b → (a⁻¹ < b⁻¹ ↔ b < a)",
  "name": "inv_lt_inv",
  "kind": "theorem",
  "doc_string":
  "See `inv_lt_inv_of_lt` for the implication from right-to-left with one fewer assumption. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.tacticSimp_rw__",
  "kind": "def",
  "doc_string":
  "`simp_rw` functions as a mix of `simp` and `rw`. Like `rw`, it applies each\nrewrite rule in the given order, but like `simp` it repeatedly applies these\nrules and also under binders like `∀ x, ...`, `∃ x, ...` and `λ x, ...`.\nUsage:\n\n- `simp_rw [lemma_1, ..., lemma_n]` will rewrite the goal by applying the\n  lemmas in that order. A lemma preceded by `←` is applied in the reverse direction.\n- `simp_rw [lemma_1, ..., lemma_n] at h₁ ... hₙ` will rewrite the given hypotheses.\n- `simp_rw [...] at *` rewrites in the whole context: all hypotheses and the goal.\n\nLemmas passed to `simp_rw` must be expressions that are valid arguments to `simp`.\nFor example, neither `simp` nor `rw` can solve the following, but `simp_rw` can:\n\n```lean\nexample {a : ℕ}\n  (h1 : ∀ a b : ℕ, a - 1 ≤ b ↔ a ≤ b + 1)\n  (h2 : ∀ a b : ℕ, a ≤ b ↔ ∀ c, c < a → c < b) :\n  (∀ b, a - 1 ≤ b) = ∀ b c : ℕ, c < a → c < b + 1 :=\nby simp_rw [h1, h2]\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c d : α},\n  a < b → c < d → a + c < b + d",
  "name": "Right.add_lt_add",
  "kind": "theorem",
  "doc_string": "Only assumes right strict covariance",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : NonAssocSemiring α] → [inst_1 : NonAssocSemiring β] → (αᵐᵒᵖ →+* βᵐᵒᵖ) ≃ (α →+* β)",
  "name": "RingHom.unop",
  "kind": "def",
  "doc_string":
  "The 'unopposite' of a ring hom `αᵐᵒᵖ →+* βᵐᵒᵖ`. Inverse to `RingHom.op`. ",
  "args": ""},
 {"type":
  "{α β : Type u} → SlimCheck.Gen α → SlimCheck.Gen β → SlimCheck.Gen (α × β)",
  "name": "SlimCheck.Gen.prodOf",
  "kind": "def",
  "doc_string":
  "Given two generators produces a tuple consisting out of the result of both ",
  "args": ""},
 {"type":
  "Mathlib.Prelude.Rename.RenameMap → Lean.Name → Option (String × Lean.Name)",
  "name": "Mathlib.Prelude.Rename.RenameMap.find?",
  "kind": "def",
  "doc_string":
  "Look up a lean 4 name from the lean 3 name. Also return the `dubious` error message. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → α ⊕ β → Option β",
  "name": "Sum.getRight",
  "kind": "def",
  "doc_string": "Check if a sum is `inr` and if so, retrieve its contents. ",
  "args": ""},
 {"type": "{M : Type u} → [inst : CommMonoid M] → ℕ → M →* M",
  "name": "powMonoidHom",
  "kind": "def",
  "doc_string":
  "The `n`th power map on a commutative monoid for a natural `n`, considered as a morphism of\nmonoids. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → List α → List α",
  "name": "List.erasep",
  "kind": "def",
  "doc_string":
  "`erasep p l` removes the first element of `l` satisfying the predicate `p`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Group α] → (a : α) → Invertible a",
  "name": "invertibleOfGroup",
  "kind": "def",
  "doc_string": "Each element of a group is invertible. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ≃r s → r ↪r s",
  "name": "RelIso.toRelEmbedding",
  "kind": "def",
  "doc_string":
  "Convert an `RelIso` to a `RelEmbedding`. This function is also available as a coercion\nbut often it is easier to write `f.toRelEmbedding` than to write explicitly `r` and `s`\nin the target type. ",
  "args": ""},
 {"type": "Linarith.PComp → Linarith.PComp → ℕ → Linarith.PComp",
  "name": "Linarith.PComp.add",
  "kind": "def",
  "doc_string":
  "`PComp.add c1 c2 elimVar` creates the result of summing the linear comparisons `c1` and `c2`,\nduring the process of eliminating the variable `elimVar`.\nThe computation assumes, but does not enforce, that `elimVar` appears in both `c1` and `c2`\nand does not appear in the sum.\nComputing the sum of the two comparisons is easy; the complicated details lie in tracking the\nadditional fields of `PComp`.\n* The historical set `pcomp.history` of `c1 + c2` is the union of the two historical sets.\n* `vars` is the union of `c1.vars` and `c2.vars`.\n* The effectively eliminated variables of `c1 + c2` are the union of the two effective sets,\n  with `elim_var` inserted.\n* The implicitly eliminated variables of `c1 + c2` are those that appear in\n  `vars` but not `c.vars` or `effective`.\n(Note that the description of the implicitly eliminated variables of `c1 + c2` in the algorithm\ndescribed in Section 6 of https://doi.org/10.1016/B978-0-444-88771-9.50019-2 seems to be wrong:\nthat says it should be `(c1.implicit.union c2.implicit).sdiff explicit`.\nSince the implicitly eliminated sets start off empty for the assumption,\nthis formula would leave them always empty.)\n",
  "args": ""},
 {"type": "Lean.Expr → Lean.Expr → List Lean.Expr → Lean.Expr",
  "name": "Mathlib.Tactic.MkIff.mkOpList",
  "kind": "def",
  "doc_string":
  "`mkOpList op empty [x1, x2, ...]` is defined as `op x1 (op x2 ...)`.\nReturns `empty` if the list is empty. ",
  "args": ""},
 {"type": "{ι : Type u_1} → ComplexShape ι → ι → ι",
  "name": "ComplexShape.prev",
  "kind": "def",
  "doc_string":
  "An arbitary choice of index `i` such that `Rel i j`, if such exists.\nReturns `j` otherwise.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt (f ∘ g) x → Function.IsFixedPt g x → Function.IsFixedPt f x",
  "name": "Function.IsFixedPt.left_of_comp",
  "kind": "theorem",
  "doc_string":
  "If `x` is a fixed point of `f ∘ g` and `g`, then it is a fixed point of `f`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : One α] {a : α} [self : Invertible a], a * ⅟a = 1",
  "name": "Invertible.mul_invOf_self",
  "kind": "def",
  "doc_string": "`invOf a` is a right inverse of `a` ",
  "args": ""},
 {"type":
  "Type u_1 → (A : Type u_2) → [inst : AddZeroClass A] → Type (max u_1 u_2)",
  "name": "DistribSMul",
  "kind": "inductive",
  "doc_string":
  "Typeclass for scalar multiplication that preserves `0` and `+` on the right.\n\nThis is exactly `DistribMulAction` without the `MulAction` part.\n",
  "args": ""},
 {"type": "(α : Sort u_1) → (Empty → α) ≃ PUnit",
  "name": "Equiv.emptyArrowEquivPUnit",
  "kind": "def",
  "doc_string": "The sort of maps from `Empty` is equivalent to `PUnit`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] {f : α → α} {p : α → Prop} {hf : ∀ (x : α), x ≤ f x} {hfp : ∀ (x : α), p (f x)}\n  {hmin : ∀ ⦃x y : α⦄, x ≤ y → p y → f x ≤ y} (x : α), p (↑(ClosureOperator.mk₃ f p hf hfp hmin).toOrderHom x)",
  "name": "ClosureOperator.closure_mem_mk₃",
  "kind": "theorem",
  "doc_string":
  "This lemma shows that the image of `x` of a closure operator built from the `mk₃` constructor\nrespects `p`, the property that was fed into it. ",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrderedAddCommGroup α] → DecidableRel fun x x_1 => x < x_1",
  "name": "LinearOrderedAddCommGroup.decidable_lt",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "∀ {n m : ℕ}, ↑n < ↑m → n < m",
  "name": "Int.lt_of_ofNat_lt_ofNat",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `Int.ofNat_lt`.",
  "args": ""},
 {"type":
  "∀ {V : Type u_2} [inst : Quiver V] {V' : Type u_1} [inst_1 : Quiver V'] [inst_2 : Quiver.HasReverse V'] (φ : V ⥤q V')\n  (Φ : Quiver.Symmetrify V ⥤q V'),\n  (Quiver.Symmetrify.of ⋙q Φ) = φ →\n    (∀ {X Y : Quiver.Symmetrify V} (f : X ⟶ Y),\n        Prefunctor.map Φ (Quiver.reverse f) = Quiver.reverse (Prefunctor.map Φ f)) →\n      Φ = Quiver.Symmetrify.lift φ",
  "name": "Quiver.Symmetrify.lift_unique",
  "kind": "theorem",
  "doc_string":
  "`lift φ` is the only prefunctor extending `φ` and preserving reverses. ",
  "args": ""},
 {"type": "∀ {α : Type u} {a : α} (as : List α), List.Mem a (a :: as)",
  "name": "List.Mem.head",
  "kind": "def",
  "doc_string": "The head of a list is a member: `a ∈ a :: as`. ",
  "args": ""},
 {"type":
  "ℕ → Linarith.PCompSet → Linarith.PCompSet × Linarith.PCompSet × Linarith.PCompSet",
  "name": "Linarith.splitSetByVarSign",
  "kind": "def",
  "doc_string":
  "`splitSetByVarSign a comps` partitions the set `comps` into three parts.\n* `pos` contains the elements of `comps` in which `a` has a positive coefficient.\n* `neg` contains the elements of `comps` in which `a` has a negative coefficient.\n* `notPresent` contains the elements of `comps` in which `a` has coefficient 0.\n\nReturns `(pos, neg, notPresent)`.\n",
  "args": ""},
 {"type":
  "∀ (α : Type u_1) [inst : AddLeftCancelMonoid α], FaithfulVAdd αᵃᵒᵖ α",
  "name": "AddLeftCancelMonoid.toFaithfulVAdd_opposite",
  "kind": "def",
  "doc_string":
  "`AddMonoid.toOppositeAddAction` is faithful on cancellative monoids.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Monoid M] (a : M) (u : Mˣ), IsUnit (a * ↑u) ↔ IsUnit a",
  "name": "Units.isUnit_mul_units",
  "kind": "theorem",
  "doc_string":
  "Multiplication by a `u : Mˣ` on the right doesn't affect `IsUnit`. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : CancelMonoidWithZero M₀] {a b : M₀}, b ≠ 1 → b * a = a → a = 0",
  "name": "eq_zero_of_mul_eq_self_left",
  "kind": "theorem",
  "doc_string":
  "An element of a `CancelMonoidWithZero` fixed by left multiplication by an element other\nthan one must be zero. ",
  "args": ""},
 {"type":
  "{β : Sort u_1} → {α : Sort u_2} → (P : β → Sort w) → (e : α ≃ β) → ((a : α) → P (↑e a)) ≃ ((b : β) → P b)",
  "name": "Equiv.piCongrLeft",
  "kind": "def",
  "doc_string":
  "Transporting dependent functions through an equivalence of the base,\nexpressed as a \"simplification\".\n",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Neg M₂] →\n      [inst_1 : InvolutiveNeg M₁] →\n        (f : M₁ → M₂) → Function.Surjective f → (∀ (x : M₁), f (-x) = -f x) → InvolutiveNeg M₂",
  "name": "Function.Surjective.involutiveNeg",
  "kind": "def",
  "doc_string":
  "A type has an involutive negation if it admits a surjective map that\npreserves `-` to a type which has an involutive negation.",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.PCompSet",
  "kind": "def",
  "doc_string": "A collection of comparisons. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : One M₁] →\n        [inst_2 : Pow M₁ ℕ] →\n          [inst_3 : RightCancelMonoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 1 = 1 →\n                  (∀ (x y : M₁), f (x * y) = f x * f y) →\n                    (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) → RightCancelMonoid M₁",
  "name": "Function.Injective.rightCancelMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `1` and `*` is a right cancel monoid, if it admits an injective map that\npreserves `1` and `*` to a right cancel monoid. See note [reducible non-instances]. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Lattice α] → Prop",
  "name": "IsModularLattice",
  "kind": "inductive",
  "doc_string":
  "A modular lattice is one with a limited associativity between `⊓` and `⊔`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [self : Distrib R] (a b c : R), a * (b + c) = a * b + a * c",
  "name": "Distrib.left_distrib",
  "kind": "def",
  "doc_string": "Multiplication is left distributive over addition ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "List.«term_<+_»",
  "kind": "def",
  "doc_string":
  "`l₁ <+ l₂`, or `Sublist l₁ l₂`, says that `l₁` is a (non-contiguous) subsequence of `l₂`. ",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.choose",
  "kind": "def",
  "doc_string":
  "`choose n k` is the number of `k`-element subsets in an `n`-element set. Also known as binomial\ncoefficients. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    (α : Type u_3) → [inst : AddMonoid M] → [inst_1 : AddAction M α] → [inst_2 : AddMonoid N] → (N →+ M) → AddAction N α",
  "name": "AddAction.compHom",
  "kind": "def",
  "doc_string":
  "An additive action of `M` on `α` and an additive monoid homomorphism `N → M` induce\nan additive action of `N` on `α`.\n\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "∀ {α : Sort u}, (∀ (a b : α), a = b) → Subsingleton α",
  "name": "Subsingleton.intro",
  "kind": "def",
  "doc_string":
  "Construct a proof that `α` is a subsingleton by showing that any two elements are equal. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Nontriviality.nontriviality",
  "kind": "def",
  "doc_string":
  "Attempts to generate a `Nontrivial α` hypothesis.\n\nThe tactic first looks for an instance using `infer_instance`.\n\nIf the goal is an (in)equality, the type `α` is inferred from the goal.\nOtherwise, the type needs to be specified in the tactic invocation, as `nontriviality α`.\n\nThe `nontriviality` tactic will first look for strict inequalities amongst the hypotheses,\nand use these to derive the `Nontrivial` instance directly.\n\nOtherwise, it will perform a case split on `Subsingleton α ∨ Nontrivial α`, and attempt to discharge\nthe `Subsingleton` goal using `simp [lemmas, nontriviality]`, where `[lemmas]` is a list of\nadditional `simp` lemmas that can be passed to `nontriviality` using the syntax\n`nontriviality α using [lemmas]`.\n\n```\nexample {R : Type} [OrderedRing R] {a : R} (h : 0 < a) : 0 < a := by\n  nontriviality -- There is now a `nontrivial R` hypothesis available.\n  assumption\n```\n\n```\nexample {R : Type} [CommRing R] {r s : R} : r * s = s * r := by\n  nontriviality -- There is now a `nontrivial R` hypothesis available.\n  apply mul_comm\n```\n\n```\nexample {R : Type} [OrderedRing R] {a : R} (h : 0 < a) : (2 : ℕ) ∣ 4 := by\n  nontriviality R -- there is now a `nontrivial R` hypothesis available.\n  dec_trivial\n```\n\n```\ndef myeq {α : Type} (a b : α) : Prop := a = b\n\nexample {α : Type} (a b : α) (h : a = b) : myeq a b := by\n  success_if_fail nontriviality α -- Fails\n  nontriviality α using [myeq] -- There is now a `nontrivial α` hypothesis available\n  assumption\n```\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {a : R} [inst : Monoid R] {n : ℕ}, 0 < n → (IsRegular (a ^ n) ↔ IsRegular a)",
  "name": "IsRegular.pow_iff",
  "kind": "theorem",
  "doc_string":
  "An element `a` is regular if and only if a positive power of `a` is regular. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Part α → (α → Part β) → Part β",
  "name": "Part.bind",
  "kind": "def",
  "doc_string":
  "The bind operation has value `g (f.get)`, and is defined when all the\nparts are defined. ",
  "args": ""},
 {"type":
  "{α₁ : Type u₁} → {α₂ : Type u₂} → {β₁ : Type v₁} → {β₂ : Type v₂} → (α₁ → α₂) → (β₁ → β₂) → α₁ × β₁ → α₂ × β₂",
  "name": "Prod.map",
  "kind": "def",
  "doc_string":
  "`Prod.map f g : α₁ × β₁ → α₂ × β₂` maps across a pair\nby applying `f` to the first component and `g` to the second.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {s t : Set α}, BddAbove t → BddAbove (s ∩ t)",
  "name": "BddAbove.inter_of_right",
  "kind": "theorem",
  "doc_string": "If `t` is bounded, then so is `s ∩ t` ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Tactic.MfldSetTac.mfldSetTac",
  "kind": "def",
  "doc_string":
  "A very basic tactic to show that sets showing up in manifolds coincide or are included\nin one another. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulStrictMono α],\n  a ≤ 1 → b < 1 → 0 < a → a * b < 1",
  "name": "Left.mul_lt_of_le_of_lt_one_of_pos",
  "kind": "theorem",
  "doc_string": "Assumes left covariance. ",
  "args": ""},
 {"type": "ℕ ⊕ PUnit ≃ ℕ",
  "name": "Equiv.natSumPUnitEquivNat",
  "kind": "def",
  "doc_string": "`ℕ ⊕ Punit` is equivalent to `ℕ`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : CompleteLattice α] → (α →o α) →o α",
  "name": "OrderHom.lfp",
  "kind": "def",
  "doc_string": "Least fixed point of a monotone function ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedField α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Neg β] →\n                [inst_6 : Sub β] →\n                  [inst_7 : Pow β ℕ] →\n                    [inst_8 : SMul ℕ β] →\n                      [inst_9 : SMul ℤ β] →\n                        [inst_10 : SMul ℚ β] →\n                          [inst_11 : NatCast β] →\n                            [inst_12 : IntCast β] →\n                              [inst_13 : RatCast β] →\n                                [inst_14 : Inv β] →\n                                  [inst_15 : Div β] →\n                                    [inst_16 : Pow β ℤ] →\n                                      [inst_17 : HasSup β] →\n                                        [inst_18 : HasInf β] →\n                                          (f : β → α) →\n                                            Function.Injective f →\n                                              f 0 = 0 →\n                                                f 1 = 1 →\n                                                  (∀ (x y : β), f (x + y) = f x + f y) →\n                                                    (∀ (x y : β), f (x * y) = f x * f y) →\n                                                      (∀ (x : β), f (-x) = -f x) →\n                                                        (∀ (x y : β), f (x - y) = f x - f y) →\n                                                          (∀ (x : β), f x⁻¹ = (f x)⁻¹) →\n                                                            (∀ (x y : β), f (x / y) = f x / f y) →\n                                                              (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                                                (∀ (x : β) (n : ℤ), f (n • x) = n • f x) →\n                                                                  (∀ (x : β) (n : ℚ), f (n • x) = n • f x) →\n                                                                    (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                                      (∀ (x : β) (n : ℤ), f (x ^ n) = f x ^ n) →\n                                                                        (∀ (n : ℕ), f ↑n = ↑n) →\n                                                                          (∀ (n : ℤ), f ↑n = ↑n) →\n                                                                            (∀ (n : ℚ), f ↑n = ↑n) →\n                                                                              (∀ (x y : β),\n                                                                                  f (x ⊔ y) = max (f x) (f y)) →\n                                                                                (∀ (x y : β),\n                                                                                    f (x ⊓ y) = min (f x) (f y)) →\n                                                                                  LinearOrderedField β",
  "name": "Function.Injective.linearOrderedField",
  "kind": "def",
  "doc_string": "Pullback a `LinearOrderedField` under an injective map. ",
  "args": ""},
 {"type":
  "{a : Lean.Level} →\n  {arg : Q(Type a)} →\n    {sα : Q(CommSemiring «$arg»)} →\n      {a_1 : Q(«$arg»)} →\n        {a_2 : Lean.Level} →\n          {arg_1 : Q(Type a_2)} →\n            {sβ : Q(CommSemiring «$arg_1»)} →\n              Mathlib.Tactic.Ring.ExSum sα a_1 → (a : Q(«$arg_1»)) × Mathlib.Tactic.Ring.ExSum sβ a",
  "name": "Mathlib.Tactic.Ring.ExSum.cast",
  "kind": "opaque",
  "doc_string":
  "Converts `ExSum sα` to `ExSum sβ`, assuming `sα` and `sβ` are defeq. ",
  "args": ""},
 {"type": "{α : Type u} → (α → Prop) → Stream' α → Prop",
  "name": "Stream'.All",
  "kind": "def",
  "doc_string":
  "Proposition saying that all elements of a stream satisfy a predicate. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → N →* M × N",
  "name": "MonoidHom.inr",
  "kind": "def",
  "doc_string":
  "Given monoids `M`, `N`, the natural inclusion homomorphism from `N` to `M × N`. ",
  "args": ""},
 {"type":
  "Lean.HashSet (Lean.Expr × Bool) → Lean.Expr → Lean.MetaM (Lean.HashSet (Lean.Expr × Bool))",
  "name": "Linarith.findSquares",
  "kind": "opaque",
  "doc_string":
  "`findSquares s e` collects all terms of the form `a ^ 2` and `a * a` that appear in `e`\nand adds them to the set `s`.\nA pair `(a, true)` is added to `s` when `a^2` appears in `e`,\nand `(a, false)` is added to `s` when `a*a` appears in `e`.  ",
  "args": ""},
 {"type": "∀ {α : Type u_1} (self : Finset α), Multiset.Nodup self.val",
  "name": "Finset.nodup",
  "kind": "def",
  "doc_string":
  "The proof that the underlying `Multiset` of a `Finset` has no duplicates. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : Zero M] → [inst : Zero N] → Type (max u_1 u_2)",
  "name": "ZeroHom",
  "kind": "inductive",
  "doc_string":
  "`ZeroHom M N` is the type of functions `M → N` that preserve zero.\n\nWhen possible, instead of parametrizing results over `(f : ZeroHom M N)`,\nyou should parametrize over `(F : Type*) [ZeroHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `ZeroHomClass`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} →\n        (p : Set β) → (f : r ≺i s) → (∀ (a : α), ↑f.toRelEmbedding.toEmbedding a ∈ p) → f.top ∈ p → r ≺i Subrel s p",
  "name": "PrincipalSeg.codRestrict",
  "kind": "def",
  "doc_string": "Restrict the codomain of a principal segment ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {a : α}, 0 ≤ a → 0 ≤ a⁻¹",
  "name": "inv_nonneg_of_nonneg",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `inv_nonneg`.",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0",
  "name": "NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero",
  "kind": "def",
  "doc_string":
  "For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : CommGroupWithZero α] → α × α →*₀ α",
  "name": "divMonoidWithZeroHom",
  "kind": "def",
  "doc_string": "Division as a multiplicative homomorphism with zero. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {M : Type u_2} {N : Type u_3} {inst : One M} {inst_1 : One N} [self : OneHomClass F M N] (f : F),\n  ↑f 1 = 1",
  "name": "OneHomClass.map_one",
  "kind": "def",
  "doc_string": "The proposition that the function preserves 1 ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : BEq α] →\n    {m : Type → Type u_2} →\n      [inst_1 : Monad m] →\n        (α → m Bool) →\n          (s : Aesop.UnorderedArraySet α) → optParam ℕ 0 → optParam ℕ (Aesop.UnorderedArraySet.size s) → m Bool",
  "name": "Aesop.UnorderedArraySet.anyM",
  "kind": "def",
  "doc_string": "O(n) ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Rel α β → Set β",
  "name": "Rel.codom",
  "kind": "def",
  "doc_string": "Codomain aka range of a relation ",
  "args": ""},
 {"type": "{α : Type u} → [self : Mul α] → α → α → α",
  "name": "Mul.mul",
  "kind": "def",
  "doc_string": "`a * b` computes the product of `a` and `b`. See `HMul`. ",
  "args": ""},
 {"type":
  "{m n : ℕ} → (Fin2 m → Fin2 n) → (k : ℕ) → Fin2 (m + k) → Fin2 (n + k)",
  "name": "Fin2.remapLeft",
  "kind": "def",
  "doc_string":
  "`remapLeft f k : Fin2 (m + k) → Fin2 (n + k)` applies the function\n`f : Fin2 m → Fin2 n` to inputs less than `m`, and leaves the right part\non the right (that is, `remapLeft f k (m + i) = n + i`). ",
  "args": ""},
 {"type":
  "{K : Type u_1} →\n  [inst : DivisionRing K] →\n    {K' : Type u_2} →\n      [inst_1 : Zero K'] →\n        [inst_2 : One K'] →\n          [inst_3 : Add K'] →\n            [inst_4 : Mul K'] →\n              [inst_5 : Neg K'] →\n                [inst_6 : Sub K'] →\n                  [inst_7 : Inv K'] →\n                    [inst_8 : Div K'] →\n                      [inst_9 : SMul ℕ K'] →\n                        [inst_10 : SMul ℤ K'] →\n                          [inst_11 : SMul ℚ K'] →\n                            [inst_12 : Pow K' ℕ] →\n                              [inst_13 : Pow K' ℤ] →\n                                [inst_14 : NatCast K'] →\n                                  [inst_15 : IntCast K'] →\n                                    [inst_16 : RatCast K'] →\n                                      (f : K' → K) →\n                                        Function.Injective f →\n                                          f 0 = 0 →\n                                            f 1 = 1 →\n                                              (∀ (x y : K'), f (x + y) = f x + f y) →\n                                                (∀ (x y : K'), f (x * y) = f x * f y) →\n                                                  (∀ (x : K'), f (-x) = -f x) →\n                                                    (∀ (x y : K'), f (x - y) = f x - f y) →\n                                                      (∀ (x : K'), f x⁻¹ = (f x)⁻¹) →\n                                                        (∀ (x y : K'), f (x / y) = f x / f y) →\n                                                          (∀ (x : K') (n : ℕ), f (n • x) = n • f x) →\n                                                            (∀ (x : K') (n : ℤ), f (n • x) = n • f x) →\n                                                              (∀ (x : K') (n : ℚ), f (n • x) = n • f x) →\n                                                                (∀ (x : K') (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                                  (∀ (x : K') (n : ℤ), f (x ^ n) = f x ^ n) →\n                                                                    (∀ (n : ℕ), f ↑n = ↑n) →\n                                                                      (∀ (n : ℤ), f ↑n = ↑n) →\n                                                                        (∀ (n : ℚ), f ↑n = ↑n) → DivisionRing K'",
  "name": "Function.Injective.divisionRing",
  "kind": "def",
  "doc_string":
  "Pullback a `DivisionSemiring` along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop}, (∀ (a : α), β (Quot.mk r a)) → ∀ (q : Quot r), β q",
  "name": "Quot.ind",
  "kind": "def",
  "doc_string":
  "Given a type `α` and any binary relation `r` on `α`,\n`Quot.ind` says that every element of `Quot r` is of the form `Quot.mk r a`.\n\nSee `Quot` and `Quot.lift`.\n",
  "args": ""},
 {"type": "{δ σ : Type u} → [self : EStateM.Backtrackable δ σ] → σ → δ → σ",
  "name": "EStateM.Backtrackable.restore",
  "kind": "def",
  "doc_string":
  "`restore (s : σ) (x : δ) : σ` applies the old backtracking state `x` to\nthe state `s` to get a backtracked state `s'`. ",
  "args": ""},
 {"type":
  "{m : Type u → Type v} → [self : Bind m] → {α β : Type u} → m α → (α → m β) → m β",
  "name": "Bind.bind",
  "kind": "def",
  "doc_string":
  "If `x : m α` and `f : α → m β`, then `x >>= f : m β` represents the\nresult of executing `x` to get a value of type `α` and then passing it to `f`. ",
  "args": ""},
 {"type": "True",
  "name": "trivial",
  "kind": "def",
  "doc_string":
  "`True` is true, and `True.intro` (or more commonly, `trivial`)\nis the proof. ",
  "args": ""},
 {"type": "{α : Type u_1} → [self : HasCompl α] → α → α",
  "name": "HasCompl.compl",
  "kind": "def",
  "doc_string": "Set / lattice complement ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : LinearOrder α] → [inst_1 : Preorder β] → (f : α → β) → StrictMono f → α ≃o ↑(Set.range f)",
  "name": "StrictMono.orderIso",
  "kind": "def",
  "doc_string":
  "A strictly monotone function from a linear order is an order isomorphism between its domain and\nits range. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Mul M] {p : M → Prop} (x : M) {s : Set M},\n  Subsemigroup.closure s = ⊤ → (∀ (x : M), x ∈ s → p x) → (∀ (x y : M), p x → p y → p (x * y)) → p x",
  "name": "Subsemigroup.dense_induction",
  "kind": "theorem",
  "doc_string":
  "If `s` is a dense set in a magma `M`, `Subsemigroup.closure s = ⊤`, then in order to prove that\nsome predicate `p` holds for all `x : M` it suffices to verify `p x` for `x ∈ s`,\nand verify that `p x` and `p y` imply `p (x * y)`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.MkIff.mkIff",
  "kind": "def",
  "doc_string":
  "Applying the `mk_iff` attribute to an inductively-defined proposition `mk_iff` makes an `iff` rule\n`r` with the shape `∀ps is, i as ↔ ⋁_j, ∃cs, is = cs`, where `ps` are the type parameters, `is` are\nthe indices, `j` ranges over all possible constructors, the `cs` are the parameters for each of the\nconstructors, and the equalities `is = cs` are the instantiations for each constructor for each of\nthe indices to the inductive type `i`.\n\nIn each case, we remove constructor parameters (i.e. `cs`) when the corresponding equality would\nbe just `c = i` for some index `i`.\n\nFor example, if we try the following:\n```lean\n@[mk_iff]\nstructure Foo (m n : Nat) : Prop where\n  equal : m = n\n  sum_eq_two : m + n = 2\n```\n\nThen `#check Foo_iff` returns:\n```lean\nFoo_iff : ∀ (m n : Nat), Foo m n ↔ m = n ∧ m + n = 2\n```\n\nYou can add an optional string after `mk_iff` to change the name of the generated lemma.\nFor example, if we try the following:\n```lean\n@[mk_iff bar]\nstructure Foo (m n : Nat) : Prop where\n  equal : m = n\n  sum_eq_two : m + n = 2\n```\n\nThen `#check bar` returns:\n```lean\nbar : ∀ (m n : ℕ), Foo m n ↔ m = n ∧ m + n = 2\n```\n\nSee also the user command `mk_iff_of_inductive_prop`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : One α] → [inst : Add α] → PosNum → α",
  "name": "castPosNum",
  "kind": "def",
  "doc_string":
  "`castPosNum` casts a `PosNum` into any type which has `1` and `+`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "LinearOrder",
  "kind": "inductive",
  "doc_string":
  "A linear order is reflexive, transitive, antisymmetric and total relation `≤`.\nWe assume that every linear ordered type has decidable `(≤)`, `(<)`, and `(=)`. ",
  "args": ""},
 {"type": "∀ {α : Type v} {S : Type w}, α ≃ S → Small α",
  "name": "Small.mk'",
  "kind": "theorem",
  "doc_string":
  "Constructor for `Small α` from an explicit witness type and equivalence.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, a ⋖ ⊤ → IsCoatom a",
  "name": "Covby.is_coatom",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `covby_top_iff`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Preorder α] → (p : α → Prop) → Subtype p →o α",
  "name": "OrderHom.Subtype.val",
  "kind": "def",
  "doc_string": "`Subtype.val` as a bundled monotone function.  ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : CommMonoid M] → (S : Submonoid M) → CommMonoid { x // x ∈ S }",
  "name": "Submonoid.toCommMonoid",
  "kind": "def",
  "doc_string": "A submonoid of a `CommMonoid` is a `CommMonoid`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_<->_»",
  "kind": "def",
  "doc_string":
  "If and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrder α] {s : Set α}, ¬BddBelow s ↔ ∀ (x : α), ∃ y, y ∈ s ∧ y < x",
  "name": "not_bddBelow_iff",
  "kind": "theorem",
  "doc_string":
  "A set `s` is not bounded below if and only if for each `x` there exists `y ∈ s` that is less\nthan `x`. A version for preorders is called `not_bddBelow_iff'`. ",
  "args": ""},
 {"type": "optParam ℕ 0 → StdGen",
  "name": "mkStdGen",
  "kind": "def",
  "doc_string": "Return a standard number generator. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : CompleteSemilatticeInf α] → CompleteLattice α",
  "name": "completeLatticeOfCompleteSemilatticeInf",
  "kind": "def",
  "doc_string":
  "Any `CompleteSemilatticeInf` is in fact a `CompleteLattice`.\n\nNote that this construction has bad definitional properties:\nsee the doc-string on `completeLatticeOfInf`.\n",
  "args": ""},
 {"type":
  "{C : ℚ → Sort u} → (a : ℚ) → ((n : ℤ) → (d : ℕ) → d ≠ 0 → C (Rat.divInt n ↑d)) → C a",
  "name": "Rat.numDenCasesOn'",
  "kind": "def",
  "doc_string":
  "Define a (dependent) function or prove `∀ r : ℚ, p r` by dealing with rational\nnumbers of the form `n /. d` with `d ≠ 0`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : Mul α] → [inst_1 : One α] → [inst_2 : HasDistribNeg α] → (a : α) → [inst_3 : Invertible a] → Invertible (-a)",
  "name": "invertibleNeg",
  "kind": "def",
  "doc_string": "`-⅟a` is the inverse of `-a` ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : LE α] → OrderTop α ⊕' NoTopOrder α",
  "name": "topOrderOrNoTopOrder",
  "kind": "def",
  "doc_string":
  "An order is (noncomputably) either an `OrderTop` or a `NoTopOrder`. Use as\n`casesI topOrderOrNoTopOrder α`. ",
  "args": ""},
 {"type":
  "(R : Type u_1) → [inst : Mul R] → [inst_1 : Add R] → RingAut R →* AddAut R",
  "name": "RingAut.toAddAut",
  "kind": "def",
  "doc_string":
  "Monoid homomorphism from ring automorphisms to additive automorphisms. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1],\n  StrictMonoOn f s → MonotoneOn g s → StrictMonoOn (fun x => f x * g x) s",
  "name": "StrictMonoOn.mul_monotone'",
  "kind": "theorem",
  "doc_string":
  "The product of a strictly monotone function and a monotone function is strictly monotone. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {F : Type u_3} → [inst : One M] → [inst_1 : One N] → [inst_2 : OneHomClass F M N] → CoeTC F (OneHom M N)",
  "name": "instCoeTCOneHom",
  "kind": "def",
  "doc_string":
  "Any type satisfying `OneHomClass` can be cast into `OneHom` via `OneHomClass.toOneHom`. ",
  "args": ""},
 {"type": "ZNum → ZNum",
  "name": "ZNum.zNeg",
  "kind": "def",
  "doc_string": "The negation of a `ZNum`. ",
  "args": ""},
 {"type":
  "∀ (n k : ℕ), Nat.factorial n * Nat.ascFactorial n k = Nat.factorial (n + k)",
  "name": "Nat.factorial_mul_ascFactorial",
  "kind": "theorem",
  "doc_string":
  "`n.ascFactorial k = (n + k)! / n!` but without ℕ-division. See `Nat.ascFactorial_eq_div` for\nthe version with ℕ-division. ",
  "args": ""},
 {"type":
  "(α : Type u_1) →\n  [inst : Preorder α] → (Antisymmetrization α fun x x_1 => x ≤ x_1)ᵒᵈ ≃o Antisymmetrization αᵒᵈ fun x x_1 => x ≤ x_1",
  "name": "OrderIso.dualAntisymmetrization",
  "kind": "def",
  "doc_string": "`Antisymmetrization` and `orderDual` commute. ",
  "args": ""},
 {"type":
  "{F : Type → Type v} → [inst : Alternative F] → {α : Type} → F α → F Unit",
  "name": "tryM",
  "kind": "def",
  "doc_string":
  "Attempts to perform the computation, but fails silently if it doesn't succeed. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} →\n      [inst : MulOneClass M] → [inst_1 : MulOneClass N] → [inst_2 : MulOneClass P] → (N →* P) → (M →* N) → M →* P",
  "name": "MonoidHom.comp",
  "kind": "def",
  "doc_string": "Composition of monoid morphisms as a monoid morphism. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Add α] → [inst : Zero α] → List α → α",
  "name": "List.sum",
  "kind": "def",
  "doc_string": "Sum of a list.\n\n`sum [a, b, c] = ((0 + a) + b) + c` ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Monoid α] →\n      [inst_1 : Mul β] →\n        [inst_2 : MulAction α β] → [inst_3 : IsScalarTower α β β] → [inst_4 : SMulCommClass α β β] → α × β →ₙ* β",
  "name": "smulMulHom",
  "kind": "def",
  "doc_string": "Scalar multiplication as a multiplicative homomorphism. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.RingNF.convRing_nf!_",
  "kind": "def",
  "doc_string":
  "Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `ring_nf at h` can be used to rewrite in a hypothesis.\n",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Semiquot",
  "kind": "inductive",
  "doc_string":
  "A member of `Semiquot α` is classically a nonempty `Set α`,\nand in the VM is represented by an element of `α`; the relation\nbetween these is that the VM element is required to be a member\nof the set `s`. The specific element of `s` that the VM computes\nis hidden by a quotient construction, allowing for the representation\nof nondeterministic functions. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a : α}, 1 < a⁻¹ ↔ a < 1",
  "name": "Left.one_lt_inv_iff",
  "kind": "theorem",
  "doc_string": "Uses `left` co(ntra)variant. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Type u_2} {β : Type u_3} {S : ι → Set α} {f : (i : ι) → ↑(S i) → β}\n  {hf :\n    ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j),\n      f i { val := x, property := hxi } = f j { val := x, property := hxj }}\n  {T : Set α} {hT : T ⊆ Set.unionᵢ S} (hT' : T = Set.unionᵢ S),\n  Directed (fun x x_1 => x ≤ x_1) S →\n    ∀ (op : ↑T → ↑T → ↑T) (opi : (i : ι) → ↑(S i) → ↑(S i) → ↑(S i)),\n      (∀ (i : ι) (x y : ↑(S i)),\n          Set.inclusion (_ : S i ⊆ T) (opi i x y) =\n            op (Set.inclusion (_ : S i ⊆ T) x) (Set.inclusion (_ : S i ⊆ T) y)) →\n        ∀ (opβ : β → β → β),\n          (∀ (i : ι) (x y : ↑(S i)), f i (opi i x y) = opβ (f i x) (f i y)) →\n            ∀ (x y : ↑T),\n              Set.unionᵢLift S f hf T (_ : T ≤ Set.unionᵢ S) (op x y) =\n                opβ (Set.unionᵢLift S f hf T (_ : T ≤ Set.unionᵢ S) x)\n                  (Set.unionᵢLift S f hf T (_ : T ≤ Set.unionᵢ S) y)",
  "name": "Set.unionᵢLift_binary",
  "kind": "theorem",
  "doc_string":
  "`unionᵢLift_binary` is useful for proving that `unionᵢLift` is a homomorphism\nof algebraic structures when defined on the Union of algebraic subobjects.\nFor example, it could be used to prove that the lift of a collection\nof group homomorphisms on a union of subgroups preserves `*`. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : MulOneClass M] → Bot (Submonoid M)",
  "name": "Submonoid.instBotSubmonoid",
  "kind": "def",
  "doc_string": "The trivial submonoid `{1}` of an monoid `M`. ",
  "args": ""},
 {"type": "ZNum → ZNum → ZNum",
  "name": "ZNum.mod",
  "kind": "def",
  "doc_string": "Modulus of `ZNum`s. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] [self : NoMinOrder α] (a : α), ∃ b, b < a",
  "name": "NoMinOrder.exists_lt",
  "kind": "def",
  "doc_string": "For each term `a`, there is some strictly smaller `b`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → (r : α → α → Prop) → (s : β → β → Prop) → [inst : IsEmpty α] → [inst : IsEmpty β] → r ≃r s",
  "name": "RelIso.relIsoOfIsEmpty",
  "kind": "def",
  "doc_string": "Two relations on empty types are isomorphic. ",
  "args": ""},
 {"type": "outParam (Type u) → (Type u → Type v) → Type (max (u + 1) v)",
  "name": "MonadWithReader",
  "kind": "inductive",
  "doc_string":
  "Similar to `MonadWithReaderOf`, but `ρ` is an `outParam` for convenience. ",
  "args": ""},
 {"type": "Linarith.Preprocessor",
  "name": "Linarith.compWithZero",
  "kind": "def",
  "doc_string":
  "`compWithZero h` takes a proof `h` of an equality, inequality, or negation thereof,\nand turns it into a proof of a comparison `_ R 0`, where `R ∈ {=, ≤, <}`.\n ",
  "args": ""},
 {"type":
  "Lean.Expr → StateRefT' IO.RealWorld (Lean.HashSet Lean.MVarId) Lean.MetaM Unit",
  "name": "Mathlib.Tactic.getUnassignedGoalMVarDependencies.addMVars",
  "kind": "opaque",
  "doc_string": "auxiliary function for `getUnassignedGoalMVarDependencies` ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_/\\_»",
  "kind": "def",
  "doc_string":
  "`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n",
  "args": ""},
 {"type": "(m : Type u → Type u_1) → Type u → CategoryTheory.KleisliCat m",
  "name": "CategoryTheory.KleisliCat.mk",
  "kind": "def",
  "doc_string": "Construct an object of the Kleisli category from a type. ",
  "args": ""},
 {"type": "Mathlib.Tactic.RingNF.RingMode",
  "name": "Mathlib.Tactic.RingNF.RingMode.raw",
  "kind": "def",
  "doc_string": "Raw form: the representation `ring` uses internally. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} (a : α) (n : ℕ), List.length (List.repeat a n) = n",
  "name": "List.length_repeat",
  "kind": "theorem",
  "doc_string":
  "Length of the list consisting of an element repeated `n` times is `n`. ",
  "args": ""},
 {"type": "Q(ℕ) → Type",
  "name": "Mathlib.Tactic.Ring.ExtractCoeff",
  "kind": "inductive",
  "doc_string":
  "The result of `extractCoeff` is a numeral and a proof that the original expression\nfactors by this numeral.\n",
  "args": ""},
 {"type":
  "{α₁ : Type u_1} → {α₂ : Type u_2} → {β₁ : Type u_3} → {β₂ : Type u_4} → α₁ ≃ α₂ → β₁ ≃ β₂ → α₁ × β₁ ≃ α₂ × β₂",
  "name": "Equiv.prodCongr",
  "kind": "def",
  "doc_string":
  "Product of two equivalences. If `α₁ ≃ α₂` and `β₁ ≃ β₂`, then `α₁ × β₁ ≃ α₂ × β₂`. This is\n`Prod.map` as an equivalence. ",
  "args": ""},
 {"type":
  "∀ {X : Type u} {m₁ m₂ : X → X → X} {e₁ e₂ : X},\n  EckmannHilton.IsUnital m₁ e₁ →\n    EckmannHilton.IsUnital m₂ e₂ → (∀ (a b c d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) → m₁ = m₂",
  "name": "EckmannHilton.mul",
  "kind": "theorem",
  "doc_string":
  "If a type carries two unital binary operations that distribute over each other,\nthen these operations are equal.\n\nIn fact, they give a commutative monoid structure, see `eckmann_hilton.CommMonoid`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      {δ : Type u_4} →\n        {r : α → α → Prop} →\n          {s : β → β → Prop} → {t : γ → γ → Prop} → {u : δ → δ → Prop} → r ↪r s → t ↪r u → Sum.Lex r t ↪r Sum.Lex s u",
  "name": "RelEmbedding.sumLexMap",
  "kind": "def",
  "doc_string":
  "`Sum.map` as a relation embedding between `Sum.Lex` relations. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddSemigroup R] {a : R} (b : R),\n  IsAddLeftRegular a → (IsAddLeftRegular (a + b) ↔ IsAddLeftRegular b)",
  "name": "add_isAddLeftRegular_iff",
  "kind": "theorem",
  "doc_string":
  "An element is add-left-regular if and only if adding to it on the left\na add-left-regular element is add-left-regular.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} (f : α → β),\n  Relation.Fibration rα rβ f → ∀ {a : α}, Acc rα a → Acc rβ (f a)",
  "name": "Acc.of_fibration",
  "kind": "theorem",
  "doc_string":
  "If `f : α → β` is a fibration between relations `rα` and `rβ`, and `a : α` is\naccessible under `rα`, then `f a` is accessible under `rβ`. ",
  "args": ""},
 {"type": "(ℕ → Bool) → ℕ → Bool",
  "name": "Nat.anyTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `Nat.any`. ",
  "args": ""},
 {"type":
  "{P : ℕ → Sort u_1} → ((n : ℕ) → P (n + 1) → P n) → {m n : ℕ} → m ≤ n → P n → P m",
  "name": "Nat.decreasingInduction",
  "kind": "def",
  "doc_string":
  "Decreasing induction: if `P (k+1)` implies `P k`, then `P n` implies `P m` for all `m ≤ n`.\nAlso works for functions to `Sort*`. For a version assuming only the assumption for `k < n`, see\n`decreasing_induction'`. ",
  "args": ""},
 {"type":
  "Lean.MVarId → Lean.MetaM (Option (Lean.Expr × Lean.Expr) × Lean.MVarId)",
  "name": "Linarith.applyContrLemma",
  "kind": "def",
  "doc_string":
  "`applyContrLemma` inspects the target to see if it can be moved to a hypothesis by negation.\nFor example, a goal `⊢ a ≤ b` can become `a > b ⊢ false`.\nIf this is the case, it applies the appropriate lemma and introduces the new hypothesis.\nIt returns the type of the terms in the comparison (e.g. the type of `a` and `b` above) and the\nnewly introduced local constant.\nOtherwise returns `none`.\n",
  "args": ""},
 {"type":
  "(G : Type u_1) →\n  (R : Type u_2) → [inst : Group G] → [inst_1 : Semiring R] → [inst_2 : MulSemiringAction G R] → G →* RingAut R",
  "name": "MulSemiringAction.toRingAut",
  "kind": "def",
  "doc_string":
  "Each element of the group defines a ring automorphism.\n\nThis is a stronger version of `DistribMulAction.toAddAut` and\n`MulDistribMulAction.toMulAut`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Mul M] →\n      [inst_1 : Mul N] →\n        (f : M →ₙ* N) → (g : N →ₙ* M) → MulHom.comp g f = MulHom.id M → MulHom.comp f g = MulHom.id N → M ≃* N",
  "name": "MulHom.toMulEquiv",
  "kind": "def",
  "doc_string":
  "Given a pair of multiplicative homomorphisms `f`, `g` such that `g.comp f = id` and\n`f.comp g = id`, returns an multiplicative equivalence with `toFun = f` and `invFun = g`. This\nconstructor is useful if the underlying type(s) have specialized `ext` lemmas for multiplicative\nhomomorphisms. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ⩿ b → a = b ∨ a ⋖ b",
  "name": "Wcovby.eq_or_covby",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `wcovby_iff_eq_or_covby`.",
  "args": ""},
 {"type":
  "{obj : Type u} → [self : CategoryTheory.CategoryStruct obj] → (X : obj) → X ⟶ X",
  "name": "CategoryTheory.CategoryStruct.id",
  "kind": "def",
  "doc_string": "The identity morphism on an object. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → Option β → γ) → List α → List β → List γ × List β",
  "name": "List.zipWithLeft'TR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `zipWithLeft'`. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {P : Type u_2} [inst : AddMonoid G] [self : AddAction G P] (p : P), 0 +ᵥ p = p",
  "name": "AddAction.zero_vadd",
  "kind": "def",
  "doc_string": "Zero is a neutral element for `+ᵥ` ",
  "args": ""},
 {"type":
  "(Type u → Type v) → (Type u → Type w) → Type (max (max (u + 1) v) w)",
  "name": "MonadLiftT",
  "kind": "inductive",
  "doc_string":
  "The reflexive-transitive closure of `MonadLift`. `monadLift` is used to\ntransitively lift monadic computations such as `StateT.get` or `StateT.put s`.\nCorresponds to Haskell's [`MonadLift`].\n\n  [`MonadLift`]: https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLift\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Sum.Lex.«term_⊕ₗ_»",
  "kind": "def",
  "doc_string": "The linear sum of two orders ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 2",
  "name": "two_pos",
  "kind": "theorem",
  "doc_string": "**Alias** of `zero_lt_two`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Semifield β] →\n      [inst_1 : Zero α] →\n        [inst_2 : Mul α] →\n          [inst_3 : Add α] →\n            [inst_4 : One α] →\n              [inst_5 : Inv α] →\n                [inst_6 : Div α] →\n                  [inst_7 : SMul ℕ α] →\n                    [inst_8 : Pow α ℕ] →\n                      [inst_9 : Pow α ℤ] →\n                        [inst_10 : NatCast α] →\n                          (f : α → β) →\n                            Function.Injective f →\n                              f 0 = 0 →\n                                f 1 = 1 →\n                                  (∀ (x y : α), f (x + y) = f x + f y) →\n                                    (∀ (x y : α), f (x * y) = f x * f y) →\n                                      (∀ (x : α), f x⁻¹ = (f x)⁻¹) →\n                                        (∀ (x y : α), f (x / y) = f x / f y) →\n                                          (∀ (x : α) (n : ℕ), f (n • x) = n • f x) →\n                                            (∀ (x : α) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                              (∀ (x : α) (n : ℤ), f (x ^ n) = f x ^ n) →\n                                                (∀ (n : ℕ), f ↑n = ↑n) → Semifield α",
  "name": "Function.Injective.semifield",
  "kind": "def",
  "doc_string": "Pullback a `Field` along an injective function. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b c : α}, a * b < c → b < a⁻¹ * c",
  "name": "lt_inv_mul_of_mul_lt",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `lt_inv_mul_iff_mul_lt`.",
  "args": ""},
 {"type":
  "{B : Type u_1} →\n  {E : B → Type u_2} → {B' : Type u_3} → (f : B' → B) → Bundle.TotalSpace (f *ᵖ E) → B' × Bundle.TotalSpace E",
  "name": "Bundle.pullbackTotalSpaceEmbedding",
  "kind": "def",
  "doc_string":
  "Natural embedding of the total space of `f *ᵖ E` into `B' × TotalSpace E`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : AddMonoid α] → AddUnits α →+ α × αᵃᵒᵖ",
  "name": "AddUnits.embedProduct",
  "kind": "def",
  "doc_string":
  "Canonical homomorphism of additive monoids from `AddUnits α` into `α × αᵃᵒᵖ`.\nUsed mainly to define the natural topology of `AddUnits α`.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "NegPart",
  "kind": "inductive",
  "doc_string":
  "The negative part of an element admiting a decomposition into positive and negative parts.\n",
  "args": ""},
 {"type":
  "{M' : Type u_1} →\n  {α : Type u_2} →\n    [inst : AddMonoid M'] → [inst_1 : AddAction M' α] → (S : AddSubmonoid M') → AddAction { x // x ∈ S } α",
  "name":
  "AddSubmonoid.instAddActionSubtypeMemAddSubmonoidToAddZeroClassInstMembershipInstSetLikeAddSubmonoidToAddMonoid",
  "kind": "def",
  "doc_string":
  "The additive action by an `AddSubmonoid` is the action by the underlying `AddMonoid`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : SemilatticeSup α] → {P : α → Prop} → (∀ ⦃x y : α⦄, P x → P y → P (x ⊔ y)) → SemilatticeSup { x // P x }",
  "name": "Subtype.semilatticeSup",
  "kind": "def",
  "doc_string":
  "A subtype forms a `⊔`-semilattice if `⊔` preserves the property.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Sort u_1} → (¬(α → False) → α) → Nonempty α → α",
  "name": "Classical.choice_of_byContradiction'",
  "kind": "def",
  "doc_string":
  "`classical.byContradiction'` is equivalent to lean's axiom `classical.choice`. ",
  "args": ""},
 {"type": "Linarith.Ineq → Linarith.Ineq → Linarith.Ineq",
  "name": "Linarith.Ineq.max",
  "kind": "def",
  "doc_string":
  "`max R1 R2` computes the strength of the sum of two inequalities. If `t1 R1 0` and `t2 R2 0`,\nthen `t1 + t2 (max R1 R2) 0`.\n",
  "args": ""},
 {"type":
  "{α₁ : Type u_1} → {α₂ : Sort u_2} → {β₁ : Type u_3} → {β₂ : Sort u_4} → α₁ ≃ α₂ → β₁ ≃ β₂ → α₁ × β₁ ≃ PProd α₂ β₂",
  "name": "Equiv.prodPProd",
  "kind": "def",
  "doc_string":
  "Combine two equivalences using `PProd` in the codomain and `Prod` in the domain. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "OrderedCancelAddCommMonoid",
  "kind": "inductive",
  "doc_string":
  "An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 < a → 0 ≤ b → 0 < a + b",
  "name": "add_pos_of_pos_of_nonneg",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.add_pos_of_pos_of_nonneg`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : SuccOrder α] [inst_2 : IsSuccArchimedean α] (r : α → α → Prop)\n  {n m : α},\n  Reflexive r →\n    (∀ (i : α), i ∈ Set.Ico n m → r i (Order.succ i)) →\n      (∀ (i : α), i ∈ Set.Ico m n → r (Order.succ i) i) → Relation.TransGen r n m",
  "name": "transGen_of_succ_of_reflexive",
  "kind": "theorem",
  "doc_string":
  "`(n, m)` is in the transitive closure of a reflexive relation `~` if `i ~ succ i` and\n`succ i ~ i` for all `i` between `n` and `m`. ",
  "args": ""},
 {"type": "{α : Type u_1} → Set α → Set (α × α)",
  "name": "Set.offDiag",
  "kind": "def",
  "doc_string":
  "The off-diagonal of a set `s` is the set of pairs `(a, b)` with `a, b ∈ s` and `a ≠ b`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β},\n  Function.Injective f → ∀ (s : Set α), Set.Subsingleton (f '' s) → Set.Subsingleton s",
  "name": "Set.subsingleton_of_image",
  "kind": "theorem",
  "doc_string":
  "If the image of a set under an injective map is a subsingleton, the set is a subsingleton. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "linarithArgsRest",
  "kind": "def",
  "doc_string":
  "Syntax for the arguments of `linarith`, after the optional `!`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : AddCommGroup α] → Type u_1",
  "name": "AddCommGroup.TotalPositiveCone",
  "kind": "inductive",
  "doc_string":
  "A positive cone in an `AddCommGroup` induces a linear order if\nfor every `a`, either `a` or `-a` is non-negative. ",
  "args": ""},
 {"type": "Num → Num → Num",
  "name": "Num.sub",
  "kind": "def",
  "doc_string": "Subtraction of two `Num`s, where if `a < b`, `a - b = 0`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → (β → α) → Type (max u v)",
  "name": "GaloisCoinsertion",
  "kind": "inductive",
  "doc_string":
  "A Galois coinsertion is a Galois connection where `u ∘ l = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual to\n`GaloisInsertion` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : PartialOrder α] → [inst : OrderTop α] → α → α → Prop",
  "name": "Codisjoint",
  "kind": "def",
  "doc_string":
  "Two elements of a lattice are codisjoint if their sup is the top element.\n\nNote that we define this without reference to `⊔`, as this allows us to talk about orders where\nthe supremum is not unique, or where implement `HasSup` would require additional `Decidable`\narguments. ",
  "args": ""},
 {"type": "(R : Type u_1) → [inst : AddMonoidWithOne R] → Prop",
  "name": "CharZero",
  "kind": "inductive",
  "doc_string":
  "Typeclass for monoids with characteristic zero.\n  (This is usually stated on fields but it makes sense for any additive monoid with 1.)\n*Warning*: for a semiring `R`, `CharZero R` and `CharP R 0` need not coincide.\n* `CharZero R` requires an injection `ℕ ↪ R`;\n* `CharP R 0` asks that only `0 : ℕ` maps to `0 : R` under the map `ℕ → R`.\nFor instance, endowing `{0, 1}` with addition given by `max` (i.e. `1` is absorbing), shows that\n`CharZero {0, 1}` does not hold and yet `CharP {0, 1} 0` does.\nThis example is formalized in `counterexamples/char_p_zero_ne_char_zero`.\n ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "byContra'",
  "kind": "def",
  "doc_string":
  "If the target of the main goal is a proposition `p`,\n`by_contra'` reduces the goal to proving `False` using the additional hypothesis `this : ¬ p`.\n`by_contra' h` can be used to name the hypothesis `h : ¬ p`.\nThe hypothesis `¬ p` will be negation normalized using `push_neg`.\nFor instance, `¬ a < b` will be changed to `b ≤ a`.\n`by_contra' h : q` will normalize negations in `¬ p`, normalize negations in `q`,\nand then check that the two normalized forms are equal.\nThe resulting hypothesis is the pre-normalized form, `q`.\nIf the name `h` is not explicitly provided, then `this` will be used as name.\nThis tactic uses classical reasoning.\nIt is a variant on the tactic `by_contra`.\nExamples:\n```lean\nexample : 1 < 2 := by\n  by_contra' h\n  -- h : 2 ≤ 1 ⊢ False\n\nexample : 1 < 2 := by\n  by_contra' h : ¬ 1 < 2\n  -- h : ¬ 1 < 2 ⊢ False\n```\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {C : {n : ℕ} → Vector α n → Sort u} →\n    ((l : List α) → C { val := l, property := (_ : List.length l = List.length l) }) → {n : ℕ} → (v : Vector α n) → C v",
  "name": "Vector.elim",
  "kind": "def",
  "doc_string": "Elimination rule for `Vector`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [inst : ConditionallyCompleteLattice α] [inst_1 : SemilatticeSup β] {f g : β → α},\n  (Antitone fun n => Set.Icc (f n) (g n)) →\n    (∀ (n : β), f n ≤ g n) → (⨆ n, f n) ∈ Set.interᵢ fun n => Set.Icc (f n) (g n)",
  "name": "csupᵢ_mem_Inter_Icc_of_antitone_Icc",
  "kind": "theorem",
  "doc_string":
  "Nested intervals lemma: if `[f n, g n]` is an antitone sequence of nonempty\nclosed intervals, then `⨆ n, f n` belongs to all the intervals `[f n, g n]`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MonoidWithZero M] {f g : ℤ →*₀ M},\n  ↑f (-1) = ↑g (-1) →\n    MonoidWithZeroHom.comp f (RingHom.toMonoidWithZeroHom Int.ofNatHom) =\n        MonoidWithZeroHom.comp g (RingHom.toMonoidWithZeroHom Int.ofNatHom) →\n      f = g",
  "name": "MonoidWithZeroHom.ext_int",
  "kind": "theorem",
  "doc_string":
  "If two `MonoidWithZeroHom`s agree on `-1` and the naturals then they are equal. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«⨆_,_»",
  "kind": "def",
  "doc_string": "Indexed supremum. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : CommMonoidWithZero M] → M →*₀ M",
  "name": "MonoidWithZero.inverse",
  "kind": "def",
  "doc_string":
  "We define the inverse as a `MonoidWithZeroHom` by extending the inverse map by zero\non non-units. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisConnection l u → ∀ {x y z : α}, x ≤ u (l y) → y ≤ u (l z) → x ≤ u (l z)",
  "name": "GaloisConnection.le_u_l_trans",
  "kind": "theorem",
  "doc_string":
  "If `(l, u)` is a Galois connection, then the relation `x ≤ u (l y)` is a transitive relation.\nIf `l` is a closure operator (`Submodule.span`, `Subgroup.closure`, ...) and `u` is the coercion to\n`Set`, this reads as \"if `U` is in the closure of `V` and `V` is in the closure of `W` then `U` is\nin the closure of `W`\". ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : Monoid M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [inst : SubmonoidClass A M] → (S : A) → Pow { x // x ∈ S } ℕ",
  "name": "SubmonoidClass.nPow",
  "kind": "def",
  "doc_string": "A submonoid of a monoid inherits a power operator. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : DecidableEq α] → α → List α → List α",
  "name": "List.insert",
  "kind": "def",
  "doc_string": "Inserts an element into a list without duplication. ",
  "args": ""},
 {"type": "∀ {M : Type u} [self : Monoid M] (a : M), a * 1 = a",
  "name": "Monoid.mul_one",
  "kind": "def",
  "doc_string": "One is a right neutral element for multiplication ",
  "args": ""},
 {"type":
  "{α : Sort u₁} →\n  {β : Sort u₂} → {γ : Sort v₁} → {δ : Sort v₂} → (α → β → Prop) → (γ → δ → Prop) → (α → γ) → (β → δ) → Prop",
  "name": "Relator.LiftFun",
  "kind": "def",
  "doc_string":
  "The binary relations `R : α → β → Prop` and `S : γ → δ → Prop` induce a binary\nrelation on functions `LiftFun : (f : α → γ) (g : β → δ) : Prop'. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : α → Type u_2} →\n    (γ : (a : α) → β a → Type u_3) → (ab : (a : α) × β a) × γ ab.fst ab.snd ≃ (a : α) × (b : β a) × γ a b",
  "name": "Equiv.sigmaAssoc",
  "kind": "def",
  "doc_string":
  "Dependent product of types is associative up to an equivalence. ",
  "args": ""},
 {"type":
  "{f : Type u → Type v} → [self : SeqLeft f] → {α β : Type u} → f α → (Unit → f β) → f α",
  "name": "SeqLeft.seqLeft",
  "kind": "def",
  "doc_string":
  "If `x : F α` and `y : F β`, then `x <* y` evaluates `x`, then `y`,\nand returns the result of `x`.\n\nTo avoid surprising evaluation semantics, `y` is taken \"lazily\", using a\n`Unit → f β` function. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_∩_»",
  "kind": "def",
  "doc_string": "`a ∩ b` is the intersection of`a` and `b`. ",
  "args": ""},
 {"type": "ToAdditive.Config → Lean.Name → Lean.Name → Lean.CoreM Unit",
  "name": "ToAdditive.transformDecl",
  "kind": "def",
  "doc_string":
  "Make a new copy of a declaration, replacing fragments of the names of identifiers in the type and\nthe body using the `translations` dictionary.\nThis is used to implement `@[to_additive]`.\n",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (β → α → m β) → β → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → m β",
  "name": "Array.foldlM",
  "kind": "def",
  "doc_string": "Reference implementation for `foldlM` ",
  "args": ""},
 {"type": "{α : Type u} → [self : LE α] → α → α → Prop",
  "name": "LE.le",
  "kind": "def",
  "doc_string": "The less-equal relation: `x ≤ y` ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {α : ι → Type u_2} → [inst : Preorder ι] → [inst : (i : ι) → Preorder (α i)] → Preorder (Lex ((i : ι) × α i))",
  "name": "Sigma.Lex.preorder",
  "kind": "def",
  "doc_string": "The lexicographical preorder on a sigma type. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : GroupWithZero α] → {a : α} → a ≠ 0 → Invertible a",
  "name": "invertibleOfNonzero",
  "kind": "def",
  "doc_string": "`a⁻¹` is an inverse of `a` if `a ≠ 0` ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : AddSemigroup M₂] →\n        (f : M₁ → M₂) → Function.Injective f → (∀ (x y : M₁), f (x + y) = f x + f y) → AddSemigroup M₁",
  "name": "Function.Injective.addSemigroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `+` is an additive semigroup, if it admits an\ninjective map that preserves `+` to an additive semigroup.",
  "args": ""},
 {"type":
  "(Lean.Expr → Lean.MetaM Bool) →\n  optParam Bool false →\n    optParam Bool true → Lean.MVarId → optParam (Array Lean.MVarId) #[] → Lean.MetaM (Array Lean.MVarId)",
  "name": "Mathlib.Tactic.casesMatching.go",
  "kind": "opaque",
  "doc_string":
  "Auxiliary for `casesMatching`. Accumulates generated subgoals in `acc`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {f g : M →* N} {s : Set M},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Submonoid.closure s)",
  "name": "MonoidHom.eqOn_closureM",
  "kind": "theorem",
  "doc_string":
  "If two monoid homomorphisms are equal on a set, then they are equal on its submonoid closure. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 < a → 0 ≤ b → 0 < a + b",
  "name": "Left.add_pos_of_pos_of_nonneg",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_pos_of_pos_of_nonneg`.",
  "args": ""},
 {"type":
  "(α : Type u_1) →\n  (β : Type u_2) →\n    [inst : Preorder α] → [inst : Preorder β] → [inst : AddZeroClass α] → [inst : AddZeroClass β] → Type (max u_1 u_2)",
  "name": "OrderAddMonoidHom",
  "kind": "inductive",
  "doc_string":
  "`α →+o β` is the type of monotone functions `α → β` that preserve the `OrderedAddCommMonoid`\nstructure.\n\n`OrderAddMonoidHom` is also used for ordered group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →+o β)`,\nyou should parametrize over `(F : Type*) [OrderAddMonoidHomClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderAddMonoidHomClass`. ",
  "args": ""},
 {"type":
  "(M : Type u) → (R : Type v) → [inst : Monoid M] → [inst : Semiring R] → Type (max u v)",
  "name": "MulSemiringAction",
  "kind": "inductive",
  "doc_string":
  "Typeclass for multiplicative actions by monoids on semirings.\n\nThis combines `DistribMulAction` with `MulDistribMulAction`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} → [inst : NonUnitalSemiring R] → [inst : NonUnitalSemiring S] → NonUnitalSemiring (R × S)",
  "name": "Prod.instNonUnitalSemiringProd",
  "kind": "def",
  "doc_string":
  "Product of two `NonUnitalSemiring`s is a `NonUnitalSemiring`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → [inst : Nontrivial R] → [hR : Ring R] → (∀ (a : R), IsUnit a ∨ a = 0) → DivisionRing R",
  "name": "divisionRingOfIsUnitOrEqZero",
  "kind": "def",
  "doc_string":
  "Constructs a `DivisionRing` structure on a `Ring` consisting only of units and 0. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → [inst : IsWellOrder β s] → r ≼i s → (r ≺i s) ⊕ (r ≃r s)",
  "name": "InitialSeg.ltOrEq",
  "kind": "def",
  "doc_string":
  "To an initial segment taking values in a well order, one can associate either a principal\nsegment (if the range is not everything, hence one can take as top the minimum of the complement\nof the range) or an order isomorphism (if the range is everything). ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : LinearOrder α] → (p : α → Prop) → LinearOrder (Subtype p)",
  "name": "Subtype.linearOrder",
  "kind": "def",
  "doc_string":
  "A subtype of a linear order is a linear order. We explicitly give the proofs of decidable\nequality and decidable order in order to ensure the decidability instances are all definitionally\nequal. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : BEq α] → List α → List α → Bool",
  "name": "List.isPrefixOf",
  "kind": "def",
  "doc_string":
  "`isPrefixOf l₁ l₂` returns `true` Iff `l₁` is a prefix of `l₂`.\nThat is, there exists a `t` such that `l₂ == l₁ ++ t`. ",
  "args": ""},
 {"type": "{α : Sort u_1} → {β : Sort u_2} → (α ↪ β) → α → β",
  "name": "Function.Embedding.Simps.apply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → (α ≃. β) → α → Option β",
  "name": "PEquiv.toFun",
  "kind": "def",
  "doc_string": "The underlying partial function of a `PEquiv` ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → (e : Q(«$α»)) → optParam Bool false → Lean.MetaM (Mathlib.Meta.NormNum.Result e)",
  "name": "Mathlib.Meta.NormNum.derive",
  "kind": "def",
  "doc_string":
  "Run each registered `norm_num` extension on an expression, returning a `NormNum.Result`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«stx_,+,?»",
  "kind": "def",
  "doc_string":
  "`p,+,?` is shorthand for `sepBy1(p, \",\", allowTrailingSep)`.\nIt parses 1 or more occurrences of `p` separated by `,`, possibly including\na trailing `,`, that is: `p | p, | p,p | p,p, | p,p,p | ...`.\n\nIt produces a `nullNode` containing a `SepArray` with the interleaved parser\nresults. It has arity 1, and auto-groups its component parser if needed.\n",
  "args": ""},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "name": "Applicative",
  "kind": "inductive",
  "doc_string":
  "An [applicative functor](https://en.wikipedia.org/wiki/Applicative_functor) is\nan intermediate structure between `Functor` and `Monad`. It mainly consists of\ntwo operations:\n\n* `pure : α → F α`\n* `seq : F (α → β) → F α → F β` (written as `<*>`)\n\nThe `seq` operator gives a notion of evaluation order to the effects, where\nthe first argument is executed before the second, but unlike a monad the results\nof earlier computations cannot be used to define later actions.\n",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Lattice α] → Prop",
  "name": "IsLowerModularLattice",
  "kind": "inductive",
  "doc_string":
  "A lower modular lattice is a lattice where `a` and `b` both cover `a ⊓ b` if `a ⊔ b` covers\neither `a` or `b`. ",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  [inst : Group G] →\n    {H : Type u_2} → [inst_1 : Group H] → (f : G → H) → (∀ (a b : G), f (a * b⁻¹) = f a * (f b)⁻¹) → G →* H",
  "name": "MonoidHom.ofMapMulInv",
  "kind": "def",
  "doc_string":
  "Makes a group homomorphism from a proof that the map preserves right division\n`fun x y => x * y⁻¹`. See also `MonoidHom.of_map_div` for a version using `fun x y => x / y`.\n",
  "args": ""},
 {"type": "Lean.Option Bool",
  "name": "linter.unnecessarySimpa",
  "kind": "opaque",
  "doc_string":
  "Enables the 'unnecessary `simpa`' linter. This will report if a use of\n`simpa` could be proven using `simp` or `simp at h` instead.\n",
  "args": ""},
 {"type": "{α : Type u_1} → ℕ → α → List α → List α",
  "name": "List.leftpadTR",
  "kind": "def",
  "doc_string": "Optimized version of `leftpad`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → AddHom M N → M → N",
  "name": "AddHom.Simps.apply",
  "kind": "def",
  "doc_string": "See Note custom simps projection",
  "args": ""},
 {"type":
  "∀ (f : Type u₀ → Type u₁) [inst : EquivFunctor f] {α β γ : Type u₀} (ab : α ≃ β) (bc : β ≃ γ),\n  Equiv.trans (EquivFunctor.mapEquiv f ab) (EquivFunctor.mapEquiv f bc) = EquivFunctor.mapEquiv f (Equiv.trans ab bc)",
  "name": "EquivFunctor.mapEquiv_trans",
  "kind": "theorem",
  "doc_string":
  "The composition of `mapEquiv`s is carried over the `EquivFunctor`.\nFor plain `Functor`s, this lemma is named `map_map` when applied\nor `map_comp_map` when not applied.\n",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → (p : Set α) → ↑p → ↑p → Prop",
  "name": "Subrel",
  "kind": "def",
  "doc_string": "`subrel r p` is the inherited relation on a subset. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {s t : Set α}, BddAbove s → BddAbove (s ∩ t)",
  "name": "BddAbove.inter_of_left",
  "kind": "theorem",
  "doc_string": "If `s` is bounded, then so is `s ∩ t` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Mul M] →\n      [inst_1 : Mul N] →\n        (e : M ≃* N) → (S : Subsemigroup M) → { x // x ∈ S } ≃* { x // x ∈ Subsemigroup.map (MulEquiv.toMulHom e) S }",
  "name": "MulEquiv.subsemigroupMap",
  "kind": "def",
  "doc_string":
  "A `MulEquiv` `φ` between two semigroups `M` and `N` induces a `MulEquiv` between\na subsemigroup `S ≤ M` and the subsemigroup `φ(S) ≤ N`.\nSee `MulHom.subsemigroupMap` for a variant for `MulHom`s. ",
  "args": ""},
 {"type": "(a b : ℕ) → a < b ⊕' b ≤ a",
  "name": "Nat.lt_sum_ge",
  "kind": "def",
  "doc_string": "Strong case analysis on `a < b ∨ b ≤ a` ",
  "args": ""},
 {"type": "∀ {M : Type u_1} [inst : MulOneClass M] (x : M), SemiconjBy 1 x x",
  "name": "SemiconjBy.one_left",
  "kind": "theorem",
  "doc_string": "One semiconjugates any element to itself. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Semigroup α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : ContravariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_5 : ContravariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b c d : α},\n  a ≤ c → b ≤ d → (a * b = c * d ↔ a = c ∧ b = d)",
  "name": "mul_eq_mul_iff_eq_and_eq",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.mul_eq_mul_iff_eq_and_eq`.",
  "args": ""},
 {"type": "Substring → Char → String.Pos",
  "name": "Substring.posOf",
  "kind": "def",
  "doc_string":
  "Return the offset into `s` of the first occurence of `c` in `s`,\nor `s.bsize` if `c` doesn't occur. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → α ↪o β → (fun x x_1 => x < x_1) ↪r fun x x_1 => x < x_1",
  "name": "OrderEmbedding.ltEmbedding",
  "kind": "def",
  "doc_string": "`<` is preserved by order embeddings of preorders. ",
  "args": ""},
 {"type": "Linarith.Comp → Linarith.Comp → Ordering",
  "name": "Linarith.Comp.cmp",
  "kind": "def",
  "doc_string":
  "`Comp` has a lex order. First the `ineq`s are compared, then the `coeff`s. ",
  "args": ""},
 {"type": "{G₀ : Type u} → [self : GroupWithZero G₀] → ℤ → G₀ → G₀",
  "name": "GroupWithZero.zpow",
  "kind": "def",
  "doc_string":
  "The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] → [inst_1 : Preorder β] → {l : α → β} → {u : β → α} → GaloisConnection l u → LowerAdjoint u",
  "name": "GaloisConnection.lowerAdjoint",
  "kind": "def",
  "doc_string": "Every Galois connection induces a lower adjoint. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_3} {ι : Sort u_1} {f : ι → α} {g₁ g₂ : α → β},\n  Set.EqOn g₁ g₂ (Set.range f) → g₁ ∘ f = g₂ ∘ f",
  "name": "Set.eqOn.comp_eq",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `Set.eqOn_range`.",
  "args": ""},
 {"type": "∀ {a c b d : Prop}, (a ↔ c) → (b ↔ d) → (a ∧ b ↔ c ∧ d)",
  "name": "Iff.and",
  "kind": "theorem",
  "doc_string": "**Alias** of `and_congr`.",
  "args": ""},
 {"type": "ℕ+ → ℕ+ → ℕ+ × ℕ",
  "name": "PNat.modDiv",
  "kind": "def",
  "doc_string":
  "`mod_div m k = (m % k, m / k)`.\nWe define `m % k` and `m / k` in the same way as for `ℕ`\nexcept that when `m = n * k` we take `m % k = k` and\n`m / k = n - 1`.  This ensures that `m % k` is always positive\nand `m = (m % k) + k * (m / k)` in all cases.  Later we\ndefine a function `div_exact` which gives the usual `m / k`\nin the case where `k` divides `m`.\n",
  "args": ""},
 {"type": "outParam (Type u) → Type v → Type (max u v)",
  "name": "Sep",
  "kind": "inductive",
  "doc_string": "Type class used to implement the notation `{ a ∈ c | p a }` ",
  "args": ""},
 {"type": "∀ {α : Type u}, Vector.toList Vector.nil = []",
  "name": "Vector.toList_nil",
  "kind": "theorem",
  "doc_string": "A nil vector maps to a nil list. ",
  "args": ""},
 {"type":
  "∀ {G : Type u} [self : Semigroup G] (a b c : G), a * b * c = a * (b * c)",
  "name": "Semigroup.mul_assoc",
  "kind": "def",
  "doc_string": "Multiplication is associative ",
  "args": ""},
 {"type": "{α : Sort u} → α → αᵒᵖ",
  "name": "Opposite.op",
  "kind": "def",
  "doc_string": "The canonical map `α → αᵒᵖ`. ",
  "args": ""},
 {"type": "{α : Sort u_1} → α → Erased α",
  "name": "Erased.mk",
  "kind": "def",
  "doc_string": "Erase a value. ",
  "args": ""},
 {"type": "Bool → ℕ → ℕ",
  "name": "Nat.bit",
  "kind": "def",
  "doc_string":
  "`bit b` appends the digit `b` to the binary representation of\nits natural number input. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : StrictOrderedCommSemiring α] (a b : α), a * b = b * a",
  "name": "StrictOrderedCommSemiring.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {M : Type u_2} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MulAction G M]\n  [inst_3 : SMulCommClass G M M] [inst_4 : IsScalarTower G M M] (g : G) (m : Mˣ), (g • m)⁻¹ = g⁻¹ • m⁻¹",
  "name": "Units.smul_inv",
  "kind": "theorem",
  "doc_string":
  "Note that this lemma exists more generally as the global `smul_inv` ",
  "args": ""},
 {"type":
  "{F : Type u → Type u} → [inst : Functor F] → {α : Type u} → (α → α → Prop) → F α → F α → Prop",
  "name": "Functor.Liftr",
  "kind": "def",
  "doc_string":
  "If we consider `x : F α` to, in some sense, contain values of type `α`, then\n`Liftr r x y` relates `x` and `y` iff (1) `x` and `y` have the same shape and\n(2) we can pair values `a` from `x` and `b` from `y` so that `r a b` holds. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "termSudoSet_option__In_",
  "kind": "def",
  "doc_string":
  "The command `sudo set_option name val in term` is similar to `set_option name val in term`,\nbut it also allows to set undeclared options.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → List α → (List α → List β) → List β",
  "name": "List.sublistsAux₁",
  "kind": "def",
  "doc_string":
  "Definition of a `sublists` function with an explicit list construction function\nUsed in `Data.Lists.Sublists`: TODO: move there when ported.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Antitone f → ∀ {a : α} {s : Set α}, IsLeast s a → IsGreatest (f '' s) (f a)",
  "name": "Antitone.map_isLeast",
  "kind": "theorem",
  "doc_string":
  "An antitone map sends a least element of a set to a greatest element of its image. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Function.«term_-[_]-_»",
  "kind": "def",
  "doc_string":
  "Given functions `f : α → β → φ`, `g : α → β → δ` and a binary operator `op : φ → δ → ζ`,\nproduce a function `α → β → ζ` that applies `f` and `g` on each argument and then applies\n`op` to the results.\n",
  "args": ""},
 {"type": "Linarith.Preprocessor",
  "name": "Linarith.strengthenStrictInt",
  "kind": "def",
  "doc_string":
  "`strengthenStrictInt h` turns a proof `h` of a strict integer inequality `t1 < t2`\ninto a proof of `t1 ≤ t2 + 1`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [self : DivisionSemiring α] → ℤ → α → α",
  "name": "DivisionSemiring.zpow",
  "kind": "def",
  "doc_string":
  "The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : AddCommGroup α] → Type u_1",
  "name": "AddCommGroup.PositiveCone",
  "kind": "inductive",
  "doc_string":
  "A collection of elements in an `AddCommGroup` designated as \"non-negative\".\nThis is useful for constructing an `OrderedAddCommGroup`\nby choosing a positive cone in an exisiting `AddCommGroup`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tacticDecreasing_trivial",
  "kind": "def",
  "doc_string":
  "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
  "args": ""},
 {"type": "{α : Type u_1} → ℕ → ℕ → List α → List α",
  "name": "List.dropSlice",
  "kind": "def",
  "doc_string":
  "`List.dropSlice n m xs` removes a slice of length `m` at index `n` in list `xs`. ",
  "args": ""},
 {"type": "ℕ → Num → Num → Num",
  "name": "Num.gcdAux",
  "kind": "def",
  "doc_string": "Auxiliary definition for `Num.gcd`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Mul α] → SMul αᵐᵒᵖ α",
  "name": "Mul.toHasOppositeSMul",
  "kind": "def",
  "doc_string":
  "Like `Mul.toSMul`, but multiplies on the right.\n\nSee also `Monoid.toOppositeMulAction` and `MonoidWithZero.toOppositeMulActionWithZero`. ",
  "args": ""},
 {"type": "{α : Type u} → List α → Stream' α → Stream' α",
  "name": "Stream'.appendStream'",
  "kind": "def",
  "doc_string": "Append a stream to a list. ",
  "args": ""},
 {"type":
  "∀ {A : Type u_1} [inst : AddMonoid A] {f g : ℤ →+ A}, ↑f 1 = ↑g 1 → f = g",
  "name": "AddMonoidHom.ext_int",
  "kind": "theorem",
  "doc_string":
  "Two additive monoid homomorphisms `f`, `g` from `ℤ` to an additive monoid are equal\nif `f 1 = g 1`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : HasSup α] →\n      [inst_1 : HasInf α] →\n        [inst_2 : Top α] →\n          [inst_3 : Bot α] →\n            [inst_4 : HasCompl α] →\n              [inst_5 : HNot α] →\n                [inst_6 : HImp α] →\n                  [inst_7 : SDiff α] →\n                    [inst_8 : BiheytingAlgebra β] →\n                      (f : α → β) →\n                        Function.Injective f →\n                          (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) →\n                            (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) →\n                              f ⊤ = ⊤ →\n                                f ⊥ = ⊥ →\n                                  (∀ (a : α), f (aᶜ) = f aᶜ) →\n                                    (∀ (a : α), f (￢a) = ￢f a) →\n                                      (∀ (a b : α), f (a ⇨ b) = f a ⇨ f b) →\n                                        (∀ (a b : α), f (a \\ b) = f a \\ f b) → BiheytingAlgebra α",
  "name": "Function.Injective.biheytingAlgebra",
  "kind": "def",
  "doc_string": "Pullback a `BiheytingAlgebra` along an injection. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), min a b = if a ≤ b then a else b",
  "name": "LinearOrderedSemiring.min_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `minOfLe`. ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Distrib R] → R → AddHom R R",
  "name": "AddHom.mulRight",
  "kind": "def",
  "doc_string":
  "Left multiplication by an element of a type with distributive multiplication is an `AddHom`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSSubset α] [inst_1 : IsIrrefl α fun x x_1 => x ⊂ x_1] {a b : α}, a ⊂ b → a ≠ b",
  "name": "HasSSubset.SSubset.ne",
  "kind": "theorem",
  "doc_string": "**Alias** of `ne_of_ssubset`.",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u_1} →\n          [inst_2 : CategoryTheory.Category E] →\n            {F G : C ⥤ D} →\n              (H : D ⥤ E) →\n                [inst_3 : CategoryTheory.Full H] → [inst_4 : CategoryTheory.Faithful H] → (F ⋙ H ≅ G ⋙ H) → (F ≅ G)",
  "name": "CategoryTheory.natIsoOfCompFullyFaithful",
  "kind": "def",
  "doc_string":
  "We can construct a natural isomorphism between functors by constructing a natural isomorphism\nbetween those functors composed with a fully faithful functor. ",
  "args": ""},
 {"type": "ToAdditive.Config → Bool",
  "name": "ToAdditive.Config.replaceAll",
  "kind": "def",
  "doc_string":
  "Replace all multiplicative declarations, do not use the heuristic. ",
  "args": ""},
 {"type":
  "{β : Type v} → {m : Type v → Type w} → [inst : Monad m] → ByteArray → β → (UInt8 → β → m (ForInStep β)) → m β",
  "name": "ByteArray.forIn",
  "kind": "def",
  "doc_string": "Reference implementation for `forIn` ",
  "args": ""},
 {"type":
  "∀ {I : Type u} {f : I → Type v₁} [inst : DecidableEq I] [inst_1 : (i : I) → Zero (f i)] {i i' : I},\n  i ≠ i' → ∀ (x : f i), Pi.single i x i' = 0",
  "name": "Pi.single_eq_of_ne'",
  "kind": "theorem",
  "doc_string":
  "Abbreviation for `single_eq_of_ne h.symm`, for ease of use by `simp`.",
  "args": ""},
 {"type": "Linarith.PComp → Std.RBSet ℕ compare",
  "name": "Linarith.PComp.implicit",
  "kind": "def",
  "doc_string":
  "The variables which have been *implicitly eliminated*.\nThese are variables that appear in the historical set,\ndo not appear in `c` itself, and are not in `effective.",
  "args": ""},
 {"type":
  "∀ {M : Type u} [self : AddMonoid M] (n : ℕ) (x : M), AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "name": "AddMonoid.nsmul_succ",
  "kind": "def",
  "doc_string": "Multiplication by `(n + 1 : ℕ)` behaves as expected. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {a b c : α}, 0 ≤ b → 0 ≤ c → a ≤ c * b → a / b ≤ c",
  "name": "div_le_of_nonneg_of_le_mul",
  "kind": "theorem",
  "doc_string":
  "One direction of `div_le_iff` where `b` is allowed to be `0` (but `c` must be nonnegative) ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Type u_2} → (f : α → β) → (f_inv : β → α) → Function.LeftInverse f_inv f → α ≃ ↑(Set.range f)",
  "name": "Equiv.ofLeftInverse'",
  "kind": "def",
  "doc_string":
  "If `f : α → β` has a left-inverse, then `α` is computably equivalent to the range of `f`.\n\nNote that if `α` is empty, no such `f_inv` exists and so this definition can't be used, unlike\nthe stronger but less convenient `ofLeftInverse`. ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.Context → Lean.Expr → Lean.MetaM (Mathlib.Tactic.Abel.NormalExpr × Lean.Expr)",
  "name": "Mathlib.Tactic.Abel.evalAtom",
  "kind": "def",
  "doc_string": "Interpret an expression as an atom for `abel`'s normal form. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  (A : Type u_2) → [inst : Monoid M] → [inst_1 : Monoid A] → [inst : MulDistribMulAction M A] → M → A →* A",
  "name": "MulDistribMulAction.toMonoidHom",
  "kind": "def",
  "doc_string": "Scalar multiplication by `r` as a `MonoidHom`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.swapRule",
  "kind": "def",
  "doc_string": "The parser for swap rules ",
  "args": ""},
 {"type":
  "{I : Type u} →\n  {f : I → Type v} →\n    {γ : Type w} →\n      [inst : (i : I) → Add (f i)] → [inst_1 : Add γ] → ((i : I) → AddHom γ (f i)) → AddHom γ ((i : I) → f i)",
  "name": "Pi.addHom",
  "kind": "def",
  "doc_string":
  "A family of AddHom's `f a : γ → β a` defines an AddHom `Pi.addHom f : γ → Π a, β a` given by\n`Pi.addHom f x b = f b x`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Mul β] [inst_1 : SMul α β] [inst_2 : SMulCommClass α β β] (s : α) (x y : β),\n  x * s • y = s • (x * y)",
  "name": "mul_smul_comm",
  "kind": "theorem",
  "doc_string":
  "Note that the `SMulCommClass α β β` typeclass argument is usually satisfied by `Algebra α β`.\n",
  "args": ""},
 {"type":
  "{A : Type u_1} → [inst : AddZeroClass A] → Submonoid (Multiplicative A) ≃o AddSubmonoid A",
  "name": "Submonoid.toAddSubmonoid'",
  "kind": "def",
  "doc_string":
  "Submonoids of a monoid `Multiplicative A` are isomorphic to additive submonoids of `A`. ",
  "args": ""},
 {"type": "Type",
  "name": "Aesop.RuleApplication",
  "kind": "inductive",
  "doc_string":
  "A single rule application, representing the application of a tactic to the input\ngoal. Must accurately report the following information:\n\n- `goals`: the goals generated by the tactic.\n- `postState`: the `MetaM` state after the tactic was run.\n- `scriptBuilder`: script builder for the tactic.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Add M] →\n      [inst_1 : Add N] →\n        {f : AddHom M N} → Function.Surjective ↑f → GaloisInsertion (AddSubsemigroup.map f) (AddSubsemigroup.comap f)",
  "name": "AddSubsemigroup.giMapComap",
  "kind": "def",
  "doc_string":
  "`map f` and `comap f` form a `GaloisInsertion` when `f` is surjective. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : DivisionMonoid α] → {a : α} → IsUnit a → αˣ",
  "name": "IsUnit.unit'",
  "kind": "def",
  "doc_string":
  "The element of the group of units, corresponding to an element of a monoid which is a unit. As\nopposed to `IsUnit.unit`, the inverse is computable and comes from the inversion on `α`. This is\nuseful to transfer properties of inversion in `Units α` to `α`. See also `toUnits`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Sort u_2} {κ : ι → Sort u_3} {s : Set α} {t : (i : ι) → κ i → Set α} (i : ι) (j : κ i),\n  s ⊆ t i j → s ⊆ Set.unionᵢ fun i => Set.unionᵢ fun j => t i j",
  "name": "Set.subset_unionᵢ₂_of_subset",
  "kind": "theorem",
  "doc_string":
  "This rather trivial consequence of `subset_unionᵢ₂` is convenient with `apply`, and has `i` and\n`j` explicit for this purpose. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {σ : Type u_2} →\n    [inst : Mul M] →\n      {N : Type u_3} →\n        [inst_1 : Mul N] →\n          [inst_2 : SetLike σ M] → [inst_3 : MulMemClass σ M] → (M →ₙ* N) → (S : σ) → { x // x ∈ S } →ₙ* N",
  "name": "MulHom.restrict",
  "kind": "def",
  "doc_string":
  "Restriction of a semigroup hom to a subsemigroup of the domain. ",
  "args": ""},
 {"type": "ℕ → Prop",
  "name": "Nat.AtLeastTwo",
  "kind": "inductive",
  "doc_string":
  "A type class for natural numbers which are greater than or equal to `2`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → (α → α → Prop) → (β → β → Prop) → α ⊕ β → α ⊕ β → Prop",
  "name": "Sum.Lex",
  "kind": "inductive",
  "doc_string":
  "Lexicographic order for sum. Sort all the `inl a` before the `inr b`, otherwise use the\nrespective order on `α` or `β`. ",
  "args": ""},
 {"type": "{α : Type u_1} → α → Set α → Prop",
  "name": "Set.Mem",
  "kind": "def",
  "doc_string": "Membership in a set ",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableRel fun x x_1 => x < x_1",
  "name": "LinearOrderedSemiring.decidable_lt",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, a < 0 → b < 0 → a + b < 0",
  "name": "add_neg",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.add_neg`.",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {C : Trunc α → Sort u_2} →\n    [inst : ∀ (a : α), Subsingleton (C (Trunc.mk a))] → (q : Trunc α) → ((a : α) → C (Trunc.mk a)) → C q",
  "name": "Trunc.recOnSubsingleton",
  "kind": "def",
  "doc_string":
  "A version of `Trunc.recOn` assuming the codomain is a `Subsingleton`. ",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} → {n : Type u_1 → Type u_3} → [self : MonadLiftT m n] → {α : Type u_1} → m α → n α",
  "name": "liftM",
  "kind": "def",
  "doc_string": "Lifts a value from monad `m` into monad `n`. ",
  "args": ""},
 {"type":
  "(Type u → Type v) → (Type u → Type w) → Type (max (max (u + 1) v) w)",
  "name": "MonadControl",
  "kind": "inductive",
  "doc_string":
  "MonadControl is a way of stating that the monad `m` can be 'run inside' the monad `n`.\n\nThis is the same as [`MonadBaseControl`](https://hackage.haskell.org/package/monad-control-1.0.3.1/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl) in Haskell.\nTo learn about `MonadControl`, see the comment above this docstring.\n\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → (p : α → Type v) → (q : α → Prop) → (∀ (x : α), p x → q x) → (x : Subtype q) × p ↑x ≃ (x : α) × p x",
  "name": "Equiv.sigmaSubtypeEquivOfSubset",
  "kind": "def",
  "doc_string":
  "A sigma type over a subtype is equivalent to the sigma set over the original type,\nif the fiber is empty outside of the subset ",
  "args": ""},
 {"type":
  "∀ {M : Type u_2} {α : Type u_1} [inst : Monoid M] [inst_1 : MulAction M α] [inst_2 : Mul α] (r s : M) (x y : α)\n  [inst_3 : IsScalarTower M α α] [inst_4 : SMulCommClass M α α], r • x * s • y = (r * s) • (x * y)",
  "name": "smul_mul_smul",
  "kind": "theorem",
  "doc_string":
  "Note that the `IsScalarTower M α α` and `SMulCommClass M α α` typeclass arguments are\nusually satisfied by `Algebra M α`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → α → List α → ℕ",
  "name": "List.indexOf",
  "kind": "def",
  "doc_string":
  "Returns the index of the first element equal to `a`, or the length of the list otherwise. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : α → Sort u_2} → {γ : Sort u_3} → ((a : α) → β a → γ) → PSigma β → γ",
  "name": "PSigma.elim",
  "kind": "def",
  "doc_string": "Nondependent eliminator for `PSigma`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {R : α → β → Prop}, List.Forall₂ R [] []",
  "name": "List.Forall₂.nil",
  "kind": "def",
  "doc_string": "Two nil lists are `Forall₂`-related ",
  "args": ""},
 {"type": "Mathlib.Tactic.LinearCombination.Config → Bool",
  "name": "Mathlib.Tactic.LinearCombination.Config.normalize",
  "kind": "def",
  "doc_string": "whether or not the normalization step should be used ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : NonAssocRing α] (a : α), 1 * a = a",
  "name": "NonAssocRing.one_mul",
  "kind": "def",
  "doc_string": "One is a left neutral element for multiplication ",
  "args": ""},
 {"type":
  "{m : Type → Type} → [inst : Lean.MonadMCtx m] → Lean.MVarId → Lean.FVarId → (Lean.LocalDecl → Lean.LocalDecl) → m Unit",
  "name": "Mathlib.Tactic.modifyLocalDecl",
  "kind": "def",
  "doc_string":
  "`modifyLocalDecl mvarId fvarId f` updates the local decl `fvarId` in the local\ncontext of `mvarId` with `f`. `f` must leave the `fvarId` and `index` of the\n`LocalDecl` unchanged. The type of the new `LocalDecl` must be defeq to the type\nof the old `LocalDecl` (and the same applies to the value of the `LocalDecl`, if\nany).\n\nIf `mvarId` does not refer to a declared metavariable or if `fvarId` does not\nexist in the local context of `mvarId`, nothing happens.\n",
  "args": ""},
 {"type": "{α : Type u} → (α → Prop) → Stream' α → Prop",
  "name": "Stream'.Any",
  "kind": "def",
  "doc_string":
  "Proposition saying that at least one element of a stream satisfies a predicate. ",
  "args": ""},
 {"type":
  "{M : Type uM} → {N : Type uN} → [inst : MulOneClass M] → [inst_1 : CommMonoid N] → CommMonoid (M →* N)",
  "name": "MonoidHom.commMonoid",
  "kind": "def",
  "doc_string": "`(M →* N)` is a `CommMonoid` if `N` is commutative. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ 0 → b ≤ 0 → a + b ≤ 0",
  "name": "add_nonpos",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.add_nonpos`.",
  "args": ""},
 {"type": "{m n k : ℕ} → k ∣ m * n → { d // k = ↑d.fst * ↑d.snd }",
  "name": "Nat.prodDvdAndDvdOfDvdProd",
  "kind": "def",
  "doc_string":
  "Represent a divisor of `m * n` as a product of a divisor of `m` and a divisor of `n`.\n\nSee `exists_dvd_and_dvd_of_dvd_mul` for the more general but less constructive version for other\n`GCDMonoid`s. ",
  "args": ""},
 {"type":
  "∀ (G : Type u) [inst : AddRightCancelSemigroup G], IsRightCancelAdd G",
  "name": "AddRightCancelSemigroup.toIsRightCancelAdd",
  "kind": "def",
  "doc_string": "Any `AddRightCancelSemigroup` satisfies\n`IsRightCancelAdd`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedAddMonoid α] (a b : α), max a b = if a ≤ b then b else a",
  "name": "CanonicallyLinearOrderedAddMonoid.max_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `maxOfLe`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (f : M →ₙ* N) {x y : M}, x = y → ↑f x = ↑f y",
  "name": "MulHom.congr_arg",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.congr_arg` instead. ",
  "args": ""},
 {"type":
  "{V : Type u₁} →\n  [inst : Quiver V] →\n    {W : Type u₂} →\n      [inst_1 : Quiver W] → (self : V ⥤q W) → {X Y : V} → (X ⟶ Y) → (Prefunctor.obj self X ⟶ Prefunctor.obj self Y)",
  "name": "Prefunctor.map",
  "kind": "def",
  "doc_string": "The action of a (pre)functor on edges/arrows/morphisms. ",
  "args": ""},
 {"type":
  "{α : Sort u₁} → {β : Sort u₂} → {φ : Sort u₃} → (β → β → φ) → (α → β) → α → α → φ",
  "name": "Function.onFun",
  "kind": "def",
  "doc_string":
  "Given functions `f : β → β → φ` and `g : α → β`, produce a function `α → α → φ` that evaluates\n`g` on each argument, then applies `f` to the results. Can be used, e.g., to transfer a relation\nfrom `β` to `α`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List (List α)",
  "name": "List.inits",
  "kind": "def",
  "doc_string":
  "`inits l` is the list of initial segments of `l`.\n```\ninits [1, 2, 3] = [[], [1], [1, 2], [1, 2, 3]]\n```\n",
  "args": ""},
 {"type": "{α : Type u_1} → (lt : α → α → Bool) → α → BinaryHeap α lt",
  "name": "BinaryHeap.singleton",
  "kind": "def",
  "doc_string": "`O(1)`. Build a one-element heap. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Preorder α] → [inst_1 : MulZeroOneClass α] → α →*₀o α",
  "name": "OrderMonoidWithZeroHom.id",
  "kind": "def",
  "doc_string":
  "The identity map as an ordered monoid with zero homomorphism. ",
  "args": ""},
 {"type":
  "{G : Type u_1} → [inst : Zero G] → [inst : Add G] → [inst : Neg G] → List G → G",
  "name": "List.alternatingSum",
  "kind": "def",
  "doc_string": "The alternating sum of a list. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.RingNF.tacticRing_nf!___",
  "kind": "def",
  "doc_string":
  "Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `ring_nf at h` can be used to rewrite in a hypothesis.\n",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : One M₁] →\n        [inst_2 : Pow M₁ ℕ] →\n          [inst_3 : CancelCommMonoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 1 = 1 →\n                  (∀ (x y : M₁), f (x * y) = f x * f y) →\n                    (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) → CancelCommMonoid M₁",
  "name": "Function.Injective.cancelCommMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `1` and `*` is a cancel commutative monoid, if it admits an injective map\nthat preserves `1` and `*` to a cancel commutative monoid.  See note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] (a b : α), a * b = 0 → a = 0 ∨ b = 0",
  "name": "CanonicallyOrderedCommSemiring.eq_zero_or_eq_zero_of_mul_eq_zero",
  "kind": "def",
  "doc_string": "No zero divisors. ",
  "args": ""},
 {"type":
  "∀ {R : Type x} [inst : CommRing R] (a b : R), a * a - b * b = (a + b) * (a - b)",
  "name": "mul_self_sub_mul_self",
  "kind": "theorem",
  "doc_string":
  "Representation of a difference of two squares in a commutative ring as a product. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Add α] [inst_1 : LE α] [self : ExistsAddOfLE α] {a b : α}, a ≤ b → ∃ c, b = a + c",
  "name": "ExistsAddOfLE.exists_add_of_le",
  "kind": "def",
  "doc_string": "For `a ≤ b`, there is a `c` so `b = a + c`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddGroup",
  "kind": "inductive",
  "doc_string":
  "An `AddGroup` is an `AddMonoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition.\n",
  "args": ""},
 {"type": "(α : Type u_1) → PUnit × α ≃ α",
  "name": "Equiv.punitProd",
  "kind": "def",
  "doc_string":
  "`PUnit` is a left identity for type product up to an equivalence. ",
  "args": ""},
 {"type": "Prop → Prop",
  "name": "Fact",
  "kind": "inductive",
  "doc_string":
  "Wrapper for adding elementary propositions to the type class systems.\nWarning: this can easily be abused. See the rest of this docstring for details.\n\nCertain propositions should not be treated as a class globally,\nbut sometimes it is very convenient to be able to use the type class system\nin specific circumstances.\n\nFor example, `Zmod p` is a field if and only if `p` is a prime number.\nIn order to be able to find this field instance automatically by type class search,\nwe have to turn `p.prime` into an instance implicit assumption.\n\nOn the other hand, making `Nat.prime` a class would require a major refactoring of the library,\nand it is questionable whether making `Nat.prime` a class is desirable at all.\nThe compromise is to add the assumption `[Fact p.prime]` to `Zmod.field`.\n\nIn particular, this class is not intended for turning the type class system\ninto an automated theorem prover for first order logic. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : MulOneClass M] → { x // x ∈ ⊤ } ≃* M",
  "name": "Submonoid.topEquiv",
  "kind": "def",
  "doc_string": "The top submonoid is isomorphic to the monoid. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddSemigroup R] {a b : R},\n  IsAddRightRegular a → IsAddRightRegular b → IsAddRightRegular (a + b)",
  "name": "IsAddRightRegular.add",
  "kind": "theorem",
  "doc_string":
  "In an additive semigroup, the sum of add-right-regular elements is\nadd-right-regular.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedCommSemiring α] (a b : α), max a b = if a ≤ b then b else a",
  "name": "LinearOrderedCommSemiring.max_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `maxOfLe`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → {x : MulZeroOneClass M} → [inst : CommMonoidWithZero N] → Mul (M →*₀ N)",
  "name": "instMulMonoidWithZeroHomToMulZeroOneClassToMonoidWithZero",
  "kind": "def",
  "doc_string":
  "Given two monoid with zero morphisms `f`, `g` to a commutative monoid, `f * g` is the monoid\nwith zero morphism sending `x` to `f x * g x`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u} [self : AddMonoidWithOne R] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "name": "AddMonoidWithOne.natCast_succ",
  "kind": "def",
  "doc_string": "The canonical map `ℕ → R` is a homomorphism. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "OrderedRing",
  "kind": "inductive",
  "doc_string":
  "An `OrderedRing` is a ring with a partial order such that addition is monotone and\nmultiplication by a nonnegative number is monotone. ",
  "args": ""},
 {"type": "Linarith.Ineq → Linarith.Ineq → Lean.Name × Linarith.Ineq",
  "name": "Linarith.addIneq",
  "kind": "def",
  "doc_string":
  "If our goal is to add together two inequalities `t1 R1 0` and `t2 R2 0`,\n`addIneq R1 R2` produces the strength of the inequality in the sum `R`,\nalong with the name of a lemma to apply in order to conclude `t1 + t2 R 0`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → List (α × β) → Std.AssocList α β",
  "name": "List.toAssocList",
  "kind": "def",
  "doc_string":
  "Converts a list into an `AssocList`. This is the inverse function to `AssocList.toList`. ",
  "args": ""},
 {"type": "Type",
  "name": "Unit",
  "kind": "def",
  "doc_string":
  "The unit type, the canonical type with one element, named `unit` or `()`.\nIn other words, it describes only a single value, which consists of said constructor applied\nto no arguments whatsoever.\nThe `Unit` type is similar to `void` in languages derived from C.\n\n`Unit` is actually defined as `PUnit.{0}` where `PUnit` is the universe\npolymorphic version. The `Unit` should be preferred over `PUnit` where possible to avoid\nunnecessary universe parameters.\n\nIn functional programming, `Unit` is the return type of things that \"return\nnothing\", since a type with one element conveys no additional information.\nWhen programming with monads, the type `m Unit` represents an action that has\nsome side effects but does not return a value, while `m α` would be an action\nthat has side effects and returns a value of type `α`.\n",
  "args": ""},
 {"type": "∀ {α : Type u_1} (r : Setoid α), Setoid.ker Quotient.mk'' = r",
  "name": "Setoid.ker_mk_eq",
  "kind": "theorem",
  "doc_string":
  "The kernel of the quotient map induced by an equivalence relation r equals r. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → {S : Type u_2} → [inst : Semiring R] → [inst_1 : Semiring S] → (R →+* S) → Module R S",
  "name": "RingHom.toModule",
  "kind": "def",
  "doc_string":
  "A ring homomorphism `f : R →+* M` defines a module structure by `r • x = f r * x`. ",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≤ b → ¬b < a",
  "name": "LE.le.not_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of `not_lt_of_le`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] → [inst_2 : MulOneClass α] → [inst_3 : MulOneClass β] → (α →*o β) → α →o β",
  "name": "OrderMonoidHom.toOrderHom",
  "kind": "def",
  "doc_string":
  "Reinterpret an ordered monoid homomorphism as an order homomorphism. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] (a : α), 1 * a = a",
  "name": "CanonicallyOrderedCommSemiring.one_mul",
  "kind": "def",
  "doc_string": "One is a left neutral element for multiplication ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {F G : C ⥤ D}\n  (α : F ⟶ G) [inst_2 : ∀ (X : C), CategoryTheory.Mono (CategoryTheory.NatTrans.app α X)], CategoryTheory.Mono α",
  "name": "CategoryTheory.NatTrans.mono_of_mono_app",
  "kind": "theorem",
  "doc_string":
  "A natural transformation is a monomorphism if each component is. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : Unique α] → [inst : Preorder β] → (α → β) ≃o β",
  "name": "OrderIso.funUnique",
  "kind": "def",
  "doc_string":
  "Order isomorphism between `α → β` and `β`, where `α` has a unique element. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : LE α] → [inst_1 : LE β] → [inst_2 : OrderTop β] → OrderTop (Lex (α ⊕ β))",
  "name": "Sum.Lex.orderTop",
  "kind": "def",
  "doc_string":
  "The lexicographical top of a sum is the top of the right component. ",
  "args": ""},
 {"type": "Mathlib.Meta.NormNum.NormNumExt",
  "name": "Mathlib.Meta.NormNum.evalSub",
  "kind": "def",
  "doc_string":
  "The `norm_num` extension which identifies expressions of the form `a - b`,\nsuch that `norm_num` successfully recognises both `a` and `b`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → (γ : Type u_3) → (α × β → γ) ≃ (α → β → γ)",
  "name": "Equiv.curry",
  "kind": "def",
  "doc_string":
  "`γ`-valued functions on `α × β` are equivalent to functions `α → β → γ`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CommMonoid α] (a b u : α), IsUnit u → (u * a ∣ b ↔ a ∣ b)",
  "name": "IsUnit.mul_left_dvd",
  "kind": "theorem",
  "doc_string":
  "In a commutative monoid, an element `a` divides an element `b` iff all\nleft associates of `a` divide `b`.",
  "args": ""},
 {"type":
  "∀ {R : Type u₁} [inst : NonUnitalNonAssocRing R], SMulCommClass ℤ R R",
  "name": "NonUnitalNonAssocRing.int_smulCommClass",
  "kind": "def",
  "doc_string":
  "Note that `AddCommGroup.int_smulCommClass` requires stronger assumptions on `R`. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM (Lean.Expr × Lean.Expr)",
  "name": "Linarith.getRelSides",
  "kind": "def",
  "doc_string":
  "`getRelSides e` returns the left and right hand sides of `e` if `e` is a comparison,\nand fails otherwise.\nThis function is more naturally in the `Option` monad, but it is convenient to put in `MetaM`\nfor compositionality.\n ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : Semigroup M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [inst : MulMemClass A M] → (S : A) → Semigroup { x // x ∈ S }",
  "name": "MulMemClass.toSemigroup",
  "kind": "def",
  "doc_string":
  "A subsemigroup of a semigroup inherits a semigroup structure. ",
  "args": ""},
 {"type": "(α : Sort u) → DecidableEq α",
  "name": "Classical.decEq",
  "kind": "def",
  "doc_string": "Any type `α` has decidable equality classically. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [self : PredOrder α] (a : α), PredOrder.pred a ≤ a",
  "name": "PredOrder.pred_le",
  "kind": "def",
  "doc_string": "Proof of basic ordering with respect to `pred`",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, b ≤ c → a < b → a < c",
  "name": "LE.le.trans_lt'",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_le_of_lt'`.",
  "args": ""},
 {"type": "{α : Type u} → [inst : Monoid α] → MulOneClass αˣ",
  "name": "Units.instMulOneClassUnits",
  "kind": "def",
  "doc_string":
  "Units of a monoid form have a multiplication and multiplicative identity. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} (M : Type u_2) [inst : Monoid R] [inst_1 : MulAction R M], IsSMulRegular M 1",
  "name": "IsSMulRegular.one",
  "kind": "theorem",
  "doc_string": "One is always `M`-regular. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] (a b : α), max a b = a ∧ b ≤ a ∨ max a b = b ∧ a < b",
  "name": "max_cases",
  "kind": "theorem",
  "doc_string":
  "For elements `a` and `b` of a linear order, either `max a b = a` and `b ≤ a`,\nor `max a b = b` and `a < b`.\nUse cases on this lemma to automate linarith in inequalities ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Prefunctor.«term_⥤q_»",
  "kind": "def",
  "doc_string": "Notation for a prefunctor between quivers. ",
  "args": ""},
 {"type": "(α : Type u_1) → (β : Type u_2) → [inst : IsEmpty α] → α ⊕ β ≃ β",
  "name": "Equiv.emptySum",
  "kind": "def",
  "doc_string":
  "The sum of `IsEmpty` with any type is equivalent to that type. ",
  "args": ""},
 {"type":
  "{α : Type u} → {m : Type u → Type u_1} → {β : Type u} → [inst : Bind m] → (α → m β) → m α → m β",
  "name": "Bind.bindLeft",
  "kind": "def",
  "doc_string": "Same as `Bind.bind` but with arguments swapped. ",
  "args": ""},
 {"type": "{α : Type u} → Stream' α → α",
  "name": "Stream'.head",
  "kind": "def",
  "doc_string": "Head of a stream: `Stream'.head s = Stream'.nth s 0`. ",
  "args": ""},
 {"type": "ToAdditive.Config → Lean.Syntax",
  "name": "ToAdditive.Config.ref",
  "kind": "def",
  "doc_string":
  "The `Syntax` element corresponding to the original multiplicative declaration\n(or the `to_additive` attribute if it is added later),\nwhich we need for adding definition ranges. ",
  "args": ""},
 {"type":
  "{M : Type uM} → {N : Type uN} → [inst : AddZeroClass M] → [inst_1 : AddCommMonoid N] → AddCommMonoid (M →+ N)",
  "name": "AddMonoidHom.addCommMonoid",
  "kind": "def",
  "doc_string": "`(M →+ N)` is an `AddCommMonoid` if `N` is commutative.",
  "args": ""},
 {"type": "Lean.Name → Lean.Name → Bool → Lean.CoreM Lean.Name",
  "name": "ToAdditive.targetName",
  "kind": "def",
  "doc_string":
  "Return the provided target name or autogenerate one if one was not provided. ",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrderedCancelAddCommMonoid α] → DecidableRel fun x x_1 => x ≤ x_1",
  "name": "LinearOrderedCancelAddCommMonoid.decidable_le",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«stx_<|>_»",
  "kind": "def",
  "doc_string":
  "`p1 <|> p2` is shorthand for `orelse(p1, p2)`, and parses either `p1` or `p2`.\nIt does not backtrack, meaning that if `p1` consumes at least one token then\n`p2` will not be tried. Therefore, the parsers should all differ in their first\ntoken. The `atomic(p)` parser combinator can be used to locally backtrack a parser.\n(For full backtracking, consider using extensible syntax classes instead.)\n\nOn success, if the inner parser does not generate exactly one node, it will be\nautomatically wrapped in a `group` node, so the result will always be arity 1.\n\nThe `<|>` combinator does not generate a node of its own, and in particular\ndoes not tag the inner parsers to distinguish them, which can present a problem\nwhen reconstructing the parse. A well formed `<|>` parser should use disjoint\nnode kinds for `p1` and `p2`.\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} {F : Type u_3} {x : AddZeroClass M} {x_1 : AddZeroClass N}\n  [inst : AddMonoidHomClass F M N] (f : F) {x_2 : M}, (∃ y, y + x_2 = 0) → ∃ y, y + ↑f x_2 = 0",
  "name": "AddMonoidHom.map_exists_left_neg",
  "kind": "theorem",
  "doc_string":
  "Given an AddMonoid homomorphism `f : M →+ N` and an element `x : M`, if `x` has\na left inverse, then `f x` has a left inverse too. For elements invertible on both sides see\n`IsAddUnit.map`.",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type u_1} →\n    [inst : HasSup α] →\n      [inst_1 : HasInf α] →\n        [inst_2 : Bot α] →\n          [inst_3 : SDiff α] →\n            [inst_4 : GeneralizedBooleanAlgebra β] →\n              (f : α → β) →\n                Function.Injective f →\n                  (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) →\n                    (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) →\n                      f ⊥ = ⊥ → (∀ (a b : α), f (a \\ b) = f a \\ f b) → GeneralizedBooleanAlgebra α",
  "name": "Function.Injective.generalizedBooleanAlgebra",
  "kind": "def",
  "doc_string": "Pullback a `GeneralizedBooleanAlgebra` along an injection. ",
  "args": ""},
 {"type":
  "(β : Type v) → (α : Type u_1) → [inst : AddGroup α] → [inst_1 : AddAction α β] → α →+ Additive (Equiv.Perm β)",
  "name": "AddAction.toPermHom",
  "kind": "def",
  "doc_string":
  "Given an action of a additive group `α` on a set `β`, each `g : α` defines a permutation of\n`β`. ",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → [inst : Inhabited β] → α ≃ β → Inhabited α",
  "name": "Equiv.inhabited",
  "kind": "def",
  "doc_string": "If `α ≃ β` and `β` is inhabited, then so is `α`. ",
  "args": ""},
 {"type": "AddHom ℕ+ ℕ",
  "name": "PNat.coeAddHom",
  "kind": "def",
  "doc_string":
  "`coe` promoted to an `AddHom`, that is, a morphism which preserves addition. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tacticDecreasing_tactic",
  "kind": "def",
  "doc_string":
  "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {G : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddCommGroup G] → AddCommGroup (M →+ G)",
  "name": "AddMonoidHom.addCommGroup",
  "kind": "def",
  "doc_string":
  "If `G` is an additive commutative group, then `M →+ G` is an additive commutative\ngroup too.",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Choose.ElimStatus → Mathlib.Tactic.Choose.ElimStatus → Mathlib.Tactic.Choose.ElimStatus",
  "name": "Mathlib.Tactic.Choose.ElimStatus.merge",
  "kind": "def",
  "doc_string":
  "Combine two statuses, keeping a success from either side\nor merging the failures. ",
  "args": ""},
 {"type": "{S : Type u_1} → [inst : LinearOrderedRing S] → AbsoluteValue S S",
  "name": "AbsoluteValue.abs",
  "kind": "def",
  "doc_string": "`AbsoluteValue.abs` is `abs` as a bundled `AbsoluteValue`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (f : α → β) → (s : Set α) → ↑s → ↑(f '' s)",
  "name": "Set.imageFactorization",
  "kind": "def",
  "doc_string":
  "Restriction of `f` to `s` factors through `s.imageFactorization f : s → f '' s`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → ℕ → List α",
  "name": "List.removeNth",
  "kind": "def",
  "doc_string":
  "Removes the `n`th element of `l`, or the original list if `n` is out of bounds. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → ℤ → (e : Q(«$α»)) → Mathlib.Meta.NormNum.Result e",
  "name": "Mathlib.Meta.NormNum.Result.ofRawInt",
  "kind": "def",
  "doc_string":
  "Constructs a `Result` out of a raw int cast.\nAssumes `e` is a raw int cast expression denoting `n`. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → (α ≃. β) → β ≃. α",
  "name": "PEquiv.symm",
  "kind": "def",
  "doc_string": "The inverse partial equivalence. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u₃} →\n          [inst_2 : CategoryTheory.Category E] → {F G : C ⥤ D} → {H I : D ⥤ E} → (F ≅ G) → (H ≅ I) → (F ⋙ H ≅ G ⋙ I)",
  "name": "CategoryTheory.NatIso.hcomp",
  "kind": "def",
  "doc_string": "Horizontal composition of natural isomorphisms. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [self : AddCommMonoidWithOne R] (a b : R), a + b = b + a",
  "name": "AddCommMonoidWithOne.add_comm",
  "kind": "def",
  "doc_string":
  "Addition is commutative in an additive commutative semigroup. ",
  "args": ""},
 {"type":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [inst : NonUnitalNonAssocSemiring α] →\n        [inst_1 : NonUnitalNonAssocSemiring β] → [inst_2 : NonUnitalRingHomClass F α β] → F → α →ₙ+* β",
  "name": "NonUnitalRingHomClass.toNonUnitalRingHom",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `NonUnitalRingHomClass F α β` into an actual\n`NonUnitalRingHom`. This is declared as the default coercion from `F` to `α →ₙ+* β`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : CommRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Neg β] →\n                [inst_6 : Sub β] →\n                  [inst_7 : SMul ℕ β] →\n                    [inst_8 : SMul ℤ β] →\n                      [inst_9 : Pow β ℕ] →\n                        [inst_10 : NatCast β] →\n                          [inst_11 : IntCast β] →\n                            (f : α → β) →\n                              Function.Surjective f →\n                                f 0 = 0 →\n                                  f 1 = 1 →\n                                    (∀ (x y : α), f (x + y) = f x + f y) →\n                                      (∀ (x y : α), f (x * y) = f x * f y) →\n                                        (∀ (x : α), f (-x) = -f x) →\n                                          (∀ (x y : α), f (x - y) = f x - f y) →\n                                            (∀ (x : α) (n : ℕ), f (n • x) = n • f x) →\n                                              (∀ (x : α) (n : ℤ), f (n • x) = n • f x) →\n                                                (∀ (x : α) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                  (∀ (n : ℕ), f ↑n = ↑n) → (∀ (n : ℤ), f ↑n = ↑n) → CommRing β",
  "name": "Function.Surjective.commRing",
  "kind": "def",
  "doc_string":
  "Pushforward a `CommRing` instance along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Neg α] → List α → List α",
  "name": "List.Func.neg",
  "kind": "def",
  "doc_string": "Elementwise negation of a list ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : StrictOrderedSemiring α], 0 ≤ 1",
  "name": "StrictOrderedSemiring.zero_le_one",
  "kind": "def",
  "doc_string": "In a strict ordered semiring, `0 ≤ 1`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Inv α] → Inv (WithZero α)",
  "name": "WithZero.inv",
  "kind": "def",
  "doc_string":
  "Given an inverse operation on `α` there is an inverse operation\non `WithZero α` sending `0` to `0`",
  "args": ""},
 {"type": "{ι : Type u_1} → ComplexShape ι → ComplexShape ι → ComplexShape ι",
  "name": "ComplexShape.trans",
  "kind": "def",
  "doc_string":
  "The \"composition\" of two `ComplexShape`s.\n\nWe need this to define \"related in k steps\" later.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.RunCmd.runCmd",
  "kind": "def",
  "doc_string":
  "The `run_cmd doSeq` command executes code in `CommandElabM Unit`.\nThis is almost the same as `#eval show CommandElabM Unit from do doSeq`,\nexcept that it doesn't print an empty diagnostic.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : PartialOrder β] → (f : α → β) → Function.Injective f → PartialOrder α",
  "name": "PartialOrder.lift",
  "kind": "def",
  "doc_string":
  "Transfer a `PartialOrder` on `β` to a `PartialOrder` on `α` using an injective\nfunction `f : α → β`. See note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u} → (x : ℕ) → [self : OfNat α x] → α",
  "name": "OfNat.ofNat",
  "kind": "def",
  "doc_string":
  "The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. ",
  "args": ""},
 {"type":
  "{V : Type u_1} → [inst : Quiver V] → {W : Type u_3} → (σ : V → W) → V ⥤q Quiver.Push σ",
  "name": "Quiver.Push.of",
  "kind": "def",
  "doc_string": "The prefunctor induced by pushing arrows via `σ` ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LT α] → α → α → Prop",
  "name": "Covby",
  "kind": "def",
  "doc_string":
  "`Covby a b` means that `b` covers `a`: `a < b` and there is no element in between. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Fintype α] → Finset α",
  "name": "Finset.univ",
  "kind": "def",
  "doc_string":
  "`univ` is the universal finite set of type `Finset α` implied from\nthe assumption `Fintype α`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Monoid α] → α → Associates α",
  "name": "Associates.mk",
  "kind": "def",
  "doc_string":
  "The canonical quotient map from a monoid `α` into the `Associates` of `α` ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {f g : M →+ N} {s : Set M},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(AddSubmonoid.closure s)",
  "name": "AddMonoidHom.eqOn_closureM",
  "kind": "theorem",
  "doc_string":
  "If two monoid homomorphisms are equal on a set, then they are equal on its submonoid\nclosure.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemigroup α] {a b : α}, a ∣ b → ∀ (c : α), a ∣ c * b",
  "name": "Dvd.dvd.mul_left",
  "kind": "theorem",
  "doc_string": "**Alias** of `dvd_mul_of_dvd_right`.",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → (f : α ↪ β) → Function.Surjective ↑f → α ≃ β",
  "name": "Function.Embedding.equivOfSurjective",
  "kind": "def",
  "doc_string": "Convert a surjective `Embedding` to an `Equiv` ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LE α] → α → Prop",
  "name": "IsBot",
  "kind": "def",
  "doc_string":
  "`a : α` is a bottom element of `α` if it is less than or equal to any other element of `α`.\nThis predicate is roughly an unbundled version of `OrderBot`, except that a preorder may have\nseveral bottom elements. When `α` is linear, this is useful to make a case disjunction on\n`NoMinOrder α` within a proof. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Parser.Attr.monad_norm",
  "kind": "def",
  "doc_string": "Simp set for `functor_norm` ",
  "args": ""},
 {"type":
  "∀ (α : Type u) [inst : Preorder α] [inst_1 : Nonempty α] [inst_2 : NoMinOrder α] [inst_3 : NoMaxOrder α],\n  ∃ f, StrictMono f",
  "name": "Int.exists_strictMono",
  "kind": "theorem",
  "doc_string":
  "If `α` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly\nmonotone function `f : ℤ → α`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CanonicallyLinearOrderedAddMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α] {a b c : α},\n  AddLECancellable a → AddLECancellable b → b ≤ a → (a - b < a - c ↔ c < b)",
  "name": "AddLECancellable.tsub_lt_tsub_iff_left_of_le",
  "kind": "theorem",
  "doc_string":
  "See `lt_tsub_iff_left_of_le_of_le` for a weaker statement in a partial order. ",
  "args": ""},
 {"type": "ℕ → ℕ → Mathlib.Tactic.Polyrith.Poly",
  "name": "Mathlib.Tactic.Polyrith.Poly.pow'",
  "kind": "def",
  "doc_string":
  "Constructs a power expression `v_i ^ j`, performing some simplifications in trivial cases. ",
  "args": ""},
 {"type": "(A : Type y) → [inst : AddCommGroup A] → A ≃+ (ℤ →+ A)",
  "name": "zmultiplesAddHom",
  "kind": "def",
  "doc_string":
  "If `M` is commutative, `zmultiplesHom` is an additive equivalence. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : SuccOrder α] {a b : α} [inst_2 : NoMaxOrder α],\n  Order.succ a ≤ Order.succ b → a ≤ b",
  "name": "Order.le_of_succ_le_succ",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `Order.succ_le_succ_iff`.",
  "args": ""},
 {"type": "(α : Type u) → [inst : LE α] → Type u",
  "name": "OrderTop",
  "kind": "inductive",
  "doc_string":
  "An order is an `OrderTop` if it has a greatest element.\nWe state this using a data mixin, holding the value of `⊤` and the greatest element constraint. ",
  "args": ""},
 {"type":
  "∀ {f : Type u₀ → Type u₁} [self : EquivFunctor f] {α β γ : Type u₀} (k : α ≃ β) (h : β ≃ γ),\n  EquivFunctor.map (Equiv.trans k h) = EquivFunctor.map h ∘ EquivFunctor.map k",
  "name": "EquivFunctor.map_trans'",
  "kind": "def",
  "doc_string": "`map` is functorial on equivalences. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_→*₀o_»",
  "kind": "def",
  "doc_string": "Infix notation for `OrderMonoidWithZeroHom`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : CanonicallyLinearOrderedMonoid α] → DecidableRel fun x x_1 => x < x_1",
  "name": "CanonicallyLinearOrderedMonoid.decidable_lt",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type u_1} →\n    [inst : OrderedSemiring α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Pow β ℕ] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : NatCast β] →\n                    (f : β → α) →\n                      Function.Injective f →\n                        f 0 = 0 →\n                          f 1 = 1 →\n                            (∀ (x y : β), f (x + y) = f x + f y) →\n                              (∀ (x y : β), f (x * y) = f x * f y) →\n                                (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                  (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) → (∀ (n : ℕ), f ↑n = ↑n) → OrderedSemiring β",
  "name": "Function.Injective.orderedSemiring",
  "kind": "def",
  "doc_string": "Pullback an `OrderedSemiring` under an injective map. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : OrderedSemiring S] (self : AbsoluteValue R S) (x y : R),\n  ↑self.toMulHom (x + y) ≤ ↑self.toMulHom x + ↑self.toMulHom y",
  "name": "AbsoluteValue.add_le'",
  "kind": "def",
  "doc_string": "The absolute value satisfies the triangle inequality ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : OrderedCancelAddCommMonoid M] →\n    {A : Type u_2} →\n      [inst_1 : SetLike A M] → [inst : AddSubmonoidClass A M] → (S : A) → OrderedCancelAddCommMonoid { x // x ∈ S }",
  "name": "AddSubmonoidClass.toOrderedCancelAddCommMonoid",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of an `OrderedCancelAddCommMonoid` is an `OrderedCancelAddCommMonoid`.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Abel.convAbel_nf!_",
  "kind": "def",
  "doc_string":
  "Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "GeneralizedBooleanAlgebra",
  "kind": "inductive",
  "doc_string":
  "A generalized Boolean algebra is a distributive lattice with `⊥` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a ⊓ b) ⊔ (a \\ b) = a` and\n`(a ⊓ b) ⊓ (a \\ b) = ⊥`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `Finset α` for arbitrary\n(not-necessarily-`Fintype`) `α`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α},\n  Set.Nontrivial s → ∀ {f : α → β}, Function.Injective f → Set.Nontrivial (f '' s)",
  "name": "Set.Nontrivial.image",
  "kind": "theorem",
  "doc_string":
  "The image of a nontrivial set under an injective map is nontrivial. ",
  "args": ""},
 {"type": "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → Option α",
  "name": "BinaryHeap.max",
  "kind": "def",
  "doc_string": "`O(1)`. Get the maximum element in a `BinaryHeap`. ",
  "args": ""},
 {"type":
  "∀ {N : Type u_1} {α : Type u_2} [inst : Preorder α] [inst_1 : Preorder N] {f : N → α} {μ : N → N → N}\n  [inst_2 : CovariantClass N N (Function.swap μ) fun x x_1 => x ≤ x_1],\n  Antitone f → ∀ (m : N), Antitone fun n => f (μ n m)",
  "name": "Antitone.covariant_of_const'",
  "kind": "theorem",
  "doc_string": "Dual of `monotone.covariant_of_const'` ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {f g : M →+ N},\n  f = g → ∀ (x : M), ↑f x = ↑g x",
  "name": "AddMonoidHom.congr_fun",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.congr_fun` instead.",
  "args": ""},
 {"type":
  "{R : Type u} → [inst : EuclideanDomain R] → [inst : DecidableEq R] → R → R → R",
  "name": "EuclideanDomain.gcdA",
  "kind": "def",
  "doc_string":
  "The extended GCD `a` value in the equation `gcd x y = x * a + y * b`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → α → Lex (α ⊕ β)",
  "name": "Sum.inlₗ",
  "kind": "def",
  "doc_string": "Lexicographical `sum.inl`. Only used for pattern matching. ",
  "args": ""},
 {"type":
  "{V : Type u_1} → [inst : Quiver V] → [inst_1 : Quiver.HasReverse V] → {a b : V} → Quiver.Path a b → Quiver.Path b a",
  "name": "Quiver.Path.reverse",
  "kind": "def",
  "doc_string": "Reverse the direction of a path. ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → α) → outParam α → Prop",
  "name": "IsRightId",
  "kind": "inductive",
  "doc_string": "A binary operation with a right identity. ",
  "args": ""},
 {"type": "Mathlib.Meta.NormNum.NormNumExt",
  "name": "Mathlib.Meta.NormNum.evalPow",
  "kind": "def",
  "doc_string":
  "The `norm_num` extension which identifies expressions of the form `a ^ b`,\nsuch that `norm_num` successfully recognises both `a` and `b`, with `b : ℕ`. ",
  "args": ""},
 {"type": "{α : Sort u} → (α → α → Prop) → Sort u",
  "name": "Quot",
  "kind": "def",
  "doc_string":
  "Let `α` be any type, and let `r` be an equivalence relation on `α`.\nIt is mathematically common to form the \"quotient\" `α / r`, that is, the type of\nelements of `α` \"modulo\" `r`. Set theoretically, one can view `α / r` as the set\nof equivalence classes of `α` modulo `r`. If `f : α → β` is any function that\nrespects the equivalence relation in the sense that for every `x y : α`,\n`r x y` implies `f x = f y`, then f \"lifts\" to a function `f' : α / r → β`\ndefined on each equivalence class `⟦x⟧` by `f' ⟦x⟧ = f x`.\nLean extends the Calculus of Constructions with additional constants that\nperform exactly these constructions, and installs this last equation as a\ndefinitional reduction rule.\n\nGiven a type `α` and any binary relation `r` on `α`, `Quot r` is a type. Note\nthat `r` is not required to be an equivalance relation. `Quot` is the basic\nbuilding block used to construct later the type `Quotient`.\n",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : Preorder α] → {s : Set α} → {a : α} → IsGreatest s a → OrderTop ↑s",
  "name": "IsGreatest.orderTop",
  "kind": "def",
  "doc_string":
  "If `a` is the greatest element of a set `s`, then subtype `s` is an order with top element. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.LinearCombination.tacticLinear_combination2____",
  "kind": "def",
  "doc_string":
  "`linear_combination` attempts to simplify the target by creating a linear combination\n  of a list of equalities and subtracting it from the target.\n  The tactic will create a linear\n  combination by adding the equalities together from left to right, so the order\n  of the input hypotheses does matter.  If the `normalize` field of the\n  configuration is set to false, then the tactic will simply set the user up to\n  prove their target using the linear combination instead of normalizing the subtraction.\n\nNote: The left and right sides of all the equalities should have the same\n  type, and the coefficients should also have this type.  There must be\n  instances of `Mul` and `AddGroup` for this type.\n\n* The input `e` in `linear_combination e` is a linear combination of proofs of equalities,\n  given as a sum/difference of coefficients multiplied by expressions.\n  The coefficients may be arbitrary expressions.\n  The expressions can be arbitrary proof terms proving equalities.\n  Most commonly they are hypothesis names `h1, h2, ...`.\n* `linear_combination (norm := tac) e` runs the \"normalization tactic\" `tac`\n  on the subgoal(s) after constructing the linear combination.\n  * The default normalization tactic is `ring1`, which closes the goal or fails.\n  * To get a subgoal in the case that it is not immediately provable, use\n    `ring_nf` as the normalization tactic.\n  * To avoid normalization entirely, use `skip` as the normalization tactic.\n* `linear_combination2 e` is the same as `linear_combination e` but it produces two\n  subgoals instead of one: rather than proving that `(a - b) - (a' - b') = 0` where\n  `a' = b'` is the linear combination from `e` and `a = b` is the goal,\n  it instead attempts to prove `a = a'` and `b = b'`.\n  Because it does not use subtraction, this form is applicable also to semirings.\n  * Note that a goal which is provable by `linear_combination e` may not be provable\n    by `linear_combination2 e`; in general you may need to add a coefficient to `e`\n    to make both sides match, as in `linear_combination2 e + c`.\n  * You can also reverse equalities using `← h`, so for example if `h₁ : a = b`\n    then `2 * (← h)` is a proof of `2 * b = 2 * a`.\n\nExample Usage:\n```\nexample (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by\n  linear_combination 1*h1 - 2*h2\n\nexample (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by\n  linear_combination h1 - 2*h2\n\nexample (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by\n  linear_combination (norm := ring_nf) -2*h2\n  /- Goal: x * y + x * 2 - 1 = 0 -/\n\nexample (x y z : ℝ) (ha : x + 2*y - z = 4) (hb : 2*x + y + z = -2)\n    (hc : x + 2*y + z = 2) :\n    -3*x - 3*y - 4*z = 2 := by\n  linear_combination ha - hb - 2*hc\n\nexample (x y : ℚ) (h1 : x + y = 3) (h2 : 3*x = 7) :\n    x*x*y + y*x*y + 6*x = 3*x*y + 14 := by\n  linear_combination x*y*h1 + 2*h2\n\nexample (x y : ℤ) (h1 : x = -3) (h2 : y = 10) : 2*x = -6 := by\n  linear_combination (norm := skip) 2*h1\n  simp\n\naxiom qc : ℚ\naxiom hqc : qc = 2*qc\n\nexample (a b : ℚ) (h : ∀ p q : ℚ, p = q) : 3*a + qc = 3*b + 2*qc := by\n  linear_combination 3 * h a b + hqc\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] (self : ClosureOperator α) (x : α),\n  ↑self.toOrderHom (↑self.toOrderHom x) = ↑self.toOrderHom x",
  "name": "ClosureOperator.idempotent'",
  "kind": "def",
  "doc_string": "Closures are idempotent ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, 1 ≤ a → 1 ≤ b → 1 ≤ a * b",
  "name": "one_le_mul",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.one_le_mul`.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] {f g : AddHom M N} {s : Set M},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(AddSubsemigroup.closure s)",
  "name": "AddHom.eqOn_closure",
  "kind": "theorem",
  "doc_string":
  "If two add homomorphisms are equal on a set,\nthen they are equal on its additive subsemigroup closure.",
  "args": ""},
 {"type":
  "(α : Type u_1) →\n  [H1 : PartialOrder α] →\n    [H2 : InfSet α] →\n      (∀ (a b : α), BddAbove {a, b}) →\n        (∀ (a b : α), BddBelow {a, b}) →\n          (∀ (s : Set α), BddBelow s → Set.Nonempty s → IsGLB s (infₛ s)) → ConditionallyCompleteLattice α",
  "name": "conditionallyCompleteLatticeOfInfₛ",
  "kind": "def",
  "doc_string":
  "Create a `ConditionallyCompleteLattice` from a `PartialOrder` and `inf` function\nthat returns the greatest lower bound of a nonempty set which is bounded below. Usually this\nconstructor provides poor definitional equalities.  If other fields are known explicitly, they\nshould be provided; for example, if `inf` is known explicitly, construct the\n`ConditionallyCompleteLattice` instance as\n```\ninstance : ConditionallyCompleteLattice my_T :=\n{ inf := better_inf,\n  le_inf := ...,\n  inf_le_right := ...,\n  inf_le_left := ...\n  -- don't care to fix sup, supₛ\n  ..conditionallyCompleteLatticeOfInfₛ my_T _ }\n```\n",
  "args": ""},
 {"type": "Sort u → Prop",
  "name": "Subsingleton",
  "kind": "inductive",
  "doc_string":
  "A \"subsingleton\" is a type with at most one element.\nIn other words, it is either empty, or has a unique element.\nAll propositions are subsingletons because of proof irrelevance, but some other types\nare subsingletons as well and they inherit many of the same properties as propositions.\n`Subsingleton α` is a typeclass, so it is usually used as an implicit argument and\ninferred by typeclass inference.\n",
  "args": ""},
 {"type": "Linarith.Sum → Linarith.Monom → Linarith.Sum",
  "name": "Linarith.Sum.scaleByMonom",
  "kind": "def",
  "doc_string":
  "`Sum.scaleByMonom s m` multiplies every monomial in `s` by `m`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {s t : Set α} → s ⊆ t → [inst : DecidablePred fun x => x ∈ s] → ↑s ⊕ ↑(t \\ s) ≃ ↑t",
  "name": "Equiv.Set.sumDiffSubset",
  "kind": "def",
  "doc_string":
  "`sumDiffSubset s t` is the natural equivalence between\n`s ⊕ (t \\ s)` and `t`, where `s` and `t` are two sets. ",
  "args": ""},
 {"type":
  "{V : Type u_1} → [inst : Quiver V] → [self : Quiver.HasReverse V] → {a b : V} → (a ⟶ b) → (b ⟶ a)",
  "name": "Quiver.HasReverse.reverse'",
  "kind": "def",
  "doc_string": "the map which sends an arrow to its reverse ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : NonAssocSemiring α] [inst_1 : NonAssocSemiring β] (self : α →+* β) (x y : α),\n  ↑↑↑self (x + y) = ↑↑↑self x + ↑↑↑self y",
  "name": "RingHom.map_add'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves addition ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : ConditionallyCompleteLinearOrderBot α] (x : α), ⊥ ≤ x",
  "name": "ConditionallyCompleteLinearOrderBot.bot_le",
  "kind": "def",
  "doc_string": "`⊥` is the least element ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α ↪ β) → Set α ↪ Set β",
  "name": "Function.Embedding.image",
  "kind": "def",
  "doc_string": "`Set.image` as an embedding `Set α ↪ Set β`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Add α] → [inst_1 : Add β] → AddHom α β → WithZero α →+ WithZero β",
  "name": "WithZero.map",
  "kind": "def",
  "doc_string":
  "Given an additive map from `α → β` returns an add monoid homomorphism from\n`WithZero α` to `WithZero β`",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], 0 < 1",
  "name": "zero_lt_one",
  "kind": "theorem",
  "doc_string": "See `zero_lt_one'` for a version with the type explicit. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : BEq α] → List α → List α → Option (List α)",
  "name": "List.isPrefixOf?",
  "kind": "def",
  "doc_string": "`isPrefixOf? l₁ l₂` returns `some t` when `l₂ == l₁ ++ t`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {s : Set α} → [inst : DecidablePred fun x => x ∈ s] → {a : α} → ¬a ∈ s → ↑(insert a s) ≃ ↑s ⊕ PUnit",
  "name": "Equiv.Set.insert",
  "kind": "def",
  "doc_string": "If `a ∉ s`, then `insert a s` is equivalent to `s ⊕ punit`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → α → Set α",
  "name": "Set.Iic",
  "kind": "def",
  "doc_string": "Left-infinite right-closed interval ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : CommSemigroup α] → α × α →ₙ* α",
  "name": "mulMulHom",
  "kind": "def",
  "doc_string": "Multiplication as a multiplicative homomorphism. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.Context → Lean.Meta.TransparencyMode",
  "name": "Mathlib.Tactic.Abel.Context.red",
  "kind": "def",
  "doc_string": "TransparencyMode for comparing atoms ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] (oi : α ≃o β),\n  GaloisConnection ↑(RelIso.toRelEmbedding oi).toEmbedding ↑(RelIso.toRelEmbedding (OrderIso.symm oi)).toEmbedding",
  "name": "OrderIso.to_galoisConnection",
  "kind": "theorem",
  "doc_string":
  "Makes a Galois connection from an order-preserving bijection. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Monoid R] {a b : R}, b * a = 1 → IsLeftRegular a",
  "name": "isLeftRegular_of_mul_eq_one",
  "kind": "theorem",
  "doc_string": "An element admitting a left inverse is left-regular. ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] (F : C ⥤ D)\n  [inst_2 : CategoryTheory.Full F] [inst_3 : CategoryTheory.Faithful F] {X Y : C} (f : X ⟶ Y)\n  [inst_4 : CategoryTheory.IsIso (Prefunctor.map F.toPrefunctor f)], CategoryTheory.IsIso f",
  "name": "CategoryTheory.isIso_of_fully_faithful",
  "kind": "theorem",
  "doc_string":
  "If the image of a morphism under a fully faithful functor in an isomorphism,\nthen the original morphisms is also an isomorphism.\n",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : Group G] → Bracket G G",
  "name": "commutatorElement",
  "kind": "def",
  "doc_string": "The commutator of two elements `g₁` and `g₂`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Bundle.«term_×ᵇ_»",
  "kind": "def",
  "doc_string": "The direct sum of two bundles. ",
  "args": ""},
 {"type": "ParsedProjectionData → ProjectionData",
  "name": "ParsedProjectionData.toProjectionData",
  "kind": "def",
  "doc_string": "Turn `ParsedProjectionData` into `ProjectionData`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Semigroup α] [inst_1 : HasDistribNeg α] (a b : α), a ∣ -b ↔ a ∣ b",
  "name": "dvd_neg",
  "kind": "theorem",
  "doc_string":
  "An element a of a semigroup with a distributive negation divides the negation of an element b\niff a divides b. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (s : Set α) → [inst : InfSet α] → [inst : Inhabited ↑s] → InfSet ↑s",
  "name": "subsetInfSet",
  "kind": "def",
  "doc_string":
  "`InfSet` structure on a nonempty subset `s` of an object with `InfSet`. This definition is\nnon-canonical (it uses `default s`); it should be used only as here, as an auxiliary instance in the\nconstruction of the `ConditionallyCompleteLinearOrder` structure. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : α → Sort u_2} → [inst : CoeFun α β] → CoeFun (Multiplicative α) fun a => β (↑Multiplicative.toAdd a)",
  "name": "Multiplicative.coeToFun",
  "kind": "def",
  "doc_string":
  "If `α` has some additive structure and coerces to a function,\nthen `Multiplicative α` should also coerce to the same function.\n\nThis allows `Multiplicative` to be used on bundled function types with an additive structure, which\nis often used for composition, without affecting the behavior of the function itself.\n",
  "args": ""},
 {"type":
  "{α₁ : Sort u_1} → {α₂ : Type u_2} → {β₁ : Sort u_3} → {β₂ : Type u_4} → α₁ ≃ α₂ → β₁ ≃ β₂ → PProd α₁ β₁ ≃ α₂ × β₂",
  "name": "Equiv.pprodProd",
  "kind": "def",
  "doc_string":
  "Combine two equivalences using `PProd` in the domain and `Prod` in the codomain. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ⩿ b → ↑OrderDual.toDual b ⩿ ↑OrderDual.toDual a",
  "name": "Wcovby.toDual",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `toDual_wcovby_toDual_iff`.",
  "args": ""},
 {"type":
  "{M : Type uM} →\n  {N : Type uN} →\n    {P : Type uP} →\n      {Q : Type uQ} →\n        [inst : AddZeroClass M] →\n          [inst_1 : AddZeroClass N] →\n            [inst_2 : AddCommMonoid P] → [inst_3 : AddCommMonoid Q] → (M →+ N →+ P) → (P →+ Q) → M →+ N →+ Q",
  "name": "AddMonoidHom.compr₂",
  "kind": "def",
  "doc_string":
  "The expression `λ m n, g (f m n)` as an `AddMonoidHom`.\n\nThis also exists as a `LinearMap` version, `LinearMap.compr₂`",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {s₁ : Setoid α} →\n        {s₂ : Setoid β} →\n          Quotient s₁ →\n            Quotient s₂ →\n              (f : α → β → γ) →\n                (∀ (a₁ : α) (a₂ : β) (b₁ : α) (b₂ : β), Setoid.r a₁ b₁ → Setoid.r a₂ b₂ → f a₁ a₂ = f b₁ b₂) → γ",
  "name": "Quotient.liftOn₂'",
  "kind": "def",
  "doc_string":
  "A version of `Quotient.liftOn₂` taking `{s₁ : Setoid α} {s₂ : Setoid β}` as implicit arguments\ninstead of instance arguments. ",
  "args": ""},
 {"type": "ℕ → Lean.Expr → Lean.Expr × Lean.Expr",
  "name": "Mathlib.Tactic.Sat.buildReify.reifyVar",
  "kind": "def",
  "doc_string":
  "Returns `a` and `pr : v n ↔ a` given a variable index `n`.\nThese are both lookups into the context\n`(a0 .. a(n-1) : Prop) (v) (h1 : v 0 ↔ a0) ... (hn : v (n-1) ↔ a(n-1))`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    (A : Type u_3) →\n      [inst : Monoid M] →\n        [inst_1 : Monoid A] →\n          [inst_2 : MulDistribMulAction M A] → [inst_3 : Monoid N] → (N →* M) → MulDistribMulAction N A",
  "name": "MulDistribMulAction.compHom",
  "kind": "def",
  "doc_string":
  "Compose a `MulDistribMulAction` with a `MonoidHom`, with action `f r' • m`.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (f : α → β) → ↑(Set.range f) → α",
  "name": "Set.rangeSplitting",
  "kind": "def",
  "doc_string":
  "We can use the axiom of choice to pick a preimage for every element of `range f`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Monoid α] → α → Prop",
  "name": "Irreducible",
  "kind": "inductive",
  "doc_string":
  "`Irreducible p` states that `p` is non-unit and only factors into units.\n\nWe explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a\nmonoid allows us to reuse irreducible for associated elements.\n",
  "args": ""},
 {"type": "(α : Sort u_1) → (PUnit → α) ≃ α",
  "name": "Equiv.punitArrowEquiv",
  "kind": "def",
  "doc_string": "The sort of maps from `PUnit` is equivalent to the codomain. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} → [inst : Add M] → [inst_1 : Add N] → [inst_2 : Add P] → AddHom N P → AddHom M N → AddHom M P",
  "name": "AddHom.comp",
  "kind": "def",
  "doc_string": "Composition of `AddHom`s as a `AddHom`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : Add α] → [inst_1 : Mul α] → [inst_2 : Add β] → [inst_3 : Mul β] → α ≃+* β ≃ (αᵐᵒᵖ ≃+* βᵐᵒᵖ)",
  "name": "RingEquiv.op",
  "kind": "def",
  "doc_string":
  "A ring iso `α ≃+* β` can equivalently be viewed as a ring iso `αᵐᵒᵖ ≃+* βᵐᵒᵖ`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} → [inst : PartialOrder β] → [inst_1 : SemilatticeSup α] → GaloisInsertion l u → SemilatticeSup β",
  "name": "GaloisInsertion.liftSemilatticeSup",
  "kind": "def",
  "doc_string": "Lift the suprema along a Galois insertion ",
  "args": ""},
 {"type": "∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0",
  "name": "NeZero.out",
  "kind": "def",
  "doc_string": "The proposition that `n` is not zero. ",
  "args": ""},
 {"type": "{α : Type u_1} → Set α → (α → α → Prop) → Prop",
  "name": "Set.Pairwise",
  "kind": "def",
  "doc_string":
  "The relation `r` holds pairwise on the set `s` if `r x y` for all *distinct* `x y ∈ s`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), max a b = if a ≤ b then b else a",
  "name": "LinearOrderedRing.max_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `maxOfLe`. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] [inst_1 : SubtractionMonoid H] (h : G ≃+ H) (x : G), ↑h (-x) = -↑h x",
  "name": "AddEquiv.map_neg",
  "kind": "theorem",
  "doc_string":
  "An additive equivalence of additive groups preserves negation.",
  "args": ""},
 {"type":
  "∀ {n k : ℕ}, k ≤ n → Nat.descFactorial n k = Nat.factorial n / Nat.factorial (n - k)",
  "name": "Nat.descFactorial_eq_div",
  "kind": "theorem",
  "doc_string":
  "Avoid in favor of `Nat.factorial_mul_descFactorial` if you can. ℕ-division isn't worth it. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} {l : List α}, l ⊆ [] → l = []",
  "name": "List.eq_nil_of_subset_nil",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `List.subset_nil`.",
  "args": ""},
 {"type": "∀ {α : Type u} [self : OrderedCommRing α] (a b : α), a * b = b * a",
  "name": "OrderedCommRing.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Abel.convAbel!",
  "kind": "def",
  "doc_string":
  "The tactic `abel` evaluates expressions in abelian groups.\nThis is the conv tactic version, which rewrites a target which is a abel equality to `True`.\n\nSee also the `abel` tactic.\n",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Monoid α] → Setoid α",
  "name": "IsConj.setoid",
  "kind": "def",
  "doc_string":
  "The setoid of the relation `IsConj` iff there is a unit `u` such that `u * x = y * u` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : SuccOrder α] [inst_2 : IsSuccArchimedean α] (r : α → α → Prop)\n  {n m : α}, (∀ (i : α), i ∈ Set.Ico n m → r i (Order.succ i)) → n ≤ m → Relation.ReflTransGen r n m",
  "name": "reflTransGen_of_succ_of_le",
  "kind": "theorem",
  "doc_string":
  "For `n ≤ m`, `(n, m)` is in the reflexive-transitive closure of `~` if `i ~ succ i`\nfor all `i` between `n` and `m`. ",
  "args": ""},
 {"type": "(G : Type u) → [inst : Add G] → Prop",
  "name": "IsLeftCancelAdd",
  "kind": "inductive",
  "doc_string": "A mixin for left cancellative addition. ",
  "args": ""},
 {"type": "Linarith.LinarithData → Linarith.PCompSet",
  "name": "Linarith.LinarithData.comps",
  "kind": "def",
  "doc_string": "The set of comparisions. ",
  "args": ""},
 {"type":
  "{M : Type uM} →\n  {N : Type uN} →\n    {P : Type uP} →\n      {Q : Type uQ} →\n        [inst : MulOneClass M] →\n          [inst_1 : MulOneClass N] →\n            [inst_2 : CommMonoid P] → [inst_3 : MulOneClass Q] → (M →* N →* P) → (Q →* N) → M →* Q →* P",
  "name": "MonoidHom.compl₂",
  "kind": "def",
  "doc_string":
  "The expression `λ m q, f m (g q)` as a `MonoidHom`.\n\nNote that the expression `λ q n, f (g q) n` is simply `MonoidHom.comp`. ",
  "args": ""},
 {"type": "Lean.LocalDecl → Lean.MVarId → Lean.MetaM Lean.MVarId",
  "name": "Mathlib.Tactic.Tauto.distribNotAt",
  "kind": "def",
  "doc_string": "Tries to apply de-Morgan-like rules on a hypothesis. ",
  "args": ""},
 {"type":
  "Lean.Expr → ℚ → Lean.Expr → Lean.Expr → Lean.Expr → Mathlib.Meta.NormNum.Result'",
  "name": "Mathlib.Meta.NormNum.Result'.isRat",
  "kind": "def",
  "doc_string": "Untyped version of `Result.isRat`. ",
  "args": ""},
 {"type": "ℕ → Bool → ℕ → ℚ",
  "name": "Rat.ofScientific",
  "kind": "def",
  "doc_string":
  "Implements \"scientific notation\" `123.4e-5` for rational numbers. ",
  "args": ""},
 {"type": "Mathlib.Meta.NormNum.NormNumExt → Bool",
  "name": "Mathlib.Meta.NormNum.NormNumExt.post",
  "kind": "def",
  "doc_string":
  "The extension should be run in the `post` phase when used as simp plugin. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddCommSemigroup α] [inst_1 : PartialOrder α] [inst_2 : ExistsAddOfLE α]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_4 : Sub α] [inst_5 : OrderedSub α]\n  {a b c : α} [inst_6 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  c ≤ b → (a < b - c ↔ a + c < b)",
  "name": "lt_tsub_iff_right_of_le",
  "kind": "theorem",
  "doc_string":
  "See `lt_tsub_iff_right` for a stronger statement in a linear order. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {s : β → β → Prop} → (r : α → α → Prop) → [inst : IsEmpty α] → {b : β} → (∀ (b' : β), ¬s b' b) → r ≺i s",
  "name": "PrincipalSeg.ofIsEmpty",
  "kind": "def",
  "doc_string":
  "Principal segment from an empty type into a type with a minimal element. ",
  "args": ""},
 {"type":
  "{A : Type u_1} →\n  {M₁ : Type u_2} → [inst : SetLike A M₁] → [inst_1 : One M₁] → [hA : OneMemClass A M₁] → (S' : A) → One { x // x ∈ S' }",
  "name": "OneMemClass.one",
  "kind": "def",
  "doc_string": "A submonoid of a monoid inherits a 1. ",
  "args": ""},
 {"type": "ℤ → Bool",
  "name": "Int.bodd",
  "kind": "def",
  "doc_string": "`bodd n` returns `true` if `n` is odd",
  "args": ""},
 {"type": "∀ {K : Type u} [self : Field K] (a : K), a ≠ 0 → a * a⁻¹ = 1",
  "name": "Field.mul_inv_cancel",
  "kind": "def",
  "doc_string": "For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : LE α] →\n      [inst_1 : Top α] →\n        [inst_2 : Bot α] →\n          [inst_3 : LE β] →\n            [inst_4 : BoundedOrder β] →\n              (f : α → β) → (∀ (a b : α), f a ≤ f b → a ≤ b) → f ⊤ = ⊤ → f ⊥ = ⊥ → BoundedOrder α",
  "name": "BoundedOrder.lift",
  "kind": "def",
  "doc_string": "Pullback a `BoundedOrder`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {l : List α}, List.Nodup l → List.Nodup (List.attach l)",
  "name": "List.Nodup.attach",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `List.nodup_attach`.",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {s₁ : Setoid α} {p : Quotient s₁ → Prop}, (∀ (a : α), p (Quotient.mk'' a)) → ∀ (q : Quotient s₁), p q",
  "name": "Quotient.ind'",
  "kind": "theorem",
  "doc_string":
  "A version of `Quotient.ind` taking `{s : Setoid α}` as an implicit argument instead of an\ninstance argument. ",
  "args": ""},
 {"type": "{α : Type u} → (α → α → Prop) → List α → List α → Prop",
  "name": "List.Lex",
  "kind": "inductive",
  "doc_string":
  "Given a strict order `<` on `α`, the lexicographic strict order on `List α`, for which\n`[a0, ..., an] < [b0, ..., b_k]` if `a0 < b0` or `a0 = b0` and `[a1, ..., an] < [b1, ..., bk]`.\nThe definition is given for any relation `r`, not only strict orders. ",
  "args": ""},
 {"type": "ZNum → ZNum",
  "name": "ZNum.bit0",
  "kind": "def",
  "doc_string":
  "`bit0 n` appends a `0` to the end of `n`, where `bit0 n = n0`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddZeroClass M] → (S : AddSubmonoid M) → { x // x ∈ S } →+ M",
  "name": "AddSubmonoid.subtype",
  "kind": "def",
  "doc_string":
  "The natural monoid hom from an `AddSubmonoid` of `AddMonoid` `M` to `M`.",
  "args": ""},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_3} {γ : Sort u_1} (f : α → β → γ) (P : Prop) [inst : Decidable P] (a b : α) (c d : β),\n  f (if P then a else b) (if P then c else d) = if P then f a c else f b d",
  "name": "apply_ite₂",
  "kind": "theorem",
  "doc_string":
  "A two-argument function applied to two `ite`s is a `ite` of that two-argument function\napplied to each of the branches. ",
  "args": ""},
 {"type": "{K : Type u} → [self : DivisionRing K] → ℚ → K → K",
  "name": "DivisionRing.qsmul",
  "kind": "def",
  "doc_string": "Multiplication by a rational number. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : HasSubset α] → α → α → Prop",
  "name": "Superset",
  "kind": "def",
  "doc_string": "Superset relation: `a ⊇ b`  ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {α : Type u_2} → {β : Type u_3} → [inst : Preorder α] → [inst : Preorder β] → (ι → α) → (ι → β) → Set ι → Prop",
  "name": "AntivaryOn",
  "kind": "def",
  "doc_string":
  "`f` antivaries with `g` on `s` if `g i < g j` implies `f j ≤ f i` for all `i, j ∈ s`. ",
  "args": ""},
 {"type": "Lean.Name → Lean.Name → Lean.CoreM Unit",
  "name": "ToAdditive.copyInstanceAttribute",
  "kind": "def",
  "doc_string":
  "Copy the instance attribute in a `to_additive`\n\n[todo] it seems not to work when the `to_additive` is added as an attribute later. ",
  "args": ""},
 {"type":
  "{t t' : Type u → Type u} →\n  (eqv : (α : Type u) → t α ≃ t' α) →\n    [inst : Traversable t] →\n      [inst_1 : IsLawfulTraversable t] →\n        [inst_2 : Traversable t'] →\n          (∀ {α β : Type u} (f : α → β), Functor.map f = Equiv.map eqv f) →\n            (∀ {α β : Type u} (f : β), Functor.mapConst f = Function.comp (Equiv.map eqv) (Function.const α) f) →\n              (∀ {F : Type u → Type u} [inst_3 : Applicative F] [inst_4 : LawfulApplicative F] {α β : Type u}\n                  (f : α → F β), traverse f = Equiv.traverse eqv f) →\n                IsLawfulTraversable t'",
  "name": "Equiv.isLawfulTraversable'",
  "kind": "def",
  "doc_string":
  "If the `Traversable t'` instance has the properties that `map`,\n`map_const`, and `traverse` are equal to the ones that come from\ncarrying the traversable functor structure from `t` over the\nequivalences, then the fact that `t` is a lawful traversable functor\ncarries over as well. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    [sa : Setoid α] →\n      [sb : Setoid β] →\n        {φ : Quotient sa → Quotient sb → Sort u_3} →\n          (qa : Quotient sa) →\n            (qb : Quotient sb) →\n              (f : (a : α) → (b : β) → φ (Quotient.mk sa a) (Quotient.mk sb b)) →\n                (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → HEq (f a₁ b₁) (f a₂ b₂)) → φ qa qb",
  "name": "Quotient.hrecOn₂",
  "kind": "def",
  "doc_string":
  "Induction on two `Quotient` arguments `a` and `b`, result type depends on `⟦a⟧` and `⟦b⟧`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "CategoryTheory.«term_≫_»",
  "kind": "def",
  "doc_string": "Notation for composition of morphisms in a category. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_≼i_»",
  "kind": "def",
  "doc_string":
  "If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≼i s` is an order\nembedding whose range is an initial segment. That is, whenever `b < f a` in `β` then `b` is in the\nrange of `f`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), -1 * a = -a",
  "name": "neg_one_mul",
  "kind": "theorem",
  "doc_string":
  "The additive inverse of one multiplied by an element of a ring is the element's additive\ninverse. ",
  "args": ""},
 {"type":
  "∀ {ι : Sort u_2} {M : Type u_1} [inst : Mul M] (S : ι → Subsemigroup M) {C : M → Prop} {x₁ : M},\n  (x₁ ∈ ⨆ i, S i) → (∀ (i : ι) (x₂ : M), x₂ ∈ S i → C x₂) → (∀ (x y : M), C x → C y → C (x * y)) → C x₁",
  "name": "Subsemigroup.supᵢ_induction",
  "kind": "theorem",
  "doc_string":
  "An induction principle for elements of `⨆ i, S i`.\nIf `C` holds all elements of `S i` for all `i`, and is preserved under multiplication,\nthen it holds for all elements of the supremum of `S`. ",
  "args": ""},
 {"type": "{α : Type u} → [self : Sub α] → α → α → α",
  "name": "Sub.sub",
  "kind": "def",
  "doc_string": "`a - b` computes the difference of `a` and `b`. See `HSub`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Nat.«term_≡_[MOD_]»",
  "kind": "def",
  "doc_string":
  "Modular equality. `n.ModEq a b`, or `a ≡ b [MOD n]`, means that `a - b` is a multiple of `n`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a b : α}, BddBelow s → a ∈ s → a < b → infₛ s < b",
  "name": "cinfₛ_lt_of_lt",
  "kind": "theorem",
  "doc_string":
  "`infₛ s < b` when there is an element `a` in `s` with `a < b`, when `s` is bounded below.\nThis is essentially an iff, except that the assumptions for the two implications are\nslightly different (one needs boundedness below for one direction, nonemptiness and linear\norder for the other one), so we formulate separately the two implications, contrary to\nthe `CompleteLattice` case.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : NonUnitalNonAssocSemiring α] → [inst_1 : NonUnitalNonAssocSemiring β] → (αᵐᵒᵖ →ₙ+* βᵐᵒᵖ) ≃ (α →ₙ+* β)",
  "name": "NonUnitalRingHom.unop",
  "kind": "def",
  "doc_string":
  "The 'unopposite' of a non-unital ring hom `αᵐᵒᵖ →ₙ+* βᵐᵒᵖ`. Inverse to\n`NonUnitalRingHom.op`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), LinearOrderedCommGroupWithZero.zpow 0 a = 1",
  "name": "LinearOrderedCommGroupWithZero.zpow_zero'",
  "kind": "def",
  "doc_string": "`a ^ 0 = 1` ",
  "args": ""},
 {"type":
  "∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂} {σ' : R₂ →+* R₁}\n  [self : RingHomInvPair σ σ'], RingHom.comp σ σ' = RingHom.id R₂",
  "name": "RingHomInvPair.comp_eq₂",
  "kind": "def",
  "doc_string": "`σ'` is a left inverse of `σ'` ",
  "args": ""},
 {"type": "{α : Type u_1} → ℕ → List α → α → List α",
  "name": "List.takeDTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `takeD`. ",
  "args": ""},
 {"type": "Mathlib.Meta.NormNum.NormNumExt",
  "name": "Mathlib.Meta.NormNum.evalZero",
  "kind": "def",
  "doc_string":
  "The `norm_num` extension which identifies the expression `Zero.zero`, returning `0`. ",
  "args": ""},
 {"type": "ProjectionData → Bool",
  "name": "ProjectionData.isDefault",
  "kind": "def",
  "doc_string":
  "A boolean specifying whether `simp` lemmas are generated for this projection by default. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_4} {β' : Type u_3} {γ : Type u_1} {δ : Type u_5} {s : Set α} {t : Set β} {f : α → β' → γ}\n  {g : β → β'} {f' : β → α → δ} {g' : δ → γ},\n  (∀ (a : α) (b : β), f a (g b) = g' (f' b a)) → Set.image2 f s (g '' t) = g' '' Set.image2 f' t s",
  "name": "Set.image_image2_right_anticomm",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Set.image_image2_antidistrib_right`. ",
  "args": ""},
 {"type": "Mathlib.Prelude.Rename.NameEntry → Bool",
  "name": "Mathlib.Prelude.Rename.NameEntry.synthetic",
  "kind": "def",
  "doc_string":
  "If true, this lean 3 -> lean 4 mapping will not be entered into the converse map.\nThis is used for \"internal\" definitions that should never be referred to in the source syntax. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] {s : Set M}, s ⊆ ↑(AddSubmonoid.closure s)",
  "name": "AddSubmonoid.subset_closure",
  "kind": "theorem",
  "doc_string": "The `AddSubmonoid` generated by a set includes the set.",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α α_1 : Type u_1} {p₁ : (α → α_1) → Prop} {f : m (α → α_1)} {q : α_1 → Prop}\n  [inst : Applicative m] [inst_1 : LawfulApplicative m] {x : m α},\n  SatisfiesM p₁ f → SatisfiesM (fun a => ∀ {f : α → α_1}, p₁ f → q (f a)) x → SatisfiesM q (Seq.seq f fun x_1 => x)",
  "name": "SatisfiesM.seq_pre'",
  "kind": "theorem",
  "doc_string":
  "`SatisfiesM` distributes over `<*>`, weakest precondition version 2.\n(Use this when `f` and the goal are known and `x` is a subgoal.)\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] (f : M →* N) (a b : M),\n  ↑f (a * b) = ↑f a * ↑f b",
  "name": "MonoidHom.map_mul",
  "kind": "theorem",
  "doc_string":
  "If `f` is a monoid homomorphism then `f (a * b) = f a * f b`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : One α] → [inst_1 : Mul α] → {a : α} → [inst_2 : Invertible a] → Invertible ⅟a",
  "name": "invertibleInvOf",
  "kind": "def",
  "doc_string": "`a` is the inverse of `⅟a`. ",
  "args": ""},
 {"type":
  "Mathlib.Meta.Positivity.PositivityExt →\n  {u : Lean.Level} →\n    {α : Q(Type u)} →\n      (zα : Q(Zero «$α»)) →\n        (pα : Q(PartialOrder «$α»)) → (e : Q(«$α»)) → Lean.MetaM (Mathlib.Meta.Positivity.Strictness zα pα e)",
  "name": "Mathlib.Meta.Positivity.PositivityExt.eval",
  "kind": "def",
  "doc_string":
  "Attempts to prove a expression `e : α` is `>0`, `≥0`, or `≠0`. ",
  "args": ""},
 {"type": "{α : Type u} → α → α → Array α",
  "name": "Array.mkArray2",
  "kind": "def",
  "doc_string": "Create array `#[a₁, a₂]` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : CommSemigroup M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [inst : MulMemClass A M] → (S : A) → CommSemigroup { x // x ∈ S }",
  "name": "MulMemClass.toCommSemigroup",
  "kind": "def",
  "doc_string": "A subsemigroup of a `CommSemigroup` is a `CommSemigroup`. ",
  "args": ""},
 {"type": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0",
  "name": "MulZeroClass.mul_zero",
  "kind": "def",
  "doc_string": "Zero is a right absorbing element for multiplication ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → {γ : Sort u_3} → (α → β → γ) → Prop",
  "name": "Function.Injective2",
  "kind": "def",
  "doc_string":
  "The property of a binary function `f : α → β → γ` being injective.\nMathematically this should be thought of as the corresponding function `α × β → γ` being injective.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Positivity.positivity",
  "kind": "def",
  "doc_string":
  "Tactic solving goals of the form `0 ≤ x`, `0 < x` and `x ≠ 0`.  The tactic works recursively\naccording to the syntax of the expression `x`, if the atoms composing the expression all have\nnumeric lower bounds which can be proved positive/nonnegative/nonzero by `norm_num`.  This tactic\neither closes the goal or fails.\n\nExamples:\n```\nexample {a : ℤ} (ha : 3 < a) : 0 ≤ a ^ 3 + a := by positivity\n\nexample {a : ℤ} (ha : 1 < a) : 0 < |(3:ℤ) + a| := by positivity\n\nexample {b : ℤ} : 0 ≤ max (-3) (b ^ 2) := by positivity\n```\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] (h : M ≃* N), ↑h 1 = 1",
  "name": "MulEquiv.map_one",
  "kind": "theorem",
  "doc_string":
  "A multiplicative isomorphism of monoids sends `1` to `1` (and is hence a monoid isomorphism). ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Option α) → List α → List α",
  "name": "List.replaceFTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `replaceF`. ",
  "args": ""},
 {"type":
  "∀ (G : Type u) [inst : AddCommSemigroup G] [inst_1 : IsRightCancelAdd G], IsLeftCancelAdd G",
  "name": "AddCommSemigroup.IsRightCancelAdd.toIsLeftCancelAdd",
  "kind": "theorem",
  "doc_string":
  "Any\n`AddCommSemigroup G` that satisfies `IsRightCancelAdd G` also satisfies\n`IsLeftCancelAdd G`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : NonUnitalCommRing α] (a b : α), a * b = b * a",
  "name": "NonUnitalCommRing.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : AddRightCancelSemigroup G] → G → G ↪ G",
  "name": "addRightEmbedding",
  "kind": "def",
  "doc_string":
  "The embedding of a right cancellative additive semigroup into itself\nby right translation by a fixed element.",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : One M] → [inst : Mul M] → [inst : Inv M] → ℤ → M → M",
  "name": "zpowRec",
  "kind": "def",
  "doc_string":
  "The fundamental power operation in a group. `zpowRec n a = a*a*...*a` n times, for integer `n`.\nUse instead `a ^ n`,  which has better definitional behavior. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} →\n      [inst : MulOneClass M] → [inst_1 : MulOneClass N] → [inst_2 : MulOneClass P] → (M →* N) → (M →* P) → M →* N × P",
  "name": "MonoidHom.prod",
  "kind": "def",
  "doc_string":
  "Combine two `MonoidHom`s `f : M →* N`, `g : M →* P` into `f.prod g : M →* N × P`\ngiven by `(f.prod g) x = (f x, g x)`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (r : α → α → Prop) → (a : α) → Subrel r { b | r b a } ≺i r",
  "name": "PrincipalSeg.ofElement",
  "kind": "def",
  "doc_string": "Any element of a well order yields a principal segment ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} → {E : Q(«$α») → Type} → {e : Q(«$α»)} → (self : Mathlib.Tactic.Ring.Result E e) → E self.expr",
  "name": "Mathlib.Tactic.Ring.Result.val",
  "kind": "def",
  "doc_string": "The data associated to the normalization. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {p : α → Prop} (f : Equiv.Perm α) (hf : ∀ (x : α), p x ↔ p (↑f x)),\n  (Equiv.Perm.subtypePerm f hf)⁻¹ = Equiv.Perm.subtypePerm f⁻¹ (_ : ∀ (x : α), p x ↔ p (↑f⁻¹ x))",
  "name": "Equiv.Perm.inv_subtypePerm",
  "kind": "theorem",
  "doc_string": "See `Equiv.Perm.subtypePerm_inv`",
  "args": ""},
 {"type": "{M₀ : Type u_1} → [inst : MulZeroOneClass M₀] → 0 = 1 → Unique M₀",
  "name": "uniqueOfZeroEqOne",
  "kind": "def",
  "doc_string":
  "In a monoid with zero, if zero equals one, then zero is the unique element.\n\nSomewhat arbitrarily, we define the default element to be `0`.\nAll other elements will be provably equal to it, but not necessarily definitionally equal. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b",
  "name": "OrderedCommGroup.mul_le_mul_left",
  "kind": "def",
  "doc_string": "Multiplication is monotone in a ordered commutative group. ",
  "args": ""},
 {"type": "(α : Type u_1) → α × PUnit ≃ α",
  "name": "Equiv.prodPUnit",
  "kind": "def",
  "doc_string":
  "`PUnit` is a right identity for type product up to an equivalence. ",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : Group G] → G → Equiv.Perm G",
  "name": "Equiv.mulLeft",
  "kind": "def",
  "doc_string":
  "Left multiplication in a `Group` is a permutation of the underlying type. ",
  "args": ""},
 {"type":
  "{M : Type uM} →\n  {N : Type uN} →\n    {P : Type uP} →\n      {Q : Type uQ} →\n        [inst : MulOneClass M] →\n          [inst_1 : MulOneClass N] →\n            [inst_2 : CommMonoid P] → [inst_3 : CommMonoid Q] → (M →* N →* P) → (P →* Q) → M →* N →* Q",
  "name": "MonoidHom.compr₂",
  "kind": "def",
  "doc_string": "The expression `λ m n, g (f m n)` as a `MonoidHom`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ≃r s → β → α",
  "name": "RelIso.Simps.symmApply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection]. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : MulOneClass M] → Submonoid M ≃o AddSubmonoid (Additive M)",
  "name": "Submonoid.toAddSubmonoid",
  "kind": "def",
  "doc_string":
  "Submonoids of monoid `M` are isomorphic to additive submonoids of `additive M`. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] {f g : ℚ →*₀ M₀},\n  MonoidWithZeroHom.comp f ↑(Int.castRingHom ℚ) = MonoidWithZeroHom.comp g ↑(Int.castRingHom ℚ) → f = g",
  "name": "MonoidWithZeroHom.ext_rat",
  "kind": "theorem",
  "doc_string":
  "If `f` and `g` agree on the integers then they are equal `φ`.\n\nSee note [partially-applied ext lemmas] for why `comp` is used here. ",
  "args": ""},
 {"type": "ℤ → ℤ → ℤ",
  "name": "Int.shiftr",
  "kind": "def",
  "doc_string":
  "`shiftr m n` produces a integer whose binary representation\nis obtained by right-shifting the binary representation of `m` by `n` places ",
  "args": ""},
 {"type": "Q(Prop) → Lean.MetaM Bool",
  "name": "Mathlib.Tactic.Tauto.finishingConstructorMatcher",
  "kind": "def",
  "doc_string":
  "Matches propositions where we want to apply the `constructor` tactic in the\nfinishing stage of `tauto`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : AddGroup α] [inst_1 : SubtractionMonoid β] (f : α →+ β) (g : α) (n : ℤ),\n  ↑f (n • g) = n • ↑f g",
  "name": "AddMonoidHom.map_zsmul",
  "kind": "theorem",
  "doc_string": "Additive group homomorphisms preserve integer scaling.",
  "args": ""},
 {"type": "∀ {α : Type u} {p : α → Prop} {a : α}, a ∈ { x | p x } → p a",
  "name": "Membership.Mem.out",
  "kind": "theorem",
  "doc_string":
  "If `h : a ∈ {x | p x}` then `h.out : p x`. These are definitionally equal, but this can\nnevertheless be useful for various reasons, e.g. to apply further projection notation or in an\nargument to `simp`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → (f : α → β) → (p : β → Prop) → (∀ (x : α), p (f x)) → (y : Subtype p) × { x // f x = ↑y } ≃ α",
  "name": "Equiv.sigmaSubtypeFiberEquiv",
  "kind": "def",
  "doc_string":
  "If a predicate `p : β → Prop` is true on the range of a map `f : α → β`, then\n`Σ y : {y // p y}, {x // f x = y}` is equivalent to `α`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (self : R ≃+* S)\n  (x y : R), Equiv.toFun self.toEquiv (x + y) = Equiv.toFun self.toEquiv x + Equiv.toFun self.toEquiv y",
  "name": "RingEquiv.map_add'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves addition ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → (Mᵐᵒᵖ →* Nᵐᵒᵖ) ≃ (M →* N)",
  "name": "MonoidHom.unop",
  "kind": "def",
  "doc_string":
  "The 'unopposite' of a monoid homomorphism `Mᵐᵒᵖ →* Nᵐᵒᵖ`. Inverse to `MonoidHom.op`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Preorder α] → Set α → α → Prop",
  "name": "IsGreatest",
  "kind": "def",
  "doc_string":
  "`a` is a greatest element of a set `s`; for a partial order, it is unique if exists ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} {inst : Mul α} {inst_1 : Mul β} {inst_2 : LE β}\n  [self : SubmultiplicativeHomClass F α β] (f : F) (a b : α), ↑f (a * b) ≤ ↑f a * ↑f b",
  "name": "SubmultiplicativeHomClass.map_mul_le_mul",
  "kind": "def",
  "doc_string":
  "the image of a product is less or equal than the product of the images. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] {S T : AddSubmonoid M}, (∀ (x : M), x ∈ S ↔ x ∈ T) → S = T",
  "name": "AddSubmonoid.ext",
  "kind": "theorem",
  "doc_string": "Two `AddSubmonoid`s are equal if they have the same elements.",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (α → β → m β) → β → (as : Array α) → optParam ℕ (Array.size as) → optParam ℕ 0 → m β",
  "name": "Array.foldrMUnsafe",
  "kind": "def",
  "doc_string": "See comment at `forInUnsafe` ",
  "args": ""},
 {"type":
  "{m : Type v → Type w} → [inst : Monad m] → {α : Type u_1} → (ℕ → α → m PUnit) → ℕ → List α → m PUnit",
  "name": "List.mapIdxMAux'",
  "kind": "def",
  "doc_string": "Auxiliary definition for `mapIdxM'`. ",
  "args": ""},
 {"type":
  "ℕ → Lean.MVarId → Lean.FVarId → Lean.MetaM (List (Lean.FVarId × Lean.MVarId))",
  "name": "Mathlib.Tactic.MkIff.nCasesSum",
  "kind": "def",
  "doc_string":
  "Calls `cases` on `h` (assumed to be a binary sum) `n` times, and returns\nthe resulting subgoals and their corresponding new hypotheses.\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M], Reflexive fun a b => ∃ c, AddSemiconjBy c a b",
  "name": "AddSemiconjBy.reflexive",
  "kind": "theorem",
  "doc_string":
  "The relation “there exists an element that semiconjugates `a` to `b`” on an additive\nmonoid (or, more generally, on a `AddZeroClass` type) is reflexive.",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : LinearOrderedRing R] (a : R), a ≠ 0 → 0 < a ^ 2",
  "name": "pow_two_pos_of_ne_zero",
  "kind": "theorem",
  "doc_string": "**Alias** of `sq_pos_of_ne_zero`.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M",
  "name": "Submonoid.center.smulCommClass_right",
  "kind": "def",
  "doc_string": "The center of a monoid acts commutatively on that monoid. ",
  "args": ""},
 {"type":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : DecidableEq ι] [inst_1 : (i : ι) → LinearOrder (α i)]\n  (x y x' y' : (i : ι) → α i),\n  (Set.Icc x y \\ Set.pi Set.univ fun i => Set.Ioo (x' i) (y' i)) ⊆\n    (Set.unionᵢ fun i => Set.Icc x (Function.update y i (x' i))) ∪\n      Set.unionᵢ fun i => Set.Icc (Function.update x i (y' i)) y",
  "name": "Set.Icc_diff_pi_univ_Ioo_subset",
  "kind": "theorem",
  "doc_string":
  "If `x`, `y`, `x'`, and `y'` are functions `Π i : ι, α i`, then\nthe set difference between the box `[x, y]` and the product of the open intervals `(x' i, y' i)`\nis covered by the union of the following boxes: for each `i : ι`, we take\n`[x, update y i (x' i)]` and `[update x i (y' i), y]`.\n\nE.g., if `x' = x` and `y' = y`, then this lemma states that the difference between a closed box\n`[x, y]` and the corresponding open box `{z | ∀ i, x i < z i < y i}` is covered by the union\nof the faces of `[x, y]`. ",
  "args": ""},
 {"type": "outParam (Type u_1) → Type u_2 → Type (max u_1 u_2)",
  "name": "VSub",
  "kind": "inductive",
  "doc_string": "Type class for the `-ᵥ` notation. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Zero M] → [inst_1 : Zero N] → ZeroHom M N → M → N",
  "name": "ZeroHom.Simps.apply",
  "kind": "def",
  "doc_string": "See Note custom simps projection",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (f : α → β) → (s : Set ↑(Set.range f)) → ↑(Set.rangeSplitting f '' s) ≃ ↑s",
  "name": "Equiv.Set.rangeSplittingImageEquiv",
  "kind": "def",
  "doc_string":
  "If `s` is a set in `range f`,\nthen its image under `rangeSplitting f` is in bijection (via `f`) with `s`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : LE α] [self : ExistsMulOfLE α] {a b : α}, a ≤ b → ∃ c, b = a * c",
  "name": "ExistsMulOfLE.exists_mul_of_le",
  "kind": "def",
  "doc_string": "For `a ≤ b`, `a` left divides `b` ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {s t : Set α} →\n    (p : α → Prop) →\n      [inst : DecidablePred p] → (∀ (x : α), x ∈ s → p x) → (∀ (x : α), x ∈ t → ¬p x) → ↑(s ∪ t) ≃ ↑s ⊕ ↑t",
  "name": "Equiv.Set.union'",
  "kind": "def",
  "doc_string":
  "If sets `s` and `t` are separated by a decidable predicate, then `s ∪ t` is equivalent to\n`s ⊕ t`. ",
  "args": ""},
 {"type": "SlimCheck.Shrinkable ℤ",
  "name": "SlimCheck.Int.shrinkable",
  "kind": "def",
  "doc_string":
  "`Int.shrinkable` operates like `Nat.shrinkable` but also includes the negative variants. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Zero M] [inst_1 : Zero N] (f : ZeroHom M N) {x y : M}, x = y → ↑f x = ↑f y",
  "name": "ZeroHom.congr_arg",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.congr_arg` instead.",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Add M] → AddSubsemigroup M → Set M",
  "name": "AddSubsemigroup.Simps.coe",
  "kind": "def",
  "doc_string": "See Note [custom simps projection]",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {E : Type u₃}\n  [inst_2 : CategoryTheory.Category E] {F : C ⥤ D} {G : D ⥤ E} {H : C ⥤ E} [ℋ : CategoryTheory.Faithful H],\n  F ⋙ G = H → CategoryTheory.Faithful F",
  "name": "Eq.faithful_of_comp",
  "kind": "theorem",
  "doc_string": "**Alias** of `CategoryTheory.Faithful.of_comp_eq`.",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : One M₁] →\n        [inst_2 : Pow M₁ ℕ] →\n          [inst_3 : Inv M₁] →\n            [inst_4 : Div M₁] →\n              [inst_5 : Pow M₁ ℤ] →\n                [inst_6 : DivInvMonoid M₂] →\n                  (f : M₁ → M₂) →\n                    Function.Injective f →\n                      f 1 = 1 →\n                        (∀ (x y : M₁), f (x * y) = f x * f y) →\n                          (∀ (x : M₁), f x⁻¹ = (f x)⁻¹) →\n                            (∀ (x y : M₁), f (x / y) = f x / f y) →\n                              (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                (∀ (x : M₁) (n : ℤ), f (x ^ n) = f x ^ n) → DivInvMonoid M₁",
  "name": "Function.Injective.divInvMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `1`, `*`, `⁻¹`, and `/` is a `DivInvMonoid` if it admits an injective map\nthat preserves `1`, `*`, `⁻¹`, and `/` to a `DivInvMonoid`. See note [reducible non-instances]. ",
  "args": ""},
 {"type": "∀ (a b : ℕ), a ^ 2 - b ^ 2 = (a + b) * (a - b)",
  "name": "Nat.pow_two_sub_pow_two",
  "kind": "theorem",
  "doc_string": "**Alias** of `Nat.sq_sub_sq`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : OrderedCommSemiring α] (a b : α), a * b = b * a",
  "name": "OrderedCommSemiring.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tacticFunext__",
  "kind": "def",
  "doc_string":
  "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
  "args": ""},
 {"type": "Ordering → Ordering",
  "name": "Ordering.swap",
  "kind": "def",
  "doc_string": "Swaps less and greater ordering results ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Ord α] → [inst : Ord β] → Ord (α × β)",
  "name": "lexOrd",
  "kind": "def",
  "doc_string": "The lexicographic order on pairs. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⊆_»",
  "kind": "def",
  "doc_string": "Subset relation: `a ⊆ b`  ",
  "args": ""},
 {"type": "∀ {α : Type u} {s t : Set α}, Disjoint t s → s ⊆ tᶜ",
  "name": "Disjoint.subset_compl_left",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Set.subset_compl_iff_disjoint_left`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ≤ b → a ⊓ b = a",
  "name": "inf_of_le_left",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `inf_eq_left`.",
  "args": ""},
 {"type": "∀ {α : Type u} (f : α → Type (max u v)), ¬Function.Surjective f",
  "name": "Function.not_surjective_Type",
  "kind": "theorem",
  "doc_string":
  "There is no surjection from `α : Type u` into `Type u`. This theorem\ndemonstrates why `Type : Type` would be inconsistent in Lean. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : AddSemigroup α] →\n    [inst_1 : PartialOrder α] →\n      [inst : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] → AddLeftCancelSemigroup α",
  "name": "Contravariant.toAddLeftCancelSemigroup",
  "kind": "def",
  "doc_string":
  "An additive semigroup with a partial order and satisfying `AddLeftCancelSemigroup`\n(i.e. `c + a < c + b → a < b`) is a `left_cancel AddSemigroup`.",
  "args": ""},
 {"type":
  "Lean.MVarId → StateRefT' IO.RealWorld (Lean.HashSet Lean.MVarId) Lean.MetaM Unit",
  "name": "Mathlib.Tactic.getUnassignedGoalMVarDependencies.go",
  "kind": "opaque",
  "doc_string": "auxiliary function for `getUnassignedGoalMVarDependencies` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} (r : α → α → Prop) [inst : IsAntisymm α r] {a b : α}, r a b → r b a → a = b",
  "name": "antisymm_of",
  "kind": "theorem",
  "doc_string":
  "A version of `antisymm` with `r` explicit.\n\nThis lemma matches the lemmas from lean core in `Init.Algebra.Classes`, but is missing there.  ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {A : Type u_2} [inst : Monoid M] [inst_1 : AddMonoid A] [self : DistribMulAction M A] (a : M)\n  (x y : A), a • (x + y) = a • x + a • y",
  "name": "DistribMulAction.smul_add",
  "kind": "def",
  "doc_string": "Scalar multiplication distributes across addition ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Lex",
  "kind": "def",
  "doc_string": "A type synonym to equip a type with its lexicographic order. ",
  "args": ""},
 {"type":
  "{C : Type u} → [inst : CategoryTheory.Category C] → {X Y : C} → (X ⟶ Y) → Prop",
  "name": "CategoryTheory.Epi",
  "kind": "inductive",
  "doc_string":
  "A morphism `f` is an epimorphism if it can be cancelled when precomposed:\n`f ≫ g = f ≫ h` implies `g = h`.\n\nSee <https://stacks.math.columbia.edu/tag/003B>.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : SuccOrder α] [inst_2 : Preorder β] {f : α → β},\n  Antitone f → Pairwise (Disjoint on fun n => Set.Ico (f (Order.succ n)) (f n))",
  "name": "Antitone.pairwise_disjoint_on_Ico_succ",
  "kind": "theorem",
  "doc_string":
  "If `α` is a linear succ order, `β` is a preorder, and `f : α → β` is an antitone function, then\nthe intervals `Set.Ico (f (Order.succ n)) (f n)` are pairwise disjoint. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (S : Set α) (f : β ≃ α), ↑f ⁻¹' S = ↑(Equiv.symm f) '' S",
  "name": "Set.preimage_equiv_eq_image_symm",
  "kind": "theorem",
  "doc_string": "Alias for `Equiv.image_eq_preimage` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : AddMonoid M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [inst : AddSubmonoidClass A M] → (S : A) → SMul ℕ { x // x ∈ S }",
  "name": "AddSubmonoidClass.nSMul",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of an `AddMonoid` inherits a scalar multiplication. ",
  "args": ""},
 {"type": "Substring → String",
  "name": "Substring.str",
  "kind": "def",
  "doc_string": "The underlying string to slice. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "LinearOrderedCancelCommMonoid",
  "kind": "inductive",
  "doc_string":
  "A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {F : Type u_3}\n  [mc : AddMonoidHomClass F M N] (f : F), Function.Surjective ↑f → AddMonoidHom.mrange f = ⊤",
  "name": "AddMonoidHom.mrange_top_of_surjective",
  "kind": "theorem",
  "doc_string":
  "The range of a surjective `AddMonoid` hom is the whole of the codomain.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "StrictOrderedCommRing",
  "kind": "inductive",
  "doc_string":
  "A `StrictOrderedCommRing` is a commutative ring with a partial order such that addition is\nstrictly monotone and multiplication by a positive number is strictly monotone. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulStrictMono α],\n  0 < a → 0 < b → 0 < a * b",
  "name": "mul_pos",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.mul_pos`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α),\n  Set.BijOn g (Function.fixedPoints (f ∘ g)) (Function.fixedPoints (g ∘ f))",
  "name": "Function.bijOn_fixedPoints_comp",
  "kind": "theorem",
  "doc_string":
  "Given two maps `f : α → β` and `g : β → α`, `g` is a bijective map between the fixed points\nof `f ∘ g` and the fixed points of `g ∘ f`. The inverse map is `f`, see `invOn_fixedPoints_comp`. ",
  "args": ""},
 {"type":
  "∀ {K : Type u} [self : Field K] (a : ℚ) (x : K), Field.qsmul a x = ↑a * x",
  "name": "Field.qsmul_eq_mul'",
  "kind": "def",
  "doc_string":
  "However `qsmul` is defined,\npropositionally it must be equal to multiplication by `ratCast`. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "name": "congr_arg",
  "kind": "theorem",
  "doc_string": "**Alias** of `congrArg`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      {δ : Type u_4} →\n        {r : α → α → Prop} →\n          {s : β → β → Prop} → {t : γ → γ → Prop} → {u : δ → δ → Prop} → r ↪r s → t ↪r u → Prod.Lex r t ↪r Prod.Lex s u",
  "name": "RelEmbedding.prodLexMap",
  "kind": "def",
  "doc_string": "`Prod.map` as a relation embedding. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Set α → Set β → Prop",
  "name": "Set.MapsTo",
  "kind": "def",
  "doc_string":
  "`MapsTo f a b` means that the image of `a` is contained in `b`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Function.term_On_",
  "kind": "def",
  "doc_string":
  "Given functions `f : β → β → φ` and `g : α → β`, produce a function `α → α → φ` that evaluates\n`g` on each argument, then applies `f` to the results. Can be used, e.g., to transfer a relation\nfrom `β` to `α`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {G : Type u_2} →\n    [inst : Group G] → [inst_1 : MulOneClass M] → (f : M → G) → (∀ (a b : M), f (a * b) = f a * f b) → M →* G",
  "name": "MonoidHom.mk'",
  "kind": "def",
  "doc_string":
  "Makes a group homomorphism from a proof that the map preserves multiplication. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : MulAction α β] [inst_2 : FaithfulSMul α β],\n  Function.Injective MulAction.toPerm",
  "name": "MulAction.toPerm_injective",
  "kind": "theorem",
  "doc_string": "`MulAction.toPerm` is injective on faithful actions. ",
  "args": ""},
 {"type": "{α : Sort u_1} → [inst : DecidableEq α] → α → α → α → α",
  "name": "Equiv.swapCore",
  "kind": "def",
  "doc_string": "A helper function for `Equiv.swap`. ",
  "args": ""},
 {"type": "Type",
  "name": "USize",
  "kind": "inductive",
  "doc_string":
  "A `USize` is an unsigned integer with the size of a word\nfor the platform's architecture.\n\nFor example, if running on a 32-bit machine, USize is equivalent to UInt32.\nOr on a 64-bit machine, UInt64.\n",
  "args": ""},
 {"type":
  "(σ : Type u) → {m : Type u → Type v} → [inst : MonadStateOf σ m] → (σ → σ) → m PUnit",
  "name": "modifyThe",
  "kind": "def",
  "doc_string":
  "Like `modify`, but with `σ` explicit. This is useful if a monad supports\n`MonadStateOf` for multiple different types `σ`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : SemilatticeSup α] {S : Set α},\n  (∀ ⦃i j : α⦄, i ∈ S → j ∈ S → i ⊔ j ∈ S) → DirectedOn (fun x x_1 => x ≤ x_1) S",
  "name": "directedOn_of_sup_mem",
  "kind": "theorem",
  "doc_string": "A set stable by supremum is `≤`-directed. ",
  "args": ""},
 {"type": "Type",
  "name": "lcErased",
  "kind": "axiom",
  "doc_string":
  "Marker for information that has been erased by the code generator. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (t : Set β) → (f : α → β) → ↑(f ⁻¹' t) → ↑t",
  "name": "Set.restrictPreimage",
  "kind": "def",
  "doc_string": "The restriction of a function onto the preimage of a set. ",
  "args": ""},
 {"type": "{α : Type u_1} → (q : Semiquot α) → Semiquot.IsPure q → α",
  "name": "Semiquot.get",
  "kind": "def",
  "doc_string": "Extract the value from a `IsPure` semiquotient. ",
  "args": ""},
 {"type": "ProjectionData → Bool",
  "name": "ProjectionData.isPrefix",
  "kind": "def",
  "doc_string":
  "A boolean specifying whether this projection is written as prefix. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → (γ : Type u_3) → (α ⊕ β) × γ ≃ α × γ ⊕ β × γ",
  "name": "Equiv.sumProdDistrib",
  "kind": "def",
  "doc_string":
  "Type product is right distributive with respect to type sum up to an equivalence. ",
  "args": ""},
 {"type": "Lean.MVarId → Lean.MetaM Unit",
  "name": "Mathlib.Meta.Positivity.positivity",
  "kind": "def",
  "doc_string":
  "The main entry point to the `positivity` tactic. Given a goal `goal` of the form `0 [≤/</≠] e`,\nattempts to recurse on the structure of `e` to prove the goal.\nIt will either close `goal` or fail. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} {inst : NonUnitalNonAssocSemiring α}\n  {inst_1 : NonUnitalNonAssocSemiring β} [self : NonUnitalRingHomClass F α β] (f : F) (x y : α),\n  ↑f (x + y) = ↑f x + ↑f y",
  "name": "NonUnitalRingHomClass.map_add",
  "kind": "def",
  "doc_string": "The proposition that the function preserves addition ",
  "args": ""},
 {"type": "Type",
  "name": "Sat.Clause",
  "kind": "def",
  "doc_string":
  "A clause is a list of literals, thought of as a disjunction like `a ∨ b ∨ ¬c`. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (A : Type u_2) → [inst : Monoid M] → [inst : AddMonoid A] → Type (max u_1 u_2)",
  "name": "DistribMulAction",
  "kind": "inductive",
  "doc_string":
  "Typeclass for multiplicative actions on additive structures. This generalizes group modules. ",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : AddGroup G] → G → Equiv.Perm G",
  "name": "Equiv.addLeft",
  "kind": "def",
  "doc_string":
  "Left addition in an `AddGroup` is a permutation of the underlying type.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "name": "CanonicallyLinearOrderedSemifield.mul_inv_cancel",
  "kind": "def",
  "doc_string": "Every nonzero element of a group with zero is invertible. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : HasSup α] →\n      [inst_1 : SemilatticeSup β] →\n        (f : α → β) → Function.Injective f → (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) → SemilatticeSup α",
  "name": "Function.Injective.semilatticeSup",
  "kind": "def",
  "doc_string":
  "A type endowed with `⊔` is a `SemilatticeSup`, if it admits an injective map that\npreserves `⊔` to a `SemilatticeSup`.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : BEq α] → List α → α → α → List α",
  "name": "List.replace",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `replace l a b` replaces the first element in the list equal to `a` with `b`.\n\n* `replace [1, 4, 2, 3, 3, 7] 3 6 = [1, 4, 2, 6, 3, 7]`\n* `replace [1, 4, 2, 3, 3, 7] 5 6 = [1, 4, 2, 3, 3, 7]`\n",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → (γ : Type u_3) → (α ⊕ β → γ) ≃ (α → γ) × (β → γ)",
  "name": "Equiv.sumArrowEquivProdArrow",
  "kind": "def",
  "doc_string":
  "The type of functions on a sum type `α ⊕ β` is equivalent to the type of pairs of functions\non `α` and on `β`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → (f : r ↪r s) → Function.Surjective ↑f.toEmbedding → r ≃r s",
  "name": "RelIso.ofSurjective",
  "kind": "def",
  "doc_string": "A surjective relation embedding is a relation isomorphism. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → WithBot α → WithBot β",
  "name": "WithBot.map",
  "kind": "def",
  "doc_string":
  "Lift a map `f : α → β` to `WithBot α → WithBot β`. Implemented using `Option.map`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : AddCommGroup α] → ℤ → α → α",
  "name": "Mathlib.Tactic.Abel.smulg",
  "kind": "def",
  "doc_string": "A synonym for `•`, used internally in `abel`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : PartialOrder α] [inst_1 : Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β},\n  Function.Semiconj g ↑(RelIso.toRelEmbedding fa).toEmbedding ↑fb.toEmbedding →\n    ∀ {g' : β → α},\n      IsOrderRightAdjoint g g' → Function.Semiconj g' ↑fb.toEmbedding ↑(RelIso.toRelEmbedding fa).toEmbedding",
  "name": "Function.Semiconj.symm_adjoint",
  "kind": "theorem",
  "doc_string":
  "If an order automorphism `fa` is semiconjugate to an order embedding `fb` by a function `g`\nand `g'` is an order right adjoint of `g` (i.e. `g' y = supₛ {x | f x ≤ y}`), then `fb` is\nsemiconjugate to `fa` by `g'`.\n\nThis is a version of Proposition 2.1 from [Étienne Ghys, Groupes d'homéomorphismes du cercle et\ncohomologie bornée][ghys87:groupes]. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«command#helpConv+__»",
  "kind": "def",
  "doc_string":
  "The command `#help conv` shows all tactics that have been defined in the current environment.\nSee `#help cat` for more information.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : GeneralizedHeytingAlgebra α] (a b c : α), a ≤ b ⇨ c ↔ a ⊓ b ≤ c",
  "name": "GeneralizedHeytingAlgebra.le_himp_iff",
  "kind": "def",
  "doc_string": "`a ⇨` is right adjoint to `a ⊓` ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → Array α → (α → m β) → m (Array β)",
  "name": "Array.sequenceMap",
  "kind": "def",
  "doc_string":
  "A fusion of Haskell's `sequence` and `map`. Used in syntax quotations. ",
  "args": ""},
 {"type": "(α : Type u_1) → (α → α → Prop) → (α → α → Prop) → Type",
  "name": "IsNonstrictStrictOrder",
  "kind": "inductive",
  "doc_string":
  "An unbundled relation class stating that `r` is the nonstrict relation corresponding to the\nstrict relation `s`. Compare `Preorder.lt_iff_le_not_le`. This is mostly meant to provide dot\nnotation on `(⊆)` and `(⊂)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, Disjoint a a → a = ⊥",
  "name": "Disjoint.eq_bot_of_self",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `disjoint_self`.",
  "args": ""},
 {"type": "{α β σ : Type u} → σ → DoResultPRBC α β σ",
  "name": "DoResultPRBC.break",
  "kind": "def",
  "doc_string":
  "`break s` means that `break` was called, meaning that we should exit\nfrom the containing loop ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, a < 1 → b ≤ 1 → a * b < 1",
  "name": "Left.mul_lt_one_of_lt_of_le",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one_of_lt_of_le`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : AddCommGroup α] → AddCommGroup.TotalPositiveCone α → LinearOrderedAddCommGroup α",
  "name": "LinearOrderedAddCommGroup.mkOfPositiveCone",
  "kind": "def",
  "doc_string":
  "Construct a `LinearOrderedAddCommGroup` by\ndesignating a positive cone in an existing `AddCommGroup`\nsuch that for every `a`, either `a` or `-a` is non-negative. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {R' : Type u_2} →\n    {S : Type u_3} →\n      {S' : Type u_4} →\n        [inst : NonUnitalNonAssocSemiring R] →\n          [inst_1 : NonUnitalNonAssocSemiring S] →\n            [inst_2 : NonUnitalNonAssocSemiring R'] →\n              [inst_3 : NonUnitalNonAssocSemiring S'] → (R →ₙ+* R') → (S →ₙ+* S') → R × S →ₙ+* R' × S'",
  "name": "NonUnitalRingHom.prodMap",
  "kind": "def",
  "doc_string": "`prod.map` as a `NonUnitalRingHom`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "LT",
  "kind": "inductive",
  "doc_string":
  "`LT α` is the typeclass which supports the notation `x < y` where `x y : α`.",
  "args": ""},
 {"type": "{α : Type u_1} → [self : LinearOrderedSemifield α] → ℤ → α → α",
  "name": "LinearOrderedSemifield.zpow",
  "kind": "def",
  "doc_string":
  "The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        (P : D → Prop) →\n          (F : C ⥤ D) →\n            (hF : ∀ (X : C), P (Prefunctor.obj F.toPrefunctor X)) →\n              CategoryTheory.FullSubcategory.lift P F hF ⋙ CategoryTheory.fullSubcategoryInclusion P ≅ F",
  "name": "CategoryTheory.FullSubcategory.lift_comp_inclusion",
  "kind": "def",
  "doc_string":
  "Composing the lift of a functor through a full subcategory with the inclusion yields the\noriginal functor. Unfortunately, this is not true by definition, so we only get a natural\nisomorphism, but it is pointwise definitionally true, see\n`fullSubcategoryInclusion_obj_lift_obj` and `fullSubcategoryInclusion_map_lift_map`. ",
  "args": ""},
 {"type": "{β : Sort u_1} → β → PUnit ↪ β",
  "name": "Function.Embedding.punit",
  "kind": "def",
  "doc_string":
  "Choosing an element `b : β` gives an embedding of `punit` into `β`. ",
  "args": ""},
 {"type": "{M : Type u_1} → [hM : Monoid M] → (∀ (a : M), IsUnit a) → Group M",
  "name": "groupOfIsUnit",
  "kind": "def",
  "doc_string":
  "Constructs a `Group` structure on a `Monoid` consisting only of units. ",
  "args": ""},
 {"type": "PosNum → PosNum → PosNum",
  "name": "PosNum.sub",
  "kind": "def",
  "doc_string":
  "Subtraction of `PosNum`s, where if `a < b`, then `a - b = 1`. ",
  "args": ""},
 {"type":
  "Lean.Expr → optParam Bool true → Mathlib.Tactic.RingNF.M Lean.Meta.Simp.Result",
  "name": "Mathlib.Tactic.RingNF.rewrite",
  "kind": "def",
  "doc_string":
  "A tactic in the `RingNF.M` monad which will simplify expression `parent` to a normal form.\n* `root`: true if this is a direct call to the function.\n  `RingNF.M.run` sets this to `false` in recursive mode.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m",
  "name": "exists_maximal_of_chains_bounded",
  "kind": "theorem",
  "doc_string":
  "**Zorn's lemma**\n\nIf every chain has an upper bound, then there exists a maximal element. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddMonoid M] {a : AddUnits M} {x y : M}, AddSemiconjBy (↑a) x y → AddSemiconjBy (↑(-a)) y x",
  "name": "AddSemiconjBy.addUnits_neg_symm_left",
  "kind": "theorem",
  "doc_string":
  "If an additive unit `a` semiconjugates `x` to `y`, then `-a` semiconjugates `y` to\n`x`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Ring α] → [inst : NoZeroDivisors α] → CancelMonoidWithZero α",
  "name": "NoZeroDivisors.toCancelMonoidWithZero",
  "kind": "def",
  "doc_string":
  "A ring with no zero divisors is a `CancelMonoidWithZero`.\n\nNote this is not an instance as it forms a typeclass loop. ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : NonAssocSemiring α] (a : α), 1 * a = a",
  "name": "NonAssocSemiring.one_mul",
  "kind": "def",
  "doc_string": "One is a left neutral element for multiplication ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) ≃o (αᵒᵈ →o βᵒᵈ)ᵒᵈ",
  "name": "OrderHom.dualIso",
  "kind": "def",
  "doc_string": "`OrderHom.dual` as an order isomorphism. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Sat.LClause → Lean.Expr",
  "name": "Mathlib.Tactic.Sat.LClause.expr",
  "kind": "def",
  "doc_string": "The clause expression of type `Clause` ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_<_»",
  "kind": "def",
  "doc_string": "The less-than relation: `x < y` ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {zα : Q(Zero «$α»)} →\n      {pα : Q(PartialOrder «$α»)} →\n        {m : Type → Type u_1} →\n          {e : Q(«$α»)} →\n            [inst : Monad m] →\n              [inst : Alternative m] →\n                m (Mathlib.Meta.Positivity.Strictness zα pα e) → m (Mathlib.Meta.Positivity.Strictness zα pα e)",
  "name": "Mathlib.Meta.Positivity.throwNone",
  "kind": "def",
  "doc_string":
  "Converts a `MetaM Strictness` which can return `.none`\ninto one which never returns `.none` but fails instead. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Mul M] → HasInf (Subsemigroup M)",
  "name": "Subsemigroup.instHasInfSubsemigroup",
  "kind": "def",
  "doc_string": "The inf of two subsemigroups is their intersection. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HShiftLeft α β γ] → α → β → γ",
  "name": "HShiftLeft.hShiftLeft",
  "kind": "def",
  "doc_string":
  "`a <<< b` computes `a` shifted to the left by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat`, this is equivalent to `a * 2 ^ b`.\n* On `UInt8` and other fixed width unsigned types, this is the same but\n  truncated to the bit width. ",
  "args": ""},
 {"type": "{α : Sort u} → Nonempty α → α",
  "name": "Classical.choice",
  "kind": "axiom",
  "doc_string":
  "**The axiom of choice**. `Nonempty α` is a proof that `α` has an element,\nbut the element itself is erased. The axiom `choice` supplies a particular\nelement of `α` given only this proof.\n\nThe textbook axiom of choice normally makes a family of choices all at once,\nbut that is implied from this formulation, because if `α : ι → Type` is a\nfamily of types and `h : ∀ i, Nonempty (α i)` is a proof that they are all\nnonempty, then `fun i => Classical.choice (h i) : ∀ i, α i` is a family of\nchosen elements. This is actually a bit stronger than the ZFC choice axiom;\nthis is sometimes called \"[global choice](https://en.wikipedia.org/wiki/Axiom_of_global_choice)\".\n\nIn lean, we use the axiom of choice to derive the law of excluded middle\n(see `Classical.em`), so it will often show up in axiom listings where you\nmay not expect. You can use `#print axioms my_thm` to find out if a given\ntheorem depends on this or other axioms.\n\nThis axiom can be used to construct \"data\", but obviously there is no algorithm\nto compute it, so lean will require you to mark any definition that would\ninvolve executing `Classical.choice` or other axioms as `noncomputable`, and\nwill not produce any executable code for such definitions.\n",
  "args": ""},
 {"type": "{α : Type u} → ℕ → List α → List α",
  "name": "List.drop",
  "kind": "def",
  "doc_string":
  "`O(min n |xs|)`. Removes the first `n` elements of `xs`.\n* `drop 0 [a, b, c, d, e] = [a, b, c, d, e]`\n* `drop 3 [a, b, c, d, e] = [d, e]`\n* `drop 6 [a, b, c, d, e] = []`\n",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : LE α] →\n      [inst_1 : Top α] →\n        [inst_2 : LE β] → [inst_3 : OrderTop β] → (f : α → β) → (∀ (a b : α), f a ≤ f b → a ≤ b) → f ⊤ = ⊤ → OrderTop α",
  "name": "OrderTop.lift",
  "kind": "def",
  "doc_string": "Pullback an `OrderTop`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [self : SuccOrder α] {a : α}, SuccOrder.succ a ≤ a → IsMax a",
  "name": "SuccOrder.max_of_succ_le",
  "kind": "def",
  "doc_string": "Proof of interaction between `succ` and maximal element",
  "args": ""},
 {"type": "Lean.MVarId → ℕ → Lean.MetaM Unit",
  "name": "Mathlib.Tactic.LibrarySearch.solveByElim",
  "kind": "def",
  "doc_string": "Shortcut for calling `solveByElimImpl`. ",
  "args": ""},
 {"type": "Type u_1 → outParam (Type u_2) → Type (max u_1 u_2)",
  "name": "SetLike",
  "kind": "inductive",
  "doc_string":
  "A class to indicate that there is a canonical injection between `A` and `Set B`.\n\nThis has the effect of giving terms of `A` elements of type `B` (through a `Membership`\ninstance) and a compatible coercion to `Type*` as a subtype.\n\nNote: if `SetLike.coe` is a projection, implementers should create a simp lemma such as\n```\n@[simp] lemma mem_carrier {p : MySubobject X} : x ∈ p.carrier ↔ x ∈ (p : Set X) := Iff.rfl\n```\nto normalize terms.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {l l' : List α} (h : l = l') (i : Fin (List.length l)),\n  List.get l i = List.get l' { val := ↑i, isLt := (_ : ↑i < List.length l') }",
  "name": "List.get_of_eq",
  "kind": "theorem",
  "doc_string":
  "If one has `get l i hi` in a formula and `h : l = l'`, one can not `rw h` in the formula as\n`hi` gives `i < l.length` and not `i < l'.length`. The theorem `get_of_eq` can be used to make\nsuch a rewrite, with `rw (get_of_eq h)`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Sort u_2} → (ℕ → α → β → β) → β → List α → optParam ℕ 0 → β",
  "name": "List.foldrIdx",
  "kind": "def",
  "doc_string":
  "Fold a list from right to left as with `foldr`, but the combining function\nalso receives each element's index.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : OrderTop α] {a : α}, IsCoatom a → IsAtom (↑OrderDual.toDual a)",
  "name": "IsCoatom.dual",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `isAtom_dual_iff_isCoatom`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedMonoid α] (a b : α), a ≤ b ∨ b ≤ a",
  "name": "CanonicallyLinearOrderedMonoid.le_total",
  "kind": "def",
  "doc_string": "A linear order is total. ",
  "args": ""},
 {"type": "∀ (p : Prop), p ∨ ¬p",
  "name": "Classical.em",
  "kind": "theorem",
  "doc_string":
  "Diaconescu's theorem: excluded middle from choice, Function extensionality and propositional extensionality. ",
  "args": ""},
 {"type":
  "∀ {a b : ℤ}, a ≠ 0 → IsLeast { n | 0 < n ∧ ∃ x y, ↑n = a * x + b * y } (Int.gcd a b)",
  "name": "Int.gcd_least_linear",
  "kind": "theorem",
  "doc_string":
  "For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be\nwritten in the form `a * x + b * y` for some pair of integers `x` and `y` ",
  "args": ""},
 {"type":
  "{M : Type u_1} → (A : Type u_2) → [inst : Zero A] → [inst_1 : SMulZeroClass M A] → M → ZeroHom A A",
  "name": "SMulZeroClass.toZeroHom",
  "kind": "def",
  "doc_string": "Each element of the scalars defines a zero-preserving map. ",
  "args": ""},
 {"type":
  "∀ {ι : Sort u_2} {M : Type u_1} [inst : Add M] (S : ι → AddSubsemigroup M) {C : M → Prop} {x₁ : M},\n  (x₁ ∈ ⨆ i, S i) → (∀ (i : ι) (x₂ : M), x₂ ∈ S i → C x₂) → (∀ (x y : M), C x → C y → C (x + y)) → C x₁",
  "name": "AddSubsemigroup.supᵢ_induction",
  "kind": "theorem",
  "doc_string":
  "An induction principle for elements of `⨆ i, S i`. If `C` holds all\nelements of `S i` for all `i`, and is preserved under addition, then it holds for all elements of\nthe supremum of `S`.",
  "args": ""},
 {"type": "Lean.NameMapExtension Lean.Name",
  "name": "ToAdditive.translations",
  "kind": "opaque",
  "doc_string": "Maps multiplicative names to their additive counterparts. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] {f g : AddHom M N}, f = g ↔ ∀ (x : M), ↑f x = ↑g x",
  "name": "AddHom.ext_iff",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.ext_iff` instead.",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → Zero (M →+ N)",
  "name": "instZeroAddMonoidHom",
  "kind": "def",
  "doc_string":
  "`0` is the additive monoid homomorphism sending all elements to `0`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Add α] → [inst_1 : Add β] → AddHom αᵐᵒᵖ βᵐᵒᵖ ≃ AddHom α β",
  "name": "AddHom.mulUnop",
  "kind": "def",
  "doc_string":
  "The 'unopposite' of an additive semigroup hom `αᵐᵒᵖ →+ βᵐᵒᵖ`. Inverse to\n`AddHom.mul_op`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LE α] → WithTop α ≃o Lex (α ⊕ PUnit)",
  "name": "WithTop.orderIsoSumLexPUnit",
  "kind": "def",
  "doc_string":
  "`WithTop α` is order-isomorphic to `α ⊕ₗ PUnit`, by sending `⊤` to `unit` and `↑a` to\n`a`. ",
  "args": ""},
 {"type": "(G : Type u_1) → [inst : InvolutiveNeg G] → Equiv.Perm G",
  "name": "Equiv.neg",
  "kind": "def",
  "doc_string":
  "Negation on an `AddGroup` is a permutation of the underlying type.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] (n : ℕ) (x : α),\n  CanonicallyOrderedCommSemiring.npow (n + 1) x = x * CanonicallyOrderedCommSemiring.npow n x",
  "name": "CanonicallyOrderedCommSemiring.npow_succ",
  "kind": "def",
  "doc_string": "Raising to the power `(n + 1 : ℕ)` behaves as expected. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} {inst : Preorder α} {inst_1 : Preorder β} {inst_2 : AddZeroClass α}\n  {inst_3 : AddZeroClass β} [self : OrderAddMonoidHomClass F α β] (f : F), Monotone ↑f",
  "name": "OrderAddMonoidHomClass.monotone",
  "kind": "def",
  "doc_string": "An `OrderAddMonoidHom` is a monotone function. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : PredOrder α] {a b : α} [inst_2 : NoMinOrder α],\n  a ≠ b → Order.pred a ≠ Order.pred b",
  "name": "Order.pred_ne_pred",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Order.pred_ne_pred_iff`.",
  "args": ""},
 {"type":
  "∀ {n k : ℕ} {S : Set ℕ}, k ∈ S → (∀ (k : ℕ), k ∈ S → k + 1 ∈ S) → k ≤ n → n ∈ S",
  "name": "Nat.set_induction_bounded",
  "kind": "theorem",
  "doc_string":
  "A subset of `ℕ` containing `k : ℕ` and closed under `Nat.succ` contains every `n ≥ k`. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_2} {M₀' : Type u_1} [inst : MulZeroOneClass M₀] [inst_1 : Nontrivial M₀] [inst_2 : Zero M₀']\n  [inst_3 : One M₀'] (f : M₀' → M₀), f 0 = 0 → f 1 = 1 → Nontrivial M₀'",
  "name": "pullback_nonzero",
  "kind": "theorem",
  "doc_string":
  "Pullback a `nontrivial` instance along a function sending `0` to `0` and `1` to `1`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "LinearOrderedSemiring",
  "kind": "inductive",
  "doc_string":
  "A `LinearOrderedSemiring` is a nontrivial semiring with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {f g : β → α},\n  Antitone f → StrictAnti g → StrictAnti fun x => f x + g x",
  "name": "Antitone.add_strict_anti",
  "kind": "theorem",
  "doc_string":
  "The sum of a antitone function and a strictly antitone function is\nstrictly antitone.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a : α}, a⁻¹ ≤ 1 ↔ 1 ≤ a",
  "name": "inv_le_one'",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.inv_le_one_iff`.",
  "args": ""},
 {"type":
  "Lean.Syntax → Lean.Syntax → optParam Bool false → optParam Bool true → Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Meta.NormNum.elabNormNum",
  "kind": "def",
  "doc_string":
  "Elaborates a call to `norm_num only? [args]` or `norm_num1`.\n* `args`: the `(simpArgs)?` syntax for simp arguments\n* `loc`: the `(location)?` syntax for the optional location argument\n* `simpOnly`: true if `only` was used in `norm_num`\n* `useSimp`: false if `norm_num1` was used, in which case only the structural parts\n  of `simp` will be used, not any of the post-processing that `simp only` does without lemmas\n",
  "args": ""},
 {"type": "{α : Type u_1} → (List α → List α) → ℕ → List α → List α",
  "name": "List.modifyNthTail",
  "kind": "def",
  "doc_string":
  "Apply a function to the nth tail of `l`. Returns the input without\nusing `f` if the index is larger than the length of the List.\n```\nmodifyNthTail f 2 [a, b, c] = [a, b] ++ f [c]\n```\n",
  "args": ""},
 {"type":
  "∀ {A : Type u_1} {B : Type u_2} [inst : Add A] [inst_1 : Add B] (self : A ≃+ B) (x y : A),\n  Equiv.toFun self.toEquiv (x + y) = Equiv.toFun self.toEquiv x + Equiv.toFun self.toEquiv y",
  "name": "AddEquiv.map_add'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves addition ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₂] →\n      [inst_1 : Zero M₂] →\n        [inst_2 : AddZeroClass M₁] →\n          (f : M₁ → M₂) → Function.Surjective f → f 0 = 0 → (∀ (x y : M₁), f (x + y) = f x + f y) → AddZeroClass M₂",
  "name": "Function.Surjective.addZeroClass",
  "kind": "def",
  "doc_string":
  "A type endowed with `0` and `+` is an `AddZeroClass`, if it admits a\nsurjective map that preserves `0` and `+` to an `AddZeroClass`.",
  "args": ""},
 {"type": "∀ {α : Sort u_1} (a : α), a = a",
  "name": "Eq.refl",
  "kind": "def",
  "doc_string":
  "`Eq.refl a : a = a` is reflexivity, the unique constructor of the\nequality type. See also `rfl`, which is usually used instead. ",
  "args": ""},
 {"type": "Linarith.PComp → Std.RBSet ℕ compare",
  "name": "Linarith.PComp.effective",
  "kind": "def",
  "doc_string":
  "The variables which have been *effectively eliminated*,\ni.e. the by running the elimination algorithm on that variable. ",
  "args": ""},
 {"type":
  "{C : Type u} → [inst : CategoryTheory.Category C] → {X Y Z : C} → (X ≅ Y) → (Y ≅ Z) → (X ≅ Z)",
  "name": "CategoryTheory.Iso.trans",
  "kind": "def",
  "doc_string": "Composition of two isomorphisms ",
  "args": ""},
 {"type":
  "{a : Q(ℕ)} → Mathlib.Tactic.Ring.ExBase Mathlib.Tactic.Ring.sℕ a → Option Q(0 < «$a»)",
  "name": "Mathlib.Tactic.Ring.ExBase.evalPos",
  "kind": "opaque",
  "doc_string":
  "Attempts to prove that a polynomial expression in `ℕ` is positive.\n\n* Atoms are not (necessarily) positive\n* Sums defer to `ExSum.evalPos`\n",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → Prop",
  "name": "Pairwise",
  "kind": "def",
  "doc_string": "A relation `r` holds pairwise if `r i j` for all `i ≠ j`. ",
  "args": ""},
 {"type":
  "ProjectionRule → (Lean.Name × Lean.Syntax) × Lean.Name × Lean.Syntax ⊕ Lean.Name × Lean.Syntax",
  "name": "ProjectionRule.rule",
  "kind": "def",
  "doc_string":
  "A projection rule is either a renaming rule `before→after` or a hiding rule `-hideMe`.\nEach name comes with the syntax used to write the rule,\nwhich is used to declare hover information. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : HeytingAlgebra α] {a b : α}, Disjoint a b → a ≤ bᶜ",
  "name": "Disjoint.le_compl_right",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `le_compl_iff_disjoint_right`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LinearOrderedRing α] (a b c : α), 0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a",
  "name": "mul_nonneg_of_three",
  "kind": "theorem",
  "doc_string":
  "Out of three elements of a `LinearOrderedRing`, two must have the same sign. ",
  "args": ""},
 {"type": "Simps.Config → Bool",
  "name": "Simps.Config.debug",
  "kind": "def",
  "doc_string":
  "Output debug messages. Not used much, use `set_option simps.debug true` instead. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  {D : Type u₂} → [inst : CategoryTheory.Category C] → [inst_1 : CategoryTheory.Category D] → C ⥤ D → Set D",
  "name": "CategoryTheory.Functor.essImage",
  "kind": "def",
  "doc_string":
  "The essential image of a functor `F` consists of those objects in the target category which are\nisomorphic to an object in the image of the function `F.obj`. In other words, this is the closure\nunder isomorphism of the function `F.obj`.\nThis is the \"non-evil\" way of describing the image of a functor.\n",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → {γ : Sort u_3} → (α → γ) → (α → β) → Prop",
  "name": "Function.FactorsThrough",
  "kind": "def",
  "doc_string": "g factors through f : `f a = f b → g a = g b` ",
  "args": ""},
 {"type": "Prop → Prop",
  "name": "Not",
  "kind": "def",
  "doc_string":
  "`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,\nso if your goal is `¬p` you can use `intro h` to turn the goal into\n`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
  "args": ""},
 {"type":
  "∀ {γ : Type w} [inst : SemilatticeSup γ] {s t : Set γ}, BddAbove s → BddAbove t → BddAbove (s ∪ t)",
  "name": "BddAbove.union",
  "kind": "theorem",
  "doc_string":
  "If `s` and `t` are bounded above sets in a `semilattice_sup`, then so is `s ∪ t`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α},\n  a < 1 → b < 1 → a * b < 1",
  "name": "Right.mul_lt_one",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : Semifield α] (n : ℕ) (a : α),\n  Semifield.zpow (Int.negSucc n) a = (Semifield.zpow (↑(Nat.succ n)) a)⁻¹",
  "name": "Semifield.zpow_neg'",
  "kind": "def",
  "doc_string": "`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` ",
  "args": ""},
 {"type": "Type u → (Type u → Type v) → Type v",
  "name": "MonadReaderOf",
  "kind": "inductive",
  "doc_string":
  "An implementation of Haskell's [`MonadReader`] (sans functional dependency; see also `MonadReader`\nin this module). It does not contain `local` because this\nfunction cannot be lifted using `monadLift`. `local` is instead provided by\nthe `MonadWithReader` class as `withReader`.\n\nNote: This class can be seen as a simplification of the more \"principled\" definition\n```\nclass MonadReaderOf (ρ : Type u) (n : Type u → Type u) where\n  lift {α : Type u} : ({m : Type u → Type u} → [Monad m] → ReaderT ρ m α) → n α\n```\n\n  [`MonadReader`]: https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader\n",
  "args": ""},
 {"type": "∀ {a b c : ℤ}, a ∣ b * c → Int.gcd a b = 1 → a ∣ c",
  "name": "Int.dvd_of_dvd_mul_right_of_gcd_one",
  "kind": "theorem",
  "doc_string":
  "Euclid's lemma: if `a ∣ b * c` and `gcd a b = 1` then `a ∣ c`.\nCompare with `IsCoprime.dvd_of_dvd_mul_right` and\n`UniqueFactorizationMonoid.dvd_of_dvd_mul_right_of_no_prime_factors` ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : AddCommMonoid α] → ℕ → α → α → α",
  "name": "Mathlib.Tactic.Abel.term",
  "kind": "def",
  "doc_string":
  "A type synonym used by `abel` to represent `n • x + a` in an additive commutative monoid. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Sort u_2} [inst : ConditionallyCompleteLattice α] {f g : ι → α},\n  BddBelow (Set.range f) → (∀ (x : ι), f x ≤ g x) → infᵢ f ≤ infᵢ g",
  "name": "cinfᵢ_mono",
  "kind": "theorem",
  "doc_string":
  "The indexed infimum of two functions are comparable if the functions are pointwise comparable",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ b → a ⊔ b = b",
  "name": "sup_of_le_right",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `sup_eq_right`.",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "name": "Eq.le",
  "kind": "theorem",
  "doc_string": "**Alias** of `le_of_eq`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : LinearOrder β] {f g : α → β} {s : Set α},\n  MonotoneOn f s → MonotoneOn g s → MonotoneOn (fun x => min (f x) (g x)) s",
  "name": "MonotoneOn.min",
  "kind": "theorem",
  "doc_string":
  "Pointwise minimum of two monotone functions is a monotone function. ",
  "args": ""},
 {"type": "Type (u + 1)",
  "name": "CategoryTheory.RelCat",
  "kind": "def",
  "doc_string":
  "A type synonym for `Type`, which carries the category instance for which\nmorphisms are binary relations. ",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} →\n  {α : Type u_3} →\n    {β : Type u_1} → [inst : Monad m] → (α → β → m (ForInStep β)) → List α → ForInStep β → m (ForInStep β)",
  "name": "ForInStep.bindList",
  "kind": "def",
  "doc_string":
  "Applies function `f` to each element of a list to accumulate a `ForInStep` value. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "rawNatLit",
  "kind": "def",
  "doc_string":
  "The `nat_lit n` macro constructs \"raw numeric literals\". This corresponds to the\n`Expr.lit (.natVal n)` constructor in the `Expr` data type.\n\nNormally, when you write a numeral like `#check 37`, the parser turns this into\nan application of `OfNat.ofNat` to the raw literal `37` to cast it into the\ntarget type, even if this type is `Nat` (so the cast is the identity function).\nBut sometimes it is necessary to talk about the raw numeral directly,\nespecially when proving properties about the `ofNat` function itself.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] →\n        (f : M →* N) → (g : N →* M) → MonoidHom.comp g f = MonoidHom.id M → MonoidHom.comp f g = MonoidHom.id N → M ≃* N",
  "name": "MonoidHom.toMulEquiv",
  "kind": "def",
  "doc_string":
  "Given a pair of monoid homomorphisms `f`, `g` such that `g.comp f = id` and `f.comp g = id`,\nreturns an multiplicative equivalence with `toFun = f` and `invFun = g`.  This constructor is\nuseful if the underlying type(s) have specialized `ext` lemmas for monoid homomorphisms. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Preorder α] →\n    {ι : Type u_2} →\n      {π : ι → Type u_3} → [inst_1 : (i : ι) → Preorder (π i)] → ((i : ι) → α →o π i) → α →o (i : ι) → π i",
  "name": "OrderHom.pi",
  "kind": "def",
  "doc_string":
  "Construct a bundled monotone map `α →o Π i, π i` from a family of monotone maps\n`f i : α →o π i`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : DecidableEq α] → List α → List α → List α",
  "name": "List.inter",
  "kind": "def",
  "doc_string":
  "Constructs the intersection of two lists, by filtering the elements of `l₁` that are in `l₂`.\nUnlike `bagInter` this does not preserve multiplicity: `[1, 1].inter [1]` is `[1, 1]`.\n",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : LinearOrderedSemifield α], 0⁻¹ = 0",
  "name": "LinearOrderedSemifield.inv_zero",
  "kind": "def",
  "doc_string": "The inverse of `0` in a group with zero is `0`. ",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} {p₂ : α → Prop} {α_1 : Type u_1} {q : α_1 → Prop} {f : m (α → α_1)}\n  [inst : Applicative m] [inst_1 : LawfulApplicative m] {x : m α},\n  SatisfiesM (fun f => ∀ {a : α}, p₂ a → q (f a)) f → SatisfiesM p₂ x → SatisfiesM q (Seq.seq f fun x_1 => x)",
  "name": "SatisfiesM.seq_pre",
  "kind": "theorem",
  "doc_string":
  "`SatisfiesM` distributes over `<*>`, weakest precondition version 1.\n(Use this when `x` and the goal are known and `f` is a subgoal.)\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_≠_»",
  "kind": "def",
  "doc_string":
  "`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → M ≃* N → M ≃ N",
  "name": "MulEquiv.toEquiv",
  "kind": "def",
  "doc_string": "The `Equiv` underlying a `MulEquiv`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Thunk",
  "kind": "inductive",
  "doc_string":
  "Thunks are \"lazy\" values that are evaluated when first accessed using `Thunk.get/map/bind`.\nThe value is then stored and not recomputed for all further accesses. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Tactic.NormCast.tacticRw_mod_cast____",
  "kind": "def",
  "doc_string":
  "Rewrite with the given rules and normalize casts between steps.\n",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Ring α] → Type u_1",
  "name": "Ring.TotalPositiveCone",
  "kind": "inductive",
  "doc_string":
  "A total positive cone in a nontrivial ring induces a linear order. ",
  "args": ""},
 {"type":
  "IO.Ref Mathlib.Tactic.Ring.State →\n  Mathlib.Tactic.RingNF.Config → Mathlib.Tactic.RingNF.Context → Mathlib.Tactic.Ring.Context",
  "name": "Mathlib.Tactic.RingNF.M.run.rctx",
  "kind": "opaque",
  "doc_string": "The recursive context. ",
  "args": ""},
 {"type": "∀ {M₀ : Type u} [self : MulZeroOneClass M₀] (a : M₀), 0 * a = 0",
  "name": "MulZeroOneClass.zero_mul",
  "kind": "def",
  "doc_string": "Zero is a left absorbing element for multiplication ",
  "args": ""},
 {"type": "{a b : Prop} → {α : Sort u_1} → (a → b → α) → a ∧ b → α",
  "name": "And.elim",
  "kind": "def",
  "doc_string": "Non-dependent eliminator for `And`. ",
  "args": ""},
 {"type":
  "{G : Type u_1} → [inst : GroupWithZero G] → (a : G) → a ≠ 0 → Equiv.Perm G",
  "name": "Equiv.mulLeft₀",
  "kind": "def",
  "doc_string":
  "Left multiplication by a nonzero element in a `GroupWithZero` is a permutation of the\nunderlying type. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : NonUnitalCommRing α] {b c x : α},\n  x * x - b * x + c = 0 → ∃ y, y * y - b * y + c = 0 ∧ x + y = b ∧ x * y = c",
  "name": "vieta_formula_quadratic",
  "kind": "theorem",
  "doc_string":
  "Vieta's formula for a quadratic equation, relating the coefficients of the polynomial with\nits roots. This particular version states that if we have a root `x` of a monic quadratic\npolynomial, then there is another root `y` such that `x + y` is negative the `a_1` coefficient\nand `x * y` is the `a_0` coefficient. ",
  "args": ""},
 {"type":
  "{F : Type u_1} →\n  {α : Type u_2} → {β : Type u_3} → {x : LE α} → {x_1 : LE β} → [inst : OrderIsoClass F α β] → CoeTC F (α ≃o β)",
  "name": "instCoeTCOrderIso",
  "kind": "def",
  "doc_string":
  "Any type satisfying `OrderIsoClass` can be cast into `OrderIso` via\n`OrderIsoClass.toOrderIso`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Mul β] [inst_1 : SMul α β] [inst_2 : IsScalarTower α β β] (r : α) (x y : β),\n  r • x * y = r • (x * y)",
  "name": "smul_mul_assoc",
  "kind": "theorem",
  "doc_string":
  "Note that the `IsScalarTower α β β` typeclass argument is usually satisfied by `Algebra α β`.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : MulOneClass M] →\n    {N : Type u_2} →\n      {S : Type u_3} →\n        [inst_1 : MulOneClass N] →\n          [inst_2 : SetLike S M] → [inst_3 : SubmonoidClass S M] → (M →* N) → (s : S) → { x // x ∈ s } →* N",
  "name": "MonoidHom.restrict",
  "kind": "def",
  "doc_string": "Restriction of a monoid hom to a submonoid of the domain. ",
  "args": ""},
 {"type": "∀ {a b c : Prop}, a ∧ b ∧ c → b ∧ c ∧ a",
  "name": "And.rotate",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `and_rotate`.",
  "args": ""},
 {"type": "{α : Type u} → Equiv.Perm α ≃* (Function.End α)ˣ",
  "name": "Equiv.Perm.equivUnitsEnd",
  "kind": "def",
  "doc_string":
  "The permutation of a type is equivalent to the units group of the endomorphisms monoid of this\ntype. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : MulOneClass M] → {S T : Submonoid M} → S = T → { x // x ∈ S } ≃* { x // x ∈ T }",
  "name": "MulEquiv.submonoidCongr",
  "kind": "def",
  "doc_string":
  "Makes the identity isomorphism from a proof that two submonoids of a multiplicative\nmonoid are equal. ",
  "args": ""},
 {"type": "ℕ+ → ℕ+ → ℕ",
  "name": "PNat.div",
  "kind": "def",
  "doc_string":
  "We define `m / k` in the same way as for `ℕ` except that when `m = n * k` we take\n`m / k = n - 1`. This ensures that `m = (m % k) + k * (m / k)` in all cases. Later we\ndefine a function `div_exact` which gives the usual `m / k` in the case where `k` divides `m`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α",
  "name": "List.swapFirstTwo",
  "kind": "def",
  "doc_string": "Swap the first two elements of a list ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ 0 → b ≤ 0 → a + b ≤ 0",
  "name": "Left.add_nonpos",
  "kind": "theorem",
  "doc_string":
  "Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_nonpos`.",
  "args": ""},
 {"type": "Lean.Environment → Lean.Name → Bool",
  "name": "hasSimpAttribute",
  "kind": "def",
  "doc_string":
  "Tests whether `declName` has the `@[simp]` attribute in `env`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → (β : α → Sort u_2) → (i : α) ×' β i ≃ (i : PLift α) × PLift (β i.down)",
  "name": "Equiv.psigmaEquivSigmaPLift",
  "kind": "def",
  "doc_string":
  "A `PSigma`-type is equivalent to the corresponding `Sigma`-type. ",
  "args": ""},
 {"type": "∀ {M : Type u} [self : MulOneClass M] (a : M), 1 * a = a",
  "name": "MulOneClass.one_mul",
  "kind": "def",
  "doc_string": "One is a left neutral element for multiplication ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  0 ≤ a → 0 < b → 0 < a + b",
  "name": "Right.add_pos_of_nonneg_of_pos",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos_of_nonneg_of_pos`.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → {F : Type u_3} → [inst : Mul M] → [inst_1 : Mul N] → [inst_2 : MulHomClass F M N] → F → M →ₙ* N",
  "name": "MulHomClass.toMulHom",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `MulHomClass F M N` into an actual\n`MulHom`. This is declared as the default coercion from `F` to `M →ₙ* N`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddSemigroup α] (x y : α), ((fun x_1 => x_1 + x) ∘ fun x => x + y) = fun x_1 => x_1 + (y + x)",
  "name": "comp_add_right",
  "kind": "theorem",
  "doc_string":
  "Composing two additions on the right by `y` and `x`\nis equal to a addition on the right by `y + x`.",
  "args": ""},
 {"type": "(α : Type u_1) → (β : Type u_2) → [inst : Add β] → AddHom β (α → β)",
  "name": "Pi.constAddHom",
  "kind": "def",
  "doc_string": "`Function.const` as an `AddHom`.",
  "args": ""},
 {"type": "(k : ℕ) → {n : ℕ} → Fin2 n → Fin2 (k + n)",
  "name": "Fin2.left",
  "kind": "def",
  "doc_string": "`left k` is the embedding `Fin2 n → Fin2 (k + n)` ",
  "args": ""},
 {"type":
  "∀ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : Zero M] [inst_1 : Zero N] [inst_2 : Zero P]\n  [inst_3 : Zero Q] (f : ZeroHom M N) (g : ZeroHom N P) (h : ZeroHom P Q),\n  ZeroHom.comp (ZeroHom.comp h g) f = ZeroHom.comp h (ZeroHom.comp g f)",
  "name": "ZeroHom.comp_assoc",
  "kind": "theorem",
  "doc_string": "Composition of additive monoid homomorphisms is associative.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → { f // Disjoint (Set.range ↑f.fst) (Set.range ↑f.snd) } ≃ (f : α ↪ γ) × (β ↪ ↑(Set.range ↑fᶜ))",
  "name": "Equiv.prodEmbeddingDisjointEquivSigmaEmbeddingRestricted",
  "kind": "def",
  "doc_string":
  "Pairs of embeddings with disjoint ranges are equivalent to a dependent sum of embeddings,\nin which the second embedding cannot take values in the range of the first. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : GroupWithZero α] → {a : α} → [inst_1 : Invertible a] → Invertible a⁻¹",
  "name": "invertibleInv",
  "kind": "def",
  "doc_string": "`a` is the inverse of `a⁻¹` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : α → Type u_2} → ((a : α) → Equiv.Perm (β a)) → Equiv.Perm ((a : α) × β a)",
  "name": "Equiv.Perm.sigmaCongrRight",
  "kind": "def",
  "doc_string":
  "A family of permutations `Π a, Perm (β a)` generates a permuation `Perm (Σ a, β₁ a)`. ",
  "args": ""},
 {"type": "ℤ → ℤ",
  "name": "Int.sign",
  "kind": "def",
  "doc_string":
  "Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : α → Sort v} → [inst : DecidableEq α] → ((a : α) → β a) → (a' : α) → β a' → (a : α) → β a",
  "name": "Function.update",
  "kind": "def",
  "doc_string":
  "Replacing the value of a function at a given point by a given value. ",
  "args": ""},
 {"type":
  "Lean.Meta.Simp.Context → optParam Bool true → Lean.Expr → Lean.Meta.SimpM (Option Lean.Expr)",
  "name": "Mathlib.Meta.NormNum.discharge",
  "kind": "opaque",
  "doc_string": "A discharger which calls `norm_num`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Monoid M] →\n      [inst_1 : Monoid N] →\n        (R : Type v) → [inst_2 : Semiring R] → (N →* M) → [inst : MulSemiringAction M R] → MulSemiringAction N R",
  "name": "MulSemiringAction.compHom",
  "kind": "def",
  "doc_string":
  "Compose a `MulSemiringAction` with a `MonoidHom`, with action `f r' • m`.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_2} {H : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : OrderedAddCommGroup H] {f : G → H},\n  (∀ (x : G), f (-x) = -f x) → MonotoneOn f (Set.Ici 0) → Monotone f",
  "name": "monotone_of_odd_of_monotone_on_nonneg",
  "kind": "theorem",
  "doc_string":
  "An odd function on a linear ordered additive commutative group is monotone on the whole group\nprovided that it is monotone on `Set.Ici 0`. ",
  "args": ""},
 {"type":
  "∀ {I : Type u_1} {f : I → Type u_2} [inst : Inhabited I] [inst_1 : ∀ (i : I), Nonempty (f i)]\n  [inst : Nontrivial (f default)], Nontrivial ((i : I) → f i)",
  "name": "Pi.nontrivial",
  "kind": "def",
  "doc_string":
  "As a convenience, provide an instance automatically if `(f default)` is nontrivial.\n\nIf a different index has the non-trivial type, then use `haveI := nontrivial_at that_index`.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsLeftRegular (a * b) → IsLeftRegular b",
  "name": "IsLeftRegular.of_mul",
  "kind": "theorem",
  "doc_string":
  "If an element `b` becomes left-regular after multiplying it on the left by a left-regular\nelement, then `b` is left-regular. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "name": "Covariant",
  "kind": "def",
  "doc_string":
  "`Covariant` is useful to formulate succintly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `CovariantClass` doc-string for its meaning. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α}, a < 1 → b < 1 → a * b < 1",
  "name": "mul_lt_one",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.mul_lt_one`.",
  "args": ""},
 {"type": "∀ (u : ℤˣ), u ^ 2 = 1",
  "name": "Int.units_pow_two",
  "kind": "theorem",
  "doc_string": "**Alias** of `Int.units_sq`.",
  "args": ""},
 {"type": "ℤ ≃ ℕ ⊕ ℕ",
  "name": "Equiv.intEquivNatSumNat",
  "kind": "def",
  "doc_string": "The type of integer numbers is equivalent to `ℕ ⊕ ℕ`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a = b ∨ a < b",
  "name": "LE.le.eq_or_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of `eq_or_lt_of_le`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LT α] [inst_1 : WellFoundedGT α] (a : α), Acc (fun x x_1 => x > x_1) a",
  "name": "WellFoundedGT.apply",
  "kind": "theorem",
  "doc_string": "All values are accessible under the well-founded `>`. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : AddZeroClass M] → HasInf (AddSubmonoid M)",
  "name": "AddSubmonoid.instHasInfAddSubmonoid",
  "kind": "def",
  "doc_string": "The inf of two `AddSubmonoid`s is their intersection.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {f g : β → α},\n  Monotone f → StrictMono g → StrictMono fun x => f x + g x",
  "name": "Monotone.add_strict_mono",
  "kind": "theorem",
  "doc_string":
  "The sum of a monotone function and a strictly monotone function is\nstrictly monotone.",
  "args": ""},
 {"type": "∀ {G : Type u} [self : DivInvMonoid G] (a b : G), a / b = a * b⁻¹",
  "name": "DivInvMonoid.div_eq_mul_inv",
  "kind": "def",
  "doc_string": "`a / b := a * b⁻¹` ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Sub",
  "kind": "inductive",
  "doc_string":
  "The homogeneous version of `HSub`: `a - b : α` where `a b : α`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), AddSubmonoid.closure ↑S = S",
  "name": "AddSubmonoid.closure_eq",
  "kind": "theorem",
  "doc_string": "Additive closure of an additive submonoid `S` equals `S`",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → α ≃ β → [inst : DecidableEq β] → DecidableEq α",
  "name": "Equiv.decidableEq",
  "kind": "def",
  "doc_string": "Transfer `DecidableEq` across an equivalence. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), ↑f (a * b⁻¹) = ↑f a * (↑f b)⁻¹",
  "name": "map_mul_inv",
  "kind": "theorem",
  "doc_string": "Group homomorphisms preserve division. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  [inst : Monoid R] → {S : Submonoid R} → [self : OreLocalization.OreSet S] → R → { x // x ∈ S } → { x // x ∈ S }",
  "name": "OreLocalization.OreSet.oreDenom",
  "kind": "def",
  "doc_string": "The Ore denominator of a fraction. ",
  "args": ""},
 {"type": "Prop → Prop → Prop",
  "name": "Iff",
  "kind": "inductive",
  "doc_string":
  "If and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → ℕ",
  "name": "List.findIdx",
  "kind": "def",
  "doc_string":
  "Returns the index of the first element satisfying `p`, or the length of the list otherwise. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → ∀ {s : Set α}, BddAbove s → BddAbove (f '' s)",
  "name": "Monotone.map_bddAbove",
  "kind": "theorem",
  "doc_string":
  "The image under a monotone function of a set which is bounded above is bounded above. See also\n`bdd_above.image2`. ",
  "args": ""},
 {"type": "(R : Type u_1) → [inst : Mul R] → [inst : Add R] → Type u_1",
  "name": "RingAut",
  "kind": "def",
  "doc_string": "The group of ring automorphisms. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Mul α] → [inst_1 : Mul β] → (α →ₙ* β) → WithOne α →* WithOne β",
  "name": "WithOne.map",
  "kind": "def",
  "doc_string":
  "Given a multiplicative map from `α → β` returns a monoid homomorphism\nfrom `WithOne α` to `WithOne β` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : PartialOrder α] → (c : ClosureOperator α) → α → ↑(ClosureOperator.closed c)",
  "name": "ClosureOperator.toClosed",
  "kind": "def",
  "doc_string":
  "Send an `x` to an element of the set of closed elements (by taking the closure). ",
  "args": ""},
 {"type": "Mathlib.Meta.NormNum.NormNumExt",
  "name": "Mathlib.Meta.NormNum.evalIntCast",
  "kind": "def",
  "doc_string":
  "The `norm_num` extension which identifies an expression `Int.cast n`, returning `n`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Inhabited α] → ℕ → List α → List α",
  "name": "List.takeI",
  "kind": "def",
  "doc_string":
  "\"Inhabited\" `take` function: Take `n` elements from a list `l`. If `l` has less than `n`\nelements, append `n - length l` elements `default`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {P : α → Prop}, Antitone fun s => ∀ (x : α), x ∈ s → P x",
  "name": "Set.antitone_bforall",
  "kind": "theorem",
  "doc_string": "Quantifying over a set is antitone in the set ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → M × N ≃+ N × M",
  "name": "AddEquiv.prodComm",
  "kind": "def",
  "doc_string":
  "The equivalence between `M × N` and `N × M` given by swapping the\ncomponents is additive.",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α → ℕ → Array α → List α × List α",
  "name": "List.splitAt.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `splitAt`: `splitAt.go l n xs acc = (acc.toList ++ take n xs, drop n xs)`\nif `n < length xs`, else `(l, [])`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  (A : Type u_2) → [inst : Monoid M] → [inst_1 : AddMonoid A] → [inst : DistribMulAction M A] → M → A →+ A",
  "name": "DistribMulAction.toAddMonoidHom",
  "kind": "def",
  "doc_string":
  "Each element of the monoid defines a additive monoid homomorphism. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (f : α ↪ β) → (s : β → β → Prop) → ↑f ⁻¹'o s ↪r s",
  "name": "RelEmbedding.preimage",
  "kind": "def",
  "doc_string":
  "If `f` is injective, then it is a relation embedding from the\npreimage relation of `s` to `s`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → Aesop.UnorderedArraySet α → ℕ",
  "name": "Aesop.UnorderedArraySet.size",
  "kind": "def",
  "doc_string": "O(1) ",
  "args": ""},
 {"type": "Linarith.GlobalPreprocessor → String",
  "name": "Linarith.GlobalPreprocessor.name",
  "kind": "def",
  "doc_string": "The name of the global preprocessor, used in trace output. ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.AbelNF.Config →\n  Lean.Meta.Simp.Context →\n    (Lean.Meta.Simp.Result → Lean.Meta.SimpM Lean.Meta.Simp.Result) →\n      Bool → Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "name": "Mathlib.Tactic.Abel.abelNFCore.go",
  "kind": "opaque",
  "doc_string":
  "The recursive case of `abelNF`.\n* `root`: true when the function is called directly from `abelNFCore`\n  and false when called by `evalAtom` in recursive mode.\n* `parent`: The input expression to simplify. In `pre` we make use of both `parent` and `e`\n  to determine if we are at the top level in order to prevent a loop\n  `go -> eval -> evalAtom -> go` which makes no progress.\n",
  "args": ""},
 {"type": "{α : Type u_1} → Option α → List α",
  "name": "Option.toList",
  "kind": "def",
  "doc_string":
  "Cast of `Option` to `List`. Returns `[a]` if the input is `some a`, and `[]` if it is `none`.\n",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : LT α] → [inst : WellFoundedLT α] → WellFoundedRelation α",
  "name": "WellFoundedLT.toWellFoundedRelation",
  "kind": "def",
  "doc_string":
  "Derive a `WellFoundedRelation` instance from a `WellFoundedLT` instance. ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Monoid M] → Submonoid M",
  "name": "Submonoid.center",
  "kind": "def",
  "doc_string":
  "The center of a monoid `M` is the set of elements that commute with everything in `M` ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.normNum1Conv",
  "kind": "def",
  "doc_string": "Basic version of `norm_num` that does not call `simp`. ",
  "args": ""},
 {"type": "∀ {G : Type u_1} [inst : Group G], MulAction.IsPretransitive G G",
  "name": "MulAction.Regular.isPretransitive",
  "kind": "def",
  "doc_string": "The regular action of a group on itself is transitive. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_<|>_»",
  "kind": "def",
  "doc_string":
  "`a <|> b` executes `a` and returns the result, unless it fails in which\ncase it executes and returns `b`. Because `b` is not always executed, it\nis passed as a thunk so it can be forced only when needed.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : NonAssocSemiring α] → [inst : NonAssocSemiring β] → Type (max u_1 u_2)",
  "name": "RingHom",
  "kind": "inductive",
  "doc_string":
  "Bundled semiring homomorphisms; use this for bundled ring homomorphisms too.\n\nThis extends from both `MonoidHom` and `MonoidWithZeroHom` in order to put the fields in a\nsensible order, even though `MonoidWithZeroHom` already extends `MonoidHom`. ",
  "args": ""},
 {"type": "Type u → (Type u → Type v) → Type (max (u + 1) v)",
  "name": "MonadWithReaderOf",
  "kind": "inductive",
  "doc_string":
  "`MonadWithReaderOf ρ` adds the operation `withReader : (ρ → ρ) → m α → m α`.\nThis runs the inner `x : m α` inside a modified context after applying the\nfunction `f : ρ → ρ`. In addition to `ReaderT` itself, this operation lifts\nover most monad transformers, so it allows us to apply `withReader` to monads\ndeeper in the stack.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : CommRing R] {x₁ x₂ y₁ y₂ n : R},\n  (x₁ ^ 2 + n * x₂ ^ 2) * (y₁ ^ 2 + n * y₂ ^ 2) = (x₁ * y₁ - n * x₂ * y₂) ^ 2 + n * (x₁ * y₂ + x₂ * y₁) ^ 2",
  "name": "sq_add_mul_sq_mul_sq_add_mul_sq",
  "kind": "theorem",
  "doc_string":
  "Brahmagupta's identity, see <https://en.wikipedia.org/wiki/Brahmagupta%27s_identity>\n",
  "args": ""},
 {"type": "Type → Type",
  "name": "Linarith.LinarithM",
  "kind": "def",
  "doc_string":
  "The linarith monad extends an exceptional monad with a `LinarithData` state.\nAn exception produces a contradictory `PComp`.\n",
  "args": ""},
 {"type": "(α : Type u_1) → α ≃. α",
  "name": "PEquiv.refl",
  "kind": "def",
  "doc_string": "The identity map as a partial equivalence. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β₁ : α → Sort u_2} → {β₂ : α → Sort u_3} → ((a : α) → β₁ a ≃ β₂ a) → ((a : α) → β₁ a) ≃ ((a : α) → β₂ a)",
  "name": "Equiv.piCongrRight",
  "kind": "def",
  "doc_string":
  "A family of equivalences `∀ a, β₁ a ≃ β₂ a` generates an equivalence between `∀ a, β₁ a` and\n`∀ a, β₂ a`. ",
  "args": ""},
 {"type": "(α : Sort u_1) → (PEmpty → α) ≃ PUnit",
  "name": "Equiv.pemptyArrowEquivPUnit",
  "kind": "def",
  "doc_string": "The sort of maps from `PEmpty` is equivalent to `PUnit`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  StrictMonoOn f s → StrictAntiOn (f ∘ ↑OrderDual.ofDual) s",
  "name": "StrictMonoOn.dual_left",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `strictAntiOn_comp_ofDual_iff`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrder α] →\n      [inst_1 : Preorder β] → (f : α → β) → StrictMono f → (g : β → α) → Function.RightInverse g f → α ≃o β",
  "name": "StrictMono.orderIsoOfRightInverse",
  "kind": "def",
  "doc_string":
  "A strictly monotone function with a right inverse is an order isomorphism. ",
  "args": ""},
 {"type": "{α : Type u_1} → α → Part α → Prop",
  "name": "Part.Mem",
  "kind": "def",
  "doc_string": "`a ∈ o` means that `o` is defined and equal to `a` ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → Q(CommSemiring «$α») → Q(«$α») → Type",
  "name": "Mathlib.Tactic.Ring.Overlap",
  "kind": "inductive",
  "doc_string":
  "Two monomials are said to \"overlap\" if they differ by a constant factor, in which case the\nconstants just add. When this happens, the constant may be either zero (if the monomials cancel)\nor nonzero (if they add up); the zero case is handled specially.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : DecidableEq α] → [inst : LE α] → [inst_1 : BoundedOrder α] → [inst : IsSimpleOrder α] → α ≃ Bool",
  "name": "IsSimpleOrder.equivBool",
  "kind": "def",
  "doc_string":
  "Every simple lattice is isomorphic to `Bool`, regardless of order. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] {f g : AddHom M N}, f = g → ∀ (x : M), ↑f x = ↑g x",
  "name": "AddHom.congr_fun",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.congr_fun` instead.",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.AbelNF.Config → Mathlib.Tactic.Abel.AbelMode",
  "name": "Mathlib.Tactic.Abel.AbelNF.Config.mode",
  "kind": "def",
  "doc_string": "The normalization style. ",
  "args": ""},
 {"type": "(α : Sort u_1) → α ≃ α",
  "name": "Equiv.refl",
  "kind": "def",
  "doc_string": "Any type is equivalent to itself. ",
  "args": ""},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [self : MonadStateOf σ m] → σ → m PUnit",
  "name": "MonadStateOf.set",
  "kind": "def",
  "doc_string": "`set (s : σ)` replaces the state with value `s`. ",
  "args": ""},
 {"type":
  "(p : Prop) →\n  [inst : SlimCheck.Testable p] →\n    optParam SlimCheck.Configuration\n        { numInst := 100, maxSize := 100, numRetries := 10, traceDiscarded := false, traceSuccesses := false,\n          traceShrink := false, traceShrinkCandidates := false, randomSeed := none, quiet := false } →\n      Rand (SlimCheck.TestResult p)",
  "name": "SlimCheck.Testable.runSuite",
  "kind": "def",
  "doc_string": "Try to find a counter-example of `p`. ",
  "args": ""},
 {"type":
  "Linarith.Ineq → Lean.Expr → Lean.Expr → ℕ → Lean.MetaM (Linarith.Ineq × Lean.Expr)",
  "name": "Linarith.mkLTZeroProof.step",
  "kind": "def",
  "doc_string":
  "`step c pf npf coeff` assumes that `pf` is a proof of `t1 R1 0` and `npf` is a proof\nof `t2 R2 0`. It uses `mkSingleCompZeroOf` to prove `t1 + coeff*t2 R 0`, and returns `R`\nalong with this proof.\n",
  "args": ""},
 {"type": "{R : Type u} → [self : EuclideanDomain R] → R → R → R",
  "name": "EuclideanDomain.quotient",
  "kind": "def",
  "doc_string":
  "A division function (denoted `/`) on `R`.\nThis satisfies the property `b * (a / b) + a % b = a`, where `%` denotes `remainder`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} → [inst : PartialOrder β] → [inst_1 : CompleteLattice α] → GaloisInsertion l u → CompleteLattice β",
  "name": "GaloisInsertion.liftCompleteLattice",
  "kind": "def",
  "doc_string": "Lift all suprema and infima along a Galois insertion ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LE α] → Flag α → Set α",
  "name": "Flag.carrier",
  "kind": "def",
  "doc_string": "The `carrier` of a flag is the underlying set. ",
  "args": ""},
 {"type": "∀ {n k : ℕ}, n < k → Nat.descFactorial n k = 0",
  "name": "Nat.descFactorial_of_lt",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Nat.descFactorial_eq_zero_iff_lt`.",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : MulOneClass M] → Set M → Submonoid M",
  "name": "Submonoid.closure",
  "kind": "def",
  "doc_string": "The `Submonoid` generated by a set. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Sort u_2} {γ : Sort u_3} {s : Set α} (e : β ≃ ↑s) (v : β → γ) (w : α → γ) (j : β) (x : γ)\n  [inst : DecidableEq β] [inst_1 : DecidableEq α] [inst_2 : (j : α) → Decidable (j ∈ s)],\n  (fun i => if h : i ∈ s then Function.update v j x (↑(Equiv.symm e) { val := i, property := h }) else w i) =\n    Function.update (fun i => if h : i ∈ s then v (↑(Equiv.symm e) { val := i, property := h }) else w i) (↑(↑e j)) x",
  "name": "dite_comp_equiv_update",
  "kind": "theorem",
  "doc_string":
  "The composition of an updated function with an equiv on a subset can be expressed as an\nupdated function. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  AntitoneOn f s → MonotoneOn (↑OrderDual.toDual ∘ f) s",
  "name": "AntitoneOn.dual_right",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `monotoneOn_toDual_comp_iff`.",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«stx_+»",
  "kind": "def",
  "doc_string":
  "`p+` is shorthand for `many1(p)`. It uses parser `p` 1 or more times, and produces a\n`nullNode` containing the array of parsed results. This parser has arity 1.\n\nIf `p` has arity more than 1, it is auto-grouped in the items generated by the parser.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {π : α → Type u_2} → (s : Set α) → ((a : α) → π a) → (a : ↑s) → π ↑a",
  "name": "Set.restrict",
  "kind": "def",
  "doc_string":
  "Restrict domain of a function `f` to a set `s`. Same as `Subtype.restrict` but this version\ntakes an argument `↥s` instead of `Subtype s`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : NonUnitalNonAssocSemiring β] → β →ₙ+* α → β",
  "name": "Pi.constNonUnitalRingHom",
  "kind": "def",
  "doc_string": "`Function.const` as a `NonUnitalRingHom`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α → ℕ → Array α → List α",
  "name": "List.removeNthTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `removeNthTR`:\n`removeNthTR.go l xs n acc = acc.toList ++ removeNth xs n` if `n < length xs`, else `l`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "CategoryTheory.«term_≅_»",
  "kind": "def",
  "doc_string": "Notation for an isomorphism in a category. ",
  "args": ""},
 {"type": "{C : Type u} → [inst : CategoryTheory.Category C] → (X : C) → X ≅ X",
  "name": "CategoryTheory.Iso.refl",
  "kind": "def",
  "doc_string": "Identity isomorphism. ",
  "args": ""},
 {"type":
  "∀ {I : Type u} {β : Type u_1} [inst : DecidableEq I] [inst_1 : One β] (i : I) (x : β) (i' : I),\n  Pi.mulSingle i x i' = Pi.mulSingle i' x i",
  "name": "Pi.mulSingle_comm",
  "kind": "theorem",
  "doc_string":
  "On non-dependent functions, `Pi.mulSingle` is symmetric in the two indices. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {a : α} {n : ℤ}, Even n → n ≠ 0 → a ≠ 0 → 0 < a ^ n",
  "name": "Even.zpow_pos",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `Even.zpow_pos_iff`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] → [inst_2 : AddZeroClass α] → [inst_3 : AddZeroClass β] → (α →+o β) → α →o β",
  "name": "OrderAddMonoidHom.toOrderHom",
  "kind": "def",
  "doc_string":
  "Reinterpret an ordered additive monoid homomorphism as an order homomorphism.",
  "args": ""},
 {"type":
  "{α : Type v} → (P : α → Prop) → (i : α) × ULift (PLift (P i)) ≃ Subtype P",
  "name": "Equiv.sigmaULiftPLiftEquivSubtype",
  "kind": "def",
  "doc_string":
  "A `Sigma` with `λ i, ULift (PLift (P i))` fibers is equivalent to `{ x // P x }`.\nVariant of `sigmaPLiftEquivSubtype`.\n",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Add M] → Set M → AddSubsemigroup M",
  "name": "AddSubsemigroup.closure",
  "kind": "def",
  "doc_string": "The `AddSubsemigroup` generated by a set",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Monoid α] [self : MulAction α β] (x y : α) (b : β), (x * y) • b = x • y • b",
  "name": "MulAction.mul_smul",
  "kind": "def",
  "doc_string": "Associativity of `•` and `*` ",
  "args": ""},
 {"type":
  "∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} [self : CategoryTheory.Epi f] {Z : C}\n  (g h : Y ⟶ Z), f ≫ g = f ≫ h → g = h",
  "name": "CategoryTheory.Epi.left_cancellation",
  "kind": "def",
  "doc_string":
  "A morphism `f` is an epimorphism if it can be cancelled when precomposed. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → Aesop.UnorderedArraySet α → Aesop.UnorderedArraySet α → Aesop.UnorderedArraySet α",
  "name": "Aesop.UnorderedArraySet.merge",
  "kind": "def",
  "doc_string": "O(n*m) ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → PProd α β → β",
  "name": "PProd.snd",
  "kind": "def",
  "doc_string":
  "The second projection out of a pair. if `p : PProd α β` then `p.2 : β`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "name": "List.isSuffix",
  "kind": "def",
  "doc_string":
  "`isSuffix l₁ l₂`, or `l₁ <:+ l₂`, means that `l₁` is a suffix of `l₂`,\nthat is, `l₂` has the form `t ++ l₁` for some `t`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.negSucc n) a = (LinearOrderedSemifield.zpow (↑(Nat.succ n)) a)⁻¹",
  "name": "LinearOrderedSemifield.zpow_neg'",
  "kind": "def",
  "doc_string": "`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` ",
  "args": ""},
 {"type": "{α : Type u} → α → ULift α",
  "name": "ULift.pure",
  "kind": "def",
  "doc_string": "Embedding of pure values. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : SemilatticeInf α] →\n      [inst_1 : SemilatticeInf β] → (f : α → β) → RightOrdContinuous f → Function.Injective f → α ↪o β",
  "name": "RightOrdContinuous.toOrderEmbedding",
  "kind": "def",
  "doc_string":
  "Convert an injective left order continuous function to a `order_embedding`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Unique M] → [inst : Unique N] → [inst : Mul M] → [inst_1 : Mul N] → M ≃* N",
  "name": "MulEquiv.mulEquivOfUnique",
  "kind": "def",
  "doc_string": "The `MulEquiv` between two monoids with a unique element. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {a : R} [inst : Monoid R] (n : ℕ), IsRegular a → IsRegular (a ^ n)",
  "name": "IsRegular.pow",
  "kind": "theorem",
  "doc_string": "Any power of a regular element is regular. ",
  "args": ""},
 {"type":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : LeftDistribClass R] (a b c : R), a * (b + c) = a * b + a * c",
  "name": "mul_add",
  "kind": "theorem",
  "doc_string": "**Alias** of `left_distrib`.",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → Set α → Set α",
  "name": "SuccChain",
  "kind": "def",
  "doc_string":
  "Given a set `s`, if there exists a chain `t` strictly including `s`, then `SuccChain s`\nis one of these chains. Otherwise it is `s`. ",
  "args": ""},
 {"type": "ZNum → ZNum → Num",
  "name": "ZNum.gcd",
  "kind": "def",
  "doc_string": "Greatest Common Divisor (GCD) of two `ZNum`s. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : DecidableEq α] → [inst : DecidableEq β] → α → β → α ≃. β",
  "name": "PEquiv.single",
  "kind": "def",
  "doc_string":
  "Create a `PEquiv` which sends `a` to `b` and `b` to `a`, but is otherwise `none`. ",
  "args": ""},
 {"type": "{α : Type u_1} → ℕ → List α → α → List α",
  "name": "List.takeD",
  "kind": "def",
  "doc_string":
  "Take `n` elements from a list `l`. If `l` has less than `n` elements, append `n - length l`\nelements `x`.\n",
  "args": ""},
 {"type":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} → [inst : Preorder α] → [inst_1 : Preorder β] → [inst_2 : OrderHomClass F α β] → CoeTC F (α →o β)",
  "name": "OrderHomClass.instCoeTCOrderHom",
  "kind": "def",
  "doc_string":
  "Any type satisfying `OrderHomClass` can be cast into `OrderHom` via\n`OrderHomClass.toOrderHom`. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : AddZeroClass M] → AddSubmonoid M → Set M",
  "name": "AddSubmonoid.Simps.coe",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type": "Lean.MVarId → Lean.Name → Lean.Name → Lean.MetaM Unit",
  "name": "Mathlib.Tactic.renameBVarTarget",
  "kind": "def",
  "doc_string": "Renames a bound variable in the target. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [self : CharZero R], Function.Injective Nat.cast",
  "name": "CharZero.cast_injective",
  "kind": "def",
  "doc_string":
  "An additive monoid with one has charateristic zero if the canonical map `ℕ → R` is\ninjective. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    [sa : Setoid α] →\n      [sb : Setoid β] →\n        (f : α → β) → Relator.LiftFun (fun x x_1 => x ≈ x_1) (fun x x_1 => x ≈ x_1) f f → Quotient sa → Quotient sb",
  "name": "Quotient.map",
  "kind": "def",
  "doc_string":
  "Map a function `f : α → β` that sends equivalent elements to equivalent elements\nto a function `Quotient sa → Quotient sb`. Useful to define unary operations on quotients. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "SemilatticeSup",
  "kind": "inductive",
  "doc_string":
  "A `SemilatticeSup` is a join-semilattice, that is, a partial order\nwith a join (a.k.a. lub / least upper bound, sup / supremum) operation\n`⊔` which is the least element larger than both factors. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : LT α] → Prop",
  "name": "WellFoundedGT",
  "kind": "def",
  "doc_string": "A class for a well founded relation `>`. ",
  "args": ""},
 {"type": "DistribLattice Prop",
  "name": "Prop.distribLattice",
  "kind": "def",
  "doc_string": "Propositions form a distributive lattice. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (α → Bool) → List α → Array α → Array (List α) → List (List α)",
  "name": "List.splitOnP.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `splitOnP`: `splitOnP.go xs acc r = r.toList ++ res'`\nwhere `res'` is obtained from `splitOnP P xs` by prepending `acc.toList` to the first element. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : One M₁] →\n        [inst_2 : MulOneClass M₂] →\n          (f : M₁ → M₂) → Function.Injective f → f 1 = 1 → (∀ (x y : M₁), f (x * y) = f x * f y) → MulOneClass M₁",
  "name": "Function.Injective.mulOneClass",
  "kind": "def",
  "doc_string":
  "A type endowed with `1` and `*` is a `MulOneClass`, if it admits an injective map that\npreserves `1` and `*` to a `MulOneClass`.  See note [reducible non-instances]. ",
  "args": ""},
 {"type": "Linarith.Ineq → Lean.Name",
  "name": "Linarith.Ineq.toConstMulName",
  "kind": "def",
  "doc_string":
  "Finds the name of a multiplicative lemma corresponding to an inequality strength. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} (r : α → α → Prop), EqvGen.Setoid r = infₛ { s | ∀ ⦃x y : α⦄, r x y → Setoid.Rel s x y }",
  "name": "Setoid.eqvGen_eq",
  "kind": "theorem",
  "doc_string":
  "The inductively defined equivalence closure of a binary relation r is the infimum\nof the set of all equivalence relations containing r. ",
  "args": ""},
 {"type": "String → String → String",
  "name": "ToAdditive.capitalizeLike",
  "kind": "def",
  "doc_string":
  "Capitalizes `s` char-by-char like `r`. If `s` is longer, it leaves the tail untouched. ",
  "args": ""},
 {"type": "∀ (x : ℤ), ↑(Int.natAbs x ^ 2) = x ^ 2",
  "name": "Int.natAbs_pow_two",
  "kind": "theorem",
  "doc_string": "**Alias** of `Int.natAbs_sq`.",
  "args": ""},
 {"type": "∀ {α : Type u_1} [inst : Add α] {a : α}, Even a → ∃ b, a = bit0 b",
  "name": "Even.exists_bit0",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `even_iff_exists_bit0`.",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} → {α : Type u_3} → {β : Type u_1} → [inst : Monad m] → (α → m β) → List α → m (List β)",
  "name": "List.mapM'",
  "kind": "def",
  "doc_string": "Alternate (non-tail-recursive) form of mapM for proofs. ",
  "args": ""},
 {"type": "Lean.RBMap String (List String) compare",
  "name": "endCapitalNames",
  "kind": "def",
  "doc_string":
  "A set of strings of names that end in a capital letter.\n* If the string contains a lowercase letter, the string should be split between the first occurrence\n  of a lower-case letter followed by a upper-case letter.\n* If multiple strings have the same prefix, they should be grouped by prefix\n* In this case, the second list should be prefix-free\n  (no element can be a prefix of a later element)\n\nTodo: automate the translation from `String` to an element in this `RBMap`\n  (but this would require having something similar to the `rb_lmap` from Lean 3). ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → {γ : Type u_1} → γ → α ⊕ β ⊕ γ",
  "name": "Sum3.in₂",
  "kind": "def",
  "doc_string": "The map from the third summand into a ternary sum. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] {s : Set M} {S : AddSubmonoid M}, AddSubmonoid.closure s ≤ S ↔ s ⊆ ↑S",
  "name": "AddSubmonoid.closure_le",
  "kind": "theorem",
  "doc_string":
  "An additive submonoid `S` includes `closure s` if and only if it includes `s`",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {A : Type u_2} [inst : Zero A] [self : SMulZeroClass M A] (a : M), a • 0 = 0",
  "name": "SMulZeroClass.smul_zero",
  "kind": "def",
  "doc_string": "Multiplying `0` by a scalar gives `0` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : PredOrder α] {a : α}, ¬IsMin a → Order.pred a < a",
  "name": "Order.pred_lt_of_not_isMin",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Order.pred_lt_iff_not_isMin`.",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → Set α → Prop",
  "name": "IsChain",
  "kind": "def",
  "doc_string":
  "A chain is a set `s` satisfying `x ≺ y ∨ x = y ∨ y ≺ x` for all `x y ∈ s`. ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsWellFounded",
  "kind": "inductive",
  "doc_string":
  "A well-founded relation. Not to be confused with `isWellOrder`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {a : α}, 0 < a → 0 < a⁻¹",
  "name": "inv_pos_of_pos",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `inv_pos`.",
  "args": ""},
 {"type":
  "Type u_1 →\n  (α : outParam (Type u_2)) → (β : outParam (Type u_3)) → [inst : LE α] → [inst : LE β] → Type (max (max u_1 u_2) u_3)",
  "name": "OrderIsoClass",
  "kind": "inductive",
  "doc_string":
  "`OrderIsoClass F α β` states that `F` is a type of order isomorphisms.\n\nYou should extend this class when you extend `OrderIso`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Lattice α] → Prop",
  "name": "IsWeakLowerModularLattice",
  "kind": "inductive",
  "doc_string":
  "A weakly lower modular lattice is a lattice where `a` and `b` cover `a ⊓ b` if `a ⊔ b` covers\nboth `a` and `b`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⊕_»",
  "kind": "def",
  "doc_string":
  "`Sum α β`, or `α ⊕ β`, is the disjoint union of types `α` and `β`.\nAn element of `α ⊕ β` is either of the form `.inl a` where `a : α`,\nor `.inr b` where `b : β`.\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_::_»",
  "kind": "def",
  "doc_string":
  "If `a : α` and `l : List α`, then `cons a l`, or `a :: l`, is the\nlist whose first element is `a` and with `l` as the rest of the list. ",
  "args": ""},
 {"type":
  "{β α : Type} →\n  [inst : Inhabited β] →\n    Lean.SimpleScopedEnvExtension α β → (β → Lean.Name → Bool) → Lean.Name → Lean.Name → Lean.Name → Lean.CoreM Unit",
  "name": "ToAdditive.hackyCopyAttr",
  "kind": "def",
  "doc_string":
  "Copy an attribute that stores enough information to test whether a declaration is in it\nin a hacky way.\nTODO: have a proper implementation once we have the infrastructure for this. ",
  "args": ""},
 {"type":
  "Type u_1 →\n  (α : outParam (Type u_2)) →\n    (β : outParam (Type u_3)) →\n      [inst : NonUnitalNonAssocSemiring α] → [inst : NonUnitalNonAssocSemiring β] → Type (max (max u_1 u_2) u_3)",
  "name": "NonUnitalRingHomClass",
  "kind": "inductive",
  "doc_string":
  "`NonUnitalRingHomClass F α β` states that `F` is a type of non-unital (semi)ring\nhomomorphisms. You should extend this class when you extend `NonUnitalRingHom`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} {α : Type u_3} [inst : VAdd M α] [inst_1 : VAdd N α] [self : VAddCommClass M N α]\n  (m : M) (n : N) (a : α), m +ᵥ (n +ᵥ a) = n +ᵥ (m +ᵥ a)",
  "name": "VAddCommClass.vadd_comm",
  "kind": "def",
  "doc_string": "`+ᵥ` is left commutative ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Add M] (s : Set M) {p : (x : M) → x ∈ AddSubsemigroup.closure s → Prop},\n  (∀ (x : M) (h : x ∈ s), p x (_ : x ∈ ↑(AddSubsemigroup.closure s))) →\n    (∀ (x : M) (hx : x ∈ AddSubsemigroup.closure s) (y : M) (hy : y ∈ AddSubsemigroup.closure s),\n        p x hx → p y hy → p (x + y) (_ : x + y ∈ AddSubsemigroup.closure s)) →\n      ∀ {x : M} (hx : x ∈ AddSubsemigroup.closure s), p x hx",
  "name": "AddSubsemigroup.closure_induction'",
  "kind": "theorem",
  "doc_string": "A dependent version of `AddSubsemigroup.closure_induction`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "NonAssocSemiring",
  "kind": "inductive",
  "doc_string": "A unital but not-necessarily-associative semiring. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} (self : α ↪ β), Function.Injective self.toFun",
  "name": "Function.Embedding.inj'",
  "kind": "def",
  "doc_string":
  "An embedding is an injective function. Use `Function.Embedding.injective` instead. ",
  "args": ""},
 {"type":
  "(R : Type u_1) → (M : Type u_2) → [inst : Zero R] → [inst : Zero M] → Type (max u_1 u_2)",
  "name": "SMulWithZero",
  "kind": "inductive",
  "doc_string":
  "`SMulWithZero` is a class consisting of a Type `R` with `0 ∈ R` and a scalar multiplication\nof `R` on a Type `M` with `0`, such that the equality `r • m = 0` holds if at least one among `r`\nor `m` equals `0`. ",
  "args": ""},
 {"type": "Type",
  "name": "PosNum",
  "kind": "inductive",
  "doc_string":
  "The type of positive binary numbers.\n\n13 = 1101(base 2) = bit1 (bit0 (bit1 one)) ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a : Q(ℕ)} →\n        Mathlib.Tactic.Ring.ExProd Mathlib.Tactic.Ring.sℕ a →\n          Mathlib.Tactic.Ring.RingM (Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExProd sα) q(↑«$a»))",
  "name": "Mathlib.Tactic.Ring.ExProd.evalNatCast",
  "kind": "opaque",
  "doc_string":
  "Applies `Nat.cast` to a nat monomial to produce a monomial in `α`.\n\n* `↑c = c` if `c` is a numeric literal\n* `↑(a ^ n * b) = ↑a ^ n * ↑b`\n",
  "args": ""},
 {"type": "List ℕ → ℕ",
  "name": "Nat.sum",
  "kind": "def",
  "doc_string": "Sum of a list of natural numbers. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (S : Set α) (f : α ≃ β), ↑f '' S = ↑(Equiv.symm f) ⁻¹' S",
  "name": "Set.image_equiv_eq_preimage_symm",
  "kind": "theorem",
  "doc_string": "Alias for `Equiv.image_eq_preimage` ",
  "args": ""},
 {"type": "{α : Sort u} → αᵒᵖ → α",
  "name": "Opposite.unop",
  "kind": "def",
  "doc_string": "The canonical map `αᵒᵖ → α`. ",
  "args": ""},
 {"type": "ℕ → Bool",
  "name": "Bool.ofNat",
  "kind": "def",
  "doc_string":
  "convert a `ℕ` to a `bool`, `0 -> false`, everything else -> `true` ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrder α] →\n      [inst_1 : LinearOrder β] → (f : α → β) → (g : β → α) → (∀ (a : α) (b : β), cmp a (g b) = cmp (f a) b) → α ≃o β",
  "name": "OrderIso.ofCmpEqCmp",
  "kind": "def",
  "doc_string":
  "To show that `f : α → β`, `g : β → α` make up an order isomorphism of linear orders,\nit suffices to prove `cmp a (g b) = cmp (f a) b`. ",
  "args": ""},
 {"type": "∀ {K : Type u} [self : Field K] (a b : K), a / b = a * b⁻¹",
  "name": "Field.div_eq_mul_inv",
  "kind": "def",
  "doc_string": "`a / b := a * b⁻¹` ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_\\_»",
  "kind": "def",
  "doc_string":
  "`a \\ b` is the set difference of `a` and `b`,\nconsisting of all elements in `a` that are not in `b`.\n",
  "args": ""},
 {"type": "{α : Type u} → [self : OrElse α] → α → (Unit → α) → α",
  "name": "OrElse.orElse",
  "kind": "def",
  "doc_string": "The implementation of `a <|> b : α`. See `HOrElse`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → List α → α → List α",
  "name": "List.erase",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `erase l a` removes the first occurrence of `a` from `l`.\n* `erase [1, 5, 3, 2, 5] 5 = [1, 3, 2, 5]`\n* `erase [1, 5, 3, 2, 5] 6 = [1, 5, 3, 2, 5]`\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (a : α) (s : Set α), (⨅ b, ⨅ h, a ⊔ b) ≤ a ⊔ infₛ s",
  "name": "CompleteBooleanAlgebra.infᵢ_sup_le_sup_infₛ",
  "kind": "def",
  "doc_string":
  "In a completely distributive lattice, `⊔` distributes over `⨅`. ",
  "args": ""},
 {"type": "(f : ℕ → Type u) → (n : ℕ) × f n ≃ f 0 ⊕ (n : ℕ) × f (n + 1)",
  "name": "Equiv.sigmaNatSucc",
  "kind": "def",
  "doc_string":
  "An equivalence that separates out the 0th fiber of `(Σ (n : ℕ), f n)`. ",
  "args": ""},
 {"type":
  "{a : Q(ℕ)} → Mathlib.Tactic.Ring.ExProd Mathlib.Tactic.Ring.sℕ a → Mathlib.Tactic.Ring.ExtractCoeff a",
  "name": "Mathlib.Tactic.Ring.extractCoeff",
  "kind": "def",
  "doc_string":
  "Given a monomial expression `va`, splits off the leading coefficient `k` and the remainder\n`e'`, stored in the `ExtractCoeff` structure.\n\n* `c = 1 * c` (if `c` is a constant)\n* `a * b = (a * b') * k` if `b = b' * k`\n",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {Z : ι → Type u_2} → [inst : (i : ι) → CanonicallyOrderedMonoid (Z i)] → CanonicallyOrderedMonoid ((i : ι) → Z i)",
  "name": "Pi.instCanonicallyOrderedMonoidForAll",
  "kind": "def",
  "doc_string":
  "The product of a family of canonically ordered monoids is a canonically ordered monoid. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (β : α → Type u_2) → ((a : α) → Equiv.Perm (β a)) →* Equiv.Perm ((a : α) × β a)",
  "name": "Equiv.Perm.sigmaCongrRightHom",
  "kind": "def",
  "doc_string":
  "`Equiv.Perm.sigmaCongrRight` as a `MonoidHom`.\n\nThis is particularly useful for its `MonoidHom.range` projection, which is the subgroup of\npermutations which do not exchange elements between fibers. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : NonUnitalCommRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : Add β] →\n          [inst_3 : Mul β] →\n            [inst_4 : Neg β] →\n              [inst_5 : Sub β] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : SMul ℤ β] →\n                    (f : β → α) →\n                      Function.Injective f →\n                        f 0 = 0 →\n                          (∀ (x y : β), f (x + y) = f x + f y) →\n                            (∀ (x y : β), f (x * y) = f x * f y) →\n                              (∀ (x : β), f (-x) = -f x) →\n                                (∀ (x y : β), f (x - y) = f x - f y) →\n                                  (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                    (∀ (x : β) (n : ℤ), f (n • x) = n • f x) → NonUnitalCommRing β",
  "name": "Function.Injective.nonUnitalCommRing",
  "kind": "def",
  "doc_string":
  "Pullback a `NonUnitalCommRing` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_3} {β : Type u_6} {γ : Type u_4} {δ : Type u_5} {ε : Type u_1} {ζ : Type u_2} (f : α → β) (f' : γ → δ)\n  (g : β → ε) (g' : δ → ζ), Prod.map g g' ∘ Prod.map f f' = Prod.map (g ∘ f) (g' ∘ f')",
  "name": "Prod.map_comp_map",
  "kind": "theorem",
  "doc_string":
  "Composing a `Prod.map` with another `Prod.map` is equal to\na single `Prod.map` of composed functions.\n",
  "args": ""},
 {"type": "∀ {a b c : Prop}, a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c)",
  "name": "or_and_left",
  "kind": "theorem",
  "doc_string": "`∨` distributes over `∧` (on the left). ",
  "args": ""},
 {"type": "{α : Type u} → {γ : Type v} → [self : Insert α γ] → α → γ → γ",
  "name": "Insert.insert",
  "kind": "def",
  "doc_string":
  "`insert x xs` inserts the element `x` into the collection `xs`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → (M →ₙ* N) → Subsemigroup N → Subsemigroup M",
  "name": "Subsemigroup.comap",
  "kind": "def",
  "doc_string":
  "The preimage of a subsemigroup along a semigroup homomorphism is a subsemigroup. ",
  "args": ""},
 {"type": "Lean.Expr → optParam (List ℕ) [] → Lean.MetaM Lean.Expr",
  "name": "ToAdditive.reorderLambda",
  "kind": "def",
  "doc_string":
  "Reorder lambda-binders. See doc of `reorderAttr` for the interpretation of the argument ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : CanonicallyLinearOrderedSemifield α] → DecidableEq α",
  "name": "CanonicallyLinearOrderedSemifield.decidable_eq",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {x y : α}, Setoid.Rel (Setoid.ker f) x y ↔ x ∈ f ⁻¹' {f y}",
  "name": "Setoid.ker_iff_mem_preimage",
  "kind": "theorem",
  "doc_string":
  "The elements related to x ∈ α by the kernel of f are those in the preimage of f(x) under f. ",
  "args": ""},
 {"type":
  "∀ {I : Type u} {f : I → Type v} {α : Type u_1} [inst : (i : I) → SMul α (f i)] [inst_1 : ∀ (i : I), Nonempty (f i)]\n  (i : I) [inst_2 : FaithfulSMul α (f i)], FaithfulSMul α ((i : I) → f i)",
  "name": "Pi.faithfulSMul_at",
  "kind": "theorem",
  "doc_string":
  "If `f i` has a faithful scalar action for a given `i`, then so does `Π i, f i`. This is\nnot an instance as `i` cannot be inferred. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_3} {γ : Sort u_1} (f : α → β → γ) (P : Prop) [inst : Decidable P] (a : P → α) (b : ¬P → α)\n  (c : P → β) (d : ¬P → β), f (dite P a b) (dite P c d) = if h : P then f (a h) (c h) else f (b h) (d h)",
  "name": "apply_dite₂",
  "kind": "theorem",
  "doc_string":
  "A two-argument function applied to two `dite`s is a `dite` of that two-argument function\napplied to each of the branches. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → (α : Q(Type u)) → Lean.MetaM Q(AddMonoidWithOne «$α»)",
  "name": "Mathlib.Meta.NormNum.inferAddMonoidWithOne",
  "kind": "def",
  "doc_string":
  "Helper functor to synthesize a typed `AddMonoidWithOne α` expression. ",
  "args": ""},
 {"type":
  "(G : Type u_1) → [inst : Group G] → (R : Type v) → [inst_1 : Semiring R] → [inst : MulSemiringAction G R] → G → R ≃+* R",
  "name": "MulSemiringAction.toRingEquiv",
  "kind": "def",
  "doc_string": "Each element of the group defines a semiring isomorphism. ",
  "args": ""},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "name": "Pure",
  "kind": "inductive",
  "doc_string":
  "The typeclass which supplies the `pure` function. See `Monad`. ",
  "args": ""},
 {"type": "(P : ℕ → Prop) → [inst : DecidablePred P] → ℕ → ℕ",
  "name": "Nat.findGreatest",
  "kind": "def",
  "doc_string":
  "`find_greatest P b` is the largest `i ≤ bound` such that `P i` holds, or `0` if no such `i`\nexists ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (α → α → Bool) → (a : Array α) → Fin (Array.size a) → { a' // Array.size a' = Array.size a }",
  "name": "BinaryHeap.heapifyUp",
  "kind": "def",
  "doc_string":
  "Core operation for binary heaps, expressed directly on arrays.\nGiven an array which is a max-heap, push item `i` up to restore the max-heap property. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Add M] → HasInf (AddSubsemigroup M)",
  "name": "AddSubsemigroup.instHasInfSubsemigroup",
  "kind": "def",
  "doc_string": "The inf of two `AddSubsemigroup`s is their intersection.",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HVAdd",
  "kind": "inductive",
  "doc_string":
  "The notation typeclass for heterogeneous additive actions.\nThis enables the notation `a +ᵥ b : γ` where `a : α`, `b : β`.\n",
  "args": ""},
 {"type": "{α : Sort u_1} → {β : Sort u_2} → (α → β) → Erased α → Erased β",
  "name": "Erased.map",
  "kind": "def",
  "doc_string":
  "`(<$>)` operation on `Erased`.\n\nThis is a separate definition because `α` and `β` can live in different\nuniverses (the universe is fixed in `Functor`).\n",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  [inst : AddGroup G] →\n    {H : Type u_2} → [inst_1 : AddGroup H] → (f : G → H) → (∀ (x y : G), f (x - y) = f x - f y) → G →+ H",
  "name": "AddMonoidHom.ofMapSub",
  "kind": "def",
  "doc_string":
  "Define a morphism of additive groups given a map which respects difference.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {a : α} {s : Set α}, a ⊔ infₛ s ≤ ⨅ b, ⨅ h, a ⊔ b",
  "name": "sup_infₛ_le_infᵢ_sup",
  "kind": "theorem",
  "doc_string": "This is a weaker version of `sup_infₛ_eq` ",
  "args": ""},
 {"type":
  "{F : Type u_1} → {α : Type u_2} → {β : Type u_3} → {x : LE α} → {x_1 : LE β} → [inst : OrderIsoClass F α β] → F → α ≃o β",
  "name": "OrderIsoClass.toOrderIso",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `OrderIsoClass F α β` into an actual\n`OrderIso`. This is declared as the default coercion from `F` to `α ≃o β`. ",
  "args": ""},
 {"type":
  "Array (Array ℤ) → Lean.Expr → Lean.Expr → Array Mathlib.Tactic.Sat.LRATStep → Lean.MetaM Lean.Expr",
  "name": "Mathlib.Tactic.Sat.buildProof",
  "kind": "def",
  "doc_string":
  "Build the main proof of `⊢ ctx.proof []` using the LRAT proof trace.\n\n* `arr`: The input CNF\n* `ctx`: The abbreviated formula, a constant like `foo.ctx_1`\n* `ctx'`: The definitional expansion of the formula, a tree of `Fmla.and` nodes\n* `steps`: The input LRAT proof trace\n",
  "args": ""},
 {"type": "{α : Type s} → α → ULift α",
  "name": "ULift.up",
  "kind": "def",
  "doc_string": "Lift a value into `ULift α` ",
  "args": ""},
 {"type":
  "{A : Type u} → {B : Type v} → [self : HasQuotient A B] → B → Type (max u v)",
  "name": "HasQuotient.quotient'",
  "kind": "def",
  "doc_string":
  "auxiliary quotient function, the one used will have `A` explicit ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulStrictMono α],\n  0 < a → 0 < b → 0 < a * b",
  "name": "Left.mul_pos",
  "kind": "theorem",
  "doc_string": "Assumes left covariance. ",
  "args": ""},
 {"type":
  "{F : Type u → Type v} → [inst : Applicative F] → {α : Type u_1} → {β : Type u} → (α → F β) → List α → F (List β)",
  "name": "List.traverse",
  "kind": "def",
  "doc_string":
  "Map each element of a `List` to an action, evaluate these actions in order,\nand collect the results.\n",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : Mul G] → G → G → G",
  "name": "rightMul",
  "kind": "def",
  "doc_string": "`rightMul g` denotes right multiplication by `g` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Add α] → [inst_1 : Add β] → αᵐᵒᵖ ≃+ βᵐᵒᵖ ≃ (α ≃+ β)",
  "name": "AddEquiv.mulUnop",
  "kind": "def",
  "doc_string":
  "The 'unopposite' of an iso `αᵐᵒᵖ ≃+ βᵐᵒᵖ`. Inverse to `AddEquiv.mul_op`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_3} {N : Type u_4} {α : Type u_2} {β : Type u_1} [inst : VAdd M α] [inst_1 : VAdd β α]\n  [inst_2 : VAddCommClass β M α] (g : N → M), VAddCommClass β N α",
  "name": "VAdd.comp.vaddCommClass'",
  "kind": "theorem",
  "doc_string":
  "This cannot be an instance because it can cause infinite loops wheneverthe `VAdd` arguments\nare still metavariables.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] {p : M → Prop} (x : M) {s : Set M},\n  AddSubmonoid.closure s = ⊤ → (∀ (x : M), x ∈ s → p x) → p 0 → (∀ (x y : M), p x → p y → p (x + y)) → p x",
  "name": "AddSubmonoid.dense_induction",
  "kind": "theorem",
  "doc_string":
  "If `s` is a dense set in an additive monoid `M`, `AddSubmonoid.closure s = ⊤`, then in\norder to prove that some predicate `p` holds for all `x : M` it suffices to verify `p x` for\n`x ∈ s`, verify `p 0`, and verify that `p x` and `p y` imply `p (x + y)`.",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} {a b : R} [inst : SMul R M] [inst_1 : Mul R] [inst_2 : IsScalarTower R R M],\n  IsSMulRegular M (a * b) ∧ IsSMulRegular M (b * a) ↔ IsSMulRegular M a ∧ IsSMulRegular M b",
  "name": "IsSMulRegular.mul_and_mul_iff",
  "kind": "theorem",
  "doc_string":
  "Two elements `a` and `b` are `M`-regular if and only if both products `a * b` and `b * a`\nare `M`-regular. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  {D : Type u₂} →\n    [inst : CategoryTheory.Category C] →\n      [inst_1 : CategoryTheory.Category D] → {F : C ⥤ D} → {Y : D} → Y ∈ CategoryTheory.Functor.essImage F → C",
  "name": "CategoryTheory.Functor.essImage.witness",
  "kind": "def",
  "doc_string":
  "Get the witnessing object that `Y` is in the subcategory given by `F`. ",
  "args": ""},
 {"type":
  "{ε σ α β : Type u} → EStateM ε σ α → (α → EStateM ε σ β) → EStateM ε σ β",
  "name": "EStateM.bind",
  "kind": "def",
  "doc_string": "The `bind` operation of the `EStateM` monad. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α ⊕ β ↪ γ) ≃ { f // Disjoint (Set.range ↑f.fst) (Set.range ↑f.snd) }",
  "name": "Equiv.sumEmbeddingEquivProdEmbeddingDisjoint",
  "kind": "def",
  "doc_string":
  "Embeddings from a sum type are equivalent to two separate embeddings with disjoint ranges. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (ℕ → α → β) → List α → List β",
  "name": "List.mapWithIndex",
  "kind": "def",
  "doc_string":
  "Given a function `f : ℕ → α → β` and `as : List α`, `as = [a₀, a₁, ...]`, returns the list\n`[f 0 a₀, f 1 a₁, ...]`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) →\n  [H1 : Lattice α] →\n    [inst : SupSet α] → (∀ (s : Set α), BddAbove s → Set.Nonempty s → IsLUB s (supₛ s)) → ConditionallyCompleteLattice α",
  "name": "conditionallyCompleteLatticeOfLatticeOfSupₛ",
  "kind": "def",
  "doc_string":
  "A version of `conditionallyCompleteLatticeOfSupₛ` when we already know that `α` is a lattice.\n\nThis should only be used when it is both hard and unnecessary to provide `inf` explicitly. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "OrderedCommRing",
  "kind": "inductive",
  "doc_string":
  "An `OrderedCommRing` is a commutative ring with a partial order such that addition is monotone\nand multiplication by a nonnegative number is monotone. ",
  "args": ""},
 {"type": "IO.Ref (Lean.Expr → Lean.MetaM Lean.Expr)",
  "name": "Mathlib.Tactic.Ring.ringCleanupRef",
  "kind": "opaque",
  "doc_string":
  "This is a routine which is used to clean up the unsolved subgoal\nof a failed `ring1` application. It is overridden in `Mathlib.Tactic.Ring.RingNF`\nto apply the `ring_nf` simp set to the goal.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Membership α β] {s : β} {a b : α}, a ∈ s → ¬b ∈ s → a ≠ b",
  "name": "Membership.Mem.ne_of_not_mem",
  "kind": "theorem",
  "doc_string": "**Alias** of `ne_of_mem_of_not_mem`.",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.lcm",
  "kind": "def",
  "doc_string":
  "The least common multiple of `m` and `n`, defined using `gcd`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, 0 < a → -a < a",
  "name": "neg_lt_self",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.neg_lt_self`.",
  "args": ""},
 {"type": "{α : Type u} → List α → Stream' α → Stream' (List α)",
  "name": "Stream'.initsCore",
  "kind": "def",
  "doc_string": "An auxiliary definition for `Stream'.inits`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → (f : M ≃ N) → (∀ (x y : M), ↑f (x + y) = ↑f x + ↑f y) → M ≃+ N",
  "name": "AddEquiv.mk'",
  "kind": "def",
  "doc_string":
  "Makes an additive isomorphism from a bijection which preserves addition.",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : BEq α] → α → List (α × β) → Option β",
  "name": "List.lookup",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `lookup a l` treats `l : List (α × β)` like an association list,\nand returns the first `β` value corresponding to an `α` value in the list equal to `a`.\n\n* `lookup 3 [(1, 2), (3, 4), (3, 5)] = some 4`\n* `lookup 2 [(1, 2), (3, 4), (3, 5)] = none`\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_4} {β : Type u_5} {γ : Type u_3} {f : α → β → γ} {a : Option α} {b : Option β} {δ : Type u_1}\n  {α' : Type u_2} {g : γ → δ} {f' : β → α' → δ} {g' : α → α'},\n  (∀ (a : α) (b : β), g (f a b) = f' b (g' a)) → Option.map g (Option.map₂ f a b) = Option.map₂ f' b (Option.map g' a)",
  "name": "Option.map_map₂_antidistrib_right",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Option.map_map₂_right_anticomm`. ",
  "args": ""},
 {"type": "(n : ℕ) → List (Fin n)",
  "name": "List.finRange",
  "kind": "def",
  "doc_string":
  "All elements of `Fin n`, from `0` to `n-1`. The corresponding finset is `Finset.univ`. ",
  "args": ""},
 {"type":
  "{a : Q(ℕ)} → Mathlib.Tactic.Ring.ExProd Mathlib.Tactic.Ring.sℕ a → Option Q(0 < «$a»)",
  "name": "Mathlib.Tactic.Ring.ExProd.evalPos",
  "kind": "opaque",
  "doc_string":
  "Attempts to prove that a monomial expression in `ℕ` is positive.\n\n* `0 < c` (where `c` is a numeral) is true by the normalization invariant (`c` is not zero)\n* `0 < x ^ e * b` if `0 < x` and `0 < b`\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : SuccOrder α] [inst_2 : IsSuccArchimedean α] (r : α → α → Prop)\n  {n m : α}, (∀ (i : α), i ∈ Set.Ico m n → r (Order.succ i) i) → m < n → Relation.TransGen r n m",
  "name": "transGen_of_succ_of_gt",
  "kind": "theorem",
  "doc_string":
  "For `m < n`, `(n, m)` is in the transitive closure of a relation `~` if `succ i ~ i`\nfor all `i` between `n` and `m`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«termα≥0»",
  "kind": "def",
  "doc_string":
  "Local notation for the nonnegative elements of a type `α`. TODO: actually make local. ",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Monoid α] (u : αˣ), ↑u⁻¹ = 1 /ₚ u",
  "name": "inv_eq_one_divp",
  "kind": "theorem",
  "doc_string": "Used for `field_simp` to deal with inverses of units. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → ℕ → List α",
  "name": "List.rotate",
  "kind": "def",
  "doc_string":
  "`rotate l n` rotates the elements of `l` to the left by `n`\n```\nrotate [0, 1, 2, 3, 4, 5] 2 = [2, 3, 4, 5, 0, 1]\n```\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {F : Type u_3} →\n      [inst : MulOneClass M] → [inst_1 : MulOneClass N] → [inst_2 : MonoidHomClass F M N] → CoeTC F (M →* N)",
  "name": "instCoeTCMonoidHom",
  "kind": "def",
  "doc_string":
  "Any type satisfying `MonoidHomClass` can be cast into `MonoidHom` via\n`MonoidHomClass.toMonoidHom`. ",
  "args": ""},
 {"type": "Linarith.Sum → Linarith.Sum → Linarith.Sum",
  "name": "Linarith.Sum.mul",
  "kind": "def",
  "doc_string": "`sum.mul s1 s2` distributes the multiplication of two sums.` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) → α → β",
  "name": "OrderHom.Simps.coe",
  "kind": "def",
  "doc_string":
  "See Note [custom simps projection]. Note: all other FunLike classes use `apply` instead of `coe`\nfor the projection names. Maybe we should change this. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (q : Semiquot α) → {s : Set α} → q.s ⊆ s → Semiquot α",
  "name": "Semiquot.blur'",
  "kind": "def",
  "doc_string": "Replace `s` in a `Semiquot` with a superset. ",
  "args": ""},
 {"type": "True",
  "name": "True.intro",
  "kind": "def",
  "doc_string":
  "`True` is true, and `True.intro` (or more commonly, `trivial`)\nis the proof. ",
  "args": ""},
 {"type": "(V : Type u_1) → [inst : Quiver V] → Type (max u_1 v)",
  "name": "Quiver.HasInvolutiveReverse",
  "kind": "inductive",
  "doc_string":
  "A quiver `HasInvolutiveReverse` if reversing twice is the identity.`",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {A : Type u_2} [inst : AddZeroClass A] [self : DistribSMul M A] (a : M) (x y : A),\n  a • (x + y) = a • x + a • y",
  "name": "DistribSMul.smul_add",
  "kind": "def",
  "doc_string": "Scalar multiplication distributes across addition ",
  "args": ""},
 {"type":
  "{F : Type u → Type v} →\n  [inst : Applicative F] →\n    {G : Type u → Type w} → [inst_1 : Applicative G] → ApplicativeTransformation F G → (α : Type u) → F α → G α",
  "name": "ApplicativeTransformation.app",
  "kind": "def",
  "doc_string":
  "The function on objects defined by an `ApplicativeTransformation`. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "OrderedCommMonoid",
  "kind": "inductive",
  "doc_string":
  "An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a ≤ b → c * a ≤ c * b` (multiplication is monotone)\n",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "DivInvOneMonoid",
  "kind": "inductive",
  "doc_string": "A `DivInvMonoid` where `1⁻¹ = 1`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : MulOneClass N] → One (M →ₙ* N)",
  "name": "instOneMulHomToMul",
  "kind": "def",
  "doc_string":
  "`1` is the multiplicative homomorphism sending all elements to `1`. ",
  "args": ""},
 {"type":
  "{γ : Type u_1} → {α : Type u_2} → {β : Type u_3} → (α → β) → Functor.Const γ β → Functor.Const γ α",
  "name": "Functor.Const.map",
  "kind": "def",
  "doc_string": "The map operation of the `Const γ` functor. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {E : Type u_2} (R : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R] [inst_2 : Monoid α]\n  [inst_3 : Module R E] [inst_4 : DistribMulAction α E] (n : ℤ) (s : α) (x : E), (↑n)⁻¹ • s • x = s • (↑n)⁻¹ • x",
  "name": "inv_int_cast_smul_comm",
  "kind": "theorem",
  "doc_string":
  "If `E` is a vector space over a division rings `R` and has a monoid action by `α`, then that\naction commutes by scalar multiplication of inverses of integers in `R` ",
  "args": ""},
 {"type": "{α : Type u} → {n : ℕ} → Vector α n → ℕ",
  "name": "Vector.length",
  "kind": "def",
  "doc_string": "The length of a vector. ",
  "args": ""},
 {"type": "{α : Sort u_1} → Erased α → α",
  "name": "Erased.out",
  "kind": "def",
  "doc_string": "Extracts the erased value, noncomputably. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "name": "LE.le.antisymm",
  "kind": "theorem",
  "doc_string": "**Alias** of `le_antisymm`.",
  "args": ""},
 {"type": "{α : Type u_1} → ℕ → α → List α → List α",
  "name": "List.leftpad",
  "kind": "def",
  "doc_string":
  "Pads `l : List α` with repeated occurrences of `a : α` until it is of length `n`.\nIf `l` is initially larger than `n`, just return `l`.\n",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.ascFactorial",
  "kind": "def",
  "doc_string":
  "`n.ascFactorial k = (n + k)! / n!` (as seen in `Nat.ascFactorial_eq_div`), but implemented\nrecursively to allow for \"quick\" computation when using `norm_num`. This is closely related to\n`pochhammer`, but much less general. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → (γ : Type u_3) → (α × β) × γ ≃ α × β × γ",
  "name": "Equiv.prodAssoc",
  "kind": "def",
  "doc_string": "Type product is associative up to an equivalence. ",
  "args": ""},
 {"type": "{α : Type u} → Set α → Prop",
  "name": "Set.Nontrivial",
  "kind": "def",
  "doc_string":
  "A set `s` is `nontrivial` if it has at least two distinct elements. ",
  "args": ""},
 {"type": "Lean.Elab.Command.CommandElab",
  "name": "Tactic.Alias.elabAliasLRDots",
  "kind": "def",
  "doc_string": "Elaborates an `alias ↔ ..` command. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → β → Prop) → List α → List β → Prop",
  "name": "List.Forall₂",
  "kind": "inductive",
  "doc_string":
  "`Forall₂ R l₁ l₂` means that `l₁` and `l₂` have the same length,\nand whenever `a` is the nth element of `l₁`, and `b` is the nth element of `l₂`,\nthen `R a b` is satisfied.\n",
  "args": ""},
 {"type":
  "{α : Type u₁} → {β : Type u₂} → {φ : Type u₃} → (α × β → φ) → α → β → φ",
  "name": "Function.curry",
  "kind": "def",
  "doc_string":
  "Interpret a function on `α × β` as a function with two arguments. ",
  "args": ""},
 {"type":
  "{I : Type u} →\n  (f : I → Type v) → [inst : DecidableEq I] → [inst : (i : I) → AddZeroClass (f i)] → (i : I) → f i →+ (i : I) → f i",
  "name": "AddMonoidHom.single",
  "kind": "def",
  "doc_string":
  "The additive monoid homomorphism including a single additive monoid into a dependent family\nof additive monoids, as functions supported at a point.\n\nThis is the `AddMonoidHom` version of `Pi.single`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → {γ : Type u_3} → {f : α → γ} → {g : β → γ} → ((c : γ) → ↑(f ⁻¹' {c}) ≃ ↑(g ⁻¹' {c})) → α ≃ β",
  "name": "Equiv.ofPreimageEquiv",
  "kind": "def",
  "doc_string":
  "A family of equivalences between preimages of points gives an equivalence between domains. ",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Preorder α] {x y : α}, x = y → y ≤ x",
  "name": "Eq.ge",
  "kind": "theorem",
  "doc_string":
  "If `x = y` then `y ≤ x`. Note: this lemma uses `y ≤ x` instead of `x ≥ y`, because `le` is used\nalmost exclusively in mathlib. ",
  "args": ""},
 {"type": "Lean.FVarId → Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Tactic.PushNeg.pushNegLocalDecl",
  "kind": "def",
  "doc_string": "Execute main loop of `push_neg` at a local hypothesis. ",
  "args": ""},
 {"type": "{α : Type u_1} → (r : α → α → Prop) → r ≃r r",
  "name": "RelIso.refl",
  "kind": "def",
  "doc_string": "Identity map is a relation isomorphism. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  (s : Set α) →\n    [inst : ConditionallyCompleteLinearOrder α] →\n      [inst_1 : Inhabited ↑s] →\n        (∀ {t : Set ↑s}, Set.Nonempty t → BddAbove t → supₛ (Subtype.val '' t) ∈ s) →\n          (∀ {t : Set ↑s}, Set.Nonempty t → BddBelow t → infₛ (Subtype.val '' t) ∈ s) →\n            ConditionallyCompleteLinearOrder ↑s",
  "name": "subsetConditionallyCompleteLinearOrder",
  "kind": "def",
  "doc_string":
  "For a nonempty subset of a conditionally complete linear order to be a conditionally complete\nlinear order, it suffices that it contain the `supₛ` of all its nonempty bounded-above subsets, and\nthe `infₛ` of all its nonempty bounded-below subsets.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : AddMonoid M] → AddSubmonoid M",
  "name": "AddSubmonoid.center",
  "kind": "def",
  "doc_string":
  "The center of a monoid `M` is the set of elements that commute with everything in `M`",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Zero M] → [inst : Add M] → [inst : Neg M] → ℤ → M → M",
  "name": "zsmulRec",
  "kind": "def",
  "doc_string":
  "The fundamental scalar multiplication in an additive group. `zpowRec n a = a+a+...+a` n\ntimes, for integer `n`. Use instead `n • a`, which has better definitional behavior. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → α → Functor.AddConst α β",
  "name": "Functor.AddConst.mk",
  "kind": "def",
  "doc_string":
  "`AddConst.mk` is the canonical map `α → AddConst α β`, which is the identity,\nwhere `AddConst α β = Const α β`. It can be used as a pattern to extract this value. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_ᵒᵖ»",
  "kind": "def",
  "doc_string":
  "The type of objects of the opposite of `α`; used to define the opposite category.\n\nIn order to avoid confusion between `α` and its opposite type, we\nset up the type of objects `Opposite α` using the following pattern,\nwhich will be repeated later for the morphisms.\n\n1. Define `Opposite α := α`.\n2. Define the isomorphisms `op : α → Opposite α`, `unop : Opposite α → α`.\n3. Make the definition `Opposite` irreducible.\n\nThis has the following consequences.\n\n* `Opposite α` and `α` are distinct types in the elaborator, so you\n  must use `op` and `unop` explicitly to convert between them.\n* Both `unop (op X) = X` and `op (unop X) = X` are definitional\n  equalities. Notably, every object of the opposite category is\n  definitionally of the form `op X`, which greatly simplifies the\n  definition of the structure of the opposite category, for example.\n\n(Now that Lean 4 supports definitional eta equality for records, we could\nachieve the same goals using a structure with one field.)\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : α → Type u_2} → {γ : (a : α) → β a → Type u_3} → ((x : Sigma β) → γ x.fst x.snd) → (x : α) → (y : β x) → γ x y",
  "name": "Sigma.curry",
  "kind": "def",
  "doc_string":
  "Interpret a function on `Σ x : α, β x` as a dependent function with two arguments.\n\nThis also exists as an `equiv` as `equiv.Pi_curry γ`. ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Mul R] → R → Prop",
  "name": "IsRegular",
  "kind": "inductive",
  "doc_string":
  "A regular element is an element `c` such that multiplication by `c` both on the left and\non the right is injective. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → {p : α → Prop} → ((a : α) → p a → β) → (l : List α) → (∀ (a : α), a ∈ l → p a) → List β",
  "name": "List.pmap",
  "kind": "def",
  "doc_string":
  "Partial map. If `f : Π a, p a → β` is a partial function defined on\n`a : α` satisfying `p`, then `pmap f l h` is essentially the same as `map f l`\nbut is defined only when all members of `l` satisfy `p`, using the proof\nto apply `f`. ",
  "args": ""},
 {"type": "{α : Type u} → α → List α → List α",
  "name": "List.cons",
  "kind": "def",
  "doc_string":
  "If `a : α` and `l : List α`, then `cons a l`, or `a :: l`, is the\nlist whose first element is `a` and with `l` as the rest of the list. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} → [inst : Mul R] → [inst_1 : Mul S] → [inst_2 : Add R] → [inst_3 : Add S] → R ≃+* S → S → R",
  "name": "RingEquiv.Simps.symmApply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HAnd α β γ] → α → β → γ",
  "name": "HAnd.hAnd",
  "kind": "def",
  "doc_string":
  "`a &&& b` computes the bitwise AND of `a` and `b`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : AddGroup G] [inst_1 : AddMonoid M]\n  [inst_2 : AddMonoidHomClass F G M] (f g : F) {x : G}, ↑f x = ↑g x → ↑f (-x) = ↑g (-x)",
  "name": "eq_on_neg",
  "kind": "theorem",
  "doc_string":
  "If two homomorphism from an additive group to an additive monoid are equal at `x`,\nthen they are equal at `-x`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_3} {β : Type u_5} {γ : Type u_4} {δ : Type u_6} {ε : Type u_1} {ζ : Type u_2} (f : α → β) (f' : γ → δ)\n  (g : β → ε) (g' : δ → ζ) (x : α × γ), Prod.map g g' (Prod.map f f' x) = Prod.map (g ∘ f) (g' ∘ f') x",
  "name": "Prod.map_map",
  "kind": "theorem",
  "doc_string":
  "Composing a `Prod.map` with another `Prod.map` is equal to\na single `Prod.map` of composed functions, fully applied.\n",
  "args": ""},
 {"type": "Simps.Config",
  "name": "Simps.Config.lemmasOnly",
  "kind": "def",
  "doc_string":
  "A common configuration for `@[simps]`: don't tag the generated lemmas with `@[simp]`. ",
  "args": ""},
 {"type":
  "Bool →\n  List (Lean.TSyntax `term) → Lean.MetaM (List (Lean.Elab.TermElabM Lean.Expr) × Lean.Elab.TermElabM (List Lean.Expr))",
  "name": "Mathlib.Tactic.SolveByElim.mkAssumptionSet",
  "kind": "def",
  "doc_string":
  "`mkAssumptionSet` builds a collection of lemmas for use in\nthe backtracking search in `solve_by_elim`.\n\n* By default, it includes all local hypotheses, along with `rfl`, `trivial`, `congrFun` and\n  `congrArg`.\n* The flag `noDflt` removes these.\n* The argument `hs` is the list of arguments inside the square braces\n  and can be used to add lemmas or expressions from the set. (TODO support removal.)\n\n`mkAssumptionSet` returns not a `List expr`, but a `List (TermElabM Expr) × TermElabM (List Expr)`.\nThere are two separate problems that need to be solved.\n\n### Relevant local hypotheses\n\n`solve_by_elim*` (not implemented yet here) works with multiple goals,\nand we need to use separate sets of local hypotheses for each goal.\nThe second component of the returned value provides these local hypotheses.\n(Essentially using `local_context`, along with some filtering to remove hypotheses\nthat have been explicitly removed via `only` or `[-h]`.)\n\n### Stuck metavariables\n\nLemmas with implicit arguments would be filled in with metavariables if we created the\n`Expr` objects immediately, so instead we return thunks that generate the expressions\non demand. This is the first component, with type `List (TermElabM expr)`.\n\nAs an example, we have `def rfl : ∀ {α : Sort u} {a : α}, a = a`, which on elaboration will become\n`@rfl ?m_1 ?m_2`.\n\nBecause `solve_by_elim` works by repeated application of lemmas against subgoals,\nthe first time such a lemma is successfully applied,\nthose metavariables will be unified, and thereafter have fixed values.\nThis would make it impossible to apply the lemma\na second time with different values of the metavariables.\n\nSee https://github.com/leanprover-community/mathlib/issues/2269\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_/_»",
  "kind": "def",
  "doc_string":
  "`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat` and `Int`, `a / b` rounds toward 0.\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. ",
  "args": ""},
 {"type": "Lean.Parsec (Array Mathlib.Tactic.Sat.LRATStep)",
  "name": "Mathlib.Tactic.Sat.Parser.parseLRAT",
  "kind": "def",
  "doc_string": "Parse an LRAT file into a list of steps. ",
  "args": ""},
 {"type":
  "∀ {ι : Type u_1} (self : ComplexShape ι) {i j j' : ι}, ComplexShape.Rel self i j → ComplexShape.Rel self i j' → j = j'",
  "name": "ComplexShape.next_eq",
  "kind": "def",
  "doc_string": "There is at most one nonzero differential from `X i`. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {Z : ι → Type u_2} → [inst : (i : ι) → OrderedAddCommMonoid (Z i)] → OrderedAddCommMonoid ((i : ι) → Z i)",
  "name": "Pi.orderedAddCommMonoid",
  "kind": "def",
  "doc_string":
  "The product of a family of ordered additive commutative monoids is\nan ordered additive commutative monoid.",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (ℕ → α → β) → ℕ → List α → List β",
  "name": "List.mapWithIndexCore",
  "kind": "def",
  "doc_string": "Auxiliary function for `mapWithIndex`. ",
  "args": ""},
 {"type":
  "∀ (n k : ℕ), Nat.ascFactorial n k = Nat.factorial (n + k) / Nat.factorial n",
  "name": "Nat.ascFactorial_eq_div",
  "kind": "theorem",
  "doc_string":
  "Avoid in favor of `Nat.factorial_mul_ascFactorial` if you can. ℕ-division isn't worth it. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.clearAuxDecl",
  "kind": "def",
  "doc_string":
  "This tactic clears all auxiliary declarations from the context. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : PartialOrder α] → [inst_1 : Preorder β] → ((fun x x_1 => x < x_1) →r fun x x_1 => x < x_1) → α →o β",
  "name": "RelHom.toOrderHom",
  "kind": "def",
  "doc_string":
  "A bundled expression of the fact that a map between partial orders that is strictly monotone\nis weakly monotone. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : MulZeroClass R] [inst_1 : Nontrivial R], ¬IsRegular 0",
  "name": "not_isRegular_zero",
  "kind": "theorem",
  "doc_string":
  "In a non-trivial ring, the element `0` is not regular -- with typeclasses. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Polyrith.SageError → String",
  "name": "Mathlib.Tactic.Polyrith.SageError.value",
  "kind": "def",
  "doc_string": "The error message ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Semigroup α] (x y : α), ((fun x_1 => x_1 * x) ∘ fun x => x * y) = fun x_1 => x_1 * (y * x)",
  "name": "comp_mul_right",
  "kind": "theorem",
  "doc_string":
  "Composing two multiplications on the right by `y` and `x`\nis equal to a multiplication on the right by `y * x`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → β) → (α → α → α) → (β → β → β) → Prop",
  "name": "Function.Semiconj₂",
  "kind": "def",
  "doc_string":
  "A map `f` semiconjugates a binary operation `ga` to a binary operation `gb` if\nfor all `x`, `y` we have `f (ga x y) = gb (f x) (f y)`. E.g., a `MonoidHom`\nsemiconjugates `(*)` to `(*)`.\n",
  "args": ""},
 {"type":
  "{C : Type u₁} → [inst : CategoryTheory.CategoryStruct C] → [inst : Quiver.IsThin C] → CategoryTheory.Category C",
  "name": "CategoryTheory.thin_category",
  "kind": "def",
  "doc_string":
  "Construct a category instance from a category_struct, using the fact that\nhom spaces are subsingletons to prove the axioms. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → (α → β) → (β → β → Prop) → α → α → Prop",
  "name": "Order.Preimage",
  "kind": "def",
  "doc_string":
  "Given a relation `R` on `β` and a function `f : α → β`, the preimage relation on `α` is defined\nby `x ≤ y ↔ f x ≤ f y`. It is the unique relation on `α` making `f` a `RelEmbedding` (assuming `f`\nis injective). ",
  "args": ""},
 {"type": "ℕ → ℕ → Prop",
  "name": "Nat.lt",
  "kind": "def",
  "doc_string":
  "The strict less than relation on natural numbers is defined as `n < m := n + 1 ≤ m`. ",
  "args": ""},
 {"type":
  "{S : Type u_1} →\n  [inst : LinearOrderedSemifield S] →\n    {R : Type u_2} →\n      [inst_1 : Semiring R] → [inst_2 : Nontrivial R] → (abv : R → S) → [inst_3 : IsAbsoluteValue abv] → R →*₀ S",
  "name": "IsAbsoluteValue.abvHom'",
  "kind": "def",
  "doc_string":
  "An absolute value as a monoid with zero homomorphism, assuming the target is a semifield. ",
  "args": ""},
 {"type": "{α : Type u} → α → List α",
  "name": "List.ret",
  "kind": "def",
  "doc_string": "List with a single given element. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_3} {S : Type u_1} {M : Type u_2} {s : S} [inst : SMul R M] [inst_1 : SMul R S] [inst_2 : SMul S M]\n  [inst : IsScalarTower R S M] (a : R), IsSMulRegular M (a • s) → IsSMulRegular M s",
  "name": "IsSMulRegular.of_smul",
  "kind": "theorem",
  "doc_string":
  "If an element `b` becomes `M`-regular after multiplying it on the left by an `M`-regular\nelement, then `b` is `M`-regular. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {f : α → β} {x y : α}, Set.InjOn f s → x ∈ s → y ∈ s → x ≠ y → f x ≠ f y",
  "name": "Set.InjOn.ne",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `Set.InjOn.ne_iff`.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → (M →+ N) → WithTop M →+ WithTop N",
  "name": "AddMonoidHom.withTopMap",
  "kind": "def",
  "doc_string": "A version of `WithTop.map` for `AddMonoidHom`s. ",
  "args": ""},
 {"type": "{α : Type u} → αᵃᵒᵖ → α",
  "name": "AddOpposite.unop",
  "kind": "def",
  "doc_string": "The element of `α` represented by `x : αᵃᵒᵖ`. ",
  "args": ""},
 {"type":
  "Lean.Name → Lean.Name → optParam Lean.Meta.SimpExtension Lean.Meta.simpExtension → Lean.CoreM Unit",
  "name": "ToAdditive.copySimpAttribute",
  "kind": "def",
  "doc_string": "Copy the simp attribute in a `to_additive` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m",
  "name": "exists_maximal_of_nonempty_chains_bounded",
  "kind": "theorem",
  "doc_string":
  "A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then\nthere is a maximal element.\n",
  "args": ""},
 {"type": "Linarith.GlobalPreprocessor",
  "name": "Linarith.nlinarithExtras",
  "kind": "def",
  "doc_string":
  "`nlinarithExtras` is the preprocessor corresponding to the `nlinarith` tactic.\n\n* For every term `t` such that `t^2` or `t*t` appears in the input, adds a proof of `t^2 ≥ 0`\n  or `t*t ≥ 0`.\n* For every pair of comparisons `t1 R1 0` and `t2 R2 0`, adds a proof of `t1*t2 R 0`.\n\nThis preprocessor is typically run last, after all inputs have been canonized.\n",
  "args": ""},
 {"type": "{K : Type u} → [self : DivisionRing K] → ℤ → K → K",
  "name": "DivisionRing.zpow",
  "kind": "def",
  "doc_string":
  "The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : Add α] [inst_2 : Sub α] [self : OrderedSub α] (a b c : α),\n  a - b ≤ c ↔ a ≤ c + b",
  "name": "OrderedSub.tsub_le_iff_right",
  "kind": "def",
  "doc_string": "`a - b` provides a lower bound on `c` such that `a ≤ c + b`. ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Add R] → R → Prop",
  "name": "IsAddRightRegular",
  "kind": "def",
  "doc_string":
  "An add-right-regular element is an element `c` such that addition\non the right by `c` is injective.",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≠ b",
  "name": "LT.lt.ne",
  "kind": "theorem",
  "doc_string": "**Alias** of `ne_of_lt`.",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → Stream' (α → β) → Stream' α → Stream' β",
  "name": "Stream'.apply",
  "kind": "def",
  "doc_string":
  "Given a stream of functions and a stream of values, apply `n`-th function to `n`-th value. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {α : ι → Type u_2} → [inst : LinearOrder ι] → [inst : (i : ι) → LinearOrder (α i)] → LinearOrder (Lex ((i : ι) × α i))",
  "name": "Sigma.Lex.linearOrder",
  "kind": "def",
  "doc_string": "The lexicographical linear order on a sigma type. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1],\n  StrictAntiOn f s → AntitoneOn g s → StrictAntiOn (fun x => f x * g x) s",
  "name": "StrictAntiOn.mul_antitone'",
  "kind": "theorem",
  "doc_string":
  "The product of a strictly antitone function and a antitone function is strictly antitone. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → (α → β) → LazyList α → LazyList β",
  "name": "LazyList.map",
  "kind": "def",
  "doc_string": "Maps a function over a lazy list. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_&&_»",
  "kind": "def",
  "doc_string":
  "`and x y`, or `x && y`, is the boolean \"and\" operation (not to be confused\nwith `And : Prop → Prop → Prop`, which is the propositional connective).\nIt is `@[macro_inline]` because it has C-like short-circuiting behavior:\nif `x` is false then `y` is not evaluated.\n",
  "args": ""},
 {"type": "{α : Type u} → Stream' α → Stream' (ℕ × α)",
  "name": "Stream'.enum",
  "kind": "def",
  "doc_string": "Enumerate a stream by tagging each element with its index. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R) (s : { x // x ∈ S }),\n  r * ↑(OreLocalization.oreDenom r s) = ↑s * OreLocalization.oreNum r s",
  "name": "OreLocalization.ore_eq",
  "kind": "theorem",
  "doc_string":
  "The Ore condition of a fraction, expressed in terms of `oreNum` and `oreDenom`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {x : Q(«$α»)} →\n      (inst : autoParam Q(Ring «$α») _auto✝) →\n        (lit : Q(ℕ)) → Q(Mathlib.Meta.NormNum.IsInt «$x» (Int.negOfNat «$lit»)) → Mathlib.Meta.NormNum.Result x",
  "name": "Mathlib.Meta.NormNum.Result.isNegNat",
  "kind": "def",
  "doc_string":
  "The result is `-lit` where `lit` is a raw nat literal\nand `proof : isInt x (.negOfNat lit)`. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (α : Type u_2) → [inst : Monoid M] → [inst : MulAction M α] → α ↪ M → α",
  "name": "MulAction.toFun",
  "kind": "def",
  "doc_string":
  "Embedding of `α` into functions `M → α` induced by a multiplicative action of `M` on `α`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.applyWith",
  "kind": "def",
  "doc_string":
  "`apply (config := cfg) e` is like `apply e` but allows you to provide a configuration\n`cfg : ApplyConfig` to pass to the underlying apply operation.\n",
  "args": ""},
 {"type": "∀ {α : Sort u} (b : PLift α), { down := b.down } = b",
  "name": "PLift.up_down",
  "kind": "theorem",
  "doc_string": "Bijection between `α` and `PLift α` ",
  "args": ""},
 {"type": "{α : Type u} → ℕ → Stream' α → Stream' α",
  "name": "Stream'.drop",
  "kind": "def",
  "doc_string": "Drop first `n` elements of a stream. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Set.«term_⁻¹'_»",
  "kind": "def",
  "doc_string":
  "`f ⁻¹' t` denotes the preimage of `t : Set β` under the function `f : α → β`. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        (F : C ⥤ D) →\n          [inst_2 : CategoryTheory.Full F] →\n            [inst_3 : CategoryTheory.Faithful F] →\n              {X Y : C} → (X ⟶ Y) ≃ (Prefunctor.obj F.toPrefunctor X ⟶ Prefunctor.obj F.toPrefunctor Y)",
  "name": "CategoryTheory.equivOfFullyFaithful",
  "kind": "def",
  "doc_string":
  "If `F` is fully faithful, we have an equivalence of hom-sets `X ⟶ Y` and `F X ⟶ F Y`. ",
  "args": ""},
 {"type": "{α : Sort u} → α → id α",
  "name": "id.mk",
  "kind": "def",
  "doc_string":
  "Introduce `id` as a quasi-functor. (Note that where a lawful `Monad` or\n`Applicative` or `Functor` is needed, `Id` is the correct definition). ",
  "args": ""},
 {"type": "(V : Type u) → [inst : Quiver V] → WideSubquiver V → Type u",
  "name": "WideSubquiver.toType",
  "kind": "def",
  "doc_string":
  "A type synonym for `V`, when thought of as a quiver having only the arrows from\nsome `WideSubquiver`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "solve",
  "kind": "def",
  "doc_string":
  "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsPreorder",
  "kind": "inductive",
  "doc_string":
  "`IsPreorder X r` means that the binary relation `r` on `X` is a pre-order, that is, reflexive\nand transitive. ",
  "args": ""},
 {"type":
  "{m : Type v → Type w} → [inst : Monad m] → {α : Type u_1} → {β : Type v} → (ℕ → α → β → m β) → β → List α → m β",
  "name": "List.foldrIdxM",
  "kind": "def",
  "doc_string": "Monadic variant of `foldrIdx`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddZeroClass",
  "kind": "inductive",
  "doc_string":
  "Typeclass for expressing that a type `M` with addition and a zero satisfies\n`0 + a = a` and `a + 0 = a` for all `a : M`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CancelMonoidWithZero α] {a b c : α}, a ≠ 0 → (a * b ∣ a * c ↔ b ∣ c)",
  "name": "mul_dvd_mul_iff_left",
  "kind": "theorem",
  "doc_string":
  "Given two elements `b`, `c` of a `CancelMonoidWithZero` and a nonzero element `a`,\n`a*b` divides `a*c` iff `b` divides `c`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} (s : Set α) (r : α → α → Prop), (Pairwise fun x y => r ↑x ↑y) → Set.Pairwise s r",
  "name": "Pairwise.set_of_subtype",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `pairwise_subtype_iff_pairwise_set`.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : CommMonoid α] → CommGroup αˣ",
  "name": "Units.instCommGroupUnitsToMonoid",
  "kind": "def",
  "doc_string": "Units of a commutative monoid form a commutative group. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : CoheytingAlgebra α] (a : α), ⊤ \\ a = ￢a",
  "name": "CoheytingAlgebra.top_sdiff",
  "kind": "def",
  "doc_string": "`⊤ \\ a` is `￢a` ",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.AbelNF.Config → Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Tactic.Abel.abelNFTarget",
  "kind": "def",
  "doc_string": "Use `abel_nf` to rewrite the main goal. ",
  "args": ""},
 {"type": "∀ {R : Type u_1} [inst : AddCancelMonoid R] (g : R), IsAddRegular g",
  "name": "isAddRegular_of_addCancelMonoid",
  "kind": "theorem",
  "doc_string":
  "Elements of an add cancel monoid are regular.\nAdd cancel semigroups do not appear to exist.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Ring α] → ℤ → α",
  "name": "Int.rawCast",
  "kind": "def",
  "doc_string":
  "A \"raw int cast\" is an expression of the form:\n\n* `(Nat.rawCast lit : α)` where `lit` is a raw natural number literal\n* `(Int.rawCast (Int.negOfNat lit) : α)` where `lit` is a nonzero raw natural number literal\n\n(That is, we only actually use this function for negative integers.) This representation is used by\ntactics like `ring` to decrease the number of typeclass arguments required in each use of a number\nliteral at type `α`.\n",
  "args": ""},
 {"type":
  "(M : Type u_1) → (α : Type u_2) → [inst : AddMonoid M] → [inst : AddAction M α] → α ↪ M → α",
  "name": "AddAction.toFun",
  "kind": "def",
  "doc_string":
  "Embedding of `α` into functions `M → α` induced by an additive action of `M` on `α`. ",
  "args": ""},
 {"type":
  "∀ {G : Type u} [self : DivisionCommMonoid G] (a b : G), a * b = b * a",
  "name": "DivisionCommMonoid.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Unique M] → [inst : Unique N] → [inst : Add M] → [inst_1 : Add N] → M ≃+ N",
  "name": "AddEquiv.addEquivOfUnique",
  "kind": "def",
  "doc_string":
  "The `AddEquiv` between two `AddMonoid`s with a unique element.",
  "args": ""},
 {"type": "Linarith.Preprocessor",
  "name": "Linarith.filterComparisons",
  "kind": "def",
  "doc_string":
  "Removes any expressions that are not proofs of inequalities, equalities, or negations thereof.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (f : α → β) → (b : β) × ↑(f ⁻¹' {b}) ≃ α",
  "name": "Equiv.sigmaPreimageEquiv",
  "kind": "def",
  "doc_string":
  "`sigmaPreimageEquiv f` for `f : α → β` is the natural equivalence between\nthe type of all preimages of points under `f` and the total space `α`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : SuccOrder α] {a b : α} [inst_2 : NoMaxOrder α],\n  Order.succ a < Order.succ b → a < b",
  "name": "Order.lt_of_succ_lt_succ",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `Order.succ_lt_succ_iff`.",
  "args": ""},
 {"type": "{α : Sort u} → (α → α → Prop) → α → α → Prop",
  "name": "TC",
  "kind": "inductive",
  "doc_string":
  "The transitive closure `r⁺` of a relation `r` is the smallest relation which is\ntransitive and contains `r`. `r⁺ a z` if and only if there exists a sequence\n`a r b r ... r z` of length at least 1 connecting `a` to `z`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Type u_2} {β : Type u_3} {S : ι → Set α} {f : (i : ι) → ↑(S i) → β}\n  {hf :\n    ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j),\n      f i { val := x, property := hxi } = f j { val := x, property := hxj }}\n  {T : Set α} {hT : T ⊆ Set.unionᵢ S} (hT' : T = Set.unionᵢ S) (u : ↑T → ↑T) (ui : (i : ι) → ↑(S i) → ↑(S i)),\n  (∀ (i : ι) (x : ↑(S i)), u (Set.inclusion (_ : S i ⊆ T) x) = Set.inclusion (_ : S i ⊆ T) (ui i x)) →\n    ∀ (uβ : β → β),\n      (∀ (i : ι) (x : ↑(S i)), f i (ui i x) = uβ (f i x)) →\n        ∀ (x : ↑T),\n          Set.unionᵢLift S f hf T (_ : T ≤ Set.unionᵢ S) (u x) = uβ (Set.unionᵢLift S f hf T (_ : T ≤ Set.unionᵢ S) x)",
  "name": "Set.unionᵢLift_unary",
  "kind": "theorem",
  "doc_string":
  "`unionᵢLift_unary` is useful for proving that `unionᵢLift` is a homomorphism\nof algebraic structures when defined on the Union of algebraic subobjects.\nFor example, it could be used to prove that the lift of a collection\nof linear_maps on a union of submodules preserves scalar multiplication. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [inst_2 : Unique N] → N × M ≃+ M",
  "name": "AddEquiv.uniqueProd",
  "kind": "def",
  "doc_string":
  "Multiplying by the trivial monoid doesn't change the structure.",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} {D : Type u₂} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {F F' : C ⥤ D},\n  (F ≅ F') → ∀ {Y : D}, Y ∈ CategoryTheory.Functor.essImage F → Y ∈ CategoryTheory.Functor.essImage F'",
  "name": "CategoryTheory.Functor.essImage.ofNatIso",
  "kind": "theorem",
  "doc_string":
  "If `Y` is in the essential image of `F` then it is in the essential image of `F'` as long as\n`F ≅ F'`.\n",
  "args": ""},
 {"type":
  "∀ (α : Type u) (r : α → α → Prop) [s : IsTotalPreorder α r], IsPreorder α r",
  "name": "isTotalPreorder_isPreorder",
  "kind": "def",
  "doc_string": "Every total pre-order is a pre-order. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c : α}, a ≤ b + c → a - b ≤ c",
  "name": "sub_left_le_of_le_add",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `sub_le_iff_le_add'`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Sort u_2} {f : ι → α}, Function.Surjective f → Set.range f = Set.univ",
  "name": "Function.Surjective.range_eq",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Set.range_iff_surjective`.",
  "args": ""},
 {"type": "{α : Type u₁} → {β : Type u₂} → (α → β → Prop) → Prop",
  "name": "Relator.BiUnique",
  "kind": "def",
  "doc_string":
  "A relation is \"bi-unique\" if it is both left unique and right unique. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {φ : Type w} → {n : ℕ} → (α → β → φ) → Vector α n → Vector β n → Vector φ n",
  "name": "Vector.map₂",
  "kind": "def",
  "doc_string":
  "Mapping two vectors under a curried function of two variables. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : DivisionSemiring β] →\n      [inst_1 : Zero α] →\n        [inst_2 : Mul α] →\n          [inst_3 : Add α] →\n            [inst_4 : One α] →\n              [inst_5 : Inv α] →\n                [inst_6 : Div α] →\n                  [inst_7 : SMul ℕ α] →\n                    [inst_8 : Pow α ℕ] →\n                      [inst_9 : Pow α ℤ] →\n                        [inst_10 : NatCast α] →\n                          (f : α → β) →\n                            Function.Injective f →\n                              f 0 = 0 →\n                                f 1 = 1 →\n                                  (∀ (x y : α), f (x + y) = f x + f y) →\n                                    (∀ (x y : α), f (x * y) = f x * f y) →\n                                      (∀ (x : α), f x⁻¹ = (f x)⁻¹) →\n                                        (∀ (x y : α), f (x / y) = f x / f y) →\n                                          (∀ (x : α) (n : ℕ), f (n • x) = n • f x) →\n                                            (∀ (x : α) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                              (∀ (x : α) (n : ℤ), f (x ^ n) = f x ^ n) →\n                                                (∀ (n : ℕ), f ↑n = ↑n) → DivisionSemiring α",
  "name": "Function.Injective.divisionSemiring",
  "kind": "def",
  "doc_string": "Pullback a `DivisionSemiring` along an injective function. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → ∀ {s : Set α}, BddBelow s → BddBelow (f '' s)",
  "name": "Monotone.map_bddBelow",
  "kind": "theorem",
  "doc_string":
  "The image under a monotone function of a set which is bounded below is bounded below. See also\n`bdd_below.image2`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {p : α → Prop} → [inst : LE α] → [inst_1 : OrderBot α] → p ⊥ → OrderBot { x // p x }",
  "name": "Subtype.orderBot",
  "kind": "def",
  "doc_string": "A subtype remains a `⊥`-order if the property holds at `⊥`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (Option α → β → γ) → List α → List β → List γ × List α",
  "name": "List.map₂Right'",
  "kind": "def",
  "doc_string":
  "Right-biased version of `List.map₂`. `map₂Right' f as bs` applies `f` to each\npair of elements `aᵢ ∈ as` and `bᵢ ∈ bs`. If `as` is shorter than `bs`, `f` is\napplied to `none` for the remaining `bᵢ`. Returns the results of the `f`\napplications and the remaining `as`.\n\n```\nmap₂Right' prod.mk [1] ['a', 'b'] = ([(some 1, 'a'), (none, 'b')], [])\n\nmap₂Right' prod.mk [1, 2] ['a'] = ([(some 1, 'a')], [2])\n```\n",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Part α → Part β",
  "name": "Part.map",
  "kind": "def",
  "doc_string":
  "The map operation for `Part` just maps the value and maintains the same domain. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {C : Trunc α → Sort u_2} →\n    (q : Trunc α) → (f : (a : α) → C (Trunc.mk a)) → (∀ (a b : α), (_ : Trunc.mk a = Trunc.mk b) ▸ f a = f b) → C q",
  "name": "Trunc.recOn",
  "kind": "def",
  "doc_string":
  "A version of `Trunc.rec` taking `q : Trunc α` as the first argument. ",
  "args": ""},
 {"type": "{α : Type u_1} → Finset α → Multiset α",
  "name": "Finset.val",
  "kind": "def",
  "doc_string": "The underlying `Multiset` of a `Finset`. ",
  "args": ""},
 {"type":
  "{C : ℕ → Sort u} → (n : ℕ) → ((b : Bool) → (n : ℕ) → C (Nat.bit b n)) → C n",
  "name": "Nat.bitCasesOn",
  "kind": "def",
  "doc_string":
  "For a predicate `C : Nat → Sort _`, if instances can be\nconstructed for natural numbers of the form `bit b n`,\nthey can be constructed for any given natural number. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Relator.«term_⇒_»",
  "kind": "def",
  "doc_string": "`(R ⇒ S) f g` means `LiftFun R S f g`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_ᵃᵒᵖ»",
  "kind": "def",
  "doc_string": "Additive opposite of a type. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (n : ℕ) (a : α),\n  LinearOrderedCommGroupWithZero.zpow (Int.ofNat (Nat.succ n)) a =\n    a * LinearOrderedCommGroupWithZero.zpow (Int.ofNat n) a",
  "name": "LinearOrderedCommGroupWithZero.zpow_succ'",
  "kind": "def",
  "doc_string": "`a ^ (n + 1) = a * a ^ n` ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {l : α → β} → {u : β → α} → GaloisConnection l u → (∀ (b : β), b ≤ l (u b)) → GaloisInsertion l u",
  "name": "GaloisConnection.toGaloisInsertion",
  "kind": "def",
  "doc_string":
  "Make a `GaloisInsertion l u` from a `GaloisConnection l u` such that `∀ b, b ≤ l (u b)` ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Mul α] → ULift α ≃* α",
  "name": "ULift.MulEquiv.ulift",
  "kind": "def",
  "doc_string": "The multiplicative equivalence between `ULift α` and `α`.\n",
  "args": ""},
 {"type":
  "{M₂ : Type u_1} →\n  {M₁ : Type u_2} →\n    [inst : Neg M₁] →\n      [inst_1 : InvolutiveNeg M₂] →\n        (f : M₁ → M₂) → Function.Injective f → (∀ (x : M₁), f (-x) = -f x) → InvolutiveNeg M₁",
  "name": "Function.Injective.involutiveNeg",
  "kind": "def",
  "doc_string":
  "A type has an involutive negation if it admits a surjective map that\npreserves `-` to a type which has an involutive negation.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {p : Prop} {q : α → Prop}, (p → ∀ (x : α), q x) ↔ ∀ (x : α), p → q x",
  "name": "imp_forall_iff",
  "kind": "theorem",
  "doc_string":
  "We intentionally restrict the type of `α` in this lemma so that this is a safer to use in simp\nthan `forall_swap`. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Linarith.rearrangeComparison",
  "kind": "def",
  "doc_string":
  "`rearrangeComparison e` takes a proof `e` of an equality, inequality, or negation thereof,\nand turns it into a proof of a comparison `_ R 0`, where `R ∈ {=, ≤, <}`.\n ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Mul M] →\n      [inst_1 : Mul N] →\n        (S : Subsemigroup M) →\n          (f : M →ₙ* N) → Function.Injective ↑f → { x // x ∈ S } ≃* { x // x ∈ Subsemigroup.map f S }",
  "name": "Subsemigroup.equivMapOfInjective",
  "kind": "def",
  "doc_string":
  "A subsemigroup is isomorphic to its image under an injective function ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    (A : Type u_3) →\n      [inst : Monoid M] →\n        [inst_1 : AddMonoid A] → [inst_2 : DistribMulAction M A] → [inst_3 : Monoid N] → (N →* M) → DistribMulAction N A",
  "name": "DistribMulAction.compHom",
  "kind": "def",
  "doc_string":
  "Compose a `DistribMulAction` with a `MonoidHom`, with action `f r' • m`.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Inhabited α] → Semiquot α",
  "name": "Semiquot.univ",
  "kind": "def",
  "doc_string":
  "`univ : Semiquot α` represents an unspecified element of `univ : Set α`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} → {u : β → α} → [inst : PartialOrder β] → [inst_1 : Lattice α] → GaloisInsertion l u → Lattice β",
  "name": "GaloisInsertion.liftLattice",
  "kind": "def",
  "doc_string": "Lift the suprema and infima along a Galois insertion ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : AddMonoid M] → AddUnits M → Equiv.Perm M",
  "name": "AddUnits.addRight",
  "kind": "def",
  "doc_string":
  "Right addition of an additive unit is a permutation of the underlying type.",
  "args": ""},
 {"type": "{α : Type u} → [self : LT α] → α → α → Prop",
  "name": "LT.lt",
  "kind": "def",
  "doc_string": "The less-than relation: `x < y` ",
  "args": ""},
 {"type":
  "{β : Type v} →\n  {m : Type v → Type w} →\n    [inst : Monad m] → (β → UInt8 → m β) → β → (as : ByteArray) → optParam ℕ 0 → optParam ℕ (ByteArray.size as) → m β",
  "name": "ByteArray.foldlMUnsafe",
  "kind": "def",
  "doc_string": "See comment at `forInUnsafe` ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : PartialOrder α] → [inst : PartialOrder β] → PartialOrder (Lex (α × β))",
  "name": "Prod.Lex.partialOrder",
  "kind": "def",
  "doc_string": "Dictionary / lexicographic partial order for pairs. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : NonAssocRing α], NatCast.natCast 0 = 0",
  "name": "NonAssocRing.natCast_zero",
  "kind": "def",
  "doc_string": "The canonical map `ℕ → R` sends `0 : ℕ` to `0 : R`. ",
  "args": ""},
 {"type": "Array Lean.Meta.AbstractMVarsResult → Lean.Expr → Lean.MetaM Bool",
  "name": "Mathlib.Tactic.matchPatterns",
  "kind": "def",
  "doc_string": "Returns true if any of the patterns match the expression. ",
  "args": ""},
 {"type": "{α : Sort u} → (α → α → Prop) → Prop",
  "name": "Equivalence",
  "kind": "inductive",
  "doc_string":
  "An equivalence relation `~ : α → α → Prop` is a relation that is:\n\n* reflexive: `x ~ x`\n* symmetric: `x ~ y` implies `y ~ x`\n* transitive: `x ~ y` and `y ~ z` implies `x ~ z`\n\nEquality is an equivalence relation, and equivalence relations share many of\nthe properties of equality. In particular, `Quot α r` is most well behaved\nwhen `r` is an equivalence relation, and in this case we use `Quotient` instead.\n",
  "args": ""},
 {"type":
  "∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\n  A ≃+* B → NoZeroDivisors A",
  "name": "RingEquiv.noZeroDivisors",
  "kind": "theorem",
  "doc_string":
  "If two rings are isomorphic, and the second doesn't have zero divisors,\nthen so does the first. ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → α ≃ β → β ≃ α",
  "name": "Equiv.symm",
  "kind": "def",
  "doc_string": "Inverse of an equivalence `e : α ≃ β`. ",
  "args": ""},
 {"type": "Bool → Bool → Bool",
  "name": "xor",
  "kind": "def",
  "doc_string": "Boolean XOR ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {sα : Q(CommSemiring «$α»)} →\n      {a b : Q(«$α»)} →\n        Mathlib.Tactic.Ring.ExProd sα a → Mathlib.Tactic.Ring.ExSum sα b → Mathlib.Tactic.Ring.ExSum sα q(«$a» + «$b»)",
  "name": "Mathlib.Tactic.Ring.ExSum.add",
  "kind": "def",
  "doc_string":
  "A sum `a + b` is a polynomial if `a` is a monomial and `b` is another polynomial. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → [inst : NonUnitalNonAssocSemiring R] → R →+ AddMonoid.End R",
  "name": "AddMonoid.End.mulLeft",
  "kind": "def",
  "doc_string":
  "The left multiplication map: `(a, b) ↦ a * b`. See also `AddMonoidHom.mulLeft`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → (M →* N) → (M →* N) → Submonoid M",
  "name": "MonoidHom.eqLocusM",
  "kind": "def",
  "doc_string": "The submonoid of elements `x : M` such that `f x = g x` ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Monoid M] → (u : Mˣ) → (a b : M) → a * b = ↑u → Commute a b → Mˣ",
  "name": "Units.leftOfMul",
  "kind": "def",
  "doc_string":
  "If the product of two commuting elements is a unit, then the left multiplier is a unit. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : PredOrder α] {a b : α} [inst_2 : NoMinOrder α],\n  Order.pred a < Order.pred b → a < b",
  "name": "Order.lt_of_pred_lt_pred",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `Order.pred_lt_pred_iff`.",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : MulZeroClass R], IsRegular 0 → Subsingleton R",
  "name": "IsRegular.subsingleton",
  "kind": "theorem",
  "doc_string": "The element `0` is regular if and only if `R` is trivial. ",
  "args": ""},
 {"type": "{α : Type u_1} → Semiquot α → Set α",
  "name": "Semiquot.s",
  "kind": "def",
  "doc_string": "Set containing some element of `α`",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst : Preorder β] → (β → α) → Type (max u_1 u_2)",
  "name": "LowerAdjoint",
  "kind": "inductive",
  "doc_string":
  "A lower adjoint of `u` on the preorder `α` is a function `l` such that `l` and `u` form a Galois\nconnection. It allows us to define closure operators whose output does not match the input. In\npractice, `u` is often `(↑) : β → α`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : SemilatticeInf α] → {P : α → Prop} → (∀ ⦃x y : α⦄, P x → P y → P (x ⊓ y)) → SemilatticeInf { x // P x }",
  "name": "Subtype.semilatticeInf",
  "kind": "def",
  "doc_string":
  "A subtype forms a `⊓`-semilattice if `⊓` preserves the property.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "∀ {b : ℕ}, 1 < b → ∀ {x y : ℕ}, x ≤ b ^ y ↔ Nat.clog b x ≤ y",
  "name": "Nat.le_pow_iff_clog_le",
  "kind": "theorem",
  "doc_string": "`clog b` and `pow b` form a Galois connection. ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Semiring R] → DistribMulAction (R →+* R) R",
  "name": "RingHom.applyDistribMulAction",
  "kind": "def",
  "doc_string":
  "The tautological action by `R →+* R` on `R`.\n\nThis generalizes `Function.End.applyMulAction`. ",
  "args": ""},
 {"type": "{α : Type u_1} → WithBot α ≃ WithTop αᵒᵈ",
  "name": "WithBot.toDual",
  "kind": "def",
  "doc_string":
  "`WithBot.toDual` is the equivalence sending `⊥` to `⊤` and any `a : α` to `toDual a : αᵒᵈ`.\nSee `WithBot.toDual_top_equiv` for the related order-iso.\n",
  "args": ""},
 {"type":
  "{φ : Type w₁} → {σ : Type w₂} → {α : Type u_1} → {β : Type u_2} → (α → β → σ → σ × φ) → List α → List β → σ → σ × List φ",
  "name": "List.mapAccumr₂",
  "kind": "def",
  "doc_string":
  "Runs a function over two lists returning the intermediate results and a\na final result.\n",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Monoid α] → Type u_1",
  "name": "ConjClasses",
  "kind": "def",
  "doc_string": "The quotient type of conjugacy classes of a group. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : AddCommSemigroup N] → Add (AddHom M N)",
  "name": "AddHom.instAddAddHomToAddToAddSemigroup",
  "kind": "def",
  "doc_string":
  "Given two additive morphisms `f`, `g` to an additive commutative semigroup, `f + g` is the\nadditive morphism sending `x` to `f x + g x`. ",
  "args": ""},
 {"type":
  "(α : Sort u) → (β : Sort v) → [inst : Unique α] → [inst : Unique β] → α ≃ β",
  "name": "Equiv.equivOfUnique",
  "kind": "def",
  "doc_string": "If both `α` and `β` have a unique element, then `α ≃ β`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrder β] →\n      [inst_1 : HasSup α] →\n        [inst_2 : HasInf α] →\n          (f : α → β) →\n            Function.Injective f →\n              (∀ (x y : α), f (x ⊔ y) = max (f x) (f y)) → (∀ (x y : α), f (x ⊓ y) = min (f x) (f y)) → LinearOrder α",
  "name": "LinearOrder.lift",
  "kind": "def",
  "doc_string":
  "Transfer a `LinearOrder` on `β` to a `LinearOrder` on `α` using an injective\nfunction `f : α → β`. This version takes `[HasSup α]` and `[HasInf α]` as arguments, then uses\nthem for `max` and `min` fields. See `LinearOrder.lift'` for a version that autogenerates `min` and\n`max` fields. See note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MulOneClass M] {S T : Submonoid M}, (∀ (x : M), x ∈ S ↔ x ∈ T) → S = T",
  "name": "Submonoid.ext",
  "kind": "theorem",
  "doc_string": "Two submonoids are equal if they have the same elements. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : OrderedCancelCommMonoid α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b",
  "name": "OrderedCancelCommMonoid.mul_le_mul_left",
  "kind": "def",
  "doc_string":
  "Multiplication is monotone in an ordered cancellative commutative monoid. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_=_»",
  "kind": "def",
  "doc_string":
  "The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
  "args": ""},
 {"type": "∀ (b : ℤ), b ≤ b ^ 2",
  "name": "Int.le_self_pow_two",
  "kind": "theorem",
  "doc_string": "**Alias** of `Int.le_self_sq`.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "GeneralizedHeytingAlgebra",
  "kind": "inductive",
  "doc_string":
  "A generalized Heyting algebra is a lattice with an additional binary operation `⇨` called\nHeyting implication such that `a ⇨` is right adjoint to `a ⊓`.\n\n This generalizes `HeytingAlgebra` by not requiring a bottom element. ",
  "args": ""},
 {"type": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "name": "Equiv",
  "kind": "inductive",
  "doc_string":
  "`α ≃ β` is the type of functions from `α → β` with a two-sided inverse. ",
  "args": ""},
 {"type": "(A : Type u_1) → [inst : AddZeroClass A] → Type u_1",
  "name": "AddMonoid.End",
  "kind": "def",
  "doc_string": "The monoid of endomorphisms. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.SolveByElim.solveByElim",
  "kind": "def",
  "doc_string":
  "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `max_depth` (currently hard-coded to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs back-tracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ, attr₁, ... attrᵣ]` also applies the named lemmas, as well as\n  all lemmas tagged with the specified attributes.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* (not implemented yet) `solve_by_elim [-id_1, ... -id_n]` uses the default assumptions,\n   removing the specified ones.\n\nTODO: configurability via optional arguments.\n<!--\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n\noptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated sub-goals\n- `discharger`: a subsidiary tactic to try at each step when no lemmas apply\n  (e.g. `cc` may be helpful).\n- `preApply`: a subsidiary tactic to run at each step before applying lemmas (e.g. `intros`).\n- `accept`: a subsidiary tactic `List Expr → Tactic` that at each step,\n  before any lemmas are applied, is passed the original proof terms\n  as reported by `getGoals` when `solve_by_elim` started\n  (but which may by now have been partially solved by previous `apply` steps).\n  If the `accept` tactic fails,\n  `solve_by_elim` will abort searching the current branch and backtrack.\n  This may be used to filter results, either at every step of the search,\n  or filtering complete results\n  (by testing for the absence of metavariables, and then the filtering condition).\n-->\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.tacticRecover_",
  "kind": "def",
  "doc_string":
  "Modifier `recover` for a tactic (sequence) to debug cases where goals are closed incorrectly.\nThe tactic `recover tacs` for a tactic (sequence) tacs applies the tactics and then adds goals\nthat are not closed starting from the original ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β → γ) {x x' : α} {y y' : β}, x = x' → y = y' → f x y = f x' y'",
  "name": "congr_arg₂",
  "kind": "theorem",
  "doc_string": "**Alias** of `congrArg₂`.",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Add M] → Set M",
  "name": "Set.addCenter",
  "kind": "def",
  "doc_string": "The center of an additive magma. ",
  "args": ""},
 {"type": "{α : Type u} → ℕ → α → List α",
  "name": "List.replicate",
  "kind": "def",
  "doc_string":
  "`replicate n a` is `n` copies of `a`:\n* `replicate 5 a = [a, a, a, a, a]`\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → List α → β) → List α → List β",
  "name": "List.mapWithComplement",
  "kind": "def",
  "doc_string":
  "`List.mapWithComplement f l` is a variant of `List.mapWithPrefixSuffix`\nthat maps `f` across a list `l`.\nFor each `a ∈ l` with `l = pref ++ [a] ++ suff`, `a` is mapped to `f a (pref ++ suff)`,\ni.e., the list input to `f` is `l` with `a` removed.\nExample: if `f : Nat → list Nat → β`, `List.mapWithComplement f [1, 2, 3]` will produce the list\n`[f 1 [2, 3], f 2 [1, 3], f 3 [1, 2]]`.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : OrderedCancelCommMonoid M] → (S : Submonoid M) → OrderedCancelCommMonoid { x // x ∈ S }",
  "name": "Submonoid.toOrderedCancelCommMonoid",
  "kind": "def",
  "doc_string":
  "A submonoid of an `OrderedCancelCommMonoid` is an `OrderedCancelCommMonoid`. ",
  "args": ""},
 {"type": "Type u → Type (max u (v + 1))",
  "name": "CategoryTheory.CategoryStruct",
  "kind": "inductive",
  "doc_string":
  "A preliminary structure on the way to defining a category,\ncontaining the data, but none of the axioms. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → {r : α → α → Prop} → {s : β → β → Prop} → {t : γ → γ → Prop} → r ≺i s → s ≃r t → r ≺i t",
  "name": "PrincipalSeg.ltEquiv",
  "kind": "def",
  "doc_string":
  "Composition of a principal segment with an order isomorphism, as a principal segment ",
  "args": ""},
 {"type": "{α : Sort u_1} → [inst : Subsingleton α] → α → Unique α",
  "name": "uniqueOfSubsingleton",
  "kind": "def",
  "doc_string":
  "Given an explicit `a : α` with `Subsingleton α`, we can construct\na `Unique α` instance. This is a def because the typeclass search cannot\narbitrarily invent the `a : α` term. Nevertheless, these instances are all\nequivalent by `Unique.Subsingleton.unique`.\n\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {a b c m : ℕ}, Nat.gcd m c = 1 → a * c ≡ b * c [MOD m] → a ≡ b [MOD m]",
  "name": "Nat.ModEq.modEq_cancel_right_of_coprime",
  "kind": "theorem",
  "doc_string":
  "A common factor that's coprime with the modulus can be cancelled from a `ModEq` ",
  "args": ""},
 {"type": "ParsedProjectionData → Bool",
  "name": "ParsedProjectionData.isDefault",
  "kind": "def",
  "doc_string":
  "will simp lemmas be generated for with (without specifically naming this?) ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : IntCast R] → ℤ → R",
  "name": "Int.cast",
  "kind": "def",
  "doc_string":
  "Canonical homomorphism from the integers to any ring(-like) structure `R` ",
  "args": ""},
 {"type":
  "∀ {α β : Type u_1} (e : α ≃ β), Equiv.optionCongr e = EquivFunctor.mapEquiv Option e",
  "name": "Equiv.optionCongr_eq_equivFunctor_mapEquiv",
  "kind": "theorem",
  "doc_string":
  "When `α` and `β` are in the same universe, this is the same as the result of\n`EquivFunctor.mapEquiv`. ",
  "args": ""},
 {"type": "Type",
  "name": "Tactic.Alias.Target",
  "kind": "inductive",
  "doc_string": "An alias can be in one of three forms ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (zα : Q(Zero «$α»)) →\n      (pα : Q(PartialOrder «$α»)) →\n        (e a b : Q(«$α»)) → Q(«$a» = «$b») → Lean.MetaM (Mathlib.Meta.Positivity.Strictness zα pα e)",
  "name": "Mathlib.Meta.Positivity.compareHypEq",
  "kind": "def",
  "doc_string":
  "A variation on `assumption` when the hypothesis is `a = b` where `a` is a numeral. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : NonAssocSemiring α] → [inst_1 : NonAssocSemiring β] → (α →+* β) → α → β",
  "name": "RingHom.Simps.apply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type":
  "{U : Type u_1} → [inst : Quiver U] → {u v u' v' : U} → u = u' → v = v' → Quiver.Path u v → Quiver.Path u' v'",
  "name": "Quiver.Path.cast",
  "kind": "def",
  "doc_string": "Change the endpoints of a path using equalities. ",
  "args": ""},
 {"type": "Type u → Type u → Type u",
  "name": "MProd",
  "kind": "inductive",
  "doc_string":
  "Similar to `Prod`, but `α` and `β` are in the same universe.\nWe say `MProd` is the universe monomorphic product type.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → α → (α →o β) →o β",
  "name": "OrderHom.apply",
  "kind": "def",
  "doc_string":
  "Function application `fun f => f a` (for fixed `a`) is a monotone function from the\nmonotone function space `α →o β` to `β`. See also `Pi.evalOrderHom`.  ",
  "args": ""},
 {"type": "(α : Sort u_1) → Erased α ≃ α",
  "name": "Erased.equiv",
  "kind": "def",
  "doc_string": "Equivalence between `Erased α` and `α`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Preorder α] → {β : Type u_2} → [inst_1 : Preorder β] → β →o α →o β",
  "name": "OrderHom.const",
  "kind": "def",
  "doc_string": "Constant function bundled as a `OrderHom`. ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Add R] → R → Prop",
  "name": "IsAddRegular",
  "kind": "inductive",
  "doc_string":
  "An add-regular element is an element `c` such that addition by `c` both on the left and\non the right is injective. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : CommMonoid α] → α ≃ ConjClasses α",
  "name": "ConjClasses.mkEquiv",
  "kind": "def",
  "doc_string": "The bijection between a `CommGroup` and its `ConjClasses`. ",
  "args": ""},
 {"type":
  "{a : Lean.Level} →\n  {arg : Q(Type a)} →\n    {sα : Q(CommSemiring «$arg»)} →\n      {a_1 b : Q(«$arg»)} → Mathlib.Tactic.Ring.ExSum sα a_1 → Mathlib.Tactic.Ring.ExSum sα b → Bool",
  "name": "Mathlib.Tactic.Ring.ExSum.eq",
  "kind": "opaque",
  "doc_string":
  "Equality test for expressions. This is not a `BEq` instance because it is heterogeneous. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℤ}, Mathlib.Meta.NormNum.IsInt a n → a = ↑n",
  "name": "Mathlib.Meta.NormNum.IsInt.out",
  "kind": "def",
  "doc_string": "The element is equal to the coercion of the integer. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (r : Setoid α) → (f : α → β) → Setoid.ker f ≤ r → Function.Surjective f → Setoid β",
  "name": "Setoid.mapOfSurjective",
  "kind": "def",
  "doc_string":
  "Given a surjective function f whose kernel is contained in an equivalence relation r, the\nequivalence relation on f's codomain defined by x ≈ y ↔ the elements of f⁻¹(x) are related to\nthe elements of f⁻¹(y) by r. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {a : α}, 2 ≤ a → (1 - 1 / a)⁻¹ ≤ 2",
  "name": "sub_one_div_inv_le_two",
  "kind": "theorem",
  "doc_string": "An inequality involving `2`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), 0 = 1 ↔ ↑f 1 = 0",
  "name": "RingHom.codomain_trivial_iff_map_one_eq_zero",
  "kind": "theorem",
  "doc_string": "`f : α →+* β` has a trivial codomain iff `f 1 = 0`. ",
  "args": ""},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "name": "PProd",
  "kind": "inductive",
  "doc_string":
  "Similar to `Prod`, but `α` and `β` can be propositions.\nWe use this Type internally to automatically generate the `brecOn` recursor.\n",
  "args": ""},
 {"type":
  "{M : Type u} →\n  {N : Type v} →\n    [inst : Monoid M] → [inst_1 : Monoid N] → (f : M →* N) → (g : M → Nˣ) → (∀ (x : M), ↑(g x) = ↑f x) → M →* Nˣ",
  "name": "Units.liftRight",
  "kind": "def",
  "doc_string":
  "If a map `g : M → Nˣ` agrees with a homomorphism `f : M →* N`, then\nthis map is a monoid homomorphism too. ",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : AddLeftCancelSemigroup G] → G → G ↪ G",
  "name": "addLeftEmbedding",
  "kind": "def",
  "doc_string":
  "The embedding of a left cancellative additive semigroup into itself\nby left translation by a fixed element.",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Add M] → M → M → M → Prop",
  "name": "AddSemiconjBy",
  "kind": "def",
  "doc_string":
  "`x` is additive semiconjugate to `y` by `a` if `a + x = y + a`",
  "args": ""},
 {"type":
  "Bool →\n  Option Lean.Expr →\n    List (Lean.TSyntax `Lean.binderIdent) →\n      Mathlib.Tactic.Choose.ElimStatus → Lean.MVarId → Lean.Elab.TermElabM Lean.MVarId",
  "name": "Mathlib.Tactic.Choose.elabChoose",
  "kind": "def",
  "doc_string":
  "A loop around `choose1`. The main entry point for the `choose` tactic. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} [inst : NonUnitalNonAssocSemiring α]\n  [inst_1 : NonUnitalNonAssocSemiring β] {x : NonUnitalNonAssocSemiring γ} {δ : Type u_1}\n  {x_1 : NonUnitalNonAssocSemiring δ} (f : α →ₙ+* β) (g : β →ₙ+* γ) (h : γ →ₙ+* δ),\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)",
  "name": "NonUnitalRingHom.comp_assoc",
  "kind": "theorem",
  "doc_string": "Composition of non-unital ring homomorphisms is associative. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddSemigroup R] {a b : R},\n  IsAddRegular (a + b) ∧ IsAddRegular (b + a) ↔ IsAddRegular a ∧ IsAddRegular b",
  "name": "isAddRegular_add_and_add_iff",
  "kind": "theorem",
  "doc_string":
  "Two elements `a` and `b` are add-regular if and only if both sums `a + b` and\n`b + a` are add-regular.",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {ra : α → α → Prop} →\n      {rb : β → β → Prop} →\n        {φ : Quot ra → Quot rb → Sort u_3} →\n          (qa : Quot ra) →\n            (qb : Quot rb) →\n              (f : (a : α) → (b : β) → φ (Quot.mk ra a) (Quot.mk rb b)) →\n                (∀ {b : β} {a₁ a₂ : α}, ra a₁ a₂ → HEq (f a₁ b) (f a₂ b)) →\n                  (∀ {a : α} {b₁ b₂ : β}, rb b₁ b₂ → HEq (f a b₁) (f a b₂)) → φ qa qb",
  "name": "Quot.hrecOn₂",
  "kind": "def",
  "doc_string":
  "Recursion on two `Quotient` arguments `a` and `b`, result type depends on `⟦a⟧` and `⟦b⟧`. ",
  "args": ""},
 {"type": "Bool → Bool → Bool",
  "name": "or",
  "kind": "def",
  "doc_string":
  "`or x y`, or `x || y`, is the boolean \"or\" operation (not to be confused\nwith `Or : Prop → Prop → Prop`, which is the propositional connective).\nIt is `@[macro_inline]` because it has C-like short-circuiting behavior:\nif `x` is true then `y` is not evaluated.\n",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : Preorder α] → {s : Set α} → {a : α} → IsLeast s a → OrderBot ↑s",
  "name": "IsLeast.orderBot",
  "kind": "def",
  "doc_string":
  "If `a` is the least element of a set `s`, then subtype `s` is an order with bottom element. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type u_1} →\n    [inst : OrderedRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Neg β] →\n                [inst_6 : Sub β] →\n                  [inst_7 : SMul ℕ β] →\n                    [inst_8 : SMul ℤ β] →\n                      [inst_9 : Pow β ℕ] →\n                        [inst_10 : NatCast β] →\n                          [inst_11 : IntCast β] →\n                            (f : β → α) →\n                              Function.Injective f →\n                                f 0 = 0 →\n                                  f 1 = 1 →\n                                    (∀ (x y : β), f (x + y) = f x + f y) →\n                                      (∀ (x y : β), f (x * y) = f x * f y) →\n                                        (∀ (x : β), f (-x) = -f x) →\n                                          (∀ (x y : β), f (x - y) = f x - f y) →\n                                            (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                              (∀ (x : β) (n : ℤ), f (n • x) = n • f x) →\n                                                (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                  (∀ (n : ℕ), f ↑n = ↑n) → (∀ (n : ℤ), f ↑n = ↑n) → OrderedRing β",
  "name": "Function.Injective.orderedRing",
  "kind": "def",
  "doc_string": "Pullback an `OrderedRing` under an injective map. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "NonUnitalCommRing",
  "kind": "inductive",
  "doc_string":
  "A non-unital commutative ring is a `NonUnitalRing` with commutative multiplication. ",
  "args": ""},
 {"type": "{α : Type u} → [self : Semiring α] → ℕ → α → α",
  "name": "Semiring.npow",
  "kind": "def",
  "doc_string": "Raising to the power of a natural number. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : NonAssocRing α] → ℤ →+* α",
  "name": "Int.castRingHom",
  "kind": "def",
  "doc_string": "`coe : ℤ → α` as a `RingHom`. ",
  "args": ""},
 {"type": "(M : Type u) → [inst : AddMonoid M] → AddUnits M →+ M",
  "name": "AddUnits.coeHom",
  "kind": "def",
  "doc_string": "Coercion `AddUnits M → M` as an AddMonoid homomorphism.",
  "args": ""},
 {"type": "∀ {α : Type u_1} {s : Set α}, Set.Pairwise s ⊥ → Set.Subsingleton s",
  "name": "Set.Pairwise.subsingleton",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `Set.pairwise_bot_iff`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (t : Set β) {f : α → β},\n  Function.Surjective f → Function.Surjective (Set.restrictPreimage t f)",
  "name": "Function.Surjective.restrictPreimage",
  "kind": "theorem",
  "doc_string": "**Alias** of `Set.restrictPreimage_surjective`.",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {α : ι → Type u_2} → [S : (i : ι) → Setoid (α i)] → ((i : ι) → Quotient (S i)) → Quotient inferInstance",
  "name": "Quotient.choice",
  "kind": "def",
  "doc_string":
  "Given a function `f : Π i, Quotient (S i)`, returns the class of functions `Π i, α i` sending\neach `i` to an element of the class `f i`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b = a ∨ a < b",
  "name": "LE.le.eq_or_gt",
  "kind": "theorem",
  "doc_string": "**Alias** of `eq_or_gt_of_le`.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LE α] → α → Prop",
  "name": "IsTop",
  "kind": "def",
  "doc_string":
  "`a : α` is a top element of `α` if it is greater than or equal to any other element of `α`.\nThis predicate is roughly an unbundled version of `OrderBot`, except that a preorder may have\nseveral top elements. When `α` is linear, this is useful to make a case disjunction on\n`NoMaxOrder α` within a proof. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {α : Type u_2} → [inst : AddMonoid M] → (M →+ Additive (Function.End α)) → AddAction M α",
  "name": "AddAction.ofEndHom",
  "kind": "def",
  "doc_string":
  "The additive action induced by a hom to `Additive (Function.End α)`\n\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_∨_»",
  "kind": "def",
  "doc_string":
  "`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : Semigroup S], Transitive fun a b => ∃ c, SemiconjBy c a b",
  "name": "SemiconjBy.transitive",
  "kind": "theorem",
  "doc_string":
  "The relation “there exists an element that semiconjugates `a` to `b`” on a semigroup\nis transitive. ",
  "args": ""},
 {"type": "∀ (M : Type u) [inst : CancelMonoid M], IsCancelMul M",
  "name": "CancelMonoid.toIsCancelMul",
  "kind": "def",
  "doc_string": "Any `CancelMonoid G` satisfies `IsCancelMul G`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → Array α → Array α → Bool",
  "name": "Array.isPrefixOf",
  "kind": "def",
  "doc_string":
  "Return true iff `as` is a prefix of `bs`.\nThat is, `bs = as ++ t` for some `t : List α`.",
  "args": ""},
 {"type": "∀ {M : Type u} [self : AddMonoid M] (a : M), 0 + a = a",
  "name": "AddMonoid.zero_add",
  "kind": "def",
  "doc_string": "Zero is a left neutral element for addition ",
  "args": ""},
 {"type": "∀ {p : Prop} [dec : Decidable p], (¬p → False) → p",
  "name": "Decidable.by_contradiction",
  "kind": "theorem",
  "doc_string": "**Alias** of `Decidable.byContradiction`.",
  "args": ""},
 {"type": "{α : Type u_1} → Part α ≃ Option α",
  "name": "Part.equivOption",
  "kind": "def",
  "doc_string": "`Part α` is (classically) equivalent to `Option α`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term{_}»",
  "kind": "def",
  "doc_string":
  "`{ a, b, c }` is a set with elements `a`, `b`, and `c`.\n\nThis notation works for all types that implement `Insert` and `Singleton`.\n",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ},\n  Function.Injective2 f → ∀ (a : α), Function.Injective (f a)",
  "name": "Function.Injective2.right",
  "kind": "theorem",
  "doc_string":
  "A binary injective function is injective when only the right argument varies. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Semigroup R] {a : R} (b : R), IsLeftRegular a → (IsLeftRegular (a * b) ↔ IsLeftRegular b)",
  "name": "mul_isLeftRegular_iff",
  "kind": "theorem",
  "doc_string":
  "An element is left-regular if and only if multiplying it on the left by a left-regular element\nis left-regular. ",
  "args": ""},
 {"type": "∀ {n : ℕ}, Nat.le n n",
  "name": "Nat.le.refl",
  "kind": "def",
  "doc_string": "Less-equal is reflexive: `n ≤ n` ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Set (α → β) → Set α → Set β",
  "name": "Set.seq",
  "kind": "def",
  "doc_string":
  "Given a set `s` of functions `α → β` and `t : Set α`, `seq s t` is the union of `f '' t` over\nall `f ∈ s`. ",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : CanonicallyLinearOrderedMonoid α], ⊥ = 1",
  "name": "bot_eq_one'",
  "kind": "theorem",
  "doc_string":
  "In a linearly ordered monoid, we are happy for `bot_eq_one` to be a `@[simp]` lemma. ",
  "args": ""},
 {"type":
  "{A : Type u_1} →\n  {M₁ : Type u_2} →\n    [inst : SetLike A M₁] → [inst_1 : Zero M₁] → [hA : ZeroMemClass A M₁] → (S' : A) → Zero { x // x ∈ S' }",
  "name": "ZeroMemClass.zero",
  "kind": "def",
  "doc_string": "An `AddSubmonoid` of an `AddMonoid` inherits a zero.",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_<=_»",
  "kind": "def",
  "doc_string": "The less-equal relation: `x ≤ y` ",
  "args": ""},
 {"type":
  "{η : Type u_1} →\n  {Ms : η → Type u_2} →\n    {Ns : η → Type u_3} →\n      [inst : (j : η) → Mul (Ms j)] →\n        [inst_1 : (j : η) → Mul (Ns j)] → ((j : η) → Ms j ≃* Ns j) → ((j : η) → Ms j) ≃* ((j : η) → Ns j)",
  "name": "MulEquiv.piCongrRight",
  "kind": "def",
  "doc_string":
  "A family of multiplicative equivalences `Π j, (Ms j ≃* Ns j)` generates a\nmultiplicative equivalence between `Π j, Ms j` and `Π j, Ns j`.\n\nThis is the `MulEquiv` version of `Equiv.piCongrRight`, and the dependent version of\n`MulEquiv.arrowCongr`.\n",
  "args": ""},
 {"type": "(α : Type u) → (α → α → α) → Prop",
  "name": "IsCommutative",
  "kind": "inductive",
  "doc_string": "A commutative binary operation. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : LE α] → α ≃o αᵒᵈᵒᵈ",
  "name": "OrderIso.dualDual",
  "kind": "def",
  "doc_string": "The order isomorphism between a type and its double dual. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {F : Type u_3} →\n      [inst : Add R] →\n        [inst_1 : Add S] →\n          [inst_2 : Mul R] →\n            [inst_3 : Mul S] →\n              [inst_4 : MulEquivClass F R S] → (f : F) → (∀ (x y : R), ↑f (x + y) = ↑f x + ↑f y) → R ≃+* S",
  "name": "MulEquiv.toRingEquiv",
  "kind": "def",
  "doc_string":
  "Gives a `RingEquiv` from an element of a `MulEquivClass` preserving addition.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.RunCmd.runTac",
  "kind": "def",
  "doc_string": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
  "args": ""},
 {"type": "List String → List String",
  "name": "ToAdditive.applyNameDict",
  "kind": "def",
  "doc_string":
  "Turn each element to lower-case, apply the `nameDict` and\ncapitalize the output like the input.\n",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : AddGroup G] → G →+ Additive (AddAut G)",
  "name": "AddAut.conj",
  "kind": "def",
  "doc_string":
  "Additive group conjugation, `AddAut.conj g h = g + h - g`, as an additive monoid\nhomomorphism mapping addition in `G` into multiplication in the automorphism group `AddAut G`\n(written additively in order to define the map). ",
  "args": ""},
 {"type": "{α : Type u} → [self : OrOp α] → α → α → α",
  "name": "OrOp.or",
  "kind": "def",
  "doc_string": "The implementation of `a ||| b : α`. See `HOr`. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Linarith.typeOfIneqProof",
  "kind": "def",
  "doc_string":
  "If `prf` is a proof of `t R s`, `typeOfIneqProof prf` returns the type of `t`. ",
  "args": ""},
 {"type": "{n : ℕ} → Fin2 (Nat.succ n)",
  "name": "Fin2.fz",
  "kind": "def",
  "doc_string": "`0` as a member of `Fin (succ n)` (`Fin 0` is empty) ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : Monoid α] → (u : αˣ) → (val : α) → val = ↑u → (inv : α) → inv = ↑u⁻¹ → αˣ",
  "name": "Units.copy",
  "kind": "def",
  "doc_string": "Copy a unit, adjusting definition equalities. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → ℕ",
  "name": "List.lengthTR",
  "kind": "def",
  "doc_string":
  "A tail-recursive version of `List.length`, used to implement `List.length`\nwithout running out of stack space.\n",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → ¬b < a",
  "name": "LT.lt.asymm",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_asymm`.",
  "args": ""},
 {"type": "∀ {a b : Prop}, (¬a → ¬b) → b → a",
  "name": "Function.mtr",
  "kind": "theorem",
  "doc_string":
  "Provide the reverse of modus tollens (`mt`) as dot notation for implications. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : CompleteLattice α] (x : α), ⊥ ≤ x",
  "name": "CompleteLattice.bot_le",
  "kind": "def",
  "doc_string": "Any element is more than the bottom one. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] [self : NoBotOrder α] (a : α), ∃ b, ¬a ≤ b",
  "name": "NoBotOrder.exists_not_ge",
  "kind": "def",
  "doc_string":
  "For each term `a`, there is some `b` which is either incomparable or strictly smaller. ",
  "args": ""},
 {"type":
  "Sort u_1 → outParam (Sort u_2) → outParam (Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "name": "EmbeddingLike",
  "kind": "inductive",
  "doc_string":
  "The class `EmbeddingLike F α β` expresses that terms of type `F` have an\ninjective coercion to injective functions `α ↪ β`.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Mul R] {a : R}, IsLeftRegular a ↔ IsSMulRegular R a",
  "name": "isLeftRegular_iff",
  "kind": "theorem",
  "doc_string":
  "Left-regular multiplication on `R` is equivalent to `R`-regularity of `R` itself. ",
  "args": ""},
 {"type": "(α : Type u) → [inst : Monoid α] → Type u",
  "name": "Units",
  "kind": "inductive",
  "doc_string":
  "Units of a `Monoid`, bundled version. Notation: `αˣ`.\n\nAn element of a `Monoid` is a unit if it has a two-sided inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `IsUnit`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedAddMonoid α] (a b : α), a ≤ b ∨ b ≤ a",
  "name": "CanonicallyLinearOrderedAddMonoid.le_total",
  "kind": "def",
  "doc_string": "A linear order is total. ",
  "args": ""},
 {"type":
  "(M : Type u_1) →\n  (A : Type u_2) → [inst : Monoid M] → [inst_1 : Monoid A] → [inst_2 : MulDistribMulAction M A] → M →* Monoid.End A",
  "name": "MulDistribMulAction.toMonoidEnd",
  "kind": "def",
  "doc_string": "Each element of the monoid defines a monoid homomorphism. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] {s : Set M} {p : M → M → Prop} {x y : M},\n  x ∈ AddSubmonoid.closure s →\n    y ∈ AddSubmonoid.closure s →\n      (∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → p x y) →\n        (∀ (x : M), p 0 x) →\n          (∀ (x : M), p x 0) →\n            (∀ (x y z : M), p x z → p y z → p (x + y) z) → (∀ (x y z : M), p z x → p z y → p z (x + y)) → p x y",
  "name": "AddSubmonoid.closure_induction₂",
  "kind": "theorem",
  "doc_string":
  "An induction principle for additive closure membership for predicates with two arguments.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : PredOrder α] {a : α}, IsMin a → Order.pred a = a",
  "name": "IsMin.pred_eq",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Order.pred_eq_iff_isMin`.",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} {inst : Preorder α} {inst_1 : Preorder β} {inst_2 : MulOneClass α}\n  {inst_3 : MulOneClass β} [self : OrderMonoidHomClass F α β] (f : F), Monotone ↑f",
  "name": "OrderMonoidHomClass.monotone",
  "kind": "def",
  "doc_string": "An `OrderMonoidHom` is a monotone function. ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : MulOneClass M] → Type u_1",
  "name": "Monoid.End",
  "kind": "def",
  "doc_string": "The monoid of endomorphisms. ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} {D : Type u₂} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {F : C ⥤ D}\n  {Y Y' : D}, (Y ≅ Y') → Y ∈ CategoryTheory.Functor.essImage F → Y' ∈ CategoryTheory.Functor.essImage F",
  "name": "CategoryTheory.Functor.essImage.ofIso",
  "kind": "theorem",
  "doc_string":
  "Being in the essential image is a \"hygenic\" property: it is preserved under isomorphism. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : Add S] {a x y : S}, AddSemiconjBy a x y → a + x = y + a",
  "name": "AddSemiconjBy.eq",
  "kind": "theorem",
  "doc_string": "Equality behind `AddSemiconjBy a x y`; useful for rewriting.",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → [self : CoeOTC α β] → α → β",
  "name": "CoeOTC.coe",
  "kind": "def",
  "doc_string":
  "Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → α → Prop) → (β → β → Prop) → Type (max u_1 u_2)",
  "name": "PrincipalSeg",
  "kind": "inductive",
  "doc_string":
  "If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≺i s` is an order\nembedding whose range is an open interval `(-∞, top)` for some element `top` of `β`. Such order\nembeddings are called principal segments ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → α × β → α",
  "name": "Prod.fst",
  "kind": "def",
  "doc_string":
  "The first projection out of a pair. if `p : α × β` then `p.1 : α`. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : AddGroup G] [inst_1 : SubtractionMonoid H]\n  [inst_2 : AddMonoidHomClass F G H] (f : F) (a : G), ↑f (-a) = -↑f a",
  "name": "map_neg",
  "kind": "theorem",
  "doc_string": "Additive group homomorphisms preserve negation.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : OrderedCommMonoid α] → OrderedCommGroup αˣ",
  "name": "Units.orderedCommGroup",
  "kind": "def",
  "doc_string":
  "The units of an ordered commutative monoid form an ordered commutative group. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Sort u_3} {ι' : Sort u_2} {s : ι → ι' → Set α},\n  (Set.unionᵢ fun j => Set.interᵢ fun i => s i j) ⊆ Set.interᵢ fun i => Set.unionᵢ fun j => s i j",
  "name": "Set.unionᵢ_interᵢ_subset",
  "kind": "theorem",
  "doc_string":
  "An equality version of this lemma is `unionᵢ_interᵢ_of_monotone` in `Data.Set.Finite`. ",
  "args": ""},
 {"type":
  "Mathlib.Prelude.Rename.RenameMap → Lean.NameMap (Lean.Name × List Lean.Name)",
  "name": "Mathlib.Prelude.Rename.RenameMap.toLean3",
  "kind": "def",
  "doc_string":
  "This maps `n4 ↦ (n3, clashes)` where `n4` is the lean 4 name and `n3::clashes` is the list of\nall (non-`synthetic`) declarations that map to `n4`. (That is, we do not assume the mapping\nfrom lean 3 to lean 4 name is injective.) ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → TwoPointing α → TwoPointing β → TwoPointing (α ⊕ β)",
  "name": "TwoPointing.sum",
  "kind": "def",
  "doc_string":
  "The sum of two pointings. Keeps the first point from the left and the second point from the\nright. ",
  "args": ""},
 {"type": "Sat.Valuation → Sat.Clause → Prop → Prop",
  "name": "Sat.Clause.reify",
  "kind": "inductive",
  "doc_string": "Asserts that `¬⟦c⟧_v` implies `p`. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM (List Lean.MVarId)",
  "name": "Mathlib.Tactic.applyFunTargetFailure",
  "kind": "def",
  "doc_string": "Failure message for `applyFunTarget`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {p : α → Prop} → {q : β → Prop} → (e : α ≃ β) → (∀ (a : α), p a ↔ q (↑e a)) → { a // p a } ≃ { b // q b }",
  "name": "Equiv.subtypeEquiv",
  "kind": "def",
  "doc_string":
  "If `α` is equivalent to `β` and the predicates `p : α → Prop` and `q : β → Prop` are equivalent\nat corresponding points, then `{a // p a}` is equivalent to `{b // q b}`.\nFor the statement where `α = β`, that is, `e : perm α`, see `Perm.subtypePerm`. ",
  "args": ""},
 {"type":
  "∀ (G : Type u) [inst : CommSemigroup G] [inst_1 : IsLeftCancelMul G], IsCancelMul G",
  "name": "CommSemigroup.IsLeftCancelMul.toIsCancelMul",
  "kind": "theorem",
  "doc_string":
  "Any `CommSemigroup G` that satisfies `IsLeftCancelMul G` also satisfies\n`IsCancelMul G`. ",
  "args": ""},
 {"type": "∀ (E : Type u_1) [inst : AddCommGroup E], Subsingleton (Module ℚ E)",
  "name": "subsingleton_rat_module",
  "kind": "def",
  "doc_string":
  "There can be at most one `Module ℚ E` structure on an additive commutative group. ",
  "args": ""},
 {"type": "∀ (x y : ℕ), ↑(Nat.gcd x y) = ↑x * Nat.gcdA x y + ↑y * Nat.gcdB x y",
  "name": "Nat.gcd_eq_gcd_ab",
  "kind": "theorem",
  "doc_string":
  "**Bézout's lemma**: given `x y : ℕ`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and\n`b = gcd_b x y` are computed by the extended Euclidean algorithm.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : GeneralizedBooleanAlgebra α] (a b : α), a ⊓ b ⊓ a \\ b = ⊥",
  "name": "GeneralizedBooleanAlgebra.inf_inf_sdiff",
  "kind": "def",
  "doc_string": "For any `a`, `b`, `(a ⊓ b) ⊓ (a / b) = ⊥` ",
  "args": ""},
 {"type":
  "{α : Type u} → {p : α → Prop} → [inst : DecidablePred p] → Equiv.Perm (Subtype p) →* Equiv.Perm α",
  "name": "Equiv.Perm.ofSubtype",
  "kind": "def",
  "doc_string":
  "The inclusion map of permutations on a subtype of `α` into permutations of `α`,\nfixing the other points. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  (r : α → α → Prop) → [inst : IsStrictTotalOrder α r] → [inst : (x y : α) → Decidable ¬r x y] → LinearOrder α",
  "name": "linearOrderOfSTO",
  "kind": "def",
  "doc_string":
  "Construct a linear order from an `IsStrictTotalOrder` relation.\n\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u_1} → α → List α → α",
  "name": "List.ilast'",
  "kind": "def",
  "doc_string":
  "`ilast' x xs` returns the last element of `xs` if `xs` is non-empty; it returns `x` otherwise.\n",
  "args": ""},
 {"type": "(α : Type u_1) → Option α",
  "name": "Option.choice",
  "kind": "def",
  "doc_string":
  "An arbitrary `some a` with `a : α` if `α` is nonempty, and otherwise `none`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddZeroClass M] → (S : AddSubmonoid M) → (s : Set M) → s = ↑S → AddSubmonoid M",
  "name": "AddSubmonoid.copy",
  "kind": "def",
  "doc_string":
  "Copy an additive submonoid replacing `carrier` with a set that is equal to it.",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} → {p : α → Prop} → {q : β → Prop} → (f : α → β) → (∀ (a : α), p a → q (f a)) → Subtype p → Subtype q",
  "name": "Subtype.map",
  "kind": "def",
  "doc_string": "Restriction of a function to a function on subtypes. ",
  "args": ""},
 {"type": "ℚ → ℤ",
  "name": "Rat.ceil",
  "kind": "def",
  "doc_string":
  "The ceiling of a rational number `a` is the smallest integer greater than or equal to `a`. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₂] →\n      [inst_1 : One M₂] →\n        [inst_2 : MulOneClass M₁] →\n          (f : M₁ → M₂) → Function.Surjective f → f 1 = 1 → (∀ (x y : M₁), f (x * y) = f x * f y) → MulOneClass M₂",
  "name": "Function.Surjective.mulOneClass",
  "kind": "def",
  "doc_string":
  "A type endowed with `1` and `*` is a `MulOneClass`, if it admits a surjective map that preserves\n`1` and `*` from a `MulOneClass`. See note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → List (α × β) → List α × List β",
  "name": "List.unzipTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `unzip`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "OrderedCommSemiring",
  "kind": "inductive",
  "doc_string":
  "An `OrderedCommSemiring` is a commutative semiring with a partial order such that addition is\nmonotone and multiplication by a nonnegative number is monotone. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : Mul α] → [inst_1 : One α] → (a : α) → [self : Invertible a] → α",
  "name": "Invertible.invOf",
  "kind": "def",
  "doc_string": "The inverse of an `Invertible` element ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : NonUnitalNonAssocSemiring α] [inst_1 : NonUnitalNonAssocSemiring β]\n  (self : α →ₙ+* β), ↑self.toMulHom 0 = 0",
  "name": "NonUnitalRingHom.map_zero'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves 0 ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (f : α → β) → Function.Surjective f → Quotient (Setoid.ker f) ≃ β",
  "name": "Setoid.quotientKerEquivOfSurjective",
  "kind": "def",
  "doc_string":
  "The quotient of α by the kernel of a surjective function f bijects with f's codomain.\n\nIf a specific right-inverse of `f` is known, `Setoid.quotientKerEquivOfRightInverse` can be\ndefinitionally more useful. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → List α → Prop",
  "name": "List.Pairwise",
  "kind": "inductive",
  "doc_string":
  "`Pairwise R l` means that all the elements with earlier indexes are\n`R`-related to all the elements with later indexes.\n```\nPairwise R [1, 2, 3] ↔ R 1 2 ∧ R 1 3 ∧ R 2 3\n```\nFor example if `R = (·≠·)` then it asserts `l` has no duplicates,\nand if `R = (·<·)` then it asserts that `l` is (strictly) sorted.\n",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Mul M] → M → M → M → Prop",
  "name": "SemiconjBy",
  "kind": "def",
  "doc_string": "`x` is semiconjugate to `y` by `a`, if `a * x = y * a`. ",
  "args": ""},
 {"type": "ℚ → ℤ",
  "name": "Rat.num",
  "kind": "def",
  "doc_string": "The numerator of the rational number is an integer. ",
  "args": ""},
 {"type": "Num → Num",
  "name": "Num.bit1",
  "kind": "def",
  "doc_string":
  "`bit1 n` appends a `1` to the end of `n`, where `bit1 n = n1`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (l : List α) → l ≠ [] → α",
  "name": "List.last",
  "kind": "def",
  "doc_string": "The last element of a non-empty list. ",
  "args": ""},
 {"type": "{G₀ : Type u_1} → [inst : CommGroupWithZero G₀] → G₀ →*₀ G₀",
  "name": "invMonoidWithZeroHom",
  "kind": "def",
  "doc_string":
  "Inversion on a commutative group with zero, considered as a monoid with zero homomorphism. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : Semifield α] (a b : α), a / b = a * b⁻¹",
  "name": "Semifield.div_eq_mul_inv",
  "kind": "def",
  "doc_string": "`a / b := a * b⁻¹` ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        (F : C ⥤ D) →\n          [inst_2 : CategoryTheory.Full F] →\n            [inst_3 : CategoryTheory.Faithful F] →\n              {X Y : C} → (X ≅ Y) ≃ (Prefunctor.obj F.toPrefunctor X ≅ Prefunctor.obj F.toPrefunctor Y)",
  "name": "CategoryTheory.isoEquivOfFullyFaithful",
  "kind": "def",
  "doc_string":
  "If `F` is fully faithful, we have an equivalence of iso-sets `X ≅ Y` and `F X ≅ F Y`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {n : ℕ} (a : α) (v : Vector α n), Vector.head (Vector.cons a v) = a",
  "name": "Vector.head_cons",
  "kind": "theorem",
  "doc_string":
  "The head of a vector obtained by prepending is the element prepended. ",
  "args": ""},
 {"type": "{α : Type u_1} → Set (Set α) → Set α",
  "name": "Set.unionₛ",
  "kind": "def",
  "doc_string": "Intersection of a set of sets. ",
  "args": ""},
 {"type": "{α : Type u} → [self : Top α] → α",
  "name": "Top.top",
  "kind": "def",
  "doc_string": "The top (`⊤`, `\\top`) element ",
  "args": ""},
 {"type": "Simps.Config",
  "name": "Simps.Config.asFn",
  "kind": "def",
  "doc_string":
  "A common configuration for `@[simps]`: generate equalities between functions instead equalities\nbetween fully applied Expressions. ",
  "args": ""},
 {"type":
  "Lean.Name → ParsedProjectionData → List Lean.Level → Lean.CoreM ParsedProjectionData",
  "name": "simpsFindCustomProjection",
  "kind": "def",
  "doc_string":
  "Auxilliary function for `simpsGetRawProjections`.\nTODO: we can use something similar to `getStructureFieldsFlattened` to simplify the notation for\nthis\nFind custom projections declared by the user. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HShiftRight α β γ] → α → β → γ",
  "name": "HShiftRight.hShiftRight",
  "kind": "def",
  "doc_string":
  "`a >>> b` computes `a` shifted to the right by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat` and fixed width unsigned types like `UInt8`,\n  this is equivalent to `a / 2 ^ b`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.«tacticUse_,,»",
  "kind": "def",
  "doc_string":
  "`use e₁, e₂, ⋯` applies the tactic `refine ⟨e₁, e₂, ⋯, ?_⟩` and then tries\nto close the goal with `trivial` (which may or may not close it). It's\nuseful, for example, to advance on existential goals, for which terms as\nwell as proofs of some claims about them are expected.\n\nExamples:\n\n```lean\nexample : ∃ x : Nat, x = x := by use 42\n\nexample : ∃ x : Nat, ∃ y : Nat, x = y := by use 42, 42\n\nexample : ∃ x : String × String, x.1 = x.2 := by use (\"forty-two\", \"forty-two\")\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : LinearOrder β] {f g : α → β},\n  Monotone f → Monotone g → Monotone fun x => min (f x) (g x)",
  "name": "Monotone.min",
  "kind": "theorem",
  "doc_string":
  "Pointwise minimum of two monotone functions is a monotone function. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α",
  "name": "List.dropLast",
  "kind": "def",
  "doc_string":
  "Removes the last element of the list.\n* `dropLast [] = []`\n* `dropLast [a] = []`\n* `dropLast [a, b, c] = [a, b]`\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → (self : BinaryHeap α lt) → Fin (BinaryHeap.size self) → α → BinaryHeap α lt",
  "name": "BinaryHeap.increaseKey",
  "kind": "def",
  "doc_string":
  "`O(log n)`. Replace the value at index `i` by `x`. Assumes that `self.get i ≤ x`. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.Expr → Lean.Expr → Mathlib.Meta.NormNum.Result'",
  "name": "Mathlib.Meta.NormNum.Result'.isNat",
  "kind": "def",
  "doc_string": "Untyped version of `Result.isNat`. ",
  "args": ""},
 {"type":
  "Lean.Expr → Lean.Expr → Lean.Expr → Lean.MetaM (Option (Lean.Expr × Lean.Expr))",
  "name": "Mathlib.Tactic.getExplicitRelArg?",
  "kind": "def",
  "doc_string": "solving `tgt ← mkAppM' rel #[x, z]` given `tgt = f z` ",
  "args": ""},
 {"type": "{α : Sort u_1} → {a : α} → α",
  "name": "hidden",
  "kind": "def",
  "doc_string":
  "An identity function with its main argument implicit. This will be printed as `hidden` even\nif it is applied to a large term, so it can be used for elision,\nas done in the `elide` and `unelide` tactics. ",
  "args": ""},
 {"type":
  "∀ {n k : ℕ}, k ≤ n → Nat.factorial (n - k) * Nat.descFactorial n k = Nat.factorial n",
  "name": "Nat.factorial_mul_descFactorial",
  "kind": "theorem",
  "doc_string":
  "`n.descFactorial k = n! / (n - k)!` but without ℕ-division. See `Nat.descFactorial_eq_div`\nfor the version using ℕ-division. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_2} {R : Type u_1} [inst : Semiring R] [inst : RingHomClass F ℚ R] (f g : F), f = g",
  "name": "RingHom.ext_rat",
  "kind": "theorem",
  "doc_string":
  "Any two ring homomorphisms from `ℚ` to a semiring are equal. If the codomain is a division ring,\nthen this lemma follows from `eq_ratCast`. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {η : Type v} → (R : Type w) → (ι → η) → [inst : AddZeroClass R] → (ι → R) →+ η → R",
  "name": "Function.ExtendByZero.hom",
  "kind": "def",
  "doc_string": "`Function.extend s f 0` as a bundled hom.",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} {r : α → α → Prop} {s : β → β → Prop} [self : RelHomClass F r s] (f : F)\n  {a b : α}, r a b → s (↑f a) (↑f b)",
  "name": "RelHomClass.map_rel",
  "kind": "def",
  "doc_string": "A `RelHomClass` sends related elements to related elements ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → Semiquot α → (α → Semiquot β) → Semiquot β",
  "name": "Semiquot.bind",
  "kind": "def",
  "doc_string": "Apply a function returning a `Semiquot` to a `Semiquot`. ",
  "args": ""},
 {"type": "PosNum → PosNum → PosNum",
  "name": "PosNum.mul",
  "kind": "def",
  "doc_string": "Multiplication of two `PosNum`s. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {F : Type u_3} →\n      [inst : MulZeroOneClass M] → [inst_1 : MulZeroOneClass N] → [inst_2 : MonoidWithZeroHomClass F M N] → F → M →*₀ N",
  "name": "MonoidWithZeroHomClass.toMonoidWithZeroHom",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `MonoidWithZeroHomClass F M N` into an actual\n`MonoidWithZeroHom`. This is declared as the default coercion from `F` to `M →*₀ N`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : PartialOrder α] → [inst_1 : PartialOrder β] → α ≃o β → WithTop α ≃o WithTop β",
  "name": "OrderIso.withTopCongr",
  "kind": "def",
  "doc_string": "A version of `Equiv.optionCongr` for `WithTop`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Set α → Prop",
  "name": "StrictAntiOn",
  "kind": "def",
  "doc_string":
  "A function `f` is strictly antitone on `s` if, for all `a, b ∈ s`, `a < b` implies\n`f b < f a`. ",
  "args": ""},
 {"type": "(R : Type u_1) → [inst : Mul R] → [inst : Add R] → Type",
  "name": "RightDistribClass",
  "kind": "inductive",
  "doc_string":
  "A typeclass stating that multiplication is right distributive over addition. ",
  "args": ""},
 {"type":
  "{s : Bool} →\n  Lean.MVarId →\n    Lean.Meta.DiscrTree Lean.Name s →\n      List Lean.Expr → optParam ℕ 6 → Lean.MetaM (Option (Array (Lean.MetavarContext × List Lean.MVarId)))",
  "name": "Mathlib.Tactic.LibrarySearch.librarySearch",
  "kind": "def",
  "doc_string":
  "Try to solve the goal either by:\n* calling `solveByElim`\n* or applying a library lemma then calling  `solveByElim` on the resulting goals.\n\nIf it successfully closes the goal, returns `none`.\nOtherwise, it returns `some a`, where `a : Array (MetavarContext × List MVarId)`,\nwith an entry for each library lemma which was successfully applied,\ncontaining the metavariable context after the application, and a list of the subsidiary goals.\n\n(Always succeeds, and the metavariable context stored in the monad is reverted,\nunless the goal was completely solved.)\n\n(Note that if `solveByElim` solves some but not all subsidiary goals,\nthis is not currently tracked.)\n",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Mul M] → Bot (Subsemigroup M)",
  "name": "Subsemigroup.instBotSubsemigroup",
  "kind": "def",
  "doc_string": "The trivial subsemigroup `∅` of a magma `M`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Lattice α] → Prop",
  "name": "IsWeakUpperModularLattice",
  "kind": "inductive",
  "doc_string":
  "A weakly upper modular lattice is a lattice where `a ⊔ b` covers `a` and `b` if `a` and `b` both\ncover `a ⊓ b`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → {u : β → α} → LowerAdjoint u → Set α",
  "name": "LowerAdjoint.closed",
  "kind": "def",
  "doc_string":
  "An element `x` is closed for `l : LowerAdjoint u` if it is a fixed point: `u (l x) = x` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedAddCommGroup α] (a b : α), min a b = if a ≤ b then a else b",
  "name": "LinearOrderedAddCommGroup.min_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `minOfLe`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "name": "PosMulMono",
  "kind": "def",
  "doc_string":
  "`PosMulMono α` is an abbreviation for `CovariantClass α≥0 α (λ x y, x * y) (≤)`,\nexpressing that multiplication by nonnegative elements on the left is monotone. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : BEq α] → α → List α → Bool",
  "name": "List.notElem",
  "kind": "def",
  "doc_string": "`notElem a l` is `!(elem a l)`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} →\n        [inst : PartialOrder β] →\n          [inst_1 : Preorder α] → [inst_2 : BoundedOrder α] → GaloisInsertion l u → BoundedOrder β",
  "name": "GaloisInsertion.liftBoundedOrder",
  "kind": "def",
  "doc_string":
  "Lift the top, bottom, suprema, and infima along a Galois insertion ",
  "args": ""},
 {"type":
  "{α : Sort u} → {F : αᵒᵖ → Sort v} → ((X : α) → F (Opposite.op X)) → (X : αᵒᵖ) → F X",
  "name": "Opposite.rec",
  "kind": "def",
  "doc_string":
  "A recursor for `Opposite`. Use as `induction x using Opposite.rec`. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : LE α] → α → α → Prop",
  "name": "GE.ge",
  "kind": "def",
  "doc_string": "`a ≥ b` is an abbreviation for `b ≤ a`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a : Q(«$α»)} →\n        {b : Q(ℕ)} →\n          Mathlib.Tactic.Ring.ExBase sα a →\n            Mathlib.Tactic.Ring.ExProd Mathlib.Tactic.Ring.sℕ b →\n              Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExSum sα) q(«$a» ^ «$b»)",
  "name": "Mathlib.Tactic.Ring.evalPowAtom",
  "kind": "def",
  "doc_string":
  "The fallback case for exponentiating polynomials is to use `ExBase.toProd` to just build an\nexponent expression.\n\n* `x ^ e = x ^ e * 1 + 0`\n",
  "args": ""},
 {"type": "String → String → Lean.Name → Lean.MetaM Unit",
  "name": "Mathlib.Tactic.Sat.fromLRAT",
  "kind": "def",
  "doc_string":
  "Main entry point. Given strings `cnf` and `lrat` with unparsed file data, and a name `name`,\nadds `theorem name : type := proof` where `type` is a propositional theorem like\n`∀ (a a_1 : Prop), (¬a ∧ ¬a_1 ∨ a ∧ ¬a_1) ∨ ¬a ∧ a_1 ∨ a ∧ a_1`.\n\nAlso creates auxiliaries named `name.ctx_1` (for the CNF formula)\nand `name.proof_1` (for the LRAT proof), with `name` itself containing the reification proof. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {α : ι → Type u_2} → [inst : (i : ι) → Preorder (α i)] → Set ((i : ι) → α i) → Prop",
  "name": "IsWeakAntichain",
  "kind": "def",
  "doc_string":
  "A weak antichain in `Π i, α i` is a set such that no two distinct elements are strongly less\nthan each other. ",
  "args": ""},
 {"type":
  "ToAdditive.Config → Lean.Name → Lean.Name → Lean.Name → Lean.CoreM Unit",
  "name": "ToAdditive.transformDeclAux",
  "kind": "opaque",
  "doc_string":
  "transform the declaration `src` and all declarations `pre._proof_i` occurring in `src`\nusing the transforms dictionary.\n`replace_all`, `trace`, `ignore` and `reorder` are configuration options.\n`pre` is the declaration that got the `@[to_additive]` attribute and `tgt_pre` is the target of this\ndeclaration. ",
  "args": ""},
 {"type": "ProjectionData → Lean.Expr",
  "name": "ProjectionData.expr",
  "kind": "def",
  "doc_string":
  "An Expression used by simps for the projection. It must be definitionally equal to an original\nprojection (or a composition of multiple projections).\nThese Expressions can contain the universe parameters specified in the first argument of\n`simpsStructure`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_3} {M : Type u_2} {a : R} {s : S} [inst : SMul R M] [inst_1 : SMul R S] [inst_2 : SMul S M]\n  [inst_3 : IsScalarTower R S M], IsSMulRegular M a → IsSMulRegular M s → IsSMulRegular M (a • s)",
  "name": "IsSMulRegular.smul",
  "kind": "theorem",
  "doc_string": "The product of `M`-regular elements is `M`-regular. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.Context → Mathlib.Tactic.Abel.NormalExpr",
  "name": "Mathlib.Tactic.Abel.NormalExpr.zero'",
  "kind": "def",
  "doc_string": "Construct the normal form representing zero. ",
  "args": ""},
 {"type":
  "(α : Type u_1) →\n  (β : Type u_2) → [inst : NonUnitalNonAssocSemiring α] → [inst : NonUnitalNonAssocSemiring β] → Type (max u_1 u_2)",
  "name": "NonUnitalRingHom",
  "kind": "inductive",
  "doc_string":
  "Bundled non-unital semiring homomorphisms `α →ₙ+* β`; use this for bundled non-unital ring\nhomomorphisms too.\n\nWhen possible, instead of parametrizing results over `(f : α →ₙ+* β)`,\nyou should parametrize over `(F : Type _) [NonUnitalRingHomClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `NonUnitalRingHomClass`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Preorder α] → {a b : α} → a ≤ b → BoundedOrder ↑(Set.Icc a b)",
  "name": "Set.Icc.boundedOrder",
  "kind": "def",
  "doc_string": "`Icc a b` is a `bounded_order` whenever `a ≤ b`. ",
  "args": ""},
 {"type": "{α : Type u} → (self : Part α) → self.Dom → α",
  "name": "Part.get",
  "kind": "def",
  "doc_string": "Extract a value from a partial value given a proof of `Dom` ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : DecidableEq α] → (i : α) → (β : α → Type u_2) → ((j : α) → β j) ≃ β i × ((j : { j // j ≠ i }) → β ↑j)",
  "name": "Equiv.piSplitAt",
  "kind": "def",
  "doc_string":
  "A product of types can be split as the binary product of one of the types and the product\nof all the remaining types. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀], (fun x x_1 => x * x_1) 0 = Function.const M₀ 0",
  "name": "zero_mul_eq_const",
  "kind": "theorem",
  "doc_string": "To match `one_mul_eq_id`. ",
  "args": ""},
 {"type": "∀ {M : Type u} [self : AddRightCancelMonoid M] (a : M), a + 0 = a",
  "name": "AddRightCancelMonoid.add_zero",
  "kind": "def",
  "doc_string": "Zero is a right neutral element for addition ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : DivisionSemiring α] (n : ℕ) (a : α),\n  DivisionSemiring.zpow (Int.ofNat (Nat.succ n)) a = a * DivisionSemiring.zpow (Int.ofNat n) a",
  "name": "DivisionSemiring.zpow_succ'",
  "kind": "def",
  "doc_string": "`a ^ (n + 1) = a * a ^ n` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_4} {β' : Type u_6} {γ : Type u_5} {γ' : Type u_7} {δ : Type u_3} {ε : Type u_1} {s : Set α}\n  {t : Set β} {u : Set γ} {f : α → δ → ε} {g : β → γ → δ} {f₁ : α → β → β'} {f₂ : α → γ → γ'} {g' : β' → γ' → ε},\n  (∀ (a : α) (b : β) (c : γ), f a (g b c) = g' (f₁ a b) (f₂ a c)) →\n    Set.image2 f s (Set.image2 g t u) ⊆ Set.image2 g' (Set.image2 f₁ s t) (Set.image2 f₂ s u)",
  "name": "Set.image2_distrib_subset_left",
  "kind": "theorem",
  "doc_string":
  "The other direction does not hold because of the `s`-`s` cross terms on the RHS. ",
  "args": ""},
 {"type":
  "{a : Lean.Level} →\n  {arg : Q(Type a)} → {sα : Q(CommSemiring «$arg»)} → {a_1 : Q(«$arg»)} → Mathlib.Tactic.Ring.ExProd sα a_1 → Bool",
  "name": "Mathlib.Tactic.Ring.ExProd.isAtom",
  "kind": "def",
  "doc_string": "True if this represents an atomic expression. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : OrderBot α] {a : α}, IsAtom a → IsCoatom (↑OrderDual.toDual a)",
  "name": "IsAtom.dual",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `isCoatom_dual_iff_isAtom`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r s : Setoid α}, r ⊔ s = EqvGen.Setoid (Setoid.Rel r ⊔ Setoid.Rel s)",
  "name": "Setoid.sup_def",
  "kind": "theorem",
  "doc_string":
  "The supremum of 2 equivalence relations r and s is the equivalence closure of the\nsupremum of the underlying binary operations. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_1} {p : α → β → Prop} {x₀ x₁ : (a : α) ×' Subtype (p a)},\n  x₀.fst = x₁.fst → ↑x₀.snd = ↑x₁.snd → x₀ = x₁",
  "name": "PSigma.subtype_ext",
  "kind": "theorem",
  "doc_string":
  "A specialized ext lemma for equality of `PSigma` types over an indexed subtype. ",
  "args": ""},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "name": "Function.Bijective",
  "kind": "def",
  "doc_string":
  "A function is called bijective if it is both injective and surjective. ",
  "args": ""},
 {"type":
  "∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂} {σ' : R₂ →+* R₁}\n  [self : RingHomInvPair σ σ'], RingHom.comp σ' σ = RingHom.id R₁",
  "name": "RingHomInvPair.comp_eq",
  "kind": "def",
  "doc_string": "`σ'` is a left inverse of `σ` ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : LinearOrderedCommGroup α] →\n    {β : Type u_2} →\n      [inst_1 : One β] →\n        [inst_2 : Mul β] →\n          [inst_3 : Inv β] →\n            [inst_4 : Div β] →\n              [inst_5 : Pow β ℕ] →\n                [inst_6 : Pow β ℤ] →\n                  [inst_7 : HasSup β] →\n                    [inst_8 : HasInf β] →\n                      (f : β → α) →\n                        Function.Injective f →\n                          f 1 = 1 →\n                            (∀ (x y : β), f (x * y) = f x * f y) →\n                              (∀ (x : β), f x⁻¹ = (f x)⁻¹) →\n                                (∀ (x y : β), f (x / y) = f x / f y) →\n                                  (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                    (∀ (x : β) (n : ℤ), f (x ^ n) = f x ^ n) →\n                                      (∀ (x y : β), f (x ⊔ y) = max (f x) (f y)) →\n                                        (∀ (x y : β), f (x ⊓ y) = min (f x) (f y)) → LinearOrderedCommGroup β",
  "name": "Function.Injective.linearOrderedCommGroup",
  "kind": "def",
  "doc_string":
  "Pullback a `LinearOrderedCommGroup` under an injective map.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "name": "MulPosMono",
  "kind": "def",
  "doc_string":
  "`MulPosMono α` is an abbreviation for `CovariantClass α≥0 α (λ x y, y * x) (≤)`,\nexpressing that multiplication by nonnegative elements on the right is monotone. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → ℕ → List α",
  "name": "List.rotate'",
  "kind": "def",
  "doc_string":
  "rotate' is the same as `rotate`, but slower. Used for proofs about `rotate` ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Monoid M] → Mˣ → Equiv.Perm M",
  "name": "Units.mulLeft",
  "kind": "def",
  "doc_string":
  "Left multiplication by a unit of a monoid is a permutation of the underlying type. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : LE α] → Prop",
  "name": "NoBotOrder",
  "kind": "inductive",
  "doc_string": "Order without bottom elements. ",
  "args": ""},
 {"type": "Sort u → Sort (max 1 u)",
  "name": "Setoid",
  "kind": "inductive",
  "doc_string":
  "A setoid is a type with a distinguished equivalence relation, denoted `≈`.\nThis is mainly used as input to the `Quotient` type constructor.\n",
  "args": ""},
 {"type":
  "{A : Type u_1} → {B : Type u_2} → [inst : Add A] → [inst_1 : Add B] → A ≃+ B → AddHom A B",
  "name": "AddEquiv.toAddHom",
  "kind": "def",
  "doc_string": "The `AddHom` underlying a `AddEquiv`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "DivInvMonoid",
  "kind": "inductive",
  "doc_string":
  "A `DivInvMonoid` is a `Monoid` with operations `/` and `⁻¹` satisfying\n`div_eq_mul_inv : ∀ a b, a / b = a * b⁻¹`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b⁻¹` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b⁻¹` allows us to\navoid certain classes of unification failures, for example:\nLet `Foo X` be a type with a `∀ X, Div (Foo X)` instance but no\n`∀ X, Inv (Foo X)`, e.g. when `Foo X` is a `EuclideanDomain`. Suppose we\nalso have an instance `∀ X [Cromulent X], GroupWithZero (Foo X)`. Then the\n`(/)` coming from `GroupWithZero.div` cannot be definitionally equal to\nthe `(/)` coming from `Foo.Div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `Monoid` and Note [forgetful inheritance] for more\nexplanations on this.\n",
  "args": ""},
 {"type": "{α : Type u_1} → Semiquot α → Prop",
  "name": "Semiquot.IsPure",
  "kind": "def",
  "doc_string": "Assert that a `Semiquot` contains only one possible value. ",
  "args": ""},
 {"type": "Type → Type",
  "name": "Mathlib.Tactic.GeneralizeProofs.M",
  "kind": "def",
  "doc_string":
  "Monad used by the `generalizeProofs` tactic, carries an expr cache and state with\nnames to use and previous generalizations ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) ≃ (αᵒᵈ →o βᵒᵈ)",
  "name": "OrderHom.dual",
  "kind": "def",
  "doc_string":
  "Reinterpret a bundled monotone function as a monotone function between dual orders. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, a - b < 0 → a < b",
  "name": "lt_of_sub_neg",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `sub_neg`.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Prelude.Rename.noalign",
  "kind": "def",
  "doc_string":
  "`#noalign lean_3.def_name` will record that `lean_3.def_name` has been marked for non-porting.\nThis information is used by the [mathport](https://github.com/leanprover-community/mathport)\nutility, which will remove the declaration from the corresponding mathport file, and later\nuses of the definition will be replaced by `sorry`.\n",
  "args": ""},
 {"type":
  "∀ {M : Type u} {R : Type v} [inst : Monoid M] [inst_1 : Semiring R] [self : MulSemiringAction M R] (g : M), g • 1 = 1",
  "name": "MulSemiringAction.smul_one",
  "kind": "def",
  "doc_string": "Multipliying `1` by a scalar gives `1` ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {r : (x : α) → β x → Prop}, (∀ (x : α), ∃ y, r x y) → ∃ f, ∀ (x : α), r x (f x)",
  "name": "Classical.axiomOfChoice",
  "kind": "theorem",
  "doc_string": "the axiom of choice ",
  "args": ""},
 {"type": "∀ {α : Sort u} (self : Unique α) (a : α), a = default",
  "name": "Unique.uniq",
  "kind": "def",
  "doc_string":
  "In a `Unique` type, every term is equal to the default element (from `Inhabited`). ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Semigroup α] → Dvd α",
  "name": "semigroupDvd",
  "kind": "def",
  "doc_string":
  "There are two possible conventions for divisibility, which coincide in a `CommMonoid`.\nThis matches the convention for ordinals. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Prop",
  "name": "Antitone",
  "kind": "def",
  "doc_string": "A function `f` is antitone if `a ≤ b` implies `f b ≤ f a`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → α → α → Set α",
  "name": "Set.Icc",
  "kind": "def",
  "doc_string": "Left-closed right-closed interval ",
  "args": ""},
 {"type":
  "{M' : Type u_1} →\n  {α : Type u_2} → [inst : Monoid M'] → [inst_1 : MulAction M' α] → (S : Submonoid M') → MulAction { x // x ∈ S } α",
  "name":
  "Submonoid.instMulActionSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidToMonoid",
  "kind": "def",
  "doc_string":
  "The action by a submonoid is the action by the underlying monoid. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ) (s : Set α) (t : Set β),\n  Set.image2 f s t = Set.unionᵢ fun i => Set.unionᵢ fun h => Set.unionᵢ fun j => Set.unionᵢ fun h => {f i j}",
  "name": "Set.image2_eq_unionᵢ",
  "kind": "theorem",
  "doc_string": "The `Set.image2` version of `Set.image_eq_unionᵢ` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : OrderedCommMonoid α] → [inst_1 : OrderedCommMonoid β] → Mul (α →*o β)",
  "name":
  "OrderMonoidHom.instMulOrderMonoidHomToPreorderToPartialOrderToPreorderToPartialOrderToMulOneClassToMonoidToCommMonoidToMulOneClassToMonoidToCommMonoid",
  "kind": "def",
  "doc_string":
  "For two ordered monoid morphisms `f` and `g`, their product is the ordered monoid morphism\nsending `a` to `f a * g a`. ",
  "args": ""},
 {"type": "∀ {a c b d : Prop}, (a ↔ c) → (b ↔ d) → (a → b ↔ c → d)",
  "name": "Iff.imp",
  "kind": "theorem",
  "doc_string": "**Alias** of `imp_congr`.",
  "args": ""},
 {"type": "{α : Sort u_1} → {β : Sort u_2} → α ≃ β → Unique α ≃ Unique β",
  "name": "Equiv.uniqueCongr",
  "kind": "def",
  "doc_string":
  "If `α` is equivalent to `β`, then `Unique α` is equivalent to `Unique β`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ infₛ s",
  "name": "CompleteSemilatticeInf.le_infₛ",
  "kind": "def",
  "doc_string": "Any lower bound is less than the set infimum. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → β → α ⊕ β",
  "name": "Sum.inr",
  "kind": "def",
  "doc_string":
  "Right injection into the sum type `α ⊕ β`. If `b : β` then `.inr b : α ⊕ β`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → α ≃o β → (fun x x_1 => x < x_1) ≃r fun x x_1 => x < x_1",
  "name": "OrderIso.toRelIsoLT",
  "kind": "def",
  "doc_string": "Converts an `OrderIso` into a `RelIso (<) (<)`. ",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} {p : α → Prop} {α_1 : Type u_1} {f : α → α_1} [inst : Functor m]\n  [inst_1 : LawfulFunctor m] {x : m α}, SatisfiesM p x → SatisfiesM (fun b => ∃ a, p a ∧ b = f a) (f <$> x)",
  "name": "SatisfiesM.map_post",
  "kind": "theorem",
  "doc_string":
  "`SatisfiesM` distributes over `<$>`, strongest postcondition version.\n(Use this for reasoning forward from assumptions.)\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSSubset α] [inst_1 : IsTrans α fun x x_1 => x ⊂ x_1] {a b c : α}, a ⊂ b → b ⊂ c → a ⊂ c",
  "name": "HasSSubset.SSubset.trans",
  "kind": "theorem",
  "doc_string": "**Alias** of `ssubset_trans`.",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} (P : Prop) [inst : Decidable P] (x : ¬P → α) (y : ¬¬P → α),\n  dite (¬P) x y = dite P (fun h => y (_ : ¬¬P)) x",
  "name": "dite_not",
  "kind": "theorem",
  "doc_string":
  "Negation of the condition `P : Prop` in a `dite` is the same as swapping the branches. ",
  "args": ""},
 {"type": "(α : Type u_1) → ↑Set.univ ≃ α",
  "name": "Equiv.Set.univ",
  "kind": "def",
  "doc_string": "`univ α` is equivalent to `α`. ",
  "args": ""},
 {"type": "{α : Type u} → [self : HasSSubset α] → α → α → Prop",
  "name": "HasSSubset.SSubset",
  "kind": "def",
  "doc_string": "Strict subset relation: `a ⊂ b`  ",
  "args": ""},
 {"type":
  "{F : Type u → Type w} → {G : Type v → Type u} → {α : Type v} → Functor.Comp F G α → F (G α)",
  "name": "Functor.Comp.run",
  "kind": "def",
  "doc_string":
  "Extract a term of `F (G α)` from a term of `Comp F G α`, which is the same type. ",
  "args": ""},
 {"type":
  "{q p : Prop} → (q → p) → SlimCheck.TestResult p → optParam (Unit ⊕' (p → q)) (PSum.inl ()) → SlimCheck.TestResult q",
  "name": "SlimCheck.TestResult.imp",
  "kind": "def",
  "doc_string":
  "If `q → p`, then `¬ p → ¬ q` which means that testing `p` can allow us\nto find counter-examples to `q`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → α → List α → ℕ → Array α → List α",
  "name": "List.setTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `setTR`: `setTR.go l a xs n acc = acc.toList ++ set xs a`,\nunless `n ≥ l.length` in which case it returns `l` ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«prio(_)»",
  "kind": "def",
  "doc_string": "Parentheses are used for grouping priority expressions. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : LT α] → [inst : LT β] → LT (Lex (α ⊕ β))",
  "name": "Sum.Lex.LT",
  "kind": "def",
  "doc_string": "The linear/lexicographical `<` on a sum. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s t : Set α},\n  MonotoneOn f t → s ⊆ t → Set.Nonempty (upperBounds s ∩ t) → BddAbove (f '' s)",
  "name": "MonotoneOn.map_bddAbove",
  "kind": "theorem",
  "doc_string":
  "The image under a monotone function on a set `t` of a subset which has an upper bound in `t`\nis bounded above. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {σ : Type u_3} →\n      [inst : Add M] →\n        [inst_1 : Add N] →\n          [inst_2 : SetLike σ N] →\n            [inst_3 : AddMemClass σ N] → (f : AddHom M N) → (S : σ) → (∀ (x : M), ↑f x ∈ S) → AddHom M { x // x ∈ S }",
  "name": "AddHom.codRestrict",
  "kind": "def",
  "doc_string":
  "Restriction of an `AddSemigroup` hom to an `AddSubsemigroup` of the codomain.",
  "args": ""},
 {"type": "∀ {α : Sort u} [self : Setoid α], Equivalence Setoid.r",
  "name": "Setoid.iseqv",
  "kind": "def",
  "doc_string": "The relation `x ≈ y` is an equivalence relation. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Meta.Positivity.PositivityExt",
  "kind": "inductive",
  "doc_string": "An extension for `positivity`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : SemilatticeSup α] →\n      [inst_1 : SemilatticeSup β] → (f : α → β) → LeftOrdContinuous f → Function.Injective f → α ↪o β",
  "name": "LeftOrdContinuous.toOrderEmbedding",
  "kind": "def",
  "doc_string":
  "Convert an injective left order continuous function to an order embedding. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u₃} → [inst_2 : CategoryTheory.Category E] → C ⥤ D ⥤ E → D ⥤ C ⥤ E",
  "name": "CategoryTheory.Functor.flip",
  "kind": "def",
  "doc_string": "Flip the arguments of a bifunctor. See also `currying.lean`. ",
  "args": ""},
 {"type":
  "∀ {obj : Type u} [self : CategoryTheory.Category obj] {W X Y Z : obj} (f : W ⟶ X) (g : X ⟶ Y) (h : Y ⟶ Z),\n  (f ≫ g) ≫ h = f ≫ g ≫ h",
  "name": "CategoryTheory.Category.assoc",
  "kind": "def",
  "doc_string": "Composition in a category is associative. ",
  "args": ""},
 {"type":
  "∀ {K : Type u} [self : DivisionRing K] (n : ℕ) (a : K),\n  DivisionRing.zpow (Int.negSucc n) a = (DivisionRing.zpow (↑(Nat.succ n)) a)⁻¹",
  "name": "DivisionRing.zpow_neg'",
  "kind": "def",
  "doc_string": "`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` ",
  "args": ""},
 {"type": "∀ {α : Type u} (a : α), { down := a }.down = a",
  "name": "ULift.down_up",
  "kind": "theorem",
  "doc_string": "Bijection between `α` and `ULift.{v} α` ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tacDepIfThenElse",
  "kind": "def",
  "doc_string":
  "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : AddRightCancelMonoid α], FaithfulVAdd α α",
  "name": "AddRightCancelMonoid.faithfulVAdd",
  "kind": "def",
  "doc_string":
  "`AddMonoid.toAddAction` is faithful on additive cancellative monoids. ",
  "args": ""},
 {"type": "∀ {M : Type u} [self : Monoid M] (x : M), Monoid.npow 0 x = 1",
  "name": "Monoid.npow_zero",
  "kind": "def",
  "doc_string": "Raising to the power `(0 : ℕ)` gives `1`. ",
  "args": ""},
 {"type":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : Quot r → Sort v} →\n      (q : Quot r) → (f : (a : α) → motive (Quot.mk r a)) → (∀ (a b : α), r a b → HEq (f a) (f b)) → motive q",
  "name": "Quot.hrecOn",
  "kind": "def",
  "doc_string":
  "Heterogeneous dependent recursion principle for a quotient.\nThis may be easier to work with since it uses `HEq` instead of\nan `Eq.ndrec` in the hypothesis.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a < b → 0 < c → c * a < c * b",
  "name": "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
  "kind": "def",
  "doc_string":
  "Left multiplication by a positive element is strictly monotone. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : AddRightCancelSemigroup α] → α → ComplexShape α",
  "name": "ComplexShape.down'",
  "kind": "def",
  "doc_string":
  "The `ComplexShape` allowing differentials from `X (j+a)` to `X j`.\n(For example when `a = 1`, a homology theory indexed by `ℕ` or `ℤ`)\n",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : Mul M] → [inst : Mul N] → Type (max u_1 u_2)",
  "name": "MulHom",
  "kind": "inductive",
  "doc_string":
  "`M →ₙ* N` is the type of functions `M → N` that preserve multiplication. The `ₙ` in the notation\nstands for \"non-unital\" because it is intended to match the notation for `NonUnitalAlgHom` and\n`NonUnitalRingHom`, so a `MulHom` is a non-unital monoid hom.\n\nWhen possible, instead of parametrizing results over `(f : M →ₙ* N)`,\nyou should parametrize over `(F : Type*) [MulHomClass F M N] (f : F)`.\nWhen you extend this structure, make sure to extend `MulHomClass`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → List ℕ → List α → Array (List α) → List (List α) × List α",
  "name": "List.takeListTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `takeListTR`: `takeListTR.go as as' acc = acc.toList ++ takeList as as'`. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Linarith.leftOfIneqProof",
  "kind": "def",
  "doc_string":
  "If `prf` is a proof of `t R s`, `leftOfIneqProof prf` returns `t`. ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsRefl",
  "kind": "inductive",
  "doc_string":
  "`IsRefl X r` means the binary relation `r` on `X` is reflexive. ",
  "args": ""},
 {"type": "Inhabited NonemptyType",
  "name": "instInhabitedNonemptyType",
  "kind": "def",
  "doc_string":
  "`NonemptyType` is inhabited, because `PUnit` is a nonempty type. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  a < 1 → b < 1 → a * b < 1",
  "name": "Right.mul_lt_one'",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one'`. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₂] →\n      [inst_1 : AddCommSemigroup M₁] →\n        (f : M₁ → M₂) → Function.Surjective f → (∀ (x y : M₁), f (x + y) = f x + f y) → AddCommSemigroup M₂",
  "name": "Function.Surjective.addCommSemigroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `+` is an additive commutative semigroup, if it admits\na surjective map that preserves `+` from an additive commutative semigroup.",
  "args": ""},
 {"type": "{α : Type u} → [inst : Mul α] → α ≃* αᵃᵒᵖ",
  "name": "AddOpposite.opMulEquiv",
  "kind": "def",
  "doc_string":
  "The function `AddOpposite.op` is a multiplicative equivalence. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (f : M ≃* N) (x y : M), ↑f (x * y) = ↑f x * ↑f y",
  "name": "MulEquiv.map_mul",
  "kind": "theorem",
  "doc_string": "A multiplicative isomorphism preserves multiplication. ",
  "args": ""},
 {"type": "{α : Sort u_1} → {β : Sort u_2} → PProd α β ≃ PLift α × PLift β",
  "name": "Equiv.pprodEquivProdPLift",
  "kind": "def",
  "doc_string": "`PProd α β` is equivalent to `Plift α × Plift β` ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [self : Distrib R] (a b c : R), (a + b) * c = a * c + b * c",
  "name": "Distrib.right_distrib",
  "kind": "def",
  "doc_string": "Multiplication is right distributive over addition ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Ring α] → α → ℤ → Prop",
  "name": "Mathlib.Meta.NormNum.IsInt",
  "kind": "inductive",
  "doc_string":
  "Assert that an element of a ring is equal to the coercion of some integer. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«stx_,*,?»",
  "kind": "def",
  "doc_string":
  "`p,*,?` is shorthand for `sepBy(p, \",\", allowTrailingSep)`.\nIt parses 0 or more occurrences of `p` separated by `,`, possibly including\na trailing `,`, that is: `empty | p | p, | p,p | p,p, | p,p,p | ...`.\n\nIt produces a `nullNode` containing a `SepArray` with the interleaved parser\nresults. It has arity 1, and auto-groups its component parser if needed.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → {δ : Type u_4} → {ε : Type u_5} → (α → β → γ → δ → ε) → List α → List β → List γ → List δ → List ε",
  "name": "List.zipWith₄",
  "kind": "def",
  "doc_string": "Quaternary version of `List.zipWith`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "ShiftRight",
  "kind": "inductive",
  "doc_string":
  "The homogeneous version of `HShiftRight`: `a >>> b : α` where `a b : α`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : LE α] → [inst : LE β] → Type (max u_1 u_2)",
  "name": "OrderIso",
  "kind": "def",
  "doc_string":
  "An order isomorphism is an equivalence such that `a ≤ b ↔ (f a) ≤ (f b)`.\nThis definition is an abbreviation of `RelIso (≤) (≤)`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : AddMonoidWithOne α] → α → ℕ → Prop",
  "name": "Mathlib.Meta.NormNum.IsNat",
  "kind": "inductive",
  "doc_string":
  "Assert that an element of a semiring is equal to the coercion of some natural number. ",
  "args": ""},
 {"type": "∀ (α : Type u) (β : Type v), Nonempty (α ↪ β) ∨ Nonempty (β ↪ α)",
  "name": "Function.Embedding.total",
  "kind": "theorem",
  "doc_string":
  "The cardinals are totally ordered. See\n`Cardinal.conditionallyCompleteLinearOrderBot` for (one of) the lattice\ninstance. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {F : C → D} → [self : CategoryTheory.Functorial F] → {X Y : C} → (X ⟶ Y) → (F X ⟶ F Y)",
  "name": "CategoryTheory.Functorial.map'",
  "kind": "def",
  "doc_string": "A functorial map extends to an action on morphisms. ",
  "args": ""},
 {"type":
  "(R : Type u_1) → (M : Type u_2) → [inst : Zero R] → [inst : Zero M] → [inst : SMul R M] → Prop",
  "name": "NoZeroSMulDivisors",
  "kind": "inductive",
  "doc_string":
  "`NoZeroSMulDivisors R M` states that a scalar multiple is `0` only if either argument is `0`.\nThis a version of saying that `M` is torsion free, without assuming `R` is zero-divisor free.\n\nThe main application of `NoZeroSMulDivisors R M`, when `M` is a module,\nis the result `smul_eq_zero`: a scalar multiple is `0` iff either argument is `0`.\n\nIt is a generalization of the `NoZeroDivisors` class to heterogeneous multiplication.\n",
  "args": ""},
 {"type":
  "{I : Type u} →\n  {f : I → Type v} →\n    {γ : Type w} →\n      [inst : (i : I) → NonAssocSemiring (f i)] →\n        [inst_1 : NonAssocSemiring γ] → ((i : I) → γ →+* f i) → γ →+* (i : I) → f i",
  "name": "Pi.ringHom",
  "kind": "def",
  "doc_string":
  "A family of ring homomorphisms `f a : γ →+* β a` defines a ring homomorphism\n`Pi.ringHom f : γ →+* Π a, β a` given by `Pi.ringHom f x b = f b x`. ",
  "args": ""},
 {"type": "{α : Type u} → (α → Bool) → List α → Option α",
  "name": "List.find?",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `find? p l` returns the first element for which `p` returns true,\nor `none` if no such element is found.\n\n* `find? (· < 5) [7, 6, 5, 8, 1, 2, 6] = some 1`\n* `find? (· < 1) [7, 6, 5, 8, 1, 2, 6] = none`\n",
  "args": ""},
 {"type":
  "{A : Type u_1} →\n  {B : Type u_2} →\n    [inst : Monoid A] →\n      [inst_1 : Monoid B] → (f : A →* B) → (g : B → A) → Function.LeftInverse g ↑f → Function.RightInverse g ↑f → B →* A",
  "name": "MonoidHom.inverse",
  "kind": "def",
  "doc_string": "The inverse of a bijective `MonoidHom` is a `MonoidHom`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrderedCommGroup α] → DecidableRel fun x x_1 => x < x_1",
  "name": "LinearOrderedCommGroup.decidable_lt",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (f : M ≃+ N) (x y : M), ↑f (x + y) = ↑f x + ↑f y",
  "name": "AddEquiv.map_add",
  "kind": "theorem",
  "doc_string": "An additive isomorphism preserves addition.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulMono α],\n  a < 1 → b ≤ 1 → 0 ≤ a → a * b < 1",
  "name": "Left.mul_lt_of_lt_of_le_one_of_nonneg",
  "kind": "theorem",
  "doc_string": "Assumes left covariance. ",
  "args": ""},
 {"type": "Linarith.Comp → ℕ → ℤ",
  "name": "Linarith.Comp.coeffOf",
  "kind": "def",
  "doc_string":
  "`c.coeffOf a` projects the coefficient of variable `a` out of `c`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {p : α → Prop} → (∀ (x : α), p x) → Subtype p ≃ α",
  "name": "Equiv.subtypeUnivEquiv",
  "kind": "def",
  "doc_string":
  "If a proposition holds for all elements, then the subtype is\nequivalent to the original type. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Monoid M] → CommMonoid { x // x ∈ Submonoid.center M }",
  "name":
  "Submonoid.instCommMonoidSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidCenter",
  "kind": "def",
  "doc_string": "The center of a monoid is commutative. ",
  "args": ""},
 {"type":
  "∀ {γ : Type w} [inst : LinearOrder γ] {a b : γ} {s t : Set γ},\n  IsGreatest s a → IsGreatest t b → IsGreatest (s ∪ t) (max a b)",
  "name": "IsGreatest.union",
  "kind": "theorem",
  "doc_string":
  "If `a` is the greatest element of `s` and `b` is the greatest element of `t`,\nthen `max a b` is the greatest element of `s ∪ t`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : SuccOrder α] {a : α}, IsMax a → Order.succ a = a",
  "name": "IsMax.succ_eq",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Order.succ_eq_iff_isMax`.",
  "args": ""},
 {"type": "{α : Type u} → [inst : BEq α] → List α → α → Bool",
  "name": "List.contains",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `elem a l` or `l.contains a` is true if there is an element in `l` equal to `a`.\n\n* `elem 3 [1, 4, 2, 3, 3, 7] = true`\n* `elem 5 [1, 4, 2, 3, 3, 7] = false`\n",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → (M →* N) → M → N",
  "name": "MonoidHom.Simps.apply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type": "{σ : Type u} → σ → PUnit → σ",
  "name": "EStateM.dummyRestore",
  "kind": "def",
  "doc_string": "The `restore` implementation for `Backtrackable PUnit σ`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] → (f : M →+ N) → (∀ (x y : M), AddCommute (↑f x) (↑f y)) → M →+ Nᵃᵒᵖ",
  "name": "AddMonoidHom.toOpposite",
  "kind": "def",
  "doc_string":
  "An additive monoid homomorphism `f : M →+ N` such that `f x` additively commutes\nwith `f y` for all `x, y` defines an additive monoid homomorphism to `Sᵃᵒᵖ`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : StrictOrderedSemiring α] {a b c d : α} [inst_1 : ExistsAddOfLE α],\n  a < b → c < d → a * d + b * c < a * c + b * d",
  "name": "mul_add_mul_lt_mul_add_mul",
  "kind": "theorem",
  "doc_string": "Binary strict **rearrangement inequality**. ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Add M] → M ≃+ M",
  "name": "AddEquiv.refl",
  "kind": "def",
  "doc_string": "The identity map is an additive isomorphism.",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.Context → ℤ → Lean.MetaM Lean.Expr",
  "name": "Mathlib.Tactic.Abel.Context.intToExpr",
  "kind": "def",
  "doc_string": "Interpret an integer as a coefficient to a term. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b c x : α}, a ⋖ b → b ⋖ c → a < x → x < c → x = b",
  "name": "Covby.eq_of_between",
  "kind": "theorem",
  "doc_string":
  "If `a`, `b`, `c` are consecutive and `a < x < c` then `x = b`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder β] → (α → β) → Preorder α",
  "name": "Preorder.lift",
  "kind": "def",
  "doc_string":
  "Transfer a `Preorder` on `β` to a `Preorder` on `α` using a function `f : α → β`.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 → ∀ (a : M₀), a = 0",
  "name": "eq_zero_of_zero_eq_one",
  "kind": "theorem",
  "doc_string":
  "In a monoid with zero, if zero equals one, then zero is the only element. ",
  "args": ""},
 {"type":
  "∀ (M : Type u_1) (N : Type u_2) (α : Type u_3) [inst : SMul M α] [inst_1 : SMul N α] [inst_2 : SMulCommClass M N α],\n  SMulCommClass N M α",
  "name": "SMulCommClass.symm",
  "kind": "theorem",
  "doc_string":
  "Commutativity of actions is a symmetric relation. This lemma can't be an instance because this\nwould cause a loop in the instance search graph. ",
  "args": ""},
 {"type":
  "{M₀ : Type u_1} →\n  {M₀' : Type u_2} →\n    [inst : Zero M₀'] →\n      [inst_1 : Mul M₀'] →\n        [inst_2 : SemigroupWithZero M₀] →\n          (f : M₀' → M₀) →\n            Function.Injective f → f 0 = 0 → (∀ (x y : M₀'), f (x * y) = f x * f y) → SemigroupWithZero M₀'",
  "name": "Function.Injective.semigroupWithZero",
  "kind": "def",
  "doc_string":
  "Pullback a `SemigroupWithZero` along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {E : Sort u_2} {α : Sort u_3} {β : Sort u_1} [iE : EquivLike E α β] (e : E) (b : β), ↑e (EquivLike.inv e b) = b",
  "name": "EquivLike.apply_inv_apply",
  "kind": "theorem",
  "doc_string":
  "This lemma is only supposed to be used in the generic context, when working with instances\nof classes extending `EquivLike`.\nFor concrete isomorphism types such as `Equiv`, you should use `Equiv.apply_symm_apply`\nor its equivalent.\n\nTODO: define a generic form of `Equiv.symm`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b c d : α},\n  min a b < max c d → min c d < max a b → Set.Icc a b ∪ Set.Icc c d = Set.Icc (min a c) (max b d)",
  "name": "Set.Icc_union_Icc",
  "kind": "theorem",
  "doc_string":
  "We cannot replace `<` by `≤` in the hypotheses.\nOtherwise for `b < a = d < c` the l.h.s. is `∅` and the r.h.s. is `{a}`.\n",
  "args": ""},
 {"type":
  "∀ {M : Type u} [self : RightCancelMonoid M] (x : M), RightCancelMonoid.npow 0 x = 1",
  "name": "RightCancelMonoid.npow_zero",
  "kind": "def",
  "doc_string": "Raising to the power `(0 : ℕ)` gives `1`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} (self : r ≺i s) (b : β),\n  s b self.top ↔ ∃ a, ↑self.toRelEmbedding.toEmbedding a = b",
  "name": "PrincipalSeg.down'",
  "kind": "def",
  "doc_string":
  "The image of the order embedding is the set of elements `b` such that `s b top` ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : Mul M] → [inst_1 : Mul N] → M × N →ₙ* N",
  "name": "MulHom.snd",
  "kind": "def",
  "doc_string":
  "Given magmas `M`, `N`, the natural projection homomorphism from `M × N` to `N`.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CanonicallyLinearOrderedMonoid",
  "kind": "inductive",
  "doc_string":
  "A canonically linear-ordered monoid is a canonically ordered monoid\nwhose ordering is a linear order. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → (p q : α → Prop) → { x // q ↑x } ≃ { x // p x ∧ q x }",
  "name": "Equiv.subtypeSubtypeEquivSubtypeInter",
  "kind": "def",
  "doc_string":
  "A subtype of a subtype is equivalent to the subtype of elements satisfying both predicates. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : Nontrivial M] → [hM : CommMonoidWithZero M] → (∀ (a : M), IsUnit a ∨ a = 0) → CommGroupWithZero M",
  "name": "commGroupWithZeroOfIsUnitOrEqZero",
  "kind": "def",
  "doc_string":
  "Constructs a `CommGroupWithZero` structure on a `CommMonoidWithZero`\nconsisting only of units and 0. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a : α}, 1 < a⁻¹ → a < 1",
  "name": "inv_of_one_lt_inv",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `Left.one_lt_inv_iff`.",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → a + b = b + a",
  "name": "AddCommute.eq",
  "kind": "theorem",
  "doc_string": "Equality behind `add_commute a b`; useful for rewriting.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (self : AddSubmonoid M), 0 ∈ self.toAddSubsemigroup.carrier",
  "name": "AddSubmonoid.zero_mem'",
  "kind": "def",
  "doc_string": "An additive submonoid contains `0`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : NonUnitalNonAssocSemiring α] → [inst_1 : NonUnitalNonAssocSemiring β] → (α →ₙ+* β) → α →+ β",
  "name": "NonUnitalRingHom.toAddMonoidHom",
  "kind": "def",
  "doc_string":
  "Reinterpret a non-unital ring homomorphism `f : α →ₙ+* β` as an additive\nmonoid homomorphism `α →+ β`. The `simp`-normal form is `(f : α →+ β)`. ",
  "args": ""},
 {"type": "(G : Type u) → [inst : Mul G] → Prop",
  "name": "IsLeftCancelMul",
  "kind": "inductive",
  "doc_string": "A mixin for left cancellative multiplication. ",
  "args": ""},
 {"type": "Lean.FromJson ℚ",
  "name": "Mathlib.Tactic.Polyrith.instFromJsonRat",
  "kind": "def",
  "doc_string":
  "A JSON parser for `ℚ` specific to the return value of `polyrith_sage.py`. ",
  "args": ""},
 {"type": "ℕ → Prop",
  "name": "Nat.isValidChar",
  "kind": "def",
  "doc_string":
  "A `Nat` denotes a valid unicode codepoint if it is less than `0x110000`, and\nit is also not a \"surrogate\" character (the range `0xd800` to `0xdfff` inclusive).\n",
  "args": ""},
 {"type": "Type u → Type v → Type (max u v)",
  "name": "PEquiv",
  "kind": "inductive",
  "doc_string":
  "A `PEquiv` is a partial equivalence, a representation of a bijection between a subset\n  of `α` and a subset of `β`. See also `LocalEquiv` for a version that requires `toFun` and\n`invFun` to be globally defined functions and has `source` and `target` sets as extra fields. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  0 ≤ a → 0 ≤ b → 0 ≤ a + b",
  "name": "Right.add_nonneg",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_nonneg`.",
  "args": ""},
 {"type":
  "∀ {R : Type u} [self : AddGroupWithOne R] (n : ℕ), IntCast.intCast ↑n = ↑n",
  "name": "AddGroupWithOne.intCast_ofNat",
  "kind": "def",
  "doc_string":
  "The canonical homorphism `ℤ → R` agrees with the one from `ℕ → R` on `ℕ`. ",
  "args": ""},
 {"type": "ℕ → ℕ → Bool",
  "name": "Nat.blt",
  "kind": "def",
  "doc_string": "Boolean less-than of natural numbers. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → {δ : Type u_4} → (α → β → γ → δ) → List α → List β → List γ → List δ",
  "name": "List.zipWith3",
  "kind": "def",
  "doc_string": "Ternary version of `List.zipWith`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → Set α → Set α → Prop",
  "name": "SuperChain",
  "kind": "def",
  "doc_string":
  "`SuperChain s t` means that `t` is a chain that strictly includes `s`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → Option (α × List α)",
  "name": "List.next?",
  "kind": "def",
  "doc_string": "Get the head and tail of a list, if it is nonempty. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (zα : Q(Zero «$α»)) →\n      (pα : Q(PartialOrder «$α»)) → (e : Q(«$α»)) → Lean.MetaM (Mathlib.Meta.Positivity.Strictness zα pα e)",
  "name": "Mathlib.Meta.Positivity.positivityCanon",
  "kind": "def",
  "doc_string":
  "Attempts to prove that `e ≥ 0` using `zero_le` in a `CanonicallyOrderedAddMonoid`. ",
  "args": ""},
 {"type":
  "∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} {M : Type u_4} [inst : VAdd α M] [inst_1 : VAdd β M]\n  [inst_2 : VAddCommClass α β M], VAddCommClass α β (ι → M)",
  "name": "Function.vaddCommClass",
  "kind": "def",
  "doc_string":
  "Non-dependent version of `Pi.vaddCommClass`. Lean gets confused by the dependent\ninstance if this is not present.",
  "args": ""},
 {"type":
  "∀ {R : Type u} [inst : CommSemiring R] [inst_1 : Nontrivial R] {p : Fin 2 → R}, IsCoprime (p 0) (p 1) → p ≠ 0",
  "name": "IsCoprime.ne_zero",
  "kind": "theorem",
  "doc_string":
  "If a 2-vector `p` satisfies `IsCoprime (p 0) (p 1)`, then `p ≠ 0`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : MulOneClass α] → [inst_1 : MulOneClass β] → (α →* β) → (I : Type u_3) → (I → α) →* I → β",
  "name": "MonoidHom.compLeft",
  "kind": "def",
  "doc_string":
  "Monoid homomorphism between the function spaces `I → α` and `I → β`, induced by a monoid\nhomomorphism `f` between `α` and `β`. ",
  "args": ""},
 {"type": "{α : Type u} → α → α → α → Array α",
  "name": "Array.mkArray3",
  "kind": "def",
  "doc_string": "Create array `#[a₁, a₂, a₃]` ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → α) → Prop",
  "name": "IsAssociative",
  "kind": "inductive",
  "doc_string": "An associative binary operation. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Prod.Lex.«term_×ₗ_»",
  "kind": "def",
  "doc_string": "A type synonym to equip a type with its lexicographic order. ",
  "args": ""},
 {"type":
  "∀ {as ps : List Prop} {p : Prop} (as₁ : List Prop),\n  as = List.reverseAux as₁ ps → Sat.Valuation.implies (Sat.Valuation.mk as) p ps (List.length as₁) → p",
  "name": "Sat.Valuation.mk_implies",
  "kind": "theorem",
  "doc_string":
  "The fundamental relationship between `mk` and `implies`:\n`(mk ps).implies p ps 0` is equivalent to `p`. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {R : ι → Type u_2} →\n    {S : ι → Type u_3} →\n      [inst : (i : ι) → NonUnitalNonAssocSemiring (R i)] →\n        [inst_1 : (i : ι) → NonUnitalNonAssocSemiring (S i)] →\n          ((i : ι) → R i ≃+* S i) → ((i : ι) → R i) ≃+* ((i : ι) → S i)",
  "name": "RingEquiv.piCongrRight",
  "kind": "def",
  "doc_string":
  "A family of ring isomorphisms `∀ j, (R j ≃+* S j)` generates a\nring isomorphisms between `∀ j, R j` and `∀ j, S j`.\n\nThis is the `RingEquiv` version of `Equiv.piCongrRight`, and the dependent version of\n`RingEquiv.arrowCongr`.\n",
  "args": ""},
 {"type": "∀ {α : Type u} [self : SemilatticeInf α] (a b : α), a ⊓ b ≤ a",
  "name": "SemilatticeInf.inf_le_left",
  "kind": "def",
  "doc_string": "The infimum is a lower bound on the first argument ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → PProd α β → α",
  "name": "PProd.fst",
  "kind": "def",
  "doc_string":
  "The first projection out of a pair. if `p : PProd α β` then `p.1 : α`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {σ : α → Type u_2} → List α → ((a : α) → List (σ a)) → List ((a : α) × σ a)",
  "name": "List.sigma",
  "kind": "def",
  "doc_string":
  "`sigma l₁ l₂` is the list of dependent pairs `(a, b)` where `a ∈ l₁` and `b ∈ l₂ a`.\n```\nsigma [1, 2] (λ_, [(5 : Nat), 6]) = [(1, 5), (1, 6), (2, 5), (2, 6)]\n``` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} {f : α ≃. β},\n  (∀ (a : α), Option.isSome (PEquiv.toFun f a) = true) → Function.Injective f.toFun",
  "name": "PEquiv.injective_of_forall_isSome",
  "kind": "theorem",
  "doc_string":
  "If the domain of a `PEquiv` is all of `α`, its forward direction is injective. ",
  "args": ""},
 {"type": "{α : Type u_1} → {s t : Set α} → s = t → ↑s ≃ ↑t",
  "name": "Equiv.setCongr",
  "kind": "def",
  "doc_string": "The subtypes corresponding to equal sets are equivalent. ",
  "args": ""},
 {"type": "∀ {α : Sort u_1}, ¬Infinite α → Finite α",
  "name": "Finite.of_not_infinite",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `not_infinite_iff_finite`.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.RingNF.convRing!",
  "kind": "def",
  "doc_string":
  "The tactic `ring` evaluates expressions in *commutative* (semi)rings.\nThis is the conv tactic version, which rewrites a target which is a ring equality to `True`.\n\nSee also the `ring` tactic.\n",
  "args": ""},
 {"type": "ℕ → ℕ+",
  "name": "Nat.toPNat'",
  "kind": "def",
  "doc_string":
  "Convert a natural number to a `PNat`. `n+1` is mapped to itself,\nand `0` becomes `1`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HDiv α β γ] → α → β → γ",
  "name": "HDiv.hDiv",
  "kind": "def",
  "doc_string":
  "`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat` and `Int`, `a / b` rounds toward 0.\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. ",
  "args": ""},
 {"type":
  "(p : Prop) →\n  [inst : SlimCheck.Testable p] →\n    optParam SlimCheck.Configuration\n        { numInst := 100, maxSize := 100, numRetries := 10, traceDiscarded := false, traceSuccesses := false,\n          traceShrink := false, traceShrinkCandidates := false, randomSeed := none, quiet := false } →\n      BaseIO (SlimCheck.TestResult p)",
  "name": "SlimCheck.Testable.checkIO",
  "kind": "def",
  "doc_string":
  "Run a test suite for `p` in `BaseIO` using the global RNG in `stdGenRef`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [self : SuccOrder α] {a b : α}, a < b → SuccOrder.succ a ≤ b",
  "name": "SuccOrder.succ_le_of_lt",
  "kind": "def",
  "doc_string":
  "Proof that `succ` satifies ordering invariants betweeen `LT` and `LE`",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} →\n  {ε : Type u_3} → {α : Type u_1} → [inst : Monad m] → [inst : MonadExcept ε m] → Except ε α → m α",
  "name": "MonadExcept.ofExcept",
  "kind": "def",
  "doc_string":
  "\"Unwraps\" an `Except ε α` to get the `α`, or throws the exception otherwise. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : AddZeroClass M] → { x // x ∈ ⊤ } ≃+ M",
  "name": "AddSubmonoid.topEquiv",
  "kind": "def",
  "doc_string":
  "The top additive submonoid is isomorphic to the additive monoid.",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_^_»",
  "kind": "def",
  "doc_string":
  "`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "{F : Type u_1} →\n  {α : Type u_2} → {β : Type u_3} → [inst : Mul α] → [inst_1 : Mul β] → [inst_2 : MulEquivClass F α β] → F → α ≃* β",
  "name": "MulEquivClass.toMulEquiv",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `MulEquivClass F α β` into an actual\n`MulEquiv`. This is declared as the default coercion from `F` to `α ≃* β`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : AddZeroClass N] → Zero (AddHom M N)",
  "name": "instZeroAddHomToAdd",
  "kind": "def",
  "doc_string":
  "`0` is the additive homomorphism sending all elements to `0`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : OrderedAddCommMonoid M] →\n    {A : Type u_2} →\n      [inst_1 : SetLike A M] → [inst : AddSubmonoidClass A M] → (S : A) → OrderedAddCommMonoid { x // x ∈ S }",
  "name": "AddSubmonoidClass.toOrderedAddCommMonoid",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of an `OrderedAddCommMonoid` is an `OrderedAddCommMonoid`.",
  "args": ""},
 {"type": "∀ {α : Type u_1} {s : Set α} (p : ↑s), ↑p ∈ s",
  "name": "Subtype.mem",
  "kind": "theorem",
  "doc_string": "See also `subtype.prop` ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : AddZeroClass M] → M →+ M",
  "name": "AddMonoidHom.id",
  "kind": "def",
  "doc_string": "The identity map from an additive monoid to itself. ",
  "args": ""},
 {"type": "{α : Sort u_1} → {β : Sort u_2} → [inst : Nonempty β] → (α → β) → β",
  "name": "Function.sometimes",
  "kind": "def",
  "doc_string":
  "`sometimes f` evaluates to some value of `f`, if it exists. This function is especially\ninteresting in the case where `α` is a proposition, in which case `f` is necessarily a\nconstant function, so that `sometimes f = f a` for all `a`. ",
  "args": ""},
 {"type": "∀ (p : Prop) [inst : Decidable p], Heyting.IsRegular p",
  "name": "Heyting.isRegular_of_decidable",
  "kind": "theorem",
  "doc_string":
  "A decidable proposition is intuitionistically Heyting-regular. ",
  "args": ""},
 {"type": "(V : Type u_1) → [inst : Quiver V] → V ⥤q V",
  "name": "Prefunctor.id",
  "kind": "def",
  "doc_string": "The identity morphism between quivers. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {sα : Q(CommSemiring «$α»)} →\n      {e : Q(«$α»)} → Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExProd sα) e → Mathlib.Tactic.Ring.Overlap sα e",
  "name": "Mathlib.Tactic.Ring.Overlap.nonzero",
  "kind": "def",
  "doc_string":
  "The expression `e` (the sum of monomials) is equal to another monomial\n(with nonzero leading coefficient). ",
  "args": ""},
 {"type": "{α : Type u_1} → (p : Prop) → (p → Part α) → Part α",
  "name": "Part.assert",
  "kind": "def",
  "doc_string":
  "`assert p f` is a bind-like operation which appends an additional condition\n`p` to the domain and uses `f` to produce the value. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α} (a : α), List.Sublist l₁ l₂ → List.Sublist (a :: l₁) (a :: l₂)",
  "name": "List.Sublist.cons₂",
  "kind": "def",
  "doc_string":
  "If `l₁` is a subsequence of `l₂`, then `a :: l₁` is a subsequence of `a :: l₂`. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "LinearOrderedField",
  "kind": "inductive",
  "doc_string":
  "A linear ordered field is a field with a linear order respecting the operations. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : CommSemigroup N] → Mul (M →ₙ* N)",
  "name": "MulHom.instMulMulHomToMulToSemigroup",
  "kind": "def",
  "doc_string":
  "Given two mul morphisms `f`, `g` to a commutative semigroup, `f * g` is the mul morphism\nsending `x` to `f x * g x`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Ring α] → Ring.TotalPositiveCone α → Ring.PositiveCone α",
  "name": "Ring.TotalPositiveCone.toPositiveCone_1",
  "kind": "def",
  "doc_string": "Forget that a `TotalPositiveCone` in a ring is total. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : CanonicallyLinearOrderedSemifield α] → DecidableRel fun x x_1 => x ≤ x_1",
  "name": "CanonicallyLinearOrderedSemifield.decidable_le",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "(num : ℤ) → (den g : ℕ) → den / g ≠ 0 → Nat.coprime (Int.natAbs (Int.div num ↑g)) (den / g) → ℚ",
  "name": "Rat.maybeNormalize",
  "kind": "def",
  "doc_string":
  "Auxiliary definition for `Rat.normalize`. Constructs `num / den` as a rational number,\ndividing both `num` and `den` by `g` (which is the gcd of the two) if it is not 1.\n",
  "args": ""},
 {"type": "∀ {M₀ : Type u} [self : MonoidWithZero M₀] (a : M₀), 0 * a = 0",
  "name": "MonoidWithZero.zero_mul",
  "kind": "def",
  "doc_string": "Zero is a left absorbing element for multiplication ",
  "args": ""},
 {"type": "Bool → ℤ → ℤ",
  "name": "Int.bit",
  "kind": "def",
  "doc_string":
  "`bit b` appends the digit `b` to the binary representation of\nits integer input. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Mul M] → {N : Type u_2} → [inst_1 : Mul N] → (f : M →ₙ* N) → M →ₙ* { x // x ∈ MulHom.srange f }",
  "name": "MulHom.srangeRestrict",
  "kind": "def",
  "doc_string":
  "Restriction of a semigroup hom to its range interpreted as a subsemigroup. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : SemilatticeInf α] (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "name": "SemilatticeInf.le_inf",
  "kind": "def",
  "doc_string": "The infimum is the *greatest* lower bound ",
  "args": ""},
 {"type": "{R : Type u} → [self : IntCast R] → ℤ → R",
  "name": "IntCast.intCast",
  "kind": "def",
  "doc_string": "The canonical map `ℤ → R`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {p : α → β → Prop} {x₀ x₁ : (a : α) × Subtype (p a)},\n  x₀.fst = x₁.fst → ↑x₀.snd = ↑x₁.snd → x₀ = x₁",
  "name": "Sigma.subtype_ext",
  "kind": "theorem",
  "doc_string":
  "A specialized ext lemma for equality of sigma types over an indexed subtype. ",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} → {α : Type u_3} → {β : Type u_1} → [inst : Monad m] → (α → α → m β) → List α → m (List β)",
  "name": "List.mapDiagM",
  "kind": "def",
  "doc_string":
  "`mapDiagM f l` calls `f` on all elements in the upper triangular part of `l × l`.\nThat is, for each `e ∈ l`, it will run `f e e` and then `f e e'`\nfor each `e'` that appears after `e` in `l`.\n```\nmapDiagM f [1, 2, 3] =\n  return [← f 1 1, ← f 1 2, ← f 1 3, ← f 2 2, ← f 2 3, ← f 3 3]\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, b ≤ a → 0 ≤ a - b",
  "name": "sub_nonneg_of_le",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `sub_nonneg`.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddCommSemigroup",
  "kind": "inductive",
  "doc_string":
  "A commutative additive semigroup is a type with an associative commutative `(+)`. ",
  "args": ""},
 {"type": "Array (Array ℤ) → ℕ → ℕ → Lean.Expr",
  "name": "Mathlib.Tactic.Sat.buildConj",
  "kind": "opaque",
  "doc_string":
  "Constructs the formula expression from the input CNF, as a balanced tree of `Fmla.and` nodes. ",
  "args": ""},
 {"type": "List Lean.Expr → Lean.Expr",
  "name": "Mathlib.Tactic.MkIff.mkOrList",
  "kind": "def",
  "doc_string":
  "`mkOrList [x1, x2, ...]` is defined as `x1 ∨ (x2 ∨ ...)`, or `False` if the list is empty. ",
  "args": ""},
 {"type": "{α : Sort u_1} → {β : Sort u_2} → IsEmpty α → α → β",
  "name": "IsEmpty.elim'",
  "kind": "def",
  "doc_string":
  "Non-dependent version of `IsEmpty.elim`. Helpful if the elaborator cannot elaborate `h.elim a`\ncorrectly. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        (α →o β) → (Antisymmetrization α fun x x_1 => x ≤ x_1) →o Antisymmetrization β fun x x_1 => x ≤ x_1",
  "name": "OrderHom.antisymmetrization",
  "kind": "def",
  "doc_string":
  "Turns an order homomorphism from `α` to `β` into one from `Antisymmetrization α` to\n`Antisymmetrization β`. `Antisymmetrization` is actually a functor. See `Preorder_to_PartialOrder`.\n",
  "args": ""},
 {"type":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : RightDistribClass R] (a b c : R), (a + b) * c = a * c + b * c",
  "name": "add_mul",
  "kind": "theorem",
  "doc_string": "**Alias** of `right_distrib`.",
  "args": ""},
 {"type": "outParam (Type u) → Type v → Type (max u v)",
  "name": "Insert",
  "kind": "inductive",
  "doc_string":
  "Type class for the `insert` operation.\nUsed to implement the `{ a, b, c }` syntax.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) → WithBot α →o WithBot β",
  "name": "OrderHom.withBotMap",
  "kind": "def",
  "doc_string":
  "Lift an order homomorphism `f : α →o β` to an order homomorphism `WithBot α →o WithBot β`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Nontrivial α] {f : α → β}, Function.Injective f → ∀ (y : β), ∃ x, f x ≠ y",
  "name": "Function.Injective.exists_ne",
  "kind": "theorem",
  "doc_string":
  "An injective function from a nontrivial type has an argument at\nwhich it does not take a given value. ",
  "args": ""},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "name": "SeqRight",
  "kind": "inductive",
  "doc_string":
  "The typeclass which supplies the `*>` \"seqRight\" function. See `Applicative`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) ∧ IsRegular (b * a) ↔ IsRegular a ∧ IsRegular b",
  "name": "isRegular_mul_and_mul_iff",
  "kind": "theorem",
  "doc_string":
  "Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b ≠ 0 ↔ b * a ≠ 0",
  "name": "mul_ne_zero_comm",
  "kind": "theorem",
  "doc_string":
  "If `α` has no zero divisors, then for elements `a, b : α`, `a * b` is nonzero iff so is\n`b * a`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_%_»",
  "kind": "def",
  "doc_string":
  "`a % b` computes the remainder upon dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For `Nat` and `Int`, `a % 0` is defined to be `a`. ",
  "args": ""},
 {"type":
  "∀ {E : Sort u_1} {α : Sort u_2} {β : Sort u_3} [self : EquivLike E α β] (e g : E),\n  EquivLike.coe e = EquivLike.coe g → EquivLike.inv e = EquivLike.inv g → e = g",
  "name": "EquivLike.coe_injective'",
  "kind": "def",
  "doc_string": "If two coercions to functions are jointly injective. ",
  "args": ""},
 {"type": "{P Q : Prop} → (P ↔ Q) → P ≃ Q",
  "name": "Equiv.ofIff",
  "kind": "def",
  "doc_string": "equivalence of propositions is the same as iff ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {Z : ι → Type u_2} →\n    [inst : (i : ι) → CanonicallyOrderedAddMonoid (Z i)] → CanonicallyOrderedAddMonoid ((i : ι) → Z i)",
  "name": "Pi.instCanonicallyOrderedAddMonoidForAll",
  "kind": "def",
  "doc_string":
  "The product of a family of canonically ordered additive monoids is\na canonically ordered additive monoid.",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Add α] → [inst_1 : AddZeroClass β] → AddHom α β ≃ (WithZero α →+ β)",
  "name": "WithZero.lift",
  "kind": "def",
  "doc_string":
  "Lift an add semigroup homomorphism `f` to a bundled add monoid homorphism.",
  "args": ""},
 {"type":
  "(R : Type u_1) → (S : Type u_2) → [inst : Semiring R] → [inst : OrderedSemiring S] → Type (max u_1 u_2)",
  "name": "AbsoluteValue",
  "kind": "inductive",
  "doc_string":
  "`AbsoluteValue R S` is the type of absolute values on `R` mapping to `S`:\nthe maps that preserve `*`, are nonnegative, positive definite and satisfy the triangle equality. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : One M₁] →\n        [inst_2 : Pow M₁ ℕ] →\n          [inst_3 : Inv M₁] →\n            [inst_4 : Div M₁] →\n              [inst_5 : Pow M₁ ℤ] →\n                [inst_6 : CommGroup M₂] →\n                  (f : M₁ → M₂) →\n                    Function.Injective f →\n                      f 1 = 1 →\n                        (∀ (x y : M₁), f (x * y) = f x * f y) →\n                          (∀ (x : M₁), f x⁻¹ = (f x)⁻¹) →\n                            (∀ (x y : M₁), f (x / y) = f x / f y) →\n                              (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                (∀ (x : M₁) (n : ℤ), f (x ^ n) = f x ^ n) → CommGroup M₁",
  "name": "Function.Injective.commGroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `1`, `*` and `⁻¹` is a commutative group, if it admits an injective map that\npreserves `1`, `*` and `⁻¹` to a commutative group. See note [reducible non-instances]. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⊓_»",
  "kind": "def",
  "doc_string": "Greatest lower bound (`\\glb` notation) ",
  "args": ""},
 {"type": "ℕ → ℕ",
  "name": "Nat.factorial",
  "kind": "def",
  "doc_string": "`Nat.factorial n` is the factorial of `n`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Mul M] →\n      [inst_1 : Mul N] →\n        {f : M →ₙ* N} → Function.Surjective ↑f → GaloisInsertion (Subsemigroup.map f) (Subsemigroup.comap f)",
  "name": "Subsemigroup.giMapComap",
  "kind": "def",
  "doc_string":
  "`map f` and `comap f` form a `GaloisInsertion` when `f` is surjective. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} [inst : MonoidWithZero R] [inst_1 : Zero M] [inst_2 : MulActionWithZero R M],\n  IsSMulRegular M 0 ↔ Subsingleton M",
  "name": "IsSMulRegular.zero_iff_subsingleton",
  "kind": "theorem",
  "doc_string":
  "The element `0` is `M`-regular if and only if `M` is trivial. ",
  "args": ""},
 {"type":
  "Lean.Meta.SimpTheorems → Lean.Expr → Lean.Meta.SimpM Lean.Meta.Simp.Step",
  "name": "Tactic.NormCast.upwardAndElim",
  "kind": "def",
  "doc_string":
  "Core rewriting function used in the \"squash\" step, which moves casts upwards\nand eliminates them.\n\nIt tries to rewrite an expression using the elim and move lemmas.\nOn failure, it calls the splitting procedure heuristic.\n",
  "args": ""},
 {"type": "{α : Type} → SlimCheck.Gen α → ℕ → BaseIO α",
  "name": "SlimCheck.Gen.run",
  "kind": "def",
  "doc_string":
  "Execute a `Gen` inside the `IO` monad using `size` as the example size",
  "args": ""},
 {"type":
  "(α : Sort u_1) → (β : Sort u_2) → { f // Function.Injective f } ≃ (α ↪ β)",
  "name": "Equiv.subtypeInjectiveEquivEmbedding",
  "kind": "def",
  "doc_string":
  "The type of embeddings `α ↪ β` is equivalent to\nthe subtype of all injective functions `α → β`. ",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} {q : α → Prop} {α_1 : Type u_1} {p : α_1 → Prop} {a : α_1} [inst : Functor m]\n  [inst_1 : LawfulFunctor m] {x : m α}, SatisfiesM q x → (∀ {b : α}, q b → p a) → SatisfiesM p (Functor.mapConst a x)",
  "name": "SatisfiesM.mapConst",
  "kind": "theorem",
  "doc_string": "`SatisfiesM` distributes over `mapConst`, general version. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Lattice α] → α → α → Set α",
  "name": "Set.interval",
  "kind": "def",
  "doc_string":
  "`interval a b` is the set of elements lying between `a` and `b`, with `a` and `b` included.\nNote that we define it more generally in a lattice as `Set.Icc (a ⊓ b) (a ⊔ b)`. In a product type,\n`interval` corresponds to the bounding box of the two elements. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 1 = 1",
  "name": "RingHom.map_one",
  "kind": "theorem",
  "doc_string": "Ring homomorphisms map one to one. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Ring α] → Ring.PositiveCone α → AddCommGroup.PositiveCone α",
  "name": "Ring.PositiveCone.toPositiveCone",
  "kind": "def",
  "doc_string":
  "Forget that a positive cone in a ring respects the multiplicative structure. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.PushNeg.pushNegConv",
  "kind": "def",
  "doc_string":
  "Push negations into the conclusion of an expression.\nFor instance, an expression `¬ ∀ x, ∃ y, x ≤ y` will be transformed by `push_neg` into\n`∃ x, ∀ y, y < x`. Variable names are conserved.\nThis tactic pushes negations inside expressions. For instance, given a hypothesis\n```lean\n| ¬ ∀ ε > 0, ∃ δ > 0, ∀ x, |x - x₀| ≤ δ → |f x - y₀| ≤ ε)\n```\nwriting `push_neg` will turn the target into\n```lean\n| ∃ ε, ε > 0 ∧ ∀ δ, δ > 0 → (∃ x, |x - x₀| ≤ δ ∧ ε < |f x - y₀|),\n```\n(The pretty printer does *not* use the abreviations `∀ δ > 0` and `∃ ε > 0` but this issue\nhas nothing to do with `push_neg`).\n\nNote that names are conserved by this tactic, contrary to what would happen with `simp`\nusing the relevant lemmas.\n\nThis tactic has two modes: in standard mode, it transforms `¬(p ∧ q)` into `p → ¬q`, whereas in\ndistrib mode it produces `¬p ∨ ¬q`. To use distrib mode, use `set_option push_neg.use_distrib true`.\n",
  "args": ""},
 {"type": "{β : Sort v} → (β → β → Prop) → Prop",
  "name": "Irreflexive",
  "kind": "def",
  "doc_string": "Irreflexive means \"not reflexive\". ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "OrderDual",
  "kind": "def",
  "doc_string":
  "Type synonym to equip a type with the dual order: `≤` means `≥` and `<` means `>`. `αᵒᵈ` is\nnotation for `OrderDual α`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : CommMonoidWithZero α] → α × α →*₀ α",
  "name": "mulMonoidWithZeroHom",
  "kind": "def",
  "doc_string": "Multiplication as a multiplicative homomorphism with zero. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c",
  "name": "AddCommute.add_left",
  "kind": "theorem",
  "doc_string":
  "If both `a` and `b` commute with `c`, then their product commutes with `c`.",
  "args": ""},
 {"type": "∀ {M : Type u} [self : CommMonoid M] (a b : M), a * b = b * a",
  "name": "CommMonoid.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort u_1} → (f : α → β) → Function.Surjective f → [inst : Unique α] → Unique β",
  "name": "Function.Surjective.unique",
  "kind": "def",
  "doc_string":
  "If the domain of a surjective function is a singleton,\nthen the codomain is a singleton as well. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] → [inst_1 : MulOneClass N] → {F : Type u_3} → [mc : MonoidHomClass F M N] → F → Submonoid M",
  "name": "MonoidHom.mker",
  "kind": "def",
  "doc_string":
  "The multiplicative kernel of a monoid hom is the submonoid of elements `x : G` such\nthat `f x = 1` ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : AddCommGroup α] → ℤ → α → α → α",
  "name": "Mathlib.Tactic.Abel.termg",
  "kind": "def",
  "doc_string":
  "A type synonym used by `abel` to represent `n • x + a` in an additive commutative group. ",
  "args": ""},
 {"type": "Type",
  "name": "Aesop.RuleBuilder",
  "kind": "def",
  "doc_string":
  "Invariant: if the `RuleBuilderInput` contains a `RuleBuilderKind.local`,\nthen the builder returns a `RuleBuilderOutput.local`, and similar for\n`RuleBuilderKind.global`.\n",
  "args": ""},
 {"type": "ℤ ≃ ℕ",
  "name": "Equiv.intEquivNat",
  "kind": "def",
  "doc_string":
  "An equivalence between `ℤ` and `ℕ`, through `ℤ ≃ ℕ ⊕ ℕ` and `ℕ ⊕ ℕ ≃ ℕ`.\n",
  "args": ""},
 {"type": "(Type u → Type u) → Type (u + 1)",
  "name": "Traversable",
  "kind": "inductive",
  "doc_string":
  "A traversable functor is a functor along with a way to commute\nwith all applicative functors (see `sequence`).  For example, if `t`\nis the traversable functor `List` and `m` is the applicative functor\n`IO`, then given a function `f : α → IO β`, the function `Functor.map f` is\n`List α → List (IO β)`, but `traverse f` is `List α → IO (List β)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop}, Function.Injective fun f => ↑f.toEmbedding",
  "name": "RelEmbedding.coe_fn_injective",
  "kind": "theorem",
  "doc_string": "The map `coe_fn : (r ↪r s) → (α → β)` is injective. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MulOneClass M] {s : Set M} {p : M → Prop} {x : M},\n  x ∈ Submonoid.closure s → (∀ (x : M), x ∈ s → p x) → p 1 → (∀ (x y : M), p x → p y → p (x * y)) → p x",
  "name": "Submonoid.closure_induction",
  "kind": "theorem",
  "doc_string":
  "An induction principle for closure membership. If `p` holds for `1` and all elements of `s`, and\nis preserved under multiplication, then `p` holds for all elements of the closure of `s`. ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : NonUnitalNonAssocSemiring R] → R →+ R →+ R",
  "name": "AddMonoidHom.mul",
  "kind": "def",
  "doc_string":
  "Multiplication of an element of a (semi)ring is an `AddMonoidHom` in both arguments.\n\nThis is a more-strongly bundled version of `AddMonoidHom.mulLeft` and `AddMonoidHom.mulRight`.\n\nStronger versions of this exists for algebras as `LinearMap.mul`, `NonUnitalAlgHom.mul`\nand `Algebra.lmul`.\n",
  "args": ""},
 {"type": "{α : Type u} → {γ : Type v} → [self : Sep α γ] → (α → Prop) → γ → γ",
  "name": "Sep.sep",
  "kind": "def",
  "doc_string": "Computes `{ a ∈ c | p a }`. ",
  "args": ""},
 {"type": "{α : Type u} → (α → α → Prop) → Set α → Prop",
  "name": "DirectedOn",
  "kind": "def",
  "doc_string":
  "A subset of α is directed if there is an element of the set `≼`-above any\npair of elements in the set. ",
  "args": ""},
 {"type":
  "{A : Type u₁} →\n  [inst : CategoryTheory.Category A] → {B : Type u₂} → [inst_1 : CategoryTheory.Category B] → (F : A ⥤ B) → 𝟭 A ⋙ F ≅ F",
  "name": "CategoryTheory.Functor.leftUnitor",
  "kind": "def",
  "doc_string": "The left unitor, a natural isomorphism `((𝟭 _) ⋙ F) ≅ F`.\n",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Add M] → AddHom M M",
  "name": "AddHom.id",
  "kind": "def",
  "doc_string": "The identity map from an type with addition to itself. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {δ : Type w} → (α → β → δ) → Stream' α → Stream' β → Stream' δ",
  "name": "Stream'.zip",
  "kind": "def",
  "doc_string":
  "Zip two streams using a binary operation:\n`Stream'.nth n (Stream'.zip f s₁ s₂) = f (Stream'.nth s₁) (Stream'.nth s₂)`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : LE α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → α → Ordering",
  "name": "cmpLE",
  "kind": "def",
  "doc_string":
  "Like `cmp`, but uses a `≤` on the type instead of `<`. Given two elements `x` and `y`, returns a\nthree-way comparison result `Ordering`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {l : α → β} →\n          {u : β → α} →\n            GaloisInsertion l u →\n              GaloisCoinsertion (↑OrderDual.toDual ∘ u ∘ ↑OrderDual.ofDual) (↑OrderDual.toDual ∘ l ∘ ↑OrderDual.ofDual)",
  "name": "GaloisInsertion.dual",
  "kind": "def",
  "doc_string":
  "Make a `GaloisCoinsertion` between `αᵒᵈ` and `βᵒᵈ` from a `GaloisInsertion` between `α` and\n`β`. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.AbelMode",
  "name": "Mathlib.Tactic.Abel.AbelMode.term",
  "kind": "def",
  "doc_string": "The default form ",
  "args": ""},
 {"type": "{α : Type u} → (α → α) → Set α",
  "name": "Function.fixedPoints",
  "kind": "def",
  "doc_string": "The set of fixed points of a map `f : α → α`. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → α ⊕ β → β ⊕ α",
  "name": "Sum.swap",
  "kind": "def",
  "doc_string": "Swap the factors of a sum type ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : DivisionCommMonoid α] → ℤ → α →* α",
  "name": "zpowGroupHom",
  "kind": "def",
  "doc_string":
  "The `n`-th power map (for an integer `n`) on a commutative group, considered as a group\nhomomorphism. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type u_1} → {δ : Type u_2} → (α → γ → Prop) → (β → δ → Prop) → α ⊕ β → γ ⊕ δ → Prop",
  "name": "Sum.LiftRel",
  "kind": "inductive",
  "doc_string":
  "Lifts pointwise two relations between `α` and `γ` and between `β` and `δ` to a relation between\n`α ⊕ β` and `γ ⊕ δ`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → Subsemigroup M → Subsemigroup N → Subsemigroup (M × N)",
  "name": "Subsemigroup.prod",
  "kind": "def",
  "doc_string":
  "Given `Subsemigroup`s `s`, `t` of semigroups `M`, `N` respectively, `s × t` as a subsemigroup\nof `M × N`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u₁} [inst : LinearOrderedRing R] {a : R}, -1 ≤ a → ∀ (n : ℕ), 1 + ↑n * (a - 1) ≤ a ^ n",
  "name": "one_add_mul_sub_le_pow",
  "kind": "theorem",
  "doc_string": "Bernoulli's inequality reformulated to estimate `a^n`. ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Polyrith.Poly → Option (Mathlib.Tactic.Polyrith.Poly × ℕ)",
  "name": "Mathlib.Tactic.Polyrith.Poly.unDiv?",
  "kind": "def",
  "doc_string":
  "Extracts the divisor `c : ℕ` from a polynomial of the form `1/c * b`. ",
  "args": ""},
 {"type": "∀ {p : ℕ → Prop}, (∃ x, p x) → WellFounded (Nat.Upto.GT p)",
  "name": "Nat.Upto.wf",
  "kind": "theorem",
  "doc_string":
  "The \"greater than\" relation on `Upto p` is well founded if (and only if) there exists a value\nsatisfying `p`. ",
  "args": ""},
 {"type":
  "Lean.Meta.SimpTheorems → Lean.Expr → Lean.Expr → Lean.MetaM (Option Lean.Meta.Simp.Result)",
  "name": "Tactic.NormCast.proveEqUsing",
  "kind": "def",
  "doc_string": "Prove `a = b` using the given simp set. ",
  "args": ""},
 {"type": "{α : Sort u} → [self : Setoid α] → α → α → Prop",
  "name": "Setoid.r",
  "kind": "def",
  "doc_string":
  "`x ≈ y` is the distinguished equivalence relation of a setoid. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Tactic.Alias.aliasLRDots",
  "kind": "def",
  "doc_string":
  "Adds one-way implication declarations, inferring names for them. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  (c : ConditionallyCompleteLattice α) →\n    (le : α → α → Prop) →\n      le = LE.le →\n        (sup : α → α → α) →\n          sup = HasSup.sup →\n            (inf : α → α → α) →\n              inf = HasInf.inf →\n                (Sup : Set α → α) → Sup = supₛ → (Inf : Set α → α) → Inf = infₛ → ConditionallyCompleteLattice α",
  "name": "ConditionallyCompleteLattice.copy",
  "kind": "def",
  "doc_string":
  "A function to create a provable equal copy of a conditionally complete lattice\nwith possibly different definitional equalities. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : StrictOrderedSemiring α] {a b c d : α} [inst_1 : ExistsAddOfLE α],\n  b < a → d < c → a • d + b • c < a • c + b • d",
  "name": "mul_add_mul_lt_mul_add_mul'",
  "kind": "theorem",
  "doc_string": "Binary **rearrangement inequality**. ",
  "args": ""},
 {"type": "ℕ → ℕ → List ℕ → List ℕ",
  "name": "List.range'TR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `range'TR`: `range'TR.go n e = [e-n, ..., e-1] ++ acc`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : NonAssocSemiring α] → [inst_1 : NonAssocSemiring β] → (α →+* β) → (I : Type u_3) → (I → α) →+* I → β",
  "name": "RingHom.compLeft",
  "kind": "def",
  "doc_string":
  "Ring homomorphism between the function spaces `I → α` and `I → β`, induced by a ring\nhomomorphism `f` between `α` and `β`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⁻¹»",
  "kind": "def",
  "doc_string": "Invert an element of α. ",
  "args": ""},
 {"type":
  "{F : Type u → Type u} → [inst : Functor F] → {α : Type u} → F α → Set α",
  "name": "Functor.supp",
  "kind": "def",
  "doc_string":
  "If we consider `x : F α` to, in some sense, contain values of type `α`, then\n`supp x` is the set of values of type `α` that `x` contains. ",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.Sum",
  "kind": "def",
  "doc_string":
  "Linear combinations of monomials are represented by mapping monomials to coefficients. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM (Option (Lean.Expr × Lean.Expr))",
  "name": "Mathlib.Tactic.getExplicitFuncArg?",
  "kind": "def",
  "doc_string": "solving `e ← mkAppM' f #[x]` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyOrderedAddMonoid α] (x : α), ⊥ ≤ x",
  "name": "CanonicallyOrderedAddMonoid.bot_le",
  "kind": "def",
  "doc_string": "`⊥` is the least element ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderTop α] [self : IsCoatomic α] (b : α),\n  b = ⊤ ∨ ∃ a, IsCoatom a ∧ b ≤ a",
  "name": "IsCoatomic.eq_top_or_exists_le_coatom",
  "kind": "def",
  "doc_string": "Every element other than `⊤` has an atom above it. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Semigroup α] {a b : α}, a ∣ b → ∀ (c : α), a ∣ b * c",
  "name": "Dvd.dvd.mul_right",
  "kind": "theorem",
  "doc_string": "**Alias** of `dvd_mul_of_dvd_left`.",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : α → Sort u_2} → (x : α) → ((x : α) → β x) → β x",
  "name": "Function.eval",
  "kind": "def",
  "doc_string":
  "Evaluate a function at an argument. Useful if you want to talk about the partially applied\n`Function.eval x : (∀ x, β x) → β x`. ",
  "args": ""},
 {"type":
  "Lean.Meta.TransparencyMode → List Lean.Expr → Lean.MetaM (List Linarith.Comp × ℕ)",
  "name": "Linarith.linearFormsAndMaxVar",
  "kind": "def",
  "doc_string":
  "`linearFormsAndMaxVar red pfs` is the main interface for computing the linear forms of a list\nof expressions. Given a list `pfs` of proofs of comparisons, it produces a list `c` of `Comp`s of\nthe same length, such that `c[i]` represents the linear form of the type of `pfs[i]`.\n\nIt also returns the largest variable index that appears in comparisons in `c`.\n",
  "args": ""},
 {"type": "PosNum → PosNum → Num",
  "name": "PosNum.mod'",
  "kind": "def",
  "doc_string": "Modulus of `PosNum`s. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsGreatest s a → supₛ s = a",
  "name": "IsGreatest.csupₛ_eq",
  "kind": "theorem",
  "doc_string": "A greatest element of a set is the supremum of this set. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_==_»",
  "kind": "def",
  "doc_string": "Boolean equality, notated as `a == b`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → Option β → γ) → List α → List β → Array γ → List γ",
  "name": "List.zipWithLeftTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `zipWithLeftTR`: `zipWithLeftTR.go l acc = acc.toList ++ zipWithLeft l`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : Zero α] → [inst : Add α] → List α → List α → List α",
  "name": "List.Func.add",
  "kind": "def",
  "doc_string":
  "Pointwise addition on lists. If lists are different lengths, use zero. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : GCDMonoid α] {a b c : α}, a ∣ c → a ∣ b → a ∣ gcd c b",
  "name": "GCDMonoid.dvd_gcd",
  "kind": "def",
  "doc_string": "Tny common divisor of both elements is a divisor of the GCD. ",
  "args": ""},
 {"type": "{α : Type u} → (as : List α) → Fin (List.length as) → α",
  "name": "List.get",
  "kind": "def",
  "doc_string":
  "`as.get i` returns the `i`'th element of the list `as`.\nThis version of the function uses `i : Fin as.length` to ensure that it will\nnot index out of bounds.\n",
  "args": ""},
 {"type":
  "{β : Type v} →\n  {m : Type v → Type w} →\n    [inst : Monad m] → (β → UInt8 → m β) → β → (as : ByteArray) → optParam ℕ 0 → optParam ℕ (ByteArray.size as) → m β",
  "name": "ByteArray.foldlM",
  "kind": "def",
  "doc_string": "Reference implementation for `foldlM` ",
  "args": ""},
 {"type": "Type (u + 1)",
  "name": "NonemptyType",
  "kind": "def",
  "doc_string":
  "`NonemptyType.{u}` is the type of nonempty types in universe `u`.\nIt is mainly used in constant declarations where we wish to introduce a type\nand simultaneously assert that it is nonempty, but otherwise make the type\nopaque.\n",
  "args": ""},
 {"type":
  "∀ (n k : ℕ) (hn : 0 < n) (hk : 0 < k), { val := n, property := hn } ≤ { val := k, property := hk } ↔ n ≤ k",
  "name": "PNat.mk_le_mk",
  "kind": "theorem",
  "doc_string":
  "We now define a long list of structures on ℕ+ induced by\nsimilar structures on ℕ. Most of these behave in a completely\nobvious way, but there are a few things to be said about\nsubtraction, division and powers.\n",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Monoid α] (self : αˣ), self.inv * ↑self = 1",
  "name": "Units.inv_val",
  "kind": "def",
  "doc_string": "`inv` is the left inverse of `val` in the base `Monoid`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HSub α β γ] → α → β → γ",
  "name": "HSub.hSub",
  "kind": "def",
  "doc_string":
  "`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} {inst : NonUnitalNonAssocSemiring α}\n  {inst_1 : NonUnitalNonAssocSemiring β} [self : NonUnitalRingHomClass F α β] (f : F), ↑f 0 = 0",
  "name": "NonUnitalRingHomClass.map_zero",
  "kind": "def",
  "doc_string": "The proposition that the function preserves 0 ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a : α}, a⁻¹ < 1 ↔ 1 < a",
  "name": "Left.inv_lt_one_iff",
  "kind": "theorem",
  "doc_string": "Uses `left` co(ntra)variant. ",
  "args": ""},
 {"type": "Type u_1 → Type u_2 → Type u_1",
  "name": "Functor.Const",
  "kind": "def",
  "doc_string":
  "`Const α` is the constant functor, mapping every type to `α`. When\n`α` has a monoid structure, `Const α` has an `Applicative` instance.\n(If `α` has an additive monoid structure, see `Functor.AddConst`.) ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {a : R} [inst : Monoid R] {n : ℕ}, 0 < n → (IsLeftRegular (a ^ n) ↔ IsLeftRegular a)",
  "name": "IsLeftRegular.pow_iff",
  "kind": "theorem",
  "doc_string":
  "An element `a` is left-regular if and only if a positive power of `a` is left-regular. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type u_1} →\n    [inst : OrderedCommRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Neg β] →\n                [inst_6 : Sub β] →\n                  [inst_7 : Pow β ℕ] →\n                    [inst_8 : SMul ℕ β] →\n                      [inst_9 : SMul ℤ β] →\n                        [inst_10 : NatCast β] →\n                          [inst_11 : IntCast β] →\n                            (f : β → α) →\n                              Function.Injective f →\n                                f 0 = 0 →\n                                  f 1 = 1 →\n                                    (∀ (x y : β), f (x + y) = f x + f y) →\n                                      (∀ (x y : β), f (x * y) = f x * f y) →\n                                        (∀ (x : β), f (-x) = -f x) →\n                                          (∀ (x y : β), f (x - y) = f x - f y) →\n                                            (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                              (∀ (x : β) (n : ℤ), f (n • x) = n • f x) →\n                                                (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                  (∀ (n : ℕ), f ↑n = ↑n) → (∀ (n : ℤ), f ↑n = ↑n) → OrderedCommRing β",
  "name": "Function.Injective.orderedCommRing",
  "kind": "def",
  "doc_string": "Pullback an `OrderedCommRing` under an injective map. ",
  "args": ""},
 {"type":
  "{m : Type v → Type w} → [inst : Monad m] → {α : Type u_1} → (ℕ → α → m PUnit) → List α → m PUnit",
  "name": "List.mapIdxM'",
  "kind": "def",
  "doc_string":
  "A variant of `mapIdxM` specialised to applicative actions which\nreturn `unit`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {n : ℕ} → (Fin n → α) → ℕ → Option α",
  "name": "List.ofFnNthVal",
  "kind": "def",
  "doc_string":
  "`ofFnNthVal f i` returns `some (f i)` if `i < n` and `none` otherwise. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Monoid M], SMulCommClass { x // x ∈ Submonoid.center M } M M",
  "name": "Submonoid.center.smulCommClass_left",
  "kind": "def",
  "doc_string": "The center of a monoid acts commutatively on that monoid. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {ι : Sort u_1} [inst : ConditionallyCompleteLattice α] [inst_1 : Nonempty ι] {f : ι → α} {c : α},\n  (∀ (x : ι), f x ≤ c) → supᵢ f ≤ c",
  "name": "csupᵢ_le",
  "kind": "theorem",
  "doc_string":
  "The indexed supremum of a function is bounded above by a uniform bound",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_≤_»",
  "kind": "def",
  "doc_string": "The less-equal relation: `x ≤ y` ",
  "args": ""},
 {"type":
  "Linarith.GlobalBranchingPreprocessor → Lean.MVarId → List Lean.Expr → Lean.MetaM (List Linarith.Branch)",
  "name": "Linarith.GlobalBranchingPreprocessor.process",
  "kind": "def",
  "doc_string":
  "`process pp l` runs `pp.transform` on `l` and returns the result,\ntracing the result if `trace.linarith` is on.\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Neg",
  "kind": "inductive",
  "doc_string":
  "The notation typeclass for negation.\nThis enables the notation `-a : α` where `a : α`.\n",
  "args": ""},
 {"type": "Type",
  "name": "Sat.Literal",
  "kind": "inductive",
  "doc_string":
  "A literal is a positive or negative occurrence of an atomic propositional variable.\nNote that unlike DIMACS, 0 is a valid variable index. ",
  "args": ""},
 {"type": "{C : Type u₁} → (D : Type u₂) → (C → D) → Type u₁",
  "name": "CategoryTheory.InducedCategory",
  "kind": "def",
  "doc_string":
  "`InducedCategory D F`, where `F : C → D`, is a typeclass synonym for `C`,\nwhich provides a category structure so that the morphisms `X ⟶ Y` are the morphisms\nin `D` from `F X` to `F Y`.\n",
  "args": ""},
 {"type":
  "{F : Type u → Type w} →\n  {G : Type v → Type u} →\n    [inst : Applicative F] →\n      [inst : Applicative G] →\n        {α β : Type v} → Functor.Comp F G (α → β) → (Unit → Functor.Comp F G α) → Functor.Comp F G β",
  "name": "Functor.Comp.seq",
  "kind": "def",
  "doc_string":
  "The `<*>` operation for the composition of applicative functors. ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → [self : CoeOut α β] → α → β",
  "name": "CoeOut.coe",
  "kind": "def",
  "doc_string":
  "Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : LinearOrder β] {f g : α → β},\n  Monotone f → Monotone g → Monotone fun x => max (f x) (g x)",
  "name": "Monotone.max",
  "kind": "theorem",
  "doc_string":
  "Pointwise maximum of two monotone functions is a monotone function. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Mul α] →\n    [inst_1 : LinearOrder α] →\n      [inst : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1] → α → α ↪o α",
  "name": "OrderEmbedding.mulRight",
  "kind": "def",
  "doc_string":
  "The order embedding sending `b` to `b * a`, for some fixed `a`.\nSee also `OrderIso.mulRight` when working in an ordered group. ",
  "args": ""},
 {"type": "Lean.Expr → Bool",
  "name": "Linarith.isNatProp",
  "kind": "opaque",
  "doc_string":
  "`isNatProp tp` is true iff `tp` is an inequality or equality between natural numbers\nor the negation thereof.\n",
  "args": ""},
 {"type": "∀ {α : Type u} [self : Lattice α] (a b : α), a ⊓ b ≤ a",
  "name": "Lattice.inf_le_left",
  "kind": "def",
  "doc_string": "The infimum is a lower bound on the first argument ",
  "args": ""},
 {"type":
  "{ε : Type u} → {m : Type v → Type w} → [self : MonadExcept ε m] → {α : Type v} → ε → m α",
  "name": "MonadExcept.throw",
  "kind": "def",
  "doc_string":
  "`throw : ε → m α` \"throws an error\" of type `ε` to the nearest enclosing\ncatch block. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : MulZeroClass R], ¬IsRightRegular 0 ↔ Nontrivial R",
  "name": "not_isRightRegular_zero_iff",
  "kind": "theorem",
  "doc_string":
  "In a non-trivial `MulZeroClass`, the `0` element is not right-regular. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : MulZeroClass R], IsRightRegular 0 → Subsingleton R",
  "name": "IsRightRegular.subsingleton",
  "kind": "theorem",
  "doc_string":
  "The element `0` is right-regular if and only if `R` is trivial. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → [inst : Preorder α] → [inst_1 : Preorder β] → [inst_2 : Preorder γ] → (α × β →o γ) ≃o (α →o β →o γ)",
  "name": "OrderHom.curry",
  "kind": "def",
  "doc_string":
  "Curry/uncurry as an order isomorphism between `α × β →o γ` and `α →o β →o γ`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddMonoid",
  "kind": "inductive",
  "doc_string":
  "An `AddMonoid` is an `AddSemigroup` with an element `0` such that `0 + a = a + 0 = a`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a : Q(«$α»)} →\n        {b : Q(ℕ)} →\n          Mathlib.Tactic.Ring.ExProd sα a →\n            Mathlib.Tactic.Ring.ExProd Mathlib.Tactic.Ring.sℕ b →\n              Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExProd sα) q(«$a» ^ «$b»)",
  "name": "Mathlib.Tactic.Ring.evalPowProdAtom",
  "kind": "def",
  "doc_string":
  "The fallback case for exponentiating polynomials is to use `ExBase.toProd` to just build an\nexponent expression. (This has a slightly different normalization than `evalPowAtom` because\nthe input types are different.)\n\n* `x ^ e = (x + 0) ^ e * 1`\n",
  "args": ""},
 {"type": "{α : Type u} → α → Stream' α",
  "name": "Stream'.pure",
  "kind": "def",
  "doc_string": "A constant stream, same as `Stream'.const`. ",
  "args": ""},
 {"type":
  "∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → Preorder (π i)] {a b : (i : ι) → π i} [inst_1 : Nonempty ι],\n  StrongLT a b → a < b",
  "name": "StrongLT.lt",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_strongLT`.",
  "args": ""},
 {"type":
  "{M₀ : Type u_1} →\n  {M₀' : Type u_2} →\n    [inst : Zero M₀'] →\n      [inst_1 : Mul M₀'] →\n        [inst_2 : One M₀'] →\n          [inst_3 : Pow M₀' ℕ] →\n            [inst_4 : MonoidWithZero M₀] →\n              (f : M₀' → M₀) →\n                Function.Injective f →\n                  f 0 = 0 →\n                    f 1 = 1 →\n                      (∀ (x y : M₀'), f (x * y) = f x * f y) →\n                        (∀ (x : M₀') (n : ℕ), f (x ^ n) = f x ^ n) → MonoidWithZero M₀'",
  "name": "Function.Injective.monoidWithZero",
  "kind": "def",
  "doc_string":
  "Pullback a `MonoidWithZero` along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : HasSSubset α]\n  [inst_2 : IsNonstrictStrictOrder α (fun x x_1 => x ⊆ x_1) fun x x_1 => x ⊂ x_1] {a b : α}, a ⊆ b → ¬b ⊂ a",
  "name": "HasSubset.Subset.not_ssubset",
  "kind": "theorem",
  "doc_string": "**Alias** of `not_ssubset_of_subset`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} (r : α → α → Prop) [inst : IsWellFounded α r] {C : α → Sort u_1}\n  (F : (x : α) → ((y : α) → r y x → C y) → C x) (x : α),\n  IsWellFounded.fix r F x = F x fun y x => IsWellFounded.fix r F y",
  "name": "IsWellFounded.fix_eq",
  "kind": "theorem",
  "doc_string":
  "The value from `IsWellFounded.fix` is built from the previous ones as specified. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Preorder α] → (p : α → Prop) → Subtype p ↪o α",
  "name": "OrderEmbedding.subtype",
  "kind": "def",
  "doc_string":
  "Embedding of a subtype into the ambient type as an `OrderEmbedding`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_4} {β : Type u_5} {γ : Type u_3} {f : α → β → γ} {a : Option α} {b : Option β} {δ : Type u_1}\n  {α' : Type u_2} {g : γ → δ} {f' : α' → β → δ} {g' : α → α'},\n  (∀ (a : α) (b : β), g (f a b) = f' (g' a) b) → Option.map g (Option.map₂ f a b) = Option.map₂ f' (Option.map g' a) b",
  "name": "Option.map_map₂_distrib_left",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Option.map₂_map_left_comm`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {s : Set α} {σ : Equiv.Perm α}, { a | ↑σ a ≠ a } ⊆ s → ↑σ '' s = s",
  "name": "Set.image_perm",
  "kind": "theorem",
  "doc_string":
  "If the only elements outside `s` are those left fixed by `σ`, then mapping by `σ` has no effect.\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop} [self : ContravariantClass M N μ r],\n  Contravariant M N μ r",
  "name": "ContravariantClass.elim",
  "kind": "def",
  "doc_string":
  "For all `m ∈ M` and all elements `n₁, n₂ ∈ N`, if the relation `r` holds for the\npair `(μ m n₁, μ m n₂)` obtained from `(n₁, n₂)` by acting upon it by `m`, then, the relation\n`r` also holds for the pair `(n₁, n₂)`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : α → Type u_2} → (((a : α) → Part (β a)) → (a : α) → Part (β a)) → (x : α) → Part (β x)",
  "name": "Part.fix",
  "kind": "def",
  "doc_string":
  "The least fixed point of `f`.\n\nIf `f` is a continuous function (according to complete partial orders),\nit satisfies the equations:\n\n  1. `fix f = f (fix f)`          (is a fixed point)\n  2. `∀ X, f X ≤ X → fix f ≤ X`   (least fixed point)\n",
  "args": ""},
 {"type": "ℤ → ℤ → ℤ",
  "name": "Int.fmod",
  "kind": "def",
  "doc_string":
  "Integer modulus. This version of `Int.mod` uses the F-rounding convention\n(flooring division), in which `Int.fdiv x y` satisfies `fdiv x y = floor (x / y)`\nand `Int.fmod` is the unique function satisfying `fmod x y + (fdiv x y) * y = x`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → {σ : Type u_2} → (σ → α → σ) → σ → Aesop.UnorderedArraySet α → σ",
  "name": "Aesop.UnorderedArraySet.fold",
  "kind": "def",
  "doc_string": "O(n) ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Type u_2} → (ℕ → α → β → α) → α → List β → optParam ℕ 0 → α",
  "name": "List.foldlIdx",
  "kind": "def",
  "doc_string":
  "Fold a list from left to right as with `foldl`, but the combining function\nalso receives each element's index.\n",
  "args": ""},
 {"type":
  "(Type u → Type v) → (Type u → Type w) → Type (max (max (u + 1) v) w)",
  "name": "MonadControlT",
  "kind": "inductive",
  "doc_string": "Transitive closure of MonadControl. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → (α : ι → Type u_2) → (β : Type u_3) → ((i : ι) × α i) × β ≃ (i : ι) × α i × β",
  "name": "Equiv.sigmaProdDistrib",
  "kind": "def",
  "doc_string":
  "The product of an indexed sum of types (formally, a `Sigma`-type `Σ i, α i`) by a type `β` is\nequivalent to the sum of products `Σ i, (α i × β)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [s : Setoid α] {r : α → α → Prop} {H : ∀ (a₁ b₁ a₂ b₂ : α), a₁ ≈ a₂ → b₁ ≈ b₂ → r a₁ b₁ = r a₂ b₂},\n  WellFounded r → WellFounded (Quotient.lift₂ r H)",
  "name": "RelEmbedding.WellFounded.quotient_lift₂",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `wellFounded_lift₂_iff`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r : Setoid α} {x y : α}, Quotient.mk' x = Quotient.mk' y ↔ Setoid.Rel r x y",
  "name": "Quotient.eq_rel",
  "kind": "theorem",
  "doc_string":
  "A version of `Quotient.eq'` compatible with `Setoid.Rel`, to make rewriting possible. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {h h' : LE α} →\n    (c : BoundedOrder α) → (top : α) → top = ⊤ → (bot : α) → bot = ⊥ → (∀ (x y : α), x ≤ y ↔ x ≤ y) → BoundedOrder α",
  "name": "BoundedOrder.copy",
  "kind": "def",
  "doc_string":
  "A function to create a provable equal copy of a bounded order\nwith possibly different definitional equalities. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → {p : α → Prop} → ((a : α) → p a → β) → (x : Option α) → (∀ (a : α), a ∈ x → p a) → Option β",
  "name": "Option.pmap",
  "kind": "def",
  "doc_string":
  "Partial map. If `f : Π a, p a → β` is a partial function defined on `a : α` satisfying `p`,\nthen `pmap f x h` is essentially the same as `map f x` but is defined only when all members of `x`\nsatisfy `p`, using the proof to apply `f`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LE α] → α → Prop",
  "name": "IsMin",
  "kind": "def",
  "doc_string":
  "`a` is a minimal element of `α` if no element is strictly less than it. We spell it without `<`\nto avoid having to convert between `≤` and `<`. Instead, `isMin_iff_forall_not_lt` does the\nconversion. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CoheytingAlgebra α] {a b : α}, Codisjoint a b → ￢a ≤ b",
  "name": "Codisjoint.hnot_le_right",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `hnot_le_iff_codisjoint_right`.",
  "args": ""},
 {"type":
  "(α : Type u_1) → {β : Type u_2} → TwoPointing β → [inst : Nonempty α] → TwoPointing (α → β)",
  "name": "TwoPointing.pi",
  "kind": "def",
  "doc_string": "The two-pointing of constant functions. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Monoid α] → Inhabited αˣ",
  "name": "Units.instInhabitedUnits",
  "kind": "def",
  "doc_string": "Units of a monoid are inhabited because `1` is a unit. ",
  "args": ""},
 {"type":
  "{S : Type u_1} → [inst : OrderedSemiring S] → {R : Type u_2} → [inst : Semiring R] → (R → S) → Prop",
  "name": "IsAbsoluteValue",
  "kind": "inductive",
  "doc_string":
  "A function `f` is an absolute value if it is nonnegative, zero only at 0, additive, and\nmultiplicative.\nSee also the type `AbsoluteValue` which represents a bundled version of absolute values.\n",
  "args": ""},
 {"type": "{α : Type u} → [self : Max α] → α → α → α",
  "name": "Max.max",
  "kind": "def",
  "doc_string": "The maximum operation: `max x y`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : CompleteLattice α] → (f : α →o α) → (x : α) → ↑f x ≤ x → ↑(Function.fixedPoints ↑f)",
  "name": "OrderHom.prevFixed",
  "kind": "def",
  "doc_string":
  "Previous fixed point of a monotone map. If `f` is a monotone self-map of a complete lattice and\n`x` is a point such that `f x ≤ x`, then `f.prevFixed x hx` is the greatest fixed point of `f`\nthat is less than or equal to `x`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {sα : Q(CommSemiring «$α»)} →\n      {e : Q(«$α»)} → Mathlib.Tactic.Ring.ExProd sα e → Mathlib.Tactic.Ring.ExSum sα q(«$e» + 0)",
  "name": "Mathlib.Tactic.Ring.ExProd.toSum",
  "kind": "def",
  "doc_string": "Embed `ExProd` in `ExSum` by adding 0. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Rel α β → Rel β α",
  "name": "Rel.inv",
  "kind": "def",
  "doc_string":
  "The inverse relation : `r.inv x y ↔ r y x`. Note that this is *not* a groupoid inverse. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ b → (a ∣ b + c ↔ a ∣ c)",
  "name": "dvd_add_right",
  "kind": "theorem",
  "doc_string":
  "If an element a divides another element b in a commutative ring, a divides the sum of b and\nanother element c iff a divides c. ",
  "args": ""},
 {"type":
  "∀ {I : Type u} {f : I → Type v} [inst : DecidableEq I] [inst_1 : (i : I) → MulOneClass (f i)],\n  Pairwise fun i j => ∀ (x : f i) (y : f j), Commute (Pi.mulSingle i x) (Pi.mulSingle j y)",
  "name": "Pi.mulSingle_commute",
  "kind": "theorem",
  "doc_string":
  "The injection into a pi group at different indices commutes.\n\nFor injections of commuting elements at the same index, see `Commute.map` ",
  "args": ""},
 {"type":
  "{X : Type u} →\n  {m₁ : X → X → X} →\n    {e₁ : X} →\n      EckmannHilton.IsUnital m₁ e₁ →\n        [G : AddGroup X] → (∀ (a b c d : X), m₁ (a + b) (c + d) = m₁ a c + m₁ b d) → AddCommGroup X",
  "name": "EckmannHilton.addCommGroup",
  "kind": "def",
  "doc_string":
  "If a type carries an additive group structure that distributes over a unital binary\noperation, then the additive group is commutative.",
  "args": ""},
 {"type": "Linarith.LinarithConfig → Bool",
  "name": "Linarith.LinarithConfig.split_ne",
  "kind": "def",
  "doc_string": "Split `≠` in hypotheses, by branching in cases `<` and `>`. ",
  "args": ""},
 {"type": "ℤ → (den : optParam ℕ 1) → autoParam (den ≠ 0) _auto✝ → ℚ",
  "name": "Rat.normalize",
  "kind": "def",
  "doc_string":
  "Construct a normalized `Rat` from a numerator and nonzero denominator.\nThis is a \"smart constructor\" that divides the numerator and denominator by\nthe gcd to ensure that the resulting rational number is normalized.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tacticGet_elem_tactic",
  "kind": "def",
  "doc_string":
  "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedSemifield α] (a b : α), a / b = a * b⁻¹",
  "name": "LinearOrderedSemifield.div_eq_mul_inv",
  "kind": "def",
  "doc_string": "`a / b := a * b⁻¹` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → Array α → Aesop.UnorderedArraySet α",
  "name": "Aesop.UnorderedArraySet.ofSortedArray",
  "kind": "def",
  "doc_string": "Precondition: `xs` is sorted. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → {sα : Q(CommSemiring «$α»)} → {e : Q(«$α»)} → ℕ → Mathlib.Tactic.Ring.ExBase sα e",
  "name": "Mathlib.Tactic.Ring.ExBase.atom",
  "kind": "def",
  "doc_string":
  "An atomic expression `e` with id `id`.\n\nAtomic expressions are those which `ring` cannot parse any further.\nFor instance, `a + (a % b)` has `a` and `(a % b)` as atoms.\nThe `ring1` tactic does not normalize the subexpressions in atoms, but `ring_nf` does.\n\nAtoms in fact represent equivalence classes of expressions, modulo definitional equality.\nThe field `index : ℕ` should be a unique number for each class,\nwhile `value : expr` contains a representative of this class.\nThe function `resolve_atom` determines the appropriate atom for a given expression.\n",
  "args": ""},
 {"type":
  "{α : Sort u} → [inst : DecidableEq α] → (a b : α) → Decidable (a = b)",
  "name": "decEq",
  "kind": "def",
  "doc_string": "Proves that `a = b` is decidable given `DecidableEq α`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MulOneClass M] (self : Submonoid M), 1 ∈ self.toSubsemigroup.carrier",
  "name": "Submonoid.one_mem'",
  "kind": "def",
  "doc_string": "A submonoid contains `1`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_→o_»",
  "kind": "def",
  "doc_string": "Notation for an `OrderHom`. ",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → ¬b ≤ a",
  "name": "LT.lt.not_le",
  "kind": "theorem",
  "doc_string": "**Alias** of `not_le_of_lt`.",
  "args": ""},
 {"type": "{α : Type u} → (α → Bool) → List α → List α × List α",
  "name": "List.span",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `span p l` splits the list `l` into two parts, where the first part\ncontains the longest initial segment for which `p` returns true\nand the second part is everything else.\n\n* `span (· > 5) [6, 8, 9, 5, 2, 9] = ([6, 8, 9], [5, 2, 9])`\n* `span (· > 10) [6, 8, 9, 5, 2, 9] = ([6, 8, 9, 5, 2, 9], [])`\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Ring α] (self : Ring.PositiveCone α), AddCommGroup.PositiveCone.nonneg self.toPositiveCone 1",
  "name": "Ring.PositiveCone.one_nonneg",
  "kind": "def",
  "doc_string": "In a positive cone, `1` is `nonneg` ",
  "args": ""},
 {"type": "{α : Type u_1} → [self : LinearOrderedField α] → ℚ → α → α",
  "name": "LinearOrderedField.qsmul",
  "kind": "def",
  "doc_string": "Multiplication by a rational number. ",
  "args": ""},
 {"type": "∀ {m n : ℕ}, m ∣ m + n ↔ m ∣ n",
  "name": "Nat.dvd_add_self_left",
  "kind": "theorem",
  "doc_string":
  "A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.",
  "args": ""},
 {"type": "{α : Type u_1} → (a : α) → ↑{a} ≃ PUnit",
  "name": "Equiv.Set.singleton",
  "kind": "def",
  "doc_string": "A singleton set is equivalent to a `PUnit` type. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Mul α] → Type u_1",
  "name": "HasDistribNeg",
  "kind": "inductive",
  "doc_string":
  "Typeclass for a negation operator that distributes across multiplication.\n\nThis is useful for dealing with submonoids of a ring that contain `-1` without having to duplicate\nlemmas. ",
  "args": ""},
 {"type": "{ε σ : Type u} → σ → EStateM ε σ PUnit",
  "name": "EStateM.set",
  "kind": "def",
  "doc_string": "The `set` operation of the `EStateM` monad. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {α' : Sort w} [inst : DecidableEq α] [inst_1 : DecidableEq α'] {β : Sort u_1} (g : α' → β) {f : α → α'},\n  Function.Injective f → ∀ (i : α) (a : β), Function.update g (f i) a ∘ f = Function.update (g ∘ f) i a",
  "name": "Function.update_comp_eq_of_injective",
  "kind": "theorem",
  "doc_string":
  "Non-dependent version of `Function.update_comp_eq_of_injective'` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : Setoid α} {f : α → β} (H : r ≤ Setoid.ker f) (g : Quotient r → β),\n  f = g ∘ Quotient.mk'' → Quotient.lift f H = g",
  "name": "Setoid.lift_unique",
  "kind": "theorem",
  "doc_string":
  "The uniqueness part of the universal property for quotients of an arbitrary type. ",
  "args": ""},
 {"type": "Lean.Expr → Option String",
  "name": "Mathlib.Tactic.getHeadTk",
  "kind": "opaque",
  "doc_string":
  "Gets the initial string token in a parser description. For example, for a declaration like\n`syntax \"bla\" \"baz\" term : tactic`, it returns `some \"bla\"`. Returns `none` for syntax declarations\nthat don't start with a string constant. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_3} {ι : Type u_2} {ι' : Type u_1} [inst : CompleteLattice α] {s : Set ι'} {g : ι' → Set ι} {f : ι → α},\n  (Set.PairwiseDisjoint s fun i' => ⨆ i, ⨆ h, f i) →\n    (∀ (i : ι'), i ∈ s → Set.PairwiseDisjoint (g i) f) →\n      Set.PairwiseDisjoint (Set.unionᵢ fun i => Set.unionᵢ fun h => g i) f",
  "name": "Set.PairwiseDisjoint.bunionᵢ",
  "kind": "theorem",
  "doc_string":
  "Bind operation for `Set.PairwiseDisjoint`. If you want to only consider finsets of indices, you\ncan use `Set.PairwiseDisjoint.bunionᵢ_finset`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Tactic.NormCast.tacticAssumption_mod_cast",
  "kind": "def",
  "doc_string":
  "`assumption_mod_cast` runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` and tries to use that to close the goal. ",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u_1} [self : CommGroupWithZero G₀] (n : ℕ) (a : G₀),\n  CommGroupWithZero.zpow (Int.negSucc n) a = (CommGroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹",
  "name": "CommGroupWithZero.zpow_neg'",
  "kind": "def",
  "doc_string": "`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` ",
  "args": ""},
 {"type":
  "∀ (R : Type u_1) (M : Type u_2) [inst : Semiring R] [inst_1 : Subsingleton R] [inst_2 : AddCommMonoid M]\n  [inst : Module R M], Subsingleton M",
  "name": "Module.subsingleton",
  "kind": "theorem",
  "doc_string":
  "A module over a `Subsingleton` semiring is a `Subsingleton`. We cannot register this\nas an instance because Lean has no way to guess `R`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Preorder α] → Type u_1",
  "name": "ClosureOperator",
  "kind": "inductive",
  "doc_string":
  "A closure operator on the preorder `α` is a monotone function which is extensive (every `x`\nis less than its closure) and idempotent. ",
  "args": ""},
 {"type":
  "∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A ≃+* B → IsDomain A",
  "name": "RingEquiv.isDomain",
  "kind": "theorem",
  "doc_string":
  "If two rings are isomorphic, and the second is a domain, then so is the first. ",
  "args": ""},
 {"type": "∀ {α : Sort u} {a : α}, a = a",
  "name": "rfl",
  "kind": "def",
  "doc_string":
  "`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n",
  "args": ""},
 {"type": "{α : Type u_1} → List α → ℕ → List α",
  "name": "List.eraseIdxTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `eraseIdx`. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : Neg M₁] →\n            [inst_4 : Sub M₁] →\n              [inst_5 : SMul ℤ M₁] →\n                [inst_6 : AddCommGroup M₂] →\n                  (f : M₁ → M₂) →\n                    Function.Injective f →\n                      f 0 = 0 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁), f (-x) = -f x) →\n                            (∀ (x y : M₁), f (x - y) = f x - f y) →\n                              (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) → AddCommGroup M₁",
  "name": "Function.Injective.addCommGroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `0` and `+` is an additive commutative group, if it\nadmits an injective map that preserves `0` and `+` to an additive commutative group.",
  "args": ""},
 {"type": "Mathlib.Tactic.RingNF.Config → Lean.Meta.TransparencyMode",
  "name": "Mathlib.Tactic.RingNF.Config.red",
  "kind": "def",
  "doc_string":
  "the reducibility setting to use when comparing atoms for defeq ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → List α → Prop",
  "name": "List.Chain'",
  "kind": "def",
  "doc_string":
  "`Chain' R l` means that `R` holds between adjacent elements of `l`.\n```\nChain' R [a, b, c, d] ↔ R a b ∧ R b c ∧ R c d\n``` ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_3} {M : Type u_2} {a : R} [inst : SMul R M] [inst_1 : SMul R S] [inst_2 : SMul S M]\n  [inst_3 : IsScalarTower R S M] (b : S), IsSMulRegular M a → (IsSMulRegular M (a • b) ↔ IsSMulRegular M b)",
  "name": "IsSMulRegular.smul_iff",
  "kind": "theorem",
  "doc_string":
  "An element is `M`-regular if and only if multiplying it on the left by an `M`-regular element\nis `M`-regular. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Type u_2} {f : ι → α} {s : Set α} (h : ∀ (x : ι), f x ∈ s),\n  Function.Injective f → Function.Injective (Set.codRestrict f s h)",
  "name": "Function.Injective.codRestrict",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Set.injective_codRestrict`.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddCancelCommMonoid",
  "kind": "inductive",
  "doc_string": "Commutative version of `AddCancelMonoid`. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₂] →\n      [inst_1 : AddSemigroup M₁] →\n        (f : M₁ → M₂) → Function.Surjective f → (∀ (x y : M₁), f (x + y) = f x + f y) → AddSemigroup M₂",
  "name": "Function.Surjective.addSemigroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `+` is an additive semigroup, if it admits a\nsurjective map that preserves `+` from an additive semigroup.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  1 < a → 1 < b → 1 < a * b",
  "name": "Right.one_lt_mul'",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul'`. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → LazyList α → (α → β) → LazyList β",
  "name": "LazyList.for",
  "kind": "def",
  "doc_string":
  "Maps a function over a lazy list.\nSame as `lazy_list.map`, but with swapped arguments.\n",
  "args": ""},
 {"type": "{α : Type u} → [inst : BEq α] → List α → List α → Option (List α)",
  "name": "List.isSuffixOf?",
  "kind": "def",
  "doc_string": "`isSuffixOf? l₁ l₂` returns `some t` when `l₂ == t ++ l₁`.",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {q : (x : α) → p x → Prop},\n  (∀ (x : α) (h : p x), q x h) ↔ ∀ (x : { a // p a }), q ↑x (_ : p ↑x)",
  "name": "Subtype.forall'",
  "kind": "theorem",
  "doc_string":
  "An alternative version of `Subtype.forall`. This one is useful if Lean cannot figure out `q`\nwhen using `Subtype.forall` from right to left. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Polyrith.SageSuccess → Option String",
  "name": "Mathlib.Tactic.Polyrith.SageSuccess.trace",
  "kind": "def",
  "doc_string":
  "The script returns a string containing python script to be sent to the remote server,\nwhen the tracing option is set. ",
  "args": ""},
 {"type":
  "(R : Type u_1) → {M : Type u_2} → [inst : Ring R] → [inst_1 : AddCommMonoid M] → [inst : Module R M] → AddCommGroup M",
  "name": "Module.addCommMonoidToAddCommGroup",
  "kind": "def",
  "doc_string":
  "An `AddCommMonoid` that is a `Module` over a `Ring` carries a natural `AddCommGroup`\nstructure.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → α → α → Set α",
  "name": "Set.Ioo",
  "kind": "def",
  "doc_string": "Left-open right-open interval ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f g : α → β} {s : Set α}, (∀ (x : α), f x = g x) → f '' s = g '' s",
  "name": "Set.image_congr'",
  "kind": "theorem",
  "doc_string": "A common special case of `image_congr` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → ∀ {a : α} {s : Set α}, IsLeast s a → IsLeast (f '' s) (f a)",
  "name": "Monotone.map_isLeast",
  "kind": "theorem",
  "doc_string":
  "A monotone map sends a least element of a set to a least element of its image. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {p : α → Prop} → (∃ a, p a) → {C : Sort u_2} → ((a : α) → p a → C) → C",
  "name": "Exists.classicalRecOn",
  "kind": "def",
  "doc_string":
  "This function has the same type as `Exists.recOn`, and can be used to case on an equality,\nbut `Exists.recOn` can only eliminate into Prop, while this version eliminates into any universe\nusing the axiom of choice. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {α : ι → Type u_2} →\n    [inst : PartialOrder ι] →\n      [inst_1 : OrderTop ι] →\n        [inst_2 : (i : ι) → Preorder (α i)] → [inst_3 : OrderTop (α ⊤)] → OrderTop (Lex ((i : ι) × α i))",
  "name": "Sigma.Lex.orderTop",
  "kind": "def",
  "doc_string": "The lexicographical linear order on a sigma type. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), a ≤ b ∨ b ≤ a",
  "name": "LinearOrderedSemiring.le_total",
  "kind": "def",
  "doc_string": "A linear order is total. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → (M →+ N) ≃ (Mᵐᵒᵖ →+ Nᵐᵒᵖ)",
  "name": "AddMonoidHom.mulOp",
  "kind": "def",
  "doc_string":
  "An additive homomorphism `M →+ N` can equivalently be viewed as an additive homomorphism\n`Mᵐᵒᵖ →+ Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : PartialOrder α] → [inst : OrderTop α] → Prop",
  "name": "IsCoatomic",
  "kind": "inductive",
  "doc_string":
  "A lattice is coatomic iff every element other than `⊤` has a coatom above it. ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : CommRing α] (a b : α), a * b = b * a",
  "name": "CommRing.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type": "∀ {p q r : Prop}, (p → q) → (q → r) → p → r",
  "name": "Implies.trans",
  "kind": "theorem",
  "doc_string":
  "Implication `→` is transitive. If `P → Q` and `Q → R` then `P → R`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β' γ' : Type v} →\n    {m' : Type v → Type w} → [inst : Monad m'] → (β' → α → m' (β' × γ')) → β' → List α → m' (β' × List γ')",
  "name": "List.mapAccumLM",
  "kind": "def",
  "doc_string":
  "Takes a value `β` and `List α` and accumulates pairs according to a monadic function `f`.\nAccumulation occurs from the left (i.e., starting from the head of the list). ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → Array α",
  "name": "List.toArray",
  "kind": "def",
  "doc_string":
  "Convert a `List α` into an `Array α`. This is O(n) in the length of the list.\n\nThis function is exported to C, where it is called by `Array.mk`\n(the constructor) to implement this functionality.\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "MulOpposite",
  "kind": "inductive",
  "doc_string":
  "Multiplicative opposite of a type. This type inherits all additive structures on `α` and\nreverses left and right in multiplication.",
  "args": ""},
 {"type":
  "(R : Type u_1) → [inst : MonoidWithZero R] → MulActionWithZero Rᵐᵒᵖ R",
  "name": "MonoidWithZero.toOppositeMulActionWithZero",
  "kind": "def",
  "doc_string":
  "Like `MonoidWithZero.toMulActionWithZero`, but multiplies on the right. See also\n`Semiring.toOppositeModule` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : LE α] → [inst_1 : LE β] → α ≃o β → αᵒᵈ ≃o βᵒᵈ",
  "name": "OrderIso.dual",
  "kind": "def",
  "doc_string":
  "An order isomorphism is also an order isomorphism between dual orders. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] {f g : M →ₙ* N} {s : Set M},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subsemigroup.closure s)",
  "name": "MulHom.eqOn_closure",
  "kind": "theorem",
  "doc_string":
  "If two mul homomorphisms are equal on a set, then they are equal on its subsemigroup closure. ",
  "args": ""},
 {"type":
  "{C : ℕ → Sort u_1} → C 0 → C 1 → ((b : Bool) → (n : ℕ) → n ≠ 0 → C n → C (Nat.bit b n)) → (n : ℕ) → C n",
  "name": "Nat.binaryRecFromOne",
  "kind": "def",
  "doc_string":
  "The same as `binaryRec`, but special casing both 0 and 1 as base cases ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → α ≃ β → α ↪ β",
  "name": "Equiv.toEmbedding",
  "kind": "def",
  "doc_string":
  "Convert an `α ≃ β` to `α ↪ β`.\n\nThis is also available as a coercion `Equiv.coeEmbedding`.\nThe explicit `Equiv.toEmbedding` version is preferred though, since the coercion can have issues\ninferring the type of the resulting embedding. For example:\n\n```lean\n-- Works:\nexample (s : Finset (Fin 3)) (f : Equiv.Perm (Fin 3)) : s.map f.toEmbedding = s.map f := by simp\n-- Error, `f` has type `Fin 3 ≃ Fin 3` but is expected to have type `Fin 3 ↪ ?m_1 : Type ?`\nexample (s : Finset (Fin 3)) (f : Equiv.Perm (Fin 3)) : s.map f = s.map f.toEmbedding := by simp\n```\n",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a : Q(«$α»)} →\n        {b : Q(ℕ)} →\n          Mathlib.Tactic.Ring.ExProd sα a →\n            Mathlib.Tactic.Ring.ExProd Mathlib.Tactic.Ring.sℕ b →\n              Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExProd sα) q(«$a» ^ «$b»)",
  "name": "Mathlib.Tactic.Ring.evalPowProd",
  "kind": "def",
  "doc_string":
  "There are several special cases when exponentiating monomials:\n\n* `1 ^ n = 1`\n* `x ^ y = (x ^ y)` when `x` and `y` are constants\n* `(a * b) ^ e = a ^ e * b ^ e`\n\nIn all other cases we use `evalPowProdAtom`.\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "CancelCommMonoid",
  "kind": "inductive",
  "doc_string": "Commutative version of `CancelMonoid`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {m : Type u_1 → Type u_2} → {β γ : Type u_1} → [inst : Bind m] → (β → m γ) → (α → m β) → α → m γ",
  "name": "Bind.kleisliLeft",
  "kind": "def",
  "doc_string": "Right-to-left composition of Kleisli arrows. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AddGroupWithOne",
  "kind": "inductive",
  "doc_string":
  "An `AddGroupWithOne` is an `AddGroup` with a 1. It also contains data for the unique\nhomomorphisms `ℕ → R` and `ℤ → R`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Add M] {s : Set M}, s ⊆ ↑(AddSubsemigroup.closure s)",
  "name": "AddSubsemigroup.subset_closure",
  "kind": "theorem",
  "doc_string": "The `AddSubsemigroup` generated by a set includes the set.",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} [inst : AddGroup G] (a : G), ↑(Equiv.symm (Equiv.addRight a)) = fun x => x + -a",
  "name": "Equiv.addRight_symm_apply",
  "kind": "theorem",
  "doc_string":
  "Extra simp lemma that `dsimp` can use. `simp` will never use this.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Fix",
  "kind": "inductive",
  "doc_string":
  "`Fix α` provides a `fix` operator to define recursive computatiation\nvia the fixed point of function of type `α → α`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Ring α] → AddMonoidWithOne α",
  "name": "Mathlib.Meta.NormNum.instAddMonoidWithOne",
  "kind": "def",
  "doc_string":
  "A shortcut (non)instance for `AddMonoidWithOne α` from `Ring α` to shrink generated proofs. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  {D : Type u₂} → [inst : CategoryTheory.Category C] → [inst_1 : CategoryTheory.Category D] → C ⥤ D → Type u₂",
  "name": "CategoryTheory.Functor.EssImageSubcategory",
  "kind": "def",
  "doc_string":
  "The essential image of a functor, interpreted of a full subcategory of the target category. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Sat.Clause → Array ℤ",
  "name": "Mathlib.Tactic.Sat.Clause.lits",
  "kind": "def",
  "doc_string": "The list of literals as read from the input file ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} (self : r →r s) {a b : α},\n  r a b → s (RelHom.toFun self a) (RelHom.toFun self b)",
  "name": "RelHom.map_rel'",
  "kind": "def",
  "doc_string": "A `RelHom` sends related elements to related elements ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Meta.NormNum.Entry",
  "kind": "def",
  "doc_string":
  "Each `norm_num` extension is labelled with a collection of patterns\nwhich determine the expressions to which it should be applied. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → {n : ℕ} → [inst : NatCast R] → [inst : Nat.AtLeastTwo n] → OfNat R n",
  "name": "instOfNat",
  "kind": "def",
  "doc_string":
  "Recognize numeric literals which are at least `2` as terms of `R` via `Nat.cast`. This\ninstance is what makes things like `37 : R` type check.  Note that `0` and `1` are not needed\nbecause they are recognized as terms of `R` (at least when `R` is an `AddMonoidWithOne`) through\n`Zero` and `One`, respectively. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : AddMonoid α] → [inst_1 : LinearOrder α] → AddUnits α ↪o α",
  "name": "AddUnits.orderEmbeddingVal",
  "kind": "def",
  "doc_string": "`val : add_units α → α` as an order embedding.",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : MulOneClass M] → (S : Submonoid M) → One { x // x ∈ S }",
  "name": "Submonoid.one",
  "kind": "def",
  "doc_string": "A submonoid of a monoid inherits a 1. ",
  "args": ""},
 {"type":
  "{F : Type → Type v} → [inst : Alternative F] → {α : Type} → F α → F Bool",
  "name": "succeeds",
  "kind": "def",
  "doc_string":
  "Returns `pure true` if the computation succeeds and `pure false` otherwise. ",
  "args": ""},
 {"type":
  "{p q : Prop} → [dp : Decidable p] → [dq : Decidable q] → Decidable (p ∧ q)",
  "name": "And.decidable",
  "kind": "def",
  "doc_string": "**Alias** of `instDecidableAnd`.",
  "args": ""},
 {"type": "{α : Type u} → List α → List α",
  "name": "List.reverse",
  "kind": "def",
  "doc_string":
  "`O(|as|)`. Reverse of a list:\n* `[1, 2, 3, 4].reverse = [4, 3, 2, 1]`\n\nNote that because of the \"functional but in place\" optimization implemented by Lean's compiler,\nthis function works without any allocations provided that the input list is unshared:\nit simply walks the linked list and reverses all the node pointers.\n",
  "args": ""},
 {"type":
  "∀ {I : Type u} {β : Type u_1} [inst : DecidableEq I] [inst_1 : Zero β] (i : I) (x : β) (i' : I),\n  Pi.single i x i' = if i' = i then x else 0",
  "name": "Pi.single_apply",
  "kind": "theorem",
  "doc_string":
  "On non-dependent functions, `Pi.single` can be expressed as an `ite`",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → ¬b < a",
  "name": "LT.lt.not_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_asymm`.",
  "args": ""},
 {"type": "Lean.Elab.Tactic.Tactic",
  "name": "Mathlib.Tactic.Nontriviality.elabNontriviality",
  "kind": "def",
  "doc_string": "Elaborator for the `nontriviality` tactic. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Finset",
  "kind": "inductive",
  "doc_string":
  "`Finset α` is the type of finite sets of elements of `α`. It is implemented\nas a multiset (a list up to permutation) which has no duplicate elements. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : HasSSubset α]\n  [inst_2 : IsNonstrictStrictOrder α (fun x x_1 => x ⊆ x_1) fun x x_1 => x ⊂ x_1] {a b : α}\n  [inst_3 : IsAntisymm α fun x x_1 => x ⊆ x_1], a ⊆ b → a = b ∨ a ⊂ b",
  "name": "HasSubset.Subset.eq_or_ssubset",
  "kind": "theorem",
  "doc_string": "**Alias** of `eq_or_ssubset_of_subset`.",
  "args": ""},
 {"type": "{α : Type u} → List α → List α → List α",
  "name": "List.reverseAux",
  "kind": "def",
  "doc_string":
  "Auxiliary for `List.reverse`. `List.reverseAux l r = l.reverse ++ r`, but it is defined directly. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : HasSSubset α] → α → α → Prop",
  "name": "SSuperset",
  "kind": "def",
  "doc_string": "Strict superset relation: `a ⊃ b`  ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulReflectLT α],\n  a * b < a * c → 0 ≤ a → b < c",
  "name": "lt_of_mul_lt_mul_of_nonneg_left",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_mul_lt_mul_left`.",
  "args": ""},
 {"type": "{α : Sort u} → α → α",
  "name": "id",
  "kind": "def",
  "doc_string":
  "The identity function. `id` takes an implicit argument `α : Sort u`\n(a type in any universe), and an argument `a : α`, and returns `a`.\n\nAlthough this may look like a useless function, one application of the identity\nfunction is to explicitly put a type on an expression. If `e` has type `T`,\nand `T'` is definitionally equal to `T`, then `@id T' e` typechecks, and lean\nknows that this expression has type `T'` rather than `T`. This can make a\ndifference for typeclass inference, since `T` and `T'` may have different\ntypeclass instances on them. `show T' from e` is sugar for an `@id T' e`\nexpression.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → ¬a < b → b = a",
  "name": "LE.le.eq_of_not_gt",
  "kind": "theorem",
  "doc_string": "**Alias** of `eq_of_ge_of_not_gt`.",
  "args": ""},
 {"type":
  "{α : Sort uA} →\n  {β : Sort uB} →\n    {φ : Sort uC} →\n      {s₁ : Setoid α} →\n        {s₂ : Setoid β} →\n          Quotient s₁ →\n            Quotient s₂ →\n              (f : α → β → φ) → (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) → φ",
  "name": "Quotient.liftOn₂",
  "kind": "def",
  "doc_string": "Lift a binary function to a quotient on both arguments. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Preorder α] → Set α → Prop",
  "name": "BddAbove",
  "kind": "def",
  "doc_string": "A set is bounded above if there exists an upper bound. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Parser.Attr.functor_norm",
  "kind": "def",
  "doc_string": "Simp set for `functor_norm` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (R : α → α → Prop) → [inst : DecidableRel R] → List α → List α",
  "name": "List.destutter",
  "kind": "def",
  "doc_string":
  "Greedily create a sublist of `l` such that, for every two adjacent elements `a, b ∈ l`,\n`R a b` holds. Mostly used with ≠; for example, `destutter (≠) [1, 2, 2, 1, 1] = [1, 2, 1]`,\n`destutter (≠) [1, 2, 3, 3] = [1, 2, 3]`, `destutter (<) [1, 2, 5, 2, 3, 4, 9] = [1, 2, 5, 9]`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → (α : Type u_3) → [inst : VAdd M α] → (N → M) → VAdd N α",
  "name": "VAdd.comp",
  "kind": "def",
  "doc_string":
  "An additive action of `M` on `α` and a function `N → M` induces\nan additive action of `N` on `α` ",
  "args": ""},
 {"type": "Type",
  "name": "ByteSlice",
  "kind": "inductive",
  "doc_string":
  "A byte slice, given by a backing byte array, and an offset and length. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] {a b : αᵒᵈ}, b ⋖ a → ↑OrderDual.ofDual a ⋖ ↑OrderDual.ofDual b",
  "name": "Covby.ofDual",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `ofDual_covby_ofDual_iff`.",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (zα : Q(Zero «$α»)) →\n      (pα : Q(PartialOrder «$α»)) →\n        (e : Q(«$α»)) → Lean.LocalDecl → Lean.MetaM (Mathlib.Meta.Positivity.Strictness zα pα e)",
  "name": "Mathlib.Meta.Positivity.compareHyp",
  "kind": "def",
  "doc_string":
  "A variation on `assumption` which checks if the hypothesis `ldecl` is `a [</≤/=] e`\nwhere `a` is a numeral. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [self : CommMonoidWithZero M₀] (a : M₀), a * 0 = 0",
  "name": "CommMonoidWithZero.mul_zero",
  "kind": "def",
  "doc_string": "Zero is a right absorbing element for multiplication ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), min a b = if a ≤ b then a else b",
  "name": "LinearOrder.min_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `minOfLe`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "List.«term_<:+:__1»",
  "kind": "def",
  "doc_string": "Notation for `List.isInfix`\n",
  "args": ""},
 {"type":
  "String → String → Lean.Name → Lean.MetaM (ℕ × Lean.Expr × Lean.Expr × Lean.Expr)",
  "name": "Mathlib.Tactic.Sat.fromLRATAux",
  "kind": "def",
  "doc_string":
  "Core of `fromLRAT`. Constructs the context and main proof definitions,\nbut not the reification theorem. Returns:\n\n  * `nvars`: the number of variables specified in the CNF file\n  * `ctx`: The abbreviated formula, a constant like `foo.ctx_1`\n  * `ctx'`: The definitional expansion of the formula, a tree of `Fmla.and` nodes\n  * `proof`: A proof of `ctx.proof []`\n",
  "args": ""},
 {"type": "{M : Type u} → [self : AddLeftCancelMonoid M] → ℕ → M → M",
  "name": "AddLeftCancelMonoid.nsmul",
  "kind": "def",
  "doc_string": "Multiplication by a natural number. ",
  "args": ""},
 {"type":
  "∀ {C : ℕ → Sort u_1} {z : C 0} {f : (b : Bool) → (n : ℕ) → C n → C (Nat.bit b n)} (b : Bool) (n : ℕ),\n  f false 0 z = z ∨ (n = 0 → b = true) → Nat.binaryRec z f (Nat.bit b n) = f b n (Nat.binaryRec z f n)",
  "name": "Nat.binaryRec_eq'",
  "kind": "theorem",
  "doc_string":
  "The same as `binaryRec_eq`,\nbut that one unfortunately requires `f` to be the identity when appending `false` to `0`.\nHere, we allow you to explicitly say that that case is not happening,\ni.e. supplying `n = 0 → b = true`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] (a b : α), abs (a + b) ≤ abs a + abs b",
  "name": "abs_add",
  "kind": "theorem",
  "doc_string": "The **triangle inequality** in `LinearOrderedAddCommGroup`s. ",
  "args": ""},
 {"type":
  "{K : Type u_1} → [inst : NatCast K] → [inst : IntCast K] → [inst : Mul K] → [inst : Inv K] → ℚ → K",
  "name": "Rat.castRec",
  "kind": "def",
  "doc_string":
  "The default definition of the coercion `(↑(a : ℚ) : K)` for a division ring `K`\nis defined as `(a / b : K) = (a : K) * (b : K)⁻¹`.\nUse `coe` instead of `Rat.castRec` for better definitional behaviour.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] →\n      [inst_1 : OrderBot α] → [inst_2 : PartialOrder β] → {l : α → β} → {u : β → α} → GaloisConnection l u → OrderBot β",
  "name": "GaloisConnection.liftOrderBot",
  "kind": "def",
  "doc_string": "Lift the bottom along a Galois connection ",
  "args": ""},
 {"type": "{α : Type u_1} → ℕ → α → List α → List α",
  "name": "List.insertNth",
  "kind": "def",
  "doc_string":
  "`insertNth n a l` inserts `a` into the list `l` after the first `n` elements of `l`\n```\ninsertNth 2 1 [1, 2, 3, 4] = [1, 2, 1, 3, 4]\n```\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R] [self : RightDistribClass R] (a b c : R), (a + b) * c = a * c + b * c",
  "name": "RightDistribClass.right_distrib",
  "kind": "def",
  "doc_string": "Multiplication is right distributive over addition ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : NonAssocSemiring α] → [inst_1 : NonAssocSemiring β] → (α →+* β) → α →+ β",
  "name": "RingHom.toAddMonoidHom",
  "kind": "def",
  "doc_string":
  "Reinterpret a ring homomorphism `f : α →+* β` as an additive monoid homomorphism `α →+ β`.\nThe `simp`-normal form is `(f : α →+ β)`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [self : HImp α] → α → α → α",
  "name": "HImp.himp",
  "kind": "def",
  "doc_string": "Heyting implication `⇨` ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List (List α)",
  "name": "List.initsTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `inits`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "name": "PosMulStrictMono",
  "kind": "def",
  "doc_string":
  "`PosMulStrictMono α` is an abbreviation for `CovariantClass α>0 α (λ x y, x * y) (<)`,\nexpressing that multiplication by positive elements on the left is strictly monotone. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → ℕ",
  "name": "List.length",
  "kind": "def",
  "doc_string":
  "The length of a list: `[].length = 0` and `(a :: l).length = l.length + 1`.\n\nThis function is overridden in the compiler to `lengthTR`, which uses constant\nstack space, while leaving this function to use the \"naive\" recursion which is\neasier for reasoning.\n",
  "args": ""},
 {"type": "{α : Type u_1} → (r : α → α → Prop) → r →r r",
  "name": "RelHom.id",
  "kind": "def",
  "doc_string": "Identity map is a relation homomorphism. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → (A : Type u_3) → [inst : Zero A] → [inst_1 : SMulZeroClass M A] → (N → M) → SMulZeroClass N A",
  "name": "SMulZeroClass.compFun",
  "kind": "def",
  "doc_string":
  "Compose a `SMulZeroClass` with a function, with scalar multiplication `f r' • m`.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [inst : Semiring α] {m n : ℕ}, m ∣ n → ↑m ∣ ↑n",
  "name": "Dvd.dvd.natCast",
  "kind": "theorem",
  "doc_string": "**Alias** of `Nat.coe_nat_dvd`.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "OrderedAddCommGroup",
  "kind": "inductive",
  "doc_string":
  "An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term|___|»",
  "kind": "def",
  "doc_string": "The absolute value function. ",
  "args": ""},
 {"type": "ℤ → Linarith.Linexp → Linarith.Linexp",
  "name": "Linarith.Linexp.scale",
  "kind": "def",
  "doc_string":
  "`l.scale c` scales the values in `l` by `c` without modifying the order or keys. ",
  "args": ""},
 {"type": "∀ {R : Type u} [self : AddMonoidWithOne R], NatCast.natCast 0 = 0",
  "name": "AddMonoidWithOne.natCast_zero",
  "kind": "def",
  "doc_string": "The canonical map `ℕ → R` sends `0 : ℕ` to `0 : R`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [self : LinearOrderedRing α] → DecidableRel fun x x_1 => x ≤ x_1",
  "name": "LinearOrderedRing.decidable_le",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "{ε σ α : Type u} → (σ → α × σ) → EStateM ε σ α",
  "name": "EStateM.modifyGet",
  "kind": "def",
  "doc_string": "The `modifyGet` operation of the `EStateM` monad. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, -a ≤ 0 ↔ 0 ≤ a",
  "name": "Left.neg_nonpos_iff",
  "kind": "theorem",
  "doc_string": "Uses `left` co(ntra)variant.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (a : α) (s : Set α), a ⊓ supₛ s ≤ ⨆ b, ⨆ h, a ⊓ b",
  "name": "CompleteBooleanAlgebra.inf_supₛ_le_supᵢ_inf",
  "kind": "def",
  "doc_string": "In a frame, `⊓` distributes over `⨆`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "List.«term_<:+:_»",
  "kind": "def",
  "doc_string":
  "`isInfix l₁ l₂`, or `l₁ <:+: l₂`, means that `l₁` is a contiguous\nsubstring of `l₂`, that is, `l₂` has the form `s ++ l₁ ++ t` for some `s, t`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : CancelCommMonoidWithZero α] → [inst_1 : Unique αˣ] → Associates α ≃* α",
  "name": "associatesEquivOfUniqueUnits",
  "kind": "def",
  "doc_string":
  "If a monoid's only unit is `1`, then it is isomorphic to its associates. ",
  "args": ""},
 {"type": "Mathlib.Tactic.RingNF.Config → Mathlib.Tactic.RingNF.RingMode",
  "name": "Mathlib.Tactic.RingNF.Config.mode",
  "kind": "def",
  "doc_string": "The normalization style. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_→*_»",
  "kind": "def",
  "doc_string":
  "`M →* N` denotes the type of monoid homomorphisms from `M` to `N`. ",
  "args": ""},
 {"type": "{M : Type u_1} → Set M → [inst : Monoid M] → Submonoid M",
  "name": "Submonoid.centralizer",
  "kind": "def",
  "doc_string": "The centralizer of a subset of a monoid `M`. ",
  "args": ""},
 {"type":
  "∀ {F : Sort u_2} {α : Sort u_3} {β : α → Sort u_1} [i : FunLike F α β] [inst : ∀ (a : α), Subsingleton (β a)],\n  Subsingleton F",
  "name": "FunLike.subsingleton_cod",
  "kind": "theorem",
  "doc_string":
  "This is not an instance to avoid slowing down every single `Subsingleton` typeclass search.",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  {A : Type u_2} → {B : Type u_3} → [inst : SubtractionMonoid G] → [inst_1 : AddAction G A] → AddAction G (A → B)",
  "name": "arrowAddAction",
  "kind": "def",
  "doc_string":
  "If `G` acts on `A`, then it acts also on `A → B`, by `(g +ᵥ F) a = F (g⁻¹ +ᵥ a)`",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  StrictMono f → StrictMono (WithBot.map f)",
  "name": "StrictMono.withBot_map",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `WithBot.strictMono_map_iff`.",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Zero α] → [inst : One α] → [inst : LE α] → Type",
  "name": "ZeroLEOneClass",
  "kind": "inductive",
  "doc_string":
  "Typeclass for expressing that the `0` of a type is less or equal to its `1`. ",
  "args": ""},
 {"type": "∀ {n : ℤ}, IsUnit n → Int.natAbs n = 1",
  "name": "Int.IsUnit.natAbs_eq",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `Int.isUnit_iff_natAbs_eq`.",
  "args": ""},
 {"type": "{α : Type u_1} → {ι : Sort u_2} → (ι → α) → Set α",
  "name": "Set.range",
  "kind": "def",
  "doc_string":
  "Range of a function.\n\nThis function is more flexible than `f '' univ`, as the image requires that the domain is in Type\nand not an arbitrary Sort. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLinearOrderBot α] {s : Set α}, Set.Nonempty s → ↑(infₛ s) = ⨅ a, ⨅ h, ↑a",
  "name": "WithTop.coe_infₛ",
  "kind": "theorem",
  "doc_string":
  "A version of `WithTop.coe_infₛ'` with a more convenient but less general statement. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ↪r s → r →r s",
  "name": "RelEmbedding.toRelHom",
  "kind": "def",
  "doc_string": "A relation embedding is also a relation homomorphism ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LT α] (b : α) (bs : List α), List.lt [] (b :: bs)",
  "name": "List.lt.nil",
  "kind": "def",
  "doc_string": "`[]` is the smallest element in the order. ",
  "args": ""},
 {"type": "{M : Type u_1} → Set M → [inst : Mul M] → Set M",
  "name": "Set.centralizer",
  "kind": "def",
  "doc_string": "The centralizer of a subset of a magma. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Type u_2} →\n    (f : α → β) →\n      (f_inv : Nonempty α → β → α) → (∀ (h : Nonempty α), Function.LeftInverse (f_inv h) f) → α ≃ ↑(Set.range f)",
  "name": "Equiv.ofLeftInverse",
  "kind": "def",
  "doc_string":
  "If `f : α → β` has a left-inverse when `α` is nonempty, then `α` is computably equivalent to the\nrange of `f`.\n\nWhile awkward, the `Nonempty α` hypothesis on `f_inv` and `hf` allows this to be used when `α` is\nempty too. This hypothesis is absent on analogous definitions on stronger `Equiv`s like\n`LinearEquiv.ofLeftInverse` and `RingEquiv.ofLeftInverse` as their typeclass assumptions\nare already sufficient to ensure non-emptiness. ",
  "args": ""},
 {"type": "∀ {m n : ℕ}, m ∣ n + m ↔ m ∣ n",
  "name": "Nat.dvd_add_self_right",
  "kind": "theorem",
  "doc_string":
  "A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«termℕ+»",
  "kind": "def",
  "doc_string":
  "`ℕ+` is the type of positive natural numbers. It is defined as a subtype,\nand the VM representation of `ℕ+` is the same as `ℕ` because the proof\nis not stored. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {α : Type u_2} → [inst : AddMonoid M] → [inst_1 : AddAction M α] → M →+ Additive (Function.End α)",
  "name": "AddAction.toEndHom",
  "kind": "def",
  "doc_string":
  "The additive monoid hom representing an additive monoid action.\n\nWhen `M` is a group, see `AddAction.toPermHom`. ",
  "args": ""},
 {"type": "ℕ → ℤ → Float",
  "name": "Float.ofBinaryScientific",
  "kind": "def",
  "doc_string": "Computes `m * 2^e`. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} [inst : DecidableEq α] {β : Sort u_1} (f : α → β) (a' : α) (b : β) (a : α),\n  Function.update f a' b a = if a = a' then b else f a",
  "name": "Function.update_apply",
  "kind": "theorem",
  "doc_string":
  "On non-dependent functions, `Function.update` can be expressed as an `ite` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : α → Set β} {y : β},\n  (∀ (x : α), x ∈ s → y ∈ t x) → y ∈ Set.interᵢ fun x => Set.interᵢ fun h => t x",
  "name": "Set.mem_binterᵢ",
  "kind": "theorem",
  "doc_string": "A specialization of `mem_interᵢ₂`. ",
  "args": ""},
 {"type": "(G : Type u) → [inst : Add G] → Prop",
  "name": "IsRightCancelAdd",
  "kind": "inductive",
  "doc_string": "A mixin for right cancellative addition. ",
  "args": ""},
 {"type": "{α : Type u_1} → Array α → List α",
  "name": "Array.toListRev",
  "kind": "def",
  "doc_string": "A more efficient version of `arr.toList.reverse`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        (f : M →+ N) →\n          (g : N →+ M) → AddMonoidHom.comp g f = AddMonoidHom.id M → AddMonoidHom.comp f g = AddMonoidHom.id N → M ≃+ N",
  "name": "AddMonoidHom.toAddEquiv",
  "kind": "def",
  "doc_string":
  "Given a pair of additive monoid homomorphisms `f`, `g` such that `g.comp f = id`\nand `f.comp g = id`, returns an additive equivalence with `toFun = f` and `invFun = g`.  This\nconstructor is useful if the underlying type(s) have specialized `ext` lemmas for additive\nmonoid homomorphisms.",
  "args": ""},
 {"type": "(α : Sort u_1) → (α → PUnit) ≃ PUnit",
  "name": "Equiv.arrowPUnitEquivPUnit",
  "kind": "def",
  "doc_string":
  "The sort of maps to `PUnit.{v}` is equivalent to `PUnit.{w}`. ",
  "args": ""},
 {"type":
  "Option (Lean.TSyntax `Lean.Parser.Command.docComment) →\n  Lean.ConstantInfo → Lean.Syntax → Lean.Name → Bool → Lean.Elab.TermElabM Unit",
  "name": "Tactic.Alias.aliasIff",
  "kind": "def",
  "doc_string":
  "Given a constant representing an iff decl, adds a decl for one of the implication\ndirections.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] (c : ClosureOperator α), ClosureOperator.closed c = Set.range ↑c.toOrderHom",
  "name": "ClosureOperator.closed_eq_range_close",
  "kind": "theorem",
  "doc_string": "The set of closed elements for `c` is exactly its range. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} →\n        [inst : PartialOrder β] → [inst_1 : Preorder α] → [inst_2 : OrderTop α] → GaloisInsertion l u → OrderTop β",
  "name": "GaloisInsertion.liftOrderTop",
  "kind": "def",
  "doc_string": "Lift the top along a Galois insertion ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (self : M →+ N) (x y : M),\n  ↑↑self (x + y) = ↑↑self x + ↑↑self y",
  "name": "AddMonoidHom.map_add'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves addition ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : BiheytingAlgebra α] (a b c : α), a \\ b ≤ c ↔ a ≤ b ⊔ c",
  "name": "BiheytingAlgebra.sdiff_le_iff",
  "kind": "def",
  "doc_string": "`\\ a` is right adjoint to `⊔ a` ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Mul M] →\n      [inst_1 : Mul N] → (f : M →ₙ* N) → (g : N → M) → Function.LeftInverse g ↑f → Function.RightInverse g ↑f → N →ₙ* M",
  "name": "MulHom.inverse",
  "kind": "def",
  "doc_string":
  "Makes a multiplicative inverse from a bijection which preserves multiplication. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_≃+*_»",
  "kind": "def",
  "doc_string": "Notation for `RingEquiv`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : Add α] [inst_2 : Sub α] [inst_3 : OrderedSub α] {a b : α}, a + b - b ≤ a",
  "name": "add_tsub_le_right",
  "kind": "theorem",
  "doc_string":
  "See `add_tsub_cancel_right` for the equality if `ContravariantClass α α (+) (≤)`. ",
  "args": ""},
 {"type":
  "{m : Type u → Type v} → {n : Type u → Type w} → [self : MonadLiftT m n] → {α : Type u} → m α → n α",
  "name": "MonadLiftT.monadLift",
  "kind": "def",
  "doc_string": "Lifts a value from monad `m` into monad `n`. ",
  "args": ""},
 {"type": "Type",
  "name": "Aesop.RuleTacInput",
  "kind": "inductive",
  "doc_string":
  "Input for a rule tactic. Contains:\n\n- `goal`: the goal on which the rule is run.\n- `mvars`: the set of mvars which occur in `goal`.\n- `indexMatchLocations`: if the rule is indexed, the locations (e.g. hyps or the\n  target) matched by the rule's index entries. Otherwise an empty set.\n- `branchState`: the current branch state for this rule. If the rule does not\n  use branch state, this is always `RuleBranchState.initial`.\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Monoid M] {a : M} {x y : Mˣ}, SemiconjBy a ↑x ↑y → SemiconjBy a ↑x⁻¹ ↑y⁻¹",
  "name": "SemiconjBy.units_inv_right",
  "kind": "theorem",
  "doc_string":
  "If `a` semiconjugates a unit `x` to a unit `y`, then it semiconjugates `x⁻¹` to `y⁻¹`. ",
  "args": ""},
 {"type": "{g : Type} → [inst : RandomGen g] → RandG g (ℕ × ℕ)",
  "name": "Rand.range",
  "kind": "def",
  "doc_string":
  "Get the range of Nat that can be generated by the generator `g` ",
  "args": ""},
 {"type": "Lean.Elab.Tactic.Tactic",
  "name": "Mathlib.Tactic.RingNF.elabRingNFConv",
  "kind": "def",
  "doc_string": "Elaborator for the `ring_nf` tactic. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (α → Option α) → List α → List α → Array α → List α",
  "name": "List.replaceFTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `replaceFTR`:\n`replaceFTR.go f l xs acc = acc.toList ++ replaceF f xs` if `f` returns `some`, else `l`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} {N : Type u_3} [inst : Zero R] [inst_1 : Zero M] [inst_2 : Zero N] [inst_3 : SMul R M]\n  [inst_4 : SMul R N] [inst_5 : NoZeroSMulDivisors R N] (f : M → N),\n  Function.Injective f → f 0 = 0 → (∀ (c : R) (x : M), f (c • x) = c • f x) → NoZeroSMulDivisors R M",
  "name": "Function.Injective.noZeroSMulDivisors",
  "kind": "theorem",
  "doc_string":
  "Pullback a `NoZeroSMulDivisors` instance along an injective function. ",
  "args": ""},
 {"type": "ℤ → ℤ",
  "name": "Int.pred",
  "kind": "def",
  "doc_string": "Immediate predecessor of an integer: `pred n = n - 1` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] (self : Flag α), IsChain (fun x x_1 => x ≤ x_1) self.carrier",
  "name": "Flag.Chain'",
  "kind": "def",
  "doc_string": "By definition, a flag is a chain ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  StrictAntiOn f s → StrictMonoOn (f ∘ ↑OrderDual.ofDual) s",
  "name": "StrictAntiOn.dual_left",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `strictMonoOn_comp_ofDual_iff`.",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : CancelMonoidWithZero M₀] {a b : M₀}, b ≠ 1 → a * b = a → a = 0",
  "name": "eq_zero_of_mul_eq_self_right",
  "kind": "theorem",
  "doc_string":
  "An element of a `CancelMonoidWithZero` fixed by right multiplication by an element other\nthan one must be zero. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CompleteBooleanAlgebra",
  "kind": "inductive",
  "doc_string":
  "A complete Boolean algebra is a completely distributive Boolean algebra. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → ℕ → ℕ",
  "name": "List.countp.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `countp`: `countp.go p l acc = countp p l + acc`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {F : Type u_3} →\n          {G : Type u_4} →\n            [inst_2 : OrderHomClass F α β] →\n              [inst_3 : OrderHomClass G β α] →\n                (f : F) → (g : G) → OrderHom.comp ↑f ↑g = OrderHom.id → OrderHom.comp ↑g ↑f = OrderHom.id → α ≃o β",
  "name": "OrderIso.ofHomInv",
  "kind": "def",
  "doc_string":
  "To show that `f : α →o β` and `g : β →o α` make up an order isomorphism it is enough to show\nthat `g` is the inverse of `f`",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → α ↪o β → αᵒᵈ ↪o βᵒᵈ",
  "name": "OrderEmbedding.dual",
  "kind": "def",
  "doc_string":
  "An order embedding is also an order embedding between dual orders. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : Semiring α] →\n    {β : Type v} →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Pow β ℕ] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : NatCast β] →\n                    (f : β → α) →\n                      Function.Injective f →\n                        f 0 = 0 →\n                          f 1 = 1 →\n                            (∀ (x y : β), f (x + y) = f x + f y) →\n                              (∀ (x y : β), f (x * y) = f x * f y) →\n                                (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                  (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) → (∀ (n : ℕ), f ↑n = ↑n) → Semiring β",
  "name": "Function.Injective.semiring",
  "kind": "def",
  "doc_string":
  "Pullback a `Semiring` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "∀ (R : Type u) [inst : Field R], IsField R",
  "name": "Field.toIsField",
  "kind": "theorem",
  "doc_string": "Transferring from `Field` to `IsField`. ",
  "args": ""},
 {"type": "∀ {K : Type u} [self : DivisionRing K], 0⁻¹ = 0",
  "name": "DivisionRing.inv_zero",
  "kind": "def",
  "doc_string": "We define the inverse of `0` to be `0`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, IsMin a → a = ⊥",
  "name": "IsMin.eq_bot",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `isMin_iff_eq_bot`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : LinearOrderedCommGroupWithZero α], a ≤ 1 → b ≤ 1 → a * b ≤ 1",
  "name": "mul_le_one₀",
  "kind": "theorem",
  "doc_string": "Alias of `mul_le_one'` for unification. ",
  "args": ""},
 {"type": "∀ {S₀ : Type u} [self : SemigroupWithZero S₀] (a : S₀), a * 0 = 0",
  "name": "SemigroupWithZero.mul_zero",
  "kind": "def",
  "doc_string": "Zero is a right absorbing element for multiplication ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} {a b : R} [inst : Monoid R] [inst_1 : MulAction R M], a * b = 1 → IsSMulRegular M b",
  "name": "IsSMulRegular.of_mul_eq_one",
  "kind": "theorem",
  "doc_string": "An element of `R` admitting a left inverse is `M`-regular. ",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HSub",
  "kind": "inductive",
  "doc_string":
  "The notation typeclass for heterogeneous subtraction.\nThis enables the notation `a - b : γ` where `a : α`, `b : β`.\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term⊤»",
  "kind": "def",
  "doc_string": "The top (`⊤`, `\\top`) element ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → β → Prop}, Option.Rel r none none",
  "name": "Option.Rel.none",
  "kind": "def",
  "doc_string": "`none ~ none` ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Nat.term_!",
  "kind": "def",
  "doc_string": "factorial notation `n!` ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : PartialOrder α] → (fun x x_1 => x ≤ x_1) →r fun x x_1 => x ≤ x_1",
  "name": "toLinearExtension",
  "kind": "def",
  "doc_string":
  "The embedding of `α` into `LinearExtension α` as a relation homomorphism. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} (s : Set α), (fun x => x) '' s = s",
  "name": "Set.image_id'",
  "kind": "theorem",
  "doc_string": "A variant of `image_id` ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : DistribLattice α] →\n    [inst_1 : BoundedOrder α] → (sdiff : α → α → α) → (∀ (a b c : α), sdiff a b ≤ c ↔ a ≤ b ⊔ c) → CoheytingAlgebra α",
  "name": "CoheytingAlgebra.ofSDiff",
  "kind": "def",
  "doc_string":
  "Construct a co-Heyting algebra from the lattice structure and the difference alone. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : AddMonoid α] → [inst_1 : Repr α] → Repr (AddUnits α)",
  "name": "AddUnits.instReprAddUnits",
  "kind": "def",
  "doc_string":
  "Additive units of an addditive monoid have a representation of the base value in\nthe `AddMonoid`.",
  "args": ""},
 {"type":
  "{M : Type u} →\n  {N : Type v} →\n    [inst : AddMonoid M] →\n      [inst_1 : AddMonoid N] → (f : M →+ N) → (g : M → AddUnits N) → (∀ (x : M), ↑(g x) = ↑f x) → M →+ AddUnits N",
  "name": "AddUnits.liftRight",
  "kind": "def",
  "doc_string":
  "If a map `g : M → AddUnits N` agrees with a homomorphism `f : M →+ N`, then this map\nis an AddMonoid homomorphism too.",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → {γ : Type u_1} → α → α ⊕ β ⊕ γ",
  "name": "Sum3.in₀",
  "kind": "def",
  "doc_string": "The map from the first summand into a ternary sum. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Preorder α] → ClosureOperator α → α → α",
  "name": "ClosureOperator.Simps.apply",
  "kind": "def",
  "doc_string": "See Note [custom simps projection] ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {M : Type u_2} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → MulActionWithZero R M",
  "name": "Module.toMulActionWithZero",
  "kind": "def",
  "doc_string":
  "A module over a semiring automatically inherits a `MulActionWithZero` structure. ",
  "args": ""},
 {"type": "{α : Type u_1} → Set α → Set αᵒᵖ",
  "name": "Set.op",
  "kind": "def",
  "doc_string":
  "The opposite of a set `s` is the set obtained by taking the opposite of each member of `s`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : AddCommGroup α] → AddCommGroup.PositiveCone α → OrderedAddCommGroup α",
  "name": "OrderedAddCommGroup.mkOfPositiveCone",
  "kind": "def",
  "doc_string":
  "Construct an `OrderedAddCommGroup` by\ndesignating a positive cone in an existing `AddCommGroup`. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : Add α] → WithZero (Multiplicative α) ≃* Multiplicative (WithBot α)",
  "name": "WithZero.toMulBot",
  "kind": "def",
  "doc_string":
  "Making an additive monoid multiplicative then adding a zero is the same as adding a bottom\nelement then making it multiplicative. ",
  "args": ""},
 {"type": "(G : Type u_1) → [inst : SubtractionMonoid G] → G ≃+ Gᵃᵒᵖ",
  "name": "AddEquiv.neg'",
  "kind": "def",
  "doc_string":
  "Negation on an additive group is an `AddEquiv` to the opposite group. When `G`\nis commutative, there is `AddEquiv.inv`.",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.AbelNF.Config → Bool",
  "name": "Mathlib.Tactic.Abel.AbelNF.Config.recursive",
  "kind": "def",
  "doc_string":
  "if true, atoms inside ring expressions will be reduced recursively ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α] {x y : α}, IsCompl x y → Disjoint x y",
  "name": "IsCompl.Disjoint",
  "kind": "def",
  "doc_string":
  "If `x` and `y` are to be complementary in an order, they should be disjoint. ",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → {f : α → β} → Function.Surjective f → β → α",
  "name": "Function.surjInv",
  "kind": "def",
  "doc_string":
  "The inverse of a surjective function. (Unlike `invFun`, this does not require\n`α` to be inhabited.) ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → ULift α → (α → ULift β) → ULift β",
  "name": "ULift.bind",
  "kind": "def",
  "doc_string": "Monadic bind. ",
  "args": ""},
 {"type": "{α : Type u} → [self : Mod α] → α → α → α",
  "name": "Mod.mod",
  "kind": "def",
  "doc_string":
  "`a % b` computes the remainder upon dividing `a` by `b`. See `HMod`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : OrderedCommMonoid M] → (S : Submonoid M) → OrderedCommMonoid { x // x ∈ S }",
  "name": "Submonoid.toOrderedCommMonoid",
  "kind": "def",
  "doc_string":
  "A submonoid of an `OrderedCommMonoid` is an `OrderedCommMonoid`. ",
  "args": ""},
 {"type":
  "{F : Type u → Type v} → [inst : Applicative F] → ApplicativeTransformation F F",
  "name": "ApplicativeTransformation.idTransformation",
  "kind": "def",
  "doc_string":
  "The identity applicative transformation from an applicative functor to itself. ",
  "args": ""},
 {"type":
  "{σ : Type w₂} → {α : Type u_1} → {β : Type u_2} → (α → σ → σ × β) → List α → σ → σ × List β",
  "name": "List.mapAccumr",
  "kind": "def",
  "doc_string":
  "Runs a function over a list returning the intermediate results and a\na final result.\n",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Zero M₂] →\n      [inst_1 : One M₂] →\n        [inst_2 : Add M₂] →\n          [inst_3 : Neg M₂] →\n            [inst_4 : Sub M₂] →\n              [inst_5 : SMul ℕ M₂] →\n                [inst_6 : SMul ℤ M₂] →\n                  [inst_7 : NatCast M₂] →\n                    [inst_8 : IntCast M₂] →\n                      [inst_9 : AddGroupWithOne M₁] →\n                        (f : M₁ → M₂) →\n                          Function.Surjective f →\n                            f 0 = 0 →\n                              f 1 = 1 →\n                                (∀ (x y : M₁), f (x + y) = f x + f y) →\n                                  (∀ (x : M₁), f (-x) = -f x) →\n                                    (∀ (x y : M₁), f (x - y) = f x - f y) →\n                                      (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                        (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) →\n                                          (∀ (n : ℕ), f ↑n = ↑n) → (∀ (n : ℤ), f ↑n = ↑n) → AddGroupWithOne M₂",
  "name": "Function.Surjective.addGroupWithOne",
  "kind": "def",
  "doc_string":
  "A type endowed with `0`, `1`, `+` is an additive group with one,\nif it admits a surjective map that preserves `0`, `1`, and `+` to an additive group with one.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  (p : α → Prop) → [inst : DecidablePred p] → Equiv.Perm { a // p a } × Equiv.Perm { a // ¬p a } →* Equiv.Perm α",
  "name": "Equiv.Perm.subtypeCongrHom",
  "kind": "def",
  "doc_string": "`Equiv.Perm.subtypeCongr` as a `MonoidHom`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a b : R), (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2",
  "name": "add_pow_two",
  "kind": "theorem",
  "doc_string": "**Alias** of `add_sq`.",
  "args": ""},
 {"type": "Num → Option Num",
  "name": "Num.ppred",
  "kind": "def",
  "doc_string":
  "The predecessor of a `Num` as an `Option Num`, where `ppred 0 = none` ",
  "args": ""},
 {"type": "Type",
  "name": "Sat.Valuation",
  "kind": "def",
  "doc_string":
  "A valuation is an assignment of values to all the propositional variables. ",
  "args": ""},
 {"type":
  "∀ {M' : Type u_1} {α : Type u_2} {β : Type u_3} [inst : MulOneClass M'] [inst_1 : SMul α β] [inst_2 : SMul M' α]\n  [inst_3 : SMul M' β] [inst_4 : IsScalarTower M' α β] (S : Submonoid M'), IsScalarTower { x // x ∈ S } α β",
  "name":
  "Submonoid.instIsScalarTowerSubtypeMemSubmonoidInstMembershipInstSetLikeSubmonoidInstSMulSubtypeMemSubmonoidInstMembershipInstSetLikeSubmonoidInstSMulSubtypeMemSubmonoidInstMembershipInstSetLikeSubmonoid",
  "kind": "def",
  "doc_string":
  "Note that this provides `IsScalarTower S M' M'` which is needed by `SMulMulAssoc`. ",
  "args": ""},
 {"type":
  "Array Lean.Ident → optParam Bool false → optParam Bool true → Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Tactic.elabCasesType",
  "kind": "def",
  "doc_string": "Common implementation of `cases_type` and `cases_type!`. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {α : ι → Type u_2} → [inst : LT ι] → [inst : (i : ι) → LE (α i)] → LE (Lex ((i : ι) ×' α i))",
  "name": "PSigma.Lex.le",
  "kind": "def",
  "doc_string": "The lexicographical `≤` on a sigma type. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    [inst : NonUnitalNonAssocSemiring R] → [inst : NonUnitalNonAssocSemiring S] → NonUnitalNonAssocSemiring (R × S)",
  "name": "Prod.instNonUnitalNonAssocSemiringProd",
  "kind": "def",
  "doc_string":
  "Product of two `NonUnitalNonAssocSemiring`s is a `NonUnitalNonAssocSemiring`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u₁} [inst : NonUnitalNonAssocSemiring R], SMulCommClass ℕ R R",
  "name": "NonUnitalNonAssocSemiring.nat_smulCommClass",
  "kind": "def",
  "doc_string":
  "Note that `AddCommMonoid.nat_smulCommClass` requires stronger assumptions on `R`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (β → α) → (α → β) → Set β → Prop",
  "name": "Set.RightInvOn",
  "kind": "def",
  "doc_string":
  "`g` is a right inverse to `f` on `b` if `f (g x) = x` for all `x ∈ b`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] →\n        {M' : Type u_3} →\n          {N' : Type u_4} →\n            [inst_2 : MulOneClass M'] → [inst_3 : MulOneClass N'] → (M →* M') → (N →* N') → M × N →* M' × N'",
  "name": "MonoidHom.prodMap",
  "kind": "def",
  "doc_string": "`prod.map` as a `MonoidHom`. ",
  "args": ""},
 {"type": "{α : Type u} → {n : ℕ} → α → Vector α n → Vector α (Nat.succ n)",
  "name": "Vector.cons",
  "kind": "def",
  "doc_string":
  "If `a : α` and `l : Vector α n`, then `cons a l`, is the vector of length `n + 1`\nwhose first element is a and with l as the rest of the list. ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : GeneralizedBooleanAlgebra α] → [inst : OrderTop α] → BooleanAlgebra α",
  "name": "GeneralizedBooleanAlgebra.toBooleanAlgebra",
  "kind": "def",
  "doc_string": "A bounded generalized boolean algebra is a boolean algebra. ",
  "args": ""},
 {"type":
  "outParam (Type u) → (Type v → Type w) → Type (max (max u (v + 1)) w)",
  "name": "MonadExcept",
  "kind": "inductive",
  "doc_string":
  "Similar to `MonadExceptOf`, but `ε` is an `outParam` for convenience. ",
  "args": ""},
 {"type": "Type → Type",
  "name": "Mathlib.Tactic.Ring.RingM",
  "kind": "def",
  "doc_string":
  "The monad that `ring` works in. This is only used for collecting atoms. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : HasSup α] →\n      [inst_1 : HasInf α] →\n        [inst_2 : Lattice β] →\n          (f : α → β) →\n            Function.Injective f →\n              (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) → (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) → Lattice α",
  "name": "Function.Injective.lattice",
  "kind": "def",
  "doc_string":
  "A type endowed with `⊔` and `⊓` is a `Lattice`, if it admits an injective map that\npreserves `⊔` and `⊓` to a `Lattice`.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : One M₁] →\n        [inst_2 : Pow M₁ ℕ] →\n          [inst_3 : LeftCancelMonoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 1 = 1 →\n                  (∀ (x y : M₁), f (x * y) = f x * f y) →\n                    (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) → LeftCancelMonoid M₁",
  "name": "Function.Injective.leftCancelMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `1` and `*` is a left cancel monoid, if it admits an injective map that\npreserves `1` and `*` to a left cancel monoid. See note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u_1} → LE (Setoid α)",
  "name": "Setoid.instLESetoid",
  "kind": "def",
  "doc_string": "Defining `≤` for equivalence relations. ",
  "args": ""},
 {"type": "ℕ →+* ℤ",
  "name": "Int.ofNatHom",
  "kind": "def",
  "doc_string": "Coercion `ℕ → ℤ` as a `RingHom`. ",
  "args": ""},
 {"type": "ℤ → ℤ → ℕ",
  "name": "Int.gcd",
  "kind": "def",
  "doc_string":
  "Computes the greatest common divisor of two integers, as a `Nat`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → Set α → Prop",
  "name": "Set.OrdConnected",
  "kind": "inductive",
  "doc_string":
  "We say that a set `s : Set α` is `OrdConnected` if for all `x y ∈ s` it includes the\ninterval `[[x, y]]`. If `α` is a `DenselyOrdered` `ConditionallyCompleteLinearOrder` with\nthe `OrderTopology`, then this condition is equivalent to `IsPreconnected s`. If `α` is a\n`LinearOrderedField`, then this condition is also equivalent to `Convex α s`. ",
  "args": ""},
 {"type": "(ℕ → Prop) → Type",
  "name": "Nat.Upto",
  "kind": "def",
  "doc_string":
  "The subtype of natural numbers `i` which have the property that\nno `j` less than `i` satisfies `p`. This is an initial segment of the\nnatural numbers, up to and including the first value satisfying `p`.\n\nWe will be particularly interested in the case where there exists a value\nsatisfying `p`, because in this case the `>` relation is well-founded.  ",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  {H : Type u_2} → [inst : AddZeroClass G] → [inst_1 : MulOneClass H] → Multiplicative G ≃* H ≃ (G ≃+ Additive H)",
  "name": "MulEquiv.toAdditive''",
  "kind": "def",
  "doc_string": "Reinterpret `Multiplicative G ≃* H` as `G ≃+ Additive H` as. ",
  "args": ""},
 {"type": "ℕ → Bool × ℕ",
  "name": "Nat.boddDiv2",
  "kind": "def",
  "doc_string":
  "`boddDiv2 n` returns a 2-tuple of type `(Bool,Nat)`\nwhere the `Bool` value indicates whether `n` is odd or not\nand the `Nat` value returns `⌊n/2⌋` ",
  "args": ""},
 {"type":
  "∀ {G : Type u} [self : SubtractionCommMonoid G] (a b : G), a + b = b + a",
  "name": "SubtractionCommMonoid.add_comm",
  "kind": "def",
  "doc_string":
  "Addition is commutative in an additive commutative semigroup. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α :\n      let u := u;\n      Q(Type u)} →\n    Q(AddMonoid «$α») → List Q(«$α») → Q(«$α»)",
  "name": "Linarith.addExprs'",
  "kind": "def",
  "doc_string": "A type-safe analogue of `addExprs`. ",
  "args": ""},
 {"type":
  "{α₁ : Sort u_1} →\n  {α₂ : Sort u_2} →\n    {β₁ : α₁ → Sort u_3} → {β₂ : α₂ → Sort u_4} → (f₁ : α₁ → α₂) → ((a : α₁) → β₁ a → β₂ (f₁ a)) → PSigma β₁ → PSigma β₂",
  "name": "PSigma.map",
  "kind": "def",
  "doc_string": "Map the left and right components of a sigma ",
  "args": ""},
 {"type":
  "{α₁ : Type u_1} → {β₁ : Type u_2} → [inst : DecidableEq α₁] → α₁ → Equiv.Perm β₁ → Equiv.Perm (α₁ × β₁)",
  "name": "Equiv.Perm.prodExtendRight",
  "kind": "def",
  "doc_string":
  "`prodExtendRight a e` extends `e : Perm β` to `Perm (α × β)` by sending `(a, b)` to\n`(a, e b)` and keeping the other `(a', b)` fixed. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : AddSemigroup S] {a b x y z : S},\n  AddSemiconjBy a y z → AddSemiconjBy b x y → AddSemiconjBy (a + b) x z",
  "name": "AddSemiconjBy.add_left",
  "kind": "theorem",
  "doc_string":
  "If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a + b`\nsemiconjugates `x` to `z`.",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → (α ≃. β) → β → Option α",
  "name": "PEquiv.invFun",
  "kind": "def",
  "doc_string": "The partial inverse of `toFun` ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "InfSet",
  "kind": "inductive",
  "doc_string": "class for the `infₛ` operator ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β),\n  0 = 1 ↔ Set.range ↑f = {0}",
  "name": "RingHom.codomain_trivial_iff_range_eq_singleton_zero",
  "kind": "theorem",
  "doc_string": "`f : α →+* β` has a trivial codomain iff its range is `{0}`. ",
  "args": ""},
 {"type": "Sat.Valuation → Sat.Fmla → Prop → Prop",
  "name": "Sat.Fmla.reify",
  "kind": "inductive",
  "doc_string": "Asserts that `¬⟦f⟧_v` implies `p`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : NonAssocSemiring α] →\n      [inst_1 : NonAssocRing β] → (f : α →* β) → (∀ (a b : α), ↑f (a + b) = ↑f a + ↑f b) → α →+* β",
  "name": "RingHom.mk'",
  "kind": "def",
  "doc_string":
  "Makes a ring homomorphism from a monoid homomorphism of rings which preserves addition. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Set α → Prop",
  "name": "StrictMonoOn",
  "kind": "def",
  "doc_string":
  "A function `f` is strictly monotone on `s` if, for all `a, b ∈ s`, `a < b` implies\n`f a < f b`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {ι : Type u_2} → [inst : PartialOrder α] → [inst : OrderBot α] → Set ι → (ι → α) → Prop",
  "name": "Set.PairwiseDisjoint",
  "kind": "def",
  "doc_string":
  "A set is `PairwiseDisjoint` under `f`, if the images of any distinct two elements under `f`\nare disjoint.\n\n`s.Pairwise Disjoint` is (definitionally) the same as `s.PairwiseDisjoint id`. We prefer the latter\nin order to allow dot notation on `Set.PairwiseDisjoint`, even though the former unfolds more\nnicely. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_∪_»",
  "kind": "def",
  "doc_string": "`a ∪ b` is the union of`a` and `b`. ",
  "args": ""},
 {"type":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : Quot r → Sort v} →\n      (f : (a : α) → motive (Quot.mk r a)) →\n        (∀ (a b : α) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b) → (q : Quot r) → motive q",
  "name": "Quot.rec",
  "kind": "def",
  "doc_string":
  "Dependent recursion principle for `Quot`. This constructor can be tricky to use,\nso you should consider the simpler versions if they apply:\n* `Quot.lift`, for nondependent functions\n* `Quot.ind`, for theorems / proofs of propositions about quotients\n* `Quot.recOnSubsingleton`, when the target type is a `Subsingleton`\n* `Quot.hrecOn`, which uses `HEq (f a) (f b)` instead of a `sound p ▸ f a = f b` assummption\n",
  "args": ""},
 {"type":
  "∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] (σ₁₂ : R₁ →+* R₂) (σ₂₁ : R₂ →+* R₁)\n  [inst_2 : RingHomInvPair σ₁₂ σ₂₁], RingHomInvPair σ₂₁ σ₁₂",
  "name": "RingHomInvPair.symm",
  "kind": "theorem",
  "doc_string":
  "Swap the direction of a `ring_hom_inv_pair`. This is not an instance as it would loop, and better\ninstances are often available and may often be preferrable to using this one. Indeed, this\ndeclaration is not currently used in mathlib.\n\nSee note [reducible non-instances].\n",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    [inst : Semiring R] → [inst_1 : Semiring S] → (f : R →+* S) → (∀ (x y : R), Commute (↑f x) (↑f y)) → Rᵐᵒᵖ →+* S",
  "name": "RingHom.fromOpposite",
  "kind": "def",
  "doc_string":
  "A ring homomorphism `f : R →+* S` such that `f x` commutes with `f y` for all `x, y` defines\na ring homomorphism from `Rᵐᵒᵖ`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, 0 ≤ -a ↔ a ≤ 0",
  "name": "Left.nonneg_neg_iff",
  "kind": "theorem",
  "doc_string": "Uses `left` co(ntra)variant.",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : OrderedAddCommMonoid α] →\n    {β : Type u_1} →\n      [inst_1 : Zero β] →\n        [inst_2 : Add β] →\n          [inst_3 : SMul ℕ β] →\n            (f : β → α) →\n              Function.Injective f →\n                f 0 = 0 →\n                  (∀ (x y : β), f (x + y) = f x + f y) →\n                    (∀ (x : β) (n : ℕ), f (n • x) = n • f x) → OrderedAddCommMonoid β",
  "name": "Function.Injective.orderedAddCommMonoid",
  "kind": "def",
  "doc_string": "Pullback an `OrderedAddCommMonoid` under an injective map.",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u₃} →\n          [inst_2 : CategoryTheory.Category E] →\n            {F G : C ⥤ D} →\n              (H : D ⥤ E) →\n                [inst_3 : CategoryTheory.Full H] → [inst_4 : CategoryTheory.Faithful H] → (F ⋙ H ≅ G ⋙ H) → (F ≅ G)",
  "name": "CategoryTheory.fullyFaithfulCancelRight",
  "kind": "def",
  "doc_string":
  "Given a natural isomorphism between `F ⋙ H` and `G ⋙ H` for a fully faithful functor `H`, we\ncan 'cancel' it to give a natural iso between `F` and `G`.\n",
  "args": ""},
 {"type": "ℕ → Mathlib.Tactic.Polyrith.Source",
  "name": "Mathlib.Tactic.Polyrith.Source.input",
  "kind": "def",
  "doc_string":
  "`input n` refers to the `n`'th input `ai` in `polyrith [a1, ..., an]`. ",
  "args": ""},
 {"type": "EmptyRelation ≺i EmptyRelation",
  "name": "PrincipalSeg.pemptyToPunit",
  "kind": "def",
  "doc_string":
  "Principal segment from the empty relation on `pempty` to the empty relation on `punit`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → AddHom M N → AddHom (WithBot M) (WithBot N)",
  "name": "AddHom.withBotMap",
  "kind": "def",
  "doc_string": "A version of `WithBot.map` for `AddHom`s. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulMonoRev α],\n  a * b ≤ a * c → 0 < a → b ≤ c",
  "name": "le_of_mul_le_mul_of_pos_left",
  "kind": "theorem",
  "doc_string": "**Alias** of `le_of_mul_le_mul_left`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {β₁ : α → Type u_3} → ((a : α) → β₁ a ≃ β) → Sigma β₁ ≃ α × β",
  "name": "Equiv.sigmaEquivProdOfEquiv",
  "kind": "def",
  "doc_string":
  "If each fiber of a `Sigma` type is equivalent to a fixed type, then the sigma type\nis equivalent to the product. ",
  "args": ""},
 {"type":
  "{α : Type u} → (a b : α) → (Unit → Decidable (a = b)) → Decidable (a = b)",
  "name": "withPtrEqDecEq",
  "kind": "def",
  "doc_string": "`withPtrEq` for `DecidableEq` ",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Add M] → Type u_1",
  "name": "AddAut",
  "kind": "def",
  "doc_string": "The group of additive automorphisms.",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List Bool → List α → List α",
  "name": "List.replaceIf",
  "kind": "def",
  "doc_string":
  "Given a starting list `old`, a list of booleans and a replacement list `new`,\nread the items in `old` in succession and either replace them with the next element of `new` or\nnot, according as to whether the corresponding boolean is `true` or `false`. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u_1} →\n          [inst_2 : CategoryTheory.Category E] →\n            {F G : C ⥤ D} →\n              (H : D ⥤ E) →\n                [inst_3 : CategoryTheory.Full H] → [inst_4 : CategoryTheory.Faithful H] → (F ⋙ H ⟶ G ⋙ H) → (F ⟶ G)",
  "name": "CategoryTheory.natTransOfCompFullyFaithful",
  "kind": "def",
  "doc_string":
  "We can construct a natural transformation between functors by constructing a\nnatural transformation between those functors composed with a fully faithful functor. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : Neg M₁] →\n            [inst_4 : Sub M₁] →\n              [inst_5 : SMul ℤ M₁] →\n                [inst_6 : AddGroup M₂] →\n                  (f : M₁ → M₂) →\n                    Function.Injective f →\n                      f 0 = 0 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁), f (-x) = -f x) →\n                            (∀ (x y : M₁), f (x - y) = f x - f y) →\n                              (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) → AddGroup M₁",
  "name": "Function.Injective.addGroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `0` and `+` is an additive group, if it admits an\ninjective map that preserves `0` and `+` to an additive group.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Order.Coframe",
  "kind": "inductive",
  "doc_string":
  "A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `⊔` distributes over `⨅`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → α → List α → Prop",
  "name": "List.Chain",
  "kind": "inductive",
  "doc_string":
  "`Chain R a l` means that `R` holds between adjacent elements of `a::l`.\n```\nChain R a [b, c, d] ↔ R a b ∧ R b c ∧ R c d\n``` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c d : α},\n  a < b → c < d → a + c < b + d",
  "name": "Left.add_lt_add",
  "kind": "theorem",
  "doc_string": "Only assumes left strict covariance",
  "args": ""},
 {"type": "{V : Type u} → [self : Quiver V] → V → V → Sort v",
  "name": "Quiver.Hom",
  "kind": "def",
  "doc_string":
  "The type of edges/arrows/morphisms between a given source and target. ",
  "args": ""},
 {"type": "Prop → Type",
  "name": "SlimCheck.Testable",
  "kind": "inductive",
  "doc_string": "`Testable p` uses random examples to try to disprove `p`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a = b → b ≤ c → a ≤ c",
  "name": "Eq.trans_le",
  "kind": "theorem",
  "doc_string": "**Alias** of `le_of_eq_of_le`.",
  "args": ""},
 {"type": "ℤ → ℤ → ℤ",
  "name": "Int.gcdB",
  "kind": "def",
  "doc_string":
  "The extended GCD `b` value in the equation `gcd x y = x * a + y * b`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : CompleteSemilatticeSup α] → CompleteLattice α",
  "name": "completeLatticeOfCompleteSemilatticeSup",
  "kind": "def",
  "doc_string":
  "Any `CompleteSemilatticeSup` is in fact a `CompleteLattice`.\n\nNote that this construction has bad definitional properties:\nsee the doc-string on `completeLatticeOfSup`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {a : α} {n : ℤ}, Odd n → a ≤ 0 → a ^ n ≤ 0",
  "name": "Odd.zpow_nonpos",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `Odd.zpow_nonpos_iff`.",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Distrib R] → R → AddHom R R",
  "name": "AddHom.mulLeft",
  "kind": "def",
  "doc_string":
  "Left multiplication by an element of a type with distributive multiplication is an `AddHom`. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} [inst : Group G] (a : G), ↑(Equiv.symm (Equiv.mulLeft a)) = fun x => a⁻¹ * x",
  "name": "Equiv.mulLeft_symm_apply",
  "kind": "theorem",
  "doc_string":
  "Extra simp lemma that `dsimp` can use. `simp` will never use this. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → (f : α → β) → {p : β → Prop} → (∀ (a : α), p (f a)) → α → Subtype p",
  "name": "Subtype.coind",
  "kind": "def",
  "doc_string":
  "Defining a map into a subtype, this can be seen as an \"coinduction principle\" of `Subtype`",
  "args": ""},
 {"type":
  "{α : Type u} → {p : α → Prop} → [inst : LE α] → [inst_1 : OrderTop α] → p ⊤ → OrderTop { x // p x }",
  "name": "Subtype.orderTop",
  "kind": "def",
  "doc_string": "A subtype remains a `⊤`-order if the property holds at `⊤`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → {γ : Sort u_3} → (α ↪ β) → (β ↪ γ) → α ↪ γ",
  "name": "Function.Embedding.trans",
  "kind": "def",
  "doc_string": "Composition of `f : α ↪ β` and `g : β ↪ γ`. ",
  "args": ""},
 {"type": "Prop → Type",
  "name": "Decidable",
  "kind": "inductive",
  "doc_string":
  "`Decidable p` is a data-carrying class that supplies a proof that `p` is\neither `true` or `false`. It is equivalent to `Bool` (and in fact it has the\nsame code generation as `Bool`) together with a proof that the `Bool` is\ntrue iff `p` is.\n\n`Decidable` instances are used to infer \"computation strategies\" for\npropositions, so that you can have the convenience of writing propositions\ninside `if` statements and executing them (which actually executes the inferred\ndecidability instance instead of the proposition, which has no code).\n\nIf a proposition `p` is `Decidable`, then `(by decide : p)` will prove it by\nevaluating the decidability instance to `isTrue h` and returning `h`.\n",
  "args": ""},
 {"type":
  "{p : ℕ → Prop} → [inst : DecidablePred p] → (∃ n, p n) → { n // p n ∧ ∀ (m : ℕ), m < n → ¬p m }",
  "name": "Nat.findX",
  "kind": "def",
  "doc_string":
  "Used in the definition of `Nat.find`. Returns the smallest natural satisfying `p`",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : Add M] → Top (AddSubsemigroup M)",
  "name": "AddSubsemigroup.instTopSubsemigroup",
  "kind": "def",
  "doc_string": "The additive subsemigroup `M` of the magma `M`.",
  "args": ""},
 {"type":
  "{V : Type u_1} →\n  [inst : Quiver V] →\n    {W : Type u_3} →\n      (σ : V → W) →\n        {W' : Type u_4} →\n          [inst_1 : Quiver W'] →\n            (φ : V ⥤q W') → (τ : W → W') → (∀ (x : V), Prefunctor.obj φ x = τ (σ x)) → Quiver.Push σ ⥤q W'",
  "name": "Quiver.Push.lift",
  "kind": "def",
  "doc_string":
  "Given a function `τ : W → W'` and a prefunctor `φ : V ⥤q W'`, one can extend `τ` to be\na prefunctor `W ⥤q W'` if `τ` and `σ` factorize `φ` at the level of objects, where `W` is given\nthe pushforward quiver structure `Push σ`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Add M] {s : Set M} {p : M → M → Prop} {x y : M},\n  x ∈ AddSubsemigroup.closure s →\n    y ∈ AddSubsemigroup.closure s →\n      (∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → p x y) →\n        (∀ (x y z : M), p x z → p y z → p (x + y) z) → (∀ (x y z : M), p z x → p z y → p z (x + y)) → p x y",
  "name": "AddSubsemigroup.closure_induction₂",
  "kind": "theorem",
  "doc_string":
  "An induction principle for additive closure membership for\npredicates with two arguments.",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MulOneClass M] {s : Set M} {p : M → M → Prop} {x y : M},\n  x ∈ Submonoid.closure s →\n    y ∈ Submonoid.closure s →\n      (∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → p x y) →\n        (∀ (x : M), p 1 x) →\n          (∀ (x : M), p x 1) →\n            (∀ (x y z : M), p x z → p y z → p (x * y) z) → (∀ (x y z : M), p z x → p z y → p z (x * y)) → p x y",
  "name": "Submonoid.closure_induction₂",
  "kind": "theorem",
  "doc_string":
  "An induction principle for closure membership for predicates with two arguments.  ",
  "args": ""},
 {"type": "∀ {α : Type u} {s t : Set α}, t ⊆ s → Disjoint (sᶜ) t",
  "name": "HasSubset.Subset.disjoint_compl_left",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Set.disjoint_compl_left_iff_subset`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : PartialOrder α] → [inst_1 : Preorder β] → {u : β → α} → LowerAdjoint u → ClosureOperator α",
  "name": "LowerAdjoint.closureOperator",
  "kind": "def",
  "doc_string":
  "Every lower adjoint induces a closure operator given by the composition. This is the partial\norder version of the statement that every adjunction induces a monad. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r : α → α → Prop} [self : IsDirected α r] (a b : α), ∃ c, r a c ∧ r b c",
  "name": "IsDirected.directed",
  "kind": "def",
  "doc_string":
  "For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` ",
  "args": ""},
 {"type": "Prop ≃ Bool",
  "name": "Equiv.propEquivBool",
  "kind": "def",
  "doc_string": "`Prop` is noncomputably equivalent to `Bool`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLinearOrder α] {s : Set α} {b : α},\n  Set.Nonempty s → infₛ s < b → ∃ a, a ∈ s ∧ a < b",
  "name": "exists_lt_of_cinfₛ_lt",
  "kind": "theorem",
  "doc_string":
  "When `infₛ s < b`, there is an element `a` in `s` with `a < b`, if `s` is nonempty and the order\nis a linear order.",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List (List α) → List α",
  "name": "List.intercalateTR",
  "kind": "def",
  "doc_string": "Tail recursive version of `intercalate`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : HasSup α] →\n    (∀ (a b : α), a ⊔ b = b ⊔ a) → (∀ (a b c : α), a ⊔ b ⊔ c = a ⊔ (b ⊔ c)) → (∀ (a : α), a ⊔ a = a) → SemilatticeSup α",
  "name": "SemilatticeSup.mk'",
  "kind": "def",
  "doc_string":
  "A type with a commutative, associative and idempotent binary `sup` operation has the structure of a\njoin-semilattice.\n\nThe partial order is defined so that `a ≤ b` unfolds to `a ⊔ b = b`; cf. `sup_eq_right`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α → ℕ → Array α → List α",
  "name": "List.takeTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `take`: `take.go l xs n acc = acc.toList ++ take n xs`,\nunless `n ≥ xs.length` in which case it returns `l`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : ConditionallyCompleteLinearOrder α] → DecidableRel fun x x_1 => x ≤ x_1",
  "name": "ConditionallyCompleteLinearOrder.decidable_le",
  "kind": "def",
  "doc_string":
  "In a `ConditionallyCompleteLinearOrder`, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "{m n : ℕ} → Nat.coprime n m → (a b : ℕ) → { k // k ≡ a [MOD n] ∧ k ≡ b [MOD m] }",
  "name": "Nat.chineseRemainder",
  "kind": "def",
  "doc_string":
  "The natural number less than `n*m` congruent to `a` mod `n` and `b` mod `m` ",
  "args": ""},
 {"type": "Prop → Type",
  "name": "SlimCheck.Decorations.DecorationsOf",
  "kind": "def",
  "doc_string":
  "`DecorationsOf p` is used as a hint to `mk_decorations` to specify\nthat the goal should be satisfied with a proposition equivalent to `p`\nwith added annotations. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (r : α → α → Prop) → (s : β → β → Prop) → r ↪r Sum.Lex r s",
  "name": "RelEmbedding.sumLexInl",
  "kind": "def",
  "doc_string": "`Sum.inl` as a relation embedding into `Sum.Lex r s`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Int.«term_≡_[ZMOD_]»",
  "kind": "def",
  "doc_string": "`a ≡ b [ZMOD n]` when `a % n = b % n`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : OrderedCancelCommMonoid α] (a b c : α), a * b ≤ a * c → b ≤ c",
  "name": "OrderedCancelCommMonoid.le_of_mul_le_mul_left",
  "kind": "def",
  "doc_string":
  "Cancellation is compatible with the order in an ordered cancellative commutative monoid. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → Q(CommSemiring «$α») → Q(«$α») → Type",
  "name": "Mathlib.Tactic.Ring.ExBase",
  "kind": "inductive",
  "doc_string": "The base `e` of a normalized exponent expression. ",
  "args": ""},
 {"type": "∀ {α : Sort u_1} {p : α → Prop} (P : ∃ a, p a), p (Exists.choose P)",
  "name": "Exists.choose_spec",
  "kind": "theorem",
  "doc_string":
  "Show that an element extracted from `P : ∃ a, p a` using `P.choose` satisfies `p`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List ℕ → List (List α) × List α",
  "name": "List.takeListTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `takeList`. ",
  "args": ""},
 {"type":
  "{I : Type u} →\n  {f : I → Type v} →\n    {γ : Type w} → [inst : (i : I) → Mul (f i)] → [inst_1 : Mul γ] → ((i : I) → γ →ₙ* f i) → γ →ₙ* (i : I) → f i",
  "name": "Pi.mulHom",
  "kind": "def",
  "doc_string":
  "A family of MulHom's `f a : γ →ₙ* β a` defines a MulHom `Pi.mulHom f : γ →ₙ* Π a, β a`\ngiven by `Pi.mulHom f x b = f b x`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  (s : Set α) →\n    [inst : ConditionallyCompleteLinearOrder α] →\n      [inst_1 : Inhabited ↑s] → [inst : Set.OrdConnected s] → ConditionallyCompleteLinearOrder ↑s",
  "name": "ordConnectedSubsetConditionallyCompleteLinearOrder",
  "kind": "def",
  "doc_string":
  "A nonempty `OrdConnected` set in a conditionally complete linear order is naturally a\nconditionally complete linear order. ",
  "args": ""},
 {"type":
  "Lean.Syntax → Lean.Name → String → Lean.Expr → Array ℕ → Array Lean.Expr → Lean.MetaM (Lean.Expr × Array ℕ)",
  "name": "getCompositeOfProjectionsAux",
  "kind": "opaque",
  "doc_string": "Auxiliary function of `getCompositeOfProjections`. ",
  "args": ""},
 {"type": "ParsedProjectionData → Lean.Name × Lean.Syntax",
  "name": "ParsedProjectionData.origName",
  "kind": "def",
  "doc_string":
  "name and syntax for this projection used in the structure definition ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsIncompTrans",
  "kind": "inductive",
  "doc_string":
  "`IsIncompTrans X lt` means that for `lt` a binary relation on `X`, the incomparable relation\n`λ a b, ¬ lt a b ∧ ¬ lt b a` is transitive. ",
  "args": ""},
 {"type":
  "∀ {P : ℤ → Prop} [inst : DecidablePred P],\n  (∃ b, ∀ (z : ℤ), P z → z ≤ b) → (∃ z, P z) → ∃ ub, P ub ∧ ∀ (z : ℤ), P z → z ≤ ub",
  "name": "Int.exists_greatest_of_bdd",
  "kind": "theorem",
  "doc_string":
  "If `P : ℤ → Prop` is a predicate such that the set `{m : P m}` is bounded above and nonempty,\nthen this set has the greatest element. This lemma uses classical logic to avoid assumption\n`[DecidablePred P]`. See `Int.greatestOfBdd` for a constructive counterpart. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → α ↪o β → WithBot α ↪o WithBot β",
  "name": "OrderEmbedding.withBotMap",
  "kind": "def",
  "doc_string": "A version of `WithBot.map` for order embeddings. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : BEq α] →\n    (α → Bool) → (s : Aesop.UnorderedArraySet α) → optParam ℕ 0 → optParam ℕ (Aesop.UnorderedArraySet.size s) → Bool",
  "name": "Aesop.UnorderedArraySet.all",
  "kind": "def",
  "doc_string": "O(n) ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : CompleteLattice α] → (f : α →o α) → (x : α) → x ≤ ↑f x → ↑(Function.fixedPoints ↑f)",
  "name": "OrderHom.nextFixed",
  "kind": "def",
  "doc_string":
  "Next fixed point of a monotone map. If `f` is a monotone self-map of a complete lattice and\n`x` is a point such that `x ≤ f x`, then `f.nextFixed x hx` is the least fixed point of `f`\nthat is greater than or equal to `x`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulMono α],\n  1 ≤ a → 1 ≤ b → 0 ≤ a → 1 ≤ a * b",
  "name": "Left.one_le_mul_of_le_of_le",
  "kind": "theorem",
  "doc_string": "Assumes left covariance. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.Expr → Lean.MetaM (Option Lean.Meta.Simp.Result)",
  "name": "Tactic.NormCast.proveEqUsingDown",
  "kind": "def",
  "doc_string": "Prove `a = b` by simplifying using move and squash lemmas. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Lattice α] → Prop",
  "name": "IsUpperModularLattice",
  "kind": "inductive",
  "doc_string":
  "An upper modular lattice, aka semimodular lattice, is a lattice where `a ⊔ b` covers `a` and `b`\nif either `a` or `b` covers `a ⊓ b`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : BoundedOrder α] [self : ComplementedLattice α] (a : α), ∃ b, IsCompl a b",
  "name": "ComplementedLattice.exists_isCompl",
  "kind": "def",
  "doc_string":
  "In a `ComplementedLattice`, every element admits a complement. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "LinearOrderedCommMonoidWithZero",
  "kind": "inductive",
  "doc_string": "A linearly ordered commutative monoid with a zero element. ",
  "args": ""},
 {"type": "ℚ → ℚ → Prop",
  "name": "Rat.le'",
  "kind": "def",
  "doc_string":
  "Relation `a ≤ b` on `ℚ` defined as `a ≤ b ↔ Rat.Nonneg (b - a)`. Use `a ≤ b` instead of\n`Rat.le a b`. ",
  "args": ""},
 {"type":
  "{R : Type u} → [inst : EuclideanDomain R] → [inst : DecidableEq R] → R → R → R → R → R → R → R × R × R",
  "name": "EuclideanDomain.xgcdAux",
  "kind": "def",
  "doc_string":
  "An implementation of the extended GCD algorithm.\nAt each step we are computing a triple `(r, s, t)`, where `r` is the next value of the GCD\nalgorithm, to compute the greatest common divisor of the input (say `x` and `y`), and `s` and `t`\nare the coefficients in front of `x` and `y` to obtain `r` (i.e. `r = s * x + t * y`).\nThe function `xgcdAux` takes in two triples, and from these recursively computes the next triple:\n```\nxgcdAux (r, s, t) (r', s', t') = xgcdAux (r' % r, s' - (r' / r) * s, t' - (r' / r) * t) (r, s, t)\n```\n",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x : G), ↑h x⁻¹ = (↑h x)⁻¹",
  "name": "MulEquiv.map_inv",
  "kind": "theorem",
  "doc_string": "A multiplicative equivalence of groups preserves inversion. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : AddCommSemigroup M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [inst : AddMemClass A M] → (S : A) → AddCommSemigroup { x // x ∈ S }",
  "name": "AddMemClass.toAddCommSemigroup",
  "kind": "def",
  "doc_string":
  "An `AddSubsemigroup` of an `AddCommSemigroup` is an `AddCommSemigroup`.",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {F : C → D}\n  [self : CategoryTheory.Functorial F] {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z),\n  CategoryTheory.Functorial.map' (f ≫ g) = CategoryTheory.Functorial.map' f ≫ CategoryTheory.Functorial.map' g",
  "name": "CategoryTheory.Functorial.map_comp'",
  "kind": "def",
  "doc_string": "A functorial map preserves composition of morphisms. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedField α] (a : ℚ) (x : α), LinearOrderedField.qsmul a x = ↑a * x",
  "name": "LinearOrderedField.qsmul_eq_mul'",
  "kind": "def",
  "doc_string":
  "However `qsmul` is defined,\npropositionally it must be equal to multiplication by `ratCast`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Preorder α] → Type u_1",
  "name": "PredOrder",
  "kind": "inductive",
  "doc_string": "Order equipped with a sensible predecessor function. ",
  "args": ""},
 {"type":
  "Lean.Syntax →\n  Bool →\n    optParam Lean.Occurrences Lean.Occurrences.all →\n      optParam Lean.Meta.Rewrite.Config { transparency := Lean.Meta.TransparencyMode.reducible, offsetCnstrs := true } →\n        Lean.Elab.Tactic.TacticM Unit",
  "name": "Mathlib.Tactic.rewriteTarget'",
  "kind": "def",
  "doc_string":
  "Variant of `rewriteTarget` that allows to use `Occurrences`.\n\nThis def should be in Core. ",
  "args": ""},
 {"type": "∀ {α : Sort u_1} (a : α), id a = a",
  "name": "id_eq",
  "kind": "theorem",
  "doc_string": "`id x = x`, as a `@[simp]` lemma. ",
  "args": ""},
 {"type": "{α : Type u_1} → Array α → List α → List α",
  "name": "Array.toListAppend",
  "kind": "def",
  "doc_string": "Like `as.toList ++ l`, but in a single pass. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "precMin1",
  "kind": "def",
  "doc_string": "`(min+1)` (we can only write `min+1` after `Meta.lean`) ",
  "args": ""},
 {"type": "{m : Type → Type u_1} → [inst : Pure m] → String → m PUnit",
  "name": "SlimCheck.Testable.slimTrace",
  "kind": "def",
  "doc_string": "A `dbgTrace` with special formatting ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), 0 ∈ S",
  "name": "AddSubmonoid.zero_mem",
  "kind": "theorem",
  "doc_string": "An `AddSubmonoid` contains the monoid's 0.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Add M] → [inst_1 : Add N] → (f : AddHom M N) → (∀ (x y : M), AddCommute (↑f x) (↑f y)) → AddHom Mᵃᵒᵖ N",
  "name": "AddHom.fromOpposite",
  "kind": "def",
  "doc_string":
  "An additive semigroup homomorphism `f : AddHom M N` such that `f x` additively\ncommutes with `f y` for all `x`, `y` defines an additive semigroup homomorphism from `Mᵃᵒᵖ`.",
  "args": ""},
 {"type":
  "∀ {R : Type u_2} {S : Type u_1} {M : Type u_3} {a : R} {s : S} [inst : Monoid S] [inst_1 : SMul R M] [inst_2 : SMul R S]\n  [inst_3 : MulAction S M] [inst_4 : IsScalarTower R S M], a • s = 1 → IsSMulRegular M s",
  "name": "IsSMulRegular.of_smul_eq_one",
  "kind": "theorem",
  "doc_string":
  "An element of `S` admitting a left inverse in `R` is `M`-regular. ",
  "args": ""},
 {"type": "∀ {p q : Prop}, (p → q) → (¬p → q) → q",
  "name": "Classical.by_cases",
  "kind": "theorem",
  "doc_string": "**Alias** of `Classical.byCases`.",
  "args": ""},
 {"type": "{α : Type u} → {x : WithOne α} → x ≠ 1 → α",
  "name": "WithOne.unone",
  "kind": "def",
  "doc_string":
  "Deconstruct a `x : WithOne α` to the underlying value in `α`, given a proof that `x ≠ 1`. ",
  "args": ""},
 {"type":
  "{X : Sort u_1} →\n  [inst : DecidableEq X] → {x : X} → {Y : Sort u_2} → (f : { x' // x' ≠ x } → Y) → { g // g ∘ Subtype.val = f } ≃ Y",
  "name": "Equiv.subtypeEquivCodomain",
  "kind": "def",
  "doc_string":
  "The type of all functions `X → Y` with prescribed values for all `x' ≠ x`\nis equivalent to the codomain `Y`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {ι : Type u_2} →\n    {s : Set ι} →\n      {f : ι → Set α} → Set.PairwiseDisjoint s f → ↑(Set.unionᵢ fun i => Set.unionᵢ fun h => f i) ≃ (i : ↑s) × ↑(f ↑i)",
  "name": "Set.bunionᵢEqSigmaOfDisjoint",
  "kind": "def",
  "doc_string":
  "Equivalence between a disjoint bounded union and a dependent sum. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α) (a : α), (∀ (b : α), b ∈ s → b ≤ a) → supₛ s ≤ a",
  "name": "CompleteBooleanAlgebra.supₛ_le",
  "kind": "def",
  "doc_string": "Any upper bound is more than the set supremum. ",
  "args": ""},
 {"type": "outParam (Type u) → Type v → Type (max u v)",
  "name": "Membership",
  "kind": "inductive",
  "doc_string":
  "The typeclass behind the notation `a ∈ s : Prop` where `a : α`, `s : γ`.\nBecause `α` is an `outParam`, the \"container type\" `γ` determines the type\nof the elements of the container.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {a : R} [inst : Monoid R] (n : ℕ), IsLeftRegular a → IsLeftRegular (a ^ n)",
  "name": "IsLeftRegular.pow",
  "kind": "theorem",
  "doc_string": "Any power of a left-regular element is left-regular. ",
  "args": ""},
 {"type": "{α : Type u} → {n : ℕ} → Vector α n → Vector α (n - 1)",
  "name": "Vector.tail",
  "kind": "def",
  "doc_string":
  "The tail of a vector, with an empty vector having empty tail.  ",
  "args": ""},
 {"type":
  "(num : ℤ) → (den : ℕ) → autoParam (den ≠ 0) _auto✝ → autoParam (Nat.coprime (Int.natAbs num) den) _auto✝¹ → ℚ",
  "name": "Rat.mk'",
  "kind": "def",
  "doc_string":
  "Constructs a rational number from components.\nWe rename the constructor to `mk'` to avoid a clash with the smart constructor. ",
  "args": ""},
 {"type": "∀ {R : Type u_1} [inst : Monoid R] (a : Rˣ), IsRegular ↑a",
  "name": "Units.isRegular",
  "kind": "theorem",
  "doc_string": "If `R` is a monoid, an element in `Rˣ` is regular. ",
  "args": ""},
 {"type":
  "{α₁ : Type u_1} →\n  {α₂ : Type u_2} →\n    {β₁ : α₁ → Type u_3} → {β₂ : α₂ → Type u_4} → (f : α₁ ≃ α₂) → ((a : α₁) → β₁ a ≃ β₂ (↑f a)) → Sigma β₁ ≃ Sigma β₂",
  "name": "Equiv.sigmaCongr",
  "kind": "def",
  "doc_string":
  "Transporting a sigma type through an equivalence of the base and a family of equivalences\nof matching fibers ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α} (a : α), List.Sublist l₁ l₂ → List.Sublist l₁ (a :: l₂)",
  "name": "List.Sublist.cons",
  "kind": "def",
  "doc_string":
  "If `l₁` is a subsequence of `l₂`, then it is also a subsequence of `a :: l₂`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Mul R] {a : R}, IsRightRegular a ↔ IsSMulRegular R { unop := a }",
  "name": "isRightRegular_iff",
  "kind": "theorem",
  "doc_string":
  "Right-regular multiplication on `R` is equivalent to `Rᵐᵒᵖ`-regularity of `R` itself. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedField α] (n : ℕ) (a : α),\n  LinearOrderedField.zpow (Int.negSucc n) a = (LinearOrderedField.zpow (↑(Nat.succ n)) a)⁻¹",
  "name": "LinearOrderedField.zpow_neg'",
  "kind": "def",
  "doc_string": "`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` ",
  "args": ""},
 {"type": "(α : Type u) → [inst : Semiring α] → Prop",
  "name": "IsDomain",
  "kind": "inductive",
  "doc_string":
  "A domain is a nontrivial semiring such multiplication by a non zero element is cancellative,\non both sides. In other words, a nontrivial semiring `R` satisfying\n`∀ {a b c : R}, a ≠ 0 → a * b = a * c → b = c` and\n`∀ {a b c : R}, b ≠ 0 → a * b = c * b → a = c`.\n\nThis is implemented as a mixin for `Semiring α`.\nTo obtain an integral domain use `[CommRing α] [IsDomain α]`. ",
  "args": ""},
 {"type": "{α : Type u} → (α → α → Prop) → α → α → Prop",
  "name": "EqvGen",
  "kind": "inductive",
  "doc_string": "`EqvGen r` is the equivalence relation generated by `r`. ",
  "args": ""},
 {"type":
  "{obj : Type u} → [self : CategoryTheory.CategoryStruct obj] → {X Y Z : obj} → (X ⟶ Y) → (Y ⟶ Z) → (X ⟶ Z)",
  "name": "CategoryTheory.CategoryStruct.comp",
  "kind": "def",
  "doc_string": "Composition of morphisms in a category, written `f ≫ g`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Add M] (self : AddSubsemigroup M) {a b : M},\n  a ∈ self.carrier → b ∈ self.carrier → a + b ∈ self.carrier",
  "name": "AddSubsemigroup.add_mem'",
  "kind": "def",
  "doc_string":
  "The sum of two elements of an additive subsemigroup belongs to the subsemigroup. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddMonoid M] {a : M} {x y : AddUnits M}, AddSemiconjBy a ↑x ↑y → AddSemiconjBy a ↑(-x) ↑(-y)",
  "name": "AddSemiconjBy.addUnits_neg_right",
  "kind": "theorem",
  "doc_string":
  "If `a` semiconjugates an additive unit `x` to an additive unit `y`, then it\nsemiconjugates `-x` to `-y`.",
  "args": ""},
 {"type":
  "∀ {G : Type u_2} {H : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : OrderedAddCommGroup H] {f : G → H},\n  (∀ (x : G), f (-x) = -f x) → StrictAntiOn f (Set.Ici 0) → StrictAnti f",
  "name": "strictAnti_of_odd_strictAnti_on_nonneg",
  "kind": "theorem",
  "doc_string":
  "An odd function on a linear ordered additive commutative group is strictly antitone on the whole\ngroup provided that it is strictly antitone on `Set.Ici 0`. ",
  "args": ""},
 {"type": "Dynamic → Lean.Name",
  "name": "Dynamic.typeName",
  "kind": "opaque",
  "doc_string": "The name of the type of the value stored in the `Dynamic`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → α → Part α",
  "name": "Part.some",
  "kind": "def",
  "doc_string":
  "The `some a` value in `Part` has a `true` domain and the\nfunction returns `a`. ",
  "args": ""},
 {"type": "∀ {α : Type u} {s t : Set α}, s ⊆ t → Disjoint s (tᶜ)",
  "name": "HasSubset.Subset.disjoint_compl_right",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Set.disjoint_compl_right_iff_subset`.",
  "args": ""},
 {"type":
  "{M : Type u} → {N : Type v} → [inst : AddMonoid M] → [inst_1 : AddMonoid N] → (M →+ N) → AddUnits M →+ AddUnits N",
  "name": "AddUnits.map",
  "kind": "def",
  "doc_string":
  "The additive homomorphism on `AddUnit`s induced by an `AddMonoidHom`.",
  "args": ""},
 {"type": "{α : Sort u_1} → {s₁ : Setoid α} → α → Quotient s₁",
  "name": "Quotient.mk''",
  "kind": "def",
  "doc_string":
  "A version of `Quotient.mk` taking `{s : Setoid α}` as an implicit argument instead of an\ninstance argument. ",
  "args": ""},
 {"type": "Type → Type",
  "name": "Mathlib.Tactic.Cache",
  "kind": "def",
  "doc_string": "Once-per-file cache. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c : α}, a + b ≤ c → b ≤ c - a",
  "name": "le_sub_left_of_add_le",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `le_sub_iff_add_le'`.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : DivisionCommMonoid α] → α →* α",
  "name": "invMonoidHom",
  "kind": "def",
  "doc_string":
  "Inversion on a commutative group, considered as a monoid homomorphism. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : α → Type u_2} → {γ : (a : α) → β a → Type u_3} → ((x : α) → (y : β x) → γ x y) → (x : Sigma β) → γ x.fst x.snd",
  "name": "Sigma.uncurry",
  "kind": "def",
  "doc_string":
  "Interpret a dependent function with two arguments as a function on `Σ x : α, β x`.\n\nThis also exists as an `equiv` as `(equiv.Pi_curry γ).symm`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "attrTo_additive!_",
  "kind": "def",
  "doc_string": "The `to_additive` attribute. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r : α → α → Prop}, Reflexive r → ∀ {x y : α}, (x ≠ y → r x y) → r x y",
  "name": "Reflexive.rel_of_ne_imp",
  "kind": "theorem",
  "doc_string":
  "To show a reflexive relation `r : α → α → Prop` holds over `x y : α`,\nit suffices to show it holds when `x ≠ y`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (h : M ≃+ N), ↑h 0 = 0",
  "name": "AddEquiv.map_zero",
  "kind": "theorem",
  "doc_string":
  "An additive isomorphism of additive monoids sends `0` to `0`\n(and is hence an additive monoid isomorphism).",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Add R] {c : R}, IsAddRegular c → IsAddLeftRegular c",
  "name": "IsAddRegular.left",
  "kind": "def",
  "doc_string": "An add-regular element `c` is left-regular ",
  "args": ""},
 {"type": "{α : Sort u_1} → ¬(α → False) → α",
  "name": "Classical.byContradiction'",
  "kind": "def",
  "doc_string":
  "A version of `byContradiction` that uses types instead of propositions. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → List α → List α → List α",
  "name": "List.diff",
  "kind": "def",
  "doc_string":
  "Computes the difference of `l₁` and `l₂`, by removing each element in `l₂` from `l₁`. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} {M₀' : Type u_2} [inst : Mul M₀] [inst_1 : Zero M₀] [inst_2 : Mul M₀'] [inst_3 : Zero M₀']\n  [inst_4 : NoZeroDivisors M₀'] (f : M₀ → M₀'),\n  Function.Injective f → f 0 = 0 → (∀ (x y : M₀), f (x * y) = f x * f y) → NoZeroDivisors M₀",
  "name": "Function.Injective.noZeroDivisors",
  "kind": "theorem",
  "doc_string":
  "Pushforward a `NoZeroDivisors` instance along an injective function. ",
  "args": ""},
 {"type":
  "{M : Type uM} →\n  {N : Type uN} →\n    {P : Type uP} →\n      {x : AddZeroClass M} → {x_1 : AddZeroClass N} → {x_2 : AddCommMonoid P} → (M →+ N →+ P) →+ N →+ M →+ P",
  "name": "AddMonoidHom.flipHom",
  "kind": "def",
  "doc_string":
  "Flipping arguments of additive monoid morphisms (`AddMonoidHom.flip`)\nas an additive monoid morphism.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        (e : M ≃+ N) →\n          (S : AddSubmonoid M) → { x // x ∈ S } ≃+ { x // x ∈ AddSubmonoid.map (AddEquiv.toAddMonoidHom e) S }",
  "name": "AddEquiv.addSubmonoidMap",
  "kind": "def",
  "doc_string":
  "An `AddEquiv` `φ` between two additive monoids `M` and `N` induces an `AddEquiv`\nbetween a submonoid `S ≤ M` and the submonoid `φ(S) ≤ N`. See\n`AddMonoidHom.addSubmonoidMap` for a variant for `AddMonoidHom`s.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      [inst : Preorder α] →\n        [inst_1 : Preorder β] →\n          [inst_2 : Preorder γ] →\n            [inst_3 : MulOneClass α] →\n              [inst_4 : MulOneClass β] → [inst_5 : MulOneClass γ] → (β →*o γ) → (α →*o β) → α →*o γ",
  "name": "OrderMonoidHom.comp",
  "kind": "def",
  "doc_string": "Composition of `OrderMonoidHom`s as an `OrderMonoidHom`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : MulZeroOneClass α]\n  [inst_3 : MulZeroOneClass β] (self : α →*₀o β), Monotone ↑↑self.toMonoidWithZeroHom",
  "name": "OrderMonoidWithZeroHom.monotone'",
  "kind": "def",
  "doc_string": "An `OrderMonoidWithZeroHom` is a monotone function. ",
  "args": ""},
 {"type": "Lean.Elab.Command.CommandElab",
  "name": "elabInitializeSimpsProjections",
  "kind": "def",
  "doc_string": "Function elaborating `initialize_simps_projections`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {A : Type u_2} →\n    {B : Type u_3} →\n      [inst : Monoid M] →\n        [inst_1 : AddMonoid A] →\n          [inst_2 : DistribMulAction M A] →\n            [inst_3 : AddMonoid B] →\n              [inst_4 : SMul M B] →\n                (f : B →+ A) → Function.Injective ↑f → (∀ (c : M) (x : B), ↑f (c • x) = c • ↑f x) → DistribMulAction M B",
  "name": "Function.Injective.distribMulAction",
  "kind": "def",
  "doc_string":
  "Pullback a distributive multiplicative action along an injective additive monoid\nhomomorphism.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{β : Type u_1} → {ι : Sort u_2} → (ι → Set β) → Set β",
  "name": "Set.unionᵢ",
  "kind": "def",
  "doc_string": "Indexed union of a family of sets ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (zα : Q(Zero «$α»)) →\n      (pα : Q(PartialOrder «$α»)) → {e : Q(«$α»)} → Mathlib.Meta.Positivity.Strictness zα pα e → String",
  "name": "Mathlib.Meta.Positivity.Strictness.toString",
  "kind": "def",
  "doc_string": "Gives a generic description of the `positivity` result. ",
  "args": ""},
 {"type": "{α : Type u} → List (List α) → List α",
  "name": "List.join",
  "kind": "def",
  "doc_string":
  "`O(|join L|)`. `join L` concatenates all the lists in `L` into one list.\n* `join [[a], [], [b, c], [d, e, f]] = [a, b, c, d, e, f]`\n",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.dist",
  "kind": "def",
  "doc_string":
  "Distance (absolute value of difference) between natural numbers. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α) {b : α}, 0 ≤ b → a - b ≤ a",
  "name": "sub_le_self",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `sub_le_self_iff`.",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R →+ S),\n  (∀ (x y : R), ↑f (x * y) = ↑f x * ↑f y) ↔\n    AddMonoidHom.compr₂ AddMonoidHom.mul f = AddMonoidHom.compl₂ (AddMonoidHom.comp AddMonoidHom.mul f) f",
  "name": "AddMonoidHom.map_mul_iff",
  "kind": "theorem",
  "doc_string":
  "An `AddMonoidHom` preserves multiplication if pre- and post- composition with\n`AddMonoidHom.mul` are equivalent. By converting the statement into an equality of\n`AddMonoidHom`s, this lemma allows various specialized `ext` lemmas about `→+` to then be applied.\n",
  "args": ""},
 {"type": "{α : Type u_1} → {P : α → Prop} → (∃ x, P x) → { x // P x }",
  "name": "Classical.subtype_of_exists",
  "kind": "def",
  "doc_string":
  "A version of `Classical.indefiniteDescription` which is definitionally equal to a pair ",
  "args": ""},
 {"type": "ℕ ⊕ ℕ ≃ ℕ",
  "name": "Equiv.natSumNatEquivNat",
  "kind": "def",
  "doc_string":
  "An equivalence between `ℕ ⊕ ℕ` and `ℕ`, by mapping `(Sum.inl x)` to `2 * x` and `(Sum.inr x)` to\n`2 * x + 1`.\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (f : M →ₙ* N) (s : Set M),\n  Subsemigroup.map f (Subsemigroup.closure s) = Subsemigroup.closure (↑f '' s)",
  "name": "MulHom.map_mclosure",
  "kind": "theorem",
  "doc_string":
  "The image under a semigroup hom of the subsemigroup generated by a set equals the subsemigroup\ngenerated by the image of the set. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Sat.Clause → Lean.Expr",
  "name": "Mathlib.Tactic.Sat.Clause.proof",
  "kind": "def",
  "doc_string":
  "A proof of `⊢ ctx.proof c`.\nNote that we do not use `have` statements to cache these proofs:\nthis is literally the proof expression itself. As a result, the proof terms\nrely heavily on dag-like sharing of the expression, and printing these proof terms\ndirectly is likely to crash lean for larger examples. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → Array α → Array α",
  "name": "List.toArrayAux",
  "kind": "def",
  "doc_string": "Auxiliary definition for `List.toArray`. ",
  "args": ""},
 {"type": "(G : Type u_1) → [inst : InvolutiveInv G] → Equiv.Perm G",
  "name": "Equiv.inv",
  "kind": "def",
  "doc_string":
  "Inversion on a `Group` or `GroupWithZero` is a permutation of the underlying type. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : ConditionallyCompleteLattice α] (s : Set α) (a : α),\n  Set.Nonempty s → a ∈ lowerBounds s → a ≤ infₛ s",
  "name": "ConditionallyCompleteLattice.le_cinfₛ",
  "kind": "def",
  "doc_string": "`a ≤ infₛ s` for all `a ∈ lowerBounds s`. ",
  "args": ""},
 {"type":
  "{I : Type u} → (f : I → Type v) → [inst : (i : I) → AddZeroClass (f i)] → (i : I) → ((i : I) → f i) →+ f i",
  "name": "Pi.evalAddMonoidHom",
  "kind": "def",
  "doc_string":
  "Evaluation of functions into an indexed collection of additive monoids at a point is an\nadditive monoid homomorphism. This is `Function.eval i` as an `AddMonoidHom`.",
  "args": ""},
 {"type": "{α : Type u} → [inst : Monoid α] → ConjClasses α → Set α",
  "name": "ConjClasses.carrier",
  "kind": "def",
  "doc_string":
  "Given a conjugacy class `a`, `carrier a` is the set it represents. ",
  "args": ""},
 {"type": "Type",
  "name": "Aesop.RuleTac",
  "kind": "def",
  "doc_string":
  "A `RuleTac` is the tactic that is run when a rule is applied to a goal.\n",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹",
  "name": "eq_on_inv",
  "kind": "theorem",
  "doc_string":
  "If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. ",
  "args": ""},
 {"type": "{α : Type u} → (Stream' α → Stream' α → Prop) → Prop",
  "name": "Stream'.IsBisimulation",
  "kind": "def",
  "doc_string":
  "Streams `s₁` and `s₂` are defined to be bisimulations if\ntheir heads are equal and tails are bisimulations. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → Option β → γ) → List α → List β → List γ",
  "name": "List.zipWithLeft",
  "kind": "def",
  "doc_string":
  "Left-biased version of `List.zipWith`. `zipWithLeft f as bs` applies `f` to each pair\n`aᵢ ∈ as` and `bᵢ ‌∈ bs`. If `bs` is shorter than `as`, `f` is applied to `none`\nfor the remaining `aᵢ`.\n```\nzipWithLeft prod.mk [1, 2] ['a'] = [(1, some 'a'), (2, none)]\nzipWithLeft prod.mk [1] ['a', 'b'] = [(1, some 'a')]\nzipWithLeft f as bs = (zipWithLeft' f as bs).fst\n```\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisInsertion l u → ∀ (x : β), x ≤ l (u x)",
  "name": "GaloisInsertion.le_l_u",
  "kind": "def",
  "doc_string": "Main property of a Galois insertion. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {x : NonAssocSemiring α} → {x_1 : NonAssocSemiring β} → (f : α →+* β) → (f' : α → β) → f' = ↑f → α →+* β",
  "name": "RingHom.copy",
  "kind": "def",
  "doc_string":
  "Copy of a `RingHom` with a new `toFun` equal to the old one. Useful to fix definitional\nequalities. ",
  "args": ""},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [self : MonadState σ m] → σ → m PUnit",
  "name": "MonadState.set",
  "kind": "def",
  "doc_string": "`set (s : σ)` replaces the state with value `s`. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Polyrith.SageResult",
  "kind": "def",
  "doc_string": "The result of a sage call. ",
  "args": ""},
 {"type": "Num → Num → Num",
  "name": "Num.div",
  "kind": "def",
  "doc_string": "Division of `Num`s, where `x / 0 = 0`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {p q : Prop} {s : p → q → α}, (⨅ h₁, ⨅ h₂, s h₁ h₂) = ⨅ h, s (_ : p) (_ : q)",
  "name": "infᵢ_and'",
  "kind": "theorem",
  "doc_string":
  "The symmetric case of `infᵢ_and`, useful for rewriting into a infimum over a conjunction ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → [self : CoeHTCT α β] → α → β",
  "name": "CoeHTCT.coe",
  "kind": "def",
  "doc_string":
  "Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : DivisionSemiring α] (n : ℕ) (a : α),\n  DivisionSemiring.zpow (Int.negSucc n) a = (DivisionSemiring.zpow (↑(Nat.succ n)) a)⁻¹",
  "name": "DivisionSemiring.zpow_neg'",
  "kind": "def",
  "doc_string": "`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedCommMonoid α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b",
  "name": "LinearOrderedCommMonoid.mul_le_mul_left",
  "kind": "def",
  "doc_string": "Multiplication is monotone in an `OrderedCommMonoid`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : PredOrder α] [inst_2 : Preorder β] {f : α → β},\n  Monotone f → Pairwise (Disjoint on fun n => Set.Ico (f (Order.pred n)) (f n))",
  "name": "Monotone.pairwise_disjoint_on_Ico_pred",
  "kind": "theorem",
  "doc_string":
  "If `α` is a linear pred order, `β` is a preorder, and `f : α → β` is a monotone function, then\nthe intervals `Set.Ico (f Order.pred n) (f n)` are pairwise disjoint. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (e a : Q(«$α»)) →\n      (b nb : Q(ℕ)) →\n        Q(Mathlib.Meta.NormNum.IsNat «$b» «$nb») →\n          Q(Semiring «$α») → Mathlib.Meta.NormNum.Result a → Option (Mathlib.Meta.NormNum.Result e)",
  "name": "Mathlib.Meta.NormNum.evalPow.core",
  "kind": "def",
  "doc_string": "Main part of `evalPow`. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (g : G) (n : ℤ), ↑f (g ^ n) = ↑f g ^ n",
  "name": "map_zpow",
  "kind": "theorem",
  "doc_string": "Group homomorphisms preserve integer power. ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : Zero R] → R → Prop",
  "name": "NeZero",
  "kind": "inductive",
  "doc_string": "A type-class version of `n ≠ 0`.  ",
  "args": ""},
 {"type":
  "optParam Bool false → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)",
  "name": "Mathlib.Meta.NormNum.tryNormNum?",
  "kind": "def",
  "doc_string": "A simp plugin which calls `NormNum.eval`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {s : Set α} →\n      {t : Set β} →\n        [inst : DecidablePred fun x => x ∈ s] →\n          [inst : DecidablePred fun x => x ∈ t] →\n            (e₀ : ↑s ≃ ↑t) → { e // ∀ (x : ↑s), ↑e ↑x = ↑(↑e₀ x) } ≃ (↑(sᶜ) ≃ ↑(tᶜ))",
  "name": "Equiv.Set.compl",
  "kind": "def",
  "doc_string":
  "Given an equivalence `e₀` between sets `s : Set α` and `t : Set β`, the set of equivalences\n`e : α ≃ β` such that `e ↑x = ↑(e₀ x)` for each `x : s` is equivalent to the set of equivalences\nbetween `sᶜ` and `tᶜ`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [self : NegPart α] → α → α",
  "name": "NegPart.neg",
  "kind": "def",
  "doc_string": "The negative part function. ",
  "args": ""},
 {"type":
  "{C : ℤ → Sort u_1} → (b : ℤ) → C b → ((k : ℤ) → b ≤ k → C k → C (k + 1)) → (n : ℕ) → C (b + ↑n)",
  "name": "Int.inductionOn'.pos",
  "kind": "def",
  "doc_string": "The positive case of `Int.inductionOn'`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [self : PosPart α] → α → α",
  "name": "PosPart.pos",
  "kind": "def",
  "doc_string": "The positive part function. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Rat.termℚ",
  "kind": "def",
  "doc_string":
  "Rational numbers, implemented as a pair of integers `num / den` such that the\ndenominator is positive and the numerator and denominator are coprime.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : OrderedSemiring α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "name": "OrderedSemiring.add_le_add_left",
  "kind": "def",
  "doc_string": "Addition is monotone in an `OrderedAddCommMonoid`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : CancelCommMonoidWithZero α] → [inst_1 : NormalizationMonoid α] → Associates α → α",
  "name": "Associates.out",
  "kind": "def",
  "doc_string":
  "Maps an element of `associates` back to the normalized element of its associate class ",
  "args": ""},
 {"type":
  "∀ {γ : Type w} [inst : LinearOrder γ] {a b : γ} {s t : Set γ}, IsLeast s a → IsLeast t b → IsLeast (s ∪ t) (min a b)",
  "name": "IsLeast.union",
  "kind": "theorem",
  "doc_string":
  "If `a` is the least element of `s` and `b` is the least element of `t`,\nthen `min a b` is the least element of `s ∪ t`. ",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {P : Type u_2} [inst : VAdd G P] [self : FaithfulVAdd G P] {g₁ g₂ : G},\n  (∀ (p : P), g₁ +ᵥ p = g₂ +ᵥ p) → g₁ = g₂",
  "name": "FaithfulVAdd.eq_of_vadd_eq_vadd",
  "kind": "def",
  "doc_string":
  "Two elements `g₁` and `g₂` are equal whenever they act in the same way on all points. ",
  "args": ""},
 {"type": "Sort u",
  "name": "PEmpty",
  "kind": "inductive",
  "doc_string":
  "The universe-polymorphic empty type. Prefer `Empty` or `False` where\npossible.\n",
  "args": ""},
 {"type":
  "{α : Type u} → {m : Type u → Type v} → [inst : Monad m] → [inst : Alternative m] → (α → m PUnit) → List α → m α",
  "name": "List.findM",
  "kind": "def",
  "doc_string":
  "`findM tac l` returns the first element of `l` on which `tac` succeeds, and\nfails otherwise. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} →\n        [inst : PartialOrder α] → [inst_1 : Preorder β] → [inst_2 : OrderBot β] → GaloisCoinsertion l u → OrderBot α",
  "name": "GaloisCoinsertion.liftOrderBot",
  "kind": "def",
  "doc_string": "Lift the bot along a Galois coinsertion ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → (φ : α → β → Sort u_3) → ((a : α) → (b : β) → φ a b) ≃ ((b : β) → (a : α) → φ a b)",
  "name": "Equiv.piComm",
  "kind": "def",
  "doc_string":
  "Given `φ : α → β → Sort*`, we have an equivalence between `∀ a b, φ a b` and `∀ b a, φ a b`.\nThis is `Function.swap` as an `Equiv`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → β → γ) → Set α → Set β → Set γ",
  "name": "Set.image2",
  "kind": "def",
  "doc_string":
  "The image of a binary function `f : α → β → γ` as a function `Set α → Set β → Set γ`.\nMathematically this should be thought of as the image of the corresponding function `α × β → γ`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : NonAssocRing α] (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)",
  "name": "NonAssocRing.intCast_negSucc",
  "kind": "def",
  "doc_string":
  "The canonical homorphism `ℤ → R` for negative values is just the negation of the values\nof the canonical homomorphism `ℕ → R`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → (f : α → β) → (s : β → β → Prop) → [H : DecidableRel s] → DecidableRel (f ⁻¹'o s)",
  "name": "Order.Preimage.decidable",
  "kind": "def",
  "doc_string": "The preimage of a decidable order is decidable. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    (f : α ↪ β) →\n      (a : α) → (b : β) → [inst : (a' : α) → Decidable (a' = a)] → [inst : (a' : α) → Decidable (↑f a' = b)] → α ↪ β",
  "name": "Function.Embedding.setValue",
  "kind": "def",
  "doc_string":
  "Change the value of an embedding `f` at one point. If the prescribed image\nis already occupied by some `f a'`, then swap the values at these two points. ",
  "args": ""},
 {"type": "∀ {α : Type u} (s : Set α), Subsingleton ↑s ↔ Set.Subsingleton s",
  "name": "Set.subsingleton_coe",
  "kind": "theorem",
  "doc_string":
  "`s`, coerced to a type, is a subsingleton type if and only if `s` is a subsingleton set. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → (γ : Type u_3) → α × (β ⊕ γ) ≃ α × β ⊕ α × γ",
  "name": "Equiv.prodSumDistrib",
  "kind": "def",
  "doc_string":
  "Type product is left distributive with respect to type sum up to an equivalence. ",
  "args": ""},
 {"type":
  "{α β γ : Type u} → {F : Type u → Type v} → [inst : Applicative F] → (α → β → F γ) → List α → List β → F PUnit",
  "name": "zipWithM'",
  "kind": "def",
  "doc_string":
  "Like `zipWithM` but evaluates the result as it traverses the lists using `*>`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → ℕ",
  "name": "List.redLength",
  "kind": "def",
  "doc_string":
  "A non-tail-recursive version of `List.length`, used for `List.toArray`. ",
  "args": ""},
 {"type": "(Bool → Bool → Bool) → ℕ → ℕ → ℤ",
  "name": "Int.natBitwise",
  "kind": "def",
  "doc_string":
  "`Int.natBitwise` is an auxiliary definition for `Int.bitwise`. ",
  "args": ""},
 {"type": "Type u → Type",
  "name": "TypeName",
  "kind": "inductive",
  "doc_string":
  "Dynamic type name information.\nTypes with an instance of `TypeName` can be stored in an `Dynamic`.\nThe type class contains the declaration name of the type,\nwhich must not have any universe parameters\nand be of type `Sort ..` (i.e., monomorphic).\n\nThe preferred way to declare instances of this type is using the derive\nhandler, which will internally use the unsafe `TypeName.mk` function.\n\nMorally, this is the same as:\n```lean\nclass TypeName (α : Type) where unsafe mk ::\n  typeName : Name\n```\n",
  "args": ""},
 {"type":
  "{m : Type u₁ → Type u₂} →\n  {ρ : Type u} →\n    {α : Type v} → [self : ForIn m ρ α] → {β : Type u₁} → [inst : Monad m] → ρ → β → (α → β → m (ForInStep β)) → m β",
  "name": "ForIn.forIn",
  "kind": "def",
  "doc_string":
  "`forIn x b f : m β` runs a for-loop in the monad `m` with additional state `β`.\nThis traverses over the \"contents\" of `x`, and passes the elements `a : α` to\n`f : α → β → m (ForInStep β)`. `b : β` is the initial state, and the return value\nof `f` is the new state as well as a directive `.done` or `.yield`\nwhich indicates whether to abort early or continue iteration.\n\nThe expression\n```\nlet mut b := ...\nfor x in xs do\n  b ← foo x b\n```\nin a `do` block is syntactic sugar for:\n```\nlet b := ...\nlet b ← forIn xs b (fun x b => do\n  let b ← foo x b\n  return .yield b)\n```\n(Here `b` corresponds to the variables mutated in the loop.) ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} → [inst : PartialOrder α] → [inst_1 : SemilatticeSup β] → GaloisCoinsertion l u → SemilatticeSup α",
  "name": "GaloisCoinsertion.liftSemilatticeSup",
  "kind": "def",
  "doc_string": "Lift the suprema along a Galois coinsertion ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α ↪ β) → Option α ↪ Option β",
  "name": "Function.Embedding.optionMap",
  "kind": "def",
  "doc_string": "A version of `Option.map` for `Function.Embedding`s. ",
  "args": ""},
 {"type":
  "{p : ℕ+ → Sort u_1} → (a : ℕ+) → p 1 → ((n : ℕ+) → ((m : ℕ+) → m ≤ n → p m) → p (n + 1)) → p a",
  "name": "PNat.caseStrongInductionOn",
  "kind": "def",
  "doc_string": "Strong induction on `ℕ+`, with `n = 1` treated separately. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} → [inst : CategoryTheory.Category D] → (C → D) → Type (max v₁ v₂ u₁ u₂)",
  "name": "CategoryTheory.Functorial",
  "kind": "inductive",
  "doc_string": "A unbundled functor. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u₃} →\n          [inst_2 : CategoryTheory.Category E] →\n            {F : C ⥤ D} →\n              {G : D ⥤ E} →\n                {H : C ⥤ E} →\n                  [inst_3 : CategoryTheory.Full H] →\n                    [inst_4 : CategoryTheory.Faithful G] → (F ⋙ G ≅ H) → CategoryTheory.Full F",
  "name": "CategoryTheory.Full.ofCompFaithfulIso",
  "kind": "def",
  "doc_string": "If `F ⋙ G` is full and `G` is faithful, then `F` is full. ",
  "args": ""},
 {"type":
  "{c : Type u → Type v} → (α : Type u) → [str : c α] → CategoryTheory.Bundled c",
  "name": "CategoryTheory.Bundled.of",
  "kind": "def",
  "doc_string":
  "A generic function for lifting a type equipped with an instance to a bundled object. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {β : ι → Type u_2} → (ι → ι → Prop) → ({i : ι} → β i → β i → Prop) → ((i : ι) → β i) → ((i : ι) → β i) → Prop",
  "name": "Pi.Lex",
  "kind": "def",
  "doc_string":
  "The lexicographic relation on `Π i : ι, β i`, where `ι` is ordered by `r`,\nand each `β i` is ordered by `s`. ",
  "args": ""},
 {"type": "Linarith.PComp → Linarith.Comp",
  "name": "Linarith.PComp.c",
  "kind": "def",
  "doc_string": "The comparison `Σ cᵢ*xᵢ R 0`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : Order.Coframe α] (a : α) (s : Set α), (⨅ b, ⨅ h, a ⊔ b) ≤ a ⊔ infₛ s",
  "name": "Order.Coframe.infᵢ_sup_le_sup_infₛ",
  "kind": "def",
  "doc_string": "In a coframe, `⊔` distributes over `⨅`. ",
  "args": ""},
 {"type":
  "Lean.Meta.Simp.Context → optParam Bool true → Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "name": "Mathlib.Meta.NormNum.deriveSimp",
  "kind": "opaque",
  "doc_string":
  "Traverses the given expression using simp and normalises any numbers it finds. ",
  "args": ""},
 {"type": "∀ {α : Type u} {s : Set α}, Nontrivial ↑s ↔ Set.Nontrivial s",
  "name": "Set.nontrivial_coe_sort",
  "kind": "theorem",
  "doc_string":
  "`s`, coerced to a type, is a nontrivial type if and only if `s` is a nontrivial set. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "name": "List.Sublist",
  "kind": "inductive",
  "doc_string":
  "`l₁ <+ l₂`, or `Sublist l₁ l₂`, says that `l₁` is a (non-contiguous) subsequence of `l₂`. ",
  "args": ""},
 {"type": "Prop → Type",
  "name": "SlimCheck.PrintableProp",
  "kind": "inductive",
  "doc_string":
  "`PrintableProp p` allows one to print a proposition so that\n`SlimCheck` can indicate how values relate to each other.\nIt's basically a poor man's delaborator.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b c : α} [inst : LinearOrder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α]\n  [inst_3 : OrderedSub α], a < b - c ↔ a + c < b",
  "name": "lt_tsub_iff_right",
  "kind": "theorem",
  "doc_string":
  "See `lt_tsub_iff_right_of_le` for a weaker statement in a partial order. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M →+ N), ↑f 0 = 0",
  "name": "AddMonoidHom.map_zero",
  "kind": "theorem",
  "doc_string": "If `f` is an additive monoid homomorphism then `f 0 = 0`. ",
  "args": ""},
 {"type":
  "{R : Type u} → [inst : One R] → [inst : Zero R] → [inst : Add R] → ℕ → R",
  "name": "Nat.unaryCast",
  "kind": "def",
  "doc_string": "The numeral `((0+1)+⋯)+1`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    Q(CommSemiring «$α») →\n      Mathlib.Tactic.Ring.Cache α → Q(«$α») → Mathlib.Tactic.Ring.RingM Mathlib.Tactic.Polyrith.Poly",
  "name": "Mathlib.Tactic.Polyrith.parse",
  "kind": "opaque",
  "doc_string": "Reifies a ring expression of type `α` as a `Poly`. ",
  "args": ""},
 {"type": "{M : Type u_1} → Set M → [inst : AddMonoid M] → AddSubmonoid M",
  "name": "AddSubmonoid.centralizer",
  "kind": "def",
  "doc_string": "The centralizer of a subset of an additive monoid.",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → β → γ) → List α → List β → List γ",
  "name": "List.map₂",
  "kind": "def",
  "doc_string":
  "Mapping a pair of lists under a curried function of two variables. ",
  "args": ""},
 {"type": "∀ {α : Type u} {s : Set α}, Set.Nonempty s → ∅ ⊂ s",
  "name": "Set.Nonempty.empty_ssubset",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `Set.empty_ssubset`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddAction α β] [inst_2 : FaithfulVAdd α β],\n  Function.Injective AddAction.toPerm",
  "name": "AddAction.toPerm_injective",
  "kind": "theorem",
  "doc_string": "`AddAction.toPerm` is injective on faithful actions.",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Abel.NormalExpr",
  "kind": "inductive",
  "doc_string":
  "A normal form for `abel`.\nExpressions are represented as a list of terms of the form `e = n • x`,\nwhere `n : ℤ` and `x` is an arbitrary element of the additive commutative monoid or group.\nWe explicitly track the `Expr` forms of `e` and `n`, even though they could be reconstructed,\nfor efficiency. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → ℕ → Option α",
  "name": "List.nth",
  "kind": "def",
  "doc_string": "Optionally return nth element of a list. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "OrderedCommGroup",
  "kind": "inductive",
  "doc_string":
  "An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone. ",
  "args": ""},
 {"type": "(R : Type u) → [inst : Semiring R] → Prop",
  "name": "IsField",
  "kind": "inductive",
  "doc_string":
  "A predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionaly, this is useful when trying to prove that\na particular ring structure extends to a (semi)field. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : IsLowerModularLattice α] {a b : α}, a ⋖ a ⊔ b → a ⊓ b ⋖ b",
  "name": "Covby.inf_of_sup_left",
  "kind": "theorem",
  "doc_string": "**Alias** of `inf_covby_of_covby_sup_left`.",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → M →+ M × N",
  "name": "AddMonoidHom.inl",
  "kind": "def",
  "doc_string":
  "Given additive monoids `A`, `B`, the natural inclusion homomorphism\nfrom `A` to `A × B`.",
  "args": ""},
 {"type":
  "∀ {f : Sat.Fmla} {c : Sat.Clause}, Sat.Fmla.subsumes f (Sat.Fmla.one c) → Sat.Fmla.proof f c",
  "name": "Sat.Fmla.proof_of_subsumes",
  "kind": "theorem",
  "doc_string": "If `f` subsumes `c` (i.e. `c ∈ f`), then `f.proof c`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Ring α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Neg β] →\n                [inst_6 : Sub β] →\n                  [inst_7 : SMul ℕ β] →\n                    [inst_8 : SMul ℤ β] →\n                      [inst_9 : Pow β ℕ] →\n                        [inst_10 : NatCast β] →\n                          [inst_11 : IntCast β] →\n                            (f : β → α) →\n                              Function.Injective f →\n                                f 0 = 0 →\n                                  f 1 = 1 →\n                                    (∀ (x y : β), f (x + y) = f x + f y) →\n                                      (∀ (x y : β), f (x * y) = f x * f y) →\n                                        (∀ (x : β), f (-x) = -f x) →\n                                          (∀ (x y : β), f (x - y) = f x - f y) →\n                                            (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                              (∀ (x : β) (n : ℤ), f (n • x) = n • f x) →\n                                                (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                  (∀ (n : ℕ), f ↑n = ↑n) → (∀ (n : ℤ), f ↑n = ↑n) → Ring β",
  "name": "Function.Injective.ring",
  "kind": "def",
  "doc_string":
  "Pullback a `Ring` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : α → Sort v} →\n    (s : Set α) → ((i : α) → β i) → ((i : α) → β i) → [inst : (j : α) → Decidable (j ∈ s)] → (i : α) → β i",
  "name": "Set.piecewise",
  "kind": "def",
  "doc_string":
  "`s.piecewise f g` is the function equal to `f` on the set `s`, and to `g` on its complement. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List (List α)",
  "name": "List.tailsTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `tails`. ",
  "args": ""},
 {"type":
  "(C : Type u₁) →\n  [inst : CategoryTheory.Category C] →\n    (D : Type u₂) →\n      [inst_1 : CategoryTheory.Category D] →\n        (E : Type u₃) → [inst_2 : CategoryTheory.Category E] → (D ⥤ E) ⥤ (C ⥤ D) ⥤ C ⥤ E",
  "name": "CategoryTheory.whiskeringRight",
  "kind": "def",
  "doc_string":
  "Right-composition gives a functor `(D ⥤ E) ⥤ ((C ⥤ D) ⥤ (C ⥤ E))`.\n\n`(whiskeringRight.obj H).obj F` is `F ⋙ H`, and\n`(whiskeringRight.obj H).map α` is `whiskerRight α H`.\n",
  "args": ""},
 {"type": "{C : Type u₁} → (C → Prop) → Type u₁",
  "name": "CategoryTheory.FullSubcategory",
  "kind": "inductive",
  "doc_string":
  "A subtype-like structure for full subcategories. Morphisms just ignore the property. We don't use\nactual subtypes since the simp-normal form `↑X` of `X.val` does not work well for full\nsubcategories.\n\nSee <https://stacks.math.columbia.edu/tag/001D>. We do not define 'strictly full' subcategories.\n",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : One M] → [inst : One N] → Type (max u_1 u_2)",
  "name": "OneHom",
  "kind": "inductive",
  "doc_string":
  "`OneHom M N` is the type of functions `M → N` that preserve one.\n\nWhen possible, instead of parametrizing results over `(f : OneHom M N)`,\nyou should parametrize over `(F : Type*) [OneHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `OneHomClass`.\n",
  "args": ""},
 {"type":
  "{α₁ : Type u_1} → {α₂ : Type u_2} → {β₁ : Type u_3} → {β₂ : Type u_4} → α₁ ≃ α₂ → β₁ ≃ β₂ → α₁ ⊕ β₁ ≃ α₂ ⊕ β₂",
  "name": "Equiv.sumCongr",
  "kind": "def",
  "doc_string":
  "If `α ≃ α'` and `β ≃ β'`, then `α ⊕ β ≃ α' ⊕ β'`. This is `Sum.map` as an equivalence. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → (α → β) → Stream' α → Stream' β",
  "name": "Stream'.map",
  "kind": "def",
  "doc_string": "Apply a function `f` to all elements of a stream `s`. ",
  "args": ""},
 {"type": "{V : Type u} → [inst : Quiver V] → Quiver.Total V → V",
  "name": "Quiver.Total.left",
  "kind": "def",
  "doc_string": "the source vertex of an arrow ",
  "args": ""},
 {"type":
  "(S : Type u_1) → (M : outParam (Type u_2)) → [inst : One M] → [inst : SetLike S M] → Prop",
  "name": "OneMemClass",
  "kind": "inductive",
  "doc_string":
  "`OneMemClass S M` says `S` is a type of subsets `s ≤ M`, such that `1 ∈ s` for all `s`. ",
  "args": ""},
 {"type":
  "∀ {v : Sat.Valuation} {f₁ : Sat.Fmla} {a : Prop} {f₂ : Sat.Fmla} {b : Prop},\n  Sat.Fmla.reify v f₁ a → Sat.Fmla.reify v f₂ b → Sat.Fmla.reify v (Sat.Fmla.and f₁ f₂) (a ∨ b)",
  "name": "Sat.Fmla.reify_or",
  "kind": "theorem",
  "doc_string":
  "Negation turns AND into OR, so `¬⟦f₁ ∧ f₂⟧_v ≡ ¬⟦f₁⟧_v ∨ ¬⟦f₂⟧_v`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), S = ⊥ ∨ Nontrivial { x // x ∈ S }",
  "name": "AddSubmonoid.bot_or_nontrivial",
  "kind": "theorem",
  "doc_string":
  "An additive submonoid is either the trivial additive submonoid or nontrivial.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Semigroup α] →\n    [inst_1 : PartialOrder α] →\n      [inst : ContravariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] → LeftCancelSemigroup α",
  "name": "Contravariant.toLeftCancelSemigroup",
  "kind": "def",
  "doc_string":
  "A semigroup with a partial order and satisfying `LeftCancelSemigroup`\n(i.e. `a * c < b * c → a < b`) is a `left_cancel Semigroup`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → [inst : Unique α] → (α ↪ β) ≃ β",
  "name": "Equiv.uniqueEmbeddingEquivResult",
  "kind": "def",
  "doc_string":
  "Embeddings from a single-member type are equivalent to members of the target type. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → Prop) → Set α → Prop",
  "name": "ChainClosure",
  "kind": "inductive",
  "doc_string":
  "Predicate for whether a set is reachable from `∅` using `SuccChain` and `⋃₀`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {s₁ : Setoid α} →\n      {s₂ : Setoid β} →\n        {φ : Quotient s₁ → Quotient s₂ → Sort u_3} →\n          (qa : Quotient s₁) →\n            (qb : Quotient s₂) →\n              (f : (a : α) → (b : β) → φ (Quotient.mk'' a) (Quotient.mk'' b)) →\n                (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → HEq (f a₁ b₁) (f a₂ b₂)) → φ qa qb",
  "name": "Quotient.hrecOn₂'",
  "kind": "def",
  "doc_string":
  "Recursion on two `Quotient` arguments `a` and `b`, result type depends on `⟦a⟧` and `⟦b⟧`. ",
  "args": ""},
 {"type": "∀ {M : Type u} [self : AddZeroClass M] (a : M), a + 0 = a",
  "name": "AddZeroClass.add_zero",
  "kind": "def",
  "doc_string": "Zero is a right neutral element for addition ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_>=_»",
  "kind": "def",
  "doc_string": "`a ≥ b` is an abbreviation for `b ≤ a`. ",
  "args": ""},
 {"type": "AbsoluteValue.IsEuclidean AbsoluteValue.abs",
  "name": "AbsoluteValue.abs_isEuclidean",
  "kind": "theorem",
  "doc_string": "`abs : ℤ → ℤ` is a Euclidean absolute value ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Monoid α] (m : α), IsSquare m → ∃ c, m = c ^ 2",
  "name": "IsSquare.exists_sq",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `isSquare_iff_exists_sq`.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Preorder α] → α → Set α",
  "name": "Set.Iio",
  "kind": "def",
  "doc_string": "Left-infinite right-open interval ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      [inst : Preorder α] →\n        [inst_1 : Preorder β] →\n          [inst_2 : Preorder γ] →\n            [inst_3 : AddZeroClass α] →\n              [inst_4 : AddZeroClass β] → [inst_5 : AddZeroClass γ] → (β →+o γ) → (α →+o β) → α →+o γ",
  "name": "OrderAddMonoidHom.comp",
  "kind": "def",
  "doc_string": "Composition of `OrderAddMonoidHom`s as an `OrderAddMonoidHom`",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {s₁ : Setoid α} {s₂ : Setoid β} {p : Quotient s₁ → Quotient s₂ → Prop},\n  (∀ (a₁ : α) (a₂ : β), p (Quotient.mk'' a₁) (Quotient.mk'' a₂)) → ∀ (q₁ : Quotient s₁) (q₂ : Quotient s₂), p q₁ q₂",
  "name": "Quotient.ind₂'",
  "kind": "theorem",
  "doc_string":
  "A version of `Quotient.ind₂` taking `{s₁ : Setoid α} {s₂ : Setoid β}` as implicit arguments\ninstead of instance arguments. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : CancelCommMonoidWithZero α] →\n    [inst_1 : NormalizationMonoid α] →\n      [inst_2 : DecidableEq α] →\n        (gcd : α → α → α) →\n          (∀ (a b : α), gcd a b ∣ a) →\n            (∀ (a b : α), gcd a b ∣ b) →\n              (∀ {a b c : α}, a ∣ c → a ∣ b → a ∣ gcd c b) →\n                (∀ (a b : α), ↑normalize (gcd a b) = gcd a b) → NormalizedGCDMonoid α",
  "name": "normalizedGCDMonoidOfGCD",
  "kind": "def",
  "doc_string":
  "Define `NormalizedGCDMonoid` on a structure just from the `gcd` and its properties. ",
  "args": ""},
 {"type": "{α : Type u_1} → [self : Fix α] → (α → α) → α",
  "name": "Fix.fix",
  "kind": "def",
  "doc_string": "`fix f` represents the computation of a fixed point for `f`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {s t : Set α}, Set.Nonempty (s ∩ t) → ¬Disjoint s t",
  "name": "Set.Nonempty.not_disjoint",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `Set.not_disjoint_iff_nonempty_inter`.",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : Preorder α] → [inst_1 : OrderBot α] → GaloisInsertion (WithBot.unbot' ⊥) WithBot.some",
  "name": "WithBot.giUnbot'Bot",
  "kind": "def",
  "doc_string":
  "If `α` is a partial order with bottom element (e.g., `ℕ`, `ℝ≥0`), then `WithBot.unbot' ⊥` and\ncoercion form a Galois insertion. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddMonoid M] (a : M) (u : AddUnits M), IsAddUnit (a + ↑u) ↔ IsAddUnit a",
  "name": "AddUnits.isAddUnit_add_addUnits",
  "kind": "theorem",
  "doc_string":
  "Addition of a `u : add_units M` on the right doesn't affect `IsAddUnit`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, a - b < 0 ↔ a < b",
  "name": "sub_lt_zero",
  "kind": "theorem",
  "doc_string": "**Alias** of `sub_neg`.",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {γ : Type w} →\n    [inst : NonUnitalCommSemiring α] →\n      [inst_1 : Zero γ] →\n        [inst_2 : Add γ] →\n          [inst_3 : Mul γ] →\n            [inst_4 : SMul ℕ γ] →\n              (f : α → γ) →\n                Function.Surjective f →\n                  f 0 = 0 →\n                    (∀ (x y : α), f (x + y) = f x + f y) →\n                      (∀ (x y : α), f (x * y) = f x * f y) →\n                        (∀ (x : α) (n : ℕ), f (n • x) = n • f x) → NonUnitalCommSemiring γ",
  "name": "Function.Surjective.nonUnitalCommSemiring",
  "kind": "def",
  "doc_string":
  "Pushforward a `NonUnitalCommSemiring` instance along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ (m : ℤ) {n : ℤ}, 0 < n → ((∃ k, n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m)",
  "name": "Int.exists_lt_and_lt_iff_not_dvd",
  "kind": "theorem",
  "doc_string":
  "If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`\nfor some `k`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Preorder α] →\n    (succ : α → α) → (∀ {a b : α}, succ a ≤ b ↔ a < b) → (∀ {a b : α}, a < succ b → a ≤ b) → SuccOrder α",
  "name": "SuccOrder.ofSuccLeIffOfLeLtSucc",
  "kind": "def",
  "doc_string":
  "A constructor for `SuccOrder α` usable when `α` has no maximal element. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1],\n  StrictAnti f → Antitone g → StrictAnti fun x => f x + g x",
  "name": "StrictAnti.add_antitone",
  "kind": "theorem",
  "doc_string":
  "The sum of a strictly antitone function and a antitone function is\nstrictly antitone.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : ConditionallyCompleteLinearOrder β] {f : α → β}\n  {s : Set α}, AntitoneOn f s → BddBelow (f '' s) → BddAbove (f '' s) → ∃ g, Antitone g ∧ Set.EqOn f g s",
  "name": "AntitoneOn.exists_antitone_extension",
  "kind": "theorem",
  "doc_string":
  "If a function is antitone and is bounded on a set `s`, then it admits an antitone extension to\nthe whole space. ",
  "args": ""},
 {"type":
  "{n : ℕ} → {α β σ φ : Type} → (α → β → σ → σ × φ) → Vector α n → Vector β n → σ → σ × Vector φ n",
  "name": "Vector.mapAccumr₂",
  "kind": "def",
  "doc_string":
  "Runs a function over a pair of vectors returning the intermediate results and a\na final result.\n",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → IsUnit a",
  "name": "Ne.isUnit",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `isUnit_iff_ne_zero`.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.clear_",
  "kind": "def",
  "doc_string":
  "Clear all hypotheses starting with `_`, like `_match` and `_let_match`. ",
  "args": ""},
 {"type": "{a : Prop} → {α : Sort u_1} → ¬a → a → α",
  "name": "Not.elim",
  "kind": "def",
  "doc_string":
  "Ex falso for negation. From `¬a` and `a` anything follows. This is the same as `absurd` with\nthe arguments flipped, but it is in the `not` namespace so that projection notation can be used. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {R : α → β → Prop} {a : α} {b : β} {l₁ : List α} {l₂ : List β},\n  R a b → List.Forall₂ R l₁ l₂ → List.Forall₂ R (a :: l₁) (b :: l₂)",
  "name": "List.Forall₂.cons",
  "kind": "def",
  "doc_string":
  "Two cons lists are related by `Forall₂ R`\nif the heads are related by `R` and the tails are related by `Forall₂ R` ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : One M₁] →\n        [inst_2 : Pow M₁ ℕ] →\n          [inst_3 : CommMonoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 1 = 1 →\n                  (∀ (x y : M₁), f (x * y) = f x * f y) → (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) → CommMonoid M₁",
  "name": "Function.Injective.commMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `1` and `*` is a commutative monoid, if it admits an injective map that\npreserves `1` and `*` to a commutative monoid.  See note [reducible non-instances]. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} {R : α → α → Prop}, List.Pairwise R []",
  "name": "List.Pairwise.nil",
  "kind": "def",
  "doc_string":
  "All elements of the empty list are vacuously pairwise related. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : NonUnitalRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : Add β] →\n          [inst_3 : Mul β] →\n            [inst_4 : Neg β] →\n              [inst_5 : Sub β] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : SMul ℤ β] →\n                    (f : α → β) →\n                      Function.Surjective f →\n                        f 0 = 0 →\n                          (∀ (x y : α), f (x + y) = f x + f y) →\n                            (∀ (x y : α), f (x * y) = f x * f y) →\n                              (∀ (x : α), f (-x) = -f x) →\n                                (∀ (x y : α), f (x - y) = f x - f y) →\n                                  (∀ (x : α) (n : ℕ), f (n • x) = n • f x) →\n                                    (∀ (x : α) (n : ℤ), f (n • x) = n • f x) → NonUnitalRing β",
  "name": "Function.Surjective.nonUnitalRing",
  "kind": "def",
  "doc_string":
  "Pushforward a `NonUnitalRing` instance along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Conv.«command#simpOnly_=>__»",
  "kind": "def",
  "doc_string":
  "* `#simp => e` runs `simp` on the expression `e` and displays the resulting expression after\n  simplification.\n* `#simp only [lems] => e` runs `simp only [lems]` on `e`.\n* The `=>` is optional, so `#simp e` and `#simp only [lems] e` have the same behavior.\n  It is mostly useful for disambiguating the expression `e` from the lemmas.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : PartialOrder α] →\n    [inst_1 : PredOrder α] →\n      {C : α → Sort u_2} →\n        (b : α) → ((a : α) → ¬IsMin a → C (Order.pred a)) → ((a : α) → Order.IsPredLimit a → C a) → C b",
  "name": "Order.isPredLimitRecOn",
  "kind": "def",
  "doc_string":
  "A value can be built by building it on predecessors and predecessor limits. ",
  "args": ""},
 {"type":
  "Bool →\n  Lean.Expr →\n    ℕ →\n      Array (Mathlib.Tactic.Polyrith.Source × Mathlib.Tactic.Polyrith.Poly) →\n        Mathlib.Tactic.Polyrith.Poly → Array String",
  "name": "Mathlib.Tactic.Polyrith.createSageArgs",
  "kind": "def",
  "doc_string":
  "Constructs the list of arguments to pass to the external sage script `polyrith_sage.py`. ",
  "args": ""},
 {"type":
  "∀ (P : ℕ → ℕ → Prop),\n  (∀ (a : ℕ), P (a + 1) (a + 1)) →\n    (∀ (b : ℕ), P 0 (b + 1)) →\n      (∀ (a b : ℕ), a < b → P (a + 1) b → P a (b + 1) → P (a + 1) (b + 1)) → ∀ (a b : ℕ), a < b → P a b",
  "name": "Nat.diag_induction",
  "kind": "theorem",
  "doc_string":
  "Given a predicate on two naturals `P : ℕ → ℕ → Prop`, `P a b` is true for all `a < b` if\n`P (a + 1) (a + 1)` is true for all `a`, `P 0 (b + 1)` is true for all `b` and for all\n`a < b`, `P (a + 1) b` is true and `P a (b + 1)` is true implies `P (a + 1) (b + 1)` is true. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] (c : ClosureOperator α),\n  GaloisConnection.closureOperator (_ : GaloisConnection (ClosureOperator.toClosed c) Subtype.val) = c",
  "name": "closureOperator_gi_self",
  "kind": "theorem",
  "doc_string":
  "The Galois insertion associated to a closure operator can be used to reconstruct the closure\noperator.\nNote that the inverse in the opposite direction does not hold in general. ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → α ≃ β → (α → α) ≃ (β → β)",
  "name": "Equiv.conj",
  "kind": "def",
  "doc_string": "Conjugate a map `f : α → α` by an equivalence `α ≃ β`. ",
  "args": ""},
 {"type": "(α : Sort u_1) → [h : Nonempty α] → α",
  "name": "Classical.arbitrary",
  "kind": "def",
  "doc_string":
  "Using `Classical.choice`, extracts a term from a `Nonempty` type. ",
  "args": ""},
 {"type": "∀ {p : ℕ}, Nat.Prime p → Prime p",
  "name": "Nat.Prime.prime",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `Nat.prime_iff`.",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.Context →\n  Lean.Expr × ℤ → Mathlib.Tactic.Abel.NormalExpr → Lean.MetaM (Mathlib.Tactic.Abel.NormalExpr × Lean.Expr)",
  "name": "Mathlib.Tactic.Abel.evalSMul",
  "kind": "def",
  "doc_string": "Auxiliary function for `evalSMul'`.\n",
  "args": ""},
 {"type": "{M : Type u} → [inst : One M] → [inst : Mul M] → ℕ → M → M",
  "name": "npowRec",
  "kind": "def",
  "doc_string":
  "The fundamental power operation in a monoid. `npowRec n a = a*a*...*a` n times.\nUse instead `a ^ n`,  which has better definitional behavior. ",
  "args": ""},
 {"type": "∀ {α : Sort u} {p : α → Prop} (w : α), p w → Exists p",
  "name": "Exists.intro",
  "kind": "def",
  "doc_string":
  "Existential introduction. If `a : α` and `h : p a`,\nthen `⟨a, h⟩` is a proof that `∃ x : α, p x`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.tacticSymm_",
  "kind": "def",
  "doc_string":
  "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] ⦃s t : Set M⦄, s ⊆ t → AddSubmonoid.closure s ≤ AddSubmonoid.closure t",
  "name": "AddSubmonoid.closure_mono",
  "kind": "theorem",
  "doc_string":
  "Additive submonoid closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "prioHigh",
  "kind": "def",
  "doc_string":
  "The standardized \"high\" priority `high = 10000`, for things that should be higher than default priority. ",
  "args": ""},
 {"type":
  "{a : Lean.Level} →\n  {arg : Q(Type a)} →\n    {sα : Q(CommSemiring «$arg»)} →\n      {a_1 : Q(«$arg»)} →\n        {a_2 : Lean.Level} →\n          {arg_1 : Q(Type a_2)} →\n            {sβ : Q(CommSemiring «$arg_1»)} →\n              Mathlib.Tactic.Ring.ExBase sα a_1 → (a : Q(«$arg_1»)) × Mathlib.Tactic.Ring.ExBase sβ a",
  "name": "Mathlib.Tactic.Ring.ExBase.cast",
  "kind": "opaque",
  "doc_string":
  "Converts `ExBase sα` to `ExBase sβ`, assuming `sα` and `sβ` are defeq. ",
  "args": ""},
 {"type":
  "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {F G : C ⥤ D}\n  (α : F ⟶ G) [inst_2 : ∀ (X : C), CategoryTheory.IsIso (CategoryTheory.NatTrans.app α X)], CategoryTheory.IsIso α",
  "name": "CategoryTheory.NatIso.isIso_of_isIso_app",
  "kind": "theorem",
  "doc_string":
  "A natural transformation is an isomorphism if all its components are isomorphisms.\n",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → List α → List β → List (α × β)",
  "name": "List.product",
  "kind": "def",
  "doc_string":
  "`product l₁ l₂` is the list of pairs `(a, b)` where `a ∈ l₁` and `b ∈ l₂`.\n```\nproduct [1, 2] [5, 6] = [(1, 5), (1, 6), (2, 5), (2, 6)]\n```\n",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  [inst : SlimCheck.SampleableExt α] →\n    {β : α → Prop} →\n      [inst_1 : (x : α) → SlimCheck.Testable (β x)] →\n        SlimCheck.Configuration →\n          String →\n            SlimCheck.SampleableExt.proxy α →\n              ℕ →\n                OptionT SlimCheck.Gen\n                  ((x : SlimCheck.SampleableExt.proxy α) × SlimCheck.TestResult (β (SlimCheck.SampleableExt.interp x)))",
  "name": "SlimCheck.Testable.minimizeAux",
  "kind": "def",
  "doc_string":
  "Shrink a counter-example `x` by using `Shrinkable.shrink x`, picking the first\ncandidate that falsifies a property and recursively shrinking that one.\nThe process is guaranteed to terminate because `shrink x` produces\na proof that all the values it produces are smaller (according to `SizeOf`)\nthan `x`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "AndOp",
  "kind": "inductive",
  "doc_string":
  "The homogeneous version of `HAnd`: `a &&& b : α` where `a b : α`.\n(It is called `AndOp` because `And` is taken for the propositional connective.)\n",
  "args": ""},
 {"type": "Lean.Expr → Bool",
  "name": "Mathlib.Meta.NormNum.isNormalForm",
  "kind": "def",
  "doc_string":
  "Test if an expression represents an explicit number written in normal form. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [self : CommMonoidWithZero M₀] (a : M₀), 0 * a = 0",
  "name": "CommMonoidWithZero.zero_mul",
  "kind": "def",
  "doc_string": "Zero is a left absorbing element for multiplication ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Monoid α] → CoeHead αˣ α",
  "name": "Units.instCoeHeadUnits",
  "kind": "def",
  "doc_string": "A unit can be interpreted as a term in the base `Monoid`. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "LinearOrderedCommSemiring",
  "kind": "inductive",
  "doc_string":
  "A `LinearOrderedCommSemiring` is a nontrivial commutative semiring with a linear order such\nthat addition is monotone and multiplication by a positive number is strictly monotone. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Rel α β → Set α",
  "name": "Rel.dom",
  "kind": "def",
  "doc_string": "Domain of a relation ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_≥_»",
  "kind": "def",
  "doc_string": "`a ≥ b` is an abbreviation for `b ≤ a`. ",
  "args": ""},
 {"type":
  "(S : Type u_1) → (M : outParam (Type u_2)) → [inst : Zero M] → [inst : SetLike S M] → Prop",
  "name": "ZeroMemClass",
  "kind": "inductive",
  "doc_string":
  "`ZeroMemClass S M` says `S` is a type of subsets `s ≤ M`, such that `0 ∈ s` for all `s`. ",
  "args": ""},
 {"type":
  "(σ : Type u) → {m : Type u → Type v} → [inst : MonadStateOf σ m] → m σ",
  "name": "getThe",
  "kind": "def",
  "doc_string":
  "Like `withReader`, but with `ρ` explicit. This is useful if a monad supports\n`MonadWithReaderOf` for multiple different types `ρ`.\n",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {zα : Q(Zero «$α»)} →\n      {pα : Q(PartialOrder «$α»)} →\n        {e : Q(«$α»)} →\n          Mathlib.Meta.Positivity.Strictness zα pα e →\n            Lean.MetaM (Mathlib.Meta.Positivity.Strictness zα pα e) →\n              Lean.MetaM (Mathlib.Meta.Positivity.Strictness zα pα e)",
  "name": "Mathlib.Meta.Positivity.orElse",
  "kind": "def",
  "doc_string":
  "The main combinator which combines multiple `positivity` results.\nIt assumes `t₁` has already been run for a result, and runs `t₂` and takes the best result.\nIt will skip `t₂` if `t₁` is already a proof of `.positive`, and can also combine\n`.nonnegative` and `.nonzero` to produce a `.positive` result. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {π : ι → Type u_2} → [inst : (i : ι) → LT (π i)] → ((i : ι) → π i) → ((i : ι) → π i) → Prop",
  "name": "StrongLT",
  "kind": "def",
  "doc_string":
  "A function `a` is strongly less than a function `b`  if `a i < b i` for all `i`. ",
  "args": ""},
 {"type": "(α : Sort u_1) → α ↪ α",
  "name": "Function.Embedding.refl",
  "kind": "def",
  "doc_string": "The identity map as a `Function.Embedding`. ",
  "args": ""},
 {"type": "{α β : Sort u} → α = β → α → β",
  "name": "Eq.mp",
  "kind": "def",
  "doc_string":
  "If `h : α = β` is a proof of type equality, then `h.mp : α → β` is the induced\n\"cast\" operation, mapping elements of `α` to elements of `β`.\n\nYou can prove theorems about the resulting element by induction on `h`, since\n`rfl.mp` is definitionally the identity function.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (r s : R)\n  (x : M), (r + s) • x = r • x + s • x",
  "name": "Module.Core.add_smul",
  "kind": "def",
  "doc_string":
  "Scalar multiplication distributes over addition from the right. ",
  "args": ""},
 {"type":
  "{q p : Prop} → (q ↔ p) → SlimCheck.TestResult p → SlimCheck.TestResult q",
  "name": "SlimCheck.TestResult.iff",
  "kind": "def",
  "doc_string":
  "Test `q` by testing `p` and proving the equivalence between the two. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : α → Type u_2} → (((a : α) → Part (β a)) → (a : α) → Part (β a)) → Stream' ((a : α) → Part (β a))",
  "name": "Part.Fix.approx",
  "kind": "def",
  "doc_string":
  "A series of successive, finite approximation of the fixed point of `f`, defined by\n`approx f n = f^[n] ⊥`. The limit of this chain is the fixed point of `f`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u} [self : AddRightCancelMonoid M] (n : ℕ) (x : M),\n  AddRightCancelMonoid.nsmul (n + 1) x = x + AddRightCancelMonoid.nsmul n x",
  "name": "AddRightCancelMonoid.nsmul_succ",
  "kind": "def",
  "doc_string": "Multiplication by `(n + 1 : ℕ)` behaves as expected. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : PartialOrder α] → [inst : OrderBot α] → Prop",
  "name": "IsAtomic",
  "kind": "inductive",
  "doc_string":
  "A lattice is atomic iff every element other than `⊥` has an atom below it. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α) → List α → ℕ → Array α → List α",
  "name": "List.modifyNthTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `modifyNthTR`: `modifyNthTR.go f l n acc = acc.toList ++ modifyNth f n l`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : CancelCommMonoidWithZero α] → Type u_1",
  "name": "NormalizedGCDMonoid",
  "kind": "inductive",
  "doc_string":
  "Normalized GCD monoid: a `CancelCommMonoidWithZero` with normalization and `gcd`\n(greatest common divisor) and `lcm` (least common multiple) operations. In this setting `gcd` and\n`lcm` form a bounded lattice on the associated elements where `gcd` is the infimum, `lcm` is the\nsupremum, `1` is bottom, and `0` is top. The type class focuses on `gcd` and we derive the\ncorresponding `lcm` facts from `gcd`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → α × β →o α",
  "name": "OrderHom.fst",
  "kind": "def",
  "doc_string": "`Prod.fst` as a `OrderHom`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {e : Q(«$α»)} →\n      (_i : autoParam Q(Ring «$α») _auto✝) →\n        Mathlib.Meta.NormNum.Result e → Option (ℤ × (lit : Q(ℤ)) × Q(Mathlib.Meta.NormNum.IsInt «$e» «$lit»))",
  "name": "Mathlib.Meta.NormNum.Result.toInt",
  "kind": "def",
  "doc_string":
  "Extract from a `Result` the integer value (as both a term and an expression),\nand the proof that the original expression is equal to this integer.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p",
  "name": "Irreducible.dvd_symm",
  "kind": "theorem",
  "doc_string":
  "If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : ConditionallyCompleteLinearOrder β] {f : α → β}\n  {s : Set α}, MonotoneOn f s → BddBelow (f '' s) → BddAbove (f '' s) → ∃ g, Monotone g ∧ Set.EqOn f g s",
  "name": "MonotoneOn.exists_monotone_extension",
  "kind": "theorem",
  "doc_string":
  "If a function is monotone and is bounded on a set `s`, then it admits a monotone extension to\nthe whole space. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tacticType_check_",
  "kind": "def",
  "doc_string": "Type check the given expression, and trace its type. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : α → Sort u_2} → {γ : α → Sort u_3} → ((a : α) → β a ↪ γ a) → ((a : α) → β a) ↪ (a : α) → γ a",
  "name": "Function.Embedding.piCongrRight",
  "kind": "def",
  "doc_string":
  "Define an embedding `(Π a : α, β a) ↪ (Π a : α, γ a)` from a family of embeddings\n`e : Π a, (β a ↪ γ a)`. This embedding sends `f` to `λ a, e a (f a)`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (r : α → α → Prop) → [inst : IsPreorder α r] → Type u_1",
  "name": "Antisymmetrization",
  "kind": "def",
  "doc_string":
  "The partial order derived from a preorder by making pairwise comparable elements equal. This is\nthe quotient by `fun a b => a ≤ b ∧ b ≤ a`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddZeroClass M] → (S : AddSubmonoid M) → Add { x // x ∈ S }",
  "name": "AddSubmonoid.add",
  "kind": "def",
  "doc_string": "An `AddSubmonoid` of an `AddMonoid` inherits an addition.",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "RandomGen",
  "kind": "inductive",
  "doc_string": "Interface for random number generators. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : HasSSubset α] [inst_1 : IsIrrefl α fun x x_1 => x ⊂ x_1] {a : α}, ¬a ⊂ a",
  "name": "HasSSubset.SSubset.false",
  "kind": "theorem",
  "doc_string": "**Alias** of `ssubset_irrfl`.",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)",
  "name": "Commute.mul_right",
  "kind": "theorem",
  "doc_string":
  "If `a` commutes with both `b` and `c`, then it commutes with their product. ",
  "args": ""},
 {"type":
  "∀ {M : Type u} [self : AddRightCancelMonoid M] (x : M), AddRightCancelMonoid.nsmul 0 x = 0",
  "name": "AddRightCancelMonoid.nsmul_zero",
  "kind": "def",
  "doc_string": "Multiplication by `(0 : ℕ)` gives `0`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → α) → Option α → Option α → Option α",
  "name": "Option.merge",
  "kind": "def",
  "doc_string":
  "Take a pair of options and if they are both `some`, apply the given fn to produce an output.\nOtherwise act like `orElse`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (ℕ → α → β) → List α → List β",
  "name": "List.mapIdx",
  "kind": "def",
  "doc_string":
  "Given a function `f : Nat → α → β` and `as : list α`, `as = [a₀, a₁, ...]`, returns the list\n`[f 0 a₀, f 1 a₁, ...]`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → α → Aesop.UnorderedArraySet α",
  "name": "Aesop.UnorderedArraySet.singleton",
  "kind": "def",
  "doc_string": "O(1) ",
  "args": ""},
 {"type": "ℤ → ℤ",
  "name": "Int.sqrt",
  "kind": "def",
  "doc_string":
  "`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ≤ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ",
  "args": ""},
 {"type": "Mathlib.Prelude.Rename.NameEntry → Lean.Name",
  "name": "Mathlib.Prelude.Rename.NameEntry.n3",
  "kind": "def",
  "doc_string": "The lean 3 name. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "name": "LT.lt.trans_le",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_lt_of_le`.",
  "args": ""},
 {"type": "{α : Type u_1} → Multiset α → Prop",
  "name": "Multiset.Nodup",
  "kind": "def",
  "doc_string":
  "`nodup s` means that `s` has no duplicates, i.e. the multiplicity of\nany element is at most 1. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Inhabited α] → String → α",
  "name": "panic",
  "kind": "def",
  "doc_string":
  "`(panic \"msg\" : α)` has a built-in implementation which prints `msg` to\nthe error buffer. It *does not* terminate execution, and because it is a safe\nfunction, it still has to return an element of `α`, so it takes `[Inhabited α]`\nand returns `default`. It is primarily intended for debugging in pure contexts,\nand assertion failures.\n\nBecause this is a pure function with side effects, it is marked as\n`@[never_extract]` so that the compiler will not perform common sub-expression\nelimination and other optimizations that assume that the expression is pure.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → [inst : Unique M] → [inst : Unique N] → [inst : Mul M] → [inst_1 : Mul N] → Unique (M ≃* N)",
  "name": "MulEquiv.instUniqueMulEquiv",
  "kind": "def",
  "doc_string":
  "There is a unique monoid homomorphism between two monoids with a unique element. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : NonAssocSemiring β] → β →+* α → β",
  "name": "Pi.constRingHom",
  "kind": "def",
  "doc_string": "`Function.const` as a `RingHom`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {o : Option α} → Decidable (o = none)",
  "name": "Option.decidableEqNone",
  "kind": "def",
  "doc_string":
  "`o = none` is decidable even if the wrapped type does not have decidable equality.\nThis is not an instance because it is not definitionally equal to `Option.decidableEq`.\nTry to use `o.isNone` or `o.isSome` instead.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : CommSemigroup R] {a b : R}, IsRegular (a * b) ↔ IsRegular a ∧ IsRegular b",
  "name": "isRegular_mul_iff",
  "kind": "theorem",
  "doc_string": "A product is regular if and only if the factors are. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {lt : α → α → Prop} [self : IsOrderConnected α lt] (a b c : α), lt a c → lt a b ∨ lt b c",
  "name": "IsOrderConnected.conn",
  "kind": "def",
  "doc_string":
  "A connected order is one satisfying the condition `a < c → a < b ∨ b < c`. ",
  "args": ""},
 {"type": "∀ {R : Type u} [self : Ring R] (n : ℕ), IntCast.intCast ↑n = ↑n",
  "name": "Ring.intCast_ofNat",
  "kind": "def",
  "doc_string":
  "The canonical homorphism `ℤ → R` agrees with the one from `ℕ → R` on `ℕ`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Choose.choose",
  "kind": "def",
  "doc_string":
  "* `choose a b h h' using hyp` takes a hypothesis `hyp` of the form\n  `∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b ∧ Q x y a b`\n  for some `P Q : X → Y → A → B → Prop` and outputs\n  into context a function `a : X → Y → A`, `b : X → Y → B` and two assumptions:\n  `h : ∀ (x : X) (y : Y), P x y (a x y) (b x y)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x y) (b x y)`. It also works with dependent versions.\n\n* `choose! a b h h' using hyp` does the same, except that it will remove dependency of\n  the functions on propositional arguments if possible. For example if `Y` is a proposition\n  and `A` and `B` are nonempty in the above example then we will instead get\n  `a : X → A`, `b : X → B`, and the assumptions\n  `h : ∀ (x : X) (y : Y), P x y (a x) (b x)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x) (b x)`.\n\nThe `using hyp` part can be ommited,\nwhich will effectively cause `choose` to start with an `intro hyp`.\n\nExamples:\n\n```\nexample (h : ∀ n m : ℕ, ∃ i j, m = n + i ∨ m + j = n) : True := by\n  choose i j h using h\n  guard_hyp i : ℕ → ℕ → ℕ\n  guard_hyp j : ℕ → ℕ → ℕ\n  guard_hyp h : ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n\n  trivial\n```\n\n```\nexample (h : ∀ i : ℕ, i < 7 → ∃ j, i < j ∧ j < i+i) : True := by\n  choose! f h h' using h\n  guard_hyp f : ℕ → ℕ\n  guard_hyp h : ∀ (i : ℕ), i < 7 → i < f i\n  guard_hyp h' : ∀ (i : ℕ), i < 7 → f i < i + i\n  trivial\n```\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Zero R] [inst_1 : Zero M] [self : SMulWithZero R M] (m : M), 0 • m = 0",
  "name": "SMulWithZero.zero_smul",
  "kind": "def",
  "doc_string": "Scalar multiplication by the scalar `0` is `0`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term⊥»",
  "kind": "def",
  "doc_string": "The bot (`⊥`, `\\bot`) element ",
  "args": ""},
 {"type": "(α : Type u_1) → {β : Type u_2} → β → α ↪ α × β",
  "name": "Function.Embedding.sectl",
  "kind": "def",
  "doc_string": "Fixing an element `b : β` gives an embedding `α ↪ α × β`. ",
  "args": ""},
 {"type": "(G : Type u) → [inst : Mul G] → Prop",
  "name": "IsRightCancelMul",
  "kind": "inductive",
  "doc_string": "A mixin for right cancellative multiplication. ",
  "args": ""},
 {"type":
  "{ι₁ : Sort u_1} →\n  {ι₂ : Sort u_2} →\n    {κ₁ : ι₁ → Sort u_3} →\n      {κ₂ : ι₂ → Sort u_4} →\n        {φ : (i₁ : ι₁) → κ₁ i₁ → (i₂ : ι₂) → κ₂ i₂ → Sort u_5} →\n          ((i₁ : ι₁) → (j₁ : κ₁ i₁) → (i₂ : ι₂) → (j₂ : κ₂ i₂) → φ i₁ j₁ i₂ j₂) →\n            (i₂ : ι₂) → (j₂ : κ₂ i₂) → (i₁ : ι₁) → (j₁ : κ₁ i₁) → φ i₁ j₁ i₂ j₂",
  "name": "Function.swap₂",
  "kind": "def",
  "doc_string": "Swaps two pairs of arguments to a function. ",
  "args": ""},
 {"type":
  "{M : Type uM} →\n  {N : Type uN} →\n    {P : Type uP} →\n      [inst : MulOneClass M] → [inst_1 : CommMonoid N] → [inst_2 : CommMonoid P] → (N →* P) →* (M →* N) →* M →* P",
  "name": "MonoidHom.compHom",
  "kind": "def",
  "doc_string":
  "Composition of monoid morphisms (`MonoidHom.comp`) as a monoid morphism.\n\nNote that unlike `MonoidHom.comp_hom'` this requires commutativity of `N`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b = c → a ≤ c",
  "name": "LE.le.trans_eq",
  "kind": "theorem",
  "doc_string": "**Alias** of `le_of_le_of_eq`.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "HNot",
  "kind": "inductive",
  "doc_string":
  "Syntax typeclass for Heyting negation `￢`.\n\nThe difference between `HasCompl` and `HNot` is that the former belongs to Heyting algebras,\nwhile the latter belongs to co-Heyting algebras. They are both pseudo-complements, but `compl`\nunderestimates while `HNot` overestimates. In boolean algebras, they are equal.\nSee `hnot_eq_compl`.\n",
  "args": ""},
 {"type":
  "{α : Type u} → {γ : Type v} → [self : Membership α γ] → α → γ → Prop",
  "name": "Membership.mem",
  "kind": "def",
  "doc_string":
  "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} → [inst_1 : CategoryTheory.Category D] → (F : C ⥤ D) → CategoryTheory.NatTrans F F",
  "name": "CategoryTheory.NatTrans.id",
  "kind": "def",
  "doc_string":
  "`NatTrans.id F` is the identity natural transformation on a functor `F`. ",
  "args": ""},
 {"type": "{α : Type u} → (ℕ → α → α) → ℕ × ℕ → α → α",
  "name": "Prod.foldI",
  "kind": "def",
  "doc_string":
  "`(start, stop).foldI f a` evaluates `f` on all the numbers\nfrom `start` (inclusive) to `stop` (exclusive) in increasing order:\n* `(5, 8).foldI f init = init |> f 5 |> f 6 |> f 7`\n",
  "args": ""},
 {"type": "{α : Type u_1} → Option α → α → α",
  "name": "Option.getD",
  "kind": "def",
  "doc_string":
  "Get with default. If `opt : Option α` and `dflt : α`, then `opt.getD dflt`\nreturns `a` if `opt = some a` and `dflt` otherwise.\n\nThis function is `@[macro_inline]`, so `dflt` will not be evaluated unless\n`opt` turns out to be `none`.\n",
  "args": ""},
 {"type": "{α : Type u} → Stream' α → ℕ → α",
  "name": "Stream'.nth",
  "kind": "def",
  "doc_string": "`n`-th element of a stream. ",
  "args": ""},
 {"type":
  "{P : ℕ → ℕ → Sort u_1} → ((a b : ℕ) → ((x y : ℕ) → x < a → y < b → P x y) → P a b) → (n m : ℕ) → P n m",
  "name": "Nat.strongSubRecursion",
  "kind": "def",
  "doc_string":
  "Given `P : ℕ → ℕ → Sort*`, if for all `a b : ℕ` we can extend `P` from the rectangle\nstrictly below `(a,b)` to `P a b`, then we have `P n m` for all `n m : ℕ`.\nNote that for non-`Prop` output it is preferable to use the equation compiler directly if possible,\nsince this produces equation lemmas. ",
  "args": ""},
 {"type":
  "{V : Type u₁} → [inst : Quiver V] → {W : Type u₂} → [inst_1 : Quiver W] → V ⥤q W → V → W",
  "name": "Prefunctor.obj",
  "kind": "def",
  "doc_string": "The action of a (pre)functor on vertices/objects. ",
  "args": ""},
 {"type":
  "{F : Type u → Type w} → {G : Type v → Type u} → {α : Type v} → F (G α) → Functor.Comp F G α",
  "name": "Functor.Comp.mk",
  "kind": "def",
  "doc_string":
  "Construct a term of `Comp F G α` from a term of `F (G α)`, which is the same type.\nCan be used as a pattern to extract a term of `F (G α)`. ",
  "args": ""},
 {"type":
  "{C : Type u} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        (F : C ⥤ D) → {X Y : C} → (X ≅ Y) → (Prefunctor.obj F.toPrefunctor X ≅ Prefunctor.obj F.toPrefunctor Y)",
  "name": "CategoryTheory.Functor.mapIso",
  "kind": "def",
  "doc_string":
  "A functor `F : C ⥤ D` sends isomorphisms `i : X ≅ Y` to isomorphisms `F.obj X ≅ F.obj Y` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LT α] [self : DenselyOrdered α] (a₁ a₂ : α), a₁ < a₂ → ∃ a, a₁ < a ∧ a < a₂",
  "name": "DenselyOrdered.dense",
  "kind": "def",
  "doc_string":
  "An order is dense if there is an element between any pair of distinct elements. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : LinearOrder β] {f g : α → β},\n  Antitone f → Antitone g → Antitone fun x => max (f x) (g x)",
  "name": "Antitone.max",
  "kind": "theorem",
  "doc_string":
  "Pointwise maximum of two monotone functions is a monotone function. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} → [inst : Mul R] → [inst_1 : Mul S] → [inst_2 : Add R] → [inst_3 : Add S] → R ≃+* S → S ≃+* R",
  "name": "RingEquiv.symm",
  "kind": "def",
  "doc_string": "The inverse of a ring isomorphism is a ring isomorphism. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : PartialOrder α] → [inst_1 : PartialOrder β] → α ≃o β → WithBot α ≃o WithBot β",
  "name": "OrderIso.withBotCongr",
  "kind": "def",
  "doc_string": "A version of `equiv.optionCongr` for `WithBot`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a ↔ a = 0",
  "name": "zero_dvd_iff",
  "kind": "theorem",
  "doc_string":
  "Given an element `a` of a commutative semigroup with zero, there exists another element whose\nproduct with zero equals `a` iff `a` equals zero. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (e a b : Q(«$α»)) →\n      Q(Semiring «$α») →\n        Mathlib.Meta.NormNum.Result a → Mathlib.Meta.NormNum.Result b → Option (Mathlib.Meta.NormNum.Result e)",
  "name": "Mathlib.Meta.NormNum.evalMul.core",
  "kind": "def",
  "doc_string": "Main part of `evalMul`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → TwoPointing α → TwoPointing β → TwoPointing (α × β)",
  "name": "TwoPointing.prod",
  "kind": "def",
  "doc_string": "The product of two two-pointings. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → β → Prop) → Option α → Option β → Prop",
  "name": "Option.rel",
  "kind": "inductive",
  "doc_string":
  "Lifts a relation `α → β → Prop` to a relation `Option α → Option β → Prop` by just adding\n`none ~ none`. ",
  "args": ""},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "name": "Function.HasRightInverse",
  "kind": "def",
  "doc_string":
  "`hasRightInverse f` means that `f` has an unspecified right inverse. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} → {Q : Type u_4} → [inst : Add P] → [inst_1 : Add Q] → M ≃ N → P ≃+ Q → (M → P) ≃+ (N → Q)",
  "name": "AddEquiv.arrowCongr",
  "kind": "def",
  "doc_string":
  "An additive analogue of `Equiv.arrowCongr`,\nwhere the equivalence between the targets is additive.",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Mul M] → Set M",
  "name": "Set.center",
  "kind": "def",
  "doc_string": "The center of a magma. ",
  "args": ""},
 {"type": "ℕ → Lean.Expr → Lean.Expr × Lean.Expr",
  "name": "Mathlib.Tactic.Sat.buildReify.reifyLiteral",
  "kind": "def",
  "doc_string": "Returns `a` and `pr : reify v l a` given a literal `c` ",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : Monoid α] (self : αˣ), ↑self * self.inv = 1",
  "name": "Units.val_inv",
  "kind": "def",
  "doc_string": "`inv` is the right inverse of `val` in the base `Monoid`. ",
  "args": ""},
 {"type": "Linarith.Preprocessor",
  "name": "Linarith.splitConjunctions",
  "kind": "def",
  "doc_string":
  "Processor thaat recursively replaces `P ∧ Q` hypotheses with the pair `P` and `Q`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} → [inst : Zero M] → [inst_1 : Zero N] → [inst_2 : Zero P] → ZeroHom N P → ZeroHom M N → ZeroHom M P",
  "name": "ZeroHom.comp",
  "kind": "def",
  "doc_string": "Composition of `ZeroHom`s as a `ZeroHom`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HOrElse α β γ] → α → (Unit → β) → γ",
  "name": "HOrElse.hOrElse",
  "kind": "def",
  "doc_string":
  "`a <|> b` executes `a` and returns the result, unless it fails in which\ncase it executes and returns `b`. Because `b` is not always executed, it\nis passed as a thunk so it can be forced only when needed.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type": "Type",
  "name": "ProjectionRule",
  "kind": "inductive",
  "doc_string":
  "The type of rules that specify how metadata for projections in changes.\nSee `initialize_simps_projections`. ",
  "args": ""},
 {"type":
  "∀ {a b c m : ℕ}, Nat.gcd m c = 1 → c * a ≡ c * b [MOD m] → a ≡ b [MOD m]",
  "name": "Nat.ModEq.modEq_cancel_left_of_coprime",
  "kind": "theorem",
  "doc_string":
  "A common factor that's coprime with the modulus can be cancelled from a `ModEq` ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : AddMonoid α] → [inst_1 : DecidableEq α] → DecidableEq (AddUnits α)",
  "name": "AddUnits.instDecidableEqAddUnits",
  "kind": "def",
  "doc_string":
  "Additive units have decidable equality\nif the base `AddMonoid` has deciable equality.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {f : ℤ → α},\n  Monotone f → ∀ (n : ℤ) {x : α}, f n < x → x < f (n + 1) → ∀ (a : ℤ), f a ≠ x",
  "name": "Monotone.ne_of_lt_of_lt_int",
  "kind": "theorem",
  "doc_string":
  "If `f` is a monotone function from `ℤ` to a preorder and `x` lies between `f n` and\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Polyrith.«tacticPolyrithOnly[_]»",
  "kind": "def",
  "doc_string":
  "Attempts to prove polynomial equality goals through polynomial arithmetic\non the hypotheses (and additional proof terms if the user specifies them).\nIt proves the goal by generating an appropriate call to the tactic\n`linear_combination`. If this call succeeds, the call to `linear_combination`\nis suggested to the user.\n\n* `polyrith` will use all relevant hypotheses in the local context.\n* `polyrith [t1, t2, t3]` will add proof terms t1, t2, t3 to the local context.\n* `polyrith only [h1, h2, h3, t1, t2, t3]` will use only local hypotheses\n  `h1`, `h2`, `h3`, and proofs `t1`, `t2`, `t3`. It will ignore the rest of the local context.\n\nNotes:\n* This tactic only works with a working internet connection, since it calls Sage\n  using the SageCell web API at <https://sagecell.sagemath.org/>.\n  Many thanks to the Sage team and organization for allowing this use.\n* This tactic assumes that the user has `python3` installed and available on the path.\n  (Test by opening a terminal and executing `python3 --version`.)\n  It also assumes that the `requests` library is installed: `python3 -m pip install requests`.\n\nExamples:\n\n```lean\nexample (x y : ℚ) (h1 : x*y + 2*x = 1) (h2 : x = y) :\n  x*y = -2*y + 1 :=\nby polyrith\n-- Try this: linear_combination h1 - 2 * h2\n\nexample (x y z w : ℚ) (hzw : z = w) : x*z + 2*y*z = x*w + 2*y*w :=\nby polyrith\n-- Try this: linear_combination (2 * y + x) * hzw\n\nconstant scary : ∀ a b : ℚ, a + b = 0\n\nexample (a b c d : ℚ) (h : a + b = 0) (h2: b + c = 0) : a + b + c + d = 0 :=\nby polyrith only [scary c d, h]\n-- Try this: linear_combination scary c d + h\n```\n",
  "args": ""},
 {"type":
  "{c d : Type u → Type v} → ({α : Type u} → c α → d α) → CategoryTheory.Bundled c → CategoryTheory.Bundled d",
  "name": "CategoryTheory.Bundled.map",
  "kind": "def",
  "doc_string": "Map over the bundled structure ",
  "args": ""},
 {"type":
  "{α : Type u_1} → ℕ → List α → Array α → Array (List α) → List (List α)",
  "name": "List.toChunks.go",
  "kind": "def",
  "doc_string":
  "Auxliary definition used to define `toChunks`.\n`toChunks.go xs acc₁ acc₂` pushes elements into `acc₁` until it reaches size `n`,\nthen it pushes the resulting list to `acc₂` and continues until `xs` is exhausted. ",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.Ineq",
  "kind": "inductive",
  "doc_string":
  "The three-element type `Ineq` is used to represent the strength of a comparison between\nterms. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → (P : α → Sort u_3) → (e : α ≃ β) → ((a : α) → P a) ≃ ((b : β) → P (↑(Equiv.symm e) b))",
  "name": "Equiv.piCongrLeft'",
  "kind": "def",
  "doc_string":
  "Transport dependent functions through an equivalence of the base space.\n",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : PartialOrder α] → ClosureOperator α",
  "name": "ClosureOperator.id",
  "kind": "def",
  "doc_string": "The identity function as a closure operator. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "name": "congrFun",
  "kind": "theorem",
  "doc_string":
  "Congruence in the function part of an application: If `f = g` then `f a = g a`. ",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} {p : α → Prop} {a : α} [inst : Applicative m] [inst_1 : LawfulApplicative m],\n  p a → SatisfiesM p (pure a)",
  "name": "SatisfiesM.pure",
  "kind": "theorem",
  "doc_string":
  "`SatisfiesM` distributes over `pure`, general version / weakest precondition version. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a : α}, 1 ≤ a⁻¹ → a ≤ 1",
  "name": "le_one_of_one_le_inv",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `Left.one_le_inv_iff`.",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Type u_2} {γ : Sort u_3} [inst : DecidableEq β] (g : β → γ) {f : α → β} {i : β} (a : γ),\n  ¬i ∈ Set.range f → Function.update g i a ∘ f = g ∘ f",
  "name": "Function.update_comp_eq_of_not_mem_range",
  "kind": "theorem",
  "doc_string":
  "Non-dependent version of `Function.update_comp_eq_of_not_mem_range'` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → α → Prop) → (β → β → Prop) → Type (max u_1 u_2)",
  "name": "RelHom",
  "kind": "inductive",
  "doc_string":
  "A relation homomorphism with respect to a given pair of relations `r` and `s`\nis a function `f : α → β` such that `r a b → s (f a) (f b)`. ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Polyrith.SageError",
  "kind": "inductive",
  "doc_string": "The result of a sage call in the failure case. ",
  "args": ""},
 {"type": "Lean.Expr → Option ℕ",
  "name": "Mathlib.Meta.NormNum.isNatLit",
  "kind": "def",
  "doc_string":
  "Extract the natural number `n` if the expression is of the form `OfNat.ofNat n`. ",
  "args": ""},
 {"type":
  "{ε : Type u} → {m : Type v → Type w} → [inst : MonadExcept ε m] → {α : Type v} → m α → m α → optParam Bool true → m α",
  "name": "MonadExcept.orelse'",
  "kind": "def",
  "doc_string":
  "Alternative orelse operator that allows to select which exception should be used.\nThe default is to use the first exception since the standard `orelse` uses the second. ",
  "args": ""},
 {"type":
  "{a : Lean.Level} →\n  {arg : Q(Type a)} →\n    {sα : Q(CommSemiring «$arg»)} →\n      {a_1 b : Q(«$arg»)} → Mathlib.Tactic.Ring.ExBase sα a_1 → Mathlib.Tactic.Ring.ExBase sα b → Ordering",
  "name": "Mathlib.Tactic.Ring.ExBase.cmp",
  "kind": "opaque",
  "doc_string":
  "A total order on normalized expressions.\nThis is not an `Ord` instance because it is heterogeneous.\n",
  "args": ""},
 {"type":
  "{α : Sort u} → {r : α → α → Prop} → {motive : Quot r → Sort v} → ((a : α) → motive (Quot.mk r a)) → α → PSigma motive",
  "name": "Quot.indep",
  "kind": "def",
  "doc_string": "Auxiliary definition for `Quot.rec`. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {motive : α → Prop} {a b : α}, a = b → motive a → motive b",
  "name": "Eq.subst",
  "kind": "theorem",
  "doc_string":
  "The substitution principle for equality. If `a = b ` and `P a` holds,\nthen `P b` also holds. We conventionally use the name `motive` for `P` here,\nso that you can specify it explicitly using e.g.\n`Eq.subst (motive := fun x => x < 5)` if it is not otherwise inferred correctly.\n\nThis theorem is the underlying mechanism behind the `rw` tactic, which is\nessentially a fancy algorithm for finding good `motive` arguments to usefully\napply this theorem to replace occurrences of `a` with `b` in the goal or\nhypotheses.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n",
  "args": ""},
 {"type": "ℕ → ℕ → Prop",
  "name": "Nat.coprime",
  "kind": "def",
  "doc_string":
  "`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : SuccOrder α] [inst_2 : IsSuccArchimedean α]\n  [inst_3 : LinearOrder β] {f : α → β},\n  Monotone f →\n    ∀ (m n : α), (Set.unionᵢ fun i => Set.unionᵢ fun h => Set.Ioc (f i) (f (Order.succ i))) = Set.Ioc (f m) (f n)",
  "name": "Monotone.bunionᵢ_Ico_Ioc_map_succ",
  "kind": "theorem",
  "doc_string":
  "If `α` is a linear archimedean succ order and `β` is a linear order, then for any monotone\nfunction `f` and `m n : α`, the union of intervals `Set.Ioc (f i) (f (Order.succ i))`, `m ≤ i < n`,\nis equal to `Set.Ioc (f m) (f n)` ",
  "args": ""},
 {"type": "PosNum → PosNum → ZNum",
  "name": "PosNum.sub'",
  "kind": "def",
  "doc_string": "Subtraction of two `PosNum`s, producing a `ZNum`. ",
  "args": ""},
 {"type":
  "∀ {ι : Type u_2} {α : Type u_1} [inst : Preorder ι] [inst_1 : DecidableEq ι] [inst_2 : Preorder α] {f : ι → α}\n  {i j : ι}, i < j → f j < f i → ↑toLex (f ∘ ↑(Equiv.swap i j)) < ↑toLex f",
  "name": "Pi.lex_desc",
  "kind": "theorem",
  "doc_string":
  "If we swap two strictly decreasing values in a function, then the result is lexicographically\nsmaller than the original function. ",
  "args": ""},
 {"type": "Sat.Fmla → Sat.Fmla → Sat.Fmla",
  "name": "Sat.Fmla.and",
  "kind": "def",
  "doc_string": "A conjunction of formulas. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → [inst : MulOneClass M] → GaloisInsertion Submonoid.closure SetLike.coe",
  "name": "Submonoid.gi",
  "kind": "def",
  "doc_string": "`closure` forms a Galois insertion with the coercion to set. ",
  "args": ""},
 {"type":
  "Lean.Syntax →\n  Lean.Name →\n    optParam Simps.Config\n        { isSimp := true, attrs := [], simpRhs := false, typeMd := Lean.Meta.TransparencyMode.instances,\n          rhsMd := Lean.Meta.TransparencyMode.reducible, fullyApplied := true, notRecursive := [`Prod, `PProd],\n          debug := false, addAdditive := none } →\n      optParam (List (String × Lean.Syntax)) [] → optParam Bool false → Lean.AttrM (Array Lean.Name)",
  "name": "simpsTac",
  "kind": "def",
  "doc_string":
  "`simpsTac` derives `simp` lemmas for all (nested) non-Prop projections of the declaration.\nIf `todo` is non-empty, it will generate exactly the names in `todo`.\nIf `shortNm` is true, the generated names will only use the last projection name.\nIf `trc` is true, trace as if `trace.simps.verbose` is true. ",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.sqrt.iter",
  "kind": "def",
  "doc_string":
  "Auxiliary for `sqrt`. If `guess` is greater than the integer square root of `n`,\nreturns the integer square root of `n`. ",
  "args": ""},
 {"type": "{α : Type u} → {n : ℕ} → Vector α (Nat.succ n) → α",
  "name": "Vector.head",
  "kind": "def",
  "doc_string": "The first element of a vector with length at least `1`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (e : M ≃+ N) (y : N), ↑e (↑(AddEquiv.symm e) y) = y",
  "name": "AddEquiv.apply_symm_apply",
  "kind": "theorem",
  "doc_string":
  "`e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`.",
  "args": ""},
 {"type":
  "(R : Type u_1) →\n  (S : Type u_2) → [inst : NonAssocSemiring R] → [inst_1 : NonAssocSemiring S] → [inst_2 : Subsingleton S] → R ≃+* S × R",
  "name": "RingEquiv.zeroRingProd",
  "kind": "def",
  "doc_string":
  "A ring `R` is isomorphic to `S × R` when `S` is the zero ring ",
  "args": ""},
 {"type":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} → [inst : Add α] → [inst_1 : Add β] → [inst_2 : AddEquivClass F α β] → CoeTC F (α ≃+ β)",
  "name": "instCoeTCAddEquiv",
  "kind": "def",
  "doc_string":
  "Any type satisfying `AddEquivClass` can be cast into `AddEquiv` via\n`AddEquivClass.toAddEquiv`. ",
  "args": ""},
 {"type": "{α : Type u} → ℕ → α → List α",
  "name": "List.replicateTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `List.replicate`. ",
  "args": ""},
 {"type": "{α : Type u} → (α → α → Bool) → List α → List (List α)",
  "name": "List.groupBy",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `groupBy R l` splits `l` into chains of elements\nsuch that adjacent elements are related by `R`.\n\n* `groupBy (·==·) [1, 1, 2, 2, 2, 3, 2] = [[1, 1], [2, 2, 2], [3], [2]]`\n* `groupBy (·<·) [1, 2, 5, 4, 5, 1, 4] = [[1, 2, 5], [4, 5], [1, 4]]`\n",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "name": "Contravariant",
  "kind": "def",
  "doc_string":
  "`Contravariant` is useful to formulate succintly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `ContravariantClass` doc-string for its meaning. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α},\n  a < 0 → b < 0 → a + b < 0",
  "name": "Right.add_neg",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg`.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "NonAssocRing",
  "kind": "inductive",
  "doc_string": "A unital but not-necessarily-associative ring. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Sort u_2} [inst : CompleteLattice α] (f : ι → α), (⨅ i, f ↑i) = ⨅ i, f i",
  "name": "infᵢ_ne_top_subtype",
  "kind": "theorem",
  "doc_string":
  "When taking the infimum of `f : ι → α`, the elements of `ι` on which `f` gives `⊤` can be\ndropped, without changing the result. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : AddCommMonoid α] → ℕ → α → α",
  "name": "Mathlib.Tactic.Abel.smul",
  "kind": "def",
  "doc_string": "A synonym for `•`, used internally in `abel`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Tactic.Alias.aliasLR",
  "kind": "def",
  "doc_string": "Adds one-way implication declarations. ",
  "args": ""},
 {"type": "{α : Sort u_1} → {s₁ : Setoid α} → Quotient s₁ → α",
  "name": "Quotient.out'",
  "kind": "def",
  "doc_string":
  "A version of `Quotient.out` taking `{s₁ : Setoid α}` as an implicit argument instead of an\ninstance argument. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "name": "Tactic.NormCast.splittingProcedure",
  "kind": "def",
  "doc_string":
  "This is the main heuristic used alongside the elim and move lemmas.\nThe goal is to help casts move past operators by adding intermediate casts.\nAn expression of the shape: op (↑(x : α) : γ) (↑(y : β) : γ)\nis rewritten to:            op (↑(↑(x : α) : β) : γ) (↑(y : β) : γ)\nwhen (↑(↑(x : α) : β) : γ) = (↑(x : α) : γ) can be proven with a squash lemma\n",
  "args": ""},
 {"type": "∀ {α : Type u} [self : BooleanAlgebra α] (x y : α), x ⇨ y = y ⊔ xᶜ",
  "name": "BooleanAlgebra.himp_eq",
  "kind": "def",
  "doc_string": "`x ⇨ y` is equal to `y ⊔ xᶜ` ",
  "args": ""},
 {"type": "ZNum → ZNum",
  "name": "ZNum.pred",
  "kind": "def",
  "doc_string": "The predecessor of a `ZNum`. ",
  "args": ""},
 {"type": "(R : Type u_1) → [inst : MulZeroClass R] → SMulWithZero Rᵐᵒᵖ R",
  "name": "MulZeroClass.toOppositeSMulWithZero",
  "kind": "def",
  "doc_string":
  "Like `MulZeroClass.toSMulWithZero`, but multiplies on the right. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Bijective f → ∀ (b : β), ∃! a, f a = b",
  "name": "Function.Bijective.existsUnique",
  "kind": "theorem",
  "doc_string":
  "Shorthand for using projection notation with `Function.bijective_iff_existsUnique`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : ConditionallyCompleteLattice α] → ConditionallyCompleteLattice (WithTop α)",
  "name": "WithTop.conditionallyCompleteLattice",
  "kind": "def",
  "doc_string":
  "Adding a top element to a conditionally complete lattice\ngives a conditionally complete lattice ",
  "args": ""},
 {"type": "{α : Type u} → [self : Bot α] → α",
  "name": "Bot.bot",
  "kind": "def",
  "doc_string": "The bot (`⊥`, `\\bot`) element ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrderedCancelCommMonoid α] (a b : α), a ≤ b ∨ b ≤ a",
  "name": "LinearOrderedCancelCommMonoid.le_total",
  "kind": "def",
  "doc_string": "A linear order is total. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] {a : αᵒᵈ}, IsTop a → IsBot (↑OrderDual.ofDual a)",
  "name": "IsTop.ofDual",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `isBot_ofDual_iff`.",
  "args": ""},
 {"type": "(M : Type u_1) → (α : Type u_2) → [inst : SMul M α] → Prop",
  "name": "FaithfulSMul",
  "kind": "inductive",
  "doc_string": "Typeclass for faithful actions. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s t : Set α},\n  BddBelow s → Set.Nonempty s → BddBelow t → Set.Nonempty t → infₛ (s ∪ t) = infₛ s ⊓ infₛ t",
  "name": "cinfₛ_union",
  "kind": "theorem",
  "doc_string":
  "The `infₛ` of a union of two sets is the min of the infima of each subset, under the assumptions\nthat all sets are bounded below and nonempty.",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {t : Set α},\n  AntitoneOn f t → ∀ {a : α}, IsGreatest t a → IsLeast (f '' t) (f a)",
  "name": "AntitoneOn.map_isGreatest",
  "kind": "theorem",
  "doc_string":
  "An antitone map sends a greatest element of a set to a least element of its image. ",
  "args": ""},
 {"type":
  "∀ {α β γ : Type u_1} (f : α → β → γ) (s : Set α) (t : Set β), Set.image2 f s t = Seq.seq (f <$> s) fun x => t",
  "name": "Set.image2_def",
  "kind": "theorem",
  "doc_string":
  "`Set.image2` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. ",
  "args": ""},
 {"type":
  "Lean.PersistentEnvExtension Mathlib.Meta.NormNum.Entry (Mathlib.Meta.NormNum.Entry × Mathlib.Meta.NormNum.NormNumExt)\n  (List Mathlib.Meta.NormNum.Entry × Lean.Meta.DiscrTree Mathlib.Meta.NormNum.NormNumExt true)",
  "name": "Mathlib.Meta.NormNum.normNumExt",
  "kind": "opaque",
  "doc_string": "Environment extensions for `norm_num` declarations ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {G : Type u_2} → [inst : MulOneClass M] → [inst_1 : CommGroup G] → CommGroup (M →* G)",
  "name": "commGroup",
  "kind": "def",
  "doc_string":
  "If `G` is a commutative group, then `M →* G` is a commutative group too. ",
  "args": ""},
 {"type": "{α : Sort u_1} → (f : α → α) → Function.Involutive f → Equiv.Perm α",
  "name": "Function.Involutive.toPerm",
  "kind": "def",
  "doc_string":
  "Convert an involutive function `f` to a permutation with `toFun = invFun = f`. ",
  "args": ""},
 {"type":
  "{α : Type u} → (p : α → Prop) → [inst : DecidablePred p] → Equiv.Perm (Subtype p) ≃ { f // ∀ (a : α), ¬p a → ↑f a = a }",
  "name": "Equiv.Perm.subtypeEquivSubtypePerm",
  "kind": "def",
  "doc_string":
  "Permutations on a subtype are equivalent to permutations on the original type that fix pointwise\nthe rest. ",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u_2} {G₀' : Type u_1} {F : Type u_3} [inst : GroupWithZero G₀] [inst_1 : GroupWithZero G₀']\n  [inst_2 : MonoidWithZeroHomClass F G₀ G₀'] (f : F) (a : G₀), ↑f a⁻¹ = (↑f a)⁻¹",
  "name": "map_inv₀",
  "kind": "theorem",
  "doc_string":
  "A monoid homomorphism between groups with zeros sending `0` to `0` sends `a⁻¹` to `(f a)⁻¹`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : NonAssocRing α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "name": "NonAssocRing.natCast_succ",
  "kind": "def",
  "doc_string": "The canonical map `ℕ → R` is a homomorphism. ",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.Linexp",
  "kind": "def",
  "doc_string":
  "A linear expression is a list of pairs of variable indices and coefficients,\nrepresenting the sum of the products of each coefficient with its corresponding variable.\n\nSome functions on `Linexp` assume that `n : Nat` occurs at most once as the first element of a pair,\nand that the list is sorted in decreasing order of the first argument.\nThis is not enforced by the type but the operations here preserve it.\n",
  "args": ""},
 {"type": "ParsedProjectionData → Lean.Name × Lean.Syntax",
  "name": "ParsedProjectionData.newName",
  "kind": "def",
  "doc_string":
  "name and syntax for this projection used in the generated `simp` lemmas ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "Bot",
  "kind": "inductive",
  "doc_string": "Typeclass for the `⊥` (`\\bot`) notation ",
  "args": ""},
 {"type": "{R : Type u_1} → [inst : NonUnitalNonAssocSemiring R] → R → R →+ R",
  "name": "AddMonoidHom.mulLeft",
  "kind": "def",
  "doc_string":
  "Left multiplication by an element of a (semi)ring is an `AddMonoidHom` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosMonoRev α],\n  b * a ≤ c * a → 0 < a → b ≤ c",
  "name": "le_of_mul_le_mul_of_pos_right",
  "kind": "theorem",
  "doc_string": "**Alias** of `le_of_mul_le_mul_right`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  StrictMono f → StrictAnti (f ∘ ↑OrderDual.ofDual)",
  "name": "StrictMono.dual_left",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `strictAnti_comp_ofDual_iff`.",
  "args": ""},
 {"type":
  "∀ {M : Type u_2} {F : Type u_1} [inst : Monoid F] (c : F → M → M),\n  c 1 = id → (∀ (f g : F), c (f * g) = c f ∘ c g) → ∀ (f : F) (n : ℕ), c (f ^ n) = c f^[n]",
  "name": "hom_coe_pow",
  "kind": "theorem",
  "doc_string":
  "An auxiliary lemma that can be used to prove `⇑(f ^ n) = (⇑f^[n])`. ",
  "args": ""},
 {"type": "ℤ → ℤ → ℕ",
  "name": "Int.lcm",
  "kind": "def",
  "doc_string": "ℤ specific version of least common multiple. ",
  "args": ""},
 {"type": "∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3",
  "name": "Nat.odd_mod_four_iff",
  "kind": "theorem",
  "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Ring.ring1",
  "kind": "def",
  "doc_string":
  "Tactic for solving equations of *commutative* (semi)rings,\nallowing variables in the exponent.\n\n* This version of `ring` fails if the target is not an equality.\n* The variant `ring1!` will use a more aggressive reducibility setting\n  to determine equality of atoms.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, b ≤ c → a ≤ b → a ≤ c",
  "name": "LE.le.trans'",
  "kind": "theorem",
  "doc_string": "**Alias** of `le_trans'`.",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "name": "Mathlib.Tactic.PushNeg.pushNegCore",
  "kind": "def",
  "doc_string": "Common entry point to `push_neg` as a conv. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  (α :\n      let u := u;\n      Q(Type u)) →\n    Q(Semiring «$α») → ℕ → Q(«$α»)",
  "name": "Qq.ofNatQ",
  "kind": "def",
  "doc_string": "Typesafe conversion of `n : ℕ` to `Q($α)`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {s₁ : Setoid α} → {s₂ : Setoid β} → (f : α → β) → Relator.LiftFun Setoid.r Setoid.r f f → Quotient s₁ → Quotient s₂",
  "name": "Quotient.map'",
  "kind": "def",
  "doc_string":
  "Map a function `f : α → β` that sends equivalent elements to equivalent elements\nto a function `Quotient sa → Quotient sb`. Useful to define unary operations on quotients. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {F : Type u_3} →\n      {G : Type u_4} →\n        [inst : Monoid R] →\n          [inst_1 : Monoid S] →\n            [inst_2 : MonoidHomClass F R S] →\n              [inst_3 : MonoidHomClass G S R] →\n                (f : F) → (g : G) → (r : R) → Function.LeftInverse ↑g ↑f → Invertible (↑f r) ≃ Invertible r",
  "name": "invertibleEquivOfLeftInverse",
  "kind": "def",
  "doc_string":
  "Invertibility on either side of a monoid hom with a left-inverse is equivalent. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : HasSup α] →\n      [inst_1 : HasInf α] →\n        [inst_2 : Top α] →\n          [inst_3 : Bot α] →\n            [inst_4 : HasCompl α] →\n              [inst_5 : HImp α] →\n                [inst_6 : HeytingAlgebra β] →\n                  (f : α → β) →\n                    Function.Injective f →\n                      (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) →\n                        (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) →\n                          f ⊤ = ⊤ →\n                            f ⊥ = ⊥ →\n                              (∀ (a : α), f (aᶜ) = f aᶜ) → (∀ (a b : α), f (a ⇨ b) = f a ⇨ f b) → HeytingAlgebra α",
  "name": "Function.Injective.heytingAlgebra",
  "kind": "def",
  "doc_string": "Pullback a `HeytingAlgebra` along an injection. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Option α → Option β",
  "name": "Option.map",
  "kind": "def",
  "doc_string":
  "Map a function over an `Option` by applying the function to the contained\nvalue if present.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosStrictMono α],\n  a < 1 → b ≤ 1 → 0 < b → a * b < 1",
  "name": "Right.mul_lt_one_of_lt_of_le_of_pos",
  "kind": "theorem",
  "doc_string": "Assumes right covariance. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : CanonicallyLinearOrderedAddMonoid α] → DecidableEq α",
  "name": "CanonicallyLinearOrderedAddMonoid.decidable_eq",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type": "{M : Type u_1} → [inst : AddMonoid M] → AddUnits M → Equiv.Perm M",
  "name": "AddUnits.addLeft",
  "kind": "def",
  "doc_string":
  "Left addition of an additive unit is a permutation of the underlying type.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Heyting.«term∂_»",
  "kind": "def",
  "doc_string": "The boundary of an element of a co-Heyting algebra. ",
  "args": ""},
 {"type": "(A : Type y) → [inst : AddGroup A] → A ≃ (ℤ →+ A)",
  "name": "zmultiplesHom",
  "kind": "def",
  "doc_string":
  "Additive homomorphisms from `ℤ` are defined by the image of `1`. ",
  "args": ""},
 {"type":
  "Lean.Expr → Option Lean.Expr → Lean.MVarId → Lean.MetaM (List Lean.MVarId)",
  "name": "Mathlib.Tactic.applyFunTarget",
  "kind": "def",
  "doc_string": "Apply a function to the main goal. ",
  "args": ""},
 {"type": "Sort u",
  "name": "PUnit",
  "kind": "inductive",
  "doc_string":
  "The unit type, the canonical type with one element, named `unit` or `()`.\nThis is the universe-polymorphic version of `Unit`; it is preferred to use\n`Unit` instead where applicable.\nFor more information about universe levels: [Types as objects](https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects)\n",
  "args": ""},
 {"type": "(α : Type u_1) → Bool × α ≃ α ⊕ α",
  "name": "Equiv.boolProdEquivSum",
  "kind": "def",
  "doc_string": "The product `Bool × α` is equivalent to `α ⊕ α`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : NonUnitalNonAssocRing α] {a b c d e : α}, a * e + c = b * e + d → (a - b) * e + c = d",
  "name": "sub_mul_add_eq_of_mul_add_eq_mul_add",
  "kind": "theorem",
  "doc_string":
  "A simplification of one side of an equation exploiting right distributivity in rings\nand the definition of subtraction. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Tactic.NormCast.tacticNorm_cast__",
  "kind": "def",
  "doc_string":
  "Normalize casts at the given locations by moving them \"upwards\".\n",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → β → α ⊕' β",
  "name": "PSum.inr",
  "kind": "def",
  "doc_string":
  "Right injection into the sum type `α ⊕' β`. If `b : β` then `.inr b : α ⊕' β`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Inhabited α] → Option α → α",
  "name": "Option.iget",
  "kind": "def",
  "doc_string":
  "Inhabited `get` function. Returns `a` if the input is `some a`, otherwise returns `default`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tacIfThenElse",
  "kind": "def",
  "doc_string":
  "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
  "args": ""},
 {"type": "∀ {M : Type u} [self : AddCommMonoid M] (a b : M), a + b = b + a",
  "name": "AddCommMonoid.add_comm",
  "kind": "def",
  "doc_string":
  "Addition is commutative in an additive commutative semigroup. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : ConditionallyCompleteLattice α] → ConditionallyCompleteLattice (WithBot α)",
  "name": "WithBot.conditionallyCompleteLattice",
  "kind": "def",
  "doc_string":
  "Adding a bottom element to a conditionally complete lattice\ngives a conditionally complete lattice ",
  "args": ""},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "name": "CoeHTCT",
  "kind": "inductive",
  "doc_string":
  "Auxiliary class implementing `CoeHead* Coe* CoeTail?`.\nUsers should generally not implement this directly.\n",
  "args": ""},
 {"type": "∀ {α : Sort u} {β : Sort v}, Function.Injective fun e => ↑e",
  "name": "Equiv.coe_fn_injective",
  "kind": "theorem",
  "doc_string": "The map `(r ≃ s) → (r → s)` is injective. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : AddZeroClass α] → [inst_1 : AddCommMonoid β] → (α →+ β) →+ α → β",
  "name": "AddMonoidHom.coeFn",
  "kind": "def",
  "doc_string":
  "Coercion of an `AddMonoidHom` into a function is itself a `AddMonoidHom`.\n\nSee also `AddMonoidHom.eval`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {F : Type u_3} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → [inst_2 : MonoidHomClass F M N] → F → M →* N",
  "name": "MonoidHomClass.toMonoidHom",
  "kind": "def",
  "doc_string":
  "Turn an element of a type `F` satisfying `MonoidHomClass F M N` into an actual\n`MonoidHom`. This is declared as the default coercion from `F` to `M →* N`. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, 0 = a * b ↔ a = 0 ∨ b = 0",
  "name": "zero_eq_mul",
  "kind": "theorem",
  "doc_string":
  "If `α` has no zero divisors, then the product of two elements equals zero iff one of them\nequals zero. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {b : α},\n  Set.Nonempty s → (∀ (a : α), a ∈ s → b ≤ a) → (∀ (w : α), b < w → ∃ a, a ∈ s ∧ a < w) → infₛ s = b",
  "name": "cinfₛ_eq_of_forall_ge_of_forall_gt_exists_lt",
  "kind": "theorem",
  "doc_string":
  "Introduction rule to prove that `b` is the infimum of `s`: it suffices to check that `b`\nis smaller than all elements of `s`, and that this is not the case of any `w>b`.\nSee `infₛ_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in complete lattices. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Preorder α] → [inst_1 : Preorder β] → α ↪o β → WithTop α ↪o WithTop β",
  "name": "OrderEmbedding.withTopMap",
  "kind": "def",
  "doc_string": "A version of `WithTop.map` for order embeddings. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : NonUnitalNonAssocRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : Add β] →\n          [inst_3 : Mul β] →\n            [inst_4 : Neg β] →\n              [inst_5 : Sub β] →\n                [inst_6 : SMul ℕ β] →\n                  [inst_7 : SMul ℤ β] →\n                    (f : α → β) →\n                      Function.Surjective f →\n                        f 0 = 0 →\n                          (∀ (x y : α), f (x + y) = f x + f y) →\n                            (∀ (x y : α), f (x * y) = f x * f y) →\n                              (∀ (x : α), f (-x) = -f x) →\n                                (∀ (x y : α), f (x - y) = f x - f y) →\n                                  (∀ (x : α) (n : ℕ), f (n • x) = n • f x) →\n                                    (∀ (x : α) (n : ℤ), f (n • x) = n • f x) → NonUnitalNonAssocRing β",
  "name": "Function.Surjective.nonUnitalNonAssocRing",
  "kind": "def",
  "doc_string":
  "Pushforward a `NonUnitalNonAssocRing` instance along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → (α → β → β) → β → List α → β",
  "name": "List.foldr",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. Applies function `f` to all of the elements of the list, from right to left.\n* `foldr f init [a, b, c] = f a <| f b <| f c <| init`\n",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → AddHom M N → AddSubsemigroup N",
  "name": "AddHom.srange",
  "kind": "def",
  "doc_string": "The range of an `AddHom` is an `AddSubsemigroup`.",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → {γ : Sort w} → (α ↪ β) → (γ → α) ↪ γ → β",
  "name": "Function.Embedding.arrowCongrRight",
  "kind": "def",
  "doc_string":
  "An embedding `e : α ↪ β` defines an embedding `(γ → α) ↪ (γ → β)` that sends each `f`\nto `e ∘ f`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Monoid α] → Type u_1",
  "name": "Associates",
  "kind": "def",
  "doc_string":
  "The quotient of a monoid by the `Associated` relation. Two elements `x` and `y`\nare associated iff there is a unit `u` such that `x * u = y`. There is a natural\nmonoid structure on `Associates α`. ",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → [inst : DecidableEq β] → (α → β) → Sort w → α → α → Sort w",
  "name": "noConfusionTypeEnum",
  "kind": "def",
  "doc_string":
  "Auxiliary definition for generating compact `noConfusion` for enumeration types ",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} {inst : NonAssocSemiring α} {inst_1 : NonAssocSemiring β}\n  [self : RingHomClass F α β] (f : F) (x y : α), ↑f (x + y) = ↑f x + ↑f y",
  "name": "RingHomClass.map_add",
  "kind": "def",
  "doc_string": "The proposition that the function preserves addition ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : LinearOrderedCancelCommMonoid M] →\n    {A : Type u_2} →\n      [inst_1 : SetLike A M] → [inst : SubmonoidClass A M] → (S : A) → LinearOrderedCancelCommMonoid { x // x ∈ S }",
  "name": "SubmonoidClass.toLinearOrderedCancelCommMonoid",
  "kind": "def",
  "doc_string":
  "A submonoid of a `LinearOrderedCancelCommMonoid` is a `LinearOrderedCancelCommMonoid`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α → List (List α)",
  "name": "List.permutationsAux",
  "kind": "def",
  "doc_string":
  "An auxiliary function for defining `permutations`. `permutationsAux ts is` is the set of all\npermutations of `is ++ ts` that do not fix `ts`. ",
  "args": ""},
 {"type": "{α : Sort u_1} → α → Trunc α",
  "name": "Trunc.mk",
  "kind": "def",
  "doc_string": "Constructor for `Trunc α` ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} [self : Antisymm r] {a b : α}, r a b → r b a → a = b",
  "name": "Antisymm.antisymm",
  "kind": "def",
  "doc_string":
  "An antisymmetric relation `(·≤·)` satisfies `a ≤ b → b ≤ a → a = b`. ",
  "args": ""},
 {"type": "{α β : Type u} → MProd α β → α",
  "name": "MProd.fst",
  "kind": "def",
  "doc_string":
  "The first projection out of a pair. if `p : MProd α β` then `p.1 : α`. ",
  "args": ""},
 {"type":
  "∀ {E : Sort u_1} {α : Sort u_2} {β : Sort u_3} [self : EquivLike E α β] (e : E),\n  Function.RightInverse (EquivLike.inv e) (EquivLike.coe e)",
  "name": "EquivLike.right_inv",
  "kind": "def",
  "doc_string": "The coercions are right inverses. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → Option β → γ) → List α → List β → Array γ → List γ × List β",
  "name": "List.zipWithLeft'TR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `zipWithLeft'TR`: `zipWithLeft'TR.go l acc = acc.toList ++ zipWithLeft' l`. ",
  "args": ""},
 {"type": "{α : Type u} → Stream' α → Stream' α",
  "name": "Stream'.even",
  "kind": "def",
  "doc_string": "Elements of a stream with even indices. ",
  "args": ""},
 {"type":
  "Bool → List (Lean.TSyntax `term) → ℕ → Lean.MVarId → Lean.MetaM Unit",
  "name": "Mathlib.Tactic.SolveByElim.solveByElimImpl",
  "kind": "def",
  "doc_string":
  "Attempt to solve the given metavariable by repeating applying one of the given expressions,\nor a local hypothesis. ",
  "args": ""},
 {"type":
  "{I : Type u} →\n  {f : I → Type v₁} → [inst : DecidableEq I] → [inst : (i : I) → Zero (f i)] → (i : I) → f i → (j : I) → f j",
  "name": "Pi.single",
  "kind": "def",
  "doc_string":
  "The function supported at `i`, with value `x` there, and `0` elsewhere.",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Thunk α → (α → Thunk β) → Thunk β",
  "name": "Thunk.bind",
  "kind": "def",
  "doc_string":
  "Constructs a thunk that applies `f` to the result of `x` when forced. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.PushNeg.tacticPush_neg__",
  "kind": "def",
  "doc_string":
  "Push negations into the conclusion of a hypothesis.\nFor instance, a hypothesis `h : ¬ ∀ x, ∃ y, x ≤ y` will be transformed by `push_neg at h` into\n`h : ∃ x, ∀ y, y < x`. Variable names are conserved.\nThis tactic pushes negations inside expressions. For instance, given a hypothesis\n```lean\nh : ¬ ∀ ε > 0, ∃ δ > 0, ∀ x, |x - x₀| ≤ δ → |f x - y₀| ≤ ε)\n```\nwriting `push_neg at h` will turn `h` into\n```lean\nh : ∃ ε, ε > 0 ∧ ∀ δ, δ > 0 → (∃ x, |x - x₀| ≤ δ ∧ ε < |f x - y₀|),\n```\n(The pretty printer does *not* use the abreviations `∀ δ > 0` and `∃ ε > 0` but this issue\nhas nothing to do with `push_neg`).\n\nNote that names are conserved by this tactic, contrary to what would happen with `simp`\nusing the relevant lemmas. One can also use this tactic at the goal using `push_neg`,\nat every hypothesis and the goal using `push_neg at *` or at selected hypotheses and the goal\nusing say `push_neg at h h' ⊢` as usual.\n\nThis tactic has two modes: in standard mode, it transforms `¬(p ∧ q)` into `p → ¬q`, whereas in\ndistrib mode it produces `¬p ∨ ¬q`. To use distrib mode, use `set_option push_neg.use_distrib true`.\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "EuclideanDomain",
  "kind": "inductive",
  "doc_string":
  "A `EuclideanDomain` is an non-trivial commutative ring with a division and a remainder,\nsatisfying `b * (a / b) + a % b = a`.\nThe definition of a Euclidean domain usually includes a valuation function `R → ℕ`.\nThis definition is slightly generalised to include a well founded relation\n`r` with the property that `r (a % b) b`, instead of a valuation.  ",
  "args": ""},
 {"type": "{α : Type u} → α → α → α → α → α → α → α → Array α",
  "name": "Array.mkArray7",
  "kind": "def",
  "doc_string": "Create array `#[a₁, a₂, a₃, a₄, a₅, a₆, a₇]` ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "guardHypNums",
  "kind": "def",
  "doc_string":
  "`guard_hyp_nums n` succeeds if there are exactly `n` hypotheses and fails otherwise.\n\nNote that, depending on what options are set, some hypotheses in the local context might\nnot be printed in the goal view. This tactic computes the total number of hypotheses,\nnot the number of visible hypotheses.\n",
  "args": ""},
 {"type": "Bool ≃ PUnit ⊕ PUnit",
  "name": "Equiv.boolEquivPUnitSumPUnit",
  "kind": "def",
  "doc_string": "`Bool` is equivalent the sum of two `PUnit`s. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Monoid α] → [inst_1 : Monoid β] → (α →* β) → ConjClasses α → ConjClasses β",
  "name": "ConjClasses.map",
  "kind": "def",
  "doc_string":
  "A `MonoidHom` maps conjugacy classes of one group to conjugacy classes of another. ",
  "args": ""},
 {"type": "ℕ → Linarith.Linexp → Bool",
  "name": "Linarith.Linexp.contains",
  "kind": "def",
  "doc_string":
  "`l.contains n` is true iff `n` is the first element of a pair in `l`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → (α → Bool) → List α → ℕ",
  "name": "List.countp",
  "kind": "def",
  "doc_string":
  "`countp p l` is the number of elements of `l` that satisfy `p`. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → [inst : AddZeroClass β] → β →+ α → β",
  "name": "Pi.constAddMonoidHom",
  "kind": "def",
  "doc_string": "`Function.const` as an `AddMonoidHom`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} {n : ℕ} (f : α → β) (a : α) (v : Vector α n),\n  Vector.map f (Vector.cons a v) = Vector.cons (f a) (Vector.map f v)",
  "name": "Vector.map_cons",
  "kind": "theorem",
  "doc_string": "`map` is natural with respect to `cons`. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {α : ι → Type u_2} → [inst : (i : ι) → LT (α i)] → (i : ι) × α i → (i : ι) × α i → Prop",
  "name": "Sigma.lt",
  "kind": "inductive",
  "doc_string":
  "Disjoint sum of orders. `⟨i, a⟩ < ⟨j, b⟩` iff `i = j` and `a < b`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "precLead",
  "kind": "def",
  "doc_string":
  "Precedence used for terms not supposed to be used as arguments (`let`, `have`, ...). ",
  "args": ""},
 {"type":
  "∀ {I : Type u} {f : I → Type v} [inst : DecidableEq I] [inst_1 : (i : I) → AddZeroClass (f i)],\n  Pairwise fun i j => ∀ (x : f i) (y : f j), AddCommute (Pi.single i x) (Pi.single j y)",
  "name": "Pi.single_commute",
  "kind": "theorem",
  "doc_string":
  "The injection into an additive pi group at different indices commutes.\n\nFor injections of commuting elements at the same index, see `AddCommute.map`",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → M ≃* N → M →ₙ* N",
  "name": "MulEquiv.toMulHom",
  "kind": "def",
  "doc_string": "The `MulHom` underlying a `MulEquiv`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : PartialOrder α] → [inst_1 : Preorder β] → (f : α → β) → (∀ (a b : α), f a ≤ f b ↔ a ≤ b) → α ↪o β",
  "name": "OrderEmbedding.ofMapLeIff",
  "kind": "def",
  "doc_string":
  "To define an order embedding from a partial order to a preorder it suffices to give a function\ntogether with a proof that it satisfies `f a ≤ f b ↔ a ≤ b`.\n",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : CanonicallyOrderedMonoid α] (x : α), ⊥ ≤ x",
  "name": "CanonicallyOrderedMonoid.bot_le",
  "kind": "def",
  "doc_string": "`⊥` is the least element ",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.Preprocessor",
  "kind": "inductive",
  "doc_string":
  "A preprocessor transforms a proof of a proposition into a proof of a different propositon.\nThe return type is `List Expr`, since some preprocessing steps may create multiple new hypotheses,\nand some may remove a hypothesis from the list.\nA \"no-op\" preprocessor should return its input as a singleton list.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {F : Type u_3} → [inst : Add M] → [inst_1 : Add N] → [inst_2 : AddHomClass F M N] → CoeTC F (AddHom M N)",
  "name": "instCoeTCAddHom",
  "kind": "def",
  "doc_string":
  "Any type satisfying `AddHomClass` can be cast into `AddHom` via\n`AddHomClass.toAddHom`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → (r : Setoid α) → { s // r ≤ s } ≃o Setoid (Quotient r)",
  "name": "Setoid.correspondence",
  "kind": "def",
  "doc_string":
  "Given an equivalence relation `r` on `α`, the order-preserving bijection between the set of\nequivalence relations containing `r` and the equivalence relations on the quotient of `α` by `r`. ",
  "args": ""},
 {"type": "Sort u → Prop",
  "name": "Nonempty",
  "kind": "inductive",
  "doc_string":
  "`Nonempty α` is a typeclass that says that `α` is not an empty type,\nthat is, there exists an element in the type. It differs from `Inhabited α`\nin that `Nonempty α` is a `Prop`, which means that it does not actually carry\nan element of `α`, only a proof that *there exists* such an element.\nGiven `Nonempty α`, you can construct an element of `α` *nonconstructively*\nusing `Classical.choice`.\n",
  "args": ""},
 {"type": "{α : Type u} → [inst : AddMonoid α] → Inhabited (AddUnits α)",
  "name": "AddUnits.instInhabitedAddUnits",
  "kind": "def",
  "doc_string":
  "Additive units of an additive monoid are inhabited because `0` is an additive unit.",
  "args": ""},
 {"type":
  "∀ {M : Type u} [self : Monoid M] (n : ℕ) (x : M), Monoid.npow (n + 1) x = x * Monoid.npow n x",
  "name": "Monoid.npow_succ",
  "kind": "def",
  "doc_string": "Raising to the power `(n + 1 : ℕ)` behaves as expected. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → (β : Type u_2) → (Option α ↪ β) ≃ (f : α ↪ β) × ↑(Set.range ↑fᶜ)",
  "name": "Function.Embedding.optionEmbeddingEquiv",
  "kind": "def",
  "doc_string":
  "Equivalence between embeddings of `Option α` and a sigma type over the embeddings of `α`. ",
  "args": ""},
 {"type": "Lean.NameMapExtension (List ℕ)",
  "name": "ToAdditive.reorderAttr",
  "kind": "opaque",
  "doc_string":
  "An attribute that stores all the declarations that needs their arguments reordered when\napplying `@[to_additive]`. Currently, we only support swapping consecutive arguments.\nThe list of the natural numbers contains the positions of the first of the two arguments\nto be swapped.\nIf the first two arguments are swapped, the first two universe variables are also swapped.\nExample: `@[to_additive_reorder 1 4]` swaps the first two arguments and the arguments in\npositions 4 and 5.\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_^^^_»",
  "kind": "def",
  "doc_string":
  "`a ^^^ b` computes the bitwise XOR of `a` and `b`.\nThe meaning of this notation is type-dependent. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  {D : Type u₂} →\n    [inst : CategoryTheory.Category C] →\n      [inst_1 : CategoryTheory.Category D] → (F : C ⥤ D) → C ⥤ CategoryTheory.Functor.EssImageSubcategory F",
  "name": "CategoryTheory.Functor.toEssImage",
  "kind": "def",
  "doc_string":
  "Given a functor `F : C ⥤ D`, we have an (essentially surjective) functor from `C` to the essential\nimage of `F`.\n",
  "args": ""},
 {"type":
  "Type u_1 →\n  (A : outParam (Type u_2)) → (B : outParam (Type u_3)) → [inst : Mul A] → [inst : Mul B] → Type (max (max u_1 u_2) u_3)",
  "name": "MulEquivClass",
  "kind": "inductive",
  "doc_string":
  "`MulEquivClass F A B` states that `F` is a type of multiplication-preserving morphisms.\nYou should extend this class when you extend `MulEquiv`. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : One M₁] →\n        [inst_2 : Pow M₁ ℕ] →\n          [inst_3 : Inv M₁] →\n            [inst_4 : Div M₁] →\n              [inst_5 : Pow M₁ ℤ] →\n                [inst_6 : DivisionMonoid M₂] →\n                  (f : M₁ → M₂) →\n                    Function.Injective f →\n                      f 1 = 1 →\n                        (∀ (x y : M₁), f (x * y) = f x * f y) →\n                          (∀ (x : M₁), f x⁻¹ = (f x)⁻¹) →\n                            (∀ (x y : M₁), f (x / y) = f x / f y) →\n                              (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                (∀ (x : M₁) (n : ℤ), f (x ^ n) = f x ^ n) → DivisionMonoid M₁",
  "name": "Function.Injective.divisionMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `1`, `*`, `⁻¹`, and `/` is a `DivisionMonoid` if it admits an injective map\nthat preserves `1`, `*`, `⁻¹`, and `/` to a `DivisionMonoid`. See note [reducible non-instances] ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : LE α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → α → α",
  "name": "maxDefault",
  "kind": "def",
  "doc_string": "Default definition of `max`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [inst_3 : OrderedSub α]\n  {a b c : α} [inst_4 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], a + c < b → c < b - a",
  "name": "lt_tsub_of_add_lt_left",
  "kind": "theorem",
  "doc_string":
  "This lemma (and some of its corollaries) also holds for `ENNReal`, but this proof doesn't work\nfor it. Maybe we should add this lemma as field to `OrderedSub`? ",
  "args": ""},
 {"type": "∀ (self : ℚ), Nat.coprime (Int.natAbs self.num) self.den",
  "name": "Rat.reduced",
  "kind": "def",
  "doc_string":
  "The numerator and denominator are coprime: it is in \"reduced form\". ",
  "args": ""},
 {"type":
  "{P : ℕ → Sort u_1} → {m n : ℕ} → ((k : ℕ) → k < n → m ≤ k → P (k + 1) → P k) → m ≤ n → P n → P m",
  "name": "Nat.decreasingInduction'",
  "kind": "def",
  "doc_string":
  "Decreasing induction: if `P (k+1)` implies `P k` for all `m ≤ k < n`, then `P n` implies `P m`.\nAlso works for functions to `Sort*`. Weakens the assumptions of `decreasing_induction`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : LT α] → Prop",
  "name": "NoMaxOrder",
  "kind": "inductive",
  "doc_string": "Order without maximal elements. Sometimes called cofinal. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : AddGroupWithOne α] → ℤ →+ α",
  "name": "Int.castAddHom",
  "kind": "def",
  "doc_string": "`coe : ℤ → α` as an `AddMonoidHom`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r : α → α → Prop},\n  WellFounded r → ∀ (s : Set α), Set.Nonempty s → ∃ a, a ∈ s ∧ ∀ (x : α), x ∈ s → ¬r x a",
  "name": "WellFounded.has_min",
  "kind": "theorem",
  "doc_string":
  "If `r` is a well-founded relation, then any nonempty set has a minimal element\nwith respect to `r`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {C : Trunc α → Sort u_2} →\n    (f : (a : α) → C (Trunc.mk a)) → (∀ (a b : α), (_ : Trunc.mk a = Trunc.mk b) ▸ f a = f b) → (q : Trunc α) → C q",
  "name": "Trunc.rec",
  "kind": "def",
  "doc_string": "Recursion/induction principle for `Trunc`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HMod α β γ] → α → β → γ",
  "name": "HMod.hMod",
  "kind": "def",
  "doc_string":
  "`a % b` computes the remainder upon dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For `Nat` and `Int`, `a % 0` is defined to be `a`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} →\n      {Q : Type u_4} →\n        [inst : MulOneClass M] →\n          [inst_1 : MulOneClass N] →\n            [inst_2 : CommMonoid P] → [inst_3 : CommMonoid Q] → M ≃* N → P ≃* Q → (M →* P) ≃* (N →* Q)",
  "name": "MulEquiv.monoidHomCongr",
  "kind": "def",
  "doc_string":
  "A multiplicative analogue of `Equiv.arrowCongr`,\nfor multiplicative maps from a monoid to a commutative monoid.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {C : WithBot α → Sort u_2} → C ⊥ → ((a : α) → C ↑a) → (n : WithBot α) → C n",
  "name": "WithBot.recBotCoe",
  "kind": "def",
  "doc_string":
  "Recursor for `WithBot` using the preferred forms `⊥` and `↑a`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {a : α} (b : α) {as : List α}, List.Mem a as → List.Mem a (b :: as)",
  "name": "List.Mem.tail",
  "kind": "def",
  "doc_string":
  "A member of the tail of a list is a member of the list: `a ∈ l → a ∈ b :: l`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddZeroClass M] → (S : AddSubmonoid M) → AddZeroClass { x // x ∈ S }",
  "name": "AddSubmonoid.toAddZeroClass",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of an unital additive magma inherits an unital additive magma structure.",
  "args": ""},
 {"type": "(ℕ → Bool) → ℕ × ℕ → Bool",
  "name": "Prod.anyI",
  "kind": "def",
  "doc_string":
  "`(start, stop).anyI f a` returns true if `f` is true for some natural number\nfrom `start` (inclusive) to `stop` (exclusive):\n* `(5, 8).anyI f = f 5 || f 6 || f 7`\n",
  "args": ""},
 {"type":
  "∀ {I : Type u} {f : I → Type v} {α : Type u_1} [inst : (i : I) → VAdd α (f i)] [inst_1 : ∀ (i : I), Nonempty (f i)]\n  (i : I) [inst_2 : FaithfulVAdd α (f i)], FaithfulVAdd α ((i : I) → f i)",
  "name": "Pi.faithfulVAdd_at",
  "kind": "theorem",
  "doc_string":
  "If `f i` has a faithful additive action for a given `i`, then\nso does `Π i, f i`. This is not an instance as `i` cannot be inferred",
  "args": ""},
 {"type": "∀ {M : Type u} [self : CancelCommMonoid M] (a b : M), a * b = b * a",
  "name": "CancelCommMonoid.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        (S : AddSubmonoid M) →\n          (f : M →+ N) → Function.Injective ↑f → { x // x ∈ S } ≃+ { x // x ∈ AddSubmonoid.map f S }",
  "name": "AddSubmonoid.equivMapOfInjective",
  "kind": "def",
  "doc_string":
  "An additive submonoid is isomorphic to its image under an injective function",
  "args": ""},
 {"type":
  "{f : Type → Type} → [inst : Monad f] → {α : Type} → (α → f Bool) → List α → f (List α × List α)",
  "name": "List.partitionM",
  "kind": "def",
  "doc_string":
  "A generalization of `List.partition` which partitions the list according to a monadic\npredicate. `List.partition` corresponds to the case where `f = Id`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Abel.abel",
  "kind": "def",
  "doc_string":
  "Tactic for evaluating expressions in abelian groups.\n\n* `abel!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `abel1` fails if the target is not an equality.\n\nFor example:\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : LinearOrder β] → (f : α → β) → Function.Injective f → LinearOrder α",
  "name": "LinearOrder.lift'",
  "kind": "def",
  "doc_string":
  "Transfer a `LinearOrder` on `β` to a `LinearOrder` on `α` using an injective\nfunction `f : α → β`. This version autogenerates `min` and `max` fields. See `LinearOrder.lift`\nfor a version that takes `[HasSup α]` and `[HasInf α]`, then uses them as `max` and `min`.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : SemilatticeInf α] [inst_1 : OrderBot α] [inst_2 : SemilatticeInf β]\n  [inst_3 : OrderBot β] {a b : α} (f : α ≃o β),\n  Disjoint a b → Disjoint (↑(RelIso.toRelEmbedding f).toEmbedding a) (↑(RelIso.toRelEmbedding f).toEmbedding b)",
  "name": "Disjoint.map_orderIso",
  "kind": "theorem",
  "doc_string":
  "Note that this goal could also be stated `(Disjoint on f) a b` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α] (k : α), (∀ (x : α), x * k = 0 → x = 0) → IsRightRegular k",
  "name": "isRightRegular_of_non_zero_divisor",
  "kind": "theorem",
  "doc_string":
  "Right `Mul` by a `k : α` over `[Ring α]` is injective, if `k` is not a zero divisor.\nThe typeclass that restricts all terms of `α` to have this property is `NoZeroDivisors`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, -a < 0 ↔ 0 < a",
  "name": "Right.neg_neg_iff",
  "kind": "theorem",
  "doc_string": "Uses `right` co(ntra)variant.",
  "args": ""},
 {"type": "{α : Type u} → [inst : Preorder α] → Set α → Prop",
  "name": "BddBelow",
  "kind": "def",
  "doc_string": "A set is bounded below if there exists a lower bound. ",
  "args": ""},
 {"type":
  "(C : Type u₁) →\n  [inst : CategoryTheory.Category C] → (D : Type u₂) → [inst : CategoryTheory.Category D] → Type (max v₁ v₂ u₁ u₂)",
  "name": "CategoryTheory.Functor",
  "kind": "inductive",
  "doc_string":
  "`Functor C D` represents a functor between categories `C` and `D`.\n\nTo apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.\n\nThe axiom `map_id` expresses preservation of identities, and\n`map_comp` expresses functoriality.\n\nSee <https://stacks.math.columbia.edu/tag/001B>.\n",
  "args": ""},
 {"type": "∀ (G : Type u) [inst : LeftCancelSemigroup G], IsLeftCancelMul G",
  "name": "LeftCancelSemigroup.toIsLeftCancelMul",
  "kind": "def",
  "doc_string": "Any `LeftCancelSemigroup` satisfies `IsLeftCancelMul`. ",
  "args": ""},
 {"type": "∀ {n m : ℕ}, n * m = 0 → n = 0 ∨ m = 0",
  "name": "Int.eq_zero_or_eq_zero_of_mul_eq_zero",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `Nat.mul_eq_zero`.",
  "args": ""},
 {"type": "{α : Type u} → α × List α × α × List α → α × List α × α × List α",
  "name": "Stream'.cycleG",
  "kind": "def",
  "doc_string": "An auxiliary definition for `Stream'.cycle` corecursive def ",
  "args": ""},
 {"type":
  "{e : Q(ℕ)} → (self : Mathlib.Tactic.Ring.ExtractCoeff e) → Mathlib.Tactic.Ring.ExProd Mathlib.Tactic.Ring.sℕ self.e'",
  "name": "Mathlib.Tactic.Ring.ExtractCoeff.ve'",
  "kind": "def",
  "doc_string": "`e'` is a monomial. ",
  "args": ""},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α : Type u} → Option (m α) → m (Option α)",
  "name": "Option.maybe",
  "kind": "def",
  "doc_string":
  "If you maybe have a monadic computation in a `[Monad m]` which produces a term of type `α`,\nthen there is a naturally associated way to always perform a computation in `m` which maybe\nproduces a result. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : PredOrder α] {a : α}, ¬Order.IsPredLimit a → a ∈ Set.range Order.pred",
  "name": "Order.mem_range_pred_of_not_isPredLimit",
  "kind": "theorem",
  "doc_string":
  "See `not_isPredLimit_iff` for a version that states that `a` is a successor of a value other\nthan itself. ",
  "args": ""},
 {"type":
  "{p : Bool → Prop} → [inst : (b : Bool) → Decidable (p b)] → Decidable (∀ (b : Bool), p b)",
  "name": "Bool.decidableForallBool",
  "kind": "def",
  "doc_string":
  "If `p b` is decidable for all `b : bool`, then `∀ b, p b` is decidable ",
  "args": ""},
 {"type":
  "∀ {G₀ : Type u_1} [self : CommGroupWithZero G₀] (a : G₀), a ≠ 0 → a * a⁻¹ = 1",
  "name": "CommGroupWithZero.mul_inv_cancel",
  "kind": "def",
  "doc_string": "Every nonzero element of a group with zero is invertible. ",
  "args": ""},
 {"type": "Linarith.PComp → Linarith.CompSource",
  "name": "Linarith.PComp.src",
  "kind": "def",
  "doc_string":
  "We track how the comparison was constructed by adding and scaling previous comparisons,\nback to the original assumptions. ",
  "args": ""},
 {"type": "∀ {a b : ℤ}, a ∣ b → Int.natAbs b < Int.natAbs a → b = 0",
  "name": "Int.eq_zero_of_dvd_of_natAbs_lt_natAbs",
  "kind": "theorem",
  "doc_string":
  "If an integer with larger absolute value divides an integer, it is\nzero. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "ShiftLeft",
  "kind": "inductive",
  "doc_string":
  "The homogeneous version of `HShiftLeft`: `a <<< b : α` where `a b : α`. ",
  "args": ""},
 {"type": "(M₀ : Type u_1) → [inst : Mul M₀] → [inst : Zero M₀] → Prop",
  "name": "NoZeroDivisors",
  "kind": "inductive",
  "doc_string":
  "Predicate typeclass for expressing that `a * b = 0` implies `a = 0` or `b = 0`\nfor all `a` and `b` of type `G₀`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → β) → (α → α) → (β → β) → Prop",
  "name": "Function.Semiconj",
  "kind": "def",
  "doc_string":
  "We say that `f : α → β` semiconjugates `ga : α → α` to `gb : β → β` if `f ∘ ga = gb ∘ f`.\nWe use `∀ x, f (ga x) = gb (f x)` as the definition, so given `h : Function.Semiconj f ga gb` and\n`a : α`, we have `h a : f (ga a) = gb (f a)` and `h.comp_eq : f ∘ ga = gb ∘ f`.\n",
  "args": ""},
 {"type": "∀ {M : Type u} [self : AddLeftCancelMonoid M] (a : M), a + 0 = a",
  "name": "AddLeftCancelMonoid.add_zero",
  "kind": "def",
  "doc_string": "Zero is a right neutral element for addition ",
  "args": ""},
 {"type":
  "∀ {F : Sort u_1} {α : Sort u_2} {β : Sort u_3} [self : EmbeddingLike F α β] (f : F), Function.Injective ↑f",
  "name": "EmbeddingLike.injective'",
  "kind": "def",
  "doc_string": "The coercion to functions must produce injective functions. ",
  "args": ""},
 {"type":
  "{X : Type u} →\n  {m₁ : X → X → X} →\n    {e₁ : X} →\n      EckmannHilton.IsUnital m₁ e₁ →\n        [h : MulOneClass X] → (∀ (a b c d : X), m₁ (a * b) (c * d) = m₁ a c * m₁ b d) → CommMonoid X",
  "name": "EckmannHilton.commMonoid",
  "kind": "def",
  "doc_string":
  "If a type carries a unital magma structure that distributes over a unital binary\noperation, then the magma structure is a commutative monoid. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Monoid R] {a b : R}, a * b = 1 → IsRightRegular a",
  "name": "isRightRegular_of_mul_eq_one",
  "kind": "theorem",
  "doc_string": "An element admitting a right inverse is right-regular. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : One M₁] →\n        [inst_2 : Pow M₁ ℕ] →\n          [inst_3 : Inv M₁] →\n            [inst_4 : Div M₁] →\n              [inst_5 : Pow M₁ ℤ] →\n                [inst_6 : DivisionCommMonoid M₂] →\n                  (f : M₁ → M₂) →\n                    Function.Injective f →\n                      f 1 = 1 →\n                        (∀ (x y : M₁), f (x * y) = f x * f y) →\n                          (∀ (x : M₁), f x⁻¹ = (f x)⁻¹) →\n                            (∀ (x y : M₁), f (x / y) = f x / f y) →\n                              (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                (∀ (x : M₁) (n : ℤ), f (x ^ n) = f x ^ n) → DivisionCommMonoid M₁",
  "name": "Function.Injective.divisionCommMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `1`, `*`, `⁻¹`, and `/` is a `DivisionCommMonoid` if it admits an\ninjective map that preserves `1`, `*`, `⁻¹`, and `/` to a `DivisionCommMonoid`.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s t : Set α},\n  AntitoneOn f t → s ⊆ t → Set.Nonempty (upperBounds s ∩ t) → BddBelow (f '' s)",
  "name": "AntitoneOn.map_bddAbove",
  "kind": "theorem",
  "doc_string":
  "The image under an antitone function of a set which is bounded above is bounded below. ",
  "args": ""},
 {"type": "(ℕ → Bool) → ℕ → Bool",
  "name": "Nat.allTR",
  "kind": "def",
  "doc_string": "Tail-recursive version of `Nat.all`. ",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ → Prop",
  "name": "Nat.ModEq",
  "kind": "def",
  "doc_string":
  "Modular equality. `n.ModEq a b`, or `a ≡ b [MOD n]`, means that `a - b` is a multiple of `n`. ",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HDiv",
  "kind": "inductive",
  "doc_string":
  "The notation typeclass for heterogeneous division.\nThis enables the notation `a / b : γ` where `a : α`, `b : β`.\n",
  "args": ""},
 {"type": "{ε : Type u} → {α : Type v} → ε → Except ε α",
  "name": "Except.error",
  "kind": "def",
  "doc_string": "A failure value of type `ε` ",
  "args": ""},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "name": "PSum",
  "kind": "inductive",
  "doc_string":
  "`PSum α β`, or `α ⊕' β`, is the disjoint union of types `α` and `β`.\nIt differs from `α ⊕ β` in that it allows `α` and `β` to have arbitrary sorts\n`Sort u` and `Sort v`, instead of restricting to `Type u` and `Type v`. This means\nthat it can be used in situations where one side is a proposition, like `True ⊕' Nat`.\n\nThe reason this is not the default is that this type lives in the universe `Sort (max 1 u v)`,\nwhich can cause problems for universe level unification,\nbecause the equation `max 1 u v = ?u + 1` has no solution in level arithmetic.\n`PSum` is usually only used in automation that constructs sums of arbitrary types.\n",
  "args": ""},
 {"type": "{α : Type u_1} → [self : Abs α] → α → α",
  "name": "Abs.abs",
  "kind": "def",
  "doc_string": "The absolute value function. ",
  "args": ""},
 {"type": "Substring → String.Pos → String.Pos",
  "name": "Substring.prev",
  "kind": "def",
  "doc_string":
  "Given an offset of a codepoint into the substring,\nreturn the offset there of the previous codepoint. ",
  "args": ""},
 {"type": "∀ {R : Type u_1} [inst : CancelMonoid R] (g : R), IsRegular g",
  "name": "isRegular_of_cancelMonoid",
  "kind": "theorem",
  "doc_string":
  "Elements of a cancel monoid are regular.  Cancel semigroups do not appear to exist. ",
  "args": ""},
 {"type":
  "{I : Type u} → (f : I → Type v) → [inst : (i : I) → MulOneClass (f i)] → (i : I) → ((i : I) → f i) →* f i",
  "name": "Pi.evalMonoidHom",
  "kind": "def",
  "doc_string":
  "Evaluation of functions into an indexed collection of monoids at a point is a monoid\nhomomorphism.\nThis is `Function.eval i` as a `MonoidHom`. ",
  "args": ""},
 {"type": "SlimCheck.Configuration",
  "name": "SlimCheck.Configuration.verbose",
  "kind": "def",
  "doc_string":
  "A configuration with all the trace options enabled, useful for debugging. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : AddRightCancelSemigroup α] → α → ComplexShape α",
  "name": "ComplexShape.up'",
  "kind": "def",
  "doc_string":
  "The `ComplexShape` allowing differentials from `X i` to `X (i+a)`.\n(For example when `a = 1`, a cohomology theory indexed by `ℕ` or `ℤ`)\n",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Set.«⋃_,_»",
  "kind": "def",
  "doc_string": "Notation for `Set.unionᵢ`. Indexed union of a family of sets ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : CommMonoid α] → α →* Associates α",
  "name": "Associates.mkMonoidHom",
  "kind": "def",
  "doc_string": "`Associates.mk` as a `MonoidHom`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Parser.Attr.mfld_simps",
  "kind": "def",
  "doc_string":
  "The simpset `mfld_simps` records several simp lemmas that are\nespecially useful in manifolds. It is a subset of the whole set of simp lemmas, but it makes it\npossible to have quicker proofs (when used with `squeeze_simp` or `simp only`) while retaining\nreadability.\n\nThe typical use case is the following, in a file on manifolds:\nIf `simp [foo, bar]` is slow, replace it with `squeeze_simp [foo, bar, mfld_simps]` and paste\nits output. The list of lemmas should be reasonable (contrary to the output of\n`squeeze_simp [foo, bar]` which might contain tens of lemmas), and the outcome should be quick\nenough.\n",
  "args": ""},
 {"type":
  "(α : Type u_1) → {β : Type u_2} → [inst : One β] → Function.Surjective 1 → Unique β",
  "name": "uniqueOfSurjectiveOne",
  "kind": "def",
  "doc_string": "If the one function is surjective, the codomain is trivial. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteLattice α] (s : Set α) (a : α), (∀ (b : α), b ∈ s → b ≤ a) → supₛ s ≤ a",
  "name": "CompleteLattice.supₛ_le",
  "kind": "def",
  "doc_string": "Any upper bound is more than the set supremum. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] {a b : α}, b < a → ↑OrderDual.toDual a < ↑OrderDual.toDual b",
  "name": "LT.lt.dual",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the reverse direction of `OrderDual.toDual_lt_toDual`.",
  "args": ""},
 {"type":
  "∀ {K : Type u_1} [inst : DivisionRing K] {a b : K}, a ≠ 0 → b ≠ 0 → a⁻¹ - b⁻¹ = a⁻¹ * (b - a) * b⁻¹",
  "name": "inv_sub_inv'",
  "kind": "theorem",
  "doc_string":
  "See `inv_sub_inv` for the more convenient version when `K` is commutative. ",
  "args": ""},
 {"type": "{α : Type u} → [self : Union α] → α → α → α",
  "name": "Union.union",
  "kind": "def",
  "doc_string": "`a ∪ b` is the union of`a` and `b`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Lattice α] [self : IsWeakLowerModularLattice α] {a b : α}, a ⋖ a ⊔ b → b ⋖ a ⊔ b → a ⊓ b ⋖ a",
  "name": "IsWeakLowerModularLattice.inf_covby_of_covby_covby_sup",
  "kind": "def",
  "doc_string": "`a` and `b` cover `a ⊓ b` if `a ⊔ b` covers both `a` and `b` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {r : α → α → Prop} → WellFounded r → (s : Set α) → Set.Nonempty s → α",
  "name": "WellFounded.min",
  "kind": "def",
  "doc_string":
  "A minimal element of a nonempty set in a well-founded order.\n\nIf you're working with a nonempty linear order, consider defining a\n`ConditionallyCompleteLinearOrderBot` instance via\n`WellFounded.conditionallyCompleteLinearOrderWithBot` and using `Inf` instead. ",
  "args": ""},
 {"type": "ℕ → ℕ → Option ℕ",
  "name": "Nat.psub'",
  "kind": "def",
  "doc_string": "Same as `psub`, but with a more efficient implementation. ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsEquiv",
  "kind": "inductive",
  "doc_string":
  "`IsEquiv X r` means that the binary relation `r` on `X` is an equivalence relation, that\nis, `IsPreorder X r` and `IsSymm X r`. ",
  "args": ""},
 {"type":
  "∀ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R × S)] [inst : Nontrivial R]\n  [inst : Nontrivial S], False",
  "name": "false_of_nontrivial_of_product_domain",
  "kind": "theorem",
  "doc_string": "The product of two nontrivial rings is not a domain ",
  "args": ""},
 {"type": "{A : Type u_1} → {B : Type u_2} → [self : SetLike A B] → A → Set B",
  "name": "SetLike.coe",
  "kind": "def",
  "doc_string":
  "The coercion from a term of a `SetLike` to its corresponding `Set`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : AddSemigroup α] →\n    [inst_1 : PartialOrder α] →\n      [inst : ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] →\n        AddRightCancelSemigroup α",
  "name": "Contravariant.toAddRightCancelSemigroup",
  "kind": "def",
  "doc_string":
  "An additive semigroup with a partial order and satisfying `AddRightCancelSemigroup`\n(`a + c < b + c → a < b`) is a `right_cancel AddSemigroup`.",
  "args": ""},
 {"type":
  "{α : Type u} → {G : Type u_1} → [inst : Group G] → (G →* Function.End α) → G →* Equiv.Perm α",
  "name": "MonoidHom.toHomPerm",
  "kind": "def",
  "doc_string":
  "Lift a monoid homomorphism `f : G →* function.End α` to a monoid homomorphism\n`f : G →* equiv.perm α`. ",
  "args": ""},
 {"type": "{α : Type u} → Membership α (Stream' α)",
  "name": "Stream'.instMembershipStream'",
  "kind": "def",
  "doc_string": "`a ∈ s` means that `a = Stream'.nth n s` for some `n`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] {f g : R ≃+* S},\n  (∀ (x : R), ↑f x = ↑g x) → f = g",
  "name": "RingEquiv.ext",
  "kind": "theorem",
  "doc_string":
  "Two ring isomorphisms agree if they are defined by the\nsame underlying function. ",
  "args": ""},
 {"type":
  "{F : Type u → Type v} → [inst : Applicative F] → {α : Type u_1} → {β : Type u} → (α → F β) → Option α → F (Option β)",
  "name": "Option.traverse",
  "kind": "def",
  "doc_string":
  "Traverse an object of `Option α` with a function `f : α → F β` for an applicative `F`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1],\n  StrictMono f → StrictMono g → StrictMono fun x => f x + g x",
  "name": "StrictMono.add",
  "kind": "theorem",
  "doc_string":
  "The sum of two strictly monotone functions is strictly monotone.",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} →\n  {α : Type u_3} → {β : Type u_1} → [inst : Monad m] → (α → α → m β) → List α → Array β → m (List β)",
  "name": "List.mapDiagM.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `mapDiagM`: `mapDiagM.go as f acc = (acc.toList ++ ·) <$> mapDiagM f as` ",
  "args": ""},
 {"type":
  "∀ {ι : Type u} (β : ι → Type v) [I : Nonempty ι], ∃ i, Nonempty ((j : ι) → β i ↪ β j)",
  "name": "Function.Embedding.min_injective",
  "kind": "theorem",
  "doc_string":
  "The cardinals are well-ordered. We express it here by the fact that in any set of cardinals\nthere is an element that injects into the others. \nSee `Cardinal.conditionallyCompleteLinearOrderBot` for (one of) the lattice instances. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α),\n  Set.InvOn f g (Function.fixedPoints (f ∘ g)) (Function.fixedPoints (g ∘ f))",
  "name": "Function.invOn_fixedPoints_comp",
  "kind": "theorem",
  "doc_string":
  "Any two maps `f : α → β` and `g : β → α` are inverse of each other on the sets of fixed points\nof `f ∘ g` and `g ∘ f`, respectively. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (f : α → β) → (s : Set α) → (t : Set β) → Set.MapsTo f s t → ↑s → ↑t",
  "name": "Set.MapsTo.restrict",
  "kind": "def",
  "doc_string":
  "Given a map `f` sending `s : Set α` into `t : Set β`, restrict domain of `f` to `s`\nand the codomain to `t`. Same as `Subtype.map`. ",
  "args": ""},
 {"type": "{α : Type} → (xs : List α) → SlimCheck.Gen { ys // ys ~ xs }",
  "name": "SlimCheck.Gen.permutationOf",
  "kind": "def",
  "doc_string": "Generate a random permutation of a given list. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {α : Type u_2} → {β : Type u_3} → [inst : Preorder α] → [inst : Preorder β] → (ι → α) → (ι → β) → Prop",
  "name": "Monovary",
  "kind": "def",
  "doc_string": "`f` monovaries with `g` if `g i < g j` implies `f i ≤ f j`. ",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsOrderConnected",
  "kind": "inductive",
  "doc_string":
  "A connected order is one satisfying the condition `a < c → a < b ∨ b < c`.\nThis is recognizable as an intuitionistic substitute for `a ≤ b ∨ b ≤ a` on\nthe constructive reals, and is also known as negative transitivity,\nsince the contrapositive asserts transitivity of the relation `¬ a < b`.  ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : α → Type u_2} → (a : α) → β a ↪ (x : α) × β x",
  "name": "Function.Embedding.sigmaMk",
  "kind": "def",
  "doc_string": "`Sigma.mk` as an `Function.Embedding`. ",
  "args": ""},
 {"type": "∀ {α : Type u} [self : OrderedRing α], 0 ≤ 1",
  "name": "OrderedRing.zero_le_one",
  "kind": "def",
  "doc_string": "`0 ≤ 1` in any ordered ring. ",
  "args": ""},
 {"type": "Linarith.Preprocessor",
  "name": "Linarith.removeNegations",
  "kind": "def",
  "doc_string":
  "Replaces proofs of negations of comparisons with proofs of the reversed comparisons.\nFor example, a proof of `¬ a < b` will become a proof of `a ≥ b`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b < c → a < c",
  "name": "LT.lt.trans",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_trans`.",
  "args": ""},
 {"type":
  "∀ {K : Type u} [self : DivisionRing K] (a : ℚ) (x : K), DivisionRing.qsmul a x = ↑a * x",
  "name": "DivisionRing.qsmul_eq_mul'",
  "kind": "def",
  "doc_string":
  "However `qsmul` is defined,\npropositionally it must be equal to multiplication by `ratCast`. ",
  "args": ""},
 {"type":
  "{R : Type u} → [inst : EuclideanDomain R] → [inst : DecidableEq R] → R → R → R × R",
  "name": "EuclideanDomain.xgcd",
  "kind": "def",
  "doc_string":
  "Use the extended GCD algorithm to generate the `a` and `b` values\nsatisfying `gcd x y = x * a + y * b`. ",
  "args": ""},
 {"type":
  "{p : Sort u_1} →\n  {n : ℕ} →\n    {a : ℤ} →\n      (b : ℕ) →\n        (a ≡ OfNat.ofNat b [ZMOD OfNat.ofNat n] → p) →\n          Mathlib.Tactic.ModCases.OnModCases n a (Nat.add b 1) p → Mathlib.Tactic.ModCases.OnModCases n a b p",
  "name": "Mathlib.Tactic.ModCases.onModCases_succ",
  "kind": "def",
  "doc_string":
  "The successor case decomposes `∃ z, b ≤ z < n ∧ a ≡ z (mod n)` into\n`a ≡ b (mod n) ∨ ∃ z, b+1 ≤ z < n ∧ a ≡ z (mod n)`,\nand the `a ≡ b (mod n) → p` case becomes a subgoal.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Semigroup α] →\n    [inst_1 : PartialOrder α] →\n      [inst : ContravariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] → RightCancelSemigroup α",
  "name": "Contravariant.toRightCancelSemigroup",
  "kind": "def",
  "doc_string":
  "A semigroup with a partial order and satisfying `RightCancelSemigroup`\n(i.e. `a * c < b * c → a < b`) is a `right_cancel Semigroup`. ",
  "args": ""},
 {"type": "{α : Type u_1} → (l : List α) → List { x // x ∈ l }",
  "name": "List.attach",
  "kind": "def",
  "doc_string":
  "\"Attach\" the proof that the elements of `l` are in `l` to produce a new list\nwith the same elements but in the type `{x // x ∈ l}`. ",
  "args": ""},
 {"type": "{α : Sort u} → {β : α → Sort v} → (fst : α) → β fst → PSigma β",
  "name": "PSigma.mk",
  "kind": "def",
  "doc_string":
  "Constructor for a dependent pair. If `a : α` and `b : β a` then `⟨a, b⟩ : PSigma β`.\n(This will usually require a type ascription to determine `β`\nsince it is not determined from `a` and `b` alone.) ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] ⦃s t : Set α⦄, s ⊆ t → BddAbove t → BddAbove s",
  "name": "BddAbove.mono",
  "kind": "theorem",
  "doc_string": "If `s ⊆ t` and `t` is bounded above, then so is `s`. ",
  "args": ""},
 {"type":
  "∀ {v : Sat.Valuation} {a : Prop} {n : ℕ}, (v n ↔ a) → Sat.Literal.reify v (Sat.Literal.neg n) a",
  "name": "Sat.Literal.reify_neg",
  "kind": "theorem",
  "doc_string": "The reification of a negative literal `¬⟦¬a⟧_v ≡ a`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Mul α] → SMul α α",
  "name": "Mul.toSMul",
  "kind": "def",
  "doc_string":
  "See also `Monoid.toMulAction` and `MulZeroClass.toSMulWithZero`. ",
  "args": ""},
 {"type":
  "∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} (self : X ≅ Y), self.inv ≫ self.hom = 𝟙 Y",
  "name": "CategoryTheory.Iso.inv_hom_id",
  "kind": "def",
  "doc_string":
  "Composition of the two directions of an isomorphism in reverse order\nis the identity on the target. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "DivisionCommMonoid",
  "kind": "inductive",
  "doc_string":
  "Commutative `DivisionMonoid`.\n\nThis is the immediate common ancestor of `CommGroup` and `CommGroupWithZero`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : SubtractionCommMonoid α] → α × α →+ α",
  "name": "subAddMonoidHom",
  "kind": "def",
  "doc_string": "Subtraction as an additive monoid homomorphism.",
  "args": ""},
 {"type":
  "(α : Sort u_1) → (β : Sort u_2) → [inst : IsEmpty α] → [inst : IsEmpty β] → α ≃ β",
  "name": "Equiv.equivOfIsEmpty",
  "kind": "def",
  "doc_string": "Two empty types are equivalent. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → (α : Type u_3) → [inst : VAdd M α] → [inst : VAdd N α] → Prop",
  "name": "VAddCommClass",
  "kind": "inductive",
  "doc_string":
  "A typeclass mixin saying that two additive actions on the same space commute. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Linarith.rearrangeComparison.aux",
  "kind": "opaque",
  "doc_string":
  "Implementation of `rearrangeComparison`, after type inference. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddCommSemigroup R] {a b : R}, IsAddRegular (a + b) ↔ IsAddRegular a ∧ IsAddRegular b",
  "name": "isAddRegular_add_iff",
  "kind": "theorem",
  "doc_string": "A sum is add-regular if and only if the summands are.",
  "args": ""},
 {"type": "{α : Type u} → [self : Complement α] → α → α",
  "name": "Complement.complement",
  "kind": "def",
  "doc_string": "The implementation of `~~~a : α`. ",
  "args": ""},
 {"type":
  "Mathlib.Tactic.Abel.Context → Lean.Expr → Lean.MetaM (Mathlib.Tactic.Abel.NormalExpr × Lean.Expr)",
  "name": "Mathlib.Tactic.Abel.eval",
  "kind": "opaque",
  "doc_string":
  "Evaluate an expression into its `abel` normal form, by recursing into subexpressions. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : LinearOrderedCommRing R] (a b : R), 2 * a * b ≤ a ^ 2 + b ^ 2",
  "name": "two_mul_le_add_sq",
  "kind": "theorem",
  "doc_string":
  "Arithmetic mean-geometric mean (AM-GM) inequality for linearly ordered commutative rings. ",
  "args": ""},
 {"type": "∀ {G₀ : Type u_1} [self : CommGroupWithZero G₀], 0⁻¹ = 0",
  "name": "CommGroupWithZero.inv_zero",
  "kind": "def",
  "doc_string": "The inverse of `0` in a group with zero is `0`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : NonUnitalCommSemiring α] (a b : α), a * b = b * a",
  "name": "NonUnitalCommSemiring.mul_comm",
  "kind": "def",
  "doc_string": "Multiplication is commutative in a commutative semigroup. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Monoid α] [self : MulAction α β] (b : β), 1 • b = b",
  "name": "MulAction.one_smul",
  "kind": "def",
  "doc_string": "One is the neutral element for `•` ",
  "args": ""},
 {"type": "ToAdditive.Config → Lean.Name",
  "name": "ToAdditive.Config.tgt",
  "kind": "def",
  "doc_string": "The name of the target (the additive declaration).",
  "args": ""},
 {"type": "{σ : Type u} → σ → PUnit",
  "name": "EStateM.dummySave",
  "kind": "def",
  "doc_string": "The `save` implementation for `Backtrackable PUnit σ`. ",
  "args": ""},
 {"type":
  "{G₀ : Type u_1} →\n  {G₀' : Type u_2} →\n    [inst : CommGroupWithZero G₀] →\n      [inst_1 : Zero G₀'] →\n        [inst_2 : Mul G₀'] →\n          [inst_3 : One G₀'] →\n            [inst_4 : Inv G₀'] →\n              [inst_5 : Div G₀'] →\n                [inst_6 : Pow G₀' ℕ] →\n                  [inst_7 : Pow G₀' ℤ] →\n                    0 ≠ 1 →\n                      (f : G₀ → G₀') →\n                        Function.Surjective f →\n                          f 0 = 0 →\n                            f 1 = 1 →\n                              (∀ (x y : G₀), f (x * y) = f x * f y) →\n                                (∀ (x : G₀), f x⁻¹ = (f x)⁻¹) →\n                                  (∀ (x y : G₀), f (x / y) = f x / f y) →\n                                    (∀ (x : G₀) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                      (∀ (x : G₀) (n : ℤ), f (x ^ n) = f x ^ n) → CommGroupWithZero G₀'",
  "name": "Function.Surjective.commGroupWithZero",
  "kind": "def",
  "doc_string":
  "Pushforward a `CommGroupWithZero` along a surjective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Lattice α] → [inst : BoundedOrder α] → Prop",
  "name": "ComplementedLattice",
  "kind": "inductive",
  "doc_string":
  "A complemented bounded lattice is one where every element has a (not necessarily unique)\ncomplement. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : HasCompl α] → α → Prop",
  "name": "Heyting.IsRegular",
  "kind": "def",
  "doc_string":
  "An element of an Heyting algebra is regular if its double complement is itself. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {f g : α → α},\n  Function.Commute f g → Set.BijOn g (Function.fixedPoints (f ∘ g)) (Function.fixedPoints (f ∘ g))",
  "name": "Function.Commute.right_bijOn_fixedPoints_comp",
  "kind": "theorem",
  "doc_string":
  "If self-maps `f` and `g` commute, then `g` is bijective on the set of fixed points of `f ∘ g`.\nThis is a particular case of `Function.bijOn_fixedPoints_comp`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Mul M] →\n      [inst_1 : Mul N] →\n        (s : Subsemigroup M) →\n          (t : Subsemigroup N) → { x // x ∈ Subsemigroup.prod s t } ≃* { x // x ∈ s } × { x // x ∈ t }",
  "name": "Subsemigroup.prodEquiv",
  "kind": "def",
  "doc_string":
  "The product of subsemigroups is isomorphic to their product as semigroups. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulMono α],\n  0 ≤ a → 0 ≤ b → 0 ≤ a * b",
  "name": "Left.mul_nonneg",
  "kind": "theorem",
  "doc_string": "Assumes left covariance. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 ↔ a = 0 ∨ b = 0",
  "name": "mul_eq_zero",
  "kind": "theorem",
  "doc_string":
  "If `α` has no zero divisors, then the product of two elements equals zero iff one of them\nequals zero. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "name": "List.Subset",
  "kind": "def",
  "doc_string":
  "`l₁ ⊆ l₂` means that every element of `l₁` is also an element of `l₂`, ignoring multiplicity.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r s : α → α → Prop}, (∀ (x y : α), r x y → s x y) → EqvGen.Setoid r ≤ EqvGen.Setoid s",
  "name": "Setoid.eqvGen_mono",
  "kind": "theorem",
  "doc_string": "Equivalence closure of binary relations is monotone. ",
  "args": ""},
 {"type": "{X : Type u} → (X → X → X) → X → Prop",
  "name": "EckmannHilton.IsUnital",
  "kind": "inductive",
  "doc_string":
  "`IsUnital m e` expresses that `e : X` is a left and right unit\nfor the binary operation `m : X → X → X`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {ι : Sort u_2} [inst : CompleteLattice α] {b : α} {f : ι → α},\n  (∀ (i : ι), f i ≤ b) → (∀ (w : α), w < b → ∃ i, w < f i) → (⨆ i, f i) = b",
  "name": "supᵢ_eq_of_forall_le_of_forall_lt_exists_gt",
  "kind": "theorem",
  "doc_string":
  "Introduction rule to prove that `b` is the supremum of `f`: it suffices to check that `b`\nis larger than `f i` for all `i`, and that this is not the case of any `w<b`.\nSee `csupᵢ_eq_of_forall_le_of_forall_lt_exists_gt` for a version in conditionally complete\nlattices. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] → [inst_1 : Quiver.IsThin C] → {X Y : C} → (X ⟶ Y) → (Y ⟶ X) → (X ≅ Y)",
  "name": "CategoryTheory.iso_of_both_ways",
  "kind": "def",
  "doc_string":
  "To show `X ≅ Y` in a thin category, it suffices to just give any morphism in each direction. ",
  "args": ""},
 {"type":
  "∀ (M : Type u_2) {α : Type u_1} [inst : Monoid M] [inst_1 : MulAction M α] (a₁ a₂ : M),\n  (fun x x_1 => x • x_1) a₁ ∘ (fun x x_1 => x • x_1) a₂ = (fun x x_1 => x • x_1) (a₁ * a₂)",
  "name": "comp_smul_left",
  "kind": "theorem",
  "doc_string": "`SMul` version of `comp_mul_left` ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : CommMonoidWithZero α] → α → Prop",
  "name": "Prime",
  "kind": "def",
  "doc_string": "prime element of a `CommMonoidWithZero` ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Meta.Positivity.Entry",
  "kind": "def",
  "doc_string":
  "Each `positivity` extension is labelled with a collection of patterns\nwhich determine the expressions to which it should be applied. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "attrTo_additive?_",
  "kind": "def",
  "doc_string": "The `to_additive` attribute. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "CategoryTheory.Functor.«term𝟭»",
  "kind": "def",
  "doc_string": "Notation for the identity functor on a category. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ⋖ b ↔ a < b ∧ ∀ (c : α), a ≤ c → c ≤ b → c = a ∨ c = b",
  "name": "covby_iff_lt_and_eq_or_eq",
  "kind": "theorem",
  "doc_string":
  "An `iff` version of `Covby.eq_or_eq` and `covby_of_eq_or_eq`. ",
  "args": ""},
 {"type": "Lean.Term → Lean.Elab.TermElabM (Option Lean.Term)",
  "name": "Mathlib.Tactic.LinearCombination.expandLinearCombo",
  "kind": "opaque",
  "doc_string":
  "Performs macro expansion of a linear combination expression,\nusing `+`/`-`/`*`/`/` on equations and values.\n* `some p` means that `p` is a syntax corresponding to a proof of an equation.\n  For example, if `h : a = b` then `expandLinearCombo (2 * h)` returns `some (c_add_pf 2 h)`\n  which is a proof of `2 * a = 2 * b`.\n* `none` means that the input expression is not an equation but a value;\n  the input syntax itself is used in this case.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α}, IsLUB s a → BddAbove s",
  "name": "IsLUB.bddAbove",
  "kind": "theorem",
  "doc_string": "If `s` has a least upper bound, then it is bounded above. ",
  "args": ""},
 {"type": "ZNum → ZNum",
  "name": "ZNum.succ",
  "kind": "def",
  "doc_string": "The successor of a `ZNum`. ",
  "args": ""},
 {"type": "{α : Type u_1} → Setoid α → α → α → Prop",
  "name": "Setoid.Rel",
  "kind": "def",
  "doc_string":
  "A version of `Setoid.r` that takes the equivalence relation as an explicit argument. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → [inst_2 : Unique N] → M × N ≃* M",
  "name": "MulEquiv.prodUnique",
  "kind": "def",
  "doc_string":
  "Multiplying by the trivial monoid doesn't change the structure.",
  "args": ""},
 {"type":
  "{α : Type u} → {C : WithOne α → Sort u_1} → C 1 → ((a : α) → C ↑a) → (n : WithOne α) → C n",
  "name": "WithOne.recOneCoe",
  "kind": "def",
  "doc_string":
  "Recursor for `WithOne` using the preferred forms `1` and `↑a`. ",
  "args": ""},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [inst : MonadState σ m] → (σ → σ) → m PUnit",
  "name": "modify",
  "kind": "def",
  "doc_string":
  "`modify (f : σ → σ)` applies the function `f` to the state.\n\nIt is equivalent to `do put (f (← get))`, but `modify f` may be preferable\nbecause the former does not use the state linearly (without sufficient inlining).\n",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : LinearOrderedCommMonoid α] →\n    {β : Type u_1} →\n      [inst_1 : One β] →\n        [inst_2 : Mul β] →\n          [inst_3 : Pow β ℕ] →\n            [inst_4 : HasSup β] →\n              [inst_5 : HasInf β] →\n                (f : β → α) →\n                  Function.Injective f →\n                    f 1 = 1 →\n                      (∀ (x y : β), f (x * y) = f x * f y) →\n                        (∀ (x : β) (n : ℕ), f (x ^ n) = f x ^ n) →\n                          (∀ (x y : β), f (x ⊔ y) = max (f x) (f y)) →\n                            (∀ (x y : β), f (x ⊓ y) = min (f x) (f y)) → LinearOrderedCommMonoid β",
  "name": "Function.Injective.linearOrderedCommMonoid",
  "kind": "def",
  "doc_string":
  "Pullback a `LinearOrderedCommMonoid` under an injective map.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} → [inst : One M] → [inst_1 : One N] → [inst_2 : One P] → OneHom N P → OneHom M N → OneHom M P",
  "name": "OneHom.comp",
  "kind": "def",
  "doc_string": "Composition of `OneHom`s as a `OneHom`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a b : Q(«$α»)} →\n        (rα : Q(Ring «$α»)) →\n          Mathlib.Tactic.Ring.ExSum sα a →\n            Mathlib.Tactic.Ring.ExSum sα b → Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExSum sα) q(«$a» - «$b»)",
  "name": "Mathlib.Tactic.Ring.evalSub",
  "kind": "def",
  "doc_string":
  "Subtracts two polynomials `va, vb` to get a normalized result polynomial.\n\n* `a - b = a + -b`\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : NormalizedGCDMonoid α] (a b : α),\n  ↑normalize (lcm a b) = lcm a b",
  "name": "NormalizedGCDMonoid.normalize_lcm",
  "kind": "def",
  "doc_string": "The LCM is normalized to itself. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : SuccOrder α] [inst_2 : Preorder β] {f : α → β},\n  Antitone f → Pairwise (Disjoint on fun n => Set.Ioo (f (Order.succ n)) (f n))",
  "name": "Antitone.pairwise_disjoint_on_Ioo_succ",
  "kind": "theorem",
  "doc_string":
  "If `α` is a linear succ order, `β` is a preorder, and `f : α → β` is an antitone function, then\nthe intervals `Set.Ioo (f (Order.succ n)) (f n)` are pairwise disjoint. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → {x : MulZeroOneClass M} → {x_1 : MulZeroOneClass N} → (f : M →*₀ N) → (f' : M → N) → f' = ↑f → M →* N",
  "name": "MonoidWithZeroHom.copy",
  "kind": "def",
  "doc_string":
  "Copy of a `MonoidHom` with a new `toFun` equal to the old one. Useful to fix\ndefinitional equalities. ",
  "args": ""},
 {"type": "∀ {a b : Prop} {p : Prop → Prop}, (a ↔ b) → p a → p b",
  "name": "Iff.subst",
  "kind": "theorem",
  "doc_string": "Iff can now be used to do substitutions in a calculation ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⁻»",
  "kind": "def",
  "doc_string": "The negative part function. ",
  "args": ""},
 {"type": "{α : Type u_1} → (S : Set α) → ↑(𝒫 S) ≃ Set ↑S",
  "name": "Equiv.Set.powerset",
  "kind": "def",
  "doc_string":
  "The set `𝒫 S := {x | x ⊆ S}` is equivalent to the type `Set S`. ",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} →\n  {α : Type u_1} → [inst : Monad m] → m (ForInStep α) → (α → m (ForInStep α)) → m (ForInStep α)",
  "name": "ForInStep.bindM",
  "kind": "def",
  "doc_string":
  "This is similar to a monadic `bind` operator, except that the two type parameters have to be\nthe same, which prevents putting a monad instance on `ForInStepT m α := m (ForInStep α)`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CompleteLattice α] [self : IsAtomistic α] (b : α),\n  ∃ s, b = supₛ s ∧ ∀ (a : α), a ∈ s → IsAtom a",
  "name": "IsAtomistic.eq_supₛ_atoms",
  "kind": "def",
  "doc_string": "Every element is a `supₛ` of a set of atoms. ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [inst : Preorder α] → [inst_1 : AddZeroClass α] → α →+o α",
  "name": "OrderAddMonoidHom.id",
  "kind": "def",
  "doc_string": "The identity map as an ordered additive monoid homomorphism.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.normNumConv",
  "kind": "def",
  "doc_string":
  "Normalize numerical expressions. Supports the operations `+` `-` `*` `/` `^` and `%`\nover numerical types such as `ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,\nand can prove goals of the form `A = B`, `A ≠ B`, `A < B` and `A ≤ B`, where `A` and `B` are\nnumerical expressions. It also has a relatively simple primality prover.\n",
  "args": ""},
 {"type": "{α : Type u} → (α → Bool) → List α → List α × List α",
  "name": "List.partition",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `partition p l` calls `p` on each element of `l`, partitioning the list into two lists\n`(l_true, l_false)` where `l_true` has the elements where `p` was true\nand `l_false` has the elements where `p` is false.\n`partition p l = (filter p l, filter (not ∘ p) l)`, but it is slightly more efficient\nsince it only has to do one pass over the list.\n```\npartition (· > 2) [1, 2, 5, 2, 7, 7] = ([5, 7, 7], [1, 2, 2])\n```\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Monoid R] [inst_1 : HasDistribNeg R] (a : R), (-a) ^ 2 = a ^ 2",
  "name": "neg_pow_two",
  "kind": "theorem",
  "doc_string": "**Alias** of `neg_sq`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : PartialOrder α] {f : β → β → α},\n  (∀ (a b : β), f a b ≤ f b a) → ∀ (a b : β), f a b = f b a",
  "name": "commutative_of_le",
  "kind": "theorem",
  "doc_string":
  "To prove commutativity of a binary operation `○`, we only to check `a ○ b ≤ b ○ a` for all `a`,\n`b`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → α → Prop) → (β → β → Prop) → Type (max u_1 u_2)",
  "name": "InitialSeg",
  "kind": "inductive",
  "doc_string":
  "If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≼i s` is an order\nembedding whose range is an initial segment. That is, whenever `b < f a` in `β` then `b` is in the\nrange of `f`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [inst_3 : OrderedSub α] {a b c : α}\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], a + b - c ≤ a + (b - c)",
  "name": "add_tsub_le_assoc",
  "kind": "theorem",
  "doc_string": "See `add_tsub_assoc_of_le` for the equality. ",
  "args": ""},
 {"type": "ℚ → Prop",
  "name": "Rat.Nonneg",
  "kind": "def",
  "doc_string":
  "A rational number is called nonnegative if its numerator is nonnegative. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Prelude.Rename.lookup3",
  "kind": "def",
  "doc_string":
  "Show information about the alignment status of a lean 3 definition. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "ForInStep",
  "kind": "inductive",
  "doc_string":
  "Auxiliary type used to compile `for x in xs` notation.\n\nThis is the return value of the body of a `ForIn` call,\nrepresenting the body of a for loop. It can be:\n\n* `.yield (a : α)`, meaning that we should continue the loop and `a` is the new state.\n  `.yield` is produced by `continue` and reaching the bottom of the loop body.\n* `.done (a : α)`, meaning that we should early-exit the loop with state `a`.\n  `.done` is produced by calls to `break` or `return` in the loop,\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : LinearOrder β] {f : α → β},\n  ¬Monotone f ∧ ¬Antitone f ↔ ∃ a b c, a ≤ b ∧ b ≤ c ∧ (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c)",
  "name": "not_monotone_not_antitone_iff_exists_le_le",
  "kind": "theorem",
  "doc_string":
  "A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. ",
  "args": ""},
 {"type": "Linarith.Linexp → Linarith.Linexp → Ordering",
  "name": "Linarith.Linexp.cmp",
  "kind": "def",
  "doc_string":
  "Defines a lex ordering on `Linexp`. This function is performance critical.\n",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₂] →\n      [inst_1 : One M₂] →\n        [inst_2 : Pow M₂ ℕ] →\n          [inst_3 : Inv M₂] →\n            [inst_4 : Div M₂] →\n              [inst_5 : Pow M₂ ℤ] →\n                [inst_6 : Group M₁] →\n                  (f : M₁ → M₂) →\n                    Function.Surjective f →\n                      f 1 = 1 →\n                        (∀ (x y : M₁), f (x * y) = f x * f y) →\n                          (∀ (x : M₁), f x⁻¹ = (f x)⁻¹) →\n                            (∀ (x y : M₁), f (x / y) = f x / f y) →\n                              (∀ (x : M₁) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                (∀ (x : M₁) (n : ℤ), f (x ^ n) = f x ^ n) → Group M₂",
  "name": "Function.Surjective.group",
  "kind": "def",
  "doc_string":
  "A type endowed with `1`, `*` and `⁻¹` is a group, if it admits a surjective map that preserves\n`1`, `*` and `⁻¹` to a group. See note [reducible non-instances]. ",
  "args": ""},
 {"type": "{α : Type u_1} → α → ℕ → List α → Array α → List α",
  "name": "List.takeDTR.go",
  "kind": "def",
  "doc_string":
  "Auxiliary for `takeDTR`: `takeDTR.go dflt n l acc = acc.toList ++ takeD n l dflt`. ",
  "args": ""},
 {"type": "Linarith.PComp → Std.RBSet ℕ compare",
  "name": "Linarith.PComp.history",
  "kind": "def",
  "doc_string":
  "The set of original assumptions which have been used in constructing this comparison. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → Array α → β → (α → β → m (ForInStep β)) → m β",
  "name": "Array.forInUnsafe",
  "kind": "def",
  "doc_string":
  "We claim this unsafe implementation is correct because an array cannot have more than `usizeSz` elements in our runtime.\n\nThis kind of low level trick can be removed with a little bit of compiler support. For example, if the compiler simplifies `as.size < usizeSz` to true. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LE α] → α → Prop",
  "name": "IsMax",
  "kind": "def",
  "doc_string":
  "`a` is a maximal element of `α` if no element is strictly greater than it. We spell it without\n`<` to avoid having to convert between `≤` and `<`. Instead, `isMax_iff_forall_not_lt` does the\nconversion. ",
  "args": ""},
 {"type":
  "{t t' : Type u → Type u} → ((α : Type u) → t α ≃ t' α) → [inst : Traversable t] → Traversable t'",
  "name": "Equiv.traversable",
  "kind": "def",
  "doc_string":
  "The function `Equiv.traverse` transfers a traversable functor\ninstance across the equivalences `eqv`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "MulZeroOneClass",
  "kind": "inductive",
  "doc_string": "A typeclass for non-associative monoids with zero elements. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : MulZeroOneClass M] [inst_1 : MulZeroOneClass N] (self : M →*₀ N) (x y : M),\n  ↑↑self (x * y) = ↑↑self x * ↑↑self y",
  "name": "MonoidWithZeroHom.map_mul'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves multiplication ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⊔_»",
  "kind": "def",
  "doc_string": "Least upper bound (`\\lub` notation) ",
  "args": ""},
 {"type": "{g : Type u} → [self : RandomGen g] → g → g × g",
  "name": "RandomGen.split",
  "kind": "def",
  "doc_string":
  "The 'split' operation allows one to obtain two distinct random number\ngenerators. This is very useful in functional programs (for example, when\npassing a random number generator down to recursive calls). ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : Ring α] → {a : α} → {num : ℤ} → {denom : ℕ} → Mathlib.Meta.NormNum.IsRat a num denom → Invertible denom",
  "name": "Mathlib.Meta.NormNum.IsRat.inv",
  "kind": "def",
  "doc_string": "The denominator is invertible. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → [inst : Add M] → [inst_1 : Add N] → AddHom (M × N) M",
  "name": "AddHom.fst",
  "kind": "def",
  "doc_string":
  "Given additive magmas `A`, `B`, the natural projection homomorphism\nfrom `A × B` to `A`",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Abel.AbelMode",
  "kind": "inductive",
  "doc_string": "The normalization style for `abel_nf`. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} [self : HeytingAlgebra α] (a : α), a ⇨ ⊥ = aᶜ",
  "name": "HeytingAlgebra.himp_bot",
  "kind": "def",
  "doc_string": "`a ⇨` is right adjoint to `a ⊓` ",
  "args": ""},
 {"type":
  "{α₁ : Type u_1} → {β₁ : Type u_2} → {α₂ : Type u_3} → {β₂ : Type u_4} → α₁ ≃ α₂ → β₁ ≃ β₂ → (α₁ → β₁) ≃ (α₂ → β₂)",
  "name": "Equiv.arrowCongr'",
  "kind": "def",
  "doc_string":
  "A version of `Equiv.arrowCongr` in `Type`, rather than `Sort`.\n\nThe `equiv_rw` tactic is not able to use the default `Sort` level `Equiv.arrowCongr`,\nbecause Lean's universe rules will not unify `?l_1` with `imax (1 ?m_1)`.\n",
  "args": ""},
 {"type": "ℕ → Bool",
  "name": "Nat.bodd",
  "kind": "def",
  "doc_string": "`bodd n` returns `true` if `n` is odd",
  "args": ""},
 {"type": "{α : Type u_1} → MulAction (Function.End α) α",
  "name": "Function.End.applyMulAction",
  "kind": "def",
  "doc_string":
  "The tautological action by `Function.End α` on `α`.\n\nThis is generalized to bundled endomorphisms by:\n* `Equiv.Perm.applyMulAction`\n* `AddMonoid.End.applyDistribMulAction`\n* `AddAut.applyDistribMulAction`\n* `MulAut.applyMulDistribMulAction`\n* `RingHom.applyDistribMulAction`\n* `LinearEquiv.applyDistribMulAction`\n* `LinearMap.applyModule`\n* `RingHom.applyMulSemiringAction`\n* `AlgEquiv.applyMulSemiringAction`\n",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "OrderedSemiring",
  "kind": "inductive",
  "doc_string":
  "An `OrderedSemiring` is a semiring with a partial order such that addition is monotone and\nmultiplication by a nonnegative number is monotone. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {ι : Type u_2} → (f : ι → α) → (s : Set α) → (∀ (x : ι), f x ∈ s) → ι → ↑s",
  "name": "Set.codRestrict",
  "kind": "def",
  "doc_string":
  "Restrict codomain of a function `f` to a set `s`. Same as `Subtype.coind` but this version\nhas codomain `↥s` instead of `Subtype s`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop},\n  WellFounded rα → WellFounded rβ → WellFounded (Prod.GameAdd rα rβ)",
  "name": "WellFounded.prod_gameAdd",
  "kind": "theorem",
  "doc_string": "The sum of two well-founded games is well-founded. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : Semiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "name": "Semiring.natCast_succ",
  "kind": "def",
  "doc_string": "The canonical map `ℕ → R` is a homomorphism. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  MonotoneOn f s → MonotoneOn g s → MonotoneOn (fun x => f x + g x) s",
  "name": "MonotoneOn.add",
  "kind": "theorem",
  "doc_string": "The sum of two monotone functions is monotone.",
  "args": ""},
 {"type":
  "∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} [self : CategoryTheory.Mono f] {Z : C}\n  (g h : Z ⟶ X), g ≫ f = h ≫ f → g = h",
  "name": "CategoryTheory.Mono.right_cancellation",
  "kind": "def",
  "doc_string":
  "A morphism `f` is an epimorphism if it can be cancelled when postcomposed. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "SlimCheck.NoShrink",
  "kind": "def",
  "doc_string": "An annotation for values that should never get shrinked. ",
  "args": ""},
 {"type": "(p : ℕ) → Decidable (Nat.Prime p)",
  "name": "Nat.decidablePrime",
  "kind": "def",
  "doc_string":
  "This instance is faster in the virtual machine than `decidablePrime1`,\nbut slower in the kernel.\n\nIf you need to prove that a particular number is prime, in any case\nyou should not use `by decide`, but rather `by norm_num`, which is\nmuch faster.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : PredOrder α] [inst_2 : Preorder β] {f : α → β},\n  Antitone f → Pairwise (Disjoint on fun n => Set.Ico (f n) (f (Order.pred n)))",
  "name": "Antitone.pairwise_disjoint_on_Ico_pred",
  "kind": "theorem",
  "doc_string":
  "If `α` is a linear pred order, `β` is a preorder, and `f : α → β` is an antitone function, then\nthe intervals `Set.Ico (f n) (f (Order.pred n))` are pairwise disjoint. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedAddMonoid α] (a b : α), min a b = if a ≤ b then a else b",
  "name": "CanonicallyLinearOrderedAddMonoid.min_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `minOfLe`. ",
  "args": ""},
 {"type":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    {M : Type u_3} →\n      [inst : Monoid R] →\n        [inst_1 : AddMonoid M] →\n          [inst_2 : DistribMulAction R M] →\n            [inst_3 : Monoid S] →\n              [inst_4 : SMul S M] →\n                (f : R →* S) → Function.Surjective ↑f → (∀ (c : R) (x : M), ↑f c • x = c • x) → DistribMulAction S M",
  "name": "Function.Surjective.distribMulActionLeft",
  "kind": "def",
  "doc_string":
  "Push forward the action of `R` on `M` along a compatible surjective map `f : R →* S`.\n\nSee also `Function.Surjective.mulActionLeft` and `Function.Surjective.moduleLeft`.\n",
  "args": ""},
 {"type":
  "{C : Type u₁} → [inst : CategoryTheory.Category C] → {D : Type u₂} → [inst_1 : CategoryTheory.Category D] → C ⥤ D → Prop",
  "name": "CategoryTheory.Faithful",
  "kind": "inductive",
  "doc_string":
  "A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.\n\nSee <https://stacks.math.columbia.edu/tag/001C>.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  StrictMono (Set.restrict s f) → StrictMonoOn f s",
  "name": "StrictMono.of_restrict",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `strictMono_restrict`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : LE α] → [inst_1 : LE β] → α × β ≃o β × α",
  "name": "OrderIso.prodComm",
  "kind": "def",
  "doc_string": "`Prod.swap` as an `OrderIso`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Add M] → [inst_1 : Add N] → M ≃+ N → N ≃+ M",
  "name": "AddEquiv.symm",
  "kind": "def",
  "doc_string": "The inverse of an isomorphism is an isomorphism.",
  "args": ""},
 {"type": "{α : Type u} → [inst : Mul α] → α →ₙ* WithOne α",
  "name": "WithOne.coeMulHom",
  "kind": "def",
  "doc_string": "`WithOne.coe` as a bundled morphism ",
  "args": ""},
 {"type":
  "{α : Type u} → (r : α → α → Prop) → [inst : IsWellFounded α r] → WellFoundedRelation α",
  "name": "IsWellFounded.toWellFoundedRelation",
  "kind": "def",
  "doc_string":
  "Derive a `WellFoundedRelation` instance from an `isWellFounded` instance. ",
  "args": ""},
 {"type": "ℕ → ℕ → ℤ × ℤ",
  "name": "Nat.xgcd",
  "kind": "def",
  "doc_string":
  "Use the extended GCD algorithm to generate the `a` and `b` values\nsatisfying `gcd x y = x * a + y * b`. ",
  "args": ""},
 {"type":
  "{α : Type u} → (s : Set α) → [inst : DecidablePred fun x => x ∈ s] → α ≃. α",
  "name": "PEquiv.ofSet",
  "kind": "def",
  "doc_string":
  "Creates a `PEquiv` that is the identity on `s`, and `none` outside of it. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u} {f : α → α}, Function.Involutive f → ∀ {x y : α}, f x = y ↔ x = f y",
  "name": "Function.Involutive.eq_iff",
  "kind": "theorem",
  "doc_string":
  "An involution commutes across an equality. Compare to `Function.Injective.eq_iff`. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {q : (x : α) → p x → Prop}, (∃ x h, q x h) ↔ ∃ x, q ↑x (_ : p ↑x)",
  "name": "Subtype.exists'",
  "kind": "theorem",
  "doc_string":
  "An alternative version of `subtype.exists`. This one is useful if Lean cannot figure out `q`\nwhen using `subtype.exists` from right to left. ",
  "args": ""},
 {"type": "NonemptyType → Type u",
  "name": "NonemptyType.type",
  "kind": "def",
  "doc_string": "The underlying type of a `NonemptyType`. ",
  "args": ""},
 {"type": "{k m n : ℕ} → k ∣ m * n → { d // k = ↑d.fst * ↑d.snd }",
  "name": "Nat.prod_dvd_and_dvd_of_dvd_prod",
  "kind": "def",
  "doc_string":
  "Represent a divisor of `m * n` as a product of a divisor of `m` and a divisor of `n`. ",
  "args": ""},
 {"type": "∀ {α : Sort u_1} {a b : α}, HEq a b → a = b",
  "name": "HEq.eq",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `heq_iff_eq`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {ι : Sort u_1} {f : ι → α} [h : Unique ι], Set.range f = {f default}",
  "name": "Set.range_unique",
  "kind": "theorem",
  "doc_string":
  "The range of a function from a `unique` type contains just the\nfunction applied to its single value. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : BEq α] → α → List α → Bool",
  "name": "List.elem",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `elem a l` or `l.contains a` is true if there is an element in `l` equal to `a`.\n\n* `elem 3 [1, 4, 2, 3, 3, 7] = true`\n* `elem 5 [1, 4, 2, 3, 3, 7] = false`\n",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type u_1} →\n    [inst : HasSup α] →\n      [inst_1 : HasInf α] →\n        [inst_2 : Top α] →\n          [inst_3 : Bot α] →\n            [inst_4 : HasCompl α] →\n              [inst_5 : SDiff α] →\n                [inst_6 : BooleanAlgebra β] →\n                  (f : α → β) →\n                    Function.Injective f →\n                      (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) →\n                        (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) →\n                          f ⊤ = ⊤ →\n                            f ⊥ = ⊥ →\n                              (∀ (a : α), f (aᶜ) = f aᶜ) → (∀ (a b : α), f (a \\ b) = f a \\ f b) → BooleanAlgebra α",
  "name": "Function.Injective.booleanAlgebra",
  "kind": "def",
  "doc_string": "Pullback a `BooleanAlgebra` along an injection. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : Semiring α] (n : ℕ) (x : α), Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "name": "Semiring.npow_succ",
  "kind": "def",
  "doc_string": "Raising to the power `(n + 1 : ℕ)` behaves as expected. ",
  "args": ""},
 {"type":
  "{ε σ α δ : Type u} →\n  [inst : EStateM.Backtrackable δ σ] → EStateM ε σ α → EStateM ε σ α → optParam Bool true → EStateM ε σ α",
  "name": "EStateM.orElse'",
  "kind": "def",
  "doc_string":
  "Alternative orElse operator that allows to select which exception should be used.\nThe default is to use the first exception since the standard `orElse` uses the second. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a : α} {s t p : Set α}, IsLUB s a → IsLUB p a → s ⊆ t → t ⊆ p → IsLUB t a",
  "name": "IsLUB.of_subset_of_superset",
  "kind": "theorem",
  "doc_string":
  "If `a` is a least upper bound for sets `s` and `p`, then it is a least upper bound for any\nset `t`, `s ⊆ t ⊆ p`. ",
  "args": ""},
 {"type": "{p : ℕ → Prop} → Nat.Upto p",
  "name": "Nat.Upto.zero",
  "kind": "def",
  "doc_string":
  "Zero is always a member of `Nat.Upto p` because it has no predecessors. ",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  {H : Type u_2} → [inst : MulOneClass G] → [inst_1 : AddZeroClass H] → Additive G ≃+ H ≃ (G ≃* Multiplicative H)",
  "name": "AddEquiv.toMultiplicative'",
  "kind": "def",
  "doc_string": "Reinterpret `Additive G ≃+ H` as `G ≃* Multiplicative H`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a : α}, 1 ≤ a⁻¹ ↔ a ≤ 1",
  "name": "one_le_inv'",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.one_le_inv_iff`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α) (a : α), a ∈ s → infₛ s ≤ a",
  "name": "CompleteBooleanAlgebra.infₛ_le",
  "kind": "def",
  "doc_string": "Any element of a set is more than the set infimum. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CoheytingAlgebra α] (a b : α),\n  Coheyting.boundary (a ⊓ b) = Coheyting.boundary a ⊓ b ⊔ a ⊓ Coheyting.boundary b",
  "name": "Coheyting.boundary_inf",
  "kind": "theorem",
  "doc_string": "**Leibniz rule** for the co-Heyting boundary. ",
  "args": ""},
 {"type": "{ε σ : Type u} → EStateM ε σ σ",
  "name": "EStateM.get",
  "kind": "def",
  "doc_string": "The `get` operation of the `EStateM` monad. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α] (a b : α), a / b = a * b⁻¹",
  "name": "CanonicallyLinearOrderedSemifield.div_eq_mul_inv",
  "kind": "def",
  "doc_string": "`a / b := a * b⁻¹` ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : BoundedOrder α] [inst_2 : IsSimpleOrder α] {a b : α}, a < b → a = ⊥",
  "name": "IsSimpleOrder.LT.lt.eq_bot",
  "kind": "theorem",
  "doc_string": "**Alias** of `IsSimpleOrder.eq_bot_of_lt`.",
  "args": ""},
 {"type": "Mathlib.Tactic.RingNF.RingMode",
  "name": "Mathlib.Tactic.RingNF.RingMode.SOP",
  "kind": "def",
  "doc_string": "Sum-of-products form, like `x + x * y * 2 + z ^ 2`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List Bool → List α → List (Option α)",
  "name": "Mathlib.Tactic.MkIff.listBoolMerge",
  "kind": "def",
  "doc_string":
  "Iterate over two lists, if the first element of the first list is `false`, insert `none` into the\nresult and continue with the tail of first list. Otherwise, wrap the first element of the second\nlist with `some` and continue with the tails of both lists. Return when either list is empty.\n\nExample:\n```\nlistBoolMerge [false, true, false, true] [0, 1, 2, 3, 4] = [none, (some 0), none, (some 1)]\n```\n",
  "args": ""},
 {"type":
  "(R : Type u_1) →\n  {M : Type u_2} →\n    {M₂ : Type u_3} →\n      [inst : Semiring R] →\n        [inst_1 : AddCommMonoid M] →\n          [inst_2 : Module R M] →\n            [inst_3 : AddCommMonoid M₂] →\n              [inst_4 : SMul R M₂] →\n                (f : M →+ M₂) → Function.Surjective ↑f → (∀ (c : R) (x : M), ↑f (c • x) = c • ↑f x) → Module R M₂",
  "name": "Function.Surjective.module",
  "kind": "def",
  "doc_string":
  "Pushforward a `Module` structure along a surjective additive monoid homomorphism. ",
  "args": ""},
 {"type": "∀ {α : Prop}, α",
  "name": "lcProof",
  "kind": "axiom",
  "doc_string":
  "Auxiliary unsafe constant used by the Compiler when erasing proofs from code.\n\nIt may look strange to have an axiom that says \"every proposition is true\",\nsince this is obviously unsound, but the `unsafe` marker ensures that the\nkernel will not let this through into regular proofs. The lower levels of the\ncode generator don't need proofs in terms, so this is used to stub the proofs\nout.\n",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Subsingleton α] → α × α ≃ α",
  "name": "subsingletonProdSelfEquiv",
  "kind": "def",
  "doc_string": "If `α` is a subsingleton, then it is equivalent to `α × α`. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → [self : Pow α β] → α → β → α",
  "name": "Pow.pow",
  "kind": "def",
  "doc_string": "`a ^ b` computes `a` to the power of `b`. See `HPow`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, a < 1 → b < 1 → a * b < 1",
  "name": "mul_lt_one'",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.mul_lt_one'`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, b = c → a < b → a < c",
  "name": "Eq.trans_gt",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_of_eq_of_lt'`.",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : HasSup α] →\n      [inst_1 : HasInf α] →\n        [inst_2 : SupSet α] →\n          [inst_3 : InfSet α] →\n            [inst_4 : Top α] →\n              [inst_5 : Bot α] →\n                [inst_6 : CompleteDistribLattice β] →\n                  (f : α → β) →\n                    Function.Injective f →\n                      (∀ (a b : α), f (a ⊔ b) = f a ⊔ f b) →\n                        (∀ (a b : α), f (a ⊓ b) = f a ⊓ f b) →\n                          (∀ (s : Set α), f (supₛ s) = ⨆ a, ⨆ h, f a) →\n                            (∀ (s : Set α), f (infₛ s) = ⨅ a, ⨅ h, f a) → f ⊤ = ⊤ → f ⊥ = ⊥ → CompleteDistribLattice α",
  "name": "Function.Injective.completeDistribLattice",
  "kind": "def",
  "doc_string": "Pullback a `CompleteDistribLattice` along an injection. ",
  "args": ""},
 {"type": "{α : Type u} → (α → α) → α → Stream' α",
  "name": "Stream'.iterate",
  "kind": "def",
  "doc_string": "Iterates of a function as a stream. ",
  "args": ""},
 {"type":
  "Lean.MVarId →\n  Bool → Option Lean.Expr → Lean.Name → Lean.MetaM (Mathlib.Tactic.Choose.ElimStatus × Lean.Expr × Lean.MVarId)",
  "name": "Mathlib.Tactic.Choose.choose1",
  "kind": "def",
  "doc_string":
  "Changes `(h : ∀xs, ∃a:α, p a) ⊢ g` to `(d : ∀xs, a) ⊢ (s : ∀xs, p (d xs)) → g` and\n`(h : ∀xs, p xs ∧ q xs) ⊢ g` to `(d : ∀xs, p xs) ⊢ (s : ∀xs, q xs) → g`.\n`choose1` returns a tuple of\n\n- the error result (see `ElimStatus`)\n- the data new free variable that was \"chosen\"\n- the new goal (which contains the spec of the data as domain of an arrow type)\n\nIf `nondep` is true and `α` is inhabited, then it will remove the dependency of `d` on\nall propositional assumptions in `xs`. For example if `ys` are propositions then\n`(h : ∀xs ys, ∃a:α, p a) ⊢ g` becomes `(d : ∀xs, a) (s : ∀xs ys, p (d xs)) ⊢ g`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1],\n  StrictAntiOn f s → StrictAntiOn g s → StrictAntiOn (fun x => f x * g x) s",
  "name": "StrictAntiOn.mul'",
  "kind": "theorem",
  "doc_string":
  "The product of two strictly antitone functions is strictly antitone. ",
  "args": ""},
 {"type": "∀ {M₀ : Type u} [self : MonoidWithZero M₀] (a : M₀), a * 0 = 0",
  "name": "MonoidWithZero.mul_zero",
  "kind": "def",
  "doc_string": "Zero is a right absorbing element for multiplication ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_↪r_»",
  "kind": "def",
  "doc_string":
  "A relation embedding with respect to a given pair of relations `r` and `s`\nis an embedding `f : α ↪ β` such that `r a b ↔ s (f a) (f b)`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.RunCmd.byElab",
  "kind": "def",
  "doc_string":
  "* The `by_elab doSeq` expression runs the `doSeq` as a `TermElabM Expr` to\n  synthesize the expression.\n* `by_elab fun expectedType? ↦ do doSeq` receives the expected type (an `Option Expr`)\n  as well.\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (s : Set M) {p : (x : M) → x ∈ AddSubmonoid.closure s → Prop},\n  (∀ (x : M) (h : x ∈ s), p x (_ : x ∈ ↑(AddSubmonoid.closure s))) →\n    p 0 (_ : 0 ∈ AddSubmonoid.closure s) →\n      (∀ (x : M) (hx : x ∈ AddSubmonoid.closure s) (y : M) (hy : y ∈ AddSubmonoid.closure s),\n          p x hx → p y hy → p (x + y) (_ : x + y ∈ AddSubmonoid.closure s)) →\n        ∀ {x : M} (hx : x ∈ AddSubmonoid.closure s), p x hx",
  "name": "AddSubmonoid.closure_induction'",
  "kind": "theorem",
  "doc_string": "A dependent version of `AddSubmonoid.closure_induction`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : CancelMonoidWithZero R] {a : R} [inst_1 : Nontrivial R], IsRegular a ↔ a ≠ 0",
  "name": "isRegular_iff_ne_zero",
  "kind": "theorem",
  "doc_string":
  "In a non-trivial integral domain, an element is regular iff it is non-zero. ",
  "args": ""},
 {"type": "{δ σ : Type u} → [self : EStateM.Backtrackable δ σ] → σ → δ",
  "name": "EStateM.Backtrackable.save",
  "kind": "def",
  "doc_string":
  "`save s : δ` retrieves a copy of the backtracking state out of the state. ",
  "args": ""},
 {"type":
  "{C : ℚ → Sort u} → (a : ℚ) → ((n : ℤ) → (d : ℕ) → 0 < d → Nat.coprime (Int.natAbs n) d → C (Rat.divInt n ↑d)) → C a",
  "name": "Rat.numDenCasesOn",
  "kind": "def",
  "doc_string":
  "Define a (dependent) function or prove `∀ r : ℚ, p r` by dealing with rational\nnumbers of the form `n /. d` with `0 < d` and coprime `n`, `d`. ",
  "args": ""},
 {"type": "{α : Type u_1} → List α → Array (List α) → Array (List α)",
  "name": "List.transpose.go",
  "kind": "def",
  "doc_string":
  "`go : List α → Array (List α) → Array (List α)` handles the insertion of\na new list into all the lists in the array:\n`go [a, b, c] #[l₁, l₂, l₃] = #[a::l₁, b::l₂, c::l₃]`.\nIf the new list is too short, the later lists are unchanged, and if it is too long\nthe array is extended:\n```\ngo [a] #[l₁, l₂, l₃] = #[a::l₁, l₂, l₃]\ngo [a, b, c, d] #[l₁, l₂, l₃] = #[a::l₁, b::l₂, c::l₃, [d]]\n```\n",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} [inst : AddGroup G] (a x : G), AddSemiconjBy a x (a + x + -a)",
  "name": "AddSemiconjBy.conj_mk",
  "kind": "theorem",
  "doc_string": "`a` semiconjugates `x` to `a + x + -a`.",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] [inst_1 : NoMaxOrder α] (a : α), ∃ f, StrictMono f ∧ f 0 = a",
  "name": "Nat.exists_strictMono'",
  "kind": "theorem",
  "doc_string":
  "If `α` is a preorder with no maximal elements, then there exists a strictly monotone function\n`ℕ → α` with any prescribed value of `f 0`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CanonicallyOrderedAddMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α] {a b : α},\n  a ≤ b → a - b = 0",
  "name": "tsub_eq_zero_of_le",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `tsub_eq_zero_iff_le`.",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : α → γ → Sort w} → [self : Trans r s t] → {a : α} → {b : β} → {c : γ} → r a b → s b c → t a c",
  "name": "Trans.trans",
  "kind": "def",
  "doc_string":
  "Compose two proofs by transitivity, generalized over the relations involved. ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → PLift α → (α → PLift β) → PLift β",
  "name": "PLift.bind",
  "kind": "def",
  "doc_string": "Monadic bind. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → [inst : Subsingleton α] → [inst : Subsingleton β] → (α → β) → (β → α) → α ≃ β",
  "name": "equivOfSubsingletonOfSubsingleton",
  "kind": "def",
  "doc_string":
  "To give an equivalence between two subsingleton types, it is sufficient to give any two\nfunctions between them. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : AddZeroClass α] [inst_1 : AddZeroClass β] (f g : αᵐᵒᵖ →+ β),\n  AddMonoidHom.comp f (AddEquiv.toAddMonoidHom MulOpposite.opAddEquiv) =\n      AddMonoidHom.comp g (AddEquiv.toAddMonoidHom MulOpposite.opAddEquiv) →\n    f = g",
  "name": "AddMonoidHom.mul_op_ext",
  "kind": "theorem",
  "doc_string":
  "This ext lemma changes equalities on `αᵐᵒᵖ →+ β` to equalities on `α →+ β`.\nThis is useful because there are often ext lemmas for specific `α`s that will apply\nto an equality of `α →+ β` such as `Finsupp.addHom_ext'`. ",
  "args": ""},
 {"type":
  "∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} {M : Type u_4} [inst : SMul α M] [inst_1 : SMul β M]\n  [inst_2 : SMulCommClass α β M], SMulCommClass α β (ι → M)",
  "name": "Function.smulCommClass",
  "kind": "def",
  "doc_string":
  "Non-dependent version of `Pi.smulCommClass`. Lean gets confused by the dependent instance if\nthis is not present. ",
  "args": ""},
 {"type":
  "Lean.Meta.TransparencyMode →\n  Lean.Expr →\n    (optParam (Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result) fun e =>\n        pure { expr := e, proof? := none, dischargeDepth := 0 }) →\n      Lean.MetaM Mathlib.Tactic.Abel.Context",
  "name": "Mathlib.Tactic.Abel.mkContext",
  "kind": "def",
  "doc_string":
  "Populate a `context` object for evaluating `e`, up to reducibility level `red`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} {a : R} [inst : Monoid R] [inst_1 : MulAction R M] (n : ℕ),\n  IsSMulRegular M a → IsSMulRegular M (a ^ n)",
  "name": "IsSMulRegular.pow",
  "kind": "theorem",
  "doc_string": "Any power of an `M`-regular element is `M`-regular. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⇔_»",
  "kind": "def",
  "doc_string": "Notation for bihimp ",
  "args": ""},
 {"type": "Type",
  "name": "Mathlib.Tactic.Abel.Context",
  "kind": "inductive",
  "doc_string":
  "The `Context` for a call to `abel`.\n\nStores a few options for this call, and caches some common subexpressions\nsuch as typeclass instances and `0 : α`.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {l : α → β} → {u : β → α} → GaloisConnection l u → (∀ (a : α), u (l a) ≤ a) → GaloisCoinsertion l u",
  "name": "GaloisConnection.toGaloisCoinsertion",
  "kind": "def",
  "doc_string":
  "Make a `GaloisCoinsertion l u` from a `GaloisConnection l u` such that `∀ b, b ≤ l (u b)` ",
  "args": ""},
 {"type":
  "∀ {K : Type u} [self : Field K] (n : ℕ) (a : K), Field.zpow (Int.ofNat (Nat.succ n)) a = a * Field.zpow (Int.ofNat n) a",
  "name": "Field.zpow_succ'",
  "kind": "def",
  "doc_string": "`a ^ (n + 1) = a * a ^ n` ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : DecidableEq α] → List α → List α",
  "name": "List.eraseDup",
  "kind": "def",
  "doc_string":
  "`eraseDup l` removes duplicates from `l` (taking only the first occurrence).\nDefined as `pwFilter (≠)`.\n\n  eraseDup [1, 0, 2, 2, 1] = [0, 2, 1] ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {r : α → α → Prop} {c : Set α}, IsChain r c → ∃ M, IsMaxChain r M ∧ c ⊆ M",
  "name": "IsChain.exists_maxChain",
  "kind": "theorem",
  "doc_string":
  "Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.\n",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {l : αᵒᵈ → βᵒᵈ} →\n          {u : βᵒᵈ → αᵒᵈ} →\n            GaloisCoinsertion l u →\n              GaloisInsertion (↑OrderDual.ofDual ∘ u ∘ ↑OrderDual.toDual) (↑OrderDual.ofDual ∘ l ∘ ↑OrderDual.toDual)",
  "name": "GaloisCoinsertion.ofDual",
  "kind": "def",
  "doc_string":
  "Make a `GaloisInsertion` between `α` and `β` from a `GaloisCoinsertion` between `αᵒᵈ` and\n`βᵒᵈ`. ",
  "args": ""},
 {"type":
  "{E : Sort u_1} → {α : Sort u_2} → {β : Sort u_3} → [self : EquivLike E α β] → E → α → β",
  "name": "EquivLike.coe",
  "kind": "def",
  "doc_string": "The coercion to a function in the forward direction. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_3} {β : Type u_4} {β' : Type u_5} {γ : Type u_2} {δ : Type u_1} {f : α → β → γ} {s : Set α} {t : Set β}\n  {g : γ → δ} {f' : β' → α → δ} {g' : β → β'},\n  (∀ (a : α) (b : β), g (f a b) = f' (g' b) a) → g '' Set.image2 f s t = Set.image2 f' (g' '' t) s",
  "name": "Set.image_image2_antidistrib_left",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Set.image2_image_left_anticomm`. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → List α → List α",
  "name": "List.eraseReps",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. Erase repeated adjacent elements. Keeps the first occurrence of each run.\n* `eraseReps [1, 3, 2, 2, 2, 3, 5] = [1, 3, 2, 3, 5]`\n",
  "args": ""},
 {"type": "Sort u → Sort u",
  "name": "Opposite",
  "kind": "def",
  "doc_string":
  "The type of objects of the opposite of `α`; used to define the opposite category.\n\nIn order to avoid confusion between `α` and its opposite type, we\nset up the type of objects `Opposite α` using the following pattern,\nwhich will be repeated later for the morphisms.\n\n1. Define `Opposite α := α`.\n2. Define the isomorphisms `op : α → Opposite α`, `unop : Opposite α → α`.\n3. Make the definition `Opposite` irreducible.\n\nThis has the following consequences.\n\n* `Opposite α` and `α` are distinct types in the elaborator, so you\n  must use `op` and `unop` explicitly to convert between them.\n* Both `unop (op X) = X` and `op (unop X) = X` are definitional\n  equalities. Notably, every object of the opposite category is\n  definitionally of the form `op X`, which greatly simplifies the\n  definition of the structure of the opposite category, for example.\n\n(Now that Lean 4 supports definitional eta equality for records, we could\nachieve the same goals using a structure with one field.)\n",
  "args": ""},
 {"type": "{α : Type u} → Set α → Prop",
  "name": "Set.Nonempty",
  "kind": "def",
  "doc_string":
  "The property `s.Nonempty` expresses the fact that the set `s` is not empty. It should be used\nin theorem assumptions instead of `∃ x, x ∈ s` or `s ≠ ∅` as it gives access to a nice API thanks\nto the dot notation. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddMonoid M] {x : M} (m : ℕ) {n : ℕ}, n • x = 0 → m • x = (m % n) • x",
  "name": "nsmul_eq_mod_nsmul",
  "kind": "theorem",
  "doc_string": "If `n • x = 0`, then `m • x` is the same as `(m % n) • x`",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α], Subsingleton (PredOrder α)",
  "name": "Order.instSubsingletonPredOrderToPreorder",
  "kind": "def",
  "doc_string":
  "There is at most one way to define the predecessors in a `PartialOrder`. ",
  "args": ""},
 {"type": "{α : Type u_1} → Set α → α → Bool",
  "name": "Set.boolIndicator",
  "kind": "def",
  "doc_string":
  "`boolIndicator` maps `x` to `true` if `x ∈ s`, else to `false` ",
  "args": ""},
 {"type":
  "{α : Type u} → [inst : DecidableEq α] → (a b : List α) → Decidable (a = b)",
  "name": "List.hasDecEq",
  "kind": "def",
  "doc_string":
  "Implements decidable equality for `List α`, assuming `α` has decidable equality. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : LinearOrder β] {f g : α → β},\n  Antitone f → Antitone g → Antitone fun x => min (f x) (g x)",
  "name": "Antitone.min",
  "kind": "theorem",
  "doc_string":
  "Pointwise minimum of two monotone functions is a monotone function. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Semiring α] → α → Prop",
  "name": "Odd",
  "kind": "def",
  "doc_string":
  "An element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → [inst : IsEmpty α] → {p : α → Sort u_2} → (a : α) → p a",
  "name": "isEmptyElim",
  "kind": "def",
  "doc_string":
  "Eliminate out of a type that `IsEmpty` (without using projection notation). ",
  "args": ""},
 {"type":
  "{M : Type u → Type v} → [inst : Monad M] → {ω : Type u} → ω → MonadLift M (WriterT ω M)",
  "name": "WriterT.liftTell",
  "kind": "def",
  "doc_string":
  "Lift an `M` to a `WriterT ω M`, using the given `empty` as the monoid unit. ",
  "args": ""},
 {"type":
  "{G : Type u_1} →\n  {M : Type u_2} →\n    [inst : Group G] →\n      [inst_1 : Monoid M] →\n        [inst_2 : MulAction G M] → [inst_3 : SMulCommClass G M M] → [inst_4 : IsScalarTower G M M] → MulAction G Mˣ",
  "name": "Units.mulAction'",
  "kind": "def",
  "doc_string":
  "If an action `G` associates and commutes with multiplication on `M`, then it lifts to an\naction on `Mˣ`. Notably, this provides `mul_action Mˣ Nˣ` under suitable\nconditions.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : AddZeroClass M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [inst : AddSubmonoidClass A M] → (S : A) → AddZeroClass { x // x ∈ S }",
  "name": "AddSubmonoidClass.toAddZeroClass",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of an unital additive magma inherits an unital additive magma structure.",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_→+*_»",
  "kind": "def",
  "doc_string":
  "`α →+* β` denotes the type of ring homomorphisms from `α` to `β`. ",
  "args": ""},
 {"type": "{α : Type u_1} → Part α → α",
  "name": "Part.unwrap",
  "kind": "def",
  "doc_string":
  "`unwrap o` gets the value at `o`, ignoring the condition. This function is unsound. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : Add M] (S : AddSubsemigroup M), AddSubsemigroup.closure ↑S = S",
  "name": "AddSubsemigroup.closure_eq",
  "kind": "theorem",
  "doc_string": "Additive closure of an additive subsemigroup `S` equals `S`",
  "args": ""},
 {"type": "Type",
  "name": "Linarith.ExprMap",
  "kind": "def",
  "doc_string":
  "`ExprMap` is used to record atomic expressions which have been seen while processing inequality\nexpressions.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Mul α] → [inst_1 : Mul β] → αᵐᵒᵖ ≃* βᵐᵒᵖ ≃ (α ≃* β)",
  "name": "MulEquiv.unop",
  "kind": "def",
  "doc_string":
  "The 'unopposite' of an iso `αᵐᵒᵖ ≃* βᵐᵒᵖ`. Inverse to `MulEquiv.op`. ",
  "args": ""},
 {"type": "{α : Type u} → α ≃ Additive α",
  "name": "Additive.ofMul",
  "kind": "def",
  "doc_string": "Reinterpret `x : α` as an element of `Additive α`. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM (Linarith.Ineq × Lean.Expr)",
  "name": "Linarith.parseCompAndExpr.throwNotZero",
  "kind": "def",
  "doc_string": "helper function for error message ",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → {φ : Sort w} → (α → β → φ) → β → α → φ",
  "name": "flip",
  "kind": "def",
  "doc_string":
  "`flip f a b` is `f b a`. It is useful for \"point-free\" programming,\nsince it can sometimes be used to avoid introducing variables.\nFor example, `(·<·)` is the less-than relation,\nand `flip (·<·)` is the greater-than relation.\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : LinearOrder α] → {a b : α} → a ≤ b → (↑(Set.Icc a b) → β) → α → β",
  "name": "Set.IccExtend",
  "kind": "def",
  "doc_string": "Extend a function `[a, b] → β` to a map `α → β`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "stx!_",
  "kind": "def",
  "doc_string":
  "`!p` parses the negation of `p`. That is, it fails if `p` succeeds, and\notherwise parses nothing. It has arity 0.\n",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {sα : Q(CommSemiring «$α»)} →\n      {e : Q(«$α»)} → Q(Mathlib.Meta.NormNum.IsNat «$e» 0) → Mathlib.Tactic.Ring.Overlap sα e",
  "name": "Mathlib.Tactic.Ring.Overlap.zero",
  "kind": "def",
  "doc_string": "The expression `e` (the sum of monomials) is equal to `0`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : Add M] → {N : Type u_2} → [inst_1 : Add N] → (f : AddHom M N) → AddHom M { x // x ∈ AddHom.srange f }",
  "name": "AddHom.srangeRestrict",
  "kind": "def",
  "doc_string":
  "Restriction of an `AddSemigroup` hom to its range interpreted as a subsemigroup.",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Add α] → [inst_1 : Add β] → α ≃+ β → WithZero α ≃+ WithZero β",
  "name": "AddEquiv.withZeroCongr",
  "kind": "def",
  "doc_string": "A version of `Equiv.optionCongr` for `WithZero`.",
  "args": ""},
 {"type":
  "∀ {M : Type u} [inst : DivInvMonoid M] (x : M) (z : ℤ), { unop := x ^ z } = { unop := x } ^ z",
  "name": "MulOpposite.op_zpow",
  "kind": "theorem",
  "doc_string":
  "Moving to the opposite group or `GroupWithZero` commutes with taking powers. ",
  "args": ""},
 {"type":
  "∀ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R]\n  [inst_2 : DivisionRing S] [inst_3 : Module R E] [inst_4 : Module S E] (r : ℚ) (x : E), ↑r • x = ↑r • x",
  "name": "rat_cast_smul_eq",
  "kind": "theorem",
  "doc_string":
  "If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\nagree on rational numbers in `R` and `S`. ",
  "args": ""},
 {"type":
  "Type u_1 →\n  (M : outParam (Type u_2)) →\n    (N : outParam (Type u_3)) → [inst : MulZeroOneClass M] → [inst : MulZeroOneClass N] → Type (max (max u_1 u_2) u_3)",
  "name": "MonoidWithZeroHomClass",
  "kind": "inductive",
  "doc_string":
  "`MonoidWithZeroHomClass F M N` states that `F` is a type of\n`MonoidWithZero`-preserving homomorphisms.\n\nYou should also extend this typeclass when you extend `MonoidWithZeroHom`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedCommSemiring α] (a b : α), min a b = if a ≤ b then a else b",
  "name": "LinearOrderedCommSemiring.min_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `minOfLe`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      {δ : Type u_4} →\n        [inst : Preorder α] →\n          [inst_1 : Preorder β] → [inst_2 : Preorder γ] → [inst_3 : Preorder δ] → (α →o β) → (γ →o δ) → α × γ →o β × δ",
  "name": "OrderHom.prodMap",
  "kind": "def",
  "doc_string": "`Prod.map` of two `OrderHom`s as a `OrderHom`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b → a < b ∨ a = b",
  "name": "LE.le.lt_or_eq_dec",
  "kind": "theorem",
  "doc_string": "**Alias** of `Decidable.lt_or_eq_of_le`.",
  "args": ""},
 {"type": "{α : Type u_1} → List (List α) → List (List α)",
  "name": "List.sectionsTR",
  "kind": "def",
  "doc_string": "Optimized version of `sections`. ",
  "args": ""},
 {"type":
  "{M' : Type u_1} →\n  {α : Type u_2} →\n    [inst : Monoid M'] →\n      [inst_1 : Monoid α] →\n        [inst_2 : MulDistribMulAction M' α] → (S : Submonoid M') → MulDistribMulAction { x // x ∈ S } α",
  "name":
  "Submonoid.instMulDistribMulActionSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidToMonoid",
  "kind": "def",
  "doc_string":
  "The action by a submonoid is the action by the underlying monoid. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "LinearOrderedCommMonoid",
  "kind": "inductive",
  "doc_string": "A linearly ordered commutative monoid. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "Function.«term_↪_»",
  "kind": "def",
  "doc_string": "An embedding, a.k.a. a bundled injective function. ",
  "args": ""},
 {"type":
  "Lean.Syntax → optParam Bool false → Lean.Elab.Tactic.TacticM Lean.Meta.Simp.Context",
  "name": "Mathlib.Meta.NormNum.getSimpContext",
  "kind": "def",
  "doc_string": "Constructs a simp context from the simp argument syntax. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Ring α] → Type u_1",
  "name": "Ring.PositiveCone",
  "kind": "inductive",
  "doc_string":
  "A positive cone in a ring consists of a positive cone in underlying `AddCommGroup`,\nwhich contains `1` and such that the positive elements are closed under multiplication. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "CompleteLattice",
  "kind": "inductive",
  "doc_string":
  "A complete lattice is a bounded lattice which has supᵢema and infima for every subset. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {γ : Type w} →\n    [inst : CommSemiring α] →\n      [inst_1 : Zero γ] →\n        [inst_2 : One γ] →\n          [inst_3 : Add γ] →\n            [inst_4 : Mul γ] →\n              [inst_5 : SMul ℕ γ] →\n                [inst_6 : NatCast γ] →\n                  [inst_7 : Pow γ ℕ] →\n                    (f : γ → α) →\n                      Function.Injective f →\n                        f 0 = 0 →\n                          f 1 = 1 →\n                            (∀ (x y : γ), f (x + y) = f x + f y) →\n                              (∀ (x y : γ), f (x * y) = f x * f y) →\n                                (∀ (x : γ) (n : ℕ), f (n • x) = n • f x) →\n                                  (∀ (x : γ) (n : ℕ), f (x ^ n) = f x ^ n) → (∀ (n : ℕ), f ↑n = ↑n) → CommSemiring γ",
  "name": "Function.Injective.commSemiring",
  "kind": "def",
  "doc_string":
  "Pullback a `CommSemiring` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : BEq α] [self : PartialEquivBEq α] {a b : α}, (a == b) = true → (b == a) = true",
  "name": "PartialEquivBEq.symm",
  "kind": "def",
  "doc_string": "Symmetry for `BEq`. If `a == b` then `b == a`. ",
  "args": ""},
 {"type": "{α : Type u} → {β : Type v} → (α → Option β) → List α → Option β",
  "name": "List.findSome?",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. `findSome? f l` applies `f` to each element of `l`, and returns the first non-`none` result.\n\n* `findSome? (fun x => if x < 5 then some (10 * x) else none) [7, 6, 5, 8, 1, 2, 6] = some 10`\n",
  "args": ""},
 {"type": "ℤ",
  "name": "Int.one",
  "kind": "def",
  "doc_string": "The number `1 : ℤ`, as a standalone definition. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddCommMonoid M] (h : Module ℕ M) (n : ℕ) (x : M), SMul.smul n x = n • x",
  "name": "nat_smul_eq_nsmul",
  "kind": "theorem",
  "doc_string":
  "Convert back any exotic `ℕ`-smul to the canonical instance. This should not be needed since in\nmathlib all `AddCommMonoid`s should normally have exactly one `ℕ`-module structure by design.\n",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : AddCancelMonoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 0 = 0 →\n                  (∀ (x y : M₁), f (x + y) = f x + f y) → (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) → AddCancelMonoid M₁",
  "name": "Function.Injective.addCancelMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `0` and `+` is an additive left cancel monoid,if it\nadmits an injective map that preserves `0` and `+` to an additive left cancel monoid.",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsIrrefl",
  "kind": "inductive",
  "doc_string":
  "`IsIrrefl X r` means the binary relation `r` on `X` is irreflexive (that is, `r x x` never\nholds). ",
  "args": ""},
 {"type": "ByteArray → ByteSlice",
  "name": "ByteArray.toSlice",
  "kind": "def",
  "doc_string": "Convert a byte array into a byte slice. ",
  "args": ""},
 {"type": "{α : Type u} → [inst : LT α] → List α → List α → Prop",
  "name": "List.lt",
  "kind": "inductive",
  "doc_string":
  "The lexicographic order on lists.\n`[] < a::as`, and `a::as < b::bs` if `a < b` or if `a` and `b` are equivalent and `as < bs`.\n",
  "args": ""},
 {"type": "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, Monotone (Set.image f)",
  "name": "Set.monotone_image",
  "kind": "theorem",
  "doc_string":
  "`Set.image` is monotone. See `Set.image_subset` for the statement in terms of `⊆`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term__[_]'_»",
  "kind": "def",
  "doc_string":
  "The syntax `arr[i]` gets the `i`'th element of the collection `arr`.\nIf there are proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\nThe actual behavior of this class is type-dependent,\nbut here are some important implementations:\n* `arr[i] : α` where `arr : Array α` and `i : Nat` or `i : USize`:\n  does array indexing with no bounds check and a proof side goal `i < arr.size`.\n* `l[i] : α` where `l : List α` and `i : Nat`: index into a list,\n  with proof side goal `i < l.length`.\n* `stx[i] : Syntax` where `stx : Syntax` and `i : Nat`: get a syntax argument,\n  no side goal (returns `.missing` out of range)\n\nThere are other variations on this syntax:\n* `arr[i]`: proves the proof side goal by `get_elem_tactic`\n* `arr[i]!`: panics if the side goal is false\n* `arr[i]?`: returns `none` if the side goal is false\n* `arr[i]'h`: uses `h` to prove the side goal\n",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      [inst : Preorder α] →\n        [inst_1 : Preorder β] →\n          [inst_2 : Preorder γ] →\n            [inst_3 : MulZeroOneClass α] →\n              [inst_4 : MulZeroOneClass β] → [inst_5 : MulZeroOneClass γ] → (β →*₀o γ) → (α →*₀o β) → α →*₀o γ",
  "name": "OrderMonoidWithZeroHom.comp",
  "kind": "def",
  "doc_string":
  "Composition of `OrderMonoidWithZeroHom`s as an `OrderMonoidWithZeroHom`. ",
  "args": ""},
 {"type": "Bool → ℕ → ℕ → ℕ",
  "name": "Nat.shiftl'",
  "kind": "def",
  "doc_string":
  "`shiftl' b m n` performs a left shift of `m` `n` times\nand adds the bit `b` as the least significant bit each time.\nReturns the corresponding natural number",
  "args": ""},
 {"type": "{α : Type u} → (l : List α) → l ≠ [] → Stream' α",
  "name": "Stream'.cycle",
  "kind": "def",
  "doc_string": "Interpret a nonempty list as a cyclic stream. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u₃} →\n          [inst_2 : CategoryTheory.Category E] →\n            (F : C ⥤ E) →\n              (G : D ⥤ E) →\n                [inst_3 : CategoryTheory.Faithful G] →\n                  (obj : C → D) →\n                    (∀ (X : C), Prefunctor.obj G.toPrefunctor (obj X) = Prefunctor.obj F.toPrefunctor X) →\n                      (map : {X Y : C} → (X ⟶ Y) → (obj X ⟶ obj Y)) →\n                        (∀ {X Y : C} {f : X ⟶ Y},\n                            HEq (Prefunctor.map G.toPrefunctor (map f)) (Prefunctor.map F.toPrefunctor f)) →\n                          C ⥤ D",
  "name": "CategoryTheory.Faithful.div",
  "kind": "def",
  "doc_string": "“Divide” a functor by a faithful functor. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, 1 < a → 1 < b → 1 < a * b",
  "name": "one_lt_mul''",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.one_lt_mul'`.",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : MulOneClass M] →\n    {A : Type u_2} → [inst_1 : SetLike A M] → [hA : SubmonoidClass A M] → (S' : A) → { x // x ∈ S' } →* M",
  "name": "SubmonoidClass.Subtype",
  "kind": "def",
  "doc_string":
  "The natural monoid hom from a submonoid of monoid `M` to `M`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_3} {N : Type u_4} {α : Type u_2} {β : Type u_1} [inst : VAdd M α] [inst_1 : VAdd β α]\n  [inst_2 : VAddCommClass M β α] (g : N → M), VAddCommClass N β α",
  "name": "VAdd.comp.vaddCommClass",
  "kind": "theorem",
  "doc_string":
  "This cannot be an instance because it can cause infinite loops whenever the `VAdd` arguments\nare still metavariables.",
  "args": ""},
 {"type":
  "∀ {E : Sort u_2} {α : Sort u_1} {β : Sort u_3} [iE : EquivLike E α β] (e : E) (a : α), EquivLike.inv e (↑e a) = a",
  "name": "EquivLike.inv_apply_apply",
  "kind": "theorem",
  "doc_string":
  "This lemma is only supposed to be used in the generic context, when working with instances\nof classes extending `EquivLike`.\nFor concrete isomorphism types such as `Equiv`, you should use `Equiv.symm_apply_apply`\nor its equivalent.\n\nTODO: define a generic form of `Equiv.symm`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.tacticBy_cases_",
  "kind": "def",
  "doc_string":
  "`by_cases p` makes a case distinction on `p`,\nresulting in two subgoals `h : p ⊢` and `h : ¬ p ⊢`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α] (n : ℕ) (a : α),\n  CanonicallyLinearOrderedSemifield.zpow (Int.negSucc n) a =\n    (CanonicallyLinearOrderedSemifield.zpow (↑(Nat.succ n)) a)⁻¹",
  "name": "CanonicallyLinearOrderedSemifield.zpow_neg'",
  "kind": "def",
  "doc_string": "`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` ",
  "args": ""},
 {"type":
  "{m : Type v → Type w} → [inst : Monad m] → {α : Type u_1} → {β : Type v} → (ℕ → β → α → m β) → β → List α → m β",
  "name": "List.foldlIdxM",
  "kind": "def",
  "doc_string": "Monadic variant of `foldlIdx`. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} →\n  {var : String} →\n    [inst : SlimCheck.SampleableExt α] →\n      {β : α → Prop} →\n        [inst : (x : α) → SlimCheck.Testable (β x)] → SlimCheck.Testable (SlimCheck.NamedBinder var (∀ (x : α), β x))",
  "name": "SlimCheck.Testable.varTestable",
  "kind": "def",
  "doc_string":
  "Test a universal property by creating a sample of the right type and instantiating the\nbound variable with it. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt f x → Function.IsFixedPt g x → Function.IsFixedPt (f ∘ g) x",
  "name": "Function.IsFixedPt.comp",
  "kind": "theorem",
  "doc_string":
  "If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ∘ g`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → Q(Type u) → Lean.MVarId → Array Lean.Syntax → Lean.MetaM Lean.MVarId",
  "name": "Mathlib.Tactic.Nontriviality.nontrivialityByElim",
  "kind": "def",
  "doc_string":
  "Tries to generate a `Nontrivial α` instance by performing case analysis on\n`subsingleton_or_nontrivial α`,\nattempting to discharge the subsingleton branch using lemmas with `@[nontriviality]` attribute,\nincluding `Subsingleton.le` and `eq_iff_true_of_subsingleton`.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : CommRing R] {x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : R},\n  (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2) * (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2) =\n    (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄) ^ 2 + (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃) ^ 2 +\n        (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂) ^ 2 +\n      (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁) ^ 2",
  "name": "sum_four_sq_mul_sum_four_sq",
  "kind": "theorem",
  "doc_string":
  "Euler's four-square identity, see <https://en.wikipedia.org/wiki/Euler%27s_four-square_identity>.\n\nThis sign choice here corresponds to the signs obtained by multiplying two quaternions.\n",
  "args": ""},
 {"type": "(lo hi : ℕ) → lo < hi → SlimCheck.Gen { a // lo ≤ a ∧ a < hi }",
  "name": "SlimCheck.Gen.chooseNatLt",
  "kind": "def",
  "doc_string": "Generate a `Nat` example between `x` and `y` (exclusively). ",
  "args": ""},
 {"type":
  "(S : Type u_1) → (M : outParam (Type u_2)) → [inst : Mul M] → [inst : SetLike S M] → Prop",
  "name": "MulMemClass",
  "kind": "inductive",
  "doc_string":
  "`MulMemClass S M` says `S` is a type of sets `s : Set M` that are closed under `(*)` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b : α}, a⁻¹ < b → b⁻¹ < a",
  "name": "inv_lt_of_inv_lt'",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `inv_lt'`.",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "stx_?",
  "kind": "def",
  "doc_string":
  "`(p)?` is shorthand for `optional(p)`. It uses parser `p` 0 or 1 times, and produces a\n`nullNode` containing the array of parsed results. This parser has arity 1.\n\n`p` is allowed to have arity n > 1 (in which case the node will have either 0 or n children),\nbut if it has arity 0 then the result will be ambiguous.\n\nBecause `?` is an identifier character, `ident?` will not work as intended.\nYou have to write either `ident ?` or `(ident)?` for it to parse as the `?` combinator\napplied to the `ident` parser.\n",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⧸_»",
  "kind": "def",
  "doc_string": "Quotient notation based on the `HasQuotient` typeclass ",
  "args": ""},
 {"type": "(α : Sort u) → α ≃ Empty ≃ IsEmpty α",
  "name": "Equiv.equivEmptyEquiv",
  "kind": "def",
  "doc_string": "`α` is equivalent to an empty type iff `α` is empty. ",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HMul",
  "kind": "inductive",
  "doc_string":
  "The notation typeclass for heterogeneous multiplication.\nThis enables the notation `a * b : γ` where `a : α`, `b : β`.\n",
  "args": ""},
 {"type": "{α : Sort u} → (x a : α) → x = a → α",
  "name": "namedPattern",
  "kind": "def",
  "doc_string":
  "Auxiliary declaration used to implement named patterns like `x@h:p`. ",
  "args": ""},
 {"type": "{G : Type u} → [self : DivInvMonoid G] → ℤ → G → G",
  "name": "DivInvMonoid.zpow",
  "kind": "def",
  "doc_string":
  "The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Monoid α] (u₁ u₂ : αˣ), ↑(u₁ / u₂) = ↑u₁ /ₚ u₂",
  "name": "val_div_eq_divp",
  "kind": "theorem",
  "doc_string":
  "`field_simp` moves division inside `αˣ` to the right, and this lemma\nlifts the calculation to `α`.\n",
  "args": ""},
 {"type":
  "{M₂ : Type u_1} →\n  {M₁ : Type u_2} →\n    [inst : Inv M₁] →\n      [inst_1 : InvolutiveInv M₂] →\n        (f : M₁ → M₂) → Function.Injective f → (∀ (x : M₁), f x⁻¹ = (f x)⁻¹) → InvolutiveInv M₁",
  "name": "Function.Injective.involutiveInv",
  "kind": "def",
  "doc_string":
  "A type has an involutive inversion if it admits a surjective map that preserves `⁻¹` to a type\nwhich has an involutive inversion. See note [reducible non-instances] ",
  "args": ""},
 {"type": "{p q : Prop} → Unit ⊕' (p → q) → Unit ⊕' p → Unit ⊕' q",
  "name": "SlimCheck.TestResult.combine",
  "kind": "def",
  "doc_string": "Applicative combinator proof carrying test results. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {a : α} {n : ℤ}, Odd n → a < 0 → a ^ n < 0",
  "name": "Odd.zpow_neg",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `Odd.zpow_neg_iff`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : Ring α] → [inst_1 : Nontrivial α] → Ring.TotalPositiveCone α → LinearOrderedRing α",
  "name": "LinearOrderedRing.mkOfPositiveCone",
  "kind": "def",
  "doc_string":
  "Construct a `LinearOrderedRing` by\ndesignating a positive cone in an existing `Ring`. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0",
  "name": "mul_ne_zero_iff",
  "kind": "theorem",
  "doc_string":
  "If `α` has no zero divisors, then the product of two elements is nonzero iff both of them\nare nonzero. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Linarith.mkNonstrictIntProof",
  "kind": "def",
  "doc_string":
  "If `pf` is a proof of a strict inequality `(a : ℤ) < b`,\n`mkNonstrictIntProof pf` returns a proof of `a + 1 ≤ b`,\nand similarly if `pf` proves a negated weak inequality.\n",
  "args": ""},
 {"type": "{α : Type u_1} → TwoPointing α → TwoPointing α",
  "name": "TwoPointing.swap",
  "kind": "def",
  "doc_string": "Swaps the two pointed elements. ",
  "args": ""},
 {"type": "Lean.Expr → Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "Linarith.flipNegatedComparison",
  "kind": "def",
  "doc_string":
  "If `prf` is a proof of `¬ e`, where `e` is a comparison,\n`flipNegatedComparison prf e` flips the comparison in `e` and returns a proof.\nFor example, if `prf : ¬ a < b`, ``flipNegatedComparison prf q(a < b)`` returns a proof of `a ≥ b`.\n",
  "args": ""},
 {"type": "∀ {a : Prop}, ¬¬a ↔ a",
  "name": "not_not",
  "kind": "theorem",
  "doc_string":
  "The Double Negation Theorem: `¬ ¬ P` is equivalent to `P`.\nThe left-to-right direction, double negation elimination (DNE),\nis classically true but not constructively. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "OrderedAddCommMonoid",
  "kind": "inductive",
  "doc_string":
  "An ordered (additive) commutative monoid is a commutative monoid\nwith a partial order such that `a ≤ b → c + a ≤ c + b` (addition is monotone)\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {a b : α}, 0 < a → 0 < b → (a⁻¹ ≤ b⁻¹ ↔ b ≤ a)",
  "name": "inv_le_inv",
  "kind": "theorem",
  "doc_string":
  "See `inv_le_inv_of_le` for the implication from right-to-left with one fewer assumption. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → {δ : Type u_4} → (α → β → Prop) → (α → γ) → (β → δ) → γ → δ → Prop",
  "name": "Relation.Map",
  "kind": "def",
  "doc_string":
  "The map of a relation `r` through a pair of functions pushes the\nrelation to the codomains of the functions.  The resulting relation is\ndefined by having pairs of terms related if they have preimages\nrelated by `r`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → List α → List α → List α",
  "name": "List.bagInter",
  "kind": "def",
  "doc_string":
  "Computes the \"bag intersection\" of `l₁` and `l₂`, that is,\nthe collection of elements of `l₁` which are also in `l₂`. As each element\nis identified, it is removed from `l₂`, so elements are counted with multiplicity.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddZeroClass M] → CompleteLattice (AddSubmonoid M)",
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid",
  "kind": "def",
  "doc_string":
  "The `AddSubmonoid`s of an `AddMonoid` form a complete lattice.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Abel.tacticAbel_nf!___",
  "kind": "def",
  "doc_string":
  "Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} {β : Type v} (f : α → β), Vector.map f Vector.nil = Vector.nil",
  "name": "Vector.map_nil",
  "kind": "theorem",
  "doc_string": "A `nil` vector maps to a `nil` vector. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {R : Type u_2} → {M : Type u_3} → [inst : VAdd R M] → VAdd R (ι → M)",
  "name": "Function.hasVAdd",
  "kind": "def",
  "doc_string":
  "Non-dependent version of `Pi.vadd`. Lean gets confused by the dependent instance\nif this is not present.",
  "args": ""},
 {"type":
  "∀ {G : Type u_1} {H : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Group H] [inst_2 : Monoid M]\n  [inst_3 : MulAction G M] [inst_4 : SMulCommClass G M M] [inst_5 : MulAction H M] [inst_6 : SMulCommClass H M M]\n  [inst_7 : IsScalarTower G M M] [inst_8 : IsScalarTower H M M] [inst_9 : SMulCommClass G H M], SMulCommClass G H Mˣ",
  "name": "Units.smulCommClass'",
  "kind": "def",
  "doc_string": "Transfer `SMulCommClass G H M` to `SMulCommClass G H Mˣ` ",
  "args": ""},
 {"type": "{M : Type u} → [inst : Zero M] → [inst : Add M] → ℕ → M → M",
  "name": "nsmulRec",
  "kind": "def",
  "doc_string":
  "The fundamental scalar multiplication in an additive monoid. `nsmulRec n a = a+a+...+a` n\ntimes. Use instead `n • a`, which has better definitional behavior. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {a b c : α}, b⁻¹ * a < c → a < b * c",
  "name": "lt_mul_of_inv_mul_lt_left",
  "kind": "theorem",
  "doc_string": "**Alias** of `lt_mul_of_inv_mul_lt`.",
  "args": ""},
 {"type":
  "∀ {F : Type u_1} {A : Type u_2} {B : Type u_3} {inst : Add A} {inst_1 : Add B} [self : AddEquivClass F A B] (f : F)\n  (a b : A), ↑f (a + b) = ↑f a + ↑f b",
  "name": "AddEquivClass.map_add",
  "kind": "def",
  "doc_string": "Preserves addition. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → [inst : Monoid R] → {S : Submonoid R} → [inst_1 : OreLocalization.OreSet S] → R → { x // x ∈ S } → R",
  "name": "OreLocalization.oreNum",
  "kind": "def",
  "doc_string": "The Ore numerator of a fraction. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : BEq α] → List α → List α",
  "name": "List.eraseDups",
  "kind": "def",
  "doc_string":
  "`O(|l|^2)`. Erase duplicated elements in the list.\nKeeps the first occurrence of duplicated elements.\n* `eraseDups [1, 3, 2, 2, 3, 5] = [1, 3, 2, 5]`\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → (p : α → Type v) → (q : α → Prop) → { y // q y.fst } ≃ (x : Subtype q) × p ↑x",
  "name": "Equiv.subtypeSigmaEquiv",
  "kind": "def",
  "doc_string": "A subtype of a sigma-type is a sigma-type over a subtype. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {F : Type u_3}\n  [mc : AddMonoidHomClass F M N] (f : F) (s : Set M),\n  AddSubmonoid.map f (AddSubmonoid.closure s) = AddSubmonoid.closure (↑f '' s)",
  "name": "AddMonoidHom.map_mclosure",
  "kind": "theorem",
  "doc_string":
  "The image under an `AddMonoid` hom of the `AddSubmonoid` generated by a set equals\nthe `AddSubmonoid` generated by the image of the set.",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        {E : Type u₃} → [inst_2 : CategoryTheory.Category E] → C ⥤ D → D ⥤ E → C ⥤ E",
  "name": "CategoryTheory.Functor.comp",
  "kind": "def",
  "doc_string":
  "`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).\n",
  "args": ""},
 {"type": "ℕ → ℤ → ℤ → ℕ → ℤ → ℤ → ℕ × ℤ × ℤ",
  "name": "Nat.xgcdAux",
  "kind": "def",
  "doc_string": "Helper function for the extended GCD algorithm (`Nat.xgcd`). ",
  "args": ""},
 {"type": "Linarith.Comp → Linarith.Ineq",
  "name": "Linarith.Comp.str",
  "kind": "def",
  "doc_string": "The strength of the comparison, `<`, `≤`, or `=`. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Prop",
  "name": "Monotone",
  "kind": "def",
  "doc_string": "A function `f` is monotone if `a ≤ b` implies `f a ≤ f b`. ",
  "args": ""},
 {"type": "(M : Type u_1) → (α : Type u_2) → [inst : VAdd M α] → Prop",
  "name": "AddAction.IsPretransitive",
  "kind": "inductive",
  "doc_string":
  "`M` acts pretransitively on `α` if for any `x y` there is `g` such that `g +ᵥ x = y`.\nA transitive action should furthermore have `α` nonempty. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "NatCast",
  "kind": "inductive",
  "doc_string": "Type class for the canonical homomorphism `Nat → R`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → (p q : α → Prop) → [inst : DecidablePred p] → { x // p x ∨ q x } ↪ { x // p x } ⊕ { x // q x }",
  "name": "subtypeOrLeftEmbedding",
  "kind": "def",
  "doc_string":
  "A subtype `{x // p x ∨ q x}` over a disjunction of `p q : α → Prop` can be injectively split\ninto a sum of subtypes `{x // p x} ⊕ {x // q x}` such that `¬ p x` is sent to the right. ",
  "args": ""},
 {"type": "Linarith.Preprocessor → Linarith.GlobalPreprocessor",
  "name": "Linarith.Preprocessor.globalize",
  "kind": "def",
  "doc_string":
  "A `Preprocessor` lifts to a `GlobalPreprocessor` by folding it over the input list.\n",
  "args": ""},
 {"type":
  "{R : Type u_1} → {S : Type u_2} → [inst : NonAssocSemiring R] → [inst_1 : NonAssocSemiring S] → R × S ≃+* S × R",
  "name": "RingEquiv.prodComm",
  "kind": "def",
  "doc_string": "Swapping components as an equivalence of (semi)rings. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → (α → m β) → Array α → m (Array β)",
  "name": "Array.mapM",
  "kind": "def",
  "doc_string": "Reference implementation for `mapM` ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a b c : α), a * (b + c) = a * b + a * c",
  "name": "NonUnitalNonAssocSemiring.left_distrib",
  "kind": "def",
  "doc_string": "Multiplication is left distributive over addition ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  {D : Type u₂} →\n    [inst : CategoryTheory.Category C] →\n      [inst_1 : CategoryTheory.Category D] →\n        (F : C ⥤ D) → CategoryTheory.Functor.toEssImage F ⋙ CategoryTheory.Functor.essImageInclusion F ≅ F",
  "name": "CategoryTheory.Functor.toEssImageCompEssentialImageInclusion",
  "kind": "def",
  "doc_string":
  "The functor `F` factorises through its essential image, where the first functor is essentially\nsurjective and the second is fully faithful.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : LinearOrderedAddCommMonoid α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "name": "LinearOrderedAddCommMonoid.add_le_add_left",
  "kind": "def",
  "doc_string": "Addition is monotone in an `OrderedAddCommMonoid`. ",
  "args": ""},
 {"type":
  "{M : Type → Type} → {α : Type} → [inst : Lean.MonadError M] → [inst : Monad M] → M α → M Lean.Exception",
  "name": "successIfFail",
  "kind": "def",
  "doc_string":
  "A generalisation of `fail_if_success` to an arbitrary `MonadError`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteLattice α] (s : Set α) (a : α), a ∈ s → infₛ s ≤ a",
  "name": "CompleteLattice.infₛ_le",
  "kind": "def",
  "doc_string": "Any element of a set is more than the set infimum. ",
  "args": ""},
 {"type": "∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] (a : G₀), a * a / a = a",
  "name": "mul_self_div_self",
  "kind": "theorem",
  "doc_string":
  "Multiplying `a` by itself and then dividing by itself results in `a`, whether or not `a` is\nzero. ",
  "args": ""},
 {"type":
  "{R : Type u_1} → {S : Type u_2} → [inst : NonAssocSemiring R] → [inst_1 : NonAssocSemiring S] → R ≃+* S → R →+* S",
  "name": "RingEquiv.toRingHom",
  "kind": "def",
  "doc_string": "Reinterpret a ring equivalence as a ring homomorphism. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : NonAssocSemiring R] (f : ℕ →+* R), f = Nat.castRingHom R",
  "name": "RingHom.eq_natCast'",
  "kind": "theorem",
  "doc_string": "This is primed to match `eq_intCast'`. ",
  "args": ""},
 {"type":
  "{ι : Type u_1} → {η : Type v} → (R : Type w) → (ι → η) → [inst : MulOneClass R] → (ι → R) →* η → R",
  "name": "Function.ExtendByOne.hom",
  "kind": "def",
  "doc_string": "`Function.extend s f 1` as a bundled hom. ",
  "args": ""},
 {"type": "{α : Type u_1} → AddAction (Additive (Function.End α)) α",
  "name": "AddAction.functionEnd",
  "kind": "def",
  "doc_string":
  "The tautological additive action by `Additive (Function.End α)` on `α`. ",
  "args": ""},
 {"type": "{K : Type u} → [self : Field K] → ℤ → K → K",
  "name": "Field.zpow",
  "kind": "def",
  "doc_string":
  "The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] {f g : M ≃* N}, (∀ (x : M), ↑f x = ↑g x) → f = g",
  "name": "MulEquiv.ext",
  "kind": "theorem",
  "doc_string":
  "Two multiplicative isomorphisms agree if they are defined by the\nsame underlying function. ",
  "args": ""},
 {"type":
  "{V : Type u_1} → [inst : Quiver V] → {a b : V} → (a ⟶ b) → Quiver.Path a b",
  "name": "Quiver.Hom.toPath",
  "kind": "def",
  "doc_string": "An arrow viewed as a path of length one. ",
  "args": ""},
 {"type": "∀ {a : Prop}, ¬¬a ↔ a",
  "name": "Classical.not_not",
  "kind": "theorem",
  "doc_string":
  "The Double Negation Theorem: `¬¬P` is equivalent to `P`.\nThe left-to-right direction, double negation elimination (DNE),\nis classically true but not constructively. ",
  "args": ""},
 {"type": "{α : Type u_1} → List (List α) → List (List α)",
  "name": "List.sections",
  "kind": "def",
  "doc_string":
  "List of all sections through a list of lists. A section\nof `[L₁, L₂, ..., Lₙ]` is a list whose first element comes from\n`L₁`, whose second element comes from `L₂`, and so on.\n",
  "args": ""},
 {"type": "{α : Type u_1} → α ≃ ℕ → α × α ≃ α",
  "name": "Equiv.prodEquivOfEquivNat",
  "kind": "def",
  "doc_string":
  "An equivalence between `α × α` and `α`, given that there is an equivalence between `α` and `ℕ`.\n",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsTotal",
  "kind": "inductive",
  "doc_string":
  "`IsTotal X r` means that the binary relation `r` on `X` is total, that is, that for any\n`x y : X` we have `r x y` or `r y x`.",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.max",
  "kind": "def",
  "doc_string":
  "`Nat.max a b` is the maximum of `a` and `b`:\n* if `a ≤ b` then `Nat.max a b = b`\n* if `b ≤ a` then `Nat.max a b = a`\n",
  "args": ""},
 {"type": "{α : Type u_1} → ForInStep α → α",
  "name": "ForInStep.run",
  "kind": "def",
  "doc_string":
  "Get the value out of a `ForInStep`.\nThis is usually done at the end of a `forIn` loop to scope the early exit to the loop body.\n",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {r : α → α → Prop},\n  WellFounded r →\n    ∀ {a bot : α} {C : β → Prop} {f : α → β},\n      (∀ (b : α), f b ≠ f bot → C (f b) → ∃ c, r c b ∧ C (f c)) → C (f a) → C (f bot)",
  "name": "WellFounded.induction_bot'",
  "kind": "theorem",
  "doc_string":
  "Let `r` be a well-founded relation on `α`, let `f : α → β` be a function,\nlet `C : β → Prop`, and  let `bot : α`.\nThis induction principle shows that `C (f bot)` holds, given that\n* some `a` satisfies `C (f a)`, and\n* for each `b` such that `f b ≠ f bot` and `C (f b)` holds, there is `c`\n  satisfying `r c b` and `C (f c)`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.classical!",
  "kind": "def",
  "doc_string":
  "`classical!` adds a proof of `Classical.propDecidable` as a local variable, which makes it\navailable for instance search and effectively makes all propositions decidable.\n```\nnoncomputable def foo : Bool := by\n  classical!\n  have := ∀ p, decide p -- uses the classical instance\n  exact decide (0 < 1) -- uses the classical instance even though `0 < 1` is decidable\n```\nConsider using `classical` instead if you want to use the decidable instance when available.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} → {N : Type u_2} → [inst : Zero M] → [inst_1 : Zero N] → Zero (ZeroHom M N)",
  "name": "instZeroZeroHom",
  "kind": "def",
  "doc_string": "`0` is the homomorphism sending all elements to `0`. ",
  "args": ""},
 {"type":
  "Lean.MVarId → Bool → Array Lean.Expr → optParam Bool false → Lean.MetaM (Option Lean.MVarId × Lean.Syntax)",
  "name": "Mathlib.Tactic.Polyrith.polyrith",
  "kind": "def",
  "doc_string":
  "This is the main body of the `polyrith` tactic. It takes in the following inputs:\n* `only : Bool` - This represents whether the user used the key word \"only\"\n* `hyps : Array Expr` - the hypotheses/proof terms selecteed by the user\n* `traceOnly : Bool` - If enabled, the returned syntax will be `.missing`\n\nFirst, the tactic converts the target into a `Poly`, and finds out what type it\nis an equality of. (It also fills up a list of `Expr`s with its atoms). Then, it\ncollects all the relevant hypotheses/proof terms from the context, and from those\nselected by the user, taking into account whether `only` is true. (The list of atoms is\nupdated accordingly as well).\n\nThis information is used to create a list of args that get used in a call to\nthe appropriate python file that executes a grobner basis computation. The\noutput of this computation is a `String` representing the certificate. This\nstring is parsed into a list of `Poly` objects that are then converted into\n`Expr`s (using the updated list of atoms).\n\nthe names of the hypotheses, along with the corresponding coefficients are\ngiven to `linear_combination`. If that tactic succeeds, the user is prompted\nto replace the call to `polyrith` with the appropriate call to\n`linear_combination`.\n\nThis returns `none` if this was a \"dry run\" attempt that does not actually invoke sage.\n",
  "args": ""},
 {"type":
  "∀ {P : ℤ → Prop} {m : ℤ}, P m → (∀ (n : ℤ), n ≤ m → P n → P (n - 1)) → ∀ (n : ℤ), n ≤ m → P n",
  "name": "Int.le_induction_down",
  "kind": "theorem",
  "doc_string": "See `Int.inductionOn'` for an induction in both directions. ",
  "args": ""},
 {"type":
  "{U : Type u_1} →\n  {V : Type u_2} →\n    [inst : Quiver U] →\n      [inst_1 : Quiver V] → [inst_2 : Quiver.HasReverse U] → [inst_3 : Quiver.HasReverse V] → U ⥤q V → Type",
  "name": "Prefunctor.MapReverse",
  "kind": "inductive",
  "doc_string": "A prefunctor preserving reversal of arrows ",
  "args": ""},
 {"type": "{V : Type u_1} → {W : Type u_2} → (V → W) → Type u_2",
  "name": "Quiver.Push",
  "kind": "def",
  "doc_string":
  "The `Quiver` instance obtained by pushing arrows of `V` along the map `σ : V → W` ",
  "args": ""},
 {"type":
  "{C : ℤ → Sort u} → (n : ℤ) → ((b : Bool) → (n : ℤ) → C (Int.bit b n)) → C n",
  "name": "Int.bitCasesOn",
  "kind": "def",
  "doc_string":
  "Defines a function from `ℤ` conditionally, if it is defined for odd and even integers separately\nusing `bit`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : OrderedCancelAddCommMonoid M] → (S : AddSubmonoid M) → OrderedCancelAddCommMonoid { x // x ∈ S }",
  "name": "AddSubmonoid.toOrderedCancelAddCommMonoid",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of an `OrderedCancelAddCommMonoid` is an `OrderedCancelAddCommMonoid`.",
  "args": ""},
 {"type": "ℕ → ℕ → ℤ",
  "name": "Nat.gcdA",
  "kind": "def",
  "doc_string":
  "The extended GCD `a` value in the equation `gcd x y = x * a + y * b`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] {a b : α}, a < b → ¬a ⋖ b → ∃ c, a < c ∧ c < b",
  "name": "exists_lt_lt_of_not_covby",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `not_covby_iff`.",
  "args": ""},
 {"type":
  "Lean.Meta.TransparencyMode → Linarith.ExprMap → Lean.Expr → Lean.MetaM (Linarith.ExprMap × Linarith.Sum)",
  "name": "Linarith.linearFormOfAtom",
  "kind": "def",
  "doc_string":
  "`linearFormOfAtom red map e` is the atomic case for `linear_form_of_expr`.\nIf `e` appears with index `k` in `map`, it returns the singleton sum `var k`.\nOtherwise it updates `map`, adding `e` with index `n`, and returns the singleton sum `var n`.\n",
  "args": ""},
 {"type": "Num → Num → Num",
  "name": "Num.mod",
  "kind": "def",
  "doc_string": "Modulus of `Num`s. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : OrderedCancelCommMonoid M] →\n    {A : Type u_2} →\n      [inst_1 : SetLike A M] → [inst : SubmonoidClass A M] → (S : A) → OrderedCancelCommMonoid { x // x ∈ S }",
  "name": "SubmonoidClass.toOrderedCancelCommMonoid",
  "kind": "def",
  "doc_string":
  "A submonoid of an `OrderedCancelCommMonoid` is an `OrderedCancelCommMonoid`. ",
  "args": ""},
 {"type": "{V : Type u} → [inst : Quiver V] → {a b : V} → Quiver.Path a b → ℕ",
  "name": "Quiver.Path.length",
  "kind": "def",
  "doc_string": "The length of a path is the number of arrows it uses. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {a b c : α} [inst : LinearOrder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α]\n  [inst_3 : OrderedSub α], a < b - c ↔ c + a < b",
  "name": "lt_tsub_iff_left",
  "kind": "theorem",
  "doc_string":
  "See `lt_tsub_iff_left_of_le` for a weaker statement in a partial order. ",
  "args": ""},
 {"type":
  "∀ {γ : Type w} [inst : SemilatticeInf γ] (a : γ) {s : Set γ}, BddBelow (insert a s) ↔ BddBelow s",
  "name": "bddBelow_insert",
  "kind": "theorem",
  "doc_string": "Adding a point to a set preserves its boundedness below.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«⨅_,_»",
  "kind": "def",
  "doc_string": "Indexed infimum. ",
  "args": ""},
 {"type": "(C : Type u₁) → [inst : CategoryTheory.Category C] → C ⥤ C",
  "name": "CategoryTheory.Functor.id",
  "kind": "def",
  "doc_string": "`𝟭 C` is the identity functor on a category `C`. ",
  "args": ""},
 {"type": "∀ {a b : Prop}, a → a ∨ b",
  "name": "Or.inl",
  "kind": "def",
  "doc_string":
  "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a ∨ b`. ",
  "args": ""},
 {"type": "{α : Type u_1} → Array α → ℕ → α → Array α",
  "name": "Array.insertAt!",
  "kind": "def",
  "doc_string":
  "Insert element `a` at position `i`. Panics if `i` is not `i ≤ as.size`. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : OrderedSemiring S] {R : Type u_2} [inst_1 : Semiring R] {f : R → S} [self : IsAbsoluteValue f]\n  (x y : R), f (x + y) ≤ f x + f y",
  "name": "IsAbsoluteValue.abv_add",
  "kind": "def",
  "doc_string": "The absolute value satisfies the triangle inequality ",
  "args": ""},
 {"type": "PosNum → ℕ",
  "name": "PosNum.natSize",
  "kind": "def",
  "doc_string": "The number of bits of a `PosNum`, as a `Nat`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [self : OreLocalization.OreSet S] (r₁ r₂ : R) (s : { x // x ∈ S }),\n  ↑s * r₁ = ↑s * r₂ → ∃ s', r₁ * ↑s' = r₂ * ↑s'",
  "name": "OreLocalization.OreSet.ore_left_cancel",
  "kind": "def",
  "doc_string":
  "Common factors on the left can be turned into common factors on the right, a weak form of\ncancellability. ",
  "args": ""},
 {"type": "{α : Type u} → List α → Bool",
  "name": "List.isEmpty",
  "kind": "def",
  "doc_string":
  "`O(1)`. `isEmpty l` is true if the list is empty.\n* `isEmpty [] = true`\n* `isEmpty [a] = false`\n* `isEmpty [a, b] = false`\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, ⊥ ⋖ a → IsAtom a",
  "name": "Covby.is_atom",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `bot_covby_iff`.",
  "args": ""},
 {"type": "ℕ → Option ℕ",
  "name": "Nat.ppred",
  "kind": "def",
  "doc_string":
  "Partial predecessor operation. Returns `ppred n = some m`\nif `n = m + 1`, otherwise `none`. ",
  "args": ""},
 {"type": "{α : Type u_1} → {o : Option α} → Decidable (o = none)",
  "name": "Option.decidable_eq_none",
  "kind": "def",
  "doc_string":
  "`o = none` is decidable even if the wrapped type does not have decidable equality.\nThis is not an instance because it is not definitionally equal to `instance : DecidableEq Option`.\nTry to use `o.isNone` or `o.isSome` instead.\n",
  "args": ""},
 {"type": "List Bool → Bool",
  "name": "List.or",
  "kind": "def",
  "doc_string":
  "`O(|l|)`. Returns true if `true` is an element of the list of booleans `l`.\n* `or [a, b, c] = a || b || c`\n",
  "args": ""},
 {"type":
  "∀ {M : Type u_2} [inst : Mul M] {N : Type u_1} [inst_1 : Mul N] (f : M →ₙ* N),\n  Function.Surjective ↑f → MulHom.srange f = ⊤",
  "name": "MulHom.srange_top_of_surjective",
  "kind": "theorem",
  "doc_string":
  "The range of a surjective semigroup hom is the whole of the codomain. ",
  "args": ""},
 {"type": "Mathlib.Tactic.Abel.Context → Lean.Expr",
  "name": "Mathlib.Tactic.Abel.Context.inst",
  "kind": "def",
  "doc_string": "The `AddCommGroup α` or `AddCommMonoid α` expression. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "OrOp",
  "kind": "inductive",
  "doc_string":
  "The homogeneous version of `HOr`: `a ||| b : α` where `a b : α`.\n(It is called `OrOp` because `Or` is taken for the propositional connective.)\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : DecidableEq α] (i j : α), Function.Involutive fun x => x * Equiv.swap i j",
  "name": "Equiv.mul_swap_involutive",
  "kind": "theorem",
  "doc_string": "A stronger version of `mul_left_injective` ",
  "args": ""},
 {"type": "{α : Type u} → [inst : Monoid α] → Group αˣ",
  "name": "Units.instGroupUnits",
  "kind": "def",
  "doc_string": "Units of a monoid form a group. ",
  "args": ""},
 {"type": "∀ (α : Type u_1), FaithfulSMul (Equiv.Perm α) α",
  "name": "Equiv.Perm.applyFaithfulSMul",
  "kind": "def",
  "doc_string": "`Equiv.Perm.applyMulAction` is faithful. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : MulOneClass M] (s : Set M) {p : (x : M) → x ∈ Submonoid.closure s → Prop},\n  (∀ (x : M) (h : x ∈ s), p x (_ : x ∈ ↑(Submonoid.closure s))) →\n    p 1 (_ : 1 ∈ Submonoid.closure s) →\n      (∀ (x : M) (hx : x ∈ Submonoid.closure s) (y : M) (hy : y ∈ Submonoid.closure s),\n          p x hx → p y hy → p (x * y) (_ : x * y ∈ Submonoid.closure s)) →\n        ∀ {x : M} (hx : x ∈ Submonoid.closure s), p x hx",
  "name": "Submonoid.closure_induction'",
  "kind": "theorem",
  "doc_string": "A dependent version of `Submonoid.closure_induction`.  ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "«term~~~_»",
  "kind": "def",
  "doc_string": "The implementation of `~~~a : α`. ",
  "args": ""},
 {"type": "Lean.Name → Lean.Name → Lean.CoreM Unit",
  "name": "ToAdditive.copyMetaData",
  "kind": "def",
  "doc_string": "Copies equation lemmas and attributes from `src` to `tgt`\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CanonicallyLinearOrderedAddMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α] {a b c : α}\n  [inst_3 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], c ≤ a → (a - c < b - c ↔ a < b)",
  "name": "tsub_lt_tsub_iff_right",
  "kind": "theorem",
  "doc_string":
  "This lemma also holds for `ENNReal`, but we need a different proof for that. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : MulOneClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b : α}, a < 1 → b ≤ 1 → a * b < 1",
  "name": "mul_lt_one_of_lt_of_le",
  "kind": "theorem",
  "doc_string": "**Alias** of `Left.mul_lt_one_of_lt_of_le`.",
  "args": ""},
 {"type": "∀ {α : Type u} {β : Type v}, (α ↪ β) → (β ↪ α) → Nonempty (α ≃ β)",
  "name": "Function.Embedding.antisymm",
  "kind": "theorem",
  "doc_string":
  "**The Schröder-Bernstein Theorem**: Given embeddings `α ↪ β` and `β ↪ α`, there exists an\nequivalence `α ≃ β`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : LT α] {a : α} {as : List α} {b : α} {bs : List α},\n  ¬a < b → ¬b < a → List.lt as bs → List.lt (a :: as) (b :: bs)",
  "name": "List.lt.tail",
  "kind": "def",
  "doc_string":
  "If `a` and `b` are equivalent and `as < bs`, then `a::as < b::bs`. ",
  "args": ""},
 {"type": "Mathlib.Meta.Positivity.PositivityExt",
  "name": "Mathlib.Meta.Positivity.evalMul",
  "kind": "def",
  "doc_string":
  "The `positivity` extension which identifies expressions of the form `a * b`,\nsuch that `positivity` successfully recognises both `a` and `b`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), max a b = if a ≤ b then b else a",
  "name": "LinearOrder.max_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `maxOfLe`. ",
  "args": ""},
 {"type": "(α : Sort u) → α → Sort u",
  "name": "optParam",
  "kind": "def",
  "doc_string":
  "Gadget for optional parameter support.\n\nA binder like `(x : α := default)` in a declaration is syntax sugar for\n`x : optParam α default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → {F : Type u_3} → [inst : Mul M] → [inst_1 : Mul N] → [inst_2 : MulHomClass F M N] → CoeTC F (M →ₙ* N)",
  "name": "instCoeTCMulHom",
  "kind": "def",
  "doc_string":
  "Any type satisfying `MulHomCLass` can be cast into `MulHom` via `MulHomClass.toMulHom`. ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "NonUnitalNonAssocRing",
  "kind": "inductive",
  "doc_string": "A not-necessarily-unital, not-necessarily-associative ring. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → {E : Q(«$α») → Type} → {e : Q(«$α»)} → Mathlib.Tactic.Ring.Result E e → Q(«$α»)",
  "name": "Mathlib.Tactic.Ring.Result.expr",
  "kind": "def",
  "doc_string": "The normalized result. ",
  "args": ""},
 {"type": "{B : Type u_1} → {E : B → Type u_2} → Bundle.TotalSpace E → B",
  "name": "Bundle.TotalSpace.proj",
  "kind": "def",
  "doc_string":
  "`bundle.TotalSpace.proj` is the canonical projection `Bundle.TotalSpace E → B` from the\ntotal space to the base space. ",
  "args": ""},
 {"type": "Lean.Name → Lean.ImportM Mathlib.Meta.Positivity.PositivityExt",
  "name": "Mathlib.Meta.Positivity.mkPositivityExt",
  "kind": "def",
  "doc_string":
  "Read a `positivity` extension from a declaration of the right type. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CanonicallyLinearOrderedMonoid α] (a b : α), max a b = if a ≤ b then b else a",
  "name": "CanonicallyLinearOrderedMonoid.max_def",
  "kind": "def",
  "doc_string":
  "The minimum function is equivalent to the one you get from `maxOfLe`. ",
  "args": ""},
 {"type": "ℕ",
  "name": "USize.size",
  "kind": "def",
  "doc_string":
  "The size of type `UInt16`, that is, `2^System.Platform.numBits`, which may\nbe either `2^32` or `2^64` depending on the platform's architecture.\n",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : LinearOrderedRing α] → α →*₀ α",
  "name": "absHom",
  "kind": "def",
  "doc_string": "`abs` as a `MonoidWithZeroHom`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, Mathlib.Meta.NormNum.IsNat a n → a = ↑n",
  "name": "Mathlib.Meta.NormNum.IsNat.out",
  "kind": "def",
  "doc_string": "The element is equal to the coercion of the natural number. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_3} {α' : Type u_5} {β : Type u_4} {γ : Type u_2} {δ : Type u_1} {f : α → β → γ} {s : Set α} {t : Set β}\n  {g : γ → δ} {f' : α' → β → δ} {g' : α → α'},\n  (∀ (a : α) (b : β), g (f a b) = f' (g' a) b) → g '' Set.image2 f s t = Set.image2 f' (g' '' s) t",
  "name": "Set.image_image2_distrib_left",
  "kind": "theorem",
  "doc_string": "Symmetric statement to `Set.image2_image_left_comm`. ",
  "args": ""},
 {"type": "Type u → outParam (Type u) → Type u",
  "name": "ToStream",
  "kind": "inductive",
  "doc_string":
  "Streams are used to implement parallel `for` statements.\nExample:\n```\nfor x in xs, y in ys do\n  ...\n```\nis expanded into\n```\nlet mut s := toStream ys\nfor x in xs do\n  match Stream.next? s with\n  | none => break\n  | some (y, s') =>\n    s := s'\n    ...\n```\n",
  "args": ""},
 {"type":
  "{α : Type u_1} → (s : Set α) → [inst : DecidablePred fun x => x ∈ s] → ↑s ⊕ ↑(sᶜ) ≃ α",
  "name": "Equiv.Set.sumCompl",
  "kind": "def",
  "doc_string":
  "If `s : Set α` is a set with decidable membership, then `s ⊕ sᶜ` is equivalent to `α`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b → a - b ≤ 0",
  "name": "sub_nonpos_of_le",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `sub_nonpos`.",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : HeytingAlgebra α] → GaloisInsertion (↑Heyting.Regular.toRegular) Heyting.Regular.val",
  "name": "Heyting.Regular.gi",
  "kind": "def",
  "doc_string": "The Galois insertion between `Regular.toRegular` and `coe`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1],\n  StrictAnti f → StrictAnti g → StrictAnti fun x => f x * g x",
  "name": "StrictAnti.mul'",
  "kind": "theorem",
  "doc_string":
  "The product of two strictly antitone functions is strictly antitone. ",
  "args": ""},
 {"type":
  "{M : Type uM} →\n  {N : Type uN} →\n    {P : Type uP} →\n      [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [inst_2 : AddCommMonoid P] → (M →+ N) → (N →+ P) →+ M →+ P",
  "name": "AddMonoidHom.compHom'",
  "kind": "def",
  "doc_string":
  "The expression `λ g m, g (f m)` as a `AddMonoidHom`.\nEquivalently, `(λ g, AddMonoidHom.comp g f)` as a `AddMonoidHom`.\n\nThis also exists in a `LinearMap` version, `LinearMap.lcomp`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : ConditionallyCompleteLinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "name": "ConditionallyCompleteLinearOrder.le_total",
  "kind": "def",
  "doc_string": "A `ConditionallyCompleteLinearOrder` is total. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} {s t : Set α}, s ⊂ t → s < t",
  "name": "HasSSubset.SSubset.lt",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `Set.lt_iff_ssubset`.",
  "args": ""},
 {"type":
  "∀ {R : Type u_2} {M : Type u_1} [inst : MonoidWithZero R] [inst_1 : Zero M] [inst_2 : MulActionWithZero R M]\n  [nM : Nontrivial M], ¬IsSMulRegular M 0",
  "name": "IsSMulRegular.not_zero",
  "kind": "theorem",
  "doc_string": "The `0` element is not `M`-regular, on a non-trivial module. ",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} {p₁ : α → Prop} {a : Type u_1} {p₂ : a → Prop} {y : m a} {q : a → Prop}\n  [inst : Applicative m] [inst_1 : LawfulApplicative m] {x : m α},\n  SatisfiesM p₁ x →\n    SatisfiesM p₂ y → (∀ {a_1 : α} {b : a}, p₁ a_1 → p₂ b → q b) → SatisfiesM q (SeqRight.seqRight x fun x => y)",
  "name": "SatisfiesM.seqRight",
  "kind": "theorem",
  "doc_string": "`SatisfiesM` distributes over `*>`, general version. ",
  "args": ""},
 {"type": "(α : Sort u) → α → ℕ",
  "name": "default.sizeOf",
  "kind": "def",
  "doc_string":
  "Every type `α` has a default `SizeOf` instance that just returns `0`\nfor every element of `α`.\n",
  "args": ""},
 {"type":
  "∀ {U : Type u_1} {V : Type u_2} [inst : Quiver U] [inst_1 : Quiver V] [inst_2 : Quiver.HasReverse U]\n  [inst_3 : Quiver.HasReverse V] {φ : U ⥤q V} [self : Prefunctor.MapReverse φ] {u v : U} (e : u ⟶ v),\n  Prefunctor.map φ (Quiver.reverse e) = Quiver.reverse (Prefunctor.map φ e)",
  "name": "Prefunctor.MapReverse.map_reverse'",
  "kind": "def",
  "doc_string": "The image of a reverse is the reverse of the image. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_|>_»",
  "kind": "def",
  "doc_string":
  "Haskell-like pipe operator `|>`. `x |> f` means the same as the same as `f x`,\nand it chains such that `x |> f |> g` is interpreted as `g (f x)`.\n",
  "args": ""},
 {"type":
  "∀ {v : Sat.Valuation} {c : Sat.Clause} {a : Prop}, Sat.Clause.reify v c a → Sat.Fmla.reify v (Sat.Fmla.one c) a",
  "name": "Sat.Fmla.reify_one",
  "kind": "theorem",
  "doc_string": "Reification of a single clause formula. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} → [inst : Mul M] → [inst_1 : Mul N] → (f : M ≃ N) → (∀ (x y : M), ↑f (x * y) = ↑f x * ↑f y) → M ≃* N",
  "name": "MulEquiv.mk'",
  "kind": "def",
  "doc_string":
  "Makes a multiplicative isomorphism from a bijection which preserves multiplication. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.nthRewriteSeq",
  "kind": "def",
  "doc_string":
  "`nth_rewrite` is a variant of `rewrite` that only changes the nth occurrence of the expression\nto be rewritten.\n\nNote: The occurrences are counted beginning with `1` and not `0`, this is different than in\nmathlib3. The translation will be handled by mathport. ",
  "args": ""},
 {"type": "∀ {a b c : Prop}, a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c)",
  "name": "and_or_right",
  "kind": "theorem",
  "doc_string": "`∨` distributes over `∧` (on the right). ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : DivisionCommMonoid α] → α × α →* α",
  "name": "divMonoidHom",
  "kind": "def",
  "doc_string": "Division as a monoid homomorphism. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {P : Type u_3} →\n      [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [inst_2 : AddZeroClass P] → (M →+ N) → (M →+ P) → M →+ N × P",
  "name": "AddMonoidHom.prod",
  "kind": "def",
  "doc_string":
  "Combine two `AddMonoidHom`s `f : M →+ N`, `g : M →+ P` into\n`f.prod g : M →+ N × P` given by `(f.prod g) x = (f x, g x)`",
  "args": ""},
 {"type": "{α : Type u₁} → {β : Type u₂} → (α → β → Prop) → Prop",
  "name": "Relator.LeftUnique",
  "kind": "def",
  "doc_string":
  "A relation is \"left unique\" if every element on the right is paired with at\nmost one element on the left. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → Rel α β → Set β → Set α",
  "name": "Rel.preimage",
  "kind": "def",
  "doc_string":
  "Preimage of a set under a relation `r`. Same as the image of `s` under `r.inv` ",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    {x : Q(«$α»)} →\n      {z : Q(ℤ)} →\n        (inst : autoParam Q(Ring «$α») _auto✝) →\n          ℤ → Q(Mathlib.Meta.NormNum.IsInt «$x» «$z») → Mathlib.Meta.NormNum.Result x",
  "name": "Mathlib.Meta.NormNum.Result.isInt",
  "kind": "def",
  "doc_string": "The result is `z : ℤ` and `proof : isNat x z`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {F : Type u_3} →\n      [inst : MulZeroOneClass M] →\n        [inst_1 : MulZeroOneClass N] → [inst_2 : MonoidWithZeroHomClass F M N] → CoeTC F (M →*₀ N)",
  "name": "instCoeTCMonoidWithZeroHom",
  "kind": "def",
  "doc_string":
  "Any type satisfying `MonoidWithZeroHomClass` can be cast into `MonoidWithZeroHom` via\n`MonoidWithZeroHomClass.toMonoidWithZeroHom`. ",
  "args": ""},
 {"type": "Sort u → Sort (max 1 u)",
  "name": "Hashable",
  "kind": "inductive",
  "doc_string": "A class for types that can be hashed into a `UInt64`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : AddZeroClass M] →\n    {N : Type u_2} → [inst_1 : AddZeroClass N] → (f : M →+ N) → M →+ { x // x ∈ AddMonoidHom.mrange f }",
  "name": "AddMonoidHom.mrangeRestrict",
  "kind": "def",
  "doc_string":
  "Restriction of an `AddMonoid` hom to its range interpreted as a submonoid.",
  "args": ""},
 {"type": "∀ {α : Type u} [inst : LinearOrder α], IsIdempotent α min",
  "name": "min_idem",
  "kind": "def",
  "doc_string": "An instance asserting that `min a a = a` ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : CancelCommMonoidWithZero α] → [self : GCDMonoid α] → α → α → α",
  "name": "GCDMonoid.lcm",
  "kind": "def",
  "doc_string": "The least common multiple between two elements. ",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : HeytingAlgebra α] → α →o Heyting.Regular α",
  "name": "Heyting.Regular.toRegular",
  "kind": "def",
  "doc_string":
  "**Regularization** of `a`. The smallest regular element greater than `a`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M) {x y : M}, x ∈ S → y ∈ S → x + y ∈ S",
  "name": "AddSubmonoid.add_mem",
  "kind": "theorem",
  "doc_string": "An `AddSubmonoid` is closed under addition.",
  "args": ""},
 {"type": "ℤ → ℤ",
  "name": "Int.div2",
  "kind": "def",
  "doc_string": "`div2 n = n/2`",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1],\n  StrictMono f → Monotone g → StrictMono fun x => f x + g x",
  "name": "StrictMono.add_monotone",
  "kind": "theorem",
  "doc_string":
  "The sum of a strictly monotone function and a monotone function is\nstrictly monotone.",
  "args": ""},
 {"type": "{α : Type u_1} → [inst : Mul α] → α → Prop",
  "name": "IsSquare",
  "kind": "def",
  "doc_string":
  "An element `a` of a type `α` with multiplication satisfies `IsSquare a` if `a = r * r`,\nfor some `r : α`. ",
  "args": ""},
 {"type": "Tactic.Alias.Target → Lean.Name",
  "name": "Tactic.Alias.Target.toName",
  "kind": "def",
  "doc_string": "The name underlying an alias target ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : OrderedCancelAddCommMonoid α] →\n    {β : Type u_1} →\n      [inst_1 : Zero β] →\n        [inst_2 : Add β] →\n          [inst_3 : SMul ℕ β] →\n            (f : β → α) →\n              Function.Injective f →\n                f 0 = 0 →\n                  (∀ (x y : β), f (x + y) = f x + f y) →\n                    (∀ (x : β) (n : ℕ), f (n • x) = n • f x) → OrderedCancelAddCommMonoid β",
  "name": "Function.Injective.orderedCancelAddCommMonoid",
  "kind": "def",
  "doc_string":
  "Pullback an `OrderedCancelAddCommMonoid` under an injective map.",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : DecidableEq β] → (x : β) → { e // ↑e none = x } ≃ (α ≃ { y // y ≠ x })",
  "name": "Equiv.optionSubtype",
  "kind": "def",
  "doc_string":
  "Equivalences between `Option α` and `β` that send `none` to `x` are equivalent to\nequivalences between `α` and `{y : β // y ≠ x}`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} [inst : AddMonoid M] (u : AddUnits M) (x : M), AddSemiconjBy (↑u) x (↑u + x + ↑(-u))",
  "name": "AddUnits.mk_addSemiconjBy",
  "kind": "theorem",
  "doc_string": "`a` semiconjugates `x` to `a + x + -a`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : AddCommGroup α] → (self : AddCommGroup.TotalPositiveCone α) → DecidablePred self.toPositiveCone.nonneg",
  "name": "AddCommGroup.TotalPositiveCone.nonnegDecidable",
  "kind": "def",
  "doc_string": "For any `a` the proposition `nonneg a` is decidable ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {s : Set α}, Set.Nontrivial s → Set.Nonempty (Set.offDiag s)",
  "name": "Set.Nontrivial.offDiag_nonempty",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `Set.offDiag_nonempty`.",
  "args": ""},
 {"type": "{α : Type u} → Set α → Type u",
  "name": "Set.Elem",
  "kind": "def",
  "doc_string": "Given the set `s`, `Elem s` is the `Type` of element of `s`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.nthRwSeq",
  "kind": "def",
  "doc_string":
  "`nth_rw` is like `nth_rewrite`, but also tries to close the goal by trying `rfl` afterwards.\n",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {F : Type u_3} →\n      [inst : Mul M] → [inst_1 : Mul N] → [inst_2 : MulHomClass F M N] → (f : F) → Function.Bijective ↑f → M ≃* N",
  "name": "MulEquiv.ofBijective",
  "kind": "def",
  "doc_string": "A bijective `Semigroup` homomorphism is an isomorphism ",
  "args": ""},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "name": "CategoryTheory.Bundled",
  "kind": "inductive",
  "doc_string":
  "`Bundled` is a type bundled with a type class instance for that type. Only\nthe type class is exposed as a parameter. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Prop",
  "name": "RightOrdContinuous",
  "kind": "def",
  "doc_string":
  "A function `f` between preorders is right order continuous if it preserves all infima.  We\ndefine it using `is_glb` instead of `Inf` so that the proof works both for complete lattices and\nconditionally complete lattices. ",
  "args": ""},
 {"type":
  "∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c",
  "name": "Int.eq_of_mod_eq_of_natAbs_sub_lt_natAbs",
  "kind": "theorem",
  "doc_string":
  "If two integers are congruent to a sufficiently large modulus,\nthey are equal. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_∉_»",
  "kind": "def",
  "doc_string":
  "`a ∉ b` is negated elementhood. It is notation for `¬ (a ∈ b)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} (e p : Equiv.Perm α), ↑(Equiv.permCongr e) p = e * p * e⁻¹",
  "name": "Equiv.Perm.permCongr_eq_mul",
  "kind": "theorem",
  "doc_string":
  "If `e` is also a permutation, we can write `permCongr`\ncompletely in terms of the group structure. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : Add M] →\n      [inst_1 : Add N] →\n        (f : AddHom M N) → (g : N → M) → Function.LeftInverse g ↑f → Function.RightInverse g ↑f → AddHom N M",
  "name": "AddHom.inverse",
  "kind": "def",
  "doc_string":
  "Makes an additive inverse from a bijection which preserves addition.",
  "args": ""},
 {"type": "ℕ → ℕ → Option ℕ",
  "name": "Nat.psub",
  "kind": "def",
  "doc_string":
  "Partial subtraction operation. Returns `psub m n = some k`\nif `m = n + k`, otherwise `none`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → ¬a < b → a = b",
  "name": "LE.le.eq_of_not_lt",
  "kind": "theorem",
  "doc_string": "**Alias** of `eq_of_le_of_not_lt`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    (f : α → β) →\n      {p : α → Prop} → {q : β → Prop} → (∀ (x : α), p x ↔ q (f x)) → (y : Subtype q) × { x // f x = ↑y } ≃ Subtype p",
  "name": "Equiv.sigmaSubtypeFiberEquivSubtype",
  "kind": "def",
  "doc_string":
  "If for each `x` we have `p x ↔ q (f x)`, then `Σ y : {y // q y}, f ⁻¹' {y}` is equivalent\nto `{x // p x}`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {f : α → α} {x : α}, StrictMono f → x < f x → StrictMono fun n => Nat.iterate f n x",
  "name": "StrictMono.strictMono_iterate_of_lt_map",
  "kind": "theorem",
  "doc_string":
  "If `f` is a strictly monotone map and `x < f x` at some point `x`, then the iterates `f^[n] x`\nform a strictly monotone sequence. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  [inst : CancelCommMonoidWithZero α] →\n    [inst_1 : DecidableEq α] →\n      (lcm : α → α → α) →\n        (∀ (a b : α), a ∣ lcm a b) →\n          (∀ (a b : α), b ∣ lcm a b) → (∀ {a b c : α}, c ∣ a → b ∣ a → lcm c b ∣ a) → GCDMonoid α",
  "name": "gcdMonoidOfLCM",
  "kind": "def",
  "doc_string":
  "Define `GCDMonoid` on a structure just from the `lcm` and its properties. ",
  "args": ""},
 {"type":
  "(V : Type u) → [inst : Quiver V] → [inst : Quiver.Arborescence V] → V",
  "name": "Quiver.root",
  "kind": "def",
  "doc_string": "The root of an arborescence. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, IsBot a → a = ⊥",
  "name": "IsBot.eq_bot",
  "kind": "theorem",
  "doc_string": "**Alias** of the forward direction of `isBot_iff_eq_bot`.",
  "args": ""},
 {"type": "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a : α), 0 * a = 0",
  "name": "NonUnitalNonAssocRing.zero_mul",
  "kind": "def",
  "doc_string": "Zero is a left absorbing element for multiplication ",
  "args": ""},
 {"type": "∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a",
  "name": "AddCommute.refl",
  "kind": "theorem",
  "doc_string": "Any element commutes with itself.",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "SlimCheck.Decorations.tacticMk_decorations",
  "kind": "def",
  "doc_string":
  "In a goal of the shape `⊢ DecorationsOf p`, `mk_decoration` examines\nthe syntax of `p` and adds `NamedBinder` around universal quantifications\nto improve error messages. This tool can be used in the declaration of a\nfunction as follows:\n```lean\ndef foo (p : Prop) (p' : Decorations.DecorationsOf p := by mk_decorations) [Testable p'] : ...\n```\n`p` is the parameter given by the user, `p'` is a definitionally equivalent\nproposition where the quantifiers are annotated with `NamedBinder`.\n",
  "args": ""},
 {"type":
  "{e : Q(ℕ)} → (self : Mathlib.Tactic.Ring.ExtractCoeff e) → Q(«$e» = dummy * dummy)",
  "name": "Mathlib.Tactic.Ring.ExtractCoeff.p",
  "kind": "def",
  "doc_string":
  "The proof that `e` splits into the coefficient `k` and the monic monomial `e'`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → α → Option α × BinaryHeap α lt",
  "name": "BinaryHeap.replaceMax",
  "kind": "def",
  "doc_string":
  "`O(log n)`. Equivalent to `(self.max, self.popMax.insert x)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] [self : SuccOrder α] {a b : α}, a < SuccOrder.succ b → a ≤ b",
  "name": "SuccOrder.le_of_lt_succ",
  "kind": "def",
  "doc_string":
  "Proof that `succ` satifies ordering invariants betweeen `LE` and `LT`",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Lattice α] [self : IsLowerModularLattice α] {a b : α}, a ⋖ a ⊔ b → a ⊓ b ⋖ b",
  "name": "IsLowerModularLattice.inf_covby_of_covby_sup",
  "kind": "def",
  "doc_string":
  "`a` and `b` both cover `a ⊓ b` if `a ⊔ b` covers either `a` or `b` ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {ι : Type u_2} →\n    {β : Type u_3} →\n      (S : ι → Set α) →\n        (f : (i : ι) → ↑(S i) → β) →\n          (∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j),\n              f i { val := x, property := hxi } = f j { val := x, property := hxj }) →\n            Set.unionᵢ S = Set.univ → α → β",
  "name": "Set.liftCover",
  "kind": "def",
  "doc_string":
  "Glue together functions defined on each of a collection `S` of sets that cover a type. See\nalso `Set.unionᵢLift`.   ",
  "args": ""},
 {"type": "ByteSliceT → ℕ → UInt8",
  "name": "ByteSliceT.getOp",
  "kind": "def",
  "doc_string":
  "Index into a byte slice. The `getOp` function allows the use of the `buf[i]` notation. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "tacticLinarith!_",
  "kind": "def",
  "doc_string":
  "`linarith` attempts to find a contradiction between hypotheses that are linear (in)equalities.\nEquivalently, it can prove a linear inequality by assuming its negation and proving `false`.\n\nIn theory, `linarith` should prove any goal that is true in the theory of linear arithmetic over\nthe rationals. While there is some special handling for non-dense orders like `nat` and `int`,\nthis tactic is not complete for these theories and will not prove every true goal. It will solve\ngoals over arbitrary types that instantiate `LinearOrderedCommRing`.\n\nAn example:\n```lean\nexample (x y z : ℚ) (h1 : 2*x  < 3*y) (h2 : -4*x + 2*z < 0)\n        (h3 : 12*y - 4* z < 0)  : false :=\nby linarith\n```\n\n`linarith` will use all appropriate hypotheses and the negation of the goal, if applicable.\n\n`linarith [t1, t2, t3]` will additionally use proof terms `t1, t2, t3`.\n\n`linarith only [h1, h2, h3, t1, t2, t3]` will use only the goal (if relevant), local hypotheses\n`h1`, `h2`, `h3`, and proofs `t1`, `t2`, `t3`. It will ignore the rest of the local context.\n\n`linarith!` will use a stronger reducibility setting to try to identify atoms. For example,\n```lean\nexample (x : ℚ) : id x ≥ x :=\nby linarith\n```\nwill fail, because `linarith` will not identify `x` and `id x`. `linarith!` will.\nThis can sometimes be expensive.\n\n`linarith (config := { .. })` takes a config object with five\noptional arguments:\n* `discharger` specifies a tactic to be used for reducing an algebraic equation in the\n  proof stage. The default is `ring`. Other options include `simp` for basic\n  problems.\n* `transparency` controls how hard `linarith` will try to match atoms to each other. By default\n  it will only unfold `reducible` definitions.\n* If `split_hypotheses` is true, `linarith` will split conjunctions in the context into separate\n  hypotheses.\n* If `exfalso` is false, `linarith` will fail when the goal is neither an inequality nor `false`.\n  (True by default.)\n* `restrict_type` (not yet implemented in mathlib4)\n  will only use hypotheses that are inequalities over `tp`. This is useful\n  if you have e.g. both integer and rational valued inequalities in the local context, which can\n  sometimes confuse the tactic.\n\nA variant, `nlinarith`, does some basic preprocessing to handle some nonlinear goals.\n\nThe option `set_option trace.linarith true` will trace certain intermediate stages of the `linarith`\nroutine.\n",
  "args": ""},
 {"type":
  "∀ {G : Type u} [self : DivInvMonoid G] (n : ℕ) (a : G),\n  DivInvMonoid.zpow (Int.ofNat (Nat.succ n)) a = a * DivInvMonoid.zpow (Int.ofNat n) a",
  "name": "DivInvMonoid.zpow_succ'",
  "kind": "def",
  "doc_string": "`a ^ (n + 1) = a * a ^ n` ",
  "args": ""},
 {"type":
  "{η : Type u_1} →\n  {Ms : η → Type u_2} →\n    {Ns : η → Type u_3} →\n      [inst : (j : η) → Add (Ms j)] →\n        [inst_1 : (j : η) → Add (Ns j)] → ((j : η) → Ms j ≃+ Ns j) → ((j : η) → Ms j) ≃+ ((j : η) → Ns j)",
  "name": "AddEquiv.piCongrRight",
  "kind": "def",
  "doc_string":
  "A family of additive equivalences `Π j, (Ms j ≃+ Ns j)`\ngenerates an additive equivalence between `Π j, Ms j` and `Π j, Ns j`.\n\nThis is the `AddEquiv` version of `Equiv.piCongrRight`, and the dependent version of\n`AddEquiv.arrowCongr`.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    (r : α → α → Prop) →\n      (s : β → β → Prop) →\n        [inst : IsIrrefl α r] → [inst : IsIrrefl β s] → [inst : Unique α] → [inst : Unique β] → r ≃r s",
  "name": "RelIso.relIsoOfUniqueOfIrrefl",
  "kind": "def",
  "doc_string": "Two irreflexive relations on a unique type are isomorphic. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : AddGroup α] [inst_1 : SubtractionMonoid β] (f : α →+ β) (g h : α),\n  ↑f (g - h) = ↑f g - ↑f h",
  "name": "AddMonoidHom.map_sub",
  "kind": "theorem",
  "doc_string": "Additive group homomorphisms preserve subtraction.",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : LE α] → [inst_1 : LE β] → α ≃o β → α ↪o β",
  "name": "OrderIso.toOrderEmbedding",
  "kind": "def",
  "doc_string": "Reinterpret an order isomorphism as an order embedding. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : NonAssocSemiring α] [inst_1 : NonAssocSemiring β] (self : α →+* β),\n  ↑↑↑self 0 = 0",
  "name": "RingHom.map_zero'",
  "kind": "def",
  "doc_string": "The proposition that the function preserves 0 ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α},\n  0 < a → 0 < b → 0 < a + b",
  "name": "Right.add_pos",
  "kind": "theorem",
  "doc_string":
  "Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos`.",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : MulZeroOneClass M] → M →*₀ M",
  "name": "MonoidWithZeroHom.id",
  "kind": "def",
  "doc_string": "The identity map from a `MonoidWithZero` to itself. ",
  "args": ""},
 {"type": "(α : Sort u) → [inst : IsEmpty α] → α ≃ Empty",
  "name": "Equiv.equivEmpty",
  "kind": "def",
  "doc_string":
  "If `α` is an empty type, then it is equivalent to the `Empty` type. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α},\n  BddBelow s → BddAbove s → Set.Nonempty s → infₛ s ≤ supₛ s",
  "name": "cinfₛ_le_csupₛ",
  "kind": "theorem",
  "doc_string":
  "If a set is bounded below and above, and nonempty, its infimum is less than or equal to\nits supremum.",
  "args": ""},
 {"type": "{α : Type u} → α → LazyList α",
  "name": "LazyList.singleton",
  "kind": "def",
  "doc_string": "The singleton lazy list.  ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → β) → [inst : LT β] → (WellFounded fun x x_1 => x < x_1) → [inst : Nonempty α] → α",
  "name": "Function.argmin",
  "kind": "def",
  "doc_string":
  "Given a function `f : α → β` where `β` carries a well-founded `<`, this is an element of `α`\nwhose image under `f` is minimal in the sense of `Function.not_lt_argmin`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : LinearOrder α] → [inst : BoundedOrder α] → BiheytingAlgebra α",
  "name": "LinearOrder.toBiheytingAlgebra",
  "kind": "def",
  "doc_string":
  "A bounded linear order is a bi-Heyting algebra by setting\n* `a ⇨ b = ⊤` if `a ≤ b` and `a ⇨ b = b` otherwise.\n* `a \\ b = ⊥` if `a ≤ b` and `a \\ b = a` otherwise. ",
  "args": ""},
 {"type":
  "{m : Type u_1 → Type u_2} → {α : Type u_1} → [inst : Monad m] → List α → (α → m α) → m (List α)",
  "name": "List.mapMonoM",
  "kind": "def",
  "doc_string":
  "Monomorphic `List.mapM`. The internal implementation uses pointer equality, and does not allocate a new list\nif the result of each `f a` is a pointer equal value `a`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {f g : β → α},\n  AntitoneOn f s → StrictAntiOn g s → StrictAntiOn (fun x => f x * g x) s",
  "name": "AntitoneOn.mul_strict_anti'",
  "kind": "theorem",
  "doc_string":
  "The product of a antitone function and a strictly antitone function is strictly antitone. ",
  "args": ""},
 {"type":
  "(V : Type u₁) → [inst : Quiver V] → (W : Type u₂) → [inst : Quiver W] → Sort (max (max (max (u₁ + 1) (u₂ + 1)) v₁) v₂)",
  "name": "Prefunctor",
  "kind": "inductive",
  "doc_string":
  "A morphism of quivers. As we will later have categorical functors extend this structure,\nwe call it a `Prefunctor`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : NonAssocRing α] →\n      [inst_1 : Zero β] →\n        [inst_2 : One β] →\n          [inst_3 : Add β] →\n            [inst_4 : Mul β] →\n              [inst_5 : Neg β] →\n                [inst_6 : Sub β] →\n                  [inst_7 : SMul ℕ β] →\n                    [inst_8 : SMul ℤ β] →\n                      [inst_9 : NatCast β] →\n                        [inst_10 : IntCast β] →\n                          (f : β → α) →\n                            Function.Injective f →\n                              f 0 = 0 →\n                                f 1 = 1 →\n                                  (∀ (x y : β), f (x + y) = f x + f y) →\n                                    (∀ (x y : β), f (x * y) = f x * f y) →\n                                      (∀ (x : β), f (-x) = -f x) →\n                                        (∀ (x y : β), f (x - y) = f x - f y) →\n                                          (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                                            (∀ (x : β) (n : ℤ), f (n • x) = n • f x) →\n                                              (∀ (n : ℕ), f ↑n = ↑n) → (∀ (n : ℤ), f ↑n = ↑n) → NonAssocRing β",
  "name": "Function.Injective.nonAssocRing",
  "kind": "def",
  "doc_string":
  "Pullback a `NonAssocRing` instance along an injective function.\nSee note [reducible non-instances]. ",
  "args": ""},
 {"type": "{n : ℕ} → (m : ℕ) → [inst : Fin2.IsLT m n] → Fin2 n",
  "name": "Fin2.ofNat'",
  "kind": "def",
  "doc_string":
  "Use type class inference to infer the boundedness proof, so that we can directly convert a\n`Nat` into a `Fin2 n`. This supports notation like `&1 : Fin 3`. ",
  "args": ""},
 {"type": "(α : Type u_1) → [inst : Preorder α] → [inst : PredOrder α] → Prop",
  "name": "IsPredArchimedean",
  "kind": "inductive",
  "doc_string":
  "A `PredOrder` is pred-archimedean if one can go from any two comparable elements by iterating\n`pred` ",
  "args": ""},
 {"type":
  "(α : Type u_1) → [H1 : PartialOrder α] → [H2 : SupSet α] → (∀ (s : Set α), IsLUB s (supₛ s)) → CompleteLattice α",
  "name": "completeLatticeOfSup",
  "kind": "def",
  "doc_string":
  "Create a `CompleteLattice` from a `PartialOrder` and `SupSet`\nthat returns the least upper bound of a set. Usually this constructor provides\npoor definitional equalities.  If other fields are known explicitly, they should be\nprovided; for example, if `inf` is known explicitly, construct the `CompleteLattice`\ninstance as\n```\ninstance : CompleteLattice my_T :=\n{ inf := better_inf,\n  le_inf := ...,\n  inf_le_right := ...,\n  inf_le_left := ...\n  -- don't care to fix sup, infₛ, bot, top\n  ..completeLatticeOfSup my_T _ }\n```\n",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₂] →\n      [inst_1 : CommSemigroup M₁] →\n        (f : M₁ → M₂) → Function.Surjective f → (∀ (x y : M₁), f (x * y) = f x * f y) → CommSemigroup M₂",
  "name": "Function.Surjective.commSemigroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `*` is a commutative semigroup, if it admits a surjective map that preserves\n`*` from a commutative semigroup. See note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{α : Sort u_1} → [h : Nonempty α] → [inst : Subsingleton α] → α ≃ PUnit",
  "name": "Equiv.punitOfNonemptyOfSubsingleton",
  "kind": "def",
  "doc_string":
  "A nonempty subsingleton type is (noncomputably) equivalent to `PUnit`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : Mul M] → {S T : Subsemigroup M} → S ≤ T → { x // x ∈ S } →ₙ* { x // x ∈ T }",
  "name": "Subsemigroup.inclusion",
  "kind": "def",
  "doc_string":
  "The semigroup hom associated to an inclusion of subsemigroups. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} → [inst : PartialOrder α] → [inst_1 : SemilatticeInf β] → GaloisCoinsertion l u → SemilatticeInf α",
  "name": "GaloisCoinsertion.liftSemilatticeInf",
  "kind": "def",
  "doc_string": "Lift the infima along a Galois coinsertion ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      {δ : Type u_4} →\n        {ε : Type u_5} → {ζ : Type u_6} → (α → β → γ → δ → ε → ζ) → List α → List β → List γ → List δ → List ε → List ζ",
  "name": "List.zipWith5",
  "kind": "def",
  "doc_string": "Quinary version of `list.zipWith`. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : CommSemigroup M₂] →\n        (f : M₁ → M₂) → Function.Injective f → (∀ (x y : M₁), f (x * y) = f x * f y) → CommSemigroup M₁",
  "name": "Function.Injective.commSemigroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `*` is a commutative semigroup, if it admits an injective map that\npreserves `*` to a commutative semigroup.  See note [reducible non-instances]. ",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "ConditionallyCompleteLattice",
  "kind": "inductive",
  "doc_string":
  "A conditionally complete lattice is a lattice in which\nevery nonempty subset which is bounded above has a supremum, and\nevery nonempty subset which is bounded below has an infimum.\nTypical examples are real numbers or natural numbers.\n\nTo differentiate the statements from the corresponding statements in (unconditional)\ncomplete lattices, we prefix infₛ and subₛ by a c everywhere. The same statements should\nhold in both worlds, sometimes with additional assumptions of nonemptiness or\nboundedness.",
  "args": ""},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1],\n  StrictMonoOn f s → MonotoneOn g s → StrictMonoOn (fun x => f x + g x) s",
  "name": "StrictMonoOn.add_monotone",
  "kind": "theorem",
  "doc_string":
  "The sum of a strictly monotone function and a monotone function is\nstrictly monotone.",
  "args": ""},
 {"type":
  "{M' : Type u_1} →\n  {α : Type u_2} →\n    [inst : Monoid M'] →\n      [inst_1 : AddMonoid α] → [inst_2 : DistribMulAction M' α] → (S : Submonoid M') → DistribMulAction { x // x ∈ S } α",
  "name":
  "Submonoid.instDistribMulActionSubtypeMemSubmonoidToMulOneClassInstMembershipInstSetLikeSubmonoidToMonoid",
  "kind": "def",
  "doc_string":
  "The action by a submonoid is the action by the underlying monoid. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : SuccOrder α] [inst_2 : Preorder β] {f : α → β},\n  Monotone f → Pairwise (Disjoint on fun n => Set.Ioc (f n) (f (Order.succ n)))",
  "name": "Monotone.pairwise_disjoint_on_Ioc_succ",
  "kind": "theorem",
  "doc_string":
  "If `α` is a linear succ order, `β` is a preorder, and `f : α → β` is a monotone function, then\nthe intervals `Set.Ioc (f n) (f (Order.succ n))` are pairwise disjoint. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), a ∈ s → infₛ s ≤ a",
  "name": "CompleteSemilatticeInf.infₛ_le",
  "kind": "def",
  "doc_string": "Any element of a set is more than the set infimum. ",
  "args": ""},
 {"type": "{α : Type u_1} → GaloisInsertion EqvGen.Setoid Setoid.Rel",
  "name": "Setoid.gi",
  "kind": "def",
  "doc_string":
  "There is a Galois insertion of equivalence relations on α into binary relations\non α, with equivalence closure the lower adjoint. ",
  "args": ""},
 {"type": "(Type u → Type w) → (Type v → Type u) → Type v → Type w",
  "name": "Functor.Comp",
  "kind": "def",
  "doc_string":
  "`Functor.Comp` is a wrapper around `Function.Comp` for types.\nIt prevents Lean's type class resolution mechanism from trying\na `Functor (Comp F id)` when `Functor F` would do. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {f g : α → α}, Monotone g → f ≤ g → ∀ (n : ℕ), f^[n] ≤ g^[n]",
  "name": "Monotone.le_iterate_of_le",
  "kind": "theorem",
  "doc_string": "If `f ≤ g` and `g` is monotone, then `f^[n] ≤ g^[n]`. ",
  "args": ""},
 {"type":
  "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category D] →\n        (F : C ⥤ D) →\n          (∀ (X Y : C) (f : Prefunctor.obj F.toPrefunctor X ⟶ Prefunctor.obj F.toPrefunctor Y),\n              ∃ p, Prefunctor.map F.toPrefunctor p = f) →\n            CategoryTheory.Full F",
  "name": "CategoryTheory.Functor.fullOfExists",
  "kind": "def",
  "doc_string":
  "Deduce that `F` is full from the existence of preimages, using choice. ",
  "args": ""},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Prop",
  "name": "StrictAnti",
  "kind": "def",
  "doc_string":
  "A function `f` is strictly antitone if `a < b` implies `f b < f a`. ",
  "args": ""},
 {"type":
  "{u : Lean.Level} → {α : Q(Type u)} → {sα : Q(CommSemiring «$α»)} → {e : Q(«$α»)} → Mathlib.Tactic.Ring.ExProd sα e → ℤ",
  "name": "Mathlib.Tactic.Ring.ExProd.coeff",
  "kind": "def",
  "doc_string": "Get the leading coefficient of a `ExProd`. ",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Int.«term-[_+1]»",
  "kind": "def",
  "doc_string":
  "`-[n+1]` is suggestive notation for `negSucc n`, which is the second constructor of\n`Int` for making strictly negative numbers by mapping `n : Nat` to `-(n + 1)`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : GCDMonoid α] (a b : α), gcd a b ∣ a",
  "name": "GCDMonoid.gcd_dvd_left",
  "kind": "def",
  "doc_string": "The GCD is a divisor of the first element. ",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        [inst_2 : MulOneClass α] → [inst_3 : MulOneClass β] → (f : α →*o β) → (f' : α → β) → f' = ↑f → α →*o β",
  "name": "OrderMonoidHom.copy",
  "kind": "def",
  "doc_string":
  "Copy of an `OrderMonoidHom` with a new `toFun` equal to the old one. Useful to fix\ndefinitional equalities. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R] [self : LeftDistribClass R] (a b c : R), a * (b + c) = a * b + a * c",
  "name": "LeftDistribClass.left_distrib",
  "kind": "def",
  "doc_string": "Multiplication is left distributive over addition ",
  "args": ""},
 {"type": "{α : Type u_1} → {a : α} → {s : Set α} → a ∈ s → Semiquot α",
  "name": "Semiquot.mk",
  "kind": "def",
  "doc_string": "Construct a `Semiquot α` from `h : a ∈ s` where `s : Set α`. ",
  "args": ""},
 {"type": "∀ {α : Type u_1} {s : Set α}, Set.range Subtype.val = s",
  "name": "Subtype.range_val",
  "kind": "theorem",
  "doc_string":
  "A variant of `range_coe`. Try to use `range_coe` if possible.\nThis version is useful when defining a new type that is defined as the subtype of something.\nIn that case, the coercion doesn't fire anymore. ",
  "args": ""},
 {"type":
  "{α : Sort u} → {β : Sort v} → {s : Setoid α} → Quotient s → (f : α → β) → (∀ (a b : α), a ≈ b → f a = f b) → β",
  "name": "Quotient.liftOn",
  "kind": "def",
  "doc_string":
  "The analogue of `Quot.liftOn`: if `f : α → β` respects the equivalence relation `≈`,\nthen it lifts to a function on `Quotient s` such that `lift (mk a) f h = f a`.\n",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} →\n    (sα : Q(CommSemiring «$α»)) →\n      {a b : Q(«$α»)} →\n        Mathlib.Tactic.Ring.ExProd sα a →\n          Mathlib.Tactic.Ring.ExProd sα b → Mathlib.Tactic.Ring.Result (Mathlib.Tactic.Ring.ExProd sα) q(«$a» * «$b»)",
  "name": "Mathlib.Tactic.Ring.evalMulProd",
  "kind": "opaque",
  "doc_string":
  "Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n",
  "args": ""},
 {"type":
  "{u : Lean.Level} →\n  {α : Q(Type u)} → {E : Q(«$α») → Type} → {e : Q(«$α»)} → (self : Mathlib.Tactic.Ring.Result E e) → Q(«$e» = dummy)",
  "name": "Mathlib.Tactic.Ring.Result.proof",
  "kind": "def",
  "doc_string":
  "A proof that the original expression is equal to the normalized result. ",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Mul M₁] →\n      [inst_1 : Semigroup M₂] →\n        (f : M₁ → M₂) → Function.Injective f → (∀ (x y : M₁), f (x * y) = f x * f y) → Semigroup M₁",
  "name": "Function.Injective.semigroup",
  "kind": "def",
  "doc_string":
  "A type endowed with `*` is a semigroup, if it admits an injective map that preserves `*` to\na semigroup. See note [reducible non-instances]. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  [inst : LinearOrderedAddCommMonoid M] → (S : AddSubmonoid M) → LinearOrderedAddCommMonoid { x // x ∈ S }",
  "name": "AddSubmonoid.toLinearOrderedAddCommMonoid",
  "kind": "def",
  "doc_string":
  "An `AddSubmonoid` of a `LinearOrderedAddCommMonoid` is a `LinearOrderedAddCommMonoid`.",
  "args": ""},
 {"type": "Type u_1 → Type u_1",
  "name": "Semifield",
  "kind": "inductive",
  "doc_string":
  "A `Semifield` is a `CommSemiring` with multiplicative inverses for nonzero elements. ",
  "args": ""},
 {"type":
  "{α : Type} → IO.Ref Mathlib.Tactic.Ring.State → Mathlib.Tactic.RingNF.Config → Mathlib.Tactic.RingNF.M α → Lean.MetaM α",
  "name": "Mathlib.Tactic.RingNF.M.run",
  "kind": "def",
  "doc_string":
  "Runs a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n",
  "args": ""},
 {"type": "Mathlib.Meta.Positivity.PositivityExt",
  "name": "Mathlib.Meta.Positivity.evalPow",
  "kind": "def",
  "doc_string":
  "The `positivity` extension which identifies expressions of the form `a ^ (b : ℕ)`,\nsuch that `positivity` successfully recognises both `a` and `b`. ",
  "args": ""},
 {"type": "Lean.TrailingParserDescr",
  "name": "«term_⊃_»",
  "kind": "def",
  "doc_string": "Strict superset relation: `a ⊃ b`  ",
  "args": ""},
 {"type":
  "∀ (M : Type u_2) {α : Type u_1} [inst : Monoid M] [inst_1 : MulAction M α], (fun x x_1 => x • x_1) 1 = id",
  "name": "one_smul_eq_id",
  "kind": "theorem",
  "doc_string": "`SMul` version of `one_mul_eq_id` ",
  "args": ""},
 {"type": "{α : Type u_1} → (α → α → α) → Option α → Option α → Option α",
  "name": "Option.liftOrGet",
  "kind": "def",
  "doc_string":
  "Two arguments failsafe function. Returns `f a b` if the inputs are `some a` and `some b`, and\n\"does nothing\" otherwise.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : StrictOrderedSemiring α] {a b c d : α} [inst_1 : ExistsAddOfLE α],\n  b ≤ a → d ≤ c → a • d + b • c ≤ a • c + b • d",
  "name": "mul_add_mul_le_mul_add_mul'",
  "kind": "theorem",
  "doc_string": "Binary **rearrangement inequality**. ",
  "args": ""},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {r : α → α → Prop} {a bot : α},\n  Acc r a →\n    ∀ {C : β → Prop} {f : α → β}, (∀ (b : α), f b ≠ f bot → C (f b) → ∃ c, r c b ∧ C (f c)) → C (f a) → C (f bot)",
  "name": "Acc.induction_bot'",
  "kind": "theorem",
  "doc_string":
  "Let `r` be a relation on `α`, let `f : α → β` be a function, let `C : β → Prop`, and\nlet `bot : α`. This induction principle shows that `C (f bot)` holds, given that\n* some `a` that is accessible by `r` satisfies `C (f a)`, and\n* for each `b` such that `f b ≠ f bot` and `C (f b)` holds, there is `c`\n  satisfying `r c b` and `C (f c)`. ",
  "args": ""},
 {"type":
  "{M : Type u_1} → [inst : AddMonoid M] → (u : AddUnits M) → (a b : M) → a + b = ↑u → AddCommute a b → AddUnits M",
  "name": "AddUnits.leftOfAdd",
  "kind": "def",
  "doc_string":
  "If the sum of two commuting elements is an additive unit, then the left summand is\nan additive unit.",
  "args": ""},
 {"type": "Lean.Expr → Lean.MetaM Lean.Expr",
  "name": "ToAdditive.applyReplacementFun",
  "kind": "def",
  "doc_string":
  "`applyReplacementFun e` replaces the expression `e` with its additive counterpart.\nIt translates each identifier (inductive type, defined function etc) in an expression, unless\n* The identifier occurs in an application with first argument `arg`; and\n* `test arg` is false.\nHowever, if `f` is in the dictionary `relevant`, then the argument `relevant.find f`\nis tested, instead of the first argument.\n\nIt will also reorder arguments of certain functions, using `reorderFn`:\ne.g. `g x₁ x₂ x₃ ... xₙ` becomes `g x₂ x₁ x₃ ... xₙ` if `reorderFn g = some [1]`.\n",
  "args": ""},
 {"type": "(M : Type u_1) → [inst : Zero M] → ZeroHom M M",
  "name": "ZeroHom.id",
  "kind": "def",
  "doc_string": "The identity map from an type with zero to itself. ",
  "args": ""},
 {"type":
  "∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] [inst_1 : Nontrivial M₀] (u : M₀ˣ), ↑u ≠ 0",
  "name": "Units.ne_zero",
  "kind": "theorem",
  "doc_string":
  "An element of the unit group of a nonzero monoid with zero represented as an element\nof the monoid is nonzero. ",
  "args": ""},
 {"type": "Type",
  "name": "Nat",
  "kind": "inductive",
  "doc_string":
  "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
  "args": ""},
 {"type":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₂] →\n      [inst_1 : Zero M₂] →\n        [inst_2 : SMul ℕ M₂] →\n          [inst_3 : AddCommMonoid M₁] →\n            (f : M₁ → M₂) →\n              Function.Surjective f →\n                f 0 = 0 →\n                  (∀ (x y : M₁), f (x + y) = f x + f y) → (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) → AddCommMonoid M₂",
  "name": "Function.Surjective.addCommMonoid",
  "kind": "def",
  "doc_string":
  "A type endowed with `0` and `+` is an additive commutative monoid, if it\nadmits a surjective map that preserves `0` and `+` to an additive commutative monoid.",
  "args": ""},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {x : NonUnitalNonAssocSemiring α} →\n      {x_1 : NonUnitalNonAssocSemiring β} → (f : α →ₙ+* β) → (f' : α → β) → f' = ↑f → α →ₙ+* β",
  "name": "NonUnitalRingHom.copy",
  "kind": "def",
  "doc_string":
  "Copy of a `RingHom` with a new `toFun` equal to the old one. Useful to fix definitional\nequalities. ",
  "args": ""},
 {"type":
  "(Lean.Expr → Lean.MetaM Bool) → Lean.MVarId → optParam (Array Lean.MVarId) #[] → Lean.MetaM (Array Lean.MVarId)",
  "name": "Mathlib.Tactic.constructorMatching.go",
  "kind": "opaque",
  "doc_string":
  "Auxiliary for `constructorMatching`. Accumulates generated subgoals in `acc`. ",
  "args": ""},
 {"type": "Type u → Type (max u v)",
  "name": "Quiver",
  "kind": "inductive",
  "doc_string":
  "A quiver `G` on a type `V` of vertices assigns to every pair `a b : V` of vertices\na type `a ⟶ b` of arrows from `a` to `b`.\n\nFor graphs with no repeated edges, one can use `Quiver.{0} V`, which ensures\n`a ⟶ b : Prop`. For multigraphs, one can use `Quiver.{v+1} V`, which ensures\n`a ⟶ b : Type v`.\n\nBecause `Category` will later extend this class, we call the field `hom`.\nExcept when constructing instances, you should rarely see this, and use the `⟶` notation instead.\n",
  "args": ""},
 {"type": "Lean.Elab.Command.CommandElab",
  "name": "Mathlib.Prelude.Rename.elabNoAlign",
  "kind": "def",
  "doc_string": "Elaborate a `#noalign` command. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → {δ : Type u_4} → (α ↪ β) → (γ ↪ δ) → α × γ ↪ β × δ",
  "name": "Function.Embedding.prodMap",
  "kind": "def",
  "doc_string":
  "If `e₁` and `e₂` are embeddings, then so is `prod.map e₁ e₂ : (a, b) ↦ (e₁ a, e₂ b)`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LE α] {a : α}, IsMax a → IsMin (↑OrderDual.toDual a)",
  "name": "IsMax.toDual",
  "kind": "theorem",
  "doc_string": "**Alias** of the reverse direction of `isMin_toDual_iff`.",
  "args": ""},
 {"type":
  "{α₁ : Sort u_1} → {β₁ : Sort u_2} → {α₂ : Sort u_3} → {β₂ : Sort u_4} → α₁ ≃ α₂ → β₁ ≃ β₂ → (α₁ → β₁) ≃ (α₂ → β₂)",
  "name": "Equiv.arrowCongr",
  "kind": "def",
  "doc_string":
  "If `α₁` is equivalent to `α₂` and `β₁` is equivalent to `β₂`, then the type of maps `α₁ → β₁`\nis equivalent to the type of maps `α₂ → β₂`. ",
  "args": ""},
 {"type": "{α : Sort u} → (α → α → Prop) → Type",
  "name": "Antisymm",
  "kind": "inductive",
  "doc_string":
  "`Antisymm (·≤·)` says that `(·≤·)` is antisymmetric, that is, `a ≤ b → b ≤ a → a = b`.\n",
  "args": ""},
 {"type":
  "∀ {α : Type u_4} {α' : Type u_6} {β : Type u_5} {β' : Type u_7} {γ : Type u_3} {δ : Type u_2} {ε : Type u_1} {s : Set α}\n  {t : Set β} {u : Set γ} {f : δ → γ → ε} {g : α → β → δ} {f₁ : α → γ → α'} {f₂ : β → γ → β'} {g' : α' → β' → ε},\n  (∀ (a : α) (b : β) (c : γ), f (g a b) c = g' (f₁ a c) (f₂ b c)) →\n    Set.image2 f (Set.image2 g s t) u ⊆ Set.image2 g' (Set.image2 f₁ s u) (Set.image2 f₂ t u)",
  "name": "Set.image2_distrib_subset_right",
  "kind": "theorem",
  "doc_string":
  "The other direction does not hold because of the `u`-`u` cross terms on the RHS. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : CanonicallyOrderedCommSemiring α] [inst_1 : Sub α] [inst_2 : OrderedSub α]\n  [inst_3 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (m n : ℕ), ↑(m - n) = ↑m - ↑n",
  "name": "Nat.cast_tsub",
  "kind": "theorem",
  "doc_string":
  "A version of `Nat.cast_sub` that works for `ℝ≥0` and `ℚ≥0`. Note that this proof doesn't work\nfor `ℕ∞` and `ℝ≥0∞`, so we use type-specific lemmas for these types. ",
  "args": ""},
 {"type":
  "{E : Sort u_1} → {α : Sort u_2} → {β : Sort u_3} → [self : EquivLike E α β] → E → β → α",
  "name": "EquivLike.inv",
  "kind": "def",
  "doc_string": "The coercion to a function in the backwards direction. ",
  "args": ""},
 {"type": "{G : Type u_1} → [inst : Add G] → G → G → G",
  "name": "rightAdd",
  "kind": "def",
  "doc_string": "`right_add g` denotes right addition by `g`",
  "args": ""},
 {"type": "Lean.ParserDescr",
  "name": "Mathlib.Tactic.Abel.abelConv",
  "kind": "def",
  "doc_string":
  "The tactic `abel` evaluates expressions in abelian groups.\nThis is the conv tactic version, which rewrites a target which is a abel equality to `True`.\n\nSee also the `abel` tactic.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u} [inst : Semiring R], IsField R → ∀ {a : R}, a ≠ 0 → ∃ b, a * b = 1",
  "name": "IsField.mul_inv_cancel",
  "kind": "def",
  "doc_string": "Nonzero elements have multiplicative inverses. ",
  "args": ""},
 {"type":
  "∀ {F : Sort u_1} {α : Sort u_2} {β : α → Sort u_3} [self : FunLike F α β], Function.Injective FunLike.coe",
  "name": "FunLike.coe_injective'",
  "kind": "def",
  "doc_string": "The coercion to functions must be injective. ",
  "args": ""},
 {"type":
  "{a : Lean.Level} → {α : Q(Type a)} → {e : Q(«$α»)} → Mathlib.Meta.NormNum.Result e → ℚ",
  "name": "Mathlib.Meta.NormNum.Result.toRat",
  "kind": "def",
  "doc_string":
  "Returns the rational number that is the result of norm_num evaluation. ",
  "args": ""},
 {"type": "{m : Type → Type v} → [inst : Monad m] → List (m Bool) → m Bool",
  "name": "List.andM",
  "kind": "def",
  "doc_string":
  "`andM xs` runs the actions in `xs`, returning true if all of them return\ntrue. `andM` short-circuits, so if an action returns false, later actions are\nnot run. ",
  "args": ""},
 {"type":
  "(M : Type u_1) → (N : Type u_2) → (α : Type u_3) → [inst : VAdd M N] → [inst : VAdd N α] → [inst : VAdd M α] → Prop",
  "name": "VAddAssocClass",
  "kind": "inductive",
  "doc_string":
  "An instance of `VAddAssocClass M N α` states that the additive action of `M` on `α` is\ndetermined by the additive actions of `M` on `N` and `N` on `α`. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [inst : DecidableEq α] → List α → List α → Option (List α)",
  "name": "List.getRest",
  "kind": "def",
  "doc_string":
  "`getRest l l₁` returns `some l₂` if `l = l₁ ++ l₂`.\nIf `l₁` is not a prefix of `l`, returns `none` ",
  "args": ""},
 {"type": "∀ {α : Sort u} {r : α → α → Prop} (a b : α), r a b → TC r a b",
  "name": "TC.base",
  "kind": "def",
  "doc_string":
  "If `r a b` then `r⁺ a b`. This is the base case of the transitive closure. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {a b : α}, 0 < a → 0 < b → (a⁻¹ ≤ b ↔ b⁻¹ ≤ a)",
  "name": "inv_le",
  "kind": "theorem",
  "doc_string":
  "In a linear ordered field, for positive `a` and `b` we have `a⁻¹ ≤ b ↔ b⁻¹ ≤ a`.\nSee also `inv_le_of_inv_le` for a one-sided implication with one fewer assumption. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {l : αᵒᵈ → βᵒᵈ} →\n          {u : βᵒᵈ → αᵒᵈ} →\n            GaloisInsertion l u →\n              GaloisCoinsertion (↑OrderDual.ofDual ∘ u ∘ ↑OrderDual.toDual) (↑OrderDual.ofDual ∘ l ∘ ↑OrderDual.toDual)",
  "name": "GaloisInsertion.ofDual",
  "kind": "def",
  "doc_string":
  "Make a `GaloisCoinsertion` between `α` and `β` from a `GaloisInsertion` between `αᵒᵈ` and\n`βᵒᵈ`. ",
  "args": ""},
 {"type":
  "{α : Type u} →\n  [inst : LinearOrderedCancelAddCommMonoid α] →\n    {β : Type u_1} →\n      [inst_1 : Zero β] →\n        [inst_2 : Add β] →\n          [inst_3 : SMul ℕ β] →\n            [inst_4 : HasSup β] →\n              [inst_5 : HasInf β] →\n                (f : β → α) →\n                  Function.Injective f →\n                    f 0 = 0 →\n                      (∀ (x y : β), f (x + y) = f x + f y) →\n                        (∀ (x : β) (n : ℕ), f (n • x) = n • f x) →\n                          (∀ (x y : β), f (x ⊔ y) = max (f x) (f y)) →\n                            (∀ (x y : β), f (x ⊓ y) = min (f x) (f y)) → LinearOrderedCancelAddCommMonoid β",
  "name": "Function.Injective.linearOrderedCancelAddCommMonoid",
  "kind": "def",
  "doc_string":
  "Pullback a `LinearOrderedCancelAddCommMonoid` under an injective map.",
  "args": ""},
 {"type": "(α : Type u) → (α → α → Prop) → Prop",
  "name": "IsLinearOrder",
  "kind": "inductive",
  "doc_string":
  "`IsLinearOrder X r` means that the binary relation `r` on `X` is a linear order, that is,\n`IsPartialOrder X r` and `IsTotal X r`. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} {M : Type u_2} [inst : MonoidWithZero R] [inst_1 : Zero M] [inst_2 : MulActionWithZero R M],\n  IsSMulRegular M 0 → Subsingleton M",
  "name": "IsSMulRegular.subsingleton",
  "kind": "theorem",
  "doc_string":
  "The element `0` is `M`-regular if and only if `M` is trivial. ",
  "args": ""},
 {"type": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "name": "DecidablePred",
  "kind": "def",
  "doc_string": "A decidable predicate. See `Decidable`. ",
  "args": ""},
 {"type": "Linarith.GlobalBranchingPreprocessor",
  "name": "Linarith.natToInt",
  "kind": "def",
  "doc_string":
  "If `h` is an equality or inequality between natural numbers,\n`natToInt` lifts this inequality to the integers.\nIt also adds the facts that the integers involved are nonnegative.\nTo avoid adding the same nonnegativity facts many times, it is a global preprocessor.\n ",
  "args": ""},
 {"type": "{α : Sort u} → {β : Sort v} → (α → β) → PLift α → PLift β",
  "name": "PLift.map",
  "kind": "def",
  "doc_string": "Functorial action. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : AddSemigroup R] {a b : R}, IsAddRightRegular (b + a) → IsAddRightRegular b",
  "name": "IsAddRightRegular.of_add",
  "kind": "theorem",
  "doc_string":
  "If an element `b` becomes add-right-regular after adding to it on the right\na add-right-regular element, then `b` is add-right-regular.",
  "args": ""},
 {"type":
  "{ι : Type u_1} →\n  {α : ι → Type u_2} →\n    [inst : PartialOrder ι] →\n      [inst_1 : OrderBot ι] →\n        [inst_2 : (i : ι) → Preorder (α i)] → [inst_3 : OrderBot (α ⊥)] → OrderBot (Lex ((i : ι) ×' α i))",
  "name": "PSigma.Lex.orderBot",
  "kind": "def",
  "doc_string": "The lexicographical linear order on a sigma type. ",
  "args": ""},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "name": "HAdd",
  "kind": "inductive",
  "doc_string":
  "The notation typeclass for heterogeneous addition.\nThis enables the notation `a + b : γ` where `a : α`, `b : β`.\n",
  "args": ""},
 {"type": "Lean.Syntax → Lean.Elab.TermElabM Simps.Config",
  "name": "elabSimpsConfig",
  "kind": "def",
  "doc_string": "Function elaborating Simps.Config ",
  "args": ""},
 {"type": "(M : Type u) → [inst : CommMonoid M] → M ≃* (Multiplicative ℕ →* M)",
  "name": "powersMulHom",
  "kind": "def",
  "doc_string":
  "If `M` is commutative, `powersHom` is a multiplicative equivalence. ",
  "args": ""},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Setoid α",
  "name": "Setoid.ker",
  "kind": "def",
  "doc_string": "The kernel of a function is an equivalence relation. ",
  "args": ""},
 {"type": "Linarith.Monom",
  "name": "Linarith.Monom.one",
  "kind": "def",
  "doc_string":
  "`1` is represented by the empty monomial, the product of no variables. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (r : α → α → Prop) → (s : β → β → Prop) → r ↪r Sum.LiftRel r s",
  "name": "RelEmbedding.sumLiftRelInl",
  "kind": "def",
  "doc_string": "`Sum.inl` as a relation embedding into `Sum.LiftRel r s`. ",
  "args": ""},
 {"type": "Type",
  "name": "ByteSliceT",
  "kind": "inductive",
  "doc_string": "A terminal byte slice, a suffix of a byte array. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a < b → 0 < c → a * c < b * c",
  "name": "StrictOrderedSemiring.mul_lt_mul_of_pos_right",
  "kind": "def",
  "doc_string":
  "Right multiplication by a positive element is strictly monotone. ",
  "args": ""},
 {"type": "ℕ → ℕ → ℕ",
  "name": "Nat.log",
  "kind": "def",
  "doc_string":
  "`log b n`, is the logarithm of natural number `n` in base `b`. It returns the largest `k : ℕ`\nsuch that `b^k ≤ n`, so if `b^k = n`, it returns exactly `k`. ",
  "args": ""},
 {"type":
  "∀ {S : Type u_1} [inst : Semigroup S] {a x y x' y' : S},\n  SemiconjBy a x y → SemiconjBy a x' y' → SemiconjBy a (x * x') (y * y')",
  "name": "SemiconjBy.mul_right",
  "kind": "theorem",
  "doc_string":
  "If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x * x'` to `y * y'`. ",
  "args": ""},
 {"type":
  "∀ {M : Type u_1} {N : Type u_2} [inst : One M] [inst_1 : One N] {f g : OneHom M N}, f = g ↔ ∀ (x : M), ↑f x = ↑g x",
  "name": "OneHom.ext_iff",
  "kind": "theorem",
  "doc_string": "Deprecated: use `FunLike.ext_iff` instead. ",
  "args": ""},
 {"type": "{α : Type u} → α → List α → Prop",
  "name": "List.Mem",
  "kind": "inductive",
  "doc_string":
  "`a ∈ l` is a predicate which asserts that `a` is in the list `l`.\nUnlike `elem`, this uses `=` instead of `==` and is suited for mathematical reasoning.\n* `a ∈ [x, y, z] ↔ a = x ∨ a = y ∨ a = z`\n",
  "args": ""},
 {"type": "{α : Type u} → {s : Set α} → Set.Nonempty s → α",
  "name": "Set.Nonempty.some",
  "kind": "def",
  "doc_string":
  "Extract a witness from `s.Nonempty`. This function might be used instead of case analysis\non the argument. Note that it makes a proof depend on the `Classical.choice` axiom. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → [self : LinearOrderedCommSemiring α] → DecidableRel fun x x_1 => x ≤ x_1",
  "name": "LinearOrderedCommSemiring.decidable_le",
  "kind": "def",
  "doc_string":
  "In a linearly ordered type, we assume the order relations are all decidable. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : CommRing R] {a b : R},\n  a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)",
  "name": "pow_four_add_four_mul_pow_four'",
  "kind": "theorem",
  "doc_string":
  "Sophie Germain's identity, see <https://www.cut-the-knot.org/blue/SophieGermainIdentity.shtml>.\n",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRightRegular a → IsRightRegular b → IsRightRegular (a * b)",
  "name": "IsRightRegular.mul",
  "kind": "theorem",
  "doc_string":
  "In a semigroup, the product of right-regular elements is right-regular. ",
  "args": ""},
 {"type": "{α : Type u} → [self : SDiff α] → α → α → α",
  "name": "SDiff.sdiff",
  "kind": "def",
  "doc_string":
  "`a \\ b` is the set difference of `a` and `b`,\nconsisting of all elements in `a` that are not in `b`.\n",
  "args": ""},
 {"type": "{α : Type u_1} → [self : HNot α] → α → α",
  "name": "HNot.hnot",
  "kind": "def",
  "doc_string": "Heyting negation `￢` ",
  "args": ""},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} {p q : α → Prop} [inst : Functor m] [inst_1 : LawfulFunctor m] {x : m α},\n  SatisfiesM p x → (∀ {a : α}, p a → q a) → SatisfiesM q x",
  "name": "SatisfiesM.imp",
  "kind": "theorem",
  "doc_string": "The `SatisfiesM p x` predicate is monotonic in `p`. ",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {f : α → β}, Set.InjOn f s → Function.Injective (Set.restrict s f)",
  "name": "Set.InjOn.injective",
  "kind": "theorem",
  "doc_string":
  "**Alias** of the forward direction of `Set.injOn_iff_injective`.",
  "args": ""},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β), Function.Injective f ↔ Setoid.ker f = ⊥",
  "name": "Setoid.injective_iff_ker_bot",
  "kind": "theorem",
  "doc_string":
  "A function from α to β is injective iff its kernel is the bottom element of the complete lattice\nof equivalence relations on α. ",
  "args": ""},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {s t : Set α}, BddBelow t → BddBelow (s ∩ t)",
  "name": "BddBelow.inter_of_right",
  "kind": "theorem",
  "doc_string": "If `t` is bounded, then so is `s ∩ t` ",
  "args": ""},
 {"type": "Type u → Type u",
  "name": "HasSubset",
  "kind": "inductive",
  "doc_string": "Notation type class for the subset relation `⊆`. ",
  "args": ""},
 {"type": "∀ {a b : Prop}, (a ↔ b) → (¬a ↔ ¬b)",
  "name": "Iff.not",
  "kind": "theorem",
  "doc_string": "**Alias** of `not_congr`.",
  "args": ""},
 {"type": "ℤ → Q(ℤ)",
  "name": "Mathlib.Meta.NormNum.mkRawIntLit",
  "kind": "def",
  "doc_string": "Represent an integer as a typed expression. ",
  "args": ""},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α ⊕ β ↪ γ) ≃ (f : α ↪ γ) × (β ↪ ↑(Set.range ↑fᶜ))",
  "name": "Equiv.sumEmbeddingEquivSigmaEmbeddingRestricted",
  "kind": "def",
  "doc_string":
  "A combination of the above results, allowing us to turn one embedding over a sum type\ninto two dependent embeddings, the second of which avoids any members of the range\nof the first. This is helpful for constructing larger embeddings out of smaller ones. ",
  "args": ""},
 {"type":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    {σ : Type u_3} →\n      [inst : Mul M] →\n        [inst_1 : Mul N] →\n          [inst_2 : SetLike σ N] →\n            [inst_3 : MulMemClass σ N] → (f : M →ₙ* N) → (S : σ) → (∀ (x : M), ↑f x ∈ S) → M →ₙ* { x // x ∈ S }",
  "name": "MulHom.codRestrict",
  "kind": "def",
  "doc_string":
  "Restriction of a semigroup hom to a subsemigroup of the codomain. ",
  "args": ""},
 {"type":
  "∀ {R : Type u_1} [inst : MulZeroClass R] {a : R} [inst_1 : Nontrivial R], IsRegular a → a ≠ 0",
  "name": "IsRegular.ne_zero",
  "kind": "theorem",
  "doc_string":
  "A regular element of a `Nontrivial` `MulZeroClass` is non-zero. ",
  "args": ""}]