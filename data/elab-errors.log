 : ∀ {α : Type u_1} {f : (a : α) → ENNReal} {s : Finset α} (h : Finset.sum s fun (a : α) ↦ f a = 1) (h' : ∀ (a : α) (x : ¬ a ∈ s) , f a = 0) {a : α} (ha : ¬ a ∈ s) , ↑ Pmf.ofFinset f s h h' a = 0
failed to synthesize instance
  AddCommMonoid Prop ; identifiers [α, u_1, f, a, α, ENNReal, s, Finset, α, h, Finset.sum, s, a, α, f, a, h', a, α, x, a, s, f, a, a, α, ha, a, s, Pmf.ofFinset, f, s, h, h', a] (during elaboration)

 : ∀ {α : Type u_1} {f : (a : α) → ENNReal} {s : Finset α} (h : Finset.sum s fun (a : α) ↦ f a = 1) (h' : ∀ (a : α) (x : ¬ a ∈ s) , f a = 0) {a : α} (ha : ¬ a ∈ s) , f a = 0
failed to synthesize instance
  AddCommMonoid Prop ; identifiers [α, u_1, f, a, α, ENNReal, s, Finset, α, h, Finset.sum, s, a, α, f, a, h', a, α, x, a, s, f, a, a, α, ha, a, s, f, a] (during elaboration)

 : ∀ {V : Type u_2} {W : Type u_3} {V₁ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W] [inst_2 : SeminormedAddCommGroup V₁] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W} (φ : NormedAddGroupHom V₁ V) (h : NormedAddGroupHom.comp f φ = NormedAddGroupHom.comp g φ) (C : ℝ) (hφ : ‖ φ ‖ ≤ C) , ‖ NormedAddGroupHom.Equalizer.lift φ h ‖ ≤ C
<input>:1:325: expected term

 : ∀ {V : Type u_2} {W : Type u_3} {V₁ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W] [inst_2 : SeminormedAddCommGroup V₁] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W} (φ : NormedAddGroupHom V₁ V) (h : NormedAddGroupHom.comp f φ = NormedAddGroupHom.comp g φ) (C : ℝ) (hφ : ‖ φ ‖ ≤ C) , ‖ φ ‖ ≤ C
<input>:1:325: expected term

{α : Type u_1} [MulOneClass α] [LT α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x * x_1 fun (x : α) (x_1 : α) ↦ x < x_1] [ContravariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x * x_1 fun (x : α) (x_1 : α) ↦ x < x_1] (a : α) {b : α}  : a < b * a ↔ 1 * a < b * a = a < b * a ↔ 1 * a < b * a
<input>:1:285: expected end of input

{α : Type u_1} [MulOneClass α] [LT α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x * x_1 fun (x : α) (x_1 : α) ↦ x < x_1] [ContravariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x * x_1 fun (x : α) (x_1 : α) ↦ x < x_1] (a : α) {b : α}  : a < b * a ↔ a < b * a
application type mismatch
  CovariantClass α α Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) → (y : ?m.20) → ?m.21 x y) →
    (y : ?m.20) → (x : ?m.19) → ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  α → α → α : Type u_1 ; identifiers [α, u_1, MulOneClass, α, LT, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, ContravariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, a, b, a, a, b, a] (during elaboration)

{α : Type u_1} [GeneralizedCoheytingAlgebra α] {a : α} {b : α} {c : α} (h : a ⊔ c ≤ b ⊔ c)  : a \ c ≤ b \ c = a \ c ≤ b \ c
<input>:1:108: expected end of input

{α : Type u_1} [GeneralizedCoheytingAlgebra α] {a : α} {b : α} {c : α} (h : a ⊔ c ≤ b ⊔ c)  : a ⊔ c \ c ≤ b \ c = a ⊔ c \ c ≤ b \ c
<input>:1:112: expected end of input

{n : ℕ} {f : Vector ℕ n →. ℕ} (pf : Nat.Partrec' f) {m : ℕ} {n : ℕ} {f : Vector ℕ n →. ℕ} (g : (a : Fin n) → Vector ℕ m →. ℕ) (a : Nat.Partrec' f) (a : ∀ (i : Fin n) , Nat.Partrec' g i) (a_ih : Partrec f) (a_ih_1 : ∀ (i : Fin n) , Partrec g i)  : ∀ (i : Fin n) , Partrec g i
application type mismatch
  Nat.Partrec' g
argument
  g
has type
  Fin n → Vector ℕ m →. ℕ : Type
but is expected to have type
  Vector ℕ ?m.51 →. ℕ : Type ; identifiers [n, f, Vector, n, pf, Nat.Partrec', f, m, n, f, Vector, n, g, a, Fin, n, Vector, m, a, Nat.Partrec', f, a, i, Fin, n, Nat.Partrec', g, i, a_ih, Partrec, f, a_ih_1, i, Fin, n, Partrec, g, i, i, Fin, n, Partrec, g, i] (during elaboration)

{α : Type u_1} {l : Filter α} {R : Type u_2} [Distrib R] (f : Filter.Germ l R) (g : Filter.Germ l R) (h : Filter.Germ l R) (f : (a : α) → R) (g : (a : α) → R) (h : (a : α) → R)  : f * g + h =ᶠ[l] f * g + f * h = f * g + h =ᶠ[l] f * g + f * h
application type mismatch
  f * g + h =ᶠ[l] ?m.81592 =ᶠ[l] f * g + f * h
argument
  ?m.81592 =ᶠ[l] f * g + f * h
has type
  Prop : Type
but is expected to have type
  α → R : Type (max u_2 u_1) ; identifiers [α, u_1, l, Filter, α, R, u_2, Distrib, R, f, Filter.Germ, l, R, g, Filter.Germ, l, R, h, Filter.Germ, l, R, f, a, α, R, g, a, α, R, h, a, α, R, f, g, h, l, f, g, f, h, f, g, h, l, f, g, f, h] (during elaboration)

{α : Type u_2} {β : Type u_1} [AddMonoid α] [AddAction α β] {a : β} (motive : (x : ↑ AddAction.orbit α a) → Prop) (x : ↑ AddAction.orbit α a) (h_1 : ∀ (b : β) (x : α) (hx : fun (x : α) ↦ x +ᵥ a x = b) , motive {val := ((b)) , property := (((Exists.intro x hx =: ∃ (y : α) , fun (x : α) ↦ x +ᵥ a y = b)))}) (val : β) (property : val ∈ AddAction.orbit α a)  : ∀ (w : α) (h : fun (x : α) ↦ x +ᵥ a w = val) , motive {val := ((val)) , property := ((Exists.intro w h))}
<input>:1:260: expected term

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inl h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)))  : Or.inl h_1 = subsingleton_or_nontrivial M₀
<input>:1:143: expected term

 : ∀ {G : Type u_1} [inst : AddGroup G] (self : AddSubgroup G) {x : G} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup AddSubgroup.toAddSubmonoid self) , - x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup AddSubgroup.toAddSubmonoid self
function expected at
  AddSubsemigroup.carrier ?m.79766 AddSubgroup.toAddSubmonoid
term has type
  Prop ; identifiers [G, u_1, inst, AddGroup, G, self, AddSubgroup, G, x, G, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, AddSubgroup.toAddSubmonoid, self, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, AddSubgroup.toAddSubmonoid, self] (during elaboration)

 : ∀ (G : Type u_1) [inst : AddGroup G] (self : AddSubgroup G) {x : G} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup self . 1) , - x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup self . 1
function expected at
  AddSubsemigroup.carrier ?m.79766 self
term has type
  Prop ; identifiers [G, u_1, inst, AddGroup, G, self, AddSubgroup, G, x, G, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, self, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, self] (during elaboration)

{K : Type v} {V : Type w} [Field K] [AddCommGroup V] [Module K V] (f : Module.End K V) (μs : Set K) (xs : (a : ↑ μs) → V) (h_eigenvec : ∀ (μ : ↑ μs) , Module.End.HasEigenvector f ↑ μ xs μ) (μ : {x : K // x ∈ μs})  : Module.End.HasEigenvector f ↑ μ xs μ
type mismatch
  μs
has type
  Set K : Type v
but is expected to have type
  Sort ?u.1398 : Type ?u.1398 ; identifiers [K, v, V, w, Field, K, AddCommGroup, V, Module, K, V, f, Module.End, K, V, μs, Set, K, xs, a, μs, V, h_eigenvec, μ, μs, Module.End.HasEigenvector, f, μ, xs, μ, μ, x, K, x, μs, Module.End.HasEigenvector, f, μ, xs, μ] (during elaboration)

{α : Type u_1} {β : Type u_2} {γ : Type u_3} [Primcodable α] [Primcodable β] [Primcodable γ] {p : (a : α) → Prop} {q : (a : β) → Prop} {r : (a : γ) → Prop} (x : p ≤₀ r) (x_1 : q ≤₀ r) (f : (a : α) → γ) (c₁ : Computable f) (h₁ : ∀ (a : α) , (p a : Prop) ↔ (r f a : Prop)) (g : (a : β) → γ) (c₂ : Computable g) (h₂ : ∀ (a : β) , (q a : Prop) ↔ (r g a : Prop)) (x : α ⊕ β) (val : α) (h : x = Sum.inl val)  : Sum.inl val = x
application type mismatch
  r f
argument
  f
has type
  α → γ : Type (max u_1 u_3)
but is expected to have type
  γ : Type u_3 ; identifiers [α, u_1, β, u_2, γ, u_3, Primcodable, α, Primcodable, β, Primcodable, γ, p, a, α, q, a, β, r, a, γ, x, p, r, x_1, q, r, f, a, α, γ, c₁, Computable, f, h₁, a, α, p, a, r, f, a, g, a, β, γ, c₂, Computable, g, h₂, a, β, q, a, r, g, a, x, α, β, val, α, h, x, Sum.inl, val, Sum.inl, val, x] (during elaboration)

{α : Type u_1} {β : Type u_2} {γ : Type u_3} [Primcodable α] [Primcodable β] [Primcodable γ] {p : (a : α) → Prop} {q : (a : β) → Prop} {r : (a : γ) → Prop} (x : p ≤₀ r) (x_1 : q ≤₀ r) (f : (a : α) → γ) (c₁ : Computable f) (h₁ : ∀ (a : α) , (p a : Prop) ↔ (r f a : Prop)) (g : (a : β) → γ) (c₂ : Computable g) (h₂ : ∀ (a : β) , (q a : Prop) ↔ (r g a : Prop)) (x : α ⊕ β) (val : α) (h : x = Sum.inl val)  : p val ↔ r f val
application type mismatch
  r f
argument
  f
has type
  α → γ : Type (max u_1 u_3)
but is expected to have type
  γ : Type u_3 ; identifiers [α, u_1, β, u_2, γ, u_3, Primcodable, α, Primcodable, β, Primcodable, γ, p, a, α, q, a, β, r, a, γ, x, p, r, x_1, q, r, f, a, α, γ, c₁, Computable, f, h₁, a, α, p, a, r, f, a, g, a, β, γ, c₂, Computable, g, h₂, a, β, q, a, r, g, a, x, α, β, val, α, h, x, Sum.inl, val, p, val, r, f, val] (during elaboration)

{R : Type u₁} [StrictOrderedSemiring R] {a : R} (h : 0 ≤ a) (ha : a ≤ 1) {i : ℕ} {j : ℕ} (hij : i ≤ j) (k : ℕ) (hk : j = i + k)  : a ^ j ≤ a ^ i = a ^ j ≤ a ^ i
<input>:1:145: expected end of input

{α : Type u_1} {β : Type u_2} {γ : Type u_3} [Primcodable α] [Primcodable β] [Primcodable γ] {p : (a : α) → Prop} {q : (a : β) → Prop} {r : (a : γ) → Prop} (x : p ≤₀ r) (x_1 : q ≤₀ r) (f : (a : α) → γ) (c₁ : Computable f) (h₁ : ∀ (a : α) , (p a : Prop) ↔ (r f a : Prop)) (g : (a : β) → γ) (c₂ : Computable g) (h₂ : ∀ (a : β) , (q a : Prop) ↔ (r g a : Prop)) (x : α ⊕ β) (val : β) (h : x = Sum.inr val)  : Sum.inr val = x
application type mismatch
  r f
argument
  f
has type
  α → γ : Type (max u_1 u_3)
but is expected to have type
  γ : Type u_3 ; identifiers [α, u_1, β, u_2, γ, u_3, Primcodable, α, Primcodable, β, Primcodable, γ, p, a, α, q, a, β, r, a, γ, x, p, r, x_1, q, r, f, a, α, γ, c₁, Computable, f, h₁, a, α, p, a, r, f, a, g, a, β, γ, c₂, Computable, g, h₂, a, β, q, a, r, g, a, x, α, β, val, β, h, x, Sum.inr, val, Sum.inr, val, x] (during elaboration)

{α : Type u_1} {β : Type u_2} {γ : Type u_3} [Primcodable α] [Primcodable β] [Primcodable γ] {p : (a : α) → Prop} {q : (a : β) → Prop} {r : (a : γ) → Prop} (x : p ≤₀ r) (x_1 : q ≤₀ r) (f : (a : α) → γ) (c₁ : Computable f) (h₁ : ∀ (a : α) , (p a : Prop) ↔ (r f a : Prop)) (g : (a : β) → γ) (c₂ : Computable g) (h₂ : ∀ (a : β) , (q a : Prop) ↔ (r g a : Prop)) (x : α ⊕ β) (val : β) (h : x = Sum.inr val)  : q val ↔ r g val
application type mismatch
  r f
argument
  f
has type
  α → γ : Type (max u_1 u_3)
but is expected to have type
  γ : Type u_3 ; identifiers [α, u_1, β, u_2, γ, u_3, Primcodable, α, Primcodable, β, Primcodable, γ, p, a, α, q, a, β, r, a, γ, x, p, r, x_1, q, r, f, a, α, γ, c₁, Computable, f, h₁, a, α, p, a, r, f, a, g, a, β, γ, c₂, Computable, g, h₂, a, β, q, a, r, g, a, x, α, β, val, β, h, x, Sum.inr, val, q, val, r, g, val] (during elaboration)

{α : Type u_1} {β : Type u_2} {γ : Type u_3} [Primcodable α] [Primcodable β] [Primcodable γ] {p : (a : α) → Prop} {q : (a : β) → Prop} {r : (a : γ) → Prop} (x : p ≤₀ r) (x_1 : q ≤₀ r) (f : (a : α) → γ) (c₁ : Computable f) (h₁ : ∀ (a : α) , (p a : Prop) ↔ (r f a : Prop)) (g : (a : β) → γ) (c₂ : Computable g) (h₂ : ∀ (a : β) , (q a : Prop) ↔ (r g a : Prop)) (x : α ⊕ β)  : x = x
application type mismatch
  r f
argument
  f
has type
  α → γ : Type (max u_1 u_3)
but is expected to have type
  γ : Type u_3 ; identifiers [α, u_1, β, u_2, γ, u_3, Primcodable, α, Primcodable, β, Primcodable, γ, p, a, α, q, a, β, r, a, γ, x, p, r, x_1, q, r, f, a, α, γ, c₁, Computable, f, h₁, a, α, p, a, r, f, a, g, a, β, γ, c₂, Computable, g, h₂, a, β, q, a, r, g, a, x, α, β, x, x] (during elaboration)

 : ∀ {α : Type u} [inst : SizeOf α] , sizeOf LazyList.nil = 1
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (LazyList ?m.6756) ; identifiers [α, u, inst, SizeOf, α, sizeOf, LazyList.nil] (during elaboration)

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inl h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a') (h : a' = a) (a' : M)  : a = a
<input>:1:143: expected term

 : ∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {f : (a : α) → β} (self : MeasurableEmbedding f) ⦃ s : Set α ⦄ (a : MeasurableSet s) , MeasurableSet f '' s
application type mismatch
  Set.image (MeasurableSet ?m.353)
argument
  MeasurableSet ?m.353
has type
  Prop : Type
but is expected to have type
  α → ?m.79608 self a : Type (max ?u.146 u_1) ; identifiers [α, u_1, β, u_2, inst, MeasurableSpace, α, inst_1, MeasurableSpace, β, f, a, α, β, self, MeasurableEmbedding, f, s, Set, α, a, MeasurableSet, s, MeasurableSet, f, s] (during elaboration)

 : ∀ (α : Type u_1) (β : Type u_2) [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] (f : (a : α) → β) (self : MeasurableEmbedding f) ⦃ s : Set α ⦄ (a : MeasurableSet s) , MeasurableSet f '' s
application type mismatch
  Set.image (MeasurableSet ?m.353)
argument
  MeasurableSet ?m.353
has type
  Prop : Type
but is expected to have type
  α → ?m.79608 α β f self a : Type (max ?u.146 u_1) ; identifiers [α, u_1, β, u_2, inst, MeasurableSpace, α, inst_1, MeasurableSpace, β, f, a, α, β, self, MeasurableEmbedding, f, s, Set, α, a, MeasurableSet, s, MeasurableSet, f, s] (during elaboration)

{G : Type u_1} [Group G] (H : Subgroup G) (a : G) (b : G)  : Setoid.Rel Doset.setoid ↑ Subgroup.toSubmonoid H ↑ ⊥ a b ↔ Setoid.Rel Doset.setoid ↑ Subgroup.toSubmonoid H ↑ ⊥ a b
function expected at
  Setoid.Rel ?m.80159 ?m.80160 H
term has type
  Prop ; identifiers [G, u_1, Group, G, H, Subgroup, G, a, G, b, G, Setoid.Rel, Doset.setoid, Subgroup.toSubmonoid, H, a, b, Setoid.Rel, Doset.setoid, Subgroup.toSubmonoid, H, a, b] (during elaboration)

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inl h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a') (h : a' = a)  : a = a'
<input>:1:143: expected term

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inl h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a')  : a' = a'
<input>:1:143: expected term

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Nontrivial M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inr h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)))  : Or.inr h_1 = subsingleton_or_nontrivial M₀
<input>:1:141: expected term

 : ∀ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] (self : SchwartzMap E F) , ContDiff ℝ ⊤ SchwartzMap.toFun self
function expected at
  ContDiff ℝ ⊤ SchwartzMap.toFun
term has type
  Prop ; identifiers [E, u_1, F, u_2, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, NormedAddCommGroup, F, inst_3, NormedSpace, F, self, SchwartzMap, E, F, ContDiff, SchwartzMap.toFun, self] (during elaboration)

 : ∀ (E : Type u_1) (F : Type u_2) [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] (self : SchwartzMap E F) , ContDiff ℝ ⊤ self . 1
function expected at
  ContDiff ℝ ⊤ ↑self
term has type
  Prop ; identifiers [E, u_1, F, u_2, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, NormedAddCommGroup, F, inst_3, NormedSpace, F, self, SchwartzMap, E, F, ContDiff, self] (during elaboration)

{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [Module 𝕜 E] (x : ConvexCone 𝕜 E) (x_1 : E) (x_2 : E)  : ∃ (x_3 : E) , x_2 = 0 ∧ x_3 ∈ x ∧ x_2 + x_3 = x_1 = x_2 = 0 ∧ ∃ (x_3 : E) , x_3 ∈ x ∧ x_2 + x_3 = x_1
<input>:1:181: expected end of input

{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [Module 𝕜 E] (x : ConvexCone 𝕜 E) (x_1 : E)  : ∃ (a : E) , a ∈ x ∧ a = x_1 = x_1 ∈ x
<input>:1:149: expected end of input

{J : Type v} [CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TypeMax) [CategoryTheory.IsFilteredOrEmpty J] {i : J} {j : J} {xi : CategoryTheory.Functor.toPrefunctor F . obj i} {xj : CategoryTheory.Functor.toPrefunctor F . obj j}  : EqvGen CategoryTheory.Limits.Types.Quot.Rel F {fst := ((i)) , snd := ((xi))} {fst := ((j)) , snd := ((xj))} ↔ EqvGen CategoryTheory.Limits.Types.Quot.Rel F {fst := ((i)) , snd := ((xi))} {fst := ((j)) , snd := ((xj))}
function expected at
  F.toPrefunctor
term has type
  J ⥤q TypeMax ; identifiers [J, v, CategoryTheory.SmallCategory, J, F, CategoryTheory.Functor, J, TypeMax, CategoryTheory.IsFilteredOrEmpty, J, i, J, j, J, xi, CategoryTheory.Functor.toPrefunctor, F, obj, i, xj, CategoryTheory.Functor.toPrefunctor, F, obj, j, EqvGen, CategoryTheory.Limits.Types.Quot.Rel, F, fst, i, snd, xi, fst, j, snd, xj, EqvGen, CategoryTheory.Limits.Types.Quot.Rel, F, fst, i, snd, xi, fst, j, snd, xj] (during elaboration)

{R : Type u} [CommRing R] [IsBezout R] {x : R} {y : R} {z : R} (hx : z ∣ x) (hy : z ∣ y)  : z ∣ x = z ∣ x
<input>:1:98: expected end of input

{R : Type u} [CommRing R] [IsBezout R] {x : R} {y : R} {z : R} (hx : z ∣ x) (hy : z ∣ y)  : z ∣ y = z ∣ y
<input>:1:98: expected end of input

(𝕜 : Type u_3) (E : Type u_2) [OrderedSemiring 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] {ι : Type u_1} (b : (a : ι) → Set E) (p : (a : ι) → Prop) (hbasis : Filter.HasBasis nhds 0 p b) (hconvex : ∀ (i : ι) (a : p i) , Convex 𝕜 b i) (x : E) (i : ι) (hi : fun (x : E) ↦ p x i)  : Convex 𝕜 b i
invalid universe level, ?u.80758 is not greater than 0 ; identifiers [𝕜, u_3, E, u_2, OrderedSemiring, 𝕜, AddCommGroup, E, Module, 𝕜, E, TopologicalSpace, E, TopologicalAddGroup, E, ι, u_1, b, a, ι, Set, E, p, a, ι, hbasis, Filter.HasBasis, nhds, p, b, hconvex, i, ι, a, p, i, Convex, 𝕜, b, i, x, E, i, ι, hi, x, E, p, x, i, Convex, 𝕜, b, i] (during elaboration)

{α : Type u_1} {β : Type u_2} {s : Set α} {t : Set α} {f : (a : α) → β} (hf : Function.Injective f) (h : f '' s ⊆ f '' t)  : s ⊆ t = s ⊆ t
<input>:1:131: expected end of input

{α : Type u_1} {β : Type u_2} {s : Set α} {t : Set α} {f : (a : α) → β} (hf : Function.Injective f) (h : f '' s ⊆ f '' t)  : f ⁻¹' f '' s ⊆ t = f ⁻¹' f '' s ⊆ t
<input>:1:142: expected end of input

(q : ℚ)  : q ≤ ↑ q = q ≤ ↑ q
<input>:1:19: expected end of input

 : ∀ {α : Type u_1} {f : (a : α) → ENNReal} {s : Finset α} (h : Finset.sum s fun (a : α) ↦ f a = 1) (h' : ∀ (a : α) (x : ¬ a ∈ s) , f a = 0) {a : α} (ha : ¬ a ∈ s) , ↑ Pmf.ofFinset f s h h' a = 0
failed to synthesize instance
  AddCommMonoid Prop ; identifiers [α, u_1, f, a, α, ENNReal, s, Finset, α, h, Finset.sum, s, a, α, f, a, h', a, α, x, a, s, f, a, a, α, ha, a, s, Pmf.ofFinset, f, s, h, h', a] (during elaboration)

 : ∀ {α : Type u_1} {f : (a : α) → ENNReal} {s : Finset α} (h : Finset.sum s fun (a : α) ↦ f a = 1) (h' : ∀ (a : α) (x : ¬ a ∈ s) , f a = 0) {a : α} (ha : ¬ a ∈ s) , f a = 0
failed to synthesize instance
  AddCommMonoid Prop ; identifiers [α, u_1, f, a, α, ENNReal, s, Finset, α, h, Finset.sum, s, a, α, f, a, h', a, α, x, a, s, f, a, a, α, ha, a, s, f, a] (during elaboration)

 : ∀ {V : Type u_2} {W : Type u_3} {V₁ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W] [inst_2 : SeminormedAddCommGroup V₁] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W} (φ : NormedAddGroupHom V₁ V) (h : NormedAddGroupHom.comp f φ = NormedAddGroupHom.comp g φ) (C : ℝ) (hφ : ‖ φ ‖ ≤ C) , ‖ NormedAddGroupHom.Equalizer.lift φ h ‖ ≤ C
<input>:1:325: expected term

 : ∀ {V : Type u_2} {W : Type u_3} {V₁ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W] [inst_2 : SeminormedAddCommGroup V₁] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W} (φ : NormedAddGroupHom V₁ V) (h : NormedAddGroupHom.comp f φ = NormedAddGroupHom.comp g φ) (C : ℝ) (hφ : ‖ φ ‖ ≤ C) , ‖ φ ‖ ≤ C
<input>:1:325: expected term

{α : Type u_1} [MulOneClass α] [LT α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x * x_1 fun (x : α) (x_1 : α) ↦ x < x_1] [ContravariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x * x_1 fun (x : α) (x_1 : α) ↦ x < x_1] (a : α) {b : α}  : a < b * a ↔ 1 * a < b * a = a < b * a ↔ 1 * a < b * a
<input>:1:285: expected end of input

{α : Type u_1} [MulOneClass α] [LT α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x * x_1 fun (x : α) (x_1 : α) ↦ x < x_1] [ContravariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x * x_1 fun (x : α) (x_1 : α) ↦ x < x_1] (a : α) {b : α}  : a < b * a ↔ a < b * a
application type mismatch
  CovariantClass α α Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) → (y : ?m.20) → ?m.21 x y) →
    (y : ?m.20) → (x : ?m.19) → ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  α → α → α : Type u_1 ; identifiers [α, u_1, MulOneClass, α, LT, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, ContravariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, a, b, a, a, b, a] (during elaboration)

{α : Type u_1} [GeneralizedCoheytingAlgebra α] {a : α} {b : α} {c : α} (h : a ⊔ c ≤ b ⊔ c)  : a \ c ≤ b \ c = a \ c ≤ b \ c
<input>:1:108: expected end of input

{α : Type u_1} [GeneralizedCoheytingAlgebra α] {a : α} {b : α} {c : α} (h : a ⊔ c ≤ b ⊔ c)  : a ⊔ c \ c ≤ b \ c = a ⊔ c \ c ≤ b \ c
<input>:1:112: expected end of input

{n : ℕ} {f : Vector ℕ n →. ℕ} (pf : Nat.Partrec' f) {m : ℕ} {n : ℕ} {f : Vector ℕ n →. ℕ} (g : (a : Fin n) → Vector ℕ m →. ℕ) (a : Nat.Partrec' f) (a : ∀ (i : Fin n) , Nat.Partrec' g i) (a_ih : Partrec f) (a_ih_1 : ∀ (i : Fin n) , Partrec g i)  : ∀ (i : Fin n) , Partrec g i
application type mismatch
  Nat.Partrec' g
argument
  g
has type
  Fin n → Vector ℕ m →. ℕ : Type
but is expected to have type
  Vector ℕ ?m.51 →. ℕ : Type ; identifiers [n, f, Vector, n, pf, Nat.Partrec', f, m, n, f, Vector, n, g, a, Fin, n, Vector, m, a, Nat.Partrec', f, a, i, Fin, n, Nat.Partrec', g, i, a_ih, Partrec, f, a_ih_1, i, Fin, n, Partrec, g, i, i, Fin, n, Partrec, g, i] (during elaboration)

{α : Type u_1} {l : Filter α} {R : Type u_2} [Distrib R] (f : Filter.Germ l R) (g : Filter.Germ l R) (h : Filter.Germ l R) (f : (a : α) → R) (g : (a : α) → R) (h : (a : α) → R)  : f * g + h =ᶠ[l] f * g + f * h = f * g + h =ᶠ[l] f * g + f * h
application type mismatch
  f * g + h =ᶠ[l] ?m.81592 =ᶠ[l] f * g + f * h
argument
  ?m.81592 =ᶠ[l] f * g + f * h
has type
  Prop : Type
but is expected to have type
  α → R : Type (max u_2 u_1) ; identifiers [α, u_1, l, Filter, α, R, u_2, Distrib, R, f, Filter.Germ, l, R, g, Filter.Germ, l, R, h, Filter.Germ, l, R, f, a, α, R, g, a, α, R, h, a, α, R, f, g, h, l, f, g, f, h, f, g, h, l, f, g, f, h] (during elaboration)

{α : Type u_2} {β : Type u_1} [AddMonoid α] [AddAction α β] {a : β} (motive : (x : ↑ AddAction.orbit α a) → Prop) (x : ↑ AddAction.orbit α a) (h_1 : ∀ (b : β) (x : α) (hx : fun (x : α) ↦ x +ᵥ a x = b) , motive {val := ((b)) , property := (((Exists.intro x hx =: ∃ (y : α) , fun (x : α) ↦ x +ᵥ a y = b)))}) (val : β) (property : val ∈ AddAction.orbit α a)  : ∀ (w : α) (h : fun (x : α) ↦ x +ᵥ a w = val) , motive {val := ((val)) , property := ((Exists.intro w h))}
<input>:1:260: expected term

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inl h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)))  : Or.inl h_1 = subsingleton_or_nontrivial M₀
<input>:1:143: expected term

 : ∀ {G : Type u_1} [inst : AddGroup G] (self : AddSubgroup G) {x : G} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup AddSubgroup.toAddSubmonoid self) , - x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup AddSubgroup.toAddSubmonoid self
function expected at
  AddSubsemigroup.carrier ?m.79766 AddSubgroup.toAddSubmonoid
term has type
  Prop ; identifiers [G, u_1, inst, AddGroup, G, self, AddSubgroup, G, x, G, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, AddSubgroup.toAddSubmonoid, self, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, AddSubgroup.toAddSubmonoid, self] (during elaboration)

 : ∀ (G : Type u_1) [inst : AddGroup G] (self : AddSubgroup G) {x : G} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup self . 1) , - x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup self . 1
function expected at
  AddSubsemigroup.carrier ?m.79766 self
term has type
  Prop ; identifiers [G, u_1, inst, AddGroup, G, self, AddSubgroup, G, x, G, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, self, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, self] (during elaboration)

{K : Type v} {V : Type w} [Field K] [AddCommGroup V] [Module K V] (f : Module.End K V) (μs : Set K) (xs : (a : ↑ μs) → V) (h_eigenvec : ∀ (μ : ↑ μs) , Module.End.HasEigenvector f ↑ μ xs μ) (μ : {x : K // x ∈ μs})  : Module.End.HasEigenvector f ↑ μ xs μ
type mismatch
  μs
has type
  Set K : Type v
but is expected to have type
  Sort ?u.1398 : Type ?u.1398 ; identifiers [K, v, V, w, Field, K, AddCommGroup, V, Module, K, V, f, Module.End, K, V, μs, Set, K, xs, a, μs, V, h_eigenvec, μ, μs, Module.End.HasEigenvector, f, μ, xs, μ, μ, x, K, x, μs, Module.End.HasEigenvector, f, μ, xs, μ] (during elaboration)

{α : Type u_1} {β : Type u_2} {γ : Type u_3} [Primcodable α] [Primcodable β] [Primcodable γ] {p : (a : α) → Prop} {q : (a : β) → Prop} {r : (a : γ) → Prop} (x : p ≤₀ r) (x_1 : q ≤₀ r) (f : (a : α) → γ) (c₁ : Computable f) (h₁ : ∀ (a : α) , (p a : Prop) ↔ (r f a : Prop)) (g : (a : β) → γ) (c₂ : Computable g) (h₂ : ∀ (a : β) , (q a : Prop) ↔ (r g a : Prop)) (x : α ⊕ β) (val : α) (h : x = Sum.inl val)  : Sum.inl val = x
application type mismatch
  r f
argument
  f
has type
  α → γ : Type (max u_1 u_3)
but is expected to have type
  γ : Type u_3 ; identifiers [α, u_1, β, u_2, γ, u_3, Primcodable, α, Primcodable, β, Primcodable, γ, p, a, α, q, a, β, r, a, γ, x, p, r, x_1, q, r, f, a, α, γ, c₁, Computable, f, h₁, a, α, p, a, r, f, a, g, a, β, γ, c₂, Computable, g, h₂, a, β, q, a, r, g, a, x, α, β, val, α, h, x, Sum.inl, val, Sum.inl, val, x] (during elaboration)

{α : Type u_1} {β : Type u_2} {γ : Type u_3} [Primcodable α] [Primcodable β] [Primcodable γ] {p : (a : α) → Prop} {q : (a : β) → Prop} {r : (a : γ) → Prop} (x : p ≤₀ r) (x_1 : q ≤₀ r) (f : (a : α) → γ) (c₁ : Computable f) (h₁ : ∀ (a : α) , (p a : Prop) ↔ (r f a : Prop)) (g : (a : β) → γ) (c₂ : Computable g) (h₂ : ∀ (a : β) , (q a : Prop) ↔ (r g a : Prop)) (x : α ⊕ β) (val : α) (h : x = Sum.inl val)  : p val ↔ r f val
application type mismatch
  r f
argument
  f
has type
  α → γ : Type (max u_1 u_3)
but is expected to have type
  γ : Type u_3 ; identifiers [α, u_1, β, u_2, γ, u_3, Primcodable, α, Primcodable, β, Primcodable, γ, p, a, α, q, a, β, r, a, γ, x, p, r, x_1, q, r, f, a, α, γ, c₁, Computable, f, h₁, a, α, p, a, r, f, a, g, a, β, γ, c₂, Computable, g, h₂, a, β, q, a, r, g, a, x, α, β, val, α, h, x, Sum.inl, val, p, val, r, f, val] (during elaboration)

{R : Type u₁} [StrictOrderedSemiring R] {a : R} (h : 0 ≤ a) (ha : a ≤ 1) {i : ℕ} {j : ℕ} (hij : i ≤ j) (k : ℕ) (hk : j = i + k)  : a ^ j ≤ a ^ i = a ^ j ≤ a ^ i
<input>:1:145: expected end of input

{α : Type u_1} {β : Type u_2} {γ : Type u_3} [Primcodable α] [Primcodable β] [Primcodable γ] {p : (a : α) → Prop} {q : (a : β) → Prop} {r : (a : γ) → Prop} (x : p ≤₀ r) (x_1 : q ≤₀ r) (f : (a : α) → γ) (c₁ : Computable f) (h₁ : ∀ (a : α) , (p a : Prop) ↔ (r f a : Prop)) (g : (a : β) → γ) (c₂ : Computable g) (h₂ : ∀ (a : β) , (q a : Prop) ↔ (r g a : Prop)) (x : α ⊕ β) (val : β) (h : x = Sum.inr val)  : Sum.inr val = x
application type mismatch
  r f
argument
  f
has type
  α → γ : Type (max u_1 u_3)
but is expected to have type
  γ : Type u_3 ; identifiers [α, u_1, β, u_2, γ, u_3, Primcodable, α, Primcodable, β, Primcodable, γ, p, a, α, q, a, β, r, a, γ, x, p, r, x_1, q, r, f, a, α, γ, c₁, Computable, f, h₁, a, α, p, a, r, f, a, g, a, β, γ, c₂, Computable, g, h₂, a, β, q, a, r, g, a, x, α, β, val, β, h, x, Sum.inr, val, Sum.inr, val, x] (during elaboration)

{α : Type u_1} {β : Type u_2} {γ : Type u_3} [Primcodable α] [Primcodable β] [Primcodable γ] {p : (a : α) → Prop} {q : (a : β) → Prop} {r : (a : γ) → Prop} (x : p ≤₀ r) (x_1 : q ≤₀ r) (f : (a : α) → γ) (c₁ : Computable f) (h₁ : ∀ (a : α) , (p a : Prop) ↔ (r f a : Prop)) (g : (a : β) → γ) (c₂ : Computable g) (h₂ : ∀ (a : β) , (q a : Prop) ↔ (r g a : Prop)) (x : α ⊕ β) (val : β) (h : x = Sum.inr val)  : q val ↔ r g val
application type mismatch
  r f
argument
  f
has type
  α → γ : Type (max u_1 u_3)
but is expected to have type
  γ : Type u_3 ; identifiers [α, u_1, β, u_2, γ, u_3, Primcodable, α, Primcodable, β, Primcodable, γ, p, a, α, q, a, β, r, a, γ, x, p, r, x_1, q, r, f, a, α, γ, c₁, Computable, f, h₁, a, α, p, a, r, f, a, g, a, β, γ, c₂, Computable, g, h₂, a, β, q, a, r, g, a, x, α, β, val, β, h, x, Sum.inr, val, q, val, r, g, val] (during elaboration)

{α : Type u_1} {β : Type u_2} {γ : Type u_3} [Primcodable α] [Primcodable β] [Primcodable γ] {p : (a : α) → Prop} {q : (a : β) → Prop} {r : (a : γ) → Prop} (x : p ≤₀ r) (x_1 : q ≤₀ r) (f : (a : α) → γ) (c₁ : Computable f) (h₁ : ∀ (a : α) , (p a : Prop) ↔ (r f a : Prop)) (g : (a : β) → γ) (c₂ : Computable g) (h₂ : ∀ (a : β) , (q a : Prop) ↔ (r g a : Prop)) (x : α ⊕ β)  : x = x
application type mismatch
  r f
argument
  f
has type
  α → γ : Type (max u_1 u_3)
but is expected to have type
  γ : Type u_3 ; identifiers [α, u_1, β, u_2, γ, u_3, Primcodable, α, Primcodable, β, Primcodable, γ, p, a, α, q, a, β, r, a, γ, x, p, r, x_1, q, r, f, a, α, γ, c₁, Computable, f, h₁, a, α, p, a, r, f, a, g, a, β, γ, c₂, Computable, g, h₂, a, β, q, a, r, g, a, x, α, β, x, x] (during elaboration)

 : ∀ {α : Type u} [inst : SizeOf α] , sizeOf LazyList.nil = 1
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (LazyList ?m.6756) ; identifiers [α, u, inst, SizeOf, α, sizeOf, LazyList.nil] (during elaboration)

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inl h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a') (h : a' = a) (a' : M)  : a = a
<input>:1:143: expected term

 : ∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {f : (a : α) → β} (self : MeasurableEmbedding f) ⦃ s : Set α ⦄ (a : MeasurableSet s) , MeasurableSet f '' s
application type mismatch
  Set.image (MeasurableSet ?m.353)
argument
  MeasurableSet ?m.353
has type
  Prop : Type
but is expected to have type
  α → ?m.79608 self a : Type (max ?u.146 u_1) ; identifiers [α, u_1, β, u_2, inst, MeasurableSpace, α, inst_1, MeasurableSpace, β, f, a, α, β, self, MeasurableEmbedding, f, s, Set, α, a, MeasurableSet, s, MeasurableSet, f, s] (during elaboration)

 : ∀ (α : Type u_1) (β : Type u_2) [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] (f : (a : α) → β) (self : MeasurableEmbedding f) ⦃ s : Set α ⦄ (a : MeasurableSet s) , MeasurableSet f '' s
application type mismatch
  Set.image (MeasurableSet ?m.353)
argument
  MeasurableSet ?m.353
has type
  Prop : Type
but is expected to have type
  α → ?m.79608 α β f self a : Type (max ?u.146 u_1) ; identifiers [α, u_1, β, u_2, inst, MeasurableSpace, α, inst_1, MeasurableSpace, β, f, a, α, β, self, MeasurableEmbedding, f, s, Set, α, a, MeasurableSet, s, MeasurableSet, f, s] (during elaboration)

{G : Type u_1} [Group G] (H : Subgroup G) (a : G) (b : G)  : Setoid.Rel Doset.setoid ↑ Subgroup.toSubmonoid H ↑ ⊥ a b ↔ Setoid.Rel Doset.setoid ↑ Subgroup.toSubmonoid H ↑ ⊥ a b
function expected at
  Setoid.Rel ?m.80159 ?m.80160 H
term has type
  Prop ; identifiers [G, u_1, Group, G, H, Subgroup, G, a, G, b, G, Setoid.Rel, Doset.setoid, Subgroup.toSubmonoid, H, a, b, Setoid.Rel, Doset.setoid, Subgroup.toSubmonoid, H, a, b] (during elaboration)

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inl h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a') (h : a' = a)  : a = a'
<input>:1:143: expected term

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inl h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a')  : a' = a'
<input>:1:143: expected term

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Nontrivial M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inr h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)))  : Or.inr h_1 = subsingleton_or_nontrivial M₀
<input>:1:141: expected term

 : ∀ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] (self : SchwartzMap E F) , ContDiff ℝ ⊤ SchwartzMap.toFun self
function expected at
  ContDiff ℝ ⊤ SchwartzMap.toFun
term has type
  Prop ; identifiers [E, u_1, F, u_2, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, NormedAddCommGroup, F, inst_3, NormedSpace, F, self, SchwartzMap, E, F, ContDiff, SchwartzMap.toFun, self] (during elaboration)

 : ∀ (E : Type u_1) (F : Type u_2) [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] (self : SchwartzMap E F) , ContDiff ℝ ⊤ self . 1
function expected at
  ContDiff ℝ ⊤ ↑self
term has type
  Prop ; identifiers [E, u_1, F, u_2, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, NormedAddCommGroup, F, inst_3, NormedSpace, F, self, SchwartzMap, E, F, ContDiff, self] (during elaboration)

{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [Module 𝕜 E] (x : ConvexCone 𝕜 E) (x_1 : E) (x_2 : E)  : ∃ (x_3 : E) , x_2 = 0 ∧ x_3 ∈ x ∧ x_2 + x_3 = x_1 = x_2 = 0 ∧ ∃ (x_3 : E) , x_3 ∈ x ∧ x_2 + x_3 = x_1
<input>:1:181: expected end of input

{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [Module 𝕜 E] (x : ConvexCone 𝕜 E) (x_1 : E)  : ∃ (a : E) , a ∈ x ∧ a = x_1 = x_1 ∈ x
<input>:1:149: expected end of input

{J : Type v} [CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TypeMax) [CategoryTheory.IsFilteredOrEmpty J] {i : J} {j : J} {xi : CategoryTheory.Functor.toPrefunctor F . obj i} {xj : CategoryTheory.Functor.toPrefunctor F . obj j}  : EqvGen CategoryTheory.Limits.Types.Quot.Rel F {fst := ((i)) , snd := ((xi))} {fst := ((j)) , snd := ((xj))} ↔ EqvGen CategoryTheory.Limits.Types.Quot.Rel F {fst := ((i)) , snd := ((xi))} {fst := ((j)) , snd := ((xj))}
function expected at
  F.toPrefunctor
term has type
  J ⥤q TypeMax ; identifiers [J, v, CategoryTheory.SmallCategory, J, F, CategoryTheory.Functor, J, TypeMax, CategoryTheory.IsFilteredOrEmpty, J, i, J, j, J, xi, CategoryTheory.Functor.toPrefunctor, F, obj, i, xj, CategoryTheory.Functor.toPrefunctor, F, obj, j, EqvGen, CategoryTheory.Limits.Types.Quot.Rel, F, fst, i, snd, xi, fst, j, snd, xj, EqvGen, CategoryTheory.Limits.Types.Quot.Rel, F, fst, i, snd, xi, fst, j, snd, xj] (during elaboration)

{R : Type u} [CommRing R] [IsBezout R] {x : R} {y : R} {z : R} (hx : z ∣ x) (hy : z ∣ y)  : z ∣ x = z ∣ x
<input>:1:98: expected end of input

{R : Type u} [CommRing R] [IsBezout R] {x : R} {y : R} {z : R} (hx : z ∣ x) (hy : z ∣ y)  : z ∣ y = z ∣ y
<input>:1:98: expected end of input

(𝕜 : Type u_3) (E : Type u_2) [OrderedSemiring 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] {ι : Type u_1} (b : (a : ι) → Set E) (p : (a : ι) → Prop) (hbasis : Filter.HasBasis nhds 0 p b) (hconvex : ∀ (i : ι) (a : p i) , Convex 𝕜 b i) (x : E) (i : ι) (hi : fun (x : E) ↦ p x i)  : Convex 𝕜 b i
invalid universe level, ?u.80758 is not greater than 0 ; identifiers [𝕜, u_3, E, u_2, OrderedSemiring, 𝕜, AddCommGroup, E, Module, 𝕜, E, TopologicalSpace, E, TopologicalAddGroup, E, ι, u_1, b, a, ι, Set, E, p, a, ι, hbasis, Filter.HasBasis, nhds, p, b, hconvex, i, ι, a, p, i, Convex, 𝕜, b, i, x, E, i, ι, hi, x, E, p, x, i, Convex, 𝕜, b, i] (during elaboration)

{α : Type u_1} {β : Type u_2} {s : Set α} {t : Set α} {f : (a : α) → β} (hf : Function.Injective f) (h : f '' s ⊆ f '' t)  : s ⊆ t = s ⊆ t
<input>:1:131: expected end of input

{α : Type u_1} {β : Type u_2} {s : Set α} {t : Set α} {f : (a : α) → β} (hf : Function.Injective f) (h : f '' s ⊆ f '' t)  : f ⁻¹' f '' s ⊆ t = f ⁻¹' f '' s ⊆ t
<input>:1:142: expected end of input

(q : ℚ)  : q ≤ ↑ q = q ≤ ↑ q
<input>:1:19: expected end of input

 : (∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {n : ℕ∞} {f : (a : E) → F} {p : (a : E) → FormalMultilinearSeries 𝕜 E F} (self : HasFTaylorSeriesUpTo n f p) (x : E) , ContinuousMultilinearMap.uncurry0 p x 0 = f x)
unknown universe level 'uE' ; identifiers [𝕜, u, inst, NontriviallyNormedField, 𝕜, E, uE, inst_1, NormedAddCommGroup, E, inst_2, NormedSpace, 𝕜, E, F, uF, inst_3, NormedAddCommGroup, F, inst_4, NormedSpace, 𝕜, F, n, f, a, E, F, p, a, E, FormalMultilinearSeries, 𝕜, E, F, self, HasFTaylorSeriesUpTo, n, f, p, x, E, ContinuousMultilinearMap.uncurry0, p, x, f, x] (during elaboration)

 : ∀ (𝕜 : Type u) [inst : NontriviallyNormedField 𝕜] (E : Type uE) [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] (F : Type uF) [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (n : ℕ∞) (f : (a : E) → F) (p : (a : E) → FormalMultilinearSeries 𝕜 E F) (self : HasFTaylorSeriesUpTo n f p) (x : E) , ContinuousMultilinearMap.uncurry0 p x 0 = f x
unknown universe level 'uE' ; identifiers [𝕜, u, inst, NontriviallyNormedField, 𝕜, E, uE, inst_1, NormedAddCommGroup, E, inst_2, NormedSpace, 𝕜, E, F, uF, inst_3, NormedAddCommGroup, F, inst_4, NormedSpace, 𝕜, F, n, f, a, E, F, p, a, E, FormalMultilinearSeries, 𝕜, E, F, self, HasFTaylorSeriesUpTo, n, f, p, x, E, ContinuousMultilinearMap.uncurry0, p, x, f, x] (during elaboration)

{α : Type u_1} {β : Type u_2} {f : (a : α) → β} {c : α} [AddZeroClass α] (h : Function.Periodic f c)  : f 0 + c = f 0
failed to synthesize instance
  HAdd β α ?m.160896 ; identifiers [α, u_1, β, u_2, f, a, α, β, c, α, AddZeroClass, α, h, Function.Periodic, f, c, f, c, f] (during elaboration)

 : (∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Ring A] [inst_2 : Algebra R A] {r : R} {a : A} , (r ∈ resolventSet R a : Prop) ↔ (IsUnit ↑ algebraMap R A r - a : Prop))
function expected at
  IsUnit ?m.721
term has type
  Prop ; identifiers [R, u, A, v, inst, CommSemiring, R, inst_1, Ring, A, inst_2, Algebra, R, A, r, R, a, A, r, resolventSet, R, a, IsUnit, algebraMap, R, A, r, a] (during elaboration)

 : (∀ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M] [inst_1 : FirstOrder.Language.Structure L N] (self : FirstOrder.Language.Embedding L M N) {n : ℕ} (r : FirstOrder.Language.Relations L n) (x : (a : Fin n) → M) , (FirstOrder.Language.Structure.RelMap r Function.Embedding.toFun FirstOrder.Language.Embedding.toEmbedding self ∘ x : Prop) ↔ (FirstOrder.Language.Structure.RelMap r x : Prop))
unknown universe level 'w'' ; identifiers [L, FirstOrder.Language, M, w, N, w', inst, FirstOrder.Language.Structure, L, M, inst_1, FirstOrder.Language.Structure, L, N, self, FirstOrder.Language.Embedding, L, M, N, n, r, FirstOrder.Language.Relations, L, n, x, a, Fin, n, M, FirstOrder.Language.Structure.RelMap, r, Function.Embedding.toFun, FirstOrder.Language.Embedding.toEmbedding, self, x, FirstOrder.Language.Structure.RelMap, r, x] (during elaboration)

 : ∀ (L : FirstOrder.Language) (M : Type w) (N : Type w') [inst : FirstOrder.Language.Structure L M] [inst_1 : FirstOrder.Language.Structure L N] (self : FirstOrder.Language.Embedding L M N) {n : ℕ} (r : FirstOrder.Language.Relations L n) (x : (a : Fin n) → M) , (FirstOrder.Language.Structure.RelMap r Function.Embedding.toFun self . 1 ∘ x) ↔ (FirstOrder.Language.Structure.RelMap r x)
unknown universe level 'w'' ; identifiers [L, FirstOrder.Language, M, w, N, w', inst, FirstOrder.Language.Structure, L, M, inst_1, FirstOrder.Language.Structure, L, N, self, FirstOrder.Language.Embedding, L, M, N, n, r, FirstOrder.Language.Relations, L, n, x, a, Fin, n, M, FirstOrder.Language.Structure.RelMap, r, Function.Embedding.toFun, self, x, FirstOrder.Language.Structure.RelMap, r, x] (during elaboration)

{R : Type u_1} [AddGroup R] [StarAddMonoid R] {x : R}  : (x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup AddSubgroup.toAddSubmonoid selfAdjoint R) ↔ (x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup AddSubgroup.toAddSubmonoid selfAdjoint R)
function expected at
  AddSubsemigroup.carrier ?m.80103 AddSubgroup.toAddSubmonoid
term has type
  Prop ; identifiers [R, u_1, AddGroup, R, StarAddMonoid, R, x, R, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, AddSubgroup.toAddSubmonoid, selfAdjoint, R, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, AddSubgroup.toAddSubmonoid, selfAdjoint, R] (during elaboration)

{R : Type u_3} {S : Type u_1} {M : Type u_2} {s : S} [SMul R M] [SMul R S] [SMul S M] [IsScalarTower R S M] (a : R) (ab : IsSMulRegular M a • s) (c : M) (d : M) (cd : fun (m : M) ↦ a • m ∘ fun (x : M) ↦ s • x c = fun (m : M) ↦ a • m ∘ fun (x : M) ↦ s • x d)  : (a • s • c = a • s • d) = (a • s • c = a • s • d)
failed to synthesize instance
  HSMul Prop S ?m.90 ; identifiers [R, u_3, S, u_1, M, u_2, s, S, SMul, R, M, SMul, R, S, SMul, S, M, IsScalarTower, R, S, M, a, R, ab, IsSMulRegular, M, a, s, c, M, d, M, cd, m, M, a, m, x, M, s, x, c, m, M, a, m, x, M, s, x, d, a, s, c, a, s, d, a, s, c, a, s, d] (during elaboration)

{R : Type u_3} {S : Type u_1} {M : Type u_2} {s : S} [SMul R M] [SMul R S] [SMul S M] [IsScalarTower R S M] (a : R) (ab : IsSMulRegular M a • s) (c : M) (d : M) (cd : fun (m : M) ↦ a • m ∘ fun (x : M) ↦ s • x c = fun (m : M) ↦ a • m ∘ fun (x : M) ↦ s • x d)  : (a • s • c = a • s • d) = (a • s • c = a • s • d)
failed to synthesize instance
  HSMul Prop S ?m.90 ; identifiers [R, u_3, S, u_1, M, u_2, s, S, SMul, R, M, SMul, R, S, SMul, S, M, IsScalarTower, R, S, M, a, R, ab, IsSMulRegular, M, a, s, c, M, d, M, cd, m, M, a, m, x, M, s, x, c, m, M, a, m, x, M, s, x, d, a, s, c, a, s, d, a, s, c, a, s, d] (during elaboration)

{o : Type u_4} {m' : (a : o) → Type u_1} {n' : (a : o) → Type u_2} {α : Type u_3} [DecidableEq o] [Zero α] (M : (i : o) → Matrix m' i n' i α) (ik : (i : o) × m' i) (jk : (i : o) × n' i) (fst : o) (snd : m' fst) (h : ik = {fst := ((fst)) , snd := ((snd))})  : {fst := ((fst)) , snd := ((snd))} = ik
application type mismatch
  Matrix m'
argument
  m'
has type
  o → Type u_1 : Type (max (u_1 + 1) u_4)
but is expected to have type
  Type ?u.40 : Type (?u.40 + 1) ; identifiers [o, u_4, m', a, o, u_1, n', a, o, u_2, α, u_3, DecidableEq, o, Zero, α, M, i, o, Matrix, m', i, n', i, α, ik, i, o, m', i, jk, i, o, n', i, fst, o, snd, m', fst, h, ik, fst, fst, snd, snd, fst, fst, snd, snd, ik] (during elaboration)

{o : Type u_4} {m' : (a : o) → Type u_1} {n' : (a : o) → Type u_2} {α : Type u_3} [DecidableEq o] [Zero α] (M : (i : o) → Matrix m' i n' i α) (ik : (i : o) × m' i) (jk : (i : o) × n' i) (fst : o) (snd : m' fst) (h : ik = {fst := ((fst)) , snd := ((snd))}) (t : (i : o) × n' i)  : Sigma.fst jk = Sigma.fst {fst := ((fst)) , snd := ((snd))}
application type mismatch
  Matrix m'
argument
  m'
has type
  o → Type u_1 : Type (max (u_1 + 1) u_4)
but is expected to have type
  Type ?u.40 : Type (?u.40 + 1) ; identifiers [o, u_4, m', a, o, u_1, n', a, o, u_2, α, u_3, DecidableEq, o, Zero, α, M, i, o, Matrix, m', i, n', i, α, ik, i, o, m', i, jk, i, o, n', i, fst, o, snd, m', fst, h, ik, fst, fst, snd, snd, t, i, o, n', i, Sigma.fst, jk, Sigma.fst, fst, fst, snd, snd] (during elaboration)

{o : Type u_4} {m' : (a : o) → Type u_1} {n' : (a : o) → Type u_2} {α : Type u_3} [DecidableEq o] [Zero α] (M : (i : o) → Matrix m' i n' i α) (ik : (i : o) × m' i) (jk : (i : o) × n' i) (fst : o) (snd : m' fst) (h : ik = {fst := ((fst)) , snd := ((snd))}) (fst_1 : o) (snd_1 : n' fst_1) (h : jk = {fst := ((fst_1)) , snd := ((snd_1))})  : {fst := ((fst_1)) , snd := ((snd_1))} = jk
application type mismatch
  Matrix m'
argument
  m'
has type
  o → Type u_1 : Type (max (u_1 + 1) u_4)
but is expected to have type
  Type ?u.40 : Type (?u.40 + 1) ; identifiers [o, u_4, m', a, o, u_1, n', a, o, u_2, α, u_3, DecidableEq, o, Zero, α, M, i, o, Matrix, m', i, n', i, α, ik, i, o, m', i, jk, i, o, n', i, fst, o, snd, m', fst, h, ik, fst, fst, snd, snd, fst_1, o, snd_1, n', fst_1, h, jk, fst, fst_1, snd, snd_1, fst, fst_1, snd, snd_1, jk] (during elaboration)

{o : Type u_4} {m' : (a : o) → Type u_1} {n' : (a : o) → Type u_2} {α : Type u_3} [DecidableEq o] [Zero α] (M : (i : o) → Matrix m' i n' i α) (ik : (i : o) × m' i) (jk : (i : o) × n' i) (fst : o) (snd : m' fst) (h : ik = {fst := ((fst)) , snd := ((snd))})  : jk = jk
application type mismatch
  Matrix m'
argument
  m'
has type
  o → Type u_1 : Type (max (u_1 + 1) u_4)
but is expected to have type
  Type ?u.40 : Type (?u.40 + 1) ; identifiers [o, u_4, m', a, o, u_1, n', a, o, u_2, α, u_3, DecidableEq, o, Zero, α, M, i, o, Matrix, m', i, n', i, α, ik, i, o, m', i, jk, i, o, n', i, fst, o, snd, m', fst, h, ik, fst, fst, snd, snd, jk, jk] (during elaboration)

{o : Type u_4} {m' : (a : o) → Type u_1} {n' : (a : o) → Type u_2} {α : Type u_3} [DecidableEq o] [Zero α] (M : (i : o) → Matrix m' i n' i α) (ik : (i : o) × m' i) (jk : (i : o) × n' i)  : ik = ik
application type mismatch
  Matrix m'
argument
  m'
has type
  o → Type u_1 : Type (max (u_1 + 1) u_4)
but is expected to have type
  Type ?u.40 : Type (?u.40 + 1) ; identifiers [o, u_4, m', a, o, u_1, n', a, o, u_2, α, u_3, DecidableEq, o, Zero, α, M, i, o, Matrix, m', i, n', i, α, ik, i, o, m', i, jk, i, o, n', i, ik, ik] (during elaboration)

{n : ℕ} {a : Cardinal .{u}}  : (↑ n = a) ↔ (↑ n = a)
<input>:1:22: expected '//', '|' or '}'

{X : Type u_1} [TopologicalSpace X] (toSetoid : Setoid X) (isOpen_setOf_rel : ∀ (x : X) , IsOpen setOf Setoid.Rel toSetoid x) (toSetoid_1 : Setoid X) (isOpen_setOf_rel_1 : ∀ (x : X) , IsOpen setOf Setoid.Rel toSetoid_1 x) (a : {toSetoid := ((toSetoid)) , isOpen_setOf_rel := ((isOpen_setOf_rel))} = {toSetoid := ((toSetoid_1)) , isOpen_setOf_rel := ((isOpen_setOf_rel_1))})  : ∀ (toSetoid_eq : toSetoid = toSetoid_1) , toSetoid = toSetoid_1
function expected at
  IsOpen ?m.219
term has type
  Prop ; identifiers [X, u_1, TopologicalSpace, X, toSetoid, Setoid, X, isOpen_setOf_rel, x, X, IsOpen, setOf, Setoid.Rel, toSetoid, x, toSetoid_1, Setoid, X, isOpen_setOf_rel_1, x, X, IsOpen, setOf, Setoid.Rel, toSetoid_1, x, a, toSetoid, toSetoid, isOpen_setOf_rel, isOpen_setOf_rel, toSetoid, toSetoid_1, isOpen_setOf_rel, isOpen_setOf_rel_1, toSetoid_eq, toSetoid, toSetoid_1, toSetoid, toSetoid_1] (during elaboration)

{α : Type u} {β : Type v} [PseudoEMetricSpace α] [PseudoEMetricSpace β] {K : NNReal} {f : (a : α) → β} (h : LipschitzWith K f) (x : α) (y : α)  : edist f x f y ≤ ↑ K * edist x y
application type mismatch
  edist f x
argument
  x
has type
  α : Type u
but is expected to have type
  α → β : Type (max u v) ; identifiers [α, u, β, v, PseudoEMetricSpace, α, PseudoEMetricSpace, β, K, NNReal, f, a, α, β, h, LipschitzWith, K, f, x, α, y, α, edist, f, x, f, y, K, edist, x, y] (during elaboration)

{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : (a : α) → β} {a : α} (hf : StrictMono f) (ha : IsMax f a) (h : ¬ (IsMax a : Prop)) (w : α) (hb : a < w)  : f a < f w
function expected at
  IsMax f
term has type
  Prop ; identifiers [α, u, β, v, Preorder, α, Preorder, β, f, a, α, β, a, α, hf, StrictMono, f, ha, IsMax, f, a, h, IsMax, a, w, α, hb, a, w, f, a, f, w] (during elaboration)

{X : Type u_1} [TopologicalSpace X] (toSetoid : Setoid X) (isOpen_setOf_rel : ∀ (x : X) , IsOpen setOf Setoid.Rel toSetoid x) (toSetoid_1 : Setoid X) (isOpen_setOf_rel_1 : ∀ (x : X) , IsOpen setOf Setoid.Rel toSetoid_1 x) (a : toSetoid = toSetoid_1) (h : toSetoid_1 = toSetoid) (toSetoid_2 : Setoid X)  : toSetoid = toSetoid
function expected at
  IsOpen ?m.219
term has type
  Prop ; identifiers [X, u_1, TopologicalSpace, X, toSetoid, Setoid, X, isOpen_setOf_rel, x, X, IsOpen, setOf, Setoid.Rel, toSetoid, x, toSetoid_1, Setoid, X, isOpen_setOf_rel_1, x, X, IsOpen, setOf, Setoid.Rel, toSetoid_1, x, a, toSetoid, toSetoid_1, h, toSetoid_1, toSetoid, toSetoid_2, Setoid, X, toSetoid, toSetoid] (during elaboration)

{X : Type u_1} [TopologicalSpace X] (toSetoid : Setoid X) (isOpen_setOf_rel : ∀ (x : X) , IsOpen setOf Setoid.Rel toSetoid x) (toSetoid_1 : Setoid X) (isOpen_setOf_rel_1 : ∀ (x : X) , IsOpen setOf Setoid.Rel toSetoid_1 x) (a : toSetoid = toSetoid_1) (h : toSetoid_1 = toSetoid) (isOpen_setOf_rel_2 : ∀ (x : X) , IsOpen setOf Setoid.Rel toSetoid x) (a : toSetoid = toSetoid) (h : HEq a (Eq.refl toSetoid =: toSetoid = toSetoid))  : {toSetoid := ((toSetoid)) , isOpen_setOf_rel := ((isOpen_setOf_rel))} = {toSetoid := ((toSetoid)) , isOpen_setOf_rel := ((isOpen_setOf_rel))}
<input>:1:404: expected term

{X : Type u_1} [TopologicalSpace X] (toSetoid : Setoid X) (isOpen_setOf_rel : ∀ (x : X) , IsOpen setOf Setoid.Rel toSetoid x) (toSetoid_1 : Setoid X) (isOpen_setOf_rel_1 : ∀ (x : X) , IsOpen setOf Setoid.Rel toSetoid_1 x) (a : toSetoid = toSetoid_1) (h : toSetoid_1 = toSetoid)  : toSetoid = toSetoid_1
function expected at
  IsOpen ?m.219
term has type
  Prop ; identifiers [X, u_1, TopologicalSpace, X, toSetoid, Setoid, X, isOpen_setOf_rel, x, X, IsOpen, setOf, Setoid.Rel, toSetoid, x, toSetoid_1, Setoid, X, isOpen_setOf_rel_1, x, X, IsOpen, setOf, Setoid.Rel, toSetoid_1, x, a, toSetoid, toSetoid_1, h, toSetoid_1, toSetoid, toSetoid, toSetoid_1] (during elaboration)

{X : Type u_1} [TopologicalSpace X] (toSetoid : Setoid X) (isOpen_setOf_rel : ∀ (x : X) , IsOpen setOf Setoid.Rel toSetoid x) (toSetoid_1 : Setoid X) (isOpen_setOf_rel_1 : ∀ (x : X) , IsOpen setOf Setoid.Rel toSetoid_1 x) (a : toSetoid = toSetoid_1)  : toSetoid_1 = toSetoid_1
function expected at
  IsOpen ?m.219
term has type
  Prop ; identifiers [X, u_1, TopologicalSpace, X, toSetoid, Setoid, X, isOpen_setOf_rel, x, X, IsOpen, setOf, Setoid.Rel, toSetoid, x, toSetoid_1, Setoid, X, isOpen_setOf_rel_1, x, X, IsOpen, setOf, Setoid.Rel, toSetoid_1, x, a, toSetoid, toSetoid_1, toSetoid_1, toSetoid_1] (during elaboration)

(α : Type u) [Nonempty α] (h : Finite α) (h_1 : (finite_or_infinite α =: (Finite α : Prop) ∨ (Infinite α : Prop)) = (Or.inl h =: (Finite α : Prop) ∨ (Infinite α : Prop)))  : Or.inl h = finite_or_infinite α
<input>:1:71: expected term

{op : (a : Ordinal .{u}) → (a : Ordinal .{u}) → Ordinal .{u}} {a : Ordinal .{u}} {o : Ordinal .{u}} (hao : a < o) (H : Ordinal.IsNormal op a) (ho : Ordinal.Principal op o) (ho' : Ordinal.IsLimit o)  : (op a o ≤ o) = (op a o ≤ o)
<input>:1:19: expected ')'

{α : Type u_1} {p : (a : Multiset α) → Prop} (S : Multiset α) (h₁ : p 0) (h₂ : ∀ {a : α} {s : Multiset α} (a_1 : a ∈ S) (a_2 : s ⊆ S) (a_3 : p s) , p insert a s)  : ∀ (x : 0 ⊆ S) , p 0
application type mismatch
  p insert
argument
  insert
has type
  ?m.163 → ?m.165 → ?m.165 : Type (max ?u.161 ?u.162)
but is expected to have type
  Multiset α : Type u_1 ; identifiers [α, u_1, p, a, Multiset, α, S, Multiset, α, h₁, p, h₂, a, α, s, Multiset, α, a_1, a, S, a_2, s, S, a_3, p, s, p, insert, a, s, x, S, p] (during elaboration)

{α : Type u_1} {p : (a : Multiset α) → Prop} (S : Multiset α) (h₁ : p 0) (h₂ : ∀ {a : α} {s : Multiset α} (a_1 : a ∈ S) (a_2 : s ⊆ S) (a_3 : p s) , p insert a s) (x : α) (x_1 : Multiset α) (hps : fun (T : Multiset α) ↦ ∀ (a : T ⊆ S) , p T x_1) (hs : x ::ₘ x_1 ⊆ S) (hS : x ∈ S) (sS : x_1 ⊆ S)  : p x_1
application type mismatch
  p insert
argument
  insert
has type
  ?m.163 → ?m.165 → ?m.165 : Type (max ?u.161 ?u.162)
but is expected to have type
  Multiset α : Type u_1 ; identifiers [α, u_1, p, a, Multiset, α, S, Multiset, α, h₁, p, h₂, a, α, s, Multiset, α, a_1, a, S, a_2, s, S, a_3, p, s, p, insert, a, s, x, α, x_1, Multiset, α, hps, T, Multiset, α, a, T, S, p, T, x_1, hs, x, x_1, S, hS, x, S, sS, x_1, S, p, x_1] (during elaboration)

{op : (a : Ordinal .{u}) → (a : Ordinal .{u}) → Ordinal .{u}} {a : Ordinal .{u}} {o : Ordinal .{u}} (hao : a < o) (H : Ordinal.IsNormal op a) (ho : Ordinal.Principal op o) (ho' : Ordinal.IsLimit o) (b : Ordinal .{u}) (hbo : b < o)  : op a b < o
<input>:1:19: expected ')'

(α : Type u) [Nonempty α] (h : Infinite α) (h_1 : (finite_or_infinite α =: (Finite α : Prop) ∨ (Infinite α : Prop)) = (Or.inr h =: (Finite α : Prop) ∨ (Infinite α : Prop)))  : Or.inr h = finite_or_infinite α
<input>:1:73: expected term

{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (val : Invertible A) (h : (IsUnit.nonempty_invertible (Iff.mpr (Matrix.isUnit_iff_isUnit_det A =: (IsUnit A : Prop) ↔ (IsUnit Matrix.det A : Prop)) h_det =: IsUnit A) =: Nonempty Invertible A) = (Nonempty.intro val =: Nonempty Invertible A))  : Nonempty.intro val = IsUnit.nonempty_invertible Iff.mpr Matrix.isUnit_iff_isUnit_det A h_det
<input>:1:183: expected term

{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (val : Invertible A) (h : (IsUnit.nonempty_invertible (Iff.mpr (Matrix.isUnit_iff_isUnit_det A =: (IsUnit A : Prop) ↔ (IsUnit Matrix.det A : Prop)) h_det =: IsUnit A) =: Nonempty Invertible A) = (Nonempty.intro val =: Nonempty Invertible A))  : ⅟ A = ⅟ A
<input>:1:183: expected term

{α : Type u_1} {β : Type u_2} {e : LocalEquiv α β} {s : Set α} {t : Set β} {e' : LocalEquiv α β} (h : LocalEquiv.IsImage e s t) (hs : LocalEquiv.source e ∩ s = LocalEquiv.source e' ∩ s) (heq : Set.EqOn ↑ e ↑ e' LocalEquiv.source e ∩ s) ⦃ y : β ⦄ (a : y ∈ ↑ e '' LocalEquiv.source e ∩ s) (x : α) (h : (x ∈ LocalEquiv.source e ∩ s : Prop) ∧ (↑ e x = y : Prop)) (hx : x ∈ LocalEquiv.source e ∩ s) (right : ↑ e x = y) hx' : x ∈ LocalEquiv.source e ∩ s := hx  : ↑ e x = ↑ e' x
<input>:1:414: expected '/--' or ':'

 : (∀ {X : Type u_1} [inst : NormedAddCommGroup X] {M : Type u_2} [inst_1 : Ring M] [inst_2 : Module M X] {P : M} (self : IsLprojection X P) (x : X) , ‖ x ‖ = ‖ P • x ‖ + ‖ 1 - P • x ‖)
<input>:1:157: expected term

 : ∀ (X : Type u_1) [inst : NormedAddCommGroup X] (M : Type u_2) [inst_1 : Ring M] [inst_2 : Module M X] (P : M) (self : IsLprojection X P) (x : X) , ‖ x ‖ = ‖ P • x ‖ + ‖ 1 - P • x ‖
<input>:1:156: expected term

 : (∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] (self : ModelWithCorners 𝕜 E H) , UniqueDiffOn 𝕜 LocalEquiv.target ModelWithCorners.toLocalEquiv self)
function expected at
  UniqueDiffOn 𝕜 ?m.352
term has type
  Prop ; identifiers [𝕜, u_1, inst, NontriviallyNormedField, 𝕜, E, u_2, inst_1, NormedAddCommGroup, E, inst_2, NormedSpace, 𝕜, E, H, u_3, inst_3, TopologicalSpace, H, self, ModelWithCorners, 𝕜, E, H, UniqueDiffOn, 𝕜, LocalEquiv.target, ModelWithCorners.toLocalEquiv, self] (during elaboration)

 : ∀ (𝕜 : Type u_1) [inst : NontriviallyNormedField 𝕜] (E : Type u_2) [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] (H : Type u_3) [inst_3 : TopologicalSpace H] (self : ModelWithCorners 𝕜 E H) , UniqueDiffOn 𝕜 LocalEquiv.target self . 1
function expected at
  UniqueDiffOn 𝕜 ?m.352
term has type
  Prop ; identifiers [𝕜, u_1, inst, NontriviallyNormedField, 𝕜, E, u_2, inst_1, NormedAddCommGroup, E, inst_2, NormedSpace, 𝕜, E, H, u_3, inst_3, TopologicalSpace, H, self, ModelWithCorners, 𝕜, E, H, UniqueDiffOn, 𝕜, LocalEquiv.target, self] (during elaboration)

{α : Type u_1} {β : Type u_2} {e : LocalEquiv α β} {s : Set α} {t : Set β} {e' : LocalEquiv α β} (h : LocalEquiv.IsImage e s t) (hs : LocalEquiv.source e ∩ s = LocalEquiv.source e' ∩ s) (heq : Set.EqOn ↑ e ↑ e' LocalEquiv.source e ∩ s) ⦃ y : β ⦄ (a : y ∈ ↑ e '' LocalEquiv.source e ∩ s) (x : α) (h : (x ∈ LocalEquiv.source e ∩ s : Prop) ∧ (↑ e x = y : Prop)) (hx : x ∈ LocalEquiv.source e ∩ s) (right : ↑ e x = y) hx' : x ∈ LocalEquiv.source e ∩ s := hx  : x = x
<input>:1:414: expected '/--' or ':'

{β : Type u} {α : Type v} [inst : CommMonoid β] {p : (a : α) → Prop} {F : Fintype Subtype p} (s : Finset α) (h : ∀ (x : α) , (x ∈ s : Prop) ↔ (p x : Prop)) (f : (a : α) → β) (this : fun (x : α) ↦ x ∈ s = p) {F : Fintype {x : α // x ∈ s}} (h : ∀ (x : α) , (x ∈ s : Prop) ↔ (fun (x : α) ↦ x ∈ s x : Prop)) (α : Type v) (inst : Fintype α) (inst' : Fintype α) (e'_2 : inst = inst') (h : inst' = inst) (inst' : Fintype α)  : inst = inst
application type mismatch
  Fintype Subtype
argument
  Subtype
has type
  (?m.21 → Prop) → Sort (max 1 ?u.20) : Type (max 1 ?u.20)
but is expected to have type
  Type ?u.19 : Type (?u.19 + 1) ; identifiers [β, u, α, v, inst, CommMonoid, β, p, a, α, F, Fintype, Subtype, p, s, Finset, α, h, x, α, x, s, p, x, f, a, α, β, this, x, α, x, s, p, F, Fintype, x, α, x, s, h, x, α, x, s, x, α, x, s, x, α, v, inst, Fintype, α, inst', Fintype, α, e'_2, inst, inst', h, inst', inst, inst', Fintype, α, inst, inst] (during elaboration)

{β : Type u} {α : Type v} [inst : CommMonoid β] {p : (a : α) → Prop} {F : Fintype Subtype p} (s : Finset α) (h : ∀ (x : α) , (x ∈ s : Prop) ↔ (p x : Prop)) (f : (a : α) → β) (this : fun (x : α) ↦ x ∈ s = p) {F : Fintype {x : α // x ∈ s}} (h : ∀ (x : α) , (x ∈ s : Prop) ↔ (fun (x : α) ↦ x ∈ s x : Prop)) (α : Type v) (inst : Fintype α) (inst' : Fintype α) (e'_2 : inst = inst') (h : inst' = inst)  : inst = inst'
application type mismatch
  Fintype Subtype
argument
  Subtype
has type
  (?m.21 → Prop) → Sort (max 1 ?u.20) : Type (max 1 ?u.20)
but is expected to have type
  Type ?u.19 : Type (?u.19 + 1) ; identifiers [β, u, α, v, inst, CommMonoid, β, p, a, α, F, Fintype, Subtype, p, s, Finset, α, h, x, α, x, s, p, x, f, a, α, β, this, x, α, x, s, p, F, Fintype, x, α, x, s, h, x, α, x, s, x, α, x, s, x, α, v, inst, Fintype, α, inst', Fintype, α, e'_2, inst, inst', h, inst', inst, inst, inst'] (during elaboration)

{β : Type u} {α : Type v} [inst : CommMonoid β] {p : (a : α) → Prop} {F : Fintype Subtype p} (s : Finset α) (h : ∀ (x : α) , (x ∈ s : Prop) ↔ (p x : Prop)) (f : (a : α) → β) (this : fun (x : α) ↦ x ∈ s = p) {F : Fintype {x : α // x ∈ s}} (h : ∀ (x : α) , (x ∈ s : Prop) ↔ (fun (x : α) ↦ x ∈ s x : Prop)) (α : Type v) (inst : Fintype α) (inst' : Fintype α) (e'_2 : inst = inst')  : inst' = inst'
application type mismatch
  Fintype Subtype
argument
  Subtype
has type
  (?m.21 → Prop) → Sort (max 1 ?u.20) : Type (max 1 ?u.20)
but is expected to have type
  Type ?u.19 : Type (?u.19 + 1) ; identifiers [β, u, α, v, inst, CommMonoid, β, p, a, α, F, Fintype, Subtype, p, s, Finset, α, h, x, α, x, s, p, x, f, a, α, β, this, x, α, x, s, p, F, Fintype, x, α, x, s, h, x, α, x, s, x, α, x, s, x, α, v, inst, Fintype, α, inst', Fintype, α, e'_2, inst, inst', inst', inst'] (during elaboration)

{Ω : Type u_1} {ι : Type u_2} {m0 : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] {s : (a : ι) → MeasurableSpace Ω} [SemilatticeSup ι] [NoMaxOrder ι] [Nonempty ι] (h_le : ∀ (n : ι) , s n ≤ m0) (h_indep : ProbabilityTheory.iIndep s) ns : (a : ι) → Set ι := Set.Iic (hnsp : ∀ (i : ι) , BddAbove ns i) (t : Set ι) (a : ∃ (x : ι) , x ∈ {x : ι | ∀ ⦃ a : ι ⦄ (a_1 : a ∈ t) , a ≤ x}) (a : ι) (ha : a ∈ {x : ι | ∀ ⦃ a : ι ⦄ (a_1 : a ∈ t) , a ≤ x}) (b : ι) (hb : a < b) (c : ι) (hc : b ≤ c) (hct : c ∈ t)  : c ≤ a
<input>:1:277: expected end of input

{M : Type u_2} [AddZeroClass M] {ι : Sort u_1} {S : (a : ι) → AddSubmonoid M} {x : M} (motive : (x : ∃ (i : ι) , x ∈ S i) → Prop) (x_1 : ∃ (i : ι) , x ∈ S i) (h_1 : ∀ (i : ι) (hi : x ∈ S i) , motive (Exists.intro i hi =: ∃ (i : ι) , x ∈ S i))  : ∀ (w : ι) (h : x ∈ S w) , motive Exists.intro w h
<input>:1:219: expected term

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMax a : Prop)) (b : Fin n + 1)  : (a < ⊤) = (a < ⊤)
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMax, a, b, Fin, n, a, a] (during elaboration)

{V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [Fact (FiniteDimensional.finrank ℝ V = 2 : Prop)] (o : Orientation ℝ V Fin 2) {x : V} {y : V} (h : Orientation.oangle o x y = ↑ - Real.pi / 2)  : ↑ - Real.pi / 2 = Orientation.oangle o x y
<input>:1:190: unexpected token at this precedence level; consider parenthesizing the term

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMax a : Prop)) (b : Fin n + 1)  : (¬ (⊤ ≤ a : Prop)) = (¬ (⊤ ≤ a : Prop))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMax, a, b, Fin, n, a, a] (during elaboration)

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMax a : Prop)) (b : Fin n + 1)  : (¬ (a = ⊤ : Prop)) = (¬ (a = ⊤ : Prop))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMax, a, b, Fin, n, a, a] (during elaboration)

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMax a : Prop)) (b : Fin n + 1)  : ((a < b : Prop) ↔ (a + 1 ≤ b : Prop)) = ((a < b : Prop) ↔ (a + 1 ≤ b : Prop))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMax, a, b, Fin, n, a, b, a, b, a, b, a, b] (during elaboration)

 : (∀ {α : Type u_1} [inst : SDiff α] {a : Part α} {b : Part α} (hab : Part.Dom a \ b) , Part.Dom b)
application type mismatch
  a.Dom \ b
argument
  b
has type
  Part α : Type u_1
but is expected to have type
  Prop : Type ; identifiers [α, u_1, inst, SDiff, α, a, Part, α, b, Part, α, hab, Part.Dom, a, b, Part.Dom, b] (during elaboration)

 : ∀ {α : Type u_1} [inst : SDiff α] {a : Part α} {b : Part α} (hab : Part.Dom a \ b) , Part.Dom fun (b_1 : Part.Dom fun (x : α) (x_1 : α) ↦ x \ x_1 <$> a) ↦ fun (y : (a : α) → α) ↦ Part.map y fun (x : Unit) ↦ b () Part.get fun (x : α) (x_1 : α) ↦ x \ x_1 <$> a b_1 hab . 1
application type mismatch
  a.Dom \ b
argument
  b
has type
  Part α : Type u_1
but is expected to have type
  Prop : Type ; identifiers [α, u_1, inst, SDiff, α, a, Part, α, b, Part, α, hab, Part.Dom, a, b, Part.Dom, b_1, Part.Dom, x, α, x_1, α, x, x_1, a, y, a, α, α, Part.map, y, x, Unit, b, Part.get, x, α, x_1, α, x, x_1, a, b_1, hab] (during elaboration)

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMax a : Prop)) (b : Fin n + 1)  : ((↑ a < ↑ b : Prop) ↔ (a + 1 ≤ b : Prop)) = ((↑ a < ↑ b : Prop) ↔ (a + 1 ≤ b : Prop))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMax, a, b, Fin, n, a, b, a, b, a, b, a, b] (during elaboration)

 : (- 1 = ↑ - 1) = (- 1 = ↑ - 1)
<input>:1:12: unexpected token at this precedence level; consider parenthesizing the term

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMax a : Prop)) (b : Fin n + 1)  : ((↑ a < ↑ b : Prop) ↔ (↑ a + 1 ≤ ↑ b : Prop)) = ((↑ a < ↑ b : Prop) ↔ (↑ a + 1 ≤ ↑ b : Prop))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMax, a, b, Fin, n, a, b, a, b, a, b, a, b] (during elaboration)

 : (∀ {R : Type u} {ι : Type u'} {M₁ : (a : ι) → Type v} {M₂ : Type w} [inst : Semiring R] [inst_1 : (i : ι) → AddCommMonoid M₁ i] [inst_2 : AddCommMonoid M₂] [inst_3 : (i : ι) → Module R M₁ i] [inst_4 : Module R M₂] (self : MultilinearMap R M₁ M₂) [inst_5 : DecidableEq ι] (m : (i : ι) → M₁ i) (i : ι) (x : M₁ i) (y : M₁ i) , MultilinearMap.toFun self Function.update m i x + y = MultilinearMap.toFun self Function.update m i x + MultilinearMap.toFun self Function.update m i y)
application type mismatch
  AddCommMonoid M₁
argument
  M₁
has type
  ι → Type v : Type (max u' (v + 1))
but is expected to have type
  Type ?u.20 : Type (?u.20 + 1) ; identifiers [R, u, ι, u', M₁, a, ι, v, M₂, w, inst, Semiring, R, inst_1, i, ι, AddCommMonoid, M₁, i, inst_2, AddCommMonoid, M₂, inst_3, i, ι, Module, R, M₁, i, inst_4, Module, R, M₂, self, MultilinearMap, R, M₁, M₂, inst_5, DecidableEq, ι, m, i, ι, M₁, i, i, ι, x, M₁, i, y, M₁, i, MultilinearMap.toFun, self, Function.update, m, i, x, y, MultilinearMap.toFun, self, Function.update, m, i, x, MultilinearMap.toFun, self, Function.update, m, i, y] (during elaboration)

 : ∀ (R : Type u) (ι : Type u') (M₁ : (a : ι) → Type v) (M₂ : Type w) [inst : Semiring R] [inst_1 : (i : ι) → AddCommMonoid M₁ i] [inst_2 : AddCommMonoid M₂] [inst_3 : (i : ι) → Module R M₁ i] [inst_4 : Module R M₂] (self : MultilinearMap R M₁ M₂) [inst : DecidableEq ι] (m : (i : ι) → M₁ i) (i : ι) (x : M₁ i) (y : M₁ i) , self . 1 Function.update m i x + y = self . 1 Function.update m i x + self . 1 Function.update m i y
application type mismatch
  AddCommMonoid M₁
argument
  M₁
has type
  ι → Type v : Type (max u' (v + 1))
but is expected to have type
  Type ?u.20 : Type (?u.20 + 1) ; identifiers [R, u, ι, u', M₁, a, ι, v, M₂, w, inst, Semiring, R, inst_1, i, ι, AddCommMonoid, M₁, i, inst_2, AddCommMonoid, M₂, inst_3, i, ι, Module, R, M₁, i, inst_4, Module, R, M₂, self, MultilinearMap, R, M₁, M₂, inst, DecidableEq, ι, m, i, ι, M₁, i, i, ι, x, M₁, i, y, M₁, i, self, Function.update, m, i, x, y, self, Function.update, m, i, x, self, Function.update, m, i, y] (during elaboration)

 : (∀ {α : Type u} [inst : SizeOf α] , sizeOf LazyList.nil = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (LazyList ?m.6756) ; identifiers [α, u, inst, SizeOf, α, sizeOf, LazyList.nil] (during elaboration)

{α : Type u_1} [OrderedAddCommGroup α] {a : α} (ha : 0 ≤ a) (m : ℤ) (n : ℤ) (h : m ≤ n)  : (m • a + n - m • a = n • a) = (m • a + n - m • a = n • a)
failed to synthesize instance
  HAdd α ℤ ?m.161069 ; identifiers [α, u_1, OrderedAddCommGroup, α, a, α, ha, a, m, n, h, m, n, m, a, n, m, a, n, a, m, a, n, m, a, n, a] (during elaboration)

{V : Type w'} [FirstOrder.Language.Structure FirstOrder.Language.graph V] (φ : FirstOrder.Language.Sentence FirstOrder.Language.graph)  : (V ⊨ φ) = (V ⊨ φ)
unknown universe level 'w'' ; identifiers [V, w', FirstOrder.Language.Structure, FirstOrder.Language.graph, V, φ, FirstOrder.Language.Sentence, FirstOrder.Language.graph, V, φ, V, φ, V, φ, V, φ] (during elaboration)

{V : Type w'} [FirstOrder.Language.Structure FirstOrder.Language.graph V]  : (∀ (a : FirstOrder.Language.Sentence FirstOrder.Language.graph) (a_1 : (a = FirstOrder.Language.Relations.irreflexive FirstOrder.Language.adj : Prop) ∨ (a = FirstOrder.Language.Relations.symmetric FirstOrder.Language.adj : Prop)) , V ⊨ a) = ((V ⊨ FirstOrder.Language.Relations.irreflexive FirstOrder.Language.adj : Prop) ∧ (∀ (a : FirstOrder.Language.Sentence FirstOrder.Language.graph) (a_1 : a = FirstOrder.Language.Relations.symmetric FirstOrder.Language.adj) , V ⊨ a : Prop))
unknown universe level 'w'' ; identifiers [V, w', FirstOrder.Language.Structure, FirstOrder.Language.graph, V, a, FirstOrder.Language.Sentence, FirstOrder.Language.graph, a_1, a, FirstOrder.Language.Relations.irreflexive, FirstOrder.Language.adj, a, FirstOrder.Language.Relations.symmetric, FirstOrder.Language.adj, V, a, V, a, V, FirstOrder.Language.Relations.irreflexive, FirstOrder.Language.adj, V, FirstOrder.Language.Relations.irreflexive, FirstOrder.Language.adj, a, FirstOrder.Language.Sentence, FirstOrder.Language.graph, a_1, a, FirstOrder.Language.Relations.symmetric, FirstOrder.Language.adj, V, a, V, a] (during elaboration)

{V : Type w'} [FirstOrder.Language.Structure FirstOrder.Language.graph V]  : (∀ (a : FirstOrder.Language.Sentence FirstOrder.Language.graph) (a_1 : a = FirstOrder.Language.Relations.symmetric FirstOrder.Language.adj) , V ⊨ a) = (V ⊨ FirstOrder.Language.Relations.symmetric FirstOrder.Language.adj)
unknown universe level 'w'' ; identifiers [V, w', FirstOrder.Language.Structure, FirstOrder.Language.graph, V, a, FirstOrder.Language.Sentence, FirstOrder.Language.graph, a_1, a, FirstOrder.Language.Relations.symmetric, FirstOrder.Language.adj, V, a, V, a, V, FirstOrder.Language.Relations.symmetric, FirstOrder.Language.adj, V, FirstOrder.Language.Relations.symmetric, FirstOrder.Language.adj] (during elaboration)

{R : Type u_1} [CommRing R] (asIdeal : Ideal R) (isPrime : Ideal.IsPrime asIdeal) (ne_bot : asIdeal ≠ ⊥) (asIdeal_1 : Ideal R) (isPrime_1 : Ideal.IsPrime asIdeal_1) (ne_bot_1 : asIdeal_1 ≠ ⊥) (a : asIdeal = asIdeal_1) (h : asIdeal_1 = asIdeal) (isPrime_2 : Ideal.IsPrime asIdeal) (ne_bot_2 : asIdeal ≠ ⊥) (a : asIdeal = asIdeal) (h : HEq a (Eq.refl asIdeal =: asIdeal = asIdeal))  : {asIdeal := ((asIdeal)) , isPrime := ((isPrime)) , ne_bot := ((ne_bot))} = {asIdeal := ((asIdeal)) , isPrime := ((isPrime)) , ne_bot := ((ne_bot))}
<input>:1:358: expected term

{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] (ι : Type u_1) [Unique ι] (h : FiniteDimensional.finrank K V = 1) (v : V) (hv : v ≠ 0)  : {v} = {v}
typeclass instance problem is stuck, it is often due to metavariables
  Singleton V (?m.1867 ι h v hv) ; identifiers [K, u, V, v, DivisionRing, K, AddCommGroup, V, Module, K, V, ι, u_1, Unique, ι, h, FiniteDimensional.finrank, K, V, v, V, hv, v, v, v, v, v] (during elaboration)

{P : AlgebraicGeometry.AffineTargetMorphismProperty} (hP : CategoryTheory.MorphismProperty.RespectsIso AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P) {X : AlgebraicGeometry.Scheme} {Y : AlgebraicGeometry.Scheme} {Z : AlgebraicGeometry.Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) [CategoryTheory.IsIso g] [AlgebraicGeometry.IsAffine Z] [AlgebraicGeometry.IsAffine Y]  : (AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P f) ↔ (AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P f)
function expected at
  CategoryTheory.MorphismProperty.RespectsIso ?m.79589
term has type
  Prop ; identifiers [P, AlgebraicGeometry.AffineTargetMorphismProperty, hP, CategoryTheory.MorphismProperty.RespectsIso, AlgebraicGeometry.AffineTargetMorphismProperty.toProperty, P, X, AlgebraicGeometry.Scheme, Y, AlgebraicGeometry.Scheme, Z, AlgebraicGeometry.Scheme, f, X, Y, g, Y, Z, CategoryTheory.IsIso, g, AlgebraicGeometry.IsAffine, Z, AlgebraicGeometry.IsAffine, Y, AlgebraicGeometry.AffineTargetMorphismProperty.toProperty, P, f, AlgebraicGeometry.AffineTargetMorphismProperty.toProperty, P, f] (during elaboration)

{α : Sort u_1} {β : Sort u_2} [Finite β] (f : (a : α) → β) (H : Function.Injective f) (val : Fintype PLift β) (h : (nonempty_fintype PLift β =: Nonempty Fintype PLift β) = (Nonempty.intro val =: Nonempty Fintype PLift β))  : Nonempty.intro val = nonempty_fintype PLift β
<input>:1:142: expected term

{α : Type u_2} {ι : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} [Countable ι] {s : (a : ι) → Set α} (hd : Pairwise Disjoint on s) (hm : ∀ (i : ι) , MeasurableSet s i) (i : ι)  : MeasurableSet s i
type expected, got
  (?m.79791 on s : ι → ι → ?m.40) ; identifiers [α, u_2, ι, u_1, m0, MeasurableSpace, α, μ, MeasureTheory.Measure, α, Countable, ι, s, a, ι, Set, α, hd, Pairwise, Disjoint, s, hm, i, ι, MeasurableSet, s, i, i, ι, MeasurableSet, s, i] (during elaboration)

{α : Type u_1} {E' : Type u_2} [SeminormedAddCommGroup E'] {l : Filter α} {f₁ : (a : α) → E'} {f₂ : (a : α) → E'} (h : f₂ =o[l] f₁)  : (f₁ =O[l] f₁ + f₂) = (f₁ =O[l] f₁ + f₂)
failed to synthesize
  CoeT (α → E') x Prop
(deterministic) timeout at 'typeclass', maximum number of heartbeats (20000) has been reached (use 'set_option synthInstance.maxHeartbeats <num>' to set the limit) ; identifiers [α, u_1, E', u_2, SeminormedAddCommGroup, E', l, Filter, α, f₁, a, α, E', f₂, a, α, E', h, f₂, l, f₁, f₁, l, f₁, f₂, f₁, l, f₁, f₂] (during elaboration)

{α : Type u} {s : Stream' α} (x : ℕ) (x_1 : ℕ) (x : ℕ) (f : Nat.below (motive := fun (x : ℕ) ↦ ∀ {s : Stream' α} (x_2 : ℕ) , List.take x Stream'.take x_2 s = Stream'.take min x_2 x s) x) {s : Stream' α} (x_2 : ℕ) (n : ℕ) (x : Nat.below (motive := fun (x : ℕ) ↦ ∀ {s : Stream' α} (x_3 : ℕ) , List.take x Stream'.take x_3 s = Stream'.take min x_3 x s) 0)  : [] = []
function expected at
  List.take x ?m.79956
term has type
  List ?m.30 ; identifiers [α, u, s, Stream', α, x, x_1, x, f, Nat.below, motive, x, s, Stream', α, x_2, List.take, x, Stream'.take, x_2, s, Stream'.take, min, x_2, x, s, x, s, Stream', α, x_2, n, x, Nat.below, motive, x, s, Stream', α, x_3, List.take, x, Stream'.take, x_3, s, Stream'.take, min, x_3, x, s] (during elaboration)

{R : Type u} {A : Type v} {inst : CommSemiring R} {inst_1 : NonUnitalNonAssocSemiring A} {inst_2 : Module R A} {inst_3 : Star A} {toNonUnitalSubalgebra : NonUnitalSubalgebra R A} {star_mem' : ∀ {a : A} (_ha : a ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup NonUnitalSubsemiring.toAddSubmonoid NonUnitalSubalgebra.toNonUnitalSubsemiring toNonUnitalSubalgebra) , star a ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup NonUnitalSubsemiring.toAddSubmonoid NonUnitalSubalgebra.toNonUnitalSubsemiring toNonUnitalSubalgebra} {toNonUnitalSubalgebra_1 : NonUnitalSubalgebra R A} {star_mem'_1 : ∀ {a : A} (_ha : a ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup NonUnitalSubsemiring.toAddSubmonoid NonUnitalSubalgebra.toNonUnitalSubsemiring toNonUnitalSubalgebra_1) , star a ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup NonUnitalSubsemiring.toAddSubmonoid NonUnitalSubalgebra.toNonUnitalSubsemiring toNonUnitalSubalgebra_1} (x : {toNonUnitalSubalgebra := ((toNonUnitalSubalgebra)) , star_mem' := ((star_mem'))} = {toNonUnitalSubalgebra := ((toNonUnitalSubalgebra_1)) , star_mem' := ((star_mem'_1))})  : ∀ (toNonUnitalSubalgebra_eq : toNonUnitalSubalgebra = toNonUnitalSubalgebra_1) , toNonUnitalSubalgebra = toNonUnitalSubalgebra_1
function expected at
  AddSubsemigroup.carrier ?m.80289 NonUnitalSubsemiring.toAddSubmonoid
term has type
  Prop ; identifiers [R, u, A, v, inst, CommSemiring, R, inst_1, NonUnitalNonAssocSemiring, A, inst_2, Module, R, A, inst_3, Star, A, toNonUnitalSubalgebra, NonUnitalSubalgebra, R, A, star_mem', a, A, _ha, a, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, NonUnitalSubsemiring.toAddSubmonoid, NonUnitalSubalgebra.toNonUnitalSubsemiring, toNonUnitalSubalgebra, star, a, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, NonUnitalSubsemiring.toAddSubmonoid, NonUnitalSubalgebra.toNonUnitalSubsemiring, toNonUnitalSubalgebra, toNonUnitalSubalgebra_1, NonUnitalSubalgebra, R, A, star_mem'_1, a, A, _ha, a, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, NonUnitalSubsemiring.toAddSubmonoid, NonUnitalSubalgebra.toNonUnitalSubsemiring, toNonUnitalSubalgebra_1, star, a, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, NonUnitalSubsemiring.toAddSubmonoid, NonUnitalSubalgebra.toNonUnitalSubsemiring, toNonUnitalSubalgebra_1, x, toNonUnitalSubalgebra, toNonUnitalSubalgebra, star_mem', star_mem', toNonUnitalSubalgebra, toNonUnitalSubalgebra_1, star_mem', star_mem'_1, toNonUnitalSubalgebra_eq, toNonUnitalSubalgebra, toNonUnitalSubalgebra_1, toNonUnitalSubalgebra, toNonUnitalSubalgebra_1] (during elaboration)

{α : Type u} {s : Stream' α} (x : ℕ) (x_1 : ℕ) (x : ℕ) (f : Nat.below (motive := fun (x : ℕ) ↦ ∀ {s : Stream' α} (x_2 : ℕ) , List.take x Stream'.take x_2 s = Stream'.take min x_2 x s) x) {s : Stream' α} (x_2 : ℕ) (m : ℕ) (x : Nat.below (motive := fun (x : ℕ) ↦ ∀ {s : Stream' α} (x_3 : ℕ) , List.take x Stream'.take x_3 s = Stream'.take min x_3 x s) m)  : [] = []
function expected at
  List.take x ?m.79956
term has type
  List ?m.30 ; identifiers [α, u, s, Stream', α, x, x_1, x, f, Nat.below, motive, x, s, Stream', α, x_2, List.take, x, Stream'.take, x_2, s, Stream'.take, min, x_2, x, s, x, s, Stream', α, x_2, m, x, Nat.below, motive, x, s, Stream', α, x_3, List.take, x, Stream'.take, x_3, s, Stream'.take, min, x_3, x, s, m] (during elaboration)

{α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} (r : ENNReal) (f : (a : α) → ENNReal) (s : MeasureTheory.SimpleFunc α ENNReal) (hs : ↑ s ≤ fun (a : α) ↦ f a) (x : α)  : ↑ s x ≤ fun (a : α) ↦ f a x
function expected at
  f a
term has type
  ENNReal ; identifiers [α, u_1, m, MeasurableSpace, α, μ, MeasureTheory.Measure, α, r, ENNReal, f, a, α, ENNReal, s, MeasureTheory.SimpleFunc, α, ENNReal, hs, s, a, α, f, a, x, α, s, x, a, α, f, a, x] (during elaboration)

{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasImages V] {A : V} {B : V} {C : V} (f : A ⟶ B) (g : B ⟶ C) [CategoryTheory.Limits.HasZeroMorphisms V] [CategoryTheory.Limits.HasEqualizers V] [CategoryTheory.Limits.HasCokernels V] (h : CategoryTheory.Exact f g) (this : CategoryTheory.CategoryStruct.comp CategoryTheory.Subobject.arrow CategoryTheory.Limits.kernelSubobject g CategoryTheory.Limits.cokernel.π f = 0)  : 0 = 0
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81327 ?m.162248
term has type
  ?m.749 ⟶ ?m.751 ; identifiers [V, u, CategoryTheory.Category, V, CategoryTheory.Limits.HasImages, V, A, V, B, V, C, V, f, A, B, g, B, C, CategoryTheory.Limits.HasZeroMorphisms, V, CategoryTheory.Limits.HasEqualizers, V, CategoryTheory.Limits.HasCokernels, V, h, CategoryTheory.Exact, f, g, this, CategoryTheory.CategoryStruct.comp, CategoryTheory.Subobject.arrow, CategoryTheory.Limits.kernelSubobject, g, CategoryTheory.Limits.cokernel.π, f] (during elaboration)

{F : PFunctor} {motive : {n : ℕ} → (a : PFunctor.Approx.CofixA F n) → (a_1 : PFunctor.Approx.CofixA F n + 1) → (x : PFunctor.Approx.Agree a a_1) → Prop} {n : ℕ} {a : PFunctor.Approx.CofixA F n} {a_1 : PFunctor.Approx.CofixA F n + 1} (x : PFunctor.Approx.Agree a a_1) (ih : ∀ {n : ℕ} (a : PFunctor.Approx.CofixA F n) (a_2 : PFunctor.Approx.CofixA F n + 1) (x : PFunctor.Approx.Agree a a_2) (x_1 : PFunctor.Approx.Agree.below x) , motive a a_2 x) {n : ℕ} {a : PFunctor.A F} (x : (a : PFunctor.B F a) → PFunctor.Approx.CofixA F n) (x' : (a : PFunctor.B F a) → PFunctor.Approx.CofixA F n + 1) (a_2 : ∀ (i : PFunctor.B F a) , PFunctor.Approx.Agree x i x' i) (a_ih : ∀ (i : PFunctor.B F a) , PFunctor.Approx.Agree.below (a_2 i =: PFunctor.Approx.Agree x i x' i))  : ∀ (i : PFunctor.B F a) , PFunctor.Approx.Agree.below a_2 i
<input>:1:722: expected term

{F : PFunctor} {motive : {n : ℕ} → (a : PFunctor.Approx.CofixA F n) → (a_1 : PFunctor.Approx.CofixA F n + 1) → (x : PFunctor.Approx.Agree a a_1) → Prop} {n : ℕ} {a : PFunctor.Approx.CofixA F n} {a_1 : PFunctor.Approx.CofixA F n + 1} (x : PFunctor.Approx.Agree a a_1) (ih : ∀ {n : ℕ} (a : PFunctor.Approx.CofixA F n) (a_2 : PFunctor.Approx.CofixA F n + 1) (x : PFunctor.Approx.Agree a a_2) (x_1 : PFunctor.Approx.Agree.below x) , motive a a_2 x) {n : ℕ} {a : PFunctor.A F} (x : (a : PFunctor.B F a) → PFunctor.Approx.CofixA F n) (x' : (a : PFunctor.B F a) → PFunctor.Approx.CofixA F n + 1) (a_2 : ∀ (i : PFunctor.B F a) , PFunctor.Approx.Agree x i x' i) (a_ih : ∀ (i : PFunctor.B F a) , PFunctor.Approx.Agree.below (a_2 i =: PFunctor.Approx.Agree x i x' i)) (i : PFunctor.B F a)  : PFunctor.Approx.Agree x i x' i
<input>:1:722: expected term

{F : PFunctor} {motive : {n : ℕ} → (a : PFunctor.Approx.CofixA F n) → (a_1 : PFunctor.Approx.CofixA F n + 1) → (x : PFunctor.Approx.Agree a a_1) → Prop} {n : ℕ} {a : PFunctor.Approx.CofixA F n} {a_1 : PFunctor.Approx.CofixA F n + 1} (x : PFunctor.Approx.Agree a a_1) (ih : ∀ {n : ℕ} (a : PFunctor.Approx.CofixA F n) (a_2 : PFunctor.Approx.CofixA F n + 1) (x : PFunctor.Approx.Agree a a_2) (x_1 : PFunctor.Approx.Agree.below x) , motive a a_2 x) {n : ℕ} {a : PFunctor.A F} (x : (a : PFunctor.B F a) → PFunctor.Approx.CofixA F n) (x' : (a : PFunctor.B F a) → PFunctor.Approx.CofixA F n + 1) (a_2 : ∀ (i : PFunctor.B F a) , PFunctor.Approx.Agree x i x' i) (a_ih : ∀ (i : PFunctor.B F a) , PFunctor.Approx.Agree.below (a_2 i =: PFunctor.Approx.Agree x i x' i)) (i : PFunctor.B F a)  : PFunctor.Approx.Agree.below a_2 i
<input>:1:722: expected term

{G : Type u_1} [Group G] (ϕ : G ≃* G) (g : G) (hg : g ∈ Subgroup.comap MulEquiv.toMonoidHom ϕ Subgroup.center G) (h : G)  : (h * g = g * h) = (h * g = g * h)
function expected at
  Subgroup.comap ?m.2929 ?m.161967
term has type
  Subgroup ?m.696 ; identifiers [G, u_1, Group, G, ϕ, G, G, g, G, hg, g, Subgroup.comap, MulEquiv.toMonoidHom, ϕ, Subgroup.center, G, h, G, h, g, g, h, h, g, g, h] (during elaboration)

 : (∀ {α : Type u_1} {β : Type u_2} [inst : NonUnitalNonAssocSemiring α] [inst_1 : NonUnitalNonAssocSemiring β] (self : α →ₙ+* β) , MulHom.toFun NonUnitalRingHom.toMulHom self 0 = 0)
function expected at
  MulHom.toFun ?m.550 self
term has type
  ?m.39 ; identifiers [α, u_1, β, u_2, inst, NonUnitalNonAssocSemiring, α, inst_1, NonUnitalNonAssocSemiring, β, self, α, β, MulHom.toFun, NonUnitalRingHom.toMulHom, self] (during elaboration)

 : ∀ (α : Type u_1) (β : Type u_2) [inst : NonUnitalNonAssocSemiring α] [inst_1 : NonUnitalNonAssocSemiring β] (self : α →ₙ+* β) , MulHom.toFun self . 1 0 = 0
invalid occurrence of `·` notation, it must be surrounded by parentheses (e.g. `(· + 1)`) ; identifiers [α, u_1, β, u_2, inst, NonUnitalNonAssocSemiring, α, inst_1, NonUnitalNonAssocSemiring, β, self, α, β, MulHom.toFun, self] (during elaboration)

(a : ℕ) (b : ℕ) (c : ℕ) (this : a + b % c = a % c + b % c % c)  : (a + b % c + if (c ≤ a % c + b % c : Prop) then c else 0 = a % c + b % c) = (a + b % c + if (c ≤ a % c + b % c : Prop) then c else 0 = a % c + b % c)
application type mismatch
  if c ≤ a % c + b % c then c else 0 = a % c + b % c
argument
  0 = a % c + b % c
has type
  Prop : Type
but is expected to have type
  ℕ : Type ; identifiers [a, b, c, this, a, b, c, a, c, b, c, c, a, b, c, c, a, c, b, c, c, a, c, b, c, a, b, c, c, a, c, b, c, c, a, c, b, c] (during elaboration)

{α : Type u_1} [LinearOrder α] [LocallyFiniteOrder α] (a : α) (b : α) (c : α) (h : b ≤ c) (h_1 : (le_total b c =: (b ≤ c : Prop) ∨ (c ≤ b : Prop)) = (Or.inl h =: (b ≤ c : Prop) ∨ (c ≤ b : Prop)))  : Or.inl h = le_total b c
<input>:1:112: expected term

{M : Type u_1} [Add M] {s : Set M} {p : (a : M) → (a : M) → Prop} {x : M} {y : M} (hx : x ∈ AddSubsemigroup.closure s) (hy : y ∈ AddSubsemigroup.closure s) (Hs : ∀ (x : M) (a : x ∈ s) (y : M) (a : y ∈ s) , p x y) (Hmul_left : ∀ (x : M) (y : M) (z : M) (a : p x z) (a : p y z) , p x + y z) (Hmul_right : ∀ (x : M) (y : M) (z : M) (a : p z x) (a : p z y) , p z x + y) (x : M) (xs : x ∈ s)  : ∀ (y : M) (a : y ∈ s) , p x y
function expected at
  y
term has type
  M ; identifiers [M, u_1, Add, M, s, Set, M, p, a, M, a, M, x, M, y, M, hx, x, AddSubsemigroup.closure, s, hy, y, AddSubsemigroup.closure, s, Hs, x, M, a, x, s, y, M, a, y, s, p, x, y, Hmul_left, x, M, y, M, z, M, a, p, x, z, a, p, y, z, p, x, y, z, Hmul_right, x, M, y, M, z, M, a, p, z, x, a, p, z, y, p, z, x, y, x, M, xs, x, s, y, M, a, y, s, p, x, y] (during elaboration)

{M : Type u_1} [Add M] {s : Set M} {p : (a : M) → (a : M) → Prop} {x : M} {y : M} (hx : x ∈ AddSubsemigroup.closure s) (hy : y ∈ AddSubsemigroup.closure s) (Hs : ∀ (x : M) (a : x ∈ s) (y : M) (a : y ∈ s) , p x y) (Hmul_left : ∀ (x : M) (y : M) (z : M) (a : p x z) (a : p y z) , p x + y z) (Hmul_right : ∀ (x : M) (y : M) (z : M) (a : p z x) (a : p z y) , p z x + y) (x : M) (xs : x ∈ s)  : ∀ (z : M) (x_1 : M) (h₁ : p x z) (h₂ : p x x_1) , p x z + x_1
function expected at
  y
term has type
  M ; identifiers [M, u_1, Add, M, s, Set, M, p, a, M, a, M, x, M, y, M, hx, x, AddSubsemigroup.closure, s, hy, y, AddSubsemigroup.closure, s, Hs, x, M, a, x, s, y, M, a, y, s, p, x, y, Hmul_left, x, M, y, M, z, M, a, p, x, z, a, p, y, z, p, x, y, z, Hmul_right, x, M, y, M, z, M, a, p, z, x, a, p, z, y, p, z, x, y, x, M, xs, x, s, z, M, x_1, M, h₁, p, x, z, h₂, p, x, x_1, p, x, z, x_1] (during elaboration)

{M : Type u_1} [Add M] {s : Set M} {p : (a : M) → (a : M) → Prop} {x : M} {y : M} (hx : x ∈ AddSubsemigroup.closure s) (hy : y ∈ AddSubsemigroup.closure s) (Hs : ∀ (x : M) (a : x ∈ s) (y : M) (a : y ∈ s) , p x y) (Hmul_left : ∀ (x : M) (y : M) (z : M) (a : p x z) (a : p y z) , p x + y z) (Hmul_right : ∀ (x : M) (y : M) (z : M) (a : p z x) (a : p z y) , p z x + y)  : ∀ (x : M) (x_1 : M) (h₁ : p x y) (h₂ : p x_1 y) , p x + x_1 y
function expected at
  y
term has type
  M ; identifiers [M, u_1, Add, M, s, Set, M, p, a, M, a, M, x, M, y, M, hx, x, AddSubsemigroup.closure, s, hy, y, AddSubsemigroup.closure, s, Hs, x, M, a, x, s, y, M, a, y, s, p, x, y, Hmul_left, x, M, y, M, z, M, a, p, x, z, a, p, y, z, p, x, y, z, Hmul_right, x, M, y, M, z, M, a, p, z, x, a, p, z, y, p, z, x, y, x, M, x_1, M, h₁, p, x, y, h₂, p, x_1, y, p, x, x_1, y] (during elaboration)

{α : Type u} [Group α] [LT α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x * x_1 fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}  : ((a ⁻¹ < 1 : Prop) ↔ (1 < a : Prop)) = ((a ⁻¹ < 1 : Prop) ↔ (1 < a : Prop))
application type mismatch
  CovariantClass α α Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) → (y : ?m.20) → ?m.21 x y) →
    (y : ?m.20) → (x : ?m.19) → ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  α → α → α : Type u ; identifiers [α, u, Group, α, LT, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, a, a, a, a] (during elaboration)

{α : Type u} [Group α] [LT α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x * x_1 fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}  : ((a ⁻¹ * a < 1 * a : Prop) ↔ (1 < a : Prop)) = ((a ⁻¹ * a < 1 * a : Prop) ↔ (1 < a : Prop))
application type mismatch
  CovariantClass α α Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) → (y : ?m.20) → ?m.21 x y) →
    (y : ?m.20) → (x : ?m.19) → ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  α → α → α : Type u ; identifiers [α, u, Group, α, LT, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, a, a, a, a, a, a, a, a] (during elaboration)

{α : Type u} [Group α] [LT α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x * x_1 fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}  : ((1 < 1 * a : Prop) ↔ (1 < a : Prop)) = ((1 < 1 * a : Prop) ↔ (1 < a : Prop))
application type mismatch
  CovariantClass α α Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) → (y : ?m.20) → ?m.21 x y) →
    (y : ?m.20) → (x : ?m.19) → ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  α → α → α : Type u ; identifiers [α, u, Group, α, LT, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, a, a, a, a] (during elaboration)

(a : Ordinal .{u_1}) {b : Ordinal .{u_1}} (hb : 0 < b) (α : Type (u_1 + 1)) (self : LE α) (a : α) (a' : α) (e'_3 : a = a') (a_1 : α) (h : a' = a) (a' : α)  : a = a
<input>:1:13: expected ')'

{α : Type u} [Group α] [LT α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x * x_1 fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}  : (1 < a) ↔ (1 < a)
application type mismatch
  CovariantClass α α Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) → (y : ?m.20) → ?m.21 x y) →
    (y : ?m.20) → (x : ?m.19) → ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  α → α → α : Type u ; identifiers [α, u, Group, α, LT, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, a, a] (during elaboration)

(a : Ordinal .{u_1}) {b : Ordinal .{u_1}} (hb : 0 < b) (α : Type (u_1 + 1)) (self : LE α) (a : α) (a' : α) (e'_3 : a = a') (a_1 : α) (h : a' = a)  : a = a'
<input>:1:13: expected ')'

(a : Ordinal .{u_1}) {b : Ordinal .{u_1}} (hb : 0 < b) (α : Type (u_1 + 1)) (self : LE α) (a : α) (a' : α) (e'_3 : a = a') (a_1 : α)  : a' = a'
<input>:1:13: expected ')'

(a : Ordinal .{u_1}) {b : Ordinal .{u_1}} (hb : 0 < b)  : (a = a * 1) = (a = a * 1)
<input>:1:13: expected ')'

(a : Ordinal .{u_1}) {b : Ordinal .{u_1}} (hb : 0 < b)  : a = a
<input>:1:13: expected ')'

{α : Type u_1} [LinearOrder α] [LocallyFiniteOrder α] (a : α) (b : α) (c : α) (h : c ≤ b) (h_1 : (le_total b c =: (b ≤ c : Prop) ∨ (c ≤ b : Prop)) = (Or.inr h =: (b ≤ c : Prop) ∨ (c ≤ b : Prop)))  : Or.inr h = le_total b c
<input>:1:112: expected term

{α : Sort u_1} {β : Sort u_2} {r : (a : α) → (a : α) → Prop} {s : (a : β) → (a : β) → Prop} {δ : (a : Quot r) → (a : Quot s) → Prop} (q₁ : Quot r) (q₂ : Quot s) (h : ∀ (a : α) (b : β) , δ Quot.mk r a Quot.mk s b) (a₁ : α)  : ∀ (a₂ : β) , δ Quot.mk r a₁ Quot.mk s a₂
application type mismatch
  δ Quot.mk
argument
  Quot.mk
has type
  (r : ?m.80 → ?m.80 → Prop) → ?m.80 → Quot r : Sort (imax (max 1 ?u.79) ?u.79)
but is expected to have type
  Quot r : Sort u_1 ; identifiers [α, u_1, β, u_2, r, a, α, a, α, s, a, β, a, β, δ, a, Quot, r, a, Quot, s, q₁, Quot, r, q₂, Quot, s, h, a, α, b, β, δ, Quot.mk, r, a, Quot.mk, s, b, a₁, α, a₂, β, δ, Quot.mk, r, a₁, Quot.mk, s, a₂] (during elaboration)

{α : Type u_1} {β : Type u_2} (p : Pmf α) (f : (a : α) → Pmf β) (b : β) (this : ∀ (a : α) , if (↑ p a = 0 : Prop) then 0 else ↑ p a * ↑ f a b = ↑ p a * ↑ f a b) (a : α)  : (↑ p a = 0) = (↑ p a = 0)
failed to synthesize instance
  OfNat (Sort ?u.26) 0 ; identifiers [α, u_1, β, u_2, p, Pmf, α, f, a, α, Pmf, β, b, β, this, a, α, p, a, p, a, f, a, b, p, a, f, a, b, a, α, p, a, p, a] (during elaboration)

{α : Type u_1} {β : Type u_2} (p : Pmf α) (f : (a : α) → Pmf β) (b : β) (this : ∀ (a : α) , if (↑ p a = 0 : Prop) then 0 else ↑ p a * ↑ f a b = ↑ p a * ↑ f a b) (a : α)  : ∀ (h : ↑ p a = 0) , 0 = 0
failed to synthesize instance
  OfNat (Sort ?u.26) 0 ; identifiers [α, u_1, β, u_2, p, Pmf, α, f, a, α, Pmf, β, b, β, this, a, α, p, a, p, a, f, a, b, p, a, f, a, b, a, α, h, p, a] (during elaboration)

{α : Type u_1} {β : Type u_2} (p : Pmf α) (f : (a : α) → Pmf β) (b : β) (this : ∀ (a : α) , if (↑ p a = 0 : Prop) then 0 else ↑ p a * ↑ f a b = ↑ p a * ↑ f a b) (a : α)  : ∀ (h : ¬ (↑ p a = 0)) , ↑ f a b = ↑ f a b
failed to synthesize instance
  OfNat (Sort ?u.26) 0 ; identifiers [α, u_1, β, u_2, p, Pmf, α, f, a, α, Pmf, β, b, β, this, a, α, p, a, p, a, f, a, b, p, a, f, a, b, a, α, h, p, a, f, a, b, f, a, b] (during elaboration)

{α : Type u_1} {β : Type u_2} (p : Pmf α) (f : (a : α) → Pmf β) (b : β) (this : ∀ (a : α) , if (↑ p a = 0 : Prop) then 0 else ↑ p a * ↑ f a b = ↑ p a * ↑ f a b) (a : α)  : ∀ (a_1 : ¬ (↑ p a = 0)) , ↑ p a * ↑ f a b = ↑ p a * ↑ f a b
failed to synthesize instance
  OfNat (Sort ?u.26) 0 ; identifiers [α, u_1, β, u_2, p, Pmf, α, f, a, α, Pmf, β, b, β, this, a, α, p, a, p, a, f, a, b, p, a, f, a, b, a, α, a_1, p, a, p, a, f, a, b, p, a, f, a, b] (during elaboration)

{α : Type u_1} {β : Type u_2} (p : Pmf α) (f : (a : α) → Pmf β) (b : β) (this : ∀ (a : α) , if (↑ p a = 0 : Prop) then 0 else ↑ p a * ↑ f a b = ↑ p a * ↑ f a b) (a : α)  : ∀ (a : α) , if (↑ p a = 0) then 0 else ↑ p a * ↑ f a b = ↑ p a * ↑ f a b
failed to synthesize instance
  OfNat (Sort ?u.26) 0 ; identifiers [α, u_1, β, u_2, p, Pmf, α, f, a, α, Pmf, β, b, β, this, a, α, p, a, p, a, f, a, b, p, a, f, a, b, a, α, a, α, p, a, p, a, f, a, b, p, a, f, a, b] (during elaboration)

{α : Type u} [TopologicalSpace α] {ι : (a : α) → Sort u_1} {p : (a : α) → (a : ι a) → Prop} {s : (a : α) → (a : ι a) → Set α} (h₁ : ∀ (a : α) , Filter.HasBasis nhds a p a s a) (h₂ : ∀ (a : α) (i : ι a) (a_1 : p a i) , IsClosed s a i) (a : α)  : Filter.HasBasis nhds a p a s a
application type mismatch
  Filter.HasBasis ?m.79915 a
argument
  a
has type
  α : Type u
but is expected to have type
  ?m.43 → Prop : Sort (max 1 ?u.40) ; identifiers [α, u, TopologicalSpace, α, ι, a, α, u_1, p, a, α, a, ι, a, s, a, α, a, ι, a, Set, α, h₁, a, α, Filter.HasBasis, nhds, a, p, a, s, a, h₂, a, α, i, ι, a, a_1, p, a, i, IsClosed, s, a, i, a, α, Filter.HasBasis, nhds, a, p, a, s, a] (during elaboration)

{α : Type u} [TopologicalSpace α] {ι : (a : α) → Sort u_1} {p : (a : α) → (a : ι a) → Prop} {s : (a : α) → (a : ι a) → Set α} (h₁ : ∀ (a : α) , Filter.HasBasis nhds a p a s a) (h₂ : ∀ (a : α) (i : ι a) (a_1 : p a i) , IsClosed s a i) (a : α)  : ∀ (i : ι a) (a_1 : p a i) , IsClosed s a i
application type mismatch
  Filter.HasBasis ?m.79915 a
argument
  a
has type
  α : Type u
but is expected to have type
  ?m.43 → Prop : Sort (max 1 ?u.40) ; identifiers [α, u, TopologicalSpace, α, ι, a, α, u_1, p, a, α, a, ι, a, s, a, α, a, ι, a, Set, α, h₁, a, α, Filter.HasBasis, nhds, a, p, a, s, a, h₂, a, α, i, ι, a, a_1, p, a, i, IsClosed, s, a, i, a, α, i, ι, a, a_1, p, a, i, IsClosed, s, a, i] (during elaboration)

{R : Type u_2} [CommSemiring R] (M : Submonoid R) (S : Type u_1) [CommSemiring S] [Algebra R S] [IsLocalization M S] {I : {p : Ideal S // Ideal.IsPrime p}} {I' : {p : Ideal S // Ideal.IsPrime p}}  : ∀ (h : I ≤ I') (x : R) (hx : x ∈ ↑ ↑ {toFun := ((fun (p : {p : Ideal S // Ideal.IsPrime p}) ↦ {val := ((Ideal.comap algebraMap R S ↑ p)) , property := ((Iff.mp IsLocalization.isPrime_iff_isPrime_disjoint M S ↑ p Subtype.property p))})) , invFun := ((fun (p : {p : Ideal R // (Ideal.IsPrime p) ∧ (Disjoint ↑ M ↑ p)}) ↦ {val := ((Ideal.map algebraMap R S ↑ p)) , property := ((IsLocalization.isPrime_of_isPrime_disjoint M S ↑ p And.left Subtype.property p And.right Subtype.property p))})) , left_inv := ((fun (J : {p : Ideal S // Ideal.IsPrime p}) ↦ Subtype.eq IsLocalization.map_comap M S ↑ J)) , right_inv := ((fun (I : {p : Ideal R // (Ideal.IsPrime p) ∧ (Disjoint ↑ M ↑ p)}) ↦ Subtype.eq IsLocalization.comap_map_of_isPrime_disjoint M S ↑ I And.left Subtype.property I And.right Subtype.property I))} I) , ↑ algebraMap R S x ∈ ↑ I'
type mismatch
  I'
has type
  { p // Ideal.IsPrime p } : Type u_1
but is expected to have type
  ?m.1423 M S h x hx : Type ?u.1108 ; identifiers [R, u_2, CommSemiring, R, M, Submonoid, R, S, u_1, CommSemiring, S, Algebra, R, S, IsLocalization, M, S, I, p, Ideal, S, Ideal.IsPrime, p, I', p, Ideal, S, Ideal.IsPrime, p, h, I, I', x, R, hx, x, toFun, p, p, Ideal, S, Ideal.IsPrime, p, val, Ideal.comap, algebraMap, R, S, p, property, Iff.mp, IsLocalization.isPrime_iff_isPrime_disjoint, M, S, p, Subtype.property, p, invFun, p, p, Ideal, R, Ideal.IsPrime, p, Disjoint, M, p, val, Ideal.map, algebraMap, R, S, p, property, IsLocalization.isPrime_of_isPrime_disjoint, M, S, p, And.left, Subtype.property, p, And.right, Subtype.property, p, left_inv, J, p, Ideal, S, Ideal.IsPrime, p, Subtype.eq, IsLocalization.map_comap, M, S, J, right_inv, I, p, Ideal, R, Ideal.IsPrime, p, Disjoint, M, p, Subtype.eq, IsLocalization.comap_map_of_isPrime_disjoint, M, S, I, And.left, Subtype.property, I, And.right, Subtype.property, I, I, algebraMap, R, S, x, I'] (during elaboration)

{α : Type u} {n : ℕ} {x : α} [LinearOrderedRing α] (hn : n ≠ 0) (h : Finset.sum Finset.range n fun (i : ℕ) ↦ x ^ i = 0) (h : ∀ (_ : x = - 1) , ¬ (Even n : Prop)) (hx : (x = - 1 : Prop) ∨ (x ≠ - 1 : Prop)) (hx_1 : x = - 1) (h_1 : hx = (Or.inl hx_1 =: (x = - 1 : Prop) ∨ (x ≠ - 1 : Prop)))  : Or.inl hx_1 = hx
<input>:1:248: expected term

{α : Type u} [LinearOrder α] (a : α) (b : α) (lt : a < b)  : (if (a ≤ b : Prop) then a else b = if (b ≤ a : Prop) then b else a) = (if (a ≤ b : Prop) then a else b = if (b ≤ a : Prop) then b else a)
application type mismatch
  if a ≤ b then a else b = if b ≤ a then b else a
argument
  b = if b ≤ a then b else a
has type
  Prop : Type
but is expected to have type
  α : Type u ; identifiers [α, u, LinearOrder, α, a, α, b, α, lt, a, b, a, b, a, b, b, a, b, a, a, b, a, b, b, a, b, a] (during elaboration)

 : (∀ {α : Type u_1} {β : Type u_2} [inst : Inf α] [inst_1 : Inf β] (self : InfHom α β) (a : α) (b : α) , InfHom.toFun self a ⊓ b = InfHom.toFun self a ⊓ InfHom.toFun self b)
application type mismatch
  InfHom.toFun self a ⊓ b
argument
  b
has type
  α : Type u_1
but is expected to have type
  β : Type u_2 ; identifiers [α, u_1, β, u_2, inst, Inf, α, inst_1, Inf, β, self, InfHom, α, β, a, α, b, α, InfHom.toFun, self, a, b, InfHom.toFun, self, a, InfHom.toFun, self, b] (during elaboration)

 : ∀ (α : Type u_1) (β : Type u_2) [inst : Inf α] [inst_1 : Inf β] (self : InfHom α β) (a : α) (b : α) , self . 1 a ⊓ b = self . 1 a ⊓ self . 1 b
invalid occurrence of `·` notation, it must be surrounded by parentheses (e.g. `(· + 1)`) ; identifiers [α, u_1, β, u_2, inst, Inf, α, inst_1, Inf, β, self, InfHom, α, β, a, α, b, α, self, a, b, self, a, self, b] (during elaboration)

{α : Type u} [LinearOrder α] (a : α) (b : α) (h : (a = b : Prop) ∨ (b < a : Prop)) (eq : a = b)  : (if (a ≤ b : Prop) then a else b = if (b ≤ a : Prop) then b else a) = (if (a ≤ b : Prop) then a else b = if (b ≤ a : Prop) then b else a)
application type mismatch
  if a ≤ b then a else b = if b ≤ a then b else a
argument
  b = if b ≤ a then b else a
has type
  Prop : Type
but is expected to have type
  α : Type u ; identifiers [α, u, LinearOrder, α, a, α, b, α, h, a, b, b, a, eq, a, b, a, b, a, b, b, a, b, a, a, b, a, b, b, a, b, a] (during elaboration)

{α : Type u_1} {r : (a : α) → (a : α) → Prop} [IsWellOrder α r] {c : Cardinal .{u_1}} (H : ∀ (S : Set α) (a : Set.Unbounded r S) , c ≤ Cardinal.mk ↑ S) (d : Cardinal .{u_1}) (a : d ∈ {c : Cardinal .{u_1} | ∃ (S : Set α) , (Set.Unbounded r S : Prop) ∧ (Cardinal.mk ↑ S = c : Prop)}) (S : Set α) (h : (Set.Unbounded r S : Prop) ∧ (Cardinal.mk ↑ S = d : Prop)) (h : Set.Unbounded r S) (right : Cardinal.mk ↑ S = d)  : c ≤ Cardinal.mk ↑ S
<input>:1:78: expected '//', '|' or '}'

{V : Type u_1} {P : Type u_2} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] [Fact (FiniteDimensional.finrank ℝ V = 2 : Prop)] [Module.Oriented ℝ V Fin 2] {p₁ : P} {p₂ : P} {p₃ : P} (h : EuclideanGeometry.oangle p₁ p₂ p₃ = ↑ Real.pi / 2)  : 1 = 1
application type mismatch
  Module.Oriented ℝ V Fin
argument
  Fin
has type
  ℕ → Type : Type 1
but is expected to have type
  Type ?u.490 : Type (?u.490 + 1) ; identifiers [V, u_1, P, u_2, NormedAddCommGroup, V, InnerProductSpace, V, MetricSpace, P, NormedAddTorsor, V, P, Fact, FiniteDimensional.finrank, V, Module.Oriented, V, Fin, p₁, P, p₂, P, p₃, P, h, EuclideanGeometry.oangle, p₁, p₂, p₃, Real.pi] (during elaboration)

{α : Type u} [LinearOrder α] (a : α) (b : α) (h : (a = b : Prop) ∨ (b < a : Prop)) (gt : b < a)  : (if (a ≤ b : Prop) then a else b = if (b ≤ a : Prop) then b else a) = (if (a ≤ b : Prop) then a else b = if (b ≤ a : Prop) then b else a)
application type mismatch
  if a ≤ b then a else b = if b ≤ a then b else a
argument
  b = if b ≤ a then b else a
has type
  Prop : Type
but is expected to have type
  α : Type u ; identifiers [α, u, LinearOrder, α, a, α, b, α, h, a, b, b, a, gt, b, a, a, b, a, b, b, a, b, a, a, b, a, b, b, a, b, a] (during elaboration)

 : (∀ {V : Type u_2} {W : Type u_3} {V₁ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W] [inst_2 : SeminormedAddCommGroup V₁] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W} (φ : NormedAddGroupHom V₁ V) (h : NormedAddGroupHom.comp f φ = NormedAddGroupHom.comp g φ) (C : ℝ) (hφ : ‖ φ ‖ ≤ C) , ‖ NormedAddGroupHom.Equalizer.lift φ h ‖ ≤ C)
<input>:1:326: expected term

 : ∀ {V : Type u_2} {W : Type u_3} {V₁ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W] [inst_2 : SeminormedAddCommGroup V₁] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W} (φ : NormedAddGroupHom V₁ V) (h : NormedAddGroupHom.comp f φ = NormedAddGroupHom.comp g φ) (C : ℝ) (hφ : ‖ φ ‖ ≤ C) , ‖ φ ‖ ≤ C
<input>:1:325: expected term

{V₁ : Type u_3} {V₂ : Type u_2} {V₃ : Type u_1} [SeminormedAddCommGroup V₁] [SeminormedAddCommGroup V₂] [SeminormedAddCommGroup V₃] (g : NormedAddGroupHom V₂ V₃) (f : NormedAddGroupHom V₁ V₂) (v : V₁)  : (‖ g ‖ * ‖ f ‖ * ‖ v ‖ = ‖ g ‖ * ‖ f ‖ * ‖ v ‖) = (‖ g ‖ * ‖ f ‖ * ‖ v ‖ = ‖ g ‖ * ‖ f ‖ * ‖ v ‖)
<input>:1:211: expected term

{V₁ : Type u_3} {V₂ : Type u_2} {V₃ : Type u_1} [SeminormedAddCommGroup V₁] [SeminormedAddCommGroup V₂] [SeminormedAddCommGroup V₃] (g : NormedAddGroupHom V₂ V₃) (f : NormedAddGroupHom V₁ V₂) (v : V₁)  : ‖ g ‖ * ‖ f ‖ * ‖ v ‖ = ‖ g ‖ * ‖ f ‖ * ‖ v ‖
<input>:1:210: expected term

{α : Type u} {n : ℕ} {x : α} [LinearOrderedRing α] (hn : n ≠ 0) (h : Finset.sum Finset.range n fun (i : ℕ) ↦ x ^ i = 0) (h : ∀ (_ : x = - 1) , ¬ (Even n : Prop)) (hx : (x = - 1 : Prop) ∨ (x ≠ - 1 : Prop)) (hx_1 : x = - 1) (h_1 : hx = (Or.inl hx_1 =: (x = - 1 : Prop) ∨ (x ≠ - 1 : Prop)))  : ¬ (Even n)
<input>:1:248: expected term

{α : Type u} {n : ℕ} {x : α} [LinearOrderedRing α] (hn : n ≠ 0) (h : Finset.sum Finset.range n fun (i : ℕ) ↦ x ^ i = 0) (h : ∀ (_ : x = - 1) , ¬ (Even n : Prop)) (hx : (x = - 1 : Prop) ∨ (x ≠ - 1 : Prop)) (hx_1 : x = - 1) (h_1 : hx = (Or.inl hx_1 =: (x = - 1 : Prop) ∨ (x ≠ - 1 : Prop)))  : ∀ (a : False) , 0 = 0
<input>:1:248: expected term

{α : Type u} {n : ℕ} {x : α} [LinearOrderedRing α] (hn : n ≠ 0) (h : Finset.sum Finset.range n fun (i : ℕ) ↦ x ^ i = 0) (h : ∀ (_ : x = - 1) , ¬ (Even n : Prop)) (hx : (x = - 1 : Prop) ∨ (x ≠ - 1 : Prop)) (hx_1 : x = - 1) (h_1 : hx = (Or.inl hx_1 =: (x = - 1 : Prop) ∨ (x ≠ - 1 : Prop)))  : ∀ (a : ¬ False) , 1 = 1
<input>:1:248: expected term

{α : Type u} {p : (a : α) → Prop} {f : Filter α} (H : ∀ {q : (a : α) → Prop} (a : ∀ᶠ (x : α) in f , q x) , ∃ (x : α) , (p x : Prop) ∧ (q x : Prop)) (hp : ∀ᶠ (x : α) in f , ¬ (fun (x : α) ↦ p x x : Prop))  : ∃ (x : α) , (p x) ∧ (¬ (fun (x : α) ↦ p x x : Prop))
function expected at
  p x
term has type
  Prop ; identifiers [α, u, p, a, α, f, Filter, α, H, q, a, α, a, x, α, f, q, x, x, α, p, x, q, x, hp, x, α, f, x, α, p, x, x, x, α, p, x, x, α, p, x, x] (during elaboration)

{α : Type u} {n : ℕ} {x : α} [LinearOrderedRing α] (hn : n ≠ 0) (h : Finset.sum Finset.range n fun (i : ℕ) ↦ x ^ i = 0) (h : ∀ (_ : x = - 1) , ¬ (Even n : Prop)) (hx : (x = - 1 : Prop) ∨ (x ≠ - 1 : Prop)) (hx_1 : x ≠ - 1) (h : hx = (Or.inr hx_1 =: (x = - 1 : Prop) ∨ (x ≠ - 1 : Prop)))  : Or.inr hx_1 = hx
<input>:1:246: expected term

{α : Type u} {n : ℕ} {x : α} [LinearOrderedRing α] (hn : n ≠ 0) (h : Finset.sum Finset.range n fun (i : ℕ) ↦ x ^ i = 0) (h : ∀ (_ : x = - 1) , ¬ (Even n : Prop)) (hx : (x = - 1 : Prop) ∨ (x ≠ - 1 : Prop))  : hx = hx
function expected at
  Finset.sum ?m.378 ?m.79528
term has type
  ?m.34 ; identifiers [α, u, n, x, α, LinearOrderedRing, α, hn, n, h, Finset.sum, Finset.range, n, i, x, i, h, x, Even, n, hx, x, x, hx, hx] (during elaboration)

{α : Type u_1} [LinearOrder α] [LocallyFiniteOrder α] (a : α) (b : α) (c : α) (h : c ≤ b) (h_1 : (le_total b c =: (b ≤ c : Prop) ∨ (c ≤ b : Prop)) = (Or.inr h =: (b ≤ c : Prop) ∨ (c ≤ b : Prop))) (x : α)  : ((((a ≤ x : Prop) ∧ (x < b : Prop) : Prop) ∧ (¬ ((c ≤ x : Prop) ∧ (x < b : Prop) : Prop) : Prop) : Prop) ↔ ((a ≤ x : Prop) ∧ (x < c : Prop) : Prop)) = ((((a ≤ x : Prop) ∧ (x < b : Prop) : Prop) ∧ (¬ ((c ≤ x : Prop) ∧ (x < b : Prop) : Prop) : Prop) : Prop) ↔ ((a ≤ x : Prop) ∧ (x < c : Prop) : Prop))
<input>:1:112: expected term

{m : ℕ} {n : ℕ} (hn : 0 < n) (h : n < m) (this : ∀ {n : ℕ} (a : 0 < n) , Nat.factorial n < Nat.factorial Nat.succ n)  : ∀ (hn : 0 < n) , Nat.factorial n < Nat.factorial Nat.succ n
application type mismatch
  Nat.factorial Nat.succ
argument
  Nat.succ
has type
  ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [m, n, hn, n, h, n, m, this, n, a, n, Nat.factorial, n, Nat.factorial, Nat.succ, n, hn, n, Nat.factorial, n, Nat.factorial, Nat.succ, n] (during elaboration)

{R : Type u_1} [inst : CommRing R] [IsDomain R] (K : Type u_2) [Field K] [inst_3 : Algebra R K] [IsFractionRing R K] (a : IsIntegralClosure R R K) (algebraMap_injective' : Function.Injective ↑ algebraMap R K) (cl : ∀ {x : K} , (IsIntegral R x : Prop) ↔ (∃ (y : R) , ↑ algebraMap R K y = x : Prop)) {x : K} (hx : IsIntegral R x)  : (IsIntegral R x) ↔ (∃ (y : R) , ↑ algebraMap R K y = x)
function expected at
  Function.Injective ?m.81526
term has type
  Prop ; identifiers [R, u_1, inst, CommRing, R, IsDomain, R, K, u_2, Field, K, inst_3, Algebra, R, K, IsFractionRing, R, K, a, IsIntegralClosure, R, R, K, algebraMap_injective', Function.Injective, algebraMap, R, K, cl, x, K, IsIntegral, R, x, y, R, algebraMap, R, K, y, x, x, K, hx, IsIntegral, R, x, IsIntegral, R, x, y, R, algebraMap, R, K, y, x] (during elaboration)

{m : ℕ} {n : ℕ} (hn : 0 < n) (h : n < m) (this : ∀ {n : ℕ} (a : 0 < n) , Nat.factorial n < Nat.factorial Nat.succ n) {k : ℕ} (hnk : Nat.le Nat.succ n k) (ih : ∀ (hn : 0 < n) , (Nat.factorial n < Nat.factorial k : Prop)) (hn : 0 < n)  : (Nat.factorial n < Nat.factorial k)
application type mismatch
  Nat.factorial Nat.succ
argument
  Nat.succ
has type
  ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [m, n, hn, n, h, n, m, this, n, a, n, Nat.factorial, n, Nat.factorial, Nat.succ, n, k, hnk, Nat.le, Nat.succ, n, k, ih, hn, n, Nat.factorial, n, Nat.factorial, k, hn, n, Nat.factorial, n, Nat.factorial, k] (during elaboration)

(A : Type u_1) [AddCommGroup A] (H : ∀ {n : ℤ} (_hn : n ≠ 0) , n • ⊤ = ⊤) {n : ℤ} (a : A) (hn : n ≠ 0)  : (n = 0) = (n = 0)
typeclass instance problem is stuck, it is often due to metavariables
  Top (?m.2940 A _hn) ; identifiers [A, u_1, AddCommGroup, A, H, n, _hn, n, n, n, a, A, hn, n, n, n] (during elaboration)

(A : Type u_1) [AddCommGroup A] (H : ∀ {n : ℤ} (_hn : n ≠ 0) , n • ⊤ = ⊤) {n : ℤ} (a : A) (hn : n ≠ 0)  : ∀ (h : n = 0) , 0 = 0
typeclass instance problem is stuck, it is often due to metavariables
  Top (?m.2990 A _hn) ; identifiers [A, u_1, AddCommGroup, A, H, n, _hn, n, n, n, a, A, hn, n, h, n] (during elaboration)

{C : Type u} [CategoryTheory.Groupoid C] (arrows : (c : C) → (d : C) → Set c ⟶ d) (inv : ∀ {c : C} {d : C} {p : c ⟶ d} (a : p ∈ arrows c d) , CategoryTheory.Groupoid.inv p ∈ arrows d c) (mul : ∀ {c : C} {d : C} {e : C} {p : c ⟶ d} (a : p ∈ arrows c d) {q : d ⟶ e} (a : q ∈ arrows d e) , CategoryTheory.CategoryStruct.comp p q ∈ arrows c e) (arrows_1 : (c : C) → (d : C) → Set c ⟶ d) (inv_1 : ∀ {c : C} {d : C} {p : c ⟶ d} (a : p ∈ arrows_1 c d) , CategoryTheory.Groupoid.inv p ∈ arrows_1 d c) (mul_1 : ∀ {c : C} {d : C} {e : C} {p : c ⟶ d} (a : p ∈ arrows_1 c d) {q : d ⟶ e} (a : q ∈ arrows_1 d e) , CategoryTheory.CategoryStruct.comp p q ∈ arrows_1 c e) (a : {arrows := ((arrows)) , inv := ((inv)) , mul := ((mul))} = {arrows := ((arrows_1)) , inv := ((inv_1)) , mul := ((mul_1))})  : ∀ (arrows_eq : arrows = arrows_1) , arrows = arrows_1
application type mismatch
  Set c
argument
  c
has type
  C : Type u
but is expected to have type
  Type ?u.52 : Type (?u.52 + 1) ; identifiers [C, u, CategoryTheory.Groupoid, C, arrows, c, C, d, C, Set, c, d, inv, c, C, d, C, p, c, d, a, p, arrows, c, d, CategoryTheory.Groupoid.inv, p, arrows, d, c, mul, c, C, d, C, e, C, p, c, d, a, p, arrows, c, d, q, d, e, a, q, arrows, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows, c, e, arrows_1, c, C, d, C, Set, c, d, inv_1, c, C, d, C, p, c, d, a, p, arrows_1, c, d, CategoryTheory.Groupoid.inv, p, arrows_1, d, c, mul_1, c, C, d, C, e, C, p, c, d, a, p, arrows_1, c, d, q, d, e, a, q, arrows_1, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows_1, c, e, a, arrows, arrows, inv, inv, mul, mul, arrows, arrows_1, inv, inv_1, mul, mul_1, arrows_eq, arrows, arrows_1, arrows, arrows_1] (during elaboration)

{α : Type u_1} [LinearOrder α] [LocallyFiniteOrder α] (a : α) (b : α) (c : α) (h : c ≤ b) (h_1 : (le_total b c =: (b ≤ c : Prop) ∨ (c ≤ b : Prop)) = (Or.inr h =: (b ≤ c : Prop) ∨ (c ≤ b : Prop))) (x : α)  : (((a ≤ x : Prop) ∧ ((x < b : Prop) ∧ (¬ ((c ≤ x : Prop) ∧ (x < b : Prop) : Prop) : Prop) : Prop) : Prop) ↔ ((a ≤ x : Prop) ∧ (x < c : Prop) : Prop)) = (((a ≤ x : Prop) ∧ ((x < b : Prop) ∧ (¬ ((c ≤ x : Prop) ∧ (x < b : Prop) : Prop) : Prop) : Prop) : Prop) ↔ ((a ≤ x : Prop) ∧ (x < c : Prop) : Prop))
<input>:1:112: expected term

(A : Type u_1) [AddCommGroup A] (H : ∀ {n : ℤ} (_hn : n ≠ 0) , n • ⊤ = ⊤) {n : ℤ} (a : A) (hn : n ≠ 0) (h : ¬ (n = 0 : Prop))  : (n = 0) = (n = 0)
typeclass instance problem is stuck, it is often due to metavariables
  Top (?m.2962 A _hn) ; identifiers [A, u_1, AddCommGroup, A, H, n, _hn, n, n, n, a, A, hn, n, h, n, n, n] (during elaboration)

(A : Type u_1) [AddCommGroup A] (H : ∀ {n : ℤ} (_hn : n ≠ 0) , n • ⊤ = ⊤) {n : ℤ} (a : A) (hn : n ≠ 0) (h : ¬ (n = 0 : Prop))  : (a ∈ n • ⊤) = (a ∈ n • ⊤)
typeclass instance problem is stuck, it is often due to metavariables
  Membership A (?m.8924 A H a hn h) ; identifiers [A, u_1, AddCommGroup, A, H, n, _hn, n, n, n, a, A, hn, n, h, n, a, n, a, n] (during elaboration)

{C : Type u} [CategoryTheory.Groupoid C] (arrows : (c : C) → (d : C) → Set c ⟶ d) (inv : ∀ {c : C} {d : C} {p : c ⟶ d} (a : p ∈ arrows c d) , CategoryTheory.Groupoid.inv p ∈ arrows d c) (mul : ∀ {c : C} {d : C} {e : C} {p : c ⟶ d} (a : p ∈ arrows c d) {q : d ⟶ e} (a : q ∈ arrows d e) , CategoryTheory.CategoryStruct.comp p q ∈ arrows c e) (arrows_1 : (c : C) → (d : C) → Set c ⟶ d) (inv_1 : ∀ {c : C} {d : C} {p : c ⟶ d} (a : p ∈ arrows_1 c d) , CategoryTheory.Groupoid.inv p ∈ arrows_1 d c) (mul_1 : ∀ {c : C} {d : C} {e : C} {p : c ⟶ d} (a : p ∈ arrows_1 c d) {q : d ⟶ e} (a : q ∈ arrows_1 d e) , CategoryTheory.CategoryStruct.comp p q ∈ arrows_1 c e) (a : arrows = arrows_1) (h : arrows_1 = arrows) (arrows_2 : (c : C) → (d : C) → Set c ⟶ d)  : arrows = arrows
application type mismatch
  Set c
argument
  c
has type
  C : Type u
but is expected to have type
  Type ?u.52 : Type (?u.52 + 1) ; identifiers [C, u, CategoryTheory.Groupoid, C, arrows, c, C, d, C, Set, c, d, inv, c, C, d, C, p, c, d, a, p, arrows, c, d, CategoryTheory.Groupoid.inv, p, arrows, d, c, mul, c, C, d, C, e, C, p, c, d, a, p, arrows, c, d, q, d, e, a, q, arrows, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows, c, e, arrows_1, c, C, d, C, Set, c, d, inv_1, c, C, d, C, p, c, d, a, p, arrows_1, c, d, CategoryTheory.Groupoid.inv, p, arrows_1, d, c, mul_1, c, C, d, C, e, C, p, c, d, a, p, arrows_1, c, d, q, d, e, a, q, arrows_1, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows_1, c, e, a, arrows, arrows_1, h, arrows_1, arrows, arrows_2, c, C, d, C, Set, c, d, arrows, arrows] (during elaboration)

{α : Type u_1} [LinearOrder α] [LocallyFiniteOrder α] (a : α) (b : α) (c : α) (h : c ≤ b) (h_1 : (le_total b c =: (b ≤ c : Prop) ∨ (c ≤ b : Prop)) = (Or.inr h =: (b ≤ c : Prop) ∨ (c ≤ b : Prop))) (x : α)  : (((a ≤ x : Prop) ∧ ((x < b : Prop) ∧ (∀ (a : x < b) , ¬ (c ≤ x : Prop) : Prop) : Prop) : Prop) ↔ ((a ≤ x : Prop) ∧ (x < c : Prop) : Prop)) = (((a ≤ x : Prop) ∧ ((x < b : Prop) ∧ (∀ (a : x < b) , ¬ (c ≤ x : Prop) : Prop) : Prop) : Prop) ↔ ((a ≤ x : Prop) ∧ (x < c : Prop) : Prop))
<input>:1:112: expected term

{α : Type u_1} [LinearOrder α] [LocallyFiniteOrder α] (a : α) (b : α) (c : α) (h : c ≤ b) (h_1 : (le_total b c =: (b ≤ c : Prop) ∨ (c ≤ b : Prop)) = (Or.inr h =: (b ≤ c : Prop) ∨ (c ≤ b : Prop))) (x : α) (hx : x < c)  : ∀ (x_1 : x < b) , x < c
<input>:1:112: expected term

{C : Type u} [CategoryTheory.Groupoid C] (arrows : (c : C) → (d : C) → Set c ⟶ d) (inv : ∀ {c : C} {d : C} {p : c ⟶ d} (a : p ∈ arrows c d) , CategoryTheory.Groupoid.inv p ∈ arrows d c) (mul : ∀ {c : C} {d : C} {e : C} {p : c ⟶ d} (a : p ∈ arrows c d) {q : d ⟶ e} (a : q ∈ arrows d e) , CategoryTheory.CategoryStruct.comp p q ∈ arrows c e) (arrows_1 : (c : C) → (d : C) → Set c ⟶ d) (inv_1 : ∀ {c : C} {d : C} {p : c ⟶ d} (a : p ∈ arrows_1 c d) , CategoryTheory.Groupoid.inv p ∈ arrows_1 d c) (mul_1 : ∀ {c : C} {d : C} {e : C} {p : c ⟶ d} (a : p ∈ arrows_1 c d) {q : d ⟶ e} (a : q ∈ arrows_1 d e) , CategoryTheory.CategoryStruct.comp p q ∈ arrows_1 c e) (a : arrows = arrows_1) (h : arrows_1 = arrows) (inv_2 : ∀ {c : C} {d : C} {p : c ⟶ d} (a : p ∈ arrows c d) , CategoryTheory.Groupoid.inv p ∈ arrows d c) (mul_2 : ∀ {c : C} {d : C} {e : C} {p : c ⟶ d} (a : p ∈ arrows c d) {q : d ⟶ e} (a : q ∈ arrows d e) , CategoryTheory.CategoryStruct.comp p q ∈ arrows c e) (a : arrows = arrows) (h : HEq a (Eq.refl arrows =: arrows = arrows))  : {arrows := ((arrows)) , inv := ((inv)) , mul := ((mul))} = {arrows := ((arrows)) , inv := ((inv)) , mul := ((mul))}
<input>:1:1015: expected term

{C : Type u} [CategoryTheory.Groupoid C] (arrows : (c : C) → (d : C) → Set c ⟶ d) (inv : ∀ {c : C} {d : C} {p : c ⟶ d} (a : p ∈ arrows c d) , CategoryTheory.Groupoid.inv p ∈ arrows d c) (mul : ∀ {c : C} {d : C} {e : C} {p : c ⟶ d} (a : p ∈ arrows c d) {q : d ⟶ e} (a : q ∈ arrows d e) , CategoryTheory.CategoryStruct.comp p q ∈ arrows c e) (arrows_1 : (c : C) → (d : C) → Set c ⟶ d) (inv_1 : ∀ {c : C} {d : C} {p : c ⟶ d} (a : p ∈ arrows_1 c d) , CategoryTheory.Groupoid.inv p ∈ arrows_1 d c) (mul_1 : ∀ {c : C} {d : C} {e : C} {p : c ⟶ d} (a : p ∈ arrows_1 c d) {q : d ⟶ e} (a : q ∈ arrows_1 d e) , CategoryTheory.CategoryStruct.comp p q ∈ arrows_1 c e) (a : arrows = arrows_1) (h : arrows_1 = arrows)  : arrows = arrows_1
application type mismatch
  Set c
argument
  c
has type
  C : Type u
but is expected to have type
  Type ?u.52 : Type (?u.52 + 1) ; identifiers [C, u, CategoryTheory.Groupoid, C, arrows, c, C, d, C, Set, c, d, inv, c, C, d, C, p, c, d, a, p, arrows, c, d, CategoryTheory.Groupoid.inv, p, arrows, d, c, mul, c, C, d, C, e, C, p, c, d, a, p, arrows, c, d, q, d, e, a, q, arrows, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows, c, e, arrows_1, c, C, d, C, Set, c, d, inv_1, c, C, d, C, p, c, d, a, p, arrows_1, c, d, CategoryTheory.Groupoid.inv, p, arrows_1, d, c, mul_1, c, C, d, C, e, C, p, c, d, a, p, arrows_1, c, d, q, d, e, a, q, arrows_1, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows_1, c, e, a, arrows, arrows_1, h, arrows_1, arrows, arrows, arrows_1] (during elaboration)

{C : Type u} [CategoryTheory.Groupoid C] (arrows : (c : C) → (d : C) → Set c ⟶ d) (inv : ∀ {c : C} {d : C} {p : c ⟶ d} (a : p ∈ arrows c d) , CategoryTheory.Groupoid.inv p ∈ arrows d c) (mul : ∀ {c : C} {d : C} {e : C} {p : c ⟶ d} (a : p ∈ arrows c d) {q : d ⟶ e} (a : q ∈ arrows d e) , CategoryTheory.CategoryStruct.comp p q ∈ arrows c e) (arrows_1 : (c : C) → (d : C) → Set c ⟶ d) (inv_1 : ∀ {c : C} {d : C} {p : c ⟶ d} (a : p ∈ arrows_1 c d) , CategoryTheory.Groupoid.inv p ∈ arrows_1 d c) (mul_1 : ∀ {c : C} {d : C} {e : C} {p : c ⟶ d} (a : p ∈ arrows_1 c d) {q : d ⟶ e} (a : q ∈ arrows_1 d e) , CategoryTheory.CategoryStruct.comp p q ∈ arrows_1 c e) (a : arrows = arrows_1)  : arrows_1 = arrows_1
application type mismatch
  Set c
argument
  c
has type
  C : Type u
but is expected to have type
  Type ?u.52 : Type (?u.52 + 1) ; identifiers [C, u, CategoryTheory.Groupoid, C, arrows, c, C, d, C, Set, c, d, inv, c, C, d, C, p, c, d, a, p, arrows, c, d, CategoryTheory.Groupoid.inv, p, arrows, d, c, mul, c, C, d, C, e, C, p, c, d, a, p, arrows, c, d, q, d, e, a, q, arrows, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows, c, e, arrows_1, c, C, d, C, Set, c, d, inv_1, c, C, d, C, p, c, d, a, p, arrows_1, c, d, CategoryTheory.Groupoid.inv, p, arrows_1, d, c, mul_1, c, C, d, C, e, C, p, c, d, a, p, arrows_1, c, d, q, d, e, a, q, arrows_1, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows_1, c, e, a, arrows, arrows_1, arrows_1, arrows_1] (during elaboration)

{α : Type u_1} (S : Set Set α) (x : α)  : (¬ (∃ (x_1 : Set α) , (x_1 ∈ S : Prop) ∧ (x ∈ x_1 : Prop) : Prop)) = (∀ (x_1 : Set α) , ¬ ((x_1 ∈ S : Prop) ∧ (x ∈ x_1 : Prop) : Prop))
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.7 → Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Type ?u.6 : Type (?u.6 + 1) ; identifiers [α, u_1, S, Set, Set, α, x, α, x_1, Set, α, x_1, S, x, x_1, x_1, Set, α, x_1, S, x, x_1] (during elaboration)

{α : Type u_1} (S : Set Set α) (x : α)  : ∀ (x_1 : Set α) , (¬ ((x_1 ∈ S : Prop) ∧ (x ∈ x_1 : Prop) : Prop)) = (∀ (a : x_1 ∈ S) , ¬ (x ∈ x_1 : Prop))
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.7 → Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Type ?u.6 : Type (?u.6 + 1) ; identifiers [α, u_1, S, Set, Set, α, x, α, x_1, Set, α, x_1, S, x, x_1, a, x_1, S, x, x_1] (during elaboration)

{α : Type u} {β : Type v} [PseudoEMetricSpace α] {s : Set α} [PseudoEMetricSpace β] {f : (a : α) → β} {t : Set β} {a : α} {b : β} (ε : ENNReal) (x : 0 < ε) (δ : ENNReal) (x : 0 < δ) (x : α)  : (∀ (a : (edist x a < δ : Prop) ∧ (x ∈ s : Prop)) , (edist f x b < ε : Prop) ∧ (f x ∈ t : Prop)) = (∀ (a : edist x a < δ) (a : x ∈ s) , (edist f x b < ε : Prop) ∧ (f x ∈ t : Prop))
application type mismatch
  edist f x
argument
  x
has type
  α : Type u
but is expected to have type
  α → β : Type (max u v) ; identifiers [α, u, β, v, PseudoEMetricSpace, α, s, Set, α, PseudoEMetricSpace, β, f, a, α, β, t, Set, β, a, α, b, β, ε, ENNReal, x, ε, δ, ENNReal, x, δ, x, α, a, edist, x, a, δ, x, s, edist, f, x, b, ε, f, x, t, a, edist, x, a, δ, a, x, s, edist, f, x, b, ε, f, x, t] (during elaboration)

{α : Type u_1} (S : Set Set α) (x : α) (i : Set α)  : (i ∈ S) = (i ∈ S)
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.7 → Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Type ?u.6 : Type (?u.6 + 1) ; identifiers [α, u_1, S, Set, Set, α, x, α, i, Set, α, i, S, i, S] (during elaboration)

{α : Type ua} [UniformSpace α] {x : α} {s : Set α}  : ({p : α × α | ∀ (a : Prod.fst p = x) , Prod.snd p ∈ s} ∈ uniformity α) ↔ ({p : α × α | ∀ (a : Prod.fst p = x) , Prod.snd p ∈ s} ∈ uniformity α)
unknown universe level 'ua' ; identifiers [α, ua, UniformSpace, α, x, α, s, Set, α, p, α, α, a, Prod.fst, p, x, Prod.snd, p, s, uniformity, α, p, α, α, a, Prod.fst, p, x, Prod.snd, p, s, uniformity, α] (during elaboration)

(A : Type u_1) [AddCommGroup A] (H : ∀ {n : ℤ} (_hn : n ≠ 0) , n • ⊤ = ⊤) {n : ℤ} (a : A) (hn : n ≠ 0)  : (a ∈ n • ⊤) = (a ∈ n • ⊤)
typeclass instance problem is stuck, it is often due to metavariables
  Membership A (?m.8892 A H a hn) ; identifiers [A, u_1, AddCommGroup, A, H, n, _hn, n, n, n, a, A, hn, n, a, n, a, n] (during elaboration)

{α : Type u} {β : Type v} [PseudoEMetricSpace α] {s : Set α} [PseudoEMetricSpace β] {f : (a : α) → β} {t : Set β} {a : α} {b : β} (ε : ENNReal) (x : 0 < ε) (δ : ENNReal) (x : 0 < δ) (x : α) em : (a : Prop) → Decidable (a : Prop) := Classical.propDecidable (a_1 : ∀ (a : edist x a < δ) (a : x ∈ s) , (edist f x b < ε : Prop) ∧ (f x ∈ t : Prop)) (h : ∀ (a : x ∈ s) , (edist f x b < ε : Prop) ∧ (f x ∈ t : Prop)) (a_2 : x ∈ s) (a : edist x a < δ) (h : (edist f x b < ε : Prop) ∧ (f x ∈ t : Prop))  : ∀ (left : edist f x b < ε) (right : f x ∈ t) , (f x ∈ t) ∧ (edist f x b < ε)
<input>:1:193: expected end of input

{B : Type u₁} [CategoryTheory.Bicategory B] {C : Type u₂} [CategoryTheory.Bicategory C] {F : CategoryTheory.OplaxFunctor B C} {G : CategoryTheory.OplaxFunctor B C} {α : F ⟶ G} {β : F ⟶ G} {m : α ⟶ β} {n : α ⟶ β} (w : ∀ (b : B) , m . app b = n . app b)  : ∀ (x : B) , m . app x = n . app x
function expected at
  m
term has type
  α ⟶ β ; identifiers [B, u₁, CategoryTheory.Bicategory, B, C, u₂, CategoryTheory.Bicategory, C, F, CategoryTheory.OplaxFunctor, B, C, G, CategoryTheory.OplaxFunctor, B, C, α, F, G, β, F, G, m, α, β, n, α, β, w, b, B, m, app, b, n, app, b, x, B, m, app, x, n, app, x] (during elaboration)

{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {B : Mon_ C} {M : Bimod A B} {N : Bimod A B} (hom : Bimod.X M ⟶ Bimod.X N) (left_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (hom_1 : Bimod.X M ⟶ Bimod.X N) (left_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom_1 CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (a : Bimod.Hom.mk hom = Bimod.Hom.mk hom_1)  : ∀ (hom_eq : hom = hom_1) , hom = hom_1
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82510 ?m.162353
term has type
  ?m.1854 ⟶ ?m.1856 ; identifiers [C, u₁, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, B, Mon_, C, M, Bimod, A, B, N, Bimod, A, B, hom, Bimod.X, M, Bimod.X, N, left_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, hom_1, Bimod.X, M, Bimod.X, N, left_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom_1, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, a, Bimod.Hom.mk, hom, Bimod.Hom.mk, hom_1, hom_eq, hom, hom_1, hom, hom_1] (during elaboration)

{M : Type u_1} [AddMonoid M] [Preorder M] [CovariantClass M M fun (x : M) (x_1 : M) ↦ x + x_1 fun (x : M) (x_1 : M) ↦ x ≤ x_1] {x : M} (hx : x ≤ 0) (x_1 : ℕ) (x_2 : ℕ) (f : Nat.below x_2) (k : ℕ) (x_3 : Nat.below Nat.succ k)  : (k + 1 • x ≤ 0) = (k + 1 • x ≤ 0)
function expected at
  x_1
term has type
  M ; identifiers [M, u_1, AddMonoid, M, Preorder, M, CovariantClass, M, M, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, x, M, hx, x, x_1, x_2, f, Nat.below, x_2, k, x_3, Nat.below, Nat.succ, k, k, x, k, x] (during elaboration)

{α : Type u} {β : Type v} [PseudoEMetricSpace α] {s : Set α} [PseudoEMetricSpace β] {f : (a : α) → β} {t : Set β} {a : α} {b : β} (ε : ENNReal) (x : 0 < ε) (δ : ENNReal) (x : 0 < δ) (x : α) em : (a : Prop) → Decidable (a : Prop) := Classical.propDecidable (a_1 : ∀ (a_1 : x ∈ s) (a : edist x a < δ) , (f x ∈ t : Prop) ∧ (edist f x b < ε : Prop)) (h : ∀ (a : edist x a < δ) , (f x ∈ t : Prop) ∧ (edist f x b < ε : Prop)) (a_2 : edist x a < δ) (a_3 : x ∈ s) (h : (f x ∈ t : Prop) ∧ (edist f x b < ε : Prop))  : ∀ (left : f x ∈ t) (right : edist f x b < ε) , (edist f x b < ε) ∧ (f x ∈ t)
<input>:1:193: expected end of input

{c : (a : Type u_1) → Type u_1} {hom : ⦃ α : Type u_1 ⦄ → ⦃ β : Type u_1 ⦄ → (x : c α) → (x : c β) → Type u_1} [CategoryTheory.BundledHom hom] {d : (a : Type u_1) → Type u_1} {hom_d : ⦃ α : Type u_1 ⦄ → ⦃ β : Type u_1 ⦄ → (x : d α) → (x : d β) → Type u_1} [CategoryTheory.BundledHom hom_d] (obj : ⦃ α : Type u_1 ⦄ → (a : c α) → d α) (map : {X : CategoryTheory.Bundled c} → {Y : CategoryTheory.Bundled c} → (a : X ⟶ Y) → CategoryTheory.Bundled.map obj X ⟶ CategoryTheory.Bundled.map obj Y) (h_map : ∀ {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} (f : X ⟶ Y) , ↑ map f = ↑ f) {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} {f : X ⟶ Y}  : ↑ map f = ↑ f
type mismatch
  f
has type
  X ⟶ Y : Type u_1
but is expected to have type
  ?m.159011 obj map h_map : Sort ?u.158706 ; identifiers [c, a, u_1, u_1, hom, α, u_1, β, u_1, x, c, α, x, c, β, u_1, CategoryTheory.BundledHom, hom, d, a, u_1, u_1, hom_d, α, u_1, β, u_1, x, d, α, x, d, β, u_1, CategoryTheory.BundledHom, hom_d, obj, α, u_1, a, c, α, d, α, map, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, a, X, Y, CategoryTheory.Bundled.map, obj, X, CategoryTheory.Bundled.map, obj, Y, h_map, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, f, X, Y, map, f, f, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, f, X, Y, map, f, f] (during elaboration)

{c : (a : Type u_1) → Type u_1} {hom : ⦃ α : Type u_1 ⦄ → ⦃ β : Type u_1 ⦄ → (x : c α) → (x : c β) → Type u_1} [CategoryTheory.BundledHom hom] {d : (a : Type u_1) → Type u_1} {hom_d : ⦃ α : Type u_1 ⦄ → ⦃ β : Type u_1 ⦄ → (x : d α) → (x : d β) → Type u_1} [CategoryTheory.BundledHom hom_d] (obj : ⦃ α : Type u_1 ⦄ → (a : c α) → d α) (map : {X : CategoryTheory.Bundled c} → {Y : CategoryTheory.Bundled c} → (a : X ⟶ Y) → CategoryTheory.Bundled.map obj X ⟶ CategoryTheory.Bundled.map obj Y) (h_map : ∀ {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} (f : X ⟶ Y) , ↑ map f = ↑ f) {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} {f : X ⟶ Y}  : (↑ fun {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} ↦ map f = ↑ f) = (↑ fun {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} ↦ map f = ↑ f)
type mismatch
  f
has type
  X ⟶ Y : Type u_1
but is expected to have type
  ?m.158984 obj map f : Sort ?u.158565 ; identifiers [c, a, u_1, u_1, hom, α, u_1, β, u_1, x, c, α, x, c, β, u_1, CategoryTheory.BundledHom, hom, d, a, u_1, u_1, hom_d, α, u_1, β, u_1, x, d, α, x, d, β, u_1, CategoryTheory.BundledHom, hom_d, obj, α, u_1, a, c, α, d, α, map, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, a, X, Y, CategoryTheory.Bundled.map, obj, X, CategoryTheory.Bundled.map, obj, Y, h_map, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, f, X, Y, map, f, f, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, f, X, Y, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, map, f, f, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, map, f, f] (during elaboration)

{α : Type u_1} [DecidableEq Option α] (s : Finset Option α) (a : Option α) (a : α)  : (a ∈ none) = (none = some a)
application type mismatch
  DecidableEq Option
argument
  Option
has type
  Type ?u.7 → Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Sort ?u.6 : Type ?u.6 ; identifiers [α, u_1, DecidableEq, Option, α, s, Finset, Option, α, a, Option, α, a, α, a, none, none, some, a] (during elaboration)

 : (∀ {α : Type u_1} [inst : Union α] {a : Part α} {b : Part α} (hab : Part.Dom a ∪ b) , Part.Dom a)
application type mismatch
  a.Dom ∪ b
argument
  b
has type
  Part α : Type u_1
but is expected to have type
  Prop : Type ; identifiers [α, u_1, inst, Union, α, a, Part, α, b, Part, α, hab, Part.Dom, a, b, Part.Dom, a] (during elaboration)

 : ∀ {α : Type u_1} [inst : Union α] {a : Part α} {b : Part α} (hab : Part.Dom a ∪ b) , Part.Dom fun (x : α) (x_1 : α) ↦ x ∪ x_1 <$> a
application type mismatch
  a.Dom ∪ b
argument
  b
has type
  Part α : Type u_1
but is expected to have type
  Prop : Type ; identifiers [α, u_1, inst, Union, α, a, Part, α, b, Part, α, hab, Part.Dom, a, b, Part.Dom, x, α, x_1, α, x, x_1, a] (during elaboration)

{c : (a : Type u_1) → Type u_1} {hom : ⦃ α : Type u_1 ⦄ → ⦃ β : Type u_1 ⦄ → (x : c α) → (x : c β) → Type u_1} [CategoryTheory.BundledHom hom] {d : (a : Type u_1) → Type u_1} {hom_d : ⦃ α : Type u_1 ⦄ → ⦃ β : Type u_1 ⦄ → (x : d α) → (x : d β) → Type u_1} [CategoryTheory.BundledHom hom_d] (obj : ⦃ α : Type u_1 ⦄ → (a : c α) → d α) (map : {X : CategoryTheory.Bundled c} → {Y : CategoryTheory.Bundled c} → (a : X ⟶ Y) → CategoryTheory.Bundled.map obj X ⟶ CategoryTheory.Bundled.map obj Y) (h_map : ∀ {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} (f : X ⟶ Y) , ↑ map f = ↑ f) {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} {f : X ⟶ Y}  : ↑ f = ↑ f
type mismatch
  f
has type
  X ⟶ Y : Type u_1
but is expected to have type
  ?m.158999 obj map h_map : Sort ?u.158706 ; identifiers [c, a, u_1, u_1, hom, α, u_1, β, u_1, x, c, α, x, c, β, u_1, CategoryTheory.BundledHom, hom, d, a, u_1, u_1, hom_d, α, u_1, β, u_1, x, d, α, x, d, β, u_1, CategoryTheory.BundledHom, hom_d, obj, α, u_1, a, c, α, d, α, map, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, a, X, Y, CategoryTheory.Bundled.map, obj, X, CategoryTheory.Bundled.map, obj, Y, h_map, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, f, X, Y, map, f, f, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, f, X, Y, f, f] (during elaboration)

 : (∀ {C : Type u₁} [inst : CategoryTheory.Category C] {T₁ : CategoryTheory.Monad C} {T₂ : CategoryTheory.Monad C} (self : CategoryTheory.MonadHom T₁ T₂) (X : C) , CategoryTheory.CategoryStruct.comp CategoryTheory.NatTrans.app CategoryTheory.Monad.μ T₁ X CategoryTheory.NatTrans.app CategoryTheory.MonadHom.toNatTrans self X = CategoryTheory.CategoryStruct.comp CategoryTheory.CategoryStruct.comp CategoryTheory.Functor.toPrefunctor CategoryTheory.Monad.toFunctor T₁ . map CategoryTheory.NatTrans.app CategoryTheory.MonadHom.toNatTrans self X CategoryTheory.NatTrans.app CategoryTheory.MonadHom.toNatTrans self CategoryTheory.Functor.toPrefunctor CategoryTheory.Monad.toFunctor T₂ . obj X CategoryTheory.NatTrans.app CategoryTheory.Monad.μ T₂ X)
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82129 ?m.162635
term has type
  ?m.443 ⟶ ?m.445 ; identifiers [C, u₁, inst, CategoryTheory.Category, C, T₁, CategoryTheory.Monad, C, T₂, CategoryTheory.Monad, C, self, CategoryTheory.MonadHom, T₁, T₂, X, C, CategoryTheory.CategoryStruct.comp, CategoryTheory.NatTrans.app, CategoryTheory.Monad.μ, T₁, X, CategoryTheory.NatTrans.app, CategoryTheory.MonadHom.toNatTrans, self, X, CategoryTheory.CategoryStruct.comp, CategoryTheory.CategoryStruct.comp, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Monad.toFunctor, T₁, map, CategoryTheory.NatTrans.app, CategoryTheory.MonadHom.toNatTrans, self, X, CategoryTheory.NatTrans.app, CategoryTheory.MonadHom.toNatTrans, self, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Monad.toFunctor, T₂, obj, X, CategoryTheory.NatTrans.app, CategoryTheory.Monad.μ, T₂, X] (during elaboration)

 : ∀ (C : Type u₁) [inst : CategoryTheory.Category C] (T₁ : CategoryTheory.Monad C) (T₂ : CategoryTheory.Monad C) (self : CategoryTheory.MonadHom T₁ T₂) (X : C) , CategoryTheory.CategoryStruct.comp CategoryTheory.NatTrans.app CategoryTheory.Monad.μ T₁ X CategoryTheory.NatTrans.app self . 1 X = CategoryTheory.CategoryStruct.comp CategoryTheory.CategoryStruct.comp CategoryTheory.Functor.toPrefunctor CategoryTheory.Monad.toFunctor T₁ . map CategoryTheory.NatTrans.app self . 1 X CategoryTheory.NatTrans.app self . 1 CategoryTheory.Functor.toPrefunctor CategoryTheory.Monad.toFunctor T₂ . obj X CategoryTheory.NatTrans.app CategoryTheory.Monad.μ T₂ X
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82123 ?m.162629
term has type
  ?m.437 ⟶ ?m.439 ; identifiers [C, u₁, inst, CategoryTheory.Category, C, T₁, CategoryTheory.Monad, C, T₂, CategoryTheory.Monad, C, self, CategoryTheory.MonadHom, T₁, T₂, X, C, CategoryTheory.CategoryStruct.comp, CategoryTheory.NatTrans.app, CategoryTheory.Monad.μ, T₁, X, CategoryTheory.NatTrans.app, self, X, CategoryTheory.CategoryStruct.comp, CategoryTheory.CategoryStruct.comp, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Monad.toFunctor, T₁, map, CategoryTheory.NatTrans.app, self, X, CategoryTheory.NatTrans.app, self, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Monad.toFunctor, T₂, obj, X, CategoryTheory.NatTrans.app, CategoryTheory.Monad.μ, T₂, X] (during elaboration)

{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {B : Mon_ C} {M : Bimod A B} {N : Bimod A B} (hom : Bimod.X M ⟶ Bimod.X N) (left_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (hom_1 : Bimod.X M ⟶ Bimod.X N) (left_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom_1 CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (a : hom = hom_1) (h : hom_1 = hom) (hom_2 : Bimod.X M ⟶ Bimod.X N)  : hom = hom
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82510 ?m.162353
term has type
  ?m.1854 ⟶ ?m.1856 ; identifiers [C, u₁, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, B, Mon_, C, M, Bimod, A, B, N, Bimod, A, B, hom, Bimod.X, M, Bimod.X, N, left_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, hom_1, Bimod.X, M, Bimod.X, N, left_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom_1, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, a, hom, hom_1, h, hom_1, hom, hom_2, Bimod.X, M, Bimod.X, N, hom, hom] (during elaboration)

{α : Type u} [TopologicalSpace α] (x : α) (C : Set α)  : (ClusterPt x Filter.principal C ∩ {x} ᶜ) ↔ (ClusterPt x Filter.principal C ∩ {x} ᶜ)
application type mismatch
  ClusterPt x Filter.principal
argument
  Filter.principal
has type
  Set ?m.23 → Filter ?m.23 : Type ?u.22
but is expected to have type
  Filter α : Type u ; identifiers [α, u, TopologicalSpace, α, x, α, C, Set, α, ClusterPt, x, Filter.principal, C, x, x, ClusterPt, x, Filter.principal, C, x, x] (during elaboration)

{c₁ : Nat.Partrec.Code} {c₂ : Nat.Partrec.Code} {n₁ : ℕ} {n₂ : ℕ} (h : Nat.Partrec.Code.curry c₁ n₁ = Nat.Partrec.Code.curry c₂ n₂)  : ∀ (a_eq : c₁ = c₂) (a_eq : Nat.Partrec.Code.pair Nat.Partrec.Code.const n₁ Nat.Partrec.Code.id = Nat.Partrec.Code.pair Nat.Partrec.Code.const n₂ Nat.Partrec.Code.id) , c₁ = c₂
application type mismatch
  Nat.Partrec.Code.pair Nat.Partrec.Code.const
argument
  Nat.Partrec.Code.const
has type
  ℕ → Nat.Partrec.Code : Type
but is expected to have type
  Nat.Partrec.Code : Type ; identifiers [c₁, Nat.Partrec.Code, c₂, Nat.Partrec.Code, n₁, n₂, h, Nat.Partrec.Code.curry, c₁, n₁, Nat.Partrec.Code.curry, c₂, n₂, a_eq, c₁, c₂, a_eq, Nat.Partrec.Code.pair, Nat.Partrec.Code.const, n₁, Nat.Partrec.Code.id, Nat.Partrec.Code.pair, Nat.Partrec.Code.const, n₂, Nat.Partrec.Code.id, c₁, c₂] (during elaboration)

{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {B : Mon_ C} {M : Bimod A B} {N : Bimod A B} (hom : Bimod.X M ⟶ Bimod.X N) (left_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (hom_1 : Bimod.X M ⟶ Bimod.X N) (left_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom_1 CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (a : hom = hom_1) (h : hom_1 = hom)  : hom = hom_1
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82510 ?m.162353
term has type
  ?m.1854 ⟶ ?m.1856 ; identifiers [C, u₁, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, B, Mon_, C, M, Bimod, A, B, N, Bimod, A, B, hom, Bimod.X, M, Bimod.X, N, left_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, hom_1, Bimod.X, M, Bimod.X, N, left_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom_1, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, a, hom, hom_1, h, hom_1, hom, hom, hom_1] (during elaboration)

{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {B : Mon_ C} {M : Bimod A B} {N : Bimod A B} (hom : Bimod.X M ⟶ Bimod.X N) (left_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (hom_1 : Bimod.X M ⟶ Bimod.X N) (left_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom_1 CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (a : hom = hom_1)  : hom_1 = hom_1
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82510 ?m.162353
term has type
  ?m.1854 ⟶ ?m.1856 ; identifiers [C, u₁, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, B, Mon_, C, M, Bimod, A, B, N, Bimod, A, B, hom, Bimod.X, M, Bimod.X, N, left_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, hom_1, Bimod.X, M, Bimod.X, N, left_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom_1, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, a, hom, hom_1, hom_1, hom_1] (during elaboration)

{α : Type u_1} [DecidableEq Option α] (s : Finset Option α) (a : Option α) (x : α) (a : α)  : (a ∈ some x) = (some x = some a)
application type mismatch
  DecidableEq Option
argument
  Option
has type
  Type ?u.7 → Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Sort ?u.6 : Type ?u.6 ; identifiers [α, u_1, DecidableEq, Option, α, s, Finset, Option, α, a, Option, α, x, α, a, α, a, some, x, some, x, some, a] (during elaboration)

{α : Type u_1} [DecidableEq Option α] (s : Finset Option α) (a : Option α) (x : α)  : (∀ (a : α) (a_1 : x = a) , some a ∈ s) = (some x ∈ s)
application type mismatch
  DecidableEq Option
argument
  Option
has type
  Type ?u.7 → Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Sort ?u.6 : Type ?u.6 ; identifiers [α, u_1, DecidableEq, Option, α, s, Finset, Option, α, a, Option, α, x, α, a, α, a_1, x, a, some, a, s, some, x, s] (during elaboration)

(f : StieltjesFunction) {a : ℝ} {b : ℝ} (hab : a < b) (A : Disjoint Set.Ioo a b {b})  : - 1 = - 1
application type mismatch
  Disjoint Set.Ioo a
argument
  a
has type
  ℝ : Type
but is expected to have type
  ?m.26 → ?m.26 → Set ?m.26 : Type ?u.25 ; identifiers [f, StieltjesFunction, a, b, hab, a, b, A, Disjoint, Set.Ioo, a, b, b, b] (during elaboration)

{𝕜 : Type u_2} {E : Type u_1} [OrderedSemiring 𝕜] [AddCommGroup E] [Module 𝕜 E] {s : Set E} (hc : ∀ (t : Set E) (a : t ⊆ s) , s ∩ ↑ convexHull 𝕜 t ⊆ t) (t : Set {x : E // x ∈ s}) (x : {x : E // x ∈ s}) (h : ↑ x ∈ ↑ convexHull 𝕜 Subtype.val '' t)  : (x ∈ t) = (x ∈ t)
type mismatch
  x
has type
  { x // x ∈ s } : Type u_1
but is expected to have type
  ?m.1011 hc t x : Type ?u.912 ; identifiers [𝕜, u_2, E, u_1, OrderedSemiring, 𝕜, AddCommGroup, E, Module, 𝕜, E, s, Set, E, hc, t, Set, E, a, t, s, s, convexHull, 𝕜, t, t, t, Set, x, E, x, s, x, x, E, x, s, h, x, convexHull, 𝕜, Subtype.val, t, x, t, x, t] (during elaboration)

{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {s : Set A} {p : (a : A) → Prop} {x : A} (h : x ∈ Algebra.adjoin R s) (Hs : ∀ (x : A) (a : x ∈ s) , p x) (Halg : ∀ (r : R) , p ↑ algebraMap R A r) (Hadd : ∀ (x : A) (y : A) (a : p x) (a : p y) , p x + y) (Hmul : ∀ (x : A) (y : A) (a : p x) (a : p y) , p x * y)  : ∀ {a : A} {b : A} (a_1 : p a) (a_2 : p b) , p a * b
type mismatch
  algebraMap
has type
  (R : Type ?u.600) →
    (A : Type ?u.599) →
      [inst : CommSemiring R] →
        [inst_1 : Semiring A] → [inst_2 : Algebra R A] → R →+* A : Type (max (?u.599 + 1) (?u.600 + 1))
but is expected to have type
  A : Type v ; identifiers [R, u, A, v, CommSemiring, R, Semiring, A, Algebra, R, A, s, Set, A, p, a, A, x, A, h, x, Algebra.adjoin, R, s, Hs, x, A, a, x, s, p, x, Halg, r, R, p, algebraMap, R, A, r, Hadd, x, A, y, A, a, p, x, a, p, y, p, x, y, Hmul, x, A, y, A, a, p, x, a, p, y, p, x, y, a, A, b, A, a_1, p, a, a_2, p, b, p, a, b] (during elaboration)

(n : ℕ) (b : Bool) (n : ℕ) (h : n ≠ 0) (ih : Nat.digits 2 n = List.map fun (b : Bool) ↦ bif b then 1 else 0 Nat.bits n) (h_1 : b = false)  : false = b
type mismatch
  List.map fun b => bif b then 1 else ?m.68 b
has type
  List Bool → List ?m.46 : Type ?u.41
but is expected to have type
  List ℕ : Type ; identifiers [n, b, Bool, n, h, n, ih, Nat.digits, n, List.map, b, Bool, b, Nat.bits, n, h_1, b, false, false, b] (during elaboration)

{α : Type u_1} {s : Finset α} [Nonempty α] (H : Finset.card s ≤ 1) (h : Finset.Nonempty s) (x : α) (hx : x ∈ s) (y : α) (hy : y ∈ s)  : (y ∈ {x}) = (y ∈ {x})
typeclass instance problem is stuck, it is often due to metavariables
  Singleton α (?m.1045 H h x hx y hy) ; identifiers [α, u_1, s, Finset, α, Nonempty, α, H, Finset.card, s, h, Finset.Nonempty, s, x, α, hx, x, s, y, α, hy, y, s, y, x, x, y, x, x] (during elaboration)

{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {s : Set A} {p : (a : A) → Prop} {x : A} (h : x ∈ Algebra.adjoin R s) (Hs : ∀ (x : A) (a : x ∈ s) , p x) (Halg : ∀ (r : R) , p ↑ algebraMap R A r) (Hadd : ∀ (x : A) (y : A) (a : p x) (a : p y) , p x + y) (Hmul : ∀ (x : A) (y : A) (a : p x) (a : p y) , p x * y)  : p ↑ algebraMap R A 1
type mismatch
  algebraMap
has type
  (R : Type ?u.600) →
    (A : Type ?u.599) →
      [inst : CommSemiring R] →
        [inst_1 : Semiring A] → [inst_2 : Algebra R A] → R →+* A : Type (max (?u.599 + 1) (?u.600 + 1))
but is expected to have type
  A : Type v ; identifiers [R, u, A, v, CommSemiring, R, Semiring, A, Algebra, R, A, s, Set, A, p, a, A, x, A, h, x, Algebra.adjoin, R, s, Hs, x, A, a, x, s, p, x, Halg, r, R, p, algebraMap, R, A, r, Hadd, x, A, y, A, a, p, x, a, p, y, p, x, y, Hmul, x, A, y, A, a, p, x, a, p, y, p, x, y, p, algebraMap, R, A] (during elaboration)

 : (∀ {C : Type u₁} [inst : CategoryTheory.Category C] {G : CategoryTheory.Comonad C} (self : CategoryTheory.Comonad.Coalgebra G) , CategoryTheory.CategoryStruct.comp CategoryTheory.Comonad.Coalgebra.a self CategoryTheory.NatTrans.app CategoryTheory.Comonad.δ G CategoryTheory.Comonad.Coalgebra.A self = CategoryTheory.CategoryStruct.comp CategoryTheory.Comonad.Coalgebra.a self CategoryTheory.Functor.toPrefunctor CategoryTheory.Comonad.toFunctor G . map CategoryTheory.Comonad.Coalgebra.a self)
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81002 ?m.160851
term has type
  ?m.424 ⟶ ?m.426 ; identifiers [C, u₁, inst, CategoryTheory.Category, C, G, CategoryTheory.Comonad, C, self, CategoryTheory.Comonad.Coalgebra, G, CategoryTheory.CategoryStruct.comp, CategoryTheory.Comonad.Coalgebra.a, self, CategoryTheory.NatTrans.app, CategoryTheory.Comonad.δ, G, CategoryTheory.Comonad.Coalgebra.A, self, CategoryTheory.CategoryStruct.comp, CategoryTheory.Comonad.Coalgebra.a, self, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Comonad.toFunctor, G, map, CategoryTheory.Comonad.Coalgebra.a, self] (during elaboration)

{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {s : Set A} {p : (a : A) → Prop} {x : A} (h : x ∈ Algebra.adjoin R s) (Hs : ∀ (x : A) (a : x ∈ s) , p x) (Halg : ∀ (r : R) , p ↑ algebraMap R A r) (Hadd : ∀ (x : A) (y : A) (a : p x) (a : p y) , p x + y) (Hmul : ∀ (x : A) (y : A) (a : p x) (a : p y) , p x * y)  : ∀ {a : A} {b : A} (a_1 : p a) (a_2 : p b) , p a + b
type mismatch
  algebraMap
has type
  (R : Type ?u.600) →
    (A : Type ?u.599) →
      [inst : CommSemiring R] →
        [inst_1 : Semiring A] → [inst_2 : Algebra R A] → R →+* A : Type (max (?u.599 + 1) (?u.600 + 1))
but is expected to have type
  A : Type v ; identifiers [R, u, A, v, CommSemiring, R, Semiring, A, Algebra, R, A, s, Set, A, p, a, A, x, A, h, x, Algebra.adjoin, R, s, Hs, x, A, a, x, s, p, x, Halg, r, R, p, algebraMap, R, A, r, Hadd, x, A, y, A, a, p, x, a, p, y, p, x, y, Hmul, x, A, y, A, a, p, x, a, p, y, p, x, y, a, A, b, A, a_1, p, a, a_2, p, b, p, a, b] (during elaboration)

 : ∀ (C : Type u₁) [inst : CategoryTheory.Category C] (G : CategoryTheory.Comonad C) (self : CategoryTheory.Comonad.Coalgebra G) , CategoryTheory.CategoryStruct.comp self . 2 CategoryTheory.NatTrans.app CategoryTheory.Comonad.δ G self . 1 = CategoryTheory.CategoryStruct.comp self . 2 CategoryTheory.Functor.toPrefunctor CategoryTheory.Comonad.toFunctor G . map self . 2
invalid occurrence of `·` notation, it must be surrounded by parentheses (e.g. `(· + 1)`) ; identifiers [C, u₁, inst, CategoryTheory.Category, C, G, CategoryTheory.Comonad, C, self, CategoryTheory.Comonad.Coalgebra, G, CategoryTheory.CategoryStruct.comp, self, CategoryTheory.NatTrans.app, CategoryTheory.Comonad.δ, G, self, CategoryTheory.CategoryStruct.comp, self, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Comonad.toFunctor, G, map, self] (during elaboration)

{G : Type u_1} {P : Type u_2} [AddGroup G] [AddTorsor G P] (p : P)  : ({p} -ᵥ {p} = {0}) = ({p} -ᵥ {p} = {0})
typeclass instance problem is stuck, it is often due to metavariables
  Singleton P (?m.1960 p) ; identifiers [G, u_1, P, u_2, AddGroup, G, AddTorsor, G, P, p, P, p, p, p, p, p, p, p, p] (during elaboration)

{α : Type u_1} {s : Set α} [BooleanAlgebra α] (hs : IsAntichain fun (x : α) (x_1 : α) ↦ x ≤ x_1 s) (x : α) (ha : x ∈ compl ⁻¹' s) (x_1 : α) (ha' : x_1 ∈ compl ⁻¹' s) (hne : x ≠ x_1) (hle : fun (x : α) (x_2 : α) ↦ x ≤ x_2 x x_1) (h : x_1 ᶜ = x ᶜ)  : x ᶜ = x_1 ᶜ
function expected at
  x_1
term has type
  α ; identifiers [α, u_1, s, Set, α, BooleanAlgebra, α, hs, IsAntichain, x, α, x_1, α, x, x_1, s, x, α, ha, x, compl, s, x_1, α, ha', x_1, compl, s, hne, x, x_1, hle, x, α, x_2, α, x, x_2, x, x_1, h, x_1, x, x, x_1] (during elaboration)

{α : Type u_1} {s : Finset α} [Nonempty α] (H : Finset.card s ≤ 1) (h : Finset.Nonempty s) (x : α) (hx : x ∈ s) (y : α) (hy : y ∈ s)  : (x ∈ {x}) = (x ∈ {x})
typeclass instance problem is stuck, it is often due to metavariables
  Singleton α (?m.1045 H h x hx y hy) ; identifiers [α, u_1, s, Finset, α, Nonempty, α, H, Finset.card, s, h, Finset.Nonempty, s, x, α, hx, x, s, y, α, hy, y, s, x, x, x, x, x, x] (during elaboration)

{G : Type u_1} {P : Type u_2} [AddGroup G] [AddTorsor G P] (p : P)  : ({p -ᵥ p} = {0}) = ({p -ᵥ p} = {0})
typeclass instance problem is stuck, it is often due to metavariables
  Singleton ℕ (?m.560 p) ; identifiers [G, u_1, P, u_2, AddGroup, G, AddTorsor, G, P, p, P, p, p, p, p] (during elaboration)

{G : Type u_1} {P : Type u_2} [AddGroup G] [AddTorsor G P] (p : P)  : {0} = {0}
typeclass instance problem is stuck, it is often due to metavariables
  Singleton ℕ (?m.212 p) ; identifiers [G, u_1, P, u_2, AddGroup, G, AddTorsor, G, P, p, P] (during elaboration)

{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {s : Set A} {p : (a : A) → Prop} {x : A} (h : x ∈ Algebra.adjoin R s) (Hs : ∀ (x : A) (a : x ∈ s) , p x) (Halg : ∀ (r : R) , p ↑ algebraMap R A r) (Hadd : ∀ (x : A) (y : A) (a : p x) (a : p y) , p x + y) (Hmul : ∀ (x : A) (y : A) (a : p x) (a : p y) , p x * y)  : p ↑ algebraMap R A 0
type mismatch
  algebraMap
has type
  (R : Type ?u.600) →
    (A : Type ?u.599) →
      [inst : CommSemiring R] →
        [inst_1 : Semiring A] → [inst_2 : Algebra R A] → R →+* A : Type (max (?u.599 + 1) (?u.600 + 1))
but is expected to have type
  A : Type v ; identifiers [R, u, A, v, CommSemiring, R, Semiring, A, Algebra, R, A, s, Set, A, p, a, A, x, A, h, x, Algebra.adjoin, R, s, Hs, x, A, a, x, s, p, x, Halg, r, R, p, algebraMap, R, A, r, Hadd, x, A, y, A, a, p, x, a, p, y, p, x, y, Hmul, x, A, y, A, a, p, x, a, p, y, p, x, y, p, algebraMap, R, A] (during elaboration)

{E : Type u} [NormedAddCommGroup E] [NormedSpace ℂ E] {f : (a : E) → ℂ} {c : E} (hf : ∀ᶠ (z : E) in nhds c , DifferentiableAt ℂ f z) (hc : IsLocalMin norm ∘ f c) (h : ¬ (f c = 0 : Prop)) (h1 : ∀ᶠ (z : E) in nhds c , f z ≠ 0) (h2 : IsLocalMax norm ∘ f ⁻¹ c)  : (∀ (a : E) , True) = True
type expected, got
  (IsLocalMin norm ∘ ?m.80670 : ?m.824 → Prop) ; identifiers [E, u, NormedAddCommGroup, E, NormedSpace, E, f, a, E, c, E, hf, z, E, nhds, c, DifferentiableAt, f, z, hc, IsLocalMin, norm, f, c, h, f, c, h1, z, E, nhds, c, f, z, h2, IsLocalMax, norm, f, c, a, E, True, True] (during elaboration)

{cells : Finset ℕ × ℕ} {isLowerSet : IsLowerSet ↑ cells} {cells_1 : Finset ℕ × ℕ} {isLowerSet_1 : IsLowerSet ↑ cells_1} (x : {cells := ((cells)) , isLowerSet := ((isLowerSet))} = {cells := ((cells_1)) , isLowerSet := ((isLowerSet_1))})  : ∀ (cells_eq : cells = cells_1) , cells = cells_1
type mismatch
  cells_1
has type
  Finset ℕ × ℕ : Type
but is expected to have type
  Set ?m.833 : Type ; identifiers [cells, Finset, isLowerSet, IsLowerSet, cells, cells_1, Finset, isLowerSet_1, IsLowerSet, cells_1, x, cells, cells, isLowerSet, isLowerSet, cells, cells_1, isLowerSet, isLowerSet_1, cells_eq, cells, cells_1, cells, cells_1] (during elaboration)

 : (∀ {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E] [inst_3 : Nonempty ι] {p : SeminormFamily 𝕜 E ι} [topology : TopologicalSpace E] (self : WithSeminorms p) , topology = ModuleFilterBasis.topology SeminormFamily.moduleFilterBasis p)
function expected at
  ModuleFilterBasis.topology ?m.83532
term has type
  TopologicalSpace ?m.1801 ; identifiers [𝕜, u_1, E, u_2, ι, u_3, inst, NormedField, 𝕜, inst_1, AddCommGroup, E, inst_2, Module, 𝕜, E, inst_3, Nonempty, ι, p, SeminormFamily, 𝕜, E, ι, topology, TopologicalSpace, E, self, WithSeminorms, p, topology, ModuleFilterBasis.topology, SeminormFamily.moduleFilterBasis, p] (during elaboration)

 : ∀ (𝕜 : Type u_1) (E : Type u_2) (ι : Type u_3) [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E] [inst_3 : Nonempty ι] (p : SeminormFamily 𝕜 E ι) [topology : TopologicalSpace E] (self : WithSeminorms p) , topology = ModuleFilterBasis.topology SeminormFamily.moduleFilterBasis p
function expected at
  ModuleFilterBasis.topology ?m.83532
term has type
  TopologicalSpace ?m.1801 ; identifiers [𝕜, u_1, E, u_2, ι, u_3, inst, NormedField, 𝕜, inst_1, AddCommGroup, E, inst_2, Module, 𝕜, E, inst_3, Nonempty, ι, p, SeminormFamily, 𝕜, E, ι, topology, TopologicalSpace, E, self, WithSeminorms, p, topology, ModuleFilterBasis.topology, SeminormFamily.moduleFilterBasis, p] (during elaboration)

{α : Type u_1} [Group α] [IsCyclic α] (x : α) (y : α) (w : α) (hg_1 : ∀ (x : α) , x ∈ Subgroup.zpowers w) (w_1 : ℤ) (hn : fun (x : α) (x_1 : ℤ) ↦ x ^ x_1 w w_1 = x)  : y ∈ Subgroup.zpowers w
function expected at
  x_1
term has type
  ℤ ; identifiers [α, u_1, Group, α, IsCyclic, α, x, α, y, α, w, α, hg_1, x, α, x, Subgroup.zpowers, w, w_1, hn, x, α, x_1, x, x_1, w, w_1, x, y, Subgroup.zpowers, w] (during elaboration)

{s : Set ℕ} {m : ℕ} (hm : m < sInf s) (h : s = ∅) (h_1 : (Set.eq_empty_or_nonempty s =: (s = ∅ : Prop) ∨ (Set.Nonempty s : Prop)) = (Or.inl h =: (s = ∅ : Prop) ∨ (Set.Nonempty s : Prop)))  : Or.inl h = Set.eq_empty_or_nonempty s
<input>:1:86: expected term

{s : Set ℕ} {m : ℕ} (hm : m < sInf s) (h : s = ∅) (h_1 : (Set.eq_empty_or_nonempty s =: (s = ∅ : Prop) ∨ (Set.Nonempty s : Prop)) = (Or.inl h =: (s = ∅ : Prop) ∨ (Set.Nonempty s : Prop)))  : ∅ = s
<input>:1:86: expected term

{s : Set ℕ} {m : ℕ} (hm : m < sInf s) (h : Set.Nonempty s) (h_1 : (Set.eq_empty_or_nonempty s =: (s = ∅ : Prop) ∨ (Set.Nonempty s : Prop)) = (Or.inr h =: (s = ∅ : Prop) ∨ (Set.Nonempty s : Prop)))  : Or.inr h = Set.eq_empty_or_nonempty s
<input>:1:95: expected term

 : (∀ {α : Type u_1} {p : (a : α ᵒᵈ) → Prop} , (∃ (a : α ᵒᵈ) , p a : Prop) ↔ (∃ (a : α) , p ↑ OrderDual.toDual a : Prop))
type mismatch
  OrderDual.toDual
has type
  ?m.26 ≃ ?m.26ᵒᵈ : Type u_1
but is expected to have type
  αᵒᵈ : Type u_1 ; identifiers [α, u_1, p, a, α, a, α, p, a, a, α, p, OrderDual.toDual, a] (during elaboration)

(f : StieltjesFunction) {a : ℝ} {b : ℝ} (hab : a < b) (A : Disjoint Set.Ioo a b {b})  : 1 = 1
application type mismatch
  Disjoint Set.Ioo a
argument
  a
has type
  ℝ : Type
but is expected to have type
  ?m.26 → ?m.26 → Set ?m.26 : Type ?u.25 ; identifiers [f, StieltjesFunction, a, b, hab, a, b, A, Disjoint, Set.Ioo, a, b, b, b] (during elaboration)

(f : StieltjesFunction) {a : ℝ} {b : ℝ} (hab : a < b) (A : Disjoint Set.Ioo a b {b})  : 0 = 0
application type mismatch
  Disjoint Set.Ioo a
argument
  a
has type
  ℝ : Type
but is expected to have type
  ?m.26 → ?m.26 → Set ?m.26 : Type ?u.25 ; identifiers [f, StieltjesFunction, a, b, hab, a, b, A, Disjoint, Set.Ioo, a, b, b, b] (during elaboration)

{α : Type u_1} {m0 : MeasurableSpace α} {ι : Type u_2} [Finite ι] (μ : (a : ι) → MeasureTheory.Measure α) [∀ (i : ι) , MeasureTheory.SigmaFinite μ i] (val : Fintype ι) (h : (nonempty_fintype ι =: Nonempty Fintype ι) = (Nonempty.intro val =: Nonempty Fintype ι))  : Nonempty.intro val = nonempty_fintype ι
<input>:1:194: expected term

{ι : Type u_1} {α : (a : ι) → Type u_2} [Fintype ι] {m : (i : ι) → MeasureTheory.OuterMeasure α i} {s : Set (i : ι) → α i} (i : ι)  : ∀ (a : (x : ι) → α x) (a_1 : a ∈ s) , a i = a i
application type mismatch
  MeasureTheory.OuterMeasure α
argument
  α
has type
  ι → Type u_2 : Type (max u_1 (u_2 + 1))
but is expected to have type
  Type ?u.19 : Type (?u.19 + 1) ; identifiers [ι, u_1, α, a, ι, u_2, Fintype, ι, m, i, ι, MeasureTheory.OuterMeasure, α, i, s, Set, i, ι, α, i, i, ι, a, x, ι, α, x, a_1, a, s, a, i, a, i] (during elaboration)

(n : ℕ) (b : Bool) (n : ℕ) (h : n ≠ 0) (ih : Nat.digits 2 n = List.map fun (b : Bool) ↦ bif b then 1 else 0 Nat.bits n) (h : b = true)  : true = b
type mismatch
  List.map fun b => bif b then 1 else ?m.68 b
has type
  List Bool → List ?m.46 : Type ?u.41
but is expected to have type
  List ℕ : Type ; identifiers [n, b, Bool, n, h, n, ih, Nat.digits, n, List.map, b, Bool, b, Nat.bits, n, h, b, true, true, b] (during elaboration)

(p : Prop) U : (x : Prop) → Prop := fun (x : Prop) ↦ ((x : Prop) = (True : Prop) : Prop) ∨ (p : Prop) V : (x : Prop) → Prop := fun (x : Prop) ↦ ((x : Prop) = (False : Prop) : Prop) ∨ (p : Prop) (exU : ∃ (x : Prop) , U (x : Prop)) (exV : ∃ (x : Prop) , V (x : Prop)) u : Prop := (Classical.choose exU : Prop) v : Prop := (Classical.choose exV : Prop) (u_def : U (u : Prop)) (v_def : V (v : Prop)) (not_uv_or_p : ((u : Prop) ≠ (v : Prop) : Prop) ∨ (p : Prop)) (hp : p) (hpred : U = V) (h₀ : ∀ (exU : ∃ (x : Prop) , U (x : Prop)) (exV : ∃ (x : Prop) , V (x : Prop)) , (Classical.choose exU : Prop) = (Classical.choose exV : Prop))  : u = v
<input>:1:13: expected end of input

(p : Prop) U : (x : Prop) → Prop := fun (x : Prop) ↦ ((x : Prop) = (True : Prop) : Prop) ∨ (p : Prop) V : (x : Prop) → Prop := fun (x : Prop) ↦ ((x : Prop) = (False : Prop) : Prop) ∨ (p : Prop) (exU : ∃ (x : Prop) , U (x : Prop)) (exV : ∃ (x : Prop) , V (x : Prop)) u : Prop := (Classical.choose exU : Prop) v : Prop := (Classical.choose exV : Prop) (u_def : U (u : Prop)) (v_def : V (v : Prop)) (not_uv_or_p : ((u : Prop) ≠ (v : Prop) : Prop) ∨ (p : Prop)) (hp : p) (hpred : U = V) (h₀ : ∀ (exU : ∃ (x : Prop) , U (x : Prop)) (exV : ∃ (x : Prop) , V (x : Prop)) , (Classical.choose exU : Prop) = (Classical.choose exV : Prop))  : (Classical.choose exU) = (Classical.choose exV)
<input>:1:13: expected end of input

{α : Type u_1} [Fintype α] [DecidableEq α] {l : List Equiv.Perm α} (hl : ∀ (g : Equiv.Perm α) (a : g ∈ l) , Equiv.Perm.IsSwap g)  : (Even List.length l) ↔ (Even List.length l)
application type mismatch
  List Equiv.Perm
argument
  Equiv.Perm
has type
  Sort ?u.21 → Sort (max 1 ?u.21) : Type (max 1 ?u.21)
but is expected to have type
  Type ?u.20 : Type (?u.20 + 1) ; identifiers [α, u_1, Fintype, α, DecidableEq, α, l, List, Equiv.Perm, α, hl, g, Equiv.Perm, α, a, g, l, Equiv.Perm.IsSwap, g, Even, List.length, l, Even, List.length, l] (during elaboration)

(C : Type u_1) [CategoryTheory.Category C] [CategoryTheory.Precoherent C] (P : CategoryTheory.Functor C ᵒᵖ Type w) (h : ∀ (B : C) (α : Type) [inst_2 : Fintype α] (X : (a : α) → C) (π : (a : α) → X a ⟶ B) (a : CategoryTheory.EffectiveEpiFamily X π) , CategoryTheory.Presieve.IsSheafFor P CategoryTheory.Presieve.ofArrows X π) {B : C} (S : CategoryTheory.Presieve B) (a : S ∈ CategoryTheory.Coverage.covering CategoryTheory.coherentCoverage C B) (α : Type) (h_1 : ∃ (x : Fintype α) , ∃ (X : (a : α) → C) , ∃ (π : (a : α) → X a ⟶ B) , (S = CategoryTheory.Presieve.ofArrows X π : Prop) ∧ (CategoryTheory.EffectiveEpiFamily X π : Prop)) (w : Fintype α) (h_2 : ∃ (X : (a : α) → C) , ∃ (π : (a : α) → X a ⟶ B) , (S = CategoryTheory.Presieve.ofArrows X π : Prop) ∧ (CategoryTheory.EffectiveEpiFamily X π : Prop)) (X : (a : α) → C) (h_3 : ∃ (π : (a : α) → X a ⟶ B) , (S = CategoryTheory.Presieve.ofArrows X π : Prop) ∧ (CategoryTheory.EffectiveEpiFamily X π : Prop)) (π : (a : α) → X a ⟶ B) (h_4 : (S = CategoryTheory.Presieve.ofArrows X π : Prop) ∧ (CategoryTheory.EffectiveEpiFamily X π : Prop)) (left : S = CategoryTheory.Presieve.ofArrows X π) (hS : CategoryTheory.EffectiveEpiFamily X π)  : CategoryTheory.Presieve.ofArrows X π = S
function expected at
  CategoryTheory.Functor Cᵒᵖ Type
term has type
  Type (max ?u.7 u_1 1) ; identifiers [C, u_1, CategoryTheory.Category, C, CategoryTheory.Precoherent, C, P, CategoryTheory.Functor, C, w, h, B, C, α, inst_2, Fintype, α, X, a, α, C, π, a, α, X, a, B, a, CategoryTheory.EffectiveEpiFamily, X, π, CategoryTheory.Presieve.IsSheafFor, P, CategoryTheory.Presieve.ofArrows, X, π, B, C, S, CategoryTheory.Presieve, B, a, S, CategoryTheory.Coverage.covering, CategoryTheory.coherentCoverage, C, B, α, h_1, x, Fintype, α, X, a, α, C, π, a, α, X, a, B, S, CategoryTheory.Presieve.ofArrows, X, π, CategoryTheory.EffectiveEpiFamily, X, π, w, Fintype, α, h_2, X, a, α, C, π, a, α, X, a, B, S, CategoryTheory.Presieve.ofArrows, X, π, CategoryTheory.EffectiveEpiFamily, X, π, X, a, α, C, h_3, π, a, α, X, a, B, S, CategoryTheory.Presieve.ofArrows, X, π, CategoryTheory.EffectiveEpiFamily, X, π, π, a, α, X, a, B, h_4, S, CategoryTheory.Presieve.ofArrows, X, π, CategoryTheory.EffectiveEpiFamily, X, π, left, S, CategoryTheory.Presieve.ofArrows, X, π, hS, CategoryTheory.EffectiveEpiFamily, X, π, CategoryTheory.Presieve.ofArrows, X, π, S] (during elaboration)

(C : Type u_1) [CategoryTheory.Category C] [CategoryTheory.Precoherent C] (P : CategoryTheory.Functor C ᵒᵖ Type w) (h : ∀ (B : C) (α : Type) [inst_2 : Fintype α] (X : (a : α) → C) (π : (a : α) → X a ⟶ B) (a : CategoryTheory.EffectiveEpiFamily X π) , CategoryTheory.Presieve.IsSheafFor P CategoryTheory.Presieve.ofArrows X π) {B : C} (S : CategoryTheory.Presieve B) (a : S ∈ CategoryTheory.Coverage.covering CategoryTheory.coherentCoverage C B) (α : Type) (h_1 : ∃ (x : Fintype α) , ∃ (X : (a : α) → C) , ∃ (π : (a : α) → X a ⟶ B) , (S = CategoryTheory.Presieve.ofArrows X π : Prop) ∧ (CategoryTheory.EffectiveEpiFamily X π : Prop)) (w : Fintype α) (h_2 : ∃ (X : (a : α) → C) , ∃ (π : (a : α) → X a ⟶ B) , (S = CategoryTheory.Presieve.ofArrows X π : Prop) ∧ (CategoryTheory.EffectiveEpiFamily X π : Prop)) (X : (a : α) → C) (h_3 : ∃ (π : (a : α) → X a ⟶ B) , (S = CategoryTheory.Presieve.ofArrows X π : Prop) ∧ (CategoryTheory.EffectiveEpiFamily X π : Prop)) (π : (a : α) → X a ⟶ B) (h_4 : (S = CategoryTheory.Presieve.ofArrows X π : Prop) ∧ (CategoryTheory.EffectiveEpiFamily X π : Prop)) (left : S = CategoryTheory.Presieve.ofArrows X π) (hS : CategoryTheory.EffectiveEpiFamily X π)  : CategoryTheory.Presieve.IsSheafFor P CategoryTheory.Presieve.ofArrows X π
function expected at
  CategoryTheory.Functor Cᵒᵖ Type
term has type
  Type (max ?u.7 u_1 1) ; identifiers [C, u_1, CategoryTheory.Category, C, CategoryTheory.Precoherent, C, P, CategoryTheory.Functor, C, w, h, B, C, α, inst_2, Fintype, α, X, a, α, C, π, a, α, X, a, B, a, CategoryTheory.EffectiveEpiFamily, X, π, CategoryTheory.Presieve.IsSheafFor, P, CategoryTheory.Presieve.ofArrows, X, π, B, C, S, CategoryTheory.Presieve, B, a, S, CategoryTheory.Coverage.covering, CategoryTheory.coherentCoverage, C, B, α, h_1, x, Fintype, α, X, a, α, C, π, a, α, X, a, B, S, CategoryTheory.Presieve.ofArrows, X, π, CategoryTheory.EffectiveEpiFamily, X, π, w, Fintype, α, h_2, X, a, α, C, π, a, α, X, a, B, S, CategoryTheory.Presieve.ofArrows, X, π, CategoryTheory.EffectiveEpiFamily, X, π, X, a, α, C, h_3, π, a, α, X, a, B, S, CategoryTheory.Presieve.ofArrows, X, π, CategoryTheory.EffectiveEpiFamily, X, π, π, a, α, X, a, B, h_4, S, CategoryTheory.Presieve.ofArrows, X, π, CategoryTheory.EffectiveEpiFamily, X, π, left, S, CategoryTheory.Presieve.ofArrows, X, π, hS, CategoryTheory.EffectiveEpiFamily, X, π, CategoryTheory.Presieve.IsSheafFor, P, CategoryTheory.Presieve.ofArrows, X, π] (during elaboration)

{X : Type u_1} (R : Type u_2) [TopologicalSpace X] [Semiring R] [TopologicalSpace R] [TopologicalSemiring R] (s : Set X) (c : C(X , R)) (f : C(X , R)) (hf : f ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup {toAddSubsemigroup := (({carrier := (({f : C(X , R) | ∀ (x : X) (a : x ∈ s ᶜ) , ↑ f x = 0})) , add_mem' := (((fun {f : C(X , R)} {g : C(X , R)} (hf : f ∈ {f : C(X , R) | ∀ (x : X) (a : x ∈ s ᶜ) , ↑ f x = 0}) (hg : g ∈ {f : C(X , R) | ∀ (x : X) (a : x ∈ s ᶜ) , ↑ f x = 0}) (x : X) (hx : x ∈ s ᶜ) ↦ of_eq_true (Eq.trans (congrFun (congrArg Eq (Eq.trans (congr (congrArg HAdd.hAdd (hf x hx =: ↑ f x = 0) =: HAdd.hAdd ↑ f x = HAdd.hAdd 0) (hg x hx =: ↑ g x = 0) =: ↑ f x + ↑ g x = 0 + 0) (add_zero 0 =: 0 + 0 = 0) =: ↑ f x + ↑ g x = 0) =: Eq ↑ f x + ↑ g x = Eq 0) 0 =: (↑ f x + ↑ g x = 0 : Prop) = (0 = 0 : Prop)) (eq_self 0 =: (0 = 0 : Prop) = (True : Prop)) =: (↑ f x + ↑ g x = 0 : Prop) = (True : Prop)) =: ∀ {f : C(X , R)} {g : C(X , R)} (hf : f ∈ {f : C(X , R) | ∀ (x : X) (a : x ∈ s ᶜ) , ↑ f x = 0}) (hg : g ∈ {f : C(X , R) | ∀ (x : X) (a : x ∈ s ᶜ) , ↑ f x = 0}) (x : X) (hx : x ∈ s ᶜ) , ↑ f x + ↑ g x = 0)))})) , zero_mem' := (((fun (x : X) (x_1 : x ∈ s ᶜ) ↦ rfl =: ∀ (x : X) (x_1 : x ∈ s ᶜ) , ↑ 0 x = ↑ 0 x)))}) (x : X) (hx : x ∈ s ᶜ)  : ↑ f x = 0
<input>:1:604: expected term

{α : Type u_1} [Ring α] {a : α} [LinearOrder α] (h : | a | = a) (h_1 : (abs_choice a =: (| a | = a : Prop) ∨ (| a | = - a : Prop)) = (Or.inl h =: (| a | = a : Prop) ∨ (| a | = - a : Prop)))  : Or.inl h = abs_choice a
<input>:1:53: expected ')' or no space before

{α : Type u_1} [Ring α] {a : α} [LinearOrder α] (h : | a | = - a) (h_1 : (abs_choice a =: (| a | = a : Prop) ∨ (| a | = - a : Prop)) = (Or.inr h =: (| a | = a : Prop) ∨ (| a | = - a : Prop)))  : Or.inr h = abs_choice a
<input>:1:53: expected ')' or no space before

{f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {a : ℝ} {b : ℝ} {l : ℝ} (hab : a < b) (hfa : Filter.Tendsto f nhdsWithin a Set.Ioi a nhds l) (hfb : Filter.Tendsto f nhdsWithin b Set.Iio b nhds l) (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo a b) , HasDerivAt f f' x x) (this : ContinuousOn f Set.Ioo a b) (hcont : ContinuousOn extendFrom Set.Ioo a b f Set.Icc a b) (c : ℝ) (h : (c ∈ Set.Ioo a b : Prop) ∧ (IsLocalExtr extendFrom Set.Ioo a b f c : Prop)) (hc : c ∈ Set.Ioo a b) (hcextr : IsLocalExtr extendFrom Set.Ioo a b f c)  : HasDerivAt f f' c c
application type mismatch
  Filter.Tendsto f nhdsWithin
argument
  nhdsWithin
has type
  ?m.41 → Set ?m.41 → Filter ?m.41 : Type ?u.40
but is expected to have type
  Filter ℝ : Type ; identifiers [f, a, f', a, a, b, l, hab, a, b, hfa, Filter.Tendsto, f, nhdsWithin, a, Set.Ioi, a, nhds, l, hfb, Filter.Tendsto, f, nhdsWithin, b, Set.Iio, b, nhds, l, hff', x, a, x, Set.Ioo, a, b, HasDerivAt, f, f', x, x, this, ContinuousOn, f, Set.Ioo, a, b, hcont, ContinuousOn, extendFrom, Set.Ioo, a, b, f, Set.Icc, a, b, c, h, c, Set.Ioo, a, b, IsLocalExtr, extendFrom, Set.Ioo, a, b, f, c, hc, c, Set.Ioo, a, b, hcextr, IsLocalExtr, extendFrom, Set.Ioo, a, b, f, c, HasDerivAt, f, f', c, c] (during elaboration)

{α : Type u_1} {m0 : MeasurableSpace α} {ι : Type u_2} [Finite ι] (μ : (a : ι) → MeasureTheory.Measure α) [∀ (i : ι) , MeasureTheory.SigmaFinite μ i] (val : Fintype ι) (h : (nonempty_fintype ι =: Nonempty Fintype ι) = (Nonempty.intro val =: Nonempty Fintype ι)) (this : ∀ (n : ℕ) , MeasurableSet ⋂ (i : ι) , MeasureTheory.spanningSets μ i n) (n : ℕ)  : MeasurableSet ⋂ (i : ι) , MeasureTheory.spanningSets μ i n
<input>:1:194: expected term

{R : Type u} {I : Type v} [CommSemiring R] {z : R} {s : (a : I) → R} {t : Finset I} ⦃ a : I ⦄ {r : Finset I} (har : ¬ (a ∈ r : Prop)) (ih : ∀ (x : Set.Pairwise ↑ r IsCoprime on s) (x : ∀ (i : I) (a : i ∈ r) , s i ∣ z) , Finset.prod r fun (x : I) ↦ s x ∣ z) (Hs : Set.Pairwise ↑ insert a r IsCoprime on s) (Hs1 : ∀ (i : I) (a : i ∈ insert a r) , s i ∣ z) (aux1 : a ∈ ↑ insert a r) (i : I) (hir : i ∈ r) (a_1 : a = i)  : ∀ (hir : a ∈ r) , False
type expected, got
  (?m.79502 on s : I → I → ?m.60) ; identifiers [R, u, I, v, CommSemiring, R, z, R, s, a, I, R, t, Finset, I, a, I, r, Finset, I, har, a, r, ih, x, Set.Pairwise, r, IsCoprime, s, x, i, I, a, i, r, s, i, z, Finset.prod, r, x, I, s, x, z, Hs, Set.Pairwise, insert, a, r, IsCoprime, s, Hs1, i, I, a, i, insert, a, r, s, i, z, aux1, a, insert, a, r, i, I, hir, i, r, a_1, a, i, hir, a, r, False] (during elaboration)

{R : Type u} {I : Type v} [CommSemiring R] {z : R} {s : (a : I) → R} {t : Finset I} ⦃ a : I ⦄ {r : Finset I} (har : ¬ (a ∈ r : Prop)) (ih : ∀ (x : Set.Pairwise ↑ r IsCoprime on s) (x : ∀ (i : I) (a : i ∈ r) , s i ∣ z) , Finset.prod r fun (x : I) ↦ s x ∣ z) (Hs : Set.Pairwise ↑ insert a r IsCoprime on s) (Hs1 : ∀ (i : I) (a : i ∈ insert a r) , s i ∣ z) (aux1 : a ∈ ↑ insert a r)  : s a ∣ z
type expected, got
  (?m.79502 on s : I → I → ?m.60) ; identifiers [R, u, I, v, CommSemiring, R, z, R, s, a, I, R, t, Finset, I, a, I, r, Finset, I, har, a, r, ih, x, Set.Pairwise, r, IsCoprime, s, x, i, I, a, i, r, s, i, z, Finset.prod, r, x, I, s, x, z, Hs, Set.Pairwise, insert, a, r, IsCoprime, s, Hs1, i, I, a, i, insert, a, r, s, i, z, aux1, a, insert, a, r, s, a, z] (during elaboration)

{f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {a : ℝ} {b : ℝ} {l : ℝ} (hab : a < b) (hfa : Filter.Tendsto f nhdsWithin a Set.Ioi a nhds l) (hfb : Filter.Tendsto f nhdsWithin b Set.Iio b nhds l) (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo a b) , HasDerivAt f f' x x) (x : ℝ) (hx : x ∈ Set.Ioo a b)  : HasDerivAt f f' x x
application type mismatch
  Filter.Tendsto f nhdsWithin
argument
  nhdsWithin
has type
  ?m.41 → Set ?m.41 → Filter ?m.41 : Type ?u.40
but is expected to have type
  Filter ℝ : Type ; identifiers [f, a, f', a, a, b, l, hab, a, b, hfa, Filter.Tendsto, f, nhdsWithin, a, Set.Ioi, a, nhds, l, hfb, Filter.Tendsto, f, nhdsWithin, b, Set.Iio, b, nhds, l, hff', x, a, x, Set.Ioo, a, b, HasDerivAt, f, f', x, x, x, hx, x, Set.Ioo, a, b, HasDerivAt, f, f', x, x] (during elaboration)

(n : ℕ) (b : Bool) (n : ℕ) (h : n ≠ 0) (ih : Nat.digits 2 n = List.map fun (b : Bool) ↦ bif b then 1 else 0 Nat.bits n)  : b = b
type mismatch
  List.map fun b => bif b then 1 else ?m.68 b
has type
  List Bool → List ?m.46 : Type ?u.41
but is expected to have type
  List ℕ : Type ; identifiers [n, b, Bool, n, h, n, ih, Nat.digits, n, List.map, b, Bool, b, Nat.bits, n, b, b] (during elaboration)

{G : Type u_1} [AddGroup G] {H : AddSubgroup G} [Finite G ⧸ H] (val : Fintype G ⧸ H) (h : (nonempty_fintype G ⧸ H =: Nonempty Fintype G ⧸ H) = (Nonempty.intro val =: Nonempty Fintype G ⧸ H))  : Nonempty.intro val = nonempty_fintype G ⧸ H
<input>:1:115: expected term

{M : Type u_1} {inst : CommMonoidWithZero M} {S : Submonoid M} {N : Type u_2} {inst_1 : CommMonoidWithZero N} {toLocalizationMap : Submonoid.LocalizationMap S N} {map_zero' : OneHom.toFun ↑ Submonoid.LocalizationMap.toMonoidHom toLocalizationMap 0 = 0} {toLocalizationMap_1 : Submonoid.LocalizationMap S N} {map_zero'_1 : OneHom.toFun ↑ Submonoid.LocalizationMap.toMonoidHom toLocalizationMap_1 0 = 0} (x : {toLocalizationMap := ((toLocalizationMap)) , map_zero' := ((map_zero'))} = {toLocalizationMap := ((toLocalizationMap_1)) , map_zero' := ((map_zero'_1))})  : ∀ (toLocalizationMap_eq : toLocalizationMap = toLocalizationMap_1) , toLocalizationMap = toLocalizationMap_1
function expected at
  OneHom.toFun ?m.1615 toLocalizationMap
term has type
  ?m.1054 ; identifiers [M, u_1, inst, CommMonoidWithZero, M, S, Submonoid, M, N, u_2, inst_1, CommMonoidWithZero, N, toLocalizationMap, Submonoid.LocalizationMap, S, N, map_zero', OneHom.toFun, Submonoid.LocalizationMap.toMonoidHom, toLocalizationMap, toLocalizationMap_1, Submonoid.LocalizationMap, S, N, map_zero'_1, OneHom.toFun, Submonoid.LocalizationMap.toMonoidHom, toLocalizationMap_1, x, toLocalizationMap, toLocalizationMap, map_zero', map_zero', toLocalizationMap, toLocalizationMap_1, map_zero', map_zero'_1, toLocalizationMap_eq, toLocalizationMap, toLocalizationMap_1, toLocalizationMap, toLocalizationMap_1] (during elaboration)

{H : Type u_1} [TopologicalSpace H] {α : Type u_2} [TopologicalSpace α] (e : LocalHomeomorph α H) (x : α) em : (a : Prop) → Decidable (a : Prop) := Classical.propDecidable  : fun (x : α) ↦ e x = fun (x : α) ↦ e x
<input>:1:109: expected end of input

{α : Type u} {β : Type v} (as : List α) (bs : List β) (head : α) (tail : List α) (tail_ih : ∀ (bs : List β) , List.zipRight tail bs = Prod.fst List.zipRight' tail bs) (bs : List β) (h : bs = [])  : [] = bs
function expected at
  ?m.185.fst
term has type
  ?m.39 ; identifiers [α, u, β, v, as, List, α, bs, List, β, head, α, tail, List, α, tail_ih, bs, List, β, List.zipRight, tail, bs, Prod.fst, List.zipRight', tail, bs, bs, List, β, h, bs, bs] (during elaboration)

{α : Type u_4} {β : Type u_1} {ι : Type u_2} {κ : Type u_3} [VAdd α β] (b : (a : ι) → α) (c : (a : κ) → β) (_x : β) (motive : (x : _x ∈ Set.range fun (p : ι × κ) ↦ b Prod.fst p +ᵥ c Prod.snd p) → Prop) (x : _x ∈ Set.range fun (p : ι × κ) ↦ b Prod.fst p +ᵥ c Prod.snd p) (h_1 : ∀ (i : ι) (j : κ) (h : fun (p : ι × κ) ↦ b Prod.fst p +ᵥ c Prod.snd p (i , j) = _x) , motive (Exists.intro (i , j) h =: ∃ (y : ι × κ) , fun (p : ι × κ) ↦ b Prod.fst p +ᵥ c Prod.snd p y = _x)) (w : ι × κ) (h : fun (p : ι × κ) ↦ b Prod.fst p +ᵥ c Prod.snd p w = _x)  : ∀ (fst : ι) (snd : κ) (h : fun (p : ι × κ) ↦ b Prod.fst p +ᵥ c Prod.snd p (fst , snd) = _x) , motive Exists.intro (fst , snd) h
<input>:1:395: expected term

{α : Type u} [DecidableEq α] {a : α} {b : α} (l : List α) (x : a ≠ b) h : a ≠ b := x  : ∀ (a : False) , 0 = 0
<input>:1:72: expected end of input

{α : Type u} {β : Type v} (as : List α) (bs : List β) (head : α) (tail : List α) (tail_ih : ∀ (bs : List β) , List.zipRight tail bs = Prod.fst List.zipRight' tail bs) (bs : List β) (head_1 : β) (tail_1 : List β) (h : bs = head_1 :: tail_1)  : head_1 :: tail_1 = bs
function expected at
  ?m.185.fst
term has type
  ?m.39 ; identifiers [α, u, β, v, as, List, α, bs, List, β, head, α, tail, List, α, tail_ih, bs, List, β, List.zipRight, tail, bs, Prod.fst, List.zipRight', tail, bs, bs, List, β, head_1, β, tail_1, List, β, h, bs, head_1, tail_1, head_1, tail_1, bs] (during elaboration)

{α : Type u_1} (h : α) (s : Stream'.Seq GeneralizedContinuedFraction.Pair α) (h_1 : α) (s_1 : Stream'.Seq GeneralizedContinuedFraction.Pair α) (a : (h = h_1 : Prop) ∧ (s = s_1 : Prop)) (left : h = h_1) (right : s = s_1) (h_2 : h_1 = h) (h_3 : α)  : h = h
application type mismatch
  Stream'.Seq GeneralizedContinuedFraction.Pair
argument
  GeneralizedContinuedFraction.Pair
has type
  Type ?u.10 → Type ?u.10 : Type (?u.10 + 1)
but is expected to have type
  Type ?u.9 : Type (?u.9 + 1) ; identifiers [α, u_1, h, α, s, Stream'.Seq, GeneralizedContinuedFraction.Pair, α, h_1, α, s_1, Stream'.Seq, GeneralizedContinuedFraction.Pair, α, a, h, h_1, s, s_1, left, h, h_1, right, s, s_1, h_2, h_1, h, h_3, α, h, h] (during elaboration)

{α : Type u_1} [CommSemiring α] (E : LinearRecurrence α) {u : (a : ℕ) → α} {v : (a : ℕ) → α} (hu : u ∈ {u : (a : ℕ) → α | LinearRecurrence.IsSolution E u}) (hv : v ∈ {u : (a : ℕ) → α | LinearRecurrence.IsSolution E u}) (n : ℕ)  : u n + LinearRecurrence.order E = Finset.sum Finset.univ fun (i : Fin LinearRecurrence.order E) ↦ LinearRecurrence.coeffs E i * u n + ↑ i
application type mismatch
  Fin LinearRecurrence.order
argument
  LinearRecurrence.order
has type
  LinearRecurrence ?m.726 → ℕ : Type ?u.725
but is expected to have type
  ℕ : Type ; identifiers [α, u_1, CommSemiring, α, E, LinearRecurrence, α, u, a, α, v, a, α, hu, u, u, a, α, LinearRecurrence.IsSolution, E, u, hv, v, u, a, α, LinearRecurrence.IsSolution, E, u, n, u, n, LinearRecurrence.order, E, Finset.sum, Finset.univ, i, Fin, LinearRecurrence.order, E, LinearRecurrence.coeffs, E, i, u, n, i] (during elaboration)

{α : Type u_1} [CommSemiring α] (E : LinearRecurrence α) {u : (a : ℕ) → α} {v : (a : ℕ) → α} (hu : u ∈ {u : (a : ℕ) → α | LinearRecurrence.IsSolution E u}) (hv : v ∈ {u : (a : ℕ) → α | LinearRecurrence.IsSolution E u}) (n : ℕ)  : v n + LinearRecurrence.order E = Finset.sum Finset.univ fun (i : Fin LinearRecurrence.order E) ↦ LinearRecurrence.coeffs E i * v n + ↑ i
application type mismatch
  Fin LinearRecurrence.order
argument
  LinearRecurrence.order
has type
  LinearRecurrence ?m.726 → ℕ : Type ?u.725
but is expected to have type
  ℕ : Type ; identifiers [α, u_1, CommSemiring, α, E, LinearRecurrence, α, u, a, α, v, a, α, hu, u, u, a, α, LinearRecurrence.IsSolution, E, u, hv, v, u, a, α, LinearRecurrence.IsSolution, E, u, n, v, n, LinearRecurrence.order, E, Finset.sum, Finset.univ, i, Fin, LinearRecurrence.order, E, LinearRecurrence.coeffs, E, i, v, n, i] (during elaboration)

{G : Type u_1} [Group G] (h : Subsingleton Subgroup G) (x : G) (y : G) (this : ∀ (i : G) , i = 1)  : x = 1
application type mismatch
  Subsingleton Subgroup
argument
  Subgroup
has type
  (G : Type ?u.11) → [inst : Group G] → Type ?u.11 : Type (?u.11 + 1)
but is expected to have type
  Sort ?u.10 : Type ?u.10 ; identifiers [G, u_1, Group, G, h, Subsingleton, Subgroup, G, x, G, y, G, this, i, G, i, x] (during elaboration)

{G : Type u_1} [Group G] (h : Subsingleton Subgroup G) (x : G) (y : G) (this : ∀ (i : G) , i = 1)  : y = 1
application type mismatch
  Subsingleton Subgroup
argument
  Subgroup
has type
  (G : Type ?u.11) → [inst : Group G] → Type ?u.11 : Type (?u.11 + 1)
but is expected to have type
  Sort ?u.10 : Type ?u.10 ; identifiers [G, u_1, Group, G, h, Subsingleton, Subgroup, G, x, G, y, G, this, i, G, i, y] (during elaboration)

(R : Type u_1) [inst : CommRing R] (n : ℕ) (ν : ℕ) (h : ν ≤ n) (h' : ν < n) {α : Type u_1} {β : Type u_1} {γ : outParam Type u_1} [HMul α β γ] (a : α) (a_1 : α) (e_a : a = a_1) (a_2 : β) (a_3 : β) (e_a : a_2 = a_3)  : a * a_2 = a * a_2
function expected at
  outParam Type
term has type
  Type 1 ; identifiers [R, u_1, inst, CommRing, R, n, ν, h, ν, n, h', ν, n, α, u_1, β, u_1, γ, outParam, u_1, HMul, α, β, γ, a, α, a_1, α, e_a, a, a_1, a_2, β, a_3, β, e_a, a_2, a_3, a, a_2, a, a_2] (during elaboration)

(R : Type u_1) [inst : CommRing R] (n : ℕ) (ν : ℕ) (h : ν ≤ n) (h' : ν < n)  : - 1 ^ n - ν = - 1 ^ n - ν
failed to synthesize instance
  Neg ℕ ; identifiers [R, u_1, inst, CommRing, R, n, ν, h, ν, n, h', ν, n, n, ν, n, ν] (during elaboration)

{α : Type u} {β : Type v} (as : List α) (bs : List β) (head : α) (tail : List α) (tail_ih : ∀ (bs : List β) , List.zipRight tail bs = Prod.fst List.zipRight' tail bs) (bs : List β) (head_1 : β) (tail_1 : List β) (h : bs = head_1 :: tail_1)  : ∀ (bs : List β) , List.zipRight tail bs = Prod.fst List.zipRight' tail bs
function expected at
  ?m.185.fst
term has type
  ?m.39 ; identifiers [α, u, β, v, as, List, α, bs, List, β, head, α, tail, List, α, tail_ih, bs, List, β, List.zipRight, tail, bs, Prod.fst, List.zipRight', tail, bs, bs, List, β, head_1, β, tail_1, List, β, h, bs, head_1, tail_1, bs, List, β, List.zipRight, tail, bs, Prod.fst, List.zipRight', tail, bs] (during elaboration)

{α : Type u} {β : Type v} (as : List α) (bs : List β) (head : α) (tail : List α) (tail_ih : ∀ (bs : List β) , List.zipRight tail bs = Prod.fst List.zipRight' tail bs) (bs : List β)  : bs = bs
function expected at
  ?m.185.fst
term has type
  ?m.39 ; identifiers [α, u, β, v, as, List, α, bs, List, β, head, α, tail, List, α, tail_ih, bs, List, β, List.zipRight, tail, bs, Prod.fst, List.zipRight', tail, bs, bs, List, β, bs, bs] (during elaboration)

{R : Type u_2} {M : Type u_1} {M' : Type u_3} [Ring R] [AddCommGroup M] [AddCommGroup M'] [Module R M] [Module R M'] {s : Set M} {f : M →ₗ[R] M'} (hs : LinearIndependent R fun (x : ↑ s) ↦ ↑ x) (hf_inj : Disjoint Submodule.span R s LinearMap.ker f)  : ∀ (a : M) (a_1 : a ∈ Set.range fun (x : ↑ s) ↦ ↑ x) , ↑ f a = ↑ f a
type mismatch
  s
has type
  Set M : Type u_1
but is expected to have type
  Sort ?u.3401 : Type ?u.3401 ; identifiers [R, u_2, M, u_1, M', u_3, Ring, R, AddCommGroup, M, AddCommGroup, M', Module, R, M, Module, R, M', s, Set, M, f, M, R, M', hs, LinearIndependent, R, x, s, x, hf_inj, Disjoint, Submodule.span, R, s, LinearMap.ker, f, a, M, a_1, a, Set.range, x, s, x, f, a, f, a] (during elaboration)

{α : Type u_1} (h : α) (s : Stream'.Seq GeneralizedContinuedFraction.Pair α) (h_1 : α) (s_1 : Stream'.Seq GeneralizedContinuedFraction.Pair α) (a : (h = h_1 : Prop) ∧ (s = s_1 : Prop)) (left : h = h_1) (right : s = s_1) (h_2 : h_1 = h) (left : h = h) (h_3 : HEq left (Eq.refl h =: h = h)) (h_4 : s_1 = s) (s_2 : Stream'.Seq GeneralizedContinuedFraction.Pair α)  : s = s
<input>:1:279: expected term

{R : Type u_2} {M : Type u_1} {M' : Type u_3} [Ring R] [AddCommGroup M] [AddCommGroup M'] [Module R M] [Module R M'] {s : Set M} {f : M →ₗ[R] M'} (hs : LinearIndependent R fun (x : ↑ s) ↦ ↑ x) (hf_inj : Disjoint Submodule.span R s LinearMap.ker f)  : ∀ (a : M) (a_1 : a ∈ s) , ↑ f a = ↑ f a
type mismatch
  s
has type
  Set M : Type u_1
but is expected to have type
  Sort ?u.3401 : Type ?u.3401 ; identifiers [R, u_2, M, u_1, M', u_3, Ring, R, AddCommGroup, M, AddCommGroup, M', Module, R, M, Module, R, M', s, Set, M, f, M, R, M', hs, LinearIndependent, R, x, s, x, hf_inj, Disjoint, Submodule.span, R, s, LinearMap.ker, f, a, M, a_1, a, s, f, a, f, a] (during elaboration)

{ι : Type u_2} {M : Type u_1} [Monoid M] [Preorder M] [CovariantClass M M fun (x : M) (x_1 : M) ↦ x * x_1 fun (x : M) (x_1 : M) ↦ x < x_1] [CovariantClass M M fun (x : M) (x_1 : M) ↦ x * x_1 fun (x : M) (x_1 : M) ↦ x ≤ x_1] [CovariantClass M M Function.swap fun (x : M) (x_1 : M) ↦ x * x_1 fun (x : M) (x_1 : M) ↦ x < x_1] [CovariantClass M M Function.swap fun (x : M) (x_1 : M) ↦ x * x_1 fun (x : M) (x_1 : M) ↦ x ≤ x_1] {l : List ι} (f : (a : ι) → M) (g : (a : ι) → M) (h₁ : ∀ (i : ι) (a : i ∈ l) , f i ≤ g i) (h₂ : ∃ (i : ι) , (i ∈ l : Prop) ∧ (f i < g i : Prop)) (h₁ : ∀ (i : ι) (a : i ∈ []) , f i ≤ g i) (h₂ : ∃ (i : ι) , (i ∈ [] : Prop) ∧ (f i < g i : Prop)) (w : ι) (h : (w ∈ [] : Prop) ∧ (f w < g w : Prop)) (left : w ∈ []) (right : f w < g w)  : [] = []
function expected at
  x_1
term has type
  M ; identifiers [ι, u_2, M, u_1, Monoid, M, Preorder, M, CovariantClass, M, M, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, CovariantClass, M, M, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, CovariantClass, M, M, Function.swap, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, CovariantClass, M, M, Function.swap, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, l, List, ι, f, a, ι, M, g, a, ι, M, h₁, i, ι, a, i, l, f, i, g, i, h₂, i, ι, i, l, f, i, g, i, h₁, i, ι, a, i, f, i, g, i, h₂, i, ι, i, f, i, g, i, w, ι, h, w, f, w, g, w, left, w, right, f, w, g, w] (during elaboration)

{α : Type u_1} (h : α) (s : Stream'.Seq GeneralizedContinuedFraction.Pair α) (h_1 : α) (s_1 : Stream'.Seq GeneralizedContinuedFraction.Pair α) (a : (h = h_1 : Prop) ∧ (s = s_1 : Prop)) (left : h = h_1) (right : s = s_1) (h_2 : h_1 = h) (left : h = h) (h_3 : HEq left (Eq.refl h =: h = h)) (h_4 : s_1 = s) (right : s = s) (h_5 : HEq right (Eq.refl s =: s = s))  : {h := ((h)) , s := ((s))} = {h := ((h)) , s := ((s))}
<input>:1:279: expected term

{α : Type u_1} (h : α) (s : Stream'.Seq GeneralizedContinuedFraction.Pair α) (h_1 : α) (s_1 : Stream'.Seq GeneralizedContinuedFraction.Pair α) (a : (h = h_1 : Prop) ∧ (s = s_1 : Prop)) (left : h = h_1) (right : s = s_1) (h_2 : h_1 = h) (left : h = h) (h_3 : HEq left (Eq.refl h =: h = h)) (h_4 : s_1 = s)  : s = s_1
<input>:1:279: expected term

{α : Type u_1} (h : α) (s : Stream'.Seq GeneralizedContinuedFraction.Pair α) (h_1 : α) (s_1 : Stream'.Seq GeneralizedContinuedFraction.Pair α) (a : (h = h_1 : Prop) ∧ (s = s_1 : Prop)) (left : h = h_1) (right : s = s_1) (h_2 : h_1 = h) (left : h = h) (h_3 : HEq left (Eq.refl h =: h = h))  : s_1 = s_1
<input>:1:279: expected term

{α : Type u_1} (h : α) (s : Stream'.Seq GeneralizedContinuedFraction.Pair α) (h_1 : α) (s_1 : Stream'.Seq GeneralizedContinuedFraction.Pair α) (a : (h = h_1 : Prop) ∧ (s = s_1 : Prop)) (left : h = h_1) (right : s = s_1) (h_2 : h_1 = h)  : h = h_1
application type mismatch
  Stream'.Seq GeneralizedContinuedFraction.Pair
argument
  GeneralizedContinuedFraction.Pair
has type
  Type ?u.10 → Type ?u.10 : Type (?u.10 + 1)
but is expected to have type
  Type ?u.9 : Type (?u.9 + 1) ; identifiers [α, u_1, h, α, s, Stream'.Seq, GeneralizedContinuedFraction.Pair, α, h_1, α, s_1, Stream'.Seq, GeneralizedContinuedFraction.Pair, α, a, h, h_1, s, s_1, left, h, h_1, right, s, s_1, h_2, h_1, h, h, h_1] (during elaboration)

{α : Type u_1} (h : α) (s : Stream'.Seq GeneralizedContinuedFraction.Pair α) (h_1 : α) (s_1 : Stream'.Seq GeneralizedContinuedFraction.Pair α) (a : (h = h_1 : Prop) ∧ (s = s_1 : Prop)) (left : h = h_1) (right : s = s_1)  : h_1 = h_1
application type mismatch
  Stream'.Seq GeneralizedContinuedFraction.Pair
argument
  GeneralizedContinuedFraction.Pair
has type
  Type ?u.10 → Type ?u.10 : Type (?u.10 + 1)
but is expected to have type
  Type ?u.9 : Type (?u.9 + 1) ; identifiers [α, u_1, h, α, s, Stream'.Seq, GeneralizedContinuedFraction.Pair, α, h_1, α, s_1, Stream'.Seq, GeneralizedContinuedFraction.Pair, α, a, h, h_1, s, s_1, left, h, h_1, right, s, s_1, h_1, h_1] (during elaboration)

{m : (a : Type u_1) → Type u_2} {α : Type u_1} {α_1 : Type u_1} {p : (a : α_1) → Prop} {f : (a : α) → α_1} [Functor m] [LawfulFunctor m] {x : m α} (hx : SatisfiesM fun (a : α) ↦ p f a x)  : ∀ {a : α} (h : p f a) , p f a
application type mismatch
  p f
argument
  f
has type
  α → α_1 : Type u_1
but is expected to have type
  α_1 : Type u_1 ; identifiers [m, a, u_1, u_2, α, u_1, α_1, u_1, p, a, α_1, f, a, α, α_1, Functor, m, LawfulFunctor, m, x, m, α, hx, SatisfiesM, a, α, p, f, a, x, a, α, h, p, f, a, p, f, a] (during elaboration)

 : (∀ {n : ℕ} {m : ℕ} (eq : n = m) {a : Fin n} {b : Fin n} , (↑ {toFun := ((Fin.castLE (Eq.le eq =: n ≤ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n))) , left_inv := (((fun (x : Fin n) ↦ (_ : Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = x) =: ∀ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = x))) , right_inv := (((fun (x : Fin m) ↦ (_ : Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = x) =: ∀ (x : Fin m) , Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = x)))} a ≤ ↑ {toFun := ((Fin.castLE (Eq.le eq =: n ≤ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n))) , left_inv := (((fun (x : Fin n) ↦ (_ : Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = x) =: ∀ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = x))) , right_inv := (((fun (x : Fin m) ↦ (_ : Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = x) =: ∀ (x : Fin m) , Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = x)))} b : Prop) ↔ (↑ {toFun := ((Fin.castLE (Eq.le eq =: n ≤ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n))) , left_inv := (((fun (x : Fin n) ↦ (_ : Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = x) =: ∀ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = x))) , right_inv := (((fun (x : Fin m) ↦ (_ : Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = x) =: ∀ (x : Fin m) , Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = x)))} a ≤ ↑ {toFun := ((Fin.castLE (Eq.le eq =: n ≤ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n))) , left_inv := (((fun (x : Fin n) ↦ (_ : Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = x) =: ∀ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = x))) , right_inv := (((fun (x : Fin m) ↦ (_ : Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = x) =: ∀ (x : Fin m) , Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = x)))} b : Prop))
<input>:1:98: expected term

 : ∀ {n : ℕ} {m : ℕ} (eq : n = m) {a : Fin n} {b : Fin n} , (↑ {toFun := ((Fin.castLE (Eq.le eq =: n ≤ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n))) , left_inv := (((fun (x : Fin n) ↦ Fin.eq_of_veq (rfl =: ↑ Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = ↑ Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x) =: ∀ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = x))) , right_inv := (((fun (x : Fin m) ↦ Fin.eq_of_veq (rfl =: ↑ Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = ↑ Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x) =: ∀ (x : Fin m) , Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = x)))} a ≤ ↑ {toFun := ((Fin.castLE (Eq.le eq =: n ≤ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n))) , left_inv := (((fun (x : Fin n) ↦ Fin.eq_of_veq (rfl =: ↑ Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = ↑ Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x) =: ∀ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = x))) , right_inv := (((fun (x : Fin m) ↦ Fin.eq_of_veq (rfl =: ↑ Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = ↑ Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x) =: ∀ (x : Fin m) , Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = x)))} b) ↔ (↑ {toFun := ((Fin.castLE (Eq.le eq =: n ≤ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n))) , left_inv := (((fun (x : Fin n) ↦ Fin.eq_of_veq (rfl =: ↑ Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = ↑ Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x) =: ∀ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = x))) , right_inv := (((fun (x : Fin m) ↦ Fin.eq_of_veq (rfl =: ↑ Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = ↑ Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x) =: ∀ (x : Fin m) , Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = x)))} a ≤ ↑ {toFun := ((Fin.castLE (Eq.le eq =: n ≤ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n))) , left_inv := (((fun (x : Fin n) ↦ Fin.eq_of_veq (rfl =: ↑ Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = ↑ Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x) =: ∀ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) Fin.castLE (Eq.le eq =: n ≤ m) x = x))) , right_inv := (((fun (x : Fin m) ↦ Fin.eq_of_veq (rfl =: ↑ Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = ↑ Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x) =: ∀ (x : Fin m) , Fin.castLE (Eq.le eq =: n ≤ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ≤ n) x = x)))} b)
<input>:1:97: expected term

{α : Type u_1} {s : Set α} (motive : (hs : Set.Nonempty s) → Prop) (hs : Set.Nonempty s) (h_1 : ∀ (a : α) (ha : a ∈ s) , motive (Exists.intro a ha =: ∃ (x : α) , x ∈ s))  : ∀ (w : α) (h : w ∈ s) , motive Exists.intro w h
<input>:1:148: expected term

{M : Type u_1} {N : Type u_2} {α : Type u_3} [VAdd M α] [VAdd N α] [VAdd N ᵃᵒᵖ α] [IsCentralVAdd N α] [VAddCommClass M N α] (m : M) (n : N ᵃᵒᵖ) (a : α)  : (m +ᵥ n +ᵥ a = n +ᵥ m +ᵥ a) = (m +ᵥ n +ᵥ a = n +ᵥ m +ᵥ a)
failed to synthesize instance
  HVAdd M Nᵃᵒᵖ ?m.93 ; identifiers [M, u_1, N, u_2, α, u_3, VAdd, M, α, VAdd, N, α, VAdd, N, α, IsCentralVAdd, N, α, VAddCommClass, M, N, α, m, M, n, N, a, α, m, n, a, n, m, a, m, n, a, n, m, a] (during elaboration)

{α : Type u} {xs : List α} (head : α) (tail : List α) (tail_ih : ↑ FreeMonoid.toList List.traverse Functor.Const.mk' ∘ FreeMonoid.of tail = tail) {α : Type u} (a : α) (a_1 : α) (e_a : a = a_1) (a_2 : α) (a_3 : α) (e_a : a_2 = a_3)  : (a = a_2) = (a = a_2)
type mismatch
  tail
has type
  List α : Type u
but is expected to have type
  ?m.555482 head tail → ?m.555483 head tail : Sort (imax ?u.20 ?u.18) ; identifiers [α, u, xs, List, α, head, α, tail, List, α, tail_ih, FreeMonoid.toList, List.traverse, Functor.Const.mk', FreeMonoid.of, tail, tail, α, u, a, α, a_1, α, e_a, a, a_1, a_2, α, a_3, α, e_a, a_2, a_3, a, a_2, a, a_2] (during elaboration)

{α : Type u} {f : (a : α) → α} {g : (a : ℕ) → (a : α) → α} (H : ∀ (n : ℕ) , Function.Semiconj f g n g n + 1) (n : ℕ) (k : ℕ) (n : ℕ) (ihn : ∀ (k : ℕ) , Function.Semiconj f ^[n] g k g n + k) (k : ℕ)  : Function.Semiconj f g k g k + 1
application type mismatch
  Function.Semiconj f g
argument
  g
has type
  ℕ → α → α : Type u
but is expected to have type
  α → α : Type u ; identifiers [α, u, f, a, α, α, g, a, a, α, α, H, n, Function.Semiconj, f, g, n, g, n, n, k, n, ihn, k, Function.Semiconj, f, n, g, k, g, n, k, k, Function.Semiconj, f, g, k, g, k] (during elaboration)

{α : Type u} {xs : List α} (head : α) (tail : List α) (tail_ih : ↑ FreeMonoid.toList List.traverse Functor.Const.mk' ∘ FreeMonoid.of tail = tail)  : tail = ↑ FreeMonoid.toList List.traverse Functor.Const.mk' ∘ FreeMonoid.of tail
type mismatch
  ?m.555443 ∘ ?m.634540
has type
  ?m.555437 → ?m.555439 : Sort (imax ?u.555436 ?u.555434)
but is expected to have type
  List α : Type u ; identifiers [α, u, xs, List, α, head, α, tail, List, α, tail_ih, FreeMonoid.toList, List.traverse, Functor.Const.mk', FreeMonoid.of, tail, tail, tail, FreeMonoid.toList, List.traverse, Functor.Const.mk', FreeMonoid.of, tail] (during elaboration)

{α : Type u} {xs : List α} (head : α) (tail : List α) (tail_ih : ↑ FreeMonoid.toList List.traverse Functor.Const.mk' ∘ FreeMonoid.of tail = tail)  : head :: tail = head :: tail
type mismatch
  tail
has type
  List α : Type u
but is expected to have type
  ?m.555457 head tail → ?m.555458 head tail : Sort (imax ?u.20 ?u.18) ; identifiers [α, u, xs, List, α, head, α, tail, List, α, tail_ih, FreeMonoid.toList, List.traverse, Functor.Const.mk', FreeMonoid.of, tail, tail, head, tail, head, tail] (during elaboration)

 : (∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] {s : optParam Set M Set.univ} (self : SmoothBumpCovering ι I M s) , LocallyFinite fun (i : ι) ↦ Function.support ↑ SmoothBumpCovering.toFun s self i)
unknown universe level 'uι' ; identifiers [ι, uι, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, s, optParam, Set, M, Set.univ, self, SmoothBumpCovering, ι, I, M, s, LocallyFinite, i, ι, Function.support, SmoothBumpCovering.toFun, s, self, i] (during elaboration)

 : ∀ (ι : Type uι) (E : Type uE) [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] (H : Type uH) [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) (M : Type uM) [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] (s : optParam Set M Set.univ) (self : SmoothBumpCovering ι I M s) , LocallyFinite fun (i : ι) ↦ Function.support ↑ self . 2 i
unknown universe level 'uι' ; identifiers [ι, uι, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, s, optParam, Set, M, Set.univ, self, SmoothBumpCovering, ι, I, M, s, LocallyFinite, i, ι, Function.support, self, i] (during elaboration)

{b : Ordinal .{u_1}} {o : Ordinal .{u_1}} (hb : 1 < b) (ho : o ≠ 0) (hbo : b ≤ o)  : (b ^ 1 ≤ o) = (b ^ 1 ≤ o)
<input>:1:13: expected '//', '|' or '}'

{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] {b : K} (nth_part_denom_eq : Stream'.Seq.get? GeneralizedContinuedFraction.partialDenominators GeneralizedContinuedFraction.of v n = some b) (not_terminated_at_n : ¬ (GeneralizedContinuedFraction.TerminatedAt GeneralizedContinuedFraction.of v n : Prop)) (hB : 0 < GeneralizedContinuedFraction.denominators GeneralizedContinuedFraction.of v n) {α : Type u_1} [LE α] (a : α) (a_1 : α) (e_a : a = a_1) (a_2 : α) (a_3 : α) (e_a : a_2 = a_3)  : (a ≤ a_2) = (a ≤ a_2)
application type mismatch
  Stream'.Seq.get? ?m.79761 GeneralizedContinuedFraction.of
argument
  GeneralizedContinuedFraction.of
has type
  ?m.79763 → GeneralizedContinuedFraction ?m.79763 : Type ?u.79762
but is expected to have type
  ℕ : Type ; identifiers [K, u_1, v, K, n, LinearOrderedField, K, FloorRing, K, b, K, nth_part_denom_eq, Stream'.Seq.get?, GeneralizedContinuedFraction.partialDenominators, GeneralizedContinuedFraction.of, v, n, some, b, not_terminated_at_n, GeneralizedContinuedFraction.TerminatedAt, GeneralizedContinuedFraction.of, v, n, hB, GeneralizedContinuedFraction.denominators, GeneralizedContinuedFraction.of, v, n, α, u_1, LE, α, a, α, a_1, α, e_a, a, a_1, a_2, α, a_3, α, e_a, a_2, a_3, a, a_2, a, a_2] (during elaboration)

{R : Type u_1} [Semiring R] (n : ℕ)  : if (n = 1) then 1 else 0 = if (n = 1) then 1 else 0
failed to synthesize instance
  OfNat (Sort ?u.11) 1 ; identifiers [R, u_1, Semiring, R, n, n, n] (during elaboration)

{M : Type u_1} [Monoid M] (S : Submonoid M) {ι : Type u_2} (t : Finset ι) (f : (a : ι) → M) (comm : Set.Pairwise ↑ t fun (a : ι) (b : ι) ↦ Commute f a f b) (h : ∀ (c : ι) (a : c ∈ t) , f c ∈ S) (y : M) (a : ∃ (a : ι) , (a ∈ Finset.val t : Prop) ∧ (f a = y : Prop)) (x : ι) (h_1 : (x ∈ Finset.val t : Prop) ∧ (f x = y : Prop)) (hx : x ∈ Finset.val t) (right : f x = y)  : f x ∈ S
application type mismatch
  Commute f a
argument
  a
has type
  ι : Type u_2
but is expected to have type
  ι → M : Type (max u_1 u_2) ; identifiers [M, u_1, Monoid, M, S, Submonoid, M, ι, u_2, t, Finset, ι, f, a, ι, M, comm, Set.Pairwise, t, a, ι, b, ι, Commute, f, a, f, b, h, c, ι, a, c, t, f, c, S, y, M, a, a, ι, a, Finset.val, t, f, a, y, x, ι, h_1, x, Finset.val, t, f, x, y, hx, x, Finset.val, t, right, f, x, y, f, x, S] (during elaboration)

{𝕜 : Type u_1} {E : Type u_2} [NontriviallyNormedField 𝕜] [NormedAddCommGroup E] [NormedSpace 𝕜 E] {f : (a : 𝕜) → E} {a : 𝕜} {s : Set 𝕜} (h : ContinuousOn dslope f a s) (x : 𝕜) (hx : x ∈ s)  : ContinuousWithinAt dslope f a s x
function expected at
  ContinuousOn dslope ?m.620
term has type
  Prop ; identifiers [𝕜, u_1, E, u_2, NontriviallyNormedField, 𝕜, NormedAddCommGroup, E, NormedSpace, 𝕜, E, f, a, 𝕜, E, a, 𝕜, s, Set, 𝕜, h, ContinuousOn, dslope, f, a, s, x, 𝕜, hx, x, s, ContinuousWithinAt, dslope, f, a, s, x] (during elaboration)

{ι : Type u_2} {M : Type u_1} [Monoid M] [Preorder M] [CovariantClass M M fun (x : M) (x_1 : M) ↦ x * x_1 fun (x : M) (x_1 : M) ↦ x < x_1] [CovariantClass M M fun (x : M) (x_1 : M) ↦ x * x_1 fun (x : M) (x_1 : M) ↦ x ≤ x_1] [CovariantClass M M Function.swap fun (x : M) (x_1 : M) ↦ x * x_1 fun (x : M) (x_1 : M) ↦ x < x_1] [CovariantClass M M Function.swap fun (x : M) (x_1 : M) ↦ x * x_1 fun (x : M) (x_1 : M) ↦ x ≤ x_1] {l : List ι} (f : (a : ι) → M) (g : (a : ι) → M) (h₁ : ∀ (i : ι) (a : i ∈ l) , f i ≤ g i) (h₂ : ∃ (i : ι) , (i ∈ l : Prop) ∧ (f i < g i : Prop)) (i : ι) (l : List ι) (ihl : ∀ (h₁ : ∀ (i : ι) (a : i ∈ l) , f i ≤ g i) (h₂ : ∃ (i : ι) , (i ∈ l : Prop) ∧ (f i < g i : Prop)) , List.prod List.map f l < List.prod List.map g l) (h₁ : ∀ (i_1 : ι) (a : i_1 ∈ i :: l) , f i_1 ≤ g i_1) (h₂ : ∃ (i_1 : ι) , (i_1 ∈ i :: l : Prop) ∧ (f i_1 < g i_1 : Prop)) (h : f i < g i) (h_1 : (Eq.mp (Mathlib.Data.List.BigOperators.Basic._auxLemma.3 =: (∃ (x : ι) , (x ∈ i :: l : Prop) ∧ (f x < g x : Prop) : Prop) = ((f i < g i : Prop) ∨ (∃ (x : ι) , (x ∈ l : Prop) ∧ (f x < g x : Prop) : Prop) : Prop)) h₂ =: (f i < g i : Prop) ∨ (∃ (x : ι) , (x ∈ l : Prop) ∧ (f x < g x : Prop) : Prop)) = (Or.inl h =: (f i < g i : Prop) ∨ (∃ (x : ι) , (x ∈ l : Prop) ∧ (f x < g x : Prop) : Prop)))  : Or.inl h = Eq.mp Mathlib.Data.List.BigOperators.Basic._auxLemma.3 h₂
<input>:1:947: expected term

{o : Type u_5} {m' : (a : o) → Type u_1} {n' : (a : o) → Type u_2} {α : Type u_3} {β : Type u_4} [DecidableEq o] [Zero α] [Zero β] (M : (i : o) → Matrix m' i n' i α) (f : (a : α) → β) (hf : f 0 = 0) (i : (i : o) × m' i) (x : (i : o) × n' i)  : ∀ (h : ¬ (Sigma.fst i = Sigma.fst x)) , 0 = 0
application type mismatch
  Matrix m'
argument
  m'
has type
  o → Type u_1 : Type (max (u_1 + 1) u_5)
but is expected to have type
  Type ?u.47 : Type (?u.47 + 1) ; identifiers [o, u_5, m', a, o, u_1, n', a, o, u_2, α, u_3, β, u_4, DecidableEq, o, Zero, α, Zero, β, M, i, o, Matrix, m', i, n', i, α, f, a, α, β, hf, f, i, i, o, m', i, x, i, o, n', i, h, Sigma.fst, i, Sigma.fst, x] (during elaboration)

{α : Type u} {C : (a : FreeGroup α) → Prop} (z : FreeGroup α) (C1 : C 1) (Cp : ∀ (x : α) , C pure x) (Ci : ∀ (x : α) (a : C pure x) , C pure x ⁻¹) (Cm : ∀ (x : FreeGroup α) (y : FreeGroup α) (a : C x) (a : C y) , C x * y) (L : List α × Bool) (x : α × Bool) (_tl : List α × Bool) (ih : C Quot.mk FreeGroup.Red.Step _tl) (x : α) (b : Bool)  : C pure x
application type mismatch
  C pure
argument
  pure
has type
  ?m.59 → ?m.57 ?m.59 : Type (max ?u.55 ?u.56)
but is expected to have type
  FreeGroup α : Type u ; identifiers [α, u, C, a, FreeGroup, α, z, FreeGroup, α, C1, C, Cp, x, α, C, pure, x, Ci, x, α, a, C, pure, x, C, pure, x, Cm, x, FreeGroup, α, y, FreeGroup, α, a, C, x, a, C, y, C, x, y, L, List, α, Bool, x, α, Bool, _tl, List, α, Bool, ih, C, Quot.mk, FreeGroup.Red.Step, _tl, x, α, b, Bool, C, pure, x] (during elaboration)

{v : Sat.Valuation} {l : Sat.Literal} {a : Prop} {c : Sat.Clause} {b : Prop} (h₁ : Sat.Literal.reify v l (a : Prop)) (h₂ : Sat.Clause.reify v c (b : Prop)) (H : ¬ (Sat.Valuation.satisfies v Sat.Clause.cons l c : Prop)) (h : Sat.Valuation.satisfies v c)  : ∀ (x : Sat.Valuation.neg v l) , Sat.Valuation.satisfies v c
application type mismatch
  Sat.Valuation.satisfies v Sat.Clause.cons
argument
  Sat.Clause.cons
has type
  Sat.Literal → Sat.Clause → Sat.Clause : Type
but is expected to have type
  Sat.Clause : Type ; identifiers [v, Sat.Valuation, l, Sat.Literal, a, c, Sat.Clause, b, h₁, Sat.Literal.reify, v, l, a, h₂, Sat.Clause.reify, v, c, b, H, Sat.Valuation.satisfies, v, Sat.Clause.cons, l, c, h, Sat.Valuation.satisfies, v, c, x, Sat.Valuation.neg, v, l, Sat.Valuation.satisfies, v, c] (during elaboration)

(x : WType WType.Natβ) (x : WType WType.Natβ) (f : WType.ibelow x) (f : (a : WType.Natβ WType.Natα.zero) → WType WType.Natβ) (x : WType.ibelow WType.mk WType.Natα.zero f) (x : Empty)  : x = x
function expected at
  WType.ibelow ?m.80340
term has type
  Prop ; identifiers [x, WType, WType.Natβ, x, WType, WType.Natβ, f, WType.ibelow, x, f, a, WType.Natβ, WType.Natα.zero, WType, WType.Natβ, x, WType.ibelow, WType.mk, WType.Natα.zero, f, x, Empty, x, x] (during elaboration)

{ι : Type u_2} {M : Type u_1} [Monoid M] [Preorder M] [CovariantClass M M fun (x : M) (x_1 : M) ↦ x * x_1 fun (x : M) (x_1 : M) ↦ x < x_1] [CovariantClass M M fun (x : M) (x_1 : M) ↦ x * x_1 fun (x : M) (x_1 : M) ↦ x ≤ x_1] [CovariantClass M M Function.swap fun (x : M) (x_1 : M) ↦ x * x_1 fun (x : M) (x_1 : M) ↦ x < x_1] [CovariantClass M M Function.swap fun (x : M) (x_1 : M) ↦ x * x_1 fun (x : M) (x_1 : M) ↦ x ≤ x_1] {l : List ι} (f : (a : ι) → M) (g : (a : ι) → M) (h₁ : ∀ (i : ι) (a : i ∈ l) , f i ≤ g i) (h₂ : ∃ (i : ι) , (i ∈ l : Prop) ∧ (f i < g i : Prop)) (i : ι) (l : List ι) (ihl : ∀ (h₁ : ∀ (i : ι) (a : i ∈ l) , f i ≤ g i) (h₂ : ∃ (i : ι) , (i ∈ l : Prop) ∧ (f i < g i : Prop)) , List.prod List.map f l < List.prod List.map g l) (h₁ : ∀ (i_1 : ι) (a : i_1 ∈ i :: l) , f i_1 ≤ g i_1) (h₂ : ∃ (i_1 : ι) , (i_1 ∈ i :: l : Prop) ∧ (f i_1 < g i_1 : Prop)) (h : ∃ (x : ι) , (x ∈ l : Prop) ∧ (f x < g x : Prop)) (h_1 : (Eq.mp (Mathlib.Data.List.BigOperators.Basic._auxLemma.3 =: (∃ (x : ι) , (x ∈ i :: l : Prop) ∧ (f x < g x : Prop) : Prop) = ((f i < g i : Prop) ∨ (∃ (x : ι) , (x ∈ l : Prop) ∧ (f x < g x : Prop) : Prop) : Prop)) h₂ =: (f i < g i : Prop) ∨ (∃ (x : ι) , (x ∈ l : Prop) ∧ (f x < g x : Prop) : Prop)) = (Or.inr h =: (f i < g i : Prop) ∨ (∃ (x : ι) , (x ∈ l : Prop) ∧ (f x < g x : Prop) : Prop)))  : Or.inr h = Eq.mp Mathlib.Data.List.BigOperators.Basic._auxLemma.3 h₂
<input>:1:985: expected term

{α : Type u_1} [MeasurableSpace α] {p : (a : α) → Prop} [MeasurableSingletonClass α] (x : Subtype p)  : {x} = {x}
typeclass instance problem is stuck, it is often due to metavariables
  Singleton (Subtype p) (?m.343 x) ; identifiers [α, u_1, MeasurableSpace, α, p, a, α, MeasurableSingletonClass, α, x, Subtype, p, x, x, x, x] (during elaboration)

{o : Type u_5} {m' : (a : o) → Type u_1} {n' : (a : o) → Type u_2} {α : Type u_3} {β : Type u_4} [DecidableEq o] [Zero α] [Zero β] (M : (i : o) → Matrix m' i n' i α) (f : (a : α) → β) (hf : f 0 = 0) (i : (i : o) × m' i) (x : (i : o) × n' i) (h : Sigma.fst i = Sigma.fst x)  : Sigma.fst x = Sigma.fst i
application type mismatch
  Matrix m'
argument
  m'
has type
  o → Type u_1 : Type (max (u_1 + 1) u_5)
but is expected to have type
  Type ?u.47 : Type (?u.47 + 1) ; identifiers [o, u_5, m', a, o, u_1, n', a, o, u_2, α, u_3, β, u_4, DecidableEq, o, Zero, α, Zero, β, M, i, o, Matrix, m', i, n', i, α, f, a, α, β, hf, f, i, i, o, m', i, x, i, o, n', i, h, Sigma.fst, i, Sigma.fst, x, Sigma.fst, x, Sigma.fst, i] (during elaboration)

{C : Type u} [CategoryTheory.Category C] {F : CategoryTheory.Functor C ᵒᵖ Type w} (G : CategoryTheory.GrothendieckTopology.Subpresheaf F) (a : G = ⊤)  : ⊤ = G
function expected at
  CategoryTheory.Functor Cᵒᵖ Type
term has type
  Type (max ?u.7 u 1) ; identifiers [C, u, CategoryTheory.Category, C, F, CategoryTheory.Functor, C, w, G, CategoryTheory.GrothendieckTopology.Subpresheaf, F, a, G, G] (during elaboration)

{α : Type u} [inst : AddGroup α] [LT α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] {a : α} {b : α} {c : α} {α : Type u} [AddGroup α] [LT α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] {a : α} {b : α} {c : α}  : ((- b + a < c : Prop) ↔ (a < b + c : Prop)) = ((- b + a < c : Prop) ↔ (a < b + c : Prop))
function expected at
  x_1
term has type
  α ; identifiers [α, u, inst, AddGroup, α, LT, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, c, α, α, u, AddGroup, α, LT, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, c, α, b, a, c, a, b, c, b, a, c, a, b, c] (during elaboration)

{α : Type u} [inst : AddGroup α] [LT α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] {a : α} {b : α} {c : α} {α : Type u} [AddGroup α] [LT α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] {a : α} {b : α} {c : α}  : ((b + - b + a < b + c : Prop) ↔ (a < b + c : Prop)) = ((b + - b + a < b + c : Prop) ↔ (a < b + c : Prop))
function expected at
  x_1
term has type
  α ; identifiers [α, u, inst, AddGroup, α, LT, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, c, α, α, u, AddGroup, α, LT, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, c, α, b, b, a, b, c, a, b, c, b, b, a, b, c, a, b, c] (during elaboration)

{α : Type u} [inst : AddGroup α] [LT α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] {a : α} {b : α} {c : α} {α : Type u} [AddGroup α] [LT α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] {a : α} {b : α} {c : α}  : (a < b + c) ↔ (a < b + c)
function expected at
  x_1
term has type
  α ; identifiers [α, u, inst, AddGroup, α, LT, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, c, α, α, u, AddGroup, α, LT, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, c, α, a, b, c, a, b, c] (during elaboration)

{α : Type u_1} (motive : (x : List α) → (x : List α) → Prop) (x : List α) (x_1 : List α) (h_1 : ∀ (ys : List α) , motive [] ys) (h_2 : ∀ (xs : List α) , motive xs []) (h_3 : ∀ (x : α) (xs : List α) (y : α) (ys : List α) , motive x :: xs y :: ys) (head : α) (tail : List α)  : ∀ (head_1 : α) (tail_1 : List α) , motive head :: tail head_1 :: tail_1
application type mismatch
  motive x
argument
  x
has type
  α : Type u_1
but is expected to have type
  List α : Type u_1 ; identifiers [α, u_1, motive, x, List, α, x, List, α, x, List, α, x_1, List, α, h_1, ys, List, α, motive, ys, h_2, xs, List, α, motive, xs, h_3, x, α, xs, List, α, y, α, ys, List, α, motive, x, xs, y, ys, head, α, tail, List, α, head_1, α, tail_1, List, α, motive, head, tail, head_1, tail_1] (during elaboration)

{K : (a : Option Turing.PartrecToTM2.Γ') → Finset Turing.PartrecToTM2.Λ'} {S : Finset Turing.PartrecToTM2.Λ'} (q : Turing.PartrecToTM2.Λ')  : (∀ (h : ∃ (x : Option Turing.PartrecToTM2.Γ') , q ∈ K x) , Turing.TM2.SupportsStmt S Turing.PartrecToTM2.tr q) = (∀ (x : Option Turing.PartrecToTM2.Γ') (h : q ∈ K x) , Turing.TM2.SupportsStmt S Turing.PartrecToTM2.tr q)
function expected at
  Turing.TM2.SupportsStmt S ?m.79267
term has type
  Prop ; identifiers [K, a, Option, Turing.PartrecToTM2.Γ', Finset, Turing.PartrecToTM2.Λ', S, Finset, Turing.PartrecToTM2.Λ', q, Turing.PartrecToTM2.Λ', h, x, Option, Turing.PartrecToTM2.Γ', q, K, x, Turing.TM2.SupportsStmt, S, Turing.PartrecToTM2.tr, q, x, Option, Turing.PartrecToTM2.Γ', h, q, K, x, Turing.TM2.SupportsStmt, S, Turing.PartrecToTM2.tr, q] (during elaboration)

{a : ℝ} {b : ℝ} (hab : a < b) {l : Filter ℝ} {f : (a : ℝ) → ℝ} {g : (a : ℝ) → ℝ} (hdf : DifferentiableOn ℝ f Set.Ioo a b) (hcf : ContinuousOn f Set.Ico a b) (hcg : ContinuousOn g Set.Ico a b) (hg' : ∀ (x : ℝ) (a : x ∈ Set.Ioo a b) , deriv g x ≠ 0) (hfa : f a = 0) (hga : g a = 0) (hdiv : Filter.Tendsto fun (x : ℝ) ↦ deriv f x / deriv g x nhdsWithin a Set.Ioi a l)  : 0 = f a
application type mismatch
  DifferentiableOn ℝ f Set.Ioo
argument
  Set.Ioo
has type
  ?m.48 → ?m.48 → Set ?m.48 : Type ?u.47
but is expected to have type
  Set ℝ : Type ; identifiers [a, b, hab, a, b, l, Filter, f, a, g, a, hdf, DifferentiableOn, f, Set.Ioo, a, b, hcf, ContinuousOn, f, Set.Ico, a, b, hcg, ContinuousOn, g, Set.Ico, a, b, hg', x, a, x, Set.Ioo, a, b, deriv, g, x, hfa, f, a, hga, g, a, hdiv, Filter.Tendsto, x, deriv, f, x, deriv, g, x, nhdsWithin, a, Set.Ioi, a, l, f, a] (during elaboration)

 : (∀ {α : Type u_1} [inst : MetricSpace α] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} (self : VitaliFamily μ) (s : Set α) (f : (x : α) → Set Set α) (a : ∀ (x : α) (a : x ∈ s) , f x ⊆ VitaliFamily.setsAt self x) (a : ∀ (x : α) (a : x ∈ s) (ε : ℝ) (a : ε > 0) , ∃ (a : Set α) , (a ∈ f x : Prop) ∧ (a ⊆ Metric.closedBall x ε : Prop)) , ∃ (t : Set α × Set α) , (∀ (p : α × Set α) (a : p ∈ t) , Prod.fst p ∈ s : Prop) ∧ ((Set.PairwiseDisjoint t fun (p : α × Set α) ↦ Prod.snd p : Prop) ∧ ((∀ (p : α × Set α) (a : p ∈ t) , Prod.snd p ∈ f Prod.fst p : Prop) ∧ (↑ ↑ μ s \ ⋃ (p : α × Set α) (_ : p ∈ t) , Prod.snd p = 0 : Prop) : Prop) : Prop))
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.107 → Type ?u.107 : Type (?u.107 + 1)
but is expected to have type
  Type ?u.106 : Type (?u.106 + 1) ; identifiers [α, u_1, inst, MetricSpace, α, m, MeasurableSpace, α, μ, MeasureTheory.Measure, α, self, VitaliFamily, μ, s, Set, α, f, x, α, Set, Set, α, a, x, α, a, x, s, f, x, VitaliFamily.setsAt, self, x, a, x, α, a, x, s, ε, a, ε, a, Set, α, a, f, x, a, Metric.closedBall, x, ε, t, Set, α, Set, α, p, α, Set, α, a, p, t, Prod.fst, p, s, Set.PairwiseDisjoint, t, p, α, Set, α, Prod.snd, p, p, α, Set, α, a, p, t, Prod.snd, p, f, Prod.fst, p, μ, s, p, α, Set, α, p, t, Prod.snd, p] (during elaboration)

 : ∀ (α : Type u_1) [inst : MetricSpace α] (m : MeasurableSpace α) (μ : MeasureTheory.Measure α) (self : VitaliFamily μ) (s : Set α) (f : (x : α) → Set Set α) (a : ∀ (x : α) (a : x ∈ s) , f x ⊆ self . 1 x) (a : ∀ (x : α) (a : x ∈ s) (ε : ℝ) (a : ε > 0) , ∃ (a : Set α) , (a ∈ f x) ∧ (a ⊆ Metric.closedBall x ε)) , ∃ (t : Set α × Set α) , (∀ (p : α × Set α) (a : p ∈ t) , Prod.fst p ∈ s) ∧ ((Set.PairwiseDisjoint t fun (p : α × Set α) ↦ Prod.snd p : Prop) ∧ ((∀ (p : α × Set α) (a : p ∈ t) , Prod.snd p ∈ f Prod.fst p : Prop) ∧ (↑ ↑ μ s \ ⋃ (p : α × Set α) (_ : p ∈ t) , Prod.snd p = 0 : Prop) : Prop))
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.107 → Type ?u.107 : Type (?u.107 + 1)
but is expected to have type
  Type ?u.106 : Type (?u.106 + 1) ; identifiers [α, u_1, inst, MetricSpace, α, m, MeasurableSpace, α, μ, MeasureTheory.Measure, α, self, VitaliFamily, μ, s, Set, α, f, x, α, Set, Set, α, a, x, α, a, x, s, f, x, self, x, a, x, α, a, x, s, ε, a, ε, a, Set, α, a, f, x, a, Metric.closedBall, x, ε, t, Set, α, Set, α, p, α, Set, α, a, p, t, Prod.fst, p, s, Set.PairwiseDisjoint, t, p, α, Set, α, Prod.snd, p, p, α, Set, α, a, p, t, Prod.snd, p, f, Prod.fst, p, μ, s, p, α, Set, α, p, t, Prod.snd, p] (during elaboration)

{a : ℝ} {b : ℝ} (hab : a < b) {l : Filter ℝ} {f : (a : ℝ) → ℝ} {g : (a : ℝ) → ℝ} (hdf : DifferentiableOn ℝ f Set.Ioo a b) (hcf : ContinuousOn f Set.Ico a b) (hcg : ContinuousOn g Set.Ico a b) (hg' : ∀ (x : ℝ) (a : x ∈ Set.Ioo a b) , deriv g x ≠ 0) (hfa : f a = 0) (hga : g a = 0) (hdiv : Filter.Tendsto fun (x : ℝ) ↦ deriv f x / deriv g x nhdsWithin a Set.Ioi a l)  : 0 = g a
application type mismatch
  DifferentiableOn ℝ f Set.Ioo
argument
  Set.Ioo
has type
  ?m.48 → ?m.48 → Set ?m.48 : Type ?u.47
but is expected to have type
  Set ℝ : Type ; identifiers [a, b, hab, a, b, l, Filter, f, a, g, a, hdf, DifferentiableOn, f, Set.Ioo, a, b, hcf, ContinuousOn, f, Set.Ico, a, b, hcg, ContinuousOn, g, Set.Ico, a, b, hg', x, a, x, Set.Ioo, a, b, deriv, g, x, hfa, f, a, hga, g, a, hdiv, Filter.Tendsto, x, deriv, f, x, deriv, g, x, nhdsWithin, a, Set.Ioi, a, l, g, a] (during elaboration)

{R : Type u} {A : Type v} {B : Type w} {inst : Monoid R} {inst_1 : NonUnitalNonAssocSemiring A} {inst_2 : DistribMulAction R A} {inst_3 : NonUnitalNonAssocSemiring B} {inst_4 : DistribMulAction R B} {toDistribMulActionHom : A →+[R] B} {map_mul' : ∀ (x : A) (y : A) , MulActionHom.toFun DistribMulActionHom.toMulActionHom toDistribMulActionHom x * y = MulActionHom.toFun DistribMulActionHom.toMulActionHom toDistribMulActionHom x * MulActionHom.toFun DistribMulActionHom.toMulActionHom toDistribMulActionHom y} {toDistribMulActionHom_1 : A →+[R] B} {map_mul'_1 : ∀ (x : A) (y : A) , MulActionHom.toFun DistribMulActionHom.toMulActionHom toDistribMulActionHom_1 x * y = MulActionHom.toFun DistribMulActionHom.toMulActionHom toDistribMulActionHom_1 x * MulActionHom.toFun DistribMulActionHom.toMulActionHom toDistribMulActionHom_1 y} (x : {toDistribMulActionHom := ((toDistribMulActionHom)) , map_mul' := ((map_mul'))} = {toDistribMulActionHom := ((toDistribMulActionHom_1)) , map_mul' := ((map_mul'_1))})  : ∀ (toDistribMulActionHom_eq : toDistribMulActionHom = toDistribMulActionHom_1) , toDistribMulActionHom = toDistribMulActionHom_1
function expected at
  MulActionHom.toFun ?m.84462 toDistribMulActionHom
term has type
  ?m.82400 ; identifiers [R, u, A, v, B, w, inst, Monoid, R, inst_1, NonUnitalNonAssocSemiring, A, inst_2, DistribMulAction, R, A, inst_3, NonUnitalNonAssocSemiring, B, inst_4, DistribMulAction, R, B, toDistribMulActionHom, A, R, B, A, R, B, map_mul', x, A, y, A, MulActionHom.toFun, DistribMulActionHom.toMulActionHom, toDistribMulActionHom, x, y, MulActionHom.toFun, DistribMulActionHom.toMulActionHom, toDistribMulActionHom, x, MulActionHom.toFun, DistribMulActionHom.toMulActionHom, toDistribMulActionHom, y, toDistribMulActionHom_1, A, R, B, A, R, B, map_mul'_1, x, A, y, A, MulActionHom.toFun, DistribMulActionHom.toMulActionHom, toDistribMulActionHom_1, x, y, MulActionHom.toFun, DistribMulActionHom.toMulActionHom, toDistribMulActionHom_1, x, MulActionHom.toFun, DistribMulActionHom.toMulActionHom, toDistribMulActionHom_1, y, x, toDistribMulActionHom, toDistribMulActionHom, map_mul', map_mul', toDistribMulActionHom, toDistribMulActionHom_1, map_mul', map_mul'_1, toDistribMulActionHom_eq, toDistribMulActionHom, toDistribMulActionHom_1, toDistribMulActionHom, toDistribMulActionHom_1] (during elaboration)

{ι : Type u_1} [Countable ι] {E : (a : ι) → Type u_2} [(i : ι) → TopologicalSpace E i] [∀ (i : ι) , PolishSpace E i] (val : Encodable ι) (h : (nonempty_encodable ι =: Nonempty Encodable ι) = (Nonempty.intro val =: Nonempty Encodable ι))  : Nonempty.intro val = nonempty_encodable ι
<input>:1:165: expected term

 : ∀ (α : Type u_1) (self : MeasureTheory.OuterMeasure α) , self . 1 ∅ = 0
invalid occurrence of `·` notation, it must be surrounded by parentheses (e.g. `(· + 1)`) ; identifiers [α, u_1, self, MeasureTheory.OuterMeasure, α, self] (during elaboration)

{ι : Type u_1} {α : (a : ι) → Type u_2} {t : (i : ι) → Set α i} {f : (i : ι) → α i} (i : ι)  : (f i ∈ t i) = (f i ∈ t i)
application type mismatch
  Set α
argument
  α
has type
  ι → Type u_2 : Type (max u_1 (u_2 + 1))
but is expected to have type
  Type ?u.15 : Type (?u.15 + 1) ; identifiers [ι, u_1, α, a, ι, u_2, t, i, ι, Set, α, i, f, i, ι, α, i, i, ι, f, i, t, i, f, i, t, i] (during elaboration)

{n : ℕ} (c : CompositionAsSet n) (j : Fin n + 1) (a : ∃ (a : Fin Composition.length CompositionAsSet.toComposition c + 1) , (a ∈ Finset.univ : Prop) ∧ (↑ RelEmbedding.toEmbedding Composition.boundary CompositionAsSet.toComposition c a = j : Prop)) (i : Fin Composition.length CompositionAsSet.toComposition c + 1) (h : (i ∈ Finset.univ : Prop) ∧ (↑ RelEmbedding.toEmbedding Composition.boundary CompositionAsSet.toComposition c i = j : Prop)) (left : i ∈ Finset.univ) (hi : ↑ RelEmbedding.toEmbedding Composition.boundary CompositionAsSet.toComposition c i = j)  : j = ↑ RelEmbedding.toEmbedding Composition.boundary CompositionAsSet.toComposition c i
application type mismatch
  Fin Composition.length
argument
  Composition.length
has type
  Composition ?m.1144 → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [n, c, CompositionAsSet, n, j, Fin, n, a, a, Fin, Composition.length, CompositionAsSet.toComposition, c, a, Finset.univ, RelEmbedding.toEmbedding, Composition.boundary, CompositionAsSet.toComposition, c, a, j, i, Fin, Composition.length, CompositionAsSet.toComposition, c, h, i, Finset.univ, RelEmbedding.toEmbedding, Composition.boundary, CompositionAsSet.toComposition, c, i, j, left, i, Finset.univ, hi, RelEmbedding.toEmbedding, Composition.boundary, CompositionAsSet.toComposition, c, i, j, j, RelEmbedding.toEmbedding, Composition.boundary, CompositionAsSet.toComposition, c, i] (during elaboration)

 : (∀ {S₁ : Type u_1} {S₂ : Type u_2} [inst : Shelf S₁] [inst_1 : Shelf S₂] (self : ShelfHom S₁ S₂) {x : S₁} {y : S₁} , ShelfHom.toFun self Shelf.act x y = Shelf.act ShelfHom.toFun self x ShelfHom.toFun self y)
application type mismatch
  ShelfHom.toFun self Shelf.act
argument
  Shelf.act
has type
  ?m.49 → ?m.49 → ?m.49 : Type ?u.48
but is expected to have type
  S₁ : Type u_1 ; identifiers [S₁, u_1, S₂, u_2, inst, Shelf, S₁, inst_1, Shelf, S₂, self, ShelfHom, S₁, S₂, x, S₁, y, S₁, ShelfHom.toFun, self, Shelf.act, x, y, Shelf.act, ShelfHom.toFun, self, x, ShelfHom.toFun, self, y] (during elaboration)

 : ∀ (S₁ : Type u_1) (S₂ : Type u_2) [inst : Shelf S₁] [inst_1 : Shelf S₂] (self : ShelfHom S₁ S₂) {x : S₁} {y : S₁} , self . 1 Shelf.act x y = Shelf.act self . 1 x self . 1 y
invalid occurrence of `·` notation, it must be surrounded by parentheses (e.g. `(· + 1)`) ; identifiers [S₁, u_1, S₂, u_2, inst, Shelf, S₁, inst_1, Shelf, S₂, self, ShelfHom, S₁, S₂, x, S₁, y, S₁, self, Shelf.act, x, y, Shelf.act, self, x, self, y] (during elaboration)

{c : ℝ} (hc : 1 < c) (i : ℕ) (cpos : 0 < c) (hi : i > 0) hident : 1 ≤ i := hi  : c = c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0
<input>:1:64: expected end of input

{c : ℝ} (hc : 1 < c) (i : ℕ) (cpos : 0 < c) (hi : i > 0) hident : 1 ≤ i := hi  : c ⁻¹ = c ⁻¹
<input>:1:64: expected end of input

{α : Type u_2} {M : Type u_1} [OrderedAddCommMonoid M] (i : α) {f : (a : α) → M} (hf : Set.Finite Function.support f) (h : ∀ (j : α) , 0 ≤ f j)  : ∀ (j : α) (x : j ∈ insert i Set.Finite.toFinset hf) , 0 ≤ f j
function expected at
  Set.Finite ?m.841
term has type
  Prop ; identifiers [α, u_2, M, u_1, OrderedAddCommMonoid, M, i, α, f, a, α, M, hf, Set.Finite, Function.support, f, h, j, α, f, j, j, α, x, j, insert, i, Set.Finite.toFinset, hf, f, j] (during elaboration)

{c : ℝ} (hc : 1 < c) (i : ℕ) (cpos : 0 < c) (hi : i > 0) hident : 1 ≤ i := hi  : - 0 = 0
<input>:1:64: expected end of input

{β : Type u_1} [SeminormedAddCommGroup β] [NormedSpace ℝ β] {t : ℝ} (ht : 0 ≤ t) (x : β)  : (‖ t • x ‖ = t * ‖ x ‖) = (‖ t • x ‖ = t * ‖ x ‖)
<input>:1:103: expected term

{β : Type u_1} [SeminormedAddCommGroup β] [NormedSpace ℝ β] {t : ℝ} (ht : 0 ≤ t) (x : β)  : (‖ t ‖ * ‖ x ‖ = t * ‖ x ‖) = (‖ t ‖ * ‖ x ‖ = t * ‖ x ‖)
<input>:1:99: expected term

{c : ℝ} (hc : 1 < c) (i : ℕ) (cpos : 0 < c) (hi : i > 0) hident : 1 ≤ i := hi  : i = i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0
<input>:1:64: expected end of input

{β : Type u_1} [SeminormedAddCommGroup β] [NormedSpace ℝ β] {t : ℝ} (ht : 0 ≤ t) (x : β)  : (| t | * ‖ x ‖ = t * ‖ x ‖) = (| t | * ‖ x ‖ = t * ‖ x ‖)
<input>:1:93: expected ')', '_', '↑', '↥', '⇑', identifier or no space before

{β : Type u_1} [SeminormedAddCommGroup β] [NormedSpace ℝ β] {t : ℝ} (ht : 0 ≤ t) (x : β)  : t * ‖ x ‖ = t * ‖ x ‖
<input>:1:102: expected term

{ι : Type u} {X : Type v} [TopologicalSpace X] {E : Type u_1} [AddCommMonoid E] [SMulWithZero ℝ E] [TopologicalSpace E] [ContinuousSMul ℝ E] {s : Set X} (f : PartitionOfUnity ι X s) [ContinuousAdd E] {g : (a : ι) → (a : X) → E} (hg : ∀ (i : ι) (x : X) (a : x ∈ tsupport ↑ ↑ f i) , ContinuousAt g i x) (i : ι)  : ∀ (x : X) (a : x ∈ tsupport ↑ ↑ f i) , ContinuousAt g i x
failed to synthesize instance
  TopologicalSpace ι ; identifiers [ι, u, X, v, TopologicalSpace, X, E, u_1, AddCommMonoid, E, SMulWithZero, E, TopologicalSpace, E, ContinuousSMul, E, s, Set, X, f, PartitionOfUnity, ι, X, s, ContinuousAdd, E, g, a, ι, a, X, E, hg, i, ι, x, X, a, x, tsupport, f, i, ContinuousAt, g, i, x, i, ι, x, X, a, x, tsupport, f, i, ContinuousAt, g, i, x] (during elaboration)

{E : Type u_1} [SeminormedAddGroup E] (a : E)  : (0 ≤ ‖ a ‖) = (0 ≤ ‖ a ‖)
<input>:1:59: expected term

{β : Type u_1} [LinearOrder β] [NoMaxOrder β] {u : (a : ℕ) → β} (hu : Filter.Tendsto u Filter.atTop Filter.atTop) (φ : (a : ℕ) → ℕ) (h : StrictMono φ) (h' : ∀ (n : ℕ) (k : ℕ) (a : k < φ n) , u k < u φ n) (x : ℕ) (m : ℕ) (hnm : x < m)  : φ x < φ m
application type mismatch
  u φ
argument
  φ
has type
  ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [β, u_1, LinearOrder, β, NoMaxOrder, β, u, a, β, hu, Filter.Tendsto, u, Filter.atTop, Filter.atTop, φ, a, h, StrictMono, φ, h', n, k, a, k, φ, n, u, k, u, φ, n, x, m, hnm, x, m, φ, x, φ, m] (during elaboration)

{α : Type u_3} {M : Type u_2} {M' : Type u_1} {N : Type u_4} [Zero M] [Zero M'] [CommMonoid N] {f : (a : M) → M'} {hf : f 0 = 0} {g : α →₀ M} {h : (a : α) → (a : M') → N} (h0 : ∀ (a : α) , h a 0 = 1) (x : α) (x_1 : x ∈ Finsupp.support g) (H : ¬ (x ∈ Finsupp.support Finsupp.mapRange f hf g : Prop))  : h x 0 = 1
function expected at
  ?m.83122.support
term has type
  Finset ?m.1260 ; identifiers [α, u_3, M, u_2, M', u_1, N, u_4, Zero, M, Zero, M', CommMonoid, N, f, a, M, M', hf, f, g, α, M, h, a, α, a, M', N, h0, a, α, h, a, x, α, x_1, x, Finsupp.support, g, H, x, Finsupp.support, Finsupp.mapRange, f, hf, g, h, x] (during elaboration)

{α : Type u_3} {M : Type u_2} {M' : Type u_1} {N : Type u_4} [Zero M] [Zero M'] [CommMonoid N] {f : (a : M) → M'} {hf : f 0 = 0} {g : α →₀ M} {h : (a : α) → (a : M') → N} (h0 : ∀ (a : α) , h a 0 = 1) (x : α) (x_1 : x ∈ Finsupp.support g) (H : ¬ (x ∈ Finsupp.support Finsupp.mapRange f hf g : Prop))  : (h x 0 = 1) = (h x 0 = 1)
function expected at
  ?m.83122.support
term has type
  Finset ?m.1260 ; identifiers [α, u_3, M, u_2, M', u_1, N, u_4, Zero, M, Zero, M', CommMonoid, N, f, a, M, M', hf, f, g, α, M, h, a, α, a, M', N, h0, a, α, h, a, x, α, x_1, x, Finsupp.support, g, H, x, Finsupp.support, Finsupp.mapRange, f, hf, g, h, x, h, x] (during elaboration)

{α : Type u_3} {M : Type u_2} {M' : Type u_1} {N : Type u_4} [Zero M] [Zero M'] [CommMonoid N] {f : (a : M) → M'} {hf : f 0 = 0} {g : α →₀ M} {h : (a : α) → (a : M') → N} (h0 : ∀ (a : α) , h a 0 = 1) (x : α) (x_1 : x ∈ Finsupp.support g) (H : ¬ (x ∈ Finsupp.support Finsupp.mapRange f hf g : Prop))  : 1 = 1
function expected at
  ?m.83122.support
term has type
  Finset ?m.1260 ; identifiers [α, u_3, M, u_2, M', u_1, N, u_4, Zero, M, Zero, M', CommMonoid, N, f, a, M, M', hf, f, g, α, M, h, a, α, a, M', N, h0, a, α, h, a, x, α, x_1, x, Finsupp.support, g, H, x, Finsupp.support, Finsupp.mapRange, f, hf, g] (during elaboration)

(α : Type u_1) (r : {r : (a : α) → (a : α) → Prop // IsWellOrder α r}) (wo : fun (r : {r : (a : α) → (a : α) → Prop // IsWellOrder α r}) ↦ Ordinal.type ↑ r r = ⨅ (r : {r : (a : α) → (a : α) → Prop // IsWellOrder α r}) , Ordinal.type ↑ r)  : ⨅ (r : {r : (a : α) → (a : α) → Prop // IsWellOrder α r}) , Ordinal.type ↑ r = fun (r : {r : (a : α) → (a : α) → Prop // IsWellOrder α r}) ↦ Ordinal.type ↑ r r
type mismatch
  r
has type
  { r // IsWellOrder α r } : Type u_1
but is expected to have type
  ?m.45 → ?m.45 → Prop : Type ?u.44 ; identifiers [α, u_1, r, r, a, α, a, α, IsWellOrder, α, r, wo, r, r, a, α, a, α, IsWellOrder, α, r, Ordinal.type, r, r, r, r, a, α, a, α, IsWellOrder, α, r, Ordinal.type, r, r, r, a, α, a, α, IsWellOrder, α, r, Ordinal.type, r, r, r, a, α, a, α, IsWellOrder, α, r, Ordinal.type, r, r] (during elaboration)

(α : Type u_1) (β : Type u_2) [UniformSpace β] (𝔖 : Set Set α) (i : Set α)  : (i ∈ 𝔖) = (i ∈ 𝔖)
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.14 → Type ?u.14 : Type (?u.14 + 1)
but is expected to have type
  Type ?u.13 : Type (?u.13 + 1) ; identifiers [α, u_1, β, u_2, UniformSpace, β, 𝔖, Set, Set, α, i, Set, α, i, 𝔖, i, 𝔖] (during elaboration)

{α : Type u_2} {β : Type u_4} {β' : Type u_3} {γ : Type u_1} {δ : Type u_5} {f : Filter α} {g : Filter β} {m : (a : α) → (a : β') → γ} {n : (a : β) → β'} {m' : (a : α) → (a : β) → δ} {n' : (a : δ) → γ} (h_right_comm : ∀ (a : α) (b : β) , m a n b = n' m' a b) (a : α) (b : β)  : m a n b = n' m' a b
application type mismatch
  m a n
argument
  n
has type
  β → β' : Type (max u_3 u_4)
but is expected to have type
  β' : Type u_3 ; identifiers [α, u_2, β, u_4, β', u_3, γ, u_1, δ, u_5, f, Filter, α, g, Filter, β, m, a, α, a, β', γ, n, a, β, β', m', a, α, a, β, δ, n', a, δ, γ, h_right_comm, a, α, b, β, m, a, n, b, n', m', a, b, a, α, b, β, m, a, n, b, n', m', a, b] (during elaboration)

(α : Type u_1) (β : Type u_2) [UniformSpace β] (𝔖 : Set Set α) (s : Set α)  : (s ∈ 𝔖) = (s ∈ 𝔖)
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.14 → Type ?u.14 : Type (?u.14 + 1)
but is expected to have type
  Type ?u.13 : Type (?u.13 + 1) ; identifiers [α, u_1, β, u_2, UniformSpace, β, 𝔖, Set, Set, α, s, Set, α, s, 𝔖, s, 𝔖] (during elaboration)

{M : Type u_2} {N : Type u_1} [MulOneClass M] [MulOneClass N] (f : M →* N) (hf : ∀ (x : M) (y : M) , Commute ↑ f x ↑ f y) (x : M) (y : M)  : Commute ↑ f x ↑ f y
function expected at
  Commute ?m.42 x
term has type
  Prop ; identifiers [M, u_2, N, u_1, MulOneClass, M, MulOneClass, N, f, M, N, hf, x, M, y, M, Commute, f, x, f, y, x, M, y, M, Commute, f, x, f, y] (during elaboration)

{α : Type u_1} {m : MeasurableSpace α} {M : Type u_2} [TopologicalSpace M] [OrderedAddCommMonoid M] [OrderClosedTopology M] (v : MeasureTheory.VectorMeasure α M) (w : MeasureTheory.VectorMeasure α M) {f : (a : ℕ) → Set α} (hf₁ : ∀ (n : ℕ) , MeasurableSet f n) (hf₂ : ∀ (n : ℕ) , MeasureTheory.VectorMeasure.restrict v f n ≤ MeasureTheory.VectorMeasure.restrict w f n) (a : Set α) (ha₁ : MeasurableSet a) (ha₂ : a ⊆ ⋃ (n : ℕ) , f n) (ha₃ : ⋃ (n : ℕ) , a ∩ disjointed f n = a) (ha₄ : Pairwise Disjoint on fun (n : ℕ) ↦ a ∩ disjointed f n)  : a = ⋃ (n : ℕ) , a ∩ disjointed f n
function expected at
  MeasurableSet ?m.1001
term has type
  Prop ; identifiers [α, u_1, m, MeasurableSpace, α, M, u_2, TopologicalSpace, M, OrderedAddCommMonoid, M, OrderClosedTopology, M, v, MeasureTheory.VectorMeasure, α, M, w, MeasureTheory.VectorMeasure, α, M, f, a, Set, α, hf₁, n, MeasurableSet, f, n, hf₂, n, MeasureTheory.VectorMeasure.restrict, v, f, n, MeasureTheory.VectorMeasure.restrict, w, f, n, a, Set, α, ha₁, MeasurableSet, a, ha₂, a, n, f, n, ha₃, n, a, disjointed, f, n, a, ha₄, Pairwise, Disjoint, n, a, disjointed, f, n, a, n, a, disjointed, f, n] (during elaboration)

{α : Type u_1} {m : MeasurableSpace α} {M : Type u_2} [TopologicalSpace M] [OrderedAddCommMonoid M] [OrderClosedTopology M] (v : MeasureTheory.VectorMeasure α M) (w : MeasureTheory.VectorMeasure α M) {f : (a : ℕ) → Set α} (hf₁ : ∀ (n : ℕ) , MeasurableSet f n) (hf₂ : ∀ (n : ℕ) , MeasureTheory.VectorMeasure.restrict v f n ≤ MeasureTheory.VectorMeasure.restrict w f n) (a : Set α) (ha₁ : MeasurableSet a) (ha₂ : a ⊆ ⋃ (n : ℕ) , f n) (ha₃ : ⋃ (n : ℕ) , a ∩ disjointed f n = a) (ha₄ : Pairwise Disjoint on fun (n : ℕ) ↦ a ∩ disjointed f n)  : ((↑ v a ≤ ↑ w a : Prop)) = ((↑ v a ≤ ↑ w a : Prop))
function expected at
  MeasurableSet ?m.1001
term has type
  Prop ; identifiers [α, u_1, m, MeasurableSpace, α, M, u_2, TopologicalSpace, M, OrderedAddCommMonoid, M, OrderClosedTopology, M, v, MeasureTheory.VectorMeasure, α, M, w, MeasureTheory.VectorMeasure, α, M, f, a, Set, α, hf₁, n, MeasurableSet, f, n, hf₂, n, MeasureTheory.VectorMeasure.restrict, v, f, n, MeasureTheory.VectorMeasure.restrict, w, f, n, a, Set, α, ha₁, MeasurableSet, a, ha₂, a, n, f, n, ha₃, n, a, disjointed, f, n, a, ha₄, Pairwise, Disjoint, n, a, disjointed, f, n, v, a, w, a, v, a, w, a] (during elaboration)

{α : Type u} [AddGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α}  : ((0 ≤ - b + a : Prop) ↔ (b ≤ a : Prop)) = ((0 ≤ - b + a : Prop) ↔ (b ≤ a : Prop))
function expected at
  x_1
term has type
  α ; identifiers [α, u, AddGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, b, a, b, a, b, a, b, a] (during elaboration)

{α : Type u_1} {β : Type u_2} {rα : (a : α) → (a : α) → Prop} {rβ : (a : β) → (a : β) → Prop} (f : (a : α) → β) (fib : Relation.Fibration rα rβ f) {a : α} (ha : Acc rα a) (a : α) (h : ∀ (y : α) (a : rα y a) , Acc rα y) (ih : ∀ (y : α) (a : rα y a) , Acc rβ f y) (b : β) (hr : rβ b f a)  : ∃ (a' : α) , (rα a' a) ∧ (f a' = b)
application type mismatch
  Acc rβ f
argument
  f
has type
  α → β : Type (max u_1 u_2)
but is expected to have type
  β : Type u_2 ; identifiers [α, u_1, β, u_2, rα, a, α, a, α, rβ, a, β, a, β, f, a, α, β, fib, Relation.Fibration, rα, rβ, f, a, α, ha, Acc, rα, a, a, α, h, y, α, a, rα, y, a, Acc, rα, y, ih, y, α, a, rα, y, a, Acc, rβ, f, y, b, β, hr, rβ, b, f, a, a', α, rα, a', a, f, a', b] (during elaboration)

{M : Type u_1} [AddMonoid M] [LinearOrder M] [CovariantClass M M fun (x : M) (x_1 : M) ↦ x + x_1 fun (x : M) (x_1 : M) ↦ x ≤ x_1] {x : M} {n : ℕ} (hn : n ≠ 0)  : (((n • x ≤ 0 : Prop) ∧ (0 ≤ n • x : Prop) : Prop) ↔ ((x ≤ 0 : Prop) ∧ (0 ≤ x : Prop) : Prop)) = (((n • x ≤ 0 : Prop) ∧ (0 ≤ n • x : Prop) : Prop) ↔ ((x ≤ 0 : Prop) ∧ (0 ≤ x : Prop) : Prop))
function expected at
  x_1
term has type
  M ; identifiers [M, u_1, AddMonoid, M, LinearOrder, M, CovariantClass, M, M, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, x, M, n, hn, n, n, x, n, x, x, x, n, x, n, x, x, x] (during elaboration)

{α : Type u_1} {β : Type u_2} {rα : (a : α) → (a : α) → Prop} {rβ : (a : β) → (a : β) → Prop} (f : (a : α) → β) (fib : Relation.Fibration rα rβ f) {a : α} (ha : Acc rα a) (a : α) (h : ∀ (y : α) (a : rα y a) , Acc rα y) (ih : ∀ (y : α) (a : rα y a) , Acc rβ f y) (b : β) (hr : rβ b f a) (a' : α) (h : (rα a' a : Prop) ∧ (f a' = b : Prop)) (hr' : rα a' a) (right : f a' = b)  : ∀ (hr : rβ f a' f a) , Acc rβ f a'
application type mismatch
  Acc rβ f
argument
  f
has type
  α → β : Type (max u_1 u_2)
but is expected to have type
  β : Type u_2 ; identifiers [α, u_1, β, u_2, rα, a, α, a, α, rβ, a, β, a, β, f, a, α, β, fib, Relation.Fibration, rα, rβ, f, a, α, ha, Acc, rα, a, a, α, h, y, α, a, rα, y, a, Acc, rα, y, ih, y, α, a, rα, y, a, Acc, rβ, f, y, b, β, hr, rβ, b, f, a, a', α, h, rα, a', a, f, a', b, hr', rα, a', a, right, f, a', b, hr, rβ, f, a', f, a, Acc, rβ, f, a'] (during elaboration)

{α : Type u} [AddGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α}  : ((b + 0 ≤ b + - b + a : Prop) ↔ (b ≤ a : Prop)) = ((b + 0 ≤ b + - b + a : Prop) ↔ (b ≤ a : Prop))
function expected at
  x_1
term has type
  α ; identifiers [α, u, AddGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, b, b, b, a, b, a, b, b, b, a, b, a] (during elaboration)

 : (∀ {α : Type u} {β : Type v} {r : (a : α) → (a : α) → Prop} {ι : Sort u_1} {f : (a : ι) → β} {g : (a : β) → α} , (Directed r g ∘ f : Prop) ↔ (Directed g ⁻¹'o r f : Prop))
type mismatch
  ?m.79219 ∘ f
has type
  ι → ?m.33 : Sort (imax u_1 ?u.28)
but is expected to have type
  Prop : Type ; identifiers [α, u, β, v, r, a, α, a, α, ι, u_1, f, a, ι, β, g, a, β, α, Directed, r, g, f, Directed, g, r, f] (during elaboration)

 : ∀ {α : Type u} {β : Type v} {r : (a : α) → (a : α) → Prop} {ι : Sort u_1} {f : (a : ι) → β} {g : (a : β) → α} , (Directed r g ∘ f) ↔ (Directed r g ∘ f)
application type mismatch
  Iff (?m.79218 ∘ f)
argument
  ?m.79218 ∘ f
has type
  ι → ?m.32 : Sort (imax u_1 ?u.27)
but is expected to have type
  Prop : Type ; identifiers [α, u, β, v, r, a, α, a, α, ι, u_1, f, a, ι, β, g, a, β, α, Directed, r, g, f, Directed, r, g, f] (during elaboration)

{α : Type u} [AddGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α}  : ((b ≤ b + - b + a : Prop) ↔ (b ≤ a : Prop)) = ((b ≤ b + - b + a : Prop) ↔ (b ≤ a : Prop))
function expected at
  x_1
term has type
  α ; identifiers [α, u, AddGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, b, b, b, a, b, a, b, b, b, a, b, a] (during elaboration)

{α : Type u} [AddGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α}  : (b ≤ a) ↔ (b ≤ a)
function expected at
  x_1
term has type
  α ; identifiers [α, u, AddGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, b, a, b, a] (during elaboration)

{M : Type u_1} [AddMonoid M] [LinearOrder M] [CovariantClass M M fun (x : M) (x_1 : M) ↦ x + x_1 fun (x : M) (x_1 : M) ↦ x ≤ x_1] {x : M} {n : ℕ} (hn : n ≠ 0)  : (((x ≤ 0 : Prop) ∧ (0 ≤ n • x : Prop) : Prop) ↔ ((x ≤ 0 : Prop) ∧ (0 ≤ x : Prop) : Prop)) = (((x ≤ 0 : Prop) ∧ (0 ≤ n • x : Prop) : Prop) ↔ ((x ≤ 0 : Prop) ∧ (0 ≤ x : Prop) : Prop))
function expected at
  x_1
term has type
  M ; identifiers [M, u_1, AddMonoid, M, LinearOrder, M, CovariantClass, M, M, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, x, M, n, hn, n, x, n, x, x, x, x, n, x, x, x] (during elaboration)

{M : Type u_1} [AddMonoid M] [LinearOrder M] [CovariantClass M M fun (x : M) (x_1 : M) ↦ x + x_1 fun (x : M) (x_1 : M) ↦ x ≤ x_1] {x : M} {n : ℕ} (hn : n ≠ 0)  : ((x ≤ 0 : Prop) ∧ (0 ≤ x : Prop)) ↔ ((x ≤ 0 : Prop) ∧ (0 ≤ x : Prop))
function expected at
  x_1
term has type
  M ; identifiers [M, u_1, AddMonoid, M, LinearOrder, M, CovariantClass, M, M, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, x, M, n, hn, n, x, x, x, x] (during elaboration)

{M : Type u_1} [AddMonoid M] {s : Set M} {a : M} (hs : IsAddSubmonoid s) (h : a ∈ s) (x : ℕ) (x : ℕ) (f : Nat.below x) (n : ℕ) (x : Nat.below Nat.succ n)  : (n + 1 • a ∈ s) = (n + 1 • a ∈ s)
application type mismatch
  Nat.below Nat.succ
argument
  Nat.succ
has type
  ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [M, u_1, AddMonoid, M, s, Set, M, a, M, hs, IsAddSubmonoid, s, h, a, s, x, x, f, Nat.below, x, n, x, Nat.below, Nat.succ, n, n, a, s, n, a, s] (during elaboration)

{R : Type u} {σ : Type u_1} [CommSemiring R] (a : R) (n : σ →₀ ℕ) (hn : n ∈ MvPolynomial.support ↑ MvPolynomial.C a) (this : n ∈ {0})  : (n ∈ {0}) = (n ∈ {0})
function expected at
  MvPolynomial.support ?m.159088
term has type
  Finset (?m.383 →₀ ℕ) ; identifiers [R, u, σ, u_1, CommSemiring, R, a, R, n, σ, hn, n, MvPolynomial.support, MvPolynomial.C, a, this, n, n, n] (during elaboration)

{α : Type u_1} [SeminormedRing α] (x : ℕ) (x : ℕ) (f : Nat.below x) (n : ℕ) (x : Nat.below Nat.succ n)  : (‖ ↑ n + 1 ‖ ≤ ↑ n + 1 * ‖ 1 ‖) = (‖ ↑ n + 1 ‖ ≤ ↑ n + 1 * ‖ 1 ‖)
<input>:1:119: expected term

{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {M : Mod_ A} {N : Mod_ A} (hom : Mod_.X M ⟶ Mod_.X N) (act_hom : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (hom_1 : Mod_.X M ⟶ Mod_.X N) (act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (a : Mod_.Hom.mk hom = Mod_.Hom.mk hom_1)  : ∀ (hom_eq : hom = hom_1) , hom = hom_1
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82488 ?m.162331
term has type
  ?m.1833 ⟶ ?m.1835 ; identifiers [C, u₁, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, M, Mod_, A, N, Mod_, A, hom, Mod_.X, M, Mod_.X, N, act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, hom_1, Mod_.X, M, Mod_.X, N, act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, a, Mod_.Hom.mk, hom, Mod_.Hom.mk, hom_1, hom_eq, hom, hom_1, hom, hom_1] (during elaboration)

{α : Type u_1} [SeminormedRing α] (x : ℕ) (x : ℕ) (f : Nat.below x) (n : ℕ) (x : Nat.below Nat.succ n)  : (‖ ↑ n + 1 ‖ ≤ ↑ n + 1 * ‖ 1 ‖) = (‖ ↑ n + 1 ‖ ≤ ↑ n + 1 * ‖ 1 ‖)
<input>:1:119: expected term

{C : Type u} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w} [CategoryTheory.Category D] [∀ (P : CategoryTheory.Functor C ᵒᵖ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X) , CategoryTheory.Limits.HasMultiequalizer CategoryTheory.GrothendieckTopology.Cover.index S P] [∀ (X : C) , CategoryTheory.Limits.HasColimitsOfShape CategoryTheory.GrothendieckTopology.Cover J X ᵒᵖ D] {P : CategoryTheory.Functor C ᵒᵖ D} {Q : CategoryTheory.Functor C ᵒᵖ D} (η : P ⟶ Q) (hQ : CategoryTheory.Presheaf.IsSheaf J Q) (γ : CategoryTheory.GrothendieckTopology.plusObj J P ⟶ Q) (hγ : CategoryTheory.CategoryStruct.comp CategoryTheory.GrothendieckTopology.toPlus J P γ = η)  : η = CategoryTheory.CategoryStruct.comp CategoryTheory.GrothendieckTopology.toPlus J P γ
function expected at
  CategoryTheory.Limits.HasMultiequalizer ?m.81901
term has type
  Prop ; identifiers [C, u, CategoryTheory.Category, C, J, CategoryTheory.GrothendieckTopology, C, D, w, CategoryTheory.Category, D, P, CategoryTheory.Functor, C, D, X, C, S, CategoryTheory.GrothendieckTopology.Cover, J, X, CategoryTheory.Limits.HasMultiequalizer, CategoryTheory.GrothendieckTopology.Cover.index, S, P, X, C, CategoryTheory.Limits.HasColimitsOfShape, CategoryTheory.GrothendieckTopology.Cover, J, X, D, P, CategoryTheory.Functor, C, D, Q, CategoryTheory.Functor, C, D, η, P, Q, hQ, CategoryTheory.Presheaf.IsSheaf, J, Q, γ, CategoryTheory.GrothendieckTopology.plusObj, J, P, Q, hγ, CategoryTheory.CategoryStruct.comp, CategoryTheory.GrothendieckTopology.toPlus, J, P, γ, η, η, CategoryTheory.CategoryStruct.comp, CategoryTheory.GrothendieckTopology.toPlus, J, P, γ] (during elaboration)

{R : Type u} [CommRing R] (I : Ideal R) ⦃ a : Polynomial R ⦄ (a_1 : a ∈ ↑ Submodule.map Polynomial.monomial 1 I) (r : R) (h : (r ∈ ↑ I : Prop) ∧ (↑ Polynomial.monomial 1 r = a : Prop)) (hr : r ∈ ↑ I) (right : ↑ Polynomial.monomial 1 r = a)  : (r ∈ I ^ 1) = (r ∈ I ^ 1)
type mismatch
  I
has type
  Ideal R : Type u
but is expected to have type
  ?m.2812 I a_1 r h : Type ?u.618 ; identifiers [R, u, CommRing, R, I, Ideal, R, a, Polynomial, R, a_1, a, Submodule.map, Polynomial.monomial, I, r, R, h, r, I, Polynomial.monomial, r, a, hr, r, I, right, Polynomial.monomial, r, a, r, I, r, I] (during elaboration)

{α : Type u_1} [SeminormedRing α] (x : ℕ) (x : ℕ) (f : Nat.below x) (n : ℕ) (x : Nat.below Nat.succ n)  : (‖ ↑ n + 1 ‖ ≤ ↑ n + 1 * ‖ 1 ‖) = (‖ ↑ n + 1 ‖ ≤ ↑ n + 1 * ‖ 1 ‖)
<input>:1:119: expected term

{α : Type u_1} [SeminormedRing α] (x : ℕ) (x : ℕ) (f : Nat.below x) (n : ℕ) (x : Nat.below Nat.succ n)  : (‖ ↑ n + 1 ‖ ≤ ↑ n * ‖ 1 ‖ + 1 * ‖ 1 ‖) = (‖ ↑ n + 1 ‖ ≤ ↑ n * ‖ 1 ‖ + 1 * ‖ 1 ‖)
<input>:1:119: expected term

{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {M : Mod_ A} {N : Mod_ A} (hom : Mod_.X M ⟶ Mod_.X N) (act_hom : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (hom_1 : Mod_.X M ⟶ Mod_.X N) (act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (a : hom = hom_1) (h : hom_1 = hom) (hom_2 : Mod_.X M ⟶ Mod_.X N)  : hom = hom
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82488 ?m.162331
term has type
  ?m.1833 ⟶ ?m.1835 ; identifiers [C, u₁, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, M, Mod_, A, N, Mod_, A, hom, Mod_.X, M, Mod_.X, N, act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, hom_1, Mod_.X, M, Mod_.X, N, act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, a, hom, hom_1, h, hom_1, hom, hom_2, Mod_.X, M, Mod_.X, N, hom, hom] (during elaboration)

{α : Type u_1} {m : MeasurableSpace α} {M : Type u_2} [TopologicalSpace M] [OrderedAddCommMonoid M] [OrderClosedTopology M] (v : MeasureTheory.VectorMeasure α M) (w : MeasureTheory.VectorMeasure α M) {f : (a : ℕ) → Set α} (hf₁ : ∀ (n : ℕ) , MeasurableSet f n) (hf₂ : ∀ (n : ℕ) , MeasureTheory.VectorMeasure.restrict v f n ≤ MeasureTheory.VectorMeasure.restrict w f n) (a : Set α) (ha₁ : MeasurableSet a) (ha₂ : a ⊆ ⋃ (n : ℕ) , f n) (ha₃ : ⋃ (n : ℕ) , a ∩ disjointed f n = a) (ha₄ : Pairwise Disjoint on fun (n : ℕ) ↦ a ∩ disjointed f n) (n : ℕ)  : MeasurableSet f n
function expected at
  MeasurableSet ?m.1001
term has type
  Prop ; identifiers [α, u_1, m, MeasurableSpace, α, M, u_2, TopologicalSpace, M, OrderedAddCommMonoid, M, OrderClosedTopology, M, v, MeasureTheory.VectorMeasure, α, M, w, MeasureTheory.VectorMeasure, α, M, f, a, Set, α, hf₁, n, MeasurableSet, f, n, hf₂, n, MeasureTheory.VectorMeasure.restrict, v, f, n, MeasureTheory.VectorMeasure.restrict, w, f, n, a, Set, α, ha₁, MeasurableSet, a, ha₂, a, n, f, n, ha₃, n, a, disjointed, f, n, a, ha₄, Pairwise, Disjoint, n, a, disjointed, f, n, n, MeasurableSet, f, n] (during elaboration)

{α : Type u_1} {m : MeasurableSpace α} {M : Type u_2} [TopologicalSpace M] [OrderedAddCommMonoid M] [OrderClosedTopology M] (v : MeasureTheory.VectorMeasure α M) (w : MeasureTheory.VectorMeasure α M) {f : (a : ℕ) → Set α} (hf₁ : ∀ (n : ℕ) , MeasurableSet f n) (hf₂ : ∀ (n : ℕ) , MeasureTheory.VectorMeasure.restrict v f n ≤ MeasureTheory.VectorMeasure.restrict w f n) (a : Set α) (ha₁ : MeasurableSet a) (ha₂ : a ⊆ ⋃ (n : ℕ) , f n) (ha₃ : ⋃ (n : ℕ) , a ∩ disjointed f n = a) (ha₄ : Pairwise Disjoint on fun (n : ℕ) ↦ a ∩ disjointed f n) (n : ℕ)  : MeasureTheory.VectorMeasure.restrict v f n ≤ MeasureTheory.VectorMeasure.restrict w f n
function expected at
  MeasurableSet ?m.1001
term has type
  Prop ; identifiers [α, u_1, m, MeasurableSpace, α, M, u_2, TopologicalSpace, M, OrderedAddCommMonoid, M, OrderClosedTopology, M, v, MeasureTheory.VectorMeasure, α, M, w, MeasureTheory.VectorMeasure, α, M, f, a, Set, α, hf₁, n, MeasurableSet, f, n, hf₂, n, MeasureTheory.VectorMeasure.restrict, v, f, n, MeasureTheory.VectorMeasure.restrict, w, f, n, a, Set, α, ha₁, MeasurableSet, a, ha₂, a, n, f, n, ha₃, n, a, disjointed, f, n, a, ha₄, Pairwise, Disjoint, n, a, disjointed, f, n, n, MeasureTheory.VectorMeasure.restrict, v, f, n, MeasureTheory.VectorMeasure.restrict, w, f, n] (during elaboration)

{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {M : Mod_ A} {N : Mod_ A} (hom : Mod_.X M ⟶ Mod_.X N) (act_hom : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (hom_1 : Mod_.X M ⟶ Mod_.X N) (act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (a : hom = hom_1) (h : hom_1 = hom)  : hom = hom_1
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82488 ?m.162331
term has type
  ?m.1833 ⟶ ?m.1835 ; identifiers [C, u₁, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, M, Mod_, A, N, Mod_, A, hom, Mod_.X, M, Mod_.X, N, act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, hom_1, Mod_.X, M, Mod_.X, N, act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, a, hom, hom_1, h, hom_1, hom, hom, hom_1] (during elaboration)

{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {M : Mod_ A} {N : Mod_ A} (hom : Mod_.X M ⟶ Mod_.X N) (act_hom : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (hom_1 : Mod_.X M ⟶ Mod_.X N) (act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (a : hom = hom_1)  : hom_1 = hom_1
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82488 ?m.162331
term has type
  ?m.1833 ⟶ ?m.1835 ; identifiers [C, u₁, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, M, Mod_, A, N, Mod_, A, hom, Mod_.X, M, Mod_.X, N, act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, hom_1, Mod_.X, M, Mod_.X, N, act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, a, hom, hom_1, hom_1, hom_1] (during elaboration)

{n : ℕ} (c : CompositionAsSet n) (j : Fin n + 1) (a : ∃ (i : ℕ) , (i < Finset.card CompositionAsSet.boundaries c : Prop) ∧ (List.sum List.take i CompositionAsSet.blocks c = ↑ j : Prop)) (i : ℕ) (h : (i < Finset.card CompositionAsSet.boundaries c : Prop) ∧ (List.sum List.take i CompositionAsSet.blocks c = ↑ j : Prop)) (i_lt : i < Finset.card CompositionAsSet.boundaries c) (hi : List.sum List.take i CompositionAsSet.blocks c = ↑ j) {n : ℕ} (val : ℕ) (val_1 : ℕ) (e_val : val = val_1)  : ∀ (isLt : val < n) , {val := ((val)) , isLt := ((isLt))} = {val := ((val)) , isLt := ((isLt))}
function expected at
  Finset.card ?m.1501
term has type
  ℕ ; identifiers [n, c, CompositionAsSet, n, j, Fin, n, a, i, i, Finset.card, CompositionAsSet.boundaries, c, List.sum, List.take, i, CompositionAsSet.blocks, c, j, i, h, i, Finset.card, CompositionAsSet.boundaries, c, List.sum, List.take, i, CompositionAsSet.blocks, c, j, i_lt, i, Finset.card, CompositionAsSet.boundaries, c, hi, List.sum, List.take, i, CompositionAsSet.blocks, c, j, n, val, val_1, e_val, val, val_1, isLt, val, n, val, val, isLt, isLt, val, val, isLt, isLt] (during elaboration)

{I : Type u_1} {f : (a : I) → Type u_2} [(i : I) → OrderedRing f i] (x : (i : I) → f i) (x_1 : (i : I) → f i) (ha : 0 ≤ x) (hb : 0 ≤ x_1) (x_2 : I)  : OfNat.ofNat 0 x_2 ≤ x x_2
application type mismatch
  OrderedRing f
argument
  f
has type
  I → Type u_2 : Type (max u_1 (u_2 + 1))
but is expected to have type
  Type ?u.15 : Type (?u.15 + 1) ; identifiers [I, u_1, f, a, I, u_2, i, I, OrderedRing, f, i, x, i, I, f, i, x_1, i, I, f, i, ha, x, hb, x_1, x_2, I, OfNat.ofNat, x_2, x, x_2] (during elaboration)

{I : Type u_1} {f : (a : I) → Type u_2} [(i : I) → OrderedRing f i] (x : (i : I) → f i) (x_1 : (i : I) → f i) (ha : 0 ≤ x) (hb : 0 ≤ x_1) (x_2 : I)  : OfNat.ofNat 0 x_2 ≤ x_1 x_2
application type mismatch
  OrderedRing f
argument
  f
has type
  I → Type u_2 : Type (max u_1 (u_2 + 1))
but is expected to have type
  Type ?u.15 : Type (?u.15 + 1) ; identifiers [I, u_1, f, a, I, u_2, i, I, OrderedRing, f, i, x, i, I, f, i, x_1, i, I, f, i, ha, x, hb, x_1, x_2, I, OfNat.ofNat, x_2, x_1, x_2] (during elaboration)

{ι : Type u_1} {α : (a : ι) → Type u_2} {i : ι} {f : Filter α i} (H : IsEmpty (j : ι) → α j) (h : (isEmpty_or_nonempty (j : ι) → α j =: (IsEmpty (j : ι) → α j : Prop) ∨ (Nonempty (j : ι) → α j : Prop)) = (Or.inl H =: (IsEmpty (j : ι) → α j : Prop) ∨ (Nonempty (j : ι) → α j : Prop)))  : Or.inl H = isEmpty_or_nonempty (j : ι) → α j
<input>:1:134: expected term

{R : Type u_1} {A : Type u_2} [CommSemiring R] [StarRing R] [Semiring A] [Algebra R A] [StarRing A] [StarModule R A] {S : StarSubalgebra R A} (h : ∀ (x : A) , x ∈ S) (x : A)  : ∀ (x_1 : x ∈ ⊤) , x ∈ S
typeclass instance problem is stuck, it is often due to metavariables
  Membership A (?m.1968 h x) ; identifiers [R, u_1, A, u_2, CommSemiring, R, StarRing, R, Semiring, A, Algebra, R, A, StarRing, A, StarModule, R, A, S, StarSubalgebra, R, A, h, x, A, x, S, x, A, x_1, x, x, S] (during elaboration)

{α : Type u_2} {M : Type u_1} [AddCommMonoid M] {f : (a : α) → M} {s : Set α} (p : (a : M) → Prop) (hp₀ : p 0) (hp₁ : ∀ (x : M) (y : M) (a : p x) (a : p y) , p x + y) (hp₂ : ∀ (x : α) (a : x ∈ s) , p f x) (x : α)  : ∀ (a : x ∈ s) , p f x
failed to synthesize
  CoeT M x Prop
(deterministic) timeout at 'typeclass', maximum number of heartbeats (20000) has been reached (use 'set_option synthInstance.maxHeartbeats <num>' to set the limit) ; identifiers [α, u_2, M, u_1, AddCommMonoid, M, f, a, α, M, s, Set, α, p, a, M, hp₀, p, hp₁, x, M, y, M, a, p, x, a, p, y, p, x, y, hp₂, x, α, a, x, s, p, f, x, x, α, a, x, s, p, f, x] (during elaboration)

{α : Type u_1} [SemilatticeInf α] [OrderBot α] {s : Finset α} (hs : Set.Intersecting ↑ s) (h : ∀ (t : Finset α) (a : Set.Intersecting ↑ t) (a : s ⊆ t) , s = t) ⦃ a : α ⦄ ⦃ b : α ⦄ (hab : a ≤ b) (ha : a ∈ ↑ s)  : (b ∈ ↑ s) = (b ∈ ↑ s)
type mismatch
  s
has type
  Finset α : Type u_1
but is expected to have type
  ?m.3390 hs h hab ha : Type ?u.2710 ; identifiers [α, u_1, SemilatticeInf, α, OrderBot, α, s, Finset, α, hs, Set.Intersecting, s, h, t, Finset, α, a, Set.Intersecting, t, a, s, t, s, t, a, α, b, α, hab, a, b, ha, a, s, b, s, b, s] (during elaboration)

(α : Type u_1) [OrderedCommGroup α] {n : ℤ} (hn : 0 ≤ n) (a : α) (b : α) (hab : a ≤ b)  : (fun (x : α) ↦ x ^ n a ≤ fun (x : α) ↦ x ^ n b) = (fun (x : α) ↦ x ^ n a ≤ fun (x : α) ↦ x ^ n b)
function expected at
  n
term has type
  ℤ ; identifiers [α, u_1, OrderedCommGroup, α, n, hn, n, a, α, b, α, hab, a, b, x, α, x, n, a, x, α, x, n, b, x, α, x, n, a, x, α, x, n, b] (during elaboration)

(α : Type u_1) [OrderedCommGroup α] {n : ℤ} (hn : 0 ≤ n) (a : α) (b : α) (hab : a ≤ b)  : (1 ≤ fun (x : α) ↦ x ^ n b / fun (x : α) ↦ x ^ n a) = (1 ≤ fun (x : α) ↦ x ^ n b / fun (x : α) ↦ x ^ n a)
function expected at
  n
term has type
  ℤ ; identifiers [α, u_1, OrderedCommGroup, α, n, hn, n, a, α, b, α, hab, a, b, x, α, x, n, b, x, α, x, n, a, x, α, x, n, b, x, α, x, n, a] (during elaboration)

{α : Type u} {β : (a : α) → Type v} (x : AList β) (x_1 : AList β) (x_2 : AList.entries x = AList.entries x_1) (l₁ : List Sigma β) (h₁ : List.NodupKeys l₁) (l₂ : List Sigma β) (nodupKeys : List.NodupKeys l₂) (H : AList.entries {entries := ((l₁)) , nodupKeys := ((h₁))} = AList.entries {entries := ((l₂)) , nodupKeys := ((nodupKeys))}) {α : Type u} {β : (a : α) → Type v} (entries : List Sigma β) (entries_1 : List Sigma β) (e_entries : entries = entries_1) (entries_2 : List Sigma β) (e_entries : entries = entries_2)  : List.NodupKeys entries_2
application type mismatch
  List Sigma
argument
  Sigma
has type
  (?m.58 → Type ?u.56) → Type (max ?u.57 ?u.56) : Type (max (?u.56 + 1) (?u.57 + 1))
but is expected to have type
  Type ?u.55 : Type (?u.55 + 1) ; identifiers [α, u, β, a, α, v, x, AList, β, x_1, AList, β, x_2, AList.entries, x, AList.entries, x_1, l₁, List, Sigma, β, h₁, List.NodupKeys, l₁, l₂, List, Sigma, β, nodupKeys, List.NodupKeys, l₂, H, AList.entries, entries, l₁, nodupKeys, h₁, AList.entries, entries, l₂, nodupKeys, nodupKeys, α, u, β, a, α, v, entries, List, Sigma, β, entries_1, List, Sigma, β, e_entries, entries, entries_1, entries_2, List, Sigma, β, e_entries, entries, entries_2, List.NodupKeys, entries_2] (during elaboration)

{α : Type u} {β : (a : α) → Type v} (x : AList β) (x_1 : AList β) (x_2 : AList.entries x = AList.entries x_1) (l₁ : List Sigma β) (h₁ : List.NodupKeys l₁) (l₂ : List Sigma β) (nodupKeys : List.NodupKeys l₂) (H : AList.entries {entries := ((l₁)) , nodupKeys := ((h₁))} = AList.entries {entries := ((l₂)) , nodupKeys := ((nodupKeys))}) {α : Type u} {β : (a : α) → Type v} (entries : List Sigma β) (entries_1 : List Sigma β) (e_entries : entries = entries_1)  : ∀ (nodupKeys : List.NodupKeys entries) , {entries := ((entries)) , nodupKeys := ((nodupKeys))} = {entries := ((entries)) , nodupKeys := ((nodupKeys))}
application type mismatch
  List Sigma
argument
  Sigma
has type
  (?m.58 → Type ?u.56) → Type (max ?u.57 ?u.56) : Type (max (?u.56 + 1) (?u.57 + 1))
but is expected to have type
  Type ?u.55 : Type (?u.55 + 1) ; identifiers [α, u, β, a, α, v, x, AList, β, x_1, AList, β, x_2, AList.entries, x, AList.entries, x_1, l₁, List, Sigma, β, h₁, List.NodupKeys, l₁, l₂, List, Sigma, β, nodupKeys, List.NodupKeys, l₂, H, AList.entries, entries, l₁, nodupKeys, h₁, AList.entries, entries, l₂, nodupKeys, nodupKeys, α, u, β, a, α, v, entries, List, Sigma, β, entries_1, List, Sigma, β, e_entries, entries, entries_1, nodupKeys, List.NodupKeys, entries, entries, entries, nodupKeys, nodupKeys, entries, entries, nodupKeys, nodupKeys] (during elaboration)

{R : Type u_1} [LinearOrder R] [OrderTop R] (s : Multiset Tropical R) ⦃ s : Tropical R ⦄ {x : Multiset Tropical R} (IH : Tropical.untrop Multiset.sum x = Multiset.inf Multiset.map Tropical.untrop x)  : Multiset.inf Multiset.map Tropical.untrop x = Tropical.untrop Multiset.sum x
application type mismatch
  Multiset Tropical
argument
  Tropical
has type
  Type ?u.812 → Type ?u.812 : Type (?u.812 + 1)
but is expected to have type
  Type ?u.811 : Type (?u.811 + 1) ; identifiers [R, u_1, LinearOrder, R, OrderTop, R, s, Multiset, Tropical, R, s, Tropical, R, x, Multiset, Tropical, R, IH, Tropical.untrop, Multiset.sum, x, Multiset.inf, Multiset.map, Tropical.untrop, x, Multiset.inf, Multiset.map, Tropical.untrop, x, Tropical.untrop, Multiset.sum, x] (during elaboration)

{α : Type u_1} {l : List (a : α) → α} {f : (a : α) → α} (hl : ∀ (f : (a : α) → α) (a : f ∈ l) , Function.Injective f) (hf : Function.Injective f)  : ∀ {f : (a : α) → α} (hl : ∀ (f : (a : α) → α) (a : f ∈ []) , Function.Injective f) (hf : Function.Injective f) , Function.Injective f
unknown identifier 'a' ; identifiers [α, u_1, l, List, a, α, α, f, a, α, α, hl, f, a, α, α, a, f, l, Function.Injective, f, hf, Function.Injective, f, f, a, α, α, hl, f, a, α, α, a, f, Function.Injective, f, hf, Function.Injective, f, Function.Injective, f] (during elaboration)

{X : Type u_1} [TopologicalSpace X] {x₀ : X} {x₁ : X} {p₀ : Path x₀ x₁} {p₁ : Path x₀ x₁} (F : Path.Homotopy p₀ p₁) (t : ↑ unitInterval) (val : ℝ) (property : val ∈ unitInterval) (left : 0 ≤ val) (right : val ≤ 1)  : (0 ≤ val) ∧ (val ≤ 1)
type mismatch
  unitInterval
has type
  Set ℝ : Type
but is expected to have type
  Sort ?u.505 : Type ?u.505 ; identifiers [X, u_1, TopologicalSpace, X, x₀, X, x₁, X, p₀, Path, x₀, x₁, p₁, Path, x₀, x₁, F, Path.Homotopy, p₀, p₁, t, unitInterval, val, property, val, unitInterval, left, val, right, val, val, val] (during elaboration)

{V : Type w'} (G : SimpleGraph V) (x : V) (x_1 : V)  : (SimpleGraph.Adj FirstOrder.Language.simpleGraphOfStructure V x x_1) ↔ (SimpleGraph.Adj FirstOrder.Language.simpleGraphOfStructure V x x_1)
unknown universe level 'w'' ; identifiers [V, w', G, SimpleGraph, V, x, V, x_1, V, SimpleGraph.Adj, FirstOrder.Language.simpleGraphOfStructure, V, x, x_1, SimpleGraph.Adj, FirstOrder.Language.simpleGraphOfStructure, V, x, x_1] (during elaboration)

(R : Type u_1) [CommSemiring R] (M : Type u_2) [AddCommMonoid M] [Module R M] (r : R) (m : M)  : (r * 1 ⊗ₜ[R] m = r ⊗ₜ[R] m) = (r * 1 ⊗ₜ[R] m = r ⊗ₜ[R] m)
failed to synthesize instance
  HMul R (TensorProduct R ?m.275 M) ?m.161958 ; identifiers [R, u_1, CommSemiring, R, M, u_2, AddCommMonoid, M, Module, R, M, r, R, m, M, r, R, m, r, R, m, r, R, m, r, R, m] (during elaboration)

{C : Type u} [inst : CategoryTheory.Category C] [CategoryTheory.HasShift C ℤ] {T₁ : CategoryTheory.Pretriangulated.Triangle C} {T₂ : CategoryTheory.Pretriangulated.Triangle C} (self : CategoryTheory.Pretriangulated.TriangleMorphism T₁ T₂)  : ∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_2 : CategoryTheory.HasShift C ℤ] (T₁ : CategoryTheory.Pretriangulated.Triangle C) (T₂ : CategoryTheory.Pretriangulated.Triangle C) (self : CategoryTheory.Pretriangulated.TriangleMorphism T₁ T₂) , CategoryTheory.CategoryStruct.comp CategoryTheory.Pretriangulated.Triangle.mor₂ T₁ self . 3 = CategoryTheory.CategoryStruct.comp self . 2 CategoryTheory.Pretriangulated.Triangle.mor₂ T₂
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81555 ?m.161398
term has type
  ?m.961 ⟶ ?m.963 ; identifiers [C, u, inst, CategoryTheory.Category, C, CategoryTheory.HasShift, C, T₁, CategoryTheory.Pretriangulated.Triangle, C, T₂, CategoryTheory.Pretriangulated.Triangle, C, self, CategoryTheory.Pretriangulated.TriangleMorphism, T₁, T₂, C, u, inst, CategoryTheory.Category, C, inst_2, CategoryTheory.HasShift, C, T₁, CategoryTheory.Pretriangulated.Triangle, C, T₂, CategoryTheory.Pretriangulated.Triangle, C, self, CategoryTheory.Pretriangulated.TriangleMorphism, T₁, T₂, CategoryTheory.CategoryStruct.comp, CategoryTheory.Pretriangulated.Triangle.mor₂, T₁, self, CategoryTheory.CategoryStruct.comp, self, CategoryTheory.Pretriangulated.Triangle.mor₂, T₂] (during elaboration)

{α : Type u_2} {β : Type u_1} {M : Type u_3} [CommMonoid M] {f : (a : α) → M} {s : Set β} {g : (a : β) → α} (hg : Set.InjOn g s ∩ Function.mulSupport f ∘ g)  : 1 = 1
application type mismatch
  Set.InjOn g s ∩ Function.mulSupport f ∘ g
argument
  Function.mulSupport f ∘ g
has type
  β → Prop : Type u_1
but is expected to have type
  Prop : Type ; identifiers [α, u_2, β, u_1, M, u_3, CommMonoid, M, f, a, α, M, s, Set, β, g, a, β, α, hg, Set.InjOn, g, s, Function.mulSupport, f, g] (during elaboration)

{α : Type u_1} {a : α} {s : Multiset α} {t : Multiset α} em : (a : Prop) → Decidable (a : Prop) := Classical.propDecidable (a_1 : (¬ (a ∈ s : Prop) : Prop) ∧ (Multiset.Disjoint t s : Prop)) (left : ¬ (a ∈ s : Prop)) (right : Multiset.Disjoint t s)  : ∀ ⦃ a : α ⦄ (a_2 : a ∈ s) (a : a ∈ t) , False
<input>:1:60: expected end of input

{α : Type u_1} {a : α} {s : Multiset α} {t : Multiset α} em : (a : Prop) → Decidable (a : Prop) := Classical.propDecidable (a_1 : (¬ (a ∈ s : Prop) : Prop) ∧ (Multiset.Disjoint s t : Prop)) (left : ¬ (a ∈ s : Prop)) (right : Multiset.Disjoint s t)  : ∀ ⦃ a : α ⦄ (a_2 : a ∈ t) (a : a ∈ s) , False
<input>:1:60: expected end of input

{ι : Type u_1} {α : (a : ι) → Type u_2} {i : ι} {f : Filter α i} (H : IsEmpty (j : ι) → α j) (h : (isEmpty_or_nonempty (j : ι) → α j =: (IsEmpty (j : ι) → α j : Prop) ∨ (Nonempty (j : ι) → α j : Prop)) = (Or.inl H =: (IsEmpty (j : ι) → α j : Prop) ∨ (Nonempty (j : ι) → α j : Prop)))  : (¬ ((Nonempty (i : ι) → α i : Prop) ∧ (Filter.NeBot f : Prop) : Prop)) = (∀ (a : Nonempty (i : ι) → α i) , ¬ (Filter.NeBot f : Prop))
<input>:1:134: expected term

{α : Type u_1} {ι : Sort u_2} [ConditionallyCompleteLattice α] {f : (a : ι) → α} {g : (a : ι) → α} (B : BddAbove Set.range g) (H : ∀ (x : ι) , f x ≤ g x) (h : IsEmpty ι) (h_1 : (isEmpty_or_nonempty ι =: (IsEmpty ι : Prop) ∨ (Nonempty ι : Prop)) = (Or.inl h =: (IsEmpty ι : Prop) ∨ (Nonempty ι : Prop)))  : Or.inl h = isEmpty_or_nonempty ι
<input>:1:201: expected term

