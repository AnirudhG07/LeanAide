 : (∀ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {S₁ : CategoryTheory.ShortComplex C} {S₂ : CategoryTheory.ShortComplex C} {φ : S₁ ⟶ S₂} {h₁ : CategoryTheory.ShortComplex.RightHomologyData S₁} {h₂ : CategoryTheory.ShortComplex.RightHomologyData S₂} (self : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂) , CategoryTheory.CategoryStruct.comp CategoryTheory.ShortComplex.RightHomologyMapData.φQ self CategoryTheory.ShortComplex.RightHomologyData.g' h₂ = CategoryTheory.CategoryStruct.comp CategoryTheory.ShortComplex.RightHomologyData.g' h₁ CategoryTheory.ShortComplex.Hom.τ₃ φ)
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82047 ?m.161898
term has type
  ?m.1410 ⟶ ?m.1412 ; identifiers [C, u_1, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasZeroMorphisms, C, S₁, CategoryTheory.ShortComplex, C, S₂, CategoryTheory.ShortComplex, C, φ, S₁, S₂, h₁, CategoryTheory.ShortComplex.RightHomologyData, S₁, h₂, CategoryTheory.ShortComplex.RightHomologyData, S₂, self, CategoryTheory.ShortComplex.RightHomologyMapData, φ, h₁, h₂, CategoryTheory.CategoryStruct.comp, CategoryTheory.ShortComplex.RightHomologyMapData.φQ, self, CategoryTheory.ShortComplex.RightHomologyData.g', h₂, CategoryTheory.CategoryStruct.comp, CategoryTheory.ShortComplex.RightHomologyData.g', h₁, CategoryTheory.ShortComplex.Hom.τ₃, φ] (during elaboration)

 : ∀ (C : Type u_1) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] (S₁ : CategoryTheory.ShortComplex C) (S₂ : CategoryTheory.ShortComplex C) (φ : S₁ ⟶ S₂) (h₁ : CategoryTheory.ShortComplex.RightHomologyData S₁) (h₂ : CategoryTheory.ShortComplex.RightHomologyData S₂) (self : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂) , CategoryTheory.CategoryStruct.comp self . 1 CategoryTheory.ShortComplex.RightHomologyData.g' h₂ = CategoryTheory.CategoryStruct.comp CategoryTheory.ShortComplex.RightHomologyData.g' h₁ CategoryTheory.ShortComplex.Hom.τ₃ φ
invalid occurrence of `·` notation, it must be surrounded by parentheses (e.g. `(· + 1)`) ; identifiers [C, u_1, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasZeroMorphisms, C, S₁, CategoryTheory.ShortComplex, C, S₂, CategoryTheory.ShortComplex, C, φ, S₁, S₂, h₁, CategoryTheory.ShortComplex.RightHomologyData, S₁, h₂, CategoryTheory.ShortComplex.RightHomologyData, S₂, self, CategoryTheory.ShortComplex.RightHomologyMapData, φ, h₁, h₂, CategoryTheory.CategoryStruct.comp, self, CategoryTheory.ShortComplex.RightHomologyData.g', h₂, CategoryTheory.CategoryStruct.comp, CategoryTheory.ShortComplex.RightHomologyData.g', h₁, CategoryTheory.ShortComplex.Hom.τ₃, φ] (during elaboration)

 : (∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {A : Mon_ C} {B : Mon_ C} (self : Bimod A B) , CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom Mon_.mul A CategoryTheory.CategoryStruct.id Bimod.X self Bimod.actLeft self = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.associator Mon_.X A Mon_.X A Bimod.X self . hom CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A Bimod.actLeft self Bimod.actLeft self)
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81517 ?m.162100
term has type
  ?m.501 ⟶ ?m.503 ; identifiers [C, u₁, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.MonoidalCategory, C, A, Mon_, C, B, Mon_, C, self, Bimod, A, B, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, Mon_.mul, A, CategoryTheory.CategoryStruct.id, Bimod.X, self, Bimod.actLeft, self, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.associator, Mon_.X, A, Mon_.X, A, Bimod.X, self, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, Bimod.actLeft, self, Bimod.actLeft, self] (during elaboration)

 : ∀ (C : Type u₁) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] (A : Mon_ C) (B : Mon_ C) (self : Bimod A B) , CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom Mon_.mul A CategoryTheory.CategoryStruct.id self . 1 self . 2 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.associator Mon_.X A Mon_.X A self . 1 . hom CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A self . 2 self . 2
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81514 ?m.162097
term has type
  ?m.498 ⟶ ?m.500 ; identifiers [C, u₁, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.MonoidalCategory, C, A, Mon_, C, B, Mon_, C, self, Bimod, A, B, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, Mon_.mul, A, CategoryTheory.CategoryStruct.id, self, self, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.associator, Mon_.X, A, Mon_.X, A, self, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, self, self] (during elaboration)

 : (∀ {x : PGame} {y : PGame} , (PGame.Fuzzy x y) ↔ (Game.Fuzzy Quotient.mk PGame.setoid x Quotient.mk PGame.setoid y))
application type mismatch
  Game.Fuzzy Quotient.mk
argument
  Quotient.mk
has type
  (s : Setoid ?m.12) → ?m.12 → Quotient s : Sort (imax (max 1 ?u.11) ?u.11)
but is expected to have type
  Game : Type (?u.10 + 1) ; identifiers [x, PGame, y, PGame, PGame.Fuzzy, x, y, Game.Fuzzy, Quotient.mk, PGame.setoid, x, Quotient.mk, PGame.setoid, y] (during elaboration)

{α : Type u_1} [DecidableEq α] [Monoid α] {s : Finset α} {t : Finset α} (hst : s ⊆ t) (x : ℕ) (x : ℕ) (f : Nat.below x) (n : ℕ) (x : Nat.below Nat.succ n)  : (s ^ n + 1 ⊆ t ^ n + 1) = (s ^ n + 1 ⊆ t ^ n + 1)
application type mismatch
  Nat.below Nat.succ
argument
  Nat.succ
has type
  ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [α, u_1, DecidableEq, α, Monoid, α, s, Finset, α, t, Finset, α, hst, s, t, x, x, f, Nat.below, x, n, x, Nat.below, Nat.succ, n, s, n, t, n, s, n, t, n] (during elaboration)

{R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L] (toSubmodule : Submodule R L) (lie_mem' : ∀ {x : L} {y : L} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (a : y ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) , ⁅ x , y ⁆ ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (toSubmodule_1 : Submodule R L) (lie_mem'_1 : ∀ {x : L} {y : L} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : y ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) , ⁅ x , y ⁆ ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : {toSubmodule := ((toSubmodule)) , lie_mem' := ((lie_mem'))} = {toSubmodule := ((toSubmodule_1)) , lie_mem' := ((lie_mem'_1))})  : ∀ (toSubmodule_eq : toSubmodule = toSubmodule_1) , toSubmodule = toSubmodule_1
function expected at
  AddSubsemigroup.carrier ?m.80749 Submodule.toAddSubmonoid
term has type
  Prop ; identifiers [R, u, L, v, CommRing, R, LieRing, L, LieAlgebra, R, L, toSubmodule, Submodule, R, L, lie_mem', x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, toSubmodule_1, Submodule, R, L, lie_mem'_1, x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, toSubmodule, toSubmodule, lie_mem', lie_mem', toSubmodule, toSubmodule_1, lie_mem', lie_mem'_1, toSubmodule_eq, toSubmodule, toSubmodule_1, toSubmodule, toSubmodule_1] (during elaboration)

{V : Type u} (x : SimpleGraph V) (x_1 : SimpleGraph V) (Adj : (a : V) → (a : V) → Prop) (symm : Symmetric Adj) (loopless : Irreflexive Adj) (Adj_1 : (a : V) → (a : V) → Prop) (symm_1 : Symmetric Adj_1) (loopless_1 : Irreflexive Adj_1) (Adj_2 : SimpleGraph.Adj SimpleGraph.mk Adj = SimpleGraph.Adj SimpleGraph.mk Adj_1) (h : SimpleGraph.Adj SimpleGraph.mk Adj_1 = SimpleGraph.Adj SimpleGraph.mk Adj)  : Adj = Adj_1
application type mismatch
  (fun Adj => SimpleGraph.mk Adj).Adj
argument
  fun Adj => SimpleGraph.mk Adj
has type
  (?m.80 → ?m.80 → Prop) → SimpleGraph ?m.80 : Type ?u.79
but is expected to have type
  SimpleGraph ?m.78 : Type ?u.77 ; identifiers [V, u, x, SimpleGraph, V, x_1, SimpleGraph, V, Adj, a, V, a, V, symm, Symmetric, Adj, loopless, Irreflexive, Adj, Adj_1, a, V, a, V, symm_1, Symmetric, Adj_1, loopless_1, Irreflexive, Adj_1, Adj_2, SimpleGraph.Adj, SimpleGraph.mk, Adj, SimpleGraph.Adj, SimpleGraph.mk, Adj_1, h, SimpleGraph.Adj, SimpleGraph.mk, Adj_1, SimpleGraph.Adj, SimpleGraph.mk, Adj, Adj, Adj_1] (during elaboration)

{R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L] (toSubmodule : Submodule R L) (lie_mem' : ∀ {x : L} {y : L} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (a : y ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) , ⁅ x , y ⁆ ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (toSubmodule_1 : Submodule R L) (lie_mem'_1 : ∀ {x : L} {y : L} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : y ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) , ⁅ x , y ⁆ ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : toSubmodule = toSubmodule_1) (h : toSubmodule_1 = toSubmodule) (toSubmodule_2 : Submodule R L)  : toSubmodule = toSubmodule
function expected at
  AddSubsemigroup.carrier ?m.80749 Submodule.toAddSubmonoid
term has type
  Prop ; identifiers [R, u, L, v, CommRing, R, LieRing, L, LieAlgebra, R, L, toSubmodule, Submodule, R, L, lie_mem', x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, toSubmodule_1, Submodule, R, L, lie_mem'_1, x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, toSubmodule, toSubmodule_1, h, toSubmodule_1, toSubmodule, toSubmodule_2, Submodule, R, L, toSubmodule, toSubmodule] (during elaboration)

{M : Type u_1} [MonoidWithZero M] [NoZeroDivisors M] [Nontrivial M] {a : M} {n : ℕ} (h : n = 0) (h_1 : (LE.le.eq_or_gt (zero_le n =: 0 ≤ n) =: (n = 0 : Prop) ∨ (0 < n : Prop)) = (Or.inl h =: (n = 0 : Prop) ∨ (0 < n : Prop)))  : (Or.inl h) = (LE.le.eq_or_gt (zero_le n))
<input>:1:131: expected term

{V : Type u_1} [TopologicalSpace V] [AddCommMonoid V] [SMul ℝ V] (carrier : Set V) (convex' : Convex ℝ carrier) (isCompact' : IsCompact carrier) (nonempty' : Set.Nonempty carrier) (carrier_1 : Set V) (convex'_1 : Convex ℝ carrier_1) (isCompact'_1 : IsCompact carrier_1) (nonempty'_1 : Set.Nonempty carrier_1) (a : carrier = carrier_1) (h : carrier_1 = carrier) (convex'_2 : Convex ℝ carrier) (isCompact'_2 : IsCompact carrier) (nonempty'_2 : Set.Nonempty carrier) (a : carrier = carrier) (h : HEq a (Eq.refl carrier =: carrier = carrier))  : {carrier := ((carrier)) , convex' := ((convex')) , isCompact' := ((isCompact')) , nonempty' := ((nonempty'))} = {carrier := ((carrier)) , convex' := ((convex')) , isCompact' := ((isCompact')) , nonempty' := ((nonempty'))}
<input>:1:517: expected term

{R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L] (toSubmodule : Submodule R L) (lie_mem' : ∀ {x : L} {y : L} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (a : y ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) , ⁅ x , y ⁆ ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (toSubmodule_1 : Submodule R L) (lie_mem'_1 : ∀ {x : L} {y : L} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : y ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) , ⁅ x , y ⁆ ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : toSubmodule = toSubmodule_1) (h : toSubmodule_1 = toSubmodule) (lie_mem'_2 : ∀ {x : L} {y : L} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (a : y ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) , ⁅ x , y ⁆ ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (a : toSubmodule = toSubmodule) (h : HEq a (Eq.refl toSubmodule =: toSubmodule = toSubmodule))  : {toSubmodule := ((toSubmodule)) , lie_mem' := ((lie_mem'))} = {toSubmodule := ((toSubmodule)) , lie_mem' := ((lie_mem'))}
<input>:1:1296: expected term

{R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L] (toSubmodule : Submodule R L) (lie_mem' : ∀ {x : L} {y : L} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (a : y ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) , ⁅ x , y ⁆ ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (toSubmodule_1 : Submodule R L) (lie_mem'_1 : ∀ {x : L} {y : L} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : y ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) , ⁅ x , y ⁆ ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : toSubmodule = toSubmodule_1) (h : toSubmodule_1 = toSubmodule)  : toSubmodule = toSubmodule_1
function expected at
  AddSubsemigroup.carrier ?m.80749 Submodule.toAddSubmonoid
term has type
  Prop ; identifiers [R, u, L, v, CommRing, R, LieRing, L, LieAlgebra, R, L, toSubmodule, Submodule, R, L, lie_mem', x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, toSubmodule_1, Submodule, R, L, lie_mem'_1, x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, toSubmodule, toSubmodule_1, h, toSubmodule_1, toSubmodule, toSubmodule, toSubmodule_1] (during elaboration)

{R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L] (toSubmodule : Submodule R L) (lie_mem' : ∀ {x : L} {y : L} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (a : y ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) , ⁅ x , y ⁆ ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (toSubmodule_1 : Submodule R L) (lie_mem'_1 : ∀ {x : L} {y : L} (a : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : y ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) , ⁅ x , y ⁆ ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : toSubmodule = toSubmodule_1)  : toSubmodule_1 = toSubmodule_1
function expected at
  AddSubsemigroup.carrier ?m.80749 Submodule.toAddSubmonoid
term has type
  Prop ; identifiers [R, u, L, v, CommRing, R, LieRing, L, LieAlgebra, R, L, toSubmodule, Submodule, R, L, lie_mem', x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, toSubmodule_1, Submodule, R, L, lie_mem'_1, x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, toSubmodule, toSubmodule_1, toSubmodule_1, toSubmodule_1] (during elaboration)

{ι : Type u_1} {α : (a : ι) → Type u_2} {r₁ : (a : ι) → (a : ι) → Prop} {r₂ : (a : ι) → (a : ι) → Prop} {s₁ : (i : ι) → (a : α i) → (a : α i) → Prop} {s₂ : (i : ι) → (a : α i) → (a : α i) → Prop} (hr : ∀ (a : ι) (b : ι) (a_1 : r₁ a b) , r₂ a b) (hs : ∀ (i : ι) (a : α i) (b : α i) (a_1 : s₁ i a b) , s₂ i a b) {a : (i : ι) × α i} {b : (i : ι) × α i} (h : Sigma.Lex r₁ s₁ a b) {i : ι} {j : ι} (a_1 : α i) (b_1 : α j) (hij : r₁ i j) (h_1 : a = {fst := ((i)) , snd := ((a_1))}) (h : Sigma.Lex r₁ s₁ {fst := ((i)) , snd := ((a_1))} b) (h_2 : b = {fst := ((j)) , snd := ((b_1))}) (h : Sigma.Lex r₁ s₁ {fst := ((i)) , snd := ((a_1))} {fst := ((j)) , snd := ((b_1))}) (h_3 : HEq h (Sigma.Lex.left a_1 b_1 hij =: Sigma.Lex r₁ s₁ {fst := ((i)) , snd := ((a_1))} {fst := ((j)) , snd := ((b_1))}))  : r₂ i j
<input>:1:703: expected term

{ι : Type u_1} {K : Type u_2} {V : Type u_3} [Field K] [AddCommGroup V] [Module K V] {f : (a : ι) → ℙ K V}  : (¬ (LinearIndependent K Projectivization.rep ∘ f)) ↔ (¬ (LinearIndependent K Projectivization.rep ∘ f))
application type mismatch
  ¬?m.82840 ∘ f
argument
  ?m.82840 ∘ f
has type
  ι → ?m.862 : Sort (imax (u_1 + 1) ?u.857)
but is expected to have type
  Prop : Type ; identifiers [ι, u_1, K, u_2, V, u_3, Field, K, AddCommGroup, V, Module, K, V, f, a, ι, K, V, LinearIndependent, K, Projectivization.rep, f, LinearIndependent, K, Projectivization.rep, f] (during elaboration)

{α : Type u_1} {β : Type u_2} {m0 : MeasurableSpace α} [MeasurableSpace β] {μ : MeasureTheory.Measure α} {f : (a : α) → β} (hf : AEMeasurable f)  : ∀ (h : ¬ True) , 0 = 0
failed to synthesize instance
  MeasureTheory.MeasureSpace α ; identifiers [α, u_1, β, u_2, m0, MeasurableSpace, α, MeasurableSpace, β, μ, MeasureTheory.Measure, α, f, a, α, β, hf, AEMeasurable, f, h, True] (during elaboration)

{ι : Type u_1} {α : (a : ι) → Type u_2} {r₁ : (a : ι) → (a : ι) → Prop} {r₂ : (a : ι) → (a : ι) → Prop} {s₁ : (i : ι) → (a : α i) → (a : α i) → Prop} {s₂ : (i : ι) → (a : α i) → (a : α i) → Prop} (hr : ∀ (a : ι) (b : ι) (a_1 : r₁ a b) , r₂ a b) (hs : ∀ (i : ι) (a : α i) (b : α i) (a_1 : s₁ i a b) , s₂ i a b) {a : (i : ι) × α i} {b : (i : ι) × α i} (h : Sigma.Lex r₁ s₁ a b) {i : ι} (a_1 : α i) (b_1 : α i) (hab : s₁ i a_1 b_1) (h_1 : a = {fst := ((i)) , snd := ((a_1))}) (h : Sigma.Lex r₁ s₁ {fst := ((i)) , snd := ((a_1))} b) (h_2 : b = {fst := ((i)) , snd := ((b_1))}) (h : Sigma.Lex r₁ s₁ {fst := ((i)) , snd := ((a_1))} {fst := ((i)) , snd := ((b_1))}) (h_3 : HEq h (Sigma.Lex.right a_1 b_1 hab =: Sigma.Lex r₁ s₁ {fst := ((i)) , snd := ((a_1))} {fst := ((i)) , snd := ((b_1))}))  : s₂ i a_1 b_1
<input>:1:702: expected term

{M : Type u_1} [MonoidWithZero M] [NoZeroDivisors M] [Nontrivial M] {a : M} {n : ℕ} (h : 0 < n) (h_1 : (LE.le.eq_or_gt (zero_le n =: 0 ≤ n) =: (n = 0 : Prop) ∨ (0 < n : Prop)) = (Or.inr h =: (n = 0 : Prop) ∨ (0 < n : Prop)))  : (Or.inr h) = (LE.le.eq_or_gt (zero_le n))
<input>:1:131: expected term

 : (∀ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {J : CategoryTheory.GrothendieckTopology C} {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Arrow S) , CategoryTheory.GrothendieckTopology.Cover.sieve S . arrows CategoryTheory.GrothendieckTopology.Cover.Arrow.f self)
function expected at
  (CategoryTheory.GrothendieckTopology.Cover.sieve S).arrows ?m.871
term has type
  Prop ; identifiers [C, u, inst, CategoryTheory.Category, C, X, C, J, CategoryTheory.GrothendieckTopology, C, S, CategoryTheory.GrothendieckTopology.Cover, J, X, self, CategoryTheory.GrothendieckTopology.Cover.Arrow, S, CategoryTheory.GrothendieckTopology.Cover.sieve, S, arrows, CategoryTheory.GrothendieckTopology.Cover.Arrow.f, self] (during elaboration)

 : ∀ (C : Type u) [inst : CategoryTheory.Category C] (X : C) (J : CategoryTheory.GrothendieckTopology C) (S : CategoryTheory.GrothendieckTopology.Cover J X) (self : CategoryTheory.GrothendieckTopology.Cover.Arrow S) , CategoryTheory.GrothendieckTopology.Cover.sieve S . arrows self . 2
invalid occurrence of `·` notation, it must be surrounded by parentheses (e.g. `(· + 1)`) ; identifiers [C, u, inst, CategoryTheory.Category, C, X, C, J, CategoryTheory.GrothendieckTopology, C, S, CategoryTheory.GrothendieckTopology.Cover, J, X, self, CategoryTheory.GrothendieckTopology.Cover.Arrow, S, CategoryTheory.GrothendieckTopology.Cover.sieve, S, arrows, self] (during elaboration)

 : (∀ {C : Type u} {A : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : AddMonoid A] (self : CategoryTheory.ShiftMkCore C A) (n : A) (X : C) , CategoryTheory.NatTrans.app CategoryTheory.ShiftMkCore.add self n 0 . hom X = CategoryTheory.CategoryStruct.comp CategoryTheory.eqToHom (id (Eq.mpr (id ((add_zero n) ▸ (Eq.refl (CategoryTheory.Functor.toPrefunctor CategoryTheory.ShiftMkCore.F self n + 0 . obj X = CategoryTheory.Functor.toPrefunctor CategoryTheory.ShiftMkCore.F self n . obj X)))) (Eq.refl CategoryTheory.Functor.toPrefunctor CategoryTheory.ShiftMkCore.F self n . obj X))) CategoryTheory.NatTrans.app CategoryTheory.ShiftMkCore.zero self . inv CategoryTheory.Functor.toPrefunctor CategoryTheory.ShiftMkCore.F self n . obj X)
function expected at
  CategoryTheory.NatTrans.app ?m.81278 self
term has type
  ?m.61.obj self ⟶ ?m.62.obj self ; identifiers [C, u, A, u_1, inst, CategoryTheory.Category, C, inst_1, AddMonoid, A, self, CategoryTheory.ShiftMkCore, C, A, n, A, X, C, CategoryTheory.NatTrans.app, CategoryTheory.ShiftMkCore.add, self, n, hom, X, CategoryTheory.CategoryStruct.comp, CategoryTheory.eqToHom, id, Eq.mpr, id, add_zero, n, Eq.refl, CategoryTheory.Functor.toPrefunctor, CategoryTheory.ShiftMkCore.F, self, n, obj, X, CategoryTheory.Functor.toPrefunctor, CategoryTheory.ShiftMkCore.F, self, n, obj, X, Eq.refl, CategoryTheory.Functor.toPrefunctor, CategoryTheory.ShiftMkCore.F, self, n, obj, X, CategoryTheory.NatTrans.app, CategoryTheory.ShiftMkCore.zero, self, inv, CategoryTheory.Functor.toPrefunctor, CategoryTheory.ShiftMkCore.F, self, n, obj, X] (during elaboration)

 : ∀ (C : Type u) (A : Type u_1) [inst : CategoryTheory.Category C] [inst_1 : AddMonoid A] (self : CategoryTheory.ShiftMkCore C A) (n : A) (X : C) , CategoryTheory.NatTrans.app self . 3 n 0 . hom X = CategoryTheory.CategoryStruct.comp CategoryTheory.eqToHom (id (Eq.mpr (id ((add_zero n) ▸ (Eq.refl (CategoryTheory.Functor.toPrefunctor self . 1 n + 0 . obj X = CategoryTheory.Functor.toPrefunctor self . 1 n . obj X)))) (Eq.refl CategoryTheory.Functor.toPrefunctor self . 1 n . obj X))) CategoryTheory.NatTrans.app self . 2 . inv CategoryTheory.Functor.toPrefunctor self . 1 n . obj X
invalid occurrence of `·` notation, it must be surrounded by parentheses (e.g. `(· + 1)`) ; identifiers [C, u, A, u_1, inst, CategoryTheory.Category, C, inst_1, AddMonoid, A, self, CategoryTheory.ShiftMkCore, C, A, n, A, X, C, CategoryTheory.NatTrans.app, self, n, hom, X, CategoryTheory.CategoryStruct.comp, CategoryTheory.eqToHom, id, Eq.mpr, id, add_zero, n, Eq.refl, CategoryTheory.Functor.toPrefunctor, self, n, obj, X, CategoryTheory.Functor.toPrefunctor, self, n, obj, X, Eq.refl, CategoryTheory.Functor.toPrefunctor, self, n, obj, X, CategoryTheory.NatTrans.app, self, inv, CategoryTheory.Functor.toPrefunctor, self, n, obj, X] (during elaboration)

{V : Type u_1} {P : Type u_2} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] [Fact (FiniteDimensional.finrank ℝ V = 2 : Prop)] [Module.Oriented ℝ V Fin 2] {p₁ : P} {p₂ : P} {p₃ : P} (h : EuclideanGeometry.oangle p₁ p₂ p₃ = ↑ Real.pi)  : ↑ Real.pi = EuclideanGeometry.oangle p₁ p₂ p₃
application type mismatch
  Module.Oriented ℝ V Fin
argument
  Fin
has type
  ℕ → Type : Type 1
but is expected to have type
  Type ?u.490 : Type (?u.490 + 1) ; identifiers [V, u_1, P, u_2, NormedAddCommGroup, V, InnerProductSpace, V, MetricSpace, P, NormedAddTorsor, V, P, Fact, FiniteDimensional.finrank, V, Module.Oriented, V, Fin, p₁, P, p₂, P, p₃, P, h, EuclideanGeometry.oangle, p₁, p₂, p₃, Real.pi, Real.pi, EuclideanGeometry.oangle, p₁, p₂, p₃] (during elaboration)

{v : Sat.Valuation} {l : Sat.Literal} (h₁ : ∀ (a : Sat.Valuation.neg v Sat.Literal.negate l) , False) (h₂ : ∀ (a : Sat.Valuation.neg v l) , False)  : ∀ (a : ℕ) (h₁ : ∀ (a : Sat.Valuation.neg v Sat.Literal.negate Sat.Literal.pos a) , False) (h₂ : ∀ (a : Sat.Valuation.neg v Sat.Literal.pos a) , False) , False
application type mismatch
  Sat.Valuation.neg v Sat.Literal.negate
argument
  Sat.Literal.negate
has type
  Sat.Literal → Sat.Literal : Type
but is expected to have type
  Sat.Literal : Type ; identifiers [v, Sat.Valuation, l, Sat.Literal, h₁, a, Sat.Valuation.neg, v, Sat.Literal.negate, l, False, h₂, a, Sat.Valuation.neg, v, l, False, a, h₁, a, Sat.Valuation.neg, v, Sat.Literal.negate, Sat.Literal.pos, a, False, h₂, a, Sat.Valuation.neg, v, Sat.Literal.pos, a, False, False] (during elaboration)

{v : Sat.Valuation} {l : Sat.Literal} (h₁ : ∀ (a : Sat.Valuation.neg v Sat.Literal.negate l) , False) (h₂ : ∀ (a : Sat.Valuation.neg v l) , False)  : ∀ (a : ℕ) (h₁ : ∀ (a : Sat.Valuation.neg v Sat.Literal.negate Sat.Literal.neg a) , False) (h₂ : ∀ (a : Sat.Valuation.neg v Sat.Literal.neg a) , False) , False
application type mismatch
  Sat.Valuation.neg v Sat.Literal.negate
argument
  Sat.Literal.negate
has type
  Sat.Literal → Sat.Literal : Type
but is expected to have type
  Sat.Literal : Type ; identifiers [v, Sat.Valuation, l, Sat.Literal, h₁, a, Sat.Valuation.neg, v, Sat.Literal.negate, l, False, h₂, a, Sat.Valuation.neg, v, l, False, a, h₁, a, Sat.Valuation.neg, v, Sat.Literal.negate, Sat.Literal.neg, a, False, h₂, a, Sat.Valuation.neg, v, Sat.Literal.neg, a, False, False] (during elaboration)

{G : Type u_2} {α : Type u_1} [Group G] [MulAction G α] {s : Set α} {x : α} (i : G)  : (∃ (_h : ¬ (i = 1)) , x ∈ i • s) = ((¬ (i = 1)) ∧ (x ∈ i • s))
failed to synthesize instance
  HSMul G (Set α) ?m.943 ; identifiers [G, u_2, α, u_1, Group, G, MulAction, G, α, s, Set, α, x, α, i, G, _h, i, x, i, s, i, x, i, s] (during elaboration)

{G : Type u_2} {α : Type u_1} [Group G] [MulAction G α] {s : Set α} {x : α}  : (¬ (∃ (x_1 : G) , (¬ (x_1 = 1)) ∧ (x ∈ x_1 • s))) = (∀ (x_1 : G) , ¬ ((¬ (x_1 = 1)) ∧ (x ∈ x_1 • s)))
failed to synthesize instance
  HSMul G (Set α) ?m.940 ; identifiers [G, u_2, α, u_1, Group, G, MulAction, G, α, s, Set, α, x, α, x_1, G, x_1, x, x_1, s, x_1, G, x_1, x, x_1, s] (during elaboration)

{G : Type u_2} {α : Type u_1} [Group G] [MulAction G α] {s : Set α} {x : α}  : ∀ (x_1 : G) , (¬ ((¬ (x_1 = 1)) ∧ (x ∈ x_1 • s))) = (∀ (a : ¬ (x_1 = 1)) , ¬ (x ∈ x_1 • s))
failed to synthesize instance
  HSMul G (Set α) ?m.939 ; identifiers [G, u_2, α, u_1, Group, G, MulAction, G, α, s, Set, α, x, α, x_1, G, x_1, x, x_1, s, a, x_1, x, x_1, s] (during elaboration)

 : (∀ {α : Type u_2} {n : Type u_1} {m : Type u_3} [inst : Mul α] [inst_1 : AddCommMonoid α] (A : Matrix m n α) [inst_2 : Fintype n] , (Matrix.HasOrthogonalCols Matrix.transpose A) ↔ (Matrix.HasOrthogonalRows A))
function expected at
  Matrix.HasOrthogonalCols Matrix.transpose
term has type
  Prop ; identifiers [α, u_2, n, u_1, m, u_3, inst, Mul, α, inst_1, AddCommMonoid, α, A, Matrix, m, n, α, inst_2, Fintype, n, Matrix.HasOrthogonalCols, Matrix.transpose, A, Matrix.HasOrthogonalRows, A] (during elaboration)

{α : Type u_1} [DecidableEq α] [PartialOrder α] [OrderTop α] [SuccOrder α] {a : WithTop α} {b : WithTop α} (h : a < fun (a : WithTop α) ↦ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop α) ↦ WithTop α a fun (_ : Unit) ↦ ⊤ fun (a : α) ↦ if (a = ⊤ : Prop) then ⊤ else ↑ Order.succ a b) (h_1 : a = none)  : none = a
function expected at
  WithTop α
term has type
  Type u_1 ; identifiers [α, u_1, DecidableEq, α, PartialOrder, α, OrderTop, α, SuccOrder, α, a, WithTop, α, b, WithTop, α, h, a, a, WithTop, α, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, α, WithTop, α, a, Unit, a, α, a, Order.succ, a, b, h_1, a, none, none, a] (during elaboration)

 : ∀ {α : Type u_2} {n : Type u_1} {m : Type u_3} [inst : Mul α] [inst_1 : AddCommMonoid α] (A : Matrix m n α) [inst_2 : Fintype n] , (Matrix.HasOrthogonalCols Matrix.transpose A) ↔ (Matrix.HasOrthogonalCols Matrix.transpose A)
function expected at
  Matrix.HasOrthogonalCols Matrix.transpose
term has type
  Prop ; identifiers [α, u_2, n, u_1, m, u_3, inst, Mul, α, inst_1, AddCommMonoid, α, A, Matrix, m, n, α, inst_2, Fintype, n, Matrix.HasOrthogonalCols, Matrix.transpose, A, Matrix.HasOrthogonalCols, Matrix.transpose, A] (during elaboration)

(p : ℕ) [inst : Fact (Nat.Prime p : Prop)]  : fun (x : ℕ) ↦ ↑ x = fun (x : ℕ) ↦ ↑ x
type expected, got
  (fun x => ?m.158240 x = fun x_1 => ?m.158241 x x_1 : ℕ → Prop) ; identifiers [p, inst, Fact, Nat.Prime, p, x, x, x, x] (during elaboration)

 : (∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {K : NNReal} {f : (a : α) → β} (hf : LipschitzWith K f) {p : (a : β) → Prop} (hp : ∀ (x : α) , p f x) , LipschitzWith K fun (x : α) ↦ {val := ((f x)) , property := (((hp x)))})
application type mismatch
  p f
argument
  f
has type
  α → β : Type (max u v)
but is expected to have type
  β : Type v ; identifiers [α, u, β, v, inst, PseudoEMetricSpace, α, inst_1, PseudoEMetricSpace, β, K, NNReal, f, a, α, β, hf, LipschitzWith, K, f, p, a, β, hp, x, α, p, f, x, LipschitzWith, K, x, α, val, f, x, property, hp, x] (during elaboration)

 : ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {K : NNReal} {f : (a : α) → β} (hf : LipschitzWith K f) {p : (a : β) → Prop} (hp : ∀ (x : α) , p f x) , LipschitzWith K f
application type mismatch
  p f
argument
  f
has type
  α → β : Type (max u v)
but is expected to have type
  β : Type v ; identifiers [α, u, β, v, inst, PseudoEMetricSpace, α, inst_1, PseudoEMetricSpace, β, K, NNReal, f, a, α, β, hf, LipschitzWith, K, f, p, a, β, hp, x, α, p, f, x, LipschitzWith, K, f] (during elaboration)

 : (∀ {B : Type u_1} {F : Type u_2} {E : (a : B) → Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F] [inst_2 : (x : B) → TopologicalSpace E x] (self : FiberPrebundle F E) (e : Pretrivialization F Bundle.TotalSpace.proj) (a : e ∈ FiberPrebundle.pretrivializationAtlas self) (e' : Pretrivialization F Bundle.TotalSpace.proj) (a : e' ∈ FiberPrebundle.pretrivializationAtlas self) , ContinuousOn ↑ e ∘ ↑ LocalEquiv.symm Pretrivialization.toLocalEquiv e' LocalEquiv.target Pretrivialization.toLocalEquiv e' ∩ ↑ LocalEquiv.symm Pretrivialization.toLocalEquiv e' ⁻¹' LocalEquiv.source Pretrivialization.toLocalEquiv e)
application type mismatch
  TopologicalSpace E
argument
  E
has type
  B → Type u_3 : Type (max u_1 (u_3 + 1))
but is expected to have type
  Type ?u.21 : Type (?u.21 + 1) ; identifiers [B, u_1, F, u_2, E, a, B, u_3, inst, TopologicalSpace, B, inst_1, TopologicalSpace, F, inst_2, x, B, TopologicalSpace, E, x, self, FiberPrebundle, F, E, e, Pretrivialization, F, Bundle.TotalSpace.proj, a, e, FiberPrebundle.pretrivializationAtlas, self, e', Pretrivialization, F, Bundle.TotalSpace.proj, a, e', FiberPrebundle.pretrivializationAtlas, self, ContinuousOn, e, LocalEquiv.symm, Pretrivialization.toLocalEquiv, e', LocalEquiv.target, Pretrivialization.toLocalEquiv, e', LocalEquiv.symm, Pretrivialization.toLocalEquiv, e', LocalEquiv.source, Pretrivialization.toLocalEquiv, e] (during elaboration)

 : ∀ (B : Type u_1) (F : Type u_2) (E : (a : B) → Type u_3) [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F] [inst_2 : (x : B) → TopologicalSpace E x] (self : FiberPrebundle F E) (e : Pretrivialization F Bundle.TotalSpace.proj) (a : e ∈ self . 1) (e' : Pretrivialization F Bundle.TotalSpace.proj) (a : e' ∈ self . 1) , ContinuousOn ↑ e ∘ ↑ LocalEquiv.symm Pretrivialization.toLocalEquiv e' LocalEquiv.target Pretrivialization.toLocalEquiv e' ∩ ↑ LocalEquiv.symm Pretrivialization.toLocalEquiv e' ⁻¹' LocalEquiv.source Pretrivialization.toLocalEquiv e
application type mismatch
  TopologicalSpace E
argument
  E
has type
  B → Type u_3 : Type (max u_1 (u_3 + 1))
but is expected to have type
  Type ?u.21 : Type (?u.21 + 1) ; identifiers [B, u_1, F, u_2, E, a, B, u_3, inst, TopologicalSpace, B, inst_1, TopologicalSpace, F, inst_2, x, B, TopologicalSpace, E, x, self, FiberPrebundle, F, E, e, Pretrivialization, F, Bundle.TotalSpace.proj, a, e, self, e', Pretrivialization, F, Bundle.TotalSpace.proj, a, e', self, ContinuousOn, e, LocalEquiv.symm, Pretrivialization.toLocalEquiv, e', LocalEquiv.target, Pretrivialization.toLocalEquiv, e', LocalEquiv.symm, Pretrivialization.toLocalEquiv, e', LocalEquiv.source, Pretrivialization.toLocalEquiv, e] (during elaboration)

{G : Type u_1} [Group G] (x : Subgroup G) (toSubmonoid : Submonoid G) (inv_mem' : ∀ {x : G} (a : x ∈ Subsemigroup.carrier Submonoid.toSubsemigroup toSubmonoid) , x ⁻¹ ∈ Subsemigroup.carrier Submonoid.toSubsemigroup toSubmonoid) (h : x = {toSubmonoid := ((toSubmonoid)) , inv_mem' := ((inv_mem'))})  : {toSubmonoid := ((toSubmonoid)) , inv_mem' := ((inv_mem'))} = x
failed to synthesize instance
  Mul (Submonoid G) ; identifiers [G, u_1, Group, G, x, Subgroup, G, toSubmonoid, Submonoid, G, inv_mem', x, G, a, x, Subsemigroup.carrier, Submonoid.toSubsemigroup, toSubmonoid, x, Subsemigroup.carrier, Submonoid.toSubsemigroup, toSubmonoid, h, x, toSubmonoid, toSubmonoid, inv_mem', inv_mem', toSubmonoid, toSubmonoid, inv_mem', inv_mem', x] (during elaboration)

{R : Type u_1} [LinearOrderedSemifield R] [FloorSemiring R] {b : ℕ} (hb : b ≤ 1) (r : R) (h : 1 ≤ r) (h_1 : (le_total 1 r =: (1 ≤ r : Prop) ∨ (r ≤ 1 : Prop)) = (Or.inl h =: (1 ≤ r : Prop) ∨ (r ≤ 1 : Prop)))  : (Or.inl h) = (le_total 1 r)
<input>:1:123: expected term

{α : Type u_1} [DecidableEq α] [PartialOrder α] [OrderTop α] [SuccOrder α] {a : WithTop α} {b : WithTop α} (h : a < fun (a : WithTop α) ↦ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop α) ↦ WithTop α a fun (_ : Unit) ↦ ⊤ fun (a : α) ↦ if (a = ⊤ : Prop) then ⊤ else ↑ Order.succ a b) (val : α) (h_1 : a = some val) (h : some val < fun (a : WithTop α) ↦ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop α) ↦ WithTop α a fun (_ : Unit) ↦ ⊤ fun (a : α) ↦ if (a = ⊤ : Prop) then ⊤ else ↑ Order.succ a b) (h_2 : b = none)  : none = b
function expected at
  WithTop α
term has type
  Type u_1 ; identifiers [α, u_1, DecidableEq, α, PartialOrder, α, OrderTop, α, SuccOrder, α, a, WithTop, α, b, WithTop, α, h, a, a, WithTop, α, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, α, WithTop, α, a, Unit, a, α, a, Order.succ, a, b, val, α, h_1, a, some, val, h, some, val, a, WithTop, α, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, α, WithTop, α, a, Unit, a, α, a, Order.succ, a, b, h_2, b, none, none, b] (during elaboration)

 : (∀ {α : Type u_1} {β : Type u_1} {r : (a : α) → (a : α) → Prop} {s : (a : β) → (a : β) → Prop} [inst : IsWellOrder α r] [inst_1 : IsWellOrder β s] , (Ordinal.type r < Ordinal.type s) ↔ (Nonempty r ≺i s))
application type mismatch
  Nonempty r
argument
  r
has type
  α → α → Prop : Type u_1
but is expected to have type
  Sort ?u.102 : Type ?u.102 ; identifiers [α, u_1, β, u_1, r, a, α, a, α, s, a, β, a, β, inst, IsWellOrder, α, r, inst_1, IsWellOrder, β, s, Ordinal.type, r, Ordinal.type, s, Nonempty, r, s] (during elaboration)

{α : Type u_3} {M : Type u_2} {N : Type u_4} {R : Type u_1} [Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N] ⦃ φ : α →₀ M →ₗ[R] N ⦄ ⦃ ψ : α →₀ M →ₗ[R] N ⦄ (h : ∀ (a : α) , LinearMap.comp φ Finsupp.lsingle a = LinearMap.comp ψ Finsupp.lsingle a) (a : α)  : LinearMap.comp φ Finsupp.lsingle a = LinearMap.comp ψ Finsupp.lsingle a
function expected at
  LinearMap.comp ?m.2063 ?m.4985
term has type
  ?m.685 →ₛₗ[?m.699] ?m.687 ; identifiers [α, u_3, M, u_2, N, u_4, R, u_1, Semiring, R, AddCommMonoid, M, Module, R, M, AddCommMonoid, N, Module, R, N, φ, α, M, R, N, ψ, α, M, R, N, h, a, α, LinearMap.comp, φ, Finsupp.lsingle, a, LinearMap.comp, ψ, Finsupp.lsingle, a, a, α, LinearMap.comp, φ, Finsupp.lsingle, a, LinearMap.comp, ψ, Finsupp.lsingle, a] (during elaboration)

{α : Type u} {β : Type u_1} [AddGroup α] [Preorder α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] [Preorder β] {f : (a : β) → α} {s : Set β} (hf : StrictMonoOn f s) (x : β) (hx : x ∈ s) (x_1 : β) (hy : x_1 ∈ s) (hxy : x < x_1)  : f x < f x_1
function expected at
  x_1
term has type
  α ; identifiers [α, u, β, u_1, AddGroup, α, Preorder, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, Preorder, β, f, a, β, α, s, Set, β, hf, StrictMonoOn, f, s, x, β, hx, x, s, x_1, β, hy, x_1, s, hxy, x, x_1, f, x, f, x_1] (during elaboration)

{R : Type u_1} [LinearOrderedSemifield R] [FloorSemiring R] {b : ℕ} (hb : b ≤ 1) (r : R) (h : 1 ≤ r) (h_1 : (le_total 1 r =: (1 ≤ r : Prop) ∨ (r ≤ 1 : Prop)) = (Or.inl h =: (1 ≤ r : Prop) ∨ (r ≤ 1 : Prop)))  : (↑ 0 = 0) = (↑ 0 = 0)
<input>:1:123: expected term

{R : Type u_1} [LinearOrderedSemifield R] [FloorSemiring R] {b : ℕ} (hb : b ≤ 1) (r : R) (h : 1 ≤ r) (h_1 : (le_total 1 r =: (1 ≤ r : Prop) ∨ (r ≤ 1 : Prop)) = (Or.inl h =: (1 ≤ r : Prop) ∨ (r ≤ 1 : Prop)))  : 0 = 0
<input>:1:123: expected term

{R : Type u_1} [LinearOrderedSemifield R] [FloorSemiring R] {b : ℕ} (hb : b ≤ 1) (r : R) (h : r ≤ 1) (h_1 : (le_total 1 r =: (1 ≤ r : Prop) ∨ (r ≤ 1 : Prop)) = (Or.inr h =: (1 ≤ r : Prop) ∨ (r ≤ 1 : Prop)))  : (Or.inr h) = (le_total 1 r)
<input>:1:123: expected term

{α : Type u_1} {β : Type u_2} [DecidableEq α] [DecidableEq β] (f : (a : α) → β) (hf : Function.Injective f) (x : α) (s : Multiset α) ⦃ y : α ⦄ {s : Multiset α} (ih : Multiset.map f Multiset.erase s x = Multiset.erase Multiset.map f s f x) (h : x = y) ⦃ y : α ⦄  : y = y
application type mismatch
  Multiset.map f Multiset.erase
argument
  Multiset.erase
has type
  Multiset ?m.68 → ?m.68 → Multiset ?m.68 : Type ?u.67
but is expected to have type
  Multiset α : Type u_1 ; identifiers [α, u_1, β, u_2, DecidableEq, α, DecidableEq, β, f, a, α, β, hf, Function.Injective, f, x, α, s, Multiset, α, y, α, s, Multiset, α, ih, Multiset.map, f, Multiset.erase, s, x, Multiset.erase, Multiset.map, f, s, f, x, h, x, y, y, α, y, y] (during elaboration)

{X : CompHaus} {Y : CompHaus} {B : CompHaus} (f : X ⟶ B) (g : Y ⟶ B) (x : CategoryTheory.Functor.toPrefunctor CategoryTheory.forget CompHaus . obj CompHaus.pullback f g)  : ∀ (val : ↑ CompHaus.toTop X × ↑ CompHaus.toTop Y) (h : val ∈ {xy : ↑ CompHaus.toTop X × ↑ CompHaus.toTop Y | ↑ f Prod.fst xy = ↑ g Prod.snd xy}) , val ∈ {xy : ↑ CompHaus.toTop X × ↑ CompHaus.toTop Y | ↑ f Prod.fst xy = ↑ g Prod.snd xy}
function expected at
  ?m.330.toPrefunctor
term has type
  ?m.157 ⥤q ?m.159 ; identifiers [X, CompHaus, Y, CompHaus, B, CompHaus, f, X, B, g, Y, B, x, CategoryTheory.Functor.toPrefunctor, CategoryTheory.forget, CompHaus, obj, CompHaus.pullback, f, g, val, CompHaus.toTop, X, CompHaus.toTop, Y, h, val, xy, CompHaus.toTop, X, CompHaus.toTop, Y, f, Prod.fst, xy, g, Prod.snd, xy, val, xy, CompHaus.toTop, X, CompHaus.toTop, Y, f, Prod.fst, xy, g, Prod.snd, xy] (during elaboration)

{c : Cardinal .{u_1}} (h : ∀ (n : ℕ) , ↑ n ≤ c) (hn : c < Cardinal.aleph0) (n : ℕ) (h_1 : c = ↑ n)  : ↑ n = c
<input>:1:14: expected '//', '|' or '}'

{R : Type u_1} [LinearOrderedSemifield R] [FloorSemiring R] {b : ℕ} (hb : b ≤ 1) (r : R) (h : r ≤ 1) (h_1 : (le_total 1 r =: (1 ≤ r : Prop) ∨ (r ≤ 1 : Prop)) = (Or.inr h =: (1 ≤ r : Prop) ∨ (r ≤ 1 : Prop)))  : (- ↑ 0 = 0) = (- ↑ 0 = 0)
<input>:1:123: expected term

{R : Type u_1} [LinearOrderedSemifield R] [FloorSemiring R] {b : ℕ} (hb : b ≤ 1) (r : R) (h : r ≤ 1) (h_1 : (le_total 1 r =: (1 ≤ r : Prop) ∨ (r ≤ 1 : Prop)) = (Or.inr h =: (1 ≤ r : Prop) ∨ (r ≤ 1 : Prop)))  : (- 0 = 0) = (- 0 = 0)
<input>:1:123: expected term

{R : Type u_1} [LinearOrderedSemifield R] [FloorSemiring R] {b : ℕ} (hb : b ≤ 1) (r : R) (h : r ≤ 1) (h_1 : (le_total 1 r =: (1 ≤ r : Prop) ∨ (r ≤ 1 : Prop)) = (Or.inr h =: (1 ≤ r : Prop) ∨ (r ≤ 1 : Prop)))  : 0 = 0
<input>:1:123: expected term

{α : Type u_1} [DecidableEq α] [PartialOrder α] [OrderTop α] [SuccOrder α] {a : WithTop α} {b : WithTop α} (h : a < fun (a : WithTop α) ↦ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop α) ↦ WithTop α a fun (_ : Unit) ↦ ⊤ fun (a : α) ↦ if (a = ⊤ : Prop) then ⊤ else ↑ Order.succ a b) (val : α) (h_1 : a = some val) (h : some val < fun (a : WithTop α) ↦ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop α) ↦ WithTop α a fun (_ : Unit) ↦ ⊤ fun (a : α) ↦ if (a = ⊤ : Prop) then ⊤ else ↑ Order.succ a b) (val_1 : α) (h_2 : b = some val_1) (h : some val < fun (a : WithTop α) ↦ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop α) ↦ WithTop α a fun (_ : Unit) ↦ ⊤ fun (a : α) ↦ if (a = ⊤ : Prop) then ⊤ else ↑ Order.succ a some val_1)  : (val ≤ val_1) = (val ≤ val_1)
function expected at
  WithTop α
term has type
  Type u_1 ; identifiers [α, u_1, DecidableEq, α, PartialOrder, α, OrderTop, α, SuccOrder, α, a, WithTop, α, b, WithTop, α, h, a, a, WithTop, α, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, α, WithTop, α, a, Unit, a, α, a, Order.succ, a, b, val, α, h_1, a, some, val, h, some, val, a, WithTop, α, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, α, WithTop, α, a, Unit, a, α, a, Order.succ, a, b, val_1, α, h_2, b, some, val_1, h, some, val, a, WithTop, α, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, α, WithTop, α, a, Unit, a, α, a, Order.succ, a, some, val_1, val, val_1, val, val_1] (during elaboration)

{α : Type uu} {r : (a : α) → (a : α) → Prop} [DecidableRel r] (x : List α) (x_1 : List.Sorted r x) (x : List α) (f : List.below (motive := fun (x : List α) ↦ ∀ (x_2 : List.Sorted r x) , List.insertionSort r x = x) x) (x_2 : List.Sorted r x) (a : α) (b : α) (l : List α) (h : List.Sorted r a :: b :: l) (x : List.below (motive := fun (x : List α) ↦ ∀ (x_3 : List.Sorted r x) , List.insertionSort r x = x) a :: b :: l)  : a :: b :: l = a :: b :: l
application type mismatch
  List.Sorted r a
argument
  a
has type
  α : Type uu
but is expected to have type
  List α : Type uu ; identifiers [α, uu, r, a, α, a, α, DecidableRel, r, x, List, α, x_1, List.Sorted, r, x, x, List, α, f, List.below, motive, x, List, α, x_2, List.Sorted, r, x, List.insertionSort, r, x, x, x, x_2, List.Sorted, r, x, a, α, b, α, l, List, α, h, List.Sorted, r, a, b, l, x, List.below, motive, x, List, α, x_3, List.Sorted, r, x, List.insertionSort, r, x, x, a, b, l, a, b, l, a, b, l] (during elaboration)

 : (∀ {G : Type u_1} [inst : AddGroup G] (self : NonarchAddGroupSeminorm G) (r : G) (s : G) , ZeroHom.toFun NonarchAddGroupSeminorm.toZeroHom self r + s ≤ max ZeroHom.toFun NonarchAddGroupSeminorm.toZeroHom self r ZeroHom.toFun NonarchAddGroupSeminorm.toZeroHom self s)
function expected at
  ZeroHom.toFun ?m.665 self
term has type
  ?m.30 ; identifiers [G, u_1, inst, AddGroup, G, self, NonarchAddGroupSeminorm, G, r, G, s, G, ZeroHom.toFun, NonarchAddGroupSeminorm.toZeroHom, self, r, s, max, ZeroHom.toFun, NonarchAddGroupSeminorm.toZeroHom, self, r, ZeroHom.toFun, NonarchAddGroupSeminorm.toZeroHom, self, s] (during elaboration)

 : ∀ (G : Type u_1) [inst : AddGroup G] (self : NonarchAddGroupSeminorm G) (r : G) (s : G) , ZeroHom.toFun self . 1 r + s ≤ max ZeroHom.toFun self . 1 r ZeroHom.toFun self . 1 s
invalid occurrence of `·` notation, it must be surrounded by parentheses (e.g. `(· + 1)`) ; identifiers [G, u_1, inst, AddGroup, G, self, NonarchAddGroupSeminorm, G, r, G, s, G, ZeroHom.toFun, self, r, s, max, ZeroHom.toFun, self, r, ZeroHom.toFun, self, s] (during elaboration)

{α : Type u_1} {β : Type u_2} [DecidableEq α] [DecidableEq β] (f : (a : α) → β) (hf : Function.Injective f) (x : α) (s : Multiset α) ⦃ y : α ⦄ {s : Multiset α} (ih : Multiset.map f Multiset.erase s x = Multiset.erase Multiset.map f s f x) (h : x = y) (hxy : x = x) (h : HEq hxy (Eq.refl x =: x = x))  : ∀ (x : α) (a : x ∈ s) , f x = f x
<input>:1:290: expected term

{α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [IsROrC 𝕜] [NormedAddCommGroup E] [NormedSpace 𝕜 E] [NormedAddCommGroup F] [CompleteSpace F] {u : (a : α) → ℝ} [NormedSpace 𝕜 F] {f : (a : α) → (a : E) → F} {f' : (a : α) → (a : E) → E →L[𝕜] F} {x₀ : E} (hu : Summable u) (hf : ∀ (n : α) (x : E) , HasFDerivAt f n f' n x x) (hf' : ∀ (n : α) (x : E) , ‖ f' n x ‖ ≤ u n) (hf0 : Summable fun (n : α) ↦ f n x₀) (x : E) x_1 : NormedSpace ℝ E := NormedSpace.restrictScalars ℝ 𝕜 E  : ∀ (n : α) (x : E) (x_2 : x ∈ Set.univ) , HasFDerivAt f n f' n x x
<input>:1:371: expected term

{α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [IsROrC 𝕜] [NormedAddCommGroup E] [NormedSpace 𝕜 E] [NormedAddCommGroup F] [CompleteSpace F] {u : (a : α) → ℝ} [NormedSpace 𝕜 F] {f : (a : α) → (a : E) → F} {f' : (a : α) → (a : E) → E →L[𝕜] F} {x₀ : E} (hu : Summable u) (hf : ∀ (n : α) (x : E) , HasFDerivAt f n f' n x x) (hf' : ∀ (n : α) (x : E) , ‖ f' n x ‖ ≤ u n) (hf0 : Summable fun (n : α) ↦ f n x₀) (x : E) x_1 : NormedSpace ℝ E := NormedSpace.restrictScalars ℝ 𝕜 E  : ∀ (n : α) (x : E) (x_2 : x ∈ Set.univ) , ‖ f' n x ‖ ≤ u n
<input>:1:371: expected term

{α : Type u_1} {β : Type u_2} [DecidableEq α] [DecidableEq β] (f : (a : α) → β) (hf : Function.Injective f) (x : α) (s : Multiset α) ⦃ y : α ⦄ {s : Multiset α} (ih : Multiset.map f Multiset.erase s x = Multiset.erase Multiset.map f s f x)  : x = x
application type mismatch
  Multiset.map f Multiset.erase
argument
  Multiset.erase
has type
  Multiset ?m.68 → ?m.68 → Multiset ?m.68 : Type ?u.67
but is expected to have type
  Multiset α : Type u_1 ; identifiers [α, u_1, β, u_2, DecidableEq, α, DecidableEq, β, f, a, α, β, hf, Function.Injective, f, x, α, s, Multiset, α, y, α, s, Multiset, α, ih, Multiset.map, f, Multiset.erase, s, x, Multiset.erase, Multiset.map, f, s, f, x, x, x] (during elaboration)

{α : Type u_1} [DecidableEq α] [PartialOrder α] [OrderTop α] [SuccOrder α] {a : WithTop α} {b : WithTop α} (h : a < fun (a : WithTop α) ↦ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop α) ↦ WithTop α a fun (_ : Unit) ↦ ⊤ fun (a : α) ↦ if (a = ⊤ : Prop) then ⊤ else ↑ Order.succ a b) (val : α) (h_1 : a = some val) (h : some val < fun (a : WithTop α) ↦ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop α) ↦ WithTop α a fun (_ : Unit) ↦ ⊤ fun (a : α) ↦ if (a = ⊤ : Prop) then ⊤ else ↑ Order.succ a b) (val_1 : α) (h_2 : b = some val_1)  : some val_1 = b
function expected at
  WithTop α
term has type
  Type u_1 ; identifiers [α, u_1, DecidableEq, α, PartialOrder, α, OrderTop, α, SuccOrder, α, a, WithTop, α, b, WithTop, α, h, a, a, WithTop, α, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, α, WithTop, α, a, Unit, a, α, a, Order.succ, a, b, val, α, h_1, a, some, val, h, some, val, a, WithTop, α, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, α, WithTop, α, a, Unit, a, α, a, Order.succ, a, b, val_1, α, h_2, b, some, val_1, some, val_1, b] (during elaboration)

{α : Type u_1} [DecidableEq α] [PartialOrder α] [OrderTop α] [SuccOrder α] {a : WithTop α} {b : WithTop α} (h : a < fun (a : WithTop α) ↦ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop α) ↦ WithTop α a fun (_ : Unit) ↦ ⊤ fun (a : α) ↦ if (a = ⊤ : Prop) then ⊤ else ↑ Order.succ a b) (val : α) (h_1 : a = some val) (h : some val < fun (a : WithTop α) ↦ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop α) ↦ WithTop α a fun (_ : Unit) ↦ ⊤ fun (a : α) ↦ if (a = ⊤ : Prop) then ⊤ else ↑ Order.succ a b)  : b = b
function expected at
  WithTop α
term has type
  Type u_1 ; identifiers [α, u_1, DecidableEq, α, PartialOrder, α, OrderTop, α, SuccOrder, α, a, WithTop, α, b, WithTop, α, h, a, a, WithTop, α, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, α, WithTop, α, a, Unit, a, α, a, Order.succ, a, b, val, α, h_1, a, some, val, h, some, val, a, WithTop, α, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, α, WithTop, α, a, Unit, a, α, a, Order.succ, a, b, b, b] (during elaboration)

{α : Type u_1} [DecidableEq α] [PartialOrder α] [OrderTop α] [SuccOrder α] {a : WithTop α} {b : WithTop α} (h : a < fun (a : WithTop α) ↦ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop α) ↦ WithTop α a fun (_ : Unit) ↦ ⊤ fun (a : α) ↦ if (a = ⊤ : Prop) then ⊤ else ↑ Order.succ a b) (val : α) (h_1 : a = some val)  : some val = a
function expected at
  WithTop α
term has type
  Type u_1 ; identifiers [α, u_1, DecidableEq, α, PartialOrder, α, OrderTop, α, SuccOrder, α, a, WithTop, α, b, WithTop, α, h, a, a, WithTop, α, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, α, WithTop, α, a, Unit, a, α, a, Order.succ, a, b, val, α, h_1, a, some, val, some, val, a] (during elaboration)

{α : Type u_1} [DecidableEq α] [PartialOrder α] [OrderTop α] [SuccOrder α] {a : WithTop α} {b : WithTop α} (h : a < fun (a : WithTop α) ↦ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop α) ↦ WithTop α a fun (_ : Unit) ↦ ⊤ fun (a : α) ↦ if (a = ⊤ : Prop) then ⊤ else ↑ Order.succ a b)  : a = a
function expected at
  WithTop α
term has type
  Type u_1 ; identifiers [α, u_1, DecidableEq, α, PartialOrder, α, OrderTop, α, SuccOrder, α, a, WithTop, α, b, WithTop, α, h, a, a, WithTop, α, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, α, WithTop, α, a, Unit, a, α, a, Order.succ, a, b, a, a] (during elaboration)

{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] {ifp_n : GeneralizedContinuedFraction.IntFractPair K} (nth_stream_eq : GeneralizedContinuedFraction.IntFractPair.stream v n = some ifp_n) (n_1 : ℕ) (h : n = Nat.succ n_1) (nth_stream_eq : GeneralizedContinuedFraction.IntFractPair.stream v Nat.succ n_1 = some ifp_n) (w : GeneralizedContinuedFraction.IntFractPair K) (h : (GeneralizedContinuedFraction.IntFractPair.stream v n_1 = some w : Prop) ∧ ((GeneralizedContinuedFraction.IntFractPair.fr w ≠ 0 : Prop) ∧ (GeneralizedContinuedFraction.IntFractPair.of GeneralizedContinuedFraction.IntFractPair.fr w ⁻¹ = ifp_n : Prop) : Prop)) (left : GeneralizedContinuedFraction.IntFractPair.stream v n_1 = some w) (right : (GeneralizedContinuedFraction.IntFractPair.fr w ≠ 0 : Prop) ∧ (GeneralizedContinuedFraction.IntFractPair.of GeneralizedContinuedFraction.IntFractPair.fr w ⁻¹ = ifp_n : Prop)) (left : GeneralizedContinuedFraction.IntFractPair.fr w ≠ 0) (ifp_of_eq_ifp_n : GeneralizedContinuedFraction.IntFractPair.of GeneralizedContinuedFraction.IntFractPair.fr w ⁻¹ = ifp_n)  : ifp_n = GeneralizedContinuedFraction.IntFractPair.of GeneralizedContinuedFraction.IntFractPair.fr w ⁻¹
application type mismatch
  GeneralizedContinuedFraction.IntFractPair.stream v Nat.succ
argument
  Nat.succ
has type
  ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [K, u_1, v, K, n, LinearOrderedField, K, FloorRing, K, ifp_n, GeneralizedContinuedFraction.IntFractPair, K, nth_stream_eq, GeneralizedContinuedFraction.IntFractPair.stream, v, n, some, ifp_n, n_1, h, n, Nat.succ, n_1, nth_stream_eq, GeneralizedContinuedFraction.IntFractPair.stream, v, Nat.succ, n_1, some, ifp_n, w, GeneralizedContinuedFraction.IntFractPair, K, h, GeneralizedContinuedFraction.IntFractPair.stream, v, n_1, some, w, GeneralizedContinuedFraction.IntFractPair.fr, w, GeneralizedContinuedFraction.IntFractPair.of, GeneralizedContinuedFraction.IntFractPair.fr, w, ifp_n, left, GeneralizedContinuedFraction.IntFractPair.stream, v, n_1, some, w, right, GeneralizedContinuedFraction.IntFractPair.fr, w, GeneralizedContinuedFraction.IntFractPair.of, GeneralizedContinuedFraction.IntFractPair.fr, w, ifp_n, left, GeneralizedContinuedFraction.IntFractPair.fr, w, ifp_of_eq_ifp_n, GeneralizedContinuedFraction.IntFractPair.of, GeneralizedContinuedFraction.IntFractPair.fr, w, ifp_n, ifp_n, GeneralizedContinuedFraction.IntFractPair.of, GeneralizedContinuedFraction.IntFractPair.fr, w] (during elaboration)

{R : Type u} [CommSemiring R] {I : Ideal R} (hi : Ideal.IsPrimary I) {x : R} {y : R} (x_1 : x * y ∈ Ideal.radical I) (m : ℕ) (hxy : x * y ^ m ∈ I) (h : x ^ m ∈ I) (h_1 : (And.right hi (Eq.mp ((mul_pow x y m =: x * y ^ m = x ^ m * y ^ m) ▸ (Eq.refl (x * y ^ m ∈ I : Prop) =: (x * y ^ m ∈ I : Prop) = (x * y ^ m ∈ I : Prop)) =: (x * y ^ m ∈ I : Prop) = (x ^ m * y ^ m ∈ I : Prop)) hxy =: x ^ m * y ^ m ∈ I) =: (x ^ m ∈ I : Prop) ∨ (y ^ m ∈ Ideal.radical I : Prop)) = (Or.inl h =: (x ^ m ∈ I : Prop) ∨ (y ^ m ∈ Ideal.radical I : Prop)))  : (Or.inl h) = (And.right hi (Eq.mp ((mul_pow x y m) ▸ (Eq.refl (x * y ^ m ∈ I))) hxy))
<input>:1:208: expected term

{α : Type u_2} {β : Type u_1} [AddCommMonoid α] [TopologicalSpace α] {f : (a : β) → α} (h : Set.Finite Function.support f) (b : β)  : (f b = 0) = (f b = 0)
function expected at
  Set.Finite ?m.842
term has type
  Prop ; identifiers [α, u_2, β, u_1, AddCommMonoid, α, TopologicalSpace, α, f, a, β, α, h, Set.Finite, Function.support, f, b, β, f, b, f, b] (during elaboration)

 : (∀ {α : Type u} {β : Type v} {f : (a : α) → β} {a : α} {l : Filter β} , (Filter.Tendsto f pure a l) ↔ (∀ (s : Set β) (a_1 : s ∈ l) , f a ∈ s))
application type mismatch
  Filter.Tendsto f pure
argument
  pure
has type
  ?m.28 → ?m.26 ?m.28 : Type (max ?u.24 ?u.25)
but is expected to have type
  Filter α : Type u ; identifiers [α, u, β, v, f, a, α, β, a, α, l, Filter, β, Filter.Tendsto, f, pure, a, l, s, Set, β, a_1, s, l, f, a, s] (during elaboration)

 : ∀ {α : Type u} {β : Type v} {f : (a : α) → β} {a : α} {l : Filter β} , (Filter.Tendsto f pure a l) ↔ (Filter.Tendsto f pure a l)
application type mismatch
  Filter.Tendsto f pure
argument
  pure
has type
  ?m.28 → ?m.26 ?m.28 : Type (max ?u.24 ?u.25)
but is expected to have type
  Filter α : Type u ; identifiers [α, u, β, v, f, a, α, β, a, α, l, Filter, β, Filter.Tendsto, f, pure, a, l, Filter.Tendsto, f, pure, a, l] (during elaboration)

{α : Type u_2} {β : Type u_1} [AddCommMonoid α] [TopologicalSpace α] {f : (a : β) → α} (h : Set.Finite Function.support f) (b : β)  : (∀ (a : f b = 0) , f b = 0) = True
function expected at
  Set.Finite ?m.842
term has type
  Prop ; identifiers [α, u_2, β, u_1, AddCommMonoid, α, TopologicalSpace, α, f, a, β, α, h, Set.Finite, Function.support, f, b, β, a, f, b, f, b, True] (during elaboration)

{J : Type u₁} [inst : CategoryTheory.Category J] {C : Type u₃} [inst_1 : CategoryTheory.Category C] {F : CategoryTheory.Functor J C} {t : CategoryTheory.Limits.Cone F} (self : CategoryTheory.Limits.IsLimit t) (s : CategoryTheory.Limits.Cone F) (j : J)  : ∀ (J : Type u₁) [inst : CategoryTheory.Category J] (C : Type u₃) [inst_2 : CategoryTheory.Category C] (F : CategoryTheory.Functor J C) (t : CategoryTheory.Limits.Cone F) (self : CategoryTheory.Limits.IsLimit t) (s : CategoryTheory.Limits.Cone F) (j : J) , CategoryTheory.CategoryStruct.comp self . 1 s CategoryTheory.NatTrans.app CategoryTheory.Limits.Cone.π t j = CategoryTheory.NatTrans.app CategoryTheory.Limits.Cone.π s j
unknown universe level 'u₃' ; identifiers [J, u₁, inst, CategoryTheory.Category, J, C, u₃, inst_1, CategoryTheory.Category, C, F, CategoryTheory.Functor, J, C, t, CategoryTheory.Limits.Cone, F, self, CategoryTheory.Limits.IsLimit, t, s, CategoryTheory.Limits.Cone, F, j, J, J, u₁, inst, CategoryTheory.Category, J, C, u₃, inst_2, CategoryTheory.Category, C, F, CategoryTheory.Functor, J, C, t, CategoryTheory.Limits.Cone, F, self, CategoryTheory.Limits.IsLimit, t, s, CategoryTheory.Limits.Cone, F, j, J, CategoryTheory.CategoryStruct.comp, self, s, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cone.π, t, j, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cone.π, s, j] (during elaboration)

{R : Type u} [CommSemiring R] {I : Ideal R} (hi : Ideal.IsPrimary I) {x : R} {y : R} (x_1 : x * y ∈ Ideal.radical I) (m : ℕ) (hxy : x * y ^ m ∈ I) (h : y ^ m ∈ Ideal.radical I) (h_1 : (And.right hi (Eq.mp ((mul_pow x y m =: x * y ^ m = x ^ m * y ^ m) ▸ (Eq.refl (x * y ^ m ∈ I : Prop) =: (x * y ^ m ∈ I : Prop) = (x * y ^ m ∈ I : Prop)) =: (x * y ^ m ∈ I : Prop) = (x ^ m * y ^ m ∈ I : Prop)) hxy =: x ^ m * y ^ m ∈ I) =: (x ^ m ∈ I : Prop) ∨ (y ^ m ∈ Ideal.radical I : Prop)) = (Or.inr h =: (x ^ m ∈ I : Prop) ∨ (y ^ m ∈ Ideal.radical I : Prop)))  : (Or.inr h) = (And.right hi (Eq.mp ((mul_pow x y m) ▸ (Eq.refl (x * y ^ m ∈ I))) hxy))
<input>:1:222: expected term

{V : Type u_1} (G : SimpleGraph V) (s : Set Sym2 V) (a : V) (b : V)  : (∀ (a_1 : (SimpleGraph.Adj G a b) \ (Quotient.mk Sym2.Rel.setoid V (a , b) ∈ s)) , (SimpleGraph.Adj G a b) \ (Quotient.mk Sym2.Rel.setoid V (a , b) ∈ s)) = True
application type mismatch
  Set Sym2
argument
  Sym2
has type
  Type ?u.11 → Type ?u.11 : Type (?u.11 + 1)
but is expected to have type
  Type ?u.10 : Type (?u.10 + 1) ; identifiers [V, u_1, G, SimpleGraph, V, s, Set, Sym2, V, a, V, b, V, a_1, SimpleGraph.Adj, G, a, b, Quotient.mk, Sym2.Rel.setoid, V, a, b, s, SimpleGraph.Adj, G, a, b, Quotient.mk, Sym2.Rel.setoid, V, a, b, s, True] (during elaboration)

{C : Type u} [inst : CategoryTheory.Category C] [CategoryTheory.HasShift C ℤ] {T₁ : CategoryTheory.Pretriangulated.Triangle C} {T₂ : CategoryTheory.Pretriangulated.Triangle C} (self : CategoryTheory.Pretriangulated.TriangleMorphism T₁ T₂)  : ∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_2 : CategoryTheory.HasShift C ℤ] (T₁ : CategoryTheory.Pretriangulated.Triangle C) (T₂ : CategoryTheory.Pretriangulated.Triangle C) (self : CategoryTheory.Pretriangulated.TriangleMorphism T₁ T₂) , CategoryTheory.CategoryStruct.comp CategoryTheory.Pretriangulated.Triangle.mor₂ T₁ self . 3 = CategoryTheory.CategoryStruct.comp self . 2 CategoryTheory.Pretriangulated.Triangle.mor₂ T₂
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81555 ?m.161398
term has type
  ?m.961 ⟶ ?m.963 ; identifiers [C, u, inst, CategoryTheory.Category, C, CategoryTheory.HasShift, C, T₁, CategoryTheory.Pretriangulated.Triangle, C, T₂, CategoryTheory.Pretriangulated.Triangle, C, self, CategoryTheory.Pretriangulated.TriangleMorphism, T₁, T₂, C, u, inst, CategoryTheory.Category, C, inst_2, CategoryTheory.HasShift, C, T₁, CategoryTheory.Pretriangulated.Triangle, C, T₂, CategoryTheory.Pretriangulated.Triangle, C, self, CategoryTheory.Pretriangulated.TriangleMorphism, T₁, T₂, CategoryTheory.CategoryStruct.comp, CategoryTheory.Pretriangulated.Triangle.mor₂, T₁, self, CategoryTheory.CategoryStruct.comp, self, CategoryTheory.Pretriangulated.Triangle.mor₂, T₂] (during elaboration)

 : (∀ {α : Type u_1} [inst : Union α] {a : Part α} {b : Part α} (hab : Part.Dom a ∪ b) , Part.Dom a)
application type mismatch
  a.Dom ∪ b
argument
  b
has type
  Part α : Type u_1
but is expected to have type
  Prop : Type ; identifiers [α, u_1, inst, Union, α, a, Part, α, b, Part, α, hab, Part.Dom, a, b, Part.Dom, a] (during elaboration)

 : ∀ {α : Type u_1} [inst : Union α] {a : Part α} {b : Part α} (hab : Part.Dom a ∪ b) , Part.Dom fun (x : α) (x_1 : α) ↦ x ∪ x_1 <$> a
application type mismatch
  a.Dom ∪ b
argument
  b
has type
  Part α : Type u_1
but is expected to have type
  Prop : Type ; identifiers [α, u_1, inst, Union, α, a, Part, α, b, Part, α, hab, Part.Dom, a, b, Part.Dom, x, α, x_1, α, x, x_1, a] (during elaboration)

{𝕜 : Type u_1} {E : Type u_2} [SeminormedRing 𝕜] [SMul 𝕜 E] {s : Set E} {t : Set E} (ht : Balanced 𝕜 t) (h : s ⊆ t) ⦃ x : E ⦄ (hx : x ∈ balancedHull 𝕜 s) (r : 𝕜) (h_1 : ∃ (x_1 : ‖ r ‖ ≤ 1) , x ∈ r • s) (hr : ‖ r ‖ ≤ 1) (h_2 : x ∈ r • s) (y : E) (h_3 : (y ∈ s : Prop) ∧ (fun (x : E) ↦ r • x y = x : Prop)) (hy : y ∈ s) (right : fun (x : E) ↦ r • x y = x) (hx : fun (x : E) ↦ r • x y ∈ balancedHull 𝕜 s)  : y ∈ t
<input>:1:184: expected term

{a : Cardinal .{u_1}} {b : Cardinal .{u_1}} (h : b ≠ 0)  : (a ≤ a * b) = (a ≤ a * b)
<input>:1:14: expected '//', '|' or '}'

 : (∀ {c : (a : Type u) → Type u} {hom : ⦃ α : Type u ⦄ → ⦃ β : Type u ⦄ → (x : c α) → (x : c β) → Type u} (self : CategoryTheory.BundledHom hom) {α : Type u} {β : Type u} {γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ) , CategoryTheory.BundledHom.toFun self Iα Iγ CategoryTheory.BundledHom.comp self Iα Iβ Iγ g f = CategoryTheory.BundledHom.toFun self Iβ Iγ g ∘ CategoryTheory.BundledHom.toFun self Iα Iβ f)
application type mismatch
  CategoryTheory.BundledHom.toFun self Iα Iγ CategoryTheory.BundledHom.comp
argument
  CategoryTheory.BundledHom.comp
has type
  CategoryTheory.BundledHom ?m.85 →
    {α β γ : Type ?u.83} →
      (Iα : ?m.84 α) → (Iβ : ?m.84 β) → (Iγ : ?m.84 γ) → ?m.85 Iβ Iγ → ?m.85 Iα Iβ → ?m.85 Iα Iγ : Type (?u.83 + 1)
but is expected to have type
  hom Iα Iγ : Type u ; identifiers [c, a, u, u, hom, α, u, β, u, x, c, α, x, c, β, u, self, CategoryTheory.BundledHom, hom, α, u, β, u, γ, u, Iα, c, α, Iβ, c, β, Iγ, c, γ, f, hom, Iα, Iβ, g, hom, Iβ, Iγ, CategoryTheory.BundledHom.toFun, self, Iα, Iγ, CategoryTheory.BundledHom.comp, self, Iα, Iβ, Iγ, g, f, CategoryTheory.BundledHom.toFun, self, Iβ, Iγ, g, CategoryTheory.BundledHom.toFun, self, Iα, Iβ, f] (during elaboration)

 : ∀ (c : (a : Type u) → Type u) (hom : ⦃ α : Type u ⦄ → ⦃ β : Type u ⦄ → (x : c α) → (x : c β) → Type u) (self : CategoryTheory.BundledHom hom) {α : Type u} {β : Type u} {γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ) , self . 1 Iα Iγ self . 3 Iα Iβ Iγ g f = self . 1 Iβ Iγ g ∘ self . 1 Iα Iβ f
function expected at
  self
term has type
  CategoryTheory.BundledHom hom ; identifiers [c, a, u, u, hom, α, u, β, u, x, c, α, x, c, β, u, self, CategoryTheory.BundledHom, hom, α, u, β, u, γ, u, Iα, c, α, Iβ, c, β, Iγ, c, γ, f, hom, Iα, Iβ, g, hom, Iβ, Iγ, self, Iα, Iγ, self, Iα, Iβ, Iγ, g, f, self, Iβ, Iγ, g, self, Iα, Iβ, f] (during elaboration)

 : (∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {l : Filter α} {r : (a : β) → (a : γ) → Prop} {f : (a : α) → β} {g : (a : α) → γ} , (Filter.Germ.LiftRel r ↑ f ↑ g) ↔ (∀ᶠ (x : α) in l , r f x g x))
application type mismatch
  r f
argument
  f
has type
  α → β : Type (max u_1 u_2)
but is expected to have type
  β : Type u_2 ; identifiers [α, u_1, β, u_2, γ, u_3, l, Filter, α, r, a, β, a, γ, f, a, α, β, g, a, α, γ, Filter.Germ.LiftRel, r, f, g, x, α, l, r, f, x, g, x] (during elaboration)

 : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {l : Filter α} {r : (a : β) → (a : γ) → Prop} {f : (a : α) → β} {g : (a : α) → γ} , (Filter.Germ.LiftRel r ↑ f ↑ g) ↔ (Filter.Germ.LiftRel r ↑ f ↑ g)
type mismatch
  g
has type
  α → γ : Type (max u_1 u_3)
but is expected to have type
  Filter.Germ ?m.404 γ : Type (max ?u.218 u_3) ; identifiers [α, u_1, β, u_2, γ, u_3, l, Filter, α, r, a, β, a, γ, f, a, α, β, g, a, α, γ, Filter.Germ.LiftRel, r, f, g, Filter.Germ.LiftRel, r, f, g] (during elaboration)

{M : Type u_2} {N : Type u_1} [AddSemigroup M] [AddSemigroup N] {s : Set M} (f : (a : M) → N) (hs : AddSubsemigroup.closure s = ⊤) (hmul : ∀ (x : M) (y : M) (a : y ∈ s) , f x + y = f x + f y) (x : M) (y : M)  : ∀ (y : M) (hy : y ∈ s) (x : M) , f x + y = f x + f y
failed to synthesize instance
  HAdd N M ?m.159932 ; identifiers [M, u_2, N, u_1, AddSemigroup, M, AddSemigroup, N, s, Set, M, f, a, M, N, hs, AddSubsemigroup.closure, s, hmul, x, M, y, M, a, y, s, f, x, y, f, x, f, y, x, M, y, M, y, M, hy, y, s, x, M, f, x, y, f, x, f, y] (during elaboration)

 : ∀ (α : Type u_1) [inst : Lattice α] [inst_1 : OrderBot α] (a : α) (self : Finpartition a) , ¬ (⊥ ∈ self . 1)
function expected at
  self
term has type
  Finpartition a ; identifiers [α, u_1, inst, Lattice, α, inst_1, OrderBot, α, a, α, self, Finpartition, a, self] (during elaboration)

{M : Type u_2} {N : Type u_1} [AddSemigroup M] [AddSemigroup N] {s : Set M} (f : (a : M) → N) (hs : AddSubsemigroup.closure s = ⊤) (hmul : ∀ (x : M) (y : M) (a : y ∈ s) , f x + y = f x + f y) (x : M) (y : M) (y₁ : M) (y₂ : M) (h₁ : ∀ (x : M) , f x + y₁ = f x + f y₁) (h₂ : ∀ (x : M) , f x + y₂ = f x + f y₂) (x : M)  : ∀ (x : M) , f x + y₂ = f x + f y₂
failed to synthesize instance
  HAdd N M ?m.159932 ; identifiers [M, u_2, N, u_1, AddSemigroup, M, AddSemigroup, N, s, Set, M, f, a, M, N, hs, AddSubsemigroup.closure, s, hmul, x, M, y, M, a, y, s, f, x, y, f, x, f, y, x, M, y, M, y₁, M, y₂, M, h₁, x, M, f, x, y₁, f, x, f, y₁, h₂, x, M, f, x, y₂, f, x, f, y₂, x, M, x, M, f, x, y₂, f, x, f, y₂] (during elaboration)

{M : Type u_2} {N : Type u_1} [AddSemigroup M] [AddSemigroup N] {s : Set M} (f : (a : M) → N) (hs : AddSubsemigroup.closure s = ⊤) (hmul : ∀ (x : M) (y : M) (a : y ∈ s) , f x + y = f x + f y) (x : M) (y : M) (y₁ : M) (y₂ : M) (h₁ : ∀ (x : M) , f x + y₁ = f x + f y₁) (h₂ : ∀ (x : M) , f x + y₂ = f x + f y₂) (x : M)  : ∀ (x : M) , f x + y₁ = f x + f y₁
failed to synthesize instance
  HAdd N M ?m.159932 ; identifiers [M, u_2, N, u_1, AddSemigroup, M, AddSemigroup, N, s, Set, M, f, a, M, N, hs, AddSubsemigroup.closure, s, hmul, x, M, y, M, a, y, s, f, x, y, f, x, f, y, x, M, y, M, y₁, M, y₂, M, h₁, x, M, f, x, y₁, f, x, f, y₁, h₂, x, M, f, x, y₂, f, x, f, y₂, x, M, x, M, f, x, y₁, f, x, f, y₁] (during elaboration)

{α : Type u_1} {m : (a : Set α) → ENNReal} {s : Set α} {t : Set α} (h : ∀ (u : Set α) (a : Set.Nonempty s ∩ u) (a : Set.Nonempty t ∩ u) , m u = ⊤) (u : Set α) (hs : Set.Nonempty s ∩ u) (ht : Set.Nonempty t ∩ u)  : m u = ⊤
application type mismatch
  Set.Nonempty s ∩ u
argument
  u
has type
  Set α : Type u_1
but is expected to have type
  Prop : Type ; identifiers [α, u_1, m, a, Set, α, ENNReal, s, Set, α, t, Set, α, h, u, Set, α, a, Set.Nonempty, s, u, a, Set.Nonempty, t, u, m, u, u, Set, α, hs, Set.Nonempty, s, u, ht, Set.Nonempty, t, u, m, u] (during elaboration)

{σ : Type u_1} {k : Type u_2} [Field k] (φ : MvPowerSeries σ k) (u : k ˣ) (h : ↑ MvPowerSeries.constantCoeff σ k φ = ↑ u)  : ↑ u = ↑ MvPowerSeries.constantCoeff σ k φ
type mismatch
  u
has type
  kˣ : Type u_2
but is expected to have type
  ?m.308 φ u h : Sort ?u.235 ; identifiers [σ, u_1, k, u_2, Field, k, φ, MvPowerSeries, σ, k, u, k, h, MvPowerSeries.constantCoeff, σ, k, φ, u, u, MvPowerSeries.constantCoeff, σ, k, φ] (during elaboration)

{X : Type u_2} [TopologicalSpace X] {Y : Type u_1} [TopologicalSpace Y] {f : (a : OnePoint X) → Y} {x : X}  : (Filter.Tendsto f ∘ OnePoint.some nhds x nhds f ↑ x) ↔ (Filter.Tendsto f ∘ OnePoint.some nhds x nhds f ↑ x)
function expected at
  ↑nhds
term has type
  OnePoint (?m.55 → Filter ?m.55) ; identifiers [X, u_2, TopologicalSpace, X, Y, u_1, TopologicalSpace, Y, f, a, OnePoint, X, Y, x, X, Filter.Tendsto, f, OnePoint.some, nhds, x, nhds, f, x, Filter.Tendsto, f, OnePoint.some, nhds, x, nhds, f, x] (during elaboration)

{R : Type u} [Semiring R] {n : ℕ} {f : Polynomial R}  : (∀ (i : ℕ) (i_1 : i ≥ n) , f ∈ LinearMap.ker Polynomial.lcoeff R i) ↔ (∀ (i : ℕ) (i_1 : i ≥ n) , f ∈ LinearMap.ker Polynomial.lcoeff R i)
function expected at
  LinearMap.ker Polynomial.lcoeff
term has type
  Submodule ?m.114 ?m.116 ; identifiers [R, u, Semiring, R, n, f, Polynomial, R, i, i_1, i, n, f, LinearMap.ker, Polynomial.lcoeff, R, i, i, i_1, i, n, f, LinearMap.ker, Polynomial.lcoeff, R, i] (during elaboration)

{α : Type u_1} [CommMonoidWithZero α] (p : α)  : (¬ (IsUnit Associates.mk p)) ↔ (¬ (IsUnit Associates.mk p))
function expected at
  IsUnit Associates.mk
term has type
  Prop ; identifiers [α, u_1, CommMonoidWithZero, α, p, α, IsUnit, Associates.mk, p, IsUnit, Associates.mk, p] (during elaboration)

{α : Type u_1} {β : Type u_2} [LinearOrder β] [Inf α] (f : (a : α) → β) (inj : Function.Injective f) (hinf : ∀ (x : α) (y : α) , f x ⊓ y = min f x f y) (x : α) (y : α)  : f x ⊓ y = min f x f y
application type mismatch
  f x ⊓ y
argument
  y
has type
  α : Type u_1
but is expected to have type
  β : Type u_2 ; identifiers [α, u_1, β, u_2, LinearOrder, β, Inf, α, f, a, α, β, inj, Function.Injective, f, hinf, x, α, y, α, f, x, y, min, f, x, f, y, x, α, y, α, f, x, y, min, f, x, f, y] (during elaboration)

{R : Type u_1} {V : Type u_2} {P : Type u_3} [LinearOrderedField R] [AddCommGroup V] [Module R V] [AddTorsor V P] {s : AffineSubspace R P} {x : P} {y : P} {p₁ : P} (h : p₁ ∈ s) (hx : ¬ (x ∈ s : Prop))  : ((¬ (y ∈ s)) ∧ (∃ (p₂ : P) , (p₂ ∈ s) ∧ (SameRay R x -ᵥ p₁ y -ᵥ p₂))) ↔ ((¬ (y ∈ s)) ∧ (∃ (p₂ : P) , (p₂ ∈ s) ∧ (SameRay R x -ᵥ p₁ y -ᵥ p₂)))
failed to synthesize instance
  AddCommMonoid P ; identifiers [R, u_1, V, u_2, P, u_3, LinearOrderedField, R, AddCommGroup, V, Module, R, V, AddTorsor, V, P, s, AffineSubspace, R, P, x, P, y, P, p₁, P, h, p₁, s, hx, x, s, y, s, p₂, P, p₂, s, SameRay, R, x, p₁, y, p₂, y, s, p₂, P, p₂, s, SameRay, R, x, p₁, y, p₂] (during elaboration)

{V₁ : Type u_2} {V₂ : Type u_1} [SeminormedAddCommGroup V₁] [SeminormedAddCommGroup V₂] (n : ℕ) (f : NormedAddGroupHom V₁ V₂) (b : ℝ) (hb : ∀ (v : V₁) , ‖ NormedAddGroupHom.toFun f v ‖ ≤ b * ‖ v ‖) (v : V₁)  : (‖ n • ↑ f v ‖ ≤ n • b * ‖ v ‖) = (‖ n • ↑ f v ‖ ≤ n • b * ‖ v ‖)
<input>:1:185: expected term

{V₁ : Type u_2} {V₂ : Type u_1} [SeminormedAddCommGroup V₁] [SeminormedAddCommGroup V₂] (n : ℕ) (f : NormedAddGroupHom V₁ V₂) (b : ℝ) (hb : ∀ (v : V₁) , ‖ NormedAddGroupHom.toFun f v ‖ ≤ b * ‖ v ‖) (v : V₁)  : (‖ n • ↑ f v ‖ ≤ n • b * ‖ v ‖) = (‖ n • ↑ f v ‖ ≤ n • b * ‖ v ‖)
<input>:1:185: expected term

{V₁ : Type u_2} {V₂ : Type u_1} [SeminormedAddCommGroup V₁] [SeminormedAddCommGroup V₂] (n : ℕ) (f : NormedAddGroupHom V₁ V₂) (b : ℝ) (hb : ∀ (v : V₁) , ‖ NormedAddGroupHom.toFun f v ‖ ≤ b * ‖ v ‖) (v : V₁)  : (‖ n • ↑ f v ‖ ≤ ↑ n * b * ‖ v ‖) = (‖ n • ↑ f v ‖ ≤ ↑ n * b * ‖ v ‖)
<input>:1:185: expected term

{V₁ : Type u_2} {V₂ : Type u_1} [SeminormedAddCommGroup V₁] [SeminormedAddCommGroup V₂] (n : ℕ) (f : NormedAddGroupHom V₁ V₂) (b : ℝ) (hb : ∀ (v : V₁) , ‖ NormedAddGroupHom.toFun f v ‖ ≤ b * ‖ v ‖) (v : V₁)  : ‖ NormedAddGroupHom.toFun f v ‖ ≤ b * ‖ v ‖
<input>:1:185: expected term

{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommGroup M] (toSMul : SMul R M) (smul_add : ∀ (r : R) (x : M) (y : M) , r • x + y = r • x + r • y) (add_smul : ∀ (r : R) (s : R) (x : M) , r + s • x = r • x + s • x) (mul_smul : ∀ (r : R) (s : R) (x : M) , r * s • x = r • s • x) (one_smul : ∀ (x : M) , 1 • x = x) (toSMul_1 : SMul R M) (smul_add_1 : ∀ (r : R) (x : M) (y : M) , r • x + y = r • x + r • y) (add_smul_1 : ∀ (r : R) (s : R) (x : M) , r + s • x = r • x + s • x) (mul_smul_1 : ∀ (r : R) (s : R) (x : M) , r * s • x = r • s • x) (one_smul_1 : ∀ (x : M) , 1 • x = x) (a : {toSMul := ((toSMul)) , smul_add := ((smul_add)) , add_smul := ((add_smul)) , mul_smul := ((mul_smul)) , one_smul := ((one_smul))} = {toSMul := ((toSMul_1)) , smul_add := ((smul_add_1)) , add_smul := ((add_smul_1)) , mul_smul := ((mul_smul_1)) , one_smul := ((one_smul_1))})  : ∀ (toSMul_eq : toSMul = toSMul_1) , toSMul = toSMul_1
failed to synthesize instance
  HAdd R M ?m.161013 ; identifiers [R, u_1, M, u_2, Semiring, R, AddCommGroup, M, toSMul, SMul, R, M, smul_add, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul, r, R, s, R, x, M, r, s, x, r, s, x, one_smul, x, M, x, x, toSMul_1, SMul, R, M, smul_add_1, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul_1, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul_1, r, R, s, R, x, M, r, s, x, r, s, x, one_smul_1, x, M, x, x, a, toSMul, toSMul, smul_add, smul_add, add_smul, add_smul, mul_smul, mul_smul, one_smul, one_smul, toSMul, toSMul_1, smul_add, smul_add_1, add_smul, add_smul_1, mul_smul, mul_smul_1, one_smul, one_smul_1, toSMul_eq, toSMul, toSMul_1, toSMul, toSMul_1] (during elaboration)

(x : Num) (x_1 : Num) (a : PosNum) (b : PosNum) (this : Ordering.casesOn PosNum.cmp a b (↑ a < ↑ b : Prop) (a = b : Prop) (↑ b < ↑ a : Prop)) (h : PosNum.cmp a b = Ordering.lt)  : Ordering.lt = PosNum.cmp a b
application type mismatch
  Ordering.casesOn PosNum.cmp
argument
  PosNum.cmp
has type
  PosNum → PosNum → Ordering : Type
but is expected to have type
  Ordering : Type ; identifiers [x, Num, x_1, Num, a, PosNum, b, PosNum, this, Ordering.casesOn, PosNum.cmp, a, b, a, b, a, b, b, a, h, PosNum.cmp, a, b, Ordering.lt, Ordering.lt, PosNum.cmp, a, b] (during elaboration)

{X : Type u_1} (R : Type u_2) [TopologicalSpace X] [Semiring R] [TopologicalSpace R] [TopologicalSemiring R] (s : Set X) (c : C(X , R)) (f : C(X , R)) (hf : f ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup {toAddSubsemigroup := (({carrier := (({f : C(X , R) | ∀ (x : X) (a : x ∈ s ᶜ) , ↑ f x = 0})) , add_mem' := (((fun {f : C(X , R)} {g : C(X , R)} (hf : f ∈ {f : C(X , R) | ∀ (x : X) (a : x ∈ s ᶜ) , ↑ f x = 0}) (hg : g ∈ {f : C(X , R) | ∀ (x : X) (a : x ∈ s ᶜ) , ↑ f x = 0}) (x : X) (hx : x ∈ s ᶜ) ↦ of_eq_true (Eq.trans (congrFun (congrArg Eq (Eq.trans (congr (congrArg HAdd.hAdd (hf x hx =: ↑ f x = 0) =: HAdd.hAdd ↑ f x = HAdd.hAdd 0) (hg x hx =: ↑ g x = 0) =: ↑ f x + ↑ g x = 0 + 0) (add_zero 0 =: 0 + 0 = 0) =: ↑ f x + ↑ g x = 0) =: Eq ↑ f x + ↑ g x = Eq 0) 0 =: (↑ f x + ↑ g x = 0 : Prop) = (0 = 0 : Prop)) (eq_self 0 =: (0 = 0 : Prop) = (True : Prop)) =: (↑ f x + ↑ g x = 0 : Prop) = (True : Prop)) =: ∀ {f : C(X , R)} {g : C(X , R)} (hf : f ∈ {f : C(X , R) | ∀ (x : X) (a : x ∈ s ᶜ) , ↑ f x = 0}) (hg : g ∈ {f : C(X , R) | ∀ (x : X) (a : x ∈ s ᶜ) , ↑ f x = 0}) (x : X) (hx : x ∈ s ᶜ) , ↑ f x + ↑ g x = 0)))})) , zero_mem' := (((fun (x : X) (x_1 : x ∈ s ᶜ) ↦ rfl =: ∀ (x : X) (x_1 : x ∈ s ᶜ) , ↑ 0 x = ↑ 0 x)))}) (x : X) (hx : x ∈ s ᶜ)  : ↑ f x = 0
<input>:1:604: expected term

{ι : Type u_2} {E : Type u_1} [SeminormedAddCommGroup E] [CompleteSpace E] {f : (a : ι) → E}  : (∀ (ε : ℝ) (a : ε > 0) , ∃ (s : Finset ι) , ∀ (t : Finset ι) (a : Disjoint t s) , ‖ Finset.sum t fun (i : ι) ↦ f i ‖ < ε) ↔ (∀ (ε : ℝ) (a : ε > 0) , ∃ (s : Finset ι) , ∀ (t : Finset ι) (a : Disjoint t s) , ‖ Finset.sum t fun (i : ι) ↦ f i ‖ < ε)
<input>:1:213: expected term

(x : Num) (x_1 : Num) (a : PosNum) (b : PosNum) (this : Ordering.casesOn PosNum.cmp a b (↑ a < ↑ b : Prop) (a = b : Prop) (↑ b < ↑ a : Prop)) (h : PosNum.cmp a b = Ordering.eq)  : Ordering.eq = PosNum.cmp a b
application type mismatch
  Ordering.casesOn PosNum.cmp
argument
  PosNum.cmp
has type
  PosNum → PosNum → Ordering : Type
but is expected to have type
  Ordering : Type ; identifiers [x, Num, x_1, Num, a, PosNum, b, PosNum, this, Ordering.casesOn, PosNum.cmp, a, b, a, b, a, b, b, a, h, PosNum.cmp, a, b, Ordering.eq, Ordering.eq, PosNum.cmp, a, b] (during elaboration)

(x : Num) (x_1 : Num) (a : PosNum) (b : PosNum) (this : Ordering.casesOn PosNum.cmp a b (↑ a < ↑ b : Prop) (a = b : Prop) (↑ b < ↑ a : Prop)) (h : PosNum.cmp a b = Ordering.gt)  : Ordering.gt = PosNum.cmp a b
application type mismatch
  Ordering.casesOn PosNum.cmp
argument
  PosNum.cmp
has type
  PosNum → PosNum → Ordering : Type
but is expected to have type
  Ordering : Type ; identifiers [x, Num, x_1, Num, a, PosNum, b, PosNum, this, Ordering.casesOn, PosNum.cmp, a, b, a, b, a, b, b, a, h, PosNum.cmp, a, b, Ordering.gt, Ordering.gt, PosNum.cmp, a, b] (during elaboration)

{V : Type u} {G : SimpleGraph V} {u : V} {v : V} (p : SimpleGraph.Walk G u v) {e : Sym2 V} {u : V} {v : V} {w : V} (h : SimpleGraph.Adj G u v) (p : SimpleGraph.Walk G v w) (p_ih : (e ∈ SimpleGraph.Subgraph.edgeSet SimpleGraph.Walk.toSubgraph p : Prop) ↔ (e ∈ SimpleGraph.Walk.edges p : Prop))  : (e ∈ Quotient.mk Sym2.Rel.setoid V (u , v) :: SimpleGraph.Walk.edges p) = ((e = Quotient.mk Sym2.Rel.setoid V (u , v)) ∨ (e ∈ SimpleGraph.Walk.edges p))
failed to synthesize instance
  Membership (Sym2 V) Prop ; identifiers [V, u, G, SimpleGraph, V, u, V, v, V, p, SimpleGraph.Walk, G, u, v, e, Sym2, V, u, V, v, V, w, V, h, SimpleGraph.Adj, G, u, v, p, SimpleGraph.Walk, G, v, w, p_ih, e, SimpleGraph.Subgraph.edgeSet, SimpleGraph.Walk.toSubgraph, p, e, SimpleGraph.Walk.edges, p, e, Quotient.mk, Sym2.Rel.setoid, V, u, v, SimpleGraph.Walk.edges, p, e, Quotient.mk, Sym2.Rel.setoid, V, u, v, e, SimpleGraph.Walk.edges, p] (during elaboration)

 : (∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : SizeOf G] (toFun : (a : TopologicalSpace.Compacts G) → NNReal) (mono' : ∀ (K₁ : TopologicalSpace.Compacts G) (K₂ : TopologicalSpace.Compacts G) (a : ↑ K₁ ⊆ ↑ K₂) , toFun K₁ ≤ toFun K₂) (sup_disjoint' : ∀ (K₁ : TopologicalSpace.Compacts G) (K₂ : TopologicalSpace.Compacts G) (a : Disjoint ↑ K₁ ↑ K₂) , toFun K₁ ⊔ K₂ = toFun K₁ + toFun K₂) (sup_le' : ∀ (K₁ : TopologicalSpace.Compacts G) (K₂ : TopologicalSpace.Compacts G) , toFun K₁ ⊔ K₂ ≤ toFun K₁ + toFun K₂) , sizeOf {toFun := ((toFun)) , mono' := ((mono')) , sup_disjoint' := ((sup_disjoint')) , sup_le' := ((sup_le'))} = 1)
application type mismatch
  toFun K₁ ⊔ K₂
argument
  K₂
has type
  TopologicalSpace.Compacts G : Type w
but is expected to have type
  NNReal : Type ; identifiers [G, w, inst, TopologicalSpace, G, inst_1, SizeOf, G, toFun, a, TopologicalSpace.Compacts, G, NNReal, mono', K₁, TopologicalSpace.Compacts, G, K₂, TopologicalSpace.Compacts, G, a, K₁, K₂, toFun, K₁, toFun, K₂, sup_disjoint', K₁, TopologicalSpace.Compacts, G, K₂, TopologicalSpace.Compacts, G, a, Disjoint, K₁, K₂, toFun, K₁, K₂, toFun, K₁, toFun, K₂, sup_le', K₁, TopologicalSpace.Compacts, G, K₂, TopologicalSpace.Compacts, G, toFun, K₁, K₂, toFun, K₁, toFun, K₂, sizeOf, toFun, toFun, mono', mono', sup_disjoint', sup_disjoint', sup_le', sup_le'] (during elaboration)

 : ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : SizeOf G] (toFun : (a : TopologicalSpace.Compacts G) → NNReal) (mono' : ∀ (K₁ : TopologicalSpace.Compacts G) (K₂ : TopologicalSpace.Compacts G) (a : ↑ K₁ ⊆ ↑ K₂) , toFun K₁ ≤ toFun K₂) (sup_disjoint' : ∀ (K₁ : TopologicalSpace.Compacts G) (K₂ : TopologicalSpace.Compacts G) (a : Disjoint ↑ K₁ ↑ K₂) , toFun K₁ ⊔ K₂ = toFun K₁ + toFun K₂) (sup_le' : ∀ (K₁ : TopologicalSpace.Compacts G) (K₂ : TopologicalSpace.Compacts G) , toFun K₁ ⊔ K₂ ≤ toFun K₁ + toFun K₂) , 1 = 1
application type mismatch
  toFun K₁ ⊔ K₂
argument
  K₂
has type
  TopologicalSpace.Compacts G : Type w
but is expected to have type
  NNReal : Type ; identifiers [G, w, inst, TopologicalSpace, G, inst_1, SizeOf, G, toFun, a, TopologicalSpace.Compacts, G, NNReal, mono', K₁, TopologicalSpace.Compacts, G, K₂, TopologicalSpace.Compacts, G, a, K₁, K₂, toFun, K₁, toFun, K₂, sup_disjoint', K₁, TopologicalSpace.Compacts, G, K₂, TopologicalSpace.Compacts, G, a, Disjoint, K₁, K₂, toFun, K₁, K₂, toFun, K₁, toFun, K₂, sup_le', K₁, TopologicalSpace.Compacts, G, K₂, TopologicalSpace.Compacts, G, toFun, K₁, K₂, toFun, K₁, toFun, K₂] (during elaboration)

{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommGroup M] (toSMul : SMul R M) (smul_add : ∀ (r : R) (x : M) (y : M) , r • x + y = r • x + r • y) (add_smul : ∀ (r : R) (s : R) (x : M) , r + s • x = r • x + s • x) (mul_smul : ∀ (r : R) (s : R) (x : M) , r * s • x = r • s • x) (one_smul : ∀ (x : M) , 1 • x = x) (toSMul_1 : SMul R M) (smul_add_1 : ∀ (r : R) (x : M) (y : M) , r • x + y = r • x + r • y) (add_smul_1 : ∀ (r : R) (s : R) (x : M) , r + s • x = r • x + s • x) (mul_smul_1 : ∀ (r : R) (s : R) (x : M) , r * s • x = r • s • x) (one_smul_1 : ∀ (x : M) , 1 • x = x) (a : toSMul = toSMul_1) (h : toSMul_1 = toSMul) (toSMul_2 : SMul R M)  : toSMul = toSMul
failed to synthesize instance
  HAdd R M ?m.161013 ; identifiers [R, u_1, M, u_2, Semiring, R, AddCommGroup, M, toSMul, SMul, R, M, smul_add, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul, r, R, s, R, x, M, r, s, x, r, s, x, one_smul, x, M, x, x, toSMul_1, SMul, R, M, smul_add_1, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul_1, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul_1, r, R, s, R, x, M, r, s, x, r, s, x, one_smul_1, x, M, x, x, a, toSMul, toSMul_1, h, toSMul_1, toSMul, toSMul_2, SMul, R, M, toSMul, toSMul] (during elaboration)

 : ∀ (α : Type u_1) (β : Type u_2) [inst : Preorder α] [inst_1 : Preorder β] (self : α →o β) , Monotone self . 1
function expected at
  Monotone ↑self
term has type
  Prop ; identifiers [α, u_1, β, u_2, inst, Preorder, α, inst_1, Preorder, β, self, α, β, Monotone, self] (during elaboration)

{α : Type u} {σ : Type v} (M : εNFA α σ) (x : List α)  : ∅ = ∅
typeclass instance problem is stuck, it is often due to metavariables
  EmptyCollection (?m.393 M x) ; identifiers [α, u, σ, v, M, εNFA, α, σ, x, List, α] (during elaboration)

{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommGroup M] (toSMul : SMul R M) (smul_add : ∀ (r : R) (x : M) (y : M) , r • x + y = r • x + r • y) (add_smul : ∀ (r : R) (s : R) (x : M) , r + s • x = r • x + s • x) (mul_smul : ∀ (r : R) (s : R) (x : M) , r * s • x = r • s • x) (one_smul : ∀ (x : M) , 1 • x = x) (toSMul_1 : SMul R M) (smul_add_1 : ∀ (r : R) (x : M) (y : M) , r • x + y = r • x + r • y) (add_smul_1 : ∀ (r : R) (s : R) (x : M) , r + s • x = r • x + s • x) (mul_smul_1 : ∀ (r : R) (s : R) (x : M) , r * s • x = r • s • x) (one_smul_1 : ∀ (x : M) , 1 • x = x) (a : toSMul = toSMul_1) (h : toSMul_1 = toSMul) (smul_add_2 : ∀ (r : R) (x : M) (y : M) , r • x + y = r • x + r • y) (add_smul_2 : ∀ (r : R) (s : R) (x : M) , r + s • x = r • x + s • x) (mul_smul_2 : ∀ (r : R) (s : R) (x : M) , r * s • x = r • s • x) (one_smul_2 : ∀ (x : M) , 1 • x = x) (a : toSMul = toSMul) (h : HEq a (Eq.refl toSMul =: toSMul = toSMul))  : {toSMul := ((toSMul)) , smul_add := ((smul_add)) , add_smul := ((add_smul)) , mul_smul := ((mul_smul)) , one_smul := ((one_smul))} = {toSMul := ((toSMul)) , smul_add := ((smul_add)) , add_smul := ((add_smul)) , mul_smul := ((mul_smul)) , one_smul := ((one_smul))}
<input>:1:912: expected term

{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommGroup M] (toSMul : SMul R M) (smul_add : ∀ (r : R) (x : M) (y : M) , r • x + y = r • x + r • y) (add_smul : ∀ (r : R) (s : R) (x : M) , r + s • x = r • x + s • x) (mul_smul : ∀ (r : R) (s : R) (x : M) , r * s • x = r • s • x) (one_smul : ∀ (x : M) , 1 • x = x) (toSMul_1 : SMul R M) (smul_add_1 : ∀ (r : R) (x : M) (y : M) , r • x + y = r • x + r • y) (add_smul_1 : ∀ (r : R) (s : R) (x : M) , r + s • x = r • x + s • x) (mul_smul_1 : ∀ (r : R) (s : R) (x : M) , r * s • x = r • s • x) (one_smul_1 : ∀ (x : M) , 1 • x = x) (a : toSMul = toSMul_1) (h : toSMul_1 = toSMul)  : toSMul = toSMul_1
failed to synthesize instance
  HAdd R M ?m.161013 ; identifiers [R, u_1, M, u_2, Semiring, R, AddCommGroup, M, toSMul, SMul, R, M, smul_add, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul, r, R, s, R, x, M, r, s, x, r, s, x, one_smul, x, M, x, x, toSMul_1, SMul, R, M, smul_add_1, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul_1, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul_1, r, R, s, R, x, M, r, s, x, r, s, x, one_smul_1, x, M, x, x, a, toSMul, toSMul_1, h, toSMul_1, toSMul, toSMul, toSMul_1] (during elaboration)

{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommGroup M] (toSMul : SMul R M) (smul_add : ∀ (r : R) (x : M) (y : M) , r • x + y = r • x + r • y) (add_smul : ∀ (r : R) (s : R) (x : M) , r + s • x = r • x + s • x) (mul_smul : ∀ (r : R) (s : R) (x : M) , r * s • x = r • s • x) (one_smul : ∀ (x : M) , 1 • x = x) (toSMul_1 : SMul R M) (smul_add_1 : ∀ (r : R) (x : M) (y : M) , r • x + y = r • x + r • y) (add_smul_1 : ∀ (r : R) (s : R) (x : M) , r + s • x = r • x + s • x) (mul_smul_1 : ∀ (r : R) (s : R) (x : M) , r * s • x = r • s • x) (one_smul_1 : ∀ (x : M) , 1 • x = x) (a : toSMul = toSMul_1)  : toSMul_1 = toSMul_1
failed to synthesize instance
  HAdd R M ?m.161013 ; identifiers [R, u_1, M, u_2, Semiring, R, AddCommGroup, M, toSMul, SMul, R, M, smul_add, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul, r, R, s, R, x, M, r, s, x, r, s, x, one_smul, x, M, x, x, toSMul_1, SMul, R, M, smul_add_1, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul_1, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul_1, r, R, s, R, x, M, r, s, x, r, s, x, one_smul_1, x, M, x, x, a, toSMul, toSMul_1, toSMul_1, toSMul_1] (during elaboration)

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMin a : Prop)) (b : Fin n + 1)  : (⊥ < a) = (⊥ < a)
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, a, a] (during elaboration)

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMin a : Prop)) (b : Fin n + 1)  : (¬ (a ≤ ⊥)) = (¬ (a ≤ ⊥))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, a, a] (during elaboration)

{α : Type u} {σ : Type v} (M : εNFA α σ) (x : List α) (x : List α) (a : α) (ih : εNFA.evalFrom M ∅ x = ∅)  : ∅ = ∅
typeclass instance problem is stuck, it is often due to metavariables
  EmptyCollection (?m.592 M x✝ x a ih) ; identifiers [α, u, σ, v, M, εNFA, α, σ, x, List, α, x, List, α, a, α, ih, εNFA.evalFrom, M, x] (during elaboration)

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMin a : Prop)) (b : Fin n + 1)  : (¬ (a = ⊥)) = (¬ (a = ⊥))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, a, a] (during elaboration)

{x : ℂ} {y : ℂ}  : ((cexp x = cexp y) ↔ (cexp x / cexp y = 1)) = ((cexp x = cexp y) ↔ (cexp x / cexp y = 1))
ambiguous, possible interpretations 
  cexp x : ℂ
  
  cexp x : ℂ ; identifiers [x, y, x, y, x, y, x, y, x, y] (during elaboration)

{x : ℂ} {y : ℂ}  : (cexp x = cexp y) ↔ (cexp x = cexp y)
ambiguous, possible interpretations 
  cexp x : ℂ
  
  cexp x : ℂ ; identifiers [x, y, x, y, x, y] (during elaboration)

{R : Type u} [Semiring R] {p : Polynomial R} (h : Finset.card Polynomial.support p ≤ 1)  : p = p
function expected at
  Finset.card ?m.584
term has type
  ℕ ; identifiers [R, u, Semiring, R, p, Polynomial, R, h, Finset.card, Polynomial.support, p, p, p] (during elaboration)

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMin a : Prop)) (b : Fin n + 1)  : ((b ≤ if (a = 0) then 0 else a - 1) ↔ (b < a)) = ((b ≤ if (a = 0) then 0 else a - 1) ↔ (b < a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, a, b, a, b, a, a, b, a] (during elaboration)

{G : Type u_1} [Group G] {G' : Type u_2} [Group G'] [Group.FG G] [Group.FG G'] (f : G →* G') (hf : Function.Surjective ↑ f) (S : Finset G) (h : (Finset.card S = Group.rank G : Prop) ∧ (Subgroup.closure ↑ S = ⊤ : Prop)) (hS1 : Finset.card S = Group.rank G) (hS2 : Subgroup.closure ↑ S = ⊤)  : ⊤ = ⊤
typeclass instance problem is stuck, it is often due to metavariables
  Top (?m.76950 f hf S h hS1 hS2) ; identifiers [G, u_1, Group, G, G', u_2, Group, G', Group.FG, G, Group.FG, G', f, G, G', hf, Function.Surjective, f, S, Finset, G, h, Finset.card, S, Group.rank, G, Subgroup.closure, S, hS1, Finset.card, S, Group.rank, G, hS2, Subgroup.closure, S] (during elaboration)

{α : Type u} {β : Type v} [PseudoEMetricSpace α] [PseudoEMetricSpace β] {f : (a : α) → β} (h : Isometry f) (x : α) (y : α)  : edist f x f y = edist x y
application type mismatch
  edist f x
argument
  x
has type
  α : Type u
but is expected to have type
  α → β : Type (max u v) ; identifiers [α, u, β, v, PseudoEMetricSpace, α, PseudoEMetricSpace, β, f, a, α, β, h, Isometry, f, x, α, y, α, edist, f, x, f, y, edist, x, y] (during elaboration)

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMin a : Prop)) (b : Fin n + 1)  : ((b ≤ a - 1) ↔ (b < a)) = ((b ≤ a - 1) ↔ (b < a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, b, a, b, a, b, a] (during elaboration)

{α : Type u} {β : Type v} {f : (a : α) → β} {b : β} {s : Stream' α} (x : b ∈ Stream'.map f s) (n : ℕ) (h : b = Stream'.nth Stream'.map f s n)  : Stream'.nth Stream'.map f s n = b
application type mismatch
  Stream'.nth ?m.80406 f
argument
  f
has type
  α → β : Type (max u v)
but is expected to have type
  ℕ : Type ; identifiers [α, u, β, v, f, a, α, β, b, β, s, Stream', α, x, b, Stream'.map, f, s, n, h, b, Stream'.nth, Stream'.map, f, s, n, Stream'.nth, Stream'.map, f, s, n, b] (during elaboration)

 : (∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor D C} (self : F ⊣ G) {X : C} {Y : D} {g : X ⟶ CategoryTheory.Functor.toPrefunctor G . obj Y} , ↑ CategoryTheory.Adjunction.homEquiv self X Y . symm g = CategoryTheory.CategoryStruct.comp CategoryTheory.Functor.toPrefunctor F . map g CategoryTheory.NatTrans.app CategoryTheory.Adjunction.counit self Y)
function expected at
  G.toPrefunctor
term has type
  D ⥤q C ; identifiers [C, u₁, inst, CategoryTheory.Category, C, D, u₂, inst_1, CategoryTheory.Category, D, F, CategoryTheory.Functor, C, D, G, CategoryTheory.Functor, D, C, self, F, G, X, C, Y, D, g, X, CategoryTheory.Functor.toPrefunctor, G, obj, Y, CategoryTheory.Adjunction.homEquiv, self, X, Y, symm, g, CategoryTheory.CategoryStruct.comp, CategoryTheory.Functor.toPrefunctor, F, map, g, CategoryTheory.NatTrans.app, CategoryTheory.Adjunction.counit, self, Y] (during elaboration)

 : ∀ (C : Type u₁) [inst : CategoryTheory.Category C] (D : Type u₂) [inst_1 : CategoryTheory.Category D] (F : CategoryTheory.Functor C D) (G : CategoryTheory.Functor D C) (self : F ⊣ G) {X : C} {Y : D} {g : X ⟶ CategoryTheory.Functor.toPrefunctor G . obj Y} , ↑ self . 1 X Y . symm g = CategoryTheory.CategoryStruct.comp CategoryTheory.Functor.toPrefunctor F . map g CategoryTheory.NatTrans.app self . 3 Y
function expected at
  G.toPrefunctor
term has type
  D ⥤q C ; identifiers [C, u₁, inst, CategoryTheory.Category, C, D, u₂, inst_1, CategoryTheory.Category, D, F, CategoryTheory.Functor, C, D, G, CategoryTheory.Functor, D, C, self, F, G, X, C, Y, D, g, X, CategoryTheory.Functor.toPrefunctor, G, obj, Y, self, X, Y, symm, g, CategoryTheory.CategoryStruct.comp, CategoryTheory.Functor.toPrefunctor, F, map, g, CategoryTheory.NatTrans.app, self, Y] (during elaboration)

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMin a : Prop)) (b : Fin n + 1)  : ((b ≤ a - 1) ↔ (↑ b < ↑ a)) = ((b ≤ a - 1) ↔ (↑ b < ↑ a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, b, a, b, a, b, a] (during elaboration)

{R : Type u_2} {A : Type u_1} [CommSemiring R] [StarRing R] [Semiring A] [Algebra R A] [StarRing A] [StarModule R A] {x : A}  : (x ∈ Set.range ↑ algebraMap R A) ↔ (x ∈ Set.range ↑ algebraMap R A)
function expected at
  Set.range ?m.82028 R
term has type
  Prop ; identifiers [R, u_2, A, u_1, CommSemiring, R, StarRing, R, Semiring, A, Algebra, R, A, StarRing, A, StarModule, R, A, x, A, x, Set.range, algebraMap, R, A, x, Set.range, algebraMap, R, A] (during elaboration)

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMin a : Prop)) (b : Fin n + 1)  : ((↑ b ≤ ↑ a - 1) ↔ (↑ b < ↑ a)) = ((↑ b ≤ ↑ a - 1) ↔ (↑ b < ↑ a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, b, a, b, a, b, a] (during elaboration)

(x : ℂ) (z : ℂ) (hz : ‖ z ‖ ≤ 1) {E : Type} [Norm E] (a : E) (a_1 : E) (e_a : a = a_1)  : ‖ a ‖ = ‖ a ‖
<input>:1:28: expected term

{G : Type u_1} [Group G] (H : Subgroup G) [Subgroup.IsCommutative H] [Subgroup.FiniteIndex H] {x : ↑ Subgroup.leftTransversals ↑ H} {y : ↑ Subgroup.leftTransversals ↑ H} (h : Subgroup.leftTransversals.diff MonoidHom.id {x : G // x ∈ H} x y = 1)  : (1 ⁻¹ = 1) = (1 ⁻¹ = 1)
application type mismatch
  Subgroup.leftTransversals.diff ?m.393 { x // x ∈ H }
argument
  { x // x ∈ H }
has type
  Type u_1 : Type (u_1 + 1)
but is expected to have type
  ↑(Subgroup.leftTransversals ↑?m.268) : Type ?u.265 ; identifiers [G, u_1, Group, G, H, Subgroup, G, Subgroup.IsCommutative, H, Subgroup.FiniteIndex, H, x, Subgroup.leftTransversals, H, y, Subgroup.leftTransversals, H, h, Subgroup.leftTransversals.diff, MonoidHom.id, x, G, x, H, x, y] (during elaboration)

{G : Type u_1} [Group G] (H : Subgroup G) [Subgroup.IsCommutative H] [Subgroup.FiniteIndex H] {x : ↑ Subgroup.leftTransversals ↑ H} {y : ↑ Subgroup.leftTransversals ↑ H} (h : Subgroup.leftTransversals.diff MonoidHom.id {x : G // x ∈ H} x y = 1)  : 1 = 1
application type mismatch
  Subgroup.leftTransversals.diff ?m.393 { x // x ∈ H }
argument
  { x // x ∈ H }
has type
  Type u_1 : Type (u_1 + 1)
but is expected to have type
  ↑(Subgroup.leftTransversals ↑?m.268) : Type ?u.265 ; identifiers [G, u_1, Group, G, H, Subgroup, G, Subgroup.IsCommutative, H, Subgroup.FiniteIndex, H, x, Subgroup.leftTransversals, H, y, Subgroup.leftTransversals, H, h, Subgroup.leftTransversals.diff, MonoidHom.id, x, G, x, H, x, y] (during elaboration)

{α : Type u_1} [LinearOrderedRing α] [FloorRing α] (a : α) (ha : Int.fract a = 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)) = (Or.inl ha =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)))  : (Or.inl ha) = (eq_or_ne Int.fract a 0)
<input>:1:112: expected term

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMin a : Prop)) (b : Fin n + 1)  : ((↑ b ≤ if (a = 0) then n else ↑ a - 1) ↔ (↑ b < ↑ a)) = ((↑ b ≤ if (a = 0) then n else ↑ a - 1) ↔ (↑ b < ↑ a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, n, a, b, a, b, a, n, a, b, a] (during elaboration)

(G : Type u_1) [TopologicalSpace G] [Group G] [TopologicalGroup G] (a : G) (s : Set G) (hs : s ∈ nhds a) (this : Filter.Tendsto fun (p : G × G) ↦ Prod.fst p * Prod.snd p nhds (a , 1) nhds a)  : s ∈ Filter.map fun (p : G × G) ↦ Prod.fst p * Prod.snd p nhds (a , 1)
function expected at
  p.snd
term has type
  G ; identifiers [G, u_1, TopologicalSpace, G, Group, G, TopologicalGroup, G, a, G, s, Set, G, hs, s, nhds, a, this, Filter.Tendsto, p, G, G, Prod.fst, p, Prod.snd, p, nhds, a, nhds, a, s, Filter.map, p, G, G, Prod.fst, p, Prod.snd, p, nhds, a] (during elaboration)

{α : Type u} [AddGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {b : α} {c : α} (a : α)  : ((a - b ≤ a - c) ↔ (c ≤ b)) = ((a - b ≤ a - c) ↔ (c ≤ b))
function expected at
  x_1
term has type
  α ; identifiers [α, u, AddGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, b, α, c, α, a, α, a, b, a, c, c, b, a, b, a, c, c, b] (during elaboration)

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMin a : Prop)) (b : Fin n + 1)  : ((↑ b ≤ ↑ a - 1) ↔ (↑ b < ↑ a)) = ((↑ b ≤ ↑ a - 1) ↔ (↑ b < ↑ a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, b, a, b, a, b, a] (during elaboration)

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMin a : Prop)) (b : Fin n + 1)  : ((↑ b + 1 ≤ ↑ a) ↔ (↑ b < ↑ a)) ↔ ((↑ b < ↑ a) ↔ (↑ b + 1 ≤ ↑ a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, b, a, b, a, b, a] (during elaboration)

(n : ℕ) {a : Fin n + 1} (ha : ¬ (IsMin a : Prop)) (b : Fin n + 1)  : ((↑ b + 1 ≤ ↑ a) ↔ (↑ b < ↑ a)) = ((↑ b + 1 ≤ ↑ a) ↔ (↑ b < ↑ a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, b, a, b, a, b, a] (during elaboration)

{α : Type u} [AddGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {b : α} {c : α} (a : α)  : ((a + - b ≤ a - c) ↔ (c ≤ b)) = ((a + - b ≤ a - c) ↔ (c ≤ b))
function expected at
  x_1
term has type
  α ; identifiers [α, u, AddGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, b, α, c, α, a, α, a, b, a, c, c, b, a, b, a, c, c, b] (during elaboration)

{α : Type u_1} {c : Set Set α} (x : α) (x_1 : Set α)  : (∃ (_h : x_1 ∈ c) , ¬ (x ∈ x_1)) = ((x_1 ∈ c) ∧ (¬ (x ∈ x_1)))
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.7 → Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Type ?u.6 : Type (?u.6 + 1) ; identifiers [α, u_1, c, Set, Set, α, x, α, x_1, Set, α, _h, x_1, c, x, x_1, x_1, c, x, x_1] (during elaboration)

{M : Type u_1} [AddMonoid M] {s : Set M} (hs : IsAddSubmonoid s) (x : List M) (x_1 : ∀ (x_1 : M) (a : x_1 ∈ x) , x_1 ∈ s) (x : List M) (f : List.below (motive := fun (x : List M) ↦ ∀ (x_2 : ∀ (x_2 : M) (a : x_2 ∈ x) , x_2 ∈ s) , List.sum x ∈ s) x) (x_2 : ∀ (x_2 : M) (a : x_2 ∈ x) , x_2 ∈ s) (a : M) (l : List M) (h : ∀ (x : M) (a : x ∈ a :: l) , x ∈ s) (x : List.below (motive := fun (x : List M) ↦ ∀ (x_3 : ∀ (x_3 : M) (a : x_3 ∈ x) , x_3 ∈ s) , List.sum x ∈ s) a :: l) (x : M)  : (x ∈ a :: l) = ((x = a) ∨ (x ∈ l))
application type mismatch
  List.below (motive := fun x => (∀ (x_3 : M), x_3 ∈ x → x_3 ∈ s) → List.sum x ∈ s) a
argument
  a
has type
  M : Type u_1
but is expected to have type
  List M : Type u_1 ; identifiers [M, u_1, AddMonoid, M, s, Set, M, hs, IsAddSubmonoid, s, x, List, M, x_1, x_1, M, a, x_1, x, x_1, s, x, List, M, f, List.below, motive, x, List, M, x_2, x_2, M, a, x_2, x, x_2, s, List.sum, x, s, x, x_2, x_2, M, a, x_2, x, x_2, s, a, M, l, List, M, h, x, M, a, x, a, l, x, s, x, List.below, motive, x, List, M, x_3, x_3, M, a, x_3, x, x_3, s, List.sum, x, s, a, l, x, M, x, a, l, x, a, x, l] (during elaboration)

{M : Type u_1} [AddMonoid M] {s : Set M} (hs : IsAddSubmonoid s) (x : List M) (x_1 : ∀ (x_1 : M) (a : x_1 ∈ x) , x_1 ∈ s) (x : List M) (f : List.below (motive := fun (x : List M) ↦ ∀ (x_2 : ∀ (x_2 : M) (a : x_2 ∈ x) , x_2 ∈ s) , List.sum x ∈ s) x) (x_2 : ∀ (x_2 : M) (a : x_2 ∈ x) , x_2 ∈ s) (a : M) (l : List M) (h : ∀ (x : M) (a : x ∈ a :: l) , x ∈ s) (x : List.below (motive := fun (x : List M) ↦ ∀ (x_3 : ∀ (x_3 : M) (a : x_3 ∈ x) , x_3 ∈ s) , List.sum x ∈ s) a :: l) (x : M)  : (x ∈ s) = (x ∈ s)
application type mismatch
  List.below (motive := fun x => (∀ (x_3 : M), x_3 ∈ x → x_3 ∈ s) → List.sum x ∈ s) a
argument
  a
has type
  M : Type u_1
but is expected to have type
  List M : Type u_1 ; identifiers [M, u_1, AddMonoid, M, s, Set, M, hs, IsAddSubmonoid, s, x, List, M, x_1, x_1, M, a, x_1, x, x_1, s, x, List, M, f, List.below, motive, x, List, M, x_2, x_2, M, a, x_2, x, x_2, s, List.sum, x, s, x, x_2, x_2, M, a, x_2, x, x_2, s, a, M, l, List, M, h, x, M, a, x, a, l, x, s, x, List.below, motive, x, List, M, x_3, x_3, M, a, x_3, x, x_3, s, List.sum, x, s, a, l, x, M, x, s, x, s] (during elaboration)

{M : Type u_1} [AddMonoid M] {s : Set M} (hs : IsAddSubmonoid s) (x : List M) (x_1 : ∀ (x_1 : M) (a : x_1 ∈ x) , x_1 ∈ s) (x : List M) (f : List.below (motive := fun (x : List M) ↦ ∀ (x_2 : ∀ (x_2 : M) (a : x_2 ∈ x) , x_2 ∈ s) , List.sum x ∈ s) x) (x_2 : ∀ (x_2 : M) (a : x_2 ∈ x) , x_2 ∈ s) (a : M) (l : List M) (h : ∀ (x : M) (a : x ∈ a :: l) , x ∈ s) (x : List.below (motive := fun (x : List M) ↦ ∀ (x_3 : ∀ (x_3 : M) (a : x_3 ∈ x) , x_3 ∈ s) , List.sum x ∈ s) a :: l)  : (∀ (a_1 : M) (a : (a_1 = a) ∨ (a_1 ∈ l)) , a_1 ∈ s) = ((a ∈ s) ∧ (∀ (a : M) (a_1 : a ∈ l) , a ∈ s))
application type mismatch
  List.below (motive := fun x => (∀ (x_3 : M), x_3 ∈ x → x_3 ∈ s) → List.sum x ∈ s) a
argument
  a
has type
  M : Type u_1
but is expected to have type
  List M : Type u_1 ; identifiers [M, u_1, AddMonoid, M, s, Set, M, hs, IsAddSubmonoid, s, x, List, M, x_1, x_1, M, a, x_1, x, x_1, s, x, List, M, f, List.below, motive, x, List, M, x_2, x_2, M, a, x_2, x, x_2, s, List.sum, x, s, x, x_2, x_2, M, a, x_2, x, x_2, s, a, M, l, List, M, h, x, M, a, x, a, l, x, s, x, List.below, motive, x, List, M, x_3, x_3, M, a, x_3, x, x_3, s, List.sum, x, s, a, l, a_1, M, a, a_1, a, a_1, l, a_1, s, a, s, a, M, a_1, a, l, a, s] (during elaboration)

{α : Type u} [AddGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {b : α} {c : α} (a : α)  : ((a + - b ≤ a + - c) ↔ (c ≤ b)) = ((a + - b ≤ a + - c) ↔ (c ≤ b))
function expected at
  x_1
term has type
  α ; identifiers [α, u, AddGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, b, α, c, α, a, α, a, b, a, c, c, b, a, b, a, c, c, b] (during elaboration)

{α : Type u} [AddGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {b : α} {c : α} (a : α)  : ((- a + a + - b ≤ - a + a + - c) ↔ (c ≤ b)) = ((- a + a + - b ≤ - a + a + - c) ↔ (c ≤ b))
function expected at
  x_1
term has type
  α ; identifiers [α, u, AddGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, b, α, c, α, a, α, a, a, b, a, a, c, c, b, a, a, b, a, a, c, c, b] (during elaboration)

{G : Type u_1} [Group G] (H : Subgroup G) [Subgroup.IsCommutative H] [Subgroup.FiniteIndex H] {x : ↑ Subgroup.leftTransversals ↑ H} {y : ↑ Subgroup.leftTransversals ↑ H} {z : ↑ Subgroup.leftTransversals ↑ H} (h : Subgroup.leftTransversals.diff MonoidHom.id {x : G // x ∈ H} x y = 1) (h' : Subgroup.leftTransversals.diff MonoidHom.id {x : G // x ∈ H} y z = 1)  : (1 * 1 = 1) = (1 * 1 = 1)
application type mismatch
  Subgroup.leftTransversals.diff ?m.400 { x // x ∈ H }
argument
  { x // x ∈ H }
has type
  Type u_1 : Type (u_1 + 1)
but is expected to have type
  ↑(Subgroup.leftTransversals ↑?m.275) : Type ?u.272 ; identifiers [G, u_1, Group, G, H, Subgroup, G, Subgroup.IsCommutative, H, Subgroup.FiniteIndex, H, x, Subgroup.leftTransversals, H, y, Subgroup.leftTransversals, H, z, Subgroup.leftTransversals, H, h, Subgroup.leftTransversals.diff, MonoidHom.id, x, G, x, H, x, y, h', Subgroup.leftTransversals.diff, MonoidHom.id, x, G, x, H, y, z] (during elaboration)

{G : Type u_1} [Group G] (H : Subgroup G) [Subgroup.IsCommutative H] [Subgroup.FiniteIndex H] {x : ↑ Subgroup.leftTransversals ↑ H} {y : ↑ Subgroup.leftTransversals ↑ H} {z : ↑ Subgroup.leftTransversals ↑ H} (h : Subgroup.leftTransversals.diff MonoidHom.id {x : G // x ∈ H} x y = 1) (h' : Subgroup.leftTransversals.diff MonoidHom.id {x : G // x ∈ H} y z = 1)  : 1 = 1
application type mismatch
  Subgroup.leftTransversals.diff ?m.400 { x // x ∈ H }
argument
  { x // x ∈ H }
has type
  Type u_1 : Type (u_1 + 1)
but is expected to have type
  ↑(Subgroup.leftTransversals ↑?m.275) : Type ?u.272 ; identifiers [G, u_1, Group, G, H, Subgroup, G, Subgroup.IsCommutative, H, Subgroup.FiniteIndex, H, x, Subgroup.leftTransversals, H, y, Subgroup.leftTransversals, H, z, Subgroup.leftTransversals, H, h, Subgroup.leftTransversals.diff, MonoidHom.id, x, G, x, H, x, y, h', Subgroup.leftTransversals.diff, MonoidHom.id, x, G, x, H, y, z] (during elaboration)

{α : Type u_1} {p : (a : Finset α) → Prop} (empty : p ∅) (cons : ∀ ⦃ a : α ⦄ {s : Finset α} (h : ¬ (a ∈ s : Prop)) (a_1 : p s) , p Finset.cons a s h) (x : Finset α) (s : Multiset α) (nd : Multiset.Nodup s)  : ∀ (nd : Multiset.Nodup 0) , p ∅
application type mismatch
  p Finset.cons
argument
  Finset.cons
has type
  (a : ?m.105) → (s : Finset ?m.105) → ¬a ∈ s → Finset ?m.105 : Type ?u.104
but is expected to have type
  Finset α : Type u_1 ; identifiers [α, u_1, p, a, Finset, α, empty, p, cons, a, α, s, Finset, α, h, a, s, a_1, p, s, p, Finset.cons, a, s, h, x, Finset, α, s, Multiset, α, nd, Multiset.Nodup, s, nd, Multiset.Nodup, p] (during elaboration)

{α : Type u} [AddGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {b : α} {c : α} (a : α)  : ((- b ≤ - a + a + - c) ↔ (c ≤ b)) = ((- b ≤ - a + a + - c) ↔ (c ≤ b))
function expected at
  x_1
term has type
  α ; identifiers [α, u, AddGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, b, α, c, α, a, α, b, a, a, c, c, b, b, a, a, c, c, b] (during elaboration)

{α : Type u} [AddGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {b : α} {c : α} (a : α)  : ((- b ≤ - c) ↔ (c ≤ b)) = ((- b ≤ - c) ↔ (c ≤ b))
function expected at
  x_1
term has type
  α ; identifiers [α, u, AddGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, b, α, c, α, a, α, b, c, c, b, b, c, c, b] (during elaboration)

{α : Type u} [AddGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {b : α} {c : α} (a : α)  : (c ≤ b) ↔ (c ≤ b)
function expected at
  x_1
term has type
  α ; identifiers [α, u, AddGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, b, α, c, α, a, α, c, b, c, b] (during elaboration)

{α : Type u_1} [LinearOrderedRing α] [FloorRing α] (a : α) (ha : Int.fract a ≠ 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)))  : (Or.inr ha) = (eq_or_ne Int.fract a 0)
<input>:1:112: expected term

{α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {M : Type u_3} [AddCommMonoid M] [TopologicalSpace M] [ContinuousAdd M] {ι : Type u_1} {f : (a : ι) → (a : α) → M} (s : Finset ι) (hf : ∀ (i : ι) (a : i ∈ s) , MeasureTheory.AEStronglyMeasurable f i μ) (_g : (a : α) → M) (hg : _g ∈ Multiset.map fun (i : ι) ↦ f i Finset.val s) (_i : ι) (hi : _i ∈ Finset.val s) (hg : f _i = _g)  : MeasureTheory.AEStronglyMeasurable f _i μ
function expected at
  MeasureTheory.AEStronglyMeasurable f ?m.80064
term has type
  Prop ; identifiers [α, u_2, m, MeasurableSpace, α, μ, MeasureTheory.Measure, α, M, u_3, AddCommMonoid, M, TopologicalSpace, M, ContinuousAdd, M, ι, u_1, f, a, ι, a, α, M, s, Finset, ι, hf, i, ι, a, i, s, MeasureTheory.AEStronglyMeasurable, f, i, μ, _g, a, α, M, hg, _g, Multiset.map, i, ι, f, i, Finset.val, s, _i, ι, hi, _i, Finset.val, s, hg, f, _i, _g, MeasureTheory.AEStronglyMeasurable, f, _i, μ] (during elaboration)

{x : ℝ} (hx : | x | ≤ 1)  : 5 = 5
<input>:1:14: expected ')' or no space before

{x : ℝ} (hx : | x | ≤ 1)  : 96 = 96
<input>:1:14: expected ')' or no space before

{f : (a : Ordinal .{u}) → Ordinal .{max u v}} (h : ∀ (a : Ordinal .{u}) , f a < f Order.succ a) (H : ∀ (o : Ordinal .{u}) (a : Ordinal.IsLimit o) , Ordinal.bsup o fun (x : Ordinal .{u}) (x_1 : x < o) ↦ f x = f o) (o : Ordinal .{u}) (ho : Ordinal.IsLimit o) (this : Ordinal.bsup o fun (x : Ordinal .{u}) (x_1 : x < o) ↦ f x = f o)  : ∀ (a : Ordinal .{u}) (x : a < o) , f a < f Order.succ a
<input>:1:18: expected ')'

{f : (a : Ordinal .{u}) → Ordinal .{max u v}} (h : ∀ (a : Ordinal .{u}) , f a < f Order.succ a) (H : ∀ (o : Ordinal .{u}) (a : Ordinal.IsLimit o) , Ordinal.bsup o fun (x : Ordinal .{u}) (x_1 : x < o) ↦ f x = f o) (o : Ordinal .{u}) (ho : Ordinal.IsLimit o)  : Ordinal.bsup o fun (x : Ordinal .{u}) (x_1 : x < o) ↦ f x = f o
<input>:1:18: expected ')'

{C : Type u_1} [inst : CategoryTheory.Category C] {X : CategoryTheory.SimplicialObject.Augmented C} (self : SimplicialObject.Augmented.ExtraDegeneracy X) (n : ℕ) (i : Fin n + 2)  : ∀ (C : Type u_1) [inst : CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject.Augmented C) (self : SimplicialObject.Augmented.ExtraDegeneracy X) (n : ℕ) (i : Fin n + 2) , CategoryTheory.CategoryStruct.comp self . 2 n + 1 CategoryTheory.SimplicialObject.δ CategoryTheory.Comma.left X Fin.succ i = CategoryTheory.CategoryStruct.comp CategoryTheory.SimplicialObject.δ CategoryTheory.Comma.left X i self . 2 n
invalid occurrence of `·` notation, it must be surrounded by parentheses (e.g. `(· + 1)`) ; identifiers [C, u_1, inst, CategoryTheory.Category, C, X, CategoryTheory.SimplicialObject.Augmented, C, self, SimplicialObject.Augmented.ExtraDegeneracy, X, n, i, Fin, n, C, u_1, inst, CategoryTheory.Category, C, X, CategoryTheory.SimplicialObject.Augmented, C, self, SimplicialObject.Augmented.ExtraDegeneracy, X, n, i, Fin, n, CategoryTheory.CategoryStruct.comp, self, n, CategoryTheory.SimplicialObject.δ, CategoryTheory.Comma.left, X, Fin.succ, i, CategoryTheory.CategoryStruct.comp, CategoryTheory.SimplicialObject.δ, CategoryTheory.Comma.left, X, i, self, n] (during elaboration)

{x : ℝ} (hx : | x | ≤ 1)  : 2 = 2
<input>:1:14: expected ')' or no space before

(x : ℂ) (z : ℂ) (hz : ‖ z ‖ ≤ 1)  : - 0 = 0
<input>:1:28: expected term

{x : ℝ} (hx : | x | ≤ 1)  : (x ^ 2 ≤ 1) = (x ^ 2 ≤ 1)
<input>:1:14: expected ')' or no space before

{α : Type u_1} {m : MeasurableSpace α} {f : (a : α) → α} {μ : MeasureTheory.Measure α} {β : Type u_2} {m' : MeasurableSpace β} {μ' : MeasureTheory.Measure β} {e : α ≃ᵐ β} (h : MeasureTheory.MeasurePreserving ↑ e)  : (MeasureTheory.MeasurePreserving f) ↔ (MeasureTheory.MeasurePreserving f)
typeclass instance problem is stuck, it is often due to metavariables
  MeasureTheory.MeasureSpace ?m.68252 ; identifiers [α, u_1, m, MeasurableSpace, α, f, a, α, α, μ, MeasureTheory.Measure, α, β, u_2, m', MeasurableSpace, β, μ', MeasureTheory.Measure, β, e, α, β, h, MeasureTheory.MeasurePreserving, e, MeasureTheory.MeasurePreserving, f, MeasureTheory.MeasurePreserving, f] (during elaboration)

{R : Type u_2} {A : Type u_1} [CommSemiring R] [StarRing R] [Semiring A] [Algebra R A] [StarRing A] [StarModule R A] {S : Set StarSubalgebra R A} {x : A} (p : StarSubalgebra R A)  : (p ∈ S) = (p ∈ S)
application type mismatch
  Set StarSubalgebra
argument
  StarSubalgebra
has type
  (R : Type ?u.1309) →
    (A : Type ?u.1308) →
      [inst : CommSemiring R] →
        [inst_1 : StarRing R] →
          [inst_2 : Semiring A] →
            [inst_3 : StarRing A] →
              [inst_4 : Algebra R A] → [inst : StarModule R A] → Type ?u.1308 : Type (max (?u.1308 + 1) (?u.1309 + 1))
but is expected to have type
  Type ?u.1307 : Type (?u.1307 + 1) ; identifiers [R, u_2, A, u_1, CommSemiring, R, StarRing, R, Semiring, A, Algebra, R, A, StarRing, A, StarModule, R, A, S, Set, StarSubalgebra, R, A, x, A, p, StarSubalgebra, R, A, p, S, p, S] (during elaboration)

{x : ℝ} (hx : | x | ≤ 1)  : (x * x ≤ 1) = (x * x ≤ 1)
<input>:1:14: expected ')' or no space before

{α : Type u_1} {β : Type u_3} {γ : Type u_2} {s : Set α} {t : Set β} {f₁ : (a : α) → β} {f₂ : (a : α) → β} {g : (a : β) → γ} (h : Set.EqOn g ∘ f₁ g ∘ f₂ s) (hg : Set.InjOn g t) (hf₁ : Set.MapsTo f₁ s t) (hf₂ : Set.MapsTo f₂ s t) (x : α) (ha : x ∈ s)  : f₁ x ∈ t
application type mismatch
  f₁ g
argument
  g
has type
  β → γ : Type (max u_2 u_3)
but is expected to have type
  α : Type u_1 ; identifiers [α, u_1, β, u_3, γ, u_2, s, Set, α, t, Set, β, f₁, a, α, β, f₂, a, α, β, g, a, β, γ, h, Set.EqOn, g, f₁, g, f₂, s, hg, Set.InjOn, g, t, hf₁, Set.MapsTo, f₁, s, t, hf₂, Set.MapsTo, f₂, s, t, x, α, ha, x, s, f₁, x, t] (during elaboration)

{α : Type u_1} {β : Type u_3} {γ : Type u_2} {s : Set α} {t : Set β} {f₁ : (a : α) → β} {f₂ : (a : α) → β} {g : (a : β) → γ} (h : Set.EqOn g ∘ f₁ g ∘ f₂ s) (hg : Set.InjOn g t) (hf₁ : Set.MapsTo f₁ s t) (hf₂ : Set.MapsTo f₂ s t) (x : α) (ha : x ∈ s)  : f₂ x ∈ t
application type mismatch
  f₁ g
argument
  g
has type
  β → γ : Type (max u_2 u_3)
but is expected to have type
  α : Type u_1 ; identifiers [α, u_1, β, u_3, γ, u_2, s, Set, α, t, Set, β, f₁, a, α, β, f₂, a, α, β, g, a, β, γ, h, Set.EqOn, g, f₁, g, f₂, s, hg, Set.InjOn, g, t, hf₁, Set.MapsTo, f₁, s, t, hf₂, Set.MapsTo, f₂, s, t, x, α, ha, x, s, f₂, x, t] (during elaboration)

{x : ℝ} (hx : | x | ≤ 1)  : (| x * x | ≤ 1) = (| x * x | ≤ 1)
<input>:1:14: expected ')' or no space before

{α : Type u_1} {β : Type u_3} {γ : Type u_2} {s : Set α} {t : Set β} {f₁ : (a : α) → β} {f₂ : (a : α) → β} {g : (a : β) → γ} (h : Set.EqOn g ∘ f₁ g ∘ f₂ s) (hg : Set.InjOn g t) (hf₁ : Set.MapsTo f₁ s t) (hf₂ : Set.MapsTo f₂ s t) (x : α) (ha : x ∈ s)  : g ∘ f₁ x = g ∘ f₂ x
application type mismatch
  f₁ g
argument
  g
has type
  β → γ : Type (max u_2 u_3)
but is expected to have type
  α : Type u_1 ; identifiers [α, u_1, β, u_3, γ, u_2, s, Set, α, t, Set, β, f₁, a, α, β, f₂, a, α, β, g, a, β, γ, h, Set.EqOn, g, f₁, g, f₂, s, hg, Set.InjOn, g, t, hf₁, Set.MapsTo, f₁, s, t, hf₂, Set.MapsTo, f₂, s, t, x, α, ha, x, s, g, f₁, x, g, f₂, x] (during elaboration)

(x : ℂ) (z : ℂ) (hz : ‖ z ‖ ≤ 1)  : z = z ^ Nat.rawCast 1 * Nat.rawCast 1 + 0
<input>:1:28: expected term

{f : (a : Ordinal .{u}) → Ordinal .{max u v}} (h : ∀ (a : Ordinal .{u}) , f a < f Order.succ a) (H : ∀ (o : Ordinal .{u}) (a : Ordinal.IsLimit o) , Ordinal.blsub o fun (x : Ordinal .{u}) (x_1 : x < o) ↦ f x = f o) (o : Ordinal .{u}) (ho : Ordinal.IsLimit o) (this : Ordinal.blsub o fun (x : Ordinal .{u}) (x_1 : x < o) ↦ f x = f o)  : ∀ (a : Ordinal .{u}) (x : a < o) , f a < f Order.succ a
<input>:1:18: expected ')'

{f : (a : Ordinal .{u}) → Ordinal .{max u v}} (h : ∀ (a : Ordinal .{u}) , f a < f Order.succ a) (H : ∀ (o : Ordinal .{u}) (a : Ordinal.IsLimit o) , Ordinal.blsub o fun (x : Ordinal .{u}) (x_1 : x < o) ↦ f x = f o) (o : Ordinal .{u}) (ho : Ordinal.IsLimit o)  : Ordinal.blsub o fun (x : Ordinal .{u}) (x_1 : x < o) ↦ f x = f o
<input>:1:18: expected ')'

{α : Type u_1} {p : (a : Finset α) → Prop} (empty : p ∅) (cons : ∀ ⦃ a : α ⦄ {s : Finset α} (h : ¬ (a ∈ s : Prop)) (a_1 : p s) , p Finset.cons a s h) (x : Finset α) (s : Multiset α) (nd : Multiset.Nodup s) ⦃ a : α ⦄ {s : Multiset α} (IH : ∀ (nd : Multiset.Nodup s) , p {val := ((s)) , nodup := ((nd))}) (nd : Multiset.Nodup a ::ₘ s) (m : ¬ (a ∈ s : Prop)) (nd' : Multiset.Nodup s) (h : (Iff.mp (Multiset.nodup_cons =: (Multiset.Nodup a ::ₘ s : Prop) ↔ ((¬ (a ∈ s : Prop) : Prop) ∧ (Multiset.Nodup s : Prop) : Prop)) nd =: (¬ (a ∈ s : Prop) : Prop) ∧ (Multiset.Nodup s : Prop)) = ({left := ((m)) , right := ((nd'))} =: (¬ (a ∈ s : Prop) : Prop) ∧ (Multiset.Nodup s : Prop)))  : ({left := ((m)) , right := ((nd'))}) = (Iff.mp Multiset.nodup_cons nd)
<input>:1:416: expected term

{o : Ordinal .{u}} (ho : Ordinal.IsLimit o) {f : (a : Ordinal .{u}) → (a : a < o) → Ordinal .{max u v}} (hf : ∀ (a : Ordinal .{u}) (ha : a < o) , f a ha < f Order.succ a (And.right ho a ha =: Order.succ a < o)) (i : Ordinal .{u}) (hi : i < o)  : f i hi < f Order.succ i (And.right ho i hi)
<input>:1:13: expected '//', '|' or '}'

{α : Type u} (l : List α) (n : ℕ) (n : ℕ) (hn : ∀ (l : List α) , List.rotate List.reverse List.rotate l n n = List.reverse l) (l : List α) (h : l = [])  : [] = l
application type mismatch
  List.rotate ?m.79590 List.rotate
argument
  List.rotate
has type
  List ?m.79592 → ℕ → List ?m.79592 : Type ?u.79591
but is expected to have type
  ℕ : Type ; identifiers [α, u, l, List, α, n, n, hn, l, List, α, List.rotate, List.reverse, List.rotate, l, n, n, List.reverse, l, l, List, α, h, l, l] (during elaboration)

{x : ℝ} (hx : | x | ≤ 1)  : 192 = 192
<input>:1:14: expected ')' or no space before

{V : Type u} {G : SimpleGraph V} {u : V} {v : V} (p : SimpleGraph.Walk G u v) {u_1 : V} {v_1 : V} {w : V} (h : SimpleGraph.Adj G u_1 v_1) (p_1 : SimpleGraph.Walk G v_1 w) (h_1 : u = u_1) (h : SimpleGraph.Adj G u v_1) (h_2 : v = w) (p_2 : SimpleGraph.Walk G v_1 v) (h_3 : HEq p SimpleGraph.Walk.cons h p_2)  : (u ∈ u :: SimpleGraph.Walk.support p_2) = ((u = u) ∨ (u ∈ SimpleGraph.Walk.support p_2))
function expected at
  HEq p SimpleGraph.Walk.cons
term has type
  Prop ; identifiers [V, u, G, SimpleGraph, V, u, V, v, V, p, SimpleGraph.Walk, G, u, v, u_1, V, v_1, V, w, V, h, SimpleGraph.Adj, G, u_1, v_1, p_1, SimpleGraph.Walk, G, v_1, w, h_1, u, u_1, h, SimpleGraph.Adj, G, u, v_1, h_2, v, w, p_2, SimpleGraph.Walk, G, v_1, v, h_3, HEq, p, SimpleGraph.Walk.cons, h, p_2, u, u, SimpleGraph.Walk.support, p_2, u, u, u, SimpleGraph.Walk.support, p_2] (during elaboration)

 : (∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {A : Mon_ C} (self : Mod_ A) , CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom Mon_.one A CategoryTheory.CategoryStruct.id Mod_.X self Mod_.act self = CategoryTheory.MonoidalCategory.leftUnitor Mod_.X self . hom)
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81502 ?m.162085
term has type
  ?m.486 ⟶ ?m.488 ; identifiers [C, u₁, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.MonoidalCategory, C, A, Mon_, C, self, Mod_, A, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, Mon_.one, A, CategoryTheory.CategoryStruct.id, Mod_.X, self, Mod_.act, self, CategoryTheory.MonoidalCategory.leftUnitor, Mod_.X, self, hom] (during elaboration)

 : ∀ (C : Type u₁) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] (A : Mon_ C) (self : Mod_ A) , CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom Mon_.one A CategoryTheory.CategoryStruct.id self . 1 self . 2 = CategoryTheory.MonoidalCategory.leftUnitor self . 1 . hom
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81499 ?m.162082
term has type
  ?m.483 ⟶ ?m.485 ; identifiers [C, u₁, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.MonoidalCategory, C, A, Mon_, C, self, Mod_, A, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, Mon_.one, A, CategoryTheory.CategoryStruct.id, self, self, CategoryTheory.MonoidalCategory.leftUnitor, self, hom] (during elaboration)

{M : Type u_1} {s : Set M} [Mul M] (h : s ⊆ Set.center M) (x : M) (x_1 : x ∈ ⊤) (x_2 : M) (hm : x_2 ∈ s)  : x * x_2 = x_2 * x
typeclass instance problem is stuck, it is often due to metavariables
  Membership M (?m.627 h x) ; identifiers [M, u_1, s, Set, M, Mul, M, h, s, Set.center, M, x, M, x_1, x, x_2, M, hm, x_2, s, x, x_2, x_2, x] (during elaboration)

{X : Type u_1} [TopologicalSpace X] {x : X} {y : X} {F : Set X} (h : JoinedIn F x y) (hx : x ∈ F) (hy : y ∈ F) (h_1 : (JoinedIn.mem h =: (x ∈ F : Prop) ∧ (y ∈ F : Prop)) = ({left := ((hx)) , right := ((hy))} =: (x ∈ F : Prop) ∧ (y ∈ F : Prop)))  : ({left := ((hx)) , right := ((hy))}) = (JoinedIn.mem h)
<input>:1:135: expected term

{α : Type u} (l : List α) (n : ℕ) (n : ℕ) (hn : ∀ (l : List α) , List.rotate List.reverse List.rotate l n n = List.reverse l) (l : List α) (hd : α) (tl : List α) (h : l = hd :: tl)  : hd :: tl = l
application type mismatch
  List.rotate ?m.79590 List.rotate
argument
  List.rotate
has type
  List ?m.79592 → ℕ → List ?m.79592 : Type ?u.79591
but is expected to have type
  ℕ : Type ; identifiers [α, u, l, List, α, n, n, hn, l, List, α, List.rotate, List.reverse, List.rotate, l, n, n, List.reverse, l, l, List, α, hd, α, tl, List, α, h, l, hd, tl, hd, tl, l] (during elaboration)

{α : Type u_1} {p : (a : Finset α) → Prop} (empty : p ∅) (cons : ∀ ⦃ a : α ⦄ {s : Finset α} (h : ¬ (a ∈ s : Prop)) (a_1 : p s) , p Finset.cons a s h) (x : Finset α) (s : Multiset α) (nd : Multiset.Nodup s) ⦃ a : α ⦄ {s : Multiset α} (IH : ∀ (nd : Multiset.Nodup s) , p {val := ((s)) , nodup := ((nd))}) (nd : Multiset.Nodup a ::ₘ s) (m : ¬ (a ∈ s : Prop)) (nd' : Multiset.Nodup s) (h : (Iff.mp (Multiset.nodup_cons =: (Multiset.Nodup a ::ₘ s : Prop) ↔ ((¬ (a ∈ s : Prop) : Prop) ∧ (Multiset.Nodup s : Prop) : Prop)) nd =: (¬ (a ∈ s : Prop) : Prop) ∧ (Multiset.Nodup s : Prop)) = ({left := ((m)) , right := ((nd'))} =: (¬ (a ∈ s : Prop) : Prop) ∧ (Multiset.Nodup s : Prop)))  : p {val := ((s)) , nodup := ((nd'))}
<input>:1:416: expected term

{β : Type u_1} [LinearOrder β] (h : WellFounded fun (x : β) (x_1 : β) ↦ x < x_1) {f : (a : β) → β} (hf : StrictMono f) (h₁ : ¬ (∀ (n : β) , n ≤ f n : Prop)) (h₂ : WellFounded.min h fun (x : β) ↦ Preorder.toLT . 1 f x x (Eq.mp (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun (n : β) ↦ n ≤ f n =: (¬ (∀ (x : β) , x ≤ f x : Prop) : Prop) = (∃ (x : β) , ¬ (x ≤ f x : Prop) : Prop)) (congrArg Exists (funext (fun (n : β) ↦ Mathlib.Tactic.PushNeg.not_le_eq n f n =: ∀ (n : β) , (¬ (n ≤ f n : Prop) : Prop) = (f n < n : Prop)) =: fun (x : β) ↦ ¬ (x ≤ f x : Prop) = fun (x : β) ↦ f x < x) =: (∃ (x : β) , ¬ (x ≤ f x : Prop) : Prop) = (∃ (x : β) , f x < x : Prop)) =: (¬ (∀ (x : β) , x ≤ f x : Prop) : Prop) = (∃ (x : β) , f x < x : Prop)) h₁ =: ∃ (x : β) , f x < x) ∈ fun (x : β) ↦ Preorder.toLT . 1 f x x)  : (¬ (∀ (x : β) , x ≤ f x)) = (∃ (x : β) , ¬ (x ≤ f x))
<input>:1:297: expected term

{β : Type u_1} [LinearOrder β] (h : WellFounded fun (x : β) (x_1 : β) ↦ x < x_1) {f : (a : β) → β} (hf : StrictMono f) (h₁ : ¬ (∀ (n : β) , n ≤ f n : Prop)) (h₂ : WellFounded.min h fun (x : β) ↦ Preorder.toLT . 1 f x x (Eq.mp (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun (n : β) ↦ n ≤ f n =: (¬ (∀ (x : β) , x ≤ f x : Prop) : Prop) = (∃ (x : β) , ¬ (x ≤ f x : Prop) : Prop)) (congrArg Exists (funext (fun (n : β) ↦ Mathlib.Tactic.PushNeg.not_le_eq n f n =: ∀ (n : β) , (¬ (n ≤ f n : Prop) : Prop) = (f n < n : Prop)) =: fun (x : β) ↦ ¬ (x ≤ f x : Prop) = fun (x : β) ↦ f x < x) =: (∃ (x : β) , ¬ (x ≤ f x : Prop) : Prop) = (∃ (x : β) , f x < x : Prop)) =: (¬ (∀ (x : β) , x ≤ f x : Prop) : Prop) = (∃ (x : β) , f x < x : Prop)) h₁ =: ∃ (x : β) , f x < x) ∈ fun (x : β) ↦ Preorder.toLT . 1 f x x)  : f f WellFounded.min h fun (x : β) ↦ Preorder.toLT . 1 f x x (Eq.mp (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun (n : β) ↦ n ≤ f n) (congrArg Exists (funext (fun (n : β) ↦ Mathlib.Tactic.PushNeg.not_le_eq n f n)))) h₁) < f WellFounded.min h fun (x : β) ↦ Preorder.toLT . 1 f x x (Eq.mp (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun (n : β) ↦ n ≤ f n) (congrArg Exists (funext (fun (n : β) ↦ Mathlib.Tactic.PushNeg.not_le_eq n f n)))) h₁)
<input>:1:297: expected term

{Ω : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace Ω} [TopologicalSpace β] [Preorder ι] {u : (a : ι) → (a : Ω) → β} {v : (a : ι) → (a : Ω) → β} {f : MeasureTheory.Filtration ι m} [MeasurableSpace ι] [Add β] [ContinuousAdd β] (hu : MeasureTheory.ProgMeasurable f u) (hv : MeasureTheory.ProgMeasurable f v) (i : ι)  : MeasureTheory.StronglyMeasurable fun (p : ↑ Set.Iic i × Ω) ↦ u ↑ Prod.fst p Prod.snd p
type mismatch
  Prod.fst
has type
  ?m.844 × ?m.845 → ?m.844 : Type (max ?u.842 ?u.843)
but is expected to have type
  ι : Type u_3 ; identifiers [Ω, u_2, β, u_1, ι, u_3, m, MeasurableSpace, Ω, TopologicalSpace, β, Preorder, ι, u, a, ι, a, Ω, β, v, a, ι, a, Ω, β, f, MeasureTheory.Filtration, ι, m, MeasurableSpace, ι, Add, β, ContinuousAdd, β, hu, MeasureTheory.ProgMeasurable, f, u, hv, MeasureTheory.ProgMeasurable, f, v, i, ι, MeasureTheory.StronglyMeasurable, p, Set.Iic, i, Ω, u, Prod.fst, p, Prod.snd, p] (during elaboration)

{Ω : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace Ω} [TopologicalSpace β] [Preorder ι] {u : (a : ι) → (a : Ω) → β} {v : (a : ι) → (a : Ω) → β} {f : MeasureTheory.Filtration ι m} [MeasurableSpace ι] [Add β] [ContinuousAdd β] (hu : MeasureTheory.ProgMeasurable f u) (hv : MeasureTheory.ProgMeasurable f v) (i : ι)  : MeasureTheory.StronglyMeasurable fun (p : ↑ Set.Iic i × Ω) ↦ v ↑ Prod.fst p Prod.snd p
type mismatch
  Prod.fst
has type
  ?m.844 × ?m.845 → ?m.844 : Type (max ?u.842 ?u.843)
but is expected to have type
  ι : Type u_3 ; identifiers [Ω, u_2, β, u_1, ι, u_3, m, MeasurableSpace, Ω, TopologicalSpace, β, Preorder, ι, u, a, ι, a, Ω, β, v, a, ι, a, Ω, β, f, MeasureTheory.Filtration, ι, m, MeasurableSpace, ι, Add, β, ContinuousAdd, β, hu, MeasureTheory.ProgMeasurable, f, u, hv, MeasureTheory.ProgMeasurable, f, v, i, ι, MeasureTheory.StronglyMeasurable, p, Set.Iic, i, Ω, v, Prod.fst, p, Prod.snd, p] (during elaboration)

(x : CategoryTheory.Limits.Cocone CategoryTheory.Functor.empty Type u_2) (x_1 : CategoryTheory.Limits.Cocone.pt {pt := ((PEmpty)) , ι := ((CategoryTheory.Functor.uniqueFromEmpty CategoryTheory.Functor.toPrefunctor CategoryTheory.Functor.const CategoryTheory.Discrete PEmpty . obj PEmpty . inv))} ⟶ CategoryTheory.Limits.Cocone.pt x) (x_2 : ∀ (j : CategoryTheory.Discrete PEmpty) , CategoryTheory.CategoryStruct.comp CategoryTheory.NatTrans.app CategoryTheory.Limits.Cocone.ι {pt := ((PEmpty)) , ι := ((CategoryTheory.Functor.uniqueFromEmpty CategoryTheory.Functor.toPrefunctor CategoryTheory.Functor.const CategoryTheory.Discrete PEmpty . obj PEmpty . inv))} j x_1 = CategoryTheory.NatTrans.app CategoryTheory.Limits.Cocone.ι x j) (x_3 : CategoryTheory.Limits.Cocone.pt {pt := ((PEmpty)) , ι := ((CategoryTheory.Functor.uniqueFromEmpty CategoryTheory.Functor.toPrefunctor CategoryTheory.Functor.const CategoryTheory.Discrete PEmpty . obj PEmpty . inv))})  : x_3 = x_3
function expected at
  CategoryTheory.Limits.Cocone ?m.165
term has type
  Type (max (max ?u.4 ?u.3) ?u.5) ; identifiers [x, CategoryTheory.Limits.Cocone, CategoryTheory.Functor.empty, u_2, x_1, CategoryTheory.Limits.Cocone.pt, pt, PEmpty, ι, CategoryTheory.Functor.uniqueFromEmpty, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Functor.const, CategoryTheory.Discrete, PEmpty, obj, PEmpty, inv, CategoryTheory.Limits.Cocone.pt, x, x_2, j, CategoryTheory.Discrete, PEmpty, CategoryTheory.CategoryStruct.comp, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cocone.ι, pt, PEmpty, ι, CategoryTheory.Functor.uniqueFromEmpty, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Functor.const, CategoryTheory.Discrete, PEmpty, obj, PEmpty, inv, j, x_1, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cocone.ι, x, j, x_3, CategoryTheory.Limits.Cocone.pt, pt, PEmpty, ι, CategoryTheory.Functor.uniqueFromEmpty, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Functor.const, CategoryTheory.Discrete, PEmpty, obj, PEmpty, inv, x_3, x_3] (during elaboration)

 : (∀ {α : Type u} (self : UniformSpace.Core α) , Filter.Tendsto Prod.swap UniformSpace.Core.uniformity self UniformSpace.Core.uniformity self)
application type mismatch
  Filter.Tendsto Prod.swap UniformSpace.Core.uniformity
argument
  UniformSpace.Core.uniformity
has type
  UniformSpace.Core ?m.20 → Filter (?m.20 × ?m.20) : Type ?u.19
but is expected to have type
  Filter (?m.14 × ?m.15) : Type (max ?u.12 ?u.13) ; identifiers [α, u, self, UniformSpace.Core, α, Filter.Tendsto, Prod.swap, UniformSpace.Core.uniformity, self, UniformSpace.Core.uniformity, self] (during elaboration)

 : ∀ (α : Type u) (self : UniformSpace.Core α) , Filter.Tendsto Prod.swap self . 1 self . 1
application type mismatch
  Filter.Tendsto Prod.swap self
argument
  self
has type
  UniformSpace.Core α : Type u
but is expected to have type
  Filter (?m.14 × ?m.15) : Type (max ?u.12 ?u.13) ; identifiers [α, u, self, UniformSpace.Core, α, Filter.Tendsto, Prod.swap, self, self] (during elaboration)

{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] [T2Space α] {f : (a : α) → β} {g : (a : β) → α} (h : Function.LeftInverse f g) (hf : Continuous f) (hg : Continuous g) (this : Set.EqOn g ∘ f id closure Set.range g) (x : α) (hx : x ∈ closure Set.range g)  : g ∘ f x = id x
application type mismatch
  f id
argument
  id
has type
  ?m.726 → ?m.726 : Sort ?u.725
but is expected to have type
  α : Type u ; identifiers [α, u, β, v, TopologicalSpace, α, TopologicalSpace, β, T2Space, α, f, a, α, β, g, a, β, α, h, Function.LeftInverse, f, g, hf, Continuous, f, hg, Continuous, g, this, Set.EqOn, g, f, id, closure, Set.range, g, x, α, hx, x, closure, Set.range, g, g, f, x, id, x] (during elaboration)

{H : Type u_1} [TopologicalSpace H] {α : Type u_2} [TopologicalSpace α] (e : LocalHomeomorph α H) (x : α) em : (a : Prop) → Decidable (a : Prop) := Classical.propDecidable  : fun (x : α) ↦ e x = fun (x : α) ↦ e x
<input>:1:109: expected end of input

{ι : Type u'} {R : Type u_1} {M : Type u_2} {v : (a : ι) → M} [Ring R] [AddCommGroup M] [Module R M] (hv : LinearIndependent R v)  : ⊤ = ⊤
typeclass instance problem is stuck, it is often due to metavariables
  Top (?m.2348 hv) ; identifiers [ι, u', R, u_1, M, u_2, v, a, ι, M, Ring, R, AddCommGroup, M, Module, R, M, hv, LinearIndependent, R, v] (during elaboration)

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inl h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)))  : (Or.inl h_1) = (subsingleton_or_nontrivial M₀)
<input>:1:143: expected term

 : (∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V] [inst_3 : AddTorsor V P] {ι : Type u_4} (p : (a : ι) → P) , (AffineIndependent k p) ↔ (∀ (s : Finset ι) (w : (a : ι) → k) (a : Finset.sum s fun (i : ι) ↦ w i = 0) (a : ↑ Finset.weightedVSub s p w = 0) (i : ι) (a : i ∈ s) , w i = 0))
failed to synthesize instance
  AddCommMonoid Prop ; identifiers [k, u_1, V, u_2, P, u_3, inst, Ring, k, inst_1, AddCommGroup, V, inst_2, Module, k, V, inst_3, AddTorsor, V, P, ι, u_4, p, a, ι, P, AffineIndependent, k, p, s, Finset, ι, w, a, ι, k, a, Finset.sum, s, i, ι, w, i, a, Finset.weightedVSub, s, p, w, i, ι, a, i, s, w, i] (during elaboration)

{α : Type u_1} [UniformSpace α] (x : Quotient UniformSpace.separationSetoid α × Quotient UniformSpace.separationSetoid α) (a : Quotient UniformSpace.separationSetoid α) (b : Quotient UniformSpace.separationSetoid α) (a : α) (b : α) (h : (Quotient.mk UniformSpace.separationSetoid α a , Quotient.mk UniformSpace.separationSetoid α b) ∈ separationRel Quotient UniformSpace.separationSetoid α) (s : Set α × α) (hs : s ∈ Filter.sets uniformity α) (this : s ∈ Filter.comap fun (p : α × α) ↦ (Quotient.mk UniformSpace.separationSetoid α Prod.fst p , Quotient.mk UniformSpace.separationSetoid α Prod.snd p) uniformity Quotient UniformSpace.separationSetoid α) (t : Set Quotient UniformSpace.separationSetoid α × Quotient UniformSpace.separationSetoid α) (ht : t ∈ uniformity Quotient UniformSpace.separationSetoid α) (hts : fun (p : α × α) ↦ (Quotient.mk UniformSpace.separationSetoid α Prod.fst p , Quotient.mk UniformSpace.separationSetoid α Prod.snd p) ⁻¹' t ⊆ s)  : (Quotient.mk UniformSpace.separationSetoid α a , Quotient.mk UniformSpace.separationSetoid α b) ∈ t
function expected at
  Quotient ?m.79938
term has type
  Sort ?u.12 ; identifiers [α, u_1, UniformSpace, α, x, Quotient, UniformSpace.separationSetoid, α, Quotient, UniformSpace.separationSetoid, α, a, Quotient, UniformSpace.separationSetoid, α, b, Quotient, UniformSpace.separationSetoid, α, a, α, b, α, h, Quotient.mk, UniformSpace.separationSetoid, α, a, Quotient.mk, UniformSpace.separationSetoid, α, b, separationRel, Quotient, UniformSpace.separationSetoid, α, s, Set, α, α, hs, s, Filter.sets, uniformity, α, this, s, Filter.comap, p, α, α, Quotient.mk, UniformSpace.separationSetoid, α, Prod.fst, p, Quotient.mk, UniformSpace.separationSetoid, α, Prod.snd, p, uniformity, Quotient, UniformSpace.separationSetoid, α, t, Set, Quotient, UniformSpace.separationSetoid, α, Quotient, UniformSpace.separationSetoid, α, ht, t, uniformity, Quotient, UniformSpace.separationSetoid, α, hts, p, α, α, Quotient.mk, UniformSpace.separationSetoid, α, Prod.fst, p, Quotient.mk, UniformSpace.separationSetoid, α, Prod.snd, p, t, s, Quotient.mk, UniformSpace.separationSetoid, α, a, Quotient.mk, UniformSpace.separationSetoid, α, b, t] (during elaboration)

{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] {a : α} {s : Set α} (ha : s ⊆ Set.Ioi a) (hs : ∀ (a_1 : Set.Nonempty s) , ∃ (b : α) , (b > a : Prop) ∧ (Set.Ioo a b ⊆ s : Prop)) (h : Set.Nonempty ↑ OrderDual.ofDual ⁻¹' s)  : ∃ (b : α) , (b > a) ∧ (Set.Ioo a b ⊆ s)
application type mismatch
  Set.preimage (Set.Nonempty ?m.3093)
argument
  Set.Nonempty ?m.3093
has type
  Prop : Type
but is expected to have type
  ?m.82339 ha hs → α : Type (max u ?u.2900) ; identifiers [α, u, TopologicalSpace, α, LinearOrder, α, OrderTopology, α, DenselyOrdered, α, a, α, s, Set, α, ha, s, Set.Ioi, a, hs, a_1, Set.Nonempty, s, b, α, b, a, Set.Ioo, a, b, s, h, Set.Nonempty, OrderDual.ofDual, s, b, α, b, a, Set.Ioo, a, b, s] (during elaboration)

{V : Type} (G : SimpleGraph V) [Finite V] (a : ↑ SimpleGraph.end G) (s : (j : Finset V ᵒᵖ) → CategoryTheory.Functor.toPrefunctor SimpleGraph.componentComplFunctor G . obj j) (property : s ∈ SimpleGraph.end G) (val : Fintype V) (h : (nonempty_fintype V =: Nonempty Fintype V) = (Nonempty.intro val =: Nonempty Fintype V))  : (Nonempty.intro val) = (nonempty_fintype V)
<input>:1:253: expected term

{α : Type u} {β : (a : α) → Type v} [DecidableEq α] (c : Sigma β) (l : List Sigma β) (h : List.NodupKeys c :: l) {α : Type u} {β : (a : α) → Type v} (entries : List Sigma β) (entries_1 : List Sigma β) (e_entries : entries = entries_1)  : ∀ (nodupKeys : List.NodupKeys entries) , {entries := ((entries)) , nodupKeys := ((nodupKeys))} = {entries := ((entries)) , nodupKeys := ((nodupKeys))}
application type mismatch
  List Sigma
argument
  Sigma
has type
  (?m.34 → Type ?u.32) → Type (max ?u.33 ?u.32) : Type (max (?u.32 + 1) (?u.33 + 1))
but is expected to have type
  Type ?u.31 : Type (?u.31 + 1) ; identifiers [α, u, β, a, α, v, DecidableEq, α, c, Sigma, β, l, List, Sigma, β, h, List.NodupKeys, c, l, α, u, β, a, α, v, entries, List, Sigma, β, entries_1, List, Sigma, β, e_entries, entries, entries_1, nodupKeys, List.NodupKeys, entries, entries, entries, nodupKeys, nodupKeys, entries, entries, nodupKeys, nodupKeys] (during elaboration)

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inl h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a') (h : a' = a) (a' : M)  : a = a
<input>:1:143: expected term

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inl h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a') (h : a' = a)  : a = a'
<input>:1:143: expected term

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inl h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a')  : a' = a'
<input>:1:143: expected term

{𝕜 : Type u_1} {E : Type u_2} [SeminormedRing 𝕜] [SMul 𝕜 E] {A : Set E} {B : Set E} (hA : Balanced 𝕜 A) (hB : Balanced 𝕜 B) (_a : 𝕜) (ha : ‖ _a ‖ ≤ 1)  : _a • A ⊆ A
<input>:1:146: expected term

{𝕜 : Type u_1} {E : Type u_2} [SeminormedRing 𝕜] [SMul 𝕜 E] {A : Set E} {B : Set E} (hA : Balanced 𝕜 A) (hB : Balanced 𝕜 B) (_a : 𝕜) (ha : ‖ _a ‖ ≤ 1)  : _a • B ⊆ B
<input>:1:146: expected term

{M₀ : Type u_1} [inst : MonoidWithZero M₀] {a : M₀} (h : IsUnit Ring.inverse a) (h_1 : Nontrivial M₀) (h_2 : (subsingleton_or_nontrivial M₀ =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)) = (Or.inr h_1 =: (Subsingleton M₀ : Prop) ∨ (Nontrivial M₀ : Prop)))  : (Or.inr h_1) = (subsingleton_or_nontrivial M₀)
<input>:1:141: expected term

 : (∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : (a : α) → β} (self : IsSpectralMap f) ⦃ s : Set β ⦄ (a : IsOpen s) (a : IsCompact s) , IsCompact f ⁻¹' s)
application type mismatch
  Set.preimage (IsCompact ?m.994)
argument
  IsCompact ?m.994
has type
  Prop : Type
but is expected to have type
  ?m.80489 self a✝ a → β : Type (max u_2 ?u.668) ; identifiers [α, u_1, β, u_2, inst, TopologicalSpace, α, inst_1, TopologicalSpace, β, f, a, α, β, self, IsSpectralMap, f, s, Set, β, a, IsOpen, s, a, IsCompact, s, IsCompact, f, s] (during elaboration)

 : ∀ (α : Type u_1) (β : Type u_2) [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f : (a : α) → β) (self : IsSpectralMap f) ⦃ s : Set β ⦄ (a : IsOpen s) (a : IsCompact s) , IsCompact f ⁻¹' s
application type mismatch
  Set.preimage (IsCompact ?m.994)
argument
  IsCompact ?m.994
has type
  Prop : Type
but is expected to have type
  ?m.80489 α β f self a✝ a → β : Type (max u_2 ?u.668) ; identifiers [α, u_1, β, u_2, inst, TopologicalSpace, α, inst_1, TopologicalSpace, β, f, a, α, β, self, IsSpectralMap, f, s, Set, β, a, IsOpen, s, a, IsCompact, s, IsCompact, f, s] (during elaboration)

{M : Type u_2} {N : Type u_1} [MulOneClass M] [MulOneClass N] (f : M →* N) (hf : ∀ (x : M) (y : M) , Commute ↑ f x ↑ f y) (x : M) (y : M)  : Commute ↑ f x ↑ f y
function expected at
  Commute ?m.42 x
term has type
  Prop ; identifiers [M, u_2, N, u_1, MulOneClass, M, MulOneClass, N, f, M, N, hf, x, M, y, M, Commute, f, x, f, y, x, M, y, M, Commute, f, x, f, y] (during elaboration)

{V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [Fact (FiniteDimensional.finrank ℝ V = 2 : Prop)] (o : Orientation ℝ V Fin 2) {x : V} {y : V} (h : Orientation.oangle o x y = ↑ Real.pi)  : ↑ Real.pi = Orientation.oangle o x y
application type mismatch
  Orientation ℝ V Fin
argument
  Fin
has type
  ℕ → Type : Type 1
but is expected to have type
  Type ?u.250 : Type (?u.250 + 1) ; identifiers [V, u_1, NormedAddCommGroup, V, InnerProductSpace, V, Fact, FiniteDimensional.finrank, V, o, Orientation, V, Fin, x, V, y, V, h, Orientation.oangle, o, x, y, Real.pi, Real.pi, Orientation.oangle, o, x, y] (during elaboration)

{α : Type u_2} {β : Type u_4} {β' : Type u_3} {γ : Type u_1} {δ : Type u_5} {f : Filter α} {g : Filter β} {m : (a : α) → (a : β') → γ} {n : (a : β) → β'} {m' : (a : β) → (a : α) → δ} {n' : (a : δ) → γ} (h_right_anticomm : ∀ (a : α) (b : β) , m a n b = n' m' b a) (a : β) (b : α)  : m b n a = n' m' a b
application type mismatch
  m a n
argument
  n
has type
  β → β' : Type (max u_3 u_4)
but is expected to have type
  β' : Type u_3 ; identifiers [α, u_2, β, u_4, β', u_3, γ, u_1, δ, u_5, f, Filter, α, g, Filter, β, m, a, α, a, β', γ, n, a, β, β', m', a, β, a, α, δ, n', a, δ, γ, h_right_anticomm, a, α, b, β, m, a, n, b, n', m', b, a, a, β, b, α, m, b, n, a, n', m', a, b] (during elaboration)

{α : Type u} (l : List α) (n : ℕ) (n : ℕ) (hn : ∀ (l : List α) , List.rotate List.reverse List.rotate l n n = List.reverse l) (l : List α)  : l = l
application type mismatch
  List.rotate ?m.79590 List.rotate
argument
  List.rotate
has type
  List ?m.79592 → ℕ → List ?m.79592 : Type ?u.79591
but is expected to have type
  ℕ : Type ; identifiers [α, u, l, List, α, n, n, hn, l, List, α, List.rotate, List.reverse, List.rotate, l, n, n, List.reverse, l, l, List, α, l, l] (during elaboration)

{α : Type u} {ι : Sort w} [TopologicalSpace α] {a : α} {p : (a : ι) → Prop} {s : (a : ι) → Set α} (h : Filter.HasBasis nhds a p s) {t : Set α} ⦃ i : ι ⦄  : (p i) = (p i)
application type mismatch
  Filter.HasBasis ?m.79905 a
argument
  a
has type
  α : Type u
but is expected to have type
  ?m.33 → Prop : Sort (max 1 ?u.30) ; identifiers [α, u, ι, w, TopologicalSpace, α, a, α, p, a, ι, s, a, ι, Set, α, h, Filter.HasBasis, nhds, a, p, s, t, Set, α, i, ι, p, i, p, i] (during elaboration)

{C : Type u_2} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (S : CategoryTheory.ShortComplex C) (hf : CategoryTheory.ShortComplex.f S = 0) (c : CategoryTheory.Limits.KernelFork CategoryTheory.ShortComplex.g S) (hc : CategoryTheory.Limits.IsLimit c)  : 0 = 0
function expected at
  CategoryTheory.Limits.KernelFork ?m.83128
term has type
  Type (max ?u.147 ?u.148) ; identifiers [C, u_2, CategoryTheory.Category, C, CategoryTheory.Limits.HasZeroMorphisms, C, S, CategoryTheory.ShortComplex, C, hf, CategoryTheory.ShortComplex.f, S, c, CategoryTheory.Limits.KernelFork, CategoryTheory.ShortComplex.g, S, hc, CategoryTheory.Limits.IsLimit, c] (during elaboration)

{F : Type v} [NormedAddCommGroup F] [NormedSpace ℂ F] {f : (a : ℂ) → F} (hf : Differentiable ℂ f) (hb : Metric.Bounded Set.range f) (z : ℂ) (w : ℂ) (c : ℂ) (C : ℝ) (h : (C > 0 : Prop) ∧ (∀ (z : ℂ) , ‖ f z ‖ ≤ C : Prop)) (C₀ : C > 0) (hC : ∀ (z : ℂ) , ‖ f z ‖ ≤ C) (ε : ℝ) (ε₀ : 0 < ε)  : ∀ (z : ℂ) (x : z ∈ Metric.sphere c C / ε) , ‖ f z ‖ ≤ C
<input>:1:207: expected term

{V : Type u_1} {P : Type u_2} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] [Fact (FiniteDimensional.finrank ℝ V = 2 : Prop)] [Module.Oriented ℝ V Fin 2] {p₁ : P} {p₂ : P} {p₃ : P} (h : EuclideanGeometry.oangle p₁ p₂ p₃ = ↑ Real.pi / 2)  : 1 = 1
application type mismatch
  Module.Oriented ℝ V Fin
argument
  Fin
has type
  ℕ → Type : Type 1
but is expected to have type
  Type ?u.490 : Type (?u.490 + 1) ; identifiers [V, u_1, P, u_2, NormedAddCommGroup, V, InnerProductSpace, V, MetricSpace, P, NormedAddTorsor, V, P, Fact, FiniteDimensional.finrank, V, Module.Oriented, V, Fin, p₁, P, p₂, P, p₃, P, h, EuclideanGeometry.oangle, p₁, p₂, p₃, Real.pi] (during elaboration)

{n : ℕ} {i : Fin Nat.succ n} {j : Fin Nat.succ n} (h : j = i)  : j ≤ i
application type mismatch
  Fin Nat.succ
argument
  Nat.succ
has type
  ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [n, i, Fin, Nat.succ, n, j, Fin, Nat.succ, n, h, j, i, j, i] (during elaboration)

{n : ℕ} {i : Fin Nat.succ n} {j : Fin Nat.succ n} (h : j = i)  : (if (j = i) then 0 else j + 1 = 0) = (if (j = i) then 0 else j + 1 = 0)
application type mismatch
  Fin Nat.succ
argument
  Nat.succ
has type
  ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [n, i, Fin, Nat.succ, n, j, Fin, Nat.succ, n, h, j, i, j, i, j, j, i, j] (during elaboration)

{n : ℕ} {i : Fin Nat.succ n} {j : Fin Nat.succ n} (h : j = i)  : 0 = 0
application type mismatch
  Fin Nat.succ
argument
  Nat.succ
has type
  ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [n, i, Fin, Nat.succ, n, j, Fin, Nat.succ, n, h, j, i] (during elaboration)

{α : Type u} [inst : AddGroup α] [LE α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α} {α : Type u} [AddGroup α] [LE α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α}  : ((0 ≤ a - b) ↔ (b ≤ a)) = ((0 ≤ a - b) ↔ (b ≤ a))
application type mismatch
  CovariantClass α α Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) → (y : ?m.20) → ?m.21 x y) →
    (y : ?m.20) → (x : ?m.19) → ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  α → α → α : Type u ; identifiers [α, u, inst, AddGroup, α, LE, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, α, u, AddGroup, α, LE, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, a, b, b, a, a, b, b, a] (during elaboration)

{α : Type u_1} [AddGroup α] [Preorder α] [DecidableRel fun (x : α) (x_1 : α) ↦ x < x_1] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] (a : α)  : ∀ (a : a < 0) , 1 = 1
function expected at
  x_1
term has type
  α ; identifiers [α, u_1, AddGroup, α, Preorder, α, DecidableRel, x, α, x_1, α, x, x_1, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, a, a] (during elaboration)

{α : Type u_1} [AddGroup α] [Preorder α] [DecidableRel fun (x : α) (x_1 : α) ↦ x < x_1] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] (a : α)  : ∀ (a_1 : ¬ (a < 0)) , if (- a < 0) then - 1 else 0 = if (- a < 0) then - 1 else 0
function expected at
  x_1
term has type
  α ; identifiers [α, u_1, AddGroup, α, Preorder, α, DecidableRel, x, α, x_1, α, x, x_1, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, a_1, a, a, a] (during elaboration)

{α : Type u} [inst : AddGroup α] [LE α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α} {α : Type u} [AddGroup α] [LE α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α}  : ((0 + b ≤ a - b + b) ↔ (b ≤ a)) = ((0 + b ≤ a - b + b) ↔ (b ≤ a))
application type mismatch
  CovariantClass α α Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) → (y : ?m.20) → ?m.21 x y) →
    (y : ?m.20) → (x : ?m.19) → ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  α → α → α : Type u ; identifiers [α, u, inst, AddGroup, α, LE, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, α, u, AddGroup, α, LE, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, b, a, b, b, b, a, b, a, b, b, b, a] (during elaboration)

{α : Type u} [inst : AddGroup α] [LE α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α} {α : Type u} [AddGroup α] [LE α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α}  : ((b ≤ a - b + b) ↔ (b ≤ a)) = ((b ≤ a - b + b) ↔ (b ≤ a))
application type mismatch
  CovariantClass α α Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) → (y : ?m.20) → ?m.21 x y) →
    (y : ?m.20) → (x : ?m.19) → ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  α → α → α : Type u ; identifiers [α, u, inst, AddGroup, α, LE, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, α, u, AddGroup, α, LE, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, b, a, b, b, b, a, b, a, b, b, b, a] (during elaboration)

{α : Type u} [inst : AddGroup α] [LE α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α} {α : Type u} [AddGroup α] [LE α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α}  : ((b ≤ a + - b + b) ↔ (b ≤ a)) = ((b ≤ a + - b + b) ↔ (b ≤ a))
application type mismatch
  CovariantClass α α Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) → (y : ?m.20) → ?m.21 x y) →
    (y : ?m.20) → (x : ?m.19) → ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  α → α → α : Type u ; identifiers [α, u, inst, AddGroup, α, LE, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, α, u, AddGroup, α, LE, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, b, a, b, b, b, a, b, a, b, b, b, a] (during elaboration)

{α : Type u} [inst : AddGroup α] [LE α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α} {α : Type u} [AddGroup α] [LE α] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α}  : (b ≤ a) ↔ (b ≤ a)
application type mismatch
  CovariantClass α α Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) → (y : ?m.20) → ?m.21 x y) →
    (y : ?m.20) → (x : ?m.19) → ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  α → α → α : Type u ; identifiers [α, u, inst, AddGroup, α, LE, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, α, u, AddGroup, α, LE, α, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, b, a, b, a] (during elaboration)

 : (∀ {m : (a : Type u_1) → Type u_2} [inst : Monad m] {σ : Type u_1} [inst_1 : MonadCont m] [inst_2 : LawfulMonadCont m] , LawfulMonad StateT σ m)
application type mismatch
  @LawfulMonad StateT
argument
  StateT
has type
  Type ?u.46 → (Type ?u.46 → Type ?u.45) → Type ?u.46 → Type (max ?u.46 ?u.45) : Type (max (?u.45 + 1) (?u.46 + 1))
but is expected to have type
  Type ?u.44 → Type ?u.43 : Type (max (?u.43 + 1) (?u.44 + 1)) ; identifiers [m, a, u_1, u_2, inst, Monad, m, σ, u_1, inst_1, MonadCont, m, inst_2, LawfulMonadCont, m, LawfulMonad, StateT, σ, m] (during elaboration)

 : ∀ {m : (a : Type u_1) → Type u_2} [inst : Monad m] {σ : Type u_1} [inst_1 : MonadCont m] [inst_2 : LawfulMonadCont m] , LawfulMonad StateT σ m
application type mismatch
  @LawfulMonad StateT
argument
  StateT
has type
  Type ?u.46 → (Type ?u.46 → Type ?u.45) → Type ?u.46 → Type (max ?u.46 ?u.45) : Type (max (?u.45 + 1) (?u.46 + 1))
but is expected to have type
  Type ?u.44 → Type ?u.43 : Type (max (?u.43 + 1) (?u.44 + 1)) ; identifiers [m, a, u_1, u_2, inst, Monad, m, σ, u_1, inst_1, MonadCont, m, inst_2, LawfulMonadCont, m, LawfulMonad, StateT, σ, m] (during elaboration)

{N : Type u_1} {X : Type u_2} [TopologicalSpace X] {x : X} (f : ↑ GenLoop N X x) (g : (a : (a : N) → ↑ unitInterval) → X) (h : g = ↑ f)  : ↑ f = g
type mismatch
  unitInterval
has type
  Set ℝ : Type
but is expected to have type
  Sort ?u.26 : Type ?u.26 ; identifiers [N, u_1, X, u_2, TopologicalSpace, X, x, X, f, GenLoop, N, X, x, g, a, a, N, unitInterval, X, h, g, f, f, g] (during elaboration)

{α : Type u_1} [AddGroup α] [Preorder α] [DecidableRel fun (x : α) (x_1 : α) ↦ x < x_1] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] (a : α)  : (a < 0) = (a < 0)
function expected at
  x_1
term has type
  α ; identifiers [α, u_1, AddGroup, α, Preorder, α, DecidableRel, x, α, x_1, α, x, x_1, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, a, a] (during elaboration)

{α : Type u_1} [AddGroup α] [Preorder α] [DecidableRel fun (x : α) (x_1 : α) ↦ x < x_1] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] (a : α) (a_1 : ¬ (a < 0 : Prop))  : ∀ (a : 0 < a) , - 1 = - 1
function expected at
  x_1
term has type
  α ; identifiers [α, u_1, AddGroup, α, Preorder, α, DecidableRel, x, α, x_1, α, x, x_1, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, a_1, a, a, a] (during elaboration)

{α : Type u_1} [AddGroup α] [Preorder α] [DecidableRel fun (x : α) (x_1 : α) ↦ x < x_1] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] (a : α) (a_1 : ¬ (a < 0 : Prop))  : ∀ (a : ¬ (0 < a)) , 0 = 0
function expected at
  x_1
term has type
  α ; identifiers [α, u_1, AddGroup, α, Preorder, α, DecidableRel, x, α, x_1, α, x, x_1, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, a_1, a, a, a] (during elaboration)

{R : Type u_1} [Rack R] (h : Rack.IsInvolutory R) (x : R) (y : R)  : Shelf.act x Shelf.act x y = y
application type mismatch
  Shelf.act x Shelf.act
argument
  Shelf.act
has type
  ?m.29 → ?m.29 → ?m.29 : Type ?u.28
but is expected to have type
  R : Type u_1 ; identifiers [R, u_1, Rack, R, h, Rack.IsInvolutory, R, x, R, y, R, Shelf.act, x, Shelf.act, x, y, y] (during elaboration)

{C : Type u₁} {inst : CategoryTheory.Category C} {X : C} {arrows : CategoryTheory.Presieve X} {downward_closed : ∀ {Y : C} {Z : C} {f : Y ⟶ X} (x : arrows f) (g : Z ⟶ Y) , arrows CategoryTheory.CategoryStruct.comp g f} {arrows_1 : CategoryTheory.Presieve X} {downward_closed_1 : ∀ {Y : C} {Z : C} {f : Y ⟶ X} (x : arrows_1 f) (g : Z ⟶ Y) , arrows_1 CategoryTheory.CategoryStruct.comp g f} (x : {arrows := ((arrows)) , downward_closed := ((downward_closed))} = {arrows := ((arrows_1)) , downward_closed := ((downward_closed_1))})  : ∀ (arrows_eq : arrows = arrows_1) , arrows = arrows_1
application type mismatch
  arrows CategoryTheory.CategoryStruct.comp
argument
  CategoryTheory.CategoryStruct.comp
has type
  (?m.555 ⟶ ?m.556) → (?m.556 ⟶ ?m.557) → (?m.555 ⟶ ?m.557) : Type ?u.552
but is expected to have type
  ?m.550 ⟶ X : Type ?u.7 ; identifiers [C, u₁, inst, CategoryTheory.Category, C, X, C, arrows, CategoryTheory.Presieve, X, downward_closed, Y, C, Z, C, f, Y, X, x, arrows, f, g, Z, Y, arrows, CategoryTheory.CategoryStruct.comp, g, f, arrows_1, CategoryTheory.Presieve, X, downward_closed_1, Y, C, Z, C, f, Y, X, x, arrows_1, f, g, Z, Y, arrows_1, CategoryTheory.CategoryStruct.comp, g, f, x, arrows, arrows, downward_closed, downward_closed, arrows, arrows_1, downward_closed, downward_closed_1, arrows_eq, arrows, arrows_1, arrows, arrows_1] (during elaboration)

{R : Type u₁} [StrictOrderedSemiring R] {a : R} (h : 0 ≤ a) (ha : a ≤ 1) (i : ℕ) (x : ℕ) (x : ℕ) (f : Nat.below x) (k : ℕ) (x : Nat.below Nat.succ k)  : (a ^ i + k + 1 ≤ a ^ i) = (a ^ i + k + 1 ≤ a ^ i)
application type mismatch
  Nat.below Nat.succ
argument
  Nat.succ
has type
  ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [R, u₁, StrictOrderedSemiring, R, a, R, h, a, ha, a, i, x, x, f, Nat.below, x, k, x, Nat.below, Nat.succ, k, a, i, k, a, i, a, i, k, a, i] (during elaboration)

 : (∀ {F : (a : Type u) → Type v} [inst : Applicative F] {G : (a : Type u) → Type w} [inst_1 : Applicative G] [inst_2 : (a : Type u) → SizeOf F a] [inst_3 : (a : Type u) → SizeOf G a] (app : (α : Type u) → (a : F α) → G α) (preserves_pure' : ∀ {α : Type u} (x : α) , app α pure x = pure x) (preserves_seq' : ∀ {α : Type u} {β : Type u} (x : F (a : α) → β) (y : F α) , app β Seq.seq x fun (x : Unit) ↦ y = Seq.seq app (a : α) → β x fun (x : Unit) ↦ app α y) , sizeOf {app := ((app)) , preserves_pure' := ((preserves_pure')) , preserves_seq' := ((preserves_seq'))} = 1)
application type mismatch
  SizeOf F
argument
  F
has type
  Type u → Type v : Type (max (u + 1) (v + 1))
but is expected to have type
  Sort ?u.30 : Type ?u.30 ; identifiers [F, a, u, v, inst, Applicative, F, G, a, u, w, inst_1, Applicative, G, inst_2, a, u, SizeOf, F, a, inst_3, a, u, SizeOf, G, a, app, α, u, a, F, α, G, α, preserves_pure', α, u, x, α, app, α, pure, x, pure, x, preserves_seq', α, u, β, u, x, F, a, α, β, y, F, α, app, β, Seq.seq, x, x, Unit, y, Seq.seq, app, a, α, β, x, x, Unit, app, α, y, sizeOf, app, app, preserves_pure', preserves_pure', preserves_seq', preserves_seq'] (during elaboration)

 : ∀ {F : (a : Type u) → Type v} [inst : Applicative F] {G : (a : Type u) → Type w} [inst_1 : Applicative G] [inst_2 : (a : Type u) → SizeOf F a] [inst_3 : (a : Type u) → SizeOf G a] (app : (α : Type u) → (a : F α) → G α) (preserves_pure' : ∀ {α : Type u} (x : α) , app α pure x = pure x) (preserves_seq' : ∀ {α : Type u} {β : Type u} (x : F (a : α) → β) (y : F α) , app β Seq.seq x fun (x : Unit) ↦ y = Seq.seq app (a : α) → β x fun (x : Unit) ↦ app α y) , 1 = 1
application type mismatch
  SizeOf F
argument
  F
has type
  Type u → Type v : Type (max (u + 1) (v + 1))
but is expected to have type
  Sort ?u.30 : Type ?u.30 ; identifiers [F, a, u, v, inst, Applicative, F, G, a, u, w, inst_1, Applicative, G, inst_2, a, u, SizeOf, F, a, inst_3, a, u, SizeOf, G, a, app, α, u, a, F, α, G, α, preserves_pure', α, u, x, α, app, α, pure, x, pure, x, preserves_seq', α, u, β, u, x, F, a, α, β, y, F, α, app, β, Seq.seq, x, x, Unit, y, Seq.seq, app, a, α, β, x, x, Unit, app, α, y] (during elaboration)

{R : Type u₁} [StrictOrderedSemiring R] {a : R} (h : 0 ≤ a) (ha : a ≤ 1) (i : ℕ) (x : ℕ) (x : ℕ) (f : Nat.below x) (k : ℕ) (x : Nat.below Nat.succ k)  : (a ^ i + k + 1 ≤ a ^ i) = (a ^ i + k + 1 ≤ a ^ i)
application type mismatch
  Nat.below Nat.succ
argument
  Nat.succ
has type
  ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [R, u₁, StrictOrderedSemiring, R, a, R, h, a, ha, a, i, x, x, f, Nat.below, x, k, x, Nat.below, Nat.succ, k, a, i, k, a, i, a, i, k, a, i] (during elaboration)

{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] {p : Submodule R M}  : ∀ (h : ∀ (x : M) , x ∈ p) (x : M) (x_1 : x ∈ ⊤) , x ∈ p
typeclass instance problem is stuck, it is often due to metavariables
  Membership M (?m.681 h x) ; identifiers [R, u_1, M, u_2, Semiring, R, AddCommMonoid, M, Module, R, M, p, Submodule, R, M, h, x, M, x, p, x, M, x_1, x, x, p] (during elaboration)

{R : Type u₁} [StrictOrderedSemiring R] {a : R} (h : 0 ≤ a) (ha : a ≤ 1) (i : ℕ) (x : ℕ) (x : ℕ) (f : Nat.below x) (k : ℕ) (x : Nat.below Nat.succ k)  : (a ^ i + k + 1 ≤ 1 * a ^ i) = (a ^ i + k + 1 ≤ 1 * a ^ i)
application type mismatch
  Nat.below Nat.succ
argument
  Nat.succ
has type
  ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [R, u₁, StrictOrderedSemiring, R, a, R, h, a, ha, a, i, x, x, f, Nat.below, x, k, x, Nat.below, Nat.succ, k, a, i, k, a, i, a, i, k, a, i] (during elaboration)

(α : Type) (C : Set Set α) (C' : Set Set α) (e'_2 : C = C') (h : C' = C) (C' : Set Set α)  : C = C
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.7 → Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Type ?u.6 : Type (?u.6 + 1) ; identifiers [α, C, Set, Set, α, C', Set, Set, α, e'_2, C, C', h, C', C, C', Set, Set, α, C, C] (during elaboration)

{α : Type u_1} [AddGroup α] [Preorder α] [DecidableRel fun (x : α) (x_1 : α) ↦ x < x_1] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] (a : α)  : (0 < a) = (0 < a)
function expected at
  x_1
term has type
  α ; identifiers [α, u_1, AddGroup, α, Preorder, α, DecidableRel, x, α, x_1, α, x, x_1, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, a, a] (during elaboration)

{α : Type u_1} [AddGroup α] [Preorder α] [DecidableRel fun (x : α) (x_1 : α) ↦ x < x_1] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x < x_1] (a : α)  : ∀ (a : 0 < a) , 1 = 1
function expected at
  x_1
term has type
  α ; identifiers [α, u_1, AddGroup, α, Preorder, α, DecidableRel, x, α, x_1, α, x, x_1, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, a, a] (during elaboration)

(α : Type) (C : Set Set α) (C' : Set Set α) (e'_2 : C = C') (h : C' = C)  : C = C'
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.7 → Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Type ?u.6 : Type (?u.6 + 1) ; identifiers [α, C, Set, Set, α, C', Set, Set, α, e'_2, C, C', h, C', C, C, C'] (during elaboration)

(α : Type) (C : Set Set α) (C' : Set Set α) (e'_2 : C = C')  : C' = C'
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.7 → Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Type ?u.6 : Type (?u.6 + 1) ; identifiers [α, C, Set, Set, α, C', Set, Set, α, e'_2, C, C', C', C'] (during elaboration)

{α : Type u_1} [LinearOrderedRing α] [FloorRing α] (a : α) (ha : Int.fract a ≠ 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop))) (this : ↑ ⌈ a ⌉ = ↑ ⌊ a ⌋ + 1)  : a = Mathlib.Tactic.Abel.termg 1 a 0
<input>:1:112: expected term

{α : Type u_1} [LinearOrderedRing α] [FloorRing α] (a : α) (ha : Int.fract a ≠ 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop))) (this : ↑ ⌈ a ⌉ = ↑ ⌊ a ⌋ + 1)  : 1 = Mathlib.Tactic.Abel.termg 1 1 0
<input>:1:112: expected term

{α : Type u_2} {β : Type u_1} [One β] {l : Filter α} {f : (a : α) → β} (hf : ∀ᶠ (x : α) in l , f x ≠ 1) {s : Set α} {t : Set α} (h : Set.mulIndicator s f =ᶠ[l] Set.mulIndicator t f) (this : ∀ {s : Set α} , Function.mulSupport Set.mulIndicator s f =ᶠ[l] s)  : Function.mulSupport Set.mulIndicator s f =ᶠ[l] s
function expected at
  Function.mulSupport Set.mulIndicator s
term has type
  Prop ; identifiers [α, u_2, β, u_1, One, β, l, Filter, α, f, a, α, β, hf, x, α, l, f, x, s, Set, α, t, Set, α, h, Set.mulIndicator, s, f, l, Set.mulIndicator, t, f, this, s, Set, α, Function.mulSupport, Set.mulIndicator, s, f, l, s, Function.mulSupport, Set.mulIndicator, s, f, l, s] (during elaboration)

{α : Type u_2} {β : Type u_1} [One β] {l : Filter α} {f : (a : α) → β} (hf : ∀ᶠ (x : α) in l , f x ≠ 1) {s : Set α} {t : Set α} (h : Set.mulIndicator s f =ᶠ[l] Set.mulIndicator t f) (this : ∀ {s : Set α} , Function.mulSupport Set.mulIndicator s f =ᶠ[l] s)  : Function.mulSupport Set.mulIndicator t f =ᶠ[l] t
function expected at
  Function.mulSupport Set.mulIndicator s
term has type
  Prop ; identifiers [α, u_2, β, u_1, One, β, l, Filter, α, f, a, α, β, hf, x, α, l, f, x, s, Set, α, t, Set, α, h, Set.mulIndicator, s, f, l, Set.mulIndicator, t, f, this, s, Set, α, Function.mulSupport, Set.mulIndicator, s, f, l, s, Function.mulSupport, Set.mulIndicator, t, f, l, t] (during elaboration)

{α : Type u_2} {n : ℕ} {C : (a : Vector3 α Nat.succ n) → Sort u_1} (v : Vector3 α Nat.succ n)  : C v = C v
application type mismatch
  Vector3 α Nat.succ
argument
  Nat.succ
has type
  ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [α, u_2, n, C, a, Vector3, α, Nat.succ, n, u_1, v, Vector3, α, Nat.succ, n, C, v, C, v] (during elaboration)

(𝕜 : Type u_1) {E : Type u_2} [IsROrC 𝕜] [NormedAddCommGroup E] [InnerProductSpace 𝕜 E] {x : E} {y : E} (h : ∀ (v : E) , inner x v = inner y v)  : (x = y) = (x = y)
typeclass instance problem is stuck, it is often due to metavariables
  Inner (?m.145 𝕜 v) E ; identifiers [𝕜, u_1, E, u_2, IsROrC, 𝕜, NormedAddCommGroup, E, InnerProductSpace, 𝕜, E, x, E, y, E, h, v, E, inner, x, v, inner, y, v, x, y, x, y] (during elaboration)

(𝕜 : Type u_1) {E : Type u_2} [IsROrC 𝕜] [NormedAddCommGroup E] [InnerProductSpace 𝕜 E] {x : E} {y : E} (h : ∀ (v : E) , inner x v = inner y v)  : (x - y = 0) = (x - y = 0)
typeclass instance problem is stuck, it is often due to metavariables
  Inner (?m.1399 𝕜 v) E ; identifiers [𝕜, u_1, E, u_2, IsROrC, 𝕜, NormedAddCommGroup, E, InnerProductSpace, 𝕜, E, x, E, y, E, h, v, E, inner, x, v, inner, y, v, x, y, x, y] (during elaboration)

{α : Type u_1} [LinearOrderedRing α] [FloorRing α] (a : α) (ha : Int.fract a ≠ 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop))) (this : ↑ ⌈ a ⌉ = ↑ ⌊ a ⌋ + 1)  : - 1 = - 1
<input>:1:112: expected term

{α : Type u_1} [LinearOrderedRing α] [FloorRing α] (a : α) (ha : Int.fract a ≠ 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop))) (this : ↑ ⌈ a ⌉ = ↑ ⌊ a ⌋ + 1)  : 1 = 1
<input>:1:112: expected term

 : (∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace E] {F : Type u_3} [inst_4 : NormedAddCommGroup F] [inst_5 : NormedSpace 𝕜 F] [inst_6 : CompleteSpace F] {G : Type u_4} [inst_7 : NormedAddCommGroup G] [inst_8 : NormedSpace 𝕜 G] [inst_9 : CompleteSpace G] (self : ImplicitFunctionData 𝕜 E F G) , HasStrictFDerivAt ImplicitFunctionData.leftFun self ImplicitFunctionData.leftDeriv self ImplicitFunctionData.pt self)
application type mismatch
  HasStrictFDerivAt ImplicitFunctionData.leftFun self
argument
  self
has type
  ImplicitFunctionData 𝕜 E F G : Type (max (max u_2 u_3) u_4)
but is expected to have type
  ImplicitFunctionData ?m.1134 ?m.1136 ?m.1140 ?m.1144 →L[?m.1122]
    ?m.1136 → ?m.1140 : Type (max (max (max ?u.1130 ?u.1131) ?u.1132) ?u.1131 ?u.1132) ; identifiers [𝕜, u_1, inst, NontriviallyNormedField, 𝕜, E, u_2, inst_1, NormedAddCommGroup, E, inst_2, NormedSpace, 𝕜, E, inst_3, CompleteSpace, E, F, u_3, inst_4, NormedAddCommGroup, F, inst_5, NormedSpace, 𝕜, F, inst_6, CompleteSpace, F, G, u_4, inst_7, NormedAddCommGroup, G, inst_8, NormedSpace, 𝕜, G, inst_9, CompleteSpace, G, self, ImplicitFunctionData, 𝕜, E, F, G, HasStrictFDerivAt, ImplicitFunctionData.leftFun, self, ImplicitFunctionData.leftDeriv, self, ImplicitFunctionData.pt, self] (during elaboration)

 : ∀ (𝕜 : Type u_1) [inst : NontriviallyNormedField 𝕜] (E : Type u_2) [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace E] (F : Type u_3) [inst_4 : NormedAddCommGroup F] [inst_5 : NormedSpace 𝕜 F] [inst_6 : CompleteSpace F] (G : Type u_4) [inst_7 : NormedAddCommGroup G] [inst_8 : NormedSpace 𝕜 G] [inst_9 : CompleteSpace G] (self : ImplicitFunctionData 𝕜 E F G) , HasStrictFDerivAt self . 1 self . 2 self . 5
invalid occurrence of `·` notation, it must be surrounded by parentheses (e.g. `(· + 1)`) ; identifiers [𝕜, u_1, inst, NontriviallyNormedField, 𝕜, E, u_2, inst_1, NormedAddCommGroup, E, inst_2, NormedSpace, 𝕜, E, inst_3, CompleteSpace, E, F, u_3, inst_4, NormedAddCommGroup, F, inst_5, NormedSpace, 𝕜, F, inst_6, CompleteSpace, F, G, u_4, inst_7, NormedAddCommGroup, G, inst_8, NormedSpace, 𝕜, G, inst_9, CompleteSpace, G, self, ImplicitFunctionData, 𝕜, E, F, G, HasStrictFDerivAt, self, self, self] (during elaboration)

{K : Type u_1} {n : ℕ} {s : Stream'.Seq GeneralizedContinuedFraction.Pair K} [DivisionRing K] (terminated_at_succ_n : Stream'.Seq.TerminatedAt s n + 1) (terminated_at_succ_n : Stream'.Seq.get? s n + 1 = none) (h : Stream'.Seq.get? s n = none)  : none = Stream'.Seq.get? s n
application type mismatch
  Stream'.Seq GeneralizedContinuedFraction.Pair
argument
  GeneralizedContinuedFraction.Pair
has type
  Type ?u.10 → Type ?u.10 : Type (?u.10 + 1)
but is expected to have type
  Type ?u.9 : Type (?u.9 + 1) ; identifiers [K, u_1, n, s, Stream'.Seq, GeneralizedContinuedFraction.Pair, K, DivisionRing, K, terminated_at_succ_n, Stream'.Seq.TerminatedAt, s, n, terminated_at_succ_n, Stream'.Seq.get?, s, n, none, h, Stream'.Seq.get?, s, n, none, none, Stream'.Seq.get?, s, n] (during elaboration)

{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (toLocalEquiv : LocalEquiv α β) (open_source : IsOpen LocalEquiv.source toLocalEquiv) (open_target : IsOpen LocalEquiv.target toLocalEquiv) (continuous_toFun : ContinuousOn ↑ toLocalEquiv LocalEquiv.source toLocalEquiv) (continuous_invFun : ContinuousOn LocalEquiv.invFun toLocalEquiv LocalEquiv.target toLocalEquiv) (toLocalEquiv_1 : LocalEquiv α β) (open_source_1 : IsOpen LocalEquiv.source toLocalEquiv_1) (open_target_1 : IsOpen LocalEquiv.target toLocalEquiv_1) (continuous_toFun_1 : ContinuousOn ↑ toLocalEquiv_1 LocalEquiv.source toLocalEquiv_1) (continuous_invFun_1 : ContinuousOn LocalEquiv.invFun toLocalEquiv_1 LocalEquiv.target toLocalEquiv_1) (a : {toLocalEquiv := ((toLocalEquiv)) , open_source := ((open_source)) , open_target := ((open_target)) , continuous_toFun := ((continuous_toFun)) , continuous_invFun := ((continuous_invFun))} = {toLocalEquiv := ((toLocalEquiv_1)) , open_source := ((open_source_1)) , open_target := ((open_target_1)) , continuous_toFun := ((continuous_toFun_1)) , continuous_invFun := ((continuous_invFun_1))})  : ∀ (toLocalEquiv_eq : toLocalEquiv = toLocalEquiv_1) , toLocalEquiv = toLocalEquiv_1
function expected at
  IsOpen ?m.210
term has type
  Prop ; identifiers [α, u_1, β, u_2, TopologicalSpace, α, TopologicalSpace, β, toLocalEquiv, LocalEquiv, α, β, open_source, IsOpen, LocalEquiv.source, toLocalEquiv, open_target, IsOpen, LocalEquiv.target, toLocalEquiv, continuous_toFun, ContinuousOn, toLocalEquiv, LocalEquiv.source, toLocalEquiv, continuous_invFun, ContinuousOn, LocalEquiv.invFun, toLocalEquiv, LocalEquiv.target, toLocalEquiv, toLocalEquiv_1, LocalEquiv, α, β, open_source_1, IsOpen, LocalEquiv.source, toLocalEquiv_1, open_target_1, IsOpen, LocalEquiv.target, toLocalEquiv_1, continuous_toFun_1, ContinuousOn, toLocalEquiv_1, LocalEquiv.source, toLocalEquiv_1, continuous_invFun_1, ContinuousOn, LocalEquiv.invFun, toLocalEquiv_1, LocalEquiv.target, toLocalEquiv_1, a, toLocalEquiv, toLocalEquiv, open_source, open_source, open_target, open_target, continuous_toFun, continuous_toFun, continuous_invFun, continuous_invFun, toLocalEquiv, toLocalEquiv_1, open_source, open_source_1, open_target, open_target_1, continuous_toFun, continuous_toFun_1, continuous_invFun, continuous_invFun_1, toLocalEquiv_eq, toLocalEquiv, toLocalEquiv_1, toLocalEquiv, toLocalEquiv_1] (during elaboration)

{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (toLocalEquiv : LocalEquiv α β) (open_source : IsOpen LocalEquiv.source toLocalEquiv) (open_target : IsOpen LocalEquiv.target toLocalEquiv) (continuous_toFun : ContinuousOn ↑ toLocalEquiv LocalEquiv.source toLocalEquiv) (continuous_invFun : ContinuousOn LocalEquiv.invFun toLocalEquiv LocalEquiv.target toLocalEquiv) (toLocalEquiv_1 : LocalEquiv α β) (open_source_1 : IsOpen LocalEquiv.source toLocalEquiv_1) (open_target_1 : IsOpen LocalEquiv.target toLocalEquiv_1) (continuous_toFun_1 : ContinuousOn ↑ toLocalEquiv_1 LocalEquiv.source toLocalEquiv_1) (continuous_invFun_1 : ContinuousOn LocalEquiv.invFun toLocalEquiv_1 LocalEquiv.target toLocalEquiv_1) (a : toLocalEquiv = toLocalEquiv_1) (h : toLocalEquiv_1 = toLocalEquiv) (toLocalEquiv_2 : LocalEquiv α β)  : toLocalEquiv = toLocalEquiv
function expected at
  IsOpen ?m.210
term has type
  Prop ; identifiers [α, u_1, β, u_2, TopologicalSpace, α, TopologicalSpace, β, toLocalEquiv, LocalEquiv, α, β, open_source, IsOpen, LocalEquiv.source, toLocalEquiv, open_target, IsOpen, LocalEquiv.target, toLocalEquiv, continuous_toFun, ContinuousOn, toLocalEquiv, LocalEquiv.source, toLocalEquiv, continuous_invFun, ContinuousOn, LocalEquiv.invFun, toLocalEquiv, LocalEquiv.target, toLocalEquiv, toLocalEquiv_1, LocalEquiv, α, β, open_source_1, IsOpen, LocalEquiv.source, toLocalEquiv_1, open_target_1, IsOpen, LocalEquiv.target, toLocalEquiv_1, continuous_toFun_1, ContinuousOn, toLocalEquiv_1, LocalEquiv.source, toLocalEquiv_1, continuous_invFun_1, ContinuousOn, LocalEquiv.invFun, toLocalEquiv_1, LocalEquiv.target, toLocalEquiv_1, a, toLocalEquiv, toLocalEquiv_1, h, toLocalEquiv_1, toLocalEquiv, toLocalEquiv_2, LocalEquiv, α, β, toLocalEquiv, toLocalEquiv] (during elaboration)

{α : Type u_1} [LinearOrderedRing α] [FloorRing α] (a : α) (ha : Int.fract a ≠ 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop))) (this : ↑ ⌈ a ⌉ = ↑ ⌊ a ⌋ + 1)  : 0 = 0
<input>:1:112: expected term

{H : Type u_1} [TopologicalSpace H] (u : StructureGroupoid H) ⦃ f : LocalHomeomorph H H ⦄ (hf : f ∈ StructureGroupoid.members ⊥) hf : f ∈ {LocalHomeomorph.refl H} ∪ {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ∅} := hf (hf_1 : f = LocalHomeomorph.refl H) (h : (Eq.mp (Mathlib.Geometry.Manifold.ChartedSpace._auxLemma.1 =: (f ∈ insert LocalHomeomorph.refl H {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ∅} : Prop) = ((f = LocalHomeomorph.refl H : Prop) ∨ (f ∈ {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ∅} : Prop) : Prop)) hf =: (f = LocalHomeomorph.refl H : Prop) ∨ (f ∈ {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ∅} : Prop)) = (Or.inl hf_1 =: (f = LocalHomeomorph.refl H : Prop) ∨ (LocalEquiv.source LocalHomeomorph.toLocalEquiv f = ∅ : Prop)))  : (Or.inl hf_1) = (Eq.mp Mathlib.Geometry.Manifold.ChartedSpace._auxLemma.1 hf)
<input>:1:129: expected '/--' or ':'

{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (toLocalEquiv : LocalEquiv α β) (open_source : IsOpen LocalEquiv.source toLocalEquiv) (open_target : IsOpen LocalEquiv.target toLocalEquiv) (continuous_toFun : ContinuousOn ↑ toLocalEquiv LocalEquiv.source toLocalEquiv) (continuous_invFun : ContinuousOn LocalEquiv.invFun toLocalEquiv LocalEquiv.target toLocalEquiv) (toLocalEquiv_1 : LocalEquiv α β) (open_source_1 : IsOpen LocalEquiv.source toLocalEquiv_1) (open_target_1 : IsOpen LocalEquiv.target toLocalEquiv_1) (continuous_toFun_1 : ContinuousOn ↑ toLocalEquiv_1 LocalEquiv.source toLocalEquiv_1) (continuous_invFun_1 : ContinuousOn LocalEquiv.invFun toLocalEquiv_1 LocalEquiv.target toLocalEquiv_1) (a : toLocalEquiv = toLocalEquiv_1) (h : toLocalEquiv_1 = toLocalEquiv) (open_source_2 : IsOpen LocalEquiv.source toLocalEquiv) (open_target_2 : IsOpen LocalEquiv.target toLocalEquiv) (continuous_toFun_2 : ContinuousOn ↑ toLocalEquiv LocalEquiv.source toLocalEquiv) (continuous_invFun_2 : ContinuousOn LocalEquiv.invFun toLocalEquiv LocalEquiv.target toLocalEquiv) (a : toLocalEquiv = toLocalEquiv) (h : HEq a (Eq.refl toLocalEquiv =: toLocalEquiv = toLocalEquiv))  : {toLocalEquiv := ((toLocalEquiv)) , open_source := ((open_source)) , open_target := ((open_target)) , continuous_toFun := ((continuous_toFun)) , continuous_invFun := ((continuous_invFun))} = {toLocalEquiv := ((toLocalEquiv)) , open_source := ((open_source)) , open_target := ((open_target)) , continuous_toFun := ((continuous_toFun)) , continuous_invFun := ((continuous_invFun))}
<input>:1:1161: expected term

{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (toLocalEquiv : LocalEquiv α β) (open_source : IsOpen LocalEquiv.source toLocalEquiv) (open_target : IsOpen LocalEquiv.target toLocalEquiv) (continuous_toFun : ContinuousOn ↑ toLocalEquiv LocalEquiv.source toLocalEquiv) (continuous_invFun : ContinuousOn LocalEquiv.invFun toLocalEquiv LocalEquiv.target toLocalEquiv) (toLocalEquiv_1 : LocalEquiv α β) (open_source_1 : IsOpen LocalEquiv.source toLocalEquiv_1) (open_target_1 : IsOpen LocalEquiv.target toLocalEquiv_1) (continuous_toFun_1 : ContinuousOn ↑ toLocalEquiv_1 LocalEquiv.source toLocalEquiv_1) (continuous_invFun_1 : ContinuousOn LocalEquiv.invFun toLocalEquiv_1 LocalEquiv.target toLocalEquiv_1) (a : toLocalEquiv = toLocalEquiv_1) (h : toLocalEquiv_1 = toLocalEquiv)  : toLocalEquiv = toLocalEquiv_1
function expected at
  IsOpen ?m.210
term has type
  Prop ; identifiers [α, u_1, β, u_2, TopologicalSpace, α, TopologicalSpace, β, toLocalEquiv, LocalEquiv, α, β, open_source, IsOpen, LocalEquiv.source, toLocalEquiv, open_target, IsOpen, LocalEquiv.target, toLocalEquiv, continuous_toFun, ContinuousOn, toLocalEquiv, LocalEquiv.source, toLocalEquiv, continuous_invFun, ContinuousOn, LocalEquiv.invFun, toLocalEquiv, LocalEquiv.target, toLocalEquiv, toLocalEquiv_1, LocalEquiv, α, β, open_source_1, IsOpen, LocalEquiv.source, toLocalEquiv_1, open_target_1, IsOpen, LocalEquiv.target, toLocalEquiv_1, continuous_toFun_1, ContinuousOn, toLocalEquiv_1, LocalEquiv.source, toLocalEquiv_1, continuous_invFun_1, ContinuousOn, LocalEquiv.invFun, toLocalEquiv_1, LocalEquiv.target, toLocalEquiv_1, a, toLocalEquiv, toLocalEquiv_1, h, toLocalEquiv_1, toLocalEquiv, toLocalEquiv, toLocalEquiv_1] (during elaboration)

{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (toLocalEquiv : LocalEquiv α β) (open_source : IsOpen LocalEquiv.source toLocalEquiv) (open_target : IsOpen LocalEquiv.target toLocalEquiv) (continuous_toFun : ContinuousOn ↑ toLocalEquiv LocalEquiv.source toLocalEquiv) (continuous_invFun : ContinuousOn LocalEquiv.invFun toLocalEquiv LocalEquiv.target toLocalEquiv) (toLocalEquiv_1 : LocalEquiv α β) (open_source_1 : IsOpen LocalEquiv.source toLocalEquiv_1) (open_target_1 : IsOpen LocalEquiv.target toLocalEquiv_1) (continuous_toFun_1 : ContinuousOn ↑ toLocalEquiv_1 LocalEquiv.source toLocalEquiv_1) (continuous_invFun_1 : ContinuousOn LocalEquiv.invFun toLocalEquiv_1 LocalEquiv.target toLocalEquiv_1) (a : toLocalEquiv = toLocalEquiv_1)  : toLocalEquiv_1 = toLocalEquiv_1
function expected at
  IsOpen ?m.210
term has type
  Prop ; identifiers [α, u_1, β, u_2, TopologicalSpace, α, TopologicalSpace, β, toLocalEquiv, LocalEquiv, α, β, open_source, IsOpen, LocalEquiv.source, toLocalEquiv, open_target, IsOpen, LocalEquiv.target, toLocalEquiv, continuous_toFun, ContinuousOn, toLocalEquiv, LocalEquiv.source, toLocalEquiv, continuous_invFun, ContinuousOn, LocalEquiv.invFun, toLocalEquiv, LocalEquiv.target, toLocalEquiv, toLocalEquiv_1, LocalEquiv, α, β, open_source_1, IsOpen, LocalEquiv.source, toLocalEquiv_1, open_target_1, IsOpen, LocalEquiv.target, toLocalEquiv_1, continuous_toFun_1, ContinuousOn, toLocalEquiv_1, LocalEquiv.source, toLocalEquiv_1, continuous_invFun_1, ContinuousOn, LocalEquiv.invFun, toLocalEquiv_1, LocalEquiv.target, toLocalEquiv_1, a, toLocalEquiv, toLocalEquiv_1, toLocalEquiv_1, toLocalEquiv_1] (during elaboration)

{α : Type u_1} [LinearOrderedRing α] [FloorRing α] (a : α) (ha : Int.fract a ≠ 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop))) (this : ↑ ⌈ a ⌉ = ↑ ⌊ a ⌋ + 1)  : Mathlib.Tactic.Abel.termg 0 1 0 = 0
<input>:1:112: expected term

{α : Type u_1} [LinearOrderedRing α] [FloorRing α] (a : α) (ha : Int.fract a ≠ 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop))) (this : ↑ ⌈ a ⌉ = ↑ ⌊ a ⌋ + 1)  : Mathlib.Tactic.Abel.termg 0 a 0 = 0
<input>:1:112: expected term

 : (∀ {R : Type u_1} [inst : Add R] [inst_1 : Mul R] {s : Setoid R} {ha : ∀ {w : R} {x : R} {y : R} {z : R} (a : Setoid.r w x) (a : Setoid.r y z) , Setoid.r w + y x + z} {hm : ∀ {w : R} {x : R} {y : R} {z : R} (a : Setoid.r w x) (a : Setoid.r y z) , Setoid.r w * y x * z} {a : R} {b : R} , (↑ {toSetoid := ((s)) , add' := ((ha)) , mul' := ((hm))} a b) ↔ (Setoid.r a b))
function expected at
  y
term has type
  R ; identifiers [R, u_1, inst, Add, R, inst_1, Mul, R, s, Setoid, R, ha, w, R, x, R, y, R, z, R, a, Setoid.r, w, x, a, Setoid.r, y, z, Setoid.r, w, y, x, z, hm, w, R, x, R, y, R, z, R, a, Setoid.r, w, x, a, Setoid.r, y, z, Setoid.r, w, y, x, z, a, R, b, R, toSetoid, s, add', ha, mul', hm, a, b, Setoid.r, a, b] (during elaboration)

 : ∀ {R : Type u_1} [inst : Add R] [inst_1 : Mul R] {s : Setoid R} {ha : ∀ {w : R} {x : R} {y : R} {z : R} (a : Setoid.r w x) (a : Setoid.r y z) , Setoid.r w + y x + z} {hm : ∀ {w : R} {x : R} {y : R} {z : R} (a : Setoid.r w x) (a : Setoid.r y z) , Setoid.r w * y x * z} {a : R} {b : R} , (↑ {toSetoid := ((s)) , add' := ((ha)) , mul' := ((hm))} a b) ↔ (↑ {toSetoid := ((s)) , add' := ((ha)) , mul' := ((hm))} a b)
function expected at
  y
term has type
  R ; identifiers [R, u_1, inst, Add, R, inst_1, Mul, R, s, Setoid, R, ha, w, R, x, R, y, R, z, R, a, Setoid.r, w, x, a, Setoid.r, y, z, Setoid.r, w, y, x, z, hm, w, R, x, R, y, R, z, R, a, Setoid.r, w, x, a, Setoid.r, y, z, Setoid.r, w, y, x, z, a, R, b, R, toSetoid, s, add', ha, mul', hm, a, b, toSetoid, s, add', ha, mul', hm, a, b] (during elaboration)

{G : Type u_1} [Group G] {H : Subgroup G} [Finite G ⧸ H] (val : Fintype G ⧸ H) (h : (nonempty_fintype G ⧸ H =: Nonempty Fintype G ⧸ H) = (Nonempty.intro val =: Nonempty Fintype G ⧸ H))  : (Nonempty.intro val) = (nonempty_fintype G ⧸ H)
<input>:1:109: expected term

{H : Type u_1} [TopologicalSpace H] (u : StructureGroupoid H) ⦃ f : LocalHomeomorph H H ⦄ (hf : f ∈ StructureGroupoid.members ⊥) hf : f ∈ {LocalHomeomorph.refl H} ∪ {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ∅} := hf (hf_1 : LocalEquiv.source LocalHomeomorph.toLocalEquiv f = ∅) (h : (Eq.mp (Mathlib.Geometry.Manifold.ChartedSpace._auxLemma.1 =: (f ∈ insert LocalHomeomorph.refl H {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ∅} : Prop) = ((f = LocalHomeomorph.refl H : Prop) ∨ (f ∈ {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ∅} : Prop) : Prop)) hf =: (f = LocalHomeomorph.refl H : Prop) ∨ (f ∈ {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ∅} : Prop)) = (Or.inr hf_1 =: (f = LocalHomeomorph.refl H : Prop) ∨ (LocalEquiv.source LocalHomeomorph.toLocalEquiv f = ∅ : Prop)))  : (Or.inr hf_1) = (Eq.mp Mathlib.Geometry.Manifold.ChartedSpace._auxLemma.1 hf)
<input>:1:129: expected '/--' or ':'

{R : Type u} [CommRing R] (t : Set PrimeSpectrum R) (I : Ideal R) (h : t ⊆ PrimeSpectrum.zeroLocus ↑ I) (x : R) (k : x ∈ I) (x_1 : PrimeSpectrum R) (j : x_1 ∈ t)  : x_1 ∈ PrimeSpectrum.zeroLocus ↑ I
application type mismatch
  Set PrimeSpectrum
argument
  PrimeSpectrum
has type
  (R : Type ?u.11) → [inst : CommRing R] → Type ?u.11 : Type (?u.11 + 1)
but is expected to have type
  Type ?u.10 : Type (?u.10 + 1) ; identifiers [R, u, CommRing, R, t, Set, PrimeSpectrum, R, I, Ideal, R, h, t, PrimeSpectrum.zeroLocus, I, x, R, k, x, I, x_1, PrimeSpectrum, R, j, x_1, t, x_1, PrimeSpectrum.zeroLocus, I] (during elaboration)

{K : Type u_1} {n : ℕ} {s : Stream'.Seq GeneralizedContinuedFraction.Pair K} [DivisionRing K] (terminated_at_succ_n : Stream'.Seq.TerminatedAt s n + 1) (terminated_at_succ_n : Stream'.Seq.get? s n + 1 = none) (val : GeneralizedContinuedFraction.Pair K) (h : Stream'.Seq.get? s n = some val)  : some val = Stream'.Seq.get? s n
application type mismatch
  Stream'.Seq GeneralizedContinuedFraction.Pair
argument
  GeneralizedContinuedFraction.Pair
has type
  Type ?u.10 → Type ?u.10 : Type (?u.10 + 1)
but is expected to have type
  Type ?u.9 : Type (?u.9 + 1) ; identifiers [K, u_1, n, s, Stream'.Seq, GeneralizedContinuedFraction.Pair, K, DivisionRing, K, terminated_at_succ_n, Stream'.Seq.TerminatedAt, s, n, terminated_at_succ_n, Stream'.Seq.get?, s, n, none, val, GeneralizedContinuedFraction.Pair, K, h, Stream'.Seq.get?, s, n, some, val, some, val, Stream'.Seq.get?, s, n] (during elaboration)

{α : Type u_1} {β : Type u_2} [UniformSpace α] [UniformSpace β] (toEquiv : α ≃ β) (uniformContinuous_toFun : UniformContinuous Equiv.toFun toEquiv) (uniformContinuous_invFun : UniformContinuous Equiv.invFun toEquiv) (toEquiv_1 : α ≃ β) (uniformContinuous_toFun_1 : UniformContinuous Equiv.toFun toEquiv_1) (uniformContinuous_invFun_1 : UniformContinuous Equiv.invFun toEquiv_1) (a : {toEquiv := ((toEquiv)) , uniformContinuous_toFun := ((uniformContinuous_toFun)) , uniformContinuous_invFun := ((uniformContinuous_invFun))} = {toEquiv := ((toEquiv_1)) , uniformContinuous_toFun := ((uniformContinuous_toFun_1)) , uniformContinuous_invFun := ((uniformContinuous_invFun_1))})  : ∀ (toEquiv_eq : toEquiv = toEquiv_1) , toEquiv = toEquiv_1
function expected at
  UniformContinuous Equiv.toFun
term has type
  Prop ; identifiers [α, u_1, β, u_2, UniformSpace, α, UniformSpace, β, toEquiv, α, β, uniformContinuous_toFun, UniformContinuous, Equiv.toFun, toEquiv, uniformContinuous_invFun, UniformContinuous, Equiv.invFun, toEquiv, toEquiv_1, α, β, uniformContinuous_toFun_1, UniformContinuous, Equiv.toFun, toEquiv_1, uniformContinuous_invFun_1, UniformContinuous, Equiv.invFun, toEquiv_1, a, toEquiv, toEquiv, uniformContinuous_toFun, uniformContinuous_toFun, uniformContinuous_invFun, uniformContinuous_invFun, toEquiv, toEquiv_1, uniformContinuous_toFun, uniformContinuous_toFun_1, uniformContinuous_invFun, uniformContinuous_invFun_1, toEquiv_eq, toEquiv, toEquiv_1, toEquiv, toEquiv_1] (during elaboration)

{𝕜 : Type u_1} [LinearOrderedField 𝕜] {x : 𝕜} {y : 𝕜} (hxy : x ≠ y) (h : x < y) (h_1 : (Ne.lt_or_lt hxy =: (x < y : Prop) ∨ (y < x : Prop)) = (Or.inl h =: (x < y : Prop) ∨ (y < x : Prop)))  : (Or.inl h) = (Ne.lt_or_lt hxy)
<input>:1:105: expected term

⦃ J : Type u_1 ⦄ (F : (a : J) → CategoryTheory.Grpd) (s : CategoryTheory.Limits.Fan F) (m : CategoryTheory.Limits.Cone.pt s ⟶ CategoryTheory.Limits.Cone.pt CategoryTheory.Grpd.piLimitFan F) (w : ∀ (j : J) , CategoryTheory.CategoryStruct.comp m CategoryTheory.Limits.Fan.proj CategoryTheory.Grpd.piLimitFan F j = CategoryTheory.Limits.Fan.proj s j) (j : J)  : CategoryTheory.CategoryStruct.comp m CategoryTheory.Limits.Fan.proj CategoryTheory.Grpd.piLimitFan F j = CategoryTheory.Limits.Fan.proj s j
function expected at
  ?m.81889.pt
term has type
  ?m.1243 ; identifiers [J, u_1, F, a, J, CategoryTheory.Grpd, s, CategoryTheory.Limits.Fan, F, m, CategoryTheory.Limits.Cone.pt, s, CategoryTheory.Limits.Cone.pt, CategoryTheory.Grpd.piLimitFan, F, w, j, J, CategoryTheory.CategoryStruct.comp, m, CategoryTheory.Limits.Fan.proj, CategoryTheory.Grpd.piLimitFan, F, j, CategoryTheory.Limits.Fan.proj, s, j, j, J, CategoryTheory.CategoryStruct.comp, m, CategoryTheory.Limits.Fan.proj, CategoryTheory.Grpd.piLimitFan, F, j, CategoryTheory.Limits.Fan.proj, s, j] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ℕ} (h : Nat.coprime n addOrderOf x)  : (1 • n • x = x) = (1 • n • x = x)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 → ℕ : Type ?u.16
but is expected to have type
  ℕ : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, n, x, x, n, x, x] (during elaboration)

{α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure α} {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure α} (h : MeasureTheory.Measure.ae μ ≤ MeasureTheory.Measure.ae ν) (s : Set α)  : ∀ (hs : ∀ᵐ (a : α) ∂ ν , ¬ (a ∈ s)) , {x : α | fun (a : α) ↦ ¬ (a ∈ s) x} ∈ MeasureTheory.Measure.ae μ
function expected at
  a ∈ s
term has type
  Prop ; identifiers [α, u_1, m0, MeasurableSpace, α, μ, MeasureTheory.Measure, α, ν, MeasureTheory.Measure, α, α, u_1, m0, MeasurableSpace, α, μ, MeasureTheory.Measure, α, ν, MeasureTheory.Measure, α, h, MeasureTheory.Measure.ae, μ, MeasureTheory.Measure.ae, ν, s, Set, α, hs, a, α, ν, a, s, x, α, a, α, a, s, x, MeasureTheory.Measure.ae, μ] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ℕ} (h : Nat.coprime n addOrderOf x)  : (1 • 1 • x = x) = (1 • 1 • x = x)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 → ℕ : Type ?u.16
but is expected to have type
  ℕ : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, x, x, x, x] (during elaboration)

{H : Type u_1} [TopologicalSpace H] (u : StructureGroupoid H) ⦃ f : LocalHomeomorph H H ⦄ (hf : f ∈ StructureGroupoid.members ⊥) hf : f ∈ {LocalHomeomorph.refl H} ∪ {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ∅} := hf (hf_1 : LocalEquiv.source LocalHomeomorph.toLocalEquiv f = ∅) (h : (Eq.mp (Mathlib.Geometry.Manifold.ChartedSpace._auxLemma.1 =: (f ∈ insert LocalHomeomorph.refl H {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ∅} : Prop) = ((f = LocalHomeomorph.refl H : Prop) ∨ (f ∈ {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ∅} : Prop) : Prop)) hf =: (f = LocalHomeomorph.refl H : Prop) ∨ (f ∈ {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ∅} : Prop)) = (Or.inr hf_1 =: (f = LocalHomeomorph.refl H : Prop) ∨ (LocalEquiv.source LocalHomeomorph.toLocalEquiv f = ∅ : Prop))) (x : H) (hx : x ∈ LocalEquiv.source LocalHomeomorph.toLocalEquiv f)  : (x ∈ ∅) = (x ∈ ∅)
<input>:1:129: expected '/--' or ':'

{G : Type u_1} [AddMonoid G] {x : G} {n : ℕ} (h : Nat.coprime n addOrderOf x)  : (1 • x = x) = (1 • x = x)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 → ℕ : Type ?u.16
but is expected to have type
  ℕ : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, x, x, x, x] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ℕ} (h : Nat.coprime n addOrderOf x)  : x = x
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 → ℕ : Type ?u.16
but is expected to have type
  ℕ : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, x, x] (during elaboration)

{α : Type u_1} {β : Type u_2} [UniformSpace α] [UniformSpace β] (toEquiv : α ≃ β) (uniformContinuous_toFun : UniformContinuous Equiv.toFun toEquiv) (uniformContinuous_invFun : UniformContinuous Equiv.invFun toEquiv) (toEquiv_1 : α ≃ β) (uniformContinuous_toFun_1 : UniformContinuous Equiv.toFun toEquiv_1) (uniformContinuous_invFun_1 : UniformContinuous Equiv.invFun toEquiv_1) (a : toEquiv = toEquiv_1) (h : toEquiv_1 = toEquiv) (toEquiv_2 : α ≃ β)  : toEquiv = toEquiv
function expected at
  UniformContinuous Equiv.toFun
term has type
  Prop ; identifiers [α, u_1, β, u_2, UniformSpace, α, UniformSpace, β, toEquiv, α, β, uniformContinuous_toFun, UniformContinuous, Equiv.toFun, toEquiv, uniformContinuous_invFun, UniformContinuous, Equiv.invFun, toEquiv, toEquiv_1, α, β, uniformContinuous_toFun_1, UniformContinuous, Equiv.toFun, toEquiv_1, uniformContinuous_invFun_1, UniformContinuous, Equiv.invFun, toEquiv_1, a, toEquiv, toEquiv_1, h, toEquiv_1, toEquiv, toEquiv_2, α, β, toEquiv, toEquiv] (during elaboration)

{α : Type u_1} {β : Type u_2} [UniformSpace α] [UniformSpace β] (toEquiv : α ≃ β) (uniformContinuous_toFun : UniformContinuous Equiv.toFun toEquiv) (uniformContinuous_invFun : UniformContinuous Equiv.invFun toEquiv) (toEquiv_1 : α ≃ β) (uniformContinuous_toFun_1 : UniformContinuous Equiv.toFun toEquiv_1) (uniformContinuous_invFun_1 : UniformContinuous Equiv.invFun toEquiv_1) (a : toEquiv = toEquiv_1) (h : toEquiv_1 = toEquiv) (uniformContinuous_toFun_2 : UniformContinuous Equiv.toFun toEquiv) (uniformContinuous_invFun_2 : UniformContinuous Equiv.invFun toEquiv) (a : toEquiv = toEquiv) (h : HEq a (Eq.refl toEquiv =: toEquiv = toEquiv))  : {toEquiv := ((toEquiv)) , uniformContinuous_toFun := ((uniformContinuous_toFun)) , uniformContinuous_invFun := ((uniformContinuous_invFun))} = {toEquiv := ((toEquiv)) , uniformContinuous_toFun := ((uniformContinuous_toFun)) , uniformContinuous_invFun := ((uniformContinuous_invFun))}
<input>:1:621: expected term

{α : Type u_1} {β : Type u_2} [UniformSpace α] [UniformSpace β] (toEquiv : α ≃ β) (uniformContinuous_toFun : UniformContinuous Equiv.toFun toEquiv) (uniformContinuous_invFun : UniformContinuous Equiv.invFun toEquiv) (toEquiv_1 : α ≃ β) (uniformContinuous_toFun_1 : UniformContinuous Equiv.toFun toEquiv_1) (uniformContinuous_invFun_1 : UniformContinuous Equiv.invFun toEquiv_1) (a : toEquiv = toEquiv_1) (h : toEquiv_1 = toEquiv)  : toEquiv = toEquiv_1
function expected at
  UniformContinuous Equiv.toFun
term has type
  Prop ; identifiers [α, u_1, β, u_2, UniformSpace, α, UniformSpace, β, toEquiv, α, β, uniformContinuous_toFun, UniformContinuous, Equiv.toFun, toEquiv, uniformContinuous_invFun, UniformContinuous, Equiv.invFun, toEquiv, toEquiv_1, α, β, uniformContinuous_toFun_1, UniformContinuous, Equiv.toFun, toEquiv_1, uniformContinuous_invFun_1, UniformContinuous, Equiv.invFun, toEquiv_1, a, toEquiv, toEquiv_1, h, toEquiv_1, toEquiv, toEquiv, toEquiv_1] (during elaboration)

{α : Type u_1} {β : Type u_2} [UniformSpace α] [UniformSpace β] (toEquiv : α ≃ β) (uniformContinuous_toFun : UniformContinuous Equiv.toFun toEquiv) (uniformContinuous_invFun : UniformContinuous Equiv.invFun toEquiv) (toEquiv_1 : α ≃ β) (uniformContinuous_toFun_1 : UniformContinuous Equiv.toFun toEquiv_1) (uniformContinuous_invFun_1 : UniformContinuous Equiv.invFun toEquiv_1) (a : toEquiv = toEquiv_1)  : toEquiv_1 = toEquiv_1
function expected at
  UniformContinuous Equiv.toFun
term has type
  Prop ; identifiers [α, u_1, β, u_2, UniformSpace, α, UniformSpace, β, toEquiv, α, β, uniformContinuous_toFun, UniformContinuous, Equiv.toFun, toEquiv, uniformContinuous_invFun, UniformContinuous, Equiv.invFun, toEquiv, toEquiv_1, α, β, uniformContinuous_toFun_1, UniformContinuous, Equiv.toFun, toEquiv_1, uniformContinuous_invFun_1, UniformContinuous, Equiv.invFun, toEquiv_1, a, toEquiv, toEquiv_1, toEquiv_1, toEquiv_1] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ℕ} (h : Nat.coprime n addOrderOf x)  : (0 • n • x = x) = (0 • n • x = x)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 → ℕ : Type ?u.16
but is expected to have type
  ℕ : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, n, x, x, n, x, x] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ℕ} (h : Nat.coprime n addOrderOf x)  : (0 • n • 0 = 0) = (0 • n • 0 = 0)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 → ℕ : Type ?u.16
but is expected to have type
  ℕ : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, n, n] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ℕ} (h : Nat.coprime n addOrderOf x)  : (0 • 0 = 0) = (0 • 0 = 0)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 → ℕ : Type ?u.16
but is expected to have type
  ℕ : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ℕ} (h : Nat.coprime n addOrderOf x)  : 0 = 0
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 → ℕ : Type ?u.16
but is expected to have type
  ℕ : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x] (during elaboration)

{𝕜 : Type u_1} [LinearOrderedField 𝕜] {x : 𝕜} {y : 𝕜} (hxy : x ≠ y) (h : y < x) (h_1 : (Ne.lt_or_lt hxy =: (x < y : Prop) ∨ (y < x : Prop)) = (Or.inr h =: (x < y : Prop) ∨ (y < x : Prop)))  : (Or.inr h) = (Ne.lt_or_lt hxy)
<input>:1:105: expected term

{a : ℕ} (a1 : 1 < a) (m : ℕ) (n : ℕ) (h : Pell.yn a1 m ∣ Pell.yn a1 n) (hp : n % m > 0) (co : Nat.coprime Pell.yn a1 m Pell.xn a1 m * n / m) (e : m = 0)  : (n % 0 > 0) = (n % 0 > 0)
application type mismatch
  Nat.coprime Pell.yn
argument
  Pell.yn
has type
  1 < ?m.136 → ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [a, a1, a, m, n, h, Pell.yn, a1, m, Pell.yn, a1, n, hp, n, m, co, Nat.coprime, Pell.yn, a1, m, Pell.xn, a1, m, n, m, e, m, n, n] (during elaboration)

{a : ℕ} (a1 : 1 < a) (m : ℕ) (n : ℕ) (h : Pell.yn a1 m ∣ Pell.yn a1 n) (hp : n % m > 0) (co : Nat.coprime Pell.yn a1 m Pell.xn a1 m * n / m) (e : m = 0)  : (n % m > 0) = (n % m > 0)
application type mismatch
  Nat.coprime Pell.yn
argument
  Pell.yn
has type
  1 < ?m.136 → ℕ → ℕ : Type
but is expected to have type
  ℕ : Type ; identifiers [a, a1, a, m, n, h, Pell.yn, a1, m, Pell.yn, a1, n, hp, n, m, co, Nat.coprime, Pell.yn, a1, m, Pell.xn, a1, m, n, m, e, m, n, m, n, m] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ℕ} (h : Nat.coprime n addOrderOf x) (m : ℕ) (h : n * m % addOrderOf x = 1)  : (m • n • x = x) = (m • n • x = x)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 → ℕ : Type ?u.16
but is expected to have type
  ℕ : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, m, h, n, m, addOrderOf, x, m, n, x, x, m, n, x, x] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ℕ} (h : Nat.coprime n addOrderOf x) (m : ℕ) (h : n * m % addOrderOf x = 1)  : (n * m • x = x) = (n * m • x = x)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 → ℕ : Type ?u.16
but is expected to have type
  ℕ : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, m, h, n, m, addOrderOf, x, n, m, x, x, n, m, x, x] (during elaboration)

{α : Type u_1} [LinearOrderedRing α] [FloorRing α] (a : α) (ha : Int.fract a ≠ 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)))  : (⌈ a ⌉ = ⌊ a ⌋ + 1) = (⌈ a ⌉ = ⌊ a ⌋ + 1)
<input>:1:112: expected term

{G : Type u_1} [AddMonoid G] {x : G} {n : ℕ} (h : Nat.coprime n addOrderOf x) (m : ℕ) (h : n * m % addOrderOf x = 1)  : (1 • x = x) = (1 • x = x)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 → ℕ : Type ?u.16
but is expected to have type
  ℕ : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, m, h, n, m, addOrderOf, x, x, x, x, x] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ℕ} (h : Nat.coprime n addOrderOf x) (m : ℕ) (h : n * m % addOrderOf x = 1)  : x = x
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 → ℕ : Type ?u.16
but is expected to have type
  ℕ : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, m, h, n, m, addOrderOf, x, x, x] (during elaboration)

{ι : Type u_2} {π : (a : ι) → Type u_1} [Finite ι] [(i : ι) → LinearOrder π i] [(i : ι) → TopologicalSpace π i] [∀ (i : ι) , OrderTopology π i] {a : (i : ι) → π i} {b : (i : ι) → π i} {x : (i : ι) → π i} (ha : ∀ (i : ι) , a i < x i) (hb : ∀ (i : ι) , x i < b i) (x_1 : ι) (x_2 : x_1 ∈ Set.univ)  : a x_1 < x x_1
application type mismatch
  LinearOrder π
argument
  π
has type
  ι → Type u_1 : Type (max (u_1 + 1) u_2)
but is expected to have type
  Type ?u.19 : Type (?u.19 + 1) ; identifiers [ι, u_2, π, a, ι, u_1, Finite, ι, i, ι, LinearOrder, π, i, i, ι, TopologicalSpace, π, i, i, ι, OrderTopology, π, i, a, i, ι, π, i, b, i, ι, π, i, x, i, ι, π, i, ha, i, ι, a, i, x, i, hb, i, ι, x, i, b, i, x_1, ι, x_2, x_1, Set.univ, a, x_1, x, x_1] (during elaboration)

{ι : Type u_2} {π : (a : ι) → Type u_1} [Finite ι] [(i : ι) → LinearOrder π i] [(i : ι) → TopologicalSpace π i] [∀ (i : ι) , OrderTopology π i] {a : (i : ι) → π i} {b : (i : ι) → π i} {x : (i : ι) → π i} (ha : ∀ (i : ι) , a i < x i) (hb : ∀ (i : ι) , x i < b i) (x_1 : ι) (x_2 : x_1 ∈ Set.univ)  : x x_1 < b x_1
application type mismatch
  LinearOrder π
argument
  π
has type
  ι → Type u_1 : Type (max (u_1 + 1) u_2)
but is expected to have type
  Type ?u.19 : Type (?u.19 + 1) ; identifiers [ι, u_2, π, a, ι, u_1, Finite, ι, i, ι, LinearOrder, π, i, i, ι, TopologicalSpace, π, i, i, ι, OrderTopology, π, i, a, i, ι, π, i, b, i, ι, π, i, x, i, ι, π, i, ha, i, ι, a, i, x, i, hb, i, ι, x, i, b, i, x_1, ι, x_2, x_1, Set.univ, x, x_1, b, x_1] (during elaboration)

{α : Type u_1} [LinearOrderedRing α] [FloorRing α] (a : α) (ha : Int.fract a ≠ 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)))  : (↑ ⌊ a ⌋ + 1 - 1 < a) = (↑ ⌊ a ⌋ + 1 - 1 < a)
<input>:1:112: expected term

{α : Type u_1} {P : (a : α) → Prop} {Q : (a : α) → Prop} (H : ∀ (a : α) (a_1 : P a) , Q a) (x : Ordnode α) (x : Ordnode α) (f : Ordnode.below (motive := fun (x : Ordnode α) ↦ ∀ (a : Ordnode.Any P x) , Ordnode.Any Q x) x) (s : ℕ) (l : Ordnode α) (x : α) (r : Ordnode α) (x_1 : Ordnode.below (motive := fun (x : Ordnode α) ↦ ∀ (a : Ordnode.Any P x) , Ordnode.Any Q x) Ordnode.node s l x r)  : ∀ (a : P x) , Q x
application type mismatch
  Ordnode.below (motive := fun x => Ordnode.Any P x → Ordnode.Any Q x) Ordnode.node
argument
  Ordnode.node
has type
  ℕ → Ordnode ?m.99 → ?m.99 → Ordnode ?m.99 → Ordnode ?m.99 : Type ?u.98
but is expected to have type
  Ordnode α : Type u_1 ; identifiers [α, u_1, P, a, α, Q, a, α, H, a, α, a_1, P, a, Q, a, x, Ordnode, α, x, Ordnode, α, f, Ordnode.below, motive, x, Ordnode, α, a, Ordnode.Any, P, x, Ordnode.Any, Q, x, x, s, l, Ordnode, α, x, α, r, Ordnode, α, x_1, Ordnode.below, motive, x, Ordnode, α, a, Ordnode.Any, P, x, Ordnode.Any, Q, x, Ordnode.node, s, l, x, r, a, P, x, Q, x] (during elaboration)

{α : Type u_1} [LinearOrderedRing α] [FloorRing α] (a : α) (ha : Int.fract a ≠ 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)))  : (↑ ⌊ a ⌋ + ↑ 1 - 1 < a) = (↑ ⌊ a ⌋ + ↑ 1 - 1 < a)
<input>:1:112: expected term

{α : Type u_1} [LinearOrderedRing α] [FloorRing α] (a : α) (ha : Int.fract a ≠ 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)))  : (↑ ⌊ a ⌋ + 1 - 1 < a) = (↑ ⌊ a ⌋ + 1 - 1 < a)
<input>:1:112: expected term

{α : Type u_1} [LinearOrderedRing α] [FloorRing α] (a : α) (ha : Int.fract a ≠ 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ∨ (Int.fract a ≠ 0 : Prop)))  : (↑ ⌊ a ⌋ < a) = (↑ ⌊ a ⌋ < a)
<input>:1:112: expected term

{x : PGame} {y : PGame}  : ((∀ (i : PGame.LeftMoves x) , (∃ (i_1 : PGame.LeftMoves y) , PGame.moveLeft x i ≤ PGame.moveLeft y i_1) ∨ (∃ (j : PGame.RightMoves PGame.moveLeft x i) , PGame.moveRight PGame.moveLeft x i j ≤ y)) ∧ (∀ (j : PGame.RightMoves y) , (∃ (i : PGame.LeftMoves PGame.moveRight y j) , x ≤ PGame.moveLeft PGame.moveRight y j i) ∨ (∃ (j_1 : PGame.RightMoves x) , PGame.moveRight x j_1 ≤ PGame.moveRight y j))) ↔ ((∀ (i : PGame.LeftMoves x) , (∃ (i_1 : PGame.LeftMoves y) , PGame.moveLeft x i ≤ PGame.moveLeft y i_1) ∨ (∃ (j : PGame.RightMoves PGame.moveLeft x i) , PGame.moveRight PGame.moveLeft x i j ≤ y)) ∧ (∀ (j : PGame.RightMoves y) , (∃ (i : PGame.LeftMoves PGame.moveRight y j) , x ≤ PGame.moveLeft PGame.moveRight y j i) ∨ (∃ (j_1 : PGame.RightMoves x) , PGame.moveRight x j_1 ≤ PGame.moveRight y j)))
application type mismatch
  PGame.RightMoves PGame.moveLeft
argument
  PGame.moveLeft
has type
  (g : PGame) → PGame.LeftMoves g → PGame : Type (?u.71 + 1)
but is expected to have type
  PGame : Type (?u.70 + 1) ; identifiers [x, PGame, y, PGame, i, PGame.LeftMoves, x, i_1, PGame.LeftMoves, y, PGame.moveLeft, x, i, PGame.moveLeft, y, i_1, j, PGame.RightMoves, PGame.moveLeft, x, i, PGame.moveRight, PGame.moveLeft, x, i, j, y, j, PGame.RightMoves, y, i, PGame.LeftMoves, PGame.moveRight, y, j, x, PGame.moveLeft, PGame.moveRight, y, j, i, j_1, PGame.RightMoves, x, PGame.moveRight, x, j_1, PGame.moveRight, y, j, i, PGame.LeftMoves, x, i_1, PGame.LeftMoves, y, PGame.moveLeft, x, i, PGame.moveLeft, y, i_1, j, PGame.RightMoves, PGame.moveLeft, x, i, PGame.moveRight, PGame.moveLeft, x, i, j, y, j, PGame.RightMoves, y, i, PGame.LeftMoves, PGame.moveRight, y, j, x, PGame.moveLeft, PGame.moveRight, y, j, i, j_1, PGame.RightMoves, x, PGame.moveRight, x, j_1, PGame.moveRight, y, j] (during elaboration)

(L : FirstOrder.Language) {α : Type u'} {M : Type w} [FirstOrder.Language.Structure FirstOrder.Language.withConstants L α M] (s : Set α) (φ : FirstOrder.Language.Sentence FirstOrder.Language.withConstants L α)  : (M ⊨ φ) = (M ⊨ φ)
application type mismatch
  FirstOrder.Language.Structure FirstOrder.Language.withConstants
argument
  FirstOrder.Language.withConstants
has type
  FirstOrder.Language → Type ?u.17 → FirstOrder.Language : Type (max (max (?u.17 + 1) (?u.18 + 1)) (?u.19 + 1))
but is expected to have type
  FirstOrder.Language : Type (max (?u.16 + 1) (?u.15 + 1)) ; identifiers [L, FirstOrder.Language, α, u', M, w, FirstOrder.Language.Structure, FirstOrder.Language.withConstants, L, α, M, s, Set, α, φ, FirstOrder.Language.Sentence, FirstOrder.Language.withConstants, L, α, M, φ, M, φ, M, φ, M, φ] (during elaboration)

{R : Type u_1} [Semiring R] (n : ℕ) (a : R) [Decidable (a = 0 : Prop)] (i : ℕ) (hi : ↑ i < ↑ n)  : (if (i = n) then a else 0 = 0) = (if (i = n) then a else 0 = 0)
application type mismatch
  if i = n then a else 0 = 0
argument
  0 = 0
has type
  Prop : Type
but is expected to have type
  R : Type u_1 ; identifiers [R, u_1, Semiring, R, n, a, R, Decidable, a, i, hi, i, n, i, n, a, i, n, a] (during elaboration)

 : (∀ {α : Type u_1} [inst : Preorder α] [inst_1 : OrderBot α] {a : α} , (IsCoatom ↑ OrderDual.toDual a) ↔ (IsAtom a))
function expected at
  IsCoatom ?m.28
term has type
  Prop ; identifiers [α, u_1, inst, Preorder, α, inst_1, OrderBot, α, a, α, IsCoatom, OrderDual.toDual, a, IsAtom, a] (during elaboration)

 : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : OrderBot α] {a : α} , (IsCoatom ↑ OrderDual.toDual a) ↔ (IsCoatom ↑ OrderDual.toDual a)
function expected at
  IsCoatom ?m.28
term has type
  Prop ; identifiers [α, u_1, inst, Preorder, α, inst_1, OrderBot, α, a, α, IsCoatom, OrderDual.toDual, a, IsCoatom, OrderDual.toDual, a] (during elaboration)

{α : Type u} {β : Type v} {φ : Ultrafilter α} [LinearOrder β] (x : Filter.Germ ↑ φ β) (y : Filter.Germ ↑ φ β) (a : (a : α) → β) (b : (a : α) → β) (h : ↑ a ≤ ↑ b) (h_1 : (le_total ↑ a ↑ b =: (↑ a ≤ ↑ b : Prop) ∨ (↑ b ≤ ↑ a : Prop)) = (Or.inl h =: (↑ a ≤ ↑ b : Prop) ∨ (↑ b ≤ ↑ a : Prop)))  : (Or.inl h) = (le_total ↑ a ↑ b)
<input>:1:188: expected term

{V : Type u} {G : SimpleGraph V} {toProd : V × V} {is_adj : SimpleGraph.Adj G Prod.fst toProd Prod.snd toProd} {toProd_1 : V × V} {is_adj_1 : SimpleGraph.Adj G Prod.fst toProd_1 Prod.snd toProd_1} (x : {toProd := ((toProd)) , is_adj := ((is_adj))} = {toProd := ((toProd_1)) , is_adj := ((is_adj_1))})  : ∀ (toProd_eq : toProd = toProd_1) , toProd = toProd_1
application type mismatch
  SimpleGraph.Adj G Prod.fst
argument
  Prod.fst
has type
  ?m.21 × ?m.22 → ?m.21 : Type (max ?u.19 ?u.20)
but is expected to have type
  V : Type u ; identifiers [V, u, G, SimpleGraph, V, toProd, V, V, is_adj, SimpleGraph.Adj, G, Prod.fst, toProd, Prod.snd, toProd, toProd_1, V, V, is_adj_1, SimpleGraph.Adj, G, Prod.fst, toProd_1, Prod.snd, toProd_1, x, toProd, toProd, is_adj, is_adj, toProd, toProd_1, is_adj, is_adj_1, toProd_eq, toProd, toProd_1, toProd, toProd_1] (during elaboration)

(x : ENNReal) (y : ENNReal) {z : ℝ} (hz : 0 ≤ z)  : ∀ (a : False) , ⊤ = ⊤
typeclass instance problem is stuck, it is often due to metavariables
  Top (?m.769 x y hz a) ; identifiers [x, ENNReal, y, ENNReal, z, hz, z, a, False] (during elaboration)

{α : Type u_5} {β : Type u_4} {γ : Type u_3} {a : Option α} {b : Option β} {α' : Type u_1} {δ : Type u_2} {f : (a : α') → (a : β) → γ} {g : (a : α) → α'} {f' : (a : β) → (a : α) → δ} {g' : (a : δ) → γ} (h_left_anticomm : ∀ (a : α) (b : β) , f g a b = g' f' b a) (h : a = none)  : none = a
application type mismatch
  f g
argument
  g
has type
  α → α' : Type (max u_1 u_5)
but is expected to have type
  α' : Type u_1 ; identifiers [α, u_5, β, u_4, γ, u_3, a, Option, α, b, Option, β, α', u_1, δ, u_2, f, a, α', a, β, γ, g, a, α, α', f', a, β, a, α, δ, g', a, δ, γ, h_left_anticomm, a, α, b, β, f, g, a, b, g', f', b, a, h, a, none, none, a] (during elaboration)

{α : Type u_5} {β : Type u_4} {γ : Type u_3} {a : Option α} {b : Option β} {α' : Type u_1} {δ : Type u_2} {f : (a : α') → (a : β) → γ} {g : (a : α) → α'} {f' : (a : β) → (a : α) → δ} {g' : (a : δ) → γ} (h_left_anticomm : ∀ (a : α) (b : β) , f g a b = g' f' b a) (h : a = none) (h : b = none)  : none = b
application type mismatch
  f g
argument
  g
has type
  α → α' : Type (max u_1 u_5)
but is expected to have type
  α' : Type u_1 ; identifiers [α, u_5, β, u_4, γ, u_3, a, Option, α, b, Option, β, α', u_1, δ, u_2, f, a, α', a, β, γ, g, a, α, α', f', a, β, a, α, δ, g', a, δ, γ, h_left_anticomm, a, α, b, β, f, g, a, b, g', f', b, a, h, a, none, h, b, none, none, b] (during elaboration)

{α : Type u} {β : Type v} {φ : Ultrafilter α} [LinearOrder β] (x : Filter.Germ ↑ φ β) (y : Filter.Germ ↑ φ β) (a : (a : α) → β) (b : (a : α) → β) (h : ↑ b ≤ ↑ a) (h_1 : (le_total ↑ a ↑ b =: (↑ a ≤ ↑ b : Prop) ∨ (↑ b ≤ ↑ a : Prop)) = (Or.inr h =: (↑ a ≤ ↑ b : Prop) ∨ (↑ b ≤ ↑ a : Prop)))  : (Or.inr h) = (le_total ↑ a ↑ b)
<input>:1:188: expected term

{Ω : Type u_1} [MeasurableSpace Ω] [TopologicalSpace Ω] [OpensMeasurableSpace Ω] {μ : MeasureTheory.FiniteMeasure Ω} {fs : (a : ℕ) → BoundedContinuousFunction Ω NNReal} {c : NNReal} (fs_le_const : ∀ (n : ℕ) (ω : Ω) , ↑ fs n ω ≤ c) {f : BoundedContinuousFunction Ω NNReal} (fs_lim : ∀ (ω : Ω) , Filter.Tendsto fun (n : ℕ) ↦ ↑ fs n ω Filter.atTop nhds ↑ f ω) (n : ℕ)  : ∀ (ω : Ω) , ↑ fs n ω ≤ c
type expected, got
  (Filter.Tendsto fun n => ?m.253 n : Filter ℕ → Filter ?m.244 → Prop) ; identifiers [Ω, u_1, MeasurableSpace, Ω, TopologicalSpace, Ω, OpensMeasurableSpace, Ω, μ, MeasureTheory.FiniteMeasure, Ω, fs, a, BoundedContinuousFunction, Ω, NNReal, c, NNReal, fs_le_const, n, ω, Ω, fs, n, ω, c, f, BoundedContinuousFunction, Ω, NNReal, fs_lim, ω, Ω, Filter.Tendsto, n, fs, n, ω, Filter.atTop, nhds, f, ω, n, ω, Ω, fs, n, ω, c] (during elaboration)

{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (h : IsUnit Matrix.det A) (val : Invertible A) (h_1 : (IsUnit.nonempty_invertible (Iff.mpr (Matrix.isUnit_iff_isUnit_det A =: (IsUnit A : Prop) ↔ (IsUnit Matrix.det A : Prop)) h =: IsUnit A) =: Nonempty Invertible A) = (Nonempty.intro val =: Nonempty Invertible A))  : (Nonempty.intro val) = (IsUnit.nonempty_invertible (Iff.mpr (Matrix.isUnit_iff_isUnit_det A) h))
<input>:1:211: expected term

{α : Type u_5} {β : Type u_4} {γ : Type u_3} {a : Option α} {b : Option β} {α' : Type u_1} {δ : Type u_2} {f : (a : α') → (a : β) → γ} {g : (a : α) → α'} {f' : (a : β) → (a : α) → δ} {g' : (a : δ) → γ} (h_left_anticomm : ∀ (a : α) (b : β) , f g a b = g' f' b a) (h : a = none) (val : β) (h : b = some val)  : some val = b
application type mismatch
  f g
argument
  g
has type
  α → α' : Type (max u_1 u_5)
but is expected to have type
  α' : Type u_1 ; identifiers [α, u_5, β, u_4, γ, u_3, a, Option, α, b, Option, β, α', u_1, δ, u_2, f, a, α', a, β, γ, g, a, α, α', f', a, β, a, α, δ, g', a, δ, γ, h_left_anticomm, a, α, b, β, f, g, a, b, g', f', b, a, h, a, none, val, β, h, b, some, val, some, val, b] (during elaboration)

{α : Type u_1} [PartialOrder α] {a : α}  : {a} = {a}
typeclass instance problem is stuck, it is often due to metavariables
  Singleton α ?m.313 ; identifiers [α, u_1, PartialOrder, α, a, α, a, a, a, a] (during elaboration)

(x : Num) (x_1 : ZNum) (m : Num) (p : PosNum) (a : PosNum) (h : m = Num.pos a) (h : ZNum.pos p = Num.toZNum Num.pos a) (h_1 : Num.toZNum Num.pos a = ZNum.pos p) (a_eq : a = p)  : p = a
application type mismatch
  Num.toZNum Num.pos
argument
  Num.pos
has type
  PosNum → Num : Type
but is expected to have type
  Num : Type ; identifiers [x, Num, x_1, ZNum, m, Num, p, PosNum, a, PosNum, h, m, Num.pos, a, h, ZNum.pos, p, Num.toZNum, Num.pos, a, h_1, Num.toZNum, Num.pos, a, ZNum.pos, p, a_eq, a, p, p, a] (during elaboration)

{α : Type u} {β : Type u_1} [Group α] [Preorder α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x * x_1 fun (x : α) (x_1 : α) ↦ x < x_1] [CovariantClass α α Function.swap fun (x : α) (x_1 : α) ↦ x * x_1 fun (x : α) (x_1 : α) ↦ x < x_1] [Preorder β] {f : (a : β) → α} {s : Set β} (hf : StrictAntiOn f s) (x : β) (hx : x ∈ s) (x_1 : β) (hy : x_1 ∈ s) (hxy : x < x_1)  : f x_1 < f x
function expected at
  x_1
term has type
  α ; identifiers [α, u, β, u_1, Group, α, Preorder, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, CovariantClass, α, α, Function.swap, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, Preorder, β, f, a, β, α, s, Set, β, hf, StrictAntiOn, f, s, x, β, hx, x, s, x_1, β, hy, x_1, s, hxy, x, x_1, f, x_1, f, x] (during elaboration)

{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (h : IsUnit Matrix.det A) (val : Invertible A) (h_1 : (IsUnit.nonempty_invertible (Iff.mpr (Matrix.isUnit_iff_isUnit_det A =: (IsUnit A : Prop) ↔ (IsUnit Matrix.det A : Prop)) h =: IsUnit A) =: Nonempty Invertible A) = (Nonempty.intro val =: Nonempty Invertible A))  : 1 = 1
<input>:1:211: expected term

{α : Type u_5} {β : Type u_4} {γ : Type u_3} {a : Option α} {b : Option β} {α' : Type u_1} {δ : Type u_2} {f : (a : α') → (a : β) → γ} {g : (a : α) → α'} {f' : (a : β) → (a : α) → δ} {g' : (a : δ) → γ} (h_left_anticomm : ∀ (a : α) (b : β) , f g a b = g' f' b a) (h : a = none)  : b = b
application type mismatch
  f g
argument
  g
has type
  α → α' : Type (max u_1 u_5)
but is expected to have type
  α' : Type u_1 ; identifiers [α, u_5, β, u_4, γ, u_3, a, Option, α, b, Option, β, α', u_1, δ, u_2, f, a, α', a, β, γ, g, a, α, α', f', a, β, a, α, δ, g', a, δ, γ, h_left_anticomm, a, α, b, β, f, g, a, b, g', f', b, a, h, a, none, b, b] (during elaboration)

(α : Type u_1) [PartialOrder α] [SupSet α] (isLUB_sSup : ∀ (s : Set α) , IsLUB s sSup s) (s : Set α) (a : α) (ha : a ∈ s)  : ∀ (b : α) (hb : b ∈ lowerBounds s) , b ≤ a
application type mismatch
  IsLUB s sSup
argument
  sSup
has type
  Set ?m.25 → ?m.25 : Type ?u.24
but is expected to have type
  α : Type u_1 ; identifiers [α, u_1, PartialOrder, α, SupSet, α, isLUB_sSup, s, Set, α, IsLUB, s, sSup, s, s, Set, α, a, α, ha, a, s, b, α, hb, b, lowerBounds, s, b, a] (during elaboration)

{α : Type u_2} {β : Type u_1} [Sub α] [Zero α] [Sub β] [Zero β] {f : (a : α) → β} (h : ∀ (x : α) (y : α) , f x - y = f x - f y) (h₀ : f 0 = 0) (x : WithTop α) (x_1 : WithTop α) (x : α) (y : α)  : ∀ (x : α) (y : α) , f x - y = f x - f y
failed to synthesize instance
  HSub β α ?m.159252 ; identifiers [α, u_2, β, u_1, Sub, α, Zero, α, Sub, β, Zero, β, f, a, α, β, h, x, α, y, α, f, x, y, f, x, f, y, h₀, f, x, WithTop, α, x_1, WithTop, α, x, α, y, α, x, α, y, α, f, x, y, f, x, f, y] (during elaboration)

{α : Type u_5} {β : Type u_4} {γ : Type u_3} {a : Option α} {b : Option β} {α' : Type u_1} {δ : Type u_2} {f : (a : α') → (a : β) → γ} {g : (a : α) → α'} {f' : (a : β) → (a : α) → δ} {g' : (a : δ) → γ} (h_left_anticomm : ∀ (a : α) (b : β) , f g a b = g' f' b a) (val : α) (h : a = some val)  : some val = a
application type mismatch
  f g
argument
  g
has type
  α → α' : Type (max u_1 u_5)
but is expected to have type
  α' : Type u_1 ; identifiers [α, u_5, β, u_4, γ, u_3, a, Option, α, b, Option, β, α', u_1, δ, u_2, f, a, α', a, β, γ, g, a, α, α', f', a, β, a, α, δ, g', a, δ, γ, h_left_anticomm, a, α, b, β, f, g, a, b, g', f', b, a, val, α, h, a, some, val, some, val, a] (during elaboration)

{C : Type u_4} [CategoryTheory.Category C] {D : Type u_2} [CategoryTheory.Category D] {S : D} {T : CategoryTheory.Functor C D} {f : CategoryTheory.StructuredArrow S T} {f' : CategoryTheory.StructuredArrow S T} (g : CategoryTheory.Comma.right f ⟶ CategoryTheory.Comma.right f') (w : autoParam (CategoryTheory.CategoryStruct.comp CategoryTheory.Comma.hom f CategoryTheory.Functor.toPrefunctor T . map g = CategoryTheory.Comma.hom f' : Prop) _auto._@.Mathlib.CategoryTheory.StructuredArrow._hyg.577)  : CategoryTheory.Comma.hom f' = CategoryTheory.CategoryStruct.comp CategoryTheory.Comma.hom f CategoryTheory.Functor.toPrefunctor T . map g
function expected at
  CategoryTheory.CategoryStruct.comp ?m.86056 ?m.165836
term has type
  ?m.3979 ⟶ ?m.3981 ; identifiers [C, u_4, CategoryTheory.Category, C, D, u_2, CategoryTheory.Category, D, S, D, T, CategoryTheory.Functor, C, D, f, CategoryTheory.StructuredArrow, S, T, f', CategoryTheory.StructuredArrow, S, T, g, CategoryTheory.Comma.right, f, CategoryTheory.Comma.right, f', w, autoParam, CategoryTheory.CategoryStruct.comp, CategoryTheory.Comma.hom, f, CategoryTheory.Functor.toPrefunctor, T, map, g, CategoryTheory.Comma.hom, f', _auto._, Mathlib.CategoryTheory.StructuredArrow._hyg, CategoryTheory.Comma.hom, f', CategoryTheory.CategoryStruct.comp, CategoryTheory.Comma.hom, f, CategoryTheory.Functor.toPrefunctor, T, map, g] (during elaboration)

 : (∀ (R : Type u_2) {M : Type u_1} [inst : Ring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (a : M) (b : M) , a - b = a - b)
failed to synthesize instance
  HSub M M ?m.750 ; identifiers [R, u_2, M, u_1, inst, Ring, R, inst_1, AddCommMonoid, M, inst_2, Module, R, M, a, M, b, M, a, b, a, b] (during elaboration)

 : ∀ (R : Type u_2) {M : Type u_1} [inst : Ring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (a : M) (b : M) , a - b = a - b
failed to synthesize instance
  HSub M M ?m.750 ; identifiers [R, u_2, M, u_1, inst, Ring, R, inst_1, AddCommMonoid, M, inst_2, Module, R, M, a, M, b, M, a, b, a, b] (during elaboration)

{V : Type u} (s : Set Sym2 V) (t : Set Sym2 V) (v : V) (w : V) em : (a : Prop) → Decidable (a : Prop) := Classical.propDecidable (a : ((Quotient.mk Sym2.Rel.setoid V (v , w) ∈ s : Prop) ∧ (¬ (v = w : Prop) : Prop) : Prop) ∧ ((Quotient.mk Sym2.Rel.setoid V (v , w) ∈ t : Prop) ∧ (¬ (v = w : Prop) : Prop) : Prop)) (left : (Quotient.mk Sym2.Rel.setoid V (v , w) ∈ s : Prop) ∧ (¬ (v = w : Prop) : Prop)) (right : (Quotient.mk Sym2.Rel.setoid V (v , w) ∈ t : Prop) ∧ (¬ (v = w : Prop) : Prop)) (left : Quotient.mk Sym2.Rel.setoid V (v , w) ∈ s) (right_1 : ¬ (v = w : Prop)) (left_1 : Quotient.mk Sym2.Rel.setoid V (v , w) ∈ t) (right : ¬ (v = w : Prop))  : (Quotient.mk Sym2.Rel.setoid V (v , w) ∈ s) ∧ (Quotient.mk Sym2.Rel.setoid V (v , w) ∈ t)
<input>:1:66: expected end of input

{R : Type u} {M : Type v} [CommSemiring R] [AddCommMonoid M] [Module R M] ⦃ v : Module.Dual R M ⦄  : (v ∈ ⊥) = (v ∈ ⊥)
typeclass instance problem is stuck, it is often due to metavariables
  Membership (Module.Dual R M) ?m.1591 ; identifiers [R, u, M, v, CommSemiring, R, AddCommMonoid, M, Module, R, M, v, Module.Dual, R, M, v, v] (during elaboration)

{α : Type u_5} {β : Type u_4} {γ : Type u_3} {a : Option α} {b : Option β} {α' : Type u_1} {δ : Type u_2} {f : (a : α') → (a : β) → γ} {g : (a : α) → α'} {f' : (a : β) → (a : α) → δ} {g' : (a : δ) → γ} (h_left_anticomm : ∀ (a : α) (b : β) , f g a b = g' f' b a) (val : α) (h : a = some val) (h : b = none)  : none = b
application type mismatch
  f g
argument
  g
has type
  α → α' : Type (max u_1 u_5)
but is expected to have type
  α' : Type u_1 ; identifiers [α, u_5, β, u_4, γ, u_3, a, Option, α, b, Option, β, α', u_1, δ, u_2, f, a, α', a, β, γ, g, a, α, α', f', a, β, a, α, δ, g', a, δ, γ, h_left_anticomm, a, α, b, β, f, g, a, b, g', f', b, a, val, α, h, a, some, val, h, b, none, none, b] (during elaboration)

{V : Type u} (s : Set Sym2 V) (t : Set Sym2 V) (v : V) (w : V) em : (a : Prop) → Decidable (a : Prop) := Classical.propDecidable (a : ((Quotient.mk Sym2.Rel.setoid V (v , w) ∈ s : Prop) ∧ (Quotient.mk Sym2.Rel.setoid V (v , w) ∈ t : Prop) : Prop) ∧ (¬ (v = w : Prop) : Prop)) (left : (Quotient.mk Sym2.Rel.setoid V (v , w) ∈ s : Prop) ∧ (Quotient.mk Sym2.Rel.setoid V (v , w) ∈ t : Prop)) (right : ¬ (v = w : Prop)) (left : Quotient.mk Sym2.Rel.setoid V (v , w) ∈ s) (right_1 : Quotient.mk Sym2.Rel.setoid V (v , w) ∈ t)  : (Quotient.mk Sym2.Rel.setoid V (v , w) ∈ s) ∧ (¬ (v = w))
<input>:1:66: expected end of input

{V : Type u} (s : Set Sym2 V) (t : Set Sym2 V) (v : V) (w : V) em : (a : Prop) → Decidable (a : Prop) := Classical.propDecidable (a : ((Quotient.mk Sym2.Rel.setoid V (v , w) ∈ s : Prop) ∧ (Quotient.mk Sym2.Rel.setoid V (v , w) ∈ t : Prop) : Prop) ∧ (¬ (v = w : Prop) : Prop)) (left : (Quotient.mk Sym2.Rel.setoid V (v , w) ∈ s : Prop) ∧ (Quotient.mk Sym2.Rel.setoid V (v , w) ∈ t : Prop)) (right : ¬ (v = w : Prop)) (left : Quotient.mk Sym2.Rel.setoid V (v , w) ∈ s) (right_1 : Quotient.mk Sym2.Rel.setoid V (v , w) ∈ t)  : (Quotient.mk Sym2.Rel.setoid V (v , w) ∈ t) ∧ (¬ (v = w))
<input>:1:66: expected end of input

 : (∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {S₁ : CategoryTheory.ShortComplex C} {S₂ : CategoryTheory.ShortComplex C} (φ : S₁ ⟶ S₂) (c₁ : CategoryTheory.Limits.CokernelCofork CategoryTheory.ShortComplex.f S₁) (c₂ : CategoryTheory.Limits.CokernelCofork CategoryTheory.ShortComplex.f S₂) (f : CategoryTheory.Limits.Cocone.pt c₁ ⟶ CategoryTheory.Limits.Cocone.pt c₂) (comm : CategoryTheory.CategoryStruct.comp CategoryTheory.ShortComplex.Hom.τ₂ φ CategoryTheory.Limits.Cofork.π c₂ = CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.Cofork.π c₁ f) , CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.Cofork.π c₁ f = CategoryTheory.CategoryStruct.comp CategoryTheory.ShortComplex.Hom.τ₂ φ CategoryTheory.Limits.Cofork.π c₂)
function expected at
  CategoryTheory.Limits.CokernelCofork ?m.83128
term has type
  Type (max ?u.147 ?u.148) ; identifiers [C, u_2, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasZeroMorphisms, C, S₁, CategoryTheory.ShortComplex, C, S₂, CategoryTheory.ShortComplex, C, φ, S₁, S₂, c₁, CategoryTheory.Limits.CokernelCofork, CategoryTheory.ShortComplex.f, S₁, c₂, CategoryTheory.Limits.CokernelCofork, CategoryTheory.ShortComplex.f, S₂, f, CategoryTheory.Limits.Cocone.pt, c₁, CategoryTheory.Limits.Cocone.pt, c₂, comm, CategoryTheory.CategoryStruct.comp, CategoryTheory.ShortComplex.Hom.τ₂, φ, CategoryTheory.Limits.Cofork.π, c₂, CategoryTheory.CategoryStruct.comp, CategoryTheory.Limits.Cofork.π, c₁, f, CategoryTheory.CategoryStruct.comp, CategoryTheory.Limits.Cofork.π, c₁, f, CategoryTheory.CategoryStruct.comp, CategoryTheory.ShortComplex.Hom.τ₂, φ, CategoryTheory.Limits.Cofork.π, c₂] (during elaboration)

 : ∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {S₁ : CategoryTheory.ShortComplex C} {S₂ : CategoryTheory.ShortComplex C} (φ : S₁ ⟶ S₂) (c₁ : CategoryTheory.Limits.CokernelCofork CategoryTheory.ShortComplex.f S₁) (c₂ : CategoryTheory.Limits.CokernelCofork CategoryTheory.ShortComplex.f S₂) (f : CategoryTheory.Limits.Cocone.pt c₁ ⟶ CategoryTheory.Limits.Cocone.pt c₂) (comm : CategoryTheory.CategoryStruct.comp CategoryTheory.ShortComplex.Hom.τ₂ φ CategoryTheory.Limits.Cofork.π c₂ = CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.Cofork.π c₁ f) , CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.Cofork.π c₁ f = CategoryTheory.CategoryStruct.comp CategoryTheory.ShortComplex.Hom.τ₂ φ CategoryTheory.Limits.Cofork.π c₂
function expected at
  CategoryTheory.Limits.CokernelCofork ?m.83128
term has type
  Type (max ?u.147 ?u.148) ; identifiers [C, u_2, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasZeroMorphisms, C, S₁, CategoryTheory.ShortComplex, C, S₂, CategoryTheory.ShortComplex, C, φ, S₁, S₂, c₁, CategoryTheory.Limits.CokernelCofork, CategoryTheory.ShortComplex.f, S₁, c₂, CategoryTheory.Limits.CokernelCofork, CategoryTheory.ShortComplex.f, S₂, f, CategoryTheory.Limits.Cocone.pt, c₁, CategoryTheory.Limits.Cocone.pt, c₂, comm, CategoryTheory.CategoryStruct.comp, CategoryTheory.ShortComplex.Hom.τ₂, φ, CategoryTheory.Limits.Cofork.π, c₂, CategoryTheory.CategoryStruct.comp, CategoryTheory.Limits.Cofork.π, c₁, f, CategoryTheory.CategoryStruct.comp, CategoryTheory.Limits.Cofork.π, c₁, f, CategoryTheory.CategoryStruct.comp, CategoryTheory.ShortComplex.Hom.τ₂, φ, CategoryTheory.Limits.Cofork.π, c₂] (during elaboration)

{R : Type u_2} [CommSemiring R] {A : Type u_1} [CommSemiring A] [Algebra R A] (I : Submodule R A) (J : Submodule R A) (r : R) (x : A) (hx : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup {toAddSubsemigroup := (({carrier := (({x : A | ∀ (y : A) (a : y ∈ J) , x * y ∈ I})) , add_mem' := (((fun {a : A} {b : A} (ha : a ∈ {x : A | ∀ (y : A) (a : y ∈ J) , x * y ∈ I}) (hb : b ∈ {x : A | ∀ (y : A) (a : y ∈ J) , x * y ∈ I}) (y : A) (hy : y ∈ J) ↦ Eq.mpr (id ((add_mul a b y =: a + b * y = a * y + b * y) ▸ (Eq.refl (a + b * y ∈ I : Prop) =: (a + b * y ∈ I : Prop) = (a + b * y ∈ I : Prop)) =: (a + b * y ∈ I : Prop) = (a * y + b * y ∈ I : Prop)) =: (a + b * y ∈ I : Prop) = (a * y + b * y ∈ I : Prop)) (Submodule.add_mem I (ha y hy =: a * y ∈ I) (hb y hy =: b * y ∈ I) =: a * y + b * y ∈ I) =: ∀ {a : A} {b : A} (ha : a ∈ {x : A | ∀ (y : A) (a : y ∈ J) , x * y ∈ I}) (hb : b ∈ {x : A | ∀ (y : A) (a : y ∈ J) , x * y ∈ I}) (y : A) (hy : y ∈ J) , a + b * y ∈ I)))})) , zero_mem' := (((fun (y : A) (x : y ∈ J) ↦ Eq.mpr (id ((zero_mul y =: 0 * y = 0) ▸ (Eq.refl (0 * y ∈ I : Prop) =: (0 * y ∈ I : Prop) = (0 * y ∈ I : Prop)) =: (0 * y ∈ I : Prop) = (0 ∈ I : Prop)) =: (0 * y ∈ I : Prop) = (0 ∈ I : Prop)) (Submodule.zero_mem I =: 0 ∈ I) =: ∀ (y : A) (x : y ∈ J) , 0 * y ∈ I)))}) (y : A) (hy : y ∈ J)  : (r • x * y ∈ I) = (r • x * y ∈ I)
<input>:1:481: expected term

{α : Type u_5} {β : Type u_4} {γ : Type u_3} {a : Option α} {b : Option β} {α' : Type u_1} {δ : Type u_2} {f : (a : α') → (a : β) → γ} {g : (a : α) → α'} {f' : (a : β) → (a : α) → δ} {g' : (a : δ) → γ} (h_left_anticomm : ∀ (a : α) (b : β) , f g a b = g' f' b a) (val : α) (h : a = some val) (val_1 : β) (h : b = some val_1)  : some val_1 = b
application type mismatch
  f g
argument
  g
has type
  α → α' : Type (max u_1 u_5)
but is expected to have type
  α' : Type u_1 ; identifiers [α, u_5, β, u_4, γ, u_3, a, Option, α, b, Option, β, α', u_1, δ, u_2, f, a, α', a, β, γ, g, a, α, α', f', a, β, a, α, δ, g', a, δ, γ, h_left_anticomm, a, α, b, β, f, g, a, b, g', f', b, a, val, α, h, a, some, val, val_1, β, h, b, some, val_1, some, val_1, b] (during elaboration)

{L : FirstOrder.Language} {M : Type w} [FirstOrder.Language.Structure L M] (s : Set M) {p : (x : M) → (a : x ∈ LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s) → Prop} (Hs : ∀ (x : M) (h : x ∈ s) , p x (FirstOrder.Language.Substructure.subset_closure h =: x ∈ ↑ LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s)) (Hfun : ∀ {n : ℕ} (f : FirstOrder.Language.Functions L n) , FirstOrder.Language.ClosedUnder f {x : M | ∃ (hx : x ∈ LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s) , p x hx}) {x : M} (hx : x ∈ LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s) (x : M) (hx : x ∈ s)  : p x (FirstOrder.Language.Substructure.subset_closure hx)
<input>:1:270: expected term

{V : Type u_1} {v : V} {w : V} {a : V} {b : V} (h : fun (a : V) (b : V) ↦ Quotient.mk Sym2.Rel.setoid V (v , w) = Quotient.mk Sym2.Rel.setoid V (a , b) a b) (α : outParam Type u_1) (γ : Type u_1) (self : Membership α γ) (a : α) (a_1 : γ) (a' : γ) (e'_5 : a_1 = a') (h : a' = a_1) (a' : γ)  : a_1 = a_1
function expected at
  Quotient.mk ?m.79591 V
term has type
  Quotient ?m.79591 ; identifiers [V, u_1, v, V, w, V, a, V, b, V, h, a, V, b, V, Quotient.mk, Sym2.Rel.setoid, V, v, w, Quotient.mk, Sym2.Rel.setoid, V, a, b, a, b, α, outParam, u_1, γ, u_1, self, Membership, α, γ, a, α, a_1, γ, a', γ, e'_5, a_1, a', h, a', a_1, a', γ, a_1, a_1] (during elaboration)

{R : Type u_2} [CommSemiring R] {A : Type u_1} [CommSemiring A] [Algebra R A] (I : Submodule R A) (J : Submodule R A) (r : R) (x : A) (hx : x ∈ AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup {toAddSubsemigroup := (({carrier := (({x : A | ∀ (y : A) (a : y ∈ J) , x * y ∈ I})) , add_mem' := (((fun {a : A} {b : A} (ha : a ∈ {x : A | ∀ (y : A) (a : y ∈ J) , x * y ∈ I}) (hb : b ∈ {x : A | ∀ (y : A) (a : y ∈ J) , x * y ∈ I}) (y : A) (hy : y ∈ J) ↦ Eq.mpr (id ((add_mul a b y =: a + b * y = a * y + b * y) ▸ (Eq.refl (a + b * y ∈ I : Prop) =: (a + b * y ∈ I : Prop) = (a + b * y ∈ I : Prop)) =: (a + b * y ∈ I : Prop) = (a * y + b * y ∈ I : Prop)) =: (a + b * y ∈ I : Prop) = (a * y + b * y ∈ I : Prop)) (Submodule.add_mem I (ha y hy =: a * y ∈ I) (hb y hy =: b * y ∈ I) =: a * y + b * y ∈ I) =: ∀ {a : A} {b : A} (ha : a ∈ {x : A | ∀ (y : A) (a : y ∈ J) , x * y ∈ I}) (hb : b ∈ {x : A | ∀ (y : A) (a : y ∈ J) , x * y ∈ I}) (y : A) (hy : y ∈ J) , a + b * y ∈ I)))})) , zero_mem' := (((fun (y : A) (x : y ∈ J) ↦ Eq.mpr (id ((zero_mul y =: 0 * y = 0) ▸ (Eq.refl (0 * y ∈ I : Prop) =: (0 * y ∈ I : Prop) = (0 * y ∈ I : Prop)) =: (0 * y ∈ I : Prop) = (0 ∈ I : Prop)) =: (0 * y ∈ I : Prop) = (0 ∈ I : Prop)) (Submodule.zero_mem I =: 0 ∈ I) =: ∀ (y : A) (x : y ∈ J) , 0 * y ∈ I)))}) (y : A) (hy : y ∈ J)  : x * y ∈ I
<input>:1:481: expected term

{L : FirstOrder.Language} {M : Type w} [FirstOrder.Language.Structure L M] (s : Set M) {p : (x : M) → (a : x ∈ LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s) → Prop} (Hs : ∀ (x : M) (h : x ∈ s) , p x (FirstOrder.Language.Substructure.subset_closure h =: x ∈ ↑ LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s)) (Hfun : ∀ {n : ℕ} (f : FirstOrder.Language.Functions L n) , FirstOrder.Language.ClosedUnder f {x : M | ∃ (hx : x ∈ LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s) , p x hx}) {x : M} (hx : x ∈ LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s)  : ∀ (hx : x ∈ LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s) (hc : p x hx) , p x hx
<input>:1:270: expected term

{V : Type u_1} {v : V} {w : V} {a : V} {b : V} (h : fun (a : V) (b : V) ↦ Quotient.mk Sym2.Rel.setoid V (v , w) = Quotient.mk Sym2.Rel.setoid V (a , b) a b) (α : outParam Type u_1) (γ : Type u_1) (self : Membership α γ) (a : α) (a_1 : γ) (a' : γ) (e'_5 : a_1 = a') (h : a' = a_1)  : a_1 = a'
function expected at
  Quotient.mk ?m.79591 V
term has type
  Quotient ?m.79591 ; identifiers [V, u_1, v, V, w, V, a, V, b, V, h, a, V, b, V, Quotient.mk, Sym2.Rel.setoid, V, v, w, Quotient.mk, Sym2.Rel.setoid, V, a, b, a, b, α, outParam, u_1, γ, u_1, self, Membership, α, γ, a, α, a_1, γ, a', γ, e'_5, a_1, a', h, a', a_1, a_1, a'] (during elaboration)

{V : Type u_1} {v : V} {w : V} {a : V} {b : V} (h : fun (a : V) (b : V) ↦ Quotient.mk Sym2.Rel.setoid V (v , w) = Quotient.mk Sym2.Rel.setoid V (a , b) a b) (α : outParam Type u_1) (γ : Type u_1) (self : Membership α γ) (a : α) (a_1 : γ) (a' : γ) (e'_5 : a_1 = a')  : a' = a'
function expected at
  Quotient.mk ?m.79591 V
term has type
  Quotient ?m.79591 ; identifiers [V, u_1, v, V, w, V, a, V, b, V, h, a, V, b, V, Quotient.mk, Sym2.Rel.setoid, V, v, w, Quotient.mk, Sym2.Rel.setoid, V, a, b, a, b, α, outParam, u_1, γ, u_1, self, Membership, α, γ, a, α, a_1, γ, a', γ, e'_5, a_1, a', a', a'] (during elaboration)

(L : FirstOrder.Language) {α : Type u'} {M : Type w} [FirstOrder.Language.Structure FirstOrder.Language.withConstants L α M] (s : Set α) (h : Set.InjOn fun (i : α) ↦ ↑ FirstOrder.Language.con L i s) (φ : FirstOrder.Language.Sentence FirstOrder.Language.withConstants L α) (a : α) (b : α) (a_1 : (a , b) ∈ s ×ˢ s ∩ Set.diagonal α ᶜ) (left : (a , b) ∈ s ×ˢ s) (ab : (a , b) ∈ Set.diagonal α ᶜ) (as : Prod.fst (a , b) ∈ s) (bs : Prod.snd (a , b) ∈ s) (a_2 : FirstOrder.Language.Formula.not FirstOrder.Language.Term.equal FirstOrder.Language.Constants.term FirstOrder.Language.con L a FirstOrder.Language.Constants.term FirstOrder.Language.con L b = φ) (contra : ↑ FirstOrder.Language.con L a = ↑ FirstOrder.Language.con L b)  : Prod.fst (a , b) = Prod.snd (a , b)
application type mismatch
  FirstOrder.Language.Structure FirstOrder.Language.withConstants
argument
  FirstOrder.Language.withConstants
has type
  FirstOrder.Language → Type ?u.17 → FirstOrder.Language : Type (max (max (?u.17 + 1) (?u.18 + 1)) (?u.19 + 1))
but is expected to have type
  FirstOrder.Language : Type (max (?u.16 + 1) (?u.15 + 1)) ; identifiers [L, FirstOrder.Language, α, u', M, w, FirstOrder.Language.Structure, FirstOrder.Language.withConstants, L, α, M, s, Set, α, h, Set.InjOn, i, α, FirstOrder.Language.con, L, i, s, φ, FirstOrder.Language.Sentence, FirstOrder.Language.withConstants, L, α, a, α, b, α, a_1, a, b, s, s, Set.diagonal, α, left, a, b, s, s, ab, a, b, Set.diagonal, α, as, Prod.fst, a, b, s, bs, Prod.snd, a, b, s, a_2, FirstOrder.Language.Formula.not, FirstOrder.Language.Term.equal, FirstOrder.Language.Constants.term, FirstOrder.Language.con, L, a, FirstOrder.Language.Constants.term, FirstOrder.Language.con, L, b, φ, contra, FirstOrder.Language.con, L, a, FirstOrder.Language.con, L, b, Prod.fst, a, b, Prod.snd, a, b] (during elaboration)

 : (∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C] [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] [inst_3 : CategoryTheory.Limits.HasEqualizers C] [inst_4 : CategoryTheory.Limits.HasImages C] {Z : C} (self : CategoryTheory.InjectiveResolution Z) , CategoryTheory.Mono HomologicalComplex.Hom.f CategoryTheory.InjectiveResolution.ι self 0)
function expected at
  CategoryTheory.Mono ?m.83987
term has type
  Prop ; identifiers [C, u, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasZeroObject, C, inst_2, CategoryTheory.Limits.HasZeroMorphisms, C, inst_3, CategoryTheory.Limits.HasEqualizers, C, inst_4, CategoryTheory.Limits.HasImages, C, Z, C, self, CategoryTheory.InjectiveResolution, Z, CategoryTheory.Mono, HomologicalComplex.Hom.f, CategoryTheory.InjectiveResolution.ι, self] (during elaboration)

 : ∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C] [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] [inst_3 : CategoryTheory.Limits.HasEqualizers C] [inst_4 : CategoryTheory.Limits.HasImages C] (Z : C) (self : CategoryTheory.InjectiveResolution Z) , CategoryTheory.Mono HomologicalComplex.Hom.f self . 2 0
function expected at
  CategoryTheory.Mono ?m.83987
term has type
  Prop ; identifiers [C, u, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasZeroObject, C, inst_2, CategoryTheory.Limits.HasZeroMorphisms, C, inst_3, CategoryTheory.Limits.HasEqualizers, C, inst_4, CategoryTheory.Limits.HasImages, C, Z, C, self, CategoryTheory.InjectiveResolution, Z, CategoryTheory.Mono, HomologicalComplex.Hom.f, self] (during elaboration)

{x : PGame}  : ((IsEmpty PGame.LeftMoves x) ∧ (IsEmpty PGame.RightMoves x)) ↔ ((IsEmpty PGame.LeftMoves x) ∧ (IsEmpty PGame.RightMoves x))
application type mismatch
  IsEmpty PGame.LeftMoves
argument
  PGame.LeftMoves
has type
  PGame → Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Sort ?u.6 : Type ?u.6 ; identifiers [x, PGame, IsEmpty, PGame.LeftMoves, x, IsEmpty, PGame.RightMoves, x, IsEmpty, PGame.LeftMoves, x, IsEmpty, PGame.RightMoves, x] (during elaboration)

{M : Type u_1} [Mul M] [Subsingleton Subsemigroup M] (x : M) (y : M) (this : ∀ (a : M) , a ∈ ⊥)  : x ∈ ⊥
application type mismatch
  Subsingleton Subsemigroup
argument
  Subsemigroup
has type
  (M : Type ?u.11) → [inst : Mul M] → Type ?u.11 : Type (?u.11 + 1)
but is expected to have type
  Sort ?u.10 : Type ?u.10 ; identifiers [M, u_1, Mul, M, Subsingleton, Subsemigroup, M, x, M, y, M, this, a, M, a, x] (during elaboration)

{α : Type u_5} {β : Type u_4} {γ : Type u_3} {a : Option α} {b : Option β} {α' : Type u_1} {δ : Type u_2} {f : (a : α') → (a : β) → γ} {g : (a : α) → α'} {f' : (a : β) → (a : α) → δ} {g' : (a : δ) → γ} (h_left_anticomm : ∀ (a : α) (b : β) , f g a b = g' f' b a) (val : α) (h : a = some val) (val_1 : β) (h : b = some val_1)  : ∀ (a : α) (b : β) , f g a b = g' f' b a
application type mismatch
  f g
argument
  g
has type
  α → α' : Type (max u_1 u_5)
but is expected to have type
  α' : Type u_1 ; identifiers [α, u_5, β, u_4, γ, u_3, a, Option, α, b, Option, β, α', u_1, δ, u_2, f, a, α', a, β, γ, g, a, α, α', f', a, β, a, α, δ, g', a, δ, γ, h_left_anticomm, a, α, b, β, f, g, a, b, g', f', b, a, val, α, h, a, some, val, val_1, β, h, b, some, val_1, a, α, b, β, f, g, a, b, g', f', b, a] (during elaboration)

{α : Type u_5} {β : Type u_4} {γ : Type u_3} {a : Option α} {b : Option β} {α' : Type u_1} {δ : Type u_2} {f : (a : α') → (a : β) → γ} {g : (a : α) → α'} {f' : (a : β) → (a : α) → δ} {g' : (a : δ) → γ} (h_left_anticomm : ∀ (a : α) (b : β) , f g a b = g' f' b a) (val : α) (h : a = some val)  : b = b
application type mismatch
  f g
argument
  g
has type
  α → α' : Type (max u_1 u_5)
but is expected to have type
  α' : Type u_1 ; identifiers [α, u_5, β, u_4, γ, u_3, a, Option, α, b, Option, β, α', u_1, δ, u_2, f, a, α', a, β, γ, g, a, α, α', f', a, β, a, α, δ, g', a, δ, γ, h_left_anticomm, a, α, b, β, f, g, a, b, g', f', b, a, val, α, h, a, some, val, b, b] (during elaboration)

{α : Type u_5} {β : Type u_4} {γ : Type u_3} {a : Option α} {b : Option β} {α' : Type u_1} {δ : Type u_2} {f : (a : α') → (a : β) → γ} {g : (a : α) → α'} {f' : (a : β) → (a : α) → δ} {g' : (a : δ) → γ} (h_left_anticomm : ∀ (a : α) (b : β) , f g a b = g' f' b a)  : a = a
application type mismatch
  f g
argument
  g
has type
  α → α' : Type (max u_1 u_5)
but is expected to have type
  α' : Type u_1 ; identifiers [α, u_5, β, u_4, γ, u_3, a, Option, α, b, Option, β, α', u_1, δ, u_2, f, a, α', a, β, γ, g, a, α, α', f', a, β, a, α, δ, g', a, δ, γ, h_left_anticomm, a, α, b, β, f, g, a, b, g', f', b, a, a, a] (during elaboration)

{ι : Type u_3} {R : Type u_1} {M : (a : ι) → Type u_2} {N : Type u_4} [DecidableEq ι] [Semiring R] [(i : ι) → AddCommMonoid M i] [(i : ι) → Module R M i] [AddCommMonoid N] [Module R N] ⦃ φ : Π₀ (i : ι) , M i →ₗ[R] N ⦄ ⦃ ψ : Π₀ (i : ι) , M i →ₗ[R] N ⦄ (h : ∀ (i : ι) , LinearMap.comp φ DFinsupp.lsingle i = LinearMap.comp ψ DFinsupp.lsingle i) (i : ι)  : LinearMap.comp φ DFinsupp.lsingle i = LinearMap.comp ψ DFinsupp.lsingle i
application type mismatch
  AddCommMonoid M
argument
  M
has type
  ι → Type u_2 : Type (max (u_2 + 1) u_3)
but is expected to have type
  Type ?u.35 : Type (?u.35 + 1) ; identifiers [ι, u_3, R, u_1, M, a, ι, u_2, N, u_4, DecidableEq, ι, Semiring, R, i, ι, AddCommMonoid, M, i, i, ι, Module, R, M, i, AddCommMonoid, N, Module, R, N, φ, i, ι, M, i, R, N, ψ, i, ι, M, i, R, N, h, i, ι, LinearMap.comp, φ, DFinsupp.lsingle, i, LinearMap.comp, ψ, DFinsupp.lsingle, i, i, ι, LinearMap.comp, φ, DFinsupp.lsingle, i, LinearMap.comp, ψ, DFinsupp.lsingle, i] (during elaboration)

{A : Type u_1} [AddMonoid A] {f : ℤ →+ A} {g : ℤ →+ A} (h1 : ↑ f 1 = ↑ g 1) (this : AddMonoidHom.comp f ↑ Int.ofNatHom = AddMonoidHom.comp g ↑ Int.ofNatHom) (this' : ∀ (n : ℕ) , ↑ f ↑ n = ↑ g ↑ n) (n : ℤ)  : ∀ (n : ℕ) , ↑ f ↑ n = ↑ g ↑ n
type mismatch
  Int.ofNatHom
has type
  ℕ →+* ℤ : Type
but is expected to have type
  ?m.2246 h1 →+ ℤ : Type ?u.86 ; identifiers [A, u_1, AddMonoid, A, f, A, g, A, h1, f, g, this, AddMonoidHom.comp, f, Int.ofNatHom, AddMonoidHom.comp, g, Int.ofNatHom, this', n, f, n, g, n, n, n, f, n, g, n] (during elaboration)

 : (∀ {α : Type u_1} [inst : LE α] {a : α} , (IsMax ↑ OrderDual.toDual a) ↔ (IsMin a))
function expected at
  IsMax ?m.13
term has type
  Prop ; identifiers [α, u_1, inst, LE, α, a, α, IsMax, OrderDual.toDual, a, IsMin, a] (during elaboration)

 : ∀ {α : Type u_1} [inst : LE α] {a : α} , (IsMax ↑ OrderDual.toDual a) ↔ (IsMax ↑ OrderDual.toDual a)
function expected at
  IsMax ?m.13
term has type
  Prop ; identifiers [α, u_1, inst, LE, α, a, α, IsMax, OrderDual.toDual, a, IsMax, OrderDual.toDual, a] (during elaboration)

{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder β] [SuccOrder β] [IsSuccArchimedean β] [Nonempty β] {s : (a : β) → Set α} (H : ∀ (n : β) , IsConnected s n) (K : ∀ (n : β) , Set.Nonempty s n ∩ s Order.succ n) (i : β) (j : β)  : ∀ (i_1 : β) (x : i_1 ∈ Set.Ico i j) , Set.Nonempty s i_1 ∩ s Order.succ i_1
function expected at
  IsConnected ?m.1641
term has type
  Prop ; identifiers [α, u, β, v, TopologicalSpace, α, LinearOrder, β, SuccOrder, β, IsSuccArchimedean, β, Nonempty, β, s, a, β, Set, α, H, n, β, IsConnected, s, n, K, n, β, Set.Nonempty, s, n, s, Order.succ, n, i, β, j, β, i_1, β, x, i_1, Set.Ico, i, j, Set.Nonempty, s, i_1, s, Order.succ, i_1] (during elaboration)

{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder β] [SuccOrder β] [IsSuccArchimedean β] [Nonempty β] {s : (a : β) → Set α} (H : ∀ (n : β) , IsConnected s n) (K : ∀ (n : β) , Set.Nonempty s n ∩ s Order.succ n) (i : β) (j : β) (i_1 : β) (x : i_1 ∈ Set.Ico j i)  : Set.Nonempty s i_1 ∩ s Order.succ i_1
function expected at
  IsConnected ?m.1641
term has type
  Prop ; identifiers [α, u, β, v, TopologicalSpace, α, LinearOrder, β, SuccOrder, β, IsSuccArchimedean, β, Nonempty, β, s, a, β, Set, α, H, n, β, IsConnected, s, n, K, n, β, Set.Nonempty, s, n, s, Order.succ, n, i, β, j, β, i_1, β, x, i_1, Set.Ico, j, i, Set.Nonempty, s, i_1, s, Order.succ, i_1] (during elaboration)

 : (∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] {s : optParam Set M Set.univ} (self : SmoothBumpCovering ι I M s) , LocallyFinite fun (i : ι) ↦ Function.support ↑ SmoothBumpCovering.toFun s self i)
unknown universe level 'uι' ; identifiers [ι, uι, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, s, optParam, Set, M, Set.univ, self, SmoothBumpCovering, ι, I, M, s, LocallyFinite, i, ι, Function.support, SmoothBumpCovering.toFun, s, self, i] (during elaboration)

 : ∀ (ι : Type uι) (E : Type uE) [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] (H : Type uH) [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) (M : Type uM) [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] (s : optParam Set M Set.univ) (self : SmoothBumpCovering ι I M s) , LocallyFinite fun (i : ι) ↦ Function.support ↑ self . 2 i
unknown universe level 'uι' ; identifiers [ι, uι, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, s, optParam, Set, M, Set.univ, self, SmoothBumpCovering, ι, I, M, s, LocallyFinite, i, ι, Function.support, self, i] (during elaboration)

{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (toFun : (a : α) → β) (spectral' : IsSpectralMap toFun) (toFun_1 : (a : α) → β) (spectral'_1 : IsSpectralMap toFun_1) (a : toFun = toFun_1) (h : toFun_1 = toFun) (spectral'_2 : IsSpectralMap toFun) (a : toFun = toFun) (h : HEq a (Eq.refl toFun =: toFun = toFun))  : {toFun := ((toFun)) , spectral' := ((spectral'))} = {toFun := ((toFun)) , spectral' := ((spectral'))}
<input>:1:317: expected term

(G : Type u_1) {α : Type u_2} [AddGroup G] [AddAction G α] {U : Set α} (x : α) (motive : (x : ∃ (c : G) , c +ᵥ x ∈ U) → Prop) (x_1 : ∃ (c : G) , c +ᵥ x ∈ U) (h_1 : ∀ (g : G) (hg : g +ᵥ x ∈ U) , motive (Exists.intro g hg =: ∃ (c : G) , c +ᵥ x ∈ U))  : ∀ (w : G) (h : w +ᵥ x ∈ U) , motive (Exists.intro w h)
<input>:1:221: expected term

{α : Type u_1} {β : Type u_2} [NonAssocSemiring α] [NonAssocSemiring β] (toMonoidHom : α →* β) (map_zero' : OneHom.toFun ↑ toMonoidHom 0 = 0) (map_add' : ∀ (x : α) (y : α) , OneHom.toFun ↑ toMonoidHom x + y = OneHom.toFun ↑ toMonoidHom x + OneHom.toFun ↑ toMonoidHom y) (toMonoidHom_1 : α →* β) (map_zero'_1 : OneHom.toFun ↑ toMonoidHom_1 0 = 0) (map_add'_1 : ∀ (x : α) (y : α) , OneHom.toFun ↑ toMonoidHom_1 x + y = OneHom.toFun ↑ toMonoidHom_1 x + OneHom.toFun ↑ toMonoidHom_1 y) (a : {toMonoidHom := ((toMonoidHom)) , map_zero' := ((map_zero')) , map_add' := ((map_add'))} = {toMonoidHom := ((toMonoidHom_1)) , map_zero' := ((map_zero'_1)) , map_add' := ((map_add'_1))})  : ∀ (toMonoidHom_eq : toMonoidHom = toMonoidHom_1) , toMonoidHom = toMonoidHom_1
type mismatch
  toMonoidHom_1
has type
  α →* β : Type (max u_1 u_2)
but is expected to have type
  OneHom α α : Type u_1 ; identifiers [α, u_1, β, u_2, NonAssocSemiring, α, NonAssocSemiring, β, toMonoidHom, α, β, map_zero', OneHom.toFun, toMonoidHom, map_add', x, α, y, α, OneHom.toFun, toMonoidHom, x, y, OneHom.toFun, toMonoidHom, x, OneHom.toFun, toMonoidHom, y, toMonoidHom_1, α, β, map_zero'_1, OneHom.toFun, toMonoidHom_1, map_add'_1, x, α, y, α, OneHom.toFun, toMonoidHom_1, x, y, OneHom.toFun, toMonoidHom_1, x, OneHom.toFun, toMonoidHom_1, y, a, toMonoidHom, toMonoidHom, map_zero', map_zero', map_add', map_add', toMonoidHom, toMonoidHom_1, map_zero', map_zero'_1, map_add', map_add'_1, toMonoidHom_eq, toMonoidHom, toMonoidHom_1, toMonoidHom, toMonoidHom_1] (during elaboration)

{α : Type u} [inst : AddCommGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α} {c : α} {α : Type u} [AddCommGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α} {c : α}  : ((a - b ≤ c) ↔ (a ≤ b + c)) = ((a - b ≤ c) ↔ (a ≤ b + c))
function expected at
  x_1
term has type
  α ; identifiers [α, u, inst, AddCommGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, c, α, α, u, AddCommGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, c, α, a, b, c, a, b, c, a, b, c, a, b, c] (during elaboration)

{α : Type u} [inst : AddCommGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α} {c : α} {α : Type u} [AddCommGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α} {c : α}  : ((a ≤ c + b) ↔ (a ≤ b + c)) = ((a ≤ c + b) ↔ (a ≤ b + c))
function expected at
  x_1
term has type
  α ; identifiers [α, u, inst, AddCommGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, c, α, α, u, AddCommGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, c, α, a, c, b, a, b, c, a, c, b, a, b, c] (during elaboration)

{α : Type u} [inst : AddCommGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α} {c : α} {α : Type u} [AddCommGroup α] [LE α] [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1] {a : α} {b : α} {c : α}  : (a ≤ b + c) ↔ (a ≤ b + c)
function expected at
  x_1
term has type
  α ; identifiers [α, u, inst, AddCommGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, c, α, α, u, AddCommGroup, α, LE, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, α, b, α, c, α, a, b, c, a, b, c] (during elaboration)

{α : Type u_1} {β : Type u_2} [NonAssocSemiring α] [NonAssocSemiring β] (toMonoidHom : α →* β) (map_zero' : OneHom.toFun ↑ toMonoidHom 0 = 0) (map_add' : ∀ (x : α) (y : α) , OneHom.toFun ↑ toMonoidHom x + y = OneHom.toFun ↑ toMonoidHom x + OneHom.toFun ↑ toMonoidHom y) (toMonoidHom_1 : α →* β) (map_zero'_1 : OneHom.toFun ↑ toMonoidHom_1 0 = 0) (map_add'_1 : ∀ (x : α) (y : α) , OneHom.toFun ↑ toMonoidHom_1 x + y = OneHom.toFun ↑ toMonoidHom_1 x + OneHom.toFun ↑ toMonoidHom_1 y) (a : toMonoidHom = toMonoidHom_1) (h : toMonoidHom_1 = toMonoidHom) (toMonoidHom_2 : α →* β)  : toMonoidHom = toMonoidHom
type mismatch
  toMonoidHom_1
has type
  α →* β : Type (max u_1 u_2)
but is expected to have type
  OneHom α α : Type u_1 ; identifiers [α, u_1, β, u_2, NonAssocSemiring, α, NonAssocSemiring, β, toMonoidHom, α, β, map_zero', OneHom.toFun, toMonoidHom, map_add', x, α, y, α, OneHom.toFun, toMonoidHom, x, y, OneHom.toFun, toMonoidHom, x, OneHom.toFun, toMonoidHom, y, toMonoidHom_1, α, β, map_zero'_1, OneHom.toFun, toMonoidHom_1, map_add'_1, x, α, y, α, OneHom.toFun, toMonoidHom_1, x, y, OneHom.toFun, toMonoidHom_1, x, OneHom.toFun, toMonoidHom_1, y, a, toMonoidHom, toMonoidHom_1, h, toMonoidHom_1, toMonoidHom, toMonoidHom_2, α, β, toMonoidHom, toMonoidHom] (during elaboration)

{α : Type u_1} [NontriviallyNormedField α] (x : α) (ε : ℝ) (ε0 : ε > 0) (b : α) (h : (0 < ‖ b ‖ : Prop) ∧ (‖ b ‖ < ε : Prop)) (hb0 : 0 < ‖ b ‖) (hbε : ‖ b ‖ < ε)  : (‖ x + b - x ‖ < ε) = (‖ x + b - x ‖ < ε)
<input>:1:96: expected term

{α : Type u_1} {β : Type u_2} [NonAssocSemiring α] [NonAssocSemiring β] (toMonoidHom : α →* β) (map_zero' : OneHom.toFun ↑ toMonoidHom 0 = 0) (map_add' : ∀ (x : α) (y : α) , OneHom.toFun ↑ toMonoidHom x + y = OneHom.toFun ↑ toMonoidHom x + OneHom.toFun ↑ toMonoidHom y) (toMonoidHom_1 : α →* β) (map_zero'_1 : OneHom.toFun ↑ toMonoidHom_1 0 = 0) (map_add'_1 : ∀ (x : α) (y : α) , OneHom.toFun ↑ toMonoidHom_1 x + y = OneHom.toFun ↑ toMonoidHom_1 x + OneHom.toFun ↑ toMonoidHom_1 y) (a : toMonoidHom = toMonoidHom_1) (h : toMonoidHom_1 = toMonoidHom) (map_zero'_2 : OneHom.toFun ↑ toMonoidHom 0 = 0) (map_add'_2 : ∀ (x : α) (y : α) , OneHom.toFun ↑ toMonoidHom x + y = OneHom.toFun ↑ toMonoidHom x + OneHom.toFun ↑ toMonoidHom y) (a : toMonoidHom = toMonoidHom) (h : HEq a (Eq.refl toMonoidHom =: toMonoidHom = toMonoidHom))  : {toMonoidHom := ((toMonoidHom)) , map_zero' := ((map_zero')) , map_add' := ((map_add'))} = {toMonoidHom := ((toMonoidHom)) , map_zero' := ((map_zero')) , map_add' := ((map_add'))}
<input>:1:794: expected term

{α : Type u_1} {β : Type u_2} [NonAssocSemiring α] [NonAssocSemiring β] (toMonoidHom : α →* β) (map_zero' : OneHom.toFun ↑ toMonoidHom 0 = 0) (map_add' : ∀ (x : α) (y : α) , OneHom.toFun ↑ toMonoidHom x + y = OneHom.toFun ↑ toMonoidHom x + OneHom.toFun ↑ toMonoidHom y) (toMonoidHom_1 : α →* β) (map_zero'_1 : OneHom.toFun ↑ toMonoidHom_1 0 = 0) (map_add'_1 : ∀ (x : α) (y : α) , OneHom.toFun ↑ toMonoidHom_1 x + y = OneHom.toFun ↑ toMonoidHom_1 x + OneHom.toFun ↑ toMonoidHom_1 y) (a : toMonoidHom = toMonoidHom_1) (h : toMonoidHom_1 = toMonoidHom)  : toMonoidHom = toMonoidHom_1
type mismatch
  toMonoidHom_1
has type
  α →* β : Type (max u_1 u_2)
but is expected to have type
  OneHom α α : Type u_1 ; identifiers [α, u_1, β, u_2, NonAssocSemiring, α, NonAssocSemiring, β, toMonoidHom, α, β, map_zero', OneHom.toFun, toMonoidHom, map_add', x, α, y, α, OneHom.toFun, toMonoidHom, x, y, OneHom.toFun, toMonoidHom, x, OneHom.toFun, toMonoidHom, y, toMonoidHom_1, α, β, map_zero'_1, OneHom.toFun, toMonoidHom_1, map_add'_1, x, α, y, α, OneHom.toFun, toMonoidHom_1, x, y, OneHom.toFun, toMonoidHom_1, x, OneHom.toFun, toMonoidHom_1, y, a, toMonoidHom, toMonoidHom_1, h, toMonoidHom_1, toMonoidHom, toMonoidHom, toMonoidHom_1] (during elaboration)

{α : Type u_1} {β : Type u_2} [NonAssocSemiring α] [NonAssocSemiring β] (toMonoidHom : α →* β) (map_zero' : OneHom.toFun ↑ toMonoidHom 0 = 0) (map_add' : ∀ (x : α) (y : α) , OneHom.toFun ↑ toMonoidHom x + y = OneHom.toFun ↑ toMonoidHom x + OneHom.toFun ↑ toMonoidHom y) (toMonoidHom_1 : α →* β) (map_zero'_1 : OneHom.toFun ↑ toMonoidHom_1 0 = 0) (map_add'_1 : ∀ (x : α) (y : α) , OneHom.toFun ↑ toMonoidHom_1 x + y = OneHom.toFun ↑ toMonoidHom_1 x + OneHom.toFun ↑ toMonoidHom_1 y) (a : toMonoidHom = toMonoidHom_1)  : toMonoidHom_1 = toMonoidHom_1
type mismatch
  toMonoidHom_1
has type
  α →* β : Type (max u_1 u_2)
but is expected to have type
  OneHom α α : Type u_1 ; identifiers [α, u_1, β, u_2, NonAssocSemiring, α, NonAssocSemiring, β, toMonoidHom, α, β, map_zero', OneHom.toFun, toMonoidHom, map_add', x, α, y, α, OneHom.toFun, toMonoidHom, x, y, OneHom.toFun, toMonoidHom, x, OneHom.toFun, toMonoidHom, y, toMonoidHom_1, α, β, map_zero'_1, OneHom.toFun, toMonoidHom_1, map_add'_1, x, α, y, α, OneHom.toFun, toMonoidHom_1, x, y, OneHom.toFun, toMonoidHom_1, x, OneHom.toFun, toMonoidHom_1, y, a, toMonoidHom, toMonoidHom_1, toMonoidHom_1, toMonoidHom_1] (during elaboration)

{α : Type ua} [UniformSpace α] {d : Set α × α} (s : Set α × α) (hd : d ∈ uniformity α) cl_d : Set α × α := {p : α × α | ∃ (x : α) , ∃ (y : α) , ((Prod.fst p , x) ∈ d : Prop) ∧ (((x , y) ∈ s : Prop) ∧ ((y , Prod.snd p) ∈ d : Prop) : Prop)} (this : ∀ (p : α × α) (a : p ∈ s) , ∃ (t : Set α × α) , (t ⊆ cl_d : Prop) ∧ ((IsOpen t : Prop) ∧ (p ∈ t : Prop) : Prop)) (t : (p : α × α) → (a : p ∈ s) → Set α × α) (ht : ∀ (p : α × α) (a : p ∈ s) , (t p a ⊆ cl_d : Prop) ∧ ((IsOpen t p a : Prop) ∧ (p ∈ t p a : Prop) : Prop)) (p : α × α) (hp : p ∈ s)  : (t p hp ⊆ cl_d) ∧ ((IsOpen t p hp) ∧ (p ∈ t p hp))
<input>:1:92: expected end of input

