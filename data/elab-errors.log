 : (∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering ι I M s} {U : (a : M) → Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : ι) ↦ U (SmoothBumpCovering.c s f i)) ↔
    (SmoothBumpCovering.IsSubordinate f U))
unknown universe level 'uH' ; identifiers [ι, uι, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, ι, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, ι, U, SmoothBumpCovering.c, s, f, i, SmoothBumpCovering.IsSubordinate, f, U] (during elaboration) for (∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering ι I M s} {U : (a : M) → Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : ι) ↦ U (SmoothBumpCovering.c s f i)) ↔
    (SmoothBumpCovering.IsSubordinate f U))

 : (∀ {ι : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]
  {c : ComplexShape ι} {A : HomologicalComplex V c} {B : HomologicalComplex V c} [inst_2 : SizeOf ι] [inst_3 : SizeOf V]
  (f : (i : ι) → HomologicalComplex.X A i ⟶ HomologicalComplex.X B i)
  (comm' :
    autoParam
      (∀ (i : ι) (j : ι) (a : ComplexShape.Rel c i j),
        CategoryTheory.CategoryStruct.comp (f i) (HomologicalComplex.d B i j) =
          CategoryTheory.CategoryStruct.comp (HomologicalComplex.d A i j) (f j))
      _auto✝),
  sizeOf (HomologicalComplex.Hom.mk f) = 1)
<input>:9:11: expected token

 : (∀ {α : Type u} (m : MeasureTheory.OuterMeasure α) {s : Set α},
  (MeasurableSet s) ↔ (∀ (t : Set α), ↑m t = ↑m (t ∩ s) + ↑m (t \ s)))
failed to synthesize instance
  MeasurableSpace α ; identifiers [α, u, m, MeasureTheory.OuterMeasure, α, s, Set, α, MeasurableSet, s, t, Set, α, m, t, m, t, s, m, t, s] (during elaboration) for (∀ {α : Type u} (m : MeasureTheory.OuterMeasure α) {s : Set α},
  (MeasurableSet s) ↔ (∀ (t : Set α), ↑m t = ↑m (t ∩ s) + ↑m (t \ s)))

 : (∀ {L : FirstOrder.Language} (M : Type w) [inst : FirstOrder.Language.Structure L M]
  {φ : FirstOrder.Language.Sentence L}, (M ⊨ FirstOrder.Language.Formula.not φ) ↔ (¬(M ⊨ φ)))
ambiguous, possible interpretations 
  M ⊨ ?m.497 : Prop
  
  M ⊨ FirstOrder.Language.Formula.not φ : Prop ; identifiers [L, FirstOrder.Language, M, w, inst, FirstOrder.Language.Structure, L, M, φ, FirstOrder.Language.Sentence, L, M, FirstOrder.Language.Formula.not, φ, M, FirstOrder.Language.Formula.not, φ, M, φ, M, φ] (during elaboration) for (∀ {L : FirstOrder.Language} (M : Type w) [inst : FirstOrder.Language.Structure L M]
  {φ : FirstOrder.Language.Sentence L}, (M ⊨ FirstOrder.Language.Formula.not φ) ↔ (¬(M ⊨ φ)))

 : (∀ (A : Type u_1) [inst : CommRing A] (K : Type u_2) [inst_1 : Field K] [inst_2 : Algebra A K]
  (a : ValuationRing.ValueGroup A K) (b : ValuationRing.ValueGroup A K), (a < b) ↔ (a < b))
failed to synthesize instance
  LT (ValuationRing.ValueGroup A K) ; identifiers [A, u_1, inst, CommRing, A, K, u_2, inst_1, Field, K, inst_2, Algebra, A, K, a, ValuationRing.ValueGroup, A, K, b, ValuationRing.ValueGroup, A, K, a, b, a, b] (during elaboration) for (∀ (A : Type u_1) [inst : CommRing A] (K : Type u_2) [inst_1 : Field K] [inst_2 : Algebra A K]
  (a : ValuationRing.ValueGroup A K) (b : ValuationRing.ValueGroup A K), (a < b) ↔ (a < b))

 : (∀ {P : AlgebraicGeometry.AffineTargetMorphismProperty}
  (self : AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P) {X : AlgebraicGeometry.Scheme}
  {Y : AlgebraicGeometry.Scheme} [inst : AlgebraicGeometry.IsAffine Y] (f : X ⟶ Y)
  (r :
    ↑((CategoryTheory.Functor.toPrefunctor
            (AlgebraicGeometry.PresheafedSpace.presheaf
              (AlgebraicGeometry.SheafedSpace.toPresheafedSpace
                (AlgebraicGeometry.LocallyRingedSpace.toSheafedSpace
                  (AlgebraicGeometry.Scheme.toLocallyRingedSpace Y))))).obj
        (Opposite.op ⊤)))
  (a : P f), P (f ∣_ AlgebraicGeometry.Scheme.basicOpen Y r))
synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized
  CategoryTheory.Category.opposite
inferred
  CategoryTheory.Category.opposite ; identifiers [P, AlgebraicGeometry.AffineTargetMorphismProperty, self, AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal, P, X, AlgebraicGeometry.Scheme, Y, AlgebraicGeometry.Scheme, inst, AlgebraicGeometry.IsAffine, Y, f, X, Y, r, CategoryTheory.Functor.toPrefunctor, AlgebraicGeometry.PresheafedSpace.presheaf, AlgebraicGeometry.SheafedSpace.toPresheafedSpace, AlgebraicGeometry.LocallyRingedSpace.toSheafedSpace, AlgebraicGeometry.Scheme.toLocallyRingedSpace, Y, obj, Opposite.op, a, P, f, P, f, AlgebraicGeometry.Scheme.basicOpen, Y, r] (during elaboration) for (∀ {P : AlgebraicGeometry.AffineTargetMorphismProperty}
  (self : AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P) {X : AlgebraicGeometry.Scheme}
  {Y : AlgebraicGeometry.Scheme} [inst : AlgebraicGeometry.IsAffine Y] (f : X ⟶ Y)
  (r :
    ↑((CategoryTheory.Functor.toPrefunctor
            (AlgebraicGeometry.PresheafedSpace.presheaf
              (AlgebraicGeometry.SheafedSpace.toPresheafedSpace
                (AlgebraicGeometry.LocallyRingedSpace.toSheafedSpace
                  (AlgebraicGeometry.Scheme.toLocallyRingedSpace Y))))).obj
        (Opposite.op ⊤)))
  (a : P f), P (f ∣_ AlgebraicGeometry.Scheme.basicOpen Y r))

 : (∀ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ⟶ Y}
  {F : CategoryTheory.Limits.MonoFactorisation f} [inst_1 : SizeOf C]
  (lift :
    (F' : CategoryTheory.Limits.MonoFactorisation f) →
      CategoryTheory.Limits.MonoFactorisation.I F ⟶ CategoryTheory.Limits.MonoFactorisation.I F')
  (lift_fac :
    autoParam
      (∀ (F' : CategoryTheory.Limits.MonoFactorisation f),
        CategoryTheory.CategoryStruct.comp (lift F') (CategoryTheory.Limits.MonoFactorisation.m F') =
          CategoryTheory.Limits.MonoFactorisation.m F)
      _auto✝),
  sizeOf (CategoryTheory.Limits.IsImage.mk lift) = 1)
<input>:11:11: expected token

 : (∀ {α : Type u} [inst : SizeOf α], sizeOf RegularExpression.zero = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (RegularExpression ?m.6826) ; identifiers [α, u, inst, SizeOf, α, sizeOf, RegularExpression.zero] (during elaboration) for (∀ {α : Type u} [inst : SizeOf α], sizeOf RegularExpression.zero = 1)

 : (∀ {α : Type u_1} {β : Type u_2} [inst : NonAssocSemiring α] [inst_1 : Preorder α] [inst_2 : NonAssocSemiring β]
  [inst_3 : Preorder β] (self : α →+*o β), Monotone (OneHom.toFun ↑↑(OrderRingHom.toRingHom self)))
type mismatch
  self.toRingHom
has type
  α →+* β : Type (max u_1 u_2)
but is expected to have type
  OneHom (?m.1739 self) (?m.1740 self) : Type (max ?u.194 ?u.193) ; identifiers [α, u_1, β, u_2, inst, NonAssocSemiring, α, inst_1, Preorder, α, inst_2, NonAssocSemiring, β, inst_3, Preorder, β, self, α, β, Monotone, OneHom.toFun, OrderRingHom.toRingHom, self] (during elaboration) for (∀ {α : Type u_1} {β : Type u_2} [inst : NonAssocSemiring α] [inst_1 : Preorder α] [inst_2 : NonAssocSemiring β]
  [inst_3 : Preorder β] (self : α →+*o β), Monotone (OneHom.toFun ↑↑(OrderRingHom.toRingHom self)))

 : (∀ {G : Type u_1} [inst : Group G] (n : ℕ) (q : G),
  (q ∈ lowerCentralSeries G (n + 1)) ↔
    (q ∈
      Subgroup.closure
        {x : G | ∃ (p : G), (p ∈ lowerCentralSeries G n) ∧ (∃ (q : G), (q ∈ ⊤) ∧ (p * q * p⁻¹ * q⁻¹ = x))}))
typeclass instance problem is stuck, it is often due to metavariables
  Membership G (?m.2902 n q✝ x p q) ; identifiers [G, u_1, inst, Group, G, n, q, G, q, lowerCentralSeries, G, n, q, Subgroup.closure, x, G, p, G, p, lowerCentralSeries, G, n, q, G, q, p, q, p, q, x] (during elaboration) for (∀ {G : Type u_1} [inst : Group G] (n : ℕ) (q : G),
  (q ∈ lowerCentralSeries G (n + 1)) ↔
    (q ∈
      Subgroup.closure
        {x : G | ∃ (p : G), (p ∈ lowerCentralSeries G n) ∧ (∃ (q : G), (q ∈ ⊤) ∧ (p * q * p⁻¹ * q⁻¹ = x))}))

 : (∀ {C : Type u} [inst : SizeOf C], sizeOf CategoryTheory.FreeMonoidalCategory.Unit = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (CategoryTheory.FreeMonoidalCategory ?m.6826) ; identifiers [C, u, inst, SizeOf, C, sizeOf, CategoryTheory.FreeMonoidalCategory.Unit] (during elaboration) for (∀ {C : Type u} [inst : SizeOf C], sizeOf CategoryTheory.FreeMonoidalCategory.Unit = 1)

 : (∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]
  [inst_2 : CategoryTheory.Limits.HasBinaryCoproducts C] (P : C) (Q : C),
  β_ P Q = CategoryTheory.Limits.coprod.braiding P Q)
type mismatch
  CategoryTheory.Limits.coprod.braiding P Q
has type
  P ⨿ Q ≅ Q ⨿ P : Type ?u.6
but is expected to have type
  CategoryTheory.MonoidalCategory.tensorObj P Q ≅ CategoryTheory.MonoidalCategory.tensorObj Q P : Type ?u.6 ; identifiers [C, u, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasInitial, C, inst_2, CategoryTheory.Limits.HasBinaryCoproducts, C, P, C, Q, C, P, Q, CategoryTheory.Limits.coprod.braiding, P, Q] (during elaboration) for (∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]
  [inst_2 : CategoryTheory.Limits.HasBinaryCoproducts C] (P : C) (Q : C),
  β_ P Q = CategoryTheory.Limits.coprod.braiding P Q)

 : (∀ {α : Type u_1} [inst : Mul α] {s : Set α} {t : Set α} {a : α},
  (a ∈ s * t) ↔ (∃ (x : α), ∃ (y : α), (x ∈ s) ∧ ((y ∈ t) ∧ (x * y = a))))
failed to synthesize instance
  HMul (Set α) (Set α) ?m.1993 ; identifiers [α, u_1, inst, Mul, α, s, Set, α, t, Set, α, a, α, a, s, t, x, α, y, α, x, s, y, t, x, y, a] (during elaboration) for (∀ {α : Type u_1} [inst : Mul α] {s : Set α} {t : Set α} {a : α},
  (a ∈ s * t) ↔ (∃ (x : α), ∃ (y : α), (x ∈ s) ∧ ((y ∈ t) ∧ (x * y = a))))

 : (∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (r : R) (x : M)
  (y : M), r • (x + y) = r • x + r • y)
failed to synthesize instance
  HSMul R M ?m.54 ; identifiers [R, u_1, M, u_2, inst, Semiring, R, inst_1, AddCommGroup, M, self, Module.Core, R, M, r, R, x, M, y, M, r, x, y, r, x, r, y] (during elaboration) for (∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (r : R) (x : M)
  (y : M), r • (x + y) = r • x + r • y)

 : (∀ {G : Type u_1} {α : Type u_2} [inst : One G] [inst_1 : SMul G α] [inst_2 : MeasurableSpace α] {s : Set α}
  {μ : autoParam (MeasureTheory.Measure α) _auto✝} (self : MeasureTheory.IsFundamentalDomain G s),
  Pairwise (MeasureTheory.AEDisjoint μ on fun (g : G) ↦ g • s))
<input>:2:48: expected token

 : (∀ {R : Type u} [inst : SizeOf R], sizeOf Rack.PreEnvelGroup.unit = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (Rack.PreEnvelGroup ?m.6826) ; identifiers [R, u, inst, SizeOf, R, sizeOf, Rack.PreEnvelGroup.unit] (during elaboration) for (∀ {R : Type u} [inst : SizeOf R], sizeOf Rack.PreEnvelGroup.unit = 1)

 : (∀ {R : Type u_1} [inst : Semiring R] (h : IsField R) (a : R) (b : R), a / b = a / b)
failed to synthesize instance
  HDiv R R ?m.293 ; identifiers [R, u_1, inst, Semiring, R, h, IsField, R, a, R, b, R, a, b, a, b] (during elaboration) for (∀ {R : Type u_1} [inst : Semiring R] (h : IsField R) (a : R) (b : R), a / b = a / b)

 : (∀ {X : TopCat} (x : ↑X) (a : TopologicalSpace.OpenNhds x) (b : TopologicalSpace.OpenNhds x), (a < b) ↔ (a < b))
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, a, TopologicalSpace.OpenNhds, x, b, TopologicalSpace.OpenNhds, x, a, b, a, b] (during elaboration) for (∀ {X : TopCat} (x : ↑X) (a : TopologicalSpace.OpenNhds x) (b : TopologicalSpace.OpenNhds x), (a < b) ↔ (a < b))

 : (∀ {J : Type u_2} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.IsFiltered J]
  (F : CategoryTheory.Functor J GroupCat) (a : ↑(GroupCat.FilteredColimits.G F)) (b : ↑(GroupCat.FilteredColimits.G F)),
  a / b = a / b)
type mismatch
  GroupCat.FilteredColimits.G F
has type
  MonCat : Type ((max ?u.50 u_2) + 1)
but is expected to have type
  Sort ?u.49 : Type ?u.49 ; identifiers [J, u_2, inst, CategoryTheory.SmallCategory, J, inst_1, CategoryTheory.IsFiltered, J, F, CategoryTheory.Functor, J, GroupCat, a, GroupCat.FilteredColimits.G, F, b, GroupCat.FilteredColimits.G, F, a, b, a, b] (during elaboration) for (∀ {J : Type u_2} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.IsFiltered J]
  (F : CategoryTheory.Functor J GroupCat) (a : ↑(GroupCat.FilteredColimits.G F)) (b : ↑(GroupCat.FilteredColimits.G F)),
  a / b = a / b)

 : (∀ {α : Type u_1} {m : MeasurableSpace α} {f : (a : α) → α} {μ : autoParam (MeasureTheory.Measure α) _auto✝}
  (self : Ergodic f), MeasureTheory.MeasurePreserving f)
<input>:1:109: expected token

 : (∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {H : Type uH}
  [inst_2 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_3 : TopologicalSpace M]
  [inst_4 : ChartedSpace H M] {s : optParam (Set M) Set.univ} (self : SmoothPartitionOfUnity ι I M s) (x : M),
  ∑ᶠ (i : ι), ↑(SmoothPartitionOfUnity.toFun s self i) x ≤ 1)
unknown universe level 'uH' ; identifiers [ι, uι, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, H, uH, inst_2, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_3, TopologicalSpace, M, inst_4, ChartedSpace, H, M, s, optParam, Set, M, Set.univ, self, SmoothPartitionOfUnity, ι, I, M, s, x, M, i, ι, SmoothPartitionOfUnity.toFun, s, self, i, x] (during elaboration) for (∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {H : Type uH}
  [inst_2 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_3 : TopologicalSpace M]
  [inst_4 : ChartedSpace H M] {s : optParam (Set M) Set.univ} (self : SmoothPartitionOfUnity ι I M s) (x : M),
  ∑ᶠ (i : ι), ↑(SmoothPartitionOfUnity.toFun s self i) x ≤ 1)

 : (∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace 𝕜 F] {f : (a : 𝕜) → F} {f' : F} {x : 𝕜},
  (HasStrictDerivAt f f' x) ↔ (HasStrictFDerivAt f (ContinuousLinearMap.smulRight 1 f') x))
typeclass instance problem is stuck, it is often due to metavariables
  NormedSpace ?m.8251 F ; identifiers [𝕜, u, inst, NontriviallyNormedField, 𝕜, F, v, inst_1, NormedAddCommGroup, F, inst_2, NormedSpace, 𝕜, F, f, a, 𝕜, F, f', F, x, 𝕜, HasStrictDerivAt, f, f', x, HasStrictFDerivAt, f, ContinuousLinearMap.smulRight, f', x] (during elaboration) for (∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace 𝕜 F] {f : (a : 𝕜) → F} {f' : F} {x : 𝕜},
  (HasStrictDerivAt f f' x) ↔ (HasStrictFDerivAt f (ContinuousLinearMap.smulRight 1 f') x))

 : (∀ {R : Type u} [inst : CommRing R] {W : WeierstrassCurve R} [inst_1 : SizeOf R],
  sizeOf WeierstrassCurve.Point.zero = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (WeierstrassCurve.Point ?m.7697) ; identifiers [R, u, inst, CommRing, R, W, WeierstrassCurve, R, inst_1, SizeOf, R, sizeOf, WeierstrassCurve.Point.zero] (during elaboration) for (∀ {R : Type u} [inst : CommRing R] {W : WeierstrassCurve R} [inst_1 : SizeOf R],
  sizeOf WeierstrassCurve.Point.zero = 1)

 : (∀ {α : Type u_1} [inst : Div α] {s : Set α} {t : Set α} {a : α},
  (a ∈ s / t) ↔ (∃ (x : α), ∃ (y : α), (x ∈ s) ∧ ((y ∈ t) ∧ (x / y = a))))
failed to synthesize instance
  HDiv (Set α) (Set α) ?m.284 ; identifiers [α, u_1, inst, Div, α, s, Set, α, t, Set, α, a, α, a, s, t, x, α, y, α, x, s, y, t, x, y, a] (during elaboration) for (∀ {α : Type u_1} [inst : Div α] {s : Set α} {t : Set α} {a : α},
  (a ∈ s / t) ↔ (∃ (x : α), ∃ (y : α), (x ∈ s) ∧ ((y ∈ t) ∧ (x / y = a))))

 : (∀ {B : Type u₁} [inst : CategoryTheory.Bicategory B] {C : Type u₂} [inst_1 : CategoryTheory.Bicategory C]
  {F : CategoryTheory.OplaxFunctor B C} [inst_2 : SizeOf B] [inst_3 : SizeOf C]
  (mapIdIso :
    (a : B) →
      (↑(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map (CategoryTheory.CategoryStruct.id a) ≅
        CategoryTheory.CategoryStruct.id ((↑(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).obj a))
  (mapCompIso :
    {a : B} →
      {b : B} →
        {c : B} →
          (f : a ⟶ b) →
            (g : b ⟶ c) →
              (↑(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map (CategoryTheory.CategoryStruct.comp f g) ≅
                CategoryTheory.CategoryStruct.comp ((↑(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map f)
                  ((↑(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map g))
  (mapIdIso_hom : autoParam (∀ {a : B}, (mapIdIso a).hom = CategoryTheory.OplaxFunctor.mapId F a) _auto✝)
  (mapCompIso_hom :
    autoParam
      (∀ {a : B} {b : B} {c : B} (f : a ⟶ b) (g : b ⟶ c),
        (mapCompIso f g).hom = CategoryTheory.OplaxFunctor.mapComp F f g)
      _auto✝¹),
  sizeOf (CategoryTheory.OplaxFunctor.PseudoCore.mk mapIdIso mapCompIso) = 1)
<input>:16:103: expected token

 : (∀ {α : Type u_2} {β : Type u_1} [inst : VAdd α β] {t : Set β} {a : α} {x : β},
  (x ∈ a +ᵥ t) ↔ (∃ (y : β), (y ∈ t) ∧ (a +ᵥ y = x)))
failed to synthesize instance
  HVAdd α (Set β) ?m.29 ; identifiers [α, u_2, β, u_1, inst, VAdd, α, β, t, Set, β, a, α, x, β, x, a, t, y, β, y, t, a, y, x] (during elaboration) for (∀ {α : Type u_2} {β : Type u_1} [inst : VAdd α β] {t : Set β} {a : α} {x : β},
  (x ∈ a +ᵥ t) ↔ (∃ (y : β), (y ∈ t) ∧ (a +ᵥ y = x)))

 : (∀ (M : Type u_1) [inst : CancelMonoidWithZero M] [inst_1 : DecidableEq M] [inst_2 : Fintype M] (a : M) (b : M),
  a / b = a / b)
failed to synthesize instance
  HDiv M M ?m.289 ; identifiers [M, u_1, inst, CancelMonoidWithZero, M, inst_1, DecidableEq, M, inst_2, Fintype, M, a, M, b, M, a, b, a, b] (during elaboration) for (∀ (M : Type u_1) [inst : CancelMonoidWithZero M] [inst_1 : DecidableEq M] [inst_2 : Fintype M] (a : M) (b : M),
  a / b = a / b)

 : (∀ {α : Type u} [inst : Group α] (self : GroupTopology α), TopologicalGroup α)
failed to synthesize instance
  TopologicalSpace α ; identifiers [α, u, inst, Group, α, self, GroupTopology, α, TopologicalGroup, α] (during elaboration) for (∀ {α : Type u} [inst : Group α] (self : GroupTopology α), TopologicalGroup α)

 : (∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : AddZeroClass α]
  [inst_3 : AddZeroClass β] (self : α →+o β), Monotone (ZeroHom.toFun ↑(OrderAddMonoidHom.toAddMonoidHom self)))
typeclass instance problem is stuck, it is often due to metavariables
  Preorder (?m.2800 self) ; identifiers [α, u_1, β, u_2, inst, Preorder, α, inst_1, Preorder, β, inst_2, AddZeroClass, α, inst_3, AddZeroClass, β, self, α, β, Monotone, ZeroHom.toFun, OrderAddMonoidHom.toAddMonoidHom, self] (during elaboration) for (∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : AddZeroClass α]
  [inst_3 : AddZeroClass β] (self : α →+o β), Monotone (ZeroHom.toFun ↑(OrderAddMonoidHom.toAddMonoidHom self)))

 : (∀ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}
  {x : M} {y : M}, (x ≡ y [SMOD U]) ↔ (Submodule.Quotient.mk x = Submodule.Quotient.mk y))
typeclass instance problem is stuck, it is often due to metavariables
  Module ?m.4151 M ; identifiers [R, u_1, inst, Ring, R, M, u_2, inst_1, AddCommGroup, M, inst_2, Module, R, M, U, Submodule, R, M, x, M, y, M, x, y, U, Submodule.Quotient.mk, x, Submodule.Quotient.mk, y] (during elaboration) for (∀ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}
  {x : M} {y : M}, (x ≡ y [SMOD U]) ↔ (Submodule.Quotient.mk x = Submodule.Quotient.mk y))

 : (∀ {G : Type u_1} [inst : Monoid G] (a : G) (b : G), a / b = a / b)
failed to synthesize instance
  HDiv G G ?m.277 ; identifiers [G, u_1, inst, Monoid, G, a, G, b, G, a, b, a, b] (during elaboration) for (∀ {G : Type u_1} [inst : Monoid G] (a : G) (b : G), a / b = a / b)

 : (∀ {J : Type u₁} [inst : CategoryTheory.Category J] {C : Type u₃} [inst_1 : CategoryTheory.Category C]
  {F : CategoryTheory.Functor J C} {t : CategoryTheory.Limits.Cone F} (self : CategoryTheory.Limits.IsLimit t)
  (s : CategoryTheory.Limits.Cone F) (m : CategoryTheory.Limits.Cone.pt s ⟶ CategoryTheory.Limits.Cone.pt t)
  (x :
    ∀ (j : J),
      CategoryTheory.CategoryStruct.comp m (CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.π t) j) =
        CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.π s) j),
  m = CategoryTheory.Limits.IsLimit.lift self s)
unknown universe level 'u₃' ; identifiers [J, u₁, inst, CategoryTheory.Category, J, C, u₃, inst_1, CategoryTheory.Category, C, F, CategoryTheory.Functor, J, C, t, CategoryTheory.Limits.Cone, F, self, CategoryTheory.Limits.IsLimit, t, s, CategoryTheory.Limits.Cone, F, m, CategoryTheory.Limits.Cone.pt, s, CategoryTheory.Limits.Cone.pt, t, x, j, J, CategoryTheory.CategoryStruct.comp, m, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cone.π, t, j, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cone.π, s, j, m, CategoryTheory.Limits.IsLimit.lift, self, s] (during elaboration) for (∀ {J : Type u₁} [inst : CategoryTheory.Category J] {C : Type u₃} [inst_1 : CategoryTheory.Category C]
  {F : CategoryTheory.Functor J C} {t : CategoryTheory.Limits.Cone F} (self : CategoryTheory.Limits.IsLimit t)
  (s : CategoryTheory.Limits.Cone F) (m : CategoryTheory.Limits.Cone.pt s ⟶ CategoryTheory.Limits.Cone.pt t)
  (x :
    ∀ (j : J),
      CategoryTheory.CategoryStruct.comp m (CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.π t) j) =
        CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.π s) j),
  m = CategoryTheory.Limits.IsLimit.lift self s)

 : (∀ {X : TopCat} {x : ↑X} {y : ↑X} (e : Inseparable x y), nhds y ≤ nhds x)
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, y, X, e, Inseparable, x, y, nhds, y, nhds, x] (during elaboration) for (∀ {X : TopCat} {x : ↑X} {y : ↑X} (e : Inseparable x y), nhds y ≤ nhds x)

 : (∀ {α : Type u_1} [inst : Sub α] {f : Filter α} {g : Filter α} {s : Set α},
  (s ∈ f - g) ↔ (∃ (t₁ : Set α), ∃ (t₂ : Set α), (t₁ ∈ f) ∧ ((t₂ ∈ g) ∧ (t₁ - t₂ ⊆ s))))
failed to synthesize instance
  HSub (Filter α) (Filter α) ?m.812 ; identifiers [α, u_1, inst, Sub, α, f, Filter, α, g, Filter, α, s, Set, α, s, f, g, t₁, Set, α, t₂, Set, α, t₁, f, t₂, g, t₁, t₂, s] (during elaboration) for (∀ {α : Type u_1} [inst : Sub α] {f : Filter α} {g : Filter α} {s : Set α},
  (s ∈ f - g) ↔ (∃ (t₁ : Set α), ∃ (t₂ : Set α), (t₁ ∈ f) ∧ ((t₂ ∈ g) ∧ (t₁ - t₂ ⊆ s))))

 : (∀ {G : Type u_1} {α : Type u_2} [inst : One G] [inst_1 : SMul G α] [inst_2 : MeasurableSpace α] {s : Set α}
  {μ : autoParam (MeasureTheory.Measure α) _auto✝} (self : MeasureTheory.IsFundamentalDomain G s),
  MeasureTheory.NullMeasurableSet s)
<input>:2:48: expected token

 : (∀ {ι : Type u} {α : (a : ι) → Type v} [inst : (i : ι) → Preorder (α i)] (i : ι), Monotone (Function.eval i))
typeclass instance problem is stuck, it is often due to metavariables
  Preorder (?m.497 i i) ; identifiers [ι, u, α, a, ι, v, inst, i, ι, Preorder, α, i, i, ι, Monotone, Function.eval, i] (during elaboration) for (∀ {ι : Type u} {α : (a : ι) → Type v} [inst : (i : ι) → Preorder (α i)] (i : ι), Monotone (Function.eval i))

 : (∀ {α : Type u_1} [inst : GeneralizedBooleanAlgebra α] (a : α) (b : α), a - b = a - b)
failed to synthesize instance
  HSub α α ?m.435 ; identifiers [α, u_1, inst, GeneralizedBooleanAlgebra, α, a, α, b, α, a, b, a, b] (during elaboration) for (∀ {α : Type u_1} [inst : GeneralizedBooleanAlgebra α] (a : α) (b : α), a - b = a - b)

 : (∀ {R : Type u} [inst : Ring R] {Q : TypeMax} [inst_1 : AddCommGroup Q] [inst_2 : Module R Q] {M : Type (max u v)}
  {N : Type (max u v)} [inst_3 : AddCommGroup M] [inst_4 : AddCommGroup N] [inst_5 : Module R M] [inst_6 : Module R N]
  {i : M →ₗ[R] N} {f : M →ₗ[R] Q} (self : Module.Baer.ExtensionOf i f),
  LinearMap.range i ≤ LinearPMap.domain (Module.Baer.ExtensionOf.toLinearPMap self))
stuck at solving universe constraint
  max u ?u.9 =?= max u v
while trying to unify
  (M →ₗ[R] N) R R Ring.toSemiring Ring.toSemiring (RingHom.id R) M N ((M →ₗ[R] N) M inst_3) ((M →ₗ[R] N) N inst_4)
    inst_5 inst_6
with
  M →ₗ[R] N ; identifiers [R, u, inst, Ring, R, Q, TypeMax, inst_1, AddCommGroup, Q, inst_2, Module, R, Q, M, u, v, N, u, v, inst_3, AddCommGroup, M, inst_4, AddCommGroup, N, inst_5, Module, R, M, inst_6, Module, R, N, i, M, R, N, f, M, R, Q, self, Module.Baer.ExtensionOf, i, f, LinearMap.range, i, LinearPMap.domain, Module.Baer.ExtensionOf.toLinearPMap, self] (during elaboration) for (∀ {R : Type u} [inst : Ring R] {Q : TypeMax} [inst_1 : AddCommGroup Q] [inst_2 : Module R Q] {M : Type (max u v)}
  {N : Type (max u v)} [inst_3 : AddCommGroup M] [inst_4 : AddCommGroup N] [inst_5 : Module R M] [inst_6 : Module R N]
  {i : M →ₗ[R] N} {f : M →ₗ[R] Q} (self : Module.Baer.ExtensionOf i f),
  LinearMap.range i ≤ LinearPMap.domain (Module.Baer.ExtensionOf.toLinearPMap self))

 : (∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]
  [inst_2 : CategoryTheory.Limits.HasBinaryProducts C] (X : C) (Y : C),
  β_ X Y = CategoryTheory.Limits.prod.braiding X Y)
type mismatch
  CategoryTheory.Limits.prod.braiding X Y
has type
  X ⨯ Y ≅ Y ⨯ X : Type ?u.6
but is expected to have type
  CategoryTheory.MonoidalCategory.tensorObj X Y ≅ CategoryTheory.MonoidalCategory.tensorObj Y X : Type ?u.6 ; identifiers [C, u, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasTerminal, C, inst_2, CategoryTheory.Limits.HasBinaryProducts, C, X, C, Y, C, X, Y, CategoryTheory.Limits.prod.braiding, X, Y] (during elaboration) for (∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]
  [inst_2 : CategoryTheory.Limits.HasBinaryProducts C] (X : C) (Y : C),
  β_ X Y = CategoryTheory.Limits.prod.braiding X Y)

 : (∀ {R : Type u_1} {M₁ : Type u_2} {M₂ : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M₁]
  [inst_2 : AddCommMonoid M₂] [inst_3 : Module R M₁] [inst_4 : Module R M₂] {Q₁ : QuadraticForm R M₁}
  {Q₂ : QuadraticForm R M₂} (self : QuadraticForm.Isometry Q₁ Q₂) (m : M₁),
  ↑Q₂ (AddHom.toFun (LinearMap.toAddHom ↑(QuadraticForm.Isometry.toLinearEquiv self)) m) = ↑Q₁ m)
unknown constant 'QuadraticForm.Isometry' ; identifiers [R, u_1, M₁, u_2, M₂, u_3, inst, Semiring, R, inst_1, AddCommMonoid, M₁, inst_2, AddCommMonoid, M₂, inst_3, Module, R, M₁, inst_4, Module, R, M₂, Q₁, QuadraticForm, R, M₁, Q₂, QuadraticForm, R, M₂, self, QuadraticForm.Isometry, Q₁, Q₂, m, M₁, Q₂, AddHom.toFun, LinearMap.toAddHom, QuadraticForm.Isometry.toLinearEquiv, self, m, Q₁, m] (during elaboration) for (∀ {R : Type u_1} {M₁ : Type u_2} {M₂ : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M₁]
  [inst_2 : AddCommMonoid M₂] [inst_3 : Module R M₁] [inst_4 : Module R M₂] {Q₁ : QuadraticForm R M₁}
  {Q₂ : QuadraticForm R M₂} (self : QuadraticForm.Isometry Q₁ Q₂) (m : M₁),
  ↑Q₂ (AddHom.toFun (LinearMap.toAddHom ↑(QuadraticForm.Isometry.toLinearEquiv self)) m) = ↑Q₁ m)

 : (∀ {G : Type u_1} {α : Type u_2} [inst : Zero G] [inst_1 : VAdd G α] [inst_2 : MeasurableSpace α] {s : Set α}
  {μ : autoParam (MeasureTheory.Measure α) _auto✝} (self : MeasureTheory.IsAddFundamentalDomain G s),
  ∀ᵐ (x : α) ∂μ, ∃ (g : G), g +ᵥ x ∈ s)
<input>:2:48: expected token

 : (∀ {X : TopCat} {x : ↑X} {y : ↑X} (e : Inseparable x y), nhds x ≤ nhds y)
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, y, X, e, Inseparable, x, y, nhds, x, nhds, y] (during elaboration) for (∀ {X : TopCat} {x : ↑X} {y : ↑X} (e : Inseparable x y), nhds x ≤ nhds y)

 : (∀ (self : YoungDiagram), IsLowerSet ↑(YoungDiagram.cells self))
typeclass instance problem is stuck, it is often due to metavariables
  LE (?m.330 self) ; identifiers [self, YoungDiagram, IsLowerSet, YoungDiagram.cells, self] (during elaboration) for (∀ (self : YoungDiagram), IsLowerSet ↑(YoungDiagram.cells self))

 : (∀ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N]
  (self : AddSubmonoid.LocalizationMap S N) (x : M) (y : M),
  (ZeroHom.toFun (↑(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) x =
      ZeroHom.toFun (↑(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) y) ↔
    (∃ (c : { x : M // x ∈ S }), ↑c + x = ↑c + y))
typeclass instance problem is stuck, it is often due to metavariables
  Zero (?m.9539 self x y) ; identifiers [M, u_1, inst, AddCommMonoid, M, S, AddSubmonoid, M, N, u_2, inst_1, AddCommMonoid, N, self, AddSubmonoid.LocalizationMap, S, N, x, M, y, M, ZeroHom.toFun, AddSubmonoid.LocalizationMap.toAddMonoidHom, self, x, ZeroHom.toFun, AddSubmonoid.LocalizationMap.toAddMonoidHom, self, y, c, x, M, x, S, c, x, c, y] (during elaboration) for (∀ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N]
  (self : AddSubmonoid.LocalizationMap S N) (x : M) (y : M),
  (ZeroHom.toFun (↑(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) x =
      ZeroHom.toFun (↑(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) y) ↔
    (∃ (c : { x : M // x ∈ S }), ↑c + x = ↑c + y))

 : (∀ {α : Type u_1} {s : Set α} {a : α} [inst : Star α], (a ∈ star s) ↔ (star a ∈ s))
failed to synthesize instance
  Star (Set α) ; identifiers [α, u_1, s, Set, α, a, α, inst, Star, α, a, star, s, star, a, s] (during elaboration) for (∀ {α : Type u_1} {s : Set α} {a : α} [inst : Star α], (a ∈ star s) ↔ (star a ∈ s))

(∀ {α : Type ua} {β : Type ub} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : (a : α) → β},
  (UniformContinuous f) ↔
    (∀ (r : Set (β × β)) (a : r ∈ uniformity β), {x : α × α | (f (Prod.fst x), f (Prod.snd x)) ∈ r} ∈ uniformity α))
unknown universe level 'ua' ; identifiers [α, ua, β, ub, inst, UniformSpace, α, inst_1, UniformSpace, β, f, a, α, β, UniformContinuous, f, r, Set, β, β, a, r, uniformity, β, x, α, α, f, Prod.fst, x, f, Prod.snd, x, r, uniformity, α] (during elaboration) for (∀ {α : Type ua} {β : Type ub} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : (a : α) → β},
  (UniformContinuous f) ↔
    (∀ (r : Set (β × β)) (a : r ∈ uniformity β), {x : α × α | (f (Prod.fst x), f (Prod.snd x)) ∈ r} ∈ uniformity α))

(∀ {α : Type u_1} [inst : Preorder α] [inst_1 : OrderTop α] (x : ↑(Set.Iic ⊤)) (y : ↑(Set.Iic ⊤)),
  (↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        x ≤
      ↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        y) ↔
    (↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        x ≤
      ↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        y))
type mismatch
  Set.Iic ⊤
has type
  Set ?m.26 : Type ?u.25
but is expected to have type
  Sort ?u.21 : Type ?u.21 ; identifiers [α, u_1, inst, Preorder, α, inst_1, OrderTop, α, x, Set.Iic, y, Set.Iic, toFun, Equiv.toFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, invFun, Equiv.invFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, left_inv, Equiv.left_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, right_inv, Equiv.right_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, x, toFun, Equiv.toFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, invFun, Equiv.invFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, left_inv, Equiv.left_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, right_inv, Equiv.right_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, y, toFun, Equiv.toFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, invFun, Equiv.invFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, left_inv, Equiv.left_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, right_inv, Equiv.right_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, x, toFun, Equiv.toFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, invFun, Equiv.invFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, left_inv, Equiv.left_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, right_inv, Equiv.right_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, y] (during elaboration) for (∀ {α : Type u_1} [inst : Preorder α] [inst_1 : OrderTop α] (x : ↑(Set.Iic ⊤)) (y : ↑(Set.Iic ⊤)),
  (↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        x ≤
      ↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        y) ↔
    (↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        x ≤
      ↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        y))

(∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {A : C},
  (CategoryTheory.IsSubterminal A) ↔ (∀ ⦃Z : C⦄ (f : Z ⟶ A) (g : Z ⟶ A), f = g))
unknown universe level 'v₁' ; identifiers [C, u₁, inst, CategoryTheory.Category, v₁, u₁, C, A, C, CategoryTheory.IsSubterminal, A, Z, C, f, Z, A, g, Z, A, f, g] (during elaboration) for (∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {A : C},
  (CategoryTheory.IsSubterminal A) ↔ (∀ ⦃Z : C⦄ (f : Z ⟶ A) (g : Z ⟶ A), f = g))

(∀ {J : Type v} [inst : CategoryTheory.SmallCategory J] {F : CategoryTheory.Functor J CommRingCat} [inst_1 : SizeOf J],
  sizeOf CommRingCat.Colimits.Prequotient.one = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (CommRingCat.Colimits.Prequotient ?m.13078) ; identifiers [J, v, inst, CategoryTheory.SmallCategory, J, F, CategoryTheory.Functor, J, CommRingCat, inst_1, SizeOf, J, sizeOf, CommRingCat.Colimits.Prequotient.one] (during elaboration) for (∀ {J : Type v} [inst : CategoryTheory.SmallCategory J] {F : CategoryTheory.Functor J CommRingCat} [inst_1 : SizeOf J],
  sizeOf CommRingCat.Colimits.Prequotient.one = 1)

(∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {l : Filter α} {r : (a : β) → (a : γ) → Prop} {f : (a : α) → β}
  {g : (a : α) → γ}, (Filter.Germ.LiftRel r ↑f ↑g) ↔ (∀ᶠ (x : α) in l, r (f x) (g x)))
type mismatch
  g
has type
  α → γ : Type (max u_1 u_3)
but is expected to have type
  Filter.Germ ?m.223 γ : Type (max ?u.30 u_3) ; identifiers [α, u_1, β, u_2, γ, u_3, l, Filter, α, r, a, β, a, γ, f, a, α, β, g, a, α, γ, Filter.Germ.LiftRel, r, f, g, x, α, l, r, f, x, g, x] (during elaboration) for (∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {l : Filter α} {r : (a : β) → (a : γ) → Prop} {f : (a : α) → β}
  {g : (a : α) → γ}, (Filter.Germ.LiftRel r ↑f ↑g) ↔ (∀ᶠ (x : α) in l, r (f x) (g x)))

(∀ {J : Type u₁} [inst : SizeOf J], sizeOf CategoryTheory.Bicone.right = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (CategoryTheory.Bicone ?m.6881) ; identifiers [J, u₁, inst, SizeOf, J, sizeOf, CategoryTheory.Bicone.right] (during elaboration) for (∀ {J : Type u₁} [inst : SizeOf J], sizeOf CategoryTheory.Bicone.right = 1)

(∀ {L : FirstOrder.Language} (M : Type w) [inst : FirstOrder.Language.Structure L M]
  {φ : FirstOrder.Language.Sentence L}, (M ⊨ FirstOrder.Language.Formula.not φ) ↔ (¬(M ⊨ φ)))
ambiguous, possible interpretations 
  M ⊨ ?m.508 : Prop
  
  M ⊨ FirstOrder.Language.Formula.not φ : Prop ; identifiers [L, FirstOrder.Language, M, w, inst, FirstOrder.Language.Structure, L, M, φ, FirstOrder.Language.Sentence, L, M, FirstOrder.Language.Formula.not, φ, M, FirstOrder.Language.Formula.not, φ, M, φ, M, φ] (during elaboration) for (∀ {L : FirstOrder.Language} (M : Type w) [inst : FirstOrder.Language.Structure L M]
  {φ : FirstOrder.Language.Sentence L}, (M ⊨ FirstOrder.Language.Formula.not φ) ↔ (¬(M ⊨ φ)))

(∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] [inst_1 : SizeOf J],
  sizeOf CategoryTheory.BiconeHom.right_id = 1)
unknown universe level 'v₁' ; identifiers [J, u₁, inst, CategoryTheory.Category, v₁, u₁, J, inst_1, SizeOf, J, sizeOf, CategoryTheory.BiconeHom.right_id] (during elaboration) for (∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] [inst_1 : SizeOf J],
  sizeOf CategoryTheory.BiconeHom.right_id = 1)

(∀ {R : Type u_1} [inst : Semiring R] (h : IsField R) (a : R) (b : R), a / b = a / b)
failed to synthesize instance
  HDiv R R ?m.293 ; identifiers [R, u_1, inst, Semiring, R, h, IsField, R, a, R, b, R, a, b, a, b] (during elaboration) for (∀ {R : Type u_1} [inst : Semiring R] (h : IsField R) (a : R) (b : R), a / b = a / b)

(∀ {α : Type u_1} {l : List α}, (Multiset.Nodup ↑l) ↔ (List.Nodup l))
type mismatch
  l
has type
  List α : Type u_1
but is expected to have type
  Multiset ?m.117 : Type u_1 ; identifiers [α, u_1, l, List, α, Multiset.Nodup, l, List.Nodup, l] (during elaboration) for (∀ {α : Type u_1} {l : List α}, (Multiset.Nodup ↑l) ↔ (List.Nodup l))

(CategoryTheory.BundledHom.ParentProjection fun {α : Type u_1} (h : AddGroup α) ↦ SubNegMonoid.toAddMonoid)
typeclass instance problem is stuck, it is often due to metavariables
  SubNegMonoid ?m.41 ; identifiers [CategoryTheory.BundledHom.ParentProjection, α, u_1, h, AddGroup, α, SubNegMonoid.toAddMonoid] (during elaboration) for (CategoryTheory.BundledHom.ParentProjection fun {α : Type u_1} (h : AddGroup α) ↦ SubNegMonoid.toAddMonoid)

(∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering ι I M s} {U : (a : M) → Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : ι) ↦ U (SmoothBumpCovering.c s f i)) ↔
    (SmoothBumpCovering.IsSubordinate f U))
unknown universe level 'uH' ; identifiers [ι, uι, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, ι, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, ι, U, SmoothBumpCovering.c, s, f, i, SmoothBumpCovering.IsSubordinate, f, U] (during elaboration) for (∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering ι I M s} {U : (a : M) → Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : ι) ↦ U (SmoothBumpCovering.c s f i)) ↔
    (SmoothBumpCovering.IsSubordinate f U))

(∀ {α : Type u_2} {β : Type u_3} [inst : SMul α β] {f : Filter α} {g : Filter β} {t : Set β},
  (t ∈ f • g) ↔ (∃ (t₁ : Set α), ∃ (t₂ : Set β), (t₁ ∈ f) ∧ ((t₂ ∈ g) ∧ (t₁ • t₂ ⊆ t))))
failed to synthesize instance
  HSMul (Filter α) (Filter β) ?m.33 ; identifiers [α, u_2, β, u_3, inst, SMul, α, β, f, Filter, α, g, Filter, β, t, Set, β, t, f, g, t₁, Set, α, t₂, Set, β, t₁, f, t₂, g, t₁, t₂, t] (during elaboration) for (∀ {α : Type u_2} {β : Type u_3} [inst : SMul α β] {f : Filter α} {g : Filter β} {t : Set β},
  (t ∈ f • g) ↔ (∃ (t₁ : Set α), ∃ (t₂ : Set β), (t₁ ∈ f) ∧ ((t₂ ∈ g) ∧ (t₁ • t₂ ⊆ t))))

(∀ {A : Type u_1} [inst : AddZeroClass A] {a : AddSubmonoid A} {b : AddSubmonoid A},
  (↑{
            toFun :=
              ((fun (S : AddSubmonoid A) ↦
                {
                  toSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                      mul_mem' :=
                        (((fun {a : Multiplicative A} ↦
                          (_ :
                            ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                              (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                              ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                  one_mem' := (((AddSubmonoid.zero_mem' S))) })),
            invFun :=
              ((fun (S : Submonoid (Multiplicative A)) ↦
                {
                  toAddSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                      add_mem' :=
                        (((fun {a : A} ↦
                          (_ :
                            ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S) (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                              a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                  zero_mem' := (((Submonoid.one_mem' S))) })),
            left_inv :=
              (((fun (x : AddSubmonoid A) ↦
                (_ :
                  (fun (S : Submonoid (Multiplicative A)) ↦
                        {
                          toAddSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                              add_mem' :=
                                (((fun {a : A} ↦
                                  (_ :
                                    ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                      a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                          zero_mem' := (((Submonoid.one_mem' S))) })
                      ((fun (S : AddSubmonoid A) ↦
                          {
                            toSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                                mul_mem' :=
                                  (((fun {a : Multiplicative A} ↦
                                    (_ :
                                      ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                        ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                          AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                            one_mem' := (((AddSubmonoid.zero_mem' S))) })
                        x) =
                    x)))),
            right_inv :=
              (((fun (x : Submonoid (Multiplicative A)) ↦
                (_ :
                  (fun (S : AddSubmonoid A) ↦
                        {
                          toSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                              mul_mem' :=
                                (((fun {a : Multiplicative A} ↦
                                  (_ :
                                    ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                      ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                        AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                          one_mem' := (((AddSubmonoid.zero_mem' S))) })
                      ((fun (S : Submonoid (Multiplicative A)) ↦
                          {
                            toAddSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                                add_mem' :=
                                  (((fun {a : A} ↦
                                    (_ :
                                      ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                        a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                            zero_mem' := (((Submonoid.one_mem' S))) })
                        x) =
                    x)))) }
        a ≤
      ↑{
            toFun :=
              ((fun (S : AddSubmonoid A) ↦
                {
                  toSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                      mul_mem' :=
                        (((fun {a : Multiplicative A} ↦
                          (_ :
                            ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                              (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                              ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                  one_mem' := (((AddSubmonoid.zero_mem' S))) })),
            invFun :=
              ((fun (S : Submonoid (Multiplicative A)) ↦
                {
                  toAddSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                      add_mem' :=
                        (((fun {a : A} ↦
                          (_ :
                            ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S) (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                              a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                  zero_mem' := (((Submonoid.one_mem' S))) })),
            left_inv :=
              (((fun (x : AddSubmonoid A) ↦
                (_ :
                  (fun (S : Submonoid (Multiplicative A)) ↦
                        {
                          toAddSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                              add_mem' :=
                                (((fun {a : A} ↦
                                  (_ :
                                    ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                      a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                          zero_mem' := (((Submonoid.one_mem' S))) })
                      ((fun (S : AddSubmonoid A) ↦
                          {
                            toSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                                mul_mem' :=
                                  (((fun {a : Multiplicative A} ↦
                                    (_ :
                                      ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                        ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                          AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                            one_mem' := (((AddSubmonoid.zero_mem' S))) })
                        x) =
                    x)))),
            right_inv :=
              (((fun (x : Submonoid (Multiplicative A)) ↦
                (_ :
                  (fun (S : AddSubmonoid A) ↦
                        {
                          toSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                              mul_mem' :=
                                (((fun {a : Multiplicative A} ↦
                                  (_ :
                                    ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                      ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                        AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                          one_mem' := (((AddSubmonoid.zero_mem' S))) })
                      ((fun (S : Submonoid (Multiplicative A)) ↦
                          {
                            toAddSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                                add_mem' :=
                                  (((fun {a : A} ↦
                                    (_ :
                                      ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                        a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                            zero_mem' := (((Submonoid.one_mem' S))) })
                        x) =
                    x)))) }
        b) ↔
    (↑{
            toFun :=
              ((fun (S : AddSubmonoid A) ↦
                {
                  toSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                      mul_mem' :=
                        (((fun {a : Multiplicative A} ↦
                          (_ :
                            ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                              (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                              ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                  one_mem' := (((AddSubmonoid.zero_mem' S))) })),
            invFun :=
              ((fun (S : Submonoid (Multiplicative A)) ↦
                {
                  toAddSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                      add_mem' :=
                        (((fun {a : A} ↦
                          (_ :
                            ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S) (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                              a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                  zero_mem' := (((Submonoid.one_mem' S))) })),
            left_inv :=
              (((fun (x : AddSubmonoid A) ↦
                (_ :
                  (fun (S : Submonoid (Multiplicative A)) ↦
                        {
                          toAddSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                              add_mem' :=
                                (((fun {a : A} ↦
                                  (_ :
                                    ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                      a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                          zero_mem' := (((Submonoid.one_mem' S))) })
                      ((fun (S : AddSubmonoid A) ↦
                          {
                            toSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                                mul_mem' :=
                                  (((fun {a : Multiplicative A} ↦
                                    (_ :
                                      ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                        ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                          AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                            one_mem' := (((AddSubmonoid.zero_mem' S))) })
                        x) =
                    x)))),
            right_inv :=
              (((fun (x : Submonoid (Multiplicative A)) ↦
                (_ :
                  (fun (S : AddSubmonoid A) ↦
                        {
                          toSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                              mul_mem' :=
                                (((fun {a : Multiplicative A} ↦
                                  (_ :
                                    ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                      ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                        AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                          one_mem' := (((AddSubmonoid.zero_mem' S))) })
                      ((fun (S : Submonoid (Multiplicative A)) ↦
                          {
                            toAddSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                                add_mem' :=
                                  (((fun {a : A} ↦
                                    (_ :
                                      ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                        a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                            zero_mem' := (((Submonoid.one_mem' S))) })
                        x) =
                    x)))) }
        a ≤
      ↑{
            toFun :=
              ((fun (S : AddSubmonoid A) ↦
                {
                  toSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                      mul_mem' :=
                        (((fun {a : Multiplicative A} ↦
                          (_ :
                            ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                              (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                              ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                  one_mem' := (((AddSubmonoid.zero_mem' S))) })),
            invFun :=
              ((fun (S : Submonoid (Multiplicative A)) ↦
                {
                  toAddSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                      add_mem' :=
                        (((fun {a : A} ↦
                          (_ :
                            ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S) (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                              a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                  zero_mem' := (((Submonoid.one_mem' S))) })),
            left_inv :=
              (((fun (x : AddSubmonoid A) ↦
                (_ :
                  (fun (S : Submonoid (Multiplicative A)) ↦
                        {
                          toAddSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                              add_mem' :=
                                (((fun {a : A} ↦
                                  (_ :
                                    ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                      a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                          zero_mem' := (((Submonoid.one_mem' S))) })
                      ((fun (S : AddSubmonoid A) ↦
                          {
                            toSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                                mul_mem' :=
                                  (((fun {a : Multiplicative A} ↦
                                    (_ :
                                      ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                        ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                          AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                            one_mem' := (((AddSubmonoid.zero_mem' S))) })
                        x) =
                    x)))),
            right_inv :=
              (((fun (x : Submonoid (Multiplicative A)) ↦
                (_ :
                  (fun (S : AddSubmonoid A) ↦
                        {
                          toSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                              mul_mem' :=
                                (((fun {a : Multiplicative A} ↦
                                  (_ :
                                    ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                      ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                        AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                          one_mem' := (((AddSubmonoid.zero_mem' S))) })
                      ((fun (S : Submonoid (Multiplicative A)) ↦
                          {
                            toAddSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                                add_mem' :=
                                  (((fun {a : A} ↦
                                    (_ :
                                      ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                        a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                            zero_mem' := (((Submonoid.one_mem' S))) })
                        x) =
                    x)))) }
        b))
<input>:8:22: expected '}'

(∀ {G : Type u_1} [inst : Group G] {S : Type u_6} (H : S) [inst_1 : SetLike S G] [inst_2 : SubgroupClass S G],
  ↑↑H = Subtype.val)
type mismatch
  H
has type
  S : Type u_6
but is expected to have type
  Subtype (?m.164168 H) → ?m.164167 H : Sort (imax (max 1 ?u.147) ?u.147) ; identifiers [G, u_1, inst, Group, G, S, u_6, H, S, inst_1, SetLike, S, G, inst_2, SubgroupClass, S, G, H, Subtype.val] (during elaboration) for (∀ {G : Type u_1} [inst : Group G] {S : Type u_6} (H : S) [inst_1 : SetLike S G] [inst_2 : SubgroupClass S G],
  ↑↑H = Subtype.val)

(∀ {α : Type u_1} [inst : Preorder α] {a : ↑Set.univ} {b : ↑Set.univ},
  (↑(Equiv.Set.univ α) a ≤ ↑(Equiv.Set.univ α) b) ↔ (↑(Equiv.Set.univ α) a ≤ ↑(Equiv.Set.univ α) b))
type mismatch
  Set.univ
has type
  Set ?m.9 : Type ?u.8
but is expected to have type
  Sort ?u.7 : Type ?u.7 ; identifiers [α, u_1, inst, Preorder, α, a, Set.univ, b, Set.univ, Equiv.Set.univ, α, a, Equiv.Set.univ, α, b, Equiv.Set.univ, α, a, Equiv.Set.univ, α, b] (during elaboration) for (∀ {α : Type u_1} [inst : Preorder α] {a : ↑Set.univ} {b : ↑Set.univ},
  (↑(Equiv.Set.univ α) a ≤ ↑(Equiv.Set.univ α) b) ↔ (↑(Equiv.Set.univ α) a ≤ ↑(Equiv.Set.univ α) b))

(∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] [inst_1 : SizeOf J],
  sizeOf CategoryTheory.BiconeHom.left_id = 1)
unknown universe level 'v₁' ; identifiers [J, u₁, inst, CategoryTheory.Category, v₁, u₁, J, inst_1, SizeOf, J, sizeOf, CategoryTheory.BiconeHom.left_id] (during elaboration) for (∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] [inst_1 : SizeOf J],
  sizeOf CategoryTheory.BiconeHom.left_id = 1)

(∀ {R : Type u} [inst : Ring R] {J : Type w} [inst_1 : CategoryTheory.Category.{v, w} J]
  {F : CategoryTheory.Functor J (ModuleCat R)} [inst_2 : SizeOf R] [inst_3 : SizeOf J],
  sizeOf ModuleCat.Colimits.Prequotient.zero = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (ModuleCat.Colimits.Prequotient ?m.13886) ; identifiers [R, u, inst, Ring, R, J, w, inst_1, CategoryTheory.Category, v, w, J, F, CategoryTheory.Functor, J, ModuleCat, R, inst_2, SizeOf, R, inst_3, SizeOf, J, sizeOf, ModuleCat.Colimits.Prequotient.zero] (during elaboration) for (∀ {R : Type u} [inst : Ring R] {J : Type w} [inst_1 : CategoryTheory.Category.{v, w} J]
  {F : CategoryTheory.Functor J (ModuleCat R)} [inst_2 : SizeOf R] [inst_3 : SizeOf J],
  sizeOf ModuleCat.Colimits.Prequotient.zero = 1)

(∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [inst : Semiring R] [inst_1 : Semiring R₂]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}
  {F : Type u_20} [sc : SemilinearMapClass F τ₁₂ M M₂] [inst_6 : RingHomSurjective τ₁₂] {f : F} {x : M₂},
  (x ∈ LinearMap.range f) ↔ (∃ (y : M), ↑f y = x))
unknown universe level 'u_12' ; identifiers [R, u_1, R₂, u_3, M, u_9, M₂, u_12, inst, Semiring, R, inst_1, Semiring, R₂, inst_2, AddCommMonoid, M, inst_3, AddCommMonoid, M₂, inst_4, Module, R, M, inst_5, Module, R₂, M₂, τ₁₂, R, R₂, F, u_20, sc, SemilinearMapClass, F, τ₁₂, M, M₂, inst_6, RingHomSurjective, τ₁₂, f, F, x, M₂, x, LinearMap.range, f, y, M, f, y, x] (during elaboration) for (∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [inst : Semiring R] [inst_1 : Semiring R₂]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}
  {F : Type u_20} [sc : SemilinearMapClass F τ₁₂ M M₂] [inst_6 : RingHomSurjective τ₁₂] {f : F} {x : M₂},
  (x ∈ LinearMap.range f) ↔ (∃ (y : M), ↑f y = x))

(∀ {α : Type u} [inst : SizeOf α], sizeOf none = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (Option ?m.6881) ; identifiers [α, u, inst, SizeOf, α, sizeOf, none] (during elaboration) for (∀ {α : Type u} [inst : SizeOf α], sizeOf none = 1)

(∀ {M : Type u_1} [hM : MonoidWithZero M] (h : ∀ (a : M), (IsUnit a) ∨ (a = 0)) (a : M) (b : M), a / b = a / b)
failed to synthesize instance
  HDiv M M ?m.779 ; identifiers [M, u_1, hM, MonoidWithZero, M, h, a, M, IsUnit, a, a, a, M, b, M, a, b, a, b] (during elaboration) for (∀ {M : Type u_1} [hM : MonoidWithZero M] (h : ∀ (a : M), (IsUnit a) ∨ (a = 0)) (a : M) (b : M), a / b = a / b)

(∀ {α : Type u} [inst : SizeOf α], sizeOf LazyList.nil = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (LazyList ?m.6881) ; identifiers [α, u, inst, SizeOf, α, sizeOf, LazyList.nil] (during elaboration) for (∀ {α : Type u} [inst : SizeOf α], sizeOf LazyList.nil = 1)

(∀ {X : TopCat} {x : ↑X} {y : ↑X} (e : Inseparable x y), nhds y ≤ nhds x)
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, y, X, e, Inseparable, x, y, nhds, y, nhds, x] (during elaboration) for (∀ {X : TopCat} {x : ↑X} {y : ↑X} (e : Inseparable x y), nhds y ≤ nhds x)

(∀ {K : Type u_1} {Γ : (a : K) → Type u_2} {Λ : Type u_3} {σ : Type u_4} [inst : SizeOf K]
  [inst_1 : (a : K) → SizeOf (Γ a)] [inst_2 : SizeOf Λ] [inst_3 : SizeOf σ] (a : (a : σ) → Λ),
  sizeOf (Turing.TM2.Stmt.goto a) = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (Turing.TM2.Stmt (?m.6994 a) Λ σ) ; identifiers [K, u_1, Γ, a, K, u_2, Λ, u_3, σ, u_4, inst, SizeOf, K, inst_1, a, K, SizeOf, Γ, a, inst_2, SizeOf, Λ, inst_3, SizeOf, σ, a, a, σ, Λ, sizeOf, Turing.TM2.Stmt.goto, a] (during elaboration) for (∀ {K : Type u_1} {Γ : (a : K) → Type u_2} {Λ : Type u_3} {σ : Type u_4} [inst : SizeOf K]
  [inst_1 : (a : K) → SizeOf (Γ a)] [inst_2 : SizeOf Λ] [inst_3 : SizeOf σ] (a : (a : σ) → Λ),
  sizeOf (Turing.TM2.Stmt.goto a) = 1)

(∀ {α : Type u_2} {β : Type u_3} [inst : SMul α β] {t : Set β} {a : α} {x : β},
  (x ∈ a • t) ↔ (∃ (y : β), (y ∈ t) ∧ (a • y = x)))
failed to synthesize instance
  HSMul α (Set β) ?m.29 ; identifiers [α, u_2, β, u_3, inst, SMul, α, β, t, Set, β, a, α, x, β, x, a, t, y, β, y, t, a, y, x] (during elaboration) for (∀ {α : Type u_2} {β : Type u_3} [inst : SMul α β] {t : Set β} {a : α} {x : β},
  (x ∈ a • t) ↔ (∃ (y : β), (y ∈ t) ∧ (a • y = x)))

(∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : NonUnitalSemiring A]
  [inst_3 : StarRing A] [inst_4 : Module R A] [inst_5 : IsScalarTower R A A] [inst_6 : SMulCommClass R A A]
  [inst_7 : StarModule R A], Monotone star)
typeclass instance problem is stuck, it is often due to metavariables
  Preorder ?m.10739 ; identifiers [R, u, A, v, inst, CommSemiring, R, inst_1, StarRing, R, inst_2, NonUnitalSemiring, A, inst_3, StarRing, A, inst_4, Module, R, A, inst_5, IsScalarTower, R, A, A, inst_6, SMulCommClass, R, A, A, inst_7, StarModule, R, A, Monotone, star] (during elaboration) for (∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : NonUnitalSemiring A]
  [inst_3 : StarRing A] [inst_4 : Module R A] [inst_5 : IsScalarTower R A A] [inst_6 : SMulCommClass R A A]
  [inst_7 : StarModule R A], Monotone star)

(∀ {α : Type ua} {β : Type ub} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : (a : α) → β},
  (UniformContinuous f) ↔
    (∀ (r : Set (β × β)) (a : r ∈ uniformity β), {x : α × α | (f (Prod.fst x), f (Prod.snd x)) ∈ r} ∈ uniformity α))
unknown universe level 'ua' ; identifiers [α, ua, β, ub, inst, UniformSpace, α, inst_1, UniformSpace, β, f, a, α, β, UniformContinuous, f, r, Set, β, β, a, r, uniformity, β, x, α, α, f, Prod.fst, x, f, Prod.snd, x, r, uniformity, α] (during elaboration) for (∀ {α : Type ua} {β : Type ub} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : (a : α) → β},
  (UniformContinuous f) ↔
    (∀ (r : Set (β × β)) (a : r ∈ uniformity β), {x : α × α | (f (Prod.fst x), f (Prod.snd x)) ∈ r} ∈ uniformity α))

(∀ {α : Type u_1} [inst : Preorder α] [inst_1 : OrderTop α] (x : ↑(Set.Iic ⊤)) (y : ↑(Set.Iic ⊤)),
  (↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        x ≤
      ↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        y) ↔
    (↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        x ≤
      ↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        y))
type mismatch
  Set.Iic ⊤
has type
  Set ?m.26 : Type ?u.25
but is expected to have type
  Sort ?u.21 : Type ?u.21 ; identifiers [α, u_1, inst, Preorder, α, inst_1, OrderTop, α, x, Set.Iic, y, Set.Iic, toFun, Equiv.toFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, invFun, Equiv.invFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, left_inv, Equiv.left_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, right_inv, Equiv.right_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, x, toFun, Equiv.toFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, invFun, Equiv.invFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, left_inv, Equiv.left_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, right_inv, Equiv.right_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, y, toFun, Equiv.toFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, invFun, Equiv.invFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, left_inv, Equiv.left_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, right_inv, Equiv.right_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, x, toFun, Equiv.toFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, invFun, Equiv.invFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, left_inv, Equiv.left_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, right_inv, Equiv.right_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, y] (during elaboration) for (∀ {α : Type u_1} [inst : Preorder α] [inst_1 : OrderTop α] (x : ↑(Set.Iic ⊤)) (y : ↑(Set.Iic ⊤)),
  (↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        x ≤
      ↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        y) ↔
    (↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        x ≤
      ↑{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        y))

(∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {A : C},
  (CategoryTheory.IsSubterminal A) ↔ (∀ ⦃Z : C⦄ (f : Z ⟶ A) (g : Z ⟶ A), f = g))
unknown universe level 'v₁' ; identifiers [C, u₁, inst, CategoryTheory.Category, v₁, u₁, C, A, C, CategoryTheory.IsSubterminal, A, Z, C, f, Z, A, g, Z, A, f, g] (during elaboration) for (∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {A : C},
  (CategoryTheory.IsSubterminal A) ↔ (∀ ⦃Z : C⦄ (f : Z ⟶ A) (g : Z ⟶ A), f = g))

(∀ {J : Type v} [inst : CategoryTheory.SmallCategory J] {F : CategoryTheory.Functor J CommRingCat} [inst_1 : SizeOf J],
  sizeOf CommRingCat.Colimits.Prequotient.one = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (CommRingCat.Colimits.Prequotient ?m.13078) ; identifiers [J, v, inst, CategoryTheory.SmallCategory, J, F, CategoryTheory.Functor, J, CommRingCat, inst_1, SizeOf, J, sizeOf, CommRingCat.Colimits.Prequotient.one] (during elaboration) for (∀ {J : Type v} [inst : CategoryTheory.SmallCategory J] {F : CategoryTheory.Functor J CommRingCat} [inst_1 : SizeOf J],
  sizeOf CommRingCat.Colimits.Prequotient.one = 1)

(∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {l : Filter α} {r : (a : β) → (a : γ) → Prop} {f : (a : α) → β}
  {g : (a : α) → γ}, (Filter.Germ.LiftRel r ↑f ↑g) ↔ (∀ᶠ (x : α) in l, r (f x) (g x)))
type mismatch
  g
has type
  α → γ : Type (max u_1 u_3)
but is expected to have type
  Filter.Germ ?m.223 γ : Type (max ?u.30 u_3) ; identifiers [α, u_1, β, u_2, γ, u_3, l, Filter, α, r, a, β, a, γ, f, a, α, β, g, a, α, γ, Filter.Germ.LiftRel, r, f, g, x, α, l, r, f, x, g, x] (during elaboration) for (∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {l : Filter α} {r : (a : β) → (a : γ) → Prop} {f : (a : α) → β}
  {g : (a : α) → γ}, (Filter.Germ.LiftRel r ↑f ↑g) ↔ (∀ᶠ (x : α) in l, r (f x) (g x)))

(∀ {J : Type u₁} [inst : SizeOf J], sizeOf CategoryTheory.Bicone.right = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (CategoryTheory.Bicone ?m.6881) ; identifiers [J, u₁, inst, SizeOf, J, sizeOf, CategoryTheory.Bicone.right] (during elaboration) for (∀ {J : Type u₁} [inst : SizeOf J], sizeOf CategoryTheory.Bicone.right = 1)

(∀ {L : FirstOrder.Language} (M : Type w) [inst : FirstOrder.Language.Structure L M]
  {φ : FirstOrder.Language.Sentence L}, (M ⊨ FirstOrder.Language.Formula.not φ) ↔ (¬(M ⊨ φ)))
ambiguous, possible interpretations 
  M ⊨ ?m.508 : Prop
  
  M ⊨ FirstOrder.Language.Formula.not φ : Prop ; identifiers [L, FirstOrder.Language, M, w, inst, FirstOrder.Language.Structure, L, M, φ, FirstOrder.Language.Sentence, L, M, FirstOrder.Language.Formula.not, φ, M, FirstOrder.Language.Formula.not, φ, M, φ, M, φ] (during elaboration) for (∀ {L : FirstOrder.Language} (M : Type w) [inst : FirstOrder.Language.Structure L M]
  {φ : FirstOrder.Language.Sentence L}, (M ⊨ FirstOrder.Language.Formula.not φ) ↔ (¬(M ⊨ φ)))

(∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] [inst_1 : SizeOf J],
  sizeOf CategoryTheory.BiconeHom.right_id = 1)
unknown universe level 'v₁' ; identifiers [J, u₁, inst, CategoryTheory.Category, v₁, u₁, J, inst_1, SizeOf, J, sizeOf, CategoryTheory.BiconeHom.right_id] (during elaboration) for (∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] [inst_1 : SizeOf J],
  sizeOf CategoryTheory.BiconeHom.right_id = 1)

(∀ {R : Type u_1} [inst : Semiring R] (h : IsField R) (a : R) (b : R), a / b = a / b)
failed to synthesize instance
  HDiv R R ?m.293 ; identifiers [R, u_1, inst, Semiring, R, h, IsField, R, a, R, b, R, a, b, a, b] (during elaboration) for (∀ {R : Type u_1} [inst : Semiring R] (h : IsField R) (a : R) (b : R), a / b = a / b)

(∀ {α : Type u_1} {l : List α}, (Multiset.Nodup ↑l) ↔ (List.Nodup l))
type mismatch
  l
has type
  List α : Type u_1
but is expected to have type
  Multiset ?m.117 : Type u_1 ; identifiers [α, u_1, l, List, α, Multiset.Nodup, l, List.Nodup, l] (during elaboration) for (∀ {α : Type u_1} {l : List α}, (Multiset.Nodup ↑l) ↔ (List.Nodup l))

(CategoryTheory.BundledHom.ParentProjection fun {α : Type u_1} (h : AddGroup α) ↦ SubNegMonoid.toAddMonoid)
typeclass instance problem is stuck, it is often due to metavariables
  SubNegMonoid ?m.41 ; identifiers [CategoryTheory.BundledHom.ParentProjection, α, u_1, h, AddGroup, α, SubNegMonoid.toAddMonoid] (during elaboration) for (CategoryTheory.BundledHom.ParentProjection fun {α : Type u_1} (h : AddGroup α) ↦ SubNegMonoid.toAddMonoid)

(∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering ι I M s} {U : (a : M) → Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : ι) ↦ U (SmoothBumpCovering.c s f i)) ↔
    (SmoothBumpCovering.IsSubordinate f U))
unknown universe level 'uH' ; identifiers [ι, uι, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, ι, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, ι, U, SmoothBumpCovering.c, s, f, i, SmoothBumpCovering.IsSubordinate, f, U] (during elaboration) for (∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering ι I M s} {U : (a : M) → Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : ι) ↦ U (SmoothBumpCovering.c s f i)) ↔
    (SmoothBumpCovering.IsSubordinate f U))

(∀ {α : Type u_2} {β : Type u_3} [inst : SMul α β] {f : Filter α} {g : Filter β} {t : Set β},
  (t ∈ f • g) ↔ (∃ (t₁ : Set α), ∃ (t₂ : Set β), (t₁ ∈ f) ∧ ((t₂ ∈ g) ∧ (t₁ • t₂ ⊆ t))))
failed to synthesize instance
  HSMul (Filter α) (Filter β) ?m.33 ; identifiers [α, u_2, β, u_3, inst, SMul, α, β, f, Filter, α, g, Filter, β, t, Set, β, t, f, g, t₁, Set, α, t₂, Set, β, t₁, f, t₂, g, t₁, t₂, t] (during elaboration) for (∀ {α : Type u_2} {β : Type u_3} [inst : SMul α β] {f : Filter α} {g : Filter β} {t : Set β},
  (t ∈ f • g) ↔ (∃ (t₁ : Set α), ∃ (t₂ : Set β), (t₁ ∈ f) ∧ ((t₂ ∈ g) ∧ (t₁ • t₂ ⊆ t))))

(∀ {A : Type u_1} [inst : AddZeroClass A] {a : AddSubmonoid A} {b : AddSubmonoid A},
  (↑{
            toFun :=
              ((fun (S : AddSubmonoid A) ↦
                {
                  toSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                      mul_mem' :=
                        (((fun {a : Multiplicative A} ↦
                          (_ :
                            ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                              (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                              ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                  one_mem' := (((AddSubmonoid.zero_mem' S))) })),
            invFun :=
              ((fun (S : Submonoid (Multiplicative A)) ↦
                {
                  toAddSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                      add_mem' :=
                        (((fun {a : A} ↦
                          (_ :
                            ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S) (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                              a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                  zero_mem' := (((Submonoid.one_mem' S))) })),
            left_inv :=
              (((fun (x : AddSubmonoid A) ↦
                (_ :
                  (fun (S : Submonoid (Multiplicative A)) ↦
                        {
                          toAddSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                              add_mem' :=
                                (((fun {a : A} ↦
                                  (_ :
                                    ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                      a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                          zero_mem' := (((Submonoid.one_mem' S))) })
                      ((fun (S : AddSubmonoid A) ↦
                          {
                            toSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                                mul_mem' :=
                                  (((fun {a : Multiplicative A} ↦
                                    (_ :
                                      ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                        ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                          AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                            one_mem' := (((AddSubmonoid.zero_mem' S))) })
                        x) =
                    x)))),
            right_inv :=
              (((fun (x : Submonoid (Multiplicative A)) ↦
                (_ :
                  (fun (S : AddSubmonoid A) ↦
                        {
                          toSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                              mul_mem' :=
                                (((fun {a : Multiplicative A} ↦
                                  (_ :
                                    ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                      ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                        AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                          one_mem' := (((AddSubmonoid.zero_mem' S))) })
                      ((fun (S : Submonoid (Multiplicative A)) ↦
                          {
                            toAddSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                                add_mem' :=
                                  (((fun {a : A} ↦
                                    (_ :
                                      ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                        a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                            zero_mem' := (((Submonoid.one_mem' S))) })
                        x) =
                    x)))) }
        a ≤
      ↑{
            toFun :=
              ((fun (S : AddSubmonoid A) ↦
                {
                  toSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                      mul_mem' :=
                        (((fun {a : Multiplicative A} ↦
                          (_ :
                            ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                              (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                              ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                  one_mem' := (((AddSubmonoid.zero_mem' S))) })),
            invFun :=
              ((fun (S : Submonoid (Multiplicative A)) ↦
                {
                  toAddSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                      add_mem' :=
                        (((fun {a : A} ↦
                          (_ :
                            ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S) (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                              a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                  zero_mem' := (((Submonoid.one_mem' S))) })),
            left_inv :=
              (((fun (x : AddSubmonoid A) ↦
                (_ :
                  (fun (S : Submonoid (Multiplicative A)) ↦
                        {
                          toAddSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                              add_mem' :=
                                (((fun {a : A} ↦
                                  (_ :
                                    ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                      a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                          zero_mem' := (((Submonoid.one_mem' S))) })
                      ((fun (S : AddSubmonoid A) ↦
                          {
                            toSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                                mul_mem' :=
                                  (((fun {a : Multiplicative A} ↦
                                    (_ :
                                      ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                        ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                          AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                            one_mem' := (((AddSubmonoid.zero_mem' S))) })
                        x) =
                    x)))),
            right_inv :=
              (((fun (x : Submonoid (Multiplicative A)) ↦
                (_ :
                  (fun (S : AddSubmonoid A) ↦
                        {
                          toSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                              mul_mem' :=
                                (((fun {a : Multiplicative A} ↦
                                  (_ :
                                    ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                      ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                        AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                          one_mem' := (((AddSubmonoid.zero_mem' S))) })
                      ((fun (S : Submonoid (Multiplicative A)) ↦
                          {
                            toAddSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                                add_mem' :=
                                  (((fun {a : A} ↦
                                    (_ :
                                      ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                        a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                            zero_mem' := (((Submonoid.one_mem' S))) })
                        x) =
                    x)))) }
        b) ↔
    (↑{
            toFun :=
              ((fun (S : AddSubmonoid A) ↦
                {
                  toSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                      mul_mem' :=
                        (((fun {a : Multiplicative A} ↦
                          (_ :
                            ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                              (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                              ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                  one_mem' := (((AddSubmonoid.zero_mem' S))) })),
            invFun :=
              ((fun (S : Submonoid (Multiplicative A)) ↦
                {
                  toAddSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                      add_mem' :=
                        (((fun {a : A} ↦
                          (_ :
                            ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S) (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                              a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                  zero_mem' := (((Submonoid.one_mem' S))) })),
            left_inv :=
              (((fun (x : AddSubmonoid A) ↦
                (_ :
                  (fun (S : Submonoid (Multiplicative A)) ↦
                        {
                          toAddSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                              add_mem' :=
                                (((fun {a : A} ↦
                                  (_ :
                                    ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                      a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                          zero_mem' := (((Submonoid.one_mem' S))) })
                      ((fun (S : AddSubmonoid A) ↦
                          {
                            toSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                                mul_mem' :=
                                  (((fun {a : Multiplicative A} ↦
                                    (_ :
                                      ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                        ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                          AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                            one_mem' := (((AddSubmonoid.zero_mem' S))) })
                        x) =
                    x)))),
            right_inv :=
              (((fun (x : Submonoid (Multiplicative A)) ↦
                (_ :
                  (fun (S : AddSubmonoid A) ↦
                        {
                          toSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                              mul_mem' :=
                                (((fun {a : Multiplicative A} ↦
                                  (_ :
                                    ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                      ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                        AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                          one_mem' := (((AddSubmonoid.zero_mem' S))) })
                      ((fun (S : Submonoid (Multiplicative A)) ↦
                          {
                            toAddSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                                add_mem' :=
                                  (((fun {a : A} ↦
                                    (_ :
                                      ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                        a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                            zero_mem' := (((Submonoid.one_mem' S))) })
                        x) =
                    x)))) }
        a ≤
      ↑{
            toFun :=
              ((fun (S : AddSubmonoid A) ↦
                {
                  toSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                      mul_mem' :=
                        (((fun {a : Multiplicative A} ↦
                          (_ :
                            ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                              (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                              ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                  one_mem' := (((AddSubmonoid.zero_mem' S))) })),
            invFun :=
              ((fun (S : Submonoid (Multiplicative A)) ↦
                {
                  toAddSubsemigroup :=
                    (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                      add_mem' :=
                        (((fun {a : A} ↦
                          (_ :
                            ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S) (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                              a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                  zero_mem' := (((Submonoid.one_mem' S))) })),
            left_inv :=
              (((fun (x : AddSubmonoid A) ↦
                (_ :
                  (fun (S : Submonoid (Multiplicative A)) ↦
                        {
                          toAddSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                              add_mem' :=
                                (((fun {a : A} ↦
                                  (_ :
                                    ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                      a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                          zero_mem' := (((Submonoid.one_mem' S))) })
                      ((fun (S : AddSubmonoid A) ↦
                          {
                            toSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                                mul_mem' :=
                                  (((fun {a : Multiplicative A} ↦
                                    (_ :
                                      ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                        ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                          AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                            one_mem' := (((AddSubmonoid.zero_mem' S))) })
                        x) =
                    x)))),
            right_inv :=
              (((fun (x : Submonoid (Multiplicative A)) ↦
                (_ :
                  (fun (S : AddSubmonoid A) ↦
                        {
                          toSubsemigroup :=
                            (({ carrier := ((↑Multiplicative.toAdd ⁻¹' ↑S)),
                              mul_mem' :=
                                (((fun {a : Multiplicative A} ↦
                                  (_ :
                                    ∀ {b : Multiplicative A} (ha : a ∈ ↑Multiplicative.toAdd ⁻¹' ↑S)
                                      (hb : b ∈ ↑Multiplicative.toAdd ⁻¹' ↑S),
                                      ↑Multiplicative.toAdd a + ↑Multiplicative.toAdd b ∈
                                        AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                          one_mem' := (((AddSubmonoid.zero_mem' S))) })
                      ((fun (S : Submonoid (Multiplicative A)) ↦
                          {
                            toAddSubsemigroup :=
                              (({ carrier := ((↑Multiplicative.ofAdd ⁻¹' ↑S)),
                                add_mem' :=
                                  (((fun {a : A} ↦
                                    (_ :
                                      ∀ {b : A} (ha : a ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S)
                                        (hb : b ∈ ↑Multiplicative.ofAdd ⁻¹' ↑S),
                                        a * b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                            zero_mem' := (((Submonoid.one_mem' S))) })
                        x) =
                    x)))) }
        b))
<input>:8:22: expected '}'

(∀ {G : Type u_1} [inst : Group G] {S : Type u_6} (H : S) [inst_1 : SetLike S G] [inst_2 : SubgroupClass S G],
  ↑↑H = Subtype.val)
type mismatch
  H
has type
  S : Type u_6
but is expected to have type
  Subtype (?m.164168 H) → ?m.164167 H : Sort (imax (max 1 ?u.147) ?u.147) ; identifiers [G, u_1, inst, Group, G, S, u_6, H, S, inst_1, SetLike, S, G, inst_2, SubgroupClass, S, G, H, Subtype.val] (during elaboration) for (∀ {G : Type u_1} [inst : Group G] {S : Type u_6} (H : S) [inst_1 : SetLike S G] [inst_2 : SubgroupClass S G],
  ↑↑H = Subtype.val)

(∀ {α : Type u_1} [inst : Preorder α] {a : ↑Set.univ} {b : ↑Set.univ},
  (↑(Equiv.Set.univ α) a ≤ ↑(Equiv.Set.univ α) b) ↔ (↑(Equiv.Set.univ α) a ≤ ↑(Equiv.Set.univ α) b))
type mismatch
  Set.univ
has type
  Set ?m.9 : Type ?u.8
but is expected to have type
  Sort ?u.7 : Type ?u.7 ; identifiers [α, u_1, inst, Preorder, α, a, Set.univ, b, Set.univ, Equiv.Set.univ, α, a, Equiv.Set.univ, α, b, Equiv.Set.univ, α, a, Equiv.Set.univ, α, b] (during elaboration) for (∀ {α : Type u_1} [inst : Preorder α] {a : ↑Set.univ} {b : ↑Set.univ},
  (↑(Equiv.Set.univ α) a ≤ ↑(Equiv.Set.univ α) b) ↔ (↑(Equiv.Set.univ α) a ≤ ↑(Equiv.Set.univ α) b))

(∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] [inst_1 : SizeOf J],
  sizeOf CategoryTheory.BiconeHom.left_id = 1)
unknown universe level 'v₁' ; identifiers [J, u₁, inst, CategoryTheory.Category, v₁, u₁, J, inst_1, SizeOf, J, sizeOf, CategoryTheory.BiconeHom.left_id] (during elaboration) for (∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] [inst_1 : SizeOf J],
  sizeOf CategoryTheory.BiconeHom.left_id = 1)

(∀ {R : Type u} [inst : Ring R] {J : Type w} [inst_1 : CategoryTheory.Category.{v, w} J]
  {F : CategoryTheory.Functor J (ModuleCat R)} [inst_2 : SizeOf R] [inst_3 : SizeOf J],
  sizeOf ModuleCat.Colimits.Prequotient.zero = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (ModuleCat.Colimits.Prequotient ?m.13886) ; identifiers [R, u, inst, Ring, R, J, w, inst_1, CategoryTheory.Category, v, w, J, F, CategoryTheory.Functor, J, ModuleCat, R, inst_2, SizeOf, R, inst_3, SizeOf, J, sizeOf, ModuleCat.Colimits.Prequotient.zero] (during elaboration) for (∀ {R : Type u} [inst : Ring R] {J : Type w} [inst_1 : CategoryTheory.Category.{v, w} J]
  {F : CategoryTheory.Functor J (ModuleCat R)} [inst_2 : SizeOf R] [inst_3 : SizeOf J],
  sizeOf ModuleCat.Colimits.Prequotient.zero = 1)

(∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [inst : Semiring R] [inst_1 : Semiring R₂]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}
  {F : Type u_20} [sc : SemilinearMapClass F τ₁₂ M M₂] [inst_6 : RingHomSurjective τ₁₂] {f : F} {x : M₂},
  (x ∈ LinearMap.range f) ↔ (∃ (y : M), ↑f y = x))
unknown universe level 'u_12' ; identifiers [R, u_1, R₂, u_3, M, u_9, M₂, u_12, inst, Semiring, R, inst_1, Semiring, R₂, inst_2, AddCommMonoid, M, inst_3, AddCommMonoid, M₂, inst_4, Module, R, M, inst_5, Module, R₂, M₂, τ₁₂, R, R₂, F, u_20, sc, SemilinearMapClass, F, τ₁₂, M, M₂, inst_6, RingHomSurjective, τ₁₂, f, F, x, M₂, x, LinearMap.range, f, y, M, f, y, x] (during elaboration) for (∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [inst : Semiring R] [inst_1 : Semiring R₂]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}
  {F : Type u_20} [sc : SemilinearMapClass F τ₁₂ M M₂] [inst_6 : RingHomSurjective τ₁₂] {f : F} {x : M₂},
  (x ∈ LinearMap.range f) ↔ (∃ (y : M), ↑f y = x))

(∀ {α : Type u} [inst : SizeOf α], sizeOf none = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (Option ?m.6881) ; identifiers [α, u, inst, SizeOf, α, sizeOf, none] (during elaboration) for (∀ {α : Type u} [inst : SizeOf α], sizeOf none = 1)

(∀ {M : Type u_1} [hM : MonoidWithZero M] (h : ∀ (a : M), (IsUnit a) ∨ (a = 0)) (a : M) (b : M), a / b = a / b)
failed to synthesize instance
  HDiv M M ?m.779 ; identifiers [M, u_1, hM, MonoidWithZero, M, h, a, M, IsUnit, a, a, a, M, b, M, a, b, a, b] (during elaboration) for (∀ {M : Type u_1} [hM : MonoidWithZero M] (h : ∀ (a : M), (IsUnit a) ∨ (a = 0)) (a : M) (b : M), a / b = a / b)

(∀ {α : Type u} [inst : SizeOf α], sizeOf LazyList.nil = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (LazyList ?m.6881) ; identifiers [α, u, inst, SizeOf, α, sizeOf, LazyList.nil] (during elaboration) for (∀ {α : Type u} [inst : SizeOf α], sizeOf LazyList.nil = 1)

(∀ {X : TopCat} {x : ↑X} {y : ↑X} (e : Inseparable x y), nhds y ≤ nhds x)
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, y, X, e, Inseparable, x, y, nhds, y, nhds, x] (during elaboration) for (∀ {X : TopCat} {x : ↑X} {y : ↑X} (e : Inseparable x y), nhds y ≤ nhds x)

(∀ {K : Type u_1} {Γ : (a : K) → Type u_2} {Λ : Type u_3} {σ : Type u_4} [inst : SizeOf K]
  [inst_1 : (a : K) → SizeOf (Γ a)] [inst_2 : SizeOf Λ] [inst_3 : SizeOf σ] (a : (a : σ) → Λ),
  sizeOf (Turing.TM2.Stmt.goto a) = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (Turing.TM2.Stmt (?m.6994 a) Λ σ) ; identifiers [K, u_1, Γ, a, K, u_2, Λ, u_3, σ, u_4, inst, SizeOf, K, inst_1, a, K, SizeOf, Γ, a, inst_2, SizeOf, Λ, inst_3, SizeOf, σ, a, a, σ, Λ, sizeOf, Turing.TM2.Stmt.goto, a] (during elaboration) for (∀ {K : Type u_1} {Γ : (a : K) → Type u_2} {Λ : Type u_3} {σ : Type u_4} [inst : SizeOf K]
  [inst_1 : (a : K) → SizeOf (Γ a)] [inst_2 : SizeOf Λ] [inst_3 : SizeOf σ] (a : (a : σ) → Λ),
  sizeOf (Turing.TM2.Stmt.goto a) = 1)

(∀ {α : Type u_2} {β : Type u_3} [inst : SMul α β] {t : Set β} {a : α} {x : β},
  (x ∈ a • t) ↔ (∃ (y : β), (y ∈ t) ∧ (a • y = x)))
failed to synthesize instance
  HSMul α (Set β) ?m.29 ; identifiers [α, u_2, β, u_3, inst, SMul, α, β, t, Set, β, a, α, x, β, x, a, t, y, β, y, t, a, y, x] (during elaboration) for (∀ {α : Type u_2} {β : Type u_3} [inst : SMul α β] {t : Set β} {a : α} {x : β},
  (x ∈ a • t) ↔ (∃ (y : β), (y ∈ t) ∧ (a • y = x)))

(∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : NonUnitalSemiring A]
  [inst_3 : StarRing A] [inst_4 : Module R A] [inst_5 : IsScalarTower R A A] [inst_6 : SMulCommClass R A A]
  [inst_7 : StarModule R A], Monotone star)
typeclass instance problem is stuck, it is often due to metavariables
  Preorder ?m.10739 ; identifiers [R, u, A, v, inst, CommSemiring, R, inst_1, StarRing, R, inst_2, NonUnitalSemiring, A, inst_3, StarRing, A, inst_4, Module, R, A, inst_5, IsScalarTower, R, A, A, inst_6, SMulCommClass, R, A, A, inst_7, StarModule, R, A, Monotone, star] (during elaboration) for (∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : NonUnitalSemiring A]
  [inst_3 : StarRing A] [inst_4 : Module R A] [inst_5 : IsScalarTower R A A] [inst_6 : SMulCommClass R A A]
  [inst_7 : StarModule R A], Monotone star)

(∀ {α : Type u_1} [inst : AddGroup α] {s : AddSubgroup α} {t : AddSubgroup α} (h : s = t) (_a : α) (_b : α)
  (h' : Setoid.r _a _b), Setoid.r (id _a) (id _b))
failed to synthesize instance
  Setoid α ; identifiers [α, u_1, inst, AddGroup, α, s, AddSubgroup, α, t, AddSubgroup, α, h, s, t, _a, α, _b, α, h', Setoid.r, _a, _b, Setoid.r, id, _a, id, _b] (during elaboration) for (∀ {α : Type u_1} [inst : AddGroup α] {s : AddSubgroup α} {t : AddSubgroup α} (h : s = t) (_a : α) (_b : α)
  (h' : Setoid.r _a _b), Setoid.r (id _a) (id _b))

(∀ {α : Type u_1} [inst : Preorder α] (S : Set α),
  (IsOpen (↑WithLowerTopology.ofLower ⁻¹' S)) ↔ (TopologicalSpace.IsOpen S))
failed to synthesize instance
  TopologicalSpace α ; identifiers [α, u_1, inst, Preorder, α, S, Set, α, IsOpen, WithLowerTopology.ofLower, S, TopologicalSpace.IsOpen, S] (during elaboration) for (∀ {α : Type u_1} [inst : Preorder α] (S : Set α),
  (IsOpen (↑WithLowerTopology.ofLower ⁻¹' S)) ↔ (TopologicalSpace.IsOpen S))

(∀ {C : Type u} [inst : SizeOf C], sizeOf CategoryTheory.WithInitial.star = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (CategoryTheory.WithInitial ?m.6906) ; identifiers [C, u, inst, SizeOf, C, sizeOf, CategoryTheory.WithInitial.star] (during elaboration) for (∀ {C : Type u} [inst : SizeOf C], sizeOf CategoryTheory.WithInitial.star = 1)

(∀ {ι : Type u_1} {R : Type u_3} {A : Type u_5} {x : (a : ι) → A} [inst : CommRing R] [inst_1 : CommRing A]
  [inst_2 : Algebra R A], (AlgebraicIndependent R x) ↔ (Function.Injective ↑(MvPolynomial.aeval x)))
type mismatch
  MvPolynomial.aeval x
has type
  MvPolynomial ι ?m.461 →ₐ[?m.461] A : Type (max (max u_1 ?u.459) u_5)
but is expected to have type
  ?m.3447 → ?m.3448 : Sort (imax ?u.455 ?u.454) ; identifiers [ι, u_1, R, u_3, A, u_5, x, a, ι, A, inst, CommRing, R, inst_1, CommRing, A, inst_2, Algebra, R, A, AlgebraicIndependent, R, x, Function.Injective, MvPolynomial.aeval, x] (during elaboration) for (∀ {ι : Type u_1} {R : Type u_3} {A : Type u_5} {x : (a : ι) → A} [inst : CommRing R] [inst_1 : CommRing A]
  [inst_2 : Algebra R A], (AlgebraicIndependent R x) ↔ (Function.Injective ↑(MvPolynomial.aeval x)))

(∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering ι I M s} {U : (a : M) → Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : ι) ↦ U (SmoothBumpCovering.c s f i)) ↔
    (SmoothBumpCovering.IsSubordinate f U))
unknown universe level 'uH' ; identifiers [ι, uι, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, ι, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, ι, U, SmoothBumpCovering.c, s, f, i, SmoothBumpCovering.IsSubordinate, f, U] (during elaboration) for (∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering ι I M s} {U : (a : M) → Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : ι) ↦ U (SmoothBumpCovering.c s f i)) ↔
    (SmoothBumpCovering.IsSubordinate f U))

(∀ {α : Type u_1} {β : Type u_2} {l : Filter α} {f : (a : α) → β} {lb : Filter β},
  (Filter.Germ.Tendsto (↑f) lb) ↔ (Filter.Tendsto f l lb))
type mismatch
  f
has type
  α → β : Type (max u_1 u_2)
but is expected to have type
  Filter.Germ ?m.120 β : Type (max ?u.18 u_2) ; identifiers [α, u_1, β, u_2, l, Filter, α, f, a, α, β, lb, Filter, β, Filter.Germ.Tendsto, f, lb, Filter.Tendsto, f, l, lb] (during elaboration) for (∀ {α : Type u_1} {β : Type u_2} {l : Filter α} {f : (a : α) → β} {lb : Filter β},
  (Filter.Germ.Tendsto (↑f) lb) ↔ (Filter.Tendsto f l lb))

(∀ {α : Type u_1} {E : Type u_3} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {f : (a : α) → E}
  {s : Set α} {μ : MeasureTheory.Measure α} (h : MeasureTheory.IntegrableOn f s), MeasureTheory.Integrable f)
typeclass instance problem is stuck, it is often due to metavariables
  MeasureTheory.MeasureSpace ?m.218 ; identifiers [α, u_1, E, u_3, inst, MeasurableSpace, α, inst_1, NormedAddCommGroup, E, f, a, α, E, s, Set, α, μ, MeasureTheory.Measure, α, h, MeasureTheory.IntegrableOn, f, s, MeasureTheory.Integrable, f] (during elaboration) for (∀ {α : Type u_1} {E : Type u_3} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {f : (a : α) → E}
  {s : Set α} {μ : MeasureTheory.Measure α} (h : MeasureTheory.IntegrableOn f s), MeasureTheory.Integrable f)

(∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [inst : Semiring R] [inst_1 : Semiring R₂]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}
  {F : Type u_20} [sc : SemilinearMapClass F τ₁₂ M M₂] {f : F} {g : F} {S : Submodule R M},
  (S ≤ LinearMap.eqLocus f g) ↔ (Set.EqOn ↑f ↑g ↑S))
unknown universe level 'u_12' ; identifiers [R, u_1, R₂, u_3, M, u_9, M₂, u_12, inst, Semiring, R, inst_1, Semiring, R₂, inst_2, AddCommMonoid, M, inst_3, AddCommMonoid, M₂, inst_4, Module, R, M, inst_5, Module, R₂, M₂, τ₁₂, R, R₂, F, u_20, sc, SemilinearMapClass, F, τ₁₂, M, M₂, f, F, g, F, S, Submodule, R, M, S, LinearMap.eqLocus, f, g, Set.EqOn, f, g, S] (during elaboration) for (∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [inst : Semiring R] [inst_1 : Semiring R₂]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}
  {F : Type u_20} [sc : SemilinearMapClass F τ₁₂ M M₂] {f : F} {g : F} {S : Submodule R M},
  (S ≤ LinearMap.eqLocus f g) ↔ (Set.EqOn ↑f ↑g ↑S))

(∀ {α : Type u_2} [inst : TopologicalSpace α] {U : TopologicalSpace.Opens α}, (Set.Nonempty ↑U) ↔ (∃ (x : α), x ∈ U))
type mismatch
  U
has type
  TopologicalSpace.Opens α : Type u_2
but is expected to have type
  Set ?m.139 : Type ?u.19 ; identifiers [α, u_2, inst, TopologicalSpace, α, U, TopologicalSpace.Opens, α, Set.Nonempty, U, x, α, x, U] (during elaboration) for (∀ {α : Type u_2} [inst : TopologicalSpace α] {U : TopologicalSpace.Opens α}, (Set.Nonempty ↑U) ↔ (∃ (x : α), x ∈ U))

(∀ {R : Type u_1} {R₁ : Type u_2} {M₁ : Type u_6} {n : Type u_18} [inst : CommSemiring R] [inst_1 : CommSemiring R₁]
  [inst_2 : AddCommMonoid M₁] [inst_3 : Module R₁ M₁] {I₁ : R₁ →+* R} {I₁' : R₁ →+* R} {B : M₁ →ₛₗ[I₁] M₁ →ₛₗ[I₁'] R}
  {v : (a : n) → M₁}, (LinearMap.IsOrthoᵢ B v) ↔ (∀ (i : n) (j : n) (a : i ≠ j), ↑(↑B (v i)) (v j) = 0))
unknown universe level 'u_18' ; identifiers [R, u_1, R₁, u_2, M₁, u_6, n, u_18, inst, CommSemiring, R, inst_1, CommSemiring, R₁, inst_2, AddCommMonoid, M₁, inst_3, Module, R₁, M₁, I₁, R₁, R, I₁', R₁, R, B, M₁, I₁, M₁, I₁', R, v, a, n, M₁, LinearMap.IsOrthoᵢ, B, v, i, n, j, n, a, i, j, B, v, i, v, j] (during elaboration) for (∀ {R : Type u_1} {R₁ : Type u_2} {M₁ : Type u_6} {n : Type u_18} [inst : CommSemiring R] [inst_1 : CommSemiring R₁]
  [inst_2 : AddCommMonoid M₁] [inst_3 : Module R₁ M₁] {I₁ : R₁ →+* R} {I₁' : R₁ →+* R} {B : M₁ →ₛₗ[I₁] M₁ →ₛₗ[I₁'] R}
  {v : (a : n) → M₁}, (LinearMap.IsOrthoᵢ B v) ↔ (∀ (i : n) (j : n) (a : i ≠ j), ↑(↑B (v i)) (v j) = 0))

(∀ {M : Type u_1} [inst : Add M] (U : Ultrafilter M) (V : Ultrafilter M) (p : (a : M) → Prop),
  (∀ᶠ (m : M) in ↑(U + V), p m) ↔ (∀ᶠ (m : M) in ↑U, ∀ᶠ (m' : M) in ↑V, p (m + m')))
failed to synthesize instance
  HAdd (Ultrafilter M) (Ultrafilter M) ?m.1575 ; identifiers [M, u_1, inst, Add, M, U, Ultrafilter, M, V, Ultrafilter, M, p, a, M, m, M, U, V, p, m, m, M, U, m', M, V, p, m, m'] (during elaboration) for (∀ {M : Type u_1} [inst : Add M] (U : Ultrafilter M) (V : Ultrafilter M) (p : (a : M) → Prop),
  (∀ᶠ (m : M) in ↑(U + V), p m) ↔ (∀ᶠ (m : M) in ↑U, ∀ᶠ (m' : M) in ↑V, p (m + m')))

(∀ {B : Type u₁} [inst : CategoryTheory.Bicategory B] {C : Type u₂} [inst_1 : CategoryTheory.Bicategory C]
  {F : CategoryTheory.OplaxFunctor B C} {G : CategoryTheory.OplaxFunctor B C} {η : F ⟶ G} {θ : F ⟶ G}
  [inst_2 : SizeOf B] [inst_3 : SizeOf C] (app : (a : B) → η.app a ⟶ θ.app a)
  (naturality :
    autoParam
      (∀ {a : B} {b : B} (f : a ⟶ b),
        CategoryTheory.CategoryStruct.comp
            (CategoryTheory.Bicategory.whiskerLeft ((↑(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map f) (app b))
            (CategoryTheory.OplaxNatTrans.naturality θ f) =
          CategoryTheory.CategoryStruct.comp (CategoryTheory.OplaxNatTrans.naturality η f)
            (CategoryTheory.Bicategory.whiskerRight (app a) ((↑(CategoryTheory.OplaxFunctor.toPrelaxFunctor G)).map f)))
      _auto✝),
  sizeOf (CategoryTheory.OplaxNatTrans.Modification.mk app) = 1)
<input>:12:11: expected token

(∀ {J : Type u₁} [inst : SizeOf J], sizeOf CategoryTheory.Bicone.left = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (CategoryTheory.Bicone ?m.6906) ; identifiers [J, u₁, inst, SizeOf, J, sizeOf, CategoryTheory.Bicone.left] (during elaboration) for (∀ {J : Type u₁} [inst : SizeOf J], sizeOf CategoryTheory.Bicone.left = 1)

(∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X : C} {R : CategoryTheory.Sieve X}
  {S : CategoryTheory.Sieve X} {Y : C} (f : Y ⟶ X), ((R ⊓ S).arrows f) ↔ ((R.arrows f) ∧ (S.arrows f)))
unknown universe level 'v₁' ; identifiers [C, u₁, inst, CategoryTheory.Category, v₁, u₁, C, X, C, R, CategoryTheory.Sieve, X, S, CategoryTheory.Sieve, X, Y, C, f, Y, X, R, S, arrows, f, R.arrows, f, S.arrows, f] (during elaboration) for (∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X : C} {R : CategoryTheory.Sieve X}
  {S : CategoryTheory.Sieve X} {Y : C} (f : Y ⟶ X), ((R ⊓ S).arrows f) ↔ ((R.arrows f) ∧ (S.arrows f)))

(∀ (A : Type u_1) [inst : CommRing A] (K : Type u_2) [inst_1 : Field K] [inst_2 : Algebra A K]
  (a : ValuationRing.ValueGroup A K) (b : ValuationRing.ValueGroup A K), (a < b) ↔ (a < b))
failed to synthesize instance
  LT (ValuationRing.ValueGroup A K) ; identifiers [A, u_1, inst, CommRing, A, K, u_2, inst_1, Field, K, inst_2, Algebra, A, K, a, ValuationRing.ValueGroup, A, K, b, ValuationRing.ValueGroup, A, K, a, b, a, b] (during elaboration) for (∀ (A : Type u_1) [inst : CommRing A] (K : Type u_2) [inst_1 : Field K] [inst_2 : Algebra A K]
  (a : ValuationRing.ValueGroup A K) (b : ValuationRing.ValueGroup A K), (a < b) ↔ (a < b))

(∀ {z : ℂ} {w : ℂ}, (z ≤ w) ↔ ((Complex.re z ≤ Complex.re w) ∧ (Complex.im z = Complex.im w)))
failed to synthesize instance
  LE ℂ ; identifiers [z, w, z, w, Complex.re, z, Complex.re, w, Complex.im, z, Complex.im, w] (during elaboration) for (∀ {z : ℂ} {w : ℂ}, (z ≤ w) ↔ ((Complex.re z ≤ Complex.re w) ∧ (Complex.im z = Complex.im w)))

(∀ {K : Type u_1} {Γ : (a : K) → Type u_2} {Λ : Type u_3} {σ : Type u_4} [inst : SizeOf K]
  [inst_1 : (a : K) → SizeOf (Γ a)] [inst_2 : SizeOf Λ] [inst_3 : SizeOf σ] (a : (a : σ) → Λ),
  sizeOf (Turing.TM2.Stmt.goto a) = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (Turing.TM2.Stmt (?m.7019 a) Λ σ) ; identifiers [K, u_1, Γ, a, K, u_2, Λ, u_3, σ, u_4, inst, SizeOf, K, inst_1, a, K, SizeOf, Γ, a, inst_2, SizeOf, Λ, inst_3, SizeOf, σ, a, a, σ, Λ, sizeOf, Turing.TM2.Stmt.goto, a] (during elaboration) for (∀ {K : Type u_1} {Γ : (a : K) → Type u_2} {Λ : Type u_3} {σ : Type u_4} [inst : SizeOf K]
  [inst_1 : (a : K) → SizeOf (Γ a)] [inst_2 : SizeOf Λ] [inst_3 : SizeOf σ] (a : (a : σ) → Λ),
  sizeOf (Turing.TM2.Stmt.goto a) = 1)

(∀ {z : ℂ} {w : ℂ}, (z < w) ↔ ((Complex.re z < Complex.re w) ∧ (Complex.im z = Complex.im w)))
failed to synthesize instance
  LT ℂ ; identifiers [z, w, z, w, Complex.re, z, Complex.re, w, Complex.im, z, Complex.im, w] (during elaboration) for (∀ {z : ℂ} {w : ℂ}, (z < w) ↔ ((Complex.re z < Complex.re w) ∧ (Complex.im z = Complex.im w)))

(∀ (X : CommRingCat) (x : ↑X) (y : ↑X), 1 = 1)
type mismatch
  X
has type
  CommRingCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, CommRingCat, x, X, y, X] (during elaboration) for (∀ (X : CommRingCat) (x : ↑X) (y : ↑X), 1 = 1)

(∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X : C} {R : CategoryTheory.Sieve X}
  {S : CategoryTheory.Sieve X} {Y : C} (f : Y ⟶ X), ((R ⊔ S).arrows f) ↔ ((R.arrows f) ∨ (S.arrows f)))
unknown universe level 'v₁' ; identifiers [C, u₁, inst, CategoryTheory.Category, v₁, u₁, C, X, C, R, CategoryTheory.Sieve, X, S, CategoryTheory.Sieve, X, Y, C, f, Y, X, R, S, arrows, f, R.arrows, f, S.arrows, f] (during elaboration) for (∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X : C} {R : CategoryTheory.Sieve X}
  {S : CategoryTheory.Sieve X} {Y : C} (f : Y ⟶ X), ((R ⊔ S).arrows f) ↔ ((R.arrows f) ∨ (S.arrows f)))

(∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : NonUnitalSemiring A]
  [inst_3 : StarRing A] [inst_4 : Module R A] [inst_5 : IsScalarTower R A A] [inst_6 : SMulCommClass R A A]
  [inst_7 : StarModule R A], Monotone star)
typeclass instance problem is stuck, it is often due to metavariables
  Preorder ?m.10745 ; identifiers [R, u, A, v, inst, CommSemiring, R, inst_1, StarRing, R, inst_2, NonUnitalSemiring, A, inst_3, StarRing, A, inst_4, Module, R, A, inst_5, IsScalarTower, R, A, A, inst_6, SMulCommClass, R, A, A, inst_7, StarModule, R, A, Monotone, star] (during elaboration) for (∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : NonUnitalSemiring A]
  [inst_3 : StarRing A] [inst_4 : Module R A] [inst_5 : IsScalarTower R A A] [inst_6 : SMulCommClass R A A]
  [inst_7 : StarModule R A], Monotone star)

(∀ {α : Type u_1} {β : Type u_2} {σ : Type u_3} [inst : Primcodable α] [inst_1 : Primcodable β] [inst_2 : Primcodable σ]
  {f : (a : α) → (a : β) → σ} (hf : Computable₂ f), Partrec₂ fun (a : α) ↦ ↑(f a))
typeclass instance problem is stuck, it is often due to metavariables
  Primcodable (?m.287 hf) ; identifiers [α, u_1, β, u_2, σ, u_3, inst, Primcodable, α, inst_1, Primcodable, β, inst_2, Primcodable, σ, f, a, α, a, β, σ, hf, Computable₂, f, Partrec₂, a, α, f, a] (during elaboration) for (∀ {α : Type u_1} {β : Type u_2} {σ : Type u_3} [inst : Primcodable α] [inst_1 : Primcodable β] [inst_2 : Primcodable σ]
  {f : (a : α) → (a : β) → σ} (hf : Computable₂ f), Partrec₂ fun (a : α) ↦ ↑(f a))

(∀ {K : Type u_1} [inst : Field K] [inst_1 : UniformSpace K] [inst_2 : TopologicalDivisionRing K]
  [inst_3 : UniformAddGroup K] (a : UniformSpace.Completion K) (b : UniformSpace.Completion K), a / b = a / b)
failed to synthesize instance
  HDiv (UniformSpace.Completion K) (UniformSpace.Completion K) ?m.994 ; identifiers [K, u_1, inst, Field, K, inst_1, UniformSpace, K, inst_2, TopologicalDivisionRing, K, inst_3, UniformAddGroup, K, a, UniformSpace.Completion, K, b, UniformSpace.Completion, K, a, b, a, b] (during elaboration) for (∀ {K : Type u_1} [inst : Field K] [inst_1 : UniformSpace K] [inst_2 : TopologicalDivisionRing K]
  [inst_3 : UniformAddGroup K] (a : UniformSpace.Completion K) (b : UniformSpace.Completion K), a / b = a / b)

(∀ {α : Type ua} {a : α} {b : α}, ((a, b) ∈ idRel) ↔ (a = b))
unknown universe level 'ua' ; identifiers [α, ua, a, α, b, α, a, b, idRel, a, b] (during elaboration) for (∀ {α : Type ua} {a : α} {b : α}, ((a, b) ∈ idRel) ↔ (a = b))

(∀ {α : Type u} [inst : SizeOf α], sizeOf Lists'.nil = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (Lists' ?m.6912 true) ; identifiers [α, u, inst, SizeOf, α, sizeOf, Lists'.nil] (during elaboration) for (∀ {α : Type u} [inst : SizeOf α], sizeOf Lists'.nil = 1)

(∀ {α : Type u_1} [inst : AddGroup α] {s : AddSubgroup α} {t : AddSubgroup α} (h : s = t) (_a : α) (_b : α)
  (h' : Setoid.r _a _b), Setoid.r (id _a) (id _b))
failed to synthesize instance
  Setoid α ; identifiers [α, u_1, inst, AddGroup, α, s, AddSubgroup, α, t, AddSubgroup, α, h, s, t, _a, α, _b, α, h', Setoid.r, _a, _b, Setoid.r, id, _a, id, _b] (during elaboration) for (∀ {α : Type u_1} [inst : AddGroup α] {s : AddSubgroup α} {t : AddSubgroup α} (h : s = t) (_a : α) (_b : α)
  (h' : Setoid.r _a _b), Setoid.r (id _a) (id _b))

(∀ {α : Type u_1} [inst : Preorder α] (S : Set α),
  (IsOpen (↑WithLowerTopology.ofLower ⁻¹' S)) ↔ (TopologicalSpace.IsOpen S))
failed to synthesize instance
  TopologicalSpace α ; identifiers [α, u_1, inst, Preorder, α, S, Set, α, IsOpen, WithLowerTopology.ofLower, S, TopologicalSpace.IsOpen, S] (during elaboration) for (∀ {α : Type u_1} [inst : Preorder α] (S : Set α),
  (IsOpen (↑WithLowerTopology.ofLower ⁻¹' S)) ↔ (TopologicalSpace.IsOpen S))

(∀ {C : Type u} [inst : SizeOf C], sizeOf CategoryTheory.WithInitial.star = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (CategoryTheory.WithInitial ?m.6906) ; identifiers [C, u, inst, SizeOf, C, sizeOf, CategoryTheory.WithInitial.star] (during elaboration) for (∀ {C : Type u} [inst : SizeOf C], sizeOf CategoryTheory.WithInitial.star = 1)

(∀ {ι : Type u_1} {R : Type u_3} {A : Type u_5} {x : (a : ι) → A} [inst : CommRing R] [inst_1 : CommRing A]
  [inst_2 : Algebra R A], (AlgebraicIndependent R x) ↔ (Function.Injective ↑(MvPolynomial.aeval x)))
type mismatch
  MvPolynomial.aeval x
has type
  MvPolynomial ι ?m.461 →ₐ[?m.461] A : Type (max (max u_1 ?u.459) u_5)
but is expected to have type
  ?m.3447 → ?m.3448 : Sort (imax ?u.455 ?u.454) ; identifiers [ι, u_1, R, u_3, A, u_5, x, a, ι, A, inst, CommRing, R, inst_1, CommRing, A, inst_2, Algebra, R, A, AlgebraicIndependent, R, x, Function.Injective, MvPolynomial.aeval, x] (during elaboration) for (∀ {ι : Type u_1} {R : Type u_3} {A : Type u_5} {x : (a : ι) → A} [inst : CommRing R] [inst_1 : CommRing A]
  [inst_2 : Algebra R A], (AlgebraicIndependent R x) ↔ (Function.Injective ↑(MvPolynomial.aeval x)))

(∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering ι I M s} {U : (a : M) → Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : ι) ↦ U (SmoothBumpCovering.c s f i)) ↔
    (SmoothBumpCovering.IsSubordinate f U))
unknown universe level 'uH' ; identifiers [ι, uι, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, ι, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, ι, U, SmoothBumpCovering.c, s, f, i, SmoothBumpCovering.IsSubordinate, f, U] (during elaboration) for (∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering ι I M s} {U : (a : M) → Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : ι) ↦ U (SmoothBumpCovering.c s f i)) ↔
    (SmoothBumpCovering.IsSubordinate f U))

(∀ {α : Type u_1} {β : Type u_2} {l : Filter α} {f : (a : α) → β} {lb : Filter β},
  (Filter.Germ.Tendsto (↑f) lb) ↔ (Filter.Tendsto f l lb))
type mismatch
  f
has type
  α → β : Type (max u_1 u_2)
but is expected to have type
  Filter.Germ ?m.120 β : Type (max ?u.18 u_2) ; identifiers [α, u_1, β, u_2, l, Filter, α, f, a, α, β, lb, Filter, β, Filter.Germ.Tendsto, f, lb, Filter.Tendsto, f, l, lb] (during elaboration) for (∀ {α : Type u_1} {β : Type u_2} {l : Filter α} {f : (a : α) → β} {lb : Filter β},
  (Filter.Germ.Tendsto (↑f) lb) ↔ (Filter.Tendsto f l lb))

(∀ {α : Type u_1} {E : Type u_3} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {f : (a : α) → E}
  {s : Set α} {μ : MeasureTheory.Measure α} (h : MeasureTheory.IntegrableOn f s), MeasureTheory.Integrable f)
typeclass instance problem is stuck, it is often due to metavariables
  MeasureTheory.MeasureSpace ?m.218 ; identifiers [α, u_1, E, u_3, inst, MeasurableSpace, α, inst_1, NormedAddCommGroup, E, f, a, α, E, s, Set, α, μ, MeasureTheory.Measure, α, h, MeasureTheory.IntegrableOn, f, s, MeasureTheory.Integrable, f] (during elaboration) for (∀ {α : Type u_1} {E : Type u_3} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {f : (a : α) → E}
  {s : Set α} {μ : MeasureTheory.Measure α} (h : MeasureTheory.IntegrableOn f s), MeasureTheory.Integrable f)

(∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [inst : Semiring R] [inst_1 : Semiring R₂]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}
  {F : Type u_20} [sc : SemilinearMapClass F τ₁₂ M M₂] {f : F} {g : F} {S : Submodule R M},
  (S ≤ LinearMap.eqLocus f g) ↔ (Set.EqOn ↑f ↑g ↑S))
unknown universe level 'u_12' ; identifiers [R, u_1, R₂, u_3, M, u_9, M₂, u_12, inst, Semiring, R, inst_1, Semiring, R₂, inst_2, AddCommMonoid, M, inst_3, AddCommMonoid, M₂, inst_4, Module, R, M, inst_5, Module, R₂, M₂, τ₁₂, R, R₂, F, u_20, sc, SemilinearMapClass, F, τ₁₂, M, M₂, f, F, g, F, S, Submodule, R, M, S, LinearMap.eqLocus, f, g, Set.EqOn, f, g, S] (during elaboration) for (∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [inst : Semiring R] [inst_1 : Semiring R₂]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}
  {F : Type u_20} [sc : SemilinearMapClass F τ₁₂ M M₂] {f : F} {g : F} {S : Submodule R M},
  (S ≤ LinearMap.eqLocus f g) ↔ (Set.EqOn ↑f ↑g ↑S))

(∀ {α : Type u_2} [inst : TopologicalSpace α] {U : TopologicalSpace.Opens α}, (Set.Nonempty ↑U) ↔ (∃ (x : α), x ∈ U))
type mismatch
  U
has type
  TopologicalSpace.Opens α : Type u_2
but is expected to have type
  Set ?m.139 : Type ?u.19 ; identifiers [α, u_2, inst, TopologicalSpace, α, U, TopologicalSpace.Opens, α, Set.Nonempty, U, x, α, x, U] (during elaboration) for (∀ {α : Type u_2} [inst : TopologicalSpace α] {U : TopologicalSpace.Opens α}, (Set.Nonempty ↑U) ↔ (∃ (x : α), x ∈ U))

(∀ {R : Type u_1} {R₁ : Type u_2} {M₁ : Type u_6} {n : Type u_18} [inst : CommSemiring R] [inst_1 : CommSemiring R₁]
  [inst_2 : AddCommMonoid M₁] [inst_3 : Module R₁ M₁] {I₁ : R₁ →+* R} {I₁' : R₁ →+* R} {B : M₁ →ₛₗ[I₁] M₁ →ₛₗ[I₁'] R}
  {v : (a : n) → M₁}, (LinearMap.IsOrthoᵢ B v) ↔ (∀ (i : n) (j : n) (a : i ≠ j), ↑(↑B (v i)) (v j) = 0))
unknown universe level 'u_18' ; identifiers [R, u_1, R₁, u_2, M₁, u_6, n, u_18, inst, CommSemiring, R, inst_1, CommSemiring, R₁, inst_2, AddCommMonoid, M₁, inst_3, Module, R₁, M₁, I₁, R₁, R, I₁', R₁, R, B, M₁, I₁, M₁, I₁', R, v, a, n, M₁, LinearMap.IsOrthoᵢ, B, v, i, n, j, n, a, i, j, B, v, i, v, j] (during elaboration) for (∀ {R : Type u_1} {R₁ : Type u_2} {M₁ : Type u_6} {n : Type u_18} [inst : CommSemiring R] [inst_1 : CommSemiring R₁]
  [inst_2 : AddCommMonoid M₁] [inst_3 : Module R₁ M₁] {I₁ : R₁ →+* R} {I₁' : R₁ →+* R} {B : M₁ →ₛₗ[I₁] M₁ →ₛₗ[I₁'] R}
  {v : (a : n) → M₁}, (LinearMap.IsOrthoᵢ B v) ↔ (∀ (i : n) (j : n) (a : i ≠ j), ↑(↑B (v i)) (v j) = 0))

(∀ {M : Type u_1} [inst : Add M] (U : Ultrafilter M) (V : Ultrafilter M) (p : (a : M) → Prop),
  (∀ᶠ (m : M) in ↑(U + V), p m) ↔ (∀ᶠ (m : M) in ↑U, ∀ᶠ (m' : M) in ↑V, p (m + m')))
failed to synthesize instance
  HAdd (Ultrafilter M) (Ultrafilter M) ?m.1575 ; identifiers [M, u_1, inst, Add, M, U, Ultrafilter, M, V, Ultrafilter, M, p, a, M, m, M, U, V, p, m, m, M, U, m', M, V, p, m, m'] (during elaboration) for (∀ {M : Type u_1} [inst : Add M] (U : Ultrafilter M) (V : Ultrafilter M) (p : (a : M) → Prop),
  (∀ᶠ (m : M) in ↑(U + V), p m) ↔ (∀ᶠ (m : M) in ↑U, ∀ᶠ (m' : M) in ↑V, p (m + m')))

(∀ {B : Type u₁} [inst : CategoryTheory.Bicategory B] {C : Type u₂} [inst_1 : CategoryTheory.Bicategory C]
  {F : CategoryTheory.OplaxFunctor B C} {G : CategoryTheory.OplaxFunctor B C} {η : F ⟶ G} {θ : F ⟶ G}
  [inst_2 : SizeOf B] [inst_3 : SizeOf C] (app : (a : B) → η.app a ⟶ θ.app a)
  (naturality :
    autoParam
      (∀ {a : B} {b : B} (f : a ⟶ b),
        CategoryTheory.CategoryStruct.comp
            (CategoryTheory.Bicategory.whiskerLeft ((↑(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map f) (app b))
            (CategoryTheory.OplaxNatTrans.naturality θ f) =
          CategoryTheory.CategoryStruct.comp (CategoryTheory.OplaxNatTrans.naturality η f)
            (CategoryTheory.Bicategory.whiskerRight (app a) ((↑(CategoryTheory.OplaxFunctor.toPrelaxFunctor G)).map f)))
      _auto✝),
  sizeOf (CategoryTheory.OplaxNatTrans.Modification.mk app) = 1)
<input>:12:11: expected token

(∀ {J : Type u₁} [inst : SizeOf J], sizeOf CategoryTheory.Bicone.left = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (CategoryTheory.Bicone ?m.6906) ; identifiers [J, u₁, inst, SizeOf, J, sizeOf, CategoryTheory.Bicone.left] (during elaboration) for (∀ {J : Type u₁} [inst : SizeOf J], sizeOf CategoryTheory.Bicone.left = 1)

(∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X : C} {R : CategoryTheory.Sieve X}
  {S : CategoryTheory.Sieve X} {Y : C} (f : Y ⟶ X), ((R ⊓ S).arrows f) ↔ ((R.arrows f) ∧ (S.arrows f)))
unknown universe level 'v₁' ; identifiers [C, u₁, inst, CategoryTheory.Category, v₁, u₁, C, X, C, R, CategoryTheory.Sieve, X, S, CategoryTheory.Sieve, X, Y, C, f, Y, X, R, S, arrows, f, R.arrows, f, S.arrows, f] (during elaboration) for (∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X : C} {R : CategoryTheory.Sieve X}
  {S : CategoryTheory.Sieve X} {Y : C} (f : Y ⟶ X), ((R ⊓ S).arrows f) ↔ ((R.arrows f) ∧ (S.arrows f)))

(∀ (A : Type u_1) [inst : CommRing A] (K : Type u_2) [inst_1 : Field K] [inst_2 : Algebra A K]
  (a : ValuationRing.ValueGroup A K) (b : ValuationRing.ValueGroup A K), (a < b) ↔ (a < b))
failed to synthesize instance
  LT (ValuationRing.ValueGroup A K) ; identifiers [A, u_1, inst, CommRing, A, K, u_2, inst_1, Field, K, inst_2, Algebra, A, K, a, ValuationRing.ValueGroup, A, K, b, ValuationRing.ValueGroup, A, K, a, b, a, b] (during elaboration) for (∀ (A : Type u_1) [inst : CommRing A] (K : Type u_2) [inst_1 : Field K] [inst_2 : Algebra A K]
  (a : ValuationRing.ValueGroup A K) (b : ValuationRing.ValueGroup A K), (a < b) ↔ (a < b))

(∀ {z : ℂ} {w : ℂ}, (z ≤ w) ↔ ((Complex.re z ≤ Complex.re w) ∧ (Complex.im z = Complex.im w)))
failed to synthesize instance
  LE ℂ ; identifiers [z, w, z, w, Complex.re, z, Complex.re, w, Complex.im, z, Complex.im, w] (during elaboration) for (∀ {z : ℂ} {w : ℂ}, (z ≤ w) ↔ ((Complex.re z ≤ Complex.re w) ∧ (Complex.im z = Complex.im w)))

(∀ {K : Type u_1} {Γ : (a : K) → Type u_2} {Λ : Type u_3} {σ : Type u_4} [inst : SizeOf K]
  [inst_1 : (a : K) → SizeOf (Γ a)] [inst_2 : SizeOf Λ] [inst_3 : SizeOf σ] (a : (a : σ) → Λ),
  sizeOf (Turing.TM2.Stmt.goto a) = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (Turing.TM2.Stmt (?m.7019 a) Λ σ) ; identifiers [K, u_1, Γ, a, K, u_2, Λ, u_3, σ, u_4, inst, SizeOf, K, inst_1, a, K, SizeOf, Γ, a, inst_2, SizeOf, Λ, inst_3, SizeOf, σ, a, a, σ, Λ, sizeOf, Turing.TM2.Stmt.goto, a] (during elaboration) for (∀ {K : Type u_1} {Γ : (a : K) → Type u_2} {Λ : Type u_3} {σ : Type u_4} [inst : SizeOf K]
  [inst_1 : (a : K) → SizeOf (Γ a)] [inst_2 : SizeOf Λ] [inst_3 : SizeOf σ] (a : (a : σ) → Λ),
  sizeOf (Turing.TM2.Stmt.goto a) = 1)

(∀ {z : ℂ} {w : ℂ}, (z < w) ↔ ((Complex.re z < Complex.re w) ∧ (Complex.im z = Complex.im w)))
failed to synthesize instance
  LT ℂ ; identifiers [z, w, z, w, Complex.re, z, Complex.re, w, Complex.im, z, Complex.im, w] (during elaboration) for (∀ {z : ℂ} {w : ℂ}, (z < w) ↔ ((Complex.re z < Complex.re w) ∧ (Complex.im z = Complex.im w)))

(∀ (X : CommRingCat) (x : ↑X) (y : ↑X), 1 = 1)
type mismatch
  X
has type
  CommRingCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, CommRingCat, x, X, y, X] (during elaboration) for (∀ (X : CommRingCat) (x : ↑X) (y : ↑X), 1 = 1)

(∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X : C} {R : CategoryTheory.Sieve X}
  {S : CategoryTheory.Sieve X} {Y : C} (f : Y ⟶ X), ((R ⊔ S).arrows f) ↔ ((R.arrows f) ∨ (S.arrows f)))
unknown universe level 'v₁' ; identifiers [C, u₁, inst, CategoryTheory.Category, v₁, u₁, C, X, C, R, CategoryTheory.Sieve, X, S, CategoryTheory.Sieve, X, Y, C, f, Y, X, R, S, arrows, f, R.arrows, f, S.arrows, f] (during elaboration) for (∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X : C} {R : CategoryTheory.Sieve X}
  {S : CategoryTheory.Sieve X} {Y : C} (f : Y ⟶ X), ((R ⊔ S).arrows f) ↔ ((R.arrows f) ∨ (S.arrows f)))

(∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : NonUnitalSemiring A]
  [inst_3 : StarRing A] [inst_4 : Module R A] [inst_5 : IsScalarTower R A A] [inst_6 : SMulCommClass R A A]
  [inst_7 : StarModule R A], Monotone star)
typeclass instance problem is stuck, it is often due to metavariables
  Preorder ?m.10745 ; identifiers [R, u, A, v, inst, CommSemiring, R, inst_1, StarRing, R, inst_2, NonUnitalSemiring, A, inst_3, StarRing, A, inst_4, Module, R, A, inst_5, IsScalarTower, R, A, A, inst_6, SMulCommClass, R, A, A, inst_7, StarModule, R, A, Monotone, star] (during elaboration) for (∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : NonUnitalSemiring A]
  [inst_3 : StarRing A] [inst_4 : Module R A] [inst_5 : IsScalarTower R A A] [inst_6 : SMulCommClass R A A]
  [inst_7 : StarModule R A], Monotone star)

(∀ {α : Type u_1} {β : Type u_2} {σ : Type u_3} [inst : Primcodable α] [inst_1 : Primcodable β] [inst_2 : Primcodable σ]
  {f : (a : α) → (a : β) → σ} (hf : Computable₂ f), Partrec₂ fun (a : α) ↦ ↑(f a))
typeclass instance problem is stuck, it is often due to metavariables
  Primcodable (?m.287 hf) ; identifiers [α, u_1, β, u_2, σ, u_3, inst, Primcodable, α, inst_1, Primcodable, β, inst_2, Primcodable, σ, f, a, α, a, β, σ, hf, Computable₂, f, Partrec₂, a, α, f, a] (during elaboration) for (∀ {α : Type u_1} {β : Type u_2} {σ : Type u_3} [inst : Primcodable α] [inst_1 : Primcodable β] [inst_2 : Primcodable σ]
  {f : (a : α) → (a : β) → σ} (hf : Computable₂ f), Partrec₂ fun (a : α) ↦ ↑(f a))

(∀ {K : Type u_1} [inst : Field K] [inst_1 : UniformSpace K] [inst_2 : TopologicalDivisionRing K]
  [inst_3 : UniformAddGroup K] (a : UniformSpace.Completion K) (b : UniformSpace.Completion K), a / b = a / b)
failed to synthesize instance
  HDiv (UniformSpace.Completion K) (UniformSpace.Completion K) ?m.994 ; identifiers [K, u_1, inst, Field, K, inst_1, UniformSpace, K, inst_2, TopologicalDivisionRing, K, inst_3, UniformAddGroup, K, a, UniformSpace.Completion, K, b, UniformSpace.Completion, K, a, b, a, b] (during elaboration) for (∀ {K : Type u_1} [inst : Field K] [inst_1 : UniformSpace K] [inst_2 : TopologicalDivisionRing K]
  [inst_3 : UniformAddGroup K] (a : UniformSpace.Completion K) (b : UniformSpace.Completion K), a / b = a / b)

(∀ {α : Type ua} {a : α} {b : α}, ((a, b) ∈ idRel) ↔ (a = b))
unknown universe level 'ua' ; identifiers [α, ua, a, α, b, α, a, b, idRel, a, b] (during elaboration) for (∀ {α : Type ua} {a : α} {b : α}, ((a, b) ∈ idRel) ↔ (a = b))

(∀ {α : Type u} [inst : SizeOf α], sizeOf Lists'.nil = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (Lists' ?m.6912 true) ; identifiers [α, u, inst, SizeOf, α, sizeOf, Lists'.nil] (during elaboration) for (∀ {α : Type u} [inst : SizeOf α], sizeOf Lists'.nil = 1)

