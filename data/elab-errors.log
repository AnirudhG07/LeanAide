 : (∀ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ⟶ Y} {g : X ⟶ Y} {Z : C} {π : Y ⟶ Z} (self : CategoryTheory.IsSplitCoequalizer f g π) , CategoryTheory.CategoryStruct.comp CategoryTheory.IsSplitCoequalizer.leftSection self f = CategoryTheory.CategoryStruct.comp π CategoryTheory.IsSplitCoequalizer.rightSection self)
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81211 ?m.161062
term has type
  ?m.628 ⟶ ?m.630 ; identifiers [C, u, inst, CategoryTheory.Category, C, X, C, Y, C, f, X, Y, g, X, Y, Z, C, π, Y, Z, self, CategoryTheory.IsSplitCoequalizer, f, g, π, CategoryTheory.CategoryStruct.comp, CategoryTheory.IsSplitCoequalizer.leftSection, self, f, CategoryTheory.CategoryStruct.comp, π, CategoryTheory.IsSplitCoequalizer.rightSection, self] (during elaboration)

{Ω : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace Ω} [TopologicalSpace β] [Preorder ι] {u : (a : ι) → (a : Ω) → β} {v : (a : ι) → (a : Ω) → β} {f : MeasureTheory.Filtration ι m} [Sub β] [ContinuousSub β] (hu : MeasureTheory.Adapted f u) (hv : MeasureTheory.Adapted f v) (i : ι)  : MeasureTheory.StronglyMeasurable u i
function expected at
  MeasureTheory.StronglyMeasurable u
term has type
  Prop ; identifiers [Ω, u_2, β, u_1, ι, u_3, m, MeasurableSpace, Ω, TopologicalSpace, β, Preorder, ι, u, a, ι, a, Ω, β, v, a, ι, a, Ω, β, f, MeasureTheory.Filtration, ι, m, Sub, β, ContinuousSub, β, hu, MeasureTheory.Adapted, f, u, hv, MeasureTheory.Adapted, f, v, i, ι, MeasureTheory.StronglyMeasurable, u, i] (during elaboration)

{Ω : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace Ω} [TopologicalSpace β] [Preorder ι] {u : (a : ι) → (a : Ω) → β} {v : (a : ι) → (a : Ω) → β} {f : MeasureTheory.Filtration ι m} [Sub β] [ContinuousSub β] (hu : MeasureTheory.Adapted f u) (hv : MeasureTheory.Adapted f v) (i : ι)  : MeasureTheory.StronglyMeasurable v i
function expected at
  MeasureTheory.StronglyMeasurable v
term has type
  Prop ; identifiers [Ω, u_2, β, u_1, ι, u_3, m, MeasurableSpace, Ω, TopologicalSpace, β, Preorder, ι, u, a, ι, a, Ω, β, v, a, ι, a, Ω, β, f, MeasureTheory.Filtration, ι, m, Sub, β, ContinuousSub, β, hu, MeasureTheory.Adapted, f, u, hv, MeasureTheory.Adapted, f, v, i, ι, MeasureTheory.StronglyMeasurable, v, i] (during elaboration)

 : ∀ (C : Type u) [inst : CategoryTheory.Category C] (X : C) (Y : C) (f : X ⟶ Y) (g : X ⟶ Y) (Z : C) (π : Y ⟶ Z) (self : CategoryTheory.IsSplitCoequalizer f g π) , CategoryTheory.CategoryStruct.comp self . 2 f = CategoryTheory.CategoryStruct.comp π self . 1
invalid occurrence of `·` notation, it must be surrounded by parentheses (e.g. `(· + 1)`) ; identifiers [C, u, inst, CategoryTheory.Category, C, X, C, Y, C, f, X, Y, g, X, Y, Z, C, π, Y, Z, self, CategoryTheory.IsSplitCoequalizer, f, g, π, CategoryTheory.CategoryStruct.comp, self, f, CategoryTheory.CategoryStruct.comp, π, self] (during elaboration)

{α : Type u_1} [Preorder α] [AddCommSemigroup α] [Sub α] [OrderedSub α] {a : α} {b : α} {c : α} [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1]  : (a + b - a + c ≤ b - c) = (a + b - a + c ≤ b - c)
function expected at
  x_1
term has type
  α ; identifiers [α, u_1, Preorder, α, AddCommSemigroup, α, Sub, α, OrderedSub, α, a, α, b, α, c, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, b, a, c, b, c, a, b, a, c, b, c] (during elaboration)

{α : Type u_1} [Preorder α] [AddCommSemigroup α] [Sub α] [OrderedSub α] {a : α} {b : α} {c : α} [CovariantClass α α fun (x : α) (x_1 : α) ↦ x + x_1 fun (x : α) (x_1 : α) ↦ x ≤ x_1]  : (a + b ≤ a + c + b - c) = (a + b ≤ a + c + b - c)
function expected at
  x_1
term has type
  α ; identifiers [α, u_1, Preorder, α, AddCommSemigroup, α, Sub, α, OrderedSub, α, a, α, b, α, c, α, CovariantClass, α, α, x, α, x_1, α, x, x_1, x, α, x_1, α, x, x_1, a, b, a, c, b, c, a, b, a, c, b, c] (during elaboration)

{α : Type u_1} {β : Type u_2} [Inf α] [SemilatticeInf β] (f : (a : α) → β) (hf_inj : Function.Injective f) (map_inf : ∀ (a : α) (b : α) , f a ⊓ b = f a ⊓ f b) (a : α) (b : α) (c : α) (ha : a ≤ b) (hb : a ≤ c)  : f b ⊓ c = f b ⊓ f c
application type mismatch
  f a ⊓ b
argument
  b
has type
  α : Type u_1
but is expected to have type
  β : Type u_2 ; identifiers [α, u_1, β, u_2, Inf, α, SemilatticeInf, β, f, a, α, β, hf_inj, Function.Injective, f, map_inf, a, α, b, α, f, a, b, f, a, f, b, a, α, b, α, c, α, ha, a, b, hb, a, c, f, b, c, f, b, f, c] (during elaboration)

 : (∀ {α : Type u_1} {mα : MeasurableSpace α} {ρ : MeasureTheory.Measure α × ℝ} {a : α} (self : ProbabilityTheory.HasCondCdf ρ a) , Filter.Tendsto fun (r : ℚ) ↦ ProbabilityTheory.preCdf ρ r a Filter.atBot nhds 0)
application type mismatch
  ProbabilityTheory.HasCondCdf ρ
argument
  ρ
has type
  MeasureTheory.Measure α × ℝ : Type u_1
but is expected to have type
  MeasureTheory.Measure (?m.22 × ℝ) : Type ?u.21 ; identifiers [α, u_1, mα, MeasurableSpace, α, ρ, MeasureTheory.Measure, α, a, α, self, ProbabilityTheory.HasCondCdf, ρ, a, Filter.Tendsto, r, ProbabilityTheory.preCdf, ρ, r, a, Filter.atBot, nhds] (during elaboration)

 : ∀ (α : Type u_1) (mα : MeasurableSpace α) (ρ : MeasureTheory.Measure α × ℝ) (a : α) (self : ProbabilityTheory.HasCondCdf ρ a) , Filter.Tendsto fun (r : ℚ) ↦ ProbabilityTheory.preCdf ρ r a Filter.atBot nhds 0
application type mismatch
  ProbabilityTheory.HasCondCdf ρ
argument
  ρ
has type
  MeasureTheory.Measure α × ℝ : Type u_1
but is expected to have type
  MeasureTheory.Measure (?m.22 × ℝ) : Type ?u.21 ; identifiers [α, u_1, mα, MeasurableSpace, α, ρ, MeasureTheory.Measure, α, a, α, self, ProbabilityTheory.HasCondCdf, ρ, a, Filter.Tendsto, r, ProbabilityTheory.preCdf, ρ, r, a, Filter.atBot, nhds] (during elaboration)

 : (∀ {α : Type u} [inst : UniformSpace α] (self : AbstractCompletion α) , SeparatedSpace AbstractCompletion.space self)
application type mismatch
  @SeparatedSpace AbstractCompletion.space
argument
  AbstractCompletion.space
has type
  AbstractCompletion ?m.22 → Type ?u.21 : Type (?u.21 + 1)
but is expected to have type
  Type ?u.20 : Type (?u.20 + 1) ; identifiers [α, u, inst, UniformSpace, α, self, AbstractCompletion, α, SeparatedSpace, AbstractCompletion.space, self] (during elaboration)

 : ∀ (α : Type u) [inst : UniformSpace α] (self : AbstractCompletion α) , SeparatedSpace self . 1
application type mismatch
  @SeparatedSpace self
argument
  self
has type
  AbstractCompletion α : Type (u + 1)
but is expected to have type
  Type ?u.20 : Type (?u.20 + 1) ; identifiers [α, u, inst, UniformSpace, α, self, AbstractCompletion, α, SeparatedSpace, self] (during elaboration)

{R : Type u} {I : Type v} [CommSemiring R] {z : R} {s : (a : I) → R} [Fintype I] (Hs : Pairwise IsCoprime on s) (Hs1 : ∀ (i : I) , s i ∣ z)  : ∀ (i : I) (x : i ∈ Finset.univ) , s i ∣ z
type expected, got
  (?m.79373 on s : I → I → ?m.31) ; identifiers [R, u, I, v, CommSemiring, R, z, R, s, a, I, R, Fintype, I, Hs, Pairwise, IsCoprime, s, Hs1, i, I, s, i, z, i, I, x, i, Finset.univ, s, i, z] (during elaboration)

{R : Type u_1} {S : Type u_2} [ConditionallyCompleteLinearOrder R] (s : Finset S) (f : (a : S) → Tropical WithTop R) (h : s = ∅)  : ∅ = s
application type mismatch
  Tropical WithTop
argument
  WithTop
has type
  Type ?u.21 → Type ?u.21 : Type (?u.21 + 1)
but is expected to have type
  Type ?u.20 : Type (?u.20 + 1) ; identifiers [R, u_1, S, u_2, ConditionallyCompleteLinearOrder, R, s, Finset, S, f, a, S, Tropical, WithTop, R, h, s, s] (during elaboration)

{C : Type u_2} [CategoryTheory.Category C] {D : Type u_4} [CategoryTheory.Category D] {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor C D} (app : (X : C) → CategoryTheory.Functor.toPrefunctor F . obj X ≅ CategoryTheory.Functor.toPrefunctor G . obj X) (naturality : autoParam (∀ {X : C} {Y : C} (f : X ⟶ Y) , CategoryTheory.CategoryStruct.comp CategoryTheory.Functor.toPrefunctor F . map f app Y . hom = CategoryTheory.CategoryStruct.comp app X . hom CategoryTheory.Functor.toPrefunctor G . map f : Prop) _auto._@.Mathlib.CategoryTheory.NatIso._hyg.1795) ⦃ X_1 : C ⦄ ⦃ Y_1 : C ⦄ (f : X_1 ⟶ Y_1)  : ∀ {X : C} {Y : C} (f : X ⟶ Y) , CategoryTheory.CategoryStruct.comp CategoryTheory.Functor.toPrefunctor F . map f app Y . hom = CategoryTheory.CategoryStruct.comp app X . hom CategoryTheory.Functor.toPrefunctor G . map f
function expected at
  F.toPrefunctor
term has type
  C ⥤q D ; identifiers [C, u_2, CategoryTheory.Category, C, D, u_4, CategoryTheory.Category, D, F, CategoryTheory.Functor, C, D, G, CategoryTheory.Functor, C, D, app, X, C, CategoryTheory.Functor.toPrefunctor, F, obj, X, CategoryTheory.Functor.toPrefunctor, G, obj, X, naturality, autoParam, X, C, Y, C, f, X, Y, CategoryTheory.CategoryStruct.comp, CategoryTheory.Functor.toPrefunctor, F, map, f, app, Y, hom, CategoryTheory.CategoryStruct.comp, app, X, hom, CategoryTheory.Functor.toPrefunctor, G, map, f, _auto._, Mathlib.CategoryTheory.NatIso._hyg, X_1, C, Y_1, C, f, X_1, Y_1, X, C, Y, C, f, X, Y, CategoryTheory.CategoryStruct.comp, CategoryTheory.Functor.toPrefunctor, F, map, f, app, Y, hom, CategoryTheory.CategoryStruct.comp, app, X, hom, CategoryTheory.Functor.toPrefunctor, G, map, f] (during elaboration)

{X : Type u} {α : Type v} [TopologicalSpace X] [LinearOrder α] [TopologicalSpace α] [OrderClosedTopology α] {s : Set X} (hs : IsPreconnected s) {a : X} {l : Filter X} (ha : a ∈ s) [Filter.NeBot l] (hl : l ≤ Filter.principal s) {f : (a : X) → α} (hf : ContinuousOn f s) (ht : Filter.Tendsto f l Filter.atBot) (y : α) (h : y ∈ Set.Iic f a) (x : X) (h : (x ∈ s : Prop) ∧ (y = f x : Prop))  : ∀ (h : y = f x) , f x = y
application type mismatch
  Set.Iic f a
argument
  a
has type
  X : Type u
but is expected to have type
  X → α : Type (max u v) ; identifiers [X, u, α, v, TopologicalSpace, X, LinearOrder, α, TopologicalSpace, α, OrderClosedTopology, α, s, Set, X, hs, IsPreconnected, s, a, X, l, Filter, X, ha, a, s, Filter.NeBot, l, hl, l, Filter.principal, s, f, a, X, α, hf, ContinuousOn, f, s, ht, Filter.Tendsto, f, l, Filter.atBot, y, α, h, y, Set.Iic, f, a, x, X, h, x, s, y, f, x, h, y, f, x, f, x, y] (during elaboration)

 : (∀ {ι : Type u_1} {α : (a : ι) → Type u_2} [inst : (i : ι) → Preorder α i] (a : (i : ι) → α i) (b : (i : ι) → α i) , (a < b) ↔ (a < b))
application type mismatch
  Preorder α
argument
  α
has type
  ι → Type u_2 : Type (max u_1 (u_2 + 1))
but is expected to have type
  Type ?u.13 : Type (?u.13 + 1) ; identifiers [ι, u_1, α, a, ι, u_2, inst, i, ι, Preorder, α, i, a, i, ι, α, i, b, i, ι, α, i, a, b, a, b] (during elaboration)

 : ∀ {ι : Type u_1} {α : (a : ι) → Type u_2} [inst : (i : ι) → Preorder α i] (a : (i : ι) → α i) (b : (i : ι) → α i) , (a < b) ↔ (a < b)
application type mismatch
  Preorder α
argument
  α
has type
  ι → Type u_2 : Type (max u_1 (u_2 + 1))
but is expected to have type
  Type ?u.13 : Type (?u.13 + 1) ; identifiers [ι, u_1, α, a, ι, u_2, inst, i, ι, Preorder, α, i, a, i, ι, α, i, b, i, ι, α, i, a, b, a, b] (during elaboration)

{R : Type u_1} {L : Type u_2} {L' : Type u_3} [CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L'] (toLinearMap : L →ₗ[R] L') (map_lie' : ∀ {x : L} {y : L} , AddHom.toFun LinearMap.toAddHom toLinearMap ⁅ x , y ⁆ = ⁅ AddHom.toFun LinearMap.toAddHom toLinearMap x , AddHom.toFun LinearMap.toAddHom toLinearMap y ⁆) (toLinearMap_1 : L →ₗ[R] L') (map_lie'_1 : ∀ {x : L} {y : L} , AddHom.toFun LinearMap.toAddHom toLinearMap_1 ⁅ x , y ⁆ = ⁅ AddHom.toFun LinearMap.toAddHom toLinearMap_1 x , AddHom.toFun LinearMap.toAddHom toLinearMap_1 y ⁆) (a : {toLinearMap := ((toLinearMap)) , map_lie' := ((map_lie'))} = {toLinearMap := ((toLinearMap_1)) , map_lie' := ((map_lie'_1))})  : ∀ (toLinearMap_eq : toLinearMap = toLinearMap_1) , toLinearMap = toLinearMap_1
function expected at
  AddHom.toFun ?m.5802 toLinearMap
term has type
  ?m.2096 ; identifiers [R, u_1, L, u_2, L', u_3, CommRing, R, LieRing, L, LieAlgebra, R, L, LieRing, L', LieAlgebra, R, L', toLinearMap, L, R, L', map_lie', x, L, y, L, AddHom.toFun, LinearMap.toAddHom, toLinearMap, x, y, AddHom.toFun, LinearMap.toAddHom, toLinearMap, x, AddHom.toFun, LinearMap.toAddHom, toLinearMap, y, toLinearMap_1, L, R, L', map_lie'_1, x, L, y, L, AddHom.toFun, LinearMap.toAddHom, toLinearMap_1, x, y, AddHom.toFun, LinearMap.toAddHom, toLinearMap_1, x, AddHom.toFun, LinearMap.toAddHom, toLinearMap_1, y, a, toLinearMap, toLinearMap, map_lie', map_lie', toLinearMap, toLinearMap_1, map_lie', map_lie'_1, toLinearMap_eq, toLinearMap, toLinearMap_1, toLinearMap, toLinearMap_1] (during elaboration)

{α : Type u_1} [TopologicalSpace α] [Preorder α] (h : ∀ {a : α} {b : α} (a_1 : a ≤ b) , IsCompact Set.Icc a b) {a : α} {b : α}  : ∀ (a_1 : a ≤ b) , IsCompact Set.Icc a b
function expected at
  IsCompact ?m.366
term has type
  Prop ; identifiers [α, u_1, TopologicalSpace, α, Preorder, α, h, a, α, b, α, a_1, a, b, IsCompact, Set.Icc, a, b, a, α, b, α, a_1, a, b, IsCompact, Set.Icc, a, b] (during elaboration)

{K : Type u_1} [LinearOrderedField K] [FloorRing K] {v : K} (fst : GeneralizedContinuedFraction.IntFractPair K) (snd : Stream'.Seq GeneralizedContinuedFraction.IntFractPair K) (h : GeneralizedContinuedFraction.IntFractPair.seq1 v = (fst , snd))  : (fst , snd) = GeneralizedContinuedFraction.IntFractPair.seq1 v
application type mismatch
  Stream'.Seq GeneralizedContinuedFraction.IntFractPair
argument
  GeneralizedContinuedFraction.IntFractPair
has type
  Type ?u.39 → Type ?u.39 : Type (?u.39 + 1)
but is expected to have type
  Type ?u.38 : Type (?u.38 + 1) ; identifiers [K, u_1, LinearOrderedField, K, FloorRing, K, v, K, fst, GeneralizedContinuedFraction.IntFractPair, K, snd, Stream'.Seq, GeneralizedContinuedFraction.IntFractPair, K, h, GeneralizedContinuedFraction.IntFractPair.seq1, v, fst, snd, fst, snd, GeneralizedContinuedFraction.IntFractPair.seq1, v] (during elaboration)

{R : Type u_1} {L : Type u_2} {L' : Type u_3} [CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L'] (toLinearMap : L →ₗ[R] L') (map_lie' : ∀ {x : L} {y : L} , AddHom.toFun LinearMap.toAddHom toLinearMap ⁅ x , y ⁆ = ⁅ AddHom.toFun LinearMap.toAddHom toLinearMap x , AddHom.toFun LinearMap.toAddHom toLinearMap y ⁆) (toLinearMap_1 : L →ₗ[R] L') (map_lie'_1 : ∀ {x : L} {y : L} , AddHom.toFun LinearMap.toAddHom toLinearMap_1 ⁅ x , y ⁆ = ⁅ AddHom.toFun LinearMap.toAddHom toLinearMap_1 x , AddHom.toFun LinearMap.toAddHom toLinearMap_1 y ⁆) (a : toLinearMap = toLinearMap_1) (h : toLinearMap_1 = toLinearMap) (toLinearMap_2 : L →ₗ[R] L')  : toLinearMap = toLinearMap
function expected at
  AddHom.toFun ?m.5802 toLinearMap
term has type
  ?m.2096 ; identifiers [R, u_1, L, u_2, L', u_3, CommRing, R, LieRing, L, LieAlgebra, R, L, LieRing, L', LieAlgebra, R, L', toLinearMap, L, R, L', map_lie', x, L, y, L, AddHom.toFun, LinearMap.toAddHom, toLinearMap, x, y, AddHom.toFun, LinearMap.toAddHom, toLinearMap, x, AddHom.toFun, LinearMap.toAddHom, toLinearMap, y, toLinearMap_1, L, R, L', map_lie'_1, x, L, y, L, AddHom.toFun, LinearMap.toAddHom, toLinearMap_1, x, y, AddHom.toFun, LinearMap.toAddHom, toLinearMap_1, x, AddHom.toFun, LinearMap.toAddHom, toLinearMap_1, y, a, toLinearMap, toLinearMap_1, h, toLinearMap_1, toLinearMap, toLinearMap_2, L, R, L', toLinearMap, toLinearMap] (during elaboration)

{R : Type u_1} {L : Type u_2} {L' : Type u_3} [CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L'] (toLinearMap : L →ₗ[R] L') (map_lie' : ∀ {x : L} {y : L} , AddHom.toFun LinearMap.toAddHom toLinearMap ⁅ x , y ⁆ = ⁅ AddHom.toFun LinearMap.toAddHom toLinearMap x , AddHom.toFun LinearMap.toAddHom toLinearMap y ⁆) (toLinearMap_1 : L →ₗ[R] L') (map_lie'_1 : ∀ {x : L} {y : L} , AddHom.toFun LinearMap.toAddHom toLinearMap_1 ⁅ x , y ⁆ = ⁅ AddHom.toFun LinearMap.toAddHom toLinearMap_1 x , AddHom.toFun LinearMap.toAddHom toLinearMap_1 y ⁆) (a : toLinearMap = toLinearMap_1) (h : toLinearMap_1 = toLinearMap) (map_lie'_2 : ∀ {x : L} {y : L} , AddHom.toFun LinearMap.toAddHom toLinearMap ⁅ x , y ⁆ = ⁅ AddHom.toFun LinearMap.toAddHom toLinearMap x , AddHom.toFun LinearMap.toAddHom toLinearMap y ⁆) (a : toLinearMap = toLinearMap) (h : HEq a (Eq.refl toLinearMap =: toLinearMap = toLinearMap))  : {toLinearMap := (toLinearMap) , map_lie' := (map_lie')} = {toLinearMap := (toLinearMap) , map_lie' := (map_lie')}
<input>:1:879: expected term

{R : Type u_1} {L : Type u_2} {L' : Type u_3} [CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L'] (toLinearMap : L →ₗ[R] L') (map_lie' : ∀ {x : L} {y : L} , AddHom.toFun LinearMap.toAddHom toLinearMap ⁅ x , y ⁆ = ⁅ AddHom.toFun LinearMap.toAddHom toLinearMap x , AddHom.toFun LinearMap.toAddHom toLinearMap y ⁆) (toLinearMap_1 : L →ₗ[R] L') (map_lie'_1 : ∀ {x : L} {y : L} , AddHom.toFun LinearMap.toAddHom toLinearMap_1 ⁅ x , y ⁆ = ⁅ AddHom.toFun LinearMap.toAddHom toLinearMap_1 x , AddHom.toFun LinearMap.toAddHom toLinearMap_1 y ⁆) (a : toLinearMap = toLinearMap_1) (h : toLinearMap_1 = toLinearMap)  : toLinearMap = toLinearMap_1
function expected at
  AddHom.toFun ?m.5802 toLinearMap
term has type
  ?m.2096 ; identifiers [R, u_1, L, u_2, L', u_3, CommRing, R, LieRing, L, LieAlgebra, R, L, LieRing, L', LieAlgebra, R, L', toLinearMap, L, R, L', map_lie', x, L, y, L, AddHom.toFun, LinearMap.toAddHom, toLinearMap, x, y, AddHom.toFun, LinearMap.toAddHom, toLinearMap, x, AddHom.toFun, LinearMap.toAddHom, toLinearMap, y, toLinearMap_1, L, R, L', map_lie'_1, x, L, y, L, AddHom.toFun, LinearMap.toAddHom, toLinearMap_1, x, y, AddHom.toFun, LinearMap.toAddHom, toLinearMap_1, x, AddHom.toFun, LinearMap.toAddHom, toLinearMap_1, y, a, toLinearMap, toLinearMap_1, h, toLinearMap_1, toLinearMap, toLinearMap, toLinearMap_1] (during elaboration)

{R : Type u_1} {L : Type u_2} {L' : Type u_3} [CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L'] (toLinearMap : L →ₗ[R] L') (map_lie' : ∀ {x : L} {y : L} , AddHom.toFun LinearMap.toAddHom toLinearMap ⁅ x , y ⁆ = ⁅ AddHom.toFun LinearMap.toAddHom toLinearMap x , AddHom.toFun LinearMap.toAddHom toLinearMap y ⁆) (toLinearMap_1 : L →ₗ[R] L') (map_lie'_1 : ∀ {x : L} {y : L} , AddHom.toFun LinearMap.toAddHom toLinearMap_1 ⁅ x , y ⁆ = ⁅ AddHom.toFun LinearMap.toAddHom toLinearMap_1 x , AddHom.toFun LinearMap.toAddHom toLinearMap_1 y ⁆) (a : toLinearMap = toLinearMap_1)  : toLinearMap_1 = toLinearMap_1
function expected at
  AddHom.toFun ?m.5802 toLinearMap
term has type
  ?m.2096 ; identifiers [R, u_1, L, u_2, L', u_3, CommRing, R, LieRing, L, LieAlgebra, R, L, LieRing, L', LieAlgebra, R, L', toLinearMap, L, R, L', map_lie', x, L, y, L, AddHom.toFun, LinearMap.toAddHom, toLinearMap, x, y, AddHom.toFun, LinearMap.toAddHom, toLinearMap, x, AddHom.toFun, LinearMap.toAddHom, toLinearMap, y, toLinearMap_1, L, R, L', map_lie'_1, x, L, y, L, AddHom.toFun, LinearMap.toAddHom, toLinearMap_1, x, y, AddHom.toFun, LinearMap.toAddHom, toLinearMap_1, x, AddHom.toFun, LinearMap.toAddHom, toLinearMap_1, y, a, toLinearMap, toLinearMap_1, toLinearMap_1, toLinearMap_1] (during elaboration)

{α : Type u_1} [LinearOrderedAddCommGroup α] (n : ℕ) (a : α) (hneg : a ≤ 0) (h : (le_total a 0 =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)) = (Or.inl hneg =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)))  : Or.inl hneg = le_total a 0
<input>:1:96: expected term

{V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [Fact (FiniteDimensional.finrank ℝ V = 2 : Prop)] (o : Orientation ℝ V Fin 2) {x : V} {y : V} (h : Orientation.oangle o x y ≠ 0) (a : y = 0)  : 0 = y
application type mismatch
  Orientation ℝ V Fin
argument
  Fin
has type
  ℕ → Type : Type 1
but is expected to have type
  Type ?u.250 : Type (?u.250 + 1) ; identifiers [V, u_1, NormedAddCommGroup, V, InnerProductSpace, V, Fact, FiniteDimensional.finrank, V, o, Orientation, V, Fin, x, V, y, V, h, Orientation.oangle, o, x, y, a, y, y] (during elaboration)

{α : Type u_1} [LinearOrderedAddCommGroup α] (n : ℕ) (a : α) (hneg : a ≤ 0) (h : (le_total a 0 =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)) = (Or.inl hneg =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)))  : (| n • a | = n • | a |) = (| n • a | = n • | a |)
<input>:1:96: expected term

{α : Type u_1} [MeasurableSpace α] {M : Type u_2} [AddCommMonoid M] [TopologicalSpace M] (measureOf' : (a : Set α) → M) (empty' : measureOf' ∅ = 0) (not_measurable' : ∀ ⦃ i : Set α ⦄ (a : ¬ (MeasurableSet i : Prop)) , measureOf' i = 0) (m_iUnion' : ∀ ⦃ f : (a : ℕ) → Set α ⦄ (a : ∀ (i : ℕ) , MeasurableSet f i) (a : Pairwise Disjoint on f) , HasSum fun (i : ℕ) ↦ measureOf' f i measureOf' ⋃ (i : ℕ) , f i) (measureOf'_1 : (a : Set α) → M) (empty'_1 : measureOf'_1 ∅ = 0) (not_measurable'_1 : ∀ ⦃ i : Set α ⦄ (a : ¬ (MeasurableSet i : Prop)) , measureOf'_1 i = 0) (m_iUnion'_1 : ∀ ⦃ f : (a : ℕ) → Set α ⦄ (a : ∀ (i : ℕ) , MeasurableSet f i) (a : Pairwise Disjoint on f) , HasSum fun (i : ℕ) ↦ measureOf'_1 f i measureOf'_1 ⋃ (i : ℕ) , f i) (a : {measureOf' := ((measureOf')) , empty' := ((empty')) , not_measurable' := ((not_measurable')) , m_iUnion' := ((m_iUnion'))} = {measureOf' := ((measureOf'_1)) , empty' := ((empty'_1)) , not_measurable' := ((not_measurable'_1)) , m_iUnion' := ((m_iUnion'_1))})  : ∀ (measureOf'_eq : measureOf' = measureOf'_1) , measureOf' = measureOf'_1
<input>:1:389: expected ')'

{α : Type u_1} [LinearOrderedAddCommGroup α] (n : ℕ) (a : α) (hneg : a ≤ 0) (h : (le_total a 0 =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)) = (Or.inl hneg =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)))  : (| n • a | = n • - a) = (| n • a | = n • - a)
<input>:1:96: expected term

{α : Type u_1} [LinearOrderedAddCommGroup α] (n : ℕ) (a : α) (hneg : a ≤ 0) (h : (le_total a 0 =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)) = (Or.inl hneg =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)))  : (| (- n • a) | = n • - a) = (| (- n • a) | = n • - a)
<input>:1:96: expected term

{α : Type u_1} [LinearOrderedAddCommGroup α] (n : ℕ) (a : α) (hneg : a ≤ 0) (h : (le_total a 0 =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)) = (Or.inl hneg =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)))  : (| n • - a | = n • - a) = (| n • - a | = n • - a)
<input>:1:96: expected term

{α : Type u_1} [LinearOrderedAddCommGroup α] (n : ℕ) (a : α) (hneg : a ≤ 0) (h : (le_total a 0 =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)) = (Or.inl hneg =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)))  : n • - a = n • - a
<input>:1:96: expected term

{α : Type u_1} [MeasurableSpace α] {M : Type u_2} [AddCommMonoid M] [TopologicalSpace M] (measureOf' : (a : Set α) → M) (empty' : measureOf' ∅ = 0) (not_measurable' : ∀ ⦃ i : Set α ⦄ (a : ¬ (MeasurableSet i : Prop)) , measureOf' i = 0) (m_iUnion' : ∀ ⦃ f : (a : ℕ) → Set α ⦄ (a : ∀ (i : ℕ) , MeasurableSet f i) (a : Pairwise Disjoint on f) , HasSum fun (i : ℕ) ↦ measureOf' f i measureOf' ⋃ (i : ℕ) , f i) (measureOf'_1 : (a : Set α) → M) (empty'_1 : measureOf'_1 ∅ = 0) (not_measurable'_1 : ∀ ⦃ i : Set α ⦄ (a : ¬ (MeasurableSet i : Prop)) , measureOf'_1 i = 0) (m_iUnion'_1 : ∀ ⦃ f : (a : ℕ) → Set α ⦄ (a : ∀ (i : ℕ) , MeasurableSet f i) (a : Pairwise Disjoint on f) , HasSum fun (i : ℕ) ↦ measureOf'_1 f i measureOf'_1 ⋃ (i : ℕ) , f i) (a : measureOf' = measureOf'_1) (h : measureOf'_1 = measureOf') (measureOf'_2 : (a : Set α) → M)  : measureOf' = measureOf'
<input>:1:389: expected ')'

{α : Type u_1} [LinearOrderedAddCommGroup α] (n : ℕ) (a : α) (hpos : 0 ≤ a) (h : (le_total a 0 =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)) = (Or.inr hpos =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)))  : Or.inr hpos = le_total a 0
<input>:1:96: expected term

{α : Type u_1} [LinearOrderedAddCommGroup α] (n : ℕ) (a : α) (hpos : 0 ≤ a) (h : (le_total a 0 =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)) = (Or.inr hpos =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)))  : (| n • a | = n • | a |) = (| n • a | = n • | a |)
<input>:1:96: expected term

{α : Type u_1} [MeasurableSpace α] {M : Type u_2} [AddCommMonoid M] [TopologicalSpace M] (measureOf' : (a : Set α) → M) (empty' : measureOf' ∅ = 0) (not_measurable' : ∀ ⦃ i : Set α ⦄ (a : ¬ (MeasurableSet i : Prop)) , measureOf' i = 0) (m_iUnion' : ∀ ⦃ f : (a : ℕ) → Set α ⦄ (a : ∀ (i : ℕ) , MeasurableSet f i) (a : Pairwise Disjoint on f) , HasSum fun (i : ℕ) ↦ measureOf' f i measureOf' ⋃ (i : ℕ) , f i) (measureOf'_1 : (a : Set α) → M) (empty'_1 : measureOf'_1 ∅ = 0) (not_measurable'_1 : ∀ ⦃ i : Set α ⦄ (a : ¬ (MeasurableSet i : Prop)) , measureOf'_1 i = 0) (m_iUnion'_1 : ∀ ⦃ f : (a : ℕ) → Set α ⦄ (a : ∀ (i : ℕ) , MeasurableSet f i) (a : Pairwise Disjoint on f) , HasSum fun (i : ℕ) ↦ measureOf'_1 f i measureOf'_1 ⋃ (i : ℕ) , f i) (a : measureOf' = measureOf'_1) (h : measureOf'_1 = measureOf') (empty'_2 : measureOf' ∅ = 0) (not_measurable'_2 : ∀ ⦃ i : Set α ⦄ (a : ¬ (MeasurableSet i : Prop)) , measureOf' i = 0) (m_iUnion'_2 : ∀ ⦃ f : (a : ℕ) → Set α ⦄ (a : ∀ (i : ℕ) , MeasurableSet f i) (a : Pairwise Disjoint on f) , HasSum fun (i : ℕ) ↦ measureOf' f i measureOf' ⋃ (i : ℕ) , f i) (a : measureOf' = measureOf') (h : HEq a (Eq.refl measureOf' =: measureOf' = measureOf'))  : {measureOf' := (measureOf') , empty' := (empty') , not_measurable' := (not_measurable') , m_iUnion' := (m_iUnion')} = {measureOf' := (measureOf') , empty' := (empty') , not_measurable' := (not_measurable') , m_iUnion' := (m_iUnion')}
<input>:1:389: expected ')'

{α : Type u_1} [MeasurableSpace α] {M : Type u_2} [AddCommMonoid M] [TopologicalSpace M] (measureOf' : (a : Set α) → M) (empty' : measureOf' ∅ = 0) (not_measurable' : ∀ ⦃ i : Set α ⦄ (a : ¬ (MeasurableSet i : Prop)) , measureOf' i = 0) (m_iUnion' : ∀ ⦃ f : (a : ℕ) → Set α ⦄ (a : ∀ (i : ℕ) , MeasurableSet f i) (a : Pairwise Disjoint on f) , HasSum fun (i : ℕ) ↦ measureOf' f i measureOf' ⋃ (i : ℕ) , f i) (measureOf'_1 : (a : Set α) → M) (empty'_1 : measureOf'_1 ∅ = 0) (not_measurable'_1 : ∀ ⦃ i : Set α ⦄ (a : ¬ (MeasurableSet i : Prop)) , measureOf'_1 i = 0) (m_iUnion'_1 : ∀ ⦃ f : (a : ℕ) → Set α ⦄ (a : ∀ (i : ℕ) , MeasurableSet f i) (a : Pairwise Disjoint on f) , HasSum fun (i : ℕ) ↦ measureOf'_1 f i measureOf'_1 ⋃ (i : ℕ) , f i) (a : measureOf' = measureOf'_1) (h : measureOf'_1 = measureOf')  : measureOf' = measureOf'_1
<input>:1:389: expected ')'

{α : Type u_1} [LinearOrderedAddCommGroup α] (n : ℕ) (a : α) (hpos : 0 ≤ a) (h : (le_total a 0 =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)) = (Or.inr hpos =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)))  : (| n • a | = n • a) = (| n • a | = n • a)
<input>:1:96: expected term

{α : Type u_1} [LinearOrderedAddCommGroup α] (n : ℕ) (a : α) (hpos : 0 ≤ a) (h : (le_total a 0 =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)) = (Or.inr hpos =: (a ≤ 0 : Prop) ∨ (0 ≤ a : Prop)))  : n • a = n • a
<input>:1:96: expected term

{α : Type u_1} [MeasurableSpace α] {M : Type u_2} [AddCommMonoid M] [TopologicalSpace M] (measureOf' : (a : Set α) → M) (empty' : measureOf' ∅ = 0) (not_measurable' : ∀ ⦃ i : Set α ⦄ (a : ¬ (MeasurableSet i : Prop)) , measureOf' i = 0) (m_iUnion' : ∀ ⦃ f : (a : ℕ) → Set α ⦄ (a : ∀ (i : ℕ) , MeasurableSet f i) (a : Pairwise Disjoint on f) , HasSum fun (i : ℕ) ↦ measureOf' f i measureOf' ⋃ (i : ℕ) , f i) (measureOf'_1 : (a : Set α) → M) (empty'_1 : measureOf'_1 ∅ = 0) (not_measurable'_1 : ∀ ⦃ i : Set α ⦄ (a : ¬ (MeasurableSet i : Prop)) , measureOf'_1 i = 0) (m_iUnion'_1 : ∀ ⦃ f : (a : ℕ) → Set α ⦄ (a : ∀ (i : ℕ) , MeasurableSet f i) (a : Pairwise Disjoint on f) , HasSum fun (i : ℕ) ↦ measureOf'_1 f i measureOf'_1 ⋃ (i : ℕ) , f i) (a : measureOf' = measureOf'_1)  : measureOf'_1 = measureOf'_1
<input>:1:389: expected ')'

{α : Type u} {ι : Sort x} {f : (a : ι) → Filter α} {p : (a : ι) → Prop} {l : Filter α} (h : ∀ {s : Set α} , (s ∈ l : Prop) ↔ (∃ (i : ι) , (p i : Prop) ∧ (s ∈ f i : Prop) : Prop)) {x : Set α} {s : Set α}  : (s ∈ l) ↔ (∃ (i : ι) , (p i) ∧ (s ∈ f i))
unknown universe level 'x' ; identifiers [α, u, ι, x, f, a, ι, Filter, α, p, a, ι, l, Filter, α, h, s, Set, α, s, l, i, ι, p, i, s, f, i, x, Set, α, s, Set, α, s, l, i, ι, p, i, s, f, i] (during elaboration)

{α : Type u} {ι : Sort x} {f : (a : ι) → Filter α} {p : (a : ι) → Prop} {l : Filter α} (h : ∀ {s : Set α} , (s ∈ l : Prop) ↔ (∃ (i : ι) , (p i : Prop) ∧ (s ∈ f i : Prop) : Prop)) {x : Set α} (a : ι) (h : p a)  : (x ∈ f a) = (x ∈ f a)
unknown universe level 'x' ; identifiers [α, u, ι, x, f, a, ι, Filter, α, p, a, ι, l, Filter, α, h, s, Set, α, s, l, i, ι, p, i, s, f, i, x, Set, α, a, ι, h, p, a, x, f, a, x, f, a] (during elaboration)

{α : Type u} {ι : Sort x} {f : (a : ι) → Filter α} {p : (a : ι) → Prop} {l : Filter α} (h : ∀ {s : Set α} , (s ∈ l : Prop) ↔ (∃ (i : ι) , (p i : Prop) ∧ (s ∈ f i : Prop) : Prop)) {x : Set α} (a : ι)  : (p a) = (p a)
unknown universe level 'x' ; identifiers [α, u, ι, x, f, a, ι, Filter, α, p, a, ι, l, Filter, α, h, s, Set, α, s, l, i, ι, p, i, s, f, i, x, Set, α, a, ι, p, a, p, a] (during elaboration)

