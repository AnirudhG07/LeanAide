[
  {
    "tactic": "rw",
    "count": 47300
  },
  {
    "tactic": "exact",
    "count": 28769
  },
  {
    "tactic": "·",
    "count": 15538
  },
  {
    "tactic": "refine'",
    "count": 14221
  },
  {
    "tactic": "simp",
    "count": 13901
  },
  {
    "tactic": "have",
    "count": 12972
  },
  {
    "tactic": "apply",
    "count": 12920
  },
  {
    "tactic": "intro",
    "count": 11493
  },
  {
    "tactic": "rintro",
    "count": 6596
  },
  {
    "tactic": "rfl",
    "count": 6261
  },
  {
    "tactic": "ext",
    "count": 6069
  },
  {
    "tactic": "simpa",
    "count": 5848
  },
  {
    "tactic": "obtain",
    "count": 5573
  },
  {
    "tactic": "rcases",
    "count": 5081
  },
  {
    "tactic": "cases",
    "count": 4805
  },
  {
    "tactic": "by_cases",
    "count": 2918
  },
  {
    "tactic": "convert",
    "count": 2918
  },
  {
    "tactic": "rwa",
    "count": 2893
  },
  {
    "tactic": "let",
    "count": 2826
  },
  {
    "tactic": "constructor",
    "count": 2782
  },
  {
    "tactic": "cases'",
    "count": 2676
  },
  {
    "tactic": "refine",
    "count": 2214
  },
  {
    "tactic": "dsimp",
    "count": 2134
  },
  {
    "tactic": "congr",
    "count": 1997
  },
  {
    "tactic": "induction'",
    "count": 1764
  },
  {
    "tactic": "haveI",
    "count": 1747
  },
  {
    "tactic": "intros",
    "count": 1598
  },
  {
    "tactic": "erw",
    "count": 1535
  },
  {
    "tactic": "change",
    "count": 1392
  },
  {
    "tactic": "use",
    "count": 1313
  },
  {
    "tactic": "infer_instance",
    "count": 1251
  },
  {
    "tactic": "suffices",
    "count": 1107
  },
  {
    "tactic": "split_ifs",
    "count": 1033
  },
  {
    "tactic": "subst",
    "count": 987
  },
  {
    "tactic": "linarith",
    "count": 908
  },
  {
    "tactic": "letI",
    "count": 903
  },
  {
    "tactic": "ring",
    "count": 885
  },
  {
    "tactic": "induction",
    "count": 814
  },
  {
    "tactic": "norm_num",
    "count": 801
  },
  {
    "tactic": "ext1",
    "count": 797
  },
  {
    "tactic": "replace",
    "count": 755
  },
  {
    "tactic": "unfold",
    "count": 611
  },
  {
    "tactic": "assumption",
    "count": 597
  },
  {
    "tactic": "try",
    "count": 575
  },
  {
    "tactic": "aesop_cat",
    "count": 563
  },
  {
    "tactic": "norm_cast",
    "count": 520
  },
  {
    "tactic": "classical",
    "count": 505
  },
  {
    "tactic": "set",
    "count": 496
  },
  {
    "tactic": "funext",
    "count": 485
  },
  {
    "tactic": "decide",
    "count": 472
  },
  {
    "tactic": "calc",
    "count": 469
  },
  {
    "tactic": "first",
    "count": 466
  },
  {
    "tactic": "exacts",
    "count": 456
  },
  {
    "tactic": "exact_mod_cast",
    "count": 449
  },
  {
    "tactic": "contrapose!",
    "count": 449
  },
  {
    "tactic": "fin_cases",
    "count": 387
  },
  {
    "tactic": "clear",
    "count": 364
  },
  {
    "tactic": "case",
    "count": 362
  },
  {
    "tactic": "show",
    "count": 358
  },
  {
    "tactic": "revert",
    "count": 346
  },
  {
    "tactic": "lift",
    "count": 345
  },
  {
    "tactic": "field_simp",
    "count": 339
  },
  {
    "tactic": "swap",
    "count": 336
  },
  {
    "tactic": "conv_rhs",
    "count": 333
  },
  {
    "tactic": "specialize",
    "count": 330
  },
  {
    "tactic": "slice_lhs",
    "count": 312
  },
  {
    "tactic": "by_contra",
    "count": 301
  },
  {
    "tactic": "contradiction",
    "count": 295
  },
  {
    "tactic": "choose",
    "count": 295
  },
  {
    "tactic": "conv_lhs",
    "count": 287
  },
  {
    "tactic": "tauto",
    "count": 278
  },
  {
    "tactic": "symm",
    "count": 272
  },
  {
    "tactic": "gcongr",
    "count": 262
  },
  {
    "tactic": "positivity",
    "count": 244
  },
  {
    "tactic": "delta",
    "count": 244
  },
  {
    "tactic": "abel",
    "count": 242
  },
  {
    "tactic": "(",
    "count": 237
  },
  {
    "tactic": "slice_rhs",
    "count": 208
  },
  {
    "tactic": "{",
    "count": 204
  },
  {
    "tactic": "right",
    "count": 199
  },
  {
    "tactic": "push_cast",
    "count": 197
  },
  {
    "tactic": "trans",
    "count": 189
  },
  {
    "tactic": "push_neg",
    "count": 188
  },
  {
    "tactic": "aesop",
    "count": 184
  },
  {
    "tactic": "skip",
    "count": 184
  },
  {
    "tactic": "conv",
    "count": 178
  },
  {
    "tactic": "exfalso",
    "count": 177
  },
  {
    "tactic": "tfae_have",
    "count": 177
  },
  {
    "tactic": "left",
    "count": 170
  },
  {
    "tactic": "nth_rw",
    "count": 169
  },
  {
    "tactic": "injection",
    "count": 163
  },
  {
    "tactic": "apply_fun",
    "count": 153
  },
  {
    "tactic": "trivial",
    "count": 144
  },
  {
    "tactic": "norm_num1",
    "count": 140
  },
  {
    "tactic": "ring_nf",
    "count": 132
  },
  {
    "tactic": "pgame_wf_tac",
    "count": 127
  },
  {
    "tactic": "generalize",
    "count": 118
  },
  {
    "tactic": "subst_vars",
    "count": 116
  },
  {
    "tactic": "all_goals",
    "count": 116
  },
  {
    "tactic": "apply_rules",
    "count": 116
  },
  {
    "tactic": "repeat'",
    "count": 112
  },
  {
    "tactic": "done",
    "count": 110
  },
  {
    "tactic": "continuity",
    "count": 109
  },
  {
    "tactic": "by_contra'",
    "count": 108
  },
  {
    "tactic": "fapply",
    "count": 90
  },
  {
    "tactic": "inhabit",
    "count": 87
  },
  {
    "tactic": "introv",
    "count": 84
  },
  {
    "tactic": "exists",
    "count": 83
  },
  {
    "tactic": "solve_by_elim",
    "count": 77
  },
  {
    "tactic": "iterate",
    "count": 77
  },
  {
    "tactic": "rename_i",
    "count": 70
  },
  {
    "tactic": "nlinarith",
    "count": 69
  },
  {
    "tactic": "ac_rfl",
    "count": 69
  },
  {
    "tactic": "substs",
    "count": 67
  },
  {
    "tactic": "congr!",
    "count": 67
  },
  {
    "tactic": "borelize",
    "count": 62
  },
  {
    "tactic": "choose!",
    "count": 62
  },
  {
    "tactic": "simp_all",
    "count": 61
  },
  {
    "tactic": "ring1",
    "count": 58
  },
  {
    "tactic": "contrapose",
    "count": 51
  },
  {
    "tactic": "convert_to",
    "count": 47
  },
  {
    "tactic": "fconstructor",
    "count": 47
  },
  {
    "tactic": "wlog",
    "count": 47
  },
  {
    "tactic": "isBoundedDefault",
    "count": 43
  },
  {
    "tactic": "rotate_left",
    "count": 40
  },
  {
    "tactic": "linear_combination",
    "count": 40
  },
  {
    "tactic": "repeat",
    "count": 39
  },
  {
    "tactic": "cases_type",
    "count": 38
  },
  {
    "tactic": "tfae_finish",
    "count": 36
  },
  {
    "tactic": "split",
    "count": 34
  },
  {
    "tactic": "generalize_proofs",
    "count": 34
  },
  {
    "tactic": "injections",
    "count": 33
  },
  {
    "tactic": "any_goals",
    "count": 32
  },
  {
    "tactic": "casesm",
    "count": 32
  },
  {
    "tactic": "rw_mod_cast",
    "count": 30
  },
  {
    "tactic": "aesop_cat_nonterminal",
    "count": 29
  },
  {
    "tactic": "measurability",
    "count": 28
  },
  {
    "tactic": "match",
    "count": 27
  },
  {
    "tactic": "clear!",
    "count": 27
  },
  {
    "tactic": "apply_assumption",
    "count": 25
  },
  {
    "tactic": "nontriviality",
    "count": 24
  },
  {
    "tactic": "clear_value",
    "count": 22
  },
  {
    "tactic": "rsuffices",
    "count": 22
  },
  {
    "tactic": "on_goal",
    "count": 22
  },
  {
    "tactic": "next",
    "count": 22
  },
  {
    "tactic": "assumption_mod_cast",
    "count": 20
  },
  {
    "tactic": "pick_goal",
    "count": 20
  },
  {
    "tactic": "interval_cases",
    "count": 17
  },
  {
    "tactic": "classical!",
    "count": 16
  },
  {
    "tactic": "pure_coherence",
    "count": 16
  },
  {
    "tactic": "unit_interval",
    "count": 13
  },
  {
    "tactic": "nth_rewrite",
    "count": 12
  },
  {
    "tactic": "mono",
    "count": 11
  },
  {
    "tactic": "assumption'",
    "count": 8
  },
  {
    "tactic": "rcongr",
    "count": 8
  },
  {
    "tactic": "abel_nf",
    "count": 8
  },
  {
    "tactic": "apply_mod_cast",
    "count": 7
  },
  {
    "tactic": "triv",
    "count": 7
  },
  {
    "tactic": "ghost_calc",
    "count": 6
  },
  {
    "tactic": "rename",
    "count": 5
  },
  {
    "tactic": "find",
    "count": 4
  },
  {
    "tactic": "ring!",
    "count": 3
  },
  {
    "tactic": "infer_param",
    "count": 3
  },
  {
    "tactic": "· -- Porting note: simp used to be able to close this goal",
    "count": 3
  },
  {
    "tactic": "cancel_denoms",
    "count": 3
  },
  {
    "tactic": "clear_aux_decl",
    "count": 3
  },
  {
    "tactic": "· -- B₁.comp l r = B₂.comp l r → B₁ = B₂",
    "count": 2
  },
  {
    "tactic": "· -- B₁ = B₂ → B₁.comp l r = B₂.comp l r",
    "count": 2
  },
  {
    "tactic": "rotate_right",
    "count": 2
  },
  {
    "tactic": "· -- by construction, `s p` is `ε`-dense",
    "count": 2
  },
  {
    "tactic": "rename'",
    "count": 2
  },
  {
    "tactic": "· -- Porting note: this `show` wasn't needed in Lean 3",
    "count": 2
  },
  {
    "tactic": "· -- Porting note: added type ascription to LHS",
    "count": 2
  },
  {
    "tactic": "swap_var",
    "count": 2
  },
  {
    "tactic": "· -- Porting note: broken ext",
    "count": 2
  },
  {
    "tactic": "· -- Porting note : Lean can't use `Types.limit_ext'` as an `ext` lemma",
    "count": 2
  },
  {
    "tactic": "· -- This is just `hfg` run through `eventually_prod_iff`",
    "count": 2
  },
  {
    "tactic": "set!",
    "count": 2
  },
  {
    "tactic": "restrict_tac",
    "count": 2
  },
  {
    "tactic": "· -- case `b ≠ 0`",
    "count": 2
  },
  {
    "tactic": "· -- Porting note: had to add `rfl`, because `simp` only uses the built-in `rfl`.",
    "count": 2
  },
  {
    "tactic": "refine' -- pred",
    "count": 2
  },
  {
    "tactic": "refine\n      -- Porting note: removing the placeholders give an error",
    "count": 2
  },
  {
    "tactic": "· -- porting note: was `measurability`",
    "count": 2
  },
  {
    "tactic": "· -- Porting note: `rw [h1] at *` rewrites at `h1`",
    "count": 2
  },
  {
    "tactic": "repeat'\n    -- Porting note: why do we need to fill in the implicit `C` here, and below?",
    "count": 2
  },
  {
    "tactic": "classical\n      -- for Fintype (Subgroup.zpowers g)",
    "count": 1
  },
  {
    "tactic": "·-- case `ringChar F = 2`",
    "count": 1
  },
  {
    "tactic": "classical\n  -- Porting note: Originally `obtain ⟨ha, rfl⟩`\n  -- This is https://github.com/leanprover/std4/issues/62",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was simply `hp` as an argument above",
    "count": 1
  },
  {
    "tactic": "· /- First we prove that `F` is injective. Indeed, if `F x = F y` and `x ≠ y`, then we can find\n    `(U, V) ∈ s` such that `x ∈ U` and `y ∉ V`, hence `F x UV = 0 ≠ ε UV = F y UV`. -/",
    "count": 1
  },
  {
    "tactic": "· /- Now we prove that each neighborhood `V` of `x : X` include a preimage of a neighborhood of\n    `F x` under `F`. Without loss of generality, `V` belongs to `B`. Choose `U ∈ B` such that\n    `x ∈ V` and `closure V ⊆ U`. Then the preimage of the `(ε (U, V))`-neighborhood of `F x`\n    is included by `V`. -/",
    "count": 1
  },
  {
    "tactic": "· /- Finally, we prove that `F` is continuous. Given `δ > 0`, consider the set `T` of `(U, V) ∈ s`\n    such that `ε (U, V) ≥ δ`. Since `ε` tends to zero, `T` is finite. Since each `f` is continuous,\n    we can choose a neighborhood such that `dist (F y (U, V)) (F x (U, V)) ≤ δ` for any\n    `(U, V) ∈ T`. For `(U, V) ∉ T`, the same inequality is true because both `F y (U, V)` and\n    `F x (U, V)` belong to the interval `[0, ε (U, V)]`. -/",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was `replace h := pow_eq_zero h; rw [coe_coe] at h; simpa using hne.1`",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was `by norm_cast`",
    "count": 1
  },
  {
    "tactic": "· -- To show `𝓣 ≤ 𝓣₀`, we have to show that closed balls are `𝓣`-neighborhoods of 0.",
    "count": 1
  },
  {
    "tactic": "· -- Finally, to show `𝓣₀ ≤ 𝓣`, we simply argue that `id = (fun x ↦ x • 1)` is continuous from\n    -- `(𝕜, 𝓣₀)` to `(𝕜, 𝓣)` because `(•) : (𝕜, 𝓣₀) × (𝕜, 𝓣) → (𝕜, 𝓣)` is continuous.",
    "count": 1
  },
  {
    "tactic": "· -- In the case where `l` is surjective, we factor it as `φ : (E ⧸ l.ker) ≃ₗ[𝕜] 𝕜`. Note that\n    -- `E ⧸ l.ker` is T2 since `l.ker` is closed.",
    "count": 1
  },
  {
    "tactic": "· -- if `f` is not integrable, both `setToFun` are 0.",
    "count": 1
  },
  {
    "tactic": "· -- `j z a = z / (a + 1)`: we prove that this ratio is close to `α`",
    "count": 1
  },
  {
    "tactic": "· -- check that `u ∪ {a'}` is made of elements of `t`.",
    "count": 1
  },
  {
    "tactic": "· -- Check that `u ∪ {a'}` is a disjoint family. This follows from the fact that `a'` does not\n    -- intersect `u`.",
    "count": 1
  },
  {
    "tactic": "· -- `NullMeasurableSet I volume`",
    "count": 1
  },
  {
    "tactic": "· -- `∀ (g : G), g ≠ 0 → AEDisjoint volume (g +ᵥ I) I`",
    "count": 1
  },
  {
    "tactic": "· -- `∀ (g : G), QuasiMeasurePreserving (VAdd.vadd g) volume volume`",
    "count": 1
  },
  {
    "tactic": "· -- `volume univ ≤ ∑' (g : G), volume (g +ᵥ I)`",
    "count": 1
  },
  {
    "tactic": "· --the kernel of the map is clearly `(I * S) ∩ R<x>`. To get injectivity, we need to show that\n    --this is contained in `I * R<x>`, which is the content of the previous lemma.",
    "count": 1
  },
  {
    "tactic": "· -- porting note: todo: Lean fails to find InvMemClass instance",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: issues with synthesizing Algebra R S",
    "count": 1
  },
  {
    "tactic": "transitivity",
    "count": 1
  },
  {
    "tactic": "· -- φ : S → Sᶜ is injective",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: Here was one `exact`, but timeouted.",
    "count": 1
  },
  {
    "tactic": "· -- integral is continuous",
    "count": 1
  },
  {
    "tactic": "· -- `(π / b) ^ (1 / 2 : ℂ)` is continuous",
    "count": 1
  },
  {
    "tactic": "· -- RHS doesn't vanish",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was `nlinarith`",
    "count": 1
  },
  {
    "tactic": "·-- 5 ≤ fib 5",
    "count": 1
  },
  {
    "tactic": "· -- n + 1 ≤ fib (n + 1) for 5 ≤ n",
    "count": 1
  },
  {
    "tactic": "· -- Main case : `0 < y < π / 2`",
    "count": 1
  },
  {
    "tactic": "· -- Easy case : `π / 2 ≤ y ≤ 3 * π / 2`",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: makes instance metavariable like in Lean 3",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: used to be exact _|>. hg i j but that can't find an instance",
    "count": 1
  },
  {
    "tactic": "· -- `v` is an infinite basis,\n    -- so by `infinite_basis_le_maximal_linearIndependent`, `v'` is at least as big,\n    -- and then applying `infinite_basis_le_maximal_linearIndependent` again\n    -- we see they have the same cardinality.",
    "count": 1
  },
  {
    "tactic": "· -- and otherwise we have `linearIndependent_le_infinite_basis`.",
    "count": 1
  },
  {
    "tactic": "· -- porting note: was ext; · rfl; apply hEq_of_eq",
    "count": 1
  },
  {
    "tactic": "· -- porting note: was `continuity`",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: Rewrote this proof",
    "count": 1
  },
  {
    "tactic": "· -- If there exists `δ ∈ (0, ε)`, then we choose `δ`-nhd of `a` and `(ε-δ)`-nhd of `b`",
    "count": 1
  },
  {
    "tactic": "· -- Otherwise `ε`-nhd of each point `a` is `{a}`",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was `unfold LinearMap.det`",
    "count": 1
  },
  {
    "tactic": "exact  -- porting note: added `GCDMonoid.` twice",
    "count": 1
  },
  {
    "tactic": "· -- remaining goal 1",
    "count": 1
  },
  {
    "tactic": "· -- Now we just need to check that the lift we picked was the only possible one.\n      -- So we suppose we had some other gluing `t` of our sections",
    "count": 1
  },
  {
    "tactic": "· -- Claim: `1 ≤ ⇑norm_sq ↑(g • z)`. If not, then `S•g•z` has larger imaginary part",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was\n    -- linarith [hp.out.one_lt, le_of_lt hp.out.one_lt]",
    "count": 1
  },
  {
    "tactic": "· /- human proof:\n        Let g ∈ Γₛₜ 𝒢 x be a germ. Represent it on an open set U ⊆ X\n        as ⟨t, U⟩. By local surjectivity, pass to a smaller open set V\n        on which there exists s ∈ Γ_ ℱ V mapping to t |_ V.\n        Then the germ of s maps to g -/\n    -- Let g ∈ Γₛₜ 𝒢 x be a germ.",
    "count": 1
  },
  {
    "tactic": "· -- i ≠ j: this entry should be 0",
    "count": 1
  },
  {
    "tactic": "· -- Everything except `(i , j)` (= `(σ j , j)`) is given by A, and the rest is a single `1`.",
    "count": 1
  },
  {
    "tactic": "· -- This feels a little redundant, since already have `ht_cover` as a hypothesis\n    -- Unfortunately, `ht_cover` uses a bounded union over the set `t`, while here we have the\n    -- Union indexed by the type `tt`, so we need some boilerplate to translate one to the other",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: `convert` needed help",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: added `congr_arg`",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: `← Function.comp.assoc` & `-Equiv.Perm.sign_swap'` are required.",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: Explicitly specify `c`.",
    "count": 1
  },
  {
    "tactic": "· -- Check that `F` is continuous, as a uniform limit of continuous functions",
    "count": 1
  },
  {
    "tactic": "· -- Check that `F` is bounded",
    "count": 1
  },
  {
    "tactic": "· -- Check that `F` is close to `f N` in distance terms",
    "count": 1
  },
  {
    "tactic": "· -- ψ₁ is the continuous ring hom `ℂ →+* ℂ` constructed from `closure (K) ≃+* ℂ`\n      -- and `extψ : closure (K) →+* ℂ`",
    "count": 1
  },
  {
    "tactic": "· -- extψ : closure(K) →+* ℂ is the extension of ψ : K →+* ℂ",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: This case was\n            -- `exact WithBot.some_le_some.2 ⟨iInf₂_le _ ha, le_iSup₂_of_le _ ha le_rfl⟩`\n            -- but there seems to be a defEq-problem at `iInf₂_le` that lean cannot resolve yet.",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: ungolfed, due to identification problems\n                -- between `toProd` and `toDualProd`. Original mathport output:\n                -- cases h fun t hb c hc =>\n                --   (WithBot.coe_le_coe.1 <| ha _ hb).1.trans <|\n                --     s.fst_le_snd.trans (WithBot.coe_le_coe.1 <| ha _ hc).2 }",
    "count": 1
  },
  {
    "tactic": "· -- here we need to help the elaborator with an explicit instantiation",
    "count": 1
  },
  {
    "tactic": "· -- the remaining step of the calculation above",
    "count": 1
  },
  {
    "tactic": "· -- `e = left chart`, `e' = left chart`",
    "count": 1
  },
  {
    "tactic": "·-- `e = right chart`, `e' = right chart`",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: originally this was\n        -- rintro x (rfl | hx)\n        -- exacts [Or.inl (Set.mem_singleton x), Or.inr (hl.2 x hx)]\n      -- but this fails because `List.Mem` is now an inductive prop.\n      -- I couldn't work out how to drive `rcases` here but asked at\n      -- https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/rcases.3F/near/347976083",
    "count": 1
  },
  {
    "tactic": "· -- Base case: `0 < re s`, so Gamma is given by the integral formula",
    "count": 1
  },
  {
    "tactic": "· -- Induction step: use recurrence formulae in `s` for Gamma and GammaSeq",
    "count": 1
  },
  {
    "tactic": "· -- first deal with silly case z = integer",
    "count": 1
  },
  {
    "tactic": "· -- x > 0 : easy case",
    "count": 1
  },
  {
    "tactic": "· -- x = 0 : reduce to continuousAt_cpow_zero_of_re_pos",
    "count": 1
  },
  {
    "tactic": "· -- x < 0 : difficult case",
    "count": 1
  },
  {
    "tactic": ".",
    "count": 1
  },
  {
    "tactic": "· -- An intermediate claim used to apply induction along `G : Finset J` later on.",
    "count": 1
  },
  {
    "tactic": "· -- conclude...",
    "count": 1
  },
  {
    "tactic": "classical\n  -- The limit cone for `F` whose topology is defined as an infimum.",
    "count": 1
  },
  {
    "tactic": "match_target",
    "count": 1
  },
  {
    "tactic": "guard_hyp",
    "count": 1
  },
  {
    "tactic": "· -- Then we check that the formula, being a composition of `ContDiff` pieces, is\n      -- itself `ContDiff`",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was\n      -- rw [indicator_of_not_mem (not_mem_Ioo_of_le ht), indicator_of_not_mem (not_mem_Ioi.mpr ht),\n      --   ContinuousLinearMap.map_zero, ContinuousLinearMap.zero_apply]",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was\n      -- rw [indicator_of_mem ht, indicator_of_mem (mem_Ioi.mpr ht.1),\n      --     indicator_of_mem (mem_Ioi.mpr <| sub_pos.mpr ht.2)]",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was\n      -- rw [indicator_of_not_mem (not_mem_Ioo_of_ge ht),\n      --     indicator_of_not_mem (not_mem_Ioi.mpr (sub_nonpos_of_le ht)),\n      --     ContinuousLinearMap.map_zero]",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was\n      -- rw [indicator_of_not_mem (_ : x - t ∉ Ioi 0), ContinuousLinearMap.map_zero]",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was\n      -- rw [indicator_of_not_mem (mem_Ioi.not.mpr ht), ContinuousLinearMap.map_zero,\n      --  ContinuousLinearMap.zero_apply]",
    "count": 1
  },
  {
    "tactic": "· -- The easy case: `s ≠ 0`",
    "count": 1
  },
  {
    "tactic": "· -- Note the case n = 0 (i.e. s = 1) works OK here, but only because we have used\n    -- `Function.update_noteq` to change the goal; the original goal is genuinely false for s = 1.",
    "count": 1
  },
  {
    "tactic": "·-- k = 0 : evaluate explicitly",
    "count": 1
  },
  {
    "tactic": "· -- k = 2 * (m + 1) : both sides \"trivially\" zero",
    "count": 1
  },
  {
    "tactic": "classical\n  -- Porting note : use the same universe level",
    "count": 1
  },
  {
    "tactic": "· -- Porting note(https://github.com/leanprover-community/mathlib4/issues/5072): was `use`",
    "count": 1
  },
  {
    "tactic": "· -- porting note: Lean 3 had `(FreeCommRing.lift _).map_neg` but I needed to replace it with\n  -- `RingHom.map_neg` to get the rewrite to compile",
    "count": 1
  },
  {
    "tactic": "· -- porting note: was `(restriction _).map_add`",
    "count": 1
  },
  {
    "tactic": "· -- Easy case #1: 0 ∉ [a, b] -- use continuity.",
    "count": 1
  },
  {
    "tactic": "· -- Easy case #2: 0 < re r -- again use continuity",
    "count": 1
  },
  {
    "tactic": "· -- case `c < 0`: integrand is identically constant, *except* at `x = 0` if `r ≠ 0`.",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was `change ... with ...`",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: added `⟨⟩` brackets and reordered goals",
    "count": 1
  },
  {
    "tactic": "· -- the product is invertible because all the factors are",
    "count": 1
  },
  {
    "tactic": "· /- If `(c, d) = ∅`, then let `ed` be a trivialization of `proj` over a neighborhood of `d`.\n      Then the disjoint union of `ec` restricted to `(-∞, d)` and `ed` restricted to `(c, ∞)` is\n      a trivialization over `[a, d]`. -/",
    "count": 1
  },
  {
    "tactic": "· /- If `(c, d)` is nonempty, then take `d' ∈ (c, d)`. Since the base set of `ec` includes\n          `[a, d)`, it includes `[a, d'] ⊆ [a, d)` as well. -/",
    "count": 1
  },
  {
    "tactic": "· -- We need to show that `f` has bounded norm. Choose `C` such that `‖g‖ ≤ C` for all `g ∈ s`.",
    "count": 1
  },
  {
    "tactic": "·-- We use the volume as an upper estimate.",
    "count": 1
  },
  {
    "tactic": "ext\n      -- porting note: was `simp only [...]`",
    "count": 1
  },
  {
    "tactic": "· -- If `m` is an even number, then `(m / 2) * p` can be represented as a sum of four squares",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: fails without this line\n    -- This will presumably be fixed by the changes discussed at\n    -- https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/!4.232894/near/342121059",
    "count": 1
  },
  {
    "tactic": "· -- take a set set t which is nonempty and at a finite distance of s",
    "count": 1
  },
  {
    "tactic": "lift_lets",
    "count": 1
  },
  {
    "tactic": "calc\n    -- porting note: needs extra annotations, no longer unifies against the goal in the face of\n    -- ambiguity",
    "count": 1
  },
  {
    "tactic": "· -- b = f",
    "count": 1
  },
  {
    "tactic": "· -- Porting note : need more hand holding here because Lean knows that\n      -- `CommRing.ofHom ...` is iso, but without `ofHom` Lean does not know what to do",
    "count": 1
  },
  {
    "tactic": "· -- In the non-trivial case `∀ i, a i < b i`, we apply a lemma we proved above.",
    "count": 1
  },
  {
    "tactic": "· -- porting note: was compute_degree_le; repeat' rwa [Nat.sub_add_cancel]",
    "count": 1
  },
  {
    "tactic": "· -- in this case, f is constant because all values are at top",
    "count": 1
  },
  {
    "tactic": "· -- Base case: `n = 0`, the fixed subspace is the whole space, so `φ = id`",
    "count": 1
  },
  {
    "tactic": "· -- porting note: was `linarith [unitInterval.nonneg t, unitInterval.le_one t]` but `linarith`\n    -- doesn't know about `ℚ` yet. https://github.com/leanprover-community/mathlib4/issues/2714\n    -- porting note: although `linarith` now knows about `ℚ`, it still fails here as it doesn't\n    -- find `LinearOrder X`.",
    "count": 1
  },
  {
    "tactic": "· -- Show that it maps each index to the corresponding finite set",
    "count": 1
  },
  {
    "tactic": "· -- The reverse direction is a straightforward cardinality argument",
    "count": 1
  },
  {
    "tactic": "· -- Otherwise, `b ≤ a`, and the interval is a subsingleton,\n    -- so all subalgebras are the same anyway.",
    "count": 1
  },
  {
    "tactic": "norm_cast0",
    "count": 1
  },
  {
    "tactic": "· -- If Left played in -x, Right responds with the same move in x.",
    "count": 1
  },
  {
    "tactic": "· -- If Left in x, Right responds with the same move in -x.",
    "count": 1
  },
  {
    "tactic": "· -- `convert` here is faster than `exact`, and this proof is near the time limit.\n      -- convert isIntegral_isLocalization_polynomial_quotient P pX hpX",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was `rcases minimal_nonempty_open_eq_singleton ho hne _ with ⟨x, hx⟩`\n    --               https://github.com/leanprover/std4/issues/116",
    "count": 1
  },
  {
    "tactic": "ext\n    -- Porting note: why doesn't `simp` work here?",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: squeezed simp",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: this branch had been:\n      -- simpa only [Homotopy.dNext_succ_chainComplex, Homotopy.prevD_chainComplex,\n      --   HomologicalComplex.id_f, PInfty_f, ← P_is_eventually_constant (rfl.le : n + 1 ≤ n + 1),\n      --   homotopyPToId_eventually_constant X (lt_add_one (n + 1))] using\n      --   (homotopyPToId X (n + 2)).comm (n + 1)\n      -- which fails on leanprover/lean4:nightly-2023-05-16 due to\n      -- https://github.com/leanprover/lean4/pull/2146\n      -- The `erw` below clunkily works around this.",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: behavior of `@` changed relative to lean 3, was\n      -- exact fun i => (@measurable_prod_mk_left β γ _ _ b) _ (hf_meas i)",
    "count": 1
  },
  {
    "tactic": "· -- case `‖c i‖ ≤ 2`",
    "count": 1
  },
  {
    "tactic": "· -- case `2 < ‖c i‖`",
    "count": 1
  },
  {
    "tactic": "simpa!",
    "count": 1
  },
  {
    "tactic": "run_tac",
    "count": 1
  },
  {
    "tactic": "open",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was\n        -- exact fun n => eventually_of_forall fun y =>\n        --   SimpleFunc.norm_approxOn_zero_le _ _ (x, y) n",
    "count": 1
  },
  {
    "tactic": "· -- porting note: Lean does not automatically synthesize the instance\n    -- `[Subsingleton (Fin 0 → M)]` which is needed for `Subsingleton.elim 0 v` on line 114.",
    "count": 1
  },
  {
    "tactic": "focus",
    "count": 1
  },
  {
    "tactic": "· -- To prove that `n` is coprime with `b`, we need to show that for all prime factors of `n`,\n    -- we can derive a contradiction if `n` divides `b`.",
    "count": 1
  },
  {
    "tactic": "· /- Since each `f (Nx $ π.tag J)` is `ε`-close to `g (π.tag J)`, replacing the latter with\n        the former in the formula for the integral sum changes the sum at most by `μ I * ε`. -/",
    "count": 1
  },
  {
    "tactic": "· /-  For the last jump, we use the fact that the distance between `f (Nx x) x` and `g x` is less\n        than or equal to the distance between `f N₀ x` and `g x` and the integral of\n        `‖f N₀ x - g x‖` is less than or equal to `ε`. -/",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: Originally `simpa [Wbtw, affineSegment] using h`",
    "count": 1
  },
  {
    "tactic": "· -- The integral from 1 to ∞ is zero:",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: infer_instance fails because it applies `Finite.of_fintype` and produces a\n    -- \"stuck at solving universe constraint\" error.",
    "count": 1
  },
  {
    "tactic": "· -- use the IH to show that the following equality suffices",
    "count": 1
  },
  {
    "tactic": "· -- Our first goal is to show that this chosen gluing satisfies the\n      -- predicate. Of course, we use locality of the predicate.",
    "count": 1
  },
  {
    "tactic": "classical\n    -- Introduce shorthand for span of an element",
    "count": 1
  },
  {
    "tactic": "· -- We construct a map x : ℕ → α with dense image",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: `Finset.le_sup` needed some helps",
    "count": 1
  },
  {
    "tactic": "· -- If `ζ.im = 0`, then `Complex.exp ζ` is a positive real number",
    "count": 1
  },
  {
    "tactic": "· -- If `ζ.im = π / 2`, then `Complex.exp ζ` is a purely imaginary number with positive `im`",
    "count": 1
  },
  {
    "tactic": "·-- If `‖f x₀‖ ≤ C`, then `hle` implies the required estimate",
    "count": 1
  },
  {
    "tactic": "· -- Otherwise, `‖f z‖ ≤ ‖f x₀‖` for all `z` in the right half-plane due to `hle`.",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was\n      -- convert mul_comm _ _ using 2\n      -- simp",
    "count": 1
  },
  {
    "tactic": "· -- pair cf cg",
    "count": 1
  },
  {
    "tactic": "· --comp hf hg",
    "count": 1
  },
  {
    "tactic": "classical\n  -- to avoid having to show that the predicate is decidable",
    "count": 1
  },
  {
    "tactic": "· -- case 2: `a ≥ a₁`",
    "count": 1
  },
  {
    "tactic": "all_goals\n-- porting note: wlog not implemented yet, the following replaces the three previous lines\n-- wlog (discharger := tactic.skip) hab : a ≤ b := le_total a b using a b s t, b a t s",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: was\n      -- `simpa [orderedInsert, h', h] using fun b' bm => trans h' (rel_of_sorted_cons h _ bm)`",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: without the explicit argument Lean is not sure of the type.",
    "count": 1
  },
  {
    "tactic": "· -- the rest of the proof is a straightforward calculation",
    "count": 1
  },
  {
    "tactic": "· -- as `K` is closed and non-empty, it is pointed",
    "count": 1
  },
  {
    "tactic": "· -- Porting note : `ext` can't see `limit.hom_ext` applies here:\n    -- See https://github.com/leanprover-community/mathlib4/issues/5229",
    "count": 1
  },
  {
    "tactic": "· -- m even, n even",
    "count": 1
  },
  {
    "tactic": "· -- m even, n odd",
    "count": 1
  },
  {
    "tactic": "· -- m odd, n even",
    "count": 1
  },
  {
    "tactic": "· -- m odd, n odd",
    "count": 1
  },
  {
    "tactic": "· -- If `n = 5`, then `g` is itself a 5-cycle, conjugate to `finRotate 5`.",
    "count": 1
  },
  {
    "tactic": "· -- porting note: middle lemma now needs `erw` as `ENNReal` does not reduce to `WithTop NNReal`\n    -- https://github.com/leanprover-community/mathlib4/issues/5164",
    "count": 1
  },
  {
    "tactic": "· -- Map each vertex using the homomorphism provided for its singleton subgraph.",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: mathlib3 `continuity` found `continuous_set_coe`",
    "count": 1
  },
  {
    "tactic": "· -- This is also an element of the subalgebra, and takes only real values",
    "count": 1
  },
  {
    "tactic": "· -- And it also separates the points `x₁`, `x₂`",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: The previous code was:\n      -- rintro ⟨_, rfl, rfl, _⟩\n      -- rfl\n      --\n      -- The code reports an error for the second `rfl`.",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: Previous proof was `decide`",
    "count": 1
  },
  {
    "tactic": "· -- Porting note: avoided some defeq abuse",
    "count": 1
  }
]