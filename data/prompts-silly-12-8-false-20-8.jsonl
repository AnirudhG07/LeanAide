{"text": "Every prime number is `2` or odd.", "fullPrompt": "/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0 :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/\ntheorem {n : ℕ} : is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ℕ | x ≠ 0} :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem (p : ℕ) [hp : fact (nat.prime p)] : prime ↑p ↔ p % 4 = 3 :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem (p' : ℕ) : 2 < lucas_lehmer.q (p' + 2) :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1 :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1 :=\n\n/-- Every prime number is `2` or odd. -/\ntheorem "}
{"text": "There are infinitely many odd natural numbers.", "fullPrompt": "/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0 :=\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/\ntheorem {n : ℕ} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- **Cantor's theorem** -/\ntheorem (a : cardinal) : a < 2 ^ a :=\n\n/-- The cardinality of the antidiagonal of `n` is `n+1`. -/\ntheorem (n : ℕ) : ⇑multiset.card (multiset.nat.antidiagonal n) = n + 1 :=\n\n/-- The golden ratio is irrational. -/\ntheorem  : irrational golden_ratio :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ≥ b 3. n ∈ Ico a b -/\ntheorem (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b :=\n\n/-- If `s.nth n = some aₙ` for some value `aₙ`, then there is also some value `aₘ` such that `s.nth = some aₘ` for `m ≤ n`. -/\ntheorem {α : Type u} (s : seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n) (s_nth_eq_some : s.nth n = option.some aₙ) : ∃ (aₘ : α), s.nth m = option.some aₘ :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- There are infinitely many odd natural numbers. -/\ntheorem "}
{"text": "The smallest odd prime is `3`.", "fullPrompt": "/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem (p' : ℕ) : 2 < lucas_lehmer.q (p' + 2) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1 :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : zmod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] {a : zmod p} (ha : a ≠ 0) : a ^ (p - 1) = 1 :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a :=\n\n/-- `legendre_sym p (-1)` is given by `χ₄ p`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) : zmod.legendre_sym p (-1) = ⇑zmod.χ₄ ↑p :=\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/\ntheorem {n : ℕ} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0 :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem (p : ℕ) [hp : fact (nat.prime p)] : prime ↑p ↔ p % 4 = 3 :=\n\n/-- `legendre_sym p a = -1` iff`a` is a nonsquare mod `p`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] {a : ℤ} : zmod.legendre_sym p a = -1 ↔ ¬is_square ↑a :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n :=\n\n/--  If `irreducible (cyclotomic (p ^ (k + 1)) K)` (in particular for `K = ℚ`) and `p` is an odd prime, then the norm of `zeta (p ^ (k + 1)) K L - 1` is `p`. -/\ntheorem {p : ℕ+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ↑↑p] {k : ℕ} [hpri : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (h : p ≠ 2) : ⇑(algebra.norm K) (is_cyclotomic_extension.zeta (p ^ (k + 1)) K L - 1) = ↑p :=\n\n/--  If `irreducible (cyclotomic p K)` (in particular for `K = ℚ`) and `p` is an odd prime, then the norm of `zeta p K L - 1` is `p`. -/\ntheorem {p : ℕ+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ↑↑p] [hpri : fact (nat.prime ↑p)] [hcyc : is_cyclotomic_extension {p} K L] (hirr : irreducible (polynomial.cyclotomic ↑p K)) (h : p ≠ 2) : ⇑(algebra.norm K) (is_cyclotomic_extension.zeta p K L - 1) = ↑p :=\n\n/-- The smallest odd prime is `3`. -/\ntheorem "}
{"text": "There are infinitely many odd prime numbers.", "fullPrompt": "/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/\ntheorem {n : ℕ} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0 :=\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0 :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem (p' : ℕ) : 2 < lucas_lehmer.q (p' + 2) :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- A version of `nat.exists_infinite_primes` using the `bdd_above` predicate. -/\ntheorem  : ¬bdd_above {p : ℕ | nat.prime p} :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ℕ | x ≠ 0} :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1 :=\n\n/--  If `irreducible (cyclotomic (p ^ (k + 1)) K)` (in particular for `K = ℚ`) and `p` is an odd prime, then the norm of `zeta (p ^ (k + 1)) K L - 1` is `p`. -/\ntheorem {p : ℕ+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ↑↑p] {k : ℕ} [hpri : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (h : p ≠ 2) : ⇑(algebra.norm K) (is_cyclotomic_extension.zeta (p ^ (k + 1)) K L - 1) = ↑p :=\n\n/--  If `irreducible (cyclotomic p K)` (in particular for `K = ℚ`) and `p` is an odd prime, then the norm of `zeta p K L - 1` is `p`. -/\ntheorem {p : ℕ+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ↑↑p] [hpri : fact (nat.prime ↑p)] [hcyc : is_cyclotomic_extension {p} K L] (hirr : irreducible (polynomial.cyclotomic ↑p K)) (h : p ≠ 2) : ⇑(algebra.norm K) (is_cyclotomic_extension.zeta p K L - 1) = ↑p :=\n\n/-- There are infinitely many odd prime numbers. -/\ntheorem "}
{"text": "If a vector space has dimension `2` then it is finite dimensional.", "fullPrompt": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V) : finite_dimensional K V :=\n\n/-- A finite dimensional space is nontrivial if it has positive `finrank`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V :=\n\n/-- A finite dimensional space that is a subsingleton has zero `finrank`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0 :=\n\n/-- A module has dimension 1 iff there is some `v : V` so `{v}` is a basis. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] : finite_dimensional.finrank K V = 1 ↔ nonempty (basis ι K V) :=\n\n/--  In a finite-dimensional space, its dimension (seen as a cardinal) coincides with its `finrank`. -/\ntheorem (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : ↑(finite_dimensional.finrank K V) = module.rank K V :=\n\n/-- A nontrivial finite dimensional space has positive `finrank`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V :=\n\n/-- A finite dimensional space has positive `finrank` iff it has a nonzero element. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ ∃ (x : V), x ≠ 0 :=\n\n/-- A finite dimensional space has positive `finrank` iff it is nontrivial. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ nontrivial V :=\n\n/-- In an `n`-dimensional space, the rank is at most `m`. -/\ntheorem {R : Type u_1} [ring R] [strong_rank_condition R] (n : ℕ) {m : ℕ} (v : fin m → fin n → R) : linear_independent R v → m ≤ n :=\n\n/-- A free module with a basis indexed by a `fintype` is finite. -/\ntheorem {R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) : module.finite R M :=\n\n/-- A division_ring is one-dimensional as a vector space over itself. -/\ntheorem (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1 :=\n\n/--  A finite dimensional space has zero `finrank` iff it is a subsingleton. This is the `finrank` version of `dim_zero_iff`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 ↔ subsingleton V :=\n\n/--  A vector space has dimension at most `1` if and only if there is a single vector of which all vectors are multiples. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : module.rank K V ≤ 1 ↔ ∃ (v₀ : V), ∀ (v : V), ∃ (r : K), r • v₀ = v :=\n\n/-- If a vector space has dimension `2` then it is finite dimensional. -/\ntheorem "}
{"text": "Every field is a division ring.", "fullPrompt": "/-- A division_ring is one-dimensional as a vector space over itself. -/\ntheorem (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1 :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n :=\n\n/-- `ℤ` with its usual ring structure is not a field. -/\ntheorem  : ¬is_field ℤ :=\n\n/-- `polynomial R` is never a field for any ring `R`. -/\ntheorem {R : Type u} [ring R] : ¬is_field (polynomial R) :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c :=\n\n/-- When multiplication is commutative, `star` preserves division. -/\ntheorem {R : Type u} [field R] [star_ring R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y :=\n\n/-- When multiplication is commutative, `star` preserves division. -/\ntheorem {R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a :=\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem {Γ₀ : Type u_3} [linear_ordered_comm_monoid_with_zero Γ₀] [nontrivial Γ₀] {K : Type u_1} [division_ring K] (v : valuation K Γ₀) {x : K} : ⇑v x = 0 ↔ x = 0 :=\n\n/-- An element of an algebra over a field is algebraic if and only if it is integral. -/\ntheorem {K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x ↔ is_integral K x :=\n\n/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.finite K V :=\n\n/--  In a noetherian module over a division ring, if a basis is indexed by a set, that set is finite. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type u_1} {s : set ι} [is_noetherian K V] (b : basis ↥s K V) : s.finite :=\n\n/--  Over a characteristic-zero division ring, the centroids of two faces of a simplex are equal if and only if those faces are given by the same subset of points. -/\ntheorem {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : ℕ} (s : affine.simplex k P n) {fs₁ fs₂ : finset (fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.card = m₁ + 1) (h₂ : fs₂.card = m₂ + 1) : finset.centroid k finset.univ (s.face h₁).points = finset.centroid k finset.univ (s.face h₂).points ↔ fs₁ = fs₂ :=\n\n/--  The dimension of a noetherian module over a division ring, as a cardinal, is strictly less than the first infinite cardinal `ℵ₀`. -/\ntheorem (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : module.rank K V < cardinal.aleph_0 :=\n\n/--  Over a characteristic-zero division ring, the centroids given by two subsets of the points of a simplex are equal if and only if those faces are given by the same subset of points. -/\ntheorem {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : ℕ} (s : affine.simplex k P n) {fs₁ fs₂ : finset (fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.card = m₁ + 1) (h₂ : fs₂.card = m₂ + 1) : finset.centroid k fs₁ s.points = finset.centroid k fs₂ s.points ↔ fs₁ = fs₂ :=\n\n/-- Every field is a division ring. -/\ntheorem "}
{"text": "If a space has dimension `2` then it is finite dimensional.", "fullPrompt": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V) : finite_dimensional K V :=\n\n/-- A finite dimensional space is nontrivial if it has positive `finrank`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V :=\n\n/-- A finite dimensional space that is a subsingleton has zero `finrank`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0 :=\n\n/--  In a finite-dimensional space, its dimension (seen as a cardinal) coincides with its `finrank`. -/\ntheorem (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : ↑(finite_dimensional.finrank K V) = module.rank K V :=\n\n/-- A nontrivial finite dimensional space has positive `finrank`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V :=\n\n/-- A finite dimensional space has positive `finrank` iff it is nontrivial. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ nontrivial V :=\n\n/-- A finite dimensional space has positive `finrank` iff it has a nonzero element. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ ∃ (x : V), x ≠ 0 :=\n\n/-- In an `n`-dimensional space, the rank is at most `m`. -/\ntheorem {R : Type u_1} [ring R] [strong_rank_condition R] (n : ℕ) {m : ℕ} (v : fin m → fin n → R) : linear_independent R v → m ≤ n :=\n\n/-- A module has dimension 1 iff there is some `v : V` so `{v}` is a basis. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] : finite_dimensional.finrank K V = 1 ↔ nonempty (basis ι K V) :=\n\n/--  A finite dimensional space has zero `finrank` iff it is a subsingleton. This is the `finrank` version of `dim_zero_iff`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 ↔ subsingleton V :=\n\n/-- A free module with a basis indexed by a `fintype` is finite. -/\ntheorem {R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) : module.finite R M :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0 :=\n\n/--  A vector space has dimension at most `1` if and only if there is a single vector of which all vectors are multiples. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : module.rank K V ≤ 1 ↔ ∃ (v₀ : V), ∀ (v : V), ∃ (r : K), r • v₀ = v :=\n\n/-- If a space has dimension `2` then it is finite dimensional. -/\ntheorem "}
{"text": "Every natural number has a successor.", "fullPrompt": "/-- If `s.nth n = some aₙ` for some value `aₙ`, then there is also some value `aₘ` such that `s.nth = some aₘ` for `m ≤ n`. -/\ntheorem {α : Type u} (s : seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n) (s_nth_eq_some : s.nth n = option.some aₙ) : ∃ (aₘ : α), s.nth m = option.some aₘ :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ℕ | x ≠ 0} :=\n\n/-- `a ≤ b` as natural numbers if and only if `a ≤ b` in `fin n`. -/\ntheorem {n : ℕ} {a b : fin n} : ↑a ≤ ↑b ↔ a ≤ b :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- `a < b` as natural numbers if and only if `a < b` in `fin n`. -/\ntheorem {n : ℕ} {a b : fin n} : ↑a < ↑b ↔ a < b :=\n\n/-- Another way of expressing `strong_induction_on`: the `(<)` relation is well-founded. -/\ntheorem {α : Type u_1} : well_founded has_lt.lt :=\n\n/--  Every x greater than or equal to 1 is between two successive natural-number powers of every y greater than one. -/\ntheorem {α : Type u_1} [linear_ordered_ring α] [archimedean α] {x y : α} (hx : 1 ≤ x) (hy : 1 < y) : ∃ (n : ℕ), y ^ n ≤ x ∧ x < y ^ (n + 1) :=\n\n/--  The \"greater than\" relation on `upto p` is well founded if (and only if) there exists a value satisfying `p`. -/\ntheorem {p : ℕ → Prop} : (∃ (x : ℕ), p x) → well_founded (nat.upto.gt p) :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ≥ b 3. n ∈ Ico a b -/\ntheorem (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b :=\n\n/-- `ordinal.induction` but for `nat_ordinal`. -/\ntheorem {p : nat_ordinal → Prop} (i : nat_ordinal) (h : ∀ (j : nat_ordinal), (∀ (k : nat_ordinal), k < j → p k) → p j) : p i :=\n\n/--  Reformulation of well founded induction on ordinals as a lemma that works with the `induction` tactic, as in `induction i using ordinal.induction with i IH`. -/\ntheorem {p : ordinal → Prop} (i : ordinal) (h : ∀ (j : ordinal), (∀ (k : ordinal), k < j → p k) → p j) : p i :=\n\n/--  The cast of the successor is the succesor of the cast. See `fin.succ_cast_eq` for rewriting in the reverse direction. -/\ntheorem {n n' : ℕ} (i : fin n) (h : n.succ = n'.succ) : ⇑(fin.cast h) i.succ = (⇑(fin.cast _) i).succ :=\n\n/-- The Union of connected sets indexed by a subset of a type with an archimedean successor  (like `ℕ` or `ℤ`) such that any two neighboring sets meet is preconnected. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [linear_order β] [succ_order β] [is_succ_archimedean β] {s : β → set α} {t : set β} (hnt : t.nonempty) (ht : t.ord_connected) (H : ∀ (n : β), n ∈ t → is_connected (s n)) (K : ∀ (n : β), n ∈ t → order.succ n ∈ t → (s n ∩ s (order.succ n)).nonempty) : is_connected (⋃ (n : β) (H : n ∈ t), s n) :=\n\n/-- The Union of connected sets indexed by a type with an archimedean successor (like `ℕ` or `ℤ`)  such that any two neighboring sets meet is preconnected. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [linear_order β] [succ_order β] [is_succ_archimedean β] {s : β → set α} (H : ∀ (n : β), is_preconnected (s n)) (K : ∀ (n : β), (s n ∩ s (order.succ n)).nonempty) : is_preconnected (⋃ (n : β), s n) :=\n\n/-- The Union of preconnected sets indexed by a subset of a type with an archimedean successor  (like `ℕ` or `ℤ`) such that any two neighboring sets meet is preconnected. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [linear_order β] [succ_order β] [is_succ_archimedean β] {s : β → set α} {t : set β} (ht : t.ord_connected) (H : ∀ (n : β), n ∈ t → is_preconnected (s n)) (K : ∀ (n : β), n ∈ t → order.succ n ∈ t → (s n ∩ s (order.succ n)).nonempty) : is_preconnected (⋃ (n : β) (H : n ∈ t), s n) :=\n\n/-- The Union of connected sets indexed by a type with an archimedean successor (like `ℕ` or `ℤ`)  such that any two neighboring sets meet is connected. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [linear_order β] [succ_order β] [is_succ_archimedean β] [nonempty β] {s : β → set α} (H : ∀ (n : β), is_connected (s n)) (K : ∀ (n : β), (s n ∩ s (order.succ n)).nonempty) : is_connected (⋃ (n : β), s n) :=\n\n/-- Every natural number has a successor. -/\ntheorem "}
{"text": "Every natural number is less than its successor.", "fullPrompt": "/-- `a ≤ b` as natural numbers if and only if `a ≤ b` in `fin n`. -/\ntheorem {n : ℕ} {a b : fin n} : ↑a ≤ ↑b ↔ a ≤ b :=\n\n/-- `a < b` as natural numbers if and only if `a < b` in `fin n`. -/\ntheorem {n : ℕ} {a b : fin n} : ↑a < ↑b ↔ a < b :=\n\n/-- The relation `≤` on a preorder is transitive. -/\ntheorem {α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c :=\n\n/--  Every x greater than or equal to 1 is between two successive natural-number powers of every y greater than one. -/\ntheorem {α : Type u_1} [linear_ordered_ring α] [archimedean α] {x y : α} (hx : 1 ≤ x) (hy : 1 < y) : ∃ (n : ℕ), y ^ n ≤ x ∧ x < y ^ (n + 1) :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ≥ b 3. n ∈ Ico a b -/\ntheorem (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/--  The \"greater than\" relation on `upto p` is well founded if (and only if) there exists a value satisfying `p`. -/\ntheorem {p : ℕ → Prop} : (∃ (x : ℕ), p x) → well_founded (nat.upto.gt p) :=\n\n/-- The relation `≤` on a preorder is reflexive. -/\ntheorem {α : Type u} [preorder α] (a : α) : a ≤ a :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- Another way of expressing `strong_induction_on`: the `(<)` relation is well-founded. -/\ntheorem {α : Type u_1} : well_founded has_lt.lt :=\n\n/-- less-than is well-founded -/\ntheorem  : well_founded nat.lt :=\n\n/--  The cast of the successor is the succesor of the cast. See `fin.succ_cast_eq` for rewriting in the reverse direction. -/\ntheorem {n n' : ℕ} (i : fin n) (h : n.succ = n'.succ) : ⇑(fin.cast h) i.succ = (⇑(fin.cast _) i).succ :=\n\n/-- The Union of connected sets indexed by a subset of a type with an archimedean successor  (like `ℕ` or `ℤ`) such that any two neighboring sets meet is preconnected. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [linear_order β] [succ_order β] [is_succ_archimedean β] {s : β → set α} {t : set β} (hnt : t.nonempty) (ht : t.ord_connected) (H : ∀ (n : β), n ∈ t → is_connected (s n)) (K : ∀ (n : β), n ∈ t → order.succ n ∈ t → (s n ∩ s (order.succ n)).nonempty) : is_connected (⋃ (n : β) (H : n ∈ t), s n) :=\n\n/-- The Union of connected sets indexed by a type with an archimedean successor (like `ℕ` or `ℤ`)  such that any two neighboring sets meet is preconnected. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [linear_order β] [succ_order β] [is_succ_archimedean β] {s : β → set α} (H : ∀ (n : β), is_preconnected (s n)) (K : ∀ (n : β), (s n ∩ s (order.succ n)).nonempty) : is_preconnected (⋃ (n : β), s n) :=\n\n/-- The Union of preconnected sets indexed by a subset of a type with an archimedean successor  (like `ℕ` or `ℤ`) such that any two neighboring sets meet is preconnected. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [linear_order β] [succ_order β] [is_succ_archimedean β] {s : β → set α} {t : set β} (ht : t.ord_connected) (H : ∀ (n : β), n ∈ t → is_preconnected (s n)) (K : ∀ (n : β), n ∈ t → order.succ n ∈ t → (s n ∩ s (order.succ n)).nonempty) : is_preconnected (⋃ (n : β) (H : n ∈ t), s n) :=\n\n/-- The Union of connected sets indexed by a type with an archimedean successor (like `ℕ` or `ℤ`)  such that any two neighboring sets meet is connected. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [linear_order β] [succ_order β] [is_succ_archimedean β] [nonempty β] {s : β → set α} (H : ∀ (n : β), is_connected (s n)) (K : ∀ (n : β), (s n ∩ s (order.succ n)).nonempty) : is_connected (⋃ (n : β), s n) :=\n\n/-- Every natural number is less than its successor. -/\ntheorem "}
{"text": "Every set is Lebesgue measurable.", "fullPrompt": "/-- Every set has a measurable superset. Declare this as local instance as needed. -/\ntheorem {α : Type u_1} {m : measurable_space α} (s : set α) : nonempty {t // s ⊆ t ∧ measurable_set t} :=\n\n/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem  : ⇑measure_theory.measure_space.volume {x : ℝ | liouville x} = 0 :=\n\n/-- A strongly measurable function is measurable. -/\ntheorem {α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] (hf : measure_theory.strongly_measurable f) : measurable f :=\n\n/-- A sequential limit of measurable `ℝ≥0` valued functions is measurable. -/\ntheorem {α : Type u_1} [measurable_space α] {f : ℕ → α → nnreal} {g : α → nnreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g :=\n\n/-- A sequential limit of measurable `ℝ≥0∞` valued functions is measurable. -/\ntheorem {α : Type u_1} [measurable_space α] {f : ℕ → α → ennreal} {g : α → ennreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g :=\n\n/-- The range of a strongly measurable function is separable. -/\ntheorem {α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f) :=\n\n/-- **Alias** of the reverse direction of measurable_iff_comap_le`. -/\ntheorem {α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable_space.comap f m₂ ≤ m₁ → measurable f :=\n\n/-- **Alias** of the reverse direction of measurable_iff_le_map`. -/\ntheorem {α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : m₂ ≤ measurable_space.map f m₁ → measurable f :=\n\n/-- In a Polish space, a set is clopenable if and only if it is Borel-measurable. -/\ntheorem {γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {s : set γ} : polish_space.is_clopenable s ↔ measurable_set s :=\n\n/-- Subsets of a bounded set are also bounded -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} (incl : s ⊆ t) : metric.bounded t → metric.bounded s :=\n\n/-- **Alias** of the forward direction of measurable_iff_le_map`. -/\ntheorem {α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable f → m₂ ≤ measurable_space.map f m₁ :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem {γ : Type w} [semilattice_inf γ] {s t : set γ} : bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t :=\n\n/--  The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue measure zero. -/\ntheorem  : ⇑measure_theory.measure_space.volume (⋃ (p : ℝ) (hp : 2 < p), {x : ℝ | liouville_with p x}) = 0 :=\n\n/--  A useful consequence of the Lebesgue number lemma: given any compact set `K` contained in an open set `U`, we can find an (open) entourage `V` such that the ball of size `V` about any point of `K` is contained in `U`. -/\ntheorem {α : Type u_1} [uniform_space α] {K U : set α} (hK : is_compact K) (hU : is_open U) (hKU : K ⊆ U) : ∃ (V : set (α × α)) (H : V ∈ uniformity α), is_open V ∧ ∀ (x : α), x ∈ K → uniform_space.ball x V ⊆ U :=\n\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)  Tonelli's theorem is measurable.  This version has the argument `f` in curried form. -/\ntheorem {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {f : α → β → ennreal} (hf : measurable (function.uncurry f)) : measurable (λ (x : α), ∫⁻ (y : β), f x y ∂ν) :=\n\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)  Tonelli's theorem is measurable. -/\ntheorem {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {f : α × β → ennreal} (hf : measurable f) : measurable (λ (x : α), ∫⁻ (y : β), f (x, y) ∂ν) :=\n\n/-- Every set is Lebesgue measurable. -/\ntheorem "}
{"text": "Every set of Borel measure zero is Lebesgue measurable.", "fullPrompt": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem  : ⇑measure_theory.measure_space.volume {x : ℝ | liouville x} = 0 :=\n\n/-- Every set has a measurable superset. Declare this as local instance as needed. -/\ntheorem {α : Type u_1} {m : measurable_space α} (s : set α) : nonempty {t // s ⊆ t ∧ measurable_set t} :=\n\n/-- In a Polish space, a set is clopenable if and only if it is Borel-measurable. -/\ntheorem {γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {s : set γ} : polish_space.is_clopenable s ↔ measurable_set s :=\n\n/--  The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue measure zero. -/\ntheorem  : ⇑measure_theory.measure_space.volume (⋃ (p : ℝ) (hp : 2 < p), {x : ℝ | liouville_with p x}) = 0 :=\n\n/-- A sequential limit of measurable `ℝ≥0` valued functions is measurable. -/\ntheorem {α : Type u_1} [measurable_space α] {f : ℕ → α → nnreal} {g : α → nnreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g :=\n\n/-- A strongly measurable function is measurable. -/\ntheorem {α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] (hf : measure_theory.strongly_measurable f) : measurable f :=\n\n/-- The empty set has zero diameter -/\ntheorem {α : Type u} [pseudo_metric_space α] : metric.diam ∅ = 0 :=\n\n/-- A sequential limit of measurable `ℝ≥0∞` valued functions is measurable. -/\ntheorem {α : Type u_1} [measurable_space α] {f : ℕ → α → ennreal} {g : α → ennreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g :=\n\n/-- The range of a strongly measurable function is separable. -/\ntheorem {α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f) :=\n\n/-- The product of the constant function `0` over any set equals `0`. -/\ntheorem {α : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set α) : finsum (λ (i : α), finsum (λ (H : i ∈ s), 0)) = 0 :=\n\n/-- The diameter of the empty set vanishes -/\ntheorem {α : Type u} [pseudo_emetric_space α] : emetric.diam ∅ = 0 :=\n\n/-- If an additive indicator function is not equal to `0` at a point, then that point is in the set. -/\ntheorem {α : Type u_1} {M : Type u_4} [has_zero M] {s : set α} {f : α → M} {a : α} (h : s.indicator f a ≠ 0) : a ∈ s :=\n\n/--  The **Heine–Borel theorem**: In a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} [t2_space α] [proper_space α] : is_compact s ↔ is_closed s ∧ metric.bounded s :=\n\n/-- The **Heine–Borel theorem**: In a proper space, the closure of a bounded set is compact. -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} [proper_space α] (h : metric.bounded s) : is_compact (closure s) :=\n\n/-- The **Heine–Borel theorem**: In a proper space, a closed bounded set is compact. -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} [proper_space α] (hc : is_closed s) (hb : metric.bounded s) : is_compact s :=\n\n/--  The hard part of the Lusin separation theorem saying that two disjoint analytic sets are contained in disjoint Borel sets (see the full statement in `analytic_set.measurably_separable`). Here, we prove this when our analytic sets are the ranges of functions from `ℕ → ℕ`. -/\ntheorem {α : Type u_1} [topological_space α] [t2_space α] [measurable_space α] [borel_space α] {f g : (ℕ → ℕ) → α} (hf : continuous f) (hg : continuous g) (h : disjoint (set.range f) (set.range g)) : measure_theory.measurably_separable (set.range f) (set.range g) :=\n\n/--  A useful consequence of the Lebesgue number lemma: given any compact set `K` contained in an open set `U`, we can find an (open) entourage `V` such that the ball of size `V` about any point of `K` is contained in `U`. -/\ntheorem {α : Type u_1} [uniform_space α] {K U : set α} (hK : is_compact K) (hU : is_open U) (hKU : K ⊆ U) : ∃ (V : set (α × α)) (H : V ∈ uniformity α), is_open V ∧ ∀ (x : α), x ∈ K → uniform_space.ball x V ⊆ U :=\n\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)  Tonelli's theorem is measurable.  This version has the argument `f` in curried form. -/\ntheorem {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {f : α → β → ennreal} (hf : measurable (function.uncurry f)) : measurable (λ (x : α), ∫⁻ (y : β), f x y ∂ν) :=\n\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)  Tonelli's theorem is measurable. -/\ntheorem {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {f : α × β → ennreal} (hf : measurable f) : measurable (λ (x : α), ∫⁻ (y : β), f (x, y) ∂ν) :=\n\n/-- Every set of Borel measure zero is Lebesgue measurable. -/\ntheorem "}
{"text": "No prime number is a perfect square.", "fullPrompt": "/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- Euler's Criterion: a nonzero `a : zmod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] {a : zmod p} (ha : a ≠ 0) : is_square a ↔ a ^ (p / 2) = 1 :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a :=\n\n/-- The Legendre symbol of `a^2` at `p` is 1 if `p ∤ a`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p (a ^ 2) = 1 :=\n\n/-- When `p ∤ a`, then `legendre_sym p a = 1` iff `a` is a square mod `p`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] {a : ℤ} (ha0 : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ↔ is_square ↑a :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem  : pythagorean_triple 0 0 0 :=\n\n/-- The square of the symbol is 1 if `p ∤ a`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a ^ 2 = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1 :=\n\n/-- No prime number is a perfect square. -/\ntheorem "}
{"text": "Every odd prime number is greater than `2`.", "fullPrompt": "/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem (p' : ℕ) : 2 < lucas_lehmer.q (p' + 2) :=\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/\ntheorem {n : ℕ} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0 :=\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0 :=\n\n/-- An inequality involving `2`. -/\ntheorem {α : Type u_1} [linear_ordered_field α] {a : α} (a2 : 2 ≤ a) : (1 - 1 / a)⁻¹ ≤ 2 :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1 :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/\ntheorem {n : ℕ} : is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1 :=\n\n/--  If `irreducible (cyclotomic (p ^ (k + 1)) K)` (in particular for `K = ℚ`) and `p` is an odd prime, then the norm of `zeta (p ^ (k + 1)) K L - 1` is `p`. -/\ntheorem {p : ℕ+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ↑↑p] {k : ℕ} [hpri : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (h : p ≠ 2) : ⇑(algebra.norm K) (is_cyclotomic_extension.zeta (p ^ (k + 1)) K L - 1) = ↑p :=\n\n/--  If `irreducible (cyclotomic p K)` (in particular for `K = ℚ`) and `p` is an odd prime, then the norm of `zeta p K L - 1` is `p`. -/\ntheorem {p : ℕ+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ↑↑p] [hpri : fact (nat.prime ↑p)] [hcyc : is_cyclotomic_extension {p} K L] (hirr : irreducible (polynomial.cyclotomic ↑p K)) (h : p ≠ 2) : ⇑(algebra.norm K) (is_cyclotomic_extension.zeta p K L - 1) = ↑p :=\n\n/-- Every odd prime number is greater than `2`. -/\ntheorem "}
{"text": "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.", "fullPrompt": "/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p :=\n\n/--  Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity. -/\ntheorem {x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem  : pythagorean_triple 0 0 0 :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n :=\n\n/--  `(k*x, k*y, k*z)` is a Pythagorean triple if and only if `(x, y, z)` is also a triple. -/\ntheorem {x y z : ℤ} (k : ℤ) (hk : k ≠ 0) : pythagorean_triple (k * x) (k * y) (k * z) ↔ pythagorean_triple x y z :=\n\n/-- Composing two additions on the left by `y` then `x` is equal to a addition on the left by `x + y`. -/\ntheorem {α : Type u_1} [add_semigroup α] (x y : α) : has_add.add x ∘ has_add.add y = has_add.add (x + y) :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ≥ b 3. n ∈ Ico a b -/\ntheorem (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b :=\n\n/-- Composing two multiplications on the left by `y` then `x` is equal to a multiplication on the left by `x * y`. -/\ntheorem {α : Type u_1} [semigroup α] (x y : α) : has_mul.mul x ∘ has_mul.mul y = has_mul.mul (x * y) :=\n\n/-- Composing two additions on the right by `y` and `x` is equal to a addition on the right by `y + x`. -/\ntheorem {α : Type u_1} [add_semigroup α] (x y : α) : ((λ (_x : α), _x + x) ∘ λ (_x : α), _x + y) = λ (_x : α), _x + (y + x) :=\n\n/-- Composing two multiplications on the right by `y` and `x` is equal to a multiplication on the right by `y * x`. -/\ntheorem {α : Type u_1} [semigroup α] (x y : α) : ((λ (_x : α), _x * x) ∘ λ (_x : α), _x * y) = λ (_x : α), _x * (y * x) :=\n\n/-- The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares. -/\ntheorem "}
{"text": "Every compact topological space is locally compact.", "fullPrompt": "/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K' :=\n\n/-- In a locally compact T₂ space, every point has an open neighborhood with compact closure -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α) : ∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U) :=\n\n/--  Every separated topological group in which there exists a compact set with nonempty interior is locally compact. -/\ntheorem {G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G :=\n\n/-- A locally compact Hausdorff space is totally disconnected  if and only if it is totally separated. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H ↔ totally_separated_space H :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s} :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t :=\n\n/-- In a `t2_space`, every compact set is closed. -/\ntheorem {α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s) : is_closed s :=\n\n/-- A compact Hausdorff space is totally disconnected if and only if it is totally separated, this  is also true for locally compact spaces. -/\ntheorem {α : Type u} [topological_space α] [t2_space α] [compact_space α] : totally_disconnected_space α ↔ totally_separated_space α :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t) :=\n\n/-- A compact set is bounded above -/\ntheorem {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s) : bdd_above s :=\n\n/--  Given an embedding of a topological space into a metrizable space, the source space is also metrizable. -/\ntheorem {X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.metrizable_space Y] {f : X → Y} (hf : embedding f) : topological_space.metrizable_space X :=\n\n/-- The Stone-Weierstrass approximation theorem, `is_R_or_C` version, that a subalgebra `A` of `C(X, 𝕜)`, where `X` is a compact topological space and `is_R_or_C 𝕜`, is dense if it is conjugation-invariant and separates points. -/\ntheorem {𝕜 : Type u_1} {X : Type u_2} [is_R_or_C 𝕜] [topological_space X] [compact_space X] (A : subalgebra 𝕜 C(X, 𝕜)) (hA : A.separates_points) (hA' : continuous_map.conj_invariant_subalgebra (subalgebra.restrict_scalars ℝ A)) : A.topological_closure = ⊤ :=\n\n/-- The **Stone-Weierstrass Approximation Theorem**, that a subalgebra `A` of `C(X, ℝ)`, where `X` is a compact topological space, is dense if it separates points. -/\ntheorem {X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra ℝ C(X, ℝ)) (w : A.separates_points) : A.topological_closure = ⊤ :=\n\n/-- Every compact topological space is locally compact. -/\ntheorem "}
{"text": "Every continuous function is uniformly continuous.", "fullPrompt": "/-- The new distance is uniformly continuous. -/\ntheorem {α : Type u} [pseudo_metric_space α] : uniform_continuous (λ (p : uniform_space.completion α × uniform_space.completion α), has_dist.dist p.fst p.snd) :=\n\n/-- The minimal distance to a set is uniformly continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_dist x s) :=\n\n/-- The minimal distance to a set (as `ℝ≥0`) is uniformly continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_nndist x s) :=\n\n/-- The indexed supremum of a function is bounded above by a uniform bound -/\ntheorem {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c) : supr f ≤ c :=\n\n/-- On an empty space, bounded continuous functions are at distance 0 -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} [is_empty α] : has_dist.dist f g = 0 :=\n\n/-- In a sequential space, continuity and sequential continuity coincide. -/\ntheorem {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : continuous f ↔ seq_continuous f :=\n\n/-- The minimal distance to a set is continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_dist x s) :=\n\n/--  If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the Hausdorff dimension of its domain. -/\ntheorem {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) : dimH (set.range f) ≤ dimH set.univ :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f :=\n\n/-- The indexed minimum of a function is bounded below by a uniform lower bound -/\ntheorem {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), c ≤ f x) : c ≤ infi f :=\n\n/-- The minimal distance to a set (as `ℝ≥0`) is continuous in point -/\ntheorem {α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_nndist x s) :=\n\n/-- The indexed supremum of a function is bounded below by the value taken at one point -/\ntheorem {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_above (set.range f)) (c : ι) : f c ≤ supr f :=\n\n/-- A Hölder continuous function is uniformly continuous -/\ntheorem {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X → Y} (hf : holder_with C r f) (h0 : 0 < r) : uniform_continuous f :=\n\n/-- A Hölder continuous function is uniformly continuous -/\ntheorem {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X → Y} {s : set X} (hf : holder_on_with C r f s) (h0 : 0 < r) : uniform_continuous_on f s :=\n\n/-- A Lipschitz function is uniformly continuous -/\ntheorem {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : lipschitz_with K f) : uniform_continuous f :=\n\n/-- The composition operator (in the target) with a Lipschitz map is uniformly continuous -/\ntheorem {α : Type u} {β : Type v} {γ : Type w} [topological_space α] [pseudo_metric_space β] [pseudo_metric_space γ] {G : β → γ} {C : nnreal} (H : lipschitz_with C G) : uniform_continuous (bounded_continuous_function.comp G H) :=\n\n/-- The coercion from `lp E p` to `Π i, E i` is uniformly continuous. -/\ntheorem {α : Type u_1} {E : α → Type u_2} {p : ennreal} [Π (i : α), normed_group (E i)] [fact (1 ≤ p)] : uniform_continuous coe :=\n\n/--  Heine-Cantor: a continuous function on a compact set of a separated uniform space is uniformly continuous. -/\ntheorem {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {s : set α} {f : α → β} (hs : is_compact s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/--  Heine-Cantor: a continuous function on a compact separated set of a uniform space is uniformly continuous. -/\ntheorem {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] {s : set α} {f : α → β} (hs : is_compact s) (hs' : is_separated s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/-- Every continuous function is uniformly continuous. -/\ntheorem "}
{"text": "`6` is not the sum of two distinct prime numbers.", "fullPrompt": "/-- The sine of `π / 6` is `1 / 2`. -/\ntheorem  : real.sin (real.pi / 6) = 1 / 2 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- Additive congruence relations preserve addition. -/\ntheorem {M : Type u_1} [has_add M] (c : add_con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w + y) (x + z) :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ m + n ↔ m ∣ n :=\n\n/--  Euclid's lemma: if `a ∣ b * c` and `gcd a b = 1` then `a ∣ c`. Compare with `is_coprime.dvd_of_dvd_mul_right` and `unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors` -/\ntheorem {a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd b = 1) : a ∣ c :=\n\n/--  Euclid's lemma: if `a ∣ b * c` and `gcd a c = 1` then `a ∣ b`. Compare with `is_coprime.dvd_of_dvd_mul_left` and `unique_factorization_monoid.dvd_of_dvd_mul_left_of_no_prime_factors` -/\ntheorem {a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd c = 1) : a ∣ b :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ℕ | x ≠ 0} :=\n\n/--  The intersection of distinct prime powers in a Dedekind domain is the product of these prime powers. -/\ntheorem {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {ι : Type u_2} (s : finset ι) (f : ι → ideal R) (e : ι → ℕ) (prime : ∀ (i : ι), i ∈ s → _root_.prime (f i)) (coprime : ∀ (i : ι), i ∈ s → ∀ (j : ι), j ∈ s → i ≠ j → f i ≠ f j) : s.inf (λ (i : ι), f i ^ e i) = s.prod (λ (i : ι), f i ^ e i) :=\n\n/-- `6` is not the sum of two distinct prime numbers. -/\ntheorem "}
{"text": "No integer is irrational.", "fullPrompt": "/-- The golden ratio is irrational. -/\ntheorem  : irrational golden_ratio :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem  : irrational golden_conj :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ℕ | x ≠ 0} :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem  : pythagorean_triple 0 0 0 :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n :=\n\n/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\ntheorem {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a :=\n\n/-- an n-digit number in base b is less than b^n if b ≥ 2 -/\ntheorem {b : ℕ} {l : list ℕ} (hb : 2 ≤ b) (hl : ∀ (x : ℕ), x ∈ l → x < b) : nat.of_digits b l < b ^ l.length :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/--  Euclid's lemma: if `a ∣ b * c` and `gcd a b = 1` then `a ∣ c`. Compare with `is_coprime.dvd_of_dvd_mul_right` and `unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors` -/\ntheorem {a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd b = 1) : a ∣ c :=\n\n/-- Multiplicative congruence relations preserve integer powers. -/\ntheorem {M : Type u_1} [group M] (c : con M) (n : ℤ) {w x : M} : ⇑c w x → ⇑c (w ^ n) (x ^ n) :=\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem {x y : ℝ} : irrational (x + y) → irrational x ∨ irrational y :=\n\n/--  If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x` is irrational. -/\ntheorem {x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : fact (nat.prime p)] (hxr : x ^ n = ↑m) (hv : (multiplicity ↑p m).get _ % n ≠ 0) : irrational x :=\n\n/--  If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then `x` is irrational. -/\ntheorem {x : ℝ} (n : ℕ) (m : ℤ) (hxr : x ^ n = ↑m) (hv : ¬∃ (y : ℤ), x = ↑y) (hnpos : 0 < n) : irrational x :=\n\n/-- No integer is irrational. -/\ntheorem "}
{"text": "The identity element in a ring is a unit.", "fullPrompt": "/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a :=\n\n/-- Units of a monoid divide any element of the monoid. -/\ntheorem {α : Type u_1} [monoid α] {a u : α} (hu : is_unit u) : u ∣ a :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : (-1) * a = -a :=\n\n/-- The identity map is a ring homomorphism. -/\ntheorem {α : Type u} [ring α] : is_ring_hom id :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem {M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) (a : M₀) : a = 0 :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R :=\n\n/-- In a monoid with zero, either zero and one are nonequal, or zero is the only element. -/\ntheorem {M₀ : Type u_1} [mul_zero_one_class M₀] : 0 ≠ 1 ∨ ∀ (a : M₀), a = 0 :=\n\n/-- 1 is in the set of natural number powers of an element of a monoid. -/\ntheorem {M : Type u_1} [monoid M] {x : M} : 1 ∈ powers x :=\n\n/-- An element of a monoid is in the set of that element's natural number powers. -/\ntheorem {M : Type u_1} [monoid M] {x : M} : x ∈ powers x :=\n\n/-- If `R` is an additive monoid, an element in `add_units R` is add-regular. -/\ntheorem {R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular ↑a :=\n\n/-- The identity map is a monoid homomorphism. -/\ntheorem {α : Type u} [mul_one_class α] : is_monoid_hom id :=\n\n/-- The identity element in a ring is a unit. -/\ntheorem "}
{"text": "Every subgroup of a group is a group.", "fullPrompt": "/-- The normal closure of a set is a subgroup. -/\ntheorem {G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s) :=\n\n/-- If a subgroup of a topological group has `1` in its interior, then it is open. -/\ntheorem {G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H) : is_open ↑H :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem {α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f : α → β} (hf : is_group_hom f) : is_group_hom (λ (a : α), (f a)⁻¹) :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x :=\n\n/-- Inversion is a group homomorphism if the group is commutative. -/\ntheorem {α : Type u} [comm_group α] : is_group_hom has_inv.inv :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem {G : Type u_3} [group G] : group.fg G ↔ monoid.fg G :=\n\n/-- If a subgroup of an additive topological group has `0` in its interior, then it is open. -/\ntheorem {G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 ∈ interior ↑H) : is_open ↑H :=\n\n/-- A map to a group preserving multiplication is a monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [mul_one_class α] [group β] {f : α → β} (hf : is_mul_hom f) : is_monoid_hom f :=\n\n/-- The identity is a group homomorphism. -/\ntheorem {α : Type u} [group α] : is_group_hom id :=\n\n/-- Every subgroup of a group is a group. -/\ntheorem "}
{"text": "The sum of two natural numbers is a natural number.", "fullPrompt": "/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ m + n ↔ m ∣ n :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ n + m ↔ m ∣ n :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- Composing two additions on the left by `y` then `x` is equal to a addition on the left by `x + y`. -/\ntheorem {α : Type u_1} [add_semigroup α] (x y : α) : has_add.add x ∘ has_add.add y = has_add.add (x + y) :=\n\n/-- Composing two additions on the right by `y` and `x` is equal to a addition on the right by `y + x`. -/\ntheorem {α : Type u_1} [add_semigroup α] (x y : α) : ((λ (_x : α), _x + x) ∘ λ (_x : α), _x + y) = λ (_x : α), _x + (y + x) :=\n\n/-- `a ≤ b` as natural numbers if and only if `a ≤ b` in `fin n`. -/\ntheorem {n : ℕ} {a b : fin n} : ↑a ≤ ↑b ↔ a ≤ b :=\n\n/-- `a < b` as natural numbers if and only if `a < b` in `fin n`. -/\ntheorem {n : ℕ} {a b : fin n} : ↑a < ↑b ↔ a < b :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ≥ b 3. n ∈ Ico a b -/\ntheorem (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/--  Every x greater than or equal to 1 is between two successive natural-number powers of every y greater than one. -/\ntheorem {α : Type u_1} [linear_ordered_ring α] [archimedean α] {x y : α} (hx : 1 ≤ x) (hy : 1 < y) : ∃ (n : ℕ), y ^ n ≤ x ∧ x < y ^ (n + 1) :=\n\n/-- If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. -/\ntheorem {z : upper_half_plane} (hz : z ∈ modular_group.fdo) (n : ℤ) : 1 < ⇑complex.norm_sq ↑(modular_group.T ^ n • z) :=\n\n/-- The sum of two natural numbers is a natural number. -/\ntheorem "}
{"text": "The identity element of a group has finite order.", "fullPrompt": "/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem {G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem {G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) ↔ is_of_fin_add_order x :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem {G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x) :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α :=\n\n/-- 1 is of finite order in any monoid. -/\ntheorem {G : Type u} [monoid G] : is_of_fin_order 1 :=\n\n/-- Commuting elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/-- If a direct product has finite order then so does each component. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_order x) (i : η) : is_of_fin_order (x i) :=\n\n/-- Elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g :=\n\n/-- 0 is of finite order in any additive monoid. -/\ntheorem {G : Type u} [add_monoid G] : is_of_fin_add_order 0 :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem {G : Type u} [monoid G] (H : submonoid G) (x : ↥H) : is_of_fin_order x ↔ is_of_fin_order ↑x :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem {G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order x⁻¹ :=\n\n/-- The identity element of a group has finite order. -/\ntheorem "}
{"text": "`7` is a prime number.", "fullPrompt": "/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- If `p` is prime, and `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)` then `a = p^(k+1)`. -/\ntheorem {a p k : ℕ} (pp : nat.prime p) (h₁ : ¬a ∣ p ^ k) (h₂ : a ∣ p ^ (k + 1)) : a = p ^ (k + 1) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1 :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : zmod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] {a : zmod p} (ha : a ≠ 0) : a ^ (p - 1) = 1 :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p` is prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this group must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem (p : ℕ) (a : zmod p) (ha : a ^ (p - 1) = 1) (hd : ∀ (q : ℕ), nat.prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) : nat.prime p :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem (p : ℕ) [hp : fact (nat.prime p)] : prime ↑p ↔ p % 4 = 3 :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem (p' : ℕ) : 2 < lucas_lehmer.q (p' + 2) :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`  for some `k`. -/\ntheorem (m : ℤ) {n : ℤ} (hn : 0 < n) : (∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n :=\n\n/-- `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)` for some `k`. -/\ntheorem (m : ℕ) {n : ℕ} (hn : 0 < n) : (∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1 :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- `7` is a prime number. -/\ntheorem "}
{"text": "There are `3` prime numbers below `8`.", "fullPrompt": "/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem (p : ℕ) [hp : fact (nat.prime p)] : prime ↑p ↔ p % 4 = 3 :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ≥ b 3. n ∈ Ico a b -/\ntheorem (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem (p' : ℕ) : 2 < lucas_lehmer.q (p' + 2) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p :=\n\n/-- If `p` is prime, and `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)` then `a = p^(k+1)`. -/\ntheorem {a p k : ℕ} (pp : nat.prime p) (h₁ : ¬a ∣ p ^ k) (h₂ : a ∣ p ^ (k + 1)) : a = p ^ (k + 1) :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem (p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1 :=\n\n/-- There are `3` prime numbers below `8`. -/\ntheorem "}
{"text": "The empty set is contained in every finite set.", "fullPrompt": "/-- `⊥`, coerced to a set, is the empty set. -/\ntheorem (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊥ = ∅ :=\n\n/-- The empty set has zero diameter -/\ntheorem {α : Type u} [pseudo_metric_space α] : metric.diam ∅ = 0 :=\n\n/-- The diameter of the empty set vanishes -/\ntheorem {α : Type u} [pseudo_emetric_space α] : emetric.diam ∅ = 0 :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0 :=\n\n/-- The sum of any function over an empty set is `0`. -/\ntheorem {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} : finsum (λ (i : α), finsum (λ (H : i ∈ ∅), f i)) = 0 :=\n\n/-- The infimum of a singleton is the element of the singleton -/\ntheorem {α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Inf.Inf {a} = a :=\n\n/-- Empty relation is well-founded -/\ntheorem {α : Sort u} : well_founded empty_relation :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem {M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) (a : M₀) : a = 0 :=\n\n/-- The frontier of a closed set has no interior point. -/\ntheorem {α : Type u} [topological_space α] {s : set α} (h : is_closed s) : interior (frontier s) = ∅ :=\n\n/--  **Cantor's diagonal argument** implies that there are no injective functions from `set α` to `α`. -/\ntheorem {α : Type u_1} (f : set α → α) : ¬function.injective f :=\n\n/-- The minimal distance of a point to a set containing it vanishes -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : x ∈ s) : metric.inf_dist x s = 0 :=\n\n/-- The supremum of a singleton is the element of the singleton -/\ntheorem {α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Sup.Sup {a} = a :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K' :=\n\n/-- A set is contained in its affine span. -/\ntheorem (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ ↑(affine_span k s) :=\n\n/-- A set is contained in its `span_points`. -/\ntheorem (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ span_points k s :=\n\n/--  The sequential closure of a set is contained in the closure of that set. The converse is not true. -/\ntheorem {X : Type u_1} [topological_space X] (s : set X) : seq_closure s ⊆ closure s :=\n\n/-- A set is contained in its own closed thickening. -/\ntheorem {α : Type u} [pseudo_emetric_space α] {δ : ℝ} (E : set α) : E ⊆ metric.cthickening δ E :=\n\n/-- A set is contained in its own (open) thickening. -/\ntheorem {α : Type u} [pseudo_emetric_space α] {δ : ℝ} (δ_pos : 0 < δ) (E : set α) : E ⊆ metric.thickening δ E :=\n\n/-- The empty set is contained in every finite set. -/\ntheorem "}
{"text": "Every infinite set contains a finite set.", "fullPrompt": "/-- Infinite ordinals that are cardinals are unbounded. -/\ntheorem  : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b} :=\n\n/-- Subsets of a bounded set are also bounded -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} (incl : s ⊆ t) : metric.bounded t → metric.bounded s :=\n\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V) : finite_dimensional K V :=\n\n/--  **Cantor's diagonal argument** implies that there are no injective functions from `set α` to `α`. -/\ntheorem {α : Type u_1} (f : set α → α) : ¬function.injective f :=\n\n/-- When there is a global maximum, every set is bounded above. -/\ntheorem {γ : Type w} [preorder γ] [order_top γ] (s : set γ) : bdd_above s :=\n\n/-- If a category has all products then in particular it has finite products. -/\ntheorem (C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C :=\n\n/-- If `s.nth n = some aₙ` for some value `aₙ`, then there is also some value `aₘ` such that `s.nth = some aₘ` for `m ≤ n`. -/\ntheorem {α : Type u} (s : seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n) (s_nth_eq_some : s.nth n = option.some aₙ) : ∃ (aₘ : α), s.nth m = option.some aₘ :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t :=\n\n/--  **Cantor's diagonal argument** implies that there are no surjective functions from `α` to `set α`. -/\ntheorem {α : Type u_1} (f : α → set α) : ¬function.surjective f :=\n\n/-- The union of two sets is bounded iff each of the sets is bounded. -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K' :=\n\n/-- When there is a global minimum, every set is bounded below. -/\ntheorem {γ : Type w} [preorder γ] [order_bot γ] (s : set γ) : bdd_below s :=\n\n/--  If `s` is an infinite set of natural numbers and `k > 0`, then `s` contains two elements `m < n` that are equal mod `k`. -/\ntheorem {s : set ℕ} (hs : s.infinite) {k : ℕ} (hk : 0 < k) : ∃ (m : ℕ) (H : m ∈ s) (n : ℕ) (H : n ∈ s), m < n ∧ m ≡ n [MOD k] :=\n\n/-- Every infinite set contains a finite set. -/\ntheorem "}
{"text": "Every commutative ring is a monoid.", "fullPrompt": "/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem {M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) (a : M₀) : a = 0 :=\n\n/-- The set of natural number powers of an element of a monoid is closed under multiplication. -/\ntheorem {M : Type u_1} [monoid M] {x y z : M} : y ∈ powers x → z ∈ powers x → y * z ∈ powers x :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x) :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y) :=\n\n/-- In a monoid with zero, either zero and one are nonequal, or zero is the only element. -/\ntheorem {M₀ : Type u_1} [mul_zero_one_class M₀] : 0 ≠ 1 ∨ ∀ (a : M₀), a = 0 :=\n\n/-- An element of a monoid is in the set of that element's natural number powers. -/\ntheorem {M : Type u_1} [monoid M] {x : M} : x ∈ powers x :=\n\n/-- A monoid is a submonoid of itself. -/\ntheorem {M : Type u_1} [monoid M] : is_submonoid set.univ :=\n\n/-- Units of a monoid divide any element of the monoid. -/\ntheorem {α : Type u_1} [monoid α] {a u : α} (hu : is_unit u) : u ∣ a :=\n\n/-- In a monoid, an element a divides an element b iff all associates of `a` divide `b`. -/\ntheorem {α : Type u_1} [monoid α] {a b u : α} (hu : is_unit u) : a * u ∣ b ↔ a ∣ b :=\n\n/-- In a nontrivial monoid with zero, zero and one are different. -/\ntheorem {M₀ : Type u_1} [mul_zero_one_class M₀] [nontrivial M₀] : 0 ≠ 1 :=\n\n/-- In a commutative monoid, an element `a` divides an element `b` iff all  left associates of `a` divide `b`. -/\ntheorem {α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : u * a ∣ b ↔ a ∣ b :=\n\n/-- In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left    associates of `b`. -/\ntheorem {α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : a ∣ u * b ↔ a ∣ b :=\n\n/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c :=\n\n/--  The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : p ∣ ring_char R ↔ p ∣ fintype.card R :=\n\n/-- If an element a divides another element c in a commutative ring, a divides the sum of another  element b with c iff a divides b. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ c) : a ∣ b + c ↔ a ∣ b :=\n\n/-- Every commutative ring is a monoid. -/\ntheorem "}
{"text": "There is no field of order `10`.", "fullPrompt": "/-- `ℤ` with its usual ring structure is not a field. -/\ntheorem  : ¬is_field ℤ :=\n\n/-- A `fintype` can be given a field structure iff its cardinality is a prime power. -/\ntheorem {α : Type u_1} [fintype α] : nonempty (field α) ↔ is_prime_pow (fintype.card α) :=\n\n/-- There is a field structure on type if and only if its cardinality is a prime power. -/\ntheorem {α : Type u} : nonempty (field α) ↔ is_prime_pow (cardinal.mk α) :=\n\n/-- `polynomial R` is never a field for any ring `R`. -/\ntheorem {R : Type u} [ring R] : ¬is_field (polynomial R) :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a :=\n\n/-- Cannot be an instance because `power_basis` cannot be a class. -/\ntheorem {S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] (pb : power_basis K S) : finite_dimensional K S :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : ¬is_unit (minpoly A x) :=\n\n/-- Any infinite type can be endowed a field structure. -/\ntheorem {α : Type u} [infinite α] : nonempty (field α) :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem {α : Type u_1} [fintype α] [field α] : is_prime_pow (fintype.card α) :=\n\n/-- `padic_val_int p 1` is 0 for any `p`. -/\ntheorem {p : ℕ} : padic_val_int p 1 = 0 :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : minpoly A x ≠ 1 :=\n\n/-- There is no field of order `10`. -/\ntheorem "}
{"text": "Every odd natural number is the sum of two distinct natural numbers.", "fullPrompt": "/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0 :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ m + n ↔ m ∣ n :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem {m n : ℕ} : m ∣ n + m ↔ m ∣ n :=\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/\ntheorem {n : ℕ} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0 :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- Two elements `a` and `b` are add-regular if and only if both sums `a + b` and `b + a` are add-regular. -/\ntheorem {R : Type u_1} {a b : R} [add_semigroup R] : is_add_regular (a + b) ∧ is_add_regular (b + a) ↔ is_add_regular a ∧ is_add_regular b :=\n\n/-- A sum is add-regular if and only if the summands are. -/\ntheorem {R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) ↔ is_add_regular a ∧ is_add_regular b :=\n\n/-- Composing two additions on the left by `y` then `x` is equal to a addition on the left by `x + y`. -/\ntheorem {α : Type u_1} [add_semigroup α] (x y : α) : has_add.add x ∘ has_add.add y = has_add.add (x + y) :=\n\n/-- Additive congruence relations are symmetric. -/\ntheorem {M : Type u_1} [has_add M] (c : add_con M) {x y : M} : ⇑c x y → ⇑c y x :=\n\n/-- A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`. -/\ntheorem {n : ℕ} {x : ℕ × ℕ} : x ∈ list.nat.antidiagonal n ↔ x.fst + x.snd = n :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there  is some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem {X : Type u_1} [topological_space X] (hX : ∀ {x y : X}, x ≠ y → (∃ (U : set X) (h_clopen : is_clopen U), x ∈ U ∧ y ∉ U)) : is_totally_disconnected set.univ :=\n\n/--  If `A` is a family of enough low-degree polynomials over a finite ring, there is a pair of elements in `A` (with different indices but not necessarily distinct), such that their difference has small degree. -/\ntheorem {Fq : Type u_1} [fintype Fq] [ring Fq] {d m : ℕ} (hm : fintype.card Fq ^ d ≤ m) (b : polynomial Fq) (A : fin m.succ → polynomial Fq) (hA : ∀ (i : fin m.succ), (A i).degree < b.degree) : ∃ (i₀ i₁ : fin m.succ), i₀ ≠ i₁ ∧ (A i₁ - A i₀).degree < ↑(b.nat_degree - d) :=\n\n/--  The **sum of the angles of a triangle** (possibly degenerate, where the given vertex is distinct from the others), angle-at-point. -/\ntheorem {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h2 : p2 ≠ p1) (h3 : p3 ≠ p1) : euclidean_geometry.angle p1 p2 p3 + euclidean_geometry.angle p2 p3 p1 + euclidean_geometry.angle p3 p1 p2 = real.pi :=\n\n/-- If a `l : list α` is `nodup l`, then all of its cyclic permutants are distinct. -/\ntheorem {α : Type u} {l : list α} (hn : l.nodup) : l.cyclic_permutations.nodup :=\n\n/-- Every odd natural number is the sum of two distinct natural numbers. -/\ntheorem "}
{"text": "Every element in the trivial group has finite order.", "fullPrompt": "/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem {G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α :=\n\n/-- If a direct product has finite order then so does each component. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_order x) (i : η) : is_of_fin_order (x i) :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem {G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) ↔ is_of_fin_add_order x :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem {G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x) :=\n\n/-- If a direct product has finite additive order then so does each component. -/\ntheorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_add_order x) (i : η) : is_of_fin_add_order (x i) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- 1 is of finite order in any monoid. -/\ntheorem {G : Type u} [monoid G] : is_of_fin_order 1 :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g :=\n\n/-- 0 is of finite order in any additive monoid. -/\ntheorem {G : Type u} [add_monoid G] : is_of_fin_add_order 0 :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem {G : Type u} [monoid G] (H : submonoid G) (x : ↥H) : is_of_fin_order x ↔ is_of_fin_order ↑x :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem {G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order x⁻¹ :=\n\n/--  An arbitrary choice of factors of `x : M` is exactly the (unique) normalized set of factors, if `M` has a trivial group of units. -/\ntheorem {M : Type u_1} [cancel_comm_monoid_with_zero M] [decidable_eq M] [unique_factorization_monoid M] [unique Mˣ] (x : M) : unique_factorization_monoid.factors x = unique_factorization_monoid.normalized_factors x :=\n\n/-- A group `G` is nilpotent iff there exists a descending central series which reaches the  trivial group in a finite time. -/\ntheorem (G : Type u_1) [group G] : group.is_nilpotent G ↔ ∃ (n : ℕ) (H : ℕ → subgroup G), is_descending_central_series H ∧ H n = ⊥ :=\n\n/-- Every element in the trivial group has finite order. -/\ntheorem "}
{"text": "The square of an even number is even.", "fullPrompt": "/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0 :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- `0` is always a square (in a monoid with zero). -/\ntheorem (M : Type u_1) [monoid_with_zero M] : is_square 0 :=\n\n/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\ntheorem {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a :=\n\n/-- **Alias** of the reverse direction of is_square_iff_exists_sq`. -/\ntheorem {α : Type u_2} [monoid α] (m : α) : (∃ (c : α), m = c ^ 2) → is_square m :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- The square of an even number is even. -/\ntheorem "}
{"text": "Every commutative division ring is a field.", "fullPrompt": "/-- A division_ring is one-dimensional as a vector space over itself. -/\ntheorem (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1 :=\n\n/-- `polynomial R` is never a field for any ring `R`. -/\ntheorem {R : Type u} [ring R] : ¬is_field (polynomial R) :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c :=\n\n/-- When multiplication is commutative, `star` preserves division. -/\ntheorem {R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y :=\n\n/-- When multiplication is commutative, `star` preserves division. -/\ntheorem {R : Type u} [field R] [star_ring R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y :=\n\n/-- `ℤ` with its usual ring structure is not a field. -/\ntheorem  : ¬is_field ℤ :=\n\n/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.finite K V :=\n\n/-- An element of an algebra over a field is algebraic if and only if it is integral. -/\ntheorem {K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x ↔ is_integral K x :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y) :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x) :=\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem {Γ₀ : Type u_3} [linear_ordered_comm_monoid_with_zero Γ₀] [nontrivial Γ₀] {K : Type u_1} [division_ring K] (v : valuation K Γ₀) {x : K} : ⇑v x = 0 ↔ x = 0 :=\n\n/--  In a noetherian module over a division ring, if a basis is indexed by a set, that set is finite. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type u_1} {s : set ι} [is_noetherian K V] (b : basis ↥s K V) : s.finite :=\n\n/--  Over a characteristic-zero division ring, the centroids of two faces of a simplex are equal if and only if those faces are given by the same subset of points. -/\ntheorem {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : ℕ} (s : affine.simplex k P n) {fs₁ fs₂ : finset (fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.card = m₁ + 1) (h₂ : fs₂.card = m₂ + 1) : finset.centroid k finset.univ (s.face h₁).points = finset.centroid k finset.univ (s.face h₂).points ↔ fs₁ = fs₂ :=\n\n/--  The dimension of a noetherian module over a division ring, as a cardinal, is strictly less than the first infinite cardinal `ℵ₀`. -/\ntheorem (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : module.rank K V < cardinal.aleph_0 :=\n\n/--  Over a characteristic-zero division ring, the centroids given by two subsets of the points of a simplex are equal if and only if those faces are given by the same subset of points. -/\ntheorem {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : ℕ} (s : affine.simplex k P n) {fs₁ fs₂ : finset (fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.card = m₁ + 1) (h₂ : fs₂.card = m₂ + 1) : finset.centroid k fs₁ s.points = finset.centroid k fs₂ s.points ↔ fs₁ = fs₂ :=\n\n/-- Every commutative division ring is a field. -/\ntheorem "}
{"text": "The image of the identity element under the identity map is the identity element.", "fullPrompt": "/-- The identity map is a monoid homomorphism. -/\ntheorem {α : Type u} [mul_one_class α] : is_monoid_hom id :=\n\n/-- The identity map is a ring homomorphism. -/\ntheorem {α : Type u} [ring α] : is_ring_hom id :=\n\n/-- The identity map preserves multiplication. -/\ntheorem {α : Type u} [has_mul α] : is_mul_hom id :=\n\n/-- The identity is a group homomorphism. -/\ntheorem {α : Type u} [group α] : is_group_hom id :=\n\n/-- The identity map is an additive monoid homomorphism. -/\ntheorem {α : Type u} [add_zero_class α] : is_add_monoid_hom id :=\n\n/-- The identity map preserves addition -/\ntheorem {α : Type u} [has_add α] : is_add_hom id :=\n\n/-- The identity is an additive group homomorphism. -/\ntheorem {α : Type u} [add_group α] : is_add_group_hom id :=\n\n/-- The identity map is a semiring homomorphism. -/\ntheorem {α : Type u} [semiring α] : is_semiring_hom id :=\n\n/-- The identity affine map acts as the identity. -/\ntheorem (k : Type u_1) {V1 : Type u_2} {P1 : Type u_3} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] (p : P1) : ⇑(affine_map.id k P1) p = p :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : f 1 = 1 :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem {α : Type u_1} (n : ℕ) (x : α) : function.is_periodic_pt id n x :=\n\n/--  If `X` is an infinite type with discrete topology (e.g., `ℕ`), then the identity map from `cofinite_topology (alexandroff X)` to `alexandroff X` is not continuous. -/\ntheorem {X : Type u_1} [topological_space X] [infinite X] [discrete_topology X] : ¬continuous ⇑(cofinite_topology.of.symm) :=\n\n/--  If `e` is an `order_iso` between `fin n` and `fin m`, then `n = m` and `e` is the identity map. In this lemma we state that for each `i : fin n` we have `(e i : ℕ) = (i : ℕ)`. -/\ntheorem {n m : ℕ} (e : fin n ≃o fin m) (i : fin n) : ↑(⇑e i) = ↑i :=\n\n/-- The image of the identity element under the identity map is the identity element. -/\ntheorem "}
{"text": "Every point is a fixed point of the identity function on a space.", "fullPrompt": "/-- Every point is a fixed point of `id`. -/\ntheorem {α : Type u} (x : α) : function.is_fixed_pt id x :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem {α : Type u_1} (n : ℕ) (x : α) : function.is_periodic_pt id n x :=\n\n/-- If `x` is a fixed point of `f ∘ g` and `g`, then it is a fixed point of `f`. -/\ntheorem {α : Type u} {f g : α → α} {x : α} (hfg : function.is_fixed_pt (f ∘ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x :=\n\n/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem {α : Type u_1} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) (n : ℕ) : function.is_periodic_pt f n x :=\n\n/-- Any map `f` sends fixed points of `g ∘ f` to fixed points of `f ∘ g`. -/\ntheorem {α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.maps_to f (function.fixed_points (g ∘ f)) (function.fixed_points (f ∘ g)) :=\n\n/-- If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ∘ g`. -/\ntheorem {α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ∘ g) x :=\n\n/-- If `x` is a fixed point of `f`, then `f x = x`. This is useful, e.g., for `rw` or `simp`. -/\ntheorem {α : Type u} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) : f x = x :=\n\n/--  If self-maps `f` and `g` commute, then `g` is bijective on the set of fixed points of `f ∘ g`. This is a particular case of `function.bij_on_fixed_pts_comp`. -/\ntheorem {α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g)) :=\n\n/--  If self-maps `f` and `g` commute, then `f` is bijective on the set of fixed points of `f ∘ g`. This is a particular case of `function.bij_on_fixed_pts_comp`. -/\ntheorem {α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on f (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g)) :=\n\n/-- The identity map preserves multiplication. -/\ntheorem {α : Type u} [has_mul α] : is_mul_hom id :=\n\n/-- The identity map preserves addition -/\ntheorem {α : Type u} [has_add α] : is_add_hom id :=\n\n/--  Any two maps `f : α → β` and `g : β → α` are inverse of each other on the sets of fixed points of `f ∘ g` and `g ∘ f`, respectively. -/\ntheorem {α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f)) :=\n\n/--  Characterization of the `filter.map` of the coproduct of two principal filters `𝓟 {a}` and `𝓟 {i}`, under the `prod.map` of two functions, respectively the constant function `λ a, b` and the identity function.  Together with the previous lemma, `map_const_principal_coprod_map_id_principal`, this provides an example showing that the inequality in the lemma `map_prod_map_coprod_le` can be strict. -/\ntheorem {α : Type u_1} {β : Type u_2} {ι : Type u_3} (a : α) (b : β) (i : ι) : filter.map (prod.map (λ (_x : α), b) id) ((filter.principal {a}).coprod (filter.principal {i})) = filter.principal ({b} ×ˢ set.univ) :=\n\n/--  Characterization of the coproduct of the `filter.map`s of two principal filters `𝓟 {a}` and `𝓟 {i}`, the first under the constant function `λ a, b` and the second under the identity function. Together with the next lemma, `map_prod_map_const_id_principal_coprod_principal`, this provides an example showing that the inequality in the lemma `map_prod_map_coprod_le` can be strict. -/\ntheorem {α : Type u_1} {β : Type u_2} {ι : Type u_3} (a : α) (b : β) (i : ι) : (filter.map (λ (_x : α), b) (filter.principal {a})).coprod (filter.map id (filter.principal {i})) = filter.principal ({b} ×ˢ set.univ ∪ set.univ ×ˢ {i}) :=\n\n/-- Every point is a fixed point of the identity function on a space. -/\ntheorem "}
{"text": "The diameter of a singleton space is `0`.", "fullPrompt": "/-- The diameter of the empty set vanishes -/\ntheorem {α : Type u} [pseudo_emetric_space α] : emetric.diam ∅ = 0 :=\n\n/-- The empty set has zero diameter -/\ntheorem {α : Type u} [pseudo_metric_space α] : metric.diam ∅ = 0 :=\n\n/-- The diameter of a set is always nonnegative -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} : 0 ≤ metric.diam s :=\n\n/-- The diameter is monotonous with respect to inclusion -/\ntheorem {α : Type u} [pseudo_emetric_space α] {s t : set α} (h : s ⊆ t) : emetric.diam s ≤ emetric.diam t :=\n\n/-- The Hausdorff distance between a set and itself is zero -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s s = 0 :=\n\n/-- The supremum of a singleton is the element of the singleton -/\ntheorem {α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Sup.Sup {a} = a :=\n\n/-- If `s ⊆ t`, then the diameter of `s` is bounded by that of `t`, provided `t` is bounded. -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} (h : s ⊆ t) (ht : metric.bounded t) : metric.diam s ≤ metric.diam t :=\n\n/--  The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable value ∞ instead, use `Hausdorff_edist`, which takes values in ℝ≥0∞) -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist ∅ s = 0 :=\n\n/--  The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable value ∞ instead, use `Hausdorff_edist`, which takes values in ℝ≥0∞) -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s ∅ = 0 :=\n\n/-- The Hausdorff distance is nonnegative -/\ntheorem {α : Type u} [pseudo_metric_space α] {s t : set α} : 0 ≤ metric.Hausdorff_dist s t :=\n\n/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem {α : Type u} [topological_space α] : totally_disconnected_space α ↔ ∀ (x : α), connected_component x = {x} :=\n\n/--  An unbounded set has zero diameter. If you would prefer to get the value ∞, use `emetric.diam`. This lemma makes it possible to avoid side conditions in some situations -/\ntheorem {α : Type u} [pseudo_metric_space α] {s : set α} (h : ¬metric.bounded s) : metric.diam s = 0 :=\n\n/-- The diameter of a singleton space is `0`. -/\ntheorem "}
{"text": "Every group is non-empty.", "fullPrompt": "/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x :=\n\n/-- Moving to the opposite group or group_with_zero commutes with taking powers. -/\ntheorem {M : Type u} [div_inv_monoid M] (x : M) (z : ℤ) : mul_opposite.op (x ^ z) = mul_opposite.op x ^ z :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- If a subgroup of an additive topological group has `0` in its interior, then it is open. -/\ntheorem {G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 ∈ interior ↑H) : is_open ↑H :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem {G : Type u_3} [group G] : group.fg G ↔ monoid.fg G :=\n\n/-- Any element commutes with itself. -/\ntheorem {S : Type u_1} [has_add S] (a : S) : add_commute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem {S : Type u_1} [has_mul S] (a : S) : commute a a :=\n\n/-- If a subgroup of a topological group has `1` in its interior, then it is open. -/\ntheorem {G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H) : is_open ↑H :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem {M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) (a : M₀) : a = 0 :=\n\n/-- An additive group homomorphism sends negations to negations. -/\ntheorem {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) (a : α) : f (-a) = -f a :=\n\n/--  Every separated topological group in which there exists a compact set with nonempty interior is locally compact. -/\ntheorem {G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G :=\n\n/--  When the domain is non-empty, we do not need the `0 ≤ C` condition in the formula for ∥f∥ as an `Inf`. -/\ntheorem {α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] (f : bounded_continuous_function α β) [h : nonempty α] : ∥f∥ = has_Inf.Inf {C : ℝ | ∀ (x : α), ∥⇑f x∥ ≤ C} :=\n\n/-- Cardinality of a non-empty `Icc` of finsets. -/\ntheorem {α : Type u_1} [decidable_eq α] {s t : finset α} (h : s ⊆ t) : (finset.Icc s t).card = 2 ^ (t.card - s.card) :=\n\n/--  The Sup of a non-empty set is its least upper bound for a conditionally complete lattice with a top. -/\ntheorem {β : Type u_1} [conditionally_complete_lattice β] {s : set (with_top β)} (hs : s.nonempty) : is_lub s (has_Sup.Sup s) :=\n\n/-- A non-empty set is countable iff there exists a surjection from the natural numbers onto the subtype induced by the set. -/\ntheorem {α : Type u} {s : set α} (hs : s.nonempty) : s.countable ↔ ∃ (f : ℕ → ↥s), function.surjective f :=\n\n/-- Every group is non-empty. -/\ntheorem "}
{"text": "All connected components of a topological space are connected.", "fullPrompt": "/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem {α : Type u} [topological_space α] : totally_disconnected_space α ↔ ∀ (x : α), connected_component x = {x} :=\n\n/-- The closure of a (pre)connected set is (pre)connected as well. -/\ntheorem {α : Type u} [topological_space α] {s : set α} (H : is_preconnected s) : is_preconnected (closure s) :=\n\n/--  Theorem of bark and tree : if a set is within a (pre)connected set and its closure, then it is (pre)connected as well. -/\ntheorem {α : Type u} [topological_space α] {s t : set α} (H : is_preconnected s) (Kst : s ⊆ t) (Ktcs : t ⊆ closure s) : is_preconnected t :=\n\n/-- If any two objects in an nonempty category are related by `zigzag`, the category is connected. -/\ntheorem {J : Type u₁} [category_theory.category J] [nonempty J] (h : ∀ (j₁ j₂ : J), category_theory.zigzag j₁ j₂) : category_theory.is_connected J :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem {α : Type u} [topological_space α] {S : set (set α)} (K : directed_on has_subset.subset S) (H : ∀ (s : set α), s ∈ S → is_preconnected s) : is_preconnected (⋃₀S) :=\n\n/-- In a connected category, any two objects are related by `zigzag`. -/\ntheorem {J : Type u₁} [category_theory.category J] [category_theory.is_connected J] (j₁ j₂ : J) : category_theory.zigzag j₁ j₂ :=\n\n/-- A locally compact Hausdorff space is totally disconnected  if and only if it is totally separated. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H ↔ totally_separated_space H :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there  is some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem {X : Type u_1} [topological_space X] (hX : ∀ {x y : X}, x ≠ y → (∃ (U : set X) (h_clopen : is_clopen U), x ∈ U ∧ y ∉ U)) : is_totally_disconnected set.univ :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f :=\n\n/-- If a subgroup of a topological group has `1` in its interior, then it is open. -/\ntheorem {G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H) : is_open ↑H :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s} :=\n\n/--  This lemma characterizes discrete topological spaces as those whose singletons are neighbourhoods. -/\ntheorem {X : Type u_1} [topological_space X] : discrete_topology X ↔ nhds = has_pure.pure :=\n\n/-- Two gcfs `g` and `g'` are equal if and only if their components are equal. -/\ntheorem {α : Type u_1} {g g' : generalized_continued_fraction α} : g = g' ↔ g.h = g'.h ∧ g.s = g'.s :=\n\n/-- A clopen set is the union of its connected components. -/\ntheorem {α : Type u} [topological_space α] {Z : set α} (h : is_clopen Z) : (⋃ (x : α) (H : x ∈ Z), connected_component x) = Z :=\n\n/-- A space is totally disconnected iff its connected components are subsingletons. -/\ntheorem {α : Type u} [topological_space α] : totally_disconnected_space α ↔ ∀ (x : α), (connected_component x).subsingleton :=\n\n/--  Any locally constant function from a cofiltered limit of profinite sets factors through one of the components. -/\ntheorem {J : Type u} [category_theory.small_category J] [category_theory.is_cofiltered J] {F : J ⥤ Profinite} (C : category_theory.limits.cone F) (hC : category_theory.limits.is_limit C) {α : Type u_1} (f : locally_constant ↥(C.X) α) : ∃ (j : J) (g : locally_constant ↥(F.obj j) α), f = locally_constant.comap ⇑(C.π.app j) g :=\n\n/-- A natural transformation is an isomorphism if all its components are isomorphisms. -/\ntheorem {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {F G : C ⥤ D} (α : F ⟶ G) [∀ (X : C), category_theory.is_iso (α.app X)] : category_theory.is_iso α :=\n\n/--  The preimage of a singleton in `connected_components` is the connected component of an element in the equivalence class. -/\ntheorem {α : Type u} [topological_space α] {x : α} : coe ⁻¹' {↑x} = connected_component x :=\n\n/-- All connected components of a topological space are connected. -/\ntheorem "}
{"text": "The ring of integers has a maximal ideal.", "fullPrompt": "/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p :=\n\n/-- The variable of the power series ring over an integral domain is prime. -/\ntheorem {R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X :=\n\n/-- An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring. -/\ntheorem {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c :=\n\n/-- An explicit version of **Bézout's lemma** for Euclidean domains. -/\ntheorem {R : Type u} [euclidean_domain R] [decidable_eq R] (a b : R) : euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b :=\n\n/--  A `comm_ring` `K` which is the localization of an integral domain `R` at `R - {0}` is an integral domain. -/\ntheorem (A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : is_domain K :=\n\n/-- An integral element of an algebra is algebraic. -/\ntheorem (R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A} : is_integral R x → is_algebraic R x :=\n\n/--  The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : p ∣ ring_char R ↔ p ∣ fintype.card R :=\n\n/-- The class number of a principal ideal domain is `1`. -/\ntheorem {R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype.card (class_group R K) = 1 :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.finite K V :=\n\n/-- A minimal polynomial is prime. -/\ntheorem {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x) :=\n\n/-- `R` is integrally closed iff it is the integral closure of itself in its field of fractions. -/\ntheorem {R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R ↔ is_integral_closure R R K :=\n\n/-- The image of the maximal ideal of the source is contained within the maximal ideal of the target. -/\ntheorem {R : Type u} {S : Type v} [comm_semiring R] [local_ring R] [comm_semiring S] [local_ring S] (f : R →+* S) [is_local_ring_hom f] (a : R) (h : a ∈ local_ring.maximal_ideal R) : ⇑f a ∈ local_ring.maximal_ideal S :=\n\n/-- The kernel of a homomorphism to a field is a maximal ideal. -/\ntheorem {R : Type u_1} {K : Type u_2} [ring R] [field K] (f : R →+* K) (hf : function.surjective ⇑f) : f.ker.is_maximal :=\n\n/-- If `R` is a Jacobson ring, and `P` is a maximal ideal of `polynomial R`,  then `R → R[X]/P` is an integral map. -/\ntheorem {R : Type u_1} [comm_ring R] [ideal.is_jacobson R] (P : ideal (polynomial R)) [hP : P.is_maximal] : ((ideal.quotient.mk P).comp polynomial.C).is_integral :=\n\n/-- An element of a DVR is irreducible iff it is a uniformizer, that is, generates the  maximal ideal of R -/\ntheorem {R : Type u} [comm_ring R] [is_domain R] [discrete_valuation_ring R] (ϖ : R) : irreducible ϖ ↔ local_ring.maximal_ideal R = ideal.span {ϖ} :=\n\n/-- The class number is `1` iff the ring of integers is a principal ideal domain. -/\ntheorem {R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_dedekind_domain R] [fintype (class_group R K)] : fintype.card (class_group R K) = 1 ↔ is_principal_ideal_ring R :=\n\n/-- The class number of a function field is `1` iff the ring of integers is a PID. -/\ntheorem (Fq F : Type) [field Fq] [fintype Fq] [field F] [algebra (polynomial Fq) F] [algebra (ratfunc Fq) F] [is_scalar_tower (polynomial Fq) (ratfunc Fq) F] [function_field Fq F] [is_separable (ratfunc Fq) F] : function_field.class_number Fq F = 1 ↔ is_principal_ideal_ring ↥(function_field.ring_of_integers Fq F) :=\n\n/-- The class number of a number field is `1` iff the ring of integers is a PID. -/\ntheorem {K : Type u_1} [field K] [number_field K] : number_field.class_number K = 1 ↔ is_principal_ideal_ring ↥(number_field.ring_of_integers K) :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem (K : Type u_1) [field K] [number_field K] : ¬is_field ↥(number_field.ring_of_integers K) :=\n\n/-- The ring of integers has a maximal ideal. -/\ntheorem "}
{"text": "The numbers `3`, `4` and `5` form a Pythagorean triple.", "fullPrompt": "/--  Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity. -/\ntheorem {x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z :=\n\n/--  `(k*x, k*y, k*z)` is a Pythagorean triple if and only if `(x, y, z)` is also a triple. -/\ntheorem {x y z : ℤ} (k : ℤ) (hk : k ≠ 0) : pythagorean_triple (k * x) (k * y) (k * z) ↔ pythagorean_triple x y z :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem  : pythagorean_triple 0 0 0 :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n :=\n\n/-- The cosine of `π / 3` is `1 / 2`. -/\ntheorem  : real.cos (real.pi / 3) = 1 / 2 :=\n\n/--  A triple is still a triple if you multiply `x`, `y` and `z` by a constant `k`. -/\ntheorem {x y z : ℤ} (h : pythagorean_triple x y z) (k : ℤ) : pythagorean_triple (k * x) (k * y) (k * z) :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ≥ b 3. n ∈ Ico a b -/\ntheorem (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b :=\n\n/--  The square of the sine of `π / 3` is `3 / 4` (this is sometimes more convenient than the result for cosine itself). -/\ntheorem  : real.sin (real.pi / 3) ^ 2 = 3 / 4 :=\n\n/--  The square of the cosine of `π / 6` is `3 / 4` (this is sometimes more convenient than the result for cosine itself). -/\ntheorem  : real.cos (real.pi / 6) ^ 2 = 3 / 4 :=\n\n/-- `choose n 2` is the `n`-th triangle number. -/\ntheorem (n : ℕ) : n.choose 2 = n * (n - 1) / 2 :=\n\n/-- The golden ratio is irrational. -/\ntheorem  : irrational golden_ratio :=\n\n/-- Cyclic permutations preserve the triple product. See also `triple_product_eq_det`. -/\ntheorem {R : Type u_1} [comm_ring R] (u v w : fin 3 → R) : matrix.dot_product u (⇑(⇑cross_product v) w) = matrix.dot_product v (⇑(⇑cross_product w) u) :=\n\n/-- **Pythagorean theorem**, if-and-only-if angle-at-point form. -/\ntheorem {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : has_dist.dist p1 p3 * has_dist.dist p1 p3 = has_dist.dist p1 p2 * has_dist.dist p1 p2 + has_dist.dist p3 p2 * has_dist.dist p3 p2 ↔ euclidean_geometry.angle p1 p2 p3 = real.pi / 2 :=\n\n/--  Pythagorean theorem, subtracting vectors, if-and-only-if vector inner product form. -/\ntheorem {F : Type u_3} [inner_product_space ℝ F] (x y : F) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ has_inner.inner x y = 0 :=\n\n/--  by assuming `x` is odd and `z` is positive we get a slightly more precise classification of the pythagorean triple `x ^ 2 + y ^ 2 = z ^ 2` -/\ntheorem {x y z : ℤ} (h : pythagorean_triple x y z) (h_coprime : x.gcd y = 1) (h_parity : x % 2 = 1) (h_pos : 0 < z) : ∃ (m n : ℤ), x = m ^ 2 - n ^ 2 ∧ y = 2 * m * n ∧ z = m ^ 2 + n ^ 2 ∧ m.gcd n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0) ∧ 0 ≤ m :=\n\n/-- The triple product of `u`, `v`, and `w` is equal to the determinant of the matrix    with those vectors as its rows. -/\ntheorem {R : Type u_1} [comm_ring R] (u v w : fin 3 → R) : matrix.dot_product u (⇑(⇑cross_product v) w) = matrix.det ![u, v, w] :=\n\n/-- The numbers `3`, `4` and `5` form a Pythagorean triple. -/\ntheorem "}
{"text": "A vector space with the empty set as basis is trivial. ", "fullPrompt": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V) : finite_dimensional K V :=\n\n/-- A module has dimension 1 iff there is some `v : V` so `{v}` is a basis. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] : finite_dimensional.finrank K V = 1 ↔ nonempty (basis ι K V) :=\n\n/-- The sum of any function over an empty set is `0`. -/\ntheorem {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} : finsum (λ (i : α), finsum (λ (H : i ∈ ∅), f i)) = 0 :=\n\n/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem {R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0 :=\n\n/-- Any open set is the union of the basis sets contained in it. -/\ntheorem {α : Type u} [t : topological_space α] {B : set (set α)} (hB : topological_space.is_topological_basis B) {u : set α} (ou : is_open u) : u = ⋃₀{s ∈ B | s ⊆ u} :=\n\n/-- If there are zero morphisms, any initial object is a zero object. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C :=\n\n/-- The product of the constant function `0` over any set equals `0`. -/\ntheorem {α : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set α) : finsum (λ (i : α), finsum (λ (H : i ∈ s), 0)) = 0 :=\n\n/-- A finite dimensional space is nontrivial if it has positive `finrank`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V :=\n\n/-- A free module with a basis indexed by a `fintype` is finite. -/\ntheorem {R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) : module.finite R M :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0 :=\n\n/-- A regular element of a `nontrivial` `mul_zero_class` is non-zero. -/\ntheorem {R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a ≠ 0 :=\n\n/-- A finite dimensional space that is a subsingleton has zero `finrank`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0 :=\n\n/-- A vector space with the empty set as basis is trivial.  -/\ntheorem "}
