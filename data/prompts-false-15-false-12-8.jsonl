{"text":"Every ring is a field.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The multivariate polynomial ring over an integral domain is an integral domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {σ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial σ R)\"},\n {\"role\": \"user\", \"content\": \"`R[X]` is never a field for any ring `R`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R], ¬(IsField (Polynomial R) : Prop)\"},\n {\"role\": \"user\", \"content\": \"A seminormed ring is a topological ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NonUnitalSeminormedRing α], TopologicalRing α\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Ring R] (s : Subring R), 1 ∈ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : Semiring R], (IsNoetherianRing R : Prop) ↔ (∀ (I : Ideal R), Ideal.Fg I : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two rings are isomorphic, and the second is a domain, then so is the first. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B] (e : A ≃+* B), IsDomain A\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), (I = ⊥ : Prop) ∨ (I = ⊤ : Prop)\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Ring R] (s : Subring R), 0 ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : NonAssocRing R] (p : ℕ) [inst : CharP R p] [inst : Finite R], p ≠ 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), (Ideal.IsMaximal I : Prop) ↔ (IsField (R ⧸ I) : Prop)\"},\n {\"role\": \"user\", \"content\": \"Every ring involution must be its own inverse \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (↑f (MulOpposite.unop (↑f x))) = x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R] (self : IsField R), ∃ (x : R), ∃ (y : R), x ≠ y\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R} (max : Ideal.IsMaximal M)\\n  (not_field : ¬(IsField R : Prop)), M ≠ ⊥\"},\n {\"role\": \"user\",\n  \"content\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u_1) [inst : LinearOrderedField α] [inst_1 : FloorRing α], Archimedean α\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R] (self : IsField R) (x : R) (y : R), x * y = y * x\"},\n {\"role\": \"user\", \"content\": \"Every ring is a field.\"}]"}
{"text":"Every vector space is finite dimensional.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two vector spaces are isomorphic if they have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} {V₁ : Type v} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V₁] [inst_6 : Module K V₁]\\n  [inst_7 : Module.Free K V₁] (cond : Module.rank K V = Module.rank K V₁), Nonempty (V ≃ₗ[K] V₁)\"},\n {\"role\": \"user\", \"content\": \"A compact discrete space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst : DiscreteTopology α], Finite α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (h : Module.rank K V < Cardinal.aleph0), Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]\\n  [inst_3 : Module R M] [inst_4 : Module R M₂] (f : M ≃ₗ[R] M₂),\\n  FiniteDimensional.finrank R M = FiniteDimensional.finrank R M₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  (Nonempty (V ≃ₗ[K] V') : Prop) ↔ (Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image under an onto linear map of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V₂ : Type v'}\\n  [inst_3 : AddCommGroup V₂] [inst_4 : Module K V₂] [inst_5 : FiniteDimensional K V] (f : V →ₗ[K] V₂)\\n  (hf : LinearMap.range f = ⊤), FiniteDimensional K V₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The range of a linear map defined on a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V₂ : Type v'}\\n  [inst_3 : AddCommGroup V₂] [inst_4 : Module K V₂] [inst_5 : FiniteDimensional K V] (f : V →ₗ[K] V₂),\\n  FiniteDimensional K { x : V₂ // x ∈ LinearMap.range f }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S)\"},\n {\"role\": \"user\",\n  \"content\": \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁] (f : M ≃ₗ[R] M₁), Module.rank R M = Module.rank R M₁\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x : V // x ∈ S }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι} (h : Basis (↑s) K V) (hs : Set.Finite s), FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι] (h : Basis ι K V), FiniteDimensional K V\"},\n {\"role\": \"user\", \"content\": \"Every vector space is finite dimensional.\"}]"}
{"text":"Every group is a torsion monoid.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"1 is of finite order in any monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u} [inst : Monoid G], IsOfFinOrder 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A map to a group preserving multiplication is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : MulOneClass α] [inst_1 : Group β] {f : (a : α) → β} (hf : IsMulHom f), IsMonoidHom f\"},\n {\"role\": \"user\", \"content\": \"A unit in a monoid is regular. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Monoid R] {a : R} (ua : IsUnit a), IsRegular a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The topology on a linearly ordered group with zero element adjoined makes it a topological\\nmonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], ContinuousMul Γ₀\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G} {y : G} (a : x ∈ H) (a : y ∈ H), x * y ∈ H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An additive group homomorphism is an additive monoid homomorphism.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : (a : α) → β} (hf : IsAddGroupHom f),\\n  IsAddMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\": \"Composition of monoid homomorphisms is associative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : One M] [inst_1 : One N] [inst_2 : One P]\\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f)\"},\n {\"role\": \"user\",\n  \"content\": \"The weighted homogeneous submodules form a graded monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {σ : Type u_3} [inst_1 : AddCommMonoid M] {w : (a : σ) → M},\\n  SetLike.GradedMonoid (MvPolynomial.weightedHomogeneousSubmodule R w)\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a group acts commutatively on that group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x : G // x ∈ Subgroup.center G } G\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α) (a_1 : a ≠ 0), a * a⁻¹ = 1\"},\n {\"role\": \"user\", \"content\": \"A monoid is a submonoid of itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {M : Type u_1} [inst : Monoid M], IsSubmonoid Set.univ\"},\n {\"role\": \"user\", \"content\": \"Every subgroup of `ℤ` is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (H : AddSubgroup ℤ), ∃ (a : ℤ), H = AddSubgroup.closure {a}\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : (a : α) → β} (hf : IsGroupHom f), IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], (Group.Fg G : Prop) ↔ (Monoid.Fg G : Prop)\"},\n {\"role\": \"user\", \"content\": \"Every group is a torsion monoid.\"}]"}
{"text":"Every finite simple group has prime order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], (Group.Fg G : Prop) ↔ (Monoid.Fg G : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x : G // x ∈ H }),\\n  (IsOfFinAddOrder x : Prop) ↔ (IsOfFinAddOrder ↑x : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} {y : G} [inst : CommMonoid G] (hx : IsOfFinOrder x) (hy : IsOfFinOrder y), IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : AddMonoid G] {H : Type v} [inst_1 : AddMonoid H] (f : G →+ H) {x : G} (h : IsOfFinAddOrder x),\\n  IsOfFinAddOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x : α} {y : α} (a : x * y ∈ I),\\n  (x ∈ I : Prop) ∨ (y ∈ I : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\",\n  \"content\": \"Set.InjOn Nat.factorization (setOf fun (x : ℕ) ↦ x ≠ 0)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α) (a_1 : a ≠ 0), a * a⁻¹ = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : AddGroup G] {x : G} (hx : IsOfFinAddOrder x), IsOfFinAddOrder (-x)\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : Monoid G] {H : Type v} [inst_1 : Monoid H] (f : G →* H) {x : G} (h : IsOfFinOrder x),\\n  IsOfFinOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} [inst : AddMonoid G], (0 < addOrderOf x : Prop) ↔ (IsOfFinAddOrder x : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} [inst : Monoid G], (0 < orderOf x : Prop) ↔ (IsOfFinOrder x : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : Group G] {x : G}, (IsOfFinOrder x⁻¹ : Prop) ↔ (IsOfFinOrder x : Prop)\"},\n {\"role\": \"user\", \"content\": \"Every finite simple group has prime order.\"}]"}
{"text":"Every finite group is simple.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Finite product of finite sets is finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {δ : Type u_1} [inst : Finite δ] {κ : (a : δ) → Type u_2} {t : (d : δ) → Set (κ d)}\\n  (ht : ∀ (d : δ), Set.Finite (t d)), Set.Finite (Set.pi Set.univ t)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} {y : G} [inst : CommMonoid G] (hx : IsOfFinOrder x) (hy : IsOfFinOrder y), IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\": \"The submodule generated by a finite set is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V}\\n  (hA : Set.Finite A), FiniteDimensional K { x : V // x ∈ Submodule.span K A }\"},\n {\"role\": \"user\",\n  \"content\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {σ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial σ R),\\n  ∃ (n : ℕ),\\n    ∃ (f : (a : Fin n) → σ),\\n      ∃ (_hf : Function.Injective f), ∃ (q : MvPolynomial (Fin n) R), p = ↑(MvPolynomial.rename f) q\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : Group G] {x : G}, (IsOfFinOrder x⁻¹ : Prop) ↔ (IsOfFinOrder x : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} [inst : Monoid G], (0 < orderOf x : Prop) ↔ (IsOfFinOrder x : Prop)\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} (f : (a : α) → Finset β) (h : Set.Finite (Set.range f)),\\n  Set.Finite (Set.unionᵢ fun (a : α) ↦ ↑(f a))\"},\n {\"role\": \"user\", \"content\": \"Every subgroup of `ℤ` is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (H : AddSubgroup ℤ), ∃ (a : ℤ), H = AddSubgroup.closure {a}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G),\\n  (Subgroup.Fg P : Prop) ↔ (Submonoid.Fg (Subgroup.toSubmonoid P) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any `K`-algebra module that is 1-dimensional over `K` is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Type u_1}\\n  [inst_3 : Semiring A] [inst_4 : Module A V] [inst_5 : SMul K A] [inst_6 : IsScalarTower K A V]\\n  (h : FiniteDimensional.finrank K V = 1), IsSimpleOrder (Submodule A V)\"},\n {\"role\": \"user\",\n  \"content\": \"A finite group action is always properly discontinuous.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {Γ : Type u_1} [inst : AddGroup Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Γ T]\\n  [inst_3 : Finite Γ], ProperlyDiscontinuousVAdd Γ T\"},\n {\"role\": \"user\",\n  \"content\": \"A finite group action is always properly discontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\\n  [inst_3 : Finite Γ], ProperlyDiscontinuousSMul Γ T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M)\\n  (li : LinearIndependent R Subtype.val) (t : Finset ↑s), LinearIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], (Group.Fg G : Prop) ↔ (Monoid.Fg G : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α) (a_1 : a ≠ 0), a * a⁻¹ = 1\"},\n {\"role\": \"user\", \"content\": \"Every finite group is simple.\"}]"}
{"text":"Every finite group has prime order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], (Group.Fg G : Prop) ↔ (Monoid.Fg G : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x : G // x ∈ H }),\\n  (IsOfFinAddOrder x : Prop) ↔ (IsOfFinAddOrder ↑x : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} {y : G} [inst : CommMonoid G] (hx : IsOfFinOrder x) (hy : IsOfFinOrder y), IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : AddMonoid G] {H : Type v} [inst_1 : AddMonoid H] (f : G →+ H) {x : G} (h : IsOfFinAddOrder x),\\n  IsOfFinAddOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : AddGroup G] {x : G} (hx : IsOfFinAddOrder x), IsOfFinAddOrder (-x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x : α} {y : α} (a : x * y ∈ I),\\n  (x ∈ I : Prop) ∨ (y ∈ I : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α) (a_1 : a ≠ 0), a * a⁻¹ = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} [inst : AddMonoid G], (0 < addOrderOf x : Prop) ↔ (IsOfFinAddOrder x : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\",\n  \"content\": \"Set.InjOn Nat.factorization (setOf fun (x : ℕ) ↦ x ≠ 0)\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : Monoid G] {H : Type v} [inst_1 : Monoid H] (f : G →* H) {x : G} (h : IsOfFinOrder x),\\n  IsOfFinOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} [inst : Monoid G], (0 < orderOf x : Prop) ↔ (IsOfFinOrder x : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : Group G] {x : G}, (IsOfFinOrder x⁻¹ : Prop) ↔ (IsOfFinOrder x : Prop)\"},\n {\"role\": \"user\", \"content\": \"Every finite group has prime order.\"}]"}
{"text":"Every set has Lebesgue measure zero.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The closed thickening with radius zero is the closure of the set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] (E : Set α), Metric.cthickening 0 E = closure E\"},\n {\"role\": \"user\", \"content\": \"In a compact space, all sets are bounded \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : CompactSpace α], Metric.Bounded s\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two sets are at zero Hausdorff edistance if and only if they have the same closure \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α} {t : Set α},\\n  (EMetric.hausdorffEdist s t = 0 : Prop) ↔ (closure s = closure t : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of the constant function `0` over any set equals `0`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] (s : Set α),\\n  (finsum fun (i : α) ↦ finsum fun (h : i ∈ s) ↦ 0) = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two sets are at zero Hausdorff distance if and only if they have the same closures \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {t : Set α} (fin : EMetric.hausdorffEdist s t ≠ ⊤),\\n  (Metric.hausdorffDist s t = 0 : Prop) ↔ (closure s = closure t : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of any function over an empty set is `0`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : (a : α) → M},\\n  (finsum fun (i : α) ↦ finsum fun (h : i ∈ ∅) ↦ f i) = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Uniform convergence on the empty set is vacuously true \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : (a : ι) → (a : α) → β} {f : (a : α) → β}\\n  {p : Filter ι}, TendstoUniformlyOn F f p ∅\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two closed sets are at zero Hausdorff distance if and only if they coincide \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {t : Set α} (hs : IsClosed s) (ht : IsClosed t)\\n  (fin : EMetric.hausdorffEdist s t ≠ ⊤), (Metric.hausdorffDist s t = 0 : Prop) ↔ (s = t : Prop)\"},\n {\"role\": \"user\", \"content\": \"The zeroth Pythagorean triple is all zeros. \"},\n {\"role\": \"assistant\", \"content\": \"PythagoreanTriple 0 0 0\"},\n {\"role\": \"user\", \"content\": \"Constant zero function has sum `0` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α], HasSum (fun (x : β) ↦ 0) 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two closed sets are at zero Hausdorff edistance if and only if they coincide \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α} {t : Set α} (hs : IsClosed s) (ht : IsClosed t),\\n  (EMetric.hausdorffEdist s t = 0 : Prop) ↔ (s = t : Prop)\"},\n {\"role\": \"user\", \"content\": \"The empty set has zero diameter \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : PseudoMetricSpace α], Metric.diam ∅ = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The Hausdorff distance between a set and itself is zero \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.hausdorffDist s s = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : Zero α] [inst_1 : Zero β] [inst_2 : SMulWithZero α β] [inst_3 : DecidableEq β]\\n  {s : Finset β} (h : Finset.Nonempty s), 0 • s = 0\"},\n {\"role\": \"user\", \"content\": \"Every set has Lebesgue measure zero.\"}]"}
{"text":"If a topological space is compact, then every subset is compact.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {t : Set α} (hs : IsCompact s) (ht : IsClosed t),\\n  IsCompact (s ∩ t)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α} (hs : IsCompact s), IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α}\\n  (hK : IsCompact K), ∃ (V : Set α), (IsOpen V : Prop) ∧ ((K ⊆ V : Prop) ∧ (IsCompact (closure V) : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U : Set α) (V : Set α) (a : IsOpen U)\\n  (a : IsCompact U) (a : IsOpen V) (a : IsCompact V), IsCompact (U ∩ V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {t : Set α} (ht : IsCompact t) (hs : IsClosed s),\\n  IsCompact (s ∩ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α),\\n  ∃ (K : Set α), (IsCompact K : Prop) ∧ (K ∈ nhds x : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (Alexandroff X)\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {t : Set α} (hs : IsCompact s) (ht : IsClosed t) (h : t ⊆ s),\\n  IsCompact t\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α} (hK : IsCompact K),\\n  ∃ (K' : Set α), (IsCompact K' : Prop) ∧ (K ⊆ interior K' : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (self : CompHaus), CompactSpace (CategoryTheory.Bundled.α (CompHaus.toTop self))\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a topological space is compact, then every subset is compact.\"}]"}
{"text":"Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two sets are at zero Hausdorff distance if and only if they have the same closures \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {t : Set α} (fin : EMetric.hausdorffEdist s t ≠ ⊤),\\n  (Metric.hausdorffDist s t = 0 : Prop) ↔ (closure s = closure t : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a metric space, the minimal edistance to a nonempty set is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {x : α} (h : Set.Nonempty s), EMetric.infEdist x s ≠ ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially compact set in a uniform space is totally bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] {s : Set X} (h : IsSeqCompact s), TotallyBounded s\"},\n {\"role\": \"user\",\n  \"content\": \"The closure of a totally bounded set is totally bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : UniformSpace α] {s : Set α} (h : TotallyBounded s), TotallyBounded (closure s)\"},\n {\"role\": \"user\", \"content\": \"Subsets of bounded sets are bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : SeminormedRing 𝕜] [inst_1 : SMul 𝕜 E] [inst_2 : Zero E]\\n  [inst_3 : TopologicalSpace E] {s₁ : Set E} {s₂ : Set E} (h : s₁ ⊆ s₂) (hs₂ : Bornology.IsVonNBounded 𝕜 s₂),\\n  Bornology.IsVonNBounded 𝕜 s₁\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α), IsCompact s\"},\n {\"role\": \"user\", \"content\": \"The empty set has zero diameter \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : PseudoMetricSpace α], Metric.diam ∅ = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of the constant function `0` over any set equals `0`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] (s : Set α),\\n  (finsum fun (i : α) ↦ finsum fun (h : i ∈ s) ↦ 0) = 0\"},\n {\"role\": \"user\", \"content\": \"A singleton is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] [self : MeasurableSingletonClass α] (x : α), MeasurableSet {x}\"},\n {\"role\": \"user\",\n  \"content\": \"An ordinal lifted to the zero universe equals itself. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (a : Ordinal), Ordinal.lift a = a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a measurable set under a measurable embedding is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {f : (a : α) → β}\\n  (self : MeasurableEmbedding f) ⦃s : Set α⦄ (a : MeasurableSet s), MeasurableSet (f '' s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two closed sets are at zero Hausdorff edistance if and only if they coincide \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α} {t : Set α} (hs : IsClosed s) (ht : IsClosed t),\\n  (EMetric.hausdorffEdist s t = 0 : Prop) ↔ (s = t : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two closed sets are at zero Hausdorff distance if and only if they coincide \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {t : Set α} (hs : IsClosed s) (ht : IsClosed t)\\n  (fin : EMetric.hausdorffEdist s t ≠ ⊤), (Metric.hausdorffDist s t = 0 : Prop) ↔ (s = t : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"The Hausdorff distance between a set and itself is zero \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.hausdorffDist s s = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : Zero α] [inst_1 : Zero β] [inst_2 : SMulWithZero α β] [inst_3 : DecidableEq β]\\n  {s : Finset β} (h : Finset.Nonempty s), 0 • s = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.\"}]"}
{"text":"A finitely-presented group containing a torsion element is finite.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A submodule is finitely generated if and only if it is finite-dimensional \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (s : Submodule K V),\\n  (Submodule.Fg s : Prop) ↔ (FiniteDimensional K { x : V // x ∈ s } : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : AddMonoid G] {H : Type v} [inst_1 : AddMonoid H] (f : G →+ H) {x : G} (h : IsOfFinAddOrder x),\\n  IsOfFinAddOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : Monoid G] {H : Type v} [inst_1 : Monoid H] (f : G →* H) {x : G} (h : IsOfFinOrder x),\\n  IsOfFinOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\": \"A finite group action is always properly discontinuous.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {Γ : Type u_1} [inst : AddGroup Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Γ T]\\n  [inst_3 : Finite Γ], ProperlyDiscontinuousVAdd Γ T\"},\n {\"role\": \"user\",\n  \"content\": \"The submodule generated by a finset is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (s : Finset V),\\n  FiniteDimensional K { x : V // x ∈ Submodule.span K ↑s }\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : Group G] {x : G}, (IsOfFinOrder x⁻¹ : Prop) ↔ (IsOfFinOrder x : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G),\\n  (Subgroup.Fg P : Prop) ↔ (Submonoid.Fg (Subgroup.toSubmonoid P) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} [inst : AddMonoid G], (0 < addOrderOf x : Prop) ↔ (IsOfFinAddOrder x : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"The submodule generated by a finite set is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V}\\n  (hA : Set.Finite A), FiniteDimensional K { x : V // x ∈ Submodule.span K A }\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} {y : G} [inst : CommMonoid G] (hx : IsOfFinOrder x) (hy : IsOfFinOrder y), IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group `G` is finitely generated if and only if `AddMonoidAlgebra R G` is of finite type. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommGroup G] [inst_1 : CommRing R] [inst_2 : Nontrivial R],\\n  (Algebra.FiniteType R (MonoidAlgebra R G) : Prop) ↔ (Group.Fg G : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"A finite group action is always properly discontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\\n  [inst_3 : Finite Γ], ProperlyDiscontinuousSMul Γ T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The submodule generated by a single element is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (x : V),\\n  FiniteDimensional K { x_1 : V // x_1 ∈ Submodule.span K {x} }\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} [inst : Monoid G], (0 < orderOf x : Prop) ↔ (IsOfFinOrder x : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], (Group.Fg G : Prop) ↔ (Monoid.Fg G : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finitely-presented group containing a torsion element is finite.\"}]"}
{"text":"If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : (a : α) → α} (hf : Continuous f),\\n  IsClosed (Function.fixedPoints f)\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (self : CompHaus), CompactSpace (CategoryTheory.Bundled.α (CompHaus.toTop self))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a sequential space, a set is closed iff it's sequentially closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {M : Set X},\\n  (IsSeqClosed M : Prop) ↔ (IsClosed M : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"In a sequential space, a sequentially closed set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {s : Set X} (hs : IsSeqClosed s), IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {t : Set α} (ht : IsCompact t) (hs : IsClosed s),\\n  IsCompact (s ∩ t)\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  (Dense ↑s : Prop) ↔ (Submodule.topologicalClosure s = ⊤ : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {t : Set α} (hs : IsCompact s) (ht : IsClosed t),\\n  IsCompact (s ∩ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul 𝕜 E] {s : Set E}\\n  (hs : Convex 𝕜 s), Convex 𝕜 (closure s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α} (hK : IsCompact K),\\n  ∃ (K' : Set α), (IsCompact K' : Prop) ∧ (K ⊆ interior K' : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\"},\n {\"role\": \"user\",\n  \"content\": \"Subsets of a given closed subset form a closed set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] {s : Set α} (hs : IsClosed s),\\n  IsClosed (setOf fun (t : TopologicalSpace.Closeds α) ↦ ↑t ⊆ s)\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {t : Set α} (hs : IsCompact s) (ht : IsClosed t) (h : t ⊆ s),\\n  IsCompact t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.\"}]"}
{"text":"A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a complete space, the type of closed subsets is complete for the\\nHausdorff edistance. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompleteSpace α], CompleteSpace (TopologicalSpace.Closeds α)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (Alexandroff X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis (setOf fun (s : Set H) ↦ IsClopen s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  (TotallyDisconnectedSpace H : Prop) ↔ (TotallySeparatedSpace H : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : CompHaus} {Y : CompHaus} (f : X ⟶ Y)\\n  (bij : Function.Bijective (Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.forget CompHaus)) f)),\\n  CategoryTheory.IsIso f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : (a : α) → β} (h : Continuous f) (hf : Function.Injective f), ClosedEmbedding f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : CompHaus} {Y : CompHaus} (f : X ⟶ Y),\\n  IsClosedMap (Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.forget CompHaus)) f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x : α) (y : α) (a : x ≠ y),\\n  ∃ (u : Set α),\\n    ∃ (v : Set α),\\n      (IsOpen u : Prop) ∧\\n        ((IsOpen v : Prop) ∧ ((x ∈ u : Prop) ∧ ((y ∈ v : Prop) ∧ (Disjoint u v : Prop) : Prop) : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : (a : α) → β} (h : Continuous f), IsClosedMap f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.\"}]"}
{"text":"Any finite order element in a group is equal to the identity.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} {y : G} [inst : Monoid G] (h : Commute x y) (hx : IsOfFinOrder x) (hy : IsOfFinOrder y),\\n  IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : AddGroup G] {x : G}, (IsOfFinAddOrder (-x) : Prop) ↔ (IsOfFinAddOrder x : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite additive order are closed under addition.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} {y : G} [inst : AddCommMonoid G] (hx : IsOfFinAddOrder x) (hy : IsOfFinAddOrder y),\\n  IsOfFinAddOrder (x + y)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x : G // x ∈ H }),\\n  (IsOfFinAddOrder x : Prop) ↔ (IsOfFinAddOrder ↑x : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : AddGroup G] {x : G} (hx : IsOfFinAddOrder x), IsOfFinAddOrder (-x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : AddMonoid G] {H : Type v} [inst_1 : AddMonoid H] (f : G →+ H) {x : G} (h : IsOfFinAddOrder x),\\n  IsOfFinAddOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : Monoid G] {H : Type v} [inst_1 : Monoid H] (f : G →* H) {x : G} (h : IsOfFinOrder x),\\n  IsOfFinOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} [inst : AddMonoid G], (0 < addOrderOf x : Prop) ↔ (IsOfFinAddOrder x : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} {y : G} [inst : CommMonoid G] (hx : IsOfFinOrder x) (hy : IsOfFinOrder y), IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : Group G] {x : G}, (IsOfFinOrder x⁻¹ : Prop) ↔ (IsOfFinOrder x : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} [inst : Monoid G], (0 < orderOf x : Prop) ↔ (IsOfFinOrder x : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α) (a_1 : a ≠ 0), a * a⁻¹ = 1\"},\n {\"role\": \"user\",\n  \"content\": \"Any finite order element in a group is equal to the identity.\"}]"}
{"text":"If a subgroup of a group is torsion-free, then the group itself is torsion free.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G} (a : ∀ (x : G) (a : x ∈ l), x ∈ K), List.prod l ∈ K\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], (Group.Fg G : Prop) ↔ (Monoid.Fg G : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), (H = ⊥ : Prop) ∨ (∃ (x : G), (x ∈ H : Prop) ∧ (x ≠ 1 : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a topological group embeds into a nonarchimedean group, then it is nonarchimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {H : Type u_2}\\n  [inst_3 : Group H] [inst_4 : TopologicalSpace H] [inst_5 : TopologicalGroup H] (f : G →* H) (emb : OpenEmbedding ↑f),\\n  NonarchimedeanGroup H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x : α // x ∈ s }],\\n  Fintype.card { x : α // x ∈ s } ∣ Fintype.card α\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ : Subgroup G) (H₂ : Subgroup G) (hH₁ : Subgroup.Normal H₁)\\n  (hH₂ : Subgroup.Normal H₂) (hdis : Disjoint H₁ H₂) (x : G) (y : G) (hx : x ∈ H₁) (hy : y ∈ H₂), Commute x y\"},\n {\"role\": \"user\",\n  \"content\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), (H = ⊥ : Prop) ∨ (Nontrivial { x : G // x ∈ H } : Prop)\"},\n {\"role\": \"user\", \"content\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ : AddSubgroup G) (H₂ : AddSubgroup G) (hH₁ : AddSubgroup.Normal H₁)\\n  (hH₂ : AddSubgroup.Normal H₂) (hdis : Disjoint H₁ H₂) (x : G) (y : G) (hx : x ∈ H₁) (hy : y ∈ H₂), AddCommute x y\"},\n {\"role\": \"user\",\n  \"content\": \"The topological closure of a normal subgroup is normal.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\"},\n {\"role\": \"user\", \"content\": \"Every subgroup of `ℤ` is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (H : AddSubgroup ℤ), ∃ (a : ℤ), H = AddSubgroup.closure {a}\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G} (a : x ∈ H), x⁻¹ ∈ H\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S} {x : M}\\n  {y : M} (hx : x ∈ H) (hy : y ∈ H), x / y ∈ H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : Group G] (H : Subgroup G) (h : Subsingleton (G ⧸ H)), H = ⊤\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G} {y : G} (a : x ∈ H) (a : y ∈ H), x * y ∈ H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G),\\n  (Subgroup.Fg P : Prop) ↔ (Submonoid.Fg (Subgroup.toSubmonoid P) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a subgroup of a group is torsion-free, then the group itself is torsion free.\"}]"}
{"text":"Every injective homomorphism from a finitely generated free group to itself is surjective.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism sends 1 to 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : (a : α) → β} (hf : IsGroupHom f), f 1 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M →* P),\\n  Function.Injective ↑(Con.kerLift f)\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : (a : α) → β} (hf : IsGroupHom f), IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\": \"A group homomorphism sends inverses to inverses. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : (a : α) → β} (hf : IsGroupHom f) (a : α),\\n  f a⁻¹ = (f a)⁻¹\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The canonical map from the type to the free group is an injection. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u}, Function.Injective FreeGroup.of\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R₁ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R₁] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra R₁ A] [inst_4 : Algebra R₁ B] (f : A →ₐ[R₁] B), Function.Injective ↑(Ideal.kerLiftAlg f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ↑(Con.mk' c)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M) (s : Function.Surjective ↑f), Function.Bijective ↑f\"},\n {\"role\": \"user\", \"content\": \"Group homomorphisms preserve inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹\"},\n {\"role\": \"user\",\n  \"content\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V →ₗ[K] V} (hinj : Function.Injective ↑f), Function.Surjective ↑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : (a : α) → β} (hf : IsAddGroupHom f),\\n  (Function.Injective f : Prop) ↔ (∀ (a : α) (a_1 : f a = 0), a = 0 : Prop)\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is surjective \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\\n  [self : RingHomSurjective σ], Function.Surjective ↑σ\"},\n {\"role\": \"user\",\n  \"content\": \"Every graph homomomorphism from a complete graph is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ⊤ →g G'), Function.Injective ↑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M) (s : Function.Surjective ↑f), Function.Injective ↑f\"},\n {\"role\": \"user\",\n  \"content\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : (a : α) → β} (hf : IsGroupHom f),\\n  (Function.Injective f : Prop) ↔ (∀ (a : α) (a_1 : f a = 1), a = 1 : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every injective homomorphism from a finitely generated free group to itself is surjective.\"}]"}
{"text":"Every division ring is either a field or finite.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded below.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : Nonempty α] {s : Set α} (hs : Set.Finite s), BddBelow s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : Semiring R], (IsNoetherianRing R : Prop) ↔ (∀ (I : Ideal R), Ideal.Fg I : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R} (max : Ideal.IsMaximal M)\\n  (not_field : ¬(IsField R : Prop)), M ≠ ⊥\"},\n {\"role\": \"user\", \"content\": \"Every ring involution must be its own inverse \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (↑f (MulOpposite.unop (↑f x))) = x\"},\n {\"role\": \"user\", \"content\": \"A product of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : (a : ι) → WithTop R}\\n  (h : ∀ (i : ι) (a : i ∈ s), f i ≠ ⊤), (Finset.prod s fun (i : ι) ↦ f i) < ⊤\"},\n {\"role\": \"user\", \"content\": \"The rank of a finite module is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) (M : Type v) [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] [inst_4 : Module.Finite R M], Module.rank R M < Cardinal.aleph0\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} (h : Set.Finite s), Metric.Bounded s\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x : K} {y : K} (a : x ∈ s) (a : y ∈ s), x / y ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u_1) [inst : LinearOrderedField α] [inst_1 : FloorRing α], Archimedean α\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : NonAssocRing R] (p : ℕ) [inst : CharP R p] [inst : Finite R], p ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is always less than division in the field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m : ℕ} {n : ℕ}, ↑(m / n) ≤ ↑m / ↑n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R] (self : IsField R), ∃ (x : R), ∃ (y : R), x ≠ y\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), (I = ⊥ : Prop) ∨ (I = ⊤ : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is the floor of field division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] [inst_1 : FloorSemiring α] (m : ℕ) (n : ℕ), ⌊↑m / ↑n⌋₊ = m / n\"},\n {\"role\": \"user\",\n  \"content\": \"Every division ring is either a field or finite.\"}]"}
{"text":"Every natural number is the product of two primes.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} (h : n ≠ 0) (d : ℕ), Filter.Frequently (fun (m : ℕ) ↦ m ≡ d [MOD n]) Filter.atTop\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A binomial coefficient is the product of its prime factors, which are at most `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ) (k : ℕ) (hkn : k ≤ n),\\n  (Finset.prod (Finset.range (n + 1)) fun (p : ℕ) ↦ p ^ ↑(Nat.factorization (Nat.choose n k)) p) = Nat.choose n k\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} {q : ℕ} (hp : Nat.Prime p) (h : ↑(Nat.factorization p) q ≠ 0), p = q\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m : ℕ} {n : ℕ} (hn : Odd n) (hm : m ∣ n), m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (self : ℚ), Nat.coprime (Int.natAbs (Rat.num self)) (Rat.den self)\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], (Nat.Prime q : Prop) ∨ (q = 1 : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ), (Nat.factorization n = 0 : Prop) ↔ ((n = 0 : Prop) ∨ (n = 1 : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a : ℕ) (b : ℕ) (ha : a ≠ 0) (hb : b ≠ 0),\\n  (a = b : Prop) ↔ (∀ (p : ℕ) (a_1 : Nat.Prime p), padicValNat p a = padicValNat p b : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x : α} {y : α} (a : x * y ∈ I),\\n  (x ∈ I : Prop) ∨ (y ∈ I : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p : Prop)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a : Associates α}\\n  {p : Associates α} (hp : Irreducible p) [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n : Prop)] {n : ℕ} (h : a ∣ p ^ n),\\n  a = p ^ Nat.find ((Exists.intro n h=:∃ (n : ℕ), (fun (n : ℕ) ↦ a ∣ p ^ n) n)=:∃ (n : ℕ), (fun (n : ℕ) ↦ a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {m : ℕ} {n : ℕ}, (∀ (a : ℕ), (m ∣ a : Prop) ↔ (n ∣ a : Prop) : Prop) ↔ (m = n : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {m : ℕ} {n : ℕ}, (∀ (a : ℕ), (a ∣ m : Prop) ↔ (a ∣ n : Prop) : Prop) ↔ (m = n : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\",\n  \"content\": \"Set.InjOn Nat.factorization (setOf fun (x : ℕ) ↦ x ≠ 0)\"},\n {\"role\": \"user\",\n  \"content\": \"Every natural number is the product of two primes.\"}]"}
{"text":"Every even number is the square of a natural number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p : Prop)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a : Associates α}\\n  {p : Associates α} (hp : Irreducible p) [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n : Prop)] {n : ℕ} (h : a ∣ p ^ n),\\n  a = p ^ Nat.find ((Exists.intro n h=:∃ (n : ℕ), (fun (n : ℕ) ↦ a ∣ p ^ n) n)=:∃ (n : ℕ), (fun (n : ℕ) ↦ a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℕ} {b : ℕ} (w : a ∣ b) (h : b < a), b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Note that most of the lemmas about powers of two refer to it as `sq`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a\"},\n {\"role\": \"user\",\n  \"content\": \"There are no perfect squares strictly between m² and (m+1)² \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} {m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)), ¬(∃ (t : ℕ), t * t = n : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a : ℕ) (b : ℕ) (ha : a ≠ 0) (hb : b ≠ 0),\\n  (a = b : Prop) ↔ (∀ (p : ℕ) (a_1 : Nat.Prime p), padicValNat p a = padicValNat p b : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m : ℕ} {n : ℕ} (hn : Odd n) (hm : m ∣ n), m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x : α} {y : α},\\n  (x * x + y * y = 0 : Prop) ↔ ((x = 0 : Prop) ∧ (y = 0 : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, (n % 2 = 1 : Prop) ↔ ((n % 4 = 1 : Prop) ∨ (n % 4 = 3 : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {m : ℕ} {n : ℕ}, (∀ (a : ℕ), (a ∣ m : Prop) ↔ (a ∣ n : Prop) : Prop) ↔ (m = n : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\",\n  \"content\": \"Set.InjOn Nat.factorization (setOf fun (x : ℕ) ↦ x ≠ 0)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {m : ℕ} {n : ℕ}, (∀ (a : ℕ), (m ∣ a : Prop) ↔ (n ∣ a : Prop) : Prop) ↔ (m = n : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Every even number is the square of a natural number.\"}]"}
{"text":"Every normal subgroup of a group has finite index.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G} (a : x ∈ H), x⁻¹ ∈ H\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : Group G] {x : G}, (IsOfFinOrder x⁻¹ : Prop) ↔ (IsOfFinOrder x : Prop)\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S} {x : M}\\n  {y : M} (hx : x ∈ H) (hy : y ∈ H), x / y ∈ H\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x : G // x ∈ H }),\\n  (IsOfFinAddOrder x : Prop) ↔ (IsOfFinAddOrder ↑x : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a module has a finite dimension, all bases are indexed by a finite type. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {ι : Type u_1} (b : Basis ι R M) (h : Module.rank R M < Cardinal.aleph0), Nonempty (Fintype ι)\"},\n {\"role\": \"user\", \"content\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ : AddSubgroup G) (H₂ : AddSubgroup G) (hH₁ : AddSubgroup.Normal H₁)\\n  (hH₂ : AddSubgroup.Normal H₂) (hdis : Disjoint H₁ H₂) (x : G) (y : G) (hx : x ∈ H₁) (hy : y ∈ H₂), AddCommute x y\"},\n {\"role\": \"user\",\n  \"content\": \"The topological closure of a normal subgroup is normal.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G} {y : G} (a : x ∈ H) (a : y ∈ H), x * y ∈ H\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ : Subgroup G) (H₂ : Subgroup G) (hH₁ : Subgroup.Normal H₁)\\n  (hH₂ : Subgroup.Normal H₂) (hdis : Disjoint H₁ H₂) (x : G) (y : G) (hx : x ∈ H₁) (hy : y ∈ H₂), Commute x y\"},\n {\"role\": \"user\",\n  \"content\": \"The submodule generated by a finite set is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V}\\n  (hA : Set.Finite A), FiniteDimensional K { x : V // x ∈ Submodule.span K A }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a module has a finite dimension, all bases are indexed by a finite set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {ι : Type u_1} {s : Set ι} (b : Basis (↑s) R M) (h : Module.rank R M < Cardinal.aleph0),\\n  Set.Finite s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G),\\n  (Subgroup.Fg P : Prop) ↔ (Submonoid.Fg (Subgroup.toSubmonoid P) : Prop)\"},\n {\"role\": \"user\", \"content\": \"The additive subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ≠ 0\"},\n {\"role\": \"user\", \"content\": \"The subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"Every normal subgroup of a group has finite index.\"}]"}
{"text":"The characteristic polynomial of every matrix has real roots.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Every coefficient in a Cantor normal form is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {b : Ordinal} {o : Ordinal} {x : Ordinal × Ordinal} (a : x ∈ Ordinal.CNF b o), 0 < Prod.snd x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any matrix can be reduced to diagonal form by elementary operations. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : Type u_1} {𝕜 : Type u_2} [inst : Field 𝕜] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n 𝕜),\\n  ∃ (L : List (Matrix.TransvectionStruct n 𝕜)),\\n    ∃ (L' : List (Matrix.TransvectionStruct n 𝕜)),\\n      ∃ (D : (a : n) → 𝕜),\\n        Matrix.mul (Matrix.mul (List.prod (List.map Matrix.TransvectionStruct.toMatrix L)) M)\\n            (List.prod (List.map Matrix.TransvectionStruct.toMatrix L')) =\\n          Matrix.diagonal D\"},\n {\"role\": \"user\",\n  \"content\": \"A helper lemma: the characteristic is prime if it is non-zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : ℕ} [hp : CharP R p]\\n  (p_ne_zero : p ≠ 0), Nat.Prime p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a matrix has a repeated column, the determinant will be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] {M : Matrix n n R}\\n  {i : n} {j : n} (i_ne_j : i ≠ j) (hij : ∀ (k : n), M k i = M k j), Matrix.det M = 0\"},\n {\"role\": \"user\",\n  \"content\": \"If a matrix has a repeated row, the determinant will be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] {M : Matrix n n R}\\n  {i : n} {j : n} (i_ne_j : i ≠ j) (hij : M i = M j), Matrix.det M = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quadratic has roots if and only if its discriminant equals some square.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {a : R} {b : R} {c : R} [inst_1 : NeZero 2] [inst_2 : NoZeroDivisors R]\\n  (ha : a ≠ 0) (x : R), (a * x * x + b * x + c = 0 : Prop) ↔ (discrim a b c = (2 * a * x + b) ^ 2 : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every polynomial is the sum of its weighted homogeneous components. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_3} [inst : CommSemiring R] {σ : Type u_2} [inst_1 : AddCommMonoid M] (w : (a : σ) → M)\\n  (φ : MvPolynomial σ R), (finsum fun (m : M) ↦ ↑(MvPolynomial.weightedHomogeneousComponent w m) φ) = φ\"},\n {\"role\": \"user\",\n  \"content\": \"The determinant of a permutation matrix equals its sign. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (σ : Equiv.Perm n),\\n  Matrix.det (PEquiv.toMatrix (Equiv.toPEquiv σ)) = ↑↑(↑Equiv.Perm.sign σ)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R)\\n  (hp : ∀ (n : ℕ), Polynomial.coeff p n ∈ Ideal.comap Polynomial.C I), p ∈ I\"},\n {\"role\": \"user\",\n  \"content\": \"A quadratic has roots if its discriminant has square roots \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a : K} {b : K} {c : K} (ha : a ≠ 0)\\n  (h : ∃ (s : K), discrim a b c = s * s), ∃ (x : K), a * x * x + b * x + c = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A polynomial splits if and only if it has as many roots as its degree. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type v} [inst : Field K] {p : Polynomial K},\\n  (Polynomial.Splits (RingHom.id K) p : Prop) ↔ (↑Multiset.card (Polynomial.roots p) = Polynomial.natDegree p : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {σ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial σ R),\\n  ∃ (n : ℕ),\\n    ∃ (f : (a : Fin n) → σ),\\n      ∃ (_hf : Function.Injective f), ∃ (q : MvPolynomial (Fin n) R), p = ↑(MvPolynomial.rename f) q\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic polynomial of every matrix has real roots.\"}]"}
{"text":"In a commutative ring, every prime ideal is contained in a unique maximal ideal.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R] (hR : IsField R) (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R)\\n  (hx : ↑Polynomial.C x ∈ I), x = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : Semiring R], (IsNoetherianRing R : Prop) ↔ (∀ (I : Ideal R), Ideal.Fg I : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"The kernel of a homomorphism to a domain is a prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsDomain S]\\n  [inst_3 : RingHomClass F R S] (f : F), Ideal.IsPrime (RingHom.ker f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The surjective image of a principal ideal ring is again a principal ideal ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R →+* S)\\n  (hf : Function.Surjective ↑f), IsPrincipalIdealRing S\"},\n {\"role\": \"user\",\n  \"content\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ⦃J : Order.Ideal P⦄ (a : I < J),\\n  ↑J = Set.univ\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R} (max : Ideal.IsMaximal M)\\n  (not_field : ¬(IsField R : Prop)), M ≠ ⊥\"},\n {\"role\": \"user\",\n  \"content\": \"The kernel of a homomorphism to a field is a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F)\\n  (hf : Function.Surjective ↑f), Ideal.IsMaximal (RingHom.ker f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x : α} {y : α} (a : x * y ∈ I),\\n  (x ∈ I : Prop) ∨ (y ∈ I : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ (M : Ideal α), Ideal.IsMaximal M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R) (hqf : IsField (R ⧸ I)), Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), (Ideal.IsMaximal I : Prop) ↔ (IsField (R ⧸ I) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (H : ∀ (P : Ideal R) (a : Ideal.IsPrime P), Submodule.IsPrincipal P),\\n  IsPrincipalIdealRing R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a commutative ring, every prime ideal is contained in a unique maximal ideal.\"}]"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Uniform equicontinuity implies equicontinuity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\\n  {F : (a : ι) → (a : β) → α} (h : UniformEquicontinuous F), Equicontinuous F\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : (a : X) → Y} (hf : SeqContinuous f), Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : Nonempty α] [inst_4 : TopologicalSpace β] {f : (a : β) → α} {K : Set β} (hK : IsCompact K)\\n  (hf : ContinuousOn f K), BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {X : Type u_2} {α : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace α]\\n  {F : (a : ι) → (a : X) → α} (h : Equicontinuous F) (i : ι), Continuous (F i)\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous (Equiv.toFun (UniformEquiv.toEquiv self))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : (a : α) → β} [inst_1 : TopologicalSpace α]\\n  (L :\\n    ∀ (x : α) (u : Set (β × β)) (a : u ∈ uniformity β),\\n      ∃ (t : Set α),\\n        (t ∈ nhds x : Prop) ∧\\n          (∃ (F : (a : α) → β), (ContinuousAt F x : Prop) ∧ (∀ (y : α) (a : y ∈ t), (f y, F y) ∈ u : Prop) : Prop)),\\n  Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : (a : ι) → (a : α) → β} {f : (a : α) → β}\\n  {p : Filter ι} [inst_1 : TopologicalSpace α] (h : TendstoLocallyUniformly F f p)\\n  (hc : Filter.Eventually (fun (n : ι) ↦ Continuous (F n)) p) [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : (a : α) → β} [inst_1 : TopologicalSpace α]\\n  (L :\\n    ∀ (u : Set (β × β)) (a : u ∈ uniformity β),\\n      ∃ (F : (a : α) → β), (Continuous F : Prop) ∧ (∀ (y : α), (f y, F y) ∈ u : Prop)),\\n  Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : (a : ι) → (a : α) → β} {f : (a : α) → β}\\n  {p : Filter ι} [inst_1 : TopologicalSpace α] (h : TendstoUniformly F f p)\\n  (hc : Filter.Eventually (fun (n : ι) ↦ Continuous (F n)) p) [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\\n  {F : (a : ι) → (a : β) → α} (h : UniformEquicontinuous F) (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"Every continuous function is uniformly continuous.\"}]"}
{"text":"Every uniformly continuous function is bounded above.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : (a : α) → β} [inst_1 : TopologicalSpace α]\\n  (L :\\n    ∀ (x : α) (u : Set (β × β)) (a : u ∈ uniformity β),\\n      ∃ (t : Set α),\\n        (t ∈ nhds x : Prop) ∧\\n          (∃ (F : (a : α) → β), (ContinuousAt F x : Prop) ∧ (∀ (y : α) (a : y ∈ t), (f y, F y) ∈ u : Prop) : Prop)),\\n  Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a totally bounded set under a uniformly continuous map is totally bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : (a : α) → β} {s : Set α}\\n  (hs : TotallyBounded s) (hf : UniformContinuous f), TotallyBounded (f '' s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : (a : α) → β} [inst_1 : TopologicalSpace α]\\n  (L :\\n    ∀ (u : Set (β × β)) (a : u ∈ uniformity β),\\n      ∃ (F : (a : α) → β), (Continuous F : Prop) ∧ (∀ (y : α), (f y, F y) ∈ u : Prop)),\\n  Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite union of sets which are all bounded above is still bounded above.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : SemilatticeSup α] [inst_1 : Nonempty α] {I : Set β} {S : (a : β) → Set α}\\n  (H : Set.Finite I),\\n  (BddAbove (Set.unionᵢ fun (i : β) ↦ Set.unionᵢ fun (h : i ∈ I) ↦ S i) : Prop) ↔\\n    (∀ (i : β) (a : i ∈ I), BddAbove (S i) : Prop)\"},\n {\"role\": \"user\", \"content\": \"A continuous, periodic function is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {f : (a : ℝ) → α} {c : ℝ} (hp : Function.Periodic f c) (hc : c ≠ 0)\\n  (hf : Continuous f), Metric.Bounded (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\\n  {F : (a : ι) → (a : β) → α} (h : UniformEquicontinuous F) (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function with compact support is bounded below. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : Nonempty α] [inst_4 : TopologicalSpace β] [inst_5 : Zero α] {f : (a : β) → α} (hf : Continuous f)\\n  (h : HasCompactSupport f), BddBelow (Set.range f)\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded above.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : SemilatticeSup α] [inst_1 : Nonempty α] {s : Set α} (hs : Set.Finite s), BddAbove s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The indexed supremum of a function is bounded above by a uniform bound\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {ι : Sort u_1} [inst : ConditionallyCompleteLattice α] [inst_1 : Nonempty ι] {f : (a : ι) → α} {c : α}\\n  (H : ∀ (x : ι), f x ≤ c), supᵢ f ≤ c\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : (a : ι) → (a : α) → β} {f : (a : α) → β}\\n  {p : Filter ι} [inst_1 : TopologicalSpace α] (h : TendstoLocallyUniformly F f p)\\n  (hc : Filter.Eventually (fun (n : ι) ↦ Continuous (F n)) p) [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded below on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : Nonempty α] [inst_4 : TopologicalSpace β] {f : (a : β) → α} {K : Set β} (hK : IsCompact K)\\n  (hf : ContinuousOn f K), BddBelow (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : (a : ι) → (a : α) → β} {f : (a : α) → β}\\n  {p : Filter ι} [inst_1 : TopologicalSpace α] (h : TendstoUniformly F f p)\\n  (hc : Filter.Eventually (fun (n : ι) ↦ Continuous (F n)) p) [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function with compact support is bounded above. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : Nonempty α] [inst_4 : TopologicalSpace β] [inst_5 : Zero α] {f : (a : β) → α} (hf : Continuous f)\\n  (h : HasCompactSupport f), BddAbove (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : Nonempty α] [inst_4 : TopologicalSpace β] {f : (a : β) → α} {K : Set β} (hK : IsCompact K)\\n  (hf : ContinuousOn f K), BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"Every uniformly continuous function is bounded above.\"}]"}
{"text":"If every compact subset of a topological space is closed, then the space is compact.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α),\\n  ∃ (K : Set α), (IsCompact K : Prop) ∧ (K ∈ nhds x : Prop)\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (Alexandroff X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  (Dense ↑s : Prop) ↔ (Submodule.topologicalClosure s = ⊤ : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {t : Set α} (hs : IsCompact s) (ht : IsClosed t),\\n  IsCompact (s ∩ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {t : Set α} (ht : IsCompact t) (hs : IsClosed s),\\n  IsCompact (s ∩ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α}\\n  (hK : IsCompact K), ∃ (V : Set α), (IsOpen V : Prop) ∧ ((K ⊆ V : Prop) ∧ (IsCompact (closure V) : Prop) : Prop)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α} (hs : IsCompact s), IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α} (hK : IsCompact K),\\n  ∃ (K' : Set α), (IsCompact K' : Prop) ∧ (K ⊆ interior K' : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {t : Set α} (hs : IsCompact s) (ht : IsClosed t) (h : t ⊆ s),\\n  IsCompact t\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (self : CompHaus), CompactSpace (CategoryTheory.Bundled.α (CompHaus.toTop self))\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every compact subset of a topological space is closed, then the space is compact.\"}]"}
{"text":"In a commutative ring, the sum of idempotent elements is idempotent.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a semigroup, the product of right-regular elements is right-regular. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Semigroup R] {a : R} {b : R} (rra : IsRightRegular a) (rrb : IsRightRegular b),\\n  IsRightRegular (a * b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Scalar multiplication commutes with the inclusion of each component into the direct sum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : (a : ι) → Type w}\\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (i : ι) (c : R) (x : M i),\\n  ↑(DirectSum.of M i) (c • x) = c • ↑(DirectSum.of M i) x\"},\n {\"role\": \"user\",\n  \"content\": \"Addition is commutative in an additive commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u} [self : AddCancelCommMonoid M] (a : M) (b : M), a + b = b + a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The sum of two elements of an additive subsemigroup belongs to the subsemigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R) {a : R} {b : R}\\n  (a_1 : a ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (Subsemiring.toSubmonoid self)))\\n  (a_2 : b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (Subsemiring.toSubmonoid self))),\\n  a + b ∈ Subsemigroup.carrier (Submonoid.toSubsemigroup (Subsemiring.toSubmonoid self))\"},\n {\"role\": \"user\",\n  \"content\": \"the condition that the given endomorphism is an idempotent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u_1} [inst : CategoryTheory.Category C] (self : CategoryTheory.Idempotents.Karoubi C),\\n  CategoryTheory.Idempotents.Karoubi.p self ≫ CategoryTheory.Idempotents.Karoubi.p self =\\n    CategoryTheory.Idempotents.Karoubi.p self\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\": \"Scalar multiplication commutes with direct sums. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : (a : ι) → Type w}\\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (s : Finset ι) (c : R)\\n  (x : (i : ↑↑s) → M ↑i), ↑(DirectSum.mk M s) (c • x) = c • ↑(DirectSum.mk M s) x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a : R) (b : R), ↑f (a + b) = ↑f a + ↑f b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Moving to the opposite additive commutative monoid commutes with summing. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {β : Type u} {α : Type v} [inst : AddCommMonoid β] {s : Finset α} (f : (a : α) → β),\\n  { unop := Finset.sum s fun (x : α) ↦ f x } = Finset.sum s fun (x : α) ↦ { unop := f x }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (I : Ideal R) (h : Ideal.Fg I),\\n  (IsIdempotentElem I : Prop) ↔ (∃ (e : R), (IsIdempotentElem e : Prop) ∧ (I = Submodule.span R {e} : Prop) : Prop)\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S) (x : R)\\n  (y : R), ↑e (x * y) = ↑e x * ↑e y\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : StrictOrderedCommRing α] (a : α) (b : α), a * b = b * a\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves addition. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S) (x : R)\\n  (y : R), ↑e (x + y) = ↑e x + ↑e y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a commutative ring, the sum of idempotent elements is idempotent.\"}]"}
{"text":"The number of partitions of a finite set is a prime number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Finite product of finite sets is finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {δ : Type u_1} [inst : Finite δ] {κ : (a : δ) → Type u_2} {t : (d : δ) → Set (κ d)}\\n  (ht : ∀ (d : δ), Set.Finite (t d)), Set.Finite (Set.pi Set.univ t)\"},\n {\"role\": \"user\",\n  \"content\": \"A finpartition gives rise to a setoid partition \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} (f : Finpartition Set.univ), Setoid.IsPartition ↑(Finpartition.parts f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ), (Nat.factorization n = 0 : Prop) ↔ ((n = 0 : Prop) ∨ (n = 1 : Prop) : Prop)\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded above.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : SemilatticeSup α] [inst_1 : Nonempty α] {s : Set α} (hs : Set.Finite s), BddAbove s\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], (Nat.Prime q : Prop) ∨ (q = 1 : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Factoring a prime gives the corresponding one-element multiset. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (p : Nat.Primes), PNat.factorMultiset ↑p = PrimeMultiset.ofPrime p\"},\n {\"role\": \"user\", \"content\": \"The partition is supremum-independent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Lattice α] [inst_1 : OrderBot α] {a : α} (self : Finpartition a),\\n  Finset.SupIndep (Finpartition.parts self) id\"},\n {\"role\": \"user\",\n  \"content\": \"The set of finite subsets of a countable set is countable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {s : Set α} (hs : Set.Countable s),\\n  Set.Countable (setOf fun (t : Set α) ↦ (Set.Finite t : Prop) ∧ (t ⊆ s : Prop))\"},\n {\"role\": \"user\", \"content\": \"A product of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : (a : ι) → WithTop R}\\n  (h : ∀ (i : ι) (a : i ∈ s), f i ≠ ⊤), (Finset.prod s fun (i : ι) ↦ f i) < ⊤\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} (h : Set.Finite s), Metric.Bounded s\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} (f : (a : α) → Finset β) (h : Set.Finite (Set.range f)),\\n  Set.Finite (Set.unionᵢ fun (a : α) ↦ ↑(f a))\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p : Prop)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a : Associates α}\\n  {p : Associates α} (hp : Irreducible p) [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n : Prop)] {n : ℕ} (h : a ∣ p ^ n),\\n  a = p ^ Nat.find ((Exists.intro n h=:∃ (n : ℕ), (fun (n : ℕ) ↦ a ∣ p ^ n) n)=:∃ (n : ℕ), (fun (n : ℕ) ↦ a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\": \"There are finitely many subsets of a given finite set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {a : Set α} (h : Set.Finite a), Set.Finite (setOf fun (b : Set α) ↦ b ⊆ a)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\",\n  \"content\": \"Set.InjOn Nat.factorization (setOf fun (x : ℕ) ↦ x ≠ 0)\"},\n {\"role\": \"user\",\n  \"content\": \"The number of partitions of a finite set is a prime number.\"}]"}
{"text":"If a poset has a maximal element, then it has a unique minimal element.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A word and its maximal reduction correspond to the same element of the additive free\\ngroup.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {L : List (α × Bool)} [inst : DecidableEq α], FreeAddGroup.mk (FreeAddGroup.reduce L) = FreeAddGroup.mk L\"},\n {\"role\": \"user\",\n  \"content\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R] (hR : IsField R) (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R)\\n  (hx : ↑Polynomial.C x ∈ I), x = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α) (a : α) (a_1 : a ∈ s), infₛ s ≤ a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀] (h : 0 = 1) (a : M₀), a = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x : α} {y : α} (a : x * y ∈ I),\\n  (x ∈ I : Prop) ∨ (y ∈ I : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a word reduces to another word, then they have a common maximal reduction. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {L₁ : List (α × Bool)} {L₂ : List (α × Bool)} [inst : DecidableEq α] (H : FreeGroup.Red L₁ L₂),\\n  FreeGroup.reduce L₁ = FreeGroup.reduce L₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a word reduces to another word, then they have a common maximal reduction.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {L₁ : List (α × Bool)} {L₂ : List (α × Bool)} [inst : DecidableEq α] (H : FreeAddGroup.Red L₁ L₂),\\n  FreeAddGroup.reduce L₁ = FreeAddGroup.reduce L₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {r : (a : α) → (a : α) → Prop}\\n  (h : ∀ (c : Set α) (a : IsChain r c), ∃ (ub : α), ∀ (a : α) (a_1 : a ∈ c), r a ub)\\n  (trans : ∀ {a : α} {b : α} {c : α} (a_1 : r a b) (a_2 : r b c), r a c), ∃ (m : α), ∀ (a : α) (a_1 : r m a), r a m\"},\n {\"role\": \"user\",\n  \"content\": \"A least element of a set is the infimum of this set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α} (H : IsLeast s a), infₛ s = a\"},\n {\"role\": \"user\",\n  \"content\": \"A greatest element of a set is the supremum of this set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α} (H : IsGreatest s a), supₛ s = a\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is less than the set supremum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteLattice α] (s : Set α) (a : α) (a_1 : a ∈ s), a ≤ supₛ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A word and its maximal reduction correspond to the same element of the free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {L : List (α × Bool)} [inst : DecidableEq α], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a poset has a maximal element, then it has a unique minimal element.\"}]"}
{"text":"The automorphism group of an Abelian group is cyclic.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The right regular action of a group on itself is transitive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], MulAction.IsPretransitive Gᵐᵒᵖ G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An additive group homomorphism is an additive monoid homomorphism.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : (a : α) → β} (hf : IsAddGroupHom f),\\n  IsAddMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\": \"The regular action of a group on itself is transitive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive G G\"},\n {\"role\": \"user\",\n  \"content\": \"The regular action of a group on itself is transitive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], MulAction.IsPretransitive G G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], (Group.Fg G : Prop) ↔ (Monoid.Fg G : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : (a : α) → β} (hf : IsGroupHom f) {γ : Type u_1}\\n  [inst_2 : Group γ] {g : (a : β) → γ} (hg : IsGroupHom g), IsGroupHom (g ∘ f)\"},\n {\"role\": \"user\", \"content\": \"An abelian category has finite biproducts. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α) (a_1 : a ≠ 0), a * a⁻¹ = 1\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : (a : α) → β} (hf : IsGroupHom f), IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\": \"The action of an additive group on an orbit is transitive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddAction α β] (x : β),\\n  AddAction.IsPretransitive α ↑(AddAction.orbit α x)\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a group acts commutatively on that group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x : G // x ∈ Subgroup.center G } G\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f : (a : α) → β} {g : (a : α) → β}\\n  (hf : IsGroupHom f) (hg : IsGroupHom g), IsGroupHom fun (a : α) ↦ f a * g a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The right regular action of an additive group on itself is transitive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive Gᵃᵒᵖ G\"},\n {\"role\": \"user\", \"content\": \"Every subgroup of `ℤ` is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (H : AddSubgroup ℤ), ∃ (a : ℤ), H = AddSubgroup.closure {a}\"},\n {\"role\": \"user\",\n  \"content\": \"The automorphism group of an Abelian group is cyclic.\"}]"}
{"text":"If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function is locally Lipschitz around a point, then it is continuous at this point. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : (a : α) → β} {x : α}\\n  {r : ℝ} (hr : 0 < r) (K : ℝ) (h : ∀ (y : α) (a : dist y x < r), dist (f y) (f x) ≤ K * dist y x), ContinuousAt f x\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : Nonempty α] [inst_4 : TopologicalSpace β] {f : (a : β) → α} {K : Set β} (hK : IsCompact K)\\n  (hf : ContinuousOn f K), BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : (a : ι) → (a : α) → β} {f : (a : α) → β}\\n  {p : Filter ι} [inst_1 : TopologicalSpace α] (h : TendstoUniformly F f p)\\n  (hc : Filter.Eventually (fun (n : ι) ↦ Continuous (F n)) p) [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\", \"content\": \"A continuous, periodic function is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {f : (a : ℝ) → α} {c : ℝ} (hp : Function.Periodic f c) (hc : c ≠ 0)\\n  (hf : Continuous f), Metric.Bounded (Set.range f)\"},\n {\"role\": \"user\", \"content\": \"For the identity map, all points are periodic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} (n : ℕ) (x : α), Function.IsPeriodicPt id n x\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous, periodic function has compact range. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {f : (a : ℝ) → α} {c : ℝ} (hp : Function.Periodic f c) (hc : c ≠ 0)\\n  (hf : Continuous f), IsCompact (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : (a : α) → α} (hf : Continuous f),\\n  IsClosed (Function.fixedPoints f)\"},\n {\"role\": \"user\", \"content\": \"Any point is a periodic point of period `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} (f : (a : α) → α) (x : α), Function.IsPeriodicPt f 0 x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {f : (a : α) → α} {x : α} (hf : Function.IsFixedPt f x) (n : ℕ), Function.IsPeriodicPt f n x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.\"}]"}
{"text":"The complement of the union of two sets contains the union of their complements.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded above if and only if each of the sets is.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {γ : Type w} [inst : SemilatticeInf γ] {s : Set γ} {t : Set γ},\\n  (BddBelow (s ∪ t) : Prop) ↔ ((BddBelow s : Prop) ∧ (BddBelow t : Prop) : Prop)\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} (f : (a : α) → Finset β) (h : Set.Finite (Set.range f)),\\n  Set.Finite (Set.unionᵢ fun (a : α) ↦ ↑(f a))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z : Set α} {a : Set α} {b : Set α} (h : IsClopen Z) (cover : Z ⊆ a ∪ b)\\n  (ha : IsOpen a) (hb : IsOpen b) (hab : Disjoint a b), IsClopen (Z ∩ a)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of all sets in a compact exhaustion equals the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\\n  (Set.unionᵢ fun (n : ℕ) ↦ CompactExhaustion.toFun self n) = Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K : Set α} {U : Set α} {V : Set α} (hK : IsCompact K)\\n  (hU : IsOpen U) (hV : IsOpen V) (h2K : K ⊆ U ∪ V),\\n  ∃ (K₁ : Set α),\\n    ∃ (K₂ : Set α),\\n      (IsCompact K₁ : Prop) ∧\\n        ((IsCompact K₂ : Prop) ∧ ((K₁ ⊆ U : Prop) ∧ ((K₂ ⊆ V : Prop) ∧ (K = K₁ ∪ K₂ : Prop) : Prop) : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {t : Set α} (hs : IsCompact s) (ht : IsClosed t),\\n  IsCompact (s ∩ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {γ : Type w} [inst : SemilatticeSup γ] {s : Set γ} {t : Set γ},\\n  (BddAbove (s ∪ t) : Prop) ↔ ((BddAbove s : Prop) ∧ (BddAbove t : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"The span of a union of sets is the sup of their spans. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s : Set P) (t : Set P), affineSpan k (s ∪ t) = affineSpan k s ⊔ affineSpan k t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} (S : Set α) (T : Set α), Cardinal.mk ↑(S ∪ T) ≤ Cardinal.mk ↑S + Cardinal.mk ↑T\"},\n {\"role\": \"user\",\n  \"content\": \"The disjoint union of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {t : Set α},\\n  (Metric.Bounded (s ∪ t) : Prop) ↔ ((Metric.Bounded s : Prop) ∧ (Metric.Bounded t : Prop) : Prop)\"},\n {\"role\": \"user\", \"content\": \"The union of two bounded sets is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {t : Set α} (hs : Metric.Bounded s) (ht : Metric.Bounded t),\\n  Metric.Bounded (s ∪ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), frontier (sᶜ) = frontier s\"},\n {\"role\": \"user\", \"content\": \"The complement of a closed set is an open set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen (sᶜ)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of the union of two sets contains the union of their complements.\"}]"}
{"text":"The square root of an rational number is rational.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A fraction is equal to its expansion by an factor from s. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R)\\n  (s : { x : R // x ∈ S }) (s' : { x : R // x ∈ S }), r /ₒ s = r * ↑s' /ₒ (s * s')\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S)\"},\n {\"role\": \"user\", \"content\": \"Roots of a quadratic equation. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a : K} {b : K} {c : K} (ha : a ≠ 0) {s : K}\\n  (h : discrim a b c = s * s) (x : K),\\n  (a * x * x + b * x + c = 0 : Prop) ↔ ((x = (-b + s) / (2 * a) : Prop) ∨ (x = (-b - s) / (2 * a) : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A fraction `r /ₒ s` is equal to its expansion by an arbitrary factor `t` if `s * t ∈ S`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R)\\n  (s : { x : R // x ∈ S }) (t : R) (hst : ↑s * t ∈ S), r /ₒ s = r * t /ₒ { val := ↑s * t, property := hst }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `p`-adic value of an integer `z ≠ 0` is its `p`-adic value as a rational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} {n : ℕ}, padicValRat p ↑n = ↑(padicValNat p n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quadratic has roots if and only if its discriminant equals some square.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {a : R} {b : R} {c : R} [inst_1 : NeZero 2] [inst_2 : NoZeroDivisors R]\\n  (ha : a ≠ 0) (x : R), (a * x * x + b * x + c = 0 : Prop) ↔ (discrim a b c = (2 * a * x + b) ^ 2 : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {a : R} {b : R} {c : R} (h : ∀ (s : R), discrim a b c ≠ s ^ 2) (x : R),\\n  a * x * x + b * x + c ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"An ideal is radical iff it is equal to its radical. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, (Ideal.radical I = I : Prop) ↔ (Ideal.IsRadical I : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap g (Ideal.comap f' I) :=\\n    ((le_of_eq\\n          ((_root_.trans\\n                ((Ideal.comap_comap f\\n                      g'=:Ideal.comap f (Ideal.comap g' I) =\\n                      Ideal.comap (RingHom.comp g' f)\\n                        I)=:Ideal.comap f (Ideal.comap g' I) = Ideal.comap (RingHom.comp g' f) I)\\n                ((Eq.rec\\n                      ((Ideal.comap_comap g\\n                            f'=:Ideal.comap g (Ideal.comap f' I) =\\n                            Ideal.comap (RingHom.comp f' g)\\n                              I)=:Ideal.comap g (Ideal.comap f' I) = Ideal.comap (RingHom.comp f' g) I)\\n                      hfg=:Ideal.comap (RingHom.comp g' f) I =\\n                      Ideal.comap g\\n                        (Ideal.comap f'\\n                          I))=:Ideal.comap (RingHom.comp g' f) I =\\n                    Ideal.comap g\\n                      (Ideal.comap f'\\n                        I))=:Ideal.comap f (Ideal.comap g' I) =\\n                Ideal.comap g\\n                  (Ideal.comap f'\\n                    I))=:Ideal.comap f (Ideal.comap g' I) =\\n              Ideal.comap g\\n                (Ideal.comap f'\\n                  I))=:Ideal.comap f (Ideal.comap g' I) ≤\\n          Ideal.comap g (Ideal.comap f' I))=:Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap g (Ideal.comap f' I));\\n  (RingHom.comp\\n        (Ideal.quotientMap I g' ((le_rfl=:Ideal.comap g' I ≤ Ideal.comap g' I)=:Ideal.comap g' I ≤ Ideal.comap g' I))\\n        (Ideal.quotientMap (Ideal.comap g' I) f\\n          ((le_rfl=:Ideal.comap f (Ideal.comap g' I) ≤\\n                Ideal.comap f\\n                  (Ideal.comap g' I))=:Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap f (Ideal.comap g' I))) =\\n      RingHom.comp\\n        (Ideal.quotientMap I f' ((le_rfl=:Ideal.comap f' I ≤ Ideal.comap f' I)=:Ideal.comap f' I ≤ Ideal.comap f' I))\\n        (Ideal.quotientMap (Ideal.comap f' I) g leq) :\\n    Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (self : ℚ), Nat.coprime (Int.natAbs (Rat.num self)) (Rat.den self)\"},\n {\"role\": \"user\",\n  \"content\": \"A quadratic has roots if its discriminant has square roots \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a : K} {b : K} {c : K} (ha : a ≠ 0)\\n  (h : ∃ (s : K), discrim a b c = s * s), ∃ (x : K), a * x * x + b * x + c = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜]\\n  [inst_3 : Archimedean 𝕜], DenseRange Rat.cast\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\"},\n {\"role\": \"user\",\n  \"content\": \"The square root of an rational number is rational.\"}]"}
{"text":"If a module over a ring is free, then the ring is commutative.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The module of finite matrices is free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : Module.Free R M] {m : Type u_1} {n : Type u_2} [inst_4 : Finite m] [inst_5 : Finite n],\\n  Module.Free R (Matrix m n M)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The rank of a finite product of free modules is the sum of the ranks. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {η : Type u₁'} {φ : (a : η) → Type u_1} [inst : Ring K] [inst_1 : StrongRankCondition K]\\n  [inst_2 : (i : η) → AddCommGroup (φ i)] [inst_3 : (i : η) → Module K (φ i)] [inst_4 : ∀ (i : η), Module.Free K (φ i)]\\n  [inst_5 : Finite η], Module.rank K ((i : η) → φ i) = Cardinal.sum fun (i : η) ↦ Module.rank K (φ i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M) (s : Function.Surjective ↑f), Function.Bijective ↑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M) (s : Function.Surjective ↑f), Function.Injective ↑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A module over a semiring is `Finite` if it is finitely generated as a module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [self : Module.Finite R M], Submodule.Fg ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two finite and free modules are isomorphic if and only if they have the same (finite) rank. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\\n  (Nonempty (M ≃ₗ[R] N) : Prop) ↔ (FiniteDimensional.finrank R M = FiniteDimensional.finrank R N : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two finite and free modules are isomorphic if they have the same (finite) rank. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N]\\n  (cond : FiniteDimensional.finrank R M = FiniteDimensional.finrank R N), Nonempty (M ≃ₗ[R] N)\"},\n {\"role\": \"user\", \"content\": \"Modules over the trivial ring are Noetherian. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\\n  [inst_2 : Module R M], IsNoetherian R M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The lattice of submodules of a module over a division ring is atomistic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsAtomistic (Submodule K V)\"},\n {\"role\": \"user\",\n  \"content\": \"The product of finitely many free modules is free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} (R : Type u) [inst : Semiring R] (M : (a : ι) → Type u_2) [inst_1 : Finite ι]\\n  [inst_2 : (i : ι) → AddCommMonoid (M i)] [inst_3 : (i : ι) → Module R (M i)]\\n  [inst_4 : ∀ (i : ι), Module.Free R (M i)], Module.Free R ((i : ι) → M i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  (IsNoetherian K V : Prop) ↔ (Module.Finite K V : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"If a module over a ring is free, then the ring is commutative.\"}]"}
{"text":"If the set of units of a ring forms a group then the ring is commutative.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], (Group.Fg G : Prop) ↔ (Monoid.Fg G : Prop)\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\", \"content\": \"Multiplication is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : SeminormedCommRing α] (x : α) (y : α), x * y = y * x\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S) (x : R)\\n  (y : R), ↑e (x * y) = ↑e x * ↑e y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} {x : G} {y : G} [inst : Monoid G] (h : Commute x y) (hx : IsOfFinOrder x) (hy : IsOfFinOrder y),\\n  IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (H : ∀ (P : Ideal R) (a : Ideal.IsPrime P), Submodule.IsPrincipal P),\\n  IsPrincipalIdealRing R\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : (a : α) → β} (hf : IsGroupHom f), IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\": \"Composition of non-unital ring homomorphisms is associative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} [inst : NonUnitalNonAssocSemiring α]\\n  [inst_1 : NonUnitalNonAssocSemiring β] [inst_2 : NonUnitalNonAssocSemiring γ] {δ : Type u_1}\\n  {x : NonUnitalNonAssocSemiring δ} (f : α →ₙ+* β) (g : β →ₙ+* γ) (h : γ →ₙ+* δ),\\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R] (self : IsField R) (x : R) (y : R), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f : (a : α) → β} (hf : IsGroupHom f),\\n  IsGroupHom fun (a : α) ↦ (f a)⁻¹\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : StrictOrderedCommRing α] (a : α) (b : α), a * b = b * a\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x : M // x ∈ Submonoid.center M } M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f : (a : α) → β} {g : (a : α) → β}\\n  (hf : IsGroupHom f) (hg : IsGroupHom g), IsGroupHom fun (a : α) ↦ f a * g a\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a group acts commutatively on that group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x : G // x ∈ Subgroup.center G } G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the set of units of a ring forms a group then the ring is commutative.\"}]"}
{"text":"Every natural number larger than `10` is the sum of a square and a prime.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x : α} {y : α} (a : x * y ∈ I),\\n  (x ∈ I : Prop) ∨ (y ∈ I : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} (h : n ≠ 0) (d : ℕ), Filter.Frequently (fun (m : ℕ) ↦ m ≡ d [MOD n]) Filter.atTop\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℕ} {b : ℕ} (w : a ∣ b) (h : b < a), b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {m : ℕ} {n : ℕ}, (∀ (a : ℕ), (a ∣ m : Prop) ↔ (a ∣ n : Prop) : Prop) ↔ (m = n : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {m : ℕ} {n : ℕ}, (∀ (a : ℕ), (m ∣ a : Prop) ↔ (n ∣ a : Prop) : Prop) ↔ (m = n : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ), (Nat.factorization n = 0 : Prop) ↔ ((n = 0 : Prop) ∨ (n = 1 : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p : Prop)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a : Associates α}\\n  {p : Associates α} (hp : Irreducible p) [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n : Prop)] {n : ℕ} (h : a ∣ p ^ n),\\n  a = p ^ Nat.find ((Exists.intro n h=:∃ (n : ℕ), (fun (n : ℕ) ↦ a ∣ p ^ n) n)=:∃ (n : ℕ), (fun (n : ℕ) ↦ a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], (Nat.Prime q : Prop) ∨ (q = 1 : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} (w : 0 < n) (h : ¬(Nat.Prime n : Prop)), Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\",\n  \"content\": \"Set.InjOn Nat.factorization (setOf fun (x : ℕ) ↦ x ≠ 0)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every natural number larger than `10` is the sum of a square and a prime.\"}]"}
{"text":"The initial object of a category is isomorphic to its terminal object.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The map from the (any as stated) initial object to any other object is a\\nmonomorphism \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.InitialMonoClass C] {I : C} (X : C)\\n  (hI : CategoryTheory.Limits.IsInitial I), CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any category with pushouts and initial object has binary coproducts. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasBinaryCoproducts C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A category in which coimage-image comparisons are all isomorphisms has images. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : ∀ {X : C} {Y : C} (f : X ⟶ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\\n  CategoryTheory.Limits.HasImages C\"},\n {\"role\": \"user\",\n  \"content\": \"A category with finite biproducts has a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\", \"content\": \"Any morphism to an initial object is epi. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X : C} {Y : C} (t : CategoryTheory.Limits.IsInitial X) (f : Y ⟶ X),\\n  CategoryTheory.Epi f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a connected category, any two objects are related by `zigzag`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J] (j₁ : J) (j₂ : J),\\n  CategoryTheory.Zigzag j₁ j₂\"},\n {\"role\": \"user\",\n  \"content\": \"Any two morphisms from an initial object are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X : C} {Y : C} (t : CategoryTheory.Limits.IsInitial X) (f : X ⟶ Y)\\n  (g : X ⟶ Y), f = g\"},\n {\"role\": \"user\", \"content\": \"Any morphism from a terminal object is mono. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X : C} {Y : C} (t : CategoryTheory.Limits.IsTerminal X) (f : X ⟶ Y),\\n  CategoryTheory.Mono f\"},\n {\"role\": \"user\", \"content\": \"The category `D` has isomorphic objects equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {F : D ⥤ C}\\n  (self : CategoryTheory.IsSkeletonOf C D F), CategoryTheory.Skeletal D\"},\n {\"role\": \"user\",\n  \"content\": \"Any two morphisms to a terminal object are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X : C} {Y : C} (t : CategoryTheory.Limits.IsTerminal X) (f : Y ⟶ X)\\n  (g : Y ⟶ X), f = g\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The initial object of a category is isomorphic to its terminal object.\"}]"}
{"text":"If the composition of two functions is continuous, then each of them is continuous.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A continuous, periodic function is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {f : (a : ℝ) → α} {c : ℝ} (hp : Function.Periodic f c) (hc : c ≠ 0)\\n  (hf : Continuous f), Metric.Bounded (Set.range f)\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous (Equiv.toFun (UniformEquiv.toEquiv self))\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded below on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : Nonempty α] [inst_4 : TopologicalSpace β] {f : (a : β) → α} {K : Set β} (hK : IsCompact K)\\n  (hf : ContinuousOn f K), BddBelow (f '' K)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : (a : X) → Y} (hf : SeqContinuous f), Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : Nonempty α] [inst_4 : TopologicalSpace β] {f : (a : β) → α} {K : Set β} (hK : IsCompact K)\\n  (hf : ContinuousOn f K), BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : (a : ι) → (a : α) → β} {f : (a : α) → β}\\n  {p : Filter ι} [inst_1 : TopologicalSpace α] (h : TendstoLocallyUniformly F f p)\\n  (hc : Filter.Eventually (fun (n : ι) ↦ Continuous (F n)) p) [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : (a : α) → β} [inst_1 : TopologicalSpace α]\\n  (L :\\n    ∀ (x : α) (u : Set (β × β)) (a : u ∈ uniformity β),\\n      ∃ (t : Set α),\\n        (t ∈ nhds x : Prop) ∧\\n          (∃ (F : (a : α) → β), (ContinuousAt F x : Prop) ∧ (∀ (y : α) (a : y ∈ t), (f y, F y) ∈ u : Prop) : Prop)),\\n  Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\\n  {F : (a : ι) → (a : β) → α} (h : UniformEquicontinuous F) (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : (a : α) → β} [inst_1 : TopologicalSpace α]\\n  (L :\\n    ∀ (u : Set (β × β)) (a : u ∈ uniformity β),\\n      ∃ (F : (a : α) → β), (Continuous F : Prop) ∧ (∀ (y : α), (f y, F y) ∈ u : Prop)),\\n  Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {X : Type u_2} {α : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace α]\\n  {F : (a : ι) → (a : X) → α} (h : Equicontinuous F) (i : ι), Continuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : (a : ι) → (a : α) → β} {f : (a : α) → β}\\n  {p : Filter ι} [inst_1 : TopologicalSpace α] (h : TendstoUniformly F f p)\\n  (hc : Filter.Eventually (fun (n : ι) ↦ Continuous (F n)) p) [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β}\\n  (hs : Dense s) {f : (a : β) → α} {g : (a : β) → α} (hf : Continuous f) (hg : Continuous g) (h : Set.EqOn f g s), f = g\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the composition of two functions is continuous, then each of them is continuous.\"}]"}
{"text":"If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Equality behind `Commute a b`; useful for rewriting. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a : S} {b : S} (h : Commute a b), a * b = b * a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`X` commutes with everything, even when the coefficients are noncommutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X\"},\n {\"role\": \"user\", \"content\": \"If `a % b = c` then `b` divides `a - c`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℤ} {b : ℤ} {c : ℤ} (h : a % b = c), b ∣ a - c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Transitivity for `BEq`. If `a == b` and `b == c` then `a == c`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : BEq α] [self : PartialEquivBEq α] {a : α} {b : α} {c : α} (a_1 : (a == b) = true)\\n  (a_2 : (b == c) = true), (a == c) = true\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {r : (a : α) → (a : α) → Prop} [self : IsDirected α r] (a : α) (b : α),\\n  ∃ (c : α), (r a c : Prop) ∧ (r b c : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"If `c • a < c • b` for some positive `c`, then `a < b`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\\n  [self : OrderedSMul R M] {a : M} {b : M} {c : R} (a_1 : c • a < c • b) (a_2 : 0 < c), a < b\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a : S} {b : S} {c : S} (hac : AddCommute a c) (hbc : AddCommute b c),\\n  AddCommute (a + b) c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a : S} {b : S} {c : S} (hac : Commute a c) (hbc : Commute b c), Commute (a * b) c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a : S} {b : S} {c : S} (hab : AddCommute a b) (hac : AddCommute a c),\\n  AddCommute a (b + c)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a : S} {b : S} {c : S} (hab : Commute a b) (hac : Commute a c), Commute a (b * c)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a : S} {b : S} (h : Commute a b), Commute b a\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : Add S] {a : S} {b : S} (h : AddCommute a b), AddCommute b a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.\"}]"}
{"text":"If an element maps to zero under a ring homomorphism, then it is zero.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is surjective \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\\n  [self : RingHomSurjective σ], Function.Surjective ↑σ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R →+* S} {g : R →+* S}\\n  {s : Set R} (h : Set.EqOn (↑f) (↑g) s), Set.EqOn ↑f ↑g ↑(Subsemiring.closure s)\"},\n {\"role\": \"user\",\n  \"content\": \"In degree `0`, the null homotopic map `Hσ` is zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  {X : CategoryTheory.SimplicialObject C} (q : ℕ), HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.Hσ q) 0 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f : K →+* L} {g : K →+* L} {s : Set K}\\n  (h : Set.EqOn (↑f) (↑g) s), Set.EqOn ↑f ↑g ↑(Subfield.closure s)\"},\n {\"role\": \"user\", \"content\": \"Ring homomorphisms map one to one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 1 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the algebra map `R →+* A` is injective and `R` has characteristic zero then so does `A`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\\n  (h : Function.Injective ↑(algebraMap R A)) [inst : CharZero R], CharZero A\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, zero equals one if and only if all elements of that semiring\\nare equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], (0 = 1 : Prop) ↔ (Subsingleton M₀ : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {g : R →+* S} {s : Set R}\\n  (h : Set.EqOn (↑f) (↑g) s), Set.EqOn ↑f ↑g ↑(Subring.closure s)\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is an isometry. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Norm R₁] [inst_3 : Norm R₂]\\n  {σ : R₁ →+* R₂} [self : RingHomIsometric σ] {x : R₁}, ‖↑σ x‖ = ‖x‖\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀] (h : 0 = 1) (a : M₀), a = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x : R // x ∈ s }\"},\n {\"role\": \"user\",\n  \"content\": \"An element is in the kernel if and only if it maps to zero.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\\n  {r : R}, (r ∈ RingHom.ker f : Prop) ↔ (↑f r = 0 : Prop)\"},\n {\"role\": \"user\", \"content\": \"An additive group homomorphism sends 0 to 0.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : (a : α) → β} (hf : IsAddGroupHom f), f 0 = 0\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism sends zero to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R ≃+* S), ↑f 0 = 0\"},\n {\"role\": \"user\", \"content\": \"Ring homomorphisms map zero to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 0 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an element maps to zero under a ring homomorphism, then it is zero.\"}]"}
{"text":"Implication `→` is symmetric. If `P → Q` then `Q → P`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"If `f,g` is reflexive, then `g,f` is reflexive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] {A : C} {B : C} {f : A ⟶ B} {g : A ⟶ B}\\n  [inst_1 : CategoryTheory.IsReflexivePair f g], CategoryTheory.IsReflexivePair g f\"},\n {\"role\": \"user\", \"content\": \"Additive congruence relations are symmetric.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : Add M] (c : AddCon M) {x : M} {y : M} (a : ↑c x y), ↑c y x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S : Submodule R M)\\n  (T : Submodule R M) (hST : T ≤ S) [inst_3 : DecidablePred fun (x : M ⧸ T) ↦ x ∈ Submodule.map (Submodule.mkQ T) S]\\n  [inst_4 : Fintype (M ⧸ S)] [inst_5 : Fintype (M ⧸ T)],\\n  Fintype.card { x : M ⧸ T // x ∈ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M ⧸ S) = Fintype.card (M ⧸ T)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The proposition that a Heyting homomorphism preserves the Heyting implication.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} {α : outParam (Type u_2)} {β : outParam (Type u_3)} [inst : HeytingAlgebra α]\\n  [inst_1 : HeytingAlgebra β] [self : HeytingHomClass F α β] (f : F) (a : α) (b : α), ↑f (a ⇨ b) = ↑f a ⇨ ↑f b\"},\n {\"role\": \"user\", \"content\": \"Congruence relations are symmetric. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : Mul M] (c : Con M) {x : M} {y : M} (a : ↑c x y), ↑c y x\"},\n {\"role\": \"user\", \"content\": \"`x ⇨ y` is equal to `y ⊔ xᶜ` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [self : BooleanAlgebra α] (x : α) (y : α), x ⇨ y = y ⊔ xᶜ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An antisymmetric relation `(·≤·)` satisfies `a ≤ b → b ≤ a → a = b`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Sort u} {r : (a : α) → (a : α) → Prop} [self : Antisymm r] {a : α} {b : α} (a_1 : r a b) (a_2 : r b a), a = b\"},\n {\"role\": \"user\", \"content\": \"monotonicity of `≤` with respect to `→` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {a : α} {b : α} {c : α} {d : α} [inst : Preorder α] (hca : c ≤ a) (hbd : b ≤ d) (a : a ≤ b), c ≤ d\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `∀ I > J, P I` implies `P J`, then `P` holds for all submodules. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] {P : (a : Submodule R M) → Prop}\\n  (hgt : ∀ (I : Submodule R M) (a : ∀ (J : Submodule R M) (a : J > I), P J), P I) (I : Submodule R M), P I\"},\n {\"role\": \"user\", \"content\": \"An equivalence relation is reflexive: `x ~ x` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Sort u} {r : (a : α) → (a : α) → Prop} (self : Equivalence r) (x : α), r x x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Sort u} {r : (a : α) → (a : α) → Prop} (self : Equivalence r) {x : α} {y : α} {z : α} (a : r x y) (a : r y z),\\n  r x z\"},\n {\"role\": \"user\",\n  \"content\": \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p : α} {q : α} (hp : Irreducible p) (hq : Irreducible q) (a : p ∣ q), q ∣ p\"},\n {\"role\": \"user\", \"content\": \"`(P ⟶ P⁺)⁺ = P⁺ ⟶ P⁺⁺` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\\n  [inst_1 : CategoryTheory.Category D]\\n  [inst_2 :\\n    ∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\\n  (P : Cᵒᵖ ⥤ D)\\n  [inst_3 : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)ᵒᵖ D],\\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P)\"},\n {\"role\": \"user\",\n  \"content\": \"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Sort u} {r : (a : α) → (a : α) → Prop} (self : Equivalence r) {x : α} {y : α} (a : r x y), r y x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Implication `→` is transitive. If `P → Q` and `Q → R` then `P → R`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : Prop} {q : Prop} {r : Prop} (h₁ : ∀ (a : p), q) (h₂ : ∀ (a : q), r) (a : p), r\"},\n {\"role\": \"user\",\n  \"content\": \"Implication `→` is symmetric. If `P → Q` then `Q → P`.\"}]"}
{"text":"Two natural numbers are equal if and only if they are both divisible by some prime number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an integer with larger absolute value divides an integer, it is\\nzero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a : ℤ} {b : ℤ} (w : a ∣ b) (h : Int.natAbs b < Int.natAbs a), b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ), (Nat.factorization n = 0 : Prop) ↔ ((n = 0 : Prop) ∨ (n = 1 : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (self : ℚ), Nat.coprime (Int.natAbs (Rat.num self)) (Rat.den self)\"},\n {\"role\": \"user\",\n  \"content\": \"Tny common divisor of both elements is a divisor of the GCD. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : GCDMonoid α] {a : α} {b : α} {c : α} (a_1 : a ∣ c)\\n  (a_2 : a ∣ b), a ∣ gcd c b\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} (h : n ≠ 0) (d : ℕ), Filter.Frequently (fun (m : ℕ) ↦ m ≡ d [MOD n]) Filter.atTop\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a : ℕ) (b : ℕ) (ha : a ≠ 0) (hb : b ≠ 0),\\n  (a = b : Prop) ↔ (∀ (p : ℕ) (a_1 : Nat.Prime p), padicValNat p a = padicValNat p b : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a : ℤ} {b : ℤ} {c : ℤ} (h1 : a % b = c) (h2 : Int.natAbs (a - c) < Int.natAbs b), a = c\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p : Prop)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a : Associates α}\\n  {p : Associates α} (hp : Irreducible p) [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n : Prop)] {n : ℕ} (h : a ∣ p ^ n),\\n  a = p ^ Nat.find ((Exists.intro n h=:∃ (n : ℕ), (fun (n : ℕ) ↦ a ∣ p ^ n) n)=:∃ (n : ℕ), (fun (n : ℕ) ↦ a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m : ℕ} {n : ℕ}, (m ∣ n + m : Prop) ↔ (m ∣ n : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\",\n  \"content\": \"Set.InjOn Nat.factorization (setOf fun (x : ℕ) ↦ x ≠ 0)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m : ℕ} {n : ℕ}, (m ∣ m + n : Prop) ↔ (m ∣ n : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℕ} {b : ℕ} (w : a ∣ b) (h : b < a), b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {m : ℕ} {n : ℕ}, (∀ (a : ℕ), (m ∣ a : Prop) ↔ (n ∣ a : Prop) : Prop) ↔ (m = n : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {m : ℕ} {n : ℕ}, (∀ (a : ℕ), (a ∣ m : Prop) ↔ (a ∣ n : Prop) : Prop) ↔ (m = n : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they are both divisible by some prime number.\"}]"}
{"text":"Every ring is a field.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Ring R] (s : Subring R), 0 ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : NonAssocRing R] (p : ℕ) [inst : CharP R p] [inst : Finite R], p ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"Stalks of a locally ringed space are local rings. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (self : AlgebraicGeometry.LocallyRingedSpace) (x : ↑↑self.toPresheafedSpace),\\n  LocalRing ↑(TopCat.Presheaf.stalk self.presheaf x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\", \"content\": \"The category of rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\"},\n {\"role\": \"user\", \"content\": \"Every ring involution must be its own inverse \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (↑f (MulOpposite.unop (↑f x))) = x\"},\n {\"role\": \"user\",\n  \"content\": \"Any infinite type can be endowed a field structure. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Infinite α], Nonempty (Field α)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\"},\n {\"role\": \"user\",\n  \"content\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u_1) [inst : LinearOrderedField α] [inst_1 : FloorRing α], Archimedean α\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K }\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ∈ S\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\", \"content\": \"Every ring is a field.\"}]"}
{"text":"Every vector space is finite dimensional.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The range of a linear map defined on a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V₂ : Type v'}\\n  [inst_3 : AddCommGroup V₂] [inst_4 : Module K V₂] [inst_5 : FiniteDimensional K V] (f : V →ₗ[K] V₂),\\n  FiniteDimensional K { x // x ∈ LinearMap.range f }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P)\\n  [inst_4 : FiniteDimensional k { x // x ∈ AffineSubspace.direction s }] (p : P),\\n  FiniteDimensional k { x // x ∈ vectorSpan k (insert p ↑s) }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\\n  AffineIndependent k f → Set.Finite s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S)\"},\n {\"role\": \"user\",\n  \"content\": \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\"},\n {\"role\": \"user\",\n  \"content\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s → FiniteDimensional k { x // x ∈ vectorSpan k s }\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module 𝕜 E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul 𝕜 F]\\n  [inst_10 : FiniteDimensional 𝕜 E] [inst_11 : FiniteDimensional 𝕜 F], FiniteDimensional 𝕜 (E →L[𝕜] F)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\"},\n {\"role\": \"user\", \"content\": \"All hom spaces are finite dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\", \"content\": \"Every vector space is finite dimensional.\"}]"}
{"text":"Every group is a torsion monoid.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G →+ H},\\n  N = AddMonoidHom.ker f → AddMonoid.IsTorsion H → AddMonoid.IsTorsion { x // x ∈ N } → AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G → Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion submonoids are additively torsion.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddCommMonoid G], AddMonoid.IsTorsion { x // x ∈ AddCommMonoid.addTorsion G }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"The torsion submonoid of a torsion monoid is `⊤`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion G → CommMonoid.torsion G = ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion { x // x ∈ N } → Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H }\"},\n {\"role\": \"user\", \"content\": \"Torsion submonoids are torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ∈ CommMonoid.torsion G }\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ∈ H }\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H }\"},\n {\"role\": \"user\", \"content\": \"Every group is a torsion monoid.\"}]"}
{"text":"Every finite simple group has prime order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x → IsOfFinAddOrder (-x)\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\": \"finite p-groups with different p have coprime orders \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\"},\n {\"role\": \"user\", \"content\": \"Every finite simple group has prime order.\"}]"}
{"text":"Every finite group is simple.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Every finite measure is σ-finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {_m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure μ],\\n  MeasureTheory.SigmaFinite μ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any `k`-algebra module which is 1-dimensional over `k` is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} [inst : Ring R] {k : Type u_1} [inst_1 : Field k] [inst_2 : Algebra k R] {V : ModuleCat R},\\n  FiniteDimensional.finrank k ↑V = 1 → CategoryTheory.Simple V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\"},\n {\"role\": \"user\",\n  \"content\": \"A finite group action is always properly discontinuous.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {Γ : Type u_1} [inst : AddGroup Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Γ T]\\n  [inst_3 : Finite Γ], ProperlyDiscontinuousVAdd Γ T\"},\n {\"role\": \"user\",\n  \"content\": \"A finite group action is always properly discontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\\n  [inst_3 : Finite Γ], ProperlyDiscontinuousSMul Γ T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_1} [inst : Group G], Group.FG G ↔ Monoid.FG G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\"},\n {\"role\": \"user\", \"content\": \"Every finite group is simple.\"}]"}
{"text":"Every finite group has prime order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\": \"finite p-groups with different p have coprime orders \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\"},\n {\"role\": \"user\", \"content\": \"Every finite group has prime order.\"}]"}
{"text":"Every set has Lebesgue measure zero.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The Hausdorff distance between a set and itself is zero \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.hausdorffDist s s = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : Zero α] [inst_1 : Zero β] [inst_2 : SMulWithZero α β] [inst_3 : DecidableEq β]\\n  {s : Finset β}, Finset.Nonempty s → 0 • s = 0\"},\n {\"role\": \"user\", \"content\": \"The empty set is collinear. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Collinear k ∅\"},\n {\"role\": \"user\",\n  \"content\": \"Haar measure of the frontier of a convex set is zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E}, Convex ℝ s → ↑↑μ (frontier s) = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\\n  {f : E → E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ], DifferentiableOn ℝ f s → ↑↑μ s = 0 → ↑↑μ (f '' s) = 0\"},\n {\"role\": \"user\", \"content\": \"All convergents of `0` are zero. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (n : ℕ), Real.convergent 0 n = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the total masses of finite measures tend to zero, then the measures tend to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {Ω : Type u_2} [inst : MeasurableSpace Ω] [inst_1 : TopologicalSpace Ω] [inst_2 : OpensMeasurableSpace Ω]\\n  {γ : Type u_1} {F : Filter γ} {μs : γ → MeasureTheory.FiniteMeasure Ω},\\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (μs i)) F (nhds 0) → Filter.Tendsto μs F (nhds 0)\"},\n {\"role\": \"user\", \"content\": \"A strict vector subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\"},\n {\"role\": \"user\", \"content\": \"A strict affine subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : AffineSubspace ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\"},\n {\"role\": \"user\", \"content\": \"Every set has Lebesgue measure zero.\"}]"}
{"text":"If a topological space is compact, then every subset is compact.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α}, IsCompact s → IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a topological space is compact, then every subset is compact.\"}]"}
{"text":"Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A strict vector subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\"},\n {\"role\": \"user\", \"content\": \"A strict affine subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : AffineSubspace ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant ν],\\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\\n  {f : E → E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ], DifferentiableOn ℝ f s → ↑↑μ s = 0 → ↑↑μ (f '' s) = 0\"},\n {\"role\": \"user\",\n  \"content\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\\n  OpensMeasurableSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ν],\\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\"},\n {\"role\": \"user\",\n  \"content\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.\"}]"}
{"text":"A finitely-presented group containing a torsion element is finite.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G →* H},\\n  Function.Surjective ↑f → Monoid.IsTorsion G → Monoid.IsTorsion H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_1} [inst : Group G], Group.FG G ↔ Monoid.FG G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"The group exponent exists for any bounded torsion group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G → Set.Finite (Set.range fun g => orderOf g) → Monoid.ExponentExists G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G → Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G →+ H},\\n  N = AddMonoidHom.ker f → AddMonoid.IsTorsion H → AddMonoid.IsTorsion { x // x ∈ N } → AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion { x // x ∈ N } → Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"A finitely presented algebra is of finite type. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type w₁} {A : Type w₂} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\\n  Algebra.FinitePresentation R A → Algebra.FiniteType R A\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finitely-presented group containing a torsion element is finite.\"}]"}
{"text":"If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a sequential space, a set is closed iff it's sequentially closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {M : Set X}, IsSeqClosed M ↔ IsClosed M\"},\n {\"role\": \"user\",\n  \"content\": \"In a sequential space, a sequentially closed set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {s : Set X}, IsSeqClosed s → IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t)\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul 𝕜 E] {s : Set E},\\n  Convex 𝕜 s → Convex 𝕜 (closure s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\"},\n {\"role\": \"user\",\n  \"content\": \"Subsets of a given closed subset form a closed set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s}\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.\"}]"}
{"text":"A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the codomain of an injective continuous function is a Hausdorff space, then so is its\\ndomain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {f : α → β},\\n  Function.Injective f → Continuous f → T2Space α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H ↔ TotallySeparatedSpace H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → Function.Injective f → ClosedEmbedding f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.\"}]"}
{"text":"Any finite order element in a group is equal to the identity.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite additive order are closed under addition.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddCommMonoid G] {x y : G}, IsOfFinAddOrder x → IsOfFinAddOrder y → IsOfFinAddOrder (x + y)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x → IsOfFinAddOrder (-x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\\n  IsOfFinAddOrder x → IsOfFinAddOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\"},\n {\"role\": \"user\",\n  \"content\": \"Any finite order element in a group is equal to the identity.\"}]"}
{"text":"If a subgroup of a group is torsion-free, then the group itself is torsion free.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ⧸ Submodule.torsion R M) = ⊥\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G → Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion { x // x ∈ N } → Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Torsion submonoids are torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ∈ CommMonoid.torsion G }\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → AddGroup (Gs i)],\\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a subgroup of a group is torsion-free, then the group itself is torsion free.\"}]"}
{"text":"Every injective homomorphism from a finitely generated free group to itself is surjective.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The canonical map from the type to the free group is an injection. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u}, Function.Injective FreeGroup.of\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R₁ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R₁] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra R₁ A] [inst_4 : Algebra R₁ B] (f : A →ₐ[R₁] B), Function.Injective ↑(Ideal.kerLiftAlg f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ↑(Con.mk' c)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G →* H},\\n  Function.Surjective ↑f → Monoid.IsTorsion G → Monoid.IsTorsion H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Bijective ↑f\"},\n {\"role\": \"user\", \"content\": \"Group homomorphisms preserve inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹\"},\n {\"role\": \"user\",\n  \"content\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V →ₗ[K] V}, Function.Injective ↑f → Function.Surjective ↑f\"},\n {\"role\": \"user\",\n  \"content\": \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Bijective ↑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β},\\n  IsAddGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 0 → a = 0)\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is surjective \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\\n  [self : RingHomSurjective σ], Function.Surjective ↑σ\"},\n {\"role\": \"user\",\n  \"content\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ⊤ →g G'), Function.Injective ↑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Injective ↑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite ι] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R →\\n    ∀ (ps : ι → MvPolynomial ι R),\\n      (Function.Injective fun v i => ↑(MvPolynomial.eval v) (ps i)) →\\n        Function.Surjective fun v i => ↑(MvPolynomial.eval v) (ps i)\"},\n {\"role\": \"user\",\n  \"content\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Surjective ↑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every injective homomorphism from a finitely generated free group to itself is surjective.\"}]"}
{"text":"Every division ring is either a field or finite.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u_1) [inst : LinearOrderedField α] [inst_1 : FloorRing α], Archimedean α\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : NonAssocRing R] (p : ℕ) [inst : CharP R p] [inst : Finite R], p ≠ 0\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is always less than division in the field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m n : ℕ}, ↑(m / n) ≤ ↑m / ↑n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤\"},\n {\"role\": \"user\", \"content\": \"The category of rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is the floor of field division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] [inst_1 : FloorSemiring α] (m n : ℕ), ⌊↑m / ↑n⌋₊ = m / n\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\"},\n {\"role\": \"user\", \"content\": \"A field extension is integral if it is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ∈ S\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\", \"content\": \"A valued division ring is separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\\n  [inst_2 : Valued K Γ₀], SeparatedSpace K\"},\n {\"role\": \"user\",\n  \"content\": \"Every division ring is either a field or finite.\"}]"}
{"text":"Every natural number is the product of two primes.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 1 < n → ¬Nat.Prime n → FermatPsp n 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b : ℕ), a ≠ 0 → b ≠ 0 → (a = b ↔ ∀ (p : ℕ), Nat.Prime p → padicValNat p a = padicValNat p b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\": \"Every natural number is the product of two primes.\"}]"}
{"text":"Every even number is the square of a natural number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The convolution of two even functions is also even. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every even number is the square of a natural number.\"}]"}
{"text":"Every normal subgroup of a group has finite index.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\"},\n {\"role\": \"user\", \"content\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\"},\n {\"role\": \"user\",\n  \"content\": \"The topological closure of a normal subgroup is normal.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\"},\n {\"role\": \"user\", \"content\": \"A finite index subgroup has finite quotient. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → [inst_1 : Subgroup.FiniteIndex H] → Fintype (G ⧸ H)\"},\n {\"role\": \"user\",\n  \"content\": \"The submodule generated by a finite set is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\\n  Set.Finite A → FiniteDimensional K { x // x ∈ Submodule.span K A }\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a module has a finite dimension, all bases are indexed by a finite set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {ι : Type u_1} {s : Set ι}, Basis (↑s) R M → Module.rank R M < Cardinal.aleph0 → Set.Finite s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x ∈ H }\"},\n {\"role\": \"user\", \"content\": \"The additive subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ≠ 0\"},\n {\"role\": \"user\", \"content\": \"The subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"Every normal subgroup of a group has finite index.\"}]"}
{"text":"The characteristic polynomial of every matrix has real roots.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖↑φ x‖ = 1) → ∃ n x_1, x ^ n = 1\"},\n {\"role\": \"user\", \"content\": \"Every identity matrix is diagonal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero α] [inst_2 : One α], Matrix.IsDiag 1\"},\n {\"role\": \"user\",\n  \"content\": \"The degree of a minimal polynomial is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x → 0 < Polynomial.degree (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {σ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial σ R),\\n  ∃ n f _hf q, p = ↑(MvPolynomial.rename f) q\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of the spectrum of a selfadjoint is real. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ℂ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule ℂ A] (a : { x // x ∈ selfAdjoint A }) {z : ℂ},\\n  z ∈ spectrum ℂ ↑a → z = ↑z.re\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → x ≠ 0 → Polynomial.coeff (minpoly A x) 0 ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T → ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Fundamental theorem of algebra**: every non constant complex polynomial\\nhas a root \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {f : Polynomial ℂ}, 0 < Polynomial.degree f → ∃ z, Polynomial.IsRoot f z\"},\n {\"role\": \"user\",\n  \"content\": \"The diagonal elements of a complex hermitian matrix are real. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {n : Type u_1} [inst : IsROrC α] {A : Matrix n n α},\\n  Matrix.IsHermitian A → (fun i => ↑(↑IsROrC.re (Matrix.diag A i))) = Matrix.diag A\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic polynomial of every matrix has real roots.\"}]"}
{"text":"In a commutative ring, every prime ideal is contained in a unique maximal ideal.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The kernel of a homomorphism to a field is a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\\n  Function.Surjective ↑f → Ideal.IsMaximal (RingHom.ker f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I → Ideal.closure I = I\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I\"},\n {\"role\": \"user\",\n  \"content\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I\"},\n {\"role\": \"user\",\n  \"content\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a commutative ring, every prime ideal is contained in a unique maximal ideal.\"}]"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\"},\n {\"role\": \"user\", \"content\": \"A single function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_3} {β : Type u_2} {ι : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} [inst_1 : Subsingleton ι],\\n  1 ≤ p → p ≠ ⊤ → ∀ {f : ι → α → β}, (∀ (i : ι), MeasureTheory.Memℒp (f i) p) → MeasureTheory.UnifIntegrable f p μ\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {X : Type u_2} {α : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α},\\n  Equicontinuous F → ∀ (i : ι), Continuous (F i)\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UniformIntegrable (fun x => g) p μ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α) (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"Every continuous function is uniformly continuous.\"}]"}
{"text":"Every uniformly continuous function is bounded above.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α) (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a totally bounded set under a uniformly continuous map is totally bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} {s : Set α},\\n  TotallyBounded s → UniformContinuous f → TotallyBounded (f '' s)\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite union of sets which are all bounded above is still bounded above.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : SemilatticeSup α] [inst_1 : Nonempty α] {I : Set β} {S : β → Set α},\\n  Set.Finite I → (BddAbove (⋃ (i : β) (_ : i ∈ I), S i) ↔ ∀ (i : β), i ∈ I → BddAbove (S i))\"},\n {\"role\": \"user\", \"content\": \"A continuous, periodic function is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {f : ℝ → α} {c : ℝ},\\n  Function.Periodic f c → c ≠ 0 → Continuous f → Metric.Bounded (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function with compact support is bounded below. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\\n  Continuous f → HasCompactSupport f → BddBelow (Set.range f)\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded above.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : SemilatticeSup α] [inst_1 : Nonempty α] {s : Set α}, Set.Finite s → BddAbove s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The indexed supremum of a function is bounded above by a uniform bound\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {ι : Sort u_1} [inst : ConditionallyCompleteLattice α] [inst_1 : Nonempty ι] {f : ι → α} {c : α},\\n  (∀ (x : ι), f x ≤ c) → iSup f ≤ c\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded below on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function with compact support is bounded above. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\\n  Continuous f → HasCompactSupport f → BddAbove (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"Every uniformly continuous function is bounded above.\"}]"}
{"text":"If every compact subset of a topological space is closed, then the space is compact.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of compact operators from a normed space to a complete topological vector space is\\nclosed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜₁ : Type u_1} {𝕜₂ : Type u_2} [inst : NontriviallyNormedField 𝕜₁] [inst_1 : NormedField 𝕜₂] {σ₁₂ : 𝕜₁ →+* 𝕜₂}\\n  {M₁ : Type u_3} {M₂ : Type u_4} [inst_2 : SeminormedAddCommGroup M₁] [inst_3 : AddCommGroup M₂]\\n  [inst_4 : NormedSpace 𝕜₁ M₁] [inst_5 : Module 𝕜₂ M₂] [inst_6 : UniformSpace M₂] [inst_7 : UniformAddGroup M₂]\\n  [inst_8 : ContinuousConstSMul 𝕜₂ M₂] [inst_9 : T2Space M₂] [inst_10 : CompleteSpace M₂],\\n  IsClosed {f | IsCompactOperator ↑f}\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α}, IsCompact s → IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every compact subset of a topological space is closed, then the space is compact.\"}]"}
{"text":"In a commutative ring, the sum of idempotent elements is idempotent.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Addition is commutative in an additive commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u} [self : AddCancelCommMonoid M] (a b : M), a + b = b + a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Scalar multiplication commutes with the inclusion of each component into the direct sum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (i : ι) (c : R) (x : M i),\\n  ↑(DirectSum.of M i) (c • x) = c • ↑(DirectSum.of M i) x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The sum of two elements of an additive subsemigroup belongs to the subsemigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R) {a b : R},\\n  a ∈ self.carrier → b ∈ self.carrier → a + b ∈ self.carrier\"},\n {\"role\": \"user\",\n  \"content\": \"the condition that the given endomorphism is an idempotent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u_1} [inst : CategoryTheory.Category C] (self : CategoryTheory.Idempotents.Karoubi C),\\n  CategoryTheory.CategoryStruct.comp self.p self.p = self.p\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\": \"Scalar multiplication commutes with direct sums. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (s : Finset ι) (c : R)\\n  (x : (i : ↑↑s) → M ↑i), ↑(DirectSum.mk M s) (c • x) = c • ↑(DirectSum.mk M s) x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), ↑f (a + b) = ↑f a + ↑f b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Moving to the opposite additive commutative monoid commutes with summing. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {β : Type u} {α : Type v} [inst : AddCommMonoid β] {s : Finset α} (f : α → β),\\n  MulOpposite.op (Finset.sum s fun x => f x) = Finset.sum s fun x => MulOpposite.op (f x)\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : StrictOrderedCommRing α] (a b : α), a * b = b * a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I → (IsIdempotentElem I ↔ ∃ e, IsIdempotentElem e ∧ I = Submodule.span R {e})\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves addition. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), ↑e (x + y) = ↑e x + ↑e y\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [self : BooleanRing α] (a : α), a * a = a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a commutative ring, the sum of idempotent elements is idempotent.\"}]"}
{"text":"The number of partitions of a finite set is a prime number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A product of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : ι → WithTop R},\\n  (∀ (i : ι), i ∈ s → f i ≠ ⊤) → (Finset.prod s fun i => f i) < ⊤\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Set.Finite s → Metric.Bounded s\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ (a : α), ↑(f a))\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"There are finitely many subsets of a given finite set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The variable of the power series ring over an integral domain is prime.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\"},\n {\"role\": \"user\",\n  \"content\": \"The number of partitions of a finite set is a prime number.\"}]"}
{"text":"If a poset has a maximal element, then it has a unique minimal element.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A word and its maximal reduction correspond to the same element of the additive free\\ngroup.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {L : List (α × Bool)} [inst : DecidableEq α], FreeAddGroup.mk (FreeAddGroup.reduce L) = FreeAddGroup.mk L\"},\n {\"role\": \"user\",\n  \"content\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R],\\n  IsField R → ∀ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), ↑Polynomial.C x ∈ I → x = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), a ∈ s → sInf s ≤ a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 → ∀ (a : M₀), a = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a word reduces to another word, then they have a common maximal reduction. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\\n  FreeGroup.Red L₁ L₂ → FreeGroup.reduce L₁ = FreeGroup.reduce L₂\"},\n {\"role\": \"user\",\n  \"content\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ℤ) (I : { x // x ∈ nonZeroDivisors (Ideal S) }),\\n  ∃ b, b ∈ ↑I ∧ b ≠ 0 ∧ ∀ (c : S), c ∈ ↑I → ↑abv (↑(Algebra.norm R) c) < ↑abv (↑(Algebra.norm R) b) → c = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a word reduces to another word, then they have a common maximal reduction.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\\n  FreeAddGroup.Red L₁ L₂ → FreeAddGroup.reduce L₁ = FreeAddGroup.reduce L₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {r : α → α → Prop},\\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m\"},\n {\"role\": \"user\",\n  \"content\": \"A least element of a set is the infimum of this set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsLeast s a → sInf s = a\"},\n {\"role\": \"user\",\n  \"content\": \"A greatest element of a set is the supremum of this set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsGreatest s a → sSup s = a\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is less than the set supremum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), a ∈ s → a ≤ sSup s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A word and its maximal reduction correspond to the same element of the free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {L : List (α × Bool)} [inst : DecidableEq α], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a poset has a maximal element, then it has a unique minimal element.\"}]"}
{"text":"The automorphism group of an Abelian group is cyclic.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Abelian groups have nilpotency class at most one \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\": \"The action of an additive group on an orbit is transitive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddAction α β] (x : β),\\n  AddAction.IsPretransitive α ↑(AddAction.orbit α x)\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a group acts commutatively on that group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The right regular action of an additive group on itself is transitive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive Gᵃᵒᵖ G\"},\n {\"role\": \"user\", \"content\": \"Abelian groups are nilpotent \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\"},\n {\"role\": \"user\", \"content\": \"Every subgroup of `ℤ` is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\\n  IsCyclic { x // x ∈ S }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\"},\n {\"role\": \"user\",\n  \"content\": \"The automorphism group of an Abelian group is cyclic.\"}]"}
{"text":"If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {μ : MeasureTheory.Measure ℝ}\\n  {a b : ℝ}, Set.EqOn f g (Set.uIcc a b) → ∫ (x : ℝ) in a..b, f x ∂μ = ∫ (x : ℝ) in a..b, g x ∂μ\"},\n {\"role\": \"user\", \"content\": \"A continuous, periodic function is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {f : ℝ → α} {c : ℝ},\\n  Function.Periodic f c → c ≠ 0 → Continuous f → Metric.Bounded (Set.range f)\"},\n {\"role\": \"user\", \"content\": \"For the identity map, all points are periodic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} (n : ℕ) (x : α), Function.IsPeriodicPt id n x\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous, periodic function has compact range. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {f : ℝ → α} {c : ℝ},\\n  Function.Periodic f c → c ≠ 0 → Continuous f → IsCompact (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\"},\n {\"role\": \"user\", \"content\": \"Any point is a periodic point of period `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 0 x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.\"}]"}
{"text":"The complement of the union of two sets contains the union of their complements.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ (a : α), ↑(f a))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of all sets in a compact exhaustion equals the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\\n  ⋃ (n : ℕ), CompactExhaustion.toFun self n = Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {γ : Type w} [inst : SemilatticeSup γ] {s t : Set γ}, BddAbove (s ∪ t) ↔ BddAbove s ∧ BddAbove t\"},\n {\"role\": \"user\",\n  \"content\": \"The span of a union of sets is the sup of their spans. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s ∪ t) = affineSpan k s ⊔ affineSpan k t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} (S T : Set α), Cardinal.mk ↑(S ∪ T) ≤ Cardinal.mk ↑S + Cardinal.mk ↑T\"},\n {\"role\": \"user\",\n  \"content\": \"The disjoint union of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded (s ∪ t) ↔ Metric.Bounded s ∧ Metric.Bounded t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} {p : ENNReal} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup E] {s t : Set α} (hs : MeasurableSet s) (ht : MeasurableSet t) (hμs : ↑↑μ s ≠ ⊤)\\n  (hμt : ↑↑μ t ≠ ⊤),\\n  s ∩ t = ∅ →\\n    ∀ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ∪ t)) (_ : ↑↑μ (s ∪ t) ≠ ⊤) c =\\n        MeasureTheory.indicatorConstLp p hs hμs c + MeasureTheory.indicatorConstLp p ht hμt c\"},\n {\"role\": \"user\", \"content\": \"The union of two bounded sets is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded s → Metric.Bounded t → Metric.Bounded (s ∪ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), frontier sᶜ = frontier s\"},\n {\"role\": \"user\", \"content\": \"The complement of a closed set is an open set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of the union of two sets contains the union of their complements.\"}]"}
{"text":"The square root of an rational number is rational.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : ℚ), Nat.coprime (Int.natAbs self.num) self.den\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ≤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ≤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\"},\n {\"role\": \"user\", \"content\": \"**Irrationality of the Square Root of 2** \"},\n {\"role\": \"assistant\", \"content\": \"Irrational (Real.sqrt 2)\"},\n {\"role\": \"user\",\n  \"content\": \"A quadratic has roots if its discriminant has square roots \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\\n  a ≠ 0 → (∃ s, discrim a b c = s * s) → ∃ x, a * x * x + b * x + c = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of a Liouville number and a nonzero rational number is again a Liouville number.  \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p x : ℝ} {r : ℚ}, LiouvilleWith p x → r ≠ 0 → LiouvilleWith p (x * ↑r)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖↑φ x‖ = 1) → ∃ n x_1, x ^ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜]\\n  [inst_3 : Archimedean 𝕜], DenseRange Rat.cast\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2}\"},\n {\"role\": \"user\",\n  \"content\": \"The continued fraction of a rational number terminates. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (q : ℚ), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) → ∃ q, v = ↑q\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\"},\n {\"role\": \"user\",\n  \"content\": \"The square root of an rational number is rational.\"}]"}
{"text":"If a module over a ring is free, then the ring is commutative.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Bijective ↑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Injective ↑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ⧸ Submodule.torsion R M) = ⊥\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The category of modules has enough projectives, since every module is a quotient of a free\\nmodule. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R], CategoryTheory.EnoughProjectives (ModuleCat R)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A module over a semiring is `Finite` if it is finitely generated as a module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [self : Module.Finite R M], Submodule.FG ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two finite and free modules are isomorphic if and only if they have the same (finite) rank. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\\n  Nonempty (M ≃ₗ[R] N) ↔ FiniteDimensional.finrank R M = FiniteDimensional.finrank R N\"},\n {\"role\": \"user\",\n  \"content\": \"A module with a finite ring of scalars is additively torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\"},\n {\"role\": \"user\", \"content\": \"Modules over the trivial ring are Noetherian. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\\n  [inst_2 : Module R M], IsNoetherian R M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The lattice of submodules of a module over a division ring is atomistic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsAtomistic (Submodule K V)\"},\n {\"role\": \"user\",\n  \"content\": \"The product of finitely many free modules is free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} (R : Type u) [inst : Semiring R] (M : ι → Type u_2) [inst_1 : Finite ι]\\n  [inst_2 : (i : ι) → AddCommMonoid (M i)] [inst_3 : (i : ι) → Module R (M i)]\\n  [inst_4 : ∀ (i : ι), Module.Free R (M i)], Module.Free R ((i : ι) → M i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V ↔ Module.Finite K V\"},\n {\"role\": \"user\",\n  \"content\": \"If a module over a ring is free, then the ring is commutative.\"}]"}
{"text":"If the set of units of a ring forms a group then the ring is commutative.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y → IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\\n  IsCyclic { x // x ∈ S }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\": \"Composition of non-unital ring homomorphisms is associative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} [inst : NonUnitalNonAssocSemiring α]\\n  [inst_1 : NonUnitalNonAssocSemiring β] [inst_2 : NonUnitalNonAssocSemiring γ] {δ : Type u_1}\\n  {x : NonUnitalNonAssocSemiring δ} (f : α →ₙ+* β) (g : β →ₙ+* γ) (h : γ →ₙ+* δ),\\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f : α → β},\\n  IsGroupHom f → IsGroupHom fun a => (f a)⁻¹\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : StrictOrderedCommRing α] (a b : α), a * b = b * a\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a group acts commutatively on that group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the set of units of a ring forms a group then the ring is commutative.\"}]"}
{"text":"Every natural number larger than `10` is the sum of a square and a prime.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 1 < n → ¬Nat.Prime n → FermatPsp n 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every natural number larger than `10` is the sum of a square and a prime.\"}]"}
{"text":"The initial object of a category is isomorphic to its terminal object.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any category with pushouts and initial object has binary coproducts. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasBinaryCoproducts C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A category in which coimage-image comparisons are all isomorphisms has images. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : ∀ {X Y : C} (f : X ⟶ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\\n  CategoryTheory.Limits.HasImages C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a connected category, any two objects are related by `Zigzag`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J] (j₁ j₂ : J),\\n  CategoryTheory.Zigzag j₁ j₂\"},\n {\"role\": \"user\",\n  \"content\": \"A category with finite biproducts has a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\", \"content\": \"Any morphism to an initial object is epi. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsInitial X → ∀ (f : Y ⟶ X), CategoryTheory.Epi f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\",\n  \"content\": \"Any two morphisms from an initial object are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsInitial X → ∀ (f g : X ⟶ Y), f = g\"},\n {\"role\": \"user\", \"content\": \"Any morphism from a terminal object is mono. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X → ∀ (f : X ⟶ Y), CategoryTheory.Mono f\"},\n {\"role\": \"user\", \"content\": \"The category `D` has isomorphic objects equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D]\\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F → CategoryTheory.Skeletal D\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\"},\n {\"role\": \"user\",\n  \"content\": \"Any two morphisms to a terminal object are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X → ∀ (f g : Y ⟶ X), f = g\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The initial object of a category is isomorphic to its terminal object.\"}]"}
{"text":"If the composition of two functions is continuous, then each of them is continuous.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α) (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {X : Type u_2} {α : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α},\\n  Equicontinuous F → ∀ (i : ι), Continuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the composition of two functions is continuous, then each of them is continuous.\"}]"}
{"text":"If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`X` commutes with everything, even when the coefficients are noncommutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X\"},\n {\"role\": \"user\", \"content\": \"If `a % b = c` then `b` divides `a - c`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a b c : ℤ}, a % b = c → b ∣ a - c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Transitivity for `BEq`. If `a == b` and `b == c` then `a == c`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : BEq α] [self : PartialEquivBEq α] {a b c : α},\\n  (a == b) = true → (b == c) = true → (a == c) = true\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` and `b` fall within the same cycle WRT `c`, then they are congruent modulo `p`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] [hα : Archimedean α] {p : α} (hp : 0 < p) {a b c : α},\\n  toIcoMod hp c a = toIcoMod hp c b ↔ a ≡ b [PMOD p]\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {r : α → α → Prop} [self : IsDirected α r] (a b : α), ∃ c, r a c ∧ r b c\"},\n {\"role\": \"user\",\n  \"content\": \"If `c • a < c • b` for some positive `c`, then `a < b`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\\n  [self : OrderedSMul R M] {a b : M} {c : R}, c • a < c • b → 0 < c → a < b\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.\"}]"}
{"text":"If an element maps to zero under a ring homomorphism, then it is zero.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Ring homomorphisms map one to one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 1 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the algebra map `R →+* A` is injective and `R` has characteristic zero then so does `A`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\\n  Function.Injective ↑(algebraMap R A) → ∀ [inst : CharZero R], CharZero A\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, zero equals one if and only if all elements of that semiring\\nare equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 ↔ Subsingleton M₀\"},\n {\"role\": \"user\",\n  \"content\": \"A ring is a `ℚ`-algebra iff it has equal characteristic zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ℚ R) ↔ ∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R →+* S} {s : Set R},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subring.closure s)\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is an isometry. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Norm R₁] [inst_3 : Norm R₂]\\n  {σ : R₁ →+* R₂} [self : RingHomIsometric σ] {x : R₁}, ‖↑σ x‖ = ‖x‖\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 → ∀ (a : M₀), a = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\"},\n {\"role\": \"user\",\n  \"content\": \"The zero morphism maps every pseudoelement to 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} (Q : C)\\n  (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a = 0\"},\n {\"role\": \"user\",\n  \"content\": \"An element is in the kernel if and only if it maps to zero.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\\n  {r : R}, r ∈ RingHom.ker f ↔ ↑f r = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A morphism that is injective on pseudoelements only maps the zero element to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q),\\n  Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f) →\\n    ∀ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 → a = 0\"},\n {\"role\": \"user\", \"content\": \"An additive group homomorphism sends 0 to 0.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β}, IsAddGroupHom f → f 0 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A morphism that only maps the zero pseudoelement to zero is a monomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q),\\n  (∀ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 → a = 0) →\\n    CategoryTheory.Mono f\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism sends zero to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R ≃+* S), ↑f 0 = 0\"},\n {\"role\": \"user\", \"content\": \"Ring homomorphisms map zero to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 0 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an element maps to zero under a ring homomorphism, then it is zero.\"}]"}
{"text":"Implication `→` is symmetric. If `P → Q` then `Q → P`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The proposition that a Heyting homomorphism preserves the Heyting implication.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} {α : outParam (Type u_2)} {β : outParam (Type u_3)} [inst : HeytingAlgebra α]\\n  [inst_1 : HeytingAlgebra β] [self : HeytingHomClass F α β] (f : F) (a b : α), ↑f (a ⇨ b) = ↑f a ⇨ ↑f b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `P` holds for `f : X ⟶ Y`, then `P` holds for `f ∣_ U` for any `U`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P →\\n    ∀ {X Y : AlgebraicGeometry.Scheme} (f : X ⟶ Y) (U : TopologicalSpace.Opens ↑↑Y.toPresheafedSpace), P f → P (f ∣_ U)\"},\n {\"role\": \"user\", \"content\": \"Congruence relations are symmetric. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : Mul M] (c : Con M) {x y : M}, ↑c x y → ↑c y x\"},\n {\"role\": \"user\",\n  \"content\": \"`P` as a morphism property respects isomorphisms \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {P : AlgebraicGeometry.AffineTargetMorphismProperty},\\n  AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P →\\n    CategoryTheory.MorphismProperty.RespectsIso (AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P)\"},\n {\"role\": \"user\", \"content\": \"`x ⇨ y` is equal to `y ⊔ xᶜ` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [self : BooleanAlgebra α] (x y : α), x ⇨ y = y ⊔ xᶜ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An antisymmetric relation `(·≤·)` satisfies `a ≤ b → b ≤ a → a = b`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Sort u} {r : α → α → Prop} [self : Antisymm r] {a b : α}, r a b → r b a → a = b\"},\n {\"role\": \"user\", \"content\": \"monotonicity of `≤` with respect to `→` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {a b c d : α} [inst : Preorder α], c ≤ a → b ≤ d → a ≤ b → c ≤ d\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `∀ I > J, P I` implies `P J`, then `P` holds for all submodules. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] {P : Submodule R M → Prop},\\n  (∀ (I : Submodule R M), (∀ (J : Submodule R M), J > I → P J) → P I) → ∀ (I : Submodule R M), P I\"},\n {\"role\": \"user\", \"content\": \"An equivalence relation is reflexive: `x ~ x` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ (x : α), r x x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ {x y z : α}, r x y → r y z → r x z\"},\n {\"role\": \"user\", \"content\": \"`P` respects isomorphisms. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P → CategoryTheory.MorphismProperty.RespectsIso P\"},\n {\"role\": \"user\",\n  \"content\": \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\"},\n {\"role\": \"user\", \"content\": \"`(P ⟶ P⁺)⁺ = P⁺ ⟶ P⁺⁺` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\\n  [inst_1 : CategoryTheory.Category D]\\n  [inst_2 :\\n    ∀ (P : CategoryTheory.Functor Cᵒᵖ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\\n  (P : CategoryTheory.Functor Cᵒᵖ D)\\n  [inst_3 : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)ᵒᵖ D],\\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P)\"},\n {\"role\": \"user\",\n  \"content\": \"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ {x y : α}, r x y → r y x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Implication `→` is transitive. If `P → Q` and `Q → R` then `P → R`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q r : Prop}, (p → q) → (q → r) → p → r\"},\n {\"role\": \"user\",\n  \"content\": \"Implication `→` is symmetric. If `P → Q` then `Q → P`.\"}]"}
{"text":"Two natural numbers are equal if and only if they are both divisible by some prime number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : ℚ), Nat.coprime (Int.natAbs self.num) self.den\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b : ℕ), a ≠ 0 → b ≠ 0 → (a = b ↔ ∀ (p : ℕ), Nat.Prime p → padicValNat p a = padicValNat p b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Any common divisor of both elements is a divisor of the GCD. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : GCDMonoid α] {a b c : α}, a ∣ c → a ∣ b → a ∣ gcd c b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, m ∣ n + m ↔ m ∣ n\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, m ∣ m + n ↔ m ∣ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a b : ℕ}, a ∣ b → b < a → b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they are both divisible by some prime number.\"}]"}
