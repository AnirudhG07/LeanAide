(c : tactic.abel.context) (n inst : name) (l : list expr) : tactic expr
(f : format) : format
{Œ± : Type u_2} [add_zero_class Œ±] : add_zero_class (set Œ±)
{Œ± : Type u} [has_repr Œ±] : free_magma Œ± ‚Üí string
{Œ± : Type u_1} [decidable_eq Œ±] : has_sdiff (finset Œ±)
{C : Type u} [category_theory.category C] {Œπ : Type u_1} {s : Œπ ‚Üí C} [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] (o : category_theory.hom_orthogonal s) {Œ± Œ≤ : Type v} [fintype Œ±] [fintype Œ≤] {f : Œ± ‚Üí Œπ} {g : Œ≤ ‚Üí Œπ} : ((‚®Å Œª (a : Œ±), s (f a)) ‚ü∂ ‚®Å Œª (b : Œ≤), s (g b)) ‚âÉ Œ† (i : Œπ), matrix ‚Ü•(g ‚Åª¬π' {i}) ‚Ü•(f ‚Åª¬π' {i}) (category_theory.End (s i))
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.initial] {E : Type u} [category_theory.category E] {G : D ‚•§ E} (t : category_theory.limits.cone G) : category_theory.limits.is_limit (category_theory.limits.cone.whisker F t) ‚âÉ category_theory.limits.is_limit t
{Œ± : Type u} [pseudo_metric_space Œ±] (x y z : Œ±) : has_nndist.nndist x z ‚â§ has_nndist.nndist x y + has_nndist.nndist y z
{C : Type u} [category_theory.category C] : C ‚•§ category_theory.with_terminal C
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ‚Üî module.rank K V < cardinal.aleph_0
{U : Top} (X : algebraic_geometry.LocallyRingedSpace) {f : U ‚ü∂ X.to_Top} (h : open_embedding ‚áëf) : X.restrict h ‚ü∂ X
{Œ± : Type u_2} [decidable_eq Œ±] {s : finset Œ±} {B : finset (finset Œ±)} {n : ‚Ñï} (h : ‚àÄ (a : Œ±), a ‚àà s ‚Üí (finset.filter (has_mem.mem a) B).card ‚â§ n) : B.sum (Œª (t : finset Œ±), (s ‚à© t).card) ‚â§ s.card * n
{Œ± : Type u} [pseudo_emetric_space Œ±] (s t : set Œ±) : ennreal
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_zero_object C] : category_theory.limits.kernel_fork f
{R : Type u_1} {n : ‚Ñï} {M : fin n ‚Üí Type u_3} {M‚ÇÇ : Type u_4} [comm_semiring R] [add_comm_monoid M‚ÇÇ] [Œ† (i : fin n), add_comm_monoid (M i)] [Œ† (i : fin n), module R (M i)] [module R M‚ÇÇ] {f g : multilinear_map R M M‚ÇÇ} {Œπ‚ÇÅ : fin n ‚Üí Type u_2} (e : Œ† (i : fin n), basis (Œπ‚ÇÅ i) R (M i)) (h : ‚àÄ (v : Œ† (i : fin n), Œπ‚ÇÅ i), ‚áëf (Œª (i : fin n), ‚áë(e i) (v i)) = ‚áëg (Œª (i : fin n), ‚áë(e i) (v i))) : f = g
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (D : algebraic_geometry.SheafedSpace.glue_data C) [category_theory.limits.has_limits C] (i j : D.to_glue_data.J) : category_theory.limits.is_limit (D.to_glue_data.V_pullback_cone i j)
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] [category_theory.limits.has_limits C] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.reflects_isomorphisms (category_theory.forget C)] (F : Top.sheaf C X) (U : topological_space.opens ‚Ü•X) (s t : ‚Ü•(F.val.obj (opposite.op U))) (h : ‚àÄ (x : ‚Ü•U), ‚áë(F.val.germ x) s = ‚áë(F.val.germ x) t) : s = t
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ≤] [measurable_space Œ±] (f : Œ± ‚Üí Œ≤) : measure_theory.measure Œ≤ ‚Üí‚Çó[ennreal] measure_theory.measure Œ±
(G : Type u_1) [topological_space G] [group G] : Prop
(Œ± : Type u) : Type u
(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))
{G : Type u_7} [add_group G] (L : list G) (i : ‚Ñï) (p : i < L.length) : (list.drop (i + 1) L).sum = -L.nth_le i p + (list.drop i L).sum
{Œ± : Type u_1} (Œπ : Type u_3) {m : measurable_space Œ±} [preorder Œπ] (m' : measurable_space Œ±) (hm' : m' ‚â§ m) : measure_theory.filtration Œπ m
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b : Œ±} : a - b < 0 ‚Üî a < b
{C : Type u} [category_theory.category C] (i p : category_theory.arrow C) (h : category_theory.limits.is_initial i.left) : category_theory.has_lifting_property i p ‚Üî ‚àÄ {e : i.right ‚ü∂ p.right}, ‚àÉ (l : i.right ‚ü∂ p.left), l ‚â´ p.hom = e
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.pos_mul_mono Œ±] (ha : a ‚â§ 1) (hb : b ‚â§ 1) (a0 : 0 < a) : a * b ‚â§ 1
{Œ± : Type u_1} [group Œ±] {s : subgroup Œ±} (g : Œ±) : ‚Ü•(left_coset g ‚Üës) ‚âÉ ‚Ü•s
 : tactic unit
(R : Type u_1) [comm_ring R] {n m : ‚Ñï} (hpos : 0 < n) (hm : m ‚à£ n) (hdiff : m ‚â† n) : polynomial.X ^ m - 1 ‚à£ n.proper_divisors.prod (Œª (i : ‚Ñï), polynomial.cyclotomic i R)
{M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] (e : M ‚âÉ* N) (y : N) : ‚áëe (‚áë(e.symm) y) = y
(p : ‚Ñï) : witt_vector.is_poly p (Œª (R : Type u_1) (_Rcr : comm_ring R), witt_vector.verschiebung_fun)
{S‚ÇÅ : Type u_1} {S‚ÇÇ : Type u_2} {S‚ÇÉ : Type u_3} [shelf S‚ÇÅ] [shelf S‚ÇÇ] [shelf S‚ÇÉ] (g : shelf_hom S‚ÇÇ S‚ÇÉ) (f : shelf_hom S‚ÇÅ S‚ÇÇ) : shelf_hom S‚ÇÅ S‚ÇÉ
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {f : E ‚Üí F} (g : F ‚ÜíL[ùïú] G) (hf : cont_diff ùïú n f) : cont_diff ùïú n (Œª (x : E), ‚áëg (f x))
{R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular ‚Üëa
{Œ± : Type u_1} [topological_space Œ±] (S : set (set Œ±)) (hS : ‚àÄ (s : ‚Ü•S), is_open ‚Üës) [hS' : ‚àÄ (s : ‚Ü•S), quasi_sober ‚Ü•s] (hS'' : ‚ãÉ‚ÇÄS = ‚ä§) : quasi_sober Œ±
{Œ± : Type u_1} {n : Type u_4} [has_zero Œ±] [subsingleton n] (A : matrix n n Œ±) : A.is_diag
{R : Type u_1} {A : Type u_2} [has_zero R] : has_coe_t A (unitization R A)
{G : Type w} [topological_space G] [add_group G] [has_continuous_add G] (a : G) : G ‚âÉ‚Çú G
{L : first_order.language} [L.is_algebraic] {F : Type u_1} {M : Type u_2} {N : Type u_3} [L.Structure M] [L.Structure N] [fun_like F M (Œª (_x : M), N)] [first_order.language.hom_class L F M N] : first_order.language.strong_hom_class L F M N
{Œπ : Type w} {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] [is_domain R] [fintype Œπ] (b : basis Œπ R M) (P : submodule R M ‚Üí Sort u_1) (ih : Œ† (N : submodule R M), (Œ† (N' : submodule R M), N' ‚â§ N ‚Üí Œ† (x : M), x ‚àà N ‚Üí (‚àÄ (c : R) (y : M), y ‚àà N' ‚Üí c ‚Ä¢ x + y = 0 ‚Üí c = 0) ‚Üí P N') ‚Üí P N) (N : submodule R M) : P N
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.enough_projectives C] (Z : C) : category_theory.ProjectiveResolution Z
{n m : ‚Ñï} {F : typevec n ‚Üí Type u_1} {G : fin2 n ‚Üí typevec m ‚Üí Type u} {Œ± : typevec m} (x : mvqpf.comp F G Œ±) : F (Œª (i : fin2 n), G i Œ±)
{Œ± : Type u} [complete_lattice Œ±] {J : Type u} [category_theory.small_category J] (F : J ‚•§ Œ±) : category_theory.limits.colimit_cocone F
 : expr ‚Üí bool
(C : Type u) [category_theory.category C] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.abelian C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (h : category_theory.exact f g) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ (category_theory.abelian.coimage.œÄ g) _)
(Œ± : Type u) [has_add Œ±] : Œ± ‚Üí Œ± ‚Üí Prop
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {c : E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ‚Ñù} [interval_integral.FTC_filter b (nhds_within b s) (nhds_within b t)] (hmeas : strongly_measurable_at_filter f (nhds_within b t) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds_within b t ‚äì measure_theory.measure_space.volume.ae) (nhds c)) (hs : unique_diff_within_at ‚Ñù s b . "unique_diff_within_at_Ici_Iic_univ") : deriv_within (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in a..u, f x) s b = c
{R : Type u_2} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] : mul_action_with_zero R M
 : Type
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} [comm_ring R] [lie_ring L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÅ] [lie_algebra R L‚ÇÇ] (f : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : L‚ÇÅ ‚âÉ‚Çó[R] L‚ÇÇ
(P : Type u_2) [preorder P] : Type u_2
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {S : category_theory.sieve X} : ‚áëS (ùüô X) ‚Üî S = ‚ä§
(R : Type u) {M : Type v} [semiring R] [add_comm_monoid M] [module R M] : module R M·µê·µí·µñ
 : widget_override.filter_type ‚Üí expr ‚Üí tactic bool
{K : Type u} [hring : comm_ring K] : ratfunc K ‚Üí ratfunc K ‚Üí ratfunc K
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : has_dist.dist p1 p3 * has_dist.dist p1 p3 = has_dist.dist p1 p2 * has_dist.dist p1 p2 + has_dist.dist p3 p2 * has_dist.dist p3 p2 ‚Üî euclidean_geometry.angle p1 p2 p3 = real.pi / 2
{M : Type u_2} [add_comm_group M] {ùïú : Type u_1} [field ùïú] [module ùïú M] {f : M ‚Üí‚Çó[ùïú] M} (hf : ‚áëlinear_map.det f = 0) : ‚ä• < f.ker
{Œ± : Type u} (g : set (set Œ±)) : set Œ± ‚Üí Prop
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] {s t : category_theory.limits.cotrident f} (i : s.X ‚âÖ t.X) (w : s.œÄ ‚â´ i.hom = t.œÄ) : s ‚âÖ t
{m : Type u_2} {n : Type u_3} {R : Type u_7} [fintype n] [fintype m] [non_unital_semiring R] (v : m ‚Üí R) (A : matrix m n R) (w : n ‚Üí R) : matrix.dot_product v (A.mul_vec w) = matrix.dot_product (matrix.vec_mul v A) w
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.abelian D] (F : C ‚•§ D) (G : D ‚•§ C) [G.preserves_zero_morphisms] (i : F ‚ãô G ‚âÖ ùü≠ C) [category_theory.limits.preserves_finite_limits G] : category_theory.limits.has_kernels C
(X : algebraic_geometry.RingedSpace) {U : topological_space.opens ‚Ü•X} (f : ‚Ü•(X.to_PresheafedSpace.presheaf.obj (opposite.op U))) : topological_space.opens ‚Ü•X
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} (t : category_theory.limits.cofork f g) (create : Œ† (s : category_theory.limits.cofork f g), {l // t.œÄ ‚â´ l = s.œÄ ‚àß ‚àÄ {m : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj t.X).obj category_theory.limits.walking_parallel_pair.one ‚ü∂ ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.one}, t.œÄ ‚â´ m = s.œÄ ‚Üí m = l}) : category_theory.limits.is_colimit t
(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (n : ‚Ñï) : multilinear_map R (Œª (i : fin n), M) (tensor_algebra R M)
(arg_name : name) : name
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.limits.reflects_limit K F] : category_theory.limits.reflects_limit K G
(n : ‚Ñï) : equiv.perm (fin n)
 : tactic unit
{V : Type u} (G : simple_graph V) {v w : V} : G.adj v w ‚Üî v ‚â† w ‚àß ‚àÉ (e : sym2 V) (H : e ‚àà G.edge_set), v ‚àà e ‚àß w ‚àà e
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} (f : J ‚Üí (X ‚ü∂ Y)) : Type (max u v)
(params : ‚Ñï) : tactic.list_Sigma name ‚Üí tactic.list_Sigma tactic.rcases_patt ‚Üí tactic (dlist name √ó tactic.list_Sigma (name √ó tactic.list_Pi tactic.rcases_patt))
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [module ùïú E] {s : set E} : s.nonempty ‚Üí (‚áë(convex_hull ùïú) s).nonempty
{G : Type u_1} [add_group G] [fintype G] (p : ‚Ñï) [hp : fact (nat.prime p)] (hdvd : p ‚à£ fintype.card G) : ‚àÉ (x : G), add_order_of x = p
{Œ± : Type u} [has_subset Œ±] [has_ssubset Œ±] [is_nonstrict_strict_order Œ± has_subset.subset has_ssubset.ssubset] {a b c : Œ±} [is_trans Œ± has_subset.subset] (h‚ÇÅ : a ‚äÇ b) (h‚ÇÇ : b ‚äÜ c) : a ‚äÇ c
{R : Type u} {S : Type v} [comm_ring R] [comm_ring S] (f : R ‚Üí+* S) : function.injective ‚áë(f.ker_lift)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) (s : alist Œ≤) : option (Œ≤ a) √ó alist Œ≤
 : setoid (Type u)
{M : Type u_1} [has_add M] (r : M ‚Üí M ‚Üí Prop) : add_con M
{Œ± : Type} [random Œ±] : io (stream Œ±)
{G : Type u_1} [add_comm_group G] (f : ‚Ñï ‚Üí G) (n : ‚Ñï) : (finset.range n).sum (Œª (i : ‚Ñï), f (i + 1) - f i) = f n - f 0
(V : Type u) [quiver V] (L : Sort u_2) : Sort (imax (u+1) (u+1) u_1 u_2)
{M : Type u_2} [add_comm_group M] {Œπ : Type u_4} [decidable_eq Œπ] [fintype Œπ] {A : Type u_5} [comm_ring A] [module A M] (b : basis Œπ A M) (f : M ‚Üí‚Çó[A] M) : ‚áë(linear_map.det_aux (trunc.mk b)) f = (‚áë(linear_map.to_matrix b b) f).det
{Œ± : Type u_1} {l l' : list Œ±} : l <+ l' ‚Üî ‚àÉ (f : ‚Ñï ‚Ü™o ‚Ñï), ‚àÄ (ix : ‚Ñï), l.nth ix = l'.nth (‚áëf ix)
(h : expr) (tac : tactic unit) : tactic unit
{Œ± : Type u_1} : ordnode Œ± ‚Üí Œ± ‚Üí ordnode Œ± ‚Üí Œ± ‚Üí ordnode Œ± ‚Üí ordnode Œ±
(e : expr) : tactic (expr √ó expr)
{C : Type u} [category_theory.category C] {X Y Z : C} {i : category_theory.arrow C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (hf : category_theory.has_lifting_property i (category_theory.arrow.mk f)) (hg : category_theory.has_lifting_property i (category_theory.arrow.mk g)) : category_theory.has_lifting_property i (category_theory.arrow.mk (f ‚â´ g))
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} : has_mem Œ± (alist Œ≤)
{C : Type u_1} [category_theory.category C] (G : C ‚•§ Type w) : category_theory.grothendieck (G ‚ãô category_theory.Type_to_Cat) ‚âå G.elements
{Œ± : Type u_1} [has_lt Œ±] {a b : Œ±·µí·µà} : b < a ‚Üí ‚áëorder_dual.of_dual a < ‚áëorder_dual.of_dual b
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e e' : local_homeomorph Œ± Œ≤} (h : e ‚âà e') : e.to_local_equiv.target = e'.to_local_equiv.target
(Œ± : Type u) [t : topological_space Œ±] : Prop
{M : Type u_1} [ordered_cancel_add_comm_monoid M] (S : add_submonoid M) : ordered_cancel_add_comm_monoid ‚Ü•S
{Œ± : Type u} [topological_space Œ±] [sigma_compact_space Œ±] {f : Œ± ‚Üí set Œ±} {s : set Œ±} (hs : is_closed s) (hf : ‚àÄ (x : Œ±), x ‚àà s ‚Üí f x ‚àà nhds_within x s) : ‚àÉ (t : set Œ±) (H : t ‚äÜ s), t.countable ‚àß s ‚äÜ ‚ãÉ (x : Œ±) (H : x ‚àà t), f x
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (l : list Œ±) : ordnode Œ±
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [add_zero_class Œ±] [add_zero_class Œ≤] (f : Œ± ‚Üí+o Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : Œ± ‚Üí+o Œ≤
(n : Type u_3) (R : Type u_7) (Œ± : Type v) [decidable_eq n] [semiring R] [add_comm_monoid Œ±] [module R Œ±] : (n ‚Üí Œ±) ‚Üí‚Çó[R] matrix n n Œ±
 : expr ‚Üí tactic omega.nat.exprterm
{R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G ‚Üí* R) [decidable (f = 1)] : finset.univ.sum (Œª (g : G), ‚áëf g) = ite (f = 1) ‚Üë(fintype.card G) 0
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] {C : Type u} [category_theory.category C] (F : J √ó K ‚•§ C) [category_theory.limits.has_limits_of_shape J C] [category_theory.limits.has_colimits_of_shape K C] (j : J) (k : K) : category_theory.limits.colimit.Œπ (category_theory.curry.obj (category_theory.prod.swap K J ‚ãô F) ‚ãô category_theory.limits.lim) k ‚â´ category_theory.limits.colimit_limit_to_limit_colimit F ‚â´ category_theory.limits.limit.œÄ (category_theory.curry.obj F ‚ãô category_theory.limits.colim) j = category_theory.limits.limit.œÄ ((category_theory.curry.obj (category_theory.prod.swap K J ‚ãô F)).obj k) j ‚â´ category_theory.limits.colimit.Œπ ((category_theory.curry.obj F).obj j) k
(c : cardinal) : cardinal
{b : ‚Ñù} (a X : ‚Ñù) (h2 : 0 < b) : ‚à´ (x : ‚Ñù) in a..X, real.exp (-b * x) ‚â§ real.exp (-b * a) / b
{Œ± : Sort u_1} [h : nonempty Œ±] : inhabited Œ±
(n : ‚Ñï) : linarith.sum
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} (a : P.A) (f : P.last.B a ‚Üí P.last.W) (f' : typevec.arrow (P.W_path (W_type.mk a f)) Œ±) : P.W Œ±
{F : Type u_1} {K : Type u_2} {L : Type u_3} [field F] [field K] [field L] [algebra F K] [algebra F L] (s : finset K) : (‚àÄ (x : K), x ‚àà s ‚Üí is_integral F x ‚àß polynomial.splits (algebra_map F L) (minpoly F x)) ‚Üí nonempty (‚Ü•(algebra.adjoin F ‚Üës) ‚Üí‚Çê[F] L)
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} : category_theory.mono_over.map (ùüô X) ‚âÖ ùü≠ (category_theory.mono_over X)
(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] (r : ratfunc Fq) : with_zero (multiplicative ‚Ñ§)
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Group) : category_theory.limits.cocone F
(Œ± : Type) [reflected Œ±] (e : expr) : tactic Œ±
{X Y : Profinite} (f : ‚Ü•X ‚âÉ‚Çú ‚Ü•Y) : X ‚âÖ Y
 : expr ‚Üí expr ‚Üí tactic expr
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K‚ÇÅ K‚ÇÇ : J ‚•§ C} (F : C ‚•§ D) (h : K‚ÇÅ ‚âÖ K‚ÇÇ) [category_theory.limits.preserves_limit K‚ÇÅ F] : category_theory.limits.preserves_limit K‚ÇÇ F
 : algebraic_geometry.Scheme ‚•§ Top
(Œ± : Type u_1) (Œ≤ : Type u_2) : Œ± √ó Œ≤ ‚âÉ Œ≤ √ó Œ±
{M : Type u_3} {N : Type u_4} [has_mul M] [mul_one_class N] : has_one (M ‚Üí‚Çô* N)
(e : expr) : tactic unit
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b c : Œ±} : a - c < b ‚Üí a < b + c
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {s t : set Œ±} (hst : s ‚äÜ t) (ht : (t ‚à© function.mul_support f).finite) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)) * finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà t  s), f i)) = finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà t), f i))
{R : Type u_1} [semiring R] (x y : dual_number R) : (x * y).snd = triv_sq_zero_ext.fst x * triv_sq_zero_ext.snd y + triv_sq_zero_ext.fst y * triv_sq_zero_ext.snd x
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) (j : J) : F.obj j ‚ü∂ Mon.colimits.colimit F
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} {Œ∫ : Type u_1} [Œ† (i : Œπ), has_zero (Œ≤ i)] (h : Œπ ‚âÉ Œ∫) : (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚âÉ Œ†‚ÇÄ (k : Œ∫), Œ≤ (‚áë(h.symm) k)
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] {a u' : Œ±} {s : set Œ±} (hu' : a < u') : s ‚àà nhds_within a (set.Ioi a) ‚Üî ‚àÉ (u : Œ±) (H : u ‚àà set.Ioi a), set.Ioo a u ‚äÜ s
{Œ≤ : Type u_4} [linear_order Œ≤] [no_max_order Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : filter.tendsto u filter.at_top filter.at_top) : ‚àÉ·∂† (n : ‚Ñï) in filter.at_top, ‚àÄ (k : ‚Ñï), k < n ‚Üí u k < u n
{Œì‚ÇÄ : Type u_1} [linear_ordered_comm_group_with_zero Œì‚ÇÄ] (Œ≥ : Œì‚ÇÄÀ£) : {x : Œì‚ÇÄ | x < ‚ÜëŒ≥} ‚àà nhds 0
{t : Type u ‚Üí Type u ‚Üí Type u} [bitraversable t] {Œ≤ : Type u} {F : Type u ‚Üí Type u} [applicative F] {Œ± Œ±' : Type u} (f : Œ± ‚Üí F Œ±') : t Œ≤ Œ± ‚Üí F (t Œ≤ Œ±')
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] (F : category_theory.lax_braided_functor C D) : CommMon_ C ‚•§ CommMon_ D
{Œ≤ : Type u_2} {f g : Œ≤ ‚Üí nnreal} {r : nnreal} (hgf : ‚àÄ (b : Œ≤), g b ‚â§ f b) (hfr : has_sum f r) : ‚àÉ (p : nnreal) (H : p ‚â§ r), has_sum g p
{M : Type u} [comm_monoid M] {N : Type u} [comm_monoid N] (F : M ‚Üí* N) : category_theory.braided_functor (category_theory.discrete M) (category_theory.discrete N)
 : Twop ‚•§ Twop
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) {M' : Type u_13} [add_comm_monoid M'] [module R M'] (B' : bilin_form R M') (f : M ‚Üí‚Çó[R] M') (g : M' ‚Üí‚Çó[R] M) : Prop
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] (F : C ‚•§ D) : category_theory.with_initial C ‚•§ category_theory.with_initial D
{B : Type u_1} {E : B ‚Üí Type u_2} {B' : Type u_3} (f : B' ‚Üí B) : bundle.total_space (f *·µñ E) ‚Üí bundle.total_space E
{Fq : Type u_1} [field Fq] [fintype Fq] : absolute_value (polynomial Fq) ‚Ñ§
(c : turing.to_partrec.code) (k k' : turing.to_partrec.cont) (v : list ‚Ñï) : turing.to_partrec.step_normal c (k.then k') v = (turing.to_partrec.step_normal c k v).then k'
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {Œπ : Type u_1} (c : complex_shape Œπ) {Œπ' : Type u_2} (c' : complex_shape Œπ') : homological_complex.flip V c' c ‚ãô homological_complex.flip V c c' ‚âÖ ùü≠ (homological_complex (homological_complex V c') c)
{C : Type u} [category_theory.category C] {f g : category_theory.arrow C} [category_theory.limits.has_image f.hom] [category_theory.limits.has_image g.hom] (sq : f ‚ü∂ g) [category_theory.limits.has_image_map sq] : category_theory.limits.image_map sq
{R : Type u_1} [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] : free_algebra R M ‚Üí‚Çê[R] tensor_algebra R M
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] [category_theory.limits.preserves_colimits_of_shape J ‚ÜëT] (D : J ‚•§ T.algebra) [category_theory.limits.has_colimit (D ‚ãô T.forget)] : category_theory.limits.has_colimit D
{R : Type u_1} {Œπ : Type u_4} [linear_ordered_field R] [fintype Œπ] {f : Œπ ‚Üí R} (hf : f ‚àà std_simplex R Œπ) (x : Œπ) : f x ‚àà set.Icc 0 1
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] (œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ) (œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ) [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] : ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ
(G : Type u_1) [subtraction_comm_monoid G] : G ‚âÉ+ G
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} [category_theory.limits.has_equalizer f g] [category_theory.epi (category_theory.limits.equalizer.Œπ f g)] : f = g
{Œ± : Type u} [pseudo_metric_space Œ±] (x : Œ±) : emetric.ball x ‚ä§ = set.univ
{Œ± : Type u_1} (p : pmf Œ±) {s t : set Œ±} (h : s ‚à© p.support ‚äÜ t) : ‚áë(p.to_outer_measure) s ‚â§ ‚áë(p.to_outer_measure) t
(L : first_order.language) (M : Type w) [L.Structure M] : L.equiv M M
{R : Type u_1} [comm_ring R] (S : submonoid R) (P : Type u_2) [comm_ring P] [algebra R P] : Type u_2
{K : Type u_1} {v : K} {n : ‚Ñï} [linear_ordered_field K] [floor_ring K] : 0 ‚â§ (generalized_continued_fraction.of v).denominators n
{V : Type (u+1)} [category_theory.large_category V] {G : Group} (A : Action V (Mon.of ‚Ü•G)) : G ‚ü∂ Group.of (category_theory.Aut A.V)
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ≤] [measurable_space Œ±] (f : Œ± ‚Üí Œ≤) : measure_theory.measure Œ± ‚Üí‚Çó[ennreal] measure_theory.measure Œ≤
(Œ± : Type u_1) [non_unital_non_assoc_semiring Œ±] : Œ± ‚Üí‚Çô+* Œ±
(C : Type u) [category_theory.category C] : Prop
{n : with_top ‚Ñï} {ùïÇ : Type u_6} [is_R_or_C ùïÇ] {F' : Type u_8} [normed_group F'] [normed_space ùïÇ F'] {f : ùïÇ ‚Üí F'} {x : ùïÇ} (hf : cont_diff ùïÇ n f) (hn : 1 ‚â§ n) : has_strict_deriv_at f (deriv f x) x
(Œ± : Type u) [topological_space Œ±] : Prop
{p q x : ‚Ñù} (h : liouville_with p x) (hle : q ‚â§ p) : liouville_with q x
{V : Type u} {G : simple_graph V} (G' : G.subgraph) : Prop
{Œ± : Type u_1} [add_monoid Œ±] (s : multiset Œ±) (comm : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí add_commute x y) : Œ±
(E : Sort u_1) (Œ± : out_param (Sort u_2)) (Œ≤ : out_param (Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3) (imax u_1 u_3 u_2))
{Œ± : Type u_1} {Œ¥ : Œ± ‚Üí Type u_2} [decidable_eq Œ±] (s : finset Œ±) (t : Œ† (a : Œ±), finset (Œ¥ a)) : finset (Œ† (a : Œ±), a ‚àà s ‚Üí Œ¥ a)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u_1} [category_theory.category E] (F : C ‚•§ D) (G : D ‚•§ E) (hG : category_theory.is_equivalence G) (hGF : category_theory.is_equivalence (F ‚ãô G)) : category_theory.is_equivalence F
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] {F : intermediate_field K L} (E : intermediate_field ‚Ü•F L) : intermediate_field K L
(cl : name) : tactic (list name)
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] : wseq Œ± ‚Üí wseq Œ±
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (s : set P) : p ‚àà s ‚Üí p ‚àà span_points k s
{C : Type u} [category_theory.category C] {X Y Z X' Y' Z' : C} (iX : X ‚âÖ X') (iY : Y ‚âÖ Y') (iZ : Z ‚âÖ Z') {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} {f' : X' ‚ü∂ Y'} {g' : X' ‚ü∂ Z'} (wf : iX.hom ‚â´ f' = f ‚â´ iY.hom) (wg : iX.hom ‚â´ g' = g ‚â´ iZ.hom) : category_theory.limits.span f g ‚âÖ category_theory.limits.span f' g'
{key value : Type} [has_lt key] [decidable_rel has_lt.lt] [has_mul value] (b : value) (m : native.rb_map key value) : native.rb_map key value
{Œ± : Type u_1} [linear_order Œ±] (pred : Œ± ‚Üí Œ±) (hle_pred_iff : ‚àÄ {a b : Œ±}, a ‚â§ pred b ‚Üî a < b) : pred_order Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {l : filter Œ±} (r : Œ≤ ‚Üí Œ≥ ‚Üí Prop) (f : l.germ Œ≤) (g : l.germ Œ≥) : Prop
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F : J ‚•§ C} [category_theory.limits.has_colimit F] (c : category_theory.limits.cocone F) : category_theory.limits.colimit.cocone F ‚ü∂ c
{Œ± : Type u_1} [complete_lattice Œ±] [is_compactly_generated Œ±] {a : Œ±} {s : set Œ±} : a ‚äì has_Sup.Sup s = ‚®Ü (t : finset Œ±) (H : ‚Üët ‚äÜ s), a ‚äì t.sup id
{C : Type u_1} [category_theory.category C] (J : category_theory.grothendieck_topology C) : category_theory.cover_lifting J J (ùü≠ C)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.limits.preserves_colimits_of_size F] : category_theory.limits.preserves_colimits_of_size G
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] (a : Œ±) : option Œ±
{Œπ : Type u_1} {X : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), topological_space (X i)] {as bs : Œ† (i : Œπ), X i} (i : Œπ) (paths : Œ† (i : Œπ), path.homotopic.quotient (as i) (bs i)) : path.homotopic.proj i (path.homotopic.pi paths) = paths i
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ‚Ñù P) : t.orthocenter = 3 ‚Ä¢ (finset.centroid ‚Ñù finset.univ t.points -·µ• affine.simplex.circumcenter t) +·µ• affine.simplex.circumcenter t
{C : Type u‚ÇÅ} [category_theory.category C] (G : category_theory.comonad C) : G.forget ‚ä£ G.cofree
(R : Type u) (X : Type v) [comm_ring R] : free_non_unital_non_assoc_algebra R X ‚Üí free_non_unital_non_assoc_algebra R X ‚Üí Prop
{Œì : Type u_4} [group Œì] {T : Type u_5} [topological_space T] [mul_action Œì T] [t2_space T] [locally_compact_space T] [has_continuous_const_smul Œì T] [properly_discontinuous_smul Œì T] : t2_space (quotient (mul_action.orbit_rel Œì T))
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) (x : E) : formal_multilinear_series ùïú E F
{R' : Type u_1} {Œ± : Type u_2} [semiring R'] [has_zero Œ±] [mul_action_with_zero R' Œ±] (S : subsemiring R') : mul_action_with_zero ‚Ü•S Œ±
{G : Type w} [topological_space G] [has_neg G] [has_continuous_neg G] {Œπ : Type u_1} : has_continuous_neg (Œπ ‚Üí G)
 : complete_space Gromov_Hausdorff.GH_space
{m n : ‚Ñï} (f : fin2 m ‚Üí fin2 n) (k : ‚Ñï) : fin2 (m + k) ‚Üí fin2 (n + k)
{Œ± : Type u_1} [has_lt Œ±] {a b : Œ±} (h : a < b) : ¬¨a ‚ãñ b ‚Üí (‚àÉ (c : Œ±), a < c ‚àß c < b)
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] (G : C ‚•§ D) (U : D) : category_theory.sieve U
{Œ± : Type u_1} {P : Œ± ‚Üí Prop} (Œì : Type u_2) [fintype Œì] (f : Œì ‚Üí Œ±) (inj : function.injective f) (mem : ‚àÄ (x : Œì), P (f x)) : derive_fintype.finset_in P
{Œπ : Type u_1} [decidable_eq Œπ] {Œ± : Œπ ‚Üí Type u_2} [S : Œ† (i : Œπ), setoid (Œ± i)] (l : list Œπ) : (Œ† (i : Œπ), i ‚àà l ‚Üí quotient (S i)) ‚Üí quotient pi_setoid
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ± ‚Üí Œ≥} (hf : continuous f) : continuous (Œª (x : Œ± √ó Œ≤), f x.fst)
 : Type u ‚âå category_theory.SheafOfTypes category_theory.types_grothendieck_topology
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [rŒ± : non_unital_non_assoc_semiring Œ±] [rŒ≤ : non_unital_non_assoc_semiring Œ≤] {rŒ≥ : non_unital_non_assoc_semiring Œ≥} {Œ¥ : Type u_1} {rŒ¥ : non_unital_non_assoc_semiring Œ¥} (f : Œ± ‚Üí‚Çô+* Œ≤) (g : Œ≤ ‚Üí‚Çô+* Œ≥) (h : Œ≥ ‚Üí‚Çô+* Œ¥) : (h.comp g).comp f = h.comp (g.comp f)
(Œì‚ÇÄ : Type u_1) [linear_ordered_comm_group_with_zero Œì‚ÇÄ] : directed ge (Œª (Œ≥‚ÇÄ : Œì‚ÇÄÀ£), filter.principal {Œ≥ : Œì‚ÇÄ | Œ≥ < ‚ÜëŒ≥‚ÇÄ})
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] {s : set V} [nonempty ‚Ü•s] [fintype ‚Ü•s] (lin_ind : linear_independent K coe) (card_eq : s.to_finset.card = finite_dimensional.finrank K V) : basis ‚Ü•s K V
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] {A : Type u_2} [semiring A] [algebra R A] : {f // ‚àÄ (x y : M), ‚áëf x * ‚áëf y = 0} ‚âÉ (triv_sq_zero_ext R M ‚Üí‚Çê[R] A)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} [category_theory.limits.has_zero_object V] [category_theory.limits.has_images V] (C : homological_complex V c) (j : Œπ) : category_theory.subobject (C.X j)
{R : Type u_1} [ring R] : R ‚Üí power_series R ‚Üí power_series R
{Œ± : Type} [preorder Œ±] [bounded_random Œ±] (x y : Œ±) (p : x ‚â§ y) : io ‚Ü•(set.Icc x y)
(n : ‚Ñï) {a : ‚Ñù} (h : real.sqrt_two_add_series (‚Üë0 / ‚Üë1) n ‚â§ 2 - (a / 2 ^ (n + 1)) ^ 2) : a < real.pi
{Œ± : Type u} : computation Œ± ‚Üí Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F F' : C ‚•§ D} {G G' : D ‚•§ C} (adj1 : F ‚ä£ G) (adj2 : F' ‚ä£ G') (r : G ‚âÖ G') : F ‚âÖ F'
(X : algebraic_geometry.LocallyRingedSpace) (r : ‚Ü•(algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X))) : topological_space.opens ‚Ü•X
{Œ± : Type u_1} [ring Œ±] : ring_topology Œ± ‚Ü™o add_group_topology Œ±
(f : stieltjes_function) : measure_theory.measure ‚Ñù
{Œ± : Type u_8} [add_comm_monoid Œ±] : Œ± √ó Œ± ‚Üí+ Œ±
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] : add_torsor (P1 ‚Üí·µÉ[k] V2) (P1 ‚Üí·µÉ[k] P2)
{Œ± : Type u_1} (x : Œ±) : functor.const Œ± punit
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {X : C} (p : X ‚ü∂ X) (hp : p ‚â´ p = p) : (ùüô X - p) ‚â´ (ùüô X - p) = ùüô X - p
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X : C) : Type (max u v)
{X Y : algebraic_geometry.LocallyRingedSpace} (f g : X ‚ü∂ Y) : algebraic_geometry.LocallyRingedSpace
{Œ± : Type u_1} [denumerable Œ±] : Œ± √ó Œ± ‚âÉ Œ±
(n : ‚Ñï) : surreal
{G : Type u_1} [has_mul G] : G ‚Üí G ‚Üí G
 : tactic.ring_exp.ex tactic.ring_exp.ex_type.sum ‚Üí tactic.ring_exp.ex tactic.ring_exp.ex_type.sum ‚Üí tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum)
{R : Type u_1} [comm_semiring R] {n : Type w} [decidable_eq n] [fintype n] : matrix n n (polynomial R) ‚âÉ‚Çê[R] polynomial (matrix n n R)
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {s t : set Œ±} (hst : s ‚äÜ t) (ht : t.finite) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)) + finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà t  s), f i)) = finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà t), f i))
(attr : thunk norm_cast.norm_cast_attr_ty) (names : list name) : tactic norm_cast.norm_cast_cache
{Œ± : Type u_1} {Œ≤ : Type u_4} [partial_order Œ±] [partial_order Œ≤] {u : Œ≤ ‚Üí Œ±} (l : lower_adjoint u) : l.closed = set.range (u ‚àò ‚áël)
{G : Type u} [group G] [fintype G] {p n : ‚Ñï} [hp : fact (nat.prime p)] (hdvd : p ^ (n + 1) ‚à£ fintype.card G) {H : subgroup G} (hH : fintype.card ‚Ü•H = p ^ n) : p ^ (n + 1) ‚à£ fintype.card ‚Ü•(H.normalizer)
 : tactic unit
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ‚ü∂ Y} (s : category_theory.limits.cofork f 0) : s ‚âÖ category_theory.limits.cofork.of_œÄ s.œÄ _
{E : Type u_1} {Œ≤ : Type u_2} [add_comm_group E] [topological_space E] [module ‚Ñù E] [topological_add_group E] [has_continuous_smul ‚Ñù E] [ordered_add_comm_group Œ≤] [module ‚Ñù Œ≤] [ordered_smul ‚Ñù Œ≤] {s : set E} {f : E ‚Üí Œ≤} {a : E} (a_in_s : a ‚àà s) (h_localmax : is_local_max_on f s a) (h_conc : concave_on ‚Ñù s f) : is_max_on f s a
{Œ± : Type u_2} {Œ≤ : Type u_3} [decidable_eq Œ≤] [monoid Œ±] [monoid Œ≤] [mul_distrib_mul_action Œ± Œ≤] : mul_distrib_mul_action Œ± (finset Œ≤)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {x : E} {n : ‚Ñï} : iterated_fderiv ùïú (n + 1) f x = (‚áë(continuous_multilinear_curry_right_equiv' ùïú n E F) ‚àò iterated_fderiv ùïú n (Œª (y : E), fderiv ùïú f y)) x
{n : ‚Ñï} (x y : bitvec n) : bitvec n
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) : category_theory.limits.preserves_limits_of_size G
{Œ± : Type} {ds‚ÇÅ ds‚ÇÇ : list ‚Ñï} [s : has_mul Œ±] (x : holor Œ± ds‚ÇÅ) (y : holor Œ± ds‚ÇÇ) : holor Œ± (ds‚ÇÅ ++ ds‚ÇÇ)
{Œπ : Type u_1} {R : Type u_2} [comm_ring R] [linear_order Œπ] (s : finset Œπ) (f g : Œπ ‚Üí R) : s.prod (Œª (i : Œπ), f i - g i) = s.prod (Œª (i : Œπ), f i) - s.sum (Œª (i : Œπ), g i * (finset.filter (Œª (_x : Œπ), _x < i) s).prod (Œª (j : Œπ), f j - g j) * (finset.filter (Œª (j : Œπ), i < j) s).prod (Œª (j : Œπ), f j))
{Œ± : Type u} [monoid Œ±] {r : Œ±} (hr : invertible r) (s : Œ±) (hs : s = r) : invertible s
(k : turing.partrec_to_TM2.K') : turing.partrec_to_TM2.stmt' ‚Üí turing.partrec_to_TM2.stmt'
{Œ± : Type u} [uniform_space Œ±] {f : filter Œ±} (hf : cauchy f) {U : ‚Ñï ‚Üí set (Œ± √ó Œ±)} (U_mem : ‚àÄ (n : ‚Ñï), U n ‚àà uniformity Œ±) (n : ‚Ñï) : {s // ‚àÉ (_x : s ‚àà f), s √óÀ¢ s ‚äÜ U n}
{Œ± : Type u_1} [metric_space Œ±] {s : set Œ±} (hs : is_open s) (h's : s·∂ú.nonempty) : polish_space.complete_copy s ‚âÉ‚Çú ‚Ü•s
(p : ‚Ñï) [fact (nat.prime p)] (a : ‚Ñ§) : zmod.legendre_sym p a = 0 ‚Üî ‚Üëa = 0
(Œ± : Type u) [has_le Œ±] : Type u
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) {X : C} (R : category_theory.sieve (F.obj X)) : category_theory.sieve X
(i j : ‚Ñï) (h : j + 1 = i) : algebraic_topology.dold_kan.c.rel i j
{Œ± : Type u} : computation Œ± ‚Üí ‚Ñï ‚Üí option Œ±
(Œ± : Type u) : Type u
{Œ± : Type u_3} {Œ≤ : Type u_4} [has_inf Œ±] [has_top Œ±] [has_inf Œ≤] [has_top Œ≤] (f : inf_top_hom Œ± Œ≤) : top_hom Œ± Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] : has_coe_to_fun C(Œ±, Œ≤) (Œª (_x : C(Œ±, Œ≤)), Œ± ‚Üí Œ≤)
{ùïÜ : Type u_1} {Œ± : Type u_3} {Œ≤ : Type u_4} [preorder ùïÜ] [preorder Œ±] [preorder Œ≤] [grade_max_order ùïÜ Œ≤] (f : Œ± ‚Üí Œ≤) (hf : strict_mono f) (hcovby : ‚àÄ (a b : Œ±), a ‚ãñ b ‚Üí f a ‚ãñ f b) (hmax : ‚àÄ (a : Œ±), is_max a ‚Üí is_max (f a)) : grade_max_order ùïÜ Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} (f : Y ‚ü∂ Z) (P : category_theory.ProjectiveResolution Y) (Q : category_theory.ProjectiveResolution Z) : P.complex ‚ü∂ Q.complex
(R : Type u_1) {Œ± : Type u_2} (G : simple_graph Œ±) [has_zero R] [has_one R] : matrix Œ± (sym2 Œ±) R
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q R S : C} {f : P ‚ü∂ Q} {g : P ‚ü∂ R} {h : Q ‚ü∂ S} {k : R ‚ü∂ S} [hn : category_theory.normal_epi f] (comm : f ‚â´ h = g ‚â´ k) (t : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk h k comm)) : category_theory.normal_epi k
(Fq F : Type) [field Fq] [field F] [algebra (ratfunc Fq) F] : Prop
{Œ± : Type u_1} [metric_space Œ±] {K : nnreal} {f : Œ± ‚Üí Œ±} (hf : contracting_with K f) [nonempty Œ±] [complete_space Œ±] : function.is_fixed_pt f (contracting_with.fixed_point f hf)
 : first_order.language.order.sentence
{Œ± : Type u_1} [has_mul Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] {a b c d : Œ±} (h‚ÇÅ : a < b) (h‚ÇÇ : c < d) : a * c < b * d
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f g : Œ± ‚Üí M} (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) : finprod (Œª (i : Œ±), f i * g i) = finprod (Œª (i : Œ±), f i) * finprod (Œª (i : Œ±), g i)
 : omega.nat.preterm ‚Üí omega.term
{Œ± : Type u_1} {o : option Œ±} : decidable (o = option.none)
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} : 0 ‚â§ metric.Hausdorff_dist s t
(key : interactive.parse lean.parser.cur_pos) (slow_and_accurate : interactive.parse (optional (lean.parser.tk "?"))) (use_iota_eqn : interactive.parse (optional (lean.parser.tk "!"))) (no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (locat : interactive.parse interactive.types.location) (cfg : interactive.parse (optional tactic.struct_inst)) : tactic unit
{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [decidable_eq V] (n : ‚Ñï) (u v : V) : finset (G.walk u v)
{R : Type u_2} {M‚ÇÅ : Type u_3} {M‚ÇÇ : Type u_4} {N‚ÇÅ : Type u_5} {N‚ÇÇ : Type u_6} [ring R] [add_comm_group M‚ÇÅ] [add_comm_group M‚ÇÇ] [add_comm_group N‚ÇÅ] [add_comm_group N‚ÇÇ] [module R M‚ÇÅ] [module R M‚ÇÇ] [module R N‚ÇÅ] [module R N‚ÇÇ] {Q‚ÇÅ : quadratic_form R M‚ÇÅ} {Q‚ÇÇ : quadratic_form R M‚ÇÇ} {Q‚ÇÅ' : quadratic_form R N‚ÇÅ} {Q‚ÇÇ' : quadratic_form R N‚ÇÇ} (e‚ÇÅ : Q‚ÇÅ.isometry Q‚ÇÅ') (e‚ÇÇ : Q‚ÇÇ.isometry Q‚ÇÇ') : (Q‚ÇÅ.prod Q‚ÇÇ).isometry (Q‚ÇÅ'.prod Q‚ÇÇ')
{K : Type u} [field K] (s : subfield K) {l : list K} : (‚àÄ (x : K), x ‚àà l ‚Üí x ‚àà s) ‚Üí l.sum ‚àà s
(Œ± : Type u) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (u : E) {v : E} (hv : v ‚àà (submodule.span ùïú {u})·óÆ) : has_inner.inner u v = 0
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {K : J ‚•§ C} {F G : C ‚•§ D} (h : F ‚âÖ G) {c : category_theory.limits.cone K} (t : category_theory.limits.is_limit (F.map_cone c)) : category_theory.limits.is_limit (G.map_cone c)
{R : Type u_1} {a : R} [cancel_monoid_with_zero R] [nontrivial R] : is_regular a ‚Üî a ‚â† 0
{Œ± : Type u} [pseudo_metric_space Œ±] : has_dist (uniform_space.completion Œ±)
{G : Type u_1} [add_group G] : has_bot (add_subgroup G)
(Œ± : Type u_1) [fintype Œ±] [category_theory.small_category Œ±] [category_theory.fin_category Œ±] : category_theory.fin_category.as_type Œ± ‚âå category_theory.fin_category.obj_as_type Œ±
{m : Type u_1 ‚Üí Type u_2} [monad m] {Œ± : Sort u_3} {Œ≤ Œ≥ : Type u_1} (f : Œ± ‚Üí m Œ≤) (g : Œ≤ ‚Üí m Œ≥) (x : Œ±) : m Œ≥
(note_name note : string) : tactic unit
 : expr ‚Üí ‚Ñï ‚Üí bool
{n m : ‚Ñï} {F : typevec n ‚Üí Type u_1} {G : fin2 n ‚Üí typevec m ‚Üí Type u} {Œ± : typevec m} (x : F (Œª (i : fin2 n), G i Œ±)) : mvqpf.comp F G Œ±
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {a : Œ±} {s : set Œ±} (f : Œ± ‚Üí M) (h : a ‚àâ s) (hs : (s ‚à© function.support f).finite) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà has_insert.insert a s), f i)) = f a + finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i))
{Œ± : Type u} (x : Œ±) : free_comm_ring Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (e : F ‚âÖ G) : category_theory.is_equivalence F ‚âÉ category_theory.is_equivalence G
{Œ± : Type u_1} {n : Type u_4} [has_zero Œ±] [decidable_eq n] {A : matrix n n Œ±} (h : A.is_diag) : matrix.diagonal A.diag = A
{R : Type u_1} [comm_ring R] [is_domain R] {f : polynomial R} {P : ideal R} (hP : P.is_prime) (hfl : f.leading_coeff ‚àâ P) (hfP : ‚àÄ (n : ‚Ñï), ‚Üën < f.degree ‚Üí f.coeff n ‚àà P) (hfd0 : 0 < f.degree) (h0 : f.coeff 0 ‚àâ P ^ 2) (hu : f.is_primitive) : irreducible f
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddCommGroup) : category_theory.limits.is_colimit (AddCommGroup.filtered_colimits.colimit_cocone F)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (e : local_homeomorph Œ± Œ≤) (e' : local_homeomorph Œ≤ Œ≥) (h : e.to_local_equiv.target = e'.to_local_equiv.source) : local_homeomorph Œ± Œ≥
(C : Type u‚ÇÅ) [category_theory.category C] : category_theory.core C ‚•§ C
 : expr ‚Üí expr ‚Üí tactic expr
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) {J : Type u} [category_theory.category J] {K : J ‚•§ D} : F.op ‚ãô (category_theory.cones J D).obj K ‚âÖ (category_theory.cones J C).obj (K ‚ãô G)
{a b : ‚Ñï} (h : a = b) : bitvec a ‚Üí bitvec b
(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : Type u_2
{Œ± : Type u} (s t : set Œ±) [fintype ‚Ü•t] [decidable_pred (Œª (_x : Œ±), _x ‚àà s)] : fintype ‚Ü•(s ‚à© t)
{Œ≤ : Type u} {Œ± : Type v} [add_comm_monoid Œ≤] (s : finset Œ±) (f : Œ± ‚Üí Œ≤) : Œ≤
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] {module_M : module R M} {module_M‚ÇÇ : module R‚ÇÇ M‚ÇÇ} {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] (hf‚ÇÅ : function.injective ‚áëf) (hf‚ÇÇ : function.surjective ‚áëf) : M ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x : Œ±} (h : s.nonempty) : emetric.inf_edist x s ‚â† ‚ä§
(Œ± : Type u_1) (Œπ : Type u_2) : Type (max u_1 u_2)
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (s : subsemigroup M) (t : subsemigroup N) : subsemigroup (M √ó N)
{t t' : Type u ‚Üí Type u} (eqv : Œ† (Œ± : Type u), t Œ± ‚âÉ t' Œ±) [functor t] : functor t'
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.limits.reflects_colimits_of_size F] : category_theory.limits.reflects_colimits_of_size G
(t : Type u ‚Üí Type u ‚Üí Type u) : Type (u+1)
(tac : expr ‚Üí tactic (expr √ó expr)) (hs : list expr) (tgt : bool) : tactic bool
{Œ± : Type u_1} {Œ≤ : Type u_2} (t : Œ±) (ts : list Œ±) (r : list Œ≤) : list Œ± ‚Üí (list Œ± ‚Üí Œ≤) ‚Üí list Œ± √ó list Œ≤
(Œ± : Type u_1) [partial_order Œ±] : PartialOrder
{V : Type u} {G : simple_graph V} (G' : G.subgraph) : simple_graph ‚Ü•(G'.verts)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : has_dist.dist p3 p2 ‚â† 0
{m : Type u_2} {n : Type u_3} {Œ± : Type v} (M : matrix m n Œ±) : matrix n m Œ±
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [module ùïú E] [module ùïú Œ≤] [linear_order E] {s : set E} {f : E ‚Üí Œ≤} (hs : convex ùïú s) (hf : ‚àÄ ‚¶Éx y : E‚¶Ñ, x ‚àà s ‚Üí y ‚àà s ‚Üí x < y ‚Üí ‚àÄ ‚¶Éa b : ùïú‚¶Ñ, 0 < a ‚Üí 0 < b ‚Üí a + b = 1 ‚Üí a ‚Ä¢ f x + b ‚Ä¢ f y < f (a ‚Ä¢ x + b ‚Ä¢ y)) : strict_concave_on ùïú s f
{Œ± : Type u} [decidable_eq Œ±] [fintype Œ±] (f : equiv.perm Œ±) : trunc {l // l.prod = f ‚àß ‚àÄ (g : equiv.perm Œ±), g ‚àà l ‚Üí g.is_swap}
{R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] (abv : absolute_value R ‚Ñ§) {Œπ : Type u_5} [decidable_eq Œπ] [fintype Œπ] (bS : basis Œπ R S) : ‚Ñ§
{G : Type u‚ÇÇ} (k : Type u_1) (A : Type u_2) [comm_semiring k] [semiring A] [algebra k A] [add_monoid G] {H : Type u_3} {F : Type u_4} [add_monoid H] [add_monoid_hom_class F G H] (f : F) : add_monoid_algebra A G ‚Üí‚Çê[k] add_monoid_algebra A H
 : prime_multiset ‚Üí+ multiset ‚Ñï+
{M : Type u_1} [add_zero_class M] {N : Type u_2} {S : Type u_3} [add_zero_class N] [set_like S M] [add_submonoid_class S M] (f : M ‚Üí+ N) (s : S) : ‚Ü•s ‚Üí+ N
{M : Type u_1} [add_zero_class M] {p : M ‚Üí Prop} (x : M) {s : set M} (hs : add_submonoid.closure s = ‚ä§) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí p x) (H1 : p 0) (Hmul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x + y)) : p x
{Œ± Œ≤ : BoundedOrder} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (e : F ‚âÖ G) (hF : category_theory.is_equivalence F) : category_theory.is_equivalence G
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [uniform_space Œ±] [uniform_space Œ≤] [uniform_space Œ≥] (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : Prop
{Œπ : Type v} {o‚ÇÅ o‚ÇÇ o‚ÇÉ : category_theory.pairwise Œπ} (f : o‚ÇÅ.hom o‚ÇÇ) (g : o‚ÇÇ.hom o‚ÇÉ) : o‚ÇÅ.hom o‚ÇÉ
{Œ± : Type u_2} [add_zero_class Œ±] : add_zero_class (filter Œ±)
{Œì : Type u_1} {R : Type u_2} [partial_order Œì] [has_zero R] (a : Œì) : zero_hom R (hahn_series Œì R)
{X Y : algebraic_geometry.LocallyRingedSpace} {f : X ‚ü∂ Y} (H : algebraic_geometry.LocallyRingedSpace.is_open_immersion f) : X ‚âÖ Y.restrict _
(n : ‚Ñï) (Œ± : Type u_1) : array n Œ± ‚âÉ (fin n ‚Üí Œ±)
 : zmod 4 ‚Üí*‚ÇÄ ‚Ñ§
{n : ‚Ñï} {Œ± : typevec n} (p : (Œ±.prod Œ±).arrow (typevec.repeat n Prop)) : typevec.arrow (Œª (i : fin2 n), {x // typevec.of_repeat (p i (typevec.prod.mk i x.fst x.snd))}) (typevec.subtype_ p)
(M : Type u_1) [has_add M] : M ‚âÉ+ M
(ùïú : Type u_1) (A : Type u_2) [comm_semiring ùïú] [topological_space ùïú] [has_continuous_add ùïú] [has_continuous_const_smul ùïú ùïú] [non_unital_non_assoc_semiring A] [topological_space A] [module ùïú A] : set (weak_dual ùïú A)
{D : set ‚Ñù} (hD : convex ‚Ñù D) (hD‚ÇÇ : is_open D) {f : ‚Ñù ‚Üí ‚Ñù} (hf' : differentiable_on ‚Ñù f D) (hf'' : ‚àÄ (x : ‚Ñù), x ‚àà D ‚Üí 0 < deriv^[2] f x) : strict_convex_on ‚Ñù D f
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : C √ó C ‚•§ C
 : hole_command
{Œ± : Type u_1} [has_mul Œ±] [has_one Œ±] : list Œ± ‚Üí Œ±
 : Type
(C : Type u) [category_theory.category C] : Prop
{r p : nnreal} : ‚Üë(r - p) = ‚Üër - ‚Üëp
{p : ‚Ñï} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] : witt_vector p R ‚Üí+* ‚Ñï ‚Üí R
{G : Type u_1} [group G] (H : ‚Ñï ‚Üí subgroup G) (hH : is_descending_central_series H) (n : ‚Ñï) : lower_central_series G n ‚â§ H n
 : cc_config ‚Üí tactic cc_state
{Œ± : Type u_1} [distrib_lattice Œ±] [order_bot Œ±] [decidable_eq Œ±] {a b c : Œ±} (P : finpartition a) (hb : b ‚â† ‚ä•) (hab : disjoint a b) (hc : a ‚äî b = c) : finpartition c
(p : ‚Ñï) [p_prime : fact (nat.prime p)] (q : ‚Ñö) : padic_val_rat p q‚Åª¬π = -padic_val_rat p q
(n : ‚Ñï) : pSet.resp n ‚Üí arity Set n
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} {C‚ÇÅ C‚ÇÇ : homological_complex V c} (f : C‚ÇÅ ‚âÖ C‚ÇÇ) (i : Œπ) : C‚ÇÅ.X i ‚âÖ C‚ÇÇ.X i
{L : first_order.language} {F : Type u_1} {M : Type u_2} {N : Type u_3} [L.Structure M] [L.Structure N] [fun_like F M (Œª (_x : M), N)] [first_order.language.hom_class L F M N] : F ‚Üí L.hom M N
{ùïú : Type u} {G : Type wG} {G' : Type wG'} [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] (f : continuous_multilinear_map ùïú (Œª (i : fin 0), G) G') : G'
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤] (f : C(Œ±, Œ≤)) : filter_basis C(Œ±, Œ≤)
{X Y : Type u} [has_add X] [has_add Y] (e : X ‚âÉ+ Y) : AddMagma.of X ‚âÖ AddMagma.of Y
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ Ring SemiRing)
{R : Type u} [comm_semiring R] {A : Type v} [comm_semiring A] [algebra R A] : comm_semiring (submodule R A)
{k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] {Œπ : Type u_4} (s : finset Œπ) (p : Œπ ‚Üí V) (w : Œπ ‚Üí k) (hw : s.sum (Œª (i : Œπ), w i) = 1) : ‚áë(s.affine_combination p) w = s.sum (Œª (i : Œπ), w i ‚Ä¢ p i)
 : ‚ÑÇ ‚âÉ‚Çó[‚Ñù] ‚Ñù √ó ‚Ñù
{Œ± : Type u_1} {Œ≤ : Type u_2} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) : preorder Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : regular_expression Œ± ‚Üí regular_expression Œ≤
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) : Prop
(M : Type u_1) [mul_one_class M] (c : con M) : submonoid (M √ó M)
{Œ± : Type u_1} [has_to_format Œ±] : list Œ± ‚Üí format
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_zero_object C] [category_theory.epi f] : category_theory.limits.is_colimit (category_theory.limits.cokernel.zero_cokernel_cofork f)
(s e : expr) : tactic unit
(L : Type v) (M : Type w) [lie_ring L] [add_comm_group M] : Type (max v w)
(l : list ‚Ñï) (n : ‚Ñï) : finset ‚Ñï
{Œ± : Type} (ea : computability.fin_encoding Œ±) : turing.tm2_computable ea ea id
{Œ± : Type u} [preorder Œ±] {f : ‚Ñ§ ‚Üí Œ±} (hf : antitone f) (n : ‚Ñ§) {x : Œ±} (h1 : f (n + 1) < x) (h2 : x < f n) (a : ‚Ñ§) : f a ‚â† x
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {r t : category_theory.limits.cone F} (P : category_theory.limits.is_limit r) (i : r ‚âÖ t) : category_theory.limits.is_limit t
{Œ± : Type u_1} [Œ≤ : semi_normed_ring Œ±] : non_unital_semi_normed_ring Œ±
(Œ± : Type u_1) [add_group Œ±] [has_one Œ±] : ‚Ñ§ ‚Üí+ Œ±
{Œ± : Type u_1} [measurable_space Œ±] {f : ‚Ñï ‚Üí Œ± ‚Üí ennreal} {g : Œ± ‚Üí ennreal} (hf : ‚àÄ (i : ‚Ñï), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J ‚Üí C} (B : category_theory.limits.bicone F) : Type (max u v)
{Œ± : Type u} (f : filter (filter Œ±)) : filter Œ±
{M : Type u_1} [ordered_add_comm_monoid M] (S : add_submonoid M) : ordered_add_comm_monoid ‚Ü•S
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] (p q : submodule R E) (h : is_compl p q) : (‚Ü•p √ó ‚Ü•q) ‚âÉ‚Çó[R] E
{R : Type u} [ring R] {X‚ÇÇ : Type v} {X‚ÇÅ : Module R} [add_comm_group X‚ÇÇ] [module R X‚ÇÇ] : (‚Ü•X‚ÇÅ ‚Üí‚Çó[R] X‚ÇÇ) ‚Üí (X‚ÇÅ ‚ü∂ Module.of R X‚ÇÇ)
{M : Type u_6} {N : Type u_7} [add_zero_class M] [add_zero_class N] (f : M ‚Üí+ N) (g : N ‚Üí+ M) (h‚ÇÅ : g.comp f = add_monoid_hom.id M) (h‚ÇÇ : f.comp g = add_monoid_hom.id N) : M ‚âÉ+ N
{Œπ : Type u} {f g : Œπ ‚Üí nnreal} {A B : nnreal} {p q : ‚Ñù} (hpq : p.is_conjugate_exponent q) (hf : has_sum (Œª (i : Œπ), f i ^ p) (A ^ p)) (hg : has_sum (Œª (i : Œπ), g i ^ q) (B ^ q)) : ‚àÉ (C : nnreal), C ‚â§ A * B ‚àß has_sum (Œª (i : Œπ), f i * g i) C
{Œ± : Type u_1} {Œ≤ : Type u_2} {la : filter Œ±} {lb : filter Œ≤} {f : Œ± ‚Üí set Œ≤} : filter.tendsto f la lb.small_sets ‚Üî ‚àÄ (t : set Œ≤), t ‚àà lb ‚Üí (‚àÄ·∂† (x : Œ±) in la, f x ‚äÜ t)
(X : Bipointed) : X.hom X
(extra_lems : list tactic.simp_arg_type) (e : expr) : tactic (expr √ó expr)
{R : Type u_1} [ring R] [is_domain R] (s : subring R) : is_domain ‚Ü•s
 : linter
(R : Type u_1) [comm_ring R] [local_ring R] (q : ‚Ñï) [char_R_q : char_p R q] : q = 0 ‚à® is_prime_pow q
 : star_ring ‚Ñù
{F : Type} [comm_semiring F] (q : ‚Ñï) (f g : polynomial F) : Prop
 : Type (u+1)
(R : Type u_1) [comm_semiring R] {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] (m : M) (n : N) : tensor_product R M N
{Œ± : Type u} {Œ≤ : Type v} (f : Œ≤ ‚Üí Œ± ‚äï Œ≤) (b : Œ≤) : computation Œ±
{n : ‚Ñï} : equiv.perm (fin n.succ) ‚âÉ fin n.succ √ó equiv.perm (fin n)
{R : Type u_1} [comm_semiring R] [topological_space R] [topological_semiring R] : polynomial R ‚Üí‚Çê[R] C(R, R)
(Œ± : Type u_1) : computation Œ±
{Œ± : Type} : (tactic.instance_cache ‚Üí tactic (tactic.instance_cache √ó Œ±)) ‚Üí tactic.ring.ring_m Œ±
{M : Type u_1} [comm_monoid M] {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (x : M) (F : submonoid.localization_map.away_map x N) (y : M) (G : submonoid.localization_map.away_map (x * y) P) : N ‚Üí* P
{A : Type u_2} [add_group A] (H : add_subgroup A) : Prop
{M : Type u_1} [mul_one_class M] : add_submonoid (additive M) ‚âÉo submonoid M
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape J C] [category_theory.limits.has_colimits_of_shape K C] (G : J ‚•§ K ‚•§ C) [category_theory.limits.has_limit G] : category_theory.limits.colim.map_cone (category_theory.limits.limit.cone G) ‚ü∂ category_theory.limits.limit.cone (G ‚ãô category_theory.limits.colim)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {X : C} (h : category_theory.coyoneda.obj (opposite.op X) ‚ãô category_theory.ulift_functor ‚âÖ F.cocones) : category_theory.limits.is_colimit (category_theory.limits.is_colimit.of_nat_iso.colimit_cocone h)
{Œ± : Type u} {Œ≤ : Type v} (ùïú : Type u_2) [pseudo_metric_space ùïú] [topological_space Œ±] [pseudo_metric_space Œ≤] [semiring ùïú] [add_comm_monoid Œ≤] [module ùïú Œ≤] [has_bounded_smul ùïú Œ≤] [has_lipschitz_add Œ≤] (x : Œ±) : bounded_continuous_function Œ± Œ≤ ‚ÜíL[ùïú] Œ≤
(x y : pgame) : x < y ‚à® x.equiv y ‚à® y < x ‚à® x.fuzzy y
(R : Type u_1) {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] : tensor_product R A A ‚Üí‚Çó[R] A
(u : ‚Ñï ‚Üí ‚Ñù) : Prop
(R : Type u_1) (M : Type u_2) [ordered_semiring R] [ordered_add_comm_monoid M] [smul_with_zero R M] : Prop
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [nondiscrete_normed_field R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [normed_group F] [normed_space R F] [topological_space B] [topological_space (bundle.total_space E)] [Œ† (x : B), topological_space (E x)] [topological_vector_bundle R F E] (e : topological_vector_bundle.trivialization R F E) (b : B) : F ‚ÜíL[R] E b
{M : Type u_1} [mul_one_class M] (S : submonoid M) : S = ‚ä• ‚à® nontrivial ‚Ü•S
{R : Type u_1} {a : R} [monoid R] (n : ‚Ñï) (rla : is_left_regular a) : is_left_regular (a ^ n)
 : tactic unit
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) : Type (max u v)
{Œ± : Type u_1} [decidable_eq Œ±] (l : list Œ±) (x : Œ±) (h : x ‚àà l) : Œ±
{G : Type u_1} [has_add G] : G ‚Üí G ‚Üí G
(S : Type u') (R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [semiring S] [module S M] [module R M] [has_scalar S R] [is_scalar_tower S R M] : submodule R M ‚Ü™o submodule S M
(lems : interactive.parse tactic.simp_arg_list) : tactic unit
{M : Type u_1} {A : Type u_5} [has_mul M] [set_like A M] [hA : mul_mem_class A M] (S' : A) : ‚Ü•S' ‚Üí‚Çô* M
(n : ‚Ñï) (t : Type u_1) : typevec n
{G : Type u_1} [group G] (H : subgroup G) {x : G} : x ‚àà H ‚Üí x‚Åª¬π ‚àà H
(c : cardinal) : Prop
 : Type
(ùïú : Type u_1) (E : Type u_2) [ordered_semiring ùïú] [ordered_add_comm_group E] [module ùïú E] [ordered_smul ùïú E] : (convex_cone.positive_cone ùïú E).salient
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e e' : local_homeomorph Œ± Œ≤) [Œ† (x : Œ±), decidable (x ‚àà e.to_local_equiv.source)] [Œ† (y : Œ≤), decidable (y ‚àà e.to_local_equiv.target)] (Hs : disjoint e.to_local_equiv.source e'.to_local_equiv.source) (Ht : disjoint e.to_local_equiv.target e'.to_local_equiv.target) : local_homeomorph Œ± Œ≤
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s u : set E} {f : E ‚Üí F} {x : E} {n : ‚Ñï} (hu : u ‚àà nhds_within x s) (hs : unique_diff_on ùïú s) (xs : x ‚àà s) : iterated_fderiv_within ùïú n f (s ‚à© u) x = iterated_fderiv_within ùïú n f s x
{C : Type u‚ÇÅ} [category_theory.category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (S : category_theory.sieve X) : category_theory.presieve.is_sheaf_for P ‚áëS ‚Üî nonempty (category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ (category_theory.equalizer.fork_map P ‚áëS) _))
(C : Type u) [category_theory.category C] [category_theory.limits.has_images C] : Prop
(Œ± : Type u_1) [preorder Œ±] (f : closure_operator Œ±) : Œ± ‚Üí Œ±
(M : Type u_1) [add_zero_class M] (c : add_con M) : add_submonoid (M √ó M)
{X : Type u} {Y : Type v} [preorder X] [preorder Y] (f : X ‚•§ Y) : monotone f.obj
(e : environment) (s : string) (n : name) : bool
(R : Type u_1) [comm_semiring R] (X : Type u_2) : Type (max u_1 u_2)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cone F} : category_theory.limits.is_limit t ‚âÖ Œ† (s : category_theory.limits.cone F), unique (s ‚ü∂ t)
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] [ring_hom_surjective œÉ‚ÇÅ‚ÇÇ] [topological_space R‚ÇÅ] [topological_space R‚ÇÇ] [has_continuous_smul R‚ÇÅ M‚ÇÅ] [has_continuous_add M‚ÇÅ] [has_continuous_smul R‚ÇÇ M‚ÇÇ] [has_continuous_add M‚ÇÇ] {f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (hf' : dense_range ‚áëf) {s : submodule R‚ÇÅ M‚ÇÅ} (hs : s.topological_closure = ‚ä§) : (submodule.map ‚Üëf s).topological_closure = ‚ä§
(nspace : name) (id : string) : name
{Œ± : Type u_1} {Œπ : Sort u_4} {Œπ' : Sort u_5} {s : Œπ ‚Üí Œπ' ‚Üí set Œ±} : (‚ãÉ (j : Œπ'), ‚ãÇ (i : Œπ), s i j) ‚äÜ ‚ãÇ (i : Œπ), ‚ãÉ (j : Œπ'), s i j
{X : Top} (x : ‚Ü•(fundamental_groupoid.fundamental_groupoid_functor.obj X)) : ‚Ü•X
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} (a : M) : (M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí+ M‚ÇÇ
(M : Type u_1) [has_add M] : galois_insertion add_subsemigroup.closure coe
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [comm_monoid M] {g : Œ≤ ‚Üí M} (e : Œ± ‚Üí Œ≤) (he‚ÇÄ : function.bijective e) : finprod (Œª (i : Œ±), g (e i)) = finprod (Œª (j : Œ≤), g j)
{Œ≤ : Type w} {C : Type u} [category_theory.category C] [unique Œ≤] (f : Œ≤ ‚Üí C) : ‚àè f ‚âÖ f inhabited.default
(E : Type u_2) [normed_group E] [normed_space ‚Ñù E] : Type u_2
 : real.cos (real.pi / 6) ^ 2 = 3 / 4
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D·µí·µñ) [category_theory.limits.preserves_finite_colimits F] : category_theory.limits.preserves_finite_limits F.left_op
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (hash_fn : Œ± ‚Üí ‚Ñï) {n : ‚Ñï+} (data : bucket_array Œ± Œ≤ n) (a : Œ±) (b : Œ≤ a) : bucket_array Œ± Œ≤ n
{R : Type u_1} [semiring R] {M : Type u_6} [topological_space M] [add_comm_monoid M] [module R M] {N‚ÇÇ : Type u_9} [topological_space N‚ÇÇ] [add_comm_monoid N‚ÇÇ] [module R N‚ÇÇ] {N‚ÇÉ : Type u_10} [topological_space N‚ÇÉ] [add_comm_monoid N‚ÇÉ] [module R N‚ÇÉ] : (M ‚ÜíL[R] N‚ÇÇ) √ó (M ‚ÜíL[R] N‚ÇÉ) ‚âÉ (M ‚ÜíL[R] N‚ÇÇ √ó N‚ÇÉ)
{G : Type u_1} [group G] : has_bot (subgroup G)
(L : first_order.language) (M : Type w) (N : Type w') [L.Structure M] [L.Structure N] : Type (max w w')
{G : Type u_1} [add_group G] (k : set G) : add_subgroup G
(X : Top) : algebraic_geometry.SheafedSpace (category_theory.discrete punit)
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ≤ ‚Üí Œ≥} {x : Œ± √ó Œ≤} (hf : continuous_at f x.snd) : continuous_at (Œª (x : Œ± √ó Œ≤), f x.snd) x
{R : Type u_1} [comm_ring R] {A : Type u_2} [comm_ring A] [algebra R A] : has_bracket (derivation R A A) (derivation R A A)
{Œ± : Type u_1} [preorder Œ±] [decidable_rel has_lt.lt] (l : list Œ±) : with_top Œ±
 : expr ‚Üí option (linarith.ineq √ó expr)
(p : char ‚Üí Prop) [decidable_pred p] : parser char
{R : Type u} {Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} {M‚ÇÉ : Type w‚ÇÉ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [module R M‚ÇÉ] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [topological_space M‚ÇÇ] [topological_space M‚ÇÉ] (f : continuous_multilinear_map R M‚ÇÅ M‚ÇÇ) (g : continuous_multilinear_map R M‚ÇÅ M‚ÇÉ) : continuous_multilinear_map R M‚ÇÅ (M‚ÇÇ √ó M‚ÇÉ)
 : expr_lens ‚Üí tactic string
{M : Type u_1} [linear_ordered_add_comm_monoid M] {A : Type u_2} [set_like A M] [add_submonoid_class A M] (S : A) : linear_ordered_add_comm_monoid ‚Ü•S
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] {E : Type u‚ÇÉ} [category_theory.category E] [category_theory.monoidal_category E] {B : Type u‚ÇÄ} [category_theory.category B] [category_theory.monoidal_category B] (F : category_theory.monoidal_functor B C) (G : category_theory.monoidal_functor D E) : category_theory.monoidal_functor (B √ó D) (C √ó E)
{Œ± : Type u_2} {l : Type u_8} {m : Type u_9} {n : Type u_10} {p : Type u_11} [has_mul Œ±] : matrix l m Œ± ‚Üí matrix n p Œ± ‚Üí matrix (l √ó n) (m √ó p) Œ±
(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop
{S : Type u_2} [comm_ring S] {R : Type u_3} [comm_ring R] [algebra R S] {A : Type u_4} [comm_ring A] [algebra R A] [algebra S A] [is_scalar_tower R S A] {B : power_basis S A} (hB : is_integral R B.gen) [is_domain S] (hmin : minpoly S B.gen = polynomial.map (algebra_map R S) (minpoly R B.gen)) (n : ‚Ñï) (i : fin B.dim) : is_integral R (‚áë(‚áë(B.basis.repr) (B.gen ^ n)) i)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (L : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{X Y Z : Top} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : Top.of {p // ‚áëf p.fst = ‚áëg p.snd} ‚ü∂ Y
{R : Type u‚ÇÅ} [semiring R] (r : R ‚Üí R ‚Üí Prop) : Type u‚ÇÅ
(x : ‚Ü•unit_interval √ó ‚Ü•unit_interval) : ‚Ñù
{M : Type u_3} {N : Type u_4} {P : Type u_5} [mul_one_class M] [mul_one_class N] [mul_one_class P] (hnp : N ‚Üí* P) (hmn : M ‚Üí* N) : M ‚Üí* P
{Œ± : Type u_1} {Œ≤ : Type u_2} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [topological_space Œ≤] [nonempty Œ≤] [has_one Œ±] {f : Œ≤ ‚Üí Œ±} (hf : continuous f) (h : has_compact_mul_support f) : ‚àÉ (x : Œ≤), ‚àÄ (y : Œ≤), f y ‚â§ f x
{C : Type u‚ÇÅ} [category_theory.category C] (D : category_theory.glue_data C) : category_theory.limits.multispan_index C
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] {f : M ‚Üí* N} (hf : function.surjective ‚áëf) : galois_insertion (submonoid.map f) (submonoid.comap f)
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] (f : S.localization_map N) (z : N) : M √ó ‚Ü•S
{M : Type u_1} {Œ∫ : Type u_2} [add_comm_monoid M] (S : finset M) [fintype Œ∫] (C : M ‚Üí Œ∫) : ‚àÉ (a : ‚Ñï) (H : a > 0) (b : M) (c : Œ∫), ‚àÄ (s : M), s ‚àà S ‚Üí C (a ‚Ä¢ s + b) = c
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [normalization_monoid Œ±] : associates Œ± ‚Üí Œ±
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] [linear_order Œ±] {m n : ‚Ñï} {s : finset Œ±} (hm : s.card = m) (hn : s·∂ú.card = n) : fin m ‚äï fin n ‚âÉ Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [topological_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] (h : Œ± ‚âÉ‚Çú Œ≤) : Œ± ‚âÉ·µê Œ≤
(M‚ÇÄ : Type u_4) : Type u_4
{R : Type u_1} {a : R} [monoid R] {n : ‚Ñï} (n0 : 0 < n) : is_right_regular (a ^ n) ‚Üî is_right_regular a
 : declaration ‚Üí bool
(c : name) : tactic expr
{S : Type v} (s : S) {R : Type u_1} [ordered_comm_ring R] [set_like S R] [subring_class S R] : ordered_comm_ring ‚Ü•s
{Œ± : Type u_1} {n : ‚Ñï} : has_mem Œ± (sym Œ± n)
{M : Type u_1} (A : Type u_4) [monoid M] [add_monoid A] [distrib_mul_action M A] (x : M) : A ‚Üí+ A
(_x : interactive.parse (lean.parser.tk "#where")) : lean.parser unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : local_homeomorph Œ± Œ≤) {b : Œ≤} (hb : b ‚àà e.to_local_equiv.target) {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} : f =O[nhds b] g ‚Üî (f ‚àò ‚áëe) =O[nhds (‚áë(e.symm) b)] (g ‚àò ‚áëe)
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_comm_monoid M] (f : Œ± ‚Üí‚ÇÄ Œ≤ ‚Üí‚ÇÄ M) : Œ± √ó Œ≤ ‚Üí‚ÇÄ M
{Œπ Œ± : Type v} (U : Œπ ‚Üí Œ±) [complete_lattice Œ±] (o : category_theory.pairwise Œπ) : category_theory.pairwise.diagram_obj U o ‚ü∂ supr U
 : Pointed ‚•§ Twop
{C : Type u‚ÇÅ} [category_theory.category C] : category_theory.faithful category_theory.yoneda
{X : Type u_1} {Y : Type u_2} [topological_space X] [mul_one_class Y] : locally_constant X Y ‚Üí* X ‚Üí Y
{F : Type} [comm_semiring F] {q : ‚Ñï} {f : polynomial F} (hf : polynomial.has_separable_contraction q f) : ‚Ñï
(A : Type u_2) (K : Type u_3) [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] (L : Type u_4) [field L] [algebra K L] [finite_dimensional K L] [algebra A L] [is_scalar_tower A K L] : ‚àÉ (s : finset L) (b : basis ‚Ü•s K L), ‚àÄ (x : ‚Ü•s), is_integral A (‚áëb x)
(x : ‚Ñù) : ‚Ñù
{K : Type u_1} [field K] (R : valuation_subring K) (S : subring K) (h : R.to_subring ‚â§ S) : valuation_subring K
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {f : M ‚Üí* P} (x : M) : ‚áë(con.ker_lift f) ‚Üëx = ‚áëf x
 : Type (u_1+1)
{G : Type u_2} [div_inv_monoid G] : G ‚âÉ* conj_act G
{Œ± : Type u_1} {s : set (set Œ±)} (hs : is_pi_system s) : measurable_space.generate_from s = (measurable_space.dynkin_system.generate s).to_measurable_space _
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} {V‚ÇÇ : Type u_5} {P‚ÇÇ : Type u_6} [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] {p : Œπ ‚Üí P} (e : P ‚âÉ·µÉ[k] P‚ÇÇ) : affine_independent k (‚áëe ‚àò p) ‚Üî affine_independent k p
{Œ≤ : Type v} [has_zero Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_scalar ‚Ñï Œ≤] {Œ± : Type u} [non_unital_non_assoc_semiring Œ±] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_unital_non_assoc_semiring Œ≤
(env : environment) (opt : options) (levels : list name) (params : list expr) (inds : list ((name √ó expr) √ó list environment.intro_rule)) (is_meta : bool) : exceptional environment
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] {G : Type u_4} [add_comm_group G] [module R G] (g : linear_pmap R F G) (f : linear_pmap R E F) (H : ‚àÄ (x : ‚Ü•(f.domain)), ‚áëf x ‚àà g.domain) : linear_pmap R E G
(C : Type u) (X : category_theory.free_monoidal_category C) (n : (category_theory.discrete ‚àò category_theory.free_monoidal_category.normal_monoidal_object) C) : ((category_theory.free_monoidal_category.tensor_func C).obj X).obj n ‚âÖ ((category_theory.free_monoidal_category.normalize' C).obj X).obj n
{Œ± : Type u} : list (tactic Œ±) ‚Üí tactic Œ±
{R : Type u} {M : Type v} {M‚ÇÇ : Type w} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] (f : M ‚Üí‚Çó[R] M‚ÇÇ) : submodule R (M √ó M‚ÇÇ)
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] (X : Top) : (Top.presheaf.Sheaf_spaces_equiv_sheaf_sites C X).functor ‚ãô Top.sheaf.forget C X ‚âÖ category_theory.Sheaf_to_presheaf (opens.grothendieck_topology ‚Ü•X) C
(Œ± : Type u_1) [preorder Œ±] : lower_adjoint id
{Œ± : Type u_1} {Œ≤ : Type u_2} [conditionally_complete_lattice Œ±] [semilattice_sup Œ≤] {f g : Œ≤ ‚Üí Œ±} (h : antitone (Œª (n : Œ≤), set.Icc (f n) (g n))) (h' : ‚àÄ (n : Œ≤), f n ‚â§ g n) : (‚®Ü (n : Œ≤), f n) ‚àà ‚ãÇ (n : Œ≤), set.Icc (f n) (g n)
{K : Type u_1} [is_R_or_C K] : finite_dimensional ‚Ñù K
 : ‚Ñï+ ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï+ √ó ‚Ñï
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : S.normed_mk.is_quotient
(e : interactive.parse interactive.types.texpr) : tactic unit
{C : Type u} [category_theory.category C] {A B R : C} {f g : R ‚ü∂ A} {q : A ‚ü∂ B} (h : category_theory.is_kernel_pair q f g) : category_theory.is_reflexive_pair f g
 : list (list ‚Ñï) ‚Üí list turing.partrec_to_TM2.Œì'
 : (user_attribute simp_lemmas)
(e : expr) : option expr
 : Type (max (u+1) u (v+1))
{Œ± : Type u} [pseudo_emetric_space Œ±] (f : ‚Ñï ‚Üí Œ±) {m n : ‚Ñï} (h : m ‚â§ n) : has_edist.edist (f m) (f n) ‚â§ (finset.Ico m n).sum (Œª (i : ‚Ñï), has_edist.edist (f i) (f (i + 1)))
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (hf : function.injective2 f) (b : Œ≤) : function.injective (Œª (a : Œ±), f a b)
{Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±) : function.is_periodic_pt f 0 x
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] : list (sigma Œ≤) ‚Üí list (sigma Œ≤) ‚Üí list (sigma Œ≤)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) (s : finmap Œ≤) : finmap Œ≤
{Œ± : Type u_3} {Œ≤ : Type u_4} [linear_ordered_field Œ±] {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±} {r : Œ±} (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Œª (x : Œ≤), f x / r) l filter.at_top
{R S : Type u} [comm_ring R] [comm_ring S] (f : R ‚Üí+* S) : CommRing.of R ‚ü∂ CommRing.of S
{C : Type u} [category_theory.category C] (X : C) : Type (max u v)
{Œ± : Type u} (t : ordnode Œ±) : list Œ±
 : expr ‚Üí tactic expr
 : parser unit
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (s : set L) (hs : s = ‚ÜëS) : intermediate_field K L
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÇ] [has_one M‚ÇÇ] [has_pow M‚ÇÇ ‚Ñï] [monoid M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) : monoid M‚ÇÇ
{n : ‚Ñï} (Œ± : fin (n + 1) ‚Üí Type u) [Œ† (i : fin (n + 1)), has_le (Œ± i)] (i : fin (n + 1)) : (Œ† (j : fin (n + 1)), Œ± j) ‚âÉo Œ± i √ó Œ† (j : fin n), Œ± (‚áë(i.succ_above) j)
{T : Type u} [category_theory.category T] {X Y : T} {f : X ‚ü∂ Y} {P Q : T} {g : P ‚ü∂ Q} {u : X ‚ü∂ P} {v : Y ‚ü∂ Q} (w : u ‚â´ g = f ‚â´ v) : category_theory.arrow.mk f ‚ü∂ category_theory.arrow.mk g
{n : ‚Ñï} (F : typevec (n + 1) ‚Üí Type u_1) (Œ± : Type u) (Œ≤ : typevec n) : Type u_1
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) [category_theory.is_equivalence F.to_lax_monoidal_functor.to_functor] : category_theory.monoidal_functor D C
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [preorder Œ±] [preorder Œ≤] [preorder Œ≥] : (Œ± ‚Üío Œ≤ √ó Œ≥) ‚âÉo (Œ± ‚Üío Œ≤) √ó (Œ± ‚Üío Œ≥)
{R : Type u_2} {Œì‚ÇÄ : Type u_3} {Œì'‚ÇÄ : Type u_4} [linear_ordered_add_comm_monoid_with_top Œì‚ÇÄ] [linear_ordered_add_comm_monoid_with_top Œì'‚ÇÄ] [ring R] {v‚ÇÅ : add_valuation R Œì‚ÇÄ} {v‚ÇÇ : add_valuation R Œì'‚ÇÄ} {S : Type u_1} [ring S] (f : S ‚Üí+* R) (h : v‚ÇÅ.is_equiv v‚ÇÇ) : (add_valuation.comap f v‚ÇÅ).is_equiv (add_valuation.comap f v‚ÇÇ)
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] [linear_order B] [order_topology B] (e e' : topological_fiber_bundle.trivialization F proj) (a : B) (He : a ‚àà e.base_set) (He' : a ‚àà e'.base_set) (Heq : ‚àÄ (p : Z), proj p = a ‚Üí ‚áëe p = ‚áëe' p) : topological_fiber_bundle.trivialization F proj
{G : Type u_4} [normed_group G] [normed_space ‚Ñù G] {s : set G} (conv : convex ‚Ñù s) (hs : (interior s).nonempty) : unique_diff_on ‚Ñù s
{R : Type u_1} [comm_ring R] {M‚ÇÅ : Type u_4} {M‚ÇÇ : Type u_5} [add_comm_group M‚ÇÅ] [add_comm_group M‚ÇÇ] [module R M‚ÇÅ] [module R M‚ÇÇ] {Q‚ÇÅ : quadratic_form R M‚ÇÅ} {Q‚ÇÇ : quadratic_form R M‚ÇÇ} (e : Q‚ÇÅ.isometry Q‚ÇÇ) : clifford_algebra Q‚ÇÅ ‚âÉ‚Çê[R] clifford_algebra Q‚ÇÇ
 : name ‚Üí tactic name
{R : Type u_1} [has_add R] (c : R) : Prop
(S‚ÇÄ : Type u_4) : Type u_4
{Œ± : Type u} [metric_space Œ±] (x : ‚Ñï ‚Üí Œ±) (a : Œ±) : ‚Ü•(lp (Œª (n : ‚Ñï), ‚Ñù) ‚ä§)
{F : Type u ‚Üí Type u} [functor F] {Œ± : Type u} (x : F Œ±) : set Œ±
{Œì : Type u_1} [inhabited Œì] {l‚ÇÅ l‚ÇÇ : list Œì} (h : turing.blank_rel l‚ÇÅ l‚ÇÇ) : {l // turing.blank_extends l‚ÇÅ l ‚àß turing.blank_extends l‚ÇÇ l}
(n : pos_num) : tactic.ring2.horner_expr
{R : Type u} [comm_ring R] {J : Type v} [category_theory.small_category J] (F : J ‚•§ Algebra R) : category_theory.limits.is_limit (Algebra.has_limits.limit_cone F)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) [category_theory.is_equivalence F.to_lax_monoidal_functor.to_functor] : (category_theory.monoidal_inverse F).to_lax_monoidal_functor ‚äó‚ãô F.to_lax_monoidal_functor ‚ü∂ category_theory.lax_monoidal_functor.id D
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] {f : J ‚Üí C} [category_theory.limits.has_biproduct f] : finset.univ.sum (Œª (j : J), category_theory.limits.biproduct.œÄ f j ‚â´ category_theory.limits.biproduct.Œπ f j) = ùüô (‚®Å f)
{R : Type u_1} {R‚ÇÇ : Type u_2} {E‚ÇÇ : Type u_6} {F : Type u_9} [semiring R] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] [semi_normed_group E‚ÇÇ] [module R‚ÇÇ E‚ÇÇ] [normed_group F] [module R F] (f : F ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) (hfr : function.surjective ‚áëf) : F ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ
{E : Type u_2} [non_unital_normed_ring E] [star_ring E] [cstar_ring E] : normed_star_group E
{Œ± : Type u_1} [preorder Œ±] [order_top Œ±] {a : Œ±} : is_coatom a ‚Üí is_atom (‚áëorder_dual.to_dual a)
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [nondiscrete_normed_field R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [normed_group F] [normed_space R F] [topological_space B] (a : topological_vector_prebundle R F E) {e e' : topological_vector_bundle.pretrivialization R F E} (he : e ‚àà a.pretrivialization_atlas) (he' : e' ‚àà a.pretrivialization_atlas) (b : B) : F ‚ÜíL[R] F
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pushouts C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : category_theory.limits.is_colimit (category_theory.abelian.biproduct_to_pushout_is_cokernel.biproduct_to_pushout_cofork f g)
{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} : isometry f ‚Üî ‚àÄ (x y : Œ±), has_dist.dist (f x) (f y) = has_dist.dist x y
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ w)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {E' : Type u_7} [inner_product_space ùïú E'] {v : basis Œπ ùïú E} (hv : orthonormal ùïú ‚áëv) (f : E ‚âÉ‚Çó·µ¢[ùïú] E') : orthonormal ùïú ‚áë(v.map f.to_linear_equiv)
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M ‚Üí* P} (hg : ‚àÄ (y : ‚Ü•S), is_unit (‚áëg ‚Üëy)) {x y : M} (h : ‚áë(f.to_map) x = ‚áë(f.to_map) y) : ‚áëg x = ‚áëg y
{Œ± : Type u_1} {Œ≤ : Type u_2} [nontrivial Œ±] {f : Œ± ‚Üí Œ≤} (hf : function.injective f) (y : Œ≤) : ‚àÉ (x : Œ±), f x ‚â† y
 : unit
(R : Type u) (A : Type w) [comm_semiring R] [semiring A] [algebra R A] (n : ‚Ñï) [inv : invertible ‚Üën] : invertible ‚Üën
(n : ‚Ñï) : ‚Ñï
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [no_max_order Œ±] {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (set.Ici a) ‚Üî ‚àÉ (u : Œ±) (H : u ‚àà set.Ioi a), set.Ico a u ‚äÜ s
{C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} (H : X ‚âÖ Y) : algebraic_geometry.PresheafedSpace.is_open_immersion H.hom
 : interactive.parse tactic.interactive.cases_arg_p ‚Üí interactive.parse interactive.types.with_ident_list ‚Üí tactic unit
(K : Type u_1) [is_R_or_C K] : K ‚âÉ+* K·µê·µí·µñ
{R : Type u} {M : Type v} {M‚ÇÉ : Type y} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÉ] [module R M] [module R M‚ÇÉ] : M ‚Üí‚Çó[R] fin 0 ‚Üí M‚ÇÉ
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {s : set E} {x y : E} {f' : E ‚Üí (E ‚ÜíL[‚Ñù] ‚Ñù)} (hf : ‚àÄ (x : E), x ‚àà s ‚Üí has_fderiv_within_at f (f' x) s x) (hs : convex ‚Ñù s) (xs : x ‚àà s) (ys : y ‚àà s) : ‚àÉ (z : E) (H : z ‚àà segment ‚Ñù x y), f y - f x = ‚áë(f' z) (y - x)
{n : Type u_3} {R : Type u_7} {Œ± : Type v} [non_unital_non_assoc_semiring Œ±] [fintype n] [monoid R] [distrib_mul_action R Œ±] [smul_comm_class R Œ± Œ±] : smul_comm_class R (matrix n n Œ±) (matrix n n Œ±)
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) (x : X) (hsat : jordan_holder_lattice.is_maximal s.top x) : composition_series X
(p : ‚Ñï) [hp : fact (nat.prime p)] {q r : ‚Ñö} : padic_norm p (q + r) ‚â§ linear_order.max (padic_norm p q) (padic_norm p r)
(p : omega.int.preform) : Prop
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : lie_submodule R L M
(c : linarith.comp) (n : ‚Ñï) : linarith.comp
{Œ± : Type u} : ordnode Œ± ‚Üí ‚Ñï ‚Üí ordnode Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {X : C} (h : category_theory.yoneda.obj X ‚ãô category_theory.ulift_functor ‚âÖ F.cones) : category_theory.limits.is_limit (category_theory.limits.is_limit.of_nat_iso.limit_cone h)
{R : Type u_1} [comm_ring R] : is_open_map ‚áë(prime_spectrum.comap polynomial.C)
{Œ± : Type u} {G : Type u_1} [group G] (f g : free_group Œ± ‚Üí* G) (h : ‚àÄ (a : Œ±), ‚áëf (free_group.of a) = ‚áëg (free_group.of a)) : f = g
{X : ‚Ñï ‚Üí Type u} [Œ† (n : ‚Ñï), metric_space (X n)] (f : Œ† (n : ‚Ñï), X n ‚Üí X (n + 1)) (x y : Œ£ (n : ‚Ñï), X n) : ‚Ñù
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.preadditive D] {F G : C ‚•§ D} (X : C) : (F ‚ü∂ G) ‚Üí+ (F.obj X ‚ü∂ G.obj X)
(m : Type u ‚Üí Type u) [monad m] [is_lawful_monad m] : category_theory.Kleisli m ‚âå category_theory.kleisli (category_theory.of_type_monad m)
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] {f : filter Œ±} {a : Œ±} (hl : filter.is_bounded has_le.le f) (hg : filter.is_bounded ge f) (hs : f.Limsup = a) (hi : f.Liminf = a) : f ‚â§ nhds a
(c : tactic.instance_cache) (n : name) : tactic (tactic.instance_cache √ó expr)
{M : Type u_5} [nontrivial M] [hM : comm_monoid_with_zero M] (h : ‚àÄ (a : M), is_unit a ‚à® a = 0) : comm_group_with_zero M
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {s : set E} {f : E ‚Üí F} {n : with_top ‚Ñï} (hf : cont_diff_on ùïú n f s) (g : G ‚ÜíL[ùïú] E) : cont_diff_on ùïú n (f ‚àò ‚áëg) (‚áëg ‚Åª¬π' s)
{M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)
{Œ± : Type u_1} (Œ≤ : Œ± ‚Üí Type u_2) : (Œ£' (i : Œ±), Œ≤ i) ‚âÉ Œ£ (i : Œ±), Œ≤ i
(Œ± : Type u_6) [topological_space Œ±] [h : measurable_space Œ±] : Prop
{a b c : ‚Ñù} : interval_integrable (Œª (x : ‚Ñù), (x - c)‚Åª¬π) measure_theory.measure_space.volume a b ‚Üî a = b ‚à® c ‚àâ set.interval a b
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : Type (max u‚ÇÅ v‚ÇÅ)
{Œπ : Type u_1} {Œ± : Type u_2} {s : Œπ ‚Üí set Œ±} (hs : indexed_partition s) : Œπ ‚âÉ hs.quotient
{Œ± : Type u_1} (f : Œ± ‚Üí‚ÇÄ ‚Ñï) : finset ((Œ± ‚Üí‚ÇÄ ‚Ñï) √ó (Œ± ‚Üí‚ÇÄ ‚Ñï))
(ns : list name) : tactic (list string)
{Œ± : Type u_1} {m : set Œ± ‚Üí ennreal} {s t : set Œ±} (h : ‚àÄ (u : set Œ±), (s ‚à© u).nonempty ‚Üí (t ‚à© u).nonempty ‚Üí m u = ‚ä§) : ‚áë(measure_theory.outer_measure.bounded_by m) (s ‚à™ t) = ‚áë(measure_theory.outer_measure.bounded_by m) s + ‚áë(measure_theory.outer_measure.bounded_by m) t
(R : Type u_1) [comm_ring R] {C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] [category_theory.preadditive D] [category_theory.linear R D] {F G : category_theory.Free R C ‚•§ D} [F.additive] [category_theory.functor.linear R F] [G.additive] [category_theory.functor.linear R G] (Œ± : category_theory.Free.embedding R C ‚ãô F ‚âÖ category_theory.Free.embedding R C ‚ãô G) : F ‚âÖ G
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : ‚àÄ (x : ‚Ñù), x ‚àà interior D ‚Üí deriv f x < 0) : strict_anti_on f D
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] {f : filter Œ≤} {g : Œ≤ ‚Üí Œ±} (h : ‚àÉ (a : Œ±), filter.tendsto g f (nhds a)) : filter.tendsto g f (nhds (lim f g))
(n : expr) : tactic (expr √ó expr)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_terminal C] [category_theory.limits.preserves_limit (category_theory.functor.empty C) G] : category_theory.limits.is_terminal (G.obj (‚ä§_ C))
(X : algebraic_geometry.LocallyRingedSpace) : algebraic_geometry.RingedSpace
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] (f : R ‚Üí+* S) (hf : ‚àÄ (x y : R), commute (‚áëf x) (‚áëf y)) : R ‚Üí+* S·µê·µí·µñ
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] [complete_space ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [finite_dimensional ùïú F] (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ‚ä§) : F ‚Üí ‚Ü•(f'.ker) ‚Üí E
{Œπ : Type u_1} {R : Type u_2} {N : Type u_5} [ring R] [add_comm_group N] [module R N] [no_zero_smul_divisors R N] (p : Œπ ‚Üí submodule R N) (hp : complete_lattice.independent p) {v : Œπ ‚Üí N} (hv : ‚àÄ (i : Œπ), v i ‚àà p i) (hv' : ‚àÄ (i : Œπ), v i ‚â† 0) : linear_independent R v
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {n : with_top ‚Ñï} {s : set E} {f g : E ‚Üí ùïú} (hf : cont_diff_on ùïú n f s) (hg : cont_diff_on ùïú n g s) : cont_diff_on ùïú n (Œª (x : E), f x * g x) s
{G : Type u_4} [inner_product_space ‚ÑÇ G] : inner_product_space ‚Ñù G
{Œ± : Type u_2} {Œ≤ : Type u_3} [monoid Œ±] [mul_action Œ± Œ≤] : mul_action (set Œ±) (set Œ≤)
 : ‚Ñï ‚Üí option ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f
(R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A] : Type v
(Œ± : Type u) [group Œ±] : category_theory.groupoid (category_theory.single_obj Œ±)
{M : Type u_1} [has_mul M] (S : subsemigroup M) {x y : M} : x ‚àà S ‚Üí y ‚àà S ‚Üí x * y ‚àà S
{R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] [is_domain S] (H : algebra.is_integral R S) (P : ideal R) [P.is_prime] (hP : (algebra_map R S).ker ‚â§ P) : ‚àÉ (Q : ideal S), Q.is_prime ‚àß ideal.comap (algebra_map R S) Q = P
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] (i : D.to_glue_data.J) (U : topological_space.opens ‚Ü•((D.to_glue_data.U i).carrier)) : D.diagram_over_open_œÄ U i ‚â´ D.Œπ_inv_app_œÄ_eq_map U ‚â´ D.Œπ_inv_app U = ùüô (category_theory.limits.limit (D.diagram_over_open U))
{Œ± : Type u_1} [has_zero Œ±] [has_one Œ±] [has_add Œ±] [has_neg Œ±] : ‚Ñ§ ‚Üí Œ±
{Œ± : Type u_1} [topological_space Œ±] (R : Type u_2) [comm_semiring R] {A : Type u_3} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] [has_continuous_const_smul R A] : C(Œ±, A) ‚Üí‚Çê[R] Œ± ‚Üí A
 : nat.arithmetic_function ‚Ñù
{n : ‚Ñï} (P : mvpfunctor n) (Œ± : typevec n) : Type u
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (a : Œ±) : principal_seg (subrel r {b : Œ± | r b a}) r
 : list bool ‚Üí bool
{Œπ : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] (hs : is_closed s) (U : Œπ ‚Üí set X) (ho : ‚àÄ (i : Œπ), is_open (U i)) (hf : locally_finite U) (hU : s ‚äÜ ‚ãÉ (i : Œπ), U i) : ‚àÉ (f : bump_covering Œπ X s), f.is_subordinate U
(Œì‚ÇÄ : Type u_1) [linear_ordered_comm_group_with_zero Œì‚ÇÄ] : regular_space Œì‚ÇÄ
{S : Type u} [pgame.state S] (n : ‚Ñï) {s : S} (h : pgame.state.turn_bound s ‚â§ n) : (pgame.of_aux n s h).right_moves ‚âÉ {t // t ‚àà pgame.state.R s}
{Œ± : Type u_1} {n : Type u_4} {m : Type u_5} [has_zero Œ±] {A : matrix m m Œ±} {B : matrix m n Œ±} {C : matrix n m Œ±} {D : matrix n n Œ±} : (matrix.from_blocks A B C D).is_diag ‚Üî A.is_diag ‚àß B = 0 ‚àß C = 0 ‚àß D.is_diag
 : ‚Ñï ‚Üí enat
{G : Type u_10} [add_group G] (a : G) : G ‚âÉ G
 : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b ‚àß ordinal.omega ‚â§ b}
{E : Type u} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {a : E} (h : is_local_extr f a) : fderiv ‚Ñù f a = 0
{R : Type u_1} [comm_ring R] [topological_space R] {M : submonoid R} : ring_topology (localization M)
{Œ± : Type u} [topological_space Œ±] {s : set (Œ± √ó Œ±)} {x : Œ±} (hx : s ‚àà nhds (x, x)) : ‚àÉ (U : set Œ±), is_open U ‚àß x ‚àà U ‚àß U √óÀ¢ U ‚äÜ s
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.abelian C] [category_theory.has_injective_resolutions C] [category_theory.abelian D] {F G : C ‚•§ D} [F.additive] [G.additive] (Œ± : F ‚ü∂ G) (n : ‚Ñï) {X : C} (P : category_theory.InjectiveResolution X) : (category_theory.nat_trans.right_derived Œ± n).app X = (F.right_derived_obj_iso n P).hom ‚â´ (homology_functor D (complex_shape.up ‚Ñï) n).map ((category_theory.nat_trans.map_homological_complex Œ± (complex_shape.up ‚Ñï)).app P.cocomplex) ‚â´ (G.right_derived_obj_iso n P).inv
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [dec : decidable_eq Œπ] [Œ† (i : Œπ), add_group (Œ≤ i)] (s : finset Œπ) : (Œ† (i : ‚Ü•‚Üës), Œ≤ ‚Üëi) ‚Üí+ Œ†‚ÇÄ (i : Œπ), Œ≤ i
{R : Type u} [ring R] {J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Module R) : Module R
(M : Type u_9) (N : Type u_10) [has_one M] [has_one N] : Type (max u_10 u_9)
 : vm_decl ‚Üí option string
{H : Type u_1} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] {H' : Type u_3} {M' : Type u_4} [topological_space H'] [topological_space M'] [charted_space H' M'] {G : structure_groupoid H} {G' : structure_groupoid H'} {e e' : local_homeomorph M H} {f f' : local_homeomorph M' H'} {P : (H ‚Üí H') ‚Üí set H ‚Üí H ‚Üí Prop} {g : M ‚Üí M'} {s : set M} {x : M} (hG : G.local_invariant_prop G' P) (he : e ‚àà structure_groupoid.maximal_atlas M G) (xe : x ‚àà e.to_local_equiv.source) (he' : e' ‚àà structure_groupoid.maximal_atlas M G) (xe' : x ‚àà e'.to_local_equiv.source) (hf : f ‚àà structure_groupoid.maximal_atlas M' G') (xf : g x ‚àà f.to_local_equiv.source) (hf' : f' ‚àà structure_groupoid.maximal_atlas M' G') (xf' : g x ‚àà f'.to_local_equiv.source) (hgs : continuous_within_at g s x) (h : P (‚áëf ‚àò g ‚àò ‚áë(e.symm)) (e.to_local_equiv.target ‚à© ‚áë(e.symm) ‚Åª¬π' (s ‚à© g ‚Åª¬π' f.to_local_equiv.source)) (‚áëe x)) : P (‚áëf' ‚àò g ‚àò ‚áë(e'.symm)) (e'.to_local_equiv.target ‚à© ‚áë(e'.symm) ‚Åª¬π' (s ‚à© g ‚Åª¬π' f'.to_local_equiv.source)) (‚áëe' x)
{Œ± : Type u_1} {Œ≤ : Type u_2} (s : set (Œ± √ó Œ≤)) : ‚Ü•s ‚âÉ Œ£ (x : Œ±), ‚Ü•{y : Œ≤ | (x, y) ‚àà s}
{p : ‚Ñï} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n : ‚Ñï} (hn : n ‚â† 0) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic p R)
{G : Type u_1} [add_left_cancel_semigroup G] (g : G) : G ‚Ü™ G
{Œ≤ : Type u} {Œ± : Type v} {s : finset Œ±} [comm_monoid Œ≤] (f : Œ± ‚Üí Œ≤) {p : Œ± ‚Üí Prop} [decidable_pred p] (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p x) : (finset.subtype p s).prod (Œª (x : subtype p), f ‚Üëx) = s.prod (Œª (x : Œ±), f x)
(J : Type u‚ÇÅ) [category_theory.category J] : Prop
{Œ± : Type u_3} {Œ≤ : Type u_4} [linear_ordered_field Œ±] {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±} {r : Œ±} (hr : r < 0) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Œª (x : Œ≤), f x * r) l filter.at_bot
{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} (h : f = g) (x : M) : ‚áëf x = ‚áëg x
{T : Type u‚ÇÅ} [category_theory.category T] {X Y Z : T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : category_theory.under.map (f ‚â´ g) ‚âÖ category_theory.under.map g ‚ãô category_theory.under.map f
 : expr ‚Üí tactic expr
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) [complete_space ‚Ü•K] : function.involutive ‚áë(reflection K)
 : nat.arithmetic_function ‚Ñï
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (N : submonoid S) (T : Type u_4) [comm_ring T] [algebra R T] [algebra S T] [is_scalar_tower R S T] [is_localization M S] [is_localization N T] : is_localization (is_localization.localization_localization_submodule M N) T
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [ideal.is_jacobson R] : {p // p.is_maximal} ‚âÉo {p // p.is_maximal ‚àß y ‚àâ p}
{R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] (e : basis Œπ R M) (x : orientation R M Œπ) : x ‚â† e.orientation ‚Üî x = -e.orientation
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) (b : Œ≤ a) (s : finmap Œ≤) : finmap Œ≤
{n : ‚Ñï} : fin2 n ‚Üí fin2 n ‚Üí fin2 n
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
(C : Type u_1) [category_theory.category C] : C ‚•§ category_theory.idempotents.karoubi C
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} (f : J ‚Üí (X ‚ü∂ Y)) [category_theory.limits.has_wide_coequalizer f] : category_theory.limits.cotrident f
{b : ‚Ñï} {l : list ‚Ñï} (hl : ‚àÄ (x : ‚Ñï), x ‚àà l ‚Üí x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length
 : ‚Ñï ‚Üí ‚Ñ§
 : lean.parser name
(C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C
 : tactic.itauto.proof ‚Üí format
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f : X ‚ü∂ Y) : category_theory.mono f
{G : Type u} [group G] [fintype G] (p : ‚Ñï) {n : ‚Ñï} [fact (nat.prime p)] (hdvd : p ^ n ‚à£ fintype.card G) : ‚àÉ (K : subgroup G), fintype.card ‚Ü•K = p ^ n
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M ‚Üí* P} {T : submonoid P} (hy : ‚àÄ (y : ‚Ü•S), ‚áëg ‚Üëy ‚àà T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} (z : N) : ‚áë(f.map hy k) z * ‚áë(k.to_map) (‚áëg ‚Üë((f.sec z).snd)) = ‚áë(k.to_map) (‚áëg (f.sec z).fst)
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] : category_theory.lax_braided_functor (category_theory.discrete punit) C ‚âå CommMon_ C
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (h : category_theory.presieve.is_sheaf_for P ‚áëS) (f : S.functor ‚ü∂ P) : category_theory.yoneda.obj X ‚ü∂ P
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [dec_irr : Œ† (p : associates Œ±), decidable (irreducible p)] [unique_factorization_monoid Œ±] [dec : decidable_eq Œ±] [dec' : decidable_eq (associates Œ±)] {p a : associates Œ±} (hp : irreducible p) {n : ‚Ñï} (h : a ‚à£ p ^ n) : a = p ^ p.count a.factors
{Œ± : Type u_1} (d : measurable_space.dynkin_system Œ±) {s : set Œ±} (h : d.has s) : measurable_space.dynkin_system Œ±
{C : Type u} : category_theory.free_monoidal_category.normal_monoidal_object C ‚Üí category_theory.free_monoidal_category C
{n : ‚Ñï} (p : fin (n + 1)) (i : fin n) : p < ‚áë(p.succ_above) i ‚Üî p ‚â§ ‚áëfin.cast_succ i
{Œ± : Type u_1} [add_comm_monoid Œ±] (m M N : ‚Ñï) (f : (Œ£ (n : ‚Ñï), fin n ‚Üí ‚Ñï) ‚Üí Œ±) (g : (Œ£ (n : ‚Ñï), composition n) ‚Üí Œ±) (h : ‚àÄ (e : Œ£ (n : ‚Ñï), fin n ‚Üí ‚Ñï) (he : e ‚àà formal_multilinear_series.comp_partial_sum_source m M N), f e = g (formal_multilinear_series.comp_change_of_variables m M N e he)) : (formal_multilinear_series.comp_partial_sum_source m M N).sum (Œª (e : Œ£ (n : ‚Ñï), fin n ‚Üí ‚Ñï), f e) = (formal_multilinear_series.comp_partial_sum_target m M N).sum (Œª (e : Œ£ (n : ‚Ñï), composition n), g e)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q R S : C} {f : P ‚ü∂ Q} {g : P ‚ü∂ R} {h : Q ‚ü∂ S} {k : R ‚ü∂ S} [hn : category_theory.normal_mono k] (comm : f ‚â´ h = g ‚â´ k) (t : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk f g comm)) : category_theory.normal_mono f
{M : Type u_1} [mul_one_class M] (c d : con M) (h : c ‚â§ d) : c.quotient ‚Üí* d.quotient
{Œ± : Type u} {Œ≥ : Type w} [comm_semiring Œ±] [has_zero Œ≥] [has_one Œ≥] [has_add Œ≥] [has_mul Œ≥] [has_scalar ‚Ñï Œ≥] [has_pow Œ≥ ‚Ñï] (f : Œ≥ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ≥), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≥), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ≥) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ≥) (n : ‚Ñï), f (x ^ n) = f x ^ n) : comm_semiring Œ≥
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] : has_coe_to_fun (Œ± ‚Üío Œ≤) (Œª (_x : Œ± ‚Üío Œ≤), Œ± ‚Üí Œ≤)
{Œ± : Type u_1} {p : Œ± ‚Üí Prop} [encodable Œ±] [decidable_pred p] (h : ‚àÉ (x : Œ±), p x) : {a // p a}
{R : Type u_1} {B : Type u_3} [nondiscrete_normed_field R] [topological_space B] {F‚ÇÅ : Type u_6} [normed_group F‚ÇÅ] [normed_space R F‚ÇÅ] {E‚ÇÅ : B ‚Üí Type u_7} [topological_space (bundle.total_space E‚ÇÅ)] [Œ† (x : B), add_comm_monoid (E‚ÇÅ x)] [Œ† (x : B), module R (E‚ÇÅ x)] {F‚ÇÇ : Type u_8} [normed_group F‚ÇÇ] [normed_space R F‚ÇÇ] {E‚ÇÇ : B ‚Üí Type u_9} [topological_space (bundle.total_space E‚ÇÇ)] [Œ† (x : B), add_comm_monoid (E‚ÇÇ x)] [Œ† (x : B), module R (E‚ÇÇ x)] (e‚ÇÅ : topological_vector_bundle.trivialization R F‚ÇÅ E‚ÇÅ) (e‚ÇÇ : topological_vector_bundle.trivialization R F‚ÇÇ E‚ÇÇ) [Œ† (x : B), topological_space (E‚ÇÅ x)] [Œ† (x : B), topological_space (E‚ÇÇ x)] [topological_vector_bundle R F‚ÇÅ E‚ÇÅ] [topological_vector_bundle R F‚ÇÇ E‚ÇÇ] : topological_vector_bundle.trivialization R (F‚ÇÅ √ó F‚ÇÇ) (Œª (x : B), E‚ÇÅ x √ó E‚ÇÇ x)
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.initial] {E : Type u} [category_theory.category E] (G : D ‚•§ E) [category_theory.limits.has_limit G] : category_theory.limits.limit (F ‚ãô G) ‚âÖ category_theory.limits.limit G
{Œπ : Type u_1} [fintype Œπ] [decidable_eq Œπ] (w' : Œπ ‚Üí ‚ÑÇ) : (quadratic_form.weighted_sum_squares ‚ÑÇ w').isometry (quadratic_form.weighted_sum_squares ‚ÑÇ (Œª (i : Œπ), ite (w' i = 0) 0 1))
{Œ± : Type u_1} {Œπ : Type u} : (Œπ ‚Üí Œ±) ‚Üí Œ† (a : ordinal), a < ordinal.type well_ordering_rel ‚Üí Œ±
{Œ± : Sort u_1} (p : Œ± ‚Üí Prop) : subtype p ‚Ü™ Œ±
{Œ± Œ≤ : BoolRing} (e : ‚Ü•Œ± ‚âÉ+* ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
{K : Type u} [field K] (s : subfield K) {x : K} : x ‚àà s ‚Üí -x ‚àà s
(R : Type u_1) {S : Type u_6} (M : Type u_9) [semiring R] [add_comm_monoid M] [module R M] [monoid S] [distrib_mul_action S M] [smul_comm_class S R M] : S ‚Üí* module.End R M
 : tactic.ring_exp.ex tactic.ring_exp.ex_type.sum ‚Üí tactic.ring_exp.ex tactic.ring_exp.ex_type.sum ‚Üí tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum)
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] [Œ† (i : Œπ), decidable_eq (M i)] {i : Œπ} (p : free_product.word.pair M i) : free_product.word M
{G : Type u_1} [group G] {H : subgroup G} {S : set G} (hS : S ‚àà subgroup.left_transversals ‚ÜëH) : G ‚ß∏ H ‚âÉ ‚Ü•S
 : hole_command
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M ‚Üí+ P} {T : add_submonoid P} (hy : ‚àÄ (y : ‚Ü•S), ‚áëg ‚Üëy ‚àà T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} {A : Type u_5} [add_comm_monoid A] {U : add_submonoid A} {R : Type u_6} [add_comm_monoid R] (j : U.localization_map R) {l : P ‚Üí+ A} (hl : ‚àÄ (w : ‚Ü•T), ‚áël ‚Üëw ‚àà U) (x : N) : ‚áë(k.map hl j) (‚áë(f.map hy k) x) = ‚áë(f.map _ j) x
{Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} {Œπ' : Type u_3} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : filter Œπ} (hf : ‚àÄ (i : Œπ), measurable (f i)) {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí set Œπ} (hu : u.has_countable_basis p s) (hs : ‚àÄ (i : Œπ'), (s i).countable) : measurable (Œª (x : Œ¥), u.liminf (Œª (i : Œπ), f i x))
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] (a b : Œ±) : multiset Œ±
{M : Type u_1} [mul_one_class M] (c d : con M) (h : c ‚â§ d) : (con.ker (c.map d h)).quotient ‚âÉ* d.quotient
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) : hb.oangle (-x) y + hb.oangle (-y) x = 0
{R : Type u} {Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [topological_space M‚ÇÇ] (f : continuous_multilinear_map R M‚ÇÅ M‚ÇÇ) (m : Œ† (i : Œπ), M‚ÇÅ i) (i : Œπ) : M‚ÇÅ i ‚ÜíL[R] M‚ÇÇ
(Œ± : Type u_1) [uniform_space Œ±] : has_coe_t Œ± (uniform_space.completion Œ±)
{Œ± : Type u_1} {Œ≤ : Type u_2} [encodable Œ±] [inhabited Œ±] {r : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : Œ± ‚Üí Œ≤) (hf : directed r f) : ‚Ñï ‚Üí Œ±
 : box_integral.integration_params
 : tactic unit
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] {T‚ÇÅ T‚ÇÇ : category_theory.triangulated.triangle C} (f : category_theory.triangulated.triangle_morphism T‚ÇÅ T‚ÇÇ) : category_theory.triangulated.triangle_morphism T‚ÇÅ.rotate T‚ÇÇ.rotate
(S : Type u_4) (M : out_param (Type u_5)) [add_zero_class M] [set_like S M] : Type
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ Y‚ÇÇ) (f‚ÇÇ‚ÇÅ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) [category_theory.is_iso f‚ÇÅ‚ÇÅ] : Œ£' (L : X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ X‚ÇÅ ‚äû X‚ÇÇ) (R : Y‚ÇÅ ‚äû Y‚ÇÇ ‚âÖ Y‚ÇÅ ‚äû Y‚ÇÇ) (g‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ), L.hom ‚â´ category_theory.biprod.of_components f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ ‚â´ R.hom = category_theory.limits.biprod.map f‚ÇÅ‚ÇÅ g‚ÇÇ‚ÇÇ
{F : Type u_1} [field F] {K‚ÇÅ : Type u_3} [field K‚ÇÅ] [algebra F K‚ÇÅ] (E : Type u_6) [field E] [algebra F E] [algebra E K‚ÇÅ] [is_scalar_tower F E K‚ÇÅ] [normal F E] : (K‚ÇÅ ‚âÉ‚Çê[F] K‚ÇÅ) ‚Üí* E ‚âÉ‚Çê[F] E
{M : Type w} {N : Type w'} (f : M ‚âÉ N) : first_order.language.empty.equiv M N
{Œ± : Type u} [pseudo_emetric_space Œ±] (Œ¥ : ‚Ñù) (E : set Œ±) : closure E ‚äÜ metric.cthickening Œ¥ E
(R : Type u_1) [ring R] : algebra_map ‚Ñ§ R = int.cast_ring_hom R
(h : expr) (ns : name_set) : tactic bool
{Œπ : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] (hs : is_closed s) (U : Œπ ‚Üí set X) (ho : ‚àÄ (i : Œπ), is_open (U i)) (hf : locally_finite U) (hU : s ‚äÜ ‚ãÉ (i : Œπ), U i) : ‚àÉ (f : partition_of_unity Œπ X s), f.is_subordinate U
 : Type
{n : ‚Ñï} : n % 2 = 1 ‚Üî n % 4 = 1 ‚à® n % 4 = 3
{R : Type u} {Œπ : Type u'} {M‚ÇÇ : Type v‚ÇÇ} {M' : Type v'} [decidable_eq Œπ] [comm_semiring R] [add_comm_monoid M'] [add_comm_monoid M‚ÇÇ] [module R M'] [module R M‚ÇÇ] {Œπ' : Type u_1} [decidable_eq Œπ'] [decidable_eq (Œπ ‚äï Œπ')] (f : multilinear_map R (Œª (x : Œπ ‚äï Œπ'), M') M‚ÇÇ) : multilinear_map R (Œª (x : Œπ), M') (multilinear_map R (Œª (x : Œπ'), M') M‚ÇÇ)
{G‚ÇÄ : Type u_2} [group_with_zero G‚ÇÄ] (a : G‚ÇÄ) : a * a‚Åª¬π * a = a
(ùïú : Type u_1) (E : Type u_2) [is_R_or_C ùïú] [inner_product_space ùïú E] : galois_connection submodule.orthogonal submodule.orthogonal
{M : Type u_1} [has_add M] {s : set M} : s ‚äÜ ‚Üë(add_subsemigroup.closure s)
(L : first_order.language) {M : Type w} [L.Structure M] (A : set M) (Œ± : Type u_1) : Type (max u_1 w)
 : dense {x : ‚Ñù | liouville x}
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [has_one M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñï] [left_cancel_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) : left_cancel_monoid M‚ÇÅ
{C : Type u_1} [category_theory.category C] {F : C ‚•§ category_theory.Cat} {X Y Z : category_theory.grothendieck F} (f : X.hom Y) (g : Y.hom Z) : X.hom Z
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {b : M} [linear_ordered_comm_ring M] (ht : t.nonempty) (hb : ‚Üë(s.card) ‚â§ t.card ‚Ä¢ b) : ‚àÉ (y : Œ≤) (H : y ‚àà t), ‚Üë((finset.filter (Œª (x : Œ±), f x = y) s).card) ‚â§ b
{Œ± : Type u_2} [has_mul Œ±] : Œ± ‚Üí‚Çô* set Œ±
{X Y : Type u} [comm_monoid X] [comm_monoid Y] (e : X ‚âÉ* Y) : CommMon.of X ‚âÖ CommMon.of Y
{V : Type u} {G : simple_graph V} [decidable_eq V] {v w : V} (p : G.walk v w) (u : V) (h : u ‚àà p.support) : G.walk u w
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] (h : ‚àÄ (x : E), module.rank F ‚Ü•F‚üÆx‚üØ = 1) : ‚ä• = ‚ä§
(p : Set ‚Üí Prop) (A : Class) : Prop
{Œ± : Type u_1} {r : setoid Œ±} {x y : Œ±} : quotient.mk' x = quotient.mk' y ‚Üî r.rel x y
(X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] : pseudo_metric_space (X ‚äï Y)
(Fq F : Type) [field Fq] [field F] [algebra (polynomial Fq) F] : subalgebra (polynomial Fq) F
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.limits.image f ‚âÖ X
(lt : bool) (n a : expr) : tactic.norm_fin.eval_fin_m (expr √ó expr)
{Œ± : Type u_1} (f : expr ‚Üí option Œ±) : expr ‚Üí option (list Œ±)
(Œ± : Type u_3) [has_inf Œ±] : inf_hom Œ± Œ±
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {u : ‚Ñï ‚Üí E} {l : E} (h : filter.tendsto u filter.at_top (nhds l)) : filter.tendsto (Œª (n : ‚Ñï), (‚Üën)‚Åª¬π ‚Ä¢ (finset.range n).sum (Œª (i : ‚Ñï), u i)) filter.at_top (nhds l)
(t : tactic.interactive.itactic) (p : interactive.parse interactive.types.texpr) : tactic.interactive.itactic
(rs : interactive.parse tactic.interactive.rw_rules) (loc : interactive.parse interactive.types.location) : tactic unit
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (F : C ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.preserves_limit (category_theory.limits.cospan f f) F] [category_theory.mono f] : category_theory.mono (F.map f)
 : ennreal ‚Üí nnreal
{X Y Z : Type u} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : category_theory.limits.limit_cone (category_theory.limits.cospan f g)
{C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] : category_theory.limits.has_colimits (algebraic_geometry.PresheafedSpace C)
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} {Œ≤ : Type u_1} {a : P.A} (f' : (P.drop.B a).arrow Œ±) (f : P.last.B a ‚Üí Œ≤) : (P.B a).arrow (Œ± ::: Œ≤)
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üío Œ≤) : with_top Œ± ‚Üío with_top Œ≤
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C‚ÇÅ C‚ÇÇ : homological_complex V c} (i : Œπ) : (C‚ÇÅ ‚ü∂ C‚ÇÇ) ‚Üí+ (C‚ÇÅ.X i ‚ü∂ C‚ÇÇ.X i)
{R : Type u_1} [comm_ring R] {c‚ÇÅ c‚ÇÇ : R} : quaternion_algebra R c‚ÇÅ c‚ÇÇ ‚âÉ‚Çó[R] quaternion_algebra R c‚ÇÅ c‚ÇÇ
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] {a u' : Œ±} {s : set Œ±} (hu' : a < u') : s ‚àà nhds_within a (set.Ici a) ‚Üî ‚àÉ (u : Œ±) (H : u ‚àà set.Ioi a), set.Ico a u ‚äÜ s
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_scalar Œ± Œ≤] : has_scalar (set Œ±) (set Œ≤)
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x y z : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (hz : z ‚â† 0) : hb.oangle x y + hb.oangle y z + hb.oangle z x = 0
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {X : C} (h : category_theory.coyoneda.obj (opposite.op X) ‚ãô category_theory.ulift_functor ‚âÖ F.cocones) : category_theory.limits.cocone F
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p3 p2 p1
(J : Type u‚ÇÅ) [category_theory.category J] {C : Type u‚ÇÇ} [category_theory.category C] {D : Type u‚ÇÉ} [category_theory.category D] (X : C) (F : C ‚•§ D) : (category_theory.functor.const J).obj X ‚ãô F ‚âÖ (category_theory.functor.const J).obj (F.obj X)
(C : Type u) : Type u
{C : Type u} [category_theory.category C] (J : C) : Prop
{X Y : AddMon} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ+ ‚Ü•Y
 : Bipointed ‚•§ Pointed
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [unique J] (f : J ‚Üí C) : ‚®Å f ‚âÖ f inhabited.default
{X : Type u} [topological_space X] (x‚ÇÄ x‚ÇÅ : X) : setoid (path x‚ÇÄ x‚ÇÅ)
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] : ideal.is_jacobson S
{C : Type u_1} [category_theory.category C] (P : category_theory.idempotents.karoubi C) : ‚Üë(P.X) ‚ü∂ P
(x y : ‚Ñù) : ‚Ñù
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} [char_zero k] {s : finset Œπ} (p : Œπ ‚Üí P) (h : s.nonempty) : finset.centroid k s p ‚àà affine_span k (set.range p)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) (h : s.sum (Œª (i : Œπ), w i) = 0) (b‚ÇÅ b‚ÇÇ : P) : ‚áë(s.weighted_vsub_of_point p b‚ÇÅ) w = ‚áë(s.weighted_vsub_of_point p b‚ÇÇ) w
(n : ‚Ñï+) (A : Type u) (K : Type w) [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] : algebra A (cyclotomic_field n K)
{E : Type u_1} [inner_product_space ‚Ñù E] {n : ‚Ñï} [fact (finite_dimensional.finrank ‚Ñù E = n + 1)] : charted_space (euclidean_space ‚Ñù (fin n)) ‚Ü•(metric.sphere 0 1)
{G : Type u‚ÇÇ} [monoid G] (k : Type u_1) (A : Type u_2) [comm_semiring k] [semiring A] [algebra k A] {H : Type u_3} {F : Type u_4} [monoid H] [monoid_hom_class F G H] (f : F) : monoid_algebra A G ‚Üí‚Çê[k] monoid_algebra A H
(Œ± : Type u_1) {Œ≤ : Type u_2} [denumerable Œ±] (e : Œ≤ ‚âÉ Œ±) : denumerable Œ≤
(R : Type u_1) [comm_ring R] (M : Type u_2) [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [nontrivial R] : ‚áë(linear_map.trace R M) 1 = ‚Üë(finite_dimensional.finrank R M)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (k : ‚Ñï) : lie_ideal R L ‚Üí lie_ideal R L
(C : Type u) : Type u
 : BoundedOrder ‚•§ BoundedOrder
{Œ± : Type u} {Œ≤ : Type v} : Œ± ‚äï Œ≤ ‚Üí option Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} [mul_one_class Œ±] [comm_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_monoid_hom f) : is_monoid_hom (Œª (a : Œ±), (f a)‚Åª¬π)
{Œ± : Type u_1} [preorder Œ±] [order_bot Œ±] : ‚Ü•(set.Ici ‚ä•) ‚âÉo Œ±
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] [complete_space F] (p : formal_multilinear_series ùïú E F) {x y : E} (h : ‚Üë‚à•x‚à•‚Çä + ‚Üë‚à•y‚à•‚Çä < p.radius) : (p.change_origin x).sum y = p.sum (x + y)
(c : linarith.ineq) (pf npf : expr) (coeff : ‚Ñï) : tactic (linarith.ineq √ó expr)
 : level ‚Üí level ‚Üí bool
{Œ± : Type u_1} [primcodable Œ±] (p : Œ± ‚Üí Prop) : Prop
(attr : norm_cast.norm_cast_attr_ty) (cache : norm_cast.norm_cast_cache) (decl : name) : tactic norm_cast.norm_cast_cache
(C : Type u) [category_theory.category C] : C ‚•§ category_theory.discrete punit
{C : Sort u_1} : pempty ‚Üí C
{G : Type u} [category_theory.groupoid G] [is_free_groupoid G] {a b : G} : nonempty (a ‚ü∂ b) ‚Üí nonempty (quiver.path (symgen a) (symgen b))
{K : Type u_4} {V : Type u} {V' : Type u_8} [field K] [add_comm_group V] [add_comm_group V'] [module K V] [module K V'] {p : submodule K V} (f : ‚Ü•p ‚Üí‚Çó[K] V') : ‚àÉ (g : V ‚Üí‚Çó[K] V'), g.comp p.subtype = f
{Œ± : Type u_1} {p : multiset Œ± ‚Üí Sort u_2} (s : multiset Œ±) : (Œ† (s : multiset Œ±), (Œ† (t : multiset Œ±), t < s ‚Üí p t) ‚Üí p s) ‚Üí p s
{Œ± : Type u_1} : has_le (subtype setoid.is_partition)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Group) : category_theory.limits.is_limit (Group.limit_cone F)
(R : Type u) [semiring R] (q : ‚Ñï) [hp : char_p R 0] [hq : exp_char R q] : q = 1
{R : Type u_1} [ring R] [no_zero_divisors R] (s : subring R) : no_zero_divisors ‚Ü•s
 : Type
 : expr ‚Üí expr ‚Üí tactic (expr √ó expr)
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (c : add_con M) (f : N ‚Üí+ M) : (add_con.comap ‚áëf _ c).quotient ‚âÉ+ ‚Ü•((c.mk'.comp f).mrange)
{Œ± : Type u_3} {Œ≤ : Type u_4} [linear_ordered_field Œ±] {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±} {r : Œ±} (hr : r < 0) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (Œª (x : Œ≤), r * f x) l filter.at_top
(R : Type u) [comm_ring R] : ùüô_ (Module R) ‚ü∂ (Module.free R).obj (ùüô_ (Type u))
{X : Type u_1} [topological_space X] (s : set X) : set X
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {p : filter Œπ} [uniform_space Œ≥] {g : Œ≤ ‚Üí Œ≥} (h : tendsto_uniformly_on F f p s) (hg : uniform_continuous g) : tendsto_uniformly_on (Œª (i : Œπ), g ‚àò F i) (g ‚àò f) p s
{R : Type u_2} {M : Type u_5} [semiring R] [add_comm_group M] (H : module.core R M) : module R M
{X : Top} {x : ‚Ü•X} (p : fundamental_group ‚Ü•X x) : x ‚ü∂ x
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (f : M ‚Üí+ P) (g : P ‚Üí M) (hf : function.right_inverse g ‚áëf) : (add_con.ker f).quotient ‚âÉ+ P
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {s : set E} {x : E} {f' : tangent_space (model_with_corners_self ùïú E) x ‚ÜíL[ùïú] tangent_space (model_with_corners_self ùïú E') (f x)} : has_mfderiv_within_at (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f s x f' ‚Üí has_fderiv_within_at f f' s x
{R : Type u} [semiring R] (p : polynomial R) : R
{R : Type u_1} [comm_ring R] (S : submonoid R) {P : Type u_2} [comm_ring P] [algebra R P] [loc : is_localization S P] (x : P) : fractional_ideal S P
{Œ± : Type u} {Œ≤ : Type v} [semilattice_sup Œ±] [semilattice_sup Œ≤] (f : Œ± ‚Üí Œ≤) (hf : left_ord_continuous f) (h : function.injective f) : Œ± ‚Ü™o Œ≤
(n : ‚Ñï) : ‚Ñö
 : ‚Ñï ‚äï ‚Ñï ‚âÉ ‚Ñï
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [add_monoid Œπ] [graded_monoid.gmonoid A] : monoid (A 0)
{n : ‚Ñï} {i j : fin (n + 1)} (H : i ‚â§ j) : simplex_category.œÉ (‚áëfin.cast_succ i) ‚â´ simplex_category.œÉ j = simplex_category.œÉ j.succ ‚â´ simplex_category.œÉ i
{R : Type u} [comm_ring R] {X Y : Type v} [ring X] [algebra R X] [ring Y] [algebra R Y] (f : X ‚Üí‚Çê[R] Y) : Algebra.of R X ‚ü∂ Algebra.of R Y
{R : Type u_1} {S : Type u_4} [comm_ring R] [comm_ring S] (f : R ‚Üí+* S) (p : polynomial R) (x : S) (h : polynomial.eval‚ÇÇ f x p = 0) : f.is_integral_elem (‚áëf p.leading_coeff * x)
{J : Type u‚ÇÅ} [category_theory.category J] (j : category_theory.connected_components J) : nonempty (category_theory.component j)
{R : Type u} [comm_ring R] : has_quotient R (ideal R)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {f' : E ‚âÉL[ùïú] F} {g : F ‚Üí E} {a : F} (hg : continuous_at g a) (hf : has_fderiv_at f ‚Üëf' (g a)) (hfg : ‚àÄ·∂† (y : F) in nhds a, f (g y) = y) : has_fderiv_at g ‚Üë(f'.symm) a
{ùïú : Type u_1} {V : Type u_2} [normed_field ùïú] [add_comm_group V] [module ùïú V] (e : enorm ùïú V) : normed_group ‚Ü•(e.finite_subspace)
{Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_group Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u_1} [linear_ordered_field Œ±] {a b c d : Œ±} (hc : c ‚â† 0) (hd : d ‚â† 0) : a / c ‚â§ b / d ‚Üí (a * d - b * c) / (c * d) ‚â§ 0
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] {F G H : category_theory.oplax_functor B C} {Œ∑ Œ∏ : F ‚ü∂ G} (Œì : Œ∑ ‚ü∂ Œ∏) (Œπ : G ‚ü∂ H) : Œ∑ ‚â´ Œπ ‚ü∂ Œ∏ ‚â´ Œπ
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.initial] {E : Type u} [category_theory.category E] {G : D ‚•§ E} (t : category_theory.limits.cone (F ‚ãô G)) : category_theory.limits.is_limit (category_theory.functor.initial.extend_cone.obj t) ‚âÉ category_theory.limits.is_limit t
{L : first_order.language} {M : Type u_3} {N : Type u_4} [L.Structure M] [L.Structure N] (f : L.elementary_embedding M N) : L.embedding M N
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] [fact (even (fintype.card n))] : has_neg (matrix.special_linear_group n R)
{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : canonically_ordered_add_monoid (submodule R M)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : ¬¨s1 ‚â§ s2 ‚Üî ‚àÉ (p : P) (H : p ‚àà s1), p ‚àâ s2
(C : Type u) [category_theory.category C] {n : ‚Ñï} (D : Type u_1) [category_theory.category D] : (C ‚•§ D) ‚•§ category_theory.cosimplicial_object.truncated C n ‚•§ category_theory.cosimplicial_object.truncated D n
{Œ± : Type u} {Œ≤ : Type v} (l : lazy_list Œ±) (f : Œ± ‚Üí Œ≤) : lazy_list Œ≤
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : v.int_valuation_def 1 = 1
{Œ± : Type u} {Œ≤ : Type v} [has_sup Œ±] [has_inf Œ±] [has_Sup Œ±] [has_Inf Œ±] [has_top Œ±] [has_bot Œ±] [order.coframe Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.injective f) (map_sup : ‚àÄ (a b : Œ±), f (a ‚äî b) = f a ‚äî f b) (map_inf : ‚àÄ (a b : Œ±), f (a ‚äì b) = f a ‚äì f b) (map_Sup : ‚àÄ (s : set Œ±), f (has_Sup.Sup s) = ‚®Ü (a : Œ±) (H : a ‚àà s), f a) (map_Inf : ‚àÄ (s : set Œ±), f (has_Inf.Inf s) = ‚®Ö (a : Œ±) (H : a ‚àà s), f a) (map_top : f ‚ä§ = ‚ä§) (map_bot : f ‚ä• = ‚ä•) : order.coframe Œ±
{Œ± : Type u_1} [comm_monoid Œ±] {a b : Œ±} {u : Œ±À£} : ‚Üëu * a ‚à£ b ‚Üî a ‚à£ b
{M : Type u_1} {R : Type u_4} [non_unital_non_assoc_semiring R] [set_like M R] [mul_mem_class M R] {S : M} {a b : R} (ha : a ‚àà add_submonoid.closure ‚ÜëS) (hb : b ‚àà S) : a * b ‚àà add_submonoid.closure ‚ÜëS
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (G : C ‚•§ D) [G.preserves_zero_morphisms] {X Y Z : C} {f : X ‚ü∂ Y} {h : Y ‚ü∂ Z} (w : f ‚â´ h = 0) : category_theory.limits.is_colimit (G.map_cocone (category_theory.limits.cokernel_cofork.of_œÄ h w)) ‚âÉ category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ (G.map h) _)
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul G] (g : G) : G ‚âÉ·µê G
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] (f‚ÇÄ f‚ÇÅ : C(X, Y)) (P : C(X, Y) ‚Üí Prop) : Type (max u v)
(z : ‚ÑÇ) : ‚Üë(z.re) = (z + ‚áë(star_ring_end ‚ÑÇ) z) / 2
{m : Type u_2} {n : Type u_3} {R : Type u_7} {Œ± : Type v} [has_star R] [has_star Œ±] [has_scalar R Œ±] [star_module R Œ±] (c : R) (M : matrix m n Œ±) : (c ‚Ä¢ M).conj_transpose = has_star.star c ‚Ä¢ M.conj_transpose
(S : Type u_3) (G : Type u_4) [sub_neg_monoid G] [set_like S G] : Type
{n : ‚Ñï} {i : fin (n + 2)} {j : fin (n + 1)} (H : i ‚â§ ‚áëfin.cast_succ j) : simplex_category.Œ¥ (‚áëfin.cast_succ i) ‚â´ simplex_category.œÉ j.succ = simplex_category.œÉ j ‚â´ simplex_category.Œ¥ i
(L : first_order.language) (M : Type w) [L.Structure M] : Prop
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J ‚Üí C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f
(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : Type
(M : Type u) [topological_space M] [has_mul M] : Prop
(Œ± : Type u) [topological_space Œ±] : Type u
{Œ± : Sort u} {Œ≤ : Sort v} (e : Œ± ‚âÉ Œ≤) : (Œ± ‚Üí Œ±) ‚âÉ (Œ≤ ‚Üí Œ≤)
{Œ± : Type u} (s : computation Œ±) [h : s.terminates] : Œ±
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_2} (Œ≥ : Type u_3) (fŒ≥ : (Œ£ (a : Œ±), Œ≤ a ‚Üí Œ≥) ‚Üí Œ≥) : W_type Œ≤ ‚Üí Œ≥
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space F] [complete_space E] (g : E ‚Üí‚Çó[ùïú] F) (hg : is_closed ‚Üë(g.graph)) : continuous ‚áëg
 : omega.eqelim (list omega.ee)
(Œ± : Sort u_1) : (punit ‚Üí Œ±) ‚âÉ Œ±
{A : Type v} [ring A] : lie_ring A
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : part Œ±) (g : Œ± ‚Üí part Œ≤) : part Œ≤
(T : Type u) [category_theory.category T] : Type (max u v)
(depth : ‚Ñï) : tactic (tactic.list_Pi tactic.rcases_patt)
{ùïú : Type u_1} {E : Type u_2} [normed_field ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [has_continuous_smul ùïú E] : ‚ãÉ‚ÇÄset_of (bornology.is_vonN_bounded ùïú) = set.univ
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] (Q : Type u_4) [comm_semiring Q] [algebra R Q] [is_localization M Q] : S ‚âÉ‚Çê[R] Q
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {a : Œ±} : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà {a}), f i)) = f a
(C : Type u) : category_theory.free_monoidal_category C ‚•§ (category_theory.discrete ‚àò category_theory.free_monoidal_category.normal_monoidal_object) C ‚•§ (category_theory.discrete ‚àò category_theory.free_monoidal_category.normal_monoidal_object) C
{L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] : L.equiv M N ‚Üí L.embedding M N
{R : Type u_1} [normed_ring R] [complete_space R] : is_open {x : R | is_unit x}
(Œ± : Type u_2) : Type u_2
(R : Type u_1) [comm_semiring R] (X : Type u_2) : has_scalar R (free_algebra.pre R X)
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] {f g : M ‚Üí* N} {s : set M} (h : set.eq_on ‚áëf ‚áëg s) : set.eq_on ‚áëf ‚áëg ‚Üë(submonoid.closure s)
{C : Type v} [category_theory.small_category C] (X : C·µí·µñ) : category_theory.limits.cocone (category_theory.coyoneda.obj X)
{m : Type u_3} {n : Type u_4} {Œ± : Type u_5} [fintype m] [fintype n] [semi_normed_group Œ±] : semi_normed_group (matrix m n Œ±)
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [is_R_or_C ùïÇ] [normed_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] {x y : ùî∏} (hxy : commute x y) : exp ùïÇ (x + y) = exp ùïÇ x * exp ùïÇ y
{M : Type u_3} {N : Type u_4} [mul_zero_one_class M] [mul_zero_one_class N] {f g : M ‚Üí*‚ÇÄ N} (h : f = g) (x : M) : ‚áëf x = ‚áëg x
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] (S : subalgebra R B) (f : A ‚Üí‚Çê[R] B) : subalgebra R A
(d : declaration) : tactic (option string)
(Œ± : Type u_1) [pseudo_emetric_space Œ±] [t0_space Œ±] : emetric_space Œ±
{M : Type u_1} [has_mul M] (p : M) : Prop
(L : first_order.language) : Prop
{G : Type u_1} [group G] {N : Type u_3} [group N] [fintype G] [decidable_eq N] (f : G ‚Üí* N) : fintype ‚Ü•(f.range)
{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_dedekind_domain R] [fintype (class_group R K)] : fintype.card (class_group R K) = 1 ‚Üî is_principal_ideal_ring R
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_lt.lt] {a : Œ±} : 1 < a‚Åª¬π ‚Üî a < 1
 : Type
 : expr ‚Üí tactic (expr √ó expr)
(Œ± : Type u) [add_group Œ±] : Prop
{a : ‚Ñï} (a1 : 1 < a) (n : ‚Ñï) : ‚Ñ§‚àö‚Üë(d a1)
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : generalized_continued_fraction.int_fract_pair K
{Œ± : Type u} [ring Œ±] {a b : Œ±} : a ‚à£ a + b ‚Üî a ‚à£ b
(key : interactive.parse lean.parser.cur_pos) (slow_and_accurate : interactive.parse (optional (lean.parser.tk "?"))) (use_iota_eqn : interactive.parse (optional (lean.parser.tk "!"))) (no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (locat : interactive.parse interactive.types.location) (cfg : interactive.parse (optional tactic.struct_inst)) : tactic unit
{Œπ : Type w} {R : Type u} [ring R] [rank_condition R] {M : Type v} [add_comm_group M] [module R M] {J : set M} (v : basis Œπ R M) (hJ : submodule.span R J = ‚ä§) : cardinal.mk ‚Ü•(set.range ‚áëv) ‚â§ cardinal.mk ‚Ü•J
{R : Type u} [ring R] {s : set R} {p : R ‚Üí Prop} {x : R} (h : x ‚àà subring.closure s) (Hs : ‚àÄ (x : R), x ‚àà s ‚Üí p x) (H0 : p 0) (H1 : p 1) (Hadd : ‚àÄ (x y : R), p x ‚Üí p y ‚Üí p (x + y)) (Hneg : ‚àÄ (x : R), p x ‚Üí p (-x)) (Hmul : ‚àÄ (x y : R), p x ‚Üí p y ‚Üí p (x * y)) : p x
{p : Prop} (a : erased p) : p
{ùïú : Type u_1} {E : Type u_4} {F‚Çó : Type u_7} {G‚Çó : Type u_9} [semi_normed_group E] [semi_normed_group F‚Çó] [semi_normed_group G‚Çó] [nondiscrete_normed_field ùïú] [normed_space ùïú E] [normed_space ùïú F‚Çó] [normed_space ùïú G‚Çó] (R : Type u_2) [semiring R] [module R F‚Çó] [module R G‚Çó] [has_continuous_const_smul R F‚Çó] [has_continuous_const_smul R G‚Çó] [smul_comm_class ùïú R F‚Çó] [smul_comm_class ùïú R G‚Çó] : (E ‚ÜíL[ùïú] F‚Çó) √ó (E ‚ÜíL[ùïú] G‚Çó) ‚âÉ‚Çó·µ¢[R] E ‚ÜíL[ùïú] F‚Çó √ó G‚Çó
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [nondiscrete_normed_field R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [normed_group F] [normed_space R F] [topological_space B] [topological_space (bundle.total_space E)] [Œ† (x : B), topological_space (E x)] [topological_vector_bundle R F E] (e : topological_vector_bundle.trivialization R F E) (b : B) (hb : b ‚àà e.to_fiber_bundle_trivialization.base_set) : E b ‚âÉL[R] F
{X : Top} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : (Top.presheaf.sheaf_condition.pairwise_to_opens_le_cover U).final
{R : Type u_1} [comm_monoid R] : star_semigroup R
{Œ± : Type u_1} {Œπ : Type u_4} [linear_order Œ±] [decidable_eq Œπ] (f : Œπ ‚Üí Œ±) {p : finset Œπ ‚Üí Prop} (s : finset Œπ) (h0 : p ‚àÖ) (step : ‚àÄ (a : Œπ) (s : finset Œπ), a ‚àâ s ‚Üí (‚àÄ (x : Œπ), x ‚àà s ‚Üí f a ‚â§ f x) ‚Üí p s ‚Üí p (has_insert.insert a s)) : p s
{Œ± : Type u} (p : Œ± ‚Üí Type v) (q : Œ± ‚Üí Prop) (h : ‚àÄ (x : Œ±), p x ‚Üí q x) : (Œ£ (x : subtype q), p ‚Üëx) ‚âÉ Œ£ (x : Œ±), p x
 : user_attribute (name_map (list ‚Ñï)) (list ‚Ñï)
{K : Type u_1} [division_ring K] (s : seq (generalized_continued_fraction.pair K)) (n : ‚Ñï) : seq (generalized_continued_fraction.pair K)
{K : Type u} [field K] (S : subfield K) (s : set K) (hs : s = ‚ÜëS) : subfield K
 : lean.parser string
(t : tactic.interactive.itactic) : tactic unit
 : Type
{M : Type u_1} [add_monoid M] {Œπ : Type u_2} [hŒπ : nonempty Œπ] {s : Œπ ‚Üí set M} (hs : ‚àÄ (i : Œπ), is_add_submonoid (s i)) (directed : ‚àÄ (i j : Œπ), ‚àÉ (k : Œπ), s i ‚äÜ s k ‚àß s j ‚äÜ s k) : is_add_submonoid (‚ãÉ (i : Œπ), s i)
(Œ± : Type u) : Type u
{Œ± : Type u_1} {Œπ : Type u_2} {Œπ' : Type u_3} [lattice Œ±] [order_bot Œ±] {s : set Œπ'} {g : Œπ' ‚Üí finset Œπ} {f : Œπ ‚Üí Œ±} (hs : s.pairwise_disjoint (Œª (i' : Œπ'), (g i').sup f)) (hg : ‚àÄ (i : Œπ'), i ‚àà s ‚Üí ‚Üë(g i).pairwise_disjoint f) : (‚ãÉ (i : Œπ') (H : i ‚àà s), ‚Üë(g i)).pairwise_disjoint f
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] : CommMon_ (C ‚•§ D) ‚âå C ‚•§ CommMon_ D
{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b‚Åª¬π
{E : Type u_1} (c : E) : Type
{Œ± : Type u_1} [partial_order Œ±] : subsingleton (pred_order Œ±)
(h : expr) (hs : list expr) : tactic bool
{M : Type u_1} [add_monoid M] {A : Type u_2} [set_like A M] [add_submonoid_class A M] (S : A) : has_scalar ‚Ñï ‚Ü•S
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [topological_space Œ±] [pseudo_metric_space Œ≤] [pseudo_metric_space Œ≥] (G : Œ≤ ‚Üí Œ≥) {C : nnreal} (H : lipschitz_with C G) (f : bounded_continuous_function Œ± Œ≤) : bounded_continuous_function Œ± Œ≥
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_ring k] [group G] [add_comm_group V] [module k V] (œÅ : representation k G V) (g : G) : k
(x : ‚Ñ§) : ‚Üë(x.nat_abs) ^ 2 = x ^ 2
{Œì : Type u_1} [inhabited Œì] (b : Œì) (T : turing.tape Œì) : turing.tape Œì
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (L' : lie_subalgebra R L) : ‚Ü•L' ‚Üí‚Çó‚ÅÖR‚ÅÜ L
(R : Type u) (M : Type v) [comm_ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] (N : Type v) [add_comm_group N] [module R N] [module.free R N] : module.rank R (tensor_product R M N) = module.rank R M * module.rank R N
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {r : R} (h : same_ray R x y) (hr : 0 < r) : same_ray R (r ‚Ä¢ x) y
{Œ± : Type u_1} [decidable_eq Œ±] (s : finset Œ±) : finset (equiv.perm Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (S : D) (T : C ‚•§ D) : Type (max u‚ÇÅ v‚ÇÇ)
{Œ± J : Type u} [category_theory.small_category J] [category_theory.fin_category J] [semilattice_sup Œ±] [order_bot Œ±] (F : J ‚•§ Œ±) : category_theory.limits.colimit_cocone F
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (ùïú' : Type u_10) [normed_ring ùïú'] [normed_algebra ùïú ùïú'] : ùïú' ‚ÜíL[ùïú] ùïú' ‚ÜíL[ùïú] ùïú'
(Œ± : fin 2 ‚Üí Type u) : (Œ† (i : fin 2), Œ± i) ‚âÉ Œ± 0 √ó Œ± 1
(Œ± : Type u_1) [non_assoc_ring Œ±] : ‚Ñ§ ‚Üí+* Œ±
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) {A A' B B' : C} [category_theory.limits.has_binary_coproduct A B] [category_theory.limits.has_binary_coproduct A' B'] [category_theory.limits.has_binary_coproduct (F.obj A) (F.obj B)] [category_theory.limits.has_binary_coproduct (F.obj A') (F.obj B')] (f : A ‚ü∂ A') (g : B ‚ü∂ B') [category_theory.is_iso (category_theory.limits.coprod_comparison F A B)] [category_theory.is_iso (category_theory.limits.coprod_comparison F A' B')] : category_theory.inv (category_theory.limits.coprod_comparison F A B) ‚â´ category_theory.limits.coprod.map (F.map f) (F.map g) = F.map (category_theory.limits.coprod.map f g) ‚â´ category_theory.inv (category_theory.limits.coprod_comparison F A' B')
 : tactic unit
{S : Type u} [pgame.state S] (n : ‚Ñï) {s : S} (h : pgame.state.turn_bound s ‚â§ n) (t : (pgame.of_aux n s h).right_moves) : ((pgame.of_aux n s h).move_right t).relabelling (pgame.of_aux (n - 1) ‚Üë(‚áë(pgame.right_moves_of_aux n h) t) _)
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] {X Y Z : C} (a : X ‚ü∂ Z) (b : Y ‚ü∂ Z) [category_theory.mono a] [category_theory.mono b] : category_theory.limits.has_limit (category_theory.limits.cospan a b)
(E : Type u_6) [add_comm_group E] [has_norm E] : Prop
{Œ± : Sort u} : Œ± ‚Üí Œ±·µí·µñ
{Œ± : Type u} [ring Œ±] : has_neg Œ±À£
{Œ± : Type u} {Œ≤ : Type v} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} (hinf : a ‚â§ f.liminf u) (hsup : f.limsup u ‚â§ a) (h : filter.is_bounded_under has_le.le f u . "is_bounded_default") (h' : filter.is_bounded_under ge f u . "is_bounded_default") : filter.tendsto u f (nhds a)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {r t : category_theory.limits.cocone F} (P : category_theory.limits.is_colimit r) [i : category_theory.is_iso (P.desc t)] : category_theory.limits.is_colimit t
{M : Type u_6} {N : Type u_7} [has_add M] [has_add N] (h : M ‚âÉ+ N) : N ‚âÉ+ M
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_initial X) (f g : X ‚ü∂ Y) : f = g
 : Type
{Œ± : Type u} {Œ≤ : Type v} (m : Œ± ‚Üí Œ≤) (f : filter Œ±) : filter Œ≤
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : set M
{M : Type u_5} [add_comm_monoid M] (h : module ‚Ñï M) (n : ‚Ñï) (x : M) : n ‚Ä¢ x = n ‚Ä¢ x
{Œ± : Type u_1} {n : ‚Ñï} : Œ± ‚Üí sym.sym' Œ± n ‚Üí sym.sym' Œ± n.succ
{ùïú : Type u_1} [linear_ordered_field ùïú] {x : ùïú} {s : set ùïú} (hx : x ‚àà s) : star_convex ùïú x s ‚Üí s.ord_connected
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : has_coe (category_theory.over P) (category_theory.abelian.pseudoelement P)
{L : first_order.language} (T : L.Theory) : Type (max u v (w+1))
{ùïú : Type u_1} {E : Type u_2} [semi_normed_ring ùïú] [add_comm_group E] [module ùïú E] {t t' : topological_space E} (h : t ‚â§ t') {s : set E} (hs : bornology.is_vonN_bounded ùïú s) : bornology.is_vonN_bounded ùïú s
(R : Type u_1) [comm_ring R] [is_domain R] [decidable_eq R] [fintype R] : field R
 : sSet ‚•§ Top
(q : turing.partrec_to_TM2.Œõ') : turing.partrec_to_TM2.Œõ'
{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : isometry f) (x y : Œ±) : has_dist.dist (f x) (f y) = has_dist.dist x y
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) [category_theory.injective Z] : category_theory.InjectiveResolution Z
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} (A B : T.algebra) : Type v‚ÇÅ
(Œ± : Type u) {Œ≤ : Type v} [add_group Œ±] [add_action Œ± Œ≤] (b : Œ≤) : ‚Ü•(add_action.orbit Œ± b) √ó ‚Ü•(add_action.stabilizer Œ± b) ‚âÉ Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚ÜíL[ùïú] F) [complete_space F] [complete_space E] (surj : function.surjective ‚áëf) : is_open_map ‚áëf
 : NonemptyFinLinOrd ‚âå NonemptyFinLinOrd
{J : Type u‚ÇÅ} [category_theory.category J] (j‚ÇÅ j‚ÇÇ : J) : Prop
(no_defaults : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (t : tactic.interactive.itactic) : tactic.interactive.itactic
{M : Type u_1} [add_comm_monoid M] (c : add_con M) : add_comm_monoid c.quotient
 : cardinal ‚Üí ordinal
 : real.sin (real.pi / 6) = 1 / 2
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {Z : C} {h : Y ‚ü∂ Z} (t : category_theory.is_split_coequalizer f g h) : category_theory.limits.cofork f g
{G : Type u_1} [add_group G] {H : add_subgroup G} {S : set G} (hS : S ‚àà add_subgroup.right_transversals ‚ÜëH) : quotient (quotient_add_group.right_rel H) ‚âÉ ‚Ü•S
{M : Type u_4} [topological_space M] [monoid M] [has_continuous_mul M] (s : submonoid M) : submonoid M
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (h : category_theory.presieve.is_sheaf_for P ‚áëS) (f : S.functor ‚ü∂ P) : S.functor_inclusion ‚â´ h.extend f = f
{Œ± : Type u_1} [topological_space Œ±] (B : set (topological_space.opens Œ±)) : Prop
{Œ± : Type u} [topological_space Œ±] (s : set Œ±) : Prop
{n : ‚Ñï} {C : fin2 n.succ ‚Üí Sort u} (H1 : C fin2.fz) (H2 : Œ† (n_1 : fin2 n), C n_1.fs) (i : fin2 n.succ) : C i
(q : ‚Ñö) : (generalized_continued_fraction.of q).terminates
{R : Type v} [comm_ring R] {n : ‚Ñï} {A B : matrix (fin (n + 1)) (fin (n + 1)) R} (c : fin n ‚Üí R) (A_zero : ‚àÄ (j : fin (n + 1)), A 0 j = B 0 j) (A_succ : ‚àÄ (i : fin n) (j : fin (n + 1)), A i.succ j = B i.succ j + c i * A (‚áëfin.cast_succ i) j) : A.det = B.det
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (x y : M) : Prop
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_coequalizer f g] [category_theory.limits.has_coequalizer (G.map f) (G.map g)] : category_theory.limits.coequalizer (G.map f) (G.map g) ‚ü∂ G.obj (category_theory.limits.coequalizer f g)
{Œ± : Type u_2} [has_zero Œ±] [has_add Œ±] : has_scalar ‚Ñï (set Œ±)
{R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [ring R] [add_comm_group M] [add_comm_group M‚ÇÇ] [module R M] [module R M‚ÇÇ] (f : M ‚Üí‚Çó[R] M‚ÇÇ) (hf : function.surjective ‚áëf) : (M ‚ß∏ f.ker) ‚âÉ‚Çó[R] M‚ÇÇ
{E : Type u} [normed_group E] [normed_space ‚Ñù E] [complete_space E] (f g : ‚Ñù √ó ‚Ñù ‚Üí E) (f' g' : ‚Ñù √ó ‚Ñù ‚Üí (‚Ñù √ó ‚Ñù ‚ÜíL[‚Ñù] E)) (a b : ‚Ñù √ó ‚Ñù) (hle : a ‚â§ b) (s : set (‚Ñù √ó ‚Ñù)) (hs : s.countable) (Hcf : continuous_on f (set.Icc a b)) (Hcg : continuous_on g (set.Icc a b)) (Hdf : ‚àÄ (x : ‚Ñù √ó ‚Ñù), x ‚àà set.Ioo a.fst b.fst √óÀ¢ set.Ioo a.snd b.snd  s ‚Üí has_fderiv_at f (f' x) x) (Hdg : ‚àÄ (x : ‚Ñù √ó ‚Ñù), x ‚àà set.Ioo a.fst b.fst √óÀ¢ set.Ioo a.snd b.snd  s ‚Üí has_fderiv_at g (g' x) x) (Hi : measure_theory.integrable_on (Œª (x : ‚Ñù √ó ‚Ñù), ‚áë(f' x) (1, 0) + ‚áë(g' x) (0, 1)) (set.Icc a b) measure_theory.measure_space.volume) : ‚à´ (x : ‚Ñù √ó ‚Ñù) in set.Icc a b, ‚áë(f' x) (1, 0) + ‚áë(g' x) (0, 1) = (((‚à´ (x : ‚Ñù) in a.fst..b.fst, g (x, b.snd)) - ‚à´ (x : ‚Ñù) in a.fst..b.fst, g (x, a.snd)) + ‚à´ (y : ‚Ñù) in a.snd..b.snd, f (b.fst, y)) - ‚à´ (y : ‚Ñù) in a.snd..b.snd, f (a.fst, y)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {E' : Type u_6} [normed_group E'] [normed_space ùïú E'] {F' : Type u_7} [normed_group F'] [normed_space ùïú F'] {f : E ‚Üí F} {g : E' ‚Üí F'} {p : E √ó E'} (hf : cont_diff_at ùïú n f p.fst) (hg : cont_diff_at ùïú n g p.snd) : cont_diff_at ùïú n (prod.map f g) p
(hs : expr_set) : tactic (‚Ñï √ó list expr)
{E : Type u_2} {ùïú : Type u_3} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] {s : set E} (hs : convex ùïú s) {x y : E} (hx : x ‚àà closure s) (hy : x + y ‚àà interior s) {t : ùïú} (ht : t ‚àà set.Ioc 0 1) : x + t ‚Ä¢ y ‚àà interior s
(Œ± : Type u_3) [uniform_space Œ±] [add_group Œ±] : Prop
{Œ± : Type u} {s : set Œ±} : s.countable ‚Üî ‚àÉ (f : Œ± ‚Üí ‚Ñï), set.inj_on f s
 : tactic (list expr)
(M : Type u) [has_mul M] : Magma
{Œ± : Type u_1} {Œ≥ : Type u_3} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] {f : Œ± ‚Üí Œ≥} (hf : continuous f) : measurable f
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] (D : Type u‚ÇÇ) [category_theory.category D] [category_theory.monoidal_category D] : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{Œ± : Type u_1} (g : set (set Œ±)) (hg : {t : set Œ± | measurable_set t} = g) : measurable_space Œ±
{C : Type u} [category_theory.category C] {X Y Z : category_theory.with_terminal C} : X.hom Y ‚Üí Y.hom Z ‚Üí X.hom Z
(e : expr) : tactic (list (name √ó expr))
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G H : D ‚•§ C} (adj : F ‚ä£ G) (iso : G ‚âÖ H) : F ‚ä£ H
{Œ± : Sort u} {Œ≤ : Sort v} {Œ≥ : Sort w} {Œ¥ : Sort u_1} (ab : Œ± ‚âÉ Œ≤) (cd : Œ≥ ‚âÉ Œ¥) : Œ± ‚âÉ Œ≥ ‚âÉ (Œ≤ ‚âÉ Œ¥)
{R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [semiring R] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] [semi_normed_group E] [semi_normed_group E‚ÇÇ] [module R E] [module R‚ÇÇ E‚ÇÇ] : has_coe_to_fun (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) (Œª (_x : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ), E ‚Üí E‚ÇÇ)
(Œ± : Type u_2) [preorder Œ±] : Type u_2
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (q n m : ‚Ñï) (hnm : algebraic_topology.dold_kan.c.rel m n) {X Y : category_theory.simplicial_object C} (f : X ‚ü∂ Y) : f.app (opposite.op (simplex_category.mk n)) ‚â´ algebraic_topology.dold_kan.hœÉ' q n m hnm = algebraic_topology.dold_kan.hœÉ' q n m hnm ‚â´ f.app (opposite.op (simplex_category.mk m))
(S : Type u‚ÇÇ) [comm_semiring S] {A : Type u‚ÇÉ} [semiring A] [algebra S A] {B : Type u‚ÇÑ} [semiring B] [algebra S B] {s : A ‚Üí A ‚Üí Prop} : {f // ‚àÄ ‚¶Éx y : A‚¶Ñ, s x y ‚Üí ‚áëf x = ‚áëf y} ‚âÉ (ring_quot s ‚Üí‚Çê[S] B)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] : Mon_ (C ‚•§ D) ‚•§ C ‚•§ Mon_ D
(e : expr) : tactic (native.rb_set string √ó native.rb_map expr format)
(R L : Type u) [comm_ring R] [comm_ring L] [is_domain L] [algebra R L] [no_zero_smul_divisors R L] (halg : algebra.is_algebraic R L) : cardinal.mk L ‚â§ linear_order.max (cardinal.mk R) cardinal.aleph_0
(N : Type u_2) [add_monoid N] : Prop
{ùïú : Type u} [nondiscrete_normed_field ùïú] {E : Type v} [normed_group E] [normed_space ùïú E] {F : Type w} [normed_group F] [normed_space ùïú F] [complete_space ùïú] {PE : Type u_1} {PF : Type u_2} [metric_space PE] [normed_add_torsor E PE] [metric_space PF] [normed_add_torsor F PF] [finite_dimensional ùïú E] (f : PE ‚âÉ·µÉ[ùïú] PF) : PE ‚âÉ‚Çú PF
 : tactic.unify_equations.unification_step
{Œ± : Type u_1} : Œ± ‚Üí Œ±À¢ ∏·µê
(C : Type u) : Type u
 : tactic.list_Pi tactic.rcases_patt ‚Üí tactic.list_Pi tactic.rcases_patt
{Œ± : Type u_5} {Œ≤ : Type u_6} [non_assoc_semiring Œ±] [non_assoc_semiring Œ≤] (self : Œ± ‚Üí+* Œ≤) : Œ± ‚Üí+ Œ≤
(eqv ty : expr) (cfg : tactic.equiv_rw_cfg) : tactic expr
{m : Type u ‚Üí Type u} [monad m] {Œ± : Type u} : list (m Œ±) ‚Üí tactic.mllist m Œ±
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) : set.maps_to f (function.fixed_points (g ‚àò f)) (function.fixed_points (f ‚àò g))
{Œ≥ : Type} (local_c : widget.tc widget.local_collection Œ≥) (target_c : widget.tc expr Œ≥) : widget.tc unit Œ≥
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C
(Œ± : Type u_1) (Œ≤ : Type u_2) [is_empty Œ≤] : Œ± ‚äï Œ≤ ‚âÉ Œ±
{G : Type u_1} [add_group G] (H : add_subgroup G) : has_neg ‚Ü•H
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] (M : category_theory.Mat_ C) : M ‚âÖ ‚®Å Œª (i : M.Œπ), (category_theory.Mat_.embedding C).obj (M.X i)
(R : Type u_1) [rack R] : R ‚âÉ R
 : category_theory.limits.walking_parallel_pair ‚•§ category_theory.limits.walking_parallel_pair·µí·µñ
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] (T : category_theory.triangulated.triangle C) : category_theory.triangulated.triangle C
{R : Type u} {Œì‚ÇÄ : Type v} [ring R] [linear_ordered_comm_group_with_zero Œì‚ÇÄ] (v : valuation R Œì‚ÇÄ) : subring R
{Œ± : Type u} [topological_space Œ±] (f : filter Œ±) [f.ne_bot] : Œ±
{Œ± : Type u_6} : mul_action (function.End Œ±) Œ±
 : ‚Ñï ‚Üí smt_tactic unit ‚Üí smt_tactic unit
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s‚ÇÅ s‚ÇÇ : affine_subspace ‚Ñù P} [nonempty ‚Ü•s‚ÇÅ] [complete_space ‚Ü•(s‚ÇÅ.direction)] (hle : s‚ÇÅ ‚â§ s‚ÇÇ) {p : P} (hp : p ‚àà s‚ÇÇ) : ‚áë(euclidean_geometry.reflection s‚ÇÅ) p ‚àà s‚ÇÇ
(n : ‚Ñï) [has_zero (fin n)] : Type
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] [has_zero Œ≤] [compact_space Œ±] : C(Œ±, Œ≤) ‚âÉ zero_at_infty_continuous_map Œ± Œ≤
{Œ± : Type u_1} [add_semigroup Œ±] [partial_order Œ±] [contravariant_class Œ± Œ± (function.swap has_add.add) has_le.le] : add_right_cancel_semigroup Œ±
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b c : Œ±} : b < -a + c ‚Üí a + b < c
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) (P : Type u_6) (Q : Type u_7) [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [add_comm_monoid Q] [module R M] [module R N] [module R P] [module R Q] : tensor_product R (tensor_product R M N) (tensor_product R P Q) ‚âÉ‚Çó[R] tensor_product R (tensor_product R M P) (tensor_product R N Q)
(assert : interactive.parse (optional (lean.parser.tk "using" *> (lean.parser.pexpr std.prec.max)))) : tactic unit
(s : string) (xs : list string) (n : ‚Ñï) : string
{R‚ÇÅ : Type u_1} [semiring R‚ÇÅ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] [has_continuous_add M‚ÇÅ] : has_faithful_smul (M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) M‚ÇÅ
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {n : with_top ‚Ñï} (h : cont_diff ùïú n f) (hn : 1 ‚â§ n) : continuous (Œª (p : E √ó E), ‚áë(fderiv ùïú f p.fst) p.snd)
{R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra R A] [algebra R B] (f : A ‚Üí‚Çê[R] B) : Prop
{X Y : Type u} [ring X] [ring Y] : X ‚âÉ+* Y ‚âÖ Ring.of X ‚âÖ Ring.of Y
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D·µí·µñ) [category_theory.limits.preserves_colimits F] : category_theory.limits.preserves_limits F.unop
{Œ± : Type u} [ordered_comm_monoid Œ±] {Œ≤ : Type u_1} [has_one Œ≤] [has_mul Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : ordered_comm_monoid Œ≤
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [discrete_topology Œ±] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (hf : ‚àÄ (a : Œ±), continuous (f a)) : continuous (function.uncurry f)
 : num ‚Üí num ‚Üí num
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w‚ÇÅ} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] [Œ† (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)·µí·µñ (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] {G : Type (max v u) ‚•§ D} (adj : G ‚ä£ category_theory.forget D) : category_theory.Sheaf.compose_and_sheafify_from_types J G ‚ä£ category_theory.Sheaf_forget J
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddGroup) : has_neg ‚Ü•(AddGroup.filtered_colimits.G F)
{L : first_order.language} {M : Type w} [nonempty M] [L.Structure M] : L.skolem‚ÇÅ.Structure M
(M : Type u_1) (Œ± : Type u_2) [monoid M] [mul_action M Œ±] {Œπ : Sort u_3} {P : Œπ ‚Üí submonoid M} : mul_action.fixed_points ‚Ü•(supr P) Œ± = ‚ãÇ (i : Œπ), mul_action.fixed_points ‚Ü•(P i) Œ±
(G : Type u_1) [add_group G] : set G
{R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra R A] [algebra R B] (f : A ‚Üí‚Çê[R] B) : Prop
(R : Type u1) [comm_semiring R] (M : Type u2) [add_comm_monoid M] [module R M] : Type (max u1 u2)
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] : category_theory.monoidal_functor (category_theory.center C) C
{K : Type u_1} {n : ‚Ñï} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] {m : ‚Ñï} (m_lt_n : m < n) : (generalized_continued_fraction.squash_seq s n).nth m = s.nth m
(ùïú : Type u_1) {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field ùïú] [normed_space ùïú E] (ùïú' : Type u_10) [normed_field ùïú'] [normed_algebra ùïú ùïú'] [normed_space ùïú' E] [is_scalar_tower ùïú ùïú' E] : ùïú' ‚ÜíL[ùïú] E ‚ÜíL[ùïú] E
{M : Type u_1} [add_monoid M] (S : add_submonoid M) : add_submonoid M
{ùïú : Type u_1} {E : Type u_2} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] {p‚ÇÅ p‚ÇÇ : formal_multilinear_series ùïú ùïú E} {f : ùïú ‚Üí E} {x : ùïú} (h‚ÇÅ : has_fpower_series_at f p‚ÇÅ x) (h‚ÇÇ : has_fpower_series_at f p‚ÇÇ x) : p‚ÇÅ = p‚ÇÇ
{C : Type u} [category_theory.category C] : category_theory.limits.is_terminal category_theory.with_terminal.star
{ùïú : Type u_1} {E : Type u_2} [normed_field ùïú] [add_comm_group E] [module ùïú E] (f : E ‚Üí‚Çó[ùïú] ùïú) : seminorm ùïú E
(F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] : intermediate_field F E
 : two_pointing Prop
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) : Œ≤ ‚âÉ. Œ±
(p q r : ‚Ñï+) : 1 < ADE_inequality.sum_inv {p, q, r} ‚Üî ADE_inequality.admissible {p, q, r}
{Œ± : Type u} (t : tactic Œ±) : tactic (tactic_result Œ±)
{R : Type u} {A : Type w} [comm_semiring R] [semiring A] [module R A] (h‚ÇÅ : ‚àÄ (r : R) (x y : A), r ‚Ä¢ x * y = r ‚Ä¢ (x * y)) (h‚ÇÇ : ‚àÄ (r : R) (x y : A), x * r ‚Ä¢ y = r ‚Ä¢ (x * y)) : algebra R A
 : native.float
{X : Top} {x : ‚Ü•X} (U V : topological_space.open_nhds x) : U ‚äì V ‚ü∂ U
{Œ± : Type u} [has_sizeof Œ±] (shr : Œ† (x : Œ±), lazy_list {y // slim_check.sizeof_lt y x}) : slim_check.shrink_fn (list Œ±)
{Œ± : Type u_1} {p : Œ± ‚Üí Prop} [encodable Œ±] [decidable_pred p] (h : ‚àÉ (x : Œ±), p x) : Œ±
{Œ± : Type u_3} {Œ≤ : Type u_4} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : monotone f) (h : ‚àÄ (b : Œ≤), ‚àÉ (a : Œ±), f a ‚â§ b) : filter.tendsto f filter.at_bot filter.at_bot
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] (i j : D.to_glue_data.J) (U : topological_space.opens ‚Ü•((D.to_glue_data.U i).carrier)) : (D.to_glue_data.U i).presheaf.obj (opposite.op U) ‚ü∂ (D.to_glue_data.U j).presheaf.obj (opposite.op ((topological_space.opens.map (D.to_glue_data.Œπ j).base).obj (_.functor.obj U)))
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {f : F ‚Üí G} {x : E} {y : F} (hf : cont_diff_at ùïú n f y) : cont_diff_at ùïú n (Œª (x : E √ó F), f x.snd) (x, y)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [unique Œ±] : Œ≤ ‚âÉ‚Çú C(Œ±, Œ≤)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) (s : topological_space.opens Œ±) [nonempty ‚Ü•s] : local_homeomorph ‚Ü•s Œ≤
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (Œ∏ : real.angle) : hb.oangle x (‚áë(hb.rotation Œ∏) y) = hb.oangle x y + Œ∏
{n : ‚Ñï} {A : Type u} {Œ± : typevec n} (x : mvqpf.const n A Œ±) : A
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] {c : category_theory.limits.cocone (category_theory.limits.parallel_family f)} (i : category_theory.limits.is_colimit c) : category_theory.epi (c.Œπ.app category_theory.limits.walking_parallel_family.one)
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid M'] [module R M'] (b : basis Œπ R M) (S : Type u_9) [semiring S] [module S M'] [smul_comm_class R S M'] : (Œπ ‚Üí M') ‚âÉ‚Çó[S] M ‚Üí‚Çó[R] M'
{Œ± : Type u} [e : pseudo_emetric_space Œ±] (h : ‚àÄ (x y : Œ±), has_edist.edist x y ‚â† ‚ä§) : pseudo_metric_space Œ±
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P (n + 1)) (i : fin (n + 2)) : finite_dimensional.finrank ‚Ñù ‚Ü•((s.altitude i).direction) = 1
(x y : pgame) : (x * y).equiv (y * x)
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] : has_coe_to_fun (pseudo_epimorphism Œ± Œ≤) (Œª (_x : pseudo_epimorphism Œ± Œ≤), Œ± ‚Üí Œ≤)
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [densely_ordered Œ±] {Œ¥ : Type u_1} [linear_order Œ¥] [topological_space Œ¥] [order_closed_topology Œ¥] {f : Œ± ‚Üí Œ¥} {s : set Œ±} [s.ord_connected] (hs : s.nonempty) (hf : continuous_on f s) (hbot : filter.tendsto (Œª (x : ‚Ü•s), f ‚Üëx) filter.at_bot filter.at_bot) (htop : filter.tendsto (Œª (x : ‚Ü•s), f ‚Üëx) filter.at_top filter.at_top) : set.surj_on f s set.univ
{M : Type u_1} {A : Type u_5} [has_add M] [set_like A M] [hA : add_mem_class A M] (S' : A) : add_hom ‚Ü•S' M
{E : Type u_1} [inner_product_space ‚Ñù E] {n : ‚Ñï} [fact (finite_dimensional.finrank ‚Ñù E = n + 1)] : cont_mdiff (model_with_corners_self ‚Ñù (euclidean_space ‚Ñù (fin n))) (model_with_corners_self ‚Ñù E) ‚ä§ coe
(p : ‚Ñù √ó ‚Ñù) (hp : 0 < p.fst) : has_strict_fderiv_at (Œª (x : ‚Ñù √ó ‚Ñù), x.fst ^ x.snd) ((p.snd * p.fst ^ (p.snd - 1)) ‚Ä¢ continuous_linear_map.fst ‚Ñù ‚Ñù ‚Ñù + (p.fst ^ p.snd * real.log p.fst) ‚Ä¢ continuous_linear_map.snd ‚Ñù ‚Ñù ‚Ñù) p
 : inhabited tactic.decl_reducibility
{Œ± : Type u_1} [normed_division_ring Œ±] {a : Œ±} (ha : a ‚â† 0) : filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
(r : tactic.tauto_state) : expr ‚Üí expr ‚Üí tactic expr
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (p : formal_multilinear_series ùïú E F) (x : E) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) {X : C} (S : category_theory.presieve X) : category_theory.presieve (F.obj X)
{Œ± : Type u_1} [preorder Œ±] (h : ‚àÄ (a b : Œ±), (set.Icc a b).finite) : locally_finite_order Œ±
(cfg : linarith.linarith_config) (hyps : list expr) (pref_type : option expr) : tactic unit
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [mul_zero_class Œ≤] : has_mul (Œ± ‚Üí‚ÇÄ Œ≤)
{R : Type u} [comm_ring R] {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group N] [module R N] [lie_ring_module L N] [lie_module R L N] (M' : lie_submodule R L M) (N' : lie_submodule R L N) : tensor_product R ‚Ü•M' ‚Ü•N' ‚Üí‚Çó‚ÅÖR,L‚ÅÜ tensor_product R M N
{Œ± : Type u_1} [has_mul Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {b c : Œ±} (bc : b < c) (a : Œ±) : a * b < a * c
(Œ± : Sort u_1) [h : nonempty Œ±] : Œ±
(d : declaration) : tactic (option string)
(G : pgame) : Prop
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ Ring AddCommGroup)
 : expr ‚Üí tactic (list string)
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x y z : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (hz : z ‚â† 0) : hb.oangle x z - hb.oangle y z = hb.oangle x y
{n : ‚Ñï} (i : fin (n + 1)) : simplex_category.mk (n + 1) ‚ü∂ simplex_category.mk n
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [category_theory.limits.has_kernel f] [category_theory.mono g] : category_theory.limits.kernel (f ‚â´ g) ‚âÖ category_theory.limits.kernel f
{Œ± : Type u} [uniform_space Œ±] {f : filter Œ±} (hf : cauchy f) {U : ‚Ñï ‚Üí set (Œ± √ó Œ±)} (U_mem : ‚àÄ (n : ‚Ñï), U n ‚àà uniformity Œ±) (n : ‚Ñï) : set Œ±
(ùïÇ : Type u_1) {ùî∏ : Type u_2} [is_R_or_C ùïÇ] [normed_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] (x : ùî∏) : invertible (exp ùïÇ x)
(A : Type u_4) [comm_ring A] [is_domain A] {L : Type u_6} [field L] [algebra A L] (C : Type u_7) [comm_ring C] [is_domain C] [algebra C L] [is_integral_closure C A L] [algebra A C] [is_scalar_tower A C L] (alg : algebra.is_algebraic A L) (inj : ‚àÄ (x : A), ‚áë(algebra_map A L) x = 0 ‚Üí x = 0) : is_fraction_ring C L
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) (s : finmap Œ≤) : option (Œ≤ a) √ó finmap Œ≤
{Œ± : Type u} [preorder Œ±] (a : Œ±) : a ‚â§ a
{G : Type u_1} [add_group G] (H : add_subgroup G) : add_subgroup G
{Œπ : Type v} (Œ± : Œπ ‚Üí Top) : category_theory.limits.is_limit (Top.pi_fan Œ±)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cocone F} (h : category_theory.limits.is_colimit t) (s : category_theory.limits.cocone F) : t ‚ü∂ s
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (P : D ‚Üí Prop) (F : C ‚•§ D) (hF : ‚àÄ (X : C), P (F.obj X)) : C ‚•§ {X // P X}
{E : Type u_1} {PE : Type u_2} [normed_group E] [normed_space ‚Ñù E] [metric_space PE] [normed_add_torsor E PE] {F : Type u_3} {PF : Type u_4} [normed_group F] [normed_space ‚Ñù F] [metric_space PF] [normed_add_torsor F PF] (f : PE ‚âÉ·µ¢ PF) (x y : PE) : ‚áëf (midpoint ‚Ñù x y) = midpoint ‚Ñù (‚áëf x) (‚áëf y)
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] : P1 √ó P2 ‚Üí·µÉ[k] P2
 : linter
{E : Type u_1} (R : Type u_2) (S : Type u_3) [add_comm_group E] [division_ring R] [division_ring S] [module R E] [module S E] (n : ‚Ñï) (x : E) : (‚Üën)‚Åª¬π ‚Ä¢ x = (‚Üën)‚Åª¬π ‚Ä¢ x
 : user_attribute unit (option name)
(K : Type u) (L : Type v) (M : Type w) [field K] [field L] [algebra K L] [field M] [algebra K M] [is_alg_closed M] (hL : algebra.is_algebraic K L) : Type (max v w)
{Œ± : Type u_1} (s : set Œ±) [conditionally_complete_linear_order Œ±] [inhabited ‚Ü•s] [s.ord_connected] : conditionally_complete_linear_order ‚Ü•s
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) {Z : C} (l : Z ‚ü∂ Y) (i : X ‚âÖ Z) (h : i.hom ‚â´ l = f) {s : category_theory.limits.cokernel_cofork f} (hs : category_theory.limits.is_colimit s) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ (category_theory.limits.cofork.œÄ s) _)
{Œ± : Type u} {Œ≤ : Type v} (f : ultrafilter Œ±) (m : Œ± ‚Üí ultrafilter Œ≤) : ultrafilter Œ≤
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a b : Œ±} (ha : a < 1) (hb : b < 1) : a * b < 1
{Œ± : Type u_1} (l : ordnode Œ±) (x : Œ±) (r : ordnode Œ±) : ordnode Œ±
(n e : expr) : tactic expr
{Œπ : Type w} {Œπ' : Type w'} {R : Type u} [ring R] [invariant_basis_number R] {M : Type v} [add_comm_group M] [module R M] (v : basis Œπ R M) (v' : basis Œπ' R M) : Œπ ‚âÉ Œπ'
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_4} [fintype Œπ] [decidable_eq Œπ] [nontrivial R] (e : basis Œπ R M) : orientation R M Œπ
 : pos_num ‚Üí pos_num
{C : Type u} [category_theory.category C] (X : C) : category_theory.discrete punit ‚•§ C
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (H : left_commutative f) (b : Œ≤) (s : multiset Œ±) : Œ≤
 : widget.tc unit empty
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] : ordnode Œ± ‚Üí ordnode Œ±
{G : Type u_1} [add_group G] {Œπ : Type u_2} [hfin : fintype Œπ] {H : Œπ ‚Üí add_subgroup G} (hcomm : ‚àÄ (i j : Œπ), i ‚â† j ‚Üí ‚àÄ (x y : G), x ‚àà H i ‚Üí y ‚àà H j ‚Üí add_commute x y) : (Œ† (i : Œπ), ‚Ü•(H i)) ‚Üí+ G
(k : Type u_1) (G : Type u_2) [comm_semiring k] [group G] [fintype G] [invertible ‚Üë(fintype.card G)] (g : G) : finsupp.single g 1 * group_algebra.average k G = group_algebra.average k G
{n : Type u_3} {Œ± : Type v} [add_monoid Œ±] [star_add_monoid Œ±] : star_add_monoid (matrix n n Œ±)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.split_mono category_theory.limits.coprod.inl
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.simple X ‚Üî is_simple_order (category_theory.subobject X)
(Œ≤ : Type w) (C : Type u) : Type (max w u)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.abelian.image f ‚âÖ category_theory.limits.image f
(Œ± : Type u_1) [partial_order Œ±] : circular_partial_order Œ±
(c : tactic.instance_cache) (a : expr) : tactic (tactic.instance_cache √ó expr √ó expr)
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {Œ± : Type u_2} [add_right_cancel_semigroup Œ±] [has_one Œ±] [decidable_eq Œ±] (X : Œ± ‚Üí V) (d_X : Œ† (n : Œ±), X (n + 1) ‚ü∂ X n) (sq_X : ‚àÄ (n : Œ±), d_X (n + 1) ‚â´ d_X n = 0) (Y : Œ± ‚Üí V) (d_Y : Œ† (n : Œ±), Y (n + 1) ‚ü∂ Y n) (sq_Y : ‚àÄ (n : Œ±), d_Y (n + 1) ‚â´ d_Y n = 0) (f : Œ† (i : Œ±), X i ‚ü∂ Y i) (comm : ‚àÄ (i : Œ±), f (i + 1) ‚â´ d_Y i = d_X i ‚â´ f i) : chain_complex.of X d_X sq_X ‚ü∂ chain_complex.of Y d_Y sq_Y
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.is_equivalence F] : category_theory.faithful F
(Œ± : Type u) : Type u
 : tactic.ring.horner_expr ‚Üí tactic.ring.horner_expr ‚Üí tactic.ring.ring_m (tactic.ring.horner_expr √ó expr)
{Œ± : Type u_1} [semi_normed_ring Œ±] (a : Œ±) {n : ‚Ñï} : 0 < n ‚Üí ‚à•a ^ n‚à•‚Çä ‚â§ ‚à•a‚à•‚Çä ^ n
{M : Type u_1} [has_mul M] : has_mem (M √ó M) (con M)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_binary_biproduct X X] : f + g = category_theory.limits.biprod.lift (ùüô X) (ùüô X) ‚â´ category_theory.limits.biprod.desc f g
{R : Type u} [non_assoc_semiring R] (S : subsemiring R) (s : set R) (hs : s = ‚ÜëS) : subsemiring R
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_coproducts C] : (category_theory.coprod_monad X).algebra ‚âå category_theory.under X
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : function.injective f ‚Üî setoid.ker f = ‚ä•
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G : J ‚•§ C} {s : category_theory.limits.cocone F} {t : category_theory.limits.cocone G} (P : category_theory.limits.is_colimit s) (Q : category_theory.limits.is_colimit t) (w : F ‚âÖ G) : s.X ‚âÖ t.X
{Œ± : Type u_1} {G : Type u_4} {s : set Œ±} [division_comm_monoid G] (f g : Œ± ‚Üí G) (hs : s.finite) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i / g i)) = finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)) / finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), g i))
{Œ± : Type u_1} [pseudo_metric_space Œ±] (x y : Œ±) : has_edist.edist x y < ‚ä§
(attr_name : name) : name
{G : Type u_1} [group G] {H : subgroup G} {S : set G} (hS : S ‚àà subgroup.left_transversals ‚ÜëH) : G ‚Üí ‚Ü•S
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} [ring_hom_isometric œÉ‚ÇÅ‚ÇÇ] : semi_normed_group (E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F)
{R : Type u} [semiring R] {S : Type v} [semiring S] (f : R ‚Üí+* S) (r : R) : ‚áëpolynomial.C (‚áëf r) ‚àà polynomial.lifts f
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} (F : Top.presheaf C X) {U : topological_space.opens ‚Ü•X} (x : ‚Ü•U) : F.obj (opposite.op U) ‚ü∂ F.stalk ‚Üëx
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} : monotone (set.image f)
{k : Type u_1} {K : Type u_2} [field k] [is_alg_closed k] [field K] {f : K ‚Üí+* k} (p : polynomial K) : polynomial.splits f p
{Œ± : Type u_1} {Œπ : Type u_3} [complete_lattice Œ±] [fintype Œπ] {f : Œπ ‚Üí Œ±} : finset.univ.sup_indep f ‚Üí complete_lattice.independent f
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {A : Type u_3} [topological_space A] {f‚ÇÄ f‚ÇÅ : C(A, Œ±)} {g‚ÇÄ g‚ÇÅ : C(A, Œ≤)} (F : f‚ÇÄ.homotopy f‚ÇÅ) (G : g‚ÇÄ.homotopy g‚ÇÅ) : (f‚ÇÄ.prod_mk g‚ÇÄ).homotopy (f‚ÇÅ.prod_mk g‚ÇÅ)
{G H : AddCommGroup} (f : G ‚ü∂ H) : AddCommGroup
(Œ± : Type u_1) {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (b : Œ≤) : C(Œ±, Œ≤)
(V : Type u_1) [quiver V] : prefunctor V V
(L : first_order.language) : Type v
(J : Type u‚ÇÅ) [category_theory.category J] {C : Type u‚ÇÇ} [category_theory.category C] : C ‚•§ J ‚•§ C
{o : Type u_4} (m' : o ‚Üí Type u_7) (n' : o ‚Üí Type u_8) (Œ± : Type u_12) [decidable_eq o] [add_zero_class Œ±] : (Œ† (i : o), matrix (m' i) (n' i) Œ±) ‚Üí+ matrix (Œ£ (i : o), m' i) (Œ£ (i : o), n' i) Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] (X : C) : Type (max u v)
{Œπ : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [has_one R] [has_zero Œπ] (A : Œπ ‚Üí S) : Prop
{R : Type u} {M : Type v} [comm_ring R] [add_comm_group M] [module R M] (B : bilin_form R M) {N : Type w} [add_comm_group N] [module R N] (e : N ‚âÉ‚Çó[R] M) : ‚Ü•(skew_adjoint_lie_subalgebra (B.comp ‚Üëe ‚Üëe)) ‚âÉ‚Çó‚ÅÖR‚ÅÜ ‚Ü•(skew_adjoint_lie_subalgebra B)
{k : Type u_1} [ring k] {V : Type u_2} {P : Type u_3} [add_comm_group V] [module k V] [add_torsor V P] : add_action V (affine_subspace k P)
 : expr ‚Üí tactic (expr √ó expr)
(R : Type u_9) (M : Type u_10) [has_zero R] [has_zero M] [has_scalar R M] : Prop
{Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : list Œ±} : l‚ÇÅ <+: l‚ÇÇ ‚Üí l‚ÇÅ.reverse <:+ l‚ÇÇ.reverse
(R : Type u_1) [ring R] : algebra ‚Ñ§ R
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (p : quiver.path X Y) : X ‚ü∂ Y
(Œ± : Type u) : Type u
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {Œπ' : Type u_5} {E' : Type u_7} [inner_product_space ùïú E'] {v : basis Œπ ùïú E} (hv : orthonormal ùïú ‚áëv) {v' : basis Œπ' ùïú E'} (hv' : orthonormal ùïú ‚áëv') (e : Œπ ‚âÉ Œπ') : E ‚âÉ‚Çó·µ¢[ùïú] E'
{Œ± : Type u} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : set Œ±) : Prop
{Œ± : Type u} [pseudo_metric_space Œ±] (x : Œ±) (s : set Œ±) : ‚Ñù
{M‚ÇÄ : Type u_1} [monoid_with_zero M‚ÇÄ] : M‚ÇÄ ‚Üí M‚ÇÄ
(fn : expr) : tactic ‚Ñï
(h : expr) : tactic (list expr)
{Œ± : Sort u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (hf : function.injective f) : Œ± ‚âÉ ‚Ü•(set.range f)
 : filter.tendsto (Œª (x : ‚Ñù), real.exp (-x)) filter.at_top (nhds 0)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) (s : category_theory.limits.cocone F) : Mon.colimits.colimit F ‚ü∂ s.X
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom A B
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (l : Œπ ‚Üí‚ÇÄ ùïú) (i : Œπ) : has_inner.inner (‚áë(finsupp.total Œπ E ùïú v) l) (v i) = ‚áë(star_ring_end ùïú) (‚áël i)
{C : Type u} [category_theory.category C] {A B : C} [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] (f : B ‚ü∂ A) [category_theory.exponentiable B] : category_theory.exp A ‚ü∂ category_theory.exp B
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.abelian C] [category_theory.has_injective_resolutions C] [category_theory.abelian D] (F : C ‚•§ D) [F.additive] (n : ‚Ñï) : C ‚•§ D
{V : Type u_1} [quiver V] : quiver V·µí·µñ
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) : graded_algebra (clifford_algebra.even_odd Q)
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f g : add_hom M N) : add_subsemigroup M
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (G : D ‚•§ C) [‚àÄ (A : C), category_theory.limits.has_terminal (category_theory.costructured_arrow G A)] (B : D) (A : C) : (G.obj B ‚ü∂ A) ‚âÉ (B ‚ü∂ (‚ä§_ category_theory.costructured_arrow G A).left)
{Œ± : Type u_1} [decidable_eq Œ±] (xs : list Œ±) (x default : Œ±) : Œ±
{R : Type u_1} [normed_ring R] [complete_space R] : is_open_map coe
(pp : linarith.preprocessor) : linarith.global_preprocessor
{ùïÇ : Type u_1} [is_R_or_C ùïÇ] {x : ùïÇ} : has_strict_deriv_at (exp ùïÇ) (exp ùïÇ x) x
(c p : name) (i : ‚Ñï) : tactic (list name √ó ‚Ñï)
(Œ± : Type u) [pseudo_metric_space Œ±] : Type u
{n : ‚Ñï} {l : list ‚Ñï} (h‚ÇÅ : l.prod = n) (h‚ÇÇ : ‚àÄ (p : ‚Ñï), p ‚àà l ‚Üí nat.prime p) : l ~ n.factors
{Œ± : Type u} [preorder Œ±] {x y : Œ±} (h : x = y) : y ‚â§ x
{n : ‚Ñï} {F : typevec n ‚Üí Type v} [mvfunctor F] {Œ± : typevec n} (x : F Œ±) (i : fin2 n) : set (Œ± i)
 : ¬¨set.univ.countable
 : linarith.monom
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {n : with_top ‚Ñï} (h : cont_diff ùïú n f) (hn : 1 ‚â§ n) : differentiable ùïú f
(G : Type u) [add_monoid G] : Prop
{Œ± : Type u_1} {R : Type u_2} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] [monoid Œ±] [distrib_mul_action Œ± M] [smul_comm_class Œ± R M] : distrib_mul_action Œ± (submodule R M)
{S : Type u} [semigroup S] {a b x y z : S} (ha : semiconj_by a y z) (hb : semiconj_by b x y) : semiconj_by (a * b) x z
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] {F' : Type u_1} [topological_space F'] (e : topological_fiber_bundle.trivialization F proj) (h : F ‚âÉ‚Çú F') : topological_fiber_bundle.trivialization F' proj
 : vm_obj ‚Üí list vm_obj
{C : Type u} [category_theory.category C] {X Y : C} (s : category_theory.limits.binary_fan X Y) : ((category_theory.functor.const (category_theory.discrete category_theory.limits.walking_pair)).obj s.X).obj {as := category_theory.limits.walking_pair.left} ‚ü∂ (category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left}
{ùïú : Type u_1} {E : Type u_2} [semi_normed_ring ùïú] [has_scalar ùïú E] [has_zero E] [topological_space E] {s‚ÇÅ s‚ÇÇ : set E} (hs‚ÇÅ : bornology.is_vonN_bounded ùïú s‚ÇÅ) (hs‚ÇÇ : bornology.is_vonN_bounded ùïú s‚ÇÇ) : bornology.is_vonN_bounded ùïú (s‚ÇÅ ‚à™ s‚ÇÇ)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) (X Y : C) : F.to_lax_monoidal_functor.to_functor.obj X ‚äó F.to_lax_monoidal_functor.to_functor.obj Y ‚âÖ F.to_lax_monoidal_functor.to_functor.obj (X ‚äó Y)
(Œ± : Type u_1) {Œπ : Type u_2} (i : Œπ) : Type u_1
{X : algebraic_geometry.PresheafedSpace CommRing} (Y : algebraic_geometry.LocallyRingedSpace) (f : X ‚ü∂ Y.to_SheafedSpace.to_PresheafedSpace) [H : algebraic_geometry.PresheafedSpace.is_open_immersion f] : algebraic_geometry.PresheafedSpace.is_open_immersion.to_LocallyRingedSpace Y f ‚ü∂ Y
(R : Type u) [semiring R] {Œπ : Type u_1} {M : option Œπ ‚Üí Type u_2} [Œ† (i : option Œπ), add_comm_group (M i)] [Œ† (i : option Œπ), module R (M i)] : (Œ† (i : option Œπ), M i) ‚âÉ‚Çó[R] M option.none √ó Œ† (i : Œπ), M (option.some i)
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] {F : Type v} [normed_group F] [normed_space ‚ÑÇ F] [nontrivial E] {f g : E ‚Üí F} {U : set E} (hU : metric.bounded U) (hf : diff_cont_on_cl ‚ÑÇ f U) (hg : diff_cont_on_cl ‚ÑÇ g U) (hfg : set.eq_on f g (frontier U)) : set.eq_on f g (closure U)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_epi f] : Y ‚ü∂ X
{R : Type u} [semiring R] (r : R) (n : ‚Ñï) : polynomial.X ^ n * ‚áëpolynomial.C r = ‚áëpolynomial.C r * polynomial.X ^ n
 : environment ‚Üí name ‚Üí option name
{ùïú : Type u_1} {E : Type u_3} [normed_field ùïú] [add_comm_group E] [module ùïú E] {A : set E} (hA : balanced ùïú A) : absorbs ùïú A A
{V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] (B : bilin_form K V) (b‚ÇÅ : B.nondegenerate) (b‚ÇÇ : B.is_refl) {x : V} (hx : ¬¨B.is_ortho x x) : (B.restrict (B.orthogonal (submodule.span K {x}))).nondegenerate
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {X‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ : category_theory.center C} (f : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (g : X‚ÇÇ ‚ü∂ Y‚ÇÇ) : X‚ÇÅ.tensor_obj X‚ÇÇ ‚ü∂ Y‚ÇÅ.tensor_obj Y‚ÇÇ
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {f : Œ± ‚Üí Œ≤} (hf : function.bijective f) (b : Œ≤) : ‚àÉ! (a : Œ±), f a = b
 : lean.parser (list (name √ó binder_info √ó expr))
(C : Type u) [category_theory.category C] [category_theory.abelian C] [category_theory.has_injective_resolutions C] : C ‚•§ homotopy_category C (complex_shape.up ‚Ñï)
 : tactic unit
{R : Type u_1} [ring R] [nontrivial R] (s : subring R) : nontrivial ‚Ü•s
{R‚ÇÇ : Type u_5} {M‚ÇÇ : Type u_6} [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {M‚ÇÇ' : Type u_11} [add_comm_monoid M‚ÇÇ'] [module R‚ÇÇ M‚ÇÇ'] (e : M‚ÇÇ ‚âÉ‚Çó[R‚ÇÇ] M‚ÇÇ') : bilin_form R‚ÇÇ M‚ÇÇ ‚âÉ‚Çó[R‚ÇÇ] bilin_form R‚ÇÇ M‚ÇÇ'
(Œ± : Type u) : Type u
{G : Type u_1} [group G] {s : set G} (h : is_subgroup s) : subgroup G
{Œ± : Type u} [preorder Œ±] {a b : Œ±} : a = b ‚Üí a ‚â§ b
{Œ± : Type u_1} (s : set Œ±) : (filter.principal s).realizer
{H : Type u_1} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] {H' : Type u_3} {M' : Type u_4} [topological_space H'] [topological_space M'] [charted_space H' M'] (P : (H ‚Üí H') ‚Üí set H ‚Üí H ‚Üí Prop) (f : M ‚Üí M') (s : set M) (x : M) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : Œ± ‚âÉ Œ≤) : option Œ± ‚âÉ option Œ≤
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : has_dist.dist p1 p2 = has_dist.dist p1 p3) : euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p1 p3 p2
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f g : C(X, Y)} (H : f.homotopy g) (x : X) : path (‚áëf x) (‚áëg x)
 : Type v
{R : Type u_1} {R‚ÇÅ : Type u_2} {M‚ÇÅ : Type u_6} [comm_ring R] [comm_semiring R‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] {I‚ÇÅ I‚ÇÇ : R‚ÇÅ ‚Üí+* R} (B : M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ] M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÇ] R) : Prop
{G‚ÇÄ : Type u_1} [comm_group_with_zero G‚ÇÄ] : G‚ÇÄ ‚Üí*‚ÇÄ G‚ÇÄ
{x y z : ‚Ñ§} (h : pythagorean_triple x y z) (k : ‚Ñ§) : pythagorean_triple (k * x) (k * y) (k * z)
{Œ± : Type} (a : Œ±) (v : ‚Ñï ‚Üí Œ±) : ‚Ñï ‚Üí Œ±
{Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] {f : Œπ ‚Üí Œ±} (H : bdd_above (set.range f)) (c : Œπ) : f c ‚â§ supr f
{M : Type u_6} [monoid M] (u : MÀ£) : equiv.perm M
{Œ± : Type u_1} [has_one Œ±] [has_add Œ±] : pos_num ‚Üí Œ±
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {i : D ‚•§ C} [category_theory.reflective i] {B : D} : category_theory.is_iso ((category_theory.adjunction.of_right_adjoint i).unit.app (i.obj B))
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [add_zero_class Œπ] [graded_monoid.ghas_mul A] (i : Œπ) : has_scalar (A 0) (A i)
{C : Type u} [category_theory.category_struct C] {X Y : category_theory.locally_discrete C} {f g : X ‚ü∂ Y} (Œ∑ : f ‚ü∂ g) : f = g
{E : Type u_3} [h : normed_group E] : semi_normed_group E
(X : Profinite) : X.as_limit_cone ‚âÖ Profinite.limit_cone X.diagram
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_2} (f : (Œ† (a : Œ±), part (Œ≤ a)) ‚Üí Œ† (a : Œ±), part (Œ≤ a)) : stream (Œ† (a : Œ±), part (Œ≤ a))
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {F : Type u_2} [normed_group F] [normed_space ‚Ñù F] {f : E ‚Üí F} {s : set E} {x : E} {f' : E ‚ÜíL[‚Ñù] F} (f_diff : differentiable_on ‚Ñù f s) (s_conv : convex ‚Ñù s) (s_open : is_open s) (f_cont : ‚àÄ (y : E), y ‚àà closure s ‚Üí continuous_within_at f s y) (h : filter.tendsto (Œª (y : E), fderiv ‚Ñù f y) (nhds_within x s) (nhds f')) : has_fderiv_within_at f f' (closure s) x
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {Œπ : Type u_3} [hne : nonempty Œπ] [fintype Œπ] {p : Œπ ‚Üí P} (ha : affine_independent ‚Ñù p) : ‚àÉ! (cccr : P √ó ‚Ñù), cccr.fst ‚àà affine_span ‚Ñù (set.range p) ‚àß ‚àÄ (i : Œπ), has_dist.dist (p i) cccr.fst = cccr.snd
(R : Type u) [non_unital_semiring R] : Type u
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : category_theory.adjunction.core_unit_counit F G) : F ‚ä£ G
{Œ± : Type} (t : tactic Œ±) (p : string ‚Üí bool) : tactic unit
(ic : tactic.instance_cache) : expr ‚Üí tactic (tactic.instance_cache √ó expr √ó expr √ó expr)
{V : Type u} (G : simple_graph V) : Type u
{n : ‚Ñï} {Œ± : typevec n} : Œ±.arrow (Œ±.prod Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] [category_theory.symmetric_category D] : category_theory.symmetric_category (C ‚•§ D)
(ps : tactic.ring_exp.ex tactic.ring_exp.ex_type.sum) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum)
{Œ± : Type u_2} {Œ≤ : Type u_3} [comm_monoid Œ±] [comm_monoid Œ≤] {n : ‚Ñï} : freiman_hom_class (Œ± ‚Üí* Œ≤) set.univ Œ≤ n
{B : Type u} [quiver B] {a b : B} : quiver.path a b ‚Üí category_theory.free_bicategory.hom a b
{Œ± : Type u_1} [partial_order Œ±] [succ_order Œ±] {a : Œ±} : is_max a ‚Üí order.succ a = a
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} (p : Œπ ‚Üí P) (i1 : Œπ) : affine_independent k p ‚Üî linear_independent k (Œª (i : {x // x ‚â† i1}), p ‚Üëi -·µ• p i1)
 : Type
 : Type
{L : first_order.language} {L' : first_order.language} (g : L ‚Üí·¥∏ L') : L.sentence ‚Üí L'.sentence
{C : Type u} [category_theory.category C] {X Y : C} {f f' : X ‚ü∂ Y} [category_theory.limits.has_image f] [category_theory.limits.has_image f'] (h : f = f') : category_theory.limits.image f ‚âÖ category_theory.limits.image f'
{Œ± : Type u_1} {M : Type u_5} [has_zero M] {f g : Œ± ‚Üí‚ÇÄ M} (h : f = g) (a : Œ±) : ‚áëf a = ‚áëg a
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {x : Œ±} {p : filter Œπ} {g : Œπ ‚Üí Œ±} [topological_space Œ±] (h : tendsto_uniformly F f p) (hf : continuous_at f x) (hg : filter.tendsto g p (nhds x)) : filter.tendsto (Œª (n : Œπ), F n (g n)) p (nhds (f x))
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÇ} [category_theory.category C] [category_theory.is_preconnected J] {X Y : C} (Œ± : (category_theory.functor.const J).obj X ‚ü∂ (category_theory.functor.const J).obj Y) (j j' : J) : Œ±.app j = Œ±.app j'
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} : galois_insertion category_theory.sieve.generate category_theory.sieve.arrows
{C : Type u‚ÇÅ} [category_theory.category C] {X Y Z : C} (F : category_theory.mono_over X ‚•§ category_theory.mono_over Y ‚•§ category_theory.mono_over Z) : category_theory.subobject X ‚•§ category_theory.subobject Y ‚•§ category_theory.subobject Z
{Œ≤ Œ± : Type u} (f : Œ≤ ‚Üí Œ±) (Œ∏ : cardinal) (hŒ∏ : Œ∏ ‚â§ cardinal.mk Œ≤) (h‚ÇÅ : cardinal.aleph_0 ‚â§ Œ∏) (h‚ÇÇ : cardinal.mk Œ± < Œ∏.ord.cof) : ‚àÉ (a : Œ±), Œ∏ ‚â§ cardinal.mk ‚Ü•(f ‚Åª¬π' {a})
{F : Type u_1} [field F] (p q : polynomial F) : function.injective ‚áë(polynomial.gal.restrict_prod p q)
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (h : r ‚âÉr s) : Œ± ‚Üí Œ≤
{Œ± : Type u_1} [linear_ordered_field Œ±] (f : cau_seq Œ± has_abs.abs) : Prop
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} [decidable_eq Œπ] [finite_dimensional ùïú E] {V : Œπ ‚Üí submodule ùïú E} (hV : orthogonal_family ùïú (Œª (i : Œπ), (V i).subtype‚Çó·µ¢)) : direct_sum.is_internal V ‚Üî (supr V)·óÆ = ‚ä•
(E : Type u_1) [semi_normed_group E] : Prop
(H : Type u) [topological_space H] : Type u
{C : Type u‚ÇÅ} [category_theory.small_category C] (P : C·µí·µñ ‚•§ Type u‚ÇÅ) : (P.elements)·µí·µñ ‚•§ C·µí·µñ ‚•§ Type u‚ÇÅ
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [monoid G] [add_comm_monoid V] [module k V] (œÅ : representation k G V) : module (monoid_algebra k G) V
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : galois_insertion (lie_subalgebra.lie_span R L) coe
{Œ± : Type u_1} [decidable_eq Œ±] (s : cycle Œ±) (hs : s.nodup) (x : Œ±) (hx : x ‚àà s) : Œ±
{ùïú : Type u} [nondiscrete_normed_field ùïú] {E : Type v} [normed_group E] [normed_space ùïú E] {F : Type w} [normed_group F] [normed_space ùïú F] [complete_space ùïú] {Œπ : Type u_1} [fintype Œπ] (v : basis Œπ ùïú E) : ‚àÉ (C : nnreal) (H : C > 0), ‚àÄ {u : E ‚ÜíL[ùïú] F} (M : nnreal), (‚àÄ (i : Œπ), ‚à•‚áëu (‚áëv i)‚à•‚Çä ‚â§ M) ‚Üí ‚à•u‚à•‚Çä ‚â§ C * M
{n : ‚Ñï} {Œ± : Type u_1} : vector Œ± n ‚Üí array n Œ±
{Œ± : Type u_1} [linear_ordered_ring Œ±] [floor_ring Œ±] (a : Œ±) : Œ±
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) (x : X) (hm : jordan_holder_lattice.is_maximal x s.top) (hb : s.bot ‚â§ x) : ‚àÉ (t : composition_series X), t.bot = s.bot ‚àß t.length + 1 = s.length ‚àß ‚àÉ (htx : t.top = x), s.equivalent (t.snoc s.top _)
(F : Type u) (K : Type v) (A : Type w) [field F] [field K] [add_comm_group A] [algebra F K] [module K A] [module F A] [is_scalar_tower F K A] [finite_dimensional F K] : finite_dimensional.finrank F K * finite_dimensional.finrank K A = finite_dimensional.finrank F A
 : category_theory.reflective CompHaus_to_Top
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [nondiscrete_normed_field ùïÇ] [normed_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] (h : 0 < (exp_series ùïÇ ùî∏).radius) : has_fderiv_at (exp ùïÇ) 1 0
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] {module_M : module R M} {module_M‚ÇÇ : module R‚ÇÇ M‚ÇÇ} {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} {re‚ÇÅ‚ÇÇ : ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ} {re‚ÇÇ‚ÇÅ : ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ} (e : M ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (p : submodule R M) : ‚Ü•p ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] ‚Ü•(submodule.map ‚Üëe p)
{Œ± : Type u_1} [linear_ordered_field Œ±] (a : Œ±) (ha : 0 < a) : Œ± ‚âÉo Œ±
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommRing) : CommRing
{M : Type w} {N : Type w'} (f : M ‚Ü™ N) : first_order.language.empty.embedding M N
{K : Type u_1} {v : K} {n : ‚Ñï} [linear_ordered_field K] [floor_ring K] {b : K} (nth_part_denom_eq : (generalized_continued_fraction.of v).partial_denominators.nth n = option.some b) : b * (generalized_continued_fraction.of v).denominators n ‚â§ (generalized_continued_fraction.of v).denominators (n + 1)
{G : Type u} [group G] [fintype G] {p n : ‚Ñï} [hp : fact (nat.prime p)] (hdvd : p ^ (n + 1) ‚à£ fintype.card G) {H : subgroup G} (hH : fintype.card ‚Ü•H = p ^ n) : p ‚à£ fintype.card (‚Ü•(H.normalizer) ‚ß∏ subgroup.comap H.normalizer.subtype H)
(n d : pos_num) : num
{n : ‚Ñï} (p : fin (n + 1)) : fin n ‚Ü™o fin (n + 1)
{C : Type u} [category_theory.small_category C] {D : Type (u+1)} [category_theory.large_category D] [category_theory.abelian D] : category_theory.abelian (C ‚•§ D)
{F : Type u_3} [field F] [fintype F] (hF : ring_char F ‚â† 2) {a : F} (ha : a ‚â† 0) : is_square a ‚Üî a ^ (fintype.card F / 2) = 1
(G : Type u) [monoid G] : ‚Ñï
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S T : subalgebra R A) (h : S = T) : ‚Ü•S ‚âÉ‚Çê[R] ‚Ü•T
{C : Type u} [category_theory.category C] (f : category_theory.arrow C) [‚àÄ (n : ‚Ñï), category_theory.limits.has_wide_pushout f.left (Œª (i : ulift (fin (n + 1))), f.right) (Œª (i : ulift (fin (n + 1))), f.hom)] : category_theory.cosimplicial_object.augmented C
(R : Type u_1) [comm_ring R] (c‚ÇÅ c‚ÇÇ : R) : quaternion_algebra R c‚ÇÅ c‚ÇÇ ‚Üí‚Çó[R] R
(k : Type u_1) [division_ring k] {Œπ : Type u_4} (s : finset Œπ) : finset.centroid_weights k s = function.const Œπ (‚Üë(s.card))‚Åª¬π
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] : category_theory.monoidal_functor C (C √ó C)
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [bounded_order Œ±] [bounded_order Œ≤] : has_coe_to_fun (bounded_order_hom Œ± Œ≤) (Œª (_x : bounded_order_hom Œ± Œ≤), Œ± ‚Üí Œ≤)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {F : C ‚•§ D} [category_theory.full F] [category_theory.faithful F] [category_theory.limits.has_colimit (K ‚ãô F)] (c : category_theory.limits.cocone K) (i : F.map_cocone c ‚âÖ category_theory.limits.colimit.cocone (K ‚ãô F)) : category_theory.creates_colimit K F
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type v} (f : J ‚Üí C) [category_theory.limits.has_product f] [category_theory.limits.has_product (Œª (j : J), G.obj (f j))] [i : category_theory.is_iso (category_theory.limits.pi_comparison G f)] : category_theory.limits.preserves_limit (category_theory.discrete.functor f) G
{x y : simplex_category} {f : x ‚ü∂ y} : category_theory.mono f ‚Üí x.len ‚â§ y.len
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_equalizer f g] [category_theory.limits.has_equalizer (G.map f) (G.map g)] : G.obj (category_theory.limits.equalizer f g) ‚ü∂ category_theory.limits.equalizer (G.map f) (G.map g)
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] (s : finset Œ±) : finset (subtype p)
(X T : Top) : Top.prelocal_predicate (Œª (x : ‚Ü•X), ‚Ü•T)
(F : Type u_17) (M : out_param (Type u_18)) (A : out_param (Type u_19)) (B : out_param (Type u_20)) [monoid M] [add_monoid A] [add_monoid B] [distrib_mul_action M A] [distrib_mul_action M B] : Type (max u_17 u_19 u_20)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : Type w) [category_theory.category J] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ w w')
(n : ‚Ñï) : (1 + n).pred = n
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [linear_order Œ≤] [succ_order Œ≤] [is_succ_archimedean Œ≤] {s : Œ≤ ‚Üí set Œ±} (H : ‚àÄ (n : Œ≤), is_preconnected (s n)) (K : ‚àÄ (n : Œ≤), (s n ‚à© s (order.succ n)).nonempty) : is_preconnected (‚ãÉ (n : Œ≤), s n)
(p n : ‚Ñï) : witt_polynomial p (zmod (p ^ (n + 1))) (n + 1) = ‚áë(mv_polynomial.expand p) (witt_polynomial p (zmod (p ^ (n + 1))) n)
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] {j‚ÇÅ j‚ÇÇ : C} (f g h : j‚ÇÅ ‚ü∂ j‚ÇÇ) : C
{Œ± : Type u} [pseudo_metric_space Œ±] {s : ‚Ñï ‚Üí Œ±} : cauchy_seq s ‚Üî ‚àÉ (b : ‚Ñï ‚Üí ‚Ñù), (‚àÄ (n : ‚Ñï), 0 ‚â§ b n) ‚àß (‚àÄ (n m N : ‚Ñï), N ‚â§ n ‚Üí N ‚â§ m ‚Üí has_dist.dist (s n) (s m) ‚â§ b N) ‚àß filter.tendsto b filter.at_top (nhds 0)
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] : category_theory.lax_monoidal_functor C C
 : Type
 : Type
{M : Type u_5} [monoid M] {A : Type u_6} [add_monoid A] [distrib_mul_action M A] {B : Type u_8} [add_monoid B] [distrib_mul_action M B] (self : A ‚Üí+[M] B) : A ‚Üí[M] B
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) [category_theory.is_filtered J] {x y y' : Œ£ (j : J), ‚Ü•(F.obj j)} (hyy' : category_theory.limits.types.filtered_colimit.rel (F ‚ãô category_theory.forget Mon) y y') : Mon.filtered_colimits.colimit_mul_aux F x y = Mon.filtered_colimits.colimit_mul_aux F x y'
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} [t2_space Œ±] [proper_space Œ±] : is_compact s ‚Üî is_closed s ‚àß metric.bounded s
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X Y Z : algebraic_geometry.SheafedSpace C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [H : algebraic_geometry.SheafedSpace.is_open_immersion f] : algebraic_geometry.SheafedSpace.is_open_immersion category_theory.limits.pullback.snd
(x : ‚ÑÇ) : has_deriv_at complex.sin (complex.cos x) x
(R : Type u_1) (Œ∑ : Type u_2) [semiring R] [fintype Œ∑] : basis Œ∑ R (Œ∑ ‚Üí R)
{p : ‚ÑÇ √ó ‚ÑÇ} (h‚ÇÅ : 0 ‚â§ p.fst.re ‚à® p.fst.im ‚â† 0) (h‚ÇÇ : 0 < p.snd.re) : continuous_at (Œª (x : ‚ÑÇ √ó ‚ÑÇ), x.fst ^ x.snd) p
{V : Type u} {V' : Type v} {G : simple_graph V} {G' : simple_graph V'} (f : G ‚Ü™g G') {u v : V} (p : G.path u v) : G'.path (‚áëf u) (‚áëf v)
 : omega.nat.preform ‚Üí Prop
{C : Type u} [category_theory.category C] {F : category_theory.limits.walking_span ‚•§ C} (t : category_theory.limits.cocone F) : (category_theory.limits.cocones.precompose (category_theory.limits.diagram_iso_span F).inv).obj t ‚âÖ category_theory.limits.pushout_cocone.mk (t.Œπ.app category_theory.limits.walking_span.left) (t.Œπ.app category_theory.limits.walking_span.right) _
{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ‚â† 2) : char.quadratic_char F (-1) = ‚áëzmod.œá‚ÇÑ ‚Üë(fintype.card F)
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} {Œ≤ : Type u} (g : Œ≤ ‚Üí F (Œ± ::: Œ≤)) : Œ≤ ‚Üí (mvqpf.P F).M Œ±
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (x : Œ± 0) (p : Œ† (i : fin n), Œ± i.succ) (i : fin n) (y : Œ± i.succ) : fin.cons x (function.update p i y) = function.update (fin.cons x p) i.succ y
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [category_theory.limits.has_pullback f g] [category_theory.limits.has_pullback (G.map f) (G.map g)] [i : category_theory.is_iso (category_theory.limits.pullback_comparison G f g)] : category_theory.limits.preserves_limit (category_theory.limits.cospan f g) G
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] {J : Type v} [category_theory.small_category J] [category_theory.fin_category J] (F : J ‚•§ C) : nonempty (category_theory.limits.cocone F)
{V : Type u_1} [quiver V] {a b : V} (e : a ‚ü∂ b) : quiver.path a b
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : ‚Üëa = 0 ‚Üî a.hom = 0
{R : Type u} [ring R] {Œ± : Type u_1} [monoid Œ±] [mul_distrib_mul_action R Œ±] (S : subring R) : mul_distrib_mul_action ‚Ü•S Œ±
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} [category_theory.limits.has_zero_object V] [category_theory.limits.has_kernels V] [category_theory.limits.has_images V] [category_theory.limits.has_cokernels V] (C : homological_complex V c) (i : Œπ) : V
{R : Type u} [comm_ring R] {P : ideal R} (H : P.is_prime) : (ideal.map polynomial.C P).is_prime
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] (F : J ‚•§ algebraic_geometry.PresheafedSpace C) (s : category_theory.limits.cocone F) (U : (topological_space.opens ‚Ü•(s.X.carrier))·µí·µñ) : s.X.presheaf.obj U ‚ü∂ (category_theory.limits.colimit.desc (F ‚ãô algebraic_geometry.PresheafedSpace.forget C) ((algebraic_geometry.PresheafedSpace.forget C).map_cocone s) _* category_theory.limits.limit (algebraic_geometry.PresheafedSpace.pushforward_diagram_to_colimit F).left_op).obj U
 : tactic unit
{C : Type u} [category_theory.category C] [category_theory.abelian C] (Z : C) [category_theory.has_injective_resolution Z] : (cochain_complex.single‚ÇÄ C).obj Z ‚ü∂ category_theory.injective_resolution Z
{Œ± : Type u} [pseudo_metric_space Œ±] : has_nndist Œ±
{Œ± : Type u} {Œ≤ : Type v} {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} [partial_order Œ±] [preorder Œ≤] [bounded_order Œ≤] (gi : galois_coinsertion l u) : bounded_order Œ±
(h : Top.glue_data.mk_core) : Top.glue_data
{Œ± : Type u} : complete_lattice (topological_space Œ±)
 : tactic (option (expr √ó expr))
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] [‚àÄ {X Y : C} (f : X ‚ü∂ Y), category_theory.is_iso (category_theory.abelian.coimage_image_comparison f)] [category_theory.limits.has_finite_products C] : category_theory.normal_epi_category C
(G : Type u_1) [add_comm_group G] : add_subgroup G
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_group Œ±] [add_comm_group Œ≤] {f g : Œ± ‚Üí Œ≤} (hf : is_add_group_hom f) (hg : is_add_group_hom g) : is_add_group_hom (Œª (a : Œ±), f a - g a)
{a b c : Prop} : a ‚àß (b ‚à® c) ‚Üî a ‚àß b ‚à® a ‚àß c
{Œ± : Type u_1} (s : cycle Œ±) : Prop
{ùïú : Type u} {n : ‚Ñï} {Ei : fin n.succ ‚Üí Type wEi} {G : Type wG} [nondiscrete_normed_field ùïú] [Œ† (i : fin n.succ), normed_group (Ei i)] [Œ† (i : fin n.succ), normed_space ùïú (Ei i)] [normed_group G] [normed_space ùïú G] (f : Ei 0 ‚ÜíL[ùïú] continuous_multilinear_map ùïú (Œª (i : fin n), Ei i.succ) G) : continuous_multilinear_map ùïú Ei G
{Œ± : Type u} {s : set Œ±} (h : s.countable) (default : Œ±) : ‚Ñï ‚Üí Œ±
(r : tactic.tauto_state) : expr ‚Üí tactic (expr √ó expr)
(decl_name : name) (warning : string) : format
{R : ‚Ñù} {c w : ‚ÑÇ} {s : set ‚ÑÇ} (hs : s.countable) (hw : w ‚àà metric.ball c R) {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hc : continuous_on f (metric.closed_ball c R)) (hd : ‚àÄ (z : ‚ÑÇ), z ‚àà metric.ball c R  s ‚Üí differentiable_at ‚ÑÇ f z) : ‚àÆ (z : ‚ÑÇ) in C(c, R), f z / (z - w) = 2 * ‚Üëreal.pi * complex.I * f w
{Œ± : Type u_1} {P : Œ± ‚Üí Prop} : antitone (Œª (s : set Œ±), ‚àÄ (x : Œ±), x ‚àà s ‚Üí P x)
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} : b < c ‚Üí a < b ‚Üí a < c
{R : Type u_1} {M : Type u_9} {M‚ÇÇ : Type u_12} [comm_semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] (e : M ‚âÉ‚Çó[R] M‚ÇÇ) : module.End R M ‚âÉ‚Çó[R] module.End R M‚ÇÇ
{Œ± : Type u} [topological_space Œ±] (x : Œ±) (c : set (set Œ±)) (H1 : ‚àÄ (s : set Œ±), s ‚àà c ‚Üí x ‚àà s) (H2 : ‚àÄ (s : set Œ±), s ‚àà c ‚Üí is_preconnected s) : is_preconnected (‚ãÉ‚ÇÄc)
 : option ‚Ñï ‚Üí tactic unit
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_top Œ±] [has_top Œ≤] : has_coe_to_fun (top_hom Œ± Œ≤) (Œª (_x : top_hom Œ± Œ≤), Œ± ‚Üí Œ≤)
{Œ± : Type u_1} [linear_ordered_field Œ±] {Œ≤ : Type u_2} [ring Œ≤] {abv : Œ≤ ‚Üí Œ±} [is_absolute_value abv] [cau_seq.is_complete Œ≤ abv] (s : cau_seq Œ≤ abv) : Œ≤
{n : ‚Ñï} {Œ± Œ≤ : typevec n} (i : fin2 n) : Œ± i ‚Üí Œ≤ i ‚Üí Œ±.prod Œ≤ i
{M : Type u_1} [monoid M] (a : M) : Prop
{n : ‚Ñï} (i : fin (2 ^ n)) : bitvec n
{M : Type u_1} [mul_one_class M] (S : submonoid M) : submonoid.closure ‚ÜëS = S
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] : list (sigma Œ≤) ‚Üí list (sigma Œ≤)
(Œ± : Type u_1) [subsingleton Œ±] : list Œ± ‚âÉ multiset Œ±
{C : Type u} [category_theory.category C] (F : C ‚•§ Type w) : category_theory.category F.elements
{a b c : Prop} : (a ‚à® b) ‚àß c ‚Üî a ‚àß c ‚à® b ‚àß c
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] : (filter.cocompact Œ±).coprod (filter.cocompact Œ≤) = filter.cocompact (Œ± √ó Œ≤)
{R : Type u_1} [has_mul R] (c : R) : Prop
(k : Type u‚ÇÅ) {G : Type u‚ÇÇ} {R : Type u_1} [monoid R] [semiring k] [distrib_mul_action R k] [has_add G] [smul_comm_class R k k] : smul_comm_class R (add_monoid_algebra k G) (add_monoid_algebra k G)
{G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {n : with_top ‚Ñï} : cont_diff ùïú n id
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : (fin 2 ‚Üí M) ‚âÉ‚Çó[R] M √ó M
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b c : Œ±} : a < b + c ‚Üí a - c < b
{Œ± : Type u} [pseudo_metric_space Œ±] (f : ‚Ñï ‚Üí Œ±) (n : ‚Ñï) : has_dist.dist (f 0) (f n) ‚â§ (finset.range n).sum (Œª (i : ‚Ñï), has_dist.dist (f i) (f (i + 1)))
(R : Type u_1) [comm_ring R] [is_domain R] : Prop
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] [category_theory.monoidal_category C] (F : J ‚•§ Mon_ C) : category_theory.limits.is_limit (Mon_.limit_cone F)
{S : Type u‚ÇÅ} {L : Type u‚ÇÇ} {D : Type u‚ÇÉ} [category_theory.category S] [category_theory.category L] [category_theory.category D] {Œπ : S ‚•§ L} {F : S ‚•§ D} {G : L ‚•§ D} (x : L) (f : F ‚ü∂ Œπ ‚ãô G) : category_theory.limits.cocone (category_theory.Lan.diagram Œπ F x)
{Œ± : Type u_1} [decidable_eq Œ±] (s : multiset Œ±) (H : ‚àÄ (x : Œ±), x ‚àà s) : fintype Œ±
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} : a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) (n : ‚Ñï) : K
{Œ± Œ≤ : ordinal} (h : Œ± = Œ≤) : has_lt.lt ‚âÉr has_lt.lt
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) {g : N ‚Üí M} (h : function.left_inverse g ‚áëf) : M ‚âÉ+ ‚Ü•(f.srange)
{Œ± : Type u_1} [metric_space Œ±] (s : set Œ±) : has_dist (polish_space.complete_copy s)
 : pos ‚Üí widget.component tactic_state empty ‚Üí tactic unit
(X : algebraic_geometry.LocallyRingedSpace) : ‚Ü•X ‚Üí prime_spectrum ‚Ü•(algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X))
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.mono f] [category_theory.split_epi f] : category_theory.is_iso f
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≤) : ‚Ñï ‚Üí Œ≤ ‚Üí list Œ± ‚Üí Œ≤
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X : C) : category_theory.is_iso 0 ‚âÉ ùüô X = 0
(n m : ‚Ñï) : ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [locally_compact_space (Œ± √ó Œ≤)] : continuous continuous_map.curry
 : metric_space Gromov_Hausdorff.GH_space
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C·µí·µñ ‚•§ D} (Œ± : F.right_op ‚ü∂ G.right_op) : G ‚ü∂ F
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {P Q R : T.algebra} (f : P.hom Q) (g : Q.hom R) : P.hom R
{Œπ : Type u} {Œ≥ : Type w} {Œ≤ : Œπ ‚Üí Type v} [semiring Œ≥] [Œ† (i : Œπ), add_comm_monoid (Œ≤ i)] [Œ† (i : Œπ), module Œ≥ (Œ≤ i)] : module Œ≥ (Œ†‚ÇÄ (i : Œπ), Œ≤ i)
(Œ± : Type s) : Type (max s r)
{R : Type u_1} {M : Type u_7} [semiring R] [add_comm_monoid M] [module R M] : has_faithful_smul (M ‚âÉ‚Çó[R] M) M
{x y z : ‚Ñ§} (h : pythagorean_triple x y z) (h_coprime : x.gcd y = 1) (h_parity : x % 2 = 1) (h_pos : 0 < z) : ‚àÉ (m n : ‚Ñ§), x = m ^ 2 - n ^ 2 ‚àß y = 2 * m * n ‚àß z = m ^ 2 + n ^ 2 ‚àß m.gcd n = 1 ‚àß (m % 2 = 0 ‚àß n % 2 = 1 ‚à® m % 2 = 1 ‚àß n % 2 = 0) ‚àß 0 ‚â§ m
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] : K ‚äî K·óÆ = ‚ä§
(Œ± : Type u) : Type u
{R : Type u_1} [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (M N : submonoid R) [is_localization M S] (h : M ‚â§ N) (h' : ‚àÄ (x : ‚Ü•N), ‚àÉ (m : R), m * ‚Üëx ‚àà M) : is_localization N S
{Œ± : Type u_2} {Œ≤ : Type u_3} [decidable_eq Œ≤] [add_monoid Œ±] [add_action Œ± Œ≤] : add_action Œ± (finset Œ≤)
(p : omega.nat.preform) : tactic expr
{R : Type u_1} [comm_ring R] (c‚ÇÅ c‚ÇÇ : R) : quaternion_algebra.basis (clifford_algebra (clifford_algebra_quaternion.Q c‚ÇÅ c‚ÇÇ)) c‚ÇÅ c‚ÇÇ
{Œ± : Type u_1} [fintype Œ±] (p : Œ± ‚Üí Prop) [decidable_pred p] (hp : ‚àÉ! (a : Œ±), p a) : Œ±
{Œ± : Type u_1} [decidable_eq Œ±] (s : multiset Œ±) : finset Œ±
{M : Type u_1} [mul_one_class M] : has_top (submonoid M)
{V : Type u} (G : simple_graph V) (v : V) : set (sym2 V)
(n : Type u_3) (Œ± : Type v) [add_zero_class Œ±] : matrix n n Œ± ‚Üí+ n ‚Üí Œ±
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} [comm_ring R] [lie_ring L‚ÇÅ] [lie_algebra R L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÇ] : has_zero (L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ)
{R : Type u} {n : ‚Ñï} {M : fin n.succ ‚Üí Type v} {M‚ÇÇ : Type v‚ÇÇ} [semiring R] [Œ† (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : fin n.succ), module R (M i)] [module R M‚ÇÇ] (f : multilinear_map R M M‚ÇÇ) (m : Œ† (i : fin n), M (‚áëfin.cast_succ i)) (x y : M (fin.last n)) : ‚áëf (fin.snoc m (x + y)) = ‚áëf (fin.snoc m x) + ‚áëf (fin.snoc m y)
{M : Type u_1} [mul_one_class M] (s : set M) : submonoid M
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) : P
{Œ± : Type u} (c : lattice Œ±) (le : Œ± ‚Üí Œ± ‚Üí Prop) (eq_le : le = lattice.le) (sup : Œ± ‚Üí Œ± ‚Üí Œ±) (eq_sup : sup = lattice.sup) (inf : Œ± ‚Üí Œ± ‚Üí Œ±) (eq_inf : inf = lattice.inf) : lattice Œ±
(R : Type u) [comm_ring R] : Type u
{Œ± : Type u} {a b : Œ±} [mul_zero_one_class Œ±] [partial_order Œ±] [zero_lt.mul_pos_mono Œ±] (ha : a ‚â§ 1) (hb : b ‚â§ 1) (b0 : 0 < b) : a * b ‚â§ 1
(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) {p : polynomial A} (pmonic : p.monic) (hp : ‚áë(polynomial.aeval x) p = 0) : (minpoly A x).degree ‚â§ p.degree
(k : Type u‚ÇÅ) {G : Type u‚ÇÇ} [monoid G] [comm_semiring k] (V : Type u‚ÇÉ) [add_comm_monoid V] [module k V] [module (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] (g : G) : V ‚Üí‚Çó[k] V
{Œ± : Type u_2} {Œ≤ : Type u_3} [linear_ordered_comm_monoid_with_zero Œ±] [linear_ordered_comm_monoid_with_zero Œ≤] : has_mul (Œ± ‚Üí*‚ÇÄo Œ≤)
{p : ‚Ñï} [fact (nat.prime p)] {f : padic_seq p} (hf : ¬¨f ‚âà 0) (v2 v3 : ‚Ñï) : padic_norm p (‚áëf (padic_seq.stationary_point hf)) = padic_norm p (‚áëf (linear_order.max (padic_seq.stationary_point hf) (linear_order.max v2 v3)))
{M : Type u_3} {N : Type u_4} [mul_zero_one_class M] [mul_zero_one_class N] (f : M ‚Üí*‚ÇÄ N) {x y : M} (h : x = y) : ‚áëf x = ‚áëf y
{k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ‚Ñï} {s‚ÇÅ s‚ÇÇ : affine.simplex k P n} (h : set.range s‚ÇÅ.points = set.range s‚ÇÇ.points) : finset.centroid k finset.univ s‚ÇÅ.points = finset.centroid k finset.univ s‚ÇÇ.points
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (P : regular_expression Œ±) : (regular_expression.map f P).matches = ‚áë(language.map f) P.matches
(S : set ‚Ñù) (hS : ‚àÄ (x : ‚Ñù), x ‚àà S ‚Üí 0 ‚â§ x) : 0 ‚â§ has_Inf.Inf S
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [has_zero M‚ÇÅ] [has_scalar ‚Ñï M‚ÇÅ] [add_comm_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : add_comm_monoid M‚ÇÅ
(Œ± : Type u) [metric_space Œ±] [topological_space.separable_space Œ±] : ‚àÉ (f : Œ± ‚Üí ‚Ü•(lp (Œª (n : ‚Ñï), ‚Ñù) ‚ä§)), isometry f
{L : first_order.language} {M : Type w} [L.Structure M] (s : set M) {p : Œ† (x : M), x ‚àà ‚áë(first_order.language.substructure.closure L) s ‚Üí Prop} (Hs : ‚àÄ (x : M) (h : x ‚àà s), p x _) (Hfun : ‚àÄ {n : ‚Ñï} (f : L.functions n), first_order.language.closed_under f {x : M | ‚àÉ (hx : x ‚àà ‚áë(first_order.language.substructure.closure L) s), p x hx}) {x : M} (hx : x ‚àà ‚áë(first_order.language.substructure.closure L) s) : p x hx
{Œ± : Type u_1} [add_group Œ±] (H : add_subgroup Œ±) {K L : add_subgroup Œ±} (h : K ‚â§ L) : ‚Ü•K ‚ß∏ H.add_subgroup_of K ‚Ü™ ‚Ü•L ‚ß∏ H.add_subgroup_of L
{Œ± : Type u_1} {Œ≤ : Type u_2} [complete_lattice Œ±] {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} : f.liminf u = ‚®Ü (s : set Œ≤) (H : s ‚àà f), ‚®Ö (a : Œ≤) (H : a ‚àà s), u a
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] : Mon_.equiv_lax_monoidal_functor_punit.Mon_to_lax_monoidal C ‚ãô Mon_.equiv_lax_monoidal_functor_punit.lax_monoidal_to_Mon C ‚âÖ ùü≠ (Mon_ C)
{C : Type u} [category_theory.category C] [category_theory.limits.has_terminal C] (P : C) [category_theory.limits.has_binary_product (‚ä§_ C) P] : ‚ä§_ C ‚®Ø P ‚âÖ P
{C : Type u} [category_theory.category C] (all_is_iso : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), category_theory.is_iso f) : category_theory.groupoid C
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí option Œ≤) (s : multiset Œ±) : multiset Œ≤
{Œ± : Type u} (s : wseq Œ±) (p : Œ± ‚Üí bool) : computation bool
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [has_zero M] [comm_monoid N] [comm_monoid P] (h : N ‚âÉ* P) (f : Œ± ‚Üí‚ÇÄ M) (g : Œ± ‚Üí M ‚Üí N) : ‚áëh (f.prod g) = f.prod (Œª (a : Œ±) (b : M), ‚áëh (g a b))
{Œ± : Type u} {Œ≤ : Type v} (f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≤) (start : ‚Ñï) (b : Œ≤) (as : list Œ±) : Œ≤
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤] : filter (C(Œ±, Œ≤) √ó C(Œ±, Œ≤))
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : has_zero (lie_subalgebra R L)
{Œ± : Type u} [preorder Œ±] {s t : set Œ±} (h : bdd_above t) : bdd_above (s ‚à© t)
{G : Type u_1} [group G] {k : set G} {p : G ‚Üí Prop} {x : G} (h : x ‚àà subgroup.closure k) (Hk : ‚àÄ (x : G), x ‚àà k ‚Üí p x) (Hk_inv : ‚àÄ (x : G), x ‚àà k ‚Üí p x‚Åª¬π) (H1 : p 1) (Hmul : ‚àÄ (x y : G), p x ‚Üí p y ‚Üí p (x * y)) : p x
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_well_order Œ± r] (a : Œ±) : ordinal
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pushouts C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : category_theory.limits.cokernel_cofork (category_theory.limits.biprod.lift f (-g))
{K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Ring) : Ring
 : pos_num ‚Üí num
 : expr ‚Üí expr ‚Üí expr ‚Üí expr √ó expr ‚Üí expr √ó expr ‚Üí tactic.norm_fin.eval_fin_m expr
{Y : Type u_2} [topological_space Y] [normal_space Y] {s : set Y} (f : bounded_continuous_function ‚Ü•s ‚Ñù) (hs : is_closed s) {t : set ‚Ñù} [t.ord_connected] (hf : ‚àÄ (x : ‚Ü•s), ‚áëf x ‚àà t) (hne : t.nonempty) : ‚àÉ (g : bounded_continuous_function Y ‚Ñù), (‚àÄ (y : Y), ‚áëg y ‚àà t) ‚àß g.restrict s = f
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop} (f‚ÇÅ : r ‚âÉr s) (f‚ÇÇ : s ‚âÉr t) : r ‚âÉr t
{n : ‚Ñï} {Œ± : Type u_1} [preorder Œ±] {f g : fin n ‚Ü™o Œ±} (h : set.range ‚áëf = set.range ‚áëg) : f = g
 : Type (u+1)
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} (H : is_preconnected s) : is_preconnected (closure s)
(A B : finset ‚Ñï) : A.sum (Œª (i : ‚Ñï), 2 ^ i) < B.sum (Œª (i : ‚Ñï), 2 ^ i) ‚Üî A.to_colex < B.to_colex
{Œπ Œ± : Type v} (U : Œπ ‚Üí Œ±) [semilattice_inf Œ±] {o‚ÇÅ o‚ÇÇ : category_theory.pairwise Œπ} (f : o‚ÇÅ ‚ü∂ o‚ÇÇ) : category_theory.pairwise.diagram_obj U o‚ÇÅ ‚ü∂ category_theory.pairwise.diagram_obj U o‚ÇÇ
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [Œ† (i : Œπ), has_zero (Œ≤ i)] (p : Œπ ‚Üí Prop) [decidable_pred p] : (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚Üí (Œ†‚ÇÄ (i : subtype p), Œ≤ ‚Üëi)
{T : Type u‚ÇÅ} [category_theory.category T] {X : T} {U V : category_theory.over X} (f : U.left ‚ü∂ V.left) (w : f ‚â´ V.hom = U.hom . "obviously") : U ‚ü∂ V
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {Œπ : Type u_5} {Œπ' : Type u_6} [normed_field ùïú] [add_comm_group E] [module ùïú E] [add_comm_group F] [module ùïú F] (p : Œπ ‚Üí seminorm ùïú E) (q : Œπ' ‚Üí seminorm ùïú F) (f : E ‚Üí‚Çó[ùïú] F) : Prop
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [finite_dimensional ùïú E] (T : E ‚Üí‚Çó[ùïú] E) : inner_product_space.is_self_adjoint (‚áëlinear_map.adjoint T * T)
{F : Type u_1} [field F] {K‚ÇÅ : Type u_3} {K‚ÇÇ : Type u_4} [field K‚ÇÅ] [field K‚ÇÇ] [algebra F K‚ÇÅ] [algebra F K‚ÇÇ] (œá : K‚ÇÅ ‚âÉ‚Çê[F] K‚ÇÇ) (E : Type u_6) [field E] [algebra F E] [algebra E K‚ÇÅ] [algebra E K‚ÇÇ] [is_scalar_tower F E K‚ÇÅ] [is_scalar_tower F E K‚ÇÇ] [h : normal F E] : E ‚âÉ‚Çê[F] E
{Œ± : Type u_1} [group Œ±] {s t : subgroup Œ±} (h_le : s ‚â§ t) (f : Œ± ‚ß∏ t ‚Üí Œ±) (hf : function.right_inverse f quotient_group.mk) : Œ± ‚ß∏ s ‚âÉ (Œ± ‚ß∏ t) √ó ‚Ü•t ‚ß∏ s.subgroup_of t
(X : algebraic_geometry.Scheme) : X.open_cover
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [linear_ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : strict_concave_on ùïú s f) {x y : E} (hx : x ‚àà s) (hy : y ‚àà s) (hxy : x ‚â† y) {a b : ùïú} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : linear_order.min (f x) (f y) < f (a ‚Ä¢ x + b ‚Ä¢ y)
{R : Type u_1} {S : Type u_2} [conditionally_complete_linear_order R] (s : finset S) (f : S ‚Üí tropical (with_top R)) : tropical.untrop (s.sum (Œª (i : S), f i)) = ‚®Ö (i : ‚Ü•s), tropical.untrop (f ‚Üëi)
{Œπ : Type u_1} {ùïú : Type u_3} [is_R_or_C ùïú] {E : Type u_4} [inner_product_space ùïú E] {E' : Type u_5} [inner_product_space ùïú E'] [fintype Œπ] (v : basis Œπ ùïú E) (hv : orthonormal ùïú ‚áëv) (f : E ‚âÉ‚Çó·µ¢[ùïú] E') : ((v.map f.to_linear_equiv).to_orthonormal_basis _).repr = f.symm.trans (v.to_orthonormal_basis hv).repr
{Œ± : Type u_1} (t : Œ±) : list Œ± ‚Üí list (list Œ±)
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} {R : Type u_11} [monoid R] [add_monoid M] [add_comm_monoid N] [distrib_mul_action R M] {g : Œ± ‚Üí‚ÇÄ M} {b : R} {h : Œ± ‚Üí M ‚Üí+ N} : (b ‚Ä¢ g).sum (Œª (a : Œ±), ‚áë(h a)) = g.sum (Œª (i : Œ±) (c : M), ‚áë(h i) (b ‚Ä¢ c))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p‚ÇÄ : P} (h : p‚ÇÄ ‚àà s) : collinear k s ‚Üî ‚àÉ (v : V), ‚àÄ (p : P), p ‚àà s ‚Üí (‚àÉ (r : k), p = r ‚Ä¢ v +·µ• p‚ÇÄ)
{Œ± : Type u_1} [group Œ±] {s : subgroup Œ±} : Œ± ‚âÉ (Œ± ‚ß∏ s) √ó ‚Ü•s
(n : ‚Ñï) (a : zmod n) : zmod n ‚Üí zmod n
{U : Top} (X : algebraic_geometry.LocallyRingedSpace) {f : U ‚ü∂ X.to_Top} (h : open_embedding ‚áëf) : algebraic_geometry.LocallyRingedSpace
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] (F : J ‚•§ C) (G : C ‚•§ D) : category_theory.limits.cocone F ‚•§ category_theory.limits.cocone (F ‚ãô G)
{R : Type u} [field R] (p : polynomial R) : (multiset.map (Œª (a : R), polynomial.X - ‚áëpolynomial.C a) p.roots).prod ‚à£ p
{C : Type u} [category_theory.category C] {R X Y : C} {f : X ‚ü∂ Y} {a b : R ‚ü∂ X} {S : C} (k : category_theory.is_kernel_pair f a b) (p q : S ‚ü∂ X) (w : p ‚â´ f = q ‚â´ f) : {t // t ‚â´ a = p ‚àß t ‚â´ b = q}
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [densely_ordered Œ±] {a b : Œ±} {s : set Œ±} (hs : is_closed (s ‚à© set.Icc a b)) (ha : a ‚àà s) (hgt : ‚àÄ (x : Œ±), x ‚àà s ‚à© set.Ico a b ‚Üí s ‚àà nhds_within x (set.Ioi x)) : set.Icc a b ‚äÜ s
 : Pointed_to_Bipointed ‚ãô Bipointed_to_Pointed_fst ‚âÖ ùü≠ Pointed
{G : Type u_1} [group G] (H : subgroup G) : ‚Ü•H ‚Üí* G
{p : ‚Ñï+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ‚Üë‚Üëp] {k : ‚Ñï} [hpri : fact (nat.prime ‚Üëp)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ‚Üë(p ^ (k + 1)) K)) (h : p ‚â† 2) : ‚áë(algebra.norm K) (is_cyclotomic_extension.zeta (p ^ (k + 1)) K L - 1) = ‚Üëp
{F : Type u} [field F] {n : ‚Ñï} : (polynomial.X ^ n - 1).separable ‚Üî ‚Üën ‚â† 0
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] [decidable_eq Œ≤] {f : Œ± ‚Üí Œ≤} (hf : function.injective f) : ‚Ü•(set.range f) ‚Üí Œ±
(Œ± : Type u) (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_symm Œ± r] : is_symm_op Œ± Prop r
{G : Type u_1} [group G] (H : subgroup G) : has_one ‚Ü•H
{x y : pgame} (ox : x.numeric) (oy : y.numeric) : x < y ‚Üî (‚àÉ (i : y.left_moves), x ‚â§ y.move_left i) ‚à® ‚àÉ (j : x.right_moves), x.move_right j ‚â§ y
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {f' : F} [linear_order ùïú] [order_closed_topology ùïú] {x y : ùïú} (h : x < y) : has_deriv_within_at f f' (set.Ioi x) x ‚Üí has_deriv_within_at f f' (set.Ioo x y) x
{Œ± : Type u} [partial_order Œ±] {a b : Œ±} : a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b
(f f' : ‚Ñù ‚Üí ‚Ñù) {a b : ‚Ñù} (hab : a < b) (g g' : ‚Ñù ‚Üí ‚Ñù) {lfa lga lfb lgb : ‚Ñù} (hff' : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí has_deriv_at f (f' x) x) (hgg' : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí has_deriv_at g (g' x) x) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds lfa)) (hga : filter.tendsto g (nhds_within a (set.Ioi a)) (nhds lga)) (hfb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds lfb)) (hgb : filter.tendsto g (nhds_within b (set.Iio b)) (nhds lgb)) : ‚àÉ (c : ‚Ñù) (H : c ‚àà set.Ioo a b), (lgb - lga) * f' c = (lfb - lfa) * g' c
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {G : C ‚•§ D} [category_theory.reflects_isomorphisms G] [category_theory.limits.has_limits_of_shape J C] [category_theory.limits.preserves_limits_of_shape J G] : category_theory.limits.reflects_limits_of_shape J G
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_product X X] : X ‚ü∂ X ‚®Ø X
(Œ≤ : Type u_2) [pseudo_metric_space Œ≤] [add_monoid Œ≤] [has_lipschitz_add Œ≤] : nnreal
{C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object.augmented C·µí·µñ) : category_theory.simplicial_object.augmented C
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) (X : C) : category_theory.limits.is_colimit (G.map_cocone (category_theory.limits.as_empty_cocone X)) ‚âÉ category_theory.limits.is_initial (G.obj X)
(c : ‚Ñï) (h : expr) : tactic (linarith.ineq √ó expr)
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : dense s ‚Üí ‚àÄ (U : set Œ±), is_open U ‚Üí U.nonempty ‚Üí (U ‚à© s).nonempty
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (hf : function.surjective ‚áëf) [ring_hom_surjective œÉ‚ÇÅ‚ÇÇ] : galois_insertion (submodule.map f) (submodule.comap f)
 : turing.to_partrec.cfg ‚Üí turing.partrec_to_TM2.cfg' ‚Üí Prop
 : (user_attribute simp_lemmas)
{V : Type u_1} [category_theory.category V] {A‚ÇÅ B‚ÇÅ C‚ÇÅ A‚ÇÇ B‚ÇÇ C‚ÇÇ A‚ÇÉ B‚ÇÉ C‚ÇÉ : V} {f‚ÇÅ : A‚ÇÅ ‚ü∂ B‚ÇÅ} {g‚ÇÅ : B‚ÇÅ ‚ü∂ C‚ÇÅ} {f‚ÇÇ : A‚ÇÇ ‚ü∂ B‚ÇÇ} {g‚ÇÇ : B‚ÇÇ ‚ü∂ C‚ÇÇ} {f‚ÇÉ : A‚ÇÉ ‚ü∂ B‚ÇÉ} {g‚ÇÉ : B‚ÇÉ ‚ü∂ C‚ÇÉ} {Œ±‚ÇÅ : category_theory.arrow.mk f‚ÇÅ ‚ü∂ category_theory.arrow.mk f‚ÇÇ} {Œ≤‚ÇÅ : category_theory.arrow.mk g‚ÇÅ ‚ü∂ category_theory.arrow.mk g‚ÇÇ} {Œ±‚ÇÇ : category_theory.arrow.mk f‚ÇÇ ‚ü∂ category_theory.arrow.mk f‚ÇÉ} {Œ≤‚ÇÇ : category_theory.arrow.mk g‚ÇÇ ‚ü∂ category_theory.arrow.mk g‚ÇÉ} (p‚ÇÅ : Œ±‚ÇÅ.right = Œ≤‚ÇÅ.left) (p‚ÇÇ : Œ±‚ÇÇ.right = Œ≤‚ÇÇ.left) : (Œ±‚ÇÅ ‚â´ Œ±‚ÇÇ).right = (Œ≤‚ÇÅ ‚â´ Œ≤‚ÇÇ).left
{R : Type u} [ring R] (s : set R) : set R
 : expr ‚Üí list expr ‚Üí tactic expr
{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (self : submodule R M) : add_submonoid M
{Œπ : Type v} [dec_Œπ : decidable_eq Œπ] (Œ≤ : Œπ ‚Üí Type w) [Œ† (i : Œπ), add_comm_monoid (Œ≤ i)] (s : finset Œπ) : (Œ† (i : ‚Ü•‚Üës), Œ≤ i.val) ‚Üí+ direct_sum Œπ (Œª (i : Œπ), Œ≤ i)
{x : pgame} : 0 ‚â§ x ‚Üî ‚àÄ (j : x.right_moves), ‚àÉ (i : (x.move_right j).left_moves), 0 ‚â§ (x.move_right j).move_left i
{Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≥ : Type u_5} [comm_monoid Œ±] {f : Œ≤ ‚Üí Œ±} {g : Œ≥ ‚Üí Œ±} (h_eq : ‚àÄ (u : finset Œ≥), ‚àÉ (v : finset Œ≤), ‚àÄ (v' : finset Œ≤), v ‚äÜ v' ‚Üí (‚àÉ (u' : finset Œ≥), u ‚äÜ u' ‚àß u'.prod (Œª (x : Œ≥), g x) = v'.prod (Œª (b : Œ≤), f b))) : filter.map (Œª (s : finset Œ≤), s.prod (Œª (b : Œ≤), f b)) filter.at_top ‚â§ filter.map (Œª (s : finset Œ≥), s.prod (Œª (x : Œ≥), g x)) filter.at_top
{m : Type u_2} {n : Type u_3} {Œ± : Type v} [decidable_eq m] (M : matrix m n Œ±) (i : m) (b : n ‚Üí Œ±) : matrix m n Œ±
{C : Type u} [category_theory.category C] {F : category_theory.limits.walking_cospan ‚•§ C} (t : category_theory.limits.pullback_cone (F.map category_theory.limits.walking_cospan.hom.inl) (F.map category_theory.limits.walking_cospan.hom.inr)) : category_theory.limits.cone F
(R : Type u) (S‚ÇÅ : Type v) (S‚ÇÇ : Type w) [comm_semiring R] : mv_polynomial (S‚ÇÅ ‚äï S‚ÇÇ) R ‚âÉ‚Çê[R] mv_polynomial S‚ÇÅ (mv_polynomial S‚ÇÇ R)
(args : list expr) (inner : expr) : tactic expr
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [fintype K] [finite_dimensional K V] : fintype V
{R : Type u_1} {M : Type u_2} [ordered_semiring R] [ordered_add_comm_monoid M] [smul_with_zero R M] [ordered_smul R M] {a : M} {c : R} (hc : 0 < c) : 0 < a ‚Üí 0 < c ‚Ä¢ a
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (X Y : category_theory.center C) : X ‚äó Y ‚âÖ Y ‚äó X
{S : set ordinal} (hS : set.unbounded has_lt.lt S) (a : ordinal) : (S ‚à© set.Ici a).nonempty
{R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] [finite_dimensional R M] (x‚ÇÅ x‚ÇÇ : orientation R M Œπ) (h : fintype.card Œπ = finite_dimensional.finrank R M) : x‚ÇÅ ‚â† x‚ÇÇ ‚Üî x‚ÇÅ = -x‚ÇÇ
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} (f : C ‚ü∂ D) : homotopy (quot.out ((homotopy_category.quotient V c).map f)) f
{C : Type u} [category_theory.category C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : C
{S : Type u} [add_semigroup S] {a b x y z : S} (ha : add_semiconj_by a y z) (hb : add_semiconj_by b x y) : add_semiconj_by (a + b) x z
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [has_zero M‚ÇÅ] [has_scalar ‚Ñï M‚ÇÅ] [has_neg M‚ÇÅ] [has_sub M‚ÇÅ] [has_scalar ‚Ñ§ M‚ÇÅ] [subtraction_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (inv : ‚àÄ (x : M‚ÇÅ), f (-x) = -f x) (div : ‚àÄ (x y : M‚ÇÅ), f (x - y) = f x - f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : subtraction_monoid M‚ÇÅ
{Œ± : Type u} : dense_embedding has_pure.pure
{K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚ÜíL[ùïú] F) : is_bounded_linear_map ùïú ‚áëf
{k : Type u_1} [division_ring k] {Œπ : Type u_4} (s : finset Œπ) (h : ‚Üë(s.card) ‚â† 0) : s.sum (Œª (i : Œπ), finset.centroid_weights k s i) = 1
{p : ‚Ñï} (hp : nat.prime p) : p.factorization = finsupp.single p 1
(Œ± : Type u_8) (Œ≤ : Type u_9) [has_Sup Œ±] [has_Sup Œ≤] : Type (max u_8 u_9)
{M : Type u_6} {N : Type u_7} [has_add M] [has_add N] (f : add_hom M N) (g : N ‚Üí M) (h‚ÇÅ : function.left_inverse g ‚áëf) (h‚ÇÇ : function.right_inverse g ‚áëf) : add_hom N M
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : complete_lattice (lie_subalgebra R L)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F G : J ‚•§ C} [category_theory.limits.has_colimit F] [category_theory.limits.has_colimit G] (w : F ‚âÖ G) : category_theory.limits.colimit F ‚âÖ category_theory.limits.colimit G
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s1 s2 : affine_subspace k P} (hd : s1.direction = s2.direction) (hn : (‚Üës1 ‚à© ‚Üës2).nonempty) : s1 = s2
{G : Type u_7} [add_comm_group G] (L : list G) : -L.sum = (list.map (Œª (x : G), -x) L).sum
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] (Œ± : typevec n) : setoid ((mvqpf.P F).W Œ±)
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) : o.oangle (-x) y = o.oangle x (-y)
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} : L.bounded_formula Œ± n ‚Üí L.bounded_formula Œ± n ‚Üí L.bounded_formula Œ± n
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [has_zero M] (f : Œ± ‚âÉ Œ≤) : (Œ± ‚Üí‚ÇÄ M) ‚âÉ (Œ≤ ‚Üí‚ÇÄ M)
{Œ± : Type u} [ordered_add_comm_monoid Œ±] {Œ≤ : Type u_1} [has_zero Œ≤] [has_add Œ≤] [has_scalar ‚Ñï Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : ordered_add_comm_monoid Œ≤
{Œ± : Type u_1} [decidable_eq Œ±] {Œ¥ : Œ± ‚Üí Type u_2} (m : multiset Œ±) (t : Œ† (a : Œ±), multiset (Œ¥ a)) : multiset (Œ† (a : Œ±), a ‚àà m ‚Üí Œ¥ a)
(major_premise : interactive.parse tactic.interactive.cases_arg_p) (gm : interactive.parse tactic.interactive.generalisation_mode_parser) (with_patterns : interactive.parse tactic.eliminate.with_pattern.clause_parser) : tactic unit
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) (b : n ‚Üí Œ±) (h : is_unit A.det) : A.det ‚Ä¢ A‚Åª¬π.mul_vec b = ‚áë(A.cramer) b
{n : ‚Ñï} (c : composition n) (j : fin n) : fin c.length
(R : Type u_1) {Œ± : Type u_2} {l : Type u_8} {m : Type u_9} {n : Type u_10} {p : Type u_11} [comm_semiring R] [semiring Œ±] [algebra R Œ±] : matrix l m Œ± ‚Üí‚Çó[R] matrix n p Œ± ‚Üí‚Çó[R] matrix (l √ó n) (m √ó p) Œ±
{Œπ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {c : E} {l l' : filter ‚Ñù} {lt : filter Œπ} {a : ‚Ñù} [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' measure_theory.measure_space.volume) (hf : filter.tendsto f (l' ‚äì measure_theory.measure_space.volume.ae) (nhds c)) {u v : Œπ ‚Üí ‚Ñù} (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : (Œª (t : Œπ), (‚à´ (x : ‚Ñù) in u t..v t, f x) - (v t - u t) ‚Ä¢ c) =o[lt] (v - u)
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} {L‚ÇÉ : Type w‚ÇÅ} [comm_ring R] [lie_ring L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_ring L‚ÇÉ] [lie_algebra R L‚ÇÅ] [lie_algebra R L‚ÇÇ] [lie_algebra R L‚ÇÉ] (e‚ÇÅ : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) (e‚ÇÇ : L‚ÇÇ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÉ) : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÉ
(x y : ereal) : ereal
 : bool ‚Üí bool
(G : Type u_1) [add_group G] [topological_space G] : Type u_1
{x y : pgame} : x.relabelling y ‚Üí y.relabelling x
(Œ± : Type u_1) : Type u_1
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (f : Œ± ‚Üí Œ±) (x : Œ±) : ordnode Œ± ‚Üí ordnode Œ±
 : ‚Ñï ‚Üí tactic.list_Sigma name ‚Üí list (expr √ó name √ó tactic.list_Pi expr √ó list (name √ó expr)) ‚Üí tactic (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt) √ó list expr)
{Œ± : Type u} {Œ≤ : Type v} (a : Œ±) (t : tactic.ref Œ± ‚Üí tactic Œ≤) : tactic Œ≤
(K : Type v) (L : Type w) [field K] [field L] [algebra K L] (f : polynomial K) : Prop
(n : ‚Ñï) (s : set ‚Ñï) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} : option Œ± ‚Üí Œ≤ ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Œ≤
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± ‚Ñ±' : category_theory.Sheaf K A} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) : ‚Ñ± ‚âÖ ‚Ñ±'
{M : Type u_1} [has_add M] (S : add_subsemigroup M) : add_subsemigroup.closure ‚ÜëS = S
(R : Type u) [ring R] : category_theory.Mat_ (category_theory.single_obj R·µê·µí·µñ) ‚•§ category_theory.Mat R
{R : Type u_1} [comm_semiring R] (M : Type u_4) {N : Type u_5} {P : Type u_6} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] (f : N ‚Üí‚Çó[R] P) : tensor_product R M N ‚Üí‚Çó[R] tensor_product R M P
(M : Type u_5) [monoid M] {A : Type u_6} [add_monoid A] [distrib_mul_action M A] : A ‚Üí+[M] A
 : matrix (fin 2) (fin 2) ‚Ñ§
(R : Type u_1) [has_one R] [has_neg R] : quaternion R ‚âÉ R √ó R √ó R √ó R
(S : set ‚Ñï+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] : Prop
(Œ± : Type u_4) : Type u_4
 : expr ‚Üí expr ‚Üí tactic expr
{R : Type u} {L : Type v} {L' : Type w‚ÇÇ} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L') : lie_ideal R L'
{ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_3} [ordered_semiring ùïú] [add_comm_group E] [module ùïú E] {p : Œπ ‚Üí E} (hi : function.injective p) : convex_independent ùïú (Œª (x : ‚Ü•(set.range p)), ‚Üëx) ‚Üî convex_independent ùïú p
{C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_pushouts C] (F : category_theory.discrete category_theory.limits.walking_pair ‚•§ C) : category_theory.limits.colimit_cocone F
{G : Type u} [add_group G] (B : add_group_filter_basis G) : G ‚Üí filter G
{Œ± : Type u_1} [topological_space Œ±] (s : topological_space.positive_compacts Œ±) : topological_space.nonempty_compacts Œ±
(Œ± : Type u_3) [topological_space Œ±] : Prop
(F : Type u_1) (K : Type u_2) [field F] [field K] [algebra F K] : Prop
{Œ± : Type u} {Œ≤ : Type v} [semigroup Œ≤] (f : Œ± ‚Üí Œ≤) : Œ± ‚Üí list Œ± ‚Üí Œ≤
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {s : set E} (hscomp : is_compact s) (hsnemp : s.nonempty) : (set.extreme_points ‚Ñù s).nonempty
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (a b c : P) : has_dist.dist a b ^ 2 + has_dist.dist a c ^ 2 = 2 * (has_dist.dist a (midpoint ‚Ñù b c) ^ 2 + (has_dist.dist b c / 2) ^ 2)
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] {c : con M} {f : N ‚Üí* M} : con.comap ‚áëf _ c = con.ker (c.mk'.comp f)
{Œ± : Type u_1} [encodable Œ±] : list Œ± ‚Üí ‚Ñï
{G : Type u_2} [add_group G] : add_submonoid G ‚âÉo add_submonoid G
{n : ‚Ñï} {Œ± : fin n ‚Üí Type u} (a : d_array n Œ±) (i : fin n) : Œ± i
(R : Type u_1) {S : Type u_2} {M : Type u_3} [comm_ring R] [ring S] [add_comm_group M] [algebra R S] [module S M] [module R M] [is_scalar_tower R S M] (h : is_artinian R M) : is_artinian S M
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] : cont_diff ùïú ‚ä§ ‚áë((equiv.prod_assoc E F G).symm)
{R : Type u_1} [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] : disjoint (tensor_algebra.Œπ R).range 1
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] (Œπ : Type u_6) (Z : topological_vector_bundle_core R B F Œπ) : topological_space Z.total_space
{Œ± : Type u_1} : lists Œ± ‚Üí list (lists Œ±)
(C : Type u) [category_theory.category C] : Prop
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddCommMon) : AddMon
 : tactic unit
 : tactic.interactive.itactic ‚Üí tactic unit
(p : ‚Ñù √ó ‚Ñù) (hp : p.fst ‚â† 0) {n : with_top ‚Ñï} : cont_diff_at ‚Ñù n (Œª (p : ‚Ñù √ó ‚Ñù), p.fst ^ p.snd) p
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [comm_semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] (f : multilinear_map R M‚ÇÅ R) (z : M‚ÇÇ) : multilinear_map R M‚ÇÅ M‚ÇÇ
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : C(Œ±, Œ≤)) : continuous ‚áëf
{Œ± : Type u} {Œ≤ : Type v} {p : Œ± ‚Üí Prop} (f : Œ† (a : Œ±), p a ‚Üí Œ≤) (l : list Œ±) : (‚àÄ (a : Œ±), a ‚àà l ‚Üí p a) ‚Üí list Œ≤
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : galois_insertion (lie_submodule.lie_span R L) coe
(A : Type u_1) [comm_ring A] [algebra ‚Ñö A] : power_series A
{Œ± : Type u} [preorder Œ±] {a b : Œ±} (h : a < b) : ¬¨b ‚â§ a
{M : Type u_1} [add_monoid M] (u : add_units M) (a : M) : is_add_unit (‚Üëu + a) ‚Üî is_add_unit a
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : local_equiv Œ± Œ≤) : ‚Ü•(e.source) ‚âÉ ‚Ü•(e.target)
{Œì : Type u_1} {R : Type u_2} [partial_order Œì] [add_comm_monoid R] {Œ± : Type u_3} (f : Œ± ‚Üí‚ÇÄ hahn_series Œì R) : hahn_series.summable_family Œì R Œ±
{Œ± : Type u} (s : computation Œ±) [h : s.terminates] : ‚Ñï
{Œ± : Sort u} (f : Œ± ‚Üí Œ±) (h : function.involutive f) : equiv.perm Œ±
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b : Œ±} (ha : a < 0) (hb : b ‚â§ 0) : a + b < 0
{Œ± : Type u} [pseudo_emetric_space Œ±] (Œ¥ : ‚Ñù) : metric.thickening Œ¥ ‚àÖ = ‚àÖ
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G G' : D ‚•§ C} (adj1 : F ‚ä£ G) (adj2 : F ‚ä£ G') : G ‚âÖ G'
 : pgame ‚Üí pgame
(J : Type u‚ÇÅ) [category_theory.category J] : category_theory.decomposed J ‚•§ J
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚âÉ‚Çú Œ≤) : topological_space.opens Œ± ‚âÉo topological_space.opens Œ≤
{Œ± : Type u} {f : filter Œ±} {Œ≤ : Type v} {s : Œ≤ ‚Üí set Œ±} (is : finset Œ≤) : (‚ãÇ (i : Œ≤) (H : i ‚àà is), s i) ‚àà f ‚Üî ‚àÄ (i : Œ≤), i ‚àà is ‚Üí s i ‚àà f
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] {Z : D} (F : C ‚•§ D) (hZ : category_theory.limits.is_initial Z) : category_theory.with_initial C ‚•§ D
{J : Type u‚ÇÅ} [category_theory.category J] (j : category_theory.connected_components J) : category_theory.component j ‚•§ category_theory.decomposed J
{G : Type u_1} [group G] (H : subgroup G) [H.is_commutative] [fintype (G ‚ß∏ H)] : Type u_1
(a b : simplex_category) : Type
{C : Type u‚ÇÅ} [category_theory.category C] {X Y Z : C} (p : X ‚ü∂ Y) (q : Z = Y) : _.mpr p = p ‚â´ category_theory.eq_to_hom _
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) : hb.oangle (‚áë(hb.rotation (hb.oangle x y)) x) y = 0
{M : Type u_1} [add_monoid M] {s : set M} : s ‚äÜ add_monoid.closure s
{C : Type u} [category_theory.category C] {Œ≤ : Type v} [category_theory.limits.has_zero_morphisms C] (f : Œ≤ ‚Üí C) [category_theory.limits.has_colimit (category_theory.discrete.functor f)] (b : Œ≤) : category_theory.split_mono (category_theory.limits.sigma.Œπ f b)
 : ‚Ü•{r : ennreal | r ‚â† ‚ä§} ‚âÉ·µê nnreal
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (oi : Œ± ‚âÉo Œ≤) : galois_connection ‚áëoi ‚áë(oi.symm)
(X Y : Type u) : category_theory.limits.binary_fan X Y
{Œ± : Type u_1} (l : filter Œ±) (Œ≤ : Type u_2) : setoid (Œ± ‚Üí Œ≤)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] {F G : C ‚•§ D} (H : D ‚•§ E) [category_theory.full H] [category_theory.faithful H] (comp_iso : F ‚ãô H ‚âÖ G ‚ãô H) : F ‚âÖ G
{Œ± : Type u_1} {Œ≤ : Type u_2} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üío Œ≤) : antisymmetrization Œ± has_le.le ‚Üío antisymmetrization Œ≤ has_le.le
{R : Type u_1} {M : Type u_2} [ring R] [topological_space R] [topological_space M] [add_comm_group M] [has_continuous_add M] [module R M] [has_continuous_smul R M] [(nhds_within 0 {x : R | is_unit x}).ne_bot] (s : submodule R M) (hs : (interior ‚Üës).nonempty) : s = ‚ä§
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [comm_monoid Œ≤] : comm_monoid Œ±
{T : ‚Ñù} {g : ‚Ñù ‚Üí ‚Ñù} (hg : function.periodic g T) (h_int : ‚àÄ (t‚ÇÅ t‚ÇÇ : ‚Ñù), interval_integrable g measure_theory.measure_space.volume t‚ÇÅ t‚ÇÇ) (h‚ÇÄ : ‚àÄ (x : ‚Ñù), 0 < g x) (hT : 0 < T) : filter.tendsto (Œª (t : ‚Ñù), ‚à´ (x : ‚Ñù) in 0..t, g x) filter.at_bot filter.at_bot
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_group Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} : convex_on ùïú s f ‚Üí concave_on ùïú s (-f)
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : triv_sq_zero_ext R M ‚Üí‚Çó[R] M
{Œ± : Type u} [preorder Œ±] [bounded_random Œ±] (x y : Œ±) (h : x ‚â§ y) : tactic (stream ‚Ü•(set.Icc x y))
{R : Type u_1} [semiring R] [topological_space R] [topological_semiring R] (p : polynomial R) : C(R, R)
(R : Type u_1) [comm_ring R] [with_ideal R] (M : Type u_2) [add_comm_group M] [module R M] : topological_space M
 : tactic.decl_reducibility ‚Üí name
{M : Type u_1} {Œ± : Type u_2} [measurable_space M] [measurable_space Œ±] [has_scalar M Œ±] [has_scalar M·µê·µí·µñ Œ±] [is_central_scalar M Œ±] [has_measurable_smul‚ÇÇ M Œ±] : has_measurable_smul‚ÇÇ M·µê·µí·µñ Œ±
{Œ± : Type u} [topological_space Œ±] (Z : ‚Ñï ‚Üí set Œ±) (hZd : ‚àÄ (i : ‚Ñï), Z (i + 1) ‚äÜ Z i) (hZn : ‚àÄ (i : ‚Ñï), (Z i).nonempty) (hZ0 : is_compact (Z 0)) (hZcl : ‚àÄ (i : ‚Ñï), is_closed (Z i)) : (‚ãÇ (i : ‚Ñï), Z i).nonempty
{R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] [is_localization M S] (z : S) : ‚áë(algebra_map R S) (is_localization.sec M z).fst = ‚áë(algebra_map R S) ‚Üë((is_localization.sec M z).snd) * z
{R : Type u_1} {a b : R} [comm_semigroup R] : is_regular (a * b) ‚Üî is_regular a ‚àß is_regular b
{Œ∑ : Type u_5} {f : Œ∑ ‚Üí Type u_6} [Œ† (i : Œ∑), group (f i)] [decidable_eq Œ∑] [fintype Œ∑] {H : Œ† (i : Œ∑), subgroup (f i)} {J : subgroup (Œ† (i : Œ∑), f i)} : subgroup.pi set.univ H ‚â§ J ‚Üî ‚àÄ (i : Œ∑), subgroup.map (monoid_hom.single f i) (H i) ‚â§ J
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {s : set Œ±} (hf : set.eq_on f 1 s) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)) = 1
(Œ± : Type u_1) (Œ≤ : Type u_2) : psum Œ± Œ≤ ‚âÉ Œ± ‚äï Œ≤
(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (s : affine_subspace k P) : p ‚àà ‚Üës ‚Üî p ‚àà s
(k : Type u_1) (P‚ÇÅ : Type u_2) {V‚ÇÅ : Type u_6} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÅ
{R‚ÇÇ : Type u_5} {M‚ÇÇ : Type u_6} [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] (f g : M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] R‚ÇÇ) : bilin_form R‚ÇÇ M‚ÇÇ
{Œ± : Type u_1} [has_sub Œ±] [has_zero Œ±] (a b : with_top Œ±) : with_top Œ±
(h : name) (t v : expr) : smt_tactic unit
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) [complete_space ‚Ü•K] : E ‚âÉ‚Çó·µ¢[ùïú] E
{Œ± : Type u} : lazy_list Œ± ‚Üí lazy_list Œ±
(e : expr) : tactic.ring.ring_m ‚Ñï
(d : declaration) : tactic (option decl_info)
(Œ± : Type u) [uniform_space Œ±] : Prop
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} {x : P.last.M} {a : P.A} {f : P.last.B a ‚Üí P.last.M} (h : x.dest = ‚ü®a, f‚ü©) (f' : typevec.arrow (mvpfunctor.M.path P x) Œ±) (j : P.last.B a) : typevec.arrow (mvpfunctor.M.path P (f j)) Œ±
 : list tactic.suggest.decl_data ‚Üí list tactic.suggest.decl_data
{C : Type u_1} [category_theory.category C] (P : category_theory.idempotents.karoubi C) : P ‚ü∂ ‚Üë(P.X)
{Œì‚ÇÄ : Type u_1} [linear_ordered_comm_group_with_zero Œì‚ÇÄ] (Œ≥ : Œì‚ÇÄÀ£) : {‚ÜëŒ≥} ‚àà nhds ‚ÜëŒ≥
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} {r : ‚Ñù} (hr : 0 ‚â§ r) (H1 : ‚àÄ (x : Œ±), x ‚àà s ‚Üí metric.inf_dist x t ‚â§ r) (H2 : ‚àÄ (x : Œ±), x ‚àà t ‚Üí metric.inf_dist x s ‚â§ r) : metric.Hausdorff_dist s t ‚â§ r
{R : Type u_1} {R‚ÇÅ : Type u_2} {R‚ÇÇ : Type u_3} {M‚ÇÅ : Type u_6} {M‚ÇÇ : Type u_7} [comm_semiring R] [comm_semiring R‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {I‚ÇÅ : R‚ÇÅ ‚Üí+* R} {I‚ÇÇ : R‚ÇÇ ‚Üí+* R} {B : M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ] M‚ÇÇ ‚Üí‚Çõ‚Çó[I‚ÇÇ] R} : B.separating_left ‚Üî B.ker = ‚ä•
{Œ± : Type u_1} {M : Type u_4} [add_comm_monoid M] [topological_space M] {m n : measurable_space Œ±} (v : measure_theory.vector_measure Œ± M) (hle : m ‚â§ n) : measure_theory.vector_measure Œ± M
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {ps : set P} {n : ‚Ñï} [finite_dimensional ‚Ñù V] (hd : finite_dimensional.finrank ‚Ñù V = n) (hc : euclidean_geometry.cospherical ps) {sx‚ÇÅ sx‚ÇÇ : affine.simplex ‚Ñù P n} (hsx‚ÇÅ : set.range sx‚ÇÅ.points ‚äÜ ps) (hsx‚ÇÇ : set.range sx‚ÇÇ.points ‚äÜ ps) : sx‚ÇÅ.circumcenter = sx‚ÇÇ.circumcenter
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] (h : Œ± ‚âÉ·µê Œ≤) : Œ≤ ‚Üí Œ±
{L : first_order.language} {M : Type u_3} [L.Structure M] (N : L.substructure M) : Prop
{Œ± : Type u_1} {p : Prop} {q : Œ± ‚Üí Prop} : p ‚Üí ‚àÄ (x : Œ±), q x ‚Üî ‚àÄ (x : Œ±), p ‚Üí q x
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A B : matrix n n Œ±) (h : B.mul A = 1) : invertible A.det
(X : Top) (T : ‚Ü•X ‚Üí Type v) : Top.presheaf (Type v) X
(Œ± : Type u) [s : lattice Œ±] [add_comm_group Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] : distrib_lattice Œ±
{M : Type u_1} [add_monoid M] (c : add_con M) (n : ‚Ñï) {w x : M} : ‚áëc w x ‚Üí ‚áëc (n ‚Ä¢ w) (n ‚Ä¢ x)
(k : Type u‚ÇÅ) (G : Type u‚ÇÇ) [semiring k] : Type (max u‚ÇÅ u‚ÇÇ)
(R : Type u) [ring R] : Prop
{R : Type u} {N : Type z} [semiring R] [add_comm_monoid N] [module R N] {P : Type v} [add_comm_monoid P] [module R P] (h : module.free R P) (e : P ‚âÉ‚Çó[R] N) : module.free R N
{Œ± : Type u_1} [measurable_space Œ±] : has_coe (measure_theory.probability_measure Œ±) (measure_theory.measure Œ±)
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {t : category_theory.limits.fork f g} (ht : category_theory.limits.is_limit t) (Z : C) : (Z ‚ü∂ t.X) ‚âÉ {h // h ‚â´ f = h ‚â´ g}
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±] {a b : Œ±} (hab : a ‚â† b) : closure (set.Ico a b) = set.Icc a b
 : smt_tactic unit
 : ‚Ñï ‚Üí tactic unit
{R : Type u} [comm_ring R] {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group N] [module R N] [lie_ring_module L N] [lie_module R L N] : lie_module R L (tensor_product R M N)
 : (user_attribute simp_lemmas)
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (O : finset C) (H : finset (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y)) {X Y : C} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y} (mf : ‚ü®X, ‚ü®Y, ‚ü®mX, ‚ü®mY, f‚ü©‚ü©‚ü©‚ü© ‚àà H) : category_theory.is_cofiltered.inf_to O H mX ‚â´ f = category_theory.is_cofiltered.inf_to O H mY
{V : Type u} {G : simple_graph V} : G ‚âÉg G
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_comm_group Œ±] [uniform_space Œ±] [uniform_add_group Œ±] [t1_space Œ±] (f : Œ≤ ‚Üí Œ±) : filter.tendsto (Œª (s : finset Œ≤), ‚àë' (b : {x // x ‚àâ s}), f ‚Üëb) filter.at_top (nhds 0)
{Œ± : Type u} {Œ≤ : Type v} [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] (f : Œ± ‚Üí Œ≤) (g : Œ± ‚ÜíùíÑ Œ≤) (h : f = ‚áëg) : Œ± ‚ÜíùíÑ Œ≤
{R : Type u_1} [rack R] (x : R) : R ‚âÉ R
 : tactic unit
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {K K' : lie_subalgebra R L} (h : K ‚â§ K') : ‚Ü•K ‚Üí‚Çó‚ÅÖR‚ÅÜ ‚Ü•K'
{L : first_order.language} {M : Type w} [L.Structure M] {A : set M} {Œ± : Type u_1} : has_compl (L.definable_set A Œ±)
{R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (h : function.injective ‚áë(algebra_map R A)) (p : ‚Ñï) [char_p R p] : char_p A p
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 : P} (h : p1 -·µ• p2 = 0) : p1 = p2
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : GL n R ‚âÉ* linear_map.general_linear_group R (n ‚Üí R)
(a b : num) : num
{Œ± : Type u'} {Œ≤ : Type v'} (f : Œ± ‚Üí Œ≤) : first_order.language.constants_on Œ± ‚Üí·¥∏ first_order.language.constants_on Œ≤
 : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {Y : C} {S : C ‚•§ D} [category_theory.full S] [category_theory.faithful S] : category_theory.limits.is_terminal (category_theory.costructured_arrow.mk (ùüô (S.obj Y)))
{ùïú : Type u_2} {E : Type u_5} [comm_semiring ùïú] [topological_space ùïú] [has_continuous_add ùïú] [has_continuous_const_smul ùïú ùïú] [add_comm_monoid E] [module ùïú E] [topological_space E] (M : Type u_1) [monoid M] [distrib_mul_action M ùïú] [smul_comm_class ùïú M ùïú] [has_continuous_const_smul M ùïú] : distrib_mul_action M (weak_dual ùïú E)
(F : Type u_1) (E : Type u_2) [field F] [field E] [algebra F E] [finite_dimensional F E] (K : Type u_3) [field K] [algebra F K] : fintype (E ‚Üí‚Çê[F] K)
{Œ±‚ÇÅ : Type u_1} {Œ≤‚ÇÅ : Type u_2} [decidable_eq Œ±‚ÇÅ] (a : Œ±‚ÇÅ) (e : equiv.perm Œ≤‚ÇÅ) : equiv.perm (Œ±‚ÇÅ √ó Œ≤‚ÇÅ)
{G : Type u_1} [add_group G] [hN : nontrivial G] : add_monoid.is_torsion G ‚Üí ¬¨add_monoid.is_torsion_free G
{C : Type u‚ÇÅ} [category_theory.category C] {A : C} {f : category_theory.over A} (h‚ÇÅ : ‚àÄ (f_1 : category_theory.mono_over f), category_theory.mono (f.iterated_slice_equiv.functor.obj ((category_theory.mono_over.forget f).obj f_1)).hom) (h‚ÇÇ : ‚àÄ (f_1 : category_theory.mono_over f.left), category_theory.mono (f.iterated_slice_equiv.inverse.obj ((category_theory.mono_over.forget f.left).obj f_1)).hom) : category_theory.mono_over f ‚âå category_theory.mono_over f.left
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [topological_space Œ±] [pseudo_metric_space Œ≤] [pseudo_metric_space Œ≥] {G : Œ≤ ‚Üí Œ≥} {C : nnreal} (H : lipschitz_with C G) : uniform_continuous (bounded_continuous_function.comp G H)
(lcs : expr_set) : name_set
{Œπ : Type u_1} {Œ± : Type u_2} [has_zero Œ±] (f : Œπ ‚Üí‚ÇÄ finset Œ±) : finset (Œπ ‚Üí‚ÇÄ Œ±)
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} (a b : M) : ‚áë(clifford_algebra.Œπ Q) a * ‚áë(clifford_algebra.Œπ Q) b + ‚áë(clifford_algebra.Œπ Q) b * ‚áë(clifford_algebra.Œπ Q) a = ‚áë(algebra_map R (clifford_algebra Q)) (quadratic_form.polar ‚áëQ a b)
{Œ± : Type u_2} [add_monoid Œ±] (s : set Œ±) : Prop
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (f : M ‚Üí* P) : function.injective ‚áë(con.ker_lift f)
{A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ} [category_theory.category A] [category_theory.category B] [category_theory.category C] {U : B ‚•§ C} {F : C ‚•§ B} (R : A ‚•§ B) (adj‚ÇÅ : F ‚ä£ U) [Œ† (X : B), category_theory.regular_epi (adj‚ÇÅ.counit.app X)] [category_theory.limits.has_reflexive_coequalizers A] [category_theory.is_right_adjoint (R ‚ãô U)] : category_theory.is_right_adjoint R
(X : Top) : (topological_space.opens.to_Top X).obj ‚ä§ ‚âÖ X
{G : Type u_3} [add_group G] (P : add_subgroup G) : Prop
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] {S T : intermediate_field K L} (h : ‚àÄ (x : L), x ‚àà S ‚Üî x ‚àà T) : S = T
{R : Type u} [ring R] (p : polynomial R) : polynomial ‚Ü•(subring.closure ‚Üë(p.frange))
{X Y : SemiNormedGroup} (f : X ‚ü∂ Y) : Y ‚ü∂ SemiNormedGroup.explicit_cokernel f
{R : Type u} {L : Type v} {L' : Type w‚ÇÇ} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L') {I‚ÇÅ I‚ÇÇ : lie_ideal R L} : lie_ideal.map f ‚ÅÖI‚ÇÅ,I‚ÇÇ‚ÅÜ ‚â§ ‚ÅÖlie_ideal.map f I‚ÇÅ,lie_ideal.map f I‚ÇÇ‚ÅÜ
(Œ± : Type u_1) (Œ≤ : Type u_2) [topological_space Œ±] [topological_space Œ≤] [discrete_topology Œ±] : C(Œ±, Œ≤) ‚âÉ (Œ± ‚Üí Œ≤)
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : is_closed (frontier s)
 : tactic (list name)
{Œ± : Type u_1} {M : Type u_5} [add_monoid M] (l : filter Œ±) : (Œ± ‚Üí M) ‚Üí+ l.germ M
(G : pgame) : Prop
{G : Type u_1} [group G] (H : subgroup G) : H = ‚ä• ‚à® ‚àÉ (x : G) (H : x ‚àà H), x ‚â† 1
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {f : E √ó F ‚Üí G} (h : is_bounded_bilinear_map ùïú f) : continuous f
{Œ± : Type u} [pseudo_metric_space Œ±] {f : ‚Ñï ‚Üí Œ±} {m n : ‚Ñï} (hmn : m ‚â§ n) {d : ‚Ñï ‚Üí ‚Ñù} (hd : ‚àÄ {k : ‚Ñï}, m ‚â§ k ‚Üí k < n ‚Üí has_dist.dist (f k) (f (k + 1)) ‚â§ d k) : has_dist.dist (f m) (f n) ‚â§ (finset.Ico m n).sum (Œª (i : ‚Ñï), d i)
{m : Type u ‚Üí Type u} [applicative m] {Œ± Œ≤ : Type u} (F : Œ± ‚Üí m Œ≤) (x : free_add_semigroup Œ±) : m (free_add_semigroup Œ≤)
 : omega.clause ‚Üí tactic expr
{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) (r : R) : A
{A : Type u_4} [comm_ring A] [is_domain A] {L : Type u_6} [field L] [algebra A L] (alg : algebra.is_algebraic A L) (inj : ‚àÄ (x : A), ‚áë(algebra_map A L) x = 0 ‚Üí x = 0) : is_fraction_ring ‚Ü•(integral_closure A L) L
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {p : Sort u} (x : add_localization S) (f : M ‚Üí ‚Ü•S ‚Üí p) (H : ‚àÄ {a c : M} {b d : ‚Ü•S}, ‚áë(add_localization.r S) (a, b) (c, d) ‚Üí f a b = f c d) : p
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ (w+1) (w'+1))
{Œ± : Type u} {Œ≤ : Type v} {C : Œ≤ ‚Üí Sort u_1} (l : list Œ±) (op : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (b : Œ≤) (hb : C b) (hl : Œ† (b : Œ≤), C b ‚Üí Œ† (a : Œ±), a ‚àà l ‚Üí C (op a b)) : C (list.foldr op b l)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] [normed_group G] [normed_space ùïú G] (q : formal_multilinear_series ùïú F G) (p : formal_multilinear_series ùïú E F) (N : ‚Ñï) (z : E) : q.partial_sum N ((finset.Ico 1 N).sum (Œª (i : ‚Ñï), ‚áë(p i) (Œª (j : fin i), z))) = (formal_multilinear_series.comp_partial_sum_target 0 N N).sum (Œª (i : Œ£ (n : ‚Ñï), composition n), ‚áë(q.comp_along_composition p i.snd) (Œª (j : fin i.fst), z))
{Œ± : Sort u_1} (P : Prop) [decidable P] (a b : Œ±) : dite P (Œª (h : P), a) (Œª (h : ¬¨P), b) = ite P a b
{Œ± : Type u_2} [decidable_eq Œ±] [has_sub Œ±] : has_sub (finset Œ±)
(g : ‚Ü•(matrix.GL_pos (fin 2) ‚Ñù)) (z : upper_half_plane) : ‚ÑÇ
{Œ± : Type u} {line col : ‚Ñï} (f : thunk Œ±) : Œ±
(Œ± : Type u_5) (Œ≤ : Type u_6) [non_unital_non_assoc_semiring Œ±] [non_unital_non_assoc_semiring Œ≤] : Type (max u_5 u_6)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : filter Œπ} (h : tendsto_uniformly F f p) (g : Œ≥ ‚Üí Œ±) : tendsto_uniformly (Œª (n : Œπ), F n ‚àò g) (f ‚àò g) p
{d : ‚Ñ§} : has_zero (‚Ñ§‚àöd)
{C : Type u} [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} {F F' : category_theory.limits.mono_factorisation f} (hI : F.I = F'.I) (hm : F.m = category_theory.eq_to_hom hI ‚â´ F'.m) : F = F'
{Œ± : Type u_1} : galois_insertion measurable_space.generate_from (Œª (m : measurable_space Œ±), {t : set Œ± | measurable_set t})
{X : Type u_1} [topological_space X] [has_add X] [has_continuous_add X] {a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : X} (Œ≥‚ÇÅ : path a‚ÇÅ b‚ÇÅ) (Œ≥‚ÇÇ : path a‚ÇÇ b‚ÇÇ) : path (a‚ÇÅ + a‚ÇÇ) (b‚ÇÅ + b‚ÇÇ)
(Œ± : Type u_1) : Type u_1
 : tactic expr
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine.simplex ‚Ñù P 0) (i : fin 1) : s.circumcenter = s.points i
{M : Type u_1} [nonempty M] [semigroup M] [topological_space M] [compact_space M] [t2_space M] (continuous_mul_left : ‚àÄ (r : M), continuous (Œª (_x : M), _x * r)) : ‚àÉ (m : M), m * m = m
{R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] (a : RÀ£) : is_smul_regular M ‚Üëa
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÅ) [category_theory.category D] : category_theory.category (C ‚äï D)
 : ennreal ‚Üí ‚Ñù ‚Üí ennreal
{cb : char_buffer} {n n' val : ‚Ñï} (h : parser.nat cb n = parse_result.done n' val) (hn : n' < buffer.size cb) : '0' ‚â§ buffer.read cb ‚ü®n', hn‚ü© ‚Üí '9' < buffer.read cb ‚ü®n', hn‚ü©
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] [has_add Œ≤] : add_hom Œ±·µê·µí·µñ Œ≤·µê·µí·µñ ‚âÉ add_hom Œ± Œ≤
{Œ± : Type u‚ÇÅ} : category_theory.discrete Œ± ‚âÉ Œ±
{Œ± : Type u} {f g : Œ± ‚Üí Œ±} (h : function.commute f g) : set.bij_on f (function.fixed_points (f ‚àò g)) (function.fixed_points (f ‚àò g))
{R : Type u} [semiring R] (p : polynomial R) : polynomial R
{V : Type u} {G : simple_graph V} (u v w : V) (h : G.adj u v) (p : G.walk v w) : G.walk u w
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {l : filter Œ±} {a : Œ±} : is_max_filter (‚áëorder_dual.to_dual ‚àò f) l a ‚Üí is_min_filter f l a
{Œ± : Type u} (a : Œ±) : seq Œ± ‚Üí seq Œ±
{A : Type u_4} {B : Type u_5} {C : Type u_6} [add_monoid A] [add_monoid B] [add_monoid C] [topological_space A] [topological_space B] [topological_space C] (g : continuous_add_monoid_hom B C) (f : continuous_add_monoid_hom A B) : continuous_add_monoid_hom A C
{X Y : Group} (e : ‚Ü•X ‚âÉ* ‚Ü•Y) : X ‚âÖ Y
{A : Type u_4} {B : Type u_5} {E : Type u_8} [monoid A] [monoid B] [comm_group E] [topological_space A] [topological_space B] [topological_space E] [topological_group E] (f : continuous_monoid_hom A E) (g : continuous_monoid_hom B E) : continuous_monoid_hom (A √ó B) E
(x : ‚Ñù) : ‚Ñù
{m : Type u_1} {n : Type u_2} [fintype m] [fintype n] {R : Type v} [field R] : finite_dimensional.finrank R (matrix m n R) = fintype.card m * fintype.card n
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {x : E} (hf : has_strict_fderiv_at f f' x) (K : nnreal) (hK : ‚à•f'‚à•‚Çä < K) : ‚àÉ (s : set E) (H : s ‚àà nhds x), lipschitz_on_with K f s
{Œ± : Type u_1} {f g : filter Œ±} (F : f.realizer) (G : g.realizer) : (f.prod g).realizer
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : (C ‚•§ D)·µí·µñ ‚âå C·µí·µñ ‚•§ D·µí·µñ
 : Type (u+1)
{G : Type u_2} (R : Type u_3) (A : Type u_4) [comm_semiring R] [semiring A] [algebra R A] [group G] [mul_semiring_action G A] [smul_comm_class G R A] (g : G) : A ‚âÉ‚Çê[R] A
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D·µí·µñ) (G : D·µí·µñ ‚•§ C·µí·µñ) (h : G.unop ‚ä£ F.unop) : F ‚ä£ G
{Œ± : Type u} [uniform_space Œ±] {f : filter Œ±} (hf : cauchy f) {U : ‚Ñï ‚Üí set (Œ± √ó Œ±)} (U_mem : ‚àÄ (n : ‚Ñï), U n ‚àà uniformity Œ±) (n : ‚Ñï) : Œ±
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
(n : ‚Ñï+) : n.factor_multiset.prod = n
{R : Type u} {n : ‚Ñï} {M : fin n.succ ‚Üí Type v} {M‚ÇÇ : Type v‚ÇÇ} [comm_semiring R] [Œ† (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : fin n.succ), module R (M i)] [module R M‚ÇÇ] (f : multilinear_map R M M‚ÇÇ) : multilinear_map R (Œª (i : fin n), M (‚áëfin.cast_succ i)) (M (fin.last n) ‚Üí‚Çó[R] M‚ÇÇ)
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a b : Œ±} (ha : a < 1) (hb : b < 1) : a * b < 1
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] (X : C) : category_theory.is_pullback 0 0 0 (ùüô X)
{M : Type u_1} [monoid M] (c : con M) (n : ‚Ñï) {w x : M} : ‚áëc w x ‚Üí ‚áëc (w ^ n) (x ^ n)
{Œ± : Type u_1} {M : Type u_5} [has_zero M] {b : M} (h : b ‚â† 0) : function.injective (Œª (a : Œ±), finsupp.single a b)
 : tactic unit
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (f : M ‚Üí N) (H : ‚àÄ (x y : M), f (x * y) = f x * f y) (c : con N) : con M
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {P : C ‚Üí Prop} [category_theory.monoidal_category.monoidal_predicate P] {P' : C ‚Üí Prop} [category_theory.monoidal_category.monoidal_predicate P'] (h : ‚àÄ ‚¶ÉX : C‚¶Ñ, P X ‚Üí P' X) : category_theory.monoidal_functor {X // P X} {X // P' X}
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_top Œ±] [has_top Œ≤] (f : top_hom Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : top_hom Œ± Œ≤
{K : Type u_1} [is_R_or_C K] : K ‚Üí*‚ÇÄ ‚Ñù
{X Y : Type u} [comm_ring X] [comm_ring Y] : X ‚âÉ+* Y ‚âÖ CommRing.of X ‚âÖ CommRing.of Y
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} [category_theory.split_mono f] [category_theory.mono (category_theory.retraction f)] : category_theory.is_iso f
{Œ± : Type u} (P : Œ± ‚Üí Prop) : ordnode Œ± ‚Üí Prop
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [dec : decidable_eq Œπ] [Œ† (i : Œπ), has_zero (Œ≤ i)] {i j : Œπ} {xi : Œ≤ i} {xj : Œ≤ j} (h : ‚ü®i, xi‚ü© = ‚ü®j, xj‚ü©) : dfinsupp.single i xi = dfinsupp.single j xj
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y Z : C} {f g : X ‚ü∂ Y} {h : Y ‚ü∂ Z} (w : f ‚â´ h = g ‚â´ h) [category_theory.limits.reflects_colimit (category_theory.limits.parallel_pair f g) G] (l : category_theory.limits.is_colimit (category_theory.limits.cofork.of_œÄ (G.map h) _)) : category_theory.limits.is_colimit (category_theory.limits.cofork.of_œÄ h w)
{Œ± : Type u_1} {Œ≤ : Type u_2} [semilattice_sup Œ±] [order_bot Œ±] (s : finset Œ≤) (f : Œ≤ ‚Üí Œ±) : Œ±
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] {M : matrix n n R} {i j : n} (i_ne_j : i ‚â† j) (hij : M i = M j) : M.det = 0
{Œ± : Type u_1} {Œ≤ : Type u_2} [encodable Œ±] (f : Œ≤ ‚Üí Œ±) (finv : Œ± ‚Üí option Œ≤) (linv : ‚àÄ (b : Œ≤), finv (f b) = option.some b) : encodable Œ≤
(r : ennreal) : ‚àë' (n : ‚Ñï), r ^ n = (1 - r)‚Åª¬π
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) (Œ≤ : Œ± ‚Üí Type u_2) [decidable_pred p] : (Œ† (i : Œ±), Œ≤ i) ‚âÉ (Œ† (i : {x // p x}), Œ≤ ‚Üëi) √ó Œ† (i : {x // ¬¨p x}), Œ≤ ‚Üëi
{Œ± Œ≤ : Type} (ea : computability.fin_encoding Œ±) (eb : computability.fin_encoding Œ≤) (f : Œ± ‚Üí Œ≤) : Type 1
(E : Type u_1) [normed_group E] : ‚Ñï
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (S : category_theory.sieve X) : C·µí·µñ ‚•§ Type v‚ÇÅ
{V : Type u} {G : simple_graph V} (G' : G.subgraph) (V'' : set V) (hV : V'' = G'.verts) (adj' : V ‚Üí V ‚Üí Prop) (hadj : adj' = G'.adj) : G.subgraph
{p : ‚Ñï} [fact (nat.prime p)] : witt_vector.is_poly‚ÇÇ p (Œª (_x : Type u_1) (_x_1 : comm_ring _x), has_mul.mul)
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] {v‚ÇÅ v‚ÇÇ : valuation R Œì‚ÇÄ} : v‚ÇÅ = v‚ÇÇ ‚Üî ‚àÄ (r : R), ‚áëv‚ÇÅ r = ‚áëv‚ÇÇ r
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (P : C ‚Üí Prop) [category_theory.monoidal_category.monoidal_predicate P] [category_theory.braided_category C] : category_theory.braided_category {X // P X}
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) [lie_algebra.is_nilpotent R ‚Ü•H] (h : lie_algebra.zero_root_subalgebra R L H = H) : H.is_cartan_subalgebra
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : Œ± ‚Üí Œ≤ ‚Üí Prop) (s : finset Œ±) (b : Œ≤) [Œ† (a : Œ±), decidable (r a b)] : finset Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D·µí·µñ) [category_theory.limits.preserves_limits F] : category_theory.limits.preserves_colimits F.left_op
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] [category_theory.limits.preserves_binary_biproducts F] : category_theory.limits.preserves_colimits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F
{Œ± : Type u_1} {ùíú : finset (finset Œ±)} {r : ‚Ñï} : ùíú.slice r ‚äÜ ùíú
{Œ± : Type u} [t : topological_space Œ±] (s : set Œ±) : Prop
{Œ± : Type u_2} {Œ≤ : Type u_3} {r : Œ± ‚Üí Œ≤ ‚Üí Prop} (c : concept Œ± Œ≤ r) : concept Œ≤ Œ± (function.swap r)
{C : Type u_1} (A : C) : category_theory.ulift_hom C
{Œ± : Type} {m : Type ‚Üí Type} [monad m] (e : environment) (x : Œ±) (fn : declaration ‚Üí Œ± ‚Üí m Œ±) : m Œ±
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {X : category_theory.simplicial_object C} (q : ‚Ñï) : homotopy (algebraic_topology.dold_kan.HœÉ q) 0
(Œ± : Type u_1) : Type u_1
(p q : tactic.itauto.and_kind) : ordering
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b : Œ±} (ha : a ‚â§ 0) (hb : b ‚â§ 0) : a + b ‚â§ 0
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x : V} (hx : x ‚â† 0) (Œ∏ : real.angle) : o.oangle (‚áë(o.rotation Œ∏) x) x = -Œ∏
{n : ‚Ñï} {Œ± Œ±' Œ≤ Œ≤' : typevec n} : Œ±.arrow Œ≤ ‚Üí Œ±'.arrow Œ≤' ‚Üí (Œ±.prod Œ±').arrow (Œ≤.prod Œ≤')
{Œ± : Type u} {Œ≤ : Type v} [has_zero Œ≤] : slim_check.total_function Œ± Œ≤ ‚Üí slim_check.total_function Œ± Œ≤
(E : Type u_6) : Type u_6
(R : Type u) [semiring R] : ‚Ñï ‚Üí Prop
(R : Type u_3) [semiring R] (S : Type u_4) [semiring S] {M : Type u_7} {N : Type u_8} {P‚Çó : Type u_14} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P‚Çó] [module R M] [module S N] [module R P‚Çó] [module S P‚Çó] [smul_comm_class S R P‚Çó] (f : M ‚Üí N ‚Üí P‚Çó) (H1 : ‚àÄ (m‚ÇÅ m‚ÇÇ : M) (n : N), f (m‚ÇÅ + m‚ÇÇ) n = f m‚ÇÅ n + f m‚ÇÇ n) (H2 : ‚àÄ (c : R) (m : M) (n : N), f (c ‚Ä¢ m) n = c ‚Ä¢ f m n) (H3 : ‚àÄ (m : M) (n‚ÇÅ n‚ÇÇ : N), f m (n‚ÇÅ + n‚ÇÇ) = f m n‚ÇÅ + f m n‚ÇÇ) (H4 : ‚àÄ (c : S) (m : M) (n : N), f m (c ‚Ä¢ n) = c ‚Ä¢ f m n) : M ‚Üí‚Çó[R] N ‚Üí‚Çó[S] P‚Çó
{R : Type u} [ring R] (self : subring R) : add_subgroup R
{R : Type u_1} {A : Type u_2} [monoid A] [has_scalar R A] [is_scalar_tower R A A] [topological_space A] [has_continuous_mul A] : has_continuous_const_smul R A
(V : Type u) [quiver V] : Type u
{G : Type u_3} [add_group G] : add_group.fg G ‚Üî ‚àÉ (S : set G), add_subgroup.closure S = ‚ä§ ‚àß S.finite
(m : Type u‚ÇÅ ‚Üí Type u‚ÇÇ) [equiv_functor m] : category_theory.core (Type u‚ÇÅ) ‚•§ category_theory.core (Type u‚ÇÇ)
{M : Type u_1} [mul_action ‚Ñù M] : mul_action nnreal M
(a b c : ‚Ñù) (hb : 0 ‚â† b) : filter.tendsto (Œª (x : ‚Ñù), x ^ (a / (b * x + c))) filter.at_top (nhds 1)
{Œ± : Type} (s1 s2 : native.rb_set Œ±) : native.rb_set Œ±
{Œ± : Type u_1} (l : ordnode Œ±) (x : Œ±) (m : ordnode Œ±) (y : Œ±) (r : ordnode Œ±) : ordnode Œ±
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) ‚Üí same_ray R x y
{R : Type u_1} [non_unital_non_assoc_semiring R] : R ‚Üí+ add_monoid.End R
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') : category_theory.limits.cocones.functoriality F H ‚ãô category_theory.limits.cocones.precompose (category_theory.whisker_left F Œ±.inv) ‚âÖ category_theory.limits.cocones.functoriality F H'
{Œ± : Type u} : Œ± ‚âÉ cofinite_topology Œ±
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {c‚ÇÅ c‚ÇÇ p‚ÇÅ p‚ÇÇ : P} (hc‚ÇÅ : has_dist.dist p‚ÇÅ c‚ÇÅ = has_dist.dist p‚ÇÇ c‚ÇÅ) (hc‚ÇÇ : has_dist.dist p‚ÇÅ c‚ÇÇ = has_dist.dist p‚ÇÇ c‚ÇÇ) : has_inner.inner (c‚ÇÇ -·µ• c‚ÇÅ) (p‚ÇÇ -·µ• p‚ÇÅ) = 0
{Œ± : Sort u} {Œ≤ : Sort v} {p : Œ≤ ‚Üí Prop} (e : Œ± ‚âÉ Œ≤) : {a // p (‚áëe a)} ‚âÉ {b // p b}
{Œ± : Type u_1} (g : generalized_continued_fraction Œ±) [has_one Œ±] : Prop
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : Œπ ‚Üí P} (hi : affine_independent k p) {s : finset Œπ} {sp : affine_subspace k P} [finite_dimensional k ‚Ü•(sp.direction)] (hle : affine_span k ‚Üë(finset.image p s) ‚â§ sp) (hc : s.card = finite_dimensional.finrank k ‚Ü•(sp.direction) + 1) : affine_span k ‚Üë(finset.image p s) = sp
{Œ± : Type u_1} {M : Type u_5} [add_zero_class M] (a : Œ±) : (Œ± ‚Üí‚ÇÄ M) ‚Üí+ M
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_comm_group Œ±] [uniform_space Œ±] [complete_space Œ±] {f : Œ≤ ‚Üí Œ±} : summable f ‚Üî cauchy_seq (Œª (s : finset Œ≤), s.sum (Œª (b : Œ≤), f b))
{X Y : Top} (f : X ‚ü∂ Y) (x : ‚Ü•X) : topological_space.open_nhds.inclusion (‚áëf x) ‚ãô topological_space.opens.map f ‚âÖ topological_space.open_nhds.map f x ‚ãô topological_space.open_nhds.inclusion x
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : Top} [category_theory.limits.has_products C] (f : X ‚ü∂ Y) : Top.sheaf C X ‚•§ Top.sheaf C Y
{C : Type u} [category_theory.category C] [category_theory.enough_injectives C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_cokernel f] : Y ‚ü∂ category_theory.injective.syzygies f
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] [measurable_space Œ≥] (ab : Œ± ‚âÉ·µê Œ≤) (bc : Œ≤ ‚âÉ·µê Œ≥) : Œ± ‚âÉ·µê Œ≥
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} : category_theory.limits.kernel 0 ‚âÖ X
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) (s : set E) (c : nnreal) : Prop
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Type v
 : Type
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} {v : V} {s : set Œπ} {p : Œπ ‚Üí P} : (‚àÉ (fs : finset Œπ) (hfs : ‚Üëfs ‚äÜ s) (w : Œπ ‚Üí k) (hw : fs.sum (Œª (i : Œπ), w i) = 0), v = ‚áë(fs.weighted_vsub p) w) ‚Üî ‚àÉ (fs : finset ‚Ü•s) (w : ‚Ü•s ‚Üí k) (hw : fs.sum (Œª (i : ‚Ü•s), w i) = 0), v = ‚áë(fs.weighted_vsub (Œª (i : ‚Ü•s), p ‚Üëi)) w
{Œ± : Type u} {Œ≤ : Type v} {s : set Œ≤} (hs : s.subsingleton) {f : Œ± ‚Üí Œ≤} (hf : function.injective f) : (f ‚Åª¬π' s).subsingleton
(ùïú : Type u_1) {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field ùïú] [normed_space ùïú E] (x : E) : ùïú ‚ÜíL[ùïú] E
{Œ± : Type u} [linear_order Œ±] (x y : Œ±) {P : Sort u_1} (h‚ÇÅ : x < y ‚Üí P) (h‚ÇÇ : x = y ‚Üí P) (h‚ÇÉ : y < x ‚Üí P) : P
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : is_noetherian R M ‚Üî ‚àÄ (s : submodule R M), s.fg
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] {s : set Œ±} (hs : is_connected s) (hb : bdd_below s) (ha : bdd_above s) : set.Ioo (has_Inf.Inf s) (has_Sup.Sup s) ‚äÜ s
{R : Type u_1} {Œπ : Type u_3} [ring R] : basis Œπ R (Œπ ‚Üí‚ÇÄ R)
{Œπ : Type u_1} {R : Type u_3} {A : Type u_5} {x : Œπ ‚Üí A} [comm_ring R] [comm_ring A] [algebra R A] {K : Type u_2} [comm_ring K] [algebra R K] [algebra K A] [is_scalar_tower R K A] (hinj : function.injective ‚áë(algebra_map R K)) (ai : algebraic_independent K x) : algebraic_independent R x
{F : Type u_1} {E : Type u_2} {K : Type u_3} [field F] [field E] [field K] [algebra F E] [algebra F K] (x : intermediate_field.lifts F E K) {s : E} (h1 : is_integral F s) (h2 : polynomial.splits (algebra_map F K) (minpoly F s)) : intermediate_field.lifts F E K
{n : with_top ‚Ñï} {ùïÇ : Type u_6} [is_R_or_C ùïÇ] {E' : Type u_7} [normed_group E'] [normed_space ùïÇ E'] {F' : Type u_8} [normed_group F'] [normed_space ùïÇ F'] {f : E' ‚Üí F'} {x : E'} (hf : cont_diff_at ùïÇ n f x) (hn : 1 ‚â§ n) : has_strict_fderiv_at f (fderiv ùïÇ f x) x
{Œ± : Type u_1} [has_sup Œ±] [has_sdiff Œ±] (A B : Œ±) : Œ±
{C : Type u} [category_theory.category C] {F : C ‚•§ C} (A‚ÇÄ A‚ÇÅ : category_theory.endofunctor.algebra F) : Type v
 : expr ‚Üí tactic (expr √ó expr)
{a b c : Prop} : a ‚à® b ‚àß c ‚Üî (a ‚à® b) ‚àß (a ‚à® c)
(n : ‚Ñï) : ‚Ñï
(p : Gromov_Hausdorff.GH_space) : Type
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (f : C(Œ± √ó Œ≤, Œ≥)) : C(Œ±, C(Œ≤, Œ≥))
{Œ± : Type u} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_well_order Œ± r] : linear_order Œ±
{R : Type u} {S : Type v} [semiring R] [comm_semiring S] (f : R ‚Üí+* S) (x : S) : polynomial R ‚Üí+* S
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_5} [normed_group E'] [normed_space ùïú E'] {n : with_top ‚Ñï} {f : E ‚Üí E'} {s : set E} : cont_mdiff_on (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') n f s ‚Üí cont_diff_on ùïú n f s
{Œ± : Type u_1} [preorder Œ±] (s : ordset Œ±) : ‚Ñï
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [rŒ± : non_unital_non_assoc_semiring Œ±] [rŒ≤ : non_unital_non_assoc_semiring Œ≤] {rŒ≥ : non_unital_non_assoc_semiring Œ≥} (g : Œ≤ ‚Üí‚Çô+* Œ≥) (f : Œ± ‚Üí‚Çô+* Œ≤) : Œ± ‚Üí‚Çô+* Œ≥
{Œ± : Type u_1} : list (option Œ±) ‚Üí option (list Œ±)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [topological_space Œ¥] (h‚ÇÅ : Œ± ‚âÉ‚Çú Œ≤) (h‚ÇÇ : Œ≥ ‚âÉ‚Çú Œ¥) : Œ± ‚äï Œ≥ ‚âÉ‚Çú Œ≤ ‚äï Œ¥
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [fintype Œ±] [fintype Œ≤] [comm_monoid M] (e : Œ± ‚âÉ Œ≤) (f : Œ± ‚Üí M) (g : Œ≤ ‚Üí M) (h : ‚àÄ (x : Œ±), f x = g (‚áëe x)) : finset.univ.prod (Œª (x : Œ±), f x) = finset.univ.prod (Œª (x : Œ≤), g x)
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b : Œ±} (ha : a < 1) (hb : b < 1) : a * b < 1
(D : algebraic_geometry.LocallyRingedSpace.glue_data) (i j : D.to_glue_data.J) : category_theory.limits.is_limit (D.to_glue_data.V_pullback_cone i j)
 : ‚Ñï √ó ‚Ñï ‚âÉ ‚Ñï
{Œ± : Type uu} [decidable_eq Œ±] {l‚ÇÅ l‚ÇÇ : list Œ±} : l‚ÇÅ <+~ l‚ÇÇ ‚Üî ‚àÄ (x : Œ±), x ‚àà l‚ÇÅ ‚Üí list.count x l‚ÇÅ ‚â§ list.count x l‚ÇÇ
{Œ± : Type u_1} [add_group Œ±] : has_quotient Œ± (add_subgroup Œ±)
{Œ± : Type u_1} [topological_space Œ±] (s : set Œ±) : filter Œ±
{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] : category_theory.preadditive C
{Œπ : Type u_1} {M : Type u_4} [ordered_add_comm_monoid M] {s : finset Œπ} {f : Œπ ‚Üí with_top M} : s.sum (Œª (i : Œπ), f i) < ‚ä§ ‚Üî ‚àÄ (i : Œπ), i ‚àà s ‚Üí f i < ‚ä§
 : fact (1 ‚â§ ‚ä§)
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [add_zero_class Œ±] [add_zero_class Œ≤] (f : Œ± ‚Üí+o Œ≤) : Œ± ‚Üío Œ≤
(Œ± : Type u_4) : Type u_4
{A : Type u_1} (B : Type u_2) [ring A] [ring B] [is_domain B] (e : A ‚âÉ+* B) : is_domain A
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {s : set E} {f : E ‚Üí ùïú} {g : E ‚Üí F} (hf : cont_diff_on ùïú n f s) (hg : cont_diff_on ùïú n g s) : cont_diff_on ùïú n (Œª (x : E), f x ‚Ä¢ g x) s
{K : Type u_1} [field K] : valuation_subring K ‚Ü™o subgroup KÀ£
{R : Type u} {L : Type v} {M : Type w} {M' : Type w‚ÇÅ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group M'] [module R M'] [lie_ring_module L M'] [lie_module R L M'] (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M') (N : lie_submodule R L M) : lie_submodule R L M'
 : ‚Ñï ‚Üí vm vm_obj
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : affine_subspace k P) : s.direction = vector_span k ‚Üës
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] (f : ‚ÑÇ ‚Üí E) (f' : ‚ÑÇ ‚Üí (‚ÑÇ ‚ÜíL[‚Ñù] E)) (z w : ‚ÑÇ) (Hc : continuous_on f (set.interval z.re w.re √ó‚ÑÇ set.interval z.im w.im)) (Hd : ‚àÄ (x : ‚ÑÇ), x ‚àà set.Ioo (linear_order.min z.re w.re) (linear_order.max z.re w.re) √ó‚ÑÇ set.Ioo (linear_order.min z.im w.im) (linear_order.max z.im w.im) ‚Üí has_fderiv_at f (f' x) x) (Hi : measure_theory.integrable_on (Œª (z : ‚ÑÇ), complex.I ‚Ä¢ ‚áë(f' z) 1 - ‚áë(f' z) complex.I) (set.interval z.re w.re √ó‚ÑÇ set.interval z.im w.im) measure_theory.measure_space.volume) : (((‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üë(z.im) * complex.I)) - ‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üë(w.im) * complex.I)) + complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üë(w.re) + ‚Üëy * complex.I)) - complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üë(z.re) + ‚Üëy * complex.I) = ‚à´ (x : ‚Ñù) in z.re..w.re, ‚à´ (y : ‚Ñù) in z.im..w.im, complex.I ‚Ä¢ ‚áë(f' (‚Üëx + ‚Üëy * complex.I)) 1 - ‚áë(f' (‚Üëx + ‚Üëy * complex.I)) complex.I
(Œ± : Type u_1) [fin_enum Œ±] : list Œ±
{R : Type u} [comm_ring R] (A : Algebra R) : Mon_ (Module R)
{K : Type u_1} {v : K} {n : ‚Ñï} [linear_ordered_field K] [floor_ring K] {a : K} (nth_part_num_eq : (generalized_continued_fraction.of v).partial_numerators.nth n = option.some a) : a = 1
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] [fintype Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) {b : M} [linear_ordered_comm_ring M] (hb : ‚Üë(fintype.card Œ±) < fintype.card Œ≤ ‚Ä¢ b) : ‚àÉ (y : Œ≤), ‚Üë((finset.filter (Œª (x : Œ±), f x = y) finset.univ).card) < b
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [dec : decidable_eq Œπ] [Œ† (i : Œπ), has_zero (Œ≤ i)] (i : Œπ) : (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚Üí (Œ†‚ÇÄ (i : Œπ), Œ≤ i)
{Œ± : Type u} [preorder Œ±] {a b : Œ±} (h : a < b) : ¬¨b < a
{Œ± : Type u_1} {E : Œ± ‚Üí Type u_2} {p : ennreal} [Œ† (i : Œ±), normed_group (E i)] [decidable_eq Œ±] [fact (1 ‚â§ p)] (hp : p ‚â† ‚ä§) (f : ‚Ü•(lp E p)) : has_sum (Œª (i : Œ±), lp.single p i (‚áëf i)) f
{G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)
{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_group M] [module R M] : has_involutive_neg (submodule R M)
(Œ∏ : ‚ÑÇ) (n : ‚Ñï) : polynomial.eval (complex.cos Œ∏) (polynomial.chebyshev.T ‚ÑÇ n) = complex.cos (‚Üën * Œ∏)
{R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] (e : basis Œπ R M) (f : M ‚âÉ‚Çó[R] M) : (e.map f).orientation = e.orientation ‚Üî 0 < ‚áëlinear_map.det ‚Üëf
{A : Type u_1} [comm_ring A] [algebra ‚Ñö A] (t : A) : power_series.mk (Œª (n : ‚Ñï), ‚áë(polynomial.aeval t) ((1 / ‚Üë(n.factorial)) ‚Ä¢ polynomial.bernoulli n)) * (power_series.exp A - 1) = power_series.X * ‚áë(power_series.rescale t) (power_series.exp A)
{p : ‚Ñï+} {k : ‚Ñï} [hp : fact (nat.prime ‚Üëp)] : is_integral_closure (cyclotomic_ring (p ^ k) ‚Ñ§ ‚Ñö) ‚Ñ§ (cyclotomic_field (p ^ k) ‚Ñö)
{Œ± : Type u_1} [decidable_eq Œ±] (a : Œ±) : derangements.equiv.remove_none.fiber (option.some a) = {f : equiv.perm Œ± | function.fixed_points ‚áëf ‚äÜ {a}}
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) {J : Type u} [category_theory.category J] (K : J ‚•§ C) : adj.functoriality_right_adjoint K ‚ãô category_theory.limits.cocones.functoriality K F ‚ü∂ ùü≠ (category_theory.limits.cocone (K ‚ãô F))
(n m : ‚Ñï+) : ‚Ñï+
(src tgt : name) (dict : name_map name) (allow_auto_name : bool) : tactic name
{M : Type u_1} [has_add M] {S T : add_subsemigroup M} (h : ‚àÄ (x : M), x ‚àà S ‚Üî x ‚àà T) : S = T
{M : Type u} [monoid M] {x y : M} (hxy : x ‚à£ y) {n : ‚Ñï} (hn : n ‚â† 0) : x ‚à£ y ^ n
{Œ± : Type u_1} {Œ≤ : Type u_2} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {K : nnreal} {f : Œ± ‚Üí Œ≤} : antilipschitz_with K f ‚Üí ‚àÄ (x y : Œ±), has_dist.dist x y ‚â§ ‚ÜëK * has_dist.dist (f x) (f y)
{Œ± : Type u} {Œπ : Type v} [metric_space Œ±] [proper_space Œ±] {c : Œπ ‚Üí Œ±} {r : Œπ ‚Üí ‚Ñù} (hr : ‚àÄ (i : Œπ), 0 < r i) (uf : ‚àÄ (x : Œ±), {i : Œπ | x ‚àà metric.ball (c i) (r i)}.finite) (uU : (‚ãÉ (i : Œπ), metric.ball (c i) (r i)) = set.univ) : ‚àÉ (r' : Œπ ‚Üí ‚Ñù), (‚ãÉ (i : Œπ), metric.ball (c i) (r' i)) = set.univ ‚àß ‚àÄ (i : Œπ), r' i ‚àà set.Ioo 0 (r i)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {c‚ÇÅ c‚ÇÇ : Œ± √ó Œ≤} (p : path.homotopic.quotient c‚ÇÅ c‚ÇÇ) : path.homotopic.quotient c‚ÇÅ.fst c‚ÇÇ.fst
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {x : E} {f' : tangent_space (model_with_corners_self ùïú E) x ‚ÜíL[ùïú] tangent_space (model_with_corners_self ùïú E') (f x)} : has_mfderiv_at (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f x f' ‚Üí has_fderiv_at f f' x
{C : Type u‚ÇÅ} [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] [‚àÄ (a b : C), category_theory.limits.has_products_of_shape (a ‚ü∂ b) D] (c : C) : (category_theory.evaluation C D).obj c ‚ä£ category_theory.evaluation_right_adjoint D c
{G : Type u_1} [add_group G] (tG : add_monoid.is_torsion_free G) (H : add_subgroup G) : add_monoid.is_torsion_free ‚Ü•H
{R : Type u_1} [comm_semiring R] (M : Type u_4) {N : Type u_5} {P : Type u_6} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] : (N ‚Üí‚Çó[R] P) ‚Üí‚Çó[R] tensor_product R M N ‚Üí‚Çó[R] tensor_product R M P
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x y : Œ±} : metric.inf_dist x s ‚â§ metric.inf_dist y s + has_dist.dist x y
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M ‚Üí+ P} {T : add_submonoid P} (hy : ‚àÄ (y : ‚Ü•S), ‚áëg ‚Üëy ‚àà T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} {A : Type u_5} [add_comm_monoid A] {U : add_submonoid A} {R : Type u_6} [add_comm_monoid R] (j : U.localization_map R) {l : P ‚Üí+ A} (hl : ‚àÄ (w : ‚Ü•T), ‚áël ‚Üëw ‚àà U) : (k.map hl j).comp (f.map hy k) = f.map _ j
{Œ± : Type u_1} [preorder Œ±] [bounded_order Œ±] [is_simple_order Œ±] {a b : Œ±} (h : a < b) : b = ‚ä§
{k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k ‚Üí E} {a b r : k} (hab : a < b) (h‚ÇÄ : 0 < r) (h‚ÇÅ : r < 1) : f (‚áë(affine_map.line_map a b) r) < ‚áë(affine_map.line_map (f a) (f b)) r ‚Üî slope f a (‚áë(affine_map.line_map a b) r) < slope f (‚áë(affine_map.line_map a b) r) b
{A : Type u_1} {R : Type u_2} (K : Type u_3) [comm_ring A] [is_domain A] [normalized_gcd_monoid A] [field K] [comm_ring R] [is_domain R] [algebra A K] [is_fraction_ring A K] [algebra K R] [algebra A R] [is_scalar_tower A K R] {x : R} (hx : is_integral A x) : minpoly K x = polynomial.map (algebra_map A K) (minpoly A x)
{G : Type u_1} [group G] {H : subgroup G} {S : set G} (hS : S ‚àà subgroup.right_transversals ‚ÜëH) : quotient (quotient_group.right_rel H) ‚âÉ ‚Ü•S
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_le Œ±] [has_le Œ≤] [order_top Œ≤] : order_top (Œ± ‚äï‚Çó Œ≤)
{R : Type u_1} {M : Type u_3} {a b : R} [monoid R] [mul_action R M] (h : a * b = 1) : is_smul_regular M b
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop} (f : principal_seg r s) (g : initial_seg s t) : principal_seg r t
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {f : E ‚Üí G} {x : E} {y : F} (hf : cont_diff_at ùïú n f x) : cont_diff_at ùïú n (Œª (x : E √ó F), f x.fst) (x, y)
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] {P : Sort v} (x : ratfunc K) (f : polynomial K ‚Üí polynomial K ‚Üí P) (H : ‚àÄ {p q a : polynomial K}, q ‚â† 0 ‚Üí a ‚â† 0 ‚Üí f (a * p) (a * q) = f p q) : P
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {f g : E ‚Üí F} (hf : cont_diff ùïú n f) (hg : cont_diff ùïú n g) : cont_diff ùïú n (Œª (x : E), f x - g x)
{R : Type u_1} [semiring R] (r : R) : polynomial R ‚Üí‚Çó[R] polynomial R
(R : Type u_1) [semiring R] : Type u_1
{X Y : Type u} [ring X] [ring Y] (e : X ‚âÉ+* Y) : Ring.of X ‚âÖ Ring.of Y
{Œ± : Type} (ts : list (tactic Œ±)) : tactic (list Œ±)
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {C : ‚Ñù} (h‚ÇÄ : 0 ‚â§ C) (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí has_dist.dist x y ‚â§ C) : metric.diam s ‚â§ C
{R : Type u_1} {M : Type u_5} {M‚ÇÅ : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid M‚ÇÅ] [module R M‚ÇÅ] (B : M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R) (B' : M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÅ ‚Üí‚Çó[R] R) (f : M ‚Üí‚Çó[R] M‚ÇÅ) (g : M‚ÇÅ ‚Üí‚Çó[R] M) : Prop
{L : first_order.language} {L' : first_order.language} (g : L ‚Üí·¥∏ L') (T : L.Theory) : L'.Theory
{Œ± : Type u_2} [topological_space Œ±] {g : Œ± ‚Üí Œ±} (h : continuous g) : flow ‚Ñï Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {x : E} {n : with_top ‚Ñï} {f : E ‚Üí F} {g : E ‚Üí G} (hf : cont_diff_at ùïú n f x) (hg : cont_diff_at ùïú n g x) : cont_diff_at ùïú n (Œª (x : E), (f x, g x)) x
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ‚Üî module.finite K V
{X Y : Type u} (f g : X ‚ü∂ Y) : category_theory.limits.colimit_cocone (category_theory.limits.parallel_pair f g)
(C : Type u) [category_theory.category C] : Type (max u v)
(R : Type u) [ring R] [strong_rank_condition R] (m n : Type u) [fintype m] [fintype n] : module.rank R (matrix m n R) = cardinal.mk m * cardinal.mk n
{G‚ÇÅ : Type u_2} {G‚ÇÇ : Type u_3} [group G‚ÇÅ] [group G‚ÇÇ] [group.is_nilpotent G‚ÇÅ] [group.is_nilpotent G‚ÇÇ] : group.is_nilpotent (G‚ÇÅ √ó G‚ÇÇ)
{Œ± : Type u} [partial_order Œ±] {a b : Œ±} : a ‚â§ b ‚Üí a ‚â† b ‚Üí a < b
{M‚ÇÄ : Type u_1} [mul_zero_class M‚ÇÄ] [no_zero_divisors M‚ÇÄ] {a b : M‚ÇÄ} : a * b ‚â† 0 ‚Üî b * a ‚â† 0
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J·µí·µñ ‚•§ C} (c : category_theory.limits.cocone F.right_op) : category_theory.limits.cone F
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C·µí·µñ ‚•§ D·µí·µñ) [category_theory.limits.preserves_limit K.op F] : category_theory.limits.preserves_colimit K F.unop
{Œ± : Type u_1} [partial_order Œ±] [succ_order Œ±] [is_succ_archimedean Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) {n m : Œ±} (h : ‚àÄ (i : Œ±), i ‚àà set.Ico n m ‚Üí r i (order.succ i)) (hnm : n < m) : relation.trans_gen r n m
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] (s : multiset Œ±) : ‚Ñï
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.is_terminal 0
{R : Type u_1} [comm_semiring R] {P : Type u_3} [comm_semiring P] (f : R ‚Üí+* P) (r : R) (hr : is_unit (‚áëf r)) : localization.away r ‚Üí+* P
{R : Type u} {S : Type v} [semiring R] [semiring S] (e : R ‚âÉ+* S) : polynomial R ‚âÉ+* polynomial S
{A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} (hp : p.monic) {r : K} (hr : ‚áë(polynomial.aeval r) p = 0) : is_localization.is_integer A r
{Œ± : Type u_2} {Œ≤ : Type u_3} [decidable_eq Œ≤] [has_vadd Œ± Œ≤] : has_vadd Œ± (finset Œ≤)
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [semiring k] [add_comm_monoid G] : (add_monoid_algebra k G)·µê·µí·µñ ‚âÉ+* add_monoid_algebra k·µê·µí·µñ G
 : nnreal
(Œ± : Type u_1) (Œ≤ : Type u_2) : Type u_1
(C : Type u‚ÇÅ) [category_theory.category C] : Type (max u‚ÇÅ v‚ÇÅ)
{M : Type u_1} [monoid M] {P : Type u_2} [comm_semiring P] [mul_semiring_action M P] {Q : Type u_3} [comm_semiring Q] [mul_semiring_action M Q] (g : P ‚Üí+*[M] Q) : polynomial P ‚Üí+*[M] polynomial Q
{Œ± : Type u_1} (n : ‚Ñï) : list Œ± ‚Üí ‚Ñï ‚Üí list Œ± √ó list (list Œ±)
(h_equality1 h_equality2 : expr) (coeff_for_eq2 : pexpr) : tactic expr
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] [densely_ordered Œ≤] {f : Œ± ‚Üí Œ≤} (h_mono : monotone f) (h_surj : function.surjective f) : continuous f
{T : Type u‚ÇÅ} [category_theory.category T] (X : T) : category_theory.under X ‚•§ T
{X : Type u_1} [topological_space X] {x y : X} (Œ≥ : path x y) {Y : Type u_2} [topological_space Y] {f : X ‚Üí Y} (h : continuous f) : path (f x) (f y)
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (hf : ‚àÄ (x y : M), add_commute (‚áëf x) (‚áëf y)) : add_hom M·µÉ·µí·µñ N
{M : Type u_1} [comm_monoid M] (x : M) : submonoid.localization_map.away_map x (localization.away x)
{Œ± : Type u} {s : set Œ±} : s.finite ‚à® s.infinite
(ns : name) : tactic string
{J : Type v} {C : Type u} [category_theory.category C] (B : C) (objs : J ‚Üí C) (arrows : Œ† (j : J), B ‚ü∂ objs j) : Prop
{ùïú : Type u} [nondiscrete_normed_field ùïú] {E : Type v} [normed_group E] [normed_space ùïú E] [complete_space ùïú] (s : submodule ùïú E) [finite_dimensional ùïú ‚Ü•s] : is_complete ‚Üës
(xs : list expr) : omega.int.exprform ‚Üí tactic omega.int.preform
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_image f] [category_theory.limits.has_cokernel (category_theory.limits.image.Œπ f)] [category_theory.limits.has_cokernel f] [category_theory.epi (category_theory.limits.factor_thru_image f)] : category_theory.limits.cokernel (category_theory.limits.image.Œπ f) ‚âÖ category_theory.limits.cokernel f
{M : Type u_1} [has_mul M] : complete_lattice (con M)
{Œ± : Type u_1} : has_sep Œ± (finset Œ±)
(Œ± : Type u) : category_theory.single_obj Œ±
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b : Œ±} (ha : 0 ‚â§ a) (hb : 0 < b) : 0 < a + b
{X : Type v} [topological_space X] [compact_space X] : paracompact_space X
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_mono f] : Y ‚ü∂ X
 : Type u ‚•§ Type u ‚•§ Type u
{Œ± : Type u_1} {Œ≤ : Type u_2} (p : Œ≤ ‚Üí Prop) (f : Œ± ‚Üí Œ≤) : Œ± ‚Üí. subtype p
{Œ± : Type u} : list Œ± ‚Üí stream Œ± ‚Üí stream Œ±
{E : Type u_2} [normed_group E] [normed_space ‚Ñù E] [nontrivial E] {x : E} {r : ‚Ñù} : (metric.sphere x r).nonempty ‚Üî 0 ‚â§ r
{Œπ : Type u_1} {N : Type u_5} [ordered_add_comm_monoid N] {f g : Œπ ‚Üí N} {s : finset Œπ} (h : ‚àÄ (i : Œπ), i ‚àà s ‚Üí f i ‚â§ g i) : s.sum (Œª (i : Œπ), f i) ‚â§ s.sum (Œª (i : Œπ), g i)
{A : Type u_2} [add_group A] (H : add_subgroup A) : Prop
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (l‚ÇÅ l‚ÇÇ : Œπ ‚Üí ùïú) (s : finset Œπ) : has_inner.inner (s.sum (Œª (i : Œπ), l‚ÇÅ i ‚Ä¢ v i)) (s.sum (Œª (i : Œπ), l‚ÇÇ i ‚Ä¢ v i)) = s.sum (Œª (i : Œπ), ‚áë(star_ring_end ùïú) (l‚ÇÅ i) * l‚ÇÇ i)
(e : omega.ee) : omega.eqelim unit
 : category_theory.limits.walking_pair ‚âÉ bool
{M : Type u_1} [mul_action ennreal M] : mul_action nnreal M
{H : Type u_5} [topological_space H] (M : Type u_6) [topological_space M] [charted_space H M] (G : structure_groupoid H) : Prop
{G : Type u_1} [add_group G] (g1 g2 : G) : g1 -·µ• g2 = g1 - g2
{P : Type u_2} [metric_space P] (ps : set P) : euclidean_geometry.cospherical ps ‚Üî ‚àÉ (center : P) (radius : ‚Ñù), ‚àÄ (p : P), p ‚àà ps ‚Üí has_dist.dist p center = radius
{A : Type u_1} [division_ring A] [topological_space A] [has_continuous_mul A] [char_zero A] : has_continuous_const_smul ‚Ñö A
 : environment ‚Üí name ‚Üí option environment.projection_info
{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_3} [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] : add_comm_group (normed_group_hom V‚ÇÅ V‚ÇÇ)
(R : Type u_1) [semiring R] : Type u_1
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ Group Mon)
{Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] [has_continuous_add Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : lower_semicontinuous_on f s) (hg : lower_semicontinuous_on g s) : lower_semicontinuous_on (Œª (z : Œ±), f z + g z) s
(A : Type u_1) {B : Type u_2} [field A] [ring B] [algebra A B] (x : B) {p : polynomial A} (pnz : p ‚â† 0) (hp : ‚áë(polynomial.aeval x) p = 0) : (minpoly A x).degree ‚â§ p.degree
{C : Type (max v u)} [category_theory.category C] {D : Type w} [category_theory.category D] [category_theory.abelian D] {F G : C ‚•§ D} (Œ± : F ‚ü∂ G) (X : C) : (category_theory.abelian.image Œ±).obj X ‚âÖ category_theory.abelian.image (Œ±.app X)
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : isometry f) : continuous f
{R : Type u_1} {A : Type u_2} (x : unitization R A) : R
 : ‚Ñù ‚âÉo ‚Ü•(set.Ioi 0)
{Œ± Œ≤ : Frame} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [finite_dimensional k V] {s : set P} (hi : affine_independent k coe) : s.finite
(linter decl : name) : tactic bool
(k : Type u_1) {P‚ÇÅ : Type u_2} {V‚ÇÅ : Type u_6} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] (x : P‚ÇÅ) : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÅ
{Œ± : Type u_1} [linear_ordered_field Œ±] {Œ≤ : Type u_2} [has_zero Œ≤] [has_one Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_inv Œ≤] [has_div Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] [has_pow Œ≤ ‚Ñï] [has_pow Œ≤ ‚Ñ§] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ≤), f (-x) = -f x) (sub : ‚àÄ (x y : Œ≤), f (x - y) = f x - f y) (inv : ‚àÄ (x : Œ≤), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : Œ≤), f (x / y) = f x / f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (x ^ n) = f x ^ n) : linear_ordered_field Œ≤
{M : Type u_1} {A : Type u_4} {B : Type u_5} [monoid M] [monoid A] [mul_distrib_mul_action M A] [monoid B] [has_scalar M B] (f : A ‚Üí* B) (hf : function.surjective ‚áëf) (smul : ‚àÄ (c : M) (x : A), ‚áëf (c ‚Ä¢ x) = c ‚Ä¢ ‚áëf x) : mul_distrib_mul_action M B
{G : Type u_1} [group G] (H : subgroup G) : ‚Ü•H ‚âÉ ‚Ü•(H.opposite)
(n : ‚Ñï) : comm_ring (fin (n + 1))
{Œ± : Type u_1} [measurable_space Œ±] {M : Type u_3} [add_comm_monoid M] [topological_space M] {N : Type u_4} [add_comm_monoid N] [topological_space N] {R : Type u_5} [semiring R] [module R M] [module R N] [has_continuous_add M] [has_continuous_add N] [has_continuous_const_smul R M] [has_continuous_const_smul R N] (f : M ‚Üí‚Çó[R] N) (hf : continuous ‚áëf) : measure_theory.vector_measure Œ± M ‚Üí‚Çó[R] measure_theory.vector_measure Œ± N
{et : tactic.ring_exp.ex_type} (ps : tactic.ring_exp.ex et) : expr
{Œ± : Type u} [add_comm_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b c : Œ±} : a - b ‚â§ c ‚Üí a ‚â§ b + c
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} : metric.Hausdorff_dist s s = 0
{Œ± : Type u} [ordered_add_comm_group Œ±] {Œ≤ : Type u_1} [has_zero Œ≤] [has_add Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (inv : ‚àÄ (x : Œ≤), f (-x) = -f x) (div : ‚àÄ (x y : Œ≤), f (x - y) = f x - f y) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zpow : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : ordered_add_comm_group Œ≤
{K : Type u} [field K] {s : set K} : s ‚äÜ ‚Üë(subfield.closure s)
{Œπ : Type u_1} {R : Type u_4} [decidable_eq Œπ] [add_monoid Œπ] [semiring R] (A : Œπ ‚Üí add_submonoid R) [set_like.graded_monoid A] (i : Œπ) (x : ‚Ü•(A i)) : ‚áë(direct_sum.coe_ring_hom A) (‚áë(direct_sum.of (Œª (i : Œπ), ‚Ü•(A i)) i) x) = ‚Üëx
{R : Type u} {M : Type v} [ring R] {N : Type u_3} [add_comm_group M] [module R M] [add_comm_group N] [module R N] (f : M √ó N ‚Üí‚Çó[R] M) (i : function.injective ‚áëf) (n : ‚Ñï) : submodule R M
{X Y Z : SemiNormedGroup} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (w : f ‚â´ g = 0) : SemiNormedGroup.explicit_cokernel f ‚ü∂ Z
{Œ± Œ≤ : Type u} (r : Œ± ‚Üí Œ± ‚Üí Prop) [wo : is_well_order Œ± r] (s : Œ≤ ‚Üí set Œ±) (h‚ÇÅ : set.unbounded r (‚ãÉ (x : Œ≤), s x)) (h‚ÇÇ : cardinal.mk Œ≤ < strict_order.cof r) : ‚àÉ (x : Œ≤), set.unbounded r (s x)
 : lean.parser (list (name √ó binder_info √ó expr))
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] {R‚ÇÅ : Type u_1} [semiring R‚ÇÅ] [has_scalar R‚ÇÅ R] [module R‚ÇÅ L] [is_scalar_tower R‚ÇÅ R L] (L' : lie_subalgebra R L) : module R‚ÇÅ ‚Ü•L'
{Œ± : Type u_1} [monoid Œ±] (x y : Œ±) : Prop
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F G : J ‚•§ C} [category_theory.limits.has_limit F] (Œ± : F ‚âÖ G) : category_theory.limits.has_limit G
(P : ‚Ñï ‚Üí Prop) [decidable_pred P] : ‚Ñï ‚Üí ‚Ñï
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ‚Ñù P) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : ‚áë(euclidean_geometry.reflection s) p = ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p) -·µ• p +·µ• ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p)
(Œ± : Type u_1) (Œ≤ : Type u_2) [uniform_space Œ≤] : uniform_space (Œ± ‚Üí Œ≤)
{n : ‚Ñï} (p : fin (n + 1)) (i : fin n) (h : ‚áëfin.cast_succ i < p) : ‚áë(p.succ_above) i = ‚áëfin.cast_succ i
{G : Type u_1} [add_group G] (H N : add_subgroup G) [N.normal] : ‚Üë(H ‚äî N) = ‚ÜëH + ‚ÜëN
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {t : set (set Œ±)} (h : t.pairwise_disjoint id) (ht‚ÇÄ : t.finite) (ht‚ÇÅ : ‚àÄ (x : set Œ±), x ‚àà t ‚Üí x.finite) : finsum (Œª (a : Œ±), finsum (Œª (H : a ‚àà ‚ãÉ‚ÇÄt), f a)) = finsum (Œª (s : set Œ±), finsum (Œª (H : s ‚àà t), finsum (Œª (a : Œ±), finsum (Œª (H : a ‚àà s), f a))))
{Œ± : Type u_1} (enum : Œ± ‚Üí ‚Ñï) (s : derive_fintype.finset_above Œ± enum 0) (H : ‚àÄ (x : Œ±), x ‚àà s.val) : fintype Œ±
{F : Type u ‚Üí Type u} [functor F] {Œ± : Type u} (p : Œ± ‚Üí Prop) (x : F Œ±) : Prop
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} {F' : K ‚•§ D} (G : category_theory.limits.cone F ‚•§ category_theory.limits.cone F') [category_theory.limits.reflects_limit (category_theory.functor.empty (category_theory.limits.cone F)) G] {c : category_theory.limits.cone F} (hc : category_theory.limits.is_limit (G.obj c)) : category_theory.limits.is_limit c
(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop
(es : tactic.explode.entries) : tactic.explode.entry ‚Üí tactic (widget.html empty)
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (Œ∏‚ÇÅ Œ∏‚ÇÇ : real.angle) : (o.rotation Œ∏‚ÇÅ).trans (o.rotation Œ∏‚ÇÇ) = o.rotation (Œ∏‚ÇÇ + Œ∏‚ÇÅ)
(L : first_order.language) (Œ± : Type w) : first_order.language
{Œ± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Œ± ‚Üí E} {g' : Œ± ‚Üí F'} {l : filter Œ±} : f =O[l] g' ‚Üî ‚àÄ·∂† (c : ‚Ñù) in filter.at_top, asymptotics.is_O_with c l f g'
{Œ± : Type u_1} [linear_order Œ±] {s : set Œ±} : ¬¨bdd_above s ‚Üî ‚àÄ (x : Œ±), ‚àÉ (y : Œ±) (H : y ‚àà s), x < y
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [has_zero Œπ] [graded_monoid.ghas_one A] : has_one (A 0)
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] {A B : matrix n n Œ±} (h : A.mul B = 1) : A‚Åª¬π = B
{V : Type u_1} [inner_product_space ‚Ñù V] (x y : V) : ‚Ñù
(Œ± : Type u_3) [preorder Œ±] [topological_space Œ±] : Prop
{C : Type u} [category_theory.category C] [category_theory.concrete_category C] [category_theory.limits.has_limits C] [category_theory.reflects_isomorphisms (category_theory.concrete_category.forget C)] [category_theory.limits.preserves_limits (category_theory.concrete_category.forget C)] {X : Top} (F : Top.sheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) (V : topological_space.opens ‚Ü•X) (iUV : Œ† (i : Œπ), U i ‚ü∂ V) (hcover : V ‚â§ supr U) (sf : Œ† (i : Œπ), ‚Ü•(F.val.obj (opposite.op (U i)))) (h : F.val.is_compatible U sf) : ‚àÉ! (s : ‚Ü•(F.val.obj (opposite.op V))), ‚àÄ (i : Œπ), ‚áë(F.val.map (iUV i).op) s = sf i
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] : category_theory.lax_monoidal_functor (category_theory.discrete punit) C ‚•§ Mon_ C
{F : Type u_1} {E : Type u_2} {K : Type u_3} [field F] [field E] [field K] [algebra F E] [algebra F K] {c : set (intermediate_field.lifts F E K)} (hc : is_chain has_le.le c) : intermediate_field F E
(n k : ‚Ñï) : n.factorial * n.asc_factorial k = (n + k).factorial
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] (e : Œ± ‚âÉ·µê Œ≤) : measurable_embedding ‚áëe
{Œ± : Type u} {Œ≤ : Type v} (f' : Œ≤ ‚Üí Œ±) (f : Œ± ‚Üí Œ≤) (s : set Œ±) : Prop
 : ‚Ñï ‚Üí tactic.list_Pi tactic.rcases_patt ‚Üí tactic.list_Pi name √ó tactic.list_Pi tactic.rcases_patt
(n : ‚Ñï) : ‚Ñï
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (Œ∏ : real.angle) : hb.oangle (‚áë(hb.rotation Œ∏) x) y = hb.oangle x y - Œ∏
 : category_theory.ess_surj Compactum_to_CompHaus
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] : Œ± √ó Œ≤ ‚Üío Œ±
 : ‚Ñï ‚Üí ‚Ñï ‚Üí option ‚Ñï
{M : Type u_1} [monoid M] {A : Type u_2} [set_like A M] [submonoid_class A M] (S : A) : monoid ‚Ü•S
{D : set ‚Ñù} (hD : convex ‚Ñù D) (hD‚ÇÇ : is_open D) {f : ‚Ñù ‚Üí ‚Ñù} (hf' : differentiable_on ‚Ñù f D) (hf'' : differentiable_on ‚Ñù (deriv f) D) (hf''_nonpos : ‚àÄ (x : ‚Ñù), x ‚àà D ‚Üí deriv^[2] f x ‚â§ 0) : concave_on ‚Ñù D f
{k : Type u_1} {K : Type u_2} [field k] [is_alg_closed k] [field K] {f : k ‚Üí+* K} (p : polynomial k) : polynomial.splits f p
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [finite_dimensional k V] [fintype Œπ] {p : Œπ ‚Üí P} (hi : affine_independent k p) (hc : fintype.card Œπ = finite_dimensional.finrank k V + 1) : vector_span k (set.range p) = ‚ä§
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [decidable_eq Œπ] [add_monoid Œπ] [comm_semiring R] [semiring A] [algebra R A] (ùíú : Œπ ‚Üí submodule R A) : Type (max u_1 u_3)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (Q : C) (a : ‚Ü•P) : ‚áë0 a = 0
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] {Z : D} (F : C ‚•§ D) (M : Œ† (x : C), Z ‚ü∂ F.obj x) (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), M x ‚â´ F.map f = M y) : category_theory.with_initial C ‚•§ D
{E : Type u_1} {F : Type u_2} {ùïú : Type u_3} {ùïú‚ÇÇ : Type u_4} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} [ring_hom_isometric œÉ‚ÇÅ‚ÇÇ] {Œπ : Type u_5} [complete_space E] {g : Œπ ‚Üí (E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F)} (h : ‚àÄ (x : E), (‚®Ü (i : Œπ), ‚Üë‚à•‚áë(g i) x‚à•‚Çä) < ‚ä§) : (‚®Ü (i : Œπ), ‚Üë‚à•g i‚à•‚Çä) < ‚ä§
{G : Type u_1} [add_group G] {x y : G} : y ‚àà add_subgroup.closure {x} ‚Üî ‚àÉ (n : ‚Ñ§), n ‚Ä¢ x = y
{Œ± : Type u_1} {c : set (set Œ±)} (hu : ‚ãÉ‚ÇÄc = set.univ) (H : c.pairwise_disjoint id) : setoid Œ±
{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} : x ‚àà H ‚Üí y ‚àà H ‚Üí x + y ‚àà H
 : tactic unit
{Œ± : Type u_2} [subtraction_monoid Œ±] : subtraction_monoid (set Œ±)
{Œì : Type u_1} [inhabited Œì] {Œì' : Type u_2} [inhabited Œì'] (f : turing.pointed_map Œì Œì') : turing.TM0.stmt Œì ‚Üí turing.TM0.stmt Œì'
{A : Type u_4} [comm_ring A] [is_domain A] {P : ideal A} (hp : P.is_prime) : is_domain (localization.at_prime P)
(M : Type u) : Type u
{a : Prop} (b : bool) (h : ‚Ü•b ‚Üî a) : decidable a
{M : Type u_1} [mul_one_class M] {c : con M} : ‚Üë1 = 1
{R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R
{L : first_order.language} {M : Type w} [L.Structure M] (S : L.substructure M) : L.embedding ‚Ü•S M
{C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] (F : J ‚•§ C) [category_theory.limits.has_limit (category_theory.discrete.functor F.obj)] [category_theory.limits.has_limit (category_theory.discrete.functor (Œª (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), F.obj f.fst.snd))] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limit F
(Œ± : Type u) [t : topological_space Œ±] [topological_space.second_countable_topology Œ±] : set (set Œ±)
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] (f : S.localization_map N) : M ‚Üí+ N
{F : Type u ‚Üí Type u} [functor F] (q : qpf F) : Prop
{Œ∑ : Type u_2} [fintype Œ∑] {Gs : Œ∑ ‚Üí Type u_3} [Œ† (i : Œ∑), group (Gs i)] [‚àÄ (i : Œ∑), group.is_nilpotent (Gs i)] : group.nilpotency_class (Œ† (i : Œ∑), Gs i) = finset.univ.sup (Œª (i : Œ∑), group.nilpotency_class (Gs i))
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a : Œ±} : a‚Åª¬π < 1 ‚Üî 1 < a
(k n : ‚Ñï) : finset (fin k ‚Üí ‚Ñï)
{p : ‚Ñï} (hp : nat.prime p) (n : ‚Ñï) : (p ^ (n + 1)).totient = p ^ n * (p - 1)
{Œπ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (c : complex_shape Œπ) [category_theory.limits.has_zero_object V] [category_theory.limits.has_equalizers V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] [category_theory.limits.has_cokernels V] (i : Œπ) : homological_complex V c ‚•§ V
{Œ± : Type u} [pseudo_emetric_space Œ±] {f : ‚Ñï ‚Üí Œ±} {m n : ‚Ñï} (hmn : m ‚â§ n) {d : ‚Ñï ‚Üí ennreal} (hd : ‚àÄ {k : ‚Ñï}, m ‚â§ k ‚Üí k < n ‚Üí has_edist.edist (f k) (f (k + 1)) ‚â§ d k) : has_edist.edist (f m) (f n) ‚â§ (finset.Ico m n).sum (Œª (i : ‚Ñï), d i)
 : tactic unit
{R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ‚âÉ+* S) : ‚áëf 1 = 1
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {ps : set P} {n : ‚Ñï} [finite_dimensional ‚Ñù V] (hd : finite_dimensional.finrank ‚Ñù V = n) (hc : euclidean_geometry.cospherical ps) {sx‚ÇÅ sx‚ÇÇ : affine.simplex ‚Ñù P n} (hsx‚ÇÅ : set.range sx‚ÇÅ.points ‚äÜ ps) (hsx‚ÇÇ : set.range sx‚ÇÇ.points ‚äÜ ps) : sx‚ÇÅ.circumradius = sx‚ÇÇ.circumradius
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.limits.has_pullback f g] : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk category_theory.limits.pullback.fst category_theory.limits.pullback.snd category_theory.limits.pullback.condition)
 : list.nat.antidiagonal 0 = [(0, 0)]
(M : Type u) [has_add M] : AddMagma
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b : Œ±} (ha : a < 1) (hb : b ‚â§ 1) : a * b < 1
 : num ‚Üí num ‚Üí num
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {i : D ‚•§ C} [category_theory.reflective i] (X : C) : (category_theory.adjunction.of_right_adjoint i).unit.app (i.obj ((category_theory.left_adjoint i).obj X)) = i.map ((category_theory.left_adjoint i).map ((category_theory.adjunction.of_right_adjoint i).unit.app X))
{E : Type u_1} [add_comm_group E] [module ‚Ñù E] [topological_space E] [has_continuous_smul ‚Ñù E] {F : Type u_2} [add_comm_group F] [module ‚Ñù F] [topological_space F] [has_continuous_smul ‚Ñù F] [t2_space F] (f : E ‚Üí+ F) (hf : continuous ‚áëf) : E ‚ÜíL[‚Ñù] F
{o : Type u_4} (m' : o ‚Üí Type u_7) (Œ± : Type u_12) [decidable_eq o] [Œ† (i : o), decidable_eq (m' i)] [fintype o] [Œ† (i : o), fintype (m' i)] [non_assoc_semiring Œ±] : (Œ† (i : o), matrix (m' i) (m' i) Œ±) ‚Üí+* matrix (Œ£ (i : o), m' i) (Œ£ (i : o), m' i) Œ±
 : multiset.nat.antidiagonal 0 = {(0, 0)}
{Œ± : Type u} [topological_space Œ±] [t2_space Œ±] {K U V : set Œ±} (hK : is_compact K) (hU : is_open U) (hV : is_open V) (h2K : K ‚äÜ U ‚à™ V) : ‚àÉ (K‚ÇÅ K‚ÇÇ : set Œ±), is_compact K‚ÇÅ ‚àß is_compact K‚ÇÇ ‚àß K‚ÇÅ ‚äÜ U ‚àß K‚ÇÇ ‚äÜ V ‚àß K = K‚ÇÅ ‚à™ K‚ÇÇ
{C : Type u} [category_theory.category C] [category_theory.has_shift C ‚Ñ§] (T‚ÇÅ T‚ÇÇ : category_theory.triangulated.triangle C) : Type v
{R : Type u} [comm_ring R] {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group N] [module R N] [lie_ring_module L N] [lie_module R L N] (x : L) : module.End R (tensor_product R M N)
{R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra A B] [algebra R B] [algebra R A] [is_scalar_tower R A B] (A_int : algebra.is_integral R A) (x : B) (hx : is_integral A x) : is_integral R x
 : Type
(X : Type u_1) [topological_space X] : Type u_1
{x y : pgame} (ox : x.numeric) (oy : y.numeric) : x < y ‚Üî (‚àÉ (i : y.left_moves), (‚àÄ (i' : x.left_moves), x.move_left i' < y.move_left i) ‚àß ‚àÄ (j : (y.move_left i).right_moves), x < (y.move_left i).move_right j) ‚à® ‚àÉ (j : x.right_moves), (‚àÄ (i : (x.move_right j).left_moves), (x.move_right j).move_left i < y) ‚àß ‚àÄ (j' : y.right_moves), x.move_right j < y.move_right j'
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_cancel_comm_monoid E] [ordered_add_comm_monoid Œ≤] [module ùïú E] [has_scalar ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : strict_concave_on ùïú s f) (c : E) : strict_concave_on ùïú ((Œª (z : E), c + z) ‚Åª¬π' s) (f ‚àò Œª (z : E), c + z)
{Œ± : Type u_1} [normed_group Œ±] : normed_group Œ±·µí·µà
(n : ‚Ñï) : Type
 : SemilatticeSup ‚•§ SemilatticeInf
(C : Type u) [category_theory.category C] : setoid C
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (O : finset C) (H : finset (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y)) {X : C} (m : X ‚àà O) : category_theory.is_cofiltered.inf O H ‚ü∂ X
{V : Type u_1} [quiver V] {X Y : V·µí·µñ} (f : X ‚ü∂ Y) : opposite.unop Y ‚ü∂ opposite.unop X
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [group Œ±] [uniform_group Œ±] {hom : Type u_3} [uniform_space Œ≤] [discrete_topology Œ≤] [group Œ≤] [uniform_group Œ≤] [monoid_hom_class hom Œ± Œ≤] {f : hom} : uniform_continuous ‚áëf ‚Üî is_open ‚Üë(‚Üëf.ker)
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : M ‚Üí‚Çó[R] triv_sq_zero_ext R M
{Œ± : Sort u_1} {s‚ÇÅ : setoid Œ±} {p : quotient s‚ÇÅ ‚Üí Prop} (h : ‚àÄ (a : Œ±), p (quotient.mk' a)) (q : quotient s‚ÇÅ) : p q
 : Type (u+1)
{M : Type u_1} {G : Type u_2} [add_zero_class M] [add_comm_group G] : has_neg (M ‚Üí+ G)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.is_equivalence F] : category_theory.ess_surj F
{Œ± : Type u_1} [partial_order Œ±] (c : closure_operator Œ±) : galois_insertion c.to_closed coe
{Œ± : Type u} : Œ± ‚âÉ Œ±·µê·µí·µñ
{Œ± : Type u} (t : ordnode Œ±) : list Œ±
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] (f g : linear_pmap R E F) : submodule R E
(R : Type u) [comm_ring R] [local_ring R] : Type u
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (E : K ‚•§ J) : category_theory.limits.cocone F ‚•§ category_theory.limits.cocone (E ‚ãô F)
(id : module_info.module_id) : module_info
(n a b : ‚Ñï) : Prop
{X Y : Type u} [comm_group X] [comm_group Y] (f : X ‚Üí* Y) : CommGroup.of X ‚ü∂ CommGroup.of Y
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] (v : E) : v - ‚Üë(‚áë(orthogonal_projection K) v) ‚àà K·óÆ
{Œ± : Type u_1} {Œπ' : Sort u_5} {f : filter Œ±} [h : f.is_countably_generated] {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí set Œ±} (hs : f.has_basis p s) : ‚àÉ (x : ‚Ñï ‚Üí Œπ'), (‚àÄ (i : ‚Ñï), p (x i)) ‚àß f.has_antitone_basis (Œª (i : ‚Ñï), s (x i))
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [module ùïú E] [has_scalar ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : convex_on ùïú s f) (c : E) : convex_on ùïú ((Œª (z : E), c + z) ‚Åª¬π' s) (f ‚àò Œª (z : E), z + c)
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : local_equiv Œ± Œ≤) : local_equiv Œ≤ Œ±
{C : Type u} {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (X : C) (i : A) : (category_theory.shift_functor C i).obj ((category_theory.shift_functor C (-i)).obj X) ‚âÖ X
(n : ‚Ñï) : composition n ‚âÉ composition_as_set n
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {s : set E} {x : E} : unique_diff_within_at ùïú s x ‚Üí unique_mdiff_within_at (model_with_corners_self ùïú E) s x
{C : Type u} [category_theory.category C] {X Y : C} (J : category_theory.grothendieck_topology C) (f : Y ‚ü∂ X) (S R : category_theory.sieve X) (h : J.covers S f) : (‚àÄ {Z : C} (g : Z ‚ü∂ X), ‚áëS g ‚Üí J.covers R g) ‚Üí J.covers R f
 : category_theory.limits.preserves_limits_of_size (category_theory.forget SemiRing)
(ùïú : Type u_1) {E : Type u_2} [normed_linear_ordered_field ùïú] [normed_group E] [normed_space ùïú E] (A B : set E) : Prop
(B : Type u‚ÇÅ) [category_theory.bicategory B] : category_theory.pseudofunctor B B
(f : format) : format
{Œ≤ : Type v} {Œπ : Sort x} (f : Œπ ‚Üí Œ≤) : Œπ ‚Üí ‚Ü•(set.range f)
{ùïú : Type u} [nondiscrete_normed_field ùïú] {E : Type v} [normed_group E] [normed_space ùïú E] {F : Type w} [normed_group F] [normed_space ùïú F] [complete_space ùïú] {X : Type u_1} [topological_space X] [finite_dimensional ùïú E] {f : X ‚Üí (E ‚ÜíL[ùïú] F)} {s : set X} : continuous_on f s ‚Üî ‚àÄ (y : E), continuous_on (Œª (x : X), ‚áë(f x) y) s
{G : Type u} [add_group G] (N : add_subgroup G) [nN : N.normal] {H : Type v} [add_group H] (M : add_subgroup H) [M.normal] (f : G ‚Üí+ H) (h : N ‚â§ add_subgroup.comap f M) : G ‚ß∏ N ‚Üí+ H ‚ß∏ M
{Œ± : Type u} [pseudo_metric_space Œ±] {x : Œ±} {r : ‚Ñù} : metric.bounded (metric.closed_ball x r)
{a : ‚Ñï} (a1 : 1 < a) {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 1) : ‚àÉ (n : ‚Ñï), x = pell.xn a1 n ‚àß y = pell.yn a1 n
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] (T : category_theory.triangulated.triangle C) : (category_theory.triangulated.inv_rotate C).obj ((category_theory.triangulated.rotate C).obj T) ‚ü∂ T
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)
{R : Type u} [comm_ring R] {G H : Module R} (f : G ‚ü∂ H) : category_theory.limits.image f ‚âÖ Module.of R ‚Ü•(linear_map.range f)
 : num ‚Üí num ‚Üí num
{C : Type u‚ÇÅ} [category_theory.category C] {X : C·µí·µñ} (t : category_theory.limits.is_terminal X) : category_theory.limits.is_initial (opposite.unop X)
{Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : function.injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1
(R : Type u_1) (S : Type u_3) [non_assoc_semiring R] [non_assoc_semiring S] [subsingleton S] : R ‚âÉ+* S √ó R
{m : Type u_1} {n : Type u_2} [decidable_eq n] [fintype n] [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (A : matrix m m R) (B : matrix m n R) (D : matrix n n R) : (matrix.from_blocks A B 0 D).det = A.det * D.det
{Œ± : Type u_1} [linear_order Œ±] (pred : Œ± ‚Üí Œ±) (hn : ‚àÄ {a : Œ±}, ¬¨is_min a ‚Üí ‚àÄ (b : Œ±), b ‚â§ pred a ‚Üî b < a) (hm : ‚àÄ (a : Œ±), is_min a ‚Üí pred a = a) : pred_order Œ±
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] : ordnode Œ± ‚Üí ordnode Œ± √ó ordnode Œ±
{Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), group (Gs i)] (H K : Œ† (i : Œ∑), subgroup (Gs i)) : ‚ÅÖsubgroup.pi set.univ H,subgroup.pi set.univ K‚ÅÜ ‚â§ subgroup.pi set.univ (Œª (i : Œ∑), ‚ÅÖH i,K i‚ÅÜ)
{Œ± : Type u_1} {r : setoid Œ±} (a : Œ±) : ‚àÉ! (b : set Œ±) (H : b ‚àà r.classes), a ‚àà b
 : tactic unit
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] {f : L.hom M N} (hf : function.injective ‚áëf) : galois_coinsertion (first_order.language.substructure.map f) (first_order.language.substructure.comap f)
{B : Type u} [quiver B] : B ‚Üí B ‚Üí Type (max u v)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) (s : category_theory.limits.cocone F) : CommRing.colimits.prequotient F ‚Üí ‚Ü•(s.X)
 : hinst_lemmas ‚Üí smt_tactic unit
 : pos_num ‚Üí pos_num
 : pSet ‚Üí pSet
{R : Type u} [comm_ring R] [is_domain R] (a : R) (n : ‚Ñï) : polynomial.root_multiplicity a ((polynomial.X - ‚áëpolynomial.C a) ^ n) = n
{C : Type u} [category_theory.category C] {P Q : C} (f : P ‚ü∂ Q) [category_theory.is_iso f] : category_theory.strong_mono f
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} [category_theory.is_equivalence F] : category_theory.is_right_adjoint F
(R : Type u) [comm_ring R] [is_domain R] : Prop
{ùïú : Type u_3} {G : Type u_4} [is_R_or_C ùïú] [normed_group G] [normed_space ùïú G] {f : ùïú ‚Üí G} (hf : differentiable ùïú f) (hf' : ‚àÄ (x : ùïú), deriv f x = 0) (x y : ùïú) : f x = f y
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.preadditive C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {X : C} (P Q : category_theory.ProjectiveResolution X) : homotopy_equiv P.complex Q.complex
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_object V] [category_theory.limits.has_zero_morphisms V] (C : cochain_complex V ‚Ñï) : (cochain_complex.single‚ÇÄ V).obj (C.X 0) ‚ü∂ cochain_complex.truncate.obj C
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} : metric.Hausdorff_dist s ‚àÖ = 0
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f g : J ‚Üí C} [category_theory.limits.has_biproduct f] [category_theory.limits.has_biproduct g] (p : Œ† (b : J), f b ‚ü∂ g b) : ‚®Å f ‚ü∂ ‚®Å g
{G : Type u} [group G] (H N : subgroup G) [N.normal] : ‚Ü•H ‚ß∏ subgroup.comap H.subtype (H ‚äì N) ‚âÉ* ‚Ü•(H ‚äî N) ‚ß∏ subgroup.comap (H ‚äî N).subtype N
{Œπ : Type u_1} {ùïú : Type u_3} [is_R_or_C ùïú] {E : Type u_4} [inner_product_space ùïú E] [fintype Œπ] [decidable_eq Œπ] {V : Œπ ‚Üí submodule ùïú E} (hV : direct_sum.is_internal V) (hV' : orthogonal_family ùïú (Œª (i : Œπ), (V i).subtype‚Çó·µ¢)) : E ‚âÉ‚Çó·µ¢[ùïú] pi_Lp 2 (Œª (i : Œπ), ‚Ü•(V i))
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.final] (d : D) [category_theory.is_iso (category_theory.limits.colimit.pre (category_theory.coyoneda.obj (opposite.op d)) F)] : category_theory.limits.colimit (F ‚ãô category_theory.coyoneda.obj (opposite.op d)) ‚âÖ punit
{Œ± : Type u_1} {Œ≤ : Type u_2} [complete_lattice Œ±] {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} : f.limsup u = ‚®Ö (s : set Œ≤) (H : s ‚àà f), ‚®Ü (a : Œ≤) (H : a ‚àà s), u a
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [dec_irr : Œ† (p : associates Œ±), decidable (irreducible p)] (p : associates Œ±) (s : associates.factor_set Œ±) : Prop
(h : expr) : tactic unit
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (Œ∏ : real.angle) : V ‚âÉ‚Çó·µ¢[‚Ñù] V
(Œ± : Type u_1) [decidable_eq Œ±] [fintype Œ±] : trunc (encodable Œ±)
{cb : char_buffer} {n n' val : ‚Ñï} (h : parser.nat cb n = parse_result.done n' val) : val = nat.of_digits 10 (list.map (Œª (c : char), c.to_nat - '0'.to_nat) (list.take (n' - n) (list.drop n (buffer.to_list cb))).reverse)
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {x : ùïú} {s : set ùïú} {f' : ùïú ‚ÜíL[ùïú] F} : has_fderiv_within_at f f' s x ‚Üî has_deriv_within_at f (‚áëf' 1) s x
{M : Type u} [has_one M] [has_mul M] : ‚Ñï ‚Üí M ‚Üí M
 : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñö
{X : Type u_1} [topological_space X] {x y z : X} (Œ≥ : path x y) (Œ≥' : path y z) : path x z
{n : Type u_4} {Œ± : Type u_5} [fintype n] [non_unital_semi_normed_ring Œ±] : non_unital_semi_normed_ring (matrix n n Œ±)
(X : Type u) [lattice X] [jordan_holder_lattice X] : Type u
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C] (F : category_theory.limits.walking_parallel_pair ‚•§ C) : C
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [decidable_eq Œπ] {l : list Œπ} (v : list.tprod Œ± l) {i : Œπ} (hi : i ‚àà l) : Œ± i
{R : Type u_1} {M‚ÇÅ : Type u_2} {M‚ÇÇ : Type u_3} {M‚ÇÇ‚ÇÅ : Type u_4} {M‚ÇÇ‚ÇÇ : Type u_5} [comm_semiring R] [add_comm_monoid M‚ÇÅ] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÇ‚ÇÅ] [add_comm_monoid M‚ÇÇ‚ÇÇ] [module R M‚ÇÅ] [module R M‚ÇÇ] [module R M‚ÇÇ‚ÇÅ] [module R M‚ÇÇ‚ÇÇ] (e‚ÇÅ : M‚ÇÅ ‚âÉ‚Çó[R] M‚ÇÇ) (e‚ÇÇ : M‚ÇÇ‚ÇÅ ‚âÉ‚Çó[R] M‚ÇÇ‚ÇÇ) : (M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ‚ÇÅ) ‚âÉ‚Çó[R] M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÇ‚ÇÇ
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} {Œπ : Type v} (hs : is_compact s) (Z : Œπ ‚Üí set Œ±) (hZc : ‚àÄ (i : Œπ), is_closed (Z i)) (hsZ : ‚àÄ (t : finset Œπ), (s ‚à© ‚ãÇ (i : Œπ) (H : i ‚àà t), Z i).nonempty) : (s ‚à© ‚ãÇ (i : Œπ), Z i).nonempty
(R : Type u) [comm_ring R] : Type u
 : name ‚Üí tactic string
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B F : bilin_form R M) (f : module.End R M) : Prop
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) (v : E) : v ‚àà K·óÆ ‚Üî ‚àÄ (u : E), u ‚àà K ‚Üí has_inner.inner v u = 0
{Œ± : Type u_1} [U : uniform_space Œ±] (m : pseudo_metric_space Œ±) (H : uniformity Œ± = uniformity Œ±) : pseudo_metric_space Œ±
(decl : name) : tactic unit
{R : Type u_1} [comm_ring R] [ideal.is_jacobson R] (P : ideal (polynomial R)) [hP : P.is_maximal] : ((ideal.quotient.mk P).comp polynomial.C).is_integral
 : category_theory.is_skeleton_of Fintype Fintype.skeleton Fintype.skeleton.incl
{Œ± : Type u} (s : set Œ±) : Prop
 : (Œ£ (n : ‚Ñï), ‚Ü•(finset.nat.antidiagonal n)) ‚âÉ ‚Ñï √ó ‚Ñï
{a b : ‚Ñù} {g' g : ‚Ñù ‚Üí ‚Ñù} (hab : a ‚â§ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí has_deriv_within_at g (g' x) (set.Ioi x) x) (g'pos : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí 0 ‚â§ g' x) : measure_theory.integrable_on g' (set.Ioc a b) measure_theory.measure_space.volume
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} {V3 : Type u_6} {P3 : Type u_7} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] [add_comm_group V3] [module k V3] [add_torsor V3 P3] (f : P2 ‚Üí·µÉ[k] P3) (g : P1 ‚Üí·µÉ[k] P2) : ‚áë(f.comp g) = ‚áëf ‚àò ‚áëg
 : tactic.interactive.case_tag.match_result ‚Üí tactic.interactive.case_tag.match_result ‚Üí tactic.interactive.case_tag.match_result
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (f : M ‚Üí* N) : submonoid M
{Œ± : Type u_1} (a : lists Œ±) : lists Œ± ‚Üí Prop
{E : Type u_2} [normed_group E] [normed_space ‚Ñù E] {s t : set E} (hs‚ÇÅ : convex ‚Ñù s) (hs‚ÇÇ : is_closed s) (ht‚ÇÅ : convex ‚Ñù t) (ht‚ÇÇ : is_compact t) (disj : disjoint s t) : ‚àÉ (f : E ‚ÜíL[‚Ñù] ‚Ñù) (u v : ‚Ñù), (‚àÄ (a : E), a ‚àà s ‚Üí ‚áëf a < u) ‚àß u < v ‚àß ‚àÄ (b : E), b ‚àà t ‚Üí v < ‚áëf b
{Œ± : Type u_3} {Œ≤ : Type u_4} [preorder Œ≤] {f : Œ≤ ‚Üí finset Œ±} (h : monotone f) (h' : ‚àÄ (x : Œ±), ‚àÉ (n : Œ≤), x ‚àà f n) : filter.tendsto f filter.at_top filter.at_top
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_coe Œ± Œ≤] : has_coe (generalized_continued_fraction.pair Œ±) (generalized_continued_fraction.pair Œ≤)
{Œ± : Type u_1} [linear_ordered_field Œ±] {a b : Œ±} (ha : 0 < a) (hb : 0 < b) : 1 / a ‚â§ 1 / b ‚Üî b ‚â§ a
{Œ± : Type u_1} (L : list (list Œ±)) (i : ‚Ñï) : list.drop (list.take i (list.map list.length L)).sum L.join = (list.drop i L).join
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] (x : E) (r : ‚Ñù) : set E
{Œ± : Type u} (max : ‚Ñï) (f : thunk Œ±) : option Œ±
{l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {Œ± : Type u_12} (M : matrix (n ‚äï o) (l ‚äï m) Œ±) : matrix o m Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] : (C √ó D ‚•§ E) ‚•§ C ‚•§ D ‚•§ E
(e : expr) : tactic expr
{R : Type u} [non_assoc_semiring R] {s : set R} {p : R ‚Üí R ‚Üí Prop} {x y : R} (hx : x ‚àà subsemiring.closure s) (hy : y ‚àà subsemiring.closure s) (Hs : ‚àÄ (x : R), x ‚àà s ‚Üí ‚àÄ (y : R), y ‚àà s ‚Üí p x y) (H0_left : ‚àÄ (x : R), p 0 x) (H0_right : ‚àÄ (x : R), p x 0) (H1_left : ‚àÄ (x : R), p 1 x) (H1_right : ‚àÄ (x : R), p x 1) (Hadd_left : ‚àÄ (x‚ÇÅ x‚ÇÇ y : R), p x‚ÇÅ y ‚Üí p x‚ÇÇ y ‚Üí p (x‚ÇÅ + x‚ÇÇ) y) (Hadd_right : ‚àÄ (x y‚ÇÅ y‚ÇÇ : R), p x y‚ÇÅ ‚Üí p x y‚ÇÇ ‚Üí p x (y‚ÇÅ + y‚ÇÇ)) (Hmul_left : ‚àÄ (x‚ÇÅ x‚ÇÇ y : R), p x‚ÇÅ y ‚Üí p x‚ÇÇ y ‚Üí p (x‚ÇÅ * x‚ÇÇ) y) (Hmul_right : ‚àÄ (x y‚ÇÅ y‚ÇÇ : R), p x y‚ÇÅ ‚Üí p x y‚ÇÇ ‚Üí p x (y‚ÇÅ * y‚ÇÇ)) : p x y
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [comm_ring R] [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] (v : valuation R Œì‚ÇÄ) {J : ideal R} (hJ : J ‚â§ v.supp) : R ‚ß∏ J ‚Üí Œì‚ÇÄ
(R : Type u_1) [ring R] [topological_space R] [t : nonarchimedean_ring R] : nonarchimedean_add_group R
{Œ± : Type u} (s : set Œ±) : is_closed {u : ultrafilter Œ± | s ‚àà u}
{C : Type u} [category_theory.category C] : C ‚•§ category_theory.with_initial C
{Œπ : Type u_1} [encodable Œπ] {E : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), topological_space (E i)] [‚àÄ (i : Œπ), polish_space (E i)] : polish_space (Œ† (i : Œπ), E i)
{Œ± : Type u} [topological_space Œ±] [sigma_compact_space Œ±] {Œπ : Type u_1} {f : Œπ ‚Üí set Œ±} (hf : locally_finite f) (hne : ‚àÄ (i : Œπ), (f i).nonempty) : set.univ.countable
{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] {module_M : module R M} (p : submodule R M) : ‚Ü•p ‚Üí‚Çó[R] M
{n : ‚Ñï} : bitvec n ‚Üí bitvec n ‚Üí bitvec n
{F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} {p1 : P} {p : Œπ ‚Üí P} (h : p1 ‚àà affine_span k (set.range p)) : ‚àÉ (s : finset Œπ) (w : Œπ ‚Üí k) (hw : s.sum (Œª (i : Œπ), w i) = 1), p1 = ‚áë(s.affine_combination p) w
{ùïú : Type u_3} {E : Type u_4} {F : Type u_5} [semi_normed_ring ùïú] [add_comm_group E] [add_comm_group F] [module ùïú E] [module ùïú F] (p : seminorm ùïú F) (f : E ‚Üí‚Çó[ùïú] F) : seminorm ùïú E
{n : Type u_3} [fintype n] {A : Type u_1} [decidable_eq n] [comm_ring A] [is_domain A] {M : matrix n n A} : M.nondegenerate ‚Üí M.det ‚â† 0
 : ‚áëmeasure_theory.measure_space.volume {x : ‚Ñù | liouville x} = 0
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {J' : Type w‚ÇÇ} [category_theory.category J'] (e : J ‚âå J') (F : C ‚•§ D) [category_theory.limits.preserves_limits_of_shape J F] : category_theory.limits.preserves_limits_of_shape J' F
(Œ± : Type u) [s : lattice Œ±] [comm_group Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] : distrib_lattice Œ±
(k : Type u‚ÇÅ) {G : Type u‚ÇÇ} [semiring k] [has_mul G] {A : Type u‚ÇÉ} [non_unital_non_assoc_semiring A] [distrib_mul_action k A] {œÜ‚ÇÅ œÜ‚ÇÇ : monoid_algebra k G ‚Üí‚Çô‚Çê[k] A} (h : ‚àÄ (x : G), ‚áëœÜ‚ÇÅ (finsupp.single x 1) = ‚áëœÜ‚ÇÇ (finsupp.single x 1)) : œÜ‚ÇÅ = œÜ‚ÇÇ
{p : ‚Ñï} [fact (nat.prime p)] (f : padic_seq p) : ‚Ñ§
{M : Type u_1} [mul_one_class M] {s : set M} {p : M ‚Üí Prop} {x : M} (h : x ‚àà submonoid.closure s) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí p x) (H1 : p 1) (Hmul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x * y)) : p x
{ùïú : Type u_3} [field ùïú] {r : ‚Ñï} (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) (hM : M (sum.inr ()) (sum.inr ()) ‚â† 0) : ‚àÉ (L L' : list (matrix.transvection_struct (fin r ‚äï unit) ùïú)), (((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod).is_two_block_diagonal
{M : Type u_1} [monoid M] {s t : set M} (ht : is_submonoid t) (h : s ‚äÜ t) : monoid.closure s ‚äÜ t
{f : Type ‚Üí Type v} [alternative f] (p : Prop) [decidable p] : f unit
(a : ‚Ñ§) : ‚Üë(a.nat_abs) ‚â§ a ^ 2
 : lean.parser tactic.rcases_patt
{M : Type u_1} [mul_one_class M] {N : Type u_2} {S : Type u_3} [mul_one_class N] [set_like S M] [submonoid_class S M] (f : M ‚Üí* N) (s : S) : ‚Ü•s ‚Üí* N
{Œ± : Type u_8} [comm_monoid_with_zero Œ±] : Œ± √ó Œ± ‚Üí*‚ÇÄ Œ±
 : linarith.global_preprocessor
 : expr ‚Üí tactic (expr √ó expr)
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] : graded_monoid.ghas_one (Œª (i : ‚Ñï), tensor_power R i M)
{Œ± : Type u_2} {Œ≤ : Type u_3} [complete_lattice Œ±] [complete_lattice Œ≤] (f : complete_lattice_hom Œ± Œ≤) : Sup_hom Œ± Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.full F] [category_theory.faithful F] {X Y : C} (f : F.obj X ‚âÖ F.obj Y) : X ‚âÖ Y
(R : Type u_1) [rack R] : Prop
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} [fintype Œπ] [nonempty Œπ] {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (card_eq : fintype.card Œπ = finite_dimensional.finrank ùïú E) : basis Œπ ùïú E
{Œ± : Type u_1} (l : list Œ±) : list (multiset Œ±)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {v : picard_lindelof E} : v.fun_space ‚Ü™ C(‚Ü•(set.Icc v.t_min v.t_max), E)
 : onote ‚Üí ordinal
{Œ± : Type u_1} (p q : Œ± ‚Üí Prop) (h : p ‚â§ q) : {x // p x} ‚Ü™ {x // q x}
(var var' : string) (Œ± : Type u) (Œ≤ : Œ± ‚Üí Prop) [Œ† (x : Œ±), slim_check.testable (Œ≤ x)] [has_repr Œ±] (xs : list Œ±) : slim_check.testable (slim_check.named_binder var (‚àÄ (x : Œ±), slim_check.named_binder var' (x ‚àà xs ‚Üí Œ≤ x)))
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {s : set (E √ó F)} : cont_diff_on ùïú n prod.fst s
{Œ± : Type u_1} [linear_order Œ±] [succ_order Œ±] [is_succ_archimedean Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) {n m : Œ±} (h1 : ‚àÄ (i : Œ±), i ‚àà set.Ico n m ‚Üí r i (order.succ i)) (h2 : ‚àÄ (i : Œ±), i ‚àà set.Ico m n ‚Üí r (order.succ i) i) : relation.refl_trans_gen r n m
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] (F G : category_theory.oplax_functor B C) : Type (max u‚ÇÅ v‚ÇÅ v‚ÇÇ w‚ÇÇ)
{R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [add_comm_group M‚ÇÇ] [module R M‚ÇÇ] (p : submodule R M) (q : submodule R M‚ÇÇ) : ‚Ü•(p.compatible_maps q) ‚Üí‚Çó[R] M ‚ß∏ p ‚Üí‚Çó[R] M‚ÇÇ ‚ß∏ q
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [normed_comm_ring ùïú] [add_comm_monoid E] [add_comm_monoid F] [module ùïú E] [module ùïú F] (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú) : galois_connection (‚áëorder_dual.to_dual ‚àò B.polar) (B.flip.polar ‚àò ‚áëorder_dual.of_dual)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (c‚ÇÄ : omega_complete_partial_order.chain Œ±) (c‚ÇÅ : omega_complete_partial_order.chain Œ≤) : omega_complete_partial_order.chain (Œ± √ó Œ≤)
{Œ± : Type u_2} [bornology Œ±] {s : set Œ±} : bornology.is_bounded s·∂ú ‚Üí bornology.is_cobounded s
(g : expr) : tactic string
{J : Type v} [category_theory.small_category J] {F : J ‚•§ category_theory.discrete punit} {c : category_theory.limits.cone F} : category_theory.limits.is_limit c
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : basis ‚Ü•(is_noetherian.finset_basis_index K V) K V
{n : Type u_3} {Œ± : Type v} [fintype n] [non_unital_semiring Œ±] [star_ring Œ±] (M N : matrix n n Œ±) : has_star.star (M.mul N) = (has_star.star N).mul (has_star.star M)
(C : Type u) [category_theory.category C] [‚àÄ {J : Type v} {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)}, category_theory.limits.has_limit (category_theory.limits.parallel_family f)] : category_theory.limits.has_wide_equalizers C
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u} [category_theory.category C] {F : J ‚•§ C} [category_theory.limits.has_colimit F] {G : K ‚•§ C} [category_theory.limits.has_colimit G] (e : J ‚âå K) (w : e.functor ‚ãô G ‚âÖ F) : category_theory.limits.colimit F ‚âÖ category_theory.limits.colimit G
{Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [ring Œ≤] [is_domain Œ≤] (e : Œ± ‚âÉ+* Œ≤) : is_domain Œ±
 : abstract_completion ‚Ñö
{m : ‚Ñ§} (hm‚ÇÄ : m ‚â† 0) (hm‚ÇÅ : m ‚â† 1) : strict_convex_on ‚Ñù (set.Ioi 0) (Œª (x : ‚Ñù), x ^ m)
{l : filter ‚Ñù} {f g : ‚Ñù ‚Üí ‚Ñù} (hdf : ‚àÄ·∂† (x : ‚Ñù) in filter.at_top, differentiable_at ‚Ñù f x) (hg' : ‚àÄ·∂† (x : ‚Ñù) in filter.at_top, deriv g x ‚â† 0) (hftop : filter.tendsto f filter.at_top (nhds 0)) (hgtop : filter.tendsto g filter.at_top (nhds 0)) (hdiv : filter.tendsto (Œª (x : ‚Ñù), deriv f x / deriv g x) filter.at_top l) : filter.tendsto (Œª (x : ‚Ñù), f x / g x) filter.at_top l
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] (t : category_theory.limits.trident f) (create : Œ† (s : category_theory.limits.trident f), {l // l ‚â´ t.Œπ = s.Œπ ‚àß ‚àÄ {m : ((category_theory.functor.const (category_theory.limits.walking_parallel_family J)).obj s.X).obj category_theory.limits.walking_parallel_family.zero ‚ü∂ ((category_theory.functor.const (category_theory.limits.walking_parallel_family J)).obj t.X).obj category_theory.limits.walking_parallel_family.zero}, m ‚â´ t.Œπ = s.Œπ ‚Üí m = l}) : category_theory.limits.is_limit t
 : Type
 : onote ‚Üí ordinal ‚Üí Prop
 : Type
(e : expr) : expr
{Œ± : Type u_1} (Œ≤ : Œ± ‚Üí Type u_2) : W_type Œ≤ ‚âÉ Œ£ (a : Œ±), Œ≤ a ‚Üí W_type Œ≤
(R : Type u) (S‚ÇÅ : Type v) (S‚ÇÇ : Type w) [comm_semiring R] : mv_polynomial S‚ÇÅ (mv_polynomial S‚ÇÇ R) ‚Üí+* mv_polynomial (S‚ÇÅ ‚äï S‚ÇÇ) R
(M : Type u_1) (Œ± : Type u_2) [monoid M] [mul_action M Œ±] {s t : set Œ±} : fixing_submonoid M (s ‚à™ t) = fixing_submonoid M s ‚äì fixing_submonoid M t
{R : Type u_1} {M : Type u_2} [linear_ordered_semiring R] [ordered_add_comm_monoid M] [mul_action_with_zero R M] (hR : ‚àÄ {c : R}, c ‚â† 0 ‚Üí is_unit c) (hlt : ‚àÄ ‚¶Éa b : M‚¶Ñ ‚¶Éc : R‚¶Ñ, a < b ‚Üí 0 < c ‚Üí c ‚Ä¢ a ‚â§ c ‚Ä¢ b) : ordered_smul R M
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] : (M ‚Üí+ N) ‚âÉ (M·µê·µí·µñ ‚Üí+ N·µê·µí·µñ)
{Œ± : Type u} [has_ssubset Œ±] [is_irrefl Œ± has_ssubset.ssubset] {a : Œ±} : ¬¨a ‚äÇ a
{X : Type u} [metric_space X] [compact_space X] [nonempty X] {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] {Œ≥ : Type w} [metric_space Œ≥] {Œ¶ : X ‚Üí Œ≥} {Œ® : Y ‚Üí Œ≥} (ha : isometry Œ¶) (hb : isometry Œ®) : Gromov_Hausdorff.GH_dist X Y ‚â§ metric.Hausdorff_dist (set.range Œ¶) (set.range Œ®)
(xs : list expr) : omega.nat.exprterm ‚Üí tactic omega.nat.preterm
{M : Type u_1} [comm_monoid M] (S : submonoid M) (hS : S ‚â§ is_unit.submonoid M) : ‚Ü•(S.left_inv) ‚âÉ* ‚Ü•S
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] (h : bounded_continuous_function Œ± Œ≤) : Œ± ‚Üí Œ≤
{Œ± : Type u} [pseudo_metric_space Œ±] {x : Œ±} {u : set Œ±} (hu : u ‚àà nhds x) : ‚àÄ·∂† (r : ‚Ñù) in nhds 0, metric.closed_ball x r ‚äÜ u
{M : Type u_1} [linear_ordered_add_comm_monoid M] (S : add_submonoid M) : linear_ordered_add_comm_monoid ‚Ü•S
{C : Type u} [category_theory.category C] : category_theory.simplicial_object.augmented C ‚•§ category_theory.arrow C
(R : Type u) [comm_semiring R] (p : ‚Ñï) [fact (nat.prime p)] [char_p R p] [perfect_ring R p] : R ‚Üí+* R
 : expr ‚Üí tactic (expr √ó expr)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] [cs : complete_space ùïú] (f : ùïú ‚Üí ùïú) (f' a : ùïú) (hf : has_strict_deriv_at f f' a) (hf' : f' ‚â† 0) : ùïú ‚Üí ùïú
{Œ± : Type u} {Œ≤ : Type v} {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} [partial_order Œ±] [semilattice_sup Œ≤] (gi : galois_coinsertion l u) : semilattice_sup Œ±
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] : category_theory.braided_category (C ‚•§ D)
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} (x : P.M Œ±) : P.obj (Œ± ::: P.M Œ±)
{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length
 : turing.to_partrec.code
{G : Type u_7} [group G] (L : list G) (i : ‚Ñï) (p : i < L.length) : (list.drop (i + 1) L).prod = (L.nth_le i p)‚Åª¬π * (list.drop i L).prod
 : turing.to_partrec.code ‚Üí turing.partrec_to_TM2.cont' ‚Üí turing.partrec_to_TM2.Œõ'
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {mŒ± : measurable_space Œ±} [measurable_space Œ≤] [topological_space Œ≤] [topological_space.metrizable_space Œ≤] [borel_space Œ≤] [topological_space.second_countable_topology Œ≤] : measure_theory.strongly_measurable f ‚Üî measurable f
{Œ± : Type u_1} [measurable_space Œ±] [pseudo_emetric_space Œ±] [opens_measurable_space Œ±] (e : ‚Ñï ‚Üí Œ±) (N : ‚Ñï) : measure_theory.simple_func Œ± Œ±
(Œ± : Type u) : Type u
{k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k ‚Üí E} {a b r : k} (h : 0 < r * (b - a)) : ‚áë(affine_map.line_map (f a) (f b)) r ‚â§ f (‚áë(affine_map.line_map a b) r) ‚Üî slope f a b ‚â§ slope f a (‚áë(affine_map.line_map a b) r)
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a b : Œ±} (ha : a ‚â§ 1) (hb : b < 1) : a * b < 1
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] : algebra ‚Ü•(number_field.ring_of_integers K) ‚Ü•(number_field.ring_of_integers L)
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : set Œ±) : set Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {s : set E} {x : E} : differentiable_within_at ùïú f s x ‚Üí mdifferentiable_within_at (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f s x
{Œ± : Type u_1} [linear_ordered_field Œ±] {Œ≤ : Type u_2} [ring Œ≤] {abv : Œ≤ ‚Üí Œ±} (f : cau_seq Œ≤ abv) : Prop
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x y : V} (Œ∏ : real.angle) : o.oangle x y = Œ∏ ‚Üî (x ‚â† 0 ‚àß y ‚â† 0 ‚àß ‚àÉ (r : ‚Ñù), 0 < r ‚àß y = r ‚Ä¢ ‚áë(o.rotation Œ∏) x) ‚à® Œ∏ = 0 ‚àß (x = 0 ‚à® y = 0)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] [normed_group G] [normed_space ùïú G] {f : E ‚Üí F} {p : formal_multilinear_series ùïú E F} {x : E} {r : ennreal} (g : F ‚ÜíL[ùïú] G) (h : has_fpower_series_on_ball f p x r) : has_fpower_series_on_ball (‚áëg ‚àò f) (g.comp_formal_multilinear_series p) x r
{Œ± : Type u} {Œ≤ : Type v} [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] (f : Œ± ‚Üío Œ≤) (h : ‚àÄ (c : omega_complete_partial_order.chain Œ±), ‚áëf (omega_complete_partial_order.œâSup c) = omega_complete_partial_order.œâSup (c.map f)) : Œ± ‚ÜíùíÑ Œ≤
(G : Type u_1) [category_theory.groupoid G] : Type (max u_1 (v+1))
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} (h : f = g) : category_theory.limits.fork f g
{Œ± : Type u} [topological_space Œ±] {f : filter Œ±} {a : Œ±} {s : set Œ±} (h : a ‚àà s) (o : is_open s) (sf : filter.principal s ‚â§ f) : nhds a ‚â§ f
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space F] {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ‚ä§) (hker : f'.ker.closed_complemented) : ‚àÄ·∂† (x : E) in nhds a, has_strict_fderiv_at.implicit_function_of_complemented f f' hf hf' hker (f x) (‚áë(has_strict_fderiv_at.implicit_to_local_homeomorph_of_complemented f f' hf hf' hker) x).snd = x
{ùïú : Type u_1} {F : Type u_3} [is_R_or_C ùïú] [add_comm_group F] [module ùïú F] [c : inner_product_space.core ùïú F] : normed_group F
(R : Type u) : Type u
 : Lattice ‚•§ Lattice
{Œ± : Type u} {Œ≤ : Type v} [has_repr Œ±] [has_repr Œ≤] (m : list (Œ£ (_x : Œ±), Œ≤)) : string
{n : ‚Ñï} {E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {f : (fin (n + 1) ‚Üí ‚ÑÇ) ‚Üí E} {c : fin (n + 1) ‚Üí ‚ÑÇ} {R : fin (n + 1) ‚Üí ‚Ñù} (hf : torus_integrable f c R) : ‚àØ (x : fin (n + 1) ‚Üí ‚ÑÇ) in T(c, R), f x = ‚àÆ (x : ‚ÑÇ) in C(c 0, R 0), ‚àØ (y : fin n ‚Üí ‚ÑÇ) in T(c ‚àò fin.succ, R ‚àò fin.succ), f (fin.cons x y)
 : tactic (list expr)
 : linter
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {K K' : lie_subalgebra R L} (h : K ‚â§ K') : lie_subalgebra R ‚Ü•K'
(Œ± : Sort u) : Sort u
{Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : list Œ±} : l‚ÇÅ <:+: l‚ÇÇ ‚Üí l‚ÇÅ.reverse <:+: l‚ÇÇ.reverse
(Œ± : Type u_5) : Type u_5
{Œ± : Type u} [non_unital_ring Œ±] {a b c : Œ±} (h : a ‚à£ b) : a ‚à£ b + c ‚Üî a ‚à£ c
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (P : category_theory.idempotents.karoubi C) : category_theory.idempotents.karoubi C
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f : J ‚Üí C} {t : category_theory.limits.cone (category_theory.discrete.functor f)} (ht : category_theory.limits.is_limit t) : category_theory.limits.bicone f
(Œ± : Type u_3) [preorder Œ±] [topological_space Œ±] : Prop
{X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ‚àÉ (f : C(X, ‚Ñù)), set.eq_on ‚áëf 0 s ‚àß set.eq_on ‚áëf 1 t ‚àß ‚àÄ (x : X), ‚áëf x ‚àà set.Icc 0 1
{Œ± : Type u} (c : computation Œ±) : Œ± ‚äï computation Œ±
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : (span_points k s).nonempty ‚Üî s.nonempty
{Œ± : Type u} {l : list Œ±} : l.sublists'.nodup ‚Üí l.nodup
(C : Type u) [category_theory.category C] (D : Type u) [category_theory.category D] (E : Type u) [category_theory.category E] : (C ‚äï D) ‚äï E ‚•§ C ‚äï D ‚äï E
 : vm_obj ‚Üí level
{Œ± : Type u} [topological_space Œ±] (x : Œ±) : stone_cech Œ±
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} [comm_ring R] [lie_ring L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÅ] [lie_algebra R L‚ÇÇ] (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) (h‚ÇÅ : function.injective ‚áëf) (h‚ÇÇ : function.surjective ‚áëf) : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ
(t s : omega.nat.preterm) (k : ‚Ñï) : omega.nat.preterm ‚Üí omega.nat.preterm
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_initial C] {P : C} (t : category_theory.limits.is_initial P) : ‚ä•_ C ‚âÖ P
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_object D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] (F : C ‚•§ D) [F.preserves_zero_morphisms] : F.obj 0 ‚âÖ 0
(X : Twop) : Bipointed
{M : Type u_1} [add_monoid M] {A : Type u_2} [set_like A M] [add_submonoid_class A M] (S : A) : add_monoid ‚Ü•S
{C : Type u‚ÇÅ} [category_theory.category C] (G : category_theory.comonad C) : ‚ÜëG ‚ü∂ ‚ÜëG ‚ãô ‚ÜëG
{R : Type u_1} [ring R] (s : subring R) (m : multiset R) : (‚àÄ (a : R), a ‚àà m ‚Üí a ‚àà s) ‚Üí m.sum ‚àà s
(Œ± : Type u) {Œ≤ : Type v} [group Œ±] [mul_action Œ± Œ≤] (b : Œ≤) : subgroup Œ±
{Œ± : Type} (e : Œ± ‚âÉ ‚Ñï) : list Œ± ‚âÉ Œ±
{C : Type v} [category_theory.category C] [category_theory.concrete_category C] {X Y : C} (f : X ‚ü∂ Y) (s : function.surjective ‚áëf) : category_theory.epi f
(L : Type v) [has_bracket L L] [has_zero L] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.abelian C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [category_theory.epi g] (h : category_theory.exact f g) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ g _)
{ùïú : Type u_1} {E : Type u_3} [normed_field ùïú] [add_comm_group E] [module ùïú E] {A : set E} [topological_space E] [has_continuous_smul ùïú E] (hA : balanced ùïú A) : balanced ùïú (0 ‚à™ interior A)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [normed_space ‚Ñù E] : is_bounded_bilinear_map ‚Ñù (Œª (p : E √ó E), has_inner.inner p.fst p.snd)
{J : Type v} {C : Type u} [category_theory.category C] (B : C) (objs : J ‚Üí C) (arrows : Œ† (j : J), objs j ‚ü∂ B) [category_theory.limits.has_wide_pullback B objs arrows] : C
{Œ± : Type u} [lattice Œ±] [add_comm_group Œ±] (a : Œ±) (h : 0 ‚â§ a) : a‚Å∫ = a
{R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] (p : polynomial R) : polynomial R
{Œ± : Type u} [pseudo_emetric_space Œ±] {x y : Œ±} : emetric.inf_edist x {y} = has_edist.edist x y
(n : ‚Ñï) {R : Type u_1} {S : Type u_2} [ring R] [ring S] (f : R ‚Üí+* S) : polynomial.map f (polynomial.cyclotomic n R) = polynomial.cyclotomic n S
{Œπ : Type u_1} {R : Type u_8} [ordered_comm_semiring R] {f g : Œπ ‚Üí R} {s : finset Œπ} (h0 : ‚àÄ (i : Œπ), i ‚àà s ‚Üí 0 ‚â§ f i) (h1 : ‚àÄ (i : Œπ), i ‚àà s ‚Üí f i ‚â§ g i) : s.prod (Œª (i : Œπ), f i) ‚â§ s.prod (Œª (i : Œπ), g i)
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [ring R] [add_comm_group M] [module R M] (v : basis Œπ R M) (w : Œπ ‚Üí RÀ£) : basis Œπ R M
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_cokernel (f - g)] : category_theory.limits.has_coequalizer f g
{L : first_order.language} {M : Type u_3} {N : Type u_4} {P : Type u_5} [L.Structure M] [L.Structure N] [L.Structure P] (hnp : L.elementary_embedding N P) (hmn : L.elementary_embedding M N) : L.elementary_embedding M P
{X : Top} {T : ‚Ü•X ‚Üí Type v} (P : Top.prelocal_predicate T) : Top.local_predicate T
(h : interactive.parse (optional lean.parser.ident)) (t : interactive.parse (optional (lean.parser.tk ":" *> interactive.types.texpr))) : tactic unit
 : has_pure ultrafilter
(R : Type u_1) (R‚Çò : Type u_2) [comm_semiring R] [comm_semiring R‚Çò] (M : submonoid R) [subsingleton R] [algebra R R‚Çò] [is_localization M R‚Çò] : unique R‚Çò
{R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [ring A] [ring B] [algebra R A] [algebra R B] {c‚ÇÅ c‚ÇÇ : R} (q : quaternion_algebra.basis A c‚ÇÅ c‚ÇÇ) (F : A ‚Üí‚Çê[R] B) : quaternion_algebra.basis B c‚ÇÅ c‚ÇÇ
(n d : pos_num) : num
{Œ± : Type u} {Œ≤ : Type v} [mul_one_class Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_mul_hom f) : is_monoid_hom f
 : Fintype.skeleton ‚âå Fintype
(Œ± : Type u_1) (Œ≤ : Type u_2) [uniform_space Œ≤] : uniform_space.core (Œ± ‚Üí Œ≤)
(Œ≤ : Type u_2) [pseudo_metric_space Œ≤] [monoid Œ≤] : Prop
{Œ± : Type u} [topological_space Œ±] {Œπ : Type u_1} {f : Œπ ‚Üí set Œ±} (hf : locally_finite f) {s : set Œ±} (hs : is_compact s) : {i : Œπ | (f i ‚à© s).nonempty}.finite
{s : set ‚Ñù} (h : metric.bounded s) : emetric.diam s = ennreal.of_real (has_Sup.Sup s - has_Inf.Inf s)
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b c : Œ±} : a < b + c ‚Üí -b + a < c
{C : Type u} [category_theory.category C] {f g : category_theory.arrow C} [category_theory.limits.has_image f.hom] [category_theory.limits.has_image g.hom] (sq : f ‚ü∂ g) [category_theory.limits.has_image_map sq] : category_theory.limits.image f.hom ‚ü∂ category_theory.limits.image g.hom
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : category_theory.limits.walking_parallel_pair ‚•§ C
{C : Type u‚ÇÅ} [category_theory.small_category C] {‚Ñ∞ : Type u‚ÇÇ} [category_theory.category ‚Ñ∞] (A : C ‚•§ ‚Ñ∞) : ‚Ñ∞ ‚•§ C·µí·µñ ‚•§ Type u‚ÇÅ
(Œ± : Type u_1) {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [add_monoid Œ≤] [has_continuous_add Œ≤] [topological_space Œ≥] [add_monoid Œ≥] [has_continuous_add Œ≥] (g : Œ≤ ‚Üí+ Œ≥) (hg : continuous ‚áëg) : C(Œ±, Œ≤) ‚Üí+ C(Œ±, Œ≥)
{C : Type u} [category_theory.category C] : category_theory.arrow C ‚•§ C
{X : Type u_1} [topological_space X] (F : set X) : Prop
{Œ± : Type u‚ÇÅ} {a b : Œ±} (h : a = b) : {as := a} ‚âÖ {as := b}
{E : ‚Ñï ‚Üí Type u_1} : has_dist (Œ† (n : ‚Ñï), E n)
(Œ± : Type u) [t : topological_space Œ±] [topological_space.separable_space Œ±] [nonempty Œ±] : dense_range (topological_space.dense_seq Œ±)
{Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : lipschitz_with 1 (Œª (x : Œ±), metric.inf_nndist x s)
{K : Type u} [field K] {s t : subfield K} (h : s = t) : ‚Ü•s ‚âÉ+* ‚Ü•t
{C : Type u‚ÇÅ} [category_theory.category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (R : category_theory.presieve X) [category_theory.limits.has_pullbacks C] (x : category_theory.equalizer.first_obj P R) : ((category_theory.equalizer.first_obj_eq_family P R).hom x).compatible ‚Üî category_theory.equalizer.presieve.first_map P R x = category_theory.equalizer.presieve.second_map P R x
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : has_bracket (lie_ideal R L) (lie_submodule R L M)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') : category_theory.limits.cones.functoriality F H ‚ãô category_theory.limits.cones.postcompose (category_theory.whisker_left F Œ±.hom) ‚âÖ category_theory.limits.cones.functoriality F H'
{Œ± : Type u} (p : option Œ± ‚Üí Type v) (h : p option.none ‚Üí false) : (Œ£ (x : option Œ±), p x) ‚âÉ Œ£ (x : Œ±), p (option.some x)
{Œ± : Type u} [complete_lattice Œ±] : (Œ± ‚Üío Œ±) ‚Üío Œ±
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M ‚ß∏ N
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} (x : ‚Ü•X) : Top.presheaf C X ‚•§ C
{t : Type u_1 ‚Üí Type u_1 ‚Üí Type u_1} {m : Type u_1 ‚Üí Type u_1} [bitraversable t] [applicative m] {Œ± Œ≤ : Type u_1} : t (m Œ±) (m Œ≤) ‚Üí m (t Œ± Œ≤)
{Œ± : Type u_1} (a : Œ±) (n : ‚Ñï) : sym Œ± n
{n : ‚Ñï} {A : Type u} {Œ± : typevec n} (x : A) : mvqpf.const n A Œ±
{G : Type u_1} [add_group G] [topological_space G] {N : Type u_2} [add_group N] [topological_space N] (f : G ‚Üí+ N) (hf : continuous ‚áëf) (H : open_add_subgroup N) : open_add_subgroup G
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (hX : category_theory.limits.is_initial X) (i : X ‚âÖ Y) : category_theory.limits.is_initial Y
{p : ‚Ñï} [fact (nat.prime p)] (f : cau_seq ‚Ñö_[p] padic_norm_e) : ‚Ñï ‚Üí ‚Ñö
{Œ± : Type u_1} (s : multiset Œ±) : Prop
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 ‚àà s) : ‚Üë(‚ü®p1, hp1‚ü© -·µ• ‚áë(euclidean_geometry.orthogonal_projection s) p2) ‚àà s.direction
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_inv M‚ÇÇ] [has_involutive_inv M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (inv : ‚àÄ (x : M‚ÇÅ), f x‚Åª¬π = (f x)‚Åª¬π) : has_involutive_inv M‚ÇÇ
{Œ± : Type u} [random Œ±] : tactic Œ±
{G : Type u_1} [group G] (S : set G) : subgroup G
{R : Type u_1} [ring R] {f g : ‚Ñï ‚Üí R} : (‚àÄ (n : ‚Ñï), 0 < n ‚Üí n.divisors.sum (Œª (i : ‚Ñï), f i) = g n) ‚Üî ‚àÄ (n : ‚Ñï), 0 < n ‚Üí n.divisors_antidiagonal.sum (Œª (x : ‚Ñï √ó ‚Ñï), ‚Üë(‚áënat.arithmetic_function.moebius x.fst) * g x.snd) = f n
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] : category_theory.monoidal_functor C (category_theory.center C)
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] : Œ± √ó Œ≤ ‚Üío Œ≤
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {Œπ : Type u_6} (Z : topological_vector_bundle_core R B F Œπ) : is_open_map Z.proj
{Œ± : Sort u} (a : Œ±) {Œ≤ : Sort u} : Œ≤ ‚Üí Prop
 : (user_attribute unit)
{R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} [has_scalar R M] [has_scalar R S] [has_scalar S M] [is_scalar_tower R S M] (b : S) (ha : is_smul_regular M a) : is_smul_regular M (a ‚Ä¢ b) ‚Üî is_smul_regular M b
{V : Type u} {G G' : simple_graph V} (h : G ‚â§ G') : G ‚Üíg G'
{Œ≤ : Type u_2} [comm_monoid Œ≤] {n : ‚Ñï} (f : fin (n + 1) ‚Üí Œ≤) : finset.univ.prod (Œª (i : fin (n + 1)), f i) = f 0 * finset.univ.prod (Œª (i : fin n), f i.succ)
{G : Type u_1} [add_comm_monoid G] : add_monoid.is_torsion ‚Ü•(add_comm_monoid.add_torsion G)
(R : Type u) [semiring R] [nontrivial R] [hq : exp_char R 1] : char_zero R
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) [measurable_space E] [opens_measurable_space E] [complete_space F] : measurable_set {x : E | differentiable_at ùïú f x}
{Œ± : Type u_1} {Œ≤ : Type u_2} [encodable Œ±] [encodable Œ≤] (n : ‚Ñï) : option (Œ± ‚äï Œ≤)
 : expr ‚Üí tactic unit
{Œ± : Type u} [topological_space Œ±] : totally_disconnected_space Œ± ‚Üî ‚àÄ (x : Œ±), (connected_component x).subsingleton
 : Type
{C : Type u‚ÇÅ} [category_theory.category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (R : category_theory.presieve X) : category_theory.equalizer.first_obj P R ‚âÖ category_theory.presieve.family_of_elements P R
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) : Type (max u‚ÇÅ v‚ÇÅ)
{Œ± : Type u_1} [comm_semiring Œ±] (a x : Œ±) (n : ‚Ñï) (b : Œ±) : Œ±
(Œ± : Type u_1) [distrib_lattice Œ±] [bounded_order Œ±] : BoundedDistribLattice
{n : ‚Ñï} (c : composition n) : (Œ£ (i : fin c.length), fin (c.blocks_fun i)) ‚âÉ fin n
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_binary_coproducts C] [category_theory.cartesian_closed C] (X Y Z : C) : Z ‚®Ø X ‚®ø (Z ‚®Ø Y) ‚âÖ Z ‚®Ø (X ‚®ø Y)
(n : ‚Ñï+) (A : Type u) (K : Type w) [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] : algebra A (cyclotomic_ring n A K)
{M : Type u_3} [add_comm_monoid M] : add_submonoid M ‚âÉo submodule ‚Ñï M
{Œ± : Type u} {R : Type v} [comm_ring R] : (Œ± ‚Üí R) ‚âÉ (free_comm_ring Œ± ‚Üí+* R)
(v : expr) : expr ‚Üí tactic expr
 : environment ‚Üí name ‚Üí bool
 : expr ‚Üí expr ‚Üí tactic (expr √ó expr)
(k n : ‚Ñï) : n ‚â§ k ‚Üí list {m // has_well_founded.r m k} ‚Üí list {m // has_well_founded.r m k}
{ùïú : Type u_3} [field ùïú] {r : ‚Ñï} (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) (i : fin r ‚äï unit) : (matrix.pivot.list_transvec_col M).prod.mul M (sum.inr ()) i = M (sum.inr ()) i
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.preadditive C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (X : C) (P : category_theory.ProjectiveResolution X) : homotopy (category_theory.ProjectiveResolution.lift (ùüô X) P P) (ùüô P.complex)
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A‚ÇÅ B‚ÇÅ C‚ÇÅ : V} {f‚ÇÅ : A‚ÇÅ ‚ü∂ B‚ÇÅ} [category_theory.limits.has_image f‚ÇÅ] {g‚ÇÅ : B‚ÇÅ ‚ü∂ C‚ÇÅ} [category_theory.limits.has_kernel g‚ÇÅ] (w‚ÇÅ : f‚ÇÅ ‚â´ g‚ÇÅ = 0) {A‚ÇÇ B‚ÇÇ C‚ÇÇ : V} {f‚ÇÇ : A‚ÇÇ ‚ü∂ B‚ÇÇ} [category_theory.limits.has_image f‚ÇÇ] {g‚ÇÇ : B‚ÇÇ ‚ü∂ C‚ÇÇ} [category_theory.limits.has_kernel g‚ÇÇ] (w‚ÇÇ : f‚ÇÇ ‚â´ g‚ÇÇ = 0) [category_theory.limits.has_cokernel (image_to_kernel f‚ÇÅ g‚ÇÅ w‚ÇÅ)] [category_theory.limits.has_cokernel (image_to_kernel f‚ÇÇ g‚ÇÇ w‚ÇÇ)] (Œ± : category_theory.arrow.mk f‚ÇÅ ‚âÖ category_theory.arrow.mk f‚ÇÇ) (Œ≤ : category_theory.arrow.mk g‚ÇÅ ‚âÖ category_theory.arrow.mk g‚ÇÇ) (p : Œ±.hom.right = Œ≤.hom.left) : homology f‚ÇÅ g‚ÇÅ w‚ÇÅ ‚âÖ homology f‚ÇÇ g‚ÇÇ w‚ÇÇ
(p : ‚Ñï) (z : ‚Ñ§) : ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] [decidable_eq Œ≤] (f : Œ± ‚Ü™ Œ≤) : Œ± ‚âÉ ‚Ü•(set.range ‚áëf)
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {s : set Œ±} (h : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)) ‚â† 1) : s.nonempty
{X : Type u_2} [emetric_space X] (s : set X) : ennreal
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [add_comm_monoid M] [add_comm_monoid N] (f : M ‚âÉ+ N) : (Œ± ‚Üí‚ÇÄ M) ‚âÉ+ (Œ± ‚Üí‚ÇÄ N)
{Œπ : Type u_1} {x : ‚Ñï} {s : Œπ ‚Üí ‚Ñï} {t : finset Œπ} : (‚àÄ (i : Œπ), i ‚àà t ‚Üí (s i).coprime x) ‚Üí (t.prod (Œª (i : Œπ), s i)).coprime x
 : vm_obj ‚Üí ‚Ñï
 : ¬¨set.univ.countable
{Œ± : Sort u} (a : Œ±) : Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [fintype Œ±] [fintype Œ≤] [add_comm_monoid M] (e : Œ± ‚âÉ Œ≤) (f : Œ± ‚Üí M) (g : Œ≤ ‚Üí M) (h : ‚àÄ (x : Œ±), f x = g (‚áëe x)) : finset.univ.sum (Œª (x : Œ±), f x) = finset.univ.sum (Œª (x : Œ≤), g x)
(Œ± : Type u_1) [boolean_ring Œ±] : BoolRing
(a b : ‚Ñï) : conv unit
 : category_theory.Cat.free ‚ä£ category_theory.Quiv.forget
{Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) (i j : Œπ) : local_homeomorph (B √ó F) (B √ó F)
{M : Type u_3} [monoid M] (L : list M) (h : L.prod ‚â† 1) : 0 < L.length
{Œ± : Type u_1} {M : Type u_5} [monoid M] (l : filter Œ±) : (Œ± ‚Üí M) ‚Üí* l.germ M
{A : Type u_12} {B : Type u_13} [has_add A] [has_add B] (self : A ‚âÉ+ B) : A ‚âÉ B
{Œ± : Type u_2} [topological_space Œ±] [has_mul Œ±] [has_continuous_mul Œ±] : has_continuous_mul Œ±·µê·µí·µñ
 : BoundedLattice ‚•§ BoundedLattice
{a : ‚Ñï} (a1 : 1 < a) (n : ‚Ñï) : ‚Ñï
{V : Type u_1} [inner_product_space ‚Ñù V] (x y : V) {r : ‚Ñù} (hr : 0 < r) : inner_product_geometry.angle x (r ‚Ä¢ y) = inner_product_geometry.angle x y
{Œ± : Type u_1} {ùíú : finset (finset Œ±)} {A‚ÇÅ A‚ÇÇ : finset Œ±} {r‚ÇÅ r‚ÇÇ : ‚Ñï} (h‚ÇÅ : A‚ÇÅ ‚àà ùíú.slice r‚ÇÅ) (h‚ÇÇ : A‚ÇÇ ‚àà ùíú.slice r‚ÇÇ) : r‚ÇÅ ‚â† r‚ÇÇ ‚Üí A‚ÇÅ ‚â† A‚ÇÇ
{ùïú : Type u_1} {E : Type u_2} [normed_linear_ordered_field ùïú] [normed_group E] [normed_space ùïú E] {A B : set E} (hAB : is_exposed ùïú A B) : ‚àÉ (l : E ‚ÜíL[ùïú] ùïú) (a : ùïú), B = {x ‚àà A | a ‚â§ ‚áël x}
{R : Type u} [comm_ring R] {G H : Module R} {f : G ‚ü∂ H} (F' : category_theory.limits.mono_factorisation f) : Module.image f ‚ü∂ F'.I
(d : declaration) : tactic (option string)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (p : Œπ ‚Üí P) (b : P) : (Œπ ‚Üí k) ‚Üí‚Çó[k] V
(K : Type u_1) [field K] [fintype K] [fintype KÀ£] (i : ‚Ñï) : finset.univ.sum (Œª (x : KÀ£), ‚Üëx ^ i) = ite (fintype.card K - 1 ‚à£ i) (-1) 0
(q : interactive.parse interactive.types.texpr) : tactic unit
{k : Type u_2} [field k] : power_series k ‚Üí power_series k
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_monoid Œ≤] (s : finset Œ±) (f : Œ± ‚Üí Œ≤) (comm : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí add_commute (f x) (f y)) : Œ≤
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] (S : intermediate_field F E) : Prop
{Œ≤ : Type u} {Œ± : Type v} [add_comm_monoid Œ≤] {p : Œ± ‚Üí Prop} {s : finset {x // p x}} {f : {x // p x} ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (h : ‚àÄ (x : {x // p x}), x ‚àà s ‚Üí g ‚Üëx = f x) : (finset.map (function.embedding.subtype (Œª (x : Œ±), p x)) s).sum (Œª (x : Œ±), g x) = s.sum (Œª (x : {x // p x}), f x)
{K : Type u_1} [division_ring K] (g : generalized_continued_fraction K) : ‚Ñï ‚Üí generalized_continued_fraction K
(p : ‚Ñï) [hp : fact (nat.prime p)] (n : ‚Ñï) : mv_polynomial ‚Ñï ‚Ñ§
(M : Type u_1) {Œ± : Type u_2} [add_monoid M] [add_action M Œ±] (s : set Œ±) : add_submonoid M
{R : Type u_1} [comm_semiring R] {M : submonoid R} (z w : localization M) : localization M
{G : Type u_1} [group G] (K : subgroup G) : subgroup.closure ‚ÜëK = K
{Œ± : Type u} [topological_space Œ±] [t2_space Œ±] [compact_space Œ±] : totally_disconnected_space Œ± ‚Üî totally_separated_space Œ±
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] {N : lie_submodule R L M} : L ‚Üí‚Çó[R] ‚Ü•(N.to_submodule.compatible_maps N.to_submodule)
{key value : Type} [has_add value] [has_zero value] [decidable_eq value] (m1 m2 : native.rb_map key value) : native.rb_map key value
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [complete_space E] : has_star (E ‚ÜíL[ùïú] E)
{V : Type (u+1)} [category_theory.large_category V] {G : Mon} (M N : Action V G) : Type u
(R : Type u_1) [comm_semiring R] (X : Type u_2) : has_coe R (free_algebra.pre R X)
{C : Type u} [category_theory.category C] {X Y Z : algebraic_geometry.PresheafedSpace C} (Œ± : X.hom Y) (Œ≤ : Y.hom Z) : X.hom Z
{f : ‚Ñù ‚Üí ‚Ñù} {f' a : ‚Ñù} (h : is_local_max f a) (hf : has_deriv_at f f' a) : f' = 0
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} [topological_space Œ≤] {m : measurable_space Œ±} (hf : measure_theory.strongly_measurable f) : ‚Ñï ‚Üí measure_theory.simple_func Œ± Œ≤
{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_3} [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] (f : normed_group_hom V‚ÇÅ V‚ÇÇ) : V‚ÇÅ ‚Üí+ V‚ÇÇ
{F : Type u_1} [normed_group F] [normed_space ‚Ñù F] (f : ‚Ñù ‚Üí F) [complete_space F] : measurable_set {x : ‚Ñù | differentiable_within_at ‚Ñù f (set.Ioi x) x}
(R : Type u_1) [rack R] : Type u_1
(n : ‚Ñï) (a : fin n) (b : ‚Ñï) : Prop
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [bounded_order Œ±] [bounded_order Œ≤] (f : bounded_order_hom Œ± Œ≤) : bot_hom Œ± Œ≤
{Œ≤ : Type u_2} {f g : Œ≤ ‚Üí nnreal} (hgf : ‚àÄ (b : Œ≤), g b ‚â§ f b) : summable f ‚Üí summable g
(d : macro_def) : name
{Œ± : Type u_1} [add_group Œ±] {s : add_subgroup Œ±} (a : Œ±) : Œ± ‚ß∏ s
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ‚Ñù E] [normed_group F] [normed_space ‚Ñù F] {s : set E} (s_conv : convex ‚Ñù s) {f : E ‚Üí F} {f' : E ‚Üí (E ‚ÜíL[‚Ñù] F)} {f'' : E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] F} (hf : ‚àÄ (x : E), x ‚àà interior s ‚Üí has_fderiv_at f (f' x) x) {x : E} (xs : x ‚àà s) (hx : has_fderiv_within_at f' f'' (interior s) x) {v w : E} (h4v : x + 4 ‚Ä¢ v ‚àà interior s) (h4w : x + 4 ‚Ä¢ w ‚àà interior s) : ‚áë(‚áëf'' w) v = ‚áë(‚áëf'' v) w
{ùïú : Type u} [nondiscrete_normed_field ùïú] (p : polynomial ùïú) (x : ùïú) : has_deriv_at (Œª (x : ùïú), polynomial.eval x p) (polynomial.eval x (‚áëpolynomial.derivative p)) x
{Œ± : Type u_1} [partial_order Œ±] (c : closure_operator Œ±) (x : Œ±) : x ‚â§ ‚áëc x
{R : Type u_2} {Œì‚ÇÄ : Type u_3} {Œì'‚ÇÄ : Type u_4} [ring R] [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] [linear_ordered_comm_monoid_with_zero Œì'‚ÇÄ] {v‚ÇÅ : valuation R Œì‚ÇÄ} {v‚ÇÇ : valuation R Œì'‚ÇÄ} {S : Type u_1} [ring S] (f : S ‚Üí+* R) (h : v‚ÇÅ.is_equiv v‚ÇÇ) : (valuation.comap f v‚ÇÅ).is_equiv (valuation.comap f v‚ÇÇ)
(F : Type u_7) (Œ± : out_param (Type u_8)) (Œ≤ : out_param (Type u_9)) [lattice Œ±] [lattice Œ≤] [bounded_order Œ±] [bounded_order Œ≤] : Type (max u_7 u_8 u_9)
{Œ± : Type u_1} [has_to_tactic_format Œ±] (l : list (‚Ñï √ó Œ±)) : tactic string
(n : ‚Ñï+) (S : set ‚Ñï+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [ne_zero ‚Üë‚Üën] [H : is_cyclotomic_extension S K L] (hS : n ‚àà S) : polynomial.splits (algebra_map K L) (polynomial.X ^ ‚Üën - 1)
(A : Type u_1) [has_add A] : add_aut A ‚Üí* equiv.perm A
{R : Type u_1} {S : Type u_2} {M : Type u_3} [monoid R] [mul_action R M] [monoid S] [has_scalar S M] (f : R ‚Üí* S) (hf : function.surjective ‚áëf) (hsmul : ‚àÄ (c : R) (x : M), ‚áëf c ‚Ä¢ x = c ‚Ä¢ x) : mul_action S M
(local_or_meta : bool) (b : binder) : tactic expr
{Œ± : Type u_1} [lattice Œ±] [order_bot Œ±] {a : Œ±} : has_le (finpartition a)
{Œπ : Type u_5} {Œ±i : Œπ ‚Üí Type u_6} {Œ≤i : Œπ ‚Üí Type u_7} (ei : Œ† (i : Œπ), local_equiv (Œ±i i) (Œ≤i i)) : local_equiv (Œ† (i : Œπ), Œ±i i) (Œ† (i : Œπ), Œ≤i i)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [category_theory.limits.has_cokernel f] [category_theory.is_iso g] : category_theory.limits.cokernel (f ‚â´ g) ‚âÖ category_theory.limits.cokernel f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p : P) (h : s.sum (Œª (i : Œπ), w i) = 0) : ‚áë(s.weighted_vsub (Œª (_x : Œπ), p)) w = 0
{Œ± : Type u} {Œ≤ : Type v} (Œπ : Œ± ‚Ü™ Œ≤) : equiv.perm Œ± ‚Üí* equiv.perm Œ≤
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] [nonempty Œ±] [topological_space Œ≤] [has_one Œ±] {f : Œ≤ ‚Üí Œ±} (hf : continuous f) (h : has_compact_mul_support f) : bdd_below (set.range f)
{Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚Üí Œ≤} (h : function.injective f) (s : set Œ±) : set.inj_on f s
{Œ± : Type u} [decidable_eq Œ±] (a : Œ±) : wseq Œ± ‚Üí computation ‚Ñï
{R : Type u_1} [comm_semiring R] {X : Type u_2} : free_algebra R X ‚âÉ‚Çê[R] monoid_algebra R (free_monoid X)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥} (e : Œ† (c : Œ≥), ‚Ü•(f ‚Åª¬π' {c}) ‚âÉ ‚Ü•(g ‚Åª¬π' {c})) : Œ± ‚âÉ Œ≤
{G : Type u} {n : ‚Ñï} [fintype G] [group G] (h : (fintype.card G).coprime n) : G ‚âÉ G
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : Type (max u (v+1))
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det
{p n : ‚Ñï} {R : Type u_1} [comm_ring R] (x : truncated_witt_vector p n R) : witt_vector p R
(Œ± : Type u) : Type u
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] (f : S.localization_map N) : f.of_mul_equiv_of_dom _ = f
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {R : Type u_1} [semiring k] [mul_one_class G] [semiring R] {f g : monoid_algebra k G ‚Üí+* R} (h‚ÇÅ : f.comp monoid_algebra.single_one_ring_hom = g.comp monoid_algebra.single_one_ring_hom) (h_of : ‚Üëf.comp (monoid_algebra.of k G) = ‚Üëg.comp (monoid_algebra.of k G)) : f = g
(Œ± : Type u) [uniform_space Œ±] [(uniformity Œ±).is_countably_generated] [topological_space.separable_space Œ±] : topological_space.second_countable_topology Œ±
{R : Type u_1} [monoid_with_zero R] (f : nat.arithmetic_function R) : Prop
(ùïú : Type u_5) [normed_field ùïú] {E : Type u_6} [normed_group E] [normed_space ùïú E] {F : Type u_7} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) : Prop
(G : Type u_1) [monoid G] : Prop
(R : Type u_1) [comm_ring R] (M : Type u_2) [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [nontrivial R] : ‚áë(linear_map.trace R M) linear_map.id = ‚Üë(finite_dimensional.finrank R M)
{Œ± : Type u_1} {Œ≤ : Type u_2} [t : topological_space Œ±] [add_group Œ≤] (f : Œ± ‚Üí Œ≤) : add_group_topology Œ≤
{Œ± : Type u_1} [linear_ordered_field Œ±] {a b : Œ±} (ha : 0 < a) (hb : 0 < b) : a‚Åª¬π < b‚Åª¬π ‚Üî b < a
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : submodule R M
{Œ± : Type u_1} {r s : Œ± ‚Üí Œ± ‚Üí Prop} (h : ‚àÄ (x y : Œ±), r x y ‚Üí s x y) : eqv_gen.setoid r ‚â§ eqv_gen.setoid s
 : category_theory.limits.has_limits_of_size AddGroup
{p : ‚Ñï} [fact (nat.prime p)] {f : padic_seq p} (hf : ¬¨f ‚âà 0) (v1 v2 : ‚Ñï) : padic_norm p (‚áëf (padic_seq.stationary_point hf)) = padic_norm p (‚áëf (linear_order.max v1 (linear_order.max v2 (padic_seq.stationary_point hf))))
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_lt.lt] {a b : Œ±} (ha : a < 1) (hb : b ‚â§ 1) : a * b < 1
(Œ± : Type u_1) [uniform_space Œ±] : punit √ó Œ± ‚âÉ·µ§ Œ±
{Œ± : Type u_1} [has_le Œ±] {s : set Œ±} : is_upper_set s ‚Üí is_lower_set (‚áëorder_dual.of_dual ‚Åª¬π' s)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [comm_ring ùïú] [add_comm_group E] [add_comm_group F] [module ùïú E] [module ùïú F] [topological_space E] [topological_space F] [topological_add_group E] [has_continuous_const_smul ùïú E] [topological_add_group F] [has_continuous_const_smul ùïú F] (p : formal_multilinear_series ùïú E F) {n : ‚Ñï} (c : composition n) : (fin n ‚Üí E) ‚Üí fin c.length ‚Üí F
(tac : tactic unit) : tactic unit
 : expr ‚Üí tactic omega.nat.exprform
{Œ± : Type u} {Œ≤ : Type v} [uniform_space Œ±] [uniform_space Œ≤] [separated_space Œ≤] (f : Œ± ‚Üí Œ≤) : uniform_space.separation_quotient Œ± ‚Üí Œ≤
{Œ≤ : Type u} {Œ± : Type v} [add_comm_monoid Œ≤] [decidable_eq Œ±] (s : finset Œ±) (f : Œ± ‚Üí Œ≤) {a : Œ±} (h : a ‚àà s) : f a + (s.erase a).sum (Œª (x : Œ±), f x) = s.sum (Œª (x : Œ±), f x)
(C : Type u) [category_theory.category C] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_equalizer f g] [category_theory.limits.has_equalizer (G.map f) (G.map g)] [category_theory.limits.preserves_limit (category_theory.limits.parallel_pair f g) G] : G.obj (category_theory.limits.equalizer f g) ‚âÖ category_theory.limits.equalizer (G.map f) (G.map g)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {A : Type u‚ÇÉ} [category_theory.category A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (hG‚ÇÅ : category_theory.compatible_preserving K G) (hG‚ÇÇ : category_theory.cover_preserving J K G) (‚Ñ± : category_theory.Sheaf K A) : category_theory.presheaf.is_sheaf J (G.op ‚ãô ‚Ñ±.val)
{Œ± : Type u} [emetric_space Œ±] [complete_space Œ±] : complete_space (topological_space.nonempty_compacts Œ±)
{Œ± : Type u} (Œ≤ : Type v) [group Œ±] [add_monoid Œ≤] [distrib_mul_action Œ± Œ≤] (x : Œ±) : Œ≤ ‚âÉ+ Œ≤
{V : Type u} {G : simple_graph V} {u v : V} (p : G.walk u v) (n : ‚Ñï) : V
(g : ‚Ü•(matrix.GL_pos (fin 2) ‚Ñù)) (z : upper_half_plane) : ‚ÑÇ
{Œ± : Type u_1} [topological_space Œ±] {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : upper_semicontinuous f) (hg : upper_semicontinuous g) (hcont : ‚àÄ (x : Œ±), continuous_at (Œª (p : Œ≥ √ó Œ≥), p.fst + p.snd) (f x, g x)) : upper_semicontinuous (Œª (z : Œ±), f z + g z)
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] {S : Type u_1} [comm_ring S] [algebra S R] [module S M] [is_scalar_tower S R M] (f : R ‚Üí‚Çó[S] S) (Q : quadratic_form R M) : quadratic_form S M
{J : Type v} [category_theory.small_category J] (F : J ‚•§ SemiRing) : subsemiring (Œ† (j : J), ‚Ü•(F.obj j))
{Œ± : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul Œ±] [add_comm_monoid Œ±] (A : matrix m n Œ±) [fintype m] : A.transpose.has_orthogonal_rows ‚Üî A.has_orthogonal_cols
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (d : con N) : con (M √ó N)
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} (t : category_theory.limits.fork f g) [category_theory.epi t.Œπ] : f = g
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (f : Œ≤ ‚ÜíCO Œ≥) (g : Œ± ‚ÜíCO Œ≤) : Œ± ‚ÜíCO Œ≥
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] (self : A ‚Üí‚Çê[R] B) : A ‚Üí+* B
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ‚Ñù E] [normed_group F] [normed_space ‚Ñù F] {f : E ‚Üí F} {p : E ‚Üí formal_multilinear_series ‚Ñù E F} {s : set E} {x : E} (hf : has_ftaylor_series_up_to_on 1 f p (has_insert.insert x s)) (hs : convex ‚Ñù s) (K : nnreal) (hK : ‚à•p x 1‚à•‚Çä < K) : ‚àÉ (t : set E) (H : t ‚àà nhds_within x s), lipschitz_on_with K f t
 : Type
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.has_split_coequalizer f g] : C
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± ‚Ñ±' : category_theory.Sheaf K A} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) : ‚Ñ±.val ‚âÖ ‚Ñ±'.val
{Œ± : Type u} (x : Œ±) : free_semigroup Œ±
(a b : ‚Ñï) {c : ‚Ñï} (hc : 0 < c) : c * a / (c * b) = a / b
{Œ± : Type u_1} [preorder Œ±] {Œ≤ : Type u_2} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (f_strict_mono : strict_mono f) (s : ordset Œ±) : ordset Œ≤
{s : set ‚Ñï} (hs : s.infinite) {k : ‚Ñï} (hk : 0 < k) : ‚àÉ (m : ‚Ñï) (H : m ‚àà s) (n : ‚Ñï) (H : n ‚àà s), m < n ‚àß m ‚â° n [MOD k]
{Œ± : Type u} : ordnode Œ± ‚Üí ‚Ñï ‚Üí option Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {X X' Y Y' Z Z' : C} [category_theory.exact_pairing Y Y'] (f : X ‚ü∂ Y ‚äó Z) (g : X' ‚ü∂ Z') : ‚áë((category_theory.tensor_left_hom_equiv (X ‚äó X') Y Y' (Z ‚äó Z')).symm) ((f ‚äó g) ‚â´ (Œ±_ Y Z Z').hom) = (Œ±_ Y' X X').inv ‚â´ (‚áë((category_theory.tensor_left_hom_equiv X Y Y' Z).symm) f ‚äó g)
{X Y : SemiNormedGroup‚ÇÅ} (f : X ‚ü∂ Y) : category_theory.limits.cofork f 0
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : C·µí·µñ ‚•§ Type v‚ÇÅ} : category_theory.presieve.is_sheaf_for P ‚áëS ‚Üî category_theory.presieve.yoneda_sheaf_condition P S
(p : ‚Ñï) [hp : fact (nat.prime p)] {q r : ‚Ñö} : padic_norm p (q - r) ‚â§ linear_order.max (padic_norm p q) (padic_norm p r)
 : tactic unit
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [has_one Œ≤] : has_one Œ±
(n : ‚Ñï+) (A : Type w) (B : Type z) [comm_ring A] [comm_ring B] [algebra A B] [is_cyclotomic_extension {n} A B] : B
(Œ± : Type u) (Œ≤ : Type v) [add_group Œ±] [add_action Œ± Œ≤] [fintype Œ±] [Œ† (a : Œ±), fintype ‚Ü•(add_action.fixed_by Œ± Œ≤ a)] [fintype (quotient (add_action.orbit_rel Œ± Œ≤))] : finset.univ.sum (Œª (a : Œ±), fintype.card ‚Ü•(add_action.fixed_by Œ± Œ≤ a)) = fintype.card (quotient (add_action.orbit_rel Œ± Œ≤)) * fintype.card Œ±
 : expr ‚Üí expr ‚Üí expr ‚Üí expr √ó expr ‚Üí expr √ó expr ‚Üí tactic.norm_fin.eval_fin_m expr
 : tactic.ring2.csring_expr ‚Üí tactic.ring2.horner_expr
{Œ± : Type u_1} [primcodable Œ±] (p : Œ± ‚Üí Prop) : Prop
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1 < s2 ‚Üî ‚Üës1 ‚äÇ ‚Üës2
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_initial C] [category_theory.limits.has_initial D] [i : category_theory.is_iso (category_theory.limits.initial_comparison G)] : category_theory.limits.preserves_colimit (category_theory.functor.empty C) G
{Œ± : Type u_1} {p : Œ± ‚Üí Prop} [emetric_space Œ±] : emetric_space (subtype p)
(R : Type u_1) (B : Type u_3) (F : Type u_4) [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] (Œπ : Type u_2) [inhabited Œπ] : topological_vector_bundle_core R B F Œπ
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_equiv Œ± Œ≤) (hc : continuous_on ‚áëe e.source) (ho : is_open_map (e.source.restrict ‚áëe)) (hs : is_open e.source) : local_homeomorph Œ± Œ≤
{Œ± : Type u_1} : ‚ä§.realizer
{C : Type u‚ÇÅ} [category_theory.category C] (T : category_theory.monad C) : ‚ÜëT ‚ãô ‚ÜëT ‚ü∂ ‚ÜëT
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} (t : category_theory.limits.trident f) : ((category_theory.functor.const (category_theory.limits.walking_parallel_family J)).obj t.X).obj category_theory.limits.walking_parallel_family.zero ‚ü∂ (category_theory.limits.parallel_family f).obj category_theory.limits.walking_parallel_family.zero
 : pos_num ‚Üí pos_num ‚Üí num
(v : ‚Ñï ‚Üí ‚Ñ§) : omega.int.preform ‚Üí Prop
 : expr ‚Üí vm format
{M : Type u_1} [has_add M] (S : add_subsemigroup M) : set M
 : (expr ‚Üí bool) ‚Üí smt_tactic unit
 : tactic.instance_cache ‚Üí expr ‚Üí ‚Ñö ‚Üí tactic (tactic.instance_cache √ó expr √ó expr)
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [linear_ordered_add_comm_monoid_with_top Œì‚ÇÄ] [ring R] (v : add_valuation R Œì‚ÇÄ) : preorder R
{Œ± : Type u_1} [add_group Œ±] {s : add_subgroup Œ±} (g : Œ±) : ‚Ü•(left_add_coset g ‚Üës) ‚âÉ ‚Ü•s
{Œπ : Type u_1} {R : Type u_8} [ordered_comm_semiring R] {s : finset Œπ} {i : Œπ} {f g h : Œπ ‚Üí R} (hi : i ‚àà s) (h2i : g i + h i ‚â§ f i) (hgf : ‚àÄ (j : Œπ), j ‚àà s ‚Üí j ‚â† i ‚Üí g j ‚â§ f j) (hhf : ‚àÄ (j : Œπ), j ‚àà s ‚Üí j ‚â† i ‚Üí h j ‚â§ f j) (hg : ‚àÄ (i : Œπ), i ‚àà s ‚Üí 0 ‚â§ g i) (hh : ‚àÄ (i : Œπ), i ‚àà s ‚Üí 0 ‚â§ h i) : s.prod (Œª (i : Œπ), g i) + s.prod (Œª (i : Œπ), h i) ‚â§ s.prod (Œª (i : Œπ), f i)
{Œ± : Type u_1} {b : bool} : lists' Œ± b ‚Üí list (lists Œ±)
 : ‚Ñö ‚Üí string
{C : Type u} [category_theory.category C] {X Y Z : C} {sXY : category_theory.limits.binary_fan X Y} {sYZ : category_theory.limits.binary_fan Y Z} (Q : category_theory.limits.is_limit sYZ) (s : category_theory.limits.binary_fan sXY.X Z) : category_theory.limits.binary_fan X sYZ.X
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) [category_theory.limits.has_binary_biproduct P Q] : category_theory.limits.is_limit (category_theory.limits.binary_biproduct.bicone P Q).to_cone
 : pos_num ‚Üí ‚Ñï ‚Üí bool
(R : Type u_1) {A : Type u_2} [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A] [invertible 2] : A ‚Üí‚Çó[R] ‚Ü•(self_adjoint A)
{Œ± : Type u} {Œ≤ : Type v} [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] (c : omega_complete_partial_order.chain (Œ± ‚ÜíùíÑ Œ≤)) : Œ± ‚ÜíùíÑ Œ≤
 : tactic unit
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (r : ‚Ñù) (v : V) (p‚ÇÅ p‚ÇÇ : P) : has_dist.dist (r ‚Ä¢ v +·µ• p‚ÇÅ) p‚ÇÇ * has_dist.dist (r ‚Ä¢ v +·µ• p‚ÇÅ) p‚ÇÇ = has_inner.inner v v * r * r + 2 * has_inner.inner v (p‚ÇÅ -·µ• p‚ÇÇ) * r + has_inner.inner (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÅ -·µ• p‚ÇÇ)
{a : ‚Ñï} (a1 : 1 < a) (n : ‚Ñï) : ‚Ñ§
{L : first_order.language} {M : Type w} [L.Structure M] : L.equiv ‚Ü•‚ä§ M
 : Type u_1 ‚•§ Compactum
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f g : J ‚Üí C} [category_theory.limits.has_biproduct f] [category_theory.limits.has_biproduct g] (p : Œ† (b : J), f b ‚ü∂ g b) : ‚®Å f ‚ü∂ ‚®Å g
{M : Type u_1} [nonempty M] [add_semigroup M] [topological_space M] [compact_space M] [t2_space M] (continuous_mul_left : ‚àÄ (r : M), continuous (Œª (_x : M), _x + r)) : ‚àÉ (m : M), m + m = m
 : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§
 : is_trivial_topological_fiber_bundle ‚Ñù complex.re
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_initial C] : category_theory.limits.is_initial (‚ä•_ C)
{k : ‚Ñï} (n : ‚Ñï) (hpos : 0 < k) : ‚àÉ (p : ‚Ñï), nat.prime p ‚àß n ‚â§ p ‚àß p ‚â° 1 [MOD k]
{Œ± : Type u_1} [preorder Œ±] [fintype Œ±] : locally_finite_order Œ±
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : has_one (M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) {p1 : P} (p2 : P) (r : ‚Ñù) (hp : p1 ‚àà affine_span ‚Ñù (set.range s.points)) : ‚áë(s.orthogonal_projection_span) (r ‚Ä¢ (p2 -·µ• ‚Üë(‚áë(s.orthogonal_projection_span) p2)) +·µ• p1) = ‚ü®p1, hp‚ü©
(x : ‚Ñù) : ‚Ñù
 : is_trivial_topological_fiber_bundle ‚Ñù complex.im
{M : Type u_1} [has_mul M] {c d : con M} (H : c.to_setoid = d.to_setoid) : c = d
(R : Type u_2) (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] : R ‚Üí+ M ‚Üí+ M
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (M : Type w) [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [nontrivial M] [lie_algebra.is_nilpotent R L] [lie_module.is_nilpotent R L M] : lie_module.is_weight ‚ä§ M 0
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] {F G : category_theory.lax_monoidal_functor C D} (app : Œ† (X : C), F.to_functor.obj X ‚âÖ G.to_functor.obj X) (naturality : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), F.to_functor.map f ‚â´ (app Y).hom = (app X).hom ‚â´ G.to_functor.map f) (unit : F.Œµ ‚â´ (app (ùüô_ C)).hom = G.Œµ) (tensor : ‚àÄ (X Y : C), F.Œº X Y ‚â´ (app (X ‚äó Y)).hom = ((app X).hom ‚äó (app Y).hom) ‚â´ G.Œº X Y) : F ‚âÖ G
{Œ± : Type u} (s : set Œ±) : Prop
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] : list Œ± ‚Üí ordnode Œ±
{Œπ Œ± : Type v} (U : Œπ ‚Üí Œ±) [complete_lattice Œ±] : category_theory.limits.cocone (category_theory.pairwise.diagram U)
{Œ± : Type u_3} {Œ≤ : Type u_4} [lattice Œ±] [lattice Œ≤] [bounded_order Œ±] [bounded_order Œ≤] (f : bounded_lattice_hom Œ± Œ≤) : bounded_order_hom Œ± Œ≤
{C : Type u} [category_theory.category C] : category_theory.grothendieck_topology C
{Œ± : Type u} (s : stream Œ±) : stream Œ±
{X : Type u} {Y : Type v} [preorder X] [preorder Y] {L : X ‚•§ Y} {R : Y ‚•§ X} (adj : L ‚ä£ R) : galois_connection L.obj R.obj
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pullbacks C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : category_theory.limits.is_limit (category_theory.abelian.pullback_to_biproduct_is_kernel.pullback_to_biproduct_fork f g)
 : category_theory.limits.preserves_limits_of_size (category_theory.forget AddCommMon)
{Œ± : Type u_1} [topological_space Œ±] [baire_space Œ±] {S : set (set Œ±)} (hc : ‚àÄ (s : set Œ±), s ‚àà S ‚Üí is_closed s) (hS : S.countable) (hU : ‚ãÉ‚ÇÄS = set.univ) : dense (‚ãÉ (s : set Œ±) (H : s ‚àà S), interior s)
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_5} [decidable_eq Œ≥] (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (s : finset Œ±) (t : finset Œ≤) : finset Œ≥
{S : Type u} [semigroup S] {a x y x' y' : S} (h : semiconj_by a x y) (h' : semiconj_by a x' y') : semiconj_by a (x * x') (y * y')
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : X
(Œ± : Type u) (Œ≤ : Type v) [topological_space Œ±] [has_zero Œ≤] [topological_space Œ≤] : Type (max u v)
 : Type
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) : 2 ‚Ä¢ o.oangle x (-y) = 2 ‚Ä¢ o.oangle x y
(Œ± : Type u_2) [topological_space Œ±] : spectral_map Œ± Œ±
{Œπ : Type u_1} {ùïú : Type u_2} [is_R_or_C ùïú] {E : Type u_3} [inner_product_space ùïú E] [cplt : complete_space E] {G : Œπ ‚Üí Type u_4} [Œ† (i : Œπ), inner_product_space ùïú (G i)] {V : Œ† (i : Œπ), G i ‚Üí‚Çó·µ¢[ùïú] E} (hV : orthogonal_family ùïú V) [‚àÄ (i : Œπ), complete_space (G i)] (hV' : (‚®Ü (i : Œπ), (V i).to_linear_map.range).topological_closure = ‚ä§) (w : ‚Ü•(lp G 2)) : has_sum (Œª (i : Œπ), ‚áë(V i) (‚áëw i)) (‚áë((hV.linear_isometry_equiv hV').symm) w)
{V : Type u} (G : simple_graph V) : G.coloring V
{Œ± : Type u_1} {M : Type u_2} {N : Type u_3} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid N] [module R N] (e : M ‚âÉ‚Çó[R] N) : (Œ± ‚Üí‚ÇÄ M) ‚âÉ‚Çó[R] Œ± ‚Üí‚ÇÄ N
{F G H : Type u} [add_group F] [add_group G] [add_group H] [fintype F] [fintype H] (f : F ‚Üí+ G) (g : G ‚Üí+ H) (h : g.ker = f.range) : fintype G
(Œπ : Type v) (Œ≤ : Œπ ‚Üí Type w) [Œ† (i : Œπ), add_comm_monoid (Œ≤ i)] : Type (max v w)
(œÅ : out_param (Type u)) (m : Type u ‚Üí Type v) : Type v
(R : Type u) [semiring R] : Prop
{Œ± : Sort u} {F : Œ±·µí·µñ ‚Üí Sort v} (h : Œ† (X : Œ±), F (opposite.op X)) (X : Œ±·µí·µñ) : F X
(C : Type u‚ÇÅ) [category_theory.category C] : C ‚•§ category_theory.thin_skeleton C
{R : Type u_1} [semiring R] {M : laurent_polynomial R ‚Üí Prop} (p : laurent_polynomial R) (h_add : ‚àÄ (p q : laurent_polynomial R), M p ‚Üí M q ‚Üí M (p + q)) (h_C_mul_T : ‚àÄ (n : ‚Ñ§) (a : R), M (‚áëlaurent_polynomial.C a * laurent_polynomial.T n)) : M p
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (l : Œπ ‚Üí ùïú) {s : finset Œπ} {i : Œπ} (hi : i ‚àà s) : has_inner.inner (s.sum (Œª (i : Œπ), l i ‚Ä¢ v i)) (v i) = ‚áë(star_ring_end ùïú) (l i)
{Œ± : Type u_3} {Œ≤ : Type u_4} [has_inf Œ±] [has_inf Œ≤] (f : inf_hom Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : inf_hom Œ± Œ≤
(p : Prop) (t : list (slim_check.testable p)) (h : 0 < t.length) : slim_check.testable p
{Œ± : Type u_1} {M : Type u_5} [has_zero M] (f : option Œ± ‚Üí‚ÇÄ M) : Œ± ‚Üí‚ÇÄ M
{R‚ÇÅ : Type u_2} {R‚ÇÇ : Type u_3} {M : Type u_9} {N‚ÇÇ : Type u_14} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_group N‚ÇÇ] [module R‚ÇÅ M] [module R‚ÇÇ N‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} : has_neg (M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] N‚ÇÇ)
 : expr ‚Üí option ‚Ñï
{Œ± : Type u_2} [has_mul Œ±] (a : Œ±) (s t : set Œ±) : set Œ±
{F : pfunctor} {n : ‚Ñï} (x : pfunctor.approx.cofix_a F n.succ) : F.B (pfunctor.approx.head' x) ‚Üí pfunctor.approx.cofix_a F n
{R : Type u} [ring R] {Œπ : Sort u_1} [hŒπ : nonempty Œπ] {S : Œπ ‚Üí subring R} (hS : directed has_le.le S) {x : R} : (x ‚àà ‚®Ü (i : Œπ), S i) ‚Üî ‚àÉ (i : Œπ), x ‚àà S i
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (hp1p2 : p1 ‚â† p2) (hp3p2 : p3 ‚â† p2) : has_dist.dist p1 p3 = has_dist.dist p1 p2 + has_dist.dist p3 p2 ‚Üî euclidean_geometry.angle p1 p2 p3 = real.pi
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (Y Y' : C) [category_theory.exact_pairing Y Y'] : category_theory.monoidal_category.tensor_left Y' ‚ä£ category_theory.monoidal_category.tensor_left Y
(R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R
{Œ± : Type u_1} [emetric_space Œ±] : emetric_space Œ±·µê·µí·µñ
{J : Type v} [category_theory.small_category J] {F : J ‚•§ category_theory.Cat} (X : category_theory.limits.limit (F ‚ãô category_theory.Cat.objects)) (Y : category_theory.limits.limit (F ‚ãô category_theory.Cat.objects)) : J ‚•§ Type v
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [linear_order Œ≤] {f g : Œ± ‚Üí Œ≤} (hf : antitone f) (hg : antitone g) : antitone (Œª (x : Œ±), linear_order.max (f x) (g x))
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) (i : E ‚âÉL[ùïú] F) (h : p 1 = ‚áë((continuous_multilinear_curry_fin1 ùïú E F).symm) ‚Üëi) : p.left_inv i = p.right_inv i
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [mul_one_class Œ±] [mul_one_class Œ≤] : has_one (Œ± ‚Üí*o Œ≤)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí. Œ≤) : set Œ≤
 : list expr ‚Üí tactic expr
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_add M] [has_add N] : Type (max u_10 u_11 u_9)
{M : Type u} [monoid M] (F : Type v) [field F] [mul_semiring_action M F] (m : M) : subfield F
{Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ±} (hf : function.injective f) (hg : function.injective g) : ‚àÉ (h : Œ± ‚Üí Œ≤), function.bijective h
 : expr ‚Üí tactic.instance_cache ‚Üí list expr ‚Üí tactic (tactic.instance_cache √ó list expr)
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] {a b : Œ±} (ha : a ‚â§ 1) (hb : b ‚â§ 1) : a * b ‚â§ 1
{G : Type u_1} [group G] (H : subgroup G) : Prop
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] : galois_insertion (intermediate_field.adjoin F) coe
{Œ± : Type u_1} (p q : Œ± ‚Üí Prop) [decidable_pred p] (h : disjoint p q) : {x // p x ‚à® q x} ‚âÉ {x // p x} ‚äï {x // q x}
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (F : C ‚Üí D) [category_theory.functorial F] (G : D ‚Üí E) [category_theory.functorial G] : category_theory.functorial (G ‚àò F)
 : (user_attribute simp_lemmas)
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] (s t : submodule K V) [finite_dimensional K ‚Ü•s] [finite_dimensional K ‚Ü•t] : finite_dimensional.finrank K ‚Ü•(s ‚äî t) + finite_dimensional.finrank K ‚Ü•(s ‚äì t) = finite_dimensional.finrank K ‚Ü•s + finite_dimensional.finrank K ‚Ü•t
{J : Type v} {C : Type u} [category_theory.category C] (B : C) (F : category_theory.discrete J ‚•§ category_theory.over B) : category_theory.limits.cone (category_theory.over.construct_products.wide_pullback_diagram_of_diagram_over B F) ‚âå category_theory.limits.cone F
{Œ± : Type v} {d u l r : ‚Ñï} (A : matrix (fin (u + d)) (fin (l + r)) Œ±) : matrix (fin u) (fin r) Œ±
{M : Type u_1} [add_left_cancel_monoid M] [fintype M] (S : set M) (hS1 : S.nonempty) (hS2 : S + S = S) : add_submonoid M
{R : Type u_1} [cancel_comm_monoid_with_zero R] {Œ± : Type u_2} [decidable_eq Œ±] {x y a : R} {s : finset Œ±} {p : Œ± ‚Üí R} (hp : ‚àÄ (i : Œ±), i ‚àà s ‚Üí prime (p i)) (hx : x * y = a * s.prod (Œª (i : Œ±), p i)) : ‚àÉ (t u : finset Œ±) (b c : R), t ‚à™ u = s ‚àß disjoint t u ‚àß a = b * c ‚àß x = b * t.prod (Œª (i : Œ±), p i) ‚àß y = c * u.prod (Œª (i : Œ±), p i)
{G : Type w} [topological_space G] [add_group G] [topological_add_group G] {K V : set G} (hK : is_compact K) (hV : (interior V).nonempty) : ‚àÉ (t : finset G), K ‚äÜ ‚ãÉ (g : G) (H : g ‚àà t), (Œª (h : G), g + h) ‚Åª¬π' V
(a b : tactic.ring_exp.atom) : bool
(iffmp : name) : expr ‚Üí (‚Ñï ‚Üí expr) ‚Üí option expr
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (f : M ‚Üí+ P) : (add_con.ker f).quotient ‚Üí+ P
{Œ± : Type u_3} {Œ≤ : Type u_4} [has_sup Œ±] [has_sup Œ≤] : sup_hom Œ± Œ≤ ‚âÉ inf_hom Œ±·µí·µà Œ≤·µí·µà
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_mul Œ±] [has_mul Œ≤] : Œ±·µê·µí·µñ ‚âÉ* Œ≤·µê·µí·µñ ‚âÉ (Œ± ‚âÉ* Œ≤)
{Œ± : Type u_1} (s : set Œ±) : local_equiv Œ± Œ±
(hs : list expr) : tactic (list (list expr))
{R : Type u_1} {M : Type u_3} {M' : Type u_4} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [has_zero M'] [has_scalar R M'] (f : zero_hom M' M) (hf : function.injective ‚áëf) (smul : ‚àÄ (a : R) (b : M'), ‚áëf (a ‚Ä¢ b) = a ‚Ä¢ ‚áëf b) : mul_action_with_zero R M'
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] (e : topological_fiber_bundle.trivialization F proj) {Z' : Type u_1} [topological_space Z'] (h : Z' ‚âÉ‚Çú Z) : topological_fiber_bundle.trivialization F (proj ‚àò ‚áëh)
{Œ± : Type u_2} {Œ≤ : Type u_3} [non_assoc_semiring Œ±] [preorder Œ±] [non_assoc_semiring Œ≤] [preorder Œ≤] (f : Œ± ‚Üí+*o Œ≤) : Œ± ‚Üí+o Œ≤
{p n k b : ‚Ñï} (hp : nat.prime p) (hkn : k ‚â§ n) (hnb : nat.log p n < b) : multiplicity p (n.choose k) = ‚Üë((finset.filter (Œª (i : ‚Ñï), p ^ i ‚â§ k % p ^ i + (n - k) % p ^ i) (finset.Ico 1 b)).card)
{Œπ : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type u_3} [add_comm_group M] [module R M] [fintype Œπ] {s : Œπ ‚Üí M} (hs : submodule.span R (set.range s) = ‚ä§) [no_zero_smul_divisors R M] : Œ£ (n : ‚Ñï), basis (fin n) R M
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type v} (f : J ‚Üí C) {P : C} (g : Œ† (j : J), f j ‚ü∂ P) : category_theory.limits.is_colimit (G.map_cocone (category_theory.limits.cofan.mk P g)) ‚âÉ category_theory.limits.is_colimit (category_theory.limits.cofan.mk (G.obj P) (Œª (j : J), G.map (g j)))
{A : Type u_2} [add_monoid A] (s : set A) : A ‚Üí Prop
{M : Type u_1} [has_mul M] {s : set M} {S : subsemigroup M} : subsemigroup.closure s ‚â§ S ‚Üî s ‚äÜ ‚ÜëS
{G : Type u_1} [group G] {N : Type u_2} [group N] (f : G ‚Üí* N) (H : subgroup N) : subgroup G
{Œ≤ : Type u} {Œ± : Type v} {s : finset Œ±} {f : Œ± ‚Üí Œ≤} [comm_monoid Œ≤] (R : setoid Œ±) [decidable_rel setoid.r] (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí (finset.filter (Œª (y : Œ±), y ‚âà x) s).prod (Œª (a : Œ±), f a) = 1) : s.prod (Œª (x : Œ±), f x) = 1
{Œ± : Type u_1} {r : setoid Œ±} {x : Œ±} {b : set Œ±} (hc : b ‚àà r.classes) (hb : x ‚àà b) {b' : set Œ±} (hc' : b' ‚àà r.classes) (hb' : x ‚àà b') : b = b'
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {X Y : C} [category_theory.has_left_dual X] [category_theory.has_left_dual Y] (f : X ‚ü∂ Y) : ·òÅY ‚ü∂ ·òÅX
{Œ± : Type u_1} [uniform_space Œ±] (pkg pkg' : abstract_completion Œ±) : pkg.space ‚Üí pkg'.space
{Œ± : Sort u_1} {a a' : Œ±} {Œ≤ : Sort u_2} (y : Œ≤) (h : a = a') : eq.rec y h = y
 : cardinal ‚Ü™o ordinal
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ : X} (p : path x‚ÇÄ x‚ÇÅ) (f : ‚Ü•unit_interval ‚Üí ‚Ü•unit_interval) (hf : continuous f) (hf‚ÇÄ : f 0 = 0) (hf‚ÇÅ : f 1 = 1) : p.homotopy (p.reparam f hf hf‚ÇÄ hf‚ÇÅ)
{Œ± : Type u} {L‚ÇÅ L‚ÇÇ : list (Œ± √ó bool)} : free_group.red.step L‚ÇÅ L‚ÇÇ ‚Üí L‚ÇÇ.length + 2 = L‚ÇÅ.length
(Œ± : Type u_1) [partial_order Œ±] [order_top Œ±] : Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) (x : E) (L : filter E) : Prop
{Œ± : Type u_1} {Œπ : Type u_3} {m : measurable_space Œ±} [preorder Œπ] {f : measure_theory.filtration Œπ m} {œÑ : Œ± ‚Üí Œπ} (hœÑ : measure_theory.is_stopping_time f œÑ) : measurable_space Œ±
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [module ùïú E] [has_scalar ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : concave_on ùïú s f) (c : E) : concave_on ùïú ((Œª (z : E), c + z) ‚Åª¬π' s) (f ‚àò Œª (z : E), c + z)
(C : Type u_1) [category_theory.category C] : Type
{ùïú : Type u_1} {E : Type u_3} {F : Type u_4} [ordered_ring ùïú] [topological_space E] [topological_space F] [add_comm_group E] [add_comm_group F] [module ùïú E] [module ùïú F] {s : set F} (hs : strict_convex ùïú s) {f : E ‚Üí·µÉ[ùïú] F} (hf : continuous ‚áëf) (hfinj : function.injective ‚áëf) : strict_convex ùïú (‚áëf ‚Åª¬π' s)
{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ‚â† 0) : char.quadratic_char F a = 1 ‚à® char.quadratic_char F a = -1
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Ring) : SemiRing
{n : ‚Ñï} {Œ± : fin n ‚Üí Type u} [Œ† (i : fin n), decidable_eq (Œ± i)] (a b : d_array n Œ±) : bool
{Œ± : Type u} : lazy_list Œ± ‚Üí list Œ±
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] : orthogonal_projection ‚ä• = 0
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (f : M ‚Üí‚Çô* N) (S : subsemigroup M) : subsemigroup N
{Œ± : Type u_1} [complete_lattice Œ±] : Inf_hom Œ± (lower_set Œ±)
{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) ‚Üî is_left_regular b
 : expr ‚Üí tactic (expr √ó expr)
{E : ‚Ñï ‚Üí Type u_1} (x : Œ† (n : ‚Ñï), E n) (n : ‚Ñï) : set (Œ† (n : ‚Ñï), E n)
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b c : Œ±} : a * b ‚â§ c ‚Üí b ‚â§ a‚Åª¬π * c
(hs : list expr) (ns : name_set) : tactic (list bool)
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] {i : D.to_glue_data.J} (U : topological_space.opens ‚Ü•((D.to_glue_data.U i).carrier)) : (category_theory.limits.walking_multispan D.to_glue_data.diagram.fst_from D.to_glue_data.diagram.snd_from)·µí·µñ ‚•§ C
(x y : ‚Ñï) : ‚Üë(x.gcd y) = ‚Üëx * x.gcd_a y + ‚Üëy * x.gcd_b y
(ùïú : Type u_1) {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_3} [linear_order Œπ] [order_bot Œπ] [locally_finite_order Œπ] [is_well_order Œπ has_lt.lt] (f : Œπ ‚Üí E) {a b : Œπ} (h‚ÇÄ : a ‚â† b) : has_inner.inner (gram_schmidt ùïú f a) (gram_schmidt ùïú f b) = 0
(n : ‚Ñï) : bitvec n
{R : Type u_1} {A : Type u_2} [monoid A] [has_scalar R A] [smul_comm_class R A A] [topological_space A] [has_continuous_mul A] : has_continuous_const_smul R A
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type w} [category_theory.category J] [category_theory.limits.preserves_colimits_of_shape J G] [category_theory.limits.has_colimits_of_shape J D] [category_theory.limits.has_colimits_of_shape J C] : category_theory.limits.colim ‚ãô G ‚âÖ (category_theory.whiskering_right J C D).obj G ‚ãô category_theory.limits.colim
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s‚ÇÅ s‚ÇÇ : set P} (h : s‚ÇÅ ‚äÜ s‚ÇÇ) : vector_span k s‚ÇÅ ‚â§ vector_span k s‚ÇÇ
{R : Type u_1} {M : Type u_2} {N : Type u_3} {Œπ : Type u_4} {Œ∫ : Type u_5} [decidable_eq Œπ] [decidable_eq Œ∫] [fintype Œπ] [fintype Œ∫] [comm_ring R] [add_comm_group M] [add_comm_group N] [module R M] [module R N] (b : basis Œπ R M) (c : basis Œ∫ R N) : tensor_product R (module.dual R M) (module.dual R N) ‚âÉ‚Çó[R] module.dual R (tensor_product R M N)
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : free_add_magma Œ± ‚Üí free_add_magma Œ≤
(k : ‚Ñï) : nat.arithmetic_function ‚Ñï
(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : add_valuation R enat
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M ‚Üí* P} (hg : ‚àÄ (y : ‚Ü•S), is_unit (‚áëg ‚Üëy)) (z : N) : ‚áë(f.lift hg) z * ‚áëg ‚Üë((f.sec z).snd) = ‚áëg (f.sec z).fst
{Œ± : Type u_1} {Œ≤ : Type u_2} (s : finset Œ±) (t : finset Œ≤) : finset (Œ± ‚äï Œ≤)
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
(Œ± : Type u) : Type u
{a b : ereal} (h : -a ‚â§ b) : -b ‚â§ a
{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s ‚Üî is_closed s
 : list expr ‚Üí expr
(ic : tactic.instance_cache) (a b : expr) (na nb : ‚Ñö) : tactic (tactic.instance_cache √ó expr √ó expr)
{R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) [invertible A] : (‚Öü A).mul A = 1
(R : Type u) {S : Type v} {A : Type w} {B : Type u‚ÇÅ} [comm_semiring R] [comm_semiring S] [semiring A] [semiring B] [algebra R S] [algebra S A] [algebra S B] [algebra R A] [algebra R B] [is_scalar_tower R S A] [is_scalar_tower R S B] (f : A ‚Üí‚Çê[S] B) : A ‚Üí‚Çê[R] B
(n : ‚Ñï) : composition n
{d : ‚Ñ§} (n : ‚Ñ§) : ‚Ñ§‚àöd
{C : Type u} [category_theory.category C] [‚àÄ (n : ‚Ñï) (f : category_theory.arrow C), category_theory.limits.has_wide_pullback f.right (Œª (i : ulift (fin (n + 1))), f.left) (Œª (i : ulift (fin (n + 1))), f.hom)] : category_theory.simplicial_object.augmented.to_arrow ‚ä£ category_theory.simplicial_object.augmented_cech_nerve
{K : Type u} [field K] (s : subfield K) {Œπ : Type u_1} {t : finset Œπ} {f : Œπ ‚Üí K} (h : ‚àÄ (c : Œπ), c ‚àà t ‚Üí f c ‚àà s) : t.prod (Œª (i : Œπ), f i) ‚àà s
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ AddGroup AddMon)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : C(Œ±, Œ≤)) {x y : Œ±} (h : x = y) : ‚áëf x = ‚áëf y
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) : category_theory.limits.is_colimit (Mon.colimits.colimit_cocone F)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] : category_theory.limits.kernel_fork category_theory.limits.biprod.fst
{E : Type u_3} [semi_normed_group E] {r : ‚Ñù} : has_neg ‚Ü•(metric.sphere 0 r)
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} (f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ) : submodule R M
{R : Type v} [ring R] {Œπ : Type u_1} {c : complex_shape Œπ} {C : homological_complex (Module R) c} {i : Œπ} (x : ‚Ü•(linear_map.ker (C.d_from i))) : ‚Ü•(C.cycles i)
(R : Type u) (A : Type v) (B : Type w) [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B] : B ‚Üí‚Çô‚Çê[R] A √ó B
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.pos_mul_strict_mono Œ±] (ha : 1 ‚â§ a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
(M : Type u_1) (Œ± : Type u_2) [has_vadd M Œ±] [measurable_space M] [measurable_space Œ±] : Prop
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ùïú] [inner_product_space ùïú E] [inner_product_space ùïú F] [complete_space E] [complete_space F] (A : E ‚ÜíL[ùïú] F) (x : E) (y : F) : has_inner.inner (‚áë(‚áëcontinuous_linear_map.adjoint A) y) x = has_inner.inner y (‚áëA x)
 : Type
{Œ± : fin 0 ‚Üí Type u_1} : d_array 0 Œ±
 : environment ‚Üí list name
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type w} {b : finset Œπ} (h : basis ‚Ü•b K V) : finite_dimensional.finrank K V = b.card
{n n' : ‚Ñï} (m : ‚Ñï) (i : fin n') (h : n' = n) : ‚áë(fin.nat_add m) (‚áë(fin.cast h) i) = ‚áë(fin.cast _) (‚áë(fin.nat_add m) i)
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} (p : submodule R‚ÇÇ M‚ÇÇ) (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (h : ‚àÄ (c : M), ‚áëf c ‚àà p) : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] ‚Ü•p
{M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] (f : M ‚Üí* N) {x y : M} (h : x = y) : ‚áëf x = ‚áëf y
{Œ± : Type u} (P : Œ± ‚Üí Prop) [decidable_pred P] : list Œ± ‚Üí (list Œ± ‚Üí list Œ±) ‚Üí list (list Œ±)
(Œ± : Type u_1) {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [semiring Œ≤] [topological_semiring Œ≤] [topological_space Œ≥] [semiring Œ≥] [topological_semiring Œ≥] (g : Œ≤ ‚Üí+* Œ≥) (hg : continuous ‚áëg) : C(Œ±, Œ≤) ‚Üí+* C(Œ±, Œ≥)
{Œ± : Type u_1} [measurable_space Œ±] {f : ‚Ñï ‚Üí Œ± ‚Üí nnreal} {g : Œ± ‚Üí nnreal} (hf : ‚àÄ (i : ‚Ñï), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
(Œ± : Type u_1) : Type u_1
{Œ± : Type u} [ring Œ±] [no_zero_divisors Œ±] : cancel_monoid_with_zero Œ±
{x : pgame} : x.lf 0 ‚Üî ‚àÉ (j : x.right_moves), x.move_right j ‚â§ 0
{Œ± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : Œ± ‚Üí F} {f' : Œ± ‚Üí E'} {l : filter Œ±} : f' =O[l] g ‚Üí (Œª (x : Œ±), -f' x) =O[l] g
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {E : Type u‚ÇÉ} [‚Ñ∞ : category_theory.category E] (F : C ‚•§ D) (G : D ‚•§ E) [category_theory.limits.preserves_colimit K (F ‚ãô G)] [category_theory.limits.reflects_colimit (K ‚ãô F) G] : category_theory.limits.preserves_colimit K F
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} : monotone f ‚Üí antitone (f ‚àò ‚áëorder_dual.of_dual)
(ùïÇ : Type u_1) (ùî∏ : Type u_2) [is_R_or_C ùïÇ] [normed_ring ùî∏] [normed_algebra ùïÇ ùî∏] : (exp_series ùïÇ ùî∏).radius = ‚ä§
{k : Type u} [comm_ring k] {G : Group} (X Y : Rep k ‚Ü•G) : ‚Ü•((representation.lin_hom X.œÅ Y.œÅ).invariants) ‚âÉ‚Çó[k] X ‚ü∂ Y
{K : Type u} {L : Type v} [field K] [field L] {f g : K ‚Üí+* L} {s : set K} (h : set.eq_on ‚áëf ‚áëg s) : set.eq_on ‚áëf ‚áëg ‚Üë(subfield.closure s)
{R : Type u_1} {M : Type u_5} [comm_semiring R] [add_comm_monoid M] [module R M] (B F : M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R) (f : module.End R M) : Prop
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s‚ÇÅ s‚ÇÇ : affine_subspace k P} {p : P} (h‚ÇÅ : p ‚àà s‚ÇÅ) (h‚ÇÇ : p ‚àà s‚ÇÇ) : s‚ÇÅ = s‚ÇÇ ‚Üî s‚ÇÅ.direction = s‚ÇÇ.direction
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {n : ‚Ñï} (hn : finite_dimensional.finrank K V = n) : basis (fin n) K V
{Œ± : Type u_1} {Œ≤ : Type u_2} [monoid Œ≤] (s : finset Œ±) (f : Œ± ‚Üí Œ≤) (comm : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí commute (f x) (f y)) : Œ≤
{R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ‚â† 0) (no_factors : ‚àÄ {d : R}, d ‚à£ a ‚Üí d ‚à£ b ‚Üí ¬¨prime d) : a ‚à£ b * c ‚Üí a ‚à£ c
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type w} [category_theory.category J] {K : J ‚•§ C} (c : category_theory.limits.cone (K ‚ãô ùü≠ C)) : category_theory.liftable_cone K (ùü≠ C) c
{X Y : AddGroup} (e : ‚Ü•X ‚âÉ+ ‚Ü•Y) : X ‚âÖ Y
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s : set P} [nontrivial P] : affine_span k s = ‚ä§ ‚Üî vector_span k s = ‚ä§
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} (hJ : category_theory.sheaf.subcanonical J) (P : C·µí·µñ ‚•§ Type v) [P.representable] : category_theory.presieve.is_sheaf J P
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : dense s ‚Üî ‚àÄ (U : set Œ±), is_open U ‚Üí U.nonempty ‚Üí (U ‚à© s).nonempty
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} (H : C ‚•§ D) {E : K ‚•§ J} {c : category_theory.limits.cone F} : H.map_cone (category_theory.limits.cone.whisker E c) ‚âÖ category_theory.limits.cone.whisker E (H.map_cone c)
{Œ± : Type u_2} {Œ≤ : Type u_3} [decidable_eq Œ≤] [has_vadd Œ± Œ≤] {u : finset Œ≤} {s : set Œ±} {t : set Œ≤} : ‚Üëu ‚äÜ s +·µ• t ‚Üí (‚àÉ (s' : finset Œ±) (t' : finset Œ≤), ‚Üës' ‚äÜ s ‚àß ‚Üët' ‚äÜ t ‚àß u ‚äÜ s' +·µ• t')
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.pos_mul_mono Œ±] (ha : 1 < a) (hb : 1 ‚â§ b) (a0 : 0 < a) : 1 < a * b
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] (f : A ‚Üí‚Çó[R] B) (map_one : ‚áëf 1 = 1) (map_mul : ‚àÄ (x y : A), ‚áëf (x * y) = ‚áëf x * ‚áëf y) : A ‚Üí‚Çê[R] B
(R : Type u) (Œπ : Type u') {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [comm_semiring R] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] [fintype Œπ] (z : M‚ÇÇ) : multilinear_map R (Œª (i : Œπ), R) M‚ÇÇ
{Œ± : Type u} [primcodable Œ±] [inhabited Œ±] (p : set Œ±) : set ‚Ñï
{Œ± : Type u_1} [fintype Œ±] : finset Œ±
{Œ± : Type u} {Œ≤ : Type u_1} [topological_space Œ±] [topological_space Œ≤] [topological_space.second_countable_topology Œ±] [topological_space.second_countable_topology Œ≤] : topological_space.second_countable_topology (Œ± ‚äï Œ≤)
{Œ± : Type u_1} [preorder Œ±] [decidable_rel has_le.le] (x : Œ±) (s : ordset Œ±) : ordset Œ±
(œÅ œÅ' : out_param (Type u)) (m m' : Type u ‚Üí Type v) : Type (max (u+1) v)
 : Type
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {s t : set Œ±} (hst : s ‚äÜ t) (ht : (t ‚à© function.support f).finite) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)) + finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà t  s), f i)) = finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà t), f i))
{Œ± : Type u_1} [ordered_add_comm_monoid Œ±] : {x // 0 ‚â§ x} ‚Üí+ Œ±
(Œ± : Type u_4) : Type u_4
{H : Type u} [topological_space H] : closed_under_restriction (continuous_groupoid H)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {v : set E} [finite_dimensional ùïú E] (hv : orthonormal ùïú coe) : ‚àÉ (u : set E) (H : u ‚äá v) (b : basis ‚Ü•u ùïú E), orthonormal ùïú ‚áëb ‚àß ‚áëb = coe
{C : Type u_1} [category_theory.category C] (r : hom_rel C) {D : Type u_3} [category_theory.category D] (F : C ‚•§ D) (H : ‚àÄ (x y : C) (f‚ÇÅ f‚ÇÇ : x ‚ü∂ y), r f‚ÇÅ f‚ÇÇ ‚Üí F.map f‚ÇÅ = F.map f‚ÇÇ) : category_theory.quotient.functor r ‚ãô category_theory.quotient.lift r F H ‚âÖ F
(S : set ‚Ñù) (hS : ‚àÄ (x : ‚Ñù), x ‚àà S ‚Üí x ‚â§ 0) : has_Inf.Inf S ‚â§ 0
(n : ‚Ñï) : finset ‚Ñï
{Œ± Œ≤ : Type u} (f : Type u ‚Üí Type v) [functor f] [is_lawful_functor f] (h : Œ± ‚âÉ Œ≤) : f Œ± ‚âÉ f Œ≤
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] {X Y : C} (f : X ‚ü∂ Y) : opposite.unop (category_theory.limits.cokernel f.op) ‚âÖ category_theory.limits.kernel f
{Œ± : Type u_1} [preorder Œ±] [is_total Œ± has_le.le] [decidable_rel has_le.le] (x : Œ±) (s : ordset Œ±) : ordset Œ±
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K‚ÇÅ K‚ÇÇ : submodule ùïú E} (h : K‚ÇÅ ‚â§ K‚ÇÇ) [complete_space ‚Ü•K‚ÇÅ] : K‚ÇÅ ‚äî K‚ÇÅ·óÆ ‚äì K‚ÇÇ = K‚ÇÇ
(Œ± : Type u) {Œ≤ : Type u} [slim_check.sampleable Œ±] (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) (h : ‚àÄ (a : Œ±), sizeof (g (f a)) ‚â§ sizeof a) : slim_check.sampleable Œ≤
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_binary_biproduct X Y] : X ‚äû Y ‚ü∂ Y
{R : Type u} [comm_ring R] : Module.Mon_Module_equivalence_Algebra.functor ‚ãô category_theory.forget‚ÇÇ (Algebra R) (Module R) ‚âÖ Mon_.forget (Module R)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} {ps : set P} (h : ps ‚äÜ ‚Üës) [nonempty ‚Ü•s] {n : ‚Ñï} [finite_dimensional ‚Ñù ‚Ü•(s.direction)] (hd : finite_dimensional.finrank ‚Ñù ‚Ü•(s.direction) = n) (hc : euclidean_geometry.cospherical ps) {sx‚ÇÅ sx‚ÇÇ : affine.simplex ‚Ñù P n} (hsx‚ÇÅ : set.range sx‚ÇÅ.points ‚äÜ ps) (hsx‚ÇÇ : set.range sx‚ÇÇ.points ‚äÜ ps) : sx‚ÇÅ.circumradius = sx‚ÇÇ.circumradius
(M : Type u_1) (X : Type u_2) [has_scalar M X] [topological_space M] [topological_space X] : Prop
(red : interactive.parse (optional (lean.parser.tk "!"))) (SOP : interactive.parse tactic.interactive.ring.mode) (loc : interactive.parse interactive.types.location) : tactic unit
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (L' : lie_subalgebra R L) {M : Type w} [add_comm_group M] [lie_ring_module L M] [module R M] [lie_module R L M] : lie_module R ‚Ü•L' M
{V : Type (u+1)} [category_theory.large_category V] {G : Mon} {M N K : Action V G} (p : M.hom N) (q : N.hom K) : M.hom K
{M : Type u_1} {A : Type u_5} [has_add M] [set_like A M] [hA : add_mem_class A M] (S' : A) : has_add ‚Ü•S'
(S : Type u_1) (R : out_param (Type u)) [ring R] [set_like S R] : Type
(F : Type u_17) (M : out_param (Type u_18)) (X : out_param (Type u_19)) (Y : out_param (Type u_20)) [has_scalar M X] [has_scalar M Y] : Type (max u_17 u_19 u_20)
{M : Type u_1} [has_add M] : has_coe_to_fun (add_con M) (Œª (_x : add_con M), M ‚Üí M ‚Üí Prop)
{Œ± : Sort u} {Œ≤ : Sort v} {Œ≥ : Sort w} {g : Œ≤ ‚Üí Œ≥} (hg : function.surjective g) : function.surjective (function.comp g)
{Œ± : Type u_1} [topological_space Œ±] {R : Type u_2} [comm_semiring R] {A : Type u_3} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] : subalgebra R (Œ± ‚Üí A)
(C : Type u) [category_theory.category C] : Prop
{G : Type u_1} [group G] (H : subgroup G) : subgroup G
(Œ± : Type u_1) (n : ‚Ñï) : Type u_1
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {f' : F} {x : ùïú} [partial_order ùïú] : has_deriv_within_at f f' (set.Ici x) x ‚Üí has_deriv_within_at f f' (set.Ioi x) x
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] : euclidean_geometry.cospherical ‚àÖ
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_object C] {B : C} : ‚Üë‚ä• ‚âÖ 0
{Œ± : Type u} [group_with_zero Œ±] (a b : Œ±) [invertible a] [invertible b] : invertible (a / b)
{Œ± : Type u} [semilattice_inf Œ±] [order_bot Œ±] (a b : Œ±) : Prop
(eb : expr) (b : ‚Ñï) : expr ‚Üí ‚Ñï ‚Üí tactic.instance_cache ‚Üí tactic (tactic.instance_cache √ó expr √ó expr)
{Œ± : Type v} [linear_order Œ±] {x‚ÇÅ x‚ÇÇ y‚ÇÅ y‚ÇÇ : Œ±} (h : disjoint (set.Ico x‚ÇÅ x‚ÇÇ) (set.Ico y‚ÇÅ y‚ÇÇ)) (hx : x‚ÇÅ < x‚ÇÇ) (h2 : x‚ÇÇ ‚àà set.Ico y‚ÇÅ y‚ÇÇ) : y‚ÇÅ = x‚ÇÇ
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [has_zero M‚ÇÅ] [has_scalar ‚Ñï M‚ÇÅ] [add_cancel_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : add_cancel_monoid M‚ÇÅ
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} [category_theory.limits.has_zero_object V] : homological_complex V c
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {x‚ÇÄ x‚ÇÅ : X} (P‚ÇÄ : path.homotopic.quotient x‚ÇÄ x‚ÇÅ) (f : C(X, Y)) : path.homotopic.quotient (‚áëf x‚ÇÄ) (‚áëf x‚ÇÅ)
{R : Type u_1} [comm_ring R] [is_domain R] : (ideal.span {power_series.X}).is_prime
 : nat.arithmetic_function ‚Ñù
{F : Type u_1} [field F] (p : polynomial F) (E : Type u_2) [field E] [algebra F E] [fact (polynomial.splits (algebra_map F E) p)] : function.injective ‚áë(polynomial.gal.gal_action_hom p E)
{L : first_order.language} (Œ∫ : cardinal) (T : L.Theory) : Prop
 : CommMon_ (Type u) ‚•§ CommMon
(a b c : ‚Ñ§) : Prop
{Œ± : Sort u‚ÇÅ} {Œ≤ : Sort u‚ÇÇ} (f : Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u_1} [measurable_space Œ±] (s : measure_theory.signed_measure Œ±) : s.to_jordan_decomposition.to_signed_measure = s
 : tactic.instance_cache ‚Üí expr ‚Üí expr ‚Üí ‚Ñö ‚Üí ‚Ñï ‚Üí tactic (tactic.instance_cache √ó expr √ó expr)
{Œ≤ : Type u_2} [topological_space Œ≤] {Œ∫ : Type u_5} (f : Œ∫ ‚Üí Œ≤) : Prop
{M : Type u_1} [has_add M] {c d : add_con M} (h : c = d) : c.quotient ‚âÉ+ d.quotient
(C : Type u) [category_theory.category C] [‚àÄ {X Y : C} {f g : X ‚ü∂ Y}, category_theory.limits.has_colimit (category_theory.limits.parallel_pair f g)] : category_theory.limits.has_coequalizers C
 : expr ‚Üí list expr
{Œ± : Type u} {C : with_zero Œ± ‚Üí Sort u_1} (h‚ÇÅ : C 0) (h‚ÇÇ : Œ† (a : Œ±), C ‚Üëa) (n : with_zero Œ±) : C n
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} {Œ≤‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {Œ≤‚ÇÇ : Œπ ‚Üí Type v‚ÇÇ} [Œ† (i : Œπ), has_zero (Œ≤ i)] [Œ† (i : Œπ), has_zero (Œ≤‚ÇÅ i)] [Œ† (i : Œπ), has_zero (Œ≤‚ÇÇ i)] (f : Œ† (i : Œπ), Œ≤‚ÇÅ i ‚Üí Œ≤‚ÇÇ i ‚Üí Œ≤ i) (hf : ‚àÄ (i : Œπ), f i 0 0 = 0) : (Œ†‚ÇÄ (i : Œπ), Œ≤‚ÇÅ i) ‚Üí (Œ†‚ÇÄ (i : Œπ), Œ≤‚ÇÇ i) ‚Üí (Œ†‚ÇÄ (i : Œπ), Œ≤ i)
(M : Type u_1) [add_monoid M] : add_submonoid M
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p ‚àà s) (p2 : P) : p2 -·µ• p ‚àà s.direction ‚Üî p2 ‚àà s
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] : conditionally_complete_lattice (with_bot Œ±)
(h : expr) : tactic name_set
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [has_zero Œ≤] : has_zero Œ±
{Œ≤ : Type w} {C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) (f : Œ≤ ‚Üí C) [category_theory.limits.has_coproduct f] [category_theory.limits.has_coproduct (Œª (b : Œ≤), G.obj (f b))] : (‚àê Œª (b : Œ≤), G.obj (f b)) ‚ü∂ G.obj (‚àê f)
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí. Œ≤ ‚äï Œ±} {b : Œ≤} {C : Œ± ‚Üí Sort u_3} {a : Œ±} (h : b ‚àà f.fix a) (H : Œ† (a' : Œ±), b ‚àà f.fix a' ‚Üí (Œ† (a'' : Œ±), sum.inr a'' ‚àà f a' ‚Üí C a'') ‚Üí C a') : C a
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} {R‚ÇÉ : Type u_3} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [semiring R‚ÇÉ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÉ‚ÇÇ : R‚ÇÉ ‚Üí+* R‚ÇÇ} [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÉ‚ÇÇ] [ring_hom_inv_pair œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÇ‚ÇÉ] {œÉ‚ÇÅ‚ÇÉ : R‚ÇÅ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÉ‚ÇÅ : R‚ÇÉ ‚Üí+* R‚ÇÅ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÉ œÉ‚ÇÉ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÉ‚ÇÅ œÉ‚ÇÅ‚ÇÉ] [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] [ring_hom_comp_triple œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÉ‚ÇÅ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] {M‚ÇÉ : Type u_7} [topological_space M‚ÇÉ] [add_comm_monoid M‚ÇÉ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] [module R‚ÇÉ M‚ÇÉ] (e‚ÇÅ : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (e‚ÇÇ : M‚ÇÇ ‚âÉSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ
{Œ± : Type u} {Œ≤ : Type v} : wseq Œ± ‚Üí wseq Œ≤ ‚Üí wseq (Œ± √ó Œ≤)
{ùïú : Type u_3} [field ùïú] {r : ‚Ñï} (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) (hM : M (sum.inr ()) (sum.inr ()) ‚â† 0) (i : fin r) : (matrix.pivot.list_transvec_col M).prod.mul M (sum.inl i) (sum.inr ()) = 0
(G : Type u_1) [measurable_space G] [has_involutive_inv G] [has_measurable_inv G] : G ‚âÉ·µê G
{Œ± : Type u_1} [semilattice_sup Œ±] : sup_hom Œ± (upper_set Œ±)·µí·µà
(D : Top.glue_data) (a b : Œ£ (i : D.to_glue_data.J), ‚Ü•(D.to_glue_data.U i)) : Prop
{X Y : Type u} [add_monoid X] [add_monoid Y] (f : X ‚Üí+ Y) : AddMon.of X ‚ü∂ AddMon.of Y
{Œπ : Type u_1} (M : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), monoid (M i)] : Œπ ‚Üí Œπ ‚Üí Type (max u_1 u_2)
(R : Type u) [semiring R] {m : Type u_1} {n : Type u_2} [fintype m] [fintype n] : module.free R (matrix m n R)
{Œ± : Sort u_1} {Œ≤ : Œ± ‚Üí Sort u_2} {Œ≥ : Sort u_3} (f : Œ† (a : Œ±), Œ≤ a ‚Üí Œ≥) (a : psigma Œ≤) : Œ≥
(Œ± : Type u) : Type u
(patts : list tactic.rcases_patt) : tactic (list tactic.rcases_patt)
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [add_comm_semigroup M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) : add_comm_semigroup M‚ÇÅ
{p n : ‚Ñï} (h : 2 * n < p) : ‚áë(n.central_binom.factorization) p = 0
{G : Type u} [group G] (a x : G) : semiconj_by a x (a * x * a‚Åª¬π)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {s : set ‚Ñù} {e : E} {a : ‚Ñù} {f : ‚Ñù ‚Üí E} (f_diff : differentiable_on ‚Ñù f s) (f_lim : continuous_within_at f s a) (hs : s ‚àà nhds_within a (set.Iio a)) (f_lim' : filter.tendsto (Œª (x : ‚Ñù), deriv f x) (nhds_within a (set.Iio a)) (nhds e)) : has_deriv_within_at f e (set.Iic a) a
{l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {Œ± : Type v} (A : matrix m n Œ±) (r_reindex : l ‚Üí m) (c_reindex : o ‚Üí n) : matrix l o Œ±
{K : Type v} (L : Type w) [field K] [field L] [algebra K L] (f : polynomial K) [polynomial.is_splitting_field K L f] : L ‚âÉ‚Çê[K] f.splitting_field
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_4} {Œ≥ : Œ† (a : Œ±), Œ≤ a ‚Üí Type u_2} (f : Œ† (x : sigma Œ≤), Œ≥ x.fst x.snd) (x : Œ±) (y : Œ≤ x) : Œ≥ x y
{M : Type u} [monoid M] {N : Type u} [monoid N] (F : M ‚Üí* N) : category_theory.monoidal_functor (category_theory.discrete M) (category_theory.discrete N)
{Œ± : Type u} {Œ≤ : Type v} (f : ulift (Œ± ‚Üí Œ≤)) (x : ulift Œ±) : ulift Œ≤
{R : Type u_1} [semiring R] (f : laurent_polynomial R) {Q : laurent_polynomial R ‚Üí Prop} (Qf : ‚àÄ (f : polynomial R), Q (‚áëpolynomial.to_laurent f)) (QT : ‚àÄ (f : laurent_polynomial R), Q (f * laurent_polynomial.T 1) ‚Üí Q f) : Q f
(Œ± : Type u_3) : Type u_3
{k : Type u_2} {V1 : Type u_3} {P1 : Type u_4} [comm_ring k] [add_comm_group V1] [add_torsor V1 P1] [module k V1] (c : P1) : k ‚Üí* P1 ‚Üí·µÉ[k] P1
(Œ± : Type u) (lt : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (œÅ : representation k G V) [fintype G] [invertible ‚Üë(fintype.card G)] (v : V) (hv : v ‚àà œÅ.invariants) : ‚áë(œÅ.average_map) v = v
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Group) : Group
(Œì : Type u_1) (R : Type u_2) [semiring R] [ordered_semiring Œì] [nontrivial Œì] : power_series R ‚Üí+* hahn_series Œì R
(Œì : Type u_1) (T : Type u_2) [topological_space T] [has_scalar Œì T] : Prop
{C : Type u_1} [category_theory.category C] (X : C) : Prop
(R : Type u_1) (M : Type u_3) [monoid_with_zero R] [has_zero M] : Type (max u_1 u_3)
 : Type (u_1+1)
{G : Type u_3} [group G] (P : subgroup G) : P.fg ‚Üî P.to_submonoid.fg
{Œ± : Type u} : rbnode Œ± ‚Üí tree Œ±
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : submodule R A·µê·µí·µñ ‚âÉ+* (submodule R A)·µê·µí·µñ
 : cc_state ‚Üí expr ‚Üí ‚Ñï
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) (X Y : C) [category_theory.limits.has_binary_product X Y] [category_theory.limits.has_binary_product (G.obj X) (G.obj Y)] [i : category_theory.is_iso (category_theory.limits.prod_comparison G X Y)] : category_theory.limits.preserves_limit (category_theory.limits.pair X Y) G
{R : Type u_1} [comm_ring R] : (fin 3 ‚Üí R) ‚Üí‚Çó[R] (fin 3 ‚Üí R) ‚Üí‚Çó[R] fin 3 ‚Üí R
{ùïú : Type u_1} {E : Type u_2} [ordered_ring ùïú] [add_comm_group E] [module ùïú E] {K : geometry.simplicial_complex ùïú E} {s t : finset E} (hs : s ‚àà K.faces) (ht : t ‚àà K.faces) : ‚áë(convex_hull ùïú) ‚Üës ‚äÜ ‚áë(convex_hull ùïú) ‚Üët ‚Üî s ‚äÜ t
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {p q : subspace K V} (f : (V ‚ß∏ p) ‚âÉ‚Çó[K] ‚Ü•q) : (V ‚ß∏ q) ‚âÉ‚Çó[K] ‚Ü•p
{Œ± : Type u_2} {Œ≤ : Type u_3} [add_monoid Œ±] [add_action Œ± Œ≤] : add_action (filter Œ±) (filter Œ≤)
{J : Type u‚ÇÅ} [category_theory.category J] [category_theory.is_preconnected J] {Œ± : Type u‚ÇÅ} (F : J ‚•§ category_theory.discrete Œ±) (j j' : J) : F.obj j = F.obj j'
{C : Type u} {X Y : category_theory.free_monoidal_category C} : subsingleton (X ‚ü∂ Y)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G : J ‚•§ C} (Œ± : G ‚ü∂ F) : category_theory.limits.cocone F ‚•§ category_theory.limits.cocone G
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [densely_ordered Œ±] {Œ¥ : Type u_1} [linear_order Œ¥] [topological_space Œ¥] [order_closed_topology Œ¥] {s : set Œ±} [hs : s.ord_connected] {f : Œ± ‚Üí Œ¥} (hf : continuous_on f s) {a b : Œ±} (ha : a ‚àà s) (hb : b ‚àà s) : set.surj_on f s (set.Icc (f a) (f b))
{L : first_order.language} {Œ± : Type u'} : (Œ£ (n : ‚Ñï), L.bounded_formula Œ± n) ‚Üí (Œ£ (n : ‚Ñï), L.bounded_formula Œ± n) ‚Üí (Œ£ (n : ‚Ñï), L.bounded_formula Œ± n)
{p : Prop} (cmd : rand (slim_check.test_result p)) : ‚Ñï ‚Üí rand (slim_check.test_result p)
{M : Type u_1} [add_semigroup M] (c : add_con M) : add_semigroup c.quotient
(F_name : name) (i : ‚Ñï) : tactic expr
(c : linarith.comp) : bool
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {X Y Z : C} [category_theory.has_left_dual X] [category_theory.has_left_dual Y] [category_theory.has_left_dual Z] {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : ·òÅ(f ‚â´ g) = ·òÅg ‚â´ ·òÅf
{Œ≥ : Type w} [semilattice_sup Œ≥] {a b : Œ≥} {s t : set Œ≥} (hs : is_lub s a) (ht : is_lub t b) : is_lub (s ‚à™ t) (a ‚äî b)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Type (max v u)) (t : category_theory.limits.cocone F) (hsurj : ‚àÄ (x : t.X), ‚àÉ (i : J) (xi : F.obj i), x = t.Œπ.app i xi) (hinj : ‚àÄ (i j : J) (xi : F.obj i) (xj : F.obj j), t.Œπ.app i xi = t.Œπ.app j xj ‚Üí (‚àÉ (k : J) (f : i ‚ü∂ k) (g : j ‚ü∂ k), F.map f xi = F.map g xj)) : category_theory.limits.is_colimit t
(K : Type u_1) (V : Type u_2) [field K] [add_comm_group V] [module K V] : setoid {v // v ‚â† 0}
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (v : n ‚Üí Œ±) [invertible (matrix.diagonal v)] : invertible v
 : name ‚Üí tactic (list name)
{Œ± : Type u_1} {Œ≤ : Type u_2} : list (option Œ±) ‚Üí list Œ≤ ‚Üí list (option Œ≤)
{K : Type u} [hfield : field K] (p : polynomial K) {q : polynomial K} (hq : q ‚â† 0) : ‚áëpolynomial.C ((q / gcd_monoid.gcd p q).leading_coeff)‚Åª¬π * (p / gcd_monoid.gcd p q) ‚à£ p
(R : Type u) [comm_semiring R] (A : Type v) [semiring A] [algebra R A] (n : Type w) (a : A) (m : matrix n n R) : matrix n n A
(b : pgame.domineering.board) (m : ‚Ñ§ √ó ‚Ñ§) : pgame.domineering.board
{R : Type u_3} [topological_space R] [has_star R] [has_continuous_star R] : C(R, R)
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} : L.bounded_formula Œ± n ‚Üí Prop
(ùïú : Type u_1) {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] (s : set E) (f : E ‚Üí Œ≤) : Prop
 : FinPartialOrder ‚âå FinPartialOrder
(V : Type v) [category_theory.category V] [category_theory.monoidal_category V] {C : Type u‚ÇÅ} [category_theory.enriched_category V C] (X : C) : ùüô_ V ‚ü∂ category_theory.enriched_category.hom X X
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} (p : Œπ ‚Üí P) : affine_independent k p ‚Üî ‚àÄ (s1 s2 : finset Œπ) (w1 w2 : Œπ ‚Üí k), s1.sum (Œª (i : Œπ), w1 i) = 1 ‚Üí s2.sum (Œª (i : Œπ), w2 i) = 1 ‚Üí ‚áë(s1.affine_combination p) w1 = ‚áë(s2.affine_combination p) w2 ‚Üí ‚Üës1.indicator w1 = ‚Üës2.indicator w2
{R : Type u_1} {M : Type u_2} {N : Type u_3} {P : Type u_4} [ring R] [add_comm_group M] [module R M] [add_comm_group N] [module R N] [add_comm_group P] [module R P] (f : M ‚Üí‚Çó[R] N) (g : N ‚Üí‚Çó[R] P) (hf1 : f.ker.fg) (hf2 : g.ker.fg) (hsur : function.surjective ‚áëf) : (g.comp f).ker.fg
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) (K : add_subgroup N) : add_subgroup (G √ó N)
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (Œ∏ : real.angle) : o.oangle (‚áë(o.rotation Œ∏) x) y = o.oangle x y - Œ∏
(M : Type u) [add_semigroup M] : AddSemigroup
{m : Type u_2} {Œ± : Type v} {Œ≤ : Type w} [fintype m] [decidable_eq m] [non_assoc_semiring Œ±] [non_assoc_semiring Œ≤] (f : Œ± ‚Üí+* Œ≤) : matrix m m Œ± ‚Üí+* matrix m m Œ≤
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {c : F} : cont_diff ùïú n (Œª (x : E), c)
{Œ± Œ≤ : DistribLattice} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
{V : Type u} {G : simple_graph V} (H : simple_graph V) (h : H ‚â§ G) : G.subgraph
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (S : Type u_3) [comm_monoid S] [distrib_mul_action S M] [smul_comm_class S R M] : submodule R M
{Œ± : Type u} [preorder Œ±] (s : set Œ±) : Œ± ‚Üí Prop
 : sSet
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_sup Œ±] [has_inf Œ±] [has_Sup Œ±] [has_Inf Œ±] [has_top Œ±] [has_bot Œ±] [complete_lattice Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.injective f) (map_sup : ‚àÄ (a b : Œ±), f (a ‚äî b) = f a ‚äî f b) (map_inf : ‚àÄ (a b : Œ±), f (a ‚äì b) = f a ‚äì f b) (map_Sup : ‚àÄ (s : set Œ±), f (has_Sup.Sup s) = ‚®Ü (a : Œ±) (H : a ‚àà s), f a) (map_Inf : ‚àÄ (s : set Œ±), f (has_Inf.Inf s) = ‚®Ö (a : Œ±) (H : a ‚àà s), f a) (map_top : f ‚ä§ = ‚ä§) (map_bot : f ‚ä• = ‚ä•) : complete_lattice Œ±
{X : Type u_1} [topological_space X] (x y : X) : Type u_1
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±] [nontrivial Œ±] {s : set Œ±} [topological_space.separable_space ‚Ü•s] (hs : dense s) : ‚àÉ (t : set Œ±) (H : t ‚äÜ s), t.countable ‚àß dense t ‚àß (‚àÄ (x : Œ±), is_bot x ‚Üí x ‚àâ t) ‚àß ‚àÄ (x : Œ±), is_top x ‚Üí x ‚àâ t
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [comm_ring ùïú] [add_comm_group E] [add_comm_group F] [module ùïú E] [module ùïú F] [topological_space E] [topological_space F] [topological_add_group E] [has_continuous_const_smul ùïú E] [topological_add_group F] [has_continuous_const_smul ùïú F] (q : formal_multilinear_series ùïú E F) (p : formal_multilinear_series ùïú E E) : q.comp p 0 = q 0
{M‚ÇÄ : Type u_1} [mul_zero_class M‚ÇÄ] [no_zero_divisors M‚ÇÄ] {a b : M‚ÇÄ} : a * b ‚â† 0 ‚Üî a ‚â† 0 ‚àß b ‚â† 0
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [dec_E : decidable_eq E] {s : set E} : orthonormal ùïú coe ‚Üî ‚àÄ (v : E), v ‚àà s ‚Üí ‚àÄ (w : E), w ‚àà s ‚Üí has_inner.inner v w = ite (v = w) 1 0
 : category_theory.limits.walking_cospan
(J : Type v) : category_theory.limits.walking_parallel_family J ‚Üí category_theory.limits.walking_parallel_family J ‚Üí Type v
{M : Type u_1} [has_add M] {s : set M} {p : M ‚Üí Prop} {x : M} (h : x ‚àà add_subsemigroup.closure s) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí p x) (Hmul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x + y)) : p x
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_group Œ±] [subtraction_monoid Œ≤] (f : Œ± ‚Üí+ Œ≤) (g : Œ±) (n : ‚Ñ§) : ‚áëf (n ‚Ä¢ g) = n ‚Ä¢ ‚áëf g
 : Type (u_1+1)
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b : Œ±} (ha : a < 1) (hb : b < 1) : a * b < 1
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : Top.presheaf.sheaf_condition_equalizer_products.pi_inters F U ‚ü∂ category_theory.presheaf.second_obj (Top.presheaf.presieve_of_covering U) F
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ±‚ÇÇ : Type u_3} [semiring Œ≤] [has_add Œ±] [has_add Œ±‚ÇÇ] {F : Type u_4} [add_hom_class F Œ± Œ±‚ÇÇ] (f : F) (x y : add_monoid_algebra Œ≤ Œ±) : finsupp.map_domain ‚áëf (x * y) = finsupp.map_domain ‚áëf x * finsupp.map_domain ‚áëf y
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] {R : Type u_10} [monoid R] [distrib_mul_action R V2] [smul_comm_class k R V2] : mul_action R (P1 ‚Üí·µÉ[k] V2)
(t s : omega.nat.preterm) (k : ‚Ñï) : omega.nat.preform
{V : Type u} {G : simple_graph V} (G' : G.subgraph) (v : V) [fintype ‚Ü•(G'.neighbor_set v)] : ‚Ñï
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_binary_biproduct X Y] (hY : category_theory.limits.is_zero Y) : X ‚âÖ X ‚äû Y
{C : Type u} [category_theory.category C] [category_theory.abelian C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.is_iso (category_theory.abelian.coimage_image_comparison f)
{Œ± : Type u_2} [decidable_eq Œ±] [has_mul Œ±] {u : finset Œ±} {s t : set Œ±} : ‚Üëu ‚äÜ s * t ‚Üí (‚àÉ (s' t' : finset Œ±), ‚Üës' ‚äÜ s ‚àß ‚Üët' ‚äÜ t ‚àß u ‚äÜ s' * t')
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} [fintype Œπ] (p : Œπ ‚Üí P) : affine_independent k p ‚Üî ‚àÄ (w1 w2 : Œπ ‚Üí k), finset.univ.sum (Œª (i : Œπ), w1 i) = 1 ‚Üí finset.univ.sum (Œª (i : Œπ), w2 i) = 1 ‚Üí ‚áë(finset.univ.affine_combination p) w1 = ‚áë(finset.univ.affine_combination p) w2 ‚Üí w1 = w2
{Œ± : Type u_1} {Œπ : Type u_4} (l : filter Œ±) (p : Œπ ‚Üí Prop) (s : Œπ ‚Üí set Œ±) : Prop
{n : ‚Ñï} (i : fin2 n) (k : ‚Ñï) : fin2 (n + k)
{Œπ : Type u} {Œ≥ : Type w} {Œ≤ : Œπ ‚Üí Type v} [dec : decidable_eq Œπ] {Œ¥ : Type u_1} [Œ† (i : Œπ), add_zero_class (Œ≤ i)] [add_comm_monoid Œ≥] [add_comm_monoid Œ¥] (g : Œ≥ ‚Üí+ Œ¥) (f : Œ† (i : Œπ), Œ≤ i ‚Üí+ Œ≥) : g.comp (‚áëdfinsupp.lift_add_hom f) = ‚áëdfinsupp.lift_add_hom (Œª (a : Œπ), g.comp (f a))
{Œ± : Type u_1} {n : ‚Ñï} (v : vector3 Œ± n.succ) : vector3 Œ± n
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (X : category_theory.simplicial_object C) : chain_complex C ‚Ñï
(rules : list (expr √ó bool)) (exp : expr) (cfg : tactic.rewrite_search.config) : tactic (buffer tactic.rewrite_search.rewrite)
{ùïú : Type u_1} {E : Type u_2} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] {f : ùïú ‚Üí E} {r : ennreal} {x : ùïú} {p : formal_multilinear_series ùïú ùïú E} (h : has_fpower_series_on_ball f p x r) (h' : ‚àÄ (r' : nnreal), 0 < r' ‚Üí (‚àÉ (p' : formal_multilinear_series ùïú ùïú E), has_fpower_series_on_ball f p' x ‚Üër')) : has_fpower_series_on_ball f p x ‚ä§
(R : Type u_1) [comm_semiring R] (X : Type u_2) {C : free_algebra R X ‚Üí Prop} (h_grade0 : ‚àÄ (r : R), C (‚áë(algebra_map R (free_algebra R X)) r)) (h_grade1 : ‚àÄ (x : X), C (free_algebra.Œπ R x)) (h_mul : ‚àÄ (a b : free_algebra R X), C a ‚Üí C b ‚Üí C (a * b)) (h_add : ‚àÄ (a b : free_algebra R X), C a ‚Üí C b ‚Üí C (a + b)) (a : free_algebra R X) : C a
{u : ‚Ñï ‚Üí ‚Ñù} (h : subadditive u) : ‚Ñù
{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A) : Prop
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] [category_theory.limits.has_limits_of_shape J C] (G : J ‚•§ K ‚•§ C) : category_theory.limits.limit G ‚âÖ category_theory.curry.obj (category_theory.prod.swap K J ‚ãô category_theory.uncurry.obj G) ‚ãô category_theory.limits.lim
{X : Top} {x‚ÇÄ x‚ÇÅ : ‚Ü•(fundamental_groupoid.fundamental_groupoid_functor.obj X)} (p : x‚ÇÄ ‚ü∂ x‚ÇÅ) : path.homotopic.quotient x‚ÇÄ x‚ÇÅ
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F) : ‚Ñù
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] {B' : Type u_5} [topological_space B'] (h : is_topological_fiber_bundle F proj) {f : B' ‚Üí B} (hf : continuous f) : is_topological_fiber_bundle F (Œª (x : ‚Ü•{p : B' √ó Z | f p.fst = proj p.snd}), ‚Üëx.fst)
{m n : ‚Ñï} (h : m.coprime n) : zmod (m * n) ‚âÉ+* zmod m √ó zmod n
{Œ± : Type u} [pseudo_metric_space Œ±] {f : ‚Ñï ‚Üí Œ±} (n : ‚Ñï) {d : ‚Ñï ‚Üí ‚Ñù} (hd : ‚àÄ {k : ‚Ñï}, k < n ‚Üí has_dist.dist (f k) (f (k + 1)) ‚â§ d k) : has_dist.dist (f 0) (f n) ‚â§ (finset.range n).sum (Œª (i : ‚Ñï), d i)
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [ring Œ≤] : ring Œ±
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] {t : category_theory.limits.cotrident f} (ht : category_theory.limits.is_colimit t) (Z : C) : (t.X ‚ü∂ Z) ‚âÉ {h // ‚àÄ (j‚ÇÅ j‚ÇÇ : J), f j‚ÇÅ ‚â´ h = f j‚ÇÇ ‚â´ h}
(r : ‚Ñï) (b : bool) : ‚Ñï
(G : Type u) : Type u
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {x : E} {n : with_top ‚Ñï} {f g : E ‚Üí ùïú} (hf : cont_diff_at ùïú n f x) (hg : cont_diff_at ùïú n g x) : cont_diff_at ùïú n (Œª (x : E), f x * g x) x
{Œ± : Type u_1} (n : ‚Ñï) (s : finset Œ±) : finset (finset Œ±)
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : algebraic_geometry.PresheafedSpace C} (Y : algebraic_geometry.SheafedSpace C) (f : X ‚ü∂ Y.to_PresheafedSpace) [H : algebraic_geometry.PresheafedSpace.is_open_immersion f] : algebraic_geometry.SheafedSpace C
{C : Type u} [category_theory.category C] {F : category_theory.limits.walking_span ‚•§ C} (t : category_theory.limits.cocone F) : category_theory.limits.pushout_cocone (F.map category_theory.limits.walking_span.hom.fst) (F.map category_theory.limits.walking_span.hom.snd)
(C : Type u) [category_theory.category C] : category_theory.bicategory.strict (category_theory.locally_discrete C)
{Œ± : Type u_1} [linear_order Œ±] [densely_ordered Œ±] [no_min_order Œ±] [no_max_order Œ±] [nonem : nonempty Œ±] (lo hi : finset Œ±) (lo_lt_hi : ‚àÄ (x : Œ±), x ‚àà lo ‚Üí ‚àÄ (y : Œ±), y ‚àà hi ‚Üí x < y) : ‚àÉ (m : Œ±), (‚àÄ (x : Œ±), x ‚àà lo ‚Üí x < m) ‚àß ‚àÄ (y : Œ±), y ‚àà hi ‚Üí m < y
{ùïú : Type u_3} [field ùïú] {r : ‚Ñï} (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) (hM : M (sum.inr ()) (sum.inr ()) ‚â† 0) (i : fin r) : ((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod (sum.inr ()) (sum.inl i) = 0
{K : Type u_1} [field K] [invertible 2] {a b c : K} (ha : a ‚â† 0) (h : ‚àÉ (s : K), discrim a b c = s * s) : ‚àÉ (x : K), a * x * x + b * x + c = 0
 : Twop ‚âå Twop
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : valuation R (with_zero (multiplicative ‚Ñ§))
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) (P : Type u_6) (Q : Type u_7) [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [add_comm_monoid Q] [module R M] [module R N] [module R P] [module R Q] : (M ‚Üí‚Çó[R] P) ‚Üí‚Çó[R] (N ‚Üí‚Çó[R] Q) ‚Üí‚Çó[R] tensor_product R M N ‚Üí‚Çó[R] tensor_product R P Q
{G : Type u_1} [group G] (g : G) : subgroup G
{R : Type v} [comm_ring R] {n : ‚Ñï} (A : matrix (fin n.succ) (fin n.succ) R) (j : fin n.succ) : A.det = finset.univ.sum (Œª (i : fin n.succ), (-1) ^ (‚Üëi + ‚Üëj) * A i j * (A.minor ‚áë(i.succ_above) ‚áë(j.succ_above)).det)
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {a b : Œ±} (h : a ‚â† b) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà {a, b}), f i)) = f a * f b
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [ring R] [add_comm_group M] [module R M] [nontrivial R] (b : basis Œπ R M) : _.maximal
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [measurable_space Œ±] (f : measure_theory.simple_func Œ± Œ≤) (g : measure_theory.simple_func Œ± Œ≥) : measure_theory.simple_func Œ± (Œ≤ √ó Œ≥)
{Œ≤ : Type w} {C : Type u} [category_theory.category C] (f : Œ≤ ‚Üí C) : Prop
{M : Type u_1} [monoid M] {Œπ : Type u_2} [fintype Œπ] {N : Œπ ‚Üí Type u_3} [Œ† (i : Œπ), monoid (N i)] (œï : Œ† (i : Œπ), N i ‚Üí* M) (hcomm : ‚àÄ (i j : Œπ), i ‚â† j ‚Üí ‚àÄ (x : N i) (y : N j), commute (‚áë(œï i) x) (‚áë(œï j) y)) : (Œ† (i : Œπ), N i) ‚Üí* M
{Œ≤ : Type w} [add_comm_group Œ≤] (s : Œ≤) (C : Type u) : Type (max w u)
(R‚ÇÅ : Type u_1) [semiring R‚ÇÅ] (M‚ÇÅ : Type u_4) [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {Œ± : Type u_1} [add_monoid Œ±] [distrib_mul_action A Œ±] (S : subalgebra R A) : distrib_mul_action ‚Ü•S Œ±
{R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b
 : category_theory.limits.has_limits_of_size Ring
{E : Type u_1} [add_comm_group E] [module ‚Ñù E] {s : set E} {x : E} (absorbs : absorbent ‚Ñù s) : {r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s}.nonempty
{R : Type u_1} [semiring R] (N : ‚Ñï) : polynomial R ‚Üí polynomial R
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.mul_pos_strict_mono Œ±] (ha : a < 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_limit t) : (category_theory.limits.binary_bicone.of_limit_cone ht).is_bilimit
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) : category_theory.limits.is_limit (AddCommGroup.limit_cone F)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_noetherian R M] (f : M ‚Üí‚Çó[R] M) (s : function.surjective ‚áëf) : function.bijective ‚áëf
{n : ‚Ñï} {a b : fin n} {x : fin (n + 1)} : ‚áë(x.succ_above) a = ‚áë(x.succ_above) b ‚Üî a = b
 : list widget_override.local_collection ‚Üí list widget_override.local_collection
 : expr ‚Üí tactic (expr √ó expr)
(env : environment) (n : name) : list name
(G : Type u_1) [measurable_space G] [group G] [has_measurable_mul‚ÇÇ G] [has_measurable_inv G] : G √ó G ‚âÉ·µê G √ó G
{Œπ : Type u_4} {M : Type u_5} {N : Type u_7} {Œ±s : Œπ ‚Üí Type u_13} [has_zero M] (l : (Œ£ (i : Œπ), Œ±s i) ‚Üí‚ÇÄ M) [has_zero N] (g : Œ† (i : Œπ), (Œ±s i ‚Üí‚ÇÄ M) ‚Üí N) (hg : ‚àÄ (i : Œπ) (x : Œ±s i ‚Üí‚ÇÄ M), x = 0 ‚Üî g i x = 0) : Œπ ‚Üí‚ÇÄ N
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} (x : E) {g : F ‚Üí G} {g' : F ‚ÜíL[ùïú] G} (hg : has_strict_fderiv_at g g' (f x)) (hf : has_strict_fderiv_at f f' x) : has_strict_fderiv_at (Œª (x : E), g (f x)) (g'.comp f') x
{X Y : Type u} : X ‚âÉ Y ‚âÉ (X ‚âÖ Y)
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {G : D ‚•§ C} [category_theory.is_right_adjoint G] (B : D) [category_theory.limits.reflects_colimit (category_theory.limits.parallel_pair ((category_theory.left_adjoint G).map (G.map ((category_theory.adjunction.of_right_adjoint G).counit.app B))) ((category_theory.adjunction.of_right_adjoint G).counit.app ((category_theory.left_adjoint G).obj (G.obj B)))) G] : category_theory.limits.is_colimit (category_theory.monad.monadicity_internal.counit_cofork B)
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} (a : topological_fiber_prebundle F proj) : topological_space Z
{R : Type u} [ring R] {s : set R} {p : R ‚Üí R ‚Üí Prop} {a b : R} (ha : a ‚àà subring.closure s) (hb : b ‚àà subring.closure s) (Hs : ‚àÄ (x : R), x ‚àà s ‚Üí ‚àÄ (y : R), y ‚àà s ‚Üí p x y) (H0_left : ‚àÄ (x : R), p 0 x) (H0_right : ‚àÄ (x : R), p x 0) (H1_left : ‚àÄ (x : R), p 1 x) (H1_right : ‚àÄ (x : R), p x 1) (Hneg_left : ‚àÄ (x y : R), p x y ‚Üí p (-x) y) (Hneg_right : ‚àÄ (x y : R), p x y ‚Üí p x (-y)) (Hadd_left : ‚àÄ (x‚ÇÅ x‚ÇÇ y : R), p x‚ÇÅ y ‚Üí p x‚ÇÇ y ‚Üí p (x‚ÇÅ + x‚ÇÇ) y) (Hadd_right : ‚àÄ (x y‚ÇÅ y‚ÇÇ : R), p x y‚ÇÅ ‚Üí p x y‚ÇÇ ‚Üí p x (y‚ÇÅ + y‚ÇÇ)) (Hmul_left : ‚àÄ (x‚ÇÅ x‚ÇÇ y : R), p x‚ÇÅ y ‚Üí p x‚ÇÇ y ‚Üí p (x‚ÇÅ * x‚ÇÇ) y) (Hmul_right : ‚àÄ (x y‚ÇÅ y‚ÇÇ : R), p x y‚ÇÅ ‚Üí p x y‚ÇÇ ‚Üí p x (y‚ÇÅ * y‚ÇÇ)) : p a b
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {f' : F} {x : ùïú} [partial_order ùïú] : has_deriv_within_at f f' (set.Iio x) x ‚Üí has_deriv_within_at f f' (set.Iic x) x
(C : Type u_1) [category_theory.category C] [category_theory.is_idempotent_complete C] : category_theory.is_equivalence (category_theory.idempotents.to_karoubi C)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_nilpotent R L] : ‚ä§.is_cartan_subalgebra
{C : Type u} [category_theory.category C] {F G : C ‚•§ C} {Œ± Œ≤ : F ‚ü∂ G} (h : Œ± = Œ≤) : category_theory.endofunctor.algebra.functor_of_nat_trans Œ± ‚âÖ category_theory.endofunctor.algebra.functor_of_nat_trans Œ≤
 : linter
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J·µí·µñ ‚•§ C) {c : category_theory.limits.cocone F.right_op} (hc : category_theory.limits.is_colimit c) : category_theory.limits.is_limit (category_theory.limits.cone_of_cocone_right_op c)
{R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] [nontrivial R] {Œπ : Type w} (b : basis Œπ R M) [infinite Œπ] {Œ∫ : Type w'} (v : Œ∫ ‚Üí M) (i : linear_independent R v) (m : i.maximal) : (cardinal.mk Œπ).lift ‚â§ (cardinal.mk Œ∫).lift
(Œ± : Type u_1) [has_mul Œ±] : has_scalar Œ±·µê·µí·µñ Œ±
{xl xr : Type u_1} (xL : xl ‚Üí pgame) (xR : xr ‚Üí pgame) [S : (pgame.mk xl xr xL xR).short] (i : xl) : (xL i).short
{M : Type u_1} [add_semigroup M] [topological_space M] [t2_space M] (continuous_mul_left : ‚àÄ (r : M), continuous (Œª (_x : M), _x + r)) (s : set M) (snemp : s.nonempty) (s_compact : is_compact s) (s_add : ‚àÄ (x : M), x ‚àà s ‚Üí ‚àÄ (y : M), y ‚àà s ‚Üí x + y ‚àà s) : ‚àÉ (m : M) (H : m ‚àà s), m + m = m
{R : Type u} [semiring R] (f : polynomial R) : polynomial R
{M‚ÇÅ : Type u_6} {M‚ÇÇ : Type u_7} [topological_space M‚ÇÇ] [t2_space M‚ÇÇ] [mul_one_class M‚ÇÅ] [mul_one_class M‚ÇÇ] [has_continuous_mul M‚ÇÇ] {F : Type u_8} [monoid_hom_class F M‚ÇÅ M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : f ‚àà closure (set.range (Œª (f : F) (x : M‚ÇÅ), ‚áëf x))) : M‚ÇÅ ‚Üí* M‚ÇÇ
{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] : ‚Üë1 = is_localization.coe_submodule P ‚ä§
{Œ± : Type u_1} [measurable_space Œ±] : measure_theory.measure Œ±
{Œ± : Type v} [linear_order Œ±] [topological_space Œ±] [order_closed_topology Œ±] {s : set Œ±} (hs : is_preconnected s) (hb : ¬¨bdd_below s) (ha : ¬¨bdd_above s) : s = set.univ
(rw : tactic.nth_rewrite.tracked_rewrite) : tactic (expr √ó expr)
{Œ± : Type} (p : parser Œ±) : Prop
(tags : interactive.parse (lean.parser.many lean.parser.ident)) : tactic unit
{Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : lipschitz_with 1 (Œª (x : Œ±), metric.inf_dist x s)
{Œ± : Type u} (a : Œ±) (s : stream Œ±) : stream Œ±
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : ‚Ü•(set.range f) ‚Üí Œ±
 : Type (u+1)
(t : tactic.interactive.itactic) : tactic.interactive.itactic
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) : Type (max u‚ÇÅ v‚ÇÅ)
{G : Type u_1} [group G] [fintype G] : monoid.is_torsion G
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {s : set E} (hs : orthonormal ùïú coe) : ‚àÉ (w : set E) (H : w ‚äá s), orthonormal ùïú coe ‚àß ‚àÄ (u : set E), u ‚äá w ‚Üí orthonormal ùïú coe ‚Üí u = w
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [category_theory.is_iso f] : category_theory.limits.pushout_cocone f g
(C : Type u) [category_theory.category C] : Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {x : E} {n : with_top ‚Ñï} {p : E ‚Üí formal_multilinear_series ùïú E F} (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ‚â§ n) (hx : x ‚àà s) : has_fderiv_within_at f (‚áë(continuous_multilinear_curry_fin1 ùïú E F) (p x 1)) s x
 : Type
{Œ± : Type u_2} {Œπ : Type u_5} [add_comm_monoid Œ±] (t : finset Œπ) (f : Œπ ‚Üí set Œ±) (a : Œ±) : a ‚àà t.sum (Œª (i : Œπ), f i) ‚Üî ‚àÉ (g : Œπ ‚Üí Œ±) (hg : ‚àÄ {i : Œπ}, i ‚àà t ‚Üí g i ‚àà f i), t.sum (Œª (i : Œπ), g i) = a
{Œ± : Type u} [infinite Œ±] : nonempty (field Œ±)
{Œ± : Type u_1} {Œ≤ : Type u_2} [can_lift Œ± Œ≤] : can_lift (multiset Œ±) (multiset Œ≤)
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] {f : L.hom M N} (hf : function.surjective ‚áëf) : galois_insertion (first_order.language.substructure.map f) (first_order.language.substructure.comap f)
(J : Type u‚ÇÅ) [category_theory.category J] : Prop
 : tactic unit
(x y : pgame) [x.short] [y.short] : decidable (x ‚â§ y) √ó decidable (x.lf y)
(k : Type u) [field k] : Prop
{R : Type u} [ring R] {J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Module R) : category_theory.limits.is_colimit (Module.filtered_colimits.colimit_cocone F)
{n : Type u_4} {Œ± : Type u_5} [fintype n] [non_unital_normed_ring Œ±] : non_unital_normed_ring (matrix n n Œ±)
(n a : ‚Ñï) : finset.image (Œª (_x : ‚Ñï), _x % a) (finset.Ico n (n + a)) = finset.range a
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [decidable_eq Œπ] [add_monoid Œπ] [comm_semiring R] [semiring A] [algebra R A] (ùíú : Œπ ‚Üí submodule R A) [set_like.graded_monoid ùíú] (decompose : A ‚Üí‚Çê[R] direct_sum Œπ (Œª (i : Œπ), ‚Ü•(ùíú i))) (right_inv : (direct_sum.coe_alg_hom ùíú).comp decompose = alg_hom.id R A) (left_inv : ‚àÄ (i : Œπ) (x : ‚Ü•(ùíú i)), ‚áëdecompose ‚Üëx = ‚áë(direct_sum.of (Œª (i : Œπ), ‚Ü•(ùíú i)) i) x) : graded_algebra ùíú
{R : Type u} [ring R] {s t : subring R} (h : s = t) : ‚Ü•s ‚âÉ+* ‚Ü•t
{n : ‚Ñï} {a b : fin n} : a ‚ãñ b ‚Üí ‚Üëa ‚ãñ ‚Üëb
{X : Type u} {m‚ÇÅ m‚ÇÇ : X ‚Üí X ‚Üí X} {e‚ÇÅ e‚ÇÇ : X} (h‚ÇÅ : eckmann_hilton.is_unital m‚ÇÅ e‚ÇÅ) (h‚ÇÇ : eckmann_hilton.is_unital m‚ÇÇ e‚ÇÇ) (distrib : ‚àÄ (a b c d : X), m‚ÇÅ (m‚ÇÇ a b) (m‚ÇÇ c d) = m‚ÇÇ (m‚ÇÅ a c) (m‚ÇÅ b d)) : m‚ÇÅ = m‚ÇÇ
{Œ± : Type u_1} {Œπ : Type u_2} {Œπ' : Type u_3} (l : combinatorics.line Œ± Œπ) (v : Œπ' ‚Üí Œ±) : combinatorics.line Œ± (Œπ ‚äï Œπ')
{G : Type u_1} [group G] : group.is_nilpotent G ‚Üî ‚àÉ (n : ‚Ñï), lower_central_series G n = ‚ä•
(Œ± : Type u_1) [partial_order Œ±] [fintype Œ±] : FinPartialOrder
{k G : Type u} [field k] [monoid G] {V : Type u} [add_comm_group V] [module k V] [finite_dimensional k V] (œÅ : G ‚Üí* V ‚Üí‚Çó[k] V) : Rep k G
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a : Œ±} : a‚Åª¬π < 1 ‚Üî 1 < a
(T : Type u) [topological_space T] : category_theory.pretopology.of_grothendieck (topological_space.opens T) (opens.grothendieck_topology T) = opens.pretopology T
{Œ± : Type u_1} [linear_order Œ±] [succ_order Œ±] [is_succ_archimedean Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) {n m : Œ±} (hr : reflexive r) (h1 : ‚àÄ (i : Œ±), i ‚àà set.Ico n m ‚Üí r i (order.succ i)) (h2 : ‚àÄ (i : Œ±), i ‚àà set.Ico m n ‚Üí r (order.succ i) i) : relation.trans_gen r n m
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (hQ : category_theory.presheaf.is_sheaf J Q) : J.plus_obj P ‚ü∂ Q
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.monoidal_category C] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) [category_theory.is_equivalence F.to_lax_monoidal_functor.to_functor] (X : C) [category_theory.has_left_dual (F.to_lax_monoidal_functor.to_functor.obj X)] : category_theory.has_left_dual X
{n : Type u} [decidable_eq n] [fintype n] {Œ± : Type v} [comm_ring Œ±] (A : matrix n n Œ±) (b : n ‚Üí Œ±) : A.mul_vec (‚áë(A.cramer) b) = A.det ‚Ä¢ b
(p : pexpr) (depth : ‚Ñï) : tactic tactic.rcases_patt
(X : algebraic_geometry.Scheme) : Top.sheaf CommRing ‚Üë(X.to_LocallyRingedSpace.to_SheafedSpace)
{ùïú : Type u_3} {E : Type u_4} [semi_normed_ring ùïú] [add_comm_group E] [module ùïú E] (p : seminorm ùïú E) (r : ‚Ñù) : balanced ùïú (p.ball 0 r)
{R : Type u_1} [nontrivial R] [hR : ring R] (h : ‚àÄ (a : R), is_unit a ‚à® a = 0) : division_ring R
(R : Type u) [semiring R] [strong_rank_condition R] : rank_condition R
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} : metric.Hausdorff_dist (closure s) (closure t) = metric.Hausdorff_dist s t
{Œ± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {c : ‚Ñù} {g : Œ± ‚Üí F} {f' : Œ± ‚Üí E'} {l : filter Œ±} : asymptotics.is_O_with c l (Œª (x : Œ±), -f' x) g ‚Üí asymptotics.is_O_with c l f' g
 : category_theory.limits.preserves_limits_of_size (category_theory.forget CommMon)
(e : tactic.ring.horner_expr) : tactic.ring.ring_m (tactic.ring.horner_expr √ó expr)
{Œ± Œ≤ : Type u_1} {m : Type u_1 ‚Üí Type u_2} [monad m] (y : m Œ≤) (z : Œ± ‚Üí m Œ≤) (x : m (option Œ±)) : m Œ≤
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] : (Œ± ‚Üío Œ≤) ‚âÉ (Œ±·µí·µà ‚Üío Œ≤·µí·µà)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} : monotone_on f s ‚Üí antitone_on (f ‚àò ‚áëorder_dual.of_dual) s
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {S : D} {T : C ‚•§ D} {f f' : category_theory.structured_arrow S T} (g : f.right ‚âÖ f'.right) (w : f.hom ‚â´ T.map g.hom = f'.hom) : f ‚âÖ f'
{Œì : Type u_1} [inhabited Œì] (L R : list Œì) : turing.tape Œì
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b : Œ±} (ha : 0 < a) (hb : 0 ‚â§ b) : 0 < a + b
{J : Type u} (F : J ‚Üí Type u) : ‚àè F ‚âÖ Œ† (j : J), F j
{M : Type u_1} [left_cancel_monoid M] [fintype M] (S : set M) (hS1 : S.nonempty) (hS2 : S * S = S) : submonoid M
{C : Type u‚ÇÅ} [category_theory.small_category C] (X : C) (F : C·µí·µñ ‚•§ Type u‚ÇÅ) : (category_theory.yoneda.obj X ‚ü∂ F) ‚âÖ F.obj (opposite.op X)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) (i : E ‚âÉL[ùïú] F) : formal_multilinear_series ùïú F E
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] : category_theory.limits.has_coequalizers C
(Œ± : Type u) (ds : list ‚Ñï) : Type u
{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_group M] [module R M] : has_neg (submodule R M)
{Œ± : Type u} : seq (seq1 Œ±) ‚Üí seq Œ±
(z : ‚ÑÇ) : ‚Üë(z.im) = (z - ‚áë(star_ring_end ‚ÑÇ) z) / (2 * complex.I)
{Œπ : Type u} (s : finset Œπ) (w z : Œπ ‚Üí ‚Ñù) (hw : ‚àÄ (i : Œπ), i ‚àà s ‚Üí 0 ‚â§ w i) (hw' : s.sum (Œª (i : Œπ), w i) = 1) (hz : ‚àÄ (i : Œπ), i ‚àà s ‚Üí 0 ‚â§ z i) : s.prod (Œª (i : Œπ), z i ^ w i) ‚â§ s.sum (Œª (i : Œπ), w i * z i)
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [ring_hom_surjective œÉ‚ÇÅ‚ÇÇ] (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (p : submodule R M) : submodule R‚ÇÇ M‚ÇÇ
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : Top.presheaf.sheaf_condition_equalizer_products.pi_opens F U ‚ü∂ Top.presheaf.sheaf_condition_equalizer_products.pi_inters F U
(R : Type u) (M : Type v) (M‚ÇÇ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] : M √ó M‚ÇÇ ‚Üí‚Çó[R] M
{R : Type u_1} [comm_semiring R] {M‚ÇÅ : Type u_2} {M‚ÇÇ : Type u_3} [add_comm_monoid M‚ÇÅ] [module R M‚ÇÅ] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] (f : M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ) : module.dual R M‚ÇÇ ‚Üí‚Çó[R] module.dual R M‚ÇÅ
{Œπ : Type u_1} {Œ± : Type u_2} {s : Œπ ‚Üí set Œ±} (hs : indexed_partition s) : Œ± ‚Üí hs.quotient
{Œ± : Type u_2} [has_one Œ±] [has_mul Œ±] [has_inv Œ±] : has_pow (filter Œ±) ‚Ñ§
(n : ‚Ñï) (Œ≤ : Type u) : (fin (n + 1) ‚Üí Œ≤) ‚âÉ Œ≤ √ó (fin n ‚Üí Œ≤)
{a b c : simplex_category} (f : b.hom c) (g : a.hom b) : a.hom c
{Œ± : Type u_1} {p : finset Œ± ‚Üí Prop} [decidable_eq Œ±] (S : finset Œ±) (h‚ÇÅ : p ‚àÖ) (h‚ÇÇ : ‚àÄ {a : Œ±} {s : finset Œ±}, a ‚àà S ‚Üí s ‚äÜ S ‚Üí a ‚àâ s ‚Üí p s ‚Üí p (has_insert.insert a s)) : p S
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} : b < c ‚Üí a = b ‚Üí a < c
(n : ‚Ñï) (p : ‚Ñï ‚Üí ‚Ñù) (hp : ‚àÄ (k : ‚Ñï), 0 ‚â§ p k) {r a : ‚Ñù} (hr : 0 ‚â§ r) (ha : 0 ‚â§ a) : (finset.Ico 2 (n + 1)).sum (Œª (k : ‚Ñï), a ^ k * {c : composition k | 1 < c.length}.to_finset.sum (Œª (c : composition k), r ^ c.length * finset.univ.prod (Œª (j : fin c.length), p (c.blocks_fun j)))) ‚â§ (finset.Ico 2 (n + 1)).sum (Œª (j : ‚Ñï), r ^ j * (finset.Ico 1 n).sum (Œª (k : ‚Ñï), a ^ k * p k) ^ j)
(l : list ‚Ñï) (n : ‚Ñï) : list.sorted has_lt.lt (denumerable.raise' l n)
{R : Type u} [comm_ring R] (M : Module R) (N : Module R) (K : Module R) : Module.monoidal_category.tensor_obj (Module.monoidal_category.tensor_obj M N) K ‚âÖ Module.monoidal_category.tensor_obj M (Module.monoidal_category.tensor_obj N K)
{R : Type u} [comm_ring R] (M N P : Module R) : ((category_theory.monoidal_category.tensor_left M).obj N ‚ü∂ P) ‚âÉ (N ‚ü∂ ((category_theory.linear_coyoneda R (Module R)).obj (opposite.op M)).obj P)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) (h : open_embedding f) [nonempty Œ±] : local_homeomorph Œ± Œ≤
{Œ± : Type u_2} [topological_space Œ±] [has_add Œ±] [has_continuous_add Œ±] : has_continuous_add Œ±·µÉ·µí·µñ
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u} [category_theory.category C] {F : J ‚•§ C} (e : K ‚âå J) [category_theory.limits.has_limit (e.functor ‚ãô F)] : category_theory.limits.has_limit F
{Œ± : Type u} {Œ≤ : Type v} [fintype Œ≤] (r : Œ± ‚Üí Œ≤ ‚Üí Prop) [Œ† (a : Œ±), decidable_pred (r a)] : (‚àÄ (A : finset Œ±), A.card ‚â§ (finset.filter (Œª (b : Œ≤), ‚àÉ (a : Œ±) (H : a ‚àà A), r a b) finset.univ).card) ‚Üî ‚àÉ (f : Œ± ‚Üí Œ≤), function.injective f ‚àß ‚àÄ (x : Œ±), r x (f x)
(h : interactive.parse (optional lean.parser.ident <* lean.parser.tk ":")) (i‚ÇÅ : interactive.parse (interactive.with_desc ‚Üë"i" lean.parser.small_nat)) (re : interactive.parse ((lean.parser.tk "‚Üí" <|> lean.parser.tk "->") *> return tactic.tfae.arrow.right <|> (lean.parser.tk "‚Üî" <|> lean.parser.tk "<->") *> return tactic.tfae.arrow.left_right <|> (lean.parser.tk "‚Üê" <|> lean.parser.tk "<-") *> return tactic.tfae.arrow.left)) (i‚ÇÇ : interactive.parse (interactive.with_desc ‚Üë"j" lean.parser.small_nat)) : tactic unit
{Œ± : Type u} {f : Œ± ‚Üí Œ±} {x : Œ±} (hf : function.is_fixed_pt f x) : f x = x
{R : Type u_2} {Œì‚ÇÄ : Type u_3} {Œì'‚ÇÄ : Type u_4} [ring R] [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] [linear_ordered_comm_monoid_with_zero Œì'‚ÇÄ] (v‚ÇÅ : valuation R Œì‚ÇÄ) (v‚ÇÇ : valuation R Œì'‚ÇÄ) : Prop
{G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) (f : G ‚Üí* N) (hf : function.injective ‚áëf) : ‚Ü•H ‚âÉ* ‚Ü•(subgroup.map f H)
 : tactic.itauto.and_kind ‚Üí tactic.itauto.prop ‚Üí tactic.itauto.prop ‚Üí tactic.itauto.prop √ó tactic.itauto.prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : algebraic_geometry.PresheafedSpace C} (Œ± : X ‚ü∂ Y) (x : ‚Ü•X) : Y.stalk (‚áë(Œ±.base) x) ‚ü∂ X.stalk x
 : native.float ‚Üí bool
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pullbacks C] {P Q R : C} {f : P ‚ü∂ R} {g : Q ‚ü∂ R} {p : ‚Ü•P} {q : ‚Ü•Q} : ‚áëf p = ‚áëg q ‚Üí (‚àÉ (s : ‚Ü•(category_theory.limits.pullback f g)), ‚áëcategory_theory.limits.pullback.fst s = p ‚àß ‚áëcategory_theory.limits.pullback.snd s = q)
 : lean.parser (tactic.list_Pi tactic.rcases_patt)
{Œ± : Type u} {l : list Œ±} : l.sublists.nodup ‚Üí l.nodup
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {a‚ÇÅ a‚ÇÇ : Œ±} {b‚ÇÅ b‚ÇÇ : Œ≤} {p‚ÇÅ p‚ÇÅ' : path a‚ÇÅ a‚ÇÇ} {p‚ÇÇ p‚ÇÇ' : path b‚ÇÅ b‚ÇÇ} (h‚ÇÅ : p‚ÇÅ.homotopy p‚ÇÅ') (h‚ÇÇ : p‚ÇÇ.homotopy p‚ÇÇ') : (p‚ÇÅ.prod p‚ÇÇ).homotopy (p‚ÇÅ'.prod p‚ÇÇ')
{S : Type u_1} (R‚ÇÅ : Type u_4) [comm_ring R‚ÇÅ] {Œπ : Type u_6} [fintype Œπ] [monoid S] [distrib_mul_action S R‚ÇÅ] [smul_comm_class S R‚ÇÅ R‚ÇÅ] (w : Œπ ‚Üí S) : quadratic_form R‚ÇÅ (Œπ ‚Üí R‚ÇÅ)
{R S : CommRing} (f : R ‚ü∂ S) : algebraic_geometry.Scheme.Spec_obj S ‚ü∂ algebraic_geometry.Scheme.Spec_obj R
(G : Type u_1) [topological_space G] [has_sub G] : Prop
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) {r : R} (h : 0 ‚â§ r) : same_ray R (r ‚Ä¢ v) v
 : Type
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {g : Œ≤ ‚Üí M} (e : Œ± ‚Üí Œ≤) (he‚ÇÄ : function.bijective e) (he‚ÇÅ : ‚àÄ (x : Œ±), f x = g (e x)) : finprod (Œª (i : Œ±), f i) = finprod (Œª (j : Œ≤), g j)
{Œ± : Type u_1} [topological_space Œ±] {Œ≤ : Type u_2} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (x : Œ±) : Prop
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [preorder Œ±] [preorder Œ≤] [preorder Œ≥] (g : pseudo_epimorphism Œ≤ Œ≥) (f : pseudo_epimorphism Œ± Œ≤) : pseudo_epimorphism Œ± Œ≥
{ùïú : Type u_1} {V : Type u_2} {P : Type u_8} [normed_field ùïú] [semi_normed_group V] [normed_space ùïú V] [pseudo_metric_space P] [normed_add_torsor V P] : group (P ‚âÉ·µÉ‚Å±[ùïú] P)
(A B : CommRing) : category_theory.limits.binary_fan A B
(C : Type u) [category_theory.category C] (D : Type u_1) [category_theory.category D] (F : C ‚•§ D) : category_theory.cosimplicial_object.augmented C ‚•§ category_theory.cosimplicial_object.augmented D
{C : Type u} [category_theory.category C] [category_theory.limits.has_pushouts C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.under X ‚•§ category_theory.under Y
{K : Type u} {V V‚ÇÅ : Type v} [division_ring K] [add_comm_group V] [module K V] [add_comm_group V‚ÇÅ] [module K V‚ÇÅ] (cond : module.rank K V = module.rank K V‚ÇÅ) : nonempty (V ‚âÉ‚Çó[K] V‚ÇÅ)
{R : Type u_1} [normed_ring R] [complete_space R] (x : RÀ£) : ‚àÄ·∂† (t : R) in nhds 0, ring.inverse (‚Üëx + t) = ring.inverse (1 + ‚Üëx‚Åª¬π * t) * ‚Üëx‚Åª¬π
 : decidable_eq expr
{p : ‚Ñï} {G : Type u_1} [group G] {H : Type u_2} [group H] {f : H ‚Üí* G} (hf : is_p_group p ‚Ü•(f.ker)) [fintype (sylow p G)] : fintype (sylow p H)
{E : Type u_2} [semi_normed_group E] [normed_space ‚Ñù E] : convex_on ‚Ñù set.univ has_norm.norm
 : golden_ratio‚Åª¬π = -golden_conj
{Œ± : Type u_3} {Œ≤ : Type u_4} [preorder Œ≤] {f : Œ≤ ‚Üí finset Œ±} (h : monotone f) (h' : ‚àÄ (x : Œ±), ‚àÉ (n : Œ≤), x ‚àà f n) : filter.tendsto f filter.at_top filter.at_top
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] (f : ‚ÑÇ ‚Üí E) (z w : ‚ÑÇ) (Hc : continuous_on f (set.interval z.re w.re √ó‚ÑÇ set.interval z.im w.im)) (Hd : differentiable_on ‚ÑÇ f (set.Ioo (linear_order.min z.re w.re) (linear_order.max z.re w.re) √ó‚ÑÇ set.Ioo (linear_order.min z.im w.im) (linear_order.max z.im w.im))) : (((‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üë(z.im) * complex.I)) - ‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üë(w.im) * complex.I)) + complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üë(w.re) + ‚Üëy * complex.I)) - complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üë(z.re) + ‚Üëy * complex.I) = 0
{Œ± : Sort u_1} {C : trunc Œ± ‚Üí Sort u_3} (f : Œ† (a : Œ±), C (trunc.mk a)) (h : ‚àÄ (a b : Œ±), eq.rec (f a) _ = f b) (q : trunc Œ±) : C q
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} (f : Œ± ‚âÉ. Œ≤) (g : Œ≤ ‚âÉ. Œ≥) : Œ± ‚âÉ. Œ≥
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type v} (f : J ‚Üí C) [category_theory.limits.has_coproduct f] [category_theory.limits.has_coproduct (Œª (j : J), G.obj (f j))] [category_theory.limits.preserves_colimit (category_theory.discrete.functor f) G] : G.obj (‚àê f) ‚âÖ ‚àê Œª (j : J), G.obj (f j)
{C : Type u} [category_theory.category C] {X Y : C} (J : category_theory.grothendieck_topology C) (S : category_theory.sieve X) (f : Y ‚ü∂ X) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] {a b : Œ±} {h : a ‚â§ b} [topological_space Œ±] [order_topology Œ±] [topological_space Œ≤] {f : ‚Ü•(set.Icc a b) ‚Üí Œ≤} (hf : continuous f) : continuous (set.Icc_extend h f)
{n : ‚Ñï} {C : fin (n + 1) ‚Üí Sort u_1} (hlast : C (fin.last n)) (hs : Œ† (i : fin n), C i.succ ‚Üí C (‚áëfin.cast_succ i)) (i : fin (n + 1)) : C i
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommRing) : Ring
{R‚ÇÉ : Type u_7} [comm_ring R‚ÇÉ] {n : Type u_11} [fintype n] (J J‚ÇÉ A A' : matrix n n R‚ÇÉ) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] : category_theory.monoidal.CommMon_functor_category_equivalence.inverse ‚ãô category_theory.monoidal.CommMon_functor_category_equivalence.functor ‚âÖ ùü≠ (C ‚•§ CommMon_ D)
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Œπ R M) [fintype Œπ] : basis ‚Ü•(finset.image ‚áëb finset.univ) R M
 : expr ‚Üí list name
{Œπ : Type u} (f : Œπ ‚Üí ordinal) : ordinal
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] {G H : C ‚•§ D} (Œ± : G ‚âÖ H) (F : D ‚•§ E) : G ‚ãô F ‚âÖ H ‚ãô F
(e : environment) (tgt rhs : expr) (cfg : simps_cfg) : tactic (list (expr √ó projection_data))
(l : Type u_4) (R : Type u‚ÇÇ) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (l ‚äï l) (l ‚äï l) R)
{Œ± : Type u} [pseudo_metric_space Œ±] [proper_space Œ±] : topological_space.second_countable_topology Œ±
(n : ‚Ñï) : composition_as_set n ‚âÉ finset (fin (n - 1))
{M : Type u_1} [comm_monoid M] (S : submonoid M) : localization S
 : tactic unit
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s : set Œ±} {a : Œ±} (H : is_least s a) : has_Inf.Inf s = a
{n : ‚Ñï} (c : composition n) (i : ‚Ñï) : ‚Ñï
{Œ± : Type u} : ‚Ñï ‚Üí seq Œ± ‚Üí list Œ±
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_noetherian R M] (f : M ‚Üí‚Çó[R] M) (s : function.surjective ‚áëf) : function.injective ‚áëf
{R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M ‚Üí‚Çó[R] M) {Œπ : Type w} [fintype Œπ] (b : basis Œπ R M) : (‚áë(linear_map.to_matrix b b) f).charpoly = f.charpoly
 : CompHaus ‚•§ Top
{V : Type u} {G : simple_graph V} (s : set (sym2 V)) {v w : V} (p : G.walk v w) (hp : ‚àÄ (e : sym2 V), e ‚àà p.edges ‚Üí e ‚àâ s) : (G.delete_edges s).walk v w
{R : Type u} [semiring R] {S : Type v} [semiring S] {f : R ‚Üí+* S} {s : S} (n : ‚Ñï) (h : s ‚àà set.range ‚áëf) : ‚áë(polynomial.monomial n) s ‚àà polynomial.lifts f
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] (n : ‚Ñï) (f : ùïú ‚Üí F) (x : ùïú) : F
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (e : K ‚âå J) : category_theory.limits.cocone F ‚âå category_theory.limits.cocone (e.functor ‚ãô F)
{Œ± : Type u_2} [has_neg Œ±] : has_neg (set Œ±)
 : ‚Ñï ‚Üí polynomial ‚Ñù
{G‚ÇÄ : Type u_2} [group_with_zero G‚ÇÄ] (a : G‚ÇÄ) : a * a / a = a
{n : ‚Ñï} : (vector ‚Ñï n ‚Üí ‚Ñï) ‚Üí Prop
{ùïú : Type u_1} {E : Type u_3} [normed_field ùïú] [add_comm_group E] [module ùïú E] {A : set E} [topological_space E] [has_continuous_smul ùïú E] (hA : balanced ùïú A) (h : 0 ‚àà interior A) : balanced ùïú (interior A)
(M : Type u_1) [monoid M] (X : Type u) [mul_action M X] : category_theory.action_category M X ‚•§ category_theory.single_obj M
{H : Type u_1} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] {H' : Type u_3} {M' : Type u_4} [topological_space H'] [topological_space M'] [charted_space H' M'] (P : (H ‚Üí H') ‚Üí set H ‚Üí H ‚Üí Prop) (f : M ‚Üí M') (x : M) : Prop
{Œ± : Type u} (f : Œ± ‚Üí Œ±) : Œ± ‚Üí lazy_list Œ±
{Œ± J : Type u} [category_theory.small_category J] [category_theory.fin_category J] [semilattice_inf Œ±] [order_top Œ±] (F : J ‚•§ Œ±) : category_theory.limits.limit_cone F
{M : Type u_3} [add_monoid M] [inhabited M] (l : list M) (h : l ‚â† list.nil) : l.head + l.tail.sum = l.sum
{p k : ‚Ñï} (hp : nat.prime p) : (p ^ k).factorization = finsupp.single p k
{Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ±] [preorder Œ±] [topological_space Œ≤] [preorder Œ≤] (f : Œ± ‚ÜíCo Œ≤) : C(Œ±, Œ≤)
{S : Type u_5} [semiring S] {M : Type u_6} [add_comm_monoid M] [module S M] {m : submodule S M} {f : M ‚Üí‚Çó[S] M} (h : linear_map.is_proj m f) : M ‚Üí‚Çó[S] ‚Ü•m
{Œ± : Type u_2} [has_mul Œ±] (a : Œ±) : Prop
 : ‚Ñï ‚Üí ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñï ‚Üí ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñï √ó ‚Ñ§ √ó ‚Ñ§
{Œ± : Type u_3} {Œ≤ : Type u_4} [lattice Œ±] [lattice Œ≤] : lattice_hom Œ± Œ≤ ‚âÉ lattice_hom Œ±·µí·µà Œ≤·µí·µà
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {t‚ÇÅ t‚ÇÇ : affine.triangle ‚Ñù P} {i‚ÇÅ i‚ÇÇ i‚ÇÉ j‚ÇÅ j‚ÇÇ j‚ÇÉ : fin 3} (hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ) (hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ) (hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ) (hj‚ÇÅ‚ÇÇ : j‚ÇÅ ‚â† j‚ÇÇ) (hj‚ÇÅ‚ÇÉ : j‚ÇÅ ‚â† j‚ÇÉ) (hj‚ÇÇ‚ÇÉ : j‚ÇÇ ‚â† j‚ÇÉ) (h‚ÇÅ : t‚ÇÇ.points j‚ÇÅ = t‚ÇÅ.orthocenter) (h‚ÇÇ : t‚ÇÇ.points j‚ÇÇ = t‚ÇÅ.points i‚ÇÇ) (h‚ÇÉ : t‚ÇÇ.points j‚ÇÉ = t‚ÇÅ.points i‚ÇÉ) : t‚ÇÇ.orthocenter = t‚ÇÅ.points i‚ÇÅ
{R : Type u} [semiring R] (p : polynomial R) : with_top ‚Ñï
{Œπ : Type u} {f g : Œπ ‚Üí nnreal} {p : ‚Ñù} (hp : 1 ‚â§ p) (hf : summable (Œª (i : Œπ), f i ^ p)) (hg : summable (Œª (i : Œπ), g i ^ p)) : summable (Œª (i : Œπ), (f i + g i) ^ p) ‚àß (‚àë' (i : Œπ), (f i + g i) ^ p) ^ (1 / p) ‚â§ (‚àë' (i : Œπ), f i ^ p) ^ (1 / p) + (‚àë' (i : Œπ), g i ^ p) ^ (1 / p)
(C : Type u) [category_theory.category C] : (category_theory.simplicial_object.augmented C)·µí·µñ ‚•§ category_theory.cosimplicial_object.augmented C·µí·µñ
 : vm ‚Ñï
(R : Type u) [semiring R] : Type u
(M : Type u_1) [has_mul M] : galois_insertion con_gen coe_fn
(V : Type (u+1)) [category_theory.large_category V] {G H : Mon} (f : G ‚ü∂ H) : Action V H ‚•§ Action V G
{Œ± Œ≤ : Preorder} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) (s : category_theory.limits.cocone F) : AddCommGroup.colimits.colimit_type F ‚Üí ‚Ü•(s.X)
(K : Type u) [field K] (V : FinVect K) : ùüô_ (FinVect K) ‚ü∂ V ‚äó FinVect.FinVect_dual K V
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (X Y : category_theory.center C) : category_theory.center C
 : (user_attribute unit)
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : Type w
{M : Type u_1} {A : Type u_4} {B : Type u_5} [monoid M] [add_monoid A] [distrib_mul_action M A] [add_monoid B] [has_scalar M B] (f : A ‚Üí+ B) (hf : function.surjective ‚áëf) (smul : ‚àÄ (c : M) (x : A), ‚áëf (c ‚Ä¢ x) = c ‚Ä¢ ‚áëf x) : distrib_mul_action M B
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (R : D ‚•§ C) [category_theory.reflective R] : category_theory.limits.preserves_limits_of_shape (category_theory.discrete pempty) (category_theory.left_adjoint R)
{Œ± : Type u} [pseudo_emetric_space Œ±] : setoid Œ±
{M : Type uM} {N : Type uN} {P : Type uP} {Q : Type uQ} [add_zero_class M] [add_zero_class N] [add_comm_monoid P] [add_zero_class Q] (f : M ‚Üí+ N ‚Üí+ P) (g : Q ‚Üí+ N) : M ‚Üí+ Q ‚Üí+ P
(B : Type u) [category_theory.bicategory B] : Prop
{K : Type u_1} [field K] {Œì‚ÇÄ : Type u_2} [linear_ordered_comm_group_with_zero Œì‚ÇÄ] [hv : valued K Œì‚ÇÄ] : uniform_space.completion K ‚Üí Œì‚ÇÄ
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {x : Œ±} {p : filter Œπ} {g : Œπ ‚Üí Œ±} [topological_space Œ±] (h : continuous_at f x) (hg : filter.tendsto g p (nhds x)) (hunif : ‚àÄ (u : set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí (‚àÉ (t : set Œ±) (H : t ‚àà nhds x), ‚àÄ·∂† (n : Œπ) in p, ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F n y) ‚àà u)) : filter.tendsto (Œª (n : Œπ), F n (g n)) p (nhds (f x))
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_images C] {A : C} (s : set (category_theory.subobject A)) : category_theory.subobject A
(R : Type u_1) [semiring R] [topological_space R] [t : topological_space RÀ£] : Prop
(R : Type u_1) [comm_ring R] (Œπ‚ÇÅ : Type u_2) (Œπ‚ÇÇ : Type u_3) [decidable_eq Œπ‚ÇÅ] [decidable_eq Œπ‚ÇÇ] (M‚ÇÅ : Œπ‚ÇÅ ‚Üí Type u_4) (M‚ÇÇ : Œπ‚ÇÇ ‚Üí Type u_5) [Œ† (i‚ÇÅ : Œπ‚ÇÅ), add_comm_group (M‚ÇÅ i‚ÇÅ)] [Œ† (i‚ÇÇ : Œπ‚ÇÇ), add_comm_group (M‚ÇÇ i‚ÇÇ)] [Œ† (i‚ÇÅ : Œπ‚ÇÅ), module R (M‚ÇÅ i‚ÇÅ)] [Œ† (i‚ÇÇ : Œπ‚ÇÇ), module R (M‚ÇÇ i‚ÇÇ)] : tensor_product R (direct_sum Œπ‚ÇÅ (Œª (i‚ÇÅ : Œπ‚ÇÅ), M‚ÇÅ i‚ÇÅ)) (direct_sum Œπ‚ÇÇ (Œª (i‚ÇÇ : Œπ‚ÇÇ), M‚ÇÇ i‚ÇÇ)) ‚âÉ‚Çó[R] direct_sum (Œπ‚ÇÅ √ó Œπ‚ÇÇ) (Œª (i : Œπ‚ÇÅ √ó Œπ‚ÇÇ), tensor_product R (M‚ÇÅ i.fst) (M‚ÇÇ i.snd))
{R : Type u_1} {M : Type u_3} {a b : R} [comm_semigroup R] [has_scalar R M] [is_scalar_tower R R M] : is_smul_regular M (a * b) ‚Üî is_smul_regular M a ‚àß is_smul_regular M b
(l : Type u_4) (R : Type u‚ÇÇ) [decidable_eq l] [comm_ring R] : matrix (l ‚äï l) (l ‚äï l) R
{m : Type u ‚Üí Type v} [monad m] {Œ± : Type u} (p : Œ± ‚Üí m (ulift bool)) : list Œ± ‚Üí m (option Œ±)
(n : ‚Ñï) (Œ± : Type u) : Type u
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] : graded_algebra (has_pow.pow (exterior_algebra.Œπ R).range)
{F : Type (max u‚ÇÄ v‚ÇÄ) ‚Üí Type u‚ÇÅ} {G : Type v‚ÇÄ ‚Üí Type v‚ÇÅ} [L : uliftable G F] [monad F] {Œ± : Type (max u‚ÇÄ v‚ÇÄ)} {Œ≤ : Type v‚ÇÄ} (x : F Œ±) (f : Œ± ‚Üí G Œ≤) : G Œ≤
{Œ± : Type u_2} {Œ≤ : Type u_3} (r : Œ± ‚Üí Œ≤ ‚Üí Prop) (s : set Œ±) : set Œ≤
{Œ± : Type u} {Œ≤ : Type v} [comm_ring Œ±] [has_zero Œ≤] [has_one Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ± ‚Üí Œ≤) (hf : function.surjective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ±), f (-x) = -f x) (sub : ‚àÄ (x y : Œ±), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ±) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : Œ±) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ±) (n : ‚Ñï), f (x ^ n) = f x ^ n) : comm_ring Œ≤
{Œ± : Type u_1} [monoid Œ±] {p q : Œ±} (hp : irreducible p) (hq : irreducible q) : p ‚à£ q ‚Üí q ‚à£ p
(tac1 tac2 : smt_tactic unit) : smt_tactic unit
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [fintype Œπ] (b : basis Œπ R M) : M ‚âÉ‚Çó[R] Œπ ‚Üí R
{R : Type u_1} {S : Type u_2} [comm_ring R] [nontrivial R] [comm_ring S] [is_domain S] [algebra R S] (H : algebra.is_integral R S) (hRS : function.injective ‚áë(algebra_map R S)) (hS : is_field S) : is_field R
{Œ± : Type u_1} {Œπ : Type u_4} [complete_lattice Œ±] (s : Œπ ‚Üí Œ±) : (‚®Ö (i : Œπ), s i) = ‚®Ö (t : finset Œπ) (i : Œπ) (H : i ‚àà t), s i
{R : Type u} [ring R] (s : subring R) {x y : R} (hx : x ‚àà s) (hy : y ‚àà s) : x - y ‚àà s
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream (generalized_continued_fraction.pair K)
{C : Type u} [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} {F F' : category_theory.limits.mono_factorisation f} (hF : category_theory.limits.is_image F) (hF' : category_theory.limits.is_image F') : F.I ‚âÖ F'.I
(a b : snum) : snum
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [category_theory.limits.has_pushout f g] : Z ‚ü∂ category_theory.limits.pushout f g
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {X X' Y : C} [category_theory.exact_pairing X' Y] (i : X ‚âÖ X') : category_theory.exact_pairing X Y
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] {S T : convex_cone ùïú E} (h : ‚àÄ (x : E), x ‚àà S ‚Üî x ‚àà T) : S = T
(K : Type u) [hring : comm_ring K] : ratfunc K ‚âÉ+* fraction_ring (polynomial K)
{p n k : ‚Ñï} (p_large : n < p ^ 2) : ‚áë((n.choose k).factorization) p ‚â§ 1
{R : Type u} [ring R] {L M N : Module R} (f : L ‚ü∂ M) [category_theory.limits.has_image f] (g : ‚Üë(category_theory.limits.image_subobject f) ‚ü∂ N) [category_theory.limits.has_cokernel g] {x y : ‚Ü•N} (l : ‚Ü•L) (w : x = y + ‚áëg (‚áë(category_theory.limits.factor_thru_image_subobject f) l)) : ‚áë(category_theory.limits.cokernel.œÄ g) x = ‚áë(category_theory.limits.cokernel.œÄ g) y
 : (user_attribute simp_lemmas)
(E' : Type u_1) [normed_group E'] [normed_space ‚Ñù E'] [finite_dimensional ‚Ñù E'] : nnreal
{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_3} [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] : has_sub (normed_group_hom V‚ÇÅ V‚ÇÇ)
{C : Type u} [category_theory.category C] (X : algebraic_geometry.PresheafedSpace C) : X ‚ü∂ X.restrict _
{Œ± : Type u} [pseudo_emetric_space Œ±] (f : ‚Ñï ‚Üí Œ±) (n : ‚Ñï) : has_edist.edist (f 0) (f n) ‚â§ (finset.range n).sum (Œª (i : ‚Ñï), has_edist.edist (f i) (f (i + 1)))
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {x : E} {n : with_top ‚Ñï} {s : set E} {f g : E ‚Üí F} (hf : cont_diff_within_at ùïú n f s x) (hg : cont_diff_within_at ùïú n g s x) : cont_diff_within_at ùïú n (Œª (x : E), f x - g x) s x
(Œπ : Sort u_1) (Œ± : Œπ ‚Üí Sort u_2) (Œ≤ : Œπ ‚Üí Sort u_3) [Œ† (i : Œπ), can_lift (Œ± i) (Œ≤ i)] : can_lift (Œ† (i : Œπ), Œ± i) (Œ† (i : Œπ), Œ≤ i)
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L) : t2_space (L ‚âÉ‚Çê[K] L)
{Œ± : Type u_2} [has_zero Œ±] : zero_hom Œ± (filter Œ±)
(n : Type u) (R : Type v) [decidable_eq n] [fintype n] [linear_ordered_comm_ring R] : subgroup (GL n R)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) (h : e.to_local_equiv.source = set.univ) : open_embedding ‚áëe
 : ‚àÉ (Œ± Œ≤ : Type) (IŒ± : topological_space Œ±) (IŒ≤ : topological_space Œ≤), compact_space Œ± ‚àß t1_space Œ≤ ‚àß ‚àÉ (f : Œ± ‚âÉ Œ≤), continuous ‚áëf ‚àß ¬¨continuous ‚áë(f.symm)
{G : Type u_1} {H : Type u_2} [group G] [group H] {f : G ‚Üí* H} (hf : function.surjective ‚áëf) (tG : monoid.is_torsion G) : monoid.is_torsion H
{G : Type u_1} {H : Type u_2} [add_group G] [add_group H] {f : G ‚Üí+ H} (hf : function.surjective ‚áëf) (tG : add_monoid.is_torsion G) : add_monoid.is_torsion H
 : ‚Ü•{a : ennreal | a ‚â† ‚ä§} ‚âÉ‚Çú nnreal
{R : Type u_1} {E : Type u_5} [semiring R] [semi_normed_group E] [module R E] : E ‚Üí‚Çó·µ¢[R] E
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ w)
(R : Type u_1) [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] (a : S) : Prop
{Œ± : Type u} [group Œ±] [fintype Œ±] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : fintype.card Œ± = p) : is_cyclic Œ±
{C : Type u} [category_theory.category C] {F : category_theory.limits.walking_cospan ‚•§ C} (t : category_theory.limits.cone F) : category_theory.limits.pullback_cone (F.map category_theory.limits.walking_cospan.hom.inl) (F.map category_theory.limits.walking_cospan.hom.inr)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] : (C ‚•§ Mon_ D) ‚•§ Mon_ (C ‚•§ D)
{Œ± : Type u} {C : with_one Œ± ‚Üí Sort u_1} (h‚ÇÅ : C 1) (h‚ÇÇ : Œ† (a : Œ±), C ‚Üëa) (n : with_one Œ±) : C n
{M : Type u_1} [add_zero_class M] {S T : add_submonoid M} (h : ‚àÄ (x : M), x ‚àà S ‚Üî x ‚àà T) : S = T
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space F] [complete_space E] {g : E ‚Üí‚Çó[ùïú] F} (hg : ‚àÄ (u : ‚Ñï ‚Üí E) (x : E) (y : F), filter.tendsto u filter.at_top (nhds x) ‚Üí filter.tendsto (‚áëg ‚àò u) filter.at_top (nhds y) ‚Üí y = ‚áëg x) : E ‚ÜíL[ùïú] F
(n : expr) (bounds : option expr √ó option expr) (e : expr) : tactic (option expr √ó option expr)
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_epi f] : category_theory.limits.cofork (ùüô X) (f ‚â´ category_theory.section_ f)
{A : Type u_1} [ring A] [algebra ‚Ñù A] : {I' // I' * I' = -1} ‚âÉ (‚ÑÇ ‚Üí‚Çê[‚Ñù] A)
{X : Type u_1} {Y : Type u_2} (T : Type u_3) [topological_space X] [compact_space X] [topological_space Y] [compact_space Y] [normed_group T] (f : C(X, Y)) : C(C(Y, T), C(X, T))
{Œ± : Type u} [topological_space Œ±] {S U : set Œ±} (hS : is_preirreducible S) (hU : is_open U) (h : (S ‚à© U).nonempty) : S ‚äÜ closure (S ‚à© U)
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] (p q : submodule R E) (h : is_compl p q) : (E ‚ß∏ p) ‚âÉ‚Çó[R] ‚Ü•q
 : Type (u+1)
{l : Type u_1} {m : Type u_2} {Œ± : Type v} [has_zero Œ±] [decidable_eq m] [decidable_eq l] (d : m ‚Üí Œ±) (e : l ‚Üí m) (he : function.injective e) : (matrix.diagonal d).minor e e = matrix.diagonal (d ‚àò e)
{M‚ÇÄ : Type u_1} [cancel_monoid_with_zero M‚ÇÄ] {a b : M‚ÇÄ} (h‚ÇÅ : b ‚â† 1) (h‚ÇÇ : a * b = a) : a = 0
{Œ± : Sort u} {C : Œ± ‚Üí Sort v} {r : Œ± ‚Üí Œ± ‚Üí Prop} (hwf : well_founded r) (F : Œ† (x : Œ±), (Œ† (y : Œ±), r y x ‚Üí C y) ‚Üí C x) (x : Œ±) : C x
(M : Type u) [normed_ring M] [star_ring M] [cstar_ring M] [module ‚ÑÇ M] [normed_algebra ‚ÑÇ M] [star_module ‚ÑÇ M] : Type
{M : Type u_1} [comm_monoid_with_zero M] {S : submonoid M} {N : Type u_2} [comm_monoid_with_zero N] {P : Type u_3} [comm_monoid_with_zero P] (f : S.localization_with_zero_map N) (g : M ‚Üí*‚ÇÄ P) (hg : ‚àÄ (y : ‚Ü•S), is_unit (‚áëg ‚Üëy)) : N ‚Üí*‚ÇÄ P
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] {j‚ÇÅ j‚ÇÇ : C} (f g h : j‚ÇÅ ‚ü∂ j‚ÇÇ) : j‚ÇÇ ‚ü∂ category_theory.is_filtered.coeq‚ÇÉ f g h
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (G : C ‚•§ D) [G.preserves_zero_morphisms] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_cokernel f] [category_theory.limits.has_cokernel (G.map f)] [i : category_theory.is_iso (category_theory.limits.cokernel_comparison f G)] : category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f 0) G
{a b : cardinal} (ha : cardinal.aleph_0 ‚â§ a) (hb : cardinal.aleph_0 ‚â§ b) : a * b = linear_order.max a b
{Œ± Œ≤ : Type} (t1 : omega.eqelim Œ±) (t2 : omega.eqelim Œ≤) (t3 : Œ± ‚Üí omega.eqelim Œ≤) : omega.eqelim Œ≤
(G : Type u) : Type u
{E : Type u_1} {Œ≤ : Type u_2} [add_comm_group E] [topological_space E] [module ‚Ñù E] [topological_add_group E] [has_continuous_smul ‚Ñù E] [ordered_add_comm_group Œ≤] [module ‚Ñù Œ≤] [ordered_smul ‚Ñù Œ≤] {f : E ‚Üí Œ≤} {a : E} (h_local_max : is_local_max f a) (h_conc : concave_on ‚Ñù set.univ f) (x : E) : f x ‚â§ f a
(Œì : Type u_1) [inhabited Œì] : Type u_1
(s : ‚Ñù) {b : ‚Ñù} (hb : 0 < b) : (Œª (x : ‚Ñù), x ^ s) =o[filter.at_top] Œª (x : ‚Ñù), real.exp (b * x)
(R : Type u) (Œπ : Type v) [comm_ring R] (L : Type w‚ÇÅ) (M : Œπ ‚Üí Type w) [lie_ring L] [lie_algebra R L] [Œ† (i : Œπ), add_comm_group (M i)] [Œ† (i : Œπ), module R (M i)] [Œ† (i : Œπ), lie_ring_module L (M i)] [Œ† (i : Œπ), lie_module R L (M i)] (j : Œπ) : direct_sum Œπ (Œª (i : Œπ), M i) ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M j
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_image f] : (category_theory.limits.image.mono_factorisation f).e = category_theory.limits.factor_thru_image f
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] : ‚ä•.fixing_subgroup = ‚ä§
{F : Type u_2} {E‚ÇÅ : Type u_3} [semi_normed_group F] [normed_group E‚ÇÅ] {R‚ÇÅ : Type u_4} [field R‚ÇÅ] [module R‚ÇÅ E‚ÇÅ] [module R‚ÇÅ F] [finite_dimensional R‚ÇÅ E‚ÇÅ] [finite_dimensional R‚ÇÅ F] (li : E‚ÇÅ ‚Üí‚Çó·µ¢[R‚ÇÅ] F) (h : finite_dimensional.finrank R‚ÇÅ E‚ÇÅ = finite_dimensional.finrank R‚ÇÅ F) : E‚ÇÅ ‚âÉ‚Çó·µ¢[R‚ÇÅ] F
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (h_obj : ‚àÄ (X : C), F.obj X = G.obj X) (h_map : ‚àÄ (X Y : C) (f : X ‚ü∂ Y), F.map f == G.map f) : F = G
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] {C : Type u} [category_theory.category C] {F : J ‚•§ K ‚•§ C} {D : category_theory.limits.diagram_of_cones F} (Q : Œ† (j : J), category_theory.limits.is_limit (D.obj j)) (c : category_theory.limits.cone (category_theory.uncurry.obj F)) : category_theory.limits.cone D.cone_points
(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : valued (function_field.Fqt_infty Fq) (with_zero (multiplicative ‚Ñ§))
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : Type w) [category_theory.category J] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ w w')
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_images C] (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.mono_over.exists f ‚âÖ category_theory.mono_over.map f
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {ùïú‚ÇÉ : Type u_3} (E : Type u_4) (F : Type u_6) (G : Type u_8) [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [nondiscrete_normed_field ùïú‚ÇÉ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] [normed_space ùïú‚ÇÉ G] (œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ) (œÉ‚ÇÇ‚ÇÉ : ùïú‚ÇÇ ‚Üí+* ùïú‚ÇÉ) {œÉ‚ÇÅ‚ÇÉ : ùïú ‚Üí+* ùïú‚ÇÉ} [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] [ring_hom_isometric œÉ‚ÇÇ‚ÇÉ] [ring_hom_isometric œÉ‚ÇÅ‚ÇÉ] [ring_hom_isometric œÉ‚ÇÅ‚ÇÇ] : (F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) ‚ÜíL[ùïú‚ÇÉ] (E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F) ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] G
{k : Type u_1} {G : Type u_2} [comm_semiring k] [monoid G] : representation k G k
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X ‚Ñù) {t : set ‚Ñù} {e : X ‚Üí Y} [hs : t.ord_connected] (hf : ‚àÄ (x : X), ‚áëf x ‚àà t) (hne : t.nonempty) (he : closed_embedding e) : ‚àÉ (g : bounded_continuous_function Y ‚Ñù), (‚àÄ (y : Y), ‚áëg y ‚àà t) ‚àß ‚áëg ‚àò e = ‚áëf
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D·µí·µñ) : C ‚•§ D
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R) : ‚áëg ‚àò ‚áëf = ‚áë(f ‚â´ g)
{R : Type u‚ÇÅ} [comm_ring R] (a b : R) : (a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2
{C : Type u‚ÇÅ} [category_theory.category C] {A B : C} (e : A ‚âÖ B) : category_theory.subobject A ‚âå category_theory.subobject B
{Œπ : Type u_1} {X : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), topological_space (X i)] {as bs cs : Œ† (i : Œπ), X i} (Œ≥‚ÇÄ : Œ† (i : Œπ), path.homotopic.quotient (as i) (bs i)) (Œ≥‚ÇÅ : Œ† (i : Œπ), path.homotopic.quotient (bs i) (cs i)) : (path.homotopic.pi Œ≥‚ÇÄ).comp (path.homotopic.pi Œ≥‚ÇÅ) = path.homotopic.pi (Œª (i : Œπ), (Œ≥‚ÇÄ i).comp (Œ≥‚ÇÅ i))
{p : ‚Ñï} {G : Type u_1} [group G] (hG : is_p_group p G) [hp : fact (nat.prime p)] (Œ± : Type u_2) [mul_action G Œ±] [fintype Œ±] [fintype ‚Ü•(mul_action.fixed_points G Œ±)] (hpŒ± : ¬¨p ‚à£ fintype.card Œ±) : (mul_action.fixed_points G Œ±).nonempty
{ùïú : Type u_1} {E : Type u_2} [ordered_ring ùïú] [add_comm_group E] [module ùïú E] (Q : affine_subspace ùïú E) : convex ùïú ‚ÜëQ
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (a : S) : ‚àÉ (b : ‚Ü•M), is_localization.is_integer R (‚Üëb ‚Ä¢ a)
{a b c : ‚Ñï} (h : a % c = b % c) : (a - b) % c = 0
{R : Type u_1} {X : Type u_2} {Y : Type u_3} [normed_field R] [semi_normed_group X] [semi_normed_group Y] [normed_space R X] [normed_space R Y] (f' : X ‚ÜíL[R] Y) : Prop
{Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ±] [preorder Œ±] [topological_space Œ≤] [preorder Œ≤] : has_coe_to_fun (Œ± ‚ÜíCo Œ≤) (Œª (_x : Œ± ‚ÜíCo Œ≤), Œ± ‚Üí Œ≤)
(J : Type u‚ÇÇ) [category_theory.category J] : setoid J
(z : ‚ÑÇ) : cau_seq ‚ÑÇ complex.abs
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [topological_space Œ±] [preorder Œ±] [topological_space Œ≤] [preorder Œ≤] [topological_space Œ≥] [preorder Œ≥] (f : Œ≤ ‚ÜíCo Œ≥) (g : Œ± ‚ÜíCo Œ≤) : Œ± ‚ÜíCo Œ≥
{R : Type u} {M : Type v} [ring R] [add_comm_group M] [module R M] (S : submodule R M) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Sort u_3} (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ≥) : Œ± ‚äï Œ≤ ‚Üí Œ≥
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [decidable_eq (associates Œ±)] (p : {a // irreducible a}) : associates.factor_set Œ± ‚Üí ‚Ñï
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D E : homological_complex V c} {f g : D ‚ü∂ E} (h : homotopy f g) (e : C ‚ü∂ D) : homotopy (e ‚â´ f) (e ‚â´ g)
{R : Type u} {L‚ÇÅ : Type v} [comm_ring R] [lie_ring L‚ÇÅ] [lie_algebra R L‚ÇÅ] : has_one (L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÅ)
(R : Type u) {B : Type v} [comm_ring R] [decidable_eq B] [fintype B] : B √ó B ‚Üí free_lie_algebra R (cartan_matrix.generators B)
{Œ± : Type u_1} [encodable Œ±] {n : ‚Ñï} : encodable (array n Œ±)
 : fact (finite_dimensional.finrank ‚Ñù ‚ÑÇ = 2)
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) [finite_dimensional K ‚Ü•E] : is_open ‚Üë(E.fixing_subgroup)
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) : Prop
(A : Type u_1) (B : out_param (Type u_2)) : Type (max u_1 u_2)
{M : Type u_1} [add_comm_monoid M] (f : ‚Ñï ‚Üí ‚Ñï ‚Üí M) (n : ‚Ñï) : (finset.nat.antidiagonal n).sum (Œª (ij : ‚Ñï √ó ‚Ñï), f ij.fst ij.snd) = (finset.range n.succ).sum (Œª (k : ‚Ñï), f k (n - k))
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} : galois_insertion l u ‚Üí galois_coinsertion (‚áëorder_dual.to_dual ‚àò u ‚àò ‚áëorder_dual.of_dual) (‚áëorder_dual.to_dual ‚àò l ‚àò ‚áëorder_dual.of_dual)
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] (X Y : C √ó C) : (category_theory.monoidal_category.tensor C).obj X ‚äó (category_theory.monoidal_category.tensor C).obj Y ‚ü∂ (category_theory.monoidal_category.tensor C).obj (X ‚äó Y)
{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] (k : ‚Ñï) (h : ‚àÄ (v : V), k ‚â§ G.degree v) : k ‚â§ G.min_degree
(H : Type u_1) [topological_space H] (M : Type u_2) [topological_space M] [charted_space H M] (H' : Type u_3) [topological_space H'] (M' : Type u_4) [topological_space M'] [charted_space H' M'] : charted_space (model_prod H H') (M √ó M')
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) [category_theory.is_filtered J] {x y y' : Œ£ (j : J), ‚Ü•(F.obj j)} (hyy' : category_theory.limits.types.filtered_colimit.rel (F ‚ãô category_theory.forget AddMon) y y') : AddMon.filtered_colimits.colimit_add_aux F x y = AddMon.filtered_colimits.colimit_add_aux F x y'
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_equiv Œ± Œ≤) (hc : continuous_on ‚áëe e.source) (ho : is_open_map ‚áëe) (hs : is_open e.source) : local_homeomorph Œ± Œ≤
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] (f : ‚ÑÇ ‚Üí E) (z w : ‚ÑÇ) (H : differentiable_on ‚ÑÇ f (set.interval z.re w.re √ó‚ÑÇ set.interval z.im w.im)) : (((‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üë(z.im) * complex.I)) - ‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üë(w.im) * complex.I)) + complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üë(w.re) + ‚Üëy * complex.I)) - complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üë(z.re) + ‚Üëy * complex.I) = 0
(G : Type u_1) : Type u_1
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R) (a : ‚Ü•P) : ‚áë(f ‚â´ g) a = ‚áëg (‚áëf a)
{n : ‚Ñï} {Œ± : Type u_1} {v w : vector Œ± n} (h : ‚àÄ (m : fin n), v.nth m = w.nth m) : v = w
{Œ± : Type u_1} [emetric_space Œ±] : emetric_space Œ±·µÉ·µí·µñ
{Œπ : Type u_1} [decidable_eq Œπ] (R : Type u_4) [comm_semiring R] (s : Œπ ‚Üí Type u_7) [Œ† (i : Œπ), add_comm_monoid (s i)] [Œ† (i : Œπ), module R (s i)] : Type (max u_4 u_1 u_7)
{G : Type u_1} [add_group G] (H K : add_subgroup G) : add_subgroup ‚Ü•K
{Œ± : Type u} : free_magma Œ± ‚Üí ‚Ñï
{M : Type u_1} {N : Type u_2} [semi_normed_group M] [semi_normed_group N] (f : normed_group_hom M N) : Prop
{R : Type u} [field R] [star_ring R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y
(Œ± : Type u_1) (Œ≤ : Type u_2) [measurable_space Œ±] [measurable_space Œ≤] [unique Œ±] [unique Œ≤] : Œ± ‚âÉ·µê Œ≤
{Œ± Œ≤ : Type} (tac1 : tactic Œ±) (tacs2 : Œ± ‚Üí list (tactic Œ≤)) : tactic (list Œ≤)
(Œ± : Type u) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) : list (Œ£ (a : Œ±), Œ≤ a) ‚Üí list (Œ£ (a : Œ±), Œ≤ a)
{G : Type u} [add_monoid G] {H : Type v} [add_monoid H] (f : G ‚Üí+ H) {x : G} (h : is_of_fin_add_order x) : is_of_fin_add_order (‚áëf x)
(k : Type u_1) [division_ring k] {Œπ : Type u_4} (s : finset Œπ) : finset.centroid_weights_indicator k s = ‚Üës.indicator (finset.centroid_weights k s)
{Œπ : Type u_1} {Œπ' : Type u_2} {R : Type u_3} {M : Type u_5} {M' : Type u_6} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid M'] [module R M'] (b : basis Œπ R M) (b' : basis Œπ' R M') (e : Œπ ‚âÉ Œπ') : M ‚âÉ‚Çó[R] M'
{Œ± : Type u_1} [complete_lattice Œ±] {a : Œ±} {s : set Œ±} : a ‚äî has_Inf.Inf s ‚â§ ‚®Ö (b : Œ±) (H : b ‚àà s), a ‚äî b
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (l : list (sigma Œ≤)) : Prop
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {R : ‚Ñù} {c w : ‚ÑÇ} {f : ‚ÑÇ ‚Üí E} (hd : differentiable_on ‚ÑÇ f (metric.closed_ball c R)) (hw : w ‚àà metric.ball c R) : ‚àÆ (z : ‚ÑÇ) in C(c, R), (z - w)‚Åª¬π ‚Ä¢ f z = (2 * ‚Üëreal.pi * complex.I) ‚Ä¢ f w
(R : Type u) [comm_semiring R] (n : ‚Ñï) : mv_polynomial (fin (n + 1)) R ‚âÉ‚Çê[R] polynomial (mv_polynomial (fin n) R)
{C : Type u} [category_theory.category C] [category_theory.concrete_category C] [category_theory.limits.has_limits C] [category_theory.reflects_isomorphisms (category_theory.concrete_category.forget C)] [category_theory.limits.preserves_limits (category_theory.concrete_category.forget C)] {X : Top} (F : Top.sheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) (sf : Œ† (i : Œπ), ‚Ü•(F.val.obj (opposite.op (U i)))) (h : F.val.is_compatible U sf) : ‚àÉ! (s : ‚Ü•(F.val.obj (opposite.op (supr U)))), F.val.is_gluing U sf s
{V : Type u} (G : simple_graph V) (Œ± : Type v) : Type (max u v)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape J C] : category_theory.limits.lim ‚ãô category_theory.yoneda ‚ãô (category_theory.whiskering_right C·µí·µñ (Type v) (Type (max v u‚ÇÅ))).obj category_theory.ulift_functor ‚âÖ category_theory.cones J C
{Œ± : Type u_1} [preorder Œ±] (a : ‚Ñï ‚Üío Œ±) : Œ±
(p : interactive.parse interactive.types.texpr) : tactic unit
(V : Type (u+1)) [category_theory.large_category V] (G : Mon) : Action V G ‚•§ V
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [semiring k] [add_zero_class G] : k √ó multiplicative G ‚Üí* add_monoid_algebra k G
(G : Type u_1) [group G] [is_free_group G] : G ‚âÉ* free_group (is_free_group.generators G)
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ≤ ‚Üí Œ≥} {x : Œ±} {y : Œ≤} (hf : continuous_at f y) : continuous_at (Œª (x : Œ± √ó Œ≤), f x.snd) (x, y)
(d : declaration) (new_name : name) : tactic unit
{Œ± : Type u_1} {l : filter Œ±} {p : Œ± ‚Üí Prop} : (‚àÄ·∂† (s : set Œ±) in l.small_sets, ‚àÄ (x : Œ±), x ‚àà s ‚Üí p x) ‚Üí (‚àÄ·∂† (x : Œ±) in l, p x)
{Œ± : Type u} (s : wseq Œ±) : Prop
(X : Type u_1) [topological_space X] [compact_space X] [t2_space X] [totally_disconnected_space X] : Profinite
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) [category_theory.is_filtered J] (j : J) : F.obj j ‚ü∂ AddMon.filtered_colimits.colimit F
(sym : interactive.parse (interactive.with_desc ‚Üë"‚Üê" (optional (lean.parser.tk "<-")))) (r : interactive.parse interactive.types.texpr) (n : interactive.parse (optional (lean.parser.tk "using" *> lean.parser.small_nat))) : tactic unit
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : Œπ ‚Üí P} (hi : affine_independent k p) {s : finset Œπ} {sm : submodule k V} [finite_dimensional k ‚Ü•sm] (hle : vector_span k ‚Üë(finset.image p s) ‚â§ sm) (hc : s.card = finite_dimensional.finrank k ‚Ü•sm + 1) : vector_span k ‚Üë(finset.image p s) = sm
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ‚ü∂ Q) : category_theory.epi (category_theory.abelian.factor_thru_image f)
{M : Type uM} {N : Type uN} {P : Type uP} {mM : add_zero_class M} {mN : add_zero_class N} {mP : add_comm_monoid P} : (M ‚Üí+ N ‚Üí+ P) ‚Üí+ N ‚Üí+ M ‚Üí+ P
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} : metric.bounded s ‚Üî emetric.diam s ‚â† ‚ä§
{Œ± : Type u} (f : Œ± ‚Üí Œ±) (x : Œ±) : Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {x : E} : mdifferentiable_at (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f x ‚Üî differentiable_at ùïú f x
{Œ± : Type u_1} {l l' : list Œ±} (f : ‚Ñï ‚Ü™o ‚Ñï) (hf : ‚àÄ (ix : ‚Ñï), l.nth ix = l'.nth (‚áëf ix)) : l <+ l'
(ic qc : tactic.instance_cache) (cz_inst a' : expr) : tactic (tactic.instance_cache √ó tactic.instance_cache √ó expr √ó expr)
{X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra ‚Ñù C(X, ‚Ñù)) (w : A.separates_points) : A.topological_closure = ‚ä§
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x y z : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (hz : z ‚â† 0) : o.oangle x z - o.oangle x y = o.oangle y z
{x y z : ‚Ñ§} (h : pythagorean_triple x y z) : Prop
(z : upper_half_plane) : ‚Ñù
{Œ± : Type u} [has_repr Œ±] : Œ± ‚Üí string
(env : environment) (linter_name decl_name : name) (warning : string) : option string
{Œπ : Type u_1} (l u : Œπ ‚Üí ‚Ñù) : with_bot (box_integral.box Œπ)
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : affine_span k set.univ = ‚ä§
{ùïú : Type u_1} [linear_ordered_field ùïú] {s : set ùïú} {f : ùïú ‚Üí ùïú} (hf : convex_on ùïú s f) {x y z : ùïú} (hx : x ‚àà s) (hz : z ‚àà s) (hxy : x < y) (hyz : y < z) : (f y - f x) / (y - x) ‚â§ (f z - f y) / (z - y)
(rule : expr) (ns : list name) : tactic unit
(a b : ‚Ñù) : (polynomial_functions (set.Icc a b)).topological_closure = ‚ä§
(n : ‚Ñï) : finset (‚Ñï √ó ‚Ñï)
(R : Type u_1) [ordered_semiring R] [nontrivial R] : submonoid R
{C : Type u‚ÇÅ} [category_theory.category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (S : category_theory.sieve X) : category_theory.equalizer.first_obj P ‚áëS ‚ü∂ category_theory.equalizer.sieve.second_obj P S
{G : Type u_1} [group G] {H : subgroup G} {A : Type u_2} [comm_group A] (œï : ‚Ü•H ‚Üí* A) (S T : ‚Ü•(subgroup.left_transversals ‚ÜëH)) [fintype (G ‚ß∏ H)] : A
 : option pexpr ‚Üí tactic (tactic.simp_config_ext √ó format)
{C : Type u} [category_theory.category C] [‚àÄ (n : ‚Ñï) (f : category_theory.arrow C), category_theory.limits.has_wide_pushout f.left (Œª (i : ulift (fin (n + 1))), f.right) (Œª (i : ulift (fin (n + 1))), f.hom)] (F : category_theory.arrow C) (X : category_theory.cosimplicial_object.augmented C) (G : F ‚ü∂ category_theory.cosimplicial_object.augmented.to_arrow.obj X) : F.augmented_cech_conerve ‚ü∂ X
{C : Type u} {A : Type u_1} [category_theory.category C] {D : Type u_2} [category_theory.category D] [add_monoid A] [category_theory.has_shift D A] (F : C ‚•§ D) [category_theory.full F] [category_theory.faithful F] (s : A ‚Üí C ‚•§ C) (i : Œ† (i : A), s i ‚ãô F ‚âÖ F ‚ãô category_theory.shift_functor D i) (m : A) : s m ‚ãô F ‚âÖ F ‚ãô category_theory.shift_functor D m
(a b : ‚Ñù) (f : C(‚Ü•(set.Icc a b), ‚Ñù)) : f ‚àà (polynomial_functions (set.Icc a b)).topological_closure
(C : Type u) [category_theory.category C] {Œ≤ Œ≥ : Type w} (e : Œ≤ ‚âÉ Œ≥) : category_theory.graded_object Œ≤ C ‚âå category_theory.graded_object Œ≥ C
{R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] {Œπ : Type u_3} (b : affine_basis Œπ R E) : ‚áë(convex_hull R) (set.range b.points) = {x : E | ‚àÄ (i : Œπ), 0 ‚â§ ‚áë(b.coord i) x}
{Œ± : Type u} {p : Œ± ‚Üí Prop} {a : Œ±} (h : a ‚àà {x : Œ± | p x}) : p a
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (q : Œ† (i : fin (n + 1)), Œ± i) (z : Œ± 0) : fin.tail (function.update q 0 z) = fin.tail q
{Œ± : Type u_1} [decidable_eq Œ±] : monotone finset.shadow
(R : Type u_1) (A : Type u_2) [comm_semiring R] : pi.const_ring_hom A R = algebra_map R (A ‚Üí R)
{M : Type u_1} (S : set M) [has_mul M] : set M
(E : Type u_1) [add_comm_group E] [has_norm E] (C : normed_group.core E) : normed_group E
{m : Type ‚Üí Type v} [monad m] {Œ± : Type u} (p : Œ± ‚Üí m bool) (as : list Œ±) : m bool
 : tactic name
 : has_div ordinal
(H : Type u) [topological_space H] : structure_groupoid H
(Œ± : Type u_2) : Type u_2
{R : Type u_1} {S : Type u_3} [comm_semiring R] [comm_semiring S] : comm_semiring (R √ó S)
 : Type
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} : category_theory.presieve.is_sheaf_for P R ‚Üí category_theory.presieve.is_separated_for P R
 : PartialOrder ‚•§ PartialOrder
{Œ± : Type u} [has_add Œ±] {Œ≤ : Type v} [has_add Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) : add_magma.free_add_semigroup Œ± ‚Üí add_magma.free_add_semigroup Œ≤
(id : module_info.module_id) (decl_name : name) : environment
{M : Type u_1} [add_monoid M] : add_units M·µÉ·µí·µñ ‚âÉ+ (add_units M)·µÉ·µí·µñ
{G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (n : ‚Ñ§) (g : G) : ‚áëf (n ‚Ä¢ g) = n ‚Ä¢ ‚áëf g
{R : Type u} [semiring R] (p : polynomial R) : ‚Ñï
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] (l : multiset Œ±) (hp : ‚àÉ! (a : Œ±), a ‚àà l ‚àß p a) : {a // a ‚àà l ‚àß p a}
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) : add_subsemigroup N
(A : out_param (Type u)) (B : Type v) : Type (max (u+1) (v+1))
(R : CommRing) : algebraic_geometry.LocallyRingedSpace
(Œ± : Type u_1) [ht : topological_space Œ±] [h : polish_space Œ±] : upgraded_polish_space Œ±
{Œ± : Type u} [omega_complete_partial_order Œ±] {Œ≤ Œ≥ : Type v} (f : Œ± ‚ÜíùíÑ part (Œ≤ ‚Üí Œ≥)) (g : Œ± ‚ÜíùíÑ part Œ≤) : Œ± ‚ÜíùíÑ part Œ≥
{M : Type u_5} [monoid M] {A : Type u_6} [add_monoid A] [distrib_mul_action M A] {B : Type u_8} [add_monoid B] [distrib_mul_action M B] (f : A ‚Üí[M] B) (g : B ‚Üí A) (h‚ÇÅ : function.left_inverse g ‚áëf) (h‚ÇÇ : function.right_inverse g ‚áëf) : B ‚Üí[M] A
(k : Type u) [field k] : Type u
(b : bool) : tactic unit
 : omega.nat.preform ‚Üí option (omega.nat.preterm √ó omega.nat.preterm)
(n : ‚Ñï) : ‚Üë(n.totient) = ‚Üën * n.factors.to_finset.prod (Œª (p : ‚Ñï), 1 - (‚Üëp)‚Åª¬π)
(Œ± : Type u) [cancel_comm_monoid_with_zero Œ±] : Type u
{C : Type u‚ÇÅ} [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] [‚àÄ (a b : C), category_theory.limits.has_coproducts_of_shape (a ‚ü∂ b) D] (c : C) : D ‚•§ C ‚•§ D
{E : Type u_1} [add_comm_group E] [module ‚Ñù E] (p : seminorm ‚Ñù E) : gauge (p.ball 0 1) = ‚áëp
{R : Type u_1} {Œ± : Type u_2} (G : simple_graph Œ±) [has_zero R] [has_one R] [decidable_eq Œ±] [decidable_rel G.adj] {a : Œ±} {e : sym2 Œ±} : simple_graph.inc_matrix R G a e = ite (e ‚àà G.incidence_set a) 1 0
(Œ± : Type u_1) : Type u_1
{G : Type u_1} [group G] (H : ‚Ñï ‚Üí subgroup G) : Prop
 : expr_lens ‚Üí list expr_lens.dir ‚Üí expr ‚Üí option (expr_lens √ó expr)
{m : Type u} {n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) (B : matrix n m Œ±) [invertible A] : (‚Öü A).mul (A.mul B) = B
(f : ordinal ‚Üí ordinal) : ordinal ‚Üí ordinal
(p : ‚Ñï) [hp : fact (nat.prime p)] {q : ‚Ñö} (h : padic_norm p q = 0) : q = 0
(m : Type u ‚Üí Type u_1) (Œ± : Type u) : category_theory.Kleisli m
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) : o.oangle (-x) (-y) = o.oangle x y
{Œ± : Type u} [preorder Œ±] [no_max_order Œ±] (a : Œ±) : ‚àÉ (f : ‚Ñï ‚Üí Œ±), strict_mono f ‚àß f 0 = a
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
(R : Type u) (L : Type v) (M : Type w) (N : Type w‚ÇÅ) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [add_comm_group N] [module R M] [module R N] [lie_ring_module L M] [lie_ring_module L N] [lie_module R L M] [lie_module R L N] : Type (max w w‚ÇÅ)
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s : set Œ±} {b : Œ±} (hs : s.nonempty) (H : ‚àÄ (a : Œ±), a ‚àà s ‚Üí a ‚â§ b) (H' : ‚àÄ (w : Œ±), w < b ‚Üí (‚àÉ (a : Œ±) (H : a ‚àà s), w < a)) : has_Sup.Sup s = b
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (G : D ‚•§ C) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{Œ± : Type u_1} : sym Œ± 0
(p : polynomial ‚Ñö) : (p.root_set ‚ÑÇ).to_finset.card = (p.root_set ‚Ñù).to_finset.card + (‚áë(polynomial.gal.gal_action_hom p ‚ÑÇ) (‚áë(polynomial.gal.restrict p ‚ÑÇ) (alg_equiv.restrict_scalars ‚Ñö complex.conj_ae))).support.card
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommSemiRing) : category_theory.limits.cocone F
(Œ± : Type u_1) : Type u_1
(extra_lems : list tactic.simp_arg_type) (h : expr) : tactic expr
(z : upper_half_plane) : filter.tendsto (Œª (p : fin 2 ‚Üí ‚Ñ§), ‚áëcomplex.norm_sq (‚Üë(p 0) * ‚Üëz + ‚Üë(p 1))) filter.cofinite filter.at_top
{Œ± : Type u_1} {Œ≤ : Type u_2} (e e' : local_equiv Œ± Œ≤) (hs : disjoint e.source e'.source) (ht : disjoint e.target e'.target) [Œ† (x : Œ±), decidable (x ‚àà e.source)] [Œ† (y : Œ≤), decidable (y ‚àà e.target)] : local_equiv Œ± Œ≤
(k : Type u_1) (A : Type u_2) [comm_semiring k] [semiring A] [algebra k A] {G : Type u_3} {H : Type u_4} {F : Type u_5} [has_mul G] [has_mul H] [mul_hom_class F G H] (f : F) : monoid_algebra A G ‚Üí‚Çô‚Çê[k] monoid_algebra A H
(red : tactic.transparency) : list (expr √ó ‚Ñï) ‚Üí list expr ‚Üí native.rb_map linarith.monom ‚Ñï ‚Üí tactic (list linarith.comp √ó list (expr √ó ‚Ñï) √ó native.rb_map linarith.monom ‚Ñï)
{Œ± : Type u_2} [has_mul Œ±] [has_distrib_neg Œ±] : has_distrib_neg (set Œ±)
{p : ‚Ñï} [hp : fact (nat.prime p)] : witt_vector.is_poly p (Œª (R : Type u_1) (_Rcr : comm_ring R), ‚áëwitt_vector.verschiebung)
{Œ± : Sort u_1} {Œ≤ : Sort u_2} [sa : setoid Œ±] [sb : setoid Œ≤] (f : Œ± ‚Üí Œ≤) (h : (has_equiv.equiv ‚áí has_equiv.equiv) f f) : quotient sa ‚Üí quotient sb
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type v
{Œπ : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] [paracompact_space X] (hs : is_closed s) (U : Œπ ‚Üí set X) (ho : ‚àÄ (i : Œπ), is_open (U i)) (hU : s ‚äÜ ‚ãÉ (i : Œπ), U i) : ‚àÉ (f : bump_covering Œπ X s), f.is_subordinate U
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_pullbacks C] {X Y : C} (g : Y ‚ü∂ X) [category_theory.mono g] (f‚ÇÅ f‚ÇÇ : category_theory.subobject Y) : (category_theory.subobject.map g).obj (f‚ÇÅ ‚äì f‚ÇÇ) = (category_theory.subobject.map g).obj f‚ÇÅ ‚äì (category_theory.subobject.map g).obj f‚ÇÇ
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) [category_theory.is_filtered J] (j : J) : 0 = AddMon.filtered_colimits.M.mk F ‚ü®j, 0‚ü©
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x : Œ±} (h : is_closed s) (hs : s.nonempty) : x ‚àà s ‚Üî metric.inf_dist x s = 0
{M : Type uM} {N : Type uN} {P : Type uP} {mM : mul_one_class M} {mN : mul_one_class N} {mP : comm_monoid P} (f : M ‚Üí* N ‚Üí* P) : N ‚Üí* M ‚Üí* P
{Œ± : Type u} {p : Œ± ‚Üí Prop} [decidable_pred p] : equiv.perm (subtype p) ‚Üí* equiv.perm Œ±
(t : conv.interactive.itactic) : conv unit
{Œ± Œ≤ : GroupWithZero} (e : ‚Ü•Œ± ‚âÉ* ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
(Œ± : Type u_1) {Œ≤ : Type u_2} (q : two_pointing Œ≤) [nonempty Œ±] : two_pointing (Œ± ‚Üí Œ≤)
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (s : submonoid M) (t : submonoid N) : ‚Ü•(s.prod t) ‚âÉ* ‚Ü•s √ó ‚Ü•t
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (ùïú' : Type u_10) [normed_ring ùïú'] [normed_algebra ùïú ùïú'] : ùïú' ‚ÜíL[ùïú] ùïú' ‚ÜíL[ùïú] ùïú'
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (S : add_submonoid M) (f : M ‚Üí+ N) (hf : function.injective ‚áëf) : ‚Ü•S ‚âÉ+ ‚Ü•(add_submonoid.map f S)
(L : Type u_1) [topological_space L] [has_inf L] : Prop
{ùïú : Type u_1} {X : Type u_2} [is_R_or_C ùïú] [topological_space X] {A : subalgebra ùïú C(X, ùïú)} (hA : A.separates_points) (hA' : continuous_map.conj_invariant_subalgebra (subalgebra.restrict_scalars ‚Ñù A)) : ((subalgebra.restrict_scalars ‚Ñù A).comap' (alg_hom.comp_left_continuous ‚Ñù is_R_or_C.of_real_am is_R_or_C.continuous_of_real)).separates_points
{M : Type u_1} [add_monoid M] [distrib_mul_action ‚Ñù M] : distrib_mul_action nnreal M
{X : Type u} {Y : Type v} [metric_space X] [metric_space Y] : isometry sum.inl
{Œì : Type u_1} {R : Type u_2} [partial_order Œì] [add_comm_monoid R] {Œ± : Type u_3} {Œ≤ : Type u_4} (s : hahn_series.summable_family Œì R Œ±) (f : Œ± ‚Ü™ Œ≤) : hahn_series.summable_family Œì R Œ≤
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {E' : Type u_7} [inner_product_space ùïú E'] (f : E ‚âÉ‚Çó[ùïú] E') (h : ‚àÄ (x y : E), has_inner.inner (‚áëf x) (‚áëf y) = has_inner.inner x y) : E ‚âÉ‚Çó·µ¢[ùïú] E'
{k : Type u‚ÇÇ} [ring k] : inhabited (affine_basis punit k punit)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (d : D) : (category_theory.costructured_arrow F.op (opposite.op d))·µí·µñ ‚•§ category_theory.structured_arrow d F
(s b : ‚Ñù) (hb : 0 < b) : filter.tendsto (Œª (x : ‚Ñù), x ^ s * real.exp (-b * x)) filter.at_top (nhds 0)
{ùïú : Type u_3} [field ùïú] {r : ‚Ñï} (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) : list (matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú)
{M : Type u_1} [mul_one_class M] {A : Type u_4} [set_like A M] [hA : submonoid_class A M] (S' : A) : has_one ‚Ü•S'
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) (X Y : C) [category_theory.limits.has_binary_product X Y] [category_theory.limits.has_binary_product (G.obj X) (G.obj Y)] [category_theory.limits.preserves_limit (category_theory.limits.pair X Y) G] : G.obj (X ‚®Ø Y) ‚âÖ G.obj X ‚®Ø G.obj Y
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) (j : J) : F.obj j ‚ü∂ AddCommGroup.colimits.colimit F
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} [proper_space Œ±] (h : metric.bounded s) : is_compact (closure s)
{Œ± : Type u_1} {M : Type u_4} [has_one M] (s : set Œ±) (f : Œ± ‚Üí M) : Œ± ‚Üí M
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) : ‚Ü•s ‚Üí+* R
 : tactic.itauto.prop ‚Üí tactic.itauto.prop ‚Üí tactic.itauto.prop
{Œπ : Type u_1} {p : ‚Ñù} [fact_one_le_p : fact (1 ‚â§ p)] (ùïú : Type u_2) (Œ≤ : Œπ ‚Üí Type u_4) [fintype Œπ] [normed_field ùïú] [Œ† (i : Œπ), semi_normed_group (Œ≤ i)] [Œ† (i : Œπ), normed_space ùïú (Œ≤ i)] : pi_Lp p Œ≤ ‚âÉ‚Çó[ùïú] Œ† (i : Œπ), Œ≤ i
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {l : filter Œ±} (f : l.germ Œ≤) {lc : filter Œ≥} (g : Œ≥ ‚Üí Œ±) (hg : filter.tendsto g lc l) : lc.germ Œ≤
{G : Type u_1} [semi_normed_group G] {H : Type u_2} [semi_normed_group H] (f : normed_group_hom G H) : normed_group_hom (uniform_space.completion G) (uniform_space.completion H)
(Œ± : Type u_3) [has_le Œ±] : Type u_3
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {X Y : C} [category_theory.monoidal_category.lift_obj X] [category_theory.monoidal_category.lift_obj Y] (f : X ‚ü∂ Y) : Type u
{Œ± : Type u} [partial_order Œ±] {a b : Œ±} (hab : a ‚â§ b) (hba : ¬¨a < b) : a = b
{Œ± : Type u} {Œ≤ : Type v} {s : set Œ±} {f : Œ± ‚Üí Œ≤} : set.inj_on f s ‚Üí function.injective (s.restrict f)
{C : Type u} [category_theory.category C] {X : C} {s : category_theory.limits.cone (category_theory.functor.empty C)} (P : category_theory.limits.is_limit s) {t : category_theory.limits.binary_fan X s.X} (Q : category_theory.limits.is_limit t) : t.X ‚âÖ X
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [linear_order Œ≤] {f g : Œ± ‚Üí Œ≤} (hf : monotone f) (hg : monotone g) : monotone (Œª (x : Œ±), linear_order.max (f x) (g x))
{A : Type u_1} {B : Type u_2} [i : set_like A B] {p q : A} (h : ‚àÄ (x : B), x ‚àà p ‚Üî x ‚àà q) : p = q
(v : ‚Ñï ‚Üí ‚Ñï) : omega.nat.preform ‚Üí Prop
(tac : tactic.interactive.itactic) : tactic unit
(X Y : Pointed) : Type u
{Œ± : Type u_1} [semilattice_inf Œ±] : inf_hom Œ± (lower_set Œ±)
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x : V) : 2 ‚Ä¢ o.oangle (-x) x = 0
{Œ± : Type u_1} [preorder Œ±] {Œ≤ Œ≥ : Type u_2} (f : Œ± ‚Üío part Œ≤) (g : Œ± ‚Üío Œ≤ ‚Üí part Œ≥) : Œ± ‚Üío part Œ≥
{X : Type u_1} (to_prod : X √ó X) : Bipointed
(R : Type u‚ÇÅ) (L : Type u‚ÇÇ) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type (max u‚ÇÅ u‚ÇÇ)
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [add_comm_monoid Œπ] [graded_monoid.gcomm_monoid A] : comm_monoid (A 0)
{Œ± : Type u_1} [has_compl Œ±] [has_sup Œ±] (a b : Œ±) : Œ±
 : has_sub nonote
 : Type
(k : ‚Ñï) (v : ‚Ñï ‚Üí ‚Ñ§) (as : list ‚Ñ§) : ‚Ñ§
 : list ‚Ñï ‚Üí ‚Ñï ‚Üí list ‚Ñï
{C : Type u‚ÇÅ} [category_theory.category C] (T : category_theory.monad C) : C ‚•§ T.algebra
{R : Type u} [semiring R] {S : Type v} [semiring S] (f : R ‚Üí+* S) : polynomial.X ‚àà polynomial.lifts f
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [linear_ordered_field ùïú] [add_comm_group E] [linear_ordered_add_comm_group Œ≤] [module ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : convex_on ùïú (‚áë(convex_hull ùïú) s) f) {x : E} (hx : x ‚àà ‚áë(convex_hull ùïú) s) : ‚àÉ (y : E) (H : y ‚àà s), f x ‚â§ f y
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : affine.simplex k P 0
(p : ‚Ñï) : Type
(A B : Class) : Prop
{Œ± : Type u} {Œ≤ : Type v} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} [f.ne_bot] (h : filter.tendsto u f (nhds a)) : f.limsup u = a
(R : Type u_1) [comm_semiring R] {X : Type u_2} : X ‚Üí free_algebra R X
{R : Type u_1} [semiring R] {Q : laurent_polynomial R ‚Üí Prop} (f : laurent_polynomial R) (Qf : ‚àÄ {f : polynomial R} {n : ‚Ñï}, Q (‚áëpolynomial.to_laurent f * laurent_polynomial.T (-‚Üën))) : Q f
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), add_comm_monoid (A i)] [add_monoid Œπ] [direct_sum.gsemiring A] : A 0 ‚Üí+* direct_sum Œπ (Œª (i : Œπ), A i)
(Œ± : Type u) : Type u
{Œ± : Type u} [pseudo_metric_space Œ±] {x : Œ±} {r : ‚Ñù} (h : 0 ‚â§ r) : metric.diam (metric.closed_ball x r) ‚â§ 2 * r
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_2} (Œ≥ : Œ† (a : Œ±), Œ≤ a ‚Üí Type u_3) : (Œ£ (ab : Œ£ (a : Œ±), Œ≤ a), Œ≥ ab.fst ab.snd) ‚âÉ Œ£ (a : Œ±) (b : Œ≤ a), Œ≥ a b
(Œ± : Type u_1) (Œ≤ : Type u_2) [linear_order Œ±] [linear_order Œ≤] [encodable Œ±] [densely_ordered Œ±] [no_min_order Œ±] [no_max_order Œ±] [nonempty Œ±] [encodable Œ≤] [densely_ordered Œ≤] [no_min_order Œ≤] [no_max_order Œ≤] [nonempty Œ≤] : nonempty (Œ± ‚âÉo Œ≤)
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_2} [Œ† (a : Œ±), fintype (Œ≤ a)] : W_type Œ≤ ‚Üí ‚Ñï
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.is_iso (category_theory.abelian.coimage_image_comparison f)] : category_theory.limits.image_factorisation f
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_5} (m : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (f : filter Œ±) (g : filter Œ≤) : filter Œ≥
{R : Type u_1} [nontrivial R] [hR : comm_ring R] (h : ‚àÄ (a : R), is_unit a ‚à® a = 0) : field R
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_assoc_semiring Œ±} {rŒ≤ : non_assoc_semiring Œ≤} (f : Œ± ‚Üí+* Œ≤) (a : Œ±) : ‚áëf (bit1 a) = bit1 (‚áëf a)
{G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {Œì : add_subgroup G} [measurable_space (G ‚ß∏ Œì)] [borel_space (G ‚ß∏ Œì)] : has_measurable_vadd G (G ‚ß∏ Œì)
{Œ± : Type u_1} {f g : poly Œ±} : (‚àÄ (x : Œ± ‚Üí ‚Ñï), ‚áëf x = ‚áëg x) ‚Üí f = g
(Œ± : Sort u) : Sort (max 1 u)
(M : Type u_9) (N : Type u_10) [mul_one_class M] [mul_one_class N] : Type (max u_10 u_9)
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (X : algebraic_geometry.SheafedSpace C) : X.restrict _ ‚âÖ X
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] (x : ‚Ü•(projective_spectrum.Top ùíú)) (f : homogeneous_localization ùíú (projective_spectrum.as_homogeneous_ideal x).to_ideal) : ‚Ü•((algebraic_geometry.projective_spectrum.Proj.structure_sheaf ùíú).val.obj (opposite.op (projective_spectrum.basic_open ùíú f.denom)))
{Œ± : Type u_2} {Œ≤ : Type u_3} [non_assoc_ring Œ±] [non_assoc_ring Œ≤] (f : Œ± ‚Üí+* Œ≤) (x y : Œ±) : ‚áëf (x - y) = ‚áëf x - ‚áëf y
(p1 p2 : linarith.pcomp) : ordering
{n : ‚Ñï} (P : mvpfunctor (n + 1)) : mvpfunctor n
 : linarith.monom ‚Üí linarith.monom ‚Üí Prop
{R : Type u} {Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [topological_space M‚ÇÇ] (f : continuous_multilinear_map R M‚ÇÅ M‚ÇÇ) {Œ± : Œπ ‚Üí Type u_1} [fintype Œπ] (g : Œ† (i : Œπ), Œ± i ‚Üí M‚ÇÅ i) (A : Œ† (i : Œπ), finset (Œ± i)) : ‚áëf (Œª (i : Œπ), (A i).sum (Œª (j : Œ± i), g i j)) = (fintype.pi_finset A).sum (Œª (r : Œ† (a : Œπ), Œ± a), ‚áëf (Œª (i : Œπ), g i (r i)))
{Œ± : Type u_1} (f : Œ± ‚Üí Œ± ‚Üí Œ±) [is_associative Œ± f] (x y : Œ±) : ((Œª (z : Œ±), f z x) ‚àò Œª (z : Œ±), f z y) = Œª (z : Œ±), f z (f y x)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_kernel (f - g)] : category_theory.limits.has_equalizer f g
 : Type (u+1)
 : Type
{X : Type u_1} {Y : Type u_2} [topological_space X] (f : X ‚Üí Y) : Prop
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (k : ‚Ñï) : lie_submodule R L M ‚Üí lie_submodule R L M
{X : Type u_1} [topological_space X] {s : set X} (h : ‚àÄ (x : ‚Ñï ‚Üí X) (a : X), (‚àÄ (n : ‚Ñï), x n ‚àà s) ‚Üí filter.tendsto x filter.at_top (nhds a) ‚Üí a ‚àà s) : is_seq_closed s
{Œ± : Type u_2} [decidable_eq Œ±] [add_zero_class Œ±] : add_zero_class (finset Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {P Q : C} {S T : D} (f : P ‚âÖ Q) (g : S ‚âÖ T) : (P, S) ‚âÖ (Q, T)
{Œ± : Type u_3} {Œ≤ : Type u_4} [has_inf Œ±] [has_top Œ±] [has_inf Œ≤] [has_top Œ≤] : has_coe_to_fun (inf_top_hom Œ± Œ≤) (Œª (_x : inf_top_hom Œ± Œ≤), Œ± ‚Üí Œ≤)
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} {Œ≤ : mvqpf.fix F Œ± ‚Üí Type u} (g : Œ† (x : F (Œ± ::: sigma Œ≤)), Œ≤ (mvqpf.fix.mk (mvfunctor.map (typevec.id ::: sigma.fst) x))) (x : mvqpf.fix F Œ±) : Œ≤ x
{n : ‚Ñï} (c : composition n) : fin (c.length + 1) ‚Ü™o fin (n + 1)
{m n : ‚Ñï} : m ‚à£ m + n ‚Üî m ‚à£ n
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {Œ≤ : Type u_4} [linear_ordered_field ùïú] [add_comm_group E] [add_comm_group F] [ordered_add_comm_monoid Œ≤] [module ùïú E] [module ùïú F] [has_scalar ùïú Œ≤] {f : F ‚Üí Œ≤} (g : E ‚Üí·µÉ[ùïú] F) {s : set F} (hf : convex_on ùïú s f) : convex_on ùïú (‚áëg ‚Åª¬π' s) (f ‚àò ‚áëg)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ±‚ÇÇ : Type u_3} [semiring Œ≤] [has_zero Œ±] [has_zero Œ±‚ÇÇ] {F : Type u_4} [zero_hom_class F Œ± Œ±‚ÇÇ] (f : F) : finsupp.map_domain ‚áëf 1 = 1
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] (J : Type v) (F : C ‚•§ D) [F.preserves_zero_morphisms] : Type (max u u‚ÇÇ v)
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] [category_theory.has_projective_resolutions C] [category_theory.preadditive D] [category_theory.limits.has_zero_object D] [category_theory.limits.has_equalizers D] [category_theory.limits.has_cokernels D] [category_theory.limits.has_images D] [category_theory.limits.has_image_maps D] {F G : C ‚•§ D} [F.additive] [G.additive] (Œ± : F ‚ü∂ G) (n : ‚Ñï) {X : C} (P : category_theory.ProjectiveResolution X) : (category_theory.nat_trans.left_derived Œ± n).app X = (F.left_derived_obj_iso n P).hom ‚â´ (homology_functor D (complex_shape.down ‚Ñï) n).map ((category_theory.nat_trans.map_homological_complex Œ± (complex_shape.down ‚Ñï)).app P.complex) ‚â´ (G.left_derived_obj_iso n P).inv
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : add_comm_monoid ‚Ü•S
{Œ≥ : Type} (tooltip_component : widget.tc subexpr (widget_override.interactive_expression.action Œ≥)) (click_address select_address : option expr.address) : subexpr ‚Üí widget_override.interactive_expression.sf ‚Üí tactic (list (widget.html (widget_override.interactive_expression.action Œ≥)))
 : linarith.linarith_monad ‚Ñï
{C : Type u‚ÇÅ} [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] [‚àÄ (a b : C), category_theory.limits.has_coproducts_of_shape (a ‚ü∂ b) D] (c : C) : category_theory.evaluation_left_adjoint D c ‚ä£ (category_theory.evaluation C D).obj c
{Œ± : Type} (p : parser Œ±) (input : string) : string ‚äï Œ±
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] (F : J ‚•§ K ‚•§ C) (c : Œ† (k : K), category_theory.limits.colimit_cocone (F.flip.obj k)) : category_theory.limits.cocone F
{V : Type u_1} [inner_product_space ‚Ñù V] (x y : V) : inner_product_geometry.angle x y ‚â§ real.pi
{Œ± : Type u_1} : list Œ± ‚Üí Œ± ‚Üí list Œ±
{Œ± : Type} : environment ‚Üí Œ± ‚Üí (declaration ‚Üí Œ± ‚Üí Œ±) ‚Üí Œ±
(opt : interactive.parse (lean.parser.many lean.parser.ident)) : tactic unit
 : Type (u+1)
{K : Type u_1} [field K] {Œì : Type u_2} [linear_ordered_comm_group_with_zero Œì] (v : valuation K Œì) : valuation_subring K
(D : algebraic_geometry.Scheme.glue_data) : algebraic_geometry.LocallyRingedSpace.glue_data
{R : Type u} {M : Type v} {M‚ÇÇ : Type w} {M‚ÇÉ : Type y} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] (f : M ‚Üí‚Çó[R] M‚ÇÇ) (g : M ‚Üí‚Çó[R] M‚ÇÉ) : M ‚Üí‚Çó[R] M‚ÇÇ √ó M‚ÇÉ
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (F : J ‚•§ C) (G : C ‚•§ D) [category_theory.reflects_isomorphisms G] [category_theory.limits.has_colimit F] [category_theory.limits.preserves_colimit F G] : category_theory.limits.reflects_colimit F G
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] [has_zero Œ≤] {G : Type u_1} [continuous_map_class G Œ± Œ≤] [compact_space Œ±] : zero_at_infty_continuous_map_class G Œ± Œ≤
{Œ± : Type u} : wseq Œ± ‚Üí computation (option (Œ± √ó wseq Œ±))
{S : Type u_4} (H : S) {G : Type u_1} [ordered_add_comm_group G] [set_like S G] [add_subgroup_class S G] : ordered_add_comm_group ‚Ü•H
 : expr ‚Üí tactic expr
{Œ± : Type u_1} : free_ring Œ± ‚Üí+* free_comm_ring Œ±
{X : Type u} {Y : Type v} [preorder X] [preorder Y] {f : X ‚Üí Y} (h : monotone f) : X ‚•§ Y
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ M
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] {ùíú : finset (finset Œ±)} {r : ‚Ñï} (hùíú : set.sized r ‚Üëùíú) : set.sized (r + 1) ‚Üë(ùíú.up_shadow)
{H : Type u} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] (G : structure_groupoid H) [has_groupoid M G] {e : local_homeomorph M H} (he : e ‚àà charted_space.atlas H M) : e ‚àà structure_groupoid.maximal_atlas M G
(locat : interactive.loc) : tactic unit
{Œ± : Type u_1} [group Œ±] (s : subgroup Œ±) : setoid Œ±
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) : affine.simplex.points_with_circumcenter_index n ‚Üí P
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K
{Œπ : Type u_1} (Œ± : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), canonically_ordered_add_monoid (Œ± i)] [Œ† (i : Œπ), has_sub (Œ± i)] [Œ† (i : Œπ), has_ordered_sub (Œ± i)] : has_sub (Œ†‚ÇÄ (i : Œπ), Œ± i)
{R : Type u_1} {a b : R} [monoid R] (h : b * a = 1) : is_left_regular a
 : Type
(v : ‚Ñï ‚Üí ‚Ñ§) : omega.int.preterm ‚Üí ‚Ñ§
(Œ± : Sort u_1) : Sort (max 1 (imax 1 u_1) u_1)
{K : Type v} [field K] {P : polynomial K} (hmo : P.monic) (hP : polynomial.splits (ring_hom.id K) P) : P.coeff 0 = (-1) ^ P.nat_degree * P.roots.prod
{R : Type u} (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (M‚ÇÅ : Type w‚ÇÅ) (M‚ÇÇ : Type w‚ÇÇ) (M‚ÇÉ : Type w‚ÇÉ) [add_comm_group M‚ÇÅ] [module R M‚ÇÅ] [lie_ring_module L M‚ÇÅ] [lie_module R L M‚ÇÅ] [add_comm_group M‚ÇÇ] [module R M‚ÇÇ] [lie_ring_module L M‚ÇÇ] [lie_module R L M‚ÇÇ] [add_comm_group M‚ÇÉ] [module R M‚ÇÉ] [lie_ring_module L M‚ÇÉ] [lie_module R L M‚ÇÉ] (g : tensor_product R M‚ÇÅ M‚ÇÇ ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M‚ÇÉ) (œá‚ÇÅ œá‚ÇÇ : L ‚Üí R) : (‚Üëg.comp (tensor_product.map_incl (lie_module.pre_weight_space M‚ÇÅ œá‚ÇÅ) (lie_module.pre_weight_space M‚ÇÇ œá‚ÇÇ))).range ‚â§ lie_module.pre_weight_space M‚ÇÉ (œá‚ÇÅ + œá‚ÇÇ)
(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (Œπ : Type u_4) [decidable_eq Œπ] : Type (max u_1 u_2 u_4)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Type (max v u)) : (Œ£ (j : J), F.obj j) ‚Üí (Œ£ (j : J), F.obj j) ‚Üí Prop
 : linarith.preprocessor
(p : ‚Ñï) [fact (nat.prime p)] : ‚Üë((p - 1).factorial) = -1
(Œ≤ : Type u_2) [pseudo_metric_space Œ≤] [add_monoid Œ≤] : Prop
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} : is_min_on (‚áëorder_dual.to_dual ‚àò f) s a ‚Üí is_max_on f s a
(n : ‚Ñï) : add_comm_group (fin (n + 1))
{Œ± : Type u_1} [normed_division_ring Œ±] {a : Œ±} (ha : a ‚â† 0) : filter.tendsto (Œª (x : Œ±), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (b : category_theory.limits.bicone (category_theory.limits.pair_function X Y)) : b.to_binary_bicone.is_bilimit ‚âÉ b.is_bilimit
{ùïú : Type u_1} {E : Type u_4} [semi_normed_group E] [normed_field ùïú] [normed_space ùïú E] (f : ùïú ‚Üí‚Çó[ùïú] E) : ùïú ‚ÜíL[ùïú] E
{R : Type v} [comm_ring R] {n : Type u_1} [decidable_eq n] [fintype n] : module.End R (n ‚Üí R) ‚âÉ‚Çê[R] matrix n n R
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] {U : C} (R : category_theory.presieve U) (P : C·µí·µñ ‚•§ A) [category_theory.limits.has_products A] [category_theory.limits.has_pullbacks C] : category_theory.presheaf.first_obj R P ‚ü∂ category_theory.presheaf.second_obj R P
{R : Type u_1} {a : R} [monoid R] (ua : is_unit a) : is_regular a
{a : ‚Ñù} {l : filter ‚Ñù} {f g : ‚Ñù ‚Üí ‚Ñù} (hdf : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.univ  {a}), differentiable_at ‚Ñù f x) (hg' : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.univ  {a}), deriv g x ‚â† 0) (hfa : filter.tendsto f (nhds_within a (set.univ  {a})) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.univ  {a})) (nhds 0)) (hdiv : filter.tendsto (Œª (x : ‚Ñù), deriv f x / deriv g x) (nhds_within a (set.univ  {a})) l) : filter.tendsto (Œª (x : ‚Ñù), f x / g x) (nhds_within a (set.univ  {a})) l
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] (f : S.localization_map N) (z : N) : f.mk' (f.sec z).fst (f.sec z).snd = z
(a : ‚Ñ§) : ‚Ñ§
{X : Top} {a‚ÇÅ a‚ÇÇ : ‚Ü•(Top.of (ulift ‚Ü•unit_interval))} {b‚ÇÅ b‚ÇÇ : ‚Ü•X} (p‚ÇÅ : fundamental_groupoid.from_top a‚ÇÅ ‚ü∂ fundamental_groupoid.from_top a‚ÇÇ) (p‚ÇÇ : fundamental_groupoid.from_top b‚ÇÅ ‚ü∂ fundamental_groupoid.from_top b‚ÇÇ) : (fundamental_groupoid_functor.prod_to_prod_Top (Top.of (ulift ‚Ü•unit_interval)) X).obj (a‚ÇÅ, b‚ÇÅ) ‚ü∂ (fundamental_groupoid_functor.prod_to_prod_Top (Top.of (ulift ‚Ü•unit_interval)) X).obj (a‚ÇÇ, b‚ÇÇ)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Ü™ Œ≤) : (Œ± ‚Üí‚ÇÄ ‚Ñï) ‚Ü™ Œ≤ ‚Üí‚ÇÄ ‚Ñï
{Œ± : Sort u} {Œ≤ : Sort v} (e : Œ± ‚âÉ Œ≤) : Œ≤ ‚Üí Œ±
(ùïú : Type u_1) {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_3} [linear_order Œπ] [order_bot Œπ] [locally_finite_order Œπ] [is_well_order Œπ has_lt.lt] (f : Œπ ‚Üí E) (n : Œπ) : E
{S : Type u_2} [comm_ring S] {A : Type u_4} [comm_ring A] [algebra A S] {S' : Type u_8} [comm_ring S'] [algebra A S'] [is_domain A] (pb : power_basis A S) (pb' : power_basis A S') (h‚ÇÅ : ‚áë(polynomial.aeval pb.gen) (minpoly A pb'.gen) = 0) (h‚ÇÇ : ‚áë(polynomial.aeval pb'.gen) (minpoly A pb.gen) = 0) : S ‚âÉ‚Çê[A] S'
(Œ± Œ≤ : Type u) : Œ± √ó Œ≤ ‚âÉ Œ† (i : fin 2), ![Œ±, Œ≤] i
(x y c : bool) : bool
 : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [pred_order Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : antitone f) : pairwise (disjoint on Œª (n : Œ±), set.Ioc (f n) (f (order.pred n)))
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [dec : decidable_eq Œπ] [Œ† (i : Œπ), has_zero (Œ≤ i)] (i j : Œπ) (xi : Œ≤ i) (xj : Œ≤ j) : dfinsupp.single i xi = dfinsupp.single j xj ‚Üî i = j ‚àß xi == xj ‚à® xi = 0 ‚àß xj = 0
{S : Type u_1} [ordered_semiring S] {R : Type u_2} [semiring R] (abv : R ‚Üí S) [is_absolute_value abv] : absolute_value R S
{R : Type u} [comm_ring R] : Mon_ (Module R) ‚âå Algebra R
(A : Type u_1) (M : Type u_2) (M‚ÇÇ : Type u_3) [ring A] [add_comm_group M] [add_comm_group M‚ÇÇ] [module A M] [module A M‚ÇÇ] [topological_space M] [topological_space M‚ÇÇ] (R : Type u_4) [ring R] [module R M] [module R M‚ÇÇ] [linear_map.compatible_smul M M‚ÇÇ R A] (S : Type u_5) [ring S] [module S M‚ÇÇ] [has_continuous_const_smul S M‚ÇÇ] [smul_comm_class A S M‚ÇÇ] [smul_comm_class R S M‚ÇÇ] [topological_add_group M‚ÇÇ] : (M ‚ÜíL[A] M‚ÇÇ) ‚Üí‚Çó[S] M ‚ÜíL[R] M‚ÇÇ
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type v‚ÇÅ} [category_theory.small_category J] [category_theory.fin_category J] {K : J ‚•§ C} (F : C ‚•§ D) [category_theory.representably_flat F] {c : category_theory.limits.cone K} (hc : category_theory.limits.is_limit c) (s : category_theory.limits.cone (K ‚ãô F)) : s.X ‚ü∂ F.obj c.X
{Œ± : Type u_1} [normed_lattice_add_comm_group Œ±] : has_continuous_inf Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [semigroup Œ±] [comm_semigroup Œ≤] {f g : Œ± ‚Üí Œ≤} (hf : is_mul_hom f) (hg : is_mul_hom g) : is_mul_hom (Œª (a : Œ±), f a * g a)
(h : expr) : tactic name_set
{ùíú : Type u_1} [category_theory.category ùíú] {A B C : ùíú} [category_theory.abelian ùíú] {f : A ‚ü∂ B} {g : B ‚ü∂ C} (h : category_theory.right_split f g) : category_theory.splitting f g
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [decidable_eq Œπ] [add_monoid Œπ] [comm_semiring R] [semiring A] [algebra R A] (ùíú : Œπ ‚Üí submodule R A) [graded_algebra ùíú] (i : Œπ) : A ‚Üí‚Çó[R] A
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÇ] [has_zero M‚ÇÇ] [has_scalar ‚Ñï M‚ÇÇ] [add_monoid M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : add_monoid M‚ÇÇ
(ùïú : Type u) (G : Type wG) (G' : Type wG') [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] : continuous_multilinear_map ùïú (Œª (i : fin 1), G) G' ‚âÉ‚Çó·µ¢[ùïú] G ‚ÜíL[ùïú] G'
(R : Type u_1) [ring R] (C : Type u_2) [category_theory.category C] [category_theory.abelian C] [category_theory.linear R C] [category_theory.enough_projectives C] (X Y : C) [category_theory.projective X] (n : ‚Ñï) : ((Ext R C (n + 1)).obj (opposite.op X)).obj Y ‚âÖ 0
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} [topological_space Œ±] (L : ‚àÄ (u : set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí (‚àÉ (F : Œ± ‚Üí Œ≤), continuous_on F s ‚àß ‚àÄ (y : Œ±), y ‚àà s ‚Üí (f y, F y) ‚àà u)) : continuous_on f s
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommMon) : category_theory.limits.is_limit (AddCommMon.limit_cone F)
{C : Type u‚ÇÅ} [category_theory.category C] {Z Z' : C ‚Üí Prop} (h : ‚àÄ ‚¶ÉX : C‚¶Ñ, Z X ‚Üí Z' X) : {X // Z X} ‚•§ {X // Z' X}
{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X ‚Üí Y} (hf : inducing f) : topological_space.pseudo_metrizable_space X
(Œ± : Type u_1) : Type u_1
(t : ‚Ü•unit_interval) : ‚Ñù
{Œπ : Type u_1} {Œπ' : Type u_2} {R : Type u_3} {M : Type u_5} {M' : Type u_6} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid M'] [module R M'] (b : basis Œπ R M) (b' : basis Œπ' R M') : basis (Œπ ‚äï Œπ') R (M √ó M')
 : category_theory.limits.limit_cone (category_theory.functor.empty (Type u))
 : function.right_inverse coe ‚áëcardinal.to_nat
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (E : Type u_2) [normed_group E] [normed_space ùïú E] [complete_space E] (F : Type u_3) [normed_group F] [normed_space ùïú F] [complete_space F] (G : Type u_4) [normed_group G] [normed_space ùïú G] [complete_space G] : Type (max u_2 u_3 u_4)
 : simp_lemmas ‚Üí simp_lemmas
{t : Type u ‚Üí Type u ‚Üí Type u} [bitraversable t] (F G : Type u ‚Üí Type u) [traversable F] [traversable G] {m : Type u ‚Üí Type u} [applicative m] {Œ± Œ≤ Œ±' Œ≤' : Type u} (f : Œ± ‚Üí m Œ≤) (f' : Œ±' ‚Üí m Œ≤') : function.bicompl t F G Œ± Œ±' ‚Üí m (function.bicompl t F G Œ≤ Œ≤')
{Œ± : Type u} [pseudo_emetric_space Œ±] (s : set Œ±) : ennreal
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D) : C ‚•§ D·µí·µñ
{R : Type u_1} [comm_ring R] {a b : quaternion R} (h : commute a b) : commute (‚áëquaternion.conj a) (‚áëquaternion.conj b)
(G : Type u_10) [has_involutive_neg G] : equiv.perm G
{R : Type u} [ring R] {Œ± : Type u_1} [add_comm_monoid Œ±] [module R Œ±] (S : subring R) : module ‚Ü•S Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) (X : C) [category_theory.limits.preserves_colimit (category_theory.functor.empty C) G] (l : category_theory.limits.is_initial X) : category_theory.limits.is_initial (G.obj X)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f : J ‚Üí C} [category_theory.limits.has_biproduct f] {P : C} (p : Œ† (b : J), P ‚ü∂ f b) : P ‚ü∂ ‚®Å f
{Œ± : Type u_1} [group Œ±] {s : subgroup Œ±} (g : Œ±) : ‚Ü•(right_coset ‚Üës g) ‚âÉ ‚Ü•s
{X : Type u} [lattice X] [jordan_holder_lattice X] (l : list X) (hl : l ‚â† list.nil) (hc : list.chain' jordan_holder_lattice.is_maximal l) : composition_series X
(R : Type u) [rack R] : rack.pre_envel_group R ‚Üí rack.pre_envel_group R ‚Üí Type u
{Œ± : Type u_1} : finset Œ± ‚Ü™o set Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] {b : category_theory.limits.binary_bicone X Y} (hb : b.is_bilimit) : (hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.binary_biproduct.is_limit X Y)).hom = category_theory.limits.biprod.lift b.fst b.snd
{Œ± : Type u} (c : complete_lattice Œ±) (le : Œ± ‚Üí Œ± ‚Üí Prop) (eq_le : le = complete_lattice.le) (top : Œ±) (eq_top : top = complete_lattice.top) (bot : Œ±) (eq_bot : bot = complete_lattice.bot) (sup : Œ± ‚Üí Œ± ‚Üí Œ±) (eq_sup : sup = complete_lattice.sup) (inf : Œ± ‚Üí Œ± ‚Üí Œ±) (eq_inf : inf = complete_lattice.inf) (Sup : set Œ± ‚Üí Œ±) (eq_Sup : Sup = complete_lattice.Sup) (Inf : set Œ± ‚Üí Œ±) (eq_Inf : Inf = complete_lattice.Inf) : complete_lattice Œ±
(s t : string) : option string
(X : algebraic_geometry.LocallyRingedSpace) : Top
(nm : name) : tactic name
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (h : M ‚âÉ+ N) : ‚áëh 0 = 0
{R : Type u_1} {R' : Type u_2} {S : Type u_3} {S' : Type u_4} [non_assoc_semiring R] [non_assoc_semiring S] [non_assoc_semiring R'] [non_assoc_semiring S'] (f : R ‚Üí+* R') (g : S ‚Üí+* S') : R √ó S ‚Üí+* R' √ó S'
 : snum ‚Üí snum
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) [decidable_eq Œ±] [fin_enum Œ≤] (h : function.injective f) : fin_enum Œ±
{R : Type u_1} {M : Type u_5} [comm_ring R] [add_comm_group M] [module R M] (B : M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R) (f : module.End R M) : Prop
(opt : tactic.apply_cfg) : list (tactic expr) ‚Üí tactic unit
(R : Type u) {X : Type v} [semiring R] {A : Type w} [non_unital_non_assoc_semiring A] [module R A] [is_scalar_tower R A A] [smul_comm_class R A A] : (X ‚Üí A) ‚âÉ (free_non_unital_non_assoc_algebra R X ‚Üí‚Çô‚Çê[R] A)
 : Type (max (u+1) (v+1))
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_pullbacks C] (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.mono_over.map f ‚ä£ category_theory.mono_over.pullback f
{R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_4} {M‚ÇÇ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {Œπ : Type u_3} {v : Œπ ‚Üí M} {f g : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (hv : submodule.span R (set.range v) = ‚ä§) (h : ‚àÄ (i : Œπ), ‚áëf (v i) = ‚áëg (v i)) : f = g
{Œ± : Type u} [emetric_space Œ±] [compact_space Œ±] : compact_space (topological_space.closeds Œ±)
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [has_mul Œ±] [has_add Œ±] [has_le Œ±] [has_mul Œ≤] [has_add Œ≤] [has_le Œ≤] : Type (max u_6 u_7 u_8)
{X : Type u_1} [topological_space X] {a b : X} (Œ≥ : path a b) (t‚ÇÄ t‚ÇÅ : ‚Ñù) : path (Œ≥.extend (linear_order.min t‚ÇÄ t‚ÇÅ)) (Œ≥.extend t‚ÇÅ)
{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G ‚Üí ¬¨monoid.is_torsion_free G
{Œ± : Type u_1} [has_lt Œ±] {a b : Œ±} {o : ordering} : o.swap.compares a b ‚Üí o.compares b a
(p : Type u_2) (q : Type u_3) (R : Type u‚ÇÇ) [decidable_eq p] [decidable_eq q] [comm_ring R] : matrix (p ‚äï q) (p ‚äï q) R
(ùïú : Type u_1) (E : Type u_4) (F‚Çó : Type u_7) (G‚Çó : Type u_9) [semi_normed_group E] [semi_normed_group F‚Çó] [semi_normed_group G‚Çó] [nondiscrete_normed_field ùïú] [normed_space ùïú E] [normed_space ùïú F‚Çó] [normed_space ùïú G‚Çó] : (E ‚ÜíL[ùïú] F‚Çó ‚ÜíL[ùïú] G‚Çó) ‚âÉ‚Çó·µ¢[ùïú] F‚Çó ‚ÜíL[ùïú] E ‚ÜíL[ùïú] G‚Çó
{R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type u_3} [add_comm_group M] [module R M] (N : submodule R M) (Œπ : Type u_4) (n : ‚Ñï) : Type (max u_2 u_3 u_4)
{R : Type u_3} [semiring R] {S : Type u_4} [semiring S] {R‚ÇÇ : Type u_5} [semiring R‚ÇÇ] {S‚ÇÇ : Type u_6} [semiring S‚ÇÇ] {M : Type u_7} {N : Type u_8} {P : Type u_9} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module S N] [module R‚ÇÇ P] [module S‚ÇÇ P] [smul_comm_class S‚ÇÇ R‚ÇÇ P] {œÅ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÅ‚ÇÇ : S ‚Üí+* S‚ÇÇ} (f : M ‚Üí‚Çõ‚Çó[œÅ‚ÇÅ‚ÇÇ] N ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] P) : N ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M ‚Üí‚Çõ‚Çó[œÅ‚ÇÅ‚ÇÇ] P
(tac1 : tactic unit) (tacs2 : list (tactic unit)) : tactic unit
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J ‚Üí C) [category_theory.limits.has_biproduct F] : ‚àè F ‚âÖ ‚àê F
{Œπ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Œπ ‚Üí set X} {s : set X} (c : set (shrinking_lemma.partial_refinement u s)) (ne : c.nonempty) (i : Œπ) : shrinking_lemma.partial_refinement u s
(R : Type u) {Œπ : Type u'} (M‚ÇÅ : Œπ ‚Üí Type v) (M‚ÇÇ : Type w) [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] : Type (max u' v w)
{Œ± : Type u_1} : sym2.map (Œª (x : Œ±), x) = id
{M : Type u_3} {N : Type u_4} {hM : has_zero M} {hN : has_zero N} (f : zero_hom M N) (f' : M ‚Üí N) (h : f' = ‚áëf) : zero_hom M N
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_3} [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] [omega_complete_partial_order Œ≥] (f : Œ≤ ‚ÜíùíÑ Œ≥) (g : Œ± ‚ÜíùíÑ Œ≤) : Œ± ‚ÜíùíÑ Œ≥
{E : Type u_2} [normed_group E] [normed_space ‚Ñù E] {x y : E} (hxy : x ‚â† y) : ‚àÉ (f : E ‚ÜíL[‚Ñù] ‚Ñù), ‚áëf x < ‚áëf y
{a : ennreal} (h : a < ‚ä§) : add_le_cancellable a
(V : Type u) [quiver V] : Type (max u v)
 : nat.partrec.code ‚Üí ‚Ñï
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [has_top Œ±] [has_top Œ≤] : Type (max u_6 u_7 u_8)
{x y : simplex_category} {f : x ‚ü∂ y} : category_theory.epi f ‚Üí y.len ‚â§ x.len
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : add_con (M √ó ‚Ü•S)
 : string.iterator ‚Üí string.iterator ‚Üí bool
{a : Sort u} {b : Sort v} [has_coe_t a b] : has_lift_t a b
{R : Type u_1} [semiring R] {S : Type u_2} [semiring S] (f : R ‚Üí+* S) : power_series R ‚Üí+* power_series S
{M : Type u_1} {Œ± : Type u_6} {Œ≤ : Type u_7} [add_monoid M] [add_action M Œ±] [has_vadd M Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.surjective f) (smul : ‚àÄ (c : M) (x : Œ±), f (c +·µ• x) = c +·µ• f x) : add_action M Œ≤
{n m : ‚Ñï} (h : n ‚â§ m) : fin n ‚âÉo {i // ‚Üëi < n}
{Œ± : Type u_1} [topological_space Œ±] (s : set Œ±) : Prop
{R : Type u_1} [mul_zero_class R] : is_left_regular 0 ‚Üî subsingleton R
{Œ± : Type u_2} [decidable_eq Œ±] [has_one Œ±] [has_mul Œ±] : has_pow (finset Œ±) ‚Ñï
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.sheaf C X) (U V : topological_space.opens ‚Ü•X) (s : category_theory.limits.pullback_cone (F.val.map (category_theory.hom_of_le _).op) (F.val.map (category_theory.hom_of_le _).op)) : s.X ‚ü∂ F.val.obj (opposite.op (U ‚à™ V))
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (f : M ‚Üí‚Çó[R] M) : bilin_form R M
{Œ± : Type u_1} [linear_order Œ±] {r s : Œ±} : {r}.to_colex ‚â§ {s}.to_colex ‚Üî r ‚â§ s
(Œ± : Type u_1) [topological_space Œ±] [non_unital_non_assoc_ring Œ±] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) {J : Type u} [category_theory.category J] (K : J ‚•§ C) : category_theory.is_left_adjoint (category_theory.limits.cocones.functoriality K F)
{Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_group_hom f) (a : Œ±) : f (-a) = -f a
(L : first_order.language) (M : Type u_3) [L.Structure M] : (L.with_constants M).Theory
{M : Type u_1} {Œ± : Type u_2} [topological_space Œ±] [has_scalar M Œ±] [has_continuous_const_smul M Œ±] [has_scalar M·µê·µí·µñ Œ±] [is_central_scalar M Œ±] : has_continuous_const_smul M·µê·µí·µñ Œ±
{Œ± : Type u} {s : set Œ±} (hc : s.countable) (hs : s.nonempty) : ‚àÉ (f : ‚Ñï ‚Üí Œ±), s = set.range f
{R : Type u_1} {N : Type u_15} {N‚ÇÇ : Type u_16} [comm_semiring R] [add_comm_monoid N] [add_comm_monoid N‚ÇÇ] [module R N] [module R N‚ÇÇ] (p‚Çó : submodule R N) (q‚Çó : submodule R N‚ÇÇ) : submodule R (N ‚Üí‚Çó[R] N‚ÇÇ)
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {G : K ‚•§ C} (e : K ‚âå J) (Œ± : e.functor ‚ãô F ‚âÖ G) : category_theory.limits.cone F ‚âå category_theory.limits.cone G
(n : name) : tactic bool
{G : Type u_1} [group G] (H K : set G) : Type u_1
{R : Type u_1} {S : Type u_3} [non_assoc_semiring R] [non_assoc_semiring S] : R √ó S ‚âÉ+* S √ó R
(Œ± : Type u_5) : Type u_5
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] : has_coe_to_fun (basis Œπ R M) (Œª (_x : basis Œπ R M), Œπ ‚Üí M)
{Œ≤ : Type w} {C : Type u} [category_theory.category C] (f : Œ≤ ‚Üí C) [category_theory.limits.has_product f] : category_theory.limits.is_limit (category_theory.limits.fan.mk (‚àè f) (category_theory.limits.pi.œÄ f))
{Œ± : Type u_1} (o : part Œ±) : {dom := o.dom, get := Œª (h : o.dom), o.get h} = o
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {f' f‚ÇÅ' : E ‚ÜíL[ùïú] F} {x : E} {s : set E} (H : unique_diff_within_at ùïú s x) (hf : has_fderiv_within_at f f' s x) (hg : has_fderiv_within_at f f‚ÇÅ' s x) : f' = f‚ÇÅ'
{C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ‚Ñï} {i : fin (n + 2)} {j : fin (n + 1)} (H : ‚áëfin.cast_succ j < i) : X.Œ¥ i.succ ‚â´ X.œÉ (‚áëfin.cast_succ j) = X.œÉ j ‚â´ X.Œ¥ i
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C·µí·µñ} (c : category_theory.limits.cocone F.left_op) : category_theory.limits.cone F
(e : expr) : tactic (list binder √ó expr)
 : tactic unit
(Œ± : Type u_4) [has_le Œ±] : Type u_4
{Œ± : Sort u‚ÇÅ} {Œ≤ : Sort u‚ÇÇ} (f : Œ± ‚Üí Œ≤) : Prop
 : expr ‚Üí binder_info
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ‚ü∂ Y} [category_theory.mono f] (h : f = 0) : X ‚âÖ 0
{n : ‚Ñï} [fact (0 < n)] : (zmod n)À£ ‚âÉ {x // x.val.coprime n}
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] {u v : E} (hvm : v ‚àà K) (hvo : ‚àÄ (w : E), w ‚àà K ‚Üí has_inner.inner (u - v) w = 0) : orthogonal_projection_fn K u = v
(R : Type u) (X : Type v) [comm_ring R] : Type (max u v)
(p : tactic.ring_exp.ex tactic.ring_exp.ex_type.prod) (ps : tactic.ring_exp.ex tactic.ring_exp.ex_type.sum) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop} (f : r ‚Ü™r s) (g : s ‚Ü™r t) : r ‚Ü™r t
{Œπ : Type u} {Œ∑ : Type v} (R : Type w) (s : Œπ ‚Üí Œ∑) [add_zero_class R] : (Œπ ‚Üí R) ‚Üí+ Œ∑ ‚Üí R
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space F] {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ‚ä§) (hker : f'.ker.closed_complemented) : ‚àÄ·∂† (p : F √ó ‚Ü•(f'.ker)) in nhds (f a, 0), f (has_strict_fderiv_at.implicit_function_of_complemented f f' hf hf' hker p.fst p.snd) = p.fst
{Œ± : Type u_1} (a : Œ±) (Œ≤ : Type u_2) : Œ≤ ‚Ü™ Œ± √ó Œ≤
{k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ‚Ñï} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : ‚Ñï} (h : fs.card = m + 1) : finset.centroid k finset.univ (s.face h).points = finset.centroid k fs s.points
{Œ± : Type u_1} {Œπ : Type u_3} [lattice Œ±] [order_bot Œ±] {s : finset Œπ} {f : Œπ ‚Üí Œ±} [decidable_eq Œπ] : s.sup_indep f ‚Üî ‚àÄ (i : Œπ), i ‚àà s ‚Üí disjoint (f i) ((s.erase i).sup f)
(Œ± : Type u) (Œ≤ : Œ± ‚Üí Prop) [slim_check.sampleable_ext Œ±] [Œ† (x : Œ±), slim_check.testable (Œ≤ x)] (cfg : slim_check.slim_check_cfg) (var : string) : slim_check.sampleable_ext.proxy_repr Œ± ‚Üí ‚Ñï ‚Üí option_t slim_check.gen (Œ£ (x : slim_check.sampleable_ext.proxy_repr Œ±), slim_check.test_result (Œ≤ (slim_check.sampleable_ext.interp Œ± x)))
 : tactic unit
(x : ‚ÑÇ) : has_deriv_at complex.cos (-complex.sin x) x
(Œ± : Type u_5) : Type u_5
 : Type
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (f : M ‚Üí* P) : con M
(num_params : ‚Ñï) (ret_type : expr) : tactic (native.rb_lmap expr ‚Ñï)
(R : Type u) [ring R] : Type u
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] {P : C} (Œπ : P ‚ü∂ X) (w : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Œπ ‚â´ f j‚ÇÅ = Œπ ‚â´ f j‚ÇÇ) : category_theory.limits.trident f
{Œ± : Type u_1} {Œ≤ : Type u_2} [t : topological_space Œ±] [ring Œ≤] (f : Œ± ‚Üí Œ≤) : ring_topology Œ≤
{L : first_order.language} {Œ± : Type u'} {Œ≤ : Type v'} {n : ‚Ñï} : L.bounded_formula Œ± n ‚Üí (Œ± ‚Üí L.term Œ≤) ‚Üí L.bounded_formula Œ≤ n
{R : Type u_2} [comm_semiring R] (A : Type u_3) [semiring A] [algebra R A] : polynomial R ‚Üí‚Çê[R] power_series A
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] [has_mul Œ±] [has_add Œ≤] [has_mul Œ≤] : Œ±·µê·µí·µñ ‚âÉ+* Œ≤·µê·µí·µñ ‚âÉ (Œ± ‚âÉ+* Œ≤)
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {f' : F} {x : ùïú} {L : filter ùïú} : has_deriv_at_filter f f' x L ‚Üî filter.tendsto (slope f x) (L ‚äì filter.principal {x}·∂ú) (nhds f')
{A : Type u_2} [add_monoid A] (x : A) : add_submonoid A
{Œ± : Type u} (s t : set Œ±) [decidable_pred (Œª (_x : Œ±), _x ‚àà s)] : ‚Ü•(s ‚à™ t) ‚äï ‚Ü•(s ‚à© t) ‚âÉ ‚Ü•s ‚äï ‚Ü•t
{Œ± : Sort u_1} {Œ≤ : Type u_2} (p : set Œ≤) (f : Œ± ‚Ü™ Œ≤) (H : ‚àÄ (a : Œ±), ‚áëf a ‚àà p) : Œ± ‚Ü™ ‚Ü•p
{P : Type u_1} [preorder P] (F : order.pfilter P) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ (w+1) (w'+1))
 : Type (u+1)
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.has_split_coequalizer f g] : category_theory.limits.has_coequalizer f g
(G : Type u_1) [group G] [hG : group.is_nilpotent G] : ‚Ñï
{L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.hom M N) (g : L.hom N P) (h : L.hom P Q) : (h.comp g).comp f = h.comp (g.comp f)
{C : Type u} [category_theory.category C] (T : category_theory.monad C) : category_theory.kleisli.adjunction.to_kleisli T ‚ãô category_theory.kleisli.adjunction.from_kleisli T ‚âÖ ‚ÜëT
 : local_homeomorph ‚ÑÇ ‚ÑÇ
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {P Q R : C} : (P ‚ü∂ Q) ‚Üí+ (Q ‚ü∂ R) ‚Üí+ (P ‚ü∂ R)
 : turing.partrec_to_TM2.Œì' ‚Üí bool
{E : Type u_2} [semi_normed_group E] [normed_space ‚Ñù E] {s : set E} : metric.bounded (‚áë(convex_hull ‚Ñù) s) ‚Üî metric.bounded s
{Œ± : Type u_1} [preorder Œ±] [add_comm_semigroup Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b : Œ±} : a + b - a ‚â§ b
{Œ± : Type u_1} [add_group Œ±] {s : add_subgroup Œ±} (g : Œ±) : ‚Ü•(right_add_coset ‚Üës g) ‚âÉ ‚Ü•s
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a : Œ±} : 1 < a‚Åª¬π ‚Üî a < 1
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ‚Üí+* S) (s : subsemiring R) : subsemiring S
{Œπ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (c : complex_shape Œπ) [category_theory.limits.has_zero_object V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] (i : Œπ) : homological_complex V c ‚•§ V
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] {X Y : C} [category_theory.limits.preserves_binary_biproduct X Y F] : category_theory.limits.preserves_colimit (category_theory.limits.pair X Y) F
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {L‚ÇÅ L‚ÇÇ : C ‚•§ D} {R‚ÇÅ R‚ÇÇ : D ‚•§ C} (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) (f : R‚ÇÅ ‚ü∂ R‚ÇÇ) [category_theory.is_iso f] : category_theory.is_iso (‚áë((category_theory.transfer_nat_trans_self adj‚ÇÅ adj‚ÇÇ).symm) f)
(n : interactive.parse (optional lean.parser.ident)) : tactic unit
{X : algebraic_geometry.PresheafedSpace CommRing} (Y : algebraic_geometry.Scheme) (f : X ‚ü∂ Y.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace) [H : algebraic_geometry.PresheafedSpace.is_open_immersion f] : algebraic_geometry.PresheafedSpace.is_open_immersion.to_Scheme Y f ‚ü∂ Y
 : absolute_value.abs.is_euclidean
(bracket : bool) : tactic.rcases_patt ‚Üí tactic format
{n : ‚Ñï} : bitvec n ‚Üí bitvec n ‚Üí bitvec n
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] (M : category_theory.Mat_ C) : M.hom M
{Œ± Œ≤ : PartialFun} (e : Œ± ‚âÉ Œ≤) : Œ± ‚âÖ Œ≤
(Œ± : Type u_1) (Œ≤ : Type u_2) [unique Œ±] [measurable_space Œ≤] : (Œ± ‚Üí Œ≤) ‚âÉ·µê Œ≤
{R : Type u_1} [comm_ring R] {c‚ÇÅ c‚ÇÇ : R} : clifford_algebra (clifford_algebra_quaternion.Q c‚ÇÅ c‚ÇÇ) ‚Üí‚Çê[R] quaternion_algebra R c‚ÇÅ c‚ÇÇ
{C : Type u} [category_theory.category C] {M : Type u_1} [category_theory.category M] [category_theory.monoidal_category M] (F : category_theory.monoidal_functor M (C ‚•§ C)) (m n : M) (h : m ‚äó n ‚âÖ ùüô_ M) : F.to_lax_monoidal_functor.to_functor.obj m ‚ãô F.to_lax_monoidal_functor.to_functor.obj n ‚âÖ ùü≠ C
{C : Type u‚ÇÅ} [category_theory.category C] (T : category_theory.monad C) : T.algebra ‚•§ C
 : Top ‚•§ CompHaus
{Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Œ±) (a : Œ±) (p : parser Œ≤) : parser Œ±
{L : first_order.language} {M : Type w} [L.Structure M] {Œ± : Type u'} (v : Œ± ‚Üí M) (t : L.term Œ±) : M
{Œπ : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] [topological_space R] [nonempty Œπ] {B : Œπ ‚Üí submodule R M} (hB : submodules_basis B) : module_filter_basis R M
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M ‚Üí* P} (hg : ‚àÄ (y : ‚Ü•S), is_unit (‚áëg ‚Üëy)) : N ‚Üí* P
{R : Type u} {n : ‚Ñï} {M : fin n.succ ‚Üí Type v} {M‚ÇÇ : Type v‚ÇÇ} [semiring R] [Œ† (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : fin n.succ), module R (M i)] [module R M‚ÇÇ] (f : multilinear_map R M M‚ÇÇ) (m : Œ† (i : fin n), M i.succ) (x y : M 0) : ‚áëf (fin.cons (x + y) m) = ‚áëf (fin.cons x m) + ‚áëf (fin.cons y m)
{Œ± : Type u_1} {Œ≤ : Type u_2} (s : multiset Œ±) (t : multiset Œ≤) : multiset (Œ± ‚äï Œ≤)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (C : homological_complex V c) [category_theory.limits.has_zero_object V] (i : Œπ) : V
{Œ± : Type u_1} (G : simple_graph Œ±) [fintype Œ±] [decidable_eq Œ±] [decidable_rel G.adj] {n : ‚Ñï} : G.clique_free n ‚Üí G.clique_finset n = ‚àÖ
 : ring_hom.localization_preserves ring_hom.finite
 : W_type.nat_Œ± ‚âÉ punit ‚äï punit
 : category_theory.concrete_category CpltSepUniformSpace
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (R : D ‚•§ C) [category_theory.monadic_right_adjoint R] : category_theory.creates_limits_of_size R
(Œ± : Type u_1) : Œ± √ó empty ‚âÉ empty
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) [complete_space E] : complete_space ‚Ü•K·óÆ
{P : Type u_1} [preorder P] (p : P) : order.ideal P
 : Type
{Œ± : Type u} {L‚ÇÅ L‚ÇÇ : list (Œ± √ó bool)} [decidable_eq Œ±] (H : free_group.red L‚ÇÅ L‚ÇÇ) : free_group.red L‚ÇÇ (free_group.reduce L‚ÇÅ)
{M : Type u_1} [topological_space M] [monoid M] : topological_space MÀ£
{ùïú : Type u_1} {E : Type u_3} {F : Type u_4} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] (q : formal_multilinear_series ùïú E (E ‚ÜíL[ùïú] F)) (z : F) : formal_multilinear_series ùïú E F
{G : Type u_1} [add_group G] (s : set G) : set G
{G : Type u_1} [add_group G] {H : add_subgroup G} {S : set G} (hS : S ‚àà add_subgroup.right_transversals ‚ÜëH) : G ‚Üí ‚Ü•S
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (G : C ‚•§ D) [G.preserves_zero_morphisms] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] [category_theory.limits.preserves_limit (category_theory.limits.parallel_pair f 0) G] : category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ (G.map (category_theory.limits.kernel.Œπ f)) _)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p ‚àà s) (v : V) : v ‚àà s.direction ‚Üî ‚àÉ (p2 : P) (H : p2 ‚àà s), v = p -·µ• p2
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {Œπ : Type u_6} (Z : topological_vector_bundle_core R B F Œπ) : bundle.total_space Z.fiber ‚Üí B
{Œ± : Type u_3} {Œ≤ : Type u_4} [lattice Œ±] [lattice Œ≤] (f : lattice_hom Œ± Œ≤) : inf_hom Œ± Œ≤
 : list tactic.ring_exp.ex_info ‚Üí tactic.ring_exp.ring_exp_m (option (list expr))
(Œ± : Type u_1) [ring Œ±] : Type u_1
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] (P : C·µí·µñ ‚•§ D) [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] : J.plus_map (J.to_plus P) = J.to_plus (J.plus_obj P)
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {w : Œ± ‚Üí M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : ‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚àà t) (hb : t.card ‚Ä¢ b < s.sum (Œª (x : Œ±), w x)) : ‚àÉ (y : Œ≤) (H : y ‚àà t), b < (finset.filter (Œª (x : Œ±), f x = y) s).sum (Œª (x : Œ±), w x)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (s s' : finmap Œ≤) : finmap Œ≤
{R : Type u} [ring R] {J : Type v} [category_theory.small_category J] (F : J ‚•§ Module R) : category_theory.limits.is_limit (Module.has_limits.limit_cone F)
{Œ± : Type u} {Œ≤ : Type v} {m‚ÇÅ m‚ÇÇ : Œ± ‚Üí Œ≤} {f : filter Œ±} (h : m‚ÇÅ =·∂†[f] m‚ÇÇ) : filter.map m‚ÇÅ f = filter.map m‚ÇÇ f
{Œπ : Type u} {Œ≤‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {Œ≤‚ÇÇ : Œπ ‚Üí Type v‚ÇÇ} [Œ† (i : Œπ), has_zero (Œ≤‚ÇÅ i)] [Œ† (i : Œπ), has_zero (Œ≤‚ÇÇ i)] (f : Œ† (i : Œπ), Œ≤‚ÇÅ i ‚Üí Œ≤‚ÇÇ i) (hf : ‚àÄ (i : Œπ), f i 0 = 0) : (Œ†‚ÇÄ (i : Œπ), Œ≤‚ÇÅ i) ‚Üí (Œ†‚ÇÄ (i : Œπ), Œ≤‚ÇÇ i)
{p : Prop} (h : ¬¨p) : p ‚âÉ pempty
{M : Type u_4} [topological_space M] [monoid M] [has_continuous_mul M] [t2_space M] (s : submonoid M) (hs : ‚àÄ (x y : ‚Ü•s), x * y = y * x) : comm_monoid ‚Ü•(s.topological_closure)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {n : ‚Ñï} {f : ùïú ‚Üí F} {s : set ùïú} : iterated_fderiv_within ùïú n f s = ‚áë(continuous_multilinear_map.pi_field_equiv ùïú (fin n) F) ‚àò iterated_deriv_within n f s
{G : Type u} [category_theory.groupoid G] [is_free_groupoid G] (T : wide_subquiver (quiver.symmetrify (is_free_groupoid.generators G))) [quiver.arborescence ‚Ü•T] {a : G} (p : quiver.path (quiver.root ‚Ü•T) a) : is_free_groupoid.spanning_tree.tree_hom T a = is_free_groupoid.spanning_tree.hom_of_path T p
{Œ± : Type u} {Œ≤ : Type v} {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} [partial_order Œ≤] [semilattice_sup Œ±] (gi : galois_insertion l u) : semilattice_sup Œ≤
(Œ± : Type u_2) [fintype Œ±] [nonempty Œ±] [lattice Œ±] : bounded_order Œ±
{Œ± : Type u_1} [linear_order Œ±] {A B : finset Œ±} (h : A ‚äÇ B) : A.to_colex < B.to_colex
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {f g : X ‚ü∂ Y} (c : category_theory.limits.kernel_fork (f - g)) : category_theory.limits.fork f g
{Œ± : Type u_1} [has_add Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {b c : Œ±} (bc : b < c) (a : Œ±) : a + b < a + c
{G‚ÇÅ : Type u_3} {G‚ÇÇ : Type u_4} {G‚ÇÉ : Type u_5} [add_group G‚ÇÅ] [add_group G‚ÇÇ] [add_group G‚ÇÉ] (f : G‚ÇÅ ‚Üí+ G‚ÇÇ) (hf : function.surjective ‚áëf) : {g // f.ker ‚â§ g.ker} ‚âÉ (G‚ÇÇ ‚Üí+ G‚ÇÉ)
{Œ± : Sort u_1} {Œ≤ : Sort u_2} [nonempty Œ±] (f : Œ± ‚Üí Œ≤) : Œ≤ ‚Üí Œ±
(_x : interactive.parse (lean.parser.tk "mk_simp_attribute")) : lean.parser unit
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X ‚Üí Y} (h : lipschitz_with K f) : dimH (set.range f) ‚â§ dimH set.univ
{Œ± : Type u_1} (s : set (set Œ±)) : set Œ± ‚Üí Prop
{X : Type u_1} [topological_space X] {x y : X} (h : joined x y) : path x y
{Œ± : Type u} {s : set Œ±} [decidable_pred (Œª (_x : Œ±), _x ‚àà s)] {a : Œ±} (H : a ‚àâ s) : ‚Ü•(has_insert.insert a s) ‚âÉ ‚Ü•s ‚äï punit
(L : first_order.language) : L ‚Üí·¥∏ L
{Œ± : Type u} [linear_order Œ±] : is_idempotent Œ± linear_order.min
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] : has_dist (bounded_continuous_function Œ± Œ≤)
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : differentiable_on ‚Ñù f (interior D)) {C : ‚Ñù} (hf'_gt : ‚àÄ (x : ‚Ñù), x ‚àà interior D ‚Üí C < deriv f x) (x : ‚Ñù) (H : x ‚àà D) (y : ‚Ñù) (H_1 : y ‚àà D) : x < y ‚Üí C * (y - x) < f y - f x
{Œ± : Type u_1} [add_semigroup Œ±] (x y : Œ±) : ((Œª (_x : Œ±), _x + x) ‚àò Œª (_x : Œ±), _x + y) = Œª (_x : Œ±), _x + (y + x)
(p q : omega.int.preform) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {A : Mon_ C} {M N O : Mod A} (f : M.hom N) (g : N.hom O) : M.hom O
(R : Type u) (Œπ : Type v) [comm_ring R] (L : Œπ ‚Üí Type w) [Œ† (i : Œπ), lie_ring (L i)] [Œ† (i : Œπ), lie_algebra R (L i)] (j : Œπ) : direct_sum Œπ (Œª (i : Œπ), L i) ‚Üí‚Çó‚ÅÖR‚ÅÜ L j
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A ‚ü∂ B) [category_theory.limits.has_image f] (g : B ‚ü∂ C) [category_theory.limits.has_kernel g] (w : f ‚â´ g = 0) [category_theory.limits.has_cokernel (image_to_kernel f g w)] : ‚Üë(category_theory.limits.kernel_subobject g) ‚ü∂ homology f g w
{C : Type u} [category_theory.category C] [category_theory.enough_injectives C] (X : C) : X ‚ü∂ category_theory.injective.under X
 : interactive.parse tactic.interactive.cases_arg_p ‚Üí tactic unit
(l : list (name √ó binder_info √ó expr)) : list (expr √ó binder_info √ó list name)
{Œ± : Type u} (s : set Œ±) [decidable_pred (Œª (_x : Œ±), _x ‚àà s)] : Œ± ‚âÉ. Œ±
{P : pfunctor} [decidable_eq P.A] {Œ± : Type u_2} [inhabited Œ±] (x : P.obj Œ±) (i : P.Idx) : Œ±
(red : interactive.parse (optional (lean.parser.tk "!"))) : tactic unit
{Œ± : Type u_1} [h : encodable Œ±] : encodable (option Œ±)
{X : Type u} {Y : Type v} [metric_space X] [metric_space Y] : X ‚äï Y ‚Üí X ‚äï Y ‚Üí ‚Ñù
(R : Type u) [semiring R] (n : ‚Ñï) : submodule R (polynomial R)
{Œ≤ : Type u} (f : Œ≤ ‚Üí Type u) {P : Type u} (s : Œ† (b : Œ≤), P ‚ü∂ f b) (b : Œ≤) (x : P) : category_theory.limits.pi.œÄ f b (category_theory.limits.pi.lift s x) = s b x
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [cs : complete_space E] {f : E ‚Üí F} {f' : E ‚âÉL[ùïú] F} {a : E} (hf : has_strict_fderiv_at f ‚Üëf' a) : has_strict_fderiv_at (has_strict_fderiv_at.local_inverse f f' a hf) ‚Üë(f'.symm) (f a)
{Œ± : Type u} {Œ≤ : Type v} [has_inf Œ±] [semilattice_inf Œ≤] (f : Œ± ‚Üí Œ≤) (hf_inj : function.injective f) (map_inf : ‚àÄ (a b : Œ±), f (a ‚äì b) = f a ‚äì f b) : semilattice_inf Œ±
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] {f : J ‚Üí C} (b : category_theory.limits.bicone f) (total : finset.univ.sum (Œª (j : J), b.œÄ j ‚â´ b.Œπ j) = ùüô b.X) : b.is_bilimit
 : Type (u+1)
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (ùïú' : Type u_10) [normed_ring ùïú'] [normed_algebra ùïú ùïú'] [norm_one_class ùïú'] : ùïú' ‚Üí‚Çó·µ¢[ùïú] ùïú' ‚ÜíL[ùïú] ùïú'
{Œ± : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul Œ±] [add_comm_monoid Œ±] (A : matrix m n Œ±) [fintype m] : Prop
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] (a b : Œ±) : multiset Œ±
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] (f‚ÇÅ : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (f‚ÇÇ : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÅ] M‚ÇÅ) (h‚ÇÅ : function.left_inverse ‚áëf‚ÇÇ ‚áëf‚ÇÅ) (h‚ÇÇ : function.right_inverse ‚áëf‚ÇÇ ‚áëf‚ÇÅ) : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ
{Œ± : Type u} [topological_space Œ±] [t2_space Œ±] (s : finset Œ±) : ‚àÉ (f : Œ± ‚Üí set Œ±), ‚Üës.pairwise_disjoint f ‚àß ‚àÄ (x : Œ±), x ‚àà s ‚Üí x ‚àà f x ‚àß is_open (f x)
{Œ± : Type u_1} [group Œ±] {s : subgroup Œ±} (a : Œ±) : Œ± ‚ß∏ s
{Œ≥ : Type} (gr ir rr : list (widget.html Œ≥)) : list (widget.html Œ≥) ‚Üí widget.html Œ≥
(g : expr_map (list (expr √ó expr))) (visit : tactic.ref (expr_map bool)) (cl : tactic.closure) : list (expr √ó expr) ‚Üí expr ‚Üí tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q R S : C} {f : P ‚ü∂ Q} {g : P ‚ü∂ R} {h : Q ‚ü∂ S} {k : R ‚ü∂ S} [gn : category_theory.normal_epi g] (comm : f ‚â´ h = g ‚â´ k) (t : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk h k comm)) : category_theory.normal_epi h
{Œ± : Type u_1} {Œ≤ : Type u_2} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] {K : nnreal} {f : Œ± ‚Üí Œ≤} (hf : antilipschitz_with K f) : nnreal
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] {x‚ÇÄ : Œ±} {K : set Œ≤} (hK : is_compact K) {P : Œ± ‚Üí Œ≤ ‚Üí Prop} (hP : ‚àÄ (y : Œ≤), y ‚àà K ‚Üí (‚àÄ·∂† (z : Œ± √ó Œ≤) in nhds (x‚ÇÄ, y), P z.fst z.snd)) : ‚àÄ·∂† (x : Œ±) in nhds x‚ÇÄ, ‚àÄ (y : Œ≤), y ‚àà K ‚Üí P x y
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Sort u} (i : fin (n + 1)) (x : Œ± i) (p : Œ† (j : fin n), Œ± (‚áë(i.succ_above) j)) (j : fin (n + 1)) : Œ± j
{F : Type (max u‚ÇÄ v‚ÇÄ) ‚Üí Type u‚ÇÅ} {G : Type u‚ÇÄ ‚Üí Type v‚ÇÅ} [inst : uliftable G F] [functor F] {Œ± : Type (max u‚ÇÄ v‚ÇÄ)} {Œ≤ : Type u‚ÇÄ} (f : Œ± ‚Üí Œ≤) (x : F Œ±) : G Œ≤
{ùïú : Type u_1} {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field ùïú] [normed_space ùïú E] : semi_normed_ring (E ‚ÜíL[ùïú] E)
{Œ± : Type u} : format ‚Üí (unit ‚Üí Œ±) ‚Üí Œ±
{Œ± : Type u} {s : set (set Œ±)} (hs : cardinal.mk ‚Ü•s ‚â§ cardinal.continuum) : cardinal.mk ‚Ü•{t : set Œ± | measurable_space.generate_measurable s t} ‚â§ cardinal.continuum
{l : Type u_1} {m : Type u_2} {n : Type u_3} {Œ± : Type v} [fintype m] [has_mul Œ±] [add_comm_monoid Œ±] (M : matrix l m Œ±) (N : matrix m n Œ±) : matrix l n Œ±
{Œ± : Type u_2} [division_comm_monoid Œ±] : division_comm_monoid (filter Œ±)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {s : set E} {f : E ‚Üí F} {n : with_top ‚Ñï} (g : F ‚ÜíL[ùïú] G) (hf : cont_diff_on ùïú n f s) : cont_diff_on ùïú n (‚áëg ‚àò f) s
{Œ± : Sort u_1} (a : Œ±) : trunc Œ±
{Œ± : Type u_1} : list Œ± ‚Üí list (list Œ±)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [mul_one_class Œ≥] [has_continuous_mul Œ≥] (g : C(Œ±, Œ≤)) : C(Œ≤, Œ≥) ‚Üí* C(Œ±, Œ≥)
{A : Type u_4} {B : Type u_5} {C : Type u_6} [monoid A] [monoid B] [monoid C] [topological_space A] [topological_space B] [topological_space C] (g : continuous_monoid_hom B C) (f : continuous_monoid_hom A B) : continuous_monoid_hom A C
{K : Type u} [hring : comm_ring K] : ratfunc K ‚Üí ratfunc K ‚Üí ratfunc K
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {Œ± : Type u_1} {Œ≤ : Type u_2} [has_scalar Œ± Œ≤] [has_scalar A Œ±] [has_scalar A Œ≤] [is_scalar_tower A Œ± Œ≤] (S : subalgebra R A) : is_scalar_tower ‚Ü•S Œ± Œ≤
{Œ± Œ≤ : LinearOrder} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
(inner : tactic.interactive.itactic) : tactic unit
{G : Type u_1} [group G] [topological_space G] {H : Type u_2} [group H] [topological_space H] (U : open_subgroup G) (V : open_subgroup H) : open_subgroup (G √ó H)
{G : Type u_1} [topological_space G] [add_group G] [topological_add_group G] (N : add_subgroup G) [N.normal] : N.topological_closure.normal
(Œ± : Type u) : Type u
{M : Type u_3} [add_comm_group M] : add_subgroup M ‚âÉo submodule ‚Ñ§ M
{R : Type u} [ring R] (M : Module R) : Module.of R ‚Ü•M ‚âÖ M
 : tactic unit
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : ‚Ñï
{P : Type u_1} [preorder P] : partial_order (order.pfilter P)
(R : Type u_1) : Type u_1
{A : Type u_4} [comm_ring A] [is_domain A] {K : Type u_5} [field K] {L : Type u_7} [field L] [algebra A K] [is_fraction_ring A K] {g : A ‚Üí+* L} (hg : function.injective ‚áëg) : K ‚Üí+* L
{ùïú : Type u_1} {Œ± : Type u_2} [linear_ordered_field ùïú] [decidable_eq Œ±] {k : ‚Ñï} {ùíú : finset (finset Œ±)} [fintype Œ±] (hk : k ‚â§ fintype.card Œ±) (hùíú : is_antichain has_subset.subset ‚Üëùíú) : (finset.range (k + 1)).sum (Œª (r : ‚Ñï), ‚Üë((ùíú.slice (fintype.card Œ± - r)).card) / ‚Üë((fintype.card Œ±).choose (fintype.card Œ± - r))) ‚â§ ‚Üë((finset.falling (fintype.card Œ± - k) ùíú).card) / ‚Üë((fintype.card Œ±).choose (fintype.card Œ± - k))
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] (F : category_theory.lax_monoidal_functor C D) : Mon_ C ‚•§ Mon_ D
 : tactic.ring.horner_expr ‚Üí bool
(M : Type u_1) (A : Type u_4) [monoid M] [add_monoid A] [distrib_mul_action M A] : M ‚Üí* add_monoid.End A
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Type v
{Œ± : Type u_1} : Œ±·µí·µà ‚âÉ Œ±
{Œ∑ : Type u_1} [fintype Œ∑] {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), group (Gs i)] (H K : Œ† (i : Œ∑), subgroup (Gs i)) : ‚ÅÖsubgroup.pi set.univ H,subgroup.pi set.univ K‚ÅÜ = subgroup.pi set.univ (Œª (i : Œ∑), ‚ÅÖH i,K i‚ÅÜ)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} [complete_space E] (e : E ‚âÉL[ùïú] F) : cont_diff_at ùïú n continuous_linear_map.inverse ‚Üëe
(Œ± : Type u_8) : Type u_8
(R : Type w) [ring R] (C : Type u) [category_theory.category C] [category_theory.preadditive C] [category_theory.linear R C] : C ‚•§ C·µí·µñ ‚•§ Module R
{C : Type u‚ÇÅ} [category_theory.category C] (A B : C·µí·µñ) : (A ‚ü∂ B) ‚âÉ (opposite.unop B ‚ü∂ opposite.unop A)
(n p : ‚Ñï) : (finset.filter (Œª (e : ‚Ñï), p ‚à£ e + 1) (finset.range n)).card = n / p
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.fst
{R : Type u} {S : Type v} [semiring R] [add_comm_monoid S] (p : polynomial R) {f : ‚Ñï ‚Üí R ‚Üí S} (h : ‚àÄ (n : ‚Ñï), f n 0 = 0) : p.sum f = (finset.range (p.nat_degree + 1)).sum (Œª (a : ‚Ñï), f a (p.coeff a))
{X : Top} {T : ‚Ü•X ‚Üí Type v} (P : Top.local_predicate T) : Top.sheaf (Type v) X
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] (F : J √ó K ‚•§ Type v) [category_theory.is_filtered K] [category_theory.fin_category J] : function.surjective (category_theory.limits.colimit_limit_to_limit_colimit F)
{M : Type u_5} [monoid M] {A : Type u_6} [add_monoid A] [distrib_mul_action M A] {B : Type u_8} [add_monoid B] [distrib_mul_action M B] (f : A ‚Üí+[M] B) (g : B ‚Üí A) (h‚ÇÅ : function.left_inverse g ‚áëf) (h‚ÇÇ : function.right_inverse g ‚áëf) : B ‚Üí+[M] A
{Œ± : Type u} [pseudo_emetric_space Œ±] {s t : set Œ±} : emetric.Hausdorff_edist (closure s) t = emetric.Hausdorff_edist s t
{R : Type u} [non_assoc_semiring R] (s : set R) : subsemiring R
{Œ± : Type u_1} [topological_space Œ±] {x : Œ±} {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] [has_continuous_add Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : upper_semicontinuous_at f x) (hg : upper_semicontinuous_at g x) : upper_semicontinuous_at (Œª (z : Œ±), f z + g z) x
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L
{Œ≤ : Type u} {Œ± : Type v} {s : finset Œ±} {f : Œ± ‚Üí Œ≤} [add_comm_monoid Œ≤] (R : setoid Œ±) [decidable_rel setoid.r] : s.sum (Œª (x : Œ±), f x) = (finset.image quotient.mk s).sum (Œª (xbar : quotient R), (finset.filter (Œª (y : Œ±), ‚ü¶y‚üß = xbar) s).sum (Œª (y : Œ±), f y))
{M : Type u_1} {N : Type u_2} [add_monoid M] [add_monoid N] [fintype M] [decidable_eq N] (f : M ‚Üí+ N) : fintype ‚Ü•(f.mrange)
{M' : Type u_4} {Œ± : Type u_5} [monoid M'] [add_monoid Œ±] [distrib_mul_action M' Œ±] (S : submonoid M') : distrib_mul_action ‚Ü•S Œ±
{Œ≤ : Type v} [normed_field Œ≤] [cau_seq.is_complete Œ≤ has_norm.norm] : complete_space Œ≤
(K : Type u‚ÇÅ) [field K] (v : valuation K nnreal) (O : Type u‚ÇÇ) [comm_ring O] [algebra O K] (hv : v.integers O) (p : ‚Ñï) [hp : fact (nat.prime p)] [hvp : fact (‚áëv ‚Üëp ‚â† 1)] : Type u‚ÇÇ
{C D E : category_theory.Groupoid} (f : C ‚ü∂ D) (g : D ‚ü∂ E) : f ‚â´ g = f ‚ãô g
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {x : E} {n : with_top ‚Ñï} {s : set E} {f : E ‚Üí F} (hf : cont_diff_within_at ùïú n f s x) : cont_diff_within_at ùïú n (Œª (x : E), -f x) s x
 : Type
 : omega.nat.preform ‚Üí tactic expr
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f g : C(Œ±, Œ≤)} (H : f = g) (x : Œ±) : ‚áëf x = ‚áëg x
{M : Type u_1} {X : Type u_2} [topological_space M] [topological_space X] [has_scalar M X] [has_continuous_smul M X] [has_scalar M·µê·µí·µñ X] [is_central_scalar M X] : has_continuous_smul M·µê·µí·µñ X
{G : Type w} [topological_space G] [add_group G] [topological_add_group G] {K U : set G} (hK : is_compact K) (hU : is_open U) (hKU : K ‚äÜ U) : ‚àÉ (V : set G) (H : V ‚àà nhds 0), V + K ‚äÜ U
(x : interactive.parse (lean.parser.tk "#html")) : lean.parser unit
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : x.some_vector ‚â† 0
{M : Type u_1} [monoid M] [decidable_eq M] {n : M} (h : function.injective (Œª (m : ‚Ñï), n ^ m)) : multiplicative ‚Ñï ‚âÉ* ‚Ü•(submonoid.powers n)
{Œ± : Type u} (s1 s2 : wseq Œ±) : wseq Œ±
(p : ‚Ñï) [hp : fact (nat.prime p)] : ‚Ñï ‚Üí mv_polynomial (fin 2 √ó ‚Ñï) ‚Ñ§
(Œ± : Type u_1) (Œ≤ : Type u_2) [unique Œ±] [preorder Œ≤] : (Œ± ‚Üí Œ≤) ‚âÉo Œ≤
(k : Type u_1) {V1 : Type u_2} {P1 : Type u_3} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] (p : P1) : ‚áë(affine_map.id k P1) p = p
{M : Type u_1} [has_mul M] {Œ≤ : Sort u_2} {c : con M} (q : c.quotient) (f : M ‚Üí Œ≤) (h : ‚àÄ (a b : M), ‚áëc a b ‚Üí f a = f b) : Œ≤
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (A : C) [category_theory.closed A] : category_theory.ihom A ‚ãô category_theory.monoidal_category.tensor_left A ‚ü∂ ùü≠ C
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u} [category_theory.category C] (F : J ‚•§ C) [category_theory.limits.has_limit F] (E : K ‚•§ J) [category_theory.limits.has_limit (E ‚ãô F)] : category_theory.limits.limit F ‚ü∂ category_theory.limits.limit (E ‚ãô F)
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} (r : mvqpf.cofix F Œ± ‚Üí mvqpf.cofix F Œ± ‚Üí Prop) (h : ‚àÄ (x y : mvqpf.cofix F Œ±), r x y ‚Üí mvfunctor.liftr (Œ±.rel_last r) x.dest y.dest) (x y : mvqpf.cofix F Œ±) : r x y ‚Üí x = y
{C : Type u} [category_theory.category C] {X Y : Top} (H : X ‚âÖ Y) {‚Ñ± : Top.presheaf C X} {ùí¢ : Top.presheaf C Y} (Œ± : H.hom _* ‚Ñ± ‚ü∂ ùí¢) : ‚Ñ± ‚ü∂ H.inv _* ùí¢
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P (n + 1)) (i : fin (n + 2)) : s.points i ‚àà s.altitude i
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [densely_ordered Œ±] : {s : set Œ± | is_preconnected s} = set.range (function.uncurry set.Icc) ‚à™ set.range (function.uncurry set.Ico) ‚à™ set.range (function.uncurry set.Ioc) ‚à™ set.range (function.uncurry set.Ioo) ‚à™ (set.range set.Ici ‚à™ set.range set.Ioi ‚à™ set.range set.Iic ‚à™ set.range set.Iio ‚à™ {set.univ, ‚àÖ})
(clear_dependent : bool) (hyps : list expr) : tactic unit
(Œ± : Sort u_1) : Sort (max 1 u_1)
{Œ± : Type u} [pseudo_metric_space Œ±] (R : ‚Ñù) (h : ‚àÄ (x : Œ±) (r : ‚Ñù), R ‚â§ r ‚Üí is_compact (metric.closed_ball x r)) : proper_space Œ±
{J : Type v} {C : Type u} [category_theory.category C] {B : C} {objs : J ‚Üí C} (arrows : Œ† (j : J), objs j ‚ü∂ B) [category_theory.limits.has_wide_pullback B objs arrows] : category_theory.limits.wide_pullback B (Œª (j : J), objs j) arrows ‚ü∂ B
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (R‚ÇÇ : Type u_5) [comm_semiring R‚ÇÇ] [algebra R‚ÇÇ R] [module R‚ÇÇ M] [is_scalar_tower R‚ÇÇ R M] : bilin_form R M ‚Üí‚Çó[R‚ÇÇ] M ‚Üí‚Çó[R‚ÇÇ] M ‚Üí‚Çó[R] R
 : native.float ‚Üí bool
(k n : ‚Ñï) : multiset (fin k ‚Üí ‚Ñï)
 : native.float ‚Üí bool
(ids : interactive.parse (lean.parser.many lean.parser.ident)) : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] {G H : C ‚•§ D} (Œ± : G ‚ü∂ H) (F : D ‚•§ E) : G ‚ãô F ‚ü∂ H ‚ãô F
(k : Type u_1) (P‚ÇÅ : Type u_2) {V‚ÇÅ : Type u_6} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] : multiplicative V‚ÇÅ ‚Üí* P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÅ
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (hf : function.injective2 f) [nonempty Œ±] : function.injective (Œª (b : Œ≤) (a : Œ±), f a b)
{R : Type u_1} [comm_semiring R] {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] (x : R) [is_localization.away x S] {g : R ‚Üí+* P} (hg : is_unit (‚áëg x)) : S ‚Üí+* P
{Œ± : Type u} [monoid Œ±] (u : Œ±À£) : Œ±
{C : Type u‚ÇÅ} [category_theory.category C] (Y : C) [h : Œ† (X : C), unique (X ‚ü∂ Y)] : category_theory.limits.is_terminal Y
{m‚ÇÅ : Type u‚ÇÄ ‚Üí Type v‚ÇÄ} {m‚ÇÇ : Type u‚ÇÅ ‚Üí Type v‚ÇÅ} {Œ±‚ÇÅ r‚ÇÅ : Type u‚ÇÄ} {Œ±‚ÇÇ r‚ÇÇ : Type u‚ÇÅ} (F : m‚ÇÅ r‚ÇÅ ‚âÉ m‚ÇÇ r‚ÇÇ) (G : Œ±‚ÇÅ ‚âÉ Œ±‚ÇÇ) : cont_t r‚ÇÅ m‚ÇÅ Œ±‚ÇÅ ‚âÉ cont_t r‚ÇÇ m‚ÇÇ Œ±‚ÇÇ
{R : Type u_2} {S : Type u_4} [semiring R] [semiring S] (f : R ‚Üí+* S) : module R S
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u} [category_theory.category J] {X : J} (hX : category_theory.limits.is_terminal X) (F : J ‚•§ C) [‚àÄ (i j : J) (f : i ‚ü∂ j), category_theory.is_iso (F.map f)] : category_theory.limits.is_limit (category_theory.limits.cone_of_diagram_terminal hX F)
{X : Type u_1} {Y : Type u_2} [preorder X] [preorder Y] (f : X ‚Ü™o Y) : X ‚Üío Y
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (n : A) : C ‚âå C
{J : Type v} [category_theory.small_category J] {F : J ‚•§ category_theory.discrete punit} : category_theory.limits.cone F
{G : Type u_1} [group G] {G‚ÇÇ : Type u_2} [group G‚ÇÇ] (p‚ÇÅ p‚ÇÇ : ‚Ñï) [hp‚ÇÅ : fact (nat.prime p‚ÇÅ)] [hp‚ÇÇ : fact (nat.prime p‚ÇÇ)] (hne : p‚ÇÅ ‚â† p‚ÇÇ) (H‚ÇÅ : subgroup G) (H‚ÇÇ : subgroup G‚ÇÇ) [fintype ‚Ü•H‚ÇÅ] [fintype ‚Ü•H‚ÇÇ] (hH‚ÇÅ : is_p_group p‚ÇÅ ‚Ü•H‚ÇÅ) (hH‚ÇÇ : is_p_group p‚ÇÇ ‚Ü•H‚ÇÇ) : (fintype.card ‚Ü•H‚ÇÅ).coprime (fintype.card ‚Ü•H‚ÇÇ)
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} [comm_ring R] [lie_ring L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÅ] [lie_algebra R L‚ÇÇ] (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) (h : function.injective ‚áëf) : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ ‚Ü•(f.range)
(Œ± : Type) : Type
(X : Type u) [topological_space X] : continuous_map.homotopy_equiv X X
{Œ± : Type u} [semilattice_sup Œ±] [order_bot Œ±] (x y : Œ±) : (x ‚®ø y) = x ‚äî y
(K : Type u_1) {V : Type u_2} [field K] [add_comm_group V] [module K V] (v : V) (hv : v ‚â† 0) : ‚Ñô K V
{X Y : Profinite} (f : X ‚âÖ Y) : ‚Ü•X ‚âÉ‚Çú ‚Ü•Y
 : ‚ÑÇ ‚Üí‚Çê[‚Ñù] clifford_algebra clifford_algebra_complex.Q
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (X : C) : J.pullback (ùüô X) ‚âÖ ùü≠ (J.cover X)
{Œ± : Type uu} : list Œ± ‚Üí list Œ± √ó list Œ±
(R : Type u) [comm_ring R] : galois_connection (Œª (s : set R), prime_spectrum.zero_locus s) (Œª (t : (set (prime_spectrum R))·µí·µà), ‚Üë(prime_spectrum.vanishing_ideal t))
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_zero_class M] (f : Œ± ‚Ü™ Œ≤) : (Œ± ‚Üí‚ÇÄ M) ‚Üí+ Œ≤ ‚Üí‚ÇÄ M
{C : Type u‚ÇÅ} [category_theory.category C] {X‚ÇÅ‚ÇÅ X‚ÇÅ‚ÇÇ X‚ÇÇ‚ÇÅ X‚ÇÇ‚ÇÇ X‚ÇÉ‚ÇÅ X‚ÇÉ‚ÇÇ : C} {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÉ‚ÇÅ : X‚ÇÉ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÇ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ} {v‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÅ} {v‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÉ‚ÇÇ} (s : category_theory.is_pushout h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ) (t : category_theory.is_pushout h‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÇ h‚ÇÉ‚ÇÅ) : category_theory.is_pushout h‚ÇÅ‚ÇÅ (v‚ÇÅ‚ÇÅ ‚â´ v‚ÇÇ‚ÇÅ) (v‚ÇÅ‚ÇÇ ‚â´ v‚ÇÇ‚ÇÇ) h‚ÇÉ‚ÇÅ
(L : first_order.language) (n : ‚Ñï) : L.sentence
{G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) {f : G ‚Üí* N} (hf : function.bijective ‚áëf) : subgroup.map f H.normalizer = (subgroup.map f H).normalizer
(Œπ : Type u_1) : complex_shape Œπ
(R : Type u) [ring R] : Prop
(p : Type u_2) (q : Type u_3) (R : Type u‚ÇÇ) [decidable_eq p] [decidable_eq q] [comm_ring R] [fintype p] [fintype q] {i : R} (hi : i * i = -1) : ‚Ü•(lie_algebra.orthogonal.so' p q R) ‚âÉ‚Çó‚ÅÖR‚ÅÜ ‚Ü•(lie_algebra.orthogonal.so (p ‚äï q) R)
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [comm_monoid N] (f : Œ± ‚Üí‚ÇÄ M) (g : Œ± ‚Üí M ‚Üí N) : N
(Œ± : Type u_1) {Œ≤ : Type u_2} [linear_order Œ±] [linear_order Œ≤] [densely_ordered Œ±] [no_min_order Œ±] [no_max_order Œ±] [nonempty Œ±] (b : Œ≤) : order.cofinal (order.partial_iso Œ± Œ≤)
{Œ± : Type u_1} {Œπ : Type u_2} (f : Œπ ‚Üí measure_theory.outer_measure Œ±) : measure_theory.outer_measure Œ±
(e : expr) (c : name) (n : ‚Ñï) : bool
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] {V‚ÇÇ : Type v'} [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] [finite_dimensional K V] [finite_dimensional K V‚ÇÇ] (f : V ‚Üí‚Çó[K] V‚ÇÇ) (hf : function.injective ‚áëf) (hdim : finite_dimensional.finrank K V = finite_dimensional.finrank K V‚ÇÇ) : V ‚âÉ‚Çó[K] V‚ÇÇ
{C : Type u} [category_theory.category C] {J K : Type u‚ÇÅ} [category_theory.category J] [category_theory.category K] (F : J ‚•§ C) (G : K ‚•§ C) (h : F.cones ‚âÖ G.cones) [category_theory.limits.has_limit F] : category_theory.limits.has_limit G
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Œπ ‚Üí M} [semiring R] [add_comm_monoid M] [module R M] {s : set Œπ} : ¬¨linear_independent R (v ‚àò coe) ‚Üî ‚àÉ (f : Œπ ‚Üí‚ÇÄ R), f ‚àà finsupp.supported R R s ‚àß f.support.sum (Œª (i : Œπ), ‚áëf i ‚Ä¢ v i) = 0 ‚àß f ‚â† 0
{Œ± : Sort u} : Œ± ‚âÉ Œ±·µí·µñ
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Group) : (Œ£ (j : J), ‚Ü•(F.obj j)) ‚Üí ‚Ü•(Group.filtered_colimits.G F)
{Œ± : Type u} (s : stream Œ±) : Œ±
 : expr ‚Üí tactic (expr √ó expr)
{L : first_order.language} : setoid (category_theory.bundled L.Structure)
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [mul_zero_one_class M] [mul_zero_one_class N] : Type (max u_10 u_11 u_9)
(Œ± : Type u) [topological_space Œ±] [sigma_compact_space Œ±] : ‚Ñï ‚Üí set Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} {P : category_theory.subobject Y} {f g : X ‚ü∂ ‚ÜëP} (h : f ‚â´ P.arrow = g ‚â´ P.arrow) : f = g
{Œ± : Type u} {Œ≤ : Type v} [rŒ± : semiring Œ±] [rŒ≤ : semiring Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_semiring_hom f) : Œ± ‚Üí+* Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_mono f] : category_theory.regular_mono f
{J : Type v} {C : Type u} [category_theory.category C] {B : C} {objs : J ‚Üí C} (arrows : Œ† (j : J), B ‚ü∂ objs j) [category_theory.limits.has_wide_pushout B objs arrows] (j : J) : objs j ‚ü∂ category_theory.limits.wide_pushout B (Œª (j : J), objs j) arrows
{Œπ : Type u_1} [fintype Œπ] [decidable_eq Œπ] {R : Type u_2} [semiring R] (x : Œπ ‚Üí R) : x = finset.univ.sum (Œª (i : Œπ), x i ‚Ä¢ Œª (j : Œπ), ite (i = j) 1 0)
{J : Type v} {C : Type u} [category_theory.category C] (B : C) (F : category_theory.discrete J ‚•§ category_theory.over B) : ùü≠ (category_theory.limits.cone (category_theory.over.construct_products.wide_pullback_diagram_of_diagram_over B F)) ‚âÖ category_theory.over.construct_products.cones_equiv_functor B F ‚ãô category_theory.over.construct_products.cones_equiv_inverse B F
{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {K : nnreal} (f : Œ± ‚Üí Œ≤) (hf : lipschitz_with K f) : locally_bounded_map Œ± Œ≤
 : tactic (list (string √ó string))
{V : Type u} [fintype V] [decidable_eq V] {‚Ñì : ‚Ñï} : ‚ä•.is_SRG_with (fintype.card V) 0 ‚Ñì 0
{Œ± : Type u_1} {M : Type u_3} [monoid M] [monoid Œ±] [mul_distrib_mul_action Œ± M] : mul_action Œ± (submonoid M)
 : Type
{Œ± : Type u} (a : Œ±) : computation Œ±
{M : Type u} [add_monoid M] {N : Type u} [add_monoid N] {K : Type u} [add_monoid K] (F : M ‚Üí+ N) (G : N ‚Üí+ K) : discrete.add_monoidal_functor F ‚äó‚ãô discrete.add_monoidal_functor G ‚âÖ discrete.add_monoidal_functor (G.comp F)
(Œ± : Sort u_1) (Œ≤ : Sort u_2) [is_empty Œ±] [is_empty Œ≤] : Œ± ‚âÉ Œ≤
{Œπ : Type u_1} {ùïú : Type u_2} [is_R_or_C ùïú] {E : Type u_3} [inner_product_space ùïú E] : has_coe_to_fun (hilbert_basis Œπ ùïú E) (Œª (_x : hilbert_basis Œπ ùïú E), Œπ ‚Üí E)
{Œ± : Type u_2} [decidable_eq Œ±] [semigroup Œ±] : semigroup (finset Œ±)
{et : tactic.ring_exp.ex_type} (ps : tactic.ring_exp.ex et) : option expr
{C : Type u‚ÇÅ} [category_theory.category C] {T‚ÇÅ T‚ÇÇ : category_theory.monad C} (h : T‚ÇÅ ‚âÖ T‚ÇÇ) : T‚ÇÅ.algebra ‚âå T‚ÇÇ.algebra
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤] {f : C(Œ±, Œ≤)} {Œπ : Type u‚ÇÉ} {p : filter Œπ} {F : Œπ ‚Üí C(Œ±, Œ≤)} [compact_space Œ±] : filter.tendsto F p (nhds f) ‚Üî tendsto_uniformly (Œª (i : Œπ) (a : Œ±), ‚áë(F i) a) ‚áëf p
{E : Type u_1} {Œ≤ : Type u_2} [add_comm_group E] [topological_space E] [module ‚Ñù E] [topological_add_group E] [has_continuous_smul ‚Ñù E] [ordered_add_comm_group Œ≤] [module ‚Ñù Œ≤] [ordered_smul ‚Ñù Œ≤] {s : set E} {f : E ‚Üí Œ≤} {a : E} (a_in_s : a ‚àà s) (h_localmin : is_local_min_on f s a) (h_conv : convex_on ‚Ñù s f) : is_min_on f s a
{C : Type u‚ÇÅ} [category_theory.category C] (F : C ‚•§ Type v‚ÇÅ) [F.corepresentable] : category_theory.coyoneda.obj (opposite.op F.corepr_X) ‚âÖ F
{k : Type u_1} {P‚ÇÅ : Type u_2} {P‚ÇÇ : Type u_3} {P‚ÇÉ : Type u_4} {V‚ÇÅ : Type u_6} {V‚ÇÇ : Type u_7} {V‚ÇÉ : Type u_8} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] [add_comm_group V‚ÇÉ] [module k V‚ÇÉ] [add_torsor V‚ÇÉ P‚ÇÉ] (e : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) (e' : P‚ÇÇ ‚âÉ·µÉ[k] P‚ÇÉ) : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÉ
 : linarith.comp ‚Üí linarith.comp ‚Üí ordering
(Œ± : Type u_1) (Œ≤ : Type u_2) [preorder Œ±] [preorder Œ≤] : (Œ± ‚Üío Œ≤) ‚âÉo (Œ±·µí·µà ‚Üío Œ≤·µí·µà)·µí·µà
{Œπ : Type u_6} [decidable_eq Œπ] {K : Type u_1} [ring K] {M : Type u_2} [add_comm_group M] [module K M] {N : Type u_3} [add_comm_group N] [module K N] [no_zero_smul_divisors K N] (f : alternating_map K M N Œπ) (v : Œπ ‚Üí M) (h : ¬¨linear_independent K v) : ‚áëf v = 0
{R : Type u} [comm_semiring R] : polynomial R ‚Üí polynomial R ‚Üí+* polynomial R
(C : Type u_1) [category_theory.category C] : category_theory.idempotents.karoubi C ‚âå category_theory.idempotents.karoubi (category_theory.idempotents.karoubi C)
(R : Type u_1) (M : Type u_7) [semiring R] [add_comm_monoid M] [module R M] : M ‚âÉ‚Çó[R] M
{Œ± : Type u_1} {s : multiset Œ±} : s.powerset.nodup ‚Üí s.nodup
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [ring R] [nontrivial R] [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (v : Œπ ‚Üí M) [unique Œπ] : v inhabited.default ‚â† 0 ‚Üí linear_independent R v
(G : Type u) [topological_space G] [add_group G] : Prop
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [add_zero_class M] [add_zero_class N] : Type (max u_10 u_11 u_9)
{ùïú : Type u_3} {G : Type u_4} [is_R_or_C ùïú] [normed_group G] [normed_space ùïú G] {f : ùïú ‚Üí G} {s : set ùïú} {C : nnreal} (hs : convex ‚Ñù s) (hf : differentiable_on ùïú f s) (bound : ‚àÄ (x : ùïú), x ‚àà s ‚Üí ‚à•deriv_within f s x‚à•‚Çä ‚â§ C) : lipschitz_on_with C f s
{Œ± : Type u_1} [decidable_eq Œ±] (s t : multiset Œ±) : multiset Œ±
{Œπ : Type u_1} {R : Type u_3} {A : Type u_5} {x : Œπ ‚Üí A} [comm_ring R] [comm_ring A] [algebra R A] (hx : algebraic_independent R x) : ‚Ü•(algebra.adjoin R (set.range x)) ‚Üí‚Çê[R] mv_polynomial Œπ R
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] : ùü≠ (Mon_ (C ‚•§ D)) ‚âÖ category_theory.monoidal.Mon_functor_category_equivalence.functor ‚ãô category_theory.monoidal.Mon_functor_category_equivalence.inverse
(R : Type u_1) [rack R] (G : Type u_2) [group G] (f : shelf_hom R (quandle.conj G)) : (quandle.conj.map (‚áërack.to_envel_group.map f)).comp (rack.to_envel_group R) = f
{Œ± : Type u} {l‚ÇÅ l‚ÇÇ : list Œ±} (i : ‚Ñï) : list.drop (l‚ÇÅ.length + i) (l‚ÇÅ ++ l‚ÇÇ) = list.drop i l‚ÇÇ
{Œ± : Type u} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_antisymm Œ± r] {a b : Œ±} : r a b ‚Üí r b a ‚Üí b = a
{Œ± : Type uu} (r : Œ± ‚Üí Œ± ‚Üí Prop) [decidable_rel r] : list Œ± ‚Üí list Œ±
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddGroup) : (Œ£ (j : J), ‚Ü•(F.obj j)) ‚Üí ‚Ü•(AddGroup.filtered_colimits.G F)
(Œ± : Type u_1) (Œ≤ : Type u_2) : (Œ£ (_x : Œ±), Œ≤) ‚âÉ Œ± √ó Œ≤
 : Type
{f : ‚Ñï ‚Üí nnreal} {r : nnreal} : has_sum f r ‚Üî filter.tendsto (Œª (n : ‚Ñï), (finset.range n).sum (Œª (i : ‚Ñï), f i)) filter.at_top (nhds r)
{G : Type u_1} [group G] {M : Type u_5} [mul_one_class M] (f : G ‚Üí* M) : subgroup G
(ùïú : Type u_1) {E : Type u_4} [normed_group E] [nondiscrete_normed_field ùïú] [normed_space ùïú E] (x : E) (h : x ‚â† 0) : ‚Ü•(submodule.span ùïú {x}) ‚ÜíL[ùïú] ùïú
{C : Type u} [category_theory.category C] [category_theory.abelian C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.mono f] {T : C} (g : T ‚ü∂ Y) (hg : g ‚â´ category_theory.limits.cokernel.œÄ f = 0) : T ‚ü∂ X
{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X ‚Üí Y} (hf : holder_with C r f) (h0 : 0 < r) : uniform_continuous f
{a b : ‚Ñù} (h : a < b) : cardinal.mk ‚Ü•(set.Icc a b) = cardinal.continuum
 : category_theory.bicategory category_theory.Cat
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] : category_theory.center C
(a : erased (Sort u)) : Sort u
{Œπ‚ÇÅ : Type u_1} {Œπ‚ÇÇ : Type u_2} {R : Type u_3} {R‚ÇÇ : Type u_4} {S : Type u_5} {S‚ÇÇ : Type u_6} {M : Type u_7} {N : Type u_8} {P : Type u_9} [comm_ring R] [comm_ring S] [comm_ring R‚ÇÇ] [comm_ring S‚ÇÇ] [add_comm_group M] [add_comm_group N] [add_comm_group P] [module R M] [module S N] [module R‚ÇÇ P] [module S‚ÇÇ P] [smul_comm_class S‚ÇÇ R‚ÇÇ P] {œÅ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÅ‚ÇÇ : S ‚Üí+* S‚ÇÇ} (b‚ÇÅ : basis Œπ‚ÇÅ R M) (b‚ÇÇ : basis Œπ‚ÇÇ S N) {B : M ‚Üí‚Çõ‚Çó[œÅ‚ÇÅ‚ÇÇ] N ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] P} (x : M) (y : N) : (‚áë(b‚ÇÅ.repr) x).sum (Œª (i : Œπ‚ÇÅ) (xi : R), (‚áë(b‚ÇÇ.repr) y).sum (Œª (j : Œπ‚ÇÇ) (yj : S), ‚áëœÅ‚ÇÅ‚ÇÇ xi ‚Ä¢ ‚áëœÉ‚ÇÅ‚ÇÇ yj ‚Ä¢ ‚áë(‚áëB (‚áëb‚ÇÅ i)) (‚áëb‚ÇÇ j))) = ‚áë(‚áëB x) y
(G : Type u_1) (H : Type u_2) [group G] [mul_action G H] [has_faithful_smul G H] : G ‚âÉ* ‚Ü•((mul_action.to_perm_hom G H).range)
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_4} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (hr : ‚àÄ (a : Œ±) (b‚ÇÅ b‚ÇÇ : Œ≤), s b‚ÇÅ b‚ÇÇ ‚Üí t (f a b‚ÇÅ) (f a b‚ÇÇ)) (hs : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±) (b : Œ≤), r a‚ÇÅ a‚ÇÇ ‚Üí t (f a‚ÇÅ b) (f a‚ÇÇ b)) (q‚ÇÅ : quot r) (q‚ÇÇ : quot s) : quot t
(ùïú : Type u_1) {V : Type u_2} {P : Type u_8} [normed_field ùïú] [semi_normed_group V] [normed_space ùïú V] [pseudo_metric_space P] [normed_add_torsor V P] (p : P) : P ‚âÉ·µÉ‚Å±[ùïú] V
{Œ± : Type u_1} [encodable Œ±] (a : ulower Œ±) : Œ±
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {A B : C} [category_theory.closed A] [category_theory.closed B] (f : B ‚ü∂ A) : category_theory.ihom A ‚ü∂ category_theory.ihom B
{x y : ‚Ñù} (h : x < y) : ‚àÉ (r : ‚Ñù), irrational r ‚àß x < r ‚àß r < y
{Œ± : Type v} {d u l r : ‚Ñï} (A : matrix (fin (u + d)) (fin (l + r)) Œ±) : matrix (fin u) (fin l) Œ±
{Œ± : Type u} [comm_semiring Œ±] {p p' : Œ±} {ps ps' : ‚Ñï} : p = p' ‚Üí ps = ps' ‚Üí p ^ ps = p' ^ ps'
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] [finite_dimensional F E] : [is_galois F E, intermediate_field.fixed_field ‚ä§ = ‚ä•, fintype.card (E ‚âÉ‚Çê[F] E) = finite_dimensional.finrank F E, ‚àÉ (p : polynomial F), p.separable ‚àß polynomial.is_splitting_field F E p].tfae
(R : Type u) [semiring R] (Œπ : Type v) [dec_Œπ : decidable_eq Œπ] (M : Œπ ‚Üí Type w) [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] (i : Œπ) : M i ‚Üí‚Çó[R] direct_sum Œπ (Œª (i : Œπ), M i)
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ‚Ñù E] [normed_group F] [normed_space ‚Ñù F] {f : E ‚Üí F} {s : set E} {x : E} (hf : cont_diff_within_at ‚Ñù 1 f s x) (hs : convex ‚Ñù s) : ‚àÉ (K : nnreal) (t : set E) (H : t ‚àà nhds_within x s), lipschitz_on_with K f t
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [baire_space Œ±] [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±} (ho : ‚àÄ (s : Œ≤), is_GŒ¥ (f s)) (hd : ‚àÄ (s : Œ≤), dense (f s)) : dense (‚ãÇ (s : Œ≤), f s)
{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] : ‚àÉ (v : V), G.max_degree = G.degree v
(decl_name : name) {type : Sort u_1} [reflected type] (body : type) [reflected body] : declaration
 : tactic.ring.horner_expr ‚Üí string
{C : Type u} [category_theory.category C] {X Y : C} {f f' : X ‚ü∂ Y} [category_theory.limits.has_image f] [category_theory.limits.has_image f'] [category_theory.limits.has_equalizers C] (h : f = f') : category_theory.limits.image.Œπ f = (category_theory.limits.image.eq_to_iso h).hom ‚â´ category_theory.limits.image.Œπ f'
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : free_abelian_group Œ± ‚âÉ‚Çó[‚Ñ§] free_abelian_group Œ≤) : Œ± ‚âÉ Œ≤
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {n : with_top ‚Ñï} (h : cont_diff_on ùïú n f s) (hn : 1 ‚â§ n) : differentiable_on ùïú f s
(p : ‚Ñï) [fact (nat.prime p)] (hp : p ‚â† 2) (a : ‚Ñ§) : ‚Üë({x : zmod p | x ^ 2 = ‚Üëa}.to_finset.card) = zmod.legendre_sym p a + 1
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] (P Q R : C) : P ‚®Ø Q ‚®Ø R ‚âÖ P ‚®Ø (Q ‚®Ø R)
{C : Type u‚ÇÅ} [category_theory.small_category C] {‚Ñ∞ : Type u‚ÇÇ} [category_theory.category ‚Ñ∞] (A : C ‚•§ ‚Ñ∞) [category_theory.limits.has_colimits ‚Ñ∞] : category_theory.colimit_adj.extend_along_yoneda A ‚âÖ (category_theory.Lan category_theory.yoneda).obj A
(R : Type u) [comm_ring R] (L : Type v) (M : Type w) (N : Type w‚ÇÅ) (P : Type w‚ÇÇ) [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group N] [module R N] [lie_ring_module L N] [lie_module R L N] [add_comm_group P] [module R P] [lie_ring_module L P] [lie_module R L P] : (M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] P) ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ tensor_product R M N ‚Üí‚Çó[R] P
{C : Type u‚ÇÅ} [category_theory.category C] {B : C} {X Y : category_theory.subobject B} (f : ‚ÜëX ‚âÖ ‚ÜëY) (w : f.hom ‚â´ Y.arrow = X.arrow) : X = Y
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [unique_factorization_monoid Œ±] [normalization_monoid Œ±] [decidable_eq Œ±] {a b : Œ±} (ha : a ‚â† 0) (hb : b ‚â† 0) : factorization (a * b) = factorization a + factorization b
{Œ± : Type u_1} [fintype Œ±] : fintype.card Œ± = 0 ‚âÉ (Œ± ‚âÉ empty)
{Œ± : Type u} [preorder Œ±] {a : Œ±} : a ‚â§ a
{et et' : tactic.ring_exp.ex_type} (ps : tactic.ring_exp.ex et) (qs : tactic.ring_exp.ex et') : tactic.ring_exp.ring_exp_m expr
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [topological_space Œ¥] {e‚ÇÅ : Œ± ‚Üí Œ≤} {e‚ÇÇ : Œ≥ ‚Üí Œ¥} (de‚ÇÅ : dense_embedding e‚ÇÅ) (de‚ÇÇ : dense_embedding e‚ÇÇ) : dense_embedding (Œª (p : Œ± √ó Œ≥), (e‚ÇÅ p.fst, e‚ÇÇ p.snd))
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] (a b : Œ±) : finset Œ±
{E : Type u_1} {X : set E} (hX : X.finite) {L : Type u_2} (F : E ‚Üí multiset L) : fintype (Œ† (x : ‚Ü•X), {l // l ‚àà F ‚Üëx})
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] {V‚ÇÇ : Type v'} [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] [finite_dimensional K V] [finite_dimensional K V‚ÇÇ] {p : subspace K V} {q : subspace K V‚ÇÇ} (f‚ÇÅ : ‚Ü•p ‚âÉ‚Çó[K] ‚Ü•q) (f‚ÇÇ : V ‚âÉ‚Çó[K] V‚ÇÇ) : (V ‚ß∏ p) ‚âÉ‚Çó[K] V‚ÇÇ ‚ß∏ q
{X Y Z : Type u} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : category_theory.limits.pullback_cone f g
{C : Type u‚ÇÅ} [category_theory.small_category C] {‚Ñ∞ : Type u‚ÇÇ} [category_theory.category ‚Ñ∞] (A : C ‚•§ ‚Ñ∞) [category_theory.limits.has_colimits ‚Ñ∞] : category_theory.yoneda ‚ãô category_theory.colimit_adj.extend_along_yoneda A ‚âÖ A
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (T : E ‚ÜíL[ùïú] E) (x : E) : ‚Ñù
(C : Type u) [category_theory.category C] : Type (max u (v+1))
(L : Type u_1) [topological_space L] [has_sup L] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] : ùü≠ C ‚ä£ ùü≠ C
(J : Type u‚ÇÅ) [category_theory.category J] : Type u‚ÇÅ
 : expr ‚Üí expr ‚Üí tactic bool
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] {a b : Œ±} (h : a < b) (s : set Œ±) : [s ‚àà nhds_within b (set.Iic b), s ‚àà nhds_within b (set.Icc a b), s ‚àà nhds_within b (set.Ioc a b), ‚àÉ (l : Œ±) (H : l ‚àà set.Ico a b), set.Ioc l b ‚äÜ s, ‚àÉ (l : Œ±) (H : l ‚àà set.Iio b), set.Ioc l b ‚äÜ s].tfae
{n : ‚Ñï} (c : composition n) : ‚Ñï
(ùïú : Type u_1) {E : Type u_4} [normed_group E] [nondiscrete_normed_field ùïú] [normed_space ùïú E] (x : E) (h : x ‚â† 0) : ùïú ‚âÉL[ùïú] ‚Ü•(submodule.span ùïú {x})
(C : Type u‚ÇÅ) : Type u‚ÇÅ
{Œπ : Type u_1} {Z : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), canonically_ordered_monoid (Z i)] : canonically_ordered_monoid (Œ† (i : Œπ), Z i)
{V : Type u} {G : simple_graph V} (P : G.partition) : G.coloring (set V)
{R : Type u} [ring R] {J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Module R) : AddCommGroup
{Œπ : Type u_1} [fintype Œπ] {Œ± : Type u_2} [group Œ±] [measure_theory.measure_space Œ±] [measure_theory.sigma_finite measure_theory.measure_space.volume] [has_measurable_inv Œ±] [measure_theory.measure_space.volume.is_inv_invariant] : measure_theory.measure_space.volume.is_inv_invariant
{Œ± : Type u_1} {s : finset Œ±} {f : Œ± ‚Üí ennreal} (hf : ‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚â† ‚ä§) : (s.sum (Œª (a : Œ±), f a)).to_real = s.sum (Œª (a : Œ±), (f a).to_real)
(F : Type u ‚Üí Type v) [applicative F] [is_lawful_applicative F] (G : Type u ‚Üí Type w) [applicative G] [is_lawful_applicative G] : Type (max (u+1) v w)
(inner : tactic.interactive.itactic) : tactic unit
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] {f g : bounded_continuous_function Œ± Œ≤} {C : ‚Ñù} (C0 : 0 ‚â§ C) : has_dist.dist f g ‚â§ C ‚Üî ‚àÄ (x : Œ±), has_dist.dist (‚áëf x) (‚áëg x) ‚â§ C
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : ‚Üë(affine_span k s).nonempty ‚Üî s.nonempty
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (g : C(Œ≤, Œ≥)) : continuous g.comp
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) (b : Œ≤ a) (s : alist Œ≤) : alist Œ≤
(P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] : fintype.card L ‚â§ fintype.card P
{R : Type u_1} {a : R} [monoid R] {n : ‚Ñï} (n0 : 0 < n) : is_left_regular (a ^ n) ‚Üî is_left_regular a
{Œ± : Type u_1} [uniform_space Œ±] {s t : set Œ±} (h : s = t) : ‚Ü•s ‚âÉ·µ§ ‚Ü•t
(R : Type u) [comm_semiring R] (A : Type v‚ÇÅ) [semiring A] [algebra R A] (B : Type v‚ÇÇ) [semiring B] [algebra R B] : tensor_product R A B ‚âÉ‚Çê[R] tensor_product R B A
{K : Type u_1} {n : ‚Ñï} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] : (generalized_continued_fraction.squash_seq s (n + 1)).tail = generalized_continued_fraction.squash_seq s.tail n
{Œπ : Type u_1} (p : ‚Ñù) [fact_one_le_p : fact (1 ‚â§ p)] (Œ≤ : Œπ ‚Üí Type u_4) [fintype Œπ] [Œ† (i : Œπ), semi_normed_group (Œ≤ i)] : semi_normed_group (pi_Lp p Œ≤)
{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.non_preadditive_abelian.œÉ ‚â´ f = category_theory.limits.prod.map f f ‚â´ category_theory.non_preadditive_abelian.œÉ
{Œπ : Type u} {Œ± : option Œπ ‚Üí Type v} [Œ† (i : option Œπ), has_zero (Œ± i)] (a : Œ± option.none) : (Œ†‚ÇÄ (i : Œπ), Œ± (option.some i)) ‚Üí (Œ†‚ÇÄ (i : option Œπ), Œ± i)
(hp : interactive.parse tactic.interactive.cases_arg_p) (rec_name : interactive.parse interactive.types.using_ident) (ids : interactive.parse interactive.types.with_ident_list) (revert : interactive.parse (optional (lean.parser.tk "generalizing" *> lean.parser.many lean.parser.ident))) : tactic unit
(Œ± : Type u_1) (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_preorder Œ± r] : setoid Œ±
{R : Type u_1} {M : Type u_2} [add_zero_class R] [add_zero_class M] {P : triv_sq_zero_ext R M ‚Üí Prop} (h : ‚àÄ (r : R) (m : M), P (triv_sq_zero_ext.inl r + triv_sq_zero_ext.inr m)) (x : triv_sq_zero_ext R M) : P x
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} : has_coe_to_fun (P ‚ü∂ Q) (Œª (_x : P ‚ü∂ Q), ‚Ü•P ‚Üí ‚Ü•Q)
 : fin 2 ‚âÉ bool
{Œπ : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [fintype Œπ] {O : Type u_3} [add_comm_group O] [module R O] (M N : submodule R O) (b'M : basis Œπ R ‚Ü•M) (N_bot : N ‚â† ‚ä•) (N_le_M : N ‚â§ M) : ‚àÉ (y : O) (H : y ‚àà M) (a : R) (hay : a ‚Ä¢ y ‚àà N) (M' : submodule R O) (H : M' ‚â§ M) (N' : submodule R O) (H : N' ‚â§ N) (N'_le_M' : N' ‚â§ M') (y_ortho_M' : ‚àÄ (c : R) (z : O), z ‚àà M' ‚Üí c ‚Ä¢ y + z = 0 ‚Üí c = 0) (ay_ortho_N' : ‚àÄ (c : R) (z : O), z ‚àà N' ‚Üí c ‚Ä¢ a ‚Ä¢ y + z = 0 ‚Üí c = 0), ‚àÄ (n' : ‚Ñï) (bN' : basis (fin n') R ‚Ü•N'), ‚àÉ (bN : basis (fin (n' + 1)) R ‚Ü•N), ‚àÄ (m' : ‚Ñï) (hn'm' : n' ‚â§ m') (bM' : basis (fin m') R ‚Ü•M'), ‚àÉ (hnm : n' + 1 ‚â§ m' + 1) (bM : basis (fin (m' + 1)) R ‚Ü•M), ‚àÄ (as : fin n' ‚Üí R), (‚àÄ (i : fin n'), ‚Üë(‚áëbN' i) = as i ‚Ä¢ ‚Üë(‚áëbM' (‚áë(fin.cast_le hn'm') i))) ‚Üí (‚àÉ (as' : fin (n' + 1) ‚Üí R), ‚àÄ (i : fin (n' + 1)), ‚Üë(‚áëbN i) = as' i ‚Ä¢ ‚Üë(‚áëbM (‚áë(fin.cast_le hnm) i)))
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {S : category_theory.sieve X} (x : category_theory.presieve.family_of_elements P ‚áëS) : Prop
{G : Type u_1} [add_group G] (K : add_subgroup G) : add_subgroup.closure ‚ÜëK = K
{E : ‚Ñï ‚Üí Type u_1} [Œ† (n : ‚Ñï), topological_space (E n)] [‚àÄ (n : ‚Ñï), discrete_topology (E n)] {s : set (Œ† (n : ‚Ñï), E n)} (hs : is_closed s) (hne : s.nonempty) : ‚àÉ (f : (Œ† (n : ‚Ñï), E n) ‚Üí Œ† (n : ‚Ñï), E n), (‚àÄ (x : Œ† (n : ‚Ñï), E n), x ‚àà s ‚Üí f x = x) ‚àß set.range f = s ‚àß lipschitz_with 1 f
{G : AddCommGroup} (g : ‚Ü•G) : AddCommGroup.of ‚Ñ§ ‚ü∂ G
{ùïú : Type u_1} [linear_ordered_field ùïú] [topological_space ùïú] [topological_ring ùïú] (a b : ùïú) (h : a < b) : ‚Ü•(set.Icc a b) ‚âÉ‚Çú ‚Ü•(set.Icc 0 1)
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : valuation K (with_zero (multiplicative ‚Ñ§))
 : io std_gen
 : interactive.parse tactic.rcases_parse ‚Üí tactic unit
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [nontrivial Œ≤] : nontrivial Œ±
{Œ± : Type u} {Œ≤ : Type v} [has_sup Œ±] [has_inf Œ±] [has_Sup Œ±] [has_Inf Œ±] [has_top Œ±] [has_bot Œ±] [order.frame Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.injective f) (map_sup : ‚àÄ (a b : Œ±), f (a ‚äî b) = f a ‚äî f b) (map_inf : ‚àÄ (a b : Œ±), f (a ‚äì b) = f a ‚äì f b) (map_Sup : ‚àÄ (s : set Œ±), f (has_Sup.Sup s) = ‚®Ü (a : Œ±) (H : a ‚àà s), f a) (map_Inf : ‚àÄ (s : set Œ±), f (has_Inf.Inf s) = ‚®Ö (a : Œ±) (H : a ‚àà s), f a) (map_top : f ‚ä§ = ‚ä§) (map_bot : f ‚ä• = ‚ä•) : order.frame Œ±
{M N : SemiNormedGroup} (f : M ‚ü∂ N) (i : normed_group_hom.norm_noninc f) : SemiNormedGroup‚ÇÅ.of ‚Ü•M ‚ü∂ SemiNormedGroup‚ÇÅ.of ‚Ü•N
{Œ± : Type u_1} [measurable_space Œ±] {m‚ÇÅ m‚ÇÇ m‚ÇÉ : measure_theory.outer_measure Œ±} {op : ennreal ‚Üí ennreal ‚Üí ennreal} (h : ‚àÄ (s : set Œ±), ‚áëm‚ÇÅ s = op (‚áëm‚ÇÇ s) (‚áëm‚ÇÉ s)) (s : set Œ±) : ‚áë(m‚ÇÅ.trim) s = op (‚áë(m‚ÇÇ.trim) s) (‚áë(m‚ÇÉ.trim) s)
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] {f : add_hom M N} (hf : function.injective ‚áëf) : galois_coinsertion (add_subsemigroup.map f) (add_subsemigroup.comap f)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type u_1} [fintype Œπ] (S : Œπ ‚Üí submodule K V) [‚àÄ (i : Œπ), finite_dimensional K ‚Ü•(S i)] : finite_dimensional K (‚Ü•‚®Ü (i : Œπ), S i)
{G‚ÇÄ : Type u_2} {G‚ÇÄ' : Type u_4} [comm_group_with_zero G‚ÇÄ] [has_zero G‚ÇÄ'] [has_mul G‚ÇÄ'] [has_one G‚ÇÄ'] [has_inv G‚ÇÄ'] [has_div G‚ÇÄ'] [has_pow G‚ÇÄ' ‚Ñï] [has_pow G‚ÇÄ' ‚Ñ§] (f : G‚ÇÄ' ‚Üí G‚ÇÄ) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ‚àÄ (x y : G‚ÇÄ'), f (x * y) = f x * f y) (inv : ‚àÄ (x : G‚ÇÄ'), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : G‚ÇÄ'), f (x / y) = f x / f y) (npow : ‚àÄ (x : G‚ÇÄ') (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : G‚ÇÄ') (n : ‚Ñ§), f (x ^ n) = f x ^ n) : comm_group_with_zero G‚ÇÄ'
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {G : C ‚•§ D} [category_theory.reflects_isomorphisms G] [category_theory.limits.has_limits_of_size C] [category_theory.limits.preserves_limits_of_size G] : category_theory.limits.reflects_limits_of_size G
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [non_assoc_ring Œ≤] : non_assoc_ring Œ±
 : environment ‚Üí name ‚Üí bool
{Œ± : Type u} [add_comm_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b c : Œ±} : a ‚â§ b + c ‚Üí a - b ‚â§ c
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ùïú] [inner_product_space ùïú E] [inner_product_space ùïú F] [finite_dimensional ùïú E] [finite_dimensional ùïú F] {Œπ‚ÇÅ : Type u_4} {Œπ‚ÇÇ : Type u_5} (b‚ÇÅ : basis Œπ‚ÇÅ ùïú E) (b‚ÇÇ : basis Œπ‚ÇÇ ùïú F) (A : E ‚Üí‚Çó[ùïú] F) (B : F ‚Üí‚Çó[ùïú] E) : A = ‚áëlinear_map.adjoint B ‚Üî ‚àÄ (i‚ÇÅ : Œπ‚ÇÅ) (i‚ÇÇ : Œπ‚ÇÇ), has_inner.inner (‚áëA (‚áëb‚ÇÅ i‚ÇÅ)) (‚áëb‚ÇÇ i‚ÇÇ) = has_inner.inner (‚áëb‚ÇÅ i‚ÇÅ) (‚áëB (‚áëb‚ÇÇ i‚ÇÇ))
(C : Type v) [category_theory.category C] [category_theory.concrete_category C] : has_coe_to_sort C (Type u)
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {Œπ : Type u_3} {t : finset Œπ} {f : Œπ ‚Üí L} (h : ‚àÄ (c : Œπ), c ‚àà t ‚Üí f c ‚àà S) : t.prod (Œª (i : Œπ), f i) ‚àà S
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X Y : C} (f : X ‚ü∂ Y) (hf : ‚àÄ (Z : C) (g : Y ‚ü∂ Z), f ‚â´ g = 0 ‚Üí g = 0) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ 0 _)
(p : ‚Ñï) [hp : fact (nat.prime p)] : is_domain (zmod p)
(Œ± : Type u_1) [topological_space Œ±] [t0_space Œ±] : partial_order Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_biproducts C] : category_theory.Mat_.embedding C ‚ãô ùü≠ (category_theory.Mat_ C) ‚âÖ category_theory.Mat_.embedding C ‚ãô category_theory.Mat_.lift (ùü≠ C) ‚ãô category_theory.Mat_.embedding C
(p : ‚Ñï) [hp : fact (nat.prime p)] {k : Type u_1} [field k] [char_p k p] [is_alg_closed k] {a‚ÇÅ a‚ÇÇ : witt_vector p k} (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0) (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) : witt_vector p k
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] : E ‚ÜíL[ùïú] E ‚ÜíL‚ãÜ[ùïú] ùïú
{Œ± : Type u_1} [measurable_space Œ±] (p : pmf Œ±) : measure_theory.is_probability_measure p.to_measure
{R : Type u_1} [comm_semiring R] {A : Type u} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] (s : subalgebra R A) {B : Type u_2} [topological_space B] [ring B] [topological_ring B] [algebra R B] (f : B ‚Üí‚Çê[R] A) (f' : B ‚âÉ‚Çú A) (w : ‚áëf = ‚áëf') : s.topological_closure.comap' f = (s.comap' f).topological_closure
{Œ± : Type u_1} {C : cycle Œ± ‚Üí Prop} (s : cycle Œ±) (H0 : C cycle.nil) (HI : ‚àÄ (a : Œ±) (l : list Œ±), C ‚Üël ‚Üí C ‚Üë(a :: l)) : C s
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x : V} (hx : x ‚â† 0) (Œ∏ : real.angle) : ‚áë(hb.rotation Œ∏) x = x ‚Üî Œ∏ = 0
{x y : ‚Ñù} : irrational (x + y) ‚Üí irrational x ‚à® irrational y
{X : Type u_2} [emetric_space X] [topological_space.second_countable_topology X] {s : set X} {r : ennreal} (h : r < dimH s) : ‚àÉ (x : X) (H : x ‚àà s), ‚àÄ (t : set X), t ‚àà nhds_within x s ‚Üí r < dimH t
{A : Type u_1} [comm_ring A] [algebra ‚Ñö A] (n : ‚Ñï) : (finset.range n).sum (Œª (k : ‚Ñï), power_series.exp A ^ k) = power_series.mk (Œª (p : ‚Ñï), (finset.range n).sum (Œª (k : ‚Ñï), ‚Üëk ^ p * ‚áë(algebra_map ‚Ñö A) (‚Üë(p.factorial))‚Åª¬π))
{M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_3} [mul_zero_class M‚ÇÄ] [has_mul M‚ÇÄ'] [has_zero M‚ÇÄ'] (f : M‚ÇÄ' ‚Üí M‚ÇÄ) (hf : function.injective f) (zero : f 0 = 0) (mul : ‚àÄ (a b : M‚ÇÄ'), f (a * b) = f a * f b) : mul_zero_class M‚ÇÄ'
(Œì : Type u_1) (R : Type u_2) [comm_semiring R] {A : Type u_3} [semiring A] [algebra R A] [ordered_semiring Œì] [nontrivial Œì] : power_series A ‚Üí‚Çê[R] hahn_series Œì A
{G : Type u_1} [comm_monoid G] : monoid.is_torsion ‚Ü•(comm_monoid.torsion G)
(f : stieltjes_function) (s : set ‚Ñù) : ennreal
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (f : C(Œ≤, Œ≥)) (g : C(Œ±, Œ≤)) : C(Œ±, Œ≥)
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_products C] : Type (max u v)
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j j' : C) : j' ‚ü∂ category_theory.is_filtered.max j j'
{Œ± : Type u} [pseudo_emetric_space Œ±] {x : Œ±} {s : set Œ±} {r : ennreal} : emetric.inf_edist x s < r ‚Üî ‚àÉ (y : Œ±) (H : y ‚àà s), has_edist.edist x y < r
(Œ± : expr) : tactic unit
{Œ± : Type} (p : lean.parser Œ±) (input : string) : lean.parser (Œ± √ó string)
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] : non_unital_comm_ring Œ±
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.monoidal_category C] [category_theory.monoidal_category D] [category_theory.braided_category C] [category_theory.symmetric_category D] (F : category_theory.braided_functor C D) [category_theory.faithful F.to_monoidal_functor.to_lax_monoidal_functor.to_functor] : category_theory.symmetric_category C
{Œ± : Type u_1} [monoid Œ±] (s t : set Œ±) (a : Œ±) : set (Œ± √ó Œ±)
 : BoundedDistribLattice ‚•§ BoundedDistribLattice
{f‚ÇÅ f‚ÇÇ : circle_deg1_lift} (h‚ÇÅ : function.bijective ‚áëf‚ÇÅ) (h‚ÇÇ : function.bijective ‚áëf‚ÇÇ) (h : f‚ÇÅ.translation_number = f‚ÇÇ.translation_number) : ‚àÉ (F : circle_deg1_lift), function.semiconj ‚áëF ‚áëf‚ÇÅ ‚áëf‚ÇÇ
{X : Type u} [lattice X] [jordan_holder_lattice X] (s‚ÇÅ s‚ÇÇ : composition_series X) (hb : s‚ÇÅ.bot = s‚ÇÇ.bot) (ht : s‚ÇÅ.top = s‚ÇÇ.top) : s‚ÇÅ.equivalent s‚ÇÇ
{Œ± : Type u_1} [complete_lattice Œ±] {s : set Œ±} {b : Œ±} (_x : ‚àÄ (a : Œ±), a ‚àà s ‚Üí a ‚â§ b) (H : ‚àÄ (w : Œ±), w < b ‚Üí (‚àÉ (a : Œ±) (H : a ‚àà s), w < a)) : has_Sup.Sup s = b
{C : Type u} {A : Type u_1} [category_theory.category C] [add_group A] (F : category_theory.monoidal_functor (category_theory.discrete A) (C ‚•§ C)) (n : A) : C ‚âå C
{K : Type u_1} [field K] [fintype K] (i : ‚Ñï) (h : i < fintype.card K - 1) : finset.univ.sum (Œª (x : K), x ^ i) = 0
{C : Type u} [category_theory.category C] (n : ‚Ñï) : category_theory.simplicial_object C ‚•§ category_theory.simplicial_object.truncated C n
{Œπ : Type uŒπ} (R : Type uR) (A : Œπ ‚Üí Type uA) [decidable_eq Œπ] [comm_semiring R] [Œ† (i : Œπ), add_comm_monoid (A i)] [Œ† (i : Œπ), module R (A i)] [add_monoid Œπ] [direct_sum.gsemiring A] : Type (max uA uR)
{Œπ : Type u_1} {M : Type u_3} [decidable_eq Œπ] [semiring M] [Œ† (m : M), decidable (m ‚â† 0)] (f : direct_sum Œπ (Œª (i : Œπ), M)) : add_monoid_algebra M Œπ
(A : Type u) [comm_ring A] [is_domain A] : Prop
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} (t : category_theory.limits.pushout_cocone f g) : Y ‚ü∂ t.X
{R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [ring R] [add_comm_group M] [add_comm_group M‚ÇÇ] [module R M] [module R M‚ÇÇ] (f : M ‚âÉ‚Çó[R] M‚ÇÇ) : finite_dimensional.finrank R M = finite_dimensional.finrank R M‚ÇÇ
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) [has_le Œ±] [has_le Œ≤] [has_le Œ≥] : (Œ± ‚äï‚Çó Œ≤) ‚äï‚Çó Œ≥ ‚âÉo Œ± ‚äï‚Çó Œ≤ ‚äï‚Çó Œ≥
{p : ‚Ñï} {G : Type u_1} [group G] [fact (nat.prime p)] [fintype (sylow p G)] (P Q : sylow p G) : ‚Ü•P ‚âÉ* ‚Ü•Q
{R : Type u} {S : Type v} [semiring R] [add_comm_monoid S] (p : polynomial R) {f : ‚Ñï ‚Üí R ‚Üí S} (h : ‚àÄ (n : ‚Ñï), f n 0 = 0) (n : ‚Ñï) (w : p.nat_degree < n) : p.sum f = (finset.range n).sum (Œª (a : ‚Ñï), f a (p.coeff a))
{Œ± : Type u_1} (o : part Œ±) [decidable o.dom] : option Œ±
{n : ‚Ñï} {Œ± : Type u_1} (a : Œ±) (i : fin (n + 1)) (v : vector Œ± n) : vector Œ± (n + 1)
(Œ± : Type u_1) [monoid_with_zero Œ±] [decidable_eq Œ±] [decidable_pred is_square] (a : Œ±) : ‚Ñ§
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] (f : equiv.perm Œ±) : finset (equiv.perm Œ±)
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) {r : R} {s : ‚Ü•(non_zero_divisors R)} : ‚áë(v.valuation) (is_localization.mk' K r s) = ‚áë(v.int_valuation) r / ‚áë(v.int_valuation) ‚Üës
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (r : Œ± ‚Üí Œ≤ ‚Üí Prop) (p : Œ≤ ‚Üí Œ≥ ‚Üí Prop) (a : Œ±) (c : Œ≥) : Prop
(Œ± : Type u) [topological_space Œ±] [t1_space Œ±] : bornology Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.regular_mono f] : category_theory.mono f
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) (C : nnreal) {r : nnreal} (h : ‚àÄ (n : ‚Ñï), ‚à•p n‚à•‚Çä * r ^ n ‚â§ C) : ‚Üër ‚â§ p.radius
{Œ± : Type} (p : parser Œ±) : parser unit
(m : Type u_2) (Œ± : Type v) [add_comm_monoid Œ±] [comm_semigroup Œ±] [fintype m] : matrix m m Œ± ‚âÉ+* (matrix m m Œ±)·µê·µí·µñ
 : category_theory.large_category category_theory.Cat
{C : Type u‚ÇÅ} [category_theory.category C] (F : C ‚•§ Type v‚ÇÅ) [F.corepresentable] : category_theory.coyoneda.obj (opposite.op F.corepr_X) ‚ü∂ F
(generate_induction_hyps : bool) (cinfo : tactic.eliminate.constructor_info) : tactic (list (name √ó tactic.eliminate.constructor_argument_info) √ó list (name √ó name √ó tactic.eliminate.constructor_argument_info))
{C : Type u‚ÇÅ} [category_theory.category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (R : category_theory.presieve X) [category_theory.limits.has_pullbacks C] : category_theory.equalizer.first_obj P R ‚ü∂ category_theory.equalizer.presieve.second_obj P R
{V : Type u} (G : simple_graph V) (d d' : G.dart) : Prop
{Œ± : Type u_2} [has_one Œ±] : has_one (finset Œ±)
(C : Type u) (A : Type u_1) [category_theory.category C] [add_monoid A] [category_theory.has_shift C A] : category_theory.monoidal_functor (category_theory.discrete A) (C ‚•§ C)
{R : Type u_1} [ring R] (a b c : R) : R
{Œ± : Type u_1} [linear_ordered_field Œ±] [archimedean Œ±] {x y : Œ±} (hx : 0 < x) (hy : 1 < y) : ‚àÉ (n : ‚Ñ§), x ‚àà set.Ioc (y ^ n) (y ^ (n + 1))
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {D : Type u‚ÇÇ} [category_theory.category D] (F : D ‚•§ C) {Z : D} {T : category_theory.presieve (F.obj Z)} (x : category_theory.presieve.family_of_elements P T) : category_theory.presieve.family_of_elements (F.op ‚ãô P) (category_theory.presieve.functor_pullback F T)
 : tactic unit
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (self : subalgebra R A) : subsemiring A
{Œ± : Type u_1} {P : Œ± ‚Üí Prop} (m : Œ† (s : Œ±), P s ‚Üí ennreal) (s : Œ±) : ennreal
(n : ‚Ñï) : fin n ‚Ü™o ‚Ñï
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M ‚Üí* N} (h : ‚àÄ (y : ‚Ü•S), is_unit (‚áëf ‚Üëy)) (y : ‚Ü•S) (w z : N) : z = w * ‚Üë(‚áë(is_unit.lift_right (f.restrict S) h) y)‚Åª¬π ‚Üî z * ‚áëf ‚Üëy = w
{C : Type u} [category_theory.category C] (P : C) (f g : category_theory.over P) : Prop
{R : Type u_1} [distrib R] (r : R) : add_hom R R
{Œ± : Type u} {Œ≤ : Type v} [add_zero_class Œ±] [add_zero_class Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_monoid_hom f) {Œ≥ : Type u_1} [add_zero_class Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : is_add_monoid_hom g) : is_add_monoid_hom (g ‚àò f)
(Œ± : Type u_1) [complete_lattice Œ±] : complete_lattice.is_Sup_finite_compact Œ± ‚Üí well_founded gt
{R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : ¬¨is_right_regular 0
{C : Type u_1} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.limits.has_pullback f g] [category_theory.limits.has_binary_product X Y] : category_theory.mono (category_theory.limits.prod.lift category_theory.limits.pullback.fst category_theory.limits.pullback.snd)
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} (hs : is_compact s) {p : set Œ± ‚Üí Prop} (he : p ‚àÖ) (hmono : ‚àÄ ‚¶És t : set Œ±‚¶Ñ, s ‚äÜ t ‚Üí p t ‚Üí p s) (hunion : ‚àÄ ‚¶És t : set Œ±‚¶Ñ, p s ‚Üí p t ‚Üí p (s ‚à™ t)) (hnhds : ‚àÄ (x : Œ±), x ‚àà s ‚Üí (‚àÉ (t : set Œ±) (H : t ‚àà nhds_within x s), p t)) : p s
{C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (hu : category_theory.cover_lifting J K G) (‚Ñ± : category_theory.Sheaf J A) {X : A} {U : D} {S : category_theory.sieve U} (hS : S ‚àà ‚áëK U) {x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj ‚Ñ±.val ‚ãô category_theory.coyoneda.obj (opposite.op X)) S.arrows} (hx : x.compatible) : X ‚ü∂ ((category_theory.Ran G.op).obj ‚Ñ±.val).obj (opposite.op U)
 : category_theory.limits.walking_span.zero ‚ü∂ category_theory.limits.walking_span.left
 : tactic unit
{G : Type u_1} [add_comm_group G] (H : add_subgroup G) : add_comm_group ‚Ü•H
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P (n + 2)) (i‚ÇÅ i‚ÇÇ : fin (n + 3)) : affine_subspace ‚Ñù P
{Œ±‚ÇÅ : Type u_1} {Œ±‚ÇÇ : Type u_2} {Œ≤‚ÇÅ : Type u_3} {Œ≤‚ÇÇ : Type u_4} {r‚ÇÅ : Œ±‚ÇÅ ‚Üí Œ±‚ÇÅ ‚Üí Prop} {r‚ÇÇ : Œ±‚ÇÇ ‚Üí Œ±‚ÇÇ ‚Üí Prop} {s‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ≤‚ÇÅ ‚Üí Prop} {s‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ≤‚ÇÇ ‚Üí Prop} (e‚ÇÅ : r‚ÇÅ ‚âÉr s‚ÇÅ) (e‚ÇÇ : r‚ÇÇ ‚âÉr s‚ÇÇ) : prod.lex r‚ÇÅ r‚ÇÇ ‚âÉr prod.lex s‚ÇÅ s‚ÇÇ
{Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) (a : Œ±) : f a‚Åª¬π = (f a)‚Åª¬π
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ‚ü∂ Q) (a b : category_theory.over P) : a ‚âà b ‚Üí category_theory.abelian.app f a ‚âà category_theory.abelian.app f b
{Œ± : Type u_1} {Œ≤ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] : measurable_space.generate_from (set.image2 has_set_prod.prod {s : set Œ± | measurable_set s} {t : set Œ≤ | measurable_set t}) = prod.measurable_space
(Œ± : Type u_1) (Œ≤ : Type u_2) [topological_space Œ±] [topological_space Œ≤] [monoid Œ≤] [has_continuous_mul Œ≤] : submonoid (Œ± ‚Üí Œ≤)
{Œ± : Type u_1} [B : bornology Œ±] (m : pseudo_metric_space Œ±) (H : ‚àÄ (s : set Œ±), bornology.is_bounded s ‚Üî bornology.is_bounded s) : pseudo_metric_space Œ±
(loc : interactive.parse interactive.types.location) : tactic unit
 : SemilatticeInf ‚•§ SemilatticeSup
{ùïú : Type u_1} {E : Type u_2} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] {p‚ÇÅ p‚ÇÇ : formal_multilinear_series ùïú ùïú E} {f : ùïú ‚Üí E} {r‚ÇÅ r‚ÇÇ : ennreal} {x : ùïú} (h‚ÇÅ : has_fpower_series_on_ball f p‚ÇÅ x r‚ÇÅ) (h‚ÇÇ : has_fpower_series_on_ball f p‚ÇÇ x r‚ÇÇ) : has_fpower_series_on_ball f p‚ÇÅ x r‚ÇÇ
{Œ± : Type u_1} : multiset Œ± ‚âÉ+ (Œ± ‚Üí‚ÇÄ ‚Ñï)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : category_theory.skeleton C ‚âÉ category_theory.skeleton D
(x : ‚Ñù) : ‚Ñù
(X Y : Type u) : category_theory.limits.limit_cone (category_theory.limits.pair X Y)
(Œ± : Type u) : Type u
{V : Type u_1} [semi_normed_group V] (s : add_subgroup V) : normed_group_hom ‚Ü•s V
{Œ± : Type u_1} {p : finset Œ± ‚Üí Sort u_2} (s : finset Œ±) : (Œ† (s : finset Œ±), (Œ† (t : finset Œ±), t ‚äÇ s ‚Üí p t) ‚Üí p s) ‚Üí p s
(d : pos_num) : pos_num ‚Üí num √ó num
{R : Type u} [semiring R] {p : polynomial R} {n : ‚Ñï} : p.nat_degree ‚â§ n ‚Üí p.degree ‚â§ ‚Üën
(R : Type u) (A : Type v) [comm_ring R] [ring A] [algebra R A] : Prop
(Œ± : Type u_6) (Œ≤ : Type u_7) [preorder Œ±] [preorder Œ≤] [mul_one_class Œ±] [mul_one_class Œ≤] : Type (max u_6 u_7)
(l : Type u_4) (R : Type u‚ÇÇ) [decidable_eq l] [comm_ring R] [fintype l] [invertible 2] : ‚Ü•(lie_algebra.orthogonal.type_B l R) ‚âÉ‚Çó‚ÅÖR‚ÅÜ ‚Ü•(lie_algebra.orthogonal.so' (unit ‚äï l) l R)
(_x : interactive.parse (lean.parser.tk "restate_axiom")) : lean.parser unit
{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] {P' : Type u_3} [comm_ring P'] [algebra R P'] (g : P ‚âÉ‚Çê[R] P') : fractional_ideal S P ‚âÉ+* fractional_ideal S P'
{Œ± : Type u_1} (f : Œ± ‚Üí nnreal) (s : finset Œ±) (h : s.sum (Œª (a : Œ±), f a) = 1) (h' : ‚àÄ (a : Œ±), a ‚àâ s ‚Üí f a = 0) : pmf Œ±
{Œ± : Type u} [preorder Œ±] [order_bot Œ±] : galois_insertion (Œª (o : with_bot Œ±), option.get_or_else o ‚ä•) coe
 : expr ‚Üí ‚Ñï ‚Üí tactic (list expr √ó expr)
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] : M.localization_with_zero_map S
{Œ± : Type u} {Œ≤ : Type v} [decidable_eq Œ≤] [fintype Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) {n : ‚Ñï} [nonempty Œ≤] (hn : fintype.card Œ± ‚â§ fintype.card Œ≤ * n) : ‚àÉ (y : Œ≤), (finset.filter (Œª (x : Œ±), f x = y) finset.univ).card ‚â§ n
{X : Top} {T : ‚Ü•X ‚Üí Type v} (P : Top.local_predicate T) : (Top.subpresheaf_to_Types P.to_prelocal_predicate).is_sheaf
(C : Type u) [category_theory.category C] {X : C} {f : X ‚ü∂ X} (hf : f ‚â´ f = f) {c : category_theory.limits.cofork (ùüô X) f} (i : category_theory.limits.is_colimit c) : category_theory.split_epi c.œÄ
{ùïú : Type u_2} [is_R_or_C ùïú] {E : Type u_3} [inner_product_space ùïú E] [cplt : complete_space E] {s : set E} (hs : orthonormal ùïú coe) : ‚àÉ (w : set E) (b : hilbert_basis ‚Ü•w ùïú E), s ‚äÜ w ‚àß ‚áëb = coe
{Œ± : Type u} (S : wseq (computation Œ±)) : computation Œ±
{K : Type u_2} [division_ring K] (a b ppredA predA : K) : K
(xs : list format) : format
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J ‚Üí C) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {X‚ÇÅ‚ÇÅ X‚ÇÅ‚ÇÇ X‚ÇÅ‚ÇÉ X‚ÇÇ‚ÇÅ X‚ÇÇ‚ÇÇ X‚ÇÇ‚ÇÉ : C} {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ‚ÇÉ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÉ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ} {v‚ÇÅ‚ÇÉ : X‚ÇÅ‚ÇÉ ‚ü∂ X‚ÇÇ‚ÇÉ} (s : category_theory.is_pushout h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ) (t : category_theory.is_pushout h‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÉ h‚ÇÇ‚ÇÇ) : category_theory.is_pushout (h‚ÇÅ‚ÇÅ ‚â´ h‚ÇÅ‚ÇÇ) v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÉ (h‚ÇÇ‚ÇÅ ‚â´ h‚ÇÇ‚ÇÇ)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {tas : set (topological_space Œ±)} {tbs : set (topological_space Œ≤)} {ta : topological_space Œ±} {tb : topological_space Œ≤} {tc : topological_space Œ≥} (ha : ta ‚àà tas) (hb : tb ‚àà tbs) (hf : continuous (Œª (p : Œ± √ó Œ≤), f p.fst p.snd)) : continuous (Œª (p : Œ± √ó Œ≤), f p.fst p.snd)
 : tactic.ring.horner_expr ‚Üí expr √ó ‚Ñï ‚Üí tactic.ring.ring_m (tactic.ring.horner_expr √ó expr)
{n : ‚Ñï} (c : composition n) (i : fin c.length) : fin (c.blocks_fun i) ‚Ü™o fin n
{M : Type u_1} [mul_one_class M] {Œπ : Sort u_2} (S : Œπ ‚Üí submonoid M) {C : M ‚Üí Prop} {x : M} (hx : x ‚àà ‚®Ü (i : Œπ), S i) (hp : ‚àÄ (i : Œπ) (x : M), x ‚àà S i ‚Üí C x) (h1 : C 1) (hmul : ‚àÄ (x y : M), C x ‚Üí C y ‚Üí C (x * y)) : C x
{G : Type u} [group G] [fintype G] {p : ‚Ñï} [hp : fact (nat.prime p)] (P : sylow p G) : fintype.card ‚Ü•P = p ^ ‚áë((fintype.card G).factorization) p
(n : ‚Ñï) : has_deriv_at (exp_neg_inv_glue.f_aux n) 0 0
{Œ± : Sort u} {Œ≤ : Sort v} {p : Œ± ‚Üí Prop} (e : Œ± ‚âÉ Œ≤) : {a // p a} ‚âÉ {b // p (‚áë(e.symm) b)}
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : ‚Ü•S ‚Üí+ M
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Œπ R M) : M ‚Üí‚Çó[R] R
(Œ± : Type u) : Type u
(C : Type u) [category_theory.category C] : C ‚•§ category_theory.simplicial_object C
 : linarith.ineq ‚Üí name
{Œ± : Type u} [non_unital_non_assoc_ring Œ±] {a b c d e : Œ±} : a * e + c = b * e + d ‚Üî (a - b) * e + c = d
 : Type
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : setoid Œ±) (f : Œ± ‚Üí Œ≤) (h : setoid.ker f ‚â§ r) (hf : function.surjective f) : setoid Œ≤
{f : ordinal ‚Üí ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f)
{X Y : Type u} [monoid X] [monoid Y] (f : X ‚Üí* Y) : Mon.of X ‚ü∂ Mon.of Y
{Œ± : Type u_1} [measurable_space Œ±] {Œπ : Type u_2} {f : Œπ ‚Üí Œ± ‚Üí nnreal} {g : Œ± ‚Üí nnreal} (u : filter Œπ) [u.ne_bot] [u.is_countably_generated] (hf : ‚àÄ (i : Œπ), measurable (f i)) (lim : filter.tendsto f u (nhds g)) : measurable g
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} (h_mono : strict_mono_on f s) (hs : s ‚àà nhds a) (hfs_l : ‚àÄ (b : Œ≤), b < f a ‚Üí (‚àÉ (c : Œ±) (H : c ‚àà s), f c ‚àà set.Ico b (f a))) (hfs_r : ‚àÄ (b : Œ≤), b > f a ‚Üí (‚àÉ (c : Œ±) (H : c ‚àà s), f c ‚àà set.Ioc (f a) b)) : continuous_at f a
(x : pgame) : (x + 0).relabelling x
{Œ± : Type u_1} [fintype Œ±] {n : ‚Ñï} (h : fintype.card Œ± = n) : Œ± ‚âÉ fin n
{Œπ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape Œπ) : hom_rel (homological_complex V c)
{Œ± : Type u} [t : topological_space Œ±] (s : set (set Œ±)) : Prop
{Œ± : Type u_1} [monoid Œ±] (a : Œ±) : associates Œ±
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] (F : C ‚•§ D) [category_theory.limits.preserves_colimits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] [category_theory.limits.preserves_colimits_of_shape (category_theory.discrete pempty) F] [category_theory.limits.has_finite_coproducts C] (n : ‚Ñï) : category_theory.limits.preserves_colimits_of_shape (category_theory.discrete (ulift (fin n))) F
(hs : name_set) : tactic (list expr)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ‚ü∂ Y} {Z : C} (Œπ : Z ‚ü∂ X) (w : Œπ ‚â´ f = 0) : category_theory.limits.kernel_fork f
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (F : C ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.preserves_colimit (category_theory.limits.span f f) F] [category_theory.epi f] : category_theory.epi (F.map f)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) (e' : local_equiv Œ± Œ≤) (h : e.to_local_equiv = e') : local_homeomorph Œ± Œ≤
{x y : pgame} (h : x < y) : x.lf y
{G : Type u_1} [group G] : subgroup G ‚âÉo add_subgroup (additive G)
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (h : ‚àÄ (c : set Œ±), is_chain r c ‚Üí (‚àÉ (ub : Œ±), ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub)) (trans : ‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) : ‚àÉ (m : Œ±), ‚àÄ (a : Œ±), r m a ‚Üí r a m
(rec : interactive.parse (optional (lean.parser.tk "*"))) (ps : interactive.parse interactive.types.pexpr_list_or_texpr) : tactic unit
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] [t2_space Œ±] {s : set Œ≤} {f g : Œ≤ ‚Üí Œ±} (h : set.eq_on f g s) (hf : continuous f) (hg : continuous g) : set.eq_on f g (closure s)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F : J ‚•§ C} [category_theory.limits.has_limit F] (c : category_theory.limits.cone F) : c ‚ü∂ category_theory.limits.limit.cone F
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {G : C ‚•§ D} [category_theory.reflects_isomorphisms G] [category_theory.limits.has_colimits_of_shape J C] [category_theory.limits.preserves_colimits_of_shape J G] : category_theory.limits.reflects_colimits_of_shape J G
{Œ± : Type u} [pseudo_emetric_space Œ±] {x y : Œ±} {s : set Œ±} : emetric.inf_edist x s ‚â§ emetric.inf_edist y s + has_edist.edist x y
{Œ± : Type u_1} {Œ≤ : Type u_2} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] [has_zero Œ±] [has_zero Œ≤] [has_scalar Œ± Œ≤] [has_bounded_smul Œ± Œ≤] : has_continuous_smul Œ± Œ≤
(X Y : Type u) : category_theory.limits.is_colimit (category_theory.limits.types.binary_coproduct_cocone X Y)
{Œ± : Type u} [decidable_eq Œ±] : list Œ± ‚Üí list Œ± ‚Üí bool
{M : Type u_1} [add_group M] (c : add_con M) {w x : M} : ‚áëc w x ‚Üí ‚áëc (-w) (-x)
(M : Type u_9) (N : Type u_10) [has_zero M] [has_zero N] : Type (max u_10 u_9)
{Œì : Type u_1} {R : Type u_2} [linear_ordered_add_comm_group Œì] [comm_ring R] [is_domain R] (x : hahn_series Œì R) (hx : 0 < ‚áë(hahn_series.add_val Œì R) x) : hahn_series.summable_family Œì R ‚Ñï
(ùïú : Type u) (n : ‚Ñï) (G : Type wG) (G' : Type wG') [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] : continuous_multilinear_map ùïú (Œª (i : fin n), G) (G ‚ÜíL[ùïú] G') ‚âÉ‚Çó·µ¢[ùïú] continuous_multilinear_map ùïú (Œª (i : fin n.succ), G) G'
(i : ‚Ñï) : lazy_list ‚Ñï
{Œπ : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] (BR : ring_filter_basis R) (B : Œπ ‚Üí submodule R M) : Prop
{R : Type u_1} {a : R} [monoid R] (n : ‚Ñï) (rra : is_right_regular a) : is_right_regular (a ^ n)
{E : Type u_2} {ùïú : Type u_3} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] {s : set E} (hs : convex ùïú s) : convex ùïú (interior s)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.full F] [category_theory.faithful F] {X Y : C} : (X ‚âÖ Y) ‚âÉ (F.obj X ‚âÖ F.obj Y)
{Œ≤ : Type v} [pseudo_emetric_space Œ≤] {Œ± : Type u} [emetric_space Œ±] {f : Œ± ‚Üí Œ≤} (h : isometry f) : function.injective f
(Œ± : Type u) [metric_space Œ±] [compact_space Œ±] [nonempty Œ±] : topological_space.nonempty_compacts ‚Ü•(lp (Œª (n : ‚Ñï), ‚Ñù) ‚ä§)
{Œ± : Type u_2} [has_inv Œ±] : has_inv (filter Œ±)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) [category_theory.limits.has_limit F] (j : J) : category_theory.limits.limit F ‚ü∂ F.obj j
(n : ‚Ñï) : fin (n + 1)
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) : hb.oangle (-x) y = hb.oangle x (-y)
{C : Type u} [category_theory.category C] (F : C ‚•§ Type w) : F.elements ‚•§ C
(R : Type u) [comm_ring R] [local_ring R] : prime_spectrum R
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] : ordnode Œ± ‚Üí ordnode Œ± √ó ordnode Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {s : set (E √ó F)} : cont_diff_on ùïú n prod.snd s
(ùïú : Type u_1) (E : Type u_2) [is_R_or_C ùïú] [inner_product_space ùïú E] : inner_product_space ‚Ñù E
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [normalization_monoid Œ±] [decidable_eq Œ±] (h : ‚àÄ (a b : Œ±), ‚àÉ (c : Œ±), ‚àÄ (d : Œ±), a ‚à£ d ‚àß b ‚à£ d ‚Üî c ‚à£ d) : normalized_gcd_monoid Œ±
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} {x : Œ±} : x ‚àà closure s ‚Üî ‚àÉ (u : ultrafilter Œ±), s ‚àà u ‚àß ‚Üëu ‚â§ nhds x
{Œ± : Type u_1} [Œ≤ : normed_ring Œ±] : semi_normed_ring Œ±
 : filter.tendsto (Œª (k : ‚Ñï), (finset.range k).sum (Œª (i : ‚Ñï), (-1) ^ i / (2 * ‚Üëi + 1))) filter.at_top (nhds (real.pi / 4))
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) : CommRing.colimits.prequotient F ‚Üí CommRing.colimits.prequotient F ‚Üí Prop
{R : Type u_1} {X : Type u_2} [comm_semiring R] (p : ‚Ñï) [char_p R p] : char_p (free_algebra R X) p
{H : Type u_1} [topological_space H] {x : H} : charted_space.chart_at H x = local_homeomorph.refl H
{R : Type u_1} [comm_ring R] {x‚ÇÅ x‚ÇÇ x‚ÇÉ x‚ÇÑ y‚ÇÅ y‚ÇÇ y‚ÇÉ y‚ÇÑ : R} : (x‚ÇÅ ^ 2 + x‚ÇÇ ^ 2 + x‚ÇÉ ^ 2 + x‚ÇÑ ^ 2) * (y‚ÇÅ ^ 2 + y‚ÇÇ ^ 2 + y‚ÇÉ ^ 2 + y‚ÇÑ ^ 2) = (x‚ÇÅ * y‚ÇÅ - x‚ÇÇ * y‚ÇÇ - x‚ÇÉ * y‚ÇÉ - x‚ÇÑ * y‚ÇÑ) ^ 2 + (x‚ÇÅ * y‚ÇÇ + x‚ÇÇ * y‚ÇÅ + x‚ÇÉ * y‚ÇÑ - x‚ÇÑ * y‚ÇÉ) ^ 2 + (x‚ÇÅ * y‚ÇÉ - x‚ÇÇ * y‚ÇÑ + x‚ÇÉ * y‚ÇÅ + x‚ÇÑ * y‚ÇÇ) ^ 2 + (x‚ÇÅ * y‚ÇÑ + x‚ÇÇ * y‚ÇÉ - x‚ÇÉ * y‚ÇÇ + x‚ÇÑ * y‚ÇÅ) ^ 2
(C : Type u) [category_theory.category C] : category_theory.monad C ‚•§ Mon_ (C ‚•§ C)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) [category_theory.is_filtered J] (x y : Œ£ (j : J), ‚Ü•(F.obj j)) : AddMon.filtered_colimits.M F
{M : Type u_1} [ordered_comm_monoid M] (S : submonoid M) : ordered_comm_monoid ‚Ü•S
{R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0) : is_add_left_regular a
{G : Type u_1} [add_group G] (tG : add_monoid.is_torsion G) (bounded : (set.range (Œª (g : G), add_order_of g)).finite) : add_monoid.exponent_exists G
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : tensor_product R M N ‚âÉ‚Çó[R] tensor_product R N M
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [semiring k] [has_one G] : has_one (monoid_algebra k G)
{Œ± : Type u} [preorder Œ±] {s : set Œ±} {a : Œ±} (h : is_least s a) : bdd_below s
{M : Type u_1} [mul_one_class M] (S : submonoid M) : set M
(p : ‚Ñï) [fact (nat.prime p)] (R : Type u‚ÇÅ) [comm_semiring R] [char_p R p] : perfection_map p (perfection.coeff R p 0)
{Œ± : Type u} {Œ≤ : Type v} [non_unital_non_assoc_ring Œ±] [has_zero Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ≤), f (-x) = -f x) (sub : ‚àÄ (x y : Œ≤), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_unital_non_assoc_ring Œ≤
{x : pgame} : x.left_moves ‚âÉ (-x).right_moves
{V : Type u} (G : simple_graph V) (v : V) [fintype ‚Ü•(G.neighbor_set v)] [decidable_eq V] : finset (sym2 V)
{C : Type u‚ÇÅ} [category_theory.small_category C] {‚Ñ∞ : Type u‚ÇÇ} [category_theory.category ‚Ñ∞] [category_theory.limits.has_colimits ‚Ñ∞] (L : (C ‚•§ Type u‚ÇÅ) ‚•§ ‚Ñ∞) [category_theory.limits.preserves_colimits L] : category_theory.is_left_adjoint L
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X) : category_theory.simple ‚ÜëY ‚Üî is_atom Y
{Œ± : Type u_1} {Œ≤ : Type u_2} (e e' : local_equiv Œ± Œ≤) (s : set Œ±) (t : set Œ≤) [Œ† (x : Œ±), decidable (x ‚àà s)] [Œ† (y : Œ≤), decidable (y ‚àà t)] (H : e.is_image s t) (H' : e'.is_image s t) : local_equiv Œ± Œ≤
{Œ± : Type u} [preorder Œ±] (s : set Œ±) : set Œ±
{C : Type u} [category_theory.category C] : category_theory.monad C ‚Üí Mon_ (C ‚•§ C)
{Œπ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {c : E} {lb lb' : filter ‚Ñù} {lt : filter Œπ} {a b : ‚Ñù} {u v : Œπ ‚Üí ‚Ñù} [interval_integral.FTC_filter b lb lb'] (hab : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f lb' measure_theory.measure_space.volume) (hf : filter.tendsto f (lb' ‚äì measure_theory.measure_space.volume.ae) (nhds c)) (hu : filter.tendsto u lt lb) (hv : filter.tendsto v lt lb) : (Œª (t : Œπ), ((‚à´ (x : ‚Ñù) in a..v t, f x) - ‚à´ (x : ‚Ñù) in a..u t, f x) - (v t - u t) ‚Ä¢ c) =o[lt] (v - u)
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (A : matrix n n R) (h : is_unit A.det) : GL n R
{M : Type u_1} [add_zero_class M] (c d : add_con M) (h : c ‚â§ d) : c.quotient ‚Üí+ d.quotient
{m : Type u_3} {n : Type u_4} {Œ± : Type u_5} [fintype m] [fintype n] [semi_normed_group Œ±] : semi_normed_group (matrix m n Œ±)
{Œ± : Type u} [canonically_ordered_comm_semiring Œ±] [nontrivial Œ±] : 0 < 1
{L : first_order.language} {M : Type u_3} {N : Type u_4} [L.Structure M] [L.Structure N] (f : L.equiv M N) : L.elementary_embedding M N
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [has_add Œ≤] : has_add Œ±
{Œ± : Type u_2} [has_add Œ±] [decidable_eq Œ±] (s t : set Œ±) [fintype ‚Ü•s] [fintype ‚Ü•t] : fintype ‚Ü•(s + t)
{ùïú : Type u} [nondiscrete_normed_field ùïú] {E : Type v} [normed_group E] [normed_space ùïú E] [complete_space ùïú] (s : submodule ùïú E) [finite_dimensional ùïú ‚Ü•s] : is_closed ‚Üës
{R : Type u} {S : Type v} {A : Type w} [comm_semiring R] [semiring S] [add_comm_monoid A] [algebra R S] [module S A] [module R A] [is_scalar_tower R S A] {Œπ : Type v‚ÇÅ} {Œπ' : Type w‚ÇÅ} (b : basis Œπ R S) (c : basis Œπ' S A) : basis (Œπ √ó Œπ') R A
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (Œ∏ : real.angle) : (hb.rotation Œ∏).symm = hb.rotation (-Œ∏)
 : ‚Ñï ‚Üí nat.partrec.code
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : set P} (ho : euclidean_geometry.orthocentric_system s) {p : fin 3 ‚Üí P} (hps : set.range p ‚äÜ s) (hpi : function.injective p) : affine_span ‚Ñù (set.range p) = affine_span ‚Ñù s
{G : Type w} [topological_space G] [add_comm_group G] [topological_add_group G] : add_hom G (filter G)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') (c : category_theory.limits.cocone F) : (category_theory.limits.cocones.precompose (category_theory.whisker_left F Œ±.inv)).obj (H.map_cocone c) ‚âÖ H'.map_cocone c
(x : pgame) : (0 * x).relabelling 0
{C : Type u} [category_theory.category C] [‚àÄ (n : ‚Ñï) (f : category_theory.arrow C), category_theory.limits.has_wide_pullback f.right (Œª (i : ulift (fin (n + 1))), f.left) (Œª (i : ulift (fin (n + 1))), f.hom)] : category_theory.arrow C ‚•§ category_theory.simplicial_object.augmented C
{G : Type u_2} [add_group G] {a b : G} : a = b ‚Üí a - b = 0
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {v w : Œπ ‚Üí E} (hv : orthonormal ùïú v) (hw : ‚àÄ (i : Œπ), w i = v i ‚à® w i = -v i) : orthonormal ùïú w
(Œ± : Type u) : Type u
{Œ± : Type u_1} [has_zero Œ±] (t : tree Œ±) (n : pos_num) : Œ±
(C : Type u‚ÇÅ) [category_theory.category C] : Type (max u‚ÇÅ v‚ÇÅ)
 : function.bijective real.sinh
{M : Type u_5} {N : Type u_6} [add_monoid M] [add_monoid N] : add_units (M √ó N) ‚âÉ+ add_units M √ó add_units N
 : expr ‚Üí ‚Ñï
(m : ‚Ñï) : ‚Ñï ‚Üí option ‚Ñï
{Œ± : Type u_1} {s t : set Œ±} (p : Œ± ‚Üí Prop) [decidable_pred p] (hs : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p x) (ht : ‚àÄ (x : Œ±), x ‚àà t ‚Üí ¬¨p x) : ‚Ü•(s ‚à™ t) ‚âÉ ‚Ü•s ‚äï ‚Ü•t
{X : Type u} {Y : Type v} {Z : Type w} [nonempty Z] [metric_space Z] [metric_space X] [metric_space Y] {Œ¶ : Z ‚Üí X} {Œ® : Z ‚Üí Y} (hŒ¶ : isometry Œ¶) (hŒ® : isometry Œ®) (x : X) : metric.glue_space hŒ¶ hŒ®
{Œ± : Type u} [has_subset Œ±] [has_ssubset Œ±] [is_nonstrict_strict_order Œ± has_subset.subset has_ssubset.ssubset] {a b : Œ±} [is_antisymm Œ± has_subset.subset] (h‚ÇÅ : a ‚â† b) (h‚ÇÇ : a ‚äÜ b) : a ‚äÇ b
{G : Type u_1} [group G] (H : subgroup G) : subgroup G
(p : ‚Ñï) [fact (nat.prime p)] {a : zmod p} (ha : a ‚â† 0) : is_square a ‚Üî a ^ (p / 2) = 1
 : SemilatticeSup ‚âå SemilatticeInf
(c : tactic.instance_cache) (e : expr) : tactic (tactic.instance_cache √ó expr)
{Œ≥ : Type w} [semilattice_sup Œ≥] (a : Œ≥) {s : set Œ≥} : bdd_above (has_insert.insert a s) ‚Üî bdd_above s
 : Type
 : category_theory.limits.preserves_limits algebraic_geometry.Spec.to_LocallyRingedSpace
{Œ± : Type u} {Œ≤ : Type v} (r : rel Œ± Œ≤) (f : filter Œ≤) : filter Œ±
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] (t : category_theory.limits.cotrident f) (desc : Œ† (s : category_theory.limits.cotrident f), t.X ‚ü∂ s.X) (fac : ‚àÄ (s : category_theory.limits.cotrident f), t.œÄ ‚â´ desc s = s.œÄ) (uniq : ‚àÄ (s : category_theory.limits.cotrident f) (m : t.X ‚ü∂ s.X), (‚àÄ (j : category_theory.limits.walking_parallel_family J), t.Œπ.app j ‚â´ m = s.Œπ.app j) ‚Üí m = desc s) : category_theory.limits.is_colimit t
(R : Type u_1) (M : Type u_2) [has_zero M] : Type u_2
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] (X : C) : Prop
{S : Type u} [pgame.state S] (s : S) (n m : ‚Ñï) (hn : pgame.state.turn_bound s ‚â§ n) (hm : pgame.state.turn_bound s ‚â§ m) : (pgame.of_aux n s hn).relabelling (pgame.of_aux m s hm)
{Œ± : Type u_2} [decidable_eq Œ±] {s : finset Œ±} {B : finset (finset Œ±)} {n : ‚Ñï} (h : ‚àÄ (a : Œ±), a ‚àà s ‚Üí n ‚â§ (finset.filter (has_mem.mem a) B).card) : s.card * n ‚â§ B.sum (Œª (t : finset Œ±), (s ‚à© t).card)
{Œ± : Type u_1} {Œ≤ : Type u_2} [non_unital_normed_ring Œ±] [non_unital_normed_ring Œ≤] : non_unital_normed_ring (Œ± √ó Œ≤)
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {Œπ : Type u_6} (Z : topological_vector_bundle_core R B F Œπ) : topological_fiber_bundle_core Œπ B F
 : format ‚Üí options ‚Üí buffer char
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] {p : P} (hp : p ‚àà s) {v : V} (hv : v ‚àà (s.direction)·óÆ) : ‚áë(euclidean_geometry.reflection s) (v +·µ• p) = -v +·µ• p
(Œ± : Type u‚ÇÅ) : (category_theory.discrete Œ±)·µí·µñ ‚âå category_theory.discrete Œ±
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (p : polynomial S) (i : ‚Ñï) : R
(C : Type u‚ÇÅ) [category_theory.category C] : Prop
{Œπ : Type u} (Œ≥ : Type w) (Œ≤ : Œπ ‚Üí Type v) [semiring Œ≥] [Œ† (i : Œπ), add_comm_monoid (Œ≤ i)] [Œ† (i : Œπ), module Œ≥ (Œ≤ i)] (p : Œπ ‚Üí Prop) [decidable_pred p] : (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚Üí‚Çó[Œ≥] Œ†‚ÇÄ (i : Œπ), Œ≤ i
{R‚ÇÇ : Type u_5} {M‚ÇÇ : Type u_6} [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] : bilin_form R‚ÇÇ M‚ÇÇ ‚âÉ‚Çó[R‚ÇÇ] bilin_form R‚ÇÇ M‚ÇÇ
 : cardinal
{Œ± : Type u_1} [topological_space Œ±] (s : set Œ±) : topological_space.opens Œ±
 : linarith.sum
{R : Type u_1} {K : Type u_2} [ring R] [field K] (f : R ‚Üí+* K) (hf : function.surjective ‚áëf) : f.ker.is_maximal
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V‚ÇÇ : Type v'} [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] [h : finite_dimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ) (hf : f.range = ‚ä§) : finite_dimensional K V‚ÇÇ
{X : Type u_1} (point : X) : Pointed
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] : (M ‚Üí+ N) ‚âÉ (M·µÉ·µí·µñ ‚Üí+ N·µÉ·µí·µñ)
{R : Type u_1} [comm_semiring R] {m : Type u_3} {n : Type u_4} [fintype n] [decidable_eq n] : matrix m n R ‚âÉ‚Çó[R] (n ‚Üí R) ‚Üí‚Çó[R] m ‚Üí R
{C : Type u} [category_theory.category C] (X Y : C) [category_theory.limits.has_binary_product X Y] : category_theory.limits.is_limit (category_theory.limits.binary_fan.mk category_theory.limits.prod.fst category_theory.limits.prod.snd)
{Œ± : Type u_1} (s : cycle Œ±) : multiset (list Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚Üí D) : Type (max v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ)
(Œ± : Type u_2) [cancel_comm_monoid_with_zero Œ±] : Type u_2
{Y Z : Type u} {g h : Y ‚ü∂ Z} : category_theory.limits.limit_cone (category_theory.limits.parallel_pair g h)
{M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_3} [has_zero M‚ÇÄ'] [has_mul M‚ÇÄ'] [has_one M‚ÇÄ'] [has_pow M‚ÇÄ' ‚Ñï] [comm_monoid_with_zero M‚ÇÄ] (f : M‚ÇÄ ‚Üí M‚ÇÄ') (hf : function.surjective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÄ), f (x * y) = f x * f y) (npow : ‚àÄ (x : M‚ÇÄ) (n : ‚Ñï), f (x ^ n) = f x ^ n) : comm_monoid_with_zero M‚ÇÄ'
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ : X} {p‚ÇÄ p‚ÇÅ : path x‚ÇÄ x‚ÇÅ} (F : p‚ÇÄ.homotopy p‚ÇÅ) : p‚ÇÅ.homotopy p‚ÇÄ
(ic : tactic.instance_cache) : expr ‚Üí expr ‚Üí tactic (tactic.instance_cache √ó expr)
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J·µí·µñ ‚•§ C) {c : category_theory.limits.cone F} (hc : category_theory.limits.is_limit c) : category_theory.limits.is_colimit (category_theory.limits.cocone_right_op_of_cone c)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (A : set (set Œ±)) (F : Œ† (s : set Œ±), s ‚àà A ‚Üí C(‚Ü•s, Œ≤)) (hF : ‚àÄ (s : set Œ±) (hs : s ‚àà A) (t : set Œ±) (ht : t ‚àà A) (x : Œ±) (hxi : x ‚àà s) (hxj : x ‚àà t), ‚áë(F s hs) ‚ü®x, hxi‚ü© = ‚áë(F t ht) ‚ü®x, hxj‚ü©) (hA : ‚àÄ (x : Œ±), ‚àÉ (i : set Œ±) (H : i ‚àà A), i ‚àà nhds x) : C(Œ±, Œ≤)
(ùïÜ : Type u_5) (Œ± : Type u_6) [preorder ùïÜ] [preorder Œ±] : Type (max u_5 u_6)
{ùïú : Type u_3} {E : Type u_4} [normed_field ùïú] [add_comm_group E] [module ùïú E] (p : seminorm ùïú E) {r : ‚Ñù} (hr : 0 < r) : absorbent ùïú (p.ball 0 r)
(x y : pgame) : (x + y).relabelling (y + x)
{K : Type u} [field K] {S T : subfield K} (h : S ‚â§ T) : ‚Ü•S ‚Üí+* ‚Ü•T
(k : Type u‚ÇÅ) {G : Type u‚ÇÇ} [semiring k] [has_add G] {A : Type u‚ÇÉ} [non_unital_non_assoc_semiring A] [module k A] [is_scalar_tower k A A] [smul_comm_class k A A] : (multiplicative G ‚Üí‚Çô* A) ‚âÉ (add_monoid_algebra k G ‚Üí‚Çô‚Çê[k] A)
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] {R : Type u_1} [non_assoc_semiring R] {f : Œ† (k : ‚Ñï), R ‚Üí+* zmod (p ^ k)} (f_compat : ‚àÄ (k1 k2 : ‚Ñï) (hk : k1 ‚â§ k2), (zmod.cast_hom _ (zmod (p ^ k1))).comp (f k2) = f k1) (r : R) : padic_seq p
{Œ± : Type u} (s : wseq Œ±) : ‚Ñï ‚Üí wseq Œ±
{R : Type u‚ÇÅ} [monoid R] [has_distrib_neg R] : (-1) ^ 2 = 1
(Œ± : Type u_1) [cancel_comm_monoid_with_zero Œ±] [unique_factorization_monoid Œ±] [decidable_eq (associates Œ±)] [decidable_eq Œ±] : gcd_monoid Œ±
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] [compact_space Œ±] (f : C(Œ±, Œ≤)) : bounded_continuous_function Œ± Œ≤
 : expr ‚Üí option ‚Ñö
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} : b ‚â§ c ‚Üí a < b ‚Üí a < c
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) {r : ‚Ñù} (hr : 0 < r) : hb.oangle x (r ‚Ä¢ y) = hb.oangle x y
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {k : S.localization_map P} (z : N) : ‚áë(k.lift _) (‚áë(f.lift _) z) = z
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [add_comm_monoid E] [module ùïú E] [topological_space E] (s : set E) : Prop
 : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} {m : measurable_space Œ±} [topological_space Œ≤] [preorder Œπ] {u : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : measure_theory.filtration Œπ m} [topological_space Œπ] [topological_space.metrizable_space Œπ] [measurable_space Œπ] [topological_space.second_countable_topology Œπ] [opens_measurable_space Œπ] [topological_space.metrizable_space Œ≤] (h : measure_theory.adapted f u) (hu_cont : ‚àÄ (x : Œ±), continuous (Œª (i : Œπ), u i x)) : measure_theory.prog_measurable f u
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (C : homological_complex V c) [category_theory.limits.has_zero_object V] {j : Œπ} (h : c.prev j = option.none) : C.X_prev j ‚âÖ 0
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ‚Ñù P) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p) ‚àà affine_subspace.mk' p (s.direction)·óÆ
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) : has_bracket L (M ‚ß∏ N)
{Œ± : Type u_5} {Œ≤ : Type u_6} [non_assoc_semiring Œ±] [non_assoc_semiring Œ≤] (self : Œ± ‚Üí+* Œ≤) : Œ± ‚Üí* Œ≤
{K : Type u_2} [division_ring K] (a b : K) (ppred pred : generalized_continued_fraction.pair K) : generalized_continued_fraction.pair K
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : local_homeomorph Œ± Œ≤) {b : Œ≤} (hb : b ‚àà e.to_local_equiv.target) {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} {C : ‚Ñù} : asymptotics.is_O_with C (nhds b) f g ‚Üî asymptotics.is_O_with C (nhds (‚áë(e.symm) b)) (f ‚àò ‚áëe) (g ‚àò ‚áëe)
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {r : R} (h : same_ray R x y) (hr : 0 ‚â§ r) : same_ray R x (r ‚Ä¢ y)
{G : Type u_1} [add_group G] {k : set G} {p : G ‚Üí Prop} {x : G} (h : x ‚àà add_subgroup.closure k) (Hk : ‚àÄ (x : G), x ‚àà k ‚Üí p x) (Hk_inv : ‚àÄ (x : G), x ‚àà k ‚Üí p (-x)) (H1 : p 0) (Hmul : ‚àÄ (x y : G), p x ‚Üí p y ‚Üí p (x + y)) : p x
{C : Type u} [category_theory.category C] (F : category_theory.discrete pempty ‚•§ C) : F ‚âÖ category_theory.functor.empty C
{Œπ : Type u} (f : Œπ ‚Üí cardinal) : cardinal
{n : ‚Ñï} {E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] (f : (fin n ‚Üí ‚ÑÇ) ‚Üí E) (c : fin n ‚Üí ‚ÑÇ) (R : fin n ‚Üí ‚Ñù) : E
{Œ± : Type u} : tactic.ref Œ± ‚Üí tactic Œ±
{G : Type u_10} [add_group G] (a : G) : equiv.perm G
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (m : multiset L) : (‚àÄ (a : L), a ‚àà m ‚Üí a ‚àà S) ‚Üí m.sum ‚àà S
(Œ± : Type u) [monoid Œ±] : set Œ±
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] {F : intermediate_field K L} (E : intermediate_field ‚Ü•F L) : ‚Ü•‚ÜëE ‚âÉ‚Çê[K] ‚Ü•E
 : Preorder_to_PartialOrder ‚ãô PartialOrder.dual ‚âÖ Preorder.dual ‚ãô Preorder_to_PartialOrder
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) : category_theory.limits.cocone (category_theory.functor.empty C)
{ùïú : Type u_1} [linear_ordered_field ùïú] {s : set ùïú} {f : ùïú ‚Üí ùïú} : convex_on ùïú s f ‚Üî convex ùïú s ‚àß ‚àÄ ‚¶Éx y z : ùïú‚¶Ñ, x ‚àà s ‚Üí z ‚àà s ‚Üí x < y ‚Üí y < z ‚Üí (f y - f x) / (y - x) ‚â§ (f z - f y) / (z - y)
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] (a b : Œ±) : finset Œ±
(Œ± : Sort u_1) (Œ≤ : Sort u_2) [unique Œ±] : (Œ± ‚Üí Œ≤) ‚âÉ Œ≤
(red : interactive.parse (optional (lean.parser.tk "!"))) : tactic unit
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x : V} (hx : x ‚â† 0) (Œ∏ : real.angle) : hb.oangle x (‚áë(hb.rotation Œ∏) x) = Œ∏
{V : Type u} {G : simple_graph V} {v w : V} (e : sym2 V) (p : G.walk v w) (hp : e ‚àâ p.edges) : (G.delete_edges {e}).walk v w
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (l : filter Œ±) (a : Œ±) : Prop
{M : Type v} {X : Type x} [uniform_space X] [has_scalar M X] [has_scalar M·µê·µí·µñ X] [is_central_scalar M X] [has_uniform_continuous_const_smul M X] : has_uniform_continuous_const_smul M·µê·µí·µñ X
(F : Type u ‚Üí Type u) [functor F] : Type (u+1)
{C : Type u‚ÇÅ} [category_theory.category C] : category_theory.SheafOfTypes ‚ä• ‚âå C·µí·µñ ‚•§ Type w
{Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : is_preconnected s) (ht : is_clopen t) : disjoint s t ‚à® s ‚äÜ t
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {s : set E} {f : E ‚Üí F} {n : with_top ‚Ñï} {p : E ‚Üí formal_multilinear_series ùïú E F} (hf : has_ftaylor_series_up_to_on n f p s) (g : G ‚ÜíL[ùïú] E) : has_ftaylor_series_up_to_on n (f ‚àò ‚áëg) (Œª (x : G) (k : ‚Ñï), (p (‚áëg x) k).comp_continuous_linear_map (Œª (_x : fin k), g)) (‚áëg ‚Åª¬π' s)
{R : Type u_1} [comm_ring R] {M : submonoid R} {S : Type u_2} [comm_ring S] [algebra R S] (R‚Çò : Type u_4) (S‚Çò : Type u_5) [comm_ring R‚Çò] [comm_ring S‚Çò] [algebra R R‚Çò] [is_localization M R‚Çò] [algebra S S‚Çò] [is_localization (algebra.algebra_map_submonoid S M) S‚Çò] (hRS : function.injective ‚áë(algebra_map R S)) (hM : algebra.algebra_map_submonoid S M ‚â§ non_zero_divisors S) : function.injective ‚áë(algebra_map R‚Çò S‚Çò)
{X Y : Ring} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ+* ‚Ü•Y
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (S : Type u_3) [comm_monoid S] [distrib_mul_action S M] [smul_comm_class S R M] : module.is_torsion' ‚Ü•(submodule.torsion' R M S) S
{E : Type u} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {a : E} {f' : E ‚ÜíL[‚Ñù] ‚Ñù} {s : set E} (h : is_local_max_on f s a) (hf : has_fderiv_within_at f f' s a) {y : E} (hy : y ‚àà pos_tangent_cone_at s a) (hy' : -y ‚àà pos_tangent_cone_at s a) : ‚áëf' y = 0
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Œπ R M) (i : Œπ) : M ‚Üí‚Çó[R] R
{x y : pgame} : x.right_moves ‚äï y.right_moves ‚âÉ (x + y).right_moves
 : Type
{Œ≤ : Type u} {Œ± : Type v} {s : finset Œ±} {f : Œ± ‚Üí Œ≤} [comm_monoid Œ≤] (R : setoid Œ±) [decidable_rel setoid.r] : s.prod (Œª (x : Œ±), f x) = (finset.image quotient.mk s).prod (Œª (xbar : quotient R), (finset.filter (Œª (y : Œ±), ‚ü¶y‚üß = xbar) s).prod (Œª (y : Œ±), f y))
(c : turing.to_partrec.code) : Prop
{M : Type u_1} [has_mul M] {N : Type u_2} [has_mul N] (f : M ‚Üí‚Çô* N) (hf : function.surjective ‚áëf) : f.srange = ‚ä§
{n : ‚Ñï} (Œ± : fin (n + 1) ‚Üí Type u_1) [Œ† (i : fin (n + 1)), measurable_space (Œ± i)] (i : fin (n + 1)) : (Œ† (j : fin (n + 1)), Œ± j) ‚âÉ·µê Œ± i √ó Œ† (j : fin n), Œ± (‚áë(i.succ_above) j)
{ùïú : Type u_1} {E : Type u} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] {s : set E} {x : E} (hx : x ‚àà ‚áë(convex_hull ùïú) s) : finset E
{X : Top} (U : topological_space.opens ‚Ü•X) : ‚ä• ‚ü∂ U
(md : tactic.transparency) (unify : bool) (e : expr) (to_generalize : list (name √ó expr)) : tactic (expr √ó list expr)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] [compact_space Œ±] [compact_space Œ≤] : compact_space (Œ± ‚äï Œ≤)
(h : name) (p : pexpr) : tactic unit
{R : Type u} {S : Type v} [ring R] [ring S] : ideal (R √ó S) ‚âÉ ideal R √ó ideal S
(m n : ‚Ñï+) : Prop
(G : Type u) : Type u
{Œ± : Type u_1} : list Œ± ‚Üí list (list Œ±) ‚Üí list (list Œ±)
(C : Type u) [category_theory.category C] [category_theory.has_shift C ‚Ñ§] : Type (max u v)
{R‚ÇÅ : Type u_2} {R‚ÇÇ : Type u_3} {M : Type u_9} {N‚ÇÇ : Type u_14} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_group N‚ÇÇ] [module R‚ÇÅ M] [module R‚ÇÇ N‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} : has_sub (M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] N‚ÇÇ)
{J : Type v} (X Y Z : category_theory.limits.walking_parallel_family J) (f : category_theory.limits.walking_parallel_family.hom J X Y) (g : category_theory.limits.walking_parallel_family.hom J Y Z) : category_theory.limits.walking_parallel_family.hom J X Z
(f : ‚Ñù ‚Üí ‚Ñù) {a b : ‚Ñù} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfI : f a = f b) : ‚àÉ (c : ‚Ñù) (H : c ‚àà set.Ioo a b), deriv f c = 0
{Œ± : Type u_1} {n : ‚Ñï} (s : sym Œ± n) : sym {x // x ‚àà s} n
 : Type u ‚•§ CommRing
 : list ‚Ñ§ ‚Üí omega.eqelim (‚Ñ§ √ó ‚Ñï)
(k : Type u‚ÇÅ) (G : Type u‚ÇÇ) {R : Type u_1} [comm_semiring R] [semiring k] [algebra R k] [add_monoid G] : add_monoid_algebra k G ‚âÉ‚Çê[R] monoid_algebra k (multiplicative G)
(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_binary_products C
(Œ± : Type u) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
(Œ± : Type u_1) [monoid Œ±] : Œ±À£ ‚Üí* Œ± √ó Œ±·µê·µí·µñ
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [category_theory.limits.has_pushout f g] [category_theory.limits.has_pushout (G.map f) (G.map g)] [i : category_theory.is_iso (category_theory.limits.pushout_comparison G f g)] : category_theory.limits.preserves_colimit (category_theory.limits.span f g) G
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : (Œ≥ ‚Üí Œ± √ó Œ≤) ‚âÉ (Œ≥ ‚Üí Œ±) √ó (Œ≥ ‚Üí Œ≤)
(n : ‚Ñï) (R : Type u_1) [comm_ring R] [is_domain R] : polynomial.cyclotomic' n R ‚â† 0
{Œ± : Type u_1} [has_one Œ±] [has_zero Œ±] [has_lt Œ±] : has_coe (continued_fraction Œ±) (generalized_continued_fraction Œ±)
(Œ± : Type u_1) : Type u_1
{Œ± : Type u} [preorder Œ±] {s t : set Œ±} (h : bdd_above s) : bdd_above (s ‚à© t)
{Œ± : Type u_1} [uniform_space Œ±] (x : Œ±) : nhds (x, x) ‚â§ uniformity Œ±
(R : CommRing) : algebraic_geometry.SheafedSpace CommRing
{Œ± : Type u_1} [comm_monoid Œ±] (a b : Œ±) : Prop
{a : Prop} {Œ± : Sort u_1} (H1 : ¬¨a) (H2 : a) : Œ±
{F : Type u_1} [field F] (p : polynomial F) (E : Type u_2) [field E] [algebra F E] [fact (polynomial.splits (algebra_map F E) p)] : (E ‚âÉ‚Çê[F] E) ‚Üí* p.gal
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {f‚ÇÄ f‚ÇÅ : C(X, Y)} (F : f‚ÇÄ.homotopy f‚ÇÅ) : ‚Ü•unit_interval √ó X ‚Üí Y
{C : Type (max v u)} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] {K : Type (max v u)} [category_theory.small_category K] [category_theory.concrete_category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [category_theory.limits.preserves_limits (category_theory.forget D)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] [Œ† (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)·µí·µñ (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] {F : K ‚•§ category_theory.Sheaf J D} (E : category_theory.limits.cocone (F ‚ãô category_theory.Sheaf_to_presheaf J D)) : category_theory.limits.cocone F
{Œ± : Type u_2} {G : Type u_4} [topological_space Œ±] [add_group G] [add_action G Œ±] [has_continuous_const_vadd G Œ±] (Œ≥ : G) : Œ± ‚âÉ‚Çú Œ±
{Œ± : Type u_2} {Œπ : Type u_5} [comm_monoid Œ±] (t : finset Œπ) (f : Œπ ‚Üí set Œ±) (a : Œ±) : a ‚àà t.prod (Œª (i : Œπ), f i) ‚Üî ‚àÉ (g : Œπ ‚Üí Œ±) (hg : ‚àÄ {i : Œπ}, i ‚àà t ‚Üí g i ‚àà f i), t.prod (Œª (i : Œπ), g i) = a
{ùïú : Type u_1} {A : Type u_2} [is_R_or_C ùïú] [normed_ring A] [normed_algebra ùïú A] [complete_space A] (a : A) {z : ùïú} (hz : z ‚àà spectrum ùïú a) : exp ùïú z ‚àà spectrum ùïú (exp ùïú a)
(n : ‚Ñï) : ‚Üën.numeric
(Œ± : Type u) : Œ± √ó Œ± ‚Üí Œ± √ó Œ± ‚Üí Prop
{ùïú : Type u_1} [normed_division_ring ùïú] [char_zero ùïú] [normed_algebra ‚Ñù ùïú] : normed_algebra ‚Ñö ùïú
{Œπ : Type u} {X : Type v} [topological_space X] {s : set X} (f : partition_of_unity Œπ X s) (U : Œπ ‚Üí set X) : Prop
{Œ± : Type u} [topological_space Œ±] {J : Type u} (U : J ‚Üí topological_space.opens Œ±) : Top.glue_data
(Œ± : Type u_1) : Type u_1
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {t : category_theory.limits.cofork f g} (ht : category_theory.limits.is_colimit t) (Z : C) : (t.X ‚ü∂ Z) ‚âÉ {h // f ‚â´ h = g ‚â´ h}
{Œ± : Type u_1} {Œ≤ : Type u_2} (x : Œ≤) : Œ± ‚Üí. Œ≤
{Œ± : Type u} {Œ≤ : Type v} [has_le Œ±] [has_top Œ±] [has_bot Œ±] [has_le Œ≤] [bounded_order Œ≤] (f : Œ± ‚Üí Œ≤) (map_le : ‚àÄ (a b : Œ±), f a ‚â§ f b ‚Üí a ‚â§ b) (map_top : f ‚ä§ = ‚ä§) (map_bot : f ‚ä• = ‚ä•) : bounded_order Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {p : E ‚Üí formal_multilinear_series ùïú E F} {n : ‚Ñï} : has_ftaylor_series_up_to_on (‚Üën + 1) f p s ‚Üî has_ftaylor_series_up_to_on ‚Üën f p s ‚àß (‚àÄ (x : E), x ‚àà s ‚Üí has_fderiv_within_at (Œª (y : E), p y n) (p x n.succ).curry_left s x) ‚àß continuous_on (Œª (x : E), p x (n + 1)) s
{Œ± : Type u_1} [topological_space Œ±] [t2_space Œ±] [locally_compact_space Œ±] : baire_space Œ±
{n : with_top ‚Ñï} : cont_diff ‚Ñù n exp_neg_inv_glue
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) [category_theory.is_filtered J] : has_add (AddMon.filtered_colimits.M F)
{ùïú : Type u} {Œπ : Type v} {E : Œπ ‚Üí Type wE} {G : Type wG} [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] [normed_group G] [normed_space ùïú G] [complete_space G] : complete_space (continuous_multilinear_map ùïú E G)
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] {A B : C·µí·µñ} (g : A ‚ü∂ B) : opposite.op (category_theory.limits.kernel g.unop) ‚âÖ category_theory.limits.cokernel g
{M : Type u} {N : Type v} [monoid M] [monoid N] (f : M ‚Üí* N) (g : M ‚Üí NÀ£) (h : ‚àÄ (x : M), ‚Üë(g x) = ‚áëf x) : M ‚Üí* NÀ£
{R : Type u_1} {R' : Type u_2} (M : Type u_3) [has_zero R] [has_zero M] [smul_with_zero R M] [has_zero R'] (f : zero_hom R' R) : smul_with_zero R' M
(R : Type u) [comm_ring R] : algebraic_geometry.structure_presheaf_in_CommRing R ‚ãô category_theory.forget CommRing ‚âÖ (algebraic_geometry.structure_sheaf_in_Type R).val
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : rel Œ± Œ≤) (s : set Œ±) : set Œ≤
{Œ± : Type u_1} [lattice Œ±] [order_bot Œ±] [decidable_eq Œ±] {a : Œ±} (parts : finset Œ±) (sup_indep : parts.sup_indep id) (sup_parts : parts.sup id = a) : finpartition a
{C : Type u} [category_theory.category C] : category_theory.simplicial_object.augmented C ‚•§ C
(e : expr) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum √ó expr)
(str : string) : lean.parser string
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {x y : Œ±} : (setoid.ker f).rel x y ‚Üî x ‚àà f ‚Åª¬π' {f y}
{G : Type u_1} [add_monoid G] (tG : add_monoid.is_torsion G) : add_group G
{p : ‚Ñï} : padic_val_int p 1 = 0
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : set Œ±
{S : Type u_2} [comm_ring S] {K : Type u_4} {F : Type u_6} [field K] [field F] [algebra K F] [algebra K S] (pb : power_basis K S) (hf : polynomial.splits (algebra_map K F) (minpoly K pb.gen)) : ‚áë(algebra_map K F) (‚áë(algebra.norm K) pb.gen) = (polynomial.map (algebra_map K F) (minpoly K pb.gen)).roots.prod
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} {Œ≤ : Type u} (g‚ÇÄ : Œ≤ ‚Üí P.A) (g‚ÇÅ : Œ† (b : Œ≤), (P.drop.B (g‚ÇÄ b)).arrow Œ±) (g‚ÇÇ : Œ† (b : Œ≤), P.last.B (g‚ÇÄ b) ‚Üí Œ≤) (x : P.last.M) (b : Œ≤) : x = mvpfunctor.M.corec_shape P g‚ÇÄ g‚ÇÇ b ‚Üí typevec.arrow (mvpfunctor.M.path P x) Œ±
{Œπ : Type u_1} {R : Type u_2} {M : Type u_3} {N : Type u_4} [comm_ring R] [add_comm_group M] [add_comm_group N] [module R M] [module R N] [decidable_eq Œπ] [fintype Œπ] (b : basis Œπ R M) : tensor_product R (module.dual R M) N ‚âÉ‚Çó[R] M ‚Üí‚Çó[R] N
(h : expr) (hs : expr_set) : tactic bool
{Œ± : Type u} [topological_space Œ±] : set Œ± ‚Üí set Œ± ‚Üí Prop
(K : Type u_1) [field K] (L : Type u_2) [field L] [algebra K L] : set (intermediate_field K L)
{m : Type u_2} {Œ± : Type v} {Œ≤ : Type w} [fintype m] [decidable_eq m] [non_assoc_semiring Œ±] [non_assoc_semiring Œ≤] (f : Œ± ‚âÉ+* Œ≤) : matrix m m Œ± ‚âÉ+* matrix m m Œ≤
{a b : ordinal} : {o : ordinal | a ‚â§ b + o}.nonempty
(C : Type u) [category_theory.category C] : Type (max u v)
{E : Type u_2} [normed_group E] [normed_space ‚Ñù E] {r : ‚Ñù} (hr : 0 ‚â§ r) : r ‚Ä¢ metric.closed_ball 0 1 = metric.closed_ball 0 r
{Œ≥ : Type u_1} [U : topological_space Œ≥] (m : pseudo_metric_space Œ≥) (H : U = uniform_space.to_topological_space) : pseudo_metric_space Œ≥
(n : ‚Ñï) : list (fin n)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] {p1 : P} (p2 : P) (r : ‚Ñù) (hp : p1 ‚àà s) : ‚áë(euclidean_geometry.orthogonal_projection s) (r ‚Ä¢ (p2 -·µ• ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p2)) +·µ• p1) = ‚ü®p1, hp‚ü©
(R : Type u) {Œπ : Type v} (M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ) (M‚ÇÇ : Type w‚ÇÇ) [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [topological_space M‚ÇÇ] : Type (max v w‚ÇÅ w‚ÇÇ)
(H : Type u_1) [topological_space H] : pregroupoid H
(k : Type u_1) {V1 : Type u_2} (P1 : Type u_3) [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] : ‚áë(affine_map.id k P1) = id
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] : category_theory.triangulated.inv_rotate C ‚ãô category_theory.triangulated.rotate C ‚âÖ ùü≠ (category_theory.triangulated.triangle C)
{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (k : ‚Ñï) (h : ‚àÄ (v : V), G.degree v ‚â§ k) : G.max_degree ‚â§ k
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e e' : local_homeomorph Œ± Œ≤} (h : e ‚âà e') : e.symm ‚âà e'.symm
(x : ‚Ñù) : ‚Ñù
{Œ± : Type u_1} [topological_space Œ±] (s : topological_space.opens Œ±) [nonempty ‚Ü•s] : local_homeomorph ‚Ü•s Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] : category_theory.limits.is_limit (category_theory.limits.biprod.snd_kernel_fork X Y)
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {D : Type u‚ÇÑ} [category_theory.category D] {G : K ‚•§ D} (h : category_theory.limits.cocone G ‚âå category_theory.limits.cocone F) {c : category_theory.limits.cocone G} : category_theory.limits.is_colimit (h.functor.obj c) ‚âÉ category_theory.limits.is_colimit c
 : expr ‚Üí ‚Ñï
{Œ± : Type u} {Œ≤ : Type v} [non_unital_comm_ring Œ±] [has_zero Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.surjective f) (zero : f 0 = 0) (add : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ±), f (-x) = -f x) (sub : ‚àÄ (x y : Œ±), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ±) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : Œ±) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_unital_comm_ring Œ≤
{et : tactic.ring_exp.ex_type} : tactic.ring_exp.ex et ‚Üí tactic.ring_exp.ex et ‚Üí bool
(n : name) : tactic name
 : Top ‚•§ category_theory.Groupoid
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E1 E2 : intermediate_field K L) (h1 : finite_dimensional K ‚Ü•E1) (h2 : finite_dimensional K ‚Ü•E2) : finite_dimensional K ‚Ü•(E1 ‚äî E2)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (u : E) {v : E} (hv : v ‚àà (submodule.span ùïú {u})·óÆ) : has_inner.inner v u = 0
(cache : expr_map expr_set) (h : expr) : tactic (expr_set √ó expr_map expr_set)
(R : Type u_1) [ring R] : polynomial.cyclotomic 2 R = polynomial.X + 1
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] {X Y : C} (hX : category_theory.exponentiable X) (hY : category_theory.exponentiable Y) : category_theory.exponentiable (X ‚®Ø Y)
{C : Type u} {X Y : category_theory.free_monoidal_category C} : X.hom Y ‚Üí (category_theory.discrete.functor X.normalize_obj ‚ü∂ category_theory.discrete.functor Y.normalize_obj)
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b : Œ±} (ha : a < 1) (hb : b ‚â§ 1) : a * b < 1
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_group Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} : concave_on ùïú s (-f) ‚Üî convex_on ùïú s f
(G : Type u_1) [add_comm_group G] : add_comm_monoid.add_torsion G = (add_torsion G).to_add_submonoid
{Œ± : Type u} [pseudo_metric_space Œ±] : isometry coe
 : list pgame ‚Üí Type (u+1)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] {f : J ‚Üí C} {t : category_theory.limits.cone (category_theory.discrete.functor f)} (ht : category_theory.limits.is_limit t) : (category_theory.limits.bicone.of_limit_cone ht).is_bilimit
{Œ≥ : Type u_3} [tŒ≥ : topological_space Œ≥] [polish_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] {Œ≤ : Type u_4} [tŒ≤ : topological_space Œ≤] [t2_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] {f : Œ≥ ‚Üí Œ≤} (f_cont : continuous f) (f_inj : function.injective f) : measurable_embedding f
{R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] (j k : S ‚Üí P) (hj1 : j 1 = 1) (hk1 : k 1 = 1) (hjm : ‚àÄ (a b : S), j (a * b) = j a * j b) (hkm : ‚àÄ (a b : S), k (a * b) = k a * k b) (h : ‚àÄ (a : R), j (‚áë(algebra_map R S) a) = k (‚áë(algebra_map R S) a)) : j = k
{Œ± : Type u} (s : wseq Œ±) (n : ‚Ñï) : list Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (ga : Œ± ‚Üí Œ±) (gb : Œ≤ ‚Üí Œ≤) : Prop
{Œ± : Type u} [topological_space Œ±] {S : set (set Œ±)} (K : directed_on has_subset.subset S) (H : ‚àÄ (s : set Œ±), s ‚àà S ‚Üí is_preconnected s) : is_preconnected (‚ãÉ‚ÇÄS)
 : tactic unit
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} : P.W Œ± ‚Üí P.obj (Œ± ::: P.W Œ±)
{Œ± : Type u_1} (M : Type u_2) [mul_one_class M] (s : set Œ±) : (Œ± ‚Üí M) ‚Üí* Œ± ‚Üí M
{R‚ÇÉ : Type u_7} [comm_ring R‚ÇÉ] {n : Type u_11} [fintype n] (J : matrix n n R‚ÇÉ) [decidable_eq n] : submodule R‚ÇÉ (matrix n n R‚ÇÉ)
{Œ± : Type u} [preorder Œ±] (s : set Œ±) : Prop
(R : Type u_1) [linear_ordered_semiring R] : subgroup RÀ£
{Œ± : Type u_1} [lattice Œ±] [is_modular_lattice Œ±] {Œ≤ : Type u_2} {Œ≥ : Type u_3} [partial_order Œ≤] [preorder Œ≥] (h‚ÇÅ : well_founded has_lt.lt) (h‚ÇÇ : well_founded has_lt.lt) (K : Œ±) (f‚ÇÅ : Œ≤ ‚Üí Œ±) (f‚ÇÇ : Œ± ‚Üí Œ≤) (g‚ÇÅ : Œ≥ ‚Üí Œ±) (g‚ÇÇ : Œ± ‚Üí Œ≥) (gci : galois_coinsertion f‚ÇÅ f‚ÇÇ) (gi : galois_insertion g‚ÇÇ g‚ÇÅ) (hf : ‚àÄ (a : Œ±), f‚ÇÅ (f‚ÇÇ a) = a ‚äì K) (hg : ‚àÄ (a : Œ±), g‚ÇÅ (g‚ÇÇ a) = a ‚äî K) : well_founded has_lt.lt
(Œ± : Type u_1) [topological_space Œ±] : local_homeomorph Œ± Œ±
{Œ± : Type u_1} [partial_order Œ±] [pred_order Œ±] {a : Œ±} : is_min a ‚Üí order.pred a = a
(R : Type u) [comm_ring R] (p : prime_spectrum R) : is_localization.at_prime ‚Ü•((algebraic_geometry.Spec.structure_sheaf R).val.stalk p) p.as_ideal
{R : Type u} [comm_semiring R] (t : multiset (polynomial R)) : t.prod.degree ‚â§ (multiset.map polynomial.degree t).sum
{M : Type u_1} [has_add M] {c d : add_con M} : (‚àÄ (x y : M), ‚áëc x y ‚Üî ‚áëd x y) ‚Üî c = d
(F : Type u) (K A : Type v) [field F] [field K] [add_comm_group A] [algebra F K] [module K A] [module F A] [is_scalar_tower F K A] : module.rank F K * module.rank K A = module.rank F A
{R : Type u_1} {M : Type u_2} [comm_ring R] [topological_space R] [add_comm_group M] [module R M] [discrete_topology R] : inhabited (module_filter_basis R M)
(c : linarith.pcomp) (n : ‚Ñï) : linarith.pcomp
{M : Type u_1} [comm_monoid M] (f s : ‚Ñï ‚Üí M) (h0 : s 0 = 1) (h : ‚àÄ (n : ‚Ñï), s (n + 1) = s n * f n) (n : ‚Ñï) : (finset.range n).prod (Œª (k : ‚Ñï), f k) = s n
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_terminal C] (P : C) : P ‚ü∂ ‚ä§_ C
{A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ} [category_theory.category A] [category_theory.category B] [category_theory.category C] (U : B ‚•§ C) [category_theory.monadic_right_adjoint U] {R : A ‚•§ B} [category_theory.limits.has_reflexive_coequalizers A] [category_theory.is_right_adjoint (R ‚ãô U)] : category_theory.is_right_adjoint R
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [comm_ring R] [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] (v : valuation R Œì‚ÇÄ) : ideal R
(a b : pos_num) : pos_num
{Œ± : Type u_2} [division_monoid Œ±] : division_monoid (filter Œ±)
{Œ± : Type u_1} (l‚ÇÅ l‚ÇÇ : list Œ±) : Prop
{C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ‚Ñï} (i : fin (n + 1)) : X.obj (simplex_category.mk (n + 1)) ‚ü∂ X.obj (simplex_category.mk n)
{K : Type u} [hring : comm_ring K] : ratfunc K ‚Üí ratfunc K
{Œ± : Type u} {L‚ÇÅ L‚ÇÇ : list (Œ± √ó bool)} [decidable_eq Œ±] (H : free_group.mk L‚ÇÅ = free_group.mk L‚ÇÇ) : free_group.reduce L‚ÇÅ = free_group.reduce L‚ÇÇ
{Œ± : Type u} [pseudo_emetric_space Œ±] {p : Œ± ‚Üí Prop} (x y : subtype p) : has_edist.edist x y = has_edist.edist ‚Üëx ‚Üëy
{Œ± : Type u_2} [preorder Œ±] : Œ± ‚Üío Œ±
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±] {a b : Œ±} (hab : a ‚â† b) : closure (set.Ioc a b) = set.Icc a b
{n : ‚Ñï} {p : fin n ‚Üí Prop} [decidable_pred p] : fin.find p = option.none ‚Üî ‚àÄ (i : fin n), ¬¨p i
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : Top} (f : X ‚ü∂ Y) (F : Top.presheaf C X) (x : ‚Ü•X) : (f _* F).stalk (‚áëf x) ‚ü∂ F.stalk x
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] [category_theory.normal_epi_category C] (f : X ‚ü∂ Y) [category_theory.epi f] : category_theory.normal_epi f
{A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [is_dedekind_domain A] [algebra A K] [is_fraction_ring A K] {J : ideal A} (hJ : J ‚â† ‚ä§) {Œπ : Type u_1} (s : finset Œπ) (f : Œπ ‚Üí K) {j : Œπ} (hjs : j ‚àà s) (hjf : f j ‚â† 0) : ‚àÉ (a : K), (‚àÄ (i : Œπ), i ‚àà s ‚Üí is_localization.is_integer A (a * f i)) ‚àß ‚àÉ (i : Œπ) (H : i ‚àà s), a * f i ‚àâ ‚ÜëJ
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [add_monoid Œπ] [Œ† (i : Œπ), add_comm_monoid (A i)] : Type (max u_1 u_2)
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.mul_pos_mono Œ±] (ha : 1 ‚â§ a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b
 : tactic.rewrite_search.side ‚Üí format
(C : Type v) (D : Type v') [category_theory.category C] [category_theory.concrete_category C] [category_theory.category D] [category_theory.concrete_category D] : Type (max u_1 u_2 v v')
 : Type
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (Œ¶ : submodule R (module.dual R M)) : submodule R M
{m : Type u_1 ‚Üí Type u_2} [alternative m] {Œ± : Type u_3} {Œ≤ : Type u_1} (f : Œ± ‚Üí m Œ≤) : lazy_list Œ± ‚Üí m Œ≤
{R : Type u} {n : ‚Ñï} {M : fin n.succ ‚Üí Type v} {M‚ÇÇ : Type v‚ÇÇ} [comm_semiring R] [Œ† (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : fin n.succ), module R (M i)] [module R M‚ÇÇ] (f : M 0 ‚Üí‚Çó[R] multilinear_map R (Œª (i : fin n), M i.succ) M‚ÇÇ) : multilinear_map R M M‚ÇÇ
(Œ± : Type u_1) [complete_lattice Œ±] : Prop
{G : Type u_1} {M : Type u_3} [group G] [monoid M] [mul_action G M] [smul_comm_class G M M] [is_scalar_tower G M M] : mul_action G MÀ£
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x : V} (hx : x ‚â† 0) : o.oangle x (-x) = ‚Üëreal.pi
{Œ± Œ≤ : Type u} (f : Œ± ‚Üí Œ≤) : Œ± ‚ü∂ Œ≤
 : Type (u_1+1)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_5} [normed_group E'] [normed_space ùïú E'] {n : with_top ‚Ñï} {f : E ‚Üí E'} {x : E} : cont_diff_at ùïú n f x ‚Üí cont_mdiff_at (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') n f x
{K : Type u_1} {n : ‚Ñï} {g : generalized_continued_fraction K} [division_ring K] (terminated_at_n : g.terminated_at n) : g.squash_gcf n = g
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : finset V
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} (p : Œπ ‚Üí P) (i : Œπ) : finset.centroid k {i} p = p i
 : category_theory.category algebraic_geometry.Scheme
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.full F] [category_theory.faithful F] : category_theory.limits.reflects_limits_of_size F
(Œ± : Type u_2) [has_le Œ±] : Prop
{M : Type u_5} {N : Type u_6} {P : Type u_7} [add_zero_class M] [add_zero_class N] [add_zero_class P] (f : M ‚Üí+ N) (g : M ‚Üí+ P) : M ‚Üí+ N √ó P
 : format ‚Üí format.color ‚Üí format
{Œπ : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [ordered_comm_monoid N] (f : M ‚Üí N) (h_one : f 1 = 1) (h_mul : ‚àÄ (x y : M), f (x * y) ‚â§ f x * f y) (s : finset Œπ) (g : Œπ ‚Üí M) : f (s.prod (Œª (i : Œπ), g i)) ‚â§ s.prod (Œª (i : Œπ), f (g i))
(f v : expr) : expr ‚Üí tactic expr
{Œ± : Type u} (f : filter Œ±) [f.ne_bot] : ultrafilter Œ±
{R‚ÇÅ : Type u_1} [semiring R‚ÇÅ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] {M‚ÇÉ : Type u_7} [topological_space M‚ÇÉ] [add_comm_monoid M‚ÇÉ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] [has_continuous_add M‚ÇÉ] (f‚ÇÅ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) (f‚ÇÇ : M‚ÇÇ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) : M‚ÇÅ √ó M‚ÇÇ ‚ÜíL[R‚ÇÅ] M‚ÇÉ
(major_premise : expr) (gm : tactic.eliminate.generalization_mode) : tactic ‚Ñï
(R : Type u) [comm_ring R] (L : Type v) (M : Type w) [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : tensor_product R L M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M
{ùïú : Type u} [nondiscrete_normed_field ùïú] {E : Type v} [normed_group E] [normed_space ùïú E] {F : Type w} [normed_group F] [normed_space ùïú F] [complete_space ùïú] {f : E ‚Üí‚Çó[ùïú] F} (hf : f.ker = ‚ä•) [finite_dimensional ùïú E] : closed_embedding ‚áëf
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [succ_order Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : monotone f) : pairwise (disjoint on Œª (n : Œ±), set.Ioc (f n) (f (order.succ n)))
{n : ‚Ñï} (p i : fin n) : p.pred_above (‚áë((‚áëfin.cast_succ p).succ_above) i) = i
{Œ± : Type u} [decidable_eq Œ±] {Œπ : Type u_1} (s : set Œπ) [fintype ‚Ü•s] (t : Œπ ‚Üí set Œ±) (H : Œ† (i : Œπ), i ‚àà s ‚Üí fintype ‚Ü•(t i)) : fintype (‚Ü•‚ãÉ (x : Œπ) (H : x ‚àà s), t x)
{F : Type u_8} {G : Type u_1} {H : Type u_2} [add_group G] [add_zero_class H] [add_monoid_hom_class F G H] (f : F) : function.injective ‚áëf ‚Üî ‚àÄ (a : G), ‚áëf a = 0 ‚Üî a = 0
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : with_top Œ± ‚Üí with_top Œ≤
(n : name) (l : list name) : tactic unit
 : expr ‚Üí tactic bool
{Œ± : Type u_1} [semigroup Œ±] : has_dvd Œ±
{Œ± : Type u_1} {c : set (set Œ±)} (H : ‚àÄ (a : Œ±), ‚àÉ! (b : set Œ±) (H : b ‚àà c), a ‚àà b) {y : Œ±} : {x : Œ± | (setoid.mk_classes c H).rel x y} ‚àà c
{Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) (i j : Œπ) : (Z.local_triv_as_local_equiv i).symm.trans (Z.local_triv_as_local_equiv j) ‚âà (Z.triv_change i j).to_local_equiv
{Œ± : Type u} [pseudo_metric_space Œ±] [proper_space Œ±] : complete_space Œ±
{Œ± : Type u} [topological_space Œ±] (s : set Œ±) : Prop
 : expr ‚Üí expr
{M : Type u_1} [monoid M] {x y : M} : y ‚àà submonoid.closure {x} ‚Üî ‚àÉ (n : ‚Ñï), x ^ n = y
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} : 0 ‚â§ metric.diam s
{G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 ‚àà interior ‚ÜëH) : is_open ‚ÜëH
(x y : Set) : Set
{R : Type u} {A‚ÇÅ : Type v} [comm_semiring R] [semiring A‚ÇÅ] [algebra R A‚ÇÅ] : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÅ
{Œ± : Type u_1} [bornology Œ±] {s : set Œ±} : bornology.is_bounded s ‚Üí bounded_space ‚Ü•s
{Œ± : Type u_1} [has_le Œ±] [decidable_rel has_le.le] (x y : Œ±) : ordering
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : P} {ps : set P} (h : p ‚àà affine_span k ps) : affine_span k (has_insert.insert p ps) = affine_span k ps
{R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y
{M : Type u_1} [comm_monoid M] (S : submonoid M) : localization S ‚Üí localization S ‚Üí localization S
(R : Type u_1) [semiring R] {C : Type u_2} {D : Type u_3} [category_theory.category C] [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] [category_theory.linear R C] [category_theory.linear R D] (F : C ‚•§ D) [F.additive] : Prop
{R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] {v : M} (hv : v ‚â† 0) {r : R} (hr : r ‚â† 0) : same_ray R (r ‚Ä¢ v) v ‚Üî 0 < r
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M] : is_smul_regular M 0
(p : ‚Ñï) [fact (nat.prime p)] : galois_field p 1 ‚âÉ‚Çê[zmod p] zmod p
{R : Type u_2} {S : Type u_4} (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] [semiring S] (f : S ‚Üí+* R) : module S M
{Œ± : Type u_1} (G : simple_graph Œ±) (n : ‚Ñï) : Prop
{F : Type} [comm_semiring F] {q : ‚Ñï} {f g : polynomial F} (hf : polynomial.is_separable_contraction q f g) : ‚àÉ (m : ‚Ñï), g.nat_degree * q ^ m = f.nat_degree
{p q : Prop} (h : p ‚Üî q) (r : slim_check.test_result p) : slim_check.test_result q
{C : Type u} [category_theory.category C] (J‚ÇÅ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : J‚ÇÅ.is_closed S ‚Üî J‚ÇÅ.close S = S
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.abelian C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : category_theory.exact f g ‚Üî category_theory.limits.image_subobject f = category_theory.limits.kernel_subobject g
(length : ‚Ñï) (characters : string) : slim_check.sampleable char
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) [category_theory.limits.has_colimit F] (c : category_theory.limits.cocone F) : category_theory.limits.colimit F ‚ü∂ c.X
{Œπ : Type u_2} {R : Type u_3} [decidable_eq Œπ] [add_monoid Œπ] [comm_semiring R] : direct_sum.is_internal (add_monoid_algebra.grade R)
{Œπ : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [comm_monoid R] [add_comm_monoid Œπ] (A : Œπ ‚Üí S) [set_like.graded_monoid A] : graded_monoid.gcomm_monoid (Œª (i : Œπ), ‚Ü•(A i))
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) {f : G ‚Üí+ N} (hf : function.bijective ‚áëf) : add_subgroup.map f H.normalizer = (add_subgroup.map f H).normalizer
{Œ± : Type u_1} {Œ≤ : Type u_2} [tŒ± : topological_space Œ±] [tŒ≤ : topological_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
(M‚ÇÄ : Type u_4) : Type u_4
{Œ± : Type u_2} [decidable_eq Œ±] [has_add Œ±] {u : finset Œ±} {s t : set Œ±} : ‚Üëu ‚äÜ s + t ‚Üí (‚àÉ (s' t' : finset Œ±), ‚Üës' ‚äÜ s ‚àß ‚Üët' ‚äÜ t ‚àß u ‚äÜ s' + t')
 : category_theory.limits.walking_span ‚âå category_theory.limits.walking_span
(C : Type u_1) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.preadditive C] [category_theory.monoidal_preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_cokernels C] [category_theory.limits.has_images C] [category_theory.limits.has_image_maps C] [category_theory.has_projective_resolutions C] (X Y : C) [category_theory.projective Y] (n : ‚Ñï) : ((category_theory.Tor C (n + 1)).obj X).obj Y ‚âÖ 0
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] {X Y : C} (f : X ‚ü∂ Y) (Z : C) (l : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ 0 _)) : category_theory.epi f
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.snd
{Œ± : Type u_1} [has_one Œ±] [has_add Œ±] [z : has_zero Œ±] : num ‚Üí Œ±
(F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] : Prop
 : Type
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {a : Œ±} {s : set Œ±} (f : Œ± ‚Üí M) (h : a ‚àâ s) (hs : s.finite) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà has_insert.insert a s), f i)) = f a + finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i))
{F : Type u ‚Üí Type u} [applicative F] {Œ± : Type u_1} {Œ±' : Type u} {Œ≤ : Type u_2} {Œ≤' : Type u} (f : Œ± ‚Üí F Œ±') (f' : Œ≤ ‚Üí F Œ≤') : Œ± √ó Œ≤ ‚Üí F (Œ±' √ó Œ≤')
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {A B : Mon_ C} (f : A ‚ü∂ B) : Mod B ‚•§ Mod A
(R : Type u) [semiring R] [nontrivial R] (p : ‚Ñï) [hp : char_p R p] [hq : exp_char R 1] : p = 0
 : lean.parser tactic.ring.normalize_mode
{C : Type u} [category_theory.category C] (F : C ‚•§ Type w) : F.elements ‚âå category_theory.structured_arrow punit F
{M : Type u_1} [monoid M] {x : M} : 1 ‚àà powers x
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (t : category_theory.limits.binary_bicone X Y) (ht : category_theory.limits.is_colimit t.to_cocone) : t.is_bilimit
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≥ : Type u_5} [add_comm_monoid Œ±] {g : Œ≥ ‚Üí Œ≤} (hg : function.injective g) {f : Œ≤ ‚Üí Œ±} (hf : ‚àÄ (x : Œ≤), x ‚àâ set.range g ‚Üí f x = 0) : filter.map (Œª (s : finset Œ≥), s.sum (Œª (i : Œ≥), f (g i))) filter.at_top = filter.map (Œª (s : finset Œ≤), s.sum (Œª (i : Œ≤), f i)) filter.at_top
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} {F : Top.presheaf C X} {Œπ : Type v} {V : Top} {j : V ‚ü∂ X} (oe : open_embedding ‚áëj) (ùí∞ : Œπ ‚Üí topological_space.opens ‚Ü•V) : Top.presheaf.sheaf_condition_equalizer_products.diagram (_.functor.op ‚ãô F) ùí∞ ‚âÖ Top.presheaf.sheaf_condition_equalizer_products.diagram F (Top.presheaf.sheaf_condition_equalizer_products.cover.of_open_embedding oe ùí∞)
 : ‚ÑÇ ‚âÉ+ ‚Ñù √ó ‚Ñù
(Œ± : Type u_1) [t : topological_space Œ±] : Prop
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : has_dist.dist p3 p1 = has_dist.dist p3 p2) : euclidean_geometry.angle p3 (midpoint ‚Ñù p1 p2) p1 = real.pi / 2
{C : Type u} [category_theory.category C] {F : category_theory.limits.walking_parallel_pair ‚•§ C} (t : category_theory.limits.cone F) : category_theory.limits.fork (F.map category_theory.limits.walking_parallel_pair_hom.left) (F.map category_theory.limits.walking_parallel_pair_hom.right)
{R : Type u_1} {E : Type u_2} {Œπ : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] {s : set E} {t : finset Œπ} {w : Œπ ‚Üí R} {z : Œπ ‚Üí E} (hs : convex R s) : (‚àÄ (i : Œπ), i ‚àà t ‚Üí 0 ‚â§ w i) ‚Üí 0 < t.sum (Œª (i : Œπ), w i) ‚Üí (‚àÄ (i : Œπ), i ‚àà t ‚Üí z i ‚àà s) ‚Üí t.center_mass w z ‚àà s
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] {M‚ÇÅ' : Œπ ‚Üí Type u_1} [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ' i)] [Œ† (i : Œπ), module R (M‚ÇÅ' i)] (f : Œ† (i : Œπ), M‚ÇÅ i ‚Üí‚Çó[R] M‚ÇÅ' i) (hf : ‚àÄ (i : Œπ), function.surjective ‚áë(f i)) : function.injective (Œª (g : multilinear_map R M‚ÇÅ' M‚ÇÇ), g.comp_linear_map f)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (c : omega_complete_partial_order.chain Œ±) (f : Œ± ‚Üío Œ≤) : omega_complete_partial_order.chain Œ≤
{M : Type u_1} [monoid M] (c : con M) : monoid c.quotient
(Œ± : Type u_2) : Type u_2
(C : Type u_1) [category_theory.category C] : category_theory.idempotents.karoubi_karoubi.inverse C ‚ãô category_theory.idempotents.to_karoubi (category_theory.idempotents.karoubi C) ‚âÖ ùü≠ (category_theory.idempotents.karoubi (category_theory.idempotents.karoubi C))
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ‚ä•.direction = ‚ä•
(Œ± : Type u) [pseudo_emetric_space Œ±] [sigma_compact_space Œ±] : topological_space.second_countable_topology Œ±
{ùïÇ : Type u_1} [is_R_or_C ùïÇ] {x : ùïÇ} : has_deriv_at (exp ùïÇ) (exp ùïÇ x) x
{Œ± : Type u_2} [division_comm_monoid Œ±] : division_comm_monoid (set Œ±)
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (ha : continuous_at f a) : has_deriv_at (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in u..b, f x) (-f a) a
{R : Type u} {Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [topological_space M‚ÇÇ] [has_continuous_add M‚ÇÇ] (m : Œ† (i : Œπ), M‚ÇÅ i) : continuous_multilinear_map R M‚ÇÅ M‚ÇÇ ‚Üí+ M‚ÇÇ
{Œ± : Type u_2} {Œ≤ : Type u_3} [comm_monoid Œ±] [comm_monoid Œ≤] (A : set Œ±) (n : ‚Ñï) (b : Œ≤) : A ‚Üí*[n] Œ≤
{X : Type u_1} [topological_space X] (S : discrete_quotient X) : setoid X
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (œÅ : representation k G V) : submodule k V
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] {N : lie_submodule R L M} (h‚ÇÅ : N ‚â§ lie_module.max_triv_submodule R L M) (h‚ÇÇ : lie_module.is_nilpotent R L (M ‚ß∏ N)) : lie_module.is_nilpotent R L M
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x : V} (hx : x ‚â† 0) (Œ∏ : real.angle) : x = ‚áë(hb.rotation Œ∏) x ‚Üî Œ∏ = 0
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_image f] : ‚Üë(category_theory.limits.image_subobject f) ‚âÖ category_theory.limits.image f
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (P : C ‚Üí Prop) [category_theory.monoidal_category.monoidal_predicate P] : category_theory.monoidal_functor {X // P X} C
{Œ± : Type u_1} {Œπ : Type u_2} [semilattice_inf Œ±] [order_bot Œ±] (s : set Œπ) (f : Œπ ‚Üí Œ±) : Prop
{Œ± : Type u_1} (a : Œ±) : pmf Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [add_comm_monoid Œ±] [topological_space Œ±] [has_continuous_add Œ±] [regular_space Œ±] {f : Œ≤ √ó Œ≥ ‚Üí Œ±} {g : Œ≤ ‚Üí Œ±} {a : Œ±} (ha : has_sum f a) (hf : ‚àÄ (b : Œ≤), has_sum (Œª (c : Œ≥), f (b, c)) (g b)) : has_sum g a
 : cc_state ‚Üí expr ‚Üí tactic expr
{ùïú : Type u_1} [is_R_or_C ùïú] [decidable_eq ùïú] {n : Type u_2} [fintype n] [decidable_eq n] {A : matrix n n ùïú} (hA : A.is_hermitian) : matrix n n ùïú
(f : string ‚Üí string) : name ‚Üí name
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} : b ‚â§ c ‚Üí a ‚â§ b ‚Üí a ‚â§ c
{C : Type u} [category_theory.category C] [category_theory.preadditive C] : category_theory.preadditive_coyoneda ‚ãô (category_theory.whiskering_right C AddCommGroup (Type v)).obj (category_theory.forget AddCommGroup) = category_theory.coyoneda
{G : Type u_6} [group G] {H : Type u_1} [group H] (f : G ‚Üí H) (hf : ‚àÄ (x y : G), f (x / y) = f x / f y) : G ‚Üí* H
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype (Œ± ‚äï Œ≤)] : fintype Œ±
{Œ± : Type u_1} (f : poly Œ±) : is_poly ‚áëf
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type u} {Œ∫ : cardinal} (hŒ∫ : cardinal.sum (Œª (a : Œ±), Œ∫ ^ cardinal.mk (Œ≤ a)) ‚â§ Œ∫) : cardinal.mk (W_type Œ≤) ‚â§ Œ∫
(Œ± : Type u) : Type u
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (s : set E) (x : E) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {f g : E ‚Üí F} (hf : cont_diff ùïú n f) (hg : cont_diff ùïú n g) : cont_diff ùïú n (Œª (x : E), f x + g x)
(m : Type ‚Üí Type u) [monad m] : Type (max 1 u)
(p : ‚Ñï) [hp : fact (nat.prime p)] (a : zmod p) (hap : a ‚â† 0) : multiset.map (Œª (x : ‚Ñï), (a * ‚Üëx).val_min_abs.nat_abs) (finset.Ico 1 (p / 2).succ).val = multiset.map (Œª (a : ‚Ñï), a) (finset.Ico 1 (p / 2).succ).val
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.limits.preserves_limits F] : category_theory.limits.preserves_colimits F.op
(R : Type u) (Œπ : Type u') [decidable_eq Œπ] [comm_semiring R] (A : Type u_1) [comm_semiring A] [algebra R A] [fintype Œπ] : multilinear_map R (Œª (i : Œπ), A) A
{R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} [comm_semiring R] [semiring A‚ÇÅ] [semiring A‚ÇÇ] [algebra R A‚ÇÅ] [algebra R A‚ÇÇ] (e : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ) : A‚ÇÅ ‚Üí‚Çê[R] A‚ÇÇ
{Œ± : Type u_1} [topological_space Œ±] {ùïú : Type u_5} [topological_space ùïú] [field ùïú] [topological_ring ùïú] {s : subalgebra ùïú C(Œ±, ùïú)} (h : s.separates_points) : ‚Üës.separates_points_strongly
{Œ± : Type u} (f : equiv.perm Œ±) {p : Œ± ‚Üí Prop} (h : ‚àÄ (x : Œ±), p x ‚Üî p (‚áëf x)) : equiv.perm {x // p x}
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (N : submonoid S) (T : Type u_4) [comm_ring T] [algebra R T] [algebra S T] [is_scalar_tower R S T] [is_localization M S] [is_localization N T] (H : ‚àÄ (x : S), is_unit x ‚Üí x ‚àà N) : is_localization (submonoid.comap (algebra_map R S).to_monoid_hom N) T
{G : Type u_1} [add_group G] (H K : add_subgroup G) : Prop
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (f : M ‚Üí* N) {g : N ‚Üí M} (h : function.left_inverse g ‚áëf) : M ‚âÉ* ‚Ü•(f.mrange)
(n : ‚Ñï) (e : expr) : tactic (list expr)
(X : Type u_1) [topological_space X] [compact_space X] [t2_space X] : Compactum
{œÑ : Type u_1} {Œ± : Type u_2} [canonically_ordered_add_monoid œÑ] {œï : œÑ ‚Üí Œ± ‚Üí Œ±} {s : set Œ±} : is_fw_invariant œï s ‚Üî is_invariant œï s
{Œ± : Type u} [pseudo_emetric_space Œ±] {s : set Œ±} : emetric.Hausdorff_edist s s = 0
{Œ± : Type u_1} [denumerable Œ±] : denumerable (finset Œ±)
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ CommRing CommSemiRing)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ùïú] [inner_product_space ùïú E] [inner_product_space ùïú F] [finite_dimensional ùïú E] [finite_dimensional ùïú F] (A : E ‚Üí‚Çó[ùïú] F) (B : F ‚Üí‚Çó[ùïú] E) : A = ‚áëlinear_map.adjoint B ‚Üî ‚àÄ (x : E) (y : F), has_inner.inner (‚áëA x) y = has_inner.inner x (‚áëB y)
(Œ± : Type u_1) : Type u_1
{Œ± : Type u_1} {Œ≤ : Type u_2} [unique Œ±] : (Œ± ‚Ü™ Œ≤) ‚âÉ Œ≤
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Top) : category_theory.limits.cocone F
 : list expr ‚Üí tactic (list expr)
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] [fintype Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) {w : Œ± ‚Üí M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hb : finset.univ.sum (Œª (x : Œ±), w x) < fintype.card Œ≤ ‚Ä¢ b) : ‚àÉ (y : Œ≤), (finset.filter (Œª (x : Œ±), f x = y) finset.univ).sum (Œª (x : Œ±), w x) < b
(p : ‚Ñï+) : Prop
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [comm_monoid Œ±] [comm_monoid Œ≤] [comm_monoid Œ≥] {A : set Œ±} {B : set Œ≤} {n : ‚Ñï} (f : B ‚Üí*[n] Œ≥) (g : A ‚Üí*[n] Œ≤) (hAB : set.maps_to ‚áëg A B) : A ‚Üí*[n] Œ≥
{R‚ÇÅ : Type u_1} [semiring R‚ÇÅ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] [has_continuous_add M‚ÇÅ] : (M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) ‚Üí+* M‚ÇÅ ‚Üí‚Çó[R‚ÇÅ] M‚ÇÅ
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x y z : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (hz : z ‚â† 0) : o.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = ‚Üëreal.pi
(R : Type u) [comm_semiring R] (p : ‚Ñï) [fact (nat.prime p)] [char_p R p] [perfect_ring R p] : R ‚âÉ+* R
{Œ± : Type u_2} {Œ≤ : Type u_3} [monoid Œ±] [add_monoid Œ≤] [distrib_mul_action Œ± Œ≤] : distrib_mul_action Œ± (filter Œ≤)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (self : C ‚•§ D) : prefunctor C D
{R : Type u_4} {S : Type u_5} [has_mul R] [has_add R] [has_mul S] [has_add S] (e : R ‚âÉ+* S) (x y : R) : ‚áëe (x + y) = ‚áëe x + ‚áëe y
{Œ± : Type u_1} (q : semiquot Œ±) (h : q.is_pure) : Œ±
(R : Type u) [comm_ring R] : Type u
(Œ± : Type u_1) (n : ‚Ñï) : Type u_1
 : turing.to_partrec.code
(args : list expr) : tactic.ring_exp.ring_exp_m expr
{Œ± : Type u} : seq Œ± ‚Üí ‚Ñï ‚Üí option Œ±
{M : Type u_3} {F : Type u_8} {G : Type u_1} [add_group G] [add_monoid M] [add_monoid_hom_class F G M] {f g : F} {x : G} (h : ‚áëf x = ‚áëg x) : ‚áëf (-x) = ‚áëg (-x)
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [semiring R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] (e : topological_vector_bundle.pretrivialization R F E) (b : B) (hb : b ‚àà e.to_fiber_bundle_pretrivialization.base_set) : E b ‚âÉ‚Çó[R] F
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_zero_object C] [category_theory.limits.has_kernel f] [category_theory.mono f] : category_theory.limits.kernel f ‚âÖ 0
{A : Type u_1} {B : Type u_2} [fintype B] [set_like A B] : fintype A
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] {l : filter Œ≤} {f‚ÇÅ f‚ÇÇ f‚ÇÉ : Œ≤ ‚Üí Œ±} (h‚ÇÅ‚ÇÇ : filter.tendsto (Œª (x : Œ≤), (f‚ÇÅ x, f‚ÇÇ x)) l (uniformity Œ±)) (h‚ÇÇ‚ÇÉ : filter.tendsto (Œª (x : Œ≤), (f‚ÇÇ x, f‚ÇÉ x)) l (uniformity Œ±)) : filter.tendsto (Œª (x : Œ≤), (f‚ÇÅ x, f‚ÇÉ x)) l (uniformity Œ±)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} [category_theory.limits.has_binary_biproduct X Y] : category_theory.limits.biprod.fst ‚â´ category_theory.limits.biprod.inl + category_theory.limits.biprod.snd ‚â´ category_theory.limits.biprod.inr = ùüô (X ‚äû Y)
{M : Type u_6} {N : Type u_7} [has_add M] [has_add N] (f : M ‚âÉ N) (h : ‚àÄ (x y : M), ‚áëf (x + y) = ‚áëf x + ‚áëf y) : M ‚âÉ+ N
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} (l : list Œπ) (t : Œ† (i : Œπ), set (Œ± i)) : set (list.tprod Œ± l)
(Œ± : Type u_1) [metric_space Œ±] (N : ‚Ñï) (œÑ : ‚Ñù) : Type u_1
(c : Type u ‚Üí Type v) : Type (max (u+1) v)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {s t : category_theory.limits.cone F} (P : category_theory.limits.is_limit s) (Q : category_theory.limits.is_limit t) : s ‚âÖ t
{C : Type u} [category_theory.category C] {X Y Z : algebraic_geometry.PresheafedSpace C} (f : X ‚ü∂ Z) [hf : algebraic_geometry.PresheafedSpace.is_open_immersion f] (g : Y ‚ü∂ Z) : category_theory.limits.is_limit (algebraic_geometry.PresheafedSpace.is_open_immersion.pullback_cone_of_left f g)
{Œì : Type u_1} [inhabited Œì] (f : Œì ‚Üí Œì) : ‚Ñï ‚Üí turing.list_blank Œì ‚Üí turing.list_blank Œì
(X : Top) : CompHaus
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] [finite_dimensional F E] (h : ‚àÄ (x : E), finite_dimensional.finrank F ‚Ü•F‚üÆx‚üØ ‚â§ 1) : ‚ä• = ‚ä§
(n : ‚Ñï) : ‚àÉ (p : ‚Ñï), n ‚â§ p ‚àß nat.prime p
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {G G' : D ‚•§ C} (iso : G ‚âÖ G') {X : C} {Y : D} : (X ‚ü∂ G.obj Y) ‚âÉ (X ‚ü∂ G'.obj Y)
{L : first_order.language} {M : Type w} [nonempty M] [L.Structure M] (S : (L.sum L.skolem‚ÇÅ).substructure M) : L.elementary_substructure M
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) (s : set Œ±) : local_homeomorph Œ± Œ≤
{Œ± : Type u} [mul_zero_class Œ±] [has_distrib_neg Œ±] : -0 = 0
{R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (r : R) (x : A) : ‚áë(algebra_map R A) r * x = x * ‚áë(algebra_map R A) r
(R : Type u) [comm_semiring R] (A : Type v) [comm_semiring A] [algebra R A] : module (set_semiring A) (submodule R A)
{Œ± : Type u_1} {c : set (set Œ±)} (hc : setoid.is_partition c) {s : set Œ±} (h : s ‚àà c) : s.nonempty
(n : ‚Ñï) : ‚Ñï
(M : Type u) [comm_monoid M] : M ‚âÉ* (multiplicative ‚Ñï ‚Üí* M)
{Œ± : Type u_3} {Œ≤ : Type u_4} (r : Œ± ‚Üí Œ≤ ‚Üí Prop) [Œ† (a : Œ±), decidable_pred (r a)] (s : finset Œ±) (t : finset Œ≤) : ‚Ñö
{C : Type u} [category_theory.category C] (A : C) [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] : category_theory.exp A ‚ãô category_theory.limits.prod.functor.obj A ‚ü∂ ùü≠ C
{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] : G.max_degree < fintype.card V
{Œ± : Type u_1} [subtraction_comm_monoid Œ±] : Œ± ‚Üí+ Œ±
(Œ± : Type u_1) [topological_space Œ±] [quasi_sober Œ±] [irreducible_space Œ±] : Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {X : C} (h : category_theory.yoneda.obj X ‚ãô category_theory.ulift_functor ‚âÖ F.cones) {Y : C} (f : Y ‚ü∂ X) : category_theory.limits.is_limit.of_nat_iso.cone_of_hom h f = (category_theory.limits.is_limit.of_nat_iso.limit_cone h).extend f
{Œ± : Type u_1} [ordered_semiring Œ±] [floor_semiring Œ±] : Œ± ‚Üí ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] [separated_space Œ±] {s : set Œ±} {f : Œ± ‚Üí Œ≤} (hs : is_compact s) (hf : continuous_on f s) : uniform_continuous_on f s
{a b c : ‚Ñ§} (h : fermat_42 a b c) : ‚àÉ (a0 b0 c0 : ‚Ñ§), fermat_42.minimal a0 b0 c0
{X : Type u_1} [topological_space X] [topological_space.first_countable_topology X] : sequential_space X
{Œ± : Type u_1} (s : set Œ±) [fintype ‚Ü•s] : finset Œ±
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M ‚Üí+ P} {T : add_submonoid P} (hy : ‚àÄ (y : ‚Ü•S), ‚áëg ‚Üëy ‚àà T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} (z : N) : ‚áë(k.to_map) (‚áëg ‚Üë((f.sec z).snd)) + ‚áë(f.map hy k) z = ‚áë(k.to_map) (‚áëg (f.sec z).fst)
(R : Type u_1) (A : Type u_2) (M : Type u_3) (N : Type u_4) (P : Type u_5) [comm_semiring R] [comm_semiring A] [algebra R A] [add_comm_monoid M] [module R M] [module A M] [is_scalar_tower R A M] [add_comm_monoid N] [module R N] [add_comm_monoid P] [module R P] [module A P] [is_scalar_tower R A P] : (M ‚Üí‚Çó[A] N ‚Üí‚Çó[R] P) ‚Üí‚Çó[A] tensor_product R M N ‚Üí‚Çó[A] P
{F : Type} [comm_semiring F] (q : ‚Ñï) (f : polynomial F) : Prop
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {F : J ‚•§ K ‚•§ C} (c : category_theory.limits.cocone F) (t : Œ† (k : K), category_theory.limits.is_colimit (((category_theory.evaluation K C).obj k).map_cocone c)) : category_theory.limits.is_colimit c
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] (F : D ‚•§ K ‚•§ C) (G : J ‚•§ D) (H : Œ† (k : K), category_theory.limits.preserves_limit G (F ‚ãô (category_theory.evaluation K C).obj k)) : category_theory.limits.preserves_limit G F
(Œπ : Type u_1) (Œ± : Type u_2) [unique Œπ] [topological_space Œ±] : (Œπ ‚Üí Œ±) ‚âÉ‚Çú Œ±
{Œ≤ : Type u_2} [comm_monoid Œ≤] {n : ‚Ñï} (f : fin (n + 1) ‚Üí Œ≤) (x : fin (n + 1)) : finset.univ.prod (Œª (i : fin (n + 1)), f i) = f x * finset.univ.prod (Œª (i : fin n), f (‚áë(x.succ_above) i))
{n : ‚Ñï} {a : cardinal} : n ‚Ä¢ a < cardinal.aleph_0 ‚Üî n = 0 ‚à® a < cardinal.aleph_0
{G : Type u_1} [add_group G] (H : add_subgroup G) : ‚Ü•H ‚âÉ ‚Ü•(H.opposite)
{Œ± : Type u} {Œπ : Sort x} {f : Œπ ‚Üí filter Œ±} [hn : nonempty Œ±] (hd : directed ge f) (hb : ‚àÄ (i : Œπ), (f i).ne_bot) : (infi f).ne_bot
(C : Type u) [category_theory.category C] : Prop
{Œ± : Type u_3} {Œ≤ : Type u_4} [linear_ordered_field Œ±] {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±} {r : Œ±} (hr : 0 < r) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (Œª (x : Œ≤), r * f x) l filter.at_bot
(pqr : multiset ‚Ñï+) : ‚Ñö
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) {r : R} (h : 0 < r) : same_ray R v (r ‚Ä¢ v)
{C : Type u} [category_theory.category C] {F G : C ‚•§ C} (Œ± : G ‚ü∂ F) : category_theory.endofunctor.algebra F ‚•§ category_theory.endofunctor.algebra G
(Œ± : Type u_8) : Type u_8
{Œπ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (c : complex_shape Œπ) : Type (max u u_1 v)
{Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚Üí Œ≤} {a : filter Œ±} {b‚ÇÅ b‚ÇÇ : filter Œ≤} (hf : filter.tendsto f a b‚ÇÅ) [a.ne_bot] (hb : disjoint b‚ÇÅ b‚ÇÇ) : ¬¨filter.tendsto f a b‚ÇÇ
{Œ± : Type u} : lazy_list (lazy_list Œ±) ‚Üí lazy_list Œ±
{Œπ : Type u‚ÇÅ} {k : Type u‚ÇÇ} {V : Type u‚ÇÉ} {P : Type u‚ÇÑ} [add_comm_group V] [add_torsor V P] [ring k] [module k V] (b : affine_basis Œπ k P) {Œπ' : Type u_1} (q : Œπ' ‚Üí P) : matrix Œπ' Œπ k
 : category_theory.limits.has_colimits_of_size (Type (max v u))
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) [category_theory.limits.has_binary_biproduct P Q] : category_theory.limits.binary_biproduct_data P Q
{S : Type u_1} [has_add S] (a : S) : add_commute a a
(ùïú : Type u) (Œπ : Type v) (G : Type wG) [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] : G ‚âÉ‚Çó·µ¢[ùïú] continuous_multilinear_map ùïú (Œª (i : Œπ), ùïú) G
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (l : Œ± ‚Üí Œ≤) (u : Œ≤ ‚Üí Œ±) : Type (max u v)
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddCommGroup) : AddGroup
{p : ‚Ñï} [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (a : kÀ£) (A : witt_vector p k) : ‚Ñï ‚Üí k
{Œ± : Sort u‚ÇÅ} {Œ≤ : Sort u‚ÇÇ} (f : Œ± ‚Üí Œ≤) : Prop
{Œ± Œ≤ : Type u_1} [i‚ÇÅ : measurable_space Œ±] [i‚ÇÇ : measurable_space Œ≤] (h : Œ± = Œ≤) (hi : i‚ÇÅ == i‚ÇÇ) : Œ± ‚âÉ·µê Œ≤
(n : ‚Ñï) : Type
{G H : AddCommGroup} (f : G ‚ü∂ H) : category_theory.limits.cokernel f ‚âÖ AddCommGroup.of (‚Ü•H ‚ß∏ add_monoid_hom.range f)
{A : Type u_2} [comm_ring A] [is_domain A] [is_dedekind_domain A] {P : ideal A} (hP : P ‚â† ‚ä•) : prime P ‚Üî P.is_prime
(R‚ÇÅ : Type u_3) [comm_ring R‚ÇÅ] {K : Type u_4} [field K] [algebra R‚ÇÅ K] [is_fraction_ring R‚ÇÅ K] {Œπ : Type u_1} (s : finset Œπ) (f : Œπ ‚Üí K) : fractional_ideal (non_zero_divisors R‚ÇÅ) K
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {b : M} [linear_ordered_comm_ring M] (hf : ‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚àà t) (ht : t.card ‚Ä¢ b < ‚Üë(s.card)) : ‚àÉ (y : Œ≤) (H : y ‚àà t), b < ‚Üë((finset.filter (Œª (x : Œ±), f x = y) s).card)
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (Œ∏ : real.angle) : ‚áëlinear_map.det ‚Üë((hb.rotation Œ∏).to_linear_equiv) = 1
{A : Type v} [ring A] {R : Type u} [comm_ring R] [algebra R A] {B : Type w} [ring B] [algebra R B] (f : A ‚Üí‚Çê[R] B) : A ‚Üí‚Çó‚ÅÖR‚ÅÜ B
 : monad filter
(t : tactic unit) : tactic unit
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M ‚Üí+ P} {T : add_submonoid P} (hy : ‚àÄ (y : ‚Ü•S), ‚áëg ‚Üëy ‚àà T) {Q : Type u_4} [add_comm_monoid Q] (k : T.localization_map Q) : N ‚Üí+ Q
{R : Type u} {S : Type v} [ring R] [ring S] (f : R ‚Üí+* S) (s : subring S) : subring R
{G : Type u_1} [add_group G] (S : set G) : add_subgroup G
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] (D : Type u‚ÇÇ) [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] : category_theory.lax_braided_functor C D ‚•§ CommMon_ C ‚•§ CommMon_ D
{Œ± : Type u} [has_neg Œ±] (as : list Œ±) : list Œ±
(p : ‚Ñï) [fact (nat.prime p)] (a : (zmod p)À£) : a ^ (p - 1) = 1
(at_ : interactive.parse interactive.types.location) (names : interactive.parse interactive.types.with_ident_list) : tactic unit
{X : Type u_1} {Y : Type u_2} {Z : Type u_3} [topological_space X] (f : Y ‚Üí Z) : locally_constant X Y ‚Üí locally_constant X Z
 : turing.to_partrec.code ‚Üí turing.partrec_to_TM2.cont' ‚Üí finset turing.partrec_to_TM2.Œõ'
(m n : ‚Ñï) : Type
{Œ± : Type u_2} {Œ≤ : Type u_3} [add_comm_monoid Œ±] [add_comm_monoid Œ≤] {n : ‚Ñï} : add_freiman_hom_class (Œ± ‚Üí+ Œ≤) set.univ Œ≤ n
{Œ± : Type u} {l : list Œ±} : l.nodup ‚Üí l.sublists.nodup
{p : ‚Ñï} [fact (nat.prime p)] (seq : ‚Ñï ‚Üí ‚Ñ§) (h : is_cau_seq (padic_norm p) (Œª (n : ‚Ñï), ‚Üë(seq n))) : ‚Ñ§_[p]
(R : CommRing) (M : submonoid ‚Ü•R) (x : prime_spectrum (localization M)) : category_theory.is_iso (algebraic_geometry.PresheafedSpace.stalk_map (algebraic_geometry.Spec.to_PresheafedSpace.map (CommRing.of_hom (algebra_map ‚Ü•R (localization M))).op) x)
 : filter.tendsto real.exp (nhds 0) (nhds 1)
{M : Type u_1} [monoid M] {Œ≥ : Type u_2} [monoid Œ≥] {f : M ‚Üí Œ≥} (hf : is_monoid_hom f) : is_submonoid (set.range f)
{Œ± : Type u_1} (V : set (Œ± √ó Œ±)) : Prop
{Œ± : Type u_1} (a : Œ±) : generalized_continued_fraction Œ±
{n : ‚Ñï} (x y : bitvec n) : bool
 : list expr ‚Üí expr ‚Üí tactic expr
{Œ± : Type u_1} {M : Type u_5} {G : Type u_9} [monoid G] [mul_action G Œ±] [add_comm_monoid M] : has_scalar G (Œ± ‚Üí‚ÇÄ M)
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b c : Œ±} : b ‚â§ -a + c ‚Üí a + b ‚â§ c
(Œ± : Type u_1) [preorder Œ±] {Œ≤ : Type u_2} [preorder Œ≤] : Œ≤ ‚Üío Œ± ‚Üío Œ≤
{f : nat.partrec.code ‚Üí nat.partrec.code} (hf : computable f) : ‚àÉ (c : nat.partrec.code), (f c).eval = c.eval
{R : Type u} [non_assoc_semiring R] : has_inf (subsemiring R)
(Œ± : Type u_1) [bornology Œ±] : Born
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {f : E ‚Üí ùïú} {g : E ‚Üí F} (hf : cont_diff ùïú n f) (hg : cont_diff ùïú n g) : cont_diff ùïú n (Œª (x : E), f x ‚Ä¢ g x)
{Œ≥ : Type u_1} {Œ≤ : Type u_2} (f : Œ≥ ‚Üí Œ≤) (hf : function.injective f) (m : metric_space Œ≤) : metric_space Œ≥
{R : Type u} [ring R] {M N : Module R} (f : M ‚ü∂ N) (hf : category_theory.epi f) : category_theory.normal_epi f
{M : Type u_1} {N : Type u_2} [monoid M] [monoid N] {s : set M} (f : M ‚Üí N) (hs : submonoid.closure s = ‚ä§) (h1 : f 1 = 1) (hmul : ‚àÄ (x y : M), y ‚àà s ‚Üí f (x * y) = f x * f y) : M ‚Üí* N
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s t : set Œ±} (sne : s.nonempty) (tne : t.nonempty) (hst : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà t ‚Üí x ‚â§ y) : (upper_bounds s ‚à© lower_bounds t).nonempty
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} (t : category_theory.limits.fork f g) (create : Œ† (s : category_theory.limits.fork f g), {l // l ‚â´ t.Œπ = s.Œπ ‚àß ‚àÄ {m : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero ‚ü∂ ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj t.X).obj category_theory.limits.walking_parallel_pair.zero}, m ‚â´ t.Œπ = s.Œπ ‚Üí m = l}) : category_theory.limits.is_limit t
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [category_theory.is_iso f] : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone_of_left_iso f g)
(Œ± : Type u) : Type u
{r : nnreal} : ‚ä§ - ‚Üër = ‚ä§
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {F : C ‚•§ D} {t : category_theory.limits.cone K} (h : category_theory.limits.is_limit t) (hF : category_theory.limits.is_limit (F.map_cone t)) : category_theory.limits.preserves_limit K F
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] {œÉS : Type u_2} [set_like œÉS S] [subsemiring_class œÉS S] (f : R ‚Üí+* S) (s : œÉS) (h : ‚àÄ (x : R), ‚áëf x ‚àà s) : R ‚Üí+* ‚Ü•s
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] {X : C} {P : C·µí·µñ ‚•§ D} {S T : J.cover X} (x : category_theory.meq P T) (e : S ‚ü∂ T) : category_theory.meq P S
{Œ± : Type u_1} [decidable_eq Œ±] {a : Œ±} {z : sym2 Œ±} (h : a ‚àà z) : Œ±
{V : Type u} [category_theory.category V] [category_theory.limits.has_images V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_kernels V] {A B C : V} (f : A ‚ü∂ B) (g : B ‚ü∂ C) : Prop
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M] : ¬¨is_smul_regular M 0
 : Type 1
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] [decidable_rel disjoint] [decidable_rel has_le.le] {s : finset Œ±} {u v a : Œ±} (ha : a ‚àà uv.compression u v s) (hva : v ‚â§ a) (hua : disjoint u a) : (a ‚äî u)  v ‚àà s
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} (t : category_theory.limits.pullback_cone f g) (create : Œ† (s : category_theory.limits.pullback_cone f g), {l // l ‚â´ t.fst = s.fst ‚àß l ‚â´ t.snd = s.snd ‚àß ‚àÄ {m : s.X ‚ü∂ t.X}, m ‚â´ t.fst = s.fst ‚Üí m ‚â´ t.snd = s.snd ‚Üí m = l}) : category_theory.limits.is_limit t
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] : pseudo_emetric_space (Œ± √ó Œ≤)
 : expr ‚Üí expr ‚Üí tactic expr
{G H : AddCommGroup} (f : G ‚ü∂ H) : category_theory.over.mk (category_theory.limits.kernel.Œπ f) ‚âÖ category_theory.over.mk (add_monoid_hom.ker f).subtype
{M : Type u_2} (R : Type u_5) [semiring R] [add_comm_monoid M] [module R M] {Œ± : Type u_1} {Œ≤ : Type u_3} : (Œ± ‚äï Œ≤ ‚Üí‚ÇÄ M) ‚âÉ‚Çó[R] (Œ± ‚Üí‚ÇÄ M) √ó (Œ≤ ‚Üí‚ÇÄ M)
{Œ± : Type u} [has_subset Œ±] {a b : Œ±} [is_antisymm Œ± has_subset.subset] (h : a ‚äÜ b) (h' : b ‚äÜ a) : a = b
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p1 p2 : P} (hp1 : p1 ‚àà s) (hp2 : p2 ‚àà s) : p1 -·µ• p2 ‚àà s.direction
 : nzsnum ‚Üí snum
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) : o.oangle y x = -o.oangle x y
(R : Type u) {n : ‚Ñï} (M : fin n.succ ‚Üí Type v) (M‚ÇÇ : Type v‚ÇÇ) [comm_semiring R] [Œ† (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : fin n.succ), module R (M i)] [module R M‚ÇÇ] : (M 0 ‚Üí‚Çó[R] multilinear_map R (Œª (i : fin n), M i.succ) M‚ÇÇ) ‚âÉ‚Çó[R] multilinear_map R M M‚ÇÇ
{J : Type u‚ÇÅ} [category_theory.category J] [nonempty J] (h : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), category_theory.zigzag j‚ÇÅ j‚ÇÇ) : category_theory.is_connected J
{p : ‚Ñï} {G : Type u_1} [group G] (hG : is_p_group p G) [hp : fact (nat.prime p)] (Œ± : Type u_2) [mul_action G Œ±] [fintype Œ±] [fintype ‚Ü•(mul_action.fixed_points G Œ±)] (hpŒ± : p ‚à£ fintype.card Œ±) {a : Œ±} (ha : a ‚àà mul_action.fixed_points G Œ±) : ‚àÉ (b : Œ±), b ‚àà mul_action.fixed_points G Œ± ‚àß a ‚â† b
(x : ‚Ñù) : Prop
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) : o.oangle (-x) y = o.oangle x y + ‚Üëreal.pi
{T : Type u‚ÇÅ} [category_theory.category T] {X : T} (f : category_theory.over X) : category_theory.over f ‚âå category_theory.over f.left
{Œ± : Type u_1} [complete_lattice Œ±] : Sup_hom Œ± (upper_set Œ±)·µí·µà
{M : Type u_1} [ordered_cancel_add_comm_monoid M] {A : Type u_2} [set_like A M] [add_submonoid_class A M] (S : A) : ordered_cancel_add_comm_monoid ‚Ü•S
{G : Type u_1} [semi_normed_group G] {H : Type u_2} [semi_normed_group H] : normed_group_hom G H ‚Üí+ normed_group_hom (uniform_space.completion G) (uniform_space.completion H)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} {p : Œπ ‚Üí P} (ha : affine_independent k (Œª (x : ‚Ü•(set.range p)), ‚Üëx)) (hi : function.injective p) : affine_independent k p
{Œ±‚ÇÅ : Type u_1} {Œ≤‚ÇÅ : Type u_2} {Œ±‚ÇÇ : Type u_3} {Œ≤‚ÇÇ : Type u_4} (e‚ÇÅ : Œ±‚ÇÅ ‚âÉ Œ±‚ÇÇ) (e‚ÇÇ : Œ≤‚ÇÅ ‚âÉ Œ≤‚ÇÇ) : Œ±‚ÇÅ √ó Œ≤‚ÇÅ ‚âÉ Œ±‚ÇÇ √ó Œ≤‚ÇÇ
{S : Type u‚ÇÅ} {L : Type u‚ÇÇ} (D : Type u‚ÇÉ) [category_theory.category S] [category_theory.category L] [category_theory.category D] (Œπ : S ‚•§ L) [‚àÄ (X : L), category_theory.limits.has_limits_of_shape (category_theory.structured_arrow X Œπ) D] : (category_theory.whiskering_left S L D).obj Œπ ‚ä£ category_theory.Ran Œπ
(env : environment) (src tgt : name) (prio : ‚Ñï) : tactic unit
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y Z X' Y' Z' : C} (f : X ‚ü∂ Y) [category_theory.limits.has_cokernel f] (g : Y ‚ü∂ Z) (w : f ‚â´ g = 0) (f' : X' ‚ü∂ Y') [category_theory.limits.has_cokernel f'] (g' : Y' ‚ü∂ Z') (w' : f' ‚â´ g' = 0) (p : X ‚ü∂ X') (q : Y ‚ü∂ Y') (r : Z ‚ü∂ Z') (h‚ÇÅ : f ‚â´ q = p ‚â´ f') (h‚ÇÇ : g ‚â´ r = q ‚â´ g') : category_theory.limits.cokernel.map f f' p q h‚ÇÅ ‚â´ category_theory.limits.cokernel.desc f' g' w' = category_theory.limits.cokernel.desc f g w ‚â´ r
{Œ± : Type u_2} [add_monoid Œ±] (m : Œ±) : even m ‚Üí (‚àÉ (c : Œ±), m = 2 ‚Ä¢ c)
(R : Type u) [non_assoc_ring R] (p : ‚Ñï) [hc : char_p R p] [fintype R] : p ‚â† 0
 : Type u ‚•§ Top
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : subfield L) (algebra_map_mem : ‚àÄ (x : K), ‚áë(algebra_map K L) x ‚àà S) : intermediate_field K L
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (f : G ‚Üí+ N) (H : add_subgroup G) : add_subgroup N
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} [comm_ring R] [lie_ring L‚ÇÅ] [lie_algebra R L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÇ] (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) (g : L‚ÇÇ ‚Üí L‚ÇÅ) (h‚ÇÅ : function.left_inverse g ‚áëf) (h‚ÇÇ : function.right_inverse g ‚áëf) : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÅ
(R : Type u) [ring R] [strong_rank_condition R] {Œπ : Type v} (M : Œπ ‚Üí Type w) [Œ† (i : Œπ), add_comm_group (M i)] [Œ† (i : Œπ), module R (M i)] [‚àÄ (i : Œπ), module.free R (M i)] : module.rank R (direct_sum Œπ (Œª (i : Œπ), M i)) = cardinal.sum (Œª (i : Œπ), module.rank R (M i))
{G : Type w} [topological_space G] : has_coe_to_fun (measure_theory.content G) (Œª (_x : measure_theory.content G), topological_space.compacts G ‚Üí ennreal)
{M : Type u_1} [comm_monoid M] (S : submonoid M) : Type u_1
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ : X} {p‚ÇÄ p‚ÇÅ p‚ÇÇ : path x‚ÇÄ x‚ÇÅ} (F : p‚ÇÄ.homotopy p‚ÇÅ) (G : p‚ÇÅ.homotopy p‚ÇÇ) : p‚ÇÄ.homotopy p‚ÇÇ
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : finset P} {p : P} (hp : p ‚àà s) : vector_span k ‚Üës = submodule.span k ‚Üë(finset.image (Œª (_x : P), _x -·µ• p) (s.erase p))
(R : Type u) [semiring R] : SemiRing
(R : Type u) {A : Type w} [comm_ring R] [semiring A] [algebra R A] : ring A
(R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] (N : Type v) [add_comm_group N] [module R N] [module.free R N] : module.rank R (M √ó N) = module.rank R M + module.rank R N
(Œ≥ : Type u) : W_type (W_type.list_Œ≤ Œ≥) ‚âÉ list Œ≥
{R : Type u_1} [monoid_with_zero R] {f : nat.arithmetic_function R} : f.is_multiplicative ‚Üî ‚áëf 1 = 1 ‚àß ‚àÄ {m n : ‚Ñï}, m ‚â† 0 ‚Üí n ‚â† 0 ‚Üí m.coprime n ‚Üí ‚áëf (m * n) = ‚áëf m * ‚áëf n
{X Y : Top} {f : X ‚ü∂ Y} (h : is_open_map ‚áëf) (x : ‚Ü•X) : h.functor_nhds x ‚ä£ topological_space.open_nhds.map f x
{X Y : Type u} [has_add X] [has_add Y] : X ‚âÉ+ Y ‚âÖ AddMagma.of X ‚âÖ AddMagma.of Y
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (c : con M) (f : M ‚Üí* P) (H : c ‚â§ con.ker f) (h : function.injective ‚áë(c.lift f H)) : con.ker f = c
{n : ‚Ñï} {E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {f : (fin (n + 1) ‚Üí ‚ÑÇ) ‚Üí E} {c : fin (n + 1) ‚Üí ‚ÑÇ} {R : fin (n + 1) ‚Üí ‚Ñù} (hf : torus_integrable f c R) (i : fin (n + 1)) : ‚àØ (x : fin (n + 1) ‚Üí ‚ÑÇ) in T(c, R), f x = ‚àÆ (x : ‚ÑÇ) in C(c i, R i), ‚àØ (y : fin n ‚Üí ‚ÑÇ) in T(c ‚àò ‚áë(i.succ_above), R ‚àò ‚áë(i.succ_above)), f (i.insert_nth x y)
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {ùïú‚ÇÉ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [nondiscrete_normed_field ùïú‚ÇÉ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] [normed_space ùïú‚ÇÉ G] {œÉ‚ÇÇ‚ÇÉ : ùïú‚ÇÇ ‚Üí+* ùïú‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : ùïú ‚Üí+* ùïú‚ÇÉ} [ring_hom_isometric œÉ‚ÇÇ‚ÇÉ] [ring_hom_isometric œÉ‚ÇÅ‚ÇÉ] (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] G
{P : ‚Ñ§ ‚Üí Prop} {m : ‚Ñ§} (h0 : P m) (h1 : ‚àÄ (n : ‚Ñ§), n ‚â§ m ‚Üí P n ‚Üí P (n - 1)) (n : ‚Ñ§) : n ‚â§ m ‚Üí P n
(B : Type u) : Type u
(f : cau_seq ‚Ñö has_abs.abs) : ‚Ñï ‚Üí ‚Ñö
{Œ± : Type u} [has_subset Œ±] [has_ssubset Œ±] [is_nonstrict_strict_order Œ± has_subset.subset has_ssubset.ssubset] {a b : Œ±} (h : a ‚äÇ b) : ¬¨b ‚äÜ a
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] {C : Type u} [category_theory.category C] (F : J ‚•§ K ‚•§ C) [category_theory.limits.has_limits_of_shape K C] : category_theory.limits.diagram_of_cones F
(l : list ‚Ñö) : tactic unit
(e : expr) : expr_set
(M : Type u_1) [cancel_monoid_with_zero M] [decidable_eq M] [fintype M] [nontrivial M] : group_with_zero M
(s : ‚Ñù) : (Œª (x : ‚Ñù), x ^ s) =o[filter.at_top] real.exp
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : filter Œπ} {s : set Œ±} : tendsto_uniformly_on F f p s ‚Üî filter.tendsto (Œª (q : Œπ √ó Œ±), (f q.snd, F q.fst q.snd)) (p.prod (filter.principal s)) (uniformity Œ≤)
{R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] [is_localization M S] (z : S) : z * ‚áë(algebra_map R S) ‚Üë((is_localization.sec M z).snd) = ‚áë(algebra_map R S) (is_localization.sec M z).fst
{X : Type u_2} [emetric_space X] [topological_space.second_countable_topology X] (s : set X) : (‚®Ü (x : X) (H : x ‚àà s), (nhds_within x s).small_sets.limsup dimH) = dimH s
{R : Type u} {a : R} [semiring R] {p : polynomial R} (h : a * p.leading_coeff ‚â† 0) : (‚áëpolynomial.C a * p).nat_degree = p.nat_degree
 : expr ‚Üí option ‚Ñ§
 : tactic.explode.thm ‚Üí tactic (list (widget.html empty))
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± : D·µí·µñ ‚•§ A} {‚Ñ±' : category_theory.Sheaf K A} : (G.op ‚ãô ‚Ñ± ‚ü∂ G.op ‚ãô ‚Ñ±'.val) ‚âÉ (‚Ñ± ‚ü∂ ‚Ñ±'.val)
(e : expr) : list expr
{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] : has_one (one_hom M N)
{Œ± : Type u} (a : Œ±) : ordnode Œ±
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] (f : equiv.perm Œ±) {x : Œ±} : (f.cycle_of x).is_cycle ‚Üî ‚áëf x ‚â† x
{Œ± : Type u} (s : set Œ±) (h : s.infinite) : ‚Ñï ‚Ü™ ‚Ü•s
{G : Type u_1} {H : Type u_2} [group G] [group H] [is_cyclic H] (f : G ‚Üí* H) (hf : f.ker ‚â§ subgroup.center G) : comm_group G
{R : Type u_1} [semiring R] : polynomial R ‚Üí+* laurent_polynomial R
(s : set ‚Ñï) [decidable_pred (Œª (_x : ‚Ñï), _x ‚àà s)] [infinite ‚Ü•s] : ‚Ñï ‚Üí ‚Ü•s
{Œ± : Type u_2} [preorder Œ±] (p : Œ± ‚Üí Prop) : subtype p ‚Üío Œ±
 : parser char
{G : Type u_10} {H : Type u_11} [mul_one_class G] [add_zero_class H] : G ‚âÉ* multiplicative H ‚âÉ (additive G ‚âÉ+ H)
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type x} [decidable_eq Œ≥] (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (s : set Œ±) (t : set Œ≤) [hs : fintype ‚Ü•s] [ht : fintype ‚Ü•t] : fintype ‚Ü•(set.image2 f s t)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [linear_ordered_add_comm_group Œ±] [order_topology Œ±] {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±} {C : Œ±} (hf : filter.tendsto f l filter.at_bot) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (Œª (x : Œ≤), f x + g x) l filter.at_bot
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [linear_ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : concave_on ùïú s f) {x y : E} (hx : x ‚àà s) (hy : y ‚àà s) {a b : ùïú} (ha : 0 ‚â§ a) (hb : 0 ‚â§ b) (hab : a + b = 1) : linear_order.min (f x) (f y) ‚â§ f (a ‚Ä¢ x + b ‚Ä¢ y)
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} : P.obj (Œ± ::: P.W Œ±) ‚Üí P.W Œ±
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] [complete_space Œ≤] : complete_space (bounded_continuous_function Œ± Œ≤)
(R : Type u_1) [rack R] (G : Type u_2) [group G] (f : shelf_hom R (quandle.conj G)) (g : rack.envel_group R ‚Üí* G) (h : f = (quandle.conj.map g).comp (rack.to_envel_group R)) : g = ‚áërack.to_envel_group.map f
{Œπa : Type u_7} {Œπb : Type u_8} [decidable_eq Œπa] [decidable_eq Œπb] [fintype Œπa] [fintype Œπb] {R' : Type u_9} {M·µ¢ : Type u_10} {N‚ÇÅ : Type u_11} {N‚ÇÇ : Type u_12} [comm_semiring R'] [add_comm_group N‚ÇÅ] [module R' N‚ÇÅ] [add_comm_group N‚ÇÇ] [module R' N‚ÇÇ] [add_comm_monoid M·µ¢] [module R' M·µ¢] : tensor_product R' (alternating_map R' M·µ¢ N‚ÇÅ Œπa) (alternating_map R' M·µ¢ N‚ÇÇ Œπb) ‚Üí‚Çó[R'] alternating_map R' M·µ¢ (tensor_product R' N‚ÇÅ N‚ÇÇ) (Œπa ‚äï Œπb)
(Œì : Type u_1) (R : Type u_2) [linear_ordered_add_comm_group Œì] [ring R] [is_domain R] : add_valuation (hahn_series Œì R) (with_top Œì)
{K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero 2] {k : ‚Ñï} (hk : 2 ‚â§ k) [is_cyclotomic_extension {2 ^ k} K L] (hirr : irreducible (polynomial.cyclotomic (2 ^ k) K)) : ‚áë(algebra.norm K) (is_cyclotomic_extension.zeta (2 ^ k) K L - 1) = 2
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [ring R] [add_comm_group M] [module R M] (v : basis Œπ R M) {w : Œπ ‚Üí R} (hw : ‚àÄ (i : Œπ), is_unit (w i)) : basis Œπ R M
{Œ≤ : Type v} [has_zero Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_scalar ‚Ñï Œ≤] {Œ± : Type u} [non_unital_non_assoc_semiring Œ±] (f : Œ± ‚Üí Œ≤) (hf : function.surjective f) (zero : f 0 = 0) (add : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ±) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_unital_non_assoc_semiring Œ≤
{Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) : Z.total_space ‚Üí B
{Œπ : Type u_1} {Z : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), ordered_comm_monoid (Z i)] : ordered_comm_monoid (Œ† (i : Œπ), Z i)
(env : environment) (n : name) (levels : list name) (num_params : ‚Ñï) (type : expr) (intros : list (name √ó expr)) (is_meta : bool) : exceptional environment
{Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) : is_add_group_hom f
(P L : Type u) [has_mem P L] : Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {g : F ‚Üí G} {f : E ‚Üí F} (hg : cont_diff ùïú n g) (hf : cont_diff ùïú n f) : cont_diff ùïú n (g ‚àò f)
{n : ‚Ñï} (Œ± : typevec n) {Œ≤ : Type u_1} (p : Œ≤ ‚Üí Prop) : (Œ± ::: Œ≤).arrow (typevec.repeat (n + 1) Prop)
{k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k ‚Üí E} {a b r : k} (hab : a < b) (h‚ÇÄ : 0 < r) (h‚ÇÅ : r < 1) : ‚áë(affine_map.line_map (f a) (f b)) r ‚â§ f (‚áë(affine_map.line_map a b) r) ‚Üî slope f (‚áë(affine_map.line_map a b) r) b ‚â§ slope f a (‚áë(affine_map.line_map a b) r)
 : path {down := 0} {down := 1}
(Œ± : Type u_1) [has_mul Œ±] : has_scalar Œ± Œ±
{X : Top} (F : Top.presheaf (Type v) X) (Fsh : F.is_sheaf_unique_gluing) : F.is_sheaf
{œÉ‚ÇÅ : Type u_1} {œÉ‚ÇÇ : Type u_2} (f‚ÇÇ : œÉ‚ÇÇ ‚Üí option œÉ‚ÇÇ) (tr : œÉ‚ÇÅ ‚Üí œÉ‚ÇÇ) (a‚ÇÇ : œÉ‚ÇÇ) : option œÉ‚ÇÅ ‚Üí Prop
{ùïú : Type u_3} [is_R_or_C ùïú] {n m : ‚Ñï} (A B : matrix (fin n) (fin m) ùïú) (i j : fin n) : has_inner.inner (A i) (B j) = B.mul A.conj_transpose j i
(a : ennreal) : ‚Ñù
(P : Type u_2) [preorder P] : Type u_2
 : turing.to_partrec.cfg ‚Üí turing.to_partrec.cont ‚Üí turing.to_partrec.cfg
(p : interactive.parse (lean.parser.many lean.parser.ident)) : tactic unit
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] {X Y : C} (F : C ‚•§ D) [F.preserves_zero_morphisms] [category_theory.limits.preserves_binary_biproduct X Y F] {b : category_theory.limits.binary_bicone X Y} (hb : b.is_bilimit) : (F.map_binary_bicone b).is_bilimit
{M : Type u_1} [add_zero_class M] {s : set M} {p : M ‚Üí M ‚Üí Prop} {x y : M} (hx : x ‚àà add_submonoid.closure s) (hy : y ‚àà add_submonoid.closure s) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí ‚àÄ (y : M), y ‚àà s ‚Üí p x y) (H1_left : ‚àÄ (x : M), p 0 x) (H1_right : ‚àÄ (x : M), p x 0) (Hmul_left : ‚àÄ (x y z : M), p x z ‚Üí p y z ‚Üí p (x + y) z) (Hmul_right : ‚àÄ (x y z : M), p z x ‚Üí p z y ‚Üí p z (x + y)) : p x y
(hs : interactive.parse tactic.simp_arg_list) (l : interactive.parse interactive.types.location) : tactic unit
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type u_1} [fintype Œπ] (b : Œπ ‚Üí V) (span_eq : submodule.span K (set.range b) = ‚ä§) (card_eq : fintype.card Œπ = finite_dimensional.finrank K V) : basis Œπ K V
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u‚ÇÅ v‚ÇÅ)
{X : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) [H : compact_space ‚Ü•(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)] : X.open_cover
(Œ± : Type u_2) : Type u_2
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} {Œπ : Type v} [hŒπ : nonempty Œπ] (hs : is_compact s) (U : Œπ ‚Üí set Œ±) (hUo : ‚àÄ (i : Œπ), is_open (U i)) (hsU : s ‚äÜ ‚ãÉ (i : Œπ), U i) (hdU : directed has_subset.subset U) : ‚àÉ (i : Œπ), s ‚äÜ U i
{Œ± : Type u_1} [uniform_space Œ±] : (uniformity Œ±).has_basis (Œª (s : set (Œ± √ó Œ±)), s ‚àà uniformity Œ± ‚àß symmetric_rel s) id
(Œ≥ : Type u) : W_type.list_Œ± Œ≥ ‚âÉ punit ‚äï Œ≥
(R : Type u) : Type u
{ùïú : Type u_1} {E : Type u_3} [ordered_semiring ùïú] [topological_space E] [add_comm_group E] [module ùïú E] [has_continuous_add E] {s : set E} (hs : strict_convex ùïú s) (x : E) : strict_convex ùïú (x +·µ• s)
{Œ± : Type} (p : lean.parser Œ±) : lean.parser Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b c d p : P} (h : euclidean_geometry.cospherical {a, b, c, d}) (hapc : euclidean_geometry.angle a p c = real.pi) (hbpd : euclidean_geometry.angle b p d = real.pi) : has_dist.dist a b * has_dist.dist c d + has_dist.dist b c * has_dist.dist d a = has_dist.dist a c * has_dist.dist b d
{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ‚Ñï} (hb : 1 < b) {x : ‚Ñ§} {r : R} (hr : 0 < r) : r < ‚Üëb ^ x ‚Üî int.log b r < x
{Œ± : Type u_1} [topological_space Œ±] [polish_space Œ±] [measurable_space Œ±] [borel_space Œ±] {s : set Œ±} (hs : measurable_set s) : polish_space.is_clopenable s
 : cc_state ‚Üí expr ‚Üí tactic cc_state
{Œ± : Type u} {p : Œ± ‚Üí Prop} (h : ‚àÄ (x : Œ±), p x) : subtype p ‚âÉ Œ±
{Œ± : Type u} {Œ≤ : Type v} : Œ± ‚äï Œ≤ ‚Üí option Œ±
(ùïú : Type u) {Œπ : Type v} (E : Œπ ‚Üí Type wE) (G : Type wG) (G' : Type wG') [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] : (G ‚ÜíL[ùïú] G') ‚ÜíL[ùïú] continuous_multilinear_map ùïú E G ‚ÜíL[ùïú] continuous_multilinear_map ùïú E G'
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Œπ ‚Üí M} [ring R] [add_comm_group M] [module R M] {hli : linear_independent R v} {hsp : submodule.span R (set.range v) = ‚ä§} {i j : Œπ} : ‚áë((basis.mk hli hsp).coord i) (v j) = ite (j = i) 1 0
{p n : ‚Ñï} (h_pos : 0 < ‚áë(n.central_binom.factorization) p) : p ‚â§ 2 * n
{n m : ‚Ñï} (i : fin m) (h : i.val < n) : fin n
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {R : ‚Ñù} {c w : ‚ÑÇ} {f : ‚ÑÇ ‚Üí E} {s : set ‚ÑÇ} (hs : s.countable) (hw : w ‚àà metric.ball c R) (hc : continuous_on f (metric.closed_ball c R)) (hd : ‚àÄ (x : ‚ÑÇ), x ‚àà metric.ball c R  s ‚Üí differentiable_at ‚ÑÇ f x) : (2 * ‚Üëreal.pi * complex.I)‚Åª¬π ‚Ä¢ ‚àÆ (z : ‚ÑÇ) in C(c, R), (z - w)‚Åª¬π ‚Ä¢ f z = f w
{Œ± : Type u_1} : ordnode Œ± ‚Üí Œ± ‚Üí ordnode Œ± ‚Üí ordnode Œ±
(ùïú : Type u_5) (ùïú' : Type u_6) [normed_field ùïú] [semi_normed_ring ùïú'] : Type (max u_5 u_6)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [linear_order Œ≤] [succ_order Œ≤] [is_succ_archimedean Œ≤] {s : Œ≤ ‚Üí set Œ±} {t : set Œ≤} (hnt : t.nonempty) (ht : t.ord_connected) (H : ‚àÄ (n : Œ≤), n ‚àà t ‚Üí is_connected (s n)) (K : ‚àÄ (n : Œ≤), n ‚àà t ‚Üí order.succ n ‚àà t ‚Üí (s n ‚à© s (order.succ n)).nonempty) : is_connected (‚ãÉ (n : Œ≤) (H : n ‚àà t), s n)
{Œ± : Sort u} {r r' : Œ± ‚Üí Œ± ‚Üí Prop} (eq : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±), r a‚ÇÅ a‚ÇÇ ‚Üî r' a‚ÇÅ a‚ÇÇ) : quot r ‚âÉ quot r'
{R : Type v} [comm_ring R] (A : matrix (fin 2) (fin 2) R) : A.det = A 0 0 * A 1 1 - A 0 1 * A 1 0
(Œ± : Type u_1) : Type u_1
{T : Type u‚ÇÅ} [category_theory.category T] {D : Type u‚ÇÇ} [category_theory.category D] {X : T} (F : T ‚•§ D) : category_theory.under X ‚•§ category_theory.under (F.obj X)
{Œ± : Type u_1} [topological_space Œ±] : inhabited (topological_space.compacts Œ±)
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : Type (max u v)
(n : Type u_3) (Œ± : Type v) [non_assoc_semiring Œ±] [fintype n] [decidable_eq n] : (n ‚Üí Œ±) ‚Üí+* matrix n n Œ±
 : box_integral.integration_params ‚âÉo bool √ó bool·µí·µà √ó bool·µí·µà
(R : Type u_3) (M : Type u_4) [add_comm_monoid M] [semiring R] [module R M] (tR : add_monoid.is_torsion R) : add_monoid.is_torsion M
(R : Type u) (A : Type v) (B : Type w) [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B] : A √ó B ‚Üí‚Çô‚Çê[R] B
{Œ± : Type u} [topological_space Œ±] {p : Œ± ‚Üí Prop} {a : Œ±} (h : ‚àÄ·∂† (y : Œ±) in nhds a, p y) : p a
{G : Type u_1} [group G] (h : group.is_nilpotent (G ‚ß∏ subgroup.center G)) : group.is_nilpotent G
{R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) : lie_subalgebra R L
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) : category_theory.comonad D
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} {m : measurable_space Œ±} [topological_space Œ≤] [preorder Œπ] [measurable_space Œπ] (f : measure_theory.filtration Œπ m) (u : Œπ ‚Üí Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u_2} {Œ≤ : Type u_3} [monoid Œ±] [monoid Œ≤] [mul_distrib_mul_action Œ± Œ≤] : mul_distrib_mul_action Œ± (set Œ≤)
 : gaussian_int ‚Üí+* ‚ÑÇ
{G : Type u_1} [hG : group G] [hf : fintype G] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G
 : tactic.rcases_patt ‚Üí tactic.rcases_patt ‚Üí tactic.rcases_patt
{Œ± : Type u} {n m : ‚Ñï} [has_repr Œ±] : has_repr (matrix (fin m) (fin n) Œ±)
{R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] : exterior_algebra R M ‚Üí‚Çó[R] M
{P : Type u_2} [metric_space P] (p : P) : euclidean_geometry.cospherical {p}
{Œ± : Type u_1} [ordered_cancel_comm_monoid Œ±] {s t : set Œ±} (hs : s.is_pwo) (ht : t.is_pwo) (a : Œ±) : finset (Œ± √ó Œ±)
(p : omega.int.preform) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (S : category_theory.presieve X) : category_theory.limits.cocone S.diagram
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : (generalized_continued_fraction.of v).terminates ‚Üî ‚àÉ (q : ‚Ñö), v = ‚Üëq
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÉ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÑ : X‚ÇÉ ‚ü∂ Y‚ÇÇ) [category_theory.limits.has_pullback f‚ÇÅ f‚ÇÇ] [category_theory.limits.has_pullback f‚ÇÉ f‚ÇÑ] [category_theory.limits.has_pullback (category_theory.limits.pullback.snd ‚â´ f‚ÇÉ) f‚ÇÑ] [category_theory.limits.has_pullback f‚ÇÅ (category_theory.limits.pullback.fst ‚â´ f‚ÇÇ)] : category_theory.limits.pullback (category_theory.limits.pullback.snd ‚â´ f‚ÇÉ) f‚ÇÑ ‚âÖ category_theory.limits.pullback f‚ÇÅ (category_theory.limits.pullback.fst ‚â´ f‚ÇÇ)
{R : Type u} [ring R] {J : Type w} [category_theory.category J] (F : J ‚•§ Module R) (j : J) (x : ‚Ü•(F.obj j)) : Module.colimits.colimit_type F
{E : Type u_1} {PE : Type u_2} [normed_group E] [normed_space ‚Ñù E] [metric_space PE] [normed_add_torsor E PE] {x y : PE} (e : PE ‚âÉ·µ¢ PE) : ‚áëe x = x ‚Üí ‚áëe y = y ‚Üí ‚áëe (midpoint ‚Ñù x y) = midpoint ‚Ñù x y
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] (f g : L.hom M N) : L.substructure M
(S T : set ‚Ñï+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [h : is_cyclotomic_extension T A B] (hS : S ‚äÜ T) : is_cyclotomic_extension S A ‚Ü•(algebra.adjoin A {b : B | ‚àÉ (a : ‚Ñï+), a ‚àà S ‚àß b ^ ‚Üëa = 1})
{M : Type u_1} [add_monoid M] (s : set M) : set M
{R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a) : is_smul_regular M a
{J : Type v} [category_theory.small_category J] {A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] {L : A ‚•§ T} {R : B ‚•§ T} (F : J ‚•§ category_theory.comma L R) [category_theory.limits.preserves_colimit (F ‚ãô category_theory.comma.fst L R) L] {c‚ÇÅ : category_theory.limits.cocone (F ‚ãô category_theory.comma.fst L R)} (t‚ÇÅ : category_theory.limits.is_colimit c‚ÇÅ) (c‚ÇÇ : category_theory.limits.cocone (F ‚ãô category_theory.comma.snd L R)) : category_theory.limits.cocone F
(s t : tactic.unify_equations.unification_step) : tactic.unify_equations.unification_step
(K : Type u‚ÇÅ) [field K] (v : valuation K nnreal) (O : Type u‚ÇÇ) [comm_ring O] [algebra O K] (hv : v.integers O) (p : ‚Ñï) : Type u‚ÇÇ
{R : Type u} [ring R] : category_theory.limits.has_limits_of_size (Module R)
{k : Type u_1} {P‚ÇÅ : Type u_2} {V‚ÇÅ : Type u_6} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] : (P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÅ) ‚âÉ* (P‚ÇÅ ‚Üí·µÉ[k] P‚ÇÅ)À£
{C : Type u‚ÇÅ} [category_theory.category C] (T : category_theory.monad C) : T.free ‚ä£ T.forget
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {t : affine.triangle ‚Ñù P} (ho : t.orthocenter ‚àâ set.range t.points) {p : fin 3 ‚Üí P} (hps : set.range p ‚äÜ has_insert.insert t.orthocenter (set.range t.points)) (hpi : function.injective p) : (‚àÉ (i‚ÇÅ i‚ÇÇ i‚ÇÉ j‚ÇÇ j‚ÇÉ : fin 3), i‚ÇÅ ‚â† i‚ÇÇ ‚àß i‚ÇÅ ‚â† i‚ÇÉ ‚àß i‚ÇÇ ‚â† i‚ÇÉ ‚àß (‚àÄ (i : fin 3), i = i‚ÇÅ ‚à® i = i‚ÇÇ ‚à® i = i‚ÇÉ) ‚àß p i‚ÇÅ = t.orthocenter ‚àß j‚ÇÇ ‚â† j‚ÇÉ ‚àß t.points j‚ÇÇ = p i‚ÇÇ ‚àß t.points j‚ÇÉ = p i‚ÇÉ) ‚à® set.range p = set.range t.points
{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : set M) (h : S.finite) : complete_lattice.is_compact_element (submodule.span R S)
 : Type
(Œ± : Type u_1) : ‚Ü•‚àÖ ‚âÉ empty
 : string ‚Üí string
{Œ± : Type u_1} {m : measurable_space Œ±} (v : measure_theory.vector_measure Œ± ennreal) : measure_theory.measure Œ±
 : set upper_half_plane
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : add_zero_class ‚Ü•S
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} [measurable_space Œ±] [measurable_space Œ≤] [measurable_space Œ≥] [measurable_space Œ¥] (ab : Œ± ‚âÉ·µê Œ≤) (cd : Œ≥ ‚âÉ·µê Œ¥) : Œ± ‚äï Œ≥ ‚âÉ·µê Œ≤ ‚äï Œ¥
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (H : well_founded r) (s : set Œ±) : s.nonempty ‚Üí (‚àÉ (a : Œ±) (H : a ‚àà s), ‚àÄ (x : Œ±), x ‚àà s ‚Üí ¬¨r x a)
{Œ± : Type u_1} {Œ≤ : Type u_2} {n : ‚Ñï} (e : Œ± ‚âÉ Œ≤) : sym Œ± n ‚âÉ sym Œ≤ n
{M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] (f : M ‚Üí‚Çô* N) (g : N ‚Üí M) (h‚ÇÅ : function.left_inverse g ‚áëf) (h‚ÇÇ : function.right_inverse g ‚áëf) : N ‚Üí‚Çô* M
 : znum ‚Üí znum
{C : Type u} [category_theory.category C] (B : C) {J : Type v} (F : category_theory.discrete J ‚•§ category_theory.over B) : category_theory.limits.wide_pullback_shape J ‚•§ C
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G : J ‚•§ C} (Œ± : G ‚âÖ F) : category_theory.limits.cocone F ‚âå category_theory.limits.cocone G
{E : Type u_1} [inner_product_space ‚Ñù E] {Œπ : Type u_2} [fintype Œπ] [decidable_eq Œπ] [nonempty Œπ] {e : basis Œπ ‚Ñù E} (h : orthonormal ‚Ñù ‚áëe) (x : orientation ‚Ñù E Œπ) : orthonormal ‚Ñù ‚áë(e.adjust_to_orientation x)
{C : Type u} [category_theory.category C] (f : category_theory.arrow C) [‚àÄ (n : ‚Ñï), category_theory.limits.has_wide_pullback f.right (Œª (i : ulift (fin (n + 1))), f.left) (Œª (i : ulift (fin (n + 1))), f.hom)] : category_theory.simplicial_object C
{C : Type u} [category_theory.category C] (f : category_theory.arrow C) [‚àÄ (n : ‚Ñï), category_theory.limits.has_wide_pullback f.right (Œª (i : ulift (fin (n + 1))), f.left) (Œª (i : ulift (fin (n + 1))), f.hom)] : category_theory.simplicial_object.augmented C
{G : Type u} {n : ‚Ñï} [fintype G] [add_left_cancel_monoid G] (x : G) : add_order_of (n ‚Ä¢ x) = add_order_of x / (add_order_of x).gcd n
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] [complete_space ùïú] {f f' : ùïú ‚Üí ùïú} (hf : ‚àÄ (x : ùïú), has_strict_deriv_at f (f' x) x) (h0 : ‚àÄ (x : ùïú), f' x ‚â† 0) : is_open_map f
{R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] {p : ideal R} {P : ideal S} [algebra R S] [algebra (R ‚ß∏ p) (S ‚ß∏ P)] [is_scalar_tower R (R ‚ß∏ p) (S ‚ß∏ P)] (h : function.injective ‚áë(algebra_map (R ‚ß∏ p) (S ‚ß∏ P))) : ideal.comap (algebra_map R S) P = p
{Œ± : Type u_1} (r : setoid Œ±) : set (set Œ±)
{Œ± : Type u_1} [i‚ÇÅ : linear_order Œ±] [i‚ÇÇ : order_bot Œ±] (h : well_founded has_lt.lt) : conditionally_complete_linear_order_bot Œ±
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {k : S.localization_map P} (z : N) : ‚áë(k.lift _) (‚áë(f.lift _) z) = z
{X : Type u_1} {M : Type u_2} [topological_space X] [add_monoid M] [topological_space M] [has_continuous_add M] : C(X, add_units M) ‚âÉ add_units C(X, M)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : e.inverse ‚ãô e.functor ‚ü∂ ùü≠ D
(R : Type u_1) [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (N : Type u_3) [add_comm_monoid N] [module R N] (Œπ : Type u_6) [decidable_eq Œπ] {M‚ÇÇ : Type u_7} [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] (S : Type u_9) [semiring S] [module S N] [smul_comm_class R S N] (e : M ‚âÉ‚Çó[R] M‚ÇÇ) : alternating_map R M N Œπ ‚âÉ‚Çó[S] alternating_map R M‚ÇÇ N Œπ
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} (X : T.algebra) : category_theory.limits.is_colimit (category_theory.monad.beck_cofork X)
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] {G : Type u_4} [add_comm_group G] [module R G] (f : E ‚Üí‚Çó[R] F) (g : E ‚Üí‚Çó[R] G) (hf : f.range = ‚ä§) (hg : g.range = ‚ä§) (hfg : is_compl f.ker g.ker) : E ‚âÉ‚Çó[R] F √ó G
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (P : category_theory.idempotents.karoubi C) : P ‚äû P.complement ‚âÖ (category_theory.idempotents.to_karoubi C).obj P.X
{m‚ÇÅ : Type u‚ÇÄ ‚Üí Type v‚ÇÄ} {m‚ÇÇ : Type u‚ÇÅ ‚Üí Type v‚ÇÅ} {Œ±‚ÇÅ œâ‚ÇÅ : Type u‚ÇÄ} {Œ±‚ÇÇ œâ‚ÇÇ : Type u‚ÇÅ} (F : m‚ÇÅ (Œ±‚ÇÅ √ó œâ‚ÇÅ) ‚âÉ m‚ÇÇ (Œ±‚ÇÇ √ó œâ‚ÇÇ)) : writer_t œâ‚ÇÅ m‚ÇÅ Œ±‚ÇÅ ‚âÉ writer_t œâ‚ÇÇ m‚ÇÇ Œ±‚ÇÇ
(ic : tactic.instance_cache) (en en1 : expr) (n1 : ‚Ñï) (ek : expr) (k : ‚Ñï) : tactic expr
 : ‚Ñï ‚Üí expr ‚Üí tactic unit
{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} {r : ‚Ñù} (hr : 0 < r) (K : ‚Ñù) (h : ‚àÄ (y : Œ±), has_dist.dist y x < r ‚Üí has_dist.dist (f y) (f x) ‚â§ K * has_dist.dist y x) : continuous_at f x
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : function.injective (quotient.lift f _)
 : linarith.linarith_monad unit
{J : Type v} [category_theory.small_category J] (F : J ‚•§ SemiRing) : category_theory.limits.is_limit ((category_theory.forget‚ÇÇ SemiRing Mon).map_cone (SemiRing.has_limits.limit_cone F))
{Œ± : Type u_1} {E : Type u_2} [linear_order E] [has_zero E] [measurable_space Œ±] [has_neg E] (f : measure_theory.simple_func Œ± E) : measure_theory.simple_func Œ± E
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] (x : ‚Ñ§_[p]) : ‚Ñ§
{M : Type u_2} [add_comm_group M] {ùïú : Type u_1} [field ùïú] [module ùïú M] {f : M ‚Üí‚Çó[ùïú] M} (hf : ‚áëlinear_map.det f = 0) : f.range < ‚ä§
(D : algebraic_geometry.Scheme.glue_data) : D.glued.open_cover
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.full F] [category_theory.faithful F] {X Y : C} : (X ‚ü∂ Y) ‚âÉ (F.obj X ‚ü∂ F.obj Y)
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (p : submodule R M) : ‚Ü•p ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ
(Œ± : Type u_1) (Œ≤ : Type u_2) [has_le Œ±] [has_le Œ≤] : Type (max u_1 u_2)
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (R‚ÇÇ : Type u_5) [comm_semiring R‚ÇÇ] [algebra R‚ÇÇ R] [module R‚ÇÇ M] [is_scalar_tower R‚ÇÇ R M] : bilin_form R M ‚Üí‚Çó[R‚ÇÇ] M ‚Üí‚Çó[R‚ÇÇ] M ‚Üí‚Çó[R] R
{R : Type u_1} [ring R] (p q : polynomial R) : polynomial R
{Œ± : Type u_1} {Œ≤ : Type u_2} [pseudo_emetric_space Œ±] [nonempty Œ≤] [semilattice_sup Œ≤] {s : Œ≤ ‚Üí Œ±} : cauchy_seq s ‚Üî ‚àÉ (b : Œ≤ ‚Üí ennreal), (‚àÄ (n m N : Œ≤), N ‚â§ n ‚Üí N ‚â§ m ‚Üí has_edist.edist (s n) (s m) ‚â§ b N) ‚àß filter.tendsto b filter.at_top (nhds 0)
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] (f : Œ≤ ‚Üí Œ±) (l : filter Œ≤) : filter.tendsto (Œª (x : Œ≤), (f x, f x)) l (uniformity Œ±)
{Œ¥ : Type u_1} [fintype Œ¥] {Œ∫ : Œ¥ ‚Üí Type u_2} {t : Œ† (d : Œ¥), set (Œ∫ d)} (ht : ‚àÄ (d : Œ¥), (t d).finite) : (set.univ.pi t).finite
{Œ± : Type u_1} : list (poly Œ±) ‚Üí poly Œ±
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (f : M ‚Üí* P) {x y : M} : ‚áë(con.ker f) x y ‚Üî ‚áëf x = ‚áëf y
{ùïú : Type u_1} {E : Type u_2} [ordered_ring ùïú] [add_comm_group E] [module ùïú E] (faces : set (finset E)) (indep : ‚àÄ (s : finset E), s ‚àà faces ‚Üí affine_independent ùïú coe) (down_closed : ‚àÄ (s : finset E), s ‚àà faces ‚Üí ‚àÄ (t : finset E), t ‚äÜ s ‚Üí t ‚àà faces) (inter_subset_convex_hull : ‚àÄ (s : finset E), s ‚àà faces ‚Üí ‚àÄ (t : finset E), t ‚àà faces ‚Üí ‚áë(convex_hull ùïú) ‚Üës ‚à© ‚áë(convex_hull ùïú) ‚Üët ‚äÜ ‚áë(convex_hull ùïú) (‚Üës ‚à© ‚Üët)) : geometry.simplicial_complex ùïú E
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : L ‚Üí‚Çó‚ÅÖR‚ÅÜ module.End R M
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [category_theory.limits.has_pushout f g] [category_theory.epi f] : category_theory.epi category_theory.limits.pushout.inr
{C : Type u} [category_theory.category C] {J‚ÇÅ J‚ÇÇ : category_theory.grothendieck_topology C} (h : category_theory.presieve.is_sheaf J‚ÇÅ (category_theory.functor.closed_sieves J‚ÇÇ)) : J‚ÇÅ ‚â§ J‚ÇÇ
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [has_zero M‚ÇÅ] [has_scalar ‚Ñï M‚ÇÅ] [add_left_cancel_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : add_left_cancel_monoid M‚ÇÅ
(E : Type u_1) [add_comm_group E] : subsingleton (module ‚Ñö E)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (F : C ‚•§ D) (G : D ‚•§ E) [category_theory.limits.preserves_finite_colimits F] [category_theory.limits.preserves_finite_colimits G] : category_theory.limits.preserves_finite_colimits (F ‚ãô G)
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] (x : ‚Ñ§_[p]) : ‚Ñï
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x : V) (Œ∏ : real.angle) : x = ‚áë(hb.rotation Œ∏) x ‚Üî x = 0 ‚à® Œ∏ = 0
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [normalization_monoid Œ±] : Œ± ‚Üí*‚ÇÄ Œ±
(R : Type u_1) [comm_ring R] (K : Type u_5) [comm_ring K] [algebra R K] : Prop
{Œ± : Type u_1} [comm_semiring Œ±] (E : linear_recurrence Œ±) : ‚Ü•(E.sol_space) ‚âÉ‚Çó[Œ±] fin E.order ‚Üí Œ±
 : hilbert_basis ‚Ñ§ ‚ÑÇ ‚Ü•(measure_theory.Lp ‚ÑÇ 2 haar_circle)
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.mono_over X ‚•§ category_theory.mono_over Y
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : is_connected s ‚Üî ‚àÄ (U : finset (set Œ±)), (‚àÄ (u v : set Œ±), u ‚àà U ‚Üí v ‚àà U ‚Üí (s ‚à© (u ‚à© v)).nonempty ‚Üí u = v) ‚Üí (‚àÄ (u : set Œ±), u ‚àà U ‚Üí is_open u) ‚Üí s ‚äÜ ‚ãÉ‚ÇÄ‚ÜëU ‚Üí (‚àÉ (u : set Œ±) (H : u ‚àà U), s ‚äÜ u)
{R : Type u_1} {Œπ‚ÇÅ : Type u_2} {Œπ‚ÇÇ : Type u_3} [comm_semiring R] [decidable_eq Œπ‚ÇÅ] [decidable_eq Œπ‚ÇÇ] {N‚ÇÅ : Type u_6} [add_comm_monoid N‚ÇÅ] [module R N‚ÇÅ] {N‚ÇÇ : Type u_7} [add_comm_monoid N‚ÇÇ] [module R N‚ÇÇ] {N : Type u_8} [add_comm_monoid N] [module R N] : tensor_product R (multilinear_map R (Œª (_x : Œπ‚ÇÅ), N) N‚ÇÅ) (multilinear_map R (Œª (_x : Œπ‚ÇÇ), N) N‚ÇÇ) ‚Üí‚Çó[R] multilinear_map R (Œª (_x : Œπ‚ÇÅ ‚äï Œπ‚ÇÇ), N) (tensor_product R N‚ÇÅ N‚ÇÇ)
{G : Type u_1} [add_comm_group G] (K : add_subgroup G) {Œπ : Type u_2} {t : finset Œπ} {f : Œπ ‚Üí G} (h : ‚àÄ (c : Œπ), c ‚àà t ‚Üí f c ‚àà K) : t.sum (Œª (c : Œπ), f c) ‚àà K
{P : ‚Ñ§ ‚Üí Prop} [decidable_pred P] (b : ‚Ñ§) (Hb : ‚àÄ (z : ‚Ñ§), P z ‚Üí b ‚â§ z) (Hinh : ‚àÉ (z : ‚Ñ§), P z) : {lb // P lb ‚àß ‚àÄ (z : ‚Ñ§), P z ‚Üí lb ‚â§ z}
(ùïú : Type u_1) {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_3} [linear_order Œπ] [order_bot Œπ] [locally_finite_order Œπ] [is_well_order Œπ has_lt.lt] (f : Œπ ‚Üí E) (n : Œπ) : gram_schmidt ùïú f n = f n - (finset.Iio n).sum (Œª (i : Œπ), ‚Üë(‚áë(orthogonal_projection (submodule.span ùïú {gram_schmidt ùïú f i})) (f n)))
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] (X : category_theory.simplicial_object C) : chain_complex C ‚Ñï
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {P X Y : C} (f : P ‚ü∂ X) (g : P ‚ü∂ Y) [category_theory.limits.preserves_limit (category_theory.limits.pair X Y) G] (l : category_theory.limits.is_limit (category_theory.limits.binary_fan.mk f g)) : category_theory.limits.is_limit (category_theory.limits.binary_fan.mk (G.map f) (G.map g))
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] {f : J ‚Üí C} {t : category_theory.limits.cocone (category_theory.discrete.functor f)} (ht : category_theory.limits.is_colimit t) : (category_theory.limits.bicone.of_colimit_cocone ht).is_bilimit
{Œπ : Type u_1} {R : Type u_3} {A : Type u_5} {x : Œπ ‚Üí A} [comm_ring R] [comm_ring A] [algebra R A] (hx : algebraic_independent R x) : mv_polynomial (option Œπ) R ‚âÉ+* polynomial ‚Ü•(algebra.adjoin R (set.range x))
(k : ‚Ñï) : {n // n ‚àâ multiset.range k} ‚âÉ ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (m : pseudo_metric_space Œ≤) : pseudo_metric_space Œ±
{M : Type u_1} [add_semigroup M] : add_comm_semigroup ‚Ü•(add_subsemigroup.center M)
{R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [semiring R] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] [semi_normed_group E] [semi_normed_group E‚ÇÇ] [module R E] [module R‚ÇÇ E‚ÇÇ] (e : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) : E ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ
(n : ‚Ñï) : (list.nat.antidiagonal n).nodup
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_zero_class M] {f : Œ± ‚Üí Œ≤} (hf : function.injective f) : (Œ≤ ‚Üí‚ÇÄ M) ‚Üí+ Œ± ‚Üí‚ÇÄ M
{m : Type u ‚Üí Type v} [monad m] {Œ± : Type u} : option (m Œ±) ‚Üí m (option Œ±)
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {X Y Z : C} (G : C ‚•§ D) (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [category_theory.limits.has_pushout f g] [category_theory.limits.has_pushout (G.map f) (G.map g)] : category_theory.limits.pushout (G.map f) (G.map g) ‚ü∂ G.obj (category_theory.limits.pushout f g)
{Œπ : Type u_1} {Œì : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), inhabited (Œì i)] (i : Œπ) : turing.pointed_map (Œ† (i : Œπ), Œì i) (Œì i)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] {p : formal_multilinear_series ùïú E F} [complete_space F] : continuous_on p.sum (emetric.ball 0 p.radius)
(X : Type u_1) [topological_space X] [compact_space X] [t2_space X] : CompHaus
{M : Type u_2} [add_comm_monoid M] {G : Type u_5} [group G] [distrib_mul_action G M] {R : Type u_1} : mul_action G (ray_vector R M)
(p : ‚Ñï) [fact (nat.prime p)] : ‚Ñö ‚Üí ‚Ñö_[p]
(k : Type u_1) (G : Type u_2) (V : Type u_3) [comm_semiring k] [monoid G] [add_comm_monoid V] [module k V] : Type (max u_3 u_2)
{n : ‚Ñï} (x : ‚Ñï) (h : x.coprime n) : (zmod n)À£
 : widget_override.interactive_expression.sf ‚Üí widget_override.interactive_expression.sf
{M : Type u_1} [add_zero_class M] : has_inf (add_submonoid M)
{Œ± J : Type u} [category_theory.small_category J] [category_theory.fin_category J] [semilattice_inf Œ±] [order_top Œ±] (F : J ‚•§ Œ±) : category_theory.limits.limit F = finset.univ.inf F.obj
{Œ± : Type u_1} [has_one Œ±] [has_zero Œ±] [has_lt Œ±] (s : simple_continued_fraction Œ±) : Prop
(C : Type u) [category_theory.category C] [category_theory.locally_small C] : C ‚âå category_theory.shrink_homs C
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] {Z : D} (F : C ‚•§ D) (hZ : category_theory.limits.is_terminal Z) : category_theory.with_terminal C ‚•§ D
(R : Type u_1) [comm_ring R] {C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] [category_theory.preadditive D] [category_theory.linear R D] (F : C ‚•§ D) : category_theory.Free R C ‚•§ D
 : ‚Ñï ‚Üí vm format
{Œ± : Type u_1} [semi_normed_ring Œ±] [norm_one_class Œ±] (a : Œ±) (n : ‚Ñï) : ‚à•a ^ n‚à•‚Çä ‚â§ ‚à•a‚à•‚Çä ^ n
{R : Type u_1} {S : Type u_2} {F : Type u_3} [mul_one_class R] [mul_one_class S] [monoid_hom_class F R S] (f : F) (r : R) [invertible r] : invertible (‚áëf r)
{m : Type u ‚Üí Type u} [applicative m] {Œ± Œ≤ : Type u} (f : Œ± ‚Üí m Œ≤) : lazy_list Œ± ‚Üí m (lazy_list Œ≤)
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.abelian C] [category_theory.has_injective_resolutions C] [category_theory.abelian D] (F : C ‚•§ D) [F.additive] (n : ‚Ñï) (X : C) [category_theory.injective X] : (F.right_derived (n + 1)).obj X ‚âÖ 0
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {s : category_theory.limits.cocone F} (P : category_theory.limits.is_colimit s) (e : K ‚âå J) : category_theory.limits.is_colimit (category_theory.limits.cocone.whisker e.functor s)
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] {i : D.to_glue_data.J} (U : topological_space.opens ‚Ü•((D.to_glue_data.U i).carrier)) : (D.to_glue_data.U i).presheaf.obj (opposite.op ((topological_space.opens.map (category_theory.limits.colimit.Œπ D.to_glue_data.diagram.multispan (opposite.unop (opposite.op (category_theory.limits.walking_multispan.right i)))).base).obj (_.functor.obj U))) ‚ü∂ (D.to_glue_data.U i).presheaf.obj (opposite.op U)
(e‚ÇÄ e‚ÇÅ : expr) : expr
{G : Type u_1} [category_theory.groupoid G] [is_free_groupoid G] {X : Type v} [group X] (f g : G ‚•§ category_theory.single_obj X) (h : ‚àÄ (a b : is_free_groupoid.generators G) (e : a ‚ü∂ b), f.map (is_free_groupoid.of e) = g.map (is_free_groupoid.of e)) : f = g
(n : ‚Ñï) : finset ‚Ñï
(o : tactic.suggest.suggest_opt) : tactic.solve_by_elim.opt
{M : Type u_1} [monoid M] (s : set M) : M ‚Üí Prop
(x y : ‚ÑÇ) : ‚ÑÇ
(n : ‚Ñï) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 ‚â§ x) : 0 ‚â§ polynomial.eval x (polynomial.cyclotomic n R)
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (l : list (matrix n n Œ±)) : (l.prod)‚Åª¬π = (list.map has_inv.inv l.reverse).prod
{M‚ÇÇ : Type u_2} {M‚ÇÅ : Type u_1} [has_inv M‚ÇÅ] [has_involutive_inv M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (inv : ‚àÄ (x : M‚ÇÅ), f x‚Åª¬π = (f x)‚Åª¬π) : has_involutive_inv M‚ÇÅ
(Œ± : Type u) : set (set (ultrafilter Œ±))
{R : Type u} [semiring R] {P : ideal R} (hmax : ‚àÄ (m : ideal R), P < m ‚Üí ¬¨m.is_maximal) (J : ideal R) (hPJ : P < J) : J = ‚ä§
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] (P : C·µí·µñ ‚•§ A) [category_theory.limits.has_pullbacks C] (K : category_theory.pretopology C) : category_theory.presheaf.is_sheaf (category_theory.pretopology.to_grothendieck C K) P ‚Üî ‚àÄ ‚¶ÉX : C‚¶Ñ (R : category_theory.presieve X), R ‚àà ‚áëK X ‚Üí nonempty (category_theory.limits.is_limit (P.map_cone (category_theory.sieve.generate R).arrows.cocone.op))
(Œ± : Type u) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [Œ† (i : Œπ), add_monoid (Œ≤ i)] : has_scalar ‚Ñï (Œ†‚ÇÄ (i : Œπ), Œ≤ i)
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f : M ‚Üí+ N) (hf : ‚àÄ (x y : M), add_commute (‚áëf x) (‚áëf y)) : M·µÉ·µí·µñ ‚Üí+ N
{Œ± : Type u_1} (s : cycle Œ±) : ‚Ñï
{Œ±‚ÇÅ : Type u_2} {Œ±‚ÇÇ : Type u_3} {Œ≤‚ÇÅ : Œ±‚ÇÅ ‚Üí Type u_5} {Œ≤‚ÇÇ : Œ±‚ÇÇ ‚Üí Type u_6} (f‚ÇÅ : Œ±‚ÇÅ ‚Üí Œ±‚ÇÇ) (f‚ÇÇ : Œ† (a : Œ±‚ÇÅ), Œ≤‚ÇÅ a ‚Üí Œ≤‚ÇÇ (f‚ÇÅ a)) (x : sigma Œ≤‚ÇÅ) : sigma Œ≤‚ÇÇ
{C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n m : ‚Ñï} (h : n = m) : X.obj (opposite.op (simplex_category.mk n)) ‚âÖ X.obj (opposite.op (simplex_category.mk m))
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] (X : C) : category_theory.center C
{Œ± Œ≤ : Type u} {Œ±' Œ≤' : Type v} (F : Type u ‚Üí Type v ‚Üí Type w) [bifunctor F] [is_lawful_bifunctor F] (h : Œ± ‚âÉ Œ≤) (h' : Œ±' ‚âÉ Œ≤') : F Œ± Œ±' ‚âÉ F Œ≤ Œ≤'
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommMon) : category_theory.limits.cone F
{M : Type u_1} [add_comm_monoid M] [module ennreal M] : module nnreal M
(L : first_order.language) : L.Theory
{Œ≤ : Type u} {Œ± : Type v} [add_comm_monoid Œ≤] {s : finset Œ±} {f : Œ± ‚Üí Œ≤} {a : Œ±} (hp : s.sum (Œª (x : Œ±), f x) = 0) (h1 : ‚àÄ (x : Œ±), x ‚àà s ‚Üí x ‚â† a ‚Üí f x = 0) (x : Œ±) (H : x ‚àà s) : f x = 0
{F : Type u} [decidable_eq F] [field F] (s : finset F) : (F ‚Üí F) ‚Üí‚Çó[F] polynomial F
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (l : filter Œ±) (a : Œ±) : Prop
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A √ó B) B
 : num ‚Üí num ‚Üí num
(l : Type u_4) (R : Type u‚ÇÇ) [decidable_eq l] [comm_ring R] : matrix (unit ‚äï l ‚äï l) (unit ‚äï l ‚äï l) R
{A : Type u_1} {Œπ : Type u_2} [ring A] (B : Œπ ‚Üí add_subgroup A) : Prop
{E : Type u_1} (R : Type u_2) (S : Type u_3) [add_comm_group E] [division_ring R] [division_ring S] [module R E] [module S E] (n : ‚Ñ§) (x : E) : (‚Üën)‚Åª¬π ‚Ä¢ x = (‚Üën)‚Åª¬π ‚Ä¢ x
{Œ± : Type u_1} {Œ≤ : Type u_2} [non_unital_semi_normed_ring Œ±] [non_unital_semi_normed_ring Œ≤] : non_unital_semi_normed_ring (Œ± √ó Œ≤)
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_products C] : category_theory.is_left_adjoint (category_theory.over.forget X)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [metric_space Œ≤] [has_zero Œ≤] [complete_space Œ≤] : complete_space (zero_at_infty_continuous_map Œ± Œ≤)
{Œ± : Type u_1} [comm_semiring Œ±] (E : linear_recurrence Œ±) (init : fin E.order ‚Üí Œ±) : ‚Ñï ‚Üí Œ±
{p : ‚Ñï} {R : Type u_1} [comm_ring R] (n : ‚Ñï) : witt_vector p R ‚Üí witt_vector p R
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (h : F ‚âÖ G) [r : category_theory.is_left_adjoint F] : category_theory.is_left_adjoint G
{C : Type u} [category_theory.category C] {f g : category_theory.arrow C} [category_theory.limits.has_image f.hom] [category_theory.limits.has_image g.hom] (sq : f ‚ü∂ g) [category_theory.limits.has_image_map sq] {h : category_theory.arrow C} [category_theory.limits.has_image h.hom] (sq' : g ‚ü∂ h) [category_theory.limits.has_image_map sq'] : category_theory.limits.image_map (sq ‚â´ sq')
{Œ± : Type u_1} {Œ≤ : Type u_2} (q : semiquot Œ±) (f : Œ± ‚Üí semiquot Œ≤) : semiquot Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} [non_assoc_semiring Œ±] [non_assoc_semiring Œ≤] : (Œ± ‚Üí+* Œ≤) ‚âÉ (Œ±·µê·µí·µñ ‚Üí+* Œ≤·µê·µí·µñ)
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] (D : J ‚•§ T.algebra) : D ‚ãô T.forget ‚ãô ‚ÜëT ‚ü∂ D ‚ãô T.forget
{ùïú : Type u_3} [is_R_or_C ùïú] {E : Type u_4} [inner_product_space ùïú E] [finite_dimensional ùïú E] {n : ‚Ñï} (hn : finite_dimensional.finrank ùïú E = n) : E ‚âÉ‚Çó·µ¢[ùïú] euclidean_space ùïú (fin n)
(p : Set ‚Üí Prop) : Class
 : ‚Ñï ‚Üí ‚Ñï ‚Üí tactic unit ‚Üí tactic unit
{Œ± : Type u} [pseudo_emetric_space Œ±] {Œ¥‚ÇÅ Œ¥‚ÇÇ : ‚Ñù} (Œ¥‚ÇÇ_pos : 0 < Œ¥‚ÇÇ) (hlt : Œ¥‚ÇÅ < Œ¥‚ÇÇ) (E : set Œ±) : metric.cthickening Œ¥‚ÇÅ E ‚äÜ metric.thickening Œ¥‚ÇÇ E
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (f : Œ± ‚Üí C(Œ≤, Œ≥)) (h : continuous (function.uncurry (Œª (x : Œ±) (y : Œ≤), ‚áë(f x) y))) : continuous f
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) : submodule R ‚Ü•p ‚âÉo {p' // p' ‚â§ p}
{V : Type u} {G : simple_graph V} (G' : G.subgraph) : Prop
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : set Œ±) : Prop
{Œ± : Type u} [topological_space Œ±] [locally_compact_space Œ±] [regular_space Œ±] {K U : set Œ±} (hK : is_compact K) (hU : is_open U) (hKU : K ‚äÜ U) : ‚àÉ (K' : set Œ±), is_compact K' ‚àß K ‚äÜ interior K' ‚àß K' ‚äÜ U
{M : Type u_1} {Œ± : Type u_6} {Œ≤ : Type u_7} [monoid M] [mul_action M Œ±] [has_scalar M Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (smul : ‚àÄ (c : M) (x : Œ≤), f (c ‚Ä¢ x) = c ‚Ä¢ f x) : mul_action M Œ≤
(n : ‚Ñï+) (x : ‚ÑÇÀ£) : x ‚àà roots_of_unity n ‚ÑÇ ‚Üî ‚àÉ (i : ‚Ñï) (H : i < ‚Üën), complex.exp (2 * ‚Üëreal.pi * complex.I * (‚Üëi / ‚Üën)) = ‚Üëx
(cfg : tactic.equiv_rw_cfg) (permissive : bool) : list expr ‚Üí tactic.interactive.itactic
(Œ± : Type u_1) : Type u_1
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : fin 3 ‚Üí P) : collinear k (set.range p) ‚Üî ¬¨affine_independent k p
(op empty : expr) : list expr ‚Üí expr
{Œ± : Type u_1} {Œ≤ : Type u_2} {t‚ÇÅ t‚ÇÇ : topological_space Œ±} {t‚ÇÉ : topological_space Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÅ) {s : set Œ±} {f : Œ± ‚Üí Œ≤} (h‚ÇÇ : continuous_on f s) : continuous_on f s
(x : ‚Ñù) : ‚Ñï ‚Üí ‚Ñù
(_x : interactive.parse (lean.parser.tk "#lint")) : lean.parser unit
(Œ± : Type u_2) [has_lt Œ±] : Prop
{Œ± : Type u} [has_zero Œ±] [has_sub Œ±] : list Œ± ‚Üí list Œ± ‚Üí list Œ±
{Œ± : Type u_1} [group Œ±] (s : subgroup Œ±) (t : set (Œ± ‚ß∏ s)) : ‚Ü•(quotient_group.mk ‚Åª¬π' t) ‚âÉ ‚Ü•s √ó ‚Ü•t
{C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] (S : J.cover X) (P : C·µí·µñ ‚•§ D) : category_theory.limits.multifork (S.index P)
(n : ‚Ñï) : Prop
{Œ± : Type u} (s‚ÇÅ s‚ÇÇ : stream Œ±) : stream Œ±
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_binary_coproducts D] (F : C ‚•§ D) (A : C) : F ‚ãô category_theory.limits.coprod.functor.obj (F.obj A) ‚ü∂ category_theory.limits.coprod.functor.obj A ‚ãô F
{Œ± : Type u_1} (s : cycle Œ±) : cycle Œ±
{Œ± : Type u_1} {n : ‚Ñï} (f : fin n ‚Üí Œ±) : list Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_wide_pullbacks C] {A : C} (s : set (category_theory.subobject A)) : category_theory.subobject A
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} (h_mono : strict_mono_on f s) (hs : s ‚àà nhds_within a (set.Ici a)) (hfs : ‚àÄ (b : Œ≤), b > f a ‚Üí (‚àÉ (c : Œ±) (H : c ‚àà s), f c ‚àà set.Ioc (f a) b)) : continuous_within_at f (set.Ici a) a
{X : Top} (U : topological_space.opens ‚Ü•X) (R : category_theory.presieve U) : (Œ£ (V : topological_space.opens ‚Ü•X), {f // R f}) ‚Üí topological_space.opens ‚Ü•X
{C : Type u} [category_theory.category C] {X Y Z : algebraic_geometry.PresheafedSpace C} (Œ± : X ‚ü∂ Y) (Œ≤ : Y ‚ü∂ Z) (U : (topological_space.opens ‚Ü•(Z.carrier))·µí·µñ) : (Œ± ‚â´ Œ≤).c.app U = Œ≤.c.app U ‚â´ Œ±.c.app (opposite.op ((topological_space.opens.map Œ≤.base).obj (opposite.unop U)))
(V : Type (u+1)) [category_theory.large_category V] (G : Mon) : (Action.functor_category_equivalence V G).functor ‚ãô (category_theory.evaluation (category_theory.single_obj ‚Ü•G) V).obj punit.star ‚âÖ Action.forget V G
(Œ± : Type u_2) [fintype Œ±] [nonempty Œ±] [semilattice_sup Œ±] : order_top Œ±
{n k : ‚Ñï} : k ‚â§ n ‚Üí (n - k).factorial * n.desc_factorial k = n.factorial
{X : Type u_1} [topological_space X] {x y : X} (Œ≥ : path x y) : path y x
{a b : ‚Ñù} (h : a < b) : cardinal.mk ‚Ü•(set.Ioo a b) = cardinal.continuum
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ± ‚Üí Œ≥} {x : Œ±} {y : Œ≤} (hf : continuous_at f x) : continuous_at (Œª (x : Œ± √ó Œ≤), f x.fst) (x, y)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {n : ‚Ñï} {f : ùïú ‚Üí F} {s : set ùïú} {x : ùïú} (hxs : unique_diff_within_at ùïú s x) : iterated_deriv_within (n + 1) f s x = deriv_within (iterated_deriv_within n f s) s x
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [finite_dimensional ùïú E] {n : ‚Ñï} (hn : finite_dimensional.finrank ùïú E = n) {Œπ : Type u_4} [fintype Œπ] [decidable_eq Œπ] {V : Œπ ‚Üí submodule ùïú E} (hV : direct_sum.is_internal V) (hV' : orthogonal_family ùïú (Œª (i : Œπ), (V i).subtype‚Çó·µ¢)) : orthonormal ùïú ‚áë(direct_sum.is_internal.subordinate_orthonormal_basis hn hV)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {p : formal_multilinear_series ùïú E F} {x : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) : tendsto_locally_uniformly_on (Œª (n : ‚Ñï) (y : E), p.partial_sum n y) (Œª (y : E), f (x + y)) filter.at_top (emetric.ball 0 r)
{Œ± : Type u} [emetric_space Œ±] : continuous (Œª (p : Œ± √ó topological_space.closeds Œ±), emetric.inf_edist p.fst ‚Üë(p.snd))
 : PartialOrder ‚âå PartialOrder
(R : Type u) [semiring R] {Œπ : Type v} [dec_Œπ : decidable_eq Œπ] {M : Œπ ‚Üí Type w} [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] (s : finset Œπ) (c : R) (x : Œ† (i : ‚Ü•‚Üës), M i.val) : ‚áë(direct_sum.mk M s) (c ‚Ä¢ x) = c ‚Ä¢ ‚áë(direct_sum.mk M s) x
{Œ± : Type u_1} [pseudo_emetric_space Œ±] (r C : ennreal) {f : ‚Ñï ‚Üí Œ±} (hu : ‚àÄ (n : ‚Ñï), has_edist.edist (f n) (f (n + 1)) ‚â§ C * r ^ n) {a : Œ±} (ha : filter.tendsto f filter.at_top (nhds a)) (n : ‚Ñï) : has_edist.edist (f n) a ‚â§ C * r ^ n / (1 - r)
 : Type
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p‚ÇÅ p‚ÇÇ : P) : collinear k {p‚ÇÅ, p‚ÇÇ}
{R : Type u} [comm_semiring R] {A : Type v‚ÇÅ} [semiring A] [algebra R A] {B : Type v‚ÇÇ} [semiring B] [algebra R B] {C : Type v‚ÇÉ} [semiring C] [algebra R C] {D : Type v‚ÇÑ} [semiring D] [algebra R D] (f : A ‚Üí‚Çê[R] B) (g : C ‚Üí‚Çê[R] D) : tensor_product R A C ‚Üí‚Çê[R] tensor_product R B D
{C' : Type u_1} (X : category_theory.shrink_homs C') : C'
 : tactic unit
 : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
{R : Type u} [ring R] (s : set R) (sm : submonoid R) (sa : add_subgroup R) (hm : ‚Üësm = s) (ha : ‚Üësa = s) : subring R
{Œ± : Type u_1} [decidable_eq Œ±] : ‚àÖ.shadow = ‚àÖ
{R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] [is_localization M S] (z : S) : R √ó ‚Ü•M
{Œ± : Type u} [preorder Œ±] (s : set Œ±) (a : Œ±) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (p : pmf Œ±) : pmf Œ≤
{R : Type u_1} {S : Type u_2} {M : Type u_3} {s : S} [has_scalar R M] [has_scalar R S] [has_scalar S M] [is_scalar_tower R S M] (a : R) (ab : is_smul_regular M (a ‚Ä¢ s)) : is_smul_regular M s
(Œ± : Type u) : Type u
{Œ± : Type u} {p : Œ± ‚Üí Prop} [has_le Œ±] [order_bot Œ±] (hbot : p ‚ä•) : order_bot {x // p x}
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C ‚•§ D} {‚Ñ± ‚Ñ±' : category_theory.Sheaf K A} (Œ± : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) (X : A) : G.op ‚ãô (category_theory.sheaf_over ‚Ñ± X).val ‚âÖ G.op ‚ãô (category_theory.sheaf_over ‚Ñ±' X).val
(Œ± : Type u_1) [measurable_space Œ±] : ‚Ü•set.univ ‚âÉ·µê Œ±
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) [category_theory.is_filtered J] {x x' y : Œ£ (j : J), ‚Ü•(F.obj j)} (hxx' : category_theory.limits.types.filtered_colimit.rel (F ‚ãô category_theory.forget AddMon) x x') : AddMon.filtered_colimits.colimit_add_aux F x y = AddMon.filtered_colimits.colimit_add_aux F x' y
 : Type
{M : Type u_1} [semi_normed_group M] {N : Type u_2} [semi_normed_group N] (S : add_subgroup M) (f : normed_group_hom M N) (hf : ‚àÄ (s : M), s ‚àà S ‚Üí ‚áëf s = 0) : normed_group_hom (M ‚ß∏ S) N
{Œ± : Type u_1} (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù) (dist_self : ‚àÄ (x : Œ±), dist x x = 0) (dist_comm : ‚àÄ (x y : Œ±), dist x y = dist y x) (dist_triangle : ‚àÄ (x y z : Œ±), dist x z ‚â§ dist x y + dist y z) : bornology Œ±
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A √ó B) (B √ó A)
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [add_comm_monoid Œ≤] : add_comm_monoid Œ±
{s : Type u‚ÇÄ} {s' : Type u‚ÇÅ} {m : Type u‚ÇÄ ‚Üí Type u_1} {m' : Type u‚ÇÅ ‚Üí Type u_2} [uliftable m m'] (F : s ‚âÉ s') : uliftable (reader_t s m) (reader_t s' m')
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] : category_theory.closed (ùüô_ C)
{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1) : 0 < L.length
{Œ± : Type u_1} [topological_space Œ±] {s t : set Œ±} (hs : is_GŒ¥ s) (ht : is_GŒ¥ t) : is_GŒ¥ (s ‚à™ t)
(p : ‚Ñï) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] (m : ‚Ñ§) : Type u_1
{C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (hu : category_theory.cover_lifting J K G) (‚Ñ± : category_theory.Sheaf J A) {X : A} {U : D} {S : category_theory.sieve U} (hS : S ‚àà ‚áëK U) {x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj ‚Ñ±.val ‚ãô category_theory.coyoneda.obj (opposite.op X)) S.arrows} (hx : x.compatible) : category_theory.limits.cone (category_theory.Ran.diagram G.op ‚Ñ±.val (opposite.op U))
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] {F G : category_theory.oplax_functor B C} {Œ∑ Œ∏ Œπ : F ‚ü∂ G} (Œì : category_theory.oplax_nat_trans.modification Œ∑ Œ∏) (Œî : category_theory.oplax_nat_trans.modification Œ∏ Œπ) : category_theory.oplax_nat_trans.modification Œ∑ Œπ
{Œ± : Type u_1} [has_sizeof Œ±] (t : Œ±) (sh : Œ† (x : Œ±), slim_check.sizeof_lt x t ‚Üí lazy_list {y // slim_check.sizeof_lt y x}) : slim_check.shrink_fn {t' // slim_check.sizeof_lt t' t}
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚Üí D) : category_theory.induced_category D F ‚•§ D
{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_3} {V‚ÇÉ : Type u_4} [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] [semi_normed_group V‚ÇÉ] : normed_group_hom V‚ÇÇ V‚ÇÉ ‚Üí+ normed_group_hom V‚ÇÅ V‚ÇÇ ‚Üí+ normed_group_hom V‚ÇÅ V‚ÇÉ
{R : Type u} [comm_ring R] {X Y : Type u} [ring X] [ring Y] [algebra R X] [algebra R Y] : (X ‚âÉ‚Çê[R] Y) ‚âÖ Algebra.of R X ‚âÖ Algebra.of R Y
{Œì : Type u_1} {Œì' : Type u_2} [inhabited Œì] [inhabited Œì'] (l : turing.list_blank Œì) (f : Œì ‚Üí list Œì') (hf : ‚àÉ (n : ‚Ñï), f inhabited.default = list.repeat inhabited.default n) : turing.list_blank Œì'
{Œ± : Type u_1} {Œ≤ : Type u_2} [mul_one_class Œ±] [mul_one_class Œ≤] (f : Œ± ‚Üí* Œ≤) : set_semiring Œ± ‚Üí+* set_semiring Œ≤
{K : Type u} [field K] (s : subfield K) : field ‚Ü•s
{Œ± : Type u} [pseudo_metric_space Œ±] [proper_space Œ±] : locally_compact_space Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x : V) : o.oangle 0 x = 0
 : Type
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] [topological_space Œ±] (F : Œπ ‚Üí Œ± ‚Üí Œ≤) (f : Œ± ‚Üí Œ≤) (p : filter Œπ) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {R : D ‚•§ C} [category_theory.reflective R] : category_theory.monadic_right_adjoint R
{Œ± : Type u} {Œ≤ : Type v} [mul_one_class Œ±] [add_zero_class Œ≤] : (Œ± ‚Üí* multiplicative Œ≤) ‚âÉ (additive Œ± ‚Üí+ Œ≤)
(n : ‚Ñï) : n.totient = n / n.factors.to_finset.prod (Œª (p : ‚Ñï), p) * n.factors.to_finset.prod (Œª (p : ‚Ñï), p - 1)
{Œ± : Type u} [topological_space Œ±] [nonempty Œ±] (f : filter Œ±) : Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x : V) {r : ‚Ñù} (hr : 0 ‚â§ r) : o.oangle x (r ‚Ä¢ x) = 0
 : multiset ‚Ñï+
{Œ± : Type} (m : tactic Œ±) : tactic.ring_exp.ring_exp_m Œ±
{C : Type u} [category_theory.category C] {A B : C} {f g : A ‚ü∂ B} [category_theory.is_coreflexive_pair f g] : category_theory.is_coreflexive_pair g f
(Œ± : Type u_1) [lattice Œ±] [bounded_order Œ±] : BoundedLattice
{L : first_order.language} {Œ± : Type u'} (l : list ((Œ£ (k : ‚Ñï), L.term (Œ± ‚äï fin k)) ‚äï (Œ£ (n : ‚Ñï), L.relations n) ‚äï ‚Ñï)) : (Œ£ (n : ‚Ñï), L.bounded_formula Œ± n) √ó {l' // l'.sizeof ‚â§ linear_order.max 1 l.sizeof}
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (G : set A) (hG : ‚àÄ (x : A), x ‚àà G ‚Üí is_integral R x) (x : A) (H : x ‚àà subring.closure G) : is_integral R x
{J : Type v} {C : Type u} [category_theory.category C] (F : category_theory.limits.wide_pushout_shape J ‚•§ C) : F ‚âÖ category_theory.limits.wide_pushout_shape.wide_span (F.obj option.none) (Œª (j : J), F.obj (option.some j)) (Œª (j : J), F.map (category_theory.limits.wide_pushout_shape.hom.init j))
{m : Type u_2} {R : Type u_7} {Œ± : Type v} {Œ≤ : Type w} [fintype m] [decidable_eq m] [comm_semiring R] [semiring Œ±] [semiring Œ≤] [algebra R Œ±] [algebra R Œ≤] (f : Œ± ‚Üí‚Çê[R] Œ≤) : matrix m m Œ± ‚Üí‚Çê[R] matrix m m Œ≤
{Œ± : Type u} {Œ≤ : Type v} [group Œ±] [mul_action Œ± Œ≤] (a : Œ±) : equiv.perm Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.limits.has_limits_of_size D] [category_theory.creates_limits_of_size F] : category_theory.limits.has_limits_of_size C
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] (f‚ÇÄ f‚ÇÅ : C(X, Y)) (S : set X) : Type (max u v)
{S : Type u_1} [has_add S] (a b : S) : Prop
 : ‚Ñù
{Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} [decidable_eq Œ±] (f : Œ† (a : Œ±), Œ≤ a) (a' : Œ±) (v : Œ≤ a') (a : Œ±) : Œ≤ a
(J : Type v) [category_theory.small_category J] : Type v
 : pos_num ‚Üí pos_num ‚Üí num
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} (p : Œπ ‚Üí P) : Prop
{X Y : AddCommGroup} (f : X ‚ü∂ Y) (hf : category_theory.mono f) : category_theory.normal_mono f
 : ¬¨summable (Œª (n : ‚Ñï), 1 / ‚Üën)
{Œ± : Type u_1} [measurable_space Œ±] (s : measure_theory.signed_measure Œ±) : measure_theory.measure Œ±
(o‚ÇÅ o‚ÇÇ : onote) : onote
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {Œπ : Type u_1} {c : complex_shape Œπ} {T : Type u_2} [category_theory.category T] (C : homological_complex (T ‚•§ V) c) : T ‚•§ homological_complex V c
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {G : C ‚•§ D} {K : category_theory.grothendieck_topology D} [category_theory.full G] [category_theory.faithful G] (Hld : category_theory.locally_cover_dense K G) : category_theory.grothendieck_topology C
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] [category_theory.limits.has_zero_object C] {X Y : C} (f : X ‚ü∂ Y) (hf : ‚àÄ (Z : C) (g : Y ‚ü∂ Z), f ‚â´ g = 0 ‚Üí g = 0) : category_theory.epi f
{R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N' : Type u_5} [add_comm_group N'] [module R N'] {Œπ : Type u_6} [decidable_eq Œπ] [fintype Œπ] : multilinear_map R (Œª (i : Œπ), M) N' ‚Üí+ alternating_map R M N' Œπ
{C : Type u} [category_theory.category C] {P Q : C} (f : P ‚ü∂ Q) (a : category_theory.over P) : category_theory.over Q
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] [ring_hom_surjective œÉ‚ÇÅ‚ÇÇ] [topological_space R‚ÇÅ] [topological_space R‚ÇÇ] [has_continuous_smul R‚ÇÅ M‚ÇÅ] [has_continuous_add M‚ÇÅ] [has_continuous_smul R‚ÇÇ M‚ÇÇ] [has_continuous_add M‚ÇÇ] (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : submodule R‚ÇÅ M‚ÇÅ) : submodule.map ‚Üëf s.topological_closure ‚â§ (submodule.map ‚Üëf s).topological_closure
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] {U : C} (R : category_theory.presieve U) (P : C·µí·µñ ‚•§ A) [category_theory.limits.has_products A] : A
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] {s : set E} : convex ùïú s ‚Üî ‚àÄ ‚¶Éa b : ùïú‚¶Ñ, 0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí a + b = 1 ‚Üí a ‚Ä¢ s + b ‚Ä¢ s ‚äÜ s
{M : Type u_1} [has_add M] {N : Type u_2} [has_add N] (f : add_hom M N) (hf : function.surjective ‚áëf) : f.srange = ‚ä§
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] [module.free R M] : Type v
(Œ± : Type u_7) (Œ≤ : Type u_8) [has_sup Œ±] [has_sup Œ≤] [has_bot Œ±] [has_bot Œ≤] : Type (max u_7 u_8)
{Œπ : Type u_1} {E : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), metric_space (E i)] (i : Œπ) : isometry (sigma.mk i)
(x : ‚Ñù) : real.cosh x = (real.exp x + real.exp (-x)) / 2
(n : ‚Ñï) : finset n.partition
(Œπ : Type u_1) (R : Type u_2) (M : Type u_3) [unique Œπ] [semiring R] [add_comm_monoid M] [module R M] : (Œπ ‚Üí M) ‚âÉ‚Çó[R] M
 : pSet ‚Üí pSet
{t : Type u ‚Üí Type u ‚Üí Type u} [bitraversable t] {F : Type u ‚Üí Type u} [applicative F] {Œ± Œ±' Œ≤ Œ≤' : Type u} (f : Œ± ‚Üí F Œ±') (f' : Œ≤ ‚Üí F Œ≤') : flip t Œ± Œ≤ ‚Üí F (flip t Œ±' Œ≤')
(h : expr) (ns : name_set) : tactic bool
{X : Top} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : category_theory.pairwise Œπ ‚Üí Top.presheaf.sheaf_condition.opens_le_cover U
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b : Œ±} : a ‚â§ -b ‚Üí b ‚â§ -a
{Œ± : Type u_1} {a b : Œ±} [partial_order Œ±] (h : a < b) : order_top ‚Ü•(set.Ioc a b)
{Œ± : Type u} [partial_order Œ±] {a b : Œ±} (h : a ‚â§ b) : b = a ‚à® a < b
(n : ‚Ñï) : ‚Üë(nat.fib n) = (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5
{Œ± : Type u_1} (x : Œ±) : free_monoid Œ±
 : tactic unit
(Œ± : Type u_1) : has_faithful_smul (equiv.perm Œ±) Œ±
{S : set ‚Ñï} (hb : 0 ‚àà S) (h_ind : ‚àÄ (k : ‚Ñï), k ‚àà S ‚Üí k + 1 ‚àà S) (n : ‚Ñï) : n ‚àà S
{E : Type u_1} [inner_product_space ‚Ñù E] {c : E} (f : cont_diff_bump_of_inner c) (x : E) : 0 ‚â§ ‚áëf x
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {A : set X} {f : X ‚Üí Y} {x : X} (h : ‚àÉ (y : Y), filter.tendsto f (nhds_within x A) (nhds y)) : filter.tendsto f (nhds_within x A) (nhds (extend_from A f x))
(R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] : finite_dimensional.finrank R M = fintype.card (module.free.choose_basis_index R M)
{R : Type u} [comm_semiring R] (p : ‚Ñï) (f : polynomial R) : polynomial R
{C : Type u} [category_theory.category C] {f g : category_theory.arrow C} [category_theory.limits.has_image f.hom] [category_theory.limits.has_image g.hom] (sq : f ‚ü∂ g) : Prop
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J·µí·µñ ‚•§ C·µí·µñ} (c : category_theory.limits.cone F.unop) : category_theory.limits.cocone F
(Œ± : Type u) : Type u
{X Y : Top} : Top.of (‚Ü•X √ó ‚Ü•Y) ‚ü∂ Y
{X Y : Type u} (e : X ‚âÉ Y) : X ‚âÖ Y
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G : J ‚•§ C} {s : category_theory.limits.cone F} {t : category_theory.limits.cone G} (P : category_theory.limits.is_limit s) (Q : category_theory.limits.is_limit t) (w : F ‚âÖ G) : s.X ‚âÖ t.X
(M : Type u_1) [sub_neg_monoid M] [measurable_space M] [has_measurable_add‚ÇÇ M] [has_measurable_neg M] : has_measurable_smul‚ÇÇ ‚Ñ§ M
{Œ± : Type u} (xs : list (‚Ñï+ √ó slim_check.gen Œ±)) (i : ‚Ñï) : i < (list.map (subtype.val ‚àò prod.fst) xs).sum ‚Üí slim_check.gen Œ±
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : (Œ± √ó Œ≤ ‚Üí Œ≥) ‚âÉ (Œ± ‚Üí Œ≤ ‚Üí Œ≥)
 : Type
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b : Œ±} : -a ‚â§ -b ‚Üí b ‚â§ a
{F : Type u_1} (Œ± : Type u_3) (Œ≤ : Type u_4) [linear_order Œ±] [lattice Œ≤] [order_hom_class F Œ± Œ≤] (f : F) : lattice_hom Œ± Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (f : option Œ± ‚Üí Œ≤ ‚Üí Œ≥) (as : list Œ±) (bs : list Œ≤) : list Œ≥ √ó list Œ±
{G : Type u_1} [add_group G] [topological_space G] (K‚ÇÄ : set G) : set (topological_space.compacts G ‚Üí ‚Ñù)
(G : Type u_1) [group G] : ‚Ñï ‚Üí subgroup G
(R : Type u_1) [monoid_with_zero R] : mul_action_with_zero R·µê·µí·µñ R
(A : Type u_1) {B : Type u_2} [field A] [ring B] [algebra A B] (x : B) {p : polynomial A} (pmonic : p.monic) (hp : ‚áë(polynomial.aeval x) p = 0) (pmin : ‚àÄ (q : polynomial A), q.monic ‚Üí ‚áë(polynomial.aeval x) q = 0 ‚Üí p.degree ‚â§ q.degree) : p = minpoly A x
{R : Type u} [comm_ring R] {g : polynomial R} (hg : g.monic) : power_basis R (adjoin_root g)
(M : Type u_2) [add_comm_monoid M] (S : Type u_1) [has_scalar S M] : Prop
{G : Type u_1} [group G] [topological_space G] (K‚ÇÄ : set G) : set (topological_space.compacts G ‚Üí ‚Ñù)
{Œ± : Type u_1} {Œ≤ : Type u_2} [denumerable Œ±] [denumerable Œ≤] : denumerable (Œ± √ó Œ≤)
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] : algebraic_geometry.LocallyRingedSpace
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] (p‚ÇÄ p‚ÇÅ : P1) : k ‚Üí·µÉ[k] P1
(Œ± : Type u_1) (Œ≤ : Type u_2) [has_mul Œ±] [comm_semigroup Œ≤] : (Œ± ‚Üí‚Çô* Œ≤) ‚Üí‚Çô* Œ± ‚Üí Œ≤
(V : Type u) [quiver V] [quiver.arborescence V] : V
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} (t : category_theory.limits.pullback_cone f g) (lift : Œ† (s : category_theory.limits.pullback_cone f g), s.X ‚ü∂ t.X) (fac_left : ‚àÄ (s : category_theory.limits.pullback_cone f g), lift s ‚â´ t.fst = s.fst) (fac_right : ‚àÄ (s : category_theory.limits.pullback_cone f g), lift s ‚â´ t.snd = s.snd) (uniq : ‚àÄ (s : category_theory.limits.pullback_cone f g) (m : s.X ‚ü∂ t.X), (‚àÄ (j : category_theory.limits.walking_cospan), m ‚â´ t.œÄ.app j = s.œÄ.app j) ‚Üí m = lift s) : category_theory.limits.is_limit t
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} (F : C ‚•§ D) {c : category_theory.limits.cocone K} (t : category_theory.limits.is_colimit c) [category_theory.limits.preserves_colimit K F] : category_theory.limits.is_colimit (F.map_cocone c)
{Œ∫ : Type w} (A : Type u) {B : Type v} (C : Type z) [comm_ring A] [comm_ring B] [algebra A B] [comm_ring C] [algebra A C] (b : Œ∫ ‚Üí B) : matrix Œ∫ (B ‚Üí‚Çê[A] C) C
{A : Type u_4} {B : Type u_5} {E : Type u_8} [add_monoid A] [add_monoid B] [add_comm_group E] [topological_space A] [topological_space B] [topological_space E] [topological_add_group E] (f : continuous_add_monoid_hom A E) (g : continuous_add_monoid_hom B E) : continuous_add_monoid_hom (A √ó B) E
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [add_comm_monoid M] [add_comm_monoid N] (f : M ‚Üí+ N) : (Œ± ‚Üí‚ÇÄ M) ‚Üí+ Œ± ‚Üí‚ÇÄ N
{ùïú : Type u_3} [field ùïú] {r : ‚Ñï} (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) (i : fin r ‚äï unit) {k : ‚Ñï} (hk : k ‚â§ r) : (list.drop k (matrix.pivot.list_transvec_col M)).prod.mul M (sum.inr ()) i = M (sum.inr ()) i
{n : ‚Ñï} {F : typevec n ‚Üí Type u_1} [mvfunctor F] (q : mvqpf F) : Prop
{Œ≤ : Type u_1} [add_comm_group Œ≤] (b : Œ≤) (V : Type u_2) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : category_theory.differential_object (category_theory.graded_object_with_shift b V) ‚•§ homological_complex V (complex_shape.up' b)
{Œ± : Type u} [topological_space Œ±] : ultrafilter Œ± ‚Üí Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f‚ÇÇ : ùïú ‚Üí F} {s‚ÇÇ : set ùïú} (hs : is_open s‚ÇÇ) : cont_diff_on ùïú ‚ä§ f‚ÇÇ s‚ÇÇ ‚Üî differentiable_on ùïú f‚ÇÇ s‚ÇÇ ‚àß cont_diff_on ùïú ‚ä§ (deriv f‚ÇÇ) s‚ÇÇ
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_le Œ±] [has_le Œ≤] (e : Œ± ‚âÉo Œ≤) : Œ± ‚Ü™o Œ≤
{R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [semiring R] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] [semi_normed_group E] [semi_normed_group E‚ÇÇ] [module R E] [module R‚ÇÇ E‚ÇÇ] (e : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) : E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ
(A : Type u_1) (B : Type u_2) [comm_semiring A] [comm_semiring B] [algebra A B] : mv_polynomial B A ‚Üí‚Çê[A] B
(Œ± : Type u) (Œ≤ : Type v) [group Œ±] [monoid Œ≤] [mul_distrib_mul_action Œ± Œ≤] : Œ± ‚Üí* mul_aut Œ≤
(Œ± : Type u_1) : Type u_1
(env : environment) (n : name) : list name
{Œ± Œ≤ : Lattice} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
 : algebraic_geometry.LocallyRingedSpace·µí·µñ ‚•§ CommRing
{Œ≤ : Type u} {Œ± : Type v} [comm_monoid Œ≤] [decidable_eq Œ±] (s : finset Œ±) {f : Œ± ‚Üí Œ≤} {a : Œ±} (h : f a = 1) : (s.erase a).prod (Œª (x : Œ±), f x) = s.prod (Œª (x : Œ±), f x)
{G : Type u_1} [group G] {s : set G} {x c : G} : x ‚àà group.conjugates_of_set s ‚Üí c * x * c‚Åª¬π ‚àà group.conjugates_of_set s
 : Top ‚•§ Locale
{Œ± : Type u_1} {Œ≤ : Type u_2} (p : pmf Œ±) (f : Œ† (a : Œ±), a ‚àà p.support ‚Üí pmf Œ≤) : pmf Œ≤
(C : Type u) [category_theory.category C] : category_theory.monad C ‚âå Mon_ (C ‚•§ C)
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] (K‚ÇÄ : topological_space.positive_compacts G) : measure_theory.measure G
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b c : Œ±} : a ‚â§ b * c ‚Üí b‚Åª¬π * a ‚â§ c
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R‚ÇÅ R‚ÇÇ : category_theory.presieve X} (h : R‚ÇÅ ‚â§ R‚ÇÇ) : category_theory.presieve.family_of_elements P R‚ÇÇ ‚Üí category_theory.presieve.family_of_elements P R‚ÇÅ
(Œ± : Type u_1) [measurable_space Œ±] : Type u_1
(Œ± : Type u) (Œ≤ : Type v) [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] (h : Œ± ‚ÜíùíÑ Œ≤) : Œ± ‚Üí Œ≤
(Œ± : Type u) : Type u
{R : Type u_1} [non_assoc_ring R] [nontrivial R] [no_zero_divisors R] (hR : ring_char R ‚â† 2) {a : R} : -a = a ‚Üî a = 0
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) {J : Type u} [category_theory.category J] (K : J ‚•§ D) : category_theory.limits.cones.functoriality K G ‚ãô adj.functoriality_left_adjoint K ‚ü∂ ùü≠ (category_theory.limits.cone K)
{G : Type u_1} [add_group G] {Œπ : Sort u_2} (S : Œπ ‚Üí add_subgroup G) {C : G ‚Üí Prop} {x : G} (hx : x ‚àà ‚®Ü (i : Œπ), S i) (hp : ‚àÄ (i : Œπ) (x : G), x ‚àà S i ‚Üí C x) (h1 : C 0) (hmul : ‚àÄ (x y : G), C x ‚Üí C y ‚Üí C (x + y)) : C x
 : Type
{n : Type u_1} {ùïú : Type u_3} [field ùïú] [decidable_eq n] [fintype n] (P : matrix n n ùïú ‚Üí Prop) (M : matrix n n ùïú) (hMdet : M.det ‚â† 0) (hdiag : ‚àÄ (D : n ‚Üí ùïú), (matrix.diagonal D).det ‚â† 0 ‚Üí P (matrix.diagonal D)) (htransvec : ‚àÄ (t : matrix.transvection_struct n ùïú), P t.to_matrix) (hmul : ‚àÄ (A B : matrix n n ùïú), A.det ‚â† 0 ‚Üí B.det ‚â† 0 ‚Üí P A ‚Üí P B ‚Üí P (A.mul B)) : P M
{V : Type u} (G : simple_graph V) (u v : V) : Prop
{K : Type u_1} [is_R_or_C K] : char_zero K
(R : Type u) (M : Type v) [ring R] [add_comm_group M] [module R M] (Œπ : Type u_1) [decidable_eq Œπ] : (Œπ ‚Üí‚ÇÄ M) ‚âÉ‚Çó[R] direct_sum Œπ (Œª (i : Œπ), M)
{S : Type u_2} [comm_ring S] {R : Type u_3} [comm_ring R] [algebra R S] {A : Type u_4} [comm_ring A] [algebra R A] [algebra S A] [is_scalar_tower R S A] {B : power_basis S A} (hB : is_integral R B.gen) [is_domain S] {x : A} (hx : ‚àÄ (i : fin B.dim), is_integral R (‚áë(‚áë(B.basis.repr) x) i)) (hmin : minpoly S B.gen = polynomial.map (algebra_map R S) (minpoly R B.gen)) (n : ‚Ñï) (i : fin B.dim) : is_integral R (‚áë(‚áë(B.basis.repr) (x ^ n)) i)
{M' : Type u_4} {Œ± : Type u_5} [monoid M'] [monoid Œ±] [mul_distrib_mul_action M' Œ±] (S : submonoid M') : mul_distrib_mul_action ‚Ü•S Œ±
(G : Type u_2) [group G] (n : ‚Ñï) : set (vector G n)
{R : Type u} {Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [decidable_eq Œπ] [comm_semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [topological_space M‚ÇÇ] (f : continuous_multilinear_map R M‚ÇÅ M‚ÇÇ) [fintype Œπ] (c : Œπ ‚Üí R) (m : Œ† (i : Œπ), M‚ÇÅ i) : ‚áëf (Œª (i : Œπ), c i ‚Ä¢ m i) = finset.univ.prod (Œª (i : Œπ), c i) ‚Ä¢ ‚áëf m
{J : Type v} {C : Type u} [category_theory.category C] {F : category_theory.limits.walking_parallel_family J ‚•§ C} (t : category_theory.limits.cocone F) : category_theory.limits.cotrident (Œª (j : J), F.map (category_theory.limits.walking_parallel_family.hom.line j))
{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ‚â† 0) : char.quadratic_char F (a ^ 2) = 1
{M : Type u_3} {N : Type u_4} [has_add M] [add_comm_semigroup N] : has_add (add_hom M N)
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} [discrete_topology ‚Ü•s] {x : Œ±} (hx : x ‚àà s) : nhds_within x s = has_pure.pure x
{Œ± : Type u_1} [canonically_linear_ordered_add_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b c : Œ±} (ha : add_le_cancellable a) (hb : add_le_cancellable b) (h : b ‚â§ a) : a - b < a - c ‚Üî c < b
{A : Type u_4} [comm_ring A] [is_domain A] {K : Type u_5} [field K] {L : Type u_7} [field L] [algebra A K] [is_fraction_ring A K] {g : A ‚Üí+* L} (hg : function.injective ‚áëg) (x : A) : ‚áë(is_fraction_ring.lift hg) (‚áë(algebra_map A K) x) = ‚áëg x
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) : o.oangle x y + o.oangle y x = 0
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [semigroup_with_zero Œ≤] : semigroup_with_zero Œ±
{X : Type u_1} [topological_space X] {Y : Type u_2} [topological_space Y] {f : Y ‚Üí X} {cont : continuous f} {A : discrete_quotient Y} {B : discrete_quotient X} (cond : discrete_quotient.le_comap cont A B) : ‚Ü•A ‚Üí ‚Ü•B
{Œ± : Type u_1} (l : lists' Œ± bool.tt) : lists Œ±
{R : Type u} [comm_ring R] (q : polynomial R) : polynomial R ‚Üí‚Çó[R] polynomial R
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s‚ÇÅ s‚ÇÇ : affine_subspace k P} (hd : s‚ÇÅ.direction = s‚ÇÇ.direction) (hn : ‚Üës‚ÇÅ.nonempty) (hle : s‚ÇÅ ‚â§ s‚ÇÇ) : s‚ÇÅ = s‚ÇÇ
{C : Type u‚ÇÅ} [category_theory.category C] {T‚ÇÅ T‚ÇÇ : category_theory.monad C} (h : T‚ÇÇ ‚ü∂ T‚ÇÅ) : T‚ÇÅ.algebra ‚•§ T‚ÇÇ.algebra
{R : Type u_1} {M : Type u_9} {M‚ÇÇ : Type u_11} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] (f : M ‚Üí M‚ÇÇ) (H : is_linear_map R f) : M ‚Üí‚Çó[R] M‚ÇÇ
{C : Type u} [category_theory.category C] [category_theory.concrete_category C] [category_theory.limits.has_limits C] [category_theory.reflects_isomorphisms (category_theory.concrete_category.forget C)] [category_theory.limits.preserves_limits (category_theory.concrete_category.forget C)] {X : Top} (F : Top.sheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) (V : topological_space.opens ‚Ü•X) (iUV : Œ† (i : Œπ), U i ‚ü∂ V) (hcover : V ‚â§ supr U) (s t : ‚Ü•(F.val.obj (opposite.op V))) (h : ‚àÄ (i : Œπ), ‚áë(F.val.map (iUV i).op) s = ‚áë(F.val.map (iUV i).op) t) : s = t
 : expr ‚Üí bool
{Œ± : Type u_1} {o p : part Œ±} (H1 : o.dom ‚Üî p.dom) (H2 : ‚àÄ (h‚ÇÅ : o.dom) (h‚ÇÇ : p.dom), o.get h‚ÇÅ = p.get h‚ÇÇ) : o = p
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (b : Œ≤) : vector.scanl f b vector.nil = b::·µ•vector.nil
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [linear_order Œ≤] {f : Œ± ‚Üí Œ≤} (h‚ÇÅ : strict_mono f) (A B : finset Œ±) : (finset.image f A).to_colex ‚â§ (finset.image f B).to_colex ‚Üî A.to_colex ‚â§ B.to_colex
{Œ± : Type u} [pseudo_emetric_space Œ±] {s : set Œ±} : continuous (Œª (x : Œ±), emetric.inf_edist x s)
 : pgame ‚Üí pgame ‚Üí Prop
 : complex_shape ‚Ñï
(R : Type u_1) {A : Type u_2} [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A] [invertible 2] : A ‚Üí‚Çó[R] ‚Ü•(skew_adjoint A)
{Œ± : Type u_1} [linear_ordered_field Œ±] {a b c d : Œ±} (hc : c ‚â† 0) (hd : d ‚â† 0) : (a * d - b * c) / (c * d) ‚â§ 0 ‚Üí a / c ‚â§ b / d
{Œ± : Type u_1} [topological_space Œ±] {U : set Œ±} {hU : is_open U} : ‚Üë‚ü®U, hU‚ü© = U
 : tactic.rewrite_search.side ‚Üí string
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ≤] [measurable_space Œ±] (f : Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {l : filter Œ±} (op : Œ≤ ‚Üí Œ≥) : l.germ Œ≤ ‚Üí l.germ Œ≥
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} [topological_space Œ±] (L : ‚àÄ (u : set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí (‚àÉ (t : set Œ±) (H : t ‚àà nhds x) (F : Œ± ‚Üí Œ≤), continuous_at F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u)) : continuous_at f x
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (t : category_theory.limits.is_terminal X) (Y : C) : Y ‚ü∂ X
{X : Type u_1} [topological_space X] [infinite X] [discrete_topology X] : ¬¨continuous ‚áë(cofinite_topology.of.symm)
(k : turing.partrec_to_TM2.K') : turing.partrec_to_TM2.stmt' ‚Üí turing.partrec_to_TM2.stmt'
{R : Type u} {M : Type v} (x : triv_sq_zero_ext R M) : R
{Œπ : Type u_1} {R : Type u_2} {M·µ¢ : Œπ ‚Üí Type u_7} [ring R] [Œ† (i : Œπ), add_comm_group (M·µ¢ i)] [Œ† (i : Œπ), module R (M·µ¢ i)] [fintype Œπ] (Q : Œ† (i : Œπ), quadratic_form R (M·µ¢ i)) : quadratic_form R (Œ† (i : Œπ), M·µ¢ i)
{ùïú : Type u_3} [is_R_or_C ùïú] {G : Type u_4} [normed_group G] [normed_space ùïú G] {f f' : ùïú ‚Üí G} {x : ùïú} (hder : ‚àÄ·∂† (y : ùïú) in nhds x, has_deriv_at f (f' y) y) (hcont : continuous_at f' x) : has_strict_deriv_at f (f' x) x
 : ‚Ñ§
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [mul_zero_one_class Œ≤] : mul_zero_one_class Œ±
{n : ‚Ñï} (a : fin (n + 1)) : ‚Üë(a.val) = a
{M : Type u_1} {G : Type u_2} [mul_one_class M] [comm_group G] : comm_group (M ‚Üí* G)
{g : equiv.perm (fin 5)} (ha : g ‚àà alternating_group (fin 5)) (h1 : g ‚â† 1) (h2 : ‚àÄ (n : ‚Ñï), n ‚àà g.cycle_type ‚Üí n = 2) : is_conj (equiv.swap 0 4 * equiv.swap 1 3) g
(C : Type u_1) [category_theory.category C] [category_theory.abelian C] : category_theory.simplicial_object C ‚•§ chain_complex C ‚Ñï
(e : interactive.parse interactive.types.texpr) (ids : interactive.parse interactive.types.with_ident_list) : tactic unit
{Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) : is_open_map Z.proj
{n : ‚Ñï} {A : Type u} (F : A ‚Üí typevec n ‚Üí Type u) [Œ† (Œ± : A), mvfunctor (F Œ±)] [Œ† (Œ± : A), mvqpf (F Œ±)] : mvpfunctor n
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [‚Ñ∞ : category_theory.category E] (F : C ‚•§ D) (G : D ‚•§ E) [category_theory.limits.preserves_limits_of_size (F ‚ãô G)] [category_theory.limits.reflects_limits_of_size G] : category_theory.limits.preserves_limits_of_size F
{Œ± : Type u_3} {Œ≤ : Type u_4} [lattice Œ±] [lattice Œ≤] [bounded_order Œ±] [bounded_order Œ≤] (f : bounded_lattice_hom Œ± Œ≤) : inf_top_hom Œ± Œ≤
{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {K : nnreal} {s : set Œ±} {f : Œ± ‚Üí Œ≤} : lipschitz_on_with K f s ‚Üí ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí has_dist.dist (f x) (f y) ‚â§ ‚ÜëK * has_dist.dist x y
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] {module_M : module R M} {module_M‚ÇÇ : module R‚ÇÇ M‚ÇÇ} {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} {re‚ÇÅ‚ÇÇ : ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ} {re‚ÇÇ‚ÇÅ : ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ} (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (g : M‚ÇÇ ‚Üí‚Çõ‚Çó[œÉ‚ÇÇ‚ÇÅ] M) (h‚ÇÅ : f.comp g = linear_map.id) (h‚ÇÇ : g.comp f = linear_map.id) : M ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ
{M : Type u_1} [has_mul M] {Œ≤ : Sort u_2} (c : con M) (f : M ‚Üí Œ≤) (h : ‚àÄ (a b : M), ‚áëc a b ‚Üí f a = f b) (x : M) : con.lift_on ‚Üëx f h = f x
 : fundamental_groupoid punit ‚âå category_theory.discrete punit
{R : Type u_2} {Œì‚ÇÄ : Type u_3} {Œì'‚ÇÄ : Type u_4} [linear_ordered_add_comm_monoid_with_top Œì‚ÇÄ] [linear_ordered_add_comm_monoid_with_top Œì'‚ÇÄ] [ring R] (v‚ÇÅ : add_valuation R Œì‚ÇÄ) (v‚ÇÇ : add_valuation R Œì'‚ÇÄ) : Prop
{R : Type u_1} [comm_ring R] {c‚ÇÅ c‚ÇÇ : R} (q : quaternion_algebra R c‚ÇÅ c‚ÇÇ) : ‚áëclifford_algebra_quaternion.of_quaternion (‚áëquaternion_algebra.conj q) = ‚áëclifford_algebra.involute (‚áëclifford_algebra.reverse (‚áëclifford_algebra_quaternion.of_quaternion q))
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ : X} (p‚ÇÄ p‚ÇÅ : path x‚ÇÄ x‚ÇÅ) : Type u
(Œ± : Type u) [uniform_space Œ±] : Type (u+1)
{ùïú : Type u_1} [linear_ordered_field ùïú] {s : set ùïú} {f : ùïú ‚Üí ùïú} (hs : convex ùïú s) (hf : ‚àÄ {x y z : ùïú}, x ‚àà s ‚Üí z ‚àà s ‚Üí x < y ‚Üí y < z ‚Üí (f z - f y) / (z - y) < (f y - f x) / (y - x)) : strict_concave_on ùïú s f
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddGroup) : category_theory.limits.cone F
{Œ± : Type u_1} {Œπ : Sort u_4} {l : filter Œ±} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí set Œ±} {t : set Œ±} (hl : l.has_basis p s) : t ‚àà l ‚Üî ‚àÉ (i : Œπ) (hi : p i), s i ‚äÜ t
{R : Type u} [ring R] (M : Module R) : category_theory.subobject M ‚âÉo submodule R ‚Ü•M
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_2} {Œ≥ : Type u_3} [Œ† (a : Œ±), add_comm_monoid (Œ≤ a)] (s : finset Œ≥) (g : Œ≥ ‚Üí Œ† (a : Œ±), Œ≤ a) : s.sum (Œª (c : Œ≥), g c) = Œª (a : Œ±), s.sum (Œª (c : Œ≥), g c a)
{R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group N] [module R N] [lie_ring_module L N] [lie_module R L N] (e : M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N) : ‚Ü•(lie_module.max_triv_submodule R L M) ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ ‚Ü•(lie_module.max_triv_submodule R L N)
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ : X} {p‚ÇÄ p‚ÇÅ q‚ÇÄ q‚ÇÅ : path x‚ÇÄ x‚ÇÅ} (F : p‚ÇÄ.homotopy p‚ÇÅ) (h‚ÇÄ : p‚ÇÄ = q‚ÇÄ) (h‚ÇÅ : p‚ÇÅ = q‚ÇÅ) : q‚ÇÄ.homotopy q‚ÇÅ
 : ‚Ñï ‚Üí vm name
{R : Type u_1} [comm_semiring R] {m : Type u_3} {n : Type u_4} [fintype n] (M : matrix m n R) : (n ‚Üí R) ‚Üí‚Çó[R] m ‚Üí R
 : tactic unit
(ids : interactive.parse (lean.parser.many lean.parser.ident)) : tactic.interactive.itactic
{n : ‚Ñï} : fin (n + 1) ‚âÉ option (fin n)
{Œ± : Type u_1} [ring Œ±] [invertible 2] : non_assoc_ring Œ±À¢ ∏·µê
{C : Type u} [category_theory.category C] {X : C} (hX : category_theory.limits.is_zero X) : category_theory.limits.is_terminal X
(Œ± : Type u_1) : set (equiv.perm Œ±)
(Œ± : Type u_2) [ordered_add_comm_monoid Œ±] : Prop
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] : (M ‚Üí* N) ‚âÉ (M·µê·µí·µñ ‚Üí* N·µê·µí·µñ)
 : expr ‚Üí ‚Ñï ‚Üí tactic (list expr √ó expr)
(a b : interactive.parse lean.parser.small_nat) (t : conv.interactive.itactic) : tactic unit
(Œ± : Type u_1) {n : ‚Ñï} : (typevec.repeat n.succ Œ±).drop.arrow (typevec.repeat n Œ±)
(K : Type u_4) (V : Type u) [division_ring K] [add_comm_group V] [module K V] : set V
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (x : Œ± (fin.last n)) (p : Œ† (i : fin n), Œ± (‚áëfin.cast_succ i)) (i : fin n) (y : Œ± (‚áëfin.cast_succ i)) : fin.snoc (function.update p i y) x = function.update (fin.snoc p x) (‚áëfin.cast_succ i) y
{X : Type u} [metric_space X] [compact_space X] [nonempty X] {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] : metric.Hausdorff_dist (set.range (Gromov_Hausdorff.optimal_GH_injl X Y)) (set.range (Gromov_Hausdorff.optimal_GH_injr X Y)) = Gromov_Hausdorff.GH_dist X Y
(Œ± : Type u_1) : Type u_1
{Œ± : Type u} [ordered_semiring Œ±] {a b c d : Œ±} [has_exists_add_of_le Œ±] (hba : b ‚â§ a) (hdc : d ‚â§ c) : a ‚Ä¢ d + b ‚Ä¢ c ‚â§ a ‚Ä¢ c + b ‚Ä¢ d
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] {M' : Type u_3} [add_comm_monoid M'] [module R M'] : (M ‚Üí‚Çó[R] M') ‚Üí‚Çó[R] module.dual R M' ‚Üí‚Çó[R] module.dual R M
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) : list (sigma Œ≤) ‚Üí option (Œ≤ a)
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x : V) : o.oangle x 0 = 0
 : expr ‚Üí tactic (expr √ó expr)
{Œ± : Type u} [pseudo_emetric_space Œ±] (Œ¥ : ‚Ñù) (E : set Œ±) : metric.thickening Œ¥ E = (Œª (x : Œ±), emetric.inf_edist x E) ‚Åª¬π' set.Iio (ennreal.of_real Œ¥)
 : cardinal ‚Ü™o cardinal
{M : Type u_3} {S : Type u_4} [div_inv_monoid M] [set_like S M] [hSM : subgroup_class S M] {H : S} {x y : M} (hx : x ‚àà H) (hy : y ‚àà H) : x / y ‚àà H
{Œ± : Type u_2} {G : Type u_6} [comm_monoid Œ±] [comm_group G] {A : set Œ±} {n : ‚Ñï} : has_inv (A ‚Üí*[n] G)
{ùïú : Type u_1} [linear_ordered_field ùïú] {s : set ùïú} {f : ùïú ‚Üí ùïú} (hf : strict_convex_on ùïú s f) {x y z : ùïú} (hx : x ‚àà s) (hz : z ‚àà s) (hxy : x < y) (hyz : y < z) : (f y - f x) / (y - x) < (f z - f y) / (z - y)
{Œ± : Type u_1} {M : Type u_5} [has_one M] (f : Œ± ‚Üí M) : set Œ±
(Œ± : Type u_1) [topological_space Œ±] : cocompact_map Œ± Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (p : set Œ≤) (f : initial_seg r s) (H : ‚àÄ (a : Œ±), ‚áëf a ‚àà p) : initial_seg r (subrel s p)
{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] (x : R) : is_algebraic R (‚áë(algebra_map R A) x)
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [has_one M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñï] [has_inv M‚ÇÅ] [has_div M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñ§] [division_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (inv : ‚àÄ (x : M‚ÇÅ), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : M‚ÇÅ), f (x / y) = f x / f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (x ^ n) = f x ^ n) : division_monoid M‚ÇÅ
{G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order x‚Åª¬π
 : cardinal ‚Üí+ enat
{Œ± : Type u} [linear_order Œ±] {x y : Œ±} : x < y ‚à® y < x ‚Üî x ‚â† y
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Prop
(n : ‚Ñï) : ‚àÉ (a b c d : ‚Ñï), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n
{L : first_order.language} {T : L.Theory} {M : Type w} [LM : L.Structure M] [ne : nonempty M] (h : M ‚ä® T) : T.Model
{K : Type v} {L : Type w} [field K] [field L] (i : K ‚Üí+* L) (f : polynomial K) : Prop
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) [complete_space ‚Ü•K] : reflection K * reflection K = 1
{V : Type u} (G : simple_graph V) : V ‚Üí V ‚Üí Type u
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [category_theory.is_iso f] [category_theory.limits.has_kernel g] : category_theory.limits.kernel (f ‚â´ g) ‚âÖ category_theory.limits.kernel g
{Œ± : Type u_1} {Œ≤ : Type u_2} (s : multiset Œ±) (t : multiset Œ≤) : multiset (Œ± √ó Œ≤)
(R : Type u) (Œπ : Type v) [comm_ring R] (L : Type w‚ÇÅ) (M : Œπ ‚Üí Type w) [lie_ring L] [lie_algebra R L] [Œ† (i : Œπ), add_comm_group (M i)] [Œ† (i : Œπ), module R (M i)] [Œ† (i : Œπ), lie_ring_module L (M i)] [Œ† (i : Œπ), lie_module R L (M i)] [decidable_eq Œπ] (j : Œπ) : M j ‚Üí‚Çó‚ÅÖR,L‚ÅÜ direct_sum Œπ (Œª (i : Œπ), M i)
(hs : list expr) : tactic (list name_set)
{Œ± : Type u_1} (Œ≤ : Type u_2) [add_comm_group Œ≤] (a : free_abelian_group Œ±) : (Œ± ‚Üí Œ≤) ‚Üí+ Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type v} (f : J ‚Üí C) [category_theory.limits.has_coproduct f] [category_theory.limits.has_coproduct (Œª (j : J), G.obj (f j))] [i : category_theory.is_iso (category_theory.limits.sigma_comparison G f)] : category_theory.limits.preserves_colimit (category_theory.discrete.functor f) G
(K : Type u) {L : Type v} (E : Type z) [field K] [field L] [field E] [algebra K L] [algebra K E] [module.finite K L] [is_alg_closed E] (pb : power_basis K L) (e : fin pb.dim ‚âÉ (L ‚Üí‚Çê[K] E)) [is_separable K L] : ‚áë(algebra_map K E) (algebra.discr K ‚áë(pb.basis)) = finset.univ.prod (Œª (i : fin pb.dim), (finset.filter (Œª (j : fin pb.dim), i < j) finset.univ).prod (Œª (j : fin pb.dim), (‚áë(‚áëe j) pb.gen - ‚áë(‚áëe i) pb.gen) ^ 2))
{R : Type u} : R ‚Üí tropical R
{Œ± : Type u} [topological_space Œ±] (K : compact_exhaustion Œ±) (x : Œ±) : ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (h : Œ± ‚âÉ‚Çú Œ≤) : Œ≤ ‚Üí Œ±
{a b : cardinal} (ha : cardinal.aleph_0 ‚â§ a) : a + b = linear_order.max a b
{Œπ : Type u_1} {Œ± : Type u_3} {Œ≤ : Type u_4} [preorder Œ±] [preorder Œ≤] (f : Œπ ‚Üí Œ±) (g : Œπ ‚Üí Œ≤) (s : set Œπ) : Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] (f : E ‚ÜíL[ùïú] F ‚ÜíL[ùïú] G) : continuous_multilinear_map ùïú (Œª (i : fin 2), E √ó F) G
{C : Type u‚ÇÅ} (D : Type u‚ÇÇ) [category_theory.category D] (F : C ‚Üí D) : Type u‚ÇÅ
{S : Type u_2} [comm_ring S] {R : Type u_3} [comm_ring R] [algebra R S] {A : Type u_4} [comm_ring A] [algebra R A] [algebra S A] [is_scalar_tower R S A] {B : power_basis S A} (hB : is_integral R B.gen) [is_domain S] {x y : A} (hx : ‚àÄ (i : fin B.dim), is_integral R (‚áë(‚áë(B.basis.repr) x) i)) (hy : ‚àÄ (i : fin B.dim), is_integral R (‚áë(‚áë(B.basis.repr) y) i)) (hmin : minpoly S B.gen = polynomial.map (algebra_map R S) (minpoly R B.gen)) (i : fin B.dim) : is_integral R (‚áë(‚áë(B.basis.repr) (x * y)) i)
{R : Type u} {Œπ : Type u'} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [semiring R] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] {M‚ÇÅ' : Œπ ‚Üí Type u_1} [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ' i)] [Œ† (i : Œπ), module R (M‚ÇÅ' i)] (g : multilinear_map R M‚ÇÅ' M‚ÇÇ) : g.comp_linear_map (Œª (i : Œπ), linear_map.id) = g
{a : ennreal} (h : a ‚â† ‚ä§) : add_le_cancellable a
{B : Type u‚ÇÅ} [comm_ring B] (r : B ‚Üí B ‚Üí Prop) : ring_quot r ‚âÉ+* B ‚ß∏ ideal.of_rel r
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [monoid Œ≤] [has_continuous_mul Œ≤] : C(Œ±, Œ≤) ‚Üí* Œ± ‚Üí Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] [compact_space Œ±] [separated_space Œ±] {f : Œ± ‚Üí Œ≤} (h : continuous f) : uniform_continuous f
(Œ± : Type u_1) (Œ≤ : Type u_2) [linear_order Œ±] [linear_order Œ≤] [encodable Œ±] [densely_ordered Œ≤] [nontrivial Œ≤] : nonempty (Œ± ‚Ü™o Œ≤)
(Œ± : Type u) [topological_space Œ±] : Prop
{p q : Prop} : psum unit (p ‚Üí q) ‚Üí psum unit p ‚Üí psum unit q
 : (user_attribute unit)
 : category_theory.limits.walking_parallel_pair ‚Üí category_theory.limits.walking_parallel_pair ‚Üí Type v
(L : first_order.language) {M : Type w} [L.Structure M] : lower_adjoint coe
 : environment ‚Üí name ‚Üí bool
(C : Type u‚ÇÅ) [category_theory.category C] : category_theory.quotient (category_theory.paths_hom_rel C) ‚âå C
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] : topological_group (L ‚âÉ‚Çê[K] L)
{C : Type u} [category_theory.category C] {M : Type u_1} [category_theory.category M] [category_theory.monoidal_category M] (F : category_theory.monoidal_functor M (C ‚•§ C)) (m n : M) (h‚ÇÅ : m ‚äó n ‚âÖ ùüô_ M) (h‚ÇÇ : n ‚äó m ‚âÖ ùüô_ M) (H : (h‚ÇÅ.hom ‚äó ùüô m) ‚â´ (Œª_ m).hom = (Œ±_ m n m).hom ‚â´ (ùüô m ‚äó h‚ÇÇ.hom) ‚â´ (œÅ_ m).hom) : C ‚âå C
{Œ± : Type u} [non_unital_ring Œ±] {a b c : Œ±} (h : a ‚à£ c) : a ‚à£ b + c ‚Üî a ‚à£ b
{Œπ : Type u_1} {R : Type u_2} {M : Œπ ‚Üí Type u_4} {N : Type u_5} [semiring R] [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] [add_comm_monoid N] [module R N] : add_comm_monoid (Œ†‚ÇÄ (i : Œπ), M i ‚Üí‚Çó[R] N)
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} {x‚ÇÅ x‚ÇÇ : category_theory.presieve.family_of_elements P ‚áë(category_theory.sieve.generate R)} (t‚ÇÅ : x‚ÇÅ.compatible) (t‚ÇÇ : x‚ÇÇ.compatible) : category_theory.presieve.family_of_elements.restrict _ x‚ÇÅ = category_theory.presieve.family_of_elements.restrict _ x‚ÇÇ ‚Üí x‚ÇÅ = x‚ÇÇ
 : environment ‚Üí name ‚Üí bool
{m : Type u ‚Üí Type u} [monad m] {Œ± : Type u} (xs : tactic.mllist m Œ±) : m (ulift bool)
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : set Œ±) (t : set Œ≤) : Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {s : set E} {f : E ‚Üí F} (hf : cont_diff_on ùïú n f s) : cont_diff_on ùïú n (Œª (x : E), -f x) s
{Œπ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Œπ ‚Üí set X} {s : set X} (c : set (shrinking_lemma.partial_refinement u s)) : set Œπ
{Œ± Œ≤ : Type u} (f : free_abelian_group (Œ± ‚Üí Œ≤)) : free_abelian_group Œ± ‚Üí+ free_abelian_group Œ≤
(Œ± : Type u_1) [monoid Œ±] : mul_action Œ±·µê·µí·µñ Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] (X : algebraic_geometry.PresheafedSpace C) (x : ‚Ü•X) : C
(Œ± : Type u) [preorder Œ±] : Type (max 1 u)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.split_mono category_theory.limits.coprod.inr
 : list ‚Ñï ‚Üí ‚Ñï ‚Üí list ‚Ñï
{Œ± : Type u_1} [denumerable Œ±] : denumerable (ulift Œ±)
{F G : Type u} [add_group F] [add_group G] [fintype F] (f : F ‚Üí+ G) [f.range.normal] [fintype (G ‚ß∏ f.range)] : fintype G
{Œ± : Type u_1} : subsingleton (vector Œ± 0)
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] {a b : Œ±} (h : a < b) (s : set Œ±) : [s ‚àà nhds_within b (set.Iio b), s ‚àà nhds_within b (set.Ico a b), s ‚àà nhds_within b (set.Ioo a b), ‚àÉ (l : Œ±) (H : l ‚àà set.Ico a b), set.Ioo l b ‚äÜ s, ‚àÉ (l : Œ±) (H : l ‚àà set.Iio b), set.Ioo l b ‚äÜ s].tfae
{Œ± : Type u_2} {Œ≤ : Type u_3} {f : Œ± ‚Üí Œ≤} (hf : function.injective f) : filter.tendsto f filter.cofinite filter.cofinite
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] {x : Œ±} : continuous (Œª (f : bounded_continuous_function Œ± Œ≤), ‚áëf x)
{Œ≥ : Type w} [metric_space Œ≥] {x y : Œ≥} : has_nndist.nndist x y = 0 ‚Üí x = y
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) : submodule ùïú E
{R : Type u_1} {M : Type u_2} [add_comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (add_monoid_algebra R M)] : add_monoid.fg M
{Œ± : Type u_1} [add_comm_monoid Œ±] [topological_space Œ±] {Œ≤ : Type u_2} (f : Œ≤ ‚Üí Œ±) : Œ±
{X Y : Compactum} (f : ‚Ü•X ‚Üí ‚Ü•Y) (cont : continuous f) : X ‚ü∂ Y
{Œ± : Type u_1} (s : set (set Œ±)) : measurable_space.dynkin_system Œ±
{Œ± : Type u_1} {M : Type u_5} {R : Type u_11} [semiring R] [add_comm_monoid M] [distrib_mul_action R M] (a : Œ±) : M ‚Üí+[R] Œ± ‚Üí‚ÇÄ M
{C : Type u} [category_theory.category C] {F : category_theory.limits.walking_parallel_pair ‚•§ C} (t : category_theory.limits.fork (F.map category_theory.limits.walking_parallel_pair_hom.left) (F.map category_theory.limits.walking_parallel_pair_hom.right)) : category_theory.limits.cone F
{R : Type u} {L : Type v} {L' : Type w‚ÇÇ} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L') : lie_ideal R L
{p : Prop} : slim_check.test_result p ‚Üí bool
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D E : homological_complex V c} (f : homotopy_equiv C D) (g : homotopy_equiv D E) : homotopy_equiv C E
{Œ± : Type u} {Œ≤ : Type v} [non_assoc_ring Œ±] [has_zero Œ≤] [has_one Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ≤), f (-x) = -f x) (sub : ‚àÄ (x y : Œ≤), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (gsmul : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_assoc_ring Œ≤
{C : Type u} [category_theory.category C] [category_theory.limits.has_images C] [category_theory.limits.has_image_maps C] : category_theory.arrow C ‚•§ C
{Œ± : Type u} [topological_space Œ±] (x : Œ±) [(nhds_within x {x}·∂ú).ne_bot] : interior {x} = ‚àÖ
{m : Type u_1} {n : Type u_2} {R : Type u_3} {S : Type u_4} [comm_semiring R] [comm_semiring S] (f : R ‚Üí+* S) (A : matrix m n S) : (matrix.mv_polynomial_X m n R).map (mv_polynomial.eval‚ÇÇ f (Œª (p : m √ó n), A p.fst p.snd)) = A
 : add_hom ‚Ñï+ ‚Ñï
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M ‚Üí* P} (hg : ‚àÄ (y : ‚Ü•S), is_unit (‚áëg ‚Üëy)) (x : M) (y : ‚Ü•S) : ‚áë(f.lift hg) (f.mk' x y) = ‚áëg x * ‚Üë(‚áë(is_unit.lift_right (g.restrict S) hg) y)‚Åª¬π
{L : first_order.language} {L' : first_order.language} (œï : L ‚Üí·¥∏ L') (M : Type u_1) [L'.Structure M] : L.Structure M
(R : Type u_1) [semiring R] : (polynomial R)·µê·µí·µñ ‚âÉ+* polynomial R·µê·µí·µñ
 : ‚Ñï
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] (f : pseudo_epimorphism Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : pseudo_epimorphism Œ± Œ≤
 : tactic unit
 : expr ‚Üí tactic expr
{Œ± : Type uu} [decidable_eq Œ±] {l‚ÇÅ l‚ÇÇ : list Œ±} (h : ‚àÄ (x : Œ±), x ‚àà l‚ÇÅ ‚Üí list.count x l‚ÇÅ ‚â§ list.count x l‚ÇÇ) : l‚ÇÅ ++ l‚ÇÇ.diff l‚ÇÅ ~ l‚ÇÇ
(C : Type u) [category_theory.category C] : Prop
{Œ± : Type u} {f g : Œ± ‚Üí Œ±} (h : function.commute f g) : set.inv_on f g (function.fixed_points (f ‚àò g)) (function.fixed_points (f ‚àò g))
{m : Type u ‚Üí Type u} [monad m] [alternative m] {Œ± : Type u} (L : tactic.mllist m Œ±) : m Œ±
(K : Type u_1) (J : Type u_2) [field K] [field J] (L : Type v) (M : Type w) [field L] [field M] [algebra K M] [is_alg_closure K M] [algebra K J] [algebra J L] [is_alg_closure J L] [algebra K L] [is_scalar_tower K J L] (hKJ : algebra.is_algebraic K J) : L ‚âÉ‚Çê[K] M
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (p1 p2 : P) : euclidean_geometry.angle p1 p2 p2 = real.pi / 2
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} (C : homological_complex V c) : homotopy_equiv C C
(Œ± : Type u) (Œ≤ : Type v) [topological_space Œ±] [pseudo_metric_space Œ≤] : Type (max u v)
{Œ± : Type u} [uniform_space Œ±] (f : filter Œ±) : Prop
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) : 2 ‚Ä¢ hb.oangle x (-y) = 2 ‚Ä¢ hb.oangle x y
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] (D : J ‚•§ T.algebra) (c : category_theory.limits.cone (D ‚ãô T.forget)) (t : category_theory.limits.is_limit c) : category_theory.limits.cone D
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ‚•§ D) : algebraic_geometry.PresheafedSpace C ‚•§ algebraic_geometry.PresheafedSpace D
(Œ± : Type u_1) [monoid Œ±] : Type u_1
{R : Type u_1} [comm_semiring R] {A : Type u_2} [comm_semiring A] [algebra R A] {M : Type u_3} [add_comm_monoid M] [module A M] [module R M] : derivation R A M ‚Üí+ A ‚Üí M
 : Type
{Œ± : Type u_1} [preorder Œ±] {a b : Œ±} (h : a ‚â§ b) : set.Iio a ‚äÜ set.Iic b
{R : Type u_1} {a : R} [monoid R] (n : ‚Ñï) (ra : is_regular a) : is_regular (a ^ n)
{Œ± : Type u_2} {Œ≤ : Type u_3} [ring Œ±] [is_domain Œ±] [ring Œ≤] (f : Œ≤ ‚Üí+* Œ±) (hf : function.injective ‚áëf) : is_domain Œ≤
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [conditionally_complete_linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] [nonempty Œ≥] {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±} (Cf : continuous_at f (‚®Ö (i : Œ≥), g i)) (Mf : monotone f) (H : bdd_below (set.range g)) : f (‚®Ö (i : Œ≥), g i) = ‚®Ö (i : Œ≥), f (g i)
{L : first_order.language} (r : L.relations 2) : L.sentence
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [ring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [nonempty Œπ] (f : multilinear_map R M‚ÇÅ M‚ÇÇ) : sub_mul_action R M‚ÇÇ
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : Z.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : (category_theory.limits.pullback f g).open_cover
(M : Type u) : Type u
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) (h : fintype.card Œ≤ < fintype.card Œ±) : ‚àÉ (x y : Œ±), x ‚â† y ‚àß f x = f y
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {n : ‚Ñï} (hn : finite_dimensional.finrank K V = n.succ) : nontrivial V
(ic : tactic.instance_cache) (e : expr) : tactic (tactic.instance_cache √ó expr √ó expr)
{R : Type u} [semiring R] (p : polynomial R) (a : R) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} (b : Œ≤) (f : Œ± ‚Üí Œ≤) : option Œ± ‚Üí Œ≤
(p : ennreal) [fact (1 ‚â§ p)] (n : ‚Ñ§) : ‚Ü•(measure_theory.Lp ‚ÑÇ p haar_circle)
{Œ± : Type u} {Œ≤ : Type v} [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
(R : Type u) {n : ‚Ñï} (M : fin n.succ ‚Üí Type v) (M‚ÇÇ : Type v‚ÇÇ) [comm_semiring R] [Œ† (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : fin n.succ), module R (M i)] [module R M‚ÇÇ] : multilinear_map R (Œª (i : fin n), M (‚áëfin.cast_succ i)) (M (fin.last n) ‚Üí‚Çó[R] M‚ÇÇ) ‚âÉ‚Çó[R] multilinear_map R M M‚ÇÇ
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : continuous_at f b) : deriv (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in a..u, f x) b = f b
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} : mvqpf.fix F Œ± ‚Üí (mvqpf.P F).W Œ±
(C : Type u_1) [category_theory.category C] : ùü≠ (category_theory.idempotents.karoubi C) ‚âÖ category_theory.idempotents.to_karoubi (category_theory.idempotents.karoubi C) ‚ãô category_theory.idempotents.karoubi_karoubi.inverse C
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (h : r ‚Ü™r s) : Œ± ‚Üí Œ≤
{B : Type u‚ÇÅ} [quiver B] {C : Type u‚ÇÇ} [category_theory.bicategory C] (F : prefunctor B C) {a b : B} {f g : category_theory.free_bicategory.hom a b} : category_theory.free_bicategory.hom‚ÇÇ f g ‚Üí (category_theory.free_bicategory.lift_hom F f ‚ü∂ category_theory.free_bicategory.lift_hom F g)
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {R' : Type} [comm_semiring R'] [algebra R' R] [module R' M] [is_scalar_tower R' R M] (f : R ‚Üí‚Çó[R'] R') (B : bilin_form R M) : bilin_form R' M
{Œπ : Type u_1} [fintype Œπ] {Œ± : Type u_2} [add_group Œ±] [measure_theory.measure_space Œ±] [measure_theory.sigma_finite measure_theory.measure_space.volume] [has_measurable_add Œ±] [measure_theory.measure_space.volume.is_add_left_invariant] : measure_theory.measure_space.volume.is_add_left_invariant
{Œ± : Type u} {g : Type} [random_gen g] [preorder Œ±] [bounded_random Œ±] (x y : Œ±) (h : x ‚â§ y) : rand_g g (stream ‚Ü•(set.Icc x y))
{R : Type u} [semiring R] (p q : polynomial R) (n : ‚Ñï) : (p * q).coeff n = (finset.nat.antidiagonal n).sum (Œª (x : ‚Ñï √ó ‚Ñï), p.coeff x.fst * q.coeff x.snd)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] [has_zero Œ≤] (f : zero_at_infty_continuous_map Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : zero_at_infty_continuous_map Œ± Œ≤
(k : ‚Ñï) {n : ‚Ñï} : fin2 n ‚Üí fin2 (k + n)
 : native.float ‚Üí native.float ‚Üí native.float
{n : Type u} {R : Type v} [decidable_eq n] [fintype n] [linear_ordered_comm_ring R] [fact (even (fintype.card n))] : has_neg ‚Ü•(matrix.GL_pos n R)
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] {D : Type u‚ÇÉ} [category_theory.bicategory D] (F : category_theory.pseudofunctor B C) (G : category_theory.pseudofunctor C D) : category_theory.pseudofunctor B D
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] (o : option Œ±) : option Œ±
{n : ‚Ñï} (i : bitvec n) : fin (2 ^ n)
{M : Type u_1} [monoid M] : smul_comm_class M ‚Ü•(submonoid.center M) M
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} (n' m : ‚Ñï) : L.bounded_formula Œ± n ‚Üí L.bounded_formula Œ± (n + n')
(cl : tactic.closure) : tactic (expr_map (list (expr √ó expr)))
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : Top} (f : X ‚ü∂ Y) [category_theory.limits.has_products C] {F : Top.presheaf C X} (h : F.is_sheaf) : (f _* F).is_sheaf
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (F : C ‚•§ D) : C ‚•§ ‚Ü•(F.ess_image)
(n : ‚Ñï) : filter.tendsto (Œª (x : ‚Ñù), x ^ n * real.exp (-x)) filter.at_top (nhds 0)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p : P) (h : s.sum (Œª (i : Œπ), w i) = 1) : ‚áë(s.affine_combination (Œª (_x : Œπ), p)) w = p
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] [nonempty Œ±] {s : set Œ±} (hs : is_compact s) : bdd_below s
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : continuous proj
{S : Type u‚ÇÅ} {L : Type u‚ÇÇ} (D : Type u‚ÇÉ) [category_theory.category S] [category_theory.category L] [category_theory.category D] (Œπ : S ‚•§ L) [‚àÄ (X : L), category_theory.limits.has_colimits_of_shape (category_theory.costructured_arrow Œπ X) D] : category_theory.Lan Œπ ‚ä£ (category_theory.whiskering_left S L D).obj Œπ
(B : Type u‚ÇÅ) [category_theory.bicategory B] (C : Type u‚ÇÇ) [category_theory.bicategory C] : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ w‚ÇÅ w‚ÇÇ)
{Œ± : Type u_1} [topological_space Œ±] [non_assoc_ring Œ±] [has_continuous_mul Œ±] : has_continuous_neg Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cone F} : category_theory.limits.is_limit t ‚âÉ category_theory.limits.is_colimit t.op
{Œ± : Type u} [pseudo_emetric_space Œ±] {Œ¥ : ‚Ñù} (E : set Œ±) : E ‚äÜ metric.cthickening Œ¥ E
{Œ± : Type u_4} {Œ≤ : Type u_5} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) : Type (max u_4 u_5)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : P} {s : set P} (hp : p ‚àà s) : p ‚àà affine_span k s
(Œ± : Type u_1) (Œ≤ : Type u_2) [add_zero_class Œ≤] : Œ≤ ‚Üí+ Œ± ‚Üí Œ≤
{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A) : S.is_algebraic ‚Üî algebra.is_algebraic R ‚Ü•S
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {Œπ : Type u_6} (Z : topological_vector_bundle_core R B F Œπ) : Type u_6
{Œ± : Type u_1} : partial_order (part Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (G : C ‚•§ D) [G.preserves_zero_morphisms] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_cokernel f] [category_theory.limits.has_cokernel (G.map f)] [category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f 0) G] : G.obj (category_theory.limits.cokernel f) ‚âÖ category_theory.limits.cokernel (G.map f)
(f : name) (args : list expr) : tactic.ring_exp.ring_exp_m expr
(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_pushouts C] : category_theory.limits.has_binary_coproducts C
(ùïú : Type u_1) (E : Type u_2) [is_R_or_C ùïú] [inner_product_space ùïú E] : E ‚Üí‚Çó·µ¢‚ãÜ[ùïú] normed_space.dual ùïú E
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {F : C ‚•§ D} {Y : D} (h : Y ‚àà F.ess_image) : F.obj (category_theory.functor.ess_image.witness h) ‚âÖ Y
{Œì : Type u_1} [inhabited Œì] : list Œì ‚Üí turing.list_blank Œì ‚Üí turing.list_blank Œì
{p q : Prop} : slim_check.test_result p ‚Üí slim_check.test_result q ‚Üí slim_check.test_result (p ‚àß q)
{Œ± : Type u_1} (s : seq Œ±) : computation (list Œ±)
{A : Type u_1} {B : Type u_2} [comm_ring A] [comm_ring B] (f : A ‚Üí+* B) : Prop
{Œ± : Type u_1} (c : set (set Œ±)) : Prop
{R : Type u_1} [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {C : tensor_algebra R M ‚Üí Prop} (h_grade0 : ‚àÄ (r : R), C (‚áë(algebra_map R (tensor_algebra R M)) r)) (h_grade1 : ‚àÄ (x : M), C (‚áë(tensor_algebra.Œπ R) x)) (h_mul : ‚àÄ (a b : tensor_algebra R M), C a ‚Üí C b ‚Üí C (a * b)) (h_add : ‚àÄ (a b : tensor_algebra R M), C a ‚Üí C b ‚Üí C (a + b)) (a : tensor_algebra R M) : C a
{C : Type u} [category_theory.category C] (ùí¢ : set C) : Prop
{R : Type u} {M : Type v} [comm_ring R] [add_comm_group M] [module R M] (N P : submodule R M) : ideal R
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [preorder Œ±] [t : order_closed_topology Œ±] {f g : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} [b.ne_bot] (hf : filter.tendsto f b (nhds a‚ÇÅ)) (hg : filter.tendsto g b (nhds a‚ÇÇ)) (h : f ‚â§·∂†[b] g) : a‚ÇÅ ‚â§ a‚ÇÇ
{Œ± : Type u_1} [linear_order Œ±] [decidable_eq Œ±] {p : finset Œ± ‚Üí Prop} (s : finset Œ±) (h0 : p ‚àÖ) (step : ‚àÄ (a : Œ±) (s : finset Œ±), (‚àÄ (x : Œ±), x ‚àà s ‚Üí x < a) ‚Üí p s ‚Üí p (has_insert.insert a s)) : p s
{R : Type u_1} [comm_ring R] (g : matrix.special_linear_group (fin 2) R) : is_coprime (‚Üëg 1 0) (‚Üëg 1 1)
(Œ± : Type u) [preorder Œ±] [nonempty Œ±] [no_min_order Œ±] [no_max_order Œ±] : ‚àÉ (f : ‚Ñ§ ‚Üí Œ±), strict_anti f
(R : Type u_1) [semiring R] (n : ‚Ñï) : ‚Ü•(polynomial.degree_lt R n) ‚âÉ‚Çó[R] fin n ‚Üí R
(G : Type u) [add_comm_group G] : AddCommGroup
(Œ± : Type u) : Type u
{Œ± : Type u} : ordnode Œ± ‚Üí option (Œ± √ó ordnode Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] : (ùü≠ C).map_Mat_ ‚âÖ ùü≠ (category_theory.Mat_ C)
{C : Type u} [category_theory.category C] (X Y : C) : Prop
 : tactic unit
{Œ± : Type u_2} {Œ≤ : Type u_3} [non_assoc_semiring Œ±] [preorder Œ±] [non_assoc_semiring Œ≤] [preorder Œ≤] (f : Œ± ‚âÉ+*o Œ≤) : Œ± ‚Üí+*o Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [uniform_space Œ±] [uniform_space Œ≤] [separated_space Œ±] [locally_compact_space Œ±] [compact_space Œ≤] [separated_space Œ≤] [uniform_space Œ≥] (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (h : continuous ‚Üøf) (x : Œ±) : tendsto_uniformly f (f x) (nhds x)
{Œ± : Type u_1} (op : Œ± ‚Üí Œ± ‚Üí Œ±) [hc : is_commutative Œ± op] [ha : is_associative Œ± op] : Œ± ‚Üí multiset Œ± ‚Üí Œ±
{Œ± : Sort u} : Œ± ‚Üí plift Œ±
{R : Type u_1} [semiring R] {C : Type u_2} {D : Type u_3} [category_theory.category C] [category_theory.category D] [category_theory.preadditive D] [category_theory.linear R D] {F G : C ‚•§ D} (X : C) : (F ‚ü∂ G) ‚Üí‚Çó[R] F.obj X ‚ü∂ G.obj X
{K : Type u_1} [field K] [number_field K] : number_field.class_number K = 1 ‚Üî is_principal_ideal_ring ‚Ü•(number_field.ring_of_integers K)
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] {J : category_theory.grothendieck_topology C} (‚Ñ± : category_theory.Sheaf J A) (E : A) : category_theory.SheafOfTypes J
{ùïú : Type u} [hnorm : nondiscrete_normed_field ùïú] {E : Type v} [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_smul ùïú E] [complete_space ùïú] [t2_space E] {Œπ : Type u_1} [fintype Œπ] (Œæ : basis Œπ ùïú E) : continuous ‚áë(Œæ.equiv_fun)
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [normed_space ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} {E' : Type u_10} [semi_normed_group E'] [normed_space ùïú E'] [ring_hom_isometric œÉ‚ÇÅ‚ÇÇ] {f : ‚Ñï ‚Üí (E' ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F)} {g : E' ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F} (hg : filter.tendsto (Œª (n : ‚Ñï) (x : E'), ‚áë(f n) x) filter.at_top (nhds ‚áëg)) (hf : cauchy_seq f) : filter.tendsto f filter.at_top (nhds g)
{C : Type u} [category_theory.category C] (F : C ‚•§ Type w) : category_theory.structured_arrow punit F ‚•§ F.elements
{G : Type u_1} [group G] {H : subgroup G} {S : set G} (hS : S ‚àà subgroup.right_transversals ‚ÜëH) : G ‚Üí ‚Ü•S
(umetas : list level) (emetas : list expr) (target : expr) (uoutput : list level) (eoutput : list expr) : tactic tactic.pattern
(M‚ÇÄ : Type u_4) : Type u_4
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ‚Ñù} [interval_integral.FTC_filter a (nhds_within a s) (nhds_within a t)] (hmeas : strongly_measurable_at_filter f (nhds_within a t) measure_theory.measure_space.volume) (ha : continuous_within_at f t a) : has_deriv_within_at (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in u..b, f x) (-f a) s a
(red : interactive.parse (optional (lean.parser.tk "!"))) (SOP : interactive.parse tactic.interactive.abel.mode) (loc : interactive.parse interactive.types.location) : tactic unit
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} : galois_coinsertion l u ‚Üí galois_insertion (‚áëorder_dual.to_dual ‚àò u ‚àò ‚áëorder_dual.of_dual) (‚áëorder_dual.to_dual ‚àò l ‚àò ‚áëorder_dual.of_dual)
{G : Type u_1} [group G] (H : subgroup G) : has_inv ‚Ü•H
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : rel Œ± Œ≤) : set Œ≤
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x : V) (Œ∏ : real.angle) : ‚áë(o.rotation Œ∏) x = x ‚Üî x = 0 ‚à® Œ∏ = 0
(S : Type u) : Type u
 : turing.to_partrec.code
{G : Type u_1} [add_group G] {M : Type u_5} [add_zero_class M] (f : G ‚Üí+ M) : add_subgroup G
{R : Type u} [non_assoc_semiring R] (s : set R) : ‚Üë(subsemiring.closure s) = ‚Üë(add_submonoid.closure ‚Üë(submonoid.closure s))
 : ‚Ñï ‚Üí expr ‚Üí expr ‚Üí tactic unit
 : snum ‚Üí snum
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {s : finset Œπ} {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) {a : Œπ ‚Üí Œπ ‚Üí ùïú} : s.sum (Œª (i : Œπ), s.sum (Œª (j : Œπ), a i j ‚Ä¢ has_inner.inner (v j) (v i))) = s.sum (Œª (k : Œπ), a k k)
 : expr ‚Üí expr
{K : Type u} {V V‚ÇÅ : Type v} [division_ring K] [add_comm_group V] [module K V] [add_comm_group V‚ÇÅ] [module K V‚ÇÅ] : nonempty (V ‚âÉ‚Çó[K] V‚ÇÅ) ‚Üî module.rank K V = module.rank K V‚ÇÅ
{Œπ : Type v} (Œ± : Œπ ‚Üí Top) : ‚àê Œ± ‚âÖ Top.of (Œ£ (i : Œπ), ‚Ü•(Œ± i))
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] {i : Œ± ‚Üí Œ≤} [topological_space Œ≥] (di : dense_inducing i) (f : Œ± ‚Üí Œ≥) (b : Œ≤) : Œ≥
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e e' : local_homeomorph Œ± Œ≤} (h : e ‚âà e') : set.eq_on ‚áëe ‚áëe' e.to_local_equiv.source
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] (f : measure_theory.simple_func Œ≤ Œ≥) (g : Œ± ‚Üí Œ≤) (hgm : measurable g) : measure_theory.simple_func Œ± Œ≥
(R : Type u) [ring R] (E : Type v) [add_comm_group E] [module R E] (F : Type w) [add_comm_group F] [module R F] : Type (max v w)
{Œ± : Type u_1} [linear_ordered_field Œ±] [floor_semiring Œ±] (m n : ‚Ñï) : ‚åä‚Üëm / ‚Üën‚åã‚Çä = m / n
{R : Type u_1} [comm_semiring R] {A : Type u} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] (s : subalgebra R A) : subalgebra R A
{K L : Type} [field K] [field L] [is_alg_closed K] [is_alg_closed L] (p : ‚Ñï) [char_p K p] [char_p L p] (hK : cardinal.aleph_0 < cardinal.mk K) (hKL : cardinal.mk K = cardinal.mk L) : K ‚âÉ+* L
{Œ± : Type u_1} [hŒ± : uniform_space Œ±] (h : uniformity Œ± = filter.principal id_rel) : discrete_topology Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (t : category_theory.limits.is_initial X) (Y : C) : X ‚ü∂ Y
{R : Type u_1} {M : Type u_2} {N : Type u_3} {Œπ : Type u_4} {Œ∫ : Type u_5} [decidable_eq Œπ] [decidable_eq Œ∫] [fintype Œπ] [fintype Œ∫] [comm_ring R] [add_comm_group M] [add_comm_group N] [module R M] [module R N] (b : basis Œπ R M) (c : basis Œ∫ R N) : module.dual R (tensor_product R M N) ‚Üí‚Çó[R] tensor_product R (module.dual R M) (module.dual R N)
 : onote ‚Üí onote ‚Üí onote
 : bounded_order Prop
{b m d : ‚Ñï} (hb : 2 ‚â§ b) (hd : d ‚àà b.digits m) : d < b
{m : Type u_3} {n : Type u_4} {Œ± : Type u_5} [fintype m] [fintype n] [normed_group Œ±] : normed_group (matrix m n Œ±)
{G : Type u} [monoid G] (x : G) : ‚Ñï
{G H : AddCommGroup} (f : G ‚ü∂ H) : category_theory.limits.image f ‚âÖ AddCommGroup.of ‚Ü•(add_monoid_hom.range f)
{X : Type u_1} [topological_space X] {Œ± : Type u_2} (f : locally_constant X Œ±) : locally_constant ‚Ü•(f.discrete_quotient) Œ±
{Œπ : Type u_1} {Œ± : Type u_2} [add_monoid Œπ] (l : list Œ±) (fŒπ : Œ± ‚Üí Œπ) : Œπ
{Œ± : Sort u} [is_empty Œ±] (Œ≤ : Œ± ‚Üí Sort v) : unique (Œ† (a : Œ±), Œ≤ a)
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (Œ∏ : real.angle) : o.oangle x (‚áë(o.rotation Œ∏) y) = o.oangle x y + Œ∏
{R : Type u} {M : Type v} [ring R] {N : Type u_3} [add_comm_group M] [module R M] [add_comm_group N] [module R N] (f : M √ó N ‚Üí‚Çó[R] M) (i : function.injective ‚áëf) : ‚Ñï ‚Üí (Œ£ (K : submodule R M), ‚Ü•K ‚âÉ‚Çó[R] M)
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.sheaf C X) (U V : topological_space.opens ‚Ü•X) : category_theory.limits.is_limit (F.inter_union_pullback_cone U V)
(R : Type u‚ÇÅ) (L : Type u‚ÇÇ) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : Œ± ‚âÉ‚Çú Œ≤) {b : Œ≤} {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} : f =O[nhds b] g ‚Üî (f ‚àò ‚áëe) =O[nhds (‚áë(e.symm) b)] (g ‚àò ‚áëe)
(G : add_subgroup ‚Ñù) : dense ‚ÜëG ‚à® ‚àÉ (a : ‚Ñù), G = add_subgroup.closure {a}
{C : Type u} [category_theory.category C] (X : C) : X ‚âÖ X
{n : ‚Ñï} {Œ± : Type u_1} [preorder Œ±] {f : fin (n + 1) ‚Üí Œ±} : strict_mono f ‚Üî ‚àÄ (i : fin n), f (‚áëfin.cast_succ i) < f i.succ
{m : Type u_2} {n : Type u_3} {Œ± : Type v} [non_unital_non_assoc_semiring Œ±] [fintype n] (v : n ‚Üí Œ±) : matrix m n Œ± ‚Üí+ m ‚Üí Œ±
{R : Type u_1} [comm_ring R] {M : submonoid R} {S : Type u_2} [comm_ring S] [algebra R S] {R‚Çò : Type u_4} {S‚Çò : Type u_5} [comm_ring R‚Çò] [comm_ring S‚Çò] [algebra R R‚Çò] [is_localization M R‚Çò] [algebra S S‚Çò] [is_localization (algebra.algebra_map_submonoid S M) S‚Çò] (H : algebra.is_integral R S) : (is_localization.map S‚Çò (algebra_map R S) _).is_integral
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (right : C ‚•§ D) [category_theory.is_right_adjoint right] : category_theory.left_adjoint right ‚ä£ right
(C : Type u) (A : Type u_1) [category_theory.category C] [add_monoid A] [category_theory.has_shift C A] : category_theory.shift_functor C 0 ‚âÖ ùü≠ C
{C : Type u} [category_theory.category C] [category_theory.limits.has_wide_equalizers C] {T : C} (hT : ‚àÄ (X : C), nonempty (T ‚ü∂ X)) : category_theory.limits.has_initial C
(R : Type u_2) [ring R] (Œì‚ÇÄ : Type u_3) [linear_ordered_add_comm_monoid_with_top Œì‚ÇÄ] : Type (max u_2 u_3)
{n : ‚Ñï} (k : fin (n + 1)) : ‚Ü•unit_interval
{Œ± : Type} (ea : computability.fin_encoding Œ±) : turing.fin_tm2
{Œ± : Type u_1} [has_zero Œ±] [has_one Œ±] [has_add Œ±] [has_neg Œ±] : znum ‚Üí Œ±
{Œπ : Type u} (F : category_theory.discrete Œπ ‚•§ algebraic_geometry.LocallyRingedSpace) : category_theory.limits.cocone F
{G : Type u_1} [add_group G] {H : add_subgroup G} {S : set G} (hS : S ‚àà add_subgroup.left_transversals ‚ÜëH) : G ‚ß∏ H ‚âÉ ‚Ü•S
{R : Type u} [ring R] {J : Type w} [category_theory.category J] (F : J ‚•§ Module R) (s : category_theory.limits.cocone F) : Module.colimits.prequotient F ‚Üí ‚Ü•(s.X)
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [add_monoid Œπ] [graded_monoid.gmonoid A] {i : Œπ} : mul_action (A 0) (A i)
(C : Type u) [category_theory.category C] : Type (max v u)
{Œ± : Type u_1} [ring Œ±] : complete_semilattice_Inf (ring_topology Œ±)
{C : Type u} [category_theory.category C] (X : C) {D : Type u'} [category_theory.category D] (f : C ‚•§ D) : category_theory.Aut X ‚Üí* category_theory.Aut (f.obj X)
(V : Type u) : Type u
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) {Z : C} (l : Z ‚ü∂ X) {s : category_theory.limits.kernel_fork f} (hs : category_theory.limits.is_limit s) (i : Z ‚âÖ s.X) (h : i.hom ‚â´ category_theory.limits.fork.Œπ s = l) : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ l _)
{X : algebraic_geometry.PresheafedSpace CommRing} (Y : algebraic_geometry.LocallyRingedSpace) (f : X ‚ü∂ Y.to_SheafedSpace.to_PresheafedSpace) [H : algebraic_geometry.PresheafedSpace.is_open_immersion f] : algebraic_geometry.LocallyRingedSpace
{x y : pgame} : x.lf y ‚Üî (‚àÉ (i : y.left_moves), x ‚â§ y.move_left i) ‚à® ‚àÉ (j : x.right_moves), x.move_right j ‚â§ y
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x : V} (hx : x ‚â† 0) (Œ∏ : real.angle) : o.oangle x (‚áë(o.rotation Œ∏) x) = Œ∏
(_x : interactive.parse (lean.parser.tk "#list_unused_decls")) : lean.parser unit
{G : Type u_1} {H : Type u_2} [group G] {N : subgroup G} [group H] {f : G ‚Üí* H} (hN : N = f.ker) (tH : monoid.is_torsion H) (tN : monoid.is_torsion ‚Ü•N) : monoid.is_torsion G
{V : Type u} (G : simple_graph V) {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚âÉ Œ≤) : G.coloring Œ± ‚âÉ G.coloring Œ≤
(p : ‚Ñï) [hp : fact (nat.prime p)] : ‚Ñï ‚Üí mv_polynomial ‚Ñï ‚Ñ§
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] : topological_space (projective_spectrum ùíú)
{Œ± : Type u} {Œ≤ : Type v} [has_zero Œ≤] [decidable_eq Œ±] [decidable_eq Œ≤] (tf : slim_check.total_function Œ± Œ≤) : Œ± ‚Üí‚ÇÄ Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : local_equiv Œ± Œ≤) : e.symm.trans e ‚âà local_equiv.of_set e.target
{m : Type ‚Üí Type u_1} [monad m] {Œ± : Type u_2} (f : Œ± ‚Üí Œ± ‚Üí m unit) : list Œ± ‚Üí m unit
 : category_theory.full algebraic_geometry.Spec.to_LocallyRingedSpace
{G : Type u} [group G] (N : subgroup G) [nN : N.normal] (M : subgroup G) [nM : M.normal] (h : N ‚â§ M) : (G ‚ß∏ N) ‚ß∏ subgroup.map (quotient_group.mk' N) M ‚âÉ* G ‚ß∏ M
{Œ± : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul Œ±] [add_comm_monoid Œ±] (A : matrix m n Œ±) [fintype n] : Prop
(V : Type u) : simple_graph V
{Œ± : Type u_1} {Œ≤ : Type u_2} [partial_order Œ±] [preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤} (h : function.semiconj g ‚áëfa ‚áëfb) {g' : Œ≤ ‚Üí Œ±} (hg' : is_order_right_adjoint g g') : function.semiconj g' ‚áëfb ‚áëfa
{G : Type u_1} [group G] (K V : set G) : ‚Ñï
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [has_le Œ±] [has_le Œ≤] [bounded_order Œ±] [bounded_order Œ≤] : Type (max u_6 u_7 u_8)
{p : ‚Ñï} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R) : witt_vector p R
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [has_add Œπ] : Type (max u_1 u_2)
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ‚Ü•X) (R : category_theory.presieve U) : category_theory.presheaf.second_obj R F ‚âÖ Top.presheaf.sheaf_condition_equalizer_products.pi_inters F (Top.presheaf.covering_of_presieve U R)
{V : Type u_1} (Œ± : Type u_2) (G : simple_graph V) [decidable_rel G.adj] [mul_zero_one_class Œ±] [nontrivial Œ±] : _.to_graph = G
{Œ± : Type u_1} {Œ≤ : Type u_2} {e e' : local_equiv Œ± Œ≤} (h : e ‚âà e') : set.eq_on ‚áë(e.symm) ‚áë(e'.symm) e.target
{Œ± : Type u_1} [fintype Œ±] {p q : Œ± ‚Üí Prop} [decidable_pred p] [decidable_pred q] (e : {x // p x} ‚âÉ {x // q x}) : equiv.perm Œ±
{X Y : Top} {f : X ‚ü∂ Y} (hf : is_open_map ‚áëf) : hf.functor ‚ä£ topological_space.opens.map f
{X Y : Group} : ‚Ü•X ‚âÉ* ‚Ü•Y ‚âÖ X ‚âÖ Y
{Œ± : Type u} : lazy_list Œ± ‚Üí ‚Ñï ‚Üí option Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_equalizers C
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (S : Type u_3) [comm_monoid S] [distrib_mul_action S M] [smul_comm_class S R M] : module.is_torsion' M S ‚Üî submodule.torsion' R M S = ‚ä§
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ D} (H : D ‚•§ C) [category_theory.is_equivalence H] (c : category_theory.limits.cocone (F ‚ãô H)) : H.map_cocone (H.map_cocone_inv c) ‚âÖ c
(Œπ : Type u_1) [fintype Œπ] : is_closed (std_simplex ‚Ñù Œπ)
{Œ± : Type u_1} [preorder Œ±] [succ_order Œ±] {a b : Œ±} [no_max_order Œ±] : a < b ‚Üí order.succ a < order.succ b
{V : Type u_1} [inner_product_space ‚Ñù V] {x y : V} (z : V) (h : inner_product_geometry.angle x y = real.pi) : inner_product_geometry.angle x z + inner_product_geometry.angle y z = real.pi
{C : Type u} [category_theory.category C] {X X‚ÇÅ X‚ÇÇ : C} [category_theory.limits.coproduct_disjoint X‚ÇÅ X‚ÇÇ] {pX‚ÇÅ : X‚ÇÅ ‚ü∂ X} {pX‚ÇÇ : X‚ÇÇ ‚ü∂ X} [category_theory.limits.has_pullback pX‚ÇÅ pX‚ÇÇ] (cX : category_theory.limits.is_colimit (category_theory.limits.binary_cofan.mk pX‚ÇÅ pX‚ÇÇ)) : category_theory.limits.is_initial (category_theory.limits.pullback pX‚ÇÅ pX‚ÇÇ)
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) [wo : is_well_order Œ± r] : ordinal
{n : ‚Ñï} (i : fin (n + 2)) : fin (n + 1)
{M : Type u_1} {N : Type u_2} {P : Type u_3} {Q : Type u_4} [add_zero_class M] [add_zero_class N] [add_comm_monoid P] [add_comm_monoid Q] (f : M ‚âÉ+ N) (g : P ‚âÉ+ Q) : (M ‚Üí+ P) ‚âÉ+ (N ‚Üí+ Q)
(Œ± : Type u) [has_mul Œ±] [has_le Œ±] : Prop
{A B : CommRing} (f g : A ‚ü∂ B) : category_theory.limits.is_limit (CommRing.equalizer_fork f g)
{Œ± : Type u_1} [uniform_space Œ±] (pkg : abstract_completion Œ±) {Œ≤ : Type u_2} [uniform_space Œ≤] (pkg' : abstract_completion Œ≤) {Œ≥ : Type u_3} [uniform_space Œ≥] (pkg'' : abstract_completion Œ≥) (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : pkg.space ‚Üí pkg'.space ‚Üí pkg''.space
{Œ≤ : Type u} {Œ± : Type v} {s : finset Œ±} {a : Œ±} {f : Œ± ‚Üí Œ≤} [add_comm_monoid Œ≤] [decidable_eq Œ±] (h : a ‚àâ s ‚Üí f a = 0) : (has_insert.insert a s).sum (Œª (x : Œ±), f x) = s.sum (Œª (x : Œ±), f x)
{Œ± : Type u_1} {Œπ : Sort u_4} [complete_lattice Œ±] (f : Œπ ‚Üí Œ±) : (‚®Ö (i : {i // f i ‚â† ‚ä§}), f ‚Üëi) = ‚®Ö (i : Œπ), f i
{Œ± : Type u} {œÉ' : Type v} (M : DFA Œ± œÉ') : NFA Œ± œÉ'
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [non_unital_non_assoc_ring Œ±] [non_unital_non_assoc_ring Œ≤] [topological_ring Œ±] [topological_ring Œ≤] : topological_ring (Œ± √ó Œ≤)
{X Y : Type u} [has_mul X] [has_mul Y] (f : X ‚Üí‚Çô* Y) : Magma.of X ‚ü∂ Magma.of Y
{C : Type u} [category_theory.category C] [category_theory.abelian C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.epi f] {T : C} (g : X ‚ü∂ T) (hg : category_theory.limits.kernel.Œπ f ‚â´ g = 0) : Y ‚ü∂ T
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) {D : Type u'} [category_theory.category D] [category_theory.limits.has_colimit F] (G : C ‚•§ D) [category_theory.limits.has_colimit (F ‚ãô G)] : category_theory.limits.colimit (F ‚ãô G) ‚ü∂ G.obj (category_theory.limits.colimit F)
{Œ± : Type u} [linear_ordered_comm_group Œ±] {Œ≤ : Type u_1} [has_one Œ≤] [has_mul Œ≤] [has_inv Œ≤] [has_div Œ≤] [has_pow Œ≤ ‚Ñï] [has_pow Œ≤ ‚Ñ§] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (inv : ‚àÄ (x : Œ≤), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : Œ≤), f (x / y) = f x / f y) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (x ^ n) = f x ^ n) : linear_ordered_comm_group Œ≤
 : ‚Ü•circle ‚Üí* ‚ÑÇ ‚âÉ‚Çó·µ¢[‚Ñù] ‚ÑÇ
{Œ± : Type u_2} {Œ≤ : Type u_3} [decidable_eq Œ±] [has_vsub Œ± Œ≤] : has_vsub (finset Œ±) (finset Œ≤)
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} : metric.Hausdorff_dist s (closure s) = 0
{R : Type u_1} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] (e : M ‚âÉ M‚ÇÇ) (h : is_linear_map R ‚áëe) : M ‚âÉ‚Çó[R] M‚ÇÇ
(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : setoid (ray_vector R M)
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : Prop
{X Y : AddCommMon} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ+ ‚Ü•Y
{Œ± : Type u_1} [has_add Œ±] [has_le Œ±] (a : Œ±) : Prop
(K : Type u) [comm_ring K] (p : ‚Ñï) [fact (nat.prime p)] [char_p K p] : K ‚Üí+* perfect_closure K p
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) [category_theory.creates_colimit K F] (c : category_theory.limits.cocone (K ‚ãô F)) (t : category_theory.limits.is_colimit c) : category_theory.lifts_to_colimit K F c t
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [preorder Œ±] [preorder Œ≤] : Type (max u_6 u_7 u_8)
(M : Type u_10) (N : Type u_11) (Œ± : Type u_12) [has_vadd M Œ±] [has_vadd N Œ±] : Prop
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] {M‚ÇÅ' : Œπ ‚Üí Type u_1} [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ' i)] [Œ† (i : Œπ), module R (M‚ÇÅ' i)] (g : multilinear_map R M‚ÇÅ' M‚ÇÇ) (f : Œ† (i : Œπ), M‚ÇÅ i ‚Üí‚Çó[R] M‚ÇÅ' i) : multilinear_map R M‚ÇÅ M‚ÇÇ
{R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] {abv : absolute_value R ‚Ñ§} {Œπ : Type u_5} [decidable_eq Œπ] [fintype Œπ] (bS : basis Œπ R S) (adm : abv.is_admissible) : ‚Ñï
 : vm ‚Ñï
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} (r : mvqpf.cofix F Œ± ‚Üí mvqpf.cofix F Œ± ‚Üí Prop) (h : ‚àÄ (x y : mvqpf.cofix F Œ±), r x y ‚Üí mvfunctor.liftr' (Œ±.rel_last' r) x.dest y.dest) (x y : mvqpf.cofix F Œ±) : r x y ‚Üí x = y
{Œπ : Type u} {Œ≤‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {Œ≤‚ÇÇ : Œπ ‚Üí Type v‚ÇÇ} [Œ† (i : Œπ), add_zero_class (Œ≤‚ÇÅ i)] [Œ† (i : Œπ), add_zero_class (Œ≤‚ÇÇ i)] (e : Œ† (i : Œπ), Œ≤‚ÇÅ i ‚âÉ+ Œ≤‚ÇÇ i) : (Œ†‚ÇÄ (i : Œπ), Œ≤‚ÇÅ i) ‚âÉ+ Œ†‚ÇÄ (i : Œπ), Œ≤‚ÇÇ i
{n : ‚Ñï} (c : composition_as_set n) (i : fin c.length) : ‚Ñï
{G : Type u_1} {M : Type u_2} [add_group G] [add_monoid M] (f : G ‚Üí+ M) : G ‚Üí+ add_units M
 : tactic.rcases_patt ‚Üí option name
(m : ‚Ñù) (k : ‚Ñï) : ‚Ñù
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {w : Œ± ‚Üí M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : ‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚àà t) (hb : s.sum (Œª (x : Œ±), w x) < t.card ‚Ä¢ b) : ‚àÉ (y : Œ≤) (H : y ‚àà t), (finset.filter (Œª (x : Œ±), f x = y) s).sum (Œª (x : Œ±), w x) < b
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] {f : filter Œ±} {a : Œ±} [f.ne_bot] : f ‚â§ nhds a ‚Üí f.Limsup = a
{S : Type u} [has_mul S] {a x y : S} (h : semiconj_by a x y) : a * x = y * a
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] (P : C) : P ‚®ø ‚ä•_ C ‚âÖ P
(X : Profinite) : discrete_quotient ‚Ü•X ‚•§ Profinite
{d : ‚Ñ§} : has_add (‚Ñ§‚àöd)
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤] {K : set Œ±} (f : C(Œ±, Œ≤)) (hK : is_compact K) {U : set Œ≤} (hU : is_open U) (hf : f ‚àà continuous_map.compact_open.gen K U) : ‚àÉ (V : set (Œ≤ √ó Œ≤)) (H : V ‚àà uniformity Œ≤), is_open V ‚àß continuous_map.compact_conv_nhd K V f ‚äÜ continuous_map.compact_open.gen K U
{L : first_order.language} {Œ± : Type u'} {Œ≤ : Type v'} [decidable_eq Œ±] : L.term (Œ± ‚äï Œ≤) ‚Üí finset Œ±
{Œ± : Sort u_1} [is_empty Œ±] {p : Œ± ‚Üí Sort u_2} (a : Œ±) : p a
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (E : K ‚•§ J) (c : category_theory.limits.cocone F) : category_theory.limits.cocone (E ‚ãô F)
(x : ‚Ñù*) : Prop
 : name ‚Üí vm (list name)
{C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ‚Ñï} {i : fin (n + 1)} : X.œÉ i ‚â´ X.Œ¥ (‚áëfin.cast_succ i) = ùüô (X.obj (opposite.op (simplex_category.mk n)))
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (q : Œ† (i : fin (n + 1)), Œ± i) : fin.cons (q 0) (fin.tail q) = q
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : submodule K V) : module.rank K ‚Ü•s ‚â§ 1 ‚Üî ‚àÉ (v‚ÇÄ : V) (H : v‚ÇÄ ‚àà s), s ‚â§ submodule.span K {v‚ÇÄ}
 : Type
{J : Type v} [category_theory.small_category J] (F : J ‚•§ SemiRing) : category_theory.limits.is_limit (SemiRing.has_limits.limit_cone F)
(Œ± : Type u) : bool √ó Œ± ‚âÉ Œ± ‚äï Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.regular_epi f] : category_theory.epi f
{Œ± : Type u} [has_mul Œ±] {Œ≤ : Type v} [semigroup Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) : magma.free_semigroup Œ± ‚Üí Œ≤
(Œ± : Type u) : Type u
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] (v w : E) (H : w ‚àà K) : has_inner.inner (v - orthogonal_projection_fn K v) w = 0
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] {a b : Œ±} (hab : a < b) (s : set Œ±) : [s ‚àà nhds_within a (set.Ici a), s ‚àà nhds_within a (set.Icc a b), s ‚àà nhds_within a (set.Ico a b), ‚àÉ (u : Œ±) (H : u ‚àà set.Ioc a b), set.Ico a u ‚äÜ s, ‚àÉ (u : Œ±) (H : u ‚àà set.Ioi a), set.Ico a u ‚äÜ s].tfae
{C : Type u} [category_theory.category C] {P Q R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R) [category_theory.strong_epi f] [category_theory.strong_epi g] : category_theory.strong_epi (f ‚â´ g)
{R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {Œπ : Type u_6} [decidable_eq Œπ] {M‚ÇÇ : Type u_7} [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] {M‚ÇÉ : Type u_8} [add_comm_monoid M‚ÇÉ] [module R M‚ÇÉ] (f : alternating_map R M N Œπ) (g‚ÇÅ : M‚ÇÇ ‚Üí‚Çó[R] M) (g‚ÇÇ : M‚ÇÉ ‚Üí‚Çó[R] M‚ÇÇ) : (f.comp_linear_map g‚ÇÅ).comp_linear_map g‚ÇÇ = f.comp_linear_map (g‚ÇÅ.comp g‚ÇÇ)
(R : Type u) {Œπ : Type u'} (M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ) (M‚ÇÇ : Type v‚ÇÇ) [decidable_eq Œπ] [comm_semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [is_empty Œπ] : M‚ÇÇ ‚âÉ‚Çó[R] multilinear_map R M‚ÇÅ M‚ÇÇ
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a b : Œ±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} [comm_semiring R] (s : subsemiring R) (m : multiset R) : (‚àÄ (a : R), a ‚àà m ‚Üí a ‚àà s) ‚Üí m.prod ‚àà s
(G‚ÇÄ : Type u_4) [has_zero G‚ÇÄ] [has_inv G‚ÇÄ] [topological_space G‚ÇÄ] : Prop
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] : Prop
(ns : list name) : tactic unit
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [has_Sup Œ±] [has_Sup Œ≤] [has_Sup Œ≥] (f : Sup_hom Œ≤ Œ≥) (g : Sup_hom Œ± Œ≤) : Sup_hom Œ± Œ≥
{n n' : ‚Ñï} (m : ‚Ñï) (i : fin n') (h : n' = n) : ‚áë(fin.cast_add m) (‚áë(fin.cast h) i) = ‚áë(fin.cast _) (‚áë(fin.cast_add m) i)
 : znum ‚Üí znum
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J ‚•§ C) {c : category_theory.limits.cone F} (hc : category_theory.limits.is_limit c) : category_theory.limits.is_colimit c.op
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} : L.bounded_formula Œ± n ‚Üí Prop
{Œ± : Type u} [pseudo_emetric_space Œ±] (Œ¥ : ‚Ñù) (E : set Œ±) : set Œ±
{F : Type} [field F] (q : ‚Ñï) [hq : fact (nat.prime q)] [hF : char_p F q] (g g' : polynomial F) (m m' : ‚Ñï) (h_expand : ‚áë(polynomial.expand F (q ^ m)) g = ‚áë(polynomial.expand F (q ^ m')) g') (h : m < m') (hg : g.separable) : g.nat_degree = g'.nat_degree
{C : ordinal ‚Üí Sort u_2} (o : ordinal) (H‚ÇÅ : C 0) (H‚ÇÇ : Œ† (o : ordinal), C o ‚Üí C (order.succ o)) (H‚ÇÉ : Œ† (o : ordinal), o.is_limit ‚Üí (Œ† (o' : ordinal), o' < o ‚Üí C o') ‚Üí C o) : C o
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] : A √ó B ‚Üí‚Çê[R] B
 : is_fraction_ring ‚Ñ§ ‚Ñö
 : list widget.local_collection ‚Üí list expr ‚Üí tactic (list widget.local_collection)
{Œ± : Type u_1} {n : Type u_4} [comm_semigroup Œ±] [add_comm_monoid Œ±] [fintype n] [add_comm_group n] (v w : n ‚Üí Œ±) : (matrix.circulant v).mul (matrix.circulant w) = (matrix.circulant w).mul (matrix.circulant v)
{Œ± : Type u} (u : uniform_space.core Œ±) : uniform_space Œ±
(ùïú : Type u_1) (E : Type u_4) (F‚Çó : Type u_7) [semi_normed_group E] [semi_normed_group F‚Çó] [nondiscrete_normed_field ùïú] [normed_space ùïú E] [normed_space ùïú F‚Çó] (ùïú' : Type u_10) [nondiscrete_normed_field ùïú'] [normed_algebra ùïú' ùïú] [normed_space ùïú' E] [is_scalar_tower ùïú' ùïú E] [normed_space ùïú' F‚Çó] [is_scalar_tower ùïú' ùïú F‚Çó] (ùïú'' : Type u_11) [ring ùïú''] [module ùïú'' F‚Çó] [has_continuous_const_smul ùïú'' F‚Çó] [smul_comm_class ùïú ùïú'' F‚Çó] [smul_comm_class ùïú' ùïú'' F‚Çó] : (E ‚ÜíL[ùïú] F‚Çó) ‚ÜíL[ùïú''] E ‚ÜíL[ùïú'] F‚Çó
{Œ± : Type u} [pseudo_metric_space Œ±] (x y : Œ±) : has_nndist.nndist x y = (has_dist.dist x y).to_nnreal
{G : Type u_1} [add_group G] (S T : set G) : Prop
(Œ± : Type u_1) [partial_order Œ±] : well_founded gt ‚Üî ‚àÄ (a : ‚Ñï ‚Üío Œ±), ‚àÉ (n : ‚Ñï), ‚àÄ (m : ‚Ñï), n ‚â§ m ‚Üí ‚áëa n = ‚áëa m
{K : Type u} [field K] : comm_group_with_zero K
{F : Type u_3} [inner_product_space ‚Ñù F] {x y : F} : has_inner.inner (x + y) (x + y) = has_inner.inner x x + 2 * has_inner.inner x y + has_inner.inner y y
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {n : ‚Ñï} [fact (finite_dimensional.finrank ùïú E = n + 1)] {v : E} (hv : v ‚â† 0) : finite_dimensional.finrank ùïú ‚Ü•(submodule.span ùïú {v})·óÆ = n
{R : Type u} [ring R] {Œ± : Type u_1} [has_zero Œ±] [mul_action_with_zero R Œ±] (S : subring R) : mul_action_with_zero ‚Ü•S Œ±
(S : Type u_1) [comm_ring S] (Œ± : Type u_2) (Œ≤ : Type u_3) : tensor_product S (Œ± ‚Üí‚ÇÄ S) (Œ≤ ‚Üí‚ÇÄ S) ‚âÉ‚Çó[S] Œ± √ó Œ≤ ‚Üí‚ÇÄ S
 : prime_multiset ‚Üí multiset ‚Ñï
{V : Type u_4} [inner_product_space ‚ÑÇ V] (T : V ‚Üí‚Çó[‚ÑÇ] V) (x y : V) : has_inner.inner (‚áëT y) x = (has_inner.inner (‚áëT (x + y)) (x + y) - has_inner.inner (‚áëT (x - y)) (x - y) + complex.I * has_inner.inner (‚áëT (x + complex.I ‚Ä¢ y)) (x + complex.I ‚Ä¢ y) - complex.I * has_inner.inner (‚áëT (x - complex.I ‚Ä¢ y)) (x - complex.I ‚Ä¢ y)) / 4
(G : Type u_2) [group G] (n : ‚Ñï) : ‚Ü•(equiv.perm.vectors_prod_eq_one G n) ‚âÉ vector G (n - 1)
{Œπ‚ÇÅ : Type u_1} {Œπ‚ÇÇ : Type u_2} {R : Type u_3} {R‚ÇÇ : Type u_4} {S : Type u_5} {S‚ÇÇ : Type u_6} {M : Type u_7} {N : Type u_8} {P : Type u_9} [comm_ring R] [comm_ring S] [comm_ring R‚ÇÇ] [comm_ring S‚ÇÇ] [add_comm_group M] [add_comm_group N] [add_comm_group P] [module R M] [module S N] [module R‚ÇÇ P] [module S‚ÇÇ P] [smul_comm_class S‚ÇÇ R‚ÇÇ P] {œÅ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÅ‚ÇÇ : S ‚Üí+* S‚ÇÇ} (b‚ÇÅ : basis Œπ‚ÇÅ R M) (b‚ÇÇ : basis Œπ‚ÇÇ S N) {B B' : M ‚Üí‚Çõ‚Çó[œÅ‚ÇÅ‚ÇÇ] N ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] P} (h : ‚àÄ (i : Œπ‚ÇÅ) (j : Œπ‚ÇÇ), ‚áë(‚áëB (‚áëb‚ÇÅ i)) (‚áëb‚ÇÇ j) = ‚áë(‚áëB' (‚áëb‚ÇÅ i)) (‚áëb‚ÇÇ j)) : B = B'
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] : ùü≠ (category_theory.lax_braided_functor (category_theory.discrete punit) C) ‚âÖ CommMon_.equiv_lax_braided_functor_punit.lax_braided_to_CommMon C ‚ãô CommMon_.equiv_lax_braided_functor_punit.CommMon_to_lax_braided C
(Œ± : Type u_2) [preorder Œ±] [succ_order Œ±] : Prop
(G : Type u_1) [add_group G] : add_subgroup G
(cl : tactic.closure) (e‚ÇÄ e‚ÇÅ : expr) : tactic bool
{Œ± : Type u_1} [linear_ordered_field Œ±] {Œ≤ : Type u_2} [ring Œ≤] {abv : Œ≤ ‚Üí Œ±} (f : cau_seq Œ≤ abv) (g : ‚Ñï ‚Üí Œ≤) (e : ‚àÄ (i : ‚Ñï), ‚áëf i = g i) : cau_seq Œ≤ abv
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G H : J ‚•§ C} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) : category_theory.limits.cones.postcompose (Œ± ‚â´ Œ≤) ‚âÖ category_theory.limits.cones.postcompose Œ± ‚ãô category_theory.limits.cones.postcompose Œ≤
(Œ± : Type u) [topological_space Œ±] : bornology Œ±
{p : ‚Ñï} : summable (Œª (n : ‚Ñï), (‚Üën ^ p)‚Åª¬π) ‚Üî 1 < p
{Œ± : Type u_1} {Œ≤ : Type u_2} [complete_lattice Œ±] {f : filter Œ≤} : f.liminf (Œª (x : Œ≤), ‚ä§) = ‚ä§
{Œ± : Type u} [metric_space Œ±] (x : ‚Ñï ‚Üí Œ±) (a b : Œ±) : has_dist.dist (Kuratowski_embedding.embedding_of_subset x a) (Kuratowski_embedding.embedding_of_subset x b) ‚â§ has_dist.dist a b
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] [complete_lattice Œ≤] (f : Œ± ‚Üí Œ≤) : finset.univ.sup f = supr f
{R : Type u} [ring R] {Œπ : Type v} (Z : Œπ ‚Üí Module R) : category_theory.limits.is_limit (Module.product_cone Z)
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : Œ±) (s : finset Œ±) : (uv.compression u v s).card = s.card
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ‚Ñ§] {X Y : category_theory.differential_object C} (f : X ‚âÖ Y) : X.X ‚âÖ Y.X
{R : Type u} {Œπ : Type w} (s : finset Œπ) [comm_semiring R] [no_zero_divisors R] (f : Œπ ‚Üí polynomial R) [nontrivial R] : (s.prod (Œª (i : Œπ), f i)).degree = s.sum (Œª (i : Œπ), (f i).degree)
(ns : list name) (loc : interactive.loc) : tactic unit
{C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] {F : J ‚•§ C} {c‚ÇÅ : category_theory.limits.cofan (Œª (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), F.obj f.fst.fst)} {c‚ÇÇ : category_theory.limits.cofan F.obj} (s t : c‚ÇÅ.X ‚ü∂ c‚ÇÇ.X) (hs : ‚àÄ (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), c‚ÇÅ.Œπ.app {as := f} ‚â´ s = F.map f.snd ‚â´ c‚ÇÇ.Œπ.app {as := f.fst.snd}) (ht : ‚àÄ (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), c‚ÇÅ.Œπ.app {as := f} ‚â´ t = c‚ÇÇ.Œπ.app {as := f.fst.fst}) {i : category_theory.limits.cofork s t} (t‚ÇÅ : category_theory.limits.is_colimit c‚ÇÅ) (t‚ÇÇ : category_theory.limits.is_colimit c‚ÇÇ) (hi : category_theory.limits.is_colimit i) : category_theory.limits.is_colimit (category_theory.limits.has_colimit_of_has_coproducts_of_has_coequalizers.build_colimit s t hs ht i)
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [Œ† (i : Œπ), has_zero (Œ≤ i)] (p : Œπ ‚Üí Prop) [decidable_pred p] : (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚Üí (Œ†‚ÇÄ (i : Œπ), Œ≤ i)
 : ‚áëlinear_map.det complex.conj_ae.to_linear_map = -1
(F : Type u) [field F] : ratfunc F ‚Üí‚Çê[polynomial F] laurent_series F
 : Type (u+1)
{Œ± : Type} [has_to_string Œ±] [slim_check.sampleable Œ±] (p : Œ± ‚Üí Prop) [decidable_pred p] : Œ± ‚Üí option Œ±
{R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {v‚ÇÅ v‚ÇÇ : M} (h : same_ray R v‚ÇÅ v‚ÇÇ) : ‚àÉ (a b : R), 0 ‚â§ a ‚àß 0 ‚â§ b ‚àß a + b = 1 ‚àß v‚ÇÅ = a ‚Ä¢ (v‚ÇÅ + v‚ÇÇ) ‚àß v‚ÇÇ = b ‚Ä¢ (v‚ÇÅ + v‚ÇÇ)
(A : Type u_2) [comm_ring A] [is_domain A] : Prop
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] : has_coe (M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)
{Œ± : Type u_2} [division_monoid Œ±] : division_monoid (set Œ±)
{Œ± : Type} [decidable_eq Œ±] [has_sizeof Œ±] : slim_check.shrink_fn (Œ£' (xs ys : list Œ±), xs ~ ys ‚àß ys.nodup)
{Œ± : Type u} [pseudo_emetric_space Œ±] {s : set Œ±} (hs : is_compact s) : ‚àÉ (t : set Œ±) (H : t ‚äÜ s), t.countable ‚àß s ‚äÜ closure t
{C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ‚Ñï} (i : fin (n + 2)) : X.obj (opposite.op (simplex_category.mk (n + 1))) ‚ü∂ X.obj (opposite.op (simplex_category.mk n))
{S : Type v} [comm_ring S] {R : Type u} (c : ‚Ñ§ ‚Üí+* S) (f : mv_polynomial R ‚Ñ§ ‚Üí+* S) (x : mv_polynomial R ‚Ñ§) : mv_polynomial.eval‚ÇÇ c (‚áëf ‚àò mv_polynomial.X) x = ‚áëf x
{Œ± : Type u_1} [add_semigroup Œ±] (x y : Œ±) : has_add.add x ‚àò has_add.add y = has_add.add (x + y)
{A : Type u} {B : Type v} {Œπ : Type w} [comm_ring A] [comm_ring B] [algebra A B] [fintype Œπ] [decidable_eq Œπ] (b : Œπ ‚Üí B) (P : matrix Œπ Œπ A) : algebra.discr A (matrix.vec_mul b (P.map ‚áë(algebra_map A B))) = P.det ^ 2 * algebra.discr A b
{b : ‚Ñï} {S : set ‚Ñï} (hb : b ‚àà S) (h_ind : ‚àÄ (k : ‚Ñï), k ‚àà S ‚Üí k + 1 ‚àà S) {n : ‚Ñï} (hbn : b ‚â§ n) : n ‚àà S
 : list name
{Œπ : Type u_1} [encodable Œπ] {E : Œπ ‚Üí Type u_2} [Œ† (n : Œπ), topological_space (E n)] [‚àÄ (n : Œπ), polish_space (E n)] : polish_space (Œ£ (n : Œπ), E n)
{G : Type u} [add_group G] (H : add_subgroup G) (h : subsingleton (G ‚ß∏ H)) : H = ‚ä§
{Œ± : Type u_1} {M : Type u_5} [has_zero M] {f g : Œ± ‚Üí‚ÇÄ M} : ‚áëf = ‚áëg ‚Üî f = g
(q : interactive.parse interactive.types.texpr) : tactic unit
(G : Type u_1) [subtraction_monoid G] : G ‚âÉ+ G·µÉ·µí·µñ
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : C(Œ±, Œ≤)) : frame_hom (topological_space.opens Œ≤) (topological_space.opens Œ±)
{R : Type u} [ring R] : category_theory.limits.has_cokernels (Module R)
{Œ± : Type u_1} {Œ≤ : Type u_2} (t : Œ±) (ts ys : list Œ±) (f : list Œ± ‚Üí Œ≤) : list.map f (list.permutations_aux2 t ts list.nil ys id).snd = (list.permutations_aux2 t ts list.nil ys f).snd
(ic : tactic.instance_cache) (a b : expr) : tactic (tactic.instance_cache √ó expr √ó expr)
{f : ‚Ñù ‚Üí ‚Ñù} (hf : differentiable ‚Ñù f) (hf'_anti : strict_anti (deriv f)) : strict_concave_on ‚Ñù set.univ f
{Œ± : Type u} [pseudo_metric_space Œ±] {x : Œ±} : metric.diam {x} = 0
{Œ± : Type u_2} [preorder Œ±] [subsingleton Œ±] : unique (Œ± ‚Üío Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (e : C ‚âå D) (f : D ‚âå E) : C ‚âå E
{n : ‚Ñï} : 0 < n ‚Üí 0 < szemeredi_regularity.step_bound n
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] {K : Type u‚ÇÇ} [category_theory.category K] (F : D ‚•§ K ‚•§ C) (H : Œ† (k : K), category_theory.limits.preserves_limits_of_size (F ‚ãô (category_theory.evaluation K C).obj k)) : category_theory.limits.preserves_limits_of_size F
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [module ùïú E] {s : set E} (hs : convex ùïú s) (z : E) : convex ùïú ((Œª (x : E), z + x) ‚Åª¬π' s)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e : local_homeomorph Œ± Œ≤} {s : set Œ±} {t : set Œ≤} : e.is_image s t ‚Üí e.to_local_equiv.target ‚à© ‚áë(e.symm) ‚Åª¬π' s = e.to_local_equiv.target ‚à© t
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_trans Œ± r] (f : ‚Ñï ‚Üí Œ±) : ‚àÉ (g : ‚Ñï ‚Ü™o ‚Ñï), (‚àÄ (m n : ‚Ñï), m < n ‚Üí r (f (‚áëg m)) (f (‚áëg n))) ‚à® ‚àÄ (m n : ‚Ñï), m < n ‚Üí ¬¨r (f (‚áëg m)) (f (‚áëg n))
{M : Type u_1} [add_monoid M] {x : M} : x ‚àà multiples x
 : Type
{R : Type u} [non_assoc_semiring R] (self : subsemiring R) : add_submonoid R
 : filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_2} (f : (Œ† (a : Œ±), part (Œ≤ a)) ‚Üí Œ† (a : Œ±), part (Œ≤ a)) {p : ‚Ñï ‚Üí Prop} (i : nat.upto p) (g : Œ† (j : nat.upto p), i < j ‚Üí Œ† (a : Œ±), part (Œ≤ a)) (a : Œ±) : part (Œ≤ a)
{G : Type u_1} [has_mul G] : G ‚Üí G ‚Üí G
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (F : C ‚•§ D) [category_theory.faithful F] : category_theory.faithful F.to_ess_image
 : tactic (list (string √ó ‚Ñï))
{Œ± : Type} (e : environment) (results : native.rb_map name Œ±) : list (name √ó Œ±)
{Œ± : Sort u_1} {Œ≤ : Sort u_2} [is_empty Œ±] : Œ± ‚Ü™ Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} : function.injective coe_fn
{m : Type u_1} {R : Type u_2} [fintype m] [comm_ring R] (M : matrix m m R) : Prop
{Œπ : Type u_1} {Œ≤ : Œπ ‚Üí Type u_2} [linear_order Œπ] [is_well_order Œπ has_lt.lt] [Œ† (a : Œπ), linear_order (Œ≤ a)] : linear_order (lex (Œ† (i : Œπ), Œ≤ i))
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [mul_zero_one_class Œ±] [mul_zero_one_class Œ≤] (f : Œ± ‚Üí*o Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : Œ± ‚Üí*o Œ≤
(f : ordinal ‚Üí ordinal) : ordinal ‚Üí ordinal
{R S : Type u} [comm_ring R] [comm_ring S] (M : submonoid R) (R' : Type u) [comm_ring R'] [algebra R R'] [algebra R' S] [algebra R S] [is_scalar_tower R R' S] [is_localization M R'] (s : set S) (x : S) (hx : x ‚àà algebra.adjoin R' s) : ‚àÉ (t : ‚Ü•M), t ‚Ä¢ x ‚àà algebra.adjoin R s
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_finite_colimits C
{R : Type u} [semiring R] (p : polynomial R) : finset R
{Œ± : Type u_1} (x : Œ±) : slim_check.no_shrink Œ±
{C : Type u‚ÇÅ} [category_theory.small_category C] {‚Ñ∞ : Type u‚ÇÇ} [category_theory.category ‚Ñ∞] (A : C ‚•§ ‚Ñ∞) (P : C·µí·µñ ‚•§ Type u‚ÇÅ) (E : ‚Ñ∞) {c : category_theory.limits.cocone ((category_theory.category_of_elements.œÄ P).left_op ‚ãô A)} (t : category_theory.limits.is_colimit c) : (c.X ‚ü∂ E) ‚âÉ (P ‚ü∂ (category_theory.colimit_adj.restricted_yoneda A).obj E)
{G : Type u_1} [group G] {k : set G} {p : G ‚Üí Prop} {x : G} (h : x ‚àà subgroup.closure k) (Hk : ‚àÄ (x : G), x ‚àà k ‚Üí p x) (H1 : p 1) (Hmul : ‚àÄ (x y : G), p x ‚Üí p y ‚Üí p (x * y)) (Hinv : ‚àÄ (x : G), p x ‚Üí p x‚Åª¬π) : p x
{R : Type u_1} [linear_ordered_ring R] (s : subring R) : linear_ordered_ring ‚Ü•s
{C : Type u‚ÇÅ} [category_theory.category C] (D : category_theory.glue_data C) [category_theory.limits.has_multicoequalizer D.diagram] : C
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [succ_order Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : antitone f) : pairwise (disjoint on Œª (n : Œ±), set.Ioc (f (order.succ n)) (f n))
{Œ± : Type u_2} {Œ≤ : Type u_3} [add_comm_monoid Œ±] [add_comm_monoid Œ≤] (A : set Œ±) (n : ‚Ñï) (b : Œ≤) : A ‚Üí+[n] Œ≤
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} {re‚ÇÅ‚ÇÇ : ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ} {re‚ÇÇ‚ÇÅ : ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ} [module R M] [module R‚ÇÇ M‚ÇÇ] (f : M ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (U : submodule R‚ÇÇ M‚ÇÇ) : ‚Ü•(submodule.comap ‚Üëf U) ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] ‚Ü•U
(n : ‚Ñï) : polynomial ‚Ñö
{Œ± : Type u} {Œ≤ : Type v} [group Œ±] [mul_action Œ± Œ≤] {x y : Œ≤} (h : (mul_action.orbit_rel Œ± Œ≤).rel x y) : ‚Ü•(mul_action.stabilizer Œ± x) ‚âÉ* ‚Ü•(mul_action.stabilizer Œ± y)
 : pnat.xgcd_type ‚Üí pnat.xgcd_type
(p : expr) : tactic (expr √ó expr)
{G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ‚Üî is_of_fin_add_order x
{X : Type u_1} : alexandroff X
(X Y Z : category_theory.limits.walking_parallel_pair) (f : category_theory.limits.walking_parallel_pair_hom X Y) (g : category_theory.limits.walking_parallel_pair_hom Y Z) : category_theory.limits.walking_parallel_pair_hom X Z
(e : pexpr) (lem : option pexpr) : tactic unit
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] {K‚ÇÄ : topological_space.positive_compacts G} : (measure_theory.measure.haar_measure K‚ÇÄ).regular
{X : Type u_1} [topological_space X] [preconnected_space X] [noncompact_space X] : connected_space (alexandroff X)
 : user_attribute (name_map (list name)) (list name)
{Œ± : Type u} [has_to_format Œ±] (l : list Œ±) : format
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí option Œ±
{C : Type u} [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} {X' : C} (g : X' ‚ü∂ X) [category_theory.is_iso g] (F : category_theory.limits.mono_factorisation (g ‚â´ f)) : category_theory.limits.mono_factorisation f
(T : Type u) [topological_space T] : category_theory.pretopology (topological_space.opens T)
 : parser ‚Ñï
{V : Type u} {G : simple_graph V} : ‚ä•.coe ‚âÉg ‚ä•
{Œ± : Type u_1} [decidable_eq Œ±] : has_union (finset Œ±)
(R : Type u_1) {S : Type u_6} (M : Type u_7) [semiring R] [add_comm_monoid M] [module R M] [group S] [distrib_mul_action S M] [smul_comm_class S R M] : S ‚Üí* M ‚âÉ‚Çó[R] M
 : Top ‚•§ Meas
{n : Type u_3} {Œ± : Type v} [fintype n] [semiring Œ±] [star_ring Œ±] : star_ring (matrix n n Œ±)
{H : Type u} {M : Type u_2} {M' : Type u_3} {M'' : Type u_4} [topological_space H] [topological_space M] [charted_space H M] [topological_space M'] [topological_space M''] {G : structure_groupoid H} [charted_space H M'] [charted_space H M''] (e : structomorph G M M') (e' : structomorph G M' M'') : structomorph G M M''
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ w)
{Œ± : Sort u_1} {n : name} (x : auto_param Œ± n) : Œ±
(tac : expr ‚Üí tactic (expr √ó expr)) (e : expr) : tactic (expr √ó expr)
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_binary_products D] [category_theory.limits.has_colimits D] [Œ† (X : D), category_theory.limits.preserves_colimits (category_theory.limits.prod.functor.obj X)] (F : C ‚•§ D) : category_theory.limits.preserves_colimits (category_theory.limits.prod.functor.obj F)
(Œ± : Type u_7) (Œ≤ : Type u_8) [lattice Œ±] [lattice Œ≤] : Type (max u_7 u_8)
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : Type (max v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ)
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A √ó B) A
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) {R‚ÇÇ : Type u_3} {M‚ÇÇ : Type u_4} [ring R‚ÇÇ] [add_comm_group M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} (q : submodule R‚ÇÇ M‚ÇÇ) (f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ) (h : p ‚â§ submodule.comap f q) : M ‚ß∏ p ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ ‚ß∏ q
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (c : con M) (f : M ‚Üí* P) (H : c ‚â§ con.ker f) : c.quotient ‚Üí* P
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : measure_theory.outer_measure Œ≤ ‚Üí‚Çó[ennreal] measure_theory.outer_measure Œ±
{R : Type u} [comm_semiring R] [star_ring R] {x : R} : ‚áë(star_ring_end R) x = has_star.star x
{Œ± : Type u_1} [topological_space Œ±] [quasi_sober Œ±] [t0_space Œ±] : ‚Ü•{s : set Œ± | is_irreducible s ‚àß is_closed s} ‚âÉo Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ‚Ñ§] [category_theory.preadditive C] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_object D] [category_theory.has_shift D ‚Ñ§] [category_theory.preadditive D] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor D n).additive] (F : category_theory.triangulated.pretriangulated.triangulated_functor_struct C D) : category_theory.triangulated.triangle C ‚•§ category_theory.triangulated.triangle D
 : tactic.eliminate.constructor_argument_naming_rule
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (v : V) (nz : v ‚â† 0) : finite_dimensional.finrank K V = 1 ‚Üî ‚àÄ (w : V), ‚àÉ (c : K), c ‚Ä¢ v = w
{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] : continuous (Œª (g : G √ó G), g.fst * g.snd * (g.fst)‚Åª¬π)
 : lattice circle_deg1_lift
{E : Type u_3} [semi_normed_group E] (u v : E) : ‚à•v‚à•‚Çä ‚â§ ‚à•u‚à•‚Çä + ‚à•u - v‚à•‚Çä
{G : Type u_1} [group G] : has_inf (subgroup G)
(ls : list level) (args : list expr) : ‚Ñï ‚Üí list name ‚Üí tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_comm_monoid Œ±] [topological_space Œ±] : has_sum (Œª (b : Œ≤), 0) 0
{Œ± : Type u_1} {Œ≤ : Type u_2} (x : Œ±) : Œ± ‚äï‚Çó Œ≤
 : Type
(decl : name) : tactic unit
(cwd : string) : io unit
{C : Type u} [category_theory.category C] (X : C) : (category_theory.End X)À£ ‚âÉ* category_theory.Aut X
{Œ± : Type u_1} {M : Type u_5} {N : Type u_6} [comm_monoid M] [comm_monoid N] {s : set Œ±} {f : Œ± ‚Üí M} (g : M ‚Üí* N) (h‚ÇÄ : (s ‚à© function.mul_support f).finite) : ‚áëg (finprod (Œª (j : Œ±), finprod (Œª (H : j ‚àà s), f j))) = finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), ‚áëg (f i)))
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [‚àÄ (i : ùí∞.J), category_theory.limits.has_pullback (ùí∞.map i ‚â´ f) g] (i j k : ùí∞.J) : category_theory.limits.pullback (algebraic_geometry.Scheme.pullback.fV ùí∞ f g i j) (algebraic_geometry.Scheme.pullback.fV ùí∞ f g i k) ‚ü∂ category_theory.limits.pullback (algebraic_geometry.Scheme.pullback.fV ùí∞ f g j k) (algebraic_geometry.Scheme.pullback.fV ùí∞ f g j i)
{R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra A B] [algebra R B] [algebra R A] [is_scalar_tower R A B] {x : B} (h : is_integral R x) : is_integral A x
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [non_assoc_semiring Œ±] [preorder Œ±] [non_assoc_semiring Œ≤] [preorder Œ≤] [non_assoc_semiring Œ≥] [preorder Œ≥] (f : Œ≤ ‚Üí+*o Œ≥) (g : Œ± ‚Üí+*o Œ≤) : Œ± ‚Üí+*o Œ≥
(a : expr) : tactic expr
{ùïú : Type u_1} [is_R_or_C ùïú] [dec_ùïú : decidable_eq ùïú] {E : Type u_2} [inner_product_space ùïú E] {T : E ‚Üí‚Çó[ùïú] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional ùïú E] {n : ‚Ñï} (hn : finite_dimensional.finrank ùïú E = n) : E ‚âÉ‚Çó·µ¢[ùïú] euclidean_space ùïú (fin n)
(hyp : expr) : tactic string
{Œ± : Type u_1} [topological_space Œ±] [t2_space Œ±] [measurable_space Œ±] [borel_space Œ±] {f g : (‚Ñï ‚Üí ‚Ñï) ‚Üí Œ±} (hf : continuous f) (hg : continuous g) (h : disjoint (set.range f) (set.range g)) : measure_theory.measurably_separable (set.range f) (set.range g)
{n : ‚Ñï+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ‚Üë‚Üën] (hn : is_prime_pow ‚Üën) [is_cyclotomic_extension {n} K L] (hirr : irreducible (polynomial.cyclotomic ‚Üën K)) (h : n ‚â† 2) : ‚áë(algebra.norm K) (is_cyclotomic_extension.zeta n K L - 1) = ‚Üë(‚Üën.min_fac)
{x : pgame} [fintype x.left_moves] [fintype x.right_moves] (sL : Œ† (i : x.left_moves), (x.move_left i).short) (sR : Œ† (j : x.right_moves), (x.move_right j).short) : x.short
 : tactic.auto_cases.auto_cases_tac
 : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [group Œ±] [comm_group Œ≤] {f g : Œ± ‚Üí Œ≤} (hf : is_group_hom f) (hg : is_group_hom g) : is_group_hom (Œª (a : Œ±), f a * g a)
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} (f : J ‚Üí (X ‚ü∂ Y)) [category_theory.limits.has_wide_coequalizer f] : C
{R : Type u} {n : ‚Ñï} {M : fin n.succ ‚Üí Type w} {M‚ÇÇ : Type w‚ÇÇ} [semiring R] [Œ† (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : fin n.succ), module R (M i)] [module R M‚ÇÇ] [Œ† (i : fin n.succ), topological_space (M i)] [topological_space M‚ÇÇ] (f : continuous_multilinear_map R M M‚ÇÇ) (m : Œ† (i : fin n), M i.succ) (c : R) (x : M 0) : ‚áëf (fin.cons (c ‚Ä¢ x) m) = c ‚Ä¢ ‚áëf (fin.cons x m)
{n : ‚Ñï} (a : equiv.perm (fin n)) : ‚Ñ§À£
{M : Type u_1} {N : Type u_2} {hM : mul_zero_one_class M} [comm_monoid_with_zero N] : has_mul (M ‚Üí*‚ÇÄ N)
(_x : interactive.parse (lean.parser.tk "initialize_simps_projections")) : lean.parser unit
{G : Type u} {n : ‚Ñï} [fintype G] [left_cancel_monoid G] (x : G) : order_of (x ^ n) = order_of x / (order_of x).gcd n
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [polish_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : closed_embedding f) : polish_space Œ±
{Œì : Type u_1} [inhabited Œì] (l : turing.list_blank Œì) : ‚àÉ (a : Œì) (l' : turing.list_blank Œì), l = turing.list_blank.cons a l'
{G : Type u_2} [group G] {H : subgroup G} [hH : H.normal] : has_scalar (conj_act G) ‚Ü•H
{E : Type u_2} [semi_normed_group E] [normed_space ‚Ñù E] {s : set E} (hs‚ÇÄ : 0 ‚àà s) (hs‚ÇÅ : convex ‚Ñù s) (hs‚ÇÇ : is_open s) {x‚ÇÄ : E} (hx‚ÇÄ : x‚ÇÄ ‚àâ s) : ‚àÉ (f : E ‚ÜíL[‚Ñù] ‚Ñù), ‚áëf x‚ÇÄ = 1 ‚àß ‚àÄ (x : E), x ‚àà s ‚Üí ‚áëf x < 1
{b m d : ‚Ñï} : d ‚àà (b + 2).digits m ‚Üí d < b + 2
{m : Type u_2} {n : Type u_3} {R : Type u_7} {Œ± : Type v} {Œ≤ : Type w} [semiring R] [add_comm_monoid Œ±] [add_comm_monoid Œ≤] [module R Œ±] [module R Œ≤] (f : Œ± ‚âÉ‚Çó[R] Œ≤) : matrix m n Œ± ‚âÉ‚Çó[R] matrix m n Œ≤
{Œ± : Type u} [preorder Œ±] {s : set Œ±} {a : Œ±} (h : is_greatest s a) : order_top ‚Ü•s
 : expr ‚Üí tactic expr
{C : Type u‚ÇÅ} [category_theory.category C] {Y : C} [category_theory.limits.has_initial C] (f : Y ‚ü∂ ‚ä•_ C) : category_theory.split_epi f
(red : interactive.parse (optional (lean.parser.tk "!"))) : tactic unit
{Œ± : Sort u_1} {p : Œ± ‚Üí Prop} (P : ‚àÉ (a : Œ±), p a) : p P.some
{Œ± : Type u} [pseudo_emetric_space Œ±] {Œ¥ : ‚Ñù} {s : set Œ±} {x : Œ±} : emetric.inf_edist x s ‚â§ emetric.inf_edist x (metric.cthickening Œ¥ s) + ennreal.of_real Œ¥
 : tactic unit
(X : Type u) [add_group X] : AddGroup
{C : Type u‚ÇÅ} [category_theory.category C] (F : C·µí·µñ ‚•§ Type v‚ÇÅ) [F.representable] : F.obj (opposite.op F.repr_X)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C} (f : X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ) [category_theory.is_iso (category_theory.limits.biprod.inl ‚â´ f ‚â´ category_theory.limits.biprod.fst)] : Œ£' (L : X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ X‚ÇÅ ‚äû X‚ÇÇ) (R : Y‚ÇÅ ‚äû Y‚ÇÇ ‚âÖ Y‚ÇÅ ‚äû Y‚ÇÇ) (g‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ), L.hom ‚â´ f ‚â´ R.hom = category_theory.limits.biprod.map (category_theory.limits.biprod.inl ‚â´ f ‚â´ category_theory.limits.biprod.fst) g‚ÇÇ‚ÇÇ
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_le Œ±] [has_le Œ≤] (f : Œ± ‚âÉo Œ≤) : Œ±·µí·µà ‚âÉo Œ≤·µí·µà
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {X : C} (h : category_theory.yoneda.obj X ‚ãô category_theory.ulift_functor ‚âÖ F.cones) (s : category_theory.limits.cone F) : s.X ‚ü∂ X
{R : Type u} [comm_ring R] {x y : prime_spectrum R} (h : x ‚§≥ y) : localization.at_prime y.as_ideal ‚Üí+* localization.at_prime x.as_ideal
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {S : D} {T : C ‚•§ D} {f f' : category_theory.structured_arrow S T} (g : f.right ‚ü∂ f'.right) (w : f.hom ‚â´ T.map g = f'.hom) : f ‚ü∂ f'
 : tactic unit
{m : Type u_1} {n : Type u_2} [decidable_eq n] [fintype n] [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (A : matrix m m R) (C : matrix n m R) (D : matrix n n R) : (matrix.from_blocks A 0 C D).det = A.det * D.det
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {s t : category_theory.limits.cofork f g} (k : s.X ‚ü∂ t.X) (w : s.œÄ ‚â´ k = t.œÄ) : s ‚ü∂ t
 : lean.parser to_additive.value_type
(Œ± : Type u_1) : punit √ó Œ± ‚âÉ Œ±
(n : ‚Ñï) : ‚Ñï
{Œ± : Type u_1} [canonically_ordered_add_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b c : Œ±} [contravariant_class Œ± Œ± has_add.add has_le.le] (h : c ‚â§ b) : a < b - c ‚Üî a + c < b
{Œ± : Type u_1} (s‚ÇÅ s‚ÇÇ : multiset Œ±) : multiset Œ±
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [preorder Œ±] [preorder Œ≤] [preorder Œ≥] [add_zero_class Œ±] [add_zero_class Œ≤] [add_zero_class Œ≥] (f : Œ≤ ‚Üí+o Œ≥) (g : Œ± ‚Üí+o Œ≤) : Œ± ‚Üí+o Œ≥
{R : Type u_4} [linear_ordered_comm_ring R] (a b : R) : 2 * a * b ‚â§ a ^ 2 + b ^ 2
(ùïú : Type u_1) {V : Type u_2} (P : Type u_8) [normed_field ùïú] [semi_normed_group V] [normed_space ùïú V] [pseudo_metric_space P] [normed_add_torsor V P] (v : V) : P ‚âÉ·µÉ‚Å±[ùïú] P
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] : CommMon_ C ‚•§ category_theory.lax_braided_functor (category_theory.discrete punit) C
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [‚àÄ (X Y : C), subsingleton (X ‚ü∂ Y)] (F‚ÇÅ F‚ÇÇ : D ‚•§ C) : subsingleton (F‚ÇÅ ‚ü∂ F‚ÇÇ)
{n : ‚Ñï} {C : fin (n + 1) ‚Üí Sort u_1} (h0 : C 0) (hs : Œ† (i : fin n), C (‚áëfin.cast_succ i) ‚Üí C i.succ) (i : fin (n + 1)) : C i
{Œ± : Type u_4} {Œ≤ : Type u_5} [monoid Œ±] [mul_one_class Œ≤] [mul_action Œ± Œ≤] [is_scalar_tower Œ± Œ≤ Œ≤] [smul_comm_class Œ± Œ≤ Œ≤] : Œ± √ó Œ≤ ‚Üí* Œ≤
(A : Type u_2) [comm_ring A] [is_domain A] (K : Type u_1) [field K] [algebra A K] [is_fraction_ring A K] : is_dedekind_domain A ‚Üî is_noetherian_ring A ‚àß ring.dimension_le_one A ‚àß ‚àÄ {x : K}, is_integral A x ‚Üí (‚àÉ (y : A), ‚áë(algebra_map A K) y = x)
{Œπ : Type u_1} {E : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), metric_space (E i)] : (Œ£ (i : Œπ), E i) ‚Üí (Œ£ (i : Œπ), E i) ‚Üí ‚Ñù
{a b c m : ‚Ñï} (hmc : m.gcd c = 1) (h : c * a ‚â° c * b [MOD m]) : a ‚â° b [MOD m]
{R : Type u} [field R] (p q : polynomial R) : polynomial R
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {t : category_theory.limits.cofork f g} {Z Z' : C} (q : Z ‚ü∂ Z') (ht : category_theory.limits.is_colimit t) (k : t.X ‚ü∂ Z) : ‚Üë(‚áë(category_theory.limits.cofork.is_colimit.hom_iso ht Z') (k ‚â´ q)) = ‚Üë(‚áë(category_theory.limits.cofork.is_colimit.hom_iso ht Z) k) ‚â´ q
(f : cau_seq ‚ÑÇ complex.abs) : cau_seq ‚ÑÇ complex.abs
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [no_min_order Œ±] [densely_ordered Œ±] {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (set.Iio a) ‚Üî ‚àÉ (l : Œ±) (H : l ‚àà set.Iio a), set.Ico l a ‚äÜ s
(V : Type (u+1)) [category_theory.large_category V] (G : Mon) : Type (u+1)
{Œ± : Type u} (x : Œ±) : dlist Œ± ‚Üí dlist Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {E : Type u‚ÇÉ} [‚Ñ∞ : category_theory.category E] (F : C ‚•§ D) (G : D ‚•§ E) [category_theory.limits.preserves_limit K (F ‚ãô G)] [category_theory.limits.reflects_limit (K ‚ãô F) G] : category_theory.limits.preserves_limit K F
(hs is : list expr) : tactic (list bool)
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] {S : finset Œπ} {q : Œπ ‚Üí R} (hq : ‚ÜëS.pairwise (is_coprime on q)) (hM : module.is_torsion_by R M (S.prod (Œª (i : Œπ), q i))) : direct_sum.is_internal (Œª (i : ‚Ü•S), submodule.torsion_by R M (q ‚Üëi))
(Œ± : Type u_1) [has_one Œ±] [has_zero Œ±] [has_lt Œ±] : Type u_1
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (N : submodule R M) : submodule R M
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : vector_span k s = submodule.span k (s -·µ• s)
{Œ± : Type u_2} [decidable_eq Œ±] [monoid Œ±] : monoid (finset Œ±)
(F : Type u) (K : Type v) (A : Type w) [field F] [field K] [add_comm_group A] [algebra F K] [module K A] [module F A] [is_scalar_tower F K A] : (module.rank F K).lift * (module.rank K A).lift = (module.rank F A).lift
{Œπ : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering Œπ X s) (i : Œπ) (x : X) : ‚Ñù
{M : Type u_3} [add_comm_group M] {R‚ÇÅ : Type u_4} [comm_ring R‚ÇÅ] [module R‚ÇÅ M] [invertible 2] : quadratic_form R‚ÇÅ M ‚Üí‚Çó[R‚ÇÅ] bilin_form R‚ÇÅ M
 : Type
(n : name) (vars : list expr) (p : expr) : tactic unit
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : Œ±) : uv.compress u v (uv.compress u v a) = uv.compress u v a
{Œ± : Type} (sep : parser unit) (p : parser Œ±) : parser (list Œ±)
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (h : reflexive r) {x y : Œ±} : x ‚â† y ‚Üí r x y ‚Üî r x y
{Œ± : Type u_1} [pseudo_emetric_space Œ±] : pseudo_emetric_space Œ±·µÉ·µí·µñ
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (i : function.injective ‚áëf) (p : submodule R M) : ‚Ü•p ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] ‚Ü•(submodule.map f p)
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {f : Œ± ‚Üí ‚Ñù} (K : nnreal) (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí f x ‚â§ f y + ‚ÜëK * has_dist.dist x y) : lipschitz_on_with K f s
{ùïú : Type u_1} [is_R_or_C ùïú] {E : Type u_2} {E' : Type u_3} [inner_product_space ùïú E] [inner_product_space ùïú E'] (f : E ‚âÉ‚Çó·µ¢[ùïú] E') (p : submodule ùïú E) [complete_space ‚Ü•p] (x : E') : ‚Üë(‚áë(orthogonal_projection (submodule.map ‚Üë(f.to_linear_equiv) p)) x) = ‚áëf ‚Üë(‚áë(orthogonal_projection p) (‚áë(f.symm) x))
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (l‚ÇÅ : filter Œ±) (l‚ÇÇ : filter Œ≤) : filter.tendsto f l‚ÇÅ l‚ÇÇ ‚Üî ‚àÄ (g : ultrafilter Œ±), ‚Üëg ‚â§ l‚ÇÅ ‚Üí filter.tendsto f ‚Üëg l‚ÇÇ
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.is_equivalence F] : C ‚âå D
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {c : ‚ÑÇ} {r R : ‚Ñù} (h0 : 0 < r) (hle : r ‚â§ R) {f : ‚ÑÇ ‚Üí E} {s : set ‚ÑÇ} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R  metric.ball c r)) (hd : ‚àÄ (z : ‚ÑÇ), z ‚àà metric.ball c R  metric.closed_ball c r  s ‚Üí differentiable_at ‚ÑÇ f z) : ‚àÆ (z : ‚ÑÇ) in C(c, R), f z = ‚àÆ (z : ‚ÑÇ) in C(c, r), f z
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) : (Œ£ (j : J), ‚Ü•(F.obj j)) ‚Üí AddMon.filtered_colimits.M F
{A : Type u_4} [comm_ring A] [is_domain A] {K : Type u_5} [field K] {L : Type u_7} [field L] [algebra A K] [is_fraction_ring A K] {g : A ‚Üí+* L} (hg : function.injective ‚áëg) (x : A) (y : ‚Ü•(non_zero_divisors A)) : ‚áë(is_fraction_ring.lift hg) (is_localization.mk' K x y) = ‚áëg x / ‚áëg ‚Üëy
{Œ± : Type u_1} [topological_space Œ±] [ring Œ±] [topological_ring Œ±] (S : subring Œ±) : subring Œ±
{v : ‚Ñï ‚Üí ‚Ñù} {c : ‚Ñù} (h‚ÇÄ : 0 < v 0) (hc : 1 < c) (hu : ‚àÄ (n : ‚Ñï), c * v n ‚â§ v (n + 1)) : filter.tendsto v filter.at_top filter.at_top
{G H : AddCommGroup} (f : G ‚ü∂ H) : category_theory.limits.is_image (AddCommGroup.mono_factorisation f)
{R : Type u_1} {E : Type u_2} {Œπ : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] (t : finset Œπ) (w : Œπ ‚Üí R) (z : Œπ ‚Üí E) : E
(a b : expr) : tactic (expr √ó expr)
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : free_abelian_group Œ± ‚Üí+ free_abelian_group Œ≤
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p1 p2 : P} (hp1 : p1 ‚àà span_points k s) (hp2 : p2 ‚àà span_points k s) : p1 -·µ• p2 ‚àà vector_span k s
(n : ‚Ñï) : ‚Ñï ‚Üí ‚Ñï
(G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G)
{G : Type u_1} [group G] [hH : group.is_nilpotent G] [nontrivial G] : group.nilpotency_class G = group.nilpotency_class (G ‚ß∏ subgroup.center G) + 1
{K : Type u_1} {E : Type u_2} {F : Type u_3} [division_ring K] [add_comm_group E] [module K E] [add_comm_group F] [module K F] (x : E) (y : F) (hx : x ‚â† 0) : linear_pmap K E F
(a b : nnreal) {p q : ‚Ñù} (hpq : p.is_conjugate_exponent q) : a * b ‚â§ a ^ p / p.to_nnreal + b ^ q / q.to_nnreal
(c : tactic.instance_cache) (n : name) (l : list expr) : tactic (tactic.instance_cache √ó expr)
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] {ùíú : ‚Ñï ‚Üí submodule R A} [graded_algebra ùíú] {U : topological_space.opens ‚Ü•(projective_spectrum.Top ùíú)} (f : Œ† (x : ‚Ü•U), homogeneous_localization ùíú (projective_spectrum.as_homogeneous_ideal x.val).to_ideal) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} [encodable Œ±] [encodable Œ≤] : encodable (Œ± ‚äï Œ≤)
{p : ‚Ñï} [fact (nat.prime p)] : p % 2 = 1 ‚Üî p ‚â† 2
{X Y : Top·µí·µñ} (f : X ‚ü∂ Y) (R : TopCommRing) : Top.continuous_functions X R ‚ü∂ Top.continuous_functions Y R
(c d : ‚Ñï) : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí Prop
 : derive_handler
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Top) : category_theory.limits.is_colimit (Top.colimit_cocone F)
(n : ‚Ñï) : tactic (list expr)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : L ‚Üí‚Çó‚ÅÖR‚ÅÜ module.End R L
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y Z : C} {f g : X ‚ü∂ Y} {h : Y ‚ü∂ Z} (w : f ‚â´ h = g ‚â´ h) [category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G] (l : category_theory.limits.is_colimit (category_theory.limits.cofork.of_œÄ h w)) : category_theory.limits.is_colimit (category_theory.limits.cofork.of_œÄ (G.map h) _)
{R : Type u_1} [semiring R] : cubic R ‚âÉ {p // p.degree ‚â§ 3}
(g : ‚Ü•(matrix.GL_pos (fin 2) ‚Ñù)) (z : upper_half_plane) : ‚ÑÇ
 : ‚áëfourier_series = fourier_Lp 2
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} (g : Œ≤ ‚Üí Œ≥) (f : Œ± ‚Üí Œ≤) : list.map g ‚àò list.map f = list.map (g ‚àò f)
{R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] (abv : absolute_value R ‚Ñ§) {Œπ : Type u_5} [decidable_eq Œπ] [fintype Œπ] (bS : basis Œπ R S) (a : S) {y : ‚Ñ§} (hy : ‚àÄ (k : Œπ), ‚áëabv (‚áë(‚áë(bS.repr) a) k) ‚â§ y) : ‚áëabv (‚áë(algebra.norm R) a) ‚â§ class_group.norm_bound abv bS * y ^ fintype.card Œπ
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ (v+1))
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] {Œ± : E} {K : Type u_3} [field K] [algebra F K] (h : is_integral F Œ±) : fintype (‚Ü•F‚üÆŒ±‚üØ ‚Üí‚Çê[F] K)
(pretty_name : name) (type : expr) (bi : binder_info) : local_context ‚Üí option (expr √ó local_context)
{X : Type u_1} {Œ± : Type u_2} [has_zero Œ±] [topological_space X] (f : X ‚Üí Œ±) : set X
(Œ± : Type u_1) [inhabited Œ±] : psum (nontrivial Œ±) (unique Œ±)
{R : Type u_1} [mul_zero_class R] : ¬¨is_right_regular 0 ‚Üî nontrivial R
 : Type
{Œ± : Type} (a : tactic Œ±) : io Œ±
(x y : ‚Ñ§) : ‚Üë(x.gcd y) = x * x.gcd_a y + y * x.gcd_b y
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (right : D ‚•§ C) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [is_R_or_C ùïÇ] [normed_comm_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] {x : ùî∏} : has_strict_fderiv_at (exp ùïÇ) (exp ùïÇ x ‚Ä¢ 1) x
{Œπ : Type u‚ÇÅ} {k : Type u‚ÇÇ} {V : Type u‚ÇÉ} {P : Type u‚ÇÑ} [add_comm_group V] [add_torsor V P] [ring k] [module k V] (b : affine_basis Œπ k P) [fintype Œπ] (b‚ÇÇ : affine_basis Œπ k P) (x : P) : matrix.vec_mul (‚áë(b‚ÇÇ.coords) x) (b.to_matrix b‚ÇÇ.points) = ‚áë(b.coords) x
{K : Type u_1} [is_R_or_C K] : ‚áëis_R_or_C.re is_R_or_C.I = 0
(F : Type u_1) (K : Type u_2) [field F] [comm_ring K] [is_domain K] [algebra F K] [finite_dimensional F K] : field K
{M : Type u_5} {N : Type u_6} {P : Type u_7} [has_mul M] [has_mul N] [has_mul P] (f : M ‚Üí‚Çô* N) (g : M ‚Üí‚Çô* P) : M ‚Üí‚Çô* N √ó P
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ‚Ñï} (s1 s2 : affine.simplex k P n) : s1 = s2 ‚Üî ‚àÄ (i : fin (n + 1)), s1.points i = s2.points i
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_binary_biproduct Y Y] : f + g = category_theory.limits.biprod.lift f g ‚â´ category_theory.limits.biprod.desc (ùüô Y) (ùüô Y)
{p : ‚Ñï} [hp : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {S : Type u_2} [semiring S] : {f // ‚àÄ (k‚ÇÅ k‚ÇÇ : ‚Ñï) (hk : k‚ÇÅ ‚â§ k‚ÇÇ), (truncated_witt_vector.truncate hk).comp (f k‚ÇÇ) = f k‚ÇÅ} ‚âÉ (S ‚Üí+* witt_vector p R)
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ≤ ‚Üí Œ±) (hf : function.surjective f) : Œ± ‚Ü™ Œ≤
{G : Type w} [topological_space G] [group G] [topological_group G] (s : subgroup G) : subgroup G
 : tactic expr
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] {F G : category_theory.oplax_functor B C} (Œ∑ Œ∏ : F ‚ü∂ G) : Type (max u‚ÇÅ w‚ÇÇ)
{Œ± : Type u_1} (a : Œ±) : uchange Œ±
{R : Type u_1} {M : Type u_9} {M‚ÇÇ : Type u_12} {M‚ÇÉ : Type u_13} [comm_semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] (f : M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÉ) : (M ‚Üí‚Çó[R] M‚ÇÇ) ‚Üí‚Çó[R] M ‚Üí‚Çó[R] M‚ÇÉ
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.limits.kernel f.op ‚âÖ opposite.op (category_theory.limits.cokernel f)
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ CommMon Mon)
{C : Type u} [category_theory.category C] {Œπ : Type u_1} (s : Œπ ‚Üí C) : Prop
{Œ± : Sort u‚ÇÅ} {Œ≤ : Sort u‚ÇÇ} (f : Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x y : Œ±} (h : y ‚àà s) : metric.inf_dist x s ‚â§ has_dist.dist x y
(e : expr) (vs : list expr) : bool
(L : first_order.language) {M : Type u_3} (s : setoid M) : Type (max u_1 u_2 u_3)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (s‚ÇÅ s‚ÇÇ : alist Œ≤) : alist Œ≤
{M : Type u_1} [has_add M] (c : add_con M) : add_con_gen ‚áëc = c
{Œ± : Type u} {Œ≤ : Type v} (s : finset Œ≤) (f : Œ± ‚Üí Œ≤) (hf : set.inj_on f (f ‚Åª¬π' ‚Üës)) : finset Œ±
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [module ùïú E] {x z : E} {s : set E} (hs : star_convex ùïú (z + x) s) : star_convex ùïú x ((Œª (x : E), z + x) ‚Åª¬π' s)
{X : Type u_2} [emetric_space X] (m : ennreal ‚Üí ennreal) : measure_theory.outer_measure X
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : has_coe (matrix.special_linear_group n ‚Ñ§) (matrix.special_linear_group n R)
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÇ] [has_one M‚ÇÇ] [has_pow M‚ÇÇ ‚Ñï] [has_inv M‚ÇÇ] [has_div M‚ÇÇ] [has_pow M‚ÇÇ ‚Ñ§] [group M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (inv : ‚àÄ (x : M‚ÇÅ), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : M‚ÇÅ), f (x / y) = f x / f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (x ^ n) = f x ^ n) : group M‚ÇÇ
{Œ± : Type u_1} [is_empty Œ±] (s : finset Œ±) : s = ‚àÖ
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [complete_space E] (v : E) : ‚áë(reflection (submodule.span ùïú {v})·óÆ) v = -v
 : list name
(Œ± : Type u) : Type (max u (v+1))
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [has_zero Œ≥] (f : Œ± ‚Üí‚ÇÄ Œ≥) (g : Œ≤ ‚Üí‚ÇÄ Œ≥) : Œ± ‚äï Œ≤ ‚Üí‚ÇÄ Œ≥
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u} [category_theory.category J] {X : J} (hX : category_theory.limits.is_terminal X) (F : J ‚•§ C) [‚àÄ (i j : J) (f : i ‚ü∂ j), category_theory.is_iso (F.map f)] : category_theory.limits.cone F
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) {J : Type u} [category_theory.category J] (K : J ‚•§ D) : category_theory.limits.cone (K ‚ãô G) ‚•§ category_theory.limits.cone K
{Œπ : Type u_1} : box_integral.box Œπ ‚Üío set (Œπ ‚Üí ‚Ñù)
{C : Type u} [category_theory.category C] : (algebraic_geometry.PresheafedSpace C)·µí·µñ ‚•§ C
(Œ± : Type u_1) [preorder Œ±] : Type u_1
{Œ± : Type u_1} [ring Œ±] (C : ring.positive_cone Œ±) : ordered_ring Œ±
{Œ± : Type u_1} [topological_space Œ±] [comm_ring Œ±] [topological_ring Œ±] (S : ideal Œ±) : ideal Œ±
{M : Type u_1} [monoid M] {X : Type u} [mul_action M X] : category_theory.action_category M X ‚Üí X
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] [module.free R M] : basis (module.free.choose_basis_index R M) R M
{M : Type u_1} [add_zero_class M] (c d : add_con M) (h : c ‚â§ d) : (add_con.ker (c.map d h)).quotient ‚âÉ+ d.quotient
(h : expr) (hs : list expr) : tactic bool
(C : Type u_1) [category_theory.category C] : Type
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≤' : Type u_4} {Œ≥ : Type u_5} {Œ¥ : Type u_7} [decidable_eq Œ≤'] [decidable_eq Œ≥] [decidable_eq Œ¥] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤' ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≤'} {f' : Œ≤ ‚Üí Œ± ‚Üí Œ¥} {g' : Œ¥ ‚Üí Œ≥} (h_right_anticomm : ‚àÄ (a : Œ±) (b : Œ≤), f a (g b) = g' (f' b a)) : finset.image‚ÇÇ f s (finset.image g t) = finset.image g' (finset.image‚ÇÇ f' t s)
(ùïú : Type u_1) (E : Type u_2) [is_R_or_C ùïú] [inner_product_space ùïú E] [complete_space E] : E ‚âÉ‚Çó·µ¢‚ãÜ[ùïú] normed_space.dual ùïú E
{Œ± : Type u} (c : computation Œ±) : option Œ±
(R : Type u_1) [comm_ring R] : ring_invo R
{M : Type u_1} [has_mul M] (c : con M) : has_mul c.quotient
{C : Type u} [category_theory.category C] {f g : category_theory.arrow C} [‚àÄ (n : ‚Ñï), category_theory.limits.has_wide_pushout f.left (Œª (i : ulift (fin (n + 1))), f.right) (Œª (i : ulift (fin (n + 1))), f.hom)] [‚àÄ (n : ‚Ñï), category_theory.limits.has_wide_pushout g.left (Œª (i : ulift (fin (n + 1))), g.right) (Œª (i : ulift (fin (n + 1))), g.hom)] (F : f ‚ü∂ g) : f.augmented_cech_conerve ‚ü∂ g.augmented_cech_conerve
{Œπ : Type u_1} {N : Type u_5} [ordered_comm_monoid N] {f g : Œπ ‚Üí N} {s : finset Œπ} (h : ‚àÄ (i : Œπ), i ‚àà s ‚Üí f i ‚â§ g i) : s.prod (Œª (i : Œπ), f i) ‚â§ s.prod (Œª (i : Œπ), g i)
{K : Type u_1} [linear_ordered_field K] (pconts conts : generalized_continued_fraction.pair K) (fr : K) : K
(R : Type u_1) (B : Type u_3) (F : Type u_4) [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] : topological_vector_bundle.trivialization R F (bundle.trivial B F)
{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (p : sub_mul_action R M) [n_empty : nonempty ‚Ü•p] : has_zero ‚Ü•p
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_zero Œ±] [has_zero Œ≤] [smul_with_zero Œ± Œ≤] {s : set Œ≤} (h : s.nonempty) : 0 ‚Ä¢ s = 0
(f : cau_seq ‚ÑÇ complex.abs) : cau_seq ‚Ñù has_abs.abs
(a b : ‚Ñö) : Prop
{Œ± : Type u} (x : Œ±) : ordnode Œ± ‚Üí Prop
{R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) : ‚àÉ (V : open_add_subgroup R), ‚ÜëV * ‚ÜëV ‚äÜ ‚ÜëU
 : ‚Ñï ‚Üí ‚Ñï
(G : Type u_3) [group G] : Prop
{Œπ : Type u_1} {ùïú : Type u_2} [is_R_or_C ùïú] {E : Type u_3} [inner_product_space ùïú E] [cplt : complete_space E] {G : Œπ ‚Üí Type u_4} [Œ† (i : Œπ), inner_product_space ùïú (G i)] {V : Œ† (i : Œπ), G i ‚Üí‚Çó·µ¢[ùïú] E} (hV : orthogonal_family ùïú V) : ‚Ü•(lp G 2) ‚Üí‚Çó·µ¢[ùïú] E
{Œ± : Type u} {Œ≤ : Type v} [linear_ordered_field Œ±] [topological_space Œ±] [order_topology Œ±] {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±} {C : Œ±} (hC : C < 0) (hf : filter.tendsto f l filter.at_top) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (Œª (x : Œ≤), f x * g x) l filter.at_bot
{Œ± : Type u_1} [has_le Œ±] {a : Œ±} : is_bot a ‚Üí is_top (‚áëorder_dual.to_dual a)
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
{M : Type u_1} [add_group M] (c : add_con M) : has_scalar ‚Ñ§ c.quotient
 : tactic unit
{ùïú : Type u_2} {E : Type u_5} {F : Type u_6} [topological_space ùïú] [comm_semiring ùïú] [add_comm_monoid E] [module ùïú E] [add_comm_monoid F] [module ùïú F] {B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú} (hB : function.injective ‚áëB) : embedding (Œª (x : weak_bilin B) (y : F), ‚áë(‚áëB x) y)
 : {p : ‚Ñï | nat.prime p}.infinite
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (s‚ÇÅ s‚ÇÇ : alist Œ≤) : Prop
(Œ± : Type u) (Œ≤ : Type v) : nonempty (Œ± ‚Ü™ Œ≤) ‚à® nonempty (Œ≤ ‚Ü™ Œ±)
 : Pointed ‚•§ Bipointed
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ (v+1))
{n : ‚Ñï} {i j : fin (n + 2)} (H : i ‚â§ j) : simplex_category.Œ¥ i ‚â´ simplex_category.Œ¥ j.succ = simplex_category.Œ¥ j ‚â´ simplex_category.Œ¥ (‚áëfin.cast_succ i)
(n : num) : num
(p : ‚Ñï) [hp : fact (nat.prime p)] : witt_vector.is_poly p (Œª (R : Type u_1) (_Rcr : comm_ring R), witt_vector.frobenius_fun)
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A √ó B) B
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ‚•§ D) [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.enough_projectives C] [category_theory.limits.preserves_finite_colimits F] {X : C} (P : category_theory.ProjectiveResolution X) : F.obj X ‚ü∂ (F.left_derived 0).obj X
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) : Type v
{Œ± : Type u} {Œ≤ : Type v} [slim_check.sampleable Œ±] [slim_check.sampleable Œ≤] [decidable_eq Œ±] : slim_check.shrink_fn (slim_check.total_function Œ± Œ≤)
{R : Type u_1} [comm_semiring R] {m : Type u_3} {n : Type u_4} [fintype n] [fintype m] [decidable_eq n] {M‚ÇÅ : Type u_5} {M‚ÇÇ : Type u_6} [add_comm_monoid M‚ÇÅ] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÅ] [module R M‚ÇÇ] (v‚ÇÅ : basis n R M‚ÇÅ) (v‚ÇÇ : basis m R M‚ÇÇ) : (M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ) ‚âÉ‚Çó[R] matrix m n R
{Œ± : Type uu} (r : Œ± ‚Üí Œ± ‚Üí Prop) [decidable_rel r] (a : Œ±) : list Œ± ‚Üí list Œ±
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] {X Y : category_theory.simplicial_object C} (f : X ‚ü∂ Y) : algebraic_topology.normalized_Moore_complex.obj X ‚ü∂ algebraic_topology.normalized_Moore_complex.obj Y
{M : Type u_6} {N : Type u_7} [has_add M] [has_add N] (f : M ‚âÉ+ N) (x y : M) : ‚áëf (x + y) = ‚áëf x + ‚áëf y
{J : Type u‚ÇÅ} [category_theory.category J] [category_theory.is_preconnected J] : category_theory.is_preconnected J·µí·µñ
(S : Type u') (R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [semiring S] [module S M] [module R M] [has_scalar S R] [is_scalar_tower S R M] (p : submodule R M) : ‚Ü•(submodule.restrict_scalars S p) ‚âÉ‚Çó[R] ‚Ü•p
{Œ± : Type u_2} (A : set Œ±) (Œ≤ : Type u_7) [add_comm_monoid Œ±] [add_comm_monoid Œ≤] (n : ‚Ñï) : Type (max u_2 u_7)
{Œπ : Type u} {X : Type v} [topological_space X] [paracompact_space X] {s : set X} (hs : is_closed s) (u : Œπ ‚Üí set X) (uo : ‚àÄ (i : Œπ), is_open (u i)) (us : s ‚äÜ ‚ãÉ (i : Œπ), u i) : ‚àÉ (v : Œπ ‚Üí set X), (‚àÄ (i : Œπ), is_open (v i)) ‚àß (s ‚äÜ ‚ãÉ (i : Œπ), v i) ‚àß locally_finite v ‚àß ‚àÄ (i : Œπ), v i ‚äÜ u i
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (C : homological_complex V c) {i j j' : Œπ} (rij : c.rel i j) (rij' : c.rel i j') : C.d i j' ‚â´ category_theory.eq_to_hom _ = C.d i j
(del : interactive.parse (optional (lean.parser.tk "!"))) (ns : interactive.parse (lean.parser.many lean.parser.ident)) : tactic unit
{Œ± : Type u} [preorder Œ±] {s : set Œ±} {a : Œ±} (h : is_lub s a) : bdd_above s
{Œ± : Type u} (s : seq Œ±) : list Œ±
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) (c : ‚àÄ (a b : Œ±), f a = f b) : trunc Œ± ‚Üí Œ≤
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (hf : function.injective2 f) [nonempty Œ≤] : function.injective f
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {N : Type (max u v)} [add_comm_group N] [module R N] {p : R} (hp : irreducible p) (hN : module.is_torsion' N ‚Ü•(submonoid.powers p)) [h' : module.finite R N] : ‚àÉ (d : ‚Ñï) (k : fin d ‚Üí ‚Ñï), nonempty (N ‚âÉ‚Çó[R] direct_sum (fin d) (Œª (i : fin d), R ‚ß∏ submodule.span R {p ^ k i}))
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (e : X ‚âÖ Y) : category_theory.subobject X ‚âÉo category_theory.subobject Y
 : (user_attribute (list name))
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] (f : A ‚Üí‚Çê[R] B) : A ‚Üí‚Çô‚Çê[R] B
(S : set ‚Ñï+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [is_domain B] [is_noetherian_ring A] [fintype ‚Ü•S] [is_cyclotomic_extension S A B] : algebra.is_integral A B
 : ordered_comm_ring ‚ÑÇ
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] {Œ± Œ≤ Œ≥ : ‚Ü•(solvable_by_rad F E)} (hŒ≥ : Œ≥ ‚àà F‚üÆŒ±, Œ≤‚üØ) (hŒ± : solvable_by_rad.P Œ±) (hŒ≤ : solvable_by_rad.P Œ≤) : solvable_by_rad.P Œ≥
(c1 c2 : linarith.pcomp) (elim_var : ‚Ñï) : linarith.pcomp
 : ‚Ñï ‚Üí ‚Ñï ‚Üí list ‚Ñï
{k k' : turing.to_partrec.cont} {v : list ‚Ñï} : turing.to_partrec.step_ret (k.then k') v = (turing.to_partrec.step_ret k v).then k'
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] (x : ‚Ü•(projective_spectrum.Top ùíú)) : homogeneous_localization ùíú (projective_spectrum.as_homogeneous_ideal x).to_ideal ‚Üí ‚Ü•((algebraic_geometry.projective_spectrum.Proj.structure_sheaf ùíú).val.stalk x)
{Œ± : Type u_1} [linear_order Œ±] [topological_space Œ±] [compact_Icc_space Œ±] {a b : Œ±} : is_compact (set.interval a b)
{Œ± : Type u} [topological_space Œ±] (x : Œ±) : set Œ±
{R‚ÇÉ : Type u_7} {M‚ÇÉ : Type u_8} [comm_ring R‚ÇÉ] [add_comm_group M‚ÇÉ] [module R‚ÇÉ M‚ÇÉ] (B‚ÇÉ : bilin_form R‚ÇÉ M‚ÇÉ) : submodule R‚ÇÉ (module.End R‚ÇÉ M‚ÇÉ)
(s : widget_override.interactive_expression.sf) : widget_override.interactive_expression.sf
{Œ± : Type u_1} [preorder Œ±] [decidable_rel has_le.le] (x : Œ±) (s : ordset Œ±) : option Œ±
(x : set Class) : Class
(k : Type u_1) [division_ring k] {Œπ : Type u_4} (s : finset Œπ) [fintype Œπ] : finset.univ.sum (Œª (i : Œπ), finset.centroid_weights_indicator k s i) = s.sum (Œª (i : Œπ), finset.centroid_weights k s i)
{Œ± : Type u_1} [preorder Œ±] [decidable_eq Œ±] (l : list Œ±) (H : list.sorted has_lt.lt l) : fin l.length ‚âÉo {x // x ‚àà l}
{A : Type u} [category_theory.category A] [category_theory.abelian A] {X Y Z : A} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (w : f ‚â´ g = 0) : A
 : tactic unit
{a b : ‚Ñï} (hab : a.coprime b) : (a * b).factors ~ a.factors ++ b.factors
{M : Type u_1} [has_mul M] {c d : con M} : c ‚â§ d ‚Üî ‚àÄ {x y : M}, ‚áëc x y ‚Üí ‚áëd x y
{V : Type u} (G : simple_graph V) : Type u
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [no_min_order Œ±] {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (set.Iio a) ‚Üî ‚àÉ (l : Œ±) (H : l ‚àà set.Iio a), set.Ioo l a ‚äÜ s
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (q : semiquot Œ±) : semiquot Œ≤
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {x : E} {n : with_top ‚Ñï} {s : set E} {f : E ‚Üí ùïú} {g : E ‚Üí F} (hf : cont_diff_within_at ùïú n f s x) (hg : cont_diff_within_at ùïú n g s x) : cont_diff_within_at ùïú n (Œª (x : E), f x ‚Ä¢ g x) s x
{R : Type u} [ordered_ring R] [star_ordered_ring R] [algebra ‚Ñù R] [ordered_smul ‚Ñù R] [star_module ‚Ñù R] (A‚ÇÄ A‚ÇÅ B‚ÇÄ B‚ÇÅ : R) (T : is_CHSH_tuple A‚ÇÄ A‚ÇÅ B‚ÇÄ B‚ÇÅ) : A‚ÇÄ * B‚ÇÄ + A‚ÇÄ * B‚ÇÅ + A‚ÇÅ * B‚ÇÄ - A‚ÇÅ * B‚ÇÅ ‚â§ real.sqrt 2 ^ 3 ‚Ä¢ 1
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) (P : Prop) [decidable P] (x : P ‚Üí Œ±) (y : ¬¨P ‚Üí Œ±) : f (dite P x y) = dite P (Œª (h : P), f (x h)) (Œª (h : ¬¨P), f (y h))
 : lean.parser pexpr
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {x : Œ±} {p : filter Œπ} {g : Œπ ‚Üí Œ±} [topological_space Œ±] (h : tendsto_locally_uniformly F f p) (hf : continuous_at f x) (hg : filter.tendsto g p (nhds x)) : filter.tendsto (Œª (n : Œπ), F n (g n)) p (nhds (f x))
{Œ± : Type u_1} [metric_space Œ±] {Œ≤ : Type u} {N : ‚Ñï} {œÑ : ‚Ñù} (hœÑ : 1 < œÑ) (hN : is_empty (besicovitch.satellite_config Œ± N œÑ)) (q : besicovitch.ball_package Œ≤ Œ±) : ‚àÉ (s : fin N ‚Üí set Œ≤), (‚àÄ (i : fin N), (s i).pairwise_disjoint (Œª (j : Œ≤), metric.closed_ball (q.c j) (q.r j))) ‚àß set.range q.c ‚äÜ ‚ãÉ (i : fin N) (j : Œ≤) (H : j ‚àà s i), metric.ball (q.c j) (q.r j)
{G : Type u} [group G] {M N : subgroup G} [M.normal] [N.normal] (h : M = N) : G ‚ß∏ M ‚âÉ* G ‚ß∏ N
 : Compactum.free ‚ä£ Compactum.forget
{C : Type u} [category_theory.category C] : category_theory.cosimplicial_object.augmented C ‚•§ category_theory.cosimplicial_object C
{Œ± : Type u_1} {Œ≤ : Type u_2} [non_assoc_semiring Œ±] [non_assoc_semiring Œ≤] : (Œ±·µê·µí·µñ ‚Üí+* Œ≤·µê·µí·µñ) ‚âÉ (Œ± ‚Üí+* Œ≤)
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (D : algebraic_geometry.SheafedSpace.glue_data C) : algebraic_geometry.PresheafedSpace.glue_data C
{R : Type u} {A : Type v} {B : Type w} {C : Type w‚ÇÅ} [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B] [non_unital_non_assoc_semiring C] [distrib_mul_action R C] : (A ‚Üí‚Çô‚Çê[R] B) √ó (A ‚Üí‚Çô‚Çê[R] C) ‚âÉ (A ‚Üí‚Çô‚Çê[R] B √ó C)
 : expr ‚Üí list expr ‚Üí expr
(R : Type u) [comm_semiring R] (A : Type v) [semiring A] [algebra R A] (n : Type w) [decidable_eq n] [fintype n] : tensor_product R A (matrix n n R) ‚Üí‚Çê[R] matrix n n A
 : setoid (topological_space.nonempty_compacts ‚Ü•(lp (Œª (n : ‚Ñï), ‚Ñù) ‚ä§))
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {a : Œ±} : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà {a}), f i)) = f a
(opt : list name) : tactic bool
{Œ± : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [has_one N] (f : Œ± ‚Üí N) (g : Œ± ‚Üí N ‚Üí M) {s t : finset Œ±} (h : s ‚äÜ t) (hg : ‚àÄ (a : Œ±), g a 1 = 1) : s.prod (Œª (i : Œ±), g i (f i)) = t.prod (Œª (i : Œ±), g i (‚Üës.mul_indicator f i))
(cs : list omega.clause) : Prop
(b : onote) : onote ‚Üí Prop
(z : ‚ÑÇ) : ‚ÑÇ
 : expr ‚Üí expr
{Œ± : Type u} [ordered_add_comm_monoid Œ±] : ordered_add_comm_group (add_units Œ±)
{X : Type u_1} [topological_space X] {x y : X} (Œ≥ : path x y) : ‚Ñù ‚Üí X
(p : interactive.parse (lean.parser.many lean.parser.ident)) : tactic unit
(m n : ‚Ñï) : option ‚Ñï
{p q : Prop} : slim_check.test_result p ‚Üí slim_check.test_result q ‚Üí slim_check.test_result (p ‚à® q)
(X : Top) (T : Type v) : Top.presheaf (Type v) X
{Œπ : Type u} (s : finset Œπ) (w z : Œπ ‚Üí nnreal) (hw' : s.sum (Œª (i : Œπ), w i) = 1) {p : ‚Ñù} (hp : 1 ‚â§ p) : s.sum (Œª (i : Œπ), w i * z i) ^ p ‚â§ s.sum (Œª (i : Œπ), w i * z i ^ p)
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : C ‚•§ (C ‚•§ D) ‚•§ D
{C : Type u‚ÇÅ} [category_theory.category C] : category_theory.as_small C ‚•§ C
{G : Type u} [add_group G] {M N : add_subgroup G} [M.normal] [N.normal] (h : M = N) : G ‚ß∏ M ‚âÉ+ G ‚ß∏ N
(k : Type u_1) {P‚ÇÅ : Type u_2} {V‚ÇÅ : Type u_6} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] (b : P‚ÇÅ) : V‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÅ
{Œ± : Type u_1} {Œ≤ : Type u_2} [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] (f g : Œ± ‚ÜíùíÑ Œ≤) : {a // ‚áëf a = ‚áëg a} ‚ÜíùíÑ Œ±
(Œ± : Type u_7) (Œ≤ : Type u_8) [has_inf Œ±] [has_inf Œ≤] : Type (max u_7 u_8)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e : local_homeomorph Œ± Œ≤} {s : set Œ±} {t : set Œ≤} : e.to_local_equiv.target ‚à© ‚áë(e.symm) ‚Åª¬π' (e.to_local_equiv.source ‚à© s) = e.to_local_equiv.target ‚à© t ‚Üí e.is_image s t
(K : Type u_1) [field K] : Type u_1
{o : ordinal} : ordinal.principal has_add.add o ‚Üî o = 0 ‚à® ‚àÉ (a : ordinal), o = ordinal.omega ^ a
{M : Type u_1} [monoid M] : mul_distrib_mul_action (mul_aut M) M
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] (F : J ‚•§ K ‚•§ C) (c : Œ† (k : K), category_theory.limits.limit_cone (F.flip.obj k)) (k : K) : ((category_theory.evaluation K C).obj k).map_cone (category_theory.limits.combine_cones F c) ‚âÖ (c k).cone
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : galois_connection l u) {x y z : Œ±} (hxy : x ‚â§ u (l y)) (hyz : y ‚â§ u (l z)) : x ‚â§ u (l z)
(Œ± : Type u_1) (Œ≤ : Type u_2) [topological_space Œ±] [topological_space Œ≤] [group Œ≤] [topological_group Œ≤] : subgroup (Œ± ‚Üí Œ≤)
{G : Type u_1} [group G] {H : subgroup G} {N : Type u_3} [group N] (f : G ‚Üí* N) : subgroup.map f H.normalizer ‚â§ (subgroup.map f H).normalizer
(type has_zero has_one has_add has_neg : expr) : ‚Ñ§ ‚Üí expr
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ : X} (p : path x‚ÇÄ x‚ÇÅ) : (path.refl x‚ÇÄ).homotopy (p.trans p.symm)
{J : Type u‚ÇÅ} [category_theory.category J] [category_theory.is_preconnected J] {Œ± : Type u‚ÇÅ} (F : J ‚•§ category_theory.discrete Œ±) (j : J) : F ‚âÖ (category_theory.functor.const J).obj (F.obj j)
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [ring_hom_surjective œÑ‚ÇÅ‚ÇÇ] (f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ) : submodule R‚ÇÇ M‚ÇÇ
{C : Type u_1} [category_theory.category C] (F : C ‚•§ category_theory.Cat) : Type (max u_1 u_6)
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_lt.lt] {a b : Œ±} : a‚Åª¬π < b ‚Üí b‚Åª¬π < a
{n : ‚Ñï} (i‚ÇÅ i‚ÇÇ : fin (n + 1)) : affine.simplex.points_with_circumcenter_index n ‚Üí ‚Ñù
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] {f : J ‚Üí C} (b : category_theory.limits.bicone f) (total : finset.univ.sum (Œª (j : J), b.œÄ j ‚â´ b.Œπ j) = ùüô b.X) : category_theory.limits.has_biproduct f
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] : has_coe_to_fun (bounded_continuous_function Œ± Œ≤) (Œª (_x : bounded_continuous_function Œ± Œ≤), Œ± ‚Üí Œ≤)
{R : Type u_1} (c‚ÇÅ c‚ÇÇ : R) : cardinal.mk ‚Ü•set.univ = cardinal.mk R ^ 4
{X : Type u} {G : Type u_2} [group G] [mul_action G X] {H : Type u_3} [group H] (F : category_theory.action_category G X ‚•§ category_theory.single_obj H) : G ‚Üí* (X ‚Üí H) ‚ãä[mul_aut_arrow] G
{Œ± : Type u} {Œ≤ : Type v} [has_sup Œ±] [semilattice_sup Œ≤] (f : Œ± ‚Üí Œ≤) (hf_inj : function.injective f) (map_sup : ‚àÄ (a b : Œ±), f (a ‚äî b) = f a ‚äî f b) : semilattice_sup Œ±
{n : ‚Ñï} (p : fin (n + 1)) (i : fin n) : ‚áëfin.cast_succ i < p ‚à® p < i.succ
(red : tactic.transparency) (atoms : tactic.ref (buffer expr)) (e : expr) {Œ± : Type} (m : tactic.ring.ring_m Œ±) : tactic Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [‚àÄ (X Y : C), subsingleton (X ‚ü∂ Y)] : category_theory.is_skeleton_of C (category_theory.thin_skeleton C) (category_theory.thin_skeleton.from_thin_skeleton C)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {v : ‚Ñù ‚Üí E ‚Üí E} {K : nnreal} (hv : ‚àÄ (t : ‚Ñù), lipschitz_with K (v t)) {f g f' g' : ‚Ñù ‚Üí E} {a b Œµf Œµg Œ¥ : ‚Ñù} (hf : continuous_on f (set.Icc a b)) (hf' : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_deriv_within_at f (f' t) (set.Ici t) t) (f_bound : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_dist.dist (f' t) (v t (f t)) ‚â§ Œµf) (hg : continuous_on g (set.Icc a b)) (hg' : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_deriv_within_at g (g' t) (set.Ici t) t) (g_bound : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_dist.dist (g' t) (v t (g t)) ‚â§ Œµg) (ha : has_dist.dist (f a) (g a) ‚â§ Œ¥) (t : ‚Ñù) (H : t ‚àà set.Icc a b) : has_dist.dist (f t) (g t) ‚â§ gronwall_bound Œ¥ ‚ÜëK (Œµf + Œµg) (t - a)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {x : E} (hf : has_strict_fderiv_at f f' x) : ‚àÉ (K : nnreal) (s : set E) (H : s ‚àà nhds x), lipschitz_on_with K f s
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {B : Type u‚ÇÑ} [category_theory.category B] (F : B ‚•§ C) (G : C ‚•§ D) (S : C) : category_theory.costructured_arrow F S ‚•§ category_theory.costructured_arrow (F ‚ãô G) (G.obj S)
{Œ± : Type u_1} {Œ≤ : Type u_2} {C : set (set Œ±)} {D : set (set Œ≤)} (hC : is_countably_spanning C) (hD : is_countably_spanning D) : prod.measurable_space = measurable_space.generate_from (set.image2 has_set_prod.prod C D)
{F : Type u‚ÇÄ ‚Üí Type u‚ÇÅ ‚Üí Type u‚ÇÇ} [bifunctor F] {Œ± Œ±' : Type u‚ÇÄ} {Œ≤ : Type u‚ÇÅ} (f : Œ± ‚Üí Œ±') : F Œ± Œ≤ ‚Üí F Œ±' Œ≤
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : Œ±) (s : finset Œ±) : uv.compression u v (uv.compression u v s) = uv.compression u v s
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e : local_homeomorph Œ± Œ≤} {s : set Œ±} {t : set Œ≤} : e.to_local_equiv.target ‚à© ‚áë(e.symm) ‚Åª¬π' s = e.to_local_equiv.target ‚à© t ‚Üí e.is_image s t
{Œ± : Type u} {Œ≤ : Type v} [add_comm_group Œ≤] : (Œ± ‚Üí Œ≤) ‚âÉ (free_abelian_group Œ± ‚Üí+ Œ≤)
{m : Type ‚Üí Type} [monad m] {key : Type} (s : native.rb_set key) (P : key ‚Üí m bool) : m (native.rb_set key)
{n a b : ‚Ñï} (h : a ‚â§ b) : a ‚â° b [MOD n] ‚Üî n ‚à£ b - a
{K : Type u_1} {v : K} {n : ‚Ñï} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : ifp_n.fr < 1
(R : Type u_1) {K : Type u_2} {T : Type u_3} {U : Type u_4} [comm_ring R] [field K] [comm_ring T] [algebra R K] [algebra K T] [algebra R T] [is_scalar_tower R K T] [comm_semiring U] [algebra K U] [algebra R U] [is_scalar_tower R K U] (x : T) (y : U) (hy : ‚áë(polynomial.aeval y) (minpoly K x) = 0) : ‚áë(polynomial.aeval y) (minpoly R x) = 0
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} {C : P.W Œ± ‚Üí Prop} (ih : ‚àÄ (a : P.A) (f' : (P.drop.B a).arrow Œ±) (f : P.last.B a ‚Üí P.W Œ±), (‚àÄ (i : P.last.B a), C (f i)) ‚Üí C (P.W_mk a f' f)) (x : P.W Œ±) : C x
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (f : Œ≤ ‚Üí Œ≥) (g : Œ± ‚Üí. Œ≤) : Œ± ‚Üí. Œ≥
{M : Type u_1} {N : Type u_2} [mM : mul_one_class M] [mN : mul_one_class N] {f : M ‚Üí N} (h : is_monoid_hom f) : M ‚Üí* N
{Œπ : Type u_1} (p : ‚Ñù) [fact_one_le_p : fact (1 ‚â§ p)] (Œ≤ : Œπ ‚Üí Type u_4) [fintype Œπ] [Œ† (i : Œπ), pseudo_emetric_space (Œ≤ i)] : pseudo_emetric_space (pi_Lp p Œ≤)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) (h : s.sum (Œª (i : Œπ), w i) = 0) (b : P) : ‚áë(s.weighted_vsub p) w = ‚áë(s.weighted_vsub_of_point p b) w
{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) : K ‚â§ K·óÆ·óÆ
{M : Type u_1} [add_semigroup M] {A : Type u_2} [set_like A M] [add_mem_class A M] (S : A) : add_semigroup ‚Ü•S
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {x : E} : mdifferentiable_at (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f x ‚Üí differentiable_at ùïú f x
{G : Type u_1} [add_group G] (N H : add_subgroup G) [N.normal] : ‚Üë(N ‚äî H) = ‚ÜëN + ‚ÜëH
(ùïú : Type u_1) {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [has_scalar ùïú Œ≤] (s : set E) (f : E ‚Üí Œ≤) : Prop
 : gcd_monoid ‚Ñï
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {x : E} {n : with_top ‚Ñï} {s : set E} {f g : E ‚Üí ùïú} (hf : cont_diff_within_at ùïú n f s x) (hg : cont_diff_within_at ùïú n g s x) : cont_diff_within_at ùïú n (Œª (x : E), f x * g x) s x
{Œ± : Type u} {L L' : list Œ±} (h : L = L') {i : ‚Ñï} (hi : i < L.length) : L.nth_le i hi = L'.nth_le i _
{Œ± : Type u_1} [has_le Œ±] {s : set Œ±} : is_lower_set s ‚Üí is_upper_set (‚áëorder_dual.of_dual ‚Åª¬π' s)
{J : Type v} {C : Type u} [category_theory.category C] {B : C} {objs : J ‚Üí C} {arrows : Œ† (j : J), B ‚ü∂ objs j} [category_theory.limits.has_wide_pushout B objs arrows] {X : C} (f : B ‚ü∂ X) (fs : Œ† (j : J), objs j ‚ü∂ X) (w : ‚àÄ (j : J), arrows j ‚â´ fs j = f) : category_theory.limits.wide_pushout B (Œª (j : J), objs j) arrows ‚ü∂ X
{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a
{G : Type w} [group G] [topological_space G] [topological_group G] (x : G) : G ‚âÉ‚Çú G
 : pgame ‚Üí Prop
{R : Type u} [comm_ring R] (M : Module R) : Module.of R (tensor_product R R ‚Ü•M) ‚âÖ M
 : tactic unit
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) : hb.oangle x (-y) = hb.oangle x y + ‚Üëreal.pi
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_group E] [has_scalar ùïú E] (S : convex_cone ùïú E) (h‚ÇÅ : S.pointed) (h‚ÇÇ : S.salient) : partial_order E
{R : Type u} {L : Type v} {L' : Type w‚ÇÇ} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L') : Prop
 : nnreal ‚Üí+* ennreal
{M : Type u_1} [has_mul M] (S : subsemigroup M) : subsemigroup.closure ‚ÜëS = S
{M : Type u_1} [comm_monoid M] {A : Type u_2} [set_like A M] [submonoid_class A M] (S : A) : comm_monoid ‚Ü•S
{Œ± : Type u_1} [preorder Œ±] {f g : Œ± ‚Üí Œ±} (hg : monotone g) (h : f ‚â§ g) (n : ‚Ñï) : f^[n] ‚â§ (g^[n])
 : name ‚Üí name
(hs : interactive.parse tactic.simp_arg_list) (l : interactive.parse interactive.types.location) : tactic unit
 : Type
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ‚Ñ§] [category_theory.preadditive C] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] : category_theory.triangulated.pretriangulated.triangulated_functor_struct C C
{C : Type u‚ÇÅ} [category_theory.small_category C] : category_theory.colimit_adj.restricted_yoneda category_theory.yoneda ‚âÖ ùü≠ (C·µí·µñ ‚•§ Type u‚ÇÅ)
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {P : C(X, Y) ‚Üí Prop} {f‚ÇÄ f‚ÇÅ : C(X, Y)} (F : f‚ÇÄ.homotopy_with f‚ÇÅ P) : f‚ÇÅ.homotopy_with f‚ÇÄ P
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] {Œ± : E} {K : Type u_3} [field K] [algebra F K] (h : is_integral F Œ±) : (‚Ü•F‚üÆŒ±‚üØ ‚Üí‚Çê[F] K) ‚âÉ {x // x ‚àà (polynomial.map (algebra_map F K) (minpoly F Œ±)).roots}
{R : Type v} [comm_ring R] {n : ‚Ñï} (A : matrix (fin n.succ) (fin n.succ) R) (i : fin n.succ) : A.det = finset.univ.sum (Œª (j : fin n.succ), (-1) ^ (‚Üëi + ‚Üëj) * A i j * (A.minor ‚áë(i.succ_above) ‚áë(j.succ_above)).det)
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M ‚Üí* P} {T : submonoid P} {Q : Type u_4} [comm_monoid Q] (hg : ‚àÄ (y : ‚Ü•S), ‚áëg ‚Üëy ‚àà T) (k : T.localization_map Q) {x y : M} (h : ‚áë(f.to_map) x = ‚áë(f.to_map) y) : ‚áë(k.to_map) (‚áëg x) = ‚áë(k.to_map) (‚áëg y)
{Œ± : Type u} [inhabited Œ±] (a : Œ±) : list Œ± ‚Üí ‚Ñï ‚Üí list Œ±
{R : Type u_1} [rack R] : rack.envel_group R ‚Üí* R ‚âÉ R
{Œ± : Type u_1} (s : set (set Œ±)) : measurable_space Œ±
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (f : M ‚Üí‚Çô* N) {g : N ‚Üí M} (h : function.left_inverse g ‚áëf) : M ‚âÉ* ‚Ü•(f.srange)
 : tactic name
{Œ± : Type u_1} (f : filter Œ±) [f.is_countably_generated] : ‚àÉ (x : ‚Ñï ‚Üí set Œ±), f.has_antitone_basis x
(K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] (pb : power_basis K L) [is_separable K L] : algebra.discr K ‚áë(pb.basis) = (-1) ^ (finite_dimensional.finrank K L * (finite_dimensional.finrank K L - 1) / 2) * ‚áë(algebra.norm K) (‚áë(polynomial.aeval pb.gen) (‚áëpolynomial.derivative (minpoly K pb.gen)))
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] : category_theory.subobject X
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {F : Type u_3} [normed_group F] [normed_space ‚Ñù F] (f : E ‚âÉ·µ¢ F) : E ‚âÉ‚Çó·µ¢[‚Ñù] F
 : category_theory.limits.types.binary_product_functor ‚âÖ category_theory.limits.prod.functor
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} (f g : c.quotient ‚Üí+ P) (h : ‚àÄ (a : M), ‚áëf ‚Üëa = ‚áëg ‚Üëa) : f = g
{Œ± : Type u_5} {Œ≤ : Type u_6} [non_assoc_semiring Œ±] [non_assoc_semiring Œ≤] (self : Œ± ‚Üí+* Œ≤) : Œ± ‚Üí‚Çô+* Œ≤
{R : Type u} [ring R] {J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Module R) (r : R) (x : Œ£ (j : J), ‚Ü•(F.obj j)) : ‚Ü•(Module.filtered_colimits.M F)
(use_dec use_classical : bool) (extra_dec : list expr) : tactic unit
 : module_info ‚Üí module_info.module_id
{X Y : Group} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ* ‚Ü•Y
 : nat.arithmetic_function ‚Ñï
(k : Type u_1) [division_ring k] {Œπ : Type u_4} (s : finset Œπ) [char_zero k] (h : s.card ‚â† 0) : s.sum (Œª (i : Œπ), finset.centroid_weights k s i) = 1
{Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_action Œ± Œ≤] (a : Œ±) : equiv.perm Œ≤
{G : Type u_1} {Œ± : Type u_3} [measurable_space G] [measurable_space Œ±] [add_group G] [add_action G Œ±] [has_measurable_vadd G Œ±] (c : G) : Œ± ‚âÉ·µê Œ±
{R : Type u_1} {S : Type u_2} [ring R] [topological_space R] [nonarchimedean_ring R] [ring S] [topological_space S] [nonarchimedean_ring S] : nonarchimedean_ring (R √ó S)
{Œ± : Type u_1} {s : finset Œ±} {f : Œ± ‚Üí ennreal} (h : ‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚â† ‚ä§) : s.sum (Œª (a : Œ±), f a) < ‚ä§
{M : Type u_1} [add_monoid M] (S : add_submonoid M) : ‚Ü•(S.left_neg) ‚Üí ‚Ü•S
(Œ± : Type u_1) : Œ± √ó punit ‚âÉ Œ±
{C : Type u} [category_theory.category C] (X : C) : category_theory.with_terminal.incl.obj X ‚ü∂ category_theory.with_terminal.star
{R : Type u_1} [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] (hp : p ‚à£ fintype.card R) : ¬¨is_unit ‚Üëp
{m : Type u} {Œ± : Type v} [comm_ring Œ±] [fintype m] [decidable_eq m] {M : matrix m m Œ±} (h : is_unit M) (N : matrix m m Œ±) : ((M‚Åª¬π.mul N).mul M).det = N.det
{Œ± : Type u_1} [topological_space Œ±] {x : Œ±} {s : set Œ±} {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] [has_continuous_add Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : upper_semicontinuous_within_at f s x) (hg : upper_semicontinuous_within_at g s x) : upper_semicontinuous_within_at (Œª (z : Œ±), f z + g z) s x
{Œ± : Type u} [topological_space Œ±] (s : set Œ±) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) {J : Type u} [category_theory.category J] {K : J ‚•§ C} (Y : D) (t : ((category_theory.cocones J D).obj (opposite.op (K ‚ãô F))).obj Y) : (G ‚ãô (category_theory.cocones J C).obj (opposite.op K)).obj Y
{Œ± : Type u_1} {R : Type u_2} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] [semiring Œ±] [module Œ± M] [smul_comm_class Œ± R M] : mul_action_with_zero Œ± (submodule R M)
{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {A B : C} (f : A ‚ü∂ B) : category_theory.over.map f ‚ä£ category_theory.over.pullback f
 : native.float ‚Üí native.float
(n : ‚Ñ§) (d : ‚Ñï) : ‚Ñö
{u : ‚Ñï ‚Üí ‚Ñù} {l : ‚Ñù} (h : filter.tendsto u filter.at_top (nhds l)) : filter.tendsto (Œª (n : ‚Ñï), (‚Üën)‚Åª¬π * (finset.range n).sum (Œª (i : ‚Ñï), u i)) filter.at_top (nhds l)
{X : Type u} [preorder X] {x y : X} (h : x ‚â§ y) : x ‚ü∂ y
{k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] {Œπ : Type u_3} {p : Œπ ‚Üí V} : affine_independent k p ‚Üî ‚àÄ (s : finset Œπ) (w : Œπ ‚Üí k), s.sum w = 0 ‚Üí s.sum (Œª (e : Œπ), w e ‚Ä¢ p e) = 0 ‚Üí ‚àÄ (e : Œπ), e ‚àà s ‚Üí w e = 0
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (p : set Œ±) : ‚Ü•p ‚Üí ‚Ü•p ‚Üí Prop
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ SemiRing Mon)
(a : pos_num) : pos_num
{F : Type u_1} [field F] {p : polynomial F} (hp : p.separable) : fintype.card p.gal = finite_dimensional.finrank F p.splitting_field
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] (F : A ‚•§ B) : ùü≠ A ‚ãô F ‚âÖ F
(tac : bool ‚Üí list tactic.simp_arg_type ‚Üí tactic unit) (user_args simp_args : list tactic.simp_arg_type) : tactic (list tactic.simp_arg_type)
(E : Type u_1) [semi_normed_group E] [star_add_monoid E] : Prop
{S : Type u‚ÇÅ} {L : Type u‚ÇÇ} {D : Type u‚ÇÉ} [category_theory.category S] [category_theory.category L] [category_theory.category D] (Œπ : S ‚•§ L) (F : S ‚•§ D) [‚àÄ (x : L), category_theory.limits.has_limit (category_theory.Ran.diagram Œπ F x)] : L ‚•§ D
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (b : Œ≤) : list Œ± ‚Üí Œ≤ √ó list Œ≤
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) [category_theory.is_filtered J] : category_theory.limits.cocone F
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : set Œ±) : Prop
(S T : set ‚Ñï+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [h : is_cyclotomic_extension (S ‚à™ T) A B] : is_cyclotomic_extension T ‚Ü•(algebra.adjoin A {b : B | ‚àÉ (a : ‚Ñï+), a ‚àà S ‚àß b ^ ‚Üëa = 1}) B
{n : ‚Ñï} [fact (0 < n)] : fintype (quaternion_group n)
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a : Œ±} : -a ‚â§ 0 ‚Üî 0 ‚â§ a
(p : ‚Ñï) (q : ‚Ñö) : ‚Ñö
{Œπ : Type uŒπ} (R : Type uR) (A : Œπ ‚Üí Type uA) {B : Type uB} [decidable_eq Œπ] [comm_semiring R] [Œ† (i : Œπ), add_comm_monoid (A i)] [Œ† (i : Œπ), module R (A i)] [add_monoid Œπ] [direct_sum.gsemiring A] [semiring B] [direct_sum.galgebra R A] [algebra R B] (f : Œ† (i : Œπ), A i ‚Üí‚Çó[R] B) (hone : ‚áë(f 0) graded_monoid.ghas_one.one = 1) (hmul : ‚àÄ {i j : Œπ} (ai : A i) (aj : A j), ‚áë(f (i + j)) (graded_monoid.ghas_mul.mul ai aj) = ‚áë(f i) ai * ‚áë(f j) aj) (hcommutes : ‚àÄ (r : R), ‚áë(f 0) (‚áëdirect_sum.galgebra.to_fun r) = ‚áë(algebra_map R B) r) : direct_sum Œπ (Œª (i : Œπ), A i) ‚Üí‚Çê[R] B
(C : Type u) [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} {r : Y ‚ü∂ X} (hr : f ‚â´ r ‚â´ f = f) (h : category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ f _)) : category_theory.split_mono f
{R : Type u_1} [comm_ring R] (P : ideal (polynomial R)) : function.injective ‚áë((ideal.map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) P).quotient_map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) ideal.le_comap_map)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {s : set E} {c : nnreal} : lipschitz_on_with c (f - ‚áëf') s ‚Üí approximates_linear_on f f' s c
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (T : E ‚Üí‚Çó[ùïú] E) : Prop
{Œ± : Type u_1} {n : ‚Ñï} {i : fin2 n} : typevec.repeat n Œ± i ‚Üí Œ±
(C : Type u) [category_theory.category C] : Prop
{n p k : ‚Ñï} (hn : n ‚â† 0) (h : n.factorization = finsupp.single p k) : n = p ^ k
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (c : add_con M) (f : M ‚Üí N) : add_con N
(p q : ‚Ñï) [hp : fact (nat.prime p)] (hq0 : ‚Üëq ‚â† 0) : (finset.Ico 1 (p / 2).succ).sum (Œª (a : ‚Ñï), a * q / p) + (finset.Ico 1 (q / 2).succ).sum (Œª (a : ‚Ñï), a * p / q) = p / 2 * (q / 2)
(p n : ‚Ñï) : mv_polynomial (fin 2 √ó ‚Ñï) ‚Ñ§
{Œ± : Type u} (s : wseq Œ±) : wseq (list Œ±)
{Œ± : Type u} {Œ≤ : Type v} [semiring Œ±] [semiring Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_semiring_hom f) : is_add_monoid_hom f
(nm : name) (type lhs rhs : expr) (args : list expr) (univs : list name) (cfg : simps_cfg) : tactic unit
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (n : with_top ‚Ñï) (f : E ‚Üí F) : Prop
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] : list Œ± ‚Üí option Œ±
{c w : ‚ÑÇ} {R : ‚Ñù} (hw : w ‚àà metric.ball c R) : ‚àÆ (z : ‚ÑÇ) in C(c, R), (z - w)‚Åª¬π = 2 * ‚Üëreal.pi * complex.I
{Œ± : Type u_1} {Œ≤ : Type u_2} [complete_lattice Œ±] (a : Œ±) (f : Œ≤ ‚Üí Œ±) : (‚®Ü (o : option Œ≤), option.elim a f o) = a ‚äî ‚®Ü (b : Œ≤), f b
{Œ± : Type u} [pseudo_emetric_space Œ±] {x : Œ±} {s t : set Œ±} (h : s ‚äÜ t) : emetric.inf_edist x t ‚â§ emetric.inf_edist x s
{Œ± : Type u_1} {Œ≤ : Type u_2} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {K : nnreal} {f : Œ± ‚Üí Œ≤} : (‚àÄ (x y : Œ±), has_dist.dist x y ‚â§ ‚ÜëK * has_dist.dist (f x) (f y)) ‚Üí antilipschitz_with K f
 : expr ‚Üí name
 : linarith.ineq ‚Üí linarith.ineq ‚Üí name √ó linarith.ineq
{R : Type u} [semiring R] {P : Type (max u v)} [add_comm_monoid P] [module R P] (huniv : ‚àÄ {M : Type (max v u)} {N : Type (max u v)} [_inst_8 : add_comm_monoid M] [_inst_9 : add_comm_monoid N] [_inst_10 : module R M] [_inst_11 : module R N] (f : M ‚Üí‚Çó[R] N) (g : P ‚Üí‚Çó[R] N), function.surjective ‚áëf ‚Üí (‚àÉ (h : P ‚Üí‚Çó[R] M), f.comp h = g)) : module.projective R P
{G : Type u_10} [group G] : G ‚âÉ* GÀ£
{C : Type u} [category_theory.category C] {D : Type v‚ÇÅ} (F : D ‚Üí category_theory.arrow C) : category_theory.category (category_theory.right_lifting_subcat C)
(Œ± : Type u_5) (Œ≤ : Type u_6) [non_assoc_semiring Œ±] [non_assoc_semiring Œ≤] : Type (max u_5 u_6)
{Œπ : Type u_1} {Œ± : Type u_2} (s : Œπ ‚Üí set Œ±) (dis : ‚àÄ (i j : Œπ), i ‚â† j ‚Üí disjoint (s i) (s j)) (nonempty : ‚àÄ (i : Œπ), (s i).nonempty) (ex : ‚àÄ (x : Œ±), ‚àÉ (i : Œπ), x ‚àà s i) : indexed_partition s
{R : Type u_1} [comm_ring R] (c‚ÇÅ c‚ÇÇ : R) : quadratic_form R (R √ó R)
(X : Type u) [topological_space X] : Top
 : list name ‚Üí list string √ó list string
{R : Type u} {S : Type v} [non_assoc_semiring R] [set_like S R] [hSR : subsemiring_class S R] (s : S) : ‚Ü•s ‚Üí+* R
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [add_monoid Œ≤] : add_monoid Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : category_theory.well_powered C ‚Üî category_theory.well_powered D
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [normed_space ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} {E' : Type u_10} [semi_normed_group E'] [normed_space ùïú E'] [ring_hom_isometric œÉ‚ÇÅ‚ÇÇ] {Œ± : Type u_3} {l : filter Œ±} [l.ne_bot] (f : E' ‚Üí F) (g : Œ± ‚Üí (E' ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F)) (hf : filter.tendsto (Œª (a : Œ±) (x : E'), ‚áë(g a) x) l (nhds f)) (hg : metric.bounded (set.range g)) : E' ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F
{Œ± : Type u_1} [comm_ring Œ±] (E : linear_recurrence Œ±) (q : Œ±) : E.is_solution (Œª (n : ‚Ñï), q ^ n) ‚Üî E.char_poly.is_root q
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [comm_ring A] [comm_ring B] [algebra R A] [algebra R B] (f : A ‚Üí‚Çê[R] B) [is_noetherian_ring A] : is_noetherian_ring ‚Ü•(f.range)
{M : Type u_1} {N : Type u_2} [semigroup M] [semigroup N] {s : set M} (f : M ‚Üí N) (hs : subsemigroup.closure s = ‚ä§) (hmul : ‚àÄ (x y : M), y ‚àà s ‚Üí f (x * y) = f x * f y) : M ‚Üí‚Çô* N
{C : Type u} [category_theory.category C] {f g : category_theory.arrow C} [category_theory.limits.has_image f.hom] [category_theory.limits.has_image g.hom] (sq : f ‚ü∂ g) : Type v
{R : Type u_1} {S : Type u_3} [non_unital_comm_semiring R] [non_unital_comm_semiring S] : non_unital_comm_semiring (R √ó S)
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {R : ‚Ñù} (h0 : 0 < R) {f : ‚ÑÇ ‚Üí E} {c : ‚ÑÇ} {s : set ‚ÑÇ} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R)) (hd : ‚àÄ (z : ‚ÑÇ), z ‚àà metric.ball c R  s ‚Üí differentiable_at ‚ÑÇ f z) : ‚àÆ (z : ‚ÑÇ) in C(c, R), (z - c)‚Åª¬π ‚Ä¢ f z = (2 * ‚Üëreal.pi * complex.I) ‚Ä¢ f c
(Œ± : Type u) : Type u
{Œ± : Type u_1} {M : Type u_4} [comm_monoid M] (f : Œ± ‚Üí M) {s t : finset Œ±} (h : s ‚äÜ t) : s.prod (Œª (i : Œ±), f i) = t.prod (Œª (i : Œ±), ‚Üës.mul_indicator f i)
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] {i : D.to_glue_data.J} (U : topological_space.opens ‚Ü•((D.to_glue_data.U i).carrier)) (j : category_theory.limits.walking_multispan D.to_glue_data.diagram.fst_from D.to_glue_data.diagram.snd_from) : (D.to_glue_data.U i).presheaf.obj (opposite.op U) ‚ü∂ (D.diagram_over_open U).obj (opposite.op j)
 : W_type W_type.nat_Œ≤ ‚Üí ‚Ñï
{Œ± : Type u_1} (R : Œ± ‚Üí Œ± ‚Üí Prop) : list Œ± ‚Üí Prop
{a b : ‚Ñù} (h : a < b) : cardinal.mk ‚Ü•(set.Ioc a b) = cardinal.continuum
(r : pexpr) : tactic unit
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) : Prop
(p : interactive.parse interactive.types.texpr) (t : interactive.parse tactic.to_texpr) (h : interactive.parse tactic.using_texpr) (n : interactive.parse interactive.types.with_ident_list) : tactic unit
{Œ± : Type u_8} [comm_group_with_zero Œ±] : Œ± √ó Œ± ‚Üí*‚ÇÄ Œ±
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (l‚ÇÅ : filter Œ±) (l‚ÇÇ : filter Œ≤) : Prop
{q : ‚Ñï+} : fintype.card (lucas_lehmer.X q) = ‚Üëq ^ 2
{B : Type u} [quiver B] : category_theory.bicategory (category_theory.free_bicategory B)
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : continuous_at f b) : has_strict_deriv_at (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in a..u, f x) (f b) b
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : r ‚Ü™r s) : function.swap r ‚Ü™r function.swap s
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] {a b : Œ±} : ¬¨a ‚â§ b ‚Üí finset.Icc a b = ‚àÖ
(X : Type u_1) [normed_group X] {M : Type} [ring M] [module M X] (P : M) : Prop
 : well_founded nat.lt
{n : ‚Ñï} (i : ‚Ñï) (h : i < n) : fin n
(_x : interactive.parse (lean.parser.tk "trace!")) (s : string) : lean.parser pexpr
 : ‚Ñù ‚Üí+* ‚ÑÇ
{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {K : nnreal} {f : Œ± ‚Üí Œ≤} : (‚àÄ (x y : Œ±), has_dist.dist (f x) (f y) ‚â§ ‚ÜëK * has_dist.dist x y) ‚Üí lipschitz_with K f
{A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] {x : B} (hx : is_integral A x) : (minpoly A x).monic
 : Type
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddGroup) : category_theory.creates_limit F (category_theory.forget‚ÇÇ AddGroup AddMon)
{Œ± : Type u} : has_inf (filter Œ±)
{Œ± : Type u_1} {Œ≤ : Type u_2} [conditionally_complete_lattice Œ±] [semilattice_sup Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : monotone f) (hg : antitone g) (h : f ‚â§ g) : (‚®Ü (n : Œ≤), f n) ‚àà ‚ãÇ (n : Œ≤), set.Icc (f n) (g n)
{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ‚â† 0) : 0 < L.length
{Œ± : Type} (f : Œ± ‚Üí expr ‚Üí tactic.unsafe.type_context Œ±) : Œ± ‚Üí tactic.unsafe.type_context Œ±
{Œ± : Type u_1} (g : generalized_continued_fraction Œ±) (n : ‚Ñï) : Prop
{Œπ : Type u_1} {M : Type u_4} [ordered_add_comm_monoid M] {s : finset Œπ} {f : Œπ ‚Üí with_top M} : s.sum (Œª (i : Œπ), f i) = ‚ä§ ‚Üî ‚àÉ (i : Œπ) (H : i ‚àà s), f i = ‚ä§
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a b : Œ±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} [comm_ring R] {p n : ‚Ñï} (hp : nat.prime p) : polynomial.cyclotomic (p ^ (n + 1)) R = (finset.range p).sum (Œª (i : ‚Ñï), (polynomial.X ^ p ^ n) ^ i)
 : Type (u_1+1)
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
{G : Type u} [group G] (N : subgroup G) [nN : N.normal] : G ‚Üí* G ‚ß∏ N
{G : Type u} [group G] {R : Type v} [semiring R] [mul_semiring_action G R] (H : subgroup G) : mul_semiring_action ‚Ü•H R
{cb : char_buffer} {n n' val : ‚Ñï} : parser.nat cb n = parse_result.done n' val ‚Üî ‚àÉ (hn : n < n'), val = nat.of_digits 10 (list.map (Œª (c : char), c.to_nat - '0'.to_nat) (list.take (n' - n) (list.drop n (buffer.to_list cb))).reverse) ‚àß (‚àÄ (hn' : n' < buffer.size cb), '0' ‚â§ buffer.read cb ‚ü®n', hn'‚ü© ‚Üí '9' < buffer.read cb ‚ü®n', hn'‚ü©) ‚àß ‚àÉ (hn'' : n' ‚â§ buffer.size cb), ‚àÄ (k : ‚Ñï) (hk : k < n'), n ‚â§ k ‚Üí '0' ‚â§ buffer.read cb ‚ü®k, _‚ü© ‚àß buffer.read cb ‚ü®k, _‚ü© ‚â§ '9'
{X Y : Top} {f g : C(‚Ü•X, ‚Ü•Y)} (H : f.homotopy g) {x‚ÇÄ x‚ÇÅ : ‚Ü•X} (p : fundamental_groupoid.from_top x‚ÇÄ ‚ü∂ fundamental_groupoid.from_top x‚ÇÅ) : fundamental_groupoid.from_top (‚áëH (0, x‚ÇÄ)) ‚ü∂ fundamental_groupoid.from_top (‚áëH (1, x‚ÇÅ))
{Œ± : Type u} {Œ≤ : Type v} [has_sup Œ±] [has_inf Œ±] [has_Sup Œ±] [has_Inf Œ±] [has_top Œ±] [has_bot Œ±] [has_compl Œ±] [has_sdiff Œ±] [complete_boolean_algebra Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.injective f) (map_sup : ‚àÄ (a b : Œ±), f (a ‚äî b) = f a ‚äî f b) (map_inf : ‚àÄ (a b : Œ±), f (a ‚äì b) = f a ‚äì f b) (map_Sup : ‚àÄ (s : set Œ±), f (has_Sup.Sup s) = ‚®Ü (a : Œ±) (H : a ‚àà s), f a) (map_Inf : ‚àÄ (s : set Œ±), f (has_Inf.Inf s) = ‚®Ö (a : Œ±) (H : a ‚àà s), f a) (map_top : f ‚ä§ = ‚ä§) (map_bot : f ‚ä• = ‚ä•) (map_compl : ‚àÄ (a : Œ±), f a·∂ú = (f a)·∂ú) (map_sdiff : ‚àÄ (a b : Œ±), f (a  b) = f a  f b) : complete_boolean_algebra Œ±
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop} (h : ‚àÄ (x : Œ±), p x ‚Üî q (f x)) : (Œ£ (y : subtype q), {x // f x = ‚Üëy}) ‚âÉ subtype p
{Œ± : Type u_1} [finite Œ±] {n : ‚Ñï} (h : nat.card Œ± = n) : Œ± ‚âÉ fin n
{Œ± : Type u} [decidable_eq Œ±] : list Œ± ‚Üí list (finset Œ±)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (h‚ÇÅ : Œ± ‚âÉ‚Çú Œ≤) (h‚ÇÇ : Œ≤ ‚âÉ‚Çú Œ≥) : Œ± ‚âÉ‚Çú Œ≥
 : expr ‚Üí tactic (expr √ó expr)
 : tactic.rewrite_search.how ‚Üí format
{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (v : V) : G.min_degree ‚â§ G.degree v
{ùïú : Type u} [nondiscrete_normed_field ùïú] {E : Type v} [normed_group E] [normed_space ùïú E] [complete_space ùïú] (Œπ : Type u_1) [fintype Œπ] [decidable_eq Œπ] : ((Œπ ‚Üí ùïú) ‚ÜíL[ùïú] E) ‚âÉL[ùïú] Œπ ‚Üí E
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X Y : C} {S : category_theory.sieve X} (f : Y ‚ü∂ X) (x : category_theory.presieve.family_of_elements P ‚áëS) : category_theory.presieve.family_of_elements P ‚áë(category_theory.sieve.pullback f S)
{G : Type u_1} [group G] (H K : subgroup G) (g : conj_act G) : ‚Ü•K ‚ß∏ H.subgroup_of K ‚âÉ ‚Ü•((g ‚Ä¢ K).carrier) ‚ß∏ (g ‚Ä¢ H).subgroup_of (g ‚Ä¢ K)
{M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_3} [mul_zero_class M‚ÇÄ] [has_mul M‚ÇÄ'] [has_zero M‚ÇÄ'] (f : M‚ÇÄ ‚Üí M‚ÇÄ') (hf : function.surjective f) (zero : f 0 = 0) (mul : ‚àÄ (a b : M‚ÇÄ), f (a * b) = f a * f b) : mul_zero_class M‚ÇÄ'
{Œ± : Type u_1} {M : Type u_2} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {Œ±' : Type u_3} (s : set Œ±) (t : set Œ±') (e : ‚Ü•s ‚âÉ ‚Ü•t) : ‚Ü•(finsupp.supported M R s) ‚âÉ‚Çó[R] ‚Ü•(finsupp.supported M R t)
 : native.float ‚Üí bool
(G : pgame) : ordinal
{Œ± : Type u_1} {G‚ÇÄ : Type u_3} [group_with_zero G‚ÇÄ] [topological_space G‚ÇÄ] [has_continuous_inv‚ÇÄ G‚ÇÄ] [has_continuous_mul G‚ÇÄ] {f g : Œ± ‚Üí G‚ÇÄ} [topological_space Œ±] {a : Œ±} (hf : continuous_at f a) (hg : continuous_at g a) (h‚ÇÄ : g a ‚â† 0) : continuous_at (f / g) a
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [linear_ordered_add_comm_monoid_with_top Œì‚ÇÄ] [comm_ring R] (v : add_valuation R Œì‚ÇÄ) {J : ideal R} (hJ : J ‚â§ v.supp) : (v.on_quot hJ).supp = ideal.map (ideal.quotient.mk J) v.supp
{Œ± : Type u_2} [decidable_eq Œ±] [add_zero_class Œ±] : Œ± ‚Üí+ finset Œ±
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] (F : C ‚•§ D) [category_theory.limits.preserves_colimits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] [category_theory.limits.preserves_colimits_of_shape (category_theory.discrete pempty) F] [category_theory.limits.has_finite_coproducts C] (J : Type v) [fintype J] : category_theory.limits.preserves_colimits_of_shape (category_theory.discrete J) F
{Œ± : Type u_1} [ring Œ±] (self : ring.positive_cone Œ±) : add_comm_group.positive_cone Œ±
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] (M : Type u_3) [monoid M] [mul_semiring_action M E] [smul_comm_class M F E] : intermediate_field F E
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type w} [fintype Œπ] (h : basis Œπ K V) : finite_dimensional.finrank K V = fintype.card Œπ
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 ‚àà s) : has_dist.dist p1 p2 * has_dist.dist p1 p2 = has_dist.dist p1 ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p2) * has_dist.dist p1 ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p2) + has_dist.dist p2 ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p2) * has_dist.dist p2 ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p2)
{Œ± : Type u} [pseudo_emetric_space Œ±] {s : set Œ±} : emetric.Hausdorff_edist s (closure s) = 0
{Œ± : Type u_1} [partial_order Œ±] [succ_order Œ±] [is_succ_archimedean Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) {n m : Œ±} (h : ‚àÄ (i : Œ±), i ‚àà set.Ico n m ‚Üí r i (order.succ i)) (hnm : n ‚â§ m) : relation.refl_trans_gen r n m
{f : ‚Ñù ‚Üí ‚Ñù} {a : ‚Ñù} (h : is_local_max f a) : deriv f a = 0
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] : pseudo_metric_space (bounded_continuous_function Œ± Œ≤)
{C : Type u} [category_theory.category C] {X Y : C} (s : category_theory.limits.binary_cofan X Y) : (category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right} ‚ü∂ ((category_theory.functor.const (category_theory.discrete category_theory.limits.walking_pair)).obj s.X).obj {as := category_theory.limits.walking_pair.right}
{R : Type u} {M : Type v} [ring R] {N : Type u_3} [add_comm_group M] [module R M] [add_comm_group N] [module R N] (f : M √ó N ‚Üí‚Çó[R] M) (i : function.injective ‚áëf) (n : ‚Ñï) : ‚Ü•(f.tailing i n) ‚âÉ‚Çó[R] N
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : Type (max u v)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ (v‚ÇÇ+1))
{R : Type u} {Œπ : Type w} (s : finset Œπ) [comm_semiring R] (f : Œπ ‚Üí polynomial R) (h : s.prod (Œª (i : Œπ), (f i).leading_coeff) ‚â† 0) : (s.prod (Œª (i : Œπ), f i)).nat_degree = s.sum (Œª (i : Œπ), (f i).nat_degree)
 : Type u ‚•§ Pointed
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ CommGroup CommMon)
{M : Type u_1} [has_add M] : has_Inf (add_con M)
 : matrix.special_linear_group (fin 2) ‚Ñ§
 : name ‚Üí ‚Ñï ‚Üí name
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (i : fin 1) : (affine.simplex.mk_of_point k p).points i = p
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [‚Ñ∞ : category_theory.category E] {F : C ‚•§ D} {G : D ‚•§ E} [Fr : category_theory.is_right_adjoint F] [Gr : category_theory.is_right_adjoint G] : category_theory.is_right_adjoint (F ‚ãô G)
 : ‚Ñï ‚Üí tactic (list expr)
{k : Type u} [linear_ordered_field k] {a : k} (ha : 0 < a) : (set.Ioo 0 a)‚Åª¬π = set.Ioi a‚Åª¬π
(A : Type u) [comm_ring A] (K : Type v) [field K] [algebra A K] : Type v
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_solvable R ‚Ü•(lie_algebra.radical R L)
 : category_theory.is_skeleton_of NonemptyFinLinOrd simplex_category simplex_category.skeletal_functor
(v : prime_multiset) : ‚Ñï+
 : turing.partrec_to_TM2.cont' ‚Üí finset turing.partrec_to_TM2.Œõ'
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) : category_theory.limits.is_limit (CommRing.limit_cone F)
{R : Type u} [comm_ring R] (x y : R) (i : ‚Ñï) : {z // x ^ i - y ^ i = z * (x - y)}
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) (Œ¥ : Type u_4) [measurable_space Œ±] [measurable_space Œ≤] [measurable_space Œ≥] [measurable_space Œ¥] : (Œ± ‚äï Œ≤) √ó (Œ≥ ‚äï Œ¥) ‚âÉ·µê (Œ± √ó Œ≥ ‚äï Œ± √ó Œ¥) ‚äï Œ≤ √ó Œ≥ ‚äï Œ≤ √ó Œ¥
{Œ± : Type u_1} {Œ≤ : Type u_2} (e e' : local_equiv Œ± Œ≤) (h : e ‚âà e') (s : e.source = set.univ) (t : e.target = set.univ) : e = e'
{ùïú : Type u_3} {G : Type u_4} [is_R_or_C ùïú] [normed_group G] [normed_space ùïú G] {f : ùïú ‚Üí G} {C : nnreal} (hf : differentiable ùïú f) (bound : ‚àÄ (x : ùïú), ‚à•deriv f x‚à•‚Çä ‚â§ C) : lipschitz_with C f
{a‚ÇÅ : Sort ua‚ÇÅ} {a‚ÇÇ : Sort ua‚ÇÇ} {b‚ÇÅ : Sort ub‚ÇÅ} {b‚ÇÇ : Sort ub‚ÇÇ} [has_lift a‚ÇÇ a‚ÇÅ] [has_lift_t b‚ÇÅ b‚ÇÇ] : has_lift (a‚ÇÅ ‚Üí b‚ÇÅ) (a‚ÇÇ ‚Üí b‚ÇÇ)
 : vm bool
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [preorder Œ≤] {a : Œ±} {f : Œ± ‚Üí Œ≤} (h‚ÇÅ : strict_anti_on f (set.Iic a)) (h‚ÇÇ : strict_anti_on f (set.Ici a)) : strict_anti f
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] (F : C ‚•§ D) [F.preserves_zero_morphisms] : Type (max u u‚ÇÇ (v+1))
{R : Type u_1} {F : Type u_3} [add_comm_group F] [topological_space F] [topological_add_group F] [ring R] [module R F] [topological_space R] [has_continuous_smul R F] {p v : F} : continuous ‚áë(affine_map.line_map p v)
{Œ± : Type u_1} {s t : set Œ±} : s = t ‚Üí s ‚äÜ t
{Œ± : Type u_1} (q : semiquot Œ±) : trunc Œ±
{m : Type u ‚Üí Type u} [monad m] {Œ± : Type u} : tactic.mllist m Œ± ‚Üí m (list Œ±)
{m : Type u ‚Üí Type u} [monad m] {Œ± : Type u} : ‚Ñï ‚Üí tactic.mllist m Œ± ‚Üí tactic.mllist m (‚Ñï √ó Œ±)
(fs : list (option string)) : tactic (name_map declaration)
{M : Type u_3} {N : Type u_4} [has_mul M] [has_mul N] (f : M ‚Üí‚Çô* N) {x y : M} (h : x = y) : ‚áëf x = ‚áëf y
{Œ± : Type u_1} [fintype Œ±] [decidable_eq Œ±] : {f // f.is_cycle} ‚âÉ {s // s.nodup ‚àß s.nontrivial}
{ùïú : Type u_1} {E : Type u_2} [ordered_ring ùïú] [add_comm_group E] [module ùïú E] (K : geometry.simplicial_complex ùïú E) : set (finset E)
{m n : ‚Ñï} (cop : m.coprime n) (hm : 1 < m) (hn : 1 < n) : is_frobenius_number (m * n - m - n) {m, n}
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [has_mul Œ≤] : has_mul Œ±
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [comm_semiring k] [monoid G] {A : Type u‚ÇÉ} [semiring A] [algebra k A] {B : Type u_2} [semiring B] [algebra k B] (f : A ‚Üí‚Çê[k] B) (g : G ‚Üí* B) (h_comm : ‚àÄ (x : A) (y : G), commute (‚áëf x) (‚áëg y)) : monoid_algebra A G ‚Üí‚Çê[k] B
{Œ± : Type u_1} : ‚Ñï ‚Üí list Œ± ‚Üí list Œ± √ó list Œ±
{Œ≥ : Type w} [emetric_space Œ≥] {x y : Œ≥} : has_edist.edist x y = 0 ‚Üî x = y
 : seq ‚Ñï
{M : Type u_1} [mul_one_class M] {S T : submonoid M} (h : S ‚â§ T) : ‚Ü•S ‚Üí* ‚Ü•T
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_2} : (Œ£ (a : Œ±), Œ≤ a ‚Üí W_type Œ≤) ‚Üí W_type Œ≤
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] {R : Type u_1} [non_assoc_semiring R] {f : Œ† (k : ‚Ñï), R ‚Üí+* zmod (p ^ k)} (f_compat : ‚àÄ (k1 k2 : ‚Ñï) (hk : k1 ‚â§ k2), (zmod.cast_hom _ (zmod (p ^ k1))).comp (f k2) = f k1) (g : R ‚Üí+* ‚Ñ§_[p]) (hg : ‚àÄ (n : ‚Ñï), (padic_int.to_zmod_pow n).comp g = f n) : padic_int.lift f_compat = g
 : expr.coord ‚Üí expr ‚Üí option expr
{n : ‚Ñï} (P : mvpfunctor (n + 1)) : P.last.M ‚Üí fin2 n ‚Üí Type u
{Œ± : Type u_1} [decidable_eq Œ±] (s : multiset Œ±) : s - 0 = s
{V : Type (u+1)} [category_theory.large_category V] {G : Mon} : ùü≠ (Action V G) ‚âÖ Action.functor_category_equivalence.functor ‚ãô Action.functor_category_equivalence.inverse
 : omega.int.preform ‚Üí omega.int.preform
{p n : ‚Ñï} (hp : nat.prime p) (hdiv : ¬¨p ‚à£ n) (R : Type u_1) [comm_ring R] : ‚áë(polynomial.expand R p) (polynomial.cyclotomic n R) = polynomial.cyclotomic (n * p) R * polynomial.cyclotomic n R
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {Z : C} {h : Y ‚ü∂ Z} (t : category_theory.is_split_coequalizer f g h) : category_theory.limits.is_colimit t.as_cofork
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] {s : set E} : convex ùïú s ‚Üí ‚àÄ ‚¶Éa b : ùïú‚¶Ñ, 0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí a + b = 1 ‚Üí a ‚Ä¢ s + b ‚Ä¢ s ‚äÜ s
(R : Type u) [field R] : is_field R
(Œ≤ : Type v) (C : Type u_1) [category_theory.category C] : Prop
(B : Type u) [quiver B] : category_theory.prelax_functor (category_theory.locally_discrete (category_theory.paths B)) (category_theory.free_bicategory B)
(Œ± : Type u_2) [fintype Œ±] [nonempty Œ±] [semilattice_inf Œ±] : order_bot Œ±
(k : expr √ó ‚Ñö) : tactic.ring.horner_expr ‚Üí tactic.ring.ring_m (tactic.ring.horner_expr √ó expr)
{M : Type u_1} [comm_monoid M] (f : ‚Ñï ‚Üí ‚Ñï ‚Üí M) (n : ‚Ñï) : (finset.nat.antidiagonal n).prod (Œª (ij : ‚Ñï √ó ‚Ñï), f ij.fst ij.snd) = (finset.range n.succ).prod (Œª (k : ‚Ñï), f k (n - k))
{M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] (f : M ‚âÉ N) (h : ‚àÄ (x y : M), ‚áëf (x * y) = ‚áëf x * ‚áëf y) : M ‚âÉ* N
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u} [category_theory.category J] {X : J} (hX : category_theory.limits.is_initial X) (F : J ‚•§ C) [‚àÄ (i j : J) (f : i ‚ü∂ j), category_theory.is_iso (F.map f)] : category_theory.limits.is_colimit (category_theory.limits.cocone_of_diagram_initial hX F)
{M : Type u_1} [has_add M] (c : add_con M) {x y : M} : ‚áëc x y ‚Üí ‚áëc y x
{Œπ : Type u‚ÇÅ} {k : Type u‚ÇÇ} {V : Type u‚ÇÉ} [add_comm_group V] [ring k] [module k V] [fintype Œπ] (b : affine_basis Œπ k V) (v : V) : finset.univ.sum (Œª (i : Œπ), ‚áë(b.coord i) v ‚Ä¢ b.points i) = v
{Œ± Œ≤ : SemilatticeSup} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} {f g : C ‚ü∂ D} [category_theory.limits.has_equalizers V] [category_theory.limits.has_cokernels V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] [category_theory.limits.has_zero_object V] (h : homotopy f g) (i : Œπ) : (homology_functor V c i).map f = (homology_functor V c i).map g
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (s : multiset (sigma Œ≤)) : multiset Œ±
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (hu : monotone u) (hl : monotone l) (hlu : ‚àÄ (b : Œ≤), l (u b) ‚â§ b) (hul : ‚àÄ (a : Œ±), u (l a) = a) : galois_coinsertion l u
{Œ± : Type u_1} {Œπ : Type u} (r : Œπ ‚Üí Œπ ‚Üí Prop) [is_well_order Œπ r] {o : ordinal} (ho : ordinal.type r = o) (f : Œ† (a : ordinal), a < o ‚Üí Œ±) : Œπ ‚Üí Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.regular_mono_category C] (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.regular_mono f
(M' : Type u_1) {X : Type u_2} [has_scalar M' X] : X ‚Üí[M'] X
(c : tactic.instance_cache) (ex ey : expr) : tactic (tactic.instance_cache √ó expr √ó expr)
(Œ± : Type u_1) (Œ≤ : Type u_2) [has_mul Œ≤] : Œ≤ ‚Üí‚Çô* Œ± ‚Üí Œ≤
{Œπ : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [ordered_add_comm_monoid N] (f : M ‚Üí N) (h_one : f 0 = 0) (h_mul : ‚àÄ (x y : M), f (x + y) ‚â§ f x + f y) (s : finset Œπ) (g : Œπ ‚Üí M) : f (s.sum (Œª (i : Œπ), g i)) ‚â§ s.sum (Œª (i : Œπ), f (g i))
{R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (p : submodule R A) (h_one : 1 ‚àà p) (h_mul : ‚àÄ (x y : A), x ‚àà p ‚Üí y ‚àà p ‚Üí x * y ‚àà p) : subalgebra R A
{n : ‚Ñï} {Œ± : typevec (n + 1)} {Œ≤ : typevec (n + 1)} (f : Œ±.arrow Œ≤) : Œ±.drop.arrow Œ≤.drop
{ùïú : Type u_2} {E : Type u_5} {F : Type u_6} [topological_space ùïú] [comm_semiring ùïú] [add_comm_monoid E] [module ùïú E] [add_comm_monoid F] [module ùïú F] (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú) [has_continuous_add ùïú] : has_continuous_add (weak_bilin B)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) : setoid (AddCommGroup.colimits.prequotient F)
{Œ± : Type u_1} {Œ≤ : Type u_2} (q : semiquot Œ±) (f : Œ± ‚Üí Œ≤) (h : ‚àÄ (a : Œ±), a ‚àà q ‚Üí ‚àÄ (b : Œ±), b ‚àà q ‚Üí f a = f b) : Œ≤
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {E' : Type u_7} [inner_product_space ùïú E'] (f : E ‚âÉ‚Çó·µ¢[ùïú] E') (x y : E) : has_inner.inner (‚áëf x) (‚áëf y) = has_inner.inner x y
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] (f : Œ± ‚Üí Œ≤) [fintype Œ≤] [decidable_pred (Œª (y : Œ≤), y ‚àà set.range f)] [decidable_eq Œ≤] : finset.filter (Œª (y : Œ≤), y ‚àà set.range f) finset.univ = finset.image f finset.univ
{Œ± : Type u_1} [linear_order Œ±] (s : finset Œ±) (H : s.nonempty) : Œ±
{K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] {x : S} (B : power_basis K S) (hint : is_integral K x) (hx : B.gen ‚àà algebra.adjoin K {x}) : power_basis K S
(m : ‚Ñï) (p : omega.nat.preform) : tactic expr
{ùíú : Type u_1} [category_theory.category ùíú] {A B C : ùíú} {f : A ‚ü∂ B} {g : B ‚ü∂ C} [category_theory.limits.has_zero_morphisms ùíú] [category_theory.limits.has_binary_biproducts ùíú] (h : category_theory.splitting f g) : C ‚ü∂ B
{G : Type u_1} [group G] [is_free_group G] {H : Type u_2} [group H] : (is_free_group.generators G ‚Üí H) ‚âÉ (G ‚Üí* H)
{Œπ : Type u} {f : Œπ ‚Üí ordinal ‚Üí ordinal} (H : ‚àÄ (i : Œπ), ordinal.is_normal (f i)) : set.unbounded has_lt.lt (‚ãÇ (i : Œπ), function.fixed_points (f i))
{Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : ‚Ñù
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_pullbacks C] {A : C} : category_theory.subobject A ‚•§ category_theory.subobject A ‚•§ category_theory.subobject A
{M : Type u} [monoid M] {N : Type u} [monoid N] {K : Type u} [monoid K] (F : M ‚Üí* N) (G : N ‚Üí* K) : category_theory.discrete.monoidal_functor F ‚äó‚ãô category_theory.discrete.monoidal_functor G ‚âÖ category_theory.discrete.monoidal_functor (G.comp F)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (C : homological_complex V c) [category_theory.limits.has_zero_object V] {i j : Œπ} (r : c.rel i j) : C.X_prev j ‚âÖ C.X i
(A : Type) [metric_space A] : Type 1
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) : A‚Åª¬π = ring.inverse A
{K : Type u} {V V‚ÇÅ : Type v} [field K] [add_comm_group V] [module K V] [add_comm_group V‚ÇÅ] [module K V‚ÇÅ] (f : V ‚Üí‚Çó[K] V‚ÇÅ) : module.rank K ‚Ü•(f.range) + module.rank K ‚Ü•(f.ker) = module.rank K V
{X : Type u_2} [emetric_space X] {s : set X} (hs : s.countable) : dimH s = 0
{Œ± : Type u} [topological_space Œ±] (a : Œ±) (s : set Œ±) : filter Œ±
{Œ± : Type u_1} {Œ≤ : Type u_4} [preorder Œ±] [preorder Œ≤] {u : Œ≤ ‚Üí Œ±} (l : lower_adjoint u) (x : Œ±) : x ‚â§ u (‚áël x)
{Œ± : Type u} [inhabited Œ±] (as1 as2 : list Œ±) : Prop
 : quaternion_group 0 ‚âÉ* dihedral_group 0
{Œ± : Type u_1} {Œ≤ : Type u_4} [preorder Œ±] [preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : galois_connection l u) : lower_adjoint u
(s1 s2 : linarith.sum) : linarith.sum
{Œ± : Type u} (s : stream Œ±) : stream (stream Œ±)
{M‚ÇÄ : Type u_1} [monoid_with_zero M‚ÇÄ] (x : M‚ÇÄ) (h : ¬¨is_unit x) : ring.inverse x = 0
{et : tactic.ring_exp.ex_type} (ps : tactic.ring_exp.ex et) : tactic.ring_exp.ex_info
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [comm_monoid N] (f : Œ± ‚Üí‚ÇÄ M) (y : Œ±) (g : Œ± ‚Üí M ‚Üí N) (hyf : y ‚àà f.support) : g y (‚áëf y) * (finsupp.erase y f).prod g = f.prod g
(x y z : pgame) : ((x + y) * z).equiv (x * z + y * z)
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [has_zero M‚ÇÅ] [has_scalar ‚Ñï M‚ÇÅ] [add_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : add_monoid M‚ÇÅ
{Œ± : Type u} [has_subset Œ±] [has_ssubset Œ±] [is_nonstrict_strict_order Œ± has_subset.subset has_ssubset.ssubset] {a b : Œ±} (h : a ‚äÜ b) : ¬¨b ‚äÇ a
{ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_3} [ordered_semiring ùïú] [add_comm_group E] [module ùïú E] [subsingleton Œπ] (p : Œπ ‚Üí E) : convex_independent ùïú p
{Œ± : Sort u_1} (hh : Œ±) {Œ≤ : Prop} (x : tactic.calculated_Prop Œ≤ hh . "derive_reassoc_proof") : Œ≤
{Œ± : Type u} (s : seq Œ±) : option Œ±
{F : Type u_1} [normed_group F] [normed_space ‚Ñù F] (f : ‚Ñù ‚Üí F) [complete_space F] : measurable_set {x : ‚Ñù | differentiable_within_at ‚Ñù f (set.Ici x) x}
(m M N : ‚Ñï) : finset (Œ£ (n : ‚Ñï), fin n ‚Üí ‚Ñï)
{Œ± : Type u} {Œ≤ : Type u_1} (t‚ÇÅ : ordnode Œ±) (t‚ÇÇ : ordnode Œ≤) : ordnode (Œ± √ó Œ≤)
(R : Type u_1) [comm_ring R] {A : Type u} [topological_space A] [ring A] [algebra R A] [topological_ring A] (x : A) : subalgebra R A
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) (P : Type u_6) (Q : Type u_7) [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [add_comm_monoid Q] [module R M] [module R N] [module R P] [module R Q] : tensor_product R (tensor_product R M N) (tensor_product R P Q) ‚âÉ‚Çó[R] tensor_product R (tensor_product R M (tensor_product R N P)) Q
{Œ± : Type u} (s : set Œ±) : Prop
{Œ± : Type u_1} {M : Type u_5} {G : Type u_9} [monoid G] [mul_action G Œ±] [add_comm_monoid M] : distrib_mul_action G (Œ± ‚Üí‚ÇÄ M)
{X Y Z : Top} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : category_theory.limits.is_limit (Top.pullback_cone f g)
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] [category_theory.monoidal_category C] (F : J ‚•§ Mon_ C) : Mon_ C
{Œ± : Type u} {Œ≤ : Type u_1} (t‚ÇÅ : ordnode Œ±) (t‚ÇÇ : ordnode Œ≤) : ordnode (Œ± ‚äï Œ≤)
(M : Type u_1) (Œ± : Type u_2) [group M] [mul_action M Œ±] {P Q : subgroup M} : mul_action.fixed_points ‚Ü•(P ‚äî Q) Œ± = mul_action.fixed_points ‚Ü•P Œ± ‚à© mul_action.fixed_points ‚Ü•Q Œ±
{ùïú : Type u_1} {E : Type u_2} [ordered_ring ùïú] [add_comm_group E] [module ùïú E] : has_mem (finset E) (geometry.simplicial_complex ùïú E)
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [‚àÄ (i : ùí∞.J), category_theory.limits.has_pullback (ùí∞.map i ‚â´ f) g] (i : ùí∞.J) : category_theory.limits.pullback (algebraic_geometry.Scheme.pullback.p1 ùí∞ f g) (ùí∞.map i) ‚âÖ category_theory.limits.pullback (ùí∞.map i ‚â´ f) g
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (e : local_homeomorph Œ± Œ≤) (e' : Œ≤ ‚âÉ‚Çú Œ≥) : local_homeomorph Œ± Œ≥
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] {N : lie_submodule R L M} : M ‚Üí M ‚ß∏ N
{M : Type u_1} [mul_one_class M] {p : M ‚Üí Prop} (x : M) {s : set M} (hs : submonoid.closure s = ‚ä§) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí p x) (H1 : p 1) (Hmul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x * y)) : p x
(R : Type u_2) [comm_ring R] : Type u_2
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} : list (sigma Œ≤) ‚Üí list Œ±
{S : Type u} [pgame.state S] (n : ‚Ñï) {s : S} (h : pgame.state.turn_bound s ‚â§ n) (t : (pgame.of_aux n s h).left_moves) : ((pgame.of_aux n s h).move_left t).relabelling (pgame.of_aux (n - 1) ‚Üë(‚áë(pgame.left_moves_of_aux n h) t) _)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : ùü≠ C ‚ü∂ e.functor ‚ãô e.inverse
 : tactic.eliminate.constructor_argument_naming_rule
{Œ± : Type u_2} [monoid Œ±] (m : Œ±) : (‚àÉ (c : Œ±), m = c ^ 2) ‚Üí is_square m
{R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] {P : Type u_3} [comm_ring P] [is_localization M S] (Q : Type u_5) [comm_ring Q] {g : R ‚Üí+* P} [algebra P Q] (hg : function.injective ‚áëg) [is_localization (submonoid.map ‚Üëg M) Q] (hM : submonoid.map ‚Üëg M ‚â§ non_zero_divisors P) : function.injective ‚áë(is_localization.map Q g _)
{Œ± : Type u_1} (t : tactic_result Œ±) : tactic Œ±
{C : Type u} [category_theory.category C] (F : C·µí·µñ ‚•§ Type v) : (F.elements)·µí·µñ ‚•§ category_theory.costructured_arrow category_theory.yoneda F
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} {N : Type u_7} [add_comm_monoid M] [add_comm_monoid N] (f : Œ± ‚Üí Œ≤) (v : Œ± ‚Üí‚ÇÄ M) (g : M ‚Üí N) (h0 : g 0 = 0) (hadd : ‚àÄ (x y : M), g (x + y) = g x + g y) : finsupp.map_domain f (finsupp.map_range g h0 v) = finsupp.map_range g h0 (finsupp.map_domain f v)
{Œ± : Type u} [uniform_space Œ±] (s : set Œ±) : Prop
(b : pgame.domineering.board) (m : ‚Ñ§ √ó ‚Ñ§) : pgame.domineering.board
(Œ± : Type u_1) (Œ≤ : Type u_2) [topological_space Œ±] [topological_space Œ≤] : Œ± √ó Œ≤ ‚âÉ‚Çú Œ≤ √ó Œ±
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ‚Ñ§] : ùü≠ (category_theory.differential_object C) ‚âÖ category_theory.differential_object.shift_functor C 0
{Œ± : Sort u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (q : quot r) : Œ±
(C : Type u) [category_theory.category C] : Prop
(Œ± : Type u) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : e.functor ‚ãô e.inverse ‚ü∂ ùü≠ C
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J ‚Üí C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f
(X : algebraic_geometry.LocallyRingedSpace) (r : ‚Ü•(algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X))) : (algebraic_geometry.Spec.structure_sheaf ‚Ü•(algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X))).val.obj (opposite.op (prime_spectrum.basic_open r)) ‚ü∂ X.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op (X.to_Œì_Spec_map_basic_open r))
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop} (f : principal_seg r s) (g : s ‚âÉr t) : principal_seg r t
{Œ± : Type u_1} [decidable_eq Œ±] {Œ¥ : Œ± ‚Üí Type u_2} (m : multiset Œ±) (a : Œ±) (b : Œ¥ a) (f : Œ† (a : Œ±), a ‚àà m ‚Üí Œ¥ a) (a' : Œ±) (H : a' ‚àà a ::‚Çò m) : Œ¥ a'
(h : interactive.parse (optional lean.parser.ident)) (_x : interactive.parse (lean.parser.tk ":")) (p : interactive.parse generalize_arg_p) (l : interactive.parse interactive.types.location) : tactic unit
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] [fintype Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) {w : Œ± ‚Üí M} {b : M} [linear_ordered_cancel_add_comm_monoid M] [nonempty Œ≤] (hb : fintype.card Œ≤ ‚Ä¢ b ‚â§ finset.univ.sum (Œª (x : Œ±), w x)) : ‚àÉ (y : Œ≤), b ‚â§ (finset.filter (Œª (x : Œ±), f x = y) finset.univ).sum (Œª (x : Œ±), w x)
{Œ± : Type u_1} [conditionally_complete_linear_order Œ±] {a : Œ±} (h : has_Sup.Sup ‚àÖ ‚â§ a) : conditionally_complete_linear_order_bot {x // a ‚â§ x}
{Œ± : Type u_1} {n : ‚Ñï} (a : Œ±) (v : vector3 Œ± n) : vector3 Œ± n.succ
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (p‚ÇÅ p‚ÇÇ : P) : euclidean_geometry.cospherical {p‚ÇÅ, p‚ÇÇ}
 : golden_conj‚Åª¬π = -golden_ratio
 : Type
{M : Type u_1} [mul_one_class M] {A : Type u_4} [set_like A M] [hA : submonoid_class A M] (S' : A) : ‚Ü•S' ‚Üí* M
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí. Œ≤) {p : set Œ±} (H : p ‚äÜ f.dom) : Œ± ‚Üí. Œ≤
(F : Type u_8) (Œ± : out_param (Type u_9)) (Œ≤ : out_param (Type u_10)) [has_Sup Œ±] [has_Sup Œ≤] : Type (max u_10 u_8 u_9)
{Œ± : Type u} [topological_space Œ±] (a : Œ±) : (nhds a).has_basis (Œª (s : set Œ±), s ‚àà nhds a ‚àß is_open s) (Œª (x : set Œ±), x)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y Z : C} {f g : X ‚ü∂ Y} {h : Y ‚ü∂ Z} (w : f ‚â´ h = g ‚â´ h) : category_theory.limits.is_colimit (G.map_cocone (category_theory.limits.cofork.of_œÄ h w)) ‚âÉ category_theory.limits.is_colimit (category_theory.limits.cofork.of_œÄ (G.map h) _)
{X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] (s : set X) : dimH s = ‚®Ü (d : nnreal) (hd : ‚áë(measure_theory.measure.hausdorff_measure ‚Üëd) s = ‚ä§), ‚Üëd
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] (F : C ‚•§ D) : category_theory.with_terminal C ‚•§ category_theory.with_terminal D
(R : Type u_1) {S : Type u_6} {M : Type u_9} {M‚ÇÇ : Type u_11} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] [module S M] [module S M‚ÇÇ] [linear_map.compatible_smul M M‚ÇÇ R S] (f‚Çó : M ‚Üí‚Çó[S] M‚ÇÇ) : M ‚Üí‚Çó[R] M‚ÇÇ
{n : ‚Ñï} {Œ± : typevec n} (p : Œ±.arrow (typevec.repeat n Prop)) : (typevec.subtype_ p).arrow (Œª (i : fin2 n), {x // typevec.of_repeat (p i x)})
{A B : Type u} [comm_group A] [comm_group B] (f : A ‚Üí* B) (n : ‚Ñ§) : A ‚ß∏ (zpow_group_hom n).range ‚Üí* B ‚ß∏ (zpow_group_hom n).range
{M : Type u_1} [add_monoid M] {s t : set M} (ht : is_add_submonoid t) (h : s ‚äÜ t) : add_monoid.closure s ‚äÜ t
(c : tactic.instance_cache) : expr ‚Üí tactic (tactic.instance_cache √ó expr)
(X Y : Top) : category_theory.limits.binary_fan X Y
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {G : C ‚•§ D} {K : category_theory.grothendieck_topology D} [category_theory.full G] [category_theory.faithful G] (Hld : category_theory.locally_cover_dense K G) : category_theory.cover_lifting Hld.induced_topology K G
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : r ‚Ü™r s) : r ‚Üír s
{R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] [finite_dimensional R M] (x‚ÇÅ x‚ÇÇ : orientation R M Œπ) (h : fintype.card Œπ = finite_dimensional.finrank R M) : x‚ÇÅ = x‚ÇÇ ‚à® x‚ÇÅ = -x‚ÇÇ
{Œ± : Type} (t : tactic Œ±) : smt_tactic Œ±
{Œ± : Type u} [topological_space Œ±] [sigma_compact_space Œ±] {Œπ : Type u_1} {f : Œπ ‚Üí set Œ±} (hf : locally_finite f) (hne : ‚àÄ (i : Œπ), (f i).nonempty) : encodable Œπ
{Œ± : Type u_1} {Œ≤ : Type u_2} {s : set Œ±} {t : Œ± ‚Üí set Œ≤} {x : Œ±} (xs : x ‚àà s) : (‚ãÇ (x : Œ±) (H : x ‚àà s), t x) ‚äÜ t x
(_x : interactive.parse (lean.parser.tk "localized")) : lean.parser unit
{Œ± : Type u} [topological_space Œ±] (a : Œ±) : filter Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [‚Ñ∞ : category_theory.category E] (F : C ‚•§ D) (G : D ‚•§ E) [category_theory.limits.preserves_colimits_of_size (F ‚ãô G)] [category_theory.limits.reflects_colimits_of_size G] : category_theory.limits.preserves_colimits_of_size F
(Œ± : Type u) [has_one Œ±] [has_mul Œ±] : category_theory.category_struct (category_theory.single_obj Œ±)
(c : tactic.instance_cache) (ex ey : expr) : tactic (tactic.instance_cache √ó (expr ‚äï expr))
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí ordnode Œ±
{Œ± : Type u_1} {s t : set Œ±} : (s ‚à© t).nonempty ‚Üí ¬¨disjoint s t
(g : expr) : tactic tactic.packaged_goal
(ic : tactic.instance_cache) : expr ‚Üí tactic (tactic.instance_cache √ó ‚Ñï √ó expr √ó expr)
 : num ‚Üí znum
{ùïú : Type u} {Œπ : Type v} {G : Type wG} {G' : Type wG'} [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] : normed_group (continuous_multilinear_map ùïú (Œª (i : Œπ), G) G')
 : list expr ‚Üí expr ‚Üí expr √ó list expr
{R : Type u_1} {S : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [semiring S] (f : R ‚Üí+* S) (s : submonoid S) (a : R) (ha : a ‚â† 0) (h : ‚àÄ (b : R), b ‚àà principal_ideal_ring.factors a ‚Üí ‚áëf b ‚àà s) (hf : ‚àÄ (c : RÀ£), ‚áëf ‚Üëc ‚àà s) : ‚áëf a ‚àà s
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {ùïú : Type u_3} {G : Type u_4} [is_R_or_C ùïú] [normed_space ùïú E] [normed_group G] [normed_space ùïú G] {s : set E} {x : E} {f' : E ‚Üí (E ‚ÜíL[ùïú] G)} (hs : convex ‚Ñù s) {f : E ‚Üí G} (hder : ‚àÄ·∂† (y : E) in nhds_within x s, has_fderiv_within_at f (f' y) s y) (hcont : continuous_within_at f' s x) (K : nnreal) (hK : ‚à•f' x‚à•‚Çä < K) : ‚àÉ (t : set E) (H : t ‚àà nhds_within x s), lipschitz_on_with K f t
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] [complete_space E] {f : ‚Ñù ‚Üí E} {T : ‚Ñù} (hf : function.periodic f T) (n : ‚Ñ§) (t : ‚Ñù) (h_int : ‚àÄ (t‚ÇÅ t‚ÇÇ : ‚Ñù), interval_integrable f measure_theory.measure_space.volume t‚ÇÅ t‚ÇÇ) : ‚à´ (x : ‚Ñù) in t..t + n ‚Ä¢ T, f x = n ‚Ä¢ ‚à´ (x : ‚Ñù) in t..t + T, f x
{Œ± : Type u} [preorder Œ±] [no_min_order Œ±] (a : Œ±) : ‚àÉ (f : ‚Ñï ‚Üí Œ±), strict_anti f ‚àß f 0 = a
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_binary_biproduct X Y] : Y ‚ü∂ X ‚äû Y
 : widget.component tactic_state empty
{R : Type u} [semiring R] {Œπ : Type v} [dec_Œπ : decidable_eq Œπ] {M : Type u_1} [add_comm_monoid M] [module R M] {A : Œπ ‚Üí submodule R M} (h : direct_sum.is_internal A) {Œ± : Œπ ‚Üí Type u_2} (v : Œ† (i : Œπ), basis (Œ± i) R ‚Ü•(A i)) : basis (Œ£ (i : Œπ), Œ± i) R M
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a : Œ±} : 0 < -a ‚Üî a < 0
{Œ± : Type u_1} (p : two_pointing Œ±) : two_pointing Œ±
(C : Type u) (X : category_theory.free_monoidal_category C) : (category_theory.free_monoidal_category.tensor_func C).obj X ‚âÖ (category_theory.free_monoidal_category.normalize' C).obj X
{Œ± : Type u_1} (max : ‚Ñï) (tac : tactic Œ±) : tactic Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {f : V ‚âÉ‚Çó·µ¢[‚Ñù] V} (hd : 0 < ‚áëlinear_map.det ‚Üë(f.to_linear_equiv)) : ‚àÉ (Œ∏ : real.angle), f = hb.rotation Œ∏
{C : Type u‚ÇÅ} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A)
{Œ± : Type u_2} [has_add Œ±] : add_hom Œ± (set Œ±)
{Œ± : Type u_1} {Œπ : Type u_2} (m : measure_theory.outer_measure Œ±) {s : Œπ ‚Üí set Œ±} (l : filter Œπ) [l.ne_bot] (h0 : filter.tendsto (Œª (k : Œπ), ‚áëm ((‚ãÉ (n : Œπ), s n)  s k)) l (nhds 0)) : ‚áëm (‚ãÉ (n : Œπ), s n) = ‚®Ü (n : Œπ), ‚áëm (s n)
(Œ± : Type u) {Œ≤ : Type v} [monoid Œ±] [mul_action Œ± Œ≤] (b : Œ≤) : submonoid Œ±
{M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_3} [cancel_monoid_with_zero M‚ÇÄ] [has_zero M‚ÇÄ'] [has_mul M‚ÇÄ'] [has_one M‚ÇÄ'] [has_pow M‚ÇÄ' ‚Ñï] (f : M‚ÇÄ' ‚Üí M‚ÇÄ) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÄ'), f (x * y) = f x * f y) (npow : ‚àÄ (x : M‚ÇÄ') (n : ‚Ñï), f (x ^ n) = f x ^ n) : cancel_monoid_with_zero M‚ÇÄ'
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {X : C} (h : category_theory.yoneda.obj X ‚ãô category_theory.ulift_functor ‚âÖ F.cones) {Y : C} (f : Y ‚ü∂ X) : category_theory.limits.cone F
(Œ± : Type u_3) [topological_space Œ±] : Prop
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K
{M : Type u_1} [mul_one_class M] {Œπ : Sort u_2} (S : Œπ ‚Üí submonoid M) {C : Œ† (x : M), (x ‚àà ‚®Ü (i : Œπ), S i) ‚Üí Prop} (hp : ‚àÄ (i : Œπ) (x : M) (H : x ‚àà S i), C x _) (h1 : C 1 _) (hmul : ‚àÄ (x y : M) (hx : x ‚àà ‚®Ü (i : Œπ), S i) (hy : y ‚àà ‚®Ü (i : Œπ), S i), C x hx ‚Üí C y hy ‚Üí C (x * y) _) {x : M} (hx : x ‚àà ‚®Ü (i : Œπ), S i) : C x hx
{Œ± : Type u} [topological_space Œ±] (s : set Œ±) : set Œ±
{M : Type u_1} [monoid M] (s : submonoid M) {l : list M} (hl : ‚àÄ (x : M), x ‚àà l ‚Üí x ‚àà s) : l.prod ‚àà s
{Œ± : Type u_1} {s : finset Œ±} : s.nonempty ‚Üí ‚Üës.nonempty
(x y z : pgame) : (x * y * z).equiv (x * (y * z))
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {Œ¥ : out_param (Sort u_4)} [has_coe Œ± Œ≤] [has_coe_t_aux Œ≤ Œ≥] [has_coe_to_fun Œ≥ (Œª (_x : Œ≥), Œ¥)] (x : Œ±) : ‚áëx = ‚áë‚Üëx
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {R : C·µí·µñ ‚•§ Type v‚ÇÅ} (f : R ‚ü∂ category_theory.yoneda.obj X) : category_theory.sieve X
{Œπ : Type u_1} {Œ± : Type u_3} {Œ≤ : Type u_4} [preorder Œ±] [preorder Œ≤] (f : Œπ ‚Üí Œ±) (g : Œπ ‚Üí Œ≤) : Prop
 : option expr ‚Üí option expr ‚Üí tactic (option expr)
(J : Type u‚ÇÅ) [category_theory.category J] (C : Type u‚ÇÉ) [category_theory.category C] : (J ‚•§ C)·µí·µñ ‚•§ C ‚•§ Type (max u‚ÇÅ v‚ÇÉ)
(R : Type u) (M : Type v) (N : Type w) [comm_ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [add_comm_group N] [module R N] [module.free R N] [module.finite R N] : finite_dimensional.finrank R (M ‚Üí‚Çó[R] N) = finite_dimensional.finrank R M * finite_dimensional.finrank R N
{H : Type u} [topological_space H] (G : structure_groupoid H) : closed_under_restriction G ‚Üî id_restr_groupoid ‚â§ G
{R : Type u_1} {M : Type u_2} {R‚ÇÇ : Type u_3} {M‚ÇÇ : Type u_4} [ring R] [ring R‚ÇÇ] [add_comm_monoid M] [add_comm_group M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [ring_hom_surjective œÑ‚ÇÅ‚ÇÇ] {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ} (h : ‚àÄ (u v : M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] M‚ÇÇ ‚ß∏ f.range), u.comp f = v.comp f ‚Üí u = v) : f.range = ‚ä§
{M : Type u_1} [add_comm_group M] [module ‚ÑÇ M] [finite_dimensional ‚ÑÇ M] (Q‚ÇÅ Q‚ÇÇ : quadratic_form ‚ÑÇ M) (hQ‚ÇÅ : (‚áëquadratic_form.associated Q‚ÇÅ).nondegenerate) (hQ‚ÇÇ : (‚áëquadratic_form.associated Q‚ÇÇ).nondegenerate) : Q‚ÇÅ.equivalent Q‚ÇÇ
{Œ± : Type u_1} [preorder Œ±] {a b : Œ±} (h : a ‚â§ b) : bounded_order ‚Ü•(set.Icc a b)
(S : Type u') {R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [semiring S] [module S M] [module R M] [has_scalar S R] [is_scalar_tower S R M] (V : submodule R M) : submodule S M
{J : Type u} [category_theory.small_category J] (F : J ‚•§ Top) [category_theory.is_cofiltered J] [‚àÄ (j : J), nonempty ‚Ü•(F.obj j)] [‚àÄ (j : J), compact_space ‚Ü•(F.obj j)] [‚àÄ (j : J), t2_space ‚Ü•(F.obj j)] : nonempty ‚Ü•((Top.limit_cone F).X)
{Œ± : Type u_2} {Œ≤ : Type u_3} [add_comm_monoid Œ±] [add_cancel_comm_monoid Œ≤] {A : set Œ±} {m n : ‚Ñï} (h : m ‚â§ n) (f : A ‚Üí+[n] Œ≤) : A ‚Üí+[m] Œ≤
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Type (max u v)
{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a)) : is_add_right_regular b
(v : list ‚Ñï) : turing.partrec_to_TM2.cfg'
{G : Type u_1} [group G] [topological_space G] [topological_group G] (K‚ÇÄ : topological_space.positive_compacts G) (K : topological_space.compacts G) : ‚Ñù
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G : J ‚•§ C} (Œ± : F ‚âÖ G) (c : category_theory.limits.cone F) : category_theory.limits.is_limit ((category_theory.limits.cones.postcompose Œ±.hom).obj c) ‚âÉ category_theory.limits.is_limit c
(x y : ‚Ñù) [fact (x < y)] : smooth_manifold_with_corners (model_with_corners_euclidean_half_space 1) ‚Ü•(set.Icc x y)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] {s : set Œ±} {t : set Œ≤} (hs : dense s) (ht : dense t) : dense (s √óÀ¢ t)
 : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {Z X Y P : C} {f : Z ‚ü∂ X} {g : Z ‚ü∂ Y} {inl : X ‚ü∂ P} {inr : Y ‚ü∂ P} (h : category_theory.is_pushout f g inl inr) : category_theory.limits.pushout_cocone f g
(Œ± : Type u_3) [measurable_space Œ±] : Type u_3
{Œ± Œ≤ : ordinal} (h : Œ± < Œ≤) : principal_seg has_lt.lt has_lt.lt
{R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] {p : polynomial R} (hp : p.is_primitive) : irreducible p ‚Üî irreducible (polynomial.map (algebra_map R K) p)
{Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) (b : B) : continuous (bundle.total_space_mk b)
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} (hs : is_compact s) {e : ‚Ñù} (he : 0 < e) : ‚àÉ (t : set Œ±) (H : t ‚äÜ s), t.finite ‚àß s ‚äÜ ‚ãÉ (x : Œ±) (H : x ‚àà t), metric.ball x e
{R : Type u} [semigroup R] [star_semigroup R] : R ‚âÉ* R·µê·µí·µñ
{ùïú : Type u_2} {E : Type u_5} {F : Type u_6} [topological_space ùïú] [comm_ring ùïú] [add_comm_group E] [module ùïú E] [add_comm_group F] [module ùïú F] (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú) [has_continuous_add ùïú] : topological_add_group (weak_bilin B)
{Œ± : Type} [has_sizeof Œ±] [decidable_eq Œ±] : slim_check.shrink_fn (slim_check.injective_function Œ±)
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] (M : submodule R A) {C : A ‚Üí Prop} (hr : ‚àÄ (r : R), C (‚áë(algebra_map R A) r)) (hadd : ‚àÄ (x y : A), C x ‚Üí C y ‚Üí C (x + y)) (hmul : ‚àÄ (x : A), C x ‚Üí ‚àÄ (m : A), m ‚àà M ‚Üí C (x * m)) {x : A} {n : ‚Ñï} (hx : x ‚àà M ^ n) : C x
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (S : C ‚•§ D) (T : D) : category_theory.costructured_arrow S T ‚•§ C
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] [category_theory.limits.has_limits C] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.reflects_isomorphisms (category_theory.forget C)] {F G : Top.sheaf C X} (f : F ‚ü∂ G) (U : topological_space.opens ‚Ü•X) (hinj : ‚àÄ (x : ‚Ü•U), function.injective ‚áë((Top.presheaf.stalk_functor C x.val).map f)) (hsurj : ‚àÄ (t : ‚Ü•(G.val.obj (opposite.op U))) (x : ‚Ü•U), ‚àÉ (V : topological_space.opens ‚Ü•X) (m : x.val ‚àà V) (iVU : V ‚ü∂ U) (s : ‚Ü•(F.val.obj (opposite.op V))), ‚áë(f.app (opposite.op V)) s = ‚áë(G.val.map iVU.op) t) : function.surjective ‚áë(f.app (opposite.op U))
 : ‚Ñö ‚Üí ‚Ñö ‚Üí ‚Ñö
(R : Type u_1) [comm_ring R] : Type u_1
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
 : category_theory.limits.is_initial (CommRing.of ‚Ñ§)
{R : Type u_1} [comm_semiring R] {X : Type u_2} {A : Type u_3} [semiring A] [algebra R A] {f g : free_algebra R X ‚Üí‚Çê[R] A} (w : ‚áëf ‚àò free_algebra.Œπ R = ‚áëg ‚àò free_algebra.Œπ R) : f = g
{G : Type u_1} {A : Type u_2} {B : Type u_3} [group G] [mul_action G A] : mul_action G (A ‚Üí B)
(Œ± : Type u) [preorder Œ±] [nonempty Œ±] [no_min_order Œ±] [no_max_order Œ±] : ‚àÉ (f : ‚Ñ§ ‚Üí Œ±), strict_mono f
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} : function.commute ‚áëclifford_algebra.reverse ‚áëclifford_algebra.involute
{t t' : Type u ‚Üí Type u} (eqv : Œ† (Œ± : Type u), t Œ± ‚âÉ t' Œ±) [traversable t] : traversable t'
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) : list (Œ£ (a : Œ±), Œ≤ a) ‚Üí option (Œ≤ a)
{key : Type} [has_lt key] [decidable_rel has_lt.lt] : list key ‚Üí native.rb_set key
{X : Type u_1} {Y : Type u_2} [normed_group X] [normed_group Y] [normed_space ‚Ñù X] [normed_space ‚Ñù Y] (f : X ‚Üí Y) (x : X) : Prop
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_4} [decidable_eq Œπ] [fintype Œπ] (e : basis Œπ R M) {w : Œπ ‚Üí R} (hw : ‚àÄ (i : Œπ), is_unit (w i)) : ‚áë(e.det) ‚áë(e.is_unit_smul hw) = finset.univ.prod (Œª (i : Œπ), w i)
{ùïú : Type u_1} {V : Type u_2} {V‚ÇÇ : Type u_4} [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] (f : V ‚Üí‚Çó·µ¢[ùïú] V‚ÇÇ) : V ‚Üí·µÉ‚Å±[ùïú] V‚ÇÇ
(f : stieltjes_function) : measure_theory.outer_measure ‚Ñù
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] : ordnode Œ± ‚Üí ordnode Œ± ‚Üí ordnode Œ±
{Œ± : Type u} {Œ≤ : Type v} [non_unital_comm_ring Œ±] [has_zero Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ≤), f (-x) = -f x) (sub : ‚àÄ (x y : Œ≤), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_unital_comm_ring Œ≤
(nondep : bool) (h : expr) (data spec : name) : tactic (expr √ó option (option expr))
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] : Mon_ C
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [‚àÄ (i : ùí∞.J), category_theory.limits.has_pullback (ùí∞.map i ‚â´ f) g] : (algebraic_geometry.Scheme.pullback.gluing ùí∞ f g).glued ‚ü∂ X
{Œ± : Type u_1} {Œ≤ : Type u_2} [group Œ±] [division_monoid Œ≤] (f : Œ± ‚Üí* Œ≤) (g h : Œ±) : ‚áëf (g / h) = ‚áëf g / ‚áëf h
 : expr ‚Üí name_set ‚Üí bool
{Œ± : Type u_1} {Œ≤ : Type u_2} [tŒ± : topological_space Œ±] [tŒ≤ : topological_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u_1} {Œπ : Type u_2} {Œπ' : Type u_3} (l : combinatorics.line Œ± Œπ) (l' : combinatorics.line Œ± Œπ') : combinatorics.line Œ± (Œπ ‚äï Œπ')
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) : nonempty Œ± ‚Üí nonempty Œ≤
 : name ‚Üí expr ‚Üí expr ‚Üí tactic unit
{R : Type u_1} [comm_ring R] {A : Type u} [topological_space A] [ring A] [algebra R A] [topological_ring A] [t2_space A] (s : subalgebra R A) (hs : ‚àÄ (x y : ‚Ü•s), x * y = y * x) : comm_ring ‚Ü•(s.topological_closure)
(C : Type u) [category_theory.category C] : Prop
{H : Type u} [topological_space H] : closed_under_restriction id_restr_groupoid
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space F] (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ‚ä§) (hker : f'.ker.closed_complemented) : local_homeomorph E (F √ó ‚Ü•(f'.ker))
{Œ± : Type u} (i : ‚Ñï) (t : ordnode Œ±) : ordnode Œ± √ó ordnode Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {J' : Type u‚ÇÇ} [category_theory.category J'] (e : J ‚âå J') [category_theory.limits.has_colimits_of_shape J C] : category_theory.limits.has_colimits_of_shape J' C
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [semiring k] [mul_one_class G] : k ‚Üí+* monoid_algebra k G
{Œ± : Type u_1} [semigroup Œ±] [partial_order Œ±] [contravariant_class Œ± Œ± has_mul.mul has_le.le] : left_cancel_semigroup Œ±
(e : expr) : tactic (list (name √ó expr))
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f g : X ‚ü∂ Y} [category_theory.limits.has_kernel f] [category_theory.limits.has_kernel g] (h : f = g) : category_theory.limits.kernel f ‚âÖ category_theory.limits.kernel g
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) : list (sigma Œ≤) ‚Üí list (Œ≤ a)
{V : Type u} (G : simple_graph V) [decidable_eq V] {v : V} {e : sym2 V} (h : e ‚àà G.incidence_set v) : V
{Œ± : Sort u_1} {Œ≤ : Sort u_2} [sa : setoid Œ±] [sb : setoid Œ≤] (f : Œ± ‚Üí Œ≤ ‚Üí Prop) (h : ‚àÄ (a‚ÇÅ : Œ±) (b‚ÇÅ : Œ≤) (a‚ÇÇ : Œ±) (b‚ÇÇ : Œ≤), a‚ÇÅ ‚âà a‚ÇÇ ‚Üí b‚ÇÅ ‚âà b‚ÇÇ ‚Üí f a‚ÇÅ b‚ÇÅ = f a‚ÇÇ b‚ÇÇ) [hf : Œ† (a : Œ±), decidable_pred (f a)] (q‚ÇÅ : quotient sa) : decidable_pred (quotient.lift‚ÇÇ f h q‚ÇÅ)
(ùïú : Type u_1) {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] (A : set E) : set E
{c : ‚Ñù} (h1 : 0 < c) (h2 : c < 1 / 2) {n : ‚Ñï} {f g : ‚Ñï ‚Üí bool} (hn : ‚àÄ (k : ‚Ñï), k < n ‚Üí f k = g k) (fn : f n = bool.ff) (gn : g n = bool.tt) : cardinal.cantor_function c f < cardinal.cantor_function c g
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (s : multiset (sigma Œ≤)) : Prop
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] (f : filter Œ±) : Œ±
{X Y : algebraic_geometry.LocallyRingedSpace} (f g : X ‚ü∂ Y) : category_theory.limits.cofork f g
{F : Type u_1} [normed_group F] [normed_space ‚Ñù F] {f : ‚Ñù ‚Üí F} {K : set F} (hK : is_complete K) : right_deriv_measurable_aux.D f K ‚äÜ {x : ‚Ñù | differentiable_within_at ‚Ñù f (set.Ici x) x ‚àß deriv_within f (set.Ici x) x ‚àà K}
{b : ‚Ñï} {l : list ‚Ñï} (hb : 2 ‚â§ b) (hl : ‚àÄ (x : ‚Ñï), x ‚àà l ‚Üí x < b) : nat.of_digits b l < b ^ l.length
{Œ± : Type u_3} (G : simple_graph Œ±) [decidable_rel G.adj] : finset Œ± ‚Üí finset Œ± ‚Üí ‚Ñö
(C : Type u) [category_theory.category C] (D : Type u') [category_theory.category D] : (C ‚•§ D) ‚•§ category_theory.cosimplicial_object.augmented C ‚•§ category_theory.cosimplicial_object.augmented D
(opt : tactic.interactive.mono_cfg) (l r : list expr) : tactic (list expr √ó list expr √ó list expr √ó list expr)
{V : Type u} {G : simple_graph V} (H : G.subgraph) : Prop
(Œ± : expr) : list expr ‚Üí tactic (expr √ó expr)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C·µí·µñ) (F : C ‚•§ D·µí·µñ) [category_theory.limits.preserves_limit K.left_op F] : category_theory.limits.preserves_colimit K F.left_op
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w‚ÇÅ} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] [Œ† (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)·µí·µñ (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] (G : Type (max v u) ‚•§ D) : category_theory.SheafOfTypes J ‚•§ category_theory.Sheaf J D
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ‚Ñù E] [normed_group F] [normed_space ‚Ñù F] {x : E} {f : E ‚Üí F} {f' : E ‚Üí (E ‚ÜíL[‚Ñù] F)} {f'' : E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] F} (hf : ‚àÄ·∂† (y : E) in nhds x, has_fderiv_at f (f' y) y) (hx : has_fderiv_at f' f'' x) (v w : E) : ‚áë(‚áëf'' v) w = ‚áë(‚áëf'' w) v
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (hS : S ‚â§ is_add_unit.add_submonoid M) : ‚Ü•(S.left_neg) ‚âÉ+ ‚Ü•S
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : M ‚Üí N) (H : ‚àÄ (x y : M), f (x + y) = f x + f y) (c : add_con N) : add_con M
{Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) : is_group_hom f
{C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ‚Ñï} {i j : fin (n + 2)} (H : i ‚â§ j) : X.Œ¥ i ‚â´ X.Œ¥ j.succ = X.Œ¥ j ‚â´ X.Œ¥ (‚áëfin.cast_succ i)
 : Type (u_1+1)
{R : Type u} [ring R] : has_inf (subring R)
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (G : D ‚•§ C) [‚àÄ (A : C), category_theory.limits.has_initial (category_theory.structured_arrow A G)] : category_theory.is_right_adjoint G
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} (f : Œ≤ ‚Üí Œ≥) : option (Œ± √ó Œ≤) ‚Üí option (Œ± √ó Œ≥)
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom A (A √ó B)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J ‚Üí C) [category_theory.limits.has_biproduct F] : category_theory.limits.is_limit (category_theory.limits.biproduct.bicone F).to_cone
(Œ± : Type u_1) [complete_lattice Œ±] : Prop
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_coproducts C] : category_theory.monad C
{Œ± : Type u_1} [unique Œ±] : encodable Œ±
{Œ± : Type} : widget.attr Œ± ‚Üí widget.html Œ± ‚Üí widget.html Œ±
(R : Type u_1) [has_mul R] [has_add R] : group (ring_aut R)
(z : ‚ÑÇ) : ‚ÑÇ
 : category_theory.limits.walking_pair ‚âÉ category_theory.limits.walking_pair
 : ‚Ñï
(vs : list expr) : tactic unit
{k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k ‚Üí E} {a b r : k} (h : 0 < r * (b - a)) : f (‚áë(affine_map.line_map a b) r) ‚â§ ‚áë(affine_map.line_map (f a) (f b)) r ‚Üî slope f a (‚áë(affine_map.line_map a b) r) ‚â§ slope f a b
{f : ‚Ñù ‚Üí ‚Ñù} (hf' : ‚àÄ (x : ‚Ñù), deriv f x < 0) : strict_anti f
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] {f : M ‚Üí‚Çô* N} (hf : function.surjective ‚áëf) : galois_insertion (subsemigroup.map f) (subsemigroup.comap f)
{Œ± : Type u_1} {E : Type u_2} {m m‚ÇÇ : measurable_space Œ±} [topological_space E] [has_zero E] {s : set Œ±} {f : Œ± ‚Üí E} (hs_m : measurable_set s) (hs : ‚àÄ (t : set Œ±), measurable_set (s ‚à© t) ‚Üí measurable_set (s ‚à© t)) (hf : measure_theory.strongly_measurable f) (hf_zero : ‚àÄ (x : Œ±), x ‚àâ s ‚Üí f x = 0) : measure_theory.strongly_measurable f
(Œ± : Type u_1) [preorder Œ±] : (antisymmetrization Œ± has_le.le)·µí·µà ‚âÉo antisymmetrization Œ±·µí·µà has_le.le
{f : ‚Ñù ‚Üí ‚Ñù} (hf' : ‚àÄ (x : ‚Ñù), 0 < deriv f x) : strict_mono f
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] (M : submodule R A) {C : A ‚Üí Prop} (hr : ‚àÄ (r : R), C (‚áë(algebra_map R A) r)) (hadd : ‚àÄ (x y : A), C x ‚Üí C y ‚Üí C (x + y)) (hmul : ‚àÄ (m : A), m ‚àà M ‚Üí ‚àÄ (x : A), C x ‚Üí C (m * x)) {x : A} {n : ‚Ñï} (hx : x ‚àà M ^ n) : C x
{G : Type u_1} [add_group G] (H : add_subgroup G) : add_subgroup G·µÉ·µí·µñ
{R : Type u} {S : Type v} [comm_ring R] [is_domain R] [comm_ring S] [is_domain S] [algebra R S] (g : polynomial R) (pb : power_basis R S) (h‚ÇÅ : ‚áë(polynomial.aeval (adjoin_root.root g)) (minpoly R pb.gen) = 0) (h‚ÇÇ : ‚áë(polynomial.aeval pb.gen) g = 0) : adjoin_root g ‚âÉ‚Çê[R] S
{Œ± : Type u} (l : list Œ±) : seq Œ±
(Œ± : Sort u) : Sort u
(new_lhs h : expr) : conv unit
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R ‚Üí+* S) : polynomial R ‚Üí+* polynomial S
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÇ] [has_zero M‚ÇÇ] [has_scalar ‚Ñï M‚ÇÇ] [has_neg M‚ÇÇ] [has_sub M‚ÇÇ] [has_scalar ‚Ñ§ M‚ÇÇ] [add_group M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (inv : ‚àÄ (x : M‚ÇÅ), f (-x) = -f x) (div : ‚àÄ (x y : M‚ÇÅ), f (x - y) = f x - f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : add_group M‚ÇÇ
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_comm_monoid M] {s : set Œ±} {t : set Œ≤} {f : Œ± ‚Üí M} {g : Œ≤ ‚Üí M} (e : Œ± ‚Üí Œ≤) (he‚ÇÄ : set.bij_on e s t) (he‚ÇÅ : ‚àÄ (x : Œ±), x ‚àà s ‚Üí f x = g (e x)) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)) = finsum (Œª (j : Œ≤), finsum (Œª (H : j ‚àà t), g j))
(Œ± : Type u_2) [preorder Œ±] [topological_space Œ±] : Type
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {F F' : C ‚•§ D} (h : F ‚âÖ F') : F.ess_image = F'.ess_image
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] (f : ‚ÑÇ ‚Üí E) (c : ‚ÑÇ) (R : ‚Ñù) : formal_multilinear_series ‚ÑÇ ‚ÑÇ E
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {s : set E} {t : set F} {g : F ‚Üí G} {f : E ‚Üí F} (x : E) (hg : cont_diff_within_at ùïú n g t (f x)) (hf : cont_diff_within_at ùïú n f s x) : cont_diff_within_at ùïú n (g ‚àò f) (s ‚à© f ‚Åª¬π' t) x
{Œ± : Type u_1} [pseudo_emetric_space Œ±] (r C : ennreal) {f : ‚Ñï ‚Üí Œ±} (hu : ‚àÄ (n : ‚Ñï), has_edist.edist (f n) (f (n + 1)) ‚â§ C * r ^ n) {a : Œ±} (ha : filter.tendsto f filter.at_top (nhds a)) : has_edist.edist (f 0) a ‚â§ C / (1 - r)
{m : Type u_2} {n : Type u_3} {o : Type u_4} {Œ± : Type u_12} [decidable_eq o] [has_zero Œ±] (M : o ‚Üí matrix m n Œ±) : matrix (m √ó o) (n √ó o) Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {T T' : D} {S : C ‚•§ D} (f : T ‚ü∂ T') : category_theory.costructured_arrow S T ‚•§ category_theory.costructured_arrow S T'
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {f g : X ‚ü∂ Y} (c : category_theory.limits.cokernel_cofork (f - g)) : category_theory.limits.cofork f g
(Œπ : Type u_1) (ùïú : Type u_3) [is_R_or_C ùïú] (E : Type u_4) [inner_product_space ùïú E] [fintype Œπ] : Type (max u_1 u_3 u_4)
(x : ‚Ñù) : ‚Ñù
(p : omega.int.preform) : (‚Ñï ‚Üí ‚Ñ§) ‚Üí ‚Ñï ‚Üí Prop
 : Type
{Œ± : Type u_5} {Œ≤ : Type u_6} [non_unital_non_assoc_semiring Œ±] [non_unital_non_assoc_semiring Œ≤] (self : Œ± ‚Üí‚Çô+* Œ≤) : Œ± ‚Üí‚Çô* Œ≤
{X : Type u_1} [topological_space X] {Œ± : Type u_2} (f : locally_constant X Œ±) : ‚Ü•(f.discrete_quotient) ‚Üí Œ±
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ : X} {p q : path x‚ÇÄ x‚ÇÅ} (F : p.homotopy q) : p.symm.homotopy q.symm
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] (F G : C ‚•§ D) : C ‚•§ D
{Œ± : Type} (p : parser Œ±) : parser (list Œ±)
{G : Type u} [group G] (B : group_filter_basis G) : topological_space G
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [add_comm_monoid Œ±] [topological_space Œ±] {f : Œ≤ ‚Üí Œ±} [add_comm_monoid Œ≥] [topological_space Œ≥] {G : Type u_4} [add_equiv_class G Œ± Œ≥] (g : G) (hg : continuous ‚áëg) (hg' : continuous (add_equiv_class.inv g)) : summable (‚áëg ‚àò f) ‚Üî summable f
{G : Type u} [add_group G] (a x : G) : add_semiconj_by a x (a + x + -a)
{G : Type u_1} [comm_group G] (H : subgroup G) : comm_group ‚Ü•H
{Œ≤ : Type u_2} [add_comm_monoid Œ≤] (f : fin 0 ‚Üí Œ≤) : finset.univ.sum (Œª (i : fin 0), f i) = 0
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {Y : Top} (‚Ñ± : Top.presheaf C Y) : Top.presheaf.pullback_obj (ùüô Y) ‚Ñ± ‚âÖ ‚Ñ±
{Œπ Œ± : Type v} (U : Œπ ‚Üí Œ±) [complete_lattice Œ±] : category_theory.limits.is_colimit (category_theory.pairwise.cocone U)
{S : Type u} [pgame.state S] (n : ‚Ñï) {s : S} (h : pgame.state.turn_bound s ‚â§ n) : (pgame.of_aux n s h).left_moves ‚âÉ {t // t ‚àà pgame.state.L s}
{F : Type u_1} [field F] (S : set F) : Prop
{C' : Type u_1} (X : C') : category_theory.shrink_homs C'
{R : Type u} [ring R] {Œ± : Type u_1} [mul_action R Œ±] (S : subring R) : mul_action ‚Ü•S Œ±
{C : Type u} [category_theory.category C] {X Y : C} (s : category_theory.limits.binary_fan X Y) : ((category_theory.functor.const (category_theory.discrete category_theory.limits.walking_pair)).obj s.X).obj {as := category_theory.limits.walking_pair.right} ‚ü∂ (category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right}
(M : Type u_1) [measurable_space M] [has_inf M] : Prop
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F G : J ‚•§ C} [category_theory.limits.has_colimit F] [category_theory.limits.has_colimit G] (Œ± : F ‚ü∂ G) : category_theory.limits.colimit F ‚ü∂ category_theory.limits.colimit G
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [locally_compact_space Œ≤] (f : C(Œ±, C(Œ≤, Œ≥))) : continuous (function.uncurry (Œª (x : Œ±) (y : Œ≤), ‚áë(‚áëf x) y))
(k : ‚Ñï) (R : Type u_1) [comm_ring R] [is_domain R] : finset R
{C : Type u} [category_theory.category C] {F G : category_theory.discrete category_theory.limits.walking_pair ‚•§ C} (f : F.obj {as := category_theory.limits.walking_pair.left} ‚âÖ G.obj {as := category_theory.limits.walking_pair.left}) (g : F.obj {as := category_theory.limits.walking_pair.right} ‚âÖ G.obj {as := category_theory.limits.walking_pair.right}) : F ‚âÖ G
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} (t : category_theory.limits.pushout_cocone f g) : Z ‚ü∂ t.X
{R : Type u_1} [rack R] {G : Type u_2} [group G] (f : shelf_hom R (quandle.conj G)) : rack.pre_envel_group R ‚Üí G
{Œπ : Type u_1} {E : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), metric_space (E i)] : metric_space (Œ£ (i : Œπ), E i)
{o : ordinal} (ho : 0 < o) : order_bot (quotient.out o).Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {s : category_theory.limits.cocone F} (e : K ‚âå J) : category_theory.limits.is_colimit s ‚âÉ category_theory.limits.is_colimit (category_theory.limits.cocone.whisker e.functor s)
(c : turing.to_partrec.code) (k : turing.partrec_to_TM2.cont') : turing.TM2.supports turing.partrec_to_TM2.tr (turing.partrec_to_TM2.code_supp c k)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (F : C ‚•§ D) (G : D ‚•§ E) [category_theory.limits.preserves_finite_limits F] [category_theory.limits.preserves_finite_limits G] : category_theory.limits.preserves_finite_limits (F ‚ãô G)
(L : first_order.language) : first_order.language
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {f : E √ó F ‚Üí G} (h : is_bounded_bilinear_map ùïú f) (p : E √ó F) : E √ó F ‚Üí‚Çó[ùïú] G
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (R : D ‚•§ C) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{Œ± : Type u_1} [has_lt Œ±] : has_le (finset.colex Œ±)
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Œ† (x : clifford_algebra Q), x ‚àà clifford_algebra.even_odd Q 0 ‚Üí Prop} (hr : ‚àÄ (r : R), P (‚áë(algebra_map R (clifford_algebra Q)) r) _) (hadd : ‚àÄ {x y : clifford_algebra Q} {hx : x ‚àà clifford_algebra.even_odd Q 0} {hy : y ‚àà clifford_algebra.even_odd Q 0}, P x hx ‚Üí P y hy ‚Üí P (x + y) _) (hŒπŒπ_mul : ‚àÄ (m‚ÇÅ m‚ÇÇ : M) {x : clifford_algebra Q} {hx : x ‚àà clifford_algebra.even_odd Q 0}, P x hx ‚Üí P (‚áë(clifford_algebra.Œπ Q) m‚ÇÅ * ‚áë(clifford_algebra.Œπ Q) m‚ÇÇ * x) _) (x : clifford_algebra Q) (hx : x ‚àà clifford_algebra.even_odd Q 0) : P x hx
 : has_repr pnat.xgcd_type
{R : Type u_4} {S : Type u_5} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S] (e : R ‚âÉ+* S) : R ‚Üí‚Çô+* S
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (P : Prop) [decidable P] (a : P ‚Üí Œ±) (b : ¬¨P ‚Üí Œ±) (c : P ‚Üí Œ≤) (d : ¬¨P ‚Üí Œ≤) : f (dite P a b) (dite P c d) = dite P (Œª (h : P), f (a h) (c h)) (Œª (h : ¬¨P), f (b h) (d h))
{R : Type u} [ring R] {J : Type v} [category_theory.small_category J] (F : J ‚•§ Module R) : submodule R (Œ† (j : J), ‚Ü•(F.obj j))
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (f : filter Œ±) : Prop
{S : Type v} (s : S) {R : Type u_1} [semiring R] [set_like S R] [subsemiring_class S R] : semiring ‚Ü•s
(Œ± : Type u_1) (R : Type u_2) [topological_space Œ±] [topological_space R] [ring R] [topological_ring R] : subring (Œ± ‚Üí R)
{Œ± : Type u} (c‚ÇÅ c‚ÇÇ : computation Œ±) : Prop
{Œ± : Type u_1} [has_lt Œ±] {a b : Œ±·µí·µà} : b ‚ãñ a ‚Üí ‚áëorder_dual.of_dual a ‚ãñ ‚áëorder_dual.of_dual b
 : Type
{Œ± : Type u} [decidable_eq Œ±] (xs : list Œ±) (h : ‚àÄ (x : Œ±), x ‚àà xs) (h' : xs.nodup) : fin_enum Œ±
{Œ± : Type u_1} [ring Œ±] [uniform_space Œ±] [topological_ring Œ±] [uniform_add_group Œ±] : Œ± ‚Üí+* uniform_space.completion Œ±
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [nondiscrete_normed_field R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [normed_group F] [normed_space R F] [topological_space B] [topological_space (bundle.total_space E)] [Œ† (x : B), topological_space (E x)] [topological_vector_bundle R F E] (e : topological_vector_bundle.trivialization R F E) (b : B) : E b ‚ÜíL[R] F
{C : Type u} [category_theory.category C] (B : C) {J : Type v} (F : category_theory.discrete J ‚•§ category_theory.over B) : category_theory.limits.cone F ‚•§ category_theory.limits.cone (category_theory.over.construct_products.wide_pullback_diagram_of_diagram_over B F)
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : Type (max u (v+1))
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] {a : Œ±} {s : set Œ±} (hl : ‚àÉ (l : Œ±), l < a) (hu : ‚àÉ (u : Œ±), a < u) : s ‚àà nhds a ‚Üî ‚àÉ (l u : Œ±), a ‚àà set.Ioo l u ‚àß set.Ioo l u ‚äÜ s
{S : Type u} [add_semigroup S] {a x y x' y' : S} (h : add_semiconj_by a x y) (h' : add_semiconj_by a x' y') : add_semiconj_by a (x + x') (y + y')
{C : Type u‚ÇÅ} [category_theory.small_category C] {‚Ñ∞ : Type u‚ÇÇ} [category_theory.category ‚Ñ∞] (A : C ‚•§ ‚Ñ∞) [category_theory.limits.has_colimits ‚Ñ∞] : category_theory.limits.preserves_colimits (category_theory.colimit_adj.extend_along_yoneda A)
(n : name) (trusted : bool) (elab_def : tactic unit) : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_pullbacks C] {A B : C} (f : A ‚ü∂ B) [category_theory.mono f] : ‚ä§ ‚ü∂ (category_theory.mono_over.pullback f).obj (category_theory.mono_over.mk' f)
{C : Type u} [category_theory.category C] {X : C} [category_theory.limits.has_finite_products C] [category_theory.exponentiable (‚ä§_ C)] : (category_theory.exp (‚ä§_ C)).obj X ‚âÖ X
 : interactive.parse interactive.types.location ‚Üí tactic unit
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] (S : submodule K V) : finite_dimensional K (V ‚ß∏ S)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (m : hash_map Œ± Œ≤) (a : Œ±) (b : Œ≤ a) : hash_map Œ± Œ≤
{Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≥ : Type u_5} [has_inf Œ±] [has_inf Œ≤] [has_inf Œ≥] (f : inf_hom Œ≤ Œ≥) (g : inf_hom Œ± Œ≤) : inf_hom Œ± Œ≥
(M : Type u_1) [measurable_space M] [has_inf M] : Prop
(G : Type u) [monoid G] : Prop
{Œπ : Type u} (F : category_theory.discrete Œπ ‚•§ algebraic_geometry.LocallyRingedSpace) : algebraic_geometry.LocallyRingedSpace
 : linter
{Œ± : Type u} (l : ordnode Œ±) (x : Œ±) (r : ordnode Œ±) : ordnode Œ±
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] [pseudo_emetric_space Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : isometry g) (hf : isometry f) : isometry (g ‚àò f)
{Œ± : Type u_1} [complete_lattice Œ±] [is_compactly_generated Œ±] {a : Œ±} {s : set Œ±} (h : directed_on has_le.le s) : a ‚äì has_Sup.Sup s = ‚®Ü (b : Œ±) (H : b ‚àà s), a ‚äì b
{Œ± : Type u} [topological_space Œ±] {x : Œ±} : connected_component x ‚äÜ ‚ãÇ (Z : {Z // is_clopen Z ‚àß x ‚àà Z}), ‚ÜëZ
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} : function.injective coe_fn
{X : Top} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : (category_theory.pairwise.cocone U).op ‚âÖ (category_theory.limits.cones.postcompose_equivalence (category_theory.nat_iso.op (Top.presheaf.sheaf_condition.pairwise_diagram_iso U))).functor.obj (category_theory.limits.cone.whisker (Top.presheaf.sheaf_condition.pairwise_to_opens_le_cover U).op (Top.presheaf.sheaf_condition.opens_le_cover_cocone U).op)
{H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H ‚Üî totally_separated_space H
{G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] {x y : P} (h : function.injective bit0) : ‚áë(equiv.point_reflection x) y = y ‚Üî y = x
{Œ± : Sort u} {Œ≤ : Sort v} {f : Œ± ‚Üí Œ≤} (h : function.surjective f) (b : Œ≤) : Œ±
(e : expr) : tactic unit
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X Y : C) [category_theory.monoidal_category.lift_obj X] [category_theory.monoidal_category.lift_obj Y] : Type v
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Ring) : subring (Œ† (j : J), ‚Ü•(F.obj j))
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {E' : Type u_7} [inner_product_space ùïú E'] {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (f : E ‚Üí‚Çó·µ¢[ùïú] E') : orthonormal ùïú (‚áëf ‚àò v)
{X : Type u} [lattice X] [jordan_holder_lattice X] (s‚ÇÅ s‚ÇÇ : composition_series X) : Prop
{C : Type u} [category_theory.category C] {J‚ÇÅ J‚ÇÇ : category_theory.grothendieck_topology C} (h : ‚áëJ‚ÇÅ = ‚áëJ‚ÇÇ) : J‚ÇÅ = J‚ÇÇ
{Œ± : Type u_1} {M : Type u_5} [add_monoid M] : has_scalar ‚Ñï (Œ± ‚Üí‚ÇÄ M)
{Œ± : Type u_1} [linear_order Œ±] (s : finset Œ±) (H : s.nonempty) : Œ±
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), add_comm_monoid (A i)] [add_monoid Œπ] [direct_sum.gsemiring A] : semiring (A 0)
{Œ± : Type u_1} {Œπ : Type u_2} {s : set Œπ} {f : Œπ ‚Üí set Œ±} (h : s.pairwise_disjoint f) : (‚Ü•‚ãÉ (i : Œπ) (H : i ‚àà s), f i) ‚âÉ Œ£ (i : ‚Ü•s), ‚Ü•(f ‚Üëi)
{Œ± : Type u_1} [has_repr Œ±] : has_repr (cycle Œ±)
{Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [ring Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_ring_hom f) : is_semiring_hom f
{Œ± : Type u_1} [has_le Œ±] {a b : Œ±·µí·µà} : b ‚â§ a ‚Üí ‚áëorder_dual.of_dual a ‚â§ ‚áëorder_dual.of_dual b
{R : Type u_1} {M : Type u_9} {M‚ÇÇ : Type u_12} [comm_semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] : M ‚Üí‚Çó[R] (M ‚Üí‚Çó[R] M‚ÇÇ) ‚Üí‚Çó[R] M‚ÇÇ
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (G : D ‚•§ C) [‚àÄ (A : C), category_theory.limits.has_initial (category_theory.structured_arrow A G)] : C ‚•§ D
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {f : V ‚âÉ‚Çó·µ¢[‚Ñù] V} (hd : 0 < ‚áëlinear_map.det ‚Üë(f.to_linear_equiv)) : ‚àÉ (Œ∏ : real.angle), f = o.rotation Œ∏
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] (F : J ‚•§ algebraic_geometry.PresheafedSpace C) : category_theory.limits.cocone F
(M : Type u_1) [semigroup M] : subsemigroup M
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} {x : P.last.M} {a : P.A} {f : P.last.B a ‚Üí P.last.M} (h : x.dest = ‚ü®a, f‚ü©) (f' : typevec.arrow (mvpfunctor.M.path P x) Œ±) : (P.drop.B a).arrow Œ±
{Œπ : Type u_1} {X : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), topological_space (X i)] {as bs : Œ† (i : Œπ), X i} (i : Œπ) (p : path.homotopic.quotient as bs) : path.homotopic.quotient (as i) (bs i)
{n : ‚Ñï} (x y : bitvec n) : Prop
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (f : M ‚Üí* N) (S : submonoid N) : submonoid M
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : C ‚•§ C ‚•§ C
{Œ± : Type u} {Œ≤ : Type v} (m : Œ± ‚Üí Œ≤) (f : ultrafilter Œ±) : ultrafilter Œ≤
{M : Type u_1} [linear_ordered_cancel_add_comm_monoid M] (S : add_submonoid M) : linear_ordered_cancel_add_comm_monoid ‚Ü•S
(R : Type u) [comm_ring R] [is_domain R] : discrete_valuation_ring R ‚Üî is_principal_ideal_ring R ‚àß ‚àÉ! (P : ideal R), P ‚â† ‚ä• ‚àß P.is_prime
{Œ± : Type u_1} {M : Type u_5} [has_zero M] (p : Œ± ‚Üí Prop) (f : Œ± ‚Üí‚ÇÄ M) : Œ± ‚Üí‚ÇÄ M
{Œ≥ : Type w} [semilattice_inf Œ≥] {a‚ÇÅ a‚ÇÇ : Œ≥} {s t : set Œ≥} (hs : is_glb s a‚ÇÅ) (ht : is_glb t a‚ÇÇ) : is_glb (s ‚à™ t) (a‚ÇÅ ‚äì a‚ÇÇ)
(tac : tactic.interactive.itactic) : tactic unit
(n : expr) : tactic expr
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} : category_theory.limits.cokernel 0 ‚âÖ Y
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : tensor_product R A (polynomial R) ‚Üí‚Çê[R] polynomial A
{R‚ÇÅ : Type u_1} [semiring R‚ÇÅ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] {M‚ÇÉ : Type u_7} [topological_space M‚ÇÉ] [add_comm_monoid M‚ÇÉ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] (f‚ÇÅ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ) (f‚ÇÇ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ √ó M‚ÇÉ
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} (x : E) {g : F ‚Üí G} {g' : F ‚ÜíL[ùïú] G} (hg : has_fderiv_at g g' (f x)) (hf : has_fderiv_at f f' x) : has_fderiv_at (g ‚àò f) (g'.comp f') x
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.is_iso g] : category_theory.limits.pullback_cone f g
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (s : add_submonoid M) (t : add_submonoid N) : ‚Ü•(s.prod t) ‚âÉ+ ‚Ü•s √ó ‚Ü•t
{M : Type u_3} {N : Type u_4} {P : Type u_5} {Q : Type u_1} [has_one M] [has_one N] [has_one P] [has_one Q] (f : one_hom M N) (g : one_hom N P) (h : one_hom P Q) : (h.comp g).comp f = h.comp (g.comp f)
 : binder_info ‚Üí string √ó string
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f g : Y ‚ü∂ X) : f = g
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [normalized_gcd_monoid Œ±] (s : multiset Œ±) : Œ±
{C : Type u} {X Y : category_theory.free_monoidal_category C} : X.hom Y ‚Üí X.hom Y ‚Üí Prop
{Œπ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Œπ ‚Üí set X} {s : set X} (hs : is_closed s) (uo : ‚àÄ (i : Œπ), is_open (u i)) (uf : ‚àÄ (x : X), x ‚àà s ‚Üí {i : Œπ | x ‚àà u i}.finite) (us : s ‚äÜ ‚ãÉ (i : Œπ), u i) : ‚àÉ (v : Œπ ‚Üí set X), s ‚äÜ set.Union v ‚àß (‚àÄ (i : Œπ), is_closed (v i)) ‚àß ‚àÄ (i : Œπ), v i ‚äÜ u i
{R : Type u} {S : Type v} [ring R] [ring S] (s : subring R) (t : subring S) : subring (R √ó S)
(Œ± : Type u) : category_theory.mono_over Œ± ‚âå set Œ±
 : is_absolute_value.uniform_space has_abs.abs = pseudo_metric_space.to_uniform_space
{C : Type u‚ÇÅ} [category_theory.small_category C] {‚Ñ∞ : Type u‚ÇÇ} [category_theory.category ‚Ñ∞] (A : C ‚•§ ‚Ñ∞) [category_theory.limits.has_colimits ‚Ñ∞] (L : (C·µí·µñ ‚•§ Type u‚ÇÅ) ‚•§ ‚Ñ∞) (hL : category_theory.yoneda ‚ãô L ‚âÖ A) [category_theory.limits.preserves_colimits L] : L ‚âÖ category_theory.colimit_adj.extend_along_yoneda A
{Œ± : Type u_1} [topological_space Œ±] [partial_order Œ±] {s : set Œ±} [topological_space.separable_space ‚Ü•s] (hs : dense s) : ‚àÉ (t : set Œ±) (H : t ‚äÜ s), t.countable ‚àß dense t ‚àß (‚àÄ (x : Œ±), is_bot x ‚Üí x ‚àà s ‚Üí x ‚àà t) ‚àß ‚àÄ (x : Œ±), is_top x ‚Üí x ‚àà s ‚Üí x ‚àà t
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.preadditive C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} {P : category_theory.ProjectiveResolution Y} {Q : category_theory.ProjectiveResolution Z} (f : P.complex ‚ü∂ Q.complex) (n : ‚Ñï) (g : P.complex.X n ‚ü∂ Q.complex.X (n + 1)) (g' : P.complex.X (n + 1) ‚ü∂ Q.complex.X (n + 2)) (w : f.f (n + 1) = P.complex.d (n + 1) n ‚â´ g + g' ‚â´ Q.complex.d (n + 2) (n + 1)) : P.complex.X (n + 2) ‚ü∂ Q.complex.X (n + 3)
{n : ‚Ñï} {Œ± : Type u_1} [linear_order Œ±] (f : fin n ‚Üí Œ±) : equiv.perm (fin n)
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
(Œ± : Type u') : first_order.language
{Œπ : Type u_1} (Œ± : Œπ ‚Üí Type u_2) (Œ≤ : Type u_3) : (Œ£ (i : Œπ), Œ± i) √ó Œ≤ ‚âÉ Œ£ (i : Œπ), Œ± i √ó Œ≤
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] : list Œ± ‚Üí list Œ±
 : znum ‚Üí option num
{Œ± : Type} (p : lean.parser Œ±) : lean.parser Œ±
{Œ± : Type u} [has_subset Œ±] [has_ssubset Œ±] [is_nonstrict_strict_order Œ± has_subset.subset has_ssubset.ssubset] {a b : Œ±} (h : a ‚äÇ b) : a ‚äÜ b
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {s t : category_theory.limits.cone F} (P : category_theory.limits.is_limit s) (Q : category_theory.limits.is_limit t) (f : s ‚ü∂ t) : category_theory.is_iso f
(n : ‚Ñï) : convex_on ‚Ñù (set.Ici 0) (Œª (x : ‚Ñù), x ^ n)
{R : Type u_1} {A : Type u_2} (x : unitization R A) : A
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space E] {f : E ‚Üí F} {f' : E ‚Üí (E ‚âÉL[ùïú] F)} (hf : ‚àÄ (x : E), has_strict_fderiv_at f ‚Üë(f' x) x) : is_open_map f
{J : Type v} [category_theory.small_category J] {A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] {L : A ‚•§ T} {R : B ‚•§ T} (F : J ‚•§ category_theory.comma L R) [category_theory.limits.preserves_limit (F ‚ãô category_theory.comma.snd L R) R] (c‚ÇÅ : category_theory.limits.cone (F ‚ãô category_theory.comma.fst L R)) {c‚ÇÇ : category_theory.limits.cone (F ‚ãô category_theory.comma.snd L R)} (t‚ÇÇ : category_theory.limits.is_limit c‚ÇÇ) : category_theory.limits.cone F
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {ps : set P} {n : ‚Ñï} [finite_dimensional ‚Ñù V] (hd : finite_dimensional.finrank ‚Ñù V = n) (hc : euclidean_geometry.cospherical ps) : ‚àÉ (r : ‚Ñù), ‚àÄ (sx : affine.simplex ‚Ñù P n), set.range sx.points ‚äÜ ps ‚Üí sx.circumradius = r
{A : Type u_1} {B : Type u_2} [comm_ring A] [is_domain A] [ring B] [algebra A B] {x : B} {a : polynomial A} (hx : is_integral A x) (hamonic : a.monic) (hdvd : dvd_not_unit a (minpoly A x)) : ‚áë(polynomial.aeval x) a ‚â† 0
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} {C : clifford_algebra Q ‚Üí Prop} (h_grade0 : ‚àÄ (r : R), C (‚áë(algebra_map R (clifford_algebra Q)) r)) (h_grade1 : ‚àÄ (x : M), C (‚áë(clifford_algebra.Œπ Q) x)) (h_mul : ‚àÄ (a b : clifford_algebra Q), C a ‚Üí C b ‚Üí C (a * b)) (h_add : ‚àÄ (a b : clifford_algebra Q), C a ‚Üí C b ‚Üí C (a + b)) (a : clifford_algebra Q) : C a
{X : Top} {Œπ : Type v} {V : Top} {j : V ‚ü∂ X} (oe : open_embedding ‚áëj) (ùí∞ : Œπ ‚Üí topological_space.opens ‚Ü•V) : Œπ ‚Üí topological_space.opens ‚Ü•X
{p : nat_ordinal ‚Üí Prop} (i : nat_ordinal) (h : ‚àÄ (j : nat_ordinal), (‚àÄ (k : nat_ordinal), k < j ‚Üí p k) ‚Üí p j) : p i
{F : Type u_1} [field F] {K‚ÇÅ : Type u_3} {K‚ÇÇ : Type u_4} [field K‚ÇÅ] [field K‚ÇÇ] [algebra F K‚ÇÅ] [algebra F K‚ÇÇ] (œá : K‚ÇÅ ‚âÉ‚Çê[F] K‚ÇÇ) (E : Type u_6) [field E] [algebra F E] [algebra K‚ÇÅ E] [algebra K‚ÇÇ E] [is_scalar_tower F K‚ÇÅ E] [is_scalar_tower F K‚ÇÇ E] [normal F E] : E ‚âÉ‚Çê[F] E
{Œ± : Sort u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} : quot r ‚Üí Œ±
(e : expr) (l : list name) : bool
{Œ± : Type u} (l : ordnode Œ±) (x : Œ±) (r : ordnode Œ±) : ordnode Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) {r : ‚Ñù} (hr : r ‚â† 0) : 2 ‚Ä¢ o.oangle x (r ‚Ä¢ y) = 2 ‚Ä¢ o.oangle x y
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_zero_class Œ±] [add_zero_class Œ≤] : (Œ±·µê·µí·µñ ‚Üí+ Œ≤·µê·µí·µñ) ‚âÉ (Œ± ‚Üí+ Œ≤)
{Œ± : Type} (desc : format) (p : lean.parser Œ±) : lean.parser Œ±
{Œ± : Type u} [pseudo_metric_space Œ±] {x : Œ±} : metric.bounded {x}
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {s t : set Œ±} (hst : disjoint (s ‚à© function.mul_support f) (t ‚à© function.mul_support f)) (hs : (s ‚à© function.mul_support f).finite) (ht : (t ‚à© function.mul_support f).finite) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s ‚à™ t), f i)) = finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)) * finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà t), f i))
 : Type
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] (F : C ‚•§ D) [category_theory.limits.preserves_colimits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] [category_theory.limits.preserves_colimits_of_shape (category_theory.discrete pempty) F] [category_theory.limits.has_finite_coproducts C] (n : ‚Ñï) (f : ulift (fin n) ‚Üí C) : category_theory.limits.preserves_colimit (category_theory.discrete.functor f) F
{R : Type u_1} [comm_ring R] {x‚ÇÅ x‚ÇÇ y‚ÇÅ y‚ÇÇ : R} : (x‚ÇÅ ^ 2 + x‚ÇÇ ^ 2) * (y‚ÇÅ ^ 2 + y‚ÇÇ ^ 2) = (x‚ÇÅ * y‚ÇÅ - x‚ÇÇ * y‚ÇÇ) ^ 2 + (x‚ÇÅ * y‚ÇÇ + x‚ÇÇ * y‚ÇÅ) ^ 2
{V : Type v} [category_theory.category V] [category_theory.monoidal_category V] {C : Type u‚ÇÅ} [category_theory.enriched_category V C] {D : Type u‚ÇÇ} [category_theory.enriched_category V D] (A : category_theory.center V) (F G : category_theory.enriched_functor V C D) : Type (max u‚ÇÅ w)
 : quadratic_form ‚Ñù ‚Ñù
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} (F : C ‚•§ D) {c : category_theory.limits.cocone K} (t : category_theory.limits.is_colimit (F.map_cocone c)) [category_theory.limits.reflects_colimit K F] : category_theory.limits.is_colimit c
{Œ± : Type u_1} {R : Type u_11} [has_zero R] [subsingleton R] : unique (Œ± ‚Üí‚ÇÄ R)
{Œ± : Type u} [pseudo_metric_space Œ±] {f : Œ± ‚Üí ‚Ñù} (K : ‚Ñù) (h : ‚àÄ (x y : Œ±), f x ‚â§ f y + K * has_dist.dist x y) : lipschitz_with K.to_nnreal f
{P : ‚Ñï ‚Üí Sort u_1} (n : ‚Ñï) (h : Œ† (n : ‚Ñï), (Œ† (m : ‚Ñï), m < n ‚Üí P m) ‚Üí P n) : P n
(L : first_order.language) (M : Type w) : Type (max u v w)
{Œ± : Type u} [linear_ordered_comm_monoid Œ±] {Œ≤ : Type u_1} [has_one Œ≤] [has_mul Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : linear_ordered_comm_monoid Œ≤
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} : (mvqpf.P F).W Œ± ‚Üí (mvqpf.P F).W Œ±
{R : Type u} {n : Type w} [comm_ring R] [decidable_eq n] [fintype n] (J P : matrix n n R) (h : invertible P) : ‚Ü•(skew_adjoint_matrices_lie_subalgebra J) ‚âÉ‚Çó‚ÅÖR‚ÅÜ ‚Ü•(skew_adjoint_matrices_lie_subalgebra ((P.transpose.mul J).mul P))
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) : Type (max u_1 u_2)
(R : Type u_1) [semiring R] {C : Type u_2} {D : Type u_3} [category_theory.category C] [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] [category_theory.linear R C] [category_theory.linear R D] (F : C ‚•§ D) [F.additive] [category_theory.functor.linear R F] {X Y : C} : (X ‚ü∂ Y) ‚Üí‚Çó[R] F.obj X ‚ü∂ F.obj Y
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D·µí·µñ) (G : D ‚•§ C) (h : G ‚ä£ F.unop) : F ‚ä£ G.op
{C : Type u} [category_theory.category C] : category_theory.arrow.left_func ‚ü∂ category_theory.arrow.right_func
{Œπ : Type v} {M : Type u_1} {S : Type u_2} [decidable_eq Œπ] [add_comm_monoid M] [set_like S M] [add_submonoid_class S M] (A : Œπ ‚Üí S) : direct_sum Œπ (Œª (i : Œπ), ‚Ü•(A i)) ‚Üí+ M
{Œ± : Type u_1} [topological_space Œ±] {s t : set Œ±} (h : s = t) : ‚Ü•s ‚âÉ‚Çú ‚Ü•t
 : vm_obj ‚Üí ‚Ñï
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_preorder Œ± r] : antisymmetrization Œ± r ‚Üí Œ±
(n a : ‚Ñï) (p : ‚Ñï ‚Üí Prop) [decidable_pred p] (pp : function.periodic p a) : ‚áëmultiset.card (multiset.filter p (multiset.Ico n (n + a))) = nat.count p a
{Œ± : Type u_1} (l‚ÇÅ l‚ÇÇ : list Œ±) : Prop
{Œ± : Type u_1} [semigroup Œ±] (x y : Œ±) : ((Œª (_x : Œ±), _x * x) ‚àò Œª (_x : Œ±), _x * y) = Œª (_x : Œ±), _x * (y * x)
{C : Type u} [category_theory.category C] [category_theory.enough_injectives C] (X : C) : C
{L : first_order.language} {Œ± : Type u'} {Œ≤ : Type v'} (g : Œ± ‚Üí Œ≤) : L.formula Œ± ‚Üí L.formula Œ≤
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± : D·µí·µñ ‚•§ A} {‚Ñ±' : category_theory.Sheaf K A} (Œ± : G.op ‚ãô ‚Ñ± ‚ü∂ G.op ‚ãô ‚Ñ±'.val) : category_theory.whisker_left G.op (H.sheaf_hom Œ±) = Œ±
{Œ± : Type} {m : Type ‚Üí Type u_1} [monad m] (f : Œ± ‚Üí expr ‚Üí m Œ±) : Œ± ‚Üí expr ‚Üí m Œ±
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {a a' : P.A} (h : a = a') : P.last.B a ‚Üí P.last.B a'
(Œ± : Type u_1) : Type u_1
{G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G ‚Üí* G') (hf : function.surjective ‚áëf) : group.is_nilpotent G'
{ùïú : Type u_1} {V : Type u_2} {V‚ÇÇ : Type u_4} {P : Type u_8} {P‚ÇÇ : Type u_9} [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V P] [normed_add_torsor V‚ÇÇ P‚ÇÇ] {f : P ‚Üí P‚ÇÇ} (hf : isometry f) {p : P} {g : V ‚Üí V‚ÇÇ} (hg : ‚àÄ (v : V), g v = f (v +·µ• p) -·µ• f p) : isometry g
 : free_ring pempty ‚âÉ+* ‚Ñ§
{Œπ : Type u_1} {R : Type u_8} [ordered_comm_semiring R] {f : Œπ ‚Üí R} {s : finset Œπ} (h0 : ‚àÄ (i : Œπ), i ‚àà s ‚Üí 0 ‚â§ f i) (h1 : ‚àÄ (i : Œπ), i ‚àà s ‚Üí f i ‚â§ 1) : s.prod (Œª (i : Œπ), f i) ‚â§ 1
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] {A : set E} {x : E} : x ‚àà set.extreme_points ùïú A ‚Üî is_extreme ùïú A {x}
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] [has_zero Œ≤] : has_coe_to_fun (zero_at_infty_continuous_map Œ± Œ≤) (Œª (_x : zero_at_infty_continuous_map Œ± Œ≤), Œ± ‚Üí Œ≤)
{S : Type v} (s : S) {R : Type u_1} [ordered_ring R] [set_like S R] [subring_class S R] : ordered_ring ‚Ü•s
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j‚ÇÅ j‚ÇÇ j‚ÇÉ : C) : j‚ÇÇ ‚ü∂ category_theory.is_filtered.max‚ÇÉ j‚ÇÅ j‚ÇÇ j‚ÇÉ
{Œ± : Type u_1} {Œ≤ : Type u_2} [semi_normed_ring Œ±] [semi_normed_ring Œ≤] : semi_normed_ring (Œ± √ó Œ≤)
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) : hb.oangle y (‚áë(hb.rotation (hb.oangle x y)) x) = 0
{Œ± : Type u} : seq1 Œ± ‚Üí seq Œ±
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : add_localization S ‚Üí add_localization S ‚Üí add_localization S
(pos neg zero : name) (Œ± Œ≤ one a b : expr) : tactic (expr √ó expr)
 : has_add many_one_degree
{X : Type u_1} [topological_space X] {x y : X} (Œ≥ : path x y) : ‚Ü•unit_interval ‚Üí X
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X ‚Ñù) {a b : ‚Ñù} {e : X ‚Üí Y} (hf : ‚àÄ (x : X), ‚áëf x ‚àà set.Icc a b) (hle : a ‚â§ b) (he : closed_embedding e) : ‚àÉ (g : bounded_continuous_function Y ‚Ñù), (‚àÄ (y : Y), ‚áëg y ‚àà set.Icc a b) ‚àß ‚áëg ‚àò e = ‚áëf
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : Prop
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (a b : Œ±) : Œ±
(R : Type u) [semiring R] {Œπ : Type u_1} [fintype Œπ] {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), add_comm_group (M i)] [Œ† (i : Œπ), module R (M i)] [‚àÄ (i : Œπ), module.free R (M i)] : module.free R (Œ† (i : Œπ), M i)
(M : Type u) : Type u
{Œ± : Type u} [complete_lattice Œ±] (f : Œ± ‚Üío Œ±) (x : Œ±) (hx : x ‚â§ ‚áëf x) : ‚Ü•(function.fixed_points ‚áëf)
{R S : Type u} [comm_ring R] [comm_ring S] (M : submonoid R) (S' : Type u) [comm_ring S'] [algebra S S'] [algebra R S] [algebra R S'] [is_scalar_tower R S S'] [is_localization (submonoid.map ‚Üë(algebra_map R S) M) S'] (x : S) (s : finset S') (hx : ‚áë(algebra_map S S') x ‚àà submodule.span R ‚Üës) : ‚àÉ (m : ‚Ü•M), m ‚Ä¢ x ‚àà submodule.span R ‚Üë(is_localization.finset_integer_multiple (submonoid.map ‚Üë(algebra_map R S) M) s)
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {s : category_theory.limits.cocone F} (e : K ‚âå J) (P : category_theory.limits.is_colimit (category_theory.limits.cocone.whisker e.functor s)) : category_theory.limits.is_colimit s
{Œ± : Type u_1} (V : set (Œ± √ó Œ±)) : set (Œ± √ó Œ±)
 : pSet ‚Üí pSet ‚Üí Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] (Œπ : Type u_2) [fintype Œπ] (E : Œπ ‚Üí Type u_3) [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] (s : Œ† (i : Œπ), set (E i)) (h : ‚àÄ (i : Œπ), unique_diff_on ùïú (s i)) : unique_diff_on ùïú (set.univ.pi s)
(x : ‚ÑÇ) : has_deriv_at complex.exp (complex.exp x) x
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (F : D ‚•§ C) (Y : D) : F.obj Y ‚àà F.ess_image
(Œ± : Type u_1) [linear_order Œ±] : LinearOrder
(F : Type u_1) (R : Type u_2) [field F] [semiring R] [nontrivial R] [algebra F R] : ‚Ü•‚ä• ‚âÉ‚Çê[F] F
(R : Type v) [comm_ring R] : basis ‚Ñï R (polynomial R)
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : (C·µí·µñ ‚•§ D)·µí·µñ ‚âå C ‚•§ D·µí·µñ
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x : V) : hb.oangle x 0 = 0
 : tactic.list_Pi tactic.rcases_patt ‚Üí tactic.rcases_patt
{Œ± : Type u_1} [measurable_space Œ±] [pseudo_emetric_space Œ±] [opens_measurable_space Œ±] (e : ‚Ñï ‚Üí Œ±) : ‚Ñï ‚Üí measure_theory.simple_func Œ± ‚Ñï
{G : Type u} [group G] [fintype G] {p : ‚Ñï} [hp : fact (nat.prime p)] (P : sylow p G) : (fintype.card ‚Ü•P).coprime ‚ÜëP.index
 : Type
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cocone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_colimit t) : (category_theory.limits.binary_bicone.of_colimit_cocone ht).is_bilimit
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_vadd Œ± Œ≤] : has_vadd (set Œ±) (set Œ≤)
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (S : submonoid M) (f : M ‚Üí* N) (hf : function.injective ‚áëf) : ‚Ü•S ‚âÉ* ‚Ü•(submonoid.map f S)
 : turing.to_partrec.code
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0
{G : Type u_1} [group G] (S T : set G) : Prop
(X : Top) (T : ‚Ü•X ‚Üí Type u) : (X.presheaf_to_Types T).is_sheaf
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] (L : A ‚•§ T) (R : B ‚•§ T) : category_theory.comma L R ‚•§ B
(a b : nonote) : ordering
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (n : with_top ‚Ñï) (f : E ‚Üí F) (s : set E) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {B A : C} (X : category_theory.subobject B) (f : A ‚ü∂ B) [category_theory.mono f] (h : X = category_theory.subobject.mk f) : ‚ÜëX ‚âÖ A
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_assoc_semiring Œ±} {rŒ≤ : non_assoc_semiring Œ≤} (f : Œ± ‚Üí+* Œ≤) (a : Œ±) : ‚áëf (bit0 a) = bit0 (‚áëf a)
 : expr ‚Üí expr ‚Üí bool
{Œ± : Type u} [t : topological_space Œ±] {Œπ : Type u_1} [encodable Œπ] {U : Œπ ‚Üí set Œ±} [‚àÄ (i : Œπ), topological_space.second_countable_topology ‚Ü•(U i)] (Uo : ‚àÄ (i : Œπ), is_open (U i)) (hc : (‚ãÉ (i : Œπ), U i) = set.univ) : topological_space.second_countable_topology Œ±
(c : cardinal) : Prop
(step : expr ‚Üí tactic (expr √ó expr)) (hs : list tactic.simp_arg_type) (l : interactive.loc) : tactic unit
(ùïú : Type u_1) {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] (x y : E) : set E
{Œ± : Type u_1} [ring Œ±] [uniform_space Œ±] [topological_ring Œ±] [uniform_add_group Œ±] {Œ≤ : Type u} [uniform_space Œ≤] [ring Œ≤] [uniform_add_group Œ≤] [topological_ring Œ≤] (f : Œ± ‚Üí+* Œ≤) (hf : continuous ‚áëf) [complete_space Œ≤] [separated_space Œ≤] : uniform_space.completion Œ± ‚Üí+* Œ≤
(A B : Top) : ‚Ü•(fundamental_groupoid.fundamental_groupoid_functor.obj A) √ó ‚Ü•(fundamental_groupoid.fundamental_groupoid_functor.obj B) ‚•§ ‚Ü•(fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (‚Ü•A √ó ‚Ü•B)))
(S : set ‚Ñï+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [is_domain B] [h‚ÇÅ : fintype ‚Ü•S] [h‚ÇÇ : is_cyclotomic_extension S A B] : module.finite A B
 : primrec (Œª (a : (‚Ñï √ó nat.partrec.code) √ó ‚Ñï), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)
(n : ‚Ñï) (f : format) : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [preorder Œ±] [order_bot Œ±] [partial_order Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : galois_connection l u) : order_bot Œ≤
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} [category_theory.artinian_object X] (h : ¬¨category_theory.limits.is_zero X) : category_theory.simple_subobject h ‚ü∂ X
 : ‚Ñï
{M : Type u_1} [comm_monoid M] {S : submonoid M} {p : Sort u} (x : localization S) (f : M ‚Üí ‚Ü•S ‚Üí p) (H : ‚àÄ {a c : M} {b d : ‚Ü•S}, ‚áë(localization.r S) (a, b) (c, d) ‚Üí f a b = f c d) : p
(id : interactive.parse (optional lean.parser.ident)) (tac : tactic.interactive.itactic) : tactic unit
 : native.float ‚Üí native.float
{C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] [category_theory.limits.has_binary_product Q P] : P ‚®Ø Q ‚âÖ Q ‚®Ø P
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {S S' : D} {T : C ‚•§ D} (f : S ‚ü∂ S') : category_theory.structured_arrow S' T ‚•§ category_theory.structured_arrow S T
 : ordinal ‚Üí pgame
 : tactic unit
(R : Type u) [comm_semiring R] (S : Type v) [semiring S] [algebra R S] : polynomial R ‚Üí‚Çê[R] polynomial S
{G : Type u_1} [comm_group G] : group.is_nilpotent G
{Œ± : Type u} [pseudo_emetric_space Œ±] (B : ‚Ñï ‚Üí ennreal) (hB : ‚àÄ (n : ‚Ñï), 0 < B n) (H : ‚àÄ (u : ‚Ñï ‚Üí Œ±), (‚àÄ (N n m : ‚Ñï), N ‚â§ n ‚Üí N ‚â§ m ‚Üí has_edist.edist (u n) (u m) < B N) ‚Üí (‚àÉ (x : Œ±), filter.tendsto u filter.at_top (nhds x))) : complete_space Œ±
{R : Type u} [semiring R] : polynomial R ‚Üí‚Çó[R] polynomial R
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) : e.trans e.symm ‚âà local_homeomorph.of_set e.to_local_equiv.source _
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F F' : C ‚•§ D} [category_theory.full F] (Œ± : F ‚âÖ F') : category_theory.full F'
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R) : ‚Üë‚Üë‚Üëg = ‚Üëg
(Œ± : Type u_1) : Type u_1
{B : Type u_3} (E‚ÇÅ : B ‚Üí Type u_6) (E‚ÇÇ : B ‚Üí Type u_7) [topological_space (bundle.total_space E‚ÇÅ)] [topological_space (bundle.total_space E‚ÇÇ)] : inducing (Œª (p : bundle.total_space (Œª (x : B), E‚ÇÅ x √ó E‚ÇÇ x)), (‚ü®p.fst, p.snd.fst‚ü©, ‚ü®p.fst, p.snd.snd‚ü©))
(n : ‚Ñï) : n.totient * n.factors.to_finset.prod (Œª (p : ‚Ñï), p) = n * n.factors.to_finset.prod (Œª (p : ‚Ñï), p - 1)
{Œ± : Type} (a b : expr) (f : expr ‚Üí expr √ó expr ‚Üí expr √ó expr ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí tactic.norm_fin.eval_fin_m Œ±) : tactic Œ±
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (hash_fn : Œ± ‚Üí ‚Ñï) {n : ‚Ñï+} (data : bucket_array Œ± Œ≤ n) (a : Œ±) (f : list (Œ£ (a : Œ±), Œ≤ a) ‚Üí list (Œ£ (a : Œ±), Œ≤ a)) : bucket_array Œ± Œ≤ n
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] {a : Œ±} {s : set Œ±} (ha : is_glb s a) (hs : s.nonempty) (sc : is_closed s) : a ‚àà s
(G : Type u_1) [group G] (n : ‚Ñï) : subgroup G
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {D : Type u_3} [category_theory.category D] [category_theory.preadditive D] (G : C ‚•§ D) [G.additive] (X : category_theory.simplicial_object C) (q n m : ‚Ñï) (hnm : algebraic_topology.dold_kan.c.rel m n) : algebraic_topology.dold_kan.hœÉ' q n m hnm = G.map (algebraic_topology.dold_kan.hœÉ' q n m hnm)
{Œ± : Type u} [monoid Œ±] {a : Œ±} (h : is_unit a) : invertible a
{m : Type u ‚Üí Type u} [monad m] {Œ± Œ≤ : Type u} (f : Œ± ‚Üí Œ≤) : tactic.mllist m Œ± ‚Üí tactic.mllist m Œ≤
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] (f : equiv.perm Œ±) : finset Œ±
{Œ± : Type u} {Œ≤ : Type u_1} (f : Œ± ‚Üí Œ≤) : tree Œ± ‚Üí tree Œ≤
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b : Œ±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{G : Type u_1} [add_group G] {Œ± : Type u_4} [add_action G Œ±] (S : add_subgroup G) : add_action ‚Ü•S Œ±
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {G : D ‚•§ C} [category_theory.is_right_adjoint G] [‚àÄ (A : (category_theory.adjunction.of_right_adjoint G).to_monad.algebra), category_theory.limits.has_coequalizer ((category_theory.left_adjoint G).map A.a) ((category_theory.adjunction.of_right_adjoint G).counit.app ((category_theory.left_adjoint G).obj A.A))] : (category_theory.adjunction.of_right_adjoint G).to_monad.algebra ‚•§ D
{C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ‚Ñï} {i j : fin (n + 1)} (H : i ‚â§ j) : X.œÉ j ‚â´ X.œÉ (‚áëfin.cast_succ i) = X.œÉ i ‚â´ X.œÉ j.succ
(Œ± : Type u_5) (Œ≤ : Type u_6) [topological_space Œ±] [topological_space Œ≤] : Type (max u_5 u_6)
(t : ‚Ü•unit_interval) : ‚Ñù
(a : ordinal) : ‚àÉ (f : Œ† (b : ordinal), b < a.cof.ord ‚Üí ordinal), a.is_fundamental_sequence a.cof.ord f
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} {p : filter Œπ} {g : Œπ ‚Üí Œ±} [topological_space Œ±] (h : tendsto_locally_uniformly_on F f p s) (hf : continuous_within_at f s x) (hx : x ‚àà s) (hg : filter.tendsto g p (nhds_within x s)) : filter.tendsto (Œª (n : Œπ), F n (g n)) p (nhds (f x))
{K : Type u} [field K] (s : subfield K) : add_subgroup K
(R : Type u) [comm_ring R] : Type u
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f g : Œ± ‚Üí M} (hf : (function.support f).finite) (hg : (function.support g).finite) : finsum (Œª (i : Œ±), f i + g i) = finsum (Œª (i : Œ±), f i) + finsum (Œª (i : Œ±), g i)
(k : ‚Ñ§) {b : ‚Ñù} (hb : 0 < b) : (Œª (x : ‚Ñù), x ^ k) =o[filter.at_top] Œª (x : ‚Ñù), real.exp (b * x)
{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] {Œ± : Type u_1} (s : set (Œ± ‚Üí M)) : Prop
{Œ± : Type u_1} {R : Œ± ‚Üí Œ± ‚Üí Prop} [decidable_rel R] {l : list Œ±} : list.pairwise R l ‚Üí list.pw_filter R l = l
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} (h : Œ≤ ‚Üí Œ≥) (g : Œ± ‚Üí Œ≤) (l : list Œ±) : list.map (h ‚àò g) l = list.map h (list.map g l)
{R : Type u_1} [comm_ring R] : clifford_algebra 0 ‚âÉ‚Çê[R] R
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (b : category_theory.limits.bicone (category_theory.limits.pair_function X Y)) : category_theory.limits.binary_bicone X Y
{Œπ : Type u} (Œ≤ : Œπ ‚Üí Type v) [Œ† (i : Œπ), add_zero_class (Œ≤ i)] (p : Œπ ‚Üí Prop) [decidable_pred p] : (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚Üí+ Œ†‚ÇÄ (i : Œπ), Œ≤ i
{C : Type u} [category_theory.category C] {P : C·µí·µñ ‚•§ Type v} (Ps : set (C·µí·µñ ‚•§ Type v)) (h : P ‚àà Ps) : category_theory.presieve.is_sheaf (category_theory.sheaf.finest_topology Ps) P
{x : ‚Ñù} (hx : x ‚â§ 0) : exp_neg_inv_glue x = 0
(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (Œπ : Type u_4) [decidable_eq Œπ] : Type (max u_2 u_1 u_4)
{Œ± : Type u_1} {M : Type u_2} {N : Type u_3} {R : Type u_5} (S : Type u_6) [semiring R] [semiring S] [add_comm_monoid M] [module R M] [add_comm_monoid N] [module R N] [module S N] [smul_comm_class R S N] : (Œ± ‚Üí (M ‚Üí‚Çó[R] N)) ‚âÉ‚Çó[S] (Œ± ‚Üí‚ÇÄ M) ‚Üí‚Çó[R] N
{Œ± : Type u_1} [topological_space Œ±] [group_with_zero Œ±] [has_continuous_mul Œ±] (c : Œ±) (hc : c ‚â† 0) : Œ± ‚âÉ‚Çú Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u} [category_theory.category J] (F : J ‚•§ C) [category_theory.limits.has_terminal J] [category_theory.limits.has_limit F] [‚àÄ (i j : J) (f : i ‚ü∂ j), category_theory.is_iso (F.map f)] : category_theory.limits.limit F ‚âÖ F.obj (‚ä§_ J)
(x y : {x // x.numeric}) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] (X : Type v‚ÇÅ) [category_theory.limits.has_coproducts_of_shape X C] : category_theory.limits.has_products_of_shape X C·µí·µñ
(J : Type u‚ÇÅ) [category_theory.category J] (C : Type u) [category_theory.category C] : Prop
(F : pfunctor) : Type u
 : tactic unit
{Œ± : Type u_1} {f g : ‚Ñï ‚Üí Œ±} [topological_space Œ±] [non_unital_non_assoc_semiring Œ±] [regular_space Œ±] [topological_semiring Œ±] (hf : summable f) (hg : summable g) (hfg : summable (Œª (x : ‚Ñï √ó ‚Ñï), f x.fst * g x.snd)) : (‚àë' (n : ‚Ñï), f n) * ‚àë' (n : ‚Ñï), g n = ‚àë' (n : ‚Ñï), (finset.range (n + 1)).sum (Œª (k : ‚Ñï), f k * g (n - k))
{ùïú : Type u} {Œπ : Type v} {Œπ' : Type v'} {G : Type wG} {G' : Type wG'} [decidable_eq Œπ] [fintype Œπ] [decidable_eq Œπ'] [fintype Œπ'] [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] [decidable_eq (Œπ ‚äï Œπ')] (f : continuous_multilinear_map ùïú (Œª (x : Œπ), G) (continuous_multilinear_map ùïú (Œª (x : Œπ'), G) G')) : continuous_multilinear_map ùïú (Œª (x : Œπ ‚äï Œπ'), G) G'
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) : Prop
{ùïú : Type u_1} {_x : ring ùïú} {E : Type u_2} [normed_group E] {_x_1 : module ùïú E} (s : submodule ùïú E) : normed_group ‚Ü•s
(R : Type u_1) [semiring R] : Type u_1
{R : Type u_1} [has_zero R] [has_one R] : dual_number R
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [mul_one_class M] [mul_one_class N] : Type (max u_10 u_11 u_9)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] {X‚ÇÅ X‚ÇÇ : C} (r : X‚ÇÅ ‚ü∂ X‚ÇÇ) : X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ X‚ÇÅ ‚äû X‚ÇÇ
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f‚ÇÇ : ùïú ‚Üí F} : cont_diff ùïú ‚ä§ f‚ÇÇ ‚Üî differentiable ùïú f‚ÇÇ ‚àß cont_diff ùïú ‚ä§ (deriv f‚ÇÇ)
{G : Type u_1} [group G] {H : subgroup G} [hG : group.fg G] (hH : H.index ‚â† 0) : group.fg ‚Ü•H
(X Y : Top) : category_theory.limits.is_limit (X.prod_binary_fan Y)
{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_zero M] [has_zero N] [has_zero P] (hnp : zero_hom N P) (hmn : zero_hom M N) : zero_hom M P
 : filter.tendsto (Œª (k : ‚Ñï), (finset.range k).prod (Œª (i : ‚Ñï), (2 * ‚Üëi + 2) / (2 * ‚Üëi + 1) * ((2 * ‚Üëi + 2) / (2 * ‚Üëi + 3)))) filter.at_top (nhds (real.pi / 2))
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J·µí·µñ ‚•§ C} (c : category_theory.limits.cone F.right_op) : category_theory.limits.cocone F
(m : ‚Ñï) (neg pos : list (list ‚Ñï √ó omega.term)) : tactic (list (list ‚Ñï √ó omega.term))
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {f : E ‚Üí F} {g : G ‚ÜíL[ùïú] E} (hf : cont_diff ùïú n f) : cont_diff ùïú n (f ‚àò ‚áëg)
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] {U : C} (R : category_theory.presieve U) (P : C·µí·µñ ‚•§ A) [category_theory.limits.has_products A] : P.obj (opposite.op U) ‚ü∂ category_theory.presheaf.first_obj R P
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] : category_theory.monoidal_functor (C √ó C) C
{Œ± : Type u} [pseudo_emetric_space Œ±] (E : set Œ±) : metric.cthickening 0 E = closure E
{S : set ordinal} (o : ordinal) : ordinal.enum_ord S o = has_Inf.Inf (S ‚à© set.Ici (o.blsub (Œª (a : ordinal) (_x : a < o), ordinal.enum_ord S a)))
(tm : turing.fin_tm2) : Type
{M : Type u_1} [add_comm_group M] [module ‚Ñù M] [finite_dimensional ‚Ñù M] (Q : quadratic_form ‚Ñù M) : ‚àÉ (w : fin (finite_dimensional.finrank ‚Ñù M) ‚Üí ‚Ñù), (‚àÄ (i : fin (finite_dimensional.finrank ‚Ñù M)), w i = -1 ‚à® w i = 0 ‚à® w i = 1) ‚àß Q.equivalent (quadratic_form.weighted_sum_squares ‚Ñù w)
{M : Type u_1} [add_monoid M] {Œπ : Type u_2} [fintype Œπ] {N : Œπ ‚Üí Type u_3} [Œ† (i : Œπ), add_monoid (N i)] (œï : Œ† (i : Œπ), N i ‚Üí+ M) (hcomm : ‚àÄ (i j : Œπ), i ‚â† j ‚Üí ‚àÄ (x : N i) (y : N j), add_commute (‚áë(œï i) x) (‚áë(œï j) y)) : (Œ† (i : Œπ), N i) ‚Üí+ M
{Œ± : Type u_1} (x : Œ±) : lazy_list Œ± ‚Üí Prop
{m : Type u ‚Üí Type u} [monad m] {Œ± : Type u} : tactic.mllist m Œ± ‚Üí tactic.mllist m (‚Ñï √ó Œ±)
(M‚ÇÄ : Type u_4) [has_mul M‚ÇÄ] [has_zero M‚ÇÄ] : Prop
(G : Type u) [add_monoid G] : ‚Ñï
(K : Type u) [field K] (V : FinVect K) : FinVect.FinVect_dual K V ‚äó V ‚ü∂ ùüô_ (FinVect K)
(x : pSet) : x.type ‚Üí pSet
(n : interactive.parse lean.parser.small_nat) (q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) : tactic unit
{G : add_subgroup ‚Ñù} {g‚ÇÄ : ‚Ñù} (g‚ÇÄ_in : g‚ÇÄ ‚àà G) (g‚ÇÄ_ne : g‚ÇÄ ‚â† 0) (H' : ¬¨‚àÉ (a : ‚Ñù), is_least {g : ‚Ñù | g ‚àà G ‚àß 0 < g} a) : dense ‚ÜëG
{Œ± : Type u_1} (q : semiquot Œ±) : Prop
{Œ± : Type u} [monoid Œ±] (a : Œ±) : set Œ±
{n : ‚Ñï} (fs : finset (fin (n + 1))) : affine.simplex.points_with_circumcenter_index n ‚Üí ‚Ñù
 : tactic unit
{R : Type u_1} [comm_ring R] [nontrivial R] {M : ideal R} (max : M.is_maximal) (not_field : ¬¨is_field R) : M ‚â† ‚ä•
{Œπa : Type u_7} {Œπb : Type u_8} [decidable_eq Œπa] [decidable_eq Œπb] [fintype Œπa] [fintype Œπb] {R' : Type u_9} {M·µ¢ : Type u_10} {N‚ÇÅ : Type u_11} {N‚ÇÇ : Type u_12} [comm_semiring R'] [add_comm_group N‚ÇÅ] [module R' N‚ÇÅ] [add_comm_group N‚ÇÇ] [module R' N‚ÇÇ] [add_comm_monoid M·µ¢] [module R' M·µ¢] (a : alternating_map R' M·µ¢ N‚ÇÅ Œπa) (b : alternating_map R' M·µ¢ N‚ÇÇ Œπb) : ‚áëmultilinear_map.alternatization (‚Üëa.dom_coprod ‚Üëb) = ((fintype.card Œπa).factorial * (fintype.card Œπb).factorial) ‚Ä¢ a.dom_coprod b
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [decidable_eq J] (f : J ‚Üí C) [category_theory.limits.has_biproduct f] (j j' : J) : category_theory.limits.biproduct.Œπ f j ‚â´ category_theory.limits.biproduct.œÄ f j' = dite (j = j') (Œª (h : j = j'), category_theory.eq_to_hom _) (Œª (h : ¬¨j = j'), 0)
(n : ‚Ñï) (Œ∏ : ‚ÑÇ) : complex.cos (‚Üën * Œ∏) = polynomial.eval (complex.cos Œ∏) (polynomial.chebyshev.T ‚ÑÇ n)
{C : Type u‚ÇÅ} [category_theory.category C] {X A : C} (f : A ‚ü∂ X) [category_theory.mono f] : category_theory.subobject X
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) : o.oangle (-x) y + o.oangle (-y) x = 0
{f : ‚ÑÇ ‚Üí ‚ÑÇ} {z : ‚ÑÇ} {R : ‚Ñù} (hd : differentiable_on ‚ÑÇ f (metric.ball 0 R)) (h_maps : set.maps_to f (metric.ball 0 R) (metric.ball 0 R)) (h‚ÇÄ : f 0 = 0) (hz : complex.abs z < R) : complex.abs (f z) ‚â§ complex.abs z
(Œ± : Type u) (Œ≤ : Type v) [add_monoid Œ±] [add_action Œ± Œ≤] : set Œ≤
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] (p q : submodule R E) (h : is_compl p q) : E ‚Üí‚Çó[R] ‚Ü•p
(C : Type v) (D : Type v') [category_theory.category C] [category_theory.concrete_category C] [category_theory.category D] [category_theory.concrete_category D] [category_theory.has_forget‚ÇÇ C D] : C ‚•§ D
{M : Type u_1} [monoid M] {f g : ‚Ñ§ ‚Üí* M} (h_neg_one : ‚áëf (-1) = ‚áëg (-1)) (h_nat : f.comp int.of_nat_hom.to_monoid_hom = g.comp int.of_nat_hom.to_monoid_hom) : f = g
 : category_theory.has_forget‚ÇÇ CommRing CommSemiRing
{G : Type u_1} [add_group G] {H K : add_subgroup G} (h : H ‚â§ K) : ‚Ü•H ‚Üí+ ‚Ü•K
{Œπ : Type v} {Œπ' : Type v'} (f : Œπ ‚Üí cardinal) (f' : Œπ' ‚Üí cardinal) (g : Œπ ‚Üí Œπ') (h : ‚àÄ (i : Œπ), (f i).lift ‚â§ (f' (g i)).lift) : (cardinal.sup f).lift ‚â§ (cardinal.sup f').lift
{R : Type u_1} [semiring R] (f : R ‚Üí+* R·µê·µí·µñ) (involution : ‚àÄ (r : R), mul_opposite.unop (‚áëf (mul_opposite.unop (‚áëf r))) = r) : ring_invo R
{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (v : ‚Ñô K V) : submodule K V
{Œ± : Type u_1} [monoid Œ±] {a b : Œ±} {u : Œ±À£} : a * ‚Üëu ‚à£ b ‚Üî a ‚à£ b
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [comm_monoid M] {s : set Œ±} {t : set Œ≤} (f : Œ± ‚Üí Œ≤ ‚Üí M) (hs : s.finite) (ht : t.finite) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), finprod (Œª (j : Œ≤), finprod (Œª (H : j ‚àà t), f i j)))) = finprod (Œª (j : Œ≤), finprod (Œª (H : j ‚àà t), finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i j))))
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] (x : E) (y : F) (H : ‚àÄ (c : R), c ‚Ä¢ x = 0 ‚Üí c ‚Ä¢ y = 0) : linear_pmap R E F
{C : Type u‚ÇÅ} [category_theory.category C] {P Q : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} (f : P ‚ü∂ Q) (x : category_theory.presieve.family_of_elements P R) : category_theory.presieve.family_of_elements Q R
{ùïú : Type u_1} {V : Type u_2} {V‚ÇÇ : Type u_4} {P : Type u_8} {P‚ÇÇ : Type u_9} [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V P] [normed_add_torsor V‚ÇÇ P‚ÇÇ] (e : P ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÇ) : P ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [linear_ordered_add_comm_monoid_with_top Œì‚ÇÄ] [comm_ring R] (v : add_valuation R Œì‚ÇÄ) {J : ideal R} (hJ : J ‚â§ v.supp) : add_valuation (R ‚ß∏ J) Œì‚ÇÄ
{x y z : pgame} (h‚ÇÅ : x.lf y) (h‚ÇÇ : y ‚â§ z) : x.lf z
{J : Type v} [category_theory.small_category J] (F : J ‚•§ SemiRing) : category_theory.limits.cone F
(Œ± : Type u_2) [preorder Œ±] : Type u_2
 : expr ‚Üí expr ‚Üí expr
(R : Type u) (S‚ÇÅ : Type v) (S‚ÇÇ : Type w) [comm_semiring R] : mv_polynomial (S‚ÇÅ ‚äï S‚ÇÇ) R ‚Üí+* mv_polynomial S‚ÇÅ (mv_polynomial S‚ÇÇ R)
{R : Type u} [ring R] {M N : Module R} (f : M ‚ü∂ N) : category_theory.limits.kernel_fork f
{Œ± : Type u_1} [lattice Œ±] [order_bot Œ±] {a : Œ±} (ha : is_atom a) : unique (finpartition a)
{L : first_order.language} {M : Type w} [L.Structure M] [h : nonempty L.constants] : nonempty M
{Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] : opens_measurable_space Œ±
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] (f : (fin 1 ‚Üí ‚ÑÇ) ‚Üí E) (c : fin 1 ‚Üí ‚ÑÇ) (R : fin 1 ‚Üí ‚Ñù) : ‚àØ (x : fin 1 ‚Üí ‚ÑÇ) in T(c, R), f x = ‚àÆ (z : ‚ÑÇ) in C(c 0, R 0), f (Œª (_x : fin 1), z)
(Œ± : Type u_3) [topological_space Œ±] : Type u_3
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} (f : J ‚Üí (X ‚ü∂ Y)) : Type (max u v)
{Œ± : Type u_1} [measurable_space Œ±] {R : Type u_2} [has_scalar R ennreal] [is_scalar_tower R ennreal ennreal] (c : R) (m : measure_theory.outer_measure Œ±) : (c ‚Ä¢ m).trim = c ‚Ä¢ m.trim
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} {x : P.last.M} {a : P.A} {f : P.last.B a ‚Üí P.last.M} (h : x.dest = ‚ü®a, f‚ü©) (f' : typevec.arrow (mvpfunctor.M.path P x) Œ±) : P.obj (Œ± ::: P.M Œ±)
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A ‚ü∂ B) (g : B ‚ü∂ C) [category_theory.limits.has_kernels V] [category_theory.limits.has_images V] [category_theory.limits.has_cokernels V] [category_theory.limits.has_equalizers V] (w : f ‚â´ g = 0) : homology f g w ‚âÖ category_theory.limits.cokernel (category_theory.limits.kernel.lift g f w)
{Fq : Type u_1} [fintype Fq] [semiring Fq] {d m : ‚Ñï} (hm : fintype.card Fq ^ d ‚â§ m) (b : polynomial Fq) (hb : b.nat_degree ‚â§ d) (A : fin m.succ ‚Üí polynomial Fq) (hA : ‚àÄ (i : fin m.succ), (A i).degree < b.degree) : ‚àÉ (i‚ÇÄ i‚ÇÅ : fin m.succ), i‚ÇÄ ‚â† i‚ÇÅ ‚àß A i‚ÇÅ = A i‚ÇÄ
{Œ± : Type u_2} [add_comm_monoid Œ±] : multiset Œ± ‚Üí Œ±
{Œ± : Type u_1} [preorder Œ±] (b : Œ±) : set Œ±
{C : Type u} [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} (F : category_theory.limits.mono_factorisation f) {Y' : C} (g : Y ‚ü∂ Y') [category_theory.mono g] : category_theory.limits.mono_factorisation (f ‚â´ g)
(h : interactive.parse (optional lean.parser.ident)) (q‚ÇÅ : interactive.parse (optional (lean.parser.tk ":" *> interactive.types.texpr))) (q‚ÇÇ : interactive.parse (optional (lean.parser.tk ":=" *> interactive.types.texpr))) : tactic unit
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] [t2_space Œ±] {s : set Œ≤} (hs : dense s) {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) (h : set.eq_on f g s) : f = g
{c : cardinal} (h : cardinal.aleph_0 ‚â§ c) : c + c = c
{ùíú : Type u_1} [category_theory.category ùíú] [category_theory.preadditive ùíú] [category_theory.limits.has_kernels ùíú] [category_theory.limits.has_images ùíú] [category_theory.limits.has_binary_biproducts ùíú] (A B : ùíú) : category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (p : X = Y) : X ‚ü∂ Y
 : ‚Ñ§ ‚âÉ ‚Ñï
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] : E ‚Üí Prop
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] : monotone finset.up_shadow
{P : pfunctor} {Œ± : Type u} (F : Œ† (X : Type u), (Œ± ‚Üí X) ‚Üí Œ± ‚Üí P.obj X) : Œ± ‚Üí P.M
{Œ± : Type u} [mul_one_class Œ±] [has_distrib_neg Œ±] (a : Œ±) : (-1) * a = -a
(R : Type u) {B : Type v} [comm_ring R] [decidable_eq B] [fintype B] : B √ó B ‚Üí free_lie_algebra R (cartan_matrix.generators B)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) {V‚ÇÇ : Type u_5} {P‚ÇÇ : Type u_6} [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] (p : Œπ ‚Üí P) (w : Œπ ‚Üí k) (hw : s.sum w = 1) (f : P ‚Üí·µÉ[k] P‚ÇÇ) : ‚áëf (‚áë(s.affine_combination p) w) = ‚áë(s.affine_combination (‚áëf ‚àò p)) w
(hs : list expr) (ns : name_set) : tactic (list bool)
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {f‚ÇÄ f‚ÇÅ f‚ÇÇ : C(X, Y)} (F : f‚ÇÄ.homotopy f‚ÇÅ) (G : f‚ÇÅ.homotopy f‚ÇÇ) : f‚ÇÄ.homotopy f‚ÇÇ
{n : ‚Ñï} (i : fin (n + 1)) {C : fin (n + 1) ‚Üí Sort u_1} (h0 : C 0) (hs : Œ† (i : fin n), C (‚áëfin.cast_succ i) ‚Üí C i.succ) : C i
{R : Type u} [comm_monoid R] [star_semigroup R] : star_module R·µê·µí·µñ R
{X Y Z : algebraic_geometry.LocallyRingedSpace} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [H : algebraic_geometry.LocallyRingedSpace.is_open_immersion f] : algebraic_geometry.LocallyRingedSpace.is_open_immersion category_theory.limits.pullback.snd
(R : Type u) (M : Type v) (N : Type w) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [add_comm_group N] [module R N] [module.free R N] [module.finite R N] : finite_dimensional.finrank R (M √ó N) = finite_dimensional.finrank R M + finite_dimensional.finrank R N
(R : Type u_1) [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (K : Type u_5) [field K] [is_domain R] [is_domain S] [algebra R K] [algebra S K] [no_zero_smul_divisors R K] [is_fraction_ring S K] [is_scalar_tower R S K] : algebra.is_algebraic R S ‚Üî algebra.is_algebraic R K
{Œ± : Type u} {Œ≤ : Type w} : buffer Œ± ‚Üí (Œ± ‚Üí Œ≤) ‚Üí buffer Œ≤
{Œ± : Type u} {s : set Œ±} (h : s.finite) : fintype ‚Ü•s
{X : Top} {C : Type u} [category_theory.category C] (F : Top.presheaf C X) : Prop
{Œ± : Type u} [preorder Œ±] (s : set Œ±) : set Œ±
{Œ± : Type u_1} [semigroup_with_zero Œ±] {a : Œ±} : 0 ‚à£ a ‚Üî a = 0
{Œ± : Type u_1} [decidable_eq Œ±] {s t : finset Œ±} (h : s ‚äÜ t) : (finset.Icc s t).card = 2 ^ (t.card - s.card)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J ‚Üí C) [category_theory.limits.has_biproduct f] {b : category_theory.limits.bicone f} (hb : b.is_bilimit) : b.X ‚âÖ ‚®Å f
 : Type (u+1)
{K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K √ó polynomial K
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F G : C ‚•§ D) : Type (max u‚ÇÅ v‚ÇÇ)
(G : pgame) : Prop
{R‚ÇÅ : Type u_1} [semiring R‚ÇÅ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] {M‚ÇÉ : Type u_7} [topological_space M‚ÇÉ] [add_comm_monoid M‚ÇÉ] {M‚ÇÑ : Type u_8} [topological_space M‚ÇÑ] [add_comm_monoid M‚ÇÑ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] [module R‚ÇÅ M‚ÇÑ] (e : M‚ÇÅ ‚âÉL[R‚ÇÅ] M‚ÇÇ) (e' : M‚ÇÉ ‚âÉL[R‚ÇÅ] M‚ÇÑ) : (M‚ÇÅ √ó M‚ÇÉ) ‚âÉL[R‚ÇÅ] M‚ÇÇ √ó M‚ÇÑ
 : Type
{Œ± : Sort u} {Œ≤ : Sort v} (a : Œ±) : Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (h : Y ‚ü∂ X) (S : category_theory.sieve X) : category_theory.sieve Y
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {G : D ‚•§ C} [category_theory.is_right_adjoint G] (A : (category_theory.adjunction.of_right_adjoint G).to_monad.algebra) : category_theory.is_reflexive_pair ((category_theory.left_adjoint G).map A.a) ((category_theory.adjunction.of_right_adjoint G).counit.app ((category_theory.left_adjoint G).obj A.A))
{C : Type u‚ÇÅ} [category_theory.category C] {P X Y Z : C} (fst : P ‚ü∂ X) (snd : P ‚ü∂ Y) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {m : measurable_space Œ±} [topological_space Œ≤] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f)
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [has_mul Œ±] [has_add Œ±] [has_le Œ±] [has_mul Œ≤] [has_add Œ≤] [has_le Œ≤] [has_mul Œ≥] [has_add Œ≥] [has_le Œ≥] (f : Œ± ‚âÉ+*o Œ≤) (g : Œ≤ ‚âÉ+*o Œ≥) : Œ± ‚âÉ+*o Œ≥
{Œ± : Type u} [group_with_zero Œ±] {a : Œ±} [invertible a] : invertible a‚Åª¬π
{S : Type u_1} [has_mul S] (a b : S) : Prop
(p : ‚Ñï) [fact (nat.prime p)] {a : ‚Ñ§} (hp : p ‚â† 2) (ha0 : ‚Üëa ‚â† 0) : zmod.legendre_sym p a = (-1) ^ (finset.filter (Œª (x : ‚Ñï), p / 2 < (‚Üëa * ‚Üëx).val) (finset.Ico 1 (p / 2).succ)).card
{n p : ‚Ñï} (hp : nat.prime p) : multiplicity p (p * n).factorial = multiplicity p n.factorial + ‚Üën
{V : Type u} {G : simple_graph V} {Œ± : Type v} (C : G.coloring Œ±) : set (set V)
{R : Type u} {S : Type v} [ring R] [ring S] (f : R ‚Üí+* S) (hf : function.bijective ‚áëf) : ideal S ‚âÉo ideal R
{M : Type u_2} [add_comm_group M] {A : Type u_5} [comm_ring A] [module A M] [decidable_eq M] {P : A ‚Üí Prop} (f : M ‚Üí‚Çó[A] M) (hb : ‚àÄ (s : finset M) (b : basis ‚Ü•s A M), P (‚áë(linear_map.to_matrix b b) f).det) (h1 : P 1) : P (‚áëlinear_map.det f)
{m : Type u_2} {Œ± : Type v} [fintype m] [has_mul Œ±] [add_comm_monoid Œ±] (v w : m ‚Üí Œ±) : Œ±
 : ereal ‚âÉo ereal·µí·µà
{M : Type u_1} [ordered_cancel_comm_monoid M] (S : submonoid M) : ordered_cancel_comm_monoid ‚Ü•S
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {R : Type u_1} [comm_semiring R] [semiring k] [algebra R k] [add_monoid G] : k ‚Üí‚Çê[R] add_monoid_algebra k G
{S : Type v} (s : S) {R : Type u_1} [comm_semiring R] [set_like S R] [subsemiring_class S R] : comm_semiring ‚Ü•s
{Œ± : Type u} (S : wseq (wseq Œ±)) : wseq Œ±
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] {f c : equiv.perm Œ±} {a : Œ±} (ha : a ‚àà c.support) (hc : c ‚àà f.cycle_factors_finset) : c = f.cycle_of a
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : affine_subspace k P) : submodule k V
{Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {s : set Œ±} (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí s ‚àà nhds_within x (set.Ioi x)) : measurable_set s
{V : Type u_1} [inner_product_space ‚Ñù V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b c d p : P} (h : euclidean_geometry.cospherical {a, b, c, d}) (hapb : euclidean_geometry.angle a p b = real.pi) (hcpd : euclidean_geometry.angle c p d = real.pi) : has_dist.dist a p * has_dist.dist b p = has_dist.dist c p * has_dist.dist d p
{C : Type u} [category_theory.category C] {A B : C} (f g : A ‚ü∂ B) [category_theory.is_coreflexive_pair f g] : B ‚ü∂ A
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} : strict_mono_on f s ‚Üí strict_anti_on (‚áëorder_dual.to_dual ‚àò f) s
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) (s : category_theory.limits.cocone F) : AddCommGroup.colimits.colimit F ‚ü∂ s.X
{R : Type u_1} [comm_ring R] : quaternion R ‚âÉ‚Çê[R] (quaternion R)·µê·µí·µñ
(K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V‚ÇÇ : Type v'} [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] (f : V ‚Üí‚Çó[K] V‚ÇÇ) (p : submodule K V) [h : finite_dimensional K ‚Ü•p] : finite_dimensional K ‚Ü•(submodule.map f p)
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b c : Œ±} : -b + a < c ‚Üí a < b + c
(Œ± : Type u_1) [cancel_monoid_with_zero Œ±] [nontrivial Œ±] : has_faithful_smul Œ±·µê·µí·µñ Œ±
(n e : expr) : tactic.norm_fin.eval_fin_m (option ‚Ñï)
{Œ± : Type u} {a b : Œ±} [mul_zero_class Œ±] [partial_order Œ±] [zero_lt.mul_pos_mono Œ±] (ha : 0 ‚â§ a) (hb : 0 ‚â§ b) : 0 ‚â§ a * b
{Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) : Type (max u_2 u_3)
{V : Type w'} (G : simple_graph V) : first_order.language.graph.Structure V
 : topological_space.positive_compacts ‚Ñù
{Œ± : Type u_1} [comm_monoid_with_zero Œ±] (p : Œ±) : Prop
{Œ± : Type u} {Œ≤ : Type v} : Œ± ‚äï Œ≤ ‚Üí Œ≤ ‚äï Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] {F G : category_theory.lax_braided_functor C D} (i : F.to_lax_monoidal_functor ‚âÖ G.to_lax_monoidal_functor) : F ‚âÖ G
(R : Type u_1) [monoid_with_zero R] : submonoid R
{Œ± : Type u_1} {t : set Œ±} (s : finset ‚Ü•t) : ‚Üë(finset.map (function.embedding.subtype (Œª (x : Œ±), x ‚àà t)) s) ‚äÜ t
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} (f : c.quotient ‚Üí+ P) : c.lift (f.comp c.mk') _ = f
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {b : M} [linear_ordered_comm_ring M] (hf : ‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚àà t) (ht : t.nonempty) (hb : t.card ‚Ä¢ b ‚â§ ‚Üë(s.card)) : ‚àÉ (y : Œ≤) (H : y ‚àà t), b ‚â§ ‚Üë((finset.filter (Œª (x : Œ±), f x = y) s).card)
 : SemiNormedGroup ‚•§ SemiNormedGroup
(Œ± : Type u_3) [h : topological_space Œ±] : Prop
{E : Type u_1} [inner_product_space ‚Ñù E] {n : ‚Ñï} (hn : 0 < n) (h : finite_dimensional.finrank ‚Ñù E = n) (x : orientation ‚Ñù E (fin n)) : (orientation.fin_orthonormal_basis hn h x).orientation = x
{C : Type u‚ÇÅ} [category_theory.category C] {M N : category_theory.comonad C} (f : ‚ÜëM ‚âÖ ‚ÜëN) (f_Œµ : ‚àÄ (X : C), f.hom.app X ‚â´ N.Œµ.app X = M.Œµ.app X) (f_Œ¥ : ‚àÄ (X : C), f.hom.app X ‚â´ N.Œ¥.app X = M.Œ¥.app X ‚â´ f.hom.app (‚ÜëM.obj X) ‚â´ ‚ÜëN.map (f.hom.app X)) : M ‚âÖ N
{G : Type u_1} [group G] {k : set G} (hcomm : ‚àÄ (x : G), x ‚àà k ‚Üí ‚àÄ (y : G), y ‚àà k ‚Üí x * y = y * x) : comm_group ‚Ü•(subgroup.closure k)
{R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] [comm_ring B] [algebra R B] [algebra A B] [is_scalar_tower R A B] (hfpA : algebra.finite_presentation R A) (hfpB : algebra.finite_presentation A B) : algebra.finite_presentation R B
{M : Type u_1} {N : Type u_2} {Œ± : Type u_6} {Œ≤ : Type u_7} [has_scalar M Œ±] [has_scalar Œ≤ Œ±] [smul_comm_class M Œ≤ Œ±] (g : N ‚Üí M) : smul_comm_class N Œ≤ Œ±
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (c : add_con M) (f : M ‚Üí+ P) (H : c ‚â§ add_con.ker f) : c.quotient ‚Üí+ P
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [preorder Œ±] [preorder Œ≤] [preorder Œ≥] [bounded_order Œ±] [bounded_order Œ≤] [bounded_order Œ≥] (f : bounded_order_hom Œ≤ Œ≥) (g : bounded_order_hom Œ± Œ≤) : bounded_order_hom Œ± Œ≥
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} {f' : ‚Ñù ‚Üí E} (hcont : continuous_on f (set.interval a b)) (hderiv : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo (linear_order.min a b) (linear_order.max a b) ‚Üí has_deriv_within_at f (f' x) (set.Ioi x) x) (hint : interval_integrable f' measure_theory.measure_space.volume a b) : ‚à´ (y : ‚Ñù) in a..b, f' y = f b - f a
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} {C : Type u_1} (g : Œ† (a : P.A), (P.drop.B a).arrow Œ± ‚Üí (P.last.B a ‚Üí P.W Œ±) ‚Üí (P.last.B a ‚Üí C) ‚Üí C) (a : P.A) (f' : (P.drop.B a).arrow Œ±) (f : P.last.B a ‚Üí P.W Œ±) : P.W_rec g (P.W_mk a f' f) = g a f' f (Œª (i : P.last.B a), P.W_rec g (f i))
{Œ± : Type u} {Œ≤ : Type v} [mul_one_class Œ±] [mul_one_class Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
(F : Type u_7) (Œ± : out_param (Type u_8)) (Œ≤ : out_param (Type u_9)) [has_sup Œ±] [has_sup Œ≤] [has_bot Œ±] [has_bot Œ≤] : Type (max u_7 u_8 u_9)
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : Top} (f : X ‚ü∂ Y) (F : Top.presheaf C Y) (x : ‚Ü•X) : F.stalk (‚áëf x) ‚âÖ (Top.presheaf.pullback_obj f F).stalk x
 : widget.component widget_override.filter_type widget_override.filter_type
{Œ± : Type u} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : set Œ±) : Prop
(R : Type u) [comm_ring R] (Œ± Œ≤ : Type u) : (Module.free R).obj Œ± ‚äó (Module.free R).obj Œ≤ ‚ü∂ (Module.free R).obj (Œ± ‚äó Œ≤)
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {A : Type u_1} [comm_semiring k] [semiring A] [algebra k A] [monoid G] : algebra k (monoid_algebra A G)
{Œ± : Type u_1} [canonically_linear_ordered_add_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b c : Œ±} [contravariant_class Œ± Œ± has_add.add has_le.le] (h : c ‚â§ a) : a - c < b - c ‚Üî a < b
 : has_coe_to_sort bool Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {s : set ùïú} [complete_space F] (h : analytic_on ùïú f s) : analytic_on ùïú (deriv f) s
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] (X : category_theory.simplicial_object C) (n : ‚Ñï) : category_theory.subobject (X.obj (opposite.op (simplex_category.mk n)))
 : tactic expr
{Œ± : Type u_1} {ùïú : Type u_14} [normed_field ùïú] {l : filter Œ±} {u v : Œ± ‚Üí ùïú} (h : u =o[l] v) : u / v * v =·∂†[l] u
{G : Type u_1} [add_group G] {S : Type u_4} [set_like S G] [hSG : add_subgroup_class S G] {H K : S} (h : H ‚â§ K) : ‚Ü•H ‚Üí+ ‚Ü•K
{Œ± : Type u_1} [circular_preorder Œ±] {a b c : Œ±} (h : has_sbtw.sbtw a b c) : ¬¨has_btw.btw c b a
(R : Type u_1) (S : Type u_2) (M : Type u_3) [semiring S] [add_comm_monoid M] [comm_semiring R] [algebra R S] [module S M] : module R (restrict_scalars R S M)
{tm : turing.fin_tm2} {l : list (tm.Œì tm.k‚ÇÄ)} {l' : option (list (tm.Œì tm.k‚ÇÅ))} {m : ‚Ñï} (h : turing.tm2_outputs_in_time tm l l' m) : turing.tm2_outputs tm l l'
 : znum ‚Üí znum
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_pullbacks C] {A : C} (f g h : category_theory.mono_over A) : (h ‚ü∂ f) ‚Üí (h ‚ü∂ g) ‚Üí (h ‚ü∂ (category_theory.mono_over.inf.obj f).obj g)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] (x y : E) : ‚Ñù
{A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] {x : B} (hx : is_integral A x) : 0 < (minpoly A x).nat_degree
(m : ‚Ñï) : list (list ‚Ñï √ó omega.term) ‚Üí list (list ‚Ñï √ó omega.term) √ó list (list ‚Ñï √ó omega.term) √ó list (list ‚Ñï √ó omega.term)
{m : Type u_3} {Œ± : Type u_5} [fintype m] [is_R_or_C Œ±] [decidable_eq m] : normed_ring (matrix m m Œ±)
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] [subsingleton M] [subsingleton M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] : unique (M ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)
{R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] [decidable_eq (module.End R M)] [is_simple_module R M] : division_ring (module.End R M)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] (F : J ‚•§ C) (G : C ‚•§ D) : category_theory.limits.cone F ‚•§ category_theory.limits.cone (F ‚ãô G)
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {R : Type u_1} [semiring k] [non_unital_non_assoc_semiring R] (f : k ‚Üí+ R) (g : G ‚Üí R) : monoid_algebra k G ‚Üí+ R
{X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {Œ≤ : Type u_1} {Œπ : Œ≤ ‚Üí Type u_3} [hŒπ : Œ† (n : Œ≤), fintype (Œπ n)] (d : ‚Ñù) (s : set X) {l : filter Œ≤} (r : Œ≤ ‚Üí ennreal) (hr : filter.tendsto r l (nhds 0)) (t : Œ† (n : Œ≤), Œπ n ‚Üí set X) (ht : ‚àÄ·∂† (n : Œ≤) in l, ‚àÄ (i : Œπ n), emetric.diam (t n i) ‚â§ r n) (hst : ‚àÄ·∂† (n : Œ≤) in l, s ‚äÜ ‚ãÉ (i : Œπ n), t n i) : ‚áë(measure_theory.measure.hausdorff_measure d) s ‚â§ l.liminf (Œª (n : Œ≤), finset.univ.sum (Œª (i : Œπ n), emetric.diam (t n i) ^ d))
(F : Type u_7) (R : out_param (Type u_8)) (S : out_param (Type u_9)) [has_mul R] [has_add R] [has_mul S] [has_add S] : Type (max u_7 u_8 u_9)
{R : Type u} [comm_ring R] (a : R) (p : polynomial R) : ‚Ñï
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : Y ‚ü∂ X) [category_theory.mono f] : galois_coinsertion (category_theory.sieve.pushforward f) (category_theory.sieve.pullback f)
{C : Type u‚ÇÅ} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : A ‚®Ø A ‚âÖ A
{t : ‚Ü•unit_interval} : t ‚â§ 1
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [category_theory.limits.has_pushout f g] [category_theory.epi g] : category_theory.epi category_theory.limits.pushout.inl
(R : Type u_1) [comm_semiring R] (M : Type u_4) (P : Type u_6) (Q : Type u_7) [add_comm_monoid M] [add_comm_monoid P] [add_comm_monoid Q] [module R M] [module R P] [module R Q] : tensor_product R (M ‚Üí‚Çó[R] P) Q ‚Üí‚Çó[R] M ‚Üí‚Çó[R] tensor_product R P Q
(step : expr ‚Üí tactic (expr √ó expr)) : expr ‚Üí tactic (expr √ó expr)
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u} [category_theory.category J] {X : J} (tX : category_theory.limits.is_initial X) (F : J ‚•§ C) : category_theory.limits.cone F
{C : Type u} [category_theory.category C] [category_theory.preadditive C] (R : Type w) [semiring R] [category_theory.linear R C] {X Y : C} (Z : C) (f : X ‚ü∂ Y) : (Y ‚ü∂ Z) ‚Üí‚Çó[R] X ‚ü∂ Z
{Œ± : Type u_1} {s : finset Œ±} {a : Œ±} [decidable_eq Œ±] : (s.erase a).card = ite (a ‚àà s) (s.card - 1) s.card
(Œ± : Type u_5) [topological_space Œ±] : Prop
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (c : category_theory.limits.cocone F) : category_theory.coyoneda.obj (opposite.op c.X) ‚ãô category_theory.ulift_functor ‚ü∂ F.cocones
{C : Type u‚ÇÅ} [category_theory.category C] (G : category_theory.comonad C) {A B : G.coalgebra} (f : A ‚ü∂ B) [category_theory.is_iso f.f] : category_theory.is_iso f
{A : Type u_4} [add_comm_monoid A] (x : A) {B : Type u_5} [add_comm_monoid B] (F : add_submonoid.localization_map.away_map x B) {C : Type u_6} [add_comm_monoid C] {g : A ‚Üí+ C} (hg : is_add_unit (‚áëg x)) : B ‚Üí+ C
{Œ± : Type u_2} [has_zero Œ±] [has_add Œ±] : has_scalar ‚Ñï (filter Œ±)
 : ‚Ñï ‚Üí pgame
{Œ± : Type u} (a : Œ±) (s : set Œ±) [decidable_eq Œ±] [fintype ‚Ü•s] : fintype ‚Ü•(has_insert.insert a s)
{G : Type u_1} [group G] (s : set G) : set G
 : Type
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] (X : C) : ùüô X = 0 ‚âÉ (X ‚âÖ 0)
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [decidable_eq Œ±] (h : ‚àÄ (a b : Œ±), ‚àÉ (c : Œ±), ‚àÄ (d : Œ±), a ‚à£ d ‚àß b ‚à£ d ‚Üî c ‚à£ d) : gcd_monoid Œ±
{A : Type u_2} [add_group A] (H : add_subgroup A) : Prop
(K : Type u_1) [field K] : subalgebra ‚Ñ§ K
{R : Type u} [semiring R] : R ‚Üí+* polynomial R
{l : filter ‚Ñù} {f g : ‚Ñù ‚Üí ‚Ñù} (hdf : ‚àÄ·∂† (x : ‚Ñù) in filter.at_bot, differentiable_at ‚Ñù f x) (hg' : ‚àÄ·∂† (x : ‚Ñù) in filter.at_bot, deriv g x ‚â† 0) (hfbot : filter.tendsto f filter.at_bot (nhds 0)) (hgbot : filter.tendsto g filter.at_bot (nhds 0)) (hdiv : filter.tendsto (Œª (x : ‚Ñù), deriv f x / deriv g x) filter.at_bot l) : filter.tendsto (Œª (x : ‚Ñù), f x / g x) filter.at_bot l
 : Compactum_to_CompHaus ‚ãô category_theory.forget CompHaus ‚âÖ Compactum.forget
{V : Type u_1} [inner_product_space ‚Ñù V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b c d p : P} (h : euclidean_geometry.cospherical {a, b, c, d}) (hapb : ‚àÉ (k‚ÇÅ : ‚Ñù), k‚ÇÅ ‚â† 1 ‚àß b -·µ• p = k‚ÇÅ ‚Ä¢ (a -·µ• p)) (hcpd : ‚àÉ (k‚ÇÇ : ‚Ñù), k‚ÇÇ ‚â† 1 ‚àß d -·µ• p = k‚ÇÇ ‚Ä¢ (c -·µ• p)) : has_dist.dist a p * has_dist.dist b p = has_dist.dist c p * has_dist.dist d p
{f : ‚Ñù ‚Üí ‚Ñù} {f' a : ‚Ñù} (h : is_local_extr f a) : has_deriv_at f f' a ‚Üí f' = 0
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ : X} (p : path x‚ÇÄ x‚ÇÅ) : (path.refl x‚ÇÅ).homotopy (p.symm.trans p)
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí ordnode Œ±
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : Œπ ‚Üí M} [semiring R] [add_comm_monoid M] [add_comm_monoid M'] [module R M] [module R M'] (f : M ‚Üí‚Çó[R] M') (hf_inj : f.ker = ‚ä•) : linear_independent R (‚áëf ‚àò v) ‚Üî linear_independent R v
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (s‚ÇÅ s‚ÇÇ : finmap Œ≤) : finmap Œ≤
(l : list ‚Ñï+) (h : ‚àÄ (p : ‚Ñï+), p ‚àà l ‚Üí p.prime) : prime_multiset
 : bool ‚Üí snum ‚Üí snum
(n : name) {Œ± : Type u} [has_to_tactic_format Œ±] (msg : Œ±) : tactic unit
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] [complete_space ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [finite_dimensional ùïú F] {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ‚ä§) : ‚àÄ·∂† (x : E) in nhds a, has_strict_fderiv_at.implicit_function f f' hf hf' (f x) (‚áë(has_strict_fderiv_at.implicit_to_local_homeomorph f f' hf hf') x).snd = x
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] (e‚ÇÅ e‚ÇÇ : topological_fiber_bundle.trivialization F proj) {b : B} (h‚ÇÅ : b ‚àà e‚ÇÅ.base_set) (h‚ÇÇ : b ‚àà e‚ÇÇ.base_set) : F ‚âÉ‚Çú F
{R : Type u_1} [comm_ring R] {n : ‚Ñï} (v : fin n ‚Üí R) : matrix (fin n) (fin n) R
(k : Type u) [field k] (n : ‚Ñï) : algebraic_closure.step k n ‚Üí+* algebraic_closure.step k (n + 1)
{F : Type u_3} [inner_product_space ‚Ñù F] (T : F ‚Üí‚Çó[‚Ñù] F) : inner_product_space.is_self_adjoint T ‚Üî bilin_form_of_real_inner.is_self_adjoint T
{R : Type u_1} {A : Type u_2} [has_zero A] (r : R) : unitization R A
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M ‚Üí+ P} (H : c ‚â§ add_con.ker f) : (c.lift f H).mrange = f.mrange
 : simplex_category ‚âå NonemptyFinLinOrd
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) [complete_space ‚Ü•K] : K·óÆ·óÆ = K
{n : ‚Ñï} (x y : bitvec n) : Prop
(b m : ‚Ñï) (hm : m ‚â† 0) : (b + 2) ^ ((b + 2).digits m).length ‚â§ (b + 2) * m
(G : Type u) [div_inv_monoid G] [measurable_space G] [has_measurable_mul‚ÇÇ G] [has_measurable_inv G] : has_measurable_pow G ‚Ñ§
(X : Type u_5) [t : topological_space X] : Prop
{Œ± : Type u_1} [has_add Œ±] [has_le Œ±] [contravariant_class Œ± Œ± has_add.add has_le.le] {a b c : Œ±} (bc : a + b ‚â§ a + c) : b ‚â§ c
(Œ± : Type u_1) : galois_insertion filter.generate filter.sets
{Œ± : Type u} {L : list (Œ± √ó bool)} [decidable_eq Œ±] : free_group.mk (free_group.reduce L) = free_group.mk L
{p a b : ‚Ñï} (hab : a.coprime b) : ‚áë((a * b).factorization) p = ‚áë(a.factorization) p + ‚áë(b.factorization) p
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [semiring k] [has_add G] : has_mul (add_monoid_algebra k G)
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {f : ‚ÑÇ ‚Üí E} {s : set ‚ÑÇ} {c : ‚ÑÇ} (hc : s ‚àà nhds_within c {c}·∂ú) (hd : differentiable_on ‚ÑÇ f s) (ho : (Œª (z : ‚ÑÇ), f z - f c) =o[nhds_within c {c}·∂ú] Œª (z : ‚ÑÇ), (z - c)‚Åª¬π) : differentiable_on ‚ÑÇ (function.update f c (lim (nhds_within c {c}·∂ú) f)) (has_insert.insert c s)
{m : Type u_3} {n : Type u_4} {Œ± : Type u_5} [fintype m] [fintype n] [normed_group Œ±] : normed_group (matrix m n Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) [h : Œ† (Y : C), unique (Y ‚ü∂ X)] : category_theory.limits.has_terminal C
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {R : ‚Ñù} {c w : ‚ÑÇ} {f : ‚ÑÇ ‚Üí E} {s : set ‚ÑÇ} (hs : s.countable) (hw : w ‚àà metric.ball c R  s) (hc : continuous_on f (metric.closed_ball c R)) (hd : ‚àÄ (x : ‚ÑÇ), x ‚àà metric.ball c R  s ‚Üí differentiable_at ‚ÑÇ f x) : ‚àÆ (z : ‚ÑÇ) in C(c, R), (z - w)‚Åª¬π ‚Ä¢ f z = (2 * ‚Üëreal.pi * complex.I) ‚Ä¢ f w
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_mul Œ±] [preorder Œ±] [preorder Œ≤] {f g : Œ≤ ‚Üí Œ±} [covariant_class Œ± Œ± has_mul.mul has_lt.lt] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_lt.lt] (hf : strict_mono f) (hg : strict_mono g) : strict_mono (Œª (x : Œ≤), f x * g x)
{k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k ‚Üí E} {a b r : k} (h : 0 < r * (b - a)) : f (‚áë(affine_map.line_map a b) r) < ‚áë(affine_map.line_map (f a) (f b)) r ‚Üî slope f a (‚áë(affine_map.line_map a b) r) < slope f a b
{G : Type u_6} {H : Type u_7} {F : Type u_8} [group G] [division_monoid H] [monoid_hom_class F G H] (f : F) (a b : G) : ‚áëf (a * b‚Åª¬π) = ‚áëf a * (‚áëf b)‚Åª¬π
(X : Type u) (Y : Type v) [metric_space X] [compact_space X] [inhabited X] [metric_space Y] [compact_space Y] [inhabited Y] : Cb X Y
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (h : Œ± ‚âÉ‚Çú Œ≤) : Œ± ‚Üí Œ≤
{Œ± : Type u_1} {c : set (set Œ±)} (hc : setoid.is_partition c) {s : set Œ±} (hs : s ‚àà c) : ‚àÉ (y : Œ±), s = {x : Œ± | (setoid.mk_classes c _).rel x y}
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [has_zero M‚ÇÅ] [add_zero_class M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) : add_zero_class M‚ÇÅ
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] : (reflection K)‚Åª¬π = reflection K
(L : first_order.language) (L' : first_order.language) : Type (max u u' v v')
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} {A : Type u_3} [semiring A] [algebra R A] {f g : clifford_algebra Q ‚Üí‚Çê[R] A} : f.to_linear_map.comp (clifford_algebra.Œπ Q) = g.to_linear_map.comp (clifford_algebra.Œπ Q) ‚Üí f = g
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f : M ‚Üí+ N) (S : add_submonoid N) : add_submonoid M
(ùïú : Type u_4) (E : Type u_5) [is_R_or_C ùïú] : Type (max u_4 u_5)
{Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (p : parser Œ±) (b : Œ≤) : parser Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_epi f] : category_theory.regular_epi f
 : onote ‚Üí string
{ùïú : Type u_3} {E : Type u_4} [normed_field ùïú] [semi_normed_group E] [normed_space ùïú E] {r : ‚Ñù} (hr : 0 < r) : absorbent ùïú (metric.ball 0 r)
 : category_theory.limits.preserves_limits_of_size (category_theory.forget CommSemiRing)
{F : Type u_1} [field F] (p q : polynomial F) (hq : q.nat_degree ‚â† 0) : polynomial.splits (algebra_map F (p.comp q).splitting_field) p
 : Type
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : Type w) [category_theory.category J] (F : C·µí·µñ ‚•§ D) [category_theory.limits.preserves_limits_of_shape J·µí·µñ F] : category_theory.limits.preserves_colimits_of_shape J F.right_op
 : Type
(k : Type u) [field k] : ideal (mv_polynomial (algebraic_closure.monic_irreducible k) k)
{M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] {f g : M ‚Üí* N} : f = g ‚Üî ‚àÄ (x : M), ‚áëf x = ‚áëg x
{x y z : pgame} : x.relabelling y ‚Üí y.relabelling z ‚Üí x.relabelling z
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape J C] : (J ‚•§ C) ‚•§ C
{C : Type u} [category_theory.category C] (J‚ÇÅ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : J‚ÇÅ.close S = ‚ä§ ‚Üî S ‚àà ‚áëJ‚ÇÅ X
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ‚Ñù P) {i‚ÇÅ i‚ÇÇ i‚ÇÉ : fin 3} (h‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ) (h‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ) (h‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ) : affine.simplex.altitude t i‚ÇÅ = affine.simplex.monge_plane t i‚ÇÇ i‚ÇÉ
{Œ± : Type u_1} {G‚ÇÄ : Type u_3} [has_zero G‚ÇÄ] [has_inv G‚ÇÄ] [topological_space G‚ÇÄ] [has_continuous_inv‚ÇÄ G‚ÇÄ] {l : filter Œ±} {f : Œ± ‚Üí G‚ÇÄ} {a : G‚ÇÄ} (hf : filter.tendsto f l (nhds a)) (ha : a ‚â† 0) : filter.tendsto (Œª (x : Œ±), (f x)‚Åª¬π) l (nhds a‚Åª¬π)
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [monoid Œ≤] : monoid Œ±
{X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s
(ùïú : Type u_1) (E : Type u_2) (F : Type u_3) [ring ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] [add_comm_group F] [module ùïú F] [topological_space F] [topological_add_group F] [has_continuous_const_smul ùïú F] : Type (max u_2 u_3)
(A : Type u_4) [add_monoid A] [topological_space A] : continuous_add_monoid_hom A A
{Œ± : Type u_1} [add_comm_group Œ±] (self : add_comm_group.total_positive_cone Œ±) : add_comm_group.positive_cone Œ±
{R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [semiring R] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] [semi_normed_group E] [semi_normed_group E‚ÇÇ] [module R E] [module R‚ÇÇ E‚ÇÇ] (e : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) : E ‚âÉ·µ¢ E‚ÇÇ
(x y : Set) : Set
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cone F} (h : category_theory.limits.is_limit t) : category_theory.yoneda.obj t.X ‚ãô category_theory.ulift_functor ‚âÖ F.cones
{Œ± : Type u_2} {Œπ : Type u_5} [comm_monoid Œ±] [fintype Œπ] (f : Œπ ‚Üí set Œ±) (a : Œ±) : a ‚àà finset.univ.prod (Œª (i : Œπ), f i) ‚Üî ‚àÉ (g : Œπ ‚Üí Œ±) (hg : ‚àÄ (i : Œπ), g i ‚àà f i), finset.univ.prod (Œª (i : Œπ), g i) = a
{R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] (a : R) (H : a ‚â† 0) (b : R) : ‚àÉ (a' b' c' : R), (‚àÄ {d : R}, d ‚à£ a' ‚Üí d ‚à£ b' ‚Üí is_unit d) ‚àß c' * a' = a ‚àß c' * b' = b
(n : ‚Ñï) : ‚Ñï √ó ‚Ñï
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] {Œ± Œ≤ : ‚Ü•(solvable_by_rad F E)} (hŒ≤ : Œ≤ ‚àà F‚üÆŒ±‚üØ) (hŒ± : solvable_by_rad.P Œ±) : solvable_by_rad.P Œ≤
{n : ‚Ñï} (c : composition n) : c.boundaries.order_emb_of_fin _ = c.boundary
{Œì : Type u_1} {R : Type u_2} [partial_order Œì] [add_monoid R] (a : Œì) : R ‚Üí+ hahn_series Œì R
(R : Type u_1) [euclidean_domain R] : gcd_monoid R
{Œπ : Type u_1} [fintype Œπ] : measure_theory.measure.hausdorff_measure ‚Üë(fintype.card Œπ) = measure_theory.measure_space.volume
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) : is_closed ‚ÜëK·óÆ
 : Top.discrete ‚ä£ category_theory.forget Top
{L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] (f : L.equiv M N) : L.equiv N M
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] (self : category_theory.oplax_functor B C) : category_theory.prelax_functor B C
{m : Type u ‚Üí Type v} [applicative m] {Œ± : Type u_1} {Œ≤ : Type u} (f : ‚Ñï ‚Üí Œ± ‚Üí m Œ≤) (start : ‚Ñï) (as : list Œ±) : m (list Œ≤)
{R : Type u} {n : ‚Ñï} {M : fin n.succ ‚Üí Type w} {M‚ÇÇ : Type w‚ÇÇ} [semiring R] [Œ† (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : fin n.succ), module R (M i)] [module R M‚ÇÇ] [Œ† (i : fin n.succ), topological_space (M i)] [topological_space M‚ÇÇ] (f : continuous_multilinear_map R M M‚ÇÇ) (m : Œ† (i : fin n), M i.succ) (x y : M 0) : ‚áëf (fin.cons (x + y) m) = ‚áëf (fin.cons x m) + ‚áëf (fin.cons y m)
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : seq Œ± ‚Üí seq Œ≤ ‚Üí seq Œ≥
(M : Type u_10) (A : Type u_11) [monoid M] [add_monoid A] : Type (max u_10 u_11)
(P : (Type u)·µí·µñ ‚•§ Type u) (Œ± : Type u) (s : P.obj (opposite.op Œ±)) (x : Œ±) : P.obj (opposite.op punit)
{L R : Type v} {fst snd : L ‚Üí R} {A B C : category_theory.limits.walking_multispan fst snd} (f : A.hom B) (g : B.hom C) : A.hom C
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type v‚ÇÅ} [category_theory.small_category J] {K : J ‚•§ C} (F : C ‚•§ D) (c : category_theory.limits.cone K) {X : D} (f : X ‚ü∂ F.obj c.X) : category_theory.limits.cone (category_theory.structured_arrow_cone.to_diagram (F.map_cone c) ‚ãô category_theory.structured_arrow.map f ‚ãô category_theory.structured_arrow.pre X K F)
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (A : category_theory.mono_over X) : category_theory.subobject.representative.obj ((category_theory.to_thin_skeleton (category_theory.mono_over X)).obj A) ‚âÖ A
 : PartialFun ‚•§ Pointed
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} {s : affine.simplex ‚Ñù P (n + 2)} {i‚ÇÅ : fin (n + 3)} {p : P} (h : ‚àÄ (i‚ÇÇ : fin (n + 3)), i‚ÇÅ ‚â† i‚ÇÇ ‚Üí p ‚àà s.monge_plane i‚ÇÅ i‚ÇÇ) : p = s.monge_point
{Œì : Type u_1} [inhabited Œì] (l : turing.list_blank Œì) : Œì
(n : Type u_3) (R : Type u_6) [fintype n] [add_comm_monoid R] : matrix n n R ‚Üí+ R
{R : Type u_1} [comm_monoid_with_zero R] (n : R) : Prop
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] : has_involutive_neg (module.ray R M)
{Œ± : Type u_1} {a b c : Œ±} [linear_order Œ±] [add_comm_semigroup Œ±] [has_sub Œ±] [has_ordered_sub Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] (h : a - b < a - c) : c < b
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [preorder Œπ] [Œ† (i : Œπ), partial_order (Œ± i)] : partial_order (Œ£‚Çó (i : Œπ), Œ± i)
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.final] {E : Type u} [category_theory.category E] {G : D ‚•§ E} (t : category_theory.limits.cocone G) : category_theory.limits.is_colimit (category_theory.limits.cocone.whisker F t) ‚âÉ category_theory.limits.is_colimit t
(x : Class) : set Class
{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L} : ‚áëlinear_map.det (‚áë(algebra.lmul K L) x) = 0 ‚Üî x = 0
(R : Type u) [ring R] : subring R
 : list expr ‚Üí list (expr √ó expr) ‚Üí list (option expr) √ó list (expr √ó expr)
{C : Type u} [category_theory.category C] {J‚ÇÅ J‚ÇÇ : category_theory.grothendieck_topology C} : J‚ÇÅ = J‚ÇÇ ‚Üî ‚àÄ (P : C·µí·µñ ‚•§ Type (max v u)), category_theory.presieve.is_sheaf J‚ÇÅ P ‚Üî category_theory.presieve.is_sheaf J‚ÇÇ P
{p : ‚Ñï} : padic_val_nat p 1 = 0
(fs : list (option string)) : tactic (name_map declaration)
{Œ± : Sort u} {Œ≤ : Sort v} (P : Œ≤ ‚Üí Sort w) (e : Œ± ‚âÉ Œ≤) : (Œ† (a : Œ±), P (‚áëe a)) ‚âÉ Œ† (b : Œ≤), P b
 : widget.component tactic_state empty
{Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : upper_semicontinuous_on f s) (hg : upper_semicontinuous_on g s) (hcont : ‚àÄ (x : Œ±), x ‚àà s ‚Üí continuous_at (Œª (p : Œ≥ √ó Œ≥), p.fst + p.snd) (f x, g x)) : upper_semicontinuous_on (Œª (z : Œ±), f z + g z) s
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} {F : Top.presheaf C X} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) {G : Top.presheaf C X} (Œ± : F ‚âÖ G) : Top.presheaf.sheaf_condition_equalizer_products.fork F U ‚âÖ (category_theory.limits.cones.postcompose (Top.presheaf.sheaf_condition_equalizer_products.diagram.iso_of_iso U Œ±).inv).obj (Top.presheaf.sheaf_condition_equalizer_products.fork G U)
{Œ± : Sort u_1} {p : Œ± ‚Üí Prop} (x : subtype p) : p ‚Üëx
{Œ± : Type u_3} {Œ≤ : Type u_4} [linear_ordered_field Œ±] {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±} {r : Œ±} (hr : r < 0) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (Œª (x : Œ≤), f x * r) l filter.at_top
 : Type
{C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] (S : J.cover X) (P : C·µí·µñ ‚•§ D) : category_theory.limits.multicospan_index D
{Œπ : Type u_1} {E : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), topological_space (E i)] [encodable Œπ] [‚àÄ (i : Œπ), topological_space.second_countable_topology (E i)] : topological_space.second_countable_topology (Œ£ (i : Œπ), E i)
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} : L.bounded_formula Œ± n ‚Üí list ((Œ£ (k : ‚Ñï), L.term (Œ± ‚äï fin k)) ‚äï (Œ£ (n : ‚Ñï), L.relations n) ‚äï ‚Ñï)
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream (generalized_continued_fraction.pair K)
{Œ± Œ≤ : NonemptyFinLinOrd} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (Œ± : F ‚ü∂ G) : G.op ‚ü∂ F.op
{G : Type u_1} [group G] : complete_lattice (subgroup G)
(C : Type u) [category_theory.category C] : Prop
{Œ± : Type u_1} [decidable_eq Œ±] : ‚Ü•(derangements (option Œ±)) ‚âÉ Œ£ (a : Œ±), ‚Ü•(derangements ‚Ü•{a}·∂ú) ‚äï ‚Ü•(derangements Œ±)
(C : Type u) [category_theory.category C] : Type u
(G : Type u) [category_theory.groupoid G] [category_theory.is_connected G] [is_free_groupoid G] (r : G) : quiver.rooted_connected (symgen r)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} {n : ‚Ñï+} (data : bucket_array Œ± Œ≤ n) : list (Œ£ (a : Œ±), Œ≤ a)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cone F} (h : category_theory.limits.is_limit t) (s : category_theory.limits.cone F) : s ‚ü∂ t
{M : Type u_1} [has_mul M] : has_le (con M)
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [preorder Œ±] [preorder Œ≤] [preorder Œ≥] : (Œ± ‚Üío Œ≤) ‚Üío (Œ± ‚Üío Œ≥) ‚Üío Œ± ‚Üío Œ≤ √ó Œ≥
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [Œ† (i : Œπ), add_group (Œ≤ i)] : has_scalar ‚Ñ§ (Œ†‚ÇÄ (i : Œπ), Œ≤ i)
 : tactic unit
{G : Type u_1} [group G] (H : subgroup G) : Prop
 : distrib_lattice Prop
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] : ideal S ‚Ü™o ideal R
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop} (f : initial_seg r s) (g : initial_seg s t) : initial_seg r t
(Œ± : Type u) : Type u
{X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ‚àÉ (f : bounded_continuous_function X ‚Ñù), set.eq_on ‚áëf 0 s ‚àß set.eq_on ‚áëf 1 t ‚àß ‚àÄ (x : X), ‚áëf x ‚àà set.Icc 0 1
(X : Profinite) : X ‚âÖ (Profinite.limit_cone X.diagram).X
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} (x : Œ±) (H : ‚àÄ (y : Œ±), y ‚àà s ‚Üí (‚àÉ (t : set Œ±) (H : t ‚äÜ s), x ‚àà t ‚àß y ‚àà t ‚àß is_preconnected t)) : is_preconnected s
{x : pgame} : x ‚â§ 0 ‚Üî ‚àÄ (i : x.left_moves), ‚àÉ (j : (x.move_left i).right_moves), (x.move_left i).move_right j ‚â§ 0
{E : Type u_1} [add_comm_group E] [module ‚Ñù E] [topological_space E] [has_continuous_smul ‚Ñù E] {F : Type u_2} [add_comm_group F] [module ‚Ñù F] [topological_space F] [has_continuous_smul ‚Ñù F] [t2_space F] (e : E ‚âÉ+ F) (h‚ÇÅ : continuous ‚áëe) (h‚ÇÇ : continuous ‚áë(e.symm)) : E ‚âÉL[‚Ñù] F
(r : ‚Ñö) : ‚Ñö
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) {r : ‚Ñù} (hr : 0 < r) : o.oangle x (r ‚Ä¢ y) = o.oangle x y
{Œ± : Type u} [pseudo_metric_space Œ±] {f : Œ± ‚Üí ‚Ñù} (K : nnreal) (h : ‚àÄ (x y : Œ±), f x ‚â§ f y + ‚ÜëK * has_dist.dist x y) : lipschitz_with K f
(p : ‚Ñï) {idx : Type u_2} [hp : fact (nat.prime p)] (Œ¶ : mv_polynomial idx ‚Ñö) (n : ‚Ñï) : mv_polynomial (idx √ó ‚Ñï) ‚Ñö
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P (n + 2)) {i‚ÇÅ i‚ÇÇ : fin (n + 3)} : s.monge_point ‚àà s.monge_plane i‚ÇÅ i‚ÇÇ
 : expr ‚Üí tactic expr
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : ray_of_ne_zero R x.some_vector _ = x
{Œ± : Type u} [t : topological_space Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_1} (s : Œπ ‚Üí set Œ±) (H : ‚àÄ (i : Œπ), is_open (s i)) : ‚àÉ (T : set Œπ), T.countable ‚àß (‚ãÉ (i : Œπ) (H : i ‚àà T), s i) = ‚ãÉ (i : Œπ), s i
(p : ‚Ñï) [hp : fact (nat.prime p)] (n : ‚Ñï) {m : ‚Ñï} (hm : n ‚â§ m) : (truncated_witt_vector.truncate hm).comp (truncated_witt_vector.zmod_equiv_trunc p m).to_ring_hom = (truncated_witt_vector.zmod_equiv_trunc p n).to_ring_hom.comp (zmod.cast_hom _ (zmod (p ^ n)))
(A B : Top) : ‚Ü•(fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (‚Ü•A √ó ‚Ü•B))) ‚•§ ‚Ü•(fundamental_groupoid.fundamental_groupoid_functor.obj B)
(pr : tactic.proof_state) (tac : tactic unit) : tactic bool
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : add_submonoid A
 : lean.parser (tactic.list_Pi tactic.rcases_patt ‚äï ‚Ñï)
{J : Type v} {C : Type u} [category_theory.category C] {F : category_theory.limits.walking_parallel_family J ‚•§ C} (t : category_theory.limits.cotrident (Œª (j : J), F.map (category_theory.limits.walking_parallel_family.hom.line j))) : category_theory.limits.cocone F
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (s : set Œ±) : continuous (Œª (F : C(Œ±, Œ≤)), continuous_map.restrict s F)
{R : Type u_2} {M‚ÇÅ : Type u_5} {M‚ÇÇ : Type u_6} [ring R] [add_comm_group M‚ÇÅ] [add_comm_group M‚ÇÇ] [module R M‚ÇÅ] [module R M‚ÇÇ] (Q‚ÇÅ : quadratic_form R M‚ÇÅ) (Q‚ÇÇ : quadratic_form R M‚ÇÇ) : Type (max u_5 u_6)
(C : Type u) : Type u
{R : Type u_3} {M : Type u_5} [ring R] [add_comm_group M] [module R M] {n : ‚Ñï} {N : submodule R M} (y : M) (b : basis (fin n) R ‚Ü•N) (hli : ‚àÄ (c : R) (x : M), x ‚àà N ‚Üí c ‚Ä¢ y + x = 0 ‚Üí c = 0) (hsp : ‚àÄ (z : M), ‚àÉ (c : R), z + c ‚Ä¢ y ‚àà N) : basis (fin (n + 1)) R M
{C : Type u} [category_theory.category C] (X : C) : Type (max u v)
{Œ± : Type u_1} {n : ‚Ñï} (v : vector3 Œ± n.succ) : Œ±
{n : Type u_1} {ùïú : Type u_3} [field ùïú] [decidable_eq n] [fintype n] (M : matrix n n ùïú) : ‚àÉ (L L' : list (matrix.transvection_struct n ùïú)) (D : n ‚Üí ùïú), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
{Œ± : Type u} (s : computation Œ±) (a : Œ±) (n : ‚Ñï) : Prop
{m : Type u_2} {n : Type u_3} {Œ± : Type v} (M : matrix m n Œ±) (i : m) (j : n) : M.transpose j i = M i j
(G‚ÇÄ : Type u_4) : Type u_4
{Œπ : Type v} [dec_Œπ : decidable_eq Œπ] (Œ≤ : Œπ ‚Üí Type w) [Œ† (i : Œπ), add_comm_monoid (Œ≤ i)] (i : Œπ) : Œ≤ i ‚Üí+ direct_sum Œπ (Œª (i : Œπ), Œ≤ i)
{Œ± : Type u_1} (P : Œ± ‚Üí Prop) : Type u_1
{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G) : continuous (Œª (h : G), g + h + -g)
(C : Type u) [category_theory.category C] : Prop
{Œ± : Type u} {Œ≤ : Type v} [monoid Œ±] [monoid Œ≤] (f : Œ± ‚Üí* Œ≤) : category_theory.single_obj Œ± ‚•§ category_theory.single_obj Œ≤
{M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] : has_one (M ‚Üí* N)
(Œ± : Type u_1) [uniform_space Œ±] : Œ± ‚âÉ·µ§ Œ±
 : ‚Ñù ‚Üí‚Çê[‚Ñù] ‚ÑÇ
{M : Type u_1} [add_comm_monoid M] (a b : ‚Ñï) (f : ‚Ñï ‚Üí ‚Ñï ‚Üí M) : (finset.Ico a b).sum (Œª (i : ‚Ñï), (finset.Ico i b).sum (Œª (j : ‚Ñï), f i j)) = (finset.Ico a b).sum (Œª (j : ‚Ñï), (finset.Ico a (j + 1)).sum (Œª (i : ‚Ñï), f i j))
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ‚Ñù P) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : ‚áë(euclidean_geometry.orthogonal_projection s) ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p) = ‚áë(euclidean_geometry.orthogonal_projection s) p
(R : Type u_1) {B : Type u_3} [nondiscrete_normed_field R] [topological_space B] (F‚ÇÅ : Type u_6) [normed_group F‚ÇÅ] [normed_space R F‚ÇÅ] (E‚ÇÅ : B ‚Üí Type u_7) [topological_space (bundle.total_space E‚ÇÅ)] [Œ† (x : B), add_comm_monoid (E‚ÇÅ x)] [Œ† (x : B), module R (E‚ÇÅ x)] (F‚ÇÇ : Type u_8) [normed_group F‚ÇÇ] [normed_space R F‚ÇÇ] (E‚ÇÇ : B ‚Üí Type u_9) [topological_space (bundle.total_space E‚ÇÇ)] [Œ† (x : B), add_comm_monoid (E‚ÇÇ x)] [Œ† (x : B), module R (E‚ÇÇ x)] [Œ† (x : B), topological_space (E‚ÇÅ x)] [Œ† (x : B), topological_space (E‚ÇÇ x)] [topological_vector_bundle R F‚ÇÅ E‚ÇÅ] [topological_vector_bundle R F‚ÇÇ E‚ÇÇ] : topological_vector_bundle R (F‚ÇÅ √ó F‚ÇÇ) (Œª (x : B), E‚ÇÅ x √ó E‚ÇÇ x)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] (s : submodule K V) : finite_dimensional.finrank K (V ‚ß∏ s) ‚â§ finite_dimensional.finrank K V
(h : name) (p : expr) (tac‚ÇÄ : tactic unit) : tactic (expr √ó list expr)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] (x : Œ± √ó Œ≤) : filter.map prod.snd (nhds_within x (prod.fst ‚Åª¬π' {x.fst})) = nhds x.snd
{Y Z : Type u} (g h : Y ‚ü∂ Z) : category_theory.limits.equalizer g h ‚âÖ {x // g x = h x}
(Œ± : Type u_1) [comm_semiring Œ±] : Type u_1
(h : name) : tactic unit
(X : Type u_1) [fintype X] : Fintype
{n : ‚Ñï} {Œ± : typevec (n + 1)} : (Œ±.drop ::: Œ±.last).arrow Œ±
{Œ± : Type u_1} {Œ≥ : Œ± ‚Üí Type u_3} [encodable Œ±] [Œ† (a : Œ±), encodable (Œ≥ a)] (n : ‚Ñï) : option (sigma Œ≥)
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {s t : set Œ±} (hst : disjoint (s ‚à© function.support f) (t ‚à© function.support f)) (hs : (s ‚à© function.support f).finite) (ht : (t ‚à© function.support f).finite) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s ‚à™ t), f i)) = finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)) + finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà t), f i))
{K : Type u_1} {g : generalized_continued_fraction K} {n : ‚Ñï} [division_ring K] {gp : generalized_continued_fraction.pair K} {ppredB predB : K} (succ_nth_s_eq : g.s.nth (n + 1) = option.some gp) (nth_denom_eq : g.denominators n = ppredB) (succ_nth_denom_eq : g.denominators (n + 1) = predB) : g.denominators (n + 2) = gp.b * predB + gp.a * ppredB
 : tactic unit
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (ùïú' : Type u_10) [normed_ring ùïú'] [normed_algebra ùïú ùïú'] : ùïú' ‚ÜíL[ùïú] ùïú' ‚ÜíL[ùïú] ùïú' ‚ÜíL[ùïú] ùïú'
 : ‚Ñ§ ‚Üí tactic expr
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] (s : set Œ±) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), 1)) = 1
{M : Type u_1} [add_monoid M] {x : M} : 0 ‚àà multiples x
(x y : ‚Ñù) [fact (x < y)] : charted_space (euclidean_half_space 1) ‚Ü•(set.Icc x y)
{Œ± : Type u_1} [semigroup Œ±] (x y : Œ±) : has_mul.mul x ‚àò has_mul.mul y = has_mul.mul (x * y)
{Œ± : Type u_1} : multiset Œ± ‚Üí+ ‚Ñï
{X : Type u_1} [topological_space X] : compact_space (alexandroff X)
{n : ‚Ñï} (p : fin (n + 1)) : set.range ‚áë(p.succ_above) = {p}·∂ú
{ùïú : Type u_1} {F : Type u_3} [is_R_or_C ùïú] [add_comm_group F] [module ùïú F] (c : inner_product_space.core ùïú F) : inner_product_space ùïú F
{G‚ÇÄ : Type u_2} [group_with_zero G‚ÇÄ] (a : G‚ÇÄ) : a / (a / a) = a
{X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y) : path x y
(G : Type u) [group G] (F : Type v) [field F] [mul_semiring_action G F] [fintype G] (x : F) : polynomial ‚Ü•(fixed_points.subfield G F)
(Œ± : Type u_1) (M : Type u_2) (R : Type u_5) [semiring R] [add_comm_monoid M] [module R M] (v : Œ± ‚Üí M) : (Œ± ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] M
 : Type (u+1)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C·µí·µñ ‚•§ D·µí·µñ} (Œ± : F ‚ü∂ G) : G.unop ‚ü∂ F.unop
{O : ordinal} : ‚Ü•(set.Iio O) ‚âÉ (nim O).right_moves
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (s‚ÇÅ s‚ÇÇ : finmap Œ≤) : Prop
{x : pgame} {xl' xr' : Type u_1} (el : x.left_moves ‚âÉ xl') (er : x.right_moves ‚âÉ xr') : x.relabelling (pgame.relabel el er)
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} {F' : K ‚•§ D} (G : category_theory.limits.cocone F ‚•§ category_theory.limits.cocone F') [category_theory.limits.reflects_colimit (category_theory.functor.empty (category_theory.limits.cocone F)) G] {c : category_theory.limits.cocone F} (hc : category_theory.limits.is_colimit (G.obj c)) : category_theory.limits.is_colimit c
(k : Type u_1) {P‚ÇÅ : Type u_2} {V‚ÇÅ : Type u_6} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] (p : P‚ÇÅ) : P‚ÇÅ ‚âÉ·µÉ[k] V‚ÇÅ
(X : Type u_2) [topological_space X] : Type u_2
{G : Type u_1} [add_group G] (s : set G) : set G
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} : clifford_algebra Q ‚Üí‚Çê[R] clifford_algebra Q
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] (F : J ‚•§ K ‚•§ C) (c : Œ† (k : K), category_theory.limits.colimit_cocone (F.flip.obj k)) (k : K) : ((category_theory.evaluation K C).obj k).map_cocone (category_theory.limits.combine_cocones F c) ‚âÖ (c k).cocone
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) : category_theory.limits.cocone F
{M : Type u_1} [comm_semigroup M] {A : Type u_2} [set_like A M] [mul_mem_class A M] (S : A) : comm_semigroup ‚Ü•S
(X : Type u_1) {ùïú : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [topological_space X] [compact_space X] [nondiscrete_normed_field ùïú] [normed_group Œ≤] [normed_space ùïú Œ≤] [normed_group Œ≥] [normed_space ùïú Œ≥] (g : Œ≤ ‚ÜíL[ùïú] Œ≥) : C(X, Œ≤) ‚ÜíL[ùïú] C(X, Œ≥)
(Œ± : Type u_1) [measurable_space Œ±] : Œ± ‚âÉ·µê Œ±
{Œ± : Type u} (t : ordnode Œ±) : ordnode (ordnode Œ±)
 : Mon ‚•§ category_theory.Cat
{Œ± : Sort u_1} {Œ≤ : Sort u_2} [nonempty Œ≤] (f : Œ± ‚Üí Œ≤) : Œ≤
(Œ± : Type u_1) : Type u_1
{R : Type u} [semiring R] (n : ‚Ñï) : R ‚Üí‚Çó[R] polynomial R
{M : Type u_1} [add_monoid M] (P : add_submonoid M) : Prop
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : closed_embedding f) : filter.tendsto f (filter.cocompact Œ±) (filter.cocompact Œ≤)
 : tactic unit
{Œ± : Type u_1} (G : simple_graph Œ±) (n : ‚Ñï) (s : finset Œ±) : Prop
{R' : Type u_1} {Œ± : Type u_2} [non_assoc_semiring R'] [has_scalar R' Œ±] (S : subsemiring R') : has_scalar ‚Ü•S Œ±
 : Type
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [unique Œ±À£] : associates Œ± ‚âÉ* Œ±
{L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] (hnp : L.equiv N P) (hmn : L.equiv M N) : L.equiv M P
{ùïú : Type u_1} [linear_ordered_field ùïú] {s : set ùïú} {f : ùïú ‚Üí ùïú} : concave_on ùïú s f ‚Üî convex ùïú s ‚àß ‚àÄ ‚¶Éx y z : ùïú‚¶Ñ, x ‚àà s ‚Üí z ‚àà s ‚Üí x < y ‚Üí y < z ‚Üí (f z - f y) / (z - y) ‚â§ (f y - f x) / (y - x)
{p : ‚Ñù} : summable (Œª (n : ‚Ñï), 1 / ‚Üën ^ p) ‚Üî 1 < p
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_comm_monoid N] {f g : Œ± ‚Üí‚ÇÄ M} {h : Œ± ‚Üí M ‚Üí N} (h_zero : ‚àÄ (a : Œ±), h a 0 = 0) (h_add : ‚àÄ (a : Œ±) (b‚ÇÅ b‚ÇÇ : M), h a (b‚ÇÅ + b‚ÇÇ) = h a b‚ÇÅ + h a b‚ÇÇ) : (f + g).sum h = f.sum h + g.sum h
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] (x : Œ± √ó Œ≤) : filter.map prod.fst (nhds_within x (prod.snd ‚Åª¬π' {x.snd})) = nhds x.fst
{G : Type u_1} [group G] {H : subgroup G} {N : Type u_3} [group N] (f : N ‚Üí* G) : subgroup.comap f H.normalizer ‚â§ (subgroup.comap f H).normalizer
(q : interactive.parse interactive.types.texpr) (locs : interactive.parse interactive.types.location) (lem : interactive.parse (optional (lean.parser.tk "using" *> interactive.types.texpr))) : tactic unit
 : tactic.eliminate.constructor_argument_naming_rule
{n : ‚Ñï} (c : composition n) {i‚ÇÅ i‚ÇÇ : fin c.length} (h : i‚ÇÅ ‚â† i‚ÇÇ) : disjoint (set.range ‚áë(c.embedding i‚ÇÅ)) (set.range ‚áë(c.embedding i‚ÇÇ))
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (m : hash_map Œ± Œ≤) (a : Œ±) : option (Œ≤ a)
 : Pointed_to_Twop_fst ‚ä£ category_theory.forget‚ÇÇ Twop Bipointed ‚ãô Bipointed_to_Pointed_fst
{G : Type u_10} [add_group G] : G ‚âÉ+ add_units G
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [linear_ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : strict_convex_on ùïú s f) {x y z : E} (hx : x ‚àà s) (hy : y ‚àà s) (hxy : x ‚â† y) (hz : z ‚àà open_segment ùïú x y) : f z < linear_order.max (f x) (f y)
{Œ± : Type u} [topological_space Œ±] (s : set Œ±) : Prop
{K : Type u} (V : Type v) [division_ring K] [add_comm_group V] [module K V] (V‚ÇÇ : Type v') [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] [finite_dimensional K V] [finite_dimensional K V‚ÇÇ] (cond : finite_dimensional.finrank K V = finite_dimensional.finrank K V‚ÇÇ) : V ‚âÉ‚Çó[K] V‚ÇÇ
{R : Type u} {M : Type v} {M‚ÇÇ : Type w} {M‚ÇÉ : Type y} {M‚ÇÑ : Type z} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [add_comm_monoid M‚ÇÑ] {module_M : module R M} {module_M‚ÇÇ : module R M‚ÇÇ} {module_M‚ÇÉ : module R M‚ÇÉ} {module_M‚ÇÑ : module R M‚ÇÑ} (e‚ÇÅ : M ‚âÉ‚Çó[R] M‚ÇÇ) (e‚ÇÇ : M‚ÇÉ ‚âÉ‚Çó[R] M‚ÇÑ) : (M √ó M‚ÇÉ) ‚âÉ‚Çó[R] M‚ÇÇ √ó M‚ÇÑ
{G : Type u_1} [add_group G] [fintype G] (S : set G) (hS1 : S.nonempty) (hS2 : S + S = S) : add_subgroup G
{Œ± : Type u_1} {Œ≤ : Type u_3} {C : set (set Œ±)} {D : set (set Œ≤)} (hC : is_countably_spanning C) (hD : is_countably_spanning D) : is_countably_spanning (set.image2 has_set_prod.prod C D)
 : category_theory.monad Meas
{Œ± : Type u} {f g : filter Œ±} (h : ‚àÄ (s : set Œ±), s·∂ú ‚àà f ‚Üî s·∂ú ‚àà g) : f = g
{C : Type u‚ÇÅ} [category_theory.category C] (D : category_theory.glue_data C) [category_theory.limits.has_multicoequalizer D.diagram] (i : D.J) : D.U i ‚ü∂ D.glued
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (f : module.End R M) : Prop
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M ‚Üí+ N} (hf : ‚àÄ (y : ‚Ü•S), is_add_unit (‚áëf ‚Üëy)) {y z : ‚Ü•S} (h : -‚áë(is_add_unit.lift_right (f.restrict S) hf) y = -‚áë(is_add_unit.lift_right (f.restrict S) hf) z) : ‚áëf ‚Üëy = ‚áëf ‚Üëz
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí option Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C·µí·µñ ‚•§ D} [category_theory.faithful F] : category_theory.faithful F.right_op
(Œ± : Type u_1) [topological_space Œ±] : Œ± √ó punit ‚âÉ‚Çú Œ±
(R : Type u) [ring R] [strong_rank_condition R] {Œπ : Type v} [fintype Œπ] {M : Œπ ‚Üí Type w} [Œ† (i : Œπ), add_comm_group (M i)] [Œ† (i : Œπ), module R (M i)] [‚àÄ (i : Œπ), module.free R (M i)] : module.rank R (Œ† (i : Œπ), M i) = cardinal.sum (Œª (i : Œπ), module.rank R (M i))
(x : pgame) : (x * 0).relabelling 0
(n : ‚Ñï) : ‚àë' (i : ‚Ñï), ite (n ‚â§ i) (2‚Åª¬π ^ i) 0 = 2 * 2‚Åª¬π ^ n
{l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {Œ± : Type u_12} [has_zero Œ±] (A : matrix (n ‚äï o) (l ‚äï m) Œ±) : Prop
{R : Type u} [semiring R] : R ‚Üí polynomial R ‚Üí R
(Œ± : Type u) (Œ≤ : Type v) [monoid Œ±] [monoid Œ≤] : (Œ± ‚Üí* Œ≤) ‚âÉ category_theory.single_obj Œ± ‚•§ category_theory.single_obj Œ≤
 : tactic.rewrite_search.edge ‚Üí format
{X Y : CommMon} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ* ‚Ü•Y
(Œ≥ : Type u) : W_type.list_Œ± Œ≥ ‚Üí Type u
{J : Type v} {C : Type u} [category_theory.category C] (B : C) (objs : J ‚Üí C) (arrows : Œ† (j : J), objs j ‚ü∂ B) : Prop
 : tactic unit
{Œ± : Type u_1} [partial_order Œ±] (c : closure_operator Œ±) : c.closed = set.range ‚áëc
(R : Type u_1) [comm_semiring R] (X : Type u_2) {A : Type u_3} [semiring A] [algebra R A] (f : X ‚Üí A) : free_algebra.pre R X ‚Üí A
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ‚àà S ‚Üí y ‚àà S ‚Üí x / y ‚àà S
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) : Type (max v u)
{Œ± : Type u} {Œ≤ : Type w} {m : Type w ‚Üí Type u_1} [monad m] (b : buffer Œ±) (f : Œ± ‚Üí m Œ≤) : m (buffer Œ≤)
(Œ± : Type u_1) (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_preorder Œ± r] : Type u_1
{a b c m : ‚Ñï} (hm : 0 < m) (h : c * a ‚â° c * b [MOD m]) : a ‚â° b [MOD m / m.gcd c]
{L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] : L.equiv M N ‚Üí L.hom M N
{C : Type u‚ÇÅ} [category_theory.category C] {X‚ÇÅ‚ÇÅ X‚ÇÅ‚ÇÇ X‚ÇÇ‚ÇÅ X‚ÇÇ‚ÇÇ X‚ÇÉ‚ÇÅ X‚ÇÉ‚ÇÇ : C} {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÉ‚ÇÅ : X‚ÇÉ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÇ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ} {v‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÅ} {v‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÉ‚ÇÇ} (s : category_theory.is_pullback h‚ÇÅ‚ÇÅ (v‚ÇÅ‚ÇÅ ‚â´ v‚ÇÇ‚ÇÅ) (v‚ÇÅ‚ÇÇ ‚â´ v‚ÇÇ‚ÇÇ) h‚ÇÉ‚ÇÅ) (p : h‚ÇÅ‚ÇÅ ‚â´ v‚ÇÅ‚ÇÇ = v‚ÇÅ‚ÇÅ ‚â´ h‚ÇÇ‚ÇÅ) (t : category_theory.is_pullback h‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÇ h‚ÇÉ‚ÇÅ) : category_theory.is_pullback h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] {t : category_theory.limits.cotrident f} {Z Z' : C} (q : Z ‚ü∂ Z') (ht : category_theory.limits.is_colimit t) (k : t.X ‚ü∂ Z) : ‚Üë(‚áë(category_theory.limits.cotrident.is_colimit.hom_iso ht Z') (k ‚â´ q)) = ‚Üë(‚áë(category_theory.limits.cotrident.is_colimit.hom_iso ht Z) k) ‚â´ q
{G : Type w} [topological_space G] [add_group G] [has_continuous_add G] (a : G) : G ‚âÉ‚Çú G
{X Y : Compactum} (f : X ‚ü∂ Y) : continuous ‚áëf
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} : (Œ± ‚äï Œ≤ ‚Ü™ Œ≥) ‚âÉ Œ£ (f : Œ± ‚Ü™ Œ≥), Œ≤ ‚Ü™ ‚Ü•(set.range ‚áëf)·∂ú
 : ‚Ñù
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] {M N : submodule R A} {C : Œ† (r : A), r ‚àà M * N ‚Üí Prop} (hm : ‚àÄ (m : A) (H : m ‚àà M) (n : A) (H_1 : n ‚àà N), C (m * n) _) (ha : ‚àÄ (x : A) (hx : x ‚àà M * N) (y : A) (hy : y ‚àà M * N), C x hx ‚Üí C y hy ‚Üí C (x + y) _) {r : A} (hr : r ‚àà M * N) : C r hr
{R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [topological_space M] [topological_space M‚ÇÇ] [semiring R] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] [add_comm_monoid M] [module R M] (e : M ‚âÉL[R] M‚ÇÇ) : ‚Üëe.inverse = ‚Üë(e.symm)
{A : Type u_3} [add_group A] (s : set A) : A ‚Üí Prop
{R : Type u_1} [rack R] {G : Type u_2} [group G] : shelf_hom R (quandle.conj G) ‚âÉ (rack.envel_group R ‚Üí* G)
{n : ‚Ñï} (i : fin (n + 1)) : finset.univ.sum (Œª (j : affine.simplex.points_with_circumcenter_index n), affine.simplex.point_weights_with_circumcenter i j) = 1
{R : Type u_1} {M : Type u_7} [semiring R] [add_comm_monoid M] [module R M] : distrib_mul_action (M ‚âÉ‚Çó[R] M) M
(k : Type u‚ÇÅ) {G : Type u‚ÇÇ} [semiring k] [has_mul G] {A : Type u‚ÇÉ} [non_unital_non_assoc_semiring A] [distrib_mul_action k A] {œÜ‚ÇÅ œÜ‚ÇÇ : monoid_algebra k G ‚Üí‚Çô‚Çê[k] A} (h : œÜ‚ÇÅ.to_mul_hom.comp (monoid_algebra.of_magma k G) = œÜ‚ÇÇ.to_mul_hom.comp (monoid_algebra.of_magma k G)) : œÜ‚ÇÅ = œÜ‚ÇÇ
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] {X : C} (P : C·µí·µñ ‚•§ D) (S : J.cover X) : Type (max (max u v) v u)
(Œ± : Type u_3) [lattice Œ±] : lattice_hom Œ± Œ±
{C : Type u‚ÇÇ} [category_theory.category C] [category_theory.limits.has_binary_products C] {J : Type v‚ÇÇ} [category_theory.small_category J] {K : J ‚•§ C} (X : C) : K ‚ãô category_theory.limits.prod.functor.obj X ‚ü∂ (category_theory.functor.const J).obj X
{Œ± : Type u_1} [linear_ordered_field Œ±] {Œ≤ : Type u_2} [ring Œ≤] (abv : Œ≤ ‚Üí Œ±) (f : ‚Ñï ‚Üí Œ≤) : Prop
{F : Type u_3} [field F] [fintype F] (hF : ring_char F ‚â† 2) : ‚àÉ (a : F), ¬¨is_square a
{Œ± : Type u_1} {o p : part Œ±} (H : ‚àÄ (a : Œ±), a ‚àà o ‚Üî a ‚àà p) : o = p
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x : V} (hx : x ‚â† 0) : hb.oangle x (-x) = ‚Üëreal.pi
{R : Type u} (x : category_theory.right_lifting_subcat R) : R
{E : Type u_1} {F : Type u_2} [inner_product_space ‚Ñù E] [inner_product_space ‚Ñù F] {f : E ‚Üí F} {x : E} {f' : E ‚ÜíL[‚Ñù] F} (h : has_fderiv_at f f' x) : conformal_at f x ‚Üî ‚àÉ (c : ‚Ñù), 0 < c ‚àß ‚àÄ (u v : E), has_inner.inner (‚áëf' u) (‚áëf' v) = c * has_inner.inner u v
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] [category_theory.limits.preserves_binary_biproducts F] : category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ‚Ñù P) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p) -·µ• p ‚àà (s.direction)·óÆ
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] [category_theory.limits.preserves_colimits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] : category_theory.limits.preserves_binary_biproducts F
{m : Type v ‚Üí Type w} [monad m] {Œ± : Type u_1} {Œ≤ : Type v} (f : ‚Ñï ‚Üí Œ≤ ‚Üí Œ± ‚Üí m Œ≤) (b : Œ≤) (as : list Œ±) : m Œ≤
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} : is_extr_on f s a ‚Üí is_extr_on (‚áëorder_dual.to_dual ‚àò f) s a
{Œπ : Type u} {Œ± : Type v} [fintype Œπ] {t : Œπ ‚Üí finset Œ±} [decidable_eq Œ±] (ht : ‚àÄ (s : finset Œπ), s.card ‚â§ (s.bUnion t).card) : ‚àÉ (f : Œπ ‚Üí Œ±), function.injective f ‚àß ‚àÄ (x : Œπ), f x ‚àà t x
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] {M N K : category_theory.Mat_ C} (f : M.hom N) (g : N.hom K) : M.hom K
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {E' : Type u_6} [normed_group E'] [normed_space ùïú E'] {F' : Type u_7} [normed_group F'] [normed_space ùïú F'] {f : E ‚Üí F} {g : E' ‚Üí F'} {x : E} {y : E'} (hf : cont_diff_at ùïú n f x) (hg : cont_diff_at ùïú n g y) : cont_diff_at ùïú n (prod.map f g) (x, y)
{G : Type u_1} [div_inv_monoid G] [measurable_space G] [has_measurable_mul G] (g : G) : measurable (Œª (h : G), h / g)
{L : first_order.language} {L' : first_order.language} : L' ‚Üí·¥∏ L.sum L'
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A ‚ü∂ B) (g : B ‚ü∂ C) [category_theory.limits.has_kernels V] [category_theory.limits.has_images V] [category_theory.limits.has_cokernels V] (w : f ‚â´ g = 0) : homology f g w ‚âÖ category_theory.limits.cokernel (image_to_kernel' f g w)
{Œ± : Sort u_1} {k l : ‚Ñï} (h : k = l) {f : fin k ‚Üí Œ±} {g : fin l ‚Üí Œ±} : f == g ‚Üî ‚àÄ (i : fin k), f i = g ‚ü®‚Üëi, _‚ü©
 : environment ‚Üí name ‚Üí environment
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {Œ± : Type u_1} [add_comm_monoid Œ±] [module A Œ±] (S : subalgebra R A) : module ‚Ü•S Œ±
{Œ± : Type u_1} (f : Œ± ‚Üí ‚Ñù) (A : ‚Ñù) : Œ± ‚Üí ‚Ñù
(args : io.process.spawn_args) : io string
{Œ± : Type u_1} [linear_ordered_ring Œ±] [floor_ring Œ±] : Œ± ‚Üí ‚Ñ§
{R : Type u_1} [comm_semiring R] {n : Type u_4} [fintype n] [decidable_eq n] {M‚ÇÅ : Type u_5} [add_comm_monoid M‚ÇÅ] [module R M‚ÇÅ] (v‚ÇÅ : basis n R M‚ÇÅ) : ‚áë(linear_map.to_matrix v‚ÇÅ v‚ÇÅ) linear_map.id = 1
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (M' : submodule R M) (s : set R) (hs : ideal.span s = ‚ä§) (x : M) (H : ‚àÄ (r : ‚Ü•s), ‚àÉ (n : ‚Ñï), ‚Üër ^ n ‚Ä¢ x ‚àà M') : x ‚àà M'
(ùïú : Type u_1) {V : Type u_2} {V‚ÇÇ : Type u_4} (P : Type u_8) (P‚ÇÇ : Type u_9) [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V P] [normed_add_torsor V‚ÇÇ P‚ÇÇ] : Type (max u_2 u_4 u_8 u_9)
{n : ‚Ñï} {A : Type u} {Œ± : typevec n} (x : (mvpfunctor.const n A).obj Œ±) : A
{Œ± : Type u} [partial_order Œ±] [order_top Œ±] {a : Œ±} : is_top a ‚Üí a = ‚ä§
(Œ± : Type u_2) [non_assoc_semiring Œ±] [preorder Œ±] : Œ± ‚Üí+*o Œ±
{P Q : Prop} (h : P ‚Üî Q) : P ‚âÉ Q
{R : Type u} [ring R] {Œπ : Type v} [dec_Œπ : decidable_eq Œπ] {M : Type u_1} [add_comm_group M] [module R M] (A : Œπ ‚Üí submodule R M) : direct_sum.is_internal A ‚Üî complete_lattice.independent A ‚àß supr A = ‚ä§
(R : Type u) (M : Type v) : Type (max u v)
{R : Type u_1} [semiring R] {m : Type u_3} {n : Type u_4} [fintype m] [decidable_eq m] : ((m ‚Üí R) ‚Üí‚Çó[R] n ‚Üí R) ‚âÉ‚Çó[R·µê·µí·µñ] matrix m n R
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] : quadratic_form R M ‚Üí+ M ‚Üí R
 : tactic unit
{Œ± : Type u_1} [boolean_ring Œ±] : has_inf Œ±
{R : Type x} [ring R] [no_zero_divisors R] (u : RÀ£) : u‚Åª¬π = u ‚Üî u = 1 ‚à® u = -1
{p : ‚Ñï} {G : Type u_1} [group G] (P : sylow p G) {K : Type u_2} [group K] (œï : K ‚Üí* G) (hœï : is_p_group p ‚Ü•(œï.ker)) (h : ‚ÜëP ‚â§ œï.range) : sylow p K
{R : Type u_3} {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] (s : set A) (li : algebraic_independent R coe) (t : finset ‚Ü•s) : algebraic_independent R coe
{C : Type u} [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} {c : category_theory.limits.fork f f} (h : category_theory.limits.is_limit c) : category_theory.is_iso c.Œπ
{Œ± : Type} (type : expr) (tac : tactic Œ±) : tactic (Œ± √ó expr)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {r t : category_theory.limits.cone F} (P : category_theory.limits.is_limit r) [i : category_theory.is_iso (P.lift t)] : category_theory.limits.is_limit t
(R : Type u) [semiring R] {Œπ : Type v} [dec_Œπ : decidable_eq Œπ] {M : Œπ ‚Üí Type w} [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] (S T : set Œπ) (H : S ‚äÜ T) : direct_sum ‚Ü•S (Œª (i : ‚Ü•S), M ‚Üëi) ‚Üí‚Çó[R] direct_sum ‚Ü•T (Œª (i : ‚Ü•T), M ‚Üëi)
(s : ‚ÑÇ) : ‚ÑÇ
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_equalizer f g] : category_theory.limits.fork f g
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [add_comm_monoid Œ≤] {s : finset Œ±} {t : finset Œ≥} {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ≤} (i : Œ† (a : Œ±), a ‚àà s ‚Üí Œ≥) (hi : ‚àÄ (a : Œ±) (ha : a ‚àà s), i a ha ‚àà t) (h : ‚àÄ (a : Œ±) (ha : a ‚àà s), f a = g (i a ha)) (i_inj : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±) (ha‚ÇÅ : a‚ÇÅ ‚àà s) (ha‚ÇÇ : a‚ÇÇ ‚àà s), i a‚ÇÅ ha‚ÇÅ = i a‚ÇÇ ha‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ) (i_surj : ‚àÄ (b : Œ≥), b ‚àà t ‚Üí (‚àÉ (a : Œ±) (ha : a ‚àà s), b = i a ha)) : s.sum (Œª (x : Œ±), f x) = t.sum (Œª (x : Œ≥), g x)
 : Type
(l : Type u_4) (R : Type u‚ÇÇ) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (l ‚äï l) (l ‚äï l) R)
(M : Type u_1) [has_add M] : galois_insertion add_con_gen coe_fn
{G : Type u_1} [group G] {N : Type u_3} [group N] (f : G ‚Üí* N) : G ‚Üí* ‚Ü•(f.range)
{Œ± : Type u} [pseudo_emetric_space Œ±] : emetric.diam ‚àÖ = 0
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) [h : Œ† (Y : C), unique (X ‚ü∂ Y)] : category_theory.limits.is_initial X
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K‚ÇÅ K‚ÇÇ : J ‚•§ C} (F : C ‚•§ D) (h : K‚ÇÅ ‚âÖ K‚ÇÇ) [category_theory.creates_limit K‚ÇÅ F] : category_theory.creates_limit K‚ÇÇ F
{C : Type u‚ÇÅ} [category_theory.category C] : C·µí·µñ ‚•§ C ‚•§ Type v‚ÇÅ
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : ‚Üës1 ‚äì ‚Üës2 = ‚Üës1 ‚à© ‚Üës2
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J·µí·µñ ‚•§ C·µí·µñ) {c : category_theory.limits.cone F.unop} (hc : category_theory.limits.is_limit c) : category_theory.limits.is_colimit (category_theory.limits.cocone_of_cone_unop c)
{Œ± : Type u_1} [encodable Œ±] : encodable (list Œ±)
 : cardinal.mk ‚Ü•set.univ = cardinal.continuum
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [has_zero M‚ÇÅ] [has_scalar ‚Ñï M‚ÇÅ] [add_cancel_comm_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : add_cancel_comm_monoid M‚ÇÅ
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {D : Type u‚ÇÇ} [category_theory.category D] {Y : D} (F : category_theory.over Y ‚•§ category_theory.over X) (h : ‚àÄ (f : category_theory.mono_over Y), category_theory.mono (F.obj ((category_theory.mono_over.forget Y).obj f)).hom) : category_theory.mono_over Y ‚•§ category_theory.mono_over X
{F : pfunctor} {n : ‚Ñï} : pfunctor.approx.cofix_a F (n + 1) ‚Üí pfunctor.approx.cofix_a F n
{Œ± : Type u_1} {Œ≤ : Type u_2} {m : measurable_space Œ±} {f : measure_theory.filtration ‚Ñï m} {u : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} [add_comm_monoid Œ≤] [topological_space Œ≤] [has_continuous_add Œ≤] (h : measure_theory.adapted f u) : measure_theory.prog_measurable f u
 : expr ‚Üí tactic (expr √ó expr)
 : matrix.special_linear_group (fin 2) ‚Ñ§
{a : ‚Ñù} {l : filter ‚Ñù} {f f' g g' : ‚Ñù ‚Üí ‚Ñù} (hff' : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.univ  {a}), has_deriv_at f (f' x) x) (hgg' : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.univ  {a}), has_deriv_at g (g' x) x) (hg' : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.univ  {a}), g' x ‚â† 0) (hfa : filter.tendsto f (nhds_within a (set.univ  {a})) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.univ  {a})) (nhds 0)) (hdiv : filter.tendsto (Œª (x : ‚Ñù), f' x / g' x) (nhds_within a (set.univ  {a})) l) : filter.tendsto (Œª (x : ‚Ñù), f x / g x) (nhds_within a (set.univ  {a})) l
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [has_bot Œ±] [has_bot Œ≤] [has_bot Œ≥] (f : bot_hom Œ≤ Œ≥) (g : bot_hom Œ± Œ≤) : bot_hom Œ± Œ≥
{K : Type u_1} [is_R_or_C K] (z : K) : ‚Ñù
{R : Type u} {K : Type v} {L : Type z} {p : R} [comm_ring R] [field K] [field L] [algebra K L] [algebra R L] [algebra R K] [is_scalar_tower R K L] [is_separable K L] [is_domain R] [normalized_gcd_monoid R] [is_fraction_ring R K] [is_integrally_closed R] {B : power_basis K L} (hp : prime p) (hBint : is_integral R B.gen) {z : L} {Q : polynomial R} (hQ : ‚áë(polynomial.aeval B.gen) Q = p ‚Ä¢ z) (hzint : is_integral R z) (hei : (minpoly R B.gen).is_eisenstein_at (submodule.span R {p})) : p ‚à£ Q.coeff 0
(h : interactive.parse (optional lean.parser.ident)) (_x : interactive.parse (lean.parser.tk ":")) (p : interactive.parse generalize_arg_p) : tactic unit
{Œ± : Type u_3} {Œ≤ : Type u_4} [linear_ordered_field Œ±] {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±} {r : Œ±} (hr : r < 0) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Œª (x : Œ≤), r * f x) l filter.at_bot
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {G : Œπ ‚Üí Type u_5} [Œ† (i : Œπ), inner_product_space ùïú (G i)] {V : Œ† (i : Œπ), G i ‚Üí‚Çó·µ¢[ùïú] E} (hV : orthogonal_family ùïú V) {Œ≥ : Type u_3} {f : Œ≥ ‚Üí Œπ} (hf : function.injective f) : orthogonal_family ùïú (Œª (g : Œ≥), V (f g))
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ±‚ÇÇ : Type u_3} [semiring Œ≤] [has_one Œ±] [has_one Œ±‚ÇÇ] {F : Type u_4} [one_hom_class F Œ± Œ±‚ÇÇ] (f : F) : finsupp.map_domain ‚áëf 1 = 1
(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : Type (max u_1 u_2)
(type : expr) : tactic pexpr
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), add_comm_group (A i)] [add_monoid Œπ] [direct_sum.gsemiring A] : ring (A 0)
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (O : finset C) : ‚àÉ (S : C), ‚àÄ {X : C}, X ‚àà O ‚Üí nonempty (X ‚ü∂ S)
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} : function.injective coe_fn
(R : Type u) {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) : set R
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) : Type (max u v)
(ic : tactic.instance_cache) (a b : expr) : tactic (tactic.instance_cache √ó expr √ó expr)
{Œ± : Type u} (a : Œ±) (n : ‚Ñï) : arity Œ± n
{G : Type u_1} [group G] {N : Type u_3} [group N] {f : G ‚Üí* N} (hf : function.injective ‚áëf) : G ‚âÉ* ‚Ü•(f.range)
(p : ‚Ñï) {q : ‚Ñö} (hq : q ‚â† 0) : padic_norm p q = ‚Üëp ^ -padic_val_rat p q
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {F : C ‚•§ D} [category_theory.creates_limit K F] {c : category_theory.limits.cone (K ‚ãô F)} (t : category_theory.limits.is_limit c) : F.map_cone (category_theory.lift_limit t) ‚âÖ c
{Œ± : Type u_2} [decidable_eq Œ±] [has_inv Œ±] {s : finset Œ±} : s.nonempty ‚Üí s‚Åª¬π.nonempty
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] : multiset Œ± ‚Üí+ ‚Ñï
{Œ± : Type u} [has_add Œ±] : is_add_hom id
 : list expr ‚Üí smt_tactic hinst_lemmas
{Œ± : Sort u_1} {Œ≤ : Sort u_2} [sa : setoid Œ±] [sb : setoid Œ≤] {Œ≥ : Sort u_4} [sc : setoid Œ≥] (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (h : (has_equiv.equiv ‚áí has_equiv.equiv ‚áí has_equiv.equiv) f f) : quotient sa ‚Üí quotient sb ‚Üí quotient sc
{R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : S.to_submodule * S.to_submodule = S.to_submodule
{K : Type u_1} [linear_ordered_field K] [floor_ring K] {a : K} (b c : K) (fract_a_ne_zero : int.fract a ‚â† 0) : (‚Üë‚åäa‚åã * b + c) / int.fract a + b = (b * a + c) / int.fract a
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) [category_theory.is_equivalence F.to_lax_monoidal_functor.to_functor] : category_theory.lax_monoidal_functor.id C ‚ü∂ F.to_lax_monoidal_functor ‚äó‚ãô (category_theory.monoidal_inverse F).to_lax_monoidal_functor
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : differentiable_on ‚Ñù f (interior D)) {C : ‚Ñù} (hf'_ge : ‚àÄ (x : ‚Ñù), x ‚àà interior D ‚Üí C ‚â§ deriv f x) (x : ‚Ñù) (H : x ‚àà D) (y : ‚Ñù) (H_1 : y ‚àà D) : x ‚â§ y ‚Üí C * (y - x) ‚â§ f y - f x
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Ü™o Œ≤) : with_bot Œ± ‚Ü™o with_bot Œ≤
{R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] {H : lie_subalgebra R L} {x y : L} (hx : x ‚àà H.normalizer) (hy : y ‚àà H) : ‚ÅÖx,y‚ÅÜ ‚àà H
{R : Type u_1} {M : Type u_2} [add_comm_monoid M] [comm_semiring R] {S : set M} (hS : add_submonoid.closure S = ‚ä§) : function.surjective ‚áë(mv_polynomial.aeval (Œª (s : ‚Ü•S), add_monoid_algebra.of' R M ‚Üës))
(p : ‚Ñï ‚Üí Prop) [decidable_pred p] (n : ‚Ñï) : fintype {i // i < n ‚àß p i}
{n : ‚Ñï} (w : 0 < n) (h : ¬¨nat.prime n) : n.min_fac ^ 2 ‚â§ n
 : ‚Ñï ‚Üí pSet
 : Type
(p : ‚Ñï) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : ‚Ñï) (a‚ÇÅ a‚ÇÇ : witt_vector p k) (bs : fin (n + 1) ‚Üí k) : polynomial k
(F : Type u_1) (K : Type u_2) [field F] [field K] [algebra F K] [finite_dimensional F K] [char_zero F] : is_separable F K
(s : string) : ‚Ñï
(F : pfunctor) : Type u
{Œ± : Type u_1} {f g : Œ± ‚Üí ‚Ñù} {t‚ÇÄ : filter Œ±} (hf : ‚àÄ (t : Œ±), 0 ‚â§ f t) (hft : ‚àÄ (t : Œ±), f t ‚â§ g t) (g0 : filter.tendsto g t‚ÇÄ (nhds 0)) : filter.tendsto f t‚ÇÄ (nhds 0)
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± Œ≤ : typevec n} (g : Œ±.arrow Œ≤) : P.W Œ± ‚Üí P.W Œ≤
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (c : category_theory.limits.cone F.op) : category_theory.limits.cocone F
{C : Type u} [category_theory.category C] {X Y : C} (J : category_theory.grothendieck_topology C) (f : Y ‚ü∂ X) (S : category_theory.sieve X) (hf : ‚áëS f) : J.covers S f
 : name ‚Üí name
(K : Type u_1) (V : Type u_2) [field K] [add_comm_group V] [module K V] : Type u_2
 : expr ‚Üí tactic (list (‚Ñï √ó binder) √ó expr)
{R : Type u_1} (A : Type u_2) {M : Type u_4} {N : Type u_5} [comm_semiring R] [semiring A] [algebra R A] [add_comm_monoid M] [module R M] [add_comm_monoid N] [module R N] (f : M ‚Üí‚Çó[R] N) : tensor_product R A M ‚Üí‚Çó[A] tensor_product R A N
{ùïú : Type u_1} [linear_ordered_field ùïú] {s : set ùïú} {f : ùïú ‚Üí ùïú} (hf : strict_concave_on ùïú s f) {x y z : ùïú} (hx : x ‚àà s) (hz : z ‚àà s) (hxy : x < y) (hyz : y < z) : (f z - f y) / (z - y) < (f y - f x) / (y - x)
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.sheaf C X) : category_theory.limits.is_terminal (F.val.obj (opposite.op ‚àÖ))
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (R : D ‚•§ C) [category_theory.reflective R] [category_theory.limits.has_colimits_of_size C] : category_theory.limits.has_colimits_of_size D
{R : Type u} [ring R] (s : subring R) : ring ‚Ü•s
{ùïú : Type u_1} {E : Type u_2} [normed_field ùïú] [normed_group E] [normed_space ùïú E] : E ‚ÜíL[ùïú] uniform_space.completion E
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [topological_space Œ±] [topological_space Œ≤] : Type (max u_6 u_7 u_8)
{Œ± : Type u_1} {Œ≤ : Type u_2} : list Œ± ‚Üí list Œ≤ ‚Üí list (option Œ± √ó Œ≤)
{G : Type u_1} {H : Type u_2} [add_group G] {N : add_subgroup G} [add_group H] {f : G ‚Üí+ H} (hN : N = f.ker) (tH : add_monoid.is_torsion H) (tN : add_monoid.is_torsion ‚Ü•N) : add_monoid.is_torsion G
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_comm_monoid M] (s : finset (Œ± √ó Œ≤)) (f : Œ± √ó Œ≤ ‚Üí M) : finsum (Œª (ab : Œ± √ó Œ≤), finsum (Œª (h : ab ‚àà s), f ab)) = finsum (Œª (a : Œ±), finsum (Œª (b : Œ≤), finsum (Œª (h : (a, b) ‚àà s), f (a, b))))
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.cartesian_closed C] : C·µí·µñ ‚•§ C ‚•§ C
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) [category_theory.is_iso h.unit] : category_theory.full L
(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ‚Ñï} [hp : char_p R p] (p_ne_zero : p ‚â† 0) : nat.prime p
 : tactic unit
(n : ‚Ñï) : (pgame.pow_half n).numeric
{Œ± : Type u_1} (a : Œ±) [decidable_pred (Œª (_x : Œ±), _x = a)] (h : fintype {b // b ‚â† a}) : fintype Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cone F} (ht : ‚àÄ (s : category_theory.limits.cone F), ‚àÉ! (l : s.X ‚ü∂ t.X), ‚àÄ (j : J), l ‚â´ t.œÄ.app j = s.œÄ.app j) : category_theory.limits.is_limit t
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : has_dist.dist p1 p3 * has_dist.dist p1 p3 = has_dist.dist p1 p2 * has_dist.dist p1 p2 + has_dist.dist p3 p2 * has_dist.dist p3 p2 - 2 * has_dist.dist p1 p2 * has_dist.dist p3 p2 * real.cos (euclidean_geometry.angle p1 p2 p3)
{n : ‚Ñï} {Œ± : Type u_1} [linear_order Œ±] (f : fin n ‚Üí Œ±) : fin n ‚âÉ ‚Ü•(tuple.graph f)
{A : Type u_2} [add_group A] : add_subgroup A ‚âÉo subgroup (multiplicative A)
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [ring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [nonempty Œπ] (f : multilinear_map R M‚ÇÅ M‚ÇÇ) (p : Œ† (i : Œπ), submodule R (M‚ÇÅ i)) : ‚Üë(f.map p).nonempty
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.limits.equalizer f f ‚âÖ X
(C : Type u) [category_theory.category C] : Prop
{G : Type u_1} [group G] (H : subgroup G) {x y : G} : x ‚àà H ‚Üí y ‚àà H ‚Üí x * y ‚àà H
{Œ± : Type u} (s : set Œ±) : Prop
{Œ± : Type u} (n : ‚Ñï) (s : stream Œ±) : stream Œ±
{Œ± : Type u} [has_repr Œ±] : slim_check.injective_function Œ± ‚Üí string
 : environment ‚Üí module_info ‚Üí environment
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤] {f : C(Œ±, Œ≤)} {Œπ : Type u‚ÇÉ} {p : filter Œπ} {F : Œπ ‚Üí C(Œ±, Œ≤)} [locally_compact_space Œ±] : filter.tendsto F p (nhds f) ‚Üî tendsto_locally_uniformly (Œª (i : Œπ) (a : Œ±), ‚áë(F i) a) ‚áëf p
{R : Type u_1} {S : Type u_2} [ring R] [ring S] [algebra ‚Ñ§ R] [algebra ‚Ñ§ S] (f : R ‚Üí+* S) : R ‚Üí‚Çê[‚Ñ§] S
(x : onote) : onote ‚Üí onote
{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] {P : ‚Ñô K V ‚Üí Prop} (h : ‚àÄ (v : V) (h : v ‚â† 0), P (projectivization.mk K v h)) (p : ‚Ñô K V) : P p
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (m : hash_map Œ± Œ≤) (a : Œ±) : hash_map Œ± Œ≤
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} (f : J ‚Üí (X ‚ü∂ Y)) [category_theory.limits.has_wide_equalizer f] : category_theory.limits.trident f
{Œ± : Type u_1} (f : Œ± ‚Üí Œ±) : ‚Ñï ‚Üí list Œ± ‚Üí list Œ±
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R ‚Üí+* S) (x : S) : polynomial R ‚Üí+ S
{Œ± : Type u} (p q : Œ± ‚Üí Prop) : {x // q x.val} ‚âÉ {x // p x ‚àß q x}
{Œ± : Type u} [decidable_eq Œ±] [mul_zero_one_class Œ±] [nontrivial Œ±] : mul_zero_one_class (with_top Œ±)
 : environment ‚Üí name ‚Üí ‚Ñï
(p : ‚Ñï) [hp : fact (nat.prime p)] (n : ‚Ñï) : witt_vector.is_poly p (Œª (R : Type u_1) (_Rcr : comm_ring R) (x : witt_vector p R), x * ‚Üën)
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} {Œ≤ : Type u} (g : F (Œ± ::: Œ≤) ‚Üí Œ≤) : (mvqpf.P F).W Œ± ‚Üí Œ≤
 : list expr ‚Üí expr ‚Üí expr
{Œπ : Type u} {f g : Œπ ‚Üí ‚Ñù} {p q : ‚Ñù} (hpq : p.is_conjugate_exponent q) (hf : ‚àÄ (i : Œπ), 0 ‚â§ f i) (hg : ‚àÄ (i : Œπ), 0 ‚â§ g i) (hf_sum : summable (Œª (i : Œπ), f i ^ p)) (hg_sum : summable (Œª (i : Œπ), g i ^ q)) : summable (Œª (i : Œπ), f i * g i) ‚àß ‚àë' (i : Œπ), f i * g i ‚â§ (‚àë' (i : Œπ), f i ^ p) ^ (1 / p) * (‚àë' (i : Œπ), g i ^ q) ^ (1 / q)
{C : Type u} [ùíû : category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.limits.has_limit (category_theory.limits.pair X Y)] [category_theory.limits.has_limit (category_theory.limits.parallel_pair (category_theory.limits.prod.fst ‚â´ f) (category_theory.limits.prod.snd ‚â´ g))] : category_theory.limits.has_limit (category_theory.limits.cospan f g)
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : semiring (submodule R A)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space F] [complete_space E] (f : E ‚ÜíL[ùïú] F) (hsurj : f.range = ‚ä§) : f.nonlinear_right_inverse
{Œπ : Type u_1} (p : ‚Ñù) (Œ± : Œπ ‚Üí Type u_3) : pi_Lp p Œ± ‚âÉ Œ† (i : Œπ), Œ± i
{Œ≥ : Type w} [linear_order Œ≥] {a b : Œ≥} {s t : set Œ≥} (ha : is_greatest s a) (hb : is_greatest t b) : is_greatest (s ‚à™ t) (linear_order.max a b)
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} (f : J ‚Üí (X ‚ü∂ Y)) : category_theory.limits.walking_parallel_family J ‚•§ C
(Œ∏ : ‚ÑÇ) (n : ‚Ñï) : polynomial.eval (complex.cos Œ∏) (polynomial.chebyshev.U ‚ÑÇ n) * complex.sin Œ∏ = complex.sin ((‚Üën + 1) * Œ∏)
(ùïú : Type u_1) (E : Type u_2) [ordered_semiring ùïú] [ordered_add_comm_group E] [module ùïú E] [ordered_smul ùïú E] : convex_cone ùïú E
{Œ± : Type} (a : Œ±) (c : tactic.simp_config) (s : simp_lemmas) (discharger : Œ± ‚Üí tactic Œ±) (pre post : Œ± ‚Üí simp_lemmas ‚Üí name ‚Üí option expr ‚Üí expr ‚Üí tactic (Œ± √ó expr √ó option expr √ó bool)) (r : name) : expr ‚Üí tactic (Œ± √ó expr √ó expr)
(s : set ‚Ñï) [decidable_pred (Œª (_x : ‚Ñï), _x ‚àà s)] [infinite ‚Ü•s] : ‚Ñï ‚âÉo ‚Ü•s
{Œ± : Type u} {Œ≤ : Type u_1} (f : Œ± ‚Üí Œ≤) : ordnode Œ± ‚Üí ordnode Œ≤
{Œπ : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [has_mul R] [has_add Œπ] (A : Œπ ‚Üí S) : Prop
(Œ± : Type u) [measurable_space Œ±] : Meas
{Œ± : Type u_1} (max : ‚Ñï) (tac : tactic Œ±) : tactic Œ±
{R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] [comm_ring B] [algebra R B] {f : A ‚Üí‚Çê[R] B} (hf : function.surjective ‚áëf) (hker : f.to_ring_hom.ker.fg) (hfp : algebra.finite_presentation R A) : algebra.finite_presentation R B
{Œπ : Type u_1} (p : ‚Ñù) [fact_one_le_p : fact (1 ‚â§ p)] (Œ± : Œπ ‚Üí Type u_3) [Œ† (i : Œπ), pseudo_metric_space (Œ± i)] [fintype Œπ] : pseudo_metric_space (pi_Lp p Œ±)
{ùïú : Type u_1} [linear_ordered_field ùïú] {s : set ùïú} {f : ùïú ‚Üí ùïú} : strict_concave_on ùïú s f ‚Üî convex ùïú s ‚àß ‚àÄ ‚¶Éx y z : ùïú‚¶Ñ, x ‚àà s ‚Üí z ‚àà s ‚Üí x < y ‚Üí y < z ‚Üí (f z - f y) / (z - y) < (f y - f x) / (y - x)
{Œ± : Type u_1} [semigroup Œ±] {a b c : Œ±} : a ‚à£ b ‚Üí b ‚à£ c ‚Üí a ‚à£ c
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {v : picard_lindelof E} (f : v.fun_space) (t : ‚Ñù) : E
 : subsingleton (fin 1)
{Œ± : Type} : string ‚Üí widget.attr Œ±
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : C √ó D ‚•§ C
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) [h : Œ† (Y : C), unique (X ‚ü∂ Y)] : category_theory.limits.has_initial C
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) (hf : continuous f) (K : topological_space.compacts Œ±) : topological_space.compacts Œ≤
{Œ± Œ≤ : Type u} (f : Œ± ‚ü∂ Œ≤) : Type u
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [complete_space ‚Ü•(s.direction)] {ps : set P} (hnps : ps.nonempty) {p : P} (hps : ps ‚äÜ ‚Üës) (hp : p ‚àâ s) (hu : ‚àÉ! (cccr : P √ó ‚Ñù), cccr.fst ‚àà s ‚àß ‚àÄ (p1 : P), p1 ‚àà ps ‚Üí has_dist.dist p1 cccr.fst = cccr.snd) : ‚àÉ! (cccr‚ÇÇ : P √ó ‚Ñù), cccr‚ÇÇ.fst ‚àà affine_span ‚Ñù (has_insert.insert p ‚Üës) ‚àß ‚àÄ (p1 : P), p1 ‚àà has_insert.insert p ps ‚Üí has_dist.dist p1 cccr‚ÇÇ.fst = cccr‚ÇÇ.snd
{G : Type w} [topological_space G] [group G] [has_continuous_mul G] (a : G) : G ‚âÉ‚Çú G
 : bool √ó ‚Ñï ‚âÉ ‚Ñï
{M : Type u_3} {N : Type u_4} [monoid M] [monoid N] (f : M ‚Üí* N) (hf : ‚àÄ (x : M), is_unit (‚áëf x)) : M ‚Üí* NÀ£
(X : CpltSepUniformSpace) : UniformSpace
{F : Type u_1} [field F] (p : polynomial F) (E : Type u_2) [field E] [algebra F E] [fact (polynomial.splits (algebra_map F E) p)] : mul_action p.gal ‚Ü•(p.root_set E)
 : linter
{Œ± : Type u} (s : seq Œ±) : option (seq1 Œ±)
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] {i j : Œπ} (w : free_product.neword M i j) : list (Œ£ (i : Œπ), M i)
(z : upper_half_plane) : ‚àÉ (g : matrix.special_linear_group (fin 2) ‚Ñ§), ‚àÄ (g' : matrix.special_linear_group (fin 2) ‚Ñ§), (g' ‚Ä¢ z).im ‚â§ (g ‚Ä¢ z).im
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {M N O : Mon_ C} (f : M.hom N) (g : N.hom O) : M.hom O
(Œ± : Type u_1) : Type u_1
 : expr ‚Üí (expr ‚Üí ‚Ñï ‚Üí option expr) ‚Üí expr
 : native.float ‚Üí option ‚Ñ§
(i : tactic.interactive.itactic) : tactic.interactive.itactic
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) [category_theory.is_filtered J] : has_mul (Mon.filtered_colimits.M F)
{V : Type u} [quiver V] (r : V) (height : V ‚Üí ‚Ñï) (height_lt : ‚àÄ ‚¶Éa b : V‚¶Ñ, (a ‚ü∂ b) ‚Üí height a < height b) (unique_arrow : ‚àÄ ‚¶Éa b c : V‚¶Ñ (e : a ‚ü∂ c) (f : b ‚ü∂ c), a = b ‚àß e == f) (root_or_arrow : ‚àÄ (b : V), b = r ‚à® ‚àÉ (a : V), nonempty (a ‚ü∂ b)) : quiver.arborescence V
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [comm_ring ùïú] [add_comm_group E] [add_comm_group F] [add_comm_group G] [module ùïú E] [module ùïú F] [module ùïú G] [topological_space E] [topological_space F] [topological_space G] [topological_add_group E] [has_continuous_const_smul ùïú E] [topological_add_group F] [has_continuous_const_smul ùïú F] [topological_add_group G] [has_continuous_const_smul ùïú G] (q : formal_multilinear_series ùïú F G) (p : formal_multilinear_series ùïú E F) (v : fin 0 ‚Üí E) (v' : fin 0 ‚Üí F) : ‚áë(q.comp p 0) v = ‚áë(q 0) v'
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (N : submodule R M) : ideal R
{R : Type u} [ring R] : ¬¨is_field (polynomial R)
{Œ± : Type u_1} {Œ≤ : Type u_2} [decidable_eq Œ≤] (f : Œ± ‚Üí. Œ≤) [Œ† (x : Œ±), decidable (f x).dom] (s : finset Œ±) : finset Œ≤
 : expr ‚Üí ‚Ñï ‚Üí tactic (list (expr √ó name √ó binder_info) √ó expr)
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [‚àÄ (i : ùí∞.J), category_theory.limits.has_pullback (ùí∞.map i ‚â´ f) g] (s : category_theory.limits.pullback_cone f g) : s.X ‚ü∂ (algebraic_geometry.Scheme.pullback.gluing ùí∞ f g).glued
{R : Type u_1} (A : Type u_2) {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra R B] [algebra A B] [is_integral_closure A R B] (x : B) (hx : is_integral R x) : A
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : has_one (submodule R A)
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : Type (max u_4 u_5)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {A : Type u‚ÇÉ} [category_theory.category A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (hG‚ÇÅ : category_theory.compatible_preserving K G) (hG‚ÇÇ : category_theory.cover_preserving J K G) (‚Ñ± : category_theory.Sheaf K A) : category_theory.Sheaf J A
{cd : fin 2 ‚Üí ‚Ñ§} (hcd : is_coprime (cd 0) (cd 1)) : filter.tendsto (Œª (g : {g // ‚Üëg 1 = cd}), ‚áë(modular_group.lc_row0 cd) ‚Üë‚Üëg) filter.cofinite (filter.cocompact ‚Ñù)
{Œ± : Type u_1} [topological_space Œ±] {Œπ : Type u_2} [hŒπ : nonempty Œπ] [encodable Œπ] [t2_space Œ±] {s : Œπ ‚Üí set Œ±} (hs : ‚àÄ (n : Œπ), measure_theory.analytic_set (s n)) : measure_theory.analytic_set (‚ãÇ (n : Œπ), s n)
{V : Type u} {G : simple_graph V} (M : G.subgraph) : Prop
{Œ± : Type u} (e p : equiv.perm Œ±) : ‚áë(equiv.perm_congr e) p = e * p * e‚Åª¬π
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ≤] {f : Œ± ‚Üí Œ≤} [topological_space Œ±] (L : ‚àÄ (u : set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí (‚àÉ (F : Œ± ‚Üí Œ≤), continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u)) : continuous f
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) {J : Type u} [category_theory.category J] (K : J ‚•§ D) : category_theory.is_right_adjoint (category_theory.limits.cones.functoriality K G)
{Œ± : Type u} [add_monoid Œ±] (u : add_units Œ±) : Œ±
{Œ± : Type uu} (r : Œ± ‚Üí Œ± ‚Üí Prop) [decidable_rel r] [is_total Œ± r] [is_trans Œ± r] (l : list Œ±) : list.sorted r (list.insertion_sort r l)
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] [category_theory.limits.has_finite_products C] [category_theory.limits.has_finite_products D] (F : C ‚•§ D) {L : D ‚•§ C} [category_theory.cartesian_closed C] [category_theory.cartesian_closed D] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] (h : L ‚ä£ F) [category_theory.full F] [category_theory.faithful F] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) L] : category_theory.cartesian_closed_functor F
(k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p : P) : p ‚àà ‚ä§
(R : Type u_1) {V : Type u_2} {P : Type u_4} [ring R] [invertible 2] [add_comm_group V] [module R V] [add_torsor V P] (R' : Type u_3) [ring R'] [invertible 2] [module R' V] (x y : P) : midpoint R x y = midpoint R' x y
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {f : E ‚Üí F} {g : F ‚Üí G} {n : with_top ‚Ñï} (x : E) (hg : cont_diff_at ùïú n g (f x)) (hf : cont_diff_at ùïú n f x) : cont_diff_at ùïú n (g ‚àò f) x
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] (l : list Œ±) (hp : ‚àÉ (a : Œ±), a ‚àà l ‚àß p a) : {a // a ‚àà l ‚àß p a}
(p : Type u_2) (q : Type u_3) (R : Type u‚ÇÇ) [decidable_eq p] [decidable_eq q] [comm_ring R] [fintype p] [fintype q] {i : R} (hi : i * i = -1) : invertible (lie_algebra.orthogonal.Pso p q R i)
{e : ‚ÑÇ ‚Üí ‚ÑÇ} {e' : ‚ÑÇ} {z : ‚Ñù} (h : has_deriv_at e e' ‚Üëz) : has_deriv_at (Œª (x : ‚Ñù), (e ‚Üëx).re) e'.re z
{Œ± : Type u} (f : ‚Ñï ‚Üí ‚Ñï) (cmd : slim_check.gen Œ±) : slim_check.gen Œ±
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_object V] [category_theory.limits.has_zero_morphisms V] (C : chain_complex V ‚Ñï) : chain_complex.truncate.obj C ‚ü∂ (chain_complex.single‚ÇÄ V).obj (C.X 0)
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {s t : set Œ±} (hs : (s ‚à© function.mul_support f).finite) (ht : (t ‚à© function.mul_support f).finite) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s ‚à™ t), f i)) * finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s ‚à© t), f i)) = finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)) * finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà t), f i))
{Œ≤ : ‚Ñï ‚Üí Type u_1} : inhabited (hash_map ‚Ñï Œ≤)
(J : Type u‚ÇÅ) [category_theory.category J] {C : Type u‚ÇÇ} [category_theory.category C] [nonempty J] : category_theory.faithful (category_theory.functor.const J)
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_assoc_semiring Œ±} {rŒ≤ : non_assoc_semiring Œ≤} (f : Œ± ‚Üí+* Œ≤) : 0 = 1 ‚Üî set.range ‚áëf = {0}
{G : Type u_1} [group G] (K : subgroup G) (s : set G) (hs : s = ‚ÜëK) : subgroup G
(hs : name_set) : tactic ‚Ñï
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) : category_theory.limits.cone F
{Œ± : Type u} {Œ≤ : Type v} [has_add Œ±] [add_zero_class Œ≤] : add_hom Œ± Œ≤ ‚âÉ (with_zero Œ± ‚Üí+ Œ≤)
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [decidable_eq Œ±] (h : ‚àÄ (a b : Œ±), ‚àÉ (c : Œ±), ‚àÄ (d : Œ±), d ‚à£ a ‚àß d ‚à£ b ‚Üî d ‚à£ c) : gcd_monoid Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) {r : ‚Ñù} (hr : r < 0) : o.oangle x (r ‚Ä¢ y) = o.oangle x (-y)
{F : pfunctor} : F.M ‚Üí F.obj F.M
{Œ± : Type u_1} [comm_semiring Œ±] (E : linear_recurrence Œ±) : submodule Œ± (‚Ñï ‚Üí Œ±)
{n : ‚Ñï} {i : fin (n + 2)} : simplex_category.Œ¥ i ‚â´ simplex_category.Œ¥ (‚áëfin.cast_succ i) = simplex_category.Œ¥ i ‚â´ simplex_category.Œ¥ i.succ
{Œ± : Type} (m : tactic.norm_fin.eval_fin_m Œ±) : tactic.norm_fin.eval_fin_m Œ±
{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] [topological_space Œ≤] {f g : Œ≤ ‚Üí uniform_space.completion Œ±} (hf : continuous f) (hg : continuous g) : continuous (Œª (x : Œ≤), has_dist.dist (f x) (g x))
{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] (s : set (M √ó M)) : Prop
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {s : finset V} (span_eq : submodule.span K ‚Üës = ‚ä§) (card_eq : s.card = finite_dimensional.finrank K V) : basis ‚Ü•‚Üës K V
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_cokernel f] : C
(hs : list expr) : tactic (list expr_set)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type v‚ÇÅ} [category_theory.small_category J] (F : C ‚•§ D) {X : D} (G : J ‚•§ category_theory.structured_arrow X F) : category_theory.limits.cone (G ‚ãô category_theory.structured_arrow.proj X F ‚ãô F)
(u : pnat.xgcd_type) : Prop
{Œ± : Type u_1} [has_mul Œ±] [linear_order Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] (m : Œ±) : Œ± ‚Ü™o Œ±
{R : Type u} {M‚ÇÅ : Type v} {M‚ÇÇ : Type w} [comm_ring R] [add_comm_group M‚ÇÅ] [module R M‚ÇÅ] [add_comm_group M‚ÇÇ] [module R M‚ÇÇ] (e : M‚ÇÅ ‚âÉ‚Çó[R] M‚ÇÇ) : module.End R M‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ module.End R M‚ÇÇ
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.abelian D] (F : C ‚•§ D) [F.preserves_zero_morphisms] (G : D ‚•§ C) [G.preserves_zero_morphisms] [category_theory.limits.preserves_finite_limits G] (i : F ‚ãô G ‚âÖ ùü≠ C) (adj : G ‚ä£ F) : category_theory.abelian C
(Œ± : Type u) [uniform_space Œ±] : filter (Œ± √ó Œ±)
{M : Type u_1} [add_zero_class M] (s : set M) {p : Œ† (x : M), x ‚àà add_submonoid.closure s ‚Üí Prop} (Hs : ‚àÄ (x : M) (h : x ‚àà s), p x _) (H1 : p 0 _) (Hmul : ‚àÄ (x : M) (hx : x ‚àà add_submonoid.closure s) (y : M) (hy : y ‚àà add_submonoid.closure s), p x hx ‚Üí p y hy ‚Üí p (x + y) _) {x : M} (hx : x ‚àà add_submonoid.closure s) : p x hx
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] {F G H : category_theory.oplax_functor B C} (Œ∑ : F ‚ü∂ G) {Œ∏ Œπ : G ‚ü∂ H} (Œì : Œ∏ ‚ü∂ Œπ) : Œ∑ ‚â´ Œ∏ ‚ü∂ Œ∑ ‚â´ Œπ
(V : out_param (Type u_1)) (P : Type u_2) [out_param (semi_normed_group V)] [pseudo_metric_space P] : Type (max u_1 u_2)
{C : Type u} [category_theory.category C] {Z X‚ÇÅ X‚ÇÇ : C} [category_theory.limits.has_binary_coproduct X‚ÇÅ X‚ÇÇ] [category_theory.limits.coproduct_disjoint X‚ÇÅ X‚ÇÇ] {f : Z ‚ü∂ X‚ÇÅ} {g : Z ‚ü∂ X‚ÇÇ} {comm : f ‚â´ category_theory.limits.coprod.inl = g ‚â´ category_theory.limits.coprod.inr} (cZ : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk f g comm)) : category_theory.limits.is_initial Z
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) : set.inv_on f g (function.fixed_points (f ‚àò g)) (function.fixed_points (g ‚àò f))
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : free_group Œ± ‚Üí* free_group Œ≤
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_Inf Œ±] [has_Inf Œ≤] : Inf_hom Œ± Œ≤ ‚âÉ Sup_hom Œ±·µí·µà Œ≤·µí·µà
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_le Œ≤] [has_add Œ≤] [has_one Œ≤] (s : set Œ±) (f : Œ± ‚Üí Œ≤) : Prop
{R : Type u_1} {m : Type u_3} {n : Type u_4} {Œ± : Type u_5} [fintype m] [fintype n] [normed_field R] [semi_normed_group Œ±] [normed_space R Œ±] : normed_space R (matrix m n Œ±)
{F : Type} [field F] (q : ‚Ñï) [hq : fact (nat.prime q)] [char_p F q] (g g' : polynomial F) (m m' : ‚Ñï) (h_expand : ‚áë(polynomial.expand F (q ^ m)) g = ‚áë(polynomial.expand F (q ^ m')) g') (hg : g.separable) (hg' : g'.separable) : g.nat_degree = g'.nat_degree
{a b c : ‚Ñ§} (h : a % b = c) : b ‚à£ a - c
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} {x : Œ±} (hx : x ‚àà s) (fin : emetric.Hausdorff_edist s t ‚â† ‚ä§) : metric.inf_dist x t ‚â§ metric.Hausdorff_dist s t
{R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L ‚â§ cardinal.mk R
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {p : filter Œπ} [topological_space Œ±] (hs : is_compact s) : tendsto_locally_uniformly_on F f p s ‚Üî tendsto_uniformly_on F f p s
{X : Top} (F : Top.presheaf (Type v) X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) (sf : Top.presheaf.sheaf_condition_equalizer_products.pi_opens F U) : F.is_compatible U ((F.pi_opens_iso_sections_family U).hom sf) ‚Üî Top.presheaf.sheaf_condition_equalizer_products.left_res F U sf = Top.presheaf.sheaf_condition_equalizer_products.right_res F U sf
(n : ‚Ñï) : finset.univ = finset.cons (fin.last n) (finset.map fin.cast_succ.to_embedding finset.univ) _
 : expr ‚Üí bool
(C : Type u) [category_theory.category C] : category_theory.monoidal_category (C ‚•§ C)
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k ‚Üí PE) (a b c : k) : ((b - a) / (c - a)) ‚Ä¢ slope f a b + ((c - b) / (c - a)) ‚Ä¢ slope f b c = slope f a c
{Œ± : Type u_1} : (tactic.closure ‚Üí tactic Œ±) ‚Üí tactic Œ±
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommGroup) : category_theory.limits.is_colimit (CommGroup.filtered_colimits.colimit_cocone F)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) : category_theory.limits.cocone F
{Œ± : Type u_2} [has_le Œ±] : with_top Œ±·µí·µà ‚âÉo (with_bot Œ±)·µí·µà
{Œ± : Type u} {Œ≤ : Type v} [add_zero_class Œ±] [add_zero_class Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] : vector_span k ‚àÖ = ‚ä•
{c c' : Œ£ (n : ‚Ñï), composition n} : c = c' ‚Üî c.snd.blocks = c'.snd.blocks
{Œ± : Type u_1} {Œπ : Type u_3} {m : measurable_space Œ±} [preorder Œπ] (f : measure_theory.filtration Œπ m) (œÑ : Œ± ‚Üí Œπ) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (Œ± : F ‚âÖ G) (X : C) : F.obj X ‚âÖ G.obj X
{Œ± : Type u_1} [semiring Œ±] {m n : ‚Ñï} (h : m ‚à£ n) : ‚Üëm ‚à£ ‚Üën
{V : Type u} (G : simple_graph V) (v : V) : G.connected_component
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] (K : intermediate_field F E) : subgroup (E ‚âÉ‚Çê[F] E)
{E : Type u_2} [add_comm_group E] {F : Type u_3} [add_comm_group F] {R‚ÇÅ : Type u_7} [comm_ring R‚ÇÅ] [module R‚ÇÅ E] [module R‚ÇÅ F] {p q : submodule R‚ÇÅ E} (h : is_compl p q) : (‚Ü•p ‚Üí‚Çó[R‚ÇÅ] F) √ó (‚Ü•q ‚Üí‚Çó[R‚ÇÅ] F) ‚Üí‚Çó[R‚ÇÅ] E ‚Üí‚Çó[R‚ÇÅ] F
(L : first_order.language) (Œ± : Type w) [ie : is_empty Œ±] : L ‚âÉ·¥∏ L.with_constants Œ±
{n : Type u} [decidable_eq n] [fintype n] {Œ± : Type v} [comm_ring Œ±] (A B : matrix n n Œ±) : (A.mul B).adjugate = B.adjugate.mul A.adjugate
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {f : X ‚ü∂ Y} [category_theory.split_epi f] {c : category_theory.limits.kernel_fork f} (i : category_theory.limits.is_limit c) : (category_theory.limits.binary_bicone_of_split_epi_of_kernel i).is_bilimit
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] (U : topological_space.opens ‚Ü•(projective_spectrum.Top ùíú)) (x : ‚Ü•(projective_spectrum.Top ùíú)) (hx : x ‚àà U) : (algebraic_geometry.projective_spectrum.Proj.structure_sheaf ùíú).val.obj (opposite.op U) ‚ü∂ CommRing.of (homogeneous_localization ùíú (projective_spectrum.as_homogeneous_ideal x).to_ideal)
{M : Type u_4} [group_with_zero M] {f g : ‚Ñö ‚Üí*‚ÇÄ M} (same_on_int : f.comp (int.cast_ring_hom ‚Ñö).to_monoid_with_zero_hom = g.comp (int.cast_ring_hom ‚Ñö).to_monoid_with_zero_hom) : f = g
{Œ≤ : Type u_1} [comm_ring Œ≤] : fib_rec.char_poly = polynomial.X ^ 2 - (polynomial.X + 1)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (Q : C) (f : category_theory.over P) : f ‚âà ‚Üë0 ‚Üî f.hom = 0
{Œ± : Type u_1} {Œ≤ : Type u_2} (p : pmf Œ±) (f : Œ± ‚Üí pmf Œ≤) : p.bind_on_support (Œª (a : Œ±) (_x : a ‚àà p.support), f a) = p.bind f
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÇ] [has_one M‚ÇÇ] [has_pow M‚ÇÇ ‚Ñï] [has_inv M‚ÇÇ] [has_div M‚ÇÇ] [has_pow M‚ÇÇ ‚Ñ§] [comm_group M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (inv : ‚àÄ (x : M‚ÇÅ), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : M‚ÇÅ), f (x / y) = f x / f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (x ^ n) = f x ^ n) : comm_group M‚ÇÇ
{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] {X Y : C} : has_sub (X ‚ü∂ Y)
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] [decidable_rel disjoint] [decidable_rel has_le.le] (u : Œ±) (s : finset Œ±) : uv.is_compressed u u s
{Œ± : Type u_3} {Œ≤ : Type u_4} [linear_ordered_field Œ±] {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±} {r : Œ±} (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Œª (x : Œ≤), r * f x) l filter.at_top
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (t : cochain_complex.mk_struct V) : Œ£' (X‚ÇÄ X‚ÇÅ X‚ÇÇ : V) (d‚ÇÄ : X‚ÇÄ ‚ü∂ X‚ÇÅ) (d‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ), d‚ÇÄ ‚â´ d‚ÇÅ = 0
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} : {x // x.compatible} ‚âÉ {x // x.compatible}
{R : Type u} [ring R] (B : ring_filter_basis R) : topological_ring R
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) {x y : M} : x ‚àà S ‚Üí y ‚àà S ‚Üí x + y ‚àà S
 : znum ‚Üí znum ‚Üí znum
{A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) (h : x ‚â† 0) : (minpoly A x).coeff 0 ‚â† 0
{C : Type u} [category_theory.category C] (i p : category_theory.arrow C) : Prop
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (E : Type u_2) [normed_group E] [normed_space ùïú E] (H : Type u_3) [topological_space H] : Type (max u_2 u_3)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [preorder Œ±] {f : Œ± ‚Üí set Œ≤} {g : Œ± ‚Üí set Œ≥} (hf : monotone f) (hg : monotone g) : monotone (Œª (x : Œ±), f x √óÀ¢ g x)
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) (h : is_unit A.det) : (matrix n n Œ±)À£
{Œ± : Type u} {Œ≤ : Type v} [has_zero Œ≤] [decidable_eq Œ±] [decidable_eq Œ≤] : slim_check.total_function Œ± Œ≤ ‚Üí finset Œ±
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí. Œ≤) (l‚ÇÅ : filter Œ±) (l‚ÇÇ : filter Œ≤) : Prop
(V : Type u) [quiver V] (H : wide_subquiver V) : Type u
{C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) (X‚ÇÄ : C) (f : X‚ÇÄ ‚ü∂ X.obj (simplex_category.mk 0)) (w : ‚àÄ (i : simplex_category) (g‚ÇÅ g‚ÇÇ : simplex_category.mk 0 ‚ü∂ i), f ‚â´ X.map g‚ÇÅ = f ‚â´ X.map g‚ÇÇ) : category_theory.cosimplicial_object.augmented C
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) {D : Type u'} [category_theory.category D] [category_theory.limits.has_limit F] (G : C ‚•§ D) [category_theory.limits.has_limit (F ‚ãô G)] : G.obj (category_theory.limits.limit F) ‚ü∂ category_theory.limits.limit (F ‚ãô G)
{Œ± : Type u} [pseudo_emetric_space Œ±] {x : Œ±} {s : set Œ±} (h : is_closed s) : x ‚àà s ‚Üî emetric.inf_edist x s = 0
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_comm_monoid Œ±] [topological_space Œ±] (f : Œ≤ ‚Üí Œ±) (a : Œ±) : Prop
(Œ± : Type u_1) (n : ‚Ñï) : vector Œ± n ‚âÉ array n Œ±
 : option expr ‚Üí option expr ‚Üí tactic (option expr)
(R : Type u_1) [comm_semiring R] {M : Type u_2} {N : Type u_3} [add_comm_group M] [add_comm_group N] [module R M] [module R N] : free_add_monoid (M √ó N) ‚Üí+ tensor_product R M N
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) : Prop
{Œπ : Type u} {Œ± : Type v} [decidable_eq Œ±] (t : Œπ ‚Üí finset Œ±) (h : ‚àÄ (s : finset Œπ), s.card ‚â§ (s.bUnion t).card) (Œπ' : finset Œπ) : nonempty ‚Ü•(hall_matchings_on t Œπ')
 : clifford_algebra clifford_algebra_complex.Q ‚Üí‚Çê[‚Ñù] ‚ÑÇ
(loc : interactive.parse interactive.types.location) : tactic unit
{A : Type u_1} [add_monoid A] : distrib_mul_action (add_aut A) A
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {t : affine.triangle ‚Ñù P} {i‚ÇÅ i‚ÇÇ : fin 3} {p : P} (h‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ) (h‚ÇÅ : p ‚àà affine.simplex.altitude t i‚ÇÅ) (h‚ÇÇ : p ‚àà affine.simplex.altitude t i‚ÇÇ) : p = t.orthocenter
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (S : add_subsemigroup M) (f : add_hom M N) (hf : function.injective ‚áëf) : ‚Ü•S ‚âÉ+ ‚Ü•(add_subsemigroup.map f S)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (F : C ‚•§ D) [category_theory.creates_colimits_of_shape J F] [category_theory.limits.has_colimits_of_shape J D] : category_theory.limits.preserves_colimits_of_shape J F
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (X : C) : Type (max u‚ÇÅ v‚ÇÅ)
{C : Type u‚ÇÅ} [category_theory.small_category C] : category_theory.yoneda ‚ãô (category_theory.whiskering_left C·µí·µñ (C·µí·µñ ‚•§ Type u‚ÇÅ)·µí·µñ (Type u‚ÇÅ)).obj category_theory.yoneda.op ‚âÖ ùü≠ (C·µí·µñ ‚•§ Type u‚ÇÅ)
(p : ‚Ñï) {q : ‚Ñö} (hq : q ‚â† 0) : ‚àÉ (z : ‚Ñ§), padic_norm p q = ‚Üëp ^ -z
{V : Type u_1} [inner_product_space ‚Ñù V] (x y : V) : has_inner.inner x y = 0 ‚Üî inner_product_geometry.angle x y = real.pi / 2
{ùïú : Type u_1} [linear_ordered_field ùïú] {s : set ùïú} {f : ùïú ‚Üí ùïú} (hs : convex ùïú s) (hf : ‚àÄ {x y z : ùïú}, x ‚àà s ‚Üí z ‚àà s ‚Üí x < y ‚Üí y < z ‚Üí (f y - f x) / (y - x) ‚â§ (f z - f y) / (z - y)) : convex_on ùïú s f
 : tactic unit
{B : Type u} [quiver B] {a b : category_theory.free_bicategory B} (f g : a ‚ü∂ b) : subsingleton (f ‚ü∂ g)
(K : Type u_1) (V : Type u_2) [division_ring K] [add_comm_group V] [module K V] : Prop
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Œπ] {p : Œπ ‚Üí P} (hi : affine_independent k p) {sp : affine_subspace k P} [finite_dimensional k ‚Ü•(sp.direction)] (hle : affine_span k (set.range p) ‚â§ sp) (hc : fintype.card Œπ = finite_dimensional.finrank k ‚Ü•(sp.direction) + 1) : affine_span k (set.range p) = sp
{Œ± : Type u_1} [linear_ordered_add_comm_group Œ±] [archimedean Œ±] {a : Œ±} (ha : 0 < a) (g : Œ±) : ‚àÉ! (k : ‚Ñ§), k ‚Ä¢ a ‚â§ g ‚àß g < (k + 1) ‚Ä¢ a
(Œ± : Sort u_1) (Œ≤ : Sort u_2) : Sort (max 1 (imax u_2 u_1) u_1)
{n : ‚Ñï} {Œ± : typevec n} : Œ±.arrow Œ±
{H : Type u} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] (G : structure_groupoid H) [has_groupoid M G] (s : topological_space.opens M) [closed_under_restriction G] : has_groupoid ‚Ü•s G
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : R
{C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] (F : J ‚•§ C) [category_theory.limits.has_limit (category_theory.discrete.functor F.obj)] [category_theory.limits.has_limit (category_theory.discrete.functor (Œª (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), F.obj f.fst.snd))] [category_theory.limits.has_equalizers C] : category_theory.limits.limit_cone F
{Œ± : Type u} (T : set (set Œ±)) (empty_mem : ‚àÖ ‚àà T) (sInter_mem : ‚àÄ (A : set (set Œ±)), A ‚äÜ T ‚Üí ‚ãÇ‚ÇÄ A ‚àà T) (union_mem : ‚àÄ (A : set Œ±), A ‚àà T ‚Üí ‚àÄ (B : set Œ±), B ‚àà T ‚Üí A ‚à™ B ‚àà T) : topological_space Œ±
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f : V ‚Üí‚Çó[K] V} : function.injective ‚áëf ‚Üî function.surjective ‚áëf
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q R : C} {f : P ‚ü∂ Q} {g : Q ‚ü∂ R} (h : category_theory.exact f g) : (‚àÄ (a : ‚Ü•P), ‚áëg (‚áëf a) = 0) ‚àß ‚àÄ (b : ‚Ü•Q), ‚áëg b = 0 ‚Üí (‚àÉ (a : ‚Ü•P), ‚áëf a = b)
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} (incl : s ‚äÜ t) : metric.bounded t ‚Üí metric.bounded s
(Œ± : Type u) : category_theory.subobject Œ± ‚âÉo set Œ±
{Œ± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] (l : filter Œ±) (f : Œ± ‚Üí E) (g : Œ± ‚Üí F) : Prop
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (wf : well_founded r) (s : set Œ±) (h : set.bounded r s) : Œ±
{Œ± : Type u} (t : tactic Œ±) : tactic unit
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] : Top.sheaf (Type u_2) (projective_spectrum.Top ùíú)
{t : Type u ‚Üí Type u ‚Üí Type u} [bitraversable t] {Œ≤ : Type u} {F : Type u ‚Üí Type u} [applicative F] {Œ± Œ±' : Type u} (f : Œ± ‚Üí F Œ±') : t Œ± Œ≤ ‚Üí F (t Œ±' Œ≤)
{Œ≤ : Type u} {Œ± : Type v} [add_comm_monoid Œ≤] {s : finset Œ±} (hc : s.card ‚â§ 1) {f : Œ± ‚Üí Œ≤} {b : Œ≤} (h : s.sum (Œª (x : Œ±), f x) = b) (x : Œ±) (H : x ‚àà s) : f x = b
{n : ‚Ñï} (p : fin (n + 1)) (i : fin n) : ‚áë(p.succ_above) i ‚â† p
{Œ± : Type u'} {Œ≤ : Type v'} {n : ‚Ñï} (g : Œ± ‚Üí Œ≤ ‚äï fin n) (k : ‚Ñï) : Œ± ‚äï fin k ‚Üí Œ≤ ‚äï fin (n + k)
{Œπ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Œπ ‚Üí set X} {s : set X} (hs : is_closed s) (uo : ‚àÄ (i : Œπ), is_open (u i)) (uf : ‚àÄ (x : X), x ‚àà s ‚Üí {i : Œπ | x ‚àà u i}.finite) (us : s ‚äÜ ‚ãÉ (i : Œπ), u i) : ‚àÉ (v : Œπ ‚Üí set X), s ‚äÜ set.Union v ‚àß (‚àÄ (i : Œπ), is_open (v i)) ‚àß ‚àÄ (i : Œπ), closure (v i) ‚äÜ u i
{G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x)
{C : Type u} [category_theory.category C] (J‚ÇÅ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : J‚ÇÅ.is_closed (J‚ÇÅ.close S)
(Œ± : Type u) : Type u
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [module ùïú E] [module ùïú Œ≤] [linear_order E] {s : set E} {f : E ‚Üí Œ≤} (hs : convex ùïú s) (hf : ‚àÄ ‚¶Éx y : E‚¶Ñ, x ‚àà s ‚Üí y ‚àà s ‚Üí x < y ‚Üí ‚àÄ ‚¶Éa b : ùïú‚¶Ñ, 0 < a ‚Üí 0 < b ‚Üí a + b = 1 ‚Üí a ‚Ä¢ f x + b ‚Ä¢ f y ‚â§ f (a ‚Ä¢ x + b ‚Ä¢ y)) : concave_on ùïú s f
{Œ± : Type u_1} {P : set Œ± ‚Üí Prop} {m : Œ† (s : set Œ±), P s ‚Üí ennreal} {P0 : P ‚àÖ} {m0 : m ‚àÖ P0 = 0} {s t : set Œ±} (h : ‚àÄ (u : set Œ±), (s ‚à© u).nonempty ‚Üí (t ‚à© u).nonempty ‚Üí ¬¨P u) : ‚áë(measure_theory.induced_outer_measure m P0 m0) (s ‚à™ t) = ‚áë(measure_theory.induced_outer_measure m P0 m0) s + ‚áë(measure_theory.induced_outer_measure m P0 m0) t
{n : ‚Ñï} (A B : finset (fin n)) : (finset.image (Œª (i : fin n), ‚Üëi) A).to_colex < (finset.image (Œª (i : fin n), ‚Üëi) B).to_colex ‚Üî A.to_colex < B.to_colex
{C : Type u} [category_theory.category C] (A : C) [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] : category_theory.limits.prod.functor.obj A ‚ä£ category_theory.exp A
 : tactic.instance_cache ‚Üí expr ‚Üí expr ‚Üí tactic (tactic.instance_cache √ó expr √ó expr)
{Œ± : Type u_1} [metric_space Œ±] {Œ≤ : Type u} [nonempty Œ≤] (p : besicovitch.tau_package Œ≤ Œ±) : ordinal ‚Üí ‚Ñï
 : ‚Ñï ‚Üí lazy_list ‚Ñï+
{m : Type u} {n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] [fintype m] [decidable_eq m] (A : matrix m m Œ±) (B : matrix m n Œ±) (C : matrix n m Œ±) (D : matrix n n Œ±) [invertible A] : (matrix.from_blocks A B C D).det = A.det * (D - (C.mul (‚Öü A)).mul B).det
(x : ‚ÑÇ) : ‚ÑÇ
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} [uniform_space Œ±] [uniform_space Œ≤] [uniform_space Œ≥] [uniform_space Œ¥] (h‚ÇÅ : Œ± ‚âÉ·µ§ Œ≤) (h‚ÇÇ : Œ≥ ‚âÉ·µ§ Œ¥) : Œ± √ó Œ≥ ‚âÉ·µ§ Œ≤ √ó Œ¥
{Œ± : Type u} (l : thunk (list Œ±)) : dlist Œ±
{M : Type u_1} [comm_monoid M] (S : submonoid M) (m : multiset M) (hm : ‚àÄ (a : M), a ‚àà m ‚Üí a ‚àà S) : m.prod ‚àà S
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [partial_order Œπ] [Œ† (i : Œπ), partial_order (Œ± i)] : partial_order (Œ£‚Çó' (i : Œπ), Œ± i)
(R : Type u) [comm_ring R] : Type u ‚•§ Algebra R
{M : Type u_1} [monoid M] (n : M) (m : ‚Ñï) : ‚Ü•(submonoid.powers n)
 : Type
{M : Type u_1} [mul_one_class M] (S : submonoid M) : mul_one_class ‚Ü•S
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} {E : Type u‚ÇÉ} [category_theory.category C] [category_theory.category D] [category_theory.category E] (F : C ‚•§ D) (G : D ‚•§ E) [Fr : category_theory.reflective F] [Gr : category_theory.reflective G] : category_theory.reflective (F ‚ãô G)
(J : Type v) : Type v
(Œ± : Type u) [subsingleton Œ±] : free_ring Œ± ‚âÉ+* free_comm_ring Œ±
{J : Type v} [category_theory.small_category J] [category_theory.fin_category J] {k : Type v} [field k] (F : J ‚•§ FinVect k) : category_theory.creates_limit F (category_theory.forget‚ÇÇ (FinVect k) (Module k))
{G : Type u_1} [group G] [topological_space G] {N : Type u_2} [group N] [topological_space N] (f : G ‚Üí* N) (hf : continuous ‚áëf) (H : open_subgroup N) : open_subgroup G
{R : Type u} [semiring R] (p : polynomial R) : Prop
{Œ± : Type u} [canonically_ordered_add_monoid Œ±] : canonically_ordered_add_monoid (with_zero Œ±)
{a b : ‚Ñï} (hab : a.coprime b) : (a * b).factorization.support = a.factorization.support ‚à™ b.factorization.support
{Œ≥ : Type} (tooltip : widget.tc subexpr Œ≥) : widget.tc expr Œ≥
(b : bool) : ‚Ñï
 : Type
(Œ± : Type u_1) : basis Œ± ‚Ñ§ (free_abelian_group Œ±)
{Œ± : Type u_1} {M : Type u_5} [has_zero M] (f : Œ± ‚Üí M) (hf : (function.support f).finite) : Œ± ‚Üí‚ÇÄ M
{E : Type u_2} [semi_normed_group E] [star_add_monoid E] [normed_star_group E] : normed_group_hom E E
{Œ± : Type u} [group Œ±] : group_with_zero (with_zero Œ±)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : has_dist.dist p3 p1 = has_dist.dist p3 p2) : euclidean_geometry.angle p3 (midpoint ‚Ñù p1 p2) p2 = real.pi / 2
(R : Type u) [comm_ring R] (x : ‚Ü•(algebraic_geometry.prime_spectrum.Top R)) : CommRing.of (localization.at_prime (prime_spectrum.as_ideal x)) ‚ü∂ (algebraic_geometry.Spec.structure_sheaf R).val.stalk x
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] [nontrivial k] {s : set P} {p : P} (hp : p ‚àà s) (w : ‚Ü•s ‚Üí kÀ£) : affine_span k (set.range (Œª (q : ‚Ü•s), ‚áë(affine_map.line_map p ‚Üëq) ‚Üë(w q))) = affine_span k s
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
{Œ± : Type u} {Œ≤ : Type v} : Œ± ‚äï Œ≤ ‚Üí bool
{Œ± : Type u_1} [has_add Œ±] (a : Œ±) (s : set Œ±) : set Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [pred_order Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : antitone f) : pairwise (disjoint on Œª (n : Œ±), set.Ico (f n) (f (order.pred n)))
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w‚ÇÅ} [category_theory.category D] {E : Type w‚ÇÇ} [category_theory.category E] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] [Œ† (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)·µí·µñ (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] (G : E ‚•§ D) : category_theory.Sheaf J E ‚•§ category_theory.Sheaf J D
(p : ‚Ñï) [hp : fact (nat.prime p)] : prime ‚Üëp ‚Üî p % 4 = 3
{Œ± : Type} (rels : set (free_group Œ±)) : Type
{M : Type u_1} [mul_one_class M] (S : submonoid M) : ‚Ü•S ‚Üí* M
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type v} (f : J ‚Üí C) [category_theory.limits.reflects_limit (category_theory.discrete.functor f) G] {P : C} (g : Œ† (j : J), P ‚ü∂ f j) (t : category_theory.limits.is_limit (category_theory.limits.fan.mk (G.obj P) (Œª (j : J), G.map (g j)))) : category_theory.limits.is_limit (category_theory.limits.fan.mk P g)
{V : Type u_1} [inner_product_space ‚Ñù V] (x y : V) {r : ‚Ñù} (hr : r < 0) : inner_product_geometry.angle x (r ‚Ä¢ y) = inner_product_geometry.angle x (-y)
{M : Type u_1} {N : Type u_2} {F : Type u_3} [has_add M] [has_add N] [add_hom_class F M N] (f : F) (hf : function.bijective ‚áëf) : M ‚âÉ+ N
{Œ± : Type u} [topological_space Œ±] {a : Œ±} {p : Œ± ‚Üí Prop} : (‚àÄ·∂† (x : Œ±) in nhds a, p x) ‚Üî ‚àÉ (t : set Œ±), (‚àÄ (x : Œ±), x ‚àà t ‚Üí p x) ‚àß is_open t ‚àß a ‚àà t
{Œ± : Type u_1} [measurable_space Œ±] (j : measure_theory.jordan_decomposition Œ±) : measure_theory.signed_measure Œ±
(Œ± : Type u) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{G : Type u_1} [group G] {H‚ÇÅ H‚ÇÇ H‚ÇÉ : subgroup G} (h1 : ‚ÅÖ‚ÅÖH‚ÇÇ,H‚ÇÉ‚ÅÜ,H‚ÇÅ‚ÅÜ = ‚ä•) (h2 : ‚ÅÖ‚ÅÖH‚ÇÉ,H‚ÇÅ‚ÅÜ,H‚ÇÇ‚ÅÜ = ‚ä•) : ‚ÅÖ‚ÅÖH‚ÇÅ,H‚ÇÇ‚ÅÜ,H‚ÇÉ‚ÅÜ = ‚ä•
{Œ± : Type u_1} {M : Type u_5} [has_zero M] (a : Œ±) (f : Œ± ‚Üí‚ÇÄ M) : Œ± ‚Üí‚ÇÄ M
{M : Type u_1} [monoid M] : M·µê·µí·µñÀ£ ‚âÉ* MÀ£·µê·µí·µñ
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] [category_theory.has_projective_resolutions C] [category_theory.preadditive D] [category_theory.limits.has_zero_object D] [category_theory.limits.has_equalizers D] [category_theory.limits.has_cokernels D] [category_theory.limits.has_images D] [category_theory.limits.has_image_maps D] (F : C ‚•§ D) [F.additive] (n : ‚Ñï) (X : C) [category_theory.projective X] : (F.left_derived (n + 1)).obj X ‚âÖ 0
 : ‚Ñï ‚Üí pexpr
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] (h : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚Üí M‚ÇÇ
{Œ± : Type u} [topological_space Œ±] {p : Œ± ‚Üí Prop} {a : Œ±} (h : ‚àÄ·∂† (y : Œ±) in nhds a, p y) : ‚àÄ·∂† (y : Œ±) in nhds a, ‚àÄ·∂† (x : Œ±) in nhds y, p x
(C : Type u) [category_theory.category C] (n : ‚Ñï) : Type (max v u)
{R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R ‚Üí+* P} (hg : ‚àÄ (y : ‚Ü•M), is_unit (‚áëg ‚Üëy)) : S ‚Üí+* P
{Œ± : Type u_1} [pseudo_emetric_space Œ±] (C : ennreal) {f : ‚Ñï ‚Üí Œ±} (hu : ‚àÄ (n : ‚Ñï), has_edist.edist (f n) (f (n + 1)) ‚â§ C / 2 ^ n) {a : Œ±} (ha : filter.tendsto f filter.at_top (nhds a)) (n : ‚Ñï) : has_edist.edist (f n) a ‚â§ 2 * C / 2 ^ n
(A : Type u_1) (B : Type u_2) [field A] [ring B] [algebra A B] [nontrivial B] : minpoly A 1 = polynomial.X - 1
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {f : E ‚Üí F √ó G} (hf : cont_diff ùïú n f) : cont_diff ùïú n (Œª (x : E), (f x).fst)
 : Type (u_1+1)
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : polynomial A ‚âÉ‚Çê[R] tensor_product R A (polynomial R)
(s : set ‚Ñï) [decidable_pred (Œª (_x : ‚Ñï), _x ‚àà s)] [infinite ‚Ü•s] : ‚Ñï ‚Ü™o ‚Ñï
{C : Type u} [category_theory.category C] [category_theory.enough_projectives C] (X : C) : category_theory.projective.over X ‚ü∂ X
(R : Type u_1) [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] : is_unit ‚Üëp ‚Üî ¬¨p ‚à£ ring_char R
(S : Type u‚ÇÇ) [comm_semiring S] {A : Type u‚ÇÉ} [semiring A] [algebra S A] (s : A ‚Üí A ‚Üí Prop) : A ‚Üí‚Çê[S] ring_quot s
{R : Type u} [ring R] {Œπ : Type v} (Z : Œπ ‚Üí Module R) [category_theory.limits.has_product Z] : ‚àè Z ‚âÖ Module.of R (Œ† (i : Œπ), ‚Ü•(Z i))
(C : Type u_1) [category_theory.category C] [category_theory.preadditive C] : category_theory.is_idempotent_complete C ‚Üî ‚àÄ (X : C) (p : X ‚ü∂ X), p ‚â´ p = p ‚Üí category_theory.limits.has_kernel p
{Œ± : Type u} [topological_space Œ±] {Œ≥ : Type u} [topological_space Œ≥] [t2_space Œ≥] [compact_space Œ≥] {f : Œ± ‚Üí Œ≥} (hf : continuous f) : stone_cech Œ± ‚Üí Œ≥
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) (B : D) : category_theory.is_reflexive_pair (F.map (G.map (adj.counit.app B))) (adj.counit.app (F.obj (G.obj B)))
{R : Type u_1} {M : Type u_9} {M‚ÇÇ : Type u_11} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] (f : M ‚Üí‚Çó[R] M‚ÇÇ) : M ‚Üí+[R] M‚ÇÇ
 : (nim 0).relabelling 0
(p1 p2 : linarith.pcomp) (a : ‚Ñï) : option linarith.pcomp
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÇ ‚âÉSL[œÉ‚ÇÇ‚ÇÅ] M‚ÇÅ
{Œ± : Type u_3} [semilattice_inf Œ±] (a : Œ±) : filter.map coe filter.at_bot = filter.at_bot
{X : Type u} {m‚ÇÅ m‚ÇÇ : X ‚Üí X ‚Üí X} {e‚ÇÅ e‚ÇÇ : X} (h‚ÇÅ : eckmann_hilton.is_unital m‚ÇÅ e‚ÇÅ) (h‚ÇÇ : eckmann_hilton.is_unital m‚ÇÇ e‚ÇÇ) (distrib : ‚àÄ (a b c d : X), m‚ÇÅ (m‚ÇÇ a b) (m‚ÇÇ c d) = m‚ÇÇ (m‚ÇÅ a c) (m‚ÇÅ b d)) : is_associative X m‚ÇÇ
(args : list expr) (univs : list level) (l : list (name √ó expr)) : bool
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : dense (closure s) ‚Üí dense s
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A B : matrix n n Œ±) (h : A.mul B = 1) : invertible A
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [category_theory.limits.has_pullback f g] : category_theory.limits.pullback f g ‚ü∂ Y
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] (D : J ‚•§ T.algebra) (c : category_theory.limits.cone (D ‚ãô T.forget)) : category_theory.limits.cone (D ‚ãô T.forget)
 : category_theory.limits.walking_cospan
(G : Type u_1) (P : Type u_2) : Type (max u_1 u_2)
{R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R ‚Üî ‚àÄ {x : K}, is_integral R x ‚Üí (‚àÉ (y : R), ‚áë(algebra_map R K) y = x)
{C : Type u‚ÇÅ} [category_theory.category C] {X‚ÇÅ‚ÇÅ X‚ÇÅ‚ÇÇ X‚ÇÅ‚ÇÉ X‚ÇÇ‚ÇÅ X‚ÇÇ‚ÇÇ X‚ÇÇ‚ÇÉ : C} {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ‚ÇÉ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÉ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ} {v‚ÇÅ‚ÇÉ : X‚ÇÅ‚ÇÉ ‚ü∂ X‚ÇÇ‚ÇÉ} (s : category_theory.is_pullback h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ) (t : category_theory.is_pullback h‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÉ h‚ÇÇ‚ÇÇ) : category_theory.is_pullback (h‚ÇÅ‚ÇÅ ‚â´ h‚ÇÅ‚ÇÇ) v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÉ (h‚ÇÇ‚ÇÅ ‚â´ h‚ÇÇ‚ÇÇ)
{Œ± : Type u_1} : bool √ó Œ± ‚Üí option Œ±
(n ŒΩ : ‚Ñï) : C(‚Ü•unit_interval, ‚Ñù)
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {M' : Type w} [add_comm_monoid M'] [module R M'] (B : bilin_form R M') (l r : M ‚Üí‚Çó[R] M') : bilin_form R M
 : Compactum ‚•§ Type u_1
{C : Type u‚ÇÅ} [category_theory.category C] (Z : C ‚Üí Prop) : category_theory.category {X // Z X}
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [mul_one_class Œ≤] : mul_one_class Œ±
{M : Type u_1} {N : Type u_2} {P : Type u_3} {Q : Type u_4} [mul_one_class M] [mul_one_class N] [comm_monoid P] [comm_monoid Q] (f : M ‚âÉ* N) (g : P ‚âÉ* Q) : (M ‚Üí* P) ‚âÉ* (N ‚Üí* Q)
{R : Type u} {A M B : Type v} [ring R] [add_comm_group A] [module R A] [add_comm_group B] [module R B] [add_comm_group M] [module R M] {j : A ‚Üí‚Çó[R] M} {g : M ‚Üí‚Çó[R] B} {f : B ‚Üí‚Çó[R] M} (hj : function.injective ‚áëj) (exac : j.range = g.ker) (h : g.comp f = linear_map.id) : (A √ó B) ‚âÉ‚Çó[R] M
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (f : Œ± ‚Üí option Œ≤ ‚Üí Œ≥) : list Œ± ‚Üí list Œ≤ ‚Üí list Œ≥
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÉ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÑ : X‚ÇÉ ‚ü∂ Y‚ÇÇ) [category_theory.limits.has_pullback f‚ÇÅ f‚ÇÇ] [category_theory.limits.has_pullback f‚ÇÉ f‚ÇÑ] [category_theory.limits.has_pullback (category_theory.limits.pullback.snd ‚â´ f‚ÇÉ) f‚ÇÑ] : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (category_theory.limits.pullback.fst ‚â´ category_theory.limits.pullback.fst) (category_theory.limits.pullback.lift (category_theory.limits.pullback.fst ‚â´ category_theory.limits.pullback.snd) category_theory.limits.pullback.snd _) _)
{R : Type u} [ring R] (T : subring R) (p : polynomial ‚Ü•T) : polynomial R
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] {E : Type u‚ÇÉ} [category_theory.category E] [category_theory.monoidal_category E] [category_theory.braided_category E] (F : category_theory.braided_functor C D) (G : category_theory.braided_functor D E) : category_theory.braided_functor C E
{R : Type u} [ring R] (s : subring R) : submonoid R
{R : Type u_1} [ordered_ring R] (s : subring R) : ordered_ring ‚Ü•s
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] {A : C} : category_theory.over A ‚Üí category_theory.over A ‚•§ category_theory.over A
{Œπ : Type u_1} {Œπ' : Type u_2} {R : Type u_3} {M : Type u_5} {v : Œπ ‚Üí M} [semiring R] [add_comm_monoid M] [module R M] (h : linear_independent R v) (f : Œπ' ‚Üí Œπ) (hf : function.injective f) : linear_independent R (v ‚àò f)
(X T : Top) : inhabited (Top.prelocal_predicate (Œª (x : ‚Ü•X), ‚Ü•T))
{Œπ : Type u_1} [fintype Œπ] {Œ± : Type u_2} [group Œ±] [measure_theory.measure_space Œ±] [measure_theory.sigma_finite measure_theory.measure_space.volume] [has_measurable_mul Œ±] [measure_theory.measure_space.volume.is_mul_left_invariant] : measure_theory.measure_space.volume.is_mul_left_invariant
{Œ± : Type u_1} {Œ≤ : Type u_2} (x : option Œ±) : (Œ† (a : Œ±), a ‚àà x ‚Üí option Œ≤) ‚Üí option Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} (F : C ‚•§ D) {c : category_theory.limits.cone K} (t : category_theory.limits.is_limit (F.map_cone c)) [category_theory.limits.reflects_limit K F] : category_theory.limits.is_limit c
{X : Type u_1} [topological_space X] {Œ± : Type u_2} {Œ≤ : Type u_3} (f : X ‚Üí Œ±) (g : Œ± ‚Üí Œ≤) (h : is_locally_constant (g ‚àò f)) (inj : function.injective g) : is_locally_constant f
{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (s : set M) (r : R) (hr : is_unit r) : submodule.span R (r ‚Ä¢ s) = submodule.span R s
(e : expr) : tactic (‚Ñï √ó expr)
{Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] [nonempty Œπ] {f : Œπ ‚Üí Œ±} {c : Œ±} (H : ‚àÄ (x : Œπ), f x ‚â§ c) : supr f ‚â§ c
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : is_preconnected s ‚Üî ‚àÄ (u v : set Œ±), is_open u ‚Üí is_open v ‚Üí s ‚äÜ u ‚à™ v ‚Üí s ‚à© (u ‚à© v) = ‚àÖ ‚Üí s ‚äÜ u ‚à® s ‚äÜ v
{E : Type u} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {a : E} (h : is_local_min f a) : fderiv ‚Ñù f a = 0
{Œ± : Type u} (s : stream Œ±) : seq Œ±
(X : Profinite) : category_theory.limits.is_limit X.as_limit_cone
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_coequalizer f g] : category_theory.limits.cofork f g
{Œ± : Type u_1} (k : ‚Ñï) : (vector3 Œ± k ‚Üí Prop) ‚Üí Prop
(R : Type u_1) {S : Type u_6} {M : Type u_7} {M‚ÇÇ : Type u_9} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] [module S M] [module S M‚ÇÇ] [linear_map.compatible_smul M M‚ÇÇ R S] (f : M ‚âÉ‚Çó[S] M‚ÇÇ) : M ‚âÉ‚Çó[R] M‚ÇÇ
 : cc_state ‚Üí expr ‚Üí tactic expr
(S : (Type u)·µí·µñ ‚•§ Type u) (hs : category_theory.presieve.is_sheaf category_theory.types_grothendieck_topology S) (Œ± : Type u) (f : Œ± ‚Üí S.obj (opposite.op punit)) : S.obj (opposite.op Œ±)
(L : first_order.language) (M : Type u_3) [L.Structure M] (N : Type u_4) [L.Structure N] [(L.with_constants M).Structure N] [(L.Lhom_with_constants M).is_expansion_on N] [N ‚ä® L.elementary_diagram M] : L.elementary_embedding M N
{ùïú : Type u_3} {E : Type u_4} [normed_field ùïú] [add_comm_group E] [normed_space ‚Ñù ùïú] [module ùïú E] [has_scalar ‚Ñù E] [is_scalar_tower ‚Ñù ùïú E] (p : seminorm ùïú E) : convex_on ‚Ñù set.univ ‚áëp
(w‚ÇÅ w‚ÇÇ p‚ÇÅ p‚ÇÇ : nnreal) : w‚ÇÅ + w‚ÇÇ = 1 ‚Üí p‚ÇÅ ^ ‚Üëw‚ÇÅ * p‚ÇÇ ^ ‚Üëw‚ÇÇ ‚â§ w‚ÇÅ * p‚ÇÅ + w‚ÇÇ * p‚ÇÇ
(p : nat.primes) : prime_multiset
(prove : tactic.itauto.context ‚Üí tactic.itauto.prop ‚Üí ‚Ñï ‚Üí bool √ó tactic.itauto.proof √ó ‚Ñï) : tactic.itauto.context ‚Üí tactic.itauto.prop ‚Üí ‚Ñï ‚Üí bool √ó tactic.itauto.proof √ó ‚Ñï
(Œ± : Type u_1) [has_sizeof Œ±] : Type u_1
{Œ± : Type u} [t : topological_space Œ±] [topological_space.second_countable_topology Œ±] {f : Œ± ‚Üí set Œ±} (hf : ‚àÄ (x : Œ±), f x ‚àà nhds x) : ‚àÉ (s : set Œ±), s.countable ‚àß (‚ãÉ (x : Œ±) (H : x ‚àà s), f x) = set.univ
{a b c : ‚Ñ§} (habc : a ‚à£ b * c) (hab : a.gcd b = 1) : a ‚à£ c
 : ‚ÑÇ ‚âÉL[‚Ñù] ‚Ñù √ó ‚Ñù
 : real.sin (real.pi / 3) ^ 2 = 3 / 4
{Œ± : Type u_1} {r‚ÇÅ r‚ÇÇ : setoid Œ±} : r‚ÇÅ = r‚ÇÇ ‚Üî r‚ÇÅ.classes = r‚ÇÇ.classes
{M : Type u_3} {N : Type u_4} [add_monoid M] [add_monoid N] (f : M ‚Üí+ N) (hf : ‚àÄ (x : M), is_add_unit (‚áëf x)) : M ‚Üí+ add_units N
{M : Type u_5} {N : Type u_6} [monoid M] [monoid N] : (M √ó N)À£ ‚âÉ* MÀ£ √ó NÀ£
 : subgroup.normal_closure {‚ü®fin_rotate 5, _‚ü©} = ‚ä§
{R : Type u_2} {M‚ÇÅ : Type u_3} {M‚ÇÇ : Type u_4} [ring R] [add_comm_group M‚ÇÅ] [add_comm_group M‚ÇÇ] [module R M‚ÇÅ] [module R M‚ÇÇ] (Q‚ÇÅ : quadratic_form R M‚ÇÅ) (Q‚ÇÇ : quadratic_form R M‚ÇÇ) : quadratic_form R (M‚ÇÅ √ó M‚ÇÇ)
{R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M ‚Üí‚Çó[R] M) : ‚áë(polynomial.aeval f) f.charpoly = 0
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {M' : Type u_3} [add_comm_group M'] [module R M'] (f : M ‚âÉ‚Çó[R] M) (e : M ‚âÉ‚Çó[R] M') : ‚áëlinear_equiv.det ((e.symm.trans f).trans e) = ‚áëlinear_equiv.det f
{Œ± : Type u_1} {c : set (set Œ±)} (H : ‚àÄ (a : Œ±), ‚àÉ! (b : set Œ±) (H : b ‚àà c), a ‚àà b) {x : Œ±} {b b' : set Œ±} (hc : b ‚àà c) (hb : x ‚àà b) (hc' : b' ‚àà c) (hb' : x ‚àà b') : b = b'
{x y : pgame} (h : x.lf y) (ox : x.numeric) (oy : y.numeric) : x < y
{ùïú : Type u_1} {F : Type u_3} [is_R_or_C ùïú] [add_comm_group F] [module ùïú F] [c : inner_product_space.core ùïú F] : normed_space ùïú F
{V : Type u} : has_sup (simple_graph V)
{Œì : Type u_1} [inhabited Œì] {l‚ÇÅ l‚ÇÇ : list Œì} (h : turing.blank_rel l‚ÇÅ l‚ÇÇ) : {l // turing.blank_extends l l‚ÇÅ ‚àß turing.blank_extends l l‚ÇÇ}
{R' : Type u_1} {Œ± : Type u_2} [semiring R'] [add_comm_monoid Œ±] [module R' Œ±] (S : subsemiring R') : module ‚Ü•S Œ±
{R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ‚â† 2) : set.inj_on coe {0, 1, -1}
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : set Œ≤) : set Œ±
{Œπ : Type u_1} {N : Type u_5} [dec_Œπ : decidable_eq Œπ] [add_comm_group N] {p : Œπ ‚Üí add_subgroup N} (h : complete_lattice.independent p) : function.injective ‚áë(dfinsupp.sum_add_hom (Œª (i : Œπ), (p i).subtype))
{Œ± : Type u} [linear_ordered_field Œ±] [topological_space Œ±] [order_topology Œ±] : filter.tendsto (Œª (r : Œ±), r‚Åª¬π) filter.at_top (nhds_within 0 (set.Ioi 0))
 : is_cyclic (quaternion_group 1)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ‚Ñ§] {X Y Z : category_theory.differential_object C} (f : X.hom Y) (g : Y.hom Z) : X.hom Z
{n : Type u_3} {Œ± : Type v} {Œ≤ : Type w} [has_mul Œ±] [has_mul Œ≤] (f : Œ± ‚Üí Œ≤) (r : Œ±) (A : matrix n n Œ±) (hf : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±), f (a‚ÇÅ * a‚ÇÇ) = f a‚ÇÅ * f a‚ÇÇ) : (r ‚Ä¢ A).map f = f r ‚Ä¢ A.map f
{S : Type v} (s : S) {R : Type u_1} [linear_ordered_ring R] [set_like S R] [subring_class S R] : linear_ordered_ring ‚Ü•s
{Œ∑ : Type u_2} {Gs : Œ∑ ‚Üí Type u_3} [Œ† (i : Œ∑), group (Gs i)] [‚àÄ (i : Œ∑), group.is_nilpotent (Gs i)] (n : ‚Ñï) (h : ‚àÄ (i : Œ∑), group.nilpotency_class (Gs i) ‚â§ n) : group.is_nilpotent (Œ† (i : Œ∑), Gs i)
{Œ± : Type u_1} [preorder Œ±] (a b : Œ±) : set Œ±
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (K : lie_subalgebra R L) : lie_submodule R ‚Ü•K L
{M‚ÇÄ : Type u_1} [monoid_with_zero M‚ÇÄ] (u : M‚ÇÄÀ£) : ring.inverse ‚Üëu = ‚Üëu‚Åª¬π
{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.non_preadditive_abelian C
{V : Type u} {G : simple_graph V} (G' : G.subgraph) : set (sym2 V)
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] (D : Type u‚ÇÇ) [category_theory.category D] [category_theory.monoidal_category D] : category_theory.lax_monoidal_functor C D ‚•§ Mon_ C ‚•§ Mon_ D
 : tactic tactic.proof_state
{n m : ‚Ñï} (F : typevec n ‚Üí Type u_1) (G : fin2 n ‚Üí typevec m ‚Üí Type u) (v : typevec m) : Type u_1
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {x : E} {s t : set E} (h : nhds_within x s = nhds_within x t) : tangent_cone_at ùïú s x = tangent_cone_at ùïú t x
{ùïú : Type u_1} [linear_ordered_field ùïú] {s : set ùïú} {f : ùïú ‚Üí ùïú} (hf : concave_on ùïú s f) {x y z : ùïú} (hx : x ‚àà s) (hz : z ‚àà s) (hxy : x < y) (hyz : y < z) : (f z - f y) / (z - y) ‚â§ (f y - f x) / (y - x)
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] {i j : Œπ} (w : free_product.neword M i j) : free_product.word M
(Œ± : Type u_1) (Œ≤ : Type u_2) : equiv.perm Œ± √ó equiv.perm Œ≤ ‚Üí* equiv.perm (Œ± ‚äï Œ≤)
 : tactic expr
{G‚ÇÅ : Type u_3} {G‚ÇÇ : Type u_4} {G‚ÇÉ : Type u_5} [group G‚ÇÅ] [group G‚ÇÇ] [group G‚ÇÉ] (f : G‚ÇÅ ‚Üí* G‚ÇÇ) (hf : function.surjective ‚áëf) : {g // f.ker ‚â§ g.ker} ‚âÉ (G‚ÇÇ ‚Üí* G‚ÇÉ)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] (F : J ‚•§ C) : C·µí·µñ ‚•§ Type (max u‚ÇÅ v‚ÇÉ)
{X : Type u} {m‚ÇÅ : X ‚Üí X ‚Üí X} {e‚ÇÅ : X} (h‚ÇÅ : eckmann_hilton.is_unital m‚ÇÅ e‚ÇÅ) [G : group X] (distrib : ‚àÄ (a b c d : X), m‚ÇÅ (a * b) (c * d) = m‚ÇÅ a c * m‚ÇÅ b d) : comm_group X
{Œ± : Type u} [pseudo_emetric_space Œ±] (E : set Œ±) {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) : frontier (metric.thickening Œ¥ E) ‚äÜ {x : Œ± | emetric.inf_edist x E = ennreal.of_real Œ¥}
{C : Type u} [category_theory.category C] (G : C) : Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {t : set F} (hs : unique_diff_on ùïú s) (ht : unique_diff_on ùïú t) : unique_diff_on ùïú (s √óÀ¢ t)
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] (D : J ‚•§ T.algebra) (c : category_theory.limits.cone (D ‚ãô T.forget)) (t : category_theory.limits.is_limit c) : category_theory.limits.is_limit (category_theory.monad.forget_creates_limits.lifted_cone D c t)
{X : Type u_1} [normed_group X] [normed_space ‚Ñù X] : pregroupoid X
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_mul Œ±] [preorder Œ±] [preorder Œ≤] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] {f g : Œ≤ ‚Üí Œ±} (hf : monotone f) (hg : strict_mono g) : strict_mono (Œª (x : Œ≤), f x * g x)
{Œ± : Type u_1} [uniform_space Œ±] : (fin 2 ‚Üí Œ±) ‚âÉ·µ§ Œ± √ó Œ±
{Œ± : Type u_3} [semilattice_inf Œ±] (a : Œ±) : filter.at_bot = filter.comap coe filter.at_bot
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [add_comm_monoid Œπ] [decidable_eq Œπ] [comm_ring R] [comm_ring A] [algebra R A] (ùíú : Œπ ‚Üí submodule R A) [graded_algebra ùíú] (x : ideal A) [x.is_prime] : Type (max u_1 u_3)
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] {P : C·µí·µñ ‚•§ D} (hP : category_theory.presheaf.is_sheaf J P) : P ‚âÖ J.sheafify P
(Œ± : Type u) [measurable_space Œ±] (Œ≤ : Type v) : Type (max u v)
{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R
 : tactic string
 : Type (max (u+1) u (v+1))
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (f : Œ† (x : Œ±), Œ≤ x ‚Üí bool) (s : finmap Œ≤) : bool
(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ‚Ñï) [hq : exp_char R q] : nat.prime q ‚à® q = 1
{S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c
(A : Type y) [add_comm_group A] : A ‚âÉ+ (‚Ñ§ ‚Üí+ A)
(R : Type u) [comm_ring R] : Top.local_predicate (algebraic_geometry.structure_sheaf.localizations R)
{Œ± : Type u_1} (l : list Œ±) (n : ‚Ñï) : list Œ±
(n : name) : tactic name
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] (f : measure_theory.simple_func Œ± Œ≤) : finset Œ≤
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : Z.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : (category_theory.limits.pullback f g).open_cover
{M : Type u_1} {N : Type u_2} [unique M] [unique N] [has_add M] [has_add N] : M ‚âÉ+ N
(ùïú : Type u) (G : Type wG) (G' : Type wG') [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] {k l n : ‚Ñï} {s : finset (fin n)} (hk : s.card = k) (hl : s·∂ú.card = l) : continuous_multilinear_map ùïú (Œª (i : fin n), G) G' ‚âÉ‚Çó·µ¢[ùïú] continuous_multilinear_map ùïú (Œª (i : fin k), G) (continuous_multilinear_map ùïú (Œª (i : fin l), G) G')
(Œ± : Type u) {g : Type} [random_gen g] [random Œ±] : rand_g g Œ±
(h_simp : interactive.parse (optional (lean.parser.tk "!"))) (a : interactive.parse lean.parser.ident) (tp : interactive.parse (optional (lean.parser.tk ":" *> interactive.types.texpr))) (_x : interactive.parse (lean.parser.tk ":=")) (pv : interactive.parse interactive.types.texpr) (rev_name : interactive.parse opt_dir_with) : tactic unit
{R : Type u_1} [semiring R] (f : polynomial R) : polynomial R
{Œ± : Type u} [pseudo_emetric_space Œ±] {s t : set Œ±} : emetric.Hausdorff_edist s (closure t) = emetric.Hausdorff_edist s t
{M : Type u_1} [mul_one_class M] (S : submonoid M) (s : set M) (hs : s = ‚ÜëS) : submonoid M
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) {Z : C} (g : Y ‚ü∂ Z) [category_theory.limits.has_image g] [category_theory.limits.has_image (f ‚â´ g)] : category_theory.limits.image (f ‚â´ g) ‚ü∂ category_theory.limits.image g
{C : Type u‚ÇÅ} [category_theory.category C] : C ‚âå category_theory.as_small C
{R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} [comm_ring R] [ring A‚ÇÅ] [ring A‚ÇÇ] [algebra R A‚ÇÅ] [algebra R A‚ÇÇ] (e : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ) : A‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ A‚ÇÇ
{B : Type u_1} (E : B ‚Üí Type u_2) : Type (max u_1 u_2)
{G H : AddCommGroup} {f : G ‚ü∂ H} (F' : category_theory.limits.mono_factorisation f) : AddCommGroup.image f ‚ü∂ F'.I
{Œ± : Type u} [preorder Œ±] (c : omega_complete_partial_order.chain Œ±) (x : Œ±) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} (f : Œ≥ ‚Üí Œ¥) (g : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Œ±) (b : Œ≤) : Œ¥
{Œ± : Type u} [preorder Œ±] [bounded_random Œ±] (x y : Œ±) (h : x ‚â§ y) : tactic ‚Ü•(set.Icc x y)
(x : ‚Ñù) : liouville_with 1 x
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : inducing f) : pseudo_metric_space Œ±
{G : Type u_1} [group G] {G' : Type u_2} [group G'] (f : G ‚Üí* G') (hf : function.surjective ‚áëf) [h : group.is_nilpotent G] : group.nilpotency_class G' ‚â§ group.nilpotency_class G
{Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ (i : ‚Ñï), measurable (f i)) : measurable (Œª (x : Œ¥), filter.at_top.limsup (Œª (i : ‚Ñï), f i x))
 : tactic.list_Sigma tactic.rcases_patt ‚Üí tactic.rcases_patt
{X : Type u_1} [topological_space X] (s : set X) : Prop
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x : V) {r : ‚Ñù} : 2 ‚Ä¢ hb.oangle x (r ‚Ä¢ x) = 0
(p : ‚Ñï) : ‚Ñï ‚Üí zmod (2 ^ p - 1)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {ùïú : Type u_3} {G : Type u_4} [is_R_or_C ùïú] [normed_space ùïú E] [normed_group G] [normed_space ùïú G] {s : set E} {x : E} {f' : E ‚Üí (E ‚ÜíL[ùïú] G)} (hs : convex ‚Ñù s) {f : E ‚Üí G} (hder : ‚àÄ·∂† (y : E) in nhds_within x s, has_fderiv_within_at f (f' y) s y) (hcont : continuous_within_at f' s x) : ‚àÉ (K : nnreal) (t : set E) (H : t ‚àà nhds_within x s), lipschitz_on_with K f t
{Œ± : Type u_1} : has_one (language Œ±)
(R : Type u_5) (k : ‚Ñï+) [comm_ring R] [is_domain R] : ‚Ü•(roots_of_unity k R) ‚âÉ {x // x ‚àà polynomial.nth_roots ‚Üëk 1}
{C : Type u‚ÇÅ} [category_theory.category C] (J : category_theory.grothendieck_topology C) : category_theory.Sheaf J (Type w) ‚âå category_theory.SheafOfTypes J
{Œ± : Type u} {Œ≤ : Type v} [nonempty Œ±] (f : Œ± ‚Üí Œ≤) (s : set Œ±) (b : Œ≤) : Œ±
{M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] (e : M ‚âÉ* N) (x : M) : ‚áë(e.symm) (‚áëe x) = x
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {D : Type u‚ÇÇ} [category_theory.category D] {Y : D} {F‚ÇÅ F‚ÇÇ : category_theory.over Y ‚•§ category_theory.over X} (h‚ÇÅ : ‚àÄ (f : category_theory.mono_over Y), category_theory.mono (F‚ÇÅ.obj ((category_theory.mono_over.forget Y).obj f)).hom) (h‚ÇÇ : ‚àÄ (f : category_theory.mono_over Y), category_theory.mono (F‚ÇÇ.obj ((category_theory.mono_over.forget Y).obj f)).hom) (i : F‚ÇÅ ‚âÖ F‚ÇÇ) : category_theory.mono_over.lift F‚ÇÅ h‚ÇÅ ‚âÖ category_theory.mono_over.lift F‚ÇÇ h‚ÇÇ
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] : category_theory.monoidal_category (C ‚•§ D)
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b : Œ±} (ha : 0 < a) (hb : 0 ‚â§ b) : 0 < a + b
(_x : interactive.parse (lean.parser.tk "run_parser")) : lean.parser unit
{C : Type u} [category_theory.category C] [category_theory.abelian C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.has_injective_resolution X] [category_theory.has_injective_resolution Y] : category_theory.injective_resolution X ‚ü∂ category_theory.injective_resolution Y
{Œ± : Type u_1} [canonically_ordered_add_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b : Œ±} [contravariant_class Œ± Œ± has_add.add has_le.le] (h : a ‚â§ b) : b - (b - a) = a
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_algebra.is_nilpotent R ‚Ü•((lie_algebra.ad R L).range) ‚Üî lie_algebra.is_nilpotent R L
 : simp_lemmas ‚Üí name ‚Üí tactic simp_lemmas
{P : Type u_2} [metric_space P] {ps‚ÇÅ ps‚ÇÇ : set P} (hs : ps‚ÇÅ ‚äÜ ps‚ÇÇ) (hc : euclidean_geometry.cospherical ps‚ÇÇ) : euclidean_geometry.cospherical ps‚ÇÅ
 : real.cos (real.pi / 6) = real.sqrt 3 / 2
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {ùïú : Type u_3} {G : Type u_4} [is_R_or_C ùïú] [normed_space ùïú E] [normed_group G] [normed_space ùïú G] {f : E ‚Üí G} {s : set E} {f' : E ‚Üí (E ‚ÜíL[ùïú] G)} {C : nnreal} (hf : ‚àÄ (x : E), x ‚àà s ‚Üí has_fderiv_within_at f (f' x) s x) (bound : ‚àÄ (x : E), x ‚àà s ‚Üí ‚à•f' x‚à•‚Çä ‚â§ C) (hs : convex ‚Ñù s) : lipschitz_on_with C f s
{x : pgame} : x ‚â§ 0 ‚Üî ‚àÄ (i : x.left_moves), (x.move_left i).lf 0
 : ‚Ü•circle ‚Üí* ‚ÑÇÀ£
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} : cont_diff ùïú ‚ä§ f ‚Üî differentiable ùïú f ‚àß cont_diff ùïú ‚ä§ (Œª (y : E), fderiv ùïú f y)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (gp : generalized_continued_fraction.pair Œ±) : generalized_continued_fraction.pair Œ≤
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ X‚ÇÉ) (g‚ÇÅ : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) (g‚ÇÇ : Y‚ÇÇ ‚ü∂ Y‚ÇÉ) (i‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (i‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (i‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) (h‚ÇÅ : i‚ÇÅ ‚â´ g‚ÇÅ = f‚ÇÅ ‚â´ i‚ÇÇ) (h‚ÇÇ : i‚ÇÇ ‚â´ g‚ÇÇ = f‚ÇÇ ‚â´ i‚ÇÉ) (H : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk g‚ÇÅ i‚ÇÇ h‚ÇÅ)) (H' : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (g‚ÇÅ ‚â´ g‚ÇÇ) i‚ÇÉ _)) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk g‚ÇÇ i‚ÇÉ h‚ÇÇ)
{X Y : œâCPO} (f g : X ‚ü∂ Y) : category_theory.limits.is_limit (œâCPO.has_equalizers.equalizer f g)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_epi f] : category_theory.split_mono (category_theory.section_ f)
{Œπ : Type v} (Œ± : Œπ ‚Üí Top) : category_theory.limits.cofan Œ±
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (O : finset C) (H : finset (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y)) {X Y : C} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y} (mf : ‚ü®X, ‚ü®Y, ‚ü®mX, ‚ü®mY, f‚ü©‚ü©‚ü©‚ü© ‚àà H) : f ‚â´ category_theory.is_filtered.to_sup O H mY = category_theory.is_filtered.to_sup O H mX
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) (X Y : C) [category_theory.limits.has_binary_coproduct X Y] [category_theory.limits.has_binary_coproduct (G.obj X) (G.obj Y)] [i : category_theory.is_iso (category_theory.limits.coprod_comparison G X Y)] : category_theory.limits.preserves_colimit (category_theory.limits.pair X Y) G
{n : ‚Ñï} {E : Type u_1} [normed_group E] {f : (fin n ‚Üí ‚ÑÇ) ‚Üí E} {c : fin n ‚Üí ‚ÑÇ} {R : fin n ‚Üí ‚Ñù} (hf : torus_integrable f c R) : torus_integrable (-f) c R
 : expr ‚Üí tactic unit
(args : list expr) : tactic.ring_exp.ring_exp_m expr
{R : Type u} {S : Type v} [comm_ring R] [comm_ring S] (f : R ‚Üí+* S) : ideal R ‚Üí*‚ÇÄ ideal S
(Œ± : Type u) (Œ≤ : Type v) [topological_space Œ±] [topological_space Œ≤] : Type (max u v)
{n : ‚Ñï+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ‚Üë‚Üën] [is_cyclotomic_extension {n} K L] (hn : n ‚â† 2) (hirr : irreducible (polynomial.cyclotomic ‚Üën K)) : ‚áë(algebra.norm K) (is_cyclotomic_extension.zeta n K L) = 1
{M : Type u_1} [mul_one_class M] {c : con M} : function.surjective ‚áë(c.mk')
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : ‚Ü•(non_zero_divisors R)) : v.int_valuation_def ‚Üëx ‚â† 0
 : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚Ñù
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí option Œ≤) : wseq Œ± ‚Üí wseq Œ≤
(S : Type u') (R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [semiring S] [module S M] [module R M] [has_scalar S R] [is_scalar_tower S R M] (p : submodule R M) : module R ‚Ü•(submodule.restrict_scalars S p)
{Œ± : Type u_1} [measurable_space Œ±] (m : measure_theory.outer_measure Œ±) : measure_theory.outer_measure Œ±
{ùïú : Type u_1} {V‚ÇÅ : Type u_3} {V‚ÇÇ : Type u_4} {P‚ÇÅ : Type u_7} {P‚ÇÇ : Type u_9} [normed_field ùïú] [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] [normed_space ùïú V‚ÇÅ] [normed_space ùïú V‚ÇÇ] [metric_space P‚ÇÅ] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V‚ÇÅ P‚ÇÅ] [normed_add_torsor V‚ÇÇ P‚ÇÇ] (e : P‚ÇÅ ‚Üí P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó·µ¢[ùïú] V‚ÇÇ) (p : P‚ÇÅ) (h : ‚àÄ (p' : P‚ÇÅ), e p' = ‚áëe' (p' -·µ• p) +·µ• e p) : P‚ÇÅ ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÇ
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {s : set E} {f : E ‚Üí F} {g : E ‚Üí G} (hf : cont_diff_on ùïú n f s) (hg : cont_diff_on ùïú n g s) : cont_diff_on ùïú n (Œª (x : E), (f x, g x)) s
{R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Œπ : Type u_1} (b : basis Œπ R M) [infinite Œπ] {Œ∫ : Type u_1} (v : Œ∫ ‚Üí M) (i : linear_independent R v) (m : i.maximal) : cardinal.mk Œ∫ = cardinal.mk Œπ
{Œ± : Type u_2} {Œ≤ : Type u_3} [comm_monoid Œ±] [comm_monoid Œ≤] {A : set Œ±} {n : ‚Ñï} : has_coe_to_fun (A ‚Üí*[n] Œ≤) (Œª (_x : A ‚Üí*[n] Œ≤), Œ± ‚Üí Œ≤)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) (hp : p = ‚ä•) : (M ‚ß∏ p) ‚âÉ‚Çó[R] M
{a b : ennreal} (h : a < b) : add_le_cancellable a
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [has_le Œ±] [has_le Œ≤] [has_le Œ≥] (e : Œ± ‚âÉo Œ≤) (e' : Œ≤ ‚âÉo Œ≥) : Œ± ‚âÉo Œ≥
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [decidable_eq Œ±] [unique_factorization_monoid Œ±] (a : Œ±) : multiset Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] : (C ‚•§ CommMon_ D) ‚•§ CommMon_ (C ‚•§ D)
{ùïú : Type u_1} [is_R_or_C ùïú] [decidable_eq ùïú] {n : Type u_2} [fintype n] [decidable_eq n] {A : matrix n n ùïú} (hA : A.is_hermitian) : basis n ùïú (n ‚Üí ùïú)
{Œ± : Sort u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : function.surjective (quot.mk r)
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {b : M} [linear_ordered_comm_ring M] (ht : ‚Üë(s.card) < t.card ‚Ä¢ b) : ‚àÉ (y : Œ≤) (H : y ‚àà t), ‚Üë((finset.filter (Œª (x : Œ±), f x = y) s).card) < b
(Œ± : Type u) (Œ≤ : Œ± ‚Üí Type v) (n : ‚Ñï+) : Type (max u v)
{E : Type u_2} [semi_normed_group E] [normed_space ‚Ñù E] (s : set E) : metric.diam (‚áë(convex_hull ‚Ñù) s) = metric.diam s
(Œ± : Type u_1) [has_lt Œ±] : has_sbtw Œ±
{M : Type u_6} {N : Type u_7} [monoid M] [monoid N] (h : M ‚âÉ* N) : MÀ£ ‚âÉ* NÀ£
(R : Type u_1) [linear_ordered_field R] [floor_ring R] {b : ‚Ñï} (hb : 1 < b) : galois_coinsertion (Œª (z : ‚Ñ§), ‚ü®‚Üëb ^ z, _‚ü©) (Œª (r : ‚Ü•(set.Ioi 0)), int.log b ‚Üër)
{M : Type u_1} [add_zero_class M] {c : add_con M} : inhabited c.quotient
{G : Type u_1} [group G] [hH : group.is_nilpotent G] : group.nilpotency_class (G ‚ß∏ subgroup.center G) = group.nilpotency_class G - 1
{Œ± : Type u_2} [has_mul Œ±] [decidable_eq Œ±] (s t : set Œ±) [fintype ‚Ü•s] [fintype ‚Ü•t] : fintype ‚Ü•(s * t)
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {P : C ‚Üí Prop} [category_theory.monoidal_category.monoidal_predicate P] {P' : C ‚Üí Prop} [category_theory.monoidal_category.monoidal_predicate P'] [category_theory.braided_category C] (h : ‚àÄ ‚¶ÉX : C‚¶Ñ, P X ‚Üí P' X) : category_theory.braided_functor {X // P X} {X // P' X}
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R ‚Üí+* S) (x : S) (hf : ‚àÄ (a : R), commute (‚áëf a) x) : polynomial R ‚Üí+* S
{Œ± : Type u} [group Œ±] (a : Œ±) : invertible a
(X T : Top) : Top.presheaf (Type v) X
 : Type
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D) [category_theory.limits.preserves_finite_colimits F] : category_theory.limits.preserves_finite_limits F.right_op
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x y z : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (hz : z ‚â† 0) : o.oangle x y + o.oangle y z + o.oangle z x = 0
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} (t‚ÇÅ t‚ÇÇ : L.term (Œ± ‚äï fin n)) : L.bounded_formula Œ± n
(cfg : tactic.rewrite_search.config) (rules : list (expr √ó bool)) (proof : expr) (units : list tactic.rewrite_search.proof_unit) : tactic unit
(n : ‚Ñ§) : ‚áëzmod.œá‚ÇÑ ‚Üën = ite (n % 2 = 0) 0 (ite (n % 4 = 1) 1 (-1))
{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] (p : fractional_ideal S P) (s : set P) (hs : s = ‚Üëp) : fractional_ideal S P
{G : Type u_2} [add_group G] : has_neg (add_submonoid G)
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : Type (max u_4 u_5)
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : setoid Œ±) : {f // r ‚â§ setoid.ker f} ‚âÉ (quotient r ‚Üí Œ≤)
{V : Type u} (G : simple_graph V) [fintype ‚Ü•(G.edge_set)] : finset (sym2 V)
(a‚ÇÄ a‚ÇÅ a‚ÇÇ : Type u) : ‚Ñï ‚Üí Type u
{R : Type u_1} {R‚ÇÉ : Type u_3} {S‚ÇÉ : Type u_5} [semiring R] [semiring R‚ÇÉ] [semiring S‚ÇÉ] {M : Type u_6} [topological_space M] [add_comm_monoid M] [module R M] {M‚ÇÉ : Type u_8} [topological_space M‚ÇÉ] [add_comm_monoid M‚ÇÉ] [module R‚ÇÉ M‚ÇÉ] [module S‚ÇÉ M‚ÇÉ] [smul_comm_class R‚ÇÉ S‚ÇÉ M‚ÇÉ] [has_continuous_const_smul S‚ÇÉ M‚ÇÉ] (œÉ‚ÇÅ‚ÇÉ : R ‚Üí+* R‚ÇÉ) [has_continuous_add M‚ÇÉ] : (M ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ) ‚Üí‚Çó[S‚ÇÉ] M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ
{G : Type u} [add_group G] {A' A B' B : add_subgroup G} [hAN : (A'.add_subgroup_of A).normal] [hBN : (B'.add_subgroup_of B).normal] (h' : A' ‚â§ B') (h : A ‚â§ B) : ‚Ü•A ‚ß∏ A'.add_subgroup_of A ‚Üí+ ‚Ü•B ‚ß∏ B'.add_subgroup_of B
{X : Type u_1} [topological_space X] {s t : set X} (ds : discrete_topology ‚Ü•s) (ts : t ‚äÜ s) : discrete_topology ‚Ü•t
{M : Type u_1} [monoid M] {x : M} (m : ‚Ñï) {n : ‚Ñï} (h : x ^ n = 1) : x ^ m = x ^ (m % n)
{Œπ : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] [paracompact_space X] (hs : is_closed s) (U : Œπ ‚Üí set X) (ho : ‚àÄ (i : Œπ), is_open (U i)) (hU : s ‚äÜ ‚ãÉ (i : Œπ), U i) : ‚àÉ (f : partition_of_unity Œπ X s), f.is_subordinate U
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] {Œπ : Type u_3} (s : finset Œπ) (f : Œπ ‚Üí S) : ‚Ü•M
{Fq : Type u_1} [fintype Fq] [field Fq] {x y z : polynomial Fq} {a : ‚Ñ§} (hxy : ‚áëpolynomial.card_pow_degree (x - y) < a) (hyz : ‚áëpolynomial.card_pow_degree (y - z) < a) : ‚áëpolynomial.card_pow_degree (x - z) < a
{Œ± : Type u_1} {m : measurable_space Œ±} (s t : measure_theory.signed_measure Œ±) : measure_theory.complex_measure Œ±
{R : Type u} [semiring R] {Œπ : Type v} [dec_Œπ : decidable_eq Œπ] {M : Type u_1} [add_comm_monoid M] [module R M] {A : Œπ ‚Üí submodule R M} (h : direct_sum.is_internal A) : complete_lattice.independent A
(p : ‚Ñï) : (lucas_lehmer.X (lucas_lehmer.q p))À£
{n : ‚Ñï} : bitvec n ‚Üí bitvec n ‚Üí bitvec n
(R : Type u) [comm_ring R] : Top
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.limits.preserves_colimits F] : category_theory.limits.preserves_limits F.op
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K‚ÇÅ K‚ÇÇ : J ‚•§ C} (F : C ‚•§ D) (h : K‚ÇÅ ‚âÖ K‚ÇÇ) [category_theory.creates_colimit K‚ÇÅ F] : category_theory.creates_colimit K‚ÇÇ F
{Œ± : Type u} (a : Œ±) (s : set Œ±) [decidable (a ‚àà s)] [fintype ‚Ü•s] : fintype ‚Ü•(has_insert.insert a s)
{x y : pgame} (r : x.relabelling y) : x.equiv y
 : norm_cast.norm_cast_cache
{Œπa : Type u_7} {Œπb : Type u_8} [decidable_eq Œπa] [decidable_eq Œπb] [fintype Œπa] [fintype Œπb] {R' : Type u_9} {M·µ¢ : Type u_10} {N‚ÇÅ : Type u_11} {N‚ÇÇ : Type u_12} [comm_semiring R'] [add_comm_group N‚ÇÅ] [module R' N‚ÇÅ] [add_comm_group N‚ÇÇ] [module R' N‚ÇÇ] [add_comm_monoid M·µ¢] [module R' M·µ¢] (a : alternating_map R' M·µ¢ N‚ÇÅ Œπa) (b : alternating_map R' M·µ¢ N‚ÇÇ Œπb) : alternating_map R' M·µ¢ (tensor_product R' N‚ÇÅ N‚ÇÇ) (Œπa ‚äï Œπb)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V‚ÇÇ : Type v'} [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] {f : V ‚Üí‚Çó[K] V‚ÇÇ} (hf : function.injective ‚áëf) : finite_dimensional.finrank K ‚Ü•(f.range) = finite_dimensional.finrank K V
{Œ≥ : Type u_1} [non_unital_non_assoc_semiring Œ≥] (x : Œ≥) : is_add_monoid_hom (Œª (y : Œ≥), x * y)
(p : interactive.parse interactive.types.texpr) : tactic unit
{R : Type u_1} {E : Type u_2} {F : Type u_3} [add_comm_group E] [topological_space E] [add_comm_group F] [topological_space F] [topological_add_group F] [ring R] [module R E] [module R F] {f : E ‚Üí·µÉ[R] F} : continuous ‚áëf ‚Üî continuous ‚áë(f.linear)
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±] (a : Œ±) [no_min_order Œ±] : closure (set.Iio a) = set.Iic a
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) {r : nnreal} (h : ‚Üër < p.radius) : ‚àÉ (C : nnreal) (H : C > 0), ‚àÄ (n : ‚Ñï), ‚à•p n‚à•‚Çä * r ^ n ‚â§ C
 : tactic unit
{V : Type u} (x y : simple_graph V) : Prop
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b : Œ±} (ha : a ‚â§ 0) (hb : b < 0) : a + b < 0
(Œ± : Type u) (Œ≤ : Type u_1) [t : topological_space Œ≤] [topological_space.second_countable_topology Œ≤] (f : Œ± ‚Üí Œ≤) : topological_space.second_countable_topology Œ±
(C : Type u) [category_theory.category C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_reflexive_coequalizers C
{m : Type ‚Üí Type u_1} [monad m] (R : expr ‚Üí ‚Ñï ‚Üí m (option expr)) (e : expr) : m expr
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : is_clopen s ‚Üí frontier s = ‚àÖ
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s : set Œ±} {b : Œ±} (hs : s.nonempty) (h_is_ub : ‚àÄ (a : Œ±), a ‚àà s ‚Üí a ‚â§ b) (h_b_le_ub : ‚àÄ (ub : Œ±), (‚àÄ (a : Œ±), a ‚àà s ‚Üí a ‚â§ ub) ‚Üí b ‚â§ ub) : has_Sup.Sup s = b
(C : Type u) : category_theory.free_monoidal_category C ‚•§ (category_theory.discrete ‚àò category_theory.free_monoidal_category.normal_monoidal_object) C ‚•§ category_theory.free_monoidal_category C
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [topological_space Œ≤] [topological_space.pseudo_metrizable_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (hf : ‚àÄ (i : ‚Ñï), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
{Œ± : Type u} [topological_space Œ±] {Œπ : Type u_1} [compact_space Œ±] {f : Œπ ‚Üí set Œ±} (hf : locally_finite f) (hne : ‚àÄ (i : Œπ), (f i).nonempty) : set.univ.finite
{R : Type u} [comm_ring R] : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ (Algebra R) (Module R))
{n : ‚Ñï} (Œ± : typevec n) (Œ≤ : Type u_1) : typevec (n + 1)
{R : Type u_1} {S : Type u_2} [semiring R] [linear_ordered_ring S] (abv : absolute_value R S) [nontrivial R] : R ‚Üí*‚ÇÄ S
{Œ± : Type u} (i : ‚Ñï) (t : ordnode Œ±) : ordnode Œ±
{R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R ‚Üî is_integral_closure R R K
(C : Type u) [category_theory.category C] : Type (max u v)
{ùïú : Type u} {n : ‚Ñï} {Ei : fin n.succ ‚Üí Type wEi} {G : Type wG} [nondiscrete_normed_field ùïú] [Œ† (i : fin n.succ), normed_group (Ei i)] [Œ† (i : fin n.succ), normed_space ùïú (Ei i)] [normed_group G] [normed_space ùïú G] (f : continuous_multilinear_map ùïú Ei G) : Ei 0 ‚ÜíL[ùïú] continuous_multilinear_map ùïú (Œª (i : fin n), Ei i.succ) G
{S : Type u_2} [comm_ring S] {A : Type u_4} [comm_ring A] [algebra A S] (pb : power_basis A S) : polynomial A
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {f : E ‚Üí F √ó G} (hf : cont_diff ùïú n f) : cont_diff ùïú n (Œª (x : E), (f x).snd)
(C : Type u‚ÇÅ) [category_theory.category C] : hom_rel (category_theory.paths C)
(R : Type u‚ÇÅ) [comm_semiring R] (p : ‚Ñï) [hp : fact (nat.prime p)] [char_p R p] (n : ‚Ñï) : ring.perfection R p ‚Üí+* R
{R : Type u‚ÇÅ} {L : Type u‚ÇÇ} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L
{R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R) : A.det = A 0 0
{Œ± : Type u_1} (L : list (list Œ±)) {i : ‚Ñï} (hi : i < L.length) : list.drop (list.take i (list.map list.length L)).sum (list.take (list.take (i + 1) (list.map list.length L)).sum L.join) = L.nth_le i hi
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (A : Mon_ C) : Type (max u‚ÇÅ v‚ÇÅ)
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : Prop
{M : Type u_4} [topological_space M] [add_monoid M] [has_continuous_add M] {U : set M} (hU : U ‚àà nhds 0) : ‚àÉ (V : set M), is_open V ‚àß 0 ‚àà V ‚àß V + V ‚äÜ U
(Œ± : Type u_1) : setoid Œ± ‚âÉo {C // setoid.is_partition C}
(n p : ‚Ñï) : (finset.Ico 1 (n + 1)).sum (Œª (k : ‚Ñï), ‚Üëk ^ p) = (finset.range (p + 1)).sum (Œª (i : ‚Ñï), bernoulli' i * ‚Üë((p + 1).choose i) * ‚Üën ^ (p + 1 - i) / (‚Üëp + 1))
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ‚Üî algebra.finite_presentation R A
{Œ± : Type u_1} [topological_space Œ±] [polish_space Œ±] {s : set Œ±} (hs : is_closed s) : polish_space.is_clopenable s
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (s : set Œ±) : set Œ≤
{R : Type u_1} [comm_ring R] (k : ‚Ñï) (a : R) : ‚Ñï ‚Üí polynomial R
{Œ± : Type u} [semilattice_inf Œ±] [order_top Œ±] {Œπ : Type u} [fintype Œπ] (f : Œπ ‚Üí Œ±) : (‚àè f) = (fintype.elems Œπ).inf f
(Œ≤ : Type u_1) (Œ± : Type u_2) : Type (max u_1 u_2)
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : isometry f) : uniform_inducing f
{Œ± : Type u_1} [preorder Œ±] [order_bot Œ±] {a : Œ±} : is_atom a ‚Üí is_coatom (‚áëorder_dual.to_dual a)
{Œ± : Type u} [has_ssubset Œ±] [is_asymm Œ± has_ssubset.ssubset] {a b : Œ±} (h : a ‚äÇ b) : ¬¨b ‚äÇ a
{p : ‚Ñï} {G : Type u_1} [group G] {P : subgroup G} (hP : is_p_group p ‚Ü•P) : ‚àÉ (Q : sylow p G), P ‚â§ ‚ÜëQ
{M : Type u_1} [monoid M] : monoid.fg M ‚Üî ‚àÉ (S : set M), submonoid.closure S = ‚ä§ ‚àß S.finite
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.initial] {E : Type u} [category_theory.category E] {G : D ‚•§ E} (t : category_theory.limits.limit_cone G) : category_theory.limits.limit_cone (F ‚ãô G)
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u} [category_theory.category J] (F : J ‚•§ C) [category_theory.limits.has_terminal J] [category_theory.limits.has_colimit F] : category_theory.limits.colimit F ‚âÖ F.obj (‚ä§_ J)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [normed_group Œ≤] : zero_at_infty_continuous_map Œ± Œ≤ ‚Üí+ bounded_continuous_function Œ± Œ≤
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ‚Ñù} [interval_integral.FTC_filter b (nhds_within b s) (nhds_within b t)] (hmeas : strongly_measurable_at_filter f (nhds_within b t) measure_theory.measure_space.volume) (hb : continuous_within_at f t b) : has_deriv_within_at (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in a..u, f x) (f b) s b
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : category_theory.presheaf.first_obj (Top.presheaf.presieve_of_covering U) F ‚ü∂ Top.presheaf.sheaf_condition_equalizer_products.pi_opens F U
 : tactic.ring_exp.ex tactic.ring_exp.ex_type.prod ‚Üí tactic.ring_exp.ex tactic.ring_exp.ex_type.prod ‚Üí tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.prod)
 : smt_tactic unit
(s : string) (n : ‚Ñï) : string
{C : Type u} [category_theory.category C] {X Y : C} (i : category_theory.arrow C) (p : X ‚âÖ Y) : category_theory.has_lifting_property i (category_theory.arrow.mk p.hom)
{K : Type u} {V : Type v} {V' : Type v'} [division_ring K] [add_comm_group V] [module K V] [add_comm_group V'] [module K V'] (cond : (module.rank K V).lift = (module.rank K V').lift) : nonempty (V ‚âÉ‚Çó[K] V')
{G : Type u_1} [group G] (S : subgroup G) : set G
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C·µí·µñ} (f : X ‚ü∂ Y) (m : category_theory.normal_epi f.unop) : category_theory.normal_mono f
 : strict_mono real.sinh
{X Y : Type u} [semigroup X] [semigroup Y] : X ‚âÉ* Y ‚âÖ Semigroup.of X ‚âÖ Semigroup.of Y
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] (p : submodule R E) (p' : submodule R F) : linear_pmap R (E √ó F) F
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : filter Œπ} [uniform_space Œ≥] {g : Œ≤ ‚Üí Œ≥} (h : tendsto_uniformly F f p) (hg : uniform_continuous g) : tendsto_uniformly (Œª (i : Œπ), g ‚àò F i) (g ‚àò f) p
{Œ± : Type u} {Œ≤ : Type u_1} (f : Œ≤ ‚Üí Œ±) [decidable_eq Œ±] [fin_enum Œ≤] (h : function.surjective f) : fin_enum Œ±
{m : Type u_2} {n : Type u_3} {Œ± : Type u_5} [decidable_eq m] [decidable_eq n] [semiring Œ±] (i : m) (j : n) (a : Œ±) : matrix m n Œ±
{Œ± : Type u_1} [preorder Œ±] (s : ordset Œ±) : Prop
{G : Type u_1} [add_group G] (S : add_subgroup G) : set G
{F : Type u ‚Üí Type u} [applicative F] {Œ± : Type u_1} {Œ±' : Type u} {Œ≤ : Type u_2} {Œ≤' : Type u} (f : Œ± ‚Üí F Œ±') (f' : Œ≤ ‚Üí F Œ≤') : functor.const Œ± Œ≤ ‚Üí F (functor.const Œ±' Œ≤')
(C : Type u) [category_theory.category C] : Type (max v u)
(Œ± : Type u) : Type u
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] (f : equiv.perm Œ±) : trunc {l // l.prod = f ‚àß (‚àÄ (g : equiv.perm Œ±), g ‚àà l ‚Üí g.is_cycle) ‚àß list.pairwise equiv.perm.disjoint l}
(G : Type u) [group G] : Type (u+1)
{Œ± : Type} (e : environment) (f : declaration ‚Üí option Œ±) : list Œ±
(R : Type u_1) (M : Type u_3) [has_zero R] [has_zero M] : Type (max u_1 u_3)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí list Œ± ‚Üí Œ≤) : list Œ± ‚Üí list Œ≤
{a b : ‚Ñù} : ‚à´ (x : ‚Ñù) in a..b, real.sin x * real.cos x = (real.sin b ^ 2 - real.sin a ^ 2) / 2
{R' : Type u_1} [semiring R'] : smul_comm_class ‚Ü•(subsemiring.center R') R' R'
{Œπ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Œπ ‚Üí set X} {s : set X} (v : shrinking_lemma.partial_refinement u s) (hs : is_closed s) (i : Œπ) (hi : i ‚àâ v.carrier) : ‚àÉ (v' : shrinking_lemma.partial_refinement u s), v < v'
{K : Type u_8} {K‚ÇÅ : Type u_9} {V‚ÇÅ : Type u_12} {n : Type u_14} [field K] [field K‚ÇÅ] [add_comm_group V‚ÇÅ] [module K‚ÇÅ V‚ÇÅ] {I‚ÇÅ I‚ÇÅ' : K‚ÇÅ ‚Üí+* K} {B : V‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ] V‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ'] K} {v : n ‚Üí V‚ÇÅ} (hv‚ÇÅ : B.is_Ortho v) (hv‚ÇÇ : ‚àÄ (i : n), ¬¨B.is_ortho (v i) (v i)) : linear_independent K‚ÇÅ v
{R : Type u_1} [comm_semiring R] (a : R) : power_series R ‚Üí+* power_series R
(Œ± : Type u_5) : Type u_5
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] [decidable_eq Œπ] [add_monoid Œπ] (ùíú : Œπ ‚Üí submodule R A) [graded_algebra ùíú] : galois_insertion (ideal.homogeneous_hull ùíú) homogeneous_ideal.to_ideal
{F : Type u_8} {G : Type u_1} {H : Type u_2} [group G] [mul_one_class H] [monoid_hom_class F G H] (f : F) : function.injective ‚áëf ‚Üî ‚àÄ (a : G), ‚áëf a = 1 ‚Üî a = 1
(Œ± : Type u_1) : Type u_1
{M : Type u_1} [linear_ordered_comm_monoid M] (S : submonoid M) : linear_ordered_comm_monoid ‚Ü•S
{n : ‚Ñï} (c : composition n) {j : ‚Ñï} (h : j < n) : ‚àÉ (i : ‚Ñï), j < c.size_up_to i.succ ‚àß i < c.length
(e : expr) : option expr ‚Üí tactic unit
{Œ± : Type u_1} [circular_preorder Œ±] (a b : Œ±) : set Œ±
 : true
{Œ± : Type u} {Œ±' : Type w} {Œ≤ : Type v} {Œ≤' : Type x} (f : Œ± ‚Üí Œ±') (g : Œ≤ ‚Üí Œ≤') : Œ± ‚äï Œ≤ ‚Üí Œ±' ‚äï Œ≤'
{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] {X Y : C} {f : X ‚ü∂ Y} [category_theory.epi f] (s : category_theory.limits.fork f 0) (h : category_theory.limits.is_limit s) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ f _)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type w} {s : finset Œπ} (h : basis ‚Ü•s K V) : finite_dimensional K V
{Œ± : Sort u_1} : erased Œ± ‚Üí Œ±
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {f : ‚ÑÇ ‚Üí E} {c : ‚ÑÇ} {R : ‚Ñù} {w : ‚ÑÇ} (hf : circle_integrable f c R) (hw : complex.abs w < R) : has_sum (Œª (n : ‚Ñï), ‚àÆ (z : ‚ÑÇ) in C(c, R), (w / (z - c)) ^ n ‚Ä¢ (z - c)‚Åª¬π ‚Ä¢ f z) (‚àÆ (z : ‚ÑÇ) in C(c, R), (z - (c + w))‚Åª¬π ‚Ä¢ f z)
 : snum ‚Üí snum
{n : Type u_1} {p : Type u_2} {R : Type u‚ÇÇ} [decidable_eq n] [decidable_eq p] [comm_ring R] (e : n ‚âÉ p) (t : matrix.transvection_struct n R) : matrix.transvection_struct p R
{X : Top} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) {Y : topological_space.opens ‚Ü•X} (hY : Y = supr U) : {f // (category_theory.sieve.generate (Top.presheaf.presieve_of_covering_aux U Y)).arrows f.hom} ‚âå Top.presheaf.sheaf_condition.opens_le_cover U
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x : V) : hb.oangle 0 x = 0
(a : pos_num) : pos_num ‚Üí pos_num
{C : Type u} [category_theory.category C] {J X Y : C} [category_theory.injective J] (g : X ‚ü∂ J) (f : X ‚ü∂ Y) [category_theory.mono f] : Y ‚ü∂ J
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {G : C ‚•§ D} {K : category_theory.grothendieck_topology D} [category_theory.full G] [category_theory.faithful G] (Hld : category_theory.locally_cover_dense K G) : category_theory.cover_preserving Hld.induced_topology K G
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [finite_dimensional ùïú E] {n : ‚Ñï} (hn : finite_dimensional.finrank ùïú E = n) {Œπ : Type u_4} [fintype Œπ] [decidable_eq Œπ] {V : Œπ ‚Üí submodule ùïú E} (hV : direct_sum.is_internal V) : (Œ£ (i : Œπ), ‚Ü•(orthonormal_basis_index ùïú ‚Ü•(V i))) ‚âÉ fin n
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [Œ† (i : Œπ), has_zero (Œ≤ i)] {f g : Œ†‚ÇÄ (i : Œπ), Œ≤ i} : f = g ‚Üî ‚àÄ (i : Œπ), ‚áëf i = ‚áëg i
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {f : ‚ÑÇ ‚Üí E} {c : ‚ÑÇ} (hd : ‚àÄ·∂† (z : ‚ÑÇ) in nhds_within c {c}·∂ú, differentiable_at ‚ÑÇ f z) (hc : continuous_at f c) : analytic_at ‚ÑÇ f c
(c : char) (f : string ‚Üí string) : string ‚Üí string
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] : has_coe_to_fun (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (Œª (_x : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ), M‚ÇÅ ‚Üí M‚ÇÇ)
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [add_monoid Œπ] [graded_monoid.gmonoid A] : A 0 ‚Üí* graded_monoid A
{C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ‚Ñï} {i : fin (n + 1)} : X.œÉ i ‚â´ X.Œ¥ i.succ = ùüô (X.obj (opposite.op (simplex_category.mk n)))
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (Œª (_x : G), _x +·µ• p)
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [comm_semiring k] [add_monoid G] {A : Type u‚ÇÉ} [semiring A] [algebra k A] {B : Type u_2} [semiring B] [algebra k B] (f : A ‚Üí‚Çê[k] B) (g : multiplicative G ‚Üí* B) (h_comm : ‚àÄ (x : A) (y : multiplicative G), commute (‚áëf x) (‚áëg y)) : add_monoid_algebra A G ‚Üí‚Çê[k] B
{R : Type v} [semiring R] {R' : Type u_1} [semiring R'] [mul_semiring_action R' R] (H : subsemiring R') : mul_semiring_action ‚Ü•H R
(M : Type u_5) (N : Type u_6) [mul_one_class M] [mul_one_class N] : M √ó N ‚Üí* M
(rs : list (expr √ó bool)) (s : tactic.rewrite_search.side) (hows : list tactic.rewrite_search.how) : tactic string
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) [category_theory.limits.has_colimit F] : category_theory.limits.is_colimit (category_theory.limits.colimit.cocone F)
{Œ± : Type u} [decidable_eq Œ±] (i j : Œ±) : function.involutive (has_mul.mul (equiv.swap i j))
{A : Type u_1} {B : Type u_2} {C : Type u_3} [ring A] [ring B] [ring C] (f : A ‚Üí+* B) (f_inv : B ‚Üí A) (hf : function.right_inverse f_inv ‚áëf) (g : A ‚Üí+* C) (hg : f.ker ‚â§ g.ker) : B ‚Üí+* C
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : filter Œπ} [topological_space Œ±] [compact_space Œ±] : tendsto_locally_uniformly F f p ‚Üî tendsto_uniformly F f p
{Œ± : Type u} [ordered_semiring Œ±] {a b c d : Œ±} [has_exists_add_of_le Œ±] (hab : a < b) (hcd : c < d) : a * d + b * c < a * c + b * d
{Œ± : Type u} {L : list (Œ± √ó bool)} [decidable_eq Œ±] : free_group.red L (free_group.reduce L)
{l : filter ‚Ñù} {f f' g g' : ‚Ñù ‚Üí ‚Ñù} (hff' : ‚àÄ·∂† (x : ‚Ñù) in filter.at_top, has_deriv_at f (f' x) x) (hgg' : ‚àÄ·∂† (x : ‚Ñù) in filter.at_top, has_deriv_at g (g' x) x) (hg' : ‚àÄ·∂† (x : ‚Ñù) in filter.at_top, g' x ‚â† 0) (hftop : filter.tendsto f filter.at_top (nhds 0)) (hgtop : filter.tendsto g filter.at_top (nhds 0)) (hdiv : filter.tendsto (Œª (x : ‚Ñù), f' x / g' x) filter.at_top l) : filter.tendsto (Œª (x : ‚Ñù), f x / g x) filter.at_top l
{p : ‚Ñï} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x y : witt_vector p R) : ‚áëwitt_vector.verschiebung (x * ‚áëwitt_vector.frobenius y) = ‚áëwitt_vector.verschiebung x * y
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.monoidal_category C] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) [category_theory.full F.to_lax_monoidal_functor.to_functor] [category_theory.faithful F.to_lax_monoidal_functor.to_functor] [category_theory.braided_category D] : category_theory.braided_category C
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [bounded_order Œ±] [bounded_order Œ≤] (f : bounded_order_hom Œ± Œ≤) : top_hom Œ± Œ≤
{n : Type u} [decidable_eq n] [fintype n] (Œ≤ : Type v) [comm_ring Œ≤] : submonoid (matrix n n Œ≤)
{Œ± : Type u_1} {m m' : metric_space Œ±} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {Œπ : Type u_1} (c : complex_shape Œπ) {Œπ' : Type u_2} (c' : complex_shape Œπ') : ùü≠ (homological_complex (homological_complex V c) c') ‚âÖ homological_complex.flip V c c' ‚ãô homological_complex.flip V c' c
{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] [nonempty Œ≤] [semilattice_sup Œ≤] {s : Œ≤ ‚Üí Œ±} (b : Œ≤ ‚Üí ‚Ñù) (h : ‚àÄ (n m : Œ≤), n ‚â§ m ‚Üí has_dist.dist (s n) (s m) ‚â§ b n) (h‚ÇÄ : filter.tendsto b filter.at_top (nhds 0)) : cauchy_seq s
(R : Type u_1) (S : Type u_2) (M : Type u_3) [semiring S] [add_comm_monoid M] [comm_semiring R] [algebra R S] [module S M] : S ‚Üí‚Çê[R] module.End R (restrict_scalars R S M)
{p : ‚Ñï} [fact (nat.prime p)] {q r : ‚Ñö_[p]} : padic_norm_e q ‚â† padic_norm_e r ‚Üí padic_norm_e (q + r) = linear_order.max (padic_norm_e q) (padic_norm_e r)
{A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ‚áë(polynomial.aeval r) p = 0) : ‚Üë(is_fraction_ring.denom A r) ‚à£ p.leading_coeff
{M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] (f : M ‚Üí* N) (a b : M) : ‚áëf (a * b) = ‚áëf a * ‚áëf b
{G : Type u_1} [group G] {G' : Type u_4} [group G'] (f : G ‚Üí* G') (H : subgroup G) : ‚Ü•H ‚Üí* ‚Ü•(subgroup.map f H)
{X : algebraic_geometry.Scheme} {U : topological_space.opens ‚Ü•(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} (hU : algebraic_geometry.is_affine_open U) : algebraic_geometry.Scheme.Spec.obj (opposite.op (X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op U))) ‚ü∂ X
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} (hs : is_closed s) : is_preconnected s ‚Üî ‚àÄ (u v : set Œ±), is_closed u ‚Üí is_closed v ‚Üí s ‚äÜ u ‚à™ v ‚Üí u ‚à© v = ‚àÖ ‚Üí s ‚äÜ u ‚à® s ‚äÜ v
{Œ± : Type u} [topological_space Œ±] {J : Type u} (U : J ‚Üí topological_space.opens Œ±) : (Top.glue_data.of_open_subsets U).to_glue_data.glued ‚ü∂ Top.of Œ±
{Œ± : Type u} (L : list (Œ± √ó bool)) : free_group Œ±
{ùíú : Type u_1} [category_theory.category ùíú] {A B C : ùíú} (f : A ‚ü∂ B) (g : B ‚ü∂ C) [category_theory.limits.has_zero_morphisms ùíú] [category_theory.limits.has_kernels ùíú] [category_theory.limits.has_images ùíú] : Prop
(q : interactive.parse interactive.types.texpr) : interactive.parse (optional (lean.parser.tk "with" *> interactive.types.texpr)) ‚Üí interactive.parse interactive.types.location ‚Üí tactic unit
(C : Type u‚ÇÅ) [category_theory.category C] : Type u‚ÇÅ
{Œπ : Type u_1} {ùïú : Type u_2} [is_R_or_C ùïú] {E : Type u_3} [inner_product_space ùïú E] [cplt : complete_space E] {G : Œπ ‚Üí Type u_4} [Œ† (i : Œπ), inner_product_space ùïú (G i)] {V : Œ† (i : Œπ), G i ‚Üí‚Çó·µ¢[ùïú] E} (hV : orthogonal_family ùïú V) [‚àÄ (i : Œπ), complete_space (G i)] (hV' : (‚®Ü (i : Œπ), (V i).to_linear_map.range).topological_closure = ‚ä§) (W‚ÇÄ : Œ†‚ÇÄ (i : Œπ), G i) : ‚áë(‚áë(hV.linear_isometry_equiv hV') (W‚ÇÄ.sum (Œª (i : Œπ), ‚áë(V i)))) = ‚áëW‚ÇÄ
(X : algebraic_geometry.Scheme) {U : topological_space.opens ‚Ü•(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} (f : ‚Ü•(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op U))) : topological_space.opens ‚Ü•(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)
(Œ± : Type u_1) [topological_space Œ±] [preorder Œ±] : Prop
(a b : ennreal) {p q : ‚Ñù} (hpq : p.is_conjugate_exponent q) : a * b ‚â§ a ^ p / ennreal.of_real p + b ^ q / ennreal.of_real q
{n : ‚Ñï} (a : fin (n + 1)) : ‚Üë‚Üëa = a
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_images C] [category_theory.limits.has_binary_coproducts C] {A : C} (f g h : category_theory.mono_over A) : (f ‚ü∂ h) ‚Üí (g ‚ü∂ h) ‚Üí ((category_theory.mono_over.sup.obj f).obj g ‚ü∂ h)
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (Y : category_theory.subobject X) : ‚ÜëY ‚ü∂ X
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) (t : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (ùüô Y) (ùüô Y) rfl)) : category_theory.epi f
{R : Type u_1} [comm_semiring R] (x y : R) (n : ‚Ñï) : {k // (x + y) ^ n = x ^ n + ‚Üën * x ^ (n - 1) * y + k * y ^ 2}
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [unique J] (f : J ‚Üí C) : category_theory.limits.limit_bicone f
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (h : reflexive r) {x y : Œ±} (hr : x ‚â† y ‚Üí r x y) : r x y
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {F : C ‚•§ D} {t : category_theory.limits.cocone K} (h : category_theory.limits.is_colimit t) (hF : category_theory.limits.is_colimit (F.map_cocone t)) : category_theory.limits.preserves_colimit K F
{R : Type u} [ring R] (s : subring R) {x y : R} : x ‚àà s ‚Üí y ‚àà s ‚Üí x * y ‚àà s
{p : ‚Ñï} [hp : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {S : Type u_2} [semiring S] (f : Œ† (k : ‚Ñï), S ‚Üí+* truncated_witt_vector p k R) (s : S) : witt_vector p R
{Œ± : Type u} [preorder Œ±] {s : set Œ±} {a : Œ±} (h : is_least s a) : order_bot ‚Ü•s
 : category_theory.large_category category_theory.Groupoid
{R : Type u_1} (M : Type u_3) [has_zero R] [has_zero M] [smul_with_zero R M] (r : R) : r ‚Ä¢ 0 = 0
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} (X : T.algebra) : T.free.obj (T.to_functor.obj X.A) ‚ü∂ T.free.obj X.A
 : category_theory.limits.has_limits_of_size Mon
{Œ± : Type u_2} {Œ≤ : Type u_3} [semilattice_inf Œ±] [order_bot Œ±] [semilattice_inf Œ≤] [order_bot Œ≤] {a b : Œ±} (f : Œ± ‚âÉo Œ≤) (ha : disjoint a b) : disjoint (‚áëf a) (‚áëf b)
{Œ± : Sort u_1} (p : Œ± ‚Üí Œ± ‚Üí Prop) : decidable_rel p
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [semilattice_inf Œ≤] {f g : Œ± ‚Üí Œ≤} (hf : antitone f) (hg : antitone g) : antitone (f ‚äì g)
 : native.float ‚Üí native.float ‚Üí native.float
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : Œ± ‚âÉ Œ≤) : set Œ± ‚âÉ set Œ≤
(p n : ‚Ñï) (R : Type u_1) : Type u_1
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [add_comm_group Œ≤] : add_comm_group Œ±
{R : Type u} {M : Type v} [ring R] {N : Type u_3} [add_comm_group M] [module R M] [add_comm_group N] [module R N] (f : M √ó N ‚Üí‚Çó[R] M) (i : function.injective ‚áëf) : ‚Ñï ‚Üí submodule R M
(H : Type u_1) [topological_space H] : structure_groupoid H
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_epi f] : category_theory.limits.is_colimit (category_theory.limits.cocone_of_split_epi f)
{E : ‚Ñï ‚Üí Type u_1} (x y : Œ† (n : ‚Ñï), E n) : ‚Ñï
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [preorder Œ±] [preorder Œ≤] [preorder Œ≥] (f : Œ± ‚Üío Œ≤) (g : Œ± ‚Üío Œ≥) : Œ± ‚Üío Œ≤ √ó Œ≥
(X : Type u_3) [topological_space X] : Prop
(Œ± : Type u_1) (Œ≤ : Type u_2) [order.frame Œ±] [order.frame Œ≤] : Type (max u_1 u_2)
 : native.float ‚Üí native.float
{G : Type u} [group G] {H : Type v} [group H] (f : G ‚Üí* H) : abelianization G ‚Üí* abelianization H
{R : Type u} {M : Type v} [has_scalar R M] (p : sub_mul_action R M) : ‚Ü•p ‚Üí[R] M
(X : algebraic_geometry.LocallyRingedSpace) (x : ‚Ü•X) : algebraic_geometry.structure_sheaf.to_stalk ‚Ü•(opposite.unop (opposite.op (algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X)))) (‚áë(X.to_Œì_Spec_SheafedSpace.base) x) ‚â´ algebraic_geometry.PresheafedSpace.stalk_map X.to_Œì_Spec_SheafedSpace x = X.Œì_to_stalk x
{Œ± : Type u} : category_theory.Aut Œ± ‚âÉ* equiv.perm Œ±
(Œ± : Type u) [has_lt Œ±] : Prop
(n : ‚Ñï) (x r : ‚Ñù) : ‚Ñù
{Œ± : Type u} {Œ≤ : Type v} [group Œ±] [mul_action Œ± Œ≤] (x : Œ≤) : mul_action.is_pretransitive Œ± ‚Ü•(mul_action.orbit Œ± x)
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí ordnode Œ±
{A : Type u_4} {B : Type u_5} [monoid A] [monoid B] [topological_space A] [topological_space B] : has_coe_to_fun (continuous_monoid_hom A B) (Œª (_x : continuous_monoid_hom A B), A ‚Üí B)
(Œ± : Type u_1) : Type u_1
{C : Type u_1} [category_theory.category C] (r : hom_rel C) : C ‚•§ category_theory.quotient r
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_mono f] (F : C ‚•§ D) : category_theory.split_mono (F.map f)
{Œ± : Type u} {Œ≤ : Type v} {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} [partial_order Œ±] [semilattice_inf Œ≤] (gi : galois_coinsertion l u) : semilattice_inf Œ±
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] (L : A ‚•§ T) (R : B ‚•§ T) : category_theory.comma.map_left R (ùüô L) ‚âÖ ùü≠ (category_theory.comma L R)
{Œ± : Type u} [topological_space Œ±] (F : set Œ±) (x : ‚Ü•F) : set Œ±
(n : ‚Ñï) : zmod n ‚Üí zmod n
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] (B : bilin_form R M) : quadratic_form R M
{Œ± : Type u} {Œ≤ : Type v} [mul_one_class Œ±] [mul_one_class Œ≤] : (Œ± ‚Üí* Œ≤) ‚âÉ (additive Œ± ‚Üí+ additive Œ≤)
{C : Type u_1} [category_theory.category C] [category_theory.monoidal_category C] (F : category_theory.monoidal_functor (Type u_3) C) (n : ‚Ñï) (Œ≤ : Type u_3) : F.to_lax_monoidal_functor.to_functor.obj (fin (n + 1) ‚Üí Œ≤) ‚âÖ F.to_lax_monoidal_functor.to_functor.obj Œ≤ ‚äó F.to_lax_monoidal_functor.to_functor.obj (fin n ‚Üí Œ≤)
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] {R‚ÇÅ R‚ÇÇ : ‚Ñù} {f : ‚ÑÇ ‚Üí E} {c z : ‚ÑÇ} (hd : differentiable_on ‚ÑÇ f (metric.ball c R‚ÇÅ)) (h_maps : set.maps_to f (metric.ball c R‚ÇÅ) (metric.ball (f c) R‚ÇÇ)) (hz : z ‚àà metric.ball c R‚ÇÅ) : has_dist.dist (f z) (f c) ‚â§ R‚ÇÇ / R‚ÇÅ * has_dist.dist z c
{Œ± : Type u_1} {Œ≤ : Type u_2} [decidable_eq Œ≤] (s : finset Œ±) (t : Œ± ‚Üí finset Œ≤) : finset Œ≤
{Œ± : Type u_2} [decidable_eq Œ±] [has_div Œ±] : has_div (finset Œ±)
(n k : ‚Ñï) : Prop
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {X : C} (h : category_theory.coyoneda.obj (opposite.op X) ‚ãô category_theory.ulift_functor ‚âÖ F.cocones) (s : category_theory.limits.cocone F) : (category_theory.limits.is_colimit.of_nat_iso.colimit_cocone h).extend (category_theory.limits.is_colimit.of_nat_iso.hom_of_cocone h s) = s
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [ring ùïú] [add_comm_group E] [add_comm_group F] [module ùïú E] [module ùïú F] [topological_space E] [topological_space F] [topological_add_group E] [topological_add_group F] [has_continuous_const_smul ùïú E] [has_continuous_const_smul ùïú F] (p : formal_multilinear_series ùïú E F) (n : ‚Ñï) (x : E) : F
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] (f : multilinear_map R M‚ÇÅ M‚ÇÇ) (m : Œ† (i : Œπ), M‚ÇÅ i) (i : Œπ) : M‚ÇÅ i ‚Üí‚Çó[R] M‚ÇÇ
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_4} [fintype Œπ] (b : basis Œπ R M) : (linear_map.trace R M).comp (dual_tensor_hom R M M) = contract_left R M
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} {Œ≤ : Type u} (g : F (Œ± ::: Œ≤) ‚Üí Œ≤) : mvqpf.fix F Œ± ‚Üí Œ≤
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {X Y Z : C} (G : C ‚•§ D) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.limits.has_pullback f g] [category_theory.limits.has_pullback (G.map f) (G.map g)] : G.obj (category_theory.limits.pullback f g) ‚ü∂ category_theory.limits.pullback (G.map f) (G.map g)
{Œ± : Type u_1} [topological_space Œ±] [topological_space.second_countable_topology Œ±] (m : measure_theory.outer_measure Œ±) {s : set Œ±} (hs : ‚áëm s ‚â† 0) : ‚àÉ (x : Œ±) (H : x ‚àà s), ‚àÄ (t : set Œ±), t ‚àà nhds_within x s ‚Üí 0 < ‚áëm t
(R : Type u) [comm_semiring R] : mv_polynomial punit R ‚âÉ‚Çê[R] polynomial R
 : Type (u+1)
{G : Type u_1} [group G] (H : subgroup G) {x y : G} (hx : x ‚àà H) (hy : y ‚àà H) : x / y ‚àà H
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : Top} (H : X ‚âÖ Y) : Top.presheaf.pullback C H.inv ‚âÖ Top.presheaf.pushforward C H.hom
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_monoid Œ≤] {s : finset Œ±} (f g : Œ± ‚Üí Œ≤) (comm_ff : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí add_commute (f x) (f y)) (comm_gg : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí add_commute (g x) (g y)) (comm_gf : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí x ‚â† y ‚Üí add_commute (g x) (f y)) : s.noncomm_sum (f + g) _ = s.noncomm_sum f comm_ff + s.noncomm_sum g comm_gg
(k : Type u_1) (G : Type u_2) [comm_semiring k] [group G] [fintype G] [invertible ‚Üë(fintype.card G)] (g : G) : group_algebra.average k G * finsupp.single g 1 = group_algebra.average k G
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {F : Type u_3} [normed_group F] [normed_space ‚Ñù F] (f : E ‚âÉ·µ¢ F) (h0 : ‚áëf 0 = 0) : E ‚âÉ‚Çó·µ¢[‚Ñù] F
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) : ‚áëlinear_map.det ‚Üë(hb.conj_lie.to_linear_equiv) = -1
{M : Type u_1} [has_zero M] [has_add M] [has_neg M] : ‚Ñ§ ‚Üí M ‚Üí M
 : irrational golden_ratio
{n : ‚Ñ§} : even n ‚Üí even n.nat_abs
{Œ± : Type u_2} [has_zero Œ±] : zero_hom Œ± (set Œ±)
{C : Type u} [category_theory.category C] [category_theory.enough_projectives C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] : C
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] (f : Œ± ‚âÉ option Œ≤) : fintype Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ≤] (f : Œ± ‚Üí Œ≤) (inj : function.injective f) : linear_order Œ±
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] {F : C ‚•§ D} [F.final] {E : Type u} [category_theory.category E] {G : D ‚•§ E} : category_theory.limits.cocone (F ‚ãô G) ‚•§ category_theory.limits.cocone G
(R : Type u) : Type (u+1)
{M : Type u_1} [monoid M] {x y z : M} : y ‚àà powers x ‚Üí z ‚àà powers x ‚Üí y * z ‚àà powers x
{M : Type u_1} [has_mul M] {c d : con M} (H : ‚àÄ (x y : M), ‚áëc x y ‚Üî ‚áëd x y) : c = d
{G : Type w} [topological_space G] [group G] [has_continuous_mul G] (a : G) : G ‚âÉ‚Çú G
{n : with_top ‚Ñï} {ùïÇ : Type u_6} [is_R_or_C ùïÇ] {E' : Type u_7} [normed_group E'] [normed_space ùïÇ E'] {F' : Type u_8} [normed_group F'] [normed_space ùïÇ F'] {f : E' ‚Üí F'} {f' : E' ‚ÜíL[ùïÇ] F'} {x : E'} (hf : cont_diff_at ùïÇ n f x) (hf' : has_fderiv_at f f' x) (hn : 1 ‚â§ n) : has_strict_fderiv_at f f' x
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {l : list L} : (‚àÄ (x : L), x ‚àà l ‚Üí x ‚àà S) ‚Üí l.prod ‚àà S
 : has_to_string tactic.simp_arg_type
(n : ‚Ñï) : arity Set n ‚Üí Type (u+1)
{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] {r : R} {a : A} : r ‚àà resolvent_set R a ‚Üî is_unit (resolvent a r)
 : environment ‚Üí name ‚Üí ‚Ñï
{Œ± : Type u_1} [has_lt Œ±] {a b : Œ±} (h : a < b) : ¬¨a ‚ãñ b ‚Üî ‚àÉ (c : Œ±), a < c ‚àß c < b
{S : Type u‚ÇÅ} {L : Type u‚ÇÇ} {D : Type u‚ÇÉ} [category_theory.category S] [category_theory.category L] [category_theory.category D] {Œπ : S ‚•§ L} {F : S ‚•§ D} {G : L ‚•§ D} (x : L) (f : Œπ ‚ãô G ‚ü∂ F) : category_theory.limits.cone (category_theory.Ran.diagram Œπ F x)
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] [subsingleton M] [subsingleton M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] : has_zero (M ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)
(R : Type u_2) (M : Type u_3) [comm_semiring R] [add_comm_monoid M] [module R M] : tensor_product R M (module.dual R M) ‚Üí‚Çó[R] R
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} (hab : a = b) (hbc : b < c) : a < c
(a b : nnreal) {p q : nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) : a * b ‚â§ a ^ ‚Üëp / p + b ^ ‚Üëq / q
 : cardinal.mk ‚Ñù = cardinal.continuum
(C : Type u) [category_theory.category C] : Type (max (max v u) u v)
(K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] {A : set V} (hA : A.finite) : finite_dimensional K ‚Ü•(submodule.span K A)
 : Fintype.skeleton ‚•§ Fintype
{Œ± : Type u_1} [pseudo_metric_space Œ±] {E' : Type u_2} [normed_group E'] [normed_space ‚Ñù E'] [finite_dimensional ‚Ñù E'] {s : set Œ±} {f : Œ± ‚Üí E'} {K : nnreal} (hf : lipschitz_on_with K f s) : ‚àÉ (g : Œ± ‚Üí E'), lipschitz_with (lipschitz_extension_constant E' * K) g ‚àß set.eq_on f g s
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {e e' : local_homeomorph Œ± Œ≤} {f f' : local_homeomorph Œ≤ Œ≥} (he : e ‚âà e') (hf : f ‚âà f') : e.trans f ‚âà e'.trans f'
(Œπ : Type u_1) [fintype Œπ] : topological_space.positive_compacts (Œπ ‚Üí ‚Ñù)
{Œ± : Type u_1} {Œπ : Sort u_4} [complete_lattice Œ±] {b : Œ±} {f : Œπ ‚Üí Œ±} (h‚ÇÅ : ‚àÄ (i : Œπ), f i ‚â§ b) (h‚ÇÇ : ‚àÄ (w : Œ±), w < b ‚Üí (‚àÉ (i : Œπ), w < f i)) : (‚®Ü (i : Œπ), f i) = b
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (ùüô X) (ùüô X) _)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] {p : P} (hp : p ‚àà s) {v : V} (hv : v ‚àà (s.direction)·óÆ) : ‚áë(euclidean_geometry.orthogonal_projection s) (v +·µ• p) = ‚ü®p, hp‚ü©
 : pos_num ‚Üí ‚Ñï
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [group Œ≤] : group Œ±
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} (t : category_theory.limits.cofork f g) [category_theory.mono t.œÄ] : f = g
(h : interactive.parse (optional lean.parser.ident)) (q‚ÇÅ : interactive.parse (optional (lean.parser.tk ":" *> interactive.types.texpr))) (q‚ÇÇ : interactive.parse (optional (lean.parser.tk ":=" *> interactive.types.texpr))) : tactic unit
(ùïÇ : Type u_1) (ùïÇ' : Type u_2) (ùî∏ : Type u_3) [field ùïÇ] [field ùïÇ'] [ring ùî∏] [algebra ùïÇ ùî∏] [algebra ùïÇ' ùî∏] [topological_space ùî∏] [topological_ring ùî∏] : exp ùïÇ = exp ùïÇ'
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {f' : F} [linear_order ùïú] [order_closed_topology ùïú] {x y : ùïú} (h : x < y) : has_deriv_within_at f f' (set.Ioo x y) x ‚Üí has_deriv_within_at f f' (set.Ioi x) x
(L : first_order.language) (M : Type w') [L.is_ordered] [has_le M] [L.Structure M] : Prop
{Œ± : Type u} {Œπ : Type u_1} [topological_space Œ±] {s : set Œ±} {b : set Œπ} {c : Œπ ‚Üí set Œ±} (hs : is_compact s) (hc‚ÇÅ : ‚àÄ (i : Œπ), i ‚àà b ‚Üí is_open (c i)) (hc‚ÇÇ : s ‚äÜ ‚ãÉ (i : Œπ) (H : i ‚àà b), c i) : ‚àÉ (b' : set Œπ) (H : b' ‚äÜ b), b'.finite ‚àß s ‚äÜ ‚ãÉ (i : Œπ) (H : i ‚àà b'), c i
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M ‚Üí* P} (hg : ‚àÄ (y : ‚Ü•S), is_unit (‚áëg ‚Üëy)) (z : N) (w v : P) : ‚áë(f.lift hg) z * w = v ‚Üî ‚áëg (f.sec z).fst * w = ‚áëg ‚Üë((f.sec z).snd) * v
{Œ± : Type u} (s : string) (f : thunk Œ±) : Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X Y : C} {R : category_theory.presieve X} {x : category_theory.presieve.family_of_elements P R} (t : x.compatible) {f : Y ‚ü∂ X} (hf : R f) : x.sieve_extend f _ = x f hf
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] : category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ (category_theory.limits.kernel.Œπ f) _)
{Œ± : Type u_1} [has_mul Œ±] [linear_order Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_lt.lt] (m : Œ±) : Œ± ‚Ü™o Œ±
(p : ‚Ñï) [hp : fact (nat.prime p)] (n : ‚Ñï) : ‚Ñï ‚Üí mv_polynomial (fin 1 √ó ‚Ñï) ‚Ñ§
{Œπ : Type u} {Œ≥ : Type w} {Œ≤ : Œπ ‚Üí Type v} [monoid Œ≥] [Œ† (i : Œπ), add_monoid (Œ≤ i)] [Œ† (i : Œπ), distrib_mul_action Œ≥ (Œ≤ i)] : distrib_mul_action Œ≥ (Œ†‚ÇÄ (i : Œπ), Œ≤ i)
(tac : tactic.interactive.itactic) : tactic unit
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y : C} (f g : X ‚ü∂ Y) [category_theory.has_split_coequalizer f g] : category_theory.has_split_coequalizer (G.map f) (G.map g)
(Œ± : Type u_1) : Type u_1
(X : ‚Ñï ‚Üí Type) [Œ† (n : ‚Ñï), metric_space (X n)] [‚àÄ (n : ‚Ñï), compact_space (X n)] [‚àÄ (n : ‚Ñï), nonempty (X n)] (n : ‚Ñï) : Gromov_Hausdorff.aux_gluing_struct (X n)
(L : list ‚Ñï) (h : ‚àÄ (i : ‚Ñï), i ‚àà L ‚Üí 1 ‚â§ i) : L.length ‚â§ L.sum
{X : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) : ùí∞.glued_cover.glued ‚ü∂ X
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (n : with_top ‚Ñï) (f : E ‚Üí F) (x : E) : Prop
{R : Type u_1} (R‚Çõ : Type u_2) [comm_ring R] [comm_ring R‚Çõ] [algebra R R‚Çõ] (S : submonoid R) [hT : is_localization S R‚Çõ] {M : Type u_3} [add_comm_group M] [module R M] [module R‚Çõ M] [is_scalar_tower R R‚Çõ M] {Œπ : Type u_4} (b : basis Œπ R M) : basis Œπ R‚Çõ M
{R : Type u} [ring R] (s : subring R) {l : list R} : (‚àÄ (x : R), x ‚àà l ‚Üí x ‚àà s) ‚Üí l.sum ‚àà s
(n : ‚Ñï) : multiset ‚Ñï
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] (v : picard_lindelof E) : Type u_1
(R : Type u) {B : Type v} [comm_ring R] [decidable_eq B] [fintype B] (A : matrix B B ‚Ñ§) : B √ó B ‚Üí free_lie_algebra R (cartan_matrix.generators B)
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] (D : J ‚•§ T.algebra) (c : category_theory.limits.cone (D ‚ãô T.forget)) (t : category_theory.limits.is_limit c) : T.algebra
(Œ± : Type u) : Type u
{V : Type u} (G : simple_graph V) : Type u
{Œ± : Type u_1} [decidable_eq Œ±] [partial_order Œ±] [bounded_order Œ±] [is_simple_order Œ±] : lattice Œ±
{ùïú : Type u} {Œπ : Type v} {E : Œπ ‚Üí Type wE} {G : Type wG} [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] [normed_group G] [normed_space ùïú G] (f : continuous_multilinear_map ùïú E G) : ‚Ñù
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f g : V ‚Üí‚Çó[K] V} (hfg : f * g = 1) : g * f = 1
(R : Type u_3) {M : Type u_5} [topological_space M] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [has_continuous_add M] [module R M] [has_continuous_const_smul R M] [has_continuous_add M‚ÇÇ] [module R M‚ÇÇ] [has_continuous_const_smul R M‚ÇÇ] (Œ± : Type u_1) [topological_space Œ±] (g : M ‚ÜíL[R] M‚ÇÇ) : C(Œ±, M) ‚Üí‚Çó[R] C(Œ±, M‚ÇÇ)
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] [category_theory.limits.has_finite_products C] [category_theory.limits.has_finite_products D] (F : C ‚•§ D) {L : D ‚•§ C} (h : L ‚ä£ F) (A : C) [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) L] [category_theory.full F] [category_theory.faithful F] : category_theory.is_iso (category_theory.frobenius_morphism F h A)
{Œ± : Type u_1} [comm_semiring Œ±] (E : linear_recurrence Œ±) {u : ‚Ñï ‚Üí Œ±} {init : fin E.order ‚Üí Œ±} (h : E.is_solution u) (heq : ‚àÄ (n : fin E.order), u ‚Üën = init n) (n : ‚Ñï) : u n = E.mk_sol init n
(n : ‚Ñï+) (A : Type u) (K : Type w) [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] : Type w
 : add_comm_group ‚ÑÇ
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] [category_theory.limits.has_colimits_of_shape J C] (G : J ‚•§ K ‚•§ C) : category_theory.limits.colimit G ‚âÖ category_theory.curry.obj (category_theory.prod.swap K J ‚ãô category_theory.uncurry.obj G) ‚ãô category_theory.limits.colim
{X Y : Top} (f : X ‚âÖ Y) : ‚Ü•X ‚âÉ‚Çú ‚Ü•Y
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {n : ‚Ñï} : cont_diff ùïú ‚Üë(n + 1) f ‚Üî differentiable ùïú f ‚àß cont_diff ùïú ‚Üën (Œª (y : E), fderiv ùïú f y)
{Œ± : Type u} [has_repr Œ±] : tree Œ± ‚Üí string
(X : Type u) [uniform_space X] [complete_space X] [separated_space X] : CpltSepUniformSpace
{Œ± : Type u_1} [topological_space Œ±] {Œ≤ : Type u_2} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u_1} [uniform_space Œ±] (pkg : abstract_completion Œ±) {Œ≤ : Type u_2} [uniform_space Œ≤] (pkg' : abstract_completion Œ≤) {Œ≥ : Type u_3} [uniform_space Œ≥] (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : pkg.space ‚Üí pkg'.space ‚Üí Œ≥
{R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type u_3} [add_comm_group M] [module R M] {Œπ : Type u_1} [fintype Œπ] (b : basis Œπ R M) (N : submodule R M) : ‚àÉ (n : ‚Ñï), nonempty (basis (fin n) R ‚Ü•N)
{Œ≤ : Type u} {Œ± : Type v} {s : finset Œ±} {f : Œ± ‚Üí Œ≤} [add_comm_monoid Œ≤] (R : setoid Œ±) [decidable_rel setoid.r] (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí (finset.filter (Œª (y : Œ±), y ‚âà x) s).sum (Œª (a : Œ±), f a) = 0) : s.sum (Œª (x : Œ±), f x) = 0
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Œ† (x : clifford_algebra Q), x ‚àà clifford_algebra.even_odd Q 1 ‚Üí Prop} (hŒπ : ‚àÄ (v : M), P (‚áë(clifford_algebra.Œπ Q) v) _) (hadd : ‚àÄ {x y : clifford_algebra Q} {hx : x ‚àà clifford_algebra.even_odd Q 1} {hy : y ‚àà clifford_algebra.even_odd Q 1}, P x hx ‚Üí P y hy ‚Üí P (x + y) _) (hŒπŒπ_mul : ‚àÄ (m‚ÇÅ m‚ÇÇ : M) {x : clifford_algebra Q} {hx : x ‚àà clifford_algebra.even_odd Q 1}, P x hx ‚Üí P (‚áë(clifford_algebra.Œπ Q) m‚ÇÅ * ‚áë(clifford_algebra.Œπ Q) m‚ÇÇ * x) _) (x : clifford_algebra Q) (hx : x ‚àà clifford_algebra.even_odd Q 1) : P x hx
{J : Type v} {C : Type u} [category_theory.category C] {B : C} {objs : J ‚Üí C} (arrows : Œ† (j : J), B ‚ü∂ objs j) [category_theory.limits.has_wide_pushout B objs arrows] : B ‚ü∂ category_theory.limits.wide_pushout B objs arrows
(Œ± : Type u_6) (Œ≤ : Type u_7) [preorder Œ±] [preorder Œ≤] [mul_zero_one_class Œ±] [mul_zero_one_class Œ≤] : Type (max u_6 u_7)
{M : Type u_1} {N : Type u_2} {Œ± : Type u_6} {Œ≤ : Type u_7} [has_scalar M Œ±] [has_scalar Œ≤ Œ±] [smul_comm_class Œ≤ M Œ±] (g : N ‚Üí M) : smul_comm_class Œ≤ N Œ±
{m : Type u_1} {A : Type u_3} [fintype m] [comm_ring A] [is_domain A] [decidable_eq m] {M : matrix m m A} (hM : M.det ‚â† 0) : M.nondegenerate
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] (a b : Œ±) : multiset Œ±
{X : Type u_1} {R : Type u_3} [topological_space X] [normed_ring R] [complete_space R] {f : C(X, R)} (h : ‚àÄ (x : X), is_unit (‚áëf x)) : C(X, RÀ£)
{Œ± : Type u_1} (s : finset Œ±) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {e e' : local_equiv Œ± Œ≤} (h : e ‚âà e') : e.symm ‚âà e'.symm
(Œ± : Type u_1) [encodable Œ±] : decidable_eq Œ±
{Œ± : Type u} [pseudo_emetric_space Œ±] {s t : set Œ±} : emetric.Hausdorff_edist (closure s) (closure t) = emetric.Hausdorff_edist s t
{F G H : Type u} [group F] [group G] [group H] [fintype F] [fintype H] (f : F ‚Üí* G) (g : G ‚Üí* H) (h : g.ker = f.range) : fintype G
{C : Type u} [category_theory.category C] {F : C ‚•§ C} {A‚ÇÄ A‚ÇÅ A‚ÇÇ : category_theory.endofunctor.algebra F} (f : A‚ÇÄ.hom A‚ÇÅ) (g : A‚ÇÅ.hom A‚ÇÇ) : A‚ÇÄ.hom A‚ÇÇ
{R : Type u} {M : Type v} [monoid R] [mul_action R M] {p : sub_mul_action R M} (m : ‚Ü•p) : mul_action.stabilizer.submonoid R m = mul_action.stabilizer.submonoid R ‚Üëm
{Œ± : Type u_2} [decidable_eq Œ±] {B : finset (finset Œ±)} {n : ‚Ñï} [fintype Œ±] (h : ‚àÄ (a : Œ±), (finset.filter (has_mem.mem a) B).card ‚â§ n) : B.sum (Œª (s : finset Œ±), s.card) ‚â§ fintype.card Œ± * n
{G : Type u_1} [group G] {H : Type u_2} [group H] (f : G ‚Üí* H) (hf1 : f.ker ‚â§ subgroup.center G) (hH : group.is_nilpotent H) : group.is_nilpotent G
 : cc_state ‚Üí expr ‚Üí tactic format
 : tactic.suggest.head_symbol_match ‚Üí string
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] {a b : Œ±} : a ‚â§ b‚Åª¬π ‚Üí b ‚â§ a‚Åª¬π
{Œ± : Type u} (p : Œ± ‚Üí Prop) (s : stream Œ±) : Prop
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) : submodule R (M ‚ß∏ p) ‚Ü™o submodule R M
{Œ± : Type u} [comm_monoid Œ±] : Œ± ‚âÉ conj_classes Œ±
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (N : submodule R M) : Prop
{R : Type u_1} [comm_semiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] (f : M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] P) : tensor_product R M N ‚Üí+ P
{Œ± : Type u‚ÇÅ} {a b : Œ±} (h : a = b) : {as := a} ‚ü∂ {as := b}
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_terminal C] {P : C} (t : category_theory.limits.is_terminal P) : ‚ä§_ C ‚âÖ P
(C : Type u‚ÇÅ) [category_theory.category C] : Type u‚ÇÅ
{R : Type u} {S : Type v} [ring R] [set_like S R] [hSR : subring_class S R] (s : S) : ring ‚Ü•s
{R : Type u_1} {Œπ : Type u_2} {M : Type u_3} [ring R] [add_comm_group M] [module R M] [fintype Œπ] [is_noetherian R M] : is_noetherian R (Œπ ‚Üí M)
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f : M ‚Üí+ N) (M' : add_submonoid M) : ‚Ü•M' ‚Üí+ ‚Ü•(add_submonoid.map f M')
(c : tactic.abel.context) (n : ‚Ñ§) : tactic expr
{Œ≤ : Type u_2} [pseudo_metric_space Œ≤] {Œ± : Type u_1} [metric_space Œ±] {K : nnreal} {f : Œ± ‚Üí Œ≤} [proper_space Œ±] (hK : antilipschitz_with K f) (f_cont : continuous f) (hf : function.surjective f) : proper_space Œ≤
(env : environment) (n : name) : bool
{n : ‚Ñï} (f : equiv.perm (fin n)) (a : Œ£ (a : fin n), fin n) : Œ£ (a : fin n), fin n
{Œ± : Type u} [emetric_space Œ±] {s t : topological_space.closeds Œ±} : has_edist.edist s t = emetric.Hausdorff_edist ‚Üës ‚Üët
{Œ± : Type u_2} [comm_monoid Œ±] : comm_monoid (filter Œ±)
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] {module_M : module R M} {module_M‚ÇÇ : module R‚ÇÇ M‚ÇÇ} {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] (h : function.injective ‚áëf) : M ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] ‚Ü•(f.range)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {n : ‚Ñï} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : vector Œ± n ‚Üí vector Œ≤ n ‚Üí vector Œ≥ n
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ‚ü∂ Y} (t : category_theory.limits.kernel_fork f) (lift : Œ† (s : category_theory.limits.kernel_fork f), s.X ‚ü∂ t.X) (fac : ‚àÄ (s : category_theory.limits.kernel_fork f), lift s ‚â´ category_theory.limits.fork.Œπ t = category_theory.limits.fork.Œπ s) (uniq : ‚àÄ (s : category_theory.limits.kernel_fork f) (m : s.X ‚ü∂ t.X), m ‚â´ category_theory.limits.fork.Œπ t = category_theory.limits.fork.Œπ s ‚Üí m = lift s) : category_theory.limits.is_limit t
(L : first_order.language) (M : Type u_3) [L.Structure M] : L.elementary_embedding M M
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) (k : S.localization_map P) : N ‚âÉ+ P
{Œπ : Type u} [dec : decidable_eq Œπ] {Œ± : option Œπ ‚Üí Type v} [Œ† (i : option Œπ), has_zero (Œ± i)] : (Œ†‚ÇÄ (i : option Œπ), Œ± i) ‚âÉ Œ± option.none √ó Œ†‚ÇÄ (i : Œπ), Œ± (option.some i)
 : Type (u_1+1)
{R : Type u_1} {K : Type u_2} [semiring R] [comm_semiring K] (a b : R) (N : ‚Ñï) (f : polynomial R) (i : R ‚Üí+* K) : Prop
 : Preorder_to_PartialOrder ‚ä£ category_theory.forget‚ÇÇ PartialOrder Preorder
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) : 0 ‚àà s
{m : Type ‚Üí Type v} [monad m] {Œ± : Type u_1} {Œ≤ : Type} (f : Œ± ‚Üí m (option Œ≤)) : list Œ± ‚Üí m (list Œ≤)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (Œ± : F ‚âÖ G) : G.op ‚âÖ F.op
{Œ± : Type u} (s : stream (option Œ±)) : Prop
{X : Type u_2} [emetric_space X] [measurable_space X] [opens_measurable_space X] (m : set X ‚Üí ennreal) (hcl : ‚àÄ (s : set X), m (closure s) = m s) (r : ennreal) : (measure_theory.outer_measure.mk_metric'.pre m r).trim = measure_theory.outer_measure.mk_metric'.pre m r
(G‚ÇÄ : Type u_1) [measurable_space G‚ÇÄ] [has_div G‚ÇÄ] : Prop
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] : list Œ± ‚Üí option Œ± √ó list Œ±
{Œπ : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type u_3} [add_comm_group M] [module R M] [fintype Œπ] (b : basis Œπ R M) (N O : submodule R M) (N_le_O : N ‚â§ O) : ‚àÉ (n o : ‚Ñï) (hno : n ‚â§ o) (bO : basis (fin o) R ‚Ü•O) (bN : basis (fin n) R ‚Ü•N) (a : fin n ‚Üí R), ‚àÄ (i : fin n), ‚Üë(‚áëbN i) = a i ‚Ä¢ ‚Üë(‚áëbO (‚áë(fin.cast_le hno) i))
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (F : C ‚•§ D) : ‚Ü•(F.ess_image) ‚•§ D
(t : omega.term) : ‚Ñï
{Œ± : Type u} [topological_space Œ±] [t2_space Œ±] [compact_space Œ±] [totally_disconnected_space Œ±] {x : Œ±} {U : set Œ±} (is_open : _root_.is_open U) (memU : x ‚àà U) : ‚àÉ (V : set Œ±) (hV : is_clopen V), x ‚àà V ‚àß V ‚äÜ U
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) [category_theory.creates_limit K F] (c : category_theory.limits.cone (K ‚ãô F)) (t : category_theory.limits.is_limit c) : category_theory.lifts_to_limit K F c t
{Œ± : Type u} [lattice Œ±] {P : Œ± ‚Üí Prop} (Psup : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, P x ‚Üí P y ‚Üí P (x ‚äî y)) (Pinf : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, P x ‚Üí P y ‚Üí P (x ‚äì y)) : lattice {x // P x}
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} (f : Œ± ‚Ü™ Œ≤) (g : Œ≤ ‚Ü™ Œ≥) : Œ± ‚Ü™ Œ≥
{p : ‚Ñï} [hp : fact (nat.prime p)] (q : ‚Ñö_[p]) : ‚Ñö
{Œ± : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul Œ±] [add_comm_monoid Œ±] (A : matrix m n Œ±) [fintype n] : A.transpose.has_orthogonal_cols ‚Üî A.has_orthogonal_rows
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] : matrix.special_linear_group n R ‚Üí* ‚Ü•(matrix.GL_pos n R)
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} : (mvqpf.P F).W Œ± ‚Üí (mvqpf.P F).W Œ± ‚Üí Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {E' : Type u_6} [normed_group E'] [normed_space ùïú E'] {F' : Type u_7} [normed_group F'] [normed_space ùïú F'] {s : set E} {t : set E'} {f : E ‚Üí F} {g : E' ‚Üí F'} {p : E √ó E'} (hf : cont_diff_within_at ùïú n f s p.fst) (hg : cont_diff_within_at ùïú n g t p.snd) : cont_diff_within_at ùïú n (prod.map f g) (s √óÀ¢ t) p
{ùïú : Type u_1} [is_R_or_C ùïú] {E : Type u_2} {E' : Type u_3} [inner_product_space ùïú E] [inner_product_space ùïú E'] (f : E ‚âÉ‚Çó·µ¢[ùïú] E') (K : submodule ùïú E) [complete_space ‚Ü•K] (x : E') : ‚áë(reflection (submodule.map ‚Üë(f.to_linear_equiv) K)) x = ‚áëf (‚áë(reflection K) (‚áë(f.symm) x))
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {x y : E} : has_inner.inner (x + y) (x + y) = has_inner.inner x x + has_inner.inner x y + has_inner.inner y x + has_inner.inner y y
{L : first_order.language} (r : L.relations 2) : L.sentence
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_group Œ±] [add_comm_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_group_hom f) : is_add_group_hom (Œª (a : Œ±), -f a)
{t : Type u} [has_repr t] (g : slim_check.gen t) : io unit
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {t‚ÇÅ t‚ÇÇ : affine.triangle ‚Ñù P} {i‚ÇÅ i‚ÇÇ i‚ÇÉ j‚ÇÅ j‚ÇÇ j‚ÇÉ : fin 3} (hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ) (hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ) (hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ) (hj‚ÇÅ‚ÇÇ : j‚ÇÅ ‚â† j‚ÇÇ) (hj‚ÇÅ‚ÇÉ : j‚ÇÅ ‚â† j‚ÇÉ) (hj‚ÇÇ‚ÇÉ : j‚ÇÇ ‚â† j‚ÇÉ) (h‚ÇÅ : t‚ÇÇ.points j‚ÇÅ = t‚ÇÅ.orthocenter) (h‚ÇÇ : t‚ÇÇ.points j‚ÇÇ = t‚ÇÅ.points i‚ÇÇ) (h‚ÇÉ : t‚ÇÇ.points j‚ÇÉ = t‚ÇÅ.points i‚ÇÉ) : affine.simplex.altitude t‚ÇÇ j‚ÇÇ = affine_span ‚Ñù {t‚ÇÅ.points i‚ÇÅ, t‚ÇÅ.points i‚ÇÇ}
{Œ± : Type u_1} {G : Type u_4} [complete_lattice Œ±] [group G] (f‚ÇÅ f‚ÇÇ : G ‚Üí* Œ± ‚âÉo Œ±) (g : G) : function.semiconj (Œª (x : Œ±), ‚®Ü (g' : G), ‚áë(‚áëf‚ÇÅ g')‚Åª¬π (‚áë(‚áëf‚ÇÇ g') x)) ‚áë(‚áëf‚ÇÇ g) ‚áë(‚áëf‚ÇÅ g)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D·µí·µñ) : F.unop.op ‚âÖ F
{R : Type u} [comm_ring R] (M : Module R) (N : Module R) : Module.monoidal_category.tensor_obj M N ‚âÖ Module.monoidal_category.tensor_obj N M
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b : Œ±} (ha : 1 ‚â§ a) (hb : 1 ‚â§ b) : 1 ‚â§ a * b
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] : category_theory.triangulated.inv_rotate C ‚ãô category_theory.triangulated.rotate C ‚ü∂ ùü≠ (category_theory.triangulated.triangle C)
 : tactic (list expr)
(ic : tactic.instance_cache) (a b : expr) (na nb : ‚Ñö) : tactic (tactic.instance_cache √ó expr)
{Œ± : Type u} {Œ≤ : Type v} [add_zero_class Œ±] [add_zero_class Œ≤] : (Œ± ‚Üí+ Œ≤) ‚âÉ (multiplicative Œ± ‚Üí* multiplicative Œ≤)
(Œ± : Type u_2) [complete_lattice Œ±] : Prop
(p : ‚Ñï) [fact (nat.prime p)] {a : ‚Ñ§} : zmod.legendre_sym p a = -1 ‚Üî ¬¨is_square ‚Üëa
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] {i : Œ± ‚Üí Œ≤} [topological_space Œ≥] [t2_space Œ≥] {f : Œ± ‚Üí Œ≥} (di : dense_inducing i) (hf : ‚àÄ (b : Œ≤), ‚àÉ (c : Œ≥), filter.tendsto f (filter.comap i (nhds b)) (nhds c)) (a : Œ±) : di.extend f (i a) = f a
{Œ± : Type u_1} (m : set (measure_theory.outer_measure Œ±)) (s : set Œ±) : ennreal
{Œ± : Type u_1} [encodable Œ±] (a : Œ±) : ulower Œ±
{K : Type u_1} [field K] [fintype K] {K' : Type u_2} [field K'] [fintype K'] (p : ‚Ñï) [fact (nat.prime p)] [algebra (zmod p) K] [algebra (zmod p) K'] (hKK' : fintype.card K = fintype.card K') : K ‚âÉ‚Çê[zmod p] K'
{k : Type u} [field k] {G : Type u} [fintype G] [invertible ‚Üë(fintype.card G)] [group G] {V : Type u} [add_comm_group V] [module k V] [module (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] : is_complemented (submodule (monoid_algebra k G) V)
{Œ± : Type u_1} {Œ≤ : Type u_2} (m‚ÇÅ : measurable_space Œ±) (m‚ÇÇ : measurable_space Œ≤) : measurable_space (Œ± √ó Œ≤)
{R : Type u} [comm_semiring R] {Œπ : Type u_1} (s : finset Œπ) (p : Œπ ‚Üí polynomial R) (x : R) : polynomial.eval x (s.prod (Œª (j : Œπ), p j)) = s.prod (Œª (j : Œπ), polynomial.eval x (p j))
{Œ± : Type u} [partial_order Œ±] [order_bot Œ±] {a : Œ±} : is_min a ‚Üí a = ‚ä•
(n : ‚Ñ§) : C(‚Ü•circle, ‚ÑÇ)
 : fin 0 ‚âÉ pempty
(X : Type u_4) [topological_space X] : Prop
{R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} [comm_semiring R] [semiring A‚ÇÅ] [semiring A‚ÇÇ] [algebra R A‚ÇÅ] [algebra R A‚ÇÇ] (e : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ) : A‚ÇÇ ‚Üí A‚ÇÅ
{L : first_order.language} {L' : first_order.language} : L ‚Üí·¥∏ L.sum L'
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] [category_theory.limits.has_limits C] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.reflects_isomorphisms (category_theory.forget C)] {F G : Top.sheaf C X} (f : F ‚ü∂ G) : category_theory.is_iso f ‚Üî ‚àÄ (x : ‚Ü•X), category_theory.is_iso ((Top.presheaf.stalk_functor C x).map f)
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] {ùíú : ‚Ñï ‚Üí submodule R A} [graded_algebra ùíú] (t : set (projective_spectrum ùíú)) : homogeneous_ideal ùíú
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {P : C(X, Y) ‚Üí Prop} (f : C(X, Y)) (hf : P f) : f.homotopy_with f P
{C : Type u} [category_theory.category C] (F : C ‚•§ C) : category_theory.endofunctor.algebra F ‚•§ C
{C : Type u‚ÇÅ} [category_theory.category C] {X‚ÇÅ‚ÇÅ X‚ÇÅ‚ÇÇ X‚ÇÇ‚ÇÅ X‚ÇÇ‚ÇÇ X‚ÇÉ‚ÇÅ X‚ÇÉ‚ÇÇ : C} {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÉ‚ÇÅ : X‚ÇÉ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÇ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ} {v‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÅ} {v‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÉ‚ÇÇ} (s : category_theory.is_pushout h‚ÇÅ‚ÇÅ (v‚ÇÅ‚ÇÅ ‚â´ v‚ÇÇ‚ÇÅ) (v‚ÇÅ‚ÇÇ ‚â´ v‚ÇÇ‚ÇÇ) h‚ÇÉ‚ÇÅ) (p : h‚ÇÇ‚ÇÅ ‚â´ v‚ÇÇ‚ÇÇ = v‚ÇÇ‚ÇÅ ‚â´ h‚ÇÉ‚ÇÅ) (t : category_theory.is_pushout h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ) : category_theory.is_pushout h‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÇ h‚ÇÉ‚ÇÅ
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_assoc_semiring Œ±} {rŒ≤ : non_assoc_semiring Œ≤} (f : Œ± ‚Üí+* Œ≤) (a b : Œ±) : ‚áëf (a + b) = ‚áëf a + ‚áëf b
{Œ± : Type u} (ast : ‚Ñï) (t : tactic Œ±) : tactic Œ±
 : Semigroup ‚•§ Mon
{R : Type u_1} {L : Type u_2} {M : Type u_3} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) : lie_submodule R L M
{n : Type u} [decidable_eq n] [fintype n] {Œ± : Type v} [comm_ring Œ±] (A : matrix n n Œ±) {Œ≤ : Type u_1} (s : finset Œ≤) (f : n ‚Üí Œ≤ ‚Üí Œ±) (i : n) : s.sum (Œª (x : Œ≤), ‚áë(A.cramer) (Œª (j : n), f j x) i) = ‚áë(A.cramer) (Œª (j : n), s.sum (Œª (x : Œ≤), f j x)) i
(p : interactive.parse interactive.types.texpr) : conv unit
(Œ± : Type u) : Type u
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid M'] [module R M'] (b : basis Œπ R M) (f : M ‚âÉ‚Çó[R] M') : basis Œπ R M'
{Œ± : Type u} (L : list Œ±) {i j : ‚Ñï} (hi : i < (list.take j L).length) : (list.take j L).nth_le i hi = L.nth_le i _
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) [invertible A] : invertible A.det
{Œ± : Type u_1} [circular_preorder Œ±] {a b c : Œ±} (h : has_btw.btw a b c) : ¬¨has_sbtw.sbtw c b a
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] : fintype (equiv.perm Œ±)
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] (Œπ : Type u_4) [decidable_eq Œπ] (e : M ‚âÉ‚Çó[R] N) : orientation R M Œπ ‚âÉ orientation R N Œπ
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (g : poly Œ±) : poly Œ≤
 : hole_command
{X Y : AddCommGroup} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ+ ‚Ü•Y
{Œ± : Type u_1} [topological_space Œ±] (s : set Œ±) (hs : is_open s) : local_homeomorph Œ± Œ±
{Œ± : Type u_1} [emetric_space Œ±] (K : nnreal) (f : Œ± ‚Üí Œ±) : Prop
(p : ‚Ñï) [hp : fact (nat.prime p)] : ‚Ñï ‚Üí ‚Ñï ‚Üí mv_polynomial ‚Ñï ‚Ñ§
 : Bipointed ‚âå Bipointed
{F : Type u ‚Üí Type u} [functor F] (q : qpf F) : Prop
{M : Type u} [monoid M] {a : M} {x y : MÀ£} (h : semiconj_by a ‚Üëx ‚Üëy) : semiconj_by a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (f : M ‚Üí‚Çô* N) (S : subsemigroup N) : subsemigroup M
{M : Type u_2} [add_comm_group M] {A : Type u_5} [comm_ring A] [module A M] {N : Type u_1} [add_comm_group N] [module A N] (f : M ‚Üí‚Çó[A] M) (e : M ‚âÉ‚Çó[A] N) : ‚áëlinear_map.det (‚Üëe.comp (f.comp ‚Üë(e.symm))) = ‚áëlinear_map.det f
{E : Type u_2} [semi_normed_group E] [star_add_monoid E] [normed_star_group E] : isometry has_star.star
{J : Type v} [category_theory.small_category J] (F : J ‚•§ SemiRing) [category_theory.is_filtered J] : category_theory.limits.cocone F
{Œπ : Type u_1} [fintype Œπ] [decidable_eq Œπ] (t : matrix.transvection_struct Œπ ‚Ñù) : measure_theory.measure_preserving ‚áë(‚áëmatrix.to_lin' t.to_matrix) measure_theory.measure_space.volume measure_theory.measure_space.volume
{n : ‚Ñï} {Œ± : typevec (n + 1)} {Œ±' : typevec (n + 1)} (f : Œ±.drop.arrow Œ±'.drop) (g : Œ±.last ‚Üí Œ±'.last) : Œ±.arrow Œ±'
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.creates_colimits_of_size F] [category_theory.limits.has_colimits_of_size D] : category_theory.limits.preserves_colimits_of_size F
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [compact_space Œ±] [metric_space Œ≤] : continuous coe_fn
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [metric_space Œ≤] (f : Œ± ‚Üí Œ≤) (h : embedding f) : metric_space Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {s t : category_theory.limits.cocone F} (P : category_theory.limits.is_colimit s) (Q : category_theory.limits.is_colimit t) : s ‚âÖ t
{S : Type u_4} (H : S) {G : Type u_1} [linear_ordered_add_comm_group G] [set_like S G] [add_subgroup_class S G] : linear_ordered_add_comm_group ‚Ü•H
{a : Prop} (b : Prop) (h : a ‚Üî b) [D : decidable b] : decidable a
(J : Type v) : (category_theory.limits.wide_pushout_shape J)·µí·µñ ‚•§ category_theory.limits.wide_pullback_shape J
{T : Type u‚ÇÅ} [category_theory.category T] {X : T} {f g : category_theory.over X} (k : f ‚ü∂ g) [hk : category_theory.mono k.left] : category_theory.mono k
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] : category_theory.limits.kernel_fork category_theory.limits.biprod.snd
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) (a‚ÇÇ : Œ±) (h : ‚àÄ (a‚ÇÅ : Œ±), a‚ÇÅ ‚â† a‚ÇÇ ‚Üí ‚Ü•((‚áëf a‚ÇÅ).is_some)) : function.injective ‚áëf
{F : pfunctor} {X : Type u_1} (f : X ‚Üí F.obj X) (i : X) : F.M
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] : CommMon_ C ‚•§ Mon_ C
 : expr ‚Üí expr √ó list expr
{E : Type u_1} [semi_normed_group E] [normed_space ‚Ñù E] : E ‚âÉ‚Çú ‚Ü•(metric.ball 0 1)
{R : Type u} [ring R] (h : is_field R) : field R
 : environment ‚Üí name ‚Üí option (‚Ñï √ó ‚Ñï √ó ‚Ñï)
{Œ± : Type u_1} [has_mul Œ±] (s : set Œ±) (a b : Œ±) : Prop
 : Type
(M : Type u_9) (M‚ÇÇ : Type u_11) [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] (R : Type u_17) (S : Type u_18) [semiring S] [has_scalar R M] [module S M] [has_scalar R M‚ÇÇ] [module S M‚ÇÇ] : Type
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommMon) : category_theory.limits.is_limit (CommMon.limit_cone F)
{G H : Type u} [add_group G] [add_group H] [fintype H] (g : G ‚Üí+ H) [fintype ‚Ü•(g.ker)] : fintype G
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : free_comm_ring Œ± ‚Üí+* free_comm_ring Œ≤
 : cc_state ‚Üí expr ‚Üí bool
{G : Type u_1} [group G] {H K : subgroup G} (h : H ‚â§ K) : ‚Ü•H ‚Üí* ‚Ü•K
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {s t : category_theory.limits.fork f g} (k : s.X ‚ü∂ t.X) (w : k ‚â´ t.Œπ = s.Œπ) : s ‚ü∂ t
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type v} (f : J ‚Üí C) [category_theory.limits.preserves_colimit (category_theory.discrete.functor f) G] {P : C} (g : Œ† (j : J), f j ‚ü∂ P) (t : category_theory.limits.is_colimit (category_theory.limits.cofan.mk P g)) : category_theory.limits.is_colimit (category_theory.limits.cofan.mk (G.obj P) (Œª (j : J), G.map (g j)))
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b : Œ±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{Œ± : Type u_1} [topological_space Œ±] {ùïú : Type u_5} [topological_space ùïú] (s : set C(Œ±, ùïú)) : Prop
{R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà mul_action.orbit ‚Ü•(units.pos_subgroup R) v‚ÇÇ) : same_ray R v‚ÇÅ v‚ÇÇ
(K : Type u) [field K] (p : ‚Ñï) [fact (nat.prime p)] [char_p K p] (L : Type v) [comm_semiring L] [char_p L p] [perfect_ring L p] : (K ‚Üí+* L) ‚âÉ (perfect_closure K p ‚Üí+* L)
(p : tactic.ring_exp.ex tactic.ring_exp.ex_type.exp) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.prod)
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_wide_pushouts C
{ùïú : Type u_3} {E : Type u_4} {F : Type u_5} [semi_normed_ring ùïú] [add_comm_group E] [add_comm_group F] [module ùïú E] [module ùïú F] (f : E ‚Üí‚Çó[ùïú] F) : seminorm ùïú F ‚Üí+ seminorm ùïú E
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [comm_ring ùïú] [add_comm_group E] [add_comm_group F] [module ùïú E] [module ùïú F] [topological_space E] [topological_space F] [topological_add_group E] [has_continuous_const_smul ùïú E] [topological_add_group F] [has_continuous_const_smul ùïú F] (p : formal_multilinear_series ùïú E F) {n : ‚Ñï} (c : composition n) (j : fin n) (v : fin n ‚Üí E) (z : E) : p.apply_composition c (function.update v j z) = function.update (p.apply_composition c v) (c.index j) (‚áë(p (c.blocks_fun (c.index j))) (function.update (v ‚àò ‚áë(c.embedding (c.index j))) (c.inv_embedding j) z))
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : (closure s).nonempty ‚Üí s.nonempty
{x y : pgame} (h : x.lf y) (ox : x.numeric) (oy : y.numeric) : x ‚â§ y
 : tactic unit
{n : ‚Ñï} (p : fin n ‚Üí Prop) [decidable_pred p] {i : fin n} (hi : i ‚àà fin.find p) : p i
{ùïú : Type u_3} [is_R_or_C ùïú] {V : Type u_8} [inner_product_space ùïú V] [finite_dimensional ùïú V] {S : submodule ùïú V} (L : ‚Ü•S ‚Üí‚Çó·µ¢[ùïú] V) : V ‚Üí‚Çó·µ¢[ùïú] V
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] [t1_space Œ≤] {f : Œ± ‚Üí Œ≤} {a : Œ±} {b : Œ≤} (h : filter.tendsto f (nhds a) (nhds b)) : f a = b
(d : name) : tactic bool
(x y : pgame) : Prop √ó Prop
(G : Type u_3) [add_group G] [h : add_group.fg G] [decidable_pred (Œª (n : ‚Ñï), ‚àÉ (S : finset G), S.card = n ‚àß add_subgroup.closure ‚ÜëS = ‚ä§)] : ‚Ñï
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] {Œπ : Type u_3} [fintype Œπ] (f : Œπ ‚Üí S) : ‚àÉ (b : ‚Ü•M), ‚àÄ (i : Œπ), is_localization.is_integer R (‚Üëb ‚Ä¢ f i)
 : list expr ‚Üí tactic unit
(Œπ : Type u_1) {R : Type u_2} [add_monoid Œπ] [monoid R] : graded_monoid.gmonoid (Œª (i : Œπ), R)
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ AddCommGroup AddCommMon)
{Œ± : Type u} [omega_complete_partial_order Œ±] {Œ≤ Œ≥ : Type v} (f : Œ≤ ‚Üí Œ≥) (g : Œ± ‚ÜíùíÑ part Œ≤) : Œ± ‚ÜíùíÑ part Œ≥
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] (F : J ‚•§ C) : Type (max u‚ÇÅ u‚ÇÉ v‚ÇÉ)
 : ‚ÑÇ ‚âÉL[‚Ñù] ‚ÑÇ
{J : Type v} (f : J ‚Üí œâCPO) : category_theory.limits.fan f
{m : Type u_2} {n : Type u_3} {Œ± : Type v} {Œ≤ : Type w} (f : Œ± ‚âÉ Œ≤) : matrix m n Œ± ‚âÉ matrix m n Œ≤
(curr new : name) : tactic unit
{n : ‚Ñï} (P : mvpfunctor (n + 1)) : mvpfunctor n
 : pos_num ‚Üí pos_num
{R : Type u_1} {S : Type u_3} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S] : non_unital_non_assoc_semiring (R √ó S)
{Œ± : Type u} [decidable_eq Œ±] [mul_zero_one_class Œ±] [nontrivial Œ±] : mul_zero_one_class (with_bot Œ±)
{p : ‚Ñï} [fact (nat.prime p)] : ‚Ñ§_[p] ‚Üí+* ‚Ñö_[p]
{Œ± : Type u} {l : list Œ±} : l.nodup ‚Üí l.sublists'.nodup
(Œ± : Type u_1) [add_monoid Œ±] : add_units Œ± ‚Üí+ Œ± √ó Œ±·µÉ·µí·µñ
(M : Type u_10) (Œ± : Type u_11) [has_scalar M Œ±] : Prop
(F : Type u_7) (Œ± : out_param (Type u_8)) (Œ≤ : out_param (Type u_9)) [has_sup Œ±] [has_sup Œ≤] : Type (max u_7 u_8 u_9)
{K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] {R : Type u_3} [comm_ring R] [algebra R S] [algebra R K] [is_scalar_tower R K S] {B B' : power_basis K S} {P : polynomial R} (h : ‚áë(polynomial.aeval B.gen) P = B'.gen) (hB : is_integral R B.gen) (hmin : minpoly K B.gen = polynomial.map (algebra_map R K) (minpoly R B.gen)) (i : fin B.dim) (j : fin B'.dim) : is_integral R (B.basis.to_matrix ‚áë(B'.basis) i j)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) [has_lt Œ≤] (h : well_founded has_lt.lt) (s : set Œ±) (hs : s.nonempty) : Œ±
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R ‚Üí+* S) {r : R} : r ‚àà f.ker ‚Üî ‚áëf r = 0
{K : Type u} [field K] (s : subfield K) {Œπ : Type u_1} {t : finset Œπ} {f : Œπ ‚Üí K} (h : ‚àÄ (c : Œπ), c ‚àà t ‚Üí f c ‚àà s) : t.sum (Œª (i : Œπ), f i) ‚àà s
{Œ± Œ≤ : Type u} {f : Œ± ‚ü∂ Œ≤} (F' : category_theory.limits.mono_factorisation f) : category_theory.limits.types.image f ‚ü∂ F'.I
{Œ± : Type u_1} (R : Œ± ‚Üí Œ± ‚Üí Prop) : list Œ± ‚Üí Prop
{X : Type u} [preorder X] {x y : X} (h : x ‚ü∂ y) : x ‚â§ y
(p : interactive.parse interactive.types.texpr) : tactic unit
{G H : AddCommGroup} (f : G ‚ü∂ H) : AddCommGroup.image f ‚ü∂ H
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {f g : X ‚ü∂ Y} {c : category_theory.limits.kernel_fork (f - g)} (i : category_theory.limits.is_limit c) : category_theory.limits.is_limit (category_theory.preadditive.fork_of_kernel_fork c)
{F : pfunctor} (R : F.M ‚Üí F.M ‚Üí Prop) : Prop
{Œ± : Type u} [is_empty Œ±] : unique (list Œ±)
 : Type u ‚•§ category_theory.Cat
{X : Type u_1} [topological_space X] [noncompact_space X] : (nhds_within alexandroff.infty {alexandroff.infty}·∂ú).ne_bot
{n : with_top ‚Ñï} {ùïÇ : Type u_6} [is_R_or_C ùïÇ] {E' : Type u_7} [normed_group E'] [normed_space ùïÇ E'] {F' : Type u_8} [normed_group F'] [normed_space ùïÇ F'] {f : E' ‚Üí F'} {x : E'} (hf : cont_diff ùïÇ n f) (hn : 1 ‚â§ n) : has_strict_fderiv_at f (fderiv ùïÇ f x) x
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {A : Mon_ C} (M N : Mod A) : Type v‚ÇÅ
{R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_4} {M‚ÇÇ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : set M‚ÇÇ) : submodule.span R (‚áëf ‚Åª¬π' s) ‚â§ submodule.comap f (submodule.span R‚ÇÇ s)
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (A : set X) (f : X ‚Üí Y) : X ‚Üí Y
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : differentiable_on ‚Ñù f (interior D)) (hf'' : differentiable_on ‚Ñù (deriv f) (interior D)) (hf''_nonneg : ‚àÄ (x : ‚Ñù), x ‚àà interior D ‚Üí 0 ‚â§ deriv^[2] f x) : convex_on ‚Ñù D f
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {R : ‚Ñù} (h0 : 0 ‚â§ R) {f : ‚ÑÇ ‚Üí E} {c : ‚ÑÇ} {s : set ‚ÑÇ} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R)) (hd : ‚àÄ (z : ‚ÑÇ), z ‚àà metric.ball c R  s ‚Üí differentiable_at ‚ÑÇ f z) : ‚àÆ (z : ‚ÑÇ) in C(c, R), f z = 0
{Œ± : Type u_6} [add_monoid Œ±] : has_faithful_smul (add_monoid.End Œ±) Œ±
{Œ± : Type u} (f : thunk Œ±) : Œ±
{Œ± : Type u} {Œ≤ : Type v} {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} [partial_order Œ≤] [complete_lattice Œ±] (gi : galois_insertion l u) : complete_lattice Œ≤
{Œ± : Type u} [linear_ordered_cancel_comm_monoid Œ±] {Œ≤ : Type u_1} [has_one Œ≤] [has_mul Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : linear_ordered_cancel_comm_monoid Œ≤
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : set Œ±) (t : set Œ≤) : Prop
(Œ± : expr) : list expr ‚Üí tactic expr
{p : ‚Ñï} {Œ± : Type u_4} {Œ≤ : Type u_5} (f : Œ± ‚Üí Œ≤) : witt_vector p Œ± ‚Üí witt_vector p Œ≤
{Œ± : Type u} {Œ≤ : Type v} [monoid Œ±] [topological_space Œ±] [has_continuous_mul Œ±] [monoid Œ≤] [topological_space Œ≤] [has_continuous_mul Œ≤] : (Œ± √ó Œ≤)À£ ‚âÉ‚Çú Œ±À£ √ó Œ≤À£
{Œ± : Type u} [ring Œ±] : is_ring_hom id
{R : Type u_4} {S : Type u_5} [has_mul R] [has_add R] [has_mul S] [has_add S] (e : R ‚âÉ+* S) : S ‚Üí R
(G : Type u_1) [topological_space G] [group G] [topological_group G] : subgroup G
{Œ± : Type u} (c : order.coframe Œ±) (le : Œ± ‚Üí Œ± ‚Üí Prop) (eq_le : le = order.coframe.le) (top : Œ±) (eq_top : top = order.coframe.top) (bot : Œ±) (eq_bot : bot = order.coframe.bot) (sup : Œ± ‚Üí Œ± ‚Üí Œ±) (eq_sup : sup = order.coframe.sup) (inf : Œ± ‚Üí Œ± ‚Üí Œ±) (eq_inf : inf = order.coframe.inf) (Sup : set Œ± ‚Üí Œ±) (eq_Sup : Sup = order.coframe.Sup) (Inf : set Œ± ‚Üí Œ±) (eq_Inf : Inf = order.coframe.Inf) : order.coframe Œ±
{C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] {F : J ‚•§ C} {c‚ÇÅ : category_theory.limits.fan F.obj} {c‚ÇÇ : category_theory.limits.fan (Œª (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), F.obj f.fst.snd)} (s t : c‚ÇÅ.X ‚ü∂ c‚ÇÇ.X) (hs : ‚àÄ (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), s ‚â´ c‚ÇÇ.œÄ.app {as := f} = c‚ÇÅ.œÄ.app {as := f.fst.fst} ‚â´ F.map f.snd) (ht : ‚àÄ (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), t ‚â´ c‚ÇÇ.œÄ.app {as := f} = c‚ÇÅ.œÄ.app {as := f.fst.snd}) {i : category_theory.limits.fork s t} (t‚ÇÅ : category_theory.limits.is_limit c‚ÇÅ) (t‚ÇÇ : category_theory.limits.is_limit c‚ÇÇ) (hi : category_theory.limits.is_limit i) : category_theory.limits.is_limit (category_theory.limits.has_limit_of_has_products_of_has_equalizers.build_limit s t hs ht i)
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [linear_ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f g : E ‚Üí Œ≤} (hf : strict_convex_on ùïú s f) (hg : strict_convex_on ùïú s g) : strict_convex_on ùïú s (f ‚äî g)
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : 1 ‚àà S
{G‚ÇÄ : Type u_2} [group_with_zero G‚ÇÄ] (a : G‚ÇÄ) : a * a * a‚Åª¬π = a
{Œπ : Type w} {Œπ' : Type u_1} [fintype Œπ'] [fintype Œπ] (K : Type u) [field K] [number_field K] {b : basis Œπ ‚Ñö K} {b' : basis Œπ' ‚Ñö K} (h : ‚àÄ (i : Œπ) (j : Œπ'), is_integral ‚Ñ§ (b.to_matrix ‚áëb' i j)) (h' : ‚àÄ (i : Œπ') (j : Œπ), is_integral ‚Ñ§ (b'.to_matrix ‚áëb i j)) : algebra.discr ‚Ñö ‚áëb = algebra.discr ‚Ñö ‚áëb'
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] (p q : formal_multilinear_series ùïú E F) : linear_order.min p.radius q.radius ‚â§ (p + q).radius
{Œ± : Type u_1} (r : setoid Œ±) : setoid.ker quotient.mk = r
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {Œπ : Type u_3} [fintype Œπ] (b : basis Œπ R M) : M ‚âÉ‚Çó[R] module.dual R (module.dual R M)
{Œ± : Type u_1} [add_monoid Œ±] (s t : set Œ±) (a : Œ±) : set (Œ± √ó Œ±)
{R : Type u} [ring R] (p q : polynomial R) : polynomial R
(c : clifford_algebra clifford_algebra_complex.Q) : ‚áëclifford_algebra_complex.to_complex (‚áëclifford_algebra.involute c) = ‚áë(star_ring_end ‚ÑÇ) (‚áëclifford_algebra_complex.to_complex c)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) (i : E ‚âÉL[ùïú] F) : p.remove_zero.right_inv i = p.right_inv i
{G : Type u_1} [group G] (H : ‚Ñï ‚Üí subgroup G) : Prop
 : expr ‚Üí tactic (expr √ó expr)
(X : Top) (Y : CompHaus) : (StoneCech_obj X ‚ü∂ Y) ‚âÉ (X ‚ü∂ CompHaus_to_Top.obj Y)
(e : expr) : smt_tactic expr
{C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ‚Ñï} {i j : fin (n + 1)} (H : i ‚â§ j) : X.œÉ (‚áëfin.cast_succ i) ‚â´ X.œÉ j = X.œÉ j.succ ‚â´ X.œÉ i
{Œ± : Type u} [ordered_semiring Œ±] {a b c d : Œ±} [has_exists_add_of_le Œ±] (hab : a ‚â§ b) (hcd : c ‚â§ d) : a * d + b * c ‚â§ a * c + b * d
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.creates_limits_of_shape J F] : category_theory.creates_limits_of_shape J G
{Œ± : Type u_1} [decidable_eq Œ±] (l : list Œ±) (H : ‚àÄ (x : Œ±), x ‚àà l) : encodable Œ±
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} : has_mem Œ± (finmap Œ≤)
(R : Type u_1) [monoid R] [star_semigroup R] : submonoid R
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : differentiable_on ‚Ñù f (interior D)) (h_anti : strict_anti_on (deriv f) (interior D)) : strict_concave_on ‚Ñù D f
{n : Type u_5} {R : Type u_8} [topological_space R] [fintype n] [decidable_eq n] [comm_ring R] [topological_ring R] (A : matrix n n R) (h : continuous_at ring.inverse A.det) : continuous_at has_inv.inv A
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) : Type v
{B : Type u} [category_theory.bicategory B] {a b c : B} {f g : a ‚ü∂ b} (Œ∑ : f ‚âÖ g) (h : b ‚ü∂ c) : f ‚â´ h ‚âÖ g ‚â´ h
{M : Type u_1} [has_add M] (S : add_subsemigroup M) {x y : M} : x ‚àà S ‚Üí y ‚àà S ‚Üí x + y ‚àà S
{C : Type u} [category_theory.category C] {X Y : C} {f f' : X ‚ü∂ Y} [category_theory.limits.has_image f] [category_theory.limits.has_image f'] (h : f = f') : category_theory.limits.image f ‚ü∂ category_theory.limits.image f'
{C : Type u‚ÇÅ} [category_theory.category C] {B : C} (X Y : category_theory.subobject B) (h : X = Y) : ‚ÜëX ‚âÖ ‚ÜëY
{R : Type u} {n : Type w} [comm_ring R] [decidable_eq n] [fintype n] (J : matrix n n R) : lie_subalgebra R (matrix n n R)
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_mul Œ±] [preorder Œ±] [preorder Œ≤] {f g : Œ≤ ‚Üí Œ±} [covariant_class Œ± Œ± has_mul.mul has_le.le] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] (hf : monotone f) (hg : monotone g) : monotone (Œª (x : Œ≤), f x * g x)
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] [decidable_eq Œ±] {a : Œ±} (P : finpartition a) (b : Œ±) : finpartition (a  b)
(Œ± : Type u_2) [preorder Œ±] : pseudo_epimorphism Œ± Œ±
{R : Type u_1} {M : Type u_2} {N : Type w} [ring R] [add_comm_group M] [module R M] [add_comm_group N] [module R N] [is_noetherian R M] (f : M √ó N ‚Üí‚Çó[R] M) (i : function.injective ‚áëf) : N ‚âÉ‚Çó[R] punit
(Œ± : Type u) : (bool ‚Üí Œ±) ‚âÉ Œ± √ó Œ±
(G : Type u_2) [group G] (n : ‚Ñï) : vector G n ‚âÉ ‚Ü•(equiv.perm.vectors_prod_eq_one G (n + 1))
{Œ± : Type v} [canonically_ordered_add_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] [contravariant_class Œ± Œ± has_add.add has_le.le] {f : ‚Ñï ‚Üí Œ±} (h : monotone f) (n : ‚Ñï) : (finset.range n).sum (Œª (i : ‚Ñï), f (i + 1) - f i) = f n - f 0
{Œ± : Type u_1} (y : Œ±) : fintype {x // x = y}
{R : Type u_1} [comm_ring R] [is_domain R] {a b c : R} (h2 : 2 ‚â† 0) (ha : a ‚â† 0) (h : ‚àÄ (s : R), discrim a b c ‚â† s * s) (x : R) : a * x * x + b * x + c ‚â† 0
 : name ‚Üí name
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] (p : submodule R E) : {q // is_compl p q} ‚âÉ {f // ‚àÄ (x : ‚Ü•p), ‚áëf ‚Üëx = x}
(k : Type u_1) [comm_semiring k] (A : Type u_2) [semiring A] [algebra k A] (M : Type u_3) [add_comm_monoid M] [module k M] [module A M] [is_scalar_tower k A M] (N : Type u_4) [add_comm_monoid N] [module k N] [module A N] [is_scalar_tower k A N] : (M ‚Üí‚Çó[A] N) ‚Üí‚Çó[k] M ‚Üí‚Çó[k] N
{Œ± : Type u} (f : equiv.perm Œ±) {p : Œ± ‚Üí Prop} [fintype {x // p x}] (h : ‚àÄ (x : Œ±), p x ‚Üí p (‚áëf x)) : equiv.perm {x // p x}
{Œ± : Type u_1} [partial_order Œ±] (f : Œ± ‚Üí Œ±) (p : Œ± ‚Üí Prop) (hf : ‚àÄ (x : Œ±), x ‚â§ f x) (hfp : ‚àÄ (x : Œ±), p (f x)) (hmin : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, x ‚â§ y ‚Üí p y ‚Üí f x ‚â§ y) : closure_operator Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.is_iso f] : category_theory.split_mono f
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : set P} (ho : euclidean_geometry.orthocentric_system s) {p : fin 3 ‚Üí P} (hps : set.range p ‚äÜ s) (hpi : function.injective p) : affine_independent ‚Ñù p
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J ‚•§ C) {c : category_theory.limits.cocone F.op} (hc : category_theory.limits.is_colimit c) : category_theory.limits.is_limit c.unop
(i r : name) : tactic unit
 : list pexpr ‚Üí pexpr
{l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {Œ± : Type u_12} (A : matrix n l Œ±) (B : matrix n m Œ±) (C : matrix o l Œ±) (D : matrix o m Œ±) : matrix (n ‚äï o) (l ‚äï m) Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] {U : C} (R : category_theory.presieve U) (P : C·µí·µñ ‚•§ A) [category_theory.limits.has_products A] [category_theory.limits.has_pullbacks C] : A
{n : ‚Ñï} {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (b : Œ≤) (v : vector Œ± n) : (vector.scanl f b v).to_list = list.scanl f b v.to_list
{k : Type u_1} {P‚ÇÅ : Type u_2} {V‚ÇÅ : Type u_6} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] : (P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÅ) ‚Üí* V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÅ
{G : Type u_1} [group G] {Œ± : Type u_4} [monoid Œ±] [mul_distrib_mul_action G Œ±] (S : subgroup G) : mul_distrib_mul_action ‚Ü•S Œ±
{Œ± : Type u_2} {Œ≤ : Type u_3} {hŒ± : ordered_add_comm_group Œ±} {hŒ≤ : ordered_add_comm_group Œ≤} (f : Œ± ‚Üí Œ≤) (hf : monotone f) (map_mul : ‚àÄ (a b : Œ±), f (a + b) = f a + f b) : Œ± ‚Üí+o Œ≤
{t t' : Type u ‚Üí Type u} (eqv : Œ† (Œ± : Type u), t Œ± ‚âÉ t' Œ±) [traversable t] [is_lawful_traversable t] : is_lawful_traversable t'
(Œ± : Type u_1) [metric_space Œ±] [complete_space Œ±] [topological_space.second_countable_topology Œ±] [nonempty Œ±] : ‚àÉ (f : (‚Ñï ‚Üí ‚Ñï) ‚Üí Œ±), continuous f ‚àß function.surjective f
 : bool ‚Üí (‚Ñï ‚Üí bool √ó tactic.itauto.proof √ó ‚Ñï) ‚Üí ‚Ñï ‚Üí bool √ó tactic.itauto.proof √ó ‚Ñï
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] : (P1 ‚Üí·µÉ[k] P1) ‚Üí* V1 ‚Üí‚Çó[k] V1
{G‚ÇÄ : Type u_2} [group_with_zero G‚ÇÄ] {p : Œ† (g : G‚ÇÄ), g ‚â† 0 ‚Üí Prop} : (‚àÉ (g : G‚ÇÄ) (hg : g ‚â† 0), p g hg) ‚Üî ‚àÉ (g : G‚ÇÄÀ£), p ‚Üëg _
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x : V} (hx : x ‚â† 0) (Œ∏ : real.angle) : x = ‚áë(o.rotation Œ∏) x ‚Üî Œ∏ = 0
{Œ± : Type u_1} : multiset Œ±
{V : Type (u+1)} [category_theory.large_category V] : Action V (Mon.of punit) ‚âå V
(k : Type u_1) {P‚ÇÅ : Type u_2} {V‚ÇÅ : Type u_6} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] {x y : P‚ÇÅ} (h : function.injective bit0) : ‚áë(affine_equiv.point_reflection k x) y = y ‚Üî y = x
(y : ‚Ñù) (hy : 0 < y) : ennreal ‚âÉo ennreal
{ùïú : Type u_2} {E : Type u_5} [comm_semiring ùïú] [topological_space ùïú] [has_continuous_add ùïú] [has_continuous_const_smul ùïú ùïú] [add_comm_monoid E] [module ùïú E] [topological_space E] (M : Type u_1) [monoid M] [distrib_mul_action M ùïú] [smul_comm_class ùïú M ùïú] [topological_space M] [has_continuous_smul M ùïú] : has_continuous_smul M (weak_dual ùïú E)
(M : Type u_1) [has_mul M] : set M
 : category_theory.limits.walking_cospan ‚Üí category_theory.limits.walking_cospan ‚Üí Type v
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e e' : local_homeomorph Œ± Œ≤} (he : e ‚âà e') (s : set Œ±) : e.restr s ‚âà e'.restr s
{Œ± : Sort u} {Œ≤ : Sort v} {Œ≥ : Sort w} {g : Œ≤ ‚Üí Œ≥} (hg : function.bijective g) : function.bijective (function.comp g)
{Œ± : Type u_1} [measurable_space Œ±] {Œπ : Type u_2} [encodable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ennreal} (h : ‚àÄ (i : Œπ), measurable (f i)) : measurable (Œª (x : Œ±), ‚àë' (i : Œπ), f i x)
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] : {p // p.is_prime} ‚âÉo {p // p.is_prime ‚àß disjoint ‚ÜëM ‚Üëp}
{Œπ : Type u_1} (f : Œπ ‚Üí cardinal) : cardinal
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (u : RÀ£) (hu : ‚Üëu < 0) (v : module.ray R M) : u ‚Ä¢ v = -v
{K : Type u_1} [is_R_or_C K] (f : cau_seq K is_R_or_C.abs) : cau_seq ‚Ñù has_abs.abs
{K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {q : ‚Ñö} (v_eq_q : v = ‚Üëq) : {h := ‚Üë((generalized_continued_fraction.of q).h), s := seq.map (generalized_continued_fraction.pair.map coe) (generalized_continued_fraction.of q).s} = generalized_continued_fraction.of v
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.is_connected J] {B : C} {F : J ‚•§ category_theory.over B} (c : category_theory.limits.cone (F ‚ãô category_theory.over.forget B)) : category_theory.limits.cone F
{M : Type u_1} {Œ± : Type u_6} [monoid M] [mul_action M Œ±] [has_mul Œ±] (r s : M) (x y : Œ±) [is_scalar_tower M Œ± Œ±] [smul_comm_class M Œ± Œ±] : r ‚Ä¢ x * s ‚Ä¢ y = (r * s) ‚Ä¢ (x * y)
{R : Type u} [semiring R] : add_submonoid.closure {p : polynomial R | ‚àÉ (n : ‚Ñï) (a : R), p = ‚áë(polynomial.monomial n) a} = ‚ä§
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X ‚ü∂ Y) : Type (max u‚ÇÅ v‚ÇÅ)
{m n : ‚Ñï} : fin m ‚äï fin n ‚âÉ fin (m + n)
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (r : R) (n : ‚Ñï) : v.int_valuation_def r ‚â§ ‚Üë(‚áëmultiplicative.of_add (-‚Üën)) ‚Üî v.as_ideal ^ n ‚à£ ideal.span {r}
{Œ± : Type u_2} [monoid Œ±] : monoid (set Œ±)
{n : ‚Ñï} {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (b : Œ≤) {v : vector Œ± n} : (vector.scanl f b v).val = list.scanl f b v.val
 : category_theory.limits.walking_cospan ‚âå category_theory.limits.walking_cospan
 : tactic unit
{Œπ : Type u_1} {R : Type u_2} {A : Type u_4} [decidable_eq Œπ] [add_monoid Œπ] [comm_semiring R] [semiring A] [algebra R A] [Œ† (m : A), decidable (m ‚â† 0)] : add_monoid_algebra A Œπ ‚âÉ‚Çê[R] direct_sum Œπ (Œª (i : Œπ), A)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {J' : Type u‚ÇÇ} [category_theory.category J'] (e : J ‚âå J') [category_theory.limits.has_limits_of_shape J C] : category_theory.limits.has_limits_of_shape J' C
 : succ_order cardinal
{C : Type u‚ÇÅ} [category_theory.category C] {Z X Y P : C} {f : Z ‚ü∂ X} {g : Z ‚ü∂ Y} {inl : X ‚ü∂ P} {inr : Y ‚ü∂ P} (h : category_theory.is_pushout f g inl inr) [category_theory.limits.has_pushout f g] : P ‚âÖ category_theory.limits.pushout f g
{Œ± : Type u} (cmd : rand Œ±) : tactic Œ±
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_image f] : X ‚ü∂ ‚Üë(category_theory.limits.image_subobject f)
{B : Type u} [category_theory.bicategory B] {a b : B} {f g h i : a ‚ü∂ b} [category_theory.bicategory.lift_hom f] [category_theory.bicategory.lift_hom g] [category_theory.bicategory.lift_hom h] (Œ∑ : f ‚ü∂ g) (Œ∏ : g ‚ü∂ h) (Œπ : h ‚ü∂ i) [category_theory.bicategory.lift_hom‚ÇÇ Œ∑] [category_theory.bicategory.lift_hom‚ÇÇ Œ∏] : Œ∑ ‚â´ Œ∏ ‚â´ Œπ = (Œ∑ ‚â´ Œ∏) ‚â´ Œπ
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e : local_homeomorph Œ± Œ≤} {s : set Œ±} {t : set Œ≤} : e.is_image s t ‚Üí e.to_local_equiv.source ‚à© ‚áëe ‚Åª¬π' t = e.to_local_equiv.source ‚à© s
(e ty : expr) : option expr
 : Type (u_1+1)
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} {F : Top.presheaf C X} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) {G : Top.presheaf C X} (Œ± : F ‚âÖ G) : Top.presheaf.sheaf_condition_equalizer_products.diagram F U ‚âÖ Top.presheaf.sheaf_condition_equalizer_products.diagram G U
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : valuation_subring (is_dedekind_domain.height_one_spectrum.adic_completion K v)
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : set Œ±) : Prop
{Œ± : Type u} (B : boolean_algebra.core Œ±) : boolean_algebra Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {x : E} {s : set E} (h : x ‚àâ closure s) : has_fderiv_within_at f f' s x
{Œπ : Type u_1} {M : Type u_4} [topological_space M] [has_mul M] [has_continuous_mul M] : has_continuous_mul (Œπ ‚Üí M)
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_2} : W_type Œ≤ ‚Üí (Œ£ (a : Œ±), Œ≤ a ‚Üí W_type Œ≤)
(Œ± : Type u_1) [metric_space Œ±] : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_terminal C] : 0 ‚âÖ ‚ä§_ C
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_products C] : category_theory.over X ‚•§ (category_theory.prod_comonad X).coalgebra
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} (t : category_theory.limits.cofork f g) : (category_theory.limits.parallel_pair f g).obj category_theory.limits.walking_parallel_pair.one ‚ü∂ ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj t.X).obj category_theory.limits.walking_parallel_pair.one
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (X Y Z : category_theory.center C) : (X.tensor_obj Y).tensor_obj Z ‚âÖ X.tensor_obj (Y.tensor_obj Z)
(f : Type u‚ÇÄ ‚Üí Type u‚ÇÅ) : Type (max (u‚ÇÄ+1) u‚ÇÅ)
{M : Type u_1} [has_mul M] {r : M ‚Üí M ‚Üí Prop} {c : con M} (h : ‚àÄ (x y : M), r x y ‚Üí setoid.r x y) : con_gen r ‚â§ c
{Œ± : Type u_1} {M : Type u_2} {N : Type u_3} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid N] [module R N] (f : M ‚Üí‚Çó[R] N) : (Œ± ‚Üí‚ÇÄ M) ‚Üí‚Çó[R] Œ± ‚Üí‚ÇÄ N
{C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (hu : category_theory.cover_lifting J K G) (‚Ñ± : category_theory.Sheaf J A) {X : A} {U : D} {S : category_theory.sieve U} (hS : S ‚àà ‚áëK U) {x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj ‚Ñ±.val ‚ãô category_theory.coyoneda.obj (opposite.op X)) S.arrows} (hx : x.compatible) (y : ((category_theory.Ran G.op).obj ‚Ñ±.val ‚ãô category_theory.coyoneda.obj (opposite.op X)).obj (opposite.op U)) (hy : x.is_amalgamation y) : y = category_theory.Ran_is_sheaf_of_cover_lifting.glued_section hu ‚Ñ± hS hx
{G : Type u_10} {H : Type u_11} [mul_one_class G] [add_zero_class H] : additive G ‚âÉ+ H ‚âÉ (G ‚âÉ* multiplicative H)
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : Prop
{Œ± : Type u_1} [preorder Œ±] (a b : Œ±) : set Œ±
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [decidable_eq Œπ] [Œ† (i : Œπ), has_zero (Œ± i)] (s : finset Œπ) (t : Œ† (i : Œπ), finset (Œ± i)) : finset (Œ†‚ÇÄ (i : Œπ), Œ± i)
(b : ‚Ñ§) : b ‚â§ b ^ 2
{L : first_order.language} {T : L.Theory} {M : T.Model} {N : Type w'} (e : ‚Ü•M ‚âÉ N) : T.Model
{Œ± : Type u_1} [measurable_space Œ±] (s : measure_theory.signed_measure Œ±) : measure_theory.jordan_decomposition Œ±
{p : Prop} (h : p) : p ‚âÉ punit
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty) (sc : is_closed s) : a ‚àà s
{z : upper_half_plane} (hz : z ‚àà modular_group.fdo) (n : ‚Ñ§) : 1 < ‚áëcomplex.norm_sq ‚Üë(modular_group.T ^ n ‚Ä¢ z)
{Œπ : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type u_3} [add_comm_group M] [module R M] [fintype Œπ] (b : basis Œπ R M) (N : submodule R M) : Œ£ (n : ‚Ñï), basis.smith_normal_form N Œπ n
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Prop
{S : Type u} [pgame.state S] (n : ‚Ñï) (s : S) (h : pgame.state.turn_bound s ‚â§ n) : pgame
{Œ± : Type u_1} (S : set Œ±) : ‚Ü•ùí´S ‚âÉ set ‚Ü•S
{Œ±‚ÇÅ : Type u_1} {Œ≤‚ÇÅ : Type u_2} {Œ≤‚ÇÇ : Type u_3} (e : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ ‚âÉ Œ≤‚ÇÇ) : Œ≤‚ÇÅ √ó Œ±‚ÇÅ ‚âÉ Œ≤‚ÇÇ √ó Œ±‚ÇÅ
{Œ± : Type} (p : parser Œ±) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_terminal C] [category_theory.limits.has_terminal D] (f : G.obj (‚ä§_ C) ‚âÖ ‚ä§_ D) : category_theory.limits.preserves_limit (category_theory.functor.empty C) G
(p : interactive.parse tactic.interactive.cases_arg_p) (q : interactive.parse interactive.types.with_ident_list) : tactic unit
{C : Type u} [category_theory.category C] (X : C) {D : Type u'} [category_theory.category D] (f : C ‚•§ D) : category_theory.End X ‚Üí* category_theory.End (f.obj X)
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C] (F : category_theory.limits.walking_parallel_pair ‚•§ C) : category_theory.limits.is_limit (category_theory.limits.has_equalizers_of_pullbacks_and_binary_products.equalizer_cone F)
(_x : interactive.parse (lean.parser.tk "#simp")) : lean.parser unit
(p : ‚Ñï) [hp : fact (nat.prime p)] : ‚Ñ§_[p] ‚Üí+* witt_vector p (zmod p)
(x : ‚Ñù) : ‚Ñù
{Œ± : Type u_1} [add_group Œ±] {s : add_subgroup Œ±} : Œ± ‚âÉ (Œ± ‚ß∏ s) √ó ‚Ü•s
(f : Type u‚ÇÄ ‚Üí Type u‚ÇÅ) (g : Type v‚ÇÄ ‚Üí Type v‚ÇÅ) : Type (max (u‚ÇÄ+1) u‚ÇÅ (v‚ÇÄ+1) v‚ÇÅ)
(f : expr ‚Üí expr ‚Üí expr ‚Üí expr √ó expr ‚Üí expr √ó expr ‚Üí tactic.norm_fin.eval_fin_m expr) (a b : expr) : tactic expr
{M : Type u_1} {R : Type u_2} [monoid M] [non_unital_non_assoc_ring R] [distrib_mul_action M R] (k : M) (h : ‚àÄ (x : R), k ‚Ä¢ x = 0 ‚Üí x = 0) {a b : R} (h' : k ‚Ä¢ a = k ‚Ä¢ b) : a = b
{g : equiv.perm (fin 5)} (h : 3 ‚àà g.cycle_type) : (g * g).is_three_cycle
{C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C] : category_theory.limits.initial_mono_class C
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] (f : linear_map.general_linear_group R M) : M ‚âÉ‚Çó[R] M
{Œ± : Type u} (x : Œ±) : dlist Œ± ‚Üí dlist Œ±
{ùïú : Type u_1} {V : Type u_2} {V‚ÇÇ : Type u_4} {P : Type u_8} {P‚ÇÇ : Type u_9} [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V P] [normed_add_torsor V‚ÇÇ P‚ÇÇ] (e : P ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÇ) : V ‚âÉ‚Çó·µ¢[ùïú] V‚ÇÇ
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] {c : E} (f : cont_diff_bump c) : E ‚Üí ‚Ñù
{A : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [ring A] [add_comm_group M] [add_comm_group M‚ÇÇ] [module A M] [module A M‚ÇÇ] [topological_space M] [topological_space M‚ÇÇ] (R : Type u_4) [ring R] [module R M] [module R M‚ÇÇ] [linear_map.compatible_smul M M‚ÇÇ R A] (f : M ‚ÜíL[A] M‚ÇÇ) : M ‚ÜíL[R] M‚ÇÇ
{S : Type u_2} [comm_ring S] (A : Type u_6) [comm_ring A] [is_domain A] [algebra A S] {M : submonoid A} [is_localization M S] (hM : M ‚â§ non_zero_divisors A) : is_domain S
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {b‚ÇÇ : basis (fin 2) ‚Ñù V} (hb‚ÇÇ : orthonormal ‚Ñù ‚áëb‚ÇÇ) (ho : b.orientation = -b‚ÇÇ.orientation) : ‚àÉ (Œ∏ : real.angle), b‚ÇÇ = b.map (hb.conj_lie.trans (hb.rotation Œ∏)).to_linear_equiv
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) : category_theory.limits.is_limit (Mon.has_limits.limit_cone F)
 : circle_deg1_liftÀ£ ‚Üí* ‚Ñù ‚âÉo ‚Ñù
(n : ‚Ñï) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 < x) : 0 < polynomial.eval x (polynomial.cyclotomic n R)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.split_epi_category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.epi f] : category_theory.split_epi f
(C : Type u) [category_theory.category C] : category_theory.category (algebraic_geometry.PresheafedSpace C)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {f g : ‚Ñù ‚Üí E} {x : ‚Ñù} (f_diff : ‚àÄ (y : ‚Ñù), y ‚â† x ‚Üí has_deriv_at f (g y) y) (hf : continuous_at f x) (hg : continuous_at g x) (y : ‚Ñù) : has_deriv_at f (g y) y
{Œ± : Type u_1} [linear_order Œ±] {A B : finset Œ±} (t : Œ±) (h‚ÇÅ : A.to_colex < B.to_colex) (h‚ÇÇ : ‚àÄ (x : Œ±), x ‚àà B ‚Üí x < t) (x : Œ±) (H : x ‚àà A) : x < t
 : local_homeomorph ‚Ñù ‚Ñù
{R : Type u} [ring R] {S : Type v} [ring S] (f : R ‚Üí+* S) (p : polynomial S) : p ‚àà polynomial.lifts f ‚Üî p ‚àà polynomial.lifts_ring f
(Œ± : Sort u) : Type
{Œ± : Type u_1} [canonically_ordered_add_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b c : Œ±} [contravariant_class Œ± Œ± has_add.add has_le.le] (h : a + c < b) : a < b - c
(msecs : ‚Ñï) : tactic unit
(ids : tactic.list_Pi tactic.rcases_patt) : tactic unit
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G : J ‚•§ C} (Œ± : F ‚âÖ G) (c : category_theory.limits.cocone F) (d : category_theory.limits.cocone G) (w : (category_theory.limits.cocones.precompose Œ±.inv).obj c ‚âÖ d) : category_theory.limits.is_colimit c ‚âÉ category_theory.limits.is_colimit d
{Œ± : Type u_1} {Œ≤ : Type u_2} [primcodable Œ±] [primcodable Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {Œ± : Type u_1} [has_zero Œ±] [mul_action_with_zero A Œ±] (S : subalgebra R A) : mul_action_with_zero ‚Ü•S Œ±
(d : declaration) : tactic (option string)
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} {s : finset Œ±} [comm_monoid Œ≤] [decidable_eq Œ≥] (f : Œ≥ ‚Üí Œ≤) (g : Œ± ‚Üí Œ≥) : s.prod (Œª (a : Œ±), f (g a)) = (finset.image g s).prod (Œª (b : Œ≥), f b ^ (finset.filter (Œª (a : Œ±), g a = b) s).card)
{K : Type u} [field K] {s : set K} {t : subfield K} : subfield.closure s ‚â§ t ‚Üî s ‚äÜ ‚Üët
{Œπ : Type u_1} {f : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), has_mul (f i)] (C : Œ† (i : Œπ), con (f i)) : con (Œ† (i : Œπ), f i)
{Œ± : Type u} {Œ≤ : Type v} [linear_ordered_field Œ±] [topological_space Œ±] [order_topology Œ±] {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±} {C : Œ±} (hC : 0 < C) (hf : filter.tendsto f l filter.at_bot) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (Œª (x : Œ≤), f x * g x) l filter.at_bot
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine.simplex ‚Ñù P 1) : s.circumcenter = finset.centroid ‚Ñù finset.univ s.points
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] (h : X ‚âÉ‚Çú Y) : continuous_map.homotopy_equiv X Y
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddCommMon) : category_theory.limits.is_colimit (AddCommMon.filtered_colimits.colimit_cocone F)
(Œ± : Type u) : Type u
(K : Type u) : Type u
(M : Type u_1) [monoid M] : submonoid M
{R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] {abv : absolute_value R ‚Ñ§} {Œπ : Type u_5} [decidable_eq Œπ] [fintype Œπ] (bS : basis Œπ R S) (adm : abv.is_admissible) [infinite R] : fin (class_group.cardM bS adm).succ ‚Ü™ R
{R : Type u_1} [comm_semiring R] (S : Type u_2) [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] (Q : Type u_4) [comm_semiring Q] [algebra P Q] (f : R ‚Üí+* P) (r : R) [is_localization.away r S] [is_localization.away (‚áëf r) Q] : S ‚Üí+* Q
{R : Type u} [semiring R] (p : polynomial R) : R
{M : Type u_1} [monoid M] (s : set M) : Prop
{Œ≤ : Type u_2} {f g : Œ≤ ‚Üí ‚Ñù} (hg : ‚àÄ (b : Œ≤), 0 ‚â§ g b) (hgf : ‚àÄ (b : Œ≤), g b ‚â§ f b) (hf : summable f) : summable g
(no_dflt : bool) (hs : list tactic.simp_arg_type) (attr : list name) : tactic (list (tactic expr) √ó tactic (list expr))
{Œ± : Type u} {Œ≤ : Type v} [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] (f : Œ± ‚Üío Œ≤) : Prop
{m : Type u ‚Üí Type u_1} [monad m] {Œ± Œ≤ : Type u} (f : Œ± ‚Üí Œ± ‚Üí m Œ≤) : list Œ± ‚Üí m (list Œ≤)
{C : Type u} [category_theory.category C] {U : Top} (X : algebraic_geometry.PresheafedSpace C) {f : U ‚ü∂ ‚ÜëX} (h : open_embedding ‚áëf) : X.restrict h ‚ü∂ X
 : category_theory.Cat ‚•§ Type u
{Œ± : Type u} [metric_space Œ±] [proper_space Œ±] {s : set Œ±} (hs : is_closed s) {R : Œ± ‚Üí ‚Ñù} (hR : ‚àÄ (x : Œ±), x ‚àà s ‚Üí 0 < R x) : ‚àÉ (Œπ : Type u) (c : Œπ ‚Üí Œ±) (r r' : Œπ ‚Üí ‚Ñù), (‚àÄ (i : Œπ), c i ‚àà s ‚àß 0 < r i ‚àß r i < r' i ‚àß r' i < R (c i)) ‚àß locally_finite (Œª (i : Œπ), metric.ball (c i) (r' i)) ‚àß s ‚äÜ ‚ãÉ (i : Œπ), metric.ball (c i) (r i)
{M : Type u_1} [monoid M] {s t : set M} (h : s ‚äÜ t) : monoid.closure s ‚äÜ monoid.closure t
(L : first_order.language) (M : Type w) (N : Type w') [L.Structure M] [L.Structure N] : Type (max w w')
 : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.prod)
(Œ± : Type u‚ÇÅ) : category_theory.small_category (category_theory.discrete Œ±)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} {Œ≥ : Type u_1} (s : finmap Œ≤) (f : alist Œ≤ ‚Üí Œ≥) (H : ‚àÄ (a b : alist Œ≤), a.entries ~ b.entries ‚Üí f a = f b) : Œ≥
(Œ± : Type u_6) : Type u_6
(n : name) (vars : list expr) (p : expr) : tactic unit
{Œ± : Type u_1} : Œ± ‚Ü™ option Œ±
{k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k ‚Üí E} {a b r : k} (hab : a < b) (h‚ÇÄ : 0 < r) (h‚ÇÅ : r < 1) : ‚áë(affine_map.line_map (f a) (f b)) r < f (‚áë(affine_map.line_map a b) r) ‚Üî slope f (‚áë(affine_map.line_map a b) r) b < slope f a (‚áë(affine_map.line_map a b) r)
{Œ± : Type u_1} : list Œ± ‚Üí Prop
{X : Type u_1} [topological_space X] (x y : X) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [category_theory.epi f] [category_theory.limits.has_cokernel g] : category_theory.limits.cokernel (f ‚â´ g) ‚âÖ category_theory.limits.cokernel g
(M : Type u_9) (N : Type u_10) [add_zero_class M] [add_zero_class N] : Type (max u_10 u_9)
{ùïú : Type u_1} {E : Type u_2} [normed_field ùïú] [has_norm E] {a : ùïú} {f : ùïú ‚Üí E} (h : filter.is_bounded_under has_le.le (nhds_within a {a}·∂ú) (has_norm.norm ‚àò f)) : f =o[nhds_within a {a}·∂ú] Œª (x : ùïú), (x - a)‚Åª¬π
(M : Type u_1) [has_add M] : set M
(tac : tactic.interactive.itactic) : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (m : measurable_space Œ≤) : measurable_space Œ±
(atoms : tactic.ref (buffer expr)) : expr ‚Üí tactic tactic.itauto.prop
{R : Type u_1} {S : Type u_2} [canonically_ordered_comm_semiring R] [decidable_eq R] [nontrivial R] [canonically_ordered_comm_semiring S] [decidable_eq S] [nontrivial S] (f : R ‚Üí+* S) (hf : function.injective ‚áëf) : with_top R ‚Üí+* with_top S
{Œ± : Type u_1} {Œπ : Sort u_4} (p : Œπ ‚Üí Prop) (s : Œπ ‚Üí set Œ±) : Prop
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X : C) : Type u
(Œ± : Type) [has_zero Œ±] [has_one Œ±] [has_add Œ±] [fintype Œ±] : parser Œ±
 : Fintype.skeleton ‚Üí ‚Ñï
(m : ‚Ñï) : (list ‚Ñï √ó omega.term) √ó list ‚Ñï √ó omega.term ‚Üí tactic (list ‚Ñï √ó omega.term)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C
 : PartialFun ‚âå Pointed
{M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] (f : M ‚Üí+ N) (a b : M) : ‚áëf (a + b) = ‚áëf a + ‚áëf b
{Œ± : Type u_1} : has_zero (language Œ±)
{Œ± : Type u} : seq Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (c : category_theory.limits.cone F) : category_theory.limits.cocone F.op
{R : Type u} [ring R] : category_theory.abelian (Module R)
{n : ‚Ñï} {A : Type u} {Œ± Œ≤ : typevec n} : mvqpf.const n A Œ± ‚Üí mvqpf.const n A Œ≤
{M : Type u_1} [has_mul M] (c : con M) : has_coe_t M c.quotient
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J ‚Üí C) [category_theory.limits.has_biproduct f] {b : category_theory.limits.bicone f} (hb : b.is_bilimit) : (hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.biproduct.is_limit f)).inv = category_theory.limits.biproduct.desc b.Œπ
{R : Type u_2} [comm_ring R] [is_domain R] [decidable_eq R] [fintype R] {p : polynomial R} (hp : 0 < p.degree) : fintype.card R ‚â§ p.nat_degree * (finset.image (Œª (x : R), polynomial.eval x p) finset.univ).card
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_cokernel f] {Z : C} (l : Z ‚ü∂ Y) (i : X ‚âÖ Z) (h : i.hom ‚â´ l = f) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ (category_theory.limits.cokernel.œÄ f) _)
{K : Type u_1} [linear_ordered_field K] {a b c : K} (ha : a ‚â† 0) (h : ‚àÄ (x : K), 0 < a * x * x + b * x + c) : discrim a b c < 0
(R : Type u) [comm_ring R] (U : (topological_space.opens ‚Ü•(algebraic_geometry.prime_spectrum.Top R))·µí·µñ) : subring (Œ† (x : ‚Ü•(opposite.unop U)), algebraic_geometry.structure_sheaf.localizations R ‚Üëx)
{Œ± : Type u} {Œπ : Type u_1} {s : set Œπ} (hs : s.finite) {t : Œ† (i : Œπ), i ‚àà s ‚Üí set Œ±} (ht : ‚àÄ (i : Œπ) (H : i ‚àà s), (t i H).finite) : (‚ãÉ (i : Œπ) (H : i ‚àà s), t i H).finite
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] [fintype R] [decidable_eq S] (f : R ‚Üí+* S) : fintype ‚Ü•(f.srange)
(C : Type u) [category_theory.category C] : Type (max v u)
 : Type
{ùïú : Type u} [nondiscrete_normed_field ùïú] {E : Type v} [normed_group E] [normed_space ùïú E] {F : Type w} [normed_group F] [normed_space ùïú F] [complete_space ùïú] [finite_dimensional ùïú E] [finite_dimensional ùïú F] (cond : finite_dimensional.finrank ùïú E = finite_dimensional.finrank ùïú F) : nonempty (E ‚âÉL[ùïú] F)
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ : X} (p‚ÇÄ p‚ÇÅ : path x‚ÇÄ x‚ÇÅ) : Prop
(s : simp_lemmas) (hs : list (expr √ó bool)) : tactic simp_lemmas
(Œ± : Type u_1) [omega_complete_partial_order Œ±] : œâCPO
(c1 c2 : linarith.comp) (a : ‚Ñï) : option (‚Ñï √ó ‚Ñï)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (e : C ‚âå D) (F : D ‚•§ E) : e.inverse ‚ãô e.functor ‚ãô F ‚âÖ F
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {J : Type v} [category_theory.small_category J] [category_theory.fin_category J] (F : J ‚•§ C) : category_theory.limits.cone F
{E : Type u_1} {F : Type u_2} [inner_product_space ‚Ñù E] [inner_product_space ‚Ñù F] {f : E ‚Üí F} {x : E} (h : conformal_at f x) : ‚Ñù
 : expr ‚Üí norm_num.match_numeral_result
(k : ‚Ñï) : ‚Ñï ‚Üí list (fin k ‚Üí ‚Ñï)
{Œ≤ : Type u_1} (x : Œ≤) {n : ‚Ñï} (Œ± : typevec n) : Œ±.arrow (typevec.repeat n Œ≤)
{Œ± : Type u} {Œ≤ : Type v} [mul_one_class Œ±] [mul_one_class Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_monoid_hom f) (x y : Œ±) : f (x * y) = f x * f y
{p a b : ‚Ñï} (hpb : p ‚àà b.factors) (ha : a ‚â† 0) : p ‚àà (a * b).factors
{R : Type u_3} {M : Type u_5} [ring R] [add_comm_group M] [module R M] {n : ‚Ñï} {N O : submodule R M} (y : M) (yO : y ‚àà O) (b : basis (fin n) R ‚Ü•N) (hNO : N ‚â§ O) (hli : ‚àÄ (c : R) (x : M), x ‚àà N ‚Üí c ‚Ä¢ y + x = 0 ‚Üí c = 0) (hsp : ‚àÄ (z : M), z ‚àà O ‚Üí (‚àÉ (c : R), z + c ‚Ä¢ y ‚àà N)) : basis (fin (n + 1)) R ‚Ü•O
{Œ± : Type u_1} [has_le Œ±] {a : Œ±·µí·µà} : is_max a ‚Üí is_min (‚áëorder_dual.of_dual a)
{J : Type u} [category_theory.category J] [category_theory.is_cofiltered J] (F : J ‚•§ Type v) [Œ† (j : J), fintype (F.obj j)] [‚àÄ (j : J), nonempty (F.obj j)] : F.sections.nonempty
{C : Type u} [category_theory.category C] (F : C ‚•§ C) : category_theory.category (category_theory.endofunctor.algebra F)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (G : C ‚•§ D) [G.preserves_zero_morphisms] [category_theory.limits.has_kernel f] [category_theory.limits.has_kernel (G.map f)] : G.obj (category_theory.limits.kernel f) ‚ü∂ category_theory.limits.kernel (G.map f)
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≤' : Type u_4} {Œ≥ : Type u_5} {Œ¥ : Type u_7} [decidable_eq Œ≤'] [decidable_eq Œ≥] [decidable_eq Œ¥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s : finset Œ±} {t : finset Œ≤} {g : Œ≥ ‚Üí Œ¥} {f' : Œ≤' ‚Üí Œ± ‚Üí Œ¥} {g' : Œ≤ ‚Üí Œ≤'} (h_antidistrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' (g' b) a) : finset.image g (finset.image‚ÇÇ f s t) = finset.image‚ÇÇ f' (finset.image g' t) s
(l : interactive.parse interactive.types.location) : tactic unit
{Œ± : Type u_1} {p q : Œ± ‚Üí Prop} (h : p = q) : subtype p ‚âÉ subtype q
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_assoc_semiring Œ±} {rŒ≤ : non_assoc_semiring Œ≤} (f : Œ± ‚Üí+* Œ≤) [nontrivial Œ≤] : ‚áëf 1 ‚â† 0
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) [lie_algebra.is_nilpotent R ‚Ü•H] (œá‚ÇÅ œá‚ÇÇ œá‚ÇÉ : ‚Ü•H ‚Üí R) (hœá : œá‚ÇÅ + œá‚ÇÇ = œá‚ÇÉ) : tensor_product R ‚Ü•(lie_algebra.root_space H œá‚ÇÅ) ‚Ü•(lie_algebra.root_space H œá‚ÇÇ) ‚Üí‚Çó‚ÅÖR,‚Ü•H‚ÅÜ ‚Ü•(lie_algebra.root_space H œá‚ÇÉ)
{Œ± : Type u_2} [decidable_eq Œ±] [has_inv Œ±] : has_inv (finset Œ±)
(func arg : pexpr) (pi_expr : expr) (n : ‚Ñï) : pexpr
{M : Type u_7} {M‚ÇÇ : Type u_9} [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] (e : M ‚âÉ+ M‚ÇÇ) : M ‚âÉ‚Çó[‚Ñï] M‚ÇÇ
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_cokernel f] {X' Y' : C} (f' : X' ‚ü∂ Y') [category_theory.limits.has_cokernel f'] (p : X ‚ü∂ X') (q : Y ‚ü∂ Y') (w : f ‚â´ q = p ‚â´ f') : category_theory.limits.cokernel f ‚ü∂ category_theory.limits.cokernel f'
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] {E : Type u‚ÇÉ} [category_theory.category E] [category_theory.monoidal_category E] (F : category_theory.monoidal_functor C D) (G : category_theory.monoidal_functor C E) : category_theory.monoidal_functor C (D √ó E)
{Œ± : Type u_1} [division_comm_monoid Œ±] (n : ‚Ñ§) : Œ± ‚Üí* Œ±
(b : bool) : num ‚Üí num
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} : L.bounded_formula Œ± n ‚Üí L.bounded_formula Œ± n
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] : category_theory.monoidal_category (category_theory.skeleton C)
(R : Type u_1) [has_zero R] : Type u_1
{R : Type u_1} {G : Type u_2} [add_comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (add_monoid_algebra R G) ‚Üî add_group.fg G
{Œ≤ : Sort u_1} (b : Œ≤) : punit ‚Ü™ Œ≤
{Œ± : Type u_1} [decidable_eq Œ±] (s : finset Œ±) (F : finset (finset Œ±)) : finpartition s
{E : Type u_2} {ùïú : Type u_3} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] {s : set E} (hs : convex ùïú s) {x y : E} (hx : x ‚àà s) (hy : x + y ‚àà interior s) {t : ùïú} (ht : t ‚àà set.Ioc 0 1) : x + t ‚Ä¢ y ‚àà interior s
(x : ‚ÑÇ) : has_deriv_at complex.sinh (complex.cosh x) x
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) (k : N ‚âÉ+ P) : S.localization_map P
 : expr ‚Üí tactic (list (expr √ó bool) √ó expr)
{Œπ Œ± : Type v} (U : Œπ ‚Üí Œ±) [semilattice_inf Œ±] : category_theory.pairwise Œπ ‚Üí Œ±
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] (h : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚Üí M‚ÇÇ
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} (h : ‚Üës.nonempty) : affine_subspace.direction_of_nonempty h = s.direction
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [decidable_eq Œπ] [Œ† (i : Œπ), has_zero (Œ± i)] {s : finset Œπ} {f : Œ†‚ÇÄ (i : Œπ), Œ± i} [Œ† (i : Œπ), decidable_eq (Œ± i)] {t : Œ†‚ÇÄ (i : Œπ), finset (Œ± i)} (ht : t.support ‚äÜ s) : f ‚àà s.dfinsupp ‚áët ‚Üî ‚àÄ (i : Œπ), ‚áëf i ‚àà ‚áët i
 : set surreal
(p : ‚Ñï) [hp : fact (nat.prime p)] (q r : ‚Ñö) : padic_norm p (q * r) = padic_norm p q * padic_norm p r
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.cartesian_closed C] : category_theory.exponential_ideal (category_theory.subterminal_inclusion C)
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A B : matrix n n Œ±) (h : B.mul A = 1) : invertible A
(n : ‚Ñï) : Type (u+1)
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : Top} (H : X ‚âÖ Y) : Top.presheaf.pullback C H.hom ‚âÖ Top.presheaf.pushforward C H.inv
(G : Type u_2) : Type u_2
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_binary_coproducts D] (A : C) [‚àÄ (B : C), category_theory.is_iso (category_theory.limits.coprod_comparison F A B)] : F ‚ãô category_theory.limits.coprod.functor.obj (F.obj A) ‚âÖ category_theory.limits.coprod.functor.obj A ‚ãô F
{Œ± : Type u_1} [fintype Œ±] : nonempty (field Œ±) ‚Üî is_prime_pow (fintype.card Œ±)
{n : ‚Ñï} [fact (0 < n)] : fintype (dihedral_group n)
{G : Type u_6} [add_group G] {H : Type u_1} [add_group H] (f : G ‚Üí H) (hf : ‚àÄ (x y : G), f (x - y) = f x - f y) : G ‚Üí+ H
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space E] {v : E} (hv : v ‚àà K) : ‚áë(reflection K·óÆ) v = -v
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {L‚ÇÇ : Type w} [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÇ] (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) (K‚ÇÇ : lie_subalgebra R L‚ÇÇ) : lie_subalgebra R L
(m : Type u ‚Üí Type v) : Type (u+1)
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [add_comm_monoid Œπ] [decidable_eq Œπ] [comm_ring R] [comm_ring A] [algebra R A] {ùíú : Œπ ‚Üí submodule R A} [graded_algebra ùíú] {x : ideal A} [x.is_prime] (f : homogeneous_localization ùíú x) : A
 : conv unit
{Œ≥ : Type w} [preorder Œ≥] [order_top Œ≥] (s : set Œ≥) : bdd_above s
{M : Type u_1} [mul_one_class M] : complete_lattice (submonoid M)
{Œπ : Type u_1} {Œ± : Type u_2} (s : Œπ ‚Üí set Œ±) : Type (max u_1 u_2)
{R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] {R' : Type u_3} [semiring R'] [mul_semiring_action R' A] [smul_comm_class R' R A] : mul_action R' (subalgebra R A)
 : omega.eqelim (list omega.term)
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {G : D ‚•§ C} [category_theory.is_right_adjoint G] (A : (category_theory.adjunction.of_right_adjoint G).to_monad.algebra) (B : D) [category_theory.limits.has_coequalizer ((category_theory.left_adjoint G).map A.a) ((category_theory.adjunction.of_right_adjoint G).counit.app ((category_theory.left_adjoint G).obj A.A))] : (category_theory.monad.monadicity_internal.comparison_left_adjoint_obj A ‚ü∂ B) ‚âÉ (A ‚ü∂ (category_theory.monad.comparison (category_theory.adjunction.of_right_adjoint G)).obj B)
{C : Type u_1} (A : category_theory.ulift_hom C) : C
(x : ‚Ñù) : ‚Ñù
{Œ± : Type u} [pseudo_emetric_space Œ±] {s t : set Œ±} : emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s
(o : ordinal) : cardinal
{Œ± : Type u} {Œ≤ : Type v} (r : rel Œ± Œ≤) (f : filter Œ≤) : filter Œ±
 : tactic tactic.packaged_goal
{R : Type u} [comm_ring R] (f : polynomial R) : adjoin_root f
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J ‚Üí C} (B : category_theory.limits.bicone F) : category_theory.limits.cocone (category_theory.discrete.functor F)
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] : category_theory.monoidal_functor C C
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {P Q : C} (f : P ‚ü∂ Q) : category_theory.abelian.coimage f ‚ü∂ Q
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] (v w : E) (H : w ‚àà K) : has_inner.inner (v - ‚Üë(‚áë(orthogonal_projection K) v)) w = 0
{R : Type u} [comm_semiring R] [star_ring R] : ring_aut R
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : rel Œ± Œ≤) (s : set Œ≤) : set Œ±
 : Type (u_1+1)
{R : Type u_1} [comm_semiring R] {R' : Type u_2} [monoid R'] {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] [distrib_mul_action R' M] [smul_comm_class R R' M] : has_scalar R' (tensor_product R M N)
{R : Type u} {A : Type v} [comm_semiring R] [star_ring R] [semiring A] [star_ring A] [algebra R A] [star_module R A] (self : star_subalgebra R A) : subalgebra R A
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] (x : Œ±) : (Œ± ‚Üío Œ≤) ‚Üío Œ≤
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {E' : Type u_4} [inner_product_space ùïú E'] : (E ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] E' ‚ÜíL‚ãÜ[ùïú] E ‚ÜíL[ùïú] ùïú
{Œ± : Type} (m : tactic.norm_fin.eval_fin_m Œ±) : tactic Œ±
(hs : name_set) : expr ‚Üí option tactic.suggest.head_symbol_match
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [‚àÄ (i : ùí∞.J), category_theory.limits.has_pullback (ùí∞.map i ‚â´ f) g] : algebraic_geometry.Scheme.glue_data
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {f‚ÇÄ f‚ÇÅ : C(X, Y)} (F : f‚ÇÄ.homotopy f‚ÇÅ) : C(‚Ü•unit_interval, C(X, Y))
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} [topological_space Œ±] [topological_space Œ≤] {i : Œ± ‚Üí Œ≤} [topological_space Œ¥] {f : Œ≥ ‚Üí Œ±} {g : Œ≥ ‚Üí Œ¥} {h : Œ¥ ‚Üí Œ≤} {d : Œ¥} {a : Œ±} (di : dense_inducing i) (H : filter.tendsto h (nhds d) (nhds (i a))) (comm : h ‚àò g = i ‚àò f) : filter.tendsto f (filter.comap g (nhds d)) (nhds a)
(M : Type u_1) {Œ± : Type u_2} [group M] [mul_action M Œ±] (s : set Œ±) : subgroup M
{Œ± : Type u} [has_subset Œ±] [has_ssubset Œ±] [is_nonstrict_strict_order Œ± has_subset.subset has_ssubset.ssubset] {a b : Œ±} [is_antisymm Œ± has_subset.subset] (h‚ÇÅ : a ‚äÜ b) (h‚ÇÇ : a ‚â† b) : a ‚äÇ b
(Œπ : Type u_1) (R : Type u_2) (M : Type u_3) [unique Œπ] [semiring R] [add_comm_monoid M] [module R M] [topological_space M] : (Œπ ‚Üí M) ‚âÉL[R] M
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (e : C ‚âå D) (F : C ‚•§ E) : e.functor ‚ãô e.inverse ‚ãô F ‚âÖ F
{Œ± : Type u_1} (E : Œ± ‚Üí Type u_2) (p : ennreal) [Œ† (i : Œ±), normed_group (E i)] (ùïú : Type u_3) [normed_field ùïú] [Œ† (i : Œ±), normed_space ùïú (E i)] : submodule ùïú (pre_lp E)
(a c b d : ‚Ñï) : Prop
{Œπ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Œπ ‚Üí set X} {s : set X} {c : set (shrinking_lemma.partial_refinement u s)} (hc : is_chain has_le.le c) (ne : c.nonempty) (hfin : ‚àÄ (x : X), x ‚àà s ‚Üí {i : Œπ | x ‚àà u i}.finite) (hU : s ‚äÜ ‚ãÉ (i : Œπ), u i) {v : shrinking_lemma.partial_refinement u s} (hv : v ‚àà c) : v ‚â§ shrinking_lemma.partial_refinement.chain_Sup c hc ne hfin hU
{n : Type u_3} [fintype n] {A : Type u_1} [decidable_eq n] [comm_ring A] [is_domain A] {M : matrix n n A} : M.det ‚â† 0 ‚Üí M.nondegenerate
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} {Œ¥ : Type w} (f : Œ¥ ‚Üí Œ† (a : Œ±), Œ≤ a ‚Üí Œ¥) (d : Œ¥) (m : alist Œ≤) : Œ¥
(Œ± : Type u_1) : Type u_1
{a : ‚Ñù} {l : filter ‚Ñù} {f g : ‚Ñù ‚Üí ‚Ñù} (hdf : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.Iio a), differentiable_at ‚Ñù f x) (hg' : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.Iio a), deriv g x ‚â† 0) (hfa : filter.tendsto f (nhds_within a (set.Iio a)) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.Iio a)) (nhds 0)) (hdiv : filter.tendsto (Œª (x : ‚Ñù), deriv f x / deriv g x) (nhds_within a (set.Iio a)) l) : filter.tendsto (Œª (x : ‚Ñù), f x / g x) (nhds_within a (set.Iio a)) l
{R : Type u_1} [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (T : Type u_4) [comm_ring T] [algebra R T] (M N : submonoid R) (h : M ‚â§ N) [is_localization M S] [is_localization N T] : algebra S T
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} : category_theory.limits.cones.postcompose (ùüô F) ‚âÖ ùü≠ (category_theory.limits.cone F)
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {x y : X} {Œ≥ : Y ‚Üí path x y} {f : Y ‚Üí ‚Ñù} (hŒ≥ : continuous ‚ÜøŒ≥) (hf : continuous f) : continuous (Œª (t : Y), (Œ≥ t).extend (f t))
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b : Œ±} (ha : 1 ‚â§ a) (hb : 1 ‚â§ b) : 1 ‚â§ a * b
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) {J : Type u} [category_theory.category J] {K : J ‚•§ C} : (category_theory.cocones J D).obj (opposite.op (K ‚ãô F)) ‚âÖ G ‚ãô (category_theory.cocones J C).obj (opposite.op K)
(M : Type u_5) (N : Type u_6) [mul_one_class M] [mul_one_class N] : M ‚Üí* M √ó N
{Œ± : Type u_1} [decidable_eq Œ±] {t : finset Œ±} {x : Œ±} (h : x ‚àâ t) : {i // i ‚àà has_insert.insert x t} ‚âÉ option {i // i ‚àà t}
{ùïú : Type u_1} [is_R_or_C ùïú] [dec_ùïú : decidable_eq ùïú] {E : Type u_2} [inner_product_space ùïú E] {T : E ‚Üí‚Çó[ùïú] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional ùïú E] {n : ‚Ñï} (hn : finite_dimensional.finrank ùïú E = n) (v : E) (i : fin n) : ‚áë(hT.diagonalization_basis hn) (‚áëT v) i = ‚Üë(hT.eigenvalues hn i) * ‚áë(hT.diagonalization_basis hn) v i
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s t : set Œ±} (ht : is_antichain r t) (h : maximals r s ‚äÜ t) (hs : ‚àÄ ‚¶Éa : Œ±‚¶Ñ, a ‚àà t ‚Üí (‚àÉ (b : Œ±) (H : b ‚àà maximals r s), r b a)) : maximals r s = t
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : Top} (f : X ‚ü∂ Y) (F : Top.presheaf C Y) (x : ‚Ü•X) : (Top.presheaf.pullback_obj f F).stalk x ‚ü∂ F.stalk (‚áëf x)
(Œ± : Type u_1) [subsingleton Œ±] : fintype Œ±
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} (hs : is_closed s) (ht : is_closed t) (fin : emetric.Hausdorff_edist s t ‚â† ‚ä§) : metric.Hausdorff_dist s t = 0 ‚Üî s = t
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (q : Œ† (i : fin (n + 1)), Œ± i) (z : Œ± (fin.last n)) : fin.init (function.update q (fin.last n) z) = fin.init q
{Œ≤ : Type v} {Œ≥ : Type w} {Œ¥ : Type u_2} [topological_space Œ≤] [topological_space Œ≥] [topological_space Œ¥] [add_monoid Œ¥] [has_continuous_add Œ¥] (g : cocompact_map Œ≤ Œ≥) : zero_at_infty_continuous_map Œ≥ Œ¥ ‚Üí+ zero_at_infty_continuous_map Œ≤ Œ¥
{Œ± : Type u} [decidable_eq Œ±] (a : Œ±) (as : list Œ±) : list (list Œ±)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [measurable_space Œ±] (f : measure_theory.simple_func Œ± (Œ≤ ‚Üí Œ≥)) (g : measure_theory.simple_func Œ± Œ≤) : measure_theory.simple_func Œ± Œ≥
(hs is : list expr) : tactic (list bool)
{Œ± : Type u} [t : topological_space Œ±] {b : set (set Œ±)} (hb : topological_space.is_topological_basis b) {s : set Œ±} : dense s ‚Üî ‚àÄ (o : set Œ±), o ‚àà b ‚Üí o.nonempty ‚Üí (o ‚à© s).nonempty
{G : Type u_1} [group G] {H K : subgroup G} (h : ‚àÄ (x : G), x ‚àà H ‚Üî x ‚àà K) : H = K
(G : out_param (Type u_1)) (P : Type u_2) [out_param (add_group G)] : Type (max u_1 u_2)
(s : ‚ÑÇ) (x : ‚Ñù) : ‚ÑÇ
 : pgame
(olde newe : pexpr) (hyp : name) : tactic unit
(md : tactic.transparency) (equ lhs rhs : expr) : tactic expr
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] {E1 E2 : intermediate_field K L} (h12 : E1 ‚â§ E2) : E2.fixing_subgroup ‚â§ E1.fixing_subgroup
{Œ± : Type u} [preorder Œ±] {a b : Œ±} (h : a < b) : a ‚â† b
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] {a b : Œ±} (ha : a ‚â§ 1) (hb : b < 1) : a * b < 1
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (f : filter Œ±) : Prop
{M : Type u_1} [mul_one_class M] (c : con M) : mul_one_class c.quotient
{Œ± : Type u} (l : ordnode Œ±) : ordnode Œ± ‚Üí ordnode Œ±
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ‚Ñù P) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : p -·µ• ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p) ‚àà (s.direction)·óÆ
{R : Type u_1} {A : Type u_2} [comm_ring R] [ring A] [algebra R A] {c‚ÇÅ c‚ÇÇ : R} (q : quaternion_algebra.basis A c‚ÇÅ c‚ÇÇ) : quaternion_algebra R c‚ÇÅ c‚ÇÇ ‚Üí‚Çê[R] A
{R : Type u_1} [ring R] (u : RÀ£) : power_series R
(M : Type u_9) (N : Type u_10) [has_add M] [has_add N] : Type (max u_10 u_9)
(C : Type u‚ÇÅ) [category_theory.category C] : Prop
(M : Type u_1) [has_add M] : Type u_1
 : Type (u+1)
 : Type (u_1+1)
(a b : expr) : tactic bool
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x y z : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (hz : z ‚â† 0) : hb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = ‚Üëreal.pi
(R : Type u_1) (S : Type u_2) [ring R] [ring S] [is_domain (R √ó S)] [nontrivial R] [nontrivial S] : false
{X Y Z : Type u} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : Type u
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {c : category_theory.limits.cofork f g} (i : category_theory.limits.is_colimit c) : category_theory.epi c.œÄ
{Œπ : Type u_1} {Œπ' : Type u_2} {R : Type u_5} {M : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] (b : basis Œπ R M) (b' : basis Œπ' R M) [fintype Œπ'] [fintype Œπ] [decidable_eq Œπ] : ‚áë(linear_map.to_matrix b b') linear_map.id = b'.to_matrix ‚áëb
(c : tactic.eliminate.constructor_info) : ‚Ñï
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [no_max_order Œ±] [densely_ordered Œ±] {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (set.Ici a) ‚Üî ‚àÉ (u : Œ±) (H : u ‚àà set.Ioi a), set.Icc a u ‚äÜ s
{G : Type u_1} {M : Type u_3} [group G] [monoid M] [mul_action G M] [smul_comm_class G M M] [is_scalar_tower G M M] (g : G) (m : MÀ£) : (g ‚Ä¢ m)‚Åª¬π = g‚Åª¬π ‚Ä¢ m‚Åª¬π
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D·µí·µñ) : C·µí·µñ ‚•§ D
(R : Type u) (X : Type v) [comm_ring R] : basis (free_monoid X) R (free_algebra R X)
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [comm_ring R] [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] (v : valuation R Œì‚ÇÄ) [nontrivial Œì‚ÇÄ] [no_zero_divisors Œì‚ÇÄ] : v.supp.is_prime
(Œ± : Type u) [topological_space Œ±] : Prop
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÅ) [category_theory.category D] : category_theory.sum.swap C D ‚ãô category_theory.sum.swap D C ‚âÖ ùü≠ (C ‚äï D)
(Œ± : Type u_1) (Œ≤ : Type u_2) : Type (max u_1 u_2)
{R : Type u} [ring R] {J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Module R) : category_theory.limits.cocone F
{C : Type u‚ÇÅ} [category_theory.category C] : ulift C ‚•§ C
{Œ± : Type u_1} [uniform_space Œ±] {Œ≤ : Type u_2} [uniform_space Œ≤] (f : Œ± ‚Üí Œ≤) : uniform_space.completion Œ± ‚Üí Œ≤
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] {S : Type u_3} [set_like S N] [add_submonoid_class S N] (f : M ‚Üí+ N) (s : S) (h : ‚àÄ (x : M), ‚áëf x ‚àà s) : M ‚Üí+ ‚Ü•s
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : ‚Ü•S ‚Üí‚Çê[K] L
{G : Type u_1} [ordered_add_comm_group G] (H : add_subgroup G) : ordered_add_comm_group ‚Ü•H
{C : Type u} [category_theory.category C] (hro : category_theory.grothendieck_topology.right_ore_condition C) : category_theory.grothendieck_topology C
 : Type
 : Type
(d : ‚Ñ§) : Type
 : format
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) : E.map (alg_hom.id K L) = E
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤] : uniform_space C(Œ±, Œ≤)
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {f : M ‚Üí+ P} : (add_con.ker_lift f).mrange = f.mrange
{Œπ : Type u} (f : Œπ ‚Üí cardinal) : bdd_above (set.range f)
{M : Type u_1} [semigroup M] (c : con M) : semigroup c.quotient
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} (u : Œπ ‚Üí Œ± ‚Üí Œ≤) (œÑ : Œ± ‚Üí Œπ) : Œ± ‚Üí Œ≤
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : bilin_form R M ‚Üí‚Çó[‚Ñï] M ‚Üí‚Çó[‚Ñï] M ‚Üí‚Çó[R] R
{Œ± : Type u_1} {m : Type u_4} {n : Type u_5} [has_mul Œ±] (A B : matrix m n Œ±) : matrix m n Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x : V) : o.oangle x x = 0
{Œ± : Type u_1} (f : Œ± ‚Üí Œ±) : set Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [semi_normed_group E] [normed_space ùïú E] : weak_dual ùïú E ‚âÉ‚Çó[ùïú] normed_space.dual ùïú E
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.limits.preserves_finite_colimits F] : category_theory.limits.preserves_finite_limits F.op
{K : Type u} {V : Type v} {V' : Type v'} [division_ring K] [add_comm_group V] [module K V] [add_comm_group V'] [module K V'] : nonempty (V ‚âÉ‚Çó[K] V') ‚Üî (module.rank K V).lift = (module.rank K V').lift
{Œ± : Type u} : ordnode Œ± ‚Üí option Œ±
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (X‚ÇÄ X‚ÇÅ : V) (d : X‚ÇÅ ‚ü∂ X‚ÇÄ) (succ' : Œ† (t : Œ£ (X‚ÇÄ X‚ÇÅ : V), X‚ÇÅ ‚ü∂ X‚ÇÄ), Œ£' (X‚ÇÇ : V) (d : X‚ÇÇ ‚ü∂ t.snd.fst), d ‚â´ t.snd.snd = 0) : chain_complex V ‚Ñï
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (C : chain_complex V ‚Ñï) : (chain_complex.truncate.obj C).augment (C.d 1 0) _ ‚âÖ C
(R : Type u_1) [comm_ring R] : Type u_1
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [semiring R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] [topological_space (bundle.total_space E)] (e : topological_vector_bundle.trivialization R F E) (b : B) (hb : b ‚àà e.to_fiber_bundle_trivialization.base_set) : E b ‚âÉ‚Çó[R] F
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [no_max_order Œ±] [no_min_order Œ±] {a : Œ±} {s : set Œ±} : s ‚àà nhds a ‚Üî ‚àÉ (l u : Œ±), a ‚àà set.Ioo l u ‚àß set.Ioo l u ‚äÜ s
{Œ± : Type u} {Œ≤ : Sort u_1} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≤) : ordnode Œ± ‚Üí Œ≤ ‚Üí Œ≤
{Œ± : Type v} {d u n : ‚Ñï} (A : matrix (fin (u + d)) (fin n) Œ±) : matrix (fin d) (fin n) Œ±
{Œπ : Type u_1} {M·µ¢ : Œπ ‚Üí Type u_7} [Œ† (i : Œπ), add_comm_group (M·µ¢ i)] [fintype Œπ] {R : Type u_2} [ordered_ring R] [Œ† (i : Œπ), module R (M·µ¢ i)] {Q : Œ† (i : Œπ), quadratic_form R (M·µ¢ i)} (h : (quadratic_form.pi Q).anisotropic) (i : Œπ) : (Q i).anisotropic
(R : Type u_3) [comm_semiring R] (M : Type u_7) [add_comm_monoid M] [module R M] : R ‚Üí‚Çó[R] M ‚Üí‚Çó[R] M
{C : Type u‚ÇÅ} [category_theory.category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (S : category_theory.sieve X) : category_theory.equalizer.first_obj P ‚áëS ‚ü∂ category_theory.equalizer.sieve.second_obj P S
{M : Type u_1} {N : Type u_2} [unique M] [unique N] [has_add M] [has_add N] : unique (M ‚âÉ+ N)
 : CommMon_ (Type u) ‚âå CommMon
{S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y) : a + x = y + a
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_zero_object C] [category_theory.limits.has_cokernel f] [category_theory.epi f] : category_theory.limits.cokernel.œÄ f = 0
{L : first_order.language} {L' : first_order.language} {Œ± : Type u'} (g : L ‚Üí·¥∏ L') {k : ‚Ñï} : L.bounded_formula Œ± k ‚Üí L'.bounded_formula Œ± k
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x y z : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (hz : z ‚â† 0) : hb.oangle x z - hb.oangle x y = hb.oangle y z
{Œπ : Type u} (Œ≥ : Type w) (Œ≤ : Œπ ‚Üí Type v) [semiring Œ≥] [Œ† (i : Œπ), add_comm_monoid (Œ≤ i)] [Œ† (i : Œπ), module Œ≥ (Œ≤ i)] (p : Œπ ‚Üí Prop) [decidable_pred p] : (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚Üí‚Çó[Œ≥] Œ†‚ÇÄ (i : subtype p), Œ≤ ‚Üëi
(C : Type u) [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} {s : Y ‚ü∂ X} (hs : f ‚â´ s ‚â´ f = f) (h : category_theory.limits.is_colimit (category_theory.limits.cofork.of_œÄ f _)) : category_theory.split_epi f
{a : ‚Ñï} : real.sqrt ‚Üëa ‚â§ ‚Üë(nat.sqrt a) + 1
{G : Type u_2} [div_inv_monoid G] {C : conj_act G ‚Üí Sort u_1} (h : Œ† (g : G), C (‚áëconj_act.to_conj_act g)) (g : conj_act G) : C g
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : matrix.special_linear_group n R ‚Üí* (n ‚Üí R) ‚âÉ‚Çó[R] n ‚Üí R
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : (C ‚•§ D)·µí·µñ ‚•§ C·µí·µñ ‚•§ D·µí·µñ
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h : s1 < s2) (hn : ‚Üës1.nonempty) : s1.direction < s2.direction
{d : ‚Ñ§} : ‚Ñ§‚àöd ‚Üí+ ‚Ñ§‚àöd
{n : ‚Ñï} {E : Type u_1} [normed_group E] {f : (fin n ‚Üí ‚ÑÇ) ‚Üí E} {c : fin n ‚Üí ‚ÑÇ} {R : fin n ‚Üí ‚Ñù} [normed_space ‚ÑÇ E] (hf : torus_integrable f c R) : measure_theory.integrable_on (Œª (Œ∏ : fin n ‚Üí ‚Ñù), finset.univ.prod (Œª (i : fin n), ‚Üë(R i) * complex.exp (‚Üë(Œ∏ i) * complex.I) * complex.I) ‚Ä¢ f (torus_map c R Œ∏)) (set.Icc 0 (Œª (_x : fin n), 2 * real.pi)) measure_theory.measure_space.volume
{R : Type u} {Œì‚ÇÄ : Type v} [comm_ring R] [linear_ordered_comm_group_with_zero Œì‚ÇÄ] (v : valuation R Œì‚ÇÄ) (O : Type w) [comm_ring O] [algebra O R] : Prop
{K : Type u_4} {V : Type u} [field K] [add_comm_group V] [module K V] (p : submodule K V) (hp : p < ‚ä§) : ‚àÉ (f : V ‚Üí‚Çó[K] K) (H : f ‚â† 0), p ‚â§ f.ker
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {s : set E} {f : E ‚Üí F} {n : with_top ‚Ñï} {x : G} (g : G ‚ÜíL[ùïú] E) (hf : cont_diff_within_at ùïú n f s (‚áëg x)) : cont_diff_within_at ùïú n (f ‚àò ‚áëg) (‚áëg ‚Åª¬π' s) x
{R : Type u_1} [semiring R] (P : polynomial R ‚Üí Prop) (N : ‚Ñï) (P_0 : P 0) (P_C_mul_pow : ‚àÄ (n : ‚Ñï) (r : R), r ‚â† 0 ‚Üí n ‚â§ N ‚Üí P (‚áëpolynomial.C r * polynomial.X ^ n)) (P_C_add : ‚àÄ (f g : polynomial R), f.nat_degree < g.nat_degree ‚Üí g.nat_degree ‚â§ N ‚Üí P f ‚Üí P g ‚Üí P (f + g)) (f : polynomial R) : f.nat_degree ‚â§ N ‚Üí P f
{Œ± : Type u_1} {r s : setoid Œ±} : (r ‚äì s).rel = r.rel ‚äì s.rel
{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop
{E : Type u_1} [inner_product_space ‚Ñù E] (v : E) [complete_space E] (x : E) : ‚Ü•(submodule.span ‚Ñù {v})·óÆ
 : tactic unit
(ids' : interactive.parse (lean.parser.many interactive.types.ident_)) : tactic unit
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.cartesian_closed C] [category_theory.limits.has_initial C] (i : ‚ä•_ C ‚âÖ ‚ä§_ C) (X Y : C) : unique (X ‚ü∂ Y)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [linear_order Œ≤] [succ_order Œ≤] [is_succ_archimedean Œ≤] [nonempty Œ≤] {s : Œ≤ ‚Üí set Œ±} (H : ‚àÄ (n : Œ≤), is_connected (s n)) (K : ‚àÄ (n : Œ≤), (s n ‚à© s (order.succ n)).nonempty) : is_connected (‚ãÉ (n : Œ≤), s n)
{M : Type uM} {N : Type uN} {P : Type uP} [add_zero_class M] [add_zero_class N] [add_comm_monoid P] (f : M ‚Üí+ N) : (N ‚Üí+ P) ‚Üí+ M ‚Üí+ P
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] [complete_space F] {f : E ‚Üí F} {p : formal_multilinear_series ùïú E F} {x y : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) (h : ‚Üë‚à•y‚à•‚Çä < r) : has_fpower_series_on_ball f (p.change_origin y) (x + y) (r - ‚Üë‚à•y‚à•‚Çä)
{Œ± : Type u} {u : ultrafilter (ultrafilter Œ±)} {x : ultrafilter Œ±} : ‚Üëu ‚â§ nhds x ‚Üî x = mjoin u
(c : nat.partrec.code) (n : ‚Ñï) : nat.partrec.code
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : Y ‚ü∂ X) (R : category_theory.sieve Y) : category_theory.sieve X
{Œì : Type u_4} [group Œì] {T : Type u_5} [topological_space T] [mul_action Œì T] [has_continuous_const_smul Œì T] : is_open_map quotient.mk
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (q : Œ† (i : fin (n + 1)), Œ± i) (i : fin n) (y : Œ± (‚áëfin.cast_succ i)) : fin.init (function.update q (‚áëfin.cast_succ i) y) = function.update (fin.init q) i y
{Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} (f : Œ† (x : Œ±), Œ≤ x) : function.extfun Œ± Œ≤
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y) (hx : x ‚â† 0) (hy : y ‚â† 0) : ‚àÉ (r‚ÇÅ r‚ÇÇ : R), 0 < r‚ÇÅ ‚àß 0 < r‚ÇÇ ‚àß r‚ÇÅ ‚Ä¢ x = r‚ÇÇ ‚Ä¢ y
{C : Type u_1} [category_theory.category C] (r : hom_rel C) {D : Type u_3} [category_theory.category D] (F : C ‚•§ D) (H : ‚àÄ (x y : C) (f‚ÇÅ f‚ÇÇ : x ‚ü∂ y), r f‚ÇÅ f‚ÇÇ ‚Üí F.map f‚ÇÅ = F.map f‚ÇÇ) : category_theory.quotient r ‚•§ D
{R : Type u} [ring R] (B : ring_filter_basis R) : topological_space R
{Œ± : Type u_1} [topological_space Œ±] [t2_space Œ±] [measurable_space Œ±] [borel_space Œ±] {s t : set Œ±} (hs : measure_theory.analytic_set s) (ht : measure_theory.analytic_set t) (h : disjoint s t) : measure_theory.measurably_separable s t
{p : ‚Ñï} {R : Type u_1} {S : Type u_2} [hp : fact (nat.prime p)] [comm_ring R] [comm_ring S] (f : R ‚Üí+* S) (x : witt_vector p R) : ‚áë(witt_vector.map f) (‚áëwitt_vector.verschiebung x) = ‚áëwitt_vector.verschiebung (‚áë(witt_vector.map f) x)
{Œ± : Type u_1} [encodable Œ±] {n : ‚Ñï} : encodable (fin n ‚Üí Œ±)
(Œì‚ÇÄ : Type u_1) [linear_ordered_comm_group_with_zero Œì‚ÇÄ] (x : Œì‚ÇÄ) : filter Œì‚ÇÄ
{x y z : ‚Ñ§} (k : ‚Ñ§) (hk : k ‚â† 0) : pythagorean_triple (k * x) (k * y) (k * z) ‚Üî pythagorean_triple x y z
(R : Type u) [comm_ring R] : CommRing
(tac1 tac2 : tactic unit) : tactic unit
{Œ± : Type u_1} (a : Œ±) : ‚Ü•{a} ‚âÉ punit
(X : Type u_1) [topological_space X] : Type u_1
{Œ± : Type u_2} {Œπ : Type u_5} [comm_monoid Œ±] (t : finset Œπ) (f : Œπ ‚Üí set Œ±) (g : Œπ ‚Üí Œ±) (hg : ‚àÄ (i : Œπ), i ‚àà t ‚Üí g i ‚àà f i) : t.prod (Œª (i : Œπ), g i) ‚àà t.prod (Œª (i : Œπ), f i)
(n : ‚Ñï) {A : Type u_2} [add_group A] : {f // ‚áëf ‚Üën = 0} ‚âÉ (zmod n ‚Üí+ A)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [linear_order Œ≤] {f g : Œ± ‚Üí Œ≤} (hf : monotone f) (hg : monotone g) : monotone (Œª (x : Œ±), linear_order.min (f x) (g x))
{Œπ : Type u_1} {M : Type u_4} [topological_space M] [has_add M] [has_continuous_add M] : has_continuous_add (Œπ ‚Üí M)
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : local_equiv Œ± Œ≤) : Œ≤ ‚Üí Œ±
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K‚ÇÅ K‚ÇÇ : submodule ùïú E} [finite_dimensional ùïú ‚Ü•K‚ÇÇ] (h : K‚ÇÅ ‚â§ K‚ÇÇ) {n : ‚Ñï} (h_dim : finite_dimensional.finrank ùïú ‚Ü•K‚ÇÅ + n = finite_dimensional.finrank ùïú ‚Ü•K‚ÇÇ) : finite_dimensional.finrank ùïú ‚Ü•(K‚ÇÅ·óÆ ‚äì K‚ÇÇ) = n
(R : Type u_1) [ring R] [topological_space R] [has_continuous_mul R] : RÀ£ ‚âÉ R ‚âÉL[R] R
{Œ± : Type u_1} [has_le Œ±] (a : Œ±) : Prop
(ùïÇ : Type u_1) (ùî∏ : Type u_2) [field ùïÇ] [ring ùî∏] [algebra ùïÇ ùî∏] [topological_space ùî∏] [topological_ring ùî∏] : formal_multilinear_series ùïÇ ùî∏ ùî∏
{R : Type u} [ring R] {P : Type (max u v)} [add_comm_group P] [module R P] (huniv : ‚àÄ {M : Type (max v u)} {N : Type (max u v)} [_inst_4 : add_comm_group M] [_inst_5 : add_comm_group N] [_inst_6 : module R M] [_inst_7 : module R N] (f : M ‚Üí‚Çó[R] N) (g : P ‚Üí‚Çó[R] N), function.surjective ‚áëf ‚Üí (‚àÉ (h : P ‚Üí‚Çó[R] M), f.comp h = g)) : module.projective R P
{n a : ‚Ñï} (h : a < n + 1) : ‚Üëa.val = a
{X : Type u} {Y : Type v} {Z : Type w} [nonempty Z] [metric_space Z] [metric_space X] [metric_space Y] {Œ¶ : Z ‚Üí X} {Œ® : Z ‚Üí Y} (hŒ¶ : isometry Œ¶) (hŒ® : isometry Œ®) (y : Y) : metric.glue_space hŒ¶ hŒ®
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} {Œπ : Type u_5} [linear_ordered_field ùïú] [add_comm_group E] [ordered_add_comm_group Œ≤] [module ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} {t : finset Œπ} {w : Œπ ‚Üí ùïú} {p : Œπ ‚Üí E} (hf : concave_on ùïú s f) (h‚ÇÄ : ‚àÄ (i : Œπ), i ‚àà t ‚Üí 0 ‚â§ w i) (h‚ÇÅ : t.sum (Œª (i : Œπ), w i) = 1) (hmem : ‚àÄ (i : Œπ), i ‚àà t ‚Üí p i ‚àà s) : t.sum (Œª (i : Œπ), w i ‚Ä¢ f (p i)) ‚â§ f (t.sum (Œª (i : Œπ), w i ‚Ä¢ p i))
{Œ± : Type u_1} [linear_order Œ±] : has_subset.subset ‚Üír has_le.le
 : Pointed ‚•§ PartialFun
{Œ± : Type u} {Œ≥ : Type w} [non_unital_comm_semiring Œ±] [has_zero Œ≥] [has_add Œ≥] [has_mul Œ≥] [has_scalar ‚Ñï Œ≥] (f : Œ≥ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (add : ‚àÄ (x y : Œ≥), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≥), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ≥) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_unital_comm_semiring Œ≥
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [preorder Œ±] [preorder Œ≤] [mul_one_class Œ±] [mul_one_class Œ≤] : Type (max u_6 u_7 u_8)
{Œ± : Type u} [pseudo_emetric_space Œ±] {s t : set Œ±} (hs : s.nonempty) (ht : t.nonempty) : emetric.Hausdorff_edist s t ‚â§ emetric.diam (s ‚à™ t)
(Œ± : Type u) : Type (max 1 u)
{Œ± : Type u} [pseudo_emetric_space Œ±] {x : Œ±} {s t : set Œ±} (h : x ‚àà s) : emetric.inf_edist x t ‚â§ emetric.Hausdorff_edist s t
{Œ± : Type u_1} [topological_space Œ±] {Œ≤ : Type u_2} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) (x : Œ±) : Prop
{Œ± : Sort u} {Œ≤ : Sort v} (f : Œ± ‚Üí Œ≤) (hf : function.bijective f) : Œ± ‚âÉ Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J ‚•§ C·µí·µñ) [category_theory.limits.has_colimit F.left_op] : category_theory.limits.has_limit F
{Œ± : Type u_1} [metric_space Œ±] {Œ≤ : Type u} [nonempty Œ≤] (p : besicovitch.tau_package Œ≤ Œ±) : ordinal
{b m : ‚Ñï} (hb : 2 ‚â§ b) : m < b ^ (b.digits m).length
{G : Type w} [add_group G] [topological_space G] [topological_add_group G] (x : G) : G ‚âÉ‚Çú G
(C : Type u‚ÇÅ) [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (Z : D) : C ‚•§ C √ó D
{M : Type u_1} [monoid M] {s : set M} (hcomm : ‚àÄ (a : M), a ‚àà s ‚Üí ‚àÄ (b : M), b ‚àà s ‚Üí a * b = b * a) : comm_monoid ‚Ü•(submonoid.closure s)
{Œ± : Type u_1} (k : ‚Ñï) : (vector3 Œ± k ‚Üí Prop) ‚Üí Prop
{C : Type u} [category_theory.category C] {P X E : C} [category_theory.projective P] (f : P ‚ü∂ X) (e : E ‚ü∂ X) [category_theory.epi e] : P ‚ü∂ E
{C : Type u‚ÇÅ} [category_theory.category C] {X A : C} (f : A ‚ü∂ X) [hf : category_theory.mono f] : category_theory.mono_over X
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] (P : C·µí·µñ ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) : J.diagram P Y ‚ü∂ (J.pullback f).op ‚ãô J.diagram P X
 : cardinal.ord ‚àò cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b ‚àß ordinal.omega ‚â§ b}
{Œ± : Type u_1} [fintype (option Œ±)] : fintype Œ±
{R : Type u} [ring R] {p : polynomial R} (r : R) : polynomial.eval r (p * (polynomial.X - ‚áëpolynomial.C r)) = 0
{Œ± : Type u} [semilattice_sup Œ±] [order_bot Œ±] {Œπ : Type u} [fintype Œπ] (f : Œπ ‚Üí Œ±) : (‚àê f) = (fintype.elems Œπ).sup f
{M : Type u_1} [has_add M] (s : set M) {p : Œ† (x : M), x ‚àà add_subsemigroup.closure s ‚Üí Prop} (Hs : ‚àÄ (x : M) (h : x ‚àà s), p x _) (Hmul : ‚àÄ (x : M) (hx : x ‚àà add_subsemigroup.closure s) (y : M) (hy : y ‚àà add_subsemigroup.closure s), p x hx ‚Üí p y hy ‚Üí p (x + y) _) {x : M} (hx : x ‚àà add_subsemigroup.closure s) : p x hx
{R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] [finite_dimensional R M] [nonempty Œπ] (x : orientation R M Œπ) (h : fintype.card Œπ = finite_dimensional.finrank R M) : (x.some_basis h).orientation = x
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type v} (f : J ‚Üí C) [category_theory.limits.preserves_limit (category_theory.discrete.functor f) G] {P : C} (g : Œ† (j : J), P ‚ü∂ f j) (t : category_theory.limits.is_limit (category_theory.limits.fan.mk P g)) : category_theory.limits.is_limit (category_theory.limits.fan.mk (G.obj P) (Œª (j : J), G.map (g j)))
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] (X : Top) : Top.sheaf C X ‚•§ Top.presheaf C X
 : pos_num ‚Üí pos_num ‚Üí ordering
{Œ± : Type u_1} [normed_field Œ±] {E : Type u_5} [semi_normed_group E] [normed_space Œ± E] {F : Type u_6} [semi_normed_group F] [normed_space Œ± F] : normed_space Œ± (E √ó F)
{Œ± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] (l : filter Œ±) (f : Œ± ‚Üí E) (g : Œ± ‚Üí F) : Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_5} [normed_group E'] [normed_space ùïú E'] {n : with_top ‚Ñï} {f : E ‚Üí E'} {s : set E} {x : E} : cont_mdiff_within_at (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') n f s x ‚Üí cont_diff_within_at ùïú n f s x
(Œ± : Type u_1) (Œ≤ : Type u_2) [topological_space Œ±] [topological_space Œ≤] [add_monoid Œ≤] [has_continuous_add Œ≤] : add_submonoid (Œ± ‚Üí Œ≤)
{E : ‚Ñï ‚Üí Type u_1} [Œ† (n : ‚Ñï), topological_space (E n)] [‚àÄ (n : ‚Ñï), discrete_topology (E n)] : metric_space (Œ† (n : ‚Ñï), E n)
{Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚âÉ. Œ≤} (h : ‚àÄ (a : Œ±), ‚Ü•((‚áëf a).is_some)) : function.injective ‚áëf
(many : interactive.parse (optional (lean.parser.tk "*"))) (dir : interactive.parse tactic.interactive.side) (hyps : interactive.parse (lean.parser.tk "with" *> interactive.types.pexpr_list_or_texpr <|> has_pure.pure list.nil)) (simp_rules : interactive.parse (lean.parser.tk "using" *> tactic.simp_arg_list <|> has_pure.pure list.nil)) : tactic unit
 : tactic expr
(b : pgame.domineering.board) : (pgame.domineering b).short
(x : ‚Ñù) : real.sinh x = (real.exp x - real.exp (-x)) / 2
{C : Type u} [category_theory.category C] {F : category_theory.limits.walking_cospan ‚•§ C} {s t : category_theory.limits.cone F} (i : s.X ‚âÖ t.X) (w‚ÇÅ : s.œÄ.app category_theory.limits.walking_cospan.left = i.hom ‚â´ t.œÄ.app category_theory.limits.walking_cospan.left) (w‚ÇÇ : s.œÄ.app category_theory.limits.walking_cospan.right = i.hom ‚â´ t.œÄ.app category_theory.limits.walking_cospan.right) : s ‚âÖ t
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (f g : R ‚Üí+* S) : subsemiring R
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : ‚Ñù
{R : Type u_1} [comm_semiring R] (s : subsemiring R) {Œπ : Type u_2} {t : finset Œπ} {f : Œπ ‚Üí R} (h : ‚àÄ (c : Œπ), c ‚àà t ‚Üí f c ‚àà s) : t.prod (Œª (i : Œπ), f i) ‚àà s
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring ùïú] [add_comm_group E] [add_comm_group F] [module ùïú E] [module ùïú F] (f : E ‚Üí·µÉ[ùïú] F) {s : set F} (hs : convex ùïú s) : convex ùïú (‚áëf ‚Åª¬π' s)
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [comm_monoid N] {s : finset Œ±} {f : Œ± ‚Üí M} {g : Œ± ‚Üí M ‚Üí N} (hf : ‚àÄ (a : Œ±), f a ‚â† 0 ‚Üí a ‚àà s) (hg : ‚àÄ (a : Œ±), g a 0 = 1) : (finsupp.on_finset s f hf).prod g = s.prod (Œª (a : Œ±), g a (f a))
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] : category_theory.limits.has_finite_biproducts C
{Œ±' : Sort w} [decidable_eq Œ±'] {Œ± : Sort u_1} {Œ≤ : Sort u_2} (g : Œ±' ‚Üí Œ≤) {f : Œ± ‚Üí Œ±'} {i : Œ±'} (a : Œ≤) (h : ‚àÄ (x : Œ±), f x ‚â† i) : function.update g i a ‚àò f = g ‚àò f
{R : Type u} [semiring R] (p q : polynomial R) : polynomial R
 : sign_type ‚Üí sign_type ‚Üí sign_type
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {p : E √ó F} : cont_diff_at ùïú n prod.fst p
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] (Œ± : ‚Ü•(solvable_by_rad F E)) : Prop
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] (f : multilinear_map R M‚ÇÅ M‚ÇÇ) {Œ± : Œπ ‚Üí Type u_1} (g : Œ† (i : Œπ), Œ± i ‚Üí M‚ÇÅ i) [fintype Œπ] [Œ† (i : Œπ), fintype (Œ± i)] : ‚áëf (Œª (i : Œπ), finset.univ.sum (Œª (j : Œ± i), g i j)) = finset.univ.sum (Œª (r : Œ† (i : Œπ), Œ± i), ‚áëf (Œª (i : Œπ), g i (r i)))
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {s‚ÇÅ : setoid Œ±} {s‚ÇÇ : setoid Œ≤} {p : quotient s‚ÇÅ ‚Üí quotient s‚ÇÇ ‚Üí Prop} (h : ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ≤), p (quotient.mk' a‚ÇÅ) (quotient.mk' a‚ÇÇ)) (q‚ÇÅ : quotient s‚ÇÅ) (q‚ÇÇ : quotient s‚ÇÇ) : p q‚ÇÅ q‚ÇÇ
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí. Œ≤) (s : set Œ±) : set Œ≤
{Œ± : Type u_1} (f : Œ± ‚Üí nnreal) : filter.tendsto (Œª (s : finset Œ±), ‚àë' (b : {x // x ‚àâ s}), f ‚Üëb) filter.at_top (nhds 0)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} {s : set Œ±} : continuous_within_at f s x ‚Üí continuous_within_at f (has_insert.insert x s) x
(a : ‚Ü•circle) : ‚áëlinear_equiv.det (‚áërotation a).to_linear_equiv = 1
{F : Type u ‚Üí Type w} {G : Type v ‚Üí Type u} [functor F] [functor G] {Œ± Œ≤ : Type v} (h : Œ± ‚Üí Œ≤) : functor.comp F G Œ± ‚Üí functor.comp F G Œ≤
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_group E] [has_scalar ùïú E] {S : convex_cone ùïú E} (hS : S.flat) : S.pointed
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : ‚Ü•‚ä§ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L
(Œ± : Type u) : Type u
(attr_decl_name attr_name simp_attr_name ex_attr_name : name) : tactic unit
(G : Type u_1) [measurable_space G] [has_sub G] : Prop
{Œπ : Type u_1} (R : Type u_2) {M : Type u_3} [decidable_eq Œπ] [semiring R] [add_comm_monoid M] [Œ† (m : M), decidable (m ‚â† 0)] [module R M] : (Œπ ‚Üí‚ÇÄ M) ‚âÉ‚Çó[R] Œ†‚ÇÄ (i : Œπ), M
(K : Type u_1) (L : Type u_2) {A : Type u_5} [field K] [field L] [comm_ring A] [algebra K L] [algebra L A] [algebra K A] [is_scalar_tower K L A] (A_alg : algebra.is_algebraic K A) : algebra.is_algebraic L A
{C : Type u} [category_theory.category C] {f g : category_theory.arrow C} [‚àÄ (n : ‚Ñï), category_theory.limits.has_wide_pullback f.right (Œª (i : ulift (fin (n + 1))), f.left) (Œª (i : ulift (fin (n + 1))), f.hom)] [‚àÄ (n : ‚Ñï), category_theory.limits.has_wide_pullback g.right (Œª (i : ulift (fin (n + 1))), g.left) (Œª (i : ulift (fin (n + 1))), g.hom)] (F : f ‚ü∂ g) : f.augmented_cech_nerve ‚ü∂ g.augmented_cech_nerve
{Œ± : Type u_1} [topological_space Œ±] [polish_space Œ±] {s : set Œ±} (hs : is_closed s) : polish_space ‚Ü•s
{G : Type u_10} {H : Type u_11} [add_zero_class G] [mul_one_class H] : G ‚âÉ+ additive H ‚âÉ (multiplicative G ‚âÉ* H)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (Œ± : X ‚âÖ Y) : opposite.op Y ‚âÖ opposite.op X
{Œ± : Type u_1} {m : multiset Œ±} {p : Œ± ‚Üí Prop} [decidable_pred p] : decidable (‚àÉ (x : Œ±) (H : x ‚àà m), p x)
(p : nnreal) (h : p ‚â§ 1) : pmf bool
(R : Type u) (M : Type v) [ring R] [add_comm_group M] [module R M] : Type (max u v)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ‚ü∂ Q) : function.surjective ‚áëf ‚Üí category_theory.epi f
{Œ± : Type u} [right_cancel_monoid Œ±] : has_faithful_smul Œ± Œ±
{K : Type u} (V : Type v) (V' : Type v') [division_ring K] [add_comm_group V] [module K V] [add_comm_group V'] [module K V'] (cond : (module.rank K V).lift = (module.rank K V').lift) : V ‚âÉ‚Çó[K] V'
{X Y : Type u} [semigroup X] [semigroup Y] (e : X ‚âÉ* Y) : Semigroup.of X ‚âÖ Semigroup.of Y
(ùïú : Type u_1) {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_group F] [normed_space ùïú E] [normed_space ùïú F] (f : E ‚Üí F) (s : set E) : Prop
(mvars : list (expr √ó name √ó binder_info)) : tactic (list expr)
{Œ≤ : Type v} {Œ≥ : Type w} {Œ¥ : Type u_2} [topological_space Œ≤] [topological_space Œ≥] [topological_space Œ¥] [add_comm_monoid Œ¥] [has_continuous_add Œ¥] {R : Type u_1} [semiring R] [module R Œ¥] [has_continuous_const_smul R Œ¥] (g : cocompact_map Œ≤ Œ≥) : zero_at_infty_continuous_map Œ≥ Œ¥ ‚Üí‚Çó[R] zero_at_infty_continuous_map Œ≤ Œ¥
{n : ‚Ñï} (a : zmod n) : ‚Üë‚Üëa = a
{E : ‚Ñï ‚Üí Type u_1} {Œ± : Type u_2} [pseudo_metric_space Œ±] {f : (Œ† (n : ‚Ñï), E n) ‚Üí Œ±} : (‚àÄ (x y : Œ† (n : ‚Ñï), E n), has_dist.dist (f x) (f y) ‚â§ has_dist.dist x y) ‚Üî ‚àÄ (x y : Œ† (n : ‚Ñï), E n) (n : ‚Ñï), y ‚àà pi_nat.cylinder x n ‚Üí has_dist.dist (f x) (f y) ‚â§ (1 / 2) ^ n
{Œπ : Type u_1} {E : Type u_3} [semi_normed_group E] {f : Œπ ‚Üí E} {g : Œπ ‚Üí nnreal} {a : nnreal} (hg : has_sum g a) (h : ‚àÄ (i : Œπ), ‚à•f i‚à•‚Çä ‚â§ g i) : ‚à•‚àë' (i : Œπ), f i‚à•‚Çä ‚â§ a
(s : string) : bool
{R : Type u} [non_assoc_semiring R] : has_top (subsemiring R)
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.initial] {E : Type u} [category_theory.category E] (G : D ‚•§ E) : category_theory.limits.cone (F ‚ãô G) ‚âå category_theory.limits.cone G
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [normalization_monoid Œ±] [decidable_eq Œ±] (gcd : Œ± ‚Üí Œ± ‚Üí Œ±) (gcd_dvd_left : ‚àÄ (a b : Œ±), gcd a b ‚à£ a) (gcd_dvd_right : ‚àÄ (a b : Œ±), gcd a b ‚à£ b) (dvd_gcd : ‚àÄ {a b c : Œ±}, a ‚à£ c ‚Üí a ‚à£ b ‚Üí a ‚à£ gcd c b) (normalize_gcd : ‚àÄ (a b : Œ±), ‚áënormalize (gcd a b) = gcd a b) : normalized_gcd_monoid Œ±
{Œ± : Type u_1} [linear_ordered_field Œ±] {a b c d : Œ±} (hc : c ‚â† 0) (hd : d ‚â† 0) : a / c < b / d ‚Üí (a * d - b * c) / (c * d) < 0
{m : Type u_2} {n : Type u_3} {Œ± : Type v} [has_add Œ±] : matrix m n Œ± ‚âÉ+ matrix n m Œ±
{X : Top} (x : ‚Ü•X) : Type u
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ : C} [category_theory.limits.has_binary_coproduct X‚ÇÅ X‚ÇÇ] [category_theory.limits.coproduct_disjoint X‚ÇÅ X‚ÇÇ] [category_theory.limits.has_pullback category_theory.limits.coprod.inl category_theory.limits.coprod.inr] : category_theory.limits.is_initial (category_theory.limits.pullback category_theory.limits.coprod.inl category_theory.limits.coprod.inr)
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Group) : category_theory.limits.is_colimit (Group.filtered_colimits.colimit_cocone F)
{R : Type u_1} [rack R] : rack R·µê·µí·µñ
(G : Type u_3) [group G] [h : group.fg G] [decidable_pred (Œª (n : ‚Ñï), ‚àÉ (S : finset G), S.card = n ‚àß subgroup.closure ‚ÜëS = ‚ä§)] : ‚Ñï
{E : Type u_2} [add_comm_group E] [module ‚Ñù E] (f : linear_pmap ‚Ñù E ‚Ñù) (N : E ‚Üí ‚Ñù) (N_hom : ‚àÄ (c : ‚Ñù), 0 < c ‚Üí ‚àÄ (x : E), N (c ‚Ä¢ x) = c * N x) (N_add : ‚àÄ (x y : E), N (x + y) ‚â§ N x + N y) (hf : ‚àÄ (x : ‚Ü•(f.domain)), ‚áëf x ‚â§ N ‚Üëx) : ‚àÉ (g : E ‚Üí‚Çó[‚Ñù] ‚Ñù), (‚àÄ (x : ‚Ü•(f.domain)), ‚áëg ‚Üëx = ‚áëf x) ‚àß ‚àÄ (x : E), ‚áëg x ‚â§ N x
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] [finite_dimensional F E] : galois_insertion (‚áëorder_dual.to_dual ‚àò intermediate_field.fixing_subgroup) (intermediate_field.fixed_field ‚àò ‚áëorder_dual.to_dual)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {p : formal_multilinear_series ùïú E F} {x : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) : tendsto_locally_uniformly_on (Œª (n : ‚Ñï) (y : E), p.partial_sum n (y - x)) f filter.at_top (emetric.ball x r)
 : has_sub ordinal
(M : Type u_1) [monoid M] [measurable_space M] [has_measurable_mul‚ÇÇ M] : has_measurable_pow M ‚Ñï
{M : Type u_1} [comm_monoid M] {S : submonoid M} {R : Type u_4} [has_scalar R M] [is_scalar_tower R M M] (c : R) (z : localization S) : localization S
{G H : AddCommGroup} (f : G ‚ü∂ H) : category_theory.limits.mono_factorisation f
(F : Type u_1) (Œ± : out_param (Type u_2)) (Œ≤ : out_param (Type u_3)) [has_le Œ±] [has_le Œ≤] : Type (max u_1 u_2 u_3)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚âÖ Y) : category_theory.monoidal_opposite.mop X ‚âÖ category_theory.monoidal_opposite.mop Y
{T : Type u‚ÇÅ} [category_theory.category T] {X Y Z : T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : category_theory.over.map (f ‚â´ g) ‚âÖ category_theory.over.map f ‚ãô category_theory.over.map g
{R : Type u} [comm_ring R] {M N : Module R} {M' N' : Module R} (f : M ‚ü∂ N) (g : M' ‚ü∂ N') : Module.monoidal_category.tensor_obj M M' ‚ü∂ Module.monoidal_category.tensor_obj N N'
(K : Type u) (V : Type v) [semiring K] [add_comm_monoid V] [module K V] : cardinal
{n : ‚Ñï} : fin n ‚Ü™o fin (n + 1)
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a : ‚Ñù} {s : set ‚Ñù} (hintg : ‚àÄ (x : ‚Ñù), x ‚àà s ‚Üí interval_integrable f measure_theory.measure_space.volume a x) (hcont : continuous f) : differentiable_on ‚Ñù (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in a..u, f x) s
{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a ‚â† 0
(B : Type u_1) (F : Type u_2) : B ‚Üí Type u_2
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : initial_seg r r
 : Type (u+1)
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : ‚áë(v.valuation) (‚áë(algebra_map R K) r) = ‚áë(v.int_valuation) r
 : native.float ‚Üí native.float √ó ‚Ñ§
{R : Type u_1} {S : Type u_2} {T : Type u_3} {M : Type u_4} {M‚ÇÇ : Type u_5} [semiring R] [semiring S] [semiring T] [module R S] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] [module S M‚ÇÇ] [is_scalar_tower R S M‚ÇÇ] [topological_space S] [topological_space M‚ÇÇ] [has_continuous_smul S M‚ÇÇ] [topological_space M] [add_comm_monoid M] [module R M] [has_continuous_add M‚ÇÇ] [module T M‚ÇÇ] [has_continuous_const_smul T M‚ÇÇ] [smul_comm_class R T M‚ÇÇ] [smul_comm_class S T M‚ÇÇ] (c : M ‚ÜíL[R] S) : M‚ÇÇ ‚Üí‚Çó[T] M ‚ÜíL[R] M‚ÇÇ
 : Type
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] (f‚ÇÄ f‚ÇÅ : C(X, Y)) : Prop
{M : Type u_1} [comm_monoid M] {s t : set M} {x : M} : x ‚àà monoid.closure (s ‚à™ t) ‚Üî ‚àÉ (y : M) (H : y ‚àà monoid.closure s) (z : M) (H : z ‚àà monoid.closure t), y * z = x
{J : Type v} {C : Type u} [category_theory.category C] (B : C) (objs : J ‚Üí C) (arrows : Œ† (j : J), B ‚ü∂ objs j) : category_theory.limits.wide_pushout_shape J ‚•§ C
{G : Type u_1} [group G] (H : subgroup G) : has_div ‚Ü•H
 : interactive.parse interactive.types.texpr ‚Üí tactic unit
{Œ± : Type u} [normed_field Œ±] {u : ‚Ñï ‚Üí Œ±} : is_cau_seq has_norm.norm u ‚Üî cauchy_seq u
{m : Type u_1} {R : Type u_3} [fintype m] [decidable_eq m] [comm_semiring R] (A : matrix m m R) : ‚áë((mv_polynomial.eval (Œª (p : m √ó m), A p.fst p.snd)).map_matrix) (matrix.mv_polynomial_X m m R) = A
(R : Type u) [ring R] (hf : is_field R) (x : R) : x ‚â† 0 ‚Üí (‚àÉ! (y : R), x * y = 1)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cone F} (h : category_theory.limits.is_limit t) (s : category_theory.limits.cone F) : ‚àÉ! (l : s.X ‚ü∂ t.X), ‚àÄ (j : J), l ‚â´ t.œÄ.app j = s.œÄ.app j
 : ‚Ñï
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (s : set (submodule ùïú E)) : (‚®Ö (K : submodule ùïú E) (H : K ‚àà s), K·óÆ) = (has_Sup.Sup s)·óÆ
{Œ± : Type u_1} {Œ±' : Type u_2} {Œπ : Type u_3} (f : Œ± ‚Üí Œ±') (l : combinatorics.line Œ± Œπ) : combinatorics.line Œ±' Œπ
{Œ± : Type u_1} [encodable Œ±] : encodable (plift Œ±)
{X : Type u} {Y : Type v} [partial_order X] [partial_order Y] (e : X ‚âå Y) : X ‚âÉo Y
{Œπ : Type u_1} {N : Type u_5} [topological_space N] [monoid N] [has_continuous_mul N] [t2_space N] {f : Œπ ‚Üí NÀ£} {r‚ÇÅ r‚ÇÇ : N} {l : filter Œπ} [l.ne_bot] (h‚ÇÅ : filter.tendsto (Œª (x : Œπ), ‚Üë(f x)) l (nhds r‚ÇÅ)) (h‚ÇÇ : filter.tendsto (Œª (x : Œπ), ‚Üë(f x)‚Åª¬π) l (nhds r‚ÇÇ)) : NÀ£
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] {K : Type u‚ÇÇ} [category_theory.category K] (F : D ‚•§ K ‚•§ C) (H : Œ† (k : K), category_theory.limits.preserves_colimits_of_size (F ‚ãô (category_theory.evaluation K C).obj k)) : category_theory.limits.preserves_colimits_of_size F
{Œ± : Type} (p : parser Œ±) : parser (list Œ±)
 : linarith.ineq ‚Üí linarith.ineq ‚Üí ordering
{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G) : continuous (Œª (g : G), g + h + -g)
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] (e : R‚ÇÅ ‚âÉ+* R‚ÇÇ) : ring_hom_inv_pair ‚Üëe ‚Üë(e.symm)
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : ‚àÄ (x y : Œ≤), f x = f y) : measurable f
{Œ± : Type u} (l : list Œ±) : l ‚â† list.nil ‚Üí stream Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {b‚ÇÇ : basis (fin 2) ‚Ñù V} (hb‚ÇÇ : orthonormal ‚Ñù ‚áëb‚ÇÇ) (ho : b.orientation = b‚ÇÇ.orientation) : ‚àÉ (Œ∏ : real.angle), b‚ÇÇ = b.map (hb.rotation Œ∏).to_linear_equiv
{Œ≤ : Type u_2} (f : equiv.perm Œ≤) : Prop
(n : interactive.parse lean.parser.small_nat) (loc : interactive.parse interactive.types.location) : tactic unit
{X : Type u} (m : X ‚Üí X ‚Üí X) (e : X) : Prop
(Œ± : Type u_1) [group_with_zero Œ±] : Œ±À£ ‚âÉ {a // a ‚â† 0}
(F : Sort u_1) (Œ± : out_param (Sort u_2)) (Œ≤ : out_param (Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3))
 : tactic bool
 : expr ‚Üí tactic (list expr √ó expr)
(C : Type u‚ÇÅ) : category_theory.enriched_category (Type v) C ‚âÉ category_theory.category C
{G‚ÇÄ : Type u_2} [group_with_zero G‚ÇÄ] {p : G‚ÇÄÀ£ ‚Üí Prop} : (‚àÉ (g : G‚ÇÄÀ£), p g) ‚Üî ‚àÉ (g : G‚ÇÄ) (hg : g ‚â† 0), p (units.mk0 g hg)
 : tactic.interactive.itactic ‚Üí tactic unit
{Œ± : Type} : list Œ± ‚Üí native.rb_map ‚Ñï Œ±
 : has_zero onote
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} : mvqpf.cofix F Œ± ‚Üí (mvqpf.P F).M Œ±
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] : is_open_map prod.fst
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} {v : V} {x : k} {s : set Œπ} {p : Œπ ‚Üí P} {b : P} : (‚àÉ (fs : finset Œπ) (hfs : ‚Üëfs ‚äÜ s) (w : Œπ ‚Üí k) (hw : fs.sum (Œª (i : Œπ), w i) = x), v = ‚áë(fs.weighted_vsub_of_point p b) w) ‚Üî ‚àÉ (fs : finset ‚Ü•s) (w : ‚Ü•s ‚Üí k) (hw : fs.sum (Œª (i : ‚Ü•s), w i) = x), v = ‚áë(fs.weighted_vsub_of_point (Œª (i : ‚Ü•s), p ‚Üëi) b) w
(p : ‚Ñï) (R : Type u_1) [comm_ring R] [invertible ‚Üëp] : ‚Ñï ‚Üí mv_polynomial ‚Ñï R
 : pSet ‚Üí pSet
{Œ≤ : Type v} [has_zero Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_scalar ‚Ñï Œ≤] {Œ± : Type u} [non_unital_semiring Œ±] (f : Œ± ‚Üí Œ≤) (hf : function.surjective f) (zero : f 0 = 0) (add : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ±) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_unital_semiring Œ≤
{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s ‚Üí is_closed s
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] : has_coe (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)
{R : Type u_1} [comm_semiring R] {M‚ÇÅ : Type u_2} {M‚ÇÇ : Type u_3} [add_comm_monoid M‚ÇÅ] [module R M‚ÇÅ] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] (f : M‚ÇÅ ‚âÉ‚Çó[R] M‚ÇÇ) : module.dual R M‚ÇÇ ‚âÉ‚Çó[R] module.dual R M‚ÇÅ
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Z‚ÇÅ Z‚ÇÇ : C} (g‚ÇÅ : Z‚ÇÅ ‚ü∂ X‚ÇÅ) (g‚ÇÇ : Z‚ÇÅ ‚ü∂ X‚ÇÇ) (g‚ÇÉ : Z‚ÇÇ ‚ü∂ X‚ÇÇ) (g‚ÇÑ : Z‚ÇÇ ‚ü∂ X‚ÇÉ) [category_theory.limits.has_pushout g‚ÇÅ g‚ÇÇ] [category_theory.limits.has_pushout g‚ÇÉ g‚ÇÑ] [category_theory.limits.has_pushout (g‚ÇÉ ‚â´ category_theory.limits.pushout.inr) g‚ÇÑ] : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk category_theory.limits.pushout.inl (category_theory.limits.pushout.desc (category_theory.limits.pushout.inr ‚â´ category_theory.limits.pushout.inl) category_theory.limits.pushout.inr _) _)
{V : Type u} {G : simple_graph V} {Œ± : Type v} (C : G.coloring Œ±) : G.partition
(Œì : Type u_1) (R : Type u_2) [partial_order Œì] [add_comm_monoid R] (Œ± : Type u_3) : Type (max u_1 u_2 u_3)
(G‚ÇÄ : Type u_1) [measurable_space G‚ÇÄ] [has_div G‚ÇÄ] : Prop
{R : Type u} [comm_ring R] : Mon_ (Module R) ‚•§ Algebra R
(K : Type u_1) (L : Type u_2) {A : Type u_5} [field K] [field L] [comm_ring A] [algebra K L] [algebra L A] [algebra K A] [is_scalar_tower K L A] {x : A} (A_alg : is_algebraic K x) : is_algebraic L x
(J : Type v) (f : J ‚Üí œâCPO) : category_theory.limits.is_limit (œâCPO.has_products.product f)
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (s : subsemiring R) (t : subsemiring S) : subsemiring (R √ó S)
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] (F : C ‚•§ D) [F.preserves_zero_morphisms] : Type (max u u‚ÇÇ (v+1))
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} {l : filter Œ±} (op : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) : l.germ Œ≤ ‚Üí l.germ Œ≥ ‚Üí l.germ Œ¥
(o : ordinal) : cardinal
(Œ± : Type u) (Œ≤ : Type v) : Type (max u v)
{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_mul M] [has_mul N] [has_mul P] (hnp : N ‚Üí‚Çô* P) (hmn : M ‚Üí‚Çô* N) : M ‚Üí‚Çô* P
 : environment ‚Üí name ‚Üí option name
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] (F : D ‚•§ C) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{Œ± : Type u_1} [metric_space Œ±] (s : set Œ±) : metric_space (polish_space.complete_copy s)
{C D : Type u‚ÇÅ} [category_theory.small_category C] [category_theory.small_category D] (E : Type u‚ÇÇ) [category_theory.category E] [category_theory.concrete_category E] [category_theory.limits.has_limits E] [category_theory.limits.has_colimits E] [category_theory.limits.reflects_limits (category_theory.forget E)] [category_theory.limits.preserves_filtered_colimits (category_theory.forget E)] [category_theory.limits.preserves_limits (category_theory.forget E)] (F : C ‚•§ D) [category_theory.representably_flat F] : category_theory.limits.preserves_finite_limits (category_theory.Lan F.op)
{C : Type u‚ÇÅ} [category_theory.category C] (A : C) : Prop
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cocone F} (h : category_theory.limits.is_colimit t) : category_theory.coyoneda.obj (opposite.op t.X) ‚ãô category_theory.ulift_functor ‚âÖ F.cocones
(k : Type u_1) [division_ring k] {Œπ : Type u_4} (s : finset Œπ) [char_zero k] {n : ‚Ñï} (h : s.card = n + 1) : s.sum (Œª (i : Œπ), finset.centroid_weights k s i) = 1
{Œ± : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [has_zero N] (f : Œ± ‚Üí N) (g : Œ± ‚Üí N ‚Üí M) {s t : finset Œ±} (h : s ‚äÜ t) (hg : ‚àÄ (a : Œ±), g a 0 = 0) : s.sum (Œª (i : Œ±), g i (f i)) = t.sum (Œª (i : Œ±), g i (‚Üës.indicator f i))
{Œ± : Type u_1} [decidable_eq Œ±] (x y : Œ± √ó Œ±) : bool
{m : Type u ‚Üí Type u} [monad m] {Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] : tactic.mllist m Œ± ‚Üí tactic.mllist m Œ±
{Œ± : Type u_2} [decidable_eq Œ±] [mul_one_class Œ±] : Œ± ‚Üí* finset Œ±
(attr_name decl_name : name) : tactic bool
{Œ± : Type u_3} [linear_ordered_add_comm_group Œ±] : filter.tendsto has_abs.abs filter.at_bot filter.at_top
(e : expr) (I_name : name) : tactic bool
{Œ± : Type u_1} {Œ±' : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_5} {Œ¥ : Type u_7} {f : filter Œ±} {g : filter Œ≤} {m : Œ±' ‚Üí Œ≤ ‚Üí Œ≥} {n : Œ± ‚Üí Œ±'} {m' : Œ± ‚Üí Œ≤ ‚Üí Œ¥} {n' : Œ¥ ‚Üí Œ≥} (h_left_comm : ‚àÄ (a : Œ±) (b : Œ≤), m (n a) b = n' (m' a b)) : filter.map‚ÇÇ m (filter.map n f) g = filter.map n' (filter.map‚ÇÇ m' f g)
 : tactic.rcases_patt ‚Üí lean.parser (tactic.list_Sigma tactic.rcases_patt)
 : tactic unit
{Œ± : Type u} (sample : slim_check.gen Œ±) : ‚Ñï ‚Üí slim_check.gen (tree Œ±)
(Œ± : Type u) (Œ≤ : Type v) [group Œ±] [add_monoid Œ≤] [distrib_mul_action Œ± Œ≤] : Œ± ‚Üí* add_aut Œ≤
{X : Top} (U V : topological_space.opens ‚Ü•X) : U ‚äì V ‚ü∂ U
{R : Type u_1} [comm_semiring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [fintype n] [decidable_eq n] [fintype m] [decidable_eq m] (M : matrix l m R) (N : matrix m n R) (x : n ‚Üí R) : ‚áë(‚áëmatrix.to_lin' (M.mul N)) x = ‚áë(‚áëmatrix.to_lin' M) (‚áë(‚áëmatrix.to_lin' N) x)
(Œ± : Type u) {Œ≤ : Type v} [monoid Œ±] [mul_action Œ± Œ≤] (b : Œ≤) : set Œ≤
(s : interactive.parse (optional interactive.types.pexpr_list)) (wth : interactive.parse (optional interactive.types.with_ident_list)) (tgt : interactive.parse (optional (lean.parser.tk "using" *> interactive.types.texpr))) : tactic unit
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] (G : C ‚•§ D) {V U : D} (f : V ‚ü∂ U) : Type (max u_1 u_4)
{R : Type u_1} [comm_ring R] {n : ‚Ñï} (hpos : 0 < n) : polynomial.cyclotomic n R = (polynomial.X ^ n - 1) /‚Çò n.proper_divisors.prod (Œª (i : ‚Ñï), polynomial.cyclotomic i R)
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [topological_space.second_countable_topology X] {r : nnreal} {f : X ‚Üí Y} (hr : 0 < r) (hf : ‚àÄ (x : X), ‚àÉ (C : nnreal) (s : set X) (H : s ‚àà nhds x), holder_on_with C r f s) : dimH (set.range f) ‚â§ dimH set.univ / ‚Üër
{Œ± : Type u} (edist : Œ± ‚Üí Œ± ‚Üí ennreal) (edist_self : ‚àÄ (x : Œ±), edist x x = 0) (edist_comm : ‚àÄ (x y : Œ±), edist x y = edist y x) (edist_triangle : ‚àÄ (x y z : Œ±), edist x z ‚â§ edist x y + edist y z) : uniform_space Œ±
{Œ± : Type u_1} (r : setoid Œ±) : Œ± ‚Üí Œ± ‚Üí Prop
{Œ≤ : Type u} {Œ± : Type v} [comm_monoid Œ≤] {s : finset Œ±} {f : Œ± ‚Üí Œ≤} {a : Œ±} (hp : s.prod (Œª (x : Œ±), f x) = 1) (h1 : ‚àÄ (x : Œ±), x ‚àà s ‚Üí x ‚â† a ‚Üí f x = 1) (x : Œ±) (H : x ‚àà s) : f x = 1
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_binary_coproduct X Y] : Y ‚ü∂ X ‚®ø Y
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} : antitone_on f s ‚Üí monotone_on (‚áëorder_dual.to_dual ‚àò f) s
 : has_lt.lt ‚âÉr has_lt.lt
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] (h : continuous_map.homotopy_equiv X Y) : Y ‚Üí X
(Œ± : Type u_1) (Œ≤ : Type u_2) [uniform_space Œ≤] : topological_space (Œ± ‚Üí Œ≤)
{m : Type u_2} {n : Type u_3} {R : Type u_7} {Œ± : Type v} {Œ≤ : Type w} [semiring R] [add_comm_monoid Œ±] [add_comm_monoid Œ≤] [module R Œ±] [module R Œ≤] (f : Œ± ‚Üí‚Çó[R] Œ≤) : matrix m n Œ± ‚Üí‚Çó[R] matrix m n Œ≤
{x y : pgame} : x.left_moves √ó y.right_moves ‚äï x.right_moves √ó y.left_moves ‚âÉ (x * y).right_moves
{X : Type u_1} [topological_space X] (x : X) [h : (nhds_within x {x}·∂ú).ne_bot] : (nhds_within ‚Üëx {‚Üëx}·∂ú).ne_bot
{M : Type u_1} {Œ± : Type u_2} [measurable_space M] [measurable_space Œ±] [has_scalar M Œ±] [has_scalar M·µê·µí·µñ Œ±] [is_central_scalar M Œ±] [has_measurable_smul M Œ±] : has_measurable_smul M·µê·µí·µñ Œ±
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [has_zero Œπ] [graded_monoid.ghas_one A] : has_one (graded_monoid A)
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] : ‚Ñö_[p] ‚Üí ‚Ñ§
{Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) : Type u_1
 : tactic unit
(V : Type u) [quiver V] : Type (max u v)
{K : Type u_1} [is_R_or_C K] : ‚Ñù ‚Üí‚Çê[‚Ñù] K
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_assoc_semiring Œ±} {rŒ≤ : non_assoc_semiring Œ≤} : has_coe_to_fun (Œ± ‚Üí+* Œ≤) (Œª (_x : Œ± ‚Üí+* Œ≤), Œ± ‚Üí Œ≤)
(ùïú : Type u) {Œπ : Type v} (E : Œπ ‚Üí Type wE) [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] {Œπ' : Type v'} [fintype Œπ'] {E' : Œπ' ‚Üí Type wE'} [Œ† (i' : Œπ'), normed_group (E' i')] [Œ† (i' : Œπ'), normed_space ùïú (E' i')] : (Œ† (i' : Œπ'), continuous_multilinear_map ùïú E (E' i')) ‚âÉ‚Çó·µ¢[ùïú] continuous_multilinear_map ùïú E (Œ† (i : Œπ'), E' i)
 : linarith.linarith_monad (native.rb_set linarith.pcomp)
(R : Type u_1) (M : Type u_2) (N : Type u_3) [comm_semiring R] [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : tensor_product R (module.dual R M) (module.dual R N) ‚Üí‚Çó[R] module.dual R (tensor_product R M N)
{C : Type u} [category_theory.category C] (F : C ‚•§ Type w) : Type (max u w)
{Œ≤ : Type u} {Œ± : Type v} {s : finset Œ±} [add_comm_monoid Œ≤] (f : Œ± ‚Üí Œ≤) {p : Œ± ‚Üí Prop} [decidable_pred p] (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p x) : (finset.subtype p s).sum (Œª (x : subtype p), f ‚Üëx) = s.sum (Œª (x : Œ±), f x)
{R : Type u_1} [cancel_monoid R] (g : R) : is_regular g
{Œ± : Type u_3} {Œ≤ : Type u_4} {f : Œ± ‚Üí Œ≤} {k : filter Œ±} {l : filter Œ≤} [k.is_countably_generated] : filter.tendsto f k l ‚Üî ‚àÄ (x : ‚Ñï ‚Üí Œ±), filter.tendsto x filter.at_top k ‚Üí filter.tendsto (f ‚àò x) filter.at_top l
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) : J.sheafify P ‚ü∂ J.sheafify Q
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{F : Type} [comm_semiring F] {f : polynomial F} (hf : polynomial.has_separable_contraction 1 f) : hf.degree = f.nat_degree
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_zero_class Œ±] [add_comm_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_monoid_hom f) : is_add_monoid_hom (Œª (a : Œ±), -f a)
 : Type
{œÑ : Type u_1} [add_comm_group œÑ] [topological_space œÑ] [topological_add_group œÑ] {Œ± : Type u_2} [topological_space Œ±] (œï : flow œÑ Œ±) (t : œÑ) : Œ± ‚âÉ‚Çú Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {i : Œ± ‚Üí Œ≤} (di : dense_inducing i) [topological_space.separable_space Œ±] : topological_space.separable_space Œ≤
 : CompHaus.to_Profinite ‚ä£ Profinite_to_CompHaus
{Œ± : Type u_1} (L : list Œ±) {i : ‚Ñï} (hi : i < L.length) : list.drop i (list.take (i + 1) L) = [L.nth_le i hi]
{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} : f = g ‚Üî ‚àÄ (x : M), ‚áëf x = ‚áëg x
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) : o.oangle y (‚áë(o.rotation (o.oangle x y)) x) = 0
(l : list (expr √ó expr)) : tactic unit
(Œ± : Type u_1) [ring Œ±] : Type u_1
{R : Type u_1} [comm_ring R] : (nat.arithmetic_function R)À£
(o : nonote) : ordinal
(n : interactive.parse lean.parser.ident) (p : interactive.parse (lean.parser.tk ":" *> interactive.types.texpr)) : tactic unit
{Œ± : Type u} {Œ≤ : Type v} [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] : (Œ± ‚ÜíùíÑ Œ≤) ‚Üío Œ± ‚Üío Œ≤
(K : Type u_1) : Type u_1
 : tactic unit
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ CommRing Ring)
(K : Type u_1) [division_ring K] [topological_space K] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_images C] (f : X ‚ü∂ Y) : category_theory.mono_over X ‚•§ category_theory.mono_over Y
{p : ‚Ñï} [fact (nat.prime p)] : has_zero ‚Ñ§_[p]
{J : Type v} [category_theory.small_category J] (F : J ‚•§ SemiRing) [category_theory.is_filtered J] : Mon
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [succ_order Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : monotone f) : pairwise (disjoint on Œª (n : Œ±), set.Ioo (f n) (f (order.succ n)))
{Œ± : Type u_1} {Œ≤ : Type u_2} (s : finset Œ±) (t : finset Œ≤) : finset (Œ± √ó Œ≤)
 : disjoint (residual ‚Ñù) measure_theory.measure_space.volume.ae
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p‚ÇÅ : Œπ ‚Üí P) (p‚ÇÇ : P) (h : s.sum (Œª (i : Œπ), w i) = 0) : s.sum (Œª (i : Œπ), w i ‚Ä¢ (p‚ÇÅ i -·µ• p‚ÇÇ)) = ‚áë(s.weighted_vsub p‚ÇÅ) w
{ùïú : Type u_2} {E : Type u_5} [comm_semiring ùïú] [topological_space ùïú] [has_continuous_add ùïú] [has_continuous_const_smul ùïú ùïú] [add_comm_monoid E] [module ùïú E] [topological_space E] (R : Type u_1) [semiring R] [module R ùïú] [smul_comm_class ùïú R ùïú] [has_continuous_const_smul R ùïú] : module R (weak_dual ùïú E)
{a b : ‚Ñï} (ha : a ‚â† 0) (hb : b ‚â† 0) : (a * b).factorization = a.factorization + b.factorization
 : Type (max (u+1) u (v+1))
{H : Type u_1} [topological_space H] (G : structure_groupoid H) (f : H ‚Üí H) (s : set H) (x : H) : Prop
(R : Type u_1) {V : Type u_2} {P : Type u_4} [ring R] [invertible 2] [add_comm_group V] [module R V] [add_torsor V P] (x y : P) : P
 : num ‚Üí num ‚Üí num
{Œπ : Type u_1} (p : ‚Ñù) [fact_one_le_p : fact (1 ‚â§ p)] (Œ≤ : Œπ ‚Üí Type u_4) [fintype Œπ] [Œ† (i : Œπ), pseudo_metric_space (Œ≤ i)] : pseudo_metric_space (pi_Lp p Œ≤)
{Œ± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Œ± ‚Üí E} {g' : Œ± ‚Üí F'} {l : filter Œ±} : (f =o[l] Œª (x : Œ±), -g' x) ‚Üí f =o[l] g'
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] {X Y : C} [category_theory.simple X] [category_theory.simple Y] (f : X ‚ü∂ Y) : category_theory.is_iso f ‚Üî f ‚â† 0
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (s : finset S) : ‚àÉ (b : ‚Ü•M), ‚àÄ (a : S), a ‚àà s ‚Üí is_localization.is_integer R (‚Üëb ‚Ä¢ a)
(Œ± : Type u_3) : Type u_3
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} [comm_ring R] [lie_ring L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÅ] [lie_algebra R L‚ÇÇ] (L‚ÇÅ' : lie_subalgebra R L‚ÇÅ) (L‚ÇÇ' : lie_subalgebra R L‚ÇÇ) (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) (h : lie_subalgebra.map ‚Üëe L‚ÇÅ' = L‚ÇÇ') : ‚Ü•L‚ÇÅ' ‚âÉ‚Çó‚ÅÖR‚ÅÜ ‚Ü•L‚ÇÇ'
{Œ± : Type u_1} {Œπ : Type u_3} [complete_lattice Œ±] {s : finset Œπ} {f : Œπ ‚Üí Œ±} : complete_lattice.independent (f ‚àò coe) ‚Üí s.sup_indep f
 : filter.tendsto ‚áëcomplex.norm_sq (filter.cocompact ‚ÑÇ) filter.at_top
{Œ± : Type u} {Œ≤ : Type v} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} [f.ne_bot] (h : filter.tendsto u f (nhds a)) : f.liminf u = a
(G : Type u) : Type u
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] [complete_space E] (p q : subspace ùïú E) (h : is_compl p q) (hp : is_closed ‚Üëp) (hq : is_closed ‚Üëq) : (‚Ü•p √ó ‚Ü•q) ‚âÉL[ùïú] E
(Œ± : Type u) : Type u
{R‚ÇÅ : Type u_2} {R‚ÇÇ : Type u_3} {M : Type u_9} {N‚ÇÇ : Type u_14} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_group N‚ÇÇ] [module R‚ÇÅ M] [module R‚ÇÇ N‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} : add_comm_group (M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] N‚ÇÇ)
{m n : ‚Ñï} (co : n.coprime m) (a b : ‚Ñï) : {k // k ‚â° a [MOD n] ‚àß k ‚â° b [MOD m]}
{Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f‚ÇÅ f‚ÇÇ : Œ† (x : Œ±), Œ≤ x} (h : ‚àÄ (x : Œ±), f‚ÇÅ x = f‚ÇÇ x) : f‚ÇÅ = f‚ÇÇ
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [comm_ring R] [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] (v : valuation R Œì‚ÇÄ) {J : ideal R} (hJ : J ‚â§ v.supp) : valuation (R ‚ß∏ J) Œì‚ÇÄ
(Œ± : Type u_1) [linear_ordered_ring Œ±] (ceil : Œ± ‚Üí ‚Ñ§) (gc_ceil_coe : galois_connection ceil coe) : floor_ring Œ±
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] {C : Type u} [category_theory.category C] {F : J ‚•§ K ‚•§ C} (D : category_theory.limits.diagram_of_cones F) : J ‚•§ C
(x y : string) : bool
(v : list bool) : ‚Ñï
{R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] (e : basis Œπ R M) (f : M ‚âÉ‚Çó[R] M) : (e.map f).orientation = -e.orientation ‚Üî ‚áëlinear_map.det ‚Üëf < 0
{Œ± : Type u} [topological_space Œ±] : t2_space Œ± ‚Üî ‚àÄ {x y : Œ±}, (nhds x ‚äì nhds y).ne_bot ‚Üí x = y
{M : Type u_1} [monoid M] (P : submonoid M) : P.fg ‚Üî ‚àÉ (S : set M), submonoid.closure S = P ‚àß S.finite
(R : Type u_1) [comm_semiring R] (S : Type u_2) [comm_semiring S] [algebra R S] (x : R) (e : is_unit x) [is_localization.away x S] : R ‚âÉ‚Çê[R] S
{A : Type u_1} [semiring A] [algebra ennreal A] : algebra nnreal A
(c : tactic.instance_cache) (a : expr) (na : ‚Ñö) : tactic (tactic.instance_cache √ó expr √ó expr √ó expr)
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [ring_hom_surjective œÉ‚ÇÅ‚ÇÇ] {f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (hf : function.injective ‚áëf) : galois_coinsertion (submodule.map f) (submodule.comap f)
{K : Type u_1} [linear_ordered_field K] {v : K} {n : ‚Ñï} [floor_ring K] (terminated_at_n : (generalized_continued_fraction.of v).terminated_at n) : v = (generalized_continued_fraction.of v).convergents n
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {g : Œ≤ ‚Üí M} (e : Œ± ‚Üí Œ≤) (he‚ÇÄ : function.bijective e) (he‚ÇÅ : ‚àÄ (x : Œ±), f x = g (e x)) : finsum (Œª (i : Œ±), f i) = finsum (Œª (j : Œ≤), g j)
(Œ± : Type u_3) [topological_space Œ±] : Type u_3
{R : Type u} [rack R] {a b : rack.pre_envel_group R} : rack.pre_envel_group_rel' R a b ‚Üí rack.pre_envel_group_rel R a b
(p : ‚Ñï) (a : ‚Ñ§) [hp : fact (nat.prime p)] : ‚Üë(zmod.legendre_sym p a) = ‚Üëa ^ (p / 2)
{R : Type u} [comm_ring R] {n : Type v} [decidable_eq n] [fintype n] (M : matrix n n R) (p : polynomial R) : ‚áë(polynomial.aeval M) p = ‚áë(polynomial.aeval M) (p %‚Çò M.charpoly)
{X : Type u} {Y : Type v} {Z : Type w} [topological_space X] [topological_space Y] [topological_space Z] (h‚ÇÅ : continuous_map.homotopy_equiv X Y) (h‚ÇÇ : continuous_map.homotopy_equiv Y Z) : continuous_map.homotopy_equiv X Z
{Œ± : Type u_1} [add_comm_monoid Œ±] {n : ‚Ñï} (f : affine.simplex.points_with_circumcenter_index n ‚Üí Œ±) : finset.univ.sum (Œª (i : affine.simplex.points_with_circumcenter_index n), f i) = finset.univ.sum (Œª (i : fin (n + 1)), f (affine.simplex.points_with_circumcenter_index.point_index i)) + f affine.simplex.points_with_circumcenter_index.circumcenter_index
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [group Œ±] [uniform_group Œ±] {hom : Type u_3} [uniform_space Œ≤] [group Œ≤] [uniform_group Œ≤] [monoid_hom_class hom Œ± Œ≤] (f : hom) (hf : continuous_at ‚áëf 1) : uniform_continuous ‚áëf
(Œ± : Type u) : ‚Ñï ‚Üí Type u
{C : Type u} [category_theory.category C] {S : Type w} [category_theory.small_category S] (e : C ‚âå S) : category_theory.essentially_small C
 : ennreal ‚Üí* ‚Ñù
{M : Type u_1} [add_monoid M] (x : M) : set M
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {E : Type u_4} {F : Type u_6} {F‚Çó : Type u_7} [normed_group E] [normed_group F] [normed_group F‚Çó] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] [normed_space ùïú F‚Çó] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F) [complete_space F] (e : E ‚ÜíL[ùïú] F‚Çó) (h_dense : dense_range ‚áëe) (h_e : uniform_inducing ‚áëe) : F‚Çó ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F
{Œ± : Type u} {s : set Œ±} : s.countable ‚Üí encodable ‚Ü•s
{Œ± : Type u_1} (s t : multiset Œ±) : Prop
{ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_5} [normed_field ùïú] [add_comm_group E] [module ùïú E] (p : seminorm_family ùïú E Œπ) : set (set E)
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] (f : P1 ‚Üí P2) (f' : V1 ‚Üí‚Çó[k] V2) (p : P1) (h : ‚àÄ (p' : P1), f p' = ‚áëf' (p' -·µ• p) +·µ• f p) : P1 ‚Üí·µÉ[k] P2
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) (X : C) : category_theory.limits.is_limit (G.map_cone (category_theory.limits.as_empty_cone X)) ‚âÉ category_theory.limits.is_terminal (G.obj X)
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_lt.lt] {a b : Œ±} (ha : 1 < a) (hb : 1 ‚â§ b) : 1 < a * b
{Œ± : Type u} [add_group Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a : Œ±} (h : 0 ‚â§ a) : -a ‚â§ a
{ùïú : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [comm_ring ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] [add_comm_group F] [module ùïú F] [topological_space F] [topological_add_group F] [has_continuous_const_smul ùïú F] [add_comm_group G] [module ùïú G] [topological_space G] [topological_add_group G] [has_continuous_const_smul ùïú G] (f : F ‚ÜíL[ùïú] G) (p : formal_multilinear_series ùïú E F) : formal_multilinear_series ùïú E G
(hs : interactive.parse tactic.simp_arg_list) : conv unit
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.enough_injectives C] (Z : C) : cochain_complex C ‚Ñï
(pre : name) : name ‚Üí tactic bool
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_3} [fintype Œπ] (m : Œ† (i : Œπ), measure_theory.outer_measure (Œ± i)) (s : set (Œ† (i : Œπ), Œ± i)) : ennreal
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} (H : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí (‚àÉ (t : set Œ±) (H : t ‚äÜ s), x ‚àà t ‚àß y ‚àà t ‚àß is_preconnected t)) : is_preconnected s
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (Y : C) : Type (max u‚ÇÅ v‚ÇÅ)
{f : ‚ÑÇ ‚Üí ‚ÑÇ} {z : ‚ÑÇ} : conformal_at f z ‚Üî (differentiable_at ‚ÑÇ f z ‚à® differentiable_at ‚ÑÇ (f ‚àò ‚áë(star_ring_end ‚ÑÇ)) (‚áë(star_ring_end ‚ÑÇ) z)) ‚àß fderiv ‚Ñù f z ‚â† 0
{ùïú : Type u_1} [is_R_or_C ùïú] [decidable_eq ùïú] {n : Type u_2} [fintype n] [decidable_eq n] {A : matrix n n ùïú} (hA : A.is_hermitian) : fin (fintype.card n) ‚Üí ‚Ñù
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type u_1} {s : set Œπ} [is_noetherian K V] (b : basis ‚Ü•s K V) : s.finite
{Œ± : Type u_1} [partial_order Œ±] [order_bot Œ±] {a : Œ±} : ‚ä• ‚ãñ a ‚Üí is_atom a
{p : ‚Ñï} : padic_val_nat p 0 = 0
{R : Type u_1} [semiring R] [nontrivial R] (n : ‚Ñï) : (power_series.X ^ n).order = ‚Üën
{G : Type u_1} [group G] {k : set G} : k ‚äÜ ‚Üë(subgroup.closure k)
 : lean.parser ((option tactic.rcases_patt √ó option pexpr) √ó option (pexpr ‚äï list pexpr))
(F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] [fintype E] : ‚àÉ (Œ± : E), F‚üÆŒ±‚üØ = ‚ä§
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (t : category_theory.limits.cone F) : Type (max u‚ÇÅ u‚ÇÉ v‚ÇÉ)
{V : Type u} (G : simple_graph V) (v : V) (w : ‚Ü•(G.neighbor_set v)) : G.dart
 : Type (u_1+1)
{ùíú : Type u_1} [category_theory.category ùíú] [category_theory.preadditive ùíú] [category_theory.limits.has_kernels ùíú] [category_theory.limits.has_images ùíú] [category_theory.limits.has_binary_biproducts ùíú] (A B : ùíú) : category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst
{R : Type u} [has_star R] : has_star R·µê·µí·µñ
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [invertible 2] (p : fin 2 ‚Üí P) : finset.centroid k finset.univ p = 2‚Åª¬π ‚Ä¢ (p 1 -·µ• p 0) +·µ• p 0
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (s : alist Œ≤) : list Œ±
(vars : list expr) : tactic (list (expr √ó expr))
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [dec : decidable_eq Œπ] [Œ† (i : Œπ), has_zero (Œ≤ i)] (i : Œπ) (b : Œ≤ i) : Œ†‚ÇÄ (i : Œπ), Œ≤ i
(X : Type u) [comm_ring X] [topological_space X] [topological_ring X] : TopCommRing
{Œ± : Type u} [has_subset Œ±] {a b : Œ±} [is_refl Œ± has_subset.subset] : a = b ‚Üí a ‚äÜ b
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_2} (F : Œ† (a : Œ±), equiv.perm (Œ≤ a)) : equiv.perm (Œ£ (a : Œ±), Œ≤ a)
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : has_coe_to_fun (matrix.special_linear_group n R) (Œª (_x : matrix.special_linear_group n R), n ‚Üí n ‚Üí R)
(R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : subsingleton M
{Œ± : Type u_1} {Œ≤ : Type u_2} [encodable Œ±] [encodable Œ≤] : Œ± ‚äï Œ≤ ‚Üí ‚Ñï
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚Üí D) [category_theory.functorial F] {X Y : C} (f : X ‚ü∂ Y) : F X ‚ü∂ F Y
{R : Type u_1} [semiring R] (n : ‚Ñï) (a : R) (h : a ‚â† 0) : (‚áë(power_series.monomial R n) a).order = ‚Üën
{M : Type u_2} [add_comm_group M] {A : Type u_1} [comm_ring A] [module A M] (f : M ‚âÉ‚Çó[A] M) : ‚áëlinear_map.det ‚Üëf * ‚áëlinear_map.det ‚Üë(f.symm) = 1
(n p : ‚Ñï) : (‚Üëp + 1) * (finset.range n).sum (Œª (k : ‚Ñï), ‚Üëk ^ p) = polynomial.eval ‚Üën (polynomial.bernoulli p.succ) - bernoulli p.succ
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e : local_homeomorph Œ± Œ≤} {s : set Œ±} {t : set Œ≤} (h : e.is_image s t) (hs : is_open (e.to_local_equiv.source ‚à© s)) : local_homeomorph Œ± Œ≤
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R) : ((‚àÄ (a : ‚Ü•P), ‚áëg (‚áëf a) = 0) ‚àß ‚àÄ (b : ‚Ü•Q), ‚áëg b = 0 ‚Üí (‚àÉ (a : ‚Ü•P), ‚áëf a = b)) ‚Üí category_theory.exact f g
{R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] (X : Module R) [h : category_theory.epi 0] : unique M
(e : expr) : name_set
{Œì‚ÇÄ : Type u_1} [linear_ordered_comm_group_with_zero Œì‚ÇÄ] (Œ≥ : Œì‚ÇÄ) (h : Œ≥ ‚â† 0) : {x : Œì‚ÇÄ | x < Œ≥} ‚àà nhds 0
{Œ± : Type u_1} [has_Inf Œ±] {Œπ : Sort u_2} (s : Œπ ‚Üí Œ±) : Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] [complete_space ùïú] {n : with_top ‚Ñï} {f : E ‚Üí (F ‚ÜíL[ùïú] G)} {s : set E} [finite_dimensional ùïú F] : cont_diff_on ùïú n f s ‚Üî ‚àÄ (y : F), cont_diff_on ùïú n (Œª (x : E), ‚áë(f x) y) s
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (A : C) [category_theory.closed A] : C ‚•§ C
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] : (algebraic_geometry.SheafedSpace C)·µí·µñ ‚•§ C
 : num ‚Üí num ‚Üí num
{R : Type u} {S : Type v} [comm_ring R] {f : polynomial R} [comm_ring S] (i : R ‚Üí+* S) (x : S) (h : polynomial.eval‚ÇÇ i x f = 0) : adjoin_root f ‚Üí+* S
{X : Type u} {m‚ÇÅ : X ‚Üí X ‚Üí X} {e‚ÇÅ : X} (h‚ÇÅ : eckmann_hilton.is_unital m‚ÇÅ e‚ÇÅ) [G : add_group X] (distrib : ‚àÄ (a b c d : X), m‚ÇÅ (a + b) (c + d) = m‚ÇÅ a c + m‚ÇÅ b d) : add_comm_group X
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {f : E ‚Üí F} {g : E ‚Üí G} (hf : cont_diff ùïú n f) (hg : cont_diff ùïú n g) : cont_diff ùïú n (Œª (x : E), (f x, g x))
(M : Type u_1) [monoid M] : mul_action M M
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {U : Top} (X : algebraic_geometry.SheafedSpace C) {f : U ‚ü∂ ‚ÜëX} (h : open_embedding ‚áëf) : algebraic_geometry.SheafedSpace C
{R : Type u} {Œπ : Type w} (s : finset Œπ) [comm_semiring R] [no_zero_divisors R] (f : Œπ ‚Üí polynomial R) : (s.prod (Œª (i : Œπ), f i)).leading_coeff = s.prod (Œª (i : Œπ), (f i).leading_coeff)
{Œ± : Type u_1} {Œ≤ : Type u_2} {e e' : local_equiv Œ± Œ≤} (he : e ‚âà e') (s : set Œ≤) : e.source ‚à© ‚áëe ‚Åª¬π' s = e'.source ‚à© ‚áëe' ‚Åª¬π' s
{Œ± : Type u} (Œ≤ : Œ± ‚Üí Type v) : Type (max u v)
{Œ± : Type u} (s : computation Œ±) : Prop
{key : Type} (s : native.rb_set key) (l : list key) : native.rb_set key
 : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (hf : function.surjective f) : quotient (setoid.ker f) ‚âÉ Œ≤
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] [decidable_eq Œπ] [canonically_ordered_add_monoid Œπ] (ùíú : Œπ ‚Üí submodule R A) [graded_algebra ùíú] : homogeneous_ideal ùíú
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} : P.obj (Œ± ::: P.M Œ±) ‚Üí P.M Œ±
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P (n + 2)) : s.monge_point = ‚áë(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.monge_point_weights_with_circumcenter n)
{ùïú : Type u_1} {E : Type u_3} {F : Type u_4} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) : formal_multilinear_series ùïú E (E ‚ÜíL[ùïú] F)
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] (F : J ‚•§ K ‚•§ C) (c : Œ† (k : K), category_theory.limits.limit_cone (F.flip.obj k)) : category_theory.limits.cone F
{R : Type u_1} {S : Type u_3} [semiring R] [semiring S] : semiring (R √ó S)
(c : omega.clause) : Prop
{m : Type u_2} {n : Type u_3} {Œ± : Type v} [non_unital_non_assoc_semiring Œ±] [fintype m] (v : m ‚Üí Œ±) (M : matrix m n Œ±) : n ‚Üí Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {Œπ : Type v} {B : Œπ ‚Üí C} (hB : ‚àÄ (A : C), ‚àÉ (i : Œπ), nonempty (B i ‚ü∂ A)) : ‚àÉ (T : C), ‚àÄ (X : C), nonempty (T ‚ü∂ X)
(trace : interactive.parse (optional (lean.parser.tk "?"))) (xs : interactive.parse (lean.parser.many tactic.rcases_patt_parse_hi)) : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {X Y : C} (F : C ‚•§ D) [category_theory.full F] (f : F.obj X ‚ü∂ F.obj Y) : X ‚ü∂ Y
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (b : Œ≤) (v : vector Œ± 1) : vector.scanl f b v = b::·µ•f b v.head::·µ•vector.nil
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {a : Œ±} {s : set Œ±} (h : f a = 0) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà has_insert.insert a s), f i)) = finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i))
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {t : finset V} (h : finite_dimensional.finrank K V < t.card) : ‚àÉ (f : V ‚Üí K), t.sum (Œª (e : V), f e ‚Ä¢ e) = 0 ‚àß ‚àÉ (x : V) (H : x ‚àà t), f x ‚â† 0
{m : Type u_1} {R : Type u_2} [fintype m] [comm_ring R] {M : matrix m m R} (hM : M.nondegenerate) {v : m ‚Üí R} (hv : ‚àÄ (w : m ‚Üí R), matrix.dot_product v (M.mul_vec w) = 0) : v = 0
{C : Type (max v u)} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] {K : Type (max v u)} [category_theory.small_category K] [category_theory.concrete_category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [category_theory.limits.preserves_limits (category_theory.forget D)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] [Œ† (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)·µí·µñ (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] {F : K ‚•§ category_theory.Sheaf J D} (E : category_theory.limits.cocone (F ‚ãô category_theory.Sheaf_to_presheaf J D)) (hE : category_theory.limits.is_colimit E) : category_theory.limits.is_colimit (category_theory.Sheaf.sheafify_cocone E)
(b : pgame.domineering.board) : finset (‚Ñ§ √ó ‚Ñ§)
{G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G
{M : Type u_1} [monoid M] (n : M) : submonoid M
(hs : list expr) : tactic (list expr_set)
(Œ± : Type u_1) [decidable_eq Œ±] : decidable_rel (sym2.rel Œ±)
(p : ‚Ñï) (R : Type u_1) [comm_ring R] (n : ‚Ñï) : mv_polynomial ‚Ñï R
{Œ± : Type u} [preorder Œ±] {a b : Œ±} (h : a < b) : ¬¨b < a
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (G : D ‚•§ C) [‚àÄ (A : C), category_theory.limits.has_terminal (category_theory.costructured_arrow G A)] : category_theory.is_left_adjoint G
{Œ± : Type u_1} {Œ≤ : Type u_2} (t : Œ±) (ts : list Œ±) (r : list Œ≤) (ys : list Œ±) (f : list Œ± ‚Üí Œ≤) : (list.permutations_aux2 t ts r ys f).snd = list.map (Œª (x : list Œ±), f (x ++ ts)) (list.permutations_aux2 t list.nil list.nil ys id).snd ++ r
{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (self : submodule R M) : sub_mul_action R M
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : filter Œπ} : tendsto_uniformly F f p ‚Üî filter.tendsto (Œª (q : Œπ √ó Œ±), (f q.snd, F q.fst q.snd)) (p.prod ‚ä§) (uniformity Œ≤)
{Œ± : Type u_1} : list Œ± ‚Üí ‚Ñï ‚Üí list Œ±
{K : Type w} [field K] {f : polynomial K} (hf : f ‚â† 0) : power_basis K (adjoin_root f)
(s : string) (c : char) : list string
 : omega.int.preform ‚Üí omega.int.preform
 : tactic unit
(n : ‚Ñï) : multiset (‚Ñï √ó ‚Ñï)
{M : Type u_1} {N : Type u_2} {Œ± : Type u_6} {Œ≤ : Type u_7} [has_scalar M Œ±] [has_scalar M Œ≤] [has_scalar Œ± Œ≤] [is_scalar_tower M Œ± Œ≤] (g : N ‚Üí M) : is_scalar_tower N Œ± Œ≤
 : vm_decl ‚Üí ‚Ñï
(R : Type u) {X : Type v} [comm_ring R] {L : Type w} [lie_ring L] [lie_algebra R L] : (X ‚Üí L) ‚âÉ (free_lie_algebra R X ‚Üí‚Çó‚ÅÖR‚ÅÜ L)
(loc : interactive.parse interactive.types.location) : tactic unit
(C : Type u‚ÇÅ) [category_theory.category C] : C·µí·µñ·µí·µñ ‚âå C
{Œ± : Type u} [topological_space Œ±] (x : Œ±) (F : filter Œ±) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [pseudo_metric_space Œ≤] (f : Œ± ‚Üí Œ≤) (h : uniform_inducing f) : pseudo_metric_space Œ±
{n : Type u_3} {Œ± : Type v} [has_star Œ±] : has_star (matrix n n Œ±)
{Œ± : Type u_1} [preorder Œ±] [order_bot Œ±] [locally_finite_order Œ±] (b : Œ±) : finset Œ±
(nm : option name) (with_list : option pexpr) (e : expr) : tactic unit
 : fourier_subalgebra.separates_points
{Œ± : Type u_2} [comm_monoid Œ±] (A : set Œ±) (n : ‚Ñï) : A ‚Üí*[n] Œ±
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (E : Type u_2) [semi_normed_group E] [normed_space ùïú E] : Type (max u_2 u_1)
(n : ‚Ñï) (R : Type u_1) [ring R] [nontrivial R] : polynomial.cyclotomic n R ‚â† 0
{Œ± : Type u_1} (c : set (set Œ±)) (H : ‚àÄ (a : Œ±), ‚àÉ! (b : set Œ±) (H : b ‚àà c), a ‚àà b) : setoid Œ±
 : ‚Ñù ‚Üí*‚ÇÄ nnreal
{Œ±‚ÇÅ : Type u_1} {Œ≤‚ÇÅ : Type u_2} {Œ±‚ÇÇ : Type u_3} {Œ≤‚ÇÇ : Type u_4} (hŒ± : Œ±‚ÇÅ ‚âÉ Œ±‚ÇÇ) (hŒ≤ : Œ≤‚ÇÅ ‚âÉ Œ≤‚ÇÇ) : (Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ) ‚âÉ (Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ)
{n : ‚Ñï} {Œ± : Type u_1} (v : vector Œ± (n + 1)) : Œ±
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a : Œ±} : -a < 0 ‚Üî 0 < a
{Œ± : Type u_1} {Œπ : Type u_3} [complete_lattice Œ±] {s : finset Œπ} {f : Œπ ‚Üí Œ±} : s.sup_indep f ‚Üí complete_lattice.independent (f ‚àò coe)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {n : ‚Ñï} {f : ùïú ‚Üí F} {s : set ùïú} {x : ùïú} (hxs : unique_diff_on ùïú s) (hx : x ‚àà s) : iterated_deriv_within (n + 1) f s x = iterated_deriv_within n (deriv_within f s) s x
{R : Type u} [non_assoc_semiring R] {s : set R} {p : R ‚Üí Prop} {x : R} (h : x ‚àà subsemiring.closure s) (Hs : ‚àÄ (x : R), x ‚àà s ‚Üí p x) (H0 : p 0) (H1 : p 1) (Hadd : ‚àÄ (x y : R), p x ‚Üí p y ‚Üí p (x + y)) (Hmul : ‚àÄ (x y : R), p x ‚Üí p y ‚Üí p (x * y)) : p x
{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b)) : is_add_left_regular b
{P : pfunctor} : P.W ‚Üí P.obj P.W
 : category_theory.grothendieck_topology (Type u)
{Œ≤ : Type u_2} [decidable_eq Œ≤] (s : finset Œ≤) (b : Œ≤) : finset.filter (Œª (a : Œ≤), a = b) s = ite (b ‚àà s) {b} ‚àÖ
(n : ‚Ñï) : option ‚Ñï ‚Üí Prop
 : expr ‚Üí tactic expr
(A : Type u_3) [category_theory.category A] [category_theory.abelian A] : algebraic_topology.normalized_Moore_complex A ‚ü∂ algebraic_topology.alternating_face_map_complex A
{k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] [contravariant_class M M has_add.add has_le.le] {a b : k} {c d : M} (hba : b ‚â§ a) (hdc : d ‚â§ c) : a ‚Ä¢ d + b ‚Ä¢ c ‚â§ a ‚Ä¢ c + b ‚Ä¢ d
(V : Type v) [category_theory.category V] [category_theory.monoidal_category V] (C : Type u‚ÇÅ) : Type (max u‚ÇÅ v w)
{L : first_order.language} {Œ± : Type u'} (r : L.relations 2) (t‚ÇÅ t‚ÇÇ : L.term Œ±) : L.formula Œ±
(Œ± : Type u_1) [pseudo_emetric_space Œ±] : Œ± ‚âÉ·µ¢ Œ±
(step : expr ‚Üí tactic (expr √ó expr)) (loc : interactive.loc) : tactic unit
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [normalization_monoid Œ±] [decidable_eq Œ±] (h : ‚àÄ (a b : Œ±), ‚àÉ (c : Œ±), ‚àÄ (d : Œ±), d ‚à£ a ‚àß d ‚à£ b ‚Üî d ‚à£ c) : normalized_gcd_monoid Œ±
{Œ± : Type u_1} [linear_ordered_ring Œ±] : Œ± ‚Üí*‚ÇÄ sign_type
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (i : D ‚•§ C) [category_theory.limits.has_finite_products C] [category_theory.cartesian_closed C] [category_theory.reflective i] (h : Œ† (A : C), i ‚ãô category_theory.exp A ‚ãô category_theory.left_adjoint i ‚ãô i ‚âÖ i ‚ãô category_theory.exp A) : category_theory.exponential_ideal i
(n : ‚Ñï) : tactic unit
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M ‚Üí+ P} {T : add_submonoid P} {Q : Type u_4} [add_comm_monoid Q] (hg : ‚àÄ (y : ‚Ü•S), ‚áëg ‚Üëy ‚àà T) (k : T.localization_map Q) {x y : M} (h : ‚áë(f.to_map) x = ‚áë(f.to_map) y) : ‚áë(k.to_map) (‚áëg x) = ‚áë(k.to_map) (‚áëg y)
{R : Type u_1} {S : Type u_2} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] [semiring S] [has_scalar S M] (f : R ‚Üí+* S) (hf : function.surjective ‚áëf) (hsmul : ‚àÄ (c : R) (x : M), ‚áëf c ‚Ä¢ x = c ‚Ä¢ x) : module S M
(C : Type u) [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] [category_theory.has_projective_resolutions C] : C ‚•§ homotopy_category C (complex_shape.down ‚Ñï)
(Œ± : Type u_1) (Œ≤ : Type u_2) [topological_space Œ±] [topological_space Œ≤] (b : Œ≤) : C(Œ±, Œ≤ √ó Œ±)
{C : Type u} [category_theory.category C] (X : category_theory.with_initial C) : X.hom X
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] : add_hom M N ‚âÉ add_hom M·µÉ·µí·µñ N·µÉ·µí·µñ
{R : Type u} [ring R] (s : subring R) : 1 ‚àà s
(R : Type u) [ring R] : Type u
{Œ± : Type u_1} {M : Type u_5} [has_zero M] : has_coe_to_fun (Œ± ‚Üí‚ÇÄ M) (Œª (_x : Œ± ‚Üí‚ÇÄ M), Œ± ‚Üí M)
(C : Type (u‚ÇÅ+1)) [category_theory.large_category C] [category_theory.preadditive C] [category_theory.limits.has_finite_biproducts C] : category_theory.Mat_ C ‚âå C
{cd : fin 2 ‚Üí ‚Ñ§} (hcd : is_coprime (cd 0) (cd 1)) : matrix (fin 2) (fin 2) ‚Ñù ‚âÉ‚Çó[‚Ñù] matrix (fin 2) (fin 2) ‚Ñù
{A : Type u_5} [has_add A] : subsemigroup (multiplicative A) ‚âÉo add_subsemigroup A
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (a : ulift Œ±) : ulift Œ≤
{Œ± : Type u} [random Œ±] : tactic (stream Œ±)
(Œ± : Type u) [inhabited Œ±] [decidable_eq Œ±] : Œ£ (Œ≤ : Type u), Œ± ‚âÉ option Œ≤
(p : ‚Ñï) {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (r : R) (n : ‚Ñï) : ‚áë(witt_vector.ghost_component n) (‚áë(witt_vector.teichmuller p) r) = r ^ p ^ n
(R : Type u_2) (A : Type u_3) [comm_semiring R] [non_unital_semiring A] [module R A] [is_scalar_tower R A A] [smul_comm_class R A A] : unitization R A ‚Üí‚Çê[R] R
{Œπ : Type u} (f : Œπ ‚Üí cardinal) : cardinal
{Œ± : Type u_1} [has_mul Œ±] (a : Œ±) (s : set Œ±) : set Œ±
{n : Type u_3} {Œ± : Type v} (A : matrix n n Œ±) (i : n) : Œ±
{G H : AddCommGroup} (f : G ‚ü∂ H) : category_theory.limits.kernel f ‚âÖ AddCommGroup.of ‚Ü•(add_monoid_hom.ker f)
{Œ± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {c : ‚Ñù} {f : Œ± ‚Üí E} {g' : Œ± ‚Üí F'} {l : filter Œ±} : asymptotics.is_O_with c l f g' ‚Üí asymptotics.is_O_with c l f (Œª (x : Œ±), -g' x)
{n : ‚Ñï} (f : pSet.resp n) {s : arity Set n} (H : pSet.resp.eval n f = s) : pSet.definable n s
{Œ± : Type u} (s‚ÇÅ s‚ÇÇ : seq Œ±) : seq Œ±
{Œ± : Type u} {F : Œ±·µê·µí·µñ ‚Üí Sort v} (h : Œ† (X : Œ±), F (mul_opposite.op X)) (X : Œ±·µê·µí·µñ) : F X
{Œ± : Type u_1} {R : Type u_2} {l : filter Œ±} {f : Œ± ‚Üí R} {r : R} [linear_ordered_semiring R] [archimedean R] (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Œª (x : Œ±), r * f x) l filter.at_top
{R : Type u_4} {S : Type u_5} [has_mul R] [has_add R] [has_mul S] [has_add S] {f g : R ‚âÉ+* S} (h : ‚àÄ (x : R), ‚áëf x = ‚áëg x) : f = g
(p t : pexpr) (h : option pexpr) (n : list name) : tactic unit
{Œπ : Type u_1} {R : Type u_2} [semiring R] {Œ≤‚ÇÅ : Œπ ‚Üí Type u_7} {Œ≤‚ÇÇ : Œπ ‚Üí Type u_8} [Œ† (i : Œπ), add_comm_monoid (Œ≤‚ÇÅ i)] [Œ† (i : Œπ), add_comm_monoid (Œ≤‚ÇÇ i)] [Œ† (i : Œπ), module R (Œ≤‚ÇÅ i)] [Œ† (i : Œπ), module R (Œ≤‚ÇÇ i)] (f : Œ† (i : Œπ), Œ≤‚ÇÅ i ‚Üí‚Çó[R] Œ≤‚ÇÇ i) : (Œ†‚ÇÄ (i : Œπ), Œ≤‚ÇÅ i) ‚Üí‚Çó[R] Œ†‚ÇÄ (i : Œπ), Œ≤‚ÇÇ i
{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (P : matrix n n R) (h : invertible P) : matrix n n R ‚âÉ‚Çó‚ÅÖR‚ÅÜ matrix n n R
 : category_theory.limits.walking_cospan·µí·µñ ‚âå category_theory.limits.walking_span
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ‚ü∂ Y} {P : C} {Œπ Œπ' : P ‚ü∂ X} {w : Œπ ‚â´ f = 0} (h : Œπ = Œπ') : category_theory.limits.kernel_fork.of_Œπ Œπ w ‚âÖ category_theory.limits.kernel_fork.of_Œπ Œπ' _
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [metric_space Œ≤] [has_zero Œ≤] (f : zero_at_infty_continuous_map Œ± Œ≤) : bounded_continuous_function Œ± Œ≤
{Œ± : Type u_1} (ùíú : finset (finset Œ±)) (r : ‚Ñï) : finset (finset Œ±)
{H : Type u_1} [comm_group H] : H ‚âÉ* abelianization H
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (P : C ‚Üí Prop) : Type
(n : ‚Ñï) : Type (u_1+1)
{J : Type u‚ÇÅ} [category_theory.category J] [nonempty J] (h : ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚Üí Œ±), (‚àÄ {j‚ÇÅ j‚ÇÇ : J}, (j‚ÇÅ ‚ü∂ j‚ÇÇ) ‚Üí F j‚ÇÅ = F j‚ÇÇ) ‚Üí ‚àÄ (j j' : J), F j = F j') : category_theory.is_connected J
 : linarith.linexp ‚Üí linarith.linexp ‚Üí ordering
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} [subsingleton Œπ] (p : Œπ ‚Üí P) : affine_independent k p
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] {U : C} (R : category_theory.presieve U) (P : C·µí·µñ ‚•§ A) [category_theory.limits.has_products A] [category_theory.limits.has_pullbacks C] : category_theory.presheaf.first_obj R P ‚ü∂ category_theory.presheaf.second_obj R P
{G : Type u_1} [add_group G] (H : add_subgroup G) : has_zero ‚Ü•H
{R‚ÇÇ : Type u_5} {M‚ÇÇ : Type u_6} [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {B : bilin_form R‚ÇÇ M‚ÇÇ} : B.nondegenerate ‚Üî (‚áëbilin_form.to_lin B).ker = ‚ä•
(ic : tactic.instance_cache) (a b : expr) (na nb : ‚Ñö) : tactic (tactic.instance_cache √ó expr)
{L : first_order.language} {M : Type u_3} [L.Structure M] : has_top (L.elementary_substructure M)
{Œ± : Type u_1} (t : tactic_result Œ±) : tactic Œ±
{G : Type u_1} [add_group G] {k : set G} {p : G ‚Üí G ‚Üí Prop} {x y : G} (hx : x ‚àà add_subgroup.closure k) (hy : y ‚àà add_subgroup.closure k) (Hk : ‚àÄ (x : G), x ‚àà k ‚Üí ‚àÄ (y : G), y ‚àà k ‚Üí p x y) (H1_left : ‚àÄ (x : G), p 0 x) (H1_right : ‚àÄ (x : G), p x 0) (Hmul_left : ‚àÄ (x‚ÇÅ x‚ÇÇ y : G), p x‚ÇÅ y ‚Üí p x‚ÇÇ y ‚Üí p (x‚ÇÅ + x‚ÇÇ) y) (Hmul_right : ‚àÄ (x y‚ÇÅ y‚ÇÇ : G), p x y‚ÇÅ ‚Üí p x y‚ÇÇ ‚Üí p x (y‚ÇÅ + y‚ÇÇ)) (Hinv_left : ‚àÄ (x y : G), p x y ‚Üí p (-x) y) (Hinv_right : ‚àÄ (x y : G), p x y ‚Üí p x (-y)) : p x y
(e : environment) (nm : name) (type lhs rhs : expr) (args : list expr) (univs : list name) (must_be_str : bool) (cfg : simps_cfg) (todo : list string) (to_apply : list ‚Ñï) : tactic unit
(D : algebraic_geometry.LocallyRingedSpace.glue_data) : algebraic_geometry.SheafedSpace.glue_data CommRing
(K : Type u) [field K] (V : FinVect K) : FinVect K
 : Preorder ‚•§ PartialOrder
{Œ± : Type u_1} (l : list Œ±) : list (list Œ±)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G : J ‚•§ C} {s : category_theory.limits.cocone F} (P : category_theory.limits.is_colimit s) (t : category_theory.limits.cocone G) (Œ± : F ‚ü∂ G) : s.X ‚ü∂ t.X
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {s‚ÇÅ : setoid Œ±} {s‚ÇÇ : setoid Œ≤} (f : Œ± ‚Üí Œ≤) (h : (setoid.r ‚áí setoid.r) f f) : quotient s‚ÇÅ ‚Üí quotient s‚ÇÇ
 : expr ‚Üí list name ‚Üí expr
{R A B : CommRing} (f : R ‚ü∂ A) (g : R ‚ü∂ B) : category_theory.limits.pushout_cocone f g
{Œπ : Type u_1} (c : complex_shape Œπ) (i : Œπ) : option {j // c.rel i j}
{R : Type u_1} {S : Type u_2} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S] (f : R ‚Üí+ S) : (‚àÄ (x y : R), ‚áëf (x * y) = ‚áëf x * ‚áëf y) ‚Üî add_monoid_hom.mul.compr‚ÇÇ f = (add_monoid_hom.mul.comp f).compl‚ÇÇ f
 : structure_instance_info ‚Üí pexpr
(n m : ‚Ñï) : list ‚Ñï
{M : Type u_1} [has_add M] (r : M ‚Üí M ‚Üí Prop) : add_con_gen r = has_Inf.Inf {s : add_con M | ‚àÄ (x y : M), r x y ‚Üí ‚áës x y}
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_semigroup Œ±] [add_comm_semigroup Œ≤] {f g : Œ± ‚Üí Œ≤} (hf : is_add_hom f) (hg : is_add_hom g) : is_add_hom (Œª (a : Œ±), f a + g a)
(Œ± : Sort u_1) [unique Œ±] : Œ± ‚âÉ punit
{R : Type u} [semiring R] {S : Type v} [semiring S] {f : R ‚Üí+* S} [nontrivial S] {p : polynomial S} (hlifts : p ‚àà polynomial.lifts f) (hp : p.monic) : ‚àÉ (q : polynomial R), polynomial.map f q = p ‚àß q.degree = p.degree ‚àß q.monic
{a : ‚Ñï} : ‚Ñ§
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÅ) [category_theory.category D] : C ‚•§ C ‚äï D
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (hf : ‚àÄ (x y : M), add_commute (‚áëf x) (‚áëf y)) : add_hom M N·µÉ·µí·µñ
 : native.rb_set (list name) ‚Üí list name
{G : Type u_1} [group G] {H : subgroup G} {A : Type u_2} [comm_group A] (œï : ‚Ü•H ‚Üí* A) [fintype (G ‚ß∏ H)] : G ‚Üí* A
{Œ± : Type u_1} (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù) (dist_self : ‚àÄ (x : Œ±), dist x x = 0) (dist_comm : ‚àÄ (x y : Œ±), dist x y = dist y x) (dist_triangle : ‚àÄ (x y z : Œ±), dist x z ‚â§ dist x y + dist y z) : uniform_space.core Œ±
{X : Type u} {Œ± : Type v} [topological_space X] [linear_order Œ±] [topological_space Œ±] [order_closed_topology Œ±] [preconnected_space X] {a b : X} {f g : X ‚Üí Œ±} (hf : continuous f) (hg : continuous g) (ha : f a ‚â§ g a) (hb : g b ‚â§ f b) : ‚àÉ (x : X), f x = g x
(n : interactive.parse (optional lean.parser.small_nat)) (t : tactic.interactive.itactic) : tactic unit
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J·µí·µñ ‚•§ C·µí·µñ} (c : category_theory.limits.cocone F) : category_theory.limits.cone F.unop
 : environment ‚Üí module_info ‚Üí environment
(A : Type u_12) (B : Type u_13) [has_add A] [has_add B] : Type (max u_12 u_13)
(Œ± : Type u) {Œ≤ : Type v} [group Œ±] [mul_action Œ± Œ≤] (b : Œ≤) : ‚Ü•(mul_action.orbit Œ± b) √ó ‚Ü•(mul_action.stabilizer Œ± b) ‚âÉ Œ±
(L : first_order.language) : Type (max u v)
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} (hf : monotone_on f s) (hs : s ‚àà nhds_within a (set.Iic a)) (hfs : ‚àÄ (b : Œ≤), b < f a ‚Üí (‚àÉ (c : Œ±) (H : c ‚àà s), f c ‚àà set.Ioo b (f a))) : continuous_within_at f (set.Iic a) a
(l : list ‚Ñï) (h : ‚àÄ (p : ‚Ñï), p ‚àà l ‚Üí nat.prime p) : prime_multiset
{Œ± : Type u} (f : filter Œ±) : Prop
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí option Œ±
{Œ± : Type u} : Œ± √ó list Œ± √ó Œ± √ó list Œ± ‚Üí Œ±
(i : ‚Ñ§) (t : omega.term) : omega.eqelim omega.term
{ùïú : Type u_1} {E : Type u_3} {F : Type u_4} [comm_ring ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] [add_comm_group F] [module ùïú F] [topological_space F] [topological_add_group F] [has_continuous_const_smul ùïú F] (p : formal_multilinear_series ùïú E F) {m n : ‚Ñï} {v : fin m ‚Üí E} {w : fin n ‚Üí E} (h1 : m = n) (h2 : ‚àÄ (i : ‚Ñï) (him : i < m) (hin : i < n), v ‚ü®i, him‚ü© = w ‚ü®i, hin‚ü©) : ‚áë(p m) v = ‚áë(p n) w
(Œ± : Type u_2) [division_ring Œ±] [char_zero Œ±] : ‚Ñö ‚Üí+* Œ±
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J ‚Üí C) [category_theory.limits.has_biproduct f] (p : J ‚Üí Prop) [category_theory.limits.has_biproduct (subtype.restrict p f)] : ‚®Å subtype.restrict p f ‚ü∂ ‚®Å f
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : continuous_at f b) : has_deriv_at (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in a..u, f x) (f b) b
(Œ± : Type u) [uniform_space Œ±] : setoid Œ±
(m n : ‚Ñï+) : (m.gcd n).factor_multiset = m.factor_multiset ‚äì n.factor_multiset
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [ring ùïú] [add_comm_group E] [add_comm_group F] [module ùïú E] [module ùïú F] [topological_space E] [topological_space F] [topological_add_group E] [topological_add_group F] [has_continuous_const_smul ùïú E] [has_continuous_const_smul ùïú F] (p : formal_multilinear_series ùïú E F) (n : ‚Ñï) : continuous (p.partial_sum n)
(Œ± : Type u) [preorder Œ±] [nonempty Œ±] [no_min_order Œ±] : ‚àÉ (f : ‚Ñï ‚Üí Œ±), strict_anti f
(Œ± : Type u_1) : Type u_1
{Œ± : Type u} {Œ≥ : Type u_1} [topological_space Œ≥] (f : Œ± ‚Üí Œ≥) : ultrafilter Œ± ‚Üí Œ≥
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_coproducts C] : category_theory.under X ‚•§ (category_theory.coprod_monad X).algebra
{M : Type u} [monoid M] (u : MÀ£) (x : M) : semiconj_by ‚Üëu x (‚Üëu * x * ‚Üëu‚Åª¬π)
{Œπ : Type u} {f g : Œπ ‚Üí nnreal} {A B : nnreal} {p : ‚Ñù} (hp : 1 ‚â§ p) (hf : has_sum (Œª (i : Œπ), f i ^ p) (A ^ p)) (hg : has_sum (Œª (i : Œπ), g i ^ p) (B ^ p)) : ‚àÉ (C : nnreal), C ‚â§ A + B ‚àß has_sum (Œª (i : Œπ), (f i + g i) ^ p) (C ^ p)
 : num ‚Üí num ‚Üí num
 : Type
(R : Type u) [ring R] (X : Type v) [add_comm_group X] [module R X] : Module R
{Œ± : Type u_1} [comm_monoid Œ±] [decidable_rel has_dvd.dvd] (a b : Œ±) : enat
(es : list omega.ee) : omega.eqelim unit
{Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [ring Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) : Prop
{Œ± : Type u_1} [preorder Œ±] [decidable_rel has_le.le] (x : Œ±) (s : ordset Œ±) : bool
(Œ± : Sort u_1) : decidable_eq Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Type (max u v)
(K : Type u_1) [field K] [uniform_space K] : Prop
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A √ó B) A
(V : Type u_1) [quiver V] : Type (max u_1 v)
 : tactic format
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (f : Œ† (x : Œ±), Œ≤ x ‚Üí bool) (s : finmap Œ≤) : bool
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) : Mon
(z : ‚ÑÇ) : ‚Ñù
{R : Type u} {S : Type v} [ring R] [ring S] [fintype R] [decidable_eq S] (f : R ‚Üí+* S) : fintype ‚Ü•(f.range)
(Œ± : Type u_1) [has_le Œ±] : Œ± ‚âÉo Œ±
{f : bool ‚Üí bool ‚Üí bool} (hf : ‚àÄ (b b' : bool), f b b' = f b' b) (hf' : f bool.ff bool.ff = bool.ff) (n m : ‚Ñï) : nat.bitwise f n m = nat.bitwise f m n
 : interactive.parse tactic.rintro_parse ‚Üí tactic unit
{Œ± : Type u_1} [linear_order Œ±] : finset Œ± ‚Üí option Œ±
{S : Type v} [comm_ring S] (d : ‚Ñï) (y : S) : polynomial.eval (1 + y) (‚áë(polynomial.monomial d) (‚Üëd + 1)) - polynomial.eval y (‚áë(polynomial.monomial d) (‚Üëd + 1)) = (finset.range (d + 1)).sum (Œª (x_1 : ‚Ñï), ‚Üë((d + 1).choose x_1) * (‚Üëx_1 * y ^ (x_1 - 1)))
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] {a l' : Œ±} {s : set Œ±} (hl' : l' < a) : s ‚àà nhds_within a (set.Iio a) ‚Üî ‚àÉ (l : Œ±) (H : l ‚àà set.Iio a), set.Ioo l a ‚äÜ s
{ùíú : Type u_1} [category_theory.category ùíú] {A B C : ùíú} (f : A ‚ü∂ B) (g : B ‚ü∂ C) [category_theory.preadditive ùíú] : Prop
{Œ± : Type u} {L‚ÇÅ L‚ÇÇ L‚ÇÉ : list (Œ± √ó bool)} : free_group.red L‚ÇÅ L‚ÇÇ ‚Üí free_group.red L‚ÇÅ L‚ÇÉ ‚Üí relation.join free_group.red L‚ÇÇ L‚ÇÉ
(red : interactive.parse (optional (lean.parser.tk "!"))) : tactic unit
{n : Type u'} [fintype n] [decidable_eq n] {Œ± : Type u_1} [non_assoc_semiring Œ±] (v : n ‚Üí Œ±) [invertible v] : invertible (matrix.diagonal v)
(Œπ : Type u_1) [fintype Œπ] : measure_theory.measure.add_haar_measure (topological_space.positive_compacts.pi_Icc01 Œπ) = measure_theory.measure_space.volume
{X : Top} {x : ‚Ü•X} (p : path.homotopic.quotient x x) : fundamental_group ‚Ü•X x
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] [category_theory.limits.has_colimits_of_shape J C] (F : J ‚•§ K ‚•§ C) (k : K) : (category_theory.limits.colimit F).obj k ‚âÖ category_theory.limits.colimit (F ‚ãô (category_theory.evaluation K C).obj k)
{R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b) : is_left_regular (a * b)
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ‚Üë‚ä§ = set.univ
{J : Type u‚ÇÅ} [category_theory.category J] [category_theory.is_connected J] (r : J ‚Üí J ‚Üí Prop) (hr : equivalence r) (h : ‚àÄ {j‚ÇÅ j‚ÇÇ : J}, (j‚ÇÅ ‚ü∂ j‚ÇÇ) ‚Üí r j‚ÇÅ j‚ÇÇ) (j‚ÇÅ j‚ÇÇ : J) : r j‚ÇÅ j‚ÇÇ
{n k : ‚Ñï} : n < k ‚Üí n.desc_factorial k = 0
 : category_theory.limits.has_limits_of_size AddCommGroup
 : list ‚Ñï ‚Üí ‚Ñï ‚Üí list ‚Ñï
{Œ± : Type u_1} [monoid Œ±] (p : Œ±) : Prop
{t t' : Type u ‚Üí Type u} (eqv : Œ† (Œ± : Type u), t Œ± ‚âÉ t' Œ±) [functor t] {Œ± Œ≤ : Type u} (f : Œ± ‚Üí Œ≤) (x : t' Œ±) : t' Œ≤
{F : Type u ‚Üí Type u} [functor F] [q : qpf F] {Œ± : Type u} (g : F Œ± ‚Üí Œ±) : qpf.fix F ‚Üí Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [pred_order Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : monotone f) : pairwise (disjoint on Œª (n : Œ±), set.Ioo (f (order.pred n)) (f n))
(C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (f : M ‚Üí‚Çô* N) : subsemigroup N
{A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ} [category_theory.category A] [category_theory.category B] [category_theory.category C] {U : B ‚•§ C} {F : C ‚•§ B} (R : A ‚•§ B) (F' : C ‚•§ A) (adj‚ÇÅ : F ‚ä£ U) (adj‚ÇÇ : F' ‚ä£ R ‚ãô U) [category_theory.limits.has_reflexive_coequalizers A] [Œ† (X : B), category_theory.regular_epi (adj‚ÇÅ.counit.app X)] : B ‚•§ A
(X : Type u) : category_theory.projective X
(key : interactive.parse lean.parser.cur_pos) (slow_and_accurate : interactive.parse (optional (lean.parser.tk "?"))) (use_iota_eqn : interactive.parse (optional (lean.parser.tk "!"))) (no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (tgt : interactive.parse (optional (lean.parser.tk "using" *> interactive.types.texpr))) (cfg : interactive.parse (optional tactic.struct_inst)) : tactic unit
(renames : interactive.parse swap_args_parser) : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] [measurable_space Œ≥] : (Œ± √ó Œ≤) √ó Œ≥ ‚âÉ·µê Œ± √ó Œ≤ √ó Œ≥
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {s : set E} : unique_diff_on ùïú s ‚Üí unique_mdiff_on (model_with_corners_self ùïú E) s
{R : Type u_1} [comm_ring R] [is_domain R] (S : subgroup RÀ£) [fintype ‚Ü•S] : is_cyclic ‚Ü•S
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : ‚Üës ‚à© ‚Üë(affine_subspace.mk' p (s.direction)·óÆ) = {euclidean_geometry.orthogonal_projection_fn s p}
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : differentiable_on ‚Ñù f (interior D)) (hf'_nonneg : ‚àÄ (x : ‚Ñù), x ‚àà interior D ‚Üí 0 ‚â§ deriv f x) : monotone_on f D
(L : first_order.language) (L' : first_order.language) : first_order.language
{G : Type u_2} [group G] {H : subgroup G} [hH : H.normal] : G ‚Üí* mul_aut ‚Ü•H
{C : Type u} [category_theory.category C] (X : Top) (Z : C) : algebraic_geometry.PresheafedSpace C
{C : Type u} [category_theory.category C] (G : C) : Prop
{R : Type u_1} [comm_group_with_zero R] {f g : ‚Ñï ‚Üí R} (hf : ‚àÄ (n : ‚Ñï), 0 < n ‚Üí f n ‚â† 0) (hg : ‚àÄ (n : ‚Ñï), 0 < n ‚Üí g n ‚â† 0) : (‚àÄ (n : ‚Ñï), 0 < n ‚Üí n.divisors.prod (Œª (i : ‚Ñï), f i) = g n) ‚Üî ‚àÄ (n : ‚Ñï), 0 < n ‚Üí n.divisors_antidiagonal.prod (Œª (x : ‚Ñï √ó ‚Ñï), g x.snd ^ ‚áënat.arithmetic_function.moebius x.fst) = f n
{T : Type u} [category_theory.category T] {f g : category_theory.arrow T} (sq : f ‚ü∂ g) [category_theory.arrow.has_lift sq] : f.right ‚ü∂ g.left
(m : ‚Ñù) : ‚Ñù
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : (Œ£ (b : Œ≤), ‚Ü•(f ‚Åª¬π' {b})) ‚âÉ Œ±
(R : Type u_1) [add_comm_group R] [star_add_monoid R] : add_subgroup R
{n : ‚Ñï} {i‚ÇÅ i‚ÇÇ : fin (n + 1)} (h : i‚ÇÅ ‚â† i‚ÇÇ) : finset.univ.sum (Œª (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.reflection_circumcenter_weights_with_circumcenter i‚ÇÅ i‚ÇÇ i) = 1
(max : interactive.parse (lean.parser.pexpr std.prec.max)) (tac : tactic.interactive.itactic) : tactic unit
{X : Type u} [pseudo_metric_space X] {Œ¥ : ‚Ñù} {E : set X} : metric.thickening Œ¥ E = ‚ãÉ (x : X) (H : x ‚àà E), metric.ball x Œ¥
(R : Type u_3) (M : Type u_4) [add_comm_monoid M] [ring R] [fintype R] [module R M] : add_monoid.is_torsion M
(var : string) (Œ± : Type u) (Œ≤ : Œ± ‚Üí Prop) [slim_check.sampleable_ext Œ±] [Œ† (x : Œ±), slim_check.testable (Œ≤ x)] : slim_check.testable (slim_check.named_binder var (‚àÄ (x : Œ±), Œ≤ x))
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] (f : Œ± ‚Üí Œ≤) (c : Œ±) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : Œ± ‚Üí Œ≤ ‚Üí Prop) (t : finset Œ≤) (a : Œ±) [decidable_pred (r a)] : finset Œ≤
(ùïú : Type u_1) {A : Type u_2} [nondiscrete_normed_field ùïú] [normed_ring A] [normed_algebra ùïú A] [complete_space A] (a : A) : has_fpower_series_on_ball (Œª (z : ùïú), ring.inverse (1 - z ‚Ä¢ a)) (Œª (n : ‚Ñï), continuous_multilinear_map.mk_pi_field ùïú (fin n) (a ^ n)) 0 (‚Üë‚à•a‚à•‚Çä)‚Åª¬π
{Œ± : Type u_1} {Œ≤ : Type u_2} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [topological_space Œ≤] [nonempty Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : continuous f) (hlim : filter.tendsto f (filter.cocompact Œ≤) filter.at_bot) : ‚àÉ (x : Œ≤), ‚àÄ (y : Œ≤), f y ‚â§ f x
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] {J : Type v} [fintype J] [category_theory.limits.preserves_biproducts_of_shape J F] : category_theory.limits.preserves_colimits_of_shape (category_theory.discrete J) F
{R : Type v} [comm_ring R] {o : Type u_1} (M : matrix o o R) (b : o ‚Üí ‚Ñï) : Prop
{V : Type u_1} [inner_product_space ‚Ñù V] (x y : V) : inner_product_geometry.angle x (-y) = real.pi - inner_product_geometry.angle x y
{R : Type u_1} [comm_semiring R] {m : Type u_3} {n : Type u_4} [fintype n] [fintype m] [decidable_eq n] {M‚ÇÅ : Type u_5} {M‚ÇÇ : Type u_6} [add_comm_monoid M‚ÇÅ] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÅ] [module R M‚ÇÇ] (v‚ÇÅ : basis n R M‚ÇÅ) (v‚ÇÇ : basis m R M‚ÇÇ) : matrix m n R ‚âÉ‚Çó[R] M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ
{R : Type u_1} [left_cancel_semigroup R] (g : R) : is_left_regular g
(S T : set ‚Ñï+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] (C : Type w) [comm_ring C] [algebra A C] [algebra B C] [is_scalar_tower A B C] [hS : is_cyclotomic_extension S A B] [hT : is_cyclotomic_extension T B C] : is_cyclotomic_extension (S ‚à™ T) A C
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj
{x y z : ‚Ñ§} : pythagorean_triple x y z ‚Üî ‚àÉ (k m n : ‚Ñ§), (x = k * (m ^ 2 - n ^ 2) ‚àß y = k * (2 * m * n) ‚à® x = k * (2 * m * n) ‚àß y = k * (m ^ 2 - n ^ 2)) ‚àß (z = k * (m ^ 2 + n ^ 2) ‚à® z = -k * (m ^ 2 + n ^ 2))
(k : ‚Ñï) : nat.partrec.code ‚Üí ‚Ñï ‚Üí option ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} [decidable_eq Œ±] [fintype Œ±] [comm_monoid Œ≤] {Œ¥ : Œ± ‚Üí Type u_3} {t : Œ† (a : Œ±), finset (Œ¥ a)} (f : (Œ† (a : Œ±), a ‚àà finset.univ ‚Üí Œ¥ a) ‚Üí Œ≤) : (finset.univ.pi t).prod (Œª (x : Œ† (a : Œ±), a ‚àà finset.univ ‚Üí Œ¥ a), f x) = (fintype.pi_finset t).prod (Œª (x : Œ† (a : Œ±), Œ¥ a), f (Œª (a : Œ±) (_x : a ‚àà finset.univ), x a))
{G : Type u_1} [group G] {Œ± : Type u_4} [add_monoid Œ±] [distrib_mul_action G Œ±] (S : subgroup G) : distrib_mul_action ‚Ü•S Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [partial_order Œ±] [t : order_topology Œ±] {f g h : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±} (hg : filter.tendsto g b (nhds a)) (hh : filter.tendsto h b (nhds a)) (hgf : g ‚â§ f) (hfh : f ‚â§ h) : filter.tendsto f b (nhds a)
{Œ± : Type u_2} (F : Type u_7) (A : out_param (set Œ±)) (Œ≤ : out_param (Type u_8)) [add_comm_monoid Œ±] [add_comm_monoid Œ≤] (n : ‚Ñï) [fun_like F Œ± (Œª (_x : Œ±), Œ≤)] : Type
 : omega.nat.preform ‚Üí ‚Ñï
{R : Type u_1} [comm_ring R] (S : submonoid R) (P : Type u_2) [comm_ring P] [algebra R P] : ideal R ‚Üí+* fractional_ideal S P
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C] : category_theory.limits.has_binary_biproducts C
{Œ≤ : Type u_2} [comm_monoid Œ≤] (f : fin 0 ‚Üí Œ≤) : finset.univ.prod (Œª (i : fin 0), f i) = 1
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] [nontrivial E] {x : E} {K : set E} (hK : is_compact K) (hx : x ‚àà K) : ‚àÉ (y : E) (H : y ‚àà frontier K), metric.inf_dist x K·∂ú = has_dist.dist x y
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} [comm_ring R] [lie_ring L‚ÇÅ] [lie_algebra R L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÇ] : has_coe_to_fun (L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) (Œª (_x : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ), L‚ÇÅ ‚Üí L‚ÇÇ)
(Œ± : Type u_1) (Œ≤ : Type u_2) [denumerable Œ±] [denumerable Œ≤] : Œ± ‚âÉ Œ≤
{C : Type u‚ÇÅ} [category_theory.small_category C] (P : C·µí·µñ ‚•§ Type u‚ÇÅ) (j : (P.elements)·µí·µñ) : (category_theory.cocone_of_representable P).Œπ.app j = (category_theory.yoneda_sections_small ((category_theory.category_of_elements.œÄ P).left_op.obj j) (((category_theory.functor.const (P.elements)·µí·µñ).obj (category_theory.cocone_of_representable P).X).obj j)).inv (opposite.unop j).snd
{n : ‚Ñï} (c : fin n ‚Üí ‚ÑÇ) (R : fin n ‚Üí ‚Ñù) : (fin n ‚Üí ‚Ñù) ‚Üí fin n ‚Üí ‚ÑÇ
{Œ± : Type u_1} {m : Type u_1 ‚Üí Type u_2} [monad m] (x : m (option Œ±)) (y : m Œ±) : m Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] (f : Œ± ‚Üí Œ≤) (hf : measurable_embedding f) : Œ± ‚âÉ·µê ‚Ü•(set.range f)
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [semi_normed_group E] [normed_space ùïú E] {s : set E} (s_nhd : s ‚àà nhds 0) : metric.bounded (normed_space.polar ùïú s)
 : linter
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {x : ùïú} {L : filter ùïú} {f' : ùïú ‚ÜíL[ùïú] F} : has_fderiv_at_filter f f' x L ‚Üî has_deriv_at_filter f (‚áëf' 1) x L
 : ‚Ñö ‚Üí expr
{Œ± : Type u_1} : list Œ± ‚Üí list (list Œ±)
{ùïú : Type u_1} {V : Type u_2} {P : Type u_8} [normed_field ùïú] [semi_normed_group V] [normed_space ùïú V] [pseudo_metric_space P] [normed_add_torsor V P] : P ‚Üí·µÉ‚Å±[ùïú] P
{C : Type u} [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} {c : category_theory.limits.cofork f f} (h : category_theory.limits.is_colimit c) : category_theory.is_iso c.œÄ
{X : Type u_1} [topological_space X] {a b : X} (Œ≥ : path a b) {t‚ÇÄ t‚ÇÅ : ‚Ñù} (h : t‚ÇÄ ‚â§ t‚ÇÅ) : path (Œ≥.extend t‚ÇÄ) (Œ≥.extend t‚ÇÅ)
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) : category_theory.subobject X ‚âå category_theory.mono_over X
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b : Œ±} (ha : a < 0) (hb : b < 0) : a + b < 0
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} (x : F (Œ± ::: mvqpf.fix F Œ±)) : mvqpf.fix F Œ±
{M : Type u_1} [comm_monoid M] (S : submonoid M) : comm_monoid ‚Ü•S
{Œ± : Type u_1} [topological_space Œ±] {x : Œ±} {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] [has_continuous_add Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : lower_semicontinuous_at f x) (hg : lower_semicontinuous_at g x) : lower_semicontinuous_at (Œª (z : Œ±), f z + g z) x
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (s1 : wseq Œ±) (s2 : wseq Œ≤) : wseq Œ≥
(m : Type u_2) (n : Type u_3) (o : Type u_4) (Œ± : Type u_12) [add_zero_class Œ±] : matrix (m √ó o) (n √ó o) Œ± ‚Üí+ o ‚Üí matrix m n Œ±
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] [category_theory.limits.has_finite_products C] [category_theory.limits.has_finite_products D] (F : C ‚•§ D) [category_theory.cartesian_closed C] [category_theory.cartesian_closed D] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] {A A' : C} (f : A' ‚ü∂ A) : category_theory.exp_comparison F A ‚â´ category_theory.whisker_left F (category_theory.pre (F.map f)) = category_theory.whisker_right (category_theory.pre f) F ‚â´ category_theory.exp_comparison F A'
 : name ‚Üí expr ‚Üí tactic unit
(D : algebraic_geometry.Scheme.glue_data) : D.glued.to_LocallyRingedSpace ‚âÖ D.to_LocallyRingedSpace_glue_data.to_glue_data.glued
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) (i : E ‚âÉL[ùïú] F) : formal_multilinear_series ùïú F E
(Œ± : Type u_1) [fintype Œ±] [decidable_eq Œ±] : subgroup (equiv.perm Œ±)
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] {module_M : module R M} {module_M‚ÇÇ : module R‚ÇÇ M‚ÇÇ} {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} {f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] {g : M‚ÇÇ ‚Üí M} (h : function.left_inverse g ‚áëf) : M ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] ‚Ü•(f.range)
(e : expr) : tactic (list expr)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [normed_space ‚Ñù E] (p : E √ó E) : E √ó E ‚ÜíL[‚Ñù] ùïú
{Œ± : Type u} (L : list Œ±) {i j : ‚Ñï} (hi : i < L.length) (hj : i < j) : L.nth_le i hi = (list.take j L).nth_le i _
{Œ± : Type} (tactics : list (tactic Œ±)) : tactic (list Œ±)
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] [category_theory.limits.has_limits C] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.reflects_isomorphisms (category_theory.forget C)] {F G : Top.sheaf C X} (f : F ‚ü∂ G) [‚àÄ (x : ‚Ü•X), category_theory.is_iso ((Top.presheaf.stalk_functor C x).map f)] : category_theory.is_iso f
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] (x : ‚Ü•(projective_spectrum.Top ùíú)) : (algebraic_geometry.projective_spectrum.Proj.structure_sheaf ùíú).val.stalk x ‚ü∂ CommRing.of (homogeneous_localization ùíú (projective_spectrum.as_homogeneous_ideal x).to_ideal)
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X Y Z : C} (S : J.cover X) (f : Z ‚ü∂ Y) (g : Y ‚ü∂ X) : S.pullback (f ‚â´ g) ‚âÖ (S.pullback g).pullback f
{Œ± : Type u} [pseudo_metric_space Œ±] (x y : Œ±) : has_edist.edist x y = ‚Üë(has_nndist.nndist x y)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {R : Type u_6} [normed_ring R] [normed_algebra ùïú R] [complete_space R] (x : RÀ£) : has_fderiv_at ring.inverse (-‚áë(‚áë(continuous_linear_map.lmul_left_right ùïú R) ‚Üëx‚Åª¬π) ‚Üëx‚Åª¬π) ‚Üëx
{Œ± : Type u‚ÇÅ} {X Y : category_theory.discrete Œ±} (h : X.as = Y.as) : X ‚ü∂ Y
{m : Type u_2} {n : Type u_3} {Œ± : Type v} [has_star Œ±] (M : matrix m n Œ±) (i : m) (j : n) : M.conj_transpose j i = has_star.star (M i j)
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : module.dual R M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R
(ùïú : Type u_1) {E : Type u_2} [normed_linear_ordered_field ùïú] [normed_group E] [normed_space ùïú E] [strict_convex_space ùïú E] (x : E) (r : ‚Ñù) : strict_convex ùïú (metric.closed_ball x r)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) (h : s.sum (Œª (i : Œπ), w i) = 1) (b‚ÇÅ b‚ÇÇ : P) : ‚áë(s.weighted_vsub_of_point p b‚ÇÅ) w +·µ• b‚ÇÅ = ‚áë(s.weighted_vsub_of_point p b‚ÇÇ) w +·µ• b‚ÇÇ
{Œì : Type u_1} [inhabited Œì] (L R : turing.list_blank Œì) : turing.tape Œì
{C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} (H : X ‚âÖ Y) : Y.presheaf ‚âÖ H.hom.base _* X.presheaf
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {R : nnreal} {c : ‚ÑÇ} {f : ‚ÑÇ ‚Üí E} {s : set ‚ÑÇ} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c ‚ÜëR)) (hd : ‚àÄ (z : ‚ÑÇ), z ‚àà metric.ball c ‚ÜëR  s ‚Üí differentiable_at ‚ÑÇ f z) (hR : 0 < R) : has_fpower_series_on_ball f (cauchy_power_series f c ‚ÜëR) c ‚ÜëR
{Œ± : Type u_1} {E : Œ± ‚Üí Type u_2} {p : ennreal} [Œ† (i : Œ±), normed_group (E i)] {Œπ : Type u_3} {l : filter Œπ} [l.ne_bot] [fact (1 ‚â§ p)] {F : Œπ ‚Üí ‚Ü•(lp E p)} (hF : metric.bounded (set.range F)) {f : Œ† (a : Œ±), E a} (hf : filter.tendsto (id (Œª (i : Œπ), ‚áë(F i))) l (nhds f)) : mem_‚Ñìp f p
{Œ± : Type u_1} [preorder Œ±] [order_top Œ±] [locally_finite_order Œ±] (a : Œ±) : multiset Œ±
{Œ± : Type u_1} (f : Œ± ‚Üí Œ± ‚Üí Œ±) : option Œ± ‚Üí option Œ± ‚Üí option Œ±
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} (x y : (mvqpf.P F).M Œ±) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (A : Mon_ C) : Mod A ‚•§ C
(p : ‚Ñï) [hp : fact (nat.prime p)] : ‚Ñï ‚Üí mv_polynomial (fin 2 √ó ‚Ñï) ‚Ñ§
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) (j : J) : (category_theory.limits.types.limit_cone (F ‚ãô category_theory.forget AddMon)).X ‚Üí+ (F ‚ãô category_theory.forget AddMon).obj j
{Œ≥ : Type u_1} [U : uniform_space Œ≥] (m : metric_space Œ≥) (H : uniformity Œ≥ = uniformity Œ≥) : metric_space Œ≥
{R : Type u_1} {M : Type u_2} [comm_ring R] [topological_space R] [add_comm_group M] [module R M] (B : module_filter_basis R M) [topological_ring R] : has_continuous_smul R M
 : widget.tc subexpr empty
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) {A A' B B' : C} [category_theory.limits.has_binary_product A B] [category_theory.limits.has_binary_product A' B'] [category_theory.limits.has_binary_product (F.obj A) (F.obj B)] [category_theory.limits.has_binary_product (F.obj A') (F.obj B')] (f : A ‚ü∂ A') (g : B ‚ü∂ B') : F.map (category_theory.limits.prod.map f g) ‚â´ category_theory.limits.prod_comparison F A' B' = category_theory.limits.prod_comparison F A B ‚â´ category_theory.limits.prod.map (F.map f) (F.map g)
{G : Type u} [group G] : inhabited (group_filter_basis G)
{ùïú : Type u_1} {E : Type u} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] {s : set E} : ‚áë(convex_hull ùïú) s = ‚ãÉ (t : finset E) (hss : ‚Üët ‚äÜ s) (hai : affine_independent ùïú coe), ‚áë(convex_hull ùïú) ‚Üët
(C : Type u) [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] : category_theory.triangulated.triangle C ‚âå category_theory.triangulated.triangle C
{Œ± : Type u_2} {Œ≤ : Type u_3} [comm_monoid Œ±] [comm_monoid Œ≤] {A : set Œ±} {n : ‚Ñï} : has_one (A ‚Üí*[n] Œ≤)
{C : Type u} [category_theory.category C] : partial_order (category_theory.grothendieck_topology C)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : e.functor ‚ä£ e.inverse
{Œ± : Type u_1} : has_inf (setoid Œ±)
{G : Type u_1} [group G] {H : subgroup G} [decidable_eq G] {R S : finset G} (hR : ‚ÜëR ‚àà subgroup.right_transversals ‚ÜëH) (hR1 : 1 ‚àà R) (hS : subgroup.closure ‚ÜëS = ‚ä§) : subgroup.closure ‚Üë(finset.image (Œª (g : G), ‚ü®g * (‚Üë(subgroup.mem_right_transversals.to_fun hR g))‚Åª¬π, _‚ü©) (R * S)) = ‚ä§
{D : CompHaus} : Compactum_to_CompHaus.obj (Compactum.of_topological_space ‚Ü•D) ‚âÖ D
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (e : R ‚âÉ+* S) (s : subsemiring R) : ‚Ü•s ‚âÉ+* ‚Ü•(subsemiring.map e.to_ring_hom s)
{Œπ : Type u} {Œ≥ : Type w} {Œ≤ : Œπ ‚Üí Type v} [monoid Œ≥] [Œ† (i : Œπ), add_monoid (Œ≤ i)] [Œ† (i : Œπ), distrib_mul_action Œ≥ (Œ≤ i)] : has_scalar Œ≥ (Œ†‚ÇÄ (i : Œπ), Œ≤ i)
(x y : Set) : Prop
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_mono f] : category_theory.limits.is_limit (category_theory.limits.cone_of_split_mono f)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : is_scalar_tower R L L
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [nondiscrete_normed_field ùïÇ] [normed_comm_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] [char_zero ùïÇ] {x y : ùî∏} (hx : x ‚àà emetric.ball 0 (exp_series ùïÇ ùî∏).radius) (hy : y ‚àà emetric.ball 0 (exp_series ùïÇ ùî∏).radius) : exp ùïÇ (x + y) = exp ùïÇ x * exp ùïÇ y
{R : Type u} {S : Type v} [comm_ring R] [comm_ring S] {f : R ‚Üí+* S} (hf : function.surjective ‚áëf) : R ‚ß∏ f.ker ‚âÉ+* S
 : ‚Ñï ‚Üí expr ‚Üí tactic (tactic.rcases_patt √ó list expr)
{Œ± : Type u_1} (l : list Œ±) : list (list Œ±)
{G : Type u_1} [add_group G] [fintype G] (S : set G) (hS : S.nonempty) : add_subgroup G
(locat : interactive.parse interactive.types.location) : tactic unit
{G : Type u_1} [group G] [is_free_group G] : is_free_group.generators G ‚Üí G
{Œ± : Type u_1} [preorder Œ±] {a b : Œ±} (h : a ‚â§ b) : order_top ‚Ü•(set.Icc a b)
{Œπ : Type u_1} (M : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), monoid (M i)] : free_monoid (Œ£ (i : Œπ), M i) ‚Üí free_monoid (Œ£ (i : Œπ), M i) ‚Üí Prop
 : ‚ä•_ Type u ‚âÖ pempty
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M ‚Üí+ P} (hg : ‚àÄ (y : ‚Ü•S), is_add_unit (‚áëg ‚Üëy)) (z : N) : ‚áë(f.lift hg) z + ‚áëg ‚Üë((f.sec z).snd) = ‚áëg (f.sec z).fst
 : linter
{Œ± : Type u_1} [dec : decidable_eq Œ±] : regular_expression Œ± ‚Üí Œ± ‚Üí regular_expression Œ±
{Œì : Type u_1} {R : Type u_2} [ordered_cancel_add_comm_monoid Œì] {Œì' : Type u_3} [ordered_cancel_add_comm_monoid Œì'] [non_assoc_semiring R] (f : Œì ‚Üí+ Œì') (hfi : function.injective ‚áëf) (hf : ‚àÄ (g g' : Œì), ‚áëf g ‚â§ ‚áëf g' ‚Üî g ‚â§ g') : hahn_series Œì R ‚Üí+* hahn_series Œì' R
{V : Type u_1} [inner_product_space ‚Ñù V] {x : V} (hx : x ‚â† 0) : inner_product_geometry.angle x (-x) = real.pi
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {a : Œ±} {s : set Œ±} (h : f a = 1) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà has_insert.insert a s), f i)) = finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i))
{X Y : Mon} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ* ‚Ü•Y
{R : Type u_1} {M : Type u_2} [topological_space R] [division_ring R] [has_continuous_sub R] [add_comm_group M] [topological_space M] [has_continuous_add M] [module R M] [has_continuous_smul R M] (f : M ‚ÜíL[R] R) (hf : f ‚â† 0) : is_open_map ‚áëf
{Œ± : Type u_1} [pseudo_emetric_space Œ±] {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) (E : set Œ±) : bounded_continuous_function Œ± nnreal
{ùïú : Type u_1} [linear_ordered_field ùïú] {R : Type u_2} [comm_ring R] (abv : R ‚Üí ùïú) [is_absolute_value abv] : uniform_space.core R
{X : Type u_1} [topological_space X] (s : set X) (h‚ÇÅ : is_closed s) (h‚ÇÇ : is_compact s) : topological_space.opens (alexandroff X)
{Œ± : Type u_2} {Œ≤ : Type u_3} [linear_order Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (h_mono : strict_mono f) : Œ± ‚âÉo ‚Ü•(set.range f)
{Œ± : Type u} (s : seq Œ±) (h : ‚àÄ (n : ‚Ñï), ‚Ü•((s.nth n).is_some)) : stream Œ±
(n : ‚Ñï+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [ne_zero ‚Üë‚Üën] [is_cyclotomic_extension {n} K L] : polynomial.is_splitting_field K L (polynomial.cyclotomic ‚Üën K)
(k : Type u_1) (G : Type u_2) [comm_semiring k] [group G] [fintype G] [invertible ‚Üë(fintype.card G)] : monoid_algebra k G
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) {X : C} [category_theory.is_iso (h.unit.app X)] : category_theory.inv (L.map (h.unit.app X)) = h.counit.app (L.obj X)
{X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X) (x : X) : ‚Ñù
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {Œ± : Type u_1} [has_zero Œ±] [smul_with_zero A Œ±] (S : subalgebra R A) : smul_with_zero ‚Ü•S Œ±
 : category_theory.limits.has_limits_of_size CommGroup
{m : Type u_1} [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (M N : matrix m m R) : (M.mul N).det = (N.mul M).det
{ùïú : Type u_1} {E : Type u_2} [semi_normed_ring ùïú] [has_scalar ùïú E] {s t : set E} (hs : balanced ùïú s) (h : s ‚äÜ t) : s ‚äÜ balanced_core ùïú t
{C : Type u‚ÇÅ} [category_theory.category C] {B A : C} (f : A ‚ü∂ B) [category_theory.mono f] (X : category_theory.subobject B) (h : category_theory.subobject.mk f = X) : A ‚âÖ ‚ÜëX
(type has_zero has_one has_add : expr) : ‚Ñï ‚Üí expr
{R : Type u} [semiring R] {M : Type u_1} [ordered_add_comm_monoid M] [module R M] (S : submodule R M) : ordered_add_comm_monoid ‚Ü•S
(L R : list pgame) : pgame
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_finite_limits C
(n : ‚Ñï) : simplex_category
{G : Type u} {x y : G} [fintype G] [left_cancel_monoid G] (h : order_of x = order_of y) : ‚Ü•‚Üë(submonoid.powers x) ‚âÉ ‚Ü•‚Üë(submonoid.powers y)
{R‚ÇÅ : Type u_2} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_11} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} : has_add (M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)
{Œπ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] (u : Œπ ‚Üí set X) (s : set X) : Type (max u_1 u_2)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u_1} [category_theory.category E] {F G : C ‚•§ D} (H : D ‚•§ E) [category_theory.full H] [category_theory.faithful H] (i : F ‚ãô H ‚âÖ G ‚ãô H) : F ‚âÖ G
{Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} : measure_theory.analytic_set s ‚Üî ‚àÉ (Œ≤ : Type) (h : topological_space Œ≤) (h' : polish_space Œ≤) (f : Œ≤ ‚Üí Œ±), continuous f ‚àß set.range f = s
{R : Type u_2} [semiring R] : module R·µê·µí·µñ R
{Œ± : Type u_1} (g : generalized_continued_fraction Œ±) : seq Œ±
{M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ‚àà s) : powers a ‚äÜ s
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_equalizers C] {X' : C} (h : X' ‚ü∂ X) [category_theory.is_iso h] (f : X ‚ü∂ Y) [category_theory.limits.has_image f] : category_theory.limits.image_subobject (h ‚â´ f) = category_theory.limits.image_subobject f
{Œπ : Type u_1} (Œ± : Œπ ‚Üí Type u_2) (l : list Œπ) : Type (max u_2 u_3)
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} : a < b ‚Üí b < c ‚Üí a < c
(c : tactic.instance_cache) (n : ‚Ñï) : tactic (tactic.instance_cache √ó expr)
(Œ± : Type u_1) [lattice Œ±] [bounded_order Œ±] : Prop
{ùïú : Type u} [hnorm : nondiscrete_normed_field ùïú] {E : Type v} [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_smul ùïú E] {F' : Type x} [add_comm_group F'] [module ùïú F'] [topological_space F'] [topological_add_group F'] [has_continuous_smul ùïú F'] [complete_space ùïú] [t2_space E] [finite_dimensional ùïú E] (f : E ‚Üí‚Çó[ùïú] F') : continuous ‚áëf
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [decidable_eq Œ±] [normalization_monoid Œ±] [unique_factorization_monoid Œ±] (a : Œ±) : multiset Œ±
{Œ± : Type u} (t : tactic Œ±) : tactic unit
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) {A A' B B' : C} [category_theory.limits.has_binary_coproduct A B] [category_theory.limits.has_binary_coproduct A' B'] [category_theory.limits.has_binary_coproduct (F.obj A) (F.obj B)] [category_theory.limits.has_binary_coproduct (F.obj A') (F.obj B')] (f : A ‚ü∂ A') (g : B ‚ü∂ B') : category_theory.limits.coprod_comparison F A B ‚â´ F.map (category_theory.limits.coprod.map f g) = category_theory.limits.coprod.map (F.map f) (F.map g) ‚â´ category_theory.limits.coprod_comparison F A' B'
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ (w+1) (w'+1))
(h : expr) : tactic (expr √ó expr √ó option name)
{X Y : Type u} [add_semigroup X] [add_semigroup Y] (f : add_hom X Y) : AddSemigroup.of X ‚ü∂ AddSemigroup.of Y
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J ‚•§ C·µí·µñ) {c : category_theory.limits.cone F} (hc : category_theory.limits.is_limit c) : category_theory.limits.is_colimit (category_theory.limits.cocone_left_op_of_cone c)
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s : set Œ±} {a : Œ±} (hs : bdd_above s) (sne : s.nonempty) : has_Sup.Sup (has_insert.insert a s) = a ‚äî has_Sup.Sup s
{V : Type u} {G : simple_graph V} (G' : G.subgraph) (v : V) : set (sym2 V)
{Œ± : Type u_2} [mul_one_class Œ±] : Œ± ‚Üí* set Œ±
{Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : list Œ±} : l‚ÇÅ <:+ l‚ÇÇ ‚Üí l‚ÇÅ.reverse <+: l‚ÇÇ.reverse
 : tactic_state ‚Üí expr ‚Üí eformat
{G : Type u_1} [add_group G] [fintype G] : add_monoid.is_torsion G
{R : Type u_1} {M : Type u_2} {Œπ : Type u_5} [comm_semiring R] [add_comm_monoid M] [module R M] [decidable_eq Œπ] (b : basis Œπ R M) : M ‚Üí‚Çó[R] module.dual R M
{Œ± : Type u} {Œπ : Sort w} (r : Œ± ‚Üí Œ± ‚Üí Prop) (f : Œπ ‚Üí Œ±) : Prop
{Œπ : Type u_1} (p : ‚Ñù) [fact_one_le_p : fact (1 ‚â§ p)] (Œ± : Œπ ‚Üí Type u_3) [fintype Œπ] [Œ† (i : Œπ), emetric_space (Œ± i)] : emetric_space (pi_Lp p Œ±)
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} (h : metric.bounded s) : metric.bounded (closure s)
{G‚ÇÄ : Type u_2} {G‚ÇÄ' : Type u_4} [group_with_zero G‚ÇÄ] [has_zero G‚ÇÄ'] [has_mul G‚ÇÄ'] [has_one G‚ÇÄ'] [has_inv G‚ÇÄ'] [has_div G‚ÇÄ'] [has_pow G‚ÇÄ' ‚Ñï] [has_pow G‚ÇÄ' ‚Ñ§] (f : G‚ÇÄ' ‚Üí G‚ÇÄ) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ‚àÄ (x y : G‚ÇÄ'), f (x * y) = f x * f y) (inv : ‚àÄ (x : G‚ÇÄ'), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : G‚ÇÄ'), f (x / y) = f x / f y) (npow : ‚àÄ (x : G‚ÇÄ') (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : G‚ÇÄ') (n : ‚Ñ§), f (x ^ n) = f x ^ n) : group_with_zero G‚ÇÄ'
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (œÅV : representation k G V) : representation k G (module.dual k V)
 : pgame ‚Üí pgame ‚Üí Type (u+1)
{C : Type u‚ÇÅ} [category_theory.category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (S : category_theory.sieve X) : Type (max v‚ÇÅ u‚ÇÅ)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] {D : Type u_1} [category_theory.category D] [category_theory.preadditive D] {E : Type u_2} [category_theory.category E] [category_theory.preadditive E] (F : C ‚•§ D) [F.additive] (G : D ‚•§ E) [G.additive] : (F ‚ãô G).map_Mat_ ‚âÖ F.map_Mat_ ‚ãô G.map_Mat_
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (q : Œ† (i : fin (n + 1)), Œ± i) (i : fin n) : Œ± i.succ
{Œπ : Type u_1} (H : Œπ ‚Üí Type u_2) : Type (max u_1 u_2)
{Œπ : Type u_1} {R : Type u_2} {N : Type u_5} [dec_Œπ : decidable_eq Œπ] [semiring R] [add_comm_monoid N] [module R N] (p : Œπ ‚Üí submodule R N) : complete_lattice.independent p ‚Üî ‚àÄ (i : Œπ) (x : ‚Ü•(p i)) (v : Œ†‚ÇÄ (i : Œπ), ‚Ü•(p i)), ‚áë(‚áë(dfinsupp.lsum ‚Ñï) (Œª (i : Œπ), (p i).subtype)) (dfinsupp.erase i v) = ‚Üëx ‚Üí x = 0
 : Pointed_to_Bipointed_snd ‚ä£ Bipointed_to_Pointed_snd
{Œ± : Type u_1} {Œ≤ : Type u_2} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [topological_space Œ≤] {s : set Œ≤} {f : Œ≤ ‚Üí Œ±} (hf : continuous_on f s) (hsc : is_closed s) {x‚ÇÄ : Œ≤} (h‚ÇÄ : x‚ÇÄ ‚àà s) (hc : ‚àÄ·∂† (x : Œ≤) in filter.cocompact Œ≤ ‚äì filter.principal s, f x ‚â§ f x‚ÇÄ) : ‚àÉ (x : Œ≤) (H : x ‚àà s), ‚àÄ (y : Œ≤), y ‚àà s ‚Üí f y ‚â§ f x
(G H : AddCommGroup) : G ‚äû H ‚âÖ AddCommGroup.of (‚Ü•G √ó ‚Ü•H)
 : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
{A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ} [category_theory.category A] [category_theory.category B] [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] (Q : A ‚•§ B) (V : B ‚•§ D) (U : A ‚•§ C) (R : C ‚•§ D) (comm : U ‚ãô R ‚âÖ Q ‚ãô V) [category_theory.is_right_adjoint U] [category_theory.is_right_adjoint V] [category_theory.is_right_adjoint R] [Œ† (X : B), category_theory.regular_epi ((category_theory.adjunction.of_right_adjoint V).counit.app X)] [category_theory.limits.has_reflexive_coequalizers A] : category_theory.is_right_adjoint Q
{Œ± : Type u} {n : ‚Ñï} (f : fin n ‚Üí Œ±) : (list.of_fn f).length = n
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Œπ R M) {R' : Type u_9} [semiring R'] [module R' M] (f : R ‚âÉ+* R') (h : ‚àÄ (c : R) (x : M), ‚áëf c ‚Ä¢ x = c ‚Ä¢ x) : basis Œπ R' M
{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X : C·µí·µñ) : C ‚•§ Module (category_theory.End X)
(R : Type u_1) (R' : Type u_2) {E : Type u_3} {F : Type u_4} [ring R] [invertible 2] [add_comm_group E] [module R E] [ring R'] [invertible 2] [add_comm_group F] [module R' F] (f : E ‚Üí F) (h0 : f 0 = 0) (hm : ‚àÄ (x y : E), f (midpoint R x y) = midpoint R' (f x) (f y)) : E ‚Üí+ F
{E : Type u} [normed_group E] [normed_space ‚Ñù E] [complete_space E] (f g : ‚Ñù √ó ‚Ñù ‚Üí E) (f' g' : ‚Ñù √ó ‚Ñù ‚Üí (‚Ñù √ó ‚Ñù ‚ÜíL[‚Ñù] E)) (a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ : ‚Ñù) (s : set (‚Ñù √ó ‚Ñù)) (hs : s.countable) (Hcf : continuous_on f (set.interval a‚ÇÅ b‚ÇÅ √óÀ¢ set.interval a‚ÇÇ b‚ÇÇ)) (Hcg : continuous_on g (set.interval a‚ÇÅ b‚ÇÅ √óÀ¢ set.interval a‚ÇÇ b‚ÇÇ)) (Hdf : ‚àÄ (x : ‚Ñù √ó ‚Ñù), x ‚àà set.Ioo (linear_order.min a‚ÇÅ b‚ÇÅ) (linear_order.max a‚ÇÅ b‚ÇÅ) √óÀ¢ set.Ioo (linear_order.min a‚ÇÇ b‚ÇÇ) (linear_order.max a‚ÇÇ b‚ÇÇ)  s ‚Üí has_fderiv_at f (f' x) x) (Hdg : ‚àÄ (x : ‚Ñù √ó ‚Ñù), x ‚àà set.Ioo (linear_order.min a‚ÇÅ b‚ÇÅ) (linear_order.max a‚ÇÅ b‚ÇÅ) √óÀ¢ set.Ioo (linear_order.min a‚ÇÇ b‚ÇÇ) (linear_order.max a‚ÇÇ b‚ÇÇ)  s ‚Üí has_fderiv_at g (g' x) x) (Hi : measure_theory.integrable_on (Œª (x : ‚Ñù √ó ‚Ñù), ‚áë(f' x) (1, 0) + ‚áë(g' x) (0, 1)) (set.interval a‚ÇÅ b‚ÇÅ √óÀ¢ set.interval a‚ÇÇ b‚ÇÇ) measure_theory.measure_space.volume) : ‚à´ (x : ‚Ñù) in a‚ÇÅ..b‚ÇÅ, ‚à´ (y : ‚Ñù) in a‚ÇÇ..b‚ÇÇ, ‚áë(f' (x, y)) (1, 0) + ‚áë(g' (x, y)) (0, 1) = (((‚à´ (x : ‚Ñù) in a‚ÇÅ..b‚ÇÅ, g (x, b‚ÇÇ)) - ‚à´ (x : ‚Ñù) in a‚ÇÅ..b‚ÇÅ, g (x, a‚ÇÇ)) + ‚à´ (y : ‚Ñù) in a‚ÇÇ..b‚ÇÇ, f (b‚ÇÅ, y)) - ‚à´ (y : ‚Ñù) in a‚ÇÇ..b‚ÇÇ, f (a‚ÇÅ, y)
{Œ± : Type u_1} [partial_order Œ±] {f : Œ± ‚Üí Œ±} {p : Œ± ‚Üí Prop} {hf : ‚àÄ (x : Œ±), x ‚â§ f x} {hfp : ‚àÄ (x : Œ±), p (f x)} {hmin : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, x ‚â§ y ‚Üí p y ‚Üí f x ‚â§ y} {x : Œ±} (hx : p x) : x ‚àà (closure_operator.mk‚ÇÉ f p hf hfp hmin).closed
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : C(X, Y)) : Prop
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {f g : X ‚ü∂ Y} {c : category_theory.limits.cokernel_cofork (f - g)} (i : category_theory.limits.is_colimit c) : category_theory.limits.is_colimit (category_theory.preadditive.cofork_of_cokernel_cofork c)
{C : Type u‚ÇÅ} [category_theory.category C] {X‚ÇÅ‚ÇÅ X‚ÇÅ‚ÇÇ X‚ÇÅ‚ÇÉ X‚ÇÇ‚ÇÅ X‚ÇÇ‚ÇÇ X‚ÇÇ‚ÇÉ : C} {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ‚ÇÉ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÉ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ} {v‚ÇÅ‚ÇÉ : X‚ÇÅ‚ÇÉ ‚ü∂ X‚ÇÇ‚ÇÉ} (s : category_theory.is_pushout (h‚ÇÅ‚ÇÅ ‚â´ h‚ÇÅ‚ÇÇ) v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÉ (h‚ÇÇ‚ÇÅ ‚â´ h‚ÇÇ‚ÇÇ)) (p : h‚ÇÅ‚ÇÇ ‚â´ v‚ÇÅ‚ÇÉ = v‚ÇÅ‚ÇÇ ‚â´ h‚ÇÇ‚ÇÇ) (t : category_theory.is_pushout h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ) : category_theory.is_pushout h‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÉ h‚ÇÇ‚ÇÇ
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [is_R_or_C ùïú] [inner_product_space ùïú E] [inner_product_space ùïú F] [inner_product_space ùïú G] [complete_space E] [complete_space G] [complete_space F] (A : F ‚ÜíL[ùïú] G) (B : E ‚ÜíL[ùïú] F) : ‚áëcontinuous_linear_map.adjoint (A.comp B) = (‚áëcontinuous_linear_map.adjoint B).comp (‚áëcontinuous_linear_map.adjoint A)
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {J : Type v} [category_theory.small_category J] [category_theory.fin_category J] (F : J ‚•§ C) : nonempty (category_theory.limits.cone F)
{Œπ : Type u_1} {ùïú : Type u_3} [is_R_or_C ùïú] {E : Type u_4} [inner_product_space ùïú E] [fintype Œπ] : has_coe_to_fun (orthonormal_basis Œπ ùïú E) (Œª (_x : orthonormal_basis Œπ ùïú E), Œπ ‚Üí E)
{ùïú : Type u} [hnorm : nondiscrete_normed_field ùïú] {E : Type v} [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_smul ùïú E] {F' : Type x} [add_comm_group F'] [module ùïú F'] [topological_space F'] [topological_add_group F'] [has_continuous_smul ùïú F'] [complete_space ùïú] [t2_space E] [finite_dimensional ùïú E] : (E ‚Üí‚Çó[ùïú] F') ‚âÉ‚Çó[ùïú] E ‚ÜíL[ùïú] F'
{L : first_order.language} {F : Type u_1} {M : Type u_2} {N : Type u_3} [L.Structure M] [L.Structure N] [embedding_like F M N] [first_order.language.strong_hom_class L F M N] : F ‚Üí L.embedding M N
{Œ± : Type u_1} {p : finset Œ± ‚Üí Prop} [decidable_eq Œ±] (s : finset Œ±) (h‚ÇÅ : p ‚àÖ) (h‚ÇÇ : ‚àÄ ‚¶Éa : Œ±‚¶Ñ {s : finset Œ±}, a ‚àâ s ‚Üí p s ‚Üí p (has_insert.insert a s)) : p s
(R : Type u_1) (M : Type u_2) [comm_ring R] [topological_space R] [add_comm_group M] [module R M] : Type u_2
{s : ‚Ñù} (h : 0 < s) : measure_theory.integrable_on (Œª (x : ‚Ñù), real.exp (-x) * x ^ (s - 1)) (set.Ioi 0) measure_theory.measure_space.volume
{Œπ : Type u_1} (R : Type u_3) {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] (x : Œπ ‚Üí A) : Prop
 : Type
{Œ± : Type u_2} [subtraction_monoid Œ±] {a : Œ±} : even a ‚Üí even (-a)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) : Prop
 : Set ‚Üí Set
{R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (s : R) (x y : A) : x * s ‚Ä¢ y = s ‚Ä¢ (x * y)
{C : Type u} [category_theory.category C] {F‚ÇÅ F‚ÇÇ : C·µí·µñ ‚•§ Type v} (Œ± : F‚ÇÅ ‚ü∂ F‚ÇÇ) : (category_theory.category_of_elements.map Œ±).op ‚ãô category_theory.category_of_elements.to_costructured_arrow F‚ÇÇ = category_theory.category_of_elements.to_costructured_arrow F‚ÇÅ ‚ãô category_theory.costructured_arrow.map Œ±
(R : Type u1) [comm_semiring R] (M : Type u2) [add_comm_monoid M] [module R M] : tensor_algebra R M ‚Üí tensor_algebra R M ‚Üí Prop
{Œ± : Type u} {L : list (Œ± √ó bool)} [decidable_eq Œ±] : free_group.reduce (free_group.reduce L) = free_group.reduce L
(X : Type u_3) [topological_space X] : Type u_3
{E : Type u_1} [normed_group E] (f : ‚ÑÇ ‚Üí E) (c : ‚ÑÇ) (R : ‚Ñù) : Prop
(h : expr) (hs : expr_set) : tactic bool
(Œ± : Type u) : Type u
 : Type
{R : Type u} {a : R} [semiring R] {p : polynomial R} (h : p.leading_coeff * a ‚â† 0) : (p * ‚áëpolynomial.C a).nat_degree = p.nat_degree
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] {E : Type u‚ÇÉ} [category_theory.category E] [category_theory.monoidal_category E] {F G : category_theory.lax_monoidal_functor C D} {H K : category_theory.lax_monoidal_functor C E} (Œ± : category_theory.monoidal_nat_trans F G) (Œ≤ : category_theory.monoidal_nat_trans H K) : category_theory.monoidal_nat_trans (F.prod' H) (G.prod' K)
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] {X Y : C} [category_theory.limits.preserves_binary_biproduct X Y F] : category_theory.limits.preserves_limit (category_theory.limits.pair X Y) F
(H : Type u_5) [topological_space H] : Type u_5
{Œ± : Type u} {Œ≤ : Type v} (R : Œ± ‚Üí Œ≤ ‚Üí Prop) (s : wseq Œ±) (t : wseq Œ≤) : Prop
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] (e e' : topological_fiber_bundle.trivialization F proj) (H : disjoint e.base_set e'.base_set) : topological_fiber_bundle.trivialization F proj
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [preorder Œ±] [preorder Œ≤] [preorder Œ≥] (g : Œ≤ ‚Üío Œ≥) (f : Œ± ‚Üío Œ≤) : Œ± ‚Üío Œ≥
(p : ‚Ñï) [hp : fact (nat.prime p)] : witt_vector p (zmod p) ‚âÉ+* ‚Ñ§_[p]
{Œ± : Type u_2} [comm_monoid Œ±] : comm_monoid (set Œ±)
{Œ± : Type u_1} [decidable_eq Œ±] : equiv.perm (option Œ±) ‚âÉ option Œ± √ó equiv.perm Œ±
{Œ± : Type u} [monoid Œ±] : group Œ±À£
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type u} [category_theory.category J] [category_theory.limits.has_limits_of_shape J C] (R : D ‚•§ C) [category_theory.reflective R] : category_theory.limits.has_limits_of_shape J D
(_x : interactive.parse (lean.parser.tk "def_replacer")) : lean.parser unit
{R : Type u_1} [comm_ring R] (P : ideal (polynomial R)) : ((ideal.quotient.mk (ideal.map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) P)).comp polynomial.C).comp (ideal.quotient.mk (ideal.comap polynomial.C P)) = ((ideal.map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) P).quotient_map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) ideal.le_comap_map).comp ((ideal.quotient.mk P).comp polynomial.C)
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] (ùíú : finset (finset Œ±)) : finset (finset Œ±)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Type (max v u)) : category_theory.limits.colimit F ‚âÉ category_theory.limits.types.quot F
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (t‚ÇÅ t‚ÇÇ : ordnode Œ±) : bool
{m : Type ‚Üí Type v} [monad m] {Œ± : Type} (p : Œ± ‚Üí m bool) (xs : list Œ±) : m (option Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y Z : C} {f g : X ‚ü∂ Y} {h : Z ‚ü∂ X} (w : h ‚â´ f = h ‚â´ g) : category_theory.limits.is_limit (G.map_cone (category_theory.limits.fork.of_Œπ h w)) ‚âÉ category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ (G.map h) _)
(R : Type u) (L : Type v) {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (s : set M) : lie_submodule R L M
{C : Type u} [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} {Y' : C} {g : Y ‚ü∂ Y'} [category_theory.is_iso g] (F : category_theory.limits.mono_factorisation (f ‚â´ g)) : category_theory.limits.mono_factorisation f
{Œ± : Type u_1} [preorder Œ±] {a b : Œ±} : a ‚©ø b ‚Üí ‚áëorder_dual.to_dual b ‚©ø ‚áëorder_dual.to_dual a
{R : Type u_1} [comm_ring R] : lie_ring (fin 3 ‚Üí R)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [uniform_space Œ±] [uniform_space Œ≤] [locally_compact_space Œ±] [compact_space Œ≤] [separated_space Œ≤] [uniform_space Œ≥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {x : Œ±} {U : set Œ±} (hxU : U ‚àà nhds x) (hU : is_separated U) (h : continuous_on ‚Üøf (U √óÀ¢ set.univ)) : tendsto_uniformly f (f x) (nhds x)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} [metric_space Œ≤] [preorder Œπ] (f : Œπ ‚Üí Œ± ‚Üí Œ≤) (g : Œ± ‚Üí Œ≤) (n : ‚Ñï) (j : Œπ) : set Œ±
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] {G : C ‚•§ D} {K : category_theory.grothendieck_topology D} (A : Type u) [category_theory.category A] [category_theory.full G] [category_theory.faithful G] (H : category_theory.cover_dense K G) [category_theory.limits.has_limits A] : category_theory.Sheaf H.induced_topology A ‚âå category_theory.Sheaf K A
{Œ± : Type} (msg : string) (t : tactic Œ±) : tactic Œ±
{a : ‚Ñù} {l : filter ‚Ñù} {f f' g g' : ‚Ñù ‚Üí ‚Ñù} (hff' : ‚àÄ·∂† (x : ‚Ñù) in nhds a, has_deriv_at f (f' x) x) (hgg' : ‚àÄ·∂† (x : ‚Ñù) in nhds a, has_deriv_at g (g' x) x) (hg' : ‚àÄ·∂† (x : ‚Ñù) in nhds a, g' x ‚â† 0) (hfa : filter.tendsto f (nhds a) (nhds 0)) (hga : filter.tendsto g (nhds a) (nhds 0)) (hdiv : filter.tendsto (Œª (x : ‚Ñù), f' x / g' x) (nhds a) l) : filter.tendsto (Œª (x : ‚Ñù), f x / g x) (nhds_within a (set.univ  {a})) l
{R : Type u_2} [semiring R] : distrib_mul_action (R ‚Üí+* R) R
{p : ‚Ñù} : summable (Œª (n : ‚Ñï), (‚Üën ^ p)‚Åª¬π) ‚Üî 1 < p
{T : Type u} [category_theory.category T] {f g : category_theory.arrow T} (sq : f ‚ü∂ g) [category_theory.arrow.has_lift sq] : category_theory.arrow.lift_struct sq
(x : pgame) : (x * 1).equiv x
 : num ‚Üí ‚Ñï
{R : Type u} [semiring R] (p : polynomial R) : R
{Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {C : Sort u} (H0 : C) (H : Œ† (a : Œ±), p a ‚Üí C) : C
 : list (list ‚Ñï √ó omega.term) ‚Üí tactic (list ‚Ñï)
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (s : finset S) : ‚Ü•M
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≤' : Type u_4} {Œ≥ : Type u_5} {Œ¥ : Type u_7} {f : filter Œ±} {g : filter Œ≤} {m : Œ± ‚Üí Œ≤' ‚Üí Œ≥} {n : Œ≤ ‚Üí Œ≤'} {m' : Œ± ‚Üí Œ≤ ‚Üí Œ¥} {n' : Œ¥ ‚Üí Œ≥} (h_right_comm : ‚àÄ (a : Œ±) (b : Œ≤), m a (n b) = n' (m' a b)) : filter.map‚ÇÇ m f (filter.map n g) = filter.map n' (filter.map‚ÇÇ m' f g)
{Œ± : Type u} [pseudo_emetric_space Œ±] {x : Œ±} : emetric.diam {x} = 0
 : ‚ÑÇ ‚âÉ ‚Ñù √ó ‚Ñù
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} {Œ≥ : Type u_1} (s‚ÇÅ s‚ÇÇ : finmap Œ≤) (f : alist Œ≤ ‚Üí alist Œ≤ ‚Üí Œ≥) (H : ‚àÄ (a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : alist Œ≤), a‚ÇÅ.entries ~ a‚ÇÇ.entries ‚Üí b‚ÇÅ.entries ~ b‚ÇÇ.entries ‚Üí f a‚ÇÅ b‚ÇÅ = f a‚ÇÇ b‚ÇÇ) : Œ≥
(g : tactic.rewrite_search.graph) : tactic (tactic.rewrite_search.graph √ó expr √ó list tactic.rewrite_search.proof_unit)
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (N : Type u_2) [add_comm_monoid N] : Type (max u_1 u_2)
(P : ‚Ñï ‚Üí Prop) (n : ‚Ñï) : mv_polynomial ‚Ñï ‚Ñ§
(Œ± : Type u_1) [complete_semilattice_Inf Œ±] : complete_lattice Œ±
(R : Type u_1) {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_artinian_ring R] {A : set M} (hA : A.finite) : is_artinian R ‚Ü•(submodule.span R A)
{V : Type u_1} [inner_product_space ‚Ñù V] {x : V} (hx : x ‚â† 0) : inner_product_geometry.angle x x = 0
{Œ± : Type u} (s : wseq Œ±) : computation bool
(p n : ‚Ñï) : witt_vector.is_poly p (Œª (R : Type u_1) (_Rcr : comm_ring R), witt_vector.init n)
 : Type (u_1+1)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (M : Type w) [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [lie_algebra.is_nilpotent R L] [lie_module.is_nilpotent R L M] : lie_module.weight_space M 0 = ‚ä§
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (F : J ‚•§ C) (G : C ‚•§ D) [category_theory.reflects_isomorphisms G] [category_theory.limits.has_limit F] [category_theory.limits.preserves_limit F G] : category_theory.limits.reflects_limit F G
(hs : list expr) (is : expr_set) : tactic (list bool)
(t : expr) : tactic (list format)
{C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] [category_theory.limits.has_binary_product Q P] : (category_theory.limits.prod.braiding P Q).hom ‚â´ (category_theory.limits.prod.braiding Q P).hom = ùüô (P ‚®Ø Q)
(Œì‚ÇÄ : Type u_1) [linear_ordered_comm_group_with_zero Œì‚ÇÄ] : order_closed_topology Œì‚ÇÄ
{Œ± : Type u_1} {Œ≤ : Type u_2} (rŒ± : Œ± ‚Üí Œ± ‚Üí Prop) (rŒ≤ : Œ≤ ‚Üí Œ≤ ‚Üí Prop) : prod.rprod rŒ± rŒ≤ ‚â§ relation.trans_gen (relation.game_add rŒ± rŒ≤)
(ic : tactic.instance_cache) (a b : expr) (na nb : ‚Ñö) : tactic (tactic.instance_cache √ó expr)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) : category_theory.creates_limit F (category_theory.forget‚ÇÇ CommRing Ring)
{Œπ : Type u_1} {X : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), topological_space (X i)] {as bs : Œ† (i : Œπ), X i} (Œ≥ : Œ† (i : Œπ), path.homotopic.quotient (as i) (bs i)) : path.homotopic.quotient as bs
{Œ± : Type u} {Œ≤ : Type v} [semiring Œ±] [semiring Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
(Œ± : Type u) (Œ≤ : Type v) [add_monoid Œ±] [add_action Œ± Œ≤] (g : Œ±) : set Œ≤
{E : Type u_3} [semi_normed_group E] : filter.tendsto has_neg.neg (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
{Œ± : Type u} : nonempty (field Œ±) ‚Üî is_prime_pow (cardinal.mk Œ±)
(x : pgame) : (x * 0).equiv 0
{Œ± : Type u_1} : finset Œ± ‚Ü™o finset (option Œ±)
{ùïú : Type u_1} [is_R_or_C ùïú] [decidable_eq ùïú] {n : Type u_2} [fintype n] [decidable_eq n] {A : matrix n n ùïú} (hA : A.is_hermitian) : matrix n n ùïú
{Œπ : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [add_monoid Œπ] [monoid R] (A : Œπ ‚Üí S) [set_like.graded_monoid A] : submonoid R
{Œ± : Type u_1} {M : Type u_5} {G : Type u_9} [group G] [mul_action G Œ±] [add_comm_monoid M] (g : G) (f : Œ± ‚Üí‚ÇÄ M) (a : Œ±) : ‚áë(g ‚Ä¢ f) a = ‚áëf (g‚Åª¬π ‚Ä¢ a)
 : Type (u_1+1)
{Œ± : Type u_3} {Œ≤ : Type u_4} [has_inf Œ±] [has_inf Œ≤] : has_coe_to_fun (inf_hom Œ± Œ≤) (Œª (_x : inf_hom Œ± Œ≤), Œ± ‚Üí Œ≤)
(B : Type u‚ÇÅ) [category_theory.bicategory B] (C : Type u‚ÇÇ) [category_theory.bicategory C] : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ w‚ÇÅ w‚ÇÇ)
(p : ‚Ñï) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : ‚Ñï) : (fin (n + 1) ‚Üí k) ‚Üí (fin (n + 1) ‚Üí k) ‚Üí k
 : ‚àÄ·∂† (x : ‚Ñù) in residual ‚Ñù, liouville x
{S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c
{Œπ : Type u_1} {ùïú : Type u_2} [is_R_or_C ùïú] {E : Type u_3} [inner_product_space ùïú E] [cplt : complete_space E] {G : Œπ ‚Üí Type u_4} [Œ† (i : Œπ), inner_product_space ùïú (G i)] {V : Œ† (i : Œπ), G i ‚Üí‚Çó·µ¢[ùïú] E} (hV : orthogonal_family ùïú V) [‚àÄ (i : Œπ), complete_space (G i)] (hV' : (‚®Ü (i : Œπ), (V i).to_linear_map.range).topological_closure = ‚ä§) (W‚ÇÄ : Œ†‚ÇÄ (i : Œπ), G i) : ‚áë((hV.linear_isometry_equiv hV').symm) (W‚ÇÄ.sum (lp.single 2)) = W‚ÇÄ.sum (Œª (i : Œπ), ‚áë(V i))
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {s‚ÇÅ : setoid Œ±} {s‚ÇÇ : setoid Œ≤} {p : quotient s‚ÇÅ ‚Üí quotient s‚ÇÇ ‚Üí Prop} (q‚ÇÅ : quotient s‚ÇÅ) (q‚ÇÇ : quotient s‚ÇÇ) (h : ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ≤), p (quotient.mk' a‚ÇÅ) (quotient.mk' a‚ÇÇ)) : p q‚ÇÅ q‚ÇÇ
{Œπ : Type u_1} {M : Type u_3} [decidable_eq Œπ] [add_monoid Œπ] [semiring M] [Œ† (m : M), decidable (m ‚â† 0)] : add_monoid_algebra M Œπ ‚âÉ+* direct_sum Œπ (Œª (i : Œπ), M)
(ùïú : Type v) [is_R_or_C ùïú] {E : Type u} [normed_group E] [normed_space ùïú E] {x y : E} : x = y ‚Üî ‚àÄ (g : normed_space.dual ùïú E), ‚áëg x = ‚áëg y
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (u : E) {v : E} (hv : has_inner.inner v u = 0) : v ‚àà (submodule.span ùïú {u})·óÆ
(x : ‚ÑÇ) : has_strict_deriv_at complex.cos (-complex.sin x) x
{C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) (X‚ÇÄ : C) (f : X.obj (opposite.op (simplex_category.mk 0)) ‚ü∂ X‚ÇÄ) (w : ‚àÄ (i : simplex_category) (g‚ÇÅ g‚ÇÇ : simplex_category.mk 0 ‚ü∂ i), X.map g‚ÇÅ.op ‚â´ f = X.map g‚ÇÇ.op ‚â´ f) : category_theory.simplicial_object.augmented C
(u : ‚Ñï ‚Üí ‚Ñù) (l : ‚Ñù) (hmono : monotone u) (c : ‚Ñï ‚Üí ‚Ñù) (cone : ‚àÄ (k : ‚Ñï), 1 < c k) (clim : filter.tendsto c filter.at_top (nhds 1)) (hc : ‚àÄ (k : ‚Ñï), filter.tendsto (Œª (n : ‚Ñï), u ‚åäc k ^ n‚åã‚Çä / ‚Üë‚åäc k ^ n‚åã‚Çä) filter.at_top (nhds l)) : filter.tendsto (Œª (n : ‚Ñï), u n / ‚Üën) filter.at_top (nhds l)
 : linter
{E : Type u_1} [add_comm_group E] [has_norm E] (C : normed_group.core E) : semi_normed_group.core E
(tac : tactic.interactive.itactic) : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {p : filter Œπ} [topological_space Œ±] (h : tendsto_uniformly_on F f p s) (hc : ‚àÄ·∂† (n : Œπ) in p, continuous_on (F n) s) [p.ne_bot] : continuous_on f s
{R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ‚âÉ+* S) : ‚Üë‚Üëf = ‚Üëf
{n m : simplex_category} {f : n ‚ü∂ m} : category_theory.epi f ‚Üî function.surjective ‚áë(simplex_category.hom.to_order_hom f)
 : Type (u+1)
{Œ± : Type u_2} [has_add Œ±] {a : Œ±} : even a ‚Üí (‚àÉ (b : Œ±), a = bit0 b)
(_x : interactive.parse (lean.parser.tk "#lint_all")) : lean.parser unit
{C : Type u} [category_theory.category C] {F G : category_theory.limits.walking_parallel_pair ‚•§ C} (zero : F.obj category_theory.limits.walking_parallel_pair.zero ‚âÖ G.obj category_theory.limits.walking_parallel_pair.zero) (one : F.obj category_theory.limits.walking_parallel_pair.one ‚âÖ G.obj category_theory.limits.walking_parallel_pair.one) (left : F.map category_theory.limits.walking_parallel_pair_hom.left ‚â´ one.hom = zero.hom ‚â´ G.map category_theory.limits.walking_parallel_pair_hom.left) (right : F.map category_theory.limits.walking_parallel_pair_hom.right ‚â´ one.hom = zero.hom ‚â´ G.map category_theory.limits.walking_parallel_pair_hom.right) : F ‚âÖ G
{K : Type u_1} [field K] {Œì‚ÇÄ : Type u_2} [linear_ordered_comm_group_with_zero Œì‚ÇÄ] [hv : valued K Œì‚ÇÄ] : completable_top_field K
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 : P) (g : G) : p1 -·µ• (g +·µ• p2) = p1 -·µ• p2 - g
{l r : Type u_1} {xL : l ‚Üí pgame} {xR : r ‚Üí pgame} [is_empty l] [is_empty r] : (pgame.mk l r xL xR).short
{Œ± : Type u_8} [add_comm_group Œ±] : Œ± √ó Œ± ‚Üí+ Œ±
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] (s : multiset Œ±) : multiset Œ±
 : has_add surreal
{Œ± : Type u} [pseudo_emetric_space Œ±] {s t u : set Œ±} : emetric.Hausdorff_edist s u ‚â§ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u
{Œ± : Type u_1} [pseudo_metric_space Œ±] (r C : ‚Ñù) (hr : r < 1) {f : ‚Ñï ‚Üí Œ±} (hu : ‚àÄ (n : ‚Ñï), has_dist.dist (f n) (f (n + 1)) ‚â§ C * r ^ n) : cauchy_seq f
{Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) : continuous Z.proj
{ùïú : Type u_3} {G : Type u_4} [is_R_or_C ùïú] [normed_group G] [normed_space ùïú G] {f : ùïú ‚Üí G} {s : set ùïú} {C : nnreal} (hf : ‚àÄ (x : ùïú), x ‚àà s ‚Üí differentiable_at ùïú f x) (bound : ‚àÄ (x : ùïú), x ‚àà s ‚Üí ‚à•deriv f x‚à•‚Çä ‚â§ C) (hs : convex ‚Ñù s) : lipschitz_on_with C f s
{G : Type u_1} [group G] (tG : monoid.is_torsion G) (H : subgroup G) : monoid.is_torsion ‚Ü•H
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (S : Type u_3) [ring S] [has_scalar S R] [module S M] [is_scalar_tower S R M] (P : submodule R M) : (M ‚ß∏ submodule.restrict_scalars S P) ‚âÉ‚Çó[S] M ‚ß∏ P
(extra_lems : list tactic.simp_arg_type) : expr ‚Üí tactic (expr √ó expr)
{p n k : ‚Ñï} (hn : 0 < n) : p ^ ‚áë((n.choose k).factorization) p ‚â§ n
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} (f : Y ‚ü∂ Z) (P : category_theory.ProjectiveResolution Y) (Q : category_theory.ProjectiveResolution Z) : category_theory.ProjectiveResolution.lift_f_one f P Q ‚â´ Q.complex.d 1 0 = P.complex.d 1 0 ‚â´ category_theory.ProjectiveResolution.lift_f_zero f P Q
 : ‚ÑÇ ‚Üí+ ‚Ñù
{J : Type v} [category_theory.small_category J] {A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] {L : A ‚•§ T} {R : B ‚•§ T} (F : J ‚•§ category_theory.comma L R) [category_theory.limits.preserves_colimit (F ‚ãô category_theory.comma.fst L R) L] {c‚ÇÅ : category_theory.limits.cocone (F ‚ãô category_theory.comma.fst L R)} (t‚ÇÅ : category_theory.limits.is_colimit c‚ÇÅ) {c‚ÇÇ : category_theory.limits.cocone (F ‚ãô category_theory.comma.snd L R)} (t‚ÇÇ : category_theory.limits.is_colimit c‚ÇÇ) : category_theory.limits.is_colimit (category_theory.comma.cocone_of_preserves F t‚ÇÅ c‚ÇÇ)
{ùïú : Type u_3} [field ùïú] {r : ‚Ñï} (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) (i : fin r ‚äï unit) {k : ‚Ñï} (hk : k ‚â§ r) : M.mul (list.take k (matrix.pivot.list_transvec_row M)).prod i (sum.inr ()) = M i (sum.inr ())
{Œ± : Type u_1} [preorder Œ±] (a : Œ±) : ordset Œ±
{G : Type u_1} (P : Type u_2) [add_group G] [add_torsor G P] : multiplicative G ‚Üí* equiv.perm P
(c : tactic.abel.context) (n : name) : list expr ‚Üí expr
{Œì : Type u_1} [inhabited Œì] {n : ‚Ñï} {enc : Œì ‚Üí vector bool n} (enc0 : enc inhabited.default = vector.repeat bool.ff n) (T : turing.tape Œì) : turing.tape bool
{Œ± : Type u_1} [encodable Œ±] : encodable (multiset Œ±)
(Œ± : Type u_1) [encodable Œ±] : Œ± ‚âÉ ulower Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_images C] [category_theory.limits.has_binary_coproducts C] {A : C} : category_theory.mono_over A ‚•§ category_theory.mono_over A ‚•§ category_theory.mono_over A
{R : Type u_1} [semiring R] (s : subsemiring R) : semiring ‚Ü•s
{V : Type u} [quiver V] (r : V) : Prop
{Œ± : Type u_1} : ordnode Œ± ‚Üí ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [ring Œ≤] [topological_ring Œ≤] : C(Œ±, Œ≤) ‚Üí+* Œ± ‚Üí Œ≤
{Œ± : Type u} [ordered_ring Œ±] {Œ≤ : Type u_1} [has_zero Œ≤] [has_one Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ≤), f (-x) = -f x) (sub : ‚àÄ (x y : Œ≤), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : ordered_ring Œ≤
{Œπ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {c : E} {la la' : filter ‚Ñù} {lt : filter Œπ} {a b : ‚Ñù} {u v : Œπ ‚Üí ‚Ñù} [interval_integral.FTC_filter a la la'] (hab : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f la' measure_theory.measure_space.volume) (hf : filter.tendsto f (la' ‚äì measure_theory.measure_space.volume.ae) (nhds c)) (hu : filter.tendsto u lt la) (hv : filter.tendsto v lt la) : (Œª (t : Œπ), ((‚à´ (x : ‚Ñù) in v t..b, f x) - ‚à´ (x : ‚Ñù) in u t..b, f x) + (v t - u t) ‚Ä¢ c) =o[lt] (v - u)
(R : Type u_1) [semiring R] : R ‚Üí+* power_series R
{a : nnreal} : add_le_cancellable ‚Üëa
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ‚Üí+* S) (s : subsemiring S) : subsemiring R
{Œ± : Type u} [has_ssubset Œ±] [is_irrefl Œ± has_ssubset.ssubset] {a b : Œ±} : a ‚äÇ b ‚Üí b ‚â† a
{C : Type u} [category_theory.category C] {X Y Z : algebraic_geometry.PresheafedSpace C} (f : X ‚ü∂ Z) [hf : algebraic_geometry.PresheafedSpace.is_open_immersion f] (g : Y ‚ü∂ Z) [algebraic_geometry.PresheafedSpace.is_open_immersion g] (e : set.range ‚áë(f.base) = set.range ‚áë(g.base)) : X ‚âÖ Y
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [complete_space E] (v : E) : ‚áë(orthogonal_projection (submodule.span ùïú {v})·óÆ) v = 0
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (G : D·µí·µñ ‚•§ C·µí·µñ) (h : G.unop ‚ä£ F) : F.op ‚ä£ G
{Œ± : Type} {f g : (Œ± ‚Üí ‚Ñï) ‚Üí ‚Ñï} (df : dioph.dioph_fn f) (dg : dioph.dioph_fn g) : dioph.dioph_fn (Œª (v : Œ± ‚Üí ‚Ñï), f v ^ g v)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L
{G : Type u_3} [add_group G] (P : add_subgroup G) : P.fg ‚Üî P.to_add_submonoid.fg
{R : Type u_1} [comm_ring R] (u v w : fin 3 ‚Üí R) : matrix.dot_product u (‚áë(‚áëcross_product v) w) = matrix.dot_product v (‚áë(‚áëcross_product w) u)
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [category_theory.limits.has_pullback f g] [category_theory.mono g] : category_theory.mono category_theory.limits.pullback.fst
 : lean.parser (tactic.list_Sigma tactic.rcases_patt)
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (G : D ‚•§ C) [category_theory.is_right_adjoint G] : category_theory.solution_set_condition G
{R : Type u_1} [comm_semiring R] (x y : R) (n : ‚Ñï) : (x + y) ^ n = (finset.range (n + 1)).sum (Œª (m : ‚Ñï), x ^ m * y ^ (n - m) * ‚Üë(n.choose m))
{Œ± : Type u_1} {Œ≤ : Type u_2} (rŒ± : Œ± ‚Üí Œ± ‚Üí Prop) (rŒ≤ : Œ≤ ‚Üí Œ≤ ‚Üí Prop) (f : Œ± ‚Üí Œ≤) : Prop
(Œ± : Type u_1) : Type u_1
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type u_1} [is_noetherian K V] (b : basis Œπ K V) : fintype Œπ
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] {v : E} (hv : v ‚àà K·óÆ) : ‚áë(reflection K) v = -v
{Œ± : Type u_1} [preorder Œ±] : simple_graph.hasse Œ±·µí·µà ‚âÉg simple_graph.hasse Œ±
(R : Type u) {X : Type v} [comm_ring R] : free_non_unital_non_assoc_algebra R X ‚Üí‚Çô‚Çê[R] free_lie_algebra R X
 : tactic (expr ‚Üí tactic (expr √ó expr))
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), add_comm_monoid (A i)] [add_comm_monoid Œπ] [direct_sum.gcomm_semiring A] : comm_semiring (A 0)
{Œ≥ : Type w} [metric_space Œ≥] : emetric_space Œ≥
 : format ‚Üí format
{R : Type u_1} [has_mul R] (c : R) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) [is_empty Œ±] [is_empty Œ≤] : r ‚âÉr s
{b m : ‚Ñï} : m < (b + 2) ^ ((b + 2).digits m).length
{V : Type u} {G : simple_graph V} {Œ≤ : Sort u_1} (f : V ‚Üí Œ≤) (h : ‚àÄ (v w : V) (p : G.walk v w), p.is_path ‚Üí f v = f w) : G.connected_component ‚Üí Œ≤
{G : Type u} [category_theory.groupoid G] [is_free_groupoid G] (T : wide_subquiver (quiver.symmetrify (is_free_groupoid.generators G))) [quiver.arborescence ‚Ü•T] (a : G) : root' T ‚ü∂ a
{Œ± : Type u_1} {s : finset Œ±} {Œ≤ : Œ± ‚Üí Type u_2} [h : Œ† (a : Œ±), decidable_eq (Œ≤ a)] : decidable_eq (Œ† (a : Œ±), a ‚àà s ‚Üí Œ≤ a)
{Œ± : Type u_1} {r : setoid Œ±} : ‚àÖ ‚àâ r.classes
(R : Type u_1) [comm_semiring R] (X : Type u_2) : has_mul (free_algebra.pre R X)
{R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {Œπ : Type u_6} [decidable_eq Œπ] (self : alternating_map R M N Œπ) : multilinear_map R (Œª (i : Œπ), M) N
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [has_neg Œ≤] : has_neg Œ±
{C : Type u‚ÇÇ} [category_theory.category C] [category_theory.limits.has_binary_products C] {J : Type v‚ÇÇ} [category_theory.small_category J] [category_theory.is_connected J] (X : C) : category_theory.limits.preserves_limits_of_shape J (category_theory.limits.prod.functor.obj X)
{G : Type u_1} {H : Type u_2} [group G] {N : subgroup G} [group H] {f : G ‚Üí* H} (hf : function.surjective ‚áëf) (hN : N = f.ker) (tN : monoid.is_torsion ‚Ü•N) : monoid.is_torsion H ‚Üî monoid.is_torsion G
{p : ‚Ñï} [hp : fact (nat.prime p)] : witt_vector.is_poly p (Œª (_x : Type u_1) (_x_1 : comm_ring _x) (_x_2 : witt_vector p _x), 1)
 : ring ‚ÑÇ
{A : Type w} (B : Type u‚ÇÅ) {C : Type u_1} {D : Type u_2} [comm_semiring A] [comm_semiring C] [comm_semiring D] [algebra A C] [algebra A D] (f : C ‚Üí‚Çê[A] D) [comm_semiring B] [algebra A B] [algebra B C] [is_scalar_tower A B C] : C ‚Üí‚Çê[B] D
{R : Type u_1} [comm_semiring R] {P : Type u_3} [comm_semiring P] (f : R ‚Üí+* P) (r : R) : localization.away r ‚Üí+* localization.away (‚áëf r)
{R : Type u_1} {M : Type u_5} [comm_ring R] [add_comm_group M] [module R M] (B F : M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R) : submodule R (module.End R M)
{X Y : Type u} [has_mul X] [has_mul Y] (e : X ‚âÉ* Y) : Magma.of X ‚âÖ Magma.of Y
{p : ‚Ñï} (hp : 1 < p) : padic_val_nat p p = 1
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D·µí·µñ} (Œ± : F ‚ü∂ G) : G.left_op ‚ü∂ F.left_op
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [has_zero M] (f : Œ± ‚Üí Œ≤) (l : Œ≤ ‚Üí‚ÇÄ M) (hf : set.inj_on f (f ‚Åª¬π' ‚Üë(l.support))) : Œ± ‚Üí‚ÇÄ M
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j j' : C) : C
{R : Type u_1} {A : Type u_2} {M : Type u_3} [semiring R] [semiring A] [add_comm_monoid M] [module R A] [module R M] (f : ‚Ñï ‚Üí (A ‚Üí‚Çó[R] M)) : polynomial A ‚Üí‚Çó[R] M
{R : Type u_1} (M : Type u_3) [has_scalar R M] (c : R) : Prop
(R : Type u1) [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] : M ‚Üí‚Çó[R] exterior_algebra R M
{Œ± : Type u} [decidable_eq Œ±] (l : list Œ±) (f : equiv.perm Œ±) : (‚àÄ {x : Œ±}, ‚áëf x ‚â† x ‚Üí x ‚àà l) ‚Üí {l // l.prod = f ‚àß ‚àÄ (g : equiv.perm Œ±), g ‚àà l ‚Üí g.is_swap}
{p n k : ‚Ñï} : ‚áë((n.choose k).factorization) p ‚â§ nat.log p n
{R : Type u_1} [mul_zero_class R] (h : is_right_regular 0) : subsingleton R
{Œ± : Type u} {Œ≤ : Type v} [has_le Œ≤] (l : filter Œ±) (f g : Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u_1} {s : multiset Œ±} : s.nodup ‚Üí s.powerset.nodup
{Œ± : Type u_1} {M : Type u_5} {R : Type u_11} {S : Type u_12} [has_zero M] [comm_semiring R] [comm_semiring S] (h : R ‚Üí+* S) (f : Œ± ‚Üí‚ÇÄ M) (g : Œ± ‚Üí M ‚Üí R) : ‚áëh (f.prod g) = f.prod (Œª (a : Œ±) (b : M), ‚áëh (g a b))
{G : Type u_6} {H : Type u_7} {F : Type u_8} [group G] [division_monoid H] [monoid_hom_class F G H] (f : F) (a : G) : ‚áëf a‚Åª¬π = (‚áëf a)‚Åª¬π
{Œ± : Type u_1} (n : ‚Ñï) (l : list Œ±) : list (multiset Œ±)
{R : Type u_1} [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] : tensor_algebra R M ‚Üí‚Çê[R] triv_sq_zero_ext R M
(M : Type u) [add_monoid M] : AddMon
{Œ± : Type u_1} {A : Type u_5} [add_monoid A] [monoid Œ±] [distrib_mul_action Œ± A] : mul_action Œ± (add_submonoid A)
{Œ± : Type u} {Œ≤ : Type v} [comm_semiring Œ≤] {Œ¥ : Œ± ‚Üí Type u_1} [decidable_eq Œ±] [Œ† (a : Œ±), decidable_eq (Œ¥ a)] {s : finset Œ±} {t : Œ† (a : Œ±), finset (Œ¥ a)} {f : Œ† (a : Œ±), Œ¥ a ‚Üí Œ≤} : s.prod (Œª (a : Œ±), (t a).sum (Œª (b : Œ¥ a), f a b)) = (s.pi t).sum (Œª (p : Œ† (a : Œ±), a ‚àà s ‚Üí Œ¥ a), s.attach.prod (Œª (x : {x // x ‚àà s}), f x.val (p x.val _)))
{n m : ‚Ñï} (f : fin (n + 1) ‚Üío fin (m + 1)) : simplex_category.mk n ‚ü∂ simplex_category.mk m
 : interactive.parse (lean.parser.many lean.parser.ident) ‚Üí tactic unit
(R : Type u) [comm_semiring R] {M : Type v} [add_comm_monoid M] [module R M] (g : M ‚Üí‚Çó[R] M) (f : (M ‚Üí‚Çó[R] M)À£) : ‚áë(linear_map.trace R M) (‚Üëf * g * ‚Üëf‚Åª¬π) = ‚áë(linear_map.trace R M) g
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G H : C ‚•§ D} (e : F ‚âÖ G) (e' : G ‚âÖ H) (hF : category_theory.is_equivalence F) : category_theory.is_equivalence.of_iso e' (category_theory.is_equivalence.of_iso e hF) = category_theory.is_equivalence.of_iso (e ‚â™‚â´ e') hF
{J : Type v} [category_theory.small_category J] {F : J ‚•§ Type (max v u)} (x : category_theory.limits.colimit F) : ‚àÉ (j : J) (y : F.obj j), category_theory.limits.colimit.Œπ F j y = x
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) [category_theory.is_filtered J] {x x' y : Œ£ (j : J), ‚Ü•(F.obj j)} (hxx' : category_theory.limits.types.filtered_colimit.rel (F ‚ãô category_theory.forget Mon) x x') : Mon.filtered_colimits.colimit_mul_aux F x y = Mon.filtered_colimits.colimit_mul_aux F x' y
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (p : formal_multilinear_series ùïú E F) (x : E) (r : ennreal) : Prop
{R : Type u} [semiring R] {S : Type v} [semiring S] (f : R ‚Üí+* S) : subsemiring (polynomial S)
{Œ± : Type u_1} (o : ordinal) (f : Œ† (a : ordinal), a < o ‚Üí Œ±) : (quotient.out o).Œ± ‚Üí Œ±
 : Type
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul G] (g : G) : G ‚âÉ·µê G
(ps : tactic.ring_exp.ex tactic.ring_exp.ex_type.sum) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.base)
{Œ± : Type u} [add_group Œ±] [linear_order Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] (a : Œ±) : linear_order.max a 0 - linear_order.max (-a) 0 = a
{C : Type u} [category_theory.category C] [category_theory.limits.has_images C] [category_theory.limits.has_pullbacks C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_strong_epi_images C
{a b : ‚Ñï} (hab : a.coprime b) : (a * b).factorization = a.factorization + b.factorization
{L : first_order.language} {M : Type w} [L.Structure M] {n : ‚Ñï} (f : L.functions n) (s : set M) : Prop
{Œ± : Type u} : list Œ± ‚Üí ordnode Œ± ‚Üí ‚Ñï ‚Üí ordnode Œ±
(C : Type u_1) [category_theory.category C] [category_theory.monoidal_category C] : category_theory.is_equivalence (category_theory.monoidal_single_obj.End_monoidal_star_functor C).to_lax_monoidal_functor.to_functor
{V : Type u} {G : simple_graph V} {x y : G.subgraph} (h : x ‚â§ y) : x.coe ‚Üíg y.coe
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (p : Œπ ‚Üí P) : finset.centroid k s p = ‚áë(s.affine_combination p) (finset.centroid_weights k s)
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_4} [fintype Œπ] [decidable_eq Œπ] [nontrivial R] (e : basis Œπ R M) (w : Œπ ‚Üí RÀ£) : (e.units_smul w).orientation = (finset.univ.prod (Œª (i : Œπ), w i))‚Åª¬π ‚Ä¢ e.orientation
(Œ± : Type u_1) [preorder Œ±] : Type u_1
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [topological_space Œ¥] (e : local_homeomorph Œ± Œ≤) (e' : local_homeomorph Œ≥ Œ¥) : local_homeomorph (Œ± √ó Œ≥) (Œ≤ √ó Œ¥)
{Œ± : Type u} {Œ≤ : Type v} [has_add Œ≤] (f : Œ± ‚Üí Œ≤) : free_add_magma Œ± ‚Üí Œ≤
 : tactic (list expr)
{Œ± : Type u} [linear_ordered_comm_ring Œ±] {Œ≤ : Type u_1} [has_zero Œ≤] [has_one Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ≤), f (-x) = -f x) (sub : ‚àÄ (x y : Œ≤), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : linear_ordered_comm_ring Œ≤
(n : ‚Ñï) (R : Type u_1) [comm_ring R] [is_domain R] : (polynomial.cyclotomic' n R).roots = (primitive_roots n R).val
{M : Type u_1} {Œπ : Type u_2} {R : Type u_3} [decidable_eq M] [add_monoid M] [decidable_eq Œπ] [add_monoid Œπ] [comm_semiring R] (f : M ‚Üí+ Œπ) : direct_sum.is_internal (add_monoid_algebra.grade_by R ‚áëf)
(Œ± : Type u_3) [uniform_space Œ±] [group Œ±] : Prop
{Œ± : Type u_1} [has_mul Œ±] (s : set Œ±) (a : Œ±) : set Œ±
(M : Type u_1) [has_zero M] : zero_hom M M
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] : Type u_2
{R : Type u_10} {V : Type u_11} {P : Type u_12} [comm_ring R] [add_comm_group V] [module R V] [add_torsor V P] (p : P) : RÀ£ ‚Üí* P ‚âÉ·µÉ[R] P
(C : Type u) [category_theory.category C] {Œ≤ Œ≥ : Type w} {f g : Œ≤ ‚Üí Œ≥} (h : f = g) : category_theory.pi.comap (Œª (_x : Œ≥), C) f ‚âÖ category_theory.pi.comap (Œª (_x : Œ≥), C) g
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} : antitone f ‚Üí monotone (‚áëorder_dual.to_dual ‚àò f)
(X : algebraic_geometry.LocallyRingedSpace) : X.hom X
{Œ± : Type u_1} [topological_space Œ±] [non_unital_non_assoc_ring Œ±] [topological_ring Œ±] (x : Œ±) : continuous ‚áë(add_monoid_hom.mul_right x)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.limits.preserves_finite_limits F] : category_theory.limits.preserves_finite_colimits F.op
{Œ± : Type u} {Œ≤ : Type v} (f : Œ≤ ‚Üí option (Œ± √ó Œ≤)) (b : Œ≤) : seq Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] : ‚Ü•(set.range sum.inr) ‚âÉ·µê Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_pullbacks C] {A B : C} (f : A ‚ü∂ B) [category_theory.mono f] : (category_theory.mono_over.pullback f).obj (category_theory.mono_over.mk' f) ‚âÖ ‚ä§
(q : interactive.parse interactive.types.texpr) (hs : interactive.parse interactive.types.with_ident_list) : tactic unit
{Œ± : Type u_1} (G : simple_graph Œ±) (s : set Œ±) : Prop
 : conv unit
(R : Type u_1) [comm_semiring R] (M : Type u_4) [add_comm_monoid M] [module R M] : tensor_product R R M ‚âÉ‚Çó[R] M
{Œ± : Type u} [metric_space Œ±] : metric_space (topological_space.nonempty_compacts Œ±)
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_comm_monoid M] (f : Œ± √ó Œ≤ ‚Üí‚ÇÄ M) : Œ± ‚Üí‚ÇÄ Œ≤ ‚Üí‚ÇÄ M
{Œ± : Type u} [topological_space Œ±] (s : set Œ±) : Prop
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] {f : ‚ÑÇ ‚Üí E} (hd : diff_cont_on_cl ‚ÑÇ f (set.Ioi 0 √ó‚ÑÇ set.Ioi 0)) (hB : ‚àÉ (c : ‚Ñù) (H : c < 2) (B : ‚Ñù), f =O[filter.comap complex.abs filter.at_top ‚äì filter.principal (set.Ioi 0 √ó‚ÑÇ set.Ioi 0)] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)) (hre : ‚àÄ (x : ‚Ñù), 0 ‚â§ x ‚Üí f ‚Üëx = 0) (him : ‚àÄ (x : ‚Ñù), 0 ‚â§ x ‚Üí f (‚Üëx * complex.I) = 0) : set.eq_on f 0 {z : ‚ÑÇ | 0 ‚â§ z.re ‚àß 0 ‚â§ z.im}
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] (X : C) : category_theory.is_pushout 0 (ùüô X) 0 0
 : ‚Ñï ‚Üí Type
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [semiring k] [has_zero G] : has_one (add_monoid_algebra k G)
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : (Œ± ‚äï Œ≤ ‚Üí Œ≥) ‚âÉ (Œ± ‚Üí Œ≥) √ó (Œ≤ ‚Üí Œ≥)
{C : Type u} [category_theory.category C] {Œπ : Type u_1} {s : Œπ ‚Üí C} [category_theory.preadditive C] [category_theory.limits.has_finite_biproducts C] (o : category_theory.hom_orthogonal s) {Œ± Œ≤ : Type v} [fintype Œ±] [fintype Œ≤] {f : Œ± ‚Üí Œπ} {g : Œ≤ ‚Üí Œπ} : ((‚®Å Œª (a : Œ±), s (f a)) ‚ü∂ ‚®Å Œª (b : Œ≤), s (g b)) ‚âÉ+ Œ† (i : Œπ), matrix ‚Ü•(g ‚Åª¬π' {i}) ‚Ü•(f ‚Åª¬π' {i}) (category_theory.End (s i))
(R : Type u) [non_assoc_semiring R] : galois_insertion subsemiring.closure coe
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ‚Ñù E] [normed_group F] [normed_space ‚Ñù F] {s : set E} (s_conv : convex ‚Ñù s) {f : E ‚Üí F} {f' : E ‚Üí (E ‚ÜíL[‚Ñù] F)} {f'' : E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] F} (hf : ‚àÄ (x : E), x ‚àà interior s ‚Üí has_fderiv_at f (f' x) x) {x : E} (xs : x ‚àà s) (hx : has_fderiv_within_at f' f'' (interior s) x) {v w : E} (hv : x + v ‚àà interior s) (hw : x + v + w ‚àà interior s) : (Œª (h : ‚Ñù), f (x + h ‚Ä¢ v + h ‚Ä¢ w) - f (x + h ‚Ä¢ v) - h ‚Ä¢ ‚áë(f' x) w - h ^ 2 ‚Ä¢ ‚áë(‚áëf'' v) w - (h ^ 2 / 2) ‚Ä¢ ‚áë(‚áëf'' w) w) =o[nhds_within 0 (set.Ioi 0)] Œª (h : ‚Ñù), h ^ 2
{H : Type u_1} [topological_space H] {e : local_homeomorph H H} : e ‚àà charted_space.atlas H H ‚Üî e = local_homeomorph.refl H
{n : ‚Ñï} (Œ± : typevec (n + 1)) : Type u
(d : tactic_doc_entry) : json
{R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] (s : set E) : ‚áë(convex_hull R) s = ‚ãÉ (t : finset E) (w : ‚Üët ‚äÜ s), ‚áë(convex_hull R) ‚Üët
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) (s : category_theory.limits.cocone F) : Mon.colimits.prequotient F ‚Üí ‚Ü•(s.X)
 : name ‚Üí string ‚Üí name
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.abelian D] (F : C ‚•§ D) (G : D ‚•§ C) [G.preserves_zero_morphisms] (i : F ‚ãô G ‚âÖ ùü≠ C) (adj : G ‚ä£ F) [category_theory.limits.has_cokernels C] [category_theory.limits.has_kernels C] [category_theory.limits.preserves_finite_limits G] {X Y : C} (f : X ‚ü∂ Y) : category_theory.limits.kernel (G.map (category_theory.limits.cokernel.œÄ (F.map f))) ‚âÖ category_theory.limits.kernel (category_theory.limits.cokernel.œÄ f)
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_wide_pullbacks C
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} {M‚ÇÉ : Type v‚ÇÉ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [module R M‚ÇÉ] (g : M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÉ) (f : multilinear_map R M‚ÇÅ M‚ÇÇ) : multilinear_map R M‚ÇÅ M‚ÇÉ
{Œ± : Type u_1} {Œ≤ : Type u_2} [encodable Œ±] [fintype Œ±] [encodable Œ≤] : encodable (Œ± ‚Üí Œ≤)
{n : ‚Ñï} {x : ‚Ñï √ó ‚Ñï} : x ‚àà finset.nat.antidiagonal n ‚Üî x.fst + x.snd = n
 : ‚Ñï ‚Üí vm (‚Ñï √ó ‚Ñï)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {X Y‚ÇÅ Y‚ÇÇ : C} (_x : category_theory.exact_pairing X Y‚ÇÅ) (_x_1 : category_theory.exact_pairing X Y‚ÇÇ) : Y‚ÇÅ ‚âÖ Y‚ÇÇ
{Œ± : Type u_1} [decidable_eq Œ±] (a : Œ±) : list Œ± ‚Üí list ‚Ñï
{p : ‚Ñï} [hp : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {S : Type u_2} [semiring S] {f : Œ† (k : ‚Ñï), S ‚Üí+* truncated_witt_vector p k R} (f_compat : ‚àÄ (k‚ÇÅ k‚ÇÇ : ‚Ñï) (hk : k‚ÇÅ ‚â§ k‚ÇÇ), (truncated_witt_vector.truncate hk).comp (f k‚ÇÇ) = f k‚ÇÅ) (g : S ‚Üí+* witt_vector p R) (g_compat : ‚àÄ (k : ‚Ñï), (witt_vector.truncate k).comp g = f k) : witt_vector.lift (Œª (k‚ÇÇ : ‚Ñï), f k‚ÇÇ) f_compat = g
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {a b : ‚Ñù} {f f' : ‚Ñù ‚Üí ‚Ñù} {g : ‚Ñù ‚Üí E} (h : ‚àÄ (x : ‚Ñù), x ‚àà set.interval a b ‚Üí has_deriv_at f (f' x) x) (h' : continuous_on f' (set.interval a b)) (hg : continuous g) : ‚à´ (x : ‚Ñù) in a..b, f' x ‚Ä¢ (g ‚àò f) x = ‚à´ (x : ‚Ñù) in f a..f b, g x
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : rel Œ± Œ≤) : rel Œ≤ Œ±
{C : Type u} (X Y : category_theory.free_monoidal_category C) : setoid (X.hom Y)
{k : Type u_1} {M : Type u_2} [linear_ordered_field k] [ordered_add_comm_monoid M] [mul_action_with_zero k M] (hlt : ‚àÄ ‚¶Éa b : M‚¶Ñ ‚¶Éc : k‚¶Ñ, a < b ‚Üí 0 < c ‚Üí c ‚Ä¢ a ‚â§ c ‚Ä¢ b) : ordered_smul k M
{Œ± : Type u} {F : Œ±·µÉ·µí·µñ ‚Üí Sort v} (h : Œ† (X : Œ±), F (add_opposite.op X)) (X : Œ±·µÉ·µí·µñ) : F X
{Œ≥ : Type u_3} [tŒ≥ : topological_space Œ≥] [polish_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] {Œ≤ : Type u_4} [tŒ≤ : topological_space Œ≤] [t2_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] {s : set Œ≥} {f : Œ≥ ‚Üí Œ≤} (hs : measurable_set s) (f_cont : continuous_on f s) (f_inj : set.inj_on f s) : measurable_embedding (s.restrict f)
{Œ± : Type u_1} {Œ≤ : Type u_2} [partial_order Œ≤] (f : Œ± ‚Üí Œ≤) (inj : function.injective f) : partial_order Œ±
(type : expr) : expr
 : tactic unit
(f : name) (inst : expr) (args : list expr) : tactic.ring_exp.ring_exp_m expr
(o : ordinal) : ordinal
{R : Type u} [comm_semiring R] (t : multiset (polynomial R)) (h : (multiset.map (Œª (f : polynomial R), f.leading_coeff) t).prod ‚â† 0) : t.prod.nat_degree = (multiset.map (Œª (f : polynomial R), f.nat_degree) t).sum
(Œ± : Type u_1) [fintype Œ±] [category_theory.small_category Œ±] [category_theory.fin_category Œ±] : category_theory.fin_category.obj_as_type Œ± ‚•§ category_theory.fin_category.as_type Œ±
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : ‚Ü•‚ä§ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] (F : Œπ ‚Üí Œ± ‚Üí Œ≤) (f : Œ± ‚Üí Œ≤) (p : filter Œπ) : Prop
{Œπ : Type u‚ÇÅ} {k : Type u‚ÇÇ} {V : Type u‚ÇÉ} {P : Type u‚ÇÑ} [add_comm_group V] [add_torsor V P] [ring k] [module k V] (b : affine_basis Œπ k P) {Œπ' : Type u_1} [fintype Œπ'] [fintype Œπ] [decidable_eq Œπ] [nontrivial k] (p : Œπ' ‚Üí P) {A : matrix Œπ Œπ' k} (hA : A.mul (b.to_matrix p) = 1) : affine_span k (set.range p) = ‚ä§
(Œ± : Sort u_1) (Œ≤ : Sort u_2) : Sort (max 1 (imax u_1 u_2))
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type w} {s : set Œπ} (h : basis ‚Ü•s K V) (hs : s.finite) : finite_dimensional K V
{Œ± : Type u_1} [decidable_eq Œ±] : ‚Ü•(derangements (option Œ±)) ‚âÉ Œ£ (a : Œ±), ‚Ü•{f : equiv.perm Œ± | function.fixed_points ‚áëf ‚äÜ {a}}
(Œ± : Type u_1) [left_cancel_monoid Œ±] : has_faithful_smul Œ±·µê·µí·µñ Œ±
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] (a : Œ±) : has_Inf.Inf {a} = a
(q : interactive.parse interactive.types.texpr) : tactic unit
{Œ± : Type u_1} [add_comm_group Œ±] (C : add_comm_group.positive_cone Œ±) : ordered_add_comm_group Œ±
(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_pushouts C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : X ‚®ø Y ‚âÖ category_theory.limits.pushout (category_theory.limits.initial.to X) (category_theory.limits.initial.to Y)
(p : ‚Ñï) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : ‚Ñï) (x y : witt_vector p k) : witt_vector.peval (witt_vector.poly_of_interest p n) ![Œª (i : ‚Ñï), x.coeff i, Œª (i : ‚Ñï), y.coeff i] = (x * y).coeff (n + 1) - y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) - x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1)
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {s : set ‚ÑÇ} {f : ‚ÑÇ ‚Üí E} {z : ‚ÑÇ} (hd : differentiable_on ‚ÑÇ f s) (hz : s ‚àà nhds z) : analytic_at ‚ÑÇ f z
{X : Top} {C : Type u} [category_theory.category C] (F : Top.presheaf C X) : Prop
{Œ± : Type u} [topological_space Œ±] [t2_space Œ±] {s : set Œ±} (hs : is_compact s) {Œπ : Type u_1} (t : finset Œπ) (U : Œπ ‚Üí set Œ±) (hU : ‚àÄ (i : Œπ), i ‚àà t ‚Üí is_open (U i)) (hsC : s ‚äÜ ‚ãÉ (i : Œπ) (H : i ‚àà t), U i) : ‚àÉ (K : Œπ ‚Üí set Œ±), (‚àÄ (i : Œπ), is_compact (K i)) ‚àß (‚àÄ (i : Œπ), K i ‚äÜ U i) ‚àß s = ‚ãÉ (i : Œπ) (H : i ‚àà t), K i
 : prime_multiset ‚Üí multiset ‚Ñï+
(C : Type u) [category_theory.category C] [category_theory.non_preadditive_abelian C] : category_theory.abelian C
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [linear_ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : convex_on ùïú s f) {x y z : E} (hx : x ‚àà s) (hy : y ‚àà s) (hz : z ‚àà segment ùïú x y) : f z ‚â§ linear_order.max (f x) (f y)
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] [category_theory.limits.has_equalizers V] [category_theory.limits.has_cokernels V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] (n : ‚Ñï) : cochain_complex.single‚ÇÄ V ‚ãô homology_functor V (complex_shape.up ‚Ñï) (n + 1) ‚âÖ 0
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : category_theory.limits.walking_span ‚•§ C
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_binary_product X Y] : X ‚®Ø Y ‚ü∂ X
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {R : ‚Ñù} {c w : ‚ÑÇ} {f : ‚ÑÇ ‚Üí E} (h : diff_cont_on_cl ‚ÑÇ f (metric.ball c R)) (hw : w ‚àà metric.ball c R) : ‚àÆ (z : ‚ÑÇ) in C(c, R), (z - w)‚Åª¬π ‚Ä¢ f z = (2 * ‚Üëreal.pi * complex.I) ‚Ä¢ f w
{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_group M] [module R M] : submodule R M ‚âÉo submodule R M
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] (F : category_theory.oplax_functor B C) : Type (max u‚ÇÅ v‚ÇÅ w‚ÇÇ)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ‚ü∂ Q) : function.injective ‚áëf ‚Üí ‚àÄ (a : ‚Ü•P), ‚áëf a = 0 ‚Üí a = 0
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] : ordnode Œ± ‚Üí ordnode Œ± ‚Üí ordnode Œ±
(Œ± : Sort u_1) (Œ≤ : Sort u_2) [unique Œ±] [unique Œ≤] : Œ± ‚âÉ Œ≤
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] {A : Type u_2} [semiring A] [algebra R A] (f : M ‚Üí‚Çó[R] A) (hf : ‚àÄ (x y : M), ‚áëf x * ‚áëf y = 0) : triv_sq_zero_ext R M ‚Üí‚Çê[R] A
{V‚ÇÅ : Type u_3} {V‚ÇÇ : Type u_4} [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] (f : normed_group_hom V‚ÇÅ V‚ÇÇ) : add_subgroup V‚ÇÇ
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] (F : category_theory.pseudofunctor B C) : category_theory.oplax_functor B C
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ‚•§ D) [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.enough_projectives C] [category_theory.limits.preserves_finite_colimits F] : F.left_derived 0 ‚âÖ F
(Œ± : Type u_1) [linear_ordered_ring Œ±] (floor : Œ± ‚Üí ‚Ñ§) (gc_coe_floor : galois_connection coe floor) : floor_ring Œ±
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.final] {E : Type u} [category_theory.category E] {G : D ‚•§ E} (t : category_theory.limits.colimit_cocone G) : category_theory.limits.colimit_cocone (F ‚ãô G)
{k : Type u_1} {V‚ÇÅ : Type u_2} {P‚ÇÅ : Type u_3} {V‚ÇÇ : Type u_4} {P‚ÇÇ : Type u_5} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] (f : P‚ÇÅ ‚Üí·µÉ[k] P‚ÇÇ) (s : affine_subspace k P‚ÇÅ) : affine_subspace k P‚ÇÇ
{R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] : exterior_algebra R M ‚Üí‚Çê[R] triv_sq_zero_ext R M
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] {N : Type v} [add_comm_group N] [module R N] (Q : quadratic_form R N) (f : M ‚Üí‚Çó[R] N) : quadratic_form R M
{C : Type u‚ÇÅ} [category_theory.category C] (G : category_theory.comonad C) : G.adj.to_comonad ‚âÖ G
{R : Type u} [semiring R] (p : polynomial R) (n : ‚Ñï) (a : R) : polynomial R
{ùïú : Type u} {A : Type v} [field ùïú] [ring A] [algebra ùïú A] [nontrivial A] : spectrum ùïú 0 = {0}
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_group Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} : strict_convex_on ùïú s (-f) ‚Üî strict_concave_on ùïú s f
{E : Type u_2} {ùïú : Type u_3} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] {s : set E} (hs : convex ùïú s) {a b : ùïú} (ha : 0 ‚â§ a) (hb : 0 < b) (hab : a + b = 1) : a ‚Ä¢ closure s + b ‚Ä¢ interior s ‚äÜ interior s
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ‚Ñù P) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] : (euclidean_geometry.reflection s).symm = euclidean_geometry.reflection s
{ùïú : Type u_1} {E : Type u_2} [semi_normed_ring ùïú] [has_scalar ùïú E] [has_zero E] [topological_space E] {s‚ÇÅ s‚ÇÇ : set E} (h : s‚ÇÅ ‚äÜ s‚ÇÇ) (hs‚ÇÇ : bornology.is_vonN_bounded ùïú s‚ÇÇ) : bornology.is_vonN_bounded ùïú s‚ÇÅ
{A : Type u_4} {B : Type u_5} {C : Type u_6} [add_monoid A] [add_monoid B] [add_monoid C] [topological_space A] [topological_space B] [topological_space C] (f : continuous_add_monoid_hom A B) (g : continuous_add_monoid_hom A C) : continuous_add_monoid_hom A (B √ó C)
{R : Type u_1} [mul_zero_class R] : is_regular 0 ‚Üî subsingleton R
{Œ± : Type u_1} (C : set (set Œ±)) : Prop
(G : Type u_1) [measurable_space G] [has_sub G] : Prop
(p : ‚Ñï) (R : Type u_1) [hp : fact (nat.prime p)] [comm_ring R] : comm_ring (witt_vector p R)
{Œ≥ : Type} : expr ‚Üí tactic (list (widget.html (widget_override.interactive_expression.action Œ≥)))
{Œ± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : filter Œ±} : f =o[l] g ‚Üî ‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ, 0 < c ‚Üí asymptotics.is_O_with c l f g
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} (h_mono : strict_mono_on f s) (hs : s ‚àà nhds_within a (set.Iic a)) (hfs : set.surj_on f s (set.Iio (f a))) : continuous_within_at f (set.Iic a) a
 : computability.encoding ‚Ñï
(R : Type u_1) [semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (N : Type u_3) [add_comm_monoid N] [module R N] (Œπ : Type u_6) [decidable_eq Œπ] : Type (max u_2 u_3 u_6)
{C : Type u‚ÇÅ} [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] [‚àÄ (a b : C), category_theory.limits.has_products_of_shape (a ‚ü∂ b) D] (c : C) : D ‚•§ C ‚•§ D
{Œπ : Type u_1} {Œ± : Type u_3} {Œ≤ : Type u_4} [preorder Œ±] [preorder Œ≤] (f : Œπ ‚Üí Œ±) (g : Œπ ‚Üí Œ≤) (s : set Œπ) : Prop
{X Y : Top} {f g : C(‚Ü•X, ‚Ü•Y)} (H : f.homotopy g) {x‚ÇÄ x‚ÇÅ : ‚Ü•X} (p : fundamental_groupoid.from_top x‚ÇÄ ‚ü∂ fundamental_groupoid.from_top x‚ÇÅ) : (fundamental_groupoid.fundamental_groupoid_functor.map g).map p = continuous_map.homotopy.hcast _ ‚â´ (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I (ùüô {down := 1}) p) ‚â´ continuous_map.homotopy.hcast _
{C : Type u‚ÇÅ} [category_theory.category C] (Z : C) (D : Type u‚ÇÇ) [category_theory.category D] : D ‚•§ C √ó D
{R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [semiring R] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [semi_normed_group E] [semi_normed_group E‚ÇÇ] [module R E] [module R‚ÇÇ E‚ÇÇ] {Œπ : Type u_3} (b : basis Œπ R E) {f‚ÇÅ f‚ÇÇ : E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : ‚àÄ (i : Œπ), ‚áëf‚ÇÅ (‚áëb i) = ‚áëf‚ÇÇ (‚áëb i)) : f‚ÇÅ = f‚ÇÇ
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) : category_theory.is_iso 0 ‚âÉ ùüô X = 0 ‚àß ùüô Y = 0
(Œ± : Type u_1) (Œ≤ : Type u_2) [has_le Œ±] [has_le Œ≤] : Œ± ‚äï Œ≤ ‚âÉo Œ≤ ‚äï Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} : Œ± ‚Ü™ Œ± ‚äï Œ≤
{R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] [is_localization M S] (h : 0 ‚àà M) : unique S
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [fintype J] {K : Type v} [fintype K] {f : J ‚Üí C} {g : K ‚Üí C} [category_theory.limits.has_finite_biproducts C] (m : ‚®Å f ‚ü∂ ‚®Å g) (j : J) (k : K) : f j ‚ü∂ g k
{G : Type u_4} [normed_group G] [normed_space ‚Ñù G] {s : set G} {x y : G} (h : open_segment ‚Ñù x y ‚äÜ s) : y - x ‚àà tangent_cone_at ‚Ñù s x
{Œ± : Type u} [semilattice_sup Œ±] [order_bot Œ±] (x y z : Œ±) (f : z ‚ü∂ x) (g : z ‚ü∂ y) : category_theory.limits.pushout f g = x ‚äî y
{Œ± : Type u_1} {Œπ : Type u_2} {Œ∫ : Type u_3} (C : (Œπ ‚Üí option Œ±) ‚Üí Œ∫) : Type (max u_1 u_2 u_3)
{M : Type u_1} [has_mul M] (c : con M) : con_gen ‚áëc = c
{Œ± : Type u_1} (l‚ÇÅ l‚ÇÇ : list Œ±) : Prop
{K : Type u_4} {V : Type u} [division_ring K] [add_comm_group V] [module K V] {x : V} {n : ‚Ñï} {v : fin n ‚Üí V} (hv : linear_independent K v) (hx : x ‚àâ submodule.span K (set.range v)) : linear_independent K (fin.cons x v)
(R : Type u) [ring R] (Œì‚ÇÄ : out_param (Type v)) [linear_ordered_comm_group_with_zero Œì‚ÇÄ] : Type (max u v)
{Œπ : Type u_1} (c : complex_shape Œπ) : complex_shape Œπ
{n : Type u} [decidable_eq n] [fintype n] {Œ± : Type v} [comm_ring Œ±] [star_ring Œ±] (A : ‚Ü•(matrix.unitary_group n Œ±)) : linear_map.general_linear_group Œ± (n ‚Üí Œ±)
{C : Type u} [category_theory.category C] {X Y Z : C} {sXY : category_theory.limits.binary_fan X Y} (P : category_theory.limits.is_limit sXY) {sYZ : category_theory.limits.binary_fan Y Z} (Q : category_theory.limits.is_limit sYZ) {s : category_theory.limits.binary_fan sXY.X Z} (R : category_theory.limits.is_limit s) {t : category_theory.limits.binary_fan X sYZ.X} (S : category_theory.limits.is_limit t) : s.X ‚âÖ t.X
{Œ± : Type u_1} {Œ≤ : Type u_2} (op : Œ≤ ‚Üí Œ≤ ‚Üí Œ≤) [hc : is_commutative Œ≤ op] [ha : is_associative Œ≤ op] (b : Œ≤) (f : Œ± ‚Üí Œ≤) (s : finset Œ±) : Œ≤
(Œ± Œ≤ : Type u) : Œ± ‚äï Œ≤ ‚âÉ Œ£ (b : bool), cond b Œ± Œ≤
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (l‚ÇÅ l‚ÇÇ : Œπ ‚Üí‚ÇÄ ùïú) : has_inner.inner (‚áë(finsupp.total Œπ E ùïú v) l‚ÇÅ) (‚áë(finsupp.total Œπ E ùïú v) l‚ÇÇ) = l‚ÇÅ.sum (Œª (i : Œπ) (y : ùïú), ‚áë(star_ring_end ùïú) y * ‚áël‚ÇÇ i)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : Type v‚ÇÅ
{Œ± : Type u_1} [group Œ±] (s : subgroup Œ±) : quotient (quotient_group.right_rel s) ‚âÉ Œ± ‚ß∏ s
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí. Œ≤) : rel Œ± Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ w)
{M : Type u_5} [add_comm_group M] : unique (module ‚Ñ§ M)
{Œ± : Type u_1} [has_add Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b c d : Œ±} (h‚ÇÅ : a < b) (h‚ÇÇ : c < d) : a + c < b + d
{Œ± : Type u_1} [linear_ordered_field Œ±] (a : Œ±) (ha : 0 < a) : Œ± ‚âÉo Œ±
(n : ‚Ñï+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] : is_cyclotomic_extension {n} A B ‚Üî (‚àÉ (r : B), ‚áë(polynomial.aeval r) (polynomial.cyclotomic ‚Üën A) = 0) ‚àß ‚àÄ (x : B), x ‚àà algebra.adjoin A {b : B | b ^ ‚Üën = 1}
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (s : subsemigroup M) (t : subsemigroup N) : ‚Ü•(s.prod t) ‚âÉ* ‚Ü•s √ó ‚Ü•t
{Œπ : Type u_1} (Œ± : Œπ ‚Üí Type u_2) (Œ≤ : Œπ ‚Üí Type u_3) : (Œ£ (i : Œπ), Œ± i ‚äï Œ≤ i) ‚âÉ (Œ£ (i : Œπ), Œ± i) ‚äï Œ£ (i : Œπ), Œ≤ i
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_cokernel f] : category_theory.limits.is_colimit (category_theory.limits.cofork.of_œÄ (category_theory.limits.cokernel.œÄ f) _)
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} {a : Œ±} : (‚àÉ·∂† (x : Œ±) in nhds a, x ‚àà s) ‚Üí a ‚àà closure s
{l : Type u_1} {m : Type u_2} {n : Type u_3} {Œ± : Type v} [non_unital_non_assoc_semiring Œ±] [fintype m] (M : matrix l m Œ±) : matrix m n Œ± ‚Üí+ matrix l n Œ±
{C : Type u‚ÇÅ} [category_theory.category C] : C ‚âå category_theory.ulift_hom C
{Œ± : Type u_2} [decidable_eq Œ±] [has_add Œ±] : add_hom Œ± (finset Œ±)
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C
{X : Type u_1} {Y : Type u_2} [decidable_eq X] {x : X} (f : {x' // x' ‚â† x} ‚Üí Y) : {g // g ‚àò coe = f} ‚âÉ Y
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.is_connected J] {B : C} : category_theory.creates_limits_of_shape J (category_theory.over.forget B)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) [category_theory.limits.has_binary_biproduct P Q] : category_theory.limits.is_colimit (category_theory.limits.binary_biproduct.bicone P Q).to_cocone
{X Y : Type u} [comm_ring X] [comm_ring Y] (e : X ‚âÉ+* Y) : CommRing.of X ‚âÖ CommRing.of Y
{Œ± : Type u_1} {s : finset Œ±} {p : finset Œ± ‚Üí Prop} (hu : Œ† (t : finset Œ±), t ‚äÜ s ‚Üí decidable (p t)) : decidable (‚àÄ (t : finset Œ±), t ‚äÜ s ‚Üí p t)
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), add_comm_group (A i)] [add_comm_monoid Œπ] [direct_sum.gcomm_semiring A] : comm_ring (A 0)
{M : Type w} {c f‚ÇÅ f‚ÇÇ : Type u} {r‚ÇÅ r‚ÇÇ : Type v} (c' : c ‚Üí M) (f‚ÇÅ' : f‚ÇÅ ‚Üí M ‚Üí M) (f‚ÇÇ' : f‚ÇÇ ‚Üí M ‚Üí M ‚Üí M) (r‚ÇÅ' : r‚ÇÅ ‚Üí set M) (r‚ÇÇ' : r‚ÇÇ ‚Üí M ‚Üí M ‚Üí Prop) : (first_order.language.mk‚ÇÇ c f‚ÇÅ f‚ÇÇ r‚ÇÅ r‚ÇÇ).Structure M
{Œ± : Type} {d : ‚Ñï} {ds : list ‚Ñï} (x y : holor Œ± (d :: ds)) (h : x.slice = y.slice) : x = y
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] (R : B ‚•§ T) {L‚ÇÅ L‚ÇÇ L‚ÇÉ : A ‚•§ T} (l : L‚ÇÅ ‚ü∂ L‚ÇÇ) (l' : L‚ÇÇ ‚ü∂ L‚ÇÉ) : category_theory.comma.map_left R (l ‚â´ l') ‚âÖ category_theory.comma.map_left R l' ‚ãô category_theory.comma.map_left R l
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] [finite_dimensional ‚Ñù V] (hd : finite_dimensional.finrank ‚Ñù V = 2) {c‚ÇÅ c‚ÇÇ p‚ÇÅ p‚ÇÇ p : P} {r‚ÇÅ r‚ÇÇ : ‚Ñù} (hc : c‚ÇÅ ‚â† c‚ÇÇ) (hp : p‚ÇÅ ‚â† p‚ÇÇ) (hp‚ÇÅc‚ÇÅ : has_dist.dist p‚ÇÅ c‚ÇÅ = r‚ÇÅ) (hp‚ÇÇc‚ÇÅ : has_dist.dist p‚ÇÇ c‚ÇÅ = r‚ÇÅ) (hpc‚ÇÅ : has_dist.dist p c‚ÇÅ = r‚ÇÅ) (hp‚ÇÅc‚ÇÇ : has_dist.dist p‚ÇÅ c‚ÇÇ = r‚ÇÇ) (hp‚ÇÇc‚ÇÇ : has_dist.dist p‚ÇÇ c‚ÇÇ = r‚ÇÇ) (hpc‚ÇÇ : has_dist.dist p c‚ÇÇ = r‚ÇÇ) : p = p‚ÇÅ ‚à® p = p‚ÇÇ
(X : algebraic_geometry.LocallyRingedSpace) : Top.sheaf CommRing X.to_Top
 : lean.parser ‚Ñï
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommGroup) : category_theory.limits.cone F
{X Y Z : Type u} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : category_theory.limits.limit.cone (category_theory.limits.cospan f g) ‚âÖ category_theory.limits.types.pullback_cone f g
 : bool ‚Üí computability.Œì'
{Œ± : Type u_1} [measurable_space Œ±] (s : set Œ±) : measure_theory.measure Œ±
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) : Type v
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} {ps : set P} (h : ps ‚äÜ ‚Üës) [nonempty ‚Ü•s] {n : ‚Ñï} [finite_dimensional ‚Ñù ‚Ü•(s.direction)] (hd : finite_dimensional.finrank ‚Ñù ‚Ü•(s.direction) = n) (hc : euclidean_geometry.cospherical ps) : ‚àÉ (r : ‚Ñù), ‚àÄ (sx : affine.simplex ‚Ñù P n), set.range sx.points ‚äÜ ps ‚Üí sx.circumradius = r
{C : Type u‚ÇÅ} [category_theory.small_category C] {‚Ñ∞ : Type u‚ÇÇ} [category_theory.category ‚Ñ∞] (A : C ‚•§ ‚Ñ∞) [category_theory.limits.has_colimits ‚Ñ∞] : category_theory.colimit_adj.extend_along_yoneda A ‚ä£ category_theory.colimit_adj.restricted_yoneda A
{Œ± : Type u_2} [has_sub Œ±] : has_sub (filter Œ±)
{Œ± : Type u_1} [has_mul Œ±] [has_le Œ±] [contravariant_class Œ± Œ± has_mul.mul has_le.le] {a b c : Œ±} (bc : a * b ‚â§ a * c) : b ‚â§ c
{C : Type u} [category_theory.category C] {X Y : C} (J : category_theory.grothendieck_topology C) (f : Y ‚ü∂ X) (S : category_theory.sieve X) (h : J.covers S f) {Z : C} (g : Z ‚ü∂ Y) : J.covers S (g ‚â´ f)
(a b c : ‚Ñ§) : Prop
{Œ± : Type u_1} [add_comm_monoid Œ±] {Œ≤ : Type u_2} [fintype Œ≤] (s : set Œ≤) [decidable_pred (Œª (_x : Œ≤), _x ‚àà s)] (f : Œ≤ ‚Üí Œ±) (g : ‚Ü•s ‚Üí Œ±) (w : ‚àÄ (x : Œ≤) (h : x ‚àà s), f x = g ‚ü®x, h‚ü©) (w' : ‚àÄ (x : Œ≤), x ‚àâ s ‚Üí f x = 0) : finset.univ.sum f = finset.univ.sum g
{K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] (h : power_basis K S) : (‚áë(algebra.left_mul_matrix h.basis) h.gen).charpoly = minpoly K h.gen
(n : ‚Ñï) : n.factors.to_finset = finset.filter nat.prime n.divisors
{M : Type u_1} [mul_one_class M] (S : submonoid M) : has_mul ‚Ü•S
 : Type
 : Type
{X : Type u} [preorder X] {x y : X·µí·µñ} (h : opposite.unop x ‚â§ opposite.unop y) : y ‚ü∂ x
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) (X Y : C) [category_theory.limits.has_binary_product X Y] [category_theory.limits.preserves_limit (category_theory.limits.pair X Y) G] : category_theory.limits.is_limit (category_theory.limits.binary_fan.mk (G.map category_theory.limits.prod.fst) (G.map category_theory.limits.prod.snd))
 : interactive.parse interactive.types.pexpr_list_or_texpr ‚Üí tactic unit
{G : Type u_1} [add_group G] {H : add_subgroup G} : has_scalar ‚Ñ§ ‚Ü•H
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} [measurable_space Œ±] [measurable_space Œ≤] [measurable_space Œ≥] [measurable_space Œ¥] (ab : Œ± ‚âÉ·µê Œ≤) (cd : Œ≥ ‚âÉ·µê Œ¥) : Œ± √ó Œ≥ ‚âÉ·µê Œ≤ √ó Œ¥
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : submodule.span R {t : tensor_product R M N | ‚àÉ (m : M) (n : N), m ‚äó‚Çú[R] n = t} = ‚ä§
{Œ± : Type u} [pseudo_metric_space Œ±] : metric.diam ‚àÖ = 0
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] {f g : R ‚Üí+* S} {s : set R} (h : set.eq_on ‚áëf ‚áëg s) : set.eq_on ‚áëf ‚áëg ‚Üë(subsemiring.closure s)
(N : ‚Ñï) : ‚Ñï ‚Ü™ ‚Ñï
{R : Type u_1} [has_add R] (c : R) : Prop
 : bool ‚Üí list string ‚Üí list string
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space.separable_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (h : dense_range f) (h' : continuous f) : topological_space.separable_space Œ≤
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [has_zero N] (f : M ‚Üí N) (hf : f 0 = 0) (g : Œ± ‚Üí‚ÇÄ M) : Œ± ‚Üí‚ÇÄ N
{p : ‚Ñï} [fact (nat.prime p)] {a : zmod p} (ha : a ‚â† 0) : a ^ (p - 1) = 1
(e : expr) : tactic (list (name √ó expr))
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} [category_theory.limits.has_zero_object V] [category_theory.limits.has_kernels V] [category_theory.limits.has_images V] (C : homological_complex V c) (i : Œπ) : ‚Üë(C.boundaries i) ‚ü∂ ‚Üë(C.cycles i)
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÅ} [category_theory.category K] [category_theory.is_preconnected J] (e : J ‚âå K) : category_theory.is_preconnected K
{Œ± : Type u_1} (f : Œ± ‚Üí‚ÇÄ ‚Ñï) : (Œ± ‚Üí‚ÇÄ ‚Ñï) √ó (Œ± ‚Üí‚ÇÄ ‚Ñï) ‚Üí‚ÇÄ ‚Ñï
{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (Œª (g : G √ó G), g.fst + g.snd + -g.fst)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {J' : Type w‚ÇÇ} [category_theory.category J'] (e : J ‚âå J') (F : C ‚•§ D) [category_theory.limits.preserves_colimits_of_shape J F] : category_theory.limits.preserves_colimits_of_shape J' F
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_mul Œ±] [has_add Œ±] [has_le Œ±] [has_mul Œ≤] [has_add Œ≤] [has_le Œ≤] (e : Œ± ‚âÉ+*o Œ≤) : Œ≤ ‚âÉ+*o Œ±
{Œ± : Type u_1} [preorder Œ±] {s : set Œ±} : s.ord_connected ‚Üî ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí x ‚â§ y ‚Üí set.Icc x y ‚äÜ s
{G : Type u_1} [group G] {k : set G} {p : Œ† (x : G), x ‚àà subgroup.closure k ‚Üí Prop} (Hs : ‚àÄ (x : G) (h : x ‚àà k), p x _) (H1 : p 1 _) (Hmul : ‚àÄ (x : G) (hx : x ‚àà subgroup.closure k) (y : G) (hy : y ‚àà subgroup.closure k), p x hx ‚Üí p y hy ‚Üí p (x * y) _) (Hinv : ‚àÄ (x : G) (hx : x ‚àà subgroup.closure k), p x hx ‚Üí p x‚Åª¬π _) {x : G} (hx : x ‚àà subgroup.closure k) : p x hx
{M : Type uM} {N : Type uN} {P : Type uP} {Q : Type uQ} [mul_one_class M] [mul_one_class N] [comm_monoid P] [mul_one_class Q] (f : M ‚Üí* N ‚Üí* P) (g : Q ‚Üí* N) : M ‚Üí* Q ‚Üí* P
(M : Type u_1) [add_monoid M] [measurable_space M] [has_measurable_add‚ÇÇ M] : has_measurable_smul‚ÇÇ ‚Ñï M
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [monoid G] [add_comm_monoid V] [module k V] (œÅ : representation k G V) : monoid_algebra k G ‚Üí‚Çê[k] module.End k V
(h : name) (t : expr) : tactic expr
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J ‚•§ C·µí·µñ) {c : category_theory.limits.cocone F} (hc : category_theory.limits.is_colimit c) : category_theory.limits.is_limit (category_theory.limits.cone_left_op_of_cocone c)
{X Y Z : algebraic_geometry.LocallyRingedSpace} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [H : algebraic_geometry.LocallyRingedSpace.is_open_immersion f] : category_theory.limits.pullback_cone f g
{Œ± : Type u_5} {Œ≤ : Type u_6} [non_assoc_semiring Œ±] [non_assoc_semiring Œ≤] (self : Œ± ‚Üí+* Œ≤) : Œ± ‚Üí*‚ÇÄ Œ≤
{Œ± : Type u} [add_monoid Œ±] : Œ± ‚Üí+ with_top Œ±
{Œ± : Type u} (s : seq Œ±) (n : ‚Ñï) : Prop
(Œ± : Type) [has_zero Œ±] [has_one Œ±] [has_add Œ±] (fromc toc : char) : parser Œ±
 : (user_attribute simp_lemmas)
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÇ] [add_semigroup M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) : add_semigroup M‚ÇÇ
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] : submodule.torsion R (M ‚ß∏ submodule.torsion R M) = ‚ä•
(Œ± : Type u_1) [preorder Œ±] : antisymmetrization Œ± has_le.le ‚Ü™o Œ±
(zc nc : tactic.instance_cache) : expr ‚Üí expr ‚Üí tactic (tactic.instance_cache √ó tactic.instance_cache √ó expr √ó expr)
{Œ± : Type u_1} {c : finset (set Œ±)} (hc : setoid.is_partition ‚Üëc) : finpartition set.univ
{Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ±] [topological_space Œ≤] (f : spectral_map Œ± Œ≤) : C(Œ±, Œ≤)
{K : Type u} [field K] (s : subfield K) {x y : K} : x ‚àà s ‚Üí y ‚àà s ‚Üí x + y ‚àà s
{R : Type u} [semiring R] {P : Type (max u v)} [add_comm_monoid P] [module R P] {M : Type (max u v)} [add_comm_group M] [module R M] {N : Type u_1} [add_comm_group N] [module R N] [h : module.projective R P] (f : M ‚Üí‚Çó[R] N) (g : P ‚Üí‚Çó[R] N) (hf : function.surjective ‚áëf) : ‚àÉ (h : P ‚Üí‚Çó[R] M), f.comp h = g
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {L‚ÇÇ : Type w} [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÇ] (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) (h : function.injective ‚áëf) : L ‚âÉ‚Çó‚ÅÖR‚ÅÜ ‚Ü•(f.range)
{Œ± : Type u_1} [linear_ordered_comm_group Œ±] {n : ‚Ñ§} {a b : Œ±} (hn : n ‚â† 0) : a ^ n = b ^ n ‚Üî a = b
(arg t : expr) : list expr ‚Üí expr ‚Üí expr ‚Üí tactic (expr √ó list expr)
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom B (A √ó B)
{n : ‚Ñï} : zmod n ‚Üí ‚Ñ§
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} {F' : K ‚•§ D} (G : category_theory.limits.cone F ‚•§ category_theory.limits.cone F') [category_theory.limits.preserves_limit (category_theory.functor.empty (category_theory.limits.cone F)) G] {c : category_theory.limits.cone F} (hc : category_theory.limits.is_limit c) : category_theory.limits.is_limit (G.obj c)
 : ‚Ñö ‚Üí ‚Ñö
{Œ± : Type u} [decidable_eq Œ±] [fintype Œ±] [linear_order Œ±] (f : equiv.perm Œ±) : {l // l.prod = f ‚àß ‚àÄ (g : equiv.perm Œ±), g ‚àà l ‚Üí g.is_swap}
{Œ± : Type u} {m : Type u ‚Üí Type u} [alternative m] (f : Œ± ‚Üí m Œ±) : Œ± ‚Üí tactic.mllist m Œ±
(x : Class) : Class
{Œπ : Type u_1} {M : Type u_3} [decidable_eq Œπ] [add_zero_class M] [Œ† (m : M), decidable (m ‚â† 0)] : (Œπ ‚Üí‚ÇÄ M) ‚âÉ+ Œ†‚ÇÄ (i : Œπ), M
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (P : C·µí·µñ ‚•§ Type w) (R : category_theory.presieve X) : Type (max u‚ÇÅ v‚ÇÅ w)
{G : Type u_1} [group G] (H : subgroup G) : group ‚Ü•H
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G : J ‚•§ C} (Œ± : F ‚âÖ G) : category_theory.limits.cone F ‚âå category_theory.limits.cone G
{Œ± : Type u_1} {m : Type u_3} {n : Type u_4} [non_unital_semiring Œ±] [star_ring Œ±] {A : matrix m m Œ±} {B : matrix m n Œ±} {C : matrix n m Œ±} {D : matrix n n Œ±} : (matrix.from_blocks A B C D).is_hermitian ‚Üî A.is_hermitian ‚àß B.conj_transpose = C ‚àß C.conj_transpose = B ‚àß D.is_hermitian
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) (P : Type u_6) [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] : tensor_product R (tensor_product R M N) P ‚âÉ‚Çó[R] tensor_product R M (tensor_product R N P)
{Œ± : Type u_2} {Œ≤ : Type u_3} [add_comm_monoid Œ±] [add_comm_monoid Œ≤] {A : set Œ±} {n : ‚Ñï} : add_comm_monoid (A ‚Üí+[n] Œ≤)
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_zero_class M] {f : Œ± ‚Üí Œ≤} (hf : function.injective f) (v‚ÇÅ v‚ÇÇ : Œ≤ ‚Üí‚ÇÄ M) : finsupp.comap_domain f (v‚ÇÅ + v‚ÇÇ) _ = finsupp.comap_domain f v‚ÇÅ _ + finsupp.comap_domain f v‚ÇÇ _
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_group E] [has_scalar ùïú E] (S : convex_cone ùïú E) : Prop
{M : Type u_1} [has_mul M] {c d : con M} : c ‚äî d = con_gen (setoid.r ‚äî setoid.r)
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {f' : F} {x : ùïú} [partial_order ùïú] : has_deriv_within_at f f' (set.Iic x) x ‚Üí has_deriv_within_at f f' (set.Iio x) x
{Œ± : Type u_2} [decidable_eq Œ±] [has_mul Œ±] [has_distrib_neg Œ±] : has_distrib_neg (finset Œ±)
(n : ‚Ñï) : ‚áëmultiset.card (multiset.nat.antidiagonal n) = n + 1
{M : Type u_12} {N : Type u_13} [has_mul M] [has_mul N] (self : M ‚âÉ* N) : M ‚Üí‚Çô* N
{Œ± : Type u_1} {Œ≤ : Type u_2} {mŒ≤ : measurable_space Œ≤} {m : measurable_space Œ±} (t : ‚Ñï ‚Üí set Œ≤) (t_meas : ‚àÄ (n : ‚Ñï), measurable_set (t n)) (t_disj : pairwise (disjoint on t)) (g : ‚Ñï ‚Üí Œ≤ ‚Üí Œ±) (hg : ‚àÄ (n : ‚Ñï), measurable (g n)) : ‚àÉ (f : Œ≤ ‚Üí Œ±), measurable f ‚àß ‚àÄ (n : ‚Ñï) (x : Œ≤), x ‚àà t n ‚Üí f x = g n x
{C : Type u‚ÇÅ} [category_theory.category C] : category_theory.creates_limits_of_size (ùü≠ C)
(mvar assignment : expr) : tactic.unsafe.type_context unit
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {p : formal_multilinear_series ùïú E F} {x : E} {r : ennreal} {r' : nnreal} (hf : has_fpower_series_on_ball f p x r) (h : ‚Üër' < r) : tendsto_uniformly_on (Œª (n : ‚Ñï) (y : E), p.partial_sum n y) (Œª (y : E), f (x + y)) filter.at_top (metric.ball 0 ‚Üër')
{Œ± : Sort u} {Œ≤ : Sort v} (e : Œ± ‚âÉ Œ≤) : is_empty Œ± ‚Üî is_empty Œ≤
(R : Type u_1) (S : Type u_2) (M : Type u_3) [semiring S] [add_comm_monoid M] [comm_semiring R] [algebra R S] [module S·µê·µí·µñ M] : module R·µê·µí·µñ (restrict_scalars R S M)
{Œ± : Type u} (s : set (set Œ±)) : (quotient.out (cardinal.aleph 1).ord).Œ± ‚Üí set (set Œ±)
{M : Type u_1} [has_add M] {c d : add_con M} : c ‚äî d = add_con_gen (setoid.r ‚äî setoid.r)
{Œ± : Type u_1} {A : Type u_3} [has_zero A] (f : Œ± ‚Üí A) : set Œ±
(R : Type u) [semiring R] (P : Type (max u v)) [add_comm_monoid P] [module R P] : Prop
{R : Type u} [non_assoc_semiring R] (M : submonoid R) : M.subsemiring_closure = subsemiring.closure ‚ÜëM
(Œ± : Sort u) : Sort (max 1 u)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} (f g : C ‚ü∂ D) (w : (homotopy_category.quotient V c).map f = (homotopy_category.quotient V c).map g) : homotopy f g
(n : ‚Ñï) : fintype ‚Ü•(set.Iio n)
{Œ± : Type u} {Œ≤ : Type v} [emetric_space Œ±] [pseudo_emetric_space Œ≤] {f : Œ± ‚Üí Œ≤} (h : isometry f) : Œ± ‚âÉ·µ¢ ‚Ü•(set.range f)
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [ring R] [linear_ordered_comm_group_with_zero Œì‚ÇÄ] (v : valuation R Œì‚ÇÄ) (Œ≥ : Œì‚ÇÄÀ£) : add_subgroup R
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] : is_compl K K·óÆ
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {B : Type u‚ÇÑ} [category_theory.category B] (F : B ‚•§ C) (G : C ‚•§ D) (S : D) : category_theory.costructured_arrow (F ‚ãô G) S ‚•§ category_theory.costructured_arrow G S
{R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [add_comm_group N] [module R M] [module R N] [lie_ring_module L M] [lie_ring_module L N] [lie_module R L M] [lie_module R L N] (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (g : N ‚Üí M) (h‚ÇÅ : function.left_inverse g ‚áëf) (h‚ÇÇ : function.right_inverse g ‚áëf) : N ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M
{Œ± Œ≤ : Type u} {F : Type u ‚Üí Type u} [applicative F] [is_comm_applicative F] [decidable_eq Œ≤] (f : Œ± ‚Üí F Œ≤) (s : finset Œ±) : F (finset Œ≤)
(R : Type u) [semiring R] {Œπ : Type v} {M : Œπ ‚Üí Type w} [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] {Œ∫ : Type u_1} (h : Œπ ‚âÉ Œ∫) : direct_sum Œπ (Œª (i : Œπ), M i) ‚âÉ‚Çó[R] direct_sum Œ∫ (Œª (k : Œ∫), M (‚áë(h.symm) k))
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) (P : Prop) [decidable P] (a b : Œ±) : f (ite P a b) = ite P (f a) (f b)
 : string ‚Üí bool
{a b : ‚Ñù} {g' g : ‚Ñù ‚Üí ‚Ñù} (hab : a ‚â§ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí has_deriv_within_at g (g' x) (set.Ioi x) x) (g'int : measure_theory.integrable_on g' (set.Icc a b) measure_theory.measure_space.volume) : ‚à´ (y : ‚Ñù) in a..b, g' y = g b - g a
{p : ‚Ñï} (hp : 1 < p) : padic_norm p ‚Üëp = 1 / ‚Üëp
{R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [semiring R] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] [semi_normed_group E] [semi_normed_group E‚ÇÇ] [module R E] [module R‚ÇÇ E‚ÇÇ] {Œπ : Type u_3} (b : basis Œπ R E) {f‚ÇÅ f‚ÇÇ : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : ‚àÄ (i : Œπ), ‚áëf‚ÇÅ (‚áëb i) = ‚áëf‚ÇÇ (‚áëb i)) : f‚ÇÅ = f‚ÇÇ
{E : Type u_1} [add_comm_group E] [star_add_monoid E] [module ‚ÑÇ E] [star_module ‚ÑÇ E] : E ‚Üí‚Çó[‚Ñù] ‚Ü•(self_adjoint E)
(cl : tactic.closure) : expr ‚Üí tactic (‚Ñï √ó expr √ó expr)
{n : ‚Ñï} (R : Type u_1) [ring R] [fact (0 < n)] : coe ‚àò zmod.val = coe
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f f‚ÇÅ : E ‚Üí F} {n : with_top ‚Ñï} {p : E ‚Üí formal_multilinear_series ùïú E F} (h : has_ftaylor_series_up_to_on n f p s) (h‚ÇÅ : ‚àÄ (x : E), x ‚àà s ‚Üí f‚ÇÅ x = f x) : has_ftaylor_series_up_to_on n f‚ÇÅ p s
{R : Type u_1} (S : Type u_4) [semiring R] [semiring S] {M : Type u_6} [topological_space M] [add_comm_monoid M] [module R M] {N‚ÇÇ : Type u_9} [topological_space N‚ÇÇ] [add_comm_monoid N‚ÇÇ] [module R N‚ÇÇ] {N‚ÇÉ : Type u_10} [topological_space N‚ÇÉ] [add_comm_monoid N‚ÇÉ] [module R N‚ÇÉ] [module S N‚ÇÇ] [has_continuous_const_smul S N‚ÇÇ] [smul_comm_class R S N‚ÇÇ] [module S N‚ÇÉ] [smul_comm_class R S N‚ÇÉ] [has_continuous_const_smul S N‚ÇÉ] [has_continuous_add N‚ÇÇ] [has_continuous_add N‚ÇÉ] : ((M ‚ÜíL[R] N‚ÇÇ) √ó (M ‚ÜíL[R] N‚ÇÉ)) ‚âÉ‚Çó[S] M ‚ÜíL[R] N‚ÇÇ √ó N‚ÇÉ
 : expr ‚Üí tactic omega.int.exprterm
{Œ± : Type u_3} {Œ≤ : Type u_4} [has_sup Œ±] [has_sup Œ≤] (f : sup_hom Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : sup_hom Œ± Œ≤
(C : Type u‚ÇÅ) [category_theory.category C] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D) [category_theory.limits.preserves_finite_limits F] : category_theory.limits.preserves_finite_colimits F.right_op
(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u} [category_theory.category J] {X : J} (tX : category_theory.limits.is_terminal X) (F : J ‚•§ C) : category_theory.limits.cocone F
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : Œ±) (s : finset Œ±) : Prop
 : turing.to_partrec.code ‚Üí list ‚Ñï ‚Üí. list ‚Ñï
 : onote ‚Üí onote √ó ‚Ñï
(S : Type u_4) (M : out_param (Type u_5)) [has_add M] [set_like S M] : Type
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] : conditionally_complete_lattice (with_top Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (h : category_theory.presieve.is_sheaf_for P ‚áëS) {f : S.functor ‚ü∂ P} (t : category_theory.yoneda.obj X ‚ü∂ P) (ht : S.functor_inclusion ‚â´ t = f) : t = h.extend f
{E : Type u_2} [semi_normed_group E] [normed_space ‚Ñù E] (s : set E) : emetric.diam (‚áë(convex_hull ‚Ñù) s) = emetric.diam s
{C : Type u} [category_theory.category C] [category_theory.abelian C] {X Y : C} {f : X ‚ü∂ Y} [category_theory.mono f] (s : category_theory.limits.cofork f 0) (h : category_theory.limits.is_colimit s) : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ f _)
{Œ± : Type u_1} : list Œ± ‚Üí Prop
(p : Set ‚Üí Prop) : Class.iota p ‚àà Class.univ
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] [has_add Œ≤] : Œ± ‚âÉ+ Œ≤ ‚âÉ (Œ±·µÉ·µí·µñ ‚âÉ+ Œ≤·µÉ·µí·µñ)
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_sizeof Œ±] [has_sizeof Œ≤] (shrink_Œ± : slim_check.shrink_fn Œ±) (shrink_Œ≤ : slim_check.shrink_fn Œ≤) : slim_check.shrink_fn (Œ± ‚äï Œ≤)
{p : ‚Ñï} {R : Type u_1} (x : witt_vector p R) (n : ‚Ñï) : witt_vector p R
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : complete_lattice (lie_submodule R L M)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space F] [complete_space E] (f : E ‚ÜíL[ùïú] F) (hinj : f.ker = ‚ä•) (hsurj : f.range = ‚ä§) : E ‚âÉL[ùïú] F
 : (user_attribute unit)
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {F F' : C ‚•§ D} (h : F ‚âÖ F') {Y : D} (hY : Y ‚àà F.ess_image) : Y ‚àà F'.ess_image
(Œ± : Type u_1) : Type u_1
{ùïú : Type u_1} [is_R_or_C ùïú] {F : Type u_2} [semi_normed_group F] [normed_space ùïú F] (fr : restrict_scalars ‚Ñù ùïú F ‚Üí‚Çó[‚Ñù] ‚Ñù) : F ‚Üí‚Çó[ùïú] ùïú
{V : Type u} {G : simple_graph V} {G' G'' : G.subgraph} [decidable_rel G'.adj] (h : G' ‚â§ G'') (v : ‚Ü•(G'.verts)) [hf : fintype ‚Ü•(G''.neighbor_set ‚Üëv)] : fintype ‚Ü•(G'.neighbor_set ‚Üëv)
{Œ± : Type u} (c : order.frame Œ±) (le : Œ± ‚Üí Œ± ‚Üí Prop) (eq_le : le = order.frame.le) (top : Œ±) (eq_top : top = order.frame.top) (bot : Œ±) (eq_bot : bot = order.frame.bot) (sup : Œ± ‚Üí Œ± ‚Üí Œ±) (eq_sup : sup = order.frame.sup) (inf : Œ± ‚Üí Œ± ‚Üí Œ±) (eq_inf : inf = order.frame.inf) (Sup : set Œ± ‚Üí Œ±) (eq_Sup : Sup = order.frame.Sup) (Inf : set Œ± ‚Üí Œ±) (eq_Inf : Inf = order.frame.Inf) : order.frame Œ±
{ùïú : Type u_1} {E : Type u_2} [ordered_ring ùïú] [add_comm_group E] [module ùïú E] (K : geometry.simplicial_complex ùïú E) : set E
{Œ± : Type u} {Œ≤ : Type v} [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] (c : omega_complete_partial_order.chain (Œ± ‚Üío Œ≤)) : Œ± ‚Üío Œ≤
 : (user_attribute simp_lemmas)
{K : Type u_1} {L : Type u_2} {M : Type u_3} [field K] [field L] [field M] [algebra K L] [algebra K M] {E1 E2 : intermediate_field K L} (e : L ‚âÉ‚Çê[K] M) (h12 : E1 ‚â§ E2) : E1.map e.to_alg_hom ‚â§ E2.map e.to_alg_hom
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] {i : D.to_glue_data.J} (U : topological_space.opens ‚Ü•((D.to_glue_data.U i).carrier)) (j : D.to_glue_data.J) : category_theory.limits.limit (D.diagram_over_open U) ‚ü∂ (D.diagram_over_open U).obj (opposite.op (category_theory.limits.walking_multispan.right j))
 : omega.clause ‚Üí tactic (list omega.ee)
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] (f : Œ± ‚âÉ·µ§ Œ≤) (g : Œ≤ ‚Üí Œ±) (hg : function.right_inverse g ‚áëf) : Œ± ‚âÉ·µ§ Œ≤
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} [fintype Œπ] {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (l : Œπ ‚Üí ùïú) (i : Œπ) : has_inner.inner (finset.univ.sum (Œª (i : Œπ), l i ‚Ä¢ v i)) (v i) = ‚áë(star_ring_end ùïú) (l i)
 : expr ‚Üí expr ‚Üí tactic.norm_fin.eval_fin_m (expr √ó expr)
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommRing) : category_theory.limits.is_colimit (CommRing.filtered_colimits.colimit_cocone F)
{n : ‚Ñï} (hn : 2 ‚â§ n) : strict_convex_on ‚Ñù (set.Ici 0) (Œª (x : ‚Ñù), x ^ n)
{Œ± : Type u_1} [preorder Œ±] {a b : Œ±} (h : a ‚â§ b) : order_bot ‚Ü•(set.Icc a b)
(c1 c2 : linarith.comp) : linarith.comp
{R : Type u_1} {M : Type u_2} {P : Type u_3} [ring R] [add_comm_group M] [module R M] [add_comm_group P] [module R P] (f : M ‚Üí‚Çó[R] P) {s : submodule R M} (hs1 : (submodule.map f s).fg) (hs2 : (s ‚äì f.ker).fg) : s.fg
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {Œπ : Type w} {p : Œπ ‚Üí submodule K V} (hp : complete_lattice.independent p) [fintype {i // p i ‚â† ‚ä•}] : fintype.card {i // p i ‚â† ‚ä•} ‚â§ finite_dimensional.finrank K V
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.initial_mono_class C] {X : C} (f : category_theory.mono_over X) : ‚ä• ‚ü∂ f
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D·µí·µñ) [category_theory.limits.preserves_colimits F] : category_theory.limits.preserves_limits F.left_op
(Œ± : Type u) : Type u
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_mem Œ± Œ≤] {s t : Œ≤} {a : Œ±} : a ‚àà s ‚Üí a ‚àâ t ‚Üí s ‚â† t
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [semiring R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] [topological_space (bundle.total_space E)] (e e' : topological_vector_bundle.trivialization R F E) (b : B) : F ‚âÉL[R] F
{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a
{K : Type u_1} {L : Type u_2} {A : Type u_5} [field K] [field L] [comm_ring A] [algebra K L] [algebra L A] [algebra K A] [is_scalar_tower K L A] (L_alg : algebra.is_algebraic K L) (A_alg : algebra.is_algebraic L A) : algebra.is_algebraic K A
{X Y : SemiNormedGroup} (f : X ‚ü∂ Y) : category_theory.limits.cofork f 0
{et et' : tactic.ring_exp.ex_type} (ps : tactic.ring_exp.ex et) (qs : tactic.ring_exp.ex et') : tactic.ring_exp.ring_exp_m expr
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] (a : Œ±) : Œ± ‚âÉo Œ±
{Œ± : Type u} : dense_range has_pure.pure
{V : Type u} : has_inf (simple_graph V)
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (œÅ : representation k G V) [fintype G] [invertible ‚Üë(fintype.card G)] : V ‚Üí‚Çó[k] V
{Œ± : Type u} [semiring Œ±] {x y : Œ±} (h : commute x y) (n : ‚Ñï) : (finset.range n).sum (Œª (i : ‚Ñï), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {E' : Type u_7} [inner_product_space ùïú E'] (f : E ‚Üí‚Çó·µ¢[ùïú] E') (x y : E) : has_inner.inner (‚áëf x) (‚áëf y) = has_inner.inner x y
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí. Œ≤) (l‚ÇÅ : filter Œ±) (l‚ÇÇ : filter Œ≤) : Prop
{C : Type u} [category_theory.category C] [category_theory.abelian C] {X Y : C} [category_theory.simple X] {f : X ‚ü∂ Y} [category_theory.epi f] (w : f ‚â† 0) : category_theory.is_iso f
{M : Type u_3} [add_monoid M] (l : list M) : (l.nth 0).get_or_else 0 + l.tail.sum = l.sum
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] : continuous_map.compact_open = ‚®Ö (s : set Œ±) (hs : is_compact s), topological_space.induced (continuous_map.restrict s) continuous_map.compact_open
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type v} (f : J ‚Üí C) [category_theory.limits.has_product f] [category_theory.limits.has_product (Œª (j : J), G.obj (f j))] [category_theory.limits.preserves_limit (category_theory.discrete.functor f) G] : G.obj (‚àè f) ‚âÖ ‚àè Œª (j : J), G.obj (f j)
{C : Type u} [category_theory.category C] {f g : category_theory.arrow C} [‚àÄ (n : ‚Ñï), category_theory.limits.has_wide_pullback f.right (Œª (i : ulift (fin (n + 1))), f.left) (Œª (i : ulift (fin (n + 1))), f.hom)] [‚àÄ (n : ‚Ñï), category_theory.limits.has_wide_pullback g.right (Œª (i : ulift (fin (n + 1))), g.left) (Œª (i : ulift (fin (n + 1))), g.hom)] (F : f ‚ü∂ g) : f.cech_nerve ‚ü∂ g.cech_nerve
{A : Type u_1} [normed_ring A] [normed_algebra ‚ÑÇ A] [complete_space A] [star_ring A] [cstar_ring A] [star_module ‚ÑÇ A] [nontrivial A] (a : ‚Ü•(self_adjoint A)) {z : ‚ÑÇ} (hz : z ‚àà spectrum ‚ÑÇ ‚Üëa) : z = ‚Üë(z.re)
(R : Type u) [comm_semiring R] (A : Type v) [semiring A] [algebra R A] (n : Type w) (a : A) : matrix n n R ‚Üí‚Çó[R] matrix n n A
{n : Type u} [decidable_eq n] [fintype n] {Œ± : Type v} [comm_ring Œ±] (A : matrix n n Œ±) : matrix n n Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop} (f : r ‚âÉr s) (g : principal_seg s t) : principal_seg r t
{n : ‚Ñï} {C : fin n.succ ‚Üí Sort u_1} (H0 : C 0) (Hs : Œ† (i : fin n), C i.succ) (i : fin n.succ) : C i
{R : Type u} [ring R] [rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Œπ : Type u_1} (b : basis Œπ R M) {w : set M} [fintype ‚Ü•w] (s : submodule.span R w = ‚ä§) : cardinal.mk Œπ ‚â§ ‚Üë(fintype.card ‚Ü•w)
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : ‚áë(v.valuation) (‚áë(algebra_map R K) r) < 1 ‚Üî v.as_ideal ‚à£ ideal.span {r}
{Œ± : Type u} [semilattice_inf Œ±] [order_bot Œ±] {a : Œ±} : disjoint a a ‚Üí a = ‚ä•
{X : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [fintype Œ±] [topological_space X] (f : Œ± ‚Üí locally_constant X Œ≤) : locally_constant X (Œ± ‚Üí Œ≤)
{R : Type u‚ÇÅ} [non_unital_non_assoc_semiring R] : is_scalar_tower ‚Ñï R R
(constr lem : name) (persistent : bool) : tactic unit
(ic zc : tactic.instance_cache) (a' : expr) : tactic (tactic.instance_cache √ó tactic.instance_cache √ó expr √ó expr)
{R : Type u_1} [comm_ring R] {x‚ÇÅ x‚ÇÇ y‚ÇÅ y‚ÇÇ n : R} : (x‚ÇÅ ^ 2 + n * x‚ÇÇ ^ 2) * (y‚ÇÅ ^ 2 + n * y‚ÇÇ ^ 2) = (x‚ÇÅ * y‚ÇÅ - n * x‚ÇÇ * y‚ÇÇ) ^ 2 + n * (x‚ÇÅ * y‚ÇÇ + x‚ÇÇ * y‚ÇÅ) ^ 2
{Œ± : Type u} [pseudo_metric_space Œ±] : metric_space (uniform_space.completion Œ±)
{Œ± : Type u_1} {Œ≤ : Type u_2} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] (K : nnreal) (f : Œ± ‚Üí Œ≤) : Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_products C
{K : Type u_3} {L : Type u_4} [field K] [field L] [algebra K L] (A : subalgebra K L) (hKL : algebra.is_algebraic K L) : is_field ‚Ü•A
{P : pfunctor} : P.W ‚Üí P.A
{Œπ : Type u} (s : finset Œπ) (f g : Œπ ‚Üí nnreal) {p : ‚Ñù} (hp : 1 ‚â§ p) : s.sum (Œª (i : Œπ), (f i + g i) ^ p) ^ (1 / p) ‚â§ s.sum (Œª (i : Œπ), f i ^ p) ^ (1 / p) + s.sum (Œª (i : Œπ), g i ^ p) ^ (1 / p)
{L : first_order.language} {M : Type u_3} [L.Structure M] (N : L.substructure M) : Prop
{M : Type u_1} {A : Type u_2} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (f : A ‚Üí M) (t : finset A) : (‚àÄ (b : A), b ‚àà t ‚Üí f b ‚àà s) ‚Üí t.sum (Œª (b : A), f b) ‚àà s
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (R : Type u_3) [semiring R] [add_comm_monoid Y] [module R Y] [has_continuous_add Y] [has_continuous_const_smul R Y] : locally_constant X Y ‚Üí‚Çó[R] C(X, Y)
 : has_pow ordinal ordinal
{Œ≤ : Type w} {C : Type u} [category_theory.category C] {f g : Œ≤ ‚Üí C} [category_theory.limits.has_coproducts_of_shape Œ≤ C] (p : Œ† (b : Œ≤), f b ‚âÖ g b) : ‚àê f ‚âÖ ‚àê g
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] {p : P} : ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p) = p ‚Üî p ‚àà s
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (e : local_homeomorph Œ± Œ≤) {f : Œ≥ ‚Üí Œ±} {s : set Œ≥} (h : s ‚äÜ f ‚Åª¬π' e.to_local_equiv.source) : continuous_on f s ‚Üî continuous_on (‚áëe ‚àò f) s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h1 : ‚Üës1.nonempty) (h2 : ‚Üës2.nonempty) (hd : s1.direction ‚äî s2.direction = ‚ä§) : (‚Üës1 ‚à© ‚Üës2).nonempty
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (N : submonoid S) : submonoid R
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (F : C ‚•§ D) {G H : D ‚•§ E} (Œ± : G ‚âÖ H) : F ‚ãô G ‚âÖ F ‚ãô H
{X Y : Type u} (f g : X ‚ü∂ Y) : Y ‚Üí Y ‚Üí Prop
 : Prop ‚âÉ bool
{Œ± Œ≤ : PartialOrder} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] {Z : D} (F : C ‚•§ D) (M : Œ† (x : C), Z ‚ü∂ F.obj x) (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), M x ‚â´ F.map f = M y) (G : category_theory.with_initial C ‚•§ D) (h : category_theory.with_initial.incl ‚ãô G ‚âÖ F) (hG : G.obj category_theory.with_initial.star ‚âÖ Z) (hh : ‚àÄ (x : C), hG.symm.hom ‚â´ G.map (category_theory.with_initial.star_initial.to (category_theory.with_initial.incl.obj x)) = M x ‚â´ h.symm.hom.app x) : G ‚âÖ category_theory.with_initial.lift F M hM
{Œ± : Type u} [has_subset Œ±] [has_ssubset Œ±] [is_nonstrict_strict_order Œ± has_subset.subset has_ssubset.ssubset] {a b c : Œ±} [is_trans Œ± has_subset.subset] (h‚ÇÅ : a ‚äÜ b) (h‚ÇÇ : b ‚äÇ c) : a ‚äÇ c
 : pos_num ‚Üí list turing.partrec_to_TM2.Œì'
{G : Type u_1} [group G] (H : subgroup G) : ‚Ñï
(ùïú : Type u_1) {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] (s : set E) : Prop
 : Type_to_Pointed ‚ä£ category_theory.forget Pointed
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (h : M ‚âÉ+ N) : is_add_monoid_hom ‚áëh
{M : Type u_3} {S : Type u_4} [div_inv_monoid M] [set_like S M] [hSM : subgroup_class S M] {H : S} : has_div ‚Ü•H
(c : tactic.instance_cache) (e : expr) : tactic (tactic.instance_cache √ó expr)
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] {E : Type w} [normed_group E] [normed_space ùïú E] {f : ùïú ‚Üí F} {f' : F} (x : ùïú) {l : F ‚Üí E} {l' : F ‚ÜíL[ùïú] E} (hl : has_fderiv_at l l' (f x)) (hf : has_deriv_at f f' x) : has_deriv_at (l ‚àò f) (‚áël' f') x
 : tactic.eliminate.constructor_argument_naming_rule
{m : Type u_1} {n : Type u_2} [decidable_eq n] [fintype n] [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (e : m ‚âÉ n) (A : matrix m m R) : (‚áë(matrix.reindex e e) A).det = A.det
 : Type
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F F' : C ‚•§ D} {G : D ‚•§ C} (adj1 : F ‚ä£ G) (adj2 : F' ‚ä£ G) : F ‚âÖ F'
{Œ± : Type u} {Œ≤ : Type v} [has_add Œ≤] : (Œ± ‚Üí Œ≤) ‚âÉ add_hom (free_add_magma Œ±) Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} (ea : equiv.perm Œ±) (eb : equiv.perm Œ≤) : equiv.perm (Œ± ‚äï Œ≤)
{Œ± : Type u} : Œ± ‚Üí Œ±·µê·µí·µñ
(V : Type u) : simple_graph V
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ùïú] [inner_product_space ùïú E] [inner_product_space ùïú F] [complete_space E] [complete_space F] (A : E ‚ÜíL[ùïú] F) : ‚áëcontinuous_linear_map.adjoint (‚áëcontinuous_linear_map.adjoint A) = A
{K : Type u_3} {V : Type u_8} [field K] [invertible 2] [add_comm_group V] [module K V] (Q : quadratic_form K V) (v : basis (fin (finite_dimensional.finrank K V)) K V) (hv‚ÇÅ : (‚áëquadratic_form.associated Q).is_Ortho ‚áëv) : Q.isometry (quadratic_form.weighted_sum_squares K (Œª (i : fin (finite_dimensional.finrank K V)), ‚áëQ (‚áëv i)))
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {s : set E} {x : E} : unique_mdiff_within_at (model_with_corners_self ùïú E) s x ‚Üí unique_diff_within_at ùïú s x
{C : Type u} [category_theory.category C] (B : C) {J : Type v} (F : category_theory.discrete J ‚•§ category_theory.over B) : category_theory.limits.cone (category_theory.over.construct_products.wide_pullback_diagram_of_diagram_over B F) ‚•§ category_theory.limits.cone F
{Œ± : Type u_2} {Œ≤ : Type u_3} [comm_monoid Œ±] [cancel_comm_monoid Œ≤] {A : set Œ±} {m n : ‚Ñï} (h : m ‚â§ n) (f : A ‚Üí*[n] Œ≤) : A ‚Üí*[m] Œ≤
{Œ± : Sort u_1} : trunc Œ± ‚Üí Œ±
 : category_theory.is_equivalence Compactum_to_CompHaus
{Œ± : Type u_1} [topological_space Œ±] {R : Type u_2} [comm_semiring R] {A : Type u_3} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] [has_continuous_const_smul R A] (s : subalgebra R C(Œ±, A)) : Prop
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {f : filter Œ±} [is_trans Œ± r] (a : Œ±) (h : ‚àÄ (s : set Œ±), s ‚àà f ‚Üí (‚àÉ (x : Œ±) (H : x ‚àà s), r a x)) : filter.is_cobounded r f
{M : Type u_1} [has_add M] : has_top (add_subsemigroup M)
{Œ± : Sort u} [decidable_eq Œ±] (a b r : Œ±) : Œ±
 : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : category_theory.grothendieck_topology C) (K : category_theory.grothendieck_topology D) (G : C ‚•§ D) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (f g : category_theory.mono_over X) : subsingleton (f ‚ü∂ g)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : Prop
{S : Type u‚ÇÅ} {L : Type u‚ÇÇ} {D : Type u‚ÇÉ} [category_theory.category S] [category_theory.category L] [category_theory.category D] (Œπ : S ‚•§ L) [‚àÄ (X : L), category_theory.limits.has_colimits_of_shape (category_theory.costructured_arrow Œπ X) D] : (S ‚•§ D) ‚•§ L ‚•§ D
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {f : E ‚Üí G} {x : E √ó F} (hf : cont_diff_at ùïú n f x.fst) : cont_diff_at ùïú n (Œª (x : E √ó F), f x.fst) x
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.final] {E : Type u} [category_theory.category E] (G : D ‚•§ E) : category_theory.limits.cocone (F ‚ãô G) ‚âå category_theory.limits.cocone G
{R : Type u_1} {S : Type u_3} [ring R] [ring S] : ring (R √ó S)
 : expr ‚Üí tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum)
{R : Type u} [ring R] : category_theory.enough_projectives (Module R)
(M : Type u_1) [monoid M] (X : Type u) [mul_action M X] : category_theory.single_obj M ‚•§ Type u
{Œ± : Type u_1} (p : pmf Œ±) (s : set Œ±) (h : ‚àÉ (a : Œ±) (H : a ‚àà s), a ‚àà p.support) : pmf Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} : list Œ± ‚Üí list Œ≤ ‚Üí list (Œ± √ó option Œ≤) √ó list Œ≤
{Œ± : Type v} {s : finset Œ±} {M : Type u_1} [add_comm_monoid M] (f : Œ± ‚Üí M) (p : M ‚Üí Prop) (p_mul : ‚àÄ (a b : M), p a ‚Üí p b ‚Üí p (a + b)) (hs_nonempty : s.nonempty) (p_s : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p (f x)) : p (s.sum (Œª (x : Œ±), f x))
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤] (K : set Œ±) (V : set (Œ≤ √ó Œ≤)) (f : C(Œ±, Œ≤)) : set C(Œ±, Œ≤)
{Œ± : Type u_1} [partial_order Œ±] [order_top Œ±] {a : Œ±} : a ‚ãñ ‚ä§ ‚Üí is_coatom a
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (E : Type u_2) [normed_group E] [normed_space ùïú E] : (model_with_corners_self ùïú E).to_local_equiv = local_equiv.refl E
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : Type w) [category_theory.category J] (F : C·µí·µñ ‚•§ D·µí·µñ) [category_theory.limits.preserves_limits_of_shape J·µí·µñ F] : category_theory.limits.preserves_colimits_of_shape J F.unop
{K : Type u_1} [is_R_or_C K] : K ‚âÉL[‚Ñù] K
{Œ± : Type u_1} {M : Type u_5} [add_zero_class M] (a : Œ±) : M ‚Üí+ Œ± ‚Üí‚ÇÄ M
 : multiset ‚Ñï+
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_binary_products C] [category_theory.limits.has_binary_products D] (F : C ‚•§ D) (A : C) : category_theory.limits.prod.functor.obj A ‚ãô F ‚ü∂ F ‚ãô category_theory.limits.prod.functor.obj (F.obj A)
{Œ± : Type v} {s : finset Œ±} {M : Type u_1} [comm_monoid M] (f : Œ± ‚Üí M) (p : M ‚Üí Prop) (p_mul : ‚àÄ (a b : M), p a ‚Üí p b ‚Üí p (a * b)) (hs_nonempty : s.nonempty) (p_s : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p (f x)) : p (s.prod (Œª (x : Œ±), f x))
 : linarith.certificate_oracle
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), add_comm_group (A i)] [add_comm_monoid Œπ] [direct_sum.gcomm_semiring A] : comm_ring (direct_sum Œπ (Œª (i : Œπ), A i))
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] (X : C) : category_theory.is_pushout (ùüô X) 0 0 0
{Œπ : Type u_1} {ùïú : Type u_3} [is_R_or_C ùïú] [fintype Œπ] [decidable_eq Œπ] (i : Œπ) (a : ùïú) : euclidean_space ùïú Œπ
{p : ‚Ñï} {G : Type u_1} [group G] {H : Type u_2} [group H] {f : H ‚Üí* G} (hf : function.injective ‚áëf) [fintype (sylow p G)] : fintype (sylow p H)
{Œ± : Type u_1} (l : ordnode Œ±) (x : Œ±) (r : ordnode Œ±) : ordnode Œ±
{a b : ‚Ñù} (h : a < b) : cardinal.mk ‚Ü•(set.Ico a b) = cardinal.continuum
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] (l : list Œ±) : list (‚Ñï √ó Œ±)
(F : Type u‚ÇÄ ‚Üí Type u‚ÇÅ ‚Üí Type u‚ÇÇ) : Type (max (u‚ÇÄ+1) (u‚ÇÅ+1) u‚ÇÇ)
{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : isometry f) (x y : Œ±) : has_nndist.nndist (f x) (f y) = has_nndist.nndist x y
{Œ± : Type u_1} {M : Type u_5} [add_zero_class M] (a : Œ±) : (Œ± ‚Üí‚ÇÄ M) ‚Üí+ Œ± ‚Üí‚ÇÄ M
 : ‚Ü•algebraic_geometry.AffineScheme ‚âå CommRing·µí·µñ
(h : interactive.parse (optional lean.parser.ident)) (t : interactive.parse (optional (lean.parser.tk ":" *> interactive.types.texpr))) : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [compact_space Œ±] [metric_space Œ≤] {f g : C(Œ±, Œ≤)} (x : Œ±) : has_dist.dist (‚áëf x) (‚áëg x) ‚â§ has_dist.dist f g
{Œπ : Type u_1} [decidable_eq Œπ] {R : Type u_4} [comm_semiring R] {s : Œπ ‚Üí Type u_7} [Œ† (i : Œπ), add_comm_monoid (s i)] [Œ† (i : Œπ), module R (s i)] {E : Type u_9} [add_comm_monoid E] [module R E] : multilinear_map R s E ‚âÉ‚Çó[R] pi_tensor_product R (Œª (i : Œπ), s i) ‚Üí‚Çó[R] E
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] (F : Œπ ‚Üí Œ± ‚Üí Œ≤) (p : filter Œπ) (s : set Œ±) : Prop
(p : Type u_2) (q : Type u_3) (R : Type u‚ÇÇ) [decidable_eq p] [decidable_eq q] [comm_ring R] [fintype p] [fintype q] : lie_subalgebra R (matrix (p ‚äï q) (p ‚äï q) R)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] [normed_group G] [normed_space ùïú G] {g : F ‚Üí G} {f : E ‚Üí F} {x : E} (hg : analytic_at ùïú g (f x)) (hf : analytic_at ùïú f x) : analytic_at ùïú (g ‚àò f) x
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R ‚Üí+* S) : polynomial R ‚Üí polynomial S
(X : Type u_1) [topological_space X] : Prop
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] {f g : add_hom M N} {s : set M} (h : set.eq_on ‚áëf ‚áëg s) : set.eq_on ‚áëf ‚áëg ‚Üë(add_subsemigroup.closure s)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : category_theory.monoidal_category D
{Œ± : Type u_1} [preorder Œ±] (a : ‚Ñï ‚Üío Œ±) : ‚Ñï
(type : name) : tactic unit
{ùïú : Type u_1} {V : Type u_2} {V‚ÇÇ : Type u_4} {V‚ÇÉ : Type u_5} {P : Type u_8} {P‚ÇÇ : Type u_9} {P‚ÇÉ : Type u_10} [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [semi_normed_group V‚ÇÉ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] [normed_space ùïú V‚ÇÉ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [pseudo_metric_space P‚ÇÉ] [normed_add_torsor V P] [normed_add_torsor V‚ÇÇ P‚ÇÇ] [normed_add_torsor V‚ÇÉ P‚ÇÉ] (g : P‚ÇÇ ‚Üí·µÉ‚Å±[ùïú] P‚ÇÉ) (f : P ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ) : P ‚Üí·µÉ‚Å±[ùïú] P‚ÇÉ
{n : ‚Ñï} (P : mvpfunctor (n + 1)) : pfunctor
{X : Top} (F : Top.presheaf (Type v) X) : Top.sheaf (Type v) X
{Œπ : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering Œπ X s) (U : Œπ ‚Üí set X) : Prop
 : category_theory.limits.preserves_limits_of_size (category_theory.forget Ring)
{Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : continuous (Œª (x : Œ±), metric.inf_nndist x s)
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : C ‚•§ C
{G : Type u} [group G] {A' A B' B : subgroup G} [hAN : (A'.subgroup_of A).normal] [hBN : (B'.subgroup_of B).normal] (h' : A' = B') (h : A = B) : ‚Ü•A ‚ß∏ A'.subgroup_of A ‚âÉ* ‚Ü•B ‚ß∏ B'.subgroup_of B
{Œ± : Type u} {Œ≤ : Type v} [uniform_space Œ±] [semilattice_sup Œ≤] (u : Œ≤ ‚Üí Œ±) : Prop
{R : Type u_1} {A : Type u_3} [comm_ring R] [ring A] (f : R ‚Üí+* A) (x : A) : Prop
(A : Type u_4) (K : Type u_5) [comm_ring A] [is_domain A] (L : Type u_6) [field K] [field L] [algebra A K] [algebra A L] [is_fraction_ring A K] (C : Type u_7) [comm_ring C] [is_domain C] [algebra C L] [is_integral_closure C A L] [algebra A C] [is_scalar_tower A C L] [algebra K L] [is_scalar_tower A K L] [finite_dimensional K L] : is_fraction_ring C L
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : semi_normed_group (M ‚ß∏ S)
 : native.float ‚Üí native.float
{Œ± : Type u_1} (s : finset Œ±) [decidable_eq Œ±] : finset (Œ± √ó Œ±)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [comm_ring ùïú] [add_comm_group E] [add_comm_group F] [add_comm_group G] [module ùïú E] [module ùïú F] [module ùïú G] [topological_space E] [topological_space F] [topological_space G] [topological_add_group E] [has_continuous_const_smul ùïú E] [topological_add_group F] [has_continuous_const_smul ùïú F] [topological_add_group G] [has_continuous_const_smul ùïú G] (q : formal_multilinear_series ùïú F G) (p : formal_multilinear_series ùïú E F) : formal_multilinear_series ùïú E G
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {ca cb : E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a ‚äì measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (nhds b ‚äì measure_theory.measure_space.volume.ae) (nhds cb)) : has_strict_fderiv_at (Œª (p : ‚Ñù √ó ‚Ñù), ‚à´ (x : ‚Ñù) in p.fst..p.snd, f x) ((continuous_linear_map.snd ‚Ñù ‚Ñù ‚Ñù).smul_right cb - (continuous_linear_map.fst ‚Ñù ‚Ñù ‚Ñù).smul_right ca) (a, b)
{ùïú : Type u_1} {E : Type u_2} [linear_ordered_ring ùïú] [add_comm_group E] [module ùïú E] [densely_ordered ùïú] [no_zero_smul_divisors ùïú E] {A : set E} {x : E} : x ‚àà set.extreme_points ùïú A ‚Üî x ‚àà A ‚àß ‚àÄ (x‚ÇÅ : E), x‚ÇÅ ‚àà A ‚Üí ‚àÄ (x‚ÇÇ : E), x‚ÇÇ ‚àà A ‚Üí x ‚àà segment ùïú x‚ÇÅ x‚ÇÇ ‚Üí x‚ÇÅ = x ‚à® x‚ÇÇ = x
(Œ± : Type u) (Œ≤ : Type v) : Type (max u v)
(C : Type u) [category_theory.category C] (D : Type u_1) [category_theory.category D] (F : C ‚•§ D) : category_theory.simplicial_object.augmented C ‚•§ category_theory.simplicial_object.augmented D
{k : ‚Ñï} {A : finset ‚Ñï} (h‚ÇÅ : ‚àÄ {x : ‚Ñï}, x ‚àà A ‚Üí x < k) : A.sum (has_pow.pow 2) < 2 ^ k
(atoms : tactic.ref (buffer expr)) (e : expr) : tactic tactic.itauto.prop
{Œ± : Type u_1} [circular_preorder Œ±] {a b c : Œ±} (h : has_sbtw.sbtw a b c) : ¬¨has_sbtw.sbtw c b a
 : omega.nat.preterm ‚Üí option (omega.nat.preterm √ó omega.nat.preterm)
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ AddCommGroup AddGroup)
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] [fintype Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) {b : M} [linear_ordered_comm_ring M] [nonempty Œ≤] (hb : fintype.card Œ≤ ‚Ä¢ b ‚â§ ‚Üë(fintype.card Œ±)) : ‚àÉ (y : Œ≤), b ‚â§ ‚Üë((finset.filter (Œª (x : Œ±), f x = y) finset.univ).card)
{Œ± : Type u_2} {Œ≤ : Type u_3} [partial_order Œ±] [partial_order Œ≤] (f : has_lt.lt ‚Ü™r has_lt.lt) : Œ± ‚Ü™o Œ≤
{n : ‚Ñï} (i : fin (n + 2)) : ‚áë(i.succ.succ_above) 1 = (‚áë(i.succ_above) 0).succ
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e : local_homeomorph Œ± Œ≤} {s : set Œ±} {t : set Œ≤} : e.to_local_equiv.source ‚à© ‚áëe ‚Åª¬π' t = e.to_local_equiv.source ‚à© s ‚Üí e.is_image s t
(s : string) {p : Prop} : slim_check.test_result p ‚Üí string
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {v : ‚Ñù ‚Üí E ‚Üí E} {s : ‚Ñù ‚Üí set E} {K : ‚Ñù} (hv : ‚àÄ (t : ‚Ñù) (x : E), x ‚àà s t ‚Üí ‚àÄ (y : E), y ‚àà s t ‚Üí has_dist.dist (v t x) (v t y) ‚â§ K * has_dist.dist x y) {f g : ‚Ñù ‚Üí E} {a b Œ¥ : ‚Ñù} (hf : continuous_on f (set.Icc a b)) (hf' : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_deriv_within_at f (v t (f t)) (set.Ici t) t) (hfs : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí f t ‚àà s t) (hg : continuous_on g (set.Icc a b)) (hg' : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_deriv_within_at g (v t (g t)) (set.Ici t) t) (hgs : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí g t ‚àà s t) (ha : has_dist.dist (f a) (g a) ‚â§ Œ¥) (t : ‚Ñù) (H : t ‚àà set.Icc a b) : has_dist.dist (f t) (g t) ‚â§ Œ¥ * real.exp (K * (t - a))
(n : ‚Ñï) : filter.tendsto (Œª (x : ‚Ñù), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-x‚Åª¬π) / x ^ (2 * n)) (nhds_within 0 (set.Ioi 0)) (nhds 0)
 : expr ‚Üí tactic expr
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [linear_order Œ≤] [densely_ordered Œ≤] [no_min_order Œ≤] [no_max_order Œ≤] [nonempty Œ≤] (f : order.partial_iso Œ± Œ≤) (a : Œ±) : ‚àÉ (b : Œ≤), ‚àÄ (p : Œ± √ó Œ≤), p ‚àà f.val ‚Üí cmp p.fst a = cmp p.snd b
(ùïú : Type u_1) {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {G : Œπ ‚Üí Type u_3} [Œ† (i : Œπ), inner_product_space ùïú (G i)] (V : Œ† (i : Œπ), G i ‚Üí‚Çó·µ¢[ùïú] E) : Prop
(Œ± : Type u_1) [preorder Œ±] : circular_preorder Œ±
 : tactic unit
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (b : category_theory.limits.binary_bicone X Y) : category_theory.limits.bicone (category_theory.limits.pair_function X Y)
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] : {a // irreducible a} ‚Üí associates.factor_set Œ± ‚Üí Prop
(p : ‚Ñï) [p_prime : fact (nat.prime p)] {n : ‚Ñï} {F : ‚Ñï ‚Üí ‚Ñö} (hF : ‚àÄ (i : ‚Ñï), i < n ‚Üí 0 < padic_val_rat p (F i)) (hn0 : (finset.range n).sum (Œª (i : ‚Ñï), F i) ‚â† 0) : 0 < padic_val_rat p ((finset.range n).sum (Œª (i : ‚Ñï), F i))
{H : Type u} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] : has_groupoid M (continuous_groupoid H)
(m : linarith.monom) : linarith.sum
{Œπ : Type w} {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] [is_noetherian R M] {v : Œπ ‚Üí M} (hi : linear_independent R v) : fintype Œπ
{G : Type u} [group G] {H : Type v} [group H] (e : G ‚âÉ* H) : abelianization G ‚âÉ* abelianization H
{M : Type u_1} [comm_monoid M] (S : submonoid M) : S.localization_map (localization S)
{M : Type u_1} [monoid M] {x : M} : monoid.closure {x} = powers x
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] (F : category_theory.oplax_functor B C) : category_theory.oplax_nat_trans F F
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [preorder Œ±] [preorder Œ≤] [preorder Œ≥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s : set Œ±} {t : set Œ≤} (h‚ÇÄ : ‚àÄ (b : Œ≤), monotone (function.swap f b)) (h‚ÇÅ : ‚àÄ (a : Œ±), monotone (f a)) : bdd_above s ‚Üí bdd_above t ‚Üí bdd_above (set.image2 f s t)
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] : fintype.card (sym2 Œ±) = fintype.card Œ± * (fintype.card Œ± + 1) / 2
(e : expr) : bool
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {D : Type u‚ÇÑ} [category_theory.category D] {G : K ‚•§ D} (h : category_theory.limits.cocone G ‚•§ category_theory.limits.cocone F) [category_theory.is_left_adjoint h] {c : category_theory.limits.cocone G} (t : category_theory.limits.is_colimit c) : category_theory.limits.is_colimit (h.obj c)
(cache : expr_set) (h : expr) (ns : name_set) : tactic (bool √ó expr_set)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) {X Y : C} (p : X = Y) : F.map_iso (category_theory.eq_to_iso p) = category_theory.eq_to_iso _
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ CommGroup Group)
{Œ± : Type u} [topological_space Œ±] {Œπ : Type u_1} [compact_space Œ±] {f : Œπ ‚Üí set Œ±} (hf : locally_finite f) : {i : Œπ | (f i).nonempty}.finite
(n : ‚Ñï) : n.factorization = 0 ‚Üî n = 0 ‚à® n = 1
{Œ± : Type u_1} [topological_space Œ±] {Œ≤ : Type u_2} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (x : Œ±) : Prop
{C : Type u} [category_theory.category C] {P Q : C} (f : P ‚ü∂ Q) : Prop
(p' : ‚Ñï) (h : lucas_lehmer.lucas_lehmer_residue (p' + 2) = 0) : order_of (lucas_lehmer.œâ_unit (p' + 2)) = 2 ^ (p' + 2)
{R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [ring R] [add_comm_group M] [add_comm_group M‚ÇÇ] [module R M] [module R M‚ÇÇ] (f : M ‚âÉ‚Çó[R] M‚ÇÇ) (p : submodule R M) : finite_dimensional.finrank R ‚Ü•(submodule.map ‚Üëf p) = finite_dimensional.finrank R ‚Ü•p
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] (i j : D.to_glue_data.J) (U : topological_space.opens ‚Ü•((D.to_glue_data.U i).carrier)) : D.diagram_over_open_œÄ U i ‚â´ D.Œπ_inv_app_œÄ_eq_map U ‚â´ D.Œπ_inv_app U ‚â´ D.diagram_over_open_œÄ U j = D.diagram_over_open_œÄ U j
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [category_theory.is_iso g] : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone_of_right_iso f g)
{Œ± : Type u_1} {m : measurable_space Œ±} {M : Type u_3} [topological_space M] [add_comm_monoid M] [partial_order M] : partial_order (measure_theory.vector_measure Œ± M)
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] {ùíú : finset (finset Œ±)} {s : finset Œ±} : s ‚àà ùíú.up_shadow ‚Üî ‚àÉ (t : finset Œ±) (H : t ‚àà ùíú), t ‚äÜ s ‚àß t.card + 1 = s.card
{Œ± : Type u} [monoid Œ±] (u : Œ±À£) : Œ±
(x : ‚Ñù) : ‚Ñù
{A : Type u_2} [normed_ring A] [normed_algebra ‚ÑÇ A] [complete_space A] [norm_one_class A] (a : A) : filter.tendsto (Œª (n : ‚Ñï), ‚Üë‚à•a ^ n‚à•‚Çä ^ (1 / ‚Üën)) filter.at_top (nhds (spectral_radius ‚ÑÇ a))
{Œ± : Type u_1} [partial_order Œ±] [succ_order Œ±] {a b : Œ±} [no_max_order Œ±] : a ‚â† b ‚Üí order.succ a ‚â† order.succ b
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_zero_object C] [category_theory.limits.has_cokernel f] [category_theory.limits.has_kernel (category_theory.limits.cokernel.œÄ f)] [category_theory.epi f] : category_theory.is_iso (category_theory.limits.kernel.Œπ (category_theory.limits.cokernel.œÄ f))
{K : Type u_1} {n : ‚Ñï} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] : generalized_continued_fraction.convergents'_aux s (n + 2) = generalized_continued_fraction.convergents'_aux (generalized_continued_fraction.squash_seq s n) (n + 1)
{R : Type u_1} [comm_ring R] (M : submonoid R) (p : ideal (localization M)) [p.is_prime] : localization.at_prime (ideal.comap (algebra_map R (localization M)) p) ‚âÉ‚Çê[R] localization.at_prime p
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] (F : J √ó K ‚•§ Type v) [category_theory.is_filtered K] [fintype J] : function.injective (category_theory.limits.colimit_limit_to_limit_colimit F)
{Œ± : Type u_1} (o : option Œ±) : finset Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] [decidable_eq Œ≤] {f : Œ± ‚Üí Œ≤} (f_bij : function.bijective f) (b : Œ≤) : Œ±
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (sym : symmetric r) : set (sym2 Œ±)
{R : Type v} [comm_ring R] {n : ‚Ñï} (A : matrix (fin n.succ) (fin n.succ) R) : A.det = finset.univ.sum (Œª (j : fin n.succ), (-1) ^ ‚Üëj * A 0 j * (A.minor fin.succ ‚áë(j.succ_above)).det)
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (h : M ‚âÉ+ N) : M ‚Üí+ N
{Œ± : Type u_1} [preorder Œ±] [add_comm_semigroup Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b : Œ±} : b - (b - a) ‚â§ a
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {a : E} (hf : has_strict_fderiv_at f f' a) {c : nnreal} (hc : subsingleton E ‚à® 0 < c) : ‚àÉ (s : set E) (H : s ‚àà nhds a), approximates_linear_on f f' s c
{M : Type u_1} [has_add M] (r : M ‚Üí M ‚Üí Prop) : M ‚Üí M ‚Üí Prop
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : Œπ ‚Üí M} [semiring R] [add_comm_monoid M] [add_comm_monoid M'] [module R M] [module R M'] (hv : linear_independent R v) {f : M ‚Üí‚Çó[R] M'} (hf_inj : disjoint (submodule.span R (set.range v)) f.ker) : linear_independent R (‚áëf ‚àò v)
(a b : nonote) : Prop
{Œπ : Type u_1} (p : ‚Ñù) (Œ± : Œπ ‚Üí Type u_2) : Type (max u_1 u_2)
{Œ± : Type u_1} [measurable_space Œ±] [topological_space Œ±] [opens_measurable_space Œ±] : measure_theory.probability_measure Œ± ‚Üí weak_dual nnreal (bounded_continuous_function Œ± nnreal)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (c : category_theory.limits.cone F) {X : C} (f : X ‚ü∂ c.X) : category_theory.limits.cone F
{P : Type u_1} [has_le P] : partial_order (order.ideal P)
{Œ± : Type u_1} [has_lt Œ±] : ordering ‚Üí Œ± ‚Üí Œ± ‚Üí Prop
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [comm_monoid Œ≤] {s : finset Œ≥} {t : finset Œ±} {f : Œ≥ ‚Üí Œ± ‚Üí Œ≤} : (s.product t).prod (Œª (x : Œ≥ √ó Œ±), f x.fst x.snd) = t.prod (Œª (y : Œ±), s.prod (Œª (x : Œ≥), f x y))
{X : Type u} {Œ± : Type v} [topological_space X] [linear_order Œ±] [topological_space Œ±] [order_closed_topology Œ±] [preconnected_space X] (a b : X) {f : X ‚Üí Œ±} (hf : continuous f) : set.Icc (f a) (f b) ‚äÜ set.range f
 : vm_decl ‚Üí ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} (r : Œ± ‚Üí Œ≤ ‚Üí Prop) (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) : Œ≥ ‚Üí Œ¥ ‚Üí Prop
{K : Type u_1} [field K] [invertible 2] {a b c : K} (ha : a ‚â† 0) {s : K} (h : discrim a b c = s * s) (x : K) : a * x * x + b * x + c = 0 ‚Üî x = (-b + s) / (2 * a) ‚à® x = (-b - s) / (2 * a)
{Œ± : Type u_1} {Œ≤ : Type u_2} {p : Œ± ‚Üí Œ≤ ‚Üí Prop} {x‚ÇÄ x‚ÇÅ : Œ£ (a : Œ±), subtype (p a)} : x‚ÇÄ.fst = x‚ÇÅ.fst ‚Üí ‚Üë(x‚ÇÄ.snd) = ‚Üë(x‚ÇÅ.snd) ‚Üí x‚ÇÄ = x‚ÇÅ
(M : Type u_1) [add_zero_class M] : galois_insertion add_submonoid.closure coe
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} [is_well_order Œ≤ s] (f : r ‚Ü™r s) (a : Œ±) : {b // ¬¨s (‚áëf a) b}
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [semilattice_sup Œ≤] [order_bot Œ≤] [has_zero Œ≤] (i : ‚Ñï ‚Üí Œ≤) (f : Œ± ‚Üí Œ≤) (n : ‚Ñï) : measure_theory.simple_func Œ± Œ≤
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] (t : category_theory.limits.cotrident f) (create : Œ† (s : category_theory.limits.cotrident f), {l // t.œÄ ‚â´ l = s.œÄ ‚àß ‚àÄ {m : ((category_theory.functor.const (category_theory.limits.walking_parallel_family J)).obj t.X).obj category_theory.limits.walking_parallel_family.one ‚ü∂ ((category_theory.functor.const (category_theory.limits.walking_parallel_family J)).obj s.X).obj category_theory.limits.walking_parallel_family.one}, t.œÄ ‚â´ m = s.œÄ ‚Üí m = l}) : category_theory.limits.is_colimit t
{m : Type u} {n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix m n Œ±) (B : matrix n n Œ±) [invertible B] : (A.mul (‚Öü B)).mul B = A
{F : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [fun_like F Œ± (Œª (_x : Œ±), Œ≤)] [add_comm_monoid Œ±] [add_cancel_comm_monoid Œ≤] {A : set Œ±} {m n : ‚Ñï} [add_freiman_hom_class F A Œ≤ n] (h : m ‚â§ n) : add_freiman_hom_class F A Œ≤ m
{R : Type u_1} {ùïú : Type u_3} {E : Type u_4} [semi_normed_ring ùïú] [add_monoid E] [has_scalar ùïú E] [has_scalar R ‚Ñù] [has_scalar R nnreal] [is_scalar_tower R nnreal ‚Ñù] : has_scalar R (seminorm ùïú E)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {Œπ : Type u_5} [decidable_eq Œπ] [fintype Œπ] {E : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] : is_bounded_linear_map ùïú (Œª (p : continuous_multilinear_map ùïú E F √ó continuous_multilinear_map ùïú E G), p.fst.prod p.snd)
{S : Type u_2} [comm_ring S] {A : Type u_4} [comm_ring A] [algebra A S] {S' : Type u_8} [comm_ring S'] [algebra A S'] [is_domain A] (pb : power_basis A S) : (S ‚Üí‚Çê[A] S') ‚âÉ {y // ‚áë(polynomial.aeval y) (minpoly A pb.gen) = 0}
 : list bool ‚Üí ‚Ñï
(J : Type v) : category_theory.limits.wide_pullback_shape J ‚•§ (category_theory.limits.wide_pushout_shape J)·µí·µñ
(m : Type u_2) (Œ± : Type v) [semiring Œ±] [star_ring Œ±] [fintype m] : matrix m m Œ± ‚âÉ+* (matrix m m Œ±)·µê·µí·µñ
{Œ± : Type u‚ÇÅ} {X Y : category_theory.discrete Œ±} (i : X ‚ü∂ Y) : X.as = Y.as
{Œ± : Type u_1} : set Œ± ‚âÉ set_semiring Œ±
(x : ‚Ñï) : Prop
{R : Type u} {S : Type v} [ring R] [ring S] [is_domain S] (f : R ‚Üí+* S) : f.ker.is_prime
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} {x : category_theory.presieve.family_of_elements P R} (t : x.compatible) : category_theory.presieve.family_of_elements.restrict _ x.sieve_extend = x
{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] {f : Œ≤ ‚Üí Œ±} [topological_space Œ≤] (hf : inducing f) {s : set Œ±} (hs : topological_space.is_separable s) : topological_space.is_separable (f ‚Åª¬π' s)
{A : Type u_1} (K : Type u_2) [comm_ring A] (S : submonoid A) [comm_ring K] [algebra A K] [is_fraction_ring A K] (hS : S ‚â§ non_zero_divisors A) : subalgebra A K
{B : Type u_3} (E‚ÇÅ : B ‚Üí Type u_6) (E‚ÇÇ : B ‚Üí Type u_7) [topological_space (bundle.total_space E‚ÇÅ)] [topological_space (bundle.total_space E‚ÇÇ)] : topological_space (bundle.total_space (Œª (x : B), E‚ÇÅ x √ó E‚ÇÇ x))
(Œπ : Type u_1) (R : Type u_3) (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_3 u_5)
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] (f : ‚Ñï ‚Üí Œ±) : ‚Ñï ‚Üí Œ±
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {G : D ‚•§ C} [category_theory.is_right_adjoint G] [‚àÄ (X : C), category_theory.is_iso ((category_theory.adjunction.of_right_adjoint G).unit.app X)] [‚àÄ (Y : D), category_theory.is_iso ((category_theory.adjunction.of_right_adjoint G).counit.app Y)] : category_theory.is_equivalence G
(C : Type u) [category_theory.category C] {n : ‚Ñï} (D : Type u_1) [category_theory.category D] : (C ‚•§ D) ‚•§ category_theory.simplicial_object.truncated C n ‚•§ category_theory.simplicial_object.truncated D n
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] {C : Type u} [category_theory.category C] (F : J ‚•§ K ‚•§ C) : Type (max u v)
{Œπ : Type u_1} {Œπ' : Type u_2} {R : Type u_5} {M : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] (b : basis Œπ R M) (b' : basis Œπ' R M) [decidable_eq Œπ] [fintype Œπ'] : (b.to_matrix ‚áëb').mul (b'.to_matrix ‚áëb) = 1
{Œ± : Type u_1} [partial_order Œ±] (c : closure_operator Œ±) (x : Œ±) : ‚Ü•(c.closed)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (e' : local_homeomorph Œ≤ Œ≥) (e : Œ± ‚âÉ‚Çú Œ≤) : local_homeomorph Œ± Œ≥
{M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : mul_one_class M} {mN : mul_one_class N} [monoid_hom_class F M N] (f : F) {x : M} (hx : ‚àÉ (y : M), x * y = 1) : ‚àÉ (y : N), ‚áëf x * y = 1
(Œ± : Type u_1) (Œ≤ : Type u_2) [uniform_space Œ≤] (ùîñ : set (set Œ±)) : uniform_space (Œ± ‚Üí Œ≤)
(k : Type u‚ÇÅ) (G : Type u‚ÇÇ) [comm_semiring k] [add_monoid G] (A : Type u‚ÇÉ) [semiring A] [algebra k A] : (multiplicative G ‚Üí* A) ‚âÉ (add_monoid_algebra k G ‚Üí‚Çê[k] A)
{E : Type u_3} {F : Type u_4} [semi_normed_group E] [semi_normed_group F] : semi_normed_group (E √ó F)
{Œ± : Type u_3} [semilattice_sup Œ±] (a : Œ±) : filter.map coe filter.at_top = filter.at_top
{Œ± : Type u_1} {M : Type u_4} [add_monoid M] : (Œ± ‚Üí M) ‚âÉ (free_add_monoid Œ± ‚Üí+ M)
{C : Type u} [category_theory.category C] (J‚ÇÅ : category_theory.grothendieck_topology C) {X : C} {S T : category_theory.sieve X} (h : S ‚â§ T) (hT : J‚ÇÅ.is_closed T) : J‚ÇÅ.close S ‚â§ T
 : expr ‚Üí expr
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_equalizer f g] : category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ (category_theory.limits.equalizer.Œπ f g) _)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} {f‚ÇÅ g‚ÇÅ f‚ÇÇ g‚ÇÇ : C ‚ü∂ D} (h‚ÇÅ : homotopy f‚ÇÅ g‚ÇÅ) (h‚ÇÇ : homotopy f‚ÇÇ g‚ÇÇ) : homotopy (f‚ÇÅ + f‚ÇÇ) (g‚ÇÅ + g‚ÇÇ)
 : denumerable ‚Ñö
{Œ± : Type u_1} {Œπ : Type u_2} {Œπ' : Type u_3} [complete_lattice Œ±] {s : set Œπ'} {g : Œπ' ‚Üí set Œπ} {f : Œπ ‚Üí Œ±} (hs : s.pairwise_disjoint (Œª (i' : Œπ'), ‚®Ü (i : Œπ) (H : i ‚àà g i'), f i)) (hg : ‚àÄ (i : Œπ'), i ‚àà s ‚Üí (g i).pairwise_disjoint f) : (‚ãÉ (i : Œπ') (H : i ‚àà s), g i).pairwise_disjoint f
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J ‚•§ C) {c : category_theory.limits.cone F.op} (hc : category_theory.limits.is_limit c) : category_theory.limits.is_colimit c.unop
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] (p : L.substructure N) (f : L.hom M N) (h : ‚àÄ (c : M), ‚áëf c ‚àà p) : L.hom M ‚Ü•p
{x y z : pgame} (h‚ÇÅ : x < y) (h‚ÇÇ : y.lf z) : x.lf z
{C : Type u} [category_theory.category C] {Œ≤ : Type v} [category_theory.limits.has_zero_morphisms C] (f : Œ≤ ‚Üí C) [category_theory.limits.has_limit (category_theory.discrete.functor f)] (b : Œ≤) : category_theory.split_epi (category_theory.limits.pi.œÄ f b)
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÉ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÑ : X‚ÇÉ ‚ü∂ Y‚ÇÇ) [category_theory.limits.has_pullback f‚ÇÅ f‚ÇÇ] [category_theory.limits.has_pullback f‚ÇÉ f‚ÇÑ] [category_theory.limits.has_pullback f‚ÇÅ (category_theory.limits.pullback.fst ‚â´ f‚ÇÇ)] : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (category_theory.limits.pullback.lift category_theory.limits.pullback.fst (category_theory.limits.pullback.snd ‚â´ category_theory.limits.pullback.fst) _) (category_theory.limits.pullback.snd ‚â´ category_theory.limits.pullback.snd) _)
{Œ± : Type u} (cmd : slim_check.gen Œ±) : slim_check.gen (list Œ±)
{R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] [nontrivial R] (w : set M) [fintype ‚Ü•w] (s : submodule.span R w = ‚ä§) {Œπ : Type w} (b : basis Œπ R M) : fintype Œπ
{R : Type u} {K : Type v} {L : Type z} {p : R} [comm_ring R] [field K] [field L] [algebra K L] [algebra R L] [algebra R K] [is_scalar_tower R K L] [is_separable K L] [is_domain R] [normalized_gcd_monoid R] [is_fraction_ring R K] [is_integrally_closed R] {B : power_basis K L} (hp : prime p) (hBint : is_integral R B.gen) {z : L} (hzint : is_integral R z) (hz : p ‚Ä¢ z ‚àà algebra.adjoin R {B.gen}) (hei : (minpoly R B.gen).is_eisenstein_at (submodule.span R {p})) : z ‚àà algebra.adjoin R {B.gen}
(Œ± : Type u_2) [preorder Œ±] [bounded_order Œ±] : bounded_order_hom Œ± Œ±
(M : Type u_1) [measurable_space M] [has_add M] : Prop
{Œ± : Type u_1} [bornology Œ±] {p : Œ± ‚Üí Prop} : bornology.is_bounded {x : Œ± | p x} ‚Üí bounded_space (subtype p)
(fmt : format) : tactic.pformat
(Fq F : Type) [field Fq] [fintype Fq] [field F] [algebra (polynomial Fq) F] [algebra (ratfunc Fq) F] [is_scalar_tower (polynomial Fq) (ratfunc Fq) F] [function_field Fq F] [is_separable (ratfunc Fq) F] : ‚Ñï
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÇ] [semigroup M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) : semigroup M‚ÇÇ
{M‚ÇÄ : Type u_1} [mul_zero_one_class M‚ÇÄ] : 0 ‚â† 1 ‚à® ‚àÄ (a : M‚ÇÄ), a = 0
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) : s.monge_point ‚àà affine_span ‚Ñù (set.range s.points)
(i : ‚Ñï+) : ‚Ñï
 : ‚Ñ§ ‚Üí option ‚Ñï
(s : linarith.sum) (m : linarith.monom) : linarith.sum
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : multiset Œ± ‚Üí+ multiset Œ≤
{Œ± : Type u_1} (g : generalized_continued_fraction Œ±) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e : Œ± ‚Üí Œ≤} (de : dense_embedding e) [topological_space.separable_space Œ±] : topological_space.separable_space Œ≤
{Œ± : Type u_1} (s : set Œ±) [has_Sup Œ±] [inhabited ‚Ü•s] : has_Sup ‚Ü•s
{R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] (t : finset E) {w : E ‚Üí R} (hw‚ÇÄ : ‚àÄ (i : E), i ‚àà t ‚Üí 0 ‚â§ w i) (hws : 0 < t.sum (Œª (i : E), w i)) : t.center_mass w id ‚àà ‚áë(convex_hull R) ‚Üët
{Œ±‚ÇÅ : Type u_1} {Œ≤‚ÇÅ : Type u_2} {Œ≤‚ÇÇ : Type u_3} (e : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ ‚âÉ Œ≤‚ÇÇ) : Œ±‚ÇÅ √ó Œ≤‚ÇÅ ‚âÉ Œ±‚ÇÅ √ó Œ≤‚ÇÇ
(x : expr) : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [baire_space Œ±] {S : set Œ≤} {f : Œ≤ ‚Üí set Œ±} (ho : ‚àÄ (s : Œ≤), s ‚àà S ‚Üí is_open (f s)) (hS : S.countable) (hd : ‚àÄ (s : Œ≤), s ‚àà S ‚Üí dense (f s)) : dense (‚ãÇ (s : Œ≤) (H : s ‚àà S), f s)
{X Y : Profinite} : (X ‚âÖ Y) ‚âÉ (‚Ü•X ‚âÉ‚Çú ‚Ü•Y)
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] (f : S.localization_map N) (x : M) (y : ‚Ü•S) : N
{Œ± : Type u} [topological_space Œ±] [t2_space Œ±] {s : set Œ±} (hs : is_compact s) : is_closed s
(S : Type u_1) [ring S] (a : ‚Ñï) : ‚Üë(a.desc_factorial 2) = ‚Üëa * (‚Üëa - 1)
{R : Type u_1} [comm_ring R] : ideal.is_jacobson R ‚Üî ‚àÄ (P : ideal R), P.is_prime ‚Üí P.jacobson = P
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] {A B C : matrix n n Œ±} (h : A.mul B = 1) (g : C.mul A = 1) : B = C
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [normed_lattice_add_comm_group Œ≤] : semilattice_inf (bounded_continuous_function Œ± Œ≤)
{Œπ : Type u_1} {Œ± : Type u_2} {A : Œπ ‚Üí Type u_3} [add_monoid Œπ] [graded_monoid.gmonoid A] (l : list Œ±) (fŒπ : Œ± ‚Üí Œπ) (fA : Œ† (a : Œ±), A (fŒπ a)) : A (l.dprod_index fŒπ)
{X Y : algebraic_geometry.Scheme} (f : X ‚ü∂ Y) [category_theory.is_iso f] : Y.open_cover
(src tgt : name) : tactic unit
(a b : ‚Ñù) (h : a < b) : (polynomial_functions unit_interval).comap' (continuous_map.comp_right_alg_hom ‚Ñù (Icc_homeo_I a b h).symm.to_continuous_map) = polynomial_functions (set.Icc a b)
{n : ‚Ñï} : bitvec n ‚Üí bitvec n
{Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_group_hom f) {Œ≥ : Type u_1} [add_group Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : is_add_group_hom g) : is_add_group_hom (g ‚àò f)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_images C·µí·µñ] [category_theory.limits.has_equalizers C·µí·µñ] {J Q R S : C} [category_theory.injective J] (h : R ‚ü∂ J) (f : Q ‚ü∂ R) (g : R ‚ü∂ S) (hgf : category_theory.exact g.op f.op) (w : f ‚â´ h = 0) : S ‚ü∂ J
{C : Type u} [category_theory.category C] {X : C} : monoid (category_theory.End X)
{Œ± : Type u_1} [normed_division_ring Œ±] : Œ± ‚Üí*‚ÇÄ nnreal
{n : ‚Ñï} {C : fin (n + 1) ‚Üí Sort u_1} (hlast : C (fin.last n)) (hcast : Œ† (i : fin n), C (‚áëfin.cast_succ i)) (i : fin (n + 1)) : C i
(c : tactic.instance_cache) (a b : expr) : tactic (tactic.instance_cache √ó expr √ó expr)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ‚Ñù P) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : ‚áë(orthogonal_projection s.direction) (p -·µ• ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p)) = 0
{C : Type u} [category_theory.category C] {X Y : Top} (H‚ÇÅ : X ‚âÖ Y) {‚Ñ± : Top.presheaf C Y} {ùí¢ : Top.presheaf C X} (H‚ÇÇ : ‚Ñ± ‚ü∂ H‚ÇÅ.hom _* ùí¢) : H‚ÇÅ.inv _* ‚Ñ± ‚ü∂ ùí¢
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {p : filter Œπ} (hF : tendsto_uniformly_on F f p s) : uniform_cauchy_seq_on F p s
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) : V ‚âÉ‚Çó·µ¢[‚Ñù] V
{K : Type u_1} {g : generalized_continued_fraction K} {n : ‚Ñï} [division_ring K] {gp ppred pred : generalized_continued_fraction.pair K} (succ_nth_s_eq : g.s.nth (n + 1) = option.some gp) (nth_conts_eq : g.continuants n = ppred) (succ_nth_conts_eq : g.continuants (n + 1) = pred) : g.continuants (n + 2) = {a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b}
 : Type
(Œ± : Sort u_1) : Prop
{Œ± : Type uu} (r : Œ± ‚Üí Œ± ‚Üí Prop) [decidable_rel r] (a : Œ±) (l : list Œ±) : list.ordered_insert r a l = list.take_while (Œª (b : Œ±), ¬¨r a b) l ++ a :: list.drop_while (Œª (b : Œ±), ¬¨r a b) l
{Œ± : Type u_1} [circular_preorder Œ±] {a b c d : Œ±} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d) : has_sbtw.sbtw a b d
{C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X) : category_theory.presheaf.is_sheaf (opens.grothendieck_topology ‚Ü•X) F ‚Üî F.is_sheaf_opens_le_cover
{Œ± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Œ± ‚Üí E} {g' : Œ± ‚Üí F'} {l : filter Œ±} : f =O[l] g' ‚Üí (f =O[l] Œª (x : Œ±), -g' x)
{p : ‚Ñï} {G : Type u_1} [group G] (P : sylow p G) {K : Type u_2} [group K] (œï : K ‚Üí* G) (hœï : function.injective ‚áëœï) (h : ‚ÜëP ‚â§ œï.range) : sylow p K
{G : Type u_1} [add_group G] (K V : set G) : ‚Ñï
(tooltip : widget.tc subexpr empty) (e : expr) : tactic (widget.html empty)
{Œ± : Type u} [preorder Œ±] [bounded_random Œ±] (x y : Œ±) (p : x ‚â§ y) : slim_check.gen ‚Ü•(set.Icc x y)
{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] (f : one_hom M N) {x y : M} (h : x = y) : ‚áëf x = ‚áëf y
{R : Type u} [ring R] : smul_comm_class R ‚Ü•(subring.center R) R
 : tactic unit
{Œ± : Type u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) (b : Œ≤) : option Œ±
{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ‚â† 2) (a : F) : ‚Üë({x : F | x ^ 2 = a}.to_finset.card) = char.quadratic_char F a + 1
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [is_R_or_C ùïÇ] [normed_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] : has_fderiv_at (exp ùïÇ) 1 0
(a b : znum) : num
(A : Type u) {B : Type v} {Œπ : Type w} [comm_ring A] [comm_ring B] [algebra A B] [fintype Œπ] [is_domain A] {b : Œπ ‚Üí B} (hli : ¬¨linear_independent A b) : algebra.discr A b = 0
{Œ± : Sort u} {Œ≤ : Sort v} [decidable_eq Œ±] {v : Œ± ‚Üí Œ≤} {i j : Œ±} (hv : v i = v j) (k : Œ±) : v (‚áë(equiv.swap i j) k) = v k
{Œ± : Type u_1} [emetric_space Œ±] {K : nnreal} {f : Œ± ‚Üí Œ±} (hf : contracting_with K f) {s : set Œ±} (hsc : is_complete s) (hsf : set.maps_to f s s) (hfs : contracting_with K (set.maps_to.restrict f s s hsf)) {x : Œ±} (hxs : x ‚àà s) (hx : has_edist.edist x (f x) ‚â† ‚ä§) {t : set Œ±} (htc : is_complete t) (htf : set.maps_to f t t) (hft : contracting_with K (set.maps_to.restrict f t t htf)) {y : Œ±} (hyt : y ‚àà t) (hy : has_edist.edist y (f y) ‚â† ‚ä§) (hxy : has_edist.edist x y ‚â† ‚ä§) : contracting_with.efixed_point' f hsc hsf hfs x hxs hx = contracting_with.efixed_point' f htc htf hft y hyt hy
(ùïú : Type u_1) (E : Type u_2) [ordered_semiring ùïú] [ordered_add_comm_group E] [module ùïú E] [ordered_smul ùïú E] : (convex_cone.positive_cone ùïú E).pointed
 : vm_obj ‚Üí declaration
(p : Set ‚Üí Set ‚Üí Prop) (x y : Set) : Set
{Œ± : Type u} [emetric_space Œ±] : emetric_space (topological_space.nonempty_compacts Œ±)
(X : Compactum) : ‚Ü•X ‚Üí ultrafilter ‚Ü•X
(N i : ‚Ñï) : polynomial.rev_at_fun N i = ‚áë(polynomial.rev_at N) i
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] [category_theory.monoidal_category D] : Mon_ (C ‚•§ D) ‚âå C ‚•§ Mon_ D
{V : Type u} [quiver V] [quiver.has_reverse V] {a b : V} : (a ‚ü∂ b) ‚Üí (b ‚ü∂ a)
{P : pfunctor} : P.obj P.W ‚Üí P.W
{Œ± : Type u_1} {Œ≤ : Type u_2} [decidable_eq Œ≤] {f : Œ± ‚Üí. Œ≤} [Œ† (x : Œ±), decidable (f x).dom] {s : finset Œ±} : finset.pimage f s = finset.image (Œª (x : {x // x ‚àà finset.filter (Œª (x : Œ±), (f x).dom) s}), (f ‚Üëx).get _) (finset.filter (Œª (x : Œ±), (f x).dom) s).attach
{Œ± : Type u_1} [has_lt Œ±] (s : set Œ±) : Prop
{V : Type u} (G : simple_graph V) : set (sym2 V)
{Œ± : Type u_1} (l : list Œ±) : list (Œ± √ó Œ±)
{R : Type u_1} {L : Type u_2} {L' : Type u_3} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L') : L ‚ß∏ f.ker ‚âÉ‚Çó‚ÅÖR‚ÅÜ ‚Ü•(f.range)
(ùïú : Type u_1) [is_R_or_C ùïú] (n : Type u_2) [fintype n] : Type (max u_2 u_1)
{V : Type (u+1)} [category_theory.large_category V] {G : Mon} : Action V G ‚âå ulift (category_theory.single_obj ‚Ü•G) ‚•§ V
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) (b : Œ≤ a) (s : alist Œ≤) : alist Œ≤
{n : ‚Ñï} {Œ± : Type u_1} (l : list Œ±) (c : composition n) : (l.split_wrt_composition c).length = c.length
(xs : list expr) : omega.nat.exprform ‚Üí tactic omega.nat.preform
{F : pfunctor} {r : F.M ‚Üí Sort w} (f : Œ† (x : F.obj F.M), r (pfunctor.M.mk x)) (x : F.M) : r x
 : expr ‚Üí bool
(G : Type u) [topological_space G] [has_neg G] : Prop
 : smt_tactic unit
{Œ± : Type u_1} {Œπ : Type u_4} [complete_lattice Œ±] (s : Œπ ‚Üí Œ±) : (‚®Ü (i : Œπ), s i) = ‚®Ü (t : finset Œπ) (i : Œπ) (H : i ‚àà t), s i
 : category_theory.bicategory.strict category_theory.Cat
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : filter Œ±) (h : set Œ± ‚Üí set Œ≤) : filter Œ≤
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : valued K (with_zero (multiplicative ‚Ñ§))
{G : Type u_1} [group G] [fintype G] (S : set G) (hS1 : S.nonempty) (hS2 : S * S = S) : subgroup G
{Œ≤ : Type u} {Œ≥ : Type w} [non_assoc_semiring Œ≤] [non_assoc_semiring Œ≥] (f : Œ≤ ‚Üí+* Œ≥) (l : list Œ≤) : ‚áëf l.sum = (list.map ‚áëf l).sum
(Œ± : Type u_1) (Œ≤ : Type u_2) [topological_space Œ±] [compact_space Œ±] [metric_space Œ≤] : C(Œ±, Œ≤) ‚âÉ·µ¢ bounded_continuous_function Œ± Œ≤
{X Y : CommGroup} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ* ‚Ü•Y
 : Type (u_1+1)
(Œ± : Type u_6) (Œ≤ : Type u_7) [preorder Œ±] [preorder Œ≤] [topological_space Œ±] [topological_space Œ≤] : Type (max u_6 u_7)
{Œ± : Type u} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_well_order Œ± r] : principal_seg r has_lt.lt
{G : Type u_1} [group G] {H K : subgroup G} (h : H = K) : ‚Ü•H ‚âÉ* ‚Ü•K
(R : Type u_1) {B : Type u_3} (F : Type u_4) (E : B ‚Üí Type u_5) [nondiscrete_normed_field R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [normed_group F] [normed_space R F] [topological_space B] : Type (max u_3 u_4 u_5)
{Œ± : Type u} (s : wseq Œ±) : Prop
{R : Type u} {n : ‚Ñï} {M : fin n.succ ‚Üí Type v} {M‚ÇÇ : Type v‚ÇÇ} [comm_semiring R] [Œ† (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : fin n.succ), module R (M i)] [module R M‚ÇÇ] (f : multilinear_map R M M‚ÇÇ) : M 0 ‚Üí‚Çó[R] multilinear_map R (Œª (i : fin n), M i.succ) M‚ÇÇ
{R : Type u_2} [semiring R] : has_faithful_smul (R ‚Üí+* R) R
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} [fintype Œπ] (p : Œπ ‚Üí P) : affine_independent k p ‚Üî ‚àÄ (w : Œπ ‚Üí k), finset.univ.sum (Œª (i : Œπ), w i) = 0 ‚Üí ‚áë(finset.univ.weighted_vsub p) w = 0 ‚Üí ‚àÄ (i : Œπ), w i = 0
{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] : module.End R (n ‚Üí R) ‚âÉ‚Çó‚ÅÖR‚ÅÜ matrix n n R
{L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.embedding M N) (g : L.embedding N P) (h : L.embedding P Q) : (h.comp g).comp f = h.comp (g.comp f)
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} {R : Type u_11} [add_monoid M] [monoid R] [distrib_mul_action R M] {f : Œ± ‚Üí Œ≤} (hf : function.injective f) (r : R) (v : Œ≤ ‚Üí‚ÇÄ M) : finsupp.comap_domain f (r ‚Ä¢ v) _ = r ‚Ä¢ finsupp.comap_domain f v _
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] (F : A ‚•§ B) (G : B ‚•§ C) (H : C ‚•§ D) : (F ‚ãô G) ‚ãô H ‚âÖ F ‚ãô G ‚ãô H
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (b : category_theory.limits.binary_bicone X Y) : category_theory.limits.is_colimit b.to_bicone.to_cocone ‚âÉ category_theory.limits.is_colimit b.to_cocone
 : nat.arithmetic_function ‚Ñ§
{R : Type u‚ÇÅ} [non_unital_non_assoc_ring R] : smul_comm_class ‚Ñ§ R R
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a b c : Œ±} : a * b < c ‚Üí b < a‚Åª¬π * c
 : Type (u+1)
 : expr ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí expr
{Œπ : Type u_1} {Œ± : Type u_2} [canonically_ordered_add_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] : has_sub (Œπ ‚Üí‚ÇÄ Œ±)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {x : E} {n : with_top ‚Ñï} {p : E ‚Üí formal_multilinear_series ùïú E F} (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ‚â§ n) (hx : s ‚àà nhds x) : has_fderiv_at f (‚áë(continuous_multilinear_curry_fin1 ùïú E F) (p x 1)) x
{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_strong_epi_mono_factorisations C
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} (t : category_theory.presieve.is_separated_for P R) : (‚àÄ (x : category_theory.presieve.family_of_elements P R), x.compatible ‚Üí (‚àÉ (t : P.obj (opposite.op X)), x.is_amalgamation t)) ‚Üí category_theory.presieve.is_sheaf_for P R
{L : first_order.language} (K : set (category_theory.bundled L.Structure)) {M : Type w} [L.Structure M] [L.countable_functions] (h : first_order.language.is_fraisse_limit K M) : first_order.language.is_fraisse K
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y Z : C} {f g : X ‚ü∂ Y} {h : Z ‚ü∂ X} (w : h ‚â´ f = h ‚â´ g) [category_theory.limits.reflects_limit (category_theory.limits.parallel_pair f g) G] (l : category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ (G.map h) _)) : category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ h w)
(expected_tp : expr) : option (tactic expr) ‚Üí list expr ‚Üí list pexpr ‚Üí tactic expr
{m : Type u ‚Üí Type u} [monad m] {Œ± : Type u} (t : m (tactic.mllist m Œ±)) : tactic.mllist m Œ±
 : expr ‚Üí expr
{M : Type u_1} [has_add M] (c : add_con M) : Type u_1
{R : Type u_1} {S : Type u_2} [comm_semiring R] [comm_semiring S] (i : R ‚Üí+* S) : algebra R S
{Œ± : Type u_1} (n : ‚Ñï) (x : Œ±) : function.is_periodic_pt id n x
 : category_theory.limits.has_limits_of_size SemiRing
{M : Type u_1} [linear_ordered_cancel_comm_monoid M] (S : submonoid M) : linear_ordered_cancel_comm_monoid ‚Ü•S
{Œ± : Sort u_1} (p : Œ± ‚Üí Prop) : decidable_pred p
(p : ‚Ñï) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] (m : ‚Ñ§) : witt_vector.isocrystal p k (witt_vector.standard_one_dim_isocrystal p k m)
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b : Œ±} (ha : a < 0) (hb : b < 0) : a + b < 0
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddCommMon) : category_theory.limits.cocone F
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {s : set V} [fintype ‚Ü•s] (span_eq : submodule.span K s = ‚ä§) (card_eq : s.to_finset.card = finite_dimensional.finrank K V) : basis ‚Ü•s K V
 : nzsnum ‚Üí bool
{ùïú : Type u_1} {E : Type u_2} [semi_normed_ring ùïú] [has_scalar ùïú E] {s t : set E} (ht : balanced ùïú t) (h : s ‚äÜ t) : balanced_hull ùïú s ‚äÜ t
{R : Type u} [ring R] {Œπ : Type v} [dec_Œπ : decidable_eq Œπ] {M : Type u_1} [add_comm_group M] [module R M] {A : Œπ ‚Üí submodule R M} (hi : complete_lattice.independent A) (hs : supr A = ‚ä§) : direct_sum.is_internal A
{R' : Type u_1} [semiring R'] : smul_comm_class R' ‚Ü•(subsemiring.center R') R'
{M : Type u_1} [topological_space M] : topological_space M·µê·µí·µñ
{Œ± : Type u_2} [has_one Œ±] : has_one (set Œ±)
{R : Type u_2} {M : Type u_4} {M‚ÇÅ : Type u_5} [ring R] [add_comm_group M] [add_comm_group M‚ÇÅ] [module R M] [module R M‚ÇÅ] (Q : quadratic_form R M) (f : M‚ÇÅ ‚âÉ‚Çó[R] M) : Q.isometry (Q.comp ‚Üëf)
{Œ± : Type u_1} {C : vector3 Œ± 0 ‚Üí Sort u} (H : C vector3.nil) (v : vector3 Œ± 0) : C v
{C : Type u_1} [category_theory.category C] : has_coe_t C (category_theory.idempotents.karoubi C)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {p : filter Œπ} [topological_space Œ±] (h : tendsto_locally_uniformly_on F f p s) (hc : ‚àÄ·∂† (n : Œπ) in p, continuous_on (F n) s) [p.ne_bot] : continuous_on f s
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Œπ ‚Üí M} [ring R] [add_comm_group M] [module R M] (hli : linear_independent R v) : basis Œπ R ‚Ü•(submodule.span R (set.range v))
{Œ± : Type u_1} [preorder Œ±] {a : Œ±} : order_bot {x // a ‚â§ x}
{Œ± : Type u} [topological_space Œ±] (s : set Œ±) : Prop
(f : ‚Ü•(measure_theory.Lp ‚ÑÇ 2 haar_circle)) (i : ‚Ñ§) : ‚áë(‚áë(fourier_series.repr) f) i = ‚à´ (t : ‚Ü•circle), ‚Üët ^ -i * ‚áëf t ‚àÇhaar_circle
{M : Type u_1} [has_add M] {Œ≤ : Sort u_2} {c : add_con M} (q r : c.quotient) (f : M ‚Üí M ‚Üí Œ≤) (h : ‚àÄ (a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ : M), ‚áëc a‚ÇÅ b‚ÇÅ ‚Üí ‚áëc a‚ÇÇ b‚ÇÇ ‚Üí f a‚ÇÅ a‚ÇÇ = f b‚ÇÅ b‚ÇÇ) : Œ≤
{Œ± : Type v} (P : Œ± ‚Üí Prop) : (Œ£' (i : Œ±), P i) ‚âÉ subtype P
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] {a b : Œ±} (h : a ‚â§ b) (f : ‚Ü•(set.Icc a b) ‚Üí Œ≤) : Œ± ‚Üí Œ≤
{L : first_order.language} (T : L.Theory) : Prop
{m : Type u_2} [fintype m] {Œ± : m ‚Üí Type v} (w : Œ† (i : m), Œ± i) : dmatrix m unit (Œª (i : m) (j : unit), Œ± i)
{Œ± : Type u} {m n : ‚Ñï} (hm : m = n + n) (v : fin m ‚Üí Œ±) (k : fin n) : Œ±
 : tactic unit
{R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] (e : basis Œπ R M) (x : orientation R M Œπ) : x = e.orientation ‚à® x = -e.orientation
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] (J : category_theory.grothendieck_topology C) : category_theory.pretopology C
{R : Type u_1} {k : Type u_2} {V1 : Type u_3} {P1 : Type u_4} {V2 : Type u_5} [ring k] [add_comm_group V1] [add_torsor V1 P1] [add_comm_group V2] [module k V1] [module k V2] [semiring R] [module R V2] [smul_comm_class k R V2] : module R (P1 ‚Üí·µÉ[k] V2)
 : lean.parser ‚Ñï
{Œ± : Type u} [pseudo_metric_space Œ±] : uniform_continuous (Œª (p : uniform_space.completion Œ± √ó uniform_space.completion Œ±), has_dist.dist p.fst p.snd)
 : list ‚Ñï ‚Üí ‚Ñï ‚Üí list ‚Ñï
{X Y : Top} {f g : C(‚Ü•X, ‚Ü•Y)} (H : f.homotopy g) {x‚ÇÄ x‚ÇÅ : ‚Ü•X} (p : fundamental_groupoid.from_top x‚ÇÄ ‚ü∂ fundamental_groupoid.from_top x‚ÇÅ) : (fundamental_groupoid.fundamental_groupoid_functor.map f).map p = continuous_map.homotopy.hcast _ ‚â´ (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I (ùüô {down := 0}) p) ‚â´ continuous_map.homotopy.hcast _
(n a b : ‚Ñï) : Prop
(Œì : Type u_1) [inhabited Œì] : Type u_1
{m : Type u_1} [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (M N P : matrix m m R) : (M.mul (N.mul P)).det = (N.mul (M.mul P)).det
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (m : multiset M) (hm : ‚àÄ (a : M), a ‚àà m ‚Üí a ‚àà S) : m.sum ‚àà S
{Œ± : Type u_1} {n : ‚Ñï} (p : Œ± ‚Üí Prop) (v : vector3 Œ± n) : Prop
{M : Type u_1} [has_mul M] : complete_lattice (subsemigroup M)
(Œ± : Type u_1) (n : ‚Ñï) : setoid (vector Œ± n)
{C : Type u} [category_theory.category C] (X : category_theory.with_terminal C) : X.hom X
{Œ± : Type u_1} (l : ordnode Œ±) (x : Œ±) (r : ordnode Œ±) : ordnode Œ±
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] (v : E) : orthogonal_projection_fn K v ‚àà K
(C : Type u) [category_theory.category C] : category_theory.bicategory (category_theory.locally_discrete C)
{Œ± : Type u_1} [uniform_space Œ±] (pkg : abstract_completion Œ±) {Œ≤ : Type u_2} [uniform_space Œ≤] (pkg' : abstract_completion Œ≤) : abstract_completion (Œ± √ó Œ≤)
 : irrational golden_conj
{X : Type u} [metric_space X] (p : topological_space.nonempty_compacts X) : Gromov_Hausdorff.GH_space
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] {n m : ‚Ñï} : tensor_product R (tensor_power R n M) (tensor_power R m M) ‚âÉ‚Çó[R] tensor_power R (n + m) M
{R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] {C : exterior_algebra R M ‚Üí Prop} (h_grade0 : ‚àÄ (r : R), C (‚áë(algebra_map R (exterior_algebra R M)) r)) (h_grade1 : ‚àÄ (x : M), C (‚áë(exterior_algebra.Œπ R) x)) (h_mul : ‚àÄ (a b : exterior_algebra R M), C a ‚Üí C b ‚Üí C (a * b)) (h_add : ‚àÄ (a b : exterior_algebra R M), C a ‚Üí C b ‚Üí C (a + b)) (a : exterior_algebra R M) : C a
{Œπ : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [ordered_add_comm_monoid N] (f : M ‚Üí N) (p : M ‚Üí Prop) (h_mul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí f (x + y) ‚â§ f x + f y) (hp_mul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x + y)) (g : Œπ ‚Üí M) (s : finset Œπ) (hs_nonempty : s.nonempty) (hs : ‚àÄ (i : Œπ), i ‚àà s ‚Üí p (g i)) : f (s.sum (Œª (i : Œπ), g i)) ‚â§ s.sum (Œª (i : Œπ), f (g i))
 : category_theory.limits.has_limits_of_size CommRing
(R : Type u) {Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [topological_space M‚ÇÇ] {A : Type u_1} [semiring A] [has_scalar R A] [Œ† (i : Œπ), module A (M‚ÇÅ i)] [module A M‚ÇÇ] [‚àÄ (i : Œπ), is_scalar_tower R A (M‚ÇÅ i)] [is_scalar_tower R A M‚ÇÇ] (f : continuous_multilinear_map A M‚ÇÅ M‚ÇÇ) : continuous_multilinear_map R M‚ÇÅ M‚ÇÇ
{Œ≤ : Type v} {Œ≥ : Type w} {Œ¥ : Type u_2} [topological_space Œ≤] [topological_space Œ≥] [topological_space Œ¥] [mul_zero_class Œ¥] [has_continuous_mul Œ¥] (g : cocompact_map Œ≤ Œ≥) : zero_at_infty_continuous_map Œ≥ Œ¥ ‚Üí‚Çô* zero_at_infty_continuous_map Œ≤ Œ¥
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] {E : Type u‚ÇÉ} [category_theory.category E] [category_theory.monoidal_category E] (F : category_theory.lax_monoidal_functor C D) (G : category_theory.lax_monoidal_functor D E) : category_theory.lax_monoidal_functor C E
 : category_theory.limits.colimit_cocone (category_theory.functor.empty (Type u))
 : (user_attribute simp_lemmas)
(Œ± : Type u) : Type u
{a b : ‚Ñï} (hab : a.coprime b) : a.factors.disjoint b.factors
(G : Type u_1) [add_comm_group G] : add_monoid.is_torsion_free (G ‚ß∏ add_torsion G)
{Œ± : Type u_1} (a : Œ±) : semiquot Œ±
{Œ± : Type u_1} {M : Type u_2} [has_zero M] (s : set Œ±) (f : Œ± ‚Üí M) : Œ± ‚Üí M
(Œπ : Type u_3) : well_founded has_lt.lt
{K : Type u} [field K] (S : Type u_1) [set_like S K] [h : subfield_class S K] : subgroup_class S K
(A : Type u_1) [has_add A] : group (add_aut A)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type u_1} (s : finset Œπ) (S : Œπ ‚Üí submodule K V) [‚àÄ (i : Œπ), finite_dimensional K ‚Ü•(S i)] : finite_dimensional K ‚Ü•(s.sup S)
{Œ± : Type u} [monoid Œ±] (a b : Œ±) : Prop
 : expr ‚Üí tactic.ring.ring_m (tactic.ring.horner_expr √ó expr)
{Œ± : Type u} : ‚Ñï ‚Üí tactic Œ± ‚Üí tactic (list Œ±)
{K : Type u} {V V‚ÇÅ V‚ÇÇ V‚ÇÉ : Type v} [field K] [add_comm_group V] [module K V] [add_comm_group V‚ÇÅ] [module K V‚ÇÅ] [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] [add_comm_group V‚ÇÉ] [module K V‚ÇÉ] (db : V‚ÇÇ ‚Üí‚Çó[K] V) (eb : V‚ÇÉ ‚Üí‚Çó[K] V) (cd : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÇ) (ce : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÉ) (hde : ‚ä§ ‚â§ db.range ‚äî eb.range) (hgd : cd.ker = ‚ä•) (eq : db.comp cd = eb.comp ce) (eq‚ÇÇ : ‚àÄ (d : V‚ÇÇ) (e : V‚ÇÉ), ‚áëdb d = ‚áëeb e ‚Üí (‚àÉ (c : V‚ÇÅ), ‚áëcd c = d ‚àß ‚áëce c = e)) : module.rank K V + module.rank K V‚ÇÅ = module.rank K V‚ÇÇ + module.rank K V‚ÇÉ
{C : Type v‚ÇÅ} [category_theory.small_category C] {D : Type v‚ÇÅ} [category_theory.small_category D] (A : Type u‚ÇÇ) [category_theory.category A] (J : category_theory.grothendieck_topology C) (K : category_theory.grothendieck_topology D) [category_theory.concrete_category A] [category_theory.limits.preserves_limits (category_theory.forget A)] [category_theory.limits.has_colimits A] [category_theory.limits.has_limits A] [category_theory.limits.preserves_filtered_colimits (category_theory.forget A)] [category_theory.reflects_isomorphisms (category_theory.forget A)] {G : C ‚•§ D} (hG‚ÇÅ : category_theory.compatible_preserving K G) (hG‚ÇÇ : category_theory.cover_preserving J K G) : category_theory.sites.pushforward A J K G ‚ä£ category_theory.sites.pullback A hG‚ÇÅ hG‚ÇÇ
{E : Type u} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {a : E} {s : set E} (h : is_local_min_on f s a) {y : E} (hy : y ‚àà pos_tangent_cone_at s a) : 0 ‚â§ ‚áë(fderiv_within ‚Ñù f s a) y
(p : Prop) [slim_check.testable p] (cfg : slim_check.slim_check_cfg) : slim_check.test_result p ‚Üí ‚Ñï ‚Üí rand (slim_check.test_result p)
(Œ± : Type u_1) (Œ≤ : Type u_2) [mul_one_class Œ±] [comm_monoid Œ≤] : (Œ± ‚Üí* Œ≤) ‚Üí* Œ± ‚Üí Œ≤
{Œ≤ : Type w} {C : Type u} [category_theory.category C] (f : Œ≤ ‚Üí C) [category_theory.limits.has_product f] (b : Œ≤) : ‚àè f ‚ü∂ f b
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {P : Prop} (S : P ‚Üí submodule K V) [‚àÄ (h : P), finite_dimensional K ‚Ü•(S h)] : finite_dimensional K (‚Ü•‚®Ü (h : P), S h)
{C : Type v} [category_theory.category C] [category_theory.concrete_category C] {X Y : C} {f g : X ‚ü∂ Y} (h : f = g) (x : ‚Ü•X) : ‚áëf x = ‚áëg x
{Œπ : Type u} (s : finset Œπ) (w z : Œπ ‚Üí ennreal) (hw' : s.sum (Œª (i : Œπ), w i) = 1) {p : ‚Ñù} (hp : 1 ‚â§ p) : s.sum (Œª (i : Œπ), w i * z i) ^ p ‚â§ s.sum (Œª (i : Œπ), w i * z i ^ p)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V‚ÇÇ : Type v'} [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] [finite_dimensional K V] [finite_dimensional K V‚ÇÇ] : nonempty (V ‚âÉ‚Çó[K] V‚ÇÇ) ‚Üî finite_dimensional.finrank K V = finite_dimensional.finrank K V‚ÇÇ
(S : Type u_3) (G : Type u_4) [has_inv G] [set_like S G] : Type
{a b : ‚Ñ§} (ha : a ‚â† 0) : is_least {n : ‚Ñï | 0 < n ‚àß ‚àÉ (x y : ‚Ñ§), ‚Üën = a * x + b * y} (a.gcd b)
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.mul_pos_strict_mono Œ±] (ha : 1 < a) (hb : 1 ‚â§ b) (b0 : 0 < b) : 1 < a * b
(X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] {f : Cb X Y} (h : f ‚àà candidates_b X Y) : metric.Hausdorff_dist (set.range (Gromov_Hausdorff.optimal_GH_injl X Y)) (set.range (Gromov_Hausdorff.optimal_GH_injr X Y)) ‚â§ Gromov_Hausdorff.HD f
 : set ‚Ñù
{R : Type u_1} [comm_ring R] (s : subring R) : comm_ring ‚Ü•s
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [is_refl Œ± r] [is_antisymm Œ± r] {a b : Œ±} : antisymm_rel r a b ‚Üí a = b
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ùïú] [inner_product_space ùïú E] [inner_product_space ùïú F] [complete_space E] [complete_space F] (A : E ‚ÜíL[ùïú] F) (B : F ‚ÜíL[ùïú] E) : A = ‚áëcontinuous_linear_map.adjoint B ‚Üî ‚àÄ (x : E) (y : F), has_inner.inner (‚áëA x) y = has_inner.inner x (‚áëB y)
(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_binary_coproducts C] : category_theory.symmetric_category C
{Œ± : Type u_1} [add_group Œ±] (s : add_subgroup Œ±) : setoid Œ±
{M : Type u_3} {N : Type u_4} [monoid M] [monoid N] (f : M ‚Üí* N) (l : list M) : ‚áëf l.prod = (list.map ‚áëf l).prod
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [preorder Œ±] [preorder Œ≤] [preorder Œ≥] : (Œ≤ ‚Üío Œ≥) ‚Üío (Œ± ‚Üío Œ≤) ‚Üío Œ± ‚Üío Œ≥
{n : ‚Ñï} {a b : fin n} : ‚Üëa ‚â§ ‚Üëb ‚Üî a ‚â§ b
{C : Type u‚ÇÅ} [category_theory.small_category C] {‚Ñ∞ : Type u‚ÇÇ} [category_theory.category ‚Ñ∞] (L‚ÇÅ L‚ÇÇ : (C·µí·µñ ‚•§ Type u‚ÇÅ) ‚•§ ‚Ñ∞) [category_theory.limits.preserves_colimits L‚ÇÅ] [category_theory.limits.preserves_colimits L‚ÇÇ] (h : category_theory.yoneda ‚ãô L‚ÇÅ ‚âÖ category_theory.yoneda ‚ãô L‚ÇÇ) : L‚ÇÅ ‚âÖ L‚ÇÇ
{Œ± : Type u_1} [measurable_space Œ±] (p : pmf Œ±) : measure_theory.measure Œ±
 : tactic unit
{R : Type u} [comm_semiring R] (f : polynomial R) : Prop
{Œ± : Type u_1} [partial_order Œ±] [order_bot Œ±] {a : Œ±} : is_atom a ‚Üí ‚ä• ‚ãñ a
 : tactic.ring.horner_expr ‚Üí tactic.ring.horner_expr ‚Üí tactic.ring.ring_m (tactic.ring.horner_expr √ó expr)
(n : ‚Ñï) (e t : expr) : expr
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : subfield L
 : linarith.preprocessor
{K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] {x : S} (hx : is_integral K x) : basis (fin (minpoly K x).nat_degree) K ‚Ü•(algebra.adjoin K {x})
(Œ± : Type u_1) {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [monoid Œ≤] [has_continuous_mul Œ≤] [topological_space Œ≥] [monoid Œ≥] [has_continuous_mul Œ≥] (g : Œ≤ ‚Üí* Œ≥) (hg : continuous ‚áëg) : C(Œ±, Œ≤) ‚Üí* C(Œ±, Œ≥)
{Œ± : Type u_1} [preorder Œ±] [pred_order Œ±] {a b : Œ±} [no_min_order Œ±] : a < b ‚Üí order.pred a < order.pred b
{K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} : (generalized_continued_fraction.of v).h = ‚Üë‚åäv‚åã
{Œ± : Type u_1} : list (option Œ±) ‚Üí list Œ± ‚Üí list Œ±
{X Y : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Y) [category_theory.is_iso f] : Y.open_cover
{p : ‚Ñï} [fact (nat.prime p)] {f : cau_seq ‚Ñö (padic_norm p)} (hf : ¬¨f ‚âà 0) : ‚àÉ (N : ‚Ñï), ‚àÄ (m n : ‚Ñï), N ‚â§ m ‚Üí N ‚â§ n ‚Üí padic_norm p (‚áëf n) = padic_norm p (‚áëf m)
{V : Type u} (G : simple_graph V) : Prop
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L) : is_totally_disconnected set.univ
{M : Type u_1} [monoid M] (S : submonoid M) : monoid ‚Ü•S
(d : declaration) : tactic bool
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {K : J ‚•§ C} {c d : category_theory.limits.cocone K} (f : c ‚ü∂ d) [i : category_theory.is_iso f.hom] : category_theory.is_iso f
{G : Type u} [add_monoid G] : is_of_fin_add_order 0
(Œ± : Type u_1) (Œ≤ : Type u_2) [mul_one_class Œ≤] : Œ≤ ‚Üí* Œ± ‚Üí Œ≤
(F : Type u_12) (A : Type u_13) (B : Type u_14) [has_mul A] [has_mul B] : Type (max u_12 u_13 u_14)
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (s : subsemiring R) (t : subsemiring S) : ‚Ü•(s.prod t) ‚âÉ+* ‚Ü•s √ó ‚Ü•t
(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop
{R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b) : is_add_left_regular (a + b)
{L' : first_order.language} {c f‚ÇÅ f‚ÇÇ : Type u} {r‚ÇÅ r‚ÇÇ : Type v} (œÜ‚ÇÄ : c ‚Üí L'.constants) (œÜ‚ÇÅ : f‚ÇÅ ‚Üí L'.functions 1) (œÜ‚ÇÇ : f‚ÇÇ ‚Üí L'.functions 2) (œÜ‚ÇÅ' : r‚ÇÅ ‚Üí L'.relations 1) (œÜ‚ÇÇ' : r‚ÇÇ ‚Üí L'.relations 2) : first_order.language.mk‚ÇÇ c f‚ÇÅ f‚ÇÇ r‚ÇÅ r‚ÇÇ ‚Üí·¥∏ L'
 : linarith.global_preprocessor
{Œ± : Type u_1} [denumerable Œ±] {Œ≥ : Œ± ‚Üí Type u_3} [Œ† (a : Œ±), denumerable (Œ≥ a)] : denumerable (sigma Œ≥)
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] : has_zero C
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : has_zero ‚Ü•P
{C D : Type u} [category_theory.small_category C] [category_theory.small_category D] (F : C ‚•§ D) (J : Type u) [category_theory.small_category J] [category_theory.limits.preserves_limits_of_shape J (category_theory.Lan F.op)] : category_theory.limits.preserves_limits_of_shape J F
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) {r : ‚Ñù} (hr : r ‚â† 0) : 2 ‚Ä¢ hb.oangle (r ‚Ä¢ x) y = 2 ‚Ä¢ hb.oangle x y
(c : ‚Ñ§) (l : linarith.linexp) : linarith.linexp
(Œπ : Type u_1) {R : Type u_2} [add_comm_monoid Œπ] [comm_monoid R] : graded_monoid.gcomm_monoid (Œª (i : Œπ), R)
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] [category_theory.has_projective_resolutions C] [category_theory.preadditive D] [category_theory.limits.has_zero_object D] [category_theory.limits.has_equalizers D] [category_theory.limits.has_cokernels D] [category_theory.limits.has_images D] [category_theory.limits.has_image_maps D] (F : C ‚•§ D) [F.additive] (X : C) [category_theory.projective X] : (F.left_derived 0).obj X ‚âÖ F.obj X
 : Type
{Œ± : Type u_1} {Œ≤ : Type u_4} [preorder Œ±] [preorder Œ≤] {u : Œ≤ ‚Üí Œ±} (l : lower_adjoint u) : set Œ±
(n : ‚Ñï) (R : Type u_1) [comm_ring R] [is_domain R] : finset R
(Œπ : Type u) (Œ≤ : Œπ ‚Üí Type v) [Œ† (i : Œπ), has_zero (Œ≤ i)] : Type (max u v)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : set P} (ho : euclidean_geometry.orthocentric_system s) {t : affine.triangle ‚Ñù P} (ht : set.range t.points ‚äÜ s) : s = has_insert.insert t.orthocenter (set.range t.points)
{G : Type u_10} {H : Type u_11} [add_group G] [subtraction_monoid H] (h : G ‚âÉ+ H) (x y : G) : ‚áëh (x - y) = ‚áëh x - ‚áëh y
{n : Type u} [decidable_eq n] [fintype n] {Œ± : Type v} [comm_ring Œ±] (A : matrix n n Œ±) [nontrivial n] : A.adjugate.adjugate = A.det ^ (fintype.card n - 2) ‚Ä¢ A
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± ‚Ñ±' : category_theory.SheafOfTypes K} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) : ‚Ñ± ‚âÖ ‚Ñ±'
(M : Type u_9) (N : Type u_10) [has_mul M] [has_mul N] : Type (max u_10 u_9)
{Œ± : Type u_1} [has_mul Œ±] [has_lt Œ±] [contravariant_class Œ± Œ± has_mul.mul has_lt.lt] {a b c : Œ±} (bc : a * b < a * c) : b < c
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] (L : A ‚•§ T) {R‚ÇÅ R‚ÇÇ : B ‚•§ T} (r : R‚ÇÅ ‚ü∂ R‚ÇÇ) : category_theory.comma L R‚ÇÅ ‚•§ category_theory.comma L R‚ÇÇ
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {n : with_top ‚Ñï} : cont_diff ùïú n f ‚Üî (‚àÄ (m : ‚Ñï), ‚Üëm ‚â§ n ‚Üí continuous (iterated_deriv m f)) ‚àß ‚àÄ (m : ‚Ñï), ‚Üëm < n ‚Üí differentiable ùïú (iterated_deriv m f)
{Œì : Type u_1} [inhabited Œì] (l : turing.list_blank Œì) : turing.list_blank Œì
{R : Type u} [semiring R] (r : R) : polynomial.X * ‚áëpolynomial.C r = ‚áëpolynomial.C r * polynomial.X
(k : Type u‚ÇÅ) (G : Type u‚ÇÇ) [comm_semiring k] [monoid G] (A : Type u‚ÇÉ) [semiring A] [algebra k A] : (G ‚Üí* A) ‚âÉ (monoid_algebra k G ‚Üí‚Çê[k] A)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} (f : Y ‚ü∂ Z) (P : category_theory.ProjectiveResolution Y) (Q : category_theory.ProjectiveResolution Z) : category_theory.ProjectiveResolution.lift f P Q ‚â´ Q.œÄ = P.œÄ ‚â´ (chain_complex.single‚ÇÄ C).map f
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} (H : C ‚•§ D) (c : category_theory.limits.cone F) : category_theory.limits.cone (F ‚ãô H)
 : matrix (fin 4) (fin 4) ‚Ñ§
(L : first_order.language) (M : Type w) [L.Structure M] : set (category_theory.bundled L.Structure)
{Œ± : Type u_1} {r s : setoid Œ±} : r ‚äî s = eqv_gen.setoid (r.rel ‚äî s.rel)
 : ‚Ñï ‚Üí expr ‚Üí list expr ‚Üí list name ‚Üí tactic (list expr √ó expr √ó list name)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {V : Type u_14} [normed_group V] [normed_space ùïú V] : smooth ((model_with_corners_self ùïú ùïú).prod (model_with_corners_self ùïú V)) (model_with_corners_self ùïú V) (Œª (p : ùïú √ó V), p.fst ‚Ä¢ p.snd)
{p : ordinal ‚Üí Prop} (i : ordinal) (h : ‚àÄ (j : ordinal), (‚àÄ (k : ordinal), k < j ‚Üí p k) ‚Üí p j) : p i
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] (f : ùïú ‚Üí F) (s : set ùïú) (x : ùïú) : F
 : function.injective real.sinh
{G : Type u_1} {Œ± : Type u_3} [measurable_space G] [measurable_space Œ±] [group G] [mul_action G Œ±] [has_measurable_smul G Œ±] (c : G) : Œ± ‚âÉ·µê Œ±
{R : Type u} [ring R] {J : Type v} [fintype J] (f : J ‚Üí Module R) : ‚®Å f ‚âÖ Module.of R (Œ† (j : J), ‚Ü•(f j))
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {A : Type u‚ÇÉ} [category_theory.category A] (J : category_theory.grothendieck_topology C) (K : category_theory.grothendieck_topology D) {L : category_theory.grothendieck_topology A} {F : C ‚•§ D} (hF : category_theory.cover_preserving J K F) {G : D ‚•§ A} (hG : category_theory.cover_preserving K L G) : category_theory.cover_preserving J L (F ‚ãô G)
(c : omega.clause) : Prop
(e : expr) (h : name) : tactic unit
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] [finite_dimensional F E] [is_galois F E] : galois_coinsertion (‚áëorder_dual.to_dual ‚àò intermediate_field.fixing_subgroup) (intermediate_field.fixed_field ‚àò ‚áëorder_dual.to_dual)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : Type w) [category_theory.category J] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ w w')
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_cancel_comm_monoid E] [ordered_add_comm_monoid Œ≤] [module ùïú E] [has_scalar ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : strict_convex_on ùïú s f) (c : E) : strict_convex_on ùïú ((Œª (z : E), c + z) ‚Åª¬π' s) (f ‚àò Œª (z : E), c + z)
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a : Œ±} : 0 < -a ‚Üî a < 0
{M : Type u_1} [group M] (c : con M) {w x : M} : ‚áëc w x ‚Üí ‚áëc w‚Åª¬π x‚Åª¬π
{C : Type u} [category_theory.category C] {X Y Z : category_theory.with_initial C} : X.hom Y ‚Üí Y.hom Z ‚Üí X.hom Z
 : expr ‚Üí tactic expr
{Œπ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape Œπ) : Type (max u u_1 v)
(L : first_order.language) {Œ± : Type w} {Œ≤ : Type u_1} (f : Œ± ‚Üí Œ≤) : L.with_constants Œ± ‚Üí·¥∏ L.with_constants Œ≤
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CompHaus) : category_theory.limits.cone F
{M : Type u_1} [has_mul M] {N : Type u_2} [has_mul N] (f : M ‚Üí‚Çô* N) : M ‚Üí‚Çô* ‚Ü•(f.srange)
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [mul_one_class Œ±] [mul_one_class Œ≤] (f : Œ± ‚Üí*o Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : Œ± ‚Üí*o Œ≤
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} (l : list M) : ‚áëclifford_algebra.involute (list.map ‚áë(clifford_algebra.Œπ Q) l).prod = (-1) ^ l.length ‚Ä¢ (list.map ‚áë(clifford_algebra.Œπ Q) l).prod
 : name ‚Üí ‚Ñï
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : is_preirreducible s ‚Üî ‚àÄ (z‚ÇÅ z‚ÇÇ : set Œ±), is_closed z‚ÇÅ ‚Üí is_closed z‚ÇÇ ‚Üí s ‚äÜ z‚ÇÅ ‚à™ z‚ÇÇ ‚Üí s ‚äÜ z‚ÇÅ ‚à® s ‚äÜ z‚ÇÇ
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) : submodule.map p.subtype ‚ä§ = p
(obj : Type u) : Type (max u (v+1))
 : computability.fin_encoding ‚Ñï
(Œ± : Sort u_1) [s : setoid Œ±] : function.surjective quotient.mk
(M : Type u_4) [mul_one_class M] : Type u_4
(z : upper_half_plane) : ‚Ñù
{V : Type u} : has_sdiff (simple_graph V)
{Œπ : Type u_1} [decidable_eq Œπ] (R : Type u_4) [comm_semiring R] (s : Œπ ‚Üí Type u_7) [Œ† (i : Œπ), add_comm_monoid (s i)] [Œ† (i : Œπ), module R (s i)] : free_add_monoid (R √ó Œ† (i : Œπ), s i) ‚Üí free_add_monoid (R √ó Œ† (i : Œπ), s i) ‚Üí Prop
{R : Type u} [comm_ring R] (t : set (prime_spectrum R)) : ideal R
{M : Type u_1} [add_zero_class M] {N : Type u_2} [add_zero_class N] (f : M ‚Üí+ N) (hf : function.surjective ‚áëf) : f.mrange = ‚ä§
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {f : ‚ÑÇ ‚Üí E} {s : set ‚ÑÇ} {c : ‚ÑÇ} (hc : s ‚àà nhds c) (hd : differentiable_on ‚ÑÇ f (s  {c})) (ho : (Œª (z : ‚ÑÇ), f z - f c) =o[nhds_within c {c}·∂ú] Œª (z : ‚ÑÇ), (z - c)‚Åª¬π) : differentiable_on ‚ÑÇ (function.update f c (lim (nhds_within c {c}·∂ú) f)) s
{n : ‚Ñï} (Œ± : fin (n + 1) ‚Üí Type u) (i : fin (n + 1)) : (Œ† (j : fin (n + 1)), Œ± j) ‚âÉ Œ± i √ó Œ† (j : fin n), Œ± (‚áë(i.succ_above) j)
(X : Profinite) : category_theory.limits.cone X.diagram
{n : Type u} [decidable_eq n] [fintype n] {Œ± : Type v} [comm_ring Œ±] (A : matrix n n Œ±) (h : fintype.card n ‚â† 1) : A.adjugate.adjugate = A.det ^ (fintype.card n - 2) ‚Ä¢ A
{G : Type u_3} [group G] : G ‚Üí* mul_aut G
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ (w+1) (w'+1))
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (hash_fn : Œ± ‚Üí ‚Ñï) {n : ‚Ñï+} (data : bucket_array Œ± Œ≤ n) (a : Œ±) : list (Œ£ (a : Œ±), Œ≤ a)
{Œ± Œ≤ : Type u} {L : Œ± ‚Üí pgame} {R : Œ≤ ‚Üí pgame} [S : (pgame.mk Œ± Œ≤ L R).short] : fintype Œ±
{M : Type u_1} {N : Type u_2} (Œ± : Type u_6) [has_vadd M Œ±] (g : N ‚Üí M) : has_vadd N Œ±
{Œì : Type u_1} [inhabited Œì] : turing.dir ‚Üí turing.tape Œì ‚Üí turing.tape Œì
{V : Type u} {G : simple_graph V} (G' : G.subgraph) (h : G'.is_spanning) : G'.spanning_coe ‚âÉg G'.coe
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] : category_theory.limits.has_finite_biproducts (category_theory.Mat_ C)
{Œπ : Type u_1} {R : Type u_2} {N : Type u_5} [dec_Œπ : decidable_eq Œπ] [ring R] [add_comm_group N] [module R N] (p : Œπ ‚Üí submodule R N) : complete_lattice.independent p ‚Üî function.injective ‚áë(‚áë(dfinsupp.lsum ‚Ñï) (Œª (i : Œπ), (p i).subtype))
(R : Type u_1) (S : Type u_2) (A : Type u_4) [semiring A] : restrict_scalars R S A ‚âÉ+* A
{R : Type u_1} {S : Type u_2} {F : Type u_3} [has_add R] [has_add S] [has_mul R] [has_mul S] [mul_equiv_class F R S] (f : F) (H : ‚àÄ (x y : R), ‚áëf (x + y) = ‚áëf x + ‚áëf y) : R ‚âÉ+* S
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) [category_theory.limits.has_limit F] : category_theory.limits.is_limit (category_theory.limits.limit.cone F)
{P : Type u_1} [preorder P] [order_top P] {F : order.pfilter P} : ‚ä§ ‚àà F
(n : interactive.parse lean.parser.small_nat) (q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) : tactic unit
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (E : Type u_2) [semi_normed_group E] [normed_space ùïú E] : normed_space.dual ùïú E ‚Üí‚Çó[ùïú] E ‚Üí‚Çó[ùïú] ùïú
{f : Type u‚ÇÄ ‚Üí Type u‚ÇÅ} {g : Type (max u‚ÇÄ v‚ÇÄ) ‚Üí Type v‚ÇÅ} [uliftable f g] {Œ± : Type u‚ÇÄ} : g (ulift Œ±) ‚Üí f Œ±
(cfg : linarith.linarith_config) (reduce_semi : bool) : linarith.linarith_config
(X : algebraic_geometry.LocallyRingedSpace) (x : ‚Ü•X) : CommRing
(v : ‚Ñï ‚Üí ‚Ñ§) : omega.term ‚Üí ‚Ñ§
{R : Type u‚ÇÅ} [non_unital_non_assoc_ring R] : is_scalar_tower ‚Ñ§ R R
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [linear_order Œ±] [order_topology Œ±] {a b : Œ±} (h : a ‚â§ b) (f : C(‚Ü•(set.Icc a b), Œ≤)) : C(Œ±, Œ≤)
{G : Type u} [add_group G] (B : add_group_filter_basis G) : topological_space G
{G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s ‚äÜ t) : group.normal_closure s ‚äÜ t
{Œ≤ : Type u_2} {Œπ : Sort u_4} (s : Œπ ‚Üí set Œ≤) : set Œ≤
{Œ± : Type u} [add_monoid Œ±] (u : add_units Œ±) : Œ±
 : expr ‚Üí expr ‚Üí tactic (expr √ó expr)
{R : Type u} {A : Type w} [comm_semiring R] [semiring A] [module R A] (h‚ÇÅ : ‚àÄ (r : R) (x : A), r ‚Ä¢ 1 * x = r ‚Ä¢ x) (h‚ÇÇ : ‚àÄ (r : R) (x : A), x * r ‚Ä¢ 1 = r ‚Ä¢ x) : algebra R A
{Œ± : Type u_1} {Œ≤ : Type u_2} [nonempty Œ±] (f : Œ± ‚Üí Œ≤) (s : set Œ±) (hf : set.inj_on f s) : local_equiv Œ± Œ≤
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {p : E ‚Üí formal_multilinear_series ùïú E F} {n : ‚Ñï} : has_ftaylor_series_up_to ‚Üë(n + 1) f p ‚Üî (‚àÄ (x : E), (p x 0).uncurry0 = f x) ‚àß (‚àÄ (x : E), has_fderiv_at (Œª (y : E), p y 0) (p x 1).curry_left x) ‚àß has_ftaylor_series_up_to ‚Üën (Œª (x : E), ‚áë(continuous_multilinear_curry_fin1 ùïú E F) (p x 1)) (Œª (x : E), (p x).shift)
{m : Type u_2} {n : Type u_3} {m' : Type u_6} {n' : Type u_7} (R : Type u_11) (A : Type u_12) [semiring R] [add_comm_monoid A] [module R A] (e‚Çò : m ‚âÉ m') (e‚Çô : n ‚âÉ n') : matrix m n A ‚âÉ‚Çó[R] matrix m' n' A
{Œ± : Type u_1} [linear_ordered_semiring Œ±] : subsingleton (floor_semiring Œ±)
{X : Type u_1} {Y : Type u_2} {Z : Type u_3} [topological_space X] [topological_space Y] (f : X ‚Üí Y) : locally_constant Y Z ‚Üí locally_constant X Z
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M ‚Üí+ P} (H : c ‚â§ add_con.ker f) (g : c.quotient ‚Üí+ P) (Hg : g.comp c.mk' = f) : g = c.lift f H
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] [category_theory.has_projective_resolutions C] [category_theory.preadditive D] [category_theory.limits.has_zero_object D] [category_theory.limits.has_equalizers D] [category_theory.limits.has_cokernels D] [category_theory.limits.has_images D] [category_theory.limits.has_image_maps D] (F : C ‚•§ D) [F.additive] (n : ‚Ñï) {X : C} (P : category_theory.ProjectiveResolution X) : (F.left_derived n).obj X ‚âÖ (homology_functor D (complex_shape.down ‚Ñï) n).obj ((F.map_homological_complex (complex_shape.down ‚Ñï)).obj P.complex)
{r : nnreal} (hr : r < 1) : has_sum (Œª (n : ‚Ñï), r ^ n) (1 - r)‚Åª¬π
(Œ± : Type u_1) (Œ≤ : Type u_2) [topological_space Œ±] [compact_space Œ±] [metric_space Œ≤] : C(Œ±, Œ≤) ‚âÉ bounded_continuous_function Œ± Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {F : C·µí·µñ ‚•§ Type v‚ÇÅ} : (category_theory.yoneda.obj X ‚ü∂ F) ‚âÉ F.obj (opposite.op X)
(Œ± : Type u_1) (Œ≤ : Type u_2) [is_empty Œ±] : Œ± ‚äï Œ≤ ‚âÉ Œ≤
(G : Type u_1) [add_group G] : galois_insertion add_subgroup.closure coe
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K‚ÇÅ K‚ÇÇ : J ‚•§ C} (F : C ‚•§ D) (h : K‚ÇÅ ‚âÖ K‚ÇÇ) [category_theory.limits.reflects_colimit K‚ÇÅ F] : category_theory.limits.reflects_colimit K‚ÇÇ F
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) : lie_module R L (M ‚ß∏ N)
{Œ± : Type u_1} (b : buffer Œ±) (i : ‚Ñï) : tactic Œ±
{R : Type u} {L : Type v} {L' : Type w‚ÇÇ} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L') (J : lie_ideal R L') : lie_ideal R L
{Œ± : Type u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí option Œ±) : Prop
(S : Type u_1) {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [comm_semiring S] [algebra S R] [invertible 2] : quadratic_form R M ‚Üí‚Çó[S] bilin_form R M
{Œπ : Type u_1} {R : Type u_2} [comm_semiring R] [linear_order Œπ] (s : finset Œπ) (f g : Œπ ‚Üí R) : s.prod (Œª (i : Œπ), f i + g i) = s.prod (Œª (i : Œπ), f i) + s.sum (Œª (i : Œπ), g i * (finset.filter (Œª (_x : Œπ), _x < i) s).prod (Œª (j : Œπ), f j + g j) * (finset.filter (Œª (j : Œπ), i < j) s).prod (Œª (j : Œπ), f j))
(R : Type u) [comm_ring R] : Top.presheaf CommRing (algebraic_geometry.prime_spectrum.Top R)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] : C
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : Top} (f : X ‚ü∂ Y) {‚Ñ± ùí¢ : Top.presheaf C Y} (Œ± : ‚Ñ± ‚ü∂ ùí¢) : Top.presheaf.pullback_obj f ‚Ñ± ‚ü∂ Top.presheaf.pullback_obj f ùí¢
{Œ± : Type u_2} [decidable_eq Œ±] (k : ‚Ñï) (ùíú : finset (finset Œ±)) : finset (finset Œ±)
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_image f] : X ‚ü∂ category_theory.limits.image f
{Œ± : Type u} [pseudo_emetric_space Œ±] : (‚àÄ (u : ‚Ñï ‚Üí Œ±), cauchy_seq u ‚Üí (‚àÉ (a : Œ±), filter.tendsto u filter.at_top (nhds a))) ‚Üí complete_space Œ±
{ùïú : Type u_1} {V : Type u_2} {V‚ÇÇ : Type u_4} {P : Type u_8} {P‚ÇÇ : Type u_9} [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V P] [normed_add_torsor V‚ÇÇ P‚ÇÇ] (e : P ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÇ) : P ‚âÉ‚Çú P‚ÇÇ
{Œ±‚ÇÅ : Sort u_3} {Œ±‚ÇÇ : Sort u_4} {Œ≤‚ÇÅ : Œ±‚ÇÅ ‚Üí Sort u_5} {Œ≤‚ÇÇ : Œ±‚ÇÇ ‚Üí Sort u_6} (f‚ÇÅ : Œ±‚ÇÅ ‚Üí Œ±‚ÇÇ) (f‚ÇÇ : Œ† (a : Œ±‚ÇÅ), Œ≤‚ÇÅ a ‚Üí Œ≤‚ÇÇ (f‚ÇÅ a)) : psigma Œ≤‚ÇÅ ‚Üí psigma Œ≤‚ÇÇ
(J : Type u‚ÇÅ) [category_theory.category J] : Type u‚ÇÅ
{Œ≤ : Type u_2} (Œ± : Type u_1) [fintype Œ±] (f : Œ± ‚âÉ Œ≤) : fintype Œ≤
{X Y : Top} (f : ‚Ü•X ‚âÉ‚Çú ‚Ü•Y) : X ‚âÖ Y
{Œ± : Type u} [pseudo_emetric_space Œ±] {Œ¥‚ÇÅ Œ¥‚ÇÇ : ‚Ñù} (hle : Œ¥‚ÇÅ ‚â§ Œ¥‚ÇÇ) (E : set Œ±) : metric.thickening Œ¥‚ÇÅ E ‚äÜ metric.thickening Œ¥‚ÇÇ E
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] [discrete_topology Œ±] (f : Œ± ‚Üí Œ≤) (C : ‚Ñù) (h : ‚àÄ (x y : Œ±), has_dist.dist (f x) (f y) ‚â§ C) : bounded_continuous_function Œ± Œ≤
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C] (F : category_theory.limits.walking_parallel_pair ‚•§ C) : category_theory.limits.has_equalizers_of_pullbacks_and_binary_products.construct_equalizer F ‚ü∂ F.obj category_theory.limits.walking_parallel_pair.zero
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [linear_order Œ≤] : order.partial_iso Œ± Œ≤ ‚Üí order.partial_iso Œ≤ Œ±
{Œ± : Type u_1} {M : Type u_5} [add_zero_class M] (p : Œ± ‚Üí Prop) : (Œ± ‚Üí‚ÇÄ M) ‚Üí+ Œ± ‚Üí‚ÇÄ M
{n : ‚Ñï} (hpos : 0 < n) {p : ‚Ñï} [hprime : fact (nat.prime p)] {a : ‚Ñï} (hroot : (polynomial.cyclotomic n (zmod p)).is_root (‚áë(nat.cast_ring_hom (zmod p)) a)) : a.coprime p
 : interactive.parse lean.parser.small_nat ‚Üí tactic.interactive.itactic ‚Üí tactic unit
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] {Z : C} (l : X ‚ü∂ Z) (i : Z ‚âÖ Y) (h : l ‚â´ i.hom = f) : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ (category_theory.limits.kernel.Œπ f) _)
{Œ± : Type u_1} {n : Type u_3} {A : matrix n n Œ±} : (‚àÄ (i j : n), A j i = A i j) ‚Üí A.is_symm
(K : Type u_4) (V : Type u) [division_ring K] [add_comm_group V] [module K V] : basis ‚Ü•(basis.of_vector_space_index K V) K V
{R : Type u} [ring R] {J : Type w} [category_theory.category J] (F : J ‚•§ Module R) : Type (max u v w)
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
(n : name) (ls : list name) (type : expr) (tac : tactic unit) : tactic expr
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] (F : C ‚•§ D) [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete pempty) F] [category_theory.limits.has_finite_products C] (n : ‚Ñï) (f : ulift (fin n) ‚Üí C) : category_theory.limits.preserves_limit (category_theory.discrete.functor f) F
 : ‚Ñï+ ‚âÉ ‚Ñï
{V : Type u} {G : simple_graph V} (H : G.subgraph) : set V
{Œ± : Type u_2} {Œ≤ : Type u_3} [comm_monoid Œ±] [comm_monoid Œ≤] {A : set Œ±} {n : ‚Ñï} : has_mul (A ‚Üí*[n] Œ≤)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {v : ‚Ñù ‚Üí E ‚Üí E} {s : ‚Ñù ‚Üí set E} {K : ‚Ñù} (hv : ‚àÄ (t : ‚Ñù) (x : E), x ‚àà s t ‚Üí ‚àÄ (y : E), y ‚àà s t ‚Üí has_dist.dist (v t x) (v t y) ‚â§ K * has_dist.dist x y) {f g : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : continuous_on f (set.Icc a b)) (hf' : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_deriv_within_at f (v t (f t)) (set.Ici t) t) (hfs : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí f t ‚àà s t) (hg : continuous_on g (set.Icc a b)) (hg' : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_deriv_within_at g (v t (g t)) (set.Ici t) t) (hgs : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí g t ‚àà s t) (ha : f a = g a) (t : ‚Ñù) (H : t ‚àà set.Icc a b) : f t = g t
{Œ± : Type u_1} [measurable_space Œ±] : (Œ± ‚Üí ennreal) ‚Üí ‚Ñï ‚Üí measure_theory.simple_func Œ± ennreal
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {r t : category_theory.limits.cocone F} (P : category_theory.limits.is_colimit r) (i : r ‚âÖ t) : category_theory.limits.is_colimit t
{C : Type u} [category_theory.category C] {Œπ : Type u_1} {s : Œπ ‚Üí C} [category_theory.preadditive C] [category_theory.limits.has_finite_biproducts C] [‚àÄ (i : Œπ), invariant_basis_number (category_theory.End (s i))] (o : category_theory.hom_orthogonal s) {Œ± Œ≤ : Type v} [fintype Œ±] [fintype Œ≤] {f : Œ± ‚Üí Œπ} {g : Œ≤ ‚Üí Œπ} (i : (‚®Å Œª (a : Œ±), s (f a)) ‚âÖ ‚®Å Œª (b : Œ≤), s (g b)) : ‚àÉ (e : Œ± ‚âÉ Œ≤), ‚àÄ (a : Œ±), g (‚áëe a) = f a
 : tactic (list expr)
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] : ordnode Œ± ‚Üí ordnode Œ± ‚Üí bool
{Œ± : Type u_1} (s : finset Œ±) (hs : s.nonempty) : pmf Œ±
{C : Type u} [category_theory.category C] (X : algebraic_geometry.PresheafedSpace C) : X.restrict _ ‚âÖ X
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R‚ÇÅ R‚ÇÇ : category_theory.presieve X} (h : R‚ÇÅ ‚â§ R‚ÇÇ) {x : category_theory.presieve.family_of_elements P R‚ÇÇ} : x.compatible ‚Üí (category_theory.presieve.family_of_elements.restrict h x).compatible
{R : Type u_1} {R‚ÇÅ : Type u_2} {M‚ÇÅ : Type u_6} {n : Type u_14} [comm_semiring R] [comm_semiring R‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] {I‚ÇÅ I‚ÇÅ' : R‚ÇÅ ‚Üí+* R} (B : M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ] M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ'] R) (v : n ‚Üí M‚ÇÅ) : Prop
{Œ± : Type u_1} {Œ±' : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_5} {Œ¥ : Type u_7} {m : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {f : filter Œ±} {g : filter Œ≤} {n : Œ≥ ‚Üí Œ¥} {m' : Œ±' ‚Üí Œ≤ ‚Üí Œ¥} {n' : Œ± ‚Üí Œ±'} (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤), n (m a b) = m' (n' a) b) : filter.map n (filter.map‚ÇÇ m f g) = filter.map‚ÇÇ m' (filter.map n' f) g
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] tensor_product R M N
(n : ‚Ñï) : (finset.range n).sum (Œª (i : ‚Ñï), i) * 2 = n * (n - 1)
{M : Type u_1} [has_mul M] : has_Inf (con M)
{Œπ : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [ordered_comm_monoid N] (f : M ‚Üí N) (h_mul : ‚àÄ (x y : M), f (x * y) ‚â§ f x * f y) {s : finset Œπ} (hs : s.nonempty) (g : Œπ ‚Üí M) : f (s.prod (Œª (i : Œπ), g i)) ‚â§ s.prod (Œª (i : Œπ), f (g i))
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} : category_theory.limits.cocones.precompose (ùüô F) ‚âÖ ùü≠ (category_theory.limits.cocone F)
{Œ± : Type u} [has_ssubset Œ±] [is_trans Œ± has_ssubset.ssubset] {a b c : Œ±} : a ‚äÇ b ‚Üí b ‚äÇ c ‚Üí a ‚äÇ c
{Œ± : Type u} (s : wseq Œ±) (n : ‚Ñï) : wseq Œ±
(p : ‚Ñù √ó ‚Ñù) (hp : p.fst < 0) : has_strict_fderiv_at (Œª (x : ‚Ñù √ó ‚Ñù), x.fst ^ x.snd) ((p.snd * p.fst ^ (p.snd - 1)) ‚Ä¢ continuous_linear_map.fst ‚Ñù ‚Ñù ‚Ñù + (p.fst ^ p.snd * real.log p.fst - real.exp (real.log p.fst * p.snd) * real.sin (p.snd * real.pi) * real.pi) ‚Ä¢ continuous_linear_map.snd ‚Ñù ‚Ñù ‚Ñù) p
{R : Type u_1} [distrib R] (r : R) : add_hom R R
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] (c : set (linear_pmap R E F)) (hc : directed_on has_le.le c) : linear_pmap R E F
{Œ± : Type u_1} {Œ≤ : Type u_2} [conditionally_complete_lattice Œ±] (f : filter Œ≤) (u : Œ≤ ‚Üí Œ±) : Œ±
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} {s t : category_theory.limits.pushout_cocone f g} (i : s.X ‚âÖ t.X) (w‚ÇÅ : s.inl ‚â´ i.hom = t.inl) (w‚ÇÇ : s.inr ‚â´ i.hom = t.inr) : s ‚âÖ t
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : (‚àÄ (f : ‚Ñï ‚Üío submodule R M), ‚àÉ (n : ‚Ñï), ‚àÄ (m : ‚Ñï), n ‚â§ m ‚Üí ‚áëf n = ‚áëf m) ‚Üî is_noetherian R M
{R : Type u_1} [semiring R] : R ‚Üí+* laurent_polynomial R
{S : Type u_1} [has_mul S] (a : S) : commute a a
(n : name) (tac : tactic unit) : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {X Y Z : C} (p : X = Y) (q : Y ‚ü∂ Z) : _.mpr q = category_theory.eq_to_hom p ‚â´ q
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a : Œ±} : -a < 0 ‚Üî 0 < a
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] [category_theory.has_projective_resolutions C] [category_theory.preadditive D] [category_theory.limits.has_zero_object D] [category_theory.limits.has_equalizers D] [category_theory.limits.has_cokernels D] [category_theory.limits.has_images D] [category_theory.limits.has_image_maps D] (F : C ‚•§ D) [F.additive] (n : ‚Ñï) : C ‚•§ D
{Œ± : Type u} (n : ‚Ñï) (cmd : slim_check.gen Œ±) : slim_check.gen (vector Œ± n)
{R : Type u_1} [semiring R] : power_series R
{Œ± : Sort u} {Œ≤ : Sort v} {Œ≥ : Sort w} (e : Œ± ‚Ü™ Œ≤) : (Œ≥ ‚Üí Œ±) ‚Ü™ Œ≥ ‚Üí Œ≤
{X : Type u_1} [topological_space X] [noncompact_space X] : dense_range coe
{Œ± : Type u} {Œ≤ : Type v} (f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤) (as : list Œ±) : list Œ≤
(G : Type u_3) [add_group G] : Type u_3
(R : Type u) {X : Type v} [semiring R] : X ‚Üí free_non_unital_non_assoc_algebra R X
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} {Œπ : Type u_5} [linear_ordered_field ùïú] [add_comm_group E] [ordered_add_comm_group Œ≤] [module ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} {t : finset Œπ} {w : Œπ ‚Üí ùïú} {p : Œπ ‚Üí E} (hf : convex_on ùïú s f) (h‚ÇÄ : ‚àÄ (i : Œπ), i ‚àà t ‚Üí 0 ‚â§ w i) (h‚ÇÅ : 0 < t.sum (Œª (i : Œπ), w i)) (hmem : ‚àÄ (i : Œπ), i ‚àà t ‚Üí p i ‚àà s) : f (t.center_mass w p) ‚â§ t.center_mass w (f ‚àò p)
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z ‚Üí B) : Prop
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) : hb.oangle (‚áë(hb.conj_lie) x) (‚áë(hb.conj_lie) y) = -hb.oangle x y
{Œì : Type u_1} {R : Type u_2} [ordered_cancel_add_comm_monoid Œì] [semiring R] {Œ± : Type u_3} : hahn_series.summable_family Œì R Œ± ‚Üí‚Çó[hahn_series Œì R] hahn_series Œì R
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_well_order Œ± r] : subrel has_lt.lt (Œª (_x : ordinal), _x < ordinal.type r) ‚âÉr r
{K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {n : ‚Ñï} {ifp_n : generalized_continued_fraction.int_fract_pair K} (stream_nth_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) (nth_fr_ne_zero : ifp_n.fr ‚â† 0) : (generalized_continued_fraction.of v).s.nth n = option.some {a := 1, b := ‚Üë((generalized_continued_fraction.int_fract_pair.of (ifp_n.fr)‚Åª¬π).b)}
(Œ± : Type u_1) [measurable_space Œ±] : measure_theory.signed_measure Œ± ‚âÉ measure_theory.jordan_decomposition Œ±
{M : Type u_1} {N : Type u_2} [has_one M] [has_one N] (f : one_hom M N) : one_hom (with_top M) (with_top N)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ‚Ñù P) {i‚ÇÅ : fin 3} : t.orthocenter ‚àà affine.simplex.altitude t i‚ÇÅ
{Œ± : Type u} [semigroup Œ±] [has_distrib_neg Œ±] (a b : Œ±) : a ‚à£ -b ‚Üî a ‚à£ b
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) (s : category_theory.limits.cocone F) : AddCommGroup.colimits.prequotient F ‚Üí ‚Ü•(s.X)
{R : Type u_1} [comm_semiring R] (M : Type u_4) {N : Type u_5} {P : Type u_6} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] (f : N ‚Üí‚Çó[R] P) : tensor_product R N M ‚Üí‚Çó[R] tensor_product R P M
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : euclidean_geometry.angle p2 p1 p3 = 0
{Œ± : Type u_2} [has_one Œ±] : one_hom Œ± (filter Œ±)
(V : Type v) [category_theory.category V] [category_theory.monoidal_category V] (C : Type u‚ÇÅ) [category_theory.enriched_category V C] : category_theory.enriched_functor V C C
(config : linear_combo.linear_combination_config) : tactic unit
{C : Type u} [category_theory.category C] (ùí¢ : set C) : Prop
{Œ± : Type u_6} : has_faithful_smul (function.End Œ±) Œ±
{Œ± : Type u} [complete_lattice Œ±] (f : Œ± ‚Üío Œ±) : complete_lattice ‚Ü•(function.fixed_points ‚áëf)
(n : interactive.parse (optional lean.parser.ident)) : tactic unit
{E : Type u_2} [add_comm_group E] [module ‚Ñù E] [topological_space E] [topological_add_group E] [has_continuous_smul ‚Ñù E] : path_connected_space E
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b : Œ±} (ha : a < 0) (hb : b ‚â§ 0) : a + b < 0
(h : expr) : tactic name_set
{Œ± : Type u_1} (Œπ : Type u_2) [preorder Œπ] (m : measurable_space Œ±) : Type (max u_1 u_2)
{M : Type u_1} [add_comm_monoid M] (x : M) : Type u_1
{L : first_order.language} (T : L.Theory) : Prop
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y z : M} (hxy : same_ray R x y) (hyz : same_ray R y z) (hy : y = 0 ‚Üí x = 0 ‚à® z = 0) : same_ray R x z
{ùïú : Type u} [hnorm : nondiscrete_normed_field ùïú] {t : topological_space ùïú} (h‚ÇÅ : topological_add_group ùïú) (h‚ÇÇ : has_continuous_smul ùïú ùïú) (h‚ÇÉ : t2_space ùïú) : t = uniform_space.to_topological_space
{Œ± : Type u_1} [complete_lattice Œ±] {p q : Prop} {s : p ‚Üí q ‚Üí Œ±} : (‚®Ö (h‚ÇÅ : p) (h‚ÇÇ : q), s h‚ÇÅ h‚ÇÇ) = ‚®Ö (h : p ‚àß q), s _ _
{C : Type u} [category_theory.category C] {f g : category_theory.arrow C} [‚àÄ (n : ‚Ñï), category_theory.limits.has_wide_pushout f.left (Œª (i : ulift (fin (n + 1))), f.right) (Œª (i : ulift (fin (n + 1))), f.hom)] [‚àÄ (n : ‚Ñï), category_theory.limits.has_wide_pushout g.left (Œª (i : ulift (fin (n + 1))), g.right) (Œª (i : ulift (fin (n + 1))), g.hom)] (F : f ‚ü∂ g) : f.cech_conerve ‚ü∂ g.cech_conerve
{C : Type u_1} [category_theory.bicategory C] (X : C) : Type u_3
{R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [semiring R] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [semi_normed_group E] [semi_normed_group E‚ÇÇ] [module R E] [module R‚ÇÇ E‚ÇÇ] : has_coe_to_fun (E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) (Œª (_x : E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ), E ‚Üí E‚ÇÇ)
 : list ‚Ñï ‚Üí list turing.partrec_to_TM2.Œì'
{M : Type u_1} {A : Type u_5} [has_mul M] [set_like A M] [hA : mul_mem_class A M] (S' : A) : has_mul ‚Ü•S'
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (n : with_top ‚Ñï) (f : E ‚Üí F) (p : E ‚Üí formal_multilinear_series ùïú E F) : Prop
{Œ≤ : Type u} {Œ≥ : Type w} [semiring Œ≤] [semiring Œ≥] (f : Œ≤ ‚Üí+* Œ≥) (l : list Œ≤) : ‚áëf l.prod = (list.map ‚áëf l).prod
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (R : D ‚•§ C) [category_theory.is_right_adjoint R] : C ‚•§ D
(n : name) : tactic expr
{Œ± : Type u} [monoid Œ±] (u : Œ±À£) : invertible ‚Üëu
{Œ± : Type u_1} {Œ≤ : Type u_2} {p : Œ± ‚Üí Prop} (f : Œ† (a : Œ±), p a ‚Üí Œ≤) (s : multiset Œ±) : (‚àÄ (a : Œ±), a ‚àà s ‚Üí p a) ‚Üí multiset Œ≤
{Œ± : Type u_1} [decidable_eq Œ±] (a : Œ±) (s : multiset Œ±) : multiset Œ±
{M : Type u_1} [add_group M] (c : add_con M) {w x y z : M} : ‚áëc w x ‚Üí ‚áëc y z ‚Üí ‚áëc (w - y) (x - z)
(Œ± : Type u_1) [add_monoid Œ±] [has_one Œ±] : ‚Ñï ‚Üí+ Œ±
(struct_n : name) : tactic (list name √ó list name)
{R : Type u} [semiring R] {P : polynomial R ‚Üí Prop} (p : polynomial R) (h0 : 0 < p.degree) (hC : ‚àÄ {a : R}, a ‚â† 0 ‚Üí P (‚áëpolynomial.C a * polynomial.X)) (hX : ‚àÄ {p : polynomial R}, 0 < p.degree ‚Üí P p ‚Üí P (p * polynomial.X)) (hadd : ‚àÄ {p : polynomial R} {a : R}, 0 < p.degree ‚Üí P p ‚Üí P (p + ‚áëpolynomial.C a)) : P p
{Œ± : Type u} {m n : ‚Ñï} (hm : m = n + n) (v : fin m ‚Üí Œ±) (k : fin n) : Œ±
(X : Type u_1) [topological_space X] : preorder X
{Œ± : Type u_1} [measurable_space Œ±] : measure_theory.finite_measure Œ± ‚Üí+ measure_theory.measure Œ±
{Œ± : Type u} (s : seq Œ±) {m n : ‚Ñï} (m_le_n : m ‚â§ n) (terminated_at_m : s.terminated_at m) : s.terminated_at n
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F G : J ‚•§ C} (H : C ‚•§ D) {Œ± : F ‚ü∂ G} {c : category_theory.limits.cone F} : H.map_cone ((category_theory.limits.cones.postcompose Œ±).obj c) ‚âÖ (category_theory.limits.cones.postcompose (category_theory.whisker_right Œ± H)).obj (H.map_cone c)
(Œ± : Type u_1) [fintype Œ±] : trunc {f // function.bijective f}
{C : Type u} [category_theory.category C] {X Y : Top} {f g : X ‚ü∂ Y} (h : f = g) (‚Ñ± : Top.presheaf C X) : f _* ‚Ñ± ‚âÖ g _* ‚Ñ±
{k n : ‚Ñï} (s : finset ‚Ñï) (hs : add_salem_spencer ‚Üës) (hsn : ‚àÄ (x : ‚Ñï), x ‚àà s ‚Üí x < n) (hsk : s.card = k) : k ‚â§ ‚áëroth_number_nat n
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} : strict_anti_on f s ‚Üí strict_mono_on (f ‚àò ‚áëorder_dual.of_dual) s
{Œ± : Type u_1} {Œ≤ : Type u_2} [infinite Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) : ‚àÉ (y : Œ≤), infinite ‚Ü•(f ‚Åª¬π' {y})
{Œ± : Type u_3} (f : filter Œ±) [f.is_countably_generated] [f.ne_bot] : ‚àÉ (x : ‚Ñï ‚Üí Œ±), filter.tendsto x filter.at_top f
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : Œ± ‚Üí. Œ≤
{Œ± : Type u_1} [topological_space Œ±] [quasi_sober Œ±] {S : set Œ±} (hS : is_irreducible S) : Œ±
{Œ± : Type u_1} [linear_ordered_comm_group_with_zero Œ±] {a : Œ±} (ha : a ‚â† 0) : Œ± ‚âÉo Œ±
{Œ± : Type u} : ordnode Œ± ‚Üí Œ± ‚Üí ordnode Œ± ‚Üí ordnode Œ± √ó Œ±
{M‚ÇÅ : Type u_6} {M‚ÇÇ : Type u_7} [topological_space M‚ÇÇ] [t2_space M‚ÇÇ] [add_zero_class M‚ÇÅ] [add_zero_class M‚ÇÇ] [has_continuous_add M‚ÇÇ] {F : Type u_8} [add_monoid_hom_class F M‚ÇÅ M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : f ‚àà closure (set.range (Œª (f : F) (x : M‚ÇÅ), ‚áëf x))) : M‚ÇÅ ‚Üí+ M‚ÇÇ
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] [t2_space Œ±] {s t : set Œ≤} {f g : Œ≤ ‚Üí Œ±} (h : set.eq_on f g s) (hf : continuous_on f t) (hg : continuous_on g t) (hst : s ‚äÜ t) (hts : t ‚äÜ closure s) : set.eq_on f g t
{C : Type u‚ÇÅ} [category_theory.category C] {P Q R S : C} {f : P ‚ü∂ Q} {g : P ‚ü∂ R} {h : Q ‚ü∂ S} {k : R ‚ü∂ S} [hr : category_theory.regular_mono h] (comm : f ‚â´ h = g ‚â´ k) (t : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk f g comm)) : category_theory.regular_mono g
{Œ± : Type u_1} [has_le Œ±] {a : Œ±·µí·µà} : is_min a ‚Üí is_max (‚áëorder_dual.of_dual a)
(K : Type u‚ÇÅ) [field K] (v : valuation K nnreal) (O : Type u‚ÇÇ) [comm_ring O] [algebra O K] (hv : v.integers O) (p : ‚Ñï) [hp : fact (nat.prime p)] [hvp : fact (‚áëv ‚Üëp ‚â† 1)] : valuation (pre_tilt K v O hv p) nnreal
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : local_homeomorph Œ± Œ≤) {b : Œ≤} (hb : b ‚àà e.to_local_equiv.target) {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} : f =o[nhds b] g ‚Üî (f ‚àò ‚áëe) =o[nhds (‚áë(e.symm) b)] (g ‚àò ‚áëe)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits_of_shape J C] : (J ‚•§ C) ‚•§ C
(red : tactic.transparency) (m : list (expr √ó ‚Ñï)) (e : expr) : tactic (list (expr √ó ‚Ñï) √ó linarith.sum)
{R : Type u} {M : Type v} [add_comm_group M] [ring R] [module R M] (S : submodule R M) [S.is_principal] : M
{Œ± : Type v} {S : Type w} (e : Œ± ‚âÉ S) : small Œ±
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {R : Type u_1} [semiring k] [add_monoid G] [semiring R] (f : k ‚Üí+* R) (g : multiplicative G ‚Üí* R) (h_comm : ‚àÄ (x : k) (y : multiplicative G), commute (‚áëf x) (‚áëg y)) : add_monoid_algebra k G ‚Üí+* R
{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] (h : G) : continuous (Œª (g : G), g * h * g‚Åª¬π)
(G : Type u_1) [comm_monoid G] : ‚Ü•(comm_monoid.torsion ‚Ü•(comm_monoid.torsion G)) ‚âÉ* ‚Ü•(comm_monoid.torsion G)
{M : Type u_2} {Œ± : Sort u_4} [comm_monoid M] (f : Œ± ‚Üí M) : M
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] : C ‚•§ D ‚•§ E ‚âå C √ó D ‚•§ E
{Œ≤ : Type v} [has_zero Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_scalar ‚Ñï Œ≤] {Œ± : Type u} [semiring Œ±] [has_one Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : semiring Œ≤
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] (f : equiv.perm Œ±) (x : Œ±) : equiv.perm Œ±
{Œ± : Type u_1} {Œ±' : Type u_2} {Œ≤ : Œ± ‚Üí Type u_3} {Œ≤' : Œ±' ‚Üí Type u_4} (f : Œ± ‚Ü™ Œ±') (g : Œ† (a : Œ±), Œ≤ a ‚Ü™ Œ≤' (‚áëf a)) : (Œ£ (a : Œ±), Œ≤ a) ‚Ü™ Œ£ (a' : Œ±'), Œ≤' a'
(R : Type u_1) [comm_semiring R] (M : Type u_4) [add_comm_monoid M] [module R M] : tensor_product R M R ‚âÉ‚Çó[R] M
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_lt.lt] {a b : Œ±} : a‚Åª¬π < b‚Åª¬π ‚Üí b < a
(k : ‚Ñï+) (M : Type u_1) [comm_monoid M] : subgroup MÀ£
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [add_comm_monoid Œ≤] {s : finset Œ≥} {t : finset Œ±} {f : Œ≥ ‚Üí Œ± ‚Üí Œ≤} : (s.product t).sum (Œª (x : Œ≥ √ó Œ±), f x.fst x.snd) = s.sum (Œª (x : Œ≥), t.sum (Œª (y : Œ±), f x y))
{Œ± : Type} (n_uvars n_mvars : ‚Ñï) : tactic.unsafe.type_context Œ± ‚Üí tactic.unsafe.type_context Œ±
{n : ‚Ñï} {E : Type u_1} [normed_group E] {f g : (fin n ‚Üí ‚ÑÇ) ‚Üí E} {c : fin n ‚Üí ‚ÑÇ} {R : fin n ‚Üí ‚Ñù} (hf : torus_integrable f c R) (hg : torus_integrable g c R) : torus_integrable (f + g) c R
(cl : tactic.closure) : list (expr √ó expr) ‚Üí list (expr √ó expr) ‚Üí expr ‚Üí tactic unit
(n : ‚Ñï) : tactic ((expr ‚Üí tactic unit) √ó tactic unit)
(M : Type u_1) [measurable_space M] [has_sup M] : Prop
{Œ± : Type u} (msg : format) (t : tactic Œ±) : tactic Œ±
(m : ‚Ñï) (p : omega.int.preform) : tactic expr
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : category_theory.monoidal_functor (category_theory.monoidal.transported e) C
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] {F : Type v} [normed_group F] [normed_space ‚ÑÇ F] {f : E ‚Üí F} (hf : differentiable ‚ÑÇ f) (hb : metric.bounded (set.range f)) : ‚àÉ (c : F), f = function.const E c
 : category_theory.limits.walking_span
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [add_group Œ≤] : add_group Œ±
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_coproduct X X] : X ‚®ø X ‚ü∂ X
{F : Type} [comm_semiring F] {q : ‚Ñï} {f : polynomial F} (hf : polynomial.has_separable_contraction q f) : hf.degree ‚à£ f.nat_degree
(Œ± : Type u) (Œ≤ : Type v) [group Œ±] [mul_action Œ± Œ≤] [fintype Œ±] [Œ† (a : Œ±), fintype ‚Ü•(mul_action.fixed_by Œ± Œ≤ a)] [fintype (quotient (mul_action.orbit_rel Œ± Œ≤))] : finset.univ.sum (Œª (a : Œ±), fintype.card ‚Ü•(mul_action.fixed_by Œ± Œ≤ a)) = fintype.card (quotient (mul_action.orbit_rel Œ± Œ≤)) * fintype.card Œ±
{m : Type u} {n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] [fintype m] [decidable_eq m] (A : matrix m n Œ±) (B : matrix n m Œ±) : (1 + A.mul B).det = (1 + B.mul A).det
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {i : D ‚•§ C} [category_theory.reflective i] {A : C} {B : D} (f : i.obj ((category_theory.left_adjoint i).obj A) ‚ü∂ i.obj B) : ‚áë((category_theory.unit_comp_partial_bijective_aux A B).symm) f = (category_theory.adjunction.of_right_adjoint i).unit.app A ‚â´ f
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] {f g : bounded_continuous_function Œ± Œ≤} [is_empty Œ±] : has_dist.dist f g = 0
(pp : linarith.global_branching_preprocessor) (l : list expr) : tactic (list linarith.branch)
(es : tactic.explode.entries) : tactic (widget.html empty)
(X : algebraic_geometry.LocallyRingedSpace) (r : ‚Ü•(algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X))) (f : (algebraic_geometry.Spec.structure_sheaf ‚Ü•(algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X))).val.obj (opposite.op (prime_spectrum.basic_open r)) ‚ü∂ X.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op (X.to_Œì_Spec_map_basic_open r))) : algebraic_geometry.structure_sheaf.to_open ‚Ü•(algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X)) (prime_spectrum.basic_open r) ‚â´ f = X.to_to_Œì_Spec_map_basic_open r ‚Üî f = X.to_Œì_Spec_c_app r
(r : ‚Ñö) : Prop
{Œ± : Type u} [uniform_space Œ±] {f : filter Œ±} {x : Œ±} (adhs : ‚àÄ (s : set (Œ± √ó Œ±)), s ‚àà uniformity Œ± ‚Üí (‚àÉ (t : set Œ±) (H : t ‚àà f), t √óÀ¢ t ‚äÜ s ‚àß ‚àÉ (y : Œ±), (x, y) ‚àà s ‚àß y ‚àà t)) : f ‚â§ nhds x
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {f : E √ó F ‚Üí G} (h : is_bounded_bilinear_map ùïú f) (p : E √ó F) : E √ó F ‚ÜíL[ùïú] G
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ±} (h : isometry f) (hg : function.right_inverse g f) : isometry g
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ : X} (p : path x‚ÇÄ x‚ÇÅ) : (p.trans (path.refl x‚ÇÅ)).homotopy p
(p : ‚Ñï) [fact (nat.prime p)] (k : Type u_1) [field k] [is_alg_closed k] [char_p k p] (V : Type u_2) [add_comm_group V] [witt_vector.isocrystal p k V] (h_dim : finite_dimensional.finrank (fraction_ring (witt_vector p k)) V = 1) : ‚àÉ (m : ‚Ñ§), nonempty (witt_vector.isocrystal_equiv p k (witt_vector.standard_one_dim_isocrystal p k m) V)
{R : Type u} [has_add R] : has_mul (tropical R)
{Œ± : Type u} [add_comm_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b c : Œ±} : b ‚â§ c - a ‚Üí a + b ‚â§ c
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [semi_normed_group Œ≤] : has_sub (bounded_continuous_function Œ± Œ≤)
(decl : name) : tactic norm_cast.label
{C : Type u} [category_theory.category C] {X Y : Top} (f : X ‚ü∂ Y) (‚Ñ± : Top.presheaf C X) : Top.presheaf C Y
(n : ‚Ñï) : finset.univ.sum (Œª (i : affine.simplex.points_with_circumcenter_index (n + 2)), affine.simplex.monge_point_weights_with_circumcenter n i) = 1
{R : Type u} [non_assoc_semiring R] (M : submonoid R) : subsemiring R
 : list expr ‚Üí list (expr √ó expr) ‚Üí list expr √ó list (expr √ó expr)
{Œ± : Type u_1} {Œ≤ : Type u_2} [monoid Œ≤] {s : finset Œ±} (f g : Œ± ‚Üí Œ≤) (comm_ff : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí commute (f x) (f y)) (comm_gg : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí commute (g x) (g y)) (comm_gf : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí x ‚â† y ‚Üí commute (g x) (f y)) : s.noncomm_prod (f * g) _ = s.noncomm_prod f comm_ff * s.noncomm_prod g comm_gg
{Œ± : Type u} (s : set Œ±) : filter Œ±
{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R M) ‚Üî monoid.fg M
(Œ± : Type u) : Type u
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ‚Ñ§] {X Y : category_theory.differential_object C} (f : X.X ‚âÖ Y.X) (hf : X.d ‚â´ (category_theory.shift_functor C 1).map f.hom = f.hom ‚â´ Y.d) : X ‚âÖ Y
{k : Type u_1} [ring k] {Œπ : Type u_10} {V : Œπ ‚Üí Type u_11} {P : Œπ ‚Üí Type u_12} [Œ† (i : Œπ), add_comm_group (V i)] [Œ† (i : Œπ), module k (V i)] [Œ† (i : Œπ), add_torsor (V i) (P i)] (i : Œπ) : (Œ† (i : Œπ), P i) ‚Üí·µÉ[k] P i
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {ca cb : E} {la lb : filter ‚Ñù} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f la measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f lb measure_theory.measure_space.volume) {s t : set ‚Ñù} [interval_integral.FTC_filter a (nhds_within a s) la] [interval_integral.FTC_filter b (nhds_within b t) lb] (ha : filter.tendsto f (la ‚äì measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (lb ‚äì measure_theory.measure_space.volume.ae) (nhds cb)) (hs : unique_diff_within_at ‚Ñù s a . "unique_diff_within_at_Ici_Iic_univ") (ht : unique_diff_within_at ‚Ñù t b . "unique_diff_within_at_Ici_Iic_univ") : fderiv_within ‚Ñù (Œª (p : ‚Ñù √ó ‚Ñù), ‚à´ (x : ‚Ñù) in p.fst..p.snd, f x) (s √óÀ¢ t) (a, b) = (continuous_linear_map.snd ‚Ñù ‚Ñù ‚Ñù).smul_right cb - (continuous_linear_map.fst ‚Ñù ‚Ñù ‚Ñù).smul_right ca
{Œ± : Type u} (s : seq Œ±) : ‚Ñï ‚Üí seq Œ±
{Œì : Type u_1} [inhabited Œì] (l : turing.list_blank Œì) (n : ‚Ñï) : Œì
 : vm ‚Ñï
(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : valuation (ratfunc Fq) (with_zero (multiplicative ‚Ñ§))
{X Y Z : Pointed} (f : X.hom Y) (g : Y.hom Z) : X.hom Z
{k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k ‚Üí E} {a b r : k} (h : 0 < r * (b - a)) : ‚áë(affine_map.line_map (f a) (f b)) r < f (‚áë(affine_map.line_map a b) r) ‚Üî slope f a b < slope f a (‚áë(affine_map.line_map a b) r)
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] [has_add Œ≤] : Œ±·µÉ·µí·µñ ‚âÉ+ Œ≤·µÉ·µí·µñ ‚âÉ (Œ± ‚âÉ+ Œ≤)
{Œ± : Type u_1} [decidable_eq Œ±] {s : finset Œ±} {a b : Œ±} (hs : b ‚àà s) (hsa : b ‚àâ s.erase a) : b = a
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_4} [fintype Œπ] [decidable_eq Œπ] (b : basis Œπ R M) : linear_map.trace R M = (contract_left R M).comp (dual_tensor_hom_equiv_of_basis b).symm.to_linear_map
{Œ± : Type u} (x : Œ±) : free_group Œ±
{Œ± : Type u} [pseudo_emetric_space Œ±] : group (Œ± ‚âÉ·µ¢ Œ±)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {s : set E} {x : E} : mfderiv_within (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f s x = fderiv_within ùïú f s x
{Œ± : Type u_1} {s : finset Œ±} : s.nonempty ‚Üí 0 < s.card
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≤' : Type u_4} {Œ≥ : Type u_5} {Œ¥ : Type u_7} {m : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {f : filter Œ±} {g : filter Œ≤} {n : Œ≥ ‚Üí Œ¥} {m' : Œ≤' ‚Üí Œ± ‚Üí Œ¥} {n' : Œ≤ ‚Üí Œ≤'} (h_antidistrib : ‚àÄ (a : Œ±) (b : Œ≤), n (m a b) = m' (n' b) a) : filter.map n (filter.map‚ÇÇ m f g) = filter.map‚ÇÇ m' (filter.map n' g) f
{Œ± : Type u_1} {n : ‚Ñï} (f : fin2 n ‚Üí Œ±) : vector3 Œ± n
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] {Z : D} (F : C ‚•§ D) (M : Œ† (x : C), Z ‚ü∂ F.obj x) (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), M x ‚â´ F.map f = M y) : (category_theory.with_initial.lift F M hM).obj category_theory.with_initial.star ‚âÖ Z
 : Type
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] : (M ‚âÉ‚Çó[R] M) ‚Üí* RÀ£
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] {A' : Type u_1} [semiring A'] [algebra R A'] (f : A ‚Üí‚Çê[R] A') : submodule R A ‚Üí*‚ÇÄ submodule R A'
(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A} : is_integral R x ‚Üí is_algebraic R x
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [has_one M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñï] [has_inv M‚ÇÅ] [has_div M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñ§] [comm_group M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (inv : ‚àÄ (x : M‚ÇÅ), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : M‚ÇÅ), f (x / y) = f x / f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (x ^ n) = f x ^ n) : comm_group M‚ÇÅ
{Œ± : Type u_1} : has_emptyc (cycle Œ±)
{Œ± : Type u_2} [decidable_eq Œ±] [has_add Œ±] : has_add (finset Œ±)
{m : Type u_2} {n : Type u_3} {Œ± : Type u_12} (M : matrix m n Œ±) (p : m ‚Üí Prop) (q : n ‚Üí Prop) : matrix {a // p a} {a // q a} Œ±
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] (K : nnreal) (f : Œ± ‚Üí Œ≤) : Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚ÜíL[ùïú] F) (x : E) : formal_multilinear_series ùïú E F
{B : Type u} [quiver B] (a b : B) : category_theory.discrete (quiver.path a b) ‚•§ category_theory.free_bicategory.hom a b
{M‚ÇÇ : Type u_2} {M‚ÇÅ : Type u_1} [has_neg M‚ÇÅ] [has_involutive_neg M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (inv : ‚àÄ (x : M‚ÇÅ), f (-x) = -f x) : has_involutive_neg M‚ÇÅ
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.enough_projectives C] (Z : C) : chain_complex C ‚Ñï
(k : ‚Ñï) : (Œ£ (n : ‚Ñï), ‚Ü•(finset.nat.antidiagonal_tuple k n)) ‚âÉ (fin k ‚Üí ‚Ñï)
 : Top ‚•§ sSet
{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop
 : (‚Ü•algebraic_geometry.AffineScheme)·µí·µñ ‚•§ CommRing
(a b : Prop) : Prop
 : lean.parser tactic.rcases_patt
{X Y : Profinite} (f : X ‚ü∂ Y) (bij : function.bijective ‚áëf) : category_theory.is_iso f
 : native.float ‚Üí ‚Ñ§
(renames : interactive.parse rename_args_parser) : tactic unit
(n : ‚Ñï) (h : 0 < n . "exact_dec_trivial") : ‚Ñï+
{B : Type u} [quiver B] {a b : B} : category_theory.free_bicategory.hom a b ‚Üí category_theory.free_bicategory.hom a b ‚Üí Type (max u v)
 : ennreal ‚Üí ereal
{Œ± : Type u_1} (gs : list (bool √ó Œ±)) : tactic.new_goals ‚Üí list Œ±
{Œ± : Type u_1} [topological_space Œ±] {Œ≤ : Type u_2} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{Œπ : Type u_5} [fintype Œπ] {Xi : Œπ ‚Üí Type u_6} {Yi : Œπ ‚Üí Type u_7} [Œ† (i : Œπ), topological_space (Xi i)] [Œ† (i : Œπ), topological_space (Yi i)] (ei : Œ† (i : Œπ), local_homeomorph (Xi i) (Yi i)) : local_homeomorph (Œ† (i : Œπ), Xi i) (Œ† (i : Œπ), Yi i)
{Œ± : Type u_1} (s : multiset Œ±) : list Œ±
{Œ± : Type u_1} [preorder Œ±] [order_top Œ±] : ‚Ü•(set.Iic ‚ä§) ‚âÉo Œ±
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b c : Œ±} : a ‚â§ c - b ‚Üí a + b ‚â§ c
 : bool ‚Üí bool ‚Üí snum ‚Üí snum
{ùïú : Type u_2} {E : Type u_5} [comm_semiring ùïú] [topological_space ùïú] [has_continuous_add ùïú] [has_continuous_const_smul ùïú ùïú] [add_comm_monoid E] [module ùïú E] [topological_space E] : has_coe_to_fun (weak_dual ùïú E) (Œª (_x : weak_dual ùïú E), E ‚Üí ùïú)
{p : ‚Ñï} (hp : 1 < p) : padic_val_int p ‚Üëp = 1
{M : Type u_1} [comm_monoid M] (x : M) (N' : Type u_2) [comm_monoid N'] : Type (max u_1 u_2)
 : lean.parser tactic.rcases_args
(Œ± : Type u) [uniform_space Œ±] : Prop
 : category_theory.category algebraic_geometry.LocallyRingedSpace
(n : ‚Ñ§) : ‚áëzmod.œá‚Çà' ‚Üën = ite (n % 2 = 0) 0 (ite (n % 8 = 1 ‚à® n % 8 = 3) 1 (-1))
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) {J : Type u} [category_theory.category J] (K : J ‚•§ C) : ùü≠ (category_theory.limits.cocone K) ‚ü∂ category_theory.limits.cocones.functoriality K F ‚ãô adj.functoriality_right_adjoint K
{Œπ : Type u_3} {œá : Œπ ‚Üí Type u_4} [Œ† (i : Œπ), topological_space (œá i)] {as bs : Œ† (i : Œπ), œá i} (Œ≥ : Œ† (i : Œπ), path (as i) (bs i)) : path as bs
{X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) {a b : ‚Ñù} (hle : a ‚â§ b) : ‚àÉ (f : bounded_continuous_function X ‚Ñù), set.eq_on ‚áëf (function.const X a) s ‚àß set.eq_on ‚áëf (function.const X b) t ‚àß ‚àÄ (x : X), ‚áëf x ‚àà set.Icc a b
 : native.float ‚Üí native.float ‚Üí native.float
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {a b : Œ±} (h : a ‚â† b) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà {a, b}), f i)) = f a + f b
{Œ± : Type u_1} {Œπ : Type u_2} {Œ≤ : Type u_3} {S : Œπ ‚Üí set Œ±} {f : Œ† (i : Œπ), ‚Ü•(S i) ‚Üí Œ≤} {hf : ‚àÄ (i j : Œπ) (x : Œ±) (hxi : x ‚àà S i) (hxj : x ‚àà S j), f i ‚ü®x, hxi‚ü© = f j ‚ü®x, hxj‚ü©} {T : set Œ±} (hT' : T = set.Union S) (dir : directed has_le.le S) (op : ‚Ü•T ‚Üí ‚Ü•T ‚Üí ‚Ü•T) (opi : Œ† (i : Œπ), ‚Ü•(S i) ‚Üí ‚Ü•(S i) ‚Üí ‚Ü•(S i)) (hopi : ‚àÄ (i : Œπ) (x y : ‚Ü•(S i)), set.inclusion _ (opi i x y) = op (set.inclusion _ x) (set.inclusion _ y)) (opŒ≤ : Œ≤ ‚Üí Œ≤ ‚Üí Œ≤) (h : ‚àÄ (i : Œπ) (x y : ‚Ü•(S i)), f i (opi i x y) = opŒ≤ (f i x) (f i y)) (x y : ‚Ü•T) : set.Union_lift S f hf T _ (op x y) = opŒ≤ (set.Union_lift S f hf T _ x) (set.Union_lift S f hf T _ y)
(G : Type u_1) [monoid G] : ¬¨monoid.is_torsion_free G ‚Üî ‚àÉ (g : G), g ‚â† 1 ‚àß is_of_fin_order g
{Œ± : Type u} [topological_space Œ±] (s : set Œ±) : frontier s·∂ú = frontier s
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] (f : M ‚Üí‚Çó[R] M) : ‚Ñï ‚Üío submodule R M
(Œ± : Type u_1) [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] : compact_Icc_space Œ±
{ùïú : Type u_3} {E : Type u_4} [semi_normed_ring ùïú] [add_monoid E] [has_scalar ùïú E] : has_coe_to_fun (seminorm ùïú E) (Œª (_x : seminorm ùïú E), E ‚Üí ‚Ñù)
{G : Type u} [add_group G] : G ‚ß∏ ‚ä• ‚âÉ+ G
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommMon) : Mon
(n : ‚Ñï) (n_big : 4 ‚â§ n) : 4 ^ n < n * n.central_binom
 : has_add nonote
{M : Type u_1} [has_mul M] (r : M ‚Üí M ‚Üí Prop) : con M
(n : ‚Ñï) (A : Type u_1) (v : typevec n) : Type u_1
{Œ± : Type u_1} {Œ≤ : Type u_2} {f g : Œ± ‚Üí. Œ≤} (H1 : ‚àÄ (a : Œ±), a ‚àà f.dom ‚Üî a ‚àà g.dom) (H2 : ‚àÄ (a : Œ±) (p : f.dom a) (q : g.dom a), f.fn a p = g.fn a q) : f = g
(R : Type u_1) [comm_ring R] {C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] [category_theory.preadditive D] [category_theory.linear R D] (F : C ‚•§ D) (L : category_theory.Free R C ‚•§ D) [L.additive] [category_theory.functor.linear R L] (Œ± : category_theory.Free.embedding R C ‚ãô L ‚âÖ F) : L ‚âÖ category_theory.Free.lift R F
(R : Type u) (S : Type v) (A : Type w) [comm_semiring R] [comm_semiring S] [semiring A] [algebra R S] [algebra S A] [algebra R A] [is_scalar_tower R S A] (r : R) [invertible (‚áë(algebra_map R S) r)] : invertible (‚áë(algebra_map R A) r)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_3} (s : finset Œπ) (f : Œπ ‚Üí E) (x : E) : has_inner.inner x (s.sum (Œª (i : Œπ), f i)) = s.sum (Œª (i : Œπ), has_inner.inner x (f i))
{m : Type u_2} {n : Type u_3} {Œ± : Type v} [non_unital_non_assoc_semiring Œ±] [fintype n] (M : matrix m n Œ±) (v : n ‚Üí Œ±) : m ‚Üí Œ±
{Œ± : Type u} [ordered_add_comm_monoid Œ±] (zero_le : ‚àÄ (a : Œ±), 0 ‚â§ a) : ordered_add_comm_monoid (with_zero Œ±)
{P : Type u ‚Üí Prop} (of_equiv : ‚àÄ {Œ± Œ≤ : Type u}, Œ± ‚âÉ Œ≤ ‚Üí P Œ± ‚Üí P Œ≤) (h_empty : P pempty) (h_option : ‚àÄ {Œ± : Type u} [_inst_1 : fintype Œ±], P Œ± ‚Üí P (option Œ±)) (Œ± : Type u) [fintype Œ±] : P Œ±
(Œ± : Type u) : Type u
 : Type
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] {R : Type u_1} [non_assoc_semiring R] {f : Œ† (k : ‚Ñï), R ‚Üí+* zmod (p ^ k)} (f_compat : ‚àÄ (k1 k2 : ‚Ñï) (hk : k1 ‚â§ k2), (zmod.cast_hom _ (zmod (p ^ k1))).comp (f k2) = f k1) : R ‚Üí+* ‚Ñ§_[p]
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] [complete_space F] (p : formal_multilinear_series ùïú E F) (h : 0 < p.radius) : has_fpower_series_on_ball p.sum p 0 p.radius
(n : ‚Ñ§) : ‚Ñö
{B : Type u} [quiver B] {a b c : B} (f : quiver.path a b) (g : quiver.path b c) : (category_theory.free_bicategory.preinclusion B).map ({as := f} ‚â´ {as := g}) ‚âÖ (category_theory.free_bicategory.preinclusion B).map {as := f} ‚â´ (category_theory.free_bicategory.preinclusion B).map {as := g}
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] [category_theory.limits.has_zero_object C] {X Y : C} (f : X ‚ü∂ Y) (hf : ‚àÄ (Z : C) (g : Z ‚ü∂ X), g ‚â´ f = 0 ‚Üí g = 0) : category_theory.mono f
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C·µí·µñ ‚•§ D·µí·µñ} (Œ± : F ‚âÖ G) : G.unop ‚âÖ F.unop
(e : environment) (nm : name) : ‚Ñï ‚Üí tactic name
{Œ± : Type u_1} [comm_semiring Œ±] (E : linear_recurrence Œ±) (init : fin E.order ‚Üí Œ±) : E.is_solution (E.mk_sol init)
{B : Type u‚ÇÅ} [quiver B] {C : Type u‚ÇÇ} [category_theory.bicategory C] (F : prefunctor B C) : category_theory.pseudofunctor (category_theory.free_bicategory B) C
 : Type (u+1)
{Œπ : Type u} {Œ± : Type v} [fintype Œπ] {t : Œπ ‚Üí finset Œ±} [decidable_eq Œ±] {n : ‚Ñï} (hn : fintype.card Œπ = n + 1) (ht : ‚àÄ (s : finset Œπ), s.card ‚â§ (s.bUnion t).card) (ih : ‚àÄ {Œπ' : Type u} [_inst_3 : fintype Œπ'] (t' : Œπ' ‚Üí finset Œ±), fintype.card Œπ' ‚â§ n ‚Üí (‚àÄ (s' : finset Œπ'), s'.card ‚â§ (s'.bUnion t').card) ‚Üí (‚àÉ (f : Œπ' ‚Üí Œ±), function.injective f ‚àß ‚àÄ (x : Œπ'), f x ‚àà t' x)) (ha : ‚àÄ (s : finset Œπ), s.nonempty ‚Üí s ‚â† finset.univ ‚Üí s.card < (s.bUnion t).card) : ‚àÉ (f : Œπ ‚Üí Œ±), function.injective f ‚àß ‚àÄ (x : Œπ), f x ‚àà t x
(num_leading_pis num_generalized num_index_vars : ‚Ñï) (ih : expr) : tactic expr
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {x : E} {n : ‚Ñï} : cont_diff_within_at ùïú ‚Üë(n + 1) f s x ‚Üî ‚àÉ (u : set E) (H : u ‚àà nhds_within x (has_insert.insert x s)) (f' : E ‚Üí (E ‚ÜíL[ùïú] F)), (‚àÄ (x : E), x ‚àà u ‚Üí has_fderiv_within_at f (f' x) u x) ‚àß cont_diff_within_at ùïú ‚Üën f' u x
 : cardinal
(F : Type u_8) (Œ± : out_param (Type u_9)) (Œ≤ : out_param (Type u_10)) [complete_lattice Œ±] [complete_lattice Œ≤] : Type (max u_10 u_8 u_9)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_initial X) (f : Y ‚ü∂ X) : category_theory.epi f
{Œπ : Type w} {R : Type u} [ring R] [nontrivial R] {M : Type v} [add_comm_group M] [module R M] {v : Œπ ‚Üí M} (i : linear_independent R v) : i.maximal ‚Üî ‚àÄ (Œ∫ : Type v) (w : Œ∫ ‚Üí M), linear_independent R w ‚Üí ‚àÄ (j : Œπ ‚Üí Œ∫), w ‚àò j = v ‚Üí function.surjective j
(M : Type u) [add_comm_monoid M] : AddCommMon
{Œ± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Œ± ‚Üí E} {g' : Œ± ‚Üí F'} {l : filter Œ±} : (f =O[l] Œª (x : Œ±), -g' x) ‚Üí f =O[l] g'
{R : Type u} [ring R] {M N : Module R} (f : M ‚ü∂ N) : category_theory.limits.is_limit (Module.kernel_cone f)
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (s : submonoid M) (t : submonoid N) : submonoid (M √ó N)
(eq : expr) (cfg : tactic.equiv_rw_cfg) : tactic unit
{Œ± : Type u_1} [preorder Œ±] [nonempty Œ±] [no_max_order Œ±] : infinite Œ±
 : list name
 : cc_state ‚Üí expr ‚Üí expr
(P L : Type u) [has_mem P L] : Type u
{Œ± : Type u_2} {m : Type u_4} {n : Type u_5} {R : Type u_8} [topological_space R] [topological_space Œ±] {f : Œ± ‚Üí matrix m n R} (h : ‚àÄ (i : m) (j : n), continuous (Œª (a : Œ±), f a i j)) : continuous f
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X Y : C) : category_theory.monoidal_category.tensor_right (X ‚äó Y) ‚âÖ category_theory.monoidal_category.tensor_right X ‚ãô category_theory.monoidal_category.tensor_right Y
{Œ± : Type u} [non_unital_non_assoc_ring Œ±] (a b c : Œ±) : a * (b - c) = a * b - a * c
{Œ± : Type u} [monoid Œ±] (a : Œ±) [invertible a] : Œ±À£
(ùïú : Type u_1) (E : Type u_2) [comm_semiring ùïú] [topological_space ùïú] [has_continuous_add ùïú] [add_comm_monoid E] [module ùïú E] [topological_space E] [has_continuous_const_smul ùïú ùïú] : (E ‚ÜíL[ùïú] ùïú) ‚Üí‚Çó[ùïú] E ‚Üí‚Çó[ùïú] ùïú
(lcs : list expr) : name_set
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] {a b : Œ±} : ¬¨a < b ‚Üí multiset.Ioc a b = 0
 : Type
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u} [category_theory.category C] {F : J ‚•§ C} [category_theory.limits.has_limit F] {G : K ‚•§ C} [category_theory.limits.has_limit G] (e : J ‚âå K) (w : e.functor ‚ãô G ‚âÖ F) : category_theory.limits.limit F ‚âÖ category_theory.limits.limit G
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {D : Type u‚ÇÇ} [category_theory.category D] (F : D ‚•§ C) {X : D} {T : category_theory.presieve X} (x : category_theory.presieve.family_of_elements (F.op ‚ãô P) T) : category_theory.presieve.family_of_elements P (category_theory.presieve.functor_pushforward F T)
{Œπ : Type u} (s : finset Œπ) (f : Œπ ‚Üí nnreal) {p : ‚Ñù} (hp : 1 ‚â§ p) : s.sum (Œª (i : Œπ), f i) ^ p ‚â§ ‚Üë(s.card) ^ (p - 1) * s.sum (Œª (i : Œπ), f i ^ p)
(a b : ‚Ñï+) : pnat.xgcd_type
(Œì : Type u) (Œì' : Type v) [inhabited Œì] [inhabited Œì'] : Type (max u v)
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {D : Type u‚ÇÇ} [category_theory.category D] {Y : D} (F : category_theory.mono_over X ‚•§ category_theory.mono_over Y) : category_theory.subobject X ‚•§ category_theory.subobject Y
{Œ± : Type u_1} [pseudo_metric_space Œ±] (C : ‚Ñù) {f : ‚Ñï ‚Üí Œ±} (hu‚ÇÇ : ‚àÄ (n : ‚Ñï), has_dist.dist (f n) (f (n + 1)) ‚â§ C / 2 / 2 ^ n) {a : Œ±} (ha : filter.tendsto f filter.at_top (nhds a)) (n : ‚Ñï) : has_dist.dist (f n) a ‚â§ C / 2 ^ n
{Œ≤ : Type u_1} [conditionally_complete_lattice Œ≤] {s : set (with_top Œ≤)} (hs : s.nonempty) : is_lub s (has_Sup.Sup s)
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] (s : wseq Œ±) : computation ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {g : Œ≤ ‚Üí Œ±} (hg : function.injective g) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà set.range g), f i)) = finsum (Œª (j : Œ≤), f (g j))
{X : Type u_1} [topological_space X] [t1_space X] : t1_space (alexandroff X)
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (h : strict_mono f) : Œ± ‚Ü™o Œ≤
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] (F : J ‚•§ C) : category_theory.limits.cocone F ‚•§ C
{Œ± : Type u_2} [subtraction_comm_monoid Œ±] : subtraction_comm_monoid (set Œ±)
(u : tactic.rewrite_search.proof_unit) (rs : list (expr √ó bool)) : list (expr √ó bool)
{M : Type u_1} [monoid M] : is_submonoid set.univ
 : Type (u+1)
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] (f‚ÇÄ f‚ÇÅ : C(X, Y)) (S : set X) : Prop
{p : ‚Ñï+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ‚Üë‚Üëp] {k : ‚Ñï} [hpri : fact (nat.prime ‚Üëp)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ‚Üë(p ^ (k + 1)) K)) {s : ‚Ñï} (hs : s ‚â§ k) (htwo : p ^ (k - s + 1) ‚â† 2) : ‚áë(algebra.norm K) (is_cyclotomic_extension.zeta (p ^ (k + 1)) K L ^ ‚Üëp ^ s - 1) = ‚Üëp ^ ‚Üëp ^ s
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] [category_theory.limits.has_limits_of_shape J C] (F : J ‚•§ K ‚•§ C) : category_theory.limits.limit F ‚âÖ F.flip ‚ãô category_theory.limits.lim
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] (s : set Œ±) (hs : measurable_set s) (f g : measure_theory.simple_func Œ± Œ≤) : measure_theory.simple_func Œ± Œ≤
(Œ≥ : Type u) : W_type (W_type.list_Œ≤ Œ≥) ‚Üí list Œ≥
{q : ‚Ñö} {n : ‚Ñï} {ifp_n ifp_succ_n : generalized_continued_fraction.int_fract_pair ‚Ñö} (stream_nth_eq : generalized_continued_fraction.int_fract_pair.stream q n = option.some ifp_n) (stream_succ_nth_eq : generalized_continued_fraction.int_fract_pair.stream q (n + 1) = option.some ifp_succ_n) : ifp_succ_n.fr.num < ifp_n.fr.num
{Œ± : Type u_2} : bornology Œ±
{Œ± : Type u_1} [division_comm_monoid Œ±] : Œ± ‚Üí* Œ±
(R : Type u1) [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] {A : Type u_1} [semiring A] [algebra R A] : {f // ‚àÄ (m : M), ‚áëf m * ‚áëf m = 0} ‚âÉ (exterior_algebra R M ‚Üí‚Çê[R] A)
{K : Type u_1} [field K] (hk : ‚àÄ (x : K), 1 + x ^ 2 ‚â† 0) : K ‚âÉ {p // p.fst ^ 2 + p.snd ^ 2 = 1 ‚àß p.snd ‚â† -1}
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Z‚ÇÅ Z‚ÇÇ : C} (g‚ÇÅ : Z‚ÇÅ ‚ü∂ X‚ÇÅ) (g‚ÇÇ : Z‚ÇÅ ‚ü∂ X‚ÇÇ) (g‚ÇÉ : Z‚ÇÇ ‚ü∂ X‚ÇÇ) (g‚ÇÑ : Z‚ÇÇ ‚ü∂ X‚ÇÉ) [category_theory.limits.has_pushout g‚ÇÅ g‚ÇÇ] [category_theory.limits.has_pushout g‚ÇÉ g‚ÇÑ] [category_theory.limits.has_pushout g‚ÇÅ (g‚ÇÇ ‚â´ category_theory.limits.pushout.inl)] : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (category_theory.limits.pushout.desc category_theory.limits.pushout.inl (category_theory.limits.pushout.inl ‚â´ category_theory.limits.pushout.inr) _) category_theory.limits.pushout.inr _)
(nm : name) : tactic bool
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] {i j : Œπ} (w : free_product.neword M i j) : M i
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : Top} (f : X ‚ü∂ Y) (F : Top.presheaf C Y) (U : topological_space.opens ‚Ü•X) (x : ‚Ü•U) : (Top.presheaf.pullback_obj f F).obj (opposite.op U) ‚ü∂ F.stalk (‚áëf ‚Üëx)
(v : ‚Ñï ‚Üí ‚Ñ§) (as : list ‚Ñ§) (l : ‚Ñï) : ‚Ñï ‚Üí ‚Ñ§
{Œ± : Type u} {h h' : has_le Œ±} (c : bounded_order Œ±) (top : Œ±) (eq_top : top = bounded_order.top) (bot : Œ±) (eq_bot : bot = bounded_order.bot) (le_eq : ‚àÄ (x y : Œ±), x ‚â§ y ‚Üî x ‚â§ y) : bounded_order Œ±
(u : pnat.xgcd_type) : pnat.xgcd_type
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.well_powered C] {A : C} (s : set (category_theory.subobject A)) (f : category_theory.subobject A) (k : ‚àÄ (g : category_theory.subobject A), g ‚àà s ‚Üí f ‚â§ g) : category_theory.limits.cone (category_theory.subobject.wide_cospan s)
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) {f : N ‚Üí+ G} (hf : function.surjective ‚áëf) : add_subgroup.comap f H.normalizer = (add_subgroup.comap f H).normalizer
{Œ± : Type u} (Œ≤ : Type v) [group Œ±] [monoid Œ≤] [mul_action Œ≤ Œ±] (H : subgroup Œ±) : Prop
{Œ± : Type u_1} (x : Œ±) : thunk Œ±
{Œ± : Type u_1} {a b c : Œ±} [linear_order Œ±] [add_comm_semigroup Œ±] [has_sub Œ±] [has_ordered_sub Œ±] : a < b - c ‚Üî c + a < b
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} (a : Œ±) : Œ± ‚äï Œ≤ ‚äï Œ≥
{E : Type u} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {a : E} {s : set E} (h : is_local_max_on f s a) {y : E} (hy : y ‚àà pos_tangent_cone_at s a) : ‚áë(fderiv_within ‚Ñù f s a) y ‚â§ 0
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S T : set E) : ‚Üë(intermediate_field.adjoin ‚Ü•(intermediate_field.adjoin F S) T) = ‚Üë(intermediate_field.adjoin ‚Ü•(intermediate_field.adjoin F T) S)
{F : Type u ‚Üí Type u} [functor F] [q : qpf F] : setoid (qpf.P F).W
{Œ± : Type u_1} {Œπ : Sort u_4} [complete_lattice Œ±] (f : Œπ ‚Üí Œ±) : (‚®Ü (i : {i // f i ‚â† ‚ä•}), f ‚Üëi) = ‚®Ü (i : Œπ), f i
(e : expr) : tactic (expr √ó expr)
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {E : Type u_4} {F : Type u_6} [normed_group E] [normed_group F] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} [ring_hom_isometric œÉ‚ÇÅ‚ÇÇ] : normed_group (E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F)
(Œ± : Type u_1) : pempty √ó Œ± ‚âÉ pempty
{Œ± : Type u_1} {M : Type u_5} [has_zero M] (a : Œ±) (b : M) : Œ± ‚Üí‚ÇÄ M
{Œ± : Type u_1} : complete_lattice (setoid Œ±)
(sub : name) : name ‚Üí name
{L R : Type v} (fst snd : L ‚Üí R) : Type v
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) [category_theory.limits.has_colimit F] : C
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] [complete_space E] {f : ‚Ñù ‚Üí E} {T : ‚Ñù} (hf : function.periodic f T) (t s : ‚Ñù) (h_int : ‚àÄ (t‚ÇÅ t‚ÇÇ : ‚Ñù), interval_integrable f measure_theory.measure_space.volume t‚ÇÅ t‚ÇÇ) : ‚à´ (x : ‚Ñù) in t..s + T, f x = (‚à´ (x : ‚Ñù) in t..s, f x) + ‚à´ (x : ‚Ñù) in t..t + T, f x
(n : name) (cl f Œ± Œ≤ e : expr) : tactic expr
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] [has_neg Œ≤] (f : Œ± ‚Üí Œ≤) (c : Œ±) : Prop
(prop pr : expr) (tag : name) : expr
{Œπ : Type v} (Œ± : Œπ ‚Üí Top) : ‚àè Œ± ‚âÖ Top.of (Œ† (i : Œπ), ‚Ü•(Œ± i))
(n : ‚Ñï) : finset (Œ£ (a : fin n), fin n)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] {D : Type u‚ÇÅ} [category_theory.category D] [category_theory.preadditive D] [category_theory.limits.has_finite_biproducts D] (F : C ‚•§ D) [F.additive] : category_theory.Mat_.embedding C ‚ãô category_theory.Mat_.lift F ‚âÖ F
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : Y ‚ü∂ X) : category_theory.presieve X
{Œ± : Type u} [partial_order Œ±] : has_le.le ‚Üír has_le.le
{R : Type u} [semiring R] {S : Type v} [semiring S] {f : R ‚Üí+* S} {p : polynomial S} (r : R) (hp : p ‚àà polynomial.lifts f) : ‚áëpolynomial.C (‚áëf r) * p ‚àà polynomial.lifts f
{C : Type u‚ÇÅ} [category_theory.small_category C] {D : Type u‚ÇÅ} [category_theory.small_category D] (F : C ‚•§ D) : F ‚ãô category_theory.yoneda ‚âÖ category_theory.yoneda ‚ãô category_theory.Lan F.op
{Œ± : Type u_1} : lists Œ± ‚Üí lists' Œ± bool.tt ‚Üí lists' Œ± bool.tt
{Œ± : Type u_1} {s : set Œ±} : set.range subtype.val = s
{Œπ : Type v} : category_theory.pairwise Œπ ‚Üí category_theory.pairwise Œπ ‚Üí Type v
 : ‚ÑÇ
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) : add_submonoid (Œ† (j : J), ‚Ü•(F.obj j))
{T : Type u‚ÇÅ} [category_theory.category T] {X Y : T} : has_coe (Y ‚ü∂ X) (category_theory.over X)
{m : Type ‚Üí Type} [monad m] (P : name ‚Üí m bool) (s : name_set) : m name_set
{A : Type u_1} [normed_ring A] [normed_algebra ‚ÑÇ A] [complete_space A] [nontrivial A] (a : A) : (spectrum ‚ÑÇ a).nonempty
{R : Type u_1} {M : Type u_7} [semiring R] [add_comm_monoid M] [module R M] : (M ‚âÉ‚Çó[R] M) ‚Üí* M ‚Üí‚Çó[R] M
(G : Type u) [group G] (R : Type v) [semiring R] [mul_semiring_action G R] (x : G) : R ‚âÉ+* R
{Œ± : Type u_1} : list (dlist Œ±) ‚Üí dlist Œ±
(decide_eq : expr ‚Üí expr ‚Üí tactic (bool √ó expr)) : expr ‚Üí tactic (list expr √ó expr √ó expr)
 : Type
{Œ± : Type u} : Œ± ‚âÉ multiplicative Œ±
 : ‚Ü•{a : ennreal | a < ‚ä§} ‚âÉ‚Çú nnreal
{x y : pgame} : x.left_moves √ó y.left_moves ‚äï x.right_moves √ó y.right_moves ‚âÉ (x * y).left_moves
{Œ± : Type u_1} {Œ≤ : Type u_2} {e : local_equiv Œ± Œ≤} {s : set Œ±} {t : set Œ≤} : e.is_image s t ‚Üí e.target ‚à© ‚áë(e.symm) ‚Åª¬π' s = e.target ‚à© t
{R : Type u_1} [semiring R] (n : ‚Ñï) (a : R) [decidable (a = 0)] : (‚áë(power_series.monomial R n) a).order = ite (a = 0) ‚ä§ ‚Üën
(R : Type u) [semiring R] : Prop
 : bool ‚Üí expr ‚Üí expr ‚Üí expr √ó expr ‚Üí tactic.norm_fin.eval_fin_m (expr √ó expr)
{Œ± : Type u} {Œ≤ : Type v} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {n : ‚Ñï} (ht : t.nonempty) (hn : s.card ‚â§ t.card * n) : ‚àÉ (y : Œ≤) (H : y ‚àà t), (finset.filter (Œª (x : Œ±), f x = y) s).card ‚â§ n
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} : a < b ‚Üí b ‚â§ c ‚Üí a < c
{M : Type u_5} {N : Type u_6} [add_zero_class M] [add_zero_class N] {M' : Type u_8} {N' : Type u_9} [add_zero_class M'] [add_zero_class N'] (f : M ‚Üí+ M') (g : N ‚Üí+ N') : M √ó N ‚Üí+ M' √ó N'
{Œ± : Type u_1} {Œ≤ : Type u_2} [encodable Œ±] (f : Œ≤ ‚Üí Œ±) (finv : Œ± ‚Üí Œ≤) (linv : ‚àÄ (b : Œ≤), finv (f b) = b) : encodable Œ≤
{t : set Gromov_Hausdorff.GH_space} {C : ‚Ñù} {u : ‚Ñï ‚Üí ‚Ñù} {K : ‚Ñï ‚Üí ‚Ñï} (ulim : filter.tendsto u filter.at_top (nhds 0)) (hdiam : ‚àÄ (p : Gromov_Hausdorff.GH_space), p ‚àà t ‚Üí metric.diam set.univ ‚â§ C) (hcov : ‚àÄ (p : Gromov_Hausdorff.GH_space), p ‚àà t ‚Üí ‚àÄ (n : ‚Ñï), ‚àÉ (s : set p.rep), cardinal.mk ‚Ü•s ‚â§ ‚Üë(K n) ‚àß set.univ ‚äÜ ‚ãÉ (x : p.rep) (H : x ‚àà s), metric.ball x (u n)) : totally_bounded t
{Œ± : Type u_1} {m : measurable_space Œ±} (ŒΩ : measure_theory.measure Œ±) [measure_theory.sigma_finite ŒΩ] {s : set Œ±} (hs : measurable_set s) : (ŒΩ.restrict s).rn_deriv ŒΩ =·µê[ŒΩ] s.indicator 1
(n : ‚Ñï) : ‚Ñï+
{Œì : Type u_1} {R : Type u_2} [partial_order Œì] [semiring R] (g : Œì) : hahn_series Œì R ‚Üí‚Çó[R] R
{Œπ : Type u_1} {M : Type u_3} [has_zero M] (f : Œπ ‚Üí‚ÇÄ M) : Œ†‚ÇÄ (i : Œπ), M
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.limits.has_colimits_of_size D] [category_theory.creates_colimits_of_size F] : category_theory.limits.has_colimits_of_size C
(Œ± : Type u_1) [lattice Œ±] : Lattice
 : Type
(c : linarith.pcomp) (elimed_ge : ‚Ñï) : bool
{Œ± : Type u_1} [semilattice_sup Œ±] [order_bot Œ±] (s : multiset Œ±) : Œ±
{E : Type u_2} [semi_normed_group E] [normed_space ‚Ñù E] {s t : set E} {x y : E} (hx : x ‚àà ‚áë(convex_hull ‚Ñù) s) (hy : y ‚àà ‚áë(convex_hull ‚Ñù) t) : ‚àÉ (x' : E) (H : x' ‚àà s) (y' : E) (H : y' ‚àà t), has_dist.dist x y ‚â§ has_dist.dist x' y'
{C : Type u‚ÇÅ} [category_theory.category C] {G : category_theory.comonad C} : category_theory.category_struct G.coalgebra
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [has_one M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñï] [has_inv M‚ÇÅ] [has_div M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñ§] [division_comm_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (inv : ‚àÄ (x : M‚ÇÅ), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : M‚ÇÅ), f (x / y) = f x / f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (x ^ n) = f x ^ n) : division_comm_monoid M‚ÇÅ
{R : Type x} {S : Type u_1} [distrib R] [has_add S] [has_mul S] (f : R ‚Üí S) (hf : function.surjective f) (add : ‚àÄ (x y : R), f (x + y) = f x + f y) (mul : ‚àÄ (x y : R), f (x * y) = f x * f y) : distrib S
(e : expr) : tactic (expr √ó expr)
{Œ± : Type u_1} [linear_ordered_field Œ±] [archimedean Œ±] {x y : Œ±} (hx : 0 < x) (hy : y < 1) : ‚àÉ (n : ‚Ñï), y ^ n < x
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : Type w) [category_theory.category J] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ w w')
(C : Type u) [category_theory.category C] : Prop
 : tactic unit
{Œ± : Type u} [preorder Œ±] {s t : set Œ±} (h : bdd_below s) : bdd_below (s ‚à© t)
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : lie_submodule R L M
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} {u v : E} (hu : u ‚àà K) (hv : v ‚àà K·óÆ) : has_inner.inner u v = 0
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) {Z : C} (g : Y ‚ü∂ Z) [category_theory.limits.has_equalizers C] [category_theory.limits.has_image f] [category_theory.is_iso g] : category_theory.limits.image f ‚âÖ category_theory.limits.image (f ‚â´ g)
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : algebraic_geometry.SheafedSpace C ‚•§ Top
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x : V) {r : ‚Ñù} : 2 ‚Ä¢ o.oangle x (r ‚Ä¢ x) = 0
(s : name_set) (l : list name) : name_set
(p' : ‚Ñï) : 2 < lucas_lehmer.q (p' + 2)
{C : Type u‚ÇÅ} [category_theory.category C] (D : category_theory.glue_data C) [category_theory.limits.has_multicoequalizer D.diagram] (i j : D.J) : category_theory.limits.pullback_cone (D.Œπ i) (D.Œπ j)
{R : Type u} {S : Type v} {A' : Type u_1} [comm_semiring A'] [comm_semiring R] [comm_semiring S] [algebra S R] [algebra S A'] (f : R ‚Üí‚Çê[S] A') (x : A') : polynomial R ‚Üí‚Çê[S] A'
 : matrix (fin 8) (fin 8) ‚Ñ§
{Œ± : Type} (p : tactic.rewrite_search.dir_pair Œ±) : expr_lens.dir ‚Üí Œ±
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] {D : Type u‚ÇÅ} [category_theory.category D] {L : D ‚•§ C} {R : C ‚•§ D} (h : L ‚ä£ R) : category_theory.is_filtered D
{M : Type u_1} [semigroup M] {A : Type u_2} [set_like A M] [mul_mem_class A M] (S : A) : semigroup ‚Ü•S
(Œ± : Type u_1) (Œ≤ : Type u_2) [partial_order Œ±] [partial_order Œ≤] : partial_order (Œ± √ó‚Çó Œ≤)
{F : Type u_1} [field F] {K‚ÇÅ : Type u_3} {K‚ÇÇ : Type u_4} [field K‚ÇÅ] [field K‚ÇÇ] [algebra F K‚ÇÅ] [algebra F K‚ÇÇ] (œï : K‚ÇÅ ‚Üí‚Çê[F] K‚ÇÇ) (E : Type u_6) [field E] [algebra F E] [algebra K‚ÇÅ E] [algebra K‚ÇÇ E] [is_scalar_tower F K‚ÇÅ E] [is_scalar_tower F K‚ÇÇ E] [h : normal F E] : E ‚Üí‚Çê[F] E
{F : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [fun_like F Œ± (Œª (_x : Œ±), Œ≤)] [comm_monoid Œ±] [cancel_comm_monoid Œ≤] {A : set Œ±} {m n : ‚Ñï} [freiman_hom_class F A Œ≤ n] (h : m ‚â§ n) : freiman_hom_class F A Œ≤ m
{n : Type u_4} {Œ± : Type u_5} [fintype n] [semi_normed_ring Œ±] [decidable_eq n] : semi_normed_ring (matrix n n Œ±)
(L : first_order.language) (L' : first_order.language) : Type (max u_1 u_2 u_3 u_4)
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {f‚ÇÄ f‚ÇÅ : C(X, Y)} (F : f‚ÇÄ.homotopy f‚ÇÅ) : f‚ÇÅ.homotopy f‚ÇÄ
{n : ‚Ñï} : (fin n)·µí·µà ‚âÉo fin n
 : omega.int.preterm ‚Üí omega.term
{X : Type u_1} [topological_space X] [discrete_topology X] : order_bot (discrete_quotient X)
{Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ±] [topological_space Œ≤] (f : spectral_map Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : spectral_map Œ± Œ≤
{C : Type u} [category_theory.category C] : ùü≠ (category_theory.monad C) ‚âÖ category_theory.Monad.Monad_to_Mon C ‚ãô category_theory.Monad.Mon_to_Monad C
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] {f : Œ± ‚Üí Œ≤} [subsingleton Œ±] : isometry f
{F G H : Type u} [group F] [group G] [group H] [fintype F] [fintype H] (f : F ‚Üí* G) (g : G ‚Üí* H) (h : g.ker ‚â§ f.range) : fintype G
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C·µí·µñ ‚•§ D) [category_theory.limits.preserves_limit K.op F] : category_theory.limits.preserves_colimit K F.right_op
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) : Prop
{key data : Type} (m : native.rb_lmap key data) : list data
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±] (a : Œ±) [no_max_order Œ±] : closure (set.Ioi a) = set.Ici a
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : Type (max u v)
{Œπ : Type u_1} {M : Type u_3} [decidable_eq Œπ] [has_zero M] [Œ† (m : M), decidable (m ‚â† 0)] : (Œπ ‚Üí‚ÇÄ M) ‚âÉ Œ†‚ÇÄ (i : Œπ), M
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K‚ÇÅ K‚ÇÇ : J ‚•§ C} (F : C ‚•§ D) (h : K‚ÇÅ ‚âÖ K‚ÇÇ) [category_theory.limits.preserves_colimit K‚ÇÅ F] : category_theory.limits.preserves_colimit K‚ÇÇ F
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] (P : C·µí·µñ ‚•§ A) {X : C} (R : category_theory.presieve X) : nonempty (category_theory.limits.is_limit (P.map_cone (category_theory.sieve.generate R).arrows.cocone.op)) ‚Üî ‚àÄ (E : A·µí·µñ), category_theory.presieve.is_sheaf_for (P ‚ãô category_theory.coyoneda.obj E) R
{V : Type u_2} {P : Type u_3} [semi_normed_group V] [pseudo_metric_space P] [normed_add_torsor V P] (x : P) : V ‚âÉ·µ¢ P
(R : Type u_1) [comm_semiring R] (X : Type u_2) : has_coe X (free_algebra.pre R X)
(q : ‚Ñö) : ‚Ñö
 : omega.nat.preterm ‚Üí Prop
{n : ‚Ñï} (hpos : 0 < n) : irreducible (polynomial.cyclotomic n ‚Ñ§)
{d : ‚Ñ§} (h : 0 ‚â§ d) : ‚Ñ§‚àöd ‚Üí+* ‚Ñù
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} : mdifferentiable (model_with_corners_self ?? E) (model_with_corners_self ùïú E') f ‚Üî differentiable ùïú f
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] {X' Y' : C} (f' : X' ‚ü∂ Y') [category_theory.limits.has_kernel f'] (p : X ‚âÖ X') (q : Y ‚âÖ Y') (w : f ‚â´ q.hom = p.hom ‚â´ f') : category_theory.limits.kernel f ‚âÖ category_theory.limits.kernel f'
{Œ± : Type u} [decidable_eq Œ±] (L : list (Œ± √ó bool)) : list (Œ± √ó bool)
{M : Type u_1} [has_mul M] : has_mul (ultrafilter M)
(R : Type u) [comm_semiring R] (A : Type v) [semiring A] [algebra R A] (n : Type w) [decidable_eq n] [fintype n] : tensor_product R A (matrix n n R) ‚âÉ matrix n n A
(Œ± : Type u_1) (Œπ : Type u_2) [nonempty Œπ] : combinatorics.line Œ± Œπ
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] [normed_group G] [normed_space ùïú G] (q : formal_multilinear_series ùïú F G) (p : formal_multilinear_series ùïú E F) (r : nnreal) (hr : summable (Œª (i : Œ£ (n : ‚Ñï), composition n), ‚à•q.comp_along_composition p i.snd‚à•‚Çä * r ^ i.fst)) : ‚Üër ‚â§ (q.comp p).radius
{Œ± : Type u_1} {Œπ : Type u_4} [linear_order Œ±] [decidable_eq Œπ] (f : Œπ ‚Üí Œ±) {p : finset Œπ ‚Üí Prop} (s : finset Œπ) (h0 : p ‚àÖ) (step : ‚àÄ (a : Œπ) (s : finset Œπ), a ‚àâ s ‚Üí (‚àÄ (x : Œπ), x ‚àà s ‚Üí f x ‚â§ f a) ‚Üí p s ‚Üí p (has_insert.insert a s)) : p s
(K S : finset turing.partrec_to_TM2.Œõ') : Prop
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {s t : set Œ±} (hst : disjoint s t) (hs : (s ‚à© function.mul_support f).finite) (ht : (t ‚à© function.mul_support f).finite) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s ‚à™ t), f i)) = finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)) * finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà t), f i))
 : environment ‚Üí name ‚Üí bool
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [linear_ordered_add_comm_group Œ±] [archimedean Œ±] (h : function.periodic f c) (hc : 0 < c) (x : Œ±) : ‚àÉ (y : Œ±) (H : y ‚àà set.Ico 0 c), f x = f y
(ùïú : Type u_1) (V : Type u_2) [normed_field ùïú] [add_comm_group V] [module ùïú V] : Type u_2
{ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_3} [ordered_semiring ùïú] [add_comm_group E] [module ùïú E] {p : Œπ ‚Üí E} (hc : convex_independent ùïú p) (s : set Œπ) : convex_independent ùïú (Œª (i : ‚Ü•s), p ‚Üëi)
{R : Type u} [non_assoc_semiring R] {s t : subsemiring R} (h : s = t) : ‚Ü•s ‚âÉ+* ‚Ü•t
(Œ± : Type u_1) : list Œ± ‚âÉ dlist Œ±
{Œ± : Type u} : partial_order (topological_space Œ±)
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [has_zero N] (f : M ‚âÉ N) (hf : ‚áëf 0 = 0) (hf' : ‚áë(f.symm) 0 = 0) : (Œ± ‚Üí‚ÇÄ M) ‚âÉ (Œ± ‚Üí‚ÇÄ N)
(k : Type u‚ÇÅ) (G : Type u‚ÇÇ) [semiring k] [has_add G] : add_monoid_algebra k G ‚âÉ+* monoid_algebra k (multiplicative G)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (e : local_homeomorph Œ± Œ≤) (e' : local_homeomorph Œ≤ Œ≥) : local_homeomorph Œ± Œ≥
{R : Type u} [comm_ring R] {J : Type v} [category_theory.small_category J] (F : J ‚•§ Algebra R) : category_theory.limits.cone F
(G : Type u) : Type u
(R : Type u) [rack R] : rack.pre_envel_group R ‚Üí rack.pre_envel_group R ‚Üí Prop
{Œ± : Type u_1} [measurable_space Œ±] (a : Œ±) : measure_theory.measure Œ±
(R : Type u_4) [non_unital_comm_semiring R] : R ‚âÉ+* R·µê·µí·µñ
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] {s t : category_theory.limits.cotrident f} (k : s.X ‚ü∂ t.X) (w : s.œÄ ‚â´ k = t.œÄ) : s ‚ü∂ t
{ùïú : Type u_1} [linear_ordered_field ùïú] [topological_space ùïú] [order_topology ùïú] [archimedean ùïú] : dense_range coe
{R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} (h : same_ray R x y) (hy : y ‚â† 0) : ‚àÉ (r : R), 0 ‚â§ r ‚àß x = r ‚Ä¢ y
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (f : module.End K V) : fintype f.eigenvalues
(Œ± : Type u) (Œ≤ : Type v) [group Œ±] [mul_action Œ± Œ≤] : Œ± ‚Üí* equiv.perm Œ≤
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [comm_semigroup Œ≤] : comm_semigroup Œ±
(ùïú : Type u_1) (E : Type u_2) [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] : formal_multilinear_series ùïú E E
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} : metric.Hausdorff_dist (closure s) t = metric.Hausdorff_dist s t
{Œπ : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] [topological_space R] [nonempty Œπ] {B : Œπ ‚Üí submodule R M} (hB : submodules_basis B) (i : Œπ) : open_add_subgroup M
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) (X : C) [category_theory.limits.reflects_limit (category_theory.functor.empty C) G] (l : category_theory.limits.is_terminal (G.obj X)) : category_theory.limits.is_terminal X
{ùíú : Type u_1} [category_theory.category ùíú] {A B C : ùíú} (f : A ‚ü∂ B) (g : B ‚ü∂ C) [category_theory.limits.has_zero_morphisms ùíú] [category_theory.limits.has_kernels ùíú] [category_theory.limits.has_images ùíú] : Prop
 : enat ‚âÉ+ with_top ‚Ñï
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (p1 p2 : P) : has_dist.dist p1 (midpoint ‚Ñù p1 p2) = has_dist.dist p2 (midpoint ‚Ñù p1 p2)
(R : Type u_2) (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] : R ‚Üí+* add_monoid.End M
{Œì‚ÇÄ : Type u_3} [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] [nontrivial Œì‚ÇÄ] {K : Type u_1} [division_ring K] (v : valuation K Œì‚ÇÄ) {x : K} : ‚áëv x = 0 ‚Üî x = 0
 : conv unit
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] : add_hom M N ‚âÉ add_hom M·µê·µí·µñ N·µê·µí·µñ
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] : Type
 : ‚Ñï ‚Üí pos_num
{Œ± : Type u} {Œ≤ : Type v} : seq Œ± ‚Üí seq Œ≤ ‚Üí seq (Œ± √ó Œ≤)
{Œ± : Type u} {Œ≥ : Type w} {ùïú : Type u_2} [normed_field ùïú] [topological_space Œ±] [normed_ring Œ≥] [normed_algebra ùïú Œ≥] : ùïú ‚Üí+* bounded_continuous_function Œ± Œ≥
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (x : module.ray R M) : x ‚â† -x
 : expr ‚Üí expr
 : Type
(n : ‚Ñï) : finset ‚Ñï
(a : zmod 8) : ‚áëzmod.œá‚Çà' a = 0 ‚à® ‚áëzmod.œá‚Çà' a = 1 ‚à® ‚áëzmod.œá‚Çà' a = -1
(t : smt_tactic.interactive.itactic) : smt_tactic unit
{R : Type u} {M : Type v} {M‚ÇÇ : Type w} {M‚ÇÉ : Type y} (S : Type u_3) [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] [module S M‚ÇÇ] [module S M‚ÇÉ] [smul_comm_class R S M‚ÇÇ] [smul_comm_class R S M‚ÇÉ] : ((M ‚Üí‚Çó[R] M‚ÇÇ) √ó (M ‚Üí‚Çó[R] M‚ÇÉ)) ‚âÉ‚Çó[S] M ‚Üí‚Çó[R] M‚ÇÇ √ó M‚ÇÉ
 : first_order.language
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : add_con (M √ó ‚Ü•S)
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_5} {Œ¥ : Type u_7} (m : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (f : filter Œ±) (g : filter Œ≤) (h : filter Œ≥) : filter Œ¥
{J : Type v} [category_theory.small_category J] [category_theory.fin_category J] : category_theory.fin_category J·µí·µñ
{Œ± : Type u_2} {Œ≤ : Type u_3} [linear_ordered_field Œ±] [linear_ordered_field Œ≤] [archimedean Œ≤] : subsingleton (Œ± ‚âÉ+*o Œ≤)
{G : Type u_1} [right_cancel_semigroup G] (g : G) : G ‚Ü™ G
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Ü™o Œ≤) : Œ±·µí·µà ‚Ü™o Œ≤·µí·µà
 : Type v
{Œ± : Type u} (L : list Œ±) {i j : ‚Ñï} (h : j < (list.drop i L).length) : (list.drop i L).nth_le j h = L.nth_le (i + j) _
(c : linarith.comp) (n : ‚Ñï) : linarith.pcomp
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [has_one M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñï] [right_cancel_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) : right_cancel_monoid M‚ÇÅ
(k : Type u_1) [division_ring k] {Œπ : Type u_4} (s : finset Œπ) : Œπ ‚Üí k
{Œ± : Type u_1} [linear_order Œ±] (a : Œ±) : {a}.min' _ = a
{x : ‚Ñù} (n : ‚Ñï) (m : ‚Ñ§) (hxr : x ^ n = ‚Üëm) (hv : ¬¨‚àÉ (y : ‚Ñ§), x = ‚Üëy) (hnpos : 0 < n) : irrational x
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {P Q : C} (f : P ‚ü∂ Q) : C
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} (p : Œπ ‚Üí P) (i0 : Œπ) : vector_span k (set.range p) = submodule.span k (set.range (Œª (i : Œπ), p i0 -·µ• p i))
{X Y : Type u} (f : X ‚ü∂ Y) : category_theory.is_iso f ‚Üî function.bijective f
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} (r : L.relations 1) (t : L.term (Œ± ‚äï fin n)) : L.bounded_formula Œ± n
{C : Type u‚ÇÅ} [category_theory.category C] (T‚ÇÅ T‚ÇÇ : category_theory.monad C) : Type (max u‚ÇÅ v‚ÇÅ)
(M‚ÇÄ : Type u_4) : Type u_4
{X : Type u_1} {Y : Type u_2} [normed_group X] [normed_group Y] [normed_space ‚Ñù X] [normed_space ‚Ñù Y] {f : X ‚Üí Y} {x : X} : conformal_at f x ‚Üî is_conformal_map (fderiv ‚Ñù f x)
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), add_comm_monoid (A i)] [add_monoid Œπ] [direct_sum.gsemiring A] : semiring (direct_sum Œπ (Œª (i : Œπ), A i))
 : user_attribute unit (option name)
(f : ‚Ñù ‚Üí ‚Ñù) {a b : ‚Ñù} (hab : a < b) (g : ‚Ñù ‚Üí ‚Ñù) {lfa lga lfb lgb : ‚Ñù} (hdf : differentiable_on ‚Ñù f (set.Ioo a b)) (hdg : differentiable_on ‚Ñù g (set.Ioo a b)) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds lfa)) (hga : filter.tendsto g (nhds_within a (set.Ioi a)) (nhds lga)) (hfb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds lfb)) (hgb : filter.tendsto g (nhds_within b (set.Iio b)) (nhds lgb)) : ‚àÉ (c : ‚Ñù) (H : c ‚àà set.Ioo a b), (lgb - lga) * deriv f c = (lfb - lfa) * deriv g c
{ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_3} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] {p : Œπ ‚Üí E} : convex_independent ùïú p ‚Üî ‚àÄ (s : finset Œπ) (x : Œπ), p x ‚àà ‚áë(convex_hull ùïú) ‚Üë(finset.image p s) ‚Üí x ‚àà s
 : filter.tendsto coe filter.cofinite (filter.cocompact ‚Ñù)
{Œ∑ : Type u_5} {f : Œ∑ ‚Üí Type u_6} [Œ† (i : Œ∑), add_group (f i)] [decidable_eq Œ∑] [fintype Œ∑] {H : Œ† (i : Œ∑), add_subgroup (f i)} {J : add_subgroup (Œ† (i : Œ∑), f i)} : add_subgroup.pi set.univ H ‚â§ J ‚Üî ‚àÄ (i : Œ∑), add_subgroup.map (add_monoid_hom.single f i) (H i) ‚â§ J
{Œ± : Type u} [has_neg Œ±] [has_sup Œ±] : has_abs Œ±
{Œ± : Type u_1} [preorder Œ±] [order_top Œ±] (a : Œ±) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [compact_space Œ±] [t2_space Œ≤] {f : Œ± ‚âÉ Œ≤} (hf : continuous ‚áëf) : Œ± ‚âÉ‚Çú Œ≤
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_5} [normed_group E'] [normed_space ùïú E'] {n : with_top ‚Ñï} {f : E ‚Üí E'} : cont_diff ùïú n f ‚Üí cont_mdiff (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') n f
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {s : set ùïú} {n : with_top ‚Ñï} {m : ‚Ñï} (h : cont_diff_on ùïú n f s) (hmn : ‚Üëm ‚â§ n) (hs : unique_diff_on ùïú s) : continuous_on (iterated_deriv_within m f s) s
(Œ± : Type u_4) : Type u_4
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] : (Œ± ‚äï Œ≤) √ó Œ≥ ‚âÉ‚Çú Œ± √ó Œ≥ ‚äï Œ≤ √ó Œ≥
{Œ≥ : Type w} [emetric_space Œ≥] {s : set Œ≥} (hs : is_compact s) : ‚àÉ (t : set Œ≥) (H : t ‚äÜ s), t.countable ‚àß s = closure t
{M : Type u_1} [mul_one_class M] {S T : submonoid M} (h : ‚àÄ (x : M), x ‚àà S ‚Üî x ‚àà T) : S = T
{Œ± : Type u_1} (a : Œ±) : lists Œ±
{Œπ : Type v} {M : Type u_1} {S : Type u_2} [decidable_eq Œπ] [add_comm_monoid M] [set_like S M] [add_submonoid_class S M] (A : Œπ ‚Üí S) : Prop
{C : Type u} [category_theory.category C] (F : category_theory.limits.walking_cospan ‚•§ C) : F ‚âÖ category_theory.limits.cospan (F.map category_theory.limits.walking_cospan.hom.inl) (F.map category_theory.limits.walking_cospan.hom.inr)
 : tactic simp_lemmas
{R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] [nontrivial R] [nonempty Œπ] (e : basis Œπ R M) (x : orientation R M Œπ) (i : Œπ) : ‚áë(e.adjust_to_orientation x) i = ‚áëe i ‚à® ‚áë(e.adjust_to_orientation x) i = -‚áëe i
{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) (s : set M) (hs : s = ‚Üëp) : submodule R M
 : Type
{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : L.sum < 0) : 0 < L.length
(Œ± : Type u_3) [topological_space Œ±] : Type u_3
{Œ± : Type u} {Œ≤ : Type v} {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} [partial_order Œ±] [lattice Œ≤] (gi : galois_coinsertion l u) : lattice Œ±
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : bilin_form R M ‚Üí+ M ‚Üí M ‚Üí R
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) (t : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (ùüô X) (ùüô X) rfl)) : category_theory.mono f
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cocone F} : category_theory.limits.is_colimit t ‚âÖ Œ† (s : category_theory.limits.cocone F), unique (t ‚ü∂ s)
{M : Type u_1} {N : Type u_2} [mM : add_zero_class M] [mN : add_zero_class N] {f : M ‚Üí N} (h : is_add_monoid_hom f) : M ‚Üí+ N
{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] [nonempty Œ≤] [semilattice_sup Œ≤] {s : Œ≤ ‚Üí Œ±} (b : Œ≤ ‚Üí ‚Ñù) (h : ‚àÄ (n m N : Œ≤), N ‚â§ n ‚Üí N ‚â§ m ‚Üí has_dist.dist (s n) (s m) ‚â§ b N) (h‚ÇÄ : filter.tendsto b filter.at_top (nhds 0)) : cauchy_seq s
(R : Type u) (M : Type v) (M‚ÇÇ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] : ‚Ü•(submodule.fst R M M‚ÇÇ) ‚âÉ‚Çó[R] M
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : has_mul (submodule R A)
{x : ‚Ñù} (hx : 0 ‚â§ x) (y z : ‚Ñù) : x ^ y * x ^ z ‚â§ x ^ (y + z)
{Œπ : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [ordered_add_comm_monoid N] (f : M ‚Üí N) (h_mul : ‚àÄ (x y : M), f (x + y) ‚â§ f x + f y) {s : finset Œπ} (hs : s.nonempty) (g : Œπ ‚Üí M) : f (s.sum (Œª (i : Œπ), g i)) ‚â§ s.sum (Œª (i : Œπ), f (g i))
(Œ± : Type u_3) [has_le Œ±] [has_add Œ±] [has_sub Œ±] : Type
(m : ‚Ñù) (k : ‚Ñï) : ‚Ñù
(n : ‚Ñï) : (n + 2).factors = (n + 2).min_fac :: ((n + 2) / (n + 2).min_fac).factors
{p : ‚Ñï} [hp : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {S : Type u_2} [semiring S] (f : Œ† (k : ‚Ñï), S ‚Üí+* truncated_witt_vector p k R) (f_compat : ‚àÄ (k‚ÇÅ k‚ÇÇ : ‚Ñï) (hk : k‚ÇÅ ‚â§ k‚ÇÇ), (truncated_witt_vector.truncate hk).comp (f k‚ÇÇ) = f k‚ÇÅ) : S ‚Üí+* witt_vector p R
{Œπ : Type u_1} [decidable_eq Œπ] {A : Œπ ‚Üí Type u_2} {R : Type u_3} [Œ† (i : Œπ), add_comm_monoid (A i)] [add_monoid Œπ] [direct_sum.gsemiring A] [semiring R] (f : Œ† (i : Œπ), A i ‚Üí+ R) (hone : ‚áë(f 0) graded_monoid.ghas_one.one = 1) (hmul : ‚àÄ {i j : Œπ} (ai : A i) (aj : A j), ‚áë(f (i + j)) (graded_monoid.ghas_mul.mul ai aj) = ‚áë(f i) ai * ‚áë(f j) aj) : direct_sum Œπ (Œª (i : Œπ), A i) ‚Üí+* R
{Œ± : Type u} [preorder Œ±] {s : set Œ±} {a : Œ±} (h : is_greatest s a) : bdd_above s
(R : Type u) [comm_ring R] (S : Type v) [comm_ring S] : prime_spectrum (R √ó S) ‚âÉ prime_spectrum R ‚äï prime_spectrum S
{E : ‚Ñï ‚Üí Type u_1} [Œ† (n : ‚Ñï), uniform_space (E n)] (h : ‚àÄ (n : ‚Ñï), uniformity (E n) = filter.principal id_rel) : metric_space (Œ† (n : ‚Ñï), E n)
(mvar : expr) : tactic.unsafe.type_context expr
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.preadditive C] : C ‚•§ category_theory.Mat_ C
{G : Type u_1} [group G] (k : set G) : subgroup G
{Œ± : Type u} {Œ≤ : Type v} [decidable_eq Œ≤] [fintype Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) {n : ‚Ñï} (hn : fintype.card Œ≤ * n < fintype.card Œ±) : ‚àÉ (y : Œ≤), n < (finset.filter (Œª (x : Œ±), f x = y) finset.univ).card
 : ‚Ñù*
{p n : ‚Ñï} {R : Type u_1} (i : fin n) (x : truncated_witt_vector p n R) : R
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u} [category_theory.category J] {X : J} (tX : category_theory.limits.is_terminal X) (F : J ‚•§ C) : category_theory.limits.is_colimit (category_theory.limits.cocone_of_diagram_terminal tX F)
{n m : ‚Ñï} (e : fin n ‚âÉo fin m) (i : fin n) : ‚Üë(‚áëe i) = ‚Üëi
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b : Œ±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{G : Type u_1} [has_zero G] [has_add G] [has_neg G] : list G ‚Üí G
{Œ± : Type u_1} [measurable_space Œ±] {M : Type u_3} [add_comm_monoid M] [topological_space M] [has_continuous_add M] (i : set Œ±) : measure_theory.vector_measure Œ± M ‚Üí+ measure_theory.vector_measure Œ± M
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) (a : Œ±) : Prop
{Œ± : Type u_1} {Œπ : Sort u_2} (m : Œπ ‚Üí measure_theory.outer_measure Œ±) {s : set Œ±} (hs : s.nonempty) : (‚áë‚®Ö (i : Œπ), m i) s = ‚®Ö (t : ‚Ñï ‚Üí set Œ±) (h2 : s ‚äÜ set.Union t), ‚àë' (n : ‚Ñï), ‚®Ö (i : Œπ), ‚áë(m i) (t n)
{M : Type u_1} [add_monoid M] : is_add_submonoid set.univ
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype (Œ± ‚äï Œ≤)] : fintype Œ≤
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} (h : s.finite) : finite_dimensional k ‚Ü•((affine_span k s).direction)
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} (Hf : function.injective f) : function.injective (option.map f)
(s : ‚Ñù) : filter.tendsto (Œª (x : ‚Ñù), real.exp x / x ^ s) filter.at_top filter.at_top
{A : Type u_4} {B : Type u_5} {C : Type u_6} {D : Type u_7} [monoid A] [monoid B] [monoid C] [monoid D] [topological_space A] [topological_space B] [topological_space C] [topological_space D] (f : continuous_monoid_hom A C) (g : continuous_monoid_hom B D) : continuous_monoid_hom (A √ó B) (C √ó D)
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [complete_lattice Œ±] [complete_lattice Œ≤] [complete_lattice Œ≥] (f : frame_hom Œ≤ Œ≥) (g : frame_hom Œ± Œ≤) : frame_hom Œ± Œ≥
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [non_assoc_semiring Œ±] [preorder Œ±] [non_assoc_semiring Œ≤] [preorder Œ≤] : Type (max u_6 u_7 u_8)
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) {X Y : C} (i : X ‚âÖ Y) : F.obj X ‚âÖ F.obj Y
(hl hu : expr) (n : option name) : tactic unit
{n : ‚Ñï} (v : bitvec n) : ‚Ñï
(Œπ : Type u_2) : Type u_2
 : snum ‚Üí snum
{G : Type u_2} [group G] : mul_action.fixed_points (conj_act G) G = ‚Üë(subgroup.center G)
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {M' : Type u_3} [add_comm_group M'] [module R M'] {Œπ : Type u_4} [decidable_eq Œπ] [fintype Œπ] {f : M ‚Üí‚Çó[R] M'} {v : basis Œπ R M} {v' : basis Œπ R M'} (h : is_unit (‚áë(linear_map.to_matrix v v') f).det) : M ‚âÉ‚Çó[R] M'
 : zmod 8 ‚Üí*‚ÇÄ ‚Ñ§
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s t : set Œ±} (hs : bdd_above s) (sne : s.nonempty) (ht : bdd_above t) (tne : t.nonempty) : has_Sup.Sup (s ‚à™ t) = has_Sup.Sup s ‚äî has_Sup.Sup t
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : euclidean_geometry.orthogonal_projection_fn s p -·µ• p ‚àà (s.direction)·óÆ
{M : Type u_5} [nontrivial M] [hM : monoid_with_zero M] (h : ‚àÄ (a : M), is_unit a ‚à® a = 0) : group_with_zero M
{Œ± : Type u_1} {Œ≤ : Type u_2} {t : Œ± ‚Üí set Œ≤} (h : ‚àÄ (i j : Œ±), i ‚â† j ‚Üí disjoint (t i) (t j)) : (‚Ü•‚ãÉ (i : Œ±), t i) ‚âÉ Œ£ (i : Œ±), ‚Ü•(t i)
{Œ± : Type u_2} {Œ≤ : Type u_3} [decidable_eq Œ≤] [has_scalar Œ± Œ≤] : has_scalar Œ± (finset Œ≤)
{C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object.augmented C·µí·µñ) : X.left_op.right_op ‚âÖ X
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (D : Type w) [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] : ùü≠ (C·µí·µñ ‚•§ D) ‚ü∂ J.plus_functor D
{R : Type u_1} [comm_semiring R] [topological_space R] [topological_semiring R] (X : set R) : polynomial R ‚Üí‚Çê[R] C(‚Ü•X, R)
{Œ≤ : Type u} {Œ± : Type v} [add_comm_monoid Œ≤] {s : finset Œ±} (f : Œ± ‚Üí Œ≤) : mul_opposite.op (s.sum (Œª (x : Œ±), f x)) = s.sum (Œª (x : Œ±), mul_opposite.op (f x))
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} (h : continuous_within_at f s x) : filter.tendsto f (nhds_within x s) (nhds (f x))
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [add_comm_semigroup Œ≤] : add_comm_semigroup Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [decidable_eq Œ≥] (s : finset Œ±) (t : finset Œ≤) (f : Œ± √ó Œ≤ ‚Üí finset Œ≥) : (s.product t).bUnion f = s.bUnion (Œª (a : Œ±), t.bUnion (Œª (b : Œ≤), f (a, b)))
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} : strict_mono f ‚Üí strict_anti (‚áëorder_dual.to_dual ‚àò f)
{n : ‚Ñï} (k : ‚Ñï) : option (fin2 n)
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} : b ‚â§ c ‚Üí a = b ‚Üí a ‚â§ c
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} : L.bounded_formula Œ± n ‚Üí Prop
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} {f g : C ‚ü∂ D} : homotopy f g ‚âÉ homotopy (f - g) 0
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {G : C ‚•§ D} {K : category_theory.grothendieck_topology D} [category_theory.full G] [category_theory.faithful G] (H : category_theory.cover_dense K G) : category_theory.grothendieck_topology C
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_mul Œ±] [has_mul Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u_1} [fintype Œ±] [decidable_eq Œ±] {n : ‚Ñï} (h : fintype.card Œ± = n) : trunc (Œ± ‚âÉ fin n)
{X Y : Top} {f : X ‚ü∂ Y} (h : is_open_map ‚áëf) (x : ‚Ü•X) : topological_space.open_nhds x ‚•§ topological_space.open_nhds (‚áëf x)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {Œπ : Type u_5} [normed_field ùïú] [add_comm_group F] [module ùïú F] [add_comm_group E] [module ùïú E] (q : seminorm_family ùïú F Œπ) (f : E ‚Üí‚Çó[ùïú] F) : seminorm_family ùïú E Œπ
{Œ± : Type u} {Œ≤ : Type v} [add_comm_monoid Œ≤] (s : finset Œ±) (f : finset Œ± ‚Üí Œ≤) : s.powerset.sum (Œª (t : finset Œ±), f t) = (finset.range (s.card + 1)).sum (Œª (j : ‚Ñï), (finset.powerset_len j s).sum (Œª (t : finset Œ±), f t))
{R : Type u} [ring R] (S : subring R) (s : set R) (hs : s = ‚ÜëS) : subring R
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] [complete_space ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [finite_dimensional ùïú F] {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ‚ä§) {Œ± : Type u_4} {l : filter Œ±} {g‚ÇÅ : Œ± ‚Üí F} {g‚ÇÇ : Œ± ‚Üí ‚Ü•(f'.ker)} (h‚ÇÅ : filter.tendsto g‚ÇÅ l (nhds (f a))) (h‚ÇÇ : filter.tendsto g‚ÇÇ l (nhds 0)) : filter.tendsto (Œª (t : Œ±), has_strict_fderiv_at.implicit_function f f' hf hf' (g‚ÇÅ t) (g‚ÇÇ t)) l (nhds a)
{Œ± : Type u_1} {Œ∑ : Type u_14} [fintype Œ∑] {Œπs : Œ∑ ‚Üí Type u_15} [has_zero Œ±] : ((Œ£ (j : Œ∑), Œπs j) ‚Üí‚ÇÄ Œ±) ‚âÉ Œ† (j : Œ∑), Œπs j ‚Üí‚ÇÄ Œ±
{Œ± : Type u_3} {Œ≤ : Type u_4} [has_inf Œ±] [has_top Œ±] [has_inf Œ≤] [has_top Œ≤] : inf_top_hom Œ± Œ≤ ‚âÉ sup_bot_hom Œ±·µí·µà Œ≤·µí·µà
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : Prop
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) [invertible A.det] : invertible A
{Œ± : Type u_3} {Œ≤ : Type u_4} [nonempty Œ±] [semilattice_sup Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : monotone f) : filter.tendsto f filter.at_top filter.at_top ‚Üî ‚àÄ (b : Œ≤), ‚àÉ (a : Œ±), b ‚â§ f a
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (s : set Œ±) (f : C(Œ±, Œ≤)) : C(‚Ü•s, Œ≤)
(ic nc : tactic.instance_cache) (a' : expr) : tactic (tactic.instance_cache √ó tactic.instance_cache √ó expr √ó expr)
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] {K‚ÇÄ : topological_space.positive_compacts G} : measure_theory.sigma_finite (measure_theory.measure.haar_measure K‚ÇÄ)
{R : Type u‚ÇÅ} [linear_ordered_ring R] {a : R} (H : -2 ‚â§ a) (n : ‚Ñï) : 1 + ‚Üën * a ‚â§ (1 + a) ^ n
(Œ± : Type u_2) [fintype Œ±] [nonempty Œ±] [linear_order Œ±] : complete_linear_order Œ±
{n : ‚Ñï} {Œ± : typevec n} {Œ≤ : typevec n} {Œ≥ : typevec n} (g : Œ≤.arrow Œ≥) (f : Œ±.arrow Œ≤) : Œ±.arrow Œ≥
(œÑ : Type u_1) [topological_space œÑ] [add_monoid œÑ] [has_continuous_add œÑ] (Œ± : Type u_2) [topological_space Œ±] : Type (max u_1 u_2)
(C : Type u) [category_theory.category C] : Mon_ (C ‚•§ C) ‚•§ category_theory.monad C
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a : Œ±} : 1 ‚â§ a‚Åª¬π ‚Üí a ‚â§ 1
{M : Type u} [monoid M] (x : M) (n : ‚Ñï) (hx : x ^ n = 1) (hn : 0 < n) : invertible x
(R : Type u_1) [semiring R] : Prop
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] [category_theory.limits.has_limits_of_shape J C] (F : J ‚•§ K ‚•§ C) (k : K) : (category_theory.limits.limit F).obj k ‚âÖ category_theory.limits.limit (F ‚ãô (category_theory.evaluation K C).obj k)
(G : Type u) : Type u
{Œ± : Type u_1} [preorder Œ±] : Œ± ‚Üío antisymmetrization Œ± has_le.le
 : (user_attribute unit)
{Œ± : Type u_1} {M : Type u_4} [has_zero M] {s : set Œ±} {f : Œ± ‚Üí M} {a : Œ±} (h : s.indicator f a ‚â† 0) : a ‚àà s
(Œ± : Type u_1) : ‚Ü•‚àÖ ‚âÉ pempty
(q : interactive.parse interactive.types.texpr) : tactic unit
{C : Type u} [category_theory.category C] {X Y : C} (Œ± : X ‚âÖ Y) : category_theory.End X ‚âÉ* category_theory.End Y
{n : ‚Ñï} {F : typevec n ‚Üí Type u_1} [mvfunctor F] (q : mvqpf F) : Prop
 : native.float
(ùïú : Type u_1) (E : Type u_2) [normed_field ùïú] [semi_normed_group E] [normed_space ùïú E] : with_seminorms (Œª (_x : fin 1), norm_seminorm ùïú E)
{R : Type u_1} [comm_monoid_with_zero R] (f : nat.arithmetic_function R) (hf : f.is_multiplicative) (g : nat.arithmetic_function R) (hg : g.is_multiplicative) : f = g ‚Üî ‚àÄ (p i : ‚Ñï), nat.prime p ‚Üí ‚áëf (p ^ i) = ‚áëg (p ^ i)
{V : Type u} {G : simple_graph V} [decidable_eq V] {u v : V} (p : G.walk u v) : G.path u v
 : tactic (name √ó expr √ó expr)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] (T : category_theory.triangulated.triangle C) : T ‚ü∂ (category_theory.triangulated.inv_rotate C).obj ((category_theory.triangulated.rotate C).obj T)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : category_theory.lax_monoidal_functor.id C ‚âÖ category_theory.monoidal.lax_to_transported e ‚äó‚ãô (category_theory.monoidal.from_transported e).to_lax_monoidal_functor
{Œπ : Type u} {Œ≥ : Type w} {Œ≤ : Œπ ‚Üí Type v} [dec : decidable_eq Œπ] [Œ† (i : Œπ), add_zero_class (Œ≤ i)] [add_comm_monoid Œ≥] (f : Œ† (i : Œπ), Œ≤ i ‚Üí+ Œ≥) (i : Œπ) : (‚áëdfinsupp.lift_add_hom f).comp (dfinsupp.single_add_hom Œ≤ i) = f i
(C : Type u‚ÇÅ) [category_theory.category C] : category_theory.comonad C ‚•§ C ‚•§ C
{Œ± : Type u_1} {R : Type u_2} {l : filter Œ±} {f : Œ± ‚Üí R} {r : R} [linear_ordered_ring R] [archimedean R] (hr : r < 0) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (Œª (x : Œ±), f x * r) l filter.at_top
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí Œ± ‚Üí Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [preorder Œ±] [preorder Œ≤] [locally_finite_order Œ≤] (f : Œ± ‚Ü™o Œ≤) : locally_finite_order Œ±
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type u_1} [finite_dimensional K V] (b : basis Œπ K V) : fintype Œπ
{K : Type u_1} {n : ‚Ñï} {g : generalized_continued_fraction K} [field K] (nth_part_denom_ne_zero : ‚àÄ {b : K}, g.partial_denominators.nth n = option.some b ‚Üí b ‚â† 0) : g.convergents (n + 1) = (g.squash_gcf n).convergents n
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_vadd Œ± Œ≤] : has_vadd (filter Œ±) (filter Œ≤)
{Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : Prop
{R : Type u_1} [comm_ring R] [is_domain R] {a b c : R} (h2 : 2 ‚â† 0) (ha : a ‚â† 0) (x : R) : a * x * x + b * x + c = 0 ‚Üî discrim a b c = (2 * a * x + b) ^ 2
(n : name) (ls : list name) (t e : expr) : declaration
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] (Q : quadratic_form R M) (Q' : M ‚Üí R) (h : Q' = ‚áëQ) : quadratic_form R M
 : category_theory.ulift_functor ‚âÖ ùü≠ (Type u)
(a : expr) : tactic (expr √ó expr)
{K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {n : ‚Ñï} : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.none ‚Üî generalized_continued_fraction.int_fract_pair.stream v n = option.none ‚à® ‚àÉ (ifp : generalized_continued_fraction.int_fract_pair K), generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp ‚àß ifp.fr = 0
{Œ± : Type u_1} (f : Œ± ‚Üí Œ± ‚Üí Œ±) [is_associative Œ± f] (x y : Œ±) : f x ‚àò f y = f (f x y)
{n : ‚Ñï} (Œ± : typevec (n + 1)) : typevec n
{M‚ÇÄ : Type u_1} [mul_zero_class M‚ÇÄ] : (Œª (_x : M‚ÇÄ), _x * 0) = function.const M‚ÇÄ 0
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} (x : category_theory.presieve.family_of_elements P R) [category_theory.limits.has_pullbacks C] : Prop
{E : Type u_1} [add_comm_group E] [module ‚Ñù E] [topological_space E] [has_continuous_smul ‚Ñù E] {F : Type u_2} [add_comm_group F] [module ‚Ñù F] [topological_space F] [has_continuous_smul ‚Ñù F] [t2_space F] (f : E ‚Üí+ F) (hf : continuous ‚áëf) (c : ‚Ñù) (x : E) : ‚áëf (c ‚Ä¢ x) = c ‚Ä¢ ‚áëf x
(D : algebraic_geometry.Scheme.glue_data) (a b : Œ£ (i : D.to_glue_data.J), ‚Ü•((D.to_glue_data.U i).to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) [category_theory.limits.has_limit (K ‚ãô F)] [category_theory.creates_limit K F] : category_theory.limits.has_limit K
(q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} [is_well_order Œ≤ s] : subsingleton (principal_seg r s)
(red : tactic.transparency) (e : expr) {Œ± : Type} (m : tactic.ring.ring_m Œ±) : tactic Œ±
(n : ‚Ñï) (R : Type u_1) [ring R] : (polynomial.cyclotomic n R).monic
{a b : Prop} : ¬¨(a ‚àß b) ‚Üî ¬¨a ‚à® ¬¨b
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {a : Œ±} {s : set Œ±} (h : a ‚àâ s ‚Üí f a = 0) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà has_insert.insert a s), f i)) = finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i))
{Œ± : Type u_1} {Œ≤ : Type u_2} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {K : nnreal} {f : Œ± ‚Üí Œ≤} : antilipschitz_with K f ‚Üí ‚àÄ (x y : Œ±), has_nndist.nndist x y ‚â§ K * has_nndist.nndist (f x) (f y)
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddCommMon) : AddCommMon
(p n : ‚Ñï) : mv_polynomial (fin 2 √ó ‚Ñï) ‚Ñ§
(x : ‚ÑÇ) : has_strict_deriv_at complex.cosh (complex.sinh x) x
{M : Type u_1} [monoid M] (u : MÀ£) (a : M) : is_unit (‚Üëu * a) ‚Üî is_unit a
 : declaration ‚Üí list level ‚Üí option expr
(J : Type v) : category_theory.limits.wide_pushout_shape J ‚•§ (category_theory.limits.wide_pullback_shape J)·µí·µñ
(a : out_param ‚Ñù) (outer : filter ‚Ñù) (inner : out_param (filter ‚Ñù)) : Prop
(cl : tactic.closure) (e‚ÇÄ e‚ÇÅ : expr) : tactic expr
(x y : ‚Ñï) : ‚Ñ§ √ó ‚Ñ§
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (i : D ‚•§ C) [category_theory.limits.has_finite_products C] [category_theory.cartesian_closed C] : Prop
{ùïÜ : Type u_1} {Œ± : Type u_3} {Œ≤ : Type u_4} [preorder ùïÜ] [preorder Œ±] [preorder Œ≤] [grade_order ùïÜ Œ≤] (f : Œ± ‚Üí Œ≤) (hf : strict_mono f) (hcovby : ‚àÄ (a b : Œ±), a ‚ãñ b ‚Üí f a ‚ãñ f b) : grade_order ùïÜ Œ±
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_coequalizer f g] : C
 : interactive.parse hyp ‚Üí interactive.parse (optional (lean.parser.tk "with" *> interactive.types.texpr)) ‚Üí interactive.parse (optional (lean.parser.tk "using" *> lean.parser.ident)) ‚Üí tactic unit
{F : pfunctor} (x : F.M) (i : F.B x.head) : F.M
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : Œ± ‚Üí Œ≤) : Prop
 : W_type W_type.nat_Œ≤ ‚âÉ ‚Ñï
 : turing.to_partrec.cont ‚Üí list ‚Ñï ‚Üí turing.to_partrec.cfg
{C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] : category_theory.limits.preserves_colimits (algebraic_geometry.PresheafedSpace.forget C)
{R : Type u_1} [comm_ring R] : set.surj_on (Œª (g : matrix.special_linear_group (fin 2) R), ‚Üëg 1) set.univ {cd : fin 2 ‚Üí R | is_coprime (cd 0) (cd 1)}
{G : Type u_1} [group G] (s : set G) : G ‚Üí Prop
{R : Type u_1} {M : Type u_9} {M‚ÇÇ : Type u_11} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] (f‚Çó : M ‚Üí+[R] M‚ÇÇ) : M ‚Üí‚Çó[R] M‚ÇÇ
 : hole_command
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b : Œ±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{Œ± : Type} : list (widget.attr Œ±) ‚Üí widget.html Œ± ‚Üí widget.html Œ±
 : znum ‚Üí znum ‚Üí znum
{Œ± : Type u_1} {Œπ : Type u_3} {m : measurable_space Œ±} [linear_order Œπ] {f : measure_theory.filtration Œπ m} {œÑ : Œ± ‚Üí Œπ} [topological_space Œπ] [order_topology Œπ] [topological_space.first_countable_topology Œπ] (hœÑ : measure_theory.is_stopping_time f œÑ) (i : Œπ) (h_lub : is_lub (set.Iio i) i) : measurable_set {x : Œ± | œÑ x < i}
 : widget.tc expr empty
{Œ± : Type u} {Œ≤ : Type v} [semiring Œ±] [semiring Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_semiring_hom f) {Œ≥ : Type u_1} [semiring Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : is_semiring_hom g) : is_semiring_hom (g ‚àò f)
{R : Type u} [comm_ring R] : topological_space (prime_spectrum R)
{Œ± : Type u_1} {Œπ : Type u_3} [complete_lattice Œ±] [fintype Œπ] {f : Œπ ‚Üí Œ±} : complete_lattice.independent f ‚Üí finset.univ.sup_indep f
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : continuous_at f a) (hb : continuous_at f b) : has_fderiv_at (Œª (p : ‚Ñù √ó ‚Ñù), ‚à´ (x : ‚Ñù) in p.fst..p.snd, f x) ((continuous_linear_map.snd ‚Ñù ‚Ñù ‚Ñù).smul_right (f b) - (continuous_linear_map.fst ‚Ñù ‚Ñù ‚Ñù).smul_right (f a)) (a, b)
{C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ‚Ñï} {i : fin (n + 2)} : X.Œ¥ i ‚â´ X.Œ¥ (‚áëfin.cast_succ i) = X.Œ¥ i ‚â´ X.Œ¥ i.succ
 : expr ‚Üí tactic (expr √ó option expr)
{M : Type u_1} [has_add M] {r s : M ‚Üí M ‚Üí Prop} (h : ‚àÄ (x y : M), r x y ‚Üí s x y) : add_con_gen r ‚â§ add_con_gen s
{Œ± : Type u_1} (Œ≤ : Type u_2) [add_group Œ±] [add_monoid Œ≤] [add_action Œ≤ Œ±] (H : add_subgroup Œ±) : Prop
{Œ± : Type u_1} [topological_space Œ±] [t2_space Œ±] (s : topological_space.nonempty_compacts Œ±) : topological_space.closeds Œ±
 : tactic.interactive.itactic ‚Üí tactic unit
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (ùïú : Type u_3) [division_ring ùïú] [category_theory.limits.has_kernels C] [category_theory.linear ùïú C] {X Y : C} [category_theory.simple X] [category_theory.simple Y] (h : (X ‚âÖ Y) ‚Üí false) : finite_dimensional.finrank ùïú (X ‚ü∂ Y) = 0
 : Type
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ùïú] [inner_product_space ùïú E] [inner_product_space ùïú F] [complete_space E] : (E ‚ÜíL[ùïú] F) ‚ÜíL‚ãÜ[ùïú] F ‚ÜíL[ùïú] E
 : Type
(M : Type u_5) (N : Type u_6) [has_add M] [has_add N] : add_hom (M √ó N) N
(n : ‚Ñï) : simple_graph (fin n)
(Œ± : Type u) [has_mul Œ±] : Type u
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) (b : n ‚Üí Œ±) (h : is_unit A.det) : A.det ‚Ä¢ matrix.vec_mul b A‚Åª¬π = ‚áë(A.transpose.cramer) b
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : Y ‚ü∂ X) [category_theory.limits.has_pullbacks C] (R : category_theory.presieve X) : category_theory.presieve Y
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} {f g : C ‚ü∂ D} (h : homotopy f g) : homotopy g f
 : Type
{Œ± : Type u_1} [linear_order Œ±] {s : set Œ±} : ¬¨bdd_below s ‚Üî ‚àÄ (x : Œ±), ‚àÉ (y : Œ±) (H : y ‚àà s), y < x
{k : ‚Ñï} : fact (even (fintype.card (fin (bit0 k))))
{B : Type u‚ÇÅ} [comm_ring B] (r : B ‚Üí B ‚Üí Prop) : B ‚ß∏ ideal.of_rel r ‚Üí+* ring_quot r
{G : Type u_1} [add_group G] (H : add_subgroup G) : Prop
{C : Type u} [category_theory.category C] (J : Type v) [category_theory.small_category J] (K : J ‚•§ C·µí·µñ) (c : category_theory.limits.cone K) (t : Œ† (X : C), category_theory.limits.is_limit ((category_theory.yoneda.obj X).map_cone c)) : category_theory.limits.is_limit c
{G : Type u_1} [group G] {G' : Type u_4} [group G'] (f : G ‚Üí* G') (H' : subgroup G') : ‚Ü•(subgroup.comap f H') ‚Üí* ‚Ü•H'
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.monoidal_category C] [category_theory.monoidal_preadditive C] [category_theory.limits.has_finite_biproducts C] {J : Type u_2} [fintype J] (X : C) (f : J ‚Üí C) : X ‚äó ‚®Å f ‚âÖ ‚®Å Œª (j : J), X ‚äó f j
(G : Type u_1) [group G] : Prop
{p : ‚Ñï} {R : Type u_1} [comm_ring R] (n : ‚Ñï) : witt_vector p R ‚Üí witt_vector p R
{n : ‚Ñï} (hn : n % 2 = 1) : ‚áëzmod.œá‚ÇÑ ‚Üën = (-1) ^ (n / 2)
{Œ± : Type u} (l : ordnode Œ±) (x : Œ±) (r : ordnode Œ±) : ordnode Œ±
{Œπ : Type u_1} {R‚ÇÇ : Type u_7} {M‚ÇÇ : Type u_8} [comm_ring R‚ÇÇ] [add_comm_group M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] [decidable_eq Œπ] (e : basis Œπ R‚ÇÇ M‚ÇÇ) (w : Œπ ‚Üí R‚ÇÇÀ£) : e.to_matrix ‚áë(e.units_smul w) = matrix.diagonal (coe ‚àò w)
{Œπ : Type u_3} : (Œπ ‚Üí‚ÇÄ ‚Ñï) ‚âÉo multiset Œπ
{Œ± : Type u_2} [has_zero Œ±] : has_zero (finset Œ±)
{M' : Type u_4} {Œ± : Type u_5} [monoid M'] [mul_action M' Œ±] (S : submonoid M') : mul_action ‚Ü•S Œ±
{C : Type u} [category_theory.category C] {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z} (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (h‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [category_theory.limits.has_pullback f‚ÇÅ g‚ÇÅ] [category_theory.limits.has_pullback f‚ÇÇ g‚ÇÇ] : category_theory.limits.pullback f‚ÇÅ g‚ÇÅ ‚âÖ category_theory.limits.pullback f‚ÇÇ g‚ÇÇ
 : (user_attribute unit)
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [ring_hom_surjective œÑ‚ÇÅ‚ÇÇ] (f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] ‚Ü•(f.range)
{Œ± : Type u_1} {a b : Œ±} [partial_order Œ±] (h : a < b) : order_bot ‚Ü•(set.Ico a b)
{Œπ : Type w} {R : Type u} [semiring R] {M : Type v} [add_comm_monoid M] [module R M] {v : Œπ ‚Üí M} (i : linear_independent R v) : Prop
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} {Œπ : Type v} (hs : is_compact s) (Z : Œπ ‚Üí set Œ±) (hZc : ‚àÄ (i : Œπ), is_closed (Z i)) (hsZ : (s ‚à© ‚ãÇ (i : Œπ), Z i) = ‚àÖ) : ‚àÉ (t : finset Œπ), (s ‚à© ‚ãÇ (i : Œπ) (H : i ‚àà t), Z i) = ‚àÖ
{T : Type u‚ÇÅ} [category_theory.category T] {Y : T} : category_theory.over.map (ùüô Y) ‚âÖ ùü≠ (category_theory.over Y)
(l : list ‚Ñï) (n : ‚Ñï) : list.sorted has_le.le (denumerable.raise l n)
(Œ± : Type u_1) : Type u_1
(E : Type u_1) [add_comm_group E] [has_norm E] (C : semi_normed_group.core E) : semi_normed_group E
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) [category_theory.is_filtered J] (j : J) : 1 = Mon.filtered_colimits.M.mk F ‚ü®j, 1‚ü©
{K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {n : ‚Ñï} {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (stream_succ_nth_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : (generalized_continued_fraction.of v).s.nth n = option.some {a := 1, b := ‚Üë(ifp_succ_n.b)}
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (f : Œ± ‚Üí Œ±) (x : Œ±) : ordnode Œ± ‚Üí ordnode Œ±
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.is_connected J] {B : C} {F : J ‚•§ category_theory.over B} {c : category_theory.limits.cone (F ‚ãô category_theory.over.forget B)} (t : category_theory.limits.is_limit c) : category_theory.limits.is_limit (category_theory.over.creates_connected.raise_cone c)
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : Top} (f : X ‚ü∂ Y) : Top.presheaf.pullback C f ‚ä£ Top.presheaf.pushforward C f
{E : Type u_3} {F : Type u_4} [normed_group E] [normed_group F] : normed_group (E √ó F)
(ùïú : Type u_1) {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_3} [linear_order Œπ] [order_bot Œπ] [locally_finite_order Œπ] [is_well_order Œπ has_lt.lt] [succ_order Œπ] [is_succ_archimedean Œπ] (f : Œπ ‚Üí E) (h‚ÇÄ : linear_independent ùïú f) : orthonormal ùïú (gram_schmidt_normed ùïú f)
{G : Type u_1} [group G] {N : Type u_2} [group N] (f : G ‚Üí* N) (hf : function.surjective ‚áëf) : f.range = ‚ä§
 : tactic.list_Pi tactic.rcases_patt ‚Üí tactic.rcases_patt
{t t' : Type u ‚Üí Type u} (eqv : Œ† (Œ± : Type u), t Œ± ‚âÉ t' Œ±) [traversable t] [is_lawful_traversable t] [traversable t'] (h‚ÇÄ : ‚àÄ {Œ± Œ≤ : Type u} (f : Œ± ‚Üí Œ≤), functor.map f = equiv.map eqv f) (h‚ÇÅ : ‚àÄ {Œ± Œ≤ : Type u} (f : Œ≤), functor.map_const f = (equiv.map eqv ‚àò function.const Œ±) f) (h‚ÇÇ : ‚àÄ {F : Type u ‚Üí Type u} [_inst_7 : applicative F] [_inst_8 : is_lawful_applicative F] {Œ± Œ≤ : Type u} (f : Œ± ‚Üí F Œ≤), traversable.traverse f = equiv.traverse eqv f) : is_lawful_traversable t'
{E : Type u_1} [inner_product_space ‚Ñù E] {c : E} (f : cont_diff_bump_of_inner c) : E ‚Üí ‚Ñù
{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (ra : is_right_regular a) : a ‚â† 0
{Œ± : Type u_1} [complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] : compact_space Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {x : E} {n : with_top ‚Ñï} {f : E ‚Üí F} (hf : cont_diff_at ùïú n f x) : cont_diff_at ùïú n (Œª (x : E), -f x) x
{C : Type u} [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} [category_theory.limits.has_image f] (F' : category_theory.limits.mono_factorisation f) : category_theory.limits.image f ‚ü∂ F'.I
{Œ± : Type u} {C : with_top Œ± ‚Üí Sort u_1} (h‚ÇÅ : C ‚ä§) (h‚ÇÇ : Œ† (a : Œ±), C ‚Üëa) (n : with_top Œ±) : C n
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] {E : Type u‚ÇÉ} [category_theory.category E] [category_theory.monoidal_category E] {B : Type u‚ÇÄ} [category_theory.category B] [category_theory.monoidal_category B] (F : category_theory.lax_monoidal_functor B C) (G : category_theory.lax_monoidal_functor D E) : category_theory.lax_monoidal_functor (B √ó D) (C √ó E)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (oi : Œ± ‚âÉo Œ≤) : galois_insertion ‚áëoi ‚áë(oi.symm)
{Œ± : Type u} (f : (Œ± ‚Üí ‚Ñï) ‚Üí ‚Ñï) : Prop
{Œ± : Type u} : Œ± ‚âÉ additive Œ±
(del : interactive.parse (optional (lean.parser.tk "!"))) (ns : interactive.parse (lean.parser.many lean.parser.ident)) : tactic unit
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) {J : Type u} [category_theory.category J] (K : J ‚•§ C) : category_theory.limits.cocone (K ‚ãô F) ‚•§ category_theory.limits.cocone K
{Œ± : Type u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {s : set Œ±} (e : Œ≤ ‚âÉ ‚Ü•s) (v : Œ≤ ‚Üí Œ≥) (w : Œ± ‚Üí Œ≥) (j : Œ≤) (x : Œ≥) [decidable_eq Œ≤] [decidable_eq Œ±] [Œ† (j : Œ±), decidable (j ‚àà s)] : (Œª (i : Œ±), dite (i ‚àà s) (Œª (h : i ‚àà s), function.update v j x (‚áë(e.symm) ‚ü®i, h‚ü©)) (Œª (h : i ‚àâ s), w i)) = function.update (Œª (i : Œ±), dite (i ‚àà s) (Œª (h : i ‚àà s), v (‚áë(e.symm) ‚ü®i, h‚ü©)) (Œª (h : i ‚àâ s), w i)) ‚Üë(‚áëe j) x
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_equalizer f g] : C
(M : Type u) : Type u
{K : Type u} [field K] : complete_lattice (subfield K)
{P : ‚Ñï ‚Üí Sort u_1} {m n : ‚Ñï} (h : Œ† (k : ‚Ñï), k < n ‚Üí m ‚â§ k ‚Üí P (k + 1) ‚Üí P k) (mn : m ‚â§ n) (hP : P n) : P m
 : ‚Ñï ‚Üí nat.partrec.code
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M ‚Üí* P} (H : c ‚â§ con.ker f) (x : M) : ‚áë(c.lift f H) ‚Üëx = ‚áëf x
{Œπ : Type u_1} (f : Œπ ‚Üí ordinal) : ordinal
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x : V) {r : ‚Ñù} : 2 ‚Ä¢ o.oangle (r ‚Ä¢ x) x = 0
{G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (a b : G) : ‚áëf (a + -b) = ‚áëf a + -‚áëf b
{Œ± : Type u_1} (l : lists Œ±) : Prop
(Œ± : Type u_1) [partial_order Œ±] [decidable_eq Œ±] (finset_Icc : Œ± ‚Üí Œ± ‚Üí finset Œ±) (mem_Icc : ‚àÄ (a b x : Œ±), x ‚àà finset_Icc a b ‚Üî a ‚â§ x ‚àß x ‚â§ b) : locally_finite_order Œ±
{Œ± : Type u} [topological_space Œ±] [t2_space Œ±] (h : topological_space.is_topological_basis {s : set Œ± | is_clopen s}) : totally_separated_space Œ±
{Œ± : Type u_1} [topological_space Œ±] : galois_coinsertion subtype.val topological_space.opens.interior
(n : ‚Ñï) {K : Type u} [field K] (f : polynomial K) : f.nat_degree = n ‚Üí Type u
{Œ± : Type uu} (a : Œ±) {l‚ÇÅ l‚ÇÇ : list Œ±} : a :: l‚ÇÅ <+~ a :: l‚ÇÇ ‚Üí l‚ÇÅ <+~ l‚ÇÇ
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (A : C) [category_theory.closed A] : category_theory.monoidal_category.tensor_left A ‚ä£ category_theory.ihom A
{R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] {f : R ‚Üí+* S} {p : ideal R} : algebra (R ‚ß∏ p) (S ‚ß∏ ideal.map f p)
{C : Type u_1} [category_theory.category C] (X : C) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) {X : C} (S : category_theory.presieve X) {Y : D} (f : Y ‚ü∂ F.obj X) : Type (max u‚ÇÅ v‚ÇÅ v‚ÇÇ)
 : tactic.unify_equations.unification_step
{M : Type u_3} {F : Type u_8} {G : Type u_1} [group G] [monoid M] [monoid_hom_class F G M] {f g : F} {x : G} (h : ‚áëf x = ‚áëg x) : ‚áëf x‚Åª¬π = ‚áëg x‚Åª¬π
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} [compact_space Œ±] : metric.bounded s
(Œ± : Type u_6) (Œ≤ : Type u_7) [has_bot Œ±] [has_bot Œ≤] : Type (max u_6 u_7)
(R : Type u_1) (A : Type u_3) [comm_ring R] [ring A] [algebra R A] : Prop
{Œ± : Type u_2} [has_add Œ±] : has_add (filter Œ±)
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : set Œ±) : set Œ±
{G : Type u_1} [group G] (H : subgroup G) : subgroup G·µê·µí·µñ
{X : Type u_2} [emetric_space X] {m‚ÇÅ m‚ÇÇ : ennreal ‚Üí ennreal} (hle : m‚ÇÅ ‚â§·∂†[nhds_within 0 (set.Ici 0)] m‚ÇÇ) : measure_theory.outer_measure.mk_metric m‚ÇÅ ‚â§ measure_theory.outer_measure.mk_metric m‚ÇÇ
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : Type w) [category_theory.category J] (F : C ‚•§ D) [category_theory.limits.preserves_limits_of_shape J·µí·µñ F] : category_theory.limits.preserves_colimits_of_shape J F.op
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} {f : A ‚ü∂ B} [category_theory.limits.has_image f] {g : B ‚ü∂ C} [category_theory.limits.has_kernel g] (w : f ‚â´ g = 0) {A' B' C' : V} {f' : A' ‚ü∂ B'} [category_theory.limits.has_image f'] {g' : B' ‚ü∂ C'} [category_theory.limits.has_kernel g'] (w' : f' ‚â´ g' = 0) (Œ± : category_theory.arrow.mk f ‚ü∂ category_theory.arrow.mk f') [category_theory.limits.has_image_map Œ±] (Œ≤ : category_theory.arrow.mk g ‚ü∂ category_theory.arrow.mk g') (p : Œ±.right = Œ≤.left) : image_to_kernel f g w ‚â´ category_theory.limits.kernel_subobject_map Œ≤ = category_theory.limits.image_subobject_map Œ± ‚â´ image_to_kernel f' g' w'
{n : ‚Ñï} {Œ± : typevec n} (p : Œ±.arrow (typevec.repeat n Prop)) : (typevec.subtype_ p).arrow Œ±
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] {f g : P1 ‚Üí·µÉ[k] P2} (h : ‚àÄ (p : P1), ‚áëf p = ‚áëg p) : f = g
(Œ± : Type u_1) : Type u_1
(p : Prop) : Type
 : BoundedLattice ‚âå BoundedLattice
{G : Type u_1} [add_group G] {H : add_subgroup G} : has_scalar ‚Ñï ‚Ü•H
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] {a b : Œ±} : ¬¨a < b ‚Üí finset.Ioc a b = ‚àÖ
(es vs : list expr) : list expr
(obj : Type u) : Type (max u (v+1))
{Œ± : Type u} {Œ≤ : Type v} (l : filter Œ±) (f g : Œ± ‚Üí Œ≤) : Prop
{E : Type u_1} [normed_group E] {f : ‚ÑÇ ‚Üí E} {c : ‚ÑÇ} {R : ‚Ñù} [normed_space ‚ÑÇ E] (hf : circle_integrable f c R) : interval_integrable (Œª (Œ∏ : ‚Ñù), deriv (circle_map c R) Œ∏ ‚Ä¢ f (circle_map c R Œ∏)) measure_theory.measure_space.volume 0 (2 * real.pi)
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : Œ± ‚âÉ Œ≤) : free_group Œ± ‚âÉ* free_group Œ≤
{Œ± : Type u_1} (c : set (set Œ±)) (hc : setoid.is_partition c) : (setoid.mk_classes c _).classes = c
 : ‚Ü•(set.Ioo (-(real.pi / 2)) (real.pi / 2)) ‚âÉo ‚Ñù
 : CompleteLattice ‚•§ CompleteLattice
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} (G : C ‚•§ D) {t : category_theory.limits.cocone F} : (G.map_cocone t).op ‚âÖ G.op.map_cone t.op
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a b c : Œ±} : b < a‚Åª¬π * c ‚Üí a * b < c
{Œ± : Type u_1} {s t : set Œ±} : disjoint s t ‚Üí disjoint (filter.principal s) (filter.principal t)
{Œ± : Type u_1} {l : list Œ±} : l <+: list.nil ‚Üí l = list.nil
{R : Type u_1} [comm_ring R] {M : Type u_2} [topological_space M] [add_comm_group M] [module R M] (A : M ‚ÜíL[R] M) : R
(cond tgt : expr) : tactic (expr √ó expr)
{Œ± : Type u_1} [preorder Œ±] [succ_order Œ±] : Œ± ‚Üí Œ±
{Œ± : Type u} : lazy_list Œ± ‚Üí thunk (lazy_list Œ±) ‚Üí lazy_list Œ±
{Œπ : Type u_1} (l : box_integral.integration_params) (r : (Œπ ‚Üí ‚Ñù) ‚Üí ‚Ü•(set.Ioi 0)) : Prop
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_comm_monoid N] {f g : Œ± ‚Üí‚ÇÄ M} {h : Œ± ‚Üí M ‚Üí N} (h_zero : ‚àÄ (a : Œ±), a ‚àà f.support ‚à™ g.support ‚Üí h a 0 = 0) (h_add : ‚àÄ (a : Œ±), a ‚àà f.support ‚à™ g.support ‚Üí ‚àÄ (b‚ÇÅ b‚ÇÇ : M), h a (b‚ÇÅ + b‚ÇÇ) = h a b‚ÇÅ + h a b‚ÇÇ) : (f + g).sum h = f.sum h + g.sum h
(Œ± : Type u) [semiring Œ±] [nontrivial Œ±] : ‚àÉ (M : ideal Œ±), M.is_maximal
{Œ± : Type u_1} {Œπ : Sort u_4} [complete_lattice Œ±] {b : Œ±} {f : Œπ ‚Üí Œ±} (h‚ÇÅ : ‚àÄ (i : Œπ), b ‚â§ f i) (h‚ÇÇ : ‚àÄ (w : Œ±), b < w ‚Üí (‚àÉ (i : Œπ), f i < w)) : (‚®Ö (i : Œπ), f i) = b
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_3} [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] : normed_group_hom V‚ÇÅ V‚ÇÇ ‚Üí+ V‚ÇÅ ‚Üí V‚ÇÇ
(X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] : set (prod_space_fun X Y)
(x : ‚Ñù) : 0 < real.cosh x
{n p : ‚Ñï} (hp : nat.prime p) : multiplicity p (p * (n + 1)).factorial = multiplicity p (p * n).factorial + multiplicity p (n + 1) + 1
 : omega.eqelim unit
(R : Type u) [comm_ring R] (r : R) : is_localization.away r ‚Ü•((algebraic_geometry.Spec.structure_sheaf R).val.obj (opposite.op (prime_spectrum.basic_open r)))
(Œ± : Type u_1) [preorder Œ±] : (fin 2 ‚Üí Œ±) ‚âÉo Œ± √ó Œ±
{R : Type u} [ring R] {J : Type w} [category_theory.category J] (F : J ‚•§ Module R) (s : category_theory.limits.cocone F) : Module.colimits.colimit F ‚ü∂ s.X
(Œ± : Type u) [topological_space Œ±] : measurable_space Œ±
{ùïÇ : Type u_1} [nondiscrete_normed_field ùïÇ] [complete_space ùïÇ] [char_zero ùïÇ] {x : ùïÇ} (hx : x ‚àà emetric.ball 0 (exp_series ùïÇ ùïÇ).radius) : has_deriv_at (exp ùïÇ) (exp ùïÇ x) x
{R : Type u_1} [mul_one_class R] : is_regular 1
{Œ± : Type u_1} {n : Type u_3} (A : matrix n n Œ±) : Prop
{ùïú : Type u} [nondiscrete_normed_field ùïú] {E : Type v} [normed_group E] [normed_space ùïú E] {F : Type w} [normed_group F] [normed_space ùïú F] [complete_space ùïú] [finite_dimensional ùïú E] [finite_dimensional ùïú F] (cond : finite_dimensional.finrank ùïú E = finite_dimensional.finrank ùïú F) : E ‚âÉL[ùïú] F
(Œ± : Type u) : Type u
{M : Type u_1} [add_zero_class M] (s : set M) : add_submonoid M
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (j j' : C) : C
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} [nontrivial k] {p : Œπ ‚Üí P} (ha : affine_independent k p) : function.injective p
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommGroup) : category_theory.limits.cocone F
{a b c : ‚Ñ§} (h : fermat_42 a b c) : ‚àÉ (a0 b0 c0 : ‚Ñ§), fermat_42.minimal a0 b0 c0 ‚àß a0 % 2 = 1 ‚àß 0 < c0
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] [preorder Œ±] [preorder Œ≤] [covariant_class Œ± Œ± has_add.add has_lt.lt] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {f g : Œ≤ ‚Üí Œ±} (hf : monotone f) (hg : strict_mono g) : strict_mono (Œª (x : Œ≤), f x + g x)
(p : ‚Ñï) [hp : fact (nat.prime p)] {n i j : ‚Ñï} (hi : i < n) (hj : j < p ^ (n - i)) : j - pnat_multiplicity p ‚ü®j + 1, _‚ü© + n = i + j + (n - i - pnat_multiplicity p ‚ü®j + 1, _‚ü©)
{n : ‚Ñï} (c : composition n) (j : fin n) : fin (c.blocks_fun (c.index j))
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) (hf : continuous f) (hf' : is_open_map f) (s : topological_space.compact_opens Œ±) : topological_space.compact_opens Œ≤
(C : Type u_1) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.preadditive C] [category_theory.monoidal_preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_cokernels C] [category_theory.limits.has_images C] [category_theory.limits.has_image_maps C] [category_theory.has_projective_resolutions C] (X Y : C) [category_theory.projective X] (n : ‚Ñï) : ((category_theory.Tor' C (n + 1)).obj X).obj Y ‚âÖ 0
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Z‚ÇÅ Z‚ÇÇ : C} (g‚ÇÅ : Z‚ÇÅ ‚ü∂ X‚ÇÅ) (g‚ÇÇ : Z‚ÇÅ ‚ü∂ X‚ÇÇ) (g‚ÇÉ : Z‚ÇÇ ‚ü∂ X‚ÇÇ) (g‚ÇÑ : Z‚ÇÇ ‚ü∂ X‚ÇÉ) [category_theory.limits.has_pushout g‚ÇÅ g‚ÇÇ] [category_theory.limits.has_pushout g‚ÇÉ g‚ÇÑ] [category_theory.limits.has_pushout (g‚ÇÉ ‚â´ category_theory.limits.pushout.inr) g‚ÇÑ] [category_theory.limits.has_pushout g‚ÇÅ (g‚ÇÇ ‚â´ category_theory.limits.pushout.inl)] : category_theory.limits.pushout (g‚ÇÉ ‚â´ category_theory.limits.pushout.inr) g‚ÇÑ ‚âÖ category_theory.limits.pushout g‚ÇÅ (g‚ÇÇ ‚â´ category_theory.limits.pushout.inl)
(x : ‚Ñù) : ‚Ñù
{M : Type u_1} {P : Type u_3} [has_add M] [has_add P] (f : M ‚Üí P) (h : ‚àÄ (x y : M), f (x + y) = f x + f y) : add_con M
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] {f : M ‚Üí+ N} (hf : function.surjective ‚áëf) : galois_insertion (add_submonoid.map f) (add_submonoid.comap f)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ‚Ñï} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : ‚Ñï} (h : fs.card = m + 1) (i : fin (m + 1)) : (s.face h).points i = s.points (‚áë(fs.order_emb_of_fin h) i)
(n : name) : bool
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {X : D} {Y : C} (U : category_theory.structured_arrow X F) (f : U.right ‚ü∂ Y) : U ‚ü∂ category_theory.structured_arrow.mk (U.hom ‚â´ F.map f)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (p : Œπ ‚Üí P) : (s.affine_combination p).linear = s.weighted_vsub p
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Ü™o Œ≤) : with_top Œ± ‚Ü™o with_top Œ≤
(ùïú : Type u_1) {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [has_scalar ùïú Œ≤] (s : set E) (f : E ‚Üí Œ≤) : Prop
{Œ± : Type u_1} {a : Œ±} {z : sym2 Œ±} (h : a ‚àà z) : Œ±
 : category_theory.limits.preserves_limits_of_size (category_theory.forget Mon)
{Œ± : Type u} (ls : list (list Œ±)) [decidable_eq Œ±] (x : Œ±) (hx : ‚àÄ (l : list Œ±), l ‚àà ls ‚Üí x ‚àâ l) (hls : ls ‚â† list.nil) : list.split_on x ([x].intercalate ls) = ls
 : computability.Œì' ‚Üí bool
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [add_comm_monoid Œ≤] [add_comm_monoid Œ≥] (g : Œ≤ ‚Üí+ Œ≥) (f : Œ± ‚Üí Œ≤) (s : finset Œ±) : ‚áëg (s.sum (Œª (x : Œ±), f x)) = s.sum (Œª (x : Œ±), ‚áëg (f x))
{Œ± : Type u} {Œ≤ : Type v} (g : Œ≤ ‚Üí Œ±) (f : Œ± ‚Üí Œ≤) (s : set Œ±) (t : set Œ≤) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {X‚ÇÅ‚ÇÅ X‚ÇÅ‚ÇÇ X‚ÇÇ‚ÇÅ X‚ÇÇ‚ÇÇ X‚ÇÉ‚ÇÅ X‚ÇÉ‚ÇÇ : C} {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÉ‚ÇÅ : X‚ÇÉ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÇ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ} {v‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÅ} {v‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÉ‚ÇÇ} (s : category_theory.is_pullback h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ) (t : category_theory.is_pullback h‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÇ h‚ÇÉ‚ÇÅ) : category_theory.is_pullback h‚ÇÅ‚ÇÅ (v‚ÇÅ‚ÇÅ ‚â´ v‚ÇÇ‚ÇÅ) (v‚ÇÅ‚ÇÇ ‚â´ v‚ÇÇ‚ÇÇ) h‚ÇÉ‚ÇÅ
{M‚ÇÄ : Type u_1} [monoid_with_zero M‚ÇÄ] [nontrivial M‚ÇÄ] (u : M‚ÇÄÀ£) : ‚Üëu ‚â† 0
{C : Type u} [category_theory.category C] (F : C ‚•§ C) : Type (max u v)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) : category_theory.limits.is_limit ((category_theory.forget‚ÇÇ AddCommGroup AddCommMon).map_cone (AddCommGroup.limit_cone F))
{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_one M] [has_one N] [has_one P] (hnp : one_hom N P) (hmn : one_hom M N) : one_hom M P
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X Y : C) : category_theory.monoidal_category.tensor_left (X ‚äó Y) ‚âÖ category_theory.monoidal_category.tensor_left Y ‚ãô category_theory.monoidal_category.tensor_left X
{C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] : category_theory.limits.has_binary_product Q P
{Œ± : Type u} (s : seq Œ±) (h : ‚àÉ (n : ‚Ñï), ¬¨‚Ü•((s.nth n).is_some)) : list Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D) [category_theory.limits.preserves_limits F] : category_theory.limits.preserves_colimits F.right_op
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] [add_monoid Œ≤] [has_lipschitz_add Œ≤] : has_add (bounded_continuous_function Œ± Œ≤)
 : Type (u+1)
 : (polynomial_functions unit_interval).topological_closure = ‚ä§
(X : Top) : topological_space.opens.map (ùüô X) ‚âÖ ùü≠ (topological_space.opens ‚Ü•X)
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ‚•§ D) {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.limits.preserves_finite_colimits F] [category_theory.epi g] (ex : category_theory.exact f g) : category_theory.exact (F.map f) (F.map g)
{Œ± : Type u} : fin 0 ‚Üí Œ±
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_5} {Œ¥ : Type u_7} (g : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (s : set Œ±) (t : set Œ≤) (u : set Œ≥) : set Œ¥
(Œ± : Type u_1) (Œ≤ : Type u_2) [has_le Œ±] [has_le Œ≤] : (Œ± ‚äï Œ≤)·µí·µà ‚âÉo Œ±·µí·µà ‚äï Œ≤·µí·µà
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) {p : P} (hr : ‚àÉ (r : ‚Ñù), ‚àÄ (i : fin (n + 1)), has_dist.dist (s.points i) p = r) : ‚Üë(‚áë(s.orthogonal_projection_span) p) = s.circumcenter
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} {a : P.A} {f : P.last.B a ‚Üí P.last.W} (g' : (P.drop.B a).arrow Œ±) (g : Œ† (j : P.last.B a), typevec.arrow (P.W_path (f j)) Œ±) : typevec.arrow (P.W_path (W_type.mk a f)) Œ±
{Œ± : Type u_1} {m n : ‚Ñï} (v : vector3 Œ± m) (w : vector3 Œ± n) : vector3 Œ± (n + m)
{k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k ‚Üí E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : f (‚áë(affine_map.line_map a b) r) < ‚áë(affine_map.line_map (f a) (f b)) r ‚Üî slope f a b < slope f (‚áë(affine_map.line_map a b) r) b
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (S : category_theory.presieve X) : {f // S f.hom} ‚•§ C
 : Type
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {F : J ‚•§ K ‚•§ C} (c : category_theory.limits.cone F) (t : Œ† (k : K), category_theory.limits.is_limit (((category_theory.evaluation K C).obj k).map_cone c)) : category_theory.limits.is_limit c
 : lean.parser tactic.eliminate.generalization_mode
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_mul Œ±] [has_add Œ±] [has_le Œ±] [has_mul Œ≤] [has_add Œ≤] [has_le Œ≤] (f : Œ± ‚âÉ+*o Œ≤) : Œ± ‚âÉo Œ≤
{Œ± : Type u} {Œ≤ : Type v} : (Œ± ‚Ü™ Œ≤) ‚Üí (Œ≤ ‚Ü™ Œ±) ‚Üí nonempty (Œ± ‚âÉ Œ≤)
(C : Type u) : ùü≠ (category_theory.free_monoidal_category C) ‚âÖ category_theory.free_monoidal_category.full_normalize C ‚ãô category_theory.free_monoidal_category.inclusion
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h2 : p2 ‚â† p1) (h3 : p3 ‚â† p1) : euclidean_geometry.angle p1 p2 p3 + euclidean_geometry.angle p2 p3 p1 + euclidean_geometry.angle p3 p1 p2 = real.pi
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) [H : decidable_rel s] : decidable_rel (f ‚Åª¬π'o s)
 : num ‚Üí num
{n : ‚Ñï} {Œ± : typevec (n + 1)} {Œ≤ : typevec (n + 1)} (f : Œ±.arrow Œ≤) : Œ±.last ‚Üí Œ≤.last
{G : Type u_6} {H : Type u_7} {F : Type u_8} [group G] [division_monoid H] [monoid_hom_class F G H] (f : F) (g : G) (n : ‚Ñ§) : ‚áëf (g ^ n) = ‚áëf g ^ n
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {n : Type w} [nontrivial R] [no_zero_divisors R] (B : bilin_form R M) (v : basis n R M) (hO : B.is_Ortho ‚áëv) : B.nondegenerate ‚Üî ‚àÄ (i : n), ¬¨B.is_ortho (‚áëv i) (‚áëv i)
{X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd
{Œ± : Type u_2} {Œ≤ : Type u_3} [comm_monoid Œ±] [comm_monoid Œ≤] (A : set Œ±) (n : ‚Ñï) (f : Œ± ‚Üí* Œ≤) : A ‚Üí*[n] Œ≤
{G‚ÇÅ : Type u_3} {G‚ÇÇ : Type u_4} {G‚ÇÉ : Type u_5} [add_group G‚ÇÅ] [add_group G‚ÇÇ] [add_group G‚ÇÉ] (f : G‚ÇÅ ‚Üí+ G‚ÇÇ) (f_inv : G‚ÇÇ ‚Üí G‚ÇÅ) (hf : function.right_inverse f_inv ‚áëf) (g : G‚ÇÅ ‚Üí+ G‚ÇÉ) (hg : f.ker ‚â§ g.ker) : G‚ÇÇ ‚Üí+ G‚ÇÉ
{Œ± : Type u} {Œ≤ : Type v} (f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ±) (start : ‚Ñï) (a : Œ±) (bs : list Œ≤) : Œ±
{R : Type u_1} {M : Type u_5} [comm_semiring R] [add_comm_monoid M] [module R M] (B : M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R) (f : module.End R M) : Prop
 : Pointed_to_Bipointed ‚ãô Bipointed_to_Pointed_snd ‚âÖ ùü≠ Pointed
{n : ‚Ñï} : is_prime_pow n ‚Üî ‚àÉ! (p : ‚Ñï), nat.prime p ‚àß p ‚à£ n
{C : Type u} [category_theory.category C] {X Y Z : C} {sXY : category_theory.limits.binary_fan X Y} (P : category_theory.limits.is_limit sXY) {sYZ : category_theory.limits.binary_fan Y Z} (s : category_theory.limits.binary_fan X sYZ.X) : category_theory.limits.binary_fan sXY.X Z
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_le Œ±] [has_le Œ≤] (e : Œ± ‚âÉo Œ≤) : Œ≤ ‚âÉo Œ±
{A : Type u_12} {B : Type u_13} [has_add A] [has_add B] (self : A ‚âÉ+ B) : add_hom A B
{Œ± : Type u} (x : Œ±) : function.is_fixed_pt id x
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {n : with_top ‚Ñï} : cont_diff ùïú n f ‚Üî has_ftaylor_series_up_to n f (ftaylor_series ùïú f)
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] [module.free R M] : M ‚âÉ‚Çó[R] module.free.choose_basis_index R M ‚Üí‚ÇÄ R
{Œ± : Type u_3} {Œ≤ : Type u_4} [lattice Œ±] [lattice Œ≤] [bounded_order Œ±] [bounded_order Œ≤] (f : bounded_lattice_hom Œ± Œ≤) : sup_bot_hom Œ± Œ≤
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) (m : M) : ‚áë(clifford_algebra.Œπ Q) m * ‚áë(clifford_algebra.Œπ Q) m = ‚áë(algebra_map R (clifford_algebra Q)) (‚áëQ m)
{Œ± : Type u_1} (t : tactic Œ±) : tactic Œ±
(ùïú : Type u_5) (E : Type u_6) [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [nontrivial E] : noncompact_space E
{ùïú : Type u} {Œπ : Type v} {E : Œπ ‚Üí Type wE} {G : Type wG} [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] [normed_group G] [normed_space ùïú G] : continuous (Œª (p : continuous_multilinear_map ùïú E G √ó Œ† (i : Œπ), E i), ‚áë(p.fst) p.snd)
(ùïú : Type u_1) {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] (s : set E) (f : E ‚Üí Œ≤) : Prop
(G : Type u_1) [division_monoid G] : G ‚âÉ* G·µê·µí·µñ
{G : Type u_1} [add_comm_monoid G] (tG : add_monoid.is_torsion G) : ‚Ü•(add_comm_monoid.add_torsion G) ‚âÉ+ G
{G : Type u_1} [add_comm_monoid G] (tG : add_monoid.is_torsion G) : add_comm_monoid.add_torsion G = ‚ä§
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] (K‚ÇÄ : topological_space.positive_compacts G) : (measure_theory.measure.haar_measure K‚ÇÄ).is_haar_measure
{M : Type u_1} [has_add M] {c d : add_con M} (H : ‚àÄ (x y : M), ‚áëc x y ‚Üî ‚áëd x y) : c = d
{C : Type u} [category_theory.category C] {X : Top} (‚Ñ± : Top.presheaf C X) {Y Z : Top} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : (f ‚â´ g) _* ‚Ñ± ‚âÖ g _* (f _* ‚Ñ±)
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] : A √ó B ‚Üí‚Çê[R] A
 : ‚Ñï ‚Üí snum ‚Üí bool
{R‚ÇÅ : Type u_3} {A : Type u_5} {B : Type u_6} [comm_semiring R‚ÇÅ] [comm_ring A] [comm_ring B] [algebra R‚ÇÅ A] [algebra R‚ÇÅ B] {f : A ‚Üí‚Çê[R‚ÇÅ] B} {g : B ‚Üí A} (hf : function.right_inverse g ‚áëf) : (A ‚ß∏ f.to_ring_hom.ker) ‚âÉ‚Çê[R‚ÇÅ] B
{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L} : ‚áë(algebra.norm K) x = 0 ‚Üî x = 0
{Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (n : ‚Ñï) (x : Œ±) : Prop
{x : ‚Ñù} (h : 0 < x) (h' : x ‚â§ 1) : x - x ^ 3 / 4 < real.sin x
{Œ≥ : Type w} [metric_space Œ≥] {x y : Œ≥} : has_nndist.nndist x y = 0 ‚Üî x = y
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} {M‚ÇÉ : Type v‚ÇÉ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [module R M‚ÇÉ] (f : multilinear_map R M‚ÇÅ M‚ÇÇ) (g : multilinear_map R M‚ÇÅ M‚ÇÉ) : multilinear_map R M‚ÇÅ (M‚ÇÇ √ó M‚ÇÉ)
{K : Type u} [field K] (s : subfield K) (m : multiset K) : (‚àÄ (a : K), a ‚àà m ‚Üí a ‚àà s) ‚Üí m.prod ‚àà s
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X Y : C} {f : X ‚ü∂ Y} (h : f = 0) [category_theory.limits.has_image f] : category_theory.limits.image f ‚âÖ 0
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [add_monoid Y] [has_continuous_add Y] : locally_constant X Y ‚Üí+ C(X, Y)
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] (f : C(X, Y)) (S : set X) : f.homotopy_rel f S
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A ‚ü∂ B) [category_theory.limits.has_image f] (g : B ‚ü∂ C) [category_theory.limits.has_kernel g] (w : f ‚â´ g = 0) [category_theory.limits.has_cokernel (image_to_kernel f g w)] {D : V} (k : ‚Üë(category_theory.limits.kernel_subobject g) ‚ü∂ D) (p : image_to_kernel f g w ‚â´ k = 0) : homology f g w ‚ü∂ D
{T : Type u‚ÇÅ} [category_theory.category T] {X : T} {f g : category_theory.over X} (k : f ‚ü∂ g) [category_theory.mono k] : category_theory.mono k.left
{Œ± : Type u_1} (m : Œ± ‚Üí Œ± ‚Üí Œ±) : list Œ± ‚Üí list Œ± ‚Üí list Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_terminal C] [category_theory.limits.preserves_limit (category_theory.functor.empty C) G] : category_theory.limits.has_terminal D
(ùïú : Type u_1) {E : Type u_2} [semi_normed_ring ùïú] [has_scalar ùïú E] (s : set E) : set E
{C D : Type u‚ÇÅ} [category_theory.small_category C] [category_theory.small_category D] [category_theory.limits.has_finite_limits C] (F : C ‚•§ D) : category_theory.limits.preserves_finite_limits F ‚âÉ category_theory.limits.preserves_finite_limits (category_theory.Lan F.op)
(R : Type u_1) (M : Type u_2) (N : Type u_3) [comm_ring R] [add_comm_group M] [add_comm_group N] [module R M] [module R N] [module.finite R M] [module.finite R N] [module.free R M] [module.free R N] [nontrivial R] : tensor_product R (module.dual R M) (module.dual R N) ‚âÉ‚Çó[R] module.dual R (tensor_product R M N)
{R : Type u_1} [semiring R] : algebra ‚Ñï R
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b : Œ±} : 0 < a - b ‚Üí b < a
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddGroup) : category_theory.limits.is_limit (AddGroup.limit_cone F)
(p : ‚Ñï) [fact (nat.prime p)] (a : ‚Ñ§) (ha : ‚Üëa ‚â† 0) : zmod.legendre_sym p (a ^ 2) = 1
{L : first_order.language} {M : Type u_3} {N : Type u_4} [L.Structure M] [L.Structure N] (f : L.elementary_embedding M N) : L.hom M N
(R : Type u_1) (M : Type u_9) [semiring R] [add_comm_monoid M] [module R M] {m : Type u_20} {n : Type u_21} (e : m ‚âÉ n) : (n ‚Üí M) ‚âÉ‚Çó[R] m ‚Üí M
{Œπ : Type u} {Œ± : Type v} (t : Œπ ‚Üí finset Œ±) (Œπ' : finset Œπ) : set (‚Ü•Œπ' ‚Üí Œ±)
 : computability.fin_encoding ‚Ñï
{Œ± : Type u} (S T : set Œ±) : cardinal.mk ‚Ü•(S ‚à™ T) ‚â§ cardinal.mk ‚Ü•S + cardinal.mk ‚Ü•T
(Œ± : Type u_2) [cancel_comm_monoid_with_zero Œ±] : Prop
(o : ordinal) : Well_order
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [comm_ring Œ≤] : comm_ring Œ±
{Œ± : Type u_1} (l : list Œ±) : list (list Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type w} [category_theory.category J] {K : J ‚•§ C} (c : category_theory.limits.cone (K ‚ãô ùü≠ C)) : inhabited (category_theory.liftable_cone K (ùü≠ C) c)
 : omega.eqelim (list omega.term)
{F : pfunctor} {n : ‚Ñï} : pfunctor.approx.cofix_a F n ‚Üí pfunctor.approx.cofix_a F (n + 1) ‚Üí Prop
{Œπ : Type u} (s : finset Œπ) (f g : Œπ ‚Üí nnreal) {p q : ‚Ñù} (hpq : p.is_conjugate_exponent q) : s.sum (Œª (i : Œπ), f i * g i) ‚â§ s.sum (Œª (i : Œπ), f i ^ p) ^ (1 / p) * s.sum (Œª (i : Œπ), g i ^ q) ^ (1 / q)
{R : Type u} [comm_ring R] {P : ideal R} (H : P.is_prime) : is_domain (polynomial R ‚ß∏ ideal.map polynomial.C P)
(ùïú : Type u_3) (E : Type u_4) [normed_field ùïú] [semi_normed_group E] [normed_space ùïú E] : seminorm ùïú E
(G : Type u_1) [monoid G] (L : Type u_2) [comm_ring L] [no_zero_divisors L] : linear_independent L (Œª (f : G ‚Üí* L), ‚áëf)
 : user_attribute unit (bool √ó list string √ó simps_cfg)
{C : Type u} [category_theory.category C] {X Y X' Y' : C} (f g : X ‚ü∂ Y) (f' g' : X' ‚ü∂ Y') (p : X ‚ü∂ X') (q : Y ‚ü∂ Y') (wf : f ‚â´ q = p ‚â´ f') (wg : g ‚â´ q = p ‚â´ g') : category_theory.limits.parallel_pair f g ‚ü∂ category_theory.limits.parallel_pair f' g'
{R : Type u_1} [semiring R] {m : Type u_3} {n : Type u_4} [fintype m] (M : matrix m n R) : (m ‚Üí R) ‚Üí‚Çó[R] n ‚Üí R
 : ‚Ñù*
{Œ± : Type u} {s : set Œ±} : s.countable ‚Üí {t : set Œ± | t.finite ‚àß t ‚äÜ s}.countable
{Œ± : Type u_1} [decidable_eq Œ±] (s t : multiset Œ±) : multiset Œ±
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) : Mon.colimits.prequotient F ‚Üí Mon.colimits.prequotient F ‚Üí Prop
(p : ‚Ñï) {R : Type u_1} [comm_ring R] (r : R) : witt_vector p R
{R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Œπ : Type u_1} (b : basis Œπ R M) {Œ∫ : Type u_1} (v : Œ∫ ‚Üí M) (i : linear_independent R v) : cardinal.mk Œ∫ ‚â§ cardinal.mk Œπ
(C : Type u) [category_theory.category C] : Type (max u (v+1))
{R : Type u} [euclidean_domain R] [decidable_eq R] : R ‚Üí R ‚Üí R
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) [invertible A] : ‚Öü A = A‚Åª¬π
{C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (hu : category_theory.cover_lifting J K G) (‚Ñ± : category_theory.Sheaf J A) {X : A} {U : D} {S : category_theory.sieve U} (hS : S ‚àà ‚áëK U) {x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj ‚Ñ±.val ‚ãô category_theory.coyoneda.obj (opposite.op X)) S.arrows} (hx : x.compatible) : x.is_amalgamation (category_theory.Ran_is_sheaf_of_cover_lifting.glued_section hu ‚Ñ± hS hx)
(R : Type u_1) [comm_ring R] (M : Type u_2) [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [nontrivial R] : linear_map.trace R M = (contract_left R M).comp (dual_tensor_hom_equiv R M M).symm.to_linear_map
(Œ± : Type u_1) : local_equiv Œ± Œ±
{P : Type u_1} [preorder P] {F : set P} (h : order.is_pfilter F) : order.pfilter P
{ùí™ : Type u} {K : Type v} {Œì : Type w} [comm_ring ùí™] [is_domain ùí™] [field K] [algebra ùí™ K] [linear_ordered_comm_group_with_zero Œì] (v : valuation K Œì) (hh : v.integers ùí™) : valuation_ring ùí™
{Œπ : Type u_1} {I‚ÇÄ : with_top (box_integral.box Œπ)} {E : Type u_4} [normed_group E] [normed_space ‚Ñù E] (f : box_integral.box_additive_map Œπ ‚Ñù I‚ÇÄ) : box_integral.box_additive_map Œπ (E ‚ÜíL[‚Ñù] E) I‚ÇÄ
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (A B : C) [category_theory.limits.has_binary_product A B] [category_theory.limits.has_binary_product (F.obj A) (F.obj B)] : F.obj (A ‚®Ø B) ‚ü∂ F.obj A ‚®Ø F.obj B
{Œ± : Type} (p : parser Œ±) : Prop
(tm : turing.fin_tm2) : tm.cfg ‚Üí option tm.cfg
{Œ± : Type u_1} [nontrivial Œ±] : nonempty Œ±
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] (D : Type u‚ÇÇ) [category_theory.category D] [category_theory.monoidal_category D] : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
(S : Type u_4) (M : out_param (Type u_5)) [has_zero M] [set_like S M] : Type
{X : Type u_1} [normed_group X] [normed_space ‚Ñù X] : structure_groupoid X
(cfg : linarith.linarith_config) (ls : list (list expr)) : tactic expr
(x y : pgame) : (-(x + y)).relabelling (-x + -y)
(p : linarith.pcomp) : bool
{Œ± : Type u_2} {Œ≤ : Type u_3} [complete_lattice Œ±] [complete_lattice Œ≤] : has_coe_to_fun (complete_lattice_hom Œ± Œ≤) (Œª (_x : complete_lattice_hom Œ± Œ≤), Œ± ‚Üí Œ≤)
{Œ≤ : Type u} {Œ± : Type v} [add_comm_monoid Œ≤] [decidable_eq Œ±] (s : finset Œ±) (f : Œ± ‚Üí Œ≤) {a : Œ±} (h : a ‚àà s) : (s.erase a).sum (Œª (x : Œ±), f x) + f a = s.sum (Œª (x : Œ±), f x)
(tac : tactic.interactive.itactic) : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [primcodable Œ±] [primcodable Œ≤] (e : Œ± ‚âÉ Œ≤) : Prop
{n : ‚Ñï} (x : bitvec n) (i : ‚Ñï) (fill : bool) : bitvec n
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà ‚àÖ), f i)) = 1
{Œ± : Type u_1} {n : Type u_3} [decidable_eq n] [has_zero Œ±] (v : n ‚Üí Œ±) : (matrix.diagonal v).is_symm
{F : Type u_1} [field F] (p : polynomial F) (h : polynomial.splits (ring_hom.id F) p) : unique p.gal
{Œπ : Type u_1} (G : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), group (G i)] [hG : Œ† (i : Œπ), is_free_group (G i)] : is_free_group (free_product G)
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] (f : L.embedding M N) : L.equiv M ‚Ü•(f.to_hom.range)
(M : Type u) [monoid M] : MÀ£ ‚Üí* M
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {s : set E} {f : E ‚Üí F} {n : with_top ‚Ñï} (e : G ‚âÉL[ùïú] E) : cont_diff_on ùïú n (f ‚àò ‚áëe) (‚áëe ‚Åª¬π' s) ‚Üî cont_diff_on ùïú n f s
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [‚àÄ (i : ùí∞.J), category_theory.limits.has_pullback (ùí∞.map i ‚â´ f) g] (i j : ùí∞.J) : category_theory.limits.pullback category_theory.limits.pullback.fst ((algebraic_geometry.Scheme.pullback.gluing ùí∞ f g).Œπ j) ‚ü∂ algebraic_geometry.Scheme.pullback.V ùí∞ f g j i
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {Œπ : Type u_1} {c : complex_shape Œπ} {T : Type u_2} [category_theory.category T] : homological_complex (T ‚•§ V) c ‚•§ T ‚•§ homological_complex V c
{Œ± : Type u_1} {Œπ : Sort u_4} {l : filter Œ±} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí set Œ±} (h : l.has_basis p s) {V : set Œ±} (hV : V ‚àà l) : l.has_basis (Œª (i : Œπ), p i ‚àß s i ‚äÜ V) s
{M : Type u_1} [add_monoid M] {s : set M} (h : is_add_submonoid s) : add_submonoid M
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : is_compact s ‚Üî ‚àÄ {Œπ : Type u} (Z : Œπ ‚Üí set Œ±), (‚àÄ (i : Œπ), is_closed (Z i)) ‚Üí (s ‚à© ‚ãÇ (i : Œπ), Z i) = ‚àÖ ‚Üí (‚àÉ (t : finset Œπ), (s ‚à© ‚ãÇ (i : Œπ) (H : i ‚àà t), Z i) = ‚àÖ)
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] {X : C} {P : C·µí·µñ ‚•§ D} {S : J.cover X} (x : category_theory.meq P S) : ‚Ü•((J.plus_obj P).obj (opposite.op X))
{Œ± : Type u} [linear_ordered_field Œ±] [topological_space Œ±] [order_topology Œ±] : filter.tendsto (Œª (x : Œ±), x‚Åª¬π) (nhds_within 0 (set.Ioi 0)) filter.at_top
(R : Type u) (n : ‚Ñï) [comm_semiring R] (A : Type u_1) [semiring A] [algebra R A] : multilinear_map R (Œª (i : fin n), A) A
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ‚Ñù P) : t.orthocenter = affine.simplex.monge_point t
(Œ± : Type u) : Type u
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {g : Œ≤ ‚Üí Œ≥} (hg : function.injective g) : function.injective (function.comp g)
(ic : tactic.instance_cache) : expr ‚Üí ‚Ñö ‚Üí tactic (tactic.instance_cache √ó expr)
(o : ordinal) : o.to_pgame.numeric
 : tactic tactic_state
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} {p : filter Œπ} {g : Œπ ‚Üí Œ±} [topological_space Œ±] (h : tendsto_uniformly_on F f p s) (hf : continuous_within_at f s x) (hg : filter.tendsto g p (nhds_within x s)) : filter.tendsto (Œª (n : Œπ), F n (g n)) p (nhds (f x))
{V : Type u} {G : simple_graph V} {Œ± : Type v} (C : G.coloring Œ±) (c : Œ±) : set V
{J : Type v} [category_theory.small_category J] {A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] {L : A ‚•§ T} {R : B ‚•§ T} (F : J ‚•§ category_theory.comma L R) (c‚ÇÇ : category_theory.limits.cocone (F ‚ãô category_theory.comma.snd L R)) : category_theory.limits.cocone ((F ‚ãô category_theory.comma.fst L R) ‚ãô L)
{a b : ‚Ñù} {g' g : ‚Ñù ‚Üí ‚Ñù} (hab : a ‚â§ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí has_deriv_at g (g' x) x) (g'pos : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí 0 ‚â§ g' x) : measure_theory.integrable_on g' (set.Ioc a b) measure_theory.measure_space.volume
{p : ‚Ñï} {R : Type u_1} {S : Type u_2} [hp : fact (nat.prime p)] [comm_ring R] [comm_ring S] (f : R ‚Üí+* S) : witt_vector p R ‚Üí+* witt_vector p S
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} (f : J ‚Üí (X ‚ü∂ Y)) [category_theory.limits.has_wide_coequalizer f] : Y ‚ü∂ category_theory.limits.wide_coequalizer f
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) : (s.circumcenter_circumradius.fst ‚àà affine_span ‚Ñù (set.range s.points) ‚àß ‚àÄ (i : fin (n + 1)), has_dist.dist (s.points i) s.circumcenter_circumradius.fst = s.circumcenter_circumradius.snd) ‚àß ‚àÄ (cccr : P √ó ‚Ñù), (cccr.fst ‚àà affine_span ‚Ñù (set.range s.points) ‚àß ‚àÄ (i : fin (n + 1)), has_dist.dist (s.points i) cccr.fst = cccr.snd) ‚Üí cccr = s.circumcenter_circumradius
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} (h_mono : strict_mono_on f s) (hs : s ‚àà nhds_within a (set.Iic a)) (hfs : ‚àÄ (b : Œ≤), b < f a ‚Üí (‚àÉ (c : Œ±) (H : c ‚àà s), f c ‚àà set.Ico b (f a))) : continuous_within_at f (set.Iic a) a
(t : smt_tactic.interactive.itactic) : smt_tactic unit
(A : Type u_1) (B : Type u_2) [field A] [ring B] [algebra A B] [nontrivial B] : minpoly A 0 = polynomial.X
{Œ± : Type u_1} [inhabited Œ±] : option Œ± ‚Üí Œ±
 : expr ‚Üí tactic unit
{G : Type u_1} [group G] {Œπ : Sort u_2} (S : Œπ ‚Üí subgroup G) {C : Œ† (x : G), (x ‚àà ‚®Ü (i : Œπ), S i) ‚Üí Prop} (hp : ‚àÄ (i : Œπ) (x : G) (H : x ‚àà S i), C x _) (h1 : C 1 _) (hmul : ‚àÄ (x y : G) (hx : x ‚àà ‚®Ü (i : Œπ), S i) (hy : y ‚àà ‚®Ü (i : Œπ), S i), C x hx ‚Üí C y hy ‚Üí C (x * y) _) {x : G} (hx : x ‚àà ‚®Ü (i : Œπ), S i) : C x hx
 : has_sizeof ‚Ñ§
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} {R‚ÇÉ : Type u_3} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [semiring R‚ÇÉ] (œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ) (œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ) (œÉ‚ÇÅ‚ÇÉ : out_param (R‚ÇÅ ‚Üí+* R‚ÇÉ)) : Prop
(x : ‚Ñù) : real.arsinh (real.sinh x) = x
(n : ‚Ñï) {a : ‚Ñù} (h : 2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ‚â§ real.sqrt_two_add_series (‚Üë0 / ‚Üë1) n) (h‚ÇÇ : 1 / 4 ^ n ‚â§ a) : real.pi < a
 : linter
{Œ± : Sort u} {Œ≤ : Sort v} {f : Œ± ‚Üí Œ≤} (hf : function.injective f) [subsingleton Œ≤] : subsingleton Œ±
{X : Type u_1} : free_abelian_group X ‚Üí+ X ‚Üí‚ÇÄ ‚Ñ§
{Œ± : Type u_2} [decidable_eq Œ±] [has_mul Œ±] : Œ± ‚Üí‚Çô* finset Œ±
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] {p : P} (hp : p ‚àâ s) : has_dist.dist p ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p) ‚â† 0
(P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop) (ha : ‚àÄ (a : ‚Ñï), P (a + 1) (a + 1)) (hb : ‚àÄ (b : ‚Ñï), P 0 (b + 1)) (hd : ‚àÄ (a b : ‚Ñï), a < b ‚Üí P (a + 1) b ‚Üí P a (b + 1) ‚Üí P (a + 1) (b + 1)) (a b : ‚Ñï) : a < b ‚Üí P a b
 : tactic.eliminate.constructor_argument_naming_rule
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (Œª (_x : P), _x -·µ• p)
(red : tactic.transparency) (pfs : list expr) : tactic (list linarith.comp √ó ‚Ñï)
(Œ± : Type u_1) [r : comm_ring Œ±] [uniform_space Œ±] [uniform_add_group Œ±] [topological_ring Œ±] : quotient (uniform_space.separation_setoid Œ±) ‚âÉ Œ± ‚ß∏ ‚ä•.closure
{n : ‚Ñï} {Œ± : Type u} {Œ≤ : Type v} {m : Type v ‚Üí Type w} [monad m] (a : array n Œ±) (f : Œ± ‚Üí m Œ≤) (i : ‚Ñï) (H : i ‚â§ n) : m (array i Œ≤)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F G : J ‚•§ C} (H : C ‚•§ D) {Œ± : F ‚âÖ G} {c : category_theory.limits.cone F} : H.map_cone ((category_theory.limits.cones.postcompose_equivalence Œ±).functor.obj c) ‚âÖ (category_theory.limits.cones.postcompose_equivalence (category_theory.iso_whisker_right Œ± H)).functor.obj (H.map_cone c)
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] [fintype Œ≤] [decidable_eq Œ±] [decidable_eq Œ≤] (h : fintype.card Œ± = fintype.card Œ≤) : trunc (Œ± ‚âÉ Œ≤)
{G : Type u_1} [group G] [hG : group.is_nilpotent G] : nat.find _ = group.nilpotency_class G
{Œ± : Type u} {Œ≤ : Type v} (a : ulift Œ±) (f : Œ± ‚Üí ulift Œ≤) : ulift Œ≤
{n : ‚Ñï} (m : ‚Ñï) : fin n ‚Ü™o fin (n + m)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} {p : Œπ ‚Üí P} (ha : affine_independent k p) : affine_independent k (Œª (x : ‚Ü•(set.range p)), ‚Üëx)
{Œ± : Type u_1} [preorder Œ±] {a b : Œ±} (h : a < b) : ¬¨is_max a
{Œ± : Type u} : Œ± ‚Üí lazy_list Œ±
(X : algebraic_geometry.LocallyRingedSpace) : X.to_SheafedSpace ‚ü∂ algebraic_geometry.Spec.to_SheafedSpace.obj (opposite.op (algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X)))
 : tactic unit
 : expr ‚Üí tactic.unsafe.type_context (option expr)
(p : Prop) : Type
{R : Type u_1} [non_unital_non_assoc_semiring R] (r : R) : R ‚Üí+ R
{Œ± : Type u} (S : set (Œ± ‚Üí ‚Ñï)) : Prop
(a b : expr) : tactic expr
{A : Type u_1} (K : Type u_2) [comm_ring A] (S : submonoid A) (hS : S ‚â§ non_zero_divisors A) [field K] [algebra A K] [is_fraction_ring A K] : subalgebra A K
{Œ± : Type u} (s : stream Œ±) : stream Œ±
{Œ± : Type u} {Œ≤ : Type v} [add_zero_class Œ±] [mul_one_class Œ≤] : (multiplicative Œ± ‚Üí* Œ≤) ‚âÉ (Œ± ‚Üí+ additive Œ≤)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} {g : ‚Ñù ‚Üí E} (fdiff : differentiable_on ‚Ñù f (set.Icc a b)) (gdiff : differentiable_on ‚Ñù g (set.Icc a b)) (hderiv : set.eq_on (deriv_within f (set.Icc a b)) (deriv_within g (set.Icc a b)) (set.Ico a b)) (hi : f a = g a) (y : ‚Ñù) (H : y ‚àà set.Icc a b) : f y = g y
(Œ± : Type u) [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] : Œ± ‚âÉo Œ±·µí·µà
{Œ± : Type u} [topological_space Œ±] {J : Type u} (U : J ‚Üí topological_space.opens Œ±) (h : (‚ãÉ (i : J), ‚Üë(U i)) = set.univ) : ‚Ü•((Top.glue_data.of_open_subsets U).to_glue_data.glued) ‚âÉ‚Çú Œ±
(ùïú : Type u_3) (E : Type u_4) [semi_normed_ring ùïú] [add_monoid E] [has_scalar ùïú E] : seminorm ùïú E ‚Üí+ E ‚Üí ‚Ñù
(Œ± : Type u_1) [distrib_lattice Œ±] : DistribLattice
(tac : smt_tactic unit) : smt_tactic unit
 : expr ‚Üí list level
{C : Type u‚ÇÅ} [category_theory.category C] {X : C·µí·µñ} (t : category_theory.limits.is_initial X) : category_theory.limits.is_terminal (opposite.unop X)
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (e : M ‚âÉ+ N) (S : add_subsemigroup M) : ‚Ü•S ‚âÉ+ ‚Ü•(add_subsemigroup.map e.to_add_hom S)
(G : Type u) [topological_space G] [has_inv G] : Prop
{Œ± : Type u_3} {Œ≤ : Type u_4} [has_sup Œ±] [has_bot Œ±] [has_sup Œ≤] [has_bot Œ≤] : sup_bot_hom Œ± Œ≤ ‚âÉ inf_top_hom Œ±·µí·µà Œ≤·µí·µà
{G : Type u_7} [group G] (L : list G) : (L.prod)‚Åª¬π = (list.map (Œª (x : G), x‚Åª¬π) L).reverse.prod
{Œ± : Type u} [semilattice_sup Œ±] {P : Œ± ‚Üí Prop} (Psup : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, P x ‚Üí P y ‚Üí P (x ‚äî y)) : semilattice_sup {x // P x}
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {m : measurable_space Œ±} [topological_space Œ≤] [topological_space.pseudo_metrizable_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] : measure_theory.strongly_measurable f ‚Üî measurable f ‚àß topological_space.is_separable (set.range f)
{Œπ : Type u} (Œ≤ : Œπ ‚Üí Type v) [dec : decidable_eq Œπ] [Œ† (i : Œπ), add_zero_class (Œ≤ i)] (i : Œπ) : (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚Üí+ Œ†‚ÇÄ (i : Œπ), Œ≤ i
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) [complete_space ‚Ü•K] : E ‚ÜíL[ùïú] ‚Ü•K
{R : Type u} [comm_ring R] (f : polynomial R) : R ‚Üí+* adjoin_root f
(Œ± : Type u_1) : Type u_1
(z : ‚ÑÇ) : ‚ÑÇ
{n : ‚Ñï} : order_of (quaternion_group.a 1) = 2 * n
{Œ± : Type u_1} [monoid Œ±] (s : multiset Œ±) (comm : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí commute x y) : Œ±
{Œ± : Type u_1} [topological_space Œ±] {x : Œ±} {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : upper_semicontinuous_at f x) (hg : upper_semicontinuous_at g x) (hcont : continuous_at (Œª (p : Œ≥ √ó Œ≥), p.fst + p.snd) (f x, g x)) : upper_semicontinuous_at (Œª (z : Œ±), f z + g z) x
{Œ± : Type} (mx : tactic.ring_exp.ring_exp_m Œ±) : tactic.ring_exp.ring_exp_m Œ±
{C : Type u} [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} (F : category_theory.limits.strong_epi_mono_factorisation f) : category_theory.limits.is_image F.to_mono_factorisation
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (X Y : C) : Type v‚ÇÅ
{Œ≥ : Type} (local_c : widget.tc widget.local_collection Œ≥) (target_c : widget.tc expr Œ≥) : widget.tc widget.filter_type Œ≥
(F : Type u_8) (Œ± : out_param (Type u_9)) (Œ≤ : out_param (Type u_10)) [complete_lattice Œ±] [complete_lattice Œ≤] : Type (max u_10 u_8 u_9)
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] (F : A ‚•§ B) : F ‚ãô ùü≠ B ‚âÖ F
{R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R ‚Üí+* P} (hg : ‚àÄ (y : ‚Ü•M), is_unit (‚áëg ‚Üëy)) (x : R) (y : ‚Ü•M) : ‚áë(is_localization.lift hg) (is_localization.mk' S x y) = ‚áëg x * ‚Üë(‚áë(is_unit.lift_right (g.to_monoid_hom.restrict M) hg) y)‚Åª¬π
{Œ± : Sort u_1} {a : Œ±} : Œ±
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] {f : ‚ÑÇ ‚Üí E} (hd : diff_cont_on_cl ‚ÑÇ f (set.Iio 0 √ó‚ÑÇ set.Iio 0)) (hB : ‚àÉ (c : ‚Ñù) (H : c < 2) (B : ‚Ñù), f =O[filter.comap complex.abs filter.at_top ‚äì filter.principal (set.Iio 0 √ó‚ÑÇ set.Iio 0)] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)) (hre : ‚àÄ (x : ‚Ñù), x ‚â§ 0 ‚Üí f ‚Üëx = 0) (him : ‚àÄ (x : ‚Ñù), x ‚â§ 0 ‚Üí f (‚Üëx * complex.I) = 0) : set.eq_on f 0 {z : ‚ÑÇ | z.re ‚â§ 0 ‚àß z.im ‚â§ 0}
 : Type (u+1)
{G : Type u_1} [group G] {N : Type u_3} [group N] (f : G ‚Üí* N) (H : subgroup G) : subgroup N
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (o : part Œ±) : part Œ≤
{J : Type v} {C : Type u} [category_theory.category C] {B : C} {objs : J ‚Üí C} {arrows : Œ† (j : J), objs j ‚ü∂ B} [category_theory.limits.has_wide_pullback B objs arrows] {X : C} (f : X ‚ü∂ B) (fs : Œ† (j : J), X ‚ü∂ objs j) (w : ‚àÄ (j : J), fs j ‚â´ arrows j = f) : X ‚ü∂ category_theory.limits.wide_pullback B (Œª (j : J), objs j) arrows
{Œ± : Type u_1} {G : Type u_4} [conditionally_complete_lattice Œ±] [group G] (f‚ÇÅ f‚ÇÇ : G ‚Üí* Œ± ‚âÉo Œ±) (hbdd : ‚àÄ (x : Œ±), bdd_above (set.range (Œª (g : G), ‚áë(‚áëf‚ÇÅ g)‚Åª¬π (‚áë(‚áëf‚ÇÇ g) x)))) (g : G) : function.semiconj (Œª (x : Œ±), ‚®Ü (g' : G), ‚áë(‚áëf‚ÇÅ g')‚Åª¬π (‚áë(‚áëf‚ÇÇ g') x)) ‚áë(‚áëf‚ÇÇ g) ‚áë(‚áëf‚ÇÅ g)
{n : ‚Ñï} (x y : bitvec n) : Prop
{R : Type u_1} {A : Type u_2} {M : Type u_3} {N : Type u_4} {P : Type u_5} [comm_semiring R] [semiring A] [algebra R A] [add_comm_monoid M] [module R M] [module A M] [is_scalar_tower R A M] [add_comm_monoid N] [module R N] [add_comm_monoid P] [module R P] [module A P] [is_scalar_tower R A P] : function.injective tensor_product.algebra_tensor_module.curry
(E : Type u_1) [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] : ‚Ñù
{Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] {R' : Type u_1} {A : Type u_2} [semiring R'] [semiring A] [Œ† (i : Œπ), module A (M‚ÇÅ i)] [module A M‚ÇÇ] [module R' M‚ÇÇ] [smul_comm_class A R' M‚ÇÇ] : module R' (multilinear_map A M‚ÇÅ M‚ÇÇ)
{R : Type u} {A : Type v} {B : Type w} {C : Type w‚ÇÅ} [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B] [non_unital_non_assoc_semiring C] [distrib_mul_action R C] (f : A ‚Üí‚Çô‚Çê[R] B) (g : A ‚Üí‚Çô‚Çê[R] C) : A ‚Üí‚Çô‚Çê[R] B √ó C
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type w} [category_theory.category J] (F : J ‚•§ C) [category_theory.limits.preserves_colimit F G] [category_theory.limits.has_colimit F] [category_theory.limits.has_colimit (F ‚ãô G)] : G.obj (category_theory.limits.colimit F) ‚âÖ category_theory.limits.colimit (F ‚ãô G)
{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_pushouts C
{n : Type u_3} {Œ± : Type v} [decidable_eq n] [has_zero Œ±] (d : n ‚Üí Œ±) : matrix n n Œ±
 : ‚ÑÇ ‚ÜíL[‚Ñù] ‚Ñù
{Œ± : Type u_1} : set (Œ± √ó Œ±)
{Œ± : Type u} : pos_num ‚Üí tree Œ± ‚Üí option Œ±
{C : Type u} [category_theory.category C] {X : C} (i : category_theory.arrow C) : category_theory.has_lifting_property i (category_theory.arrow.mk (ùüô X))
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pullbacks C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : category_theory.limits.pullback f g ‚ü∂ X ‚äû Y
(C : Type u) [category_theory.category C] {X Y : Top} (H : X ‚âÖ Y) : Top.presheaf C X ‚âå Top.presheaf C Y
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) {X : C} (R : category_theory.sieve X) : category_theory.sieve (F.obj X)
{Œ± : Type u} [semilattice_sup Œ±] [nonempty Œ±] (s : finset Œ±) : bdd_above ‚Üës
 : metric_space ‚Ñù
{X : Type u_1} (point : X) : Pointed
{R : Type u} : R ‚âÉ tropical R
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : (matrix n n Œ±)À£) : ‚ÜëA‚Åª¬π = (‚ÜëA)‚Åª¬π
{Œ± : Type u_1} : vector3 Œ± 0
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_group Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} : convex_on ùïú s (-f) ‚Üî concave_on ùïú s f
{X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {m‚ÇÅ m‚ÇÇ : ennreal ‚Üí ennreal} (hle : m‚ÇÅ ‚â§·∂†[nhds_within 0 (set.Ici 0)] m‚ÇÇ) : measure_theory.measure.mk_metric m‚ÇÅ ‚â§ measure_theory.measure.mk_metric m‚ÇÇ
{Œ± : Type u_1} : list Œ± ‚Üí list ‚Ñï ‚Üí list (list Œ±) √ó list Œ±
{G : Type u_1} [group G] (S : set G) : set (set G)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J ‚Üí C) : Type (max u v)
(F : Type u_7) (Œ± : out_param (Type u_8)) (Œ≤ : out_param (Type u_9)) [lattice Œ±] [lattice Œ≤] : Type (max u_7 u_8 u_9)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s : affine_subspace k P} (h : ‚Üës.nonempty) : s.direction = ‚ä§ ‚Üî s = ‚ä§
{G : Type u_1} [add_group G] {k : set G} : k ‚äÜ ‚Üë(add_subgroup.closure k)
{C : Type u} [category_theory.category C] {A B : C} {f g : A ‚ü∂ B} [category_theory.is_reflexive_pair f g] : category_theory.is_reflexive_pair g f
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), add_comm_group (A i)] [add_monoid Œπ] [direct_sum.gsemiring A] : ring (direct_sum Œπ (Œª (i : Œπ), A i))
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.abelian C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (h : category_theory.exact f g) : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ (category_theory.abelian.image.Œπ f) _)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.is_iso f] : category_theory.is_iso f.op
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M ‚Üí* P} (H : c ‚â§ con.ker f) : (c.lift f H).comp c.mk' = f
{Œ± : Sort u_1} (contra : ¬¨(Œ± ‚Üí false) ‚Üí Œ±) : nonempty Œ± ‚Üí Œ±
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (f : M ‚Üí‚Çô* N) (M' : subsemigroup M) : ‚Ü•M' ‚Üí‚Çô* ‚Ü•(subsemigroup.map f M')
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (P : C ‚Üí Prop) [category_theory.monoidal_category.monoidal_predicate P] : category_theory.monoidal_category {X // P X}
(x y : ‚Ñù) [fact (x < y)] : local_homeomorph ‚Ü•(set.Icc x y) (euclidean_half_space 1)
(type has_zero has_one has_add has_neg has_div : expr) : ‚Ñö ‚Üí expr
{A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ} [category_theory.category A] [category_theory.category B] [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] (Q : A ‚•§ B) (V : B ‚•§ D) (U : A ‚•§ C) (R : C ‚•§ D) (comm : U ‚ãô R ‚âÖ Q ‚ãô V) [category_theory.is_right_adjoint U] [category_theory.monadic_right_adjoint V] [category_theory.is_right_adjoint R] [category_theory.limits.has_reflexive_coequalizers A] : category_theory.is_right_adjoint Q
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : S.normed_mk.ker = S
(C : Type u‚ÇÅ) [category_theory.category C] : Type (max u‚ÇÅ v‚ÇÅ)
 : Type
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [add_group Œ±] [uniform_add_group Œ±] [uniform_space Œ≤] [add_group Œ≤] [uniform_add_group Œ≤] [complete_space Œ≤] [separated_space Œ≤] (f : Œ± ‚Üí+ Œ≤) (hf : continuous ‚áëf) : uniform_space.completion Œ± ‚Üí+ Œ≤
{Œ± : Type u_1} {M : Type u_2} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (s : set Œ±) : ‚Ü•(finsupp.supported M R s) ‚âÉ‚Çó[R] ‚Ü•s ‚Üí‚ÇÄ M
(K : Type u‚ÇÅ) [field K] (v : valuation K nnreal) (O : Type u‚ÇÇ) [comm_ring O] [algebra O K] (hv : v.integers O) (p : ‚Ñï) : Type u‚ÇÇ
(Œ± : Sort v) [is_empty Œ±] : Œ± ‚âÉ pempty
(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop
{R : Type u} [comm_ring R] {n : ‚Ñï} (u : RÀ£) (hn : is_unit ‚Üën) : (polynomial.X ^ n - ‚áëpolynomial.C ‚Üëu).separable
{R : Type u} [ring R] (S : set R) : Prop
 : path 0 1
{Œ± : Sort u_1} (x : Œ±) (h : ‚àÄ (y : Œ±), y = x) : subsingleton Œ±
 : fundamental_groupoid.from_top {down := 0} ‚ü∂ fundamental_groupoid.from_top {down := 1}
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_images C] [category_theory.limits.has_binary_coproducts C] {A : C} : category_theory.subobject A ‚•§ category_theory.subobject A ‚•§ category_theory.subobject A
{G : Type u_1} [group G] (H K : subgroup G) : ‚Ñï
{Œ± : Type u_1} (L : list (list Œ±)) (i : ‚Ñï) : list.take (list.take i (list.map list.length L)).sum L.join = (list.take i L).join
{X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] (m : ennreal ‚Üí ennreal) : measure_theory.measure X
{K : Type u_1} {K‚Çò : Type u_2} [field K] [comm_ring K‚Çò] {M : submonoid K} (hM : 0 ‚àâ M) [algebra K K‚Çò] [is_localization M K‚Çò] : function.bijective ‚áë(algebra_map K K‚Çò)
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] [t2_space M‚ÇÇ] {s : set M‚ÇÅ} (hs : dense ‚Üë(submodule.span R‚ÇÅ s)) {f g : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (h : set.eq_on ‚áëf ‚áëg s) : f = g
{M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a ‚àà s) {n : ‚Ñï} : n ‚Ä¢ a ‚àà s
{S : Type u_2} [linear_ordered_ring S] : absolute_value S S
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (f : M ‚Üí* N) : submonoid N
{R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] {R‚Çò : Type u_4} {S‚Çò : Type u_5} [comm_ring R‚Çò] [comm_ring S‚Çò] [algebra R R‚Çò] [is_localization M R‚Çò] [algebra S S‚Çò] [is_localization (algebra.algebra_map_submonoid S M) S‚Çò] : algebra R‚Çò S‚Çò
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L} : x ‚àà S ‚Üí x‚Åª¬π ‚àà S
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (f : M ‚Üí+ P) (hf : function.surjective ‚áëf) : (add_con.ker f).quotient ‚âÉ+ P
 : omega.nat.exprform ‚Üí list expr
{X : Type u_1} [uniform_space X] {s : set X} [(uniformity X).is_countably_generated] : is_compact s ‚Üî is_seq_compact s
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : ‚ü¶x.some_ray_vector‚üß = x
(p q : omega.nat.preform) : Prop
{Œ± : Type u_1} [topological_space Œ±] {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] [has_continuous_add Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : lower_semicontinuous f) (hg : lower_semicontinuous g) : lower_semicontinuous (Œª (z : Œ±), f z + g z)
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b : Œ±} (ha : 1 < a) (hb : 1 ‚â§ b) : 1 < a * b
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : Œ± ‚âÉ Œ≤) (h‚ÇÅ : continuous ‚áëe) (h‚ÇÇ : is_open_map ‚áëe) : Œ± ‚âÉ‚Çú Œ≤
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) [category_theory.is_iso f] (g : Y ‚ü∂ Z) [category_theory.limits.has_image g] : category_theory.limits.has_image (f ‚â´ g)
{Œ± : Type u_1} {Œ≤ : Type u_2} {f g : Œ± ‚Üí Œ≤} {m : measurable_space Œ±} {mŒ≤ : measurable_space Œ≤} {p : Œ± ‚Üí Prop} {_x : decidable_pred p} (hp : measurable_set {a : Œ± | p a}) (hf : measurable f) (hg : measurable g) : measurable (Œª (x : Œ±), ite (p x) (f x) (g x))
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [non_unital_comm_semiring Œ≤] : non_unital_comm_semiring Œ±
{Œ± : Type u} [topological_space Œ±] (a : Œ±) : (nhds a).has_basis (Œª (s : set Œ±), a ‚àà s ‚àß is_open s) (Œª (s : set Œ±), s)
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [linear_ordered_add_comm_group Œ±] [archimedean Œ±] (h : function.periodic f c) (hc : 0 < c) (x a : Œ±) : ‚àÉ (y : Œ±) (H : y ‚àà set.Ico a (a + c)), f x = f y
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [semi_normed_group Œ≤] (f : bounded_continuous_function Œ± Œ≤) : bounded_continuous_function Œ± ‚Ñù
(R : Type u) [has_star R] : Prop
(prf : expr) : tactic expr
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {V‚ÇÇ : Type u_5} {P‚ÇÇ : Type u_6} [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] {s : set P} (e : P ‚âÉ·µÉ[k] P‚ÇÇ) : affine_independent k coe ‚Üî affine_independent k coe
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (X : category_theory.simplicial_object C) (n : ‚Ñï) : algebraic_topology.alternating_face_map_complex.obj_d X (n + 1) ‚â´ algebraic_topology.alternating_face_map_complex.obj_d X n = 0
{K : Type v} [field K] (f : polynomial K) : polynomial (adjoin_root f.factor)
{R : Type u_2} {Œì‚ÇÄ : Type u_3} {Œì'‚ÇÄ : Type u_4} [linear_ordered_add_comm_monoid_with_top Œì‚ÇÄ] [linear_ordered_add_comm_monoid_with_top Œì'‚ÇÄ] [ring R] (f : Œì‚ÇÄ ‚Üí+ Œì'‚ÇÄ) (ht : ‚áëf ‚ä§ = ‚ä§) (hf : monotone ‚áëf) (v : add_valuation R Œì‚ÇÄ) : add_valuation R Œì'‚ÇÄ
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] {v : E} : ‚Üë(‚áë(orthogonal_projection K) v) = v ‚Üî v ‚àà K
 : ‚Ñö ‚Üí ‚Ñö ‚Üí ‚Ñö
(A : Type u) : Type u
(Œ± : Type u) : Type u
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Group) (x : Œ£ (j : J), ‚Ü•(F.obj j)) : ‚Ü•(Group.filtered_colimits.G F)
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (D : algebraic_geometry.SheafedSpace.glue_data C) [category_theory.limits.has_limits C] : D.to_glue_data.glued.to_PresheafedSpace ‚âÖ D.to_PresheafedSpace_glue_data.to_glue_data.glued
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {A X Y : C} [category_theory.closed A] : (A ‚äó Y ‚ü∂ X) ‚Üí (Y ‚ü∂ (category_theory.ihom A).obj X)
{R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (e : R ‚âÉ+* S) : R ‚Üí+* S
{M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_3} [has_zero M‚ÇÄ'] [has_mul M‚ÇÄ'] [has_one M‚ÇÄ'] [has_pow M‚ÇÄ' ‚Ñï] [comm_monoid_with_zero M‚ÇÄ] (f : M‚ÇÄ' ‚Üí M‚ÇÄ) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÄ'), f (x * y) = f x * f y) (npow : ‚àÄ (x : M‚ÇÄ') (n : ‚Ñï), f (x ^ n) = f x ^ n) : comm_monoid_with_zero M‚ÇÄ'
{C : Type u} [category_theory.category C] [category_theory.abelian C] (X : C) (h : ‚àÄ {Z : C} (f : X ‚ü∂ Z) [_inst_3 : category_theory.epi f], category_theory.is_iso f ‚Üî f ‚â† 0) : category_theory.simple X
{R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] (abv : absolute_value R ‚Ñ§) {Œπ : Type u_5} [decidable_eq Œπ] [fintype Œπ] (bS : basis Œπ R S) {T : Type u_3} [linear_ordered_ring T] (a : S) {y : T} (hy : ‚àÄ (k : Œπ), ‚Üë(‚áëabv (‚áë(‚áë(bS.repr) a) k)) < y) : ‚Üë(‚áëabv (‚áë(algebra.norm R) a)) < ‚Üë(class_group.norm_bound abv bS) * y ^ fintype.card Œπ
{Œ± : Type u} (s : seq Œ±) [decidable (‚àÉ (n : ‚Ñï), ¬¨‚Ü•((s.nth n).is_some))] : list Œ± ‚äï stream Œ±
 : Type
 : tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt) ‚Üí tactic.list_Sigma tactic.rcases_patt
(info : tactic.eliminate.constructor_argument_naming_info) (rules : list tactic.eliminate.constructor_argument_naming_rule) : tactic (list name)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) {X : C} (R : category_theory.presieve (F.obj X)) : category_theory.presieve X
 : expr ‚Üí list (name √ó level) ‚Üí expr
{R : Type u_1} (K : Type u_2) [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_dedekind_domain R] : ‚Ü•(non_zero_divisors (ideal R)) ‚Üí* class_group R K
(k : Type u_1) [division_ring k] {Œπ : Type u_4} (s : finset Œπ) [char_zero k] [fintype Œπ] {n : ‚Ñï} (h : s.card = n + 1) : finset.univ.sum (Œª (i : Œπ), finset.centroid_weights_indicator k s i) = 1
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_Inf Œ±] [has_Inf Œ≤] : has_coe_to_fun (Inf_hom Œ± Œ≤) (Œª (_x : Inf_hom Œ± Œ≤), Œ± ‚Üí Œ≤)
{R : Type u} [comm_ring R] (x : prime_spectrum R) : ideal R
{Œ± : Type u} {Œ≤ : Type v} : Œ± ‚äï Œ≤ ‚Üí bool
{M : Type u_1} [add_monoid M] {s‚ÇÅ s‚ÇÇ : set M} (is‚ÇÅ : is_add_submonoid s‚ÇÅ) (is‚ÇÇ : is_add_submonoid s‚ÇÇ) : is_add_submonoid (s‚ÇÅ ‚à© s‚ÇÇ)
{G : Type u_1} [group G] {H K : subgroup G} (h : H ‚â§ K) : ‚Ü•(subgroup.comap K.subtype H) ‚âÉ* ‚Ü•H
(x : expr) : tactic unit
{M : Type u_1} [has_mul M] {c d : con M} : setoid.r = setoid.r ‚Üî c = d
{M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_3} [mul_zero_one_class M‚ÇÄ] [has_mul M‚ÇÄ'] [has_zero M‚ÇÄ'] [has_one M‚ÇÄ'] (f : M‚ÇÄ' ‚Üí M‚ÇÄ) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ‚àÄ (a b : M‚ÇÄ'), f (a * b) = f a * f b) : mul_zero_one_class M‚ÇÄ'
{n : ‚Ñï} (F : typevec n ‚Üí Type u_2) : Type (max (u_1+1) u_2)
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] (X : Top) : Top.sheaf C X ‚•§ category_theory.Sheaf (opens.grothendieck_topology ‚Ü•X) C
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ±‚ÇÇ : Type u_3} [semiring Œ≤] [has_mul Œ±] [has_mul Œ±‚ÇÇ] {F : Type u_4} [mul_hom_class F Œ± Œ±‚ÇÇ] (f : F) (x y : monoid_algebra Œ≤ Œ±) : finsupp.map_domain ‚áëf (x * y) = finsupp.map_domain ‚áëf x * finsupp.map_domain ‚áëf y
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] {f : M ‚Üí‚Çô* N} (hf : function.injective ‚áëf) : galois_coinsertion (subsemigroup.map f) (subsemigroup.comap f)
{ùïú : Type u_1} {E : Type u_4} (E‚Çó : Type u_5) {F‚Çó : Type u_7} {G‚Çó : Type u_9} [semi_normed_group E] [semi_normed_group E‚Çó] [semi_normed_group F‚Çó] [semi_normed_group G‚Çó] [nondiscrete_normed_field ùïú] [normed_space ùïú E] [normed_space ùïú E‚Çó] [normed_space ùïú F‚Çó] [normed_space ùïú G‚Çó] (L : E ‚ÜíL[ùïú] F‚Çó ‚ÜíL[ùïú] G‚Çó) : E ‚ÜíL[ùïú] (E‚Çó ‚ÜíL[ùïú] F‚Çó) ‚ÜíL[ùïú] E‚Çó ‚ÜíL[ùïú] G‚Çó
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Type (max v u)) (x : Œ† (j : J), F.obj j) (h : ‚àÄ (j j' : J) (f : j ‚ü∂ j'), F.map f (x j) = x j') : category_theory.limits.limit F
(p : ‚Ñï) [fact (nat.prime p)] (n : ‚Ñï) {K : Type u_1} [field K] [fintype K] [algebra (zmod p) K] (h : fintype.card K = p ^ n) : K ‚âÉ‚Çê[zmod p] galois_field p n
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) ‚Üî same_ray R x y
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] {D : Type u‚ÇÅ} [category_theory.category D] (h : C ‚âå D) : category_theory.is_filtered D
{Œ± : Type u_1} {Œ≤ : Type u_2} {s : set Œ±} {t : set Œ≤} (f : Œ± ‚Üí Œ≤) (h : set.bij_on f s t) : ‚Ü•s ‚âÉ ‚Ü•t
{p : polynomial ‚Ñö} (p_irr : irreducible p) (p_deg : nat.prime p.nat_degree) (p_roots1 : fintype.card ‚Ü•(p.root_set ‚Ñù) + 1 ‚â§ fintype.card ‚Ü•(p.root_set ‚ÑÇ)) (p_roots2 : fintype.card ‚Ü•(p.root_set ‚ÑÇ) ‚â§ fintype.card ‚Ü•(p.root_set ‚Ñù) + 3) : function.bijective ‚áë(polynomial.gal.gal_action_hom p ‚ÑÇ)
{G : Type u_1} [linear_ordered_add_comm_group G] [archimedean G] {H : add_subgroup G} {a : G} (ha : is_least {g : G | g ‚àà H ‚àß 0 < g} a) : H = add_subgroup.closure {a}
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b : Œ±} (ha : a < 0) (hb : b < 0) : a + b < 0
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (i : Œ± ‚Üí Œ≤) : Prop
 : znum ‚Üí num
(G : Type w) [topological_space G] [group G] [topological_group G] : G √ó G ‚âÉ‚Çú G √ó G
{M : Type u_1} [mul_one_class M] : has_inf (submonoid M)
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] {K : Type u‚ÇÇ} [category_theory.category K] (F : D ‚•§ K ‚•§ C) (J : Type u_1) [category_theory.category J] (H : Œ† (k : K), category_theory.limits.preserves_colimits_of_shape J (F ‚ãô (category_theory.evaluation K C).obj k)) : category_theory.limits.preserves_colimits_of_shape J F
(m : Type u ‚Üí Type v) (n : Type u ‚Üí Type w) : Type (max (u+1) v w)
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [add_comm_monoid Œπ] [decidable_eq Œπ] [comm_ring R] [comm_ring A] [algebra R A] {ùíú : Œπ ‚Üí submodule R A} [graded_algebra ùíú] {x : ideal A} [x.is_prime] (f : homogeneous_localization ùíú x) : A
 : pos_num ‚Üí bool
{C : Type u} [category_theory.category C] [‚àÄ (n : ‚Ñï) (f : category_theory.arrow C), category_theory.limits.has_wide_pullback f.right (Œª (i : ulift (fin (n + 1))), f.left) (Œª (i : ulift (fin (n + 1))), f.hom)] : category_theory.arrow C ‚•§ category_theory.simplicial_object C
(e : expr) : tactic.unsafe.type_context bool
(q : interactive.parse interactive.types.texpr) : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] : category_theory.monoidal.Mon_functor_category_equivalence.inverse ‚ãô category_theory.monoidal.Mon_functor_category_equivalence.functor ‚âÖ ùü≠ (C ‚•§ Mon_ D)
{m : ‚Ñï} (hm : 0 < m) (k : ‚Ñï) : ‚àÉ (p : ‚Ñï), liouville.liouville_number_initial_terms ‚Üëm k = ‚Üëp / ‚Üëm ^ k.factorial
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {f g : category_theory.mono_over X} (h : f.val.left ‚ü∂ g.val.left) (w : h ‚â´ g.arrow = f.arrow) : f ‚ü∂ g
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [semiring R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] (e : topological_vector_bundle.pretrivialization R F E) (b : B) (y : F) : E b
{Œ± : Type u_1} [has_le Œ±] {a : Œ±·µí·µà} : is_bot a ‚Üí is_top (‚áëorder_dual.of_dual a)
(A B : Top) : category_theory.Groupoid.of (‚Ü•(fundamental_groupoid.fundamental_groupoid_functor.obj A) √ó ‚Ü•(fundamental_groupoid.fundamental_groupoid_functor.obj B)) ‚âÖ fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (‚Ü•A √ó ‚Ü•B))
 : tactic unit
{Œ± : Type u_1} [decidable_eq Œ±] (s : cycle Œ±) (h : s.nodup) : equiv.perm Œ±
(E : Type u_6) : Type u_6
{C : Type (max v u)} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] [category_theory.concrete_category D] [Œ† (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)·µí·µñ (category_theory.forget D)] {K : Type (max v u)} [category_theory.small_category K] [category_theory.fin_category K] [category_theory.limits.has_limits_of_shape K D] [category_theory.limits.preserves_limits_of_shape K (category_theory.forget D)] [category_theory.limits.reflects_limits_of_shape K (category_theory.forget D)] (F : K ‚•§ C·µí·µñ ‚•§ D) (X : C) (S : category_theory.limits.cone (F ‚ãô J.plus_functor D ‚ãô (category_theory.evaluation C·µí·µñ D).obj (opposite.op X))) : S.X ‚ü∂ (J.plus_obj (category_theory.limits.limit F)).obj (opposite.op X)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ‚Ñù P) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] : P ‚Üí·µÉ[‚Ñù] ‚Ü•s
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] {t : category_theory.limits.trident f} (ht : category_theory.limits.is_limit t) {Z Z' : C} (q : Z' ‚ü∂ Z) (k : Z ‚ü∂ t.X) : ‚Üë(‚áë(category_theory.limits.trident.is_limit.hom_iso ht Z') (q ‚â´ k)) = q ‚â´ ‚Üë(‚áë(category_theory.limits.trident.is_limit.hom_iso ht Z) k)
 : category_theory.Cat ‚•§ sSet
{Œ± : Type u_1} [decidable_eq Œ±] {s : finset Œ±} {p : finset Œ± ‚Üí Prop} (hu : Œ† (t : finset Œ±), t ‚äÇ s ‚Üí decidable (p t)) : decidable (‚àÉ (t : finset Œ±) (h : t ‚äÇ s), p t)
(Œ± : Type u_1) [partial_order Œ±] [bounded_order Œ±] : BoundedOrder
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [pred_order Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : monotone f) : pairwise (disjoint on Œª (n : Œ±), set.Ico (f (order.pred n)) (f n))
{Œ≤ : Type u} {Œ≥ : Type w} [comm_semiring Œ≤] [comm_semiring Œ≥] (f : Œ≤ ‚Üí+* Œ≥) (s : multiset Œ≤) : ‚áëf s.prod = (multiset.map ‚áëf s).prod
(s : set ‚Ñï) [decidable_pred (Œª (_x : ‚Ñï), _x ‚àà s)] [infinite ‚Ü•s] : denumerable ‚Ü•s
{M : Type u_1} {R : Type u_2} [monoid M] [semiring R] [mul_semiring_action M R] : mul_action M (subsemiring R)
{Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), monoid (Gs i)] {x : Œ† (i : Œ∑), Gs i} (h : is_of_fin_order x) (i : Œ∑) : is_of_fin_order (x i)
{K : Type u} [hfield : field K] {L : Type u_1} [field L] (f : K ‚Üí+* L) (a : L) (p : ratfunc K) : L
{R : Type u_1} {M : Type u_5} [comm_ring R] [add_comm_group M] [module R M] (B : M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R) : submodule R (module.End R M)
(tac : tactic unit) : tactic unit
{Œ± : Type u_3} {Œ≤ : Type u_4} [linear_ordered_field Œ±] {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±} {r : Œ±} (hr : 0 < r) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (Œª (x : Œ≤), f x / r) l filter.at_bot
{Œ± : Type u} {Œ≤ : Type v} [add_zero_class Œ±] [add_zero_class Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_monoid_hom f) (x y : Œ±) : f (x + y) = f x + f y
{R : Type u} {M : Type v} {M‚ÇÇ : Type w} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] {n : ‚Ñï} (f : M ‚Üí‚Çó[R] M‚ÇÇ) (g : M ‚Üí‚Çó[R] fin n ‚Üí M‚ÇÇ) : M ‚Üí‚Çó[R] fin n.succ ‚Üí M‚ÇÇ
{E : Type u_2} {ùïú : Type u_3} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] {s : set E} (hs : convex ùïú s) {x y : E} (hx : x ‚àà s) (hy : y ‚àà interior s) {t : ùïú} (ht : t ‚àà set.Ioc 0 1) : x + t ‚Ä¢ (y - x) ‚àà interior s
{C : Type u‚ÇÅ} [category_theory.category C] {G : category_theory.comonad C} (A B : G.coalgebra) : Type v‚ÇÅ
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cocone F} (ht : ‚àÄ (s : category_theory.limits.cocone F), ‚àÉ! (d : t.X ‚ü∂ s.X), ‚àÄ (j : J), t.Œπ.app j ‚â´ d = s.Œπ.app j) : category_theory.limits.is_colimit t
(Œ± : Type u_3) [topological_space Œ±] : Type u_3
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {n : with_top ‚Ñï} {R : Type u_6} [normed_ring R] [normed_algebra ùïú R] [complete_space R] (x : RÀ£) : cont_diff_at ùïú n ring.inverse ‚Üëx
{K : Type u} [field K] (s : subfield K) {x : K} : x ‚àà s ‚Üí x‚Åª¬π ‚àà s
 : znum ‚Üí znum
{K : Type u_1} [field K] (f : polynomial K) (a : K) (hf' : polynomial.eval a (‚áëpolynomial.derivative f) ‚â† 0) : is_coprime (polynomial.X - ‚áëpolynomial.C a) (f /‚Çò (polynomial.X - ‚áëpolynomial.C a))
{J : Type u} (f : J ‚Üí AddCommGroup) : category_theory.limits.limit_cone (category_theory.discrete.functor f)
{C : Type u} [category_theory.category C] [category_theory.concrete_category C] [category_theory.limits.has_limits C] [category_theory.reflects_isomorphisms (category_theory.forget C)] [category_theory.limits.preserves_limits (category_theory.forget C)] {X : Top} (F : Top.presheaf C X) : F.is_sheaf ‚Üî F.is_sheaf_unique_gluing
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {r : R} (h : same_ray R x y) (hr : 0 < r) : same_ray R x (r ‚Ä¢ y)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {T : E ‚Üí‚Çó[ùïú] E} (hT : inner_product_space.is_self_adjoint T) {V : submodule ùïú E} (hV : ‚àÄ (v : E), v ‚àà V ‚Üí ‚áëT v ‚àà V) : inner_product_space.is_self_adjoint (T.restrict hV)
{Œ± : Type u} [t : topological_space Œ±] {a : Œ±} {s : set Œ±} {b : set (set Œ±)} (hb : topological_space.is_topological_basis b) : s ‚àà nhds a ‚Üî ‚àÉ (t : set Œ±) (H : t ‚àà b), a ‚àà t ‚àß t ‚äÜ s
(C : Type u‚ÇÅ) [category_theory.category C] : Type (max u‚ÇÅ (v+1))
{n : ‚Ñï} {i : fin (n + 1)} : simplex_category.Œ¥ i.succ ‚â´ simplex_category.œÉ i = ùüô (simplex_category.mk n)
(n : ‚Ñï+) (i : ‚Ñï) : fin ‚Üën
{G : Type u_1} [group G] (H : subgroup G) [H.normal] : upper_central_series_step H = subgroup.comap (quotient_group.mk' H) (subgroup.center (G ‚ß∏ H))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) [finite_dimensional k ‚Ü•(vector_span k s)] : collinear k s ‚Üî finite_dimensional.finrank k ‚Ü•(vector_span k s) ‚â§ 1
{M : Type u_1} [has_add M] : has_inf (add_subsemigroup M)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [finite_dimensional ùïú E] : has_star (E ‚Üí‚Çó[ùïú] E)
{Œ± : Type u‚ÇÅ} [category_theory.is_connected (category_theory.discrete Œ±)] : Œ± ‚âÉ punit
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ X‚ÇÉ) (g‚ÇÅ : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) (g‚ÇÇ : Y‚ÇÇ ‚ü∂ Y‚ÇÉ) (i‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (i‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (i‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) (h‚ÇÅ : i‚ÇÅ ‚â´ g‚ÇÅ = f‚ÇÅ ‚â´ i‚ÇÇ) (h‚ÇÇ : i‚ÇÇ ‚â´ g‚ÇÇ = f‚ÇÇ ‚â´ i‚ÇÉ) (H : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk i‚ÇÇ f‚ÇÇ h‚ÇÇ)) (H' : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk i‚ÇÅ f‚ÇÅ h‚ÇÅ)) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk i‚ÇÅ (f‚ÇÅ ‚â´ f‚ÇÇ) _)
{R : Type u_4} [linear_ordered_ring R] (a : R) (h : a ‚â† 0) : 0 < a ^ 2
{n : ‚Ñï} {Œ± : Type u_1} {v : vector Œ± n} : v.reverse.to_list = v.to_list.reverse
(e : expr) : list expr
{R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] {N : Type u_3} [add_comm_group N] [module R N] [is_simple_module R M] [is_simple_module R N] (f : M ‚Üí‚Çó[R] N) : function.bijective ‚áëf ‚à® f = 0
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] {s t : category_theory.limits.trident f} (i : s.X ‚âÖ t.X) (w : i.hom ‚â´ t.Œπ = s.Œπ) : s ‚âÖ t
{r : ‚Ñù} (hr : 0 ‚â§ r) (h'r : r < 1) : filter.tendsto (Œª (n : ‚Ñï), ‚Üën * r ^ n) filter.at_top (nhds 0)
{L : first_order.language} (r : L.relations 2) : L.sentence
(K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] {R : Type z} [comm_ring R] [algebra R K] [algebra R L] [is_scalar_tower R K L] [is_domain R] [is_separable K L] [is_integrally_closed R] [is_fraction_ring R K] {B : power_basis K L} (hint : is_integral R B.gen) {z : L} (hz : is_integral R z) : algebra.discr K ‚áë(B.basis) ‚Ä¢ z ‚àà algebra.adjoin R {B.gen}
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : GL n R ‚âÉ* linear_map.general_linear_group R (n ‚Üí R)
(n m : ‚Ñï) : fin (m + 1)
{C : Type u} [category_theory.category C] (X‚ÇÅ X‚ÇÇ : C) : Type (max u v)
{Œπ : Type u_1} {E : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), metric_space (E i)] [‚àÄ (i : Œπ), complete_space (E i)] : complete_space (Œ£ (i : Œπ), E i)
(R : Type u_7) (S : Type u_8) [has_mul R] [has_add R] [has_mul S] [has_add S] : Type (max u_7 u_8)
{R : Type u_2} {M : Type u_4} [ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) : Q.isometry Q
{R : Type u_1} {S : Type u_2} {F : Type u_3} {G : Type u_4} [non_assoc_semiring R] [non_assoc_semiring S] [ring_hom_class F R S] [ring_hom_class G S R] (hom : F) (inv : G) (hom_inv_id : ‚Üëinv.comp ‚Üëhom = ring_hom.id R) (inv_hom_id : ‚Üëhom.comp ‚Üëinv = ring_hom.id S) : R ‚âÉ+* S
{Œ± : Type u_1} [linear_ordered_field Œ±] (Œ≤ : Type u_2) [ring Œ≤] (abv : Œ≤ ‚Üí Œ±) : Type u_2
{F : Type u_8} {G : Type u_1} {H : Type u_2} [group G] [mul_one_class H] [monoid_hom_class F G H] (f : F) : function.injective ‚áëf ‚Üî ‚àÄ (a : G), ‚áëf a = 1 ‚Üí a = 1
{Œ± : Type u_1} {ùïú : Type u_14} [normed_field ùïú] {l : filter Œ±} {f g : Œ± ‚Üí ùïú} (hgf : ‚àÄ (x : Œ±), g x = 0 ‚Üí f x = 0) : filter.tendsto (Œª (x : Œ±), f x / g x) l (nhds 0) ‚Üí f =o[l] g
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] {f : ‚ÑÇ ‚Üí E} (hd : diff_cont_on_cl ‚ÑÇ f (set.Ioi 0 √ó‚ÑÇ set.Iio 0)) (hB : ‚àÉ (c : ‚Ñù) (H : c < 2) (B : ‚Ñù), f =O[filter.comap complex.abs filter.at_top ‚äì filter.principal (set.Ioi 0 √ó‚ÑÇ set.Iio 0)] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)) (hre : ‚àÄ (x : ‚Ñù), 0 ‚â§ x ‚Üí f ‚Üëx = 0) (him : ‚àÄ (x : ‚Ñù), x ‚â§ 0 ‚Üí f (‚Üëx * complex.I) = 0) : set.eq_on f 0 {z : ‚ÑÇ | 0 ‚â§ z.re ‚àß z.im ‚â§ 0}
 : lean.parser pexpr
{X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y) : joined ‚ü®x, _‚ü© ‚ü®y, _‚ü©
 : ‚ÑÇ ‚âÉ‚Çó·µ¢[‚Ñù] ‚ÑÇ
{Œ± : Type u_1} {Œ≤ : Type u_2} {m‚ÇÅ : measurable_space Œ±} {m‚ÇÇ : measurable_space Œ≤} {f : Œ± ‚Üí Œ≤} : measurable f ‚Üí measurable_space.comap f m‚ÇÇ ‚â§ m‚ÇÅ
(env : environment) (n : name) : option (list name)
 : algebraic_geometry.LocallyRingedSpace ‚•§ Top
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {s : set E} [complete_space F] (h : analytic_on ùïú f s) : analytic_on ùïú (fderiv ùïú f) s
 : list string ‚Üí name
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Œπ] (p : Œπ ‚Üí P) {n : ‚Ñï} (hc : fintype.card Œπ = n + 1) : affine_independent k p ‚Üî finite_dimensional.finrank k ‚Ü•(vector_span k (set.range p)) = n
{Œ± : Type u} : additive Œ± ‚âÉ Œ±
{Œ± : Type u} [add_comm_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b c : Œ±} : a + b ‚â§ c ‚Üí b ‚â§ c - a
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {Œπ : Type u_6} (Z : topological_vector_bundle_core R B F Œπ) (x : B) : Type u_4
{Œπ : Type u_1} : has_sup (box_integral.box Œπ)
{Œ± : Sort u} : plift Œ± ‚âÉ Œ±
(R : Type u_1) (M : Type u_2) [add_comm_monoid M] [comm_ring R] [h : add_monoid.fg M] : algebra.finite_type R (add_monoid_algebra R M)
(V : Type (u+1)) [category_theory.large_category V] (G : Mon) [category_theory.monoidal_category V] : category_theory.monoidal_functor (Action V G) V
{R : Type u} [ring R] {s : set R} : s ‚äÜ ‚Üë(subring.closure s)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) [complete_space ‚Ü•K] (v : E) : E
 : name ‚Üí name
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} : (Œ± ‚äï Œ≤ ‚Ü™ Œ≥) ‚âÉ {f // disjoint (set.range ‚áë(f.fst)) (set.range ‚áë(f.snd))}
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {Œπ : Type u_6} (Z : topological_vector_bundle_core R B F Œπ) (b : B) : topological_vector_bundle.trivialization R F Z.fiber
 : tactic unit
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] {f g : ‚ÑÇ ‚Üí E} (hdf : diff_cont_on_cl ‚ÑÇ f (set.Ioi 0 √ó‚ÑÇ set.Ioi 0)) (hBf : ‚àÉ (c : ‚Ñù) (H : c < 2) (B : ‚Ñù), f =O[filter.comap complex.abs filter.at_top ‚äì filter.principal (set.Ioi 0 √ó‚ÑÇ set.Ioi 0)] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)) (hdg : diff_cont_on_cl ‚ÑÇ g (set.Ioi 0 √ó‚ÑÇ set.Ioi 0)) (hBg : ‚àÉ (c : ‚Ñù) (H : c < 2) (B : ‚Ñù), g =O[filter.comap complex.abs filter.at_top ‚äì filter.principal (set.Ioi 0 √ó‚ÑÇ set.Ioi 0)] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)) (hre : ‚àÄ (x : ‚Ñù), 0 ‚â§ x ‚Üí f ‚Üëx = g ‚Üëx) (him : ‚àÄ (x : ‚Ñù), 0 ‚â§ x ‚Üí f (‚Üëx * complex.I) = g (‚Üëx * complex.I)) : set.eq_on f g {z : ‚ÑÇ | 0 ‚â§ z.re ‚àß 0 ‚â§ z.im}
(ic : tactic.instance_cache) (n : expr) : tactic (tactic.instance_cache √ó expr √ó expr)
{K : Type u_1} {v : K} {n : ‚Ñï} [linear_ordered_field K] [floor_ring K] {b : K} (nth_part_denom_eq : (generalized_continued_fraction.of v).partial_denominators.nth n = option.some b) : ‚àÉ (z : ‚Ñ§), b = ‚Üëz
(R : Type u_1) [comm_ring R] (m k : ‚Ñï) : 2 * polynomial.chebyshev.T R m * polynomial.chebyshev.T R (m + k) = polynomial.chebyshev.T R (2 * m + k) + polynomial.chebyshev.T R k
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : category_theory.monoidal_functor C (C ‚•§ C)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (h : category_theory.mono 0) : X ‚âÖ 0
(h : name) (t : expr) : smt_tactic unit
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} : L.bounded_formula Œ± n ‚Üí L.formula Œ±
 : environment ‚Üí name ‚Üí option name
{Œ± : Type u} (s : wseq Œ±) : wseq Œ±
(J : Type u‚ÇÅ) [category_theory.category J] (C : Type u‚ÇÉ) [category_theory.category C] : (J ‚•§ C) ‚•§ C·µí·µñ ‚•§ Type (max u‚ÇÅ v‚ÇÉ)
(_x : interactive.parse (lean.parser.tk "#find")) : lean.parser unit
{Œ± : Type u_1} {Œ≤‚ÇÅ : Œ± ‚Üí Type u_2} {Œ≤‚ÇÇ : Œ± ‚Üí Type u_3} (F : Œ† (a : Œ±), Œ≤‚ÇÅ a ‚âÉ Œ≤‚ÇÇ a) : (Œ£ (a : Œ±), Œ≤‚ÇÅ a) ‚âÉ Œ£ (a : Œ±), Œ≤‚ÇÇ a
{E : Type u_1} [inner_product_space ‚Ñù E] (n : ‚Ñï) [fact (finite_dimensional.finrank ‚Ñù E = n + 1)] (v : ‚Ü•(metric.sphere 0 1)) : local_homeomorph ‚Ü•(metric.sphere 0 1) (euclidean_space ‚Ñù (fin n))
{L : first_order.language} {L' : first_order.language} (œï : L ‚Üí·¥∏ L') (M : Type u_3) [L.Structure M] [L'.Structure M] : Prop
{Œ± : Type u_1} (s : set Œ±) : Type u_1
{Œ± : Type u_1} {Œπ'' : Type u_6} [preorder Œπ''] (l : filter Œ±) (s : Œπ'' ‚Üí set Œ±) : Prop
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {D : Type u_3} [category_theory.category D] [category_theory.preadditive D] (G : C ‚•§ D) [G.additive] (X : category_theory.simplicial_object C) (q n : ‚Ñï) : (algebraic_topology.dold_kan.HœÉ q).f n = G.map ((algebraic_topology.dold_kan.HœÉ q).f n)
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_mul M] [has_mul N] : Type (max u_10 u_11 u_9)
(Œ± : Type u_3) [topological_space Œ±] : Type u_3
(n : ‚Ñï) : Type
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {D : Type u‚ÇÅ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) : category_theory.is_cofiltered D
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M ‚Üí* P} (H : c ‚â§ con.ker f) (g : c.quotient ‚Üí* P) (Hg : g.comp c.mk' = f) : g = c.lift f H
(G : Type u_1) [group G] (n : ‚Ñï) (x : G) : x ‚àà upper_central_series G (n + 1) ‚Üî ‚àÄ (y : G), x * y * x‚Åª¬π * y‚Åª¬π ‚àà upper_central_series G n
{V : Type u_1} (Œ± : Type u_2) (G : simple_graph V) [decidable_rel G.adj] [has_zero Œ±] [has_one Œ±] : matrix V V Œ±
(l : interactive.parse (lean.parser.many lean.parser.ident)) : tactic unit
(R : Type u) (S : Type v) (A : Type w) [comm_semiring R] [comm_semiring S] [semiring A] [algebra R S] [algebra S A] [algebra R A] [is_scalar_tower R S A] : S ‚Üí‚Çê[R] A
(p : ‚Ñï) [fact (nat.prime p)] (a b : ‚Ñ§) : zmod.legendre_sym p (a * b) = zmod.legendre_sym p a * zmod.legendre_sym p b
{Œ± : Type u_1} [add_comm_group Œ±] (C : add_comm_group.total_positive_cone Œ±) : linear_ordered_add_comm_group Œ±
{V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] {B : bilin_form K V} {x : V} (hx : ¬¨B.is_ortho x x) : is_compl (submodule.span K {x}) (B.orthogonal (submodule.span K {x}))
{R : Type u_1} {a b : R} [semigroup R] (rra : is_right_regular a) (rrb : is_right_regular b) : is_right_regular (a * b)
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_Sup Œ±] [has_Sup Œ≤] (f : Sup_hom Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : Sup_hom Œ± Œ≤
{m n : ‚Ñï} : bitvec m ‚Üí bitvec n ‚Üí bitvec (m + n)
(Œ± : Type u) [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±] [topological_space.separable_space Œ±] [nontrivial Œ±] : ‚àÉ (s : set Œ±), s.countable ‚àß dense s ‚àß (‚àÄ (x : Œ±), is_bot x ‚Üí x ‚àâ s) ‚àß ‚àÄ (x : Œ±), is_top x ‚Üí x ‚àâ s
{Œ± : Type v} {d u l r : ‚Ñï} (A : matrix (fin (u + d)) (fin (l + r)) Œ±) : matrix (fin d) (fin l) Œ±
(Œ± : Type u) : Type u
(X : algebraic_geometry.Scheme) [irreducible_space ‚Ü•(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)] (U : topological_space.opens ‚Ü•(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)) [h : nonempty ‚Ü•U] : X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op U) ‚ü∂ X.function_field
 : expr ‚Üí list name
{m : Type ‚Üí Type} [alternative m] : tactic.mllist m ‚Ñï
{C : Type u‚ÇÅ} [category_theory.category C] {B A : C} {X : category_theory.subobject B} (f : A ‚ü∂ B) [category_theory.mono f] (i : ‚ÜëX ‚âÖ A) (w : i.hom ‚â´ f = X.arrow) : X = category_theory.subobject.mk f
(n e : expr) : tactic expr
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÅ} [category_theory.category B] {C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÅ} [category_theory.category D] (F : A ‚•§ B) (G : C ‚•§ D) : A ‚äï C ‚•§ B ‚äï D
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) (s : alist Œ≤) : alist Œ≤
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (p : Œ† (i : fin n), Œ± (‚áëfin.cast_succ i)) (x : Œ± (fin.last n)) (i : fin (n + 1)) : Œ± i
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] [decidable_eq Œπ] [canonically_ordered_add_monoid Œπ] (ùíú : Œπ ‚Üí submodule R A) [graded_algebra ùíú] : A ‚Üí+* A
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J ‚•§ C·µí·µñ) [category_theory.limits.has_limit F.left_op] : category_theory.limits.has_colimit F
(n : Type u_1) (R : Type u‚ÇÇ) [decidable_eq n] [comm_ring R] : Type (max u_1 u‚ÇÇ)
{G‚ÇÅ : Type u_3} {G‚ÇÇ : Type u_4} {G‚ÇÉ : Type u_5} [add_group G‚ÇÅ] [add_group G‚ÇÇ] [add_group G‚ÇÉ] (f : G‚ÇÅ ‚Üí+ G‚ÇÇ) (f_inv : G‚ÇÇ ‚Üí G‚ÇÅ) (hf : function.right_inverse f_inv ‚áëf) : {g // f.ker ‚â§ g.ker} ‚âÉ (G‚ÇÇ ‚Üí+ G‚ÇÉ)
 : BoolAlg ‚•§ BoolAlg
(S‚ÇÅ : Type u_1) (S‚ÇÇ : Type u_2) [shelf S‚ÇÅ] [shelf S‚ÇÇ] : Type (max u_1 u_2)
{V : Type u} : has_compl (simple_graph V)
{p k : ‚Ñï} (hk : k ‚â† 0) (hp : nat.prime p) : (p ^ k).factors.to_finset = {p}
{Œ± : Type u} [pseudo_emetric_space Œ±] {x y : Œ±} {s : set Œ±} (hx : x ‚àà s) (hy : y ‚àà s) : has_edist.edist x y ‚â§ emetric.diam s
{C : Type u‚ÇÅ} [category_theory.category C] {X‚ÇÅ‚ÇÅ X‚ÇÅ‚ÇÇ X‚ÇÅ‚ÇÉ X‚ÇÇ‚ÇÅ X‚ÇÇ‚ÇÇ X‚ÇÇ‚ÇÉ : C} {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ‚ÇÉ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÉ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ} {v‚ÇÅ‚ÇÉ : X‚ÇÅ‚ÇÉ ‚ü∂ X‚ÇÇ‚ÇÉ} (s : category_theory.is_pullback (h‚ÇÅ‚ÇÅ ‚â´ h‚ÇÅ‚ÇÇ) v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÉ (h‚ÇÇ‚ÇÅ ‚â´ h‚ÇÇ‚ÇÇ)) (p : h‚ÇÅ‚ÇÅ ‚â´ v‚ÇÅ‚ÇÇ = v‚ÇÅ‚ÇÅ ‚â´ h‚ÇÇ‚ÇÅ) (t : category_theory.is_pullback h‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÉ h‚ÇÇ‚ÇÇ) : category_theory.is_pullback h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ
{Œ± : Type u_1} {c : set (set Œ±)} (H : ‚àÄ (a : Œ±), ‚àÉ! (b : set Œ±) (H : b ‚àà c), a ‚àà b) : c.pairwise_disjoint id
(S : set ordinal) : ordinal ‚Üí ordinal
{x : ‚Ñù} (hx : 0 < x) : 0 < exp_neg_inv_glue x
(p : omega.nat.preform) : Prop
{p : ‚Ñï} [hp : fact (nat.prime p)] {k : Type u_1} [field k] [char_p k p] [perfect_ring k p] : discrete_valuation_ring (witt_vector p k)
(k : Type u‚ÇÅ) {G : Type u‚ÇÇ} [semiring k] [has_add G] {A : Type u‚ÇÉ} [non_unital_non_assoc_semiring A] [distrib_mul_action k A] {œÜ‚ÇÅ œÜ‚ÇÇ : add_monoid_algebra k G ‚Üí‚Çô‚Çê[k] A} (h : œÜ‚ÇÅ.to_mul_hom.comp (add_monoid_algebra.of_magma k G) = œÜ‚ÇÇ.to_mul_hom.comp (add_monoid_algebra.of_magma k G)) : œÜ‚ÇÅ = œÜ‚ÇÇ
{L : first_order.language} {M : Type w} [L.Structure M] {Œ± : Type u'} {l : ‚Ñï} (f : L.bounded_formula Œ± l) (v : Œ± ‚Üí M) (xs : fin l ‚Üí M) : Prop
(h lhs : expr) : tactic expr
 : tactic.ring_exp.ex tactic.ring_exp.ex_type.sum ‚Üí tactic.ring_exp.ex tactic.ring_exp.ex_type.prod ‚Üí tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum)
{K : Type u_1} [field K] (A : valuation_subring K) : prime_spectrum ‚Ü•A ‚âÉ ‚Ü•{S : valuation_subring K | A ‚â§ S}
{Œ± : Type u_1} [decidable_eq Œ±] (s : finset Œ±) : finset (finset Œ±)
{T : Type u} [category_theory.category T] {X Y : T} (f : X ‚ü∂ Y) : category_theory.arrow T
{Œ± : Type u_1} {p : Œ± ‚Üí Prop} [decidable_pred p] {s : finset Œ±} (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p x) : finset.filter p s = s
{a b : cardinal} : cardinal.aleph_0 ‚â§ a * b ‚Üî a ‚â† 0 ‚àß b ‚â† 0 ‚àß (cardinal.aleph_0 ‚â§ a ‚à® cardinal.aleph_0 ‚â§ b)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {X X' Y Y' Z Z' : C} [category_theory.exact_pairing Y Y'] (f : X ‚ü∂ Z ‚äó Y') (g : X' ‚ü∂ Z') : ‚áë((category_theory.tensor_right_hom_equiv (X' ‚äó X) Y Y' (Z' ‚äó Z)).symm) ((g ‚äó f) ‚â´ (Œ±_ Z' Z Y').inv) = (Œ±_ X' X Y).hom ‚â´ (g ‚äó ‚áë((category_theory.tensor_right_hom_equiv X Y Y' Z).symm) f)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (direction : submodule k V) : affine_subspace k P
{Œ± : Sort u} {Œ≤ : Sort v} {ra : setoid Œ±} {rb : setoid Œ≤} (e : Œ± ‚âÉ Œ≤) (eq : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±), setoid.r a‚ÇÅ a‚ÇÇ ‚Üî setoid.r (‚áëe a‚ÇÅ) (‚áëe a‚ÇÇ)) : quotient ra ‚âÉ quotient rb
{Œ± : Type u_1} : Œ± ‚âÉ Œ±·µí·µà
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [baire_space Œ±] [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±} (hc : ‚àÄ (s : Œ≤), is_closed (f s)) (hU : (‚ãÉ (s : Œ≤), f s) = set.univ) : dense (‚ãÉ (s : Œ≤), interior (f s))
{L : first_order.language} {M : Type w} [L.Structure M] : has_top (L.substructure M)
(R : Type u_1) (A : Type u_2) (M : Type u_4) (N : Type u_5) [comm_semiring R] [semiring A] [algebra R A] [add_comm_monoid M] [module R M] [add_comm_monoid N] [module R N] : (M ‚Üí‚Çó[R] N) ‚Üí‚Çó[R] tensor_product R A M ‚Üí‚Çó[A] tensor_product R A N
 : absolute_value.abs.is_admissible
{Œ± : Sort u_1} {s‚ÇÅ : setoid Œ±} (a : quotient s‚ÇÅ) : Œ±
 : lean.parser string
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (L' : lie_subalgebra R L) {M : Type w} [add_comm_group M] [lie_ring_module L M] : lie_ring_module ‚Ü•L' M
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] {D : Type u‚ÇÅ} [category_theory.category D] [category_theory.preadditive D] [category_theory.limits.has_finite_biproducts D] (F : C ‚•§ D) [F.additive] : category_theory.Mat_ C ‚•§ D
 : expr ‚Üí tactic ‚Ñï
(f : ‚Ñï ‚Üí nnreal) : filter.tendsto (Œª (i : ‚Ñï), ‚àë' (k : ‚Ñï), f (k + i)) filter.at_top (nhds 0)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : Type w) [category_theory.category J] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ w w')
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (b : category_theory.limits.binary_bicone X Y) (total : b.fst ‚â´ b.inl + b.snd ‚â´ b.inr = ùüô b.X) : category_theory.limits.has_binary_biproduct X Y
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} [discrete_topology ‚Ü•s] {x : Œ±} (hx : x ‚àà s) : ‚àÉ (U : set Œ±) (H : U ‚àà nhds x), U ‚à© s = {x}
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [dec : decidable_eq Œπ] [Œ† (i : Œπ), has_zero (Œ≤ i)] (i : Œπ) (f : Œ†‚ÇÄ (i : Œπ), Œ≤ i) (b : Œ≤ i) [decidable (b = 0)] : Œ†‚ÇÄ (i : Œπ), Œ≤ i
{Œ± : Type u} {Œ≤ : Type v} [complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [complete_linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] {Œπ : Sort u_1} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±} (Cf : continuous_at f (infi g)) (Mf : monotone f) (ftop : f ‚ä§ = ‚ä§) : f (infi g) = infi (f ‚àò g)
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] (f : S.localization_map N) (x : M) (y : ‚Ü•S) : N
(F : Type u ‚Üí Type w) (G : Type v ‚Üí Type u) (Œ± : Type v) : Type w
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [add_group Œ±] [uniform_add_group Œ±] {hom : Type u_3} [uniform_space Œ≤] [discrete_topology Œ≤] [add_group Œ≤] [uniform_add_group Œ≤] [add_monoid_hom_class hom Œ± Œ≤] {f : hom} : uniform_continuous ‚áëf ‚Üî is_open ‚Üë(‚Üëf.ker)
{Œ± : Type u} [topological_space Œ±] {Z a b : set Œ±} (h : is_clopen Z) (cover : Z ‚äÜ a ‚à™ b) (ha : is_open a) (hb : is_open b) (hab : a ‚à© b = ‚àÖ) : is_clopen (Z ‚à© a)
 : turing.partrec_to_TM2.Œõ' ‚Üí turing.partrec_to_TM2.stmt'
{p : ‚Ñï} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (n : ‚Ñï) : witt_vector p R ‚Üí+* R
{Œπ : Type u_1} {Œ± : Type u_2} [has_zero Œ±] {s : finset Œπ} {f : Œπ ‚Üí‚ÇÄ Œ±} {t : Œπ ‚Üí‚ÇÄ finset Œ±} (ht : t.support ‚äÜ s) : f ‚àà s.finsupp ‚áët ‚Üî ‚àÄ (i : Œπ), ‚áëf i ‚àà ‚áët i
(X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] : isometry (Gromov_Hausdorff.optimal_GH_injr X Y)
(t : expr ‚Üí tactic unit) : tactic unit
{L : first_order.language} {L' : first_order.language} {L'' : first_order.language} (g : L' ‚Üí·¥∏ L'') (f : L ‚Üí·¥∏ L') : L ‚Üí·¥∏ L''
(Œ± : Type u) [ring Œ±] : Type u
{Œ± : Type u_1} {Œ≤ : Type u_2} (x : Œ±) : functor.const Œ± Œ≤
{n : Type u_3} [fintype n] {Œ± : n ‚Üí Type v} (v : Œ† (j : n), Œ± j) : dmatrix unit n (Œª (i : unit) (j : n), Œ± j)
{Œ± : Sort u} (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
(Œ± : Type u) [has_le Œ±] : Type u
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (f : Œ≤ ‚Üí. Œ≥) (g : Œ± ‚Üí. Œ≤) : Œ± ‚Üí. Œ≥
(g : Type) (Œ± : Type u) : Type u
{R : Type u_1} [add_left_cancel_semigroup R] (g : R) : is_add_left_regular g
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_mono f] : category_theory.split_epi (category_theory.retraction f)
{M : Type u_1} [has_mul M] (s : set M) : subsemigroup M
{X Y : Top} (f : X ‚ü∂ Y) (U : topological_space.opens ‚Ü•X) : U ‚ü∂ (topological_space.opens.map f).obj ‚ä§
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] [ring_hom_surjective œÉ‚ÇÅ‚ÇÇ] (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : submodule R‚ÇÇ M‚ÇÇ
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] {b : category_theory.limits.binary_bicone X Y} (hb : b.is_bilimit) : b.X ‚âÖ X ‚äû Y
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : list Œ± ‚Üí Œ± ‚Üí list Œ± ‚Üí Œ≤) (l : list Œ±) : list Œ≤
 : box_integral.integration_params
{s : ‚ÑÇ} (hs : 0 < s.re) {X : ‚Ñù} (hX : 0 ‚â§ X) : (s + 1).partial_Gamma X = s * s.partial_Gamma X - ‚Üë(real.exp (-X)) * ‚ÜëX ^ s
{G : Type u} [group G] : G ‚Üí* abelianization G
(r : ‚Ñù) : nnreal
(C : Type u‚ÇÅ) [category_theory.category C] : category_theory.skeleton C ‚•§ C
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] : category_theory.limits.cokernel_cofork category_theory.limits.biprod.inr
(u : Set) : set Set
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {p : formal_multilinear_series ùïú E F} {x : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) (y : E) : has_fpower_series_on_ball (Œª (z : E), f (z - y)) p (x + y) r
{Œ± : Type u_1} [canonically_ordered_add_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {b c : Œ±} [contravariant_class Œ± Œ± has_add.add has_le.le] (h : c ‚â§ b) (a : Œ±) : a + b - c = a + (b - c)
(n : ‚Ñï) (x : ‚Ñù) (hx : 0 < x) : has_deriv_at (exp_neg_inv_glue.f_aux n) (polynomial.eval x (exp_neg_inv_glue.P_aux (n + 1)) * real.exp (-x‚Åª¬π) / x ^ (2 * (n + 1))) x
{Œ± : Type u_2} {Œ≤ : Type u_3} [complete_lattice Œ±] [complete_lattice Œ≤] : complete_lattice_hom Œ± Œ≤ ‚âÉ complete_lattice_hom Œ±·µí·µà Œ≤·µí·µà
(x y : omega.nat.preterm) (k : ‚Ñï) : omega.nat.preform ‚Üí omega.nat.preform
{C : Type u‚ÇÅ} [category_theory.category C] (J : category_theory.grothendieck_topology C) (P : C·µí·µñ ‚•§ Type w) : Prop
{G : Type u_1} [group G] {N : Type u_3} [group N] {f : G ‚Üí* N} {g : N ‚Üí* G} (h : function.left_inverse ‚áëg ‚áëf) : G ‚âÉ* ‚Ü•(f.range)
{C : Type u} [category_theory.category C] (F G : category_theory.discrete pempty ‚•§ C) : F = G
{X : Top} (T : Top) : Top.sheaf (Type v) X
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
 : znum ‚Üí znum ‚Üí ordering
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommSemiRing) : CommSemiRing
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) (p q : submodule R (clifford_algebra Q)) : submodule.map clifford_algebra.reverse (p * q) = submodule.map clifford_algebra.reverse q * submodule.map clifford_algebra.reverse p
{Œ± : Type u} (a : Œ±) : stream Œ±
{Œ±‚ÇÅ : Type u_5} {Œ±‚ÇÇ : Type u_6} {Œ≤‚ÇÅ : Type u_7} {Œ≤‚ÇÇ : Type u_8} [topological_space Œ±‚ÇÅ] [topological_space Œ±‚ÇÇ] [topological_space Œ≤‚ÇÅ] [topological_space Œ≤‚ÇÇ] (f : C(Œ±‚ÇÅ, Œ±‚ÇÇ)) (g : C(Œ≤‚ÇÅ, Œ≤‚ÇÇ)) : C(Œ±‚ÇÅ √ó Œ≤‚ÇÅ, Œ±‚ÇÇ √ó Œ≤‚ÇÇ)
{Œπ : Type u_1} [fintype Œπ] : std_simplex ‚Ñù Œπ ‚äÜ metric.closed_ball 0 1
 : tactic.simp_arg_type ‚Üí list (expr √ó expr) ‚Üí tactic.simp_arg_type
{K : Type u} [comm_ring K] {p : ‚Ñï} [fact (nat.prime p)] [char_p K p] {L : Type u_1} (x : perfect_closure K p) (f : ‚Ñï √ó K ‚Üí L) (hf : ‚àÄ (x y : ‚Ñï √ó K), perfect_closure.r K p x y ‚Üí f x = f y) : L
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} : category_theory.is_iso (category_theory.limits.kernel.Œπ 0)
(Œì : Type u_1) [inhabited Œì] : setoid (list Œì)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] : reflection ‚ä• = linear_isometry_equiv.neg ùïú
{E : Type u_1} [add_comm_group E] [module ‚Ñù E] {s : set E} {x : E} : gauge s x = has_Inf.Inf {r ‚àà set.Ioi 0 | r‚Åª¬π ‚Ä¢ x ‚àà s}
{Œ± : Type u} (t : tactic Œ±) : tactic (option Œ±)
{R : Type u_1} [comm_semiring R] {A : Type u_2} [comm_semiring A] [algebra R A] {M : Type u_3} [add_comm_monoid M] [module A M] [module R M] {D1 D2 : derivation R A M} (s : set A) (hs : algebra.adjoin R s = ‚ä§) (h : set.eq_on ‚áëD1 ‚áëD2 s) : D1 = D2
(Œ± : Type u_1) [nonempty Œ±] [fintype Œ±] : trunc Œ±
{A : Type u_1} {B : Type u_2} (R : Type u_3) [semiring R] [add_comm_group A] [add_comm_group B] [module R B] : (A ‚Üí+ B) ‚âÉ‚Çó[R] A ‚Üí‚Çó[‚Ñ§] B
{X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] (d : ‚Ñù) (s : set X) : ‚áë(measure_theory.measure.hausdorff_measure d) s = ‚®Ü (r : ennreal) (hr : 0 < r), ‚®Ö (t : ‚Ñï ‚Üí set X) (hts : s ‚äÜ ‚ãÉ (n : ‚Ñï), t n) (ht : ‚àÄ (n : ‚Ñï), emetric.diam (t n) ‚â§ r), ‚àë' (n : ‚Ñï), ‚®Ü (h : (t n).nonempty), emetric.diam (t n) ^ d
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] (l : list Œ±) (hp : ‚àÉ (a : Œ±), a ‚àà l ‚àß p a) : Œ±
 : topological_space.second_countable_topology Gromov_Hausdorff.GH_space
{C : Type u} [category_theory.category C] [category_theory.abelian C] (P : C) : setoid (category_theory.over P)
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] (f g : linear_pmap R E F) (h : ‚àÄ (x : ‚Ü•(f.domain)) (y : ‚Ü•(g.domain)), ‚Üëx = ‚Üëy ‚Üí ‚áëf x = ‚áëg y) : linear_pmap R E F
 : Type ‚Üí Type
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] {Œ¥ : Type w} (m : hash_map Œ± Œ≤) (d : Œ¥) (f : Œ¥ ‚Üí Œ† (a : Œ±), Œ≤ a ‚Üí Œ¥) : Œ¥
{x y z : pgame} (h‚ÇÅ : x ‚â§ y) (h‚ÇÇ : y.lf z) : x.lf z
{F : Type u_1} [field F] (p : polynomial F) (E : Type u_2) [field E] [algebra F E] [fact (polynomial.splits (algebra_map F E) p)] : ‚Ü•(p.root_set p.splitting_field) ‚Üí ‚Ü•(p.root_set E)
{Œ± : Type u} [linear_order Œ±] {a b c : Œ±} : set.interval a c ‚äÜ set.interval a b ‚à™ set.interval b c
{R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] [finite_dimensional R M] (x : orientation R M Œπ) (f : M ‚âÉ‚Çó[R] M) (h : fintype.card Œπ = finite_dimensional.finrank R M) : ‚áë(orientation.map Œπ f) x = (‚áëlinear_equiv.det f)‚Åª¬π ‚Ä¢ x
{Œ± : Type u} [linear_order Œ±] : is_idempotent Œ± linear_order.max
{H : Type u_1} [topological_space H] (G : structure_groupoid H) {M : Type u_2} [topological_space M] [charted_space H M] [has_groupoid M G] {e e' : local_homeomorph M H} (he : e ‚àà charted_space.atlas H M) (he' : e' ‚àà charted_space.atlas H M) : e.symm.trans e' ‚àà G
(R : Type u_4) [has_mul R] [has_add R] : R ‚âÉ+* R
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b : Œ±} (ha : a < 0) (hb : b < 0) : a + b < 0
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) (s : category_theory.limits.cocone F) : Mon.colimits.colimit_type F ‚Üí ‚Ü•(s.X)
 : ‚Ñù ‚Üí ‚Ñù
{Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} (f : function.extfun Œ± Œ≤) (x : Œ±) : Œ≤ x
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space F] (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ‚ä§) (hker : f'.ker.closed_complemented) : implicit_function_data ùïú E F ‚Ü•(f'.ker)
{m : Type u_2} {R : Type u_7} {Œ± : Type v} {Œ≤ : Type w} [fintype m] [decidable_eq m] [comm_semiring R] [semiring Œ±] [semiring Œ≤] [algebra R Œ±] [algebra R Œ≤] (f : Œ± ‚âÉ‚Çê[R] Œ≤) : matrix m m Œ± ‚âÉ‚Çê[R] matrix m m Œ≤
(t : omega.term) : list bool
{ùïú : Type u_1} {V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_3} {P‚ÇÅ : Type u_4} {P‚ÇÇ : Type u_5} [normed_field ùïú] [normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] [normed_space ùïú V‚ÇÅ] [normed_space ùïú V‚ÇÇ] [metric_space P‚ÇÅ] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V‚ÇÅ P‚ÇÅ] [normed_add_torsor V‚ÇÇ P‚ÇÇ] [finite_dimensional ùïú V‚ÇÅ] [finite_dimensional ùïú V‚ÇÇ] [inhabited P‚ÇÅ] (li : P‚ÇÅ ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ) (h : finite_dimensional.finrank ùïú V‚ÇÅ = finite_dimensional.finrank ùïú V‚ÇÇ) : P‚ÇÅ ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÇ
{Œ± : Type u_1} [fintype Œ±] [field Œ±] : is_prime_pow (fintype.card Œ±)
{A : Type u_4} [add_comm_monoid A] (x : A) {B : Type u_5} [add_comm_monoid B] (F : add_submonoid.localization_map.away_map x B) {C : Type u_6} [add_comm_monoid C] (y : A) (G : add_submonoid.localization_map.away_map (x + y) C) : B ‚Üí+ C
{Œ± : Type u_1} : has_mem (set Œ±) (filter Œ±)
 : pSet
{ùïú : Type u_3} {G : Type u_4} [is_R_or_C ùïú] [normed_group G] [normed_space ùïú G] {f f' : ùïú ‚Üí G} {s : set ùïú} {C : nnreal} (hs : convex ‚Ñù s) (hf : ‚àÄ (x : ùïú), x ‚àà s ‚Üí has_deriv_within_at f (f' x) s x) (bound : ‚àÄ (x : ùïú), x ‚àà s ‚Üí ‚à•f' x‚à•‚Çä ‚â§ C) : lipschitz_on_with C f s
(X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] : compact_space (Gromov_Hausdorff.optimal_GH_coupling X Y)
{X Y : Type u} [has_mul X] [has_mul Y] : X ‚âÉ* Y ‚âÖ Magma.of X ‚âÖ Magma.of Y
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) : P √ó ‚Ñù
 : ‚Ñï ‚Üí list ‚Ñï
{A : Type u_1} {B : Type u_2} {K : Type u_3} {L : Type u_4} [comm_ring A] [comm_ring B] [is_domain B] [comm_ring K] [algebra A K] [is_fraction_ring A K] [comm_ring L] [algebra B L] [is_fraction_ring B L] {j : A ‚Üí+* B} (hj : function.injective ‚áëj) : K ‚Üí+* L
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) : (-o).oangle x y = -o.oangle x y
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [add_zero_class Œ±] [add_zero_class Œ≤] : has_coe_to_fun (Œ± ‚Üí+o Œ≤) (Œª (_x : Œ± ‚Üí+o Œ≤), Œ± ‚Üí Œ≤)
{Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≥ : Type u_5} [add_comm_monoid Œ±] {f : Œ≤ ‚Üí Œ±} {g : Œ≥ ‚Üí Œ±} (h_eq : ‚àÄ (u : finset Œ≥), ‚àÉ (v : finset Œ≤), ‚àÄ (v' : finset Œ≤), v ‚äÜ v' ‚Üí (‚àÉ (u' : finset Œ≥), u ‚äÜ u' ‚àß u'.sum (Œª (x : Œ≥), g x) = v'.sum (Œª (b : Œ≤), f b))) : filter.map (Œª (s : finset Œ≤), s.sum (Œª (b : Œ≤), f b)) filter.at_top ‚â§ filter.map (Œª (s : finset Œ≥), s.sum (Œª (x : Œ≥), g x)) filter.at_top
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [nondiscrete_normed_field ùïÇ] [normed_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] [char_zero ùïÇ] {x : ùî∏} (hx : x ‚àà emetric.ball 0 (exp_series ùïÇ ùî∏).radius) : invertible (exp ùïÇ x)
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J ‚•§ C·µí·µñ) {c : category_theory.limits.cocone F.left_op} (hc : category_theory.limits.is_colimit c) : category_theory.limits.is_limit (category_theory.limits.cone_of_cocone_left_op c)
{C : Type u‚ÇÅ} [category_theory.category C] {T‚ÇÅ : category_theory.monad C} : category_theory.monad.algebra_functor_of_monad_hom (ùüô T‚ÇÅ) ‚âÖ ùü≠ T‚ÇÅ.algebra
{Œ± : Type u_2} [subtraction_comm_monoid Œ±] : subtraction_comm_monoid (filter Œ±)
(h_equality : expr) : tactic expr
{Œ± : Type u_1} {m : measurable_space Œ±} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [topological_space M] [add_comm_monoid N] [topological_space N] (v : measure_theory.vector_measure Œ± M) (w : measure_theory.vector_measure Œ± N) : Prop
 : Type
{G : Type u_3} [group G] : group.fg G ‚Üî monoid.fg G
(R : Type u) (M : Type v) (M‚ÇÇ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] : submodule R (M √ó M‚ÇÇ)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ v‚ÇÅ v‚ÇÇ)
 : Type
{R : Type u} {n : ‚Ñï} {M : fin n.succ ‚Üí Type v} {M‚ÇÇ : Type v‚ÇÇ} [comm_semiring R] [Œ† (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : fin n.succ), module R (M i)] [module R M‚ÇÇ] (f : multilinear_map R (Œª (i : fin n), M (‚áëfin.cast_succ i)) (M (fin.last n) ‚Üí‚Çó[R] M‚ÇÇ)) : multilinear_map R M M‚ÇÇ
(R : Type u_8) (S : Type u_9) [comm_ring R] [ring S] [algebra R S] : Type (max u_8 u_9)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P (n + 1)) (i : fin (n + 2)) : affine_subspace ‚Ñù P
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : free_add_monoid (M √ó N) ‚Üí free_add_monoid (M √ó N) ‚Üí Prop
{Œ± : Type u_1} [preorder Œ±] [order_bot Œ±] (a : Œ±) : Prop
 : sign_type ‚âÉ* fin 3
 : expr ‚Üí option (name √ó expr)
(ic : tactic.instance_cache) (e : expr) : tactic (tactic.instance_cache √ó expr √ó expr)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ‚ü∂ Q) (x y : ‚Ü•P) : ‚áëf x = ‚áëf y ‚Üí (‚àÉ (z : ‚Ü•P), ‚áëf z = 0 ‚àß ‚àÄ (R : C) (g : P ‚ü∂ R), ‚áëg y = 0 ‚Üí ‚áëg z = ‚áëg x)
(p : ‚Ñï) [p_prime : fact (nat.prime p)] {q : ‚Ñö} (hq : q ‚â† 0) {k : ‚Ñï} : padic_val_rat p (q ^ k) = ‚Üëk * padic_val_rat p q
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (S : C ‚•§ D) (T : D) : Type (max u‚ÇÅ v‚ÇÇ)
 : fourier_subalgebra.topological_closure = ‚ä§
{n : ‚Ñï} {Œ± : typevec n} (p : (Œ±.prod Œ±).arrow (typevec.repeat n Prop)) : (typevec.subtype_ p).arrow (Œª (i : fin2 n), {x // typevec.of_repeat (p i (typevec.prod.mk i x.fst x.snd))})
 : Type
{Œ± : Type u} : wseq Œ±
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] (x : ùïú) {ùïú' : Type u_1} [nondiscrete_normed_field ùïú'] [normed_algebra ùïú ùïú'] [normed_space ùïú' F] [is_scalar_tower ùïú ùïú' F] {h : ùïú ‚Üí ùïú'} {h' : ùïú'} {g‚ÇÅ : ùïú' ‚Üí F} {g‚ÇÅ' : F} (hg : has_deriv_at g‚ÇÅ g‚ÇÅ' (h x)) (hh : has_deriv_at h h' x) : has_deriv_at (g‚ÇÅ ‚àò h) (h' ‚Ä¢ g‚ÇÅ') x
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (p : Œπ ‚Üí P) : (Œπ ‚Üí k) ‚Üí·µÉ[k] P
(Œ± : Type u_1) [has_one Œ±] : Type u_1
{f : ‚Ñù ‚Üí ‚Ñù} (hf : differentiable ‚Ñù f) (hf'_mono : strict_mono (deriv f)) : strict_convex_on ‚Ñù set.univ f
(R : Type u) (K : Type v) [comm_ring R] [field K] [algebra R K] [no_zero_smul_divisors R K] : Prop
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {f : ‚ÑÇ ‚Üí E} {c : ‚ÑÇ} (hd : ‚àÄ·∂† (z : ‚ÑÇ) in nhds_within c {c}·∂ú, differentiable_at ‚ÑÇ f z) (ho : (Œª (z : ‚ÑÇ), f z - f c) =o[nhds_within c {c}·∂ú] Œª (z : ‚ÑÇ), (z - c)‚Åª¬π) : filter.tendsto f (nhds_within c {c}·∂ú) (nhds (lim (nhds_within c {c}·∂ú) f))
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a : Œ±} : 0 < -a ‚Üí a < 0
{E : ‚Ñï ‚Üí Type u_1} [Œ† (n : ‚Ñï), topological_space (E n)] [‚àÄ (n : ‚Ñï), discrete_topology (E n)] {s : set (Œ† (n : ‚Ñï), E n)} (hs : is_closed s) (hne : s.nonempty) : ‚àÉ (f : (Œ† (n : ‚Ñï), E n) ‚Üí Œ† (n : ‚Ñï), E n), (‚àÄ (x : Œ† (n : ‚Ñï), E n), x ‚àà s ‚Üí f x = x) ‚àß set.range f = s ‚àß continuous f
{S : Type u_2} [comm_ring S] {K : Type u_4} [field K] [algebra K S] (pb : power_basis K S) : ‚áë(algebra.norm K) pb.gen = (-1) ^ pb.dim * (minpoly K pb.gen).coeff 0
{M : Type u} {N : Type v} [monoid M] [monoid N] (f : M ‚Üí* N) : MÀ£ ‚Üí* NÀ£
{G : Type u_1} [add_group G] {N : Type u_2} [add_group N] (f : G ‚Üí+ N) (H : add_subgroup N) : add_subgroup G
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_zero_object C] : category_theory.limits.cokernel_cofork f
(A : Type u_1) [comm_semiring A] : mv_polynomial A ‚Ñï ‚Üí+* A
{m : Type v ‚Üí Type w} [applicative m] {Œ± : Type u_1} {Œ≤ : Type v} (f : ‚Ñï ‚Üí Œ± ‚Üí m Œ≤) (as : list Œ±) : m (list Œ≤)
{M : Type u_2} {Œ± : Sort u_4} [comm_monoid M] {f : Œ± ‚Üí M} (p : M ‚Üí Prop) (hp‚ÇÄ : p 1) (hp‚ÇÅ : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x * y)) (hp‚ÇÇ : ‚àÄ (i : Œ±), p (f i)) : p (finprod (Œª (i : Œ±), f i))
{n : ‚Ñï} : bitvec n ‚Üí ‚Ñ§
{F : Type u ‚Üí Type u} [functor F] [q : qpf F] : (qpf.P F).W ‚Üí (qpf.P F).W
{Œ± : Type} (m : ‚Ñï) (a : Œ±) (v : ‚Ñï ‚Üí Œ±) : ‚Ñï ‚Üí Œ±
{p : ‚Ñï ‚Üí Prop} [decidable_pred p] (H : ‚àÉ (n : ‚Ñï), p n) : ‚Ñï
(e : expr) : tactic bool
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] [normed_group F] [normed_space ‚Ñù F] [measurable_space E] [borel_space E] [topological_space.second_countable_topology F] (f : E ‚Üí F) (s : set E) (f' : E ‚Üí (E ‚ÜíL[‚Ñù] F)) (hf' : ‚àÄ (x : E), x ‚àà s ‚Üí has_fderiv_within_at f (f' x) s x) (r : (E ‚ÜíL[‚Ñù] F) ‚Üí nnreal) (rpos : ‚àÄ (A : E ‚ÜíL[‚Ñù] F), r A ‚â† 0) : ‚àÉ (t : ‚Ñï ‚Üí set E) (A : ‚Ñï ‚Üí (E ‚ÜíL[‚Ñù] F)), pairwise (disjoint on t) ‚àß (‚àÄ (n : ‚Ñï), measurable_set (t n)) ‚àß (s ‚äÜ ‚ãÉ (n : ‚Ñï), t n) ‚àß (‚àÄ (n : ‚Ñï), approximates_linear_on f (A n) (s ‚à© t n) (r (A n))) ‚àß (s.nonempty ‚Üí ‚àÄ (n : ‚Ñï), ‚àÉ (y : E) (H : y ‚àà s), A n = f' y)
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.snd
{p : ‚Ñï} (hp : nat.prime p) {n : ‚Ñï} (hn : 0 < n) : (p ^ n).totient = p ^ (n - 1) * (p - 1)
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [pseudo_emetric_space Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : measurable f) (s : set Œ±) (y‚ÇÄ : Œ±) (h‚ÇÄ : y‚ÇÄ ‚àà s) [topological_space.separable_space ‚Ü•s] (n : ‚Ñï) : measure_theory.simple_func Œ≤ Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] {B : Type u‚ÇÉ} [category_theory.category B] {J : category_theory.grothendieck_topology C} (F : A ‚•§ B) (P : C·µí·µñ ‚•§ A) {X : C} (S : J.cover X) : F.map_cone (S.multifork P) ‚âÖ (category_theory.limits.cones.postcompose (category_theory.grothendieck_topology.cover.multicospan_comp F P S).hom).obj (S.multifork (P ‚ãô F))
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F : J ‚•§ C} [category_theory.limits.has_limit F] (t : category_theory.limits.limit_cone F) : category_theory.limits.limit F ‚âÖ t.cone.X
(ùïú : Type u_1) (Œπ : Type u_5) [ordered_semiring ùïú] [fintype Œπ] : set (Œπ ‚Üí ùïú)
(X : Top) (T : Type u) : (X.presheaf_to_Type T).is_sheaf
{Œ± : Type u_2} [has_zero Œ±] : has_zero (set Œ±)
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_le Œ±] [order_top Œ±] [has_le Œ≤] [order_top Œ≤] : top_hom Œ± Œ≤ ‚âÉ bot_hom Œ±·µí·µà Œ≤·µí·µà
 : filter.tendsto (Œª (x : ‚Ñù), x ^ (1 / x)) filter.at_top (nhds 1)
(d : declaration) : tactic (expr √ó expr)
(K : Type u) [field K] (V : Type v) [add_comm_group V] [module K V] [finite_dimensional K V] : (linear_map.rtensor (module.dual K V) (contract_left K V)).comp ((tensor_product.assoc K (module.dual K V) V (module.dual K V)).symm.to_linear_map.comp (linear_map.ltensor (module.dual K V) (coevaluation K V))) = (tensor_product.lid K (module.dual K V)).symm.to_linear_map.comp (tensor_product.rid K (module.dual K V)).to_linear_map
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí finset Œ≤) (h : (set.range f).finite) : (‚ãÉ (a : Œ±), ‚Üë(f a)).finite
 : turing.to_partrec.cont ‚Üí list (list ‚Ñï)
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_well_order Œ± r] (o : ordinal) : o < ordinal.type r ‚Üí Œ±
 : widget.tc expr empty
 : star_ring ‚ÑÇ
{M : Type u_1} [add_group M] (c : add_con M) : has_neg c.quotient
(Œ± : Type u) {Œ≤ : Type v} [add_group Œ±] [add_action Œ± Œ≤] (x : Œ≤) (g : Œ± ‚ß∏ add_action.stabilizer Œ± x) : Œ≤
(V : Type u) : ulift V ‚âÖ V
 : tactic unit
(A : Type u) [add_group A] : Type u
{C : Type u‚ÇÅ} [category_theory.category C] (A B : C·µí·µñ) : (A ‚âÖ B) ‚âÉ (opposite.unop B ‚âÖ opposite.unop A)
{Œ± : Type u_1} {Œ≤ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] {ŒΩ : measure_theory.measure Œ≤} [measure_theory.sigma_finite ŒΩ] {f : Œ± √ó Œ≤ ‚Üí ennreal} (hf : measurable f) : measurable (Œª (x : Œ±), ‚à´‚Åª (y : Œ≤), f (x, y) ‚àÇŒΩ)
{Œ± : Type u_1} [decidable_eq Œ±] {s t : finset Œ±} (h : s ‚äÜ t) : (finset.Ico s t).card = 2 ^ (t.card - s.card) - 1
{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : polynomial R
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (R : D ‚•§ C) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{T : Type u‚ÇÅ} [category_theory.category T] (X : T) : category_theory.over X ‚•§ T
{A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : (minpoly A x).coeff 0 = 0 ‚Üî x = 0
{Œπ : Type u} {f g : Œπ ‚Üí ‚Ñù} {p : ‚Ñù} (hp : 1 ‚â§ p) (hf : ‚àÄ (i : Œπ), 0 ‚â§ f i) (hg : ‚àÄ (i : Œπ), 0 ‚â§ g i) {A B : ‚Ñù} (hA : 0 ‚â§ A) (hB : 0 ‚â§ B) (hfA : has_sum (Œª (i : Œπ), f i ^ p) (A ^ p)) (hgB : has_sum (Œª (i : Œπ), g i ^ p) (B ^ p)) : ‚àÉ (C : ‚Ñù), 0 ‚â§ C ‚àß C ‚â§ A + B ‚àß has_sum (Œª (i : Œπ), (f i + g i) ^ p) (C ^ p)
 : tactic unit
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) : M ‚Üí‚Çó[R] direct_sum (zmod 2) (Œª (i : zmod 2), ‚Ü•(clifford_algebra.even_odd Q i))
(Œ± : Type u) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {ùïú : Type u_3} {G : Type u_4} [is_R_or_C ùïú] [normed_space ùïú E] [normed_group G] [normed_space ùïú G] {f : E ‚Üí G} {s : set E} {x y : E} (hs : convex ‚Ñù s) (hf : differentiable_on ùïú f s) (hf' : ‚àÄ (x : E), x ‚àà s ‚Üí fderiv_within ùïú f s x = 0) (hx : x ‚àà s) (hy : y ‚àà s) : f x = f y
{E : Type u_1} [add_comm_group E] [module ‚Ñù E] [topological_space E] [has_continuous_smul ‚Ñù E] [t2_space E] {A : Type u_2} [topological_space A] [ring A] [algebra ‚Ñù A] [module A E] [has_continuous_smul ‚Ñù A] [has_continuous_smul A E] : is_scalar_tower ‚Ñù A E
(C : Type u‚ÇÅ) [category_theory.category C] {F‚ÇÅ : category_theory.discrete pempty ‚•§ C} {F‚ÇÇ : category_theory.discrete pempty ‚•§ C} (c‚ÇÅ : category_theory.limits.cocone F‚ÇÅ) (c‚ÇÇ : category_theory.limits.cocone F‚ÇÇ) (h : c‚ÇÅ.X ‚âÖ c‚ÇÇ.X) : category_theory.limits.is_colimit c‚ÇÅ ‚âÉ category_theory.limits.is_colimit c‚ÇÇ
{Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) (i : Œπ) : local_equiv Z.total_space (B √ó F)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} (p : Œπ ‚Üí P) (i‚ÇÄ : Œπ) : vector_span k (set.range p) = submodule.span k (set.range (Œª (i : {x // x ‚â† i‚ÇÄ}), p ‚Üëi -·µ• p i‚ÇÄ))
{Œ± : Type u_1} [preorder Œ±] (succ : Œ± ‚Üí Œ±) (hsucc_le_iff : ‚àÄ {a b : Œ±}, succ a ‚â§ b ‚Üî a < b) (hle_of_lt_succ : ‚àÄ {a b : Œ±}, a < succ b ‚Üí a ‚â§ b) : succ_order Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {Z X Y : C} {c : category_theory.limits.binary_cofan X Y} (h : category_theory.limits.is_colimit c) (t : category_theory.limits.is_initial Z) : category_theory.is_pushout (t.to ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left})) (t.to ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right})) c.inl c.inr
{R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] [nontrivial R] {Œπ : Type w} (b : basis Œπ R M) {Œ∫ : Type w'} (v : Œ∫ ‚Üí M) (i : linear_independent R v) (m : i.maximal) : (‚ãÉ (k : Œ∫), ‚Üë((‚áë(b.repr) (v k)).support)) = set.univ
 : ‚ÑÇ ‚âÉ‚Çó·µ¢[‚Ñù] euclidean_space ‚Ñù (fin 2)
{Œ± : Type u_1} [omega_complete_partial_order Œ±] (p : Œ± ‚Üí Prop) (hp : ‚àÄ (c : omega_complete_partial_order.chain Œ±), (‚àÄ (i : Œ±), i ‚àà c ‚Üí p i) ‚Üí p (omega_complete_partial_order.œâSup c)) : omega_complete_partial_order (subtype p)
 : parser unit
(C : Type (u+1)) [category_theory.category C] [category_theory.concrete_category C] (D : Type (u+1)) [category_theory.category D] [category_theory.concrete_category D] [category_theory.has_forget‚ÇÇ C D] [category_theory.reflects_isomorphisms (category_theory.forget C)] : category_theory.reflects_isomorphisms (category_theory.forget‚ÇÇ C D)
{Œ± : Type u_2} {Œ≤ : Type u_3} [linear_order Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (h_mono : strict_mono f) (g : Œ≤ ‚Üí Œ±) (hg : function.right_inverse g f) : Œ± ‚âÉo Œ≤
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] [normed_group G] [normed_space ùïú G] {f : E ‚Üí F} {s : set E} (g : F ‚ÜíL[ùïú] G) (h : analytic_on ùïú f s) : analytic_on ùïú (‚áëg ‚àò f) s
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {T : add_submonoid P} {k : P ‚âÉ+ M} (H : add_submonoid.map k.to_add_monoid_hom T = S) : T.localization_map N
{ùïú : Type u_1} [linear_ordered_field ùïú] [topological_space ùïú] [order_topology ùïú] {s : set ùïú} : strict_convex ùïú s ‚Üî convex ùïú s
{C : Type u} [category_theory.category C] {X Y Z : algebraic_geometry.PresheafedSpace C} (f : X ‚ü∂ Z) [hf : algebraic_geometry.PresheafedSpace.is_open_immersion f] (g : Y ‚ü∂ Z) : algebraic_geometry.PresheafedSpace.is_open_immersion category_theory.limits.pullback.snd
{M : Type u_1} [monoid_with_zero M] {œÜ‚ÇÅ œÜ‚ÇÇ : ‚Ñ§ ‚Üí*‚ÇÄ M} (h_neg_one : ‚áëœÜ‚ÇÅ (-1) = ‚áëœÜ‚ÇÇ (-1)) (h_pos : ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚áëœÜ‚ÇÅ ‚Üën = ‚áëœÜ‚ÇÇ ‚Üën) : œÜ‚ÇÅ = œÜ‚ÇÇ
{Œ± : Type u_2} {Œ≤ : Type u_4} {Œ≥ : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10} {p : Type u_11} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (A : matrix l m Œ±) (B : matrix n p Œ≤) : matrix (l √ó n) (m √ó p) Œ≥
(Œ± : Type u) : Type u
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] (F : C ‚•§ D) [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete pempty) F] [category_theory.limits.has_finite_products C] (J : Type v) [fintype J] : category_theory.limits.preserves_limits_of_shape (category_theory.discrete J) F
(X : Pointed) : X.hom X
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : category_theory.pretopology.to_grothendieck C ‚ä• = ‚ä•
{R : Type u} [comm_ring R] {Œπ : Type v} (f : Œπ ‚Üí ideal R) : (R ‚ß∏ ‚®Ö (i : Œπ), f i) ‚Üí+* Œ† (i : Œπ), R ‚ß∏ f i
{Œπ : Type u} (s : finset Œπ) {f g : Œπ ‚Üí ‚Ñù} {p : ‚Ñù} (hp : 1 ‚â§ p) (hf : ‚àÄ (i : Œπ), i ‚àà s ‚Üí 0 ‚â§ f i) (hg : ‚àÄ (i : Œπ), i ‚àà s ‚Üí 0 ‚â§ g i) : s.sum (Œª (i : Œπ), (f i + g i) ^ p) ^ (1 / p) ‚â§ s.sum (Œª (i : Œπ), f i ^ p) ^ (1 / p) + s.sum (Œª (i : Œπ), g i ^ p) ^ (1 / p)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1 < s2 ‚Üî s1 ‚â§ s2 ‚àß ‚àÉ (p : P) (H : p ‚àà s2), p ‚àâ s1
{Œ± : Type u_1} {Œ≤ : Type u_2} {f g : Œ± ‚Üí Œ≤} {m : measurable_space Œ±} [topological_space Œ≤] {p : Œ± ‚Üí Prop} {_x : decidable_pred p} (hp : measurable_set {a : Œ± | p a}) (hf : measure_theory.strongly_measurable f) (hg : measure_theory.strongly_measurable g) : measure_theory.strongly_measurable (Œª (x : Œ±), ite (p x) (f x) (g x))
 : widget.tc expr empty
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s : affine_subspace k P) : affine_span k ‚Üës = s
{Œ± : Type u_1} : set Œ± ‚âÉ set Œ±·µí·µñ
{R : Type u_7} {S : Type u_8} [has_mul R] [has_add R] [has_mul S] [has_add S] (self : R ‚âÉ+* S) : R ‚âÉ* S
{Œ± : Type u‚ÇÅ} {X Y : category_theory.discrete Œ±} (h : X.as = Y.as) : X ‚âÖ Y
 : category_theory.limits.has_limits_of_size AddCommMon
{Œ± : Type u_1} {n : Type u_4} {m : Type u_5} [has_zero Œ±] {A : matrix m m Œ±} {D : matrix n n Œ±} (ha : A.is_diag) (hd : D.is_diag) : (matrix.from_blocks A 0 0 D).is_diag
(M : Type u_5) (N : Type u_6) [mul_one_class M] [mul_one_class N] : M √ó N ‚Üí* N
{R : Type u_1} [comm_ring R] {M : submonoid R} (z : localization M) : localization M
(r : tactic.tauto_state) (e : expr) : tactic (expr √ó expr)
{Œ± : Type u_1} [semiring Œ±] (b : Œ±) : list ‚Ñï ‚Üí Œ±
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] [fintype Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) {b : M} [linear_ordered_comm_ring M] (hb : fintype.card Œ≤ ‚Ä¢ b < ‚Üë(fintype.card Œ±)) : ‚àÉ (y : Œ≤), b < ‚Üë((finset.filter (Œª (x : Œ±), f x = y) finset.univ).card)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {K K' : lie_subalgebra R L} (h : K ‚â§ K') : ‚Ü•K ‚âÉ‚Çó‚ÅÖR‚ÅÜ ‚Ü•(lie_subalgebra.of_le h)
(G : Type u_1) [comm_monoid G] : submonoid G
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {U : Top} (X : algebraic_geometry.PresheafedSpace C) {f : U ‚ü∂ ‚ÜëX} (h : open_embedding ‚áëf) (x : ‚Ü•U) : (X.restrict h).stalk x ‚âÖ X.stalk (‚áëf x)
{G : Type u_10} [add_group G] (a : G) : ‚áë(equiv.symm (equiv.add_right a)) = Œª (x : G), x + -a
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} {Œπ‚ÇÇ : Type u_5} (s‚ÇÇ : finset Œπ‚ÇÇ) (e : Œπ‚ÇÇ ‚Ü™ Œπ) (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) : ‚áë((finset.map e s‚ÇÇ).affine_combination p) w = ‚áë(s‚ÇÇ.affine_combination (p ‚àò ‚áëe)) (w ‚àò ‚áëe)
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ‚•§ D) [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.enough_injectives C] [category_theory.limits.preserves_finite_limits F] {X : C} (P : category_theory.InjectiveResolution X) : (F.right_derived 0).obj X ‚âÖ F.obj X
 : Type
{Œ± : Type u} {Œ≤ : Type v} [complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [complete_linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] {Œπ : Sort u_1} [nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±} (Cf : continuous_at f (infi g)) (Mf : monotone f) : f (‚®Ö (i : Œπ), g i) = ‚®Ö (i : Œπ), f (g i)
(hs : list expr) : tactic (list name_set)
(op : ordinal ‚Üí ordinal ‚Üí ordinal) (o : ordinal) : Prop
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ± ‚Üí Œ≤ √ó Œ≥} (hf : continuous f) : continuous (Œª (a : Œ±), (f a).fst)
{R : Type u_1} {S : Type u_2} {F : Type u_3} {G : Type u_4} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S] [non_unital_ring_hom_class F R S] [non_unital_ring_hom_class G S R] (hom : F) (inv : G) (hom_inv_id : ‚Üëinv.comp ‚Üëhom = non_unital_ring_hom.id R) (inv_hom_id : ‚Üëhom.comp ‚Üëinv = non_unital_ring_hom.id S) : R ‚âÉ+* S
{Œ± : Type u} (s : wseq Œ±) : wseq Œ±
 : expr ‚Üí ‚Ñï
{C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_limits_of_shape (category_theory.discrete J) C] [category_theory.limits.has_limits_of_shape (category_theory.discrete (Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd)) C] [category_theory.limits.has_equalizers C] (G : C ‚•§ D) [category_theory.limits.preserves_limits_of_shape category_theory.limits.walking_parallel_pair G] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete J) G] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete (Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd)) G] : category_theory.limits.preserves_limits_of_shape J G
 : list unit ‚âÉ ‚Ñï
{Œ± : Type u} [preorder Œ±] {a b : Œ±} : a ‚â§ b ‚Üí ¬¨b ‚â§ a ‚Üí a < b
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] (f : M ‚Üí‚Çó[R] M) {p : submodule R M} (hf : ‚àÄ (x : M), x ‚àà p ‚Üí ‚áëf x ‚àà p) : ‚Ü•p ‚Üí‚Çó[R] ‚Ü•p
{V : Type u} [category_theory.category V] [category_theory.abelian V] {A B C D A' B' C' D' : V} {f : A ‚ü∂ B} {g : B ‚ü∂ C} {h : C ‚ü∂ D} {f' : A' ‚ü∂ B'} {g' : B' ‚ü∂ C'} {h' : C' ‚ü∂ D'} {Œ± : A ‚ü∂ A'} {Œ≤ : B ‚ü∂ B'} {Œ≥ : C ‚ü∂ C'} {Œ¥ : D ‚ü∂ D'} (comm‚ÇÅ : Œ± ‚â´ f' = f ‚â´ Œ≤) (comm‚ÇÇ : Œ≤ ‚â´ g' = g ‚â´ Œ≥) (comm‚ÇÉ : Œ≥ ‚â´ h' = h ‚â´ Œ¥) (hfg : category_theory.exact f g) (hgh : category_theory.exact g h) (hf'g' : category_theory.exact f' g') (hŒ± : category_theory.epi Œ±) (hŒ≤ : category_theory.mono Œ≤) (hŒ¥ : category_theory.mono Œ¥) : category_theory.mono Œ≥
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (F : C ‚•§ D) [category_theory.creates_limits_of_shape J F] [category_theory.limits.has_limits_of_shape J D] : category_theory.limits.preserves_limits_of_shape J F
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (G : D ‚•§ C) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] [finite_dimensional R M] (x : orientation R M Œπ) (f : M ‚âÉ‚Çó[R] M) (h : fintype.card Œπ = finite_dimensional.finrank R M) : ‚áë(orientation.map Œπ f) x = x ‚Üî 0 < ‚áëlinear_map.det ‚Üëf
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommMon) : category_theory.creates_limit F (category_theory.forget‚ÇÇ CommMon Mon)
{Œπ : Type u_1} {Œ∑ : Œπ ‚Üí Type u_4} {N : Type u_5} [add_zero_class N] : ((Œ£ (i : Œπ), Œ∑ i) ‚Üí‚ÇÄ N) ‚âÉ+ Œ†‚ÇÄ (i : Œπ), Œ∑ i ‚Üí‚ÇÄ N
{Œ± : Type u_1} {E : Type u_2} [linear_order E] [has_zero E] [measurable_space Œ±] (f : measure_theory.simple_func Œ± E) : measure_theory.simple_func Œ± E
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A B : matrix n n Œ±) (h : A.mul B = 1) : invertible A.det
(M : Type u_1) (Œ± : Type u_2) [add_monoid M] [topological_space Œ±] [add_action M Œ±] : Prop
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_le Œ±] [order_bot Œ±] [has_le Œ≤] [order_bot Œ≤] : bot_hom Œ± Œ≤ ‚âÉ top_hom Œ±·µí·µà Œ≤·µí·µà
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.limits.mono_factorisation f
(k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : Œπ ‚Üí set P) : affine_span k (‚ãÉ (i : Œπ), s i) = ‚®Ü (i : Œπ), affine_span k (s i)
 : expr ‚Üí expr ‚Üí tactic expr
(e : expr) : bool
(Œ± : Type u_1) [decidable_eq Œ±] [fintype Œ±] : trunc (Œ± ‚âÉ fin (fintype.card Œ±))
(C : Type u) : category_theory.free_monoidal_category C ‚•§ (category_theory.discrete ‚àò category_theory.free_monoidal_category.normal_monoidal_object) C ‚•§ category_theory.free_monoidal_category C
 : linarith.linarith_monad unit
{X Y : Semigroup} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ* ‚Ü•Y
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (c : cycle Œ±) : Prop
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (u : RÀ£) (hu : 0 < ‚Üëu) (v : module.ray R M) : u ‚Ä¢ v = v
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom B (A √ó B)
{Œ≤ : Type v} {Œ≥ : Type w} [emetric_space Œ≥] [emetric_space Œ≤] : emetric_space (Œ≥ √ó Œ≤)
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} {x : Œ±} (fin : emetric.Hausdorff_edist s t ‚â† ‚ä§) : metric.inf_dist x t ‚â§ metric.inf_dist x s + metric.Hausdorff_dist s t
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {D : Type u‚ÇÑ} [category_theory.category D] {G : K ‚•§ D} (h : category_theory.limits.cone G ‚•§ category_theory.limits.cone F) [category_theory.is_right_adjoint h] {c : category_theory.limits.cone G} (t : category_theory.limits.is_limit c) : category_theory.limits.is_limit (h.obj c)
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} : L.bounded_formula Œ± n ‚Üí L.formula (Œ± ‚äï fin n)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ‚Ñï} (s : affine.simplex k P n) (i : fin (n + 1)) : s.face _ = affine.simplex.mk_of_point k (s.points i)
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [pseudo_emetric_space Œ±] [topological_space Œ≤] [pseudo_emetric_space Œ≥] (f : Œ± √ó Œ≤ ‚Üí Œ≥) {s : set Œ±} {t : set Œ≤} (K : nnreal) (ha : ‚àÄ (a : Œ±), a ‚àà s ‚Üí continuous_on (Œª (y : Œ≤), f (a, y)) t) (hb : ‚àÄ (b : Œ≤), b ‚àà t ‚Üí lipschitz_on_with K (Œª (x : Œ±), f (x, b)) s) : continuous_on f (s √óÀ¢ t)
(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop
(R : Type u_1) (K : Type u_2) [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] : KÀ£ ‚Üí* (fractional_ideal (non_zero_divisors R) K)À£
{Œ± : Type u} [decidable_eq Œ±] (i j : Œ±) : function.involutive (Œª (_x : equiv.perm Œ±), _x * equiv.swap i j)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {P X Y : C} (f : X ‚ü∂ P) (g : Y ‚ü∂ P) [category_theory.limits.reflects_colimit (category_theory.limits.pair X Y) G] (l : category_theory.limits.is_colimit (category_theory.limits.binary_cofan.mk (G.map f) (G.map g))) : category_theory.limits.is_colimit (category_theory.limits.binary_cofan.mk f g)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] (M N : category_theory.Mat_ C) : Type v‚ÇÅ
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] {A B : C·µí·µñ} (g : A ‚ü∂ B) : opposite.op (category_theory.limits.cokernel g.unop) ‚âÖ category_theory.limits.kernel g
{Œ± : Type u} [semilattice_inf Œ±] {P : Œ± ‚Üí Prop} (Pinf : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, P x ‚Üí P y ‚Üí P (x ‚äì y)) : semilattice_inf {x // P x}
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : C(Œ±, Œ≤)) (x : Œ±) : continuous_at ‚áëf x
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {s : set Œ±} (h : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)) ‚â† 0) : s.nonempty
{m : Type u_2} {Œ± : Type u_12} (M : matrix m m Œ±) {n : ‚Ñï} (b : m ‚Üí fin n) (k : fin n) : matrix {a // b a = k} {a // b a = k} Œ±
 : Type
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [category_theory.limits.has_wide_equalizer f] [nonempty J] : category_theory.mono (category_theory.limits.wide_equalizer.Œπ f)
(Œ± : Type u) [pseudo_metric_space Œ±] : setoid Œ±
 : Type
{C : Type u} [category_theory.category C] {Œ≤ : Type w} (b : Œ≤) : category_theory.graded_object Œ≤ C ‚•§ C
{S : set ordinal} (hS : set.unbounded has_lt.lt S) : ordinal ‚âÉo ‚Ü•S
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] (E : Type u‚ÇÉ) [category_theory.category E] : (C √ó D) √ó E ‚•§ C √ó D √ó E
 : Type
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (d : D) : (category_theory.costructured_arrow F d)·µí·µñ ‚•§ category_theory.structured_arrow (opposite.op d) F.op
 : category_theory.limits.preserves_limits_of_size (category_theory.forget AddMon)
{G : Type u_1} [has_one G] [has_mul G] [has_inv G] : list G ‚Üí G
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (h : M ‚âÉ* N) : M ‚Üí* N
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Prop
(A : Type u_2) [add_group A] : Prop
 : has_le many_one_degree
{Œπ : Type u_1} {Œ± : Type u_3} [preorder Œπ] [linear_order Œ±] {u : Œπ ‚Üí Œ±} (h : monotone u) (H : ¬¨bdd_below (set.range u)) : filter.tendsto u filter.at_bot filter.at_bot
{Œ± : Type u_1} (tac : tactic Œ±) : tactic Œ±
{Œπ : Type u} {Œ± : Type v} (t : Œπ ‚Üí finset Œ±) : (finset Œπ)·µí·µñ ‚•§ Type (max u v)
{ùïú : Type u} {Œπ : Type v} {E : Œπ ‚Üí Type wE} {G : Type wG} [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] [normed_group G] [normed_space ùïú G] (ùïú' : Type u_1) [nondiscrete_normed_field ùïú'] [normed_algebra ùïú' ùïú] [normed_space ùïú' G] [is_scalar_tower ùïú' ùïú G] [Œ† (i : Œπ), normed_space ùïú' (E i)] [‚àÄ (i : Œπ), is_scalar_tower ùïú' ùïú (E i)] : continuous_multilinear_map ùïú E G ‚ÜíL[ùïú'] continuous_multilinear_map ùïú' E G
{Œ± : Type u} (a : Œ±) : stream Œ±
(k : Type u‚ÇÅ) (G : Type u‚ÇÇ) [semiring k] [add_zero_class G] : multiplicative G ‚Üí* add_monoid_algebra k G
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C·µí·µñ} (f : X ‚ü∂ Y) [category_theory.is_iso (category_theory.coyoneda.map f)] : category_theory.is_iso f
{V : Type u} {G : simple_graph V} [decidable_eq V] {u v : V} (c : G.walk v v) (h : u ‚àà c.support) : G.walk u u
(Œ± : expr) (lems : interactive.parse tactic.simp_arg_list) : tactic unit
(A : Fintype) : topological_space ‚Ü•A
 : ‚Ñï ‚âÉ ‚Ñï ‚äï punit
{R : Type u} [comm_semiring R] (x y : R) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.abelian D] (F : C ‚•§ D) [F.preserves_zero_morphisms] [category_theory.is_equivalence F] : category_theory.abelian C
{M : Type u_3} [add_monoid M] [preorder M] [covariant_class M M (function.swap has_add.add) has_le.le] [covariant_class M M has_add.add has_le.le] {l‚ÇÅ l‚ÇÇ : list M} (h : l‚ÇÅ <+ l‚ÇÇ) (h‚ÇÅ : ‚àÄ (a : M), a ‚àà l‚ÇÇ ‚Üí 0 ‚â§ a) : l‚ÇÅ.sum ‚â§ l‚ÇÇ.sum
{Œ± : Type u_1} {Œ≤ : Type u_2} [partial_order Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ (a b : Œ±), f a ‚â§ f b ‚Üî a ‚â§ b) : Œ± ‚Ü™o Œ≤
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M ‚Üí+ P} {T : add_submonoid P} (hy : ‚àÄ (y : ‚Ü•S), ‚áëg ‚Üëy ‚àà T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} (z : N) (u : Q) : ‚áë(f.map hy k) z = u ‚Üî ‚áë(k.to_map) (‚áëg (f.sec z).fst) = ‚áë(k.to_map) (‚áëg ‚Üë((f.sec z).snd)) + u
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {n : with_top ‚Ñï} (h : cont_diff_on ùïú n f s) (hs : unique_diff_on ùïú s) (hn : 1 ‚â§ n) : continuous_on (Œª (p : E √ó E), ‚áë(fderiv_within ùïú f s p.fst) p.snd) (s √óÀ¢ set.univ)
{Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} {M : Type u_4} [has_scalar Œ± M] [has_scalar Œ≤ M] [smul_comm_class Œ± Œ≤ M] : smul_comm_class Œ± Œ≤ (Œπ ‚Üí M)
{Œ± : Type} (t : tactic Œ±) : tactic (list Œ±)
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : Œ±) : Œ±
{R‚ÇÇ : Type u_5} {M‚ÇÇ : Type u_6} [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {n : Type u_11} [fintype n] [decidable_eq n] (b : basis n R‚ÇÇ M‚ÇÇ) : bilin_form R‚ÇÇ M‚ÇÇ ‚âÉ‚Çó[R‚ÇÇ] matrix n n R‚ÇÇ
{Œ± : Type u_1} {Œπ : Type u_4} [topological_space Œ±] {s : set Œπ} (hs : s.finite) {f : Œπ ‚Üí set Œ±} (h : ‚àÄ (i : Œπ), i ‚àà s ‚Üí is_GŒ¥ (f i)) : is_GŒ¥ (‚ãÉ (i : Œπ) (H : i ‚àà s), f i)
{R : Type u_1} [ring R] {M : Type u_3} [topological_space M] [add_comm_group M] [module R M] {M‚ÇÇ : Type u_4} [topological_space M‚ÇÇ] [add_comm_group M‚ÇÇ] [module R M‚ÇÇ] [topological_add_group M] (f‚ÇÅ : M ‚ÜíL[R] M‚ÇÇ) (f‚ÇÇ : M‚ÇÇ ‚ÜíL[R] M) (h : function.right_inverse ‚áëf‚ÇÇ ‚áëf‚ÇÅ) : M ‚âÉL[R] M‚ÇÇ √ó ‚Ü•(f‚ÇÅ.ker)
{R : Type u_1} [add_monoid R] [has_one R] [char_zero R] : ‚Ñï ‚Ü™ R
{Œ± : Type u} [non_unital_non_assoc_ring Œ±] (k : Œ±) (h : ‚àÄ (x : Œ±), x * k = 0 ‚Üí x = 0) : is_right_regular k
 : ‚Ñï ‚Üí tactic.list_Pi expr ‚Üí tactic (tactic.list_Pi tactic.rcases_patt √ó list expr)
(F : Type u‚ÇÄ ‚Üí Type u‚ÇÅ ‚Üí Type u‚ÇÇ) [bifunctor F] : Type
{Œ± : Type u} {Œ≤ : Type u_1} [has_sup Œ±] [has_inf Œ±] [has_top Œ±] [has_bot Œ±] [has_compl Œ±] [has_sdiff Œ±] [boolean_algebra Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.injective f) (map_sup : ‚àÄ (a b : Œ±), f (a ‚äî b) = f a ‚äî f b) (map_inf : ‚àÄ (a b : Œ±), f (a ‚äì b) = f a ‚äì f b) (map_top : f ‚ä§ = ‚ä§) (map_bot : f ‚ä• = ‚ä•) (map_compl : ‚àÄ (a : Œ±), f a·∂ú = (f a)·∂ú) (map_sdiff : ‚àÄ (a b : Œ±), f (a  b) = f a  f b) : boolean_algebra Œ±
{C : Type u‚ÇÅ} [category_theory.category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (R : category_theory.presieve X) [category_theory.limits.has_pullbacks C] : category_theory.presieve.is_sheaf_for P R ‚Üî nonempty (category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ (category_theory.equalizer.fork_map P R) _))
{Œ± : Type u_2} [has_zero Œ±] : has_zero (filter Œ±)
{M : Type u_1} [cancel_comm_monoid_with_zero M] [unique_factorization_monoid M] [fintype MÀ£] (y : M) (hy : y ‚â† 0) : fintype {x // x ‚à£ y}
{Œ± : Type u_1} [preorder Œ±] [order_bot Œ±] [locally_finite_order Œ±] (b : Œ±) : finset Œ±
{Œ± : Type u_1} [circular_preorder Œ±] {a b c : Œ±} (h : has_btw.btw a b c) : has_btw.btw c a b
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x : V) {r‚ÇÅ r‚ÇÇ : ‚Ñù} : 2 ‚Ä¢ o.oangle (r‚ÇÅ ‚Ä¢ x) (r‚ÇÇ ‚Ä¢ x) = 0
 : category_theory.limits.has_limits_of_size CommSemiRing
{R : Type u_1} [comm_ring R] {c‚ÇÅ c‚ÇÇ : R} : clifford_algebra (clifford_algebra_quaternion.Q c‚ÇÅ c‚ÇÇ) ‚âÉ‚Çê[R] quaternion_algebra R c‚ÇÅ c‚ÇÇ
{Œ± : Type u_1} {a b c : Œ±} [linear_order Œ±] [add_comm_semigroup Œ±] [has_sub Œ±] [has_ordered_sub Œ±] (h : a - c < b - c) : a < b
{Œ± : Type u} (t : tactic Œ±) : tactic (Œ± ‚äï string)
{Œ± : Type u} [has_add Œ±] {Œ≤ : Type v} [add_semigroup Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) : add_magma.free_add_semigroup Œ± ‚Üí Œ≤
(Œ± : Type u) [monoid Œ±] : Œ±À£ ‚âÉ* category_theory.Aut (category_theory.single_obj.star Œ±)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X Y : C} : category_theory.limits.image 0 ‚âÖ 0
{n : ‚Ñï} (i : fin n) : equiv.perm (fin n)
{Œ± : Type u} [linear_order Œ±] (a b : Œ±) : linear_order.min a b = a ‚àß a ‚â§ b ‚à® linear_order.min a b = b ‚àß b < a
{x y : pgame} : x ‚â§ y ‚Üî (‚àÄ (i : x.left_moves), (‚àÉ (i' : y.left_moves), x.move_left i ‚â§ y.move_left i') ‚à® ‚àÉ (j : (x.move_left i).right_moves), (x.move_left i).move_right j ‚â§ y) ‚àß ‚àÄ (j : y.right_moves), (‚àÉ (i : (y.move_right j).left_moves), x ‚â§ (y.move_right j).move_left i) ‚à® ‚àÉ (j' : x.right_moves), x.move_right j' ‚â§ y.move_right j
 : linter
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.creates_limits_of_size F] [category_theory.limits.has_limits_of_size D] : category_theory.limits.preserves_limits_of_size F
(M' : Type u_1) (X : Type u_2) [has_scalar M' X] (Y : Type u_3) [has_scalar M' Y] : Type (max u_2 u_3)
{R : Type u_1} {S : Type u_3} {T : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] [non_assoc_semiring T] (f : R ‚Üí+* S) (g : R ‚Üí+* T) : R ‚Üí+* S √ó T
(p : ‚Ñï ‚Üí Prop) (x y : nat.upto p) : Prop
{R : Type u_1} {E : Type u_2} {Œπ : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] (s : finset Œπ) (w‚ÇÅ w‚ÇÇ : Œπ ‚Üí R) (z : Œπ ‚Üí E) (hw‚ÇÅ : s.sum (Œª (i : Œπ), w‚ÇÅ i) = 1) (hw‚ÇÇ : s.sum (Œª (i : Œπ), w‚ÇÇ i) = 1) (a b : R) (hab : a + b = 1) : a ‚Ä¢ s.center_mass w‚ÇÅ z + b ‚Ä¢ s.center_mass w‚ÇÇ z = s.center_mass (Œª (i : Œπ), a * w‚ÇÅ i + b * w‚ÇÇ i) z
{R : Type u_1} {B : Type u_3} [nondiscrete_normed_field R] [topological_space B] {F‚ÇÅ : Type u_6} [normed_group F‚ÇÅ] [normed_space R F‚ÇÅ] {E‚ÇÅ : B ‚Üí Type u_7} [topological_space (bundle.total_space E‚ÇÅ)] [Œ† (x : B), add_comm_monoid (E‚ÇÅ x)] [Œ† (x : B), module R (E‚ÇÅ x)] {F‚ÇÇ : Type u_8} [normed_group F‚ÇÇ] [normed_space R F‚ÇÇ] {E‚ÇÇ : B ‚Üí Type u_9} [topological_space (bundle.total_space E‚ÇÇ)] [Œ† (x : B), add_comm_monoid (E‚ÇÇ x)] [Œ† (x : B), module R (E‚ÇÇ x)] (e‚ÇÅ : topological_vector_bundle.trivialization R F‚ÇÅ E‚ÇÅ) (e‚ÇÇ : topological_vector_bundle.trivialization R F‚ÇÇ E‚ÇÇ) (p : B √ó F‚ÇÅ √ó F‚ÇÇ) : bundle.total_space (Œª (x : B), E‚ÇÅ x √ó E‚ÇÇ x)
{C : Type u} [category_theory.category C] {n : ‚Ñï} (f : ulift (fin (n + 1)) ‚Üí C) {c‚ÇÅ : category_theory.limits.cofan (Œª (i : ulift (fin n)), f {down := i.down.succ})} {c‚ÇÇ : category_theory.limits.binary_cofan (f {down := 0}) c‚ÇÅ.X} (t‚ÇÅ : category_theory.limits.is_colimit c‚ÇÅ) (t‚ÇÇ : category_theory.limits.is_colimit c‚ÇÇ) : category_theory.limits.is_colimit (category_theory.extend_cofan c‚ÇÅ c‚ÇÇ)
(F : pfunctor) : Type u
(g : ‚Ü•(matrix.GL_pos (fin 2) ‚Ñù)) (z : upper_half_plane) : upper_half_plane
{ùïú : Type u_1} [linear_ordered_field ùïú] {s : set ùïú} {f : ùïú ‚Üí ùïú} : strict_convex_on ùïú s f ‚Üî convex ùïú s ‚àß ‚àÄ ‚¶Éx y z : ùïú‚¶Ñ, x ‚àà s ‚Üí z ‚àà s ‚Üí x < y ‚Üí y < z ‚Üí (f y - f x) / (y - x) < (f z - f y) / (z - y)
{C : Type u‚ÇÅ} [category_theory.category C] : category_theory.ulift_hom C ‚•§ C
(Œ± : Type u_1) (Œ≤ : Type u_2) [has_lt Œ±] [has_le Œ≤] : has_le (Œ± √ó‚Çó Œ≤)
{Œ± : Type u} [pseudo_emetric_space Œ±] {s t : set Œ±} : emetric.Hausdorff_edist s t = 0 ‚Üî closure s = closure t
 : nnreal ‚âÉo nnreal
{V : Type u} (G : simple_graph V) : setoid V
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (X : algebraic_geometry.SheafedSpace C) : Top.sheaf C ‚ÜëX
(V : Type v) [category_theory.category V] [category_theory.monoidal_category V] {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} {E : Type u‚ÇÉ} [category_theory.enriched_category V C] [category_theory.enriched_category V D] [category_theory.enriched_category V E] (F : category_theory.enriched_functor V C D) (G : category_theory.enriched_functor V D E) : category_theory.enriched_functor V C E
{Œ± : Type u_2} {Œ≤ : Type u_3} [non_assoc_semiring Œ±] [preorder Œ±] [non_assoc_semiring Œ≤] [preorder Œ≤] (f : Œ± ‚Üí+*o Œ≤) : Œ± ‚Üí*‚ÇÄo Œ≤
{Œ± : Type u_1} [preorder Œ±] {a : Œ±} [no_min_order Œ±] : nonempty ‚Ü•(set.Iio a)
{Œ± : Type u} [topological_space Œ±] [locally_compact_space Œ±] [t2_space Œ±] (x : Œ±) : ‚àÉ (U : set Œ±), is_open U ‚àß x ‚àà U ‚àß is_compact (closure U)
{n : ‚Ñï} : arity pSet n ‚Üí arity pSet n ‚Üí Prop
{ùïú : Type u_1} {V : Type u_2} {V‚ÇÇ : Type u_4} {V‚ÇÉ : Type u_5} {P : Type u_8} {P‚ÇÇ : Type u_9} {P‚ÇÉ : Type u_10} [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [semi_normed_group V‚ÇÉ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] [normed_space ùïú V‚ÇÉ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [pseudo_metric_space P‚ÇÉ] [normed_add_torsor V P] [normed_add_torsor V‚ÇÇ P‚ÇÇ] [normed_add_torsor V‚ÇÉ P‚ÇÉ] (e : P ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÇ) (e' : P‚ÇÇ ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÉ) : P ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÉ
{M : Type u_1} {Œ± : Type u_6} [monoid M] [mul_action M Œ±] : M ‚Üí* function.End Œ±
{C : Type u} [category_theory.category C] (ùí¢ : set C) : Prop
(Œ± : Type u) [group Œ±] : Type u
{Œ±‚ÇÅ : Type u_1} {Œ±‚ÇÇ : Type u_2} {Œ≤‚ÇÅ : Type u_3} {Œ≤‚ÇÇ : Type u_4} {Œ≥‚ÇÅ : Type u_5} {Œ≥‚ÇÇ : Type u_6} (f : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ ‚Üí finset Œ≥‚ÇÅ) (g : Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ ‚Üí finset Œ≥‚ÇÇ) (a : Œ±‚ÇÅ ‚äï Œ±‚ÇÇ) (b : Œ≤‚ÇÅ ‚äï Œ≤‚ÇÇ) : finset (Œ≥‚ÇÅ ‚äï Œ≥‚ÇÇ)
{L : first_order.language} (M : Type w) [L.Structure M] (T : L.Theory) : Prop
{ùïú : Type u} {n : ‚Ñï} {Ei : fin n.succ ‚Üí Type wEi} {G : Type wG} [nondiscrete_normed_field ùïú] [Œ† (i : fin n.succ), normed_group (Ei i)] [Œ† (i : fin n.succ), normed_space ùïú (Ei i)] [normed_group G] [normed_space ùïú G] (f : continuous_multilinear_map ùïú Ei G) : continuous_multilinear_map ùïú (Œª (i : fin n), Ei (‚áëfin.cast_succ i)) (Ei (fin.last n) ‚ÜíL[ùïú] G)
{Œ± : Type u_1} [has_one Œ±] : has_coe (simple_continued_fraction Œ±) (generalized_continued_fraction Œ±)
{R : Type u_1} {M : Type u_9} {M‚ÇÇ : Type u_12} [comm_semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] : (M‚ÇÇ ‚Üí‚Çó[R] R) ‚Üí‚Çó[R] M ‚Üí‚Çó[R] M‚ÇÇ ‚Üí‚Çó[R] M
{Œ± : Type u_1} [partial_order Œ±] {f : Œ± ‚Üí Œ±} {p : Œ± ‚Üí Prop} {hf : ‚àÄ (x : Œ±), x ‚â§ f x} {hfp : ‚àÄ (x : Œ±), p (f x)} {hmin : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, x ‚â§ y ‚Üí p y ‚Üí f x ‚â§ y} {x y : Œ±} (hxy : x ‚â§ y) (hy : p y) : ‚áë(closure_operator.mk‚ÇÉ f p hf hfp hmin) x ‚â§ y
{C : Type u} [category_theory.category C] {Z X‚ÇÅ X‚ÇÇ X : C} [category_theory.limits.coproduct_disjoint X‚ÇÅ X‚ÇÇ] {pX‚ÇÅ : X‚ÇÅ ‚ü∂ X} {pX‚ÇÇ : X‚ÇÇ ‚ü∂ X} (cX : category_theory.limits.is_colimit (category_theory.limits.binary_cofan.mk pX‚ÇÅ pX‚ÇÇ)) {f : Z ‚ü∂ X‚ÇÅ} {g : Z ‚ü∂ X‚ÇÇ} {comm : f ‚â´ pX‚ÇÅ = g ‚â´ pX‚ÇÇ} (cZ : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk f g comm)) : category_theory.limits.is_initial Z
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M ‚Üí* N} (hf : ‚àÄ (y : ‚Ü•S), is_unit (‚áëf ‚Üëy)) {y z : ‚Ü•S} (h : (‚áë(is_unit.lift_right (f.restrict S) hf) y)‚Åª¬π = (‚áë(is_unit.lift_right (f.restrict S) hf) z)‚Åª¬π) : ‚áëf ‚Üëy = ‚áëf ‚Üëz
{G‚ÇÅ : Type u_3} {G‚ÇÇ : Type u_4} {G‚ÇÉ : Type u_5} [group G‚ÇÅ] [group G‚ÇÇ] [group G‚ÇÉ] (f : G‚ÇÅ ‚Üí* G‚ÇÇ) (f_inv : G‚ÇÇ ‚Üí G‚ÇÅ) (hf : function.right_inverse f_inv ‚áëf) : {g // f.ker ‚â§ g.ker} ‚âÉ (G‚ÇÇ ‚Üí* G‚ÇÉ)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop} [is_trans Œ≥ t] (f : principal_seg r s) (g : principal_seg s t) : principal_seg r t
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [semiring Œ≤] : module (Œ± ‚Üí Œ≤) (Œ± ‚Üí‚ÇÄ Œ≤)
{Œ± : Type u_1} {F : Type u_3} {F' : Type u_4} [normed_group F] [normed_space ‚Ñù F] [normed_group F'] [normed_space ‚Ñù F'] {m : measurable_space Œ±} (T : set Œ± ‚Üí (F ‚ÜíL[‚Ñù] F')) (f : measure_theory.simple_func Œ± F) : F'
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) : category_theory.limits.walking_parallel_pair ‚•§ C
{Œ± : Type u_1} {Œ≤ : Type u_2} [group Œ±] [division_monoid Œ≤] (f : Œ± ‚Üí* Œ≤) (g : Œ±) (n : ‚Ñ§) : ‚áëf (g ^ n) = ‚áëf g ^ n
{K : Type u_2} [division_ring K] (a‚Çô b‚Çô ppredB predB : K) : K
{L : first_order.language} {Œ± : Type u'} (f : L.functions 2) (t‚ÇÅ t‚ÇÇ : L.term Œ±) : L.term Œ±
{x y : pgame} (r : x.relabelling y) : x.restricted y
{Œ± : Type u} [topological_space Œ±] {f : filter Œ±} (h : ‚àÉ (a : Œ±), f ‚â§ nhds a) : f ‚â§ nhds (Lim f)
{C : Type u} [category_theory.category C] {X Y : C} (h : X ‚âÖ Y) : category_theory.Aut X ‚âÉ* category_theory.Aut Y
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [module ùïú E] {s : set E} (hs : convex ùïú s) (z : E) : convex ùïú ((Œª (x : E), x + z) ‚Åª¬π' s)
(h : Top.glue_data.mk_core) (i j k : h.J) : category_theory.limits.pullback (h.V i j).inclusion (h.V i k).inclusion ‚ü∂ category_theory.limits.pullback (h.V j k).inclusion (h.V j i).inclusion
{G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] (x : P) : equiv.perm P
(func arg : pexpr) (pi_expr : expr) : pexpr
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [linear_order Œ≤] [succ_order Œ≤] [is_succ_archimedean Œ≤] {s : Œ≤ ‚Üí set Œ±} {t : set Œ≤} (ht : t.ord_connected) (H : ‚àÄ (n : Œ≤), n ‚àà t ‚Üí is_preconnected (s n)) (K : ‚àÄ (n : Œ≤), n ‚àà t ‚Üí order.succ n ‚àà t ‚Üí (s n ‚à© s (order.succ n)).nonempty) : is_preconnected (‚ãÉ (n : Œ≤) (H : n ‚àà t), s n)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (e : C ‚âå D) : E ‚•§ C ‚âå E ‚•§ D
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_nilpotent R L] : (‚®Ö (x : L), (‚áë(lie_algebra.ad R L) x).maximal_generalized_eigenspace 0) = ‚ä§
{Œ± : Type u} {n : ‚Ñï} (a : array n Œ±) : a.to_list = list.of_fn a.read
(B : Type u_1) (F : Type u_2) : bundle.total_space (bundle.trivial B F) ‚Üí F
(C : Type u) [category_theory.category C] : Type (max u (v+1))
(M : Type u_1) (Œ± : Type u_6) [monoid M] [mul_action M Œ±] : Œ± ‚Ü™ M ‚Üí Œ±
 : filter.tendsto real.log filter.at_top filter.at_top
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} (X : T.algebra) : T.free.obj (T.to_functor.obj X.A) ‚ü∂ T.free.obj X.A
(Œ± : Sort u) : Type u
(R : Type u) [comm_ring R] : Algebra.free R ‚ä£ category_theory.forget (Algebra R)
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] : V ‚•§ chain_complex V ‚Ñï
{C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ‚Ñï} (i : fin (n + 1)) : X.obj (opposite.op (simplex_category.mk n)) ‚ü∂ X.obj (opposite.op (simplex_category.mk (n + 1)))
{Œ± : Type u} [pseudo_metric_space Œ±] {u : ‚Ñï ‚Üí Œ±} (hu : cauchy_seq u) : ‚àÉ (R : ‚Ñù) (H : R > 0), ‚àÄ (m n : ‚Ñï), has_dist.dist (u m) (u n) < R
{Œ± : Type u_1} [topological_space Œ±] (x : Œ±) (S : set Œ±) : Prop
{R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R] : unique_factorization_monoid R
(R : Type u_1) {M : Type u_9} [semiring R] [add_comm_group M] [module R M] : M ‚âÉ‚Çó[R] M
{Œ± : Type u} {Œ≤ : Type v} [decidable_eq Œ≤] (r : Œ± ‚Üí Œ≤ ‚Üí Prop) [Œ† (a : Œ±), fintype ‚Ü•(rel.image r {a})] : (‚àÄ (A : finset Œ±), A.card ‚â§ fintype.card ‚Ü•(rel.image r ‚ÜëA)) ‚Üî ‚àÉ (f : Œ± ‚Üí Œ≤), function.injective f ‚àß ‚àÄ (x : Œ±), r x (f x)
 : ereal ‚Üí ereal
{Œ± : Type u_1} (s : set Œ±) : measure_theory.outer_measure Œ± ‚Üí‚Çó[ennreal] measure_theory.outer_measure Œ±
{Œ± : Type u_2} {Œ≤ : Type u_3} [partial_order Œ±] [partial_order Œ≤] (e : Œ± ‚âÉo Œ≤) : with_bot Œ± ‚âÉo with_bot Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} (s : multiset Œ±) (f : Œ± ‚Üí multiset Œ≤) : multiset Œ≤
 : Preorder ‚•§ Preorder
{R : Type u} [ring R] : comm_ring ‚Ü•(subring.center R)
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : (generalized_continued_fraction.int_fract_pair.stream v).is_seq
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] : Type (max u v)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Type (max v u)) : Type (max v u)
{R : Type u} [comm_semiring R] {A : Type v‚ÇÅ} [semiring A] [algebra R A] {B : Type v‚ÇÇ} [semiring B] [algebra R B] : tensor_product R A B ‚Üí‚Çó[R] tensor_product R A B ‚Üí‚Çó[R] tensor_product R A B
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [module ùïú E] [module ùïú Œ≤] (f : E ‚Üí‚Çó[ùïú] Œ≤) {s : set E} (hs : convex ùïú s) : convex_on ùïú s ‚áëf
{m : Type u ‚Üí Type u_1} [monad m] {Œ± : Type u} {n : ‚Ñï} : (fin n ‚Üí m Œ±) ‚Üí m (vector Œ± n)
 : widget.tc widget_override.local_collection empty
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [add_group Œ±] [uniform_add_group Œ±] [uniform_space Œ≤] [add_group Œ≤] [uniform_add_group Œ≤] (f : Œ± ‚Üí+ Œ≤) (hf : continuous ‚áëf) : uniform_space.completion Œ± ‚Üí+ uniform_space.completion Œ≤
(R : Type u_1) : Type u_1
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (F : C ‚•§ D ‚•§ E) : category_theory.uncurry.obj F.flip ‚âÖ category_theory.prod.swap D C ‚ãô category_theory.uncurry.obj F
(a b : snum) : snum
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) : Type (max u‚ÇÅ v‚ÇÅ)
{M : Type u_3} {N : Type u_4} [has_add M] [add_zero_class N] : has_zero (add_hom M N)
{Œ± : Type u_1} {m : measurable_space Œ±} : measure_theory.complex_measure Œ± ‚âÉ measure_theory.signed_measure Œ± √ó measure_theory.signed_measure Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cone F} (P : category_theory.limits.is_limit t) : category_theory.limits.is_colimit t.op
(h : interactive.parse (optional lean.parser.ident)) (q‚ÇÅ : interactive.parse (optional (lean.parser.tk ":" *> interactive.types.texpr))) (q‚ÇÇ : interactive.parse (optional (lean.parser.tk ":=" *> interactive.types.texpr))) : tactic unit
{p : ‚Ñï} [fact (nat.prime p)] : padic_seq p ‚Üí ‚Ñö_[p]
 : expr ‚Üí tactic (expr √ó expr)
{R : Type u_1} {R‚ÇÅ : Type u_2} {M‚ÇÅ : Type u_6} [comm_semiring R] [comm_semiring R‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] {I‚ÇÅ I‚ÇÇ : R‚ÇÅ ‚Üí+* R} (B : M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ] M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÇ] R) : Prop
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) (P : Type u_6) [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] : (tensor_product R M N ‚Üí‚Çó[R] P) ‚Üí‚Çó[R] M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] P
{Œ± : Type u_1} {p : Œ± ‚Üí Prop} (s : finset {x // p x}) {a : Œ±} (h : ¬¨p a) : a ‚àâ finset.map (function.embedding.subtype (Œª (x : Œ±), p x)) s
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] {j j' : C} (f f' : j ‚ü∂ j') : f ‚â´ category_theory.is_filtered.coeq_hom f f' = f' ‚â´ category_theory.is_filtered.coeq_hom f f'
{p : ‚Ñï} [p_prime : fact (nat.prime p)] {b : ‚Ñï} (dvd : p ‚à£ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1
(a b : ‚Ñï) : ‚Ñï
(p : turing.partrec_to_TM2.Œì' ‚Üí bool) (k‚ÇÅ k‚ÇÇ : turing.partrec_to_TM2.K') (q : turing.partrec_to_TM2.Œõ') : turing.partrec_to_TM2.Œõ'
 : list expr ‚Üí expr ‚Üí expr
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [semiring Œ±] [add_group Œ≤] (h : function.antiperiodic f c) : function.periodic f (2 * c)
 : ‚Ñï
(n : ‚Ñï) : Type (u+1)
{ùïú : Type u_1} {E : Type u_2} [normed_field ùïú] [normed_group E] [normed_space ùïú E] : E ‚Üí‚Çó·µ¢[ùïú] uniform_space.completion E
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) : CommRing
(z : ‚ÑÇ) : ‚ÑÇ
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] {B : bilin_form R M} (hB : B.to_quadratic_form.anisotropic) : B.nondegenerate
{G : Type u_1} [group G] (s : set G) : set G
{C : Type u} [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} (F : category_theory.limits.mono_factorisation f) {X' : C} (g : X' ‚ü∂ X) : category_theory.limits.mono_factorisation (g ‚â´ f)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) {p : P} (hp : p ‚àà affine_span ‚Ñù (set.range s.points)) {r : ‚Ñù} (hr : ‚àÄ (i : fin (n + 1)), has_dist.dist (s.points i) p = r) : r = s.circumradius
{Œ± : Type u_1} [Œ≤ : normed_division_ring Œ±] : normed_ring Œ±
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K‚ÇÅ K‚ÇÇ : submodule ùïú E} [finite_dimensional ùïú ‚Ü•K‚ÇÇ] (h : K‚ÇÅ ‚â§ K‚ÇÇ) : finite_dimensional.finrank ùïú ‚Ü•K‚ÇÅ + finite_dimensional.finrank ùïú ‚Ü•(K‚ÇÅ·óÆ ‚äì K‚ÇÇ) = finite_dimensional.finrank ùïú ‚Ü•K‚ÇÇ
(b x : ‚Ñù) : ‚Ñù
{n : ‚Ñï} (x y : bitvec n) : Prop
(S : Type u_4) (M : out_param (Type u_5)) [has_one M] [set_like S M] : Type
 : omega.int.preform ‚Üí Prop
{Œ± : Type u_1} {s : setoid Œ±} [decidable_rel has_equiv.equiv] [encodable Œ±] : encodable (quotient s)
{M : Type u_1} [monoid M] {Œπ : Sort u_2} {s : Œπ ‚Üí set M} (h : ‚àÄ (y : Œπ), is_submonoid (s y)) : is_submonoid (set.Inter s)
{Œ± : Type u_1} {Œ≤ : Type u_2} [cancel_comm_monoid_with_zero Œ±] [normalized_gcd_monoid Œ±] (s : finset Œ≤) (f : Œ≤ ‚Üí Œ±) : Œ±
{R : Type u_1} [comm_ring R] (S : submonoid R) (P : Type u_2) [comm_ring P] [algebra R P] [loc : is_localization S P] (P' : Type u_3) [comm_ring P'] [algebra R P'] [loc' : is_localization S P'] : fractional_ideal S P ‚âÉ+* fractional_ideal S P'
(ùïú : Type u_1) (E : Type u_2) [normed_field ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [has_continuous_smul ùïú E] : bornology E
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (s : add_subsemigroup M) (t : add_subsemigroup N) : add_subsemigroup (M √ó N)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J·µí·µñ ‚•§ C·µí·µñ} (c : category_theory.limits.cocone F.unop) : category_theory.limits.cone F
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M ‚Üí+ P} (hg : ‚àÄ (y : ‚Ü•S), is_add_unit (‚áëg ‚Üëy)) {x y : M} (h : ‚áë(f.to_map) x = ‚áë(f.to_map) y) : ‚áëg x = ‚áëg y
{C : Type u} [category_theory.category C] [category_theory.has_shift C ‚Ñ§] : category_theory.category (category_theory.triangulated.triangle C)
(A : Type u_1) [ring A] [algebra ‚Ñö A] : power_series A
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) : subsemiring.closure ‚Üës = s
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : M) : same_ray R x x
{Œ± : Type u_1} {M : Type u_5} {R : Type u_11} {S : Type u_12} [has_zero M] [semiring R] [semiring S] (h : R ‚Üí+* S) (f : Œ± ‚Üí‚ÇÄ M) (g : Œ± ‚Üí M ‚Üí R) : ‚áëh (f.sum g) = f.sum (Œª (a : Œ±) (b : M), ‚áëh (g a b))
(ùïú : Type u) (Œπ : Type v) {G : Type wG} [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] (z : G) : continuous_multilinear_map ùïú (Œª (i : Œπ), ùïú) G
{C : ‚Ñ§ ‚Üí Sort u_1} (z b : ‚Ñ§) (H0 : C b) (Hs : Œ† (k : ‚Ñ§), b ‚â§ k ‚Üí C k ‚Üí C (k + 1)) (Hp : Œ† (k : ‚Ñ§), k ‚â§ b ‚Üí C k ‚Üí C (k - 1)) : C z
{Œπ : Type u_1} {Œ± : Type u_2} {s : Œπ ‚Üí set Œ±} (hs : indexed_partition s) (x : Œ±) : ‚áë(hs.out) (hs.proj x) = hs.some (hs.index x)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [semilattice_sup Œ≤] {f g : Œ± ‚Üí Œ≤} (hf : monotone f) (hg : monotone g) : monotone (f ‚äî g)
{Œ± : Type u} : Œ± √ó list Œ± √ó Œ± √ó list Œ± ‚Üí Œ± √ó list Œ± √ó Œ± √ó list Œ±
{Œ± : Type u_1} : subsingleton (option Œ±) ‚Üî is_empty Œ±
{G : Type u_1} [add_group G] (T : set G) : set (set G)
{F : Type u ‚Üí Type u} [functor F] [q : qpf F] : qpf.cofix F ‚Üí F (qpf.cofix F)
{Œπ : Type u_1} (f g : Œπ ‚Üí cardinal) (H : ‚àÄ (i : Œπ), f i < g i) : cardinal.sum f < cardinal.prod g
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) : 2 ‚Ä¢ o.oangle (-x) y = 2 ‚Ä¢ o.oangle x y
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cocone F} (h : category_theory.limits.is_colimit t) (s : category_theory.limits.cocone F) : ‚àÉ! (d : t.X ‚ü∂ s.X), ‚àÄ (j : J), t.Œπ.app j ‚â´ d = s.Œπ.app j
(Œ± : Type u_1) [encodable Œ±] (n : ‚Ñï) : option Œ±
(R : Type u_1) (A : Type u_2) [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A] : submodule R A
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [linear_ordered_add_comm_group Œ±] [archimedean Œ±] (h : function.periodic f c) (hc : 0 < c) (x a : Œ±) : ‚àÉ (y : Œ±) (H : y ‚àà set.Ioc a (a + c)), f x = f y
 : (user_attribute unit)
(x : pgame) (h : x.numeric) : surreal
{A : Type u} [category_theory.category A] [category_theory.abelian A] {X Y Z : A} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (w : f ‚â´ g = 0) : homology f g w ‚âÖ category_theory.limits.kernel (category_theory.limits.cokernel.desc f g w)
{Œ± : Type u_1} [topological_space Œ±] [semiring Œ±] [topological_semiring Œ±] (s : subsemiring Œ±) : subsemiring Œ±
 : tactic (list (option string √ó list (pos √ó string)))
{R : Type u_1} [comm_semiring R] {R' : Type u_2} [monoid R'] {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] [distrib_mul_action R' M] [distrib_mul_action R' N] [tensor_product.compatible_smul R R' M N] (r : R') (m : M) (n : N) : (r ‚Ä¢ m) ‚äó‚Çú[R] n = m ‚äó‚Çú[R] (r ‚Ä¢ n)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] [complete_space E] (p q : subspace ùïú E) (h : is_compl p q) (hp : is_closed ‚Üëp) (hq : is_closed ‚Üëq) : E ‚ÜíL[ùïú] ‚Ü•p
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {K : set (E ‚ÜíL[ùïú] F)} (hK : is_complete K) : fderiv_measurable_aux.D f K ‚äÜ {x : E | differentiable_at ùïú f x ‚àß fderiv ùïú f x ‚àà K}
(x y : string) : bool
{Œ± : Type u} [pseudo_emetric_space Œ±] {s : set Œ±} (hs : s.subsingleton) : emetric.diam s = 0
{K : Type u} [field K] {Œπ : Sort u_1} [hŒπ : nonempty Œπ] {S : Œπ ‚Üí subfield K} (hS : directed has_le.le S) {x : K} : (x ‚àà ‚®Ü (i : Œπ), S i) ‚Üî ‚àÉ (i : Œπ), x ‚àà S i
{Œ± : Type u_1} {Œ≤ : Type u_2} {m : measurable_space Œ±} {f : measure_theory.filtration ‚Ñï m} {u : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {œÑ : Œ± ‚Üí ‚Ñï} [add_comm_monoid Œ≤] [topological_space Œ≤] [has_continuous_add Œ≤] (hu : measure_theory.adapted f u) (hœÑ : measure_theory.is_stopping_time f œÑ) : measure_theory.adapted f (measure_theory.stopped_process u œÑ)
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b : Œ±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {E : Type u_4} (F : Type u_6) [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] (œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ) [ring_hom_isometric œÉ‚ÇÅ‚ÇÇ] : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] (E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F) ‚ÜíL[ùïú‚ÇÇ] F
{V : Type u_4} [inner_product_space ‚ÑÇ V] (T : V ‚Üí‚Çó[‚ÑÇ] V) : (‚àÄ (x : V), has_inner.inner (‚áëT x) x = 0) ‚Üî T = 0
(Œ± : Type u_6) : Type u_6
(M : Type u_1) [add_monoid M] : add_action M M
 : snum ‚Üí Œ† (n : ‚Ñï), vector bool n
{Œ± : Type u} [ordered_cancel_add_comm_monoid Œ±] {Œ≤ : Type u_1} [has_zero Œ≤] [has_add Œ≤] [has_scalar ‚Ñï Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : ordered_cancel_add_comm_monoid Œ≤
{J : Type v} {C : Type u} [category_theory.category C] {F : category_theory.limits.wide_pushout_shape J ‚•§ C} {X : C} (f : F.obj option.none ‚ü∂ X) (Œπ : Œ† (j : J), F.obj (option.some j) ‚ü∂ X) (w : ‚àÄ (j : J), F.map (category_theory.limits.wide_pushout_shape.hom.init j) ‚â´ Œπ j = f) : category_theory.limits.cocone F
{n : ‚Ñï} (p : fin n ‚Üí Prop) [decidable_pred p] : option (fin n)
 : environment ‚Üí ‚Ñï
(cl : tactic.closure) (path : list (expr √ó expr)) (e : expr) : tactic unit
{Œ± : Type u} (i : ‚Ñï) (t : ordnode Œ±) : ordnode Œ±
{R : Type u} [comm_ring R] (r : R) : ratfunc R ‚Üí+* ratfunc R
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] : Mon_ C ‚•§ category_theory.lax_monoidal_functor (category_theory.discrete punit) C
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] (f : C(Œ±, Œ≤)) (C : ‚Ñù) (h : ‚àÄ (x y : Œ±), has_dist.dist (‚áëf x) (‚áëf y) ‚â§ C) : bounded_continuous_function Œ± Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} [t : topological_space Œ±] [polish_space Œ±] [measurable_space Œ±] [borel_space Œ±] [tŒ≤ : topological_space Œ≤] [topological_space.second_countable_topology Œ≤] [measurable_space Œ≤] [borel_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : measurable f) : ‚àÉ (t' : topological_space Œ±), t' ‚â§ t ‚àß continuous f ‚àß polish_space Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : filter Œπ} [topological_space Œ±] (h : tendsto_uniformly F f p) (hc : ‚àÄ·∂† (n : Œπ) in p, continuous (F n)) [p.ne_bot] : continuous f
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] [normed_group G] [normed_space ùïú G] (q : formal_multilinear_series ùïú F G) (p : formal_multilinear_series ùïú E F) (hq : 0 < q.radius) (hp : 0 < p.radius) : ‚àÉ (r : nnreal) (H : r > 0), summable (Œª (i : Œ£ (n : ‚Ñï), composition n), ‚à•q.comp_along_composition p i.snd‚à•‚Çä * r ^ i.fst)
{R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z ‚Üî shelf.act x z = z
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_assoc_semiring Œ±} {rŒ≤ : non_assoc_semiring Œ≤} (f : Œ± ‚Üí+* Œ≤) : ‚áëf 0 = 0
(R : Type u_2) (M : Type u_3) (N : Type u_4) (P : Type u_5) (Q : Type u_6) [comm_ring R] [add_comm_group M] [add_comm_group N] [add_comm_group P] [add_comm_group Q] [module R M] [module R N] [module R P] [module R Q] [module.free R M] [module.finite R M] [module.free R N] [module.finite R N] [nontrivial R] : tensor_product R (M ‚Üí‚Çó[R] P) (N ‚Üí‚Çó[R] Q) ‚âÉ‚Çó[R] tensor_product R M N ‚Üí‚Çó[R] tensor_product R P Q
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_assoc_semiring Œ±} {rŒ≤ : non_assoc_semiring Œ≤} (f : Œ± ‚Üí+* Œ≤) : 0 = 1 ‚Üî ‚áëf 1 = 0
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) {r : ‚Ñù} (hr : r ‚â† 0) : 2 ‚Ä¢ o.oangle (r ‚Ä¢ x) y = 2 ‚Ä¢ o.oangle x y
(z w : ‚ÑÇ) : complex.abs (z + w) ‚â§ complex.abs z + complex.abs w
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] (a : Œ±) {b : Œ±} : 0 < b ‚Üí a - b < a
{C : Type u} [category_theory.category C] {X Y Z : algebraic_geometry.PresheafedSpace C} (f : X ‚ü∂ Z) [hf : algebraic_geometry.PresheafedSpace.is_open_immersion f] (g : Y ‚ü∂ Z) : Y.restrict _ ‚ü∂ X
{a : ‚Ñù} {l : filter ‚Ñù} {f f' g g' : ‚Ñù ‚Üí ‚Ñù} (hff' : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.Iio a), has_deriv_at f (f' x) x) (hgg' : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.Iio a), has_deriv_at g (g' x) x) (hg' : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.Iio a), g' x ‚â† 0) (hfa : filter.tendsto f (nhds_within a (set.Iio a)) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.Iio a)) (nhds 0)) (hdiv : filter.tendsto (Œª (x : ‚Ñù), f' x / g' x) (nhds_within a (set.Iio a)) l) : filter.tendsto (Œª (x : ‚Ñù), f x / g x) (nhds_within a (set.Iio a)) l
{G : Type u_1} [group G] (tG : monoid.is_torsion G) (bounded : (set.range (Œª (g : G), order_of g)).finite) : monoid.exponent_exists G
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [semi_normed_group E] [normed_space ùïú E] [proper_space ùïú] (x' : normed_space.dual ùïú E) (r : ‚Ñù) : is_compact (‚áëweak_dual.to_normed_dual ‚Åª¬π' metric.closed_ball x' r)
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (a : erased Œ±) (f : Œ± ‚Üí erased Œ≤) : erased Œ≤
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [fintype Œπ] (b : basis Œπ R M) (x : Œπ ‚Üí R) : ‚áë(b.equiv_fun.symm) x = finset.univ.sum (Œª (i : Œπ), x i ‚Ä¢ ‚áëb i)
 : fact (1 ‚â§ 2)
{A : Type v} [ring A] {R : Type u} [comm_ring R] [algebra R A] {M : Type w} [add_comm_group M] [module R M] [module A M] [is_scalar_tower R A M] : lie_module R A M
(R : Type u) [comm_ring R] : Type u
{A : Type u_2} [add_monoid A] (s : set A) : Prop
{Œ± : Type u} [pseudo_emetric_space Œ±] {s : set Œ±} (ne : s.nonempty) : emetric.Hausdorff_edist s ‚àÖ = ‚ä§
{n : ‚Ñï} (x y : bitvec n) : Prop
{R : Type u} [comm_semiring R] [star_ring R] : ring_hom_inv_pair (star_ring_end R) (star_ring_end R)
{a : Prop} : ¬¨¬¨a ‚Üî a
(Œ± : Type u) : Type u
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x : V) {r : ‚Ñù} : 2 ‚Ä¢ hb.oangle (r ‚Ä¢ x) x = 0
{Œ± : Type u_1} [boolean_ring Œ±] : has_sup Œ±
(s' : tactic_state) : tactic unit
{R : Type u_1} [comm_semiring R] {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] (x : R) [is_localization.away x S] (y : R) [algebra R P] [is_localization.away (x * y) P] : S ‚Üí+* P
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} : strict_anti f ‚Üí strict_mono (f ‚àò ‚áëorder_dual.of_dual)
(n : ‚Ñï) : linarith.linexp ‚Üí option ‚Ñ§
{G : Type u_1} [add_group G] {G' : Type u_4} [add_group G'] (f : G ‚Üí+ G') (H' : add_subgroup G') : ‚Ü•(add_subgroup.comap f H') ‚Üí+ ‚Ü•H'
{C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} (S : J.cover X) : Type (max u v)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e e' : local_homeomorph Œ± Œ≤} (h : e ‚âà e') : e.to_local_equiv.source = e'.to_local_equiv.source
{F : Type u_4} [semi_normed_group F] {E : Type u_1} [add_comm_group E] (f : E ‚Üí+ F) : semi_normed_group E
{M : Type u_1} {G : Type u_2} [add_zero_class M] [add_comm_group G] : add_comm_group (M ‚Üí+ G)
{F : Type u_4} [normed_group F] {E : Type u_1} [add_comm_group E] (f : E ‚Üí+ F) (h : function.injective ‚áëf) : normed_group E
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F G : J ‚•§ C} [category_theory.limits.has_colimit F] (Œ± : G ‚âÖ F) : category_theory.limits.has_colimit G
(Œ± : Type u) [t : topological_space Œ±] [topological_space.separable_space Œ±] [nonempty Œ±] : ‚àÉ (u : ‚Ñï ‚Üí Œ±), dense_range u
{Œ± : Type u_2} [preorder Œ±] (s t : set Œ±) (h : s = t) : ‚Ü•s ‚âÉo ‚Ü•t
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ‚Ñ§] [category_theory.preadditive C] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_object D] [category_theory.has_shift D ‚Ñ§] [category_theory.preadditive D] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor D n).additive] [category_theory.triangulated.pretriangulated C] [category_theory.triangulated.pretriangulated D] (F : category_theory.triangulated.pretriangulated.triangulated_functor C D) : category_theory.triangulated.triangle C ‚•§ category_theory.triangulated.triangle D
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [finite_dimensional ùïú E] (K : submodule ùïú E) : finite_dimensional.finrank ùïú ‚Ü•K + finite_dimensional.finrank ùïú ‚Ü•K·óÆ = finite_dimensional.finrank ùïú E
 : tactic name
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_images C] (f : X ‚ü∂ Y) : category_theory.subobject X ‚•§ category_theory.subobject Y
(old new : name) : expr ‚Üí expr
(Œ± : Type u_1) [topological_space Œ±] : Type u_1
{Œ± : Type u} [pseudo_metric_space Œ±] : pseudo_emetric_space Œ±
{Œ± : Type u_1} {Œπ : Type u_3} {m : measurable_space Œ±} [preorder Œπ] {ùí¢ : measure_theory.filtration Œπ m} {œÑ Œ∑ : Œ± ‚Üí Œπ} {i : Œπ} {s : set Œ±} [decidable_pred (Œª (_x : Œ±), _x ‚àà s)] (hœÑ_st : measure_theory.is_stopping_time ùí¢ œÑ) (hŒ∑_st : measure_theory.is_stopping_time ùí¢ Œ∑) (hœÑ : ‚àÄ (x : Œ±), i ‚â§ œÑ x) (hŒ∑ : ‚àÄ (x : Œ±), i ‚â§ Œ∑ x) (hs : measurable_set s) : measure_theory.is_stopping_time ùí¢ (s.piecewise œÑ Œ∑)
{V : Type u_1} {P : Type u_2} [normed_group V] [normed_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s u : set P} (hu : is_open u) (hsu : s ‚äÜ u) (hne : s.nonempty) (h : affine_independent ‚Ñù coe) : ‚àÉ (t : set P), s ‚äÜ t ‚àß t ‚äÜ u ‚àß affine_independent ‚Ñù coe ‚àß affine_span ‚Ñù t = ‚ä§
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] (F : C ‚•§ D) [category_theory.reflects_isomorphisms F] (K : J ‚•§ C) : category_theory.reflects_isomorphisms (category_theory.limits.cocones.functoriality K F)
(cl : tactic.closure) (e : expr) : tactic unit
{C : Type u} [category_theory.category C] [category_theory.abelian C] : has_coe_to_sort C (Type (max u v))
{S : Type u} [pgame.state S] (s : S) : (pgame.of s).right_moves ‚âÉ {t // t ‚àà pgame.state.R s}
(hs : list tactic.simp_arg_type) : tactic (list (pexpr √ó bool) √ó list name √ó list name √ó bool)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : setoid Œ±
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) {r : R} (h : 0 ‚â§ r) : same_ray R v (r ‚Ä¢ v)
(ps : tactic.list_Pi pexpr) (pat : tactic.rcases_patt) : tactic unit
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] (i j k : D.to_glue_data.J) (U : topological_space.opens ‚Ü•((D.to_glue_data.U i).carrier)) : D.opens_image_preimage_map i j U ‚â´ (D.to_glue_data.f j k).c.app (opposite.op ((topological_space.opens.map (D.to_glue_data.Œπ j).base).obj (_.functor.obj U))) = (category_theory.limits.pullback.fst ‚â´ D.to_glue_data.t j i ‚â´ D.to_glue_data.f i j).c.app (opposite.op U) ‚â´ _.inv_app (opposite.unop ((topological_space.opens.map (category_theory.limits.pullback.fst ‚â´ D.to_glue_data.t j i ‚â´ D.to_glue_data.f i j).base).op.obj (opposite.op U))) ‚â´ (D.to_glue_data.V (j, k)).presheaf.map (category_theory.eq_to_hom _)
(R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A] : R ‚Üí+* A
{M : Type u_9} {M‚ÇÇ : Type u_11} [add_comm_group M] [add_comm_group M‚ÇÇ] (f : M ‚Üí+ M‚ÇÇ) : M ‚Üí‚Çó[‚Ñ§] M‚ÇÇ
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : Type w) [category_theory.category J] (F : C·µí·µñ ‚•§ D) [category_theory.limits.preserves_colimits_of_shape J·µí·µñ F] : category_theory.limits.preserves_limits_of_shape J F.right_op
 : CommRing·µí·µñ ‚•§ algebraic_geometry.Scheme
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} : strict_mono f ‚Üí strict_anti (f ‚àò ‚áëorder_dual.of_dual)
{Œ± : Type u_2} [decidable_eq Œ±] [division_monoid Œ±] : division_monoid (finset Œ±)
(G : Type u_1) [comm_group G] : monoid.is_torsion_free (G ‚ß∏ torsion G)
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [add_comm_monoid Œ≤] [add_comm_monoid Œ≥] (g : Œ≤ ‚âÉ+ Œ≥) (f : Œ± ‚Üí Œ≤) (s : finset Œ±) : ‚áëg (s.sum (Œª (x : Œ±), f x)) = s.sum (Œª (x : Œ±), ‚áëg (f x))
{R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] [is_localization M S] : ‚Ü•(submonoid.map ‚Üë(algebra_map R S) M) ‚âÉ* ‚Ü•(is_localization.inv_submonoid M S)
{m : Type u ‚Üí Type u} [monad m] {Œ± : Type u} : tactic.mllist m Œ± ‚Üí Œ± ‚Üí tactic.mllist m Œ±
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (a : Œ±) : Prop
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : has_dist.dist p1 p2 ‚â† 0
{Œ± : Type u_1} (r : setoid Œ±) : {s // r ‚â§ s} ‚âÉo setoid (quotient r)
{Œ± : Type u_1} [measurable_space Œ±] (f : Œ± ‚Üí ennreal) (n : ‚Ñï) : measure_theory.simple_func Œ± nnreal
{G : Type u} [group G] {x : G} : is_of_fin_order x‚Åª¬π ‚Üî is_of_fin_order x
{R : Type u_1} [comm_semiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} {Q : Type u_7} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [add_comm_monoid Q] [module R M] [module R N] [module R P] [module R Q] (f : M ‚âÉ‚Çó[R] P) (g : N ‚âÉ‚Çó[R] Q) : tensor_product R M N ‚âÉ‚Çó[R] tensor_product R P Q
(Œ± : Type u_1) [semilattice_sup Œ±] [order_bot Œ±] : SemilatticeSup
(c : ‚ÑÇ) (R : ‚Ñù) : ‚Ñù ‚Üí ‚ÑÇ
 : Mon_ (Type u) ‚âå Mon
(e : interactive.parse interactive.types.texpr) : tactic unit
(M : Type u_10) (Œ± : Type u_11) [has_vadd M Œ±] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_initial C] [category_theory.limits.has_initial D] (f : ‚ä•_ D ‚âÖ G.obj (‚ä•_ C)) : category_theory.limits.preserves_colimit (category_theory.functor.empty C) G
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p p' : submodule R M) : (‚Ü•p ‚ß∏ submodule.comap p.subtype (p ‚äì p')) ‚âÉ‚Çó[R] ‚Ü•(p ‚äî p') ‚ß∏ submodule.comap (p ‚äî p').subtype p'
{f : ‚ÑÇ ‚Üí ‚ÑÇ} {c z : ‚ÑÇ} {R : ‚Ñù} (hd : differentiable_on ‚ÑÇ f (metric.ball c R)) (h_maps : set.maps_to f (metric.ball c R) (metric.ball c R)) (hc : f c = c) (hz : z ‚àà metric.ball c R) : has_dist.dist (f z) c ‚â§ has_dist.dist z c
(M : Type u_1) (A : Type u_4) [monoid M] [monoid A] [mul_distrib_mul_action M A] : M ‚Üí* monoid.End A
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] : Œ± √ó (Œ≤ ‚äï Œ≥) ‚âÉ‚Çú Œ± √ó Œ≤ ‚äï Œ± √ó Œ≥
 : user_attribute unit (option name)
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] (F : C ‚•§ D) [F.preserves_zero_morphisms] [category_theory.limits.preserves_biproducts_of_shape category_theory.limits.walking_pair F] : category_theory.limits.preserves_binary_biproducts F
(ùïÜ : Type u_5) (Œ± : Type u_6) [preorder ùïÜ] [preorder Œ±] : Type (max u_5 u_6)
{C : Type u‚ÇÅ} [category_theory.category C] (G : category_theory.comonad C) : ‚ÜëG ‚ü∂ ‚ÜëG ‚ãô ‚ÜëG
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_initial C
(A : Type w) (B : Type u‚ÇÅ) (C : Type u_1) [comm_ring A] [comm_ring B] [comm_ring C] [algebra A B] [algebra B C] [algebra A C] [is_scalar_tower A B C] [is_noetherian_ring A] (hAC : ‚ä§.fg) (hBC : ‚ä§.fg) (hBCi : function.injective ‚áë(algebra_map B C)) : ‚ä§.fg
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {S : D} {Y : C} {T : C ‚•§ D} (f : S ‚ü∂ T.obj Y) : category_theory.structured_arrow S T
{Œ± : Type u_1} {M : Type u_5} [has_zero M] (a : Œ±) : function.injective (finsupp.single a)
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] : unique_factorization_monoid R
{C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] [category_theory.limits.has_limits C] (F : J ‚•§ C) : category_theory.limits.limit F ‚ü∂ ‚àè Œª (j : J), F.obj j
{Œ± : Type u_1} [linear_ordered_field Œ±] [floor_ring Œ±] (x : Œ±) : ‚Ñ§
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [has_add Œπ] [graded_monoid.ghas_mul A] : has_mul (graded_monoid A)
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_group Œ±] [subtraction_monoid Œ≤] (f : Œ± ‚Üí+ Œ≤) (a : Œ±) : ‚áëf (-a) = -‚áëf a
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : lie_module.is_nilpotent R L M ‚Üî ‚àÉ (k : ‚Ñï), lie_module.lower_central_series R L M k = ‚ä•
{E : Type u_2} [semi_normed_group E] [normed_space ‚Ñù E] {s t : set E} (disj : disjoint s t) (hs‚ÇÅ : convex ‚Ñù s) (hs‚ÇÇ : is_compact s) (ht‚ÇÅ : convex ‚Ñù t) (ht‚ÇÇ : is_closed t) : ‚àÉ (u v : set E), is_open u ‚àß is_open v ‚àß convex ‚Ñù u ‚àß convex ‚Ñù v ‚àß s ‚äÜ u ‚àß t ‚äÜ v ‚àß disjoint u v
{Œ± : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [comm_semiring A] [semiring Œ±] [algebra R A] [algebra A Œ±] (S : subalgebra R A) : algebra ‚Ü•S Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u} [category_theory.category J] {X : J} (hX : category_theory.limits.is_initial X) (F : J ‚•§ C) [‚àÄ (i j : J) (f : i ‚ü∂ j), category_theory.is_iso (F.map f)] : category_theory.limits.cocone F
{M : Type u_5} {N : Type u_6} {M' : Type u_8} {N' : Type u_9} [has_add M] [has_add N] [has_add M'] [has_add N'] (f : add_hom M M') (g : add_hom N N') : add_hom (M √ó N) (M' √ó N')
{Œ± : Type u_2} [decidable_eq Œ±] [add_comm_semigroup Œ±] : add_comm_semigroup (finset Œ±)
(Œ± : Type u_2) [has_bot Œ±] : bot_hom Œ± Œ±
{R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M ‚Üí‚Çó[R] M) (k : ‚Ñï) : f ^ k = ‚áë(polynomial.aeval f) (polynomial.X ^ k %‚Çò f.charpoly)
(C : Type u) [category_theory.category C] {X Y : Top} (f : X ‚ü∂ Y) : Top.presheaf C X ‚•§ Top.presheaf C Y
{V : Type u} {G : simple_graph V} : G.subgraph
{m : Type u} {n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix m n Œ±) (B : matrix n n Œ±) [invertible B] : (A.mul B).mul (‚Öü B) = A
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K ‚Üí ratfunc K
(L : first_order.language) (Œ± : Type w) : L ‚Üí·¥∏ L.with_constants Œ±
{F : pfunctor} [decidable_eq F.A] [inhabited F.M] : pfunctor.approx.path F ‚Üí F.M ‚Üí F.M
(R : Type u) [comm_ring R] : Type u
{Œ± : Type u} [pseudo_emetric_space Œ±] {x : Œ±} {s : set Œ±} : x ‚àà closure s ‚Üî emetric.inf_edist x s = 0
(R : Type u_1) {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (s : set M) : submodule R M
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [densely_ordered Œ±] {Œ¥ : Type u_1} [linear_order Œ¥] [topological_space Œ¥] [order_closed_topology Œ¥] {f : Œ± ‚Üí Œ¥} (hf : continuous f) (h_top : filter.tendsto f filter.at_bot filter.at_top) (h_bot : filter.tendsto f filter.at_top filter.at_bot) : function.surjective f
(R : Type u_2) (M : Type u_3) [comm_semiring R] [add_comm_monoid M] [module R M] : tensor_product R (module.dual R M) M ‚Üí‚Çó[R] R
{Œ± : Type u} {Œπ : Sort x} (f : Œπ ‚Üí Œ±) : set Œ±
{n m : ‚Ñï} (P : mvpfunctor n) (Q : fin2 n ‚Üí mvpfunctor m) : mvpfunctor m
{Œ± : Type u} [topological_space Œ±] {s U : set Œ±} (h : U ‚àà ‚®Ü (x : Œ±) (H : x ‚àà s), nhds x) : ‚àÉ (V : set Œ±), s ‚äÜ V ‚àß is_open V ‚àß V ‚äÜ U
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_cancel_comm_monoid E] [ordered_add_comm_monoid Œ≤] [module ùïú E] [has_scalar ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : strict_concave_on ùïú s f) (c : E) : strict_concave_on ùïú ((Œª (z : E), c + z) ‚Åª¬π' s) (f ‚àò Œª (z : E), z + c)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (M : Type w) [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (œá : L ‚Üí R) : submodule R M
{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] (x : K) : ‚áë(algebra.trace K L) (‚áë(algebra_map K L) x) = finite_dimensional.finrank K L ‚Ä¢ x
{Œ± : Type u} [decidable_eq Œ±] [fintype Œ±] : equiv.perm Œ± ‚Üí* ‚Ñ§À£
(ùïú : Type u_1) {A : Type u_2} [normed_field ùïú] [ring A] [algebra ùïú A] (a : A) : ennreal
{C : Type u‚ÇÅ} [category_theory.small_category C] (A : C) : category_theory.limits.is_initial (category_theory.colimit_adj.elements.initial A)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (A : homological_complex V c) : A.hom A
{S : Type u_2} [comm_ring S] {A : Type u_4} [comm_ring A] [algebra A S] {S' : Type u_8} [comm_ring S'] [algebra A S'] [is_domain A] (pb : power_basis A S) (pb' : power_basis A S') (h : minpoly A pb.gen = minpoly A pb'.gen) : S ‚âÉ‚Çê[A] S'
 : declaration ‚Üí bool
{R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [semiring R] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] [semi_normed_group E] [semi_normed_group E‚ÇÇ] [module R E] [module R‚ÇÇ E‚ÇÇ] : has_coe_t (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) (E ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ)
 : hole_command
{n : ‚Ñï} (hpos : 0 < n) : irreducible (polynomial.cyclotomic n ‚Ñö)
{Œ± : Type u_1} {Œ≤ : Type u_3} {C : set (set Œ±)} {D : set (set Œ≤)} (hC : is_pi_system C) (hD : is_pi_system D) : is_pi_system (set.image2 has_set_prod.prod C D)
{T : Type u‚ÇÅ} [category_theory.category T] {X : T} (f : category_theory.over X) : category_theory.over f ‚•§ category_theory.over f.left
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (m : hash_map Œ± Œ≤) : list (Œ£ (a : Œ±), Œ≤ a)
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : setoid Œ±) (s : setoid Œ≤) : setoid (Œ± √ó Œ≤)
(b : pgame.domineering.board) : pgame
{ùïÇ : Type u_1} [nondiscrete_normed_field ùïÇ] [complete_space ùïÇ] (h : 0 < (exp_series ùïÇ ùïÇ).radius) : has_strict_deriv_at (exp ùïÇ) 1 0
{ùïú : Type u_1} {A : Type u_2} [nondiscrete_normed_field ùïú] [normed_ring A] [normed_algebra ùïú A] [complete_space A] {a : A} {r : nnreal} (hr : ‚Üër < (spectral_radius ùïú a)‚Åª¬π) : differentiable_on ùïú (Œª (z : ùïú), ring.inverse (1 - z ‚Ä¢ a)) (metric.closed_ball 0 ‚Üër)
{Œ± : Type u_1} {Œ≤ : Type u_2} {t : Œ±} {ts ys : list Œ±} {r : list Œ≤} (f : list Œ± ‚Üí Œ≤) : (list.permutations_aux2 t list.nil r ys (Œª (x : list Œ±), f (x ++ ts))).snd = (list.permutations_aux2 t ts r ys f).snd
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : relation.fibration (relation.game_add (relation.cut_expand r) (relation.cut_expand r)) (relation.cut_expand r) (Œª (s : multiset Œ± √ó multiset Œ±), s.fst + s.snd)
{ùïú : Type u_1} [is_R_or_C ùïú] {F : Type u_2} [semi_normed_group F] [normed_space ùïú F] [normed_space ‚Ñù F] [is_scalar_tower ‚Ñù ùïú F] (fr : F ‚ÜíL[‚Ñù] ‚Ñù) : F ‚ÜíL[ùïú] ùïú
{n p : ‚Ñï} : list.count p n.factors = ‚áë(n.factorization) p
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ‚àà S ‚Üí y ‚àà S ‚Üí x * y ‚àà S
 : expr ‚Üí option ‚Ñö
{Œ± : Type u_1} [ring Œ±] (self : ring.total_positive_cone Œ±) : add_comm_group.total_positive_cone Œ±
(R : Type u_3) [comm_ring R] : Prop
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] (E : Type u‚ÇÉ) [category_theory.category E] : C √ó D √ó E ‚•§ (C √ó D) √ó E
(Œ≤ ef : expr) (xs : list expr) : tactic (expr √ó expr)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [linear_order Œ≤] {f g : Œ± ‚Üí Œ≤} (hf : antitone f) (hg : antitone g) : antitone (Œª (x : Œ±), linear_order.min (f x) (g x))
(Œ± : Type u) {Œ≤ : Type v} [add_group Œ±] [add_action Œ± Œ≤] (b : Œ≤) : ‚Ü•(add_action.orbit Œ± b) ‚âÉ Œ± ‚ß∏ add_action.stabilizer Œ± b
{C : Type u} [category_theory.category C] {R X Y Z : C} {a b : R ‚ü∂ X} {f‚ÇÅ : X ‚ü∂ Y} {f‚ÇÇ : Y ‚ü∂ Z} (comm : a ‚â´ f‚ÇÅ = b ‚â´ f‚ÇÅ) (big_k : category_theory.is_kernel_pair (f‚ÇÅ ‚â´ f‚ÇÇ) a b) : category_theory.is_kernel_pair f‚ÇÅ a b
{S : Type u_2} [comm_ring S] {A : Type u_4} {B : Type u_5} [comm_ring A] [comm_ring B] [is_domain B] [algebra A B] [algebra A S] [is_domain A] (pb : power_basis A S) : fintype (S ‚Üí‚Çê[A] B)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {s : set ùïú} {n : with_top ‚Ñï} (Hcont : ‚àÄ (m : ‚Ñï), ‚Üëm ‚â§ n ‚Üí continuous_on (Œª (x : ùïú), iterated_deriv_within m f s x) s) (Hdiff : ‚àÄ (m : ‚Ñï), ‚Üëm < n ‚Üí differentiable_on ùïú (Œª (x : ùïú), iterated_deriv_within m f s x) s) : cont_diff_on ùïú n f s
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {G : C ‚•§ D} [category_theory.reflects_isomorphisms G] [category_theory.limits.has_colimits_of_size C] [category_theory.limits.preserves_colimits_of_size G] : category_theory.limits.reflects_colimits_of_size G
(Œ≤ : Type u_1) (Œ≥ : Type u_2) [measurable_space Œ≤] [measurable_space Œ≥] [has_pow Œ≤ Œ≥] : Type
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (p1 : P) {p2 p3 p4 : P} (h : euclidean_geometry.angle p2 p3 p4 = real.pi) : euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p1 p2 p4
(X : Type u_1) : free_abelian_group X ‚âÉ+ (X ‚Üí‚ÇÄ ‚Ñ§)
{Œ± : Type u_1} {Œº‚ÇÅ Œº‚ÇÇ : measure_theory.outer_measure Œ±} (h : ‚àÄ (s : set Œ±), s.nonempty ‚Üí ‚áëŒº‚ÇÅ s = ‚áëŒº‚ÇÇ s) : Œº‚ÇÅ = Œº‚ÇÇ
(f : turing.to_partrec.code) : turing.to_partrec.code
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [comm_monoid Œ≤] {s : finset Œ≥} {t : finset Œ±} {f : Œ≥ ‚Üí Œ± ‚Üí Œ≤} : (s.product t).prod (Œª (x : Œ≥ √ó Œ±), f x.fst x.snd) = s.prod (Œª (x : Œ≥), t.prod (Œª (y : Œ±), f x y))
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), add_comm_monoid (A i)] [add_comm_monoid Œπ] [direct_sum.gcomm_semiring A] : comm_semiring (direct_sum Œπ (Œª (i : Œπ), A i))
{M : Type u_5} {N : Type u_6} {P : Type u_7} [has_mul M] [has_mul N] [comm_semigroup P] (f : M ‚Üí‚Çô* P) (g : N ‚Üí‚Çô* P) : M √ó N ‚Üí‚Çô* P
{Œ± : Type u_1} [add_group Œ±] {s t : add_subgroup Œ±} (h_le : s ‚â§ t) : Œ± ‚ß∏ s ‚âÉ (Œ± ‚ß∏ t) √ó ‚Ü•t ‚ß∏ s.add_subgroup_of t
{R : Type u_1} {A : Type u_2} {M : Type u_3} {N : Type u_4} {P : Type u_5} [comm_semiring R] [comm_semiring A] [algebra R A] [add_comm_monoid M] [module R M] [module A M] [is_scalar_tower R A M] [add_comm_monoid N] [module R N] [add_comm_monoid P] [module R P] [module A P] [is_scalar_tower R A P] (f : M ‚Üí‚Çó[A] N ‚Üí‚Çó[R] P) : tensor_product R M N ‚Üí‚Çó[A] P
{G : Type u_1} [group G] : mul_action.is_pretransitive G·µê·µí·µñ G
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u} [category_theory.category J] {X : J} (tX : category_theory.limits.is_initial X) (F : J ‚•§ C) : category_theory.limits.is_limit (category_theory.limits.cone_of_diagram_initial tX F)
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) : F.is_sheaf ‚Üî F.is_sheaf_preserves_limit_pairwise_intersections
{V : Type u_1} [inner_product_space ‚Ñù V] (x y : V) {r : ‚Ñù} (hr : r < 0) : inner_product_geometry.angle (r ‚Ä¢ x) y = inner_product_geometry.angle (-x) y
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type u} [category_theory.category J] (E : D ‚•§ C) [category_theory.is_equivalence E] [category_theory.limits.has_limits_of_shape J C] : category_theory.limits.has_limits_of_shape J D
(n : ‚Ñï) : ‚Ñï
{X Y : algebraic_geometry.LocallyRingedSpace} (f : X.to_SheafedSpace ‚ü∂ Y.to_SheafedSpace) [category_theory.is_iso f] : X ‚ü∂ Y
(M : Type u) : Type u
{n : ‚Ñï} {Œ± : fin n ‚Üí Type u} (a : d_array n Œ±) (i : fin n) (v : Œ± i) : d_array n Œ±
{R : Type u} [ring R] (M N : Module R) : M ‚äû N ‚âÖ Module.of R (‚Ü•M √ó ‚Ü•N)
 : zmod 8 ‚Üí*‚ÇÄ ‚Ñ§
 : Type
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} : antitone f ‚Üí monotone (f ‚àò ‚áëorder_dual.of_dual)
{Œ± : Type u} [metric_space Œ±] [proper_space Œ±] {R : Œ± ‚Üí ‚Ñù} (hR : ‚àÄ (x : Œ±), 0 < R x) : ‚àÉ (Œπ : Type u) (c : Œπ ‚Üí Œ±) (r r' : Œπ ‚Üí ‚Ñù), (‚àÄ (i : Œπ), 0 < r i ‚àß r i < r' i ‚àß r' i < R (c i)) ‚àß locally_finite (Œª (i : Œπ), metric.ball (c i) (r' i)) ‚àß (‚ãÉ (i : Œπ), metric.ball (c i) (r i)) = set.univ
{C : Type u} [category_theory.category C] (F : C·µí·µñ ‚•§ Type v) : (category_theory.costructured_arrow category_theory.yoneda F)·µí·µñ ‚•§ F.elements
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (Y : category_theory.subobject X) : category_theory.subobject ‚ÜëY ‚âÉo ‚Ü•(set.Iic Y)
(C : Type u) [category_theory.category C] : C·µí·µñ √ó C ‚•§ Type v
{Œ± : Type u_1} {E : Œ± ‚Üí Type u_2} [Œ† (i : Œ±), normed_group (E i)] [decidable_eq Œ±] (p : ennreal) (i : Œ±) (a : E i) : ‚Ü•(lp E p)
(R' : Type u) (S' : Type v) (T' : Type w) [comm_semiring R'] [semiring S'] [algebra R' S'] [has_scalar S' T'] : has_scalar (polynomial R') (S' ‚Üí T')
{C : Type u_1} {G : Type u_2} [category_theory.category C] [group G] (f : C ‚Üí G) : C ‚•§ category_theory.single_obj G
{G : Type u} [group G] [fintype G] {p n : ‚Ñï} [hp : fact (nat.prime p)] {H : subgroup G} (hH : fintype.card ‚Ü•H = p ^ n) : fintype.card (‚Ü•(H.normalizer) ‚ß∏ subgroup.comap H.normalizer.subtype H) ‚â° fintype.card (G ‚ß∏ H) [MOD p]
{R : Type u_1} [comm_semiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] (f : tensor_product R M N ‚Üí‚Çó[R] P) : M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] P
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (s : set Œ±) : Œ± ‚Üí. Œ≤
{Œ± : Type u} {Œ≤ : Type v} [has_mul Œ≤] (f : Œ± ‚Üí Œ≤) : free_magma Œ± ‚Üí Œ≤
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] {K : Type u‚ÇÇ} [category_theory.category K] (F : D ‚•§ K ‚•§ C) (J : Type u_1) [category_theory.category J] (H : Œ† (k : K), category_theory.limits.preserves_limits_of_shape J (F ‚ãô (category_theory.evaluation K C).obj k)) : category_theory.limits.preserves_limits_of_shape J F
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {s : set E} {x : E} : mdifferentiable_within_at (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f s x ‚Üí differentiable_within_at ùïú f s x
{z : ‚ÑÇ} (hz : 0 < z.re) : continuous_at (Œª (x : ‚ÑÇ √ó ‚ÑÇ), x.fst ^ x.snd) (0, z)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) (x : Œ±) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (F : C ‚•§ D ‚•§ E) : D ‚•§ C ‚•§ E
(e : expr) : expr_set
 : onote ‚Üí onote √ó ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} [decidable_eq Œ≤] [fintype (Œ± √ó Œ≤)] [nonempty Œ±] : fintype Œ≤
{M : Type u_1} [add_comm_monoid M] (x : M) : add_submonoid.localization_map.away_map x (add_localization.away x)
{C : Type u‚ÇÅ} [category_theory.category C] : category_theory.creates_colimits_of_size (ùü≠ C)
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M ‚Üí+ P} (hg : ‚àÄ (y : ‚Ü•S), is_add_unit (‚áëg ‚Üëy)) (z : N) : ‚áëg ‚Üë((f.sec z).snd) + ‚áë(f.lift hg) z = ‚áëg (f.sec z).fst
(h : name) (t v : expr) : smt_tactic unit
{f : ‚Ñï ‚Üí‚ÇÄ ‚Ñï} (hf : ‚àÄ (p : ‚Ñï), p ‚àà f.support ‚Üí nat.prime p) : (f.prod has_pow.pow).factorization = f
(Œπ : Type u_1) [fintype Œπ] : is_compact (std_simplex ‚Ñù Œπ)
{X : Type u} {Y : Type v} [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] : Gromov_Hausdorff.HD (Gromov_Hausdorff.candidates_b_dist X Y) ‚â§ metric.diam set.univ + 1 + metric.diam set.univ
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {P Q : C} (f : P ‚ü∂ Q) : category_theory.abelian.factor_thru_image f ‚â´ category_theory.abelian.image.Œπ f = f
{H : Type u} [topological_space H] {Œ± : Type u_5} [topological_space Œ±] (e : local_homeomorph Œ± H) (h : e.to_local_equiv.source = set.univ) : charted_space H Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (f : category_theory.mono_over X) : ‚Üëf ‚ü∂ X
{Œ± : Type u} [preorder Œ±] {s : set Œ±} : ¬¨bdd_above s ‚Üî ‚àÄ (x : Œ±), ‚àÉ (y : Œ±) (H : y ‚àà s), ¬¨y ‚â§ x
(J : Type u‚ÇÅ) [category_theory.category J] (C : Type u) [category_theory.category C] : Prop
(M : Type u_9) (N : Type u_10) [mul_zero_one_class M] [mul_zero_one_class N] : Type (max u_10 u_9)
{G : Type u} [group G] (N : subgroup G) [nN : N.normal] : con G
{x y z : ‚Ñ§} : pythagorean_triple x y z ‚Üî pythagorean_triple y x z
(R : Type u_1) {Œ± : Type u_2} {Œ≤ : Type u_4} {l : Type u_8} {m : Type u_9} {n : Type u_10} {p : Type u_11} [comm_semiring R] [add_comm_monoid Œ±] [add_comm_monoid Œ≤] [module R Œ±] [module R Œ≤] : matrix l m Œ± ‚Üí‚Çó[R] matrix n p Œ≤ ‚Üí‚Çó[R] matrix (l √ó n) (m √ó p) (tensor_product R Œ± Œ≤)
(tm : turing.fin_tm2) (s : list (tm.Œì tm.k‚ÇÅ)) : tm.cfg
(attr_name : name) : tactic name
{R : Type u} [semiring R] : polynomial R ‚Üí finset ‚Ñï
(e : environment) : list name
{G : Type u_1} [group G] [topological_space G] [topological_group G] [t2_space G] (K‚ÇÄ : topological_space.positive_compacts G) : measure_theory.content G
{X : Type u_2} [emetric_space X] {s : set X} (hs : s.finite) : dimH s = 0
(Œ± : Type u_6) : Type u_6
(Œ± : Type u_6) [measurable_space Œ±] : Type u_6
 : vm_decl ‚Üí option ‚Ñï
(C : Type u_1) [category_theory.category C] : Prop
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {Œπ : Type u_2} (s : finset Œπ) (f : Œπ ‚Üí ideal R) (e : Œπ ‚Üí ‚Ñï) (prime : ‚àÄ (i : Œπ), i ‚àà s ‚Üí _root_.prime (f i)) (coprime : ‚àÄ (i : Œπ), i ‚àà s ‚Üí ‚àÄ (j : Œπ), j ‚àà s ‚Üí i ‚â† j ‚Üí f i ‚â† f j) : s.inf (Œª (i : Œπ), f i ^ e i) = s.prod (Œª (i : Œπ), f i ^ e i)
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddGroup) : AddMon
{Œ± : Type u} [topological_space Œ±] [compact_space Œ±] [discrete_topology Œ±] : fintype Œ±
{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ‚Ñï} (hb : 1 < b) {x : ‚Ñ§} {r : R} (hr : 0 < r) : r ‚â§ ‚Üëb ^ x ‚Üî int.clog b r ‚â§ x
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] (P : C·µí·µñ ‚•§ A) {X : C} (S : category_theory.sieve X) : nonempty (category_theory.limits.is_limit (P.map_cone S.arrows.cocone.op)) ‚Üî ‚àÄ (E : A·µí·µñ), category_theory.presieve.is_sheaf_for (P ‚ãô category_theory.coyoneda.obj E) ‚áëS
 : comm_ring (clifford_algebra clifford_algebra_complex.Q)
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] {Z : D} (F : C ‚•§ D) (M : Œ† (x : C), F.obj x ‚ü∂ Z) (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), F.map f ‚â´ M y = M x) : (category_theory.with_terminal.lift F M hM).obj category_theory.with_terminal.star ‚âÖ Z
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (m : pseudo_emetric_space Œ≤) : pseudo_emetric_space Œ±
{G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (s : subgroup G) (hs : ‚àÄ (x y : ‚Ü•s), x * y = y * x) : comm_group ‚Ü•(s.topological_closure)
{Œ± : Type u} (t s s' : set Œ±) : set Œ±
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] : localization M ‚âÉ‚Çê[R] S
(n : ‚Ñï) (x : ‚Ñù) : ‚Ñù
 : ‚Ñï ‚Üí vm (name √ó option expr)
 : expr_lens ‚Üí list expr_lens.dir
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} (H : C ‚•§ D) {c c' : category_theory.limits.cocone F} (f : c ‚ü∂ c') : H.map_cocone c ‚ü∂ H.map_cocone c'
{ùïú : Type u_1} [linear_ordered_field ùïú] {x y : ùïú} (h : x ‚â§ y) {z : ùïú} : z ‚àà set.Icc x y ‚Üî ‚àÉ (a b : ùïú), 0 ‚â§ a ‚àß 0 ‚â§ b ‚àß a + b = 1 ‚àß a * x + b * y = z
(n : ‚Ñï) : list (‚Ñï √ó ‚Ñï)
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A ‚ü∂ B) [category_theory.limits.has_image f] (g : B ‚ü∂ C) [category_theory.limits.has_kernel g] (w : f ‚â´ g = 0) [category_theory.limits.has_cokernel (image_to_kernel f g w)] {D : V} {k k' : homology f g w ‚ü∂ D} (p : homology.œÄ f g w ‚â´ k = homology.œÄ f g w ‚â´ k') : k = k'
{Œπ : Type u_1} {R : Type u_2} {M : Type u_3} [has_scalar R M] : has_scalar R (Œπ ‚Üí M)
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [add_zero_class Œ±] [add_zero_class Œ≤] : has_zero (Œ± ‚Üí+o Œ≤)
{A : Type u_4} {B : Type u_5} {C : Type u_6} [monoid A] [monoid B] [monoid C] [topological_space A] [topological_space B] [topological_space C] (f : continuous_monoid_hom A B) (g : continuous_monoid_hom A C) : continuous_monoid_hom A (B √ó C)
{p : ‚Ñï} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] : witt_vector p R ‚Üí+* witt_vector p R
{L : first_order.language} {Œ± : Type u'} [decidable_eq Œ±] : L.term Œ± ‚Üí finset Œ±
(P‚ÇÇ P‚ÇÅ : pfunctor) {Œ± : Type} (x : P‚ÇÇ.obj (P‚ÇÅ.obj Œ±)) : (P‚ÇÇ.comp P‚ÇÅ).obj Œ±
(R : CommRing) : (algebraic_geometry.Scheme.Spec.obj (opposite.op R)).open_cover
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} {f : C ‚ü∂ C} (h : homotopy f (ùüô C)) (g : C ‚ü∂ D) : homotopy (f ‚â´ g) g
(R : Type u_1) [semiring R] : power_series R ‚Üí+* R
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {T : D} {S : C ‚•§ D} {f f' : category_theory.costructured_arrow S T} (g : f.left ‚ü∂ f'.left) (w : S.map g ‚â´ f'.hom = f.hom) : f ‚ü∂ f'
(a b : interactive.parse lean.parser.small_nat) (t : conv.interactive.itactic) : tactic unit
{n : Type u_3} (R : Type u_7) {Œ± : Type v} [fintype n] [decidable_eq n] [comm_semiring R] [semiring Œ±] [algebra R Œ±] : (n ‚Üí Œ±) ‚Üí‚Çê[R] matrix n n Œ±
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] [decidable_eq Œπ] [add_monoid Œπ] (ùíú : Œπ ‚Üí submodule R A) [graded_algebra ùíú] : galois_coinsertion homogeneous_ideal.to_ideal (ideal.homogeneous_core ùíú)
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] (f : L.hom M N) (p : L.substructure M) : L.hom ‚Ü•p N
{R : Type u_2} [comm_semiring R] : polynomial R ‚Üí+* power_series R
{Œ± : Type u_1} (f : filter Œ±) : Type (max u_1 (u_5+1))
{m : Type u_1} {n : Type u_2} {K : Type u_4} [fintype n] [decidable_eq n] [field K] (A : matrix m n K) : ‚Ñï
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] : M.localization_map S
{G : Type u_1} {H : Type u_2} [add_group G] {N : add_subgroup G} [add_group H] {f : G ‚Üí+ H} (hf : function.surjective ‚áëf) (hN : N = f.ker) (tN : add_monoid.is_torsion ‚Ü•N) : add_monoid.is_torsion H ‚Üî add_monoid.is_torsion G
 : Type
 : expr ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí expr
(R : Type u_1) [comm_semiring R] (X : Type u_2) : has_zero (free_algebra.pre R X)
{P : ‚Ñï ‚Üí Prop} {m : ‚Ñï} (h0 : P m) (h1 : ‚àÄ (n : ‚Ñï), m ‚â§ n ‚Üí P n ‚Üí P (n + 1)) (n : ‚Ñï) : m ‚â§ n ‚Üí P n
{Œ± : Type u_1} [complete_lattice Œ±] (s : set Œ±) : Prop
 : name ‚Üí expr ‚Üí expr ‚Üí tactic unit
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] {p : P} : has_dist.dist p ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p) = 0 ‚Üî p ‚àà s
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ (v‚ÇÇ+1))
(Œ± : Type u_3) [topological_space Œ±] : Prop
{M : Type u_1} {N : Type u_2} {Œ± : Type u_6} [has_vadd M Œ±] (g : N ‚Üí M) (n : N) (a : Œ±) : Œ±
 : omega.nat.preform ‚Üí omega.nat.preform
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R ‚Üí+* S) (hf : function.surjective ‚áëf) : galois_insertion (ideal.map f) (ideal.comap f)
{Œ± : Type u_2} {Œ≤ : Type u_3} [decidable_eq Œ±] [has_vsub Œ± Œ≤] {u : finset Œ±} {s t : set Œ≤} : ‚Üëu ‚äÜ s -·µ• t ‚Üí (‚àÉ (s' t' : finset Œ≤), ‚Üës' ‚äÜ s ‚àß ‚Üët' ‚äÜ t ‚àß u ‚äÜ s' -·µ• t')
{Œ± : Type u_1} (P : Œ± ‚Üí Prop) (r : Œ± ‚Üí Œ± ‚Üí Prop) (h : ‚àÄ (s : finset Œ±), (‚àÄ (x : Œ±), x ‚àà s ‚Üí P x) ‚Üí (‚àÉ (y : Œ±), P y ‚àß ‚àÄ (x : Œ±), x ‚àà s ‚Üí r x y)) : ‚àÉ (f : ‚Ñï ‚Üí Œ±), (‚àÄ (n : ‚Ñï), P (f n)) ‚àß ‚àÄ (m n : ‚Ñï), m < n ‚Üí r (f m) (f n)
{G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] (p : P) : P ‚âÉ G
(n : name) : expr
(ic zc : tactic.instance_cache) (a' : expr) : tactic (tactic.instance_cache √ó tactic.instance_cache √ó expr √ó expr)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [baire_space Œ±] [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±} (ho : ‚àÄ (s : Œ≤), is_open (f s)) (hd : ‚àÄ (s : Œ≤), dense (f s)) : dense (‚ãÇ (s : Œ≤), f s)
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {b‚ÇÇ : basis (fin 2) ‚Ñù V} (hb‚ÇÇ : orthonormal ‚Ñù ‚áëb‚ÇÇ) (ho : b.orientation = b‚ÇÇ.orientation) (Œ∏ : real.angle) : hb.rotation Œ∏ = hb‚ÇÇ.rotation Œ∏
(C : Type u) [category_theory.category C] : Prop
{G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) ‚Üî is_of_fin_add_order x
(R : Type u) (M : Type v) [ring R] [add_comm_group M] [module R M] [module.free R M] [nontrivial R] [module.finite R M] : fintype (module.free.choose_basis_index R M)
{K : Type u_1} {v : K} {n : ‚Ñï} [linear_ordered_field K] [floor_ring K] {b : K} (nth_part_denom_eq : (generalized_continued_fraction.of v).partial_denominators.nth n = option.some b) : 1 ‚â§ b
{G : Type u_1} [add_group G] {H K : add_subgroup G} (h : H = K) : ‚Ü•H ‚âÉ+ ‚Ü•K
{Œπ : Type u_1} {M : Type u_2} {N : Type u_3} [add_comm_monoid M] [add_comm_monoid N] {I‚ÇÄ : with_top (box_integral.box Œπ)} (f : box_integral.box_additive_map Œπ M I‚ÇÄ) (g : M ‚Üí+ N) : box_integral.box_additive_map Œπ N I‚ÇÄ
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} (X : T.algebra) : category_theory.limits.cofork (T.to_functor.map X.a) (T.Œº.app X.A)
{Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : continuous (Œª (x : Œ±), metric.inf_dist x s)
(Œ± : Type u) (Œ≤ : Type v) [topological_space Œ±] [pseudo_metric_space Œ≤] [add_monoid Œ≤] [has_lipschitz_add Œ≤] : bounded_continuous_function Œ± Œ≤ ‚Üí+ C(Œ±, Œ≤)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ SemiRing) [category_theory.is_filtered J] : SemiRing
(Œ± : Type u_2) [boolean_algebra Œ±] : Œ± ‚âÉo Œ±·µí·µà
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x : V) : 2 ‚Ä¢ hb.oangle (-x) x = 0
{Œ± : Type u_1} {Œ≤ : Type u_2} {m‚ÇÅ : measurable_space Œ±} {m‚ÇÇ : measurable_space Œ≤} {f : Œ± ‚Üí Œ≤} : measurable_space.comap f m‚ÇÇ ‚â§ m‚ÇÅ ‚Üí measurable f
{Œ± : Type u_1} [metric_space Œ±] {Œ≤ : Type u} [nonempty Œ≤] (p : besicovitch.tau_package Œ≤ Œ±) (x : Œ≤) : p.to_ball_package.c x ‚àà p.Union_up_to p.last_step
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] (f : E √ó F ‚Üí G) : Prop
{C : Type u} [category_theory.category C] {X : Top} (‚Ñ± : Top.presheaf C X) : ùüô X _* ‚Ñ± ‚âÖ ‚Ñ±
(R : Type u) {A : Type v} [comm_semiring R] [star_ring R] [semiring A] [star_ring A] [algebra R A] [star_module R A] (s : set A) (w : ‚àÄ (a : A), a ‚àà s ‚Üí has_star.star a ‚àà s) : star_subalgebra R A
{R : Type u} {S : Type v} [semiring R] [semiring S] [nontrivial S] (f : R ‚Üí+* S) : 1 ‚àâ f.ker
{V : Type u} {G : simple_graph V} (x y : G.subgraph) : G.subgraph
{Œ≤ : Type u} {Œ± : Type v} {s : finset Œ±} [comm_monoid Œ≤] (f : Œ± ‚Üí Œ≤) {p : Œ± ‚Üí Prop} [decidable_pred p] : (finset.subtype p s).prod (Œª (x : subtype p), f ‚Üëx) = (finset.filter p s).prod (Œª (x : Œ±), f x)
{Œ± : Type u} {a b : Œ±} [mul_zero_class Œ±] [partial_order Œ±] [zero_lt.pos_mul_mono Œ±] (ha : 0 ‚â§ a) (hb : 0 ‚â§ b) : 0 ‚â§ a * b
{G : Type u_1} [add_group G] (S : set G) : set (set G)
{X Y S : Top} {f : X ‚ü∂ S} {g : Y ‚ü∂ S} (H‚ÇÅ : open_embedding ‚áëf) (H‚ÇÇ : open_embedding ‚áëg) : open_embedding ‚áë(category_theory.limits.limit.œÄ (category_theory.limits.cospan f g) category_theory.limits.walking_cospan.one)
 : Type (u_1+1)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1.direction ‚äî s2.direction ‚â§ (s1 ‚äî s2).direction
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (M : Mon_ C) : M.hom M
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {f : ‚ÑÇ ‚Üí E} (hf : differentiable ‚ÑÇ f) (z : ‚ÑÇ) : analytic_at ‚ÑÇ f z
{Œ± : Type u} (s : wseq Œ±) (p : Œ± ‚Üí bool) : computation bool
 : list tactic.simp_arg_type ‚Üí format
(M : Type u_1) (N : Type u_2) (Œ± : Type u_3) [has_scalar M Œ±] [has_scalar N Œ±] [smul_comm_class M N Œ±] : smul_comm_class N M Œ±
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] : Top.presheaf CommRing (projective_spectrum.Top ùíú)
 : (user_attribute simp_lemmas)
(Œ± : Type u_1) [monoid Œ±] : Type u_1
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop} (g : s ‚Üír t) (f : r ‚Üír s) : r ‚Üír t
(M : Type u_1) (Œ± : Type u_2) [monoid M] [mul_action M Œ±] {Œπ : Sort u_3} {s : Œπ ‚Üí set Œ±} : fixing_submonoid M (‚ãÉ (i : Œπ), s i) = ‚®Ö (i : Œπ), fixing_submonoid M (s i)
(E : Type u_1) [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] : is_empty (besicovitch.satellite_config E (besicovitch.multiplicity E) (besicovitch.good_œÑ E))
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] : module (module.End R M) M
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) [category_theory.is_filtered J] : category_theory.limits.is_colimit (AddMon.filtered_colimits.colimit_cocone F)
{A : Type u_1} {B : Type u_2} [comm_ring A] [comm_ring B] (f : A ‚Üí+* B) : Prop
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] : A ‚Üí‚Çê[R] ‚Ü•‚ä§
(mi : interactive.decl_meta_info) (_x : interactive.parse (lean.parser.tk "add_tactic_doc")) : lean.parser unit
(C : Type u‚ÇÅ) [category_theory.category C] : category_theory.monad C ‚•§ C ‚•§ C
{Œ± : Type u_1} [topological_space Œ±] (s : topological_space.compact_opens Œ±) : topological_space.opens Œ±
 : filter.tendsto (Œª (N : ‚Ñï), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {x : E} {n : ‚Ñï} : cont_diff_at ùïú ‚Üë(n + 1) f x ‚Üî ‚àÉ (f' : E ‚Üí (E ‚ÜíL[ùïú] F)), (‚àÉ (u : set E) (H : u ‚àà nhds x), ‚àÄ (x : E), x ‚àà u ‚Üí has_fderiv_at f (f' x) x) ‚àß cont_diff_at ùïú ‚Üën f' x
{L : first_order.language} {M : Type u_3} {N : Type u_4} [L.Structure M] (e : M ‚âÉ N) : L.Structure N
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A ‚Üí algebra.finite_type R A
{Œ± : Type u_1} {Œ≤ : Type u_2} [semilattice_inf Œ±] [order_top Œ±] (s : finset Œ≤) (f : Œ≤ ‚Üí Œ±) : Œ±
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (p : Œπ ‚Üí P) (j : Œπ) (w‚ÇÅ w‚ÇÇ : Œπ ‚Üí k) (hw : ‚àÄ (i : Œπ), i ‚â† j ‚Üí w‚ÇÅ i = w‚ÇÇ i) : ‚áë(s.weighted_vsub_of_point p (p j)) w‚ÇÅ = ‚áë(s.weighted_vsub_of_point p (p j)) w‚ÇÇ
{Œ± : Type u_1} {œÑ : ‚Ñù} [inhabited Œ±] [metric_space Œ±] : inhabited (besicovitch.satellite_config Œ± 0 œÑ)
 : category_theory.limits.walking_parallel_family (ulift bool) ‚âå category_theory.limits.walking_parallel_pair
{n : ‚Ñï} {a b : fin n} : ‚Üëa < ‚Üëb ‚Üî a < b
{Œ± : Type u_1} {enum : Œ± ‚Üí ‚Ñï} (n : ‚Ñï) (s : derive_fintype.finset_in (Œª (a : Œ±), enum a = n)) (t : derive_fintype.finset_above Œ± enum (n + 1)) : derive_fintype.finset_above Œ± enum n
(Œ± : Type u_1) [fintype Œ±] : encodable Œ±
(R : Type u) (L : Type v) (M : Type w) (N : Type w‚ÇÅ) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [add_comm_group N] [module R M] [module R N] [lie_ring_module L M] [lie_ring_module L N] [lie_module R L M] [lie_module R L N] : Type (max w w‚ÇÅ)
{G : Type u_1} [group G] (K : subgroup G) {k : set G} : subgroup.closure k ‚â§ K ‚Üî k ‚äÜ ‚ÜëK
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [has_one M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñï] [has_inv M‚ÇÅ] [has_div M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñ§] [group M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (inv : ‚àÄ (x : M‚ÇÅ), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : M‚ÇÅ), f (x / y) = f x / f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (x ^ n) = f x ^ n) : group M‚ÇÅ
 : tactic expr
{n : ‚Ñï} (i : fin (n + 2)) : simplex_category.mk n ‚ü∂ simplex_category.mk (n + 1)
{Œ± : Type u_1} [linear_ordered_add_comm_group Œ±] {n : ‚Ñ§} {a b : Œ±} (hn : n ‚â† 0) : n ‚Ä¢ a = n ‚Ä¢ b ‚Üî a = b
(M : Type u_1) {Œ± : Type u_2} [add_group M] [add_action M Œ±] (s : set Œ±) : add_subgroup M
(p : ‚Ñï) [hp : fact (nat.prime p)] (q r : ‚Ñö) : padic_norm p (q / r) = padic_norm p q / padic_norm p r
{Œ± : Type u_2} [mul_one_class Œ±] : Œ± ‚Üí* filter Œ±
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {c : E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds a ‚äì measure_theory.measure_space.volume.ae) (nhds c)) : deriv (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in u..b, f x) a = -c
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] : P1 √ó P2 ‚Üí·µÉ[k] P1
{Œ≥ : Type u_1} [non_unital_non_assoc_semiring Œ≥] (x : Œ≥) : is_add_monoid_hom (Œª (y : Œ≥), y * x)
 : pSet ‚Üí pSet ‚Üí pSet
{V : Type u} {G : simple_graph V} [decidable_eq V] {v w : V} (p : G.walk v w) (u : V) (h : u ‚àà p.support) : G.walk v u
{R‚ÇÉ : Type u_7} [comm_ring R‚ÇÉ] {n : Type u_11} [fintype n] (J J‚ÇÉ : matrix n n R‚ÇÉ) [decidable_eq n] : submodule R‚ÇÉ (matrix n n R‚ÇÉ)
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (a : Œ±) : Œ± ‚Üí Prop
{C : Type u} [category_theory.category C] (J‚ÇÅ : category_theory.grothendieck_topology C) {X Y : C} (f : Y ‚ü∂ X) (S : category_theory.sieve X) : J‚ÇÅ.is_closed S ‚Üí J‚ÇÅ.is_closed (category_theory.sieve.pullback f S)
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} : complete_lattice (category_theory.sieve X)
{R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_4} {M‚ÇÇ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] [ring_hom_surjective œÉ‚ÇÅ‚ÇÇ] (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : set M) (N : submodule R‚ÇÇ M‚ÇÇ) : submodule.map f (submodule.span R s) ‚â§ N ‚Üî ‚àÄ (m : M), m ‚àà s ‚Üí ‚áëf m ‚àà N
{M : Type u_1} [mul_one_class M] {s : set M} {p : M ‚Üí M ‚Üí Prop} {x y : M} (hx : x ‚àà submonoid.closure s) (hy : y ‚àà submonoid.closure s) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí ‚àÄ (y : M), y ‚àà s ‚Üí p x y) (H1_left : ‚àÄ (x : M), p 1 x) (H1_right : ‚àÄ (x : M), p x 1) (Hmul_left : ‚àÄ (x y z : M), p x z ‚Üí p y z ‚Üí p (x * y) z) (Hmul_right : ‚àÄ (x y z : M), p z x ‚Üí p z y ‚Üí p z (x * y)) : p x y
{R : Type u} [ring R] {J : Type w} [category_theory.category J] (F : J ‚•§ Module R) : Module.colimits.prequotient F ‚Üí Module.colimits.prequotient F ‚Üí Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.full F] [category_theory.faithful F] : category_theory.limits.reflects_colimits_of_size F
(M : Type u_1) {Œ± : Type u_6} [monoid M] [mul_action M Œ±] (a‚ÇÅ a‚ÇÇ : M) : has_scalar.smul a‚ÇÅ ‚àò has_scalar.smul a‚ÇÇ = has_scalar.smul (a‚ÇÅ * a‚ÇÇ)
{R : Type u} [ring R] (s : subring R) {x : R} : x ‚àà s ‚Üí -x ‚àà s
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] : category_theory.lax_braided_functor (category_theory.discrete punit) C ‚•§ CommMon_ C
 : environment ‚Üí name ‚Üí option string
(n : ‚Ñï) : nonote
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] {N N' : lie_submodule R L M} (h : N ‚â§ N') : ‚Ü•N ‚Üí‚Çó‚ÅÖR,L‚ÅÜ ‚Ü•N'
{Œ± : Type u_1} {Œ≤ : Type u_2} {n : ‚Ñï} (f : Œ± ‚Üí Œ≤) (x : sym Œ± n) : sym Œ≤ n
 : Type
 : CommRing.free ‚ä£ category_theory.forget CommRing
{C : Type u} [category_theory.category C] : category_theory.arrow C ‚•§ C
(Œ± : Type u_1) [fintype Œ±] [category_theory.small_category Œ±] [category_theory.fin_category Œ±] : Type
{F : pfunctor} (x : F.M) : F.A
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [category_theory.limits.has_wide_coequalizer f] [nonempty J] : category_theory.epi (category_theory.limits.wide_coequalizer.œÄ f)
{Œ± : Type u} [partial_order Œ±] {a b : Œ±} : a ‚â§ b ‚Üí a < b ‚à® a = b
 : unique_diff_on ‚Ñù (set.Icc 0 1)
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [linear_ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f g : E ‚Üí Œ≤} (hf : strict_concave_on ùïú s f) (hg : strict_concave_on ùïú s g) : strict_concave_on ùïú s (f ‚äì g)
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] (L : A ‚•§ T) (R : B ‚•§ T) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÉ)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {p : formal_multilinear_series ùïú E F} {x : E} {r : ennreal} {r' : nnreal} (hf : has_fpower_series_on_ball f p x r) (h : ‚Üër' < r) : tendsto_uniformly_on (Œª (n : ‚Ñï) (y : E), p.partial_sum n (y - x)) f filter.at_top (metric.ball x ‚Üër')
{ùïú : Type u_1} {_x : comm_ring ùïú} {E : Type u_2} [normed_ring E] {_x_1 : algebra ùïú E} (s : subalgebra ùïú E) : normed_ring ‚Ü•s
{H : Type u} [topological_space H] : order_bot (structure_groupoid H)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) : D ‚•§ h.to_monad.algebra
 : omega.nat.preterm ‚Üí tactic expr
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (O : finset C) (H : finset (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y)) : C
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [‚àÄ (i : ùí∞.J), category_theory.limits.has_pullback (ùí∞.map i ‚â´ f) g] : (algebraic_geometry.Scheme.pullback.gluing ùí∞ f g).glued ‚ü∂ Y
{H : Type u} {M : Type u_2} [topological_space H] (c : charted_space_core H M) (e : local_equiv M H) (he : e ‚àà c.atlas) : local_homeomorph M H
{G : Type u} {x y : G} [fintype G] [add_group G] (h : add_order_of x = add_order_of y) : ‚Ü•‚Üë(add_subgroup.zmultiples x) ‚âÉ ‚Ü•‚Üë(add_subgroup.zmultiples y)
{R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Œπ : Type u_1} (b : basis Œπ R M) [infinite Œπ] {Œ∫ : Type u_1} (v : Œ∫ ‚Üí M) (i : linear_independent R v) : cardinal.mk Œ∫ ‚â§ cardinal.mk Œπ
{G : Type u_1} [group G] [is_free_group G] {H : Type u_1} [group H] (h : G ‚âÉ* H) : is_free_group H
(Œ± : Type u_1) : Type u_1
{X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X) : urysohns.CU X
(f : ‚Ñù ‚Üí ‚Ñù) {a b : ‚Ñù} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfI : f a = f b) : ‚àÉ (c : ‚Ñù) (H : c ‚àà set.Ioo a b), is_extr_on f (set.Icc a b) c
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [nondiscrete_normed_field ùïÇ] [normed_comm_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] [char_zero ùïÇ] {x : ùî∏} (hx : x ‚àà emetric.ball 0 (exp_series ùïÇ ùî∏).radius) : has_fderiv_at (exp ùïÇ) (exp ùïÇ x ‚Ä¢ 1) x
(F : pfunctor) [inhabited F.A] (n : ‚Ñï) : pfunctor.approx.cofix_a F n
{k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] [covariant_class M M has_add.add has_lt.lt] [contravariant_class M M has_add.add has_lt.lt] {a b : k} {c d : M} (hba : b < a) (hdc : d < c) : a ‚Ä¢ d + b ‚Ä¢ c < a ‚Ä¢ c + b ‚Ä¢ d
{X : Type u} {m‚ÇÅ m‚ÇÇ : X ‚Üí X ‚Üí X} {e‚ÇÅ e‚ÇÇ : X} (h‚ÇÅ : eckmann_hilton.is_unital m‚ÇÅ e‚ÇÅ) (h‚ÇÇ : eckmann_hilton.is_unital m‚ÇÇ e‚ÇÇ) (distrib : ‚àÄ (a b c d : X), m‚ÇÅ (m‚ÇÇ a b) (m‚ÇÇ c d) = m‚ÇÇ (m‚ÇÅ a c) (m‚ÇÅ b d)) : is_commutative X m‚ÇÇ
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : cochain_complex V ‚Ñï ‚•§ cochain_complex V ‚Ñï
 : tactic unit
{k : Type u_1} {V‚ÇÅ : Type u_2} {P‚ÇÅ : Type u_3} {V‚ÇÇ : Type u_4} {P‚ÇÇ : Type u_5} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] (f : P‚ÇÅ ‚Üí·µÉ[k] P‚ÇÇ) (s : affine_subspace k P‚ÇÇ) : affine_subspace k P‚ÇÅ
{R : Type u} [semiring R] {M : polynomial R ‚Üí Prop} (p : polynomial R) (h_add : ‚àÄ (p q : polynomial R), M p ‚Üí M q ‚Üí M (p + q)) (h_monomial : ‚àÄ (n : ‚Ñï) (a : R), M (‚áë(polynomial.monomial n) a)) : M p
{a x : ‚Ñù} (ha : a < 0) : has_strict_deriv_at (Œª (x : ‚Ñù), a ^ x) (a ^ x * real.log a - real.exp (real.log a * x) * real.sin (x * real.pi) * real.pi) x
{Œ± : Type u_1} [measurable_space Œ±] {M : Type u_3} [add_comm_monoid M] [topological_space M] {N : Type u_4} [add_comm_monoid N] [topological_space N] (v : measure_theory.vector_measure Œ± M) (f : M ‚Üí+ N) (hf : continuous ‚áëf) : measure_theory.vector_measure Œ± N
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.limits.reflects_colimit K F] : category_theory.limits.reflects_colimit K G
(x : ‚Ñù) : ‚Ñù
{K : Type u} [field K] {K' : Type u_1} [has_zero K'] [has_mul K'] [has_add K'] [has_neg K'] [has_sub K'] [has_one K'] [has_inv K'] [has_div K'] [has_scalar ‚Ñï K'] [has_scalar ‚Ñ§ K'] [has_pow K' ‚Ñï] [has_pow K' ‚Ñ§] (f : K' ‚Üí K) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : K'), f (x + y) = f x + f y) (mul : ‚àÄ (x y : K'), f (x * y) = f x * f y) (neg : ‚àÄ (x : K'), f (-x) = -f x) (sub : ‚àÄ (x y : K'), f (x - y) = f x - f y) (inv : ‚àÄ (x : K'), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : K'), f (x / y) = f x / f y) (nsmul : ‚àÄ (x : K') (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : K') (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : K') (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : K') (n : ‚Ñ§), f (x ^ n) = f x ^ n) : field K'
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : r ‚âÉr r
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [locally_compact_space Œ±] (a : Œ±) : continuous (Œª (f : C(Œ±, Œ≤)), ‚áëf a)
{R : Type u} [ring R] {J : Type w} [category_theory.category J] (F : J ‚•§ Module R) : Type (max u v w)
{G : Type u} [add_group G] (N : add_subgroup G) [nN : N.normal] (M : add_subgroup G) [nM : M.normal] (h : N ‚â§ M) : (G ‚ß∏ N) ‚ß∏ add_subgroup.map (quotient_add_group.mk' N) M ‚âÉ+ G ‚ß∏ M
{n : ‚Ñï} {A : Type u} (F : A ‚Üí typevec n ‚Üí Type u) (v : typevec n) : Type u
(K : Type u) [comm_ring K] (p : ‚Ñï) [fact (nat.prime p)] [char_p K p] : ‚Ñï √ó K ‚Üí ‚Ñï √ó K ‚Üí Prop
{R : Type u} {Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] {Œπ' : Type u_1} {M' : Œπ' ‚Üí Type u_2} [Œ† (i : Œπ'), add_comm_monoid (M' i)] [Œ† (i : Œπ'), topological_space (M' i)] [Œ† (i : Œπ'), module R (M' i)] (f : Œ† (i : Œπ'), continuous_multilinear_map R M‚ÇÅ (M' i)) : continuous_multilinear_map R M‚ÇÅ (Œ† (i : Œπ'), M' i)
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] : {x : Œ± | ‚àÉ (y : Œ±), y < x ‚àß set.Ioo y x = ‚àÖ}.countable
 : ordinal ‚âÉ cardinal
{R : Type u} [ring R] {J : Type v} (f : J ‚Üí Module R) (s : category_theory.limits.fan f) : s.X ‚ü∂ Module.of R (Œ† (j : J), ‚Ü•(f j))
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] (f : multilinear_map R M‚ÇÅ M‚ÇÇ) [fintype Œπ] (m m' : Œ† (i : Œπ), M‚ÇÅ i) : ‚áëf (m + m') = finset.univ.sum (Œª (s : finset Œπ), ‚áëf (s.piecewise m m'))
{n : ‚Ñï} (x y : bitvec n) : Prop
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] {f : J ‚Üí C} (t : category_theory.limits.bicone f) (ht : category_theory.limits.is_colimit t.to_cocone) : t.is_bilimit
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} {f' : ‚Ñù ‚Üí E} (hab : a ‚â§ b) (hcont : continuous_on f (set.Icc a b)) (hderiv : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí has_deriv_within_at f (f' x) (set.Ioi x) x) (f'int : interval_integrable f' measure_theory.measure_space.volume a b) : ‚à´ (y : ‚Ñù) in a..b, f' y = f b - f a
 : ‚ÑÇ ‚Üí+ ‚Ñù
(X : algebraic_geometry.Scheme) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [add_comm_monoid Œ±] [topological_space Œ±] [t2_space Œ±] [encodable Œ≥] (m : set Œ≤ ‚Üí Œ±) (m0 : m ‚àÖ = 0) (s : Œ≥ ‚Üí set Œ≤) : ‚àë' (i : ‚Ñï), m (‚ãÉ (b : Œ≥) (H : b ‚àà encodable.decode‚ÇÇ Œ≥ i), s b) = ‚àë' (b : Œ≥), m (s b)
{X : Top} {T : ‚Ü•X ‚Üí Type v} (P : Top.local_predicate T) (x : ‚Ü•X) : (Top.subsheaf_to_Types P).val.stalk x ‚ü∂ T x
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V‚ÇÇ : Type v'} [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] (f : V ‚Üí‚Çó[K] V‚ÇÇ) (w : function.injective ‚áëf) [finite_dimensional K V‚ÇÇ] : finite_dimensional K V
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type w} [category_theory.category J] {K : J ‚•§ C} (c : category_theory.limits.cocone (K ‚ãô ùü≠ C)) : category_theory.liftable_cocone K (ùü≠ C) c
{Œ± : Type u_1} {Œπ : Type u_3} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} [fintype Œπ] {t : Œπ ‚Üí set Œ±} (h : pairwise (disjoint on t)) (ht : ‚àÄ (i : Œπ), (t i).finite) : finsum (Œª (a : Œ±), finsum (Œª (H : a ‚àà ‚ãÉ (i : Œπ), t i), f a)) = finsum (Œª (i : Œπ), finsum (Œª (a : Œ±), finsum (Œª (H : a ‚àà t i), f a)))
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] (h : Œ± ‚âÉ·µ¢ Œ≤) : Œ≤ ‚Üí Œ±
(transform : expr ‚Üí tactic expr) (h : expr) : tactic unit
(M : Type u_1) [has_mul M] : M ‚Üí‚Çô* M
{J : Type v} {C : Type u} [category_theory.category C] (B : C) (objs : J ‚Üí C) (arrows : Œ† (j : J), objs j ‚ü∂ B) : category_theory.limits.wide_pullback_shape J ‚•§ C
{ùïú : Type u_1} [linear_ordered_field ùïú] {s : set ùïú} {f : ùïú ‚Üí ùïú} (hs : convex ùïú s) (hf : ‚àÄ {x y z : ùïú}, x ‚àà s ‚Üí z ‚àà s ‚Üí x < y ‚Üí y < z ‚Üí (f z - f y) / (z - y) ‚â§ (f y - f x) / (y - x)) : concave_on ùïú s f
 : lean.parser (name √ó option name)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ D} (H : D ‚•§ C) [category_theory.is_equivalence H] (c : category_theory.limits.cocone F) : H.map_cocone_inv (H.map_cocone c) ‚âÖ c
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Group) : category_theory.limits.cone F
{R : Type u} {n : Type w} [comm_ring R] [decidable_eq n] [fintype n] (J : matrix n n R) {m : Type w} [decidable_eq m] [fintype m] (e : matrix n n R ‚âÉ‚Çê[R] matrix m m R) (h : ‚àÄ (A : matrix n n R), (‚áëe A).transpose = ‚áëe A.transpose) : ‚Ü•(skew_adjoint_matrices_lie_subalgebra J) ‚âÉ‚Çó‚ÅÖR‚ÅÜ ‚Ü•(skew_adjoint_matrices_lie_subalgebra (‚áëe J))
{Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] {s : set Œ±} (hs : measurable_set s) (a : Œ±) : (nhds_within a s).is_measurably_generated
{G : Type u_10} [add_group G] (a : G) : ‚áë(equiv.symm (equiv.add_left a)) = has_add.add (-a)
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] {c : category_theory.limits.cone (category_theory.limits.parallel_family f)} (i : category_theory.limits.is_limit c) : category_theory.mono (category_theory.limits.trident.Œπ c)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} {Œ¥ : Type w} (f : Œ¥ ‚Üí Œ† (a : Œ±), Œ≤ a ‚Üí Œ¥) (H : ‚àÄ (d : Œ¥) (a‚ÇÅ : Œ±) (b‚ÇÅ : Œ≤ a‚ÇÅ) (a‚ÇÇ : Œ±) (b‚ÇÇ : Œ≤ a‚ÇÇ), f (f d a‚ÇÅ b‚ÇÅ) a‚ÇÇ b‚ÇÇ = f (f d a‚ÇÇ b‚ÇÇ) a‚ÇÅ b‚ÇÅ) (d : Œ¥) (m : finmap Œ≤) : Œ¥
(R : Type u) [semiring R] {Œπ : Type v} [dec_Œπ : decidable_eq Œπ] {M : Œπ ‚Üí Type w} [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] (i : Œπ) (c : R) (x : M i) : ‚áë(direct_sum.of M i) (c ‚Ä¢ x) = c ‚Ä¢ ‚áë(direct_sum.of M i) x
{M : Type u_7} {M‚ÇÇ : Type u_9} [add_comm_group M] [add_comm_group M‚ÇÇ] (e : M ‚âÉ+ M‚ÇÇ) : M ‚âÉ‚Çó[‚Ñ§] M‚ÇÇ
(Œ± : Type u) [reflected Œ±] : expr ‚Üí tactic Œ±
(R : Type u_1) [has_mul R] [has_add R] : Type
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.full F] [category_theory.faithful F] {X Y : C} (f : X ‚ü∂ Y) [category_theory.is_iso (F.map f)] : category_theory.is_iso f
(B : Type u) [quiver B] : category_theory.pseudofunctor (category_theory.locally_discrete (category_theory.paths B)) (category_theory.free_bicategory B)
(e s s' : expr) : expr
(A B : CommRing) : category_theory.limits.is_limit (A.prod_fan B)
{E : Type u} [normed_group E] [normed_space ‚Ñù E] [complete_space E] (f f' : ‚Ñù ‚Üí E) {a b : ‚Ñù} {s : set ‚Ñù} (hs : s.countable) (Hc : continuous_on f (set.interval a b)) (Hd : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo (linear_order.min a b) (linear_order.max a b)  s ‚Üí has_deriv_at f (f' x) x) (Hi : interval_integrable f' measure_theory.measure_space.volume a b) : ‚à´ (x : ‚Ñù) in a..b, f' x = f b - f a
{Œ± : Type u_1} (l : list Œ±) (c : composition l.length) : (l.split_wrt_composition c).join = l
{A : Type u_4} {B : Type u_5} [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] (f : A ‚Üí+ B) (hf : continuous ‚áëf) : continuous_add_monoid_hom A B
{R : Type u} [ring R] {Œì‚ÇÄ : Type v} [linear_ordered_comm_group_with_zero Œì‚ÇÄ] (v : valuation R Œì‚ÇÄ) : valued R Œì‚ÇÄ
(R : Type u) {S : Type v} {A : Type w} {B : Type u‚ÇÅ} [comm_semiring R] [comm_semiring S] [semiring A] [semiring B] [algebra R S] [algebra S A] [algebra S B] [algebra R A] [algebra R B] [is_scalar_tower R S A] [is_scalar_tower R S B] (f : A ‚âÉ‚Çê[S] B) : A ‚âÉ‚Çê[R] B
{R : Type u} [ring R] {J : Type v} [category_theory.small_category J] (F : J ‚•§ Module R) : category_theory.limits.cone F
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_ordered_ring Œ±] [floor_ring Œ±] [topological_space Œ±] [order_topology Œ±] [topological_add_group Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (h : continuous_on f (set.Icc 0 1)) (hf : f 0 = f 1) : continuous (f ‚àò int.fract)
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : differentiable_on ‚Ñù f (interior D)) (hf'' : ‚àÄ (x : ‚Ñù), x ‚àà interior D ‚Üí 0 < deriv^[2] f x) : strict_convex_on ‚Ñù D f
(G : Type u_1) [add_monoid G] : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : Top} (f : X ‚ü∂ Y) (‚Ñ± : Top.presheaf C Y) : Top.presheaf C X
{Œ± : Type u_1} [preorder Œ±] [pred_order Œ±] {a b : Œ±} [no_min_order Œ±] : order.pred a < order.pred b ‚Üí a < b
{Œ± : Type u_1} [cancel_monoid_with_zero Œ±] {a b c : Œ±} (ha : a ‚â† 0) : a * b ‚à£ a * c ‚Üî b ‚à£ c
(cs : list char) : parser char
{Œ± : Type u_2} [semigroup Œ±] : semigroup (filter Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] (J : category_theory.grothendieck_topology C) (P : C·µí·µñ ‚•§ A) : Prop
{K : Type u_1} {S : Type u_2} {T : Type u_3} [field K] [comm_ring S] [comm_ring T] [algebra K S] [algebra K T] [algebra S T] [is_scalar_tower K S T] (hST : function.injective ‚áë(algebra_map S T)) {x : S} {y : T} (hx : is_integral K x) (h : y = ‚áë(algebra_map S T) x) : minpoly K x = minpoly K y
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [left_cancel_semigroup M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) : left_cancel_semigroup M‚ÇÅ
{C : Type u} [category_theory.category C] (F : category_theory.discrete category_theory.limits.walking_pair ‚•§ C) : F ‚âÖ category_theory.limits.pair (F.obj {as := category_theory.limits.walking_pair.left}) (F.obj {as := category_theory.limits.walking_pair.right})
(M : Type u_1) (N : Type u_2) (Œ± : Type u_3) [has_vadd M Œ±] [has_vadd N Œ±] [vadd_comm_class M N Œ±] : vadd_comm_class N M Œ±
{C : Type u} [category_theory.category C] [category_theory.enough_projectives C] (X : C) : C
{R : Type u_1} {M : Type u_3} {M' : Type u_4} [has_zero R] [has_zero M] [smul_with_zero R M] [has_zero M'] [has_scalar R M'] (f : zero_hom M' M) (hf : function.injective ‚áëf) (smul : ‚àÄ (a : R) (b : M'), ‚áëf (a ‚Ä¢ b) = a ‚Ä¢ ‚áëf b) : smul_with_zero R M'
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_pullbacks C] (f : X ‚ü∂ Y) : category_theory.subobject Y ‚•§ category_theory.subobject X
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [Œ† (i : Œπ), add_zero_class (Œ≤ i)] (i : Œπ) : (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚Üí+ Œ≤ i
{Œì : Type u_1} [inhabited Œì] {n : ‚Ñï} {enc : Œì ‚Üí vector bool n} (enc0 : enc inhabited.default = vector.repeat bool.ff n) (L R : turing.list_blank Œì) : turing.tape bool
(C : Type u‚ÇÅ) [category_theory.category C] [‚àÄ (X Y : C), subsingleton (X ‚ü∂ Y)] : category_theory.thin_skeleton C ‚•§ C
{Œ± : Type u} : ordnode Œ± ‚Üí ‚Ñï
 : has_mul pgame
(Œ± : Type u_2) (Œ≤ : Type u_3) (r : Œ± ‚Üí Œ≤ ‚Üí Prop) : Type (max u_2 u_3)
{Œ± : Type u} [cancel_monoid_with_zero Œ±] [nontrivial Œ±] : has_faithful_smul Œ± Œ±
{Œ± : Type u} [has_le Œ±] (x : Œ±) : ordnode Œ± ‚Üí Prop
{Œì : Type u_1} [inhabited Œì] (T : turing.tape Œì) : turing.list_blank Œì
(obj : Type u) : Type (max u (v+1))
(n : name) : tactic string
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : Œ± ‚âÉ‚Çú Œ≤) {b : Œ≤} {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} {C : ‚Ñù} : asymptotics.is_O_with C (nhds b) f g ‚Üî asymptotics.is_O_with C (nhds (‚áë(e.symm) b)) (f ‚àò ‚áëe) (g ‚àò ‚áëe)
(Œ± : Type u) : Type u
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} [is_well_order Œ≤ s] (f : initial_seg r s) (g : initial_seg s r) : r ‚âÉr s
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) : add_hom (with_top M) (with_top N)
(F : Type u_1) (E : Type u_2) [field F] [field E] [algebra F E] [finite_dimensional F E] [is_separable F E] : ‚àÉ (Œ± : E), F‚üÆŒ±‚üØ = ‚ä§
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D) [category_theory.limits.preserves_colimits F] : category_theory.limits.preserves_limits F.right_op
{Œì‚ÇÄ : Type u_1} [linear_ordered_comm_group_with_zero Œì‚ÇÄ] (Œ≥ : Œì‚ÇÄÀ£) : nhds ‚ÜëŒ≥ = has_pure.pure ‚ÜëŒ≥
{Œ± : Type u_1} {p : Œ± ‚Üí Prop} (s : finset {x // p x}) {a : Œ±} (h : a ‚àà finset.map (function.embedding.subtype (Œª (x : Œ±), p x)) s) : p a
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (h_obj : ‚àÄ (X : C), F.obj X = G.obj X) (h_map : ‚àÄ (X Y : C) (f : X ‚ü∂ Y), F.map f = category_theory.eq_to_hom _ ‚â´ G.map f ‚â´ category_theory.eq_to_hom _) : F = G
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] {C : Type u‚ÇÑ} [category_theory.category C] (L : A ‚•§ T) (R : B ‚•§ T) (F : T ‚•§ C) : category_theory.comma L R ‚•§ category_theory.comma (L ‚ãô F) (R ‚ãô F)
{R : Type u_1} {S : Type u_6} [semiring R] [semiring S] (f : R ‚âÉ+* S) : R ‚âÉ‚Çõ‚Çó[‚Üëf] S
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} (x : category_theory.presieve.family_of_elements P R) : Prop
{R : Type u_3} [comm_semiring R] {M‚Çó : Type u_11} {N‚Çó : Type u_12} {P‚Çó : Type u_13} {Q‚Çó : Type u_14} {Q‚Çó' : Type u_15} [add_comm_monoid M‚Çó] [add_comm_monoid N‚Çó] [add_comm_monoid P‚Çó] [add_comm_monoid Q‚Çó] [add_comm_monoid Q‚Çó'] [module R M‚Çó] [module R N‚Çó] [module R P‚Çó] [module R Q‚Çó] [module R Q‚Çó'] (f : M‚Çó ‚Üí‚Çó[R] N‚Çó ‚Üí‚Çó[R] P‚Çó) (g : Q‚Çó ‚Üí‚Çó[R] M‚Çó) (g' : Q‚Çó' ‚Üí‚Çó[R] N‚Çó) : Q‚Çó ‚Üí‚Çó[R] Q‚Çó' ‚Üí‚Çó[R] P‚Çó
{Œ± : Type u_2} [decidable_eq Œ±] [comm_semigroup Œ±] : comm_semigroup (finset Œ±)
(Œ± : Type u_1) [complete_lattice Œ±] : CompleteLattice
{M : Type u_1} [monoid M] (S : submonoid M) : ‚Ü•(S.left_inv) ‚Üí ‚Ü•S
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {s : set Œ±} {t : set Œ≤} {f : Œ± ‚Üí Œ≤} (h : set.maps_to f s t) (hc : continuous f) : set.maps_to f (closure s) (closure t)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ±) (a : Œ±) (l : list Œ≤) : Œ±
{Œπ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (c : complex_shape Œπ) (i : Œπ) : homological_complex.forget V c ‚ãô category_theory.graded_object.eval i ‚âÖ homological_complex.eval V c i
(ùïú : Type u_1) {E : Type u_2} [normed_field ùïú] [normed_space ‚Ñù ùïú] [semi_normed_group E] [normed_space ùïú E] [module ‚Ñù E] [is_scalar_tower ‚Ñù ùïú E] : locally_convex_space ‚Ñù E
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) (j : J) (x : ‚Ü•(F.obj j)) : CommRing.colimits.colimit_type F
{M : Type u_1} {R : Type u_2} [monoid M] [ring R] [mul_semiring_action M R] : mul_action M (subring R)
{G : Type u_1} [add_group G] {S : Type u_4} (H : S) [set_like S G] [hSG : add_subgroup_class S G] : ‚Ü•H ‚Üí+ G
{Œ± : Type u} [pseudo_metric_space Œ±] [proper_space Œ±] {x : Œ±} {r : ‚Ñù} {s : set Œ±} (hs : is_closed s) (h : s ‚äÜ metric.ball x r) : ‚àÉ (r' : ‚Ñù) (H : r' < r), s ‚äÜ metric.ball x r'
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {f‚ÇÄ f‚ÇÅ : C(X, Y)} (F : f‚ÇÄ.homotopy f‚ÇÅ) : continuous ‚áëF
{Œ± : Type u} [topological_space Œ±] {Œπ : Type u_1} [nonempty Œπ] {V : Œπ ‚Üí set Œ±} (hV : directed superset V) (hV_cpct : ‚àÄ (i : Œπ), is_compact (V i)) (hV_closed : ‚àÄ (i : Œπ), is_closed (V i)) {U : set Œ±} (hU : ‚àÄ (x : Œ±), (x ‚àà ‚ãÇ (i : Œπ), V i) ‚Üí U ‚àà nhds x) : ‚àÉ (i : Œπ), V i ‚äÜ U
{Œ± : Type u} {Œ≤ : Sort u_1} (z : Œ≤) (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≤) : ordnode Œ± ‚Üí Œ≤
(X : Type u_2) [topological_space X] [regular_space X] [topological_space.second_countable_topology X] : topological_space.metrizable_space X
{Œ± : Type u} {C : with_bot Œ± ‚Üí Sort u_1} (h‚ÇÅ : C ‚ä•) (h‚ÇÇ : Œ† (a : Œ±), C ‚Üëa) (n : with_bot Œ±) : C n
(Œ± : Type u_3) [has_inf Œ±] [has_top Œ±] : inf_top_hom Œ± Œ±
{R : Type u_1} (f : ‚Ñï ‚Üí R) : power_series R
{Œ± : typevec 0} {Œ≤ : typevec 0} : Œ±.arrow Œ≤
{Œ± : Type u} (a : Œ±) : seq1 Œ±
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x y : R) : v.int_valuation_def (x + y) ‚â§ linear_order.max (v.int_valuation_def x) (v.int_valuation_def y)
 : Type
(is_manual : bool) : tactic unit
(e : expr) : tactic unit
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí ordnode Œ± √ó option Œ± √ó ordnode Œ±
(R : Type u) [ring R] : Type u ‚•§ Module R
(P‚ÇÇ P‚ÇÅ : pfunctor) {Œ± : Type} (x : (P‚ÇÇ.comp P‚ÇÅ).obj Œ±) : P‚ÇÇ.obj (P‚ÇÅ.obj Œ±)
{M : Type u_1} [has_mul M] {S T : subsemigroup M} (h : ‚àÄ (x : M), x ‚àà S ‚Üî x ‚àà T) : S = T
{Œ± : Type u} [t : topological_space Œ±] [topological_space.separable_space Œ±] {Œπ : Type u_1} {s : Œπ ‚Üí set Œ±} {a : set Œπ} (h : a.pairwise_disjoint s) (ha : ‚àÄ (i : Œπ), i ‚àà a ‚Üí is_open (s i)) (h'a : ‚àÄ (i : Œπ), i ‚àà a ‚Üí (s i).nonempty) : a.countable
{Œ± : Type u_1} {Œ≤ : Type u_2} (rŒ± : Œ± ‚Üí Œ± ‚Üí Prop) (rŒ≤ : Œ≤ ‚Üí Œ≤ ‚Üí Prop) : Œ± √ó Œ≤ ‚Üí Œ± √ó Œ≤ ‚Üí Prop
{C : Type u‚ÇÅ} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.limits.has_pullback f g] : category_theory.is_pullback category_theory.limits.pullback.fst category_theory.limits.pullback.snd f g
(hyps : list linarith.comp) (max_var : ‚Ñï) : linarith.linarith_structure
{d : ‚Ñ§} : has_one (‚Ñ§‚àöd)
(e : expr) : tactic expr
{C : Type u‚ÇÅ} [category_theory.category C] (T : category_theory.monad C) : ‚ÜëT ‚ãô ‚ÜëT ‚ü∂ ‚ÜëT
{Œ± : Type u} {Œ≤ : Type v} {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} [partial_order Œ≤] [preorder Œ±] [bounded_order Œ±] (gi : galois_insertion l u) : bounded_order Œ≤
{Œì : Type u_1} [inhabited Œì] : list Œì ‚Üí turing.list_blank Œì
{m : Type u ‚Üí Type u} [monad m] {Œ± : Type u} : list Œ± ‚Üí tactic.mllist m Œ±
(Œ± : Type u_1) : Type u_1
{Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x y : Œ±} {m n : ‚Ñï} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) : x = y
{Œ± Œ≤ : Type u} {m : Type u ‚Üí Type u} [monad m] [alternative m] (f : Œ± ‚Üí m (Œ± √ó list Œ≤)) : Œ± ‚Üí list Œ≤ ‚Üí tactic.mllist m Œ≤
{Œ± : Type u_1} [comm_monoid Œ±] (a b u : Œ±) (hu : is_unit u) : a ‚à£ u * b ‚Üî a ‚à£ b
{Œ± : Type u_1} [has_to_tactic_format Œ±] (msg : string) (a : Œ±) : tactic unit
 : expr ‚Üí tactic ‚Ñï
(x y : nonote) : nonote
(equ : name) : tactic tactic.unify_equations.unification_step_result
(R : Type u_1) [comm_ring R] (C : Type u) [category_theory.category C] : C ‚•§ category_theory.Free R C
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {R‚ÇÇ : Type u_5} [comm_semiring R‚ÇÇ] [algebra R‚ÇÇ R] [module R‚ÇÇ M] [is_scalar_tower R‚ÇÇ R M] (A : bilin_form R M) : M ‚Üí‚Çó[R‚ÇÇ] M ‚Üí‚Çó[R] R
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_equalizer f g] : category_theory.subobject X
{X : Top} (F : Top.presheaf (Type v) X) : Top.prelocal_predicate (Œª (x : ‚Ü•X), F.stalk x)
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.pos_mul_mono Œ±] (ha : 1 ‚â§ a) (hb : 1 ‚â§ b) (a0 : 0 < a) : 1 ‚â§ a * b
{K : Type u_1} {v : K} {n : ‚Ñï} [linear_ordered_field K] [floor_ring K] {ifp_n ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : ‚Üë(ifp_succ_n.b) ‚â§ (ifp_n.fr)‚Åª¬π
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (l : list (Œ£ (a : Œ±), Œ≤ a)) (m : hash_map Œ± Œ≤) : hash_map Œ± Œ≤
(n : ‚Ñï) : pos_num
{M : Type u_1} [has_add M] {Œ≤ : Sort u_2} {c : add_con M} (q : c.quotient) (f : M ‚Üí Œ≤) (h : ‚àÄ (a b : M), ‚áëc a b ‚Üí f a = f b) : Œ≤
{ùïú : Type u_1} {V : Type u_2} {V‚ÇÇ : Type u_4} [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] (e : V ‚âÉ‚Çó·µ¢[ùïú] V‚ÇÇ) : V ‚âÉ·µÉ‚Å±[ùïú] V‚ÇÇ
{R : Type u} [ring R] {X‚ÇÇ : Type v} {X‚ÇÅ : Module R} {g‚ÇÇ : add_comm_group X‚ÇÇ} {m‚ÇÇ : module R X‚ÇÇ} (e : ‚Ü•X‚ÇÅ ‚âÉ‚Çó[R] X‚ÇÇ) : X‚ÇÅ ‚âÖ Module.of R X‚ÇÇ
{R : Type u_1} [comm_semiring R] (s : subsemiring R) : comm_semiring ‚Ü•s
{R : Type v} [comm_ring R] {o : Type u_1} (M : matrix o o R) {n : ‚Ñï} (b : o ‚Üí fin n) : Prop
(Œ± : Type u_1) (r s : Œ± ‚Üí Œ± ‚Üí Prop) : Type
{p : ‚Ñï} (z : ‚Ñ§) (hp : p ‚â† 1) (hz : z ‚â† 0) : padic_val_rat p ‚Üëz = ‚Üë((multiplicity ‚Üëp z).get _)
 : CommRing·µí·µñ ‚•§ Top
{Œ± : Type u_1} {Œ≤ : Type u_2} (rŒ± : Œ± ‚Üí Œ± ‚Üí Prop) (rŒ≤ : Œ≤ ‚Üí Œ≤ ‚Üí Prop) : relation.game_add rŒ± rŒ≤ ‚â§ prod.lex rŒ± rŒ≤
{Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s ‚à© t)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {H : lie_subalgebra R L} [lie_algebra.is_nilpotent R ‚Ü•H] (M : Type w) [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (œá : ‚Ü•H ‚Üí R) : lie_submodule R ‚Ü•(lie_algebra.zero_root_subalgebra R L H) M
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {t‚ÇÅ t‚ÇÇ : affine.triangle ‚Ñù P} (h : set.range t‚ÇÅ.points = set.range t‚ÇÇ.points) : t‚ÇÅ.orthocenter = t‚ÇÇ.orthocenter
(s : string) : lean.parser unit
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {b‚ÇÇ : basis (fin 2) ‚Ñù V} (hb‚ÇÇ : orthonormal ‚Ñù ‚áëb‚ÇÇ) (ho : b.orientation = b‚ÇÇ.orientation) (x y : V) : hb.oangle x y = hb‚ÇÇ.oangle x y
(Œ± : Type u_2) [fintype Œ±] [linear_order Œ±] [bounded_order Œ±] : complete_linear_order Œ±
{H : Type u} [topological_space H] {Œ± : Type u_5} [topological_space Œ±] [nonempty Œ±] {f : Œ± ‚Üí H} (h : open_embedding f) : charted_space H Œ±
(X : Type u) : Type u
{R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] {n : ‚Ñï} (n0 : 0 < n) : is_smul_regular M (a ^ n) ‚Üî is_smul_regular M a
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (A : matrix n n R) (h : invertible A.det) : GL n R
{R : Type u} {S : Type v} [ring R] [ring S] (f : R ‚Üí+* S) : subring S
{Œ± : Type u_1} (s t : set Œ±) (h : s ‚äÜ t) : ‚Ü•s ‚Ü™ ‚Ü•t
{Œ± : Sort u} {Œ≤ : Sort v} [subsingleton Œ±] [subsingleton Œ≤] (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) : Œ± ‚âÉ Œ≤
{Œ± : Type u_1} [pseudo_metric_space Œ±] (r C : ‚Ñù) (hr : r < 1) {f : ‚Ñï ‚Üí Œ±} (hu : ‚àÄ (n : ‚Ñï), has_dist.dist (f n) (f (n + 1)) ‚â§ C * r ^ n) {a : Œ±} (ha : filter.tendsto f filter.at_top (nhds a)) (n : ‚Ñï) : has_dist.dist (f n) a ‚â§ C * r ^ n / (1 - r)
(prove_ne_zero : tactic.instance_cache ‚Üí expr ‚Üí ‚Ñö ‚Üí tactic (tactic.instance_cache √ó expr)) (c : tactic.instance_cache) (a d : expr) (na : ‚Ñö) (nd : ‚Ñï) : tactic (tactic.instance_cache √ó expr √ó expr)
{X : Type u_1} (to_two_pointing : two_pointing X) : Twop
(term : expr) (lem : name) (args : list expr) (hs : list tactic.ring_exp.ex_info) : tactic.ring_exp.ring_exp_m expr
{M : Type u_6} {N : Type u_7} {P : Type u_8} [has_mul M] [has_mul N] [has_mul P] (h1 : M ‚âÉ* N) (h2 : N ‚âÉ* P) : M ‚âÉ* P
(Œ± : Type u) (Œ≤ : Œ± ‚Üí Prop) [slim_check.sampleable_ext Œ±] [Œ† (x : Œ±), slim_check.testable (Œ≤ x)] (cfg : slim_check.slim_check_cfg) (var : string) (x : slim_check.sampleable_ext.proxy_repr Œ±) (r : slim_check.test_result (Œ≤ (slim_check.sampleable_ext.interp Œ± x))) : slim_check.gen (Œ£ (x : slim_check.sampleable_ext.proxy_repr Œ±), slim_check.test_result (Œ≤ (slim_check.sampleable_ext.interp Œ± x)))
{R : Type u_1} [comm_ring R] (f : polynomial R) (r : R) : (‚áë(polynomial.taylor r) f).sum (Œª (i : ‚Ñï) (a : R), ‚áëpolynomial.C a * (polynomial.X - ‚áëpolynomial.C r) ^ i) = f
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.limits.reflects_limits_of_shape J F] : category_theory.limits.reflects_limits_of_shape J G
(tk : string) : lean.parser unit
{J : Type u_1} {C : Type u_2} [category_theory.category J] [category_theory.category C] {P Q : category_theory.idempotents.karoubi (J ‚•§ C)} (f : P ‚ü∂ Q) : category_theory.idempotents.karoubi_functor_category_embedding.obj P ‚ü∂ category_theory.idempotents.karoubi_functor_category_embedding.obj Q
(X : Compactum) : ultrafilter ‚Ü•X ‚Üí ‚Ü•X
{L : first_order.language} {Œ± : Type u'} {Œ≤ : Type v'} [decidable_eq Œ±] (t : L.term Œ±) (f : ‚Ü•(t.var_finset) ‚Üí Œ≤) : L.term Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {F : C ‚•§ D} [category_theory.creates_limit K F] {c : category_theory.limits.cone (K ‚ãô F)} (t : category_theory.limits.is_limit c) : category_theory.limits.cone K
{Œ± : Type u_1} {Œ≤ : Type u_2} [semilattice_inf Œ±] (s : finset Œ≤) (H : s.nonempty) (f : Œ≤ ‚Üí Œ±) : Œ±
{V : Type u} [quiver V] [quiver.has_reverse V] {a b : V} : quiver.path a b ‚Üí quiver.path b a
(h : expr) (ns : name_set) : tactic bool
{Œ± : Type u_1} {Œπ' : Sort u_5} [complete_lattice Œ±] (s : Œπ' ‚Üí Œ±) : (‚®Ü (i : Œπ'), s i) = ‚®Ü (t : finset (plift Œπ')) (i : plift Œπ') (H : i ‚àà t), s i.down
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] (L : A ‚•§ T) (R : B ‚•§ T) : category_theory.comma L R ‚•§ A
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {y : Œ± ‚Üí Œ±} {s : set Œ±} (h : s.pairwise_disjoint (Œª (x : Œ±), set.Ioo x (y x))) (h' : ‚àÄ (x : Œ±), x ‚àà s ‚Üí x < y x) : s.countable
 : has_one onote
(l : list pexpr) : tactic unit
{Œ± : Type u_1} {n : ‚Ñï} : has_lift (vector Œ± n) (sym Œ± n)
(V : Type u) [quiver V] : Sort (max (u+1) v)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (P : category_theory.subobject Y) (f : X ‚ü∂ Y) (h : P.factors f) : X ‚ü∂ ‚ÜëP
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.preadditive C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} {P : category_theory.ProjectiveResolution Y} {Q : category_theory.ProjectiveResolution Z} (f : P.complex ‚ü∂ Q.complex) (comm : f ‚â´ Q.œÄ = 0) : P.complex.X 1 ‚ü∂ Q.complex.X 2
 : free_group empty ‚âÉ unit
{M : Type u} [has_add M] (a x y : M) : Prop
(Œ± : Type u) : category_theory.sieve Œ±
 : tactic.instance_cache ‚Üí expr ‚Üí expr ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí tactic (tactic.instance_cache √ó expr √ó expr)
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_group Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} : strict_concave_on ùïú s f ‚Üí strict_convex_on ùïú s (-f)
{Œπ : Type u} (Œ≤ : Œπ ‚Üí Type v) [dec : decidable_eq Œπ] [Œ† (i : Œπ), add_zero_class (Œ≤ i)] (i : Œπ) : Œ≤ i ‚Üí+ Œ†‚ÇÄ (i : Œπ), Œ≤ i
{n : ‚Ñï} (c : composition n) : fin c.length ‚Üí ‚Ñï
{X : Type u} {Y : Type v} [metric_space X] [metric_space Y] : isometry sum.inr
{G : Type u‚ÇÇ} (k : Type u_1) [semiring k] {H : Type u_2} {F : Type u_3} [add_monoid G] [add_monoid H] [add_monoid_hom_class F G H] (f : F) : add_monoid_algebra k G ‚Üí+* add_monoid_algebra k H
{Œ± : Type u_1} {Œ≤ : Type u_2} [preorder Œ≤] [decidable_rel has_lt.lt] (f : Œ± ‚Üí Œ≤) (l : list Œ±) : option Œ±
{G : Type u} [group G] : G ‚ß∏ ‚ä• ‚âÉ* G
{G : Type u_1} [group G] (H K : set G) : setoid G
(o : ordinal) : Prop
{M : Type u} [add_zero_class M] (a : M) : add_semiconj_by a 0 0
{Œ± : Type u} (P : Œ± ‚Üí Prop) [decidable_pred P] : list Œ± ‚Üí list Œ± ‚Üí list (list Œ±)
{R : Type u_1} {B : Type u_3} [nondiscrete_normed_field R] [topological_space B] {F‚ÇÅ : Type u_6} [normed_group F‚ÇÅ] [normed_space R F‚ÇÅ] {E‚ÇÅ : B ‚Üí Type u_7} [topological_space (bundle.total_space E‚ÇÅ)] [Œ† (x : B), add_comm_monoid (E‚ÇÅ x)] [Œ† (x : B), module R (E‚ÇÅ x)] {F‚ÇÇ : Type u_8} [normed_group F‚ÇÇ] [normed_space R F‚ÇÇ] {E‚ÇÇ : B ‚Üí Type u_9} [topological_space (bundle.total_space E‚ÇÇ)] [Œ† (x : B), add_comm_monoid (E‚ÇÇ x)] [Œ† (x : B), module R (E‚ÇÇ x)] (e‚ÇÅ : topological_vector_bundle.trivialization R F‚ÇÅ E‚ÇÅ) (e‚ÇÇ : topological_vector_bundle.trivialization R F‚ÇÇ E‚ÇÇ) : bundle.total_space (Œª (x : B), E‚ÇÅ x √ó E‚ÇÇ x) ‚Üí B √ó F‚ÇÅ √ó F‚ÇÇ
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [non_assoc_semiring Œ≤] : non_assoc_semiring Œ±
{Œ± : Type u} (f : Œ± ‚Üí Œ±) : set Œ±
(n : ‚Ñï+) {p : ‚Ñï+ ‚Üí Sort u_1} (p1 : p 1) (hp : Œ† (n : ‚Ñï+), p n ‚Üí p (n + 1)) : p n
{X : Type u} [lattice X] [jordan_holder_lattice X] {s‚ÇÅ s‚ÇÇ : composition_series X} (hl : s‚ÇÅ.length = s‚ÇÇ.length) (h : ‚àÄ (i : fin (s‚ÇÅ.length + 1)), ‚áës‚ÇÅ i = ‚áës‚ÇÇ (‚áë(fin.cast _) i)) : s‚ÇÅ = s‚ÇÇ
(Œ± : Sort u) : Sort u
(ùïú : Type u_1) {V : Type u_2} (P : Type u_8) [normed_field ùïú] [semi_normed_group V] [normed_space ùïú V] [pseudo_metric_space P] [normed_add_torsor V P] : P ‚âÉ·µÉ‚Å±[ùïú] P
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] {F : C ‚•§ D} {G : D ‚•§ E} {H : C ‚•§ E} [‚Ñã : category_theory.faithful H] (h : F ‚ãô G ‚âÖ H) : category_theory.faithful F
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] {u v : E} (hvm : v ‚àà K) (hvo : ‚àÄ (w : E), w ‚àà K ‚Üí has_inner.inner (u - v) w = 0) : ‚Üë(‚áë(orthogonal_projection K) u) = v
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e e' : local_homeomorph Œ± Œ≤) (h : ‚àÄ (x : Œ±), ‚áëe x = ‚áëe' x) (hinv : ‚àÄ (x : Œ≤), ‚áë(e.symm) x = ‚áë(e'.symm) x) (hs : e.to_local_equiv.source = e'.to_local_equiv.source) : e = e'
(R : Type u_1) : Type u_1
{b : Prop} (a : Prop) (h : a ‚Üî b) [D : decidable a] : decidable b
{ùïú : Type u_2} {E : Type u_5} {F : Type u_6} [topological_space ùïú] [comm_semiring ùïú] [add_comm_monoid E] [module ùïú E] [add_comm_monoid F] [module ùïú F] (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú) [has_continuous_smul ùïú ùïú] : has_continuous_smul ùïú (weak_bilin B)
(D : algebraic_geometry.Scheme.glue_data) : D.glued.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier ‚âÖ D.to_LocallyRingedSpace_glue_data.to_SheafedSpace_glue_data.to_PresheafedSpace_glue_data.to_Top_glue_data.to_glue_data.glued
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : submodule R M
{R : Type u} [ring R] {P : Type (max u v)} [add_comm_group P] [module R P] {Œπ : Type u_1} (b : basis Œπ R P) : module.projective R P
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {n : ‚Ñï} {f : ùïú ‚Üí F} : iterated_deriv (n + 1) f = iterated_deriv n (deriv f)
{R‚ÇÅ : Type u_2} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_11} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} : has_zero (M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)
(A B : finset ‚Ñï) : A.sum (Œª (i : ‚Ñï), 2 ^ i) ‚â§ B.sum (Œª (i : ‚Ñï), 2 ^ i) ‚Üî A.to_colex ‚â§ B.to_colex
 : simplex_category ‚•§ Top
(X : category_theory.limits.walking_cospan) : X ‚ü∂ X
(scope : bool ‚Üí lint_verbosity ‚Üí list name ‚Üí bool ‚Üí tactic (name_set √ó format)) : lean.parser unit
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [measurable_space Œ±] (g : Œ≤ ‚Üí Œ≥) (f : measure_theory.simple_func Œ± Œ≤) : measure_theory.simple_func Œ± Œ≥
 : category_theory.limits.preserves_limits_of_size (category_theory.forget AddGroup)
{Œ± : Type u} {a b : Œ±} [mul_zero_one_class Œ±] [partial_order Œ±] [zero_lt.pos_mul_mono Œ±] (ha : 1 ‚â§ a) (hb : 1 ‚â§ b) (a0 : 0 ‚â§ a) : 1 ‚â§ a * b
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (P : C·µí·µñ ‚•§ Type w) (R : category_theory.presieve X) : Prop
{C : Type u} [category_theory.category C] (J‚ÇÅ : category_theory.grothendieck_topology C) (X : C) : closure_operator (category_theory.sieve X)
(x : ‚Ñù) (h1 : 0 < x) (h2 : x < real.pi / 2) : x < real.tan x
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b : Œ±} (ha : 0 ‚â§ a) (hb : 0 ‚â§ b) : 0 ‚â§ a + b
{Fq : Type u_1} [fintype Fq] [field Fq] : polynomial.card_pow_degree.is_admissible
{G : Type u} [group G] [fintype G] {p n : ‚Ñï} [hp : fact (nat.prime p)] (hdvd : p ^ (n + 1) ‚à£ fintype.card G) {H : subgroup G} (hH : fintype.card ‚Ü•H = p ^ n) : ‚àÉ (K : subgroup G), fintype.card ‚Ü•K = p ^ (n + 1) ‚àß H ‚â§ K
{Œ± : Type u} {Œ≤ : Type v} [has_sup Œ±] [has_inf Œ±] [distrib_lattice Œ≤] (f : Œ± ‚Üí Œ≤) (hf_inj : function.injective f) (map_sup : ‚àÄ (a b : Œ±), f (a ‚äî b) = f a ‚äî f b) (map_inf : ‚àÄ (a b : Œ±), f (a ‚äì b) = f a ‚äì f b) : distrib_lattice Œ±
(Œ± : Type u) : Type u
{Œ± : Type u} : list Œ± ‚Üí list (list Œ±)
(M : Type u_10) (A : Type u_11) [monoid M] [monoid A] : Type (max u_10 u_11)
{Œ± : Type u_1} [preorder Œ±] [densely_ordered Œ±] {s : set Œ±} [hs : s.ord_connected] : densely_ordered ‚Ü•s
(k : Type u‚ÇÅ) (G : Type u‚ÇÇ) [semiring k] [mul_one_class G] : G ‚Üí* monoid_algebra k G
{R : Type u} [ring R] {J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Module R) (t : category_theory.limits.cocone F) : Module.filtered_colimits.colimit F ‚ü∂ t.X
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] {X Y : C} [category_theory.limits.preserves_limit (category_theory.limits.pair X Y) F] : category_theory.limits.preserves_binary_biproduct X Y F
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {G : D ‚•§ C} [category_theory.is_right_adjoint G] (A : (category_theory.adjunction.of_right_adjoint G).to_monad.algebra) [category_theory.limits.has_coequalizer ((category_theory.left_adjoint G).map A.a) ((category_theory.adjunction.of_right_adjoint G).counit.app ((category_theory.left_adjoint G).obj A.A))] [category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair ((category_theory.left_adjoint G).map A.a) ((category_theory.adjunction.of_right_adjoint G).counit.app ((category_theory.left_adjoint G).obj A.A))) G] : category_theory.limits.is_colimit (category_theory.monad.monadicity_internal.unit_cofork A)
 : category_theory.limits.walking_span
{R : Type u_1} [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {A : Type u_3} [semiring A] [algebra R A] {f g : tensor_algebra R M ‚Üí‚Çê[R] A} (w : f.to_linear_map.comp (tensor_algebra.Œπ R) = g.to_linear_map.comp (tensor_algebra.Œπ R)) : f = g
{Œ± : Type u_2} {Œ≤ : Type u_3} [linear_ordered_field Œ±] [archimedean Œ±] [linear_ordered_field Œ≤] : subsingleton (Œ± ‚âÉ+*o Œ≤)
{R : Type u_1} [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (T : Type u_4) [comm_ring T] [algebra R T] (M N : submonoid R) (h : M ‚â§ N) [is_localization M S] [is_localization N T] [algebra S T] [is_scalar_tower R S T] : is_localization (submonoid.map (algebra_map R S).to_monoid_hom N) T
(cl : tactic.closure) : tactic format
(s x : ‚Ñù) : ‚Ñù
{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] (C r : nnreal) (f : X ‚Üí Y) : Prop
{Œ± : Type} (tac : tactic Œ±) : tactic Œ±
{Œ± : Type u_1} {Œπ : Type u_2} [encodable Œπ] [t : topological_space Œ±] [p : polish_space Œ±] (m : Œπ ‚Üí topological_space Œ±) (hm : ‚àÄ (n : Œπ), m n ‚â§ t) (h'm : ‚àÄ (n : Œπ), polish_space Œ±) : ‚àÉ (t' : topological_space Œ±), (‚àÄ (n : Œπ), t' ‚â§ m n) ‚àß t' ‚â§ t ‚àß polish_space Œ±
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M ‚Üí* P} (hg : ‚àÄ (y : ‚Ü•S), is_unit (‚áëg ‚Üëy)) (z : N) : ‚áëg ‚Üë((f.sec z).snd) * ‚áë(f.lift hg) z = ‚áëg (f.sec z).fst
{M : Type u_1} [has_mul M] (r : M ‚Üí M ‚Üí Prop) : con_gen r = has_Inf.Inf {s : con M | ‚àÄ (x y : M), r x y ‚Üí ‚áës x y}
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [module ùïú E] [module ùïú Œ≤] (f : E ‚Üí‚Çó[ùïú] Œ≤) {s : set E} (hs : convex ùïú s) : concave_on ùïú s ‚áëf
{Œ± : Type u_1} [measurable_space Œ±] (a : Œ±) : ‚Ü•{a} ‚âÉ·µê unit
{R‚ÇÅ : Type u_1} [semiring R‚ÇÅ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] [topological_space R‚ÇÅ] {f g : R‚ÇÅ ‚âÉL[R‚ÇÅ] M‚ÇÅ} (h : ‚áëf 1 = ‚áëg 1) : f = g
{E : Type u} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {a : E} {f' : E ‚ÜíL[‚Ñù] ‚Ñù} (h : is_local_extr f a) : has_fderiv_at f f' a ‚Üí f' = 0
{X : algebraic_geometry.Scheme} (U : topological_space.opens ‚Ü•(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)) : Prop
{M : Type u_3} {N : Type u_4} [has_mul M] [has_mul N] {f g : M ‚Üí‚Çô* N} (h : f = g) (x : M) : ‚áëf x = ‚áëg x
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (A : bilin_form R M) (x : M) : M ‚Üí‚Çó[R] R
(X : algebraic_geometry.RingedSpace) {U : topological_space.opens ‚Ü•X} (f : ‚Ü•(X.to_PresheafedSpace.presheaf.obj (opposite.op U))) : is_unit (‚áë(X.to_PresheafedSpace.presheaf.map (category_theory.hom_of_le _).op) f)
{Œπ : Sort u_1} [nonempty Œπ] {f : Œπ ‚Üí ennreal} {x : ennreal} (h : x ‚â† ‚ä§) : infi f * x = ‚®Ö (i : Œπ), f i * x
 : list expr ‚Üí expr ‚Üí expr
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {E' : Type u_7} [inner_product_space ùïú E'] {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (f : E ‚âÉ‚Çó·µ¢[ùïú] E') : orthonormal ùïú (‚áëf ‚àò v)
{Œ± : Type u_1} [pseudo_emetric_space Œ±] : paracompact_space Œ±
{a b : cardinal} : cardinal.aleph_0 ‚â§ a * b ‚Üî a ‚â† 0 ‚àß cardinal.aleph_0 ‚â§ b ‚à® cardinal.aleph_0 ‚â§ a ‚àß b ‚â† 0
{M : Type u_1} [mul_one_class M] (S : submonoid M) : 1 ‚àà S
{R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Œπ : Type w} [fintype Œπ] (h : basis Œπ R M) : module.rank R M = ‚Üë(fintype.card Œπ)
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : r ‚âÉr s) : s ‚âÉr r
{M : Type u_5} {N : Type u_6} {M' : Type u_8} {N' : Type u_9} [has_mul M] [has_mul N] [has_mul M'] [has_mul N'] (f : M ‚Üí‚Çô* M') (g : N ‚Üí‚Çô* N') : M √ó N ‚Üí‚Çô* M' √ó N'
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) (s : set M) (hs : s = ‚ÜëS) : add_submonoid M
{Œ± : Type u_1} [comm_semiring Œ±] (t : tree Œ±) (r‚ÇÅ r‚ÇÇ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr r‚ÇÅ = tactic.ring2.horner_expr.of_csexpr r‚ÇÇ) : tactic.ring2.csring_expr.eval t r‚ÇÅ = tactic.ring2.csring_expr.eval t r‚ÇÇ
(_x : interactive.parse (lean.parser.tk "#norm_num")) : lean.parser unit
{k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] {a : M} {c : k} (hc : c < 0) : 0 < a ‚Üí c ‚Ä¢ a < 0
{G : Type u_1} [group G] (H : subgroup G) : subgroup (conj_act G)
{Œ± : Type u_1} {enum : Œ± ‚Üí ‚Ñï} (n : ‚Ñï) : derive_fintype.finset_above Œ± enum n
 : vm_obj ‚Üí format
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) : hb.oangle x y + hb.oangle y x = 0
(A : Type u_2) (K : Type u_3) [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] {L : Type u_4} [field L] [algebra K L] [finite_dimensional K L] [algebra A L] [is_scalar_tower A K L] (s : finset L) : ‚àÉ (y : A) (H : y ‚â† 0), ‚àÄ (x : L), x ‚àà s ‚Üí is_integral A (y ‚Ä¢ x)
(ùïú : Type u_1) (E : Type u_2) [is_R_or_C ùïú] [inner_product_space ùïú E] : has_inner ‚Ñù E
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e e' : local_homeomorph Œ± Œ≤} (h : e ‚âà e') : set.eq_on ‚áë(e.symm) ‚áë(e'.symm) e.to_local_equiv.target
{Œ± : Type u} {Œ≤ : Type v} [has_mul Œ±] [has_mul Œ≤] (f : Œ± ‚Üí‚Çô* Œ≤) : with_one Œ± ‚Üí* with_one Œ≤
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} (f : Œ± ‚Üí Œ≤) : Œ± ‚äï Œ≥ ‚Üí Œ≤ ‚äï Œ≥
{C : Type u‚ÇÅ} [category_theory.small_category C] (A : C) : (category_theory.yoneda.obj A).elements
{Œ∑ : Type u_2} [fintype Œ∑] {Gs : Œ∑ ‚Üí Type u_3} [Œ† (i : Œ∑), group (Gs i)] [‚àÄ (i : Œ∑), group.is_nilpotent (Gs i)] : group.is_nilpotent (Œ† (i : Œ∑), Gs i)
{Œπ : Type u_1} {ùïú : Type u_3} [is_R_or_C ùïú] {E : Type u_4} [inner_product_space ùïú E] [fintype Œπ] {v : Œπ ‚Üí E} (hon : orthonormal ùïú v) (hsp : submodule.span ùïú (set.range v) = ‚ä§) : orthonormal_basis Œπ ùïú E
{Œ± : Type u} [emetric_space Œ±] [complete_space Œ±] : complete_space (topological_space.closeds Œ±)
{K : Type u_1} [field K] (A : valuation_subring K) : ‚Ü•(A.unit_group) ‚âÉ* (‚Ü•A)À£
{Œ± : Type u_1} {Œπ : Type u_2} {Œ≤ : Type u_3} (S : Œπ ‚Üí set Œ±) (f : Œ† (i : Œπ), ‚Ü•(S i) ‚Üí Œ≤) (hf : ‚àÄ (i j : Œπ) (x : Œ±) (hxi : x ‚àà S i) (hxj : x ‚àà S j), f i ‚ü®x, hxi‚ü© = f j ‚ü®x, hxj‚ü©) (hS : set.Union S = set.univ) (a : Œ±) : Œ≤
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] {F : C ‚•§ D} [F.initial] {E : Type u} [category_theory.category E] {G : D ‚•§ E} : category_theory.limits.cone (F ‚ãô G) ‚•§ category_theory.limits.cone G
{Œ± : Type u} [pseudo_metric_space Œ±] (p : Œ± ‚Üí Prop) (x : Œ±) (H : ‚àÉ·∂† (R : ‚Ñù) in filter.at_top, ‚àÄ (y : Œ±), y ‚àà metric.closed_ball x R ‚Üí p y) (y : Œ±) : p y
{V : Type u} {G : simple_graph V} (x : G.subgraph) : x.spanning_coe ‚Üíg G
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_coequalizer f g] : category_theory.limits.has_cokernel (f - g)
{x : ‚Ñù} (n : ‚Ñï) {m : ‚Ñ§} (hm : m ‚â† 0) (p : ‚Ñï) [hp : fact (nat.prime p)] (hxr : x ^ n = ‚Üëm) (hv : (multiplicity ‚Üëp m).get _ % n ‚â† 0) : irrational x
(M : Type u) : Type u
{k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] [contravariant_class M M has_add.add has_le.le] {a b : k} {c d : M} (hab : a ‚â§ b) (hcd : c ‚â§ d) : a ‚Ä¢ d + b ‚Ä¢ c ‚â§ a ‚Ä¢ c + b ‚Ä¢ d
{R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R
(G : Type u_1) [monoid G] : Prop
 : environment ‚Üí name ‚Üí option pos
{P L : Type u} [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] (h : fintype.card P = fintype.card L) : configuration.has_lines P L
{Œ± : Type u_1} {Œ≤ : Type u_2} (s : set Œ±) (t : set Œ≤) : ‚Ü•(s √óÀ¢ t) ‚âÉ ‚Ü•s √ó ‚Ü•t
(ùïú : Type u_2) [is_R_or_C ùïú] (E : Type u_3) [inner_product_space ùïú E] [cplt : complete_space E] : ‚àÉ (w : set E) (b : hilbert_basis ‚Ü•w ùïú E), ‚áëb = coe
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_comm_monoid M] : (Œ± √ó Œ≤ ‚Üí‚ÇÄ M) ‚âÉ (Œ± ‚Üí‚ÇÄ Œ≤ ‚Üí‚ÇÄ M)
(M : Type u_2) [has_mul M] : mul_aut M ‚Üí* equiv.perm M
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} {e f g : C ‚ü∂ D} (h : homotopy e f) (k : homotopy f g) : homotopy e g
{Œ± : Type u} [has_mul Œ±] : Œ± ‚Üí magma.free_semigroup Œ±
{C : Type u‚ÇÅ} [category_theory.category C] (G : category_theory.comonad C) : ‚ÜëG ‚ü∂ ùü≠ C
{V : Type u} {G : simple_graph V} {G' : G.subgraph} (v : ‚Ü•(G'.verts)) : ‚Ü•(G'.coe.neighbor_set v) ‚âÉ ‚Ü•(G'.neighbor_set ‚Üëv)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {s : set (E √ó F)} {p : E √ó F} : cont_diff_within_at ùïú n prod.snd s p
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {Œπ' : Type u_3} {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (f : Œπ' ‚Üí Œπ) (hf : function.injective f) : orthonormal ùïú (v ‚àò f)
(Œ± : Type u_1) [order.frame Œ±] : Locale
 : cc_state ‚Üí bool ‚Üí list expr
{M : Type u} [add_comm_monoid M] (n : ‚Ñï) : M ‚Üí+ M
{R : Type u_3} [comm_semiring R] {M : Type u_7} {N‚Çó : Type u_12} {P‚Çó : Type u_13} {Q‚Çó : Type u_14} [add_comm_monoid M] [add_comm_monoid N‚Çó] [add_comm_monoid P‚Çó] [add_comm_monoid Q‚Çó] [module R M] [module R N‚Çó] [module R P‚Çó] [module R Q‚Çó] (f : M ‚Üí‚Çó[R] N‚Çó ‚Üí‚Çó[R] P‚Çó) (g : P‚Çó ‚Üí‚Çó[R] Q‚Çó) : M ‚Üí‚Çó[R] N‚Çó ‚Üí‚Çó[R] Q‚Çó
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [lie_module.is_nilpotent R L M] : (‚®Ö (x : L), (‚áë(lie_module.to_endomorphism R L M) x).maximal_generalized_eigenspace 0) = ‚ä§
{R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] : tensor_algebra R M ‚Üí‚Çê[R] exterior_algebra R M
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : Type (max u v)
{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ‚â† 2) : 2 ‚â† 0
(C : Type u) [category_theory.category C] : Prop
{ùïú : Type u} {Œπ : Type v} {E : Œπ ‚Üí Type wE} {G : Type wG} [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] [normed_group G] [normed_space ùïú G] (f : continuous_multilinear_map ùïú E G) (m : Œ† (i : Œπ), E i) : ‚à•‚áëf m‚à•‚Çä ‚â§ ‚à•f‚à•‚Çä * finset.univ.prod (Œª (i : Œπ), ‚à•m i‚à•‚Çä)
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] {V‚ÇÇ : Type v'} [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] [finite_dimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ) : finite_dimensional.finrank K ‚Ü•(f.range) + finite_dimensional.finrank K ‚Ü•(f.ker) = finite_dimensional.finrank K V
{M : Type u_2} {Œ± : Sort u_4} [add_comm_monoid M] {f : Œ± ‚Üí M} (p : M ‚Üí Prop) (hp‚ÇÄ : p 0) (hp‚ÇÅ : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x + y)) (hp‚ÇÇ : ‚àÄ (i : Œ±), p (f i)) : p (finsum (Œª (i : Œ±), f i))
{Œ± : Type u_1} [topological_space Œ±] [baire_space Œ±] {f : ‚Ñï ‚Üí set Œ±} (ho : ‚àÄ (n : ‚Ñï), is_open (f n)) (hd : ‚àÄ (n : ‚Ñï), dense (f n)) : dense (‚ãÇ (n : ‚Ñï), f n)
(Œ± : Type u) : Type u
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} (a : Œ±) (b : Œ≤) (i : Œπ) : (filter.map (Œª (_x : Œ±), b) (filter.principal {a})).coprod (filter.map id (filter.principal {i})) = filter.principal ({b} √óÀ¢ set.univ ‚à™ set.univ √óÀ¢ {i})
{F : pfunctor} : pfunctor.approx.path F ‚Üí F.M ‚Üí Prop
{C : Type u‚ÇÅ} [category_theory.category C] : C ‚•§ C·µí·µñ ‚•§ Type v‚ÇÅ
{R : Type u_1} [has_zero R] (n : R) : Prop
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (Œ∏‚ÇÅ Œ∏‚ÇÇ : real.angle) : (hb.rotation Œ∏‚ÇÅ).trans (hb.rotation Œ∏‚ÇÇ) = hb.rotation (Œ∏‚ÇÇ + Œ∏‚ÇÅ)
{Œ± : Type u} [has_sizeof Œ±] (shr : Œ† (x : Œ±), lazy_list {y // slim_check.sizeof_lt y x}) (xs : list Œ±) : lazy_list {ys // slim_check.sizeof_lt ys xs}
(R : Type u_1) (S : Type u_3) [non_assoc_semiring R] [non_assoc_semiring S] [subsingleton S] : R ‚âÉ+* R √ó S
{C : Type u‚ÇÅ} [category_theory.category C] {Z X Y : C} (f : Z ‚ü∂ X) (g : Z ‚ü∂ Y) [category_theory.limits.has_pushout f g] : category_theory.is_pushout f g category_theory.limits.pushout.inl category_theory.limits.pushout.inr
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ SemiRing AddCommMon)
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_type R A ‚Üî ‚àÉ (s : finset A) (f : mv_polynomial {x // x ‚àà s} R ‚Üí‚Çê[R] A), function.surjective ‚áëf
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R ‚Üí+* S) (x : S) (p : polynomial R) : S
{X Y : CompHaus} (f : X ‚ü∂ Y) (bij : function.bijective ‚áëf) : category_theory.is_iso f
(Œ± : Type u_2) : Type u_2
{m : Type u ‚Üí Type u} [monad m] {Œ± Œ≤ : Type u} : tactic.mllist m Œ± ‚Üí (Œ± ‚Üí tactic.mllist m Œ≤) ‚Üí tactic.mllist m Œ≤
{M : Type u_1} [comm_monoid M] (x : M) : localization.away x
{p : ‚Ñï+ ‚Üí Sort u_1} (a : ‚Ñï+) (hz : p 1) (hi : Œ† (n : ‚Ñï+), (Œ† (m : ‚Ñï+), m ‚â§ n ‚Üí p m) ‚Üí p (n + 1)) : p a
{n : ‚Ñï} (x y : bitvec n) : Prop
{Œ± : Type u_1} {n : ‚Ñï} (f : fin n ‚Üí Œ±) (i : ‚Ñï) : option Œ±
{J : Type u} (F : J ‚Üí Type u) : ‚àê F ‚âÖ Œ£ (j : J), F j
(Œ± : expr) : tactic tactic.ring_exp.eval_info
(m k : ‚Ñï+) : ‚Ñï+
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} (h : s.finite) : metric.bounded s
{Œ± : Type u_3} {Œ≤ : Type u_4} [linear_ordered_field Œ±] {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±} {r : Œ±} (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Œª (x : Œ≤), f x * r) l filter.at_top
(S : Type u) [semiring S] : ‚Ñï ‚Üí polynomial S
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p‚ÇÅ : Œπ ‚Üí P) (p‚ÇÇ : P) (h : s.sum (Œª (i : Œπ), w i) = 1) : s.sum (Œª (i : Œπ), w i ‚Ä¢ (p‚ÇÅ i -·µ• p‚ÇÇ)) = ‚áë(s.affine_combination p‚ÇÅ) w -·µ• p‚ÇÇ
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} (r : L.relations 2) (t‚ÇÅ t‚ÇÇ : L.term (Œ± ‚äï fin n)) : L.bounded_formula Œ± n
{n : ‚Ñï} (x y : bitvec n) : bitvec n
 : ‚Ñ§ ‚Üí pexpr
{Œ± : Type u} (s : set Œ±) {t : set Œ±} [fintype ‚Ü•s] [decidable_pred (Œª (_x : Œ±), _x ‚àà t)] (h : t ‚äÜ s) : fintype ‚Ü•t
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) : ‚áëlinear_equiv.det hb.conj_lie.to_linear_equiv = -1
{Œ± : Type u_1} {G : Type u_2} [group G] [group Œ±] [mul_distrib_mul_action Œ± G] (a : Œ±) (H : subgroup G) : ‚Ü•H ‚âÉ* ‚Ü•(a ‚Ä¢ H)
{Œ± : Type u_1} : Œ± ‚Üí list Œ± ‚Üí Œ±
{ùïú : Type u_1} {V : Type u_2} {V‚ÇÇ : Type u_4} {P : Type u_8} {P‚ÇÇ : Type u_9} [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V P] [normed_add_torsor V‚ÇÇ P‚ÇÇ] {f : P ‚Üí·µÉ[ùïú] P‚ÇÇ} : continuous ‚áë(f.linear) ‚Üî continuous ‚áëf
(k : ‚Ñï) {r : ‚Ñù} (hr : 0 ‚â§ r) (h'r : r < 1) : filter.tendsto (Œª (n : ‚Ñï), ‚Üën ^ k * r ^ n) filter.at_top (nhds 0)
 : tactic unit
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (S : subsemigroup M) (f : M ‚Üí‚Çô* N) (hf : function.injective ‚áëf) : ‚Ü•S ‚âÉ* ‚Ü•(subsemigroup.map f S)
(n : ‚Ñï) : tactic (list expr)
(n : ‚Ñï+) : prime_multiset
{Œ≤ : Type u} {Œ≥ : Type w} [non_assoc_semiring Œ≤] [non_assoc_semiring Œ≥] (f : Œ≤ ‚Üí+* Œ≥) (s : multiset Œ≤) : ‚áëf s.sum = (multiset.map ‚áëf s).sum
(A : Type u_2) : Type u_2
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [preorder Œ±] [t : order_closed_topology Œ±] [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} {s : set Œ≤} (hs : is_closed s) (hf : continuous_on f s) (hg : continuous_on g s) : is_closed {x ‚àà s | f x ‚â§ g x}
{Œπ : Type u_1} {R : Type u_2} [semiring R] {Œ≤‚ÇÅ : Œπ ‚Üí Type u_7} {Œ≤‚ÇÇ : Œπ ‚Üí Type u_8} [Œ† (i : Œπ), add_comm_monoid (Œ≤‚ÇÅ i)] [Œ† (i : Œπ), add_comm_monoid (Œ≤‚ÇÇ i)] [Œ† (i : Œπ), module R (Œ≤‚ÇÅ i)] [Œ† (i : Œπ), module R (Œ≤‚ÇÇ i)] (e : Œ† (i : Œπ), Œ≤‚ÇÅ i ‚âÉ‚Çó[R] Œ≤‚ÇÇ i) : (Œ†‚ÇÄ (i : Œπ), Œ≤‚ÇÅ i) ‚âÉ‚Çó[R] Œ†‚ÇÄ (i : Œπ), Œ≤‚ÇÇ i
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {c : E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a ‚äì measure_theory.measure_space.volume.ae) (nhds c)) : has_strict_deriv_at (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in u..b, f x) (-c) a
{Œ± : Type u} (f : fin 0 ‚Üí Œ±) : list.of_fn f = list.nil
{ùïú : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [comm_ring ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] [add_comm_group F] [module ùïú F] [topological_space F] [topological_add_group F] [has_continuous_const_smul ùïú F] [add_comm_group G] [module ùïú G] [topological_space G] [topological_add_group G] [has_continuous_const_smul ùïú G] (p : formal_multilinear_series ùïú F G) (u : E ‚ÜíL[ùïú] F) : formal_multilinear_series ùïú E G
{X : Top} (T : ‚Ü•X ‚Üí Type v) : Type v
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.representably_flat F] : category_theory.limits.preserves_finite_limits F
(R : Type u) [comm_ring R] (L : Type v) (M : Type w) [field L] [field M] [algebra R M] [no_zero_smul_divisors R M] [is_alg_closure R M] [algebra R L] [no_zero_smul_divisors R L] [is_alg_closure R L] : L ‚âÉ‚Çê[R] M
{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] (s : set M) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {f g : category_theory.mono_over X} (h : f.val.left ‚âÖ g.val.left) (w : h.hom ‚â´ g.arrow = f.arrow) : f ‚âÖ g
{Œ± : Type u_2} [topological_space Œ±] [monoid Œ±] [has_continuous_mul Œ±] : has_continuous_mul Œ±À£
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] {A : C} : category_theory.over A ‚•§ category_theory.over A ‚•§ category_theory.over A
{K : Type u_1} [linear_ordered_field K] {v : K} [floor_ring K] (terminates : (generalized_continued_fraction.of v).terminates) : ‚àÉ (n : ‚Ñï), v = (generalized_continued_fraction.of v).convergents n
(Œ± : Type u_5) : Type u_5
{R : Type u} [ring R] {S T : subring R} (h : S ‚â§ T) : ‚Ü•S ‚Üí+* ‚Ü•T
{Œ± : Type} (ea : computability.fin_encoding Œ±) : turing.tm2_computable_in_poly_time ea ea id
(generate_induction_hyps : bool) (mpinfo : tactic.eliminate.major_premise_info) (iinfo : tactic.eliminate.inductive_info) (cinfo : tactic.eliminate.constructor_info) (with_patterns : list tactic.eliminate.with_pattern) (args : list (name √ó tactic.eliminate.constructor_argument_info)) (ihs : list (name √ó name √ó tactic.eliminate.constructor_argument_info)) : tactic (list expr √ó list expr)
{Œ± Œ≤ : Type u_1} (e : Œ± ‚âÉ Œ≤) : e.option_congr = equiv_functor.map_equiv option e
 : AddCommGroup.free ‚ä£ category_theory.forget AddCommGroup
{Œ± : Type u_1} [comm_monoid Œ±] (a b u : Œ±) (hu : is_unit u) : u * a ‚à£ b ‚Üî a ‚à£ b
(Œ± : Sort u) [has_variable_names Œ±] {Œ≤ : Sort v} : has_variable_names Œ≤
 : level ‚Üí list (name √ó level) ‚Üí level
{Œ± : Type v} [semiring Œ±] (n : Type u) [decidable_eq n] [fintype n] : Œ± ‚Üí+* matrix n n Œ±
(Œ± : Type u) {Œ≤ : Type v} {Œ≥ : Type w} {ùïú : Type u_2} [topological_space Œ±] [semi_normed_group Œ≤] [nondiscrete_normed_field ùïú] [normed_space ùïú Œ≤] [semi_normed_group Œ≥] [normed_space ùïú Œ≥] (g : Œ≤ ‚ÜíL[ùïú] Œ≥) : bounded_continuous_function Œ± Œ≤ ‚ÜíL[ùïú] bounded_continuous_function Œ± Œ≥
{Œ± : Type} (seed : ‚Ñï) (cmd : rand Œ±) : io Œ±
{q : ‚Ñï+} (w : 1 < q) : fintype.card (lucas_lehmer.X q)À£ < ‚Üëq ^ 2
(ts : list omega.term) : tactic (list ‚Ñï)
{X Y : algebraic_geometry.Scheme} (f : X ‚ü∂ Y) : Prop
{Œ± : Type u_1} {Œ±' : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_5} {Œ¥ : Type u_7} [decidable_eq Œ±'] [decidable_eq Œ≥] [decidable_eq Œ¥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s : finset Œ±} {t : finset Œ≤} {g : Œ≥ ‚Üí Œ¥} {f' : Œ±' ‚Üí Œ≤ ‚Üí Œ¥} {g' : Œ± ‚Üí Œ±'} (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' (g' a) b) : finset.image g (finset.image‚ÇÇ f s t) = finset.image‚ÇÇ f' (finset.image g' s) t
 : Type
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f‚ÇÇ : ùïú ‚Üí F} {s‚ÇÇ : set ùïú} {n : ‚Ñï} (hs : unique_diff_on ùïú s‚ÇÇ) : cont_diff_on ùïú ‚Üë(n + 1) f‚ÇÇ s‚ÇÇ ‚Üî differentiable_on ùïú f‚ÇÇ s‚ÇÇ ‚àß cont_diff_on ùïú ‚Üën (deriv_within f‚ÇÇ s‚ÇÇ) s‚ÇÇ
 : bool ‚Üí bool ‚Üí bool
{G : Type u_1} [add_group G] {H K : add_subgroup G} (h : ‚àÄ (x : G), x ‚àà H ‚Üî x ‚àà K) : H = K
{C : Type u} [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} (F : category_theory.limits.strong_epi_mono_factorisation f) {F' : category_theory.limits.mono_factorisation f} (hF' : category_theory.limits.is_image F') : category_theory.strong_epi F'.e
(ic : tactic.instance_cache) : expr ‚Üí expr ‚Üí bool ‚Üí tactic (tactic.instance_cache √ó expr √ó expr)
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (M' : add_subsemigroup M) : add_hom ‚Ü•M' ‚Ü•(add_subsemigroup.map f M')
(Œ± : Type u_1) : sym2 Œ± ‚âÉ {s // ‚áëmultiset.card s = 2}
{Œ± : Type u} [pseudo_metric_space Œ±] (x y : Œ±) : has_edist.edist x y ‚â† ‚ä§
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : algebraic_geometry.PresheafedSpace C} (Y : algebraic_geometry.SheafedSpace C) (f : X ‚ü∂ Y.to_PresheafedSpace) [H : algebraic_geometry.PresheafedSpace.is_open_immersion f] : algebraic_geometry.PresheafedSpace.is_open_immersion.to_SheafedSpace Y f ‚ü∂ Y
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.epi f] : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (ùüô Y) (ùüô Y) _)
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : Œπ ‚Üí M} [semiring R] [add_comm_monoid M] [add_comm_monoid M'] [module R M] [module R M'] (f : M ‚Üí‚Çó[R] M') (hfv : linear_independent R (‚áëf ‚àò v)) : linear_independent R v
(Œ± : Type u_1) : ‚Ü•set.univ ‚âÉ Œ±
(Œ± : Type u_1) : mul_action (equiv.perm Œ±) Œ±
{C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} (S : J.cover X) : S.pullback (ùüô X) ‚âÖ S
{X Z : algebraic_geometry.Scheme} (f : X ‚ü∂ Z) [H : algebraic_geometry.is_open_immersion f] : X ‚âÖ Z.restrict _
 : ¬¨summable (Œª (n : ‚Ñï), (‚Üën)‚Åª¬π)
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (t : category_theory.limits.is_initial X) : category_theory.limits.is_terminal (opposite.op X)
{F : pfunctor} : ‚Ñï ‚Üí F.M ‚Üí F.M ‚Üí Prop
(R : Type u) [semiring R] (p q : ‚Ñï) [hp : char_p R p] [hq : exp_char R q] : p = q ‚Üî nat.prime p
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X
{G : Type u_1} [group G] (H‚ÇÅ H‚ÇÇ : subgroup G) (hH‚ÇÅ : H‚ÇÅ.normal) (hH‚ÇÇ : H‚ÇÇ.normal) (hdis : disjoint H‚ÇÅ H‚ÇÇ) (x y : G) (hx : x ‚àà H‚ÇÅ) (hy : y ‚àà H‚ÇÇ) : commute x y
{R : Type u} [comm_semiring R] {n : ‚Ñï} (m : fin n ‚Üí‚ÇÄ ‚Ñï) (f : mv_polynomial (fin (n + 1)) R) (i : ‚Ñï) : mv_polynomial.coeff m ((‚áë(mv_polynomial.fin_succ_equiv R n) f).coeff i) = mv_polynomial.coeff (finsupp.cons i m) f
(t : ‚Ñù) : filter.tendsto (Œª (x : ‚Ñï), (1 + t / ‚Üëx) ^ x) filter.at_top (nhds (real.exp t))
 : mul_action ‚Ü•(matrix.GL_pos (fin 2) ‚Ñù) upper_half_plane
 : BoolAlg ‚âå BoolAlg
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [add_comm_monoid F] [ordered_add_comm_monoid Œ≤] [module ùïú E] [module ùïú F] [has_scalar ùïú Œ≤] {f : F ‚Üí Œ≤} {s : set F} (hf : convex_on ùïú s f) (g : E ‚Üí‚Çó[ùïú] F) : convex_on ùïú (‚áëg ‚Åª¬π' s) (f ‚àò ‚áëg)
{C : Type u} [category_theory.category C] {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Y} {g‚ÇÅ g‚ÇÇ : X ‚ü∂ Z} (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (h‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [category_theory.limits.has_pushout f‚ÇÅ g‚ÇÅ] [category_theory.limits.has_pushout f‚ÇÇ g‚ÇÇ] : category_theory.limits.pushout f‚ÇÅ g‚ÇÅ ‚âÖ category_theory.limits.pushout f‚ÇÇ g‚ÇÇ
{Œ± : Type u_1} {N : Type u_6} [comm_monoid N] {f : Œ± ‚Üí N} (a : Œ±) (hf : (function.mul_support f).finite) : f a ‚à£ finprod f
{C : Type u} [category_theory.category C] (F G : C ‚•§ category_theory.discrete punit) : F = G
{G : Type u_1} [semi_normed_group G] {H : Type u_2} [semi_normed_group H] [separated_space H] [complete_space H] (f : normed_group_hom G H) : normed_group_hom (uniform_space.completion G) H
{R : Type u_1} {M : Type u_2} [has_zero R] [add_comm_monoid M] [has_scalar R M] : has_scalar (nat.arithmetic_function R) (nat.arithmetic_function M)
(r : ‚Ñù) : ennreal
 : game ‚Üí game ‚Üí Prop
{M : Type u_1} [add_comm_monoid M] {A : Type u_2} [set_like A M] [add_submonoid_class A M] (S : A) : add_comm_monoid ‚Ü•S
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] : has_faithful_smul (module.End R M) M
{Œ± : Type u_2} [add_monoid Œ±] : add_monoid (set Œ±)
{Œ±‚ÇÅ : Type u_1} {Œ≤‚ÇÅ : Type u_2} {Œ±‚ÇÇ : Type u_3} {Œ≤‚ÇÇ : Type u_4} (e‚ÇÅ : Œ±‚ÇÅ ‚âÉ Œ±‚ÇÇ) (e‚ÇÇ : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ ‚âÉ Œ≤‚ÇÇ) : Œ±‚ÇÅ √ó Œ≤‚ÇÅ ‚âÉ Œ±‚ÇÇ √ó Œ≤‚ÇÇ
(R : Type u_1) (K : Type u_2) [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] : Type u_2
{p : ‚Ñï} [hp : fact (nat.prime p)] : witt_vector.is_poly p (Œª (R : Type u_1) (_x : comm_ring R), has_neg.neg)
{Œ± : Type u_1} {Œ≤ : Type u_2} [t : topological_space Œ≤] [polish_space Œ≤] (f : Œ± ‚âÉ Œ≤) : polish_space Œ±
{A : Type u_2} [add_group A] (a : A) : add_subgroup A
(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : field K
{M : Type u_1} [group M] (c : con M) : has_pow c.quotient ‚Ñ§
(p : ‚Ñï) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] (V : Type u_2) [add_comm_group V] : Type (max u_1 u_2)
{Œ± : Type u} (l : ordnode Œ±) (x : Œ±) (r : ordnode Œ±) : ordnode Œ±
{R : Type u} {n : ‚Ñï} {M : fin n.succ ‚Üí Type v} {M‚ÇÇ : Type v‚ÇÇ} [semiring R] [Œ† (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : fin n.succ), module R (M i)] [module R M‚ÇÇ] (f : multilinear_map R M M‚ÇÇ) (m : Œ† (i : fin n), M (‚áëfin.cast_succ i)) (c : R) (x : M (fin.last n)) : ‚áëf (fin.snoc m (c ‚Ä¢ x)) = c ‚Ä¢ ‚áëf (fin.snoc m x)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (C : homological_complex V c) [category_theory.limits.has_zero_object V] [category_theory.limits.has_kernels V] (i : Œπ) : category_theory.subobject (C.X i)
{A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ} [category_theory.category A] [category_theory.category B] [category_theory.category C] {U : B ‚•§ C} {F : C ‚•§ B} (R : A ‚•§ B) (F' : C ‚•§ A) (adj‚ÇÅ : F ‚ä£ U) (adj‚ÇÇ : F' ‚ä£ R ‚ãô U) [category_theory.limits.has_reflexive_coequalizers A] [Œ† (X : B), category_theory.regular_epi (adj‚ÇÅ.counit.app X)] (Y : A) (X : B) : (category_theory.lift_adjoint.construct_left_adjoint_obj R F' adj‚ÇÅ adj‚ÇÇ X ‚ü∂ Y) ‚âÉ (X ‚ü∂ R.obj Y)
(F : Type u_1) (R : out_param (Type u_2)) (M : out_param (Type u_3)) (M‚ÇÇ : out_param (Type u_4)) [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] : Type (max u_1 u_3 u_4)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V‚ÇÇ : Type v'} [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] (f : V ‚âÉ‚Çó[K] V‚ÇÇ) [finite_dimensional K V] : finite_dimensional K V‚ÇÇ
(C : Type u) [ùíû : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_pushouts C
{Œ± : Type u_1} {Œ≤ : Type u_2} [group Œ±] [comm_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : is_group_hom (Œª (a : Œ±), (f a)‚Åª¬π)
{G : Type u_10} {H : Type u_11} [add_zero_class G] [add_zero_class H] : G ‚âÉ+ H ‚âÉ (multiplicative G ‚âÉ* multiplicative H)
(R : Type u_1) [comm_ring R] [is_domain R] (p : ‚Ñï) [char_p R p] (hp : p ‚â† 2) : polynomial.cyclotomic' 2 R = polynomial.X + 1
{G : Type u_1} [semi_normed_group G] : normed_group_hom G (uniform_space.completion G)
{R : Type u_1} [ring R] {M : Type u_2} [topological_space M] [add_comm_group M] [module R M] (p : submodule R M) : Prop
{Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±) : ‚Ñï
(Œ± : Type u) : Type u
{Œ± : Type u} [has_add Œ±] : ulift Œ± ‚âÉ+ Œ±
{R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : ‚àÄ (a : R), a ‚àà l ‚Üí 0 < a) : 0 < l.prod
{A : Type v} [ring A] {M : Type w} [add_comm_group M] [module A M] : lie_ring_module A M
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) {p : P} (hp : p ‚àà affine_span ‚Ñù (set.range s.points)) {r : ‚Ñù} (hr : ‚àÄ (i : fin (n + 1)), has_dist.dist (s.points i) p = r) : p = s.circumcenter
(M : Type u_10) (Œ± : Type u_11) [has_scalar M Œ±] : Prop
(e : expr) : tactic (list (name √ó expr))
{X : Top} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : category_theory.limits.cocone (category_theory.full_subcategory_inclusion (Œª (V : topological_space.opens ‚Ü•X), ‚àÉ (i : Œπ), V ‚â§ U i))
(k : Type u) [field k] (s : finset (algebraic_closure.monic_irreducible k)) : mv_polynomial (algebraic_closure.monic_irreducible k) k ‚Üí‚Çê[k] (s.prod (Œª (x : algebraic_closure.monic_irreducible k), ‚Üëx)).splitting_field
{Œ± : Type u_1} [ring Œ±] : partial_order (ring_topology Œ±)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) (a : Œ±) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} [category_theory.limits.has_pullbacks C] (K : category_theory.pretopology C) : category_theory.presieve.is_sheaf (category_theory.pretopology.to_grothendieck C K) P ‚Üî ‚àÄ {X : C} (R : category_theory.presieve X), R ‚àà ‚áëK X ‚Üí category_theory.presieve.is_sheaf_for P R
(F : Type u_8) (Œ± : out_param (Type u_9)) (Œ≤ : out_param (Type u_10)) [has_Inf Œ±] [has_Inf Œ≤] : Type (max u_10 u_8 u_9)
{Œ± : Type u} [primcodable Œ±] [inhabited Œ±] (p : Œ± ‚Üí Prop) : many_one_degree
{Œ± : Type u_3} [semilattice_sup Œ±] [no_max_order Œ±] (a : Œ±) : filter.map coe filter.at_top = filter.at_top
(e : pexpr) (mono_lem : option pexpr) (hyp : expr) : tactic unit
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_refl Œ± r] : {c : cardinal | ‚àÉ (S : set Œ±), (‚àÄ (a : Œ±), ‚àÉ (b : Œ±) (H : b ‚àà S), r a b) ‚àß cardinal.mk ‚Ü•S = c}.nonempty
{x y : game} : ¬¨x ‚â§ y ‚Üî y.lf x
{C : Type u} [category_theory.category C] [category_theory.limits.has_strong_epi_mono_factorisations C] {X Y : C} {f : X ‚ü∂ Y} {I' : C} (e : X ‚ü∂ I') (m : I' ‚ü∂ Y) (comm : e ‚â´ m = f) [category_theory.strong_epi e] [category_theory.mono m] : I' ‚âÖ category_theory.limits.image f
{C : Type u‚ÇÅ} [category_theory.category C] {Z X Y : C} {f : Z ‚ü∂ X} {g : Z ‚ü∂ Y} {c : category_theory.limits.pushout_cocone f g} (h : category_theory.limits.is_colimit c) : category_theory.is_pushout f g c.inl c.inr
{Œ± Œ≤ : Type} (attr : user_attribute Œ± Œ≤) : tactic Œ±
{X Y : SemiNormedGroup} (f : X ‚ü∂ Y) : category_theory.limits.is_colimit (SemiNormedGroup.cokernel_cocone f)
{M : Type u_1} [comm_monoid M] (S : submonoid M) : localization.r S = localization.r' S
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.abelian D] (F : C ‚•§ D) (G : D ‚•§ C) [G.preserves_zero_morphisms] (i : F ‚ãô G ‚âÖ ùü≠ C) (adj : G ‚ä£ F) [category_theory.limits.has_cokernels C] [category_theory.limits.has_kernels C] [category_theory.limits.preserves_finite_limits G] [F.preserves_zero_morphisms] {X Y : C} (f : X ‚ü∂ Y) : category_theory.abelian.coimage f ‚âÖ category_theory.abelian.image f
{E : Type u_3} [normed_group E] (s : add_subgroup E) : normed_group ‚Ü•s
{G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ‚àà interior ‚ÜëH) : is_open ‚ÜëH
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) {r : ‚Ñù} (hr : 0 < r) : o.oangle (r ‚Ä¢ x) y = o.oangle x y
{R : Type u_1} [comm_ring R] (v w : fin 3 ‚Üí R) : matrix.dot_product v (‚áë(‚áëcross_product v) w) = 0
{G : Type u} [group G] {N : subgroup G} [N.normal] (hN : (nat.card ‚Ü•N).coprime N.index) : ‚àÉ (H : subgroup G), H.is_complement' N
{G : Type u_1} [left_cancel_semigroup G] (g : G) : G ‚Ü™ G
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [has_add Œπ] [Œ† (i : Œπ), add_comm_monoid (A i)] [direct_sum.gnon_unital_non_assoc_semiring A] : direct_sum Œπ (Œª (i : Œπ), A i) ‚Üí+ direct_sum Œπ (Œª (i : Œπ), A i) ‚Üí+ direct_sum Œπ (Œª (i : Œπ), A i)
{Œ± : Type u_1} [decidable_eq Œ±] : filter.cofinite.realizer
(ùïú : Type u_1) {V : Type u_2} {P : Type u_8} [normed_field ùïú] [semi_normed_group V] [normed_space ùïú V] [pseudo_metric_space P] [normed_add_torsor V P] (p : P) : V ‚âÉ·µÉ‚Å±[ùïú] P
{V : Type u} [inner_product_space ‚Ñù V] [complete_space V] {B : V ‚ÜíL[‚Ñù] V ‚ÜíL[‚Ñù] ‚Ñù} (coercive : is_coercive B) : V ‚âÉL[‚Ñù] V
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P (n + 1)) : 0 < s.circumradius
(Œì : Type u_4) (T : Type u_5) [topological_space T] [has_scalar Œì T] : Prop
{M : Type u_1} [has_mul M] : add_subsemigroup (additive M) ‚âÉo subsemigroup M
(E : Type u_8) [comm_group E] [topological_space E] [topological_group E] : continuous_monoid_hom (E √ó E) E
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ‚Ñù} [interval_integral.FTC_filter b (nhds_within b s) (nhds_within b t)] (hmeas : strongly_measurable_at_filter f (nhds_within b t) measure_theory.measure_space.volume) (hb : continuous_within_at f t b) (hs : unique_diff_within_at ‚Ñù s b . "unique_diff_within_at_Ici_Iic_univ") : deriv_within (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in a..u, f x) s b = f b
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (f : M ‚Üí* N) (M' : submonoid M) : ‚Ü•M' ‚Üí* ‚Ü•(submonoid.map f M')
{Œ± : Type u_1} (v : vector Œ± 1) : v.to_list = [v.head]
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ‚ü∂ Y} (s : category_theory.limits.fork f 0) : s ‚âÖ category_theory.limits.fork.of_Œπ s.Œπ _
{Œ± : Type u_1} [normed_lattice_add_comm_group Œ±] : normed_lattice_add_comm_group Œ±·µí·µà
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), add_comm_monoid (A i)] [add_monoid Œπ] [direct_sum.gsemiring A] {i : Œπ} : module (A 0) (A i)
(n : snum) : snum
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [conditionally_complete_linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] [nonempty Œ≥] {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±} (Cf : continuous_at f (‚®Ü (i : Œ≥), g i)) (Mf : monotone f) (H : bdd_above (set.range g)) : f (‚®Ü (i : Œ≥), g i) = ‚®Ü (i : Œ≥), f (g i)
(E : Type u_8) [add_comm_group E] [topological_space E] [topological_add_group E] : continuous_add_monoid_hom (E √ó E) E
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ‚Ñ§] (m n : ‚Ñ§) : category_theory.differential_object.shift_functor C (m + n) ‚âÖ category_theory.differential_object.shift_functor C m ‚ãô category_theory.differential_object.shift_functor C n
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {R : Type u_1} [semiring k] [add_monoid G] [semiring R] {f g : add_monoid_algebra k G ‚Üí+* R} (h‚ÇÄ : ‚àÄ (b : k), ‚áëf (finsupp.single 0 b) = ‚áëg (finsupp.single 0 b)) (h_of : ‚àÄ (a : G), ‚áëf (finsupp.single a 1) = ‚áëg (finsupp.single a 1)) : f = g
{X : Type u_1} {Œ± : Type u_2} [has_one Œ±] [topological_space X] (f : X ‚Üí Œ±) : set X
(a : zmod 8) : ‚áëzmod.œá‚Çà a = 0 ‚à® ‚áëzmod.œá‚Çà a = 1 ‚à® ‚áëzmod.œá‚Çà a = -1
 : ‚Ñï ‚Üí+* ‚Ñ§
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] : E ‚âÉL[‚Ñù] euclidean_space ‚Ñù (fin (finite_dimensional.finrank ‚Ñù E))
(k : Type u) [field k] : k ‚Üí+* algebraic_closure.step k 0
{R : Type u} [linear_order R] : has_add (tropical R)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] {X : C} (P : category_theory.is_isomorphic X 0) : X ‚âÖ 0
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : finite_dimensional.finrank K V = 1 ‚Üî ‚àÉ (v : V) (n : v ‚â† 0), ‚àÄ (w : V), ‚àÉ (c : K), c ‚Ä¢ v = w
{S : Type u} [pgame.state S] (s : S) : (pgame.of s).left_moves ‚âÉ {t // t ‚àà pgame.state.L s}
{p : ‚Ñù} : p ‚â§ 0 ‚Üí ennreal.of_real p = 0
{J : Type v} {C : Type u} [category_theory.category C] (F : category_theory.limits.wide_pullback_shape J ‚•§ C) : F ‚âÖ category_theory.limits.wide_pullback_shape.wide_cospan (F.obj option.none) (Œª (j : J), F.obj (option.some j)) (Œª (j : J), F.map (category_theory.limits.wide_pullback_shape.hom.term j))
(x : Set) : Class
(C : Type u) [category_theory.category C] [category_theory.limits.has_limits C] : category_theory.limits.has_finite_limits C
{R : Type u_2} {Œì‚ÇÄ : Type u_3} {Œì'‚ÇÄ : Type u_4} [ring R] [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] [linear_ordered_comm_monoid_with_zero Œì'‚ÇÄ] (f : Œì‚ÇÄ ‚Üí*‚ÇÄ Œì'‚ÇÄ) (hf : monotone ‚áëf) (v : valuation R Œì‚ÇÄ) : valuation R Œì'‚ÇÄ
{Œ± : Type u} : ordnode Œ± ‚Üí ordnode Œ±
{V‚ÇÅ : Type u_3} {V‚ÇÇ : Type u_4} [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] (f : normed_group_hom V‚ÇÅ V‚ÇÇ) : add_subgroup V‚ÇÅ
{R : Type u_2} {A : Type u_3} [comm_semiring R] [non_unital_semiring A] [module R A] [smul_comm_class R A A] [is_scalar_tower R A A] {C : Type u_5} [ring C] [algebra R C] : (A ‚Üí‚Çô‚Çê[R] C) ‚âÉ (unitization R A ‚Üí‚Çê[R] C)
(p : ‚Ñï ‚Üí Prop) [decidable_pred p] (i : infinite ‚Ü•(set_of p)) (n : ‚Ñï) : nat.nth p n = ‚Üë(‚áë(nat.subtype.order_iso_of_nat (set_of p)) n)
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inhabited Œ±] [inhabited Œ≤] (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : list Œ± ‚Üí list Œ≤ ‚Üí list Œ≥
{x : pgame} (h : 0 ‚â§ x) (j : x.right_moves) : 0 ‚â§ (x.move_right j).move_left (pgame.left_response h j)
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : is_compact s ‚Üí ‚àÄ (f : ultrafilter Œ±), ‚Üëf ‚â§ filter.principal s ‚Üí (‚àÉ (a : Œ±) (H : a ‚àà s), ‚Üëf ‚â§ nhds a)
(n : ‚Ñï) : Type
{Œ± : Type u_1} [comm_semiring Œ±] : linear_recurrence Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Ü™ Œ≤) : ‚ä§ ‚Ü™g ‚ä§
{C : Type u‚ÇÅ} [category_theory.category C] {Œ± : Type u_1} [partial_order Œ±] [‚àÄ (X Y : C), subsingleton (X ‚ü∂ Y)] (e : C ‚âå Œ±) : category_theory.thin_skeleton C ‚âÉo Œ±
{Œ± : Type u} (f : Œ± ‚Üí Type (max u v)) : ¬¨function.surjective f
{M : Type u_1} {N : Type u_2} {P : Type u_3} {Q : Type u_4} [has_add P] [has_add Q] (f : M ‚âÉ N) (g : P ‚âÉ+ Q) : (M ‚Üí P) ‚âÉ+ (N ‚Üí Q)
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [linear_ordered_add_comm_monoid_with_top Œì‚ÇÄ] [ring R] {S : Type u_1} [ring S] (f : S ‚Üí+* R) (v : add_valuation R Œì‚ÇÄ) : add_valuation S Œì‚ÇÄ
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_3} [fintype Œπ] (m : Œ† (i : Œπ), measure_theory.outer_measure (Œ± i)) : measure_theory.outer_measure (Œ† (i : Œπ), Œ± i)
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí option Œ±
{R : Type u_1} {S : Type u_3} [comm_ring R] [comm_ring S] : comm_ring (R √ó S)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {s : set ‚Ñù} {e : E} {a : ‚Ñù} {f : ‚Ñù ‚Üí E} (f_diff : differentiable_on ‚Ñù f s) (f_lim : continuous_within_at f s a) (hs : s ‚àà nhds_within a (set.Ioi a)) (f_lim' : filter.tendsto (Œª (x : ‚Ñù), deriv f x) (nhds_within a (set.Ioi a)) (nhds e)) : has_deriv_within_at f e (set.Ici a) a
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [compact_space Œ±] [metric_space Œ≤] : continuous (Œª (p : C(Œ±, Œ≤) √ó Œ±), ‚áë(p.fst) p.snd)
{S : Type u} [pgame.state S] (s : S) (t : (pgame.of s).left_moves) : ((pgame.of s).move_left t).relabelling (pgame.of ‚Üë((pgame.left_moves_of s).to_fun t))
{G : Type u_1} [group G] {N : Type u_3} [group N] (f g : G ‚Üí* N) : subgroup G
{Œ± : Type u_1} {Œπ : Type u_2} {Œ≤ : Type u_3} {S : Œπ ‚Üí set Œ±} {f : Œ† (i : Œπ), ‚Ü•(S i) ‚Üí Œ≤} {hf : ‚àÄ (i j : Œπ) (x : Œ±) (hxi : x ‚àà S i) (hxj : x ‚àà S j), f i ‚ü®x, hxi‚ü© = f j ‚ü®x, hxj‚ü©} {T : set Œ±} (hT' : T = set.Union S) (u : ‚Ü•T ‚Üí ‚Ü•T) (ui : Œ† (i : Œπ), ‚Ü•(S i) ‚Üí ‚Ü•(S i)) (hui : ‚àÄ (i : Œπ) (x : ‚Ü•(S i)), u (set.inclusion _ x) = set.inclusion _ (ui i x)) (uŒ≤ : Œ≤ ‚Üí Œ≤) (h : ‚àÄ (i : Œπ) (x : ‚Ü•(S i)), f i (ui i x) = uŒ≤ (f i x)) (x : ‚Ü•T) : set.Union_lift S f hf T _ (u x) = uŒ≤ (set.Union_lift S f hf T _ x)
{L : first_order.language} {Œ± : Type u'} : L.term Œ± ‚Üí list (Œ± ‚äï Œ£ (i : ‚Ñï), L.functions i)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_simple_module R M] : category_theory.simple (Module.of R M)
(ic zc nc : tactic.instance_cache) (a : expr) (na : ‚Ñö) (b : expr) : tactic (tactic.instance_cache √ó tactic.instance_cache √ó tactic.instance_cache √ó expr √ó expr)
{a b p q : ‚Ñù} (ha : 0 ‚â§ a) (hb : 0 ‚â§ b) (hpq : p.is_conjugate_exponent q) : a * b ‚â§ a ^ p / p + b ^ q / q
{C : Type u‚ÇÅ} [category_theory.category C] (F : C·µí·µñ ‚•§ Type v‚ÇÅ) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} : lazy_list Œ± ‚Üí (Œ± ‚Üí lazy_list Œ≤) ‚Üí lazy_list Œ≤
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s : set Œ±} {a : Œ±} (hs : bdd_below s) (sne : s.nonempty) : has_Inf.Inf (has_insert.insert a s) = a ‚äì has_Inf.Inf s
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (t : topological_space Œ≤) : topological_space Œ±
{Œ± : Type u} (c : computation Œ±) : ‚Ñï ‚Üí computation Œ±
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (h : M ‚âÉ* N) : is_monoid_hom ‚áëh
{M : Type u_3} {S : Type u_4} [sub_neg_monoid M] [set_like S M] [hSM : add_subgroup_class S M] {H : S} : has_sub ‚Ü•H
{Œ± : Type v} (P : Œ± ‚Üí Prop) : (Œ£ (i : Œ±), plift (P i)) ‚âÉ subtype P
{Œ± : Type u_1} [linear_order Œ±] (succ : Œ± ‚Üí Œ±) (hsucc_le_iff : ‚àÄ {a b : Œ±}, succ a ‚â§ b ‚Üî a < b) : succ_order Œ±
{M : Type u_1} {N : Type u_2} {mM : mul_one_class M} [comm_monoid N] : has_mul (M ‚Üí* N)
{ùïú : Type u_1} {E : Type u_4} (E‚Çó : Type u_5) {F‚Çó : Type u_7} {G‚Çó : Type u_9} [semi_normed_group E] [semi_normed_group E‚Çó] [semi_normed_group F‚Çó] [semi_normed_group G‚Çó] [nondiscrete_normed_field ùïú] [normed_space ùïú E] [normed_space ùïú E‚Çó] [normed_space ùïú F‚Çó] [normed_space ùïú G‚Çó] (L : E ‚ÜíL[ùïú] F‚Çó ‚ÜíL[ùïú] G‚Çó) : (E‚Çó ‚ÜíL[ùïú] E) ‚ÜíL[ùïú] F‚Çó ‚ÜíL[ùïú] E‚Çó ‚ÜíL[ùïú] G‚Çó
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) [complete_space ‚Ü•K] : E ‚âÉ‚Çó[ùïú] E
{Œ± : Type u_1} [fintype Œ±] {p q : Œ± ‚Üí Prop} [decidable_pred p] [decidable_pred q] (e : {x // p x} ‚âÉ {x // q x}) : {x // ¬¨p x} ‚âÉ {x // ¬¨q x}
(Œ± : Sort u_1) : Œ± ‚Ü™ Œ±
{R : Type u} [semiring R] {S : Type u_1} [add_comm_monoid S] (p : polynomial R) (f : ‚Ñï ‚Üí R ‚Üí S) : S
 : cc_state ‚Üí ‚Ñï
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} (a : P.A) (f' : (P.drop.B a).arrow Œ±) (f : P.last.B a ‚Üí P.W Œ±) : P.W Œ±
(R : Type u‚ÇÅ) [comm_semiring R] (p : ‚Ñï) [hp : fact (nat.prime p)] [char_p R p] : ring.perfection R p ‚Üí+* ring.perfection R p
{C : Type u‚ÇÅ} [category_theory.category C] {P X Y Z : C} {fst : P ‚ü∂ X} {snd : P ‚ü∂ Y} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} (h : category_theory.is_pullback fst snd f g) : category_theory.limits.is_limit h.cone
 : interactive.parse tactic.interactive.obtain_parse ‚Üí tactic unit
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} (hs : is_compact s) {f : filter Œ±} (hf : ‚àÄ (a : Œ±), a ‚àà s ‚Üí (‚àÉ (t : set Œ±) (H : t ‚àà nhds_within a s), t·∂ú ‚àà f)) : s·∂ú ‚àà f
 : stream ‚Ñï
{X Y Z : Top} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : category_theory.limits.pullback f g ‚âÖ Top.of {p // ‚áëf p.fst = ‚áëg p.snd}
(p : ‚Ñï) [hp : fact (nat.prime p)] (n j : ‚Ñï) (hj : j < p ^ n) : p ^ (n - pnat_multiplicity p ‚ü®j + 1, _‚ü©) ‚à£ (p ^ n).choose (j + 1)
(b c : ‚Ñù) (n : ‚Ñï) (hb : 0 < b) : filter.tendsto (Œª (x : ‚Ñù), (b * real.exp x + c) / x ^ n) filter.at_top filter.at_top
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_mul Œ±] [comm_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_mul_hom f) : is_mul_hom (Œª (a : Œ±), (f a)‚Åª¬π)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) (i : E ‚âÉL[ùïú] F) (h : p 1 = ‚áë((continuous_multilinear_curry_fin1 ùïú E F).symm) ‚Üëi) : (p.left_inv i).comp p = formal_multilinear_series.id ùïú E
{x y : pgame} : x ‚â§ y ‚Üî (‚àÄ (i : x.left_moves), (x.move_left i).lf y) ‚àß ‚àÄ (j : y.right_moves), x.lf (y.move_right j)
(hs : list expr) : tactic ‚Ñï
(Œ± : Type u_1) (Œ≤ : Type u_2) (R : Type u_3) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] : (Œ± ‚äï Œ≤ ‚Üí M) ‚âÉ‚Çó[R] (Œ± ‚Üí M) √ó (Œ≤ ‚Üí M)
{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] {X Y : C} {f : X ‚ü∂ Y} [category_theory.mono f] (s : category_theory.limits.cofork f 0) (h : category_theory.limits.is_colimit s) : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ f _)
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : Prop
{M : Type u_1} [monoid M] (x : M) : is_submonoid (powers x)
{C : Type u‚ÇÅ} [category_theory.category C] {T‚ÇÅ T‚ÇÇ T‚ÇÉ : category_theory.monad C} (f : T‚ÇÅ ‚ü∂ T‚ÇÇ) (g : T‚ÇÇ ‚ü∂ T‚ÇÉ) : category_theory.monad.algebra_functor_of_monad_hom (f ‚â´ g) ‚âÖ category_theory.monad.algebra_functor_of_monad_hom g ‚ãô category_theory.monad.algebra_functor_of_monad_hom f
{n : ‚Ñï} (i : fin (n + 1)) : affine.simplex.points_with_circumcenter_index n ‚Üí ‚Ñù
{M : Type u} [add_zero_class M] (x : M) : add_semiconj_by 0 x x
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_mul Œ±] [has_add Œ±] [has_le Œ±] [has_mul Œ≤] [has_add Œ≤] [has_le Œ≤] (e : Œ± ‚âÉ+*o Œ≤) : Œ≤ ‚Üí Œ±
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] [pseudo_emetric_space Œ≥] (h‚ÇÅ : Œ± ‚âÉ·µ¢ Œ≤) (h‚ÇÇ : Œ≤ ‚âÉ·µ¢ Œ≥) : Œ± ‚âÉ·µ¢ Œ≥
{G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] [locally_compact_space G] : measure_theory.measure G
{Œ± : Type u_1} {Œ≤ : Type u_2} [primcodable Œ±] [primcodable Œ≤] (p : Œ± ‚Üí Prop) (q : Œ≤ ‚Üí Prop) : Prop
(Œ± : Type u_6) (Œ≤ : Type u_7) [non_assoc_semiring Œ±] [preorder Œ±] [non_assoc_semiring Œ≤] [preorder Œ≤] : Type (max u_6 u_7)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚ÜíL[ùïú] F) : Type (max u_2 u_3)
(A : Type y) [add_monoid A] : A ‚âÉ (‚Ñï ‚Üí+ A)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {l : Œ±·µí·µà ‚Üí Œ≤·µí·µà} {u : Œ≤·µí·µà ‚Üí Œ±·µí·µà} : galois_insertion l u ‚Üí galois_coinsertion (‚áëorder_dual.of_dual ‚àò u ‚àò ‚áëorder_dual.to_dual) (‚áëorder_dual.of_dual ‚àò l ‚àò ‚áëorder_dual.to_dual)
{M : Type u_6} [monoid M] (u : MÀ£) : equiv.perm M
{R : Type u_1} [euclidean_domain R] (abv : absolute_value R ‚Ñ§) : Type
(p : parser char) : parser string
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] : category_theory.braided_functor C C
{Œ± : Type u_1} (l : lazy_list Œ±) : lazy_list {x // x ‚àà l}
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [has_Inf Œ±] [has_Inf Œ≤] [has_Inf Œ≥] (f : Inf_hom Œ≤ Œ≥) (g : Inf_hom Œ± Œ≤) : Inf_hom Œ± Œ≥
(R : Type u) [comm_ring R] (f : R) : localization.away f ‚Üí+* ‚Ü•((algebraic_geometry.Spec.structure_sheaf R).val.obj (opposite.op (prime_spectrum.basic_open f)))
{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ‚Ñï} (hb : 1 < b) {x : ‚Ñ§} {r : R} (hr : 0 < r) : ‚Üëb ^ x < r ‚Üî x < int.clog b r
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : set Œ±) (t : set Œ≤) (h : set.maps_to f s t) : ‚Ü•s ‚Üí ‚Ü•t
{Œ± : Type u} [has_sizeof Œ±] (k : ‚Ñï) (hk : 0 < k) (xs : list Œ±) (n : ‚Ñï) : n = xs.length ‚Üí lazy_list {ys // slim_check.sizeof_lt ys xs}
{Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [ring Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_ring_hom f) {Œ≥ : Type u_1} [ring Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : is_ring_hom g) : is_ring_hom (g ‚àò f)
(K : Type u) [field K] (V : Type v) [add_comm_group V] [module K V] [finite_dimensional K V] : (linear_map.ltensor V (contract_left K V)).comp ((tensor_product.assoc K V (module.dual K V) V).to_linear_map.comp (linear_map.rtensor V (coevaluation K V))) = (tensor_product.rid K V).symm.to_linear_map.comp (tensor_product.lid K V).to_linear_map
{Œ± : Type u_1} [Œ≤ : normed_ring Œ±] : non_unital_normed_ring Œ±
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} {Œ¥ : Type u_5} [preorder Œ±] [preorder Œ≤] [preorder Œ≥] [preorder Œ¥] (f : Œ± ‚Üío Œ≤) (g : Œ≥ ‚Üío Œ¥) : Œ± √ó Œ≥ ‚Üío Œ≤ √ó Œ¥
{ùïú : Type u_3} {E : Type u_4} [semi_normed_ring ùïú] [add_monoid E] [smul_with_zero ùïú E] : zero_hom_class (seminorm ùïú E) E ‚Ñù
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} [nontrivial k] {s : finset Œπ} {w : Œπ ‚Üí k} (h : s.sum (Œª (i : Œπ), w i) = 1) (p : Œπ ‚Üí P) : ‚áë(s.affine_combination p) w ‚àà affine_span k (set.range p)
 : category_theory.limits.has_limits category_theory.Cat
 : pgame ‚Üí Type (u+1)
{Œì : Type u_1} [inhabited Œì] (a : Œì) (l : turing.list_blank Œì) : turing.list_blank Œì
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] {f g : equiv.perm Œ±} (hf : f.is_cycle) (hg : g.is_cycle) (h : f.support ‚äÜ g.support) (h' : ‚àÄ (x : Œ±), x ‚àà f.support ‚Üí ‚áëf x = ‚áëg x) : f = g
{Œ± : Type u_1} (s t : finset Œ±) (h : ‚àÄ (a : Œ±), a ‚àà s ‚Üí a ‚àâ t) : finset Œ±
{Œ± : Type u} [preorder Œ±] {s t : set Œ±} (h : bdd_below t) : bdd_below (s ‚à© t)
 : Type
{V : Type (u+1)} [category_theory.large_category V] {G : Mon} : Action.functor_category_equivalence.inverse ‚ãô Action.functor_category_equivalence.functor ‚âÖ ùü≠ (category_theory.single_obj ‚Ü•G ‚•§ V)
 : expr ‚Üí tactic (list expr √ó expr)
{Œ± : Type u_1} [decidable_eq Œ±] {s t : finset Œ±} (h : s ‚äÜ t) : (finset.Ioc s t).card = 2 ^ (t.card - s.card) - 1
(val : expr) (l : list (name √ó expr)) : tactic (option expr)
{L : first_order.language} (r : L.relations 2) : L.sentence
 : (nim 1).relabelling pgame.star
(C : Type u) [category_theory.category C] : nonempty (C ‚âå category_theory.discrete punit) ‚Üî nonempty C ‚àß ‚àÄ (x y : C), nonempty (unique (x ‚ü∂ y))
(R : Type u_1) [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] (H : ‚àÄ (x : ‚Ü•M), is_unit ‚Üëx) : R ‚âÉ‚Çê[R] S
 : format
{V : Type u_1} [inner_product_space ‚Ñù V] {x y : V} : inner_product_geometry.angle x y = 0 ‚Üî x ‚â† 0 ‚àß ‚àÉ (r : ‚Ñù), 0 < r ‚àß y = r ‚Ä¢ x
{C : Type u‚ÇÅ} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D·µí·µñ) : F.left_op.right_op ‚âÖ F
{n : ‚Ñ§} : is_unit n ‚Üí n.nat_abs = 1
(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop
(n : ‚Ñï) (l : multiset ‚Ñï) (hl : l.sum = n) : n.partition
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} (R : L.relations n) (ts : fin n ‚Üí L.term Œ±) : L.formula Œ±
(t : Type u ‚Üí Type u ‚Üí Type u) [bitraversable t] : Type
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {D : Type u‚ÇÅ} [category_theory.category D] (L : C ‚•§ D) [category_theory.is_left_adjoint L] : category_theory.is_cofiltered D
{M : Type w} {N : Type w'} (f : M ‚Üí N) : first_order.language.empty.hom M N
(m : Type u ‚Üí Type u) (Œ± : Type u) : Type u
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) [category_theory.is_filtered J] : category_theory.limits.cocone F
(X : Type u_1) [topological_space X] [h : topological_space.metrizable_space X] : metric_space X
{n : ‚Ñï+} {K : Type u_1} [field K] {L : Type u_2} [field L] [algebra K L] [is_cyclotomic_extension {n} K L] (h : irreducible (polynomial.cyclotomic ‚Üën K)) [ne_zero ‚Üë‚Üën] : (polynomial.cyclotomic ‚Üën K).gal ‚âÉ* (zmod ‚Üën)À£
{T : Type w} [comm_ring T] (p : polynomial T) (S : Type u_1) [comm_ring S] [is_domain S] [algebra T S] : set S
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space F] [complete_space E] (e : E ‚âÉ‚Çó[ùïú] F) (h : continuous ‚áëe) : E ‚âÉL[ùïú] F
(ùïÇ : Type u_1) {ùî∏ : Type u_2} {ùîπ : Type u_3} [is_R_or_C ùïÇ] [normed_ring ùî∏] [normed_algebra ùïÇ ùî∏] [normed_ring ùîπ] [normed_algebra ùïÇ ùîπ] [complete_space ùî∏] {F : Type u_4} [ring_hom_class F ùî∏ ùîπ] (f : F) (hf : continuous ‚áëf) (x : ùî∏) : ‚áëf (exp ùïÇ x) = exp ùïÇ (‚áëf x)
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y z : M} (hx : same_ray R x z) (hy : same_ray R y z) : same_ray R (x + y) z
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [has_sub Œ≤] : has_sub Œ±
{Œ± : Type u_1} [denumerable Œ±] : denumerable (list Œ±)
{C : Type u} [category_theory.category C] (G : C) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [metric_space Œ≤] {f : Œ± ‚Üí Œ≤} (h : embedding f) : isometry f
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : isometry f) (x y : Œ±) : has_edist.edist (f x) (f y) = has_edist.edist x y
{Œ± : Type u_1} {m : measurable_space Œ±} : measure_theory.complex_measure Œ± ‚Üí‚Çó[‚Ñù] measure_theory.signed_measure Œ±
{R : Type u} [semiring R] {p : polynomial R} {n : ‚Ñï} (r : R) : p * polynomial.X ^ n * ‚áëpolynomial.C r = p * ‚áëpolynomial.C r * polynomial.X ^ n
 : nnreal ‚Üí+* ‚Ñù
(p : ‚Ñï ‚Üí Prop) [decidable_pred p] (n : ‚Ñï) : nat.count p n = fintype.card {k // k < n ‚àß p k}
(e : expr) : list name
(R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v‚ÇÅ v‚ÇÇ : M) : Prop
{R‚ÇÅ : Type u_4} [comm_ring R‚ÇÅ] : quadratic_form R‚ÇÅ R‚ÇÅ
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] : Œ± √ó Œ≤ ‚âÉ·µê Œ≤ √ó Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] {X' Y' : C} (f' : X' ‚ü∂ Y') [category_theory.limits.has_kernel f'] (p : X ‚ü∂ X') (q : Y ‚ü∂ Y') (w : f ‚â´ q = p ‚â´ f') : category_theory.limits.kernel f ‚ü∂ category_theory.limits.kernel f'
{K : Type u_1} [division_ring K] {Œì‚ÇÄ : Type u_2} [linear_ordered_comm_group_with_zero Œì‚ÇÄ] [valued K Œì‚ÇÄ] : separated_space K
{K : Type u} {L : Type v} [field K] [field L] (f : K ‚Üí+* L) : subfield L
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Œπ R M) {x y : M} (h : ‚àÄ (i : Œπ), ‚áë(‚áë(b.repr) x) i = ‚áë(‚áë(b.repr) y) i) : x = y
{ùïú : Type u_1} {E : Type u_2} [linear_ordered_field ùïú] [ordered_add_comm_group E] [module ùïú E] (S : convex_cone ùïú E) (h : ‚àÄ (x y : E), x ‚â§ y ‚Üî y - x ‚àà S) : ordered_smul ùïú E
{C : Type u‚ÇÅ} [category_theory.category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (R : category_theory.presieve X) [category_theory.limits.has_pullbacks C] : Type (max v‚ÇÅ u‚ÇÅ)
{Œ± : Type} : (tactic.instance_cache ‚Üí tactic (tactic.instance_cache √ó Œ±)) ‚Üí tactic.ring.ring_m Œ±
{C : Type u} [category_theory.category C] : category_theory.cosimplicial_object.augmented C ‚•§ category_theory.arrow C
(type : name) : tactic unit
{G : Type u_4} [normed_group G] [normed_space ‚Ñù G] {s : set G} {x y : G} (h : segment ‚Ñù x y ‚äÜ s) : y - x ‚àà tangent_cone_at ‚Ñù s x
{Œ± : Type u} [pseudo_emetric_space Œ±] {s t : set Œ±} (hs : s.nonempty) (fin : emetric.Hausdorff_edist s t ‚â† ‚ä§) : t.nonempty
{Œ± : Type u_2} {Œ≤ : Type u_3} [add_comm_monoid Œ±] [add_comm_monoid Œ≤] {A : set Œ±} {n : ‚Ñï} : has_zero (A ‚Üí+[n] Œ≤)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) : submonoid (Œ† (j : J), ‚Ü•(F.obj j))
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) [category_theory.is_iso h.counit] : category_theory.faithful R
(G : Type u_1) [add_comm_monoid G] : add_submonoid G
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : C
 : has_lt.lt ‚âÉr has_lt.lt
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : add_localization.r S = add_localization.r' S
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {t : set (set Œ±)} (h : t.pairwise_disjoint id) (ht‚ÇÄ : t.finite) (ht‚ÇÅ : ‚àÄ (x : set Œ±), x ‚àà t ‚Üí x.finite) : finprod (Œª (a : Œ±), finprod (Œª (H : a ‚àà ‚ãÉ‚ÇÄt), f a)) = finprod (Œª (s : set Œ±), finprod (Œª (H : s ‚àà t), finprod (Œª (a : Œ±), finprod (Œª (H : a ‚àà s), f a))))
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ‚•§ D) [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.enough_injectives C] [category_theory.limits.preserves_finite_limits F] {X : C} (P : category_theory.InjectiveResolution X) : (F.right_derived 0).obj X ‚ü∂ F.obj X
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {E' : Type u_7} [inner_product_space ùïú E'] (f : E ‚Üí‚Çó[ùïú] E') (h : ‚àÄ (x y : E), has_inner.inner (‚áëf x) (‚áëf y) = has_inner.inner x y) : E ‚Üí‚Çó·µ¢[ùïú] E'
{R‚ÇÇ : Type u_5} {M‚ÇÇ : Type u_6} [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {B‚ÇÇ : bilin_form R‚ÇÇ M‚ÇÇ} {Œπ : Type u_13} (b : basis Œπ R‚ÇÇ M‚ÇÇ) (x y : M‚ÇÇ) : (‚áë(b.repr) x).sum (Œª (i : Œπ) (xi : R‚ÇÇ), (‚áë(b.repr) y).sum (Œª (j : Œπ) (yj : R‚ÇÇ), xi ‚Ä¢ yj ‚Ä¢ ‚áëB‚ÇÇ (‚áëb i) (‚áëb j))) = ‚áëB‚ÇÇ x y
{Œ± : Type u} {p q : Œ± ‚Üí Prop} (h : ‚àÄ {x : Œ±}, q x ‚Üí p x) : {x // q x.val} ‚âÉ subtype q
{K : Type u_1} [is_R_or_C K] : ‚Ñù ‚Üí‚Çó·µ¢[‚Ñù] K
{C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} (f : X ‚ü∂ Y) [h : algebraic_geometry.PresheafedSpace.is_open_immersion f] [h' : category_theory.epi f.base] : category_theory.is_iso f
{Œ± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] (c : ‚Ñù) (l : filter Œ±) (f : Œ± ‚Üí E) (g : Œ± ‚Üí F) : Prop
 : expr ‚Üí expr ‚Üí bool
{Œ± : Type u_2} {G : Type u_4} [topological_space Œ±] [group G] [mul_action G Œ±] [has_continuous_const_smul G Œ±] (Œ≥ : G) : Œ± ‚âÉ‚Çú Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ‚ü∂ Y} {c : category_theory.limits.kernel_fork f} (i : category_theory.limits.is_limit c) {Z : C} (g : Y ‚ü∂ Z) [hg : category_theory.mono g] {h : X ‚ü∂ Z} (hh : h = f ‚â´ g) : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ (category_theory.limits.fork.Œπ c) _)
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {Œ¥ : Sort u_4} (e‚ÇÅ : Œ± ‚Ü™ Œ≤) (e‚ÇÇ : Œ≥ ‚Ü™ Œ¥) : pprod Œ± Œ≥ ‚Ü™ pprod Œ≤ Œ¥
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : rel Œ± Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] {D : Type u‚ÇÅ} [category_theory.category D] [category_theory.preadditive D] (F : category_theory.Mat_ C ‚•§ D) [F.additive] (M : category_theory.Mat_ C) : F.obj M ‚âÖ ‚®Å Œª (i : M.Œπ), F.obj ((category_theory.Mat_.embedding C).obj (M.X i))
 : tactic.ring2.horner_expr ‚Üí Prop
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) : (Œ£ (j : J), ‚Ü•(F.obj j)) ‚Üí Mon.filtered_colimits.M F
{Œ± : Type u_2} [has_one Œ±] [has_mul Œ±] : has_pow (filter Œ±) ‚Ñï
{xl xr : Type u_1} (xL : xl ‚Üí pgame) (xR : xr ‚Üí pgame) [S : (pgame.mk xl xr xL xR).short] (j : xr) : (xR j).short
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} {Œπ : Type u_5} [linear_ordered_field ùïú] [add_comm_group E] [ordered_add_comm_group Œ≤] [module ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} {t : finset Œπ} {w : Œπ ‚Üí ùïú} {p : Œπ ‚Üí E} (hf : convex_on ùïú s f) (h‚ÇÄ : ‚àÄ (i : Œπ), i ‚àà t ‚Üí 0 ‚â§ w i) (h‚ÇÅ : t.sum (Œª (i : Œπ), w i) = 1) (hmem : ‚àÄ (i : Œπ), i ‚àà t ‚Üí p i ‚àà s) : f (t.sum (Œª (i : Œπ), w i ‚Ä¢ p i)) ‚â§ t.sum (Œª (i : Œπ), w i ‚Ä¢ f (p i))
(R : Type u) [semiring R] {Œπ : Type v} [dec_Œπ : decidable_eq Œπ] {Œ± : option Œπ ‚Üí Type w} [Œ† (i : option Œπ), add_comm_monoid (Œ± i)] [Œ† (i : option Œπ), module R (Œ± i)] : direct_sum (option Œπ) (Œª (i : option Œπ), Œ± i) ‚âÉ‚Çó[R] Œ± option.none √ó direct_sum Œπ (Œª (i : Œπ), Œ± (option.some i))
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (a : Œ±) : Œ± ‚Üí Prop
{V : Type u} [quiver V] {C : Type u} [category_theory.category C] (F : prefunctor V C) : category_theory.paths V ‚•§ C
(n : ‚Ñï) (i : fin (n + 1)) : sSet.horn n i ‚ü∂ sSet.standard_simplex.obj (simplex_category.mk n)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (G : C ‚•§ D) [G.preserves_zero_morphisms] {X Y Z : C} {f : X ‚ü∂ Y} {h : Z ‚ü∂ X} (w : h ‚â´ f = 0) : category_theory.limits.is_limit (G.map_cone (category_theory.limits.kernel_fork.of_Œπ h w)) ‚âÉ category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ (G.map h) _)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] (s : set Œ±) (t : set Œ≤) : Prop
{P : Type u_1} [preorder P] (D : order.cofinal P) (x : P) : P
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [nonempty Œ±] (f : filter Œ≤) (g : Œ≤ ‚Üí Œ±) : Œ±
{M : Type u_1} [has_mul M] {S T : subsemigroup M} (h : S = T) : ‚Ü•S ‚âÉ* ‚Ü•T
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (f : M ‚Üí N) (H : ‚àÄ (x y : M), f (x * y) = f x * f y) (h : con.mul_ker f H ‚â§ c) (hf : function.surjective f) : con N
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) [hS : is_closed ‚ÜëS] : normed_group (M ‚ß∏ S)
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] (l : list Œ±) : list ‚Ñï
{C : Type u} {D : Type u'} [category_theory.category D] [category_theory.monoidal_category D] (f : C ‚Üí D) {X Y : category_theory.free_monoidal_category C} : X.hom Y ‚Üí (category_theory.free_monoidal_category.project_obj f X ‚ü∂ category_theory.free_monoidal_category.project_obj f Y)
{Œ≤ : Type u_2} [comm_monoid Œ≤] {n : ‚Ñï} (f : fin (n + 1) ‚Üí Œ≤) : finset.univ.prod (Œª (i : fin (n + 1)), f i) = finset.univ.prod (Œª (i : fin n), f (‚áëfin.cast_succ i)) * f (fin.last n)
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {la lb : filter ‚Ñù} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f la measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f lb measure_theory.measure_space.volume) {s t : set ‚Ñù} [interval_integral.FTC_filter a (nhds_within a s) la] [interval_integral.FTC_filter b (nhds_within b t) lb] (ha : filter.tendsto f la (nhds (f a))) (hb : filter.tendsto f lb (nhds (f b))) : has_fderiv_within_at (Œª (p : ‚Ñù √ó ‚Ñù), ‚à´ (x : ‚Ñù) in p.fst..p.snd, f x) ((continuous_linear_map.snd ‚Ñù ‚Ñù ‚Ñù).smul_right (f b) - (continuous_linear_map.fst ‚Ñù ‚Ñù ‚Ñù).smul_right (f a)) (s √óÀ¢ t) (a, b)
{K : Type u_1} {Œ≤ : Type u_2} [has_coe K Œ≤] : has_coe (generalized_continued_fraction.int_fract_pair K) (generalized_continued_fraction.int_fract_pair Œ≤)
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (g : G) (p : P) : g +·µ• p -·µ• p = g
{Œ± : Type u_1} {Œπ : Type u_3} [lattice Œ±] [order_bot Œ±] (s : finset Œπ) (f : Œπ ‚Üí Œ±) : Prop
(Œπ : Type u_1) [decidable_eq Œπ] {R : Type u_2} [add_monoid Œπ] [non_unital_non_assoc_semiring R] : direct_sum.gnon_unital_non_assoc_semiring (Œª (i : Œπ), R)
{n : with_top ‚Ñï} {ùïÇ : Type u_6} [is_R_or_C ùïÇ] {F' : Type u_8} [normed_group F'] [normed_space ùïÇ F'] {f : ùïÇ ‚Üí F'} {x : ùïÇ} (hf : cont_diff_at ùïÇ n f x) (hn : 1 ‚â§ n) : has_strict_deriv_at f (deriv f x) x
{X : Top} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : Type v
(proj_folder : string) : tactic (list declaration)
{ùïú : Type u_1} [is_R_or_C ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {r : ‚Ñù} (hr : 0 < r) : normed_space.polar ùïú (metric.closed_ball 0 r) = metric.closed_ball 0 r‚Åª¬π
{R : Type u_1} {R‚Çò : Type u_2} [comm_ring R] [comm_ring R‚Çò] {M : submonoid R} (hM : 0 ‚àâ M) (hR : is_field R) [algebra R R‚Çò] [is_localization M R‚Çò] : function.bijective ‚áë(algebra_map R R‚Çò)
{m : Type u ‚Üí Type u} [monad m] {Œ± : Type u} : tactic.mllist m Œ± ‚Üí m (option (Œ± √ó tactic.mllist m Œ±))
 : tactic.itauto.prop ‚Üí tactic.itauto.proof ‚Üí tactic.itauto.proof
{Œ± : Type u} [e : emetric_space Œ±] (h : ‚àÄ (x y : Œ±), has_edist.edist x y ‚â† ‚ä§) : metric_space Œ±
(R : Type u) [comm_semiring R] (A : Type v‚ÇÅ) [semiring A] [algebra R A] : tensor_product R R A ‚âÉ‚Çê[R] A
{K : Type u} [field K] : has_inf (subfield K)
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (t : topological_space Œ±) : topological_space Œ≤
(u : pSet) : set pSet
{Œ± : Type u} [decidable_eq Œ±] : slim_check.injective_function Œ± ‚Üí Œ± ‚Üí Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ (v‚ÇÇ+1))
{Œ≤ : Type u_2} (x : Œ≤) (V : set (Œ≤ √ó Œ≤)) : set Œ≤
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f : J ‚Üí C} {t : category_theory.limits.cocone (category_theory.discrete.functor f)} (ht : category_theory.limits.is_colimit t) : category_theory.limits.bicone f
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [rŒ± : non_assoc_semiring Œ±] [rŒ≤ : non_assoc_semiring Œ≤] {rŒ≥ : non_assoc_semiring Œ≥} (g : Œ≤ ‚Üí+* Œ≥) (f : Œ± ‚Üí+* Œ≤) : Œ± ‚Üí+* Œ≥
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) [category_theory.projective Z] : category_theory.ProjectiveResolution Z
{Œπ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (c : complex_shape Œπ) : homological_complex V c ‚•§ category_theory.graded_object Œπ V
{Œ± : Type u} [has_lt Œ±] [hwo : is_well_order Œ± has_lt.lt] : has_well_founded Œ±
(R : Type u) : Type u
{F : pfunctor} (x : F.obj F.M) (n : ‚Ñï) : pfunctor.approx.cofix_a F n
 : ‚Ñù ‚Üí+ additive ‚Ü•circle
 : tactic.itauto.prop ‚Üí tactic.itauto.prop ‚Üí tactic.itauto.prop
(p : ‚Ñï) (q : ‚Ñö) : 0 ‚â§ padic_norm p q
{Œ± : Type u_1} {Œ≤ : Type u_2} [semilattice_inf Œ±] [order_top Œ±] {P : Œ± ‚Üí Prop} {Ptop : P ‚ä§} {Pinf : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, P x ‚Üí P y ‚Üí P (x ‚äì y)} (t : finset Œ≤) (f : Œ≤ ‚Üí {x // P x}) : ‚Üë(t.inf f) = t.inf (Œª (x : Œ≤), ‚Üë(f x))
{Œ± : Type u_1} {f g : ‚Ñï ‚Üí Œ±} [topological_space Œ±] [non_unital_non_assoc_semiring Œ±] [regular_space Œ±] [topological_semiring Œ±] (hf : summable f) (hg : summable g) (hfg : summable (Œª (x : ‚Ñï √ó ‚Ñï), f x.fst * g x.snd)) : (‚àë' (n : ‚Ñï), f n) * ‚àë' (n : ‚Ñï), g n = ‚àë' (n : ‚Ñï), (finset.nat.antidiagonal n).sum (Œª (kl : ‚Ñï √ó ‚Ñï), f kl.fst * g kl.snd)
{M : Type u_1} [add_monoid M] {Œ≥ : Type u_2} [add_monoid Œ≥] {f : M ‚Üí Œ≥} (hf : is_add_monoid_hom f) : is_add_submonoid (set.range f)
{E : Type u_5} [semi_normed_group E] {R' : Type u_10} [ring R'] [module R' E] (p : submodule R' E) : ‚Ü•p ‚ÜíL[R'] E
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} {f' : ‚Ñù ‚Üí E} (hderiv : ‚àÄ (x : ‚Ñù), x ‚àà set.interval a b ‚Üí has_deriv_at f (f' x) x) (hint : interval_integrable f' measure_theory.measure_space.volume a b) : ‚à´ (y : ‚Ñù) in a..b, f' y = f b - f a
(M : Type u_1) [has_mul M] : Type u_1
{Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_action Œ± Œ≤] (g : Œ±) (x : Œ≤) : add_action.stabilizer Œ± (g +·µ• x) = add_subgroup.map (add_equiv.to_add_monoid_hom (‚áëadd_aut.conj g)) (add_action.stabilizer Œ± x)
{Œ± : Type u} [topological_space Œ±] (s : set Œ±) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≤' : Type u_4} {Œ≥ : Type u_5} {Œ¥ : Type u_7} {m : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {f : filter Œ±} {g : filter Œ≤} {n : Œ≥ ‚Üí Œ¥} {m' : Œ± ‚Üí Œ≤' ‚Üí Œ¥} {n' : Œ≤ ‚Üí Œ≤'} (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤), n (m a b) = m' a (n' b)) : filter.map n (filter.map‚ÇÇ m f g) = filter.map‚ÇÇ m' f (filter.map n' g)
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} (R : category_theory.presieve X) : category_theory.presieve.is_sheaf_for P R ‚Üî category_theory.presieve.is_sheaf_for P ‚áë(category_theory.sieve.generate R)
{Œπ : Type u_1} [fintype Œπ] [decidable_eq Œπ] (w : Œπ ‚Üí ‚Ñù) : (quadratic_form.weighted_sum_squares ‚Ñù w).isometry (quadratic_form.weighted_sum_squares ‚Ñù (real.sign ‚àò w))
(K : Type u_1) (V : Type u_2) [field K] [add_comm_group V] [module K V] [finite_dimensional K V] : V ‚âÉ‚Çó[K] module.dual K (module.dual K V)
{R : Type u_1} [semiring R] : has_mul (nat.arithmetic_function R)
{Œ± : Type u_1} {Œ≤ : Type u_2} {rŒ± : Œ± ‚Üí Œ± ‚Üí Prop} {rŒ≤ : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : Œ± ‚Üí Œ≤) (fib : relation.fibration rŒ± rŒ≤ f) {a : Œ±} (ha : acc rŒ± a) : acc rŒ≤ (f a)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) {fs : finset (fin (n + 1))} {m : ‚Ñï} (h : fs.card = m + 1) : ‚Üë(‚áë((s.face h).orthogonal_projection_span) s.circumcenter) = (s.face h).circumcenter
{k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k ‚Üí E} {a b r : k} (hab : a < b) (h‚ÇÄ : 0 < r) (h‚ÇÅ : r < 1) : f (‚áë(affine_map.line_map a b) r) ‚â§ ‚áë(affine_map.line_map (f a) (f b)) r ‚Üî slope f a (‚áë(affine_map.line_map a b) r) ‚â§ slope f (‚áë(affine_map.line_map a b) r) b
{C : Type v} [category_theory.enriched_category (Type v) C] {D : Type v} [category_theory.enriched_category (Type v) D] (F G : category_theory.enriched_functor (Type v) C D) : category_theory.enriched_nat_trans_yoneda F G ‚âÖ category_theory.yoneda.obj (‚áëcategory_theory.enriched_functor_Type_equiv_functor F ‚ü∂ ‚áëcategory_theory.enriched_functor_Type_equiv_functor G)
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] (S : convex_cone ùïú E) : Prop
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} {f g : C ‚ü∂ D} (h : f = g) : homotopy f g
{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : a * b = b * a
(C : Type u‚ÇÅ) [category_theory.category C] {X Y : category_theory.thin_skeleton C} : subsingleton (X ‚ü∂ Y)
(w‚ÇÅ w‚ÇÇ z‚ÇÅ z‚ÇÇ : nnreal) (hw' : w‚ÇÅ + w‚ÇÇ = 1) {p : ‚Ñù} (hp : 1 ‚â§ p) : (w‚ÇÅ * z‚ÇÅ + w‚ÇÇ * z‚ÇÇ) ^ p ‚â§ w‚ÇÅ * z‚ÇÅ ^ p + w‚ÇÇ * z‚ÇÇ ^ p
{œÑ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ≤] (f : filter œÑ) (œï : œÑ ‚Üí Œ± ‚Üí Œ≤) (s : set Œ±) : set Œ≤
(p : ‚Ñï) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] : module (fraction_ring (witt_vector p k)) (fraction_ring (witt_vector p k))
(Œ± : Type u) [has_le Œ±] : Type u
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ≤] [comm_semiring Œ≤] (l : filter Œ±) (k f : Œ± ‚Üí Œ≤) : Prop
(M : Type u) [monoid M] (R : Type v) [semiring R] [mul_semiring_action M R] (x : M) : R ‚Üí+* R
{M : Type u_5} [add_comm_monoid M] : unique (module ‚Ñï M)
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Z‚ÇÅ Z‚ÇÇ : C} (g‚ÇÅ : Z‚ÇÅ ‚ü∂ X‚ÇÅ) (g‚ÇÇ : Z‚ÇÅ ‚ü∂ X‚ÇÇ) (g‚ÇÉ : Z‚ÇÇ ‚ü∂ X‚ÇÇ) (g‚ÇÑ : Z‚ÇÇ ‚ü∂ X‚ÇÉ) [category_theory.limits.has_pushout g‚ÇÅ g‚ÇÇ] [category_theory.limits.has_pushout g‚ÇÉ g‚ÇÑ] [category_theory.limits.has_pushout (g‚ÇÉ ‚â´ category_theory.limits.pushout.inr) g‚ÇÑ] : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (category_theory.limits.pushout.inl ‚â´ category_theory.limits.pushout.inl) (category_theory.limits.pushout.desc (category_theory.limits.pushout.inr ‚â´ category_theory.limits.pushout.inl) category_theory.limits.pushout.inr _) _)
(ùïÜ : Type u_5) (Œ± : Type u_6) [preorder ùïÜ] [preorder Œ±] : Type (max u_5 u_6)
{Œπ : Type u} (f : Œπ ‚Üí ordinal ‚Üí ordinal) (a : ordinal) : ordinal
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {Œπ‚ÇÅ : Type u_3} {s‚ÇÅ : finset Œπ‚ÇÅ} {w‚ÇÅ : Œπ‚ÇÅ ‚Üí ‚Ñù} (p‚ÇÅ : Œπ‚ÇÅ ‚Üí P) (h‚ÇÅ : s‚ÇÅ.sum (Œª (i : Œπ‚ÇÅ), w‚ÇÅ i) = 0) {Œπ‚ÇÇ : Type u_4} {s‚ÇÇ : finset Œπ‚ÇÇ} {w‚ÇÇ : Œπ‚ÇÇ ‚Üí ‚Ñù} (p‚ÇÇ : Œπ‚ÇÇ ‚Üí P) (h‚ÇÇ : s‚ÇÇ.sum (Œª (i : Œπ‚ÇÇ), w‚ÇÇ i) = 0) : has_inner.inner (‚áë(s‚ÇÅ.weighted_vsub p‚ÇÅ) w‚ÇÅ) (‚áë(s‚ÇÇ.weighted_vsub p‚ÇÇ) w‚ÇÇ) = -s‚ÇÅ.sum (Œª (i‚ÇÅ : Œπ‚ÇÅ), s‚ÇÇ.sum (Œª (i‚ÇÇ : Œπ‚ÇÇ), w‚ÇÅ i‚ÇÅ * w‚ÇÇ i‚ÇÇ * (has_dist.dist (p‚ÇÅ i‚ÇÅ) (p‚ÇÇ i‚ÇÇ) * has_dist.dist (p‚ÇÅ i‚ÇÅ) (p‚ÇÇ i‚ÇÇ)))) / 2
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_equalizers C] {X' : C} (h : X' ‚ü∂ X) [category_theory.epi h] (f : X ‚ü∂ Y) [category_theory.limits.has_image f] [category_theory.limits.has_image (h ‚â´ f)] : category_theory.epi ((category_theory.limits.image_subobject (h ‚â´ f)).of_le (category_theory.limits.image_subobject f) _)
{Œ± : Sort u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (f_inv : nonempty Œ± ‚Üí Œ≤ ‚Üí Œ±) (hf : ‚àÄ (h : nonempty Œ±), function.left_inverse (f_inv h) f) : Œ± ‚âÉ ‚Ü•(set.range f)
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] [has_add Œ≤] : Œ±·µê·µí·µñ ‚âÉ+ Œ≤·µê·µí·µñ ‚âÉ (Œ± ‚âÉ+ Œ≤)
{p : ‚Ñï} [fact (nat.prime p)] (q r : ‚Ñö_[p]) : padic_norm_e (q + r) ‚â§ linear_order.max (padic_norm_e q) (padic_norm_e r)
 : FinBoolAlg ‚•§ FinBoolAlg
 : ‚áëlinear_map.det ‚Üë(complex.conj_lie.to_linear_equiv) = -1
(Œ± : Type u_3) [has_sup Œ±] : sup_hom Œ± Œ±
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ‚Ñù P) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] {p‚ÇÅ : P} (hp‚ÇÅ : p‚ÇÅ ‚àà s) (p‚ÇÇ : P) : has_dist.dist p‚ÇÅ (‚áë(euclidean_geometry.reflection s) p‚ÇÇ) = has_dist.dist p‚ÇÅ p‚ÇÇ
 : num ‚Üí num ‚Üí ordering
{Œ± : Type u_4} {Œ≤ : Type u_5} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) : Type (max u_4 u_5)
{C : Type u} [category_theory.category C] (F G : category_theory.discrete pempty ‚•§ C) : F ‚âÖ G
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] {c : add_con M} {f : M ‚Üí N} (H : ‚àÄ (x y : M), f (x + y) = f x + f y) (h : add_con.add_ker f H ‚â§ c) (hf : function.surjective f) : c.map_gen f = c.map_of_surjective f H h hf
{R : Type u} [semiring R] {S : Type v} [semiring S] {f : R ‚Üí+* S} {p : polynomial S} (hlifts : p ‚àà polynomial.lifts f) : ‚àÉ (q : polynomial R), polynomial.map f q = p ‚àß q.degree = p.degree
(Œ± : expr) : ‚Ñ§ ‚Üí tactic expr
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {F : C ‚•§ D} [category_theory.creates_colimit K F] {c : category_theory.limits.cocone (K ‚ãô F)} (t : category_theory.limits.is_colimit c) : category_theory.limits.cocone K
(G : Type u) : Type u
{n : ‚Ñï} : group (dihedral_group n)
 : function.injective has_dvd.dvd
{X Y : Type u} [monoid X] [monoid Y] (e : X ‚âÉ* Y) : Mon.of X ‚âÖ Mon.of Y
{R : Type u_1} [comm_ring R] {c‚ÇÅ c‚ÇÇ : R} : quaternion_algebra R c‚ÇÅ c‚ÇÇ ‚âÉ‚Çê[R] (quaternion_algebra R c‚ÇÅ c‚ÇÇ)·µê·µí·µñ
{Œ± : Sort u} : Œ± ‚Üí Type
{R : Type u} [preorder R] : R ‚âÉo tropical R
{ùïú : Type u} {Œπ : Type v} {G : Type wG} {G' : Type wG'} [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] : has_norm (continuous_multilinear_map ùïú (Œª (i : Œπ), G) G')
{Œ± : Type u_1} (s : multiset Œ±) (p : Œ± ‚Üí Prop) [decidable_pred p] : multiset.count true (multiset.map p s) = ‚áëmultiset.card (multiset.filter p s)
{ùïú : Type u_1} [linear_ordered_field ùïú] [topological_space ùïú] [order_topology ùïú] {s : set ùïú} : strict_convex ùïú s ‚Üí s.ord_connected
{R : Type u_1} [rack R] (x y : R) : rack.act (shelf.act x y) = rack.act x * rack.act y * (rack.act x)‚Åª¬π
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (a b : Œ±) : Prop
 : CommRing·µí·µñ ‚•§ algebraic_geometry.PresheafedSpace CommRing
{Œ± : Type u} [decidable_eq Œ±] {Œ≤ : Œ± ‚Üí Type v} (l : list (sigma Œ≤)) : alist Œ≤
{Œ± : Type u} {Œ≤ : Type v} [complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [complete_linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] {Œπ : Sort u_1} [nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±} (Cf : continuous_at f (supr g)) (Mf : monotone f) : f (‚®Ü (i : Œπ), g i) = ‚®Ü (i : Œπ), f (g i)
{Œ± : Type u_1} {l : list Œ±} : l <:+ list.nil ‚Üí l = list.nil
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : (Œ± √ó Œ≤) √ó Œ≥ ‚âÉ Œ± √ó Œ≤ √ó Œ≥
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (e : M ‚âÉ‚Çó[R] M) (v : module.ray R M) : e ‚Ä¢ v = ‚áë(module.ray.map e) v
(m : Type u ‚Üí Type u) [monad m] [is_lawful_monad m] : category_theory.monad (Type u)
(R : Type u_1) {S : Type u_6} (M : Type u_7) [semiring R] [add_comm_monoid M] [module R M] [group S] [distrib_mul_action S M] [smul_comm_class S R M] (s : S) : M ‚âÉ‚Çó[R] M
{X : Type u_1} [topological_space X] (s : set X) : seq_closure s ‚äÜ closure s
(n : interactive.parse lean.parser.ident) (ty : interactive.parse (optional (lean.parser.tk ":" *> interactive.types.texpr))) (val : interactive.parse (optional (lean.parser.tk ":=" *> interactive.types.texpr))) : tactic unit
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommSemiRing) : category_theory.limits.cone F
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ‚ü∂ Q) : ‚Ü•P ‚Üí ‚Ü•Q
(h : expr) : tactic (expr √ó expr)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚âÉ Œ≤) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) : ‚áëf ‚Åª¬π'o s ‚âÉr s
{Œì : Type u_4} [group Œì] {T : Type u_5} [topological_space T] [mul_action Œì T] [fintype Œì] : properly_discontinuous_smul Œì T
{Œ± : Type u_1} {Œ≤ : Type u_2} (R : Œ± ‚Üí Œ≤ ‚Üí Prop) : list Œ± ‚Üí list Œ≤ ‚Üí Prop
{M : Type u_1} [add_monoid M] : add_monoid.fg M ‚Üî ‚àÉ (S : set M), add_submonoid.closure S = ‚ä§ ‚àß S.finite
{G : Type u} [group G] (X : Type u) (of : X ‚Üí G) (h : ‚àÄ {H : Type u} [_inst_5 : group H] (f : X ‚Üí H), ‚àÉ! (F : G ‚Üí* H), ‚àÄ (a : X), ‚áëF (of a) = f a) : is_free_group G
{R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group N] [module R N] [lie_ring_module L N] [lie_module R L N] (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) : lie_submodule R L M
(Œ± : Type u) : Type u
(R : Type u) [comm_ring R] : CommRing.of R ‚âÖ (algebraic_geometry.Spec.structure_sheaf R).val.obj (opposite.op ‚ä§)
{C : Type u} [category_theory.category C] [category_theory.limits.has_terminal C] (P : C) [category_theory.limits.has_binary_product P (‚ä§_ C)] : P ‚®Ø ‚ä§_ C ‚âÖ P
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] {D : Type u‚ÇÅ} [category_theory.category D] (R : C ‚•§ D) [category_theory.is_right_adjoint R] : category_theory.is_filtered D
{Œ± : Type u} {Œ≤ : Type v} [setoid Œ±] [topological_space Œ±] {f : Œ≤ ‚Üí Œ±} (hf : dense_range f) : dense_range (quotient.mk ‚àò f)
 : linter
{Œ± : Type u} [metric_space Œ±] (x : ‚Ñï ‚Üí Œ±) (H : dense_range x) : isometry (Kuratowski_embedding.embedding_of_subset x)
{Œ± : Sort u_1} [subsingleton Œ±] (a : Œ±) : unique Œ±
(R : Type u) {A : Type w} (M : Type v‚ÇÅ) [comm_semiring R] [semiring A] [algebra R A] [add_comm_monoid M] [module R M] [module A M] [is_scalar_tower R A M] : A ‚Üí‚Çê[R] module.End R M
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b : Œ±} (ha : 0 ‚â§ a) (hb : 0 < b) : 0 < a + b
(Œ± : Sort u_1) : erased Œ± ‚âÉ Œ±
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [partial_order Œπ] [order_bot Œπ] [Œ† (i : Œπ), preorder (Œ± i)] [order_bot (Œ± ‚ä•)] : order_bot (Œ£‚Çó (i : Œπ), Œ± i)
(x : interactive.parse interactive.types.texpr) : tactic unit
{Œ± : Type u_1} [decidable_eq Œ±] (s : cycle Œ±) : finset Œ±
{Œ± : Type u} [ordered_semiring Œ±] {a b c d : Œ±} [has_exists_add_of_le Œ±] (hba : b < a) (hdc : d < c) : a ‚Ä¢ d + b ‚Ä¢ c < a ‚Ä¢ c + b ‚Ä¢ d
{Œ± : Type u} [semilattice_inf Œ±] [nonempty Œ±] {s : set Œ±} (hs : s.finite) : bdd_below s
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) [decidable_rel r] (a : option Œ±) (b : Œ±) : option Œ±
{M : Type u_1} [add_monoid M] {a : M} (h : is_add_unit a) : add_units M
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] [decidable_eq Œ≤] (e : equiv.perm Œ±) (f : Œ± ‚Ü™ Œ≤) : equiv.perm Œ≤
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} : is_max_chain r (max_chain r)
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_equalizers C] [category_theory.limits.has_products C] (G : C ‚•§ D) [category_theory.limits.preserves_limits_of_shape category_theory.limits.walking_parallel_pair G] [Œ† (J : Type v), category_theory.limits.preserves_limits_of_shape (category_theory.discrete J) G] : category_theory.limits.preserves_limits G
{n : ‚Ñï} (x : bitvec n) (i : ‚Ñï) : bitvec n
(k : Type u_1) (P‚ÇÅ : Type u_2) {V‚ÇÅ : Type u_6} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] (v : V‚ÇÅ) : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÅ
{p : polynomial ‚Ñ§} (hp : p.is_primitive) : irreducible p ‚Üî irreducible (polynomial.map (int.cast_ring_hom ‚Ñö) p)
{Œ± : Type u_1} {Œ≤ : Type u_2} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {P X Y : C} (f : P ‚ü∂ X) (g : P ‚ü∂ Y) [category_theory.limits.reflects_limit (category_theory.limits.pair X Y) G] (l : category_theory.limits.is_limit (category_theory.limits.binary_fan.mk (G.map f) (G.map g))) : category_theory.limits.is_limit (category_theory.limits.binary_fan.mk f g)
{m : Type u_2} {n : Type u_3} {Œ± : Type v} {Œ≤ : Type w} [add_zero_class Œ±] [add_zero_class Œ≤] (f : Œ± ‚Üí+ Œ≤) : matrix m n Œ± ‚Üí+ matrix m n Œ≤
{Œ± : Type u} {r : Œ± ‚Üí Œ± ‚Üí Prop} {a b : Œ±} (p : Œ± ‚Üí Prop) (l : list Œ±) (h : list.chain r a l) (hb : (a :: l).last _ = b) (carries : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, r x y ‚Üí p y ‚Üí p x) (final : p b) : p a
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {f' : E ‚âÉL[ùïú] F} {s : set E} {c : nnreal} (hf : approximates_linear_on f ‚Üëf' s c) (hc : subsingleton E ‚à® c < ‚à•‚Üë(f'.symm)‚à•‚Çä‚Åª¬π) : local_equiv E F
{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] {X Y : C} : has_add (X ‚ü∂ Y)
 : algebraic_geometry.LocallyRingedSpace ‚•§ algebraic_geometry.SheafedSpace CommRing
{E : Type u_1} [add_comm_group E] [topological_space E] [has_continuous_add E] [nontrivial E] [module ‚Ñù E] [has_continuous_smul ‚Ñù E] (x : E) : (nhds_within x {x}·∂ú).ne_bot
(Œ± : Type u_2) [lattice Œ±] : Prop
 : user_attribute unit (list name √ó list projection_data)
(C : Type u) {A : Type u_1} [category_theory.category C] [add_monoid A] [category_theory.has_shift C A] (i : A) : C ‚•§ C
 : expr ‚Üí tactic bool
{D : set ‚Ñù} (hD : convex ‚Ñù D) (hD‚ÇÇ : is_open D) {f : ‚Ñù ‚Üí ‚Ñù} (hf' : differentiable_on ‚Ñù f D) (hf'' : ‚àÄ (x : ‚Ñù), x ‚àà D ‚Üí deriv^[2] f x < 0) : strict_concave_on ‚Ñù D f
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} {Œπ : Type v} (hs : is_compact s) (U : Œπ ‚Üí set Œ±) (hUo : ‚àÄ (i : Œπ), is_open (U i)) (hsU : s ‚äÜ ‚ãÉ (i : Œπ), U i) : ‚àÉ (t : finset Œπ), s ‚äÜ ‚ãÉ (i : Œπ) (H : i ‚àà t), U i
 : pgame.state pgame.domineering.board
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {a b c : Œ±} (h : ‚àÄ (a b c : Œ±), r a b ‚Üí r a c ‚Üí (‚àÉ (d : Œ±), relation.refl_gen r b d ‚àß relation.refl_trans_gen r c d)) (hab : relation.refl_trans_gen r a b) (hac : relation.refl_trans_gen r a c) : relation.join (relation.refl_trans_gen r) b c
 : Type
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] (self : category_theory.pseudofunctor B C) : category_theory.prelax_functor B C
(f : tactic.itauto.proof ‚Üí tactic.itauto.proof) : bool √ó tactic.itauto.proof √ó ‚Ñï ‚Üí bool √ó tactic.itauto.proof √ó ‚Ñï
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x y : Œ±} (h : metric.bounded s) (hx : x ‚àà s) (hy : y ‚àà s) : has_dist.dist x y ‚â§ metric.diam s
{V : Type u} [quiver V] {a b : V} : quiver.path a b ‚Üí ‚Ñï
(c : cardinal) : Prop
{C : Type u} [category_theory.category C] (ùí¢ : set C) : Prop
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [comm_ring ùïú] [add_comm_group E] [add_comm_group F] [add_comm_group G] [module ùïú E] [module ùïú F] [module ùïú G] [topological_space E] [topological_space F] [topological_space G] [topological_add_group E] [has_continuous_const_smul ùïú E] [topological_add_group F] [has_continuous_const_smul ùïú F] {n : ‚Ñï} (p : formal_multilinear_series ùïú E F) (c : composition n) (f : continuous_multilinear_map ùïú (Œª (i : fin c.length), F) G) : continuous_multilinear_map ùïú (Œª (i : fin n), E) G
(C : Type u) [category_theory.category C] {X : C} {f : X ‚ü∂ X} (hf : f ‚â´ f = f) {c : category_theory.limits.fork (ùüô X) f} (i : category_theory.limits.is_limit c) : category_theory.split_mono c.Œπ
 : category_theory.ess_surj (category_theory.forget‚ÇÇ (Module ‚Ñ§) AddCommGroup)
(Œ± : Type u) : Type u
(x : ‚Ñù) : ‚Ñù
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] {M‚ÇÅ' : Œπ ‚Üí Type u_1} [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ' i)] [Œ† (i : Œπ), module R (M‚ÇÅ' i)] (g : multilinear_map R M‚ÇÅ' M‚ÇÇ) (f : Œ† (i : Œπ), M‚ÇÅ i ‚âÉ‚Çó[R] M‚ÇÅ' i) : g.comp_linear_map (Œª (i : Œπ), ‚Üë(f i)) = 0 ‚Üî g = 0
(v : ‚Ñï ‚Üí ‚Ñ§) : omega.clause ‚Üí Prop
(a b : num) : option num
{C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X) : F.is_sheaf_opens_le_cover ‚Üî F.is_sheaf_pairwise_intersections
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_wide_pullbacks C] {A : C} (s : set (category_theory.subobject A)) : C
{Œπ : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] (p : (X ‚Üí ‚Ñù) ‚Üí Prop) (h01 : ‚àÄ (s t : set X), is_closed s ‚Üí is_closed t ‚Üí disjoint s t ‚Üí (‚àÉ (f : C(X, ‚Ñù)), p ‚áëf ‚àß set.eq_on ‚áëf 0 s ‚àß set.eq_on ‚áëf 1 t ‚àß ‚àÄ (x : X), ‚áëf x ‚àà set.Icc 0 1)) (hs : is_closed s) (U : Œπ ‚Üí set X) (ho : ‚àÄ (i : Œπ), is_open (U i)) (hf : locally_finite U) (hU : s ‚äÜ ‚ãÉ (i : Œπ), U i) : ‚àÉ (f : bump_covering Œπ X s), (‚àÄ (i : Œπ), p ‚áë(‚áëf i)) ‚àß f.is_subordinate U
(t : interactive.parse (lean.parser.pexpr std.prec.max)) (inst_name : interactive.parse (optional lean.parser.ident)) : tactic unit
{Œ± : Type u_1} [linear_ordered_field Œ±] {Œ≤ : Type u_2} [field Œ≤] {abv : Œ≤ ‚Üí Œ±} [is_absolute_value abv] : field cau_seq.completion.Cauchy
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : set_semiring A ‚Üí+* submodule R A
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : Type w) [category_theory.category J] (F : C ‚•§ D·µí·µñ) [category_theory.limits.preserves_limits_of_shape J·µí·µñ F] : category_theory.limits.preserves_colimits_of_shape J F.left_op
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_vadd Œ± Œ≤] : has_vadd Œ± (set Œ≤)
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] (h : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÇ ‚Üí M‚ÇÅ
{Œ± : Type u} [pseudo_metric_space Œ±] [complete_space Œ±] {s : ‚Ñï ‚Üí set Œ±} (hs : ‚àÄ (n : ‚Ñï), is_closed (s n)) (h's : ‚àÄ (n : ‚Ñï), metric.bounded (s n)) (h : ‚àÄ (N : ‚Ñï), (‚ãÇ (n : ‚Ñï) (H : n ‚â§ N), s n).nonempty) (h' : filter.tendsto (Œª (n : ‚Ñï), metric.diam (s n)) filter.at_top (nhds 0)) : (‚ãÇ (n : ‚Ñï), s n).nonempty
{H : Type u} [topological_space H] {G : structure_groupoid H} (M : Type u_1) [topological_space M] [charted_space H M] [has_groupoid M G] : structomorph G M M
{Œ± : Type u_1} (s : cycle Œ±) : Prop
{Œ± : Type u} : list Œ± ‚Üí lazy_list Œ±
{R : Type x} [has_mul R] [has_add R] [right_distrib_class R] (a b c : R) : (a + b) * c = a * c + b * c
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {X : category_theory.simplicial_object C} (q : ‚Ñï) : algebraic_topology.alternating_face_map_complex.obj X ‚ü∂ algebraic_topology.alternating_face_map_complex.obj X
{n m : ‚Ñï} (f : vector ‚Ñï n ‚Üí vector ‚Ñï m) : Prop
{C : Type u} [category_theory.category C] (J‚ÇÅ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : category_theory.sieve X
{Œ± : Type u_2} [has_mul Œ±] : has_mul (filter Œ±)
 : ‚Ü•unit_interval ‚Üí ‚Ü•unit_interval
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] (F G : category_theory.oplax_functor B C) : category_theory.category (F ‚ü∂ G)
{F : Type u ‚Üí Type w} {G : Type v ‚Üí Type u} [applicative F] [applicative G] {Œ± Œ≤ : Type v} : functor.comp F G (Œ± ‚Üí Œ≤) ‚Üí functor.comp F G Œ± ‚Üí functor.comp F G Œ≤
{Œ± : Type u_2} [bornology Œ±] (s : set Œ±) : Prop
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.pos_mul_mono Œ±] (ha : a < 1) (hb : b ‚â§ 1) (a0 : 0 < a) : a * b < 1
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) (q : submodule R ‚Ü•p) : ‚Ü•q ‚âÉ‚Çó[R] ‚Ü•(submodule.map p.subtype q)
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üío Œ± ‚Üío Œ≤) : Œ± ‚Üío Œ≤
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ‚Üí+* S) : R ‚Üí+* ‚Ü•(f.srange)
{Œ± : Type u} [has_subset Œ±] [has_ssubset Œ±] [is_nonstrict_strict_order Œ± has_subset.subset has_ssubset.ssubset] {a b : Œ±} (h‚ÇÅ : a ‚äÜ b) (h‚ÇÇ : ¬¨b ‚äÜ a) : a ‚äÇ b
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [comm_monoid M] {s : set Œ±} {t : set Œ≤} {f : Œ± ‚Üí M} {g : Œ≤ ‚Üí M} (e : Œ± ‚Üí Œ≤) (he‚ÇÄ : set.bij_on e s t) (he‚ÇÅ : ‚àÄ (x : Œ±), x ‚àà s ‚Üí f x = g (e x)) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)) = finprod (Œª (j : Œ≤), finprod (Œª (H : j ‚àà t), g j))
{L : first_order.language} {Œ± : Type u'} : (Œ£ (n : ‚Ñï), L.bounded_formula Œ± n) ‚Üí (Œ£ (n : ‚Ñï), L.bounded_formula Œ± n)
{Œπ : Type u_1} [fintype Œπ] [decidable_eq Œπ] (w : Œπ ‚Üí ‚ÑÇÀ£) : (quadratic_form.weighted_sum_squares ‚ÑÇ w).isometry (quadratic_form.weighted_sum_squares ‚ÑÇ 1)
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [has_zero Œ≤] (f : measure_theory.simple_func Œ± Œ≤) (s : set Œ±) : measure_theory.simple_func Œ± Œ≤
(k : Type u_1) (A : Type u_2) [comm_semiring k] [semiring A] [algebra k A] {G : Type u_3} {H : Type u_4} {F : Type u_5} [has_add G] [has_add H] [add_hom_class F G H] (f : F) : add_monoid_algebra A G ‚Üí‚Çô‚Çê[k] add_monoid_algebra A H
{Œ± : Type u_1} [preorder Œ±] [order_bot Œ±] : category_theory.limits.is_initial ‚ä•
(p : ‚Ñï) [hp : fact (nat.prime p)] : witt_vector.is_poly p (Œª (R : Type u_1) (_Rcr : comm_ring R), ‚áëwitt_vector.frobenius)
{K : Type u} (V V‚ÇÅ : Type v) [division_ring K] [add_comm_group V] [module K V] [add_comm_group V‚ÇÅ] [module K V‚ÇÅ] (cond : module.rank K V = module.rank K V‚ÇÅ) : V ‚âÉ‚Çó[K] V‚ÇÅ
(p : ‚Ñï) [p_prime : fact (nat.prime p)] {q r : ‚Ñö} (hqr : q + r ‚â† 0) (h : padic_val_rat p q ‚â§ padic_val_rat p r) : padic_val_rat p q ‚â§ padic_val_rat p (q + r)
(R : Type u) {B : Type v} [comm_ring R] [decidable_eq B] [fintype B] (A : matrix B B ‚Ñ§) : Type (max u v)
{Œ± : Type u_1} [has_le Œ±] {a : Œ±·µí·µà} : is_top a ‚Üí is_bot (‚áëorder_dual.of_dual a)
 : tactic unit
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{M : Type u_4} [comm_monoid M] {Œπ : Type u_1} [subsingleton Œπ] {s : finset Œπ} {f : Œπ ‚Üí M} {b : M} (h : s.prod (Œª (i : Œπ), f i) = b) (i : Œπ) (H : i ‚àà s) : f i = b
{x : ‚Ñù} (hx : 0 ‚â§ x) (hx' : x ‚â§ real.pi / 2) : 2 / real.pi * x ‚â§ real.sin x
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] (v : ‚Ü•K) : ‚áë(orthogonal_projection K) ‚Üëv = v
{R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} [comm_semiring R] [semiring A‚ÇÅ] [semiring A‚ÇÇ] [algebra R A‚ÇÅ] [algebra R A‚ÇÇ] {A‚ÇÅ' : Type u_1} {A‚ÇÇ' : Type u_2} [semiring A‚ÇÅ'] [semiring A‚ÇÇ'] [algebra R A‚ÇÅ'] [algebra R A‚ÇÇ'] (e‚ÇÅ : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÅ') (e‚ÇÇ : A‚ÇÇ ‚âÉ‚Çê[R] A‚ÇÇ') : (A‚ÇÅ ‚Üí‚Çê[R] A‚ÇÇ) ‚âÉ (A‚ÇÅ' ‚Üí‚Çê[R] A‚ÇÇ')
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} {p : Œπ ‚Üí P} (ha : affine_independent k p) (s : set Œπ) : affine_independent k (Œª (i : ‚Ü•s), p ‚Üëi)
 : Type
(d : declaration) : tactic (option string)
{Œ¥ : ‚Ñù} {X : Type u} [pseudo_metric_space X] {E : set X} {x : X} : x ‚àà metric.thickening Œ¥ E ‚Üî ‚àÉ (z : X) (H : z ‚àà E), has_dist.dist x z < Œ¥
{Œ± : Type u_1} [decidable_eq Œ±] {s : finset Œ±} (P : finpartition s) (G : simple_graph Œ±) [decidable_rel G.adj] : ‚Ñö
(C : Type u_1) {D : Type u_2} {E : Type u_3} [category_theory.category C] [category_theory.category D] [category_theory.category E] {F : D ‚•§ E} {G : E ‚•§ D} (adj : F ‚ä£ G) : (category_theory.whiskering_left E D C).obj G ‚ä£ (category_theory.whiskering_left D E C).obj F
{Œ± : Type u_1} (F : expr_lens ‚Üí expr ‚Üí tactic (list Œ±)) (e : expr) : tactic (list Œ±)
(e : expr) (nm‚ÇÄ : name) : native.rb_set (list name)
{ùíú : Type u_1} [category_theory.category ùíú] {A B C : ùíú} {f : A ‚ü∂ B} {g : B ‚ü∂ C} [category_theory.limits.has_zero_morphisms ùíú] [category_theory.limits.has_binary_biproducts ùíú] (h : category_theory.splitting f g) : category_theory.split_mono f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ‚Ñï} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : ‚Ñï} (h : fs.card = m + 1) : affine.simplex k P m
 : tactic.unify_equations.unification_step
{Œ± : Type u} (g : set (set Œ±)) : topological_space Œ±
{R : Type v} [ring R] {L M N K : Module R} {f : L ‚ü∂ M} {g : M ‚ü∂ N} (w : f ‚â´ g = 0) {h k : homology f g w ‚ü∂ K} (w_1 : ‚àÄ (x : ‚Ü•(linear_map.ker g)), ‚áëh (‚áë(category_theory.limits.cokernel.œÄ (image_to_kernel f g w)) (‚áëModule.to_kernel_subobject x)) = ‚áëk (‚áë(category_theory.limits.cokernel.œÄ (image_to_kernel f g w)) (‚áëModule.to_kernel_subobject x))) : h = k
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {G : D ‚•§ C} [category_theory.is_right_adjoint G] [‚àÄ (A : (category_theory.adjunction.of_right_adjoint G).to_monad.algebra), category_theory.limits.has_coequalizer ((category_theory.left_adjoint G).map A.a) ((category_theory.adjunction.of_right_adjoint G).counit.app ((category_theory.left_adjoint G).obj A.A))] : category_theory.monad.monadicity_internal.left_adjoint_comparison ‚ä£ category_theory.monad.comparison (category_theory.adjunction.of_right_adjoint G)
 : tactic unit
{p n : ‚Ñï} : padic_val_rat p ‚Üën = ‚Üë(padic_val_nat p n)
 : fin 1 ‚âÉ unit
{Œ± : Type u_1} [topological_space Œ±] (s : set Œ±) : Prop
{Œπ : Type u_1} (R : Type u_3) {M : Type u_5} (v : Œπ ‚Üí M) [semiring R] [add_comm_monoid M] [module R M] : Prop
(X : Top) (T : TopCommRing) : Top.presheaf CommRing X
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) : hb.rotation ‚Üëreal.pi = linear_isometry_equiv.neg ‚Ñù
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] : Type u_2
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] [category_theory.limits.has_colimits_of_shape J·µí·µñ C] : category_theory.limits.has_limits_of_shape J C·µí·µñ
{A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) {y : A} (h : (minpoly A x).is_root y) : ‚áë(algebra_map A B) y = x
{H : Type u} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] {G : structure_groupoid H} {e e' : local_homeomorph M H} (he : e ‚àà structure_groupoid.maximal_atlas M G) (he' : e' ‚àà structure_groupoid.maximal_atlas M G) : e.symm.trans e' ‚àà G
(C : Type u) [category_theory.category C] : Prop
{Œ± : Type u_1} [has_le Œ±] {a : Œ±} : is_max a ‚Üí is_min (‚áëorder_dual.to_dual a)
(Œ± : Type u_7) (Œ≤ : Type u_8) [has_sup Œ±] [has_sup Œ≤] : Type (max u_7 u_8)
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.initial] {E : Type u} [category_theory.category E] {G : D ‚•§ E} [category_theory.limits.has_limit (F ‚ãô G)] : category_theory.limits.has_limit G
{Œ± : Type u_1} [topological_space Œ±] [topological_space.second_countable_topology Œ±] (m : measure_theory.outer_measure Œ±) (s : set Œ±) (hs : ‚àÄ (x : Œ±), x ‚àà s ‚Üí (‚àÉ (u : set Œ±) (H : u ‚àà nhds_within x s), ‚áëm u = 0)) : ‚áëm s = 0
{J : Type u‚ÇÅ} [category_theory.category J] (j : category_theory.connected_components J) : category_theory.component j ‚•§ J
 : expr ‚Üí expr ‚Üí expr
 : tactic unit
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {P Q R S : C} [category_theory.projective P] (h : P ‚ü∂ R) (f : Q ‚ü∂ R) (g : R ‚ü∂ S) (hfg : category_theory.exact f g) (w : h ‚â´ g = 0) : P ‚ü∂ Q
{Œ± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : filter Œ±} : (‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ, 0 < c ‚Üí asymptotics.is_O_with c l f g) ‚Üí f =o[l] g
{Œ± : Type u_1} (m : set Œ± ‚Üí ennreal) (m_empty : m ‚àÖ = 0) : measure_theory.outer_measure Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F F' : C ‚•§ D} {G G' : D ‚•§ C} (adj1 : F ‚ä£ G) (adj2 : F' ‚ä£ G') (l : F ‚âÖ F') : G ‚âÖ G'
(Œ± : Type u_1) (Œ≤ : Type u_2) [topological_space Œ±] [topological_space Œ≤] [add_group Œ≤] [topological_add_group Œ≤] : add_subgroup (Œ± ‚Üí Œ≤)
{G : Type u_1} [group G] {H : subgroup G} (hH : H.index ‚â† 0) : fintype (G ‚ß∏ H)
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M ‚Üí+ P} (hg : ‚àÄ (y : ‚Ü•S), is_add_unit (‚áëg ‚Üëy)) : N ‚Üí+ P
{ùïÇ : Type u_6} [is_R_or_C ùïÇ] {E' : Type u_7} [normed_group E'] [normed_space ùïÇ E'] {F' : Type u_8} [normed_group F'] [normed_space ùïÇ F'] [complete_space E'] {f : E' ‚Üí F'} {f' : E' ‚âÉL[ùïÇ] F'} {a : E'} {n : with_top ‚Ñï} (hf : cont_diff_at ùïÇ n f a) (hf' : has_fderiv_at f ‚Üëf' a) (hn : 1 ‚â§ n) : F' ‚Üí E'
{Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_linear_order Œ±] {b : Œ±} [nonempty Œπ] {f : Œπ ‚Üí Œ±} (h : b < supr f) : ‚àÉ (i : Œπ), b < f i
(ùïú : Type u_1) {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] [complete_space F] (f : E ‚Üí F) : is_open {x : E | analytic_at ùïú f x}
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X Y : C) : category_theory.limits.mono_factorisation 0
{P L : Type u} [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] (h : fintype.card P = fintype.card L) : configuration.has_points P L
{Œ± : Type u} [decidable_eq Œ±] [fintype Œ±] {P : equiv.perm Œ± ‚Üí Prop} (f : equiv.perm Œ±) : P 1 ‚Üí (‚àÄ (f : equiv.perm Œ±) (x y : Œ±), x ‚â† y ‚Üí P f ‚Üí P (equiv.swap x y * f)) ‚Üí P f
 : linter
{C : Type v} [category_theory.small_category C] (X : C·µí·µñ) : category_theory.limits.colimit (category_theory.coyoneda.obj X) ‚âÖ punit
(L : first_order.language) (M : Type w) [L.Structure M] : L.Theory
(L : Type u_1) (F : Type u_2) [field F] [field L] [algebra F L] (f : polynomial F) (hf : f ‚â† 0) : (adjoin_root f ‚Üí‚Çê[F] L) ‚âÉ {x // x ‚àà (polynomial.map (algebra_map F L) f).roots}
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [densely_ordered Œ±] {a b : Œ±} : is_preconnected (set.Icc a b)
(f : ‚Ñù ‚Üí ‚Ñù) {a b : ‚Ñù} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfI : f a = f b) : ‚àÉ (c : ‚Ñù) (H : c ‚àà set.Ioo a b), is_local_extr f c
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F F' : C ‚•§ D} (iso : F ‚âÖ F') {X : C} {Y : D} : (F.obj X ‚ü∂ Y) ‚âÉ (F'.obj X ‚ü∂ Y)
{G : Type u_1} [add_group G] (H : add_subgroup G) : ‚Ü•H ‚Üí+ G
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : has_coe_to_fun (GL n R) (Œª (_x : GL n R), n ‚Üí n ‚Üí R)
 : game ‚Üí game ‚Üí Prop
{n : ‚Ñï} {G : Type u} [add_comm_group G] (I‚ÇÄ : box_integral.box (fin (n + 1))) (i : fin (n + 1)) (f : ‚Ñù ‚Üí box_integral.box (fin n) ‚Üí G) (fb : ‚Ü•(set.Icc (I‚ÇÄ.lower i) (I‚ÇÄ.upper i)) ‚Üí box_integral.box_additive_map (fin n) G ‚Üë(I‚ÇÄ.face i)) (hf : ‚àÄ (x : ‚Ñù) (hx : x ‚àà set.Icc (I‚ÇÄ.lower i) (I‚ÇÄ.upper i)) (J : box_integral.box (fin n)), f x J = ‚áë(fb ‚ü®x, hx‚ü©) J) : box_integral.box_additive_map (fin (n + 1)) G ‚ÜëI‚ÇÄ
(prf : expr) : expr ‚Üí tactic expr
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] : chain_complex.single‚ÇÄ V ‚âÖ homological_complex.single V (complex_shape.down ‚Ñï) 0
(eqs : list omega.term) : omega.eqelim unit
(opt : tactic.solve_by_elim.basic_opt) (original_goals : list expr) (lemmas : list (tactic expr)) (ctx : tactic (list expr)) : ‚Ñï ‚Üí tactic unit
{G : Type u_1} [group G] (H : subgroup G) (hnc : normalizer_condition G) (hmax : is_coatom H) : H.normal
{C : Type u} [category_theory.category C] {n : ‚Ñï} {f : ulift (fin (n + 1)) ‚Üí C} (c‚ÇÅ : category_theory.limits.fan (Œª (i : ulift (fin n)), f {down := i.down.succ})) (c‚ÇÇ : category_theory.limits.binary_fan (f {down := 0}) c‚ÇÅ.X) : category_theory.limits.fan f
{Œ± : Type u_1} (r s : Œ± ‚Üí Œ± ‚Üí Prop) (h : ‚àÄ (x y : Œ±), r x y ‚Üí s x y) : quot r ‚Üí quot s
 : LinearOrder ‚âå LinearOrder
(n : ‚Ñï) (R : Type u_1) [ring R] : polynomial R
(Œ± : Type u_13) (M : Type u_14) [has_zero M] : Type (max u_13 u_14)
{œÑ : Type u_1} [add_monoid œÑ] [topological_space œÑ] [has_continuous_add œÑ] {Œ± : Type u_2} [topological_space Œ±] (œï : flow œÑ Œ±) {s : set Œ±} (h : is_invariant ‚áëœï s) : flow œÑ ‚Ü•s
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M ‚Üí* P} {T : submonoid P} (hy : ‚àÄ (y : ‚Ü•S), ‚áëg ‚Üëy ‚àà T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} {A : Type u_5} [comm_monoid A] {U : submonoid A} {R : Type u_6} [comm_monoid R] (j : U.localization_map R) {l : P ‚Üí* A} (hl : ‚àÄ (w : ‚Ü•T), ‚áël ‚Üëw ‚àà U) (x : N) : ‚áë(k.map hl j) (‚áë(f.map hy k) x) = ‚áë(f.map _ j) x
{Œ± : Type u_1} (R : Œ± ‚Üí Œ± ‚Üí Prop) [decidable_rel R] : Œ± ‚Üí list Œ± ‚Üí list Œ±
{P : Type u_1} [preorder P] (s t : order.pfilter P) (h : ‚Üës = ‚Üët) : s = t
{Œ± : Type u_1} [linear_ordered_field Œ±] {a b : Œ±} (ha : 0 < a) (hb : 0 < b) : a‚Åª¬π ‚â§ b ‚Üî b‚Åª¬π ‚â§ a
{R : Type u} {M : Type v} {Œπ : Type w} [semiring R] [add_comm_monoid M] {module_M : module R M} (p : submodule R M) (x : Œπ ‚Üí ‚Ü•p) (s : finset Œπ) : ‚Üë(s.sum (Œª (i : Œπ), x i)) = s.sum (Œª (i : Œπ), ‚Üë(x i))
(Œ± : Type u_1) : Type u_1
{X : Type u_1} [topological_space X] {R : Type u_5} [has_zero R] {U : set X} (f : locally_constant X R) (hU : is_clopen U) : locally_constant X R
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] : (reflection K).symm = reflection K
(R : Type u_1) {A : Type u_3} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : Type v‚ÇÅ
{C : Type u‚ÇÅ} [category_theory.category C] : category_theory.category C·µí·µñ
{C : Type u} [category_theory.category C] (F : category_theory.limits.walking_parallel_pair ‚•§ C) : F ‚âÖ category_theory.limits.parallel_pair (F.map category_theory.limits.walking_parallel_pair_hom.left) (F.map category_theory.limits.walking_parallel_pair_hom.right)
(d : declaration) : option (list ‚Ñï)
(Œ± : Type u_1) [partial_order Œ±] [order_bot Œ±] : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} (e : local_equiv Œ± Œ≤) (e' : local_equiv Œ≥ Œ¥) : local_equiv (Œ± √ó Œ≥) (Œ≤ √ó Œ¥)
{Œ± : Type u_1} {Œ≤ : Type u_2} (t : Œ± ‚Üí set Œ≤) (x : Œ£ (i : Œ±), ‚Ü•(t i)) : ‚Ü•‚ãÉ (i : Œ±), t i
{Œ± : Type u_1} [has_mul Œ±] (s : set Œ±) (a b : Œ±) : Prop
{G : Type u_1} [group G] {s : set G} : (subgroup.normal_closure s).normal
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} [comm_ring R] [lie_ring L‚ÇÅ] [lie_algebra R L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÇ] (h : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : L‚ÇÅ ‚Üí L‚ÇÇ
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} {L‚ÇÉ : Type w‚ÇÅ} [comm_ring R] [lie_ring L‚ÇÅ] [lie_algebra R L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÇ] [lie_ring L‚ÇÉ] [lie_algebra R L‚ÇÉ] (f : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÉ) (g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÉ
{M : Type u_1} {R : Type u_4} [non_unital_non_assoc_semiring R] [set_like M R] [mul_mem_class M R] {S : M} {a b : R} (ha : a ‚àà S) (hb : b ‚àà add_submonoid.closure ‚ÜëS) : a * b ‚àà add_submonoid.closure ‚ÜëS
{Œ± : Type u} {Œ≤ : Type v} [partial_order Œ±] [preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : galois_connection l u) (a : Œ±) : (‚àÉ (b : Œ≤), a = u b) ‚Üî a = u (l a)
(Œ± : Type u_1) [fintype Œ±] [category_theory.small_category Œ±] [category_theory.fin_category Œ±] : category_theory.fin_category.as_type Œ± ‚•§ category_theory.fin_category.obj_as_type Œ±
{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {Œπ : Sort u_2} (p : Œπ ‚Üí submodule R M) {C : Œ† (x : M), (x ‚àà ‚®Ü (i : Œπ), p i) ‚Üí Prop} (hp : ‚àÄ (i : Œπ) (x : M) (H : x ‚àà p i), C x _) (h0 : C 0 _) (hadd : ‚àÄ (x y : M) (hx : x ‚àà ‚®Ü (i : Œπ), p i) (hy : y ‚àà ‚®Ü (i : Œπ), p i), C x hx ‚Üí C y hy ‚Üí C (x + y) _) {x : M} (hx : x ‚àà ‚®Ü (i : Œπ), p i) : C x hx
{M‚ÇÄ : Type u_1} [mul_zero_one_class M‚ÇÄ] (h : 0 = 1) : unique M‚ÇÄ
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (P : Prop) [decidable P] (a b : Œ±) (c d : Œ≤) : f (ite P a b) (ite P c d) = ite P (f a c) (f b d)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (p : Œπ ‚Üí P) : P
{Œπ : Type u_1} {Œ± : Type u_3} {Œ≤ : Type u_4} [preorder Œ±] [preorder Œ≤] (f : Œπ ‚Üí Œ±) (g : Œπ ‚Üí Œ≤) : Prop
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : category_theory.prod.swap C D ‚ãô category_theory.prod.swap D C ‚âÖ ùü≠ (C √ó D)
{R : Type u} [ring R] {J : Type w} [category_theory.category J] (F : J ‚•§ Module R) : setoid (Module.colimits.prequotient F)
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) : Top.glue_data
(M : Type u) (R : Type v) [monoid M] [semiring R] : Type (max u v)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G H : J ‚•§ C} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) : category_theory.limits.cocones.precompose (Œ± ‚â´ Œ≤) ‚âÖ category_theory.limits.cocones.precompose Œ≤ ‚ãô category_theory.limits.cocones.precompose Œ±
{X : Type u_1} [topological_space X] {x y : X} (Œ≥ : path x y) : continuous Œ≥.extend
{Œ± : Type} {m : Type ‚Üí Type} [monad m] (e : expr) (a : Œ±) (fn : expr ‚Üí ‚Ñï ‚Üí Œ± ‚Üí m Œ±) : m Œ±
(Œ± : Type u_2) [has_Sup Œ±] : Sup_hom Œ± Œ±
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [linear_ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : strict_concave_on ùïú s f) {x y z : E} (hx : x ‚àà s) (hy : y ‚àà s) (hxy : x ‚â† y) (hz : z ‚àà open_segment ùïú x y) : linear_order.min (f x) (f y) < f z
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚âÉ‚Çú Œ≤) : topological_space.compacts Œ± ‚âÉ topological_space.compacts Œ≤
(L : first_order.language) (M : Type u_3) (N : Type u_4) [L.Structure M] [L.Structure N] : Type (max u_3 u_4)
{R : Type u_1} {A : Type u_2} {B : Type u_3} {S : Type u_4} [comm_semiring R] [semiring A] [semiring B] [comm_semiring S] [algebra R A] [algebra R B] [algebra R S] (f : A ‚Üí‚Çê[R] S) (g : B ‚Üí‚Çê[R] S) : tensor_product R A B ‚Üí‚Çê[R] S
{Œ± : Type u_1} [decidable_eq Œ±] (s : multiset Œ±) (a : Œ±) : multiset Œ±
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (i : D ‚•§ C) [category_theory.limits.has_finite_products C] [category_theory.cartesian_closed C] (h : ‚àÄ (B : D) (A : C), (category_theory.exp A).obj (i.obj B) ‚àà i.ess_image) : category_theory.exponential_ideal i
{Œ± : Type u_2} {Œ≤ : Type u_4} [topological_space Œ±] [has_zero Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b : Œ±} (ha : 0 ‚â§ a) (hb : 0 ‚â§ b) : 0 ‚â§ a + b
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] : (M ‚Üí‚Çô* N) ‚âÉ (M·µê·µí·µñ ‚Üí‚Çô* N·µê·µí·µñ)
{Œ± : Type u} (m : measure_theory.outer_measure Œ±) : measurable_space Œ±
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {t : category_theory.limits.cofork f g} (hs : ‚àÄ (s : category_theory.limits.cofork f g), ‚àÉ! (d : t.X ‚ü∂ s.X), t.œÄ ‚â´ d = s.œÄ) : category_theory.limits.is_colimit t
(Œ± : Sort u) : Œ± ‚âÉ empty ‚âÉ is_empty Œ±
{Œ± : Type u} (l : stream Œ±) : wseq Œ±
{R : Type u_1} {M : Type u_2} {N : Type u_3} {P : Type u_4} [comm_semiring R] [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] (f : M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] P) (p : submodule R M) (q : submodule R N) : submodule R P
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (f : M ‚Üí* P) (hf : function.surjective ‚áëf) : (con.ker f).quotient ‚âÉ* P
{R : Type u} [ring R] (s : subsemiring R) (hneg : -1 ‚àà s) : subring R
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] (f : L.hom M N) : L.substructure N
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] : {a // p a} ‚äï {a // ¬¨p a} ‚âÉ Œ±
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_group E] [has_scalar ùïú E] (S : convex_cone ùïú E) (h‚ÇÅ : S.pointed) : preorder E
(Œ± : Type u_1) [encodable Œ±] : Type
(e : environment) (test : declaration ‚Üí bool) : list declaration
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] {D : J ‚•§ T.algebra} (c : category_theory.limits.cocone (D ‚ãô T.forget)) (t : category_theory.limits.is_colimit c) [category_theory.limits.preserves_colimit (D ‚ãô T.forget) ‚ÜëT] [category_theory.limits.preserves_colimit ((D ‚ãô T.forget) ‚ãô ‚ÜëT) ‚ÜëT] : T.algebra
{Œ± : Type u} {Œπ : Sort x} {f : Œπ ‚Üí Œ±} [h : unique Œπ] : set.range f = {f inhabited.default}
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ‚Üî nontrivial V
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] : preorder (Œ± ‚Üío Œ≤)
(ùïú : Type u_5) (ùïú' : Type u_6) [normed_field ùïú] [normed_field ùïú'] [normed_algebra ùïú ùïú'] (E : Type u_7) [semi_normed_group E] [normed_space ùïú' E] : normed_space ùïú E
{R : Type u_1} [ring R] (S : subring R) : subalgebra ‚Ñ§ R
{m : Type u_1 ‚Üí Type u_2} {n : Type u_1 ‚Üí Type u_3} [has_monad_lift_t m n] {Œ± : Type u_1} : has_coe (m Œ±) (n Œ±)
(a : ‚Ñï) (p : linarith.pcomp) (comps : native.rb_set linarith.pcomp) : native.rb_set linarith.pcomp
{Œ± : Type u} (s : set (set Œ±)) (hs : (filter.generate s).sets = s) : filter Œ±
{n : ‚Ñï} {x : ‚Ñï √ó ‚Ñï} : x ‚àà multiset.nat.antidiagonal n ‚Üî x.fst + x.snd = n
{Œ± : Type u_1} {M : Type u_5} {N : Type u_6} [comm_monoid M] [comm_monoid N] {s : set Œ±} (f : Œ± ‚Üí M) (g : M ‚Üí* N) (hs : s.finite) : ‚áëg (finprod (Œª (j : Œ±), finprod (Œª (H : j ‚àà s), f j))) = finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), ‚áëg (f i)))
(C : Type u‚ÇÅ) [category_theory.category C] : C ‚•§ C
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_image f] : category_theory.limits.is_image (category_theory.limits.image.mono_factorisation f)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) (l : list (Œ£ (a : Œ±), Œ≤ a)) : bool
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (Œ∏ : real.angle) : ‚áëlinear_equiv.det (hb.rotation Œ∏).to_linear_equiv = 1
{n : ‚Ñï} {Œ± : typevec n} {F : typevec n ‚Üí Type v} [mvfunctor F] (p : Œ±.arrow (typevec.repeat n Prop)) : F Œ± ‚Üí Prop
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 p3 : P) : p1 -·µ• p2 + (p2 -·µ• p3) = p1 -·µ• p3
(n : ‚Ñï) : has_neg (fin n)
{Œ± : Type u} [has_inv Œ±] [has_sup Œ±] : has_abs Œ±
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [comm_monoid N] {f g : Œ± ‚Üí‚ÇÄ M} {h : Œ± ‚Üí M ‚Üí N} (h_zero : ‚àÄ (a : Œ±), a ‚àà f.support ‚à™ g.support ‚Üí h a 0 = 1) (h_add : ‚àÄ (a : Œ±), a ‚àà f.support ‚à™ g.support ‚Üí ‚àÄ (b‚ÇÅ b‚ÇÇ : M), h a (b‚ÇÅ + b‚ÇÇ) = h a b‚ÇÅ * h a b‚ÇÇ) : (f + g).prod h = f.prod h * g.prod h
 : option expr ‚Üí tactic expr
(X : algebraic_geometry.Scheme) : Prop
{Œπ : Type u} (f : Œπ ‚Üí ordinal) : bdd_above (set.range f)
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 : P) : -(p1 -·µ• p2) = p2 -·µ• p1
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_images C] (f : X ‚ü∂ Y) [category_theory.limits.has_pullbacks C] : category_theory.mono_over.exists f ‚ä£ category_theory.mono_over.pullback f
{Œ± : Type u_1} {M : Type u_4} [has_one M] {s : set Œ±} {f : Œ± ‚Üí M} {a : Œ±} (h : s.mul_indicator f a ‚â† 1) : a ‚àà s
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (Œ± : F ‚ü∂ G) [category_theory.is_iso Œ±] (X : C) : category_theory.is_iso (Œ±.app X)
{X Y : Type u} [monoid X] [monoid Y] : X ‚âÉ* Y ‚âÖ Mon.of X ‚âÖ Mon.of Y
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) : Type (max v u)
 : cardinal.ord ‚àò cardinal.aleph' = ordinal.enum_ord {b : ordinal | b.card.ord = b}
{G : Type u_6} [add_group G] {H : Type u_1} [add_group H] (f : G ‚Üí H) (map_div : ‚àÄ (a b : G), f (a + -b) = f a + -f b) : G ‚Üí+ H
(h : expr) : tactic bool
{n : Type u_3} {R : Type u_7} {Œ± : Type v} [non_unital_non_assoc_semiring Œ±] [fintype n] [monoid R] [distrib_mul_action R Œ±] [is_scalar_tower R Œ± Œ±] : is_scalar_tower R (matrix n n Œ±) (matrix n n Œ±)
{Œ± : Type u} {Œ≤ : Type v} {Œ¥ : Type w} (f : Œ± ‚Üí Œ≤ ‚Üí Œ¥) (s‚ÇÅ : stream Œ±) (s‚ÇÇ : stream Œ≤) : stream Œ¥
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), add_comm_group (A i)] [has_add Œπ] [direct_sum.gnon_unital_non_assoc_semiring A] : non_unital_non_assoc_ring (direct_sum Œπ (Œª (i : Œπ), A i))
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {l : filter Œ±} {a : Œ±} : is_extr_filter (‚áëorder_dual.to_dual ‚àò f) l a ‚Üí is_extr_filter f l a
(C : Type u) [category_theory.category C] : Prop
{Œ≤ : Type u_6} {Œ≥ : Type u_7} {m m0 : measurable_space Œ≤} (hm : m ‚â§ m0) (f : measure_theory.simple_func Œ≤ Œ≥) : measure_theory.simple_func Œ≤ Œ≥
{n d : ‚Ñï} (hnd : d ‚à£ n) : (n / d).totient = (finset.filter (Œª (k : ‚Ñï), n.gcd k = d) (finset.range n)).card
{X Y : AddGroup} : ‚Ü•X ‚âÉ+ ‚Ü•Y ‚âÖ X ‚âÖ Y
{Œ± : Type u} {Œ≤ : Type v} [non_unital_ring Œ±] [has_zero Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ≤), f (-x) = -f x) (sub : ‚àÄ (x y : Œ≤), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (gsmul : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_unital_ring Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.initial_mono_class C] {B : C} : ‚Üë‚ä• ‚âÖ ‚ä•_ C
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] {a b c : Œ±} (hc : c ‚â† 0) : a * c ‚à£ b * c ‚Üî a ‚à£ b
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≤' : Type u_4} {Œ≥ : Type u_5} {Œ¥ : Type u_7} [decidable_eq Œ≤'] [decidable_eq Œ≥] [decidable_eq Œ¥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s : finset Œ±} {t : finset Œ≤} {g : Œ≥ ‚Üí Œ¥} {f' : Œ± ‚Üí Œ≤' ‚Üí Œ¥} {g' : Œ≤ ‚Üí Œ≤'} (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' a (g' b)) : finset.image g (finset.image‚ÇÇ f s t) = finset.image‚ÇÇ f' s (finset.image g' t)
{J : Type v} {C : Type u} [category_theory.category C] (F : category_theory.limits.walking_parallel_family J ‚•§ C) : F ‚âÖ category_theory.limits.parallel_family (Œª (j : J), F.map (category_theory.limits.walking_parallel_family.hom.line j))
{Œ± : Type u} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_partial_order Œ± r] : ‚àÉ (s : Œ± ‚Üí Œ± ‚Üí Prop) (_x : is_linear_order Œ± s), r ‚â§ s
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommMon) : category_theory.limits.cocone F
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (app : Œ† (X : C), F.obj X ‚âÖ G.obj X) (naturality : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), F.map f ‚â´ (app Y).hom = (app X).hom ‚â´ G.map f) : F ‚âÖ G
{S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)
(f : circle_deg1_lift) (hf : continuous ‚áëf) : ‚àÉ (x : ‚Ñù), ‚áëf x = x + f.translation_number
(Œ± : Sort u_1) {Œ≤ : Sort u_2} [fin_enum Œ±] (h : Œ≤ ‚âÉ Œ±) : fin_enum Œ≤
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí Œ± ‚Üí Œ±
{Œ± : Type u_1} (S : set (set Œ±)) : set (set Œ±)
(Œ± : Type u) : Type u
{X : Type v} [topological_space X] [locally_compact_space X] [sigma_compact_space X] [t2_space X] : paracompact_space X
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Ü™ Œ≤) : finset Œ± ‚Ü™o finset Œ≤
{Œ± : Type u_1} [encodable Œ±] : encodable (ulift Œ±)
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s : set Œ±} {a : Œ±} (H : is_greatest s a) : has_Sup.Sup s = a
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : collinear k {p}
 : cardinal.mk ‚ÑÇ = cardinal.continuum
{Œ± : Type u_1} (f : Œ± ‚Üí Œ±) : list Œ± ‚Üí list Œ±
 : first_order.language.graph.Theory
(h : expr) (hs : expr_set) : tactic bool
(M : Type u) [monoid M] : Mon
{Œ± : Type u_1} [subtraction_comm_monoid Œ±] (n : ‚Ñ§) : Œ± ‚Üí+ Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) : local_homeomorph Œ≤ Œ±
{K : Type u} [field K] {s : set K} {p : K ‚Üí Prop} {x : K} (h : x ‚àà subfield.closure s) (Hs : ‚àÄ (x : K), x ‚àà s ‚Üí p x) (H1 : p 1) (Hadd : ‚àÄ (x y : K), p x ‚Üí p y ‚Üí p (x + y)) (Hneg : ‚àÄ (x : K), p x ‚Üí p (-x)) (Hinv : ‚àÄ (x : K), p x ‚Üí p x‚Åª¬π) (Hmul : ‚àÄ (x y : K), p x ‚Üí p y ‚Üí p (x * y)) : p x
{Œ± : Type u_1} [linear_order Œ±] {s : finset Œ±} {k : ‚Ñï} (h : s.card = k) {f : fin k ‚Üí Œ±} (hfs : ‚àÄ (x : fin k), f x ‚àà s) (hmono : strict_mono f) : f = ‚áë(s.order_emb_of_fin h)
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà ‚àÖ), f i)) = 0
{R : Type u} [comm_ring R] (f : polynomial R) : polynomial R ‚Üí+* adjoin_root f
{V : Type u_1} {Œ± : Type u_2} [mul_zero_one_class Œ±] [nontrivial Œ±] {A : matrix V V Œ±} (h : A.is_adj_matrix) [decidable_eq Œ±] : simple_graph.adj_matrix Œ± h.to_graph = A
{Œ± : Type u_2} [decidable_eq Œ±] [subtraction_monoid Œ±] : subtraction_monoid (finset Œ±)
{m : ‚Ñï} : bitvec m ‚Üí ‚Ñï ‚Üí bitvec m
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_group Œ±] (a : Œ±) [add_action Œ± Œ≤] (b : Œ≤) : ‚Ü•(add_action.orbit ‚Ü•(add_subgroup.zmultiples a) b) ‚âÉ zmod (function.minimal_period (has_vadd.vadd a) b)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] : ùü≠ (category_theory.triangulated.triangle C) ‚âÖ category_theory.triangulated.rotate C ‚ãô category_theory.triangulated.inv_rotate C
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [finite_dimensional ùïú E] {K : submodule ùïú E} {n : ‚Ñï} (h_dim : finite_dimensional.finrank ùïú ‚Ü•K + n = finite_dimensional.finrank ùïú E) : finite_dimensional.finrank ùïú ‚Ü•K·óÆ = n
{L R : list pgame} : fin L.length ‚âÉ (pgame.of_lists L R).left_moves
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {G : D ‚•§ C} [category_theory.is_right_adjoint G] (B : D) : category_theory.limits.cofork ((category_theory.left_adjoint G).map (G.map ((category_theory.adjunction.of_right_adjoint G).counit.app B))) ((category_theory.adjunction.of_right_adjoint G).counit.app ((category_theory.left_adjoint G).obj (G.obj B)))
{R : Type u_1} [comm_ring R] {n : Type u_3} [fintype n] [decidable_eq n] (P : matrix n n R) (h : invertible P) : (n ‚Üí R) ‚âÉ‚Çó[R] n ‚Üí R
{Œ± : Type u_3} {Œ≤ : Type u_4} [lattice Œ±] [lattice Œ≤] [bounded_order Œ±] [bounded_order Œ≤] : has_coe_to_fun (bounded_lattice_hom Œ± Œ≤) (Œª (_x : bounded_lattice_hom Œ± Œ≤), Œ± ‚Üí Œ≤)
{Œ± : Type u_1} {Œ≤ : Type u_2} (e e' : local_equiv Œ± Œ≤) : Prop
(hs : list expr) (is : expr_set) : tactic (list bool)
 : pythagorean_triple 0 0 0
{R : Type u} [semiring R] (p : polynomial R) : Prop
{M : Type u} [monoid M] (x : M) (n : ‚Ñï) (hx : x ^ n.succ = 1) : invertible x
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : differentiable_on ‚Ñù f (interior D)) (hf'_mono : strict_mono_on (deriv f) (interior D)) : strict_convex_on ‚Ñù D f
 : expr ‚Üí tactic expr
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V‚ÇÇ : Type v'} [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] [h : finite_dimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ) : finite_dimensional K ‚Ü•(f.range)
{m : Type u ‚Üí Type u} [monad m] {Œ± Œ≤ : Type u} (f : Œ± ‚Üí m Œ≤) : tactic.mllist m Œ± ‚Üí tactic.mllist m Œ≤
{Œ± : Type u_1} [decidable_eq Œ±] (ùíú : finset (finset Œ±)) : finset (finset Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {B A : C} (f : A ‚ü∂ B) [category_theory.mono f] (X : category_theory.subobject B) (h : category_theory.subobject.mk f ‚â§ X) : A ‚ü∂ ‚ÜëX
{Œπ : Type u_1} {A : Œπ ‚Üí Type u_2} (i : Œπ) : A i ‚Üí graded_monoid A
{C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ‚Ñï} {i : fin (n + 2)} {j : fin (n + 1)} (H : i ‚â§ ‚áëfin.cast_succ j) : X.œÉ j.succ ‚â´ X.Œ¥ (‚áëfin.cast_succ i) = X.Œ¥ i ‚â´ X.œÉ j
{Œ± : Type u_1} {m : measurable_space Œ±} {M : Type u_3} [add_comm_monoid M] [topological_space M] {R : Type u_4} [semiring R] [module R M] [has_continuous_const_smul R M] [has_continuous_add M] (i : set Œ±) : measure_theory.vector_measure Œ± M ‚Üí‚Çó[R] measure_theory.vector_measure Œ± M
(n : ‚Ñï) : Type (u+1)
(max_var : ‚Ñï) (comps : native.rb_set linarith.pcomp) : linarith.linarith_monad unit
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±] (a b : Œ±) : filter.comap coe (nhds_within b (set.Iio b)) = filter.at_top
 : expr ‚Üí bool
(Œ≤ : Type v) (Œ± : Type u_1) [add_group Œ±] [add_action Œ± Œ≤] : Œ± ‚Üí+ additive (equiv.perm Œ≤)
{Œ± Œ≤ : Type} (t : Œ± ‚Üí tactic Œ≤) : list Œ± ‚Üí tactic Œ≤
{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 ‚Üí R} (h : is_coprime (p 0) (p 1)) : p ‚â† 0
{C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n m : ‚Ñï} (h : n = m) : X.obj (simplex_category.mk n) ‚âÖ X.obj (simplex_category.mk m)
{a b : ‚Ñù} (m n : ‚Ñï) : ‚à´ (x : ‚Ñù) in a..b, real.sin x ^ m * real.cos x ^ (2 * n + 1) = ‚à´ (u : ‚Ñù) in real.sin a..real.sin b, u ^ m * (1 - u ^ 2) ^ n
{n : Type u} [decidable_eq n] [fintype n] {Œ± : Type v} [comm_ring Œ±] (A : matrix n n Œ±) (b : n ‚Üí Œ±) : ‚áë(A.cramer) b = A.adjugate.mul_vec b
(n : ‚Ñï) : (n + 1) * (n + 1).central_binom = 2 * (2 * n + 1) * n.central_binom
{Œπ : Type u_1} {R : Type u_2} {Œ± : Type u_3} {S : Type u_4} [set_like S R] [monoid R] [add_monoid Œπ] (A : Œπ ‚Üí S) [set_like.graded_monoid A] (fŒπ : Œ± ‚Üí Œπ) (fA : Œ† (a : Œ±), ‚Ü•(A (fŒπ a))) (l : list Œ±) : ‚Üë(l.dprod fŒπ fA) = (list.map (Œª (a : Œ±), ‚Üë(fA a)) l).prod
{C : Type u} [ùíû : category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [category_theory.limits.has_colimit (category_theory.limits.pair Y Z)] [category_theory.limits.has_colimit (category_theory.limits.parallel_pair (f ‚â´ category_theory.limits.coprod.inl) (g ‚â´ category_theory.limits.coprod.inr))] : category_theory.limits.has_colimit (category_theory.limits.span f g)
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x : V} (hx : x ‚â† 0) (Œ∏ : real.angle) : hb.oangle (‚áë(hb.rotation Œ∏) x) x = -Œ∏
(h : interactive.parse (optional lean.parser.ident)) (_x : interactive.parse (lean.parser.tk ":")) (p : interactive.parse generalize_arg_p) : tactic unit
{Œ± : Type u_1} : sym2 Œ± ‚Üí Prop
{Œπ : Type u_1} (M : Œπ ‚Üí Type u_2) [Œ† (j : Œπ), has_mul (M j)] [subsingleton Œπ] (i : Œπ) : (Œ† (j : Œπ), M j) ‚âÉ* M i
{Œ≤ : Type v} {Œ≥ : Type u_1} [topological_space Œ≤] [topological_space Œ≥] {Œπ : Type u_2} {Œ∫ : Type u_3} {f : Œπ ‚Üí Œ≤} {g : Œ∫ ‚Üí Œ≥} (hf : dense_range f) (hg : dense_range g) : dense_range (prod.map f g)
{Œ≥ : Type w} [semilattice_inf Œ≥] (a : Œ≥) {s : set Œ≥} : bdd_below (has_insert.insert a s) ‚Üî bdd_below s
(X Y : algebraic_geometry.LocallyRingedSpace) : Type u_1
(G : Type u_1) [add_comm_monoid G] : ‚Ü•(add_comm_monoid.add_torsion ‚Ü•(add_comm_monoid.add_torsion G)) ‚âÉ+ ‚Ü•(add_comm_monoid.add_torsion G)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.preadditive C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} {P : category_theory.ProjectiveResolution Y} {Q : category_theory.ProjectiveResolution Z} (f : P.complex ‚ü∂ Q.complex) (comm : f ‚â´ Q.œÄ = 0) : P.complex.X 0 ‚ü∂ Q.complex.X 1
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) : Œ± ‚Üí Œ≤
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} (H : C ‚•§ D) {E : K ‚•§ J} {c : category_theory.limits.cocone F} : H.map_cocone (category_theory.limits.cocone.whisker E c) ‚âÖ category_theory.limits.cocone.whisker E (H.map_cocone c)
 : vm_obj ‚Üí name
(l : interactive.parse interactive.types.pexpr_list_or_texpr) : tactic unit
{R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Œπ : Type u_1} (v : Œπ ‚Üí M) (i : linear_independent R v) (w : set M) [fintype ‚Ü•w] (s : set.range v ‚â§ ‚Üë(submodule.span R w)) : cardinal.mk Œπ ‚â§ ‚Üë(fintype.card ‚Ü•w)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] : category_theory.preadditive_yoneda ‚ãô (category_theory.whiskering_right C·µí·µñ AddCommGroup (Type v)).obj (category_theory.forget AddCommGroup) = category_theory.yoneda
{R : Type u} [comm_semiring R] {A : Type v‚ÇÅ} [semiring A] [algebra R A] {B : Type v‚ÇÇ} [semiring B] [algebra R B] : R ‚Üí+* tensor_product R A B
{Œ± : Type u} [pseudo_emetric_space Œ±] {Œ¥ : ‚Ñù} {s : set Œ±} {x : Œ±} : emetric.inf_edist x s ‚â§ emetric.inf_edist x (metric.thickening Œ¥ s) + ennreal.of_real Œ¥
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {Œπ : Type u_3} {t : finset Œπ} {f : Œπ ‚Üí L} (h : ‚àÄ (c : Œπ), c ‚àà t ‚Üí f c ‚àà S) : t.sum (Œª (i : Œπ), f i) ‚àà S
{Œπ : Type u_1} {E : Type u_3} [semi_normed_group E] {f : Œπ ‚Üí E} (hf : summable (Œª (i : Œπ), ‚à•f i‚à•‚Çä)) : ‚à•‚àë' (i : Œπ), f i‚à•‚Çä ‚â§ ‚àë' (i : Œπ), ‚à•f i‚à•‚Çä
(n : Type u) (R : Type v) [decidable_eq n] [fintype n] [comm_ring R] : Type (max u v)
{m : Type ‚Üí Type u_1} [monad m] {key val : Type} [has_lt key] [decidable_rel has_lt.lt] (P : key ‚Üí val ‚Üí m bool) (s : native.rb_map key val) : m (native.rb_map key val)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : Type w) [category_theory.category J] (F : C ‚•§ D) [category_theory.limits.preserves_colimits_of_shape J·µí·µñ F] : category_theory.limits.preserves_limits_of_shape J F.op
 : lean.parser tactic.rcases_patt
{C : Type u} [category_theory.category C] : category_theory.Monad.Monad_to_Mon C ‚ãô category_theory.Monad.Mon_to_Monad C ‚ü∂ ùü≠ (category_theory.monad C)
{M : Type u_1} {Œ± : Type u_6} {Œ≤ : Type u_7} [monoid M] [mul_action M Œ±] [has_scalar M Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.surjective f) (smul : ‚àÄ (c : M) (x : Œ±), f (c ‚Ä¢ x) = c ‚Ä¢ f x) : mul_action M Œ≤
{C : Type u} [category_theory.category C] {X Y : C} {J : category_theory.grothendieck_topology C} (S : J.cover X) (f : Y ‚ü∂ X) : J.cover Y
{a b : ordinal} (h : b ‚â† 0) : {o : ordinal | a < b * order.succ o}.nonempty
{Œ± : Type u_1} [decidable_eq Œ±] (P : finset Œ± ‚Üí finset Œ± ‚Üí Prop) (symm : ‚àÄ {a b : finset Œ±}, P a b ‚Üí P b a) (empty_right : ‚àÄ {a : finset Œ±}, P a ‚àÖ) (singletons : ‚àÄ {a b : Œ±}, P {a} {b}) (union_of : ‚àÄ {a b c : finset Œ±}, P a c ‚Üí P b c ‚Üí P (a ‚à™ b) c) (a b : finset Œ±) : P a b
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Ü™ Œ≤} {s : finset Œ±} : s.nonempty ‚Üí (finset.map f s).nonempty
{C : Type u} [category_theory.category C] (Ps : set (C·µí·µñ ‚•§ Type v)) (J : category_theory.grothendieck_topology C) (hJ : ‚àÄ (P : C·µí·µñ ‚•§ Type v), P ‚àà Ps ‚Üí category_theory.presieve.is_sheaf J P) : J ‚â§ category_theory.sheaf.finest_topology Ps
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {A : Mon_ C} (M : Mod A) : M.hom M
(Œ± : Type u_6) (Œ≤ : Type u_7) [has_top Œ±] [has_top Œ≤] : Type (max u_6 u_7)
{R : Type u_3} {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] {Œπ : Type u_1} {f : Œπ ‚Üí A} (hf : function.injective f) : algebraic_independent R coe ‚Üí algebraic_independent R f
(R : Type u) (A : Type v) (B : Type w) [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B] : A √ó B ‚Üí‚Çô‚Çê[R] A
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (u : E) {v : E} (hv : has_inner.inner u v = 0) : v ‚àà (submodule.span ùïú {u})·óÆ
(M : Type u_1) (X : Type u_2) [has_vadd M X] [topological_space M] [topological_space X] : Prop
{Œπ : Type u_1} {R : Type u_2} {M : Type u_4} [ring R] [add_comm_group M] [module R M] [fintype Œπ] (Q : quadratic_form R M) (v : basis Œπ R M) : Q.isometry (Q.basis_repr v)
 : tactic unit
(n : ‚Ñï) : (nat.fib n).coprime (nat.fib (n + 1))
(k : Type u_1) [division_ring k] {Œπ : Type u_4} (s : finset Œπ) [char_zero k] (h : s.nonempty) : s.sum (Œª (i : Œπ), finset.centroid_weights k s i) = 1
(R : Type u) (S‚ÇÅ : Type v) [comm_semiring R] : mv_polynomial (option S‚ÇÅ) R ‚âÉ‚Çê[R] polynomial (mv_polynomial S‚ÇÅ R)
{Œ± : Type u_1} {Œ≤ : Type u_2} : Œ± √ó Œ≤ ‚Üí (Œ£ (_x : Œ±), Œ≤)
{M : Type u_3} [monoid M] [preorder M] [covariant_class M M (function.swap has_mul.mul) has_le.le] [covariant_class M M has_mul.mul has_le.le] {l‚ÇÅ l‚ÇÇ : list M} (h : l‚ÇÅ <+ l‚ÇÇ) (h‚ÇÅ : ‚àÄ (a : M), a ‚àà l‚ÇÇ ‚Üí 1 ‚â§ a) : l‚ÇÅ.prod ‚â§ l‚ÇÇ.prod
{Œ± : Sort u} : unique (unique Œ±) ‚âÉ unique Œ±
{Œ± : Type u} [group Œ±] [fintype Œ±] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : fintype.card Œ± = p) : is_simple_group Œ±
{Œ± Œ≤ : Sort u_1} (h : Œ± = Œ≤) : Œ± ‚âÉ Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] (G : category_theory.comonad C) : ‚ÜëG ‚ü∂ ùü≠ C
{X : Type u_1} (a : free_abelian_group X) : finset X
{Œ± : Type u_1} : ordnode Œ± ‚Üí Prop
 : computability.encoding ‚Ñï
(X : Type u) (Y : Type v) [topological_space X] [topological_space Y] : Type (max u v)
(f : bool ‚Üí bool) (x : bool) : f (f (f x)) = f x
 : decidable_eq ‚Ñï+
(p : ‚Ñï) (R : Type u_1) [hp : fact (nat.prime p)] [comm_ring R] [invertible ‚Üëp] : witt_vector p R ‚âÉ+* (‚Ñï ‚Üí R)
(no_defaults : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (t : tactic.interactive.itactic) : tactic.interactive.itactic
{Œ± : Type u} [partial_order Œ±] {a b : Œ±} : a ‚â§ b ‚Üí b ‚â§ a ‚Üí b = a
{Œ± : Type u} (t : tactic Œ±) : tactic unit
 : ereal ‚âÉ‚Çú ereal
{M : Type u_1} [add_group M] (c : add_con M) : has_sub c.quotient
 : Type u ‚•§ PartialFun
{n : ‚Ñï} {Œ± : Type u_1} [linear_order Œ±] {f : fin n ‚Üí Œ±} : ‚Ü•(tuple.graph f) ‚Üí Œ±
 : tactic.alias.target ‚Üí string
{œÑ : Type u_1} {Œ± : Type u_2} (œï : œÑ ‚Üí Œ± ‚Üí Œ±) (s : set Œ±) : Prop
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cocone F.op} (P : category_theory.limits.is_colimit t) : category_theory.limits.is_limit t.unop
{Œ± : Type u_1} {Œ≤ : Type u_2} (p : pmf Œ±) (f : Œ± ‚Üí pmf Œ≤) : pmf Œ≤
{Œ± : Sort u} [i : Œ±] : Œ±
{n : ‚Ñï} : zmod n ‚Üí ‚Ñï
{G : Type u_1} [group G] : normalizer_condition G ‚Üî ‚àÄ (H : subgroup G), H.normalizer = H ‚Üí H = ‚ä§
{Œ± : Type u_1} (p : pmf Œ±) : set Œ±
{R : Type u} [ring R] : category_theory.limits.preserves_limits_of_size (category_theory.forget (Module R))
{C : Type u} [category_theory.category C] : Mon_ (C ‚•§ C) ‚Üí category_theory.monad C
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] (hC : category_theory.skeletal C) : comm_monoid C
{C : Type u} [category_theory.category C] (F : C·µí·µñ ‚•§ Type v) : (category_theory.category_of_elements.to_costructured_arrow F).right_op ‚ãô category_theory.category_of_elements.from_costructured_arrow F = ùü≠ F.elements
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : C √ó (C ‚•§ D) ‚•§ D
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} (c : Œ±) : metric.bounded s ‚Üî ‚àÉ (r : ‚Ñù), s ‚äÜ metric.closed_ball c r
{Œ± : Type u_2} [add_comm_monoid Œ±] : add_comm_monoid (filter Œ±)
{Œ± : Type u_1} [partial_order Œ±] (f : Œ± ‚Üí Œ±) (hf‚ÇÅ : monotone f) (hf‚ÇÇ : ‚àÄ (x : Œ±), x ‚â§ f x) (hf‚ÇÉ : ‚àÄ (x : Œ±), f (f x) ‚â§ f x) : closure_operator Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G : J ‚•§ C} (Œ± : F ‚ü∂ G) : category_theory.limits.cone F ‚•§ category_theory.limits.cone G
(R : Type u) [ring R] : galois_insertion subring.closure coe
 : (Œ£ (k l : ‚Ñï), {s // s.card = l}) ‚âÉ Œ£ (n : ‚Ñï), finset (fin n)
{n : Type u_3} {Œ± : Type v} (v : n ‚Üí Œ±) : matrix unit n Œ±
(hs : list expr) : tactic (‚Ñï √ó list expr)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [normed_comm_ring ùïú] [add_comm_monoid E] [add_comm_monoid F] [module ùïú E] [module ùïú F] (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú) (s : set E) : is_closed (B.polar s)
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] [decidable_eq R] (s : finset S) : finset R
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] {C : Type u‚ÇÑ} [category_theory.category C] (F : C ‚•§ A) (L : A ‚•§ T) (R : B ‚•§ T) : category_theory.comma (F ‚ãô L) R ‚•§ category_theory.comma L R
{Œ± : Type u} [pseudo_emetric_space Œ±] {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) (E : set Œ±) : E ‚äÜ metric.thickening Œ¥ E
{d : ‚Ñï} : ‚Ñ§‚àö‚Üëd ‚Üí Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.limits.preserves_limit (category_theory.limits.cospan f g) G] : category_theory.limits.preserves_limit (category_theory.limits.cospan g f) G
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] {s : finset V} (hs : s.nonempty) (lin_ind : linear_independent K coe) (card_eq : s.card = finite_dimensional.finrank K V) : basis ‚Ü•s K V
(A : Type u_1) [comm_ring A] [algebra ‚Ñö A] : power_series A
{V : Type u_1} [inner_product_space ‚Ñù V] (x y : V) {r : ‚Ñù} (hr : 0 < r) : inner_product_geometry.angle (r ‚Ä¢ x) y = inner_product_geometry.angle x y
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
{R : Type u} [ring R] {M N : Module R} (f : M ‚ü∂ N) : category_theory.limits.is_colimit (Module.cokernel_cocone f)
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (n : with_top ‚Ñï) (f : E ‚Üí F) (s : set E) (x : E) : Prop
{X Y : Type u} (f : X ‚ü∂ Y) : category_theory.mono f ‚Üî function.injective f
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] [category_theory.limits.has_limits_of_shape J C] (F : K ‚•§ J ‚•§ C) : category_theory.limits.limit F.flip ‚âÖ F ‚ãô category_theory.limits.lim
{C : Type u} [category_theory.category C] {P Q : C} (f : P ‚ü∂ Q) : Prop
{C : Type u} [category_theory.category C] [‚àÄ (n : ‚Ñï) (f : category_theory.arrow C), category_theory.limits.has_wide_pushout f.left (Œª (i : ulift (fin (n + 1))), f.right) (Œª (i : ulift (fin (n + 1))), f.hom)] : category_theory.arrow C ‚•§ category_theory.cosimplicial_object C
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] [preorder Œ±] [preorder Œ≤] {f g : Œ≤ ‚Üí Œ±} [covariant_class Œ± Œ± has_add.add has_lt.lt] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] (hf : strict_mono f) (hg : strict_mono g) : strict_mono (Œª (x : Œ≤), f x + g x)
{G : Type u} {x : G} {n : ‚Ñï} [fintype G] [group G] : x ^ n = 1 ‚Üî x ^ n.gcd (fintype.card G) = 1
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] (J : category_theory.grothendieck_topology C) (P : C·µí·µñ ‚•§ A) : (‚àÄ (E : A), category_theory.presieve.is_separated J (P ‚ãô category_theory.coyoneda.obj (opposite.op E))) ‚Üî ‚àÄ ‚¶ÉX : C‚¶Ñ (S : category_theory.sieve X), S ‚àà ‚áëJ X ‚Üí ‚àÄ (c : category_theory.limits.cone (S.arrows.diagram.op ‚ãô P)), subsingleton (c ‚ü∂ P.map_cone S.arrows.cocone.op)
(V : Type (u+1)) [category_theory.large_category V] {G : Mon} : Action.res V (ùüô G) ‚âÖ ùü≠ (Action V G)
(tac : tactic unit) (e : expr) : tactic expr
 : Type u ‚•§ Mon
(Œ± : Type) [has_zero Œ±] [has_one Œ±] [has_add Œ±] [fintype Œ±] (fromc : char) : parser Œ±
{R : Type u_1} [comm_semiring R] {x : R} : has_star.star x = x
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] (f : A ‚Üí‚Çê[R] B) : A ‚Üí‚Çê[R] ‚Ü•(f.range)
 : has_le cardinal
(k : Type u) [field k] (n : ‚Ñï) : Type u
{R : Type u_2} [has_add R] (c : R) : Prop
{Œ± : Type u} [monoid Œ±] : Œ± ‚Üí* free_abelian_group Œ±
{Œ± : Type u_1} [pseudo_emetric_space Œ±] (C : ennreal) (hC : C ‚â† ‚ä§) {f : ‚Ñï ‚Üí Œ±} (hu : ‚àÄ (n : ‚Ñï), has_edist.edist (f n) (f (n + 1)) ‚â§ C / 2 ^ n) : cauchy_seq f
{R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) (r : R) : ‚àÉ (V : open_add_subgroup R), r ‚Ä¢ ‚ÜëV ‚äÜ ‚ÜëU
 : bool ‚âÉ punit ‚äï punit
(ic : tactic.instance_cache) (a b : expr) (na nb : ‚Ñö) : tactic (tactic.instance_cache √ó expr)
 : environment ‚Üí tactic unit
{f : ‚Ñù ‚Üí ‚Ñù} (hf : differentiable ‚Ñù f) (hf' : ‚àÄ (x : ‚Ñù), deriv f x ‚â§ 0) : antitone f
{G : Type u_1} {H : Type u_2} [add_group G] [add_group H] [is_add_cyclic H] (f : G ‚Üí+ H) (hf : f.ker ‚â§ add_subgroup.center G) (a b : G) : a + b = b + a
{M : Type u_1} [has_add M] {r : M ‚Üí M ‚Üí Prop} {c : add_con M} (h : ‚àÄ (x y : M), r x y ‚Üí setoid.r x y) : add_con_gen r ‚â§ c
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) {s‚ÇÅ s‚ÇÇ : finset Œπ} (h : s‚ÇÅ ‚äÜ s‚ÇÇ) : ‚áë(s‚ÇÅ.weighted_vsub p) w = ‚áë(s‚ÇÇ.weighted_vsub p) (‚Üës‚ÇÅ.indicator w)
{Œ± : Type u} [pseudo_metric_space Œ±] {f : Œ± ‚Üí ‚Ñù} {s : set Œ±} {K : nnreal} (hf : lipschitz_on_with K f s) : ‚àÉ (g : Œ± ‚Üí ‚Ñù), lipschitz_with K g ‚àß set.eq_on f g s
{Œ± : Type u_1} [has_one Œ±] [has_zero Œ±] [has_lt Œ±] (a : Œ±) : continued_fraction Œ±
 : first_order.language.order.Theory
(C : Type u‚ÇÅ) [category_theory.category C] : category_theory.quotient (category_theory.paths_hom_rel C) ‚•§ C
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) (X : C) [category_theory.limits.reflects_colimit (category_theory.functor.empty C) G] (l : category_theory.limits.is_initial (G.obj X)) : category_theory.limits.is_initial X
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [dec : decidable_eq Œπ] [Œ† (i : Œπ), has_zero (Œ≤ i)] (s : finset Œπ) (x : Œ† (i : ‚Ü•‚Üës), Œ≤ ‚Üëi) : Œ†‚ÇÄ (i : Œπ), Œ≤ i
{V : Type u} (G : simple_graph V) (u v : V) : Type u
{p n : ‚Ñï} (hp : nat.prime p) (hdiv : p ‚à£ n) (R : Type u_1) [comm_ring R] : ‚áë(polynomial.expand R p) (polynomial.cyclotomic n R) = polynomial.cyclotomic (n * p) R
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y z : M} (hy : same_ray R x y) (hz : same_ray R x z) : same_ray R x (y + z)
{C : Type v‚ÇÅ} [category_theory.small_category C] {D : Type v‚ÇÅ} [category_theory.small_category D] (A : Type u‚ÇÇ) [category_theory.category A] (J : category_theory.grothendieck_topology C) (K : category_theory.grothendieck_topology D) [category_theory.concrete_category A] [category_theory.limits.preserves_limits (category_theory.forget A)] [category_theory.limits.has_colimits A] [category_theory.limits.has_limits A] [category_theory.limits.preserves_filtered_colimits (category_theory.forget A)] [category_theory.reflects_isomorphisms (category_theory.forget A)] (G : C ‚•§ D) : category_theory.Sheaf J A ‚•§ category_theory.Sheaf K A
(K : Type u_1) (V : Type u_2) [field K] [add_comm_group V] [module K V] : ‚Ñô K V ‚âÉ {H // finite_dimensional.finrank K ‚Ü•H = 1}
(n : ‚Ñï) (f : C(‚Ü•unit_interval, ‚Ñù)) : C(‚Ü•unit_interval, ‚Ñù)
{K : Type u_1} {n : ‚Ñï} {g : generalized_continued_fraction K} [division_ring K] {m : ‚Ñï} (m_lt_n : m < n) : (g.squash_gcf (n + 1)).s.nth m = g.s.nth m
{p : ‚Ñï} [hp : fact (nat.prime p)] {n : ‚Ñï} (hn : 0 < n) : padic_val_nat p n = (multiplicity p n).get _
{M : Type u_1} [comm_monoid M] (c : con M) : comm_monoid c.quotient
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] : ùü≠ (category_theory.triangulated.triangle C) ‚ü∂ category_theory.triangulated.rotate C ‚ãô category_theory.triangulated.inv_rotate C
{V : Type u} (G : simple_graph V) (v w : V) : set V
{Œ± : Sort u_1} {s‚ÇÅ : setoid Œ±} : function.surjective quotient.mk'
{X Y : Type u} [add_group X] [add_group Y] (f : X ‚Üí+ Y) : AddGroup.of X ‚ü∂ AddGroup.of Y
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] (h : is_smul_regular M 0) : subsingleton M
{Œ± : Type u_1} : option (option Œ±) ‚Üí option Œ±
 : tactic unit ‚Üí tactic unit
(e : environment) : list declaration
{G : Type u_1} [group G] (H : subgroup G) [hG : group.is_nilpotent G] : group.is_nilpotent ‚Ü•H
{Œ± : Type u_1} (x : Œ±) : free_add_monoid Œ±
{M : Type u_1} [semigroup M] (a : stream M) (s : set (set M)) (sfin : s.finite) (scov : hindman.FP a ‚äÜ ‚ãÉ‚ÇÄs) : ‚àÉ (c : set M) (H : c ‚àà s) (b : stream M), hindman.FP b ‚äÜ c
(s : simp_lemmas) (e : expr) : tactic (expr √ó expr)
(e : environment) (nm : name) : bool
(Œ± : Type u_1) [complete_lattice Œ±] (k : Œ±) : complete_lattice.is_compact_element k ‚Üî ‚àÄ (s : set Œ±), s.nonempty ‚Üí directed_on has_le.le s ‚Üí k ‚â§ has_Sup.Sup s ‚Üí (‚àÉ (x : Œ±), x ‚àà s ‚àß k ‚â§ x)
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : free_semigroup Œ± ‚Üí free_semigroup Œ≤
(R : Type u) {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [is_empty Œπ] (m : M‚ÇÇ) : multilinear_map R M‚ÇÅ M‚ÇÇ
(old new : name) : tactic unit
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] {Œπ : Type u_3} (s : finset Œπ) (f : Œπ ‚Üí S) (i : ‚Ü•s) : R
 : format ‚Üí format ‚Üí format
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) [category_theory.limits.has_colimit F] : category_theory.limits.cocone F
{Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) : Type u_2
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] {G : Type u_4} [add_comm_group G] [module R G] (g : F ‚Üí‚Çó[R] G) (f : linear_pmap R E F) : linear_pmap R E G
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] {X Y : C} (f : X ‚ü∂ Y) (Z : C) (l : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ 0 _)) : category_theory.mono f
{R : Type u‚ÇÅ} [semiring R] (r : R ‚Üí R ‚Üí Prop) : R ‚Üí R ‚Üí Prop
(n : ‚Ñï) : option ‚Ñï
{Œ± : Type u_1} [linear_order Œ±] [pred_order Œ±] [is_pred_archimedean Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) {n m : Œ±} (h1 : ‚àÄ (i : Œ±), i ‚àà set.Ioc m n ‚Üí r i (order.pred i)) (h2 : ‚àÄ (i : Œ±), i ‚àà set.Ioc n m ‚Üí r (order.pred i) i) (hnm : n ‚â† m) : relation.trans_gen r n m
(R : Type u_1) [semiring R] : R ‚âÉ+* module.End R·µê·µí·µñ R
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : category_theory.arrow C ‚•§ category_theory.arrow D
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] [normed_group G] [normed_space ùïú G] {g : F ‚Üí G} {f : E ‚Üí F} {q : formal_multilinear_series ùïú F G} {p : formal_multilinear_series ùïú E F} {x : E} (hg : has_fpower_series_at g q (f x)) (hf : has_fpower_series_at f p x) : has_fpower_series_at (g ‚àò f) (q.comp p) x
{Œ± Œ≤ : ordinal} (h : Œ± ‚â§ Œ≤) : initial_seg has_lt.lt has_lt.lt
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] {t : category_theory.limits.trident f} (ht : category_theory.limits.is_limit t) (Z : C) : (Z ‚ü∂ t.X) ‚âÉ {h // ‚àÄ (j‚ÇÅ j‚ÇÇ : J), h ‚â´ f j‚ÇÅ = h ‚â´ f j‚ÇÇ}
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p1 p3 p2) (hpi : euclidean_geometry.angle p2 p1 p3 ‚â† real.pi) : has_dist.dist p1 p2 = has_dist.dist p1 p3
(k : Type u‚ÇÅ) (G : Type u‚ÇÇ) [semiring k] [has_add G] : multiplicative G ‚Üí‚Çô* add_monoid_algebra k G
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) [category_theory.creates_colimit K F] [category_theory.limits.has_colimit (K ‚ãô F)] : category_theory.limits.preserves_colimit K F
{p : ‚Ñï} [fact (nat.prime p)] {R : Type u‚ÇÅ} [comm_semiring R] [char_p R p] {P : Type u‚ÇÉ} [comm_semiring P] [char_p P p] [perfect_ring P p] {f : P ‚Üí+* R} (g : P ‚âÉ+* ring.perfection R p) (hfg : ‚áë(perfection.lift p P R) f = ‚Üëg) : perfection_map p f
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ≤] {f : Œ± ‚Üí Œ≤} [topological_space Œ±] (L : ‚àÄ (x : Œ±) (u : set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí (‚àÉ (t : set Œ±) (H : t ‚àà nhds x) (F : Œ± ‚Üí Œ≤), continuous_at F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u)) : continuous f
(n : ‚Ñï) : Type
{R : Type u_1} [comm_semiring R] {A : Type u_2} [comm_semiring A] [algebra R A] {M : Type u_3} [add_cancel_comm_monoid M] [module R M] [module A M] (D : A ‚Üí‚Çó[R] M) (h : ‚àÄ (a b : A), ‚áëD (a * b) = a ‚Ä¢ ‚áëD b + b ‚Ä¢ ‚áëD a) : derivation R A M
{q : ‚Ñï+} (i : ‚Ñï) : ‚Üë(lucas_lehmer.s i) = lucas_lehmer.X.œâ ^ 2 ^ i + lucas_lehmer.X.œâb ^ 2 ^ i
{Œ± : Type u_1} [preorder Œ±] {a : Œ±} [no_max_order Œ±] : nonempty ‚Ü•(set.Ioi a)
{Œ± : Type u} [pseudo_metric_space Œ±] (f : ‚Ñï ‚Üí Œ±) {m n : ‚Ñï} (h : m ‚â§ n) : has_dist.dist (f m) (f n) ‚â§ (finset.Ico m n).sum (Œª (i : ‚Ñï), has_dist.dist (f i) (f (i + 1)))
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {x : E} {n : with_top ‚Ñï} {s : set E} {f g : E ‚Üí F} (hf : cont_diff_within_at ùïú n f s x) (hg : cont_diff_within_at ùïú n g s x) : cont_diff_within_at ùïú n (Œª (x : E), f x + g x) s x
{Œ± : Type u_1} {Œ±' : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_5} {Œ¥ : Type u_7} [decidable_eq Œ±'] [decidable_eq Œ≥] [decidable_eq Œ¥] {s : finset Œ±} {t : finset Œ≤} {f : Œ±' ‚Üí Œ≤ ‚Üí Œ≥} {g : Œ± ‚Üí Œ±'} {f' : Œ± ‚Üí Œ≤ ‚Üí Œ¥} {g' : Œ¥ ‚Üí Œ≥} (h_left_comm : ‚àÄ (a : Œ±) (b : Œ≤), f (g a) b = g' (f' a b)) : finset.image‚ÇÇ f (finset.image g s) t = finset.image g' (finset.image‚ÇÇ f' s t)
{ùïú : Type u} [nondiscrete_normed_field ùïú] {E : Type v} [normed_group E] [normed_space ùïú E] {F : Type w} [normed_group F] [normed_space ùïú F] [complete_space ùïú] [finite_dimensional ùïú E] [finite_dimensional ùïú F] : nonempty (E ‚âÉL[ùïú] F) ‚Üî finite_dimensional.finrank ùïú E = finite_dimensional.finrank ùïú F
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] (S : submodule K V) : finite_dimensional K ‚Ü•S
{ùïú : Type u_1} {E : Type u} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] {s : set E} {x : E} (hx : x ‚àà ‚áë(convex_hull ùïú) s) : ‚àÉ (Œπ : Type u) (_x : fintype Œπ) (z : Œπ ‚Üí E) (w : Œπ ‚Üí ùïú) (hss : set.range z ‚äÜ s) (hai : affine_independent ùïú z) (hw : ‚àÄ (i : Œπ), 0 < w i), finset.univ.sum (Œª (i : Œπ), w i) = 1 ‚àß finset.univ.sum (Œª (i : Œπ), w i ‚Ä¢ z i) = x
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) : category_theory.limits.cocone F
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.simple Y] {f : X ‚ü∂ Y} [category_theory.mono f] (w : f ‚â† 0) : category_theory.is_iso f
{Œ± : Type u_1} (s : set Œ±) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (Œπ : Type u_1) [unique Œπ] : finite_dimensional.finrank K V = 1 ‚Üî nonempty (basis Œπ K V)
(Œ± : Type u_1) : Type u_1
(x : pgame) : (0 + x).equiv x
(R : Type u_1) (A : Type u_2) [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A] : submodule R A
{Œ± : Type u} [pseudo_emetric_space Œ±] (Œ¥ : ‚Ñù) {E‚ÇÅ E‚ÇÇ : set Œ±} (h : E‚ÇÅ ‚äÜ E‚ÇÇ) : metric.cthickening Œ¥ E‚ÇÅ ‚äÜ metric.cthickening Œ¥ E‚ÇÇ
{R‚ÇÅ : Type u_4} [comm_ring R‚ÇÅ] {n : Type w} [fintype n] [decidable_eq n] (M : matrix n n R‚ÇÅ) : quadratic_form R‚ÇÅ (n ‚Üí R‚ÇÅ)
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [linear_ordered_add_comm_monoid_with_top Œì‚ÇÄ] [ring R] (f : R ‚Üí Œì‚ÇÄ) (h0 : f 0 = ‚ä§) (h1 : f 1 = 0) (hadd : ‚àÄ (x y : R), linear_order.min (f x) (f y) ‚â§ f (x + y)) (hmul : ‚àÄ (x y : R), f (x * y) = f x + f y) : add_valuation R Œì‚ÇÄ
{R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M ‚Üí‚Çó[R] M) : polynomial R
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [mul_zero_class Œ≤] : mul_zero_class Œ±
{Œ± : Type u} [non_unital_non_assoc_semiring Œ±] : ulift Œ± ‚âÉ+* Œ±
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [fintype Œπ] [decidable_eq Œπ] [Œ† (i : Œπ), decidable_eq (Œ± i)] [Œ† (i : Œπ), linear_order (Œ± i)] {p : (Œ† (i : Œπ), finset (Œ± i)) ‚Üí Prop} (f : Œ† (i : Œπ), finset (Œ± i)) (h0 : p (Œª (_x : Œπ), ‚àÖ)) (step : ‚àÄ (g : Œ† (i : Œπ), finset (Œ± i)) (i : Œπ) (x : Œ± i), (‚àÄ (y : Œ± i), y ‚àà g i ‚Üí y < x) ‚Üí p g ‚Üí p (function.update g i (has_insert.insert x (g i)))) : p f
{J : Type v} {C : Type u} [category_theory.category C] {F : category_theory.limits.walking_parallel_family J ‚•§ C} (t : category_theory.limits.cone F) : category_theory.limits.trident (Œª (j : J), F.map (category_theory.limits.walking_parallel_family.hom.line j))
{G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)
{M : Type u_1} {A : Type u_4} {B : Type u_5} [monoid M] [add_monoid A] [distrib_mul_action M A] [add_monoid B] [has_scalar M B] (f : B ‚Üí+ A) (hf : function.injective ‚áëf) (smul : ‚àÄ (c : M) (x : B), ‚áëf (c ‚Ä¢ x) = c ‚Ä¢ ‚áëf x) : distrib_mul_action M B
{K : Type u} [hring : comm_ring K] : ratfunc K
{Œ± : Type u} [t : topological_space Œ±] (s : set Œ±) : Prop
{Œ± : Type u_2} [decidable_eq Œ±] [has_neg Œ±] : has_neg (finset Œ±)
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] (e : M ‚âÉ‚Çó[R] N) : module.ray R M ‚âÉ module.ray R N
(sl : interactive.parse tactic.simp_arg_list) (l : interactive.parse interactive.types.location) : tactic unit
(R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] : has_neg (module.ray R M)
{Œ± : Type u_1} [decidable_eq Œ±] {ùíú : finset (finset Œ±)} {s : finset Œ±} (hs : s ‚àà ùíú.shadow) : ‚àÉ (t : finset Œ±) (H : t ‚àà ùíú), s ‚äÜ t
(Œ± : Type u) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (h : F ‚âÖ G) [r : category_theory.is_right_adjoint F] : category_theory.is_right_adjoint G
{n : ‚Ñï} {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (b : Œ≤) (v : vector Œ± n) (x : Œ±) : vector.scanl f b (x::·µ•v) = b::·µ•vector.scanl f (f b x) v
{Œ≤ : Type v} [pseudo_emetric_space Œ≤] {Œ± : Type u} [emetric_space Œ±] (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) (hfg : ‚àÄ (x : Œ≤), f (g x) = x) (hf : isometry f) : Œ± ‚âÉ·µ¢ Œ≤
{ùïú : Type u_1} [field ùïú] {M : Type u_2} [add_comm_group M] [module ùïú M] (c : ùïú) (f : M ‚Üí‚Çó[ùïú] M) : ‚áëlinear_map.det (c ‚Ä¢ f) = c ^ finite_dimensional.finrank ùïú M * ‚áëlinear_map.det f
{Œ± : Type u_1} [lattice Œ±] [bounded_order Œ±] [is_simple_order Œ±] : complete_boolean_algebra Œ±
(k : Type u‚ÇÅ) (G : Type u‚ÇÇ) [semiring k] [has_mul G] : G ‚Üí‚Çô* monoid_algebra k G
(p : ‚Ñï) [hp : fact (nat.prime p)] (z : ‚Ñ§) : padic_norm p ‚Üëz ‚â§ 1
(ùïú : Type u_1) (E : Type u_2) [ordered_ring ùïú] [add_comm_group E] [module ùïú E] : Type u_2
{A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M ‚â§ non_zero_divisors A) : is_domain (localization M)
{Œ± : Type u} [non_unital_non_assoc_ring Œ±] (a b c : Œ±) : (a - b) * c = a * c - b * c
 : Type
{C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (hu : category_theory.cover_lifting J K G) (‚Ñ± : category_theory.Sheaf J A) {X : A} {U : D} {S : category_theory.sieve U} (hS : S ‚àà ‚áëK U) {x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj ‚Ñ±.val ‚ãô category_theory.coyoneda.obj (opposite.op X)) S.arrows} (hx : x.compatible) (Y : category_theory.structured_arrow (opposite.op U) G.op) : X ‚ü∂ ‚Ñ±.val.obj Y.right
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≤' : Type u_4} {Œ≥ : Type u_5} {Œ¥ : Type u_7} {f : filter Œ±} {g : filter Œ≤} {m : Œ± ‚Üí Œ≤' ‚Üí Œ≥} {n : Œ≤ ‚Üí Œ≤'} {m' : Œ≤ ‚Üí Œ± ‚Üí Œ¥} {n' : Œ¥ ‚Üí Œ≥} (h_right_anticomm : ‚àÄ (a : Œ±) (b : Œ≤), m a (n b) = n' (m' b a)) : filter.map‚ÇÇ m f (filter.map n g) = filter.map n' (filter.map‚ÇÇ m' g f)
{Œ± : Type u} (r‚ÇÅ r‚ÇÇ : set (Œ± √ó Œ±)) : set (Œ± √ó Œ±)
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] (f : ùïú ‚Üí F) (f' : F) (x : ùïú) (L : filter ùïú) : Prop
(R : Type u_1) [semiring R] (n : ‚Ñï) : R ‚Üí‚Çó[R] power_series R
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] {Z : D} (F : C ‚•§ D) (hZ : category_theory.limits.is_terminal Z) : category_theory.with_terminal.incl ‚ãô category_theory.with_terminal.lift_to_terminal F hZ ‚âÖ F
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] (P Q : C) : P ‚äû Q ‚âÖ Q ‚äû P
{Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [ring Œ≤] {f : Œ± ‚Üí Œ≤} (H : is_semiring_hom f) : is_ring_hom f
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_4} [decidable_eq Œπ] [fintype Œπ] (e : basis Œπ R M) [nontrivial R] : e.det ‚â† 0
(F : Type u) [field F] {R : Type u_1} [comm_ring R] [algebra F R] (x : R) : ‚Ü•(algebra.adjoin F {x}) ‚âÉ‚Çê[F] adjoin_root (minpoly F x)
(R : Type u) (M : Type v) (M‚ÇÇ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] : ‚Ü•(submodule.snd R M M‚ÇÇ) ‚âÉ‚Çó[R] M‚ÇÇ
{Œ± : Type u_1} [preorder Œ±] [add_comm_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b : Œ±} : a ‚â§ b ‚Üí a - b ‚â§ 0
 : local_homeomorph ‚Ñù ‚Ñù
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : C ‚•§ C ‚•§ C
{G : Type u_1} {M : Type u_3} [group G] [monoid M] [mul_distrib_mul_action G M] [smul_comm_class G M M] [is_scalar_tower G M M] : mul_distrib_mul_action G MÀ£
{Œ± : Type u_1} [pseudo_metric_space Œ±] [proper_space Œ±] (x : Œ±) (r : ‚Ñù) : compact_space ‚Ü•(metric.sphere x r)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) : ‚Ñù
{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_product X Y] : category_theory.limits.has_binary_biproduct X Y
(F : Type u_1) (Œ± : out_param (Type u_2)) (Œ≤ : out_param (Type u_3)) [topological_space Œ±] [topological_space Œ≤] : Type (max u_1 u_2 u_3)
{Œπ : Type u_1} {Œ± : Type u_3} [preorder Œπ] [preorder Œ±] {l : filter Œπ} {u : Œπ ‚Üí Œ±} (h : monotone u) [l.ne_bot] (hu : filter.tendsto u l filter.at_top) : filter.tendsto u filter.at_top filter.at_top
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [‚àÄ (i : ùí∞.J), category_theory.limits.has_pullback (ùí∞.map i ‚â´ f) g] (i j : ùí∞.J) : algebraic_geometry.Scheme.pullback.V ùí∞ f g i j ‚ü∂ category_theory.limits.pullback (ùí∞.map i ‚â´ f) g
{J : Type u} (F : J ‚Üí Type u) : category_theory.limits.colimit_cocone (category_theory.discrete.functor F)
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : R) (hx : x ‚â† 0) : v.int_valuation_def x ‚â† 0
{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] {A : C} : A ‚®Ø A ‚ü∂ A
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V
{ùïú : Type u_3} [is_R_or_C ùïú] {n m : ‚Ñï} (A B : matrix (fin n) (fin m) ùïú) (i j : fin m) : has_inner.inner (A.transpose i) (B.transpose j) = A.conj_transpose.mul B i j
 : Type
{Œ± : Type u} : has_coe_to_sort (set Œ±) (Type u)
{F : Type u_8} {G : Type u_1} {H : Type u_2} [add_group G] [add_zero_class H] [add_monoid_hom_class F G H] (f : F) : function.injective ‚áëf ‚Üî ‚àÄ (a : G), ‚áëf a = 0 ‚Üí a = 0
{F : Type u ‚Üí Type u} [functor F] [q : qpf F] {Œ± : Type u} (g : Œ± ‚Üí F Œ±) : Œ± ‚Üí (qpf.P F).M
{G : Type u_6} {H : Type u_7} {F : Type u_8} [group G] [division_monoid H] [monoid_hom_class F G H] (f : F) (a b : G) : ‚áëf (a / b) = ‚áëf a / ‚áëf b
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M ‚Üí* P} {T : submonoid P} (hy : ‚àÄ (y : ‚Ü•S), ‚áëg ‚Üëy ‚àà T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} {A : Type u_5} [comm_monoid A] {U : submonoid A} {R : Type u_6} [comm_monoid R] (j : U.localization_map R) {l : P ‚Üí* A} (hl : ‚àÄ (w : ‚Ü•T), ‚áël ‚Üëw ‚àà U) : (k.map hl j).comp (f.map hy k) = f.map _ j
 : Type
{E : Type u_2} [normed_group E] [normed_space ‚Ñù E] {r : ‚Ñù} (hr : 0 < r) (x : E) : x +·µ• r ‚Ä¢ metric.ball 0 1 = metric.ball x r
{Œ± : Type u_1} {G : Type u_4} {s : set Œ±} [subtraction_comm_monoid G] (f g : Œ± ‚Üí G) (hs : s.finite) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i - g i)) = finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)) - finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), g i))
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Type (max u‚ÇÅ v‚ÇÅ)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [comm_ring ùïú] [add_comm_group E] [add_comm_group F] [add_comm_group G] [module ùïú E] [module ùïú F] [module ùïú G] [topological_space E] [topological_space F] [topological_space G] [topological_add_group E] [has_continuous_const_smul ùïú E] [topological_add_group F] [has_continuous_const_smul ùïú F] [topological_add_group G] [has_continuous_const_smul ùïú G] {n : ‚Ñï} (q : formal_multilinear_series ùïú F G) (p : formal_multilinear_series ùïú E F) (c : composition n) : continuous_multilinear_map ùïú (Œª (i : fin n), E) G
{Œ± : Type u_1} [preorder Œ±] [decidable_rel has_lt.lt] (l : list Œ±) : with_bot Œ±
{X Y : SemiNormedGroup} (f : X ‚ü∂ Y) : SemiNormedGroup
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) [lie_algebra.is_nilpotent R ‚Ü•H] (œá : ‚Ü•H ‚Üí R) : lie_submodule R ‚Ü•H L
{Œ± : Type} {ds : list ‚Ñï} [ring Œ±] (x : holor Œ± ds) : ‚Ñï
(R : Type u_1) [comm_ring R] (c‚ÇÅ c‚ÇÇ : R) : quaternion_algebra R c‚ÇÅ c‚ÇÇ ‚Üí‚Çó[R] R
{Œ¥ : Type u_1} {Œ∫ : Œ¥ ‚Üí Type u_2} [Œ† (d : Œ¥), topological_space (Œ∫ d)] : filter.Coprod (Œª (d : Œ¥), filter.cocompact (Œ∫ d)) = filter.cocompact (Œ† (d : Œ¥), Œ∫ d)
{R : Type u_1} [normed_ring R] [complete_space R] : open_embedding coe
(v : prime_multiset) : v.prod.factor_multiset = v
{R : Type u} {Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {M‚ÇÅ' : Œπ ‚Üí Type w‚ÇÅ'} {M‚ÇÑ : Type w‚ÇÑ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ' i)] [add_comm_monoid M‚ÇÑ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [Œ† (i : Œπ), module R (M‚ÇÅ' i)] [module R M‚ÇÑ] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [Œ† (i : Œπ), topological_space (M‚ÇÅ' i)] [topological_space M‚ÇÑ] (g : continuous_multilinear_map R M‚ÇÅ' M‚ÇÑ) (f : Œ† (i : Œπ), M‚ÇÅ i ‚ÜíL[R] M‚ÇÅ' i) : continuous_multilinear_map R M‚ÇÅ M‚ÇÑ
{M : Type u_6} {N : Type u_7} [has_add M] [has_add N] (e : M ‚âÉ+ N) : N ‚Üí M
 : Type
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] (f‚ÇÄ f‚ÇÅ : C(X, Y)) (P : C(X, Y) ‚Üí Prop) : Prop
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] : is_open_map prod.snd
(a : ‚Ñ§) : ‚Ñ§
(n : ‚Ñï) : fin (n + 1) ‚Ü™ affine.simplex.points_with_circumcenter_index n
{Œ± : Type u_1} {Œ≥ : Type u_3} {Œπ : Type u_2} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí set Œ±} {f : filter Œ±} (hf : f.has_basis p s) {Œ≤ : Œπ ‚Üí Type u_4} {pg : Œ† (i : Œπ), Œ≤ i ‚Üí Prop} {sg : Œ† (i : Œπ), Œ≤ i ‚Üí set Œ≥} {g : set Œ± ‚Üí filter Œ≥} (hg : ‚àÄ (i : Œπ), (g (s i)).has_basis (pg i) (sg i)) (gm : monotone g) : (f.lift g).has_basis (Œª (i : Œ£ (i : Œπ), Œ≤ i), p i.fst ‚àß pg i.fst i.snd) (Œª (i : Œ£ (i : Œπ), Œ≤ i), sg i.fst i.snd)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ Y‚ÇÇ) (f‚ÇÇ‚ÇÅ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) [category_theory.is_iso f‚ÇÅ‚ÇÅ] [category_theory.is_iso (category_theory.biprod.of_components f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ)] : X‚ÇÇ ‚âÖ Y‚ÇÇ
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x : V) {r : ‚Ñù} (hr : 0 ‚â§ r) : hb.oangle (r ‚Ä¢ x) x = 0
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : collinear k s ‚Üî ‚àÉ (p‚ÇÄ : P) (v : V), ‚àÄ (p : P), p ‚àà s ‚Üí (‚àÉ (r : k), p = r ‚Ä¢ v +·µ• p‚ÇÄ)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J ‚Üí C) (i : J) [category_theory.limits.has_biproduct f] [category_theory.limits.has_biproduct (subtype.restrict (Œª (j : J), i ‚â† j) f)] : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ (category_theory.limits.biproduct.from_subtype f (Œª (j : J), i ‚â† j)) _)
(n m : ‚Ñï) : Prop
{Œπ : Type w} (A : Type u) {B : Type v} [comm_ring A] [comm_ring B] [algebra A B] [fintype Œπ] (b : Œπ ‚Üí B) : A
{Œ± : Type u_1} {S : finset Œ±} {g : Œ± ‚Üí ‚Ñï} (hS : ‚àÄ (x : Œ±), x ‚àà S ‚Üí g x ‚â† 0) : (S.prod g).factorization = S.sum (Œª (x : Œ±), (g x).factorization)
{V : Type u} (G : simple_graph V) : set V
{C : Type u‚ÇÅ} (X : C) : C·¥π·µí·µñ
{C : Type u} [category_theory.category C] (X : C) : category_theory.with_initial.star ‚ü∂ category_theory.with_initial.incl.obj X
{M : Type u_1} [has_add M] (r : M ‚Üí M ‚Üí Prop) : add_con_gen ‚áë(add_con_gen r) = add_con_gen r
(ùïÜ : Type u_5) (Œ± : Type u_6) [preorder ùïÜ] [preorder Œ±] : Type (max u_5 u_6)
{Œ± : Type} (m : expr ‚Üí tactic expr) (t : tactic Œ±) : tactic Œ±
 : tactic.rcases_patt ‚Üí tactic.list_Sigma tactic.rcases_patt
(Œ± : Type u_2) [has_Inf Œ±] : Inf_hom Œ± Œ±
{Œπ : Type u_1} {A : Œπ ‚Üí Type u_2} [add_monoid Œπ] [graded_monoid.ghas_mul A] [graded_monoid.ghas_one A] (n : ‚Ñï) {i : Œπ} : A i ‚Üí A (n ‚Ä¢ i)
(Œ± : fin 2 ‚Üí Type u) [Œ† (i : fin 2), preorder (Œ± i)] : (Œ† (i : fin 2), Œ± i) ‚âÉo Œ± 0 √ó Œ± 1
{R : Type u_1} [semiring R] (p : polynomial R) : polynomial R
(L : first_order.language) (L' : first_order.language) [L.is_algebraic] [L.is_relational] : L ‚Üí·¥∏ L'
{Œ± : Sort u_1} (f : Œ± ‚Üí Œ±) : Prop
 : Preorder ‚âå Preorder
 : Type
{R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] (m : M) : ‚áë(exterior_algebra.Œπ R) m * ‚áë(exterior_algebra.Œπ R) m = 0
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : stream Œ±) : stream Œ≤
{n : ‚Ñï} : (vector ‚Ñï n ‚Üí. ‚Ñï) ‚Üí Prop
{Œ± : Type u} [pseudo_emetric_space Œ±] (Œ¥ : ‚Ñù) (E : set Œ±) : set Œ±
{X Y Z : algebraic_geometry.LocallyRingedSpace} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [H : algebraic_geometry.LocallyRingedSpace.is_open_immersion f] : category_theory.limits.is_limit (algebraic_geometry.LocallyRingedSpace.is_open_immersion.pullback_cone_of_left f g)
{F : Type u_1} [normed_group F] [normed_space ‚Ñù F] {f : ‚Ñù ‚Üí F} (K : set F) : {x : ‚Ñù | differentiable_within_at ‚Ñù f (set.Ici x) x ‚àß deriv_within f (set.Ici x) x ‚àà K} ‚äÜ right_deriv_measurable_aux.D f K
{Œ≤ : Type w} {C : Type u} [category_theory.category C] {f g : Œ≤ ‚Üí C} [category_theory.limits.has_products_of_shape Œ≤ C] (p : Œ† (b : Œ≤), f b ‚âÖ g b) : ‚àè f ‚âÖ ‚àè g
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] : monoid (category_theory.skeleton C)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] : category_theory.reflects_isomorphisms (Mon_.forget C)
(m n k : ‚Ñï) : (m + n).choose k = (finset.nat.antidiagonal k).sum (Œª (ij : ‚Ñï √ó ‚Ñï), m.choose ij.fst * n.choose ij.snd)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type (max u v)} [decidable_eq Œ±] (xs : list Œ±) : (Œ† (a : Œ±), list (Œ≤ a)) ‚Üí list (Œ† (a : Œ±), a ‚àà xs ‚Üí Œ≤ a)
(Œ± : Type u_1) [topological_space Œ±] : setoid Œ±
{Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), group (Gs i)] (tfGs : ‚àÄ (i : Œ∑), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Œ† (i : Œ∑), Gs i)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) [complete_space ‚Ü•K] : (reflection K).trans (reflection K) = linear_isometry_equiv.refl ùïú E
 : nzsnum ‚Üí nzsnum
{G : Type u} [add_group G] (N : add_subgroup G) [nN : N.normal] : G ‚Üí+ G ‚ß∏ N
(p : Type u_2) (q : Type u_3) (R : Type u‚ÇÇ) [decidable_eq p] [decidable_eq q] [comm_ring R] (i : R) : matrix (p ‚äï q) (p ‚äï q) R
{Œ± : Type u_1} (x : Œ±) : slim_check.use_has_to_string Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : category_theory.monoidal_functor C (category_theory.monoidal.transported e)
{G : Type u} [add_group G] (N : add_subgroup G) [nN : N.normal] (M : add_subgroup G) [nM : M.normal] (h : N ‚â§ M) : (G ‚ß∏ N) ‚ß∏ add_subgroup.map (quotient_add_group.mk' N) M ‚Üí+ G ‚ß∏ M
{R : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_4} {Œ≥ : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10} {p : Type u_11} [comm_semiring R] [add_comm_monoid Œ±] [add_comm_monoid Œ≤] [add_comm_monoid Œ≥] [module R Œ±] [module R Œ≤] [module R Œ≥] (f : Œ± ‚Üí‚Çó[R] Œ≤ ‚Üí‚Çó[R] Œ≥) : matrix l m Œ± ‚Üí‚Çó[R] matrix n p Œ≤ ‚Üí‚Çó[R] matrix (l √ó n) (m √ó p) Œ≥
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] [‚àÄ {X Y : C} (f : X ‚ü∂ Y), category_theory.is_iso (category_theory.abelian.coimage_image_comparison f)] [category_theory.limits.has_finite_products C] : category_theory.normal_mono_category C
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí. Œ≤) (s : set Œ≤) : set Œ±
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Œπ R M) (f : M ‚Üí Œπ ‚Üí R) (hadd : ‚àÄ (x y : M), f (x + y) = f x + f y) (hsmul : ‚àÄ (c : R) (x : M), f (c ‚Ä¢ x) = c ‚Ä¢ f x) (f_eq : ‚àÄ (i : Œπ), f (‚áëb i) = ‚áë(finsupp.single i 1)) (x : M) (i : Œπ) : ‚áë(‚áë(b.repr) x) i = f x i
{K : Type u_1} [linear_ordered_field K] {c : continued_fraction K} : ‚Üëc.convergents = ‚Üëc.convergents'
{S : Type v} (s : S) {R : Type u_1} [ordered_semiring R] [set_like S R] [subsemiring_class S R] : ordered_semiring ‚Ü•s
{R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {Œπ : Type u_6} [decidable_eq Œπ] {M‚ÇÇ : Type u_7} [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] (f : alternating_map R M N Œπ) (g : M‚ÇÇ ‚âÉ‚Çó[R] M) : f.comp_linear_map ‚Üëg = 0 ‚Üî f = 0
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {v : V} (p‚ÇÅ p‚ÇÇ : P) (hv : v ‚â† 0) (r : ‚Ñù) : has_dist.dist (r ‚Ä¢ v +·µ• p‚ÇÅ) p‚ÇÇ = has_dist.dist p‚ÇÅ p‚ÇÇ ‚Üî r = 0 ‚à® r = (-2) * has_inner.inner v (p‚ÇÅ -·µ• p‚ÇÇ) / has_inner.inner v v
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a : Œ±} : a < 1 ‚Üí 1 < a‚Åª¬π
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (b : category_theory.limits.binary_bicone X Y) : category_theory.limits.is_limit b.to_bicone.to_cone ‚âÉ category_theory.limits.is_limit b.to_cone
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] (f : Œ± ‚Üí Œ≤) (H : function.bijective f) : fintype Œ≤
(K : Type u_1) [field K] [number_field K] : ‚Ñï
{Œ± : Type} (tac : tactic Œ±) : tactic (list Œ±)
(R : Type u_1) [comm_ring R] {n : ‚Ñï} (hn : 2 ‚â§ n) : (polynomial.cyclotomic n R).coeff 0 = 1
{n m : ‚Ñï} {F : typevec n ‚Üí Type u_1} [fF : mvfunctor F] {G : fin2 n ‚Üí typevec m ‚Üí Type u} [fG : Œ† (i : fin2 n), mvfunctor (G i)] {Œ± Œ≤ : typevec m} (f : Œ±.arrow Œ≤) : mvqpf.comp F G Œ± ‚Üí mvqpf.comp F G Œ≤
{X : Top} {x : ‚Ü•X} (U V : topological_space.open_nhds x) : U ‚äì V ‚ü∂ V
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : C √ó D ‚âå D √ó C
 : tactic unit
{Œ± : Type u} [emetric_space Œ±] : uniform_embedding topological_space.nonempty_compacts.to_closeds
(t : pexpr) : tactic expr
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] (v : ‚Ñï) (f : ‚Ñ§_[p] ‚Üí ‚Ñï) (f_spec : ‚àÄ (x : ‚Ñ§_[p]), x - ‚Üë(f x) ‚àà ideal.span {‚Üëv}) (f_congr : ‚àÄ (x : ‚Ñ§_[p]) (a b : ‚Ñï), x - ‚Üëa ‚àà ideal.span {‚Üëv} ‚Üí x - ‚Üëb ‚àà ideal.span {‚Üëv} ‚Üí ‚Üëa = ‚Üëb) : ‚Ñ§_[p] ‚Üí+* zmod v
{m n a b : ‚Ñï} (h : a ‚â° b [MOD n.gcd m]) : {k // k ‚â° a [MOD n] ‚àß k ‚â° b [MOD m]}
{Œ± : Type u_1} [decidable_eq Œ±] (a : Œ±) : multiset Œ± ‚Üí ‚Ñï
(n : name) : tactic.simp_arg_type
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F‚ÇÅ F‚ÇÇ : C ‚•§ D} (k : F‚ÇÅ ‚ü∂ F‚ÇÇ) : category_theory.thin_skeleton.map F‚ÇÅ ‚ü∂ category_theory.thin_skeleton.map F‚ÇÇ
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : ‚áë(v.valuation) (‚áë(algebra_map R K) r) ‚â§ 1
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) : F.is_sheaf ‚Üî F.is_sheaf_pairwise_intersections
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommMon) : category_theory.limits.cone F
{Œ± : Type u_1} (m : measure_theory.outer_measure Œ±) {s : ‚Ñï ‚Üí set Œ±} (h_mono : ‚àÄ (n : ‚Ñï), s n ‚äÜ s (n + 1)) (h0 : ‚àë' (k : ‚Ñï), ‚áëm (s (k + 1)  s k) ‚â† ‚ä§) : ‚áëm (‚ãÉ (n : ‚Ñï), s n) = ‚®Ü (n : ‚Ñï), ‚áëm (s n)
{x y z : ‚Ñ§} (h : pythagorean_triple x y z) : Prop
(Œ± : Type u) [t : topological_space Œ±] : Prop
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} [category_theory.limits.has_zero_object V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] {C‚ÇÅ C‚ÇÇ : homological_complex V c} (f : C‚ÇÅ ‚ü∂ C‚ÇÇ) (i : Œπ) : ‚Üë(C‚ÇÅ.boundaries i) ‚ü∂ ‚Üë(C‚ÇÇ.boundaries i)
{R : Type u} [comm_ring R] {J : Type v} [category_theory.small_category J] (F : J ‚•§ Algebra R) (j : J) : (category_theory.limits.types.limit_cone (F ‚ãô category_theory.forget (Algebra R))).X ‚Üí‚Çê[R] (F ‚ãô category_theory.forget (Algebra R)).obj j
{C : Type u} [category_theory.category C] : category_theory.cosimplicial_object.augmented C ‚•§ C
{M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] {R : Type u_9} {S : Type u_10} [semiring R] [semiring S] [module R M‚ÇÅ] [module R M‚ÇÇ] [module R S] [module S M‚ÇÇ] [is_scalar_tower R S M‚ÇÇ] [topological_space S] [has_continuous_smul S M‚ÇÇ] (c : M‚ÇÅ ‚ÜíL[R] S) (f : M‚ÇÇ) : M‚ÇÅ ‚ÜíL[R] M‚ÇÇ
{Œ± : Type u_1} [complete_lattice Œ±] {p q : Prop} {s : p ‚Üí q ‚Üí Œ±} : (‚®Ü (h‚ÇÅ : p) (h‚ÇÇ : q), s h‚ÇÅ h‚ÇÇ) = ‚®Ü (h : p ‚àß q), s _ _
{C : Type u‚ÇÅ} [category_theory.category C] (Z : C ‚Üí Prop) : {X // Z X} ‚•§ C
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (F : C ‚•§ D) [category_theory.ess_surj F] (Y : D) : C
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x y z : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (hz : z ‚â† 0) : hb.oangle y z + hb.oangle x y = hb.oangle x z
{Œπ : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering Œπ X s) : partition_of_unity Œπ X s
 : string ‚Üí option norm_cast.label
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} (P : category_theory.ProjectiveResolution Y) (Q : category_theory.ProjectiveResolution Z) (n : ‚Ñï) (g : P.complex.X n ‚ü∂ Q.complex.X n) (g' : P.complex.X (n + 1) ‚ü∂ Q.complex.X (n + 1)) (w : g' ‚â´ Q.complex.d (n + 1) n = P.complex.d (n + 1) n ‚â´ g) : Œ£' (g'' : P.complex.X (n + 2) ‚ü∂ Q.complex.X (n + 2)), g'' ‚â´ Q.complex.d (n + 2) (n + 1) = P.complex.d (n + 2) (n + 1) ‚â´ g'
{Œ± : Type u_1} [partial_order Œ±] (f : Œ± ‚Üí Œ±) (hf : ‚àÄ (x : Œ±), x ‚â§ f x) (hmin : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, x ‚â§ f y ‚Üí f x ‚â§ f y) : closure_operator Œ±
{E : Type u_1} [inner_product_space ‚Ñù E] {n : ‚Ñï} [fact (finite_dimensional.finrank ‚Ñù E = n + 1)] : smooth_manifold_with_corners (model_with_corners_self ‚Ñù (euclidean_space ‚Ñù (fin n))) ‚Ü•(metric.sphere 0 1)
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.final] (d : D) : C
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (b : Œ≤) (l : list Œ±) : list Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_group Œ±] [subtraction_monoid Œ≤] (f : Œ± ‚Üí+ Œ≤) (g h : Œ±) : ‚áëf (g - h) = ‚áëf g - ‚áëf h
{R : Type u_1} {E : Type u_2} {Œπ : Type u_4} {Œπ' : Type u_5} [linear_ordered_field R] [add_comm_group E] [module R E] (s : finset Œπ) (t : finset Œπ') (ws : Œπ ‚Üí R) (zs : Œπ ‚Üí E) (wt : Œπ' ‚Üí R) (zt : Œπ' ‚Üí E) (hws : s.sum (Œª (i : Œπ), ws i) = 1) (hwt : t.sum (Œª (i : Œπ'), wt i) = 1) (a b : R) (hab : a + b = 1) : a ‚Ä¢ s.center_mass ws zs + b ‚Ä¢ t.center_mass wt zt = (finset.map function.embedding.inl s ‚à™ finset.map function.embedding.inr t).center_mass (sum.elim (Œª (i : Œπ), a * ws i) (Œª (j : Œπ'), b * wt j)) (sum.elim zs zt)
{R : Type u_1} [non_assoc_semiring R] (f : ‚Ñï ‚Üí+* R) : f = nat.cast_ring_hom R
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] : category_theory.limits.cokernel_cofork category_theory.limits.biprod.inl
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) {r : ‚Ñù} (hr : r < 0) : hb.oangle (r ‚Ä¢ x) y = hb.oangle (-x) y
 : nzsnum ‚Üí bool
{C : Type u} [category_theory.category_struct C] {X : C} (f : X ‚ü∂ X) : category_theory.End X
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (f : category_theory.mono_over X) : f ‚ü∂ ‚ä§
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop} (f : Œ± ‚Ü™ Œ≤) (h : ‚àÄ ‚¶Éx : Œ±‚¶Ñ, p x ‚Üí q (‚áëf x)) : {x // p x} ‚Ü™ {y // q y}
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] {B : C} [category_theory.is_connected J] [category_theory.limits.has_limits_of_shape J C] : category_theory.limits.has_limits_of_shape J (category_theory.over B)
(L : first_order.language) : Type u
 : declaration ‚Üí bool
{n : ‚Ñï} {Œ± : fin n ‚Üí Type u} {Œ≤ : Type w} (a : d_array n Œ±) (b : Œ≤) (f : Œ† (i : fin n), Œ± i ‚Üí Œ≤ ‚Üí Œ≤) : Œ≤
{L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] (hnp : L.embedding N P) (hmn : L.embedding M N) : L.embedding M P
{R : Type u} {S : Type u_3} [comm_ring R] (L : Type v) (M : Type w) [field L] [field M] [algebra R M] [no_zero_smul_divisors R M] [is_alg_closure R M] [comm_ring S] [algebra S L] [no_zero_smul_divisors S L] [is_alg_closure S L] (hSR : S ‚âÉ+* R) : {e // e.to_ring_hom.comp (algebra_map S L) = (algebra_map R M).comp hSR.to_ring_hom}
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hderiv : ‚àÄ (x : ‚Ñù), x ‚àà set.interval a b ‚Üí differentiable_at ‚Ñù f x) (hint : interval_integrable (deriv f) measure_theory.measure_space.volume a b) : ‚à´ (y : ‚Ñù) in a..b, deriv f y = f b - f a
 : name ‚Üí tactic bool
{Œ± : Type u_1} [linear_ordered_comm_group_with_zero Œ±] {a : Œ±} (ha : a ‚â† 0) : Œ± ‚âÉo Œ±
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [nonempty Œ±] (h : ‚àÄ (c : set Œ±), is_chain r c ‚Üí c.nonempty ‚Üí (‚àÉ (ub : Œ±), ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub)) (trans : ‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) : ‚àÉ (m : Œ±), ‚àÄ (a : Œ±), r m a ‚Üí r a m
{Œ± : Type u_1} [ring Œ±] (self : ring.total_positive_cone Œ±) : ring.positive_cone Œ±
(M : Type u_5) (N : Type u_6) [add_zero_class M] [add_zero_class N] : M ‚Üí+ M √ó N
{m : Type ‚Üí Type v} [monad m] {Œ± : Type u} (p : Œ± ‚Üí m bool) : list Œ± ‚Üí m bool
{Œ± : Type u_2} [semiring Œ±] (a : Œ±) : Prop
{C : Type u} [category_theory.category_struct C] (X : C) : has_mul (category_theory.End X)
{V : Type u_1} [quiver V] {X Y : V} (f : X ‚ü∂ Y) : opposite.op Y ‚ü∂ opposite.op X
{C : Type u} [category_theory.category C] [category_theory.abelian C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.abelian.coimage f ‚âÖ category_theory.abelian.image f
(f : name ‚Üí option name) (replace_all : bool) (ignore : name_map (list ‚Ñï)) (e : expr) : bool
{Œ± : Type u_1} (a : Œ±) (s : set Œ±) [measurable_space Œ±] (hs : measurable_set s) : ‚áë((pmf.pure a).to_measure) s = ite (a ‚àà s) 1 0
 : Mon_ (Type u) ‚•§ Mon
{Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {p : Œ† (a : Œ±), Œ≤ a ‚Üí Prop} : {f // ‚àÄ (a : Œ±), p a (f a)} ‚âÉ Œ† (a : Œ±), {b // p a b}
{X : Top} {T : ‚Ü•X ‚Üí Type v} (P : Top.prelocal_predicate T) : Top.presheaf (Type v) X
{Œπ Œ± : Type v} (U : Œπ ‚Üí Œ±) [semilattice_inf Œ±] : category_theory.pairwise Œπ ‚•§ Œ±
{R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [semiring R] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] [semi_normed_group E] [semi_normed_group E‚ÇÇ] [module R E] [module R‚ÇÇ E‚ÇÇ] (e : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) : E ‚âÉ‚Çú E‚ÇÇ
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {S‚ÇÅ S‚ÇÇ : submodule K V} [finite_dimensional K ‚Ü•S‚ÇÇ] (hle : S‚ÇÅ ‚â§ S‚ÇÇ) (hd : finite_dimensional.finrank K ‚Ü•S‚ÇÅ = finite_dimensional.finrank K ‚Ü•S‚ÇÇ) : S‚ÇÅ = S‚ÇÇ
{M : Type u_1} [mul_one_class M] (c : con M) : M ‚Üí* c.quotient
{R : Type u‚ÇÅ} [semiring R] [star_ring R] (r : R ‚Üí R ‚Üí Prop) (hr : ‚àÄ (a b : R), r a b ‚Üí r (has_star.star a) (has_star.star b)) : star_ring (ring_quot r)
{G : Type u_6} [group G] {H : Type u_1} [group H] (f : G ‚Üí H) (map_div : ‚àÄ (a b : G), f (a * b‚Åª¬π) = f a * (f b)‚Åª¬π) : G ‚Üí* H
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] (f : C(X, Y)) : f.homotopy f
(m M N : ‚Ñï) : finset (Œ£ (n : ‚Ñï), composition n)
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [linear_ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : concave_on ùïú s f) {x y z : E} (hx : x ‚àà s) (hy : y ‚àà s) (hz : z ‚àà segment ùïú x y) : linear_order.min (f x) (f y) ‚â§ f z
{C : Type u} [category_theory.category C] {X Y Z : algebraic_geometry.PresheafedSpace C} (f : X ‚ü∂ Z) [hf : algebraic_geometry.PresheafedSpace.is_open_immersion f] (g : Y ‚ü∂ Z) (s : category_theory.limits.pullback_cone f g) : s.X ‚ü∂ (algebraic_geometry.PresheafedSpace.is_open_immersion.pullback_cone_of_left f g).X
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s ‚à™ t)
{Œ± : Type u_1} [preorder Œ±] (a b : Œ±) : set Œ±
{R : Type u} [comm_semiring R] : R ‚Üí polynomial R ‚Üí+* R
{M : Type u_1} [add_zero_class M] {A : Type u_4} [set_like A M] [hA : add_submonoid_class A M] (S' : A) : ‚Ü•S' ‚Üí+ M
{Œ± : Type u_1} {Œ≤ : Type u_2} [boolean_ring Œ±] [boolean_ring Œ≤] (f : Œ± ‚Üí+* Œ≤) : bounded_lattice_hom (as_boolalg Œ±) (as_boolalg Œ≤)
{J : Type u} [category_theory.small_category J] (F : J ‚•§ Profinite) : category_theory.limits.is_limit (Profinite.limit_cone F)
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : ‚Ü•(S.left_neg) ‚Üí+ ‚Ü•S
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.is_iso (category_theory.limits.coequalizer.œÄ f f)
(M : Type u) : Type u
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {s t : category_theory.limits.cone F} (P : category_theory.limits.is_limit s) (Q : category_theory.limits.is_limit t) : s.X ‚âÖ t.X
{Œ± : Type u} {Œ≤ : Type v} {F : Type u_1} [non_assoc_semiring Œ±] [non_assoc_semiring Œ≤] [add_hom_class F Œ± Œ≤] (f : F) (a : Œ±) : ‚áëf (bit0 a) = bit0 (‚áëf a)
(q : interactive.parse (optional interactive.types.texpr)) : tactic unit
{n : ‚Ñï} (x y : bitvec n) : bitvec n
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {f' : F} {x : ùïú} {s t u : set ùïú} (hu : u ‚àà nhds x) (h : s ‚à© u = t ‚à© u) : has_deriv_within_at f f' s x ‚Üí has_deriv_within_at f f' t x
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_comm_monoid M] (f : Œ± ‚Üí Œ≤) : (Œ± ‚Üí‚ÇÄ M) ‚Üí+ Œ≤ ‚Üí‚ÇÄ M
{Œ± : Type u_1} [pseudo_metric_space Œ±] {f : ‚Ñï ‚Üí Œ±} (d : ‚Ñï ‚Üí ‚Ñù) (hf : ‚àÄ (n : ‚Ñï), has_dist.dist (f n) (f n.succ) ‚â§ d n) (hd : summable d) : cauchy_seq f
(tac : tactic.interactive.itactic) (msg : string) : tactic unit
{X : Type u_2} [emetric_space X] (m : set X ‚Üí ennreal) : measure_theory.outer_measure X
{Œ± : Type u_1} [decidable_eq Œ±] {s : finset Œ±} {p : finset Œ± ‚Üí Prop} (hu : Œ† (t : finset Œ±), t ‚äÇ s ‚Üí decidable (p t)) : decidable (‚àÄ (t : finset Œ±), t ‚äÇ s ‚Üí p t)
(x : pgame) : x.restricted x
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_pullbacks C] (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.mono_over.map f ‚ãô category_theory.mono_over.pullback f ‚âÖ ùü≠ (category_theory.mono_over X)
 : ¬¨bdd_above {p : ‚Ñï | nat.prime p}
(V : Type u_1) [semi_normed_group V] : normed_group_hom V V
{p : ‚Ñï+ ‚Üí Prop} [decidable_pred p] (h : ‚àÉ (n : ‚Ñï+), p n) : {n // p n ‚àß ‚àÄ (m : ‚Ñï+), m < n ‚Üí ¬¨p m}
{C : Type (max v u)} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] {K : Type (max v u)} [category_theory.small_category K] [category_theory.limits.has_limits_of_shape K D] (F : K ‚•§ category_theory.Sheaf J D) (E : category_theory.limits.cone (F ‚ãô category_theory.Sheaf_to_presheaf J D)) (hE : category_theory.limits.is_limit E) : category_theory.presheaf.is_sheaf J E.X
{Œ± : Type} (sep : parser unit) (p : parser Œ±) : parser (list Œ±)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (f : ‚Ñï ‚Üí R) (g : ‚Ñï ‚Üí M) (n : ‚Ñï) : (finset.range n).sum (Œª (i : ‚Ñï), f i ‚Ä¢ g i) = f (n - 1) ‚Ä¢ (finset.range n).sum (Œª (i : ‚Ñï), g i) - (finset.range (n - 1)).sum (Œª (i : ‚Ñï), (f (i + 1) - f i) ‚Ä¢ (finset.range (i + 1)).sum (Œª (i : ‚Ñï), g i))
{B : Type u_3} {S : B} {M : Type u_1} [add_comm_monoid M] [set_like B M] [add_submonoid_class B M] (m : multiset M) (hm : ‚àÄ (a : M), a ‚àà m ‚Üí a ‚àà S) : m.sum ‚àà S
{Œ± : Type u_1} (n : ‚Ñ§) : poly Œ±
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) [category_theory.is_filtered J] (x y : Œ£ (j : J), ‚Ü•(F.obj j)) : Mon.filtered_colimits.M F
{R : Type u} [comm_ring R] {G H : Module R} (f : G ‚ü∂ H) : category_theory.limits.is_image (Module.mono_factorisation f)
(K : Type u‚ÇÅ) [field K] (v : valuation K nnreal) (O : Type u‚ÇÇ) [comm_ring O] [algebra O K] (hv : v.integers O) (p : ‚Ñï) [hp : fact (nat.prime p)] [hvp : fact (‚áëv ‚Üëp ‚â† 1)] (f : pre_tilt K v O hv p) : nnreal
{X Y Z : Type u} (f : X ‚ü∂ Y) {g h : Y ‚ü∂ Z} (w : f ‚â´ g = f ‚â´ h) (t : ‚àÄ (y : Y), g y = h y ‚Üí (‚àÉ! (x : X), f x = y)) : category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ f w)
{A : Type u_1} {B : Type u_2} [add_monoid A] [add_monoid B] (f : A ‚Üí+ B) (g : B ‚Üí A) (h‚ÇÅ : function.left_inverse g ‚áëf) (h‚ÇÇ : function.right_inverse g ‚áëf) : B ‚Üí+ A
 : Type
{k G : Type u} [ring k] [monoid G] {V : Type u} [add_comm_group V] [module k V] (œÅ : G ‚Üí* V ‚Üí‚Çó[k] V) : Rep k G
{Œ≤ : typevec.arrow fin2.elim0 fin2.elim0 ‚Üí Sort u_3} (f : Œ≤ typevec.nil_fun) (f_1 : typevec.arrow fin2.elim0 fin2.elim0) : Œ≤ f_1
 : subalgebra ‚ÑÇ C(‚Ü•circle, ‚ÑÇ)
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {i : D ‚•§ C} [category_theory.reflective i] (A : C) (B : D) : (A ‚ü∂ i.obj B) ‚âÉ (i.obj ((category_theory.left_adjoint i).obj A) ‚ü∂ i.obj B)
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤] (f : C(Œ±, Œ≤)) {Œπ : Type u‚ÇÉ} {p : filter Œπ} {F : Œπ ‚Üí C(Œ±, Œ≤)} : filter.tendsto F p (nhds f) ‚Üî ‚àÄ (K : set Œ±), is_compact K ‚Üí tendsto_uniformly_on (Œª (i : Œπ) (a : Œ±), ‚áë(F i) a) ‚áëf p K
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (F‚ÇÅ F‚ÇÇ : category_theory.mono_over X ‚•§ category_theory.mono_over Y) (h : F‚ÇÅ ‚âÖ F‚ÇÇ) : category_theory.subobject.lower F‚ÇÅ = category_theory.subobject.lower F‚ÇÇ
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (n : with_top ‚Ñï) (f : E ‚Üí F) (p : E ‚Üí formal_multilinear_series ùïú E F) (s : set E) : Prop
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [is_R_or_C ùïÇ] [normed_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] : has_strict_fderiv_at (exp ùïÇ) 1 0
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D·µí·µñ) [category_theory.limits.preserves_finite_limits F] : category_theory.limits.preserves_finite_colimits F.left_op
{Œ± : Type u_1} [topological_space Œ±] [t1_space Œ±] (x : Œ±) [hx : (nhds_within x {x}·∂ú).ne_bot] {s : set Œ±} (hs : s ‚àà nhds x) : s.infinite
(p : pos) (n : ‚Ñï) : pos
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {b‚ÇÅ b‚ÇÇ : basis Œπ R M} (h : ‚àÄ (i : Œπ), ‚áëb‚ÇÅ i = ‚áëb‚ÇÇ i) : b‚ÇÅ = b‚ÇÇ
 : interactive.decl_meta_info ‚Üí lean.parser interactive.inductive_decl
{A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ} [category_theory.category A] [category_theory.category B] [category_theory.category C] {U : B ‚•§ C} {F : C ‚•§ B} (R : A ‚•§ B) (F' : C ‚•§ A) (adj‚ÇÅ : F ‚ä£ U) (adj‚ÇÇ : F' ‚ä£ R ‚ãô U) (X : B) : F'.obj (U.obj (F.obj (U.obj X))) ‚ü∂ F'.obj (U.obj X)
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÅ} [category_theory.category K] (e : J ‚âå K) [category_theory.is_connected J] : category_theory.is_connected K
(K : Type u) [field K] (V : Type v) [add_comm_group V] [module K V] [finite_dimensional K V] : K ‚Üí‚Çó[K] tensor_product K V (module.dual K V)
(R : Type u_1) {B : Type u_3} (F : Type u_4) (E : B ‚Üí Type u_5) [nondiscrete_normed_field R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [normed_group F] [normed_space R F] [topological_space B] [topological_space (bundle.total_space E)] [Œ† (x : B), topological_space (E x)] : Type (max u_3 u_4 u_5)
{E : Type u_2} {ùïú : Type u_3} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] {s : set E} (hs : convex ùïú s) {a b : ùïú} (ha : 0 ‚â§ a) (hb : 0 < b) (hab : a + b = 1) : a ‚Ä¢ s + b ‚Ä¢ interior s ‚äÜ interior s
 : simp_lemmas ‚Üí simp_lemmas ‚Üí simp_lemmas
(p : ‚Ñï) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] {V : Type u_2} [add_comm_group V] [witt_vector.isocrystal p k V] : V ‚âÉ‚Çõ‚Çó[witt_vector.fraction_ring.frobenius_ring_hom p k] V
{Œ± : Type u} {Œ≤ : Type v} (f : filter Œ±) (m : Œ± ‚Üí filter Œ≤) : filter Œ≤
 : ‚ÑÇ ‚ÜíL[‚Ñù] ‚Ñù
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a : Œ±} : a‚Åª¬π < 1 ‚Üí 1 < a
{Œ± : Sort u} {p q : Œ± ‚Üí Prop} (e : ‚àÄ (x : Œ±), p x ‚Üî q x) : {x // p x} ‚âÉ {x // q x}
{key : Type} (s t : native.rb_set key) : native.rb_set key
{M : Type u_1} [has_mul M] {Œ≤ : Sort u_2} {c : con M} (q r : c.quotient) (f : M ‚Üí M ‚Üí Œ≤) (h : ‚àÄ (a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ : M), ‚áëc a‚ÇÅ b‚ÇÅ ‚Üí ‚áëc a‚ÇÇ b‚ÇÇ ‚Üí f a‚ÇÅ a‚ÇÇ = f b‚ÇÅ b‚ÇÇ) : Œ≤
 : widget.tc subexpr empty
{Œ± : Type u} [has_inv Œ±] : has_inv (with_zero Œ±)
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] (f : ‚ÑÇ ‚Üí E) (z w : ‚ÑÇ) (s : set ‚ÑÇ) (hs : s.countable) (Hc : continuous_on f (set.interval z.re w.re √ó‚ÑÇ set.interval z.im w.im)) (Hd : ‚àÄ (x : ‚ÑÇ), x ‚àà set.Ioo (linear_order.min z.re w.re) (linear_order.max z.re w.re) √ó‚ÑÇ set.Ioo (linear_order.min z.im w.im) (linear_order.max z.im w.im)  s ‚Üí differentiable_at ‚ÑÇ f x) : (((‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üë(z.im) * complex.I)) - ‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üë(w.im) * complex.I)) + complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üë(w.re) + ‚Üëy * complex.I)) - complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üë(z.re) + ‚Üëy * complex.I) = 0
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} : category_theory.presieve.is_sheaf ‚ä• P
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F‚ÇÅ F‚ÇÇ : D ‚•§ C} [‚àÄ (X Y : C), subsingleton (X ‚ü∂ Y)] (hC : category_theory.skeletal C) (hF : F‚ÇÅ ‚âÖ F‚ÇÇ) : F‚ÇÅ = F‚ÇÇ
{M : Type w} {c f‚ÇÅ f‚ÇÇ : Type u} {r‚ÇÅ r‚ÇÇ : Type v} (c' : c ‚Üí M) (f‚ÇÅ' : f‚ÇÅ ‚Üí M ‚Üí M) (f‚ÇÇ' : f‚ÇÇ ‚Üí M ‚Üí M ‚Üí M) {n : ‚Ñï} : (first_order.language.mk‚ÇÇ c f‚ÇÅ f‚ÇÇ r‚ÇÅ r‚ÇÇ).functions n ‚Üí (fin n ‚Üí M) ‚Üí M
{n : ‚Ñï} (x y : bitvec n) (c : bool) : bitvec (n + 1)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} : is_extr_on (‚áëorder_dual.to_dual ‚àò f) s a ‚Üí is_extr_on f s a
 : native.float
{p : ‚Ñï} [fact (nat.prime p)] : padic_norm_e 1 = 1
{Œπ : Type u} (s : finset Œπ) (w z : Œπ ‚Üí nnreal) (hw' : s.sum (Œª (i : Œπ), w i) = 1) {p : ‚Ñù} (hp : 1 ‚â§ p) : s.sum (Œª (i : Œπ), w i * z i) ‚â§ s.sum (Œª (i : Œπ), w i * z i ^ p) ^ (1 / p)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} : strict_mono_on f s ‚Üí strict_anti_on (f ‚àò ‚áëorder_dual.of_dual) s
{œÑ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ≤] (f : filter œÑ) (œï : œÑ ‚Üí Œ± ‚Üí Œ≤) (s : set Œ±) {c : set Œ≤} (hc‚ÇÅ : is_compact c) (hc‚ÇÇ : ‚àÉ (v : set œÑ) (H : v ‚àà f), closure (set.image2 œï v s) ‚äÜ c) {n : set Œ≤} (hn‚ÇÅ : is_open n) (hn‚ÇÇ : omega_limit f œï s ‚äÜ n) : ‚àÉ (u : set œÑ) (H : u ‚àà f), closure (set.image2 œï u s) ‚äÜ n
(cs : list omega.clause) : Prop
 : (user_attribute unit)
(C : Type v) [category_theory.category C] [category_theory.concrete_category C] : C ‚•§ Type u
{Œ± : Type u_1} {n : ‚Ñï} (f : fin n ‚Üí Œ±) (m : ‚Ñï) : m ‚â§ n ‚Üí list Œ± ‚Üí list Œ±
{M : Type u_6} {N : Type u_7} [mul_one_class M] [mul_one_class N] (f : M ‚Üí* N) (g : N ‚Üí* M) (h‚ÇÅ : g.comp f = monoid_hom.id M) (h‚ÇÇ : f.comp g = monoid_hom.id N) : M ‚âÉ* N
(Œ± : Type u_1) [ht : topological_space Œ±] [h : polish_space Œ±] : metric_space Œ±
{B : Type u‚ÇÇ} {C : Type u‚ÇÉ} [category_theory.category B] [category_theory.category C] {U : B ‚•§ C} {F : C ‚•§ B} (adj‚ÇÅ : F ‚ä£ U) [Œ† (X : B), category_theory.regular_epi (adj‚ÇÅ.counit.app X)] (X : B) : category_theory.limits.is_colimit (category_theory.limits.cofork.of_œÄ (adj‚ÇÅ.counit.app X) _)
{C : Type u} [category_theory.category_struct C] {X : C} (f : category_theory.End X) : X ‚ü∂ X
{R : Type u_1} {R‚ÇÅ : Type u_2} {M‚ÇÅ : Type u_6} [comm_ring R] [comm_ring R‚ÇÅ] [add_comm_group M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] {I‚ÇÅ I‚ÇÇ : R‚ÇÅ ‚Üí+* R} (N : submodule R‚ÇÅ M‚ÇÅ) (B : M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ] M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÇ] R) : submodule R‚ÇÅ M‚ÇÅ
{G : Type u_1} [group G] [hG : group.is_nilpotent G] : nat.find _ = group.nilpotency_class G
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) : Type (max u‚ÇÅ v‚ÇÅ)
{Œì : Type u_1} {R : Type u_2} [partial_order Œì] [has_zero R] (x : hahn_series Œì R) : set Œì
{Œ± : Type u} [pseudo_emetric_space Œ±] {x : Œ±} {s t : set Œ±} {r : ennreal} (h : x ‚àà s) (H : emetric.Hausdorff_edist s t < r) : ‚àÉ (y : Œ±) (H : y ‚àà t), has_edist.edist x y < r
 : Type ‚Üí Type
{Œ± : Type u} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_symm Œ± r] {a b : Œ±} : r a b ‚Üî r b a
{Œ± : Type u} [topological_space Œ±] [t2_space Œ±] {Œπ : Type u_1} [nonempty Œπ] {V : Œπ ‚Üí set Œ±} (hV : directed superset V) (hV_cpct : ‚àÄ (i : Œπ), is_compact (V i)) {U : set Œ±} (hU : ‚àÄ (x : Œ±), (x ‚àà ‚ãÇ (i : Œπ), V i) ‚Üí U ‚àà nhds x) : ‚àÉ (i : Œπ), V i ‚äÜ U
{R : Type u_1} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : ‚Ü•‚ä§ ‚âÉ‚Çó[R] M
{Œ± : Type u} [infinite Œ±] {s : set Œ±} (hf : s.finite) : s·∂ú ‚àà filter.hyperfilter Œ±
{Œ± : Type u} {Œ≤ : Type v} (f : filter (Œ± ‚Üí Œ≤)) (g : filter Œ±) : filter Œ≤
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ} (h : ‚àÄ (u v : ‚Ü•(f.ker) ‚Üí‚Çó[R] M), f.comp u = f.comp v ‚Üí u = v) : f.ker = ‚ä•
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {E' : Type u_7} [inner_product_space ùïú E'] (f : E ‚Üí‚Çó[ùïú] E') {v : basis Œπ ùïú E} (hv : orthonormal ùïú ‚áëv) (hf : orthonormal ùïú (‚áëf ‚àò ‚áëv)) : E ‚Üí‚Çó·µ¢[ùïú] E'
{R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} {s : S} [monoid S] [has_scalar R M] [has_scalar R S] [mul_action S M] [is_scalar_tower R S M] (h : a ‚Ä¢ s = 1) : is_smul_regular M s
(ugs : list tactic.uncleared_goal) : tactic unit
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {w : Œ± ‚Üí M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : ‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚àà t) (ht : t.nonempty) (hb : t.card ‚Ä¢ b ‚â§ s.sum (Œª (x : Œ±), w x)) : ‚àÉ (y : Œ≤) (H : y ‚àà t), b ‚â§ (finset.filter (Œª (x : Œ±), f x = y) s).sum (Œª (x : Œ±), w x)
(P : Type u) {L : Type u} [has_mem P L] (l : L) : ‚Ñï
(c : linarith.comp) (a : ‚Ñï) : ‚Ñ§
{Œ± : Type u_1} {M : Type u_2} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (a : Œ±) : (Œ± ‚Üí‚ÇÄ M) ‚Üí‚Çó[R] M
(m m' : Type u ‚Üí Type v) (n n' : Type u ‚Üí Type w) : Type (max (u+1) v w)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) (c : category_theory.limits.cone (K ‚ãô F)) (t : category_theory.limits.is_limit c) : Type (max u‚ÇÅ v‚ÇÅ v‚ÇÇ w)
{R : Type u_1} {L : Type u_2} {K : Type u_3} [comm_ring R] [field K] [algebra R K] [field L] [algebra R L] {Œπ : Type u_4} (v : Œπ ‚Üí K) {Œ∫ : Type u_5} (w : Œ∫ ‚Üí L) [is_alg_closed K] [is_alg_closed L] (e : Œπ ‚âÉ Œ∫) (hv : is_transcendence_basis R v) (hw : is_transcendence_basis R w) : K ‚âÉ+* L
{Œ± : Type u} [partial_order Œ±] [order_bot Œ±] {a : Œ±} : is_bot a ‚Üí a = ‚ä•
(K : Type u) [field K] : Type (u+1)
 : Type (u+1)
 : user_attribute unit (list name)
 : filter.cofinite = filter.at_top
{Œ± : Type u_1} [linear_ordered_add_comm_group Œ±] {x dx y dy : Œ±} (h : dy < dx) (hx : 0 < dx) : nonempty ‚Ü•(set.Ico x (x + dx)  set.Ico y (y + dy))
{X Y : AddCommGroup} : ‚Ü•X ‚âÉ+ ‚Ü•Y ‚âÖ X ‚âÖ Y
{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ‚â† 0) : char.quadratic_char F a = -1 ‚Üî ¬¨char.quadratic_char F a = 1
{A : Type u_4} [add_zero_class A] : submonoid (multiplicative A) ‚âÉo add_submonoid A
{Œ± : Type u_1} {Œ≤ : Type u_2} [decidable_eq Œ±] [fintype Œ±] [add_comm_monoid Œ≤] {Œ¥ : Œ± ‚Üí Type u_3} {t : Œ† (a : Œ±), finset (Œ¥ a)} (f : (Œ† (a : Œ±), a ‚àà finset.univ ‚Üí Œ¥ a) ‚Üí Œ≤) : (finset.univ.pi t).sum (Œª (x : Œ† (a : Œ±), a ‚àà finset.univ ‚Üí Œ¥ a), f x) = (fintype.pi_finset t).sum (Œª (x : Œ† (a : Œ±), Œ¥ a), f (Œª (a : Œ±) (_x : a ‚àà finset.univ), x a))
(Œ± : Type u_3) [topological_space Œ±] : Type u_3
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.cartesian_closed C] [category_theory.limits.has_zero_object C] : C ‚âå category_theory.discrete punit
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} (a : Œ±) (b : Œ≤) (i : Œπ) : filter.map (prod.map (Œª (_x : Œ±), b) id) ((filter.principal {a}).coprod (filter.principal {i})) = filter.principal ({b} √óÀ¢ set.univ)
 : linter
{m : ‚Ñù} (hm : 1 < m) (k : ‚Ñï) : liouville.liouville_number m = liouville.liouville_number_initial_terms m k + liouville.liouville_number_tail m k
{Œ± : Type u_1} {P : Œ± ‚Üí Prop} [encA : encodable Œ±] [decP : decidable_pred P] : encodable {a // P a}
{X Y : Type u} [comm_monoid X] [comm_monoid Y] : X ‚âÉ* Y ‚âÖ CommMon.of X ‚âÖ CommMon.of Y
 : bool ‚Üí list bool
(V : Type w') [first_order.language.graph.Structure V] [V ‚ä® first_order.language.Theory.simple_graph] : simple_graph V
(ùïú : Type u_1) (E : Type u_4) (F‚Çó : Type u_7) [normed_group E] [normed_group F‚Çó] [nondiscrete_normed_field ùïú] [normed_space ùïú E] [normed_space ùïú F‚Çó] : (E ‚ÜíL[ùïú] ùïú) ‚ÜíL[ùïú] F‚Çó ‚ÜíL[ùïú] E ‚ÜíL[ùïú] F‚Çó
(Œ± : Type u_6) (Œ≤ : Type u_7) [topological_space Œ±] [topological_space Œ≤] : Type (max u_6 u_7)
{L R : Type v} {fst snd : R ‚Üí L} (a b : category_theory.limits.walking_multicospan fst snd) : Type v
{V : Type u} {G : simple_graph V} {u v : V} (p : G.walk u v) : list (sym2 V)
{k : Type u_1} {M : Type u_2} [ordered_semiring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] {a : M} {c : k} (hc : 0 < c) : a < 0 ‚Üí c ‚Ä¢ a < 0
(R : Type u) (A : Type v) [comm_semiring R] [star_ring R] [semiring A] [star_ring A] [algebra R A] [star_module R A] : Type v
{R : Type u_3} [comm_ring R] (p : polynomial R) (s : R) : polynomial R
{Œ± : Type u_2} [monoid Œ±] (m : Œ±) : is_square m ‚Üí (‚àÉ (c : Œ±), m = c ^ 2)
(ùïú : Type u_1) {E : Type u_2} [semi_normed_ring ùïú] [has_scalar ùïú E] [has_zero E] [topological_space E] (s : set E) : Prop
{Œ± : Type u_1} {m : measurable_space Œ±} : measure_theory.complex_measure Œ± ‚Üí‚Çó[‚Ñù] measure_theory.signed_measure Œ±
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a b : Œ±} (ha : 1 ‚â§ a) (hb : 1 < b) : 1 < a * b
{Œ± : Type u_1} [boolean_algebra Œ±] : boolean_ring Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (u : uniform_space Œ≤) : uniform_space Œ±
{Œ± : Type u_1} [has_le Œ±] (a : Œ±) : Prop
{G : Type u_1} [add_group G] [topological_space G] (K‚ÇÄ U : set G) (K : topological_space.compacts G) : ‚Ñù
(g : pgame) : g.right_moves ‚Üí pgame
{n m : ‚Ñï} (h : n = m) : fin n ‚âÉ fin m
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : R) : v.int_valuation_def x ‚â§ 1
(n : ‚Ñï) : tactic.ring.ring_m expr
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_colimits C] : category_theory.limits.has_limits C·µí·µñ
{Œ± : Type u_1} [uniform_space Œ±] (pkg : abstract_completion Œ±) {Œ≤ : Type u_2} [uniform_space Œ≤] (f : Œ± ‚Üí Œ≤) : pkg.space ‚Üí Œ≤
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} {Œπ‚ÇÇ : Type u_5} (s‚ÇÇ : finset Œπ‚ÇÇ) (e : Œπ‚ÇÇ ‚Ü™ Œπ) (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) (b : P) : ‚áë((finset.map e s‚ÇÇ).weighted_vsub_of_point p b) w = ‚áë(s‚ÇÇ.weighted_vsub_of_point (p ‚àò ‚áëe) b) (w ‚àò ‚áëe)
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [fintype Œπ] [decidable_eq Œπ] [Œ† (i : Œπ), decidable_eq (Œ± i)] [Œ† (i : Œπ), linear_order (Œ± i)] {p : (Œ† (i : Œπ), finset (Œ± i)) ‚Üí Prop} (f : Œ† (i : Œπ), finset (Œ± i)) (h0 : p (Œª (_x : Œπ), ‚àÖ)) (step : ‚àÄ (g : Œ† (i : Œπ), finset (Œ± i)) (i : Œπ) (x : Œ± i), (‚àÄ (y : Œ± i), y ‚àà g i ‚Üí x < y) ‚Üí p g ‚Üí p (function.update g i (has_insert.insert x (g i)))) : p f
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P (n + 2)) {i‚ÇÅ i‚ÇÇ : fin (n + 3)} (h : i‚ÇÅ ‚â† i‚ÇÇ) : s.monge_point -·µ• finset.centroid ‚Ñù {i‚ÇÅ, i‚ÇÇ}·∂ú s.points = ‚áë(finset.univ.weighted_vsub s.points_with_circumcenter) (affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter i‚ÇÅ i‚ÇÇ)
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_2} {Œ≥ : Type u_3} [Œ† (a : Œ±), comm_monoid (Œ≤ a)] (s : finset Œ≥) (g : Œ≥ ‚Üí Œ† (a : Œ±), Œ≤ a) : s.prod (Œª (c : Œ≥), g c) = Œª (a : Œ±), s.prod (Œª (c : Œ≥), g c a)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] : (C ‚•§ D ‚•§ E) ‚•§ C √ó D ‚•§ E
{G : Type u_3} [group G] : mul_action.is_pretransitive G G
(Œ± : Type u_1) (Œ≤ : Type u_2) [has_add Œ±] [add_comm_semigroup Œ≤] : add_hom (add_hom Œ± Œ≤) (Œ± ‚Üí Œ≤)
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {v‚ÇÅ v‚ÇÇ : M} (hv‚ÇÅ : v‚ÇÅ ‚â† 0) (hv‚ÇÇ : v‚ÇÇ ‚â† 0) : ray_of_ne_zero R v‚ÇÅ hv‚ÇÅ = ray_of_ne_zero R v‚ÇÇ hv‚ÇÇ ‚Üî same_ray R v‚ÇÅ v‚ÇÇ
{Œ≤ : Type u} {Œ± : Type v} [add_comm_monoid Œ≤] [decidable_eq Œ±] (s : finset Œ±) (a : Œ±) (b : Œ± ‚Üí Œ≤) : s.sum (Œª (x : Œ±), ite (x = a) (b x) 0) = ite (a ‚àà s) (b a) 0
{R : Type u_1} {S : Type u_3} [non_unital_semiring R] [non_unital_semiring S] : non_unital_semiring (R √ó S)
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] : Top.sheaf CommRing (projective_spectrum.Top ùíú)
(G : Type u_1) [group G] : ‚Ñï ‚Üí (Œ£' (H : subgroup G), H.normal)
{G : Type u_1} [add_group G] (H K : add_subgroup G) : ‚Ñï
{R : Type u_1} {M : Type u_2} {Œπ : Type u_5} [comm_ring R] [add_comm_group M] [module R M] [fintype Œπ] (b : basis Œπ R M) (f : Œπ ‚Üí‚ÇÄ R) (i : Œπ) : ‚áë(‚áë(finsupp.total Œπ (module.dual R M) R b.coord) f) (‚áëb i) = ‚áëf i
{R : Type u_1} (c‚ÇÅ c‚ÇÇ : R) : cardinal.mk (quaternion_algebra R c‚ÇÅ c‚ÇÇ) = cardinal.mk R ^ 4
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (S‚ÇÅ S‚ÇÇ : submodule K V) [h‚ÇÅ : finite_dimensional K ‚Ü•S‚ÇÅ] [h‚ÇÇ : finite_dimensional K ‚Ü•S‚ÇÇ] : finite_dimensional K ‚Ü•(S‚ÇÅ ‚äî S‚ÇÇ)
 : znum ‚Üí znum
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {s : set E} {f g : E ‚Üí F} (hf : cont_diff_on ùïú n f s) (hg : cont_diff_on ùïú n g s) : cont_diff_on ùïú n (Œª (x : E), f x - g x) s
(n : Type u) [decidable_eq n] [fintype n] (Œ± : Type v) [comm_ring Œ±] [star_ring Œ±] : submonoid (matrix n n Œ±)
(A : Type u_1) [ring A] [algebra ‚Ñö A] : power_series A
{n : ‚Ñï} {M : Type u_1} [has_zero M] (s : fin (n + 1) ‚Üí‚ÇÄ M) : fin n ‚Üí‚ÇÄ M
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} (h_mono : monotone_on f s) (hs : s ‚àà nhds a) (hfs_l : ‚àÄ (b : Œ≤), b < f a ‚Üí (‚àÉ (c : Œ±) (H : c ‚àà s), f c ‚àà set.Ioo b (f a))) (hfs_r : ‚àÄ (b : Œ≤), b > f a ‚Üí (‚àÉ (c : Œ±) (H : c ‚àà s), f c ‚àà set.Ioo (f a) b)) : continuous_at f a
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_4} [decidable_eq Œπ] [fintype Œπ] (e : basis Œπ R M) {v : Œπ ‚Üí M} (hli : linear_independent R v) (hsp : submodule.span R (set.range v) = ‚ä§) (i : Œπ) : ‚áë(e.det) v ‚Ä¢ (basis.mk hli hsp).coord i = e.det.to_multilinear_map.to_linear_map v i
(Œ± : Type u) [t : topological_space Œ±] : Prop
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] {ùíú : finset (finset Œ±)} {s : finset Œ±} (hs : s ‚àà ùíú.up_shadow) : ‚àÉ (t : finset Œ±) (H : t ‚àà ùíú), t ‚äÜ s
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [semiring Œ≤] : semiring Œ±
{Œ≤ : Type u} {f g : Œ≤ ‚Üí Type u} (Œ± : Œ† (j : Œ≤), f j ‚ü∂ g j) (b : Œ≤) (x : ‚àè Œª (j : Œ≤), f j) : category_theory.limits.pi.œÄ g b (category_theory.limits.pi.map Œ± x) = Œ± b (category_theory.limits.pi.œÄ f b x)
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {m : measurable_space Œ±} [topological_space Œ≤] [topological_space.pseudo_metrizable_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] (hf : measure_theory.strongly_measurable f) : measurable f
(X : CompHaus) : category_theory.projective_presentation X
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ‚•§ D) [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.enough_injectives C] [category_theory.limits.preserves_finite_limits F] : F.right_derived 0 ‚âÖ F
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.abelian C] [category_theory.has_injective_resolutions C] [category_theory.abelian D] {F G : C ‚•§ D} [F.additive] [G.additive] (Œ± : F ‚ü∂ G) (n : ‚Ñï) : F.right_derived n ‚ü∂ G.right_derived n
{F : Type u_1} [field F] {K‚ÇÅ : Type u_3} {K‚ÇÇ : Type u_4} [field K‚ÇÅ] [field K‚ÇÇ] [algebra F K‚ÇÅ] [algebra F K‚ÇÇ] (œï : K‚ÇÅ ‚Üí‚Çê[F] K‚ÇÇ) (E : Type u_6) [field E] [algebra F E] [algebra E K‚ÇÅ] [algebra E K‚ÇÇ] [is_scalar_tower F E K‚ÇÅ] [is_scalar_tower F E K‚ÇÇ] [normal F E] : E ‚âÉ‚Çê[F] E
{Œ± : Type u_1} {s : multiset Œ±} {x : multiset Œ± √ó multiset Œ±} : x ‚àà s.antidiagonal ‚Üî x.fst + x.snd = s
{F : Type u_6} [inner_product_space ‚Ñù F] {v : basis (fin 2) ‚Ñù F} (hv : orthonormal ‚Ñù ‚áëv) : ‚ÑÇ ‚âÉ‚Çó·µ¢[‚Ñù] F
(Œ± : Type u‚ÇÅ) : Type u‚ÇÅ
{R : Type u} [semiring R] {M : polynomial R ‚Üí Prop} {f : polynomial R} (f0 : f.nat_degree ‚â† 0) (h_C_add : ‚àÄ {a : R} {p : polynomial R}, M p ‚Üí M (‚áëpolynomial.C a + p)) (h_add : ‚àÄ {p q : polynomial R}, M p ‚Üí M q ‚Üí M (p + q)) (h_monomial : ‚àÄ {n : ‚Ñï} {a : R}, a ‚â† 0 ‚Üí n ‚â† 0 ‚Üí M (‚áë(polynomial.monomial n) a)) : M f
(ùïú : Type u_1) {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [module ùïú E] : closure_operator (set E)
(one : interactive.parse (optional (lean.parser.tk "!"))) (rec : interactive.parse (optional (lean.parser.tk "*"))) (type_names : interactive.parse (lean.parser.many lean.parser.ident)) : tactic unit
{R : Type u_1} {M : Type u_2} [add_comm_monoid M] [comm_ring R] [nontrivial R] : algebra.finite_type R (add_monoid_algebra R M) ‚Üî add_monoid.fg M
{R : Type u} [comm_semiring R] (S : Type u_1) [semiring S] [algebra R S] (M : submonoid R) : submonoid S
{Œ± : Type u_1} {Œ≤ : Type u_2} [semilattice_sup Œ±] [order_bot Œ±] {P : Œ± ‚Üí Prop} {Pbot : P ‚ä•} {Psup : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, P x ‚Üí P y ‚Üí P (x ‚äî y)} (t : finset Œ≤) (f : Œ≤ ‚Üí {x // P x}) : ‚Üë(t.sup f) = t.sup (Œª (x : Œ≤), ‚Üë(f x))
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Œπ] (p : Œπ ‚Üí P) : finite_dimensional k ‚Ü•(vector_span k (set.range p))
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V‚ÇÇ : Type v'} [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] [finite_dimensional K V] [finite_dimensional K V‚ÇÇ] (cond : finite_dimensional.finrank K V = finite_dimensional.finrank K V‚ÇÇ) : nonempty (V ‚âÉ‚Çó[K] V‚ÇÇ)
{P : Type u_1} [preorder P] [order_top P] : order_bot (order.pfilter P)
(v : expr) : lean.parser unit
(x : expr) : tactic unit
 : Type (u+1)
{f : ‚Ñï ‚Üí nnreal} (hf : ‚àÄ ‚¶Ém n : ‚Ñï‚¶Ñ, 0 < m ‚Üí m ‚â§ n ‚Üí f n ‚â§ f m) : summable (Œª (k : ‚Ñï), 2 ^ k * f (2 ^ k)) ‚Üî summable f
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (F : C ‚•§ D) [category_theory.is_equivalence F] {X Y : C} {f : X ‚ü∂ Y} (hf : category_theory.normal_epi (F.map f)) : category_theory.normal_epi f
(meta_info : interactive.decl_meta_info) (_x : interactive.parse (lean.parser.tk "alias")) : lean.parser unit
{F : Type u} [field F] {n : ‚Ñï} (a : F) (hn : ‚Üën ‚â† 0) (ha : a ‚â† 0) : (polynomial.X ^ n - ‚áëpolynomial.C a).separable
{Œ± : Type u_1} [preorder Œ±] {a b : Œ±} (h : a ‚â§ b) : set.Iio a ‚äÜ set.Iio b
(R : Type u) [comm_semiring R] (M : Type v) [add_comm_monoid M] [module R M] : (M ‚Üí‚Çó[R] M) ‚Üí‚Çó[R] R
{Œ± : Type u_3} {Œ≤ : Type u_4} [has_sup Œ±] [has_bot Œ±] [has_sup Œ≤] [has_bot Œ≤] (f : sup_bot_hom Œ± Œ≤) : bot_hom Œ± Œ≤
{R : Type u} [comm_ring R] : category_theory.symmetric_category (Module R)
{F : Type u_1} {R : Type u_4} {S : Type u_5} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S] [non_unital_ring_hom_class F R S] (f : F) (hf : function.bijective ‚áëf) : R ‚âÉ+* S
 : expr ‚Üí tactic.unsafe.type_context expr
{R : Type u_1} [comm_semiring R] {n : Type u_4} [fintype n] [decidable_eq n] {M‚ÇÅ : Type u_5} [add_comm_monoid M‚ÇÅ] [module R M‚ÇÅ] (v‚ÇÅ : basis n R M‚ÇÅ) : (M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÅ) ‚âÉ‚Çê[R] matrix n n R
{Œ± : Type u} {n : ‚Ñï} (v : fin n.succ ‚Üí Œ±) : Œ±
{C : Type u} [category_theory.category C] {X Y X‚ÇÅ Y‚ÇÅ : C} (Œ± : X ‚âÖ X‚ÇÅ) (Œ≤ : Y ‚âÖ Y‚ÇÅ) : (X ‚ü∂ Y) ‚âÉ (X‚ÇÅ ‚ü∂ Y‚ÇÅ)
 : linarith.monom
{p : ‚Ñï} (hp : nat.prime p) (n k : ‚Ñï) : multiplicity p n ‚â§ multiplicity p (n.choose k) + multiplicity p k
{H : Type u} {M : Type u_2} {M' : Type u_3} [topological_space H] [topological_space M] [charted_space H M] [topological_space M'] {G : structure_groupoid H} [charted_space H M'] (e : structomorph G M M') : structomorph G M' M
{C : Type u} [category_theory.category C] [category_theory.limits.has_images C] [category_theory.limits.has_strong_epi_images C] : category_theory.limits.has_image_maps C
{Œ± : Type u_1} [comm_semiring Œ±] (t : tree Œ±) : tactic.ring2.horner_expr ‚Üí Œ±
{H : Type u_5} [inner_product_space ‚Ñù H] (s : set H) : convex_cone ‚Ñù H
 : tactic expr
(Œ± : Type u_1) [denumerable Œ±] : Œ± ‚âÉ ‚Ñï
{M : Type u_1} [has_add M] {c : add_con M} {C : c.quotient ‚Üí Prop} (q : c.quotient) (H : ‚àÄ (x : M), C ‚Üëx) : C q
(p : ‚Ñï ‚Üí Prop) : Type
(R : Type u_1) [rack R] : Prop
(C : Type u_1) [category_theory.category C] : category_theory.idempotents.karoubi (category_theory.idempotents.karoubi C) ‚•§ category_theory.idempotents.karoubi C
(C : Type u) [category_theory.category C] (D : Type u) [category_theory.category D] (E : Type u) [category_theory.category E] : C ‚äï D ‚äï E ‚•§ (C ‚äï D) ‚äï E
(Œ± : Type u_1) : Type u_1
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [semi_normed_group Œ≤] (f : bounded_continuous_function Œ± Œ≤) (C : nnreal) : ‚à•f‚à•‚Çä ‚â§ C ‚Üî ‚àÄ (x : Œ±), ‚à•‚áëf x‚à•‚Çä ‚â§ C
{X : Type u_1} [topological_space X] {R : Type u_5} [has_one R] {U : set X} (f : locally_constant X R) (hU : is_clopen U) : locally_constant X R
{Œ± : Type u_1} {Œπ : Sort u_4} {l : filter Œ±} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí set Œ±} (h : l.has_basis p s) (t : set Œ±) (ht : t ‚àà l) : {i // p i}
{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (v : ‚Ñô K V) : V
 : Type
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : seq Œ± ‚Üí seq Œ≤
{Œ± Œ≤ : BoundedDistribLattice} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J·µí·µñ ‚•§ C) {c : category_theory.limits.cone F.right_op} (hc : category_theory.limits.is_limit c) : category_theory.limits.is_colimit (category_theory.limits.cocone_of_cone_right_op c)
(p : ‚Ñï) (G : Type u_1) [group G] : Prop
 : expr ‚Üí tactic (list expr √ó expr)
{R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [add_comm_group N] [module R M] [module R N] [lie_ring_module L M] [lie_ring_module L N] [lie_module R L M] [lie_module R L N] : has_coe_to_fun (M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (Œª (_x : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N), M ‚Üí N)
{R‚ÇÇ : Type u_5} [comm_semiring R‚ÇÇ] {n : Type u_11} [fintype n] [decidable_eq n] : matrix n n R‚ÇÇ ‚âÉ‚Çó[R‚ÇÇ] bilin_form R‚ÇÇ (n ‚Üí R‚ÇÇ)
{Œ± : Type u} [add_group Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a : Œ±} (h : 0 < a) : -a < a
{Œ± : Type u_1} (f : part Œ± ‚Üío part Œ±) : (unit ‚Üí part Œ±) ‚Üío unit ‚Üí part Œ±
{M : Type u_1} [mul_one_class M] (S : submonoid M) {x y : M} : x ‚àà S ‚Üí y ‚àà S ‚Üí x * y ‚àà S
{M : Type u_5} {N : Type u_6} {P : Type u_7} [mul_one_class M] [mul_one_class N] [comm_monoid P] (f : M ‚Üí* P) (g : N ‚Üí* P) : M √ó N ‚Üí* P
{C : Type u} {D : Type u'} [category_theory.category D] [category_theory.monoidal_category D] (f : C ‚Üí D) : category_theory.free_monoidal_category C ‚Üí D
{R : Type u_1} [has_mul R] [has_star R] (x : R) : Prop
(x : pSet) (y : pSet) : Prop
{M : Type u_1} [mul_one_class M] : has_coe (con M) (submonoid (M √ó M))
 : name ‚Üí expr ‚Üí tactic unit
{M : Type u_3} [add_comm_group M] {R‚ÇÅ : Type u_4} [comm_ring R‚ÇÅ] [module R‚ÇÅ M] {Œπ : Type u_6} [fintype Œπ] [invertible 2] (Q : quadratic_form R‚ÇÅ M) (v : basis Œπ R‚ÇÅ M) (hv‚ÇÇ : (‚áëquadratic_form.associated Q).is_Ortho ‚áëv) : Q.basis_repr v = quadratic_form.weighted_sum_squares R‚ÇÅ (Œª (i : Œπ), ‚áëQ (‚áëv i))
{Œ± : Type u_1} [preorder Œ±] [order_top Œ±] [locally_finite_order Œ±] (a : Œ±) : finset Œ±
{A : Type u_2} [add_group A] : subgroup (multiplicative A) ‚âÉo add_subgroup A
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] {f : J ‚Üí C} (t : category_theory.limits.bicone f) (ht : category_theory.limits.is_limit t.to_cone) : t.is_bilimit
(C : Type u) [category_theory.category C] [category_theory.locally_small C] : category_theory.shrink_homs C ‚•§ C
{Œ± : Type u_1} [preorder Œ±] (pred : Œ± ‚Üí Œ±) (hle_pred_iff : ‚àÄ {a b : Œ±}, a ‚â§ pred b ‚Üî a < b) (hle_of_pred_lt : ‚àÄ {a b : Œ±}, pred a < b ‚Üí a ‚â§ b) : pred_order Œ±
{Œ± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : filter Œ±} : f =o[l] g ‚Üí ‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ, 0 < c ‚Üí asymptotics.is_O_with c l f g
 : Type
{M : Type u_1} [has_add M] {s : set M} {p : M ‚Üí M ‚Üí Prop} {x y : M} (hx : x ‚àà add_subsemigroup.closure s) (hy : y ‚àà add_subsemigroup.closure s) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí ‚àÄ (y : M), y ‚àà s ‚Üí p x y) (Hmul_left : ‚àÄ (x y z : M), p x z ‚Üí p y z ‚Üí p (x + y) z) (Hmul_right : ‚àÄ (x y z : M), p z x ‚Üí p z y ‚Üí p z (x + y)) : p x y
{x y : pgame} (ox : x.numeric) (oy : y.numeric) : x ‚â§ y ‚Üî (‚àÄ (i : x.left_moves), x.move_left i < y) ‚àß ‚àÄ (j : y.right_moves), x < y.move_right j
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (has_vsub.vsub p)
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] (h : Œ± ‚âÉ·µ§ Œ≤) : Œ≤ ‚âÉ·µ§ Œ±
{X Y : Type u} : X ‚âÉ Y ‚âÖ X ‚âÖ Y
{R : Type u_1} {M : Type u_2} {N : Type u_3} [has_zero R] [has_zero M] [has_zero N] [has_scalar R M] [has_scalar R N] [no_zero_smul_divisors R N] (f : M ‚Üí N) (hf : function.injective f) (h0 : f 0 = 0) (hs : ‚àÄ (c : R) (x : M), f (c ‚Ä¢ x) = c ‚Ä¢ f x) : no_zero_smul_divisors R M
{T : Type u‚ÇÅ} [category_theory.category T] (X : T) : category_theory.limits.cone (category_theory.under.forget X)
(f f' : ‚Ñù ‚Üí ‚Ñù) {a b : ‚Ñù} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hff' : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí has_deriv_at f (f' x) x) : ‚àÉ (c : ‚Ñù) (H : c ‚àà set.Ioo a b), f' c = (f b - f a) / (b - a)
(t : Type u ‚Üí Type u) [traversable t] : Type (u+1)
 : ‚Ñï ‚Üí tactic unit
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (direction : submodule k V) : ‚Üë(affine_subspace.mk' p direction).nonempty
 : list expr ‚Üí expr_set ‚Üí tactic expr_set
{Œ± : Type u_1} [partial_order Œ±] [pred_order Œ±] [is_pred_archimedean Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) {n m : Œ±} (h : ‚àÄ (i : Œ±), i ‚àà set.Ioc n m ‚Üí r (order.pred i) i) (hmn : n < m) : relation.trans_gen r n m
(p : ‚Ñï) [hp : fact (nat.prime p)] (n : ‚Ñï) {m : ‚Ñï} (hm : n ‚â§ m) : (truncated_witt_vector.zmod_equiv_trunc p n).symm.to_ring_hom.comp (truncated_witt_vector.truncate hm) = (zmod.cast_hom _ (zmod (p ^ n))).comp (truncated_witt_vector.zmod_equiv_trunc p m).symm.to_ring_hom
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (e : local_homeomorph Œ± Œ≤) {f : Œ≥ ‚Üí Œ±} (h : f ‚Åª¬π' e.to_local_equiv.source = set.univ) : continuous f ‚Üî continuous (‚áëe ‚àò f)
(i j : ‚Ñ§) : ‚Ñï
(Œ± : Type u_2) [cancel_comm_monoid_with_zero Œ±] : Type u_2
{Œ± : Type u_1} [has_add Œ±] [linear_order Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] (m : Œ±) : Œ± ‚Ü™o Œ±
(q : interactive.parse interactive.types.texpr) : tactic unit
{n : ‚Ñï} : nat.fib (n + 2) = nat.fib n + nat.fib (n + 1)
{V : Type u} {G : simple_graph V} (P : G.partition) : G.coloring ‚Ü•(P.parts)
{Œ± : Type u} {Œ≤ : Type v} [semiring Œ±] [semiring Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_semiring_hom f) : is_monoid_hom f
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : has_zero (lie_submodule R L M)
(X : algebraic_geometry.LocallyRingedSpace) : (category_theory.induced_functor prime_spectrum.basic_open).op ‚ãô (algebraic_geometry.Spec.structure_sheaf ‚Ü•(algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X))).val ‚ü∂ (category_theory.induced_functor prime_spectrum.basic_open).op ‚ãô ((Top.sheaf.pushforward X.to_Œì_Spec_base).obj X.ùí™).val
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] {E : Type u‚ÇÉ} [category_theory.category E] [category_theory.monoidal_category E] [category_theory.braided_category E] (F : category_theory.lax_braided_functor C D) (G : category_theory.lax_braided_functor D E) : category_theory.lax_braided_functor C E
{M : Type u_1} [add_zero_class M] : complete_lattice (add_submonoid M)
{V : Type u_4} [inner_product_space ‚ÑÇ V] (T : V ‚Üí‚Çó[‚ÑÇ] V) : inner_product_space.is_self_adjoint T ‚Üî ‚àÄ (v : V), ‚áë(star_ring_end ‚ÑÇ) (has_inner.inner (‚áëT v) v) = has_inner.inner (‚áëT v) v
{Œ± : Type u_1} (l : filter Œ±) : filter (set Œ±)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s‚ÇÅ s‚ÇÇ : affine_subspace k P} {p : P} (h : p ‚àà s‚ÇÅ ‚äì s‚ÇÇ) : (s‚ÇÅ ‚äì s‚ÇÇ).direction = s‚ÇÅ.direction ‚äì s‚ÇÇ.direction
{Œπ : Type u_1} {X : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), topological_space (X i)] {as bs : Œ† (i : Œπ), X i} (Œ≥‚ÇÄ Œ≥‚ÇÅ : Œ† (i : Œπ), path (as i) (bs i)) (H : Œ† (i : Œπ), (Œ≥‚ÇÄ i).homotopy (Œ≥‚ÇÅ i)) : (path.pi Œ≥‚ÇÄ).homotopy (path.pi Œ≥‚ÇÅ)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} (h : ‚Üës.nonempty) : ‚Üë(s.direction) = ‚Üës -·µ• ‚Üës
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [linear_order Œπ] [Œ† (i : Œπ), linear_order (Œ± i)] : linear_order (Œ£‚Çó (i : Œπ), Œ± i)
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] {S : Type u_3} [set_like S N] [submonoid_class S N] (f : M ‚Üí* N) (s : S) (h : ‚àÄ (x : M), ‚áëf x ‚àà s) : M ‚Üí* ‚Ü•s
{Œ± : Type u} [pseudo_emetric_space Œ±] (x : Œ±) (s : set Œ±) : ennreal
{Œ± : Sort u_1} {p : Œ± ‚Üí Prop} (hp : ‚àÄ (a : Œ±), ¬¨p a) : is_empty (subtype p)
{Œ± : Type u_1} (x : slim_check.no_shrink Œ±) : Œ±
{F : Type} [field F] (q : ‚Ñï) [hF : exp_char F q] (f : polynomial F) [irred : irreducible f] : polynomial.has_separable_contraction q f
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {s : set E} {t : set F} {g : F ‚Üí G} {f : E ‚Üí F} (x : E) (hg : cont_diff_within_at ùïú n g t (f x)) (hf : cont_diff_within_at ùïú n f s x) (st : s ‚äÜ f ‚Åª¬π' t) : cont_diff_within_at ùïú n (g ‚àò f) s x
{ùïú : Type u_1} [linear_ordered_field ùïú] {s : set ùïú} : convex ùïú s ‚Üí s.ord_connected
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] (P : C·µí·µñ ‚•§ D) [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] (hP : category_theory.presheaf.is_sheaf J P) : P ‚âÖ J.plus_obj P
{m : Type v ‚Üí Type w} [applicative m] {Œ± : Type u_1} (f : ‚Ñï ‚Üí Œ± ‚Üí m punit) (as : list Œ±) : m punit
{Œ± : Type u_1} [decidable_eq Œ±] (s : finset Œ±) : finset (sym2 Œ±)
{F : Type u ‚Üí Type u} [functor F] [q : qpf F] (r : (qpf.P F).M ‚Üí (qpf.P F).M ‚Üí Prop) : Prop
(R : Type u) (M : Type v) (N : Type w) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [add_comm_group N] [module R N] [module.free R N] : module.rank R (M √ó N) = (module.rank R M).lift + (module.rank R N).lift
{V : Type u} [quiver V] (H : wide_subquiver (quiver.symmetrify V)) : wide_subquiver V
 : list expr ‚Üí expr
{Œ± : Type u} [semiring Œ±] (s : set Œ±) : ideal Œ±
{n : ‚Ñï} (c : composition n) : composition_as_set n
 : turing.to_partrec.code ‚Üí turing.to_partrec.cont ‚Üí list ‚Ñï ‚Üí turing.to_partrec.cfg
{X Y : Type u} [add_monoid X] [add_monoid Y] : X ‚âÉ+ Y ‚âÖ AddMon.of X ‚âÖ AddMon.of Y
(Œ± : Type u_1) [non_assoc_semiring Œ±] : Œ± ‚Üí+* Œ±
{Œπ : Type u‚ÇÅ} {k : Type u‚ÇÇ} {V : Type u‚ÇÉ} {P : Type u‚ÇÑ} [add_comm_group V] [add_torsor V P] [ring k] [module k V] (b : affine_basis Œπ k P) (i : Œπ) : P ‚Üí·µÉ[k] k
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x : V) (Œ∏ : real.angle) : ‚áë(hb.rotation Œ∏) x = x ‚Üî x = 0 ‚à® Œ∏ = 0
{Œ± : Type u_1} {n : ‚Ñï} (m : multiset Œ±) (h : ‚áëmultiset.card m = n) : sym Œ± n
{R‚ÇÇ : Type u_5} {M‚ÇÇ : Type u_6} [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] (B‚ÇÇ : bilin_form R‚ÇÇ M‚ÇÇ) : submodule R‚ÇÇ (module.End R‚ÇÇ M‚ÇÇ)
{C : Type u} [category_theory.category C] {F : C ‚•§ C} {A‚ÇÄ A‚ÇÅ : category_theory.endofunctor.algebra F} (h : A‚ÇÄ.A ‚âÖ A‚ÇÅ.A) (w : F.map h.hom ‚â´ A‚ÇÅ.str = A‚ÇÄ.str ‚â´ h.hom) : A‚ÇÄ ‚âÖ A‚ÇÅ
(b : binder) : string
{G : Type u_1} [group G] {Œπ : Type u_2} [hfin : fintype Œπ] {H : Œπ ‚Üí subgroup G} (hcomm : ‚àÄ (i j : Œπ), i ‚â† j ‚Üí ‚àÄ (x y : G), x ‚àà H i ‚Üí y ‚àà H j ‚Üí commute x y) : (Œ† (i : Œπ), ‚Ü•(H i)) ‚Üí* G
(R : Type u) [comm_ring R] (x : ‚Ü•(algebraic_geometry.prime_spectrum.Top R)) : (algebraic_geometry.Spec.structure_sheaf R).val.stalk x ‚âÖ CommRing.of (localization.at_prime (prime_spectrum.as_ideal x))
(a b : Prop) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_4} [partial_order Œ±] [preorder Œ≤] {u : Œ≤ ‚Üí Œ±} (l : lower_adjoint u) : closure_operator Œ±
{A : Type u_2} [normed_ring A] [normed_algebra ‚ÑÇ A] [complete_space A] (a : A) : filter.at_top.limsup (Œª (n : ‚Ñï), ‚Üë‚à•a ^ n‚à•‚Çä ^ (1 / ‚Üën)) ‚â§ spectral_radius ‚ÑÇ a
{X : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : Œ† (x : ùí∞.J), (ùí∞.obj x).open_cover) : X.open_cover
{R : Type u} [comm_ring R] {X‚ÇÅ X‚ÇÇ : Type u} {g‚ÇÅ : ring X‚ÇÅ} {g‚ÇÇ : ring X‚ÇÇ} {m‚ÇÅ : algebra R X‚ÇÅ} {m‚ÇÇ : algebra R X‚ÇÇ} (e : X‚ÇÅ ‚âÉ‚Çê[R] X‚ÇÇ) : Algebra.of R X‚ÇÅ ‚âÖ Algebra.of R X‚ÇÇ
{K : Type u} {L : Type v} [field K] [field L] (f : K ‚Üí+* L) (s : subfield K) : subfield L
{Œ≥ : Type} (l : ‚Ñï) : tactic (list (widget.html Œ≥))
{Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ±] [topological_space Œ≤] : has_coe_to_fun (spectral_map Œ± Œ≤) (Œª (_x : spectral_map Œ± Œ≤), Œ± ‚Üí Œ≤)
{R : Type u_1} [comm_semiring R] {A : Type u_2} [semiring A] (P Q : algebra R A) (w : ‚àÄ (r : R), ‚áë(algebra_map R A) r = ‚áë(algebra_map R A) r) : P = Q
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f : M ‚Üí+ N) : add_submonoid M
{X : Top} (U V : topological_space.opens ‚Ü•X) : U ‚äì V ‚ü∂ V
{H : Type u} {M : Type u_2} [topological_space H] (c : charted_space_core H M) : charted_space H M
(k : Type u_1) [division_ring k] {Œπ : Type u_4} (s : finset Œπ) : Œπ ‚Üí k
{G : Type u_1} [group G] (h : monoid.exponent_exists G) : monoid.is_torsion G
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Type (max u v)
{Œ± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {c : ‚Ñù} {g : Œ± ‚Üí F} {f' : Œ± ‚Üí E'} {l : filter Œ±} : asymptotics.is_O_with c l f' g ‚Üí asymptotics.is_O_with c l (Œª (x : Œ±), -f' x) g
{S : Type u_1} {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [monoid S] [distrib_mul_action S R] [smul_comm_class S R R] : has_scalar S (quadratic_form R M)
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : 0 ‚àà S
{R : Type u} [semiring R] (x : laurent_series R) : power_series R
(C : Type u‚ÇÅ) [category_theory.category C] : category_theory.monad C
{R‚ÇÅ : Type u_2} {R‚ÇÇ : Type u_3} {R‚ÇÉ : Type u_4} {M‚ÇÅ : Type u_10} {M‚ÇÇ : Type u_11} {M‚ÇÉ : Type u_12} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [semiring R‚ÇÉ] [add_comm_monoid M‚ÇÅ] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] {module_M‚ÇÅ : module R‚ÇÅ M‚ÇÅ} {module_M‚ÇÇ : module R‚ÇÇ M‚ÇÇ} {module_M‚ÇÉ : module R‚ÇÉ M‚ÇÉ} {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : R‚ÇÅ ‚Üí+* R‚ÇÉ} [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] (f : M‚ÇÇ ‚Üí‚Çõ‚Çó[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) (g : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ
(Œ± : Type) : Type
{Œ± : Type u_1} {n : Type u_4} [has_sub n] (v : n ‚Üí Œ±) : matrix n n Œ±
{Œ± : Type u_1} {m : measurable_space Œ±} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [topological_space M] [add_comm_monoid N] [topological_space N] (v : measure_theory.vector_measure Œ± M) (w : measure_theory.vector_measure Œ± N) : Prop
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (C : homological_complex V c) [category_theory.limits.has_zero_object V] [category_theory.limits.has_kernels V] {i j : Œπ} (r : c.rel i j) : ‚Üë(C.cycles i) ‚âÖ category_theory.limits.kernel (C.d i j)
{Œπ : Type u_1} {Œ± : Type u_2} [has_zero Œ±] (s : finset Œπ) (t : Œπ ‚Üí finset Œ±) : finset (Œπ ‚Üí‚ÇÄ Œ±)
(X : algebraic_geometry.LocallyRingedSpace) (r : ‚Ü•(algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X))) : X.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op ‚ä§) ‚ü∂ X.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op (X.to_Œì_Spec_map_basic_open r))
 : Type
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] [nonempty Œ±] [topological_space Œ≤] [has_zero Œ±] {f : Œ≤ ‚Üí Œ±} (hf : continuous f) (h : has_compact_support f) : bdd_above (set.range f)
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] [category_theory.limits.has_equalizers V] [category_theory.limits.has_cokernels V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] : cochain_complex.single‚ÇÄ V ‚ãô homology_functor V (complex_shape.up ‚Ñï) 0 ‚âÖ ùü≠ V
{Œ± : Type u_1} {s : set Œ±} : ‚ä•.is_clique s ‚Üí s.subsingleton
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) [category_theory.is_filtered J] : category_theory.limits.is_colimit (Mon.filtered_colimits.colimit_cocone F)
{f : Type u‚ÇÄ ‚Üí Type u‚ÇÅ} {g : Type (max u‚ÇÄ v‚ÇÄ) ‚Üí Type v‚ÇÅ} [uliftable f g] {Œ± : Type u‚ÇÄ} : f Œ± ‚Üí g (ulift Œ±)
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} (t : category_theory.limits.cotrident f) : (category_theory.limits.parallel_family f).obj category_theory.limits.walking_parallel_family.one ‚ü∂ ((category_theory.functor.const (category_theory.limits.walking_parallel_family J)).obj t.X).obj category_theory.limits.walking_parallel_family.one
{Œ± : Type u_1} [measurable_space Œ±] {m‚ÇÅ m‚ÇÇ : measure_theory.outer_measure Œ±} {op : ennreal ‚Üí ennreal} (h : ‚àÄ (s : set Œ±), ‚áëm‚ÇÅ s = op (‚áëm‚ÇÇ s)) (s : set Œ±) : ‚áë(m‚ÇÅ.trim) s = op (‚áë(m‚ÇÇ.trim) s)
(Œ± : Type u) [metric_space Œ±] [topological_space.separable_space Œ±] : Œ± ‚Üí ‚Ü•(lp (Œª (n : ‚Ñï), ‚Ñù) ‚ä§)
(Œ± : Type u_1) [preorder Œ±] [decidable_rel has_le.le] (finset_Icc : Œ± ‚Üí Œ± ‚Üí finset Œ±) (mem_Icc : ‚àÄ (a b x : Œ±), x ‚àà finset_Icc a b ‚Üî a ‚â§ x ‚àß x ‚â§ b) : locally_finite_order Œ±
 : expr ‚Üí tactic.norm_fin.eval_fin_m (expr √ó expr)
(Œ± : Type u_1) [measurable_space Œ±] : Type u_1
{M : Type u_1} (R : Type u_3) (A : Type u_4) [comm_semiring R] [semiring A] [algebra R A] [monoid M] [mul_semiring_action M A] [smul_comm_class M R A] (m : M) : A ‚Üí‚Çê[R] A
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [invertible 2] (Q : quadratic_form R M) (hB : Q.anisotropic) : (‚áëquadratic_form.associated' Q).nondegenerate
(G : Type u_1) [category_theory.groupoid G] : Type u_1
{L : first_order.language} {M : Type u_3} [L.Structure M] (S : L.substructure M) : Prop
{Œ± : Type u_2} (F : Type u_7) (A : out_param (set Œ±)) (Œ≤ : out_param (Type u_8)) [comm_monoid Œ±] [comm_monoid Œ≤] (n : ‚Ñï) [fun_like F Œ± (Œª (_x : Œ±), Œ≤)] : Type
{M : Type u_2} [add_comm_group M] {ùïú : Type u_1} [field ùïú] [module ùïú M] (f : M ‚âÉ‚Çó[ùïú] M) : ‚áëlinear_map.det ‚Üë(f.symm) = (‚áëlinear_map.det ‚Üëf)‚Åª¬π
{G : Type u} [category_theory.groupoid G] [is_free_groupoid G] (T : wide_subquiver (quiver.symmetrify (is_free_groupoid.generators G))) [quiver.arborescence ‚Ü•T] {X : Type u_1} [monoid X] (f : category_theory.End (root' T) ‚Üí* X) : G ‚•§ category_theory.single_obj X
{Œ± : Type u_1} [pseudo_emetric_space Œ±] {Œ¥seq : ‚Ñï ‚Üí ‚Ñù} (Œ¥seq_lim : filter.tendsto Œ¥seq filter.at_top (nhds 0)) (E : set Œ±) : filter.tendsto (Œª (n : ‚Ñï), thickened_indicator_aux (Œ¥seq n) E) filter.at_top (nhds ((closure E).indicator (Œª (x : Œ±), 1)))
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [semigroup M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) : semigroup M‚ÇÅ
{Œ± : Type u} [topological_space Œ±] [t2_space Œ±] {x y : Œ±} (h : x ‚â† y) : ‚àÉ (u v : set Œ±), is_open u ‚àß is_open v ‚àß x ‚àà u ‚àß y ‚àà v ‚àß u ‚à© v = ‚àÖ
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] (F : J ‚•§ C) : C ‚•§ Type (max u‚ÇÅ v‚ÇÉ)
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_type R A ‚Üî ‚àÉ (n : ‚Ñï) (f : mv_polynomial (fin n) R ‚Üí‚Çê[R] A), function.surjective ‚áëf
(K : Type u_1) [field K] : Prop
(A : Type u_1) [ring A] [algebra ‚Ñö A] : power_series A
{Œ± : Sort u} {Œ≤ : Sort v} {Œ≥ : Sort w} {Œ¥ : Sort x} (e‚ÇÅ : Œ± ‚âÉ Œ≤) (e‚ÇÇ : Œ≥ ‚âÉ Œ¥) (f : Œ± ‚Ü™ Œ≥) : Œ≤ ‚Ü™ Œ¥
(F : Type u_7) (Œ± : out_param (Type u_8)) (Œ≤ : out_param (Type u_9)) [has_inf Œ±] [has_inf Œ≤] [has_top Œ±] [has_top Œ≤] : Type (max u_7 u_8 u_9)
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 p : P} (h : p -·µ• p1 = p -·µ• p2) : p1 = p2
(R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A] : R ‚Üí‚Çê[R] A
{M : Type uM} {N : Type uN} {P : Type uP} {Q : Type uQ} [mul_one_class M] [mul_one_class N] [comm_monoid P] [comm_monoid Q] (f : M ‚Üí* N ‚Üí* P) (g : P ‚Üí* Q) : M ‚Üí* N ‚Üí* Q
{et : tactic.ring_exp.ex_type} : tactic.ring_exp.ex et ‚Üí string
 : tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt) ‚Üí tactic.rcases_patt
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (i : fin (n + 1)) (x : Œ± i) (p : Œ† (j : fin n), Œ± (‚áë(i.succ_above) j)) (j : fin (n + 1)) : Œ± j
{Œ± : Type u} [comm_semiring Œ±] {p p' ps ps' : Œ±} : p = p' ‚Üí ps = ps' ‚Üí p + ps = p' + ps'
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} {N : Type u_7} [add_comm_monoid M] [add_comm_monoid N] {f : Œ± ‚Üí Œ≤} {s : Œ± ‚Üí‚ÇÄ M} (h : Œ≤ ‚Üí M ‚Üí+ N) : (finsupp.map_domain f s).sum (Œª (b : Œ≤) (m : M), ‚áë(h b) m) = s.sum (Œª (a : Œ±) (m : M), ‚áë(h (f a)) m)
{M : Type u_3} {N : Type u_4} {hM : has_add M} {hN : has_add N} (f : add_hom M N) (f' : M ‚Üí N) (h : f' = ‚áëf) : add_hom M N
{Œ± : Sort u_1} {p : Œ± ‚Üí Prop} (P : ‚àÉ (a : Œ±), p a) : Œ±
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [has_zero M‚ÇÅ] [has_scalar ‚Ñï M‚ÇÅ] [has_neg M‚ÇÅ] [has_sub M‚ÇÅ] [has_scalar ‚Ñ§ M‚ÇÅ] [subtraction_comm_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (inv : ‚àÄ (x : M‚ÇÅ), f (-x) = -f x) (div : ‚àÄ (x y : M‚ÇÅ), f (x - y) = f x - f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : subtraction_comm_monoid M‚ÇÅ
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (X‚ÇÄ X‚ÇÅ X‚ÇÇ : V) (d‚ÇÄ : X‚ÇÄ ‚ü∂ X‚ÇÅ) (d‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (s : d‚ÇÄ ‚â´ d‚ÇÅ = 0) (succ : Œ† (t : Œ£' (X‚ÇÄ X‚ÇÅ X‚ÇÇ : V) (d‚ÇÄ : X‚ÇÄ ‚ü∂ X‚ÇÅ) (d‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ), d‚ÇÄ ‚â´ d‚ÇÅ = 0), Œ£' (X‚ÇÉ : V) (d‚ÇÇ : t.snd.snd.fst ‚ü∂ X‚ÇÉ), t.snd.snd.snd.snd.fst ‚â´ d‚ÇÇ = 0) : cochain_complex V ‚Ñï
(e : interactive.parse interactive.types.texpr) (ids : interactive.parse interactive.types.with_ident_list) : tactic unit
 : (user_attribute unit)
{a b k : ‚Ñï} (h_ab_coprime : a.coprime b) (hka : k ‚à£ a) (hkb : k ‚à£ b) : k = 1
{Œ± : Type u_1} [pseudo_metric_space Œ±] {Œ¥ : ‚Ñù} {E : set Œ±} (hE : is_compact E) (hŒ¥ : 0 ‚â§ Œ¥) : metric.cthickening Œ¥ E = ‚ãÉ (x : Œ±) (H : x ‚àà E), metric.closed_ball x Œ¥
{Œπ : Type u_1} {Œ± : Type u_2} [unique Œπ] [inhabited Œ±] : inhabited (indexed_partition (Œª (i : Œπ), set.univ))
{Œ± : Type u_1} {ùíú : finset (finset Œ±)} {A : finset Œ±} {r : ‚Ñï} : A ‚àà ùíú.slice r ‚Üî A ‚àà ùíú ‚àß A.card = r
{Œ± : Type u_3} {Œ≤ : Type u_4} [has_inf Œ±] [has_inf Œ≤] : inf_hom Œ± Œ≤ ‚âÉ sup_hom Œ±·µí·µà Œ≤·µí·µà
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Œπ] {p : Œπ ‚Üí P} (hi : affine_independent k p) {sm : submodule k V} [finite_dimensional k ‚Ü•sm] (hle : vector_span k (set.range p) ‚â§ sm) (hc : fintype.card Œπ = finite_dimensional.finrank k ‚Ü•sm + 1) : vector_span k (set.range p) = sm
{K : Type u_1} [linear_ordered_field K] {v : K} {n : ‚Ñï} [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n ‚Üí v = generalized_continued_fraction.comp_exact_value ((generalized_continued_fraction.of v).continuants_aux n) ((generalized_continued_fraction.of v).continuants_aux (n + 1)) ifp_n.fr
{R : Type u} [comm_semiring R] {A : Type v} [comm_semiring A] [algebra R A] : has_div (submodule R A)
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] {Z : C} (h : Y ‚ü∂ Z) [category_theory.mono h] : category_theory.limits.kernel_subobject (f ‚â´ h) = category_theory.limits.kernel_subobject f
{M : Type u_1} [add_zero_class M] {c d : add_con M} (h : c ‚â§ d) (x : c.quotient) : ‚áë(c.map d h) x = ‚áë(c.lift d.mk' _) x
{B : Type u} [quiver B] {a b c : B} (p : quiver.path a b) (f : category_theory.free_bicategory.hom b c) : (category_theory.free_bicategory.preinclusion B).map {as := p} ‚â´ f ‚âÖ (category_theory.free_bicategory.preinclusion B).map {as := category_theory.free_bicategory.normalize_aux p f}
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] (F : C ‚•§ D) [category_theory.reflects_isomorphisms F] (K : J ‚•§ C) : category_theory.reflects_isomorphisms (category_theory.limits.cones.functoriality K F)
{C : Type u‚ÇÅ} [category_theory.category C] {J : category_theory.grothendieck_topology C} {A : Type u‚ÇÇ} [category_theory.category A] (F : category_theory.Sheaf J A) (X : C) (H : ‚ä• ‚àà ‚áëJ X) : category_theory.limits.is_terminal (F.val.obj (opposite.op X))
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (d : D) : (category_theory.structured_arrow d F)·µí·µñ ‚âå category_theory.costructured_arrow F.op (opposite.op d)
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [S : Œ† (i : Œπ), setoid (Œ± i)] (f : Œ† (i : Œπ), quotient (S i)) : quotient pi_setoid
(Œì : tactic.itauto.context) (A : tactic.itauto.prop) (p : tactic.itauto.proof) (B : tactic.itauto.prop) (f : tactic.itauto.context ‚Üí tactic.itauto.prop ‚Üí ‚Ñï ‚Üí bool √ó tactic.itauto.proof √ó ‚Ñï) (n : ‚Ñï) : bool √ó tactic.itauto.proof √ó ‚Ñï
{R : Type u} {M : Type v} [has_zero R] (m : M) : triv_sq_zero_ext R M
{R : Type u_1} {M : Type u_2} [monoid R] [add_comm_monoid M] [distrib_mul_action R M] {p : R} (hM : module.is_torsion' M ‚Ü•(submonoid.powers p)) (x : M) [Œ† (n : ‚Ñï), decidable (p ^ n ‚Ä¢ x = 0)] : ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [has_zero M] (f : Œ± ‚âÉ Œ≤) (l : Œ± ‚Üí‚ÇÄ M) : Œ≤ ‚Üí‚ÇÄ M
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [add_comm_monoid Œπ] [decidable_eq Œπ] [comm_ring R] [comm_ring A] [algebra R A] {ùíú : Œπ ‚Üí submodule R A} [graded_algebra ùíú] {x : ideal A} [x.is_prime] (y : homogeneous_localization ùíú x) : localization.at_prime x
(Œ± : Type u) : Type u
{G : Type u_3} [group G] (P : subgroup G) : P.fg ‚Üî ‚àÉ (S : set G), subgroup.closure S = P ‚àß S.finite
{Œ± : Type uu} (l‚ÇÅ l‚ÇÇ : list Œ±) : Prop
(env : environment) (d : declaration) : bool
{ùïú : Type u_2} [field ùïú] [topological_space ??] [topological_ring ùïú] (a b : ùïú) (h : a ‚â† 0) : ùïú ‚âÉ‚Çú ùïú
(u : pnat.xgcd_type) : Prop
 : lean.parser tactic.eliminate.with_pattern
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (C : homological_complex V c) [category_theory.limits.has_zero_object V] (j : Œπ) : C.X_prev j ‚ü∂ C.X j
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.preadditive C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} {P : category_theory.ProjectiveResolution Y} {Q : category_theory.ProjectiveResolution Z} (f : P.complex ‚ü∂ Q.complex) (comm : f ‚â´ Q.œÄ = 0) : homotopy f 0
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) : list Œ± ‚Üí list Œ≤ ‚Üí list Œ≥ ‚Üí list Œ¥
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_5} [decidable_eq Œ≥] {f f' : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s : finset Œ±} {t : finset Œ≤} (h : ‚àÄ (a : Œ±) (b : Œ≤), f a b = f' a b) : finset.image‚ÇÇ f s t = finset.image‚ÇÇ f' s t
{Œ± : Type u_1} {Œ≤ : Type u_2} {e : local_equiv Œ± Œ≤} {s : set Œ±} {t : set Œ≤} : e.is_image s t ‚Üí e.source ‚à© ‚áëe ‚Åª¬π' t = e.source ‚à© s
 : cc_state ‚Üí bool
{C : Type u} [category_theory.category C] : category_theory.limits.is_initial category_theory.with_initial.star
 : expr ‚Üí option tactic.norm_fin.match_fin_result
{M : Type u_1} {N : Type u_2} [monoid M] [monoid N] {f : M ‚Üí N} (hf : is_monoid_hom f) : MÀ£ ‚Üí* NÀ£
(Œ± : Type u_1) : Type u_1
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} {F : Top.presheaf C X} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) {G : Top.presheaf C X} (Œ± : F ‚âÖ G) : Top.presheaf.sheaf_condition_equalizer_products.pi_opens F U ‚âÖ Top.presheaf.sheaf_condition_equalizer_products.pi_opens G U
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [linear_order Œ±] [topological_space Œ≥] {a b : Œ±} {h : a ‚â§ b} [topological_space Œ±] [order_topology Œ±] [topological_space Œ≤] {f : Œ≥ ‚Üí ‚Ü•(set.Icc a b) ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±} (hf : continuous ‚Üøf) (hg : continuous g) : continuous (Œª (a_1 : Œ≥), set.Icc_extend h (f a_1) (g a_1))
{G : Type u_1} [group G] (H : subgroup G) : H = ‚ä• ‚à® nontrivial ‚Ü•H
{R : Type u_1} {G : Type u_4} [group G] [mul_action G R] (g : G) : is_smul_regular R g
{Œ± : Type u} {Œ≤ : Type v} [has_add Œ±] [has_add Œ≤] {Œ≥ : Type u_1} [has_add Œ≥] {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hf : is_add_hom f) (hg : is_add_hom g) : is_add_hom (g ‚àò f)
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [add_zero_class Œπ] [graded_monoid.ghas_mul A] : has_mul (A 0)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] (T : category_theory.triangulated.triangle C) : category_theory.triangulated.triangle C
(Œ± : Type u_2) [topological_space Œ±] [preorder Œ±] : esakia_hom Œ± Œ±
{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X ‚Üí Y} : lipschitz_with C f ‚Üí holder_with C 1 f
 : list omega.clause ‚Üí tactic expr
{C : Type u} [category_theory.category C] (X Y : C) : Type v
(p : pos_num) : ‚Ñï ‚Üí pos_num
{C : Type u‚ÇÅ} [category_theory.category C] : C ‚•§ ulift C
(R : Type u) [semiring R] (Œπ : Type v) (M : Œπ ‚Üí Type w) [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] (i : Œπ) : direct_sum Œπ (Œª (i : Œπ), M i) ‚Üí‚Çó[R] M i
{Œπ : Type u_1} (M : Œπ ‚Üí Type u_2) [Œ† (j : Œπ), has_add (M j)] [subsingleton Œπ] (i : Œπ) : (Œ† (j : Œπ), M j) ‚âÉ+ M i
(m M N : ‚Ñï) : set (Œ£ (n : ‚Ñï), composition n)
{ùïú : Type u_3} [field ùïú] {r : ‚Ñï} (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) (hM : M (sum.inr ()) (sum.inr ()) ‚â† 0) (i : fin r) : ((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod (sum.inl i) (sum.inr ()) = 0
 : linarith.comp ‚Üí list ‚Ñï
{S : Type u'} {R : Type u} {M : Type v} [monoid R] [mul_action R M] [monoid S] [has_scalar S R] [mul_action S M] [is_scalar_tower S R M] (p : sub_mul_action R M) : mul_action S ‚Ü•p
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ‚Üí+* S) : subsemiring S
{C : Type u‚ÇÅ} [category_theory.category C] (J : category_theory.grothendieck_topology C) (A : Type u‚ÇÇ) [category_theory.category A] : category_theory.Sheaf J A ‚•§ C·µí·µñ ‚•§ A
{Œ± : Type u_1} [partial_order Œ±] [pred_order Œ±] [is_pred_archimedean Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) {n m : Œ±} (h : ‚àÄ (i : Œ±), i ‚àà set.Ioc n m ‚Üí r (order.pred i) i) (hmn : n ‚â§ m) : relation.refl_trans_gen r n m
{w x y z : pgame} : w.relabelling x ‚Üí y.relabelling z ‚Üí (w + y).relabelling (x + z)
 : Lattice ‚âå Lattice
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [add_comm_monoid Œ≤] {s : finset Œ≥} {t : Œ≥ ‚Üí finset Œ±} {t' : finset Œ±} {s' : Œ± ‚Üí finset Œ≥} (h : ‚àÄ (x : Œ≥) (y : Œ±), x ‚àà s ‚àß y ‚àà t x ‚Üî x ‚àà s' y ‚àß y ‚àà t') {f : Œ≥ ‚Üí Œ± ‚Üí Œ≤} : s.sum (Œª (x : Œ≥), (t x).sum (Œª (y : Œ±), f x y)) = t'.sum (Œª (y : Œ±), (s' y).sum (Œª (x : Œ≥), f x y))
(C : Type u) [category_theory.category C] [‚àÄ {J : Type v} {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)}, category_theory.limits.has_colimit (category_theory.limits.parallel_family f)] : category_theory.limits.has_wide_coequalizers C
 : category_theory.discrete pempty ‚âå category_theory.discrete pempty
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [complete_lattice Œ±] [complete_lattice Œ≤] [complete_lattice Œ≥] (f : complete_lattice_hom Œ≤ Œ≥) (g : complete_lattice_hom Œ± Œ≤) : complete_lattice_hom Œ± Œ≥
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} : (‚àÉ (b : Œ±), ‚àÄ (x : Œ≤), r (u x) b) ‚Üí filter.is_bounded_under r f u
(h : expr) : tactic (expr √ó expr)
{Œ± : Type u_1} [field Œ±] (E : linear_recurrence Œ±) : module.rank Œ± ‚Ü•(E.sol_space) = ‚Üë(E.order)
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b : Œ±} (ha : a ‚â§ 1) (hb : b ‚â§ 1) : a * b ‚â§ 1
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] (X Y : C) (F : C ‚•§ D) [F.preserves_zero_morphisms] : Type (max u u‚ÇÇ v)
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] {M‚ÇÅ' : Œπ ‚Üí Type u_1} [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ' i)] [Œ† (i : Œπ), module R (M‚ÇÅ' i)] {M‚ÇÅ'' : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ'' i)] [Œ† (i : Œπ), module R (M‚ÇÅ'' i)] (g : multilinear_map R M‚ÇÅ'' M‚ÇÇ) (f‚ÇÅ : Œ† (i : Œπ), M‚ÇÅ' i ‚Üí‚Çó[R] M‚ÇÅ'' i) (f‚ÇÇ : Œ† (i : Œπ), M‚ÇÅ i ‚Üí‚Çó[R] M‚ÇÅ' i) : (g.comp_linear_map f‚ÇÅ).comp_linear_map f‚ÇÇ = g.comp_linear_map (Œª (i : Œπ), (f‚ÇÅ i).comp (f‚ÇÇ i))
{Œ± : Type u_2} {Œ≤ : Type u_3} [monoid Œ±] [mul_action Œ± Œ≤] : mul_action (filter Œ±) (filter Œ≤)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (G : C ‚•§ D) [G.preserves_zero_morphisms] {X Y Z : C} {f : X ‚ü∂ Y} {h : Z ‚ü∂ X} (w : h ‚â´ f = 0) [category_theory.limits.preserves_limit (category_theory.limits.parallel_pair f 0) G] (l : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ h w)) : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ (G.map h) _)
{X Y : CommGroup} (e : ‚Ü•X ‚âÉ* ‚Ü•Y) : X ‚âÖ Y
{ùïú : Type u} [nondiscrete_normed_field ùïú] {E : Type v} [normed_group E] [normed_space ùïú E] [complete_space ùïú] {Œπ : Type u_1} [fintype Œπ] (v : basis Œπ ùïú E) : E ‚âÉL[ùïú] Œπ ‚Üí ùïú
(R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] (p : ‚Ñï) [char_p R p] : char_p K p
(n : ‚Ñï) : iterated_deriv n (exp_neg_inv_glue.f_aux 0) = exp_neg_inv_glue.f_aux n
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : rel Œ± Œ≤) (s : set Œ≤) : set Œ±
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (ha : continuous_at f a) : has_strict_deriv_at (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in u..b, f x) (-f a) a
{B : Type u} [category_theory.bicategory B] {a b c : B} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : g ‚âÖ h) : f ‚â´ g ‚âÖ f ‚â´ h
{Œ± : Type u_1} [h : normed_lattice_add_comm_group Œ±] : ordered_add_comm_group Œ±
{Œ± : Type u} (p : Œ± ‚Üí Prop) (f : filter Œ±) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : r ‚âÉr s) : function.swap r ‚âÉr function.swap s
{R : Type u_1} [comm_semiring R] : polynomial R ‚Üí‚Çê[R] laurent_polynomial R
{Œ± : Type u} : ordnode Œ± ‚Üí option Œ±
(Œ± : Type u_6) (Œ≤ : Type u_7) [preorder Œ±] [preorder Œ≤] [bounded_order Œ±] [bounded_order Œ≤] : Type (max u_6 u_7)
(R : Type u) (M : Type v) (M‚ÇÇ : Type w) [comm_semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] : module.End R M √ó module.End R M‚ÇÇ ‚Üí‚Çê[R] module.End R (M √ó M‚ÇÇ)
(Œ± i : expr) : tactic unit
 : (user_attribute unit)
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {T : submonoid P} {Q : Type u_4} [comm_monoid Q] (k : T.localization_map Q) {j : M ‚âÉ* P} (H : submonoid.map j.to_monoid_hom S = T) : N ‚âÉ* Q
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] (xs : list Œ±) (h : ‚àÄ (x : Œ±), x ‚àà xs ‚Üí ¬¨p x) : list.split_on_p p xs = [xs]
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K ‚Üí ratfunc K ‚Üí ratfunc K
 : omega.nat.preform ‚Üí omega.nat.preform
{n : ‚Ñï} : {f // ‚àÄ (a b : pSet.resp n), a.equiv b ‚Üí f a = f b}
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} [comm_ring R] [lie_ring L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÅ] [lie_algebra R L‚ÇÇ] (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : L‚ÇÇ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÅ
{M : Type u_1} [has_add M] : has_add (ultrafilter M)
(L : first_order.language) : L.Structure unit
(h : expr) : tactic bool
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) [complete_space E] [complete_space ‚Ü•K] (u v : E) : has_inner.inner ‚Üë(‚áë(orthogonal_projection K) u) v = has_inner.inner u ‚Üë(‚áë(orthogonal_projection K) v)
(C : Type u) [category_theory.category C] : Prop
{X : Type v} [topological_space X] [locally_compact_space X] [sigma_compact_space X] [t2_space X] {Œπ : X ‚Üí Type u} {p : Œ† (x : X), Œπ x ‚Üí Prop} {B : Œ† (x : X), Œπ x ‚Üí set X} (hB : ‚àÄ (x : X), (nhds x).has_basis (p x) (B x)) : ‚àÉ (Œ± : Type v) (c : Œ± ‚Üí X) (r : Œ† (a : Œ±), Œπ (c a)), (‚àÄ (a : Œ±), p (c a) (r a)) ‚àß (‚ãÉ (a : Œ±), B (c a) (r a)) = set.univ ‚àß locally_finite (Œª (a : Œ±), B (c a) (r a))
{G : Type u_1} [group G] {Œπ : Sort u_2} (S : Œπ ‚Üí subgroup G) {C : G ‚Üí Prop} {x : G} (hx : x ‚àà ‚®Ü (i : Œπ), S i) (hp : ‚àÄ (i : Œπ) (x : G), x ‚àà S i ‚Üí C x) (h1 : C 1) (hmul : ‚àÄ (x y : G), C x ‚Üí C y ‚Üí C (x * y)) : C x
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} (F : Top.presheaf C X) {x y : ‚Ü•X} (h : x ‚§≥ y) : F.stalk y ‚ü∂ F.stalk x
{Œ± : Type u} (lt : Œ± ‚Üí Œ± ‚Üí Prop) [decidable_rel lt] (x : Œ±) : tree Œ± ‚Üí option pos_num
{G : Type u_1} [group G] (H : subgroup G) : has_pow ‚Ü•H ‚Ñï
(n : ‚Ñï) : sSet.boundary n ‚ü∂ sSet.standard_simplex.obj (simplex_category.mk n)
(p : ‚Ñï) [hp : fact (nat.prime p)] {k : Type u_1} [field k] [char_p k p] [is_alg_closed k] {a‚ÇÅ a‚ÇÇ : witt_vector p k} (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0) (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) : ‚Ñï ‚Üí k
{F : Type u_3} [inner_product_space ‚Ñù F] (x y : F) : has_inner.inner x y * has_inner.inner x y ‚â§ has_inner.inner x x * has_inner.inner y y
{Œ± : Type u_1} (x : Œ±) : slim_check.large Œ±
{B : Type u} [category_theory.bicategory B] {a b : B} (f : a ‚ü∂ b) : Type (max u v)
{Œπ : Sort u_1} {Œ± : Type u_2} [complete_lattice Œ±] (t : Œπ ‚Üí Œ±) : Prop
{J : Type u} [category_theory.category J] (F : J ‚•§ Type w) : set (Œ† (j : J), F.obj j)
{Œ± : Type u_1} (p : Prop) (f : p ‚Üí part Œ±) : part Œ±
(x : ‚Ñù) : ‚Ñù
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
(m : Type u) (n : Type u') (Œ± : Type v) : Type (max u u' v)
{Œ± : Sort u_1} {C : trunc Œ± ‚Üí Sort u_3} (q : trunc Œ±) (f : Œ† (a : Œ±), C (trunc.mk a)) (h : ‚àÄ (a b : Œ±), eq.rec (f a) _ = f b) : C q
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {s t : set Œ±} (hs : (s ‚à© function.support f).finite) (ht : (t ‚à© function.support f).finite) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s ‚à™ t), f i)) + finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s ‚à© t), f i)) = finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)) + finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà t), f i))
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C·µí·µñ ‚•§ D) [category_theory.limits.preserves_colimit K.op F] : category_theory.limits.preserves_limit K F.right_op
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] (f : ‚ÑÇ ‚Üí E) (f' : ‚ÑÇ ‚Üí (‚ÑÇ ‚ÜíL[‚Ñù] E)) (z w : ‚ÑÇ) (s : set ‚ÑÇ) (hs : s.countable) (Hc : continuous_on f (set.interval z.re w.re √ó‚ÑÇ set.interval z.im w.im)) (Hd : ‚àÄ (x : ‚ÑÇ), x ‚àà set.Ioo (linear_order.min z.re w.re) (linear_order.max z.re w.re) √ó‚ÑÇ set.Ioo (linear_order.min z.im w.im) (linear_order.max z.im w.im)  s ‚Üí has_fderiv_at f (f' x) x) (Hi : measure_theory.integrable_on (Œª (z : ‚ÑÇ), complex.I ‚Ä¢ ‚áë(f' z) 1 - ‚áë(f' z) complex.I) (set.interval z.re w.re √ó‚ÑÇ set.interval z.im w.im) measure_theory.measure_space.volume) : (((‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üë(z.im) * complex.I)) - ‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üë(w.im) * complex.I)) + complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üë(w.re) + ‚Üëy * complex.I)) - complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üë(z.re) + ‚Üëy * complex.I) = ‚à´ (x : ‚Ñù) in z.re..w.re, ‚à´ (y : ‚Ñù) in z.im..w.im, complex.I ‚Ä¢ ‚áë(f' (‚Üëx + ‚Üëy * complex.I)) 1 - ‚áë(f' (‚Üëx + ‚Üëy * complex.I)) complex.I
(Œ± : Type u_1) : sym2 Œ± ‚âÉ sym Œ± 2
{L : first_order.language} {Œ± : Type u'} {n l : ‚Ñï} (R : L.relations n) (ts : fin n ‚Üí L.term (Œ± ‚äï fin l)) : L.bounded_formula Œ± l
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a : Œ±} : a‚Åª¬π ‚â§ 1 ‚Üî 1 ‚â§ a
{C : Type u‚ÇÅ} [category_theory.category C] (G : category_theory.comonad C) : G.coalgebra ‚•§ C
{Œ± : Type u_2} {Œ≤ : Type u_3} [decidable_eq Œ≤] [monoid Œ±] [add_monoid Œ≤] [distrib_mul_action Œ± Œ≤] : distrib_mul_action Œ± (finset Œ≤)
{G : Type u} [category_theory.groupoid G] [is_free_groupoid G] (T : wide_subquiver (quiver.symmetrify (is_free_groupoid.generators G))) [quiver.arborescence ‚Ü•T] {a b : G} (p : a ‚ü∂ b) : category_theory.End (root' T)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (F : C √ó D ‚•§ E) : C ‚•§ D ‚•§ E
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] : (M·µÉ·µí·µñ ‚Üí+ N·µÉ·µí·µñ) ‚âÉ (M ‚Üí+ N)
(M : Type u_1) [measurable_space M] [has_add M] : Prop
{Œ± : Type u_1} : has_mem (set Œ±) (filter_basis Œ±)
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [invertible 2] {Q : quadratic_form R M} (hB‚ÇÅ : ‚áëquadratic_form.associated' Q ‚â† 0) : ‚àÉ (x : M), ‚áëQ x ‚â† 0
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] {Œ± : E} (h : is_integral F Œ±) : adjoin_root (minpoly F Œ±) ‚âÉ‚Çê[F] ‚Ü•F‚üÆŒ±‚üØ
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] (F : C ‚Üí D) [I‚ÇÅ : category_theory.functorial F] [I‚ÇÇ : category_theory.lax_monoidal F] : category_theory.lax_monoidal_functor C D
{Œ± : Type u} [pseudo_emetric_space Œ±] {x y : Œ±} {s t : set Œ±} (xs : x ‚àà s) (yt : y ‚àà t) : emetric.diam (s ‚à™ t) ‚â§ emetric.diam s + has_edist.edist x y + emetric.diam t
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] (v : valuation R Œì‚ÇÄ) : preorder R
{Œ± : Sort u} {Œ≤ : Sort v} (e : Œ± ‚âÉ Œ≤) : Œ≤ ‚âÉ Œ±
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} [ring_hom_isometric œÉ‚ÇÅ‚ÇÇ] (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F) (M : nnreal) (hM : ‚àÄ (x : E), ‚à•‚áëf x‚à•‚Çä ‚â§ M * ‚à•x‚à•‚Çä) : ‚à•f‚à•‚Çä ‚â§ M
{Œ± : Type u_2} [has_zero Œ±] : zero_hom Œ± (finset Œ±)
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] {f g : ‚ÑÇ ‚Üí E} (hdf : diff_cont_on_cl ‚ÑÇ f (set.Ioi 0 √ó‚ÑÇ set.Iio 0)) (hBf : ‚àÉ (c : ‚Ñù) (H : c < 2) (B : ‚Ñù), f =O[filter.comap complex.abs filter.at_top ‚äì filter.principal (set.Ioi 0 √ó‚ÑÇ set.Iio 0)] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)) (hdg : diff_cont_on_cl ‚ÑÇ g (set.Ioi 0 √ó‚ÑÇ set.Iio 0)) (hBg : ‚àÉ (c : ‚Ñù) (H : c < 2) (B : ‚Ñù), g =O[filter.comap complex.abs filter.at_top ‚äì filter.principal (set.Ioi 0 √ó‚ÑÇ set.Iio 0)] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)) (hre : ‚àÄ (x : ‚Ñù), 0 ‚â§ x ‚Üí f ‚Üëx = g ‚Üëx) (him : ‚àÄ (x : ‚Ñù), x ‚â§ 0 ‚Üí f (‚Üëx * complex.I) = g (‚Üëx * complex.I)) : set.eq_on f g {z : ‚ÑÇ | 0 ‚â§ z.re ‚àß z.im ‚â§ 0}
{R : Type u} [ring R] {M : Type u_1} [linear_ordered_add_comm_group M] [module R M] (S : submodule R M) : linear_ordered_add_comm_group ‚Ü•S
{M : Type u_4} [group_with_zero M] {f g : ‚Ñö ‚Üí*‚ÇÄ M} (same_on_neg_one : ‚áëf (-1) = ‚áëg (-1)) (same_on_pnat : ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚áëf ‚Üën = ‚áëg ‚Üën) : f = g
 : linter
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) : AddCommGroup.colimits.prequotient F ‚Üí AddCommGroup.colimits.prequotient F ‚Üí Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : local_equiv Œ± Œ≤) : e.trans e.symm ‚âà local_equiv.of_set e.source
(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : is_domain K
{R : Type u_1} [comm_ring R] (u v w x : fin 3 ‚Üí R) : matrix.dot_product (‚áë(‚áëcross_product u) v) (‚áë(‚áëcross_product w) x) = matrix.dot_product u w * matrix.dot_product v x - matrix.dot_product u x * matrix.dot_product v w
(R : Type u) [comm_semiring R] (p : ‚Ñï) : polynomial R ‚Üí‚Çê[R] polynomial R
{Œπ : Type u} (s : finset Œπ) (f : Œπ ‚Üí ennreal) {p : ‚Ñù} (hp : 1 ‚â§ p) : s.sum (Œª (i : Œπ), f i) ^ p ‚â§ ‚Üë(s.card) ^ (p - 1) * s.sum (Œª (i : Œπ), f i ^ p)
{R : Type u} {M : Type v} [group R] [mul_action R M] {p : sub_mul_action R M} (m : ‚Ü•p) : mul_action.stabilizer R m = mul_action.stabilizer R ‚Üëm
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] (a b : Œ±) : multiset Œ±
{Œ± : Type u} (t : tactic Œ±) : tactic unit
{R : Type u_1} {M : Type u_2} {Œπ : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype Œπ] (b : basis Œπ R M) : module.finite R M
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : category_theory.limits.cospan f g ‚ãô F ‚âÖ category_theory.limits.walking_cospan_functor ‚ãô category_theory.limits.cospan (F.map f) (F.map g)
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [dec : decidable_eq Œπ] {Œ∫ : Type u_1} [Œ† (i : Œπ), has_zero (Œ≤ i)] (h : Œ∫ ‚Üí Œπ) (hh : function.injective h) : (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚Üí (Œ†‚ÇÄ (k : Œ∫), Œ≤ (h k))
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ‚ü∂ Q) : (‚àÄ (a : ‚Ü•P), ‚áëf a = 0) ‚Üí f = 0
(X : Type u_1) [topological_space X] [locally_compact_space X] [sigma_compact_space X] : compact_exhaustion X
{V : Type u} [category_theory.category V] [category_theory.abelian V] {A B C D A' B' C' D' : V} {f : A ‚ü∂ B} {g : B ‚ü∂ C} {h : C ‚ü∂ D} {f' : A' ‚ü∂ B'} {g' : B' ‚ü∂ C'} {h' : C' ‚ü∂ D'} {Œ± : A ‚ü∂ A'} {Œ≤ : B ‚ü∂ B'} {Œ≥ : C ‚ü∂ C'} {Œ¥ : D ‚ü∂ D'} (comm‚ÇÅ : Œ± ‚â´ f' = f ‚â´ Œ≤) (comm‚ÇÇ : Œ≤ ‚â´ g' = g ‚â´ Œ≥) (comm‚ÇÉ : Œ≥ ‚â´ h' = h ‚â´ Œ¥) (hgh : category_theory.exact g h) (hf'g' : category_theory.exact f' g') (hg'h' : category_theory.exact g' h') (hŒ± : category_theory.epi Œ±) (hŒ≥ : category_theory.epi Œ≥) (hŒ¥ : category_theory.mono Œ¥) : category_theory.epi Œ≤
{R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a)) : is_right_regular b
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G : J ‚•§ C} (Œ± : F ‚âÖ G) (c : category_theory.limits.cocone F) : category_theory.limits.is_colimit ((category_theory.limits.cocones.precompose Œ±.inv).obj c) ‚âÉ category_theory.limits.is_colimit c
{V : Type u} (G : simple_graph V) {Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] [fintype Œ≤] (hn : fintype.card Œ± ‚â§ fintype.card Œ≤) : G.coloring Œ± ‚Ü™ G.coloring Œ≤
{M : Type u_6} {N : Type u_7} [has_add M] [has_add N] {f g : M ‚âÉ+ N} (h : ‚àÄ (x : M), ‚áëf x = ‚áëg x) : f = g
{b : ‚Ñï} (hb : 1 < b) {x y : ‚Ñï} (hy : 0 < y) : b ^ x ‚â§ y ‚Üî x ‚â§ nat.log b y
 : interactive.parse (optional (lean.parser.tk "?")) ‚Üí interactive.parse (lean.parser.many tactic.rintro_patt_parse_hi) ‚Üí interactive.parse (optional (lean.parser.tk ":" *> lean.parser.small_nat)) ‚Üí tactic unit
{Œ± : Type u_1} [uniform_space Œ±] [compact_space Œ±] [separated_space Œ±] : uniformity Œ± = ‚®Ü (x : Œ±), nhds (x, x)
{F : Type u_1} [field F] (p : polynomial F) (E : Type u_2) [field E] [algebra F E] [fact (polynomial.splits (algebra_map F E) p)] : ‚Ü•(p.root_set p.splitting_field) ‚âÉ ‚Ü•(p.root_set E)
 : expr ‚Üí expr ‚Üí expr ‚Üí expr √ó expr ‚Üí expr √ó expr ‚Üí tactic.norm_fin.eval_fin_m expr
(A : Type u_9) [add_zero_class A] : Type u_9
{G : Type u_1} [group G] (p‚ÇÅ p‚ÇÇ : ‚Ñï) [hp‚ÇÅ : fact (nat.prime p‚ÇÅ)] [hp‚ÇÇ : fact (nat.prime p‚ÇÇ)] (hne : p‚ÇÅ ‚â† p‚ÇÇ) (H‚ÇÅ H‚ÇÇ : subgroup G) (hH‚ÇÅ : is_p_group p‚ÇÅ ‚Ü•H‚ÇÅ) (hH‚ÇÇ : is_p_group p‚ÇÇ ‚Ü•H‚ÇÇ) : disjoint H‚ÇÅ H‚ÇÇ
(Œ± : Type) [has_zero Œ±] [has_one Œ±] [has_add Œ±] [fintype Œ±] : parser Œ±
{Œ± : Type u_2} [decidable_eq Œ±] [has_sub Œ±] {u : finset Œ±} {s t : set Œ±} : ‚Üëu ‚äÜ s - t ‚Üí (‚àÉ (s' t' : finset Œ±), ‚Üës' ‚äÜ s ‚àß ‚Üët' ‚äÜ t ‚àß u ‚äÜ s' - t')
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] (P Q : C) : P ‚®ø Q ‚âÖ Q ‚®ø P
(A : Type u) [comm_ring A] (K : Type v) [field K] [algebra A K] [is_domain A] [valuation_ring A] [is_fraction_ring A K] : valuation K (valuation_ring.value_group A K)
{Œ± : Type u_1} {Œ≤ : Type u_2} : pprod Œ± Œ≤ ‚âÉ Œ± √ó Œ≤
{R : Type u_1} {K : Type u_2} [semiring R] [comm_semiring K] {b : R} {bi : K} (i : R ‚Üí+* K) (f : polynomial R) (a : R) (bu : bi * ‚áëi b = 1) : denoms_clearable a b f.nat_degree f i
(H : add_subgroup ‚Ñ§) : ‚àÉ (a : ‚Ñ§), H = add_subgroup.closure {a}
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] (X Y : C) : category_theory.limits.prod.functor.obj (X ‚®Ø Y) ‚âÖ category_theory.limits.prod.functor.obj Y ‚ãô category_theory.limits.prod.functor.obj X
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] (D : J ‚•§ T.algebra) [category_theory.limits.preserves_colimit (D ‚ãô T.forget) ‚ÜëT] [category_theory.limits.preserves_colimit ((D ‚ãô T.forget) ‚ãô ‚ÜëT) ‚ÜëT] : category_theory.creates_colimit D T.forget
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.full (category_theory.shift_functor C i)
{T : Type u‚ÇÅ} [category_theory.category T] {X : T} {f g : category_theory.under X} (hr : f.right ‚âÖ g.right) (hw : f.hom ‚â´ hr.hom = g.hom) : f ‚âÖ g
{R : Type u} [semiring R] {p : polynomial R} : polynomial.X * p = p * polynomial.X
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.creates_limit K F] : category_theory.creates_limit K G
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (G : D ‚•§ C) [‚àÄ (A : C), category_theory.limits.has_terminal (category_theory.costructured_arrow G A)] : G ‚ä£ category_theory.right_adjoint_of_costructured_arrow_terminals G
{Œ± : Type u_1} {n : Type u_4} {m : Type u_5} [has_zero Œ±] {A : matrix m m Œ±} {C : matrix n m Œ±} {D : matrix n n Œ±} (h : (matrix.from_blocks A 0 C D).is_symm) (ha : A.is_diag) (hd : D.is_diag) : (matrix.from_blocks A 0 C D).is_diag
{R : Type u_1} [comm_ring R] (u v w : fin 3 ‚Üí R) : ‚áë(‚áëcross_product u) (‚áë(‚áëcross_product v) w) + ‚áë(‚áëcross_product v) (‚áë(‚áëcross_product w) u) + ‚áë(‚áëcross_product w) (‚áë(‚áëcross_product u) v) = 0
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] : C ‚•§ C ‚•§ C
(q : interactive.parse (optional interactive.types.texpr)) : conv unit
(Œ± : Type u_10) (Œ≤ : Type u_11) [monoid Œ±] : Type (max u_10 u_11)
(G : Type u) : Type u
(R : Type u) (Œπ : Type u') (M‚ÇÇ : Type v‚ÇÇ) (M' : Type v') [decidable_eq Œπ] [comm_semiring R] [add_comm_monoid M'] [add_comm_monoid M‚ÇÇ] [module R M'] [module R M‚ÇÇ] (Œπ' : Type u_1) [decidable_eq Œπ'] [decidable_eq (Œπ ‚äï Œπ')] : multilinear_map R (Œª (x : Œπ ‚äï Œπ'), M') M‚ÇÇ ‚âÉ‚Çó[R] multilinear_map R (Œª (x : Œπ), M') (multilinear_map R (Œª (x : Œπ'), M') M‚ÇÇ)
{C : Type u} [category_theory.category C] {F : category_theory.limits.walking_span ‚•§ C} {s t : category_theory.limits.cocone F} (i : s.X ‚âÖ t.X) (w‚ÇÅ : s.Œπ.app category_theory.limits.walking_cospan.left ‚â´ i.hom = t.Œπ.app category_theory.limits.walking_cospan.left) (w‚ÇÇ : s.Œπ.app category_theory.limits.walking_cospan.right ‚â´ i.hom = t.Œπ.app category_theory.limits.walking_cospan.right) : s ‚âÖ t
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : Type w) [category_theory.category J] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ w w')
 : expr ‚Üí option (expr √ó expr √ó expr √ó expr √ó expr)
{Œ± : Type u_1} {Œ≤ : Type u_2} [normed_group Œ≤] (l : filter Œ±) (u v : Œ± ‚Üí Œ≤) : Prop
 : Type
(loc : interactive.parse interactive.types.location) : tactic unit
{o : ordinal} : ‚Ü•(set.Iio o) ‚âÉ o.to_pgame.left_moves
{Œ± : Type u_1} : list (list Œ±) ‚Üí list (list Œ±)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) : Type v
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] {Y X : C} {P : C·µí·µñ ‚•§ D} {S : J.cover X} (x : category_theory.meq P S) (f : Y ‚ü∂ X) : category_theory.meq P ((J.pullback f).obj S)
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (D : Type w) [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] : (C·µí·µñ ‚•§ D) ‚•§ C·µí·µñ ‚•§ D
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f g : M ‚Üí+ N) : add_submonoid M
(R : Type u_1) [has_zero R] [has_pow R ‚Ñï] : Prop
{Œπ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Œπ ‚Üí set X} {s : set X} {c : set (shrinking_lemma.partial_refinement u s)} (hc : is_chain has_le.le c) {v‚ÇÅ v‚ÇÇ : shrinking_lemma.partial_refinement u s} (h‚ÇÅ : v‚ÇÅ ‚àà c) (h‚ÇÇ : v‚ÇÇ ‚àà c) {i : Œπ} (hi‚ÇÅ : i ‚àà v‚ÇÅ.carrier) (hi‚ÇÇ : i ‚àà v‚ÇÇ.carrier) : ‚áëv‚ÇÅ i = ‚áëv‚ÇÇ i
{R : Type u} {A M B : Type v} [ring R] [add_comm_group A] [module R A] [add_comm_group B] [module R B] [add_comm_group M] [module R M] {j : A ‚Üí‚Çó[R] M} {g : M ‚Üí‚Çó[R] B} {f : M ‚Üí‚Çó[R] A} (hg : function.surjective ‚áëg) (exac : j.range = g.ker) (h : f.comp j = linear_map.id) : (A √ó B) ‚âÉ‚Çó[R] M
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} {ps : set P} (h : ps ‚äÜ ‚Üës) [nonempty ‚Ü•s] {n : ‚Ñï} [finite_dimensional ‚Ñù ‚Ü•(s.direction)] (hd : finite_dimensional.finrank ‚Ñù ‚Ü•(s.direction) = n) (hc : euclidean_geometry.cospherical ps) : ‚àÉ (c : P), ‚àÄ (sx : affine.simplex ‚Ñù P n), set.range sx.points ‚äÜ ps ‚Üí sx.circumcenter = c
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p p' : submodule R M) : ‚Ü•p ‚ß∏ submodule.comap p.subtype (p ‚äì p') ‚Üí‚Çó[R] ‚Ü•(p ‚äî p') ‚ß∏ submodule.comap (p ‚äî p').subtype p'
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (n : ‚Ñï) (f : E ‚Üí F) (s : set E) : E ‚Üí continuous_multilinear_map ùïú (Œª (i : fin n), E) F
{Œ± : Type u_1} (B : filter_basis Œ±) : filter Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {n : ‚Ñï} {f : ùïú ‚Üí F} : iterated_fderiv ùïú n f = ‚áë(continuous_multilinear_map.pi_field_equiv ùïú (fin n) F) ‚àò iterated_deriv n f
{R : Type u_1} {R‚ÇÇ : Type u_2} {R‚ÇÉ : Type u_3} {E : Type u_5} {E‚ÇÇ : Type u_6} {E‚ÇÉ : Type u_7} [semiring R] [semiring R‚ÇÇ] [semiring R‚ÇÉ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} {œÉ‚ÇÅ‚ÇÉ : R ‚Üí+* R‚ÇÉ} {œÉ‚ÇÉ‚ÇÅ : R‚ÇÉ ‚Üí+* R} {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÉ‚ÇÇ : R‚ÇÉ ‚Üí+* R‚ÇÇ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÉ œÉ‚ÇÉ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÉ‚ÇÅ œÉ‚ÇÅ‚ÇÉ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÉ‚ÇÇ] [ring_hom_inv_pair œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÇ‚ÇÉ] [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] [ring_hom_comp_triple œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÉ‚ÇÅ] [semi_normed_group E] [semi_normed_group E‚ÇÇ] [semi_normed_group E‚ÇÉ] [module R E] [module R‚ÇÇ E‚ÇÇ] [module R‚ÇÉ E‚ÇÉ] (e : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) (e' : E‚ÇÇ ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÇ‚ÇÉ] E‚ÇÉ) : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÉ] E‚ÇÉ
{ùïÇ : Type u_6} [is_R_or_C ùïÇ] {E' : Type u_7} [normed_group E'] [normed_space ùïÇ E'] {F' : Type u_8} [normed_group F'] [normed_space ùïÇ F'] {f : E' ‚Üí F'} {x : E'} (hf : cont_diff_at ùïÇ 1 f x) (K : nnreal) (hK : ‚à•fderiv ùïÇ f x‚à•‚Çä < K) : ‚àÉ (t : set E') (H : t ‚àà nhds x), lipschitz_on_with K f t
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (S : add_subsemigroup M) : add_subsemigroup N
{ùïú : Type u_1} {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field ùïú] [normed_space ùïú E] : normed_algebra ùïú (E ‚ÜíL[ùïú] E)
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ≤ : Type u} (g‚ÇÄ : Œ≤ ‚Üí P.A) (g‚ÇÇ : Œ† (b : Œ≤), P.last.B (g‚ÇÄ b) ‚Üí Œ≤) : Œ≤ ‚Üí P.last.M
 : user_attribute unit (list name)
(Œ± : Type u_1) [topological_space Œ±] : filter Œ±
(R : Type u_1) {B : Type u_3} (F : Type u_4) (E : B ‚Üí Type u_5) [semiring R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] [topological_space (bundle.total_space E)] : Type (max u_3 u_4 u_5)
(ùïú : Type u_1) (E : Type u_4) (F‚Çó : Type u_7) (G‚Çó : Type u_9) [semi_normed_group E] [semi_normed_group F‚Çó] [semi_normed_group G‚Çó] [nondiscrete_normed_field ùïú] [normed_space ùïú E] [normed_space ùïú F‚Çó] [normed_space ùïú G‚Çó] : (F‚Çó ‚ÜíL[ùïú] G‚Çó) ‚ÜíL[ùïú] (E ‚ÜíL[ùïú] F‚Çó) ‚ÜíL[ùïú] E ‚ÜíL[ùïú] G‚Çó
{Œ± : Type u} {a b c d : Œ±} [preorder Œ±] (hca : c ‚â§ a) (hbd : b ‚â§ d) : a ‚â§ b ‚Üí c ‚â§ d
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) : Prop
(n : ‚Ñï) (h : 0 < n) : composition n
{Œ±‚ÇÅ : Type u_1} {Œ±‚ÇÇ : Type u_2} {Œ≤ : Œ±‚ÇÅ ‚Üí Type u_3} (f : Œ±‚ÇÅ ‚âÉ Œ±‚ÇÇ) : (Œ£ (a : Œ±‚ÇÅ), Œ≤ a) ‚âÉ Œ£ (a : Œ±‚ÇÇ), Œ≤ (‚áë(f.symm) a)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} [decidable_eq Œπ] {V : Œπ ‚Üí submodule ùïú E} (hV : orthogonal_family ùïú (Œª (i : Œπ), (V i).subtype‚Çó·µ¢)) (hc : is_complete ‚Üë(supr V)) : direct_sum.is_internal V ‚Üî (supr V)·óÆ = ‚ä•
(C : Type u) [category_theory.category C] : Type (max u v)
{Œ± : Type u_1} {s : setoid Œ±} [decidable_rel has_equiv.equiv] [encodable Œ±] (q : quotient s) : Œ±
{Œ± : Type u_1} {l : list Œ±} {x : Œ±} : list.duplicate x l ‚Üî [x, x] <+ l
{Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≥ : Type u_5} [lattice Œ±] [lattice Œ≤] [lattice Œ≥] [bounded_order Œ±] [bounded_order Œ≤] [bounded_order Œ≥] (f : bounded_lattice_hom Œ≤ Œ≥) (g : bounded_lattice_hom Œ± Œ≤) : bounded_lattice_hom Œ± Œ≥
{Œ± : Type u_1} [dec : decidable_eq Œ±] : regular_expression Œ± ‚Üí list Œ± ‚Üí bool
{Œ≤ : Type u} {Œ± : Type v} [comm_monoid Œ≤] {s : finset Œ±} (hc : s.card ‚â§ 1) {f : Œ± ‚Üí Œ≤} {b : Œ≤} (h : s.prod (Œª (x : Œ±), f x) = b) (x : Œ±) (H : x ‚àà s) : f x = b
{R : Type u} (A : Type w) {Œπ : Type u_1} {M : Type u_2} [comm_semiring R] [semiring A] [add_comm_monoid M] [algebra R A] [module A M] [module R M] [is_scalar_tower R A M] (b : basis Œπ R M) (h : function.bijective ‚áë(algebra_map R A)) : basis Œπ A M
{Œ± : Type u_1} {m : measurable_space Œ±} (ŒΩ : measure_theory.measure Œ±) [measure_theory.sigma_finite ŒΩ] {f : Œ± ‚Üí ennreal} (hf : measurable f) : (ŒΩ.with_density f).rn_deriv ŒΩ =·µê[ŒΩ] f
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] (X : Top) : category_theory.Sheaf (opens.grothendieck_topology ‚Ü•X) C ‚•§ Top.sheaf C X
{t : ‚Ü•unit_interval} : 0 ‚â§ t
{X Y : Magma} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ* ‚Ü•Y
 : Type
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {v : V} (hv : v ‚àà s.direction) {p : P} (hp : p ‚àà s) : v +·µ• p ‚àà s
{R : Type u_4} {S : Type u_5} {S' : Type u_6} [has_mul R] [has_add R] [has_mul S] [has_add S] [has_mul S'] [has_add S'] (e‚ÇÅ : R ‚âÉ+* S) (e‚ÇÇ : S ‚âÉ+* S') : R ‚âÉ+* S'
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {B : Type u‚ÇÑ} [category_theory.category B] (S : D) (F : B ‚•§ C) (G : C ‚•§ D) : category_theory.structured_arrow S (F ‚ãô G) ‚•§ category_theory.structured_arrow S G
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.creates_colimits_of_size F] : category_theory.creates_colimits_of_size G
{Œπ : Type u_1} (c‚ÇÅ c‚ÇÇ : complex_shape Œπ) : complex_shape Œπ
{Œ± : Type u} : dlist Œ±
(Œ± : Type u) (Œ≤ : Type v) [partial_order Œ±] [partial_order Œ≤] : partial_order (Œ± √ó Œ≤)
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) : submodule R ‚Ü•p ‚Ü™o submodule R M
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] {E : Type u‚ÇÉ} [category_theory.category E] [category_theory.monoidal_category E] {F G : category_theory.lax_monoidal_functor C D} {H K : category_theory.lax_monoidal_functor D E} (Œ± : category_theory.monoidal_nat_trans F G) (Œ≤ : category_theory.monoidal_nat_trans H K) : category_theory.monoidal_nat_trans (F ‚äó‚ãô H) (G ‚äó‚ãô K)
(p q : ‚Ñù) : Prop
(a : ‚Ü•circle) : ‚áëlinear_map.det ‚Üë((‚áërotation a).to_linear_equiv) = 1
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : continuous f) : filter.comap f (filter.cocompact Œ≤) ‚â§ filter.cocompact Œ±
{V : Type u_1} {Œ± : Type u_2} [has_zero Œ±] [has_one Œ±] (A : matrix V V Œ±) : Prop
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : generalized_continued_fraction K
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (f : cocompact_map Œ≤ Œ≥) (g : cocompact_map Œ± Œ≤) : cocompact_map Œ± Œ≥
(A B : Top) : ‚Ü•(fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (‚Ü•A √ó ‚Ü•B))) ‚•§ ‚Ü•(fundamental_groupoid.fundamental_groupoid_functor.obj A)
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [has_bot Œ±] [has_bot Œ≤] : Type (max u_6 u_7 u_8)
 : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : category_theory.mono_over X ‚âå category_theory.mono_over (e.functor.obj X)
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {f‚ÇÄ f‚ÇÅ : C(X, Y)} : has_coe_to_fun (f‚ÇÄ.homotopy f‚ÇÅ) (Œª (_x : f‚ÇÄ.homotopy f‚ÇÅ), ‚Ü•unit_interval √ó X ‚Üí Y)
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] (f : A ‚Üí‚Çê[R] B) (S : subalgebra R B) (hf : ‚àÄ (x : A), ‚áëf x ‚àà S) : A ‚Üí‚Çê[R] ‚Ü•S
{Œ± : Type u} {Œ≤ : Type v} (s : seq1 Œ±) (f : Œ± ‚Üí seq1 Œ≤) : seq1 Œ≤
(R : Type u‚ÇÅ) (L : Type u‚ÇÇ) [comm_ring R] [lie_ring L] [lie_algebra R L] : tensor_algebra R L ‚Üí‚Çê[R] universal_enveloping_algebra R L
{R : Type u_1} [semiring R] {M : Type u_2} [topological_space M] [add_comm_group M] {M‚ÇÇ : Type u_3} [topological_space M‚ÇÇ] [add_comm_group M‚ÇÇ] {M‚ÇÉ : Type u_4} [topological_space M‚ÇÉ] [add_comm_group M‚ÇÉ] {M‚ÇÑ : Type u_5} [topological_space M‚ÇÑ] [add_comm_group M‚ÇÑ] [module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] [module R M‚ÇÑ] [topological_add_group M‚ÇÑ] (e : M ‚âÉL[R] M‚ÇÇ) (e' : M‚ÇÉ ‚âÉL[R] M‚ÇÑ) (f : M ‚ÜíL[R] M‚ÇÑ) : (M √ó M‚ÇÉ) ‚âÉL[R] M‚ÇÇ √ó M‚ÇÑ
{P : Type u_1} [has_le P] [is_directed P has_le.le] [nonempty P] : order_top (order.ideal P)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (P : D ‚Üí Prop) (F : C ‚•§ D) (hF : ‚àÄ (X : C), P (F.obj X)) : category_theory.full_subcategory.lift P F hF ‚ãô category_theory.full_subcategory_inclusion P ‚âÖ F
 : is_simple_group ‚Ü•(alternating_group (fin 5))
{Œ± : Type u} (s : wseq Œ±) (n : ‚Ñï) : computation (option Œ±)
(Fq F : Type) [field Fq] [field F] (Fqt : Type u_1) [field Fqt] [algebra (polynomial Fq) Fqt] [is_fraction_ring (polynomial Fq) Fqt] [algebra (ratfunc Fq) F] [algebra Fqt F] [algebra (polynomial Fq) F] [is_scalar_tower (polynomial Fq) Fqt F] [is_scalar_tower (polynomial Fq) (ratfunc Fq) F] : function_field Fq F ‚Üî finite_dimensional Fqt F
(Œ± : Type u) : Type u
(Œ± : Type u_1) : (fin 2 ‚Üí Œ±) ‚âÉ Œ± √ó Œ±
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} : is_max_on (‚áëorder_dual.to_dual ‚àò f) s a ‚Üí is_min_on f s a
(p : ‚Ñù) : ‚Ñù
{Œ± : Type u_1} {Œπ : Sort u_4} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí set Œ±} (h : filter.is_basis p s) : filter_basis Œ±
{Œ± : Type u} {r : Œ± ‚Üí Œ± ‚Üí Prop} {a b : Œ±} (l : list Œ±) (hl‚ÇÅ : list.chain r a l) (hl‚ÇÇ : (a :: l).last _ = b) : relation.refl_trans_gen r a b
 : hole_command
{key value : Type} [has_zero value] (m : native.rb_map key value) (k : key) : value
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Ü™ Œ≤) (x : Œ≤) (h : x ‚àâ set.range ‚áëf) : option Œ± ‚Ü™ Œ≤
{R : Type u_1} [monoid R] [star_semigroup R] (A‚ÇÄ A‚ÇÅ B‚ÇÄ B‚ÇÅ : R) : Type
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) (x : E) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type w} [category_theory.category J] [category_theory.limits.preserves_limits_of_shape J G] [category_theory.limits.has_limits_of_shape J D] [category_theory.limits.has_limits_of_shape J C] : category_theory.limits.lim ‚ãô G ‚âÖ (category_theory.whiskering_right J C D).obj G ‚ãô category_theory.limits.lim
{Œ± : Type u_1} [preorder Œ±] (a : Œ±) : upper_set Œ±
{Œ± : Type u_1} [circular_preorder Œ±] {a b c : Œ±} (habc : has_btw.btw a b c) (hcba : ¬¨has_btw.btw c b a) : has_sbtw.sbtw a b c
{R : Type u} {L‚ÇÅ : Type v} [comm_ring R] [lie_ring L‚ÇÅ] [lie_algebra R L‚ÇÅ] : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÅ
{n : with_top ‚Ñï} {ùïÇ : Type u_6} [is_R_or_C ùïÇ] {E' : Type u_7} [normed_group E'] [normed_space ùïÇ E'] {F' : Type u_8} [normed_group F'] [normed_space ùïÇ F'] {s : set E'} {f : E' ‚Üí F'} {x : E'} {p : E' ‚Üí formal_multilinear_series ùïÇ E' F'} (hf : has_ftaylor_series_up_to_on n f p s) (hn : 1 ‚â§ n) (hs : s ‚àà nhds x) : has_strict_fderiv_at f (‚áë(continuous_multilinear_curry_fin1 ùïÇ E' F') (p x 1)) x
 : znum ‚Üí znum ‚Üí znum
{Œ≤ : Type v} [has_zero Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_scalar ‚Ñï Œ≤] {Œ± : Type u} [non_assoc_semiring Œ±] [has_one Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.surjective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ±) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_assoc_semiring Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} {p : Œ± ‚Üí Prop} (f : Œ† (a : Œ±), p a ‚Üí Œ≤) (l : lazy_list Œ±) : (‚àÄ (a : Œ±), a ‚àà l ‚Üí p a) ‚Üí lazy_list Œ≤
{Œ± : Type u_1} [decidable_eq Œ±] (s : set Œ±) [fintype ‚Ü•s] {a : Œ±} (h : a ‚àà s) : a ‚àà tactic.interval_cases.set_elems s
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} (X : T.algebra) : category_theory.limits.cofork (category_theory.monad.free_coequalizer.top_map X) (category_theory.monad.free_coequalizer.bottom_map X)
(C : Type u_1) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.preadditive C] [category_theory.monoidal_preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_cokernels C] [category_theory.limits.has_images C] [category_theory.limits.has_image_maps C] [category_theory.has_projective_resolutions C] (n : ‚Ñï) : C ‚•§ C ‚•§ C
{Œ± : Type u_1} {s t : set Œ±} (h : s ‚äÜ t) : ‚Ü•s ‚Üí ‚Ü•t
{J : Type u} (F : J ‚Üí Type u) : category_theory.limits.limit_cone (category_theory.discrete.functor F)
(C : Type u) (A : Type u_1) [category_theory.category C] [add_monoid A] : Type (max u u_1 v)
{Œ± : Type u_1} {Œ≤ : Type u_2} [decidable_eq Œ±] [fintype Œ±] [comm_semiring Œ≤] {Œ¥ : Œ± ‚Üí Type u_1} [Œ† (a : Œ±), decidable_eq (Œ¥ a)] {t : Œ† (a : Œ±), finset (Œ¥ a)} {f : Œ† (a : Œ±), Œ¥ a ‚Üí Œ≤} : finset.univ.prod (Œª (a : Œ±), (t a).sum (Œª (b : Œ¥ a), f a b)) = (fintype.pi_finset t).sum (Œª (p : Œ† (a : Œ±), Œ¥ a), finset.univ.prod (Œª (x : Œ±), f x (p x)))
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} : cont_diff ùïú n prod.fst
(R : Type u_1) {p m : ‚Ñï} [fact (nat.prime p)] [ring R] [char_p R p] (hm : ¬¨p ‚à£ m) {k : ‚Ñï} : 0 < k ‚Üí polynomial.cyclotomic (p ^ k * m) R = polynomial.cyclotomic m R ^ (p ^ k - p ^ (k - 1))
{m : Type u_3} {n : Type u_4} {Œ± : Type u_5} [fintype m] [fintype n] [normed_group Œ±] : normed_group (matrix m n Œ±)
{P : Type u_1} [preorder P] (F : set P) : Prop
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [metric_space Œ≤] [has_zero Œ≤] : metric_space (zero_at_infty_continuous_map Œ± Œ≤)
{Œ± : Type u} {p : Œ± ‚Üí Prop} [has_le Œ±] [bounded_order Œ±] (hbot : p ‚ä•) (htop : p ‚ä§) : bounded_order (subtype p)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (Œ± : F ‚ü∂ G) [‚àÄ (X : C), category_theory.epi (Œ±.app X)] : category_theory.epi Œ±
(X : Type u_1) {Y : Type u_2} [topological_space X] (y : Y) : locally_constant X Y
(R : Type u) (A : Type v) (B : Type w) [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] : Type (max v w)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {f : V ‚Üí‚Çó[K] V} (hinj : function.injective ‚áëf) : function.surjective ‚áëf
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [Œ† (i : Œπ), module R (M‚ÇÅ i)] {Œπ' : Type u_1} {M' : Œπ' ‚Üí Type u_2} [Œ† (i : Œπ'), add_comm_monoid (M' i)] [Œ† (i : Œπ'), module R (M' i)] (f : Œ† (i : Œπ'), multilinear_map R M‚ÇÅ (M' i)) : multilinear_map R M‚ÇÅ (Œ† (i : Œπ'), M' i)
{C : Type u} [category_theory.category C] {X : C} (h : category_theory.limits.is_zero X) (Y : C) : X ‚ü∂ Y
{Œì : Type u_1} {Œì' : Type u_2} [inhabited Œì] [inhabited Œì'] (f : turing.pointed_map Œì Œì') (T : turing.tape Œì) : turing.tape Œì'
{Œ± : Type u_2} [comm_semigroup Œ±] : comm_semigroup (filter Œ±)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) [category_theory.is_filtered J] (j : J) : F.obj j ‚ü∂ Mon.filtered_colimits.colimit F
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.mul_pos_mono Œ±] (ha : 1 ‚â§ a) (hb : 1 ‚â§ b) (b0 : 0 < b) : 1 ‚â§ a * b
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (G : C ‚•§ D) [G.preserves_zero_morphisms] {X Y Z : C} {f : X ‚ü∂ Y} {h : Y ‚ü∂ Z} (w : f ‚â´ h = 0) [category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f 0) G] (l : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ h w)) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ (G.map h) _)
 : list ‚Ñ§ ‚Üí ‚Ñï
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} : clifford_algebra Q ‚âÉ‚Çê[R] clifford_algebra Q
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_initial C] (P : C) : ‚ä•_ C ‚ü∂ P
{Œ± : Type v} [linear_order Œ±] [topological_space Œ±] [order_closed_topology Œ±] {s : set Œ±} (hs : is_preconnected s) {a b : Œ±} (ha : a ‚àà s) (hb : b ‚àà s) : set.Icc a b ‚äÜ s
{n : ‚Ñï} (p : fin n) (i : fin (n + 1)) : fin n
{R : Type u_1} [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (T : Type u_4) [comm_ring T] [algebra R T] (M N : submonoid R) (h : M ‚â§ N) [is_localization M S] [is_localization N T] : is_scalar_tower R S T
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] {N : Type u_3} [monoid N] : (Œ† (i : Œπ), M i ‚Üí* N) ‚âÉ (free_product M ‚Üí* N)
{k : Type u_1} {V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_3} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] (f : V‚ÇÅ ‚Üí‚Çó[k] V‚ÇÇ) : V‚ÇÅ ‚Üí·µÉ[k] V‚ÇÇ
{M : Type u_1} [linear_ordered_cancel_comm_monoid M] {A : Type u_2} [set_like A M] [submonoid_class A M] (S : A) : linear_ordered_cancel_comm_monoid ‚Ü•S
{Œ± : Type u} : free_add_magma Œ± ‚Üí ‚Ñï
{Œ± : Type u_1} {s : finset Œ±} {p : Œ± ‚Üí Prop} [decidable_pred p] (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p x) : finset.map (function.embedding.subtype p) (finset.subtype p s) = s
{C : Type u} [category_theory.category C] {X Y Z : C} {i : category_theory.arrow C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (sq : i ‚ü∂ category_theory.arrow.mk (f ‚â´ g)) : i ‚ü∂ category_theory.arrow.mk g
{C : Type u} [category_theory.category C] [category_theory.abelian C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.abelian.coimage f ‚âÖ category_theory.limits.image f
(x y : Set) : Set
{Œ± : Type u} {L‚ÇÅ L‚ÇÇ L‚ÇÉ : list (Œ± √ó bool)} [decidable_eq Œ±] (H12 : free_group.red L‚ÇÅ L‚ÇÇ) (H13 : free_group.red L‚ÇÅ L‚ÇÉ) : {L‚ÇÑ // free_group.red L‚ÇÇ L‚ÇÑ ‚àß free_group.red L‚ÇÉ L‚ÇÑ}
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) : hb.oangle (-x) (-y) = hb.oangle x y
{œÑ : Type u_1} {Œ± : Type u_2} [preorder œÑ] [has_zero œÑ] (œï : œÑ ‚Üí Œ± ‚Üí Œ±) (s : set Œ±) : Prop
(C : Type u) [category_theory.category C] : Prop
(Œ± : Type u_1) [preorder Œ±] : Type u_1
{Œ± : Type u_1} [non_unital_semi_normed_ring Œ±] : topological_ring Œ±
(Œ± : Type u_1) (Œ≤ : Type u_2) [uniform_space Œ≤] : filter_basis ((Œ± ‚Üí Œ≤) √ó (Œ± ‚Üí Œ≤))
{R : Type u} [ring R] {X‚ÇÅ : Type v} [add_comm_group X‚ÇÅ] [module R X‚ÇÅ] {X‚ÇÇ : Module R} : (X‚ÇÅ ‚Üí‚Çó[R] ‚Ü•X‚ÇÇ) ‚Üí (Module.of R X‚ÇÅ ‚ü∂ X‚ÇÇ)
{Œπ : Type u_1} {R : Type u_2} {Œ± : Type u_3} {S : Type u_4} [set_like S R] [monoid R] [add_monoid Œπ] (A : Œπ ‚Üí S) [set_like.graded_monoid A] (fŒπ : Œ± ‚Üí Œπ) (fA : Œ† (a : Œ±), ‚Ü•(A (fŒπ a))) (l : list Œ±) : l.dprod fŒπ fA = ‚ü®(list.map (Œª (a : Œ±), ‚Üë(fA a)) l).prod, _‚ü©
{Œ± : Type u_1} [add_comm_monoid Œ±] [topological_space Œ±] {a : Œ±} {f : ‚Ñï ‚Üí Œ±} (h : has_sum f a) : filter.tendsto (Œª (n : ‚Ñï), (finset.range n).sum (Œª (i : ‚Ñï), f i)) filter.at_top (nhds a)
{B : Type u} [quiver B] {a b : B} {f g : category_theory.free_bicategory.hom a b} : category_theory.free_bicategory.hom‚ÇÇ f g ‚Üí category_theory.free_bicategory.hom‚ÇÇ f g ‚Üí Prop
{Œ± : Type u_1} [measurable_space Œ±] {s : set Œ±} : measurable_set s ‚Üí (filter.principal s).is_measurably_generated
(R : Type u) {B : Type v} [comm_ring R] [decidable_eq B] [fintype B] (A : matrix B B ‚Ñ§) : B √ó B ‚Üí free_lie_algebra R (cartan_matrix.generators B)
{S : Type u} [pgame.state S] (s : S) (t : (pgame.of s).right_moves) : ((pgame.of s).move_right t).relabelling (pgame.of ‚Üë((pgame.right_moves_of s).to_fun t))
{Œ± : Type u_2} [add_semigroup Œ±] : add_semigroup (filter Œ±)
(p : ‚Ñï) [fact (nat.prime p)] (a : ‚Ñ§) (ha : ‚Üëa ‚â† 0) : zmod.legendre_sym p a = 1 ‚à® zmod.legendre_sym p a = -1
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : category_theory.monoidal_category.left_assoc_tensor C ‚âÖ category_theory.monoidal_category.right_assoc_tensor C
{Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ≤] [topological_space Œ≥] {Œ∫ : Type u_5} {g : Œ≤ ‚Üí Œ≥} {f : Œ∫ ‚Üí Œ≤} (hg : dense_range g) (hf : dense_range f) (cg : continuous g) : dense_range (g ‚àò f)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_equalizer f g] : category_theory.limits.has_kernel (f - g)
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] (D : Type u‚ÇÇ) [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{M : Type u_1} {P : Type u_3} [has_mul M] [has_mul P] (f : M ‚Üí P) (h : ‚àÄ (x y : M), f (x * y) = f x * f y) : con M
{X : Type u_1} [topological_space X] [locally_compact_space X] [t2_space X] : normal_space (alexandroff X)
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] {g : S ‚Üí R} {f : R ‚Üí+* S} (h : function.left_inverse g ‚áëf) : R ‚âÉ+* ‚Ü•(f.srange)
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J·µí·µñ ‚•§ C·µí·µñ) {c : category_theory.limits.cone F} (hc : category_theory.limits.is_limit c) : category_theory.limits.is_colimit (category_theory.limits.cocone_unop_of_cone c)
{ùïú : Type u_1} [linear_ordered_field ùïú] {x y : ùïú} (h : x < y) {z : ùïú} : z ‚àà set.Ioc x y ‚Üî ‚àÉ (a b : ùïú), 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z
{R : Type u} {S : Type v} [ring R] [ring S] (f : R ‚Üí+* S) : R ‚Üí+* ‚Ü•(f.range)
(Œ± : Type u_6) (Œ≤ : Type u_7) [preorder Œ±] [preorder Œ≤] : Type (max u_6 u_7)
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : Œ± ‚Üí Œ± ‚Üí Prop
{X : Type u_1} [emetric_space X] (s t : set X) : Prop
{Œ± : Type u} [semiring Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) : ideal Œ±
(q : interactive.parse interactive.types.texpr) : tactic unit
{R S : CommRing} (f : R ‚ü∂ S) : algebraic_geometry.Spec.LocallyRingedSpace_obj S ‚ü∂ algebraic_geometry.Spec.LocallyRingedSpace_obj R
(Œ± : Type u_1) [topological_space Œ±] [non_unital_non_assoc_semiring Œ±] : Prop
{M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : add_zero_class M} {mN : add_zero_class N} [add_monoid_hom_class F M N] (f : F) {x : M} (hx : ‚àÉ (y : M), x + y = 0) : ‚àÉ (y : N), ‚áëf x + y = 0
{R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] : disjoint (exterior_algebra.Œπ R).range 1
{X Y Z : Bipointed} (f : X.hom Y) (g : Y.hom Z) : X.hom Z
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_2} [decidable_eq Œ±] [fintype Œ±] [Œ† (a : Œ±), fintype (Œ≤ a)] : fintype (Œ† (a : Œ±), Œ≤ a)
{R : Type u_1} [cancel_comm_monoid_with_zero R] {x y a p : R} {n : ‚Ñï} (hp : prime p) (hx : x * y = a * p ^ n) : ‚àÉ (i j : ‚Ñï) (b c : R), i + j = n ‚àß a = b * c ‚àß x = b * p ^ i ‚àß y = c * p ^ j
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {Œπ : Type u_1} {c : complex_shape Œπ} {Œπ' : Type u_2} {c' : complex_shape Œπ'} (C : homological_complex (homological_complex V c) c') : homological_complex (homological_complex V c') c
{R : Type u} {M : Type v} {M‚ÇÇ : Type w} {M‚ÇÉ : Type y} [comm_semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] {n : ‚Ñï} (f : M ‚Üí‚Çó[R] M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÉ) (g : M ‚Üí‚Çó[R] M‚ÇÇ ‚Üí‚Çó[R] fin n ‚Üí M‚ÇÉ) : M ‚Üí‚Çó[R] M‚ÇÇ ‚Üí‚Çó[R] fin n.succ ‚Üí M‚ÇÉ
(A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [h : is_cyclotomic_extension ‚àÖ A B] : ‚ä• = ‚ä§
{Œ± : Type u_1} [has_le Œ±] {a : Œ±} : is_top a ‚Üí is_bot (‚áëorder_dual.to_dual a)
{Œ± : Type u_1} {P : Œ± ‚Üí Prop} [encA : encodable Œ±] : {a // P a} ‚Üí ‚Ñï
 : io string
{K : Type u} [field K] (x : ratfunc K) : ‚Ñ§
(h : expr) (hs : expr_set) : tactic bool
{F : Type u ‚Üí Type u} [applicative F] {Œ± : Type u_1} {Œ±' : Type u} {Œ≤ : Type u_2} {Œ≤' : Type u} (f : Œ± ‚Üí F Œ±') (f' : Œ≤ ‚Üí F Œ≤') : Œ± ‚äï Œ≤ ‚Üí F (Œ±' ‚äï Œ≤')
(b : pgame.domineering.board) : finset (‚Ñ§ √ó ‚Ñ§)
(do_whnf : option (tactic.transparency √ó bool)) (pis_or_lambdas locals_or_metas : bool) : expr ‚Üí ‚Ñï ‚Üí tactic (list expr √ó expr)
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : Œ± ‚Üí Œ≤ ‚Üí Prop) : list Œ± ‚Üí list Œ≤ ‚Üí Prop
 : Type
(V : Type u) : Type u
(Œ± : Type u_1) (Œ≤ : Type u_2) [has_le Œ±] [has_le Œ≤] : (Œ± ‚äï‚Çó Œ≤)·µí·µà ‚âÉo Œ≤·µí·µà ‚äï‚Çó Œ±·µí·µà
 : string
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] {x : E} {s : set E} (hx : x ‚àà s) (hs : s ‚â† set.univ) : ‚àÉ (y : E) (H : y ‚àà frontier s), metric.inf_dist x s·∂ú = has_dist.dist x y
{P : Type u_1} [preorder P] (p : P) : order.pfilter P
{V : Type u} {G : simple_graph V} {M : G.subgraph} (h : M.is_matching) (v : ‚Ü•(M.verts)) : ‚Ü•(M.edge_set)
 : Type
{Œ± : Type u_1} [pseudo_emetric_space Œ±] (C : ennreal) {f : ‚Ñï ‚Üí Œ±} (hu : ‚àÄ (n : ‚Ñï), has_edist.edist (f n) (f (n + 1)) ‚â§ C / 2 ^ n) {a : Œ±} (ha : filter.tendsto f filter.at_top (nhds a)) : has_edist.edist (f 0) a ‚â§ 2 * C
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ‚Ü•X) (R : category_theory.presieve U) (hR : category_theory.sieve.generate R ‚àà ‚áë(opens.grothendieck_topology ‚Ü•X) U) : category_theory.presheaf.fork_map R F ‚â´ (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom = F.map (category_theory.eq_to_hom _).op ‚â´ Top.presheaf.sheaf_condition_equalizer_products.res F (Top.presheaf.covering_of_presieve U R)
{X : Type u_1} [topological_space X] [path_connected_space X] (x y : X) : path x y
{Œ± : Type u_2} {Œ≤ : Type u_3} [decidable_eq Œ≤] [decidable_eq Œ±] [monoid Œ±] [mul_action Œ± Œ≤] : mul_action (finset Œ±) (finset Œ≤)
 : Type
(q : interactive.parse interactive.types.texpr) : tactic unit
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : euclidean_geometry.orthogonal_projection_fn s p ‚àà affine_subspace.mk' p (s.direction)·óÆ
{Œ± : Type u_1} {G : Type u_4} [subtraction_comm_monoid G] {f g : Œ± ‚Üí G} (hf : (function.support f).finite) (hg : (function.support g).finite) : finsum (Œª (i : Œ±), f i - g i) = finsum (Œª (i : Œ±), f i) - finsum (Œª (i : Œ±), g i)
{V : Type u} {G : simple_graph V} : ‚ä§.coe ‚âÉg G
 : fin 0 ‚âÉ empty
{Œ± : Sort u_1} (H : ¬¨(Œ± ‚Üí false)) : Œ±
{S : Type u_3} {R : Type u_4} [comm_semiring S] [semiring R] [algebra S R] (p : submodule S R) : set_like.graded_monoid (Œª (i : ‚Ñï), p ^ i)
(F : Type u_4) {Œ± : out_param (Type u_5)} {Œ≤ : out_param (Type u_6)} (r : out_param (Œ± ‚Üí Œ± ‚Üí Prop)) (s : out_param (Œ≤ ‚Üí Œ≤ ‚Üí Prop)) : Type (max u_4 u_5 u_6)
{Œ± : Type u_2} [semiring Œ±] {a : Œ±} : odd a ‚Üí (‚àÉ (b : Œ±), a = bit1 b)
(p : ‚Ñï) [p_prime : fact (nat.prime p)] {q r : ‚Ñï} (hq : q ‚â† 0) (hr : r ‚â† 0) : padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r
(f : circle_deg1_lift) {x : ‚Ñù} {n : ‚Ñï} {m : ‚Ñ§} (h : ‚áë(f ^ n) x = x + ‚Üëm) (hn : 0 < n) : f.translation_number = ‚Üëm / ‚Üën
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} : clifford_algebra Q ‚âÉ‚Çó[R] clifford_algebra Q
{Œ± : Type u_1} {M : Type u_5} [has_zero M] (f : Œ± ‚Üí‚ÇÄ M) : finset M
{J : Type v} [category_theory.small_category J] {A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] {L : A ‚•§ T} {R : B ‚•§ T} (F : J ‚•§ category_theory.comma L R) [category_theory.limits.preserves_limit (F ‚ãô category_theory.comma.snd L R) R] {c‚ÇÅ : category_theory.limits.cone (F ‚ãô category_theory.comma.fst L R)} (t‚ÇÅ : category_theory.limits.is_limit c‚ÇÅ) {c‚ÇÇ : category_theory.limits.cone (F ‚ãô category_theory.comma.snd L R)} (t‚ÇÇ : category_theory.limits.is_limit c‚ÇÇ) : category_theory.limits.is_limit (category_theory.comma.cone_of_preserves F c‚ÇÅ t‚ÇÇ)
{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_finite_biproducts C
(R : Type u) (A : Type w) [comm_semiring R] [semiring A] [algebra R A] : R ‚Üí‚Çó[R] A
{Œ± : Type u_2} {Œ≤ : Type u_3} [partial_order Œ±] [preorder Œ≤] (f : has_lt.lt ‚Üír has_lt.lt) : Œ± ‚Üío Œ≤
{G : Type u_1} [add_group G] {Œπ : Type u_2} (s : finset Œπ) (f : Œπ ‚Üí G) (comm : ‚àÄ (x : Œπ), x ‚àà s ‚Üí ‚àÄ (y : Œπ), y ‚àà s ‚Üí add_commute (f x) (f y)) (K : Œπ ‚Üí add_subgroup G) (hind : complete_lattice.independent K) (hmem : ‚àÄ (x : Œπ), x ‚àà s ‚Üí f x ‚àà K x) (heq1 : s.noncomm_sum f comm = 0) (i : Œπ) (H : i ‚àà s) : f i = 0
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] (F : J ‚•§ C) (e : C ‚âå D) : category_theory.limits.cone F ‚âå category_theory.limits.cone (F ‚ãô e.functor)
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] {f : M ‚Üí+ N} (hf : function.injective ‚áëf) : galois_coinsertion (add_submonoid.map f) (add_submonoid.comap f)
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {a : Œ±} {s : set Œ±} (f : Œ± ‚Üí M) (h : a ‚àâ s) (hs : s.finite) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà has_insert.insert a s), f i)) = f a * finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i))
{Œ± : Type u_1} {Œ≤ : Type u_2} [t : topological_space Œ±] [group Œ≤] (f : Œ± ‚Üí Œ≤) : group_topology Œ≤
{Œ± : Type u_1} {b : bool} : has_mem (lists Œ±) (lists' Œ± b)
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.strong_epi f] : inhabited (category_theory.limits.strong_epi_mono_factorisation f)
{R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} [comm_semiring R] [semiring A‚ÇÅ] [semiring A‚ÇÇ] [algebra R A‚ÇÅ] [algebra R A‚ÇÇ] (e : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ) : A‚ÇÇ ‚âÉ‚Çê[R] A‚ÇÅ
 : Type (u+1)
(nm : name) (s : string) (is_prefix : bool) : name
{G‚ÇÄ : Type u_2} [group_with_zero G‚ÇÄ] (a : G‚ÇÄ) : a / a * a = a
{M : Type u_3} {N : Type u_4} [has_add M] [has_add N] {f g : add_hom M N} (h : f = g) (x : M) : ‚áëf x = ‚áëg x
{G : Type u_1} [group G] (s : set G) : Prop
{p : ‚Ñï ‚Üí Sort u} (H : Œ† (n : ‚Ñï), (Œ† (m : ‚Ñï), m < n ‚Üí p m) ‚Üí p n) (n : ‚Ñï) : p n
{Œ± : Type u} {Œ≤ : Type v} [has_sup Œ±] [has_inf Œ±] [lattice Œ≤] (f : Œ± ‚Üí Œ≤) (hf_inj : function.injective f) (map_sup : ‚àÄ (a b : Œ±), f (a ‚äî b) = f a ‚äî f b) (map_inf : ‚àÄ (a b : Œ±), f (a ‚äì b) = f a ‚äì f b) : lattice Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} {t‚ÇÅ : topological_space Œ±} {t‚ÇÇ t‚ÇÉ : topological_space Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ) {s : set Œ±} {f : Œ± ‚Üí Œ≤} (h‚ÇÇ : continuous_on f s) : continuous_on f s
(a : ‚Ñù) : cardinal.mk ‚Ü•(set.Ioi a) = cardinal.continuum
{X : Top} (F : Top.presheaf (Type v) X) (x : ‚Ü•X) : F.sheafify.val.stalk x ‚âÖ F.stalk x
{Œ± : Type u} (s : stream Œ±) : stream Œ±
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [bounded_order Œ±] [preorder Œ≤] [bounded_order Œ≤] : bounded_order_hom Œ± Œ≤ ‚âÉ bounded_order_hom Œ±·µí·µà Œ≤·µí·µà
{G : Type u_1} [add_group G] (H : add_subgroup G) {x : G} : x ‚àà H ‚Üí -x ‚àà H
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [mul_zero_one_class Œ±] [mul_zero_one_class Œ≤] : has_coe_to_fun (Œ± ‚Üí*‚ÇÄo Œ≤) (Œª (_x : Œ± ‚Üí*‚ÇÄo Œ≤), Œ± ‚Üí Œ≤)
(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] {s : set A} (hcomm : ‚àÄ (a : A), a ‚àà s ‚Üí ‚àÄ (b : A), b ‚àà s ‚Üí a * b = b * a) : comm_ring ‚Ü•(algebra.adjoin R s)
(Œ± : Type u_5) : Type u_5
(X : Type u_1) [topological_space X] : setoid X
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_initial C] (h : ‚àÄ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C
{R : Type u_1} [ring R] {R‚ÇÇ : Type u_2} [ring R‚ÇÇ] {M : Type u_3} [topological_space M] [add_comm_group M] {M‚ÇÇ : Type u_4} [topological_space M‚ÇÇ] [add_comm_group M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [topological_add_group M] (f‚ÇÅ : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (f‚ÇÇ : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÅ] M) (h : function.right_inverse ‚áëf‚ÇÇ ‚áëf‚ÇÅ) : M ‚ÜíL[R] ‚Ü•(f‚ÇÅ.ker)
(ùïú : Type u_1) (E : Type u_2) [normed_linear_ordered_field ùïú] [normed_group E] [normed_space ùïú E] : Prop
{C : Type u} [category_theory.category C] {A Y : C} [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] (f : A ‚ü∂ Y) : ‚ä§_ C ‚ü∂ (category_theory.exp A).obj Y
 : user_attribute (name_map (list ‚Ñï)) (list ‚Ñï)
{Œπ : Type u_1} {K : Type u_4} {V : Type u} [division_ring K] [add_comm_group V] [module K V] {v : Œπ ‚Üí V} (hs : linear_independent K v) : basis (Œπ ‚äï ‚Ü•(_.extend basis.sum_extend._proof_2  set.range v)) K V
{Œ± : Type u_2} {Œπ : Type u_5} [comm_monoid Œ±] (t : finset Œπ) (f‚ÇÅ f‚ÇÇ : Œπ ‚Üí set Œ±) (hf : ‚àÄ {i : Œπ}, i ‚àà t ‚Üí f‚ÇÅ i ‚äÜ f‚ÇÇ i) : t.prod (Œª (i : Œπ), f‚ÇÅ i) ‚äÜ t.prod (Œª (i : Œπ), f‚ÇÇ i)
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : Œ± ‚âÉ Œ≤) : list Œ± ‚âÉ list Œ≤
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {G : D ‚•§ C} [category_theory.is_right_adjoint G] (A : (category_theory.adjunction.of_right_adjoint G).to_monad.algebra) [category_theory.limits.has_coequalizer ((category_theory.left_adjoint G).map A.a) ((category_theory.adjunction.of_right_adjoint G).counit.app ((category_theory.left_adjoint G).obj A.A))] : D
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : classical.some _ ‚â† 0
{X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {m‚ÇÅ m‚ÇÇ : ennreal ‚Üí ennreal} {c : ennreal} (hc : c ‚â† ‚ä§) (h0 : c ‚â† 0) (hle : m‚ÇÅ ‚â§·∂†[nhds_within 0 (set.Ici 0)] c ‚Ä¢ m‚ÇÇ) : measure_theory.measure.mk_metric m‚ÇÅ ‚â§ c ‚Ä¢ measure_theory.measure.mk_metric m‚ÇÇ
(l : list Prop) : Prop
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} : has_emptyc (alist Œ≤)
 : user_attribute (name_map name) name
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space E] {v : E} (hv : v ‚àà K) : ‚áë(orthogonal_projection K·óÆ) v = 0
{K : Type u_3} [field K] {L : Type u_4} [field L] [algebra K L] {x : L} (hx : is_integral K x) : basis (fin (minpoly K x).nat_degree) K ‚Ü•K‚üÆx‚üØ
(G : Type u_1) [group G] : Prop
{Œ± : Type u_1} (s : finset Œ±) : list Œ±
{Œ± : Type} (p : tactic.rewrite_search.dir_pair Œ±) : expr_lens.dir ‚Üí Œ± ‚Üí tactic.rewrite_search.dir_pair Œ±
 : category_theory.limits.preserves_limits_of_size (category_theory.forget AddCommGroup)
{K : Type u_1} [field K] [is_alg_closed K] : infinite K
(t : interactive.parse (optional (interactive.with_desc ‚Üë"{...}" lean.parser.itactic))) : tactic unit
{H : Type u} [topological_space H] (G : structure_groupoid H) : local_homeomorph.refl H ‚àà structure_groupoid.maximal_atlas H G
{Œ± : Type u_1} {M : Type u_5} [add_zero_class M] {p : Œ± ‚Üí Prop} : (Œ± ‚Üí‚ÇÄ M) ‚Üí+ subtype p ‚Üí‚ÇÄ M
{Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [decidable_eq Œπ] {R' : Type u_1} {A : Type u_2} [semiring R'] [semiring A] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [topological_space M‚ÇÇ] [has_continuous_add M‚ÇÇ] [Œ† (i : Œπ), module A (M‚ÇÅ i)] [module A M‚ÇÇ] [module R' M‚ÇÇ] [has_continuous_const_smul R' M‚ÇÇ] [smul_comm_class A R' M‚ÇÇ] : continuous_multilinear_map A M‚ÇÅ M‚ÇÇ ‚Üí‚Çó[R'] multilinear_map A M‚ÇÅ M‚ÇÇ
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (h : M ‚âÉ* N) : is_mul_hom ‚áëh
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : set Œ±) : set Œ±
{n : Type u_4} {Œ± : Type u_5} [fintype n] [semi_normed_group Œ±] [nonempty n] [decidable_eq n] [has_one Œ±] [norm_one_class Œ±] : norm_one_class (matrix n n Œ±)
(w‚ÇÅ w‚ÇÇ z‚ÇÅ z‚ÇÇ : ennreal) (hw' : w‚ÇÅ + w‚ÇÇ = 1) {p : ‚Ñù} (hp : 1 ‚â§ p) : (w‚ÇÅ * z‚ÇÅ + w‚ÇÇ * z‚ÇÇ) ^ p ‚â§ w‚ÇÅ * z‚ÇÅ ^ p + w‚ÇÇ * z‚ÇÇ ^ p
{n m : ‚Ñï} {P : mvpfunctor n} {Q : fin2 n ‚Üí mvpfunctor m} {Œ± : typevec m} (x : P.obj (Œª (i : fin2 n), (Q i).obj Œ±)) : (P.comp Q).obj Œ±
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {f : M ‚Üí* P} : (con.ker_lift f).mrange = f.mrange
 : simplex_category ‚•§ NonemptyFinLinOrd
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (i : D ‚•§ C) [category_theory.limits.has_finite_products C] [category_theory.reflective i] [category_theory.cartesian_closed C] [category_theory.exponential_ideal i] (A B : C) : category_theory.is_iso (category_theory.limits.prod_comparison (category_theory.left_adjoint i) A B)
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] {i : D.to_glue_data.J} (U : topological_space.opens ‚Ü•((D.to_glue_data.U i).carrier)) : (D.to_glue_data.U i).presheaf.obj (opposite.op U) ‚ü∂ category_theory.limits.limit (D.diagram_over_open U)
{M : Type u_1} {N : Type u_2} {Œ± : Type u_6} [has_scalar M Œ±] (g : N ‚Üí M) (n : N) (a : Œ±) : Œ±
{Œ± : Type u_1} [preorder Œ±] [is_total Œ± has_le.le] [decidable_rel has_le.le] (x : Œ±) (s : ordset Œ±) : ordset Œ±
{Œ± : Type} [decidable_eq Œ±] : list (widget.select_item Œ±) ‚Üí Œ± ‚Üí widget.html Œ±
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} [category_theory.limits.has_zero_object V] [category_theory.limits.has_kernels V] {C‚ÇÅ C‚ÇÇ : homological_complex V c} (f : C‚ÇÅ ‚ü∂ C‚ÇÇ) (i : Œπ) : ‚Üë(C‚ÇÅ.cycles i) ‚ü∂ ‚Üë(C‚ÇÇ.cycles i)
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (P : C·µí·µñ ‚•§ Type w) {S : category_theory.sieve X} {R : category_theory.presieve X} (h : ‚áëS ‚â§ R) (trans : ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X), category_theory.presieve.is_sheaf_for P ‚áë(category_theory.sieve.pullback f S)) : category_theory.presieve.is_sheaf_for P R
{M : Type u_1} [has_mul M] (c : con M) {a b : M} : ‚Üëa = ‚Üëb ‚Üî ‚áëc a b
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {l : list R} : (‚àÄ (x : R), x ‚àà l ‚Üí x ‚àà s) ‚Üí l.sum ‚àà s
{Œ± : Type u_1} {Œπ : Type u_2} {Œπ' : Type u_3} (v : Œπ ‚Üí Œ±) (l : combinatorics.line Œ± Œπ') : combinatorics.line Œ± (Œπ ‚äï Œπ')
{Œ± : Type u_1} {Œ≤ : Type u_2} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] [has_zero Œ±] [has_zero Œ≤] [has_scalar Œ± Œ≤] [has_bounded_smul Œ± Œ≤] [has_scalar Œ±·µê·µí·µñ Œ≤] [is_central_scalar Œ± Œ≤] : has_bounded_smul Œ±·µê·µí·µñ Œ≤
(C : Type u) [category_theory.category C] [‚àÄ {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z}, category_theory.limits.has_colimit (category_theory.limits.span f g)] : category_theory.limits.has_pushouts C
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [baire_space Œ±] [nonempty Œ±] [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±} (hc : ‚àÄ (s : Œ≤), is_closed (f s)) (hU : (‚ãÉ (s : Œ≤), f s) = set.univ) : ‚àÉ (s : Œ≤), (interior (f s)).nonempty
(P : name ‚Üí bool) : name ‚Üí bool
 : Class
 : category_theory.limits.walking_cospan.left ‚ü∂ category_theory.limits.walking_cospan.one
{Œπ : Type u_1} {ùïú : Type u_2} [is_R_or_C ùïú] {E : Type u_3} [inner_product_space ùïú E] [cplt : complete_space E] {G : Œπ ‚Üí Type u_4} [Œ† (i : Œπ), inner_product_space ùïú (G i)] {V : Œ† (i : Œπ), G i ‚Üí‚Çó·µ¢[ùïú] E} (hV : orthogonal_family ùïú V) [‚àÄ (i : Œπ), complete_space (G i)] (hV' : (‚®Ü (i : Œπ), (V i).to_linear_map.range).topological_closure = ‚ä§) (w : ‚Ü•(lp G 2)) : ‚áë((hV.linear_isometry_equiv hV').symm) w = ‚àë' (i : Œπ), ‚áë(V i) (‚áëw i)
{Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±} (hf : function.is_fixed_pt f x) (n : ‚Ñï) : function.is_periodic_pt f n x
(n : ‚Ñï) : (finset.range (n + 1)).sum (Œª (m : ‚Ñï), n.choose m) = 2 ^ n
(q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) : tactic unit
 : Type
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ CommSemiRing SemiRing)
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ‚Ñ§] [category_theory.preadditive C] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] (D : Type u‚ÇÇ) [category_theory.category D] [category_theory.limits.has_zero_object D] [category_theory.has_shift D ‚Ñ§] [category_theory.preadditive D] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor D n).additive] [category_theory.triangulated.pretriangulated C] [category_theory.triangulated.pretriangulated D] : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] {C : Type u} [category_theory.category C] (G : J √ó K ‚•§ C) [category_theory.limits.has_limits C] : category_theory.limits.limit (category_theory.curry.obj (category_theory.prod.swap K J ‚ãô G) ‚ãô category_theory.limits.lim) ‚âÖ category_theory.limits.limit (category_theory.curry.obj G ‚ãô category_theory.limits.lim)
{Œ± : Type u_1} [has_add Œ±] [has_zero Œ±] : list Œ± ‚Üí Œ±
{R : Type u_1} {M : Type u_2} [comm_ring R] {tR : topological_space R} [add_comm_group M] [module R M] (B : module_filter_basis R M) : topological_space M
{Œ± : Type u_1} {Œ≤ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] {ŒΩ : measure_theory.measure Œ≤} [measure_theory.is_finite_measure ŒΩ] {s : set (Œ± √ó Œ≤)} (hs : measurable_set s) : measurable (Œª (x : Œ±), ‚áëŒΩ (prod.mk x ‚Åª¬π' s))
{G : Type u} [group G] [fintype G] {p n : ‚Ñï} [hp : fact (nat.prime p)] {H : subgroup G} (hH : fintype.card ‚Ü•H = p ^ n) : fintype.card ‚Ü•(H.normalizer) ‚â° fintype.card G [MOD p ^ (n + 1)]
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] {a b : Œ±} {s : set Œ±} (hs : is_closed (s ‚à© set.Icc a b)) (ha : a ‚àà s) (hgt : ‚àÄ (x : Œ±), x ‚àà s ‚à© set.Ico a b ‚Üí ‚àÄ (y : Œ±), y ‚àà set.Ioi x ‚Üí (s ‚à© set.Ioc x y).nonempty) : set.Icc a b ‚äÜ s
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s t : set Œ±} : bdd_below s ‚Üí bdd_below t ‚Üí (s ‚à© t).nonempty ‚Üí has_Inf.Inf s ‚äî has_Inf.Inf t ‚â§ has_Inf.Inf (s ‚à© t)
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a : Œ±} : a‚Åª¬π < 1 ‚Üî 1 < a
{n : ‚Ñï} (R : Type u_1) [ring R] : coe ‚àò coe = coe
(r n : ‚Ñï) : (2 * n).choose r ‚â§ n.central_binom
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) (X : C) [category_theory.limits.preserves_limit (category_theory.functor.empty C) G] (l : category_theory.limits.is_terminal X) : category_theory.limits.is_terminal (G.obj X)
{X : Type u_1} {Y : Type u_2} [topological_space X] [add_zero_class Y] : Y ‚Üí+ locally_constant X Y
{Œ± : Type u_1} {Œ≤ : Type u_2} {p : pmf Œ±} (f : Œ† (a : Œ±), a ‚àà p.support ‚Üí pmf Œ≤) (s : set Œ≤) [measurable_space Œ≤] (hs : measurable_set s) : ‚áë((p.bind_on_support f).to_measure) s = ‚àë' (a : Œ±), ‚Üë(‚áëp a) * dite (‚áëp a = 0) (Œª (h : ‚áëp a = 0), 0) (Œª (h : ¬¨‚áëp a = 0), ‚áë((f a h).to_measure) s)
{G : Type u_1} [group G] (H : subgroup G) : Prop
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} (f : J ‚Üí (X ‚ü∂ Y)) [category_theory.limits.has_wide_equalizer f] [nonempty J] : category_theory.limits.is_limit (category_theory.limits.trident.of_Œπ (category_theory.limits.wide_equalizer.Œπ f) _)
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (R : category_theory.presieve X) : category_theory.sieve X
{Œ± : Type u_1} [topological_space Œ±] [baire_space Œ±] {S : set (set Œ±)} (ho : ‚àÄ (s : set Œ±), s ‚àà S ‚Üí is_open s) (hS : S.countable) (hd : ‚àÄ (s : set Œ±), s ‚àà S ‚Üí dense s) : dense (‚ãÇ‚ÇÄ S)
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [category_theory.limits.has_pushout f g] : C
{Œ± : Type u} {P : Œ± ‚Üí Prop} (t : ordnode Œ±) : ordnode.all P t ‚Üí ordnode {a // P a}
{Œπ : Type u_1} {R : Type u_5} {M : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] [fintype Œπ] (e : basis Œπ R M) : (Œπ ‚Üí M) ‚âÉ‚Çó[R] matrix Œπ Œπ R
 : category_theory.large_category CpltSepUniformSpace
{ùïú : Type u_1} [is_R_or_C ùïú] {F : Type u_2} [semi_normed_group F] [normed_space ùïú F] [module ‚Ñù F] [is_scalar_tower ‚Ñù ùïú F] (fr : F ‚Üí‚Çó[‚Ñù] ‚Ñù) : F ‚Üí‚Çó[ùïú] ùïú
{Œ± : Type u} [linear_order Œ±] (p : Œ± ‚Üí Prop) : linear_order (subtype p)
{n : ‚Ñï} {Œ± Œ≤ : typevec n} (h : Œ± = Œ≤) : Œ≤.arrow Œ±
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] (G : C ‚•§ D) (U : D) : category_theory.presieve U
 : expr ‚Üí tactic expr
{M : Type u_1} [comm_monoid M] {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] {g : M ‚Üí* P} (x : M) (F : submonoid.localization_map.away_map x N) (hg : is_unit (‚áëg x)) : N ‚Üí* P
{M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_3} [semigroup_with_zero M‚ÇÄ] [has_zero M‚ÇÄ'] [has_mul M‚ÇÄ'] (f : M‚ÇÄ ‚Üí M‚ÇÄ') (hf : function.surjective f) (zero : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÄ), f (x * y) = f x * f y) : semigroup_with_zero M‚ÇÄ'
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {f' f‚ÇÅ' : E ‚ÜíL[ùïú] F} {x : E} {s : set E} (hf : has_fderiv_within_at f f' s x) (hg : has_fderiv_within_at f f‚ÇÅ' s x) : set.eq_on ‚áëf' ‚áëf‚ÇÅ' (tangent_cone_at ùïú s x)
{Œ± : Type u_1} {p : Œ± ‚Üí Prop} : set.range coe = {x : Œ± | p x}
{R : Type u_1} {a b : R} [add_semigroup R] : is_add_regular (a + b) ‚àß is_add_regular (b + a) ‚Üî is_add_regular a ‚àß is_add_regular b
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b c : Œ±} : -b + a < c ‚Üí a < b + c
(C : Type u) [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] : category_theory.triangulated.triangle C ‚•§ category_theory.triangulated.triangle C
{R : Type u‚ÇÅ} [comm_ring R] (a b : R) : a ^ 2 - b ^ 2 = (a + b) * (a - b)
{R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} [comm_semiring R] [semiring A‚ÇÅ] [semiring A‚ÇÇ] [algebra R A‚ÇÅ] [algebra R A‚ÇÇ] (e : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ) : A‚ÇÅ ‚âÉ‚Çó[R] A‚ÇÇ
{Œ± : Type u_1} [decidable_eq Œ±] (s : finset Œ±) : s.sym2.card = s.card * (s.card + 1) / 2
(e : expr) : tactic (expr √ó expr)
{R : Type u} {S : Type v} [comm_ring R] [comm_ring S] (f : R ‚Üí+* S) : R ‚ß∏ f.ker ‚Üí+* S
{Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≥ : Type u_5} [comm_monoid Œ±] {g : Œ≥ ‚Üí Œ≤} (hg : function.injective g) {f : Œ≤ ‚Üí Œ±} (hf : ‚àÄ (x : Œ≤), x ‚àâ set.range g ‚Üí f x = 1) : filter.map (Œª (s : finset Œ≥), s.prod (Œª (i : Œ≥), f (g i))) filter.at_top = filter.map (Œª (s : finset Œ≤), s.prod (Œª (i : Œ≤), f i)) filter.at_top
{Œ± : Type u} [t : topological_space Œ±] {b : set (set Œ±)} (hb : topological_space.is_topological_basis b) {s : set Œ±} {a : Œ±} : a ‚àà closure s ‚Üî ‚àÄ (o : set Œ±), o ‚àà b ‚Üí a ‚àà o ‚Üí (o ‚à© s).nonempty
 : Type
(G : Type u_1) [group G] : set G
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) [category_theory.limits.has_binary_biproduct P Q] : (category_theory.limits.binary_biproduct.bicone P Q).is_bilimit
(n : ‚Ñï) : (multiset.nat.antidiagonal n).nodup
{Œ± : Type u_1} {Œ≤ : Type u_2} {l : filter Œ±} (f : l.germ Œ≤) (lb : filter Œ≤) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C·µí·µñ ‚•§ D·µí·µñ) [category_theory.limits.preserves_colimit K.op F] : category_theory.limits.preserves_limit K F.unop
{ùïú : Type u} [hnorm : nondiscrete_normed_field ùïú] {E : Type v} [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_smul ùïú E] {F : Type w} [add_comm_group F] [module ùïú F] [topological_space F] [topological_add_group F] [has_continuous_smul ùïú F] [complete_space ùïú] [t2_space E] [t2_space F] [finite_dimensional ùïú E] (e : E ‚âÉ‚Çó[ùïú] F) : E ‚âÉL[ùïú] F
(Œ± : Type u) {Œ≤ : Type v} [add_group Œ±] [add_action Œ± Œ≤] (b : Œ≤) [fintype Œ±] [fintype ‚Ü•(add_action.orbit Œ± b)] [fintype ‚Ü•(add_action.stabilizer Œ± b)] : fintype.card ‚Ü•(add_action.orbit Œ± b) * fintype.card ‚Ü•(add_action.stabilizer Œ± b) = fintype.card Œ±
{Œ± : Type u_1} {Œ≤ : Type u_4} [preorder Œ±] [preorder Œ≤] (u : Œ≤ ‚Üí Œ±) : Type (max u_1 u_4)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (A B : category_theory.limits.cocone F) : Type v‚ÇÉ
{Œ± : Type u} (P : Œ± ‚Üí Prop) [decidable_pred P] (l : list Œ±) : list (list Œ±)
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {v‚ÇÅ v‚ÇÇ : ray_vector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] [nonempty Œ±] {s : set Œ±} (hs : is_compact s) : bdd_above s
{R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group N] [module R N] [lie_ring_module L N] [lie_module R L N] (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) : lie_submodule R L N
(ùïú : Type u_5) (ùïú' : Type u_6) [normed_field ùïú] [semi_normed_ring ùïú'] [normed_algebra ùïú ùïú'] : ùïú ‚ÜíL[ùïú] ùïú'
{Œ± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : filter Œ±} : f =O[l] g ‚Üî ‚àÉ (c : ‚Ñù), asymptotics.is_O_with c l f g
{Œ± : Type u} {Œ≤ : Type v} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) : Œ± ‚äï Œ≤ ‚Üí Œ± ‚äï Œ≤ ‚Üí Prop
 : UniformSpace ‚•§ CpltSepUniformSpace
{Œ± : Type u_2} {Œ≤ : Type u_3} [complete_lattice Œ±] [complete_lattice Œ≤] (f : frame_hom Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : frame_hom Œ± Œ≤
{M : Type u_2} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {Œ±‚ÇÅ : Type u_1} {Œ±‚ÇÇ : Type u_3} (e : Œ±‚ÇÅ ‚âÉ Œ±‚ÇÇ) : (Œ±‚ÇÅ ‚Üí‚ÇÄ M) ‚âÉ‚Çó[R] Œ±‚ÇÇ ‚Üí‚ÇÄ M
{C : Type u} [category_theory.category C] {R X Y : C} {f : X ‚ü∂ Y} {a b : R ‚ü∂ X} (k : category_theory.is_kernel_pair f a b) [r : category_theory.regular_epi f] : category_theory.limits.is_colimit (category_theory.limits.cofork.of_œÄ f _)
(iname : name) (num_params : ‚Ñï) (c : name) : tactic tactic.eliminate.constructor_info
{F : Type u ‚Üí Type u} [functor F] [q : qpf F] {Œ± : Type u} (u : F Œ± ‚Üí Œ±) (x y : (qpf.P F).W) : qpf.Wequiv x y ‚Üí qpf.recF u x = qpf.recF u y
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) (i : fin (n + 1)) : has_dist.dist (s.points i) s.circumcenter = s.circumradius
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) : s.circumcenter ‚àà affine_span ‚Ñù (set.range s.points)
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] {Œπ : Type u_1} [nonempty Œπ] [fintype Œπ] {b : Œπ ‚Üí V} (lin_ind : linear_independent K b) (card_eq : fintype.card Œπ = finite_dimensional.finrank K V) : basis Œπ K V
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (L' : lie_subalgebra R L) : lie_ring ‚Ü•L'
{R : Type u_1} {R‚ÇÅ : Type u_2} {R‚ÇÇ : Type u_3} {M‚ÇÅ : Type u_6} {M‚ÇÇ : Type u_7} [comm_semiring R] [comm_semiring R‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {I‚ÇÅ : R‚ÇÅ ‚Üí+* R} {I‚ÇÇ : R‚ÇÇ ‚Üí+* R} (B : M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ] M‚ÇÇ ‚Üí‚Çõ‚Çó[I‚ÇÇ] R) : Prop
(c : tactic.abel.context) (n : name) (inst : expr) : list expr ‚Üí expr
{Œ± : Type u_1} [lattice Œ±] [bounded_order Œ±] [is_simple_order Œ±] : complete_lattice Œ±
 : name ‚Üí ‚Ñï ‚Üí name
{Œ± : Type u_1} {Œ≤ : Type u_2} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [topological_space Œ≤] [nonempty Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : continuous f) (hlim : filter.tendsto f (filter.cocompact Œ≤) filter.at_top) : ‚àÉ (x : Œ≤), ‚àÄ (y : Œ≤), f x ‚â§ f y
{E : Type u_2} [add_comm_group E] {F : Type u_3} [add_comm_group F] {K : Type u_5} [division_ring K] [module K E] [module K F] (f : linear_pmap K E F) (x : E) (y : F) (hx : x ‚àâ f.domain) : linear_pmap K E F
{S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] {x : S} (hx : is_integral K x) : linear_independent K (Œª (i : fin (minpoly K x).nat_degree), x ^ ‚Üëi)
{C : Type u} [category_theory.category C] {F G : category_theory.discrete category_theory.limits.walking_pair ‚•§ C} (f : F.obj {as := category_theory.limits.walking_pair.left} ‚ü∂ G.obj {as := category_theory.limits.walking_pair.left}) (g : F.obj {as := category_theory.limits.walking_pair.right} ‚ü∂ G.obj {as := category_theory.limits.walking_pair.right}) : F ‚ü∂ G
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {s t : set Œ±} (hst : disjoint s t) (hs : s.finite) (ht : t.finite) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s ‚à™ t), f i)) = finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)) * finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà t), f i))
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {C' : Type u‚ÇÉ} [category_theory.category C'] {D' : Type u‚ÇÑ} [category_theory.category D'] (iC : C ‚•§ C') (iD : D ‚•§ D') {L' : C' ‚•§ D'} {R' : D' ‚•§ C'} (adj : L' ‚ä£ R') {L : C ‚•§ D} {R : D ‚•§ C} (comm1 : iC ‚ãô L' ‚âÖ L ‚ãô iD) (comm2 : iD ‚ãô R' ‚âÖ R ‚ãô iC) [category_theory.full iC] [category_theory.faithful iC] [category_theory.full iD] [category_theory.faithful iD] : L ‚ä£ R
{Œ± : Type u_1} (s : set Œ±) (M : Type u_2) [add_comm_monoid M] : {f // ‚Üë(f.support) ‚äÜ s} ‚âÉ (‚Ü•s ‚Üí‚ÇÄ M)
{Œ± : Type u_1} : Œ± ‚Ü™ with_top Œ±
(v : ‚Ñï ‚Üí ‚Ñ§) (b : ‚Ñ§) (as : list ‚Ñ§) (n : ‚Ñï) : ‚Ñ§
{a b : ‚Ñï} (hab : a.coprime b) : disjoint a.factorization.support b.factorization.support
(t s : omega.nat.preterm) (p : omega.nat.preform) : ‚Ñï
 : name ‚Üí tactic ‚Ñï
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [semi_normed_group E] [normed_space ùïú E] : normed_space.dual ùïú E ‚âÉ‚Çó[ùïú] weak_dual ùïú E
{K : Type u} [field K] (s : subfield K) : subfield.closure ‚Üës = s
 : num ‚Üí num ‚Üí num
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_products C] : (category_theory.prod_comonad X).coalgebra ‚•§ category_theory.over X
 : linter
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {l : filter Œ±} {a : Œ±} : is_min_filter (‚áëorder_dual.to_dual ‚àò f) l a ‚Üí is_max_filter f l a
{R : Type u} [comm_ring R] [is_domain R] [discrete_valuation_ring R] (œñ : R) : irreducible œñ ‚Üî local_ring.maximal_ideal R = ideal.span {œñ}
(_x : interactive.parse (lean.parser.tk "pformat!")) (s : string) : lean.parser pexpr
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÇ] [has_zero M‚ÇÇ] [has_scalar ‚Ñï M‚ÇÇ] [has_neg M‚ÇÇ] [has_sub M‚ÇÇ] [has_scalar ‚Ñ§ M‚ÇÇ] [add_comm_group M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (inv : ‚àÄ (x : M‚ÇÅ), f (-x) = -f x) (div : ‚àÄ (x y : M‚ÇÅ), f (x - y) = f x - f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : add_comm_group M‚ÇÇ
{Œ± : Type u} [partial_order Œ±] {a b : Œ±} (hab : a ‚â§ b) (hba : ¬¨a < b) : b = a
{G : Type u_1} {H : Type u_2} [group G] [group H] (f : G ‚Üí* H) : shelf_hom (quandle.conj G) (quandle.conj H)
(C : Type u_1) {D : Type u_2} {E : Type u_3} [category_theory.category C] [category_theory.category D] [category_theory.category E] {F : D ‚•§ E} {G : E ‚•§ D} (adj : F ‚ä£ G) : (category_theory.whiskering_right C D E).obj F ‚ä£ (category_theory.whiskering_right C E D).obj G
{G : Type u_1} [add_comm_group G] (K : add_subgroup G) (g : multiset G) : (‚àÄ (a : G), a ‚àà g ‚Üí a ‚àà K) ‚Üí g.sum ‚àà K
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] : filter_basis (L ‚âÉ‚Çê[K] L)
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_3} (s : set Œπ) (t : Œ† (i : Œπ), set (Œ± i)) : set (Œ£ (i : Œπ), Œ± i)
{Œ∑ : Type u_14} [fintype Œ∑] {Œ± : Type u_1} {Œπs : Œ∑ ‚Üí Type u_2} [add_monoid Œ±] : ((Œ£ (j : Œ∑), Œπs j) ‚Üí‚ÇÄ Œ±) ‚âÉ+ Œ† (j : Œ∑), Œπs j ‚Üí‚ÇÄ Œ±
{R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] [nontrivial R] [nonempty Œπ] (e : basis Œπ R M) (x : orientation R M Œπ) : basis Œπ R M
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) [fintype Œπ] (p : Œπ ‚Üí P) : finset.centroid k s p = ‚áë(finset.univ.affine_combination p) (finset.centroid_weights_indicator k s)
 : pgame ‚Üí Type u
{Œ± : Type u_2} [decidable_eq Œ±] [has_mul Œ±] : has_mul (finset Œ±)
(n : ‚Ñï) : filter.tendsto (Œª (x : ‚Ñù), real.exp x / x ^ n) filter.at_top filter.at_top
(m n : ‚Ñï) : nat.fib (m + n + 1) = nat.fib m * nat.fib n + nat.fib (m + 1) * nat.fib (n + 1)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (s : multiset Œ±) : multiset Œ≤
{M : Type u_1} {Œ± : Type u_6} {Œ≤ : Type u_7} [add_monoid M] [add_action M Œ±] [has_vadd M Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (smul : ‚àÄ (c : M) (x : Œ≤), f (c +·µ• x) = c +·µ• f x) : add_action M Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.limits.preserves_limit K F] : category_theory.limits.preserves_limit K G
(R : Type u_3) [comm_semiring R] {M : Type u_7} {N‚Çó : Type u_12} {P‚Çó : Type u_13} [add_comm_monoid M] [add_comm_monoid N‚Çó] [add_comm_monoid P‚Çó] [module R M] [module R N‚Çó] [module R P‚Çó] (f : M ‚Üí N‚Çó ‚Üí P‚Çó) (H1 : ‚àÄ (m‚ÇÅ m‚ÇÇ : M) (n : N‚Çó), f (m‚ÇÅ + m‚ÇÇ) n = f m‚ÇÅ n + f m‚ÇÇ n) (H2 : ‚àÄ (c : R) (m : M) (n : N‚Çó), f (c ‚Ä¢ m) n = c ‚Ä¢ f m n) (H3 : ‚àÄ (m : M) (n‚ÇÅ n‚ÇÇ : N‚Çó), f m (n‚ÇÅ + n‚ÇÇ) = f m n‚ÇÅ + f m n‚ÇÇ) (H4 : ‚àÄ (c : R) (m : M) (n : N‚Çó), f m (c ‚Ä¢ n) = c ‚Ä¢ f m n) : M ‚Üí‚Çó[R] N‚Çó ‚Üí‚Çó[R] P‚Çó
{R : Type u_4} [non_unital_non_assoc_semiring R] : has_mul (add_submonoid R)
{R : Type u_1} {X : Type u_2} [comm_semiring R] [char_zero R] : char_zero (free_algebra R X)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_epi f] (F : C ‚•§ D) : category_theory.split_epi (F.map f)
(Œ± : Type u) [topological_space Œ±] : Prop
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] (f : S.localization_map N) : M ‚Üí* N
{Œì : Type u_1} [inhabited Œì] (l‚ÇÅ l‚ÇÇ : list Œì) : Prop
{Œ≤ : Type w} {C : Type u} [category_theory.category C] {f : Œ≤ ‚Üí C} [category_theory.limits.has_product f] {P : C} (p : Œ† (b : Œ≤), P ‚ü∂ f b) : P ‚ü∂ ‚àè f
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {Œ± : Type u_2} [add_right_cancel_semigroup Œ±] [has_one Œ±] [decidable_eq Œ±] (X : Œ± ‚Üí V) (d : Œ† (n : Œ±), X (n + 1) ‚ü∂ X n) (sq : ‚àÄ (n : Œ±), d (n + 1) ‚â´ d n = 0) : chain_complex V Œ±
{M : Type u_1} [add_group M] (c : add_con M) : add_group c.quotient
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_wide_pullbacks C] {A : C} (s : set (category_theory.subobject A)) : category_theory.subobject.wide_pullback s ‚ü∂ A
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p1 : P} (hp1 : p1 ‚àà s) (p2 p : P) : p ‚àà affine_span k (has_insert.insert p2 ‚Üës) ‚Üî ‚àÉ (r : k) (p0 : P) (hp0 : p0 ‚àà s), p = r ‚Ä¢ (p2 -·µ• p1) +·µ• p0
{Œ± : Type u_1} {p : Œ† (s : finset Œ±), s.nonempty ‚Üí Prop} (h‚ÇÄ : ‚àÄ (a : Œ±), p {a} _) (h‚ÇÅ : ‚àÄ ‚¶Éa : Œ±‚¶Ñ (s : finset Œ±) (h : a ‚àâ s) (hs : s.nonempty), p s hs ‚Üí p (finset.cons a s h) _) {s : finset Œ±} (hs : s.nonempty) : p s hs
{Œ± : Type u_1} [ordered_cancel_add_comm_monoid Œ±] {s t : set Œ±} (hs : s.is_pwo) (ht : t.is_pwo) (a : Œ±) : finset (Œ± √ó Œ±)
 : free_comm_ring pempty ‚âÉ+* ‚Ñ§
(L : first_order.language) : Type (max u v)
(Œ± : Type u_1) : Type u_1
 : punit ‚âÉ punit
{C : Type u‚ÇÅ} [category_theory.category C] {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B) [category_theory.mono f] [category_theory.mono g] (h : category_theory.subobject.mk f = category_theory.subobject.mk g) : A‚ÇÅ ‚âÖ A‚ÇÇ
{R : Type u} {M : Type v} [comm_ring R] [add_comm_group M] [module R M] (B : bilin_form R M) : lie_subalgebra R (module.End R M)
(n : ‚Ñï) : finset n.partition
{G : Type u_1} [sub_neg_monoid G] [measurable_space G] [has_measurable_add G] (g : G) : measurable (Œª (h : G), h - g)
{Œ± : Type u} {Œ≤ : Type v} [has_le Œ±] [has_top Œ±] [has_le Œ≤] [order_top Œ≤] (f : Œ± ‚Üí Œ≤) (map_le : ‚àÄ (a b : Œ±), f a ‚â§ f b ‚Üí a ‚â§ b) (map_top : f ‚ä§ = ‚ä§) : order_top Œ±
 : Type
{Œ± : Type u} {m : Type u ‚Üí Type v} [monad m] [alternative m] (tac : Œ± ‚Üí m punit) : list Œ± ‚Üí m Œ±
{M : Type u_1} [has_mul M] {c d : con M} (H : setoid.r = setoid.r) : c = d
{Œ± : Type u} [uniform_space Œ±] (a : Œ±) : Cauchy Œ±
{Œ± : Type u} [linear_ordered_add_comm_group Œ±] {Œ≤ : Type u_1} [has_zero Œ≤] [has_add Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (inv : ‚àÄ (x : Œ≤), f (-x) = -f x) (div : ‚àÄ (x y : Œ≤), f (x - y) = f x - f y) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zpow : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : linear_ordered_add_comm_group Œ≤
(G : Type u) : Type u
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) (t : ordnode Œ±) : option ‚Ñï
{p : ‚Ñï} [hp : fact (nat.prime p)] (n : ‚Ñï) {R : Type u_1} [comm_ring R] : witt_vector p R ‚Üí+* truncated_witt_vector p n R
{A : Type u_1} [normed_ring A] [normed_algebra ‚ÑÇ A] [star_ring A] [has_continuous_star A] [complete_space A] [star_module ‚ÑÇ A] (a : ‚Ü•(self_adjoint A)) : ‚Ü•(unitary A)
(Œ± : Type u_2) : Type u_2
 : Group.free ‚ä£ category_theory.forget Group
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ‚ü∂ Y} {D : Type u'} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (F : C ‚•§ D) [category_theory.is_equivalence F] : category_theory.limits.parallel_pair f 0 ‚ãô F ‚âÖ category_theory.limits.parallel_pair (F.map f) 0
(S : finset turing.partrec_to_TM2.Œõ') : turing.partrec_to_TM2.Œõ' ‚Üí Prop
{G : Type u_1} [group G] : smul_comm_class ‚Ü•(subgroup.center G) G G
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [cs : complete_space E] (f : E ‚Üí F) (f' : E ‚âÉL[ùïú] F) (a : E) (hf : has_strict_fderiv_at f ‚Üëf' a) : F ‚Üí E
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] : galois_connection (Œª (s : set A), projective_spectrum.zero_locus ùíú s) (Œª (t : (set (projective_spectrum ùíú))·µí·µà), ‚Üë(projective_spectrum.vanishing_ideal t))
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {X Y : category_theory.simplicial_object C} (f : X ‚ü∂ Y) : algebraic_topology.alternating_face_map_complex.obj X ‚ü∂ algebraic_topology.alternating_face_map_complex.obj Y
{k : Type u_1} {V‚ÇÅ : Type u_6} {V‚ÇÇ : Type u_7} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] (e : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) : V‚ÇÅ ‚âÉ·µÉ[k] V‚ÇÇ
(R : Type u) (M : Type v) (M‚ÇÇ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] : submodule R (M √ó M‚ÇÇ)
{J : Type v} : category_theory.limits.wide_pushout_shape J ‚Üí category_theory.limits.wide_pushout_shape J ‚Üí Type v
(Œ± : Type u_1) : Type u_1
{F : Type u_1} [field F] (p : polynomial F) (E : Type u_2) [field E] [algebra F E] [fact (polynomial.splits (algebra_map F E) p)] : p.gal ‚Üí* equiv.perm ‚Ü•(p.root_set E)
{Œ± : Type u_1} (p q : Œ± ‚Üí Prop) [decidable_pred p] : {x // p x ‚à® q x} ‚Ü™ {x // p x} ‚äï {x // q x}
{ùïú : Type u_3} {E : Type u_4} [semi_normed_ring ùïú] [add_comm_group E] [has_scalar ùïú E] (p : seminorm ùïú E) (x : E) (r : ‚Ñù) : set E
{Œ± : Type u_3} {Œ≤ : Type u_4} [nonempty Œ±] [semilattice_inf Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : monotone f) : filter.tendsto f filter.at_bot filter.at_bot ‚Üî ‚àÄ (b : Œ≤), ‚àÉ (a : Œ±), f a ‚â§ b
{R : Type v} [comm_ring R] {n : ‚Ñï} (A : matrix (fin n.succ) (fin n.succ) R) : A.det = finset.univ.sum (Œª (i : fin n.succ), (-1) ^ ‚Üëi * A i 0 * (A.minor ‚áë(i.succ_above) fin.succ).det)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (F : C ‚•§ D) [category_theory.limits.has_colimits_of_shape J D] [category_theory.creates_colimits_of_shape J F] : category_theory.limits.has_colimits_of_shape J C
(Œ± : Type u_1) [finite Œ±] : fintype Œ±
{Œ± : Type u_1} : Œ± ‚âÉ lex Œ±
(Œ± : Type u_1) [topological_space Œ±] : filter Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Ü™ Œ≤) (s : finset Œ±) : finset Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] (F : C·µí·µñ ‚•§ Type v‚ÇÅ) [F.representable] : C
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {R : ‚Ñù} {c w : ‚ÑÇ} {f : ‚ÑÇ ‚Üí E} {s : set ‚ÑÇ} (hs : s.countable) (hw : w ‚àà metric.ball c R) (hc : continuous_on f (metric.closed_ball c R)) (hd : ‚àÄ (x : ‚ÑÇ), x ‚àà metric.ball c R  s ‚Üí differentiable_at ‚ÑÇ f x) : ‚àÆ (z : ‚ÑÇ) in C(c, R), (z - w)‚Åª¬π ‚Ä¢ f z = (2 * ‚Üëreal.pi * complex.I) ‚Ä¢ f w
 : tactic (list name)
(M : Type u_1) (N : Type u_2) [add_monoid M] [add_monoid N] : Type (max u_2 u_1)
{Œ± : Type u_1} : list (option Œ±) ‚Üí list Œ±
{X : Type u} [topological_space X] (x‚ÇÄ x‚ÇÅ : X) : Type u
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] {a b : Œ±} {s : set Œ±} (hs : is_closed (s ‚à© set.Icc a b)) (ha : a ‚àà s) (hab : a ‚â§ b) (hgt : ‚àÄ (x : Œ±), x ‚àà s ‚à© set.Ico a b ‚Üí (s ‚à© set.Ioc x b).nonempty) : b ‚àà s
{R : Type u_4} [linear_ordered_ring R] (a : R) : 0 ‚â§ a ^ 2
{K : Type u_1} {v : K} {n : ‚Ñï} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : 1 ‚â§ ifp_succ_n.b
 : vm name
(R : Type u) [comm_semiring R] {M : Type v} [add_comm_monoid M] [module R M] {s : finset M} (b : basis ‚Ü•s R M) (f : M ‚Üí‚Çó[R] M) : ‚áë(linear_map.trace R M) f = (‚áë(linear_map.to_matrix b b) f).trace
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.sheaf C X) (U V : topological_space.opens ‚Ü•X) (h : U ‚à© V = ‚ä•) : category_theory.limits.is_limit (category_theory.limits.binary_fan.mk (F.val.map (category_theory.hom_of_le _).op) (F.val.map (category_theory.hom_of_le _).op))
(Œ± : Type u_2) [has_le Œ±] : Œ± ‚âÉo Œ±·µí·µà·µí·µà
{R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] [is_domain S] (H : algebra.is_integral R S) (P : ideal R) [P_max : P.is_maximal] (hP : (algebra_map R S).ker ‚â§ P) : ‚àÉ (Q : ideal S), Q.is_maximal ‚àß ideal.comap (algebra_map R S) Q = P
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : set Œ±) : Prop
(M : Type u_1) (Œ± : Type u_2) [monoid M] [mul_action M Œ±] : galois_connection (‚áëorder_dual.to_dual ‚àò fixing_submonoid M) ((Œª (P : submonoid M), mul_action.fixed_points ‚Ü•P Œ±) ‚àò ‚áëorder_dual.of_dual)
{n : ‚Ñï} (F : typevec n ‚Üí Type u_2) [mvfunctor F] : Prop
{n : Type u_1} {R : Type u‚ÇÇ} [decidable_eq n] [comm_ring R] (t : matrix.transvection_struct n R) : matrix.transvection_struct n R
 : Bipointed ‚•§ Pointed
{Œ± : Type u_1} : (tactic.impl_graph ‚Üí tactic Œ±) ‚Üí tactic Œ±
{Œ± : Type u} {Œ≤ : Type v} [h : can_lift Œ± Œ≤] : can_lift (list Œ±) (list Œ≤)
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) : Type v
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] [fintype R] : fintype S
(X : Type u_3) [topological_space X] : Prop
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_5} [measurable_space Œ±] [measurable_space Œ≤] [measurable_space Œ≥] {Œ¥ : Type u_7} [measurable_space Œ¥] {Œºa : measure_theory.measure Œ±} {Œºb : measure_theory.measure Œ≤} {Œºc : measure_theory.measure Œ≥} {Œºd : measure_theory.measure Œ¥} [measure_theory.sigma_finite Œºb] [measure_theory.sigma_finite Œºd] {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥} (hf : measure_theory.measure_preserving f Œºa Œºb) (hg : measure_theory.measure_preserving g Œºc Œºd) : measure_theory.measure_preserving (prod.map f g) (Œºa.prod Œºc) (Œºb.prod Œºd)
(C : Type u) [category_theory.category C] : Prop
 : filter.tendsto complex.abs (filter.cocompact ‚ÑÇ) filter.at_top
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M ‚Üí+ P} (H : c ‚â§ add_con.ker f) (x : M) : ‚áë(c.lift f H) ‚Üëx = ‚áëf x
(Œì‚ÇÄ : Type u_1) [linear_ordered_comm_group_with_zero Œì‚ÇÄ] : topological_space Œì‚ÇÄ
{n : ‚Ñï} (i j : Œ£ (a : composition n), composition a.length) : i = j ‚Üî i.fst.blocks = j.fst.blocks ‚àß i.snd.blocks = j.snd.blocks
{K : Type u_1} [linear_ordered_field K] {a b c : K} (h : ‚àÄ (x : K), 0 ‚â§ a * x * x + b * x + c) : discrim a b c ‚â§ 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (direction : submodule k V) : p ‚àà affine_subspace.mk' p direction
 : interactive.parse tactic.rintro_parse ‚Üí tactic unit
 : pgame ‚Üí pgame ‚Üí Prop
{M : Type u_1} [has_mul M] {c : con M} {C : c.quotient ‚Üí Prop} (q : c.quotient) (H : ‚àÄ (x : M), C ‚Üëx) : C q
{Œπ : Type u} {Œ≥ : Type w} [dec : decidable_eq Œπ] [add_comm_monoid Œ≥] (S : Œπ ‚Üí add_submonoid Œ≥) : supr S = (dfinsupp.sum_add_hom (Œª (i : Œπ), (S i).subtype)).mrange
(p : ‚Ñï) [hp : fact (nat.prime p)] {q : ‚Ñö} (hq : q ‚â† 0) : padic_norm p q ‚â† 0
{R : Type u} [ring R] {P : Type (max u v)} [add_comm_group P] [module R P] : module.projective R P ‚Üî category_theory.projective (Module.of R P)
{R : Type u} [ring R] : category_theory.limits.has_kernels (Module R)
{R : Type u_1} [normed_ring R] [complete_space R] (x : RÀ£) : continuous_at ring.inverse ‚Üëx
{Œπ : Type u_1} [decidable_eq Œπ] (R : Type u_4) [comm_semiring R] {s : Œπ ‚Üí Type u_7} [Œ† (i : Œπ), add_comm_monoid (s i)] [Œ† (i : Œπ), module R (s i)] (r : R) (f : Œ† (i : Œπ), s i) : pi_tensor_product R (Œª (i : Œπ), s i)
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x ‚àà s ‚Üí y ‚àà s ‚Üí x + y ‚àà s
{R : Type u_1} {S : Type u_6} [semiring R] [semiring S] (f : R ‚Üí+* S) : R ‚Üí‚Çõ‚Çó[f] S
 : ‚Ñï ‚Üí tactic unit ‚Üí tactic unit
{Œ± : Type u_3} {Œ≤ : Type u_4} [group Œ±] (a : Œ±) [mul_action Œ± Œ≤] (b : Œ≤) : ‚Ü•(mul_action.orbit ‚Ü•(subgroup.zpowers a) b) ‚âÉ zmod (function.minimal_period (has_scalar.smul a) b)
{ùïú : Type u_1} {_x : comm_ring ùïú} {E : Type u_2} [semi_normed_ring E] {_x_1 : algebra ùïú E} (s : subalgebra ùïú E) : semi_normed_ring ‚Ü•s
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {C r : nnreal} {f : X ‚Üí Y} (h : holder_with C r f) (hr : 0 < r) : dimH (set.range f) ‚â§ dimH set.univ / ‚Üër
{R : Type u} [comm_ring R] : category_theory.limits.has_limits_of_size (Algebra R)
{Œ± : Type u_1} [topological_space Œ±] [polish_space Œ±] : polish_space (‚Ñï ‚Üí Œ±)
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [non_unital_comm_ring Œ≤] : non_unital_comm_ring Œ±
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s t : set Œ±} (hs : bdd_above s) (ht : bdd_above t) (hst : (s ‚à© t).nonempty) : has_Sup.Sup (s ‚à© t) ‚â§ has_Sup.Sup s ‚äì has_Sup.Sup t
(Œ± : Type v) [small Œ±] : Type w
{S : Type v} (s : S) {R : Type u_1} [linear_ordered_comm_ring R] [set_like S R] [subring_class S R] : linear_ordered_comm_ring ‚Ü•s
{Œ± : Type v} {m l r : ‚Ñï} (A : matrix (fin m) (fin (l + r)) Œ±) : matrix (fin m) (fin r) Œ±
{X Y : AddCommGroup} (e : ‚Ü•X ‚âÉ+ ‚Ü•Y) : X ‚âÖ Y
{P L : Type u} [has_mem P L] [configuration.nondegenerate P L] [fintype P] [fintype L] (h : fintype.card L ‚â§ fintype.card P) : ‚àÉ (f : L ‚Üí P), function.injective f ‚àß ‚àÄ (l : L), f l ‚àâ l
 : ‚Ñï+ ‚Üí* ‚Ñï
(G : Type u_1) [division_comm_monoid G] : G ‚âÉ* G
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_scalar Œ± Œ≤] : has_scalar (filter Œ±) (filter Œ≤)
 : pos_num ‚Üí pos_num ‚Üí pos_num
(C : Type u) [category_theory.category C] [category_theory.has_shift C ‚Ñ§] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (h : Z ‚ü∂ (category_theory.shift_functor C 1).obj X) : category_theory.triangulated.triangle C
{Œ± : Type u_1} (a : Œ±) (n : ‚Ñï) : multiset Œ±
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] {M : matrix n n R} {i j : n} (i_ne_j : i ‚â† j) (hij : ‚àÄ (k : n), M k i = M k j) : M.det = 0
{G : Type u} {x : G} {n : ‚Ñï} [monoid G] (hn : 0 < n) (hx : x ^ n = 1) (hd : ‚àÄ (p : ‚Ñï), nat.prime p ‚Üí p ‚à£ n ‚Üí x ^ (n / p) ‚â† 1) : order_of x = n
 : tactic unit
(n : ‚Ñï) : ‚Ñï ‚Üí‚ÇÄ ‚Ñï
{M : Type u_1} [add_monoid M] {x : M} : add_monoid.closure {x} = multiples x
{Œ± : Type u_2} [add_comm_monoid Œ±] {A : set Œ±} {n : ‚Ñï} {Œ≤ : Type u_1} [add_comm_group Œ≤] : add_comm_group (A ‚Üí+[n] Œ≤)
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} : category_theory.mono_over.lift (ùü≠ (category_theory.over X)) category_theory.mono_over.lift_id._proof_1 ‚âÖ ùü≠ (category_theory.mono_over X)
{C : Sort u_1} : empty ‚Üí C
{K : Type w} [field K] {f : polynomial K} (hf : f ‚â† 0) : basis (fin f.nat_degree) K (adjoin_root f)
(Œ± : Type u) : Type u
{Œ≥ : Type u_3} [topological_space Œ≥] [compact_space Œ≥] [t2_space Œ≥] : uniform_space Œ≥
{Œ± : Type u_1} (Œ≤ : Œ± ‚Üí Type u_2) (a : Œ±) (h : a ‚àà ‚àÖ) : Œ≤ a
{Œ± : Type u} [pseudo_metric_space Œ±] {x : Œ±} {r : ‚Ñù} : metric.bounded (metric.sphere x r)
(k : Type u) [field k] (f : algebraic_closure.monic_irreducible k) : mv_polynomial (algebraic_closure.monic_irreducible k) k
{R : Type u} {L‚ÇÅ : Type v} [comm_ring R] [lie_ring L‚ÇÅ] [lie_algebra R L‚ÇÅ] : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÅ
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) : 2 ‚Ä¢ hb.oangle (-x) y = 2 ‚Ä¢ hb.oangle x y
{Œ± : Type u_1} [uniform_space Œ±] {s : set (Œ± √ó Œ±)} (hs : s ‚àà uniformity Œ±) : ‚àÄ·∂† (t : set (Œ± √ó Œ±)) in (uniformity Œ±).small_sets, comp_rel t t ‚äÜ s
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) : hb.rotation 0 = linear_isometry_equiv.refl ‚Ñù V
{C : Type u} [category_theory.category C] [category_theory.limits.has_strict_terminal_objects C] {J : Type v} [category_theory.small_category J] (F : J ‚•§ C) [category_theory.limits.has_limit F] (i : J) (H : Œ† (j : J), j ‚â† i ‚Üí category_theory.limits.is_terminal (F.obj j)) [subsingleton (i ‚ü∂ i)] : category_theory.is_iso (category_theory.limits.limit.œÄ F i)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) (b : Œ≤ a) (s : finmap Œ≤) : finmap Œ≤
{R : Type u} [ring R] {s : set R} (hcomm : ‚àÄ (a : R), a ‚àà s ‚Üí ‚àÄ (b : R), b ‚àà s ‚Üí a * b = b * a) : comm_ring ‚Ü•(subring.closure s)
{Œ± : Type u} [linear_order Œ±] (a b : Œ±) : set Œ±
{C : Type u‚ÇÇ} [category_theory.category C] [category_theory.limits.has_binary_products C] {J : Type v‚ÇÇ} [category_theory.small_category J] {K : J ‚•§ C} (X : C) : K ‚ãô category_theory.limits.prod.functor.obj X ‚ü∂ K
{Œ± : Type u_1} (S : set (set Œ±)) : set Œ±
(M : Type u_1) (N : Type u_2) [semiring M] [semiring N] : Type (max u_1 u_2)
{R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {Œπ : Type u_6} [decidable_eq Œπ] {S : Type u_7} [semiring S] [module S N] [smul_comm_class R S N] : module S (alternating_map R M N Œπ)
{Œπ : Type u_1} (c : complex_shape Œπ) (j : Œπ) : option {i // c.rel i j}
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (S T : submodule R M) (h : S ‚â§ T) : (M ‚ß∏ S) ‚ß∏ submodule.map S.mkq T ‚Üí‚Çó[R] M ‚ß∏ T
{G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)
(Œ± : Type u_1) : Type u_1
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) (s : category_theory.limits.cocone F) : CommRing.colimits.colimit F ‚ü∂ s.X
{x : pgame} (h : x ‚â§ 0) (i : x.left_moves) : (x.move_left i).move_right (pgame.right_response h i) ‚â§ 0
(V : Type v) [category_theory.category V] [category_theory.monoidal_category V] {C : Type u‚ÇÅ} [category_theory.enriched_category V C] (X Y Z : C) : category_theory.enriched_category.hom X Y ‚äó category_theory.enriched_category.hom Y Z ‚ü∂ category_theory.enriched_category.hom X Z
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) (j : J) : (category_theory.limits.types.limit_cone (F ‚ãô category_theory.forget Mon)).X ‚Üí* (F ‚ãô category_theory.forget Mon).obj j
 : expr ‚Üí tactic.unsafe.type_context (expr √ó list level √ó list expr)
(G : pgame) : Prop
{R : Type u} [comm_semiring R] {A : Type v‚ÇÅ} [semiring A] [algebra R A] {B : Type v‚ÇÇ} [semiring B] [algebra R B] {C : Type v‚ÇÉ} [semiring C] [algebra R C] {D : Type v‚ÇÑ} [semiring D] [algebra R D] (f : tensor_product R (tensor_product R A B) C ‚âÉ‚Çó[R] D) (w‚ÇÅ : ‚àÄ (a‚ÇÅ a‚ÇÇ : A) (b‚ÇÅ b‚ÇÇ : B) (c‚ÇÅ c‚ÇÇ : C), ‚áëf ((a‚ÇÅ * a‚ÇÇ) ‚äó‚Çú[R] (b‚ÇÅ * b‚ÇÇ) ‚äó‚Çú[R] (c‚ÇÅ * c‚ÇÇ)) = ‚áëf (a‚ÇÅ ‚äó‚Çú[R] b‚ÇÅ ‚äó‚Çú[R] c‚ÇÅ) * ‚áëf (a‚ÇÇ ‚äó‚Çú[R] b‚ÇÇ ‚äó‚Çú[R] c‚ÇÇ)) (w‚ÇÇ : ‚àÄ (r : R), ‚áëf (‚áë(algebra_map R A) r ‚äó‚Çú[R] 1 ‚äó‚Çú[R] 1) = ‚áë(algebra_map R D) r) : tensor_product R (tensor_product R A B) C ‚âÉ‚Çê[R] D
{R : Type u_1} [comm_semiring R] (M : Type u_4) {N : Type u_5} {P : Type u_6} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] : (N ‚Üí‚Çó[R] P) ‚Üí‚Çó[R] tensor_product R N M ‚Üí‚Çó[R] tensor_product R P M
{G : Type u} [group G] [fintype G] {N : subgroup G} [N.normal] (h1 : (fintype.card ‚Ü•N).coprime N.index) (h2 : ‚àÄ (G' : Type u) [_inst_4 : group G'] [_inst_5 : fintype G'], fintype.card G' < fintype.card G ‚Üí ‚àÄ {N' : subgroup G'} [_inst_6 : N'.normal], (fintype.card ‚Ü•N').coprime N'.index ‚Üí (‚àÉ (H' : subgroup G'), N'.is_complement' H')) (h3 : ‚àÄ (H : subgroup G), ¬¨N.is_complement' H) : N.is_commutative
{Œ± : Type u_1} (p : pmf Œ±) : measure_theory.outer_measure Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] {F G H : category_theory.lax_monoidal_functor C D} (Œ± : category_theory.monoidal_nat_trans F G) (Œ≤ : category_theory.monoidal_nat_trans G H) : category_theory.monoidal_nat_trans F H
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (s : set E) (x : E) : formal_multilinear_series ùïú E F
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [semi_normed_group E] [normed_space ùïú E] (s : set E) : is_closed (weak_dual.polar ùïú s)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {v : ‚Ñù ‚Üí E ‚Üí E} {K : nnreal} (hv : ‚àÄ (t : ‚Ñù), lipschitz_with K (v t)) {f g : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : continuous_on f (set.Icc a b)) (hf' : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_deriv_within_at f (v t (f t)) (set.Ici t) t) (hg : continuous_on g (set.Icc a b)) (hg' : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_deriv_within_at g (v t (g t)) (set.Ici t) t) (ha : f a = g a) (t : ‚Ñù) (H : t ‚àà set.Icc a b) : f t = g t
(R : Type u) [ring R] [strong_rank_condition R] {Œπ : Type v} : module.rank R (Œπ ‚Üí‚ÇÄ R) = (cardinal.mk Œπ).lift
{X : Type u_1} [topological_space X] (x y : X) : Prop
(G : Type u) [add_group G] : add_monoid G
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f‚ÇÇ : ùïú ‚Üí F} {n : ‚Ñï} : cont_diff ùïú ‚Üë(n + 1) f‚ÇÇ ‚Üî differentiable ùïú f‚ÇÇ ‚àß cont_diff ùïú ‚Üën (deriv f‚ÇÇ)
(F : Type u_9) (Œ± : Type u_10) (Œ≤ : Type u_11) [add_monoid Œ±] [add_monoid Œ≤] [topological_space Œ±] [topological_space Œ≤] : Type (max u_10 u_11 u_9)
{M : Type u_1} {N : Type u_2} {P : Type u_3} {Q : Type u_4} [has_mul P] [has_mul Q] (f : M ‚âÉ N) (g : P ‚âÉ* Q) : (M ‚Üí P) ‚âÉ* (N ‚Üí Q)
(n : ‚Ñï) (R : Type u_1) [comm_ring R] : (polynomial.cyclotomic n R).is_primitive
{Œ± : Type u_1} [has_compl Œ±] [has_sup Œ±] [has_inf Œ±] (a b : Œ±) : Œ±
(ty : expr) : tactic norm_cast.label
{Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : is_compact s) (ht : is_open t) : is_compact (s  t)
{M : Type u_9} {M‚ÇÇ : Type u_11} [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] (f : M ‚Üí+ M‚ÇÇ) : M ‚Üí‚Çó[‚Ñï] M‚ÇÇ
{M : Type u_1} {N : Type u_2} (Œ± : Type u_6) [monoid M] [mul_action M Œ±] [monoid N] (g : N ‚Üí* M) : mul_action N Œ±
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (S : add_subsemigroup N) : add_subsemigroup M
{L : first_order.language} (T : L.Theory) {M : T.Model} (S : L.elementary_substructure ‚Ü•M) : T.Model
(n : ‚Ñ§) : ‚áëzmod.œá‚Çà ‚Üën = ite (n % 2 = 0) 0 (ite (n % 8 = 1 ‚à® n % 8 = 7) 1 (-1))
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {f : ‚ÑÇ ‚Üí E} {c : ‚ÑÇ} {R : nnreal} (hf : circle_integrable f c ‚ÜëR) (hR : 0 < R) : has_fpower_series_on_ball (Œª (w : ‚ÑÇ), (2 * ‚Üëreal.pi * complex.I)‚Åª¬π ‚Ä¢ ‚àÆ (z : ‚ÑÇ) in C(c, ‚ÜëR), (z - w)‚Åª¬π ‚Ä¢ f z) (cauchy_power_series f c ‚ÜëR) c ‚ÜëR
(e : expr) : tactic expr
{ùíú : Type u_1} [category_theory.category ùíú] {A B C : ùíú} (f : A ‚ü∂ B) (g : B ‚ü∂ C) [category_theory.limits.has_zero_morphisms ùíú] [category_theory.limits.has_binary_biproducts ùíú] : Type u_2
{J : Type v} [category_theory.small_category J] (F : J ‚•§ category_theory.Cat) (s : category_theory.limits.cone F) : s.X ‚ü∂ category_theory.Cat.has_limits.limit_cone_X F
(G : Type u) [group G] : monoid G
{Œ± : Type u_1} {s : set Œ±} (p : ‚Ü•s) : ‚Üëp ‚àà s
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.ess_surj (category_theory.shift_functor C i)
(R : Type u) [comm_ring R] (U : topological_space.opens ‚Ü•(algebraic_geometry.prime_spectrum.Top R)) (x : ‚Ü•(algebraic_geometry.prime_spectrum.Top R)) (hx : x ‚àà U) : (algebraic_geometry.Spec.structure_sheaf R).val.obj (opposite.op U) ‚ü∂ CommRing.of (localization.at_prime (prime_spectrum.as_ideal x))
{L : first_order.language} {M : Type w} [L.Structure M] {S T : L.substructure M} (h : ‚àÄ (x : M), x ‚àà S ‚Üî x ‚àà T) : S = T
{L : first_order.language} {Œ± : Type u'} {Œ≤ : Type v'} [decidable_eq Œ±] {Œ≥ : Type u_1} (t : L.term (Œ± ‚äï Œ≥)) (f : ‚Ü•(t.var_finset_left) ‚Üí Œ≤) : L.term (Œ≤ ‚äï Œ≥)
{Œ± : Type u_1} [circular_preorder Œ±] {a b c : Œ±} : has_sbtw.sbtw a b c ‚Üî has_sbtw.sbtw c a b
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Prop
 : lean.parser name
{G H : Type u} [group G] [group H] [fintype H] (g : G ‚Üí* H) [fintype ‚Ü•(g.ker)] : fintype G
{n : ‚Ñï} {i‚ÇÅ i‚ÇÇ : fin (n + 3)} (h : i‚ÇÅ ‚â† i‚ÇÇ) : finset.univ.sum (Œª (i : affine.simplex.points_with_circumcenter_index (n + 2)), affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter i‚ÇÅ i‚ÇÇ i) = 0
{C : Type u} [category_theory.category C] (J‚ÇÅ : category_theory.grothendieck_topology C) : category_theory.topology_of_closure_operator J‚ÇÅ.closure_operator _ = J‚ÇÅ
{Œπ : Type u} {Œ± : Type v} (t : Œπ ‚Üí finset Œ±) {Œπ' Œπ'' : finset Œπ} (h : Œπ' ‚äÜ Œπ'') (f : ‚Ü•(hall_matchings_on t Œπ'')) : ‚Ü•(hall_matchings_on t Œπ')
(p : ‚Ñï) [fact (nat.prime p)] : field (zmod p)
(R : Type u_1) [comm_ring R] [is_domain R] : polynomial.cyclotomic' 1 R = polynomial.X - 1
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F : J ‚•§ C} [category_theory.limits.has_colimit F] (c : category_theory.limits.cocone F) (j : J) : category_theory.limits.colimit.Œπ F j ‚â´ category_theory.limits.colimit.desc F c = c.Œπ.app j
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (l : filter Œ±) (a : Œ±) : Prop
{Œ± : Type u_1} (tac : tactic Œ±) : tactic Œ±
 : linter
{Œπ : Type u‚ÇÅ} {k : Type u‚ÇÇ} {V : Type u‚ÇÉ} {P : Type u‚ÇÑ} [add_comm_group V] [add_torsor V P] [ring k] [module k V] (b : affine_basis Œπ k P) (i : Œπ) : basis {j // j ‚â† i} k V
{a : ‚Ñï} (a1 : 1 < a) : ‚Ñ§‚àö‚Üë(d a1) ‚Üí Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) : p.radius = filter.at_top.liminf (Œª (n : ‚Ñï), 1 / ‚Üë(‚à•p n‚à•‚Çä ^ (1 / ‚Üën)))
{R : Type u_1} [comm_ring R] (s : subring R) {Œπ : Type u_2} {t : finset Œπ} {f : Œπ ‚Üí R} (h : ‚àÄ (c : Œπ), c ‚àà t ‚Üí f c ‚àà s) : t.prod (Œª (i : Œπ), f i) ‚àà s
(R : Type u) (n : ‚Ñï) (A : Type u_1) [comm_semiring R] [semiring A] [algebra R A] [topological_space A] [has_continuous_mul A] : continuous_multilinear_map R (Œª (i : fin n), A) A
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {T : submonoid P} {k : P ‚âÉ* M} (H : submonoid.map k.to_monoid_hom T = S) : T.localization_map N
{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype (class_group R K)
 : box_integral.integration_params
{n : Type u_3} [fintype n] {K : Type u_1} [decidable_eq n] [field K] {M : matrix n n K} : (‚àÉ (v : n ‚Üí K) (H : v ‚â† 0), M.mul_vec v = 0) ‚Üî M.det = 0
(L : first_order.language) (M : Type w) [L.Structure M] : L.embedding M M
(Œ± : Type u) [group Œ±] : Prop
{Œπ : Type u} {X : Type v} [topological_space X] (i : Œπ) (s : set X) : bump_covering Œπ X s
{Œ± : Type u_2} [decidable_eq Œ±] [add_monoid Œ±] : add_monoid (finset Œ±)
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {s t : set Œ±} (hs : s.finite) (ht : t.finite) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s ‚à™ t), f i)) + finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s ‚à© t), f i)) = finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)) + finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà t), f i))
{m : Type u_2} {n : Type u_3} {Œ± : Type v} [decidable_eq n] (M : matrix m n Œ±) (j : n) (b : m ‚Üí Œ±) : matrix m n Œ±
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x y : Œ±} (h : emetric.diam s ‚â† ‚ä§) (hx : x ‚àà s) (hy : y ‚àà s) : has_dist.dist x y ‚â§ metric.diam s
{K : Type u_1} [field K] {Œì‚ÇÄ : Type u_2} [linear_ordered_comm_group_with_zero Œì‚ÇÄ] [hv : valued K Œì‚ÇÄ] : valuation (uniform_space.completion K) Œì‚ÇÄ
 : linter
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] : graded_monoid.ghas_mul (Œª (i : ‚Ñï), tensor_power R i M)
{R : Type u_1} [comm_ring R] [char_zero R] : function.injective (Œª (n : ‚Ñï), polynomial.cyclotomic n R)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_limit t) : category_theory.limits.binary_bicone X Y
(C : Type u) : category_theory.free_monoidal_category C ‚•§ (category_theory.discrete ‚àò category_theory.free_monoidal_category.normal_monoidal_object) C
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (a : Œ±) (b : Œ≤ a) : finmap Œ≤
{Œ± : Type u_2} {Œ≤ : Type u_3} [non_assoc_semiring Œ±] [preorder Œ±] [non_assoc_semiring Œ≤] [preorder Œ≤] (f : Œ± ‚Üí+*o Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : Œ± ‚Üí+*o Œ≤
{V : Type (u+1)} [category_theory.large_category V] {G : Mon} (M : Action V G) : M.hom M
 : sign_type ‚Üí sign_type ‚Üí Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_mul Œ±] [has_mul Œ≤] : Œ± ‚âÉ* Œ≤ ‚âÉ (Œ±·µê·µí·µñ ‚âÉ* Œ≤·µê·µí·µñ)
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] {X : C} [category_theory.simple X] : division_ring (category_theory.End X)
{R : Type u} [semiring R] {Œπ : Type v} [dec_Œπ : decidable_eq Œπ] {M : Type u_1} [add_comm_monoid M] [module R M] {A : Œπ ‚Üí submodule R M} (h : direct_sum.is_internal A) : supr A = ‚ä§
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : canonically_ordered_add_monoid (lie_subalgebra R L)
{Œ± : Type u} : complete_lattice (topological_space Œ±)
 : subsingleton (fin 0)
{Œπ : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type u_3} [add_comm_group M] [module R M] [fintype Œπ] (b : basis Œπ R M) (N O : submodule R M) (N_le_O : N ‚â§ O) : Œ£ (o n : ‚Ñï), basis.smith_normal_form (submodule.comap O.subtype N) (fin o) n
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [comm_monoid N] [decidable_eq Œ±] (f : Œ± ‚Üí‚ÇÄ M) (a : Œ±) (b : Œ± ‚Üí M ‚Üí N) : f.prod (Œª (x : Œ±) (v : M), ite (x = a) (b x v) 1) = ite (a ‚àà f.support) (b a (‚áëf a)) 1
 : (user_attribute unit)
 : subgroup.normal_closure {‚ü®equiv.swap 0 4 * equiv.swap 1 3, _‚ü©} = ‚ä§
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s : set Œ±} {b : Œ±} : s.nonempty ‚Üí (‚àÄ (a : Œ±), a ‚àà s ‚Üí b ‚â§ a) ‚Üí (‚àÄ (w : Œ±), b < w ‚Üí (‚àÉ (a : Œ±) (H : a ‚àà s), a < w)) ‚Üí has_Inf.Inf s = b
 : galois_insertion real.to_nnreal coe
(x : pgame) : x.relabelling x
(R : Type u_1) [comm_semiring R] (R' : Type u_2) [monoid R'] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] [distrib_mul_action R' M] [distrib_mul_action R' N] : Type
(J : Type v) (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
{G : Type u_1} [group G] (H : subgroup G) : subgroup G
 : expr ‚Üí tactic (option bool)
(Œ± : Type u) {Œ≤ : Type v} [add_group Œ±] [add_action Œ± Œ≤] (b : Œ≤) : add_subgroup Œ±
{V : Type u} {G : simple_graph V} {u v w : V} : G.walk u v ‚Üí G.walk v w ‚Üí G.walk u w
(p : interactive.parse interactive.types.texpr) : tactic unit
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [nontrivial Œ±] [unique_factorization_monoid Œ±] : normalization_monoid Œ±
(Œ≤ : Type u_2) [pseudo_metric_space Œ≤] [monoid Œ≤] [has_lipschitz_mul Œ≤] : nnreal
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] : ‚àÖ.up_shadow = ‚àÖ
{Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : is_compact s) (ht : is_closed t) : is_compact (s ‚à© t)
{E : Type u} [normed_group E] [normed_space ‚Ñù E] [complete_space E] {n : ‚Ñï} {F : Type u_1} [normed_group F] [normed_space ‚Ñù F] [partial_order F] [measure_theory.measure_space F] [borel_space F] (eL : F ‚âÉL[‚Ñù] fin (n + 1) ‚Üí ‚Ñù) (he_ord : ‚àÄ (x y : F), ‚áëeL x ‚â§ ‚áëeL y ‚Üî x ‚â§ y) (he_vol : measure_theory.measure_preserving ‚áëeL measure_theory.measure_space.volume measure_theory.measure_space.volume) (f : fin (n + 1) ‚Üí F ‚Üí E) (f' : fin (n + 1) ‚Üí F ‚Üí (F ‚ÜíL[‚Ñù] E)) (s : set F) (hs : s.countable) (a b : F) (hle : a ‚â§ b) (Hc : ‚àÄ (i : fin (n + 1)), continuous_on (f i) (set.Icc a b)) (Hd : ‚àÄ (x : F), x ‚àà interior (set.Icc a b)  s ‚Üí ‚àÄ (i : fin (n + 1)), has_fderiv_at (f i) (f' i x) x) (DF : F ‚Üí E) (hDF : ‚àÄ (x : F), DF x = finset.univ.sum (Œª (i : fin (n + 1)), ‚áë(f' i x) (‚áë(eL.symm) (pi.single i 1)))) (Hi : measure_theory.integrable_on DF (set.Icc a b) measure_theory.measure_space.volume) : ‚à´ (x : F) in set.Icc a b, DF x = finset.univ.sum (Œª (i : fin (n + 1)), (‚à´ (x : fin n ‚Üí ‚Ñù) in set.Icc (‚áëeL a ‚àò ‚áë(i.succ_above)) (‚áëeL b ‚àò ‚áë(i.succ_above)), f i (‚áë(eL.symm) (i.insert_nth (‚áëeL b i) x))) - ‚à´ (x : fin n ‚Üí ‚Ñù) in set.Icc (‚áëeL a ‚àò ‚áë(i.succ_above)) (‚áëeL b ‚àò ‚áë(i.succ_above)), f i (‚áë(eL.symm) (i.insert_nth (‚áëeL a i) x)))
(R : Type u_1) {k : Type u_2} {V1 : Type u_3} {V2 : Type u_5} [ring k] [add_comm_group V1] [add_comm_group V2] [module k V1] [module k V2] [semiring R] [module R V2] [smul_comm_class k R V2] : (V1 ‚Üí·µÉ[k] V2) ‚âÉ‚Çó[R] V2 √ó (V1 ‚Üí‚Çó[k] V2)
(B : Type u‚ÇÅ) [category_theory.bicategory B] : category_theory.oplax_functor B B
(Œ± : Type u_1) : Œ± ‚âÉ. Œ±
{Œ± : Type u_1} [topological_space Œ±] [baire_space Œ±] {s t : set Œ±} (hs : is_GŒ¥ s) (ht : is_GŒ¥ t) (hsc : dense s) (htc : dense t) : dense (s ‚à© t)
{X : Type u} {G : Type u_2} [group G] [mul_action G X] (t : X) (g : G) : ‚Üë(g‚Åª¬π ‚Ä¢ t) ‚ü∂ ‚Üët
(R : Type u_1) [semiring R] (C : Type u_2) [category_theory.category C] [category_theory.preadditive C] [category_theory.linear R C] [category_theory.monoidal_category C] [category_theory.monoidal_preadditive C] : Type
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] {S : Type u_1} [comm_ring S] (f : R ‚Üí+* S) : matrix.special_linear_group n R ‚Üí* matrix.special_linear_group n S
{a b : ‚Ñù} (m n : ‚Ñï) : ‚à´ (x : ‚Ñù) in a..b, real.sin x ^ (2 * m) * real.cos x ^ (2 * n) = ‚à´ (x : ‚Ñù) in a..b, ((1 - real.cos (2 * x)) / 2) ^ m * ((1 + real.cos (2 * x)) / 2) ^ n
{R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N' : Type u_5} [add_comm_group N'] [module R N'] {Œπ : Type u_6} [decidable_eq Œπ] [fintype Œπ] (a : alternating_map R M N' Œπ) : ‚áëmultilinear_map.alternatization ‚Üëa = (fintype.card Œπ).factorial ‚Ä¢ a
(p : ‚Ñï) : decidable (nat.prime p)
{Œ± : Type u_1} (S : set (set Œ±)) : has_finite_inter (has_finite_inter.finite_inter_closure S)
(Œ± : Type u_7) (Œ≤ : Type u_8) [lattice Œ±] [lattice Œ≤] [bounded_order Œ±] [bounded_order Œ≤] : Type (max u_7 u_8)
{p : ‚Ñï} : padic_val_int p 0 = 0
(Œ± : Sort u) [h‚ÇÅ : inhabited Œ±] [subsingleton Œ±] : unique Œ±
 : name ‚Üí name ‚Üí tactic unit
(Œ± : Type u) : Type u
 : expr ‚Üí tactic expr
(Œ± : Type u_1) (Œ≤ : Type u_2) [non_assoc_semiring Œ≤] : Œ≤ ‚Üí+* Œ± ‚Üí Œ≤
(p : ‚Ñï) [hp : fact (nat.prime p)] (n : ‚Ñï) : ‚Ñï ‚Üí mv_polynomial (fin 1 √ó ‚Ñï) ‚Ñ§
{C : Type u} [category_theory.category C] [category_theory.preadditive C] (R : Type w) [semiring R] [category_theory.linear R C] (X : C) {Y Z : C} (g : Y ‚ü∂ Z) : (X ‚ü∂ Y) ‚Üí‚Çó[R] X ‚ü∂ Z
{G : Type u_1} {A : Type u_2} {H : Type u_3} [group G] [mul_action G A] [monoid H] : G ‚Üí* mul_aut (A ‚Üí H)
{Œ± : Type u} (s : wseq Œ±) [s.productive] : seq Œ±
{G : Type u} [category_theory.groupoid G] [is_free_groupoid G] (T : wide_subquiver (quiver.symmetrify (is_free_groupoid.generators G))) [quiver.arborescence ‚Ü•T] : is_free_group (category_theory.End (root' T))
{M : Type u_1} [add_zero_class M] {c : add_con M} : ‚Üë0 = 0
 : FinPartialOrder ‚•§ FinPartialOrder
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D E : homological_complex V c} {e f : C ‚ü∂ D} (h : homotopy e f) (g : D ‚ü∂ E) : homotopy (e ‚â´ g) (f ‚â´ g)
{C : Type u‚ÇÅ} [category_theory.category C] {G : category_theory.comonad C} {P Q R : G.coalgebra} (f : P.hom Q) (g : Q.hom R) : P.hom R
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x y : Œ±} {t : set Œ±} (xs : x ‚àà s) (yt : y ‚àà t) : metric.diam (s ‚à™ t) ‚â§ metric.diam s + has_dist.dist x y + metric.diam t
{R : Type u_1} [linear_ordered_semiring R] (s : subsemiring R) : linear_ordered_semiring ‚Ü•s
(path : list expr_lens.dir) (n : interactive.parse lean.parser.small_nat) (q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) : tactic unit
(e ty : expr) : option expr
{Œ± : Type u} {Œ≤ : Type v} [semilattice_sup Œ±] {f : Œ± ‚Üí Œ≤} {r : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (H : ‚àÄ ‚¶Éi j : Œ±‚¶Ñ, i ‚â§ j ‚Üí r (f i) (f j)) : directed r f
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G : J ‚•§ C} (s : category_theory.limits.cone F) {t : category_theory.limits.cone G} (P : category_theory.limits.is_limit t) (Œ± : F ‚ü∂ G) : s.X ‚ü∂ t.X
(G : Type u) : Type u
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_coequalizer f g] : Y ‚ü∂ category_theory.limits.coequalizer f g
{R : Type u} {Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [topological_space M‚ÇÇ] (f : continuous_multilinear_map R M‚ÇÅ M‚ÇÇ) {Œ± : Œπ ‚Üí Type u_1} [fintype Œπ] (g : Œ† (i : Œπ), Œ± i ‚Üí M‚ÇÅ i) [Œ† (i : Œπ), fintype (Œ± i)] : ‚áëf (Œª (i : Œπ), finset.univ.sum (Œª (j : Œ± i), g i j)) = finset.univ.sum (Œª (r : Œ† (i : Œπ), Œ± i), ‚áëf (Œª (i : Œπ), g i (r i)))
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommSemiRing) : category_theory.creates_limit F (category_theory.forget‚ÇÇ CommSemiRing SemiRing)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] : has_coe_to_fun (cocompact_map Œ± Œ≤) (Œª (_x : cocompact_map Œ± Œ≤), Œ± ‚Üí Œ≤)
(n : ‚Ñï) : mv_polynomial ‚Ñï ‚Ñ§
{X Y : CommGroup} : ‚Ü•X ‚âÉ* ‚Ü•Y ‚âÖ X ‚âÖ Y
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (G : C ‚•§ D) [G.preserves_zero_morphisms] [category_theory.limits.has_cokernel f] [category_theory.limits.has_cokernel (G.map f)] : category_theory.limits.cokernel (G.map f) ‚ü∂ G.obj (category_theory.limits.cokernel f)
{F : Type u} [decidable_eq F] [field F] (s : finset F) (x : F) : polynomial F
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] {module_M : module R M} (p q : submodule R M) (h : p = q) : ‚Ü•p ‚âÉ‚Çó[R] ‚Ü•q
(k : Type u) [field k] (n : ‚Ñï) : algebraic_closure.step k n ‚Üí‚Çê[k] algebraic_closure k
{Œ± : Type u_1} {Œ≤ : Type u_2} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [topological_space Œ≤] [nonempty Œ≤] [has_one Œ±] {f : Œ≤ ‚Üí Œ±} (hf : continuous f) (h : has_compact_mul_support f) : ‚àÉ (x : Œ≤), ‚àÄ (y : Œ≤), f x ‚â§ f y
{Œ± : Type u_1} (r : ‚Ñï) (A : set (finset Œ±)) : Prop
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [comm_semiring Œ≤] : comm_semiring Œ±
{M : Type u_1} [add_comm_monoid M] (x : M) (N' : Type u_2) [add_comm_monoid N'] : Type (max u_1 u_2)
{a b c : ‚Ñ§} (habc : a ‚à£ b * c) (hab : a.gcd c = 1) : a ‚à£ b
{Œ± : Type u} [pseudo_metric_space Œ±] (a : Œ±) : has_nndist.nndist a a = 0
(n : name) : tactic bool
 : Type
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_5} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s s' : set Œ±} {t t' : set Œ≤} (hs : s ‚äÜ s') (ht : t ‚äÜ t') : set.image2 f s t ‚äÜ set.image2 f s' t'
{Œ≤ : Type u} {Œ± : Type v} [comm_monoid Œ≤] [decidable_eq Œ±] (s : finset Œ±) (f : Œ± ‚Üí Œ≤) {a : Œ±} (h : a ‚àà s) : (s.erase a).prod (Œª (x : Œ±), f x) * f a = s.prod (Œª (x : Œ±), f x)
{Œ± : Type u_1} {m : measurable_space Œ±} {M : Type u_3} [add_comm_monoid M] [topological_space M] [has_continuous_add M] : measure_theory.vector_measure Œ± M ‚Üí+ set Œ± ‚Üí M
(Œ± : Type u_1) [monoid Œ±] : setoid Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cone F} {D : Type u‚ÇÑ} [category_theory.category D] (G : C ‚•§ D) [category_theory.faithful G] (ht : category_theory.limits.is_limit (G.map_cone t)) (lift : Œ† (s : category_theory.limits.cone F), s.X ‚ü∂ t.X) (h : ‚àÄ (s : category_theory.limits.cone F), G.map (lift s) = ht.lift (G.map_cone s)) : category_theory.limits.is_limit t
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (N' : add_subsemigroup N) : add_hom ‚Ü•(add_subsemigroup.comap f N') ‚Ü•N'
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : r ‚Üír r
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (ùïú' : Type u_10) [normed_ring ùïú'] [normed_algebra ùïú ùïú'] [norm_one_class ùïú'] : ùïú' ‚Üí‚Çó·µ¢[ùïú] ùïú' ‚ÜíL[ùïú] ùïú'
{R : Type u} {M : Type v} {M‚ÇÇ : Type w} {M‚ÇÉ : Type y} {M‚ÇÑ : Type z} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [add_comm_group M‚ÇÑ] {module_M : module R M} {module_M‚ÇÇ : module R M‚ÇÇ} {module_M‚ÇÉ : module R M‚ÇÉ} {module_M‚ÇÑ : module R M‚ÇÑ} (e‚ÇÅ : M ‚âÉ‚Çó[R] M‚ÇÇ) (e‚ÇÇ : M‚ÇÉ ‚âÉ‚Çó[R] M‚ÇÑ) (f : M ‚Üí‚Çó[R] M‚ÇÑ) : (M √ó M‚ÇÉ) ‚âÉ‚Çó[R] M‚ÇÇ √ó M‚ÇÑ
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits_of_shape J C] : category_theory.limits.colim.op ‚ãô category_theory.coyoneda ‚ãô (category_theory.whiskering_right C (Type v) (Type (max v u‚ÇÅ))).obj category_theory.ulift_functor ‚âÖ category_theory.cocones J C
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cocone F} (desc : Œ† (s : category_theory.limits.cocone F), t ‚ü∂ s) (uniq' : ‚àÄ (s : category_theory.limits.cocone F) (m : t ‚ü∂ s), m = desc s) : category_theory.limits.is_colimit t
{E : Type u_2} [normed_group E] [normed_space ‚Ñù E] {s : set E} (hs‚ÇÅ : convex ‚Ñù s) (hs‚ÇÇ : is_closed s) : (‚ãÇ (l : E ‚ÜíL[‚Ñù] ‚Ñù), {x : E | ‚àÉ (y : E) (H : y ‚àà s), ‚áël x ‚â§ ‚áël y}) = s
{F : Type u ‚Üí Type w} {G : Type v ‚Üí Type u} {Œ± : Type v} (x : functor.comp F G Œ±) : F (G Œ±)
 : nat.arithmetic_function ‚Ñï
{M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] (f : M ‚Üí+ N) {x y : M} (h : x = y) : ‚áëf x = ‚áëf y
(p : ‚Ñï) [hp : fact (nat.prime p)] (k : ‚Ñï) : witt_vector p (zmod p) ‚Üí+* zmod (p ^ k)
{G : Type u_1} [group G] {S : Type u_4} [set_like S G] [hSG : subgroup_class S G] {H K : S} (h : H ‚â§ K) : ‚Ü•H ‚Üí* ‚Ü•K
(G : Type u_1) [add_comm_group G] [topological_space G] [topological_add_group G] : uniform_space G
(B : Type u) [category_theory.bicategory B] [category_theory.bicategory.strict B] : category_theory.category B
{D : set ‚Ñù} (hD : convex ‚Ñù D) (hD‚ÇÇ : is_open D) {f : ‚Ñù ‚Üí ‚Ñù} (hf' : differentiable_on ‚Ñù f D) (hf'' : differentiable_on ‚Ñù (deriv f) D) (hf''_nonneg : ‚àÄ (x : ‚Ñù), x ‚àà D ‚Üí 0 ‚â§ deriv^[2] f x) : convex_on ‚Ñù D f
(Œ± : Type u_1) [topological_space Œ±] [topological_space.separable_space Œ±] [partial_order Œ±] : ‚àÉ (s : set Œ±), s.countable ‚àß dense s ‚àß (‚àÄ (x : Œ±), is_bot x ‚Üí x ‚àà s) ‚àß ‚àÄ (x : Œ±), is_top x ‚Üí x ‚àà s
 : Type u
 : Type
(h : name) (t : expr) : tactic expr
{Œ± : Type u} [emetric_space Œ±] : emetric_space (topological_space.closeds Œ±)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) : Prop
{Œ≤ : Type w} {C : Type u} [category_theory.category C] (f : Œ≤ ‚Üí C) [category_theory.limits.has_coproduct f] : category_theory.limits.is_colimit (category_theory.limits.cofan.mk (‚àê f) (category_theory.limits.sigma.Œπ f))
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_cancel_comm_monoid E] [ordered_add_comm_monoid Œ≤] [module ùïú E] [has_scalar ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : strict_convex_on ùïú s f) (c : E) : strict_convex_on ùïú ((Œª (z : E), c + z) ‚Åª¬π' s) (f ‚àò Œª (z : E), z + c)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D·µí·µñ) [category_theory.limits.preserves_finite_limits F] : category_theory.limits.preserves_finite_colimits F.unop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} {H : D ‚•§ C} (adj : F ‚ä£ H) (iso : F ‚âÖ G) : G ‚ä£ H
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) (f : V ‚âÉ‚Çó·µ¢[‚Ñù] V) : _.oangle x y = hb.oangle (‚áë(f.symm) x) (‚áë(f.symm) y)
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] {Œπ : Type u_1} [decidable_eq Œπ] (c : complex_shape Œπ) (j : Œπ) : V ‚•§ homological_complex V c
{G : Type u_1} [group G] {G' : Type u_2} [group G'] (e : G ‚âÉ* G') (H : subgroup G) : ‚Ü•H ‚âÉ* ‚Ü•(subgroup.map e.to_monoid_hom H)
{J : Type u} [category_theory.small_category J] [category_theory.is_cofiltered J] {F : J ‚•§ Profinite} (C : category_theory.limits.cone F) (hC : category_theory.limits.is_limit C) {Œ± : Type u_1} (f : locally_constant ‚Ü•(C.X) Œ±) : ‚àÉ (j : J) (g : locally_constant ‚Ü•(F.obj j) Œ±), f = locally_constant.comap ‚áë(C.œÄ.app j) g
{M : Type u_1} [comm_monoid M] {N : Type u_2} [comm_monoid N] (x : M) (f : submonoid.localization_map.away_map x N) : localization.away x ‚âÉ* N
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) [has_lt Œ≤] (h : well_founded has_lt.lt) [nonempty Œ±] : Œ±
 : name ‚Üí string
(R : Type u_1) [comm_semiring R] (X : Type u_2) : has_one (free_algebra.pre R X)
{R : Type u_1} [comm_ring R] (u v w : fin 3 ‚Üí R) : matrix.dot_product u (‚áë(‚áëcross_product v) w) = matrix.det ![u, v, w]
{T : ‚Ñù} {g : ‚Ñù ‚Üí ‚Ñù} (hg : function.periodic g T) (h_int : ‚àÄ (t‚ÇÅ t‚ÇÇ : ‚Ñù), interval_integrable g measure_theory.measure_space.volume t‚ÇÅ t‚ÇÇ) (h‚ÇÄ : 0 < ‚à´ (x : ‚Ñù) in 0..T, g x) (hT : 0 < T) : filter.tendsto (Œª (t : ‚Ñù), ‚à´ (x : ‚Ñù) in 0..t, g x) filter.at_bot filter.at_bot
{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (H : submodule K V) (h : finite_dimensional.finrank K ‚Ü•H = 1) : ‚Ñô K V
(cl : tactic.closure) (p e‚ÇÄ p‚ÇÄ e‚ÇÅ p‚ÇÅ : expr) : tactic unit
(X Y : Type u) : category_theory.limits.is_limit (category_theory.limits.types.binary_product_cone X Y)
{Œ± : Type u_1} [U : uniform_space Œ±] (m : pseudo_emetric_space Œ±) (H : uniformity Œ± = uniformity Œ±) : pseudo_emetric_space Œ±
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] : Type (max u‚ÇÅ v‚ÇÅ)
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} [ring_hom_isometric œÉ‚ÇÅ‚ÇÇ] (x : E) : lipschitz_with ‚à•x‚à•‚Çä (Œª (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F), ‚áëf x)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : submodule K V) : module.rank K ‚Ü•s ‚â§ 1 ‚Üî ‚àÉ (v‚ÇÄ : V), s ‚â§ submodule.span K {v‚ÇÄ}
(a : ‚Ñ§) : ‚Ñ§ ‚ß∏ add_subgroup.zmultiples a ‚âÉ+ zmod a.nat_abs
{M : Type u_1} [has_mul M] (r : M ‚Üí M ‚Üí Prop) : M ‚Üí M ‚Üí Prop
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J·µí·µñ ‚•§ C·µí·µñ) {c : category_theory.limits.cocone F} (hc : category_theory.limits.is_colimit c) : category_theory.limits.is_limit (category_theory.limits.cone_unop_of_cocone c)
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} (l : list M) : ‚áëclifford_algebra.reverse (list.map ‚áë(clifford_algebra.Œπ Q) l).prod = (list.map ‚áë(clifford_algebra.Œπ Q) l).reverse.prod
{F : pfunctor} [inhabited F.M] [decidable_eq F.A] (i : F.Idx) (x : F.M) : F.M
{O : ordinal} : ‚Ü•(set.Iio O) ‚âÉ (nim O).left_moves
(Œ± : Type u_1) (Œ≤ : Type u_2) [preorder Œ±] [preorder Œ≤] : preorder (Œ± √ó‚Çó Œ≤)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 ‚àà s) : ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p2 -·µ• ‚ü®p1, hp1‚ü©) ‚àà s.direction
{M‚ÇÄ : Type u_1} [mul_zero_one_class M‚ÇÄ] (h : 0 = 1) (a : M‚ÇÄ) : a = 0
{ùïÇ : Type u_6} [is_R_or_C ùïÇ] {E' : Type u_7} [normed_group E'] [normed_space ùïÇ E'] {F' : Type u_8} [normed_group F'] [normed_space ùïÇ F'] {f : E' ‚Üí F'} {x : E'} (hf : cont_diff_at ùïÇ 1 f x) : ‚àÉ (K : nnreal) (t : set E') (H : t ‚àà nhds x), lipschitz_on_with K f t
 : Type
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.ess_surj F] [category_theory.full F] (X : C) : galois_insertion (category_theory.sieve.functor_pushforward F) (category_theory.sieve.functor_pullback F)
{H : Type u} [topological_space H] {Œ± : Type u_5} [topological_space Œ±] (e : local_homeomorph Œ± H) (h : e.to_local_equiv.source = set.univ) (G : structure_groupoid H) [closed_under_restriction G] : has_groupoid Œ± G
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] {a l' : Œ±} {s : set Œ±} (hl' : l' < a) : s ‚àà nhds_within a (set.Iic a) ‚Üî ‚àÉ (l : Œ±) (H : l ‚àà set.Iio a), set.Ioc l a ‚äÜ s
(R : Type u_2) [comm_semiring R] {A : Type u_3} [semiring A] [algebra R A] : hahn_series ‚Ñï A ‚âÉ‚Çê[R] power_series A
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] (e : topological_fiber_bundle.trivialization F proj) (s : set B) (hs : is_open s) : topological_fiber_bundle.trivialization F proj
 : filter.tendsto complex.exp (filter.comap complex.re filter.at_bot) (nhds 0)
{n : Type u} [decidable_eq n] [fintype n] {Œ± : Type v} [comm_ring Œ±] [star_ring Œ±] : ‚Ü•(matrix.unitary_group n Œ±) ‚Üí* linear_map.general_linear_group Œ± (n ‚Üí Œ±)
(n : ‚Ñï) (x : ‚Ñù) (hx : x ‚â† 0) : has_deriv_at (Œª (x : ‚Ñù), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-x‚Åª¬π) / x ^ (2 * n)) (polynomial.eval x (exp_neg_inv_glue.P_aux (n + 1)) * real.exp (-x‚Åª¬π) / x ^ (2 * (n + 1))) x
{Œ± : Type u} [pseudo_emetric_space Œ±] {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) (E : set Œ±) : closure E ‚äÜ metric.thickening Œ¥ E
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f g : X ‚ü∂ Y} [category_theory.limits.has_cokernel f] [category_theory.limits.has_cokernel g] (h : f = g) : category_theory.limits.cokernel f ‚âÖ category_theory.limits.cokernel g
(f : name ‚Üí option name) (ignore : name_map (list ‚Ñï)) : bool ‚Üí expr ‚Üí bool
(L : list ‚Ñï) : L.tail.sum = L.sum - L.head
{Œ± : Type u_1} {Œ≤ : Type u_2} (x : Œ±) : functor.add_const Œ± Œ≤
{Œ± : Type u_1} {Œ≥ : Type u_2} [measurable_space Œ±] [add_monoid Œ≥] {P : measure_theory.simple_func Œ± Œ≥ ‚Üí Prop} (h_ind : ‚àÄ (c : Œ≥) {s : set Œ±} (hs : measurable_set s), P (measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const Œ± c) (measure_theory.simple_func.const Œ± 0))) (h_add : ‚àÄ ‚¶Éf g : measure_theory.simple_func Œ± Œ≥‚¶Ñ, disjoint (function.support ‚áëf) (function.support ‚áëg) ‚Üí P f ‚Üí P g ‚Üí P (f + g)) (f : measure_theory.simple_func Œ± Œ≥) : P f
 : set algebraic_geometry.Scheme
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [add_comm_monoid Œπ] [decidable_eq Œπ] [comm_ring R] [comm_ring A] [algebra R A] {ùíú : Œπ ‚Üí submodule R A} [graded_algebra ùíú] {x : ideal A} [x.is_prime] (f : homogeneous_localization ùíú x) : Œπ
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : C
{M : Type u_1} [semigroup M] : semigroup (ultrafilter M)
{Œ± : Type u_1} [comm_monoid Œ±] {Œ≤ : Type u_2} [fintype Œ≤] (s : set Œ≤) [decidable_pred (Œª (_x : Œ≤), _x ‚àà s)] (f : Œ≤ ‚Üí Œ±) (g : ‚Ü•s ‚Üí Œ±) (w : ‚àÄ (x : Œ≤) (h : x ‚àà s), f x = g ‚ü®x, h‚ü©) (w' : ‚àÄ (x : Œ≤), x ‚àâ s ‚Üí f x = 1) : finset.univ.prod f = finset.univ.prod g
{M : Type u_1} [comm_monoid M] (x : M) : Type u_1
(R : Type u) [comm_semiring R] (A : Type v) [semiring A] [algebra R A] (n : Type w) : tensor_product R A (matrix n n R) ‚Üí‚Çó[R] matrix n n A
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [fintype Œπ] (b : basis Œπ R M) [fintype R] : fintype M
{Œ± : Type u_1} [preorder Œ±] [order_bot Œ±] [locally_finite_order Œ±] (b : Œ±) : multiset Œ±
(Œ± : Type u_6) (Œ≤ : Type u_7) [has_mul Œ±] [has_add Œ±] [has_le Œ±] [has_mul Œ≤] [has_add Œ≤] [has_le Œ≤] : Type (max u_6 u_7)
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_5} {Œ¥ : Type u_7} {g g' : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥} {s : set Œ±} {t : set Œ≤} {u : set Œ≥} (h : ‚àÄ (a : Œ±) (b : Œ≤) (c : Œ≥), g a b c = g' a b c) : set.image3 g s t u = set.image3 g' s t u
{C : Type u‚ÇÅ} [category_theory.category C] {J : category_theory.grothendieck_topology C} {A : Type u‚ÇÇ} [category_theory.category A] (X Y : category_theory.Sheaf J A) : Type (max u‚ÇÅ v‚ÇÇ)
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] (f : Œ± ‚Üí Œ≤) (Œºa : measure_theory.measure Œ± . "volume_tac") (Œºb : measure_theory.measure Œ≤ . "volume_tac") : Prop
(Œ± : Type u) : Type u
{R : Type u} [ring R] (self : subring R) : subsemiring R
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.abelian C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (h : category_theory.exact f g) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ (category_theory.limits.factor_thru_image g) _)
 : has_le pgame
{R : Type u} {M : Type v} {M‚ÇÇ : Type w} {M‚ÇÉ : Type y} [comm_semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] : M ‚Üí‚Çó[R] M‚ÇÇ ‚Üí‚Çó[R] fin 0 ‚Üí M‚ÇÉ
{Œ± : Type u} [topological_space Œ±] (K : compact_exhaustion Œ±) : compact_exhaustion Œ±
{S : Type u_4} (H : S) {G : Type u_1} [comm_group G] [set_like S G] [subgroup_class S G] : comm_group ‚Ü•H
{X : Top} {Œπ : Type u_1} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) (i : Œπ) : U i ‚ü∂ supr U
(C : Type u) [category_theory.category C] (X : Top) : Type (max v u)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (e : C ‚âå D) : C ‚•§ E ‚âå D ‚•§ E
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (k : ‚Ñï) : lie_ideal R L
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) {x : Œ≤} (h : x ‚àà e.to_local_equiv.target) : continuous_at ‚áë(e.symm) x
{Œ± : Type u_1} [decidable_eq Œ±] (a : Œ±) : {f // function.fixed_points ‚áëf ‚äÜ {a}} ‚âÉ ‚Ü•(derangements ‚Ü•{a}·∂ú) ‚äï ‚Ü•(derangements Œ±)
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] [preorder Œ±] [preorder Œ≤] {f g : Œ≤ ‚Üí Œ±} [covariant_class Œ± Œ± has_add.add has_le.le] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] (hf : monotone f) (hg : monotone g) : monotone (Œª (x : Œ≤), f x + g x)
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] {L‚ÇÅ : A ‚•§ T} {R‚ÇÅ : B ‚•§ T} {X Y : category_theory.comma L‚ÇÅ R‚ÇÅ} (l : X.left ‚âÖ Y.left) (r : X.right ‚âÖ Y.right) (h : L‚ÇÅ.map l.hom ‚â´ Y.hom = X.hom ‚â´ R‚ÇÅ.map r.hom) : X ‚âÖ Y
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) {r : ‚Ñù} (hr : r ‚â† 0) : 2 ‚Ä¢ hb.oangle x (r ‚Ä¢ y) = 2 ‚Ä¢ hb.oangle x y
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ≤ ‚Üí Œ≥} (hf : continuous f) : continuous (Œª (x : Œ± √ó Œ≤), f x.snd)
{Œ±' : Type u_1} {Œ≤' : Type u_2} (e : equiv.perm Œ±') {p : Œ≤' ‚Üí Prop} [decidable_pred p] (f : Œ±' ‚âÉ subtype p) : equiv.perm Œ≤'
(c : turing.to_partrec.code) (v : list ‚Ñï) : turing.partrec_to_TM2.cfg'
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] {s : set Œ±} {f : Œ± ‚Üí Œ≤} (hs : is_compact s) (hs' : is_separated s) (hf : continuous_on f s) : uniform_continuous_on f s
{Œ± : Type u} [decidable_eq Œ±] [canonically_ordered_comm_semiring Œ±] [nontrivial Œ±] : comm_semiring (with_top Œ±)
 : category_theory.faithful Compactum_to_CompHaus
{E : Type u_2} [normed_group E] [normed_space ‚Ñù E] [strict_convex_space ‚Ñù E] {x y z : E} {r : ‚Ñù} (hx : x ‚àà metric.closed_ball z r) (hy : y ‚àà metric.closed_ball z r) (hne : x ‚â† y) : open_segment ‚Ñù x y ‚äÜ metric.ball z r
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.creates_colimits_of_shape J F] : category_theory.creates_colimits_of_shape J G
{n m : simplex_category} {f : n ‚ü∂ m} : category_theory.mono f ‚Üî function.injective ‚áë(simplex_category.hom.to_order_hom f)
(L : first_order.language) : L ‚âÉ·¥∏ L
{Œ± : Type u} [group Œ±] : complete_semilattice_Inf (group_topology Œ±)
{X Y : Type u} [add_comm_monoid X] [add_comm_monoid Y] : X ‚âÉ+ Y ‚âÖ AddCommMon.of X ‚âÖ AddCommMon.of Y
(C : Type u) (A : Type u_1) [category_theory.category C] [add_monoid A] (h : category_theory.shift_mk_core C A) : category_theory.has_shift C A
{ùíú : Type u_1} [category_theory.category ùíú] {A B C : ùíú} (f : A ‚ü∂ B) (g : B ‚ü∂ C) [category_theory.limits.has_zero_morphisms ùíú] [category_theory.limits.has_kernels ùíú] [category_theory.limits.has_images ùíú] : Prop
{X : Type u_1} [topological_space X] [has_mul X] [has_continuous_mul X] {a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : X} (Œ≥‚ÇÅ : path a‚ÇÅ b‚ÇÅ) (Œ≥‚ÇÇ : path a‚ÇÇ b‚ÇÇ) : path (a‚ÇÅ * a‚ÇÇ) (b‚ÇÅ * b‚ÇÇ)
(h : expr) (ns : name_set) : tactic bool
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] [totally_disconnected_space Œ≤] {f : Œ± ‚Üí Œ≤} (h : continuous f) : connected_components Œ± ‚Üí Œ≤
{R : Type u} [semiring R] {S : Type v} [semiring S] {f : R ‚Üí+* S} {p : polynomial S} (n : ‚Ñï) (h : p ‚àà polynomial.lifts f) : polynomial.erase n p ‚àà polynomial.lifts f
{a b c : Prop} : a ‚àß b ‚à® c ‚Üî (a ‚à® c) ‚àß (b ‚à® c)
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_assoc_semiring Œ±} {rŒ≤ : non_assoc_semiring Œ≤} (f : Œ± ‚Üí+* Œ≤) : 0 = 1 ‚Üî ‚àÄ (x : Œ±), ‚áëf x = 0
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f‚ÇÇ : ùïú ‚Üí F} {s‚ÇÇ : set ùïú} (hs : unique_diff_on ùïú s‚ÇÇ) : cont_diff_on ùïú ‚ä§ f‚ÇÇ s‚ÇÇ ‚Üî differentiable_on ùïú f‚ÇÇ s‚ÇÇ ‚àß cont_diff_on ùïú ‚ä§ (deriv_within f‚ÇÇ s‚ÇÇ) s‚ÇÇ
{Œ± : Sort u} (p‚ÇÅ : Œ± ‚Üí Prop) [s‚ÇÅ : setoid Œ±] [s‚ÇÇ : setoid (subtype p‚ÇÅ)] (p‚ÇÇ : quotient s‚ÇÅ ‚Üí Prop) (hp‚ÇÇ : ‚àÄ (a : Œ±), p‚ÇÅ a ‚Üî p‚ÇÇ ‚ü¶a‚üß) (h : ‚àÄ (x y : subtype p‚ÇÅ), setoid.r x y ‚Üî ‚Üëx ‚âà ‚Üëy) : {x // p‚ÇÇ x} ‚âÉ quotient s‚ÇÇ
{Œ≤ : Type u} {Œ± : Type v} [add_comm_monoid Œ≤] [decidable_eq Œ±] (s : finset Œ±) {f : Œ± ‚Üí Œ≤} {a : Œ±} (h : f a = 0) : (s.erase a).sum (Œª (x : Œ±), f x) = s.sum (Œª (x : Œ±), f x)
{G : Type u_1} [add_right_cancel_semigroup G] (g : G) : G ‚Ü™ G
{n : ‚Ñï} {E : Type u_1} [normed_group E] {f g : (fin n ‚Üí ‚ÑÇ) ‚Üí E} {c : fin n ‚Üí ‚ÑÇ} {R : fin n ‚Üí ‚Ñù} (hf : torus_integrable f c R) (hg : torus_integrable g c R) : torus_integrable (f - g) c R
(A : Type u_4) [add_monoid A] [topological_space A] : continuous_add_monoid_hom A (A √ó A)
(l : list projection_data) (pref : string) (str : name) : tactic format
{R : Type u_1} {A : Type u_2} [add_zero_class R] [add_zero_class A] {P : unitization R A ‚Üí Prop} (h : ‚àÄ (r : R) (a : A), P (unitization.inl r + ‚Üëa)) (x : unitization R A) : P x
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (f : M ‚Üí N) : con N
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (X‚ÇÄ X‚ÇÅ X‚ÇÇ : V) (d‚ÇÄ : X‚ÇÄ ‚ü∂ X‚ÇÅ) (d‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (s : d‚ÇÄ ‚â´ d‚ÇÅ = 0) (succ : Œ† (t : Œ£' (X‚ÇÄ X‚ÇÅ X‚ÇÇ : V) (d‚ÇÄ : X‚ÇÄ ‚ü∂ X‚ÇÅ) (d‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ), d‚ÇÄ ‚â´ d‚ÇÅ = 0), Œ£' (X‚ÇÉ : V) (d‚ÇÇ : t.snd.snd.fst ‚ü∂ X‚ÇÉ), t.snd.snd.snd.snd.fst ‚â´ d‚ÇÇ = 0) (n : ‚Ñï) : cochain_complex.mk_struct V
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] {i j : Œπ} (w : free_product.neword M i j) (x : M i) (hnotone : x * w.head ‚â† 1) : free_product.neword M i j
{R : Type u_3} {S : Type u_4} {A : Type u_5} [comm_ring R] [comm_ring S] [comm_ring A] [algebra R S] [algebra S A] [algebra R A] [is_scalar_tower R S A] (hinj : function.injective ‚áë(algebra_map R S)) (A_alg : algebra.is_algebraic R A) : algebra.is_algebraic S A
 : tactic.interactive.case_tag ‚Üí list name
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] (f : E ‚Üí‚Çó[R] F) (p : submodule R E) : linear_pmap R E F
 : tactic.unsafe.type_context bool
{R : Type u} [comm_ring R] (S : submonoid R) (L : Type u) [comm_ring L] [algebra R L] [is_localization S L] (hS : S ‚â§ non_zero_divisors R) : cardinal.mk R = cardinal.mk L
(e l : expr) : bool
{R‚ÇÉ : Type u_7} [comm_ring R‚ÇÉ] {n : Type u_11} [fintype n] (J A : matrix n n R‚ÇÉ) : Prop
{Œ± : Type u} [uniform_space Œ±] {s : set Œ±} {c : set (set Œ±)} (hs : is_compact s) (hc‚ÇÅ : ‚àÄ (t : set Œ±), t ‚àà c ‚Üí is_open t) (hc‚ÇÇ : s ‚äÜ ‚ãÉ‚ÇÄc) : ‚àÉ (n : set (Œ± √ó Œ±)) (H : n ‚àà uniformity Œ±), ‚àÄ (x : Œ±), x ‚àà s ‚Üí (‚àÉ (t : set Œ±) (H : t ‚àà c), ‚àÄ (y : Œ±), (x, y) ‚àà n ‚Üí y ‚àà t)
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b c : Œ±} : b ‚â§ a‚Åª¬π * c ‚Üí a * b ‚â§ c
(C : Type u) [category_theory.category C] (D : Type u_1) [category_theory.category D] : (C ‚•§ D) ‚•§ category_theory.cosimplicial_object C ‚•§ category_theory.cosimplicial_object D
{M : Type u_1} [group M] (c : con M) : has_inv c.quotient
{n : ‚Ñï} {Œ± : typevec n} {F : typevec n ‚Üí Type v} [mvfunctor F] (r : (Œ±.prod Œ±).arrow (typevec.repeat n Prop)) : F Œ± ‚Üí F Œ± ‚Üí Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} (e‚ÇÅ : Œ± ‚Ü™ Œ≤) (e‚ÇÇ : Œ≥ ‚Ü™ Œ¥) : Œ± √ó Œ≥ ‚Ü™ Œ≤ √ó Œ¥
{Œ± : Type} (p : parser Œ±) : Prop
(R : Type u_1) [has_mul R] [has_add R] : ring_aut R ‚Üí* add_aut R
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_terminal C] [category_theory.limits.has_terminal D] (f : G.obj (‚ä§_ C) ‚ü∂ ‚ä§_ D) [i : category_theory.is_iso f] : category_theory.limits.preserves_limit (category_theory.functor.empty C) G
{R : Type u_1} [comm_ring R] {P : ideal (polynomial R)} (Pb : P ‚â† ‚ä•) (hP : ‚àÄ (x : R), ‚áëpolynomial.C x ‚àà P ‚Üí x = 0) : ‚àÉ (p : polynomial R), p ‚àà P ‚àß polynomial.map (ideal.quotient.mk (ideal.comap polynomial.C P)) p ‚â† 0
{S : Type v} (s : S) {R : Type u_1} [comm_ring R] [set_like S R] [subring_class S R] : comm_ring ‚Ü•s
{M : Type u_1} [monoid M] {x : M} : x ‚àà powers x
 : Type (u+1)
{R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] : {e // e * e = 0} ‚âÉ (dual_number R ‚Üí‚Çê[R] A)
 : expr ‚Üí option tactic.auto_cases.auto_cases_tac
{M : Type u_1} [add_comm_group M] [module ‚Ñù M] [finite_dimensional ‚Ñù M] (Q : quadratic_form ‚Ñù M) (hQ : (‚áëquadratic_form.associated Q).nondegenerate) : ‚àÉ (w : fin (finite_dimensional.finrank ‚Ñù M) ‚Üí ‚Ñù), (‚àÄ (i : fin (finite_dimensional.finrank ‚Ñù M)), w i = -1 ‚à® w i = 1) ‚àß Q.equivalent (quadratic_form.weighted_sum_squares ‚Ñù w)
{R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1
{Œ± : Type u_1} {Œ≤ : Type u_2} [denumerable Œ±] [denumerable Œ≤] : denumerable (Œ± ‚äï Œ≤)
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (hQ : category_theory.presheaf.is_sheaf J Q) : J.sheafify P ‚ü∂ Q
{C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (hG : category_theory.cover_lifting J K G) (‚Ñ± : category_theory.Sheaf J A) : category_theory.presheaf.is_sheaf K ((category_theory.Ran G.op).obj ‚Ñ±.val)
{R : Type u} {S : Type v} [ring R] [ring S] (s : subring R) (t : subring S) : ‚Ü•(s.prod t) ‚âÉ+* ‚Ü•s √ó ‚Ü•t
{Œ± : Sort u} (p : Œ± ‚Üí Prop) : Prop
 : (Œª (N : ‚Ñï), ‚Üë(‚áëroth_number_nat N)) =O[filter.at_top] Œª (N : ‚Ñï), ‚ÜëN
(S : (Type u)·µí·µñ ‚•§ Type u) (hs : category_theory.presieve.is_sheaf category_theory.types_grothendieck_topology S) (Œ± : Type u) : S.obj (opposite.op Œ±) ‚âÉ (Œ± ‚Üí S.obj (opposite.op punit))
(z : upper_half_plane) : ‚àÉ (g : matrix.special_linear_group (fin 2) ‚Ñ§), g ‚Ä¢ z ‚àà modular_group.fd
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) [category_theory.is_filtered J] (t : category_theory.limits.cocone F) : Mon.filtered_colimits.colimit F ‚ü∂ t.X
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {c : E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ‚Ñù} [interval_integral.FTC_filter b (nhds_within b s) (nhds_within b t)] (hmeas : strongly_measurable_at_filter f (nhds_within b t) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds_within b t ‚äì measure_theory.measure_space.volume.ae) (nhds c)) : has_deriv_within_at (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in a..u, f x) c s b
{R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G ‚Üí* R) (hf : f ‚â† 1) : finset.univ.sum (Œª (g : G), ‚áëf g) = 0
(h : interactive.parse (optional lean.parser.ident)) (q‚ÇÅ : interactive.parse (optional (lean.parser.tk ":" *> interactive.types.texpr))) (q‚ÇÇ : interactive.parse (optional (lean.parser.tk ":=" *> interactive.types.texpr))) : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_terminal C] [category_theory.limits.has_terminal D] : G.obj (‚ä§_ C) ‚ü∂ ‚ä§_ D
{Œ± : Type u_1} [measurable_space Œ±] [topological_space Œ±] [opens_measurable_space Œ±] {Œ≤ : Type u_2} [topological_space Œ≤] [topological_space.pseudo_metrizable_space Œ≤] [h : second_countable_topology_either Œ± Œ≤] {f : Œ± ‚Üí Œ≤} (hf : continuous f) : measure_theory.strongly_measurable f
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : category_theory.lax_monoidal_functor C (Type v)
{F : pfunctor} {X : Type u_1} (x‚ÇÄ : X) (f : X ‚Üí F.obj X) : F.M
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a b : Œ±} (ha : a ‚â§ 1) (hb : b < 1) : a * b < 1
{Œ± : Type u_1} (a : Œ±) (s : finset Œ±) (h : a ‚àâ s) : finset Œ±
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [unique_factorization_monoid Œ±] [normalization_monoid Œ±] [decidable_eq Œ±] {x : Œ±} {n : ‚Ñï} : factorization (x ^ n) = n ‚Ä¢ factorization x
{a b : ereal} : -a ‚â§ b ‚Üî -b ‚â§ a
{X : Top} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : category_theory.presieve (supr U)
{R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] {M‚ÇÅ : Type v} [add_comm_group M‚ÇÅ] [module R M‚ÇÅ] (f : M ‚âÉ‚Çó[R] M‚ÇÅ) (p : submodule R M) : module.rank R ‚Ü•(submodule.map ‚Üëf p) = module.rank R ‚Ü•p
{X Y : algebraic_geometry.LocallyRingedSpace} (f : X ‚ü∂ Y) (x : ‚Ü•X) : Y.stalk (‚áë(f.val.base) x) ‚ü∂ X.stalk x
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), add_comm_group (A i)] [add_zero_class Œπ] [direct_sum.gnon_unital_non_assoc_semiring A] : non_unital_non_assoc_ring (A 0)
{Œ± : Type u_2} [has_mul Œ±] [fintype Œ±] [decidable_eq Œ±] : decidable_pred is_square
{K : Type u_2} [division_ring K] : seq (generalized_continued_fraction.pair K) ‚Üí ‚Ñï ‚Üí K
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] [category_theory.is_filtered K] [category_theory.fin_category J] {C : Type u} [category_theory.category C] [category_theory.concrete_category C] [category_theory.limits.has_limits_of_shape J C] [category_theory.limits.has_colimits_of_shape K C] [category_theory.limits.reflects_limits_of_shape J (category_theory.forget C)] [category_theory.limits.preserves_colimits_of_shape K (category_theory.forget C)] [category_theory.limits.preserves_limits_of_shape J (category_theory.forget C)] (F : J ‚•§ K ‚•§ C) : category_theory.limits.colimit (category_theory.limits.limit F) ‚âÖ category_theory.limits.limit (category_theory.limits.colimit F.flip)
{Œ± : Type u} (s : wseq Œ±) [s.is_finite] : list Œ±
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] {P : ratfunc K ‚Üí Prop} (x : ratfunc K) (f : ‚àÄ (p q : polynomial K), q ‚â† 0 ‚Üí P (‚áë(algebra_map (polynomial K) (ratfunc K)) p / ‚áë(algebra_map (polynomial K) (ratfunc K)) q)) : P x
(ùïú : Type u_1) {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] (x y : E) : set E
{G : Type w} [topological_space G] [group G] [topological_group G] {K V : set G} (hK : is_compact K) (hV : (interior V).nonempty) : ‚àÉ (t : finset G), K ‚äÜ ‚ãÉ (g : G) (H : g ‚àà t), (Œª (h : G), g * h) ‚Åª¬π' V
(ùïú : Type u_1) (E : Type u_2) [ordered_semiring ùïú] [add_comm_monoid E] [module ùïú E] [topological_space E] : Prop
{M : Type u_1} [has_one M] [has_mul M] [has_inv M] : ‚Ñ§ ‚Üí M ‚Üí M
{J : Type v} [category_theory.small_category J] {F : J ‚•§ category_theory.discrete punit} {c : category_theory.limits.cocone F} : category_theory.limits.is_colimit c
{œÑ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ≤] (f : filter œÑ) (œï : œÑ ‚Üí Œ± ‚Üí Œ≤) (s : set Œ±) [f.ne_bot] {c : set Œ≤} (hc‚ÇÅ : is_compact c) (hc‚ÇÇ : ‚àÉ (v : set œÑ) (H : v ‚àà f), closure (set.image2 œï v s) ‚äÜ c) (hs : s.nonempty) : (omega_limit f œï s).nonempty
{Œ± : Type u} {Œπ : Type x} [pseudo_emetric_space Œ±] (f : Œπ ‚Üí function.End Œ±) (K : Œπ ‚Üí nnreal) (h : ‚àÄ (i : Œπ), lipschitz_with (K i) (f i)) (l : list Œπ) : lipschitz_with (list.map K l).prod (list.map f l).prod
{Œ± : Type u_1} {n : ‚Ñï} : sym Œ± n ‚âÉ sym.sym' Œ± n
{Œ± : Type u_2} [topological_space Œ±] [add_monoid Œ±] [has_continuous_add Œ±] : has_continuous_add (add_units Œ±)
(A : Type u_9) (B : Type u_10) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : Type (max u_10 u_9)
{C : Type u} [category_theory.category C] (X Y : C) : Type (max u v)
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] {L' : Type u_3} [field L'] [algebra K L'] (e : L ‚âÉ‚Çê[K] L') (E : intermediate_field K L) : ‚Ü•E ‚âÉ‚Çê[K] ‚Ü•(E.map e.to_alg_hom)
{Œ± : Type u} (x : Œ±) : dlist Œ±
{Œ± : Type} (x : slim_check.gen Œ±) (i : ‚Ñï) : io Œ±
{M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + ‚Üëu) ‚Üî is_add_unit a
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] {Z : D} (F : C ‚•§ D) (M : Œ† (x : C), F.obj x ‚ü∂ Z) (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), F.map f ‚â´ M y = M x) : category_theory.with_terminal C ‚•§ D
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] (S : convex_cone ùïú E) : Prop
{Œ± : Type u_1} [complete_lattice Œ±] {k : Œ±} (hk : complete_lattice.is_compact_element k) {s : set Œ±} (hemp : s.nonempty) (hdir : directed_on has_le.le s) (hbelow : ‚àÄ (x : Œ±), x ‚àà s ‚Üí x < k) : has_Sup.Sup s < k
{C : Type v} [category_theory.category C] [category_theory.concrete_category C] {X Y : C} (f g : X ‚ü∂ Y) (w : ‚àÄ (x : ‚Ü•X), ‚áëf x = ‚áëg x) : f = g
{Œ± : Type u} [emetric_space Œ±] [topological_space.second_countable_topology Œ±] : topological_space.second_countable_topology (topological_space.nonempty_compacts Œ±)
{Œ± : Type u_1} {M : Type u_4} [add_comm_monoid M] (f : Œ± ‚Üí M) {s t : finset Œ±} (h : s ‚äÜ t) : s.sum (Œª (i : Œ±), f i) = t.sum (Œª (i : Œ±), ‚Üës.indicator f i)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Top) : category_theory.limits.cone F
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) (i : Œπ) : ‚áë((s.erase i).weighted_vsub_of_point p (p i)) w = ‚áë(s.weighted_vsub_of_point p (p i)) w
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] : category_theory.triangulated.rotate C ‚ãô category_theory.triangulated.inv_rotate C ‚ü∂ ùü≠ (category_theory.triangulated.triangle C)
{Œ± : Type u_1} [preorder Œ±] (a : Œ±) : upper_set Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} {m : measurable_space Œ±} [topological_space Œ≤] [preorder Œπ] (f : measure_theory.filtration Œπ m) (u : Œπ ‚Üí Œ± ‚Üí Œ≤) : Prop
(mv : expr) (pp_name : name) (binfo : binder_info) : tactic (option expr)
{Œ± : Type u_1} (a : part Œ±) [decidable a.dom] (d : Œ±) : Œ±
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [linear_ordered_add_comm_monoid_with_top Œì‚ÇÄ] [ring R] (v : add_valuation R Œì‚ÇÄ) : valuation R (multiplicative Œì‚ÇÄ·µí·µà)
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X : C) : C ‚•§ C
 : clifford_algebra clifford_algebra_complex.Q ‚âÉ‚Çê[‚Ñù] ‚ÑÇ
{V : Type u_1} [inner_product_space ‚Ñù V] (x y : V) : inner_product_geometry.angle x y = inner_product_geometry.angle y x
 : Type
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : setoid Œ±} {f : Œ± ‚Üí Œ≤} (h : setoid.ker f ‚â§ r) (hf : function.surjective f) : r.map f = r.map_of_surjective f h hf
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_zero_morphisms C
(C : Type u) [category_theory.category C] : Type (max u u_1)
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {c : category_theory.limits.fork f g} (i : category_theory.limits.is_limit c) {Z : C} (h : Y ‚ü∂ Z) [hm : category_theory.mono h] : category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ c.Œπ _)
 : ‚Ñï ‚Üí num
(R : Type u_1) [comm_ring R] : Prop
(G : Type u) : Type u
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [preorder Œ±] [preorder Œ≤] [preorder Œ≥] [mul_zero_one_class Œ±] [mul_zero_one_class Œ≤] [mul_zero_one_class Œ≥] (f : Œ≤ ‚Üí*‚ÇÄo Œ≥) (g : Œ± ‚Üí*‚ÇÄo Œ≤) : Œ± ‚Üí*‚ÇÄo Œ≥
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : r ‚Üír s) : function.swap r ‚Üír function.swap s
{Œ± : Sort u} {Œ≤ : Sort v} (e : Œ± ‚âÉ Œ≤) [decidable_eq Œ≤] : decidable_eq Œ±
(a : cardinal) : a < 2 ^ a
{X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {Œ≤ : Type u_1} {Œπ : Œ≤ ‚Üí Type u_3} [Œ† (n : Œ≤), encodable (Œπ n)] (s : set X) {l : filter Œ≤} (r : Œ≤ ‚Üí ennreal) (hr : filter.tendsto r l (nhds 0)) (t : Œ† (n : Œ≤), Œπ n ‚Üí set X) (ht : ‚àÄ·∂† (n : Œ≤) in l, ‚àÄ (i : Œπ n), emetric.diam (t n i) ‚â§ r n) (hst : ‚àÄ·∂† (n : Œ≤) in l, s ‚äÜ ‚ãÉ (i : Œπ n), t n i) (m : ennreal ‚Üí ennreal) : ‚áë(measure_theory.measure.mk_metric m) s ‚â§ l.liminf (Œª (n : Œ≤), ‚àë' (i : Œπ n), m (emetric.diam (t n i)))
{ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_5} [normed_field ùïú] [add_comm_group E] [module ùïú E] (p : seminorm_family ùïú E Œπ) [nonempty Œπ] : add_group_filter_basis E
{g : matrix.special_linear_group (fin 2) ‚Ñ§} {z : upper_half_plane} (hz : z ‚àà modular_group.fdo) (hg : g ‚Ä¢ z ‚àà modular_group.fdo) : ‚Üëg 1 0 = 0
{Œπ : Type u_1} {Z : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), ordered_add_comm_monoid (Z i)] : ordered_add_comm_monoid (Œ† (i : Œπ), Z i)
{Œ± : Type u_1} (s t : multiset Œ±) : Prop
{R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Œπ : Type u_1} (v : Œπ ‚Üí M) (i : linear_independent R v) (w : set M) [fintype ‚Ü•w] (s : set.range v ‚â§ ‚Üë(submodule.span R w)) : fintype Œπ
{Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), add_monoid (Gs i)] {x : Œ† (i : Œ∑), Gs i} (h : is_of_fin_add_order x) (i : Œ∑) : is_of_fin_add_order (x i)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {f : X ‚ü∂ Y} [category_theory.split_epi f] {c : category_theory.limits.kernel_fork f} (i : category_theory.limits.is_limit c) : category_theory.limits.binary_bicone c.X Y
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} {V‚ÇÇ : Type u_5} {P‚ÇÇ : Type u_6} [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] {p : Œπ ‚Üí P} (hai : affine_independent k p) (f : P ‚Üí·µÉ[k] P‚ÇÇ) (hf : function.injective ‚áëf) : affine_independent k (‚áëf ‚àò p)
(G : Type w) [topological_space G] : Type w
{R : Type u_1} [comm_ring R] (v w : fin 3 ‚Üí R) : matrix.dot_product w (‚áë(‚áëcross_product v) w) = 0
(q : interactive.parse interactive.types.texpr) : tactic unit
{M : Type u_1} [has_add M] {Œ≤ : Sort u_2} (c : add_con M) (f : M ‚Üí Œ≤) (h : ‚àÄ (a b : M), ‚áëc a b ‚Üí f a = f b) (x : M) : add_con.lift_on ‚Üëx f h = f x
(R : Type u) : Type u
{Œ± : Type u} {Œ≤ : Type v} [has_mul Œ≤] : (Œ± ‚Üí Œ≤) ‚âÉ (free_magma Œ± ‚Üí‚Çô* Œ≤)
(k : Type u) [field k] (n : ‚Ñï) : algebraic_closure.step k n ‚Üí+* algebraic_closure k
 : strict_convex_on ‚Ñù set.univ real.exp
{R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} {P : Type w‚ÇÇ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [add_comm_group N] [add_comm_group P] [module R M] [module R N] [module R P] [lie_ring_module L M] [lie_ring_module L N] [lie_ring_module L P] [lie_module R L M] [lie_module R L N] [lie_module R L P] (f : N ‚Üí‚Çó‚ÅÖR,L‚ÅÜ P) (g : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ P
{R : Type u_1} [semiring R] : laurent_polynomial R ‚Üí+ polynomial R
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {j j' : C} (f f' : j ‚ü∂ j') : C
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤] (X : set (C(Œ±, Œ≤) √ó C(Œ±, Œ≤))) : X ‚àà continuous_map.compact_convergence_uniformity ‚Üî ‚àÉ (K : set Œ±) (V : set (Œ≤ √ó Œ≤)) (hK : is_compact K) (hV : V ‚àà uniformity Œ≤), {fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ (x : Œ±), x ‚àà K ‚Üí (‚áë(fg.fst) x, ‚áë(fg.snd) x) ‚àà V} ‚äÜ X
(t : omega.term) : omega.eqelim ‚Ñ§
(C : Type u) [category_theory.category C] : Prop
{R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type u_3} [add_comm_group M] [module R M] {Œπ : Type u_1} [fintype Œπ] {b : Œπ ‚Üí M} (hb : linear_independent R b) {N : submodule R M} (le : N ‚â§ submodule.span R (set.range b)) : Œ£ (n : ‚Ñï), basis (fin n) R ‚Ü•N
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.limits.has_pullbacks C] : C·µí·µñ ‚•§ Type (max u‚ÇÅ v‚ÇÅ)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K‚ÇÅ K‚ÇÇ : submodule ùïú E} (h : K‚ÇÅ ‚â§ K‚ÇÇ) : K‚ÇÅ·óÆ·óÆ ‚â§ K‚ÇÇ·óÆ·óÆ
{m : Type u_2} {n : Type u_3} {Œ± : Type v} {Œ≤ : Type w} [has_add Œ±] [has_add Œ≤] (f : Œ± ‚âÉ+ Œ≤) : matrix m n Œ± ‚âÉ+ matrix m n Œ≤
 : pos_num ‚Üí pos_num ‚Üí pos_num
{V : Type u_1} [quiver V] : wide_subquiver V ‚âÉ set (quiver.total V)
{Œπ : Type u_1} {Œ± : Type u_3} [preorder Œπ] [linear_order Œ±] {u : Œπ ‚Üí Œ±} (h : monotone u) (H : ¬¨bdd_above (set.range u)) : filter.tendsto u filter.at_top filter.at_top
(p : ‚Ñï) (G : Type u_1) [group G] [fact (nat.prime p)] [fintype (sylow p G)] : fintype.card (sylow p G) ‚â° 1 [MOD p]
(M : Type u) [monoid M] : M ‚âÉ (multiplicative ‚Ñï ‚Üí* M)
{M : Type u_1} [has_mul M] (c : con M) {w x y z : M} : ‚áëc w x ‚Üí ‚áëc y z ‚Üí ‚áëc (w * y) (x * z)
 : (user_attribute simp_lemmas)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s‚ÇÅ s‚ÇÇ : affine_subspace k P} {p : P} (h‚ÇÅ : p ‚àà s‚ÇÅ) (h‚ÇÇ : p ‚àà s‚ÇÇ) : (s‚ÇÅ ‚äì s‚ÇÇ).direction = s‚ÇÅ.direction ‚äì s‚ÇÇ.direction
{m : Type u ‚Üí Type u} [monad m] {Œ± Œ≤ : Type u} (f : Œ± ‚Üí option Œ≤) : tactic.mllist m Œ± ‚Üí tactic.mllist m Œ≤
(C : Type u) [category_theory.category C] : (category_theory.simplicial_object.augmented C)·µí·µñ ‚âå category_theory.cosimplicial_object.augmented C·µí·µñ
{Œ± : Type u} [add_comm_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b c : Œ±} : a < b + c ‚Üí a - b < c
{Œ± : Type u_1} {Œ≤ : Type u_2} [decidable_eq Œ±] [decidable_eq Œ≤] (f : Œ± ‚Üí Œ≤) (s : multiset Œ±) (hf : set.inj_on f {x : Œ± | x ‚àà s}) (x : Œ±) (H : x ‚àà s) : multiset.count (f x) (multiset.map f s) = multiset.count x s
 : ‚Ñï+ ‚âÉ ‚Ü•{f : ‚Ñï ‚Üí‚ÇÄ ‚Ñï | ‚àÄ (p : ‚Ñï), p ‚àà f.support ‚Üí nat.prime p}
(R : Type u) : Type u
(X : Type u_1) [topological_space X] [h : topological_space.pseudo_metrizable_space X] : pseudo_metric_space X
(fn : expr) : tactic ‚Ñï
{Œ± : Type u_3} {Œ≤ : Type u_4} [has_sup Œ±] [has_sup Œ≤] : has_coe_to_fun (sup_hom Œ± Œ≤) (Œª (_x : sup_hom Œ± Œ≤), Œ± ‚Üí Œ≤)
 : ‚áëlinear_equiv.det complex.conj_lie.to_linear_equiv = -1
{G : Type u_1} [group G] (H : subgroup G) [h : H.is_commutative] : comm_group ‚Ü•H
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.limits.has_pullback f g] : category_theory.limits.has_pullback g f
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x : V} (hx : x ‚â† 0) (Œ∏ : real.angle) : ‚áë(o.rotation Œ∏) x = x ‚Üî Œ∏ = 0
{G : Type u‚ÇÇ} (k : Type u_1) {H : Type u_2} {F : Type u_3} [semiring k] [monoid G] [monoid H] [monoid_hom_class F G H] (f : F) : monoid_algebra k G ‚Üí+* monoid_algebra k H
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚âÉ Œ≤) (hf : inducing ‚áëf) : Œ± ‚âÉ‚Çú Œ≤
 : tactic (list expr)
{p n : ‚Ñï} : padic_val_int p ‚Üën = padic_val_nat p n
{Œ± Œ≤ : BoolAlg} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
 : environment ‚Üí name ‚Üí exceptional declaration
(Œ± : Type u_1) : Type u_1
{H : Type u_1} [topological_space H] {H' : Type u_3} [topological_space H'] (G : structure_groupoid H) (G' : structure_groupoid H') (P : (H ‚Üí H') ‚Üí set H ‚Üí H ‚Üí Prop) : Prop
(R : Type u) [semiring R] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (G : D ‚•§ C) (h : G.op ‚ä£ F.op) : F ‚ä£ G
{C : Type u‚ÇÅ} [category_theory.category C] : C ‚âå C
{Œ± : Type u} (H : set.univ.finite) : fintype Œ±
{R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] {M' : Type v'} [add_comm_group M'] [module R M'] (f : M ‚âÉ‚Çó[R] M') : (module.rank R M).lift = (module.rank R M').lift
{Œ± Œ≤ : Type u} (f : Œ± ‚ü∂ Œ≤) : category_theory.limits.mono_factorisation f
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] {j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ : C} (f‚ÇÅ : j‚ÇÅ ‚ü∂ k‚ÇÅ) (g‚ÇÅ : j‚ÇÅ ‚ü∂ k‚ÇÇ) (f‚ÇÇ : j‚ÇÇ ‚ü∂ k‚ÇÅ) (g‚ÇÇ : j‚ÇÇ ‚ü∂ k‚ÇÇ) : ‚àÉ (s : C) (Œ± : k‚ÇÅ ‚ü∂ s) (Œ≤ : k‚ÇÇ ‚ü∂ s), f‚ÇÅ ‚â´ Œ± = g‚ÇÅ ‚â´ Œ≤ ‚àß f‚ÇÇ ‚â´ Œ± = g‚ÇÇ ‚â´ Œ≤
{Œ± : Type u_1} [linear_ordered_field Œ±] {a b : Œ±} (ha : 0 < a) (hb : 0 < b) : a‚Åª¬π ‚â§ b‚Åª¬π ‚Üî b ‚â§ a
{G : Type w} [topological_space G] [add_group G] [topological_add_group G] [t2_space G] (s : add_subgroup G) (hs : ‚àÄ (x y : ‚Ü•s), x + y = y + x) : add_comm_group ‚Ü•(s.topological_closure)
{C : category_theory.Groupoid} : ùü≠ ‚Ü•C = ùüô C
{M : Type u_1} {Œ± : Type u_6} [add_monoid M] (f : M ‚Üí+ additive (function.End Œ±)) : add_action M Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (h : Œ± ‚âÉ‚Çú Œ≤) : Œ≤ ‚âÉ‚Çú Œ±
(C : Type (u+1)) : Type (u+1)
 : tactic.ring_exp.ex tactic.ring_exp.ex_type.sum ‚Üí tactic.ring_exp.ex tactic.ring_exp.ex_type.sum ‚Üí tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum)
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : ‚Ü•(non_zero_divisors R)) : 0 < v.int_valuation_def ‚Üëx
{M : Type u_1} [mul_one_class M] (S : submonoid M) : S = ‚ä• ‚à® ‚àÉ (x : M) (H : x ‚àà S), x ‚â† 1
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {s : set Œ±} (h : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)) ‚â† 1) : ‚àÉ (x : Œ±) (H : x ‚àà s), f x ‚â† 1
 : (user_attribute simp_lemmas)
{Œπ : Type u_1} {Œ± : Type u_2} {s : Œπ ‚Üí set Œ±} (hs : indexed_partition s) (x : hs.quotient) : hs.proj (‚áë(hs.out) x) = x
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [locally_compact_space G] : measure_theory.measure G
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {ra : Œ± ‚Üí Œ± ‚Üí Prop} {rb : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : Œ± ‚Üí Œ≤) (h : (ra ‚áí rb) f f) : quot ra ‚Üí quot rb
(R : Type u) (L : Type v) (L' : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] : Type (max v w)
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] (F : C ‚•§ D) [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete pempty) F] [category_theory.limits.has_finite_products C] (n : ‚Ñï) : category_theory.limits.preserves_limits_of_shape (category_theory.discrete (ulift (fin n))) F
(r : ‚Ñï+) : multiset ‚Ñï+
{Œ± : Type u} [comm_group Œ±] : is_group_hom has_inv.inv
{et et' : tactic.ring_exp.ex_type} (ps : tactic.ring_exp.ex et) (qs : tactic.ring_exp.ex et') : tactic.ring_exp.ring_exp_m expr
{Œ± : Type u_2} {Œ≤ : Type u_3} [monoid Œ±] [monoid Œ≤] [topological_space Œ±] [topological_space Œ≤] (f : continuous_monoid_hom Œ± Œ≤) : C(Œ±, Œ≤)
(k : turing.to_partrec.cont) : list turing.partrec_to_TM2.Œì'
 : num ‚Üí num
{Œ± : Type u} [uniform_space Œ±] {s : set Œ±} (h : totally_bounded s) : totally_bounded (closure s)
{M : Type u_1} {N : Type u_2} [monoid M] [monoid N] [fintype M] [decidable_eq N] (f : M ‚Üí* N) : fintype ‚Ü•(f.mrange)
 : filter.tendsto (Œª (x : ‚Ñù), x ^ ((-1) / x)) filter.at_top (nhds 1)
 : CommRing·µí·µñ ‚•§ algebraic_geometry.LocallyRingedSpace
{ùïú : Type u_3} [field ùïú] {r : ‚Ñï} (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) : list (matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú)
(_x : interactive.parse (lean.parser.tk "copy_doc_string")) : lean.parser unit
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ w)
{R : Type u_2} {M‚ÇÅ : Type u_5} {M‚ÇÇ : Type u_6} {M‚ÇÉ : Type u_7} [ring R] [add_comm_group M‚ÇÅ] [add_comm_group M‚ÇÇ] [add_comm_group M‚ÇÉ] [module R M‚ÇÅ] [module R M‚ÇÇ] [module R M‚ÇÉ] {Q‚ÇÅ : quadratic_form R M‚ÇÅ} {Q‚ÇÇ : quadratic_form R M‚ÇÇ} {Q‚ÇÉ : quadratic_form R M‚ÇÉ} (f : Q‚ÇÅ.isometry Q‚ÇÇ) (g : Q‚ÇÇ.isometry Q‚ÇÉ) : Q‚ÇÅ.isometry Q‚ÇÉ
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] [nonempty X] (f : bounded_continuous_function X ‚Ñù) {e : X ‚Üí Y} (he : closed_embedding e) : ‚àÉ (g : bounded_continuous_function Y ‚Ñù), (‚àÄ (y : Y), ‚àÉ (x‚ÇÅ x‚ÇÇ : X), ‚áëg y ‚àà set.Icc (‚áëf x‚ÇÅ) (‚áëf x‚ÇÇ)) ‚àß ‚áëg ‚àò e = ‚áëf
(s : ‚Ñù) : (Œª (x : ‚Ñù), real.exp (-x) * x ^ s) =o[filter.at_top] Œª (x : ‚Ñù), real.exp (-(1 / 2) * x)
{P : Type u} (L : Type u) [has_mem P L] (p : P) : ‚Ñï
 : tactic.list_Pi (tactic.rcases_patt √ó expr) ‚Üí tactic (list tactic.uncleared_goal)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [linear_ordered_field ùïú] [add_comm_monoid E] [add_comm_monoid F] [module ùïú E] [module ùïú F] (f : E ‚Üí‚Çó[ùïú] F) (S : convex_cone ùïú E) : convex_cone ùïú F
{Œ± : Type u} [topological_space Œ±] {f : filter Œ±} : is_closed {x : Œ± | cluster_pt x f}
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (C : homological_complex V c) [category_theory.limits.has_zero_object V] [category_theory.limits.has_images V] [category_theory.limits.has_equalizers V] {i j : Œπ} (r : c.rel i j) : ‚Üë(C.boundaries j) ‚âÖ category_theory.limits.image (C.d i j)
{C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X) {Y : topological_space.opens ‚Ü•X} (R : category_theory.presieve Y) (hR : category_theory.sieve.generate R ‚àà ‚áë(opens.grothendieck_topology ‚Ü•X) Y) : category_theory.limits.is_limit (category_theory.functor.map_cone F (Top.presheaf.sheaf_condition.opens_le_cover_cocone (Top.presheaf.covering_of_presieve Y R)).op) ‚âÉ category_theory.limits.is_limit (category_theory.functor.map_cone F (category_theory.sieve.generate R).arrows.cocone.op)
{p : ‚Ñï} [fact (nat.prime p)] : has_add ‚Ñ§_[p]
(A : Type u) [comm_ring A] (K : Type v) [field K] [algebra A K] [is_domain A] [valuation_ring A] [is_fraction_ring A K] : A ‚âÉ+* ‚Ü•((valuation_ring.valuation A K).integer)
{Œ± : Type u} [preorder Œ±] {a b : Œ±} (h : a ‚â§ b) : ¬¨b < a
{f : ‚Ñï ‚Üí ‚Ñù} (hfa : monotone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) : ‚àÉ (l : ‚Ñù), filter.tendsto (Œª (n : ‚Ñï), (finset.range (n + 1)).sum (Œª (i : ‚Ñï), (-1) ^ i * f i)) filter.at_top (nhds l)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J ‚Üí C) [category_theory.limits.has_biproduct F] : category_theory.limits.bicone F
{Œ≤ : Type u} {Œ± : Type v} {s : finset Œ±} {a : Œ±} {f : Œ± ‚Üí Œ≤} [add_comm_monoid Œ≤] [decidable_eq Œ±] (h : f a = 0) : (has_insert.insert a s).sum (Œª (x : Œ±), f x) = s.sum (Œª (x : Œ±), f x)
 : name ‚Üí expr ‚Üí tactic (list expr)
(a a1 : expr) (n1 : ‚Ñï) : tactic.instance_cache ‚Üí expr ‚Üí expr ‚Üí tactic (tactic.instance_cache √ó expr √ó expr)
{G : Type u_1} [group G] : add_subgroup (additive G) ‚âÉo subgroup G
{Œ± : Type u} [preorder Œ±] {a : Œ±} {s t p : set Œ±} (hs : is_glb s a) (hp : is_glb p a) (hst : s ‚äÜ t) (htp : t ‚äÜ p) : is_glb t a
(red : tactic.transparency) (e : expr) (e_map : list (expr √ó ‚Ñï)) (monom_map : native.rb_map linarith.monom ‚Ñï) : tactic (linarith.comp √ó list (expr √ó ‚Ñï) √ó native.rb_map linarith.monom ‚Ñï)
{p : ‚Ñï} [fact (nat.prime p)] (f : padic_seq p) : ‚Ñö
(Œ± : Type u) : Type u
{Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ (i : ‚Ñï), measurable (f i)) : measurable (Œª (x : Œ¥), filter.at_top.liminf (Œª (i : ‚Ñï), f i x))
{Œ± : Type u_1} {Œ≤ : Type u_2} [cancel_comm_monoid_with_zero Œ±] [normalized_gcd_monoid Œ±] (s : finset Œ≤) (f : Œ≤ ‚Üí Œ±) : Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} : {f // ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±), f a‚ÇÅ a‚ÇÇ = f a‚ÇÇ a‚ÇÅ} ‚âÉ (sym2 Œ± ‚Üí Œ≤)
{Œ± : Type u_1} [encodable Œ±] : ‚Ñï ‚Üí option (list Œ±)
{Œ± : Type u_2} [add_comm_semigroup Œ±] : add_comm_semigroup (set Œ±)
{C : Type u} [category_theory.category C] {F : C ‚•§ C} (A : category_theory.endofunctor.algebra F) : A.hom A
{Œ± : Type u_3} [preorder Œ±] : filter Œ±
{Œ± : Type u} {f g : Œ± ‚Üí Œ±} {x : Œ±} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ‚àò g) x
(b m : ‚Ñï) (hb : 2 ‚â§ b) : m ‚â† 0 ‚Üí b ^ (b.digits m).length ‚â§ b * m
{C : Type u} [category_theory.category C] {f g : category_theory.arrow C} (F : category_theory.limits.image_factorisation f.hom) (sq : f ‚ü∂ g) [category_theory.is_iso sq] : category_theory.limits.image_factorisation g.hom
 : abelianize ‚ä£ category_theory.forget‚ÇÇ CommGroup Group
{X : Type u_1} (r : X ‚Üí X ‚Üí Prop) (p : X ‚Üí Prop) : subtype.val ‚Åª¬π'o r ‚Ü™r r
(h_equality1 h_equality2 : expr) : tactic expr
(Œ± : Type u) [add_monoid Œ±] : Type u
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚âÉ‚Çú Œ≤) (g : Œ≤ ‚Üí Œ±) (hg : function.right_inverse g ‚áëf) : Œ± ‚âÉ‚Çú Œ≤
{M : Type u_1} [mul_one_class M] {S T : submonoid M} (h : S = T) : ‚Ü•S ‚âÉ* ‚Ü•T
{f : ‚Ñù ‚Üí ‚Ñù} {a : ‚Ñù} (h : is_local_extr f a) : deriv f a = 0
(p : ‚Ñï) [fact (nat.prime p)] (a : ‚Ñ§) : ‚Ñ§
{M : Type u_1} [comm_monoid_with_zero M] {S : submonoid M} {N : Type u_2} [comm_monoid_with_zero N] (f : S.localization_with_zero_map N) : M ‚Üí*‚ÇÄ N
 : tactic unit
{G : Type u_1} {H : Type u_2} [group G] [group H] [is_cyclic H] (f : G ‚Üí* H) (hf : f.ker ‚â§ subgroup.center G) (a b : G) : a * b = b * a
 : tactic unit
 : ordinal
{V : Type u} (G : simple_graph V) (n : ‚Ñï) : Prop
{Œ± : Type u} [pseudo_emetric_space Œ±] (Œ¥ : ‚Ñù) {E‚ÇÅ E‚ÇÇ : set Œ±} (h : E‚ÇÅ ‚äÜ E‚ÇÇ) : metric.thickening Œ¥ E‚ÇÅ ‚äÜ metric.thickening Œ¥ E‚ÇÇ
{R : Type u‚ÇÅ} {L : Type u‚ÇÇ} {M : Type u‚ÇÑ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [is_noetherian R L] : lie_module.is_nilpotent R L M ‚Üî ‚àÄ (x : L), is_nilpotent (‚áë(lie_module.to_endomorphism R L M) x)
{R : Type u_1} [comm_ring R] : quaternion R ‚Üí*‚ÇÄ R
{Œ± : Type u} : Œ±·µê·µí·µñ ‚Üí Œ±
 : list bool ‚Üí ‚Ñï
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (f : M ‚Üí+ P) : (add_con.ker f).quotient ‚âÉ+ ‚Ü•(f.mrange)
 : nzsnum ‚Üí nzsnum
(R : Type u_1) [comm_ring R] : ‚Ñï ‚Üí polynomial R
{R' : Type u_1} {Œ± : Type u_2} [semiring R'] [add_monoid Œ±] [distrib_mul_action R' Œ±] (S : subsemiring R') : distrib_mul_action ‚Ü•S Œ±
{Œπ : Type u} {X : Type v} [topological_space X] [paracompact_space X] (u : Œπ ‚Üí set X) (uo : ‚àÄ (a : Œπ), is_open (u a)) (uc : (‚ãÉ (i : Œπ), u i) = set.univ) : ‚àÉ (v : Œπ ‚Üí set X), (‚àÄ (a : Œπ), is_open (v a)) ‚àß (‚ãÉ (i : Œπ), v i) = set.univ ‚àß locally_finite v ‚àß ‚àÄ (a : Œπ), v a ‚äÜ u a
(x : cau_seq ‚Ñö has_abs.abs) : ‚Ñù
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] (B : Œπ ‚Üí submodule R A) : Prop
(n : ‚Ñï) : linear_independent ‚Ñö (Œª (ŒΩ : fin (n + 1)), bernstein_polynomial ‚Ñö n ‚ÜëŒΩ)
{M : Type u_1} [add_monoid M] {Œπ : Sort u_2} {s : Œπ ‚Üí set M} (h : ‚àÄ (y : Œπ), is_add_submonoid (s y)) : is_add_submonoid (set.Inter s)
{Œ± : Type u} [decidable_eq Œ±] (l‚ÇÅ l‚ÇÇ : list Œ±) : bool
 : environment ‚Üí name ‚Üí option name
 : tactic unit
(Œ± : Sort u) (Œ≤ : Sort v) : Sort (max 1 u v)
(C : Type u) [category_theory.category C] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] (T : category_theory.monad C) : ùü≠ C ‚ü∂ ‚ÜëT
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : category_theory.monoidal_category.tensor_unit_right C ‚âÖ ùü≠ C
{Œ± : Type u_1} [complete_lattice Œ±] {a : Œ±} {s : set Œ±} : has_Inf.Inf s ‚äî a ‚â§ ‚®Ö (b : Œ±) (H : b ‚àà s), b ‚äî a
{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} : f = g ‚Üî ‚àÄ (x : M), ‚áëf x = ‚áëg x
(Œì : Type u_1) (T : Type u_2) [topological_space T] [has_vadd Œì T] : Prop
{Œ± : Type u_1} (B : set (set Œ±)) (empty_mem : ‚àÖ ‚àà B) (subset_mem : ‚àÄ (s‚ÇÅ : set Œ±), s‚ÇÅ ‚àà B ‚Üí ‚àÄ (s‚ÇÇ : set Œ±), s‚ÇÇ ‚äÜ s‚ÇÅ ‚Üí s‚ÇÇ ‚àà B) (union_mem : ‚àÄ (s‚ÇÅ : set Œ±), s‚ÇÅ ‚àà B ‚Üí ‚àÄ (s‚ÇÇ : set Œ±), s‚ÇÇ ‚àà B ‚Üí s‚ÇÅ ‚à™ s‚ÇÇ ‚àà B) (singleton_mem : ‚àÄ (x : Œ±), {x} ‚àà B) : bornology Œ±
 : name ‚Üí name ‚Üí tactic (bool √ó ‚Ñï)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) (hf : embedding f) : Œ± ‚âÉ‚Çú ‚Ü•(set.range f)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ‚Ñù P) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p‚ÇÅ p‚ÇÇ : P) : has_dist.dist p‚ÇÅ (‚áë(euclidean_geometry.reflection s) p‚ÇÇ) = has_dist.dist (‚áë(euclidean_geometry.reflection s) p‚ÇÅ) p‚ÇÇ
{Œ≥ : Type} (args : list (widget.html Œ≥)) : list (widget.html Œ≥)
{G : Type u_10} {H : Type u_11} [mul_one_class G] [mul_one_class H] : G ‚âÉ* H ‚âÉ (additive G ‚âÉ+ additive H)
(f : pSet ‚Üí pSet) : pSet ‚Üí pSet
{Œπ : Sort u_1} {Œπ' : Sort u_2} {Œ± : Type u_3} [complete_lattice Œ±] {s : Œπ ‚Üí Œ±} (hs : complete_lattice.independent s) (f : Œπ' ‚Üí Œπ) (hf : function.injective f) : complete_lattice.independent (s ‚àò f)
{Œπ : Type u_1} {Œ± : Type u_2} [has_zero Œ±] (s : finset Œπ) (f : Œ† (i : Œπ), i ‚àà s ‚Üí Œ±) : Œπ ‚Üí‚ÇÄ Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {X : C} (h : category_theory.coyoneda.obj (opposite.op X) ‚ãô category_theory.ulift_functor ‚âÖ F.cocones) {Y : C} (f : X ‚ü∂ Y) : category_theory.limits.cocone F
(Œ± : Type u) [u : uniform_space Œ±] : set (Œ± √ó Œ±)
(ùïÇ : Type u_1) {ùî∏ : Type u_2} [field ùïÇ] [ring ùî∏] [algebra ùïÇ ùî∏] [topological_space ùî∏] [topological_ring ùî∏] (x : ùî∏) : ùî∏
(C : Type u‚ÇÅ) : Type u‚ÇÅ
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [category_theory.limits.has_pullback f g] : category_theory.limits.pullback f g ‚ü∂ X
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [linear_ordered_field ùïú] [add_comm_group E] [linear_ordered_add_comm_group Œ≤] [module ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : concave_on ùïú (‚áë(convex_hull ùïú) s) f) {x : E} (hx : x ‚àà ‚áë(convex_hull ùïú) s) : ‚àÉ (y : E) (H : y ‚àà s), f y ‚â§ f x
{P : ‚Ñ§ ‚Üí Prop} [decidable_pred P] (b : ‚Ñ§) (Hb : ‚àÄ (z : ‚Ñ§), P z ‚Üí z ‚â§ b) (Hinh : ‚àÉ (z : ‚Ñ§), P z) : {ub // P ub ‚àß ‚àÄ (z : ‚Ñ§), P z ‚Üí z ‚â§ ub}
(S : Type u_1) (R : out_param (Type u)) [non_assoc_semiring R] [set_like S R] : Type
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddCommGroup) : category_theory.limits.cocone F
 : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}
{Œ± : Type u_1} {R : Type u_2} {l : filter Œ±} {f : Œ± ‚Üí R} {r : R} [linear_ordered_ring R] [archimedean R] (hr : r < 0) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Œª (x : Œ±), f x * r) l filter.at_bot
{z : upper_half_plane} (h : ‚áëcomplex.norm_sq ‚Üëz < 1) : z.im < (modular_group.S ‚Ä¢ z).im
(pre : option name) (n : name) (vs : list expr) (tgt : expr) : tactic unit
{Œπ : Type u} (f : Œπ ‚Üí ordinal ‚Üí ordinal) (o : ordinal) : ordinal
{ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_3} [ordered_semiring ùïú] [add_comm_group E] [module ùïú E] {Œπ' : Type u_4} (f : Œπ' ‚Ü™ Œπ) {p : Œπ ‚Üí E} (hc : convex_independent ùïú p) : convex_independent ùïú (p ‚àò ‚áëf)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (f : ‚Ñï ‚Üí R) (g : ‚Ñï ‚Üí M) {m n : ‚Ñï} (hmn : m < n) : (finset.Ico m n).sum (Œª (i : ‚Ñï), f i ‚Ä¢ g i) = f (n - 1) ‚Ä¢ (finset.range n).sum (Œª (i : ‚Ñï), g i) - f m ‚Ä¢ (finset.range m).sum (Œª (i : ‚Ñï), g i) - (finset.Ico m (n - 1)).sum (Œª (i : ‚Ñï), (f (i + 1) - f i) ‚Ä¢ (finset.range (i + 1)).sum (Œª (i : ‚Ñï), g i))
 : pos_num ‚Üí ‚Ñï ‚Üí num
(k : Type u‚ÇÅ) (G : Type u‚ÇÇ) [semiring k] : Type (max u‚ÇÇ u‚ÇÅ)
{l : Type u_1} {m : Type u_2} {n : Type u_3} {Œ± : Type v} [non_unital_non_assoc_semiring Œ±] [fintype m] (M : matrix m n Œ±) : matrix l m Œ± ‚Üí+ matrix l n Œ±
{Œ± : Type u_1} (q : trunc Œ±) : semiquot Œ±
 : znum ‚Üí pos_num
{Œ± : Sort u_1} (a : erased (erased Œ±)) : erased Œ±
{E : Type u_2} [normed_group E] [normed_space ‚Ñù E] {s t : set E} (hs‚ÇÅ : convex ‚Ñù s) (hs‚ÇÇ : is_compact s) (ht‚ÇÅ : convex ‚Ñù t) (ht‚ÇÇ : is_closed t) (disj : disjoint s t) : ‚àÉ (f : E ‚ÜíL[‚Ñù] ‚Ñù) (u v : ‚Ñù), (‚àÄ (a : E), a ‚àà s ‚Üí ‚áëf a < u) ‚àß u < v ‚àß ‚àÄ (b : E), b ‚àà t ‚Üí v < ‚áëf b
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.is_kernel_pair f (ùüô X) (ùüô X)
{Œ± : Type u} [monoid Œ±] (u : Œ±À£) (val : Œ±) (hv : val = ‚Üëu) (inv : Œ±) (hi : inv = ‚Üëu‚Åª¬π) : Œ±À£
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_lt.lt] {a : Œ±} : a‚Åª¬π < 1 ‚Üî 1 < a
{Œ± : Type u_2} {Œ≤ : Type u_3} [ordered_add_comm_monoid Œ±] [ordered_add_comm_monoid Œ≤] : has_add (Œ± ‚Üí+o Œ≤)
{Œ± : Sort u_1} [is_empty Œ±] (p : Œ± ‚Üí Prop) : is_empty (subtype p)
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] [category_theory.monoidal_category C] (F : J ‚•§ Mon_ C) : (Mon_.forget C).map_cone (Mon_.limit_cone F) ‚âÖ category_theory.limits.limit.cone (F ‚ãô Mon_.forget C)
{L : first_order.language} {Œ± : Type u'} (f : L.functions 1) (t : L.term Œ±) : L.term Œ±
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) (N : Type u_1) [has_pow Œ≤ N] : has_pow Œ± N
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : dense (closure s) ‚Üî dense s
(M‚ÇÄ : Type u_4) : Type u_4
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} (n' m : ‚Ñï) : L.term (Œ± ‚äï fin n) ‚Üí L.term (Œ± ‚äï fin (n + n'))
(n : ‚Ñï) : (Œ£ (a : composition n), composition a.length) ‚âÉ Œ£ (c : composition n), Œ† (i : fin c.length), composition (c.blocks_fun i)
{Œ± : Type u_1} (l : list (lists Œ±)) : lists Œ±
{ùïú : Type u_1} {V : Type u_2} [normed_field ùïú] [add_comm_group V] [module ùïú V] (e : enorm ùïú V) : emetric_space V
(z : ‚ÑÇ) : ‚ÑÇ
(Œ± : Type u) (lt : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{Œ± : Type} [random Œ±] : io Œ±
{M : Type u_1} {F : Type u_2} [monoid F] (c : F ‚Üí M ‚Üí M) (h1 : c 1 = id) (hmul : ‚àÄ (f g : F), c (f * g) = c f ‚àò c g) (f : F) (n : ‚Ñï) : c (f ^ n) = (c f^[n])
{Œ± : Type u_1} {Œ≤ : Type u_2} {e e' : local_equiv Œ± Œ≤} (h : ‚àÄ (x : Œ±), ‚áëe x = ‚áëe' x) (hsymm : ‚àÄ (x : Œ≤), ‚áë(e.symm) x = ‚áë(e'.symm) x) (hs : e.source = e'.source) : e = e'
{k : Type u_2} {V1 : Type u_3} {P1 : Type u_4} [comm_ring k] [add_comm_group V1] [add_torsor V1 P1] [module k V1] (c : P1) (r : k) : P1 ‚Üí·µÉ[k] P1
{Œ± : Type u_1} [decidable_eq Œ±] (a : Œ±) : list Œ± ‚Üí ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : measure_theory.outer_measure Œ± ‚Üí‚Çó[ennreal] measure_theory.outer_measure Œ≤
{K : Type u} [division_ring K] : group_with_zero K
{f : ‚Ñù ‚Üí ‚Ñù} (hf : differentiable ‚Ñù f) (hf'_mono : monotone (deriv f)) : convex_on ‚Ñù set.univ f
{Œ± : Type u_1} {Œ≤ : Type u_2} {G‚ÇÄ : Type u_3} [group_with_zero G‚ÇÄ] [topological_space G‚ÇÄ] [has_continuous_inv‚ÇÄ G‚ÇÄ] [has_continuous_mul G‚ÇÄ] [topological_space Œ±] [topological_space Œ≤] {f g : Œ± ‚Üí G‚ÇÄ} (h : Œ± ‚Üí G‚ÇÄ ‚Üí Œ≤) (hf : continuous f) (hg : continuous g) (hh : ‚àÄ (a : Œ±), g a ‚â† 0 ‚Üí continuous_at ‚Üøh (a, f a / g a)) (h2h : ‚àÄ (a : Œ±), g a = 0 ‚Üí filter.tendsto ‚Üøh ((nhds a).prod ‚ä§) (nhds (h a 0))) : continuous (Œª (x : Œ±), h x (f x / g x))
{C : Type u} [category_theory.category C] (J : Type v) [category_theory.small_category J] (K : J ‚•§ C) (c : category_theory.limits.cone K) (t : Œ† (X : C·µí·µñ), category_theory.limits.is_limit ((category_theory.coyoneda.obj X).map_cone c)) : category_theory.limits.is_limit c
{R : Type u_1} [has_mul R] (c : R) : Prop
{R : Type u_1} {S : Type u_2} [mul_zero_one_class R] [decidable_eq R] [nontrivial R] [mul_zero_one_class S] [decidable_eq S] [nontrivial S] (f : R ‚Üí*‚ÇÄ S) (hf : function.injective ‚áëf) : with_top R ‚Üí*‚ÇÄ with_top S
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a : Œ±} : a < 0 ‚Üí 0 < -a
{Œ± : Sort u} : Œ± ‚Üí id Œ±
(C : Type u) [category_theory.category C] : Prop
{R : Type u} {M : Type v} [semiring R] [topological_space R] [topological_space M] [add_comm_monoid M] [module R M] [has_continuous_smul R M] [has_continuous_add M] (s : submodule R M) : submodule R M
{R : Type u_1} {R‚ÇÅ : Type u_2} {R‚ÇÇ : Type u_3} {M‚ÇÅ : Type u_6} {M‚ÇÇ : Type u_7} [comm_semiring R] [comm_semiring R‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {I‚ÇÅ : R‚ÇÅ ‚Üí+* R} {I‚ÇÇ : R‚ÇÇ ‚Üí+* R} (B : M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ] M‚ÇÇ ‚Üí‚Çõ‚Çó[I‚ÇÇ] R) : Prop
(p : ‚Ñï) [fact (nat.prime p)] {a : ‚Ñ§} (ha0 : ‚Üëa ‚â† 0) : zmod.legendre_sym p a = 1 ‚Üî is_square ‚Üëa
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [semi_normed_group E] [normed_space ùïú E] [proper_space ùïú] {s : set E} (s_nhd : s ‚àà nhds 0) : is_compact (weak_dual.polar ùïú s)
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X ‚Üí Y} [sequential_space X] : continuous f ‚Üî seq_continuous f
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} (hab : a = b) (hbc : b ‚â§ c) : a ‚â§ c
{ùïÇ : Type u_6} [is_R_or_C ùïÇ] {E' : Type u_7} [normed_group E'] [normed_space ùïÇ E'] {F' : Type u_8} [normed_group F'] [normed_space ùïÇ F'] [complete_space E'] (f : E' ‚Üí F') {f' : E' ‚âÉL[ùïÇ] F'} {a : E'} {n : with_top ‚Ñï} (hf : cont_diff_at ùïÇ n f a) (hf' : has_fderiv_at f ‚Üëf' a) (hn : 1 ‚â§ n) : local_homeomorph E' F'
{X Y : Top} {f g : C(‚Ü•X, ‚Ü•Y)} (H : f.homotopy g) : C(‚Ü•(Top.of (ulift ‚Ü•unit_interval √ó ‚Ü•X)), ‚Ü•Y)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [normed_field ùïú] [add_comm_group E] [module ùïú E] [add_comm_group F] [module ùïú F] (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú) : seminorm_family ùïú E F
(ùïú : Type u_1) (E : Type u_2) [comm_semiring ùïú] [topological_space ùïú] [has_continuous_add ùïú] [has_continuous_const_smul ùïú ùïú] [add_comm_monoid E] [module ùïú E] [topological_space E] : Type (max u_2 u_1)
(R : Type u) (M : Type v) (Œπ : Type x) [semiring R] (S : Type u_4) [fintype Œπ] [decidable_eq Œπ] [semiring S] [add_comm_monoid M] [module R M] [module S M] [smul_comm_class R S M] : ((Œπ ‚Üí R) ‚Üí‚Çó[R] M) ‚âÉ‚Çó[S] Œπ ‚Üí M
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ‚Ü•X) (R : category_theory.presieve U) : category_theory.presheaf.first_obj R F ‚âÖ Top.presheaf.sheaf_condition_equalizer_products.pi_opens F (Top.presheaf.covering_of_presieve U R)
{Œ± : Type u} [ta : topological_space Œ±] [linear_order Œ±] [order_topology Œ±] {t : set Œ±} [ht : t.ord_connected] : order_topology ‚Ü•t
{R : Type u_1} [comm_ring R] : comm_ring (clifford_algebra 0)
{A B : Type u} [add_comm_group A] [add_comm_group B] (f : A ‚Üí+ B) (n : ‚Ñ§) : A ‚ß∏ (zsmul_add_group_hom n).range ‚Üí+ B ‚ß∏ (zsmul_add_group_hom n).range
{Œ± : Type} (msgs : thunk (list string)) (p : parser Œ±) : parser Œ±
{Œ± : Type u_1} [measurable_space Œ±] (m : measure_theory.measure (measure_theory.measure Œ±)) : measure_theory.measure Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (Œ∏ : real.angle) : (-o).rotation Œ∏ = o.rotation (-Œ∏)
{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] : omega_complete_partial_order.continuous' coe
{X Y : CommRing} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ+* ‚Ü•Y
{M : Type u_5} {N : Type u_6} {P : Type u_7} [add_zero_class M] [add_zero_class N] [add_comm_monoid P] (f : M ‚Üí+ P) (g : N ‚Üí+ P) : M √ó N ‚Üí+ P
{key data : Type} [has_lt key] [decidable_rel has_lt.lt] : list (key √ó data) ‚Üí native.rb_lmap key data
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] (f‚ÇÄ f‚ÇÅ : C(X, Y)) : Type (max u v)
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (p : submodule R‚ÇÇ M‚ÇÇ) : submodule R M
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_initial C] [category_theory.limits.preserves_colimit (category_theory.functor.empty C) G] : category_theory.limits.is_initial (G.obj (‚ä•_ C))
{ùïú : Type u_1} {E : Type u_4} {F‚Çó : Type u_7} {G‚Çó : Type u_9} [semi_normed_group E] [semi_normed_group F‚Çó] [semi_normed_group G‚Çó] [nondiscrete_normed_field ùïú] [normed_space ùïú E] [normed_space ùïú F‚Çó] [normed_space ùïú G‚Çó] (f : E ‚ÜíL[ùïú] F‚Çó ‚ÜíL[ùïú] G‚Çó) : E √ó F‚Çó ‚ÜíL[ùïú] E √ó F‚Çó ‚ÜíL[ùïú] G‚Çó
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] (J : category_theory.grothendieck_topology C) (K : category_theory.grothendieck_topology D) (G : C ‚•§ D) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {p : filter Œπ} {c : Œ≤} : filter.tendsto ‚ÜøF (p.prod ‚ä§) (nhds c) ‚Üî tendsto_uniformly F (Œª (_x : Œ±), c) p
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_initial X) (f : Y ‚ü∂ X) : category_theory.split_epi f
{ùïú : Type u_1} {E : Type u_2} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] (f : ùïú ‚Üí E) (a : ùïú) : ùïú ‚Üí E
{R : Type u_1} [comm_semiring R] {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] {R' : Type u_2} [has_scalar R' M] (r : R') : free_add_monoid (M √ó N) ‚Üí+ tensor_product R M N
{Œ± : Type u_1} [decidable_eq Œ±] (l : list Œ±) (nd : l.nodup) (h : ‚àÄ (x : Œ±), x ‚àà l) : fin l.length ‚âÉ Œ±
{Œ± : Type u} (s : wseq Œ±) : computation (option Œ±)
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (hi : irreflexive r) {s : multiset Œ±} : (‚àÄ (a : Œ±), a ‚àà s ‚Üí acc (relation.cut_expand r) {a}) ‚Üí acc (relation.cut_expand r) s
{S : set ordinal} (o : ordinal) : ordinal.enum_ord S o = has_Inf.Inf (S ‚à© {b : ordinal | ‚àÄ (c : ordinal), c < o ‚Üí ordinal.enum_ord S c < b})
{Œ± Œ≤ : Pointed} (e : ‚Ü•Œ± ‚âÉ ‚Ü•Œ≤) (he : ‚áëe Œ±.point = Œ≤.point) : Œ± ‚âÖ Œ≤
(n : ‚Ñï) : finset.univ.sum (Œª (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.circumcenter_weights_with_circumcenter n i) = 1
{Œ± : Type u} [pseudo_emetric_space Œ±] (E : set Œ±) {Œ¥ : ‚Ñù} : frontier (metric.cthickening Œ¥ E) ‚äÜ {x : Œ± | emetric.inf_edist x E = ennreal.of_real Œ¥}
(tde : tactic_doc_entry) : tactic tactic_doc_entry
{Œ± : Type u_1} {Œ≤ : Type u_2} (s : set (Œ± ‚Üí Œ≤)) (t : set Œ±) : set Œ≤
(F : Type u_2) (Œ± : Type u_3) (Œ≤ : Type u_4) [topological_space Œ±] [pseudo_metric_space Œ≤] : Type (max u_2 u_3 u_4)
{Œ± : Type u_1} [measurable_space Œ±] {M : Type u_3} [add_comm_monoid M] [topological_space M] {N : Type u_4} [add_comm_monoid N] [topological_space N] [has_continuous_add M] [has_continuous_add N] (f : M ‚Üí+ N) (hf : continuous ‚áëf) : measure_theory.vector_measure Œ± M ‚Üí+ measure_theory.vector_measure Œ± N
(f f' : ‚Ñù ‚Üí ‚Ñù) {a b : ‚Ñù} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfI : f a = f b) (hff' : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí has_deriv_at f (f' x) x) : ‚àÉ (c : ‚Ñù) (H : c ‚àà set.Ioo a b), f' c = 0
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí. Œ≤) (l : filter Œ±) : filter Œ≤
(c : tactic.ring.cache) (n : name) : list expr ‚Üí expr
{n : ‚Ñï+} {K : Type u_1} [field K] {L : Type u_2} [field L] [algebra K L] [is_cyclotomic_extension {n} K L] (h : irreducible (polynomial.cyclotomic ‚Üën K)) [ne_zero ‚Üë‚Üën] : (polynomial.X ^ ‚Üën - 1).gal ‚âÉ* (zmod ‚Üën)À£
{E : Type u} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {a : E} {f' : E ‚ÜíL[‚Ñù] ‚Ñù} (h : is_local_max f a) (hf : has_fderiv_at f f' a) : f' = 0
{Œ± : Type u_1} {œÑ : Type u_4} {f : filter Œ±} (F : f.realizer) (E : F.œÉ ‚âÉ œÑ) : f.realizer
{Œ± : Type u_1} : regular_expression Œ± ‚Üí language Œ±
{R : Type u} [non_assoc_semiring R] : complete_lattice (subsemiring R)
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤] {K : set Œ±} {V : set (Œ≤ √ó Œ≤)} (f : C(Œ±, Œ≤)) (hV : V ‚àà uniformity Œ≤) : ‚àÉ (V' : set (Œ≤ √ó Œ≤)) (H : V' ‚àà uniformity Œ≤), V' ‚äÜ V ‚àß ‚àÄ (g : C(Œ±, Œ≤)), g ‚àà continuous_map.compact_conv_nhd K V' f ‚Üí continuous_map.compact_conv_nhd K V' g ‚äÜ continuous_map.compact_conv_nhd K V f
{R : Type u} {S : Type v} [comm_ring R] [comm_ring S] {f : R ‚Üí+* S} {g : S ‚Üí R} (hf : function.right_inverse g ‚áëf) : R ‚ß∏ f.ker ‚âÉ+* S
(Œ± : Type u_1) [fintype Œ±] [linear_order Œ±] {k : ‚Ñï} (h : fintype.card Œ± = k) : fin k ‚âÉo Œ±
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type (max v u)
{R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [add_comm_group N] [module R M] [module R N] [lie_ring_module L M] [lie_ring_module L N] [lie_module R L M] [lie_module R L N] (e : M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N) : M ‚âÉ‚Çó[R] N
{C : Type u} [category_theory.category C] (J‚ÇÅ : category_theory.grothendieck_topology C) {X : C} {S : category_theory.sieve X} (h : J‚ÇÅ.is_closed S) {Y : C} (f : Y ‚ü∂ X) : J‚ÇÅ.covers S f ‚Üî ‚áëS f
{Œπ : Type v} {Œ≤ : Œπ ‚Üí Type w} [Œ† (i : Œπ), add_comm_monoid (Œ≤ i)] [is_empty Œπ] : unique (direct_sum Œπ (Œª (i : Œπ), Œ≤ i))
{Œ± : Type u_1} [measurable_space Œ±] (f : filter Œ±) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_binary_biproduct X Y] : X ‚äû Y ‚ü∂ X
(C : Type u‚ÇÅ) [ùíû : category_theory.category C] : category_theory.enriched_category (Type v) C
{Œ± : Type u_1} [conditionally_complete_linear_order Œ±] {a : Œ±} : conditionally_complete_linear_order {x // a ‚â§ x}
{J : Type u‚ÇÅ} [category_theory.category J] [category_theory.is_connected J] : category_theory.is_connected J·µí·µñ
 : real.sin (real.pi / 3) = real.sqrt 3 / 2
{X : Type u_1} (to_prod : X √ó X) : Bipointed
 : Type
{H : Type u} (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] (G : structure_groupoid H) : set (local_homeomorph M H)
{X : Compactum} (F : ultrafilter ‚Ü•X) : F.Lim = X.str F
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : M
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚âÉL[ùïú] F) : ‚Üëf.nonlinear_right_inverse
{F : Type u_1} (Œ± : Type u_3) (Œ≤ : Type u_4) [linear_order Œ±] [lattice Œ≤] [order_hom_class F Œ± Œ≤] : lattice_hom_class F Œ± Œ≤
{Œ± : Type u_1} [mul_zero_one_class Œ±] [has_distrib_neg Œ±] : sign_type ‚Üí*‚ÇÄ Œ±
(p : ‚Ñï) (q : ‚Ñö) : padic_norm p (-q) = padic_norm p q
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ‚Ü•X) (R : category_theory.presieve U) : category_theory.limits.parallel_pair (category_theory.presheaf.first_map R F) (category_theory.presheaf.second_map R F) ‚âÖ Top.presheaf.sheaf_condition_equalizer_products.diagram F (Top.presheaf.covering_of_presieve U R)
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.initial] {E : Type u} [category_theory.category E] {G : D ‚•§ E} (t : category_theory.limits.limit_cone (F ‚ãô G)) : category_theory.limits.limit_cone G
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} {F' : K ‚•§ D} (G : category_theory.limits.cocone F ‚•§ category_theory.limits.cocone F') [category_theory.limits.preserves_colimit (category_theory.functor.empty (category_theory.limits.cocone F)) G] {c : category_theory.limits.cocone F} (hc : category_theory.limits.is_colimit c) : category_theory.limits.is_colimit (G.obj c)
{ùïú : Type u_1} {E : Type u_3} [ordered_semiring ùïú] [topological_space E] [add_cancel_comm_monoid E] [has_continuous_add E] [module ùïú E] {s : set E} (hs : strict_convex ùïú s) (z : E) : strict_convex ùïú ((Œª (x : E), z + x) ‚Åª¬π' s)
{m : Type u ‚Üí Type u} [monad m] {Œ± : Type u} (x : m Œ±) : tactic.mllist m Œ±
(E : Type u_8) [add_comm_group E] [topological_space E] [topological_add_group E] : continuous_add_monoid_hom E E
(S : Type u_1) {K : Type u_2} [linear_ordered_field K] [set_like S K] [subfield_class S K] (s : S) : linear_ordered_field ‚Ü•s
(nm : name) : tactic ‚Ñï
(R : Type u_1) (E : Type u_5) (E‚ÇÇ : Type u_6) (E‚ÇÉ : Type u_7) [semiring R] [semi_normed_group E] [semi_normed_group E‚ÇÇ] [semi_normed_group E‚ÇÉ] [module R E] [module R E‚ÇÇ] [module R E‚ÇÉ] : (E √ó E‚ÇÇ) √ó E‚ÇÉ ‚âÉ‚Çó·µ¢[R] E √ó E‚ÇÇ √ó E‚ÇÉ
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (v : n ‚Üí Œ±) : invertible (matrix.diagonal v) ‚âÉ invertible v
{Œπ : Type u_1} {S : Type u_3} {R : Type u_4} [decidable_eq Œπ] [add_monoid Œπ] [comm_semiring S] [semiring R] [algebra S R] (A : Œπ ‚Üí submodule S R) [set_like.graded_monoid A] : direct_sum Œπ (Œª (i : Œπ), ‚Ü•(A i)) ‚Üí‚Çê[S] R
{n : ‚Ñï} {E : Type u_1} [normed_group E] (f : (fin n ‚Üí ‚ÑÇ) ‚Üí E) (c : fin n ‚Üí ‚ÑÇ) (R : fin n ‚Üí ‚Ñù) : Prop
{G : Type u_1} (P : Type u_2) [add_group G] [add_torsor G P] (v : G) : equiv.perm P
{P : ‚Ñ§ ‚Üí Prop} {m : ‚Ñ§} (h0 : P m) (h1 : ‚àÄ (n : ‚Ñ§), m ‚â§ n ‚Üí P n ‚Üí P (n + 1)) (n : ‚Ñ§) : m ‚â§ n ‚Üí P n
(M : Type u) : Type u
{Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A ‚Üî ‚àÉ (Œπ : Type u_2) (_x : fintype Œπ) (f : mv_polynomial Œπ R ‚Üí‚Çê[R] A), function.surjective ‚áëf ‚àß f.to_ring_hom.ker.fg
(Œ± : Type u_1) [H1 : partial_order Œ±] [H2 : has_Inf Œ±] (is_glb_Inf : ‚àÄ (s : set Œ±), is_glb s (has_Inf.Inf s)) : complete_lattice Œ±
{n : ‚Ñï} [fact (0 < n)] (x : (zmod n)À£) : x ^ n.totient = 1
{R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [semiring R] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [semi_normed_group E] [semi_normed_group E‚ÇÇ] [module R E] [module R‚ÇÇ E‚ÇÇ] (f : E ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) (hf : isometry ‚áëf) : E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ
{R : Type u_1} [comm_semiring R] {A : Type u_2} [comm_semiring A] [algebra R A] {M : Type u_3} [add_comm_monoid M] [module A M] [module R M] : has_coe_to_fun (derivation R A M) (Œª (_x : derivation R A M), A ‚Üí M)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_coequalizer f g] [category_theory.limits.has_coequalizer (G.map f) (G.map g)] [category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G] : category_theory.limits.coequalizer (G.map f) (G.map g) ‚âÖ G.obj (category_theory.limits.coequalizer f g)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.limits.preserves_colimit K F] : category_theory.limits.preserves_colimit K G
{Œ≥ : Type w} [linear_order Œ≥] {a b : Œ≥} {s t : set Œ≥} (ha : is_least s a) (hb : is_least t b) : is_least (s ‚à™ t) (linear_order.min a b)
{R : Type u} [ring R] {Œ± : Type u_1} [has_scalar R Œ±] (S : subring R) : has_scalar ‚Ü•S Œ±
{X : Type u} [lattice X] [jordan_holder_lattice X] (s‚ÇÅ s‚ÇÇ : composition_series X) (h : s‚ÇÅ.top = s‚ÇÇ.bot) : composition_series X
{C : Type u} [category_theory.category C] {R X Y : C} (f : X ‚ü∂ Y) (a b : R ‚ü∂ X) : subsingleton (category_theory.is_kernel_pair f a b)
 : Type
{C : Type u‚ÇÅ} [category_theory.category C] (T : category_theory.monad C) : T.adj.to_monad ‚âÖ T
{M : Type u_4} [add_zero_class M] (self : add_submonoid M) : add_subsemigroup M
 : tactic unit
{X : Type u_1} (Y : Type u_2) [topological_space X] [mul_zero_one_class Y] {U : set X} (hU : is_clopen U) : locally_constant X Y
{C : Type u} [category_theory.category C] [‚àÄ (X Y : C), subsingleton (X ‚ü∂ Y)] : category_theory.locally_small C
{X Y Z : algebraic_geometry.LocallyRingedSpace} (f : X.hom Y) (g : Y.hom Z) : X.hom Z
(G : pgame) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [add_zero_class Œ≥] [has_continuous_add Œ≥] (g : C(Œ±, Œ≤)) : C(Œ≤, Œ≥) ‚Üí+ C(Œ±, Œ≥)
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : ¬¨is_smul_regular M 0 ‚Üî nontrivial M
{n : ‚Ñï} (c : composition n) : finset (fin (n + 1))
(Œ± : Type u_1) {Œ≤ : Type u_2} (b : Œ≤) : Œ± ‚Ü™ Œ± √ó Œ≤
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÅ) [category_theory.category D] : category_theory.category (C √ó D)
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [topological_space Œ±] [preorder Œ±] [topological_space Œ≤] [preorder Œ≤] : Type (max u_6 u_7 u_8)
{R : Type u_4} [linear_ordered_comm_ring R] (a b : R) : 2 * a * b ‚â§ a ^ 2 + b ^ 2
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : Type (max u v)
{Œ± : Type u_1} (n : ‚Ñï) (s : multiset Œ±) : multiset (multiset Œ±)
 : computability.fin_encoding ‚Ñï
{C : Type u} [category_theory.category C] {X Y : Top} (f : X ‚ü∂ Y) {‚Ñ± ùí¢ : Top.presheaf C X} (Œ± : ‚Ñ± ‚ü∂ ùí¢) : f _* ‚Ñ± ‚ü∂ f _* ùí¢
{Œ± : Type u} [topological_space Œ±] : totally_disconnected_space Œ± ‚Üî ‚àÄ (x : Œ±), connected_component x = {x}
{ùïú : Type u} [nondiscrete_normed_field ùïú] {E : Type v} [normed_group E] [normed_space ùïú E] {F : Type w} [normed_group F] [normed_space ùïú F] [complete_space ùïú] {Œπ : Type u_1} [fintype Œπ] (v : basis Œπ ùïú E) (f : Œπ ‚Üí F) : E ‚ÜíL[ùïú] F
{Œ± : Type u} : dlist Œ± ‚Üí list Œ±
(n m : ‚Ñï+) : ‚Ñï+
{Œ± : Type u_1} : ordnode Œ± ‚Üí Œ± ‚Üí ordnode Œ± ‚Üí Œ± ‚Üí ordnode Œ± ‚Üí ordnode Œ±
{H : Type u} [topological_space H] (PG : pregroupoid H) : structure_groupoid H
{E : Type u_4} {F : Type u_5} [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] [normed_group F] [normed_space ‚Ñù F] [finite_dimensional ‚Ñù F] {f : E ‚Üí F} (h : cont_diff ‚Ñù 1 f) (hEF : finite_dimensional.finrank ‚Ñù E < finite_dimensional.finrank ‚Ñù F) : dense (set.range f)·∂ú
{X : Type u_1} [topological_space X] (s : set X) : Prop
{L : first_order.language} {M : Type w} [L.Structure M] (S : L.substructure M) (s : set M) (hs : s = ‚ÜëS) : L.substructure M
(k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p : P) : p ‚àâ ‚ä•
(tm : turing.fin_tm2) (l : list (tm.Œì tm.k‚ÇÄ)) (l' : option (list (tm.Œì tm.k‚ÇÅ))) : Type
 : Type
{m : Type u} {n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] [fintype m] [decidable_eq m] (A : matrix m n Œ±) (B : matrix n m Œ±) : (A.mul B + 1).det = (B.mul A + 1).det
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) : K ‚äì K·óÆ = ‚ä•
(R : Type u) [comm_semiring R] (A : Type v) [semiring A] [algebra R A] (n : Type w) : A ‚Üí‚Çó[R] matrix n n R ‚Üí‚Çó[R] matrix n n A
{Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_group_hom f) : f 0 = 0
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : seq1 Œ± ‚Üí seq1 Œ≤
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [add_zero_class Œ≤] : add_zero_class Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (E : C ‚•§ D) [category_theory.is_equivalence E] : E ‚ä£ E.inv
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf' : dense_range f) (hf : continuous f) {s : set Œ±} (hs : dense s) {t : set Œ≤} (ht : set.maps_to f s t) : dense t
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {P Q : C} (R : C) (f : P ‚ü∂ Q) : (Q ‚ü∂ R) ‚Üí+ (P ‚ü∂ R)
{C : Type u‚ÇÅ} [category_theory.category C] (D : category_theory.glue_data C) [category_theory.limits.has_multicoequalizer D.diagram] [category_theory.limits.has_colimits C] : D.sigma_opens ‚ü∂ D.glued
(A : Type u_2) [comm_ring A] [is_domain A] : Prop
 : simp_lemmas ‚Üí list name ‚Üí simp_lemmas
(M N : ‚Ñï) : ‚áëroth_number_nat (M + N) ‚â§ ‚áëroth_number_nat M + ‚áëroth_number_nat N
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X ‚Üí Y) : Prop
(X : algebraic_geometry.LocallyRingedSpace) (x : ‚Ü•X) : algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X) ‚ü∂ X.to_SheafedSpace.to_PresheafedSpace.presheaf.stalk x
{X : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (J : Type u_3) (obj : J ‚Üí algebraic_geometry.Scheme) (map : Œ† (i : J), obj i ‚ü∂ X) (e‚ÇÅ : J ‚âÉ ùí∞.J) (e‚ÇÇ : Œ† (i : J), obj i ‚âÖ ùí∞.obj (‚áëe‚ÇÅ i)) (e‚ÇÇ_1 : ‚àÄ (i : J), map i = (e‚ÇÇ i).hom ‚â´ ùí∞.map (‚áëe‚ÇÅ i)) : X.open_cover
{Œ± : Type u_1} [has_zero Œ±] [linear_order Œ±] (a : Œ±) : {x // 0 ‚â§ x}
{Œ± : Type u_1} (a : Œ±) [subsingleton Œ±] : fintype Œ±
{Œ± : Type u} [pseudo_emetric_space Œ±] {s t : set Œ±} (h : s ‚äÜ t) : emetric.diam s ‚â§ emetric.diam t
(m : ‚Ñ§) : convex_on ‚Ñù (set.Ioi 0) (Œª (x : ‚Ñù), x ^ m)
{G : Type u} [add_group G] (N : add_subgroup G) [nN : N.normal] : add_con G
(Œ± : Type u_2) [complete_lattice Œ±] : frame_hom Œ± Œ±
{Œ± : Type u_1} [add_semigroup Œ±] [partial_order Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] [contravariant_class Œ± Œ± has_add.add has_le.le] [contravariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b c d : Œ±} (hac : a ‚â§ c) (hbd : b ‚â§ d) : a + b = c + d ‚Üî a = c ‚àß b = d
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} (h : (s ‚à© t).nonempty) : metric.diam (s ‚à™ t) ‚â§ metric.diam s + metric.diam t
(h : expr) : tactic (list expr)
{Œ± : Type u_1} [comm_monoid Œ±] (f : ‚Ñï ‚Üí Œ±) (n : ‚Ñï) : finset.univ.prod (Œª (i : fin n), f ‚Üëi) = (finset.range n).prod (Œª (i : ‚Ñï), f i)
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L
(Œ± : Type u_1) [fintype Œ±] {R : Type u_2} [comm_semiring R] (a b : R) : finset.univ.sum (Œª (s : finset Œ±), a ^ s.card * b ^ (fintype.card Œ± - s.card)) = (a + b) ^ fintype.card Œ±
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : Top} (f : X ‚ü∂ Y) : Top.presheaf C Y ‚•§ Top.presheaf C X
(n k : ‚Ñï) : (n ^ k).factorization = k ‚Ä¢ n.factorization
{Œ± : Type u} {L‚ÇÅ L‚ÇÇ : list (Œ± √ó bool)} [decidable_eq Œ±] (H : free_group.reduce L‚ÇÅ = free_group.reduce L‚ÇÇ) : free_group.mk L‚ÇÅ = free_group.mk L‚ÇÇ
{M : Type u_3} [monoid M] [inhabited M] (l : list M) (h : l ‚â† list.nil) : l.head * l.tail.prod = l.prod
{Œ± : Type u} [preorder Œ±] {f : ‚Ñï ‚Üí Œ±} (hf : monotone f) (n : ‚Ñï) {x : Œ±} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ‚Ñï) : f a ‚â† x
{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] {X : C} : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ category_theory.non_preadditive_abelian.œÉ category_theory.non_preadditive_abelian.diag_œÉ)
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (h : M ‚âÉ* N) : ‚áëh 1 = 1
{Œ± : Type u_1} [decidable_eq Œ±] (l : list Œ±) (H : ‚àÄ (x : Œ±), x ‚àà l) : fintype Œ±
(R : Type u_1) [comm_ring R] [is_domain R] : polynomial.cyclotomic' 0 R = 1
{M : Type u_1} [add_semigroup M] : add_semigroup (ultrafilter M)
{Œ± : Type u} {l : list Œ±} (hn : l.nodup) : l.cyclic_permutations.nodup
{C : Type u} [category_theory.category C] (Ps : set (C·µí·µñ ‚•§ Type v)) : category_theory.grothendieck_topology C
 : list omega.term ‚Üí list bool
 : linter
{Œπ : Type u_4} {M : Type u_5} {Œ±s : Œπ ‚Üí Type u_13} [has_zero M] (l : (Œ£ (i : Œπ), Œ±s i) ‚Üí‚ÇÄ M) (i : Œπ) : Œ±s i ‚Üí‚ÇÄ M
(M : Type u) [semi_normed_group M] : SemiNormedGroup‚ÇÅ
(env : environment) (n : name) : bool
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [mul_zero_one_class Œ±] [mul_zero_one_class Œ≤] (f : Œ± ‚Üí*‚ÇÄo Œ≤) : Œ± ‚Üí*o Œ≤
 : Type
{ùïÇ : Type u_1} [is_R_or_C ùïÇ] : has_strict_deriv_at (exp ùïÇ) 1 0
{A : Type u_1} {B : Type u_2} [monoid A] [monoid B] (f : A ‚Üí* B) (g : B ‚Üí A) (h‚ÇÅ : function.left_inverse g ‚áëf) (h‚ÇÇ : function.right_inverse g ‚áëf) : B ‚Üí* A
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] {Z : D} (F : C ‚•§ D) (hZ : category_theory.limits.is_initial Z) (G : category_theory.with_initial C ‚•§ D) (h : category_theory.with_initial.incl ‚ãô G ‚âÖ F) (hG : G.obj category_theory.with_initial.star ‚âÖ Z) : G ‚âÖ category_theory.with_initial.lift_to_initial F hZ
{F G H : Type u} [add_group F] [add_group G] [add_group H] [fintype F] [fintype H] (f : F ‚Üí+ G) (g : G ‚Üí+ H) (h : g.ker ‚â§ f.range) : fintype G
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] {f : G ‚Üí+ N} {g : N ‚Üí+ G} (h : function.left_inverse ‚áëg ‚áëf) : G ‚âÉ+ ‚Ü•(f.range)
{Œ± : Type u_1} {s : finset Œ±} {f : Œ± ‚Üí ennreal} : s.sum (Œª (a : Œ±), f a) < ‚ä§ ‚Üî ‚àÄ (a : Œ±), a ‚àà s ‚Üí f a < ‚ä§
{Œ± : Type u_1} {Œ≤ : Type u_2} [tŒ± : topological_space Œ±] [tŒ≤ : topological_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} {V‚ÇÇ : Type u_5} {P‚ÇÇ : Type u_6} [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] {p : Œπ ‚Üí P} (f : P ‚Üí·µÉ[k] P‚ÇÇ) (hf : function.injective ‚áëf) : affine_independent k (‚áëf ‚àò p) ‚Üî affine_independent k p
{x : ‚Ñù} (hx : liouville x) (p : ‚Ñù) : liouville_with p x
{V : Type u_1} (G : simple_graph V) (u v : V) : ‚Ñï
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (E : Type u_2) [normed_group E] [normed_space ùïú E] : (model_with_corners_self ùïú E).boundaryless
{n : Type u_1} {ùïú : Type u_3} [field ùïú] [decidable_eq n] [fintype n] (M : matrix n n ùïú) : ‚àÉ (L L' : list (matrix.transvection_struct n ùïú)) (D : n ‚Üí ùïú), M = ((list.map matrix.transvection_struct.to_matrix L).prod.mul (matrix.diagonal D)).mul (list.map matrix.transvection_struct.to_matrix L').prod
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : ‚Üë(finite_dimensional.finrank K V) = module.rank K V
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] (F : category_theory.pseudofunctor B C) (a b : B) : (a ‚ü∂ b) ‚•§ (F.obj a ‚ü∂ F.obj b)
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b : Œ±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {r : setoid Œ≤} : setoid.comap f r = setoid.ker (quotient.mk ‚àò f)
{Œ± : Sort u} {Œ≤ : Sort v} {ra : Œ± ‚Üí Œ± ‚Üí Prop} {rb : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (e : Œ± ‚âÉ Œ≤) (eq : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±), ra a‚ÇÅ a‚ÇÇ ‚Üî rb (‚áëe a‚ÇÅ) (‚áëe a‚ÇÇ)) : quot ra ‚âÉ quot rb
 : znum ‚Üí znum ‚Üí znum
(x : ‚Ñù) : summable (Œª (n : ‚Ñï), x ^ n / ‚Üë(n.factorial))
(C : Type u) [category_theory.category C] [category_theory.essentially_small C] : Type w
(h : name) (t : expr) : smt_tactic unit
(ds : list ‚Ñï) : Type
{C : Type u} [category_theory.groupoid C] (X Y : C) : (X ‚âÖ Y) ‚âÉ (X ‚ü∂ Y)
{Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : uniform_continuous (Œª (x : Œ±), metric.inf_nndist x s)
{Œ± : Type u} (c : omega_complete_partial_order.chain (part Œ±)) : part Œ±
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] : submodule.torsion R ‚Ü•(submodule.torsion R M) = ‚ä§
{Œπ : Type u} {Œ± : Type v} [decidable_eq Œ±] (t : Œπ ‚Üí finset Œ±) : (‚àÄ (s : finset Œπ), s.card ‚â§ (s.bUnion t).card) ‚Üî ‚àÉ (f : Œπ ‚Üí Œ±), function.injective f ‚àß ‚àÄ (x : Œπ), f x ‚àà t x
{n : ‚Ñï} (A B : finset (fin n)) : (finset.image (Œª (i : fin n), ‚Üëi) A).to_colex ‚â§ (finset.image (Œª (i : fin n), ‚Üëi) B).to_colex ‚Üî A.to_colex ‚â§ B.to_colex
{m : Type u ‚Üí Type u} [monad m] {Œ± : Type u} : tactic.mllist m (tactic.mllist m Œ±) ‚Üí tactic.mllist m Œ±
{F : Type u_3} [field F] [fintype F] (hF : ring_char F ‚â† 2) (a : FÀ£) : is_square a ‚Üî a ^ (fintype.card F / 2) = 1
{M : Type u_3} {N : Type u_4} {hM : mul_zero_one_class M} {hN : mul_zero_one_class N} (f : M ‚Üí*‚ÇÄ N) (f' : M ‚Üí N) (h : f' = ‚áëf) : M ‚Üí* N
{G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C} (f : X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ Y‚ÇÅ ‚äû Y‚ÇÇ) [category_theory.is_iso (category_theory.limits.biprod.inl ‚â´ f.hom ‚â´ category_theory.limits.biprod.fst)] : X‚ÇÇ ‚âÖ Y‚ÇÇ
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {c : E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds b ‚äì measure_theory.measure_space.volume.ae) (nhds c)) : has_deriv_at (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in a..u, f x) c b
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] {C : Type u‚ÇÑ} [category_theory.category C] (L : A ‚•§ T) (F : C ‚•§ B) (R : B ‚•§ T) : category_theory.comma L (F ‚ãô R) ‚•§ category_theory.comma L R
{M : Type u} [has_zero M] [has_add M] : ‚Ñï ‚Üí M ‚Üí M
{M : Type u} [div_inv_monoid M] (x : M) (z : ‚Ñ§) : mul_opposite.op (x ^ z) = mul_opposite.op x ^ z
{X Y : Type u} (f : X ‚ü∂ Y) : category_theory.epi f ‚Üî function.surjective f
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {l : filter Œ±} (f : l.germ Œ≤) {lc : filter Œ≥} (g : lc.germ Œ±) (hg : g.tendsto l) : lc.germ Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : Œ± ‚âÉ‚Çú Œ≤) : local_homeomorph Œ± Œ≤
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} (n : ‚Ñï) (hs : is_open s) : set.eq_on (iterated_fderiv_within ùïú n f s) (iterated_fderiv ùïú n f) s
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {S : set X} {f‚ÇÄ f‚ÇÅ g‚ÇÄ g‚ÇÅ : C(X, Y)} (F : f‚ÇÄ.homotopy_rel f‚ÇÅ S) (h‚ÇÄ : f‚ÇÄ = g‚ÇÄ) (h‚ÇÅ : f‚ÇÅ = g‚ÇÅ) : g‚ÇÄ.homotopy_rel g‚ÇÅ S
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] {i : D.to_glue_data.J} (U : topological_space.opens ‚Ü•((D.to_glue_data.U i).carrier)) : ‚àÉ (eq_1 : opposite.op U = opposite.op ((topological_space.opens.map (category_theory.limits.colimit.Œπ D.to_glue_data.diagram.multispan (opposite.unop (opposite.op (category_theory.limits.walking_multispan.right i)))).base).obj (_.functor.obj U))), D.Œπ_inv_app U ‚â´ D.diagram_over_open_œÄ U i = (D.to_glue_data.U i).presheaf.map (category_theory.eq_to_hom eq_1)
(A : out_param (Type u)) {B : Type v} [has_quotient A B] (b : B) : Type (max u v)
{A : Type u_1} [add_monoid A] : has_faithful_smul (add_aut A) A
(decl : name) : tactic norm_cast.label
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} : is_min_on f s a ‚Üí is_max_on (‚áëorder_dual.to_dual ‚àò f) s a
(red : tactic.transparency) (e : expr) : tactic tactic.abel.context
{L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.equiv M N) (g : L.equiv N P) (h : L.equiv P Q) : (h.comp g).comp f = h.comp (g.comp f)
{m : Type u ‚Üí Type u} [applicative m] {Œ± Œ≤ : Type u} (F : Œ± ‚Üí m Œ≤) : free_add_magma Œ± ‚Üí m (free_add_magma Œ≤)
{f : ‚ÑÇ ‚Üí ‚ÑÇ} {c : ‚ÑÇ} {R‚ÇÅ R‚ÇÇ : ‚Ñù} (hd : differentiable_on ‚ÑÇ f (metric.ball c R‚ÇÅ)) (h_maps : set.maps_to f (metric.ball c R‚ÇÅ) (metric.ball (f c) R‚ÇÇ)) (h‚ÇÄ : 0 < R‚ÇÅ) : complex.abs (deriv f c) ‚â§ R‚ÇÇ / R‚ÇÅ
{s : Type u‚ÇÄ} {s' : Type u‚ÇÅ} {m : Type u‚ÇÄ ‚Üí Type v‚ÇÄ} {m' : Type u‚ÇÅ ‚Üí Type v‚ÇÅ} [uliftable m m'] (F : s ‚âÉ s') : uliftable (state_t s m) (state_t s' m')
(n : ‚Ñï+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [ne_zero ‚Üë‚Üën] [is_cyclotomic_extension {n} K L] : polynomial.is_splitting_field K L (polynomial.X ^ ‚Üën - 1)
{Œ± : Type u} {Œ≤ : Type v} {p : Œ≤ ‚Üí Prop} [decidable_pred p] (f : Œ± ‚âÉ subtype p) : equiv.perm Œ± ‚Üí* equiv.perm Œ≤
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {n : with_top ‚Ñï} {p : E ‚Üí formal_multilinear_series ùïú E F} (h : has_ftaylor_series_up_to n f p) (hn : 1 ‚â§ n) (x : E) : has_fderiv_at f (‚áë(continuous_multilinear_curry_fin1 ùïú E F) (p x 1)) x
{C : Type u} [category_theory.category C] [category_theory.abelian C] {X Y : C} {f : X ‚ü∂ Y} [category_theory.epi f] (s : category_theory.limits.fork f 0) (h : category_theory.limits.is_limit s) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ f _)
{Œ± : Type u_1} [lattice Œ±] [order_bot Œ±] {a : Œ±} (ha : a ‚â† ‚ä•) : finpartition a
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] (P Q : C) : P ‚äû Q ‚âÖ Q ‚äû P
(Œ± : Type u) : Type u
(Œ± : Type u_1) (Œ≤ : Type u_2) [uniform_space Œ±] [uniform_space Œ≤] : Œ± √ó Œ≤ ‚âÉ·µ§ Œ≤ √ó Œ±
{R : Type u} [comm_ring R] (M : Module R) (N : Module R) : Module R
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : rel Œ± Œ≤) : set Œ±
{m : Type ‚Üí Type u_1} [monad m] {key val val' : Type} [has_lt key] [decidable_rel has_lt.lt] (f : val ‚Üí m val') (s : native.rb_map key val) : m (native.rb_map key val')
{n : ‚Ñï} : n.factorization.support = n.factors.to_finset
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (ùïú : Type u_3) [field ùïú] [is_alg_closed ùïú] [category_theory.linear ùïú C] [category_theory.limits.has_kernels C] (X Y : C) [finite_dimensional ùïú (X ‚ü∂ X)] [category_theory.simple X] [category_theory.simple Y] : finite_dimensional.finrank ùïú (X ‚ü∂ Y) ‚â§ 1
{Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} (f‚ÇÅ f‚ÇÇ : Œ† (x : Œ±), Œ≤ x) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D·µí·µñ) [category_theory.limits.preserves_finite_colimits F] : category_theory.limits.preserves_finite_limits F.unop
(a : zmod 4) : ‚áëzmod.œá‚ÇÑ a = 0 ‚à® ‚áëzmod.œá‚ÇÑ a = 1 ‚à® ‚áëzmod.œá‚ÇÑ a = -1
{Œ± : Type u} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_antisymm Œ± r] {a b : Œ±} : r a b ‚Üí r b a ‚Üí a = b
(A : Type y) [add_comm_monoid A] : A ‚âÉ+ (‚Ñï ‚Üí+ A)
{R : Type u‚ÇÅ} [comm_semiring R] (a b : R) : (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2
{R : Type u} [ring R] : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ (Module R) AddCommGroup)
{R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} [comm_semiring R] [semiring A‚ÇÅ] [semiring A‚ÇÇ] [algebra R A‚ÇÅ] [algebra R A‚ÇÇ] (f : A‚ÇÅ ‚Üí‚Çê[R] A‚ÇÇ) (g : A‚ÇÇ ‚Üí‚Çê[R] A‚ÇÅ) (h‚ÇÅ : f.comp g = alg_hom.id R A‚ÇÇ) (h‚ÇÇ : g.comp f = alg_hom.id R A‚ÇÅ) : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ
{Œ± : Type u_1} (s : multiset Œ±) : multiset {x // x ‚àà s}
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {X X' Y Y' : C} [category_theory.exact_pairing X' Y'] (i : X ‚âÖ X') (j : Y ‚âÖ Y') : category_theory.exact_pairing X Y
 : ‚Ñï
 : Type_to_PartialFun ‚ãô PartialFun_to_Pointed ‚âÖ Type_to_Pointed
{R : Type u_1} {R‚ÇÅ : Type u_2} {R‚ÇÇ : Type u_3} {M‚ÇÅ : Type u_6} {M‚ÇÇ : Type u_7} [comm_semiring R] [comm_semiring R‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {I‚ÇÅ : R‚ÇÅ ‚Üí+* R} {I‚ÇÇ : R‚ÇÇ ‚Üí+* R} (B : M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ] M‚ÇÇ ‚Üí‚Çõ‚Çó[I‚ÇÇ] R) (x : M‚ÇÅ) (y : M‚ÇÇ) : Prop
{Œ≤ : Type w} {C : Type u} [category_theory.category C] (f : Œ≤ ‚Üí C) [category_theory.limits.has_coproduct f] (b : Œ≤) : f b ‚ü∂ ‚àê f
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Ring) : category_theory.limits.is_limit ((category_theory.forget‚ÇÇ Ring AddCommGroup).map_cone (Ring.limit_cone F))
(a o : ordinal) (f : Œ† (b : ordinal), b < o ‚Üí ordinal) : Prop
{Œ± : Type u_1} [decidable_eq Œ±] [lattice Œ±] [bounded_order Œ±] [is_simple_order Œ±] : boolean_algebra Œ±
(n : ‚Ñï) (R : Type u_1) [comm_ring R] [is_domain R] : (polynomial.cyclotomic' n R).monic
(R : Type u_1) {M : Type u_4} (S : Type u_7) [semiring R] [add_comm_monoid M] [module R M] (s : set M) [semiring S] [has_scalar R S] [module S M] [is_scalar_tower R S M] : submodule.span S ‚Üë(submodule.span R s) = submodule.span S s
{K : Type u_8} {V : Type u_11} [field K] [add_comm_group V] [module K V] {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.is_ortho x x) : is_compl (submodule.span K {x}) ((submodule.span K {x}).orthogonal_bilin B)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (Œ± : F.op ‚âÖ G.op) : G ‚âÖ F
(R : Type u) [comm_semiring R] [local_ring R] : ideal R
(m m' : Type u ‚Üí Type v) (n n' : Type u ‚Üí Type w) : Type (max (u+1) v w)
{R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [topological_space M] [topological_space M‚ÇÇ] [semiring R] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] [add_comm_monoid M] [module R M] (f : M ‚ÜíL[R] M‚ÇÇ) (h : ¬¨‚àÉ (e' : M ‚âÉL[R] M‚ÇÇ), ‚Üëe' = f) : f.inverse = 0
{G : Type u} [group G] [is_free_group G] (H : subgroup G) : is_free_group ‚Ü•H
(Œ± : fin 2 ‚Üí Type u) [Œ† (i : fin 2), uniform_space (Œ± i)] : (Œ† (i : fin 2), Œ± i) ‚âÉ·µ§ Œ± 0 √ó Œ± 1
(p : ‚Ñï) [fact (nat.prime p)] (a : ‚Ñ§) : zmod.legendre_sym p a = zmod.legendre_sym p (a % ‚Üëp)
{Œ± : Type u_1} : list (list Œ±) ‚Üí list (list Œ±)
(R : Type u‚ÇÅ) {L : Type u‚ÇÇ} [comm_ring R] [lie_ring L] [lie_algebra R L] {A : Type u‚ÇÉ} [ring A] [algebra R A] {g‚ÇÅ g‚ÇÇ : universal_enveloping_algebra R L ‚Üí‚Çê[R] A} (h : ‚Üëg‚ÇÅ.comp (universal_enveloping_algebra.Œπ R) = ‚Üëg‚ÇÇ.comp (universal_enveloping_algebra.Œπ R)) : g‚ÇÅ = g‚ÇÇ
(m k : ‚Ñï+) : ‚Ñï+
{ùïú : Type u} [nondiscrete_normed_field ùïú] {f g : ùïú ‚Üí ùïú} {f' a : ùïú} (hg : continuous_at g a) (hf : has_strict_deriv_at f f' (g a)) (hf' : f' ‚â† 0) (hfg : ‚àÄ·∂† (y : ùïú) in nhds a, f (g y) = y) : has_strict_deriv_at g f'‚Åª¬π a
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) [category_theory.limits.has_limit F] : C
 : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Sort v} (s : set Œ±) (f g : Œ† (i : Œ±), Œ≤ i) [Œ† (j : Œ±), decidable (j ‚àà s)] (i : Œ±) : Œ≤ i
(K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1
{R : Type u} [comm_semiring R] {A : Type v‚ÇÅ} [semiring A] [algebra R A] {B : Type v‚ÇÇ} [semiring B] [algebra R B] (a‚ÇÅ : A) (b‚ÇÅ : B) : tensor_product R A B ‚Üí‚Çó[R] tensor_product R A B
(Œ± : Sort u) : Sort (max u 1)
{X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {d‚ÇÅ d‚ÇÇ : ‚Ñù} (h : d‚ÇÅ < d‚ÇÇ) (s : set X) : ‚áë(measure_theory.measure.hausdorff_measure d‚ÇÇ) s = 0 ‚à® ‚áë(measure_theory.measure.hausdorff_measure d‚ÇÅ) s = ‚ä§
{R : Type u_1} {m : Type u_3} {n : Type u_4} {Œ± : Type u_5} [fintype m] [fintype n] [normed_field R] [semi_normed_group Œ±] [normed_space R Œ±] : normed_space R (matrix m n Œ±)
{G : Type u_1} {H : Type u_2} [group H] (f : G ‚Üí H) : set G
(ùïú : Type u_1) {E : Type u_2} {Œπ : Type u_3} [ordered_semiring ùïú] [add_comm_group E] [module ùïú E] (p : Œπ ‚Üí E) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤ ‚Üí Œ±) : Œ± ‚Üí list Œ≤ ‚Üí list Œ±
{R : Type u‚ÇÅ} [linear_ordered_ring R] {a : R} (H : -1 ‚â§ a) (n : ‚Ñï) : 1 + ‚Üën * (a - 1) ‚â§ a ^ n
{Œ± : Sort u_1} (Œ≤ : Œ± ‚Üí Sort u_2) [subsingleton Œ±] (a : Œ±) : (Œ† (a' : Œ±), Œ≤ a') ‚âÉ Œ≤ a
(C : Type u_1) [category_theory.category C] [category_theory.preadditive C] [category_theory.monoidal_category C] : Type
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y : C} (f g : X ‚ü∂ Y) : Prop
{R : Type u_1} [comm_semiring R] : star_ring R
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul G] [has_measurable_inv G] (g : G) : G ‚âÉ·µê G
{Œ± : Type u} {Œ≤ : Type v} [add_zero_class Œ±] [add_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_hom f) : is_add_monoid_hom f
{Œ± : Type u} {Œ≤ : Type v} (r : rel Œ± Œ≤) (l‚ÇÅ : filter Œ±) (l‚ÇÇ : filter Œ≤) : Prop
 : Type (u+1)
 : pos_num ‚Üí pos_num ‚Üí num
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : has_add ‚Ü•S
 : cc_state ‚Üí bool ‚Üí tactic format
{Œ≥ : Type} (local_c : widget.tc widget_override.local_collection Œ≥) (target_c : widget.tc expr Œ≥) : widget.tc widget_override.filter_type Œ≥
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_mem Œ± Œ≤] {s : Œ≤} {a b : Œ±} : a ‚àà s ‚Üí b ‚àâ s ‚Üí a ‚â† b
{Œ± : Type u} [preorder Œ±] {f : ‚Ñï ‚Üí Œ±} (hf : antitone f) (n : ‚Ñï) {x : Œ±} (h1 : f (n + 1) < x) (h2 : x < f n) (a : ‚Ñï) : f a ‚â† x
(C : Type u) [category_theory.category C] [category_theory.limits.has_images C] : Type
{Œ± : Type u_1} [topological_space Œ±] (x : Œ±) : Type u_1
{Œ± : Type u} (p : Œ± ‚Üí Prop) (q : subtype p ‚Üí Prop) : subtype q ‚âÉ {a // ‚àÉ (h : p a), q ‚ü®a, h‚ü©}
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (t : category_theory.limits.binary_bicone X Y) (ht : category_theory.limits.is_limit t.to_cone) : t.is_bilimit
{Œ± : Type u_1} [denumerable Œ±] : denumerable (multiset Œ±)
{G : Type u_1} [add_group G] [topological_space G] {H : Type u_2} [add_group H] [topological_space H] (U : open_add_subgroup G) (V : open_add_subgroup H) : open_add_subgroup (G √ó H)
{C : Type u} [category_theory.category C] (J‚ÇÅ : category_theory.grothendieck_topology C) : category_theory.presieve.is_sheaf J‚ÇÅ (category_theory.functor.closed_sieves J‚ÇÅ)
(p : ‚Ñï) {R : Type u_1} {S : Type u_2} [hp : fact (nat.prime p)] [comm_ring R] [comm_ring S] (f : R ‚Üí+* S) (r : R) : ‚áë(witt_vector.map f) (‚áë(witt_vector.teichmuller p) r) = ‚áë(witt_vector.teichmuller p) (‚áëf r)
(p : tactic.ring_exp.ex tactic.ring_exp.ex_type.base) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.exp)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {N : ‚Ñï} {œÑ : ‚Ñù} (a : besicovitch.satellite_config E N œÑ) : besicovitch.satellite_config E N œÑ
 : expr ‚Üí tactic expr
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p‚ÇÇ : Œπ ‚Üí P) (p‚ÇÅ : P) (h : s.sum (Œª (i : Œπ), w i) = 1) : s.sum (Œª (i : Œπ), w i ‚Ä¢ (p‚ÇÅ -·µ• p‚ÇÇ i)) = p‚ÇÅ -·µ• ‚áë(s.affine_combination p‚ÇÇ) w
(ùïú : Type u_1) {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_3} [linear_order Œπ] [order_bot Œπ] [locally_finite_order Œπ] [is_well_order Œπ has_lt.lt] (f : Œπ ‚Üí E) : Œπ ‚Üí E
{r n : ‚Ñï} (h : r < n / 2) : n.choose r ‚â§ n.choose (r + 1)
{R : Type u} [ring R] (p : polynomial R) (T : subring R) (hp : ‚Üë(p.frange) ‚äÜ ‚ÜëT) : polynomial ‚Ü•T
(k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} [nontrivial k] {p1 : P} {p : Œπ ‚Üí P} : p1 ‚àà affine_span k (set.range p) ‚Üî ‚àÉ (s : finset Œπ) (w : Œπ ‚Üí k) (hw : s.sum (Œª (i : Œπ), w i) = 1), p1 = ‚áë(s.affine_combination p) w
{C : Type u_1} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [category_theory.limits.has_pushout f g] [category_theory.limits.has_binary_coproduct Y Z] : category_theory.epi (category_theory.limits.coprod.desc category_theory.limits.pushout.inl category_theory.limits.pushout.inr)
 : tactic.itauto.proof ‚Üí name ‚Üí tactic.itauto.proof ‚Üí tactic.itauto.proof ‚Üí tactic.itauto.proof
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {f : E ‚Üí F} {x : E} {n : with_top ‚Ñï} (g : F ‚ÜíL[ùïú] G) (hf : cont_diff_at ùïú n f x) : cont_diff_at ùïú n (‚áëg ‚àò f) x
{C : Type u} [category_theory.category C] (X : algebraic_geometry.PresheafedSpace C) : X.hom X
{M : Type u_1} [has_add M] {N : Type u_2} [has_add N] (f : add_hom M N) : add_hom M ‚Ü•(f.srange)
{Œ± : Type u_2} (l : set (set Œ±)) (hp : ‚àÄ (S : set (set Œ±)), S.countable ‚Üí S ‚äÜ l ‚Üí ‚ãÇ‚ÇÄ S ‚àà l) (h_mono : ‚àÄ (s t : set Œ±), s ‚àà l ‚Üí s ‚äÜ t ‚Üí t ‚àà l) : filter Œ±
{Œ± : Type u_1} [decidable_eq Œ±] {s t : finset Œ±} (h : s ‚äÜ t) : (finset.Ioo s t).card = 2 ^ (t.card - s.card) - 2
{V : Type u} {G : simple_graph V} (d : G.dart) : sym2 V
{C : Type u} [category_theory.category C] (G : C) : Prop
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] {i j : Œπ} (w : free_product.neword M i j) : M j
{d : ‚Ñ§} : has_neg (‚Ñ§‚àöd)
{R : Type u_3} [comm_semiring R] {R‚ÇÇ : Type u_4} [comm_semiring R‚ÇÇ] {R‚ÇÉ : Type u_5} [comm_semiring R‚ÇÉ] {R‚ÇÑ : Type u_6} [comm_semiring R‚ÇÑ] {M : Type u_7} {N : Type u_8} {P : Type u_9} {Q : Type u_10} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [add_comm_monoid Q] [module R M] [module R‚ÇÇ N] [module R‚ÇÉ P] [module R‚ÇÑ Q] {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : R ‚Üí+* R‚ÇÉ} {œÉ‚ÇÑ‚ÇÇ : R‚ÇÑ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÑ‚ÇÉ : R‚ÇÑ ‚Üí+* R‚ÇÉ} [ring_hom_comp_triple œÉ‚ÇÑ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÑ‚ÇÉ] (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÉ] N ‚Üí‚Çõ‚Çó[œÉ‚ÇÇ‚ÇÉ] P) (g : Q ‚Üí‚Çõ‚Çó[œÉ‚ÇÑ‚ÇÇ] N) : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÉ] Q ‚Üí‚Çõ‚Çó[œÉ‚ÇÑ‚ÇÉ] P
{R : Type u} [ring R] [rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Œπ : Type u_1} [fintype Œπ] (b : basis Œπ R M) {w : set M} [fintype ‚Ü•w] (s : submodule.span R w = ‚ä§) : fintype.card Œπ ‚â§ fintype.card ‚Ü•w
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {f : E ‚Üí G} (hf : cont_diff ùïú n f) : cont_diff ùïú n (Œª (x : E √ó F), f x.fst)
{K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} : (generalized_continued_fraction.int_fract_pair.seq1 v).fst = generalized_continued_fraction.int_fract_pair.of v
{Œ± : Type u_1} [decidable_eq Œ±] (s : finset Œ±) : (finset.image quotient.mk s.diag).card = s.card
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {n : ‚Ñï} : iterated_fderiv_within ùïú (n + 1) f s = ‚áë(continuous_multilinear_curry_left_equiv ùïú (Œª (i : fin (n + 1)), E) F) ‚àò fderiv_within ùïú (iterated_fderiv_within ùïú n f s) s
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] {Œ¥ : Type u_1} [topological_space Œ¥] (f : bounded_continuous_function Œ± Œ≤) (g : C(Œ¥, Œ±)) : bounded_continuous_function Œ¥ Œ≤
(k : Type u) [field k] (n : ‚Ñï) : Œ£ (Œ± : Type u), field Œ±
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b c : Œ±} : a < c - b ‚Üí a + b < c
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {S : submodule K V} (h : finite_dimensional.finrank K ‚Ü•S = finite_dimensional.finrank K V) : S = ‚ä§
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [has_one M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñï] [cancel_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) : cancel_monoid M‚ÇÅ
(p : omega.nat.preform) : list omega.clause
 : ‚Ü•({‚ä•, ‚ä§}.compl) ‚âÉ·µê ‚Ñù
(hs : name_set) (d : declaration) : option tactic.suggest.decl_data
(Œ± : Type u_1) [monoid Œ±] : setoid Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (P : C·µí·µñ ‚•§ Type w) : category_theory.presieve.is_sheaf_for P ‚áë‚ä§
{Œ± : Type uu} (a : Œ±) {l‚ÇÅ l‚ÇÇ : list Œ±} : l‚ÇÅ <+~ l‚ÇÇ ‚Üí a :: l‚ÇÅ <+~ a :: l‚ÇÇ
{Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] [nonempty Œπ] {f : Œπ ‚Üí Œ±} {c : Œ±} (H : ‚àÄ (x : Œπ), c ‚â§ f x) : c ‚â§ infi f
{M : Type u_1} [monoid M] (x : M) : set M
(Œ± : Type u) [topological_space Œ±] : Prop
{M : Type u_4} [topological_space M] [add_monoid M] [has_continuous_add M] (s : add_submonoid M) : add_submonoid M
(K : Type u) [hring : comm_ring K] : Type u
{V : Type u} {G : simple_graph V} (x y : G.subgraph) : Prop
{K : Type u} [field K] (s : subfield K) : submonoid K
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (hF : category_theory.is_equivalence F) : category_theory.is_equivalence.of_iso (category_theory.iso.refl F) hF = hF
{ùïú : Type u_1} {V : Type u_2} {V‚ÇÇ : Type u_4} {P : Type u_8} {P‚ÇÇ : Type u_9} [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V P] [normed_add_torsor V‚ÇÇ P‚ÇÇ] (e : P ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÇ) : P ‚âÉ·µ¢ P‚ÇÇ
(k G : Type u) [ring k] [monoid G] : Type (u+1)
(v : multiset ‚Ñï) (h : ‚àÄ (p : ‚Ñï), p ‚àà v ‚Üí nat.prime p) : prime_multiset
(ùïú : Type u_1) {E : Type u_4} (F‚Çó : Type u_7) [semi_normed_group E] [semi_normed_group F‚Çó] [nondiscrete_normed_field ùïú] [normed_space ùïú E] [normed_space ùïú F‚Çó] : E ‚ÜíL[ùïú] (E ‚ÜíL[ùïú] F‚Çó) ‚ÜíL[ùïú] F‚Çó
{Œ± : Type u_1} : has_star.star 1 = 1
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : submodule R M
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type v} (f : J ‚Üí C) [category_theory.limits.has_coproduct f] [category_theory.limits.preserves_colimit (category_theory.discrete.functor f) G] : category_theory.limits.is_colimit (category_theory.limits.cofan.mk (G.obj (‚àê f)) (Œª (j : J), G.map (category_theory.limits.sigma.Œπ f j)))
(Œ± : Type u_2) [topological_space Œ±] [preorder Œ±] : Œ± ‚ÜíCo Œ±
{M : Type u_6} {N : Type u_7} {P : Type u_8} [has_add M] [has_add N] [has_add P] (h1 : M ‚âÉ+ N) (h2 : N ‚âÉ+ P) : M ‚âÉ+ P
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {j j' : C} (f f' : j ‚ü∂ j') : category_theory.is_cofiltered.eq_hom f f' ‚â´ f = category_theory.is_cofiltered.eq_hom f f' ‚â´ f'
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} : {f // disjoint (set.range ‚áë(f.fst)) (set.range ‚áë(f.snd))} ‚âÉ Œ£ (f : Œ± ‚Ü™ Œ≥), Œ≤ ‚Ü™ ‚Ü•(set.range ‚áëf)·∂ú
{X : Type u_1} (x : X) : free_abelian_group X ‚Üí+ ‚Ñ§
(Œ± : Type u_2) [linear_ordered_ring Œ±] : Type u_2
{M : Type u_1} [has_mul M] : has_top (subsemigroup M)
{p x : ‚Ñù} {r : ‚Ñö} (hr : r ‚â† 0) : liouville_with p (x * ‚Üër) ‚Üî liouville_with p x
{Œ± : Type u_1} [has_to_tactic_format Œ±] (s : Œ±) : tactic unit
{R‚ÇÅ : Type u_1} [semiring R‚ÇÅ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] {M‚ÇÉ : Type u_7} [topological_space M‚ÇÉ] [add_comm_monoid M‚ÇÉ] {M‚ÇÑ : Type u_8} [topological_space M‚ÇÑ] [add_comm_monoid M‚ÇÑ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] [module R‚ÇÅ M‚ÇÑ] (f‚ÇÅ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ) (f‚ÇÇ : M‚ÇÉ ‚ÜíL[R‚ÇÅ] M‚ÇÑ) : M‚ÇÅ √ó M‚ÇÉ ‚ÜíL[R‚ÇÅ] M‚ÇÇ √ó M‚ÇÑ
(R : Type u) [comm_ring R] (U : topological_space.opens ‚Ü•(algebraic_geometry.prime_spectrum.Top R)) : CommRing.of R ‚ü∂ (algebraic_geometry.Spec.structure_sheaf R).val.obj (opposite.op U)
 : onote ‚Üí ‚Ñï ‚Üí onote
 : Set ‚Üí Set
(n p : ‚Ñï) (l : list ‚Ñï) : Prop
{Œ± : Type} (p : parser Œ±) (input : char_buffer) : string ‚äï Œ±
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) {s‚ÇÅ s‚ÇÇ : finset Œπ} (h : s‚ÇÅ ‚äÜ s‚ÇÇ) : ‚áë(s‚ÇÅ.affine_combination p) w = ‚áë(s‚ÇÇ.affine_combination p) (‚Üës‚ÇÅ.indicator w)
{R‚ÇÅ : Type u_3} {A : Type u_5} {B : Type u_6} [comm_semiring R‚ÇÅ] [comm_ring A] [comm_ring B] [algebra R‚ÇÅ A] [algebra R‚ÇÅ B] (f : A ‚Üí‚Çê[R‚ÇÅ] B) : function.injective ‚áë(ideal.ker_lift_alg f)
(J : Type v) (X Y : category_theory.limits.wide_pushout_shape J) : (X ‚ü∂ Y) ‚Üí (opposite.op X ‚ü∂ opposite.op Y)
(hs : expr_set) : tactic ‚Ñï
{n : ‚Ñï} (P : mvpfunctor (n + 1)) (Œ± : typevec n) : Type u
{L : first_order.language} {M : Type u_3} [L.Structure M] : first_order.language.Structure.fg L M ‚Üî ‚àÉ (S : set M), S.finite ‚àß ‚áë(first_order.language.substructure.closure L) S = ‚ä§
(Œ± : Type u_1) [partial_order Œ±] : closure_operator Œ±
(Œ± : Type u_1) [has_le Œ±] : has_btw Œ±
{Œ± : Type u_1} [comm_semiring Œ±] (E : linear_recurrence Œ±) (u v : ‚Ñï ‚Üí Œ±) (hu : E.is_solution u) (hv : E.is_solution v) : u = v ‚Üî set.eq_on u v ‚Üë(finset.range E.order)
{n : ‚Ñï} {M : Type u_1} [has_zero M] (y : M) (s : fin n ‚Üí‚ÇÄ M) : fin (n + 1) ‚Üí‚ÇÄ M
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (b : category_theory.limits.bicone (category_theory.limits.pair_function X Y)) : category_theory.limits.is_limit b.to_binary_bicone.to_cone ‚âÉ category_theory.limits.is_limit b.to_cone
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] (f : A ‚Üí+* B) (h : ‚àÄ (c : R) (x : A), ‚áëf (c ‚Ä¢ x) = c ‚Ä¢ ‚áëf x) : A ‚Üí‚Çê[R] B
 : filter.tendsto real.exp filter.at_top filter.at_top
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f f‚ÇÅ : E ‚Üí F} {x : E} {n : ‚Ñï} (hs : unique_diff_on ùïú s) (hL : ‚àÄ (y : E), y ‚àà s ‚Üí f‚ÇÅ y = f y) (hx : x ‚àà s) : iterated_fderiv_within ùïú n f‚ÇÅ s x = iterated_fderiv_within ùïú n f s x
{Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] [has_continuous_add Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : upper_semicontinuous_on f s) (hg : upper_semicontinuous_on g s) : upper_semicontinuous_on (Œª (z : Œ±), f z + g z) s
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (hi : irreflexive r) {a : Œ±} (hacc : acc r a) : acc (relation.cut_expand r) {a}
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} (e : topological_fiber_bundle.pretrivialization F proj) : ‚Ü•(e.to_local_equiv.target) ‚Üí Z
{C : Type u} [category_theory.category C] {X Y Z : C} {sXY : category_theory.limits.binary_fan X Y} (P : category_theory.limits.is_limit sXY) {sYZ : category_theory.limits.binary_fan Y Z} (Q : category_theory.limits.is_limit sYZ) {s : category_theory.limits.binary_fan sXY.X Z} (R : category_theory.limits.is_limit s) : category_theory.limits.is_limit (category_theory.limits.binary_fan.assoc Q s)
(h : name) (t v : expr) : tactic expr
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (f : Œ± ‚Üí. Œ≤) (g : Œ≤ ‚Üí Œ± ‚Üí. Œ≥) : Œ± ‚Üí. Œ≥
{n : ‚Ñï+} (K : Type u_1) [field K] {L : Type u_2} [field L] [algebra K L] [is_cyclotomic_extension {n} K L] [ne_zero ‚Üë‚Üën] : comm_group (L ‚âÉ‚Çê[K] L)
{Œ± : Type u_1} (l : list Œ±) : list (multiset Œ±)
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) {A : Type u_3} [semiring A] [algebra R A] : {f // ‚àÄ (m : M), ‚áëf m * ‚áëf m = ‚áë(algebra_map R A) (‚áëQ m)} ‚âÉ (clifford_algebra Q ‚Üí‚Çê[R] A)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p ‚àà s) : affine_subspace.mk' p s.direction = s
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_lie_abelian L] : lie_algebra.lie_character R L ‚âÉ module.dual R L
{Œ± : Type u} {Œ≤ : Type v} [has_mul Œ±] [has_distrib_neg Œ±] [has_neg Œ≤] [has_mul Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (neg : ‚àÄ (a : Œ≤), f (-a) = -f a) (mul : ‚àÄ (a b : Œ≤), f (a * b) = f a * f b) : has_distrib_neg Œ≤
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} [category_theory.limits.has_zero_object V] [category_theory.limits.has_kernels V] [category_theory.limits.has_images V] (C : homological_complex V c) (i : Œπ) (h : C.boundaries i ‚â§ C.cycles i) : (C.boundaries i).of_le (C.cycles i) h = C.boundaries_to_cycles i
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S : set E) : intermediate_field F E
(R : Type u_1) {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (w : set M) (x : ‚Ü•(submodule.span R w)) : ‚Ü•w ‚Üí‚ÇÄ R
{Œ± : Type u} [monoid Œ±] (a b : Œ±) [invertible a] [invertible b] : invertible (a * b)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) {R‚ÇÇ : Type u_3} {M‚ÇÇ : Type u_4} [ring R‚ÇÇ] [add_comm_group M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} (f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ) (h : p ‚â§ f.ker) : M ‚ß∏ p ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ
{m n : ‚Ñï} : fin (m + n) ‚âÉ fin (n + m)
{Œ± : Type u} {R : Œ± ‚Üí Œ± ‚Üí Prop} {l‚ÇÅ l‚ÇÇ l‚ÇÉ : list Œ±} (h‚ÇÅ : list.chain' R (l‚ÇÅ ++ l‚ÇÇ)) (h‚ÇÇ : list.chain' R (l‚ÇÇ ++ l‚ÇÉ)) (hn : l‚ÇÇ ‚â† list.nil) : list.chain' R (l‚ÇÅ ++ l‚ÇÇ ++ l‚ÇÉ)
{M : Type u_1} [add_comm_group M] [module ‚ÑÇ M] [finite_dimensional ‚ÑÇ M] (Q : quadratic_form ‚ÑÇ M) (hQ : (‚áëquadratic_form.associated Q).nondegenerate) : Q.equivalent (quadratic_form.weighted_sum_squares ‚ÑÇ 1)
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) (x y : Œ±) : Prop
{Œ± : Sort u_1} (x : fin 0) : Œ±
(Œ± : Type u_1) : Type u_1
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] (f : S.localization_map N) (x : M) (y : ‚Ü•S) : ‚àÉ (c : ‚Ü•S), x + ‚Üë((f.sec (f.mk' x y)).snd) + ‚Üëc = (f.sec (f.mk' x y)).fst + ‚Üëy + ‚Üëc
 : list (tactic expr)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) (i : fin (n + 1)) : s.points i = ‚áë(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.point_weights_with_circumcenter i)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (v : V) (h : ‚àÄ (w : V), ‚àÉ (c : K), c ‚Ä¢ v = w) : finite_dimensional.finrank K V ‚â§ 1
{R : Type u} {M : Type v} {M‚ÇÇ : Type w} {M‚ÇÉ : Type y} {M‚ÇÑ : Type z} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [add_comm_monoid M‚ÇÑ] [module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] [module R M‚ÇÑ] (f : M ‚Üí‚Çó[R] M‚ÇÉ) (g : M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÑ) : M √ó M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÉ √ó M‚ÇÑ
(n : interactive.parse lean.parser.small_nat) (q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) : tactic unit
{P : Type u_1} [preorder P] : has_mem P (order.pfilter P)
{R : Type u_1} {M : Type u_2} {Œπ : Type u_5} [comm_ring R] [add_comm_group M] [module R M] [decidable_eq Œπ] (b : basis Œπ R M) [fintype Œπ] : M ‚âÉ‚Çó[R] module.dual R M
(R : Type u) (S : Type v) [semiring R] [semiring S] (p : ‚Ñï) [char_p R p] [char_p S p] : char_p (R √ó S) p
{Œ≤ : Type u} {Œ± : Type v} {s : finset Œ±} {a : Œ±} {f : Œ± ‚Üí Œ≤} [comm_monoid Œ≤] [decidable_eq Œ±] (h : a ‚àâ s ‚Üí f a = 1) : (has_insert.insert a s).prod (Œª (x : Œ±), f x) = s.prod (Œª (x : Œ±), f x)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} (h : ‚Üës.nonempty) : submodule k V
 : Type 1
(J : Type u‚ÇÅ) [category_theory.category J] : category_theory.bicone J ‚Üí category_theory.bicone J ‚Üí Type (max u‚ÇÅ v‚ÇÅ)
{V : Type u} (G : simple_graph V) {Œ± : Type v} [is_empty V] : G.coloring Œ±
{Œ± : Type u_2} [add_semigroup Œ±] : add_semigroup (set Œ±)
 : list omega.term ‚Üí ‚Ñï
(Œπ : Type u_1) {R : Type u_2} {Œ± : Type u_3} [add_monoid Œπ] [monoid R] (l : list Œ±) (fŒπ : Œ± ‚Üí Œπ) (fA : Œ± ‚Üí R) : l.dprod fŒπ fA = (list.map fA l).prod
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_type R A ‚Üî ‚àÉ (Œπ : Type u_2) (_x : fintype Œπ) (f : mv_polynomial Œπ R ‚Üí‚Çê[R] A), function.surjective ‚áëf
{Œ± : Type u_1} [topological_space Œ±] [locally_compact_space Œ±] [nonempty Œ±] : nonempty (topological_space.positive_compacts Œ±)
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚âÉ‚Çú M‚ÇÇ
(l : list expr) : tactic (native.rb_lmap expr expr)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_finite_limits C] (F : C ‚•§ D) : category_theory.representably_flat F ‚âÉ category_theory.limits.preserves_finite_limits F
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : closed_embedding f) {K : set Œ≤} (hK : is_compact K) : is_compact (f ‚Åª¬π' K)
{M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_3} [mul_zero_one_class M‚ÇÄ] [nontrivial M‚ÇÄ] [has_zero M‚ÇÄ'] [has_one M‚ÇÄ'] (f : M‚ÇÄ' ‚Üí M‚ÇÄ) (zero : f 0 = 0) (one : f 1 = 1) : nontrivial M‚ÇÄ'
{Œ± : Type u_2} {G‚ÇÄ : Type u_4} [topological_space Œ±] [group_with_zero G‚ÇÄ] [mul_action G‚ÇÄ Œ±] [has_continuous_const_smul G‚ÇÄ Œ±] {c : G‚ÇÄ} (hc : c ‚â† 0) : is_closed_map (Œª (x : Œ±), c ‚Ä¢ x)
 : Type
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) : category_theory.limits.is_limit (AddMon.has_limits.limit_cone F)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} {s : affine.simplex ‚Ñù P n} {p p‚ÇÅ p‚ÇÇ : P} {r : ‚Ñù} (hp‚ÇÅ : p‚ÇÅ ‚àà affine_span ‚Ñù (has_insert.insert p (set.range s.points))) (hp‚ÇÇ : p‚ÇÇ ‚àà affine_span ‚Ñù (has_insert.insert p (set.range s.points))) (h‚ÇÅ : ‚àÄ (i : fin (n + 1)), has_dist.dist (s.points i) p‚ÇÅ = r) (h‚ÇÇ : ‚àÄ (i : fin (n + 1)), has_dist.dist (s.points i) p‚ÇÇ = r) : p‚ÇÅ = p‚ÇÇ ‚à® p‚ÇÅ = ‚áë(euclidean_geometry.reflection (affine_span ‚Ñù (set.range s.points))) p‚ÇÇ
{C : Type u} [category_theory.category C] {X : C} (hX : category_theory.limits.is_zero X) : category_theory.limits.is_initial X
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {Œπ : Type u_2} {E : Œπ ‚Üí Type u_5} [decidable_eq Œπ] [fintype Œπ] [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] : is_bounded_bilinear_map ùïú (Œª (p : (F ‚ÜíL[ùïú] G) √ó continuous_multilinear_map ùïú E F), p.fst.comp_continuous_multilinear_map p.snd)
 : tactic unit
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} {ps : set P} (h : ps ‚äÜ ‚Üës) [nonempty ‚Ü•s] [finite_dimensional ‚Ñù ‚Ü•(s.direction)] : euclidean_geometry.cospherical ps ‚Üî ‚àÉ (center : P) (H : center ‚àà s) (radius : ‚Ñù), ‚àÄ (p : P), p ‚àà ps ‚Üí has_dist.dist p center = radius
{Œ± : Type u_2} [comm_monoid Œ±] : multiset Œ± ‚Üí Œ±
{Œ± : Type u} {Œ≤ : Type v} (xs : list (Œ± √ó Œ≤)) : list (Œ£ (_x : Œ±), Œ≤)
(Œ± : Type v) [small Œ±] : Œ± ‚âÉ shrink Œ±
{R : Type u_1} [linear_ordered_field R] [floor_ring R] (b : ‚Ñï) (r : R) : ‚Ñ§
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí filter Œ≤} (F : Œ† (i : Œ±), (f i).realizer) : (‚®Ü (i : Œ±), f i).realizer
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [is_R_or_C ùïÇ] [normed_comm_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] {x : ùî∏} : has_fderiv_at (exp ùïÇ) (exp ùïÇ x ‚Ä¢ 1) x
{Œ≤ : Type u_4} [linear_order Œ≤] [no_min_order Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : filter.tendsto u filter.at_top filter.at_bot) : ‚àÉ·∂† (n : ‚Ñï) in filter.at_top, ‚àÄ (k : ‚Ñï), k < n ‚Üí u n < u k
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), has_lt (Œ± i)] (a b : Œ£ (i : Œπ), Œ± i) : Prop
{m : Type u} {Œ± : Type v} [comm_ring Œ±] [fintype m] [decidable_eq m] {M : matrix m m Œ±} (h : is_unit M) (N : matrix m m Œ±) : ((M.mul N).mul M‚Åª¬π).det = N.det
(type : expr) : tactic ‚Ñï
{Œ± : Type u_1} [semigroup Œ±] [partial_order Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] [contravariant_class Œ± Œ± has_mul.mul has_le.le] [contravariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] {a b c d : Œ±} (hac : a ‚â§ c) (hbd : b ‚â§ d) : a * b = c * d ‚Üî a = c ‚àß b = d
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Type (max u_2 u_1)
{M : Type u_1} [has_mul M] {c d : con M} : setoid.r = setoid.r ‚äì setoid.r
{A : Type u_1} [ring A] [algebra ‚Ñù A] (I' : A) (hf : I' * I' = -1) : ‚ÑÇ ‚Üí‚Çê[‚Ñù] A
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {n : ‚Ñï} : cont_diff_on ùïú ‚Üë(n + 1) f s ‚Üî ‚àÄ (x : E), x ‚àà s ‚Üí (‚àÉ (u : set E) (H : u ‚àà nhds_within x (has_insert.insert x s)) (f' : E ‚Üí (E ‚ÜíL[ùïú] F)), (‚àÄ (x : E), x ‚àà u ‚Üí has_fderiv_within_at f (f' x) u x) ‚àß cont_diff_on ùïú ‚Üën f' u)
(Œ± : Type u_1) (Œ≤ : Type u_2) (V : set (Œ≤ √ó Œ≤)) : set ((Œ± ‚Üí Œ≤) √ó (Œ± ‚Üí Œ≤))
 : ennreal ‚âÉo ennreal·µí·µà
{Œ≥ : Type u_1} {Œ≤ : Type u_2} (f : Œ≥ ‚Üí Œ≤) (hf : function.injective f) (m : emetric_space Œ≤) : emetric_space Œ≥
 : omega.nat.preform ‚Üí tactic expr
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] : set (subgroup (L ‚âÉ‚Çê[K] L))
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {a‚ÇÅ a‚ÇÇ : X} {b‚ÇÅ b‚ÇÇ : Y} (Œ≥‚ÇÅ : path a‚ÇÅ a‚ÇÇ) (Œ≥‚ÇÇ : path b‚ÇÅ b‚ÇÇ) : path (a‚ÇÅ, b‚ÇÅ) (a‚ÇÇ, b‚ÇÇ)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {s : set E} : mdifferentiable_on (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f s ‚Üí differentiable_on ùïú f s
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] (xs : list Œ±) (h : ‚àÄ (x : Œ±), x ‚àà xs ‚Üí ¬¨p x) (sep : Œ±) (hsep : p sep) (as : list Œ±) : list.split_on_p p (xs ++ sep :: as) = xs :: list.split_on_p p as
(h : option name) (p : pexpr) (pat : tactic.rcases_patt) : tactic unit
{Œ± : Type u_1} [comm_monoid Œ±] {a b : Œ±} {u : Œ±À£} : a ‚à£ ‚Üëu * b ‚Üî a ‚à£ b
{Œ± : Type u_1} [circular_preorder Œ±] {a b c : Œ±} (h : has_sbtw.sbtw a b c) : has_btw.btw a b c
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.creates_limits_of_size F] : category_theory.creates_limits_of_size G
{ùïú : Type u} {G : Type wG} {G' : Type wG'} [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] {k n : ‚Ñï} (f : continuous_multilinear_map ùïú (Œª (i : fin n), G) G') (s : finset (fin n)) (hk : s.card = k) (z : G) : continuous_multilinear_map ùïú (Œª (i : fin k), G) G'
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : locally_constant X Y) : C(X, Y)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) : s.circumcenter = ‚áë(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.circumcenter_weights_with_circumcenter n)
{F : Type u_1} [field F] {K‚ÇÅ : Type u_3} {K‚ÇÇ : Type u_4} [field K‚ÇÅ] [field K‚ÇÇ] [algebra F K‚ÇÅ] [algebra F K‚ÇÇ] (œï : K‚ÇÅ ‚Üí‚Çê[F] K‚ÇÇ) (E : Type u_6) [field E] [algebra F E] [algebra E K‚ÇÅ] [algebra E K‚ÇÇ] [is_scalar_tower F E K‚ÇÅ] [is_scalar_tower F E K‚ÇÇ] [normal F E] : E ‚Üí‚Çê[F] E
(R : Type u_1) {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_noetherian_ring R] {A : set M} (hA : A.finite) : is_noetherian R ‚Ü•(submodule.span R A)
{Œ± : Type u_1} [preorder Œ±] {a b : Œ±} (h : a ‚â§ b) : set.Ioi b ‚äÜ set.Ici a
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set Œ±) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), 0)) = 0
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [nondiscrete_normed_field ùïÇ] [normed_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] (h : 0 < (exp_series ùïÇ ùî∏).radius) : has_strict_fderiv_at (exp ùïÇ) 1 0
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [comm_monoid Œ≤] {s : finset Œ±} {t : finset Œ≥} {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ≤} (i : Œ† (a : Œ±), a ‚àà s ‚Üí Œ≥) (hi : ‚àÄ (a : Œ±) (ha : a ‚àà s), i a ha ‚àà t) (h : ‚àÄ (a : Œ±) (ha : a ‚àà s), f a = g (i a ha)) (i_inj : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±) (ha‚ÇÅ : a‚ÇÅ ‚àà s) (ha‚ÇÇ : a‚ÇÇ ‚àà s), i a‚ÇÅ ha‚ÇÅ = i a‚ÇÇ ha‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ) (i_surj : ‚àÄ (b : Œ≥), b ‚àà t ‚Üí (‚àÉ (a : Œ±) (ha : a ‚àà s), b = i a ha)) : s.prod (Œª (x : Œ±), f x) = t.prod (Œª (x : Œ≥), g x)
(G : Type u) : Type u
{V : Type u} {G : simple_graph V} {u : V} (p : G.walk u u) : Prop
{ùïú : Type u} {Œπ : Type v} {E : Œπ ‚Üí Type wE} {G : Type wG} {G' : Type wG'} [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] (f : G ‚ÜíL[ùïú] continuous_multilinear_map ùïú E G') : continuous_multilinear_map ùïú E (G ‚ÜíL[ùïú] G')
{B : Type u} [quiver B] (a b : category_theory.free_bicategory B) : ùü≠ (a ‚ü∂ b) ‚âÖ (category_theory.free_bicategory.normalize B).map_functor a b ‚ãô category_theory.free_bicategory.inclusion_path a b
(X : algebraic_geometry.LocallyRingedSpace) (r : ‚Ü•(algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X))) : is_unit (‚áë(X.to_to_Œì_Spec_map_basic_open r) r)
{R : Type u} [euclidean_domain R] [decidable_eq R] : R ‚Üí R ‚Üí R ‚Üí R ‚Üí R ‚Üí R ‚Üí R √ó R √ó R
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {f : M ‚Üí+ P} (x : M) : ‚áë(add_con.ker_lift f) ‚Üëx = ‚áëf x
{n : Type u_1} {p : Type u_2} {ùïú : Type u_3} [field ùïú] [decidable_eq n] [decidable_eq p] [fintype n] [fintype p] (M : matrix p p ùïú) (e : p ‚âÉ n) (H : ‚àÉ (L L' : list (matrix.transvection_struct n ùïú)) (D : n ‚Üí ùïú), ((list.map matrix.transvection_struct.to_matrix L).prod.mul (‚áë(matrix.reindex_alg_equiv ùïú e) M)).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D) : ‚àÉ (L L' : list (matrix.transvection_struct p ùïú)) (D : p ‚Üí ùïú), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
{Œ± : Type u_1} [has_to_format Œ±] (msg : thunk Œ±) : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [has_zero M] (f : Œ± ‚Ü™ Œ≤) (v : Œ± ‚Üí‚ÇÄ M) : Œ≤ ‚Üí‚ÇÄ M
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (e : M ‚âÉ* N) (S : subsemigroup M) : ‚Ü•S ‚âÉ* ‚Ü•(subsemigroup.map e.to_mul_hom S)
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] [has_add Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
 : algebraic_geometry.Scheme
{M : Type u_1} [comm_monoid M] (S : submonoid M) : con (M √ó ‚Ü•S)
{C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} (f : X ‚ü∂ Y) [category_theory.is_iso f.base] [category_theory.is_iso f.c] : category_theory.is_iso f
{Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚ÜíCO Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : Œ± ‚ÜíCO Œ≤
(f : stieltjes_function) {a b : ‚Ñù} {c d : ‚Ñï ‚Üí ‚Ñù} (ss : set.Icc a b ‚äÜ ‚ãÉ (i : ‚Ñï), set.Ioo (c i) (d i)) : ennreal.of_real (‚áëf b - ‚áëf a) ‚â§ ‚àë' (i : ‚Ñï), ennreal.of_real (‚áëf (d i) - ‚áëf (c i))
(F : Type u_1) [field F] [fintype F] {a : F} (ha : a ‚â† 0) : ‚àÉ (b : F), ‚áë(algebra.trace (zmod (ring_char F)) F) (a * b) ‚â† 0
{R : Type u} [ordered_comm_ring R] [star_ordered_ring R] [algebra ‚Ñù R] [ordered_smul ‚Ñù R] (A‚ÇÄ A‚ÇÅ B‚ÇÄ B‚ÇÅ : R) (T : is_CHSH_tuple A‚ÇÄ A‚ÇÅ B‚ÇÄ B‚ÇÅ) : A‚ÇÄ * B‚ÇÄ + A‚ÇÄ * B‚ÇÅ + A‚ÇÅ * B‚ÇÄ - A‚ÇÅ * B‚ÇÅ ‚â§ 2
{Œ± : Type u_1} [decidable_eq Œ±] (s t : multiset Œ±) : multiset Œ±
(c : tactic.instance_cache) : expr ‚Üí tactic (tactic.instance_cache √ó expr)
{C : Type u} [category_theory.category C] {R X Y Z : C} {a b : R ‚ü∂ X} {f‚ÇÅ : X ‚ü∂ Y} {f‚ÇÇ : Y ‚ü∂ Z} [category_theory.mono f‚ÇÇ] (small_k : category_theory.is_kernel_pair f‚ÇÅ a b) : category_theory.is_kernel_pair (f‚ÇÅ ‚â´ f‚ÇÇ) a b
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : is_irreducible s ‚Üî ‚àÄ (U : finset (set Œ±)), (‚àÄ (u : set Œ±), u ‚àà U ‚Üí is_open u) ‚Üí (‚àÄ (u : set Œ±), u ‚àà U ‚Üí (s ‚à© u).nonempty) ‚Üí (s ‚à© ‚ãÇ‚ÇÄ ‚ÜëU).nonempty
{S : Type u_5} [semiring S] {M : Type u_6} [add_comm_monoid M] [module S M] (m : submodule S M) {F : Type u_7} [fun_like F M (Œª (_x : M), M)] (f : F) : Prop
(cl : tactic.closure) (e‚ÇÄ e‚ÇÅ : expr) : tactic expr
{X Y : Type u} [add_monoid X] [add_monoid Y] (e : X ‚âÉ+ Y) : AddMon.of X ‚âÖ AddMon.of Y
{G : Type u} {x : G} [fintype G] [group G] [decidable_eq G] : finset.image (Œª (i : ‚Ñï), x ^ i) (finset.range (order_of x)) = ‚Üë(subgroup.zpowers x).to_finset
{M : Type u_1} [add_zero_class M] {s : set M} {p : M ‚Üí Prop} {x : M} (h : x ‚àà add_submonoid.closure s) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí p x) (H1 : p 0) (Hmul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x + y)) : p x
{Œ± : Type uu} : list Œ± ‚Üí list Œ± ‚Üí Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] : CommMon_ (C ‚•§ D) ‚•§ C ‚•§ CommMon_ D
{Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x y : Œ±} {n : ‚Ñï} (hx : function.is_periodic_pt f n x) (hy : function.is_periodic_pt f n y) (hn : 0 < n) (h : f x = f y) : x = y
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_coproducts C] : (category_theory.coprod_monad X).algebra ‚•§ category_theory.under X
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] : V ‚•§ cochain_complex V ‚Ñï
(G : Type u_1) [comm_group G] : comm_monoid.torsion G = (torsion G).to_submonoid
(Œ± : Type u_1) [complete_lattice Œ±] : complete_lattice.is_sup_closed_compact Œ± ‚Üí complete_lattice.is_Sup_finite_compact Œ±
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] : list Œ± ‚Üí ‚Ñï
{Œ± : Type u} {Œ≤ : Type v} [comm_monoid Œ≤] (s : finset Œ±) (f : finset Œ± ‚Üí Œ≤) : s.powerset.prod (Œª (t : finset Œ±), f t) = (finset.range (s.card + 1)).prod (Œª (j : ‚Ñï), (finset.powerset_len j s).prod (Œª (t : finset Œ±), f t))
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [monoid Y] [has_continuous_mul Y] : locally_constant X Y ‚Üí* C(X, Y)
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [comm_semigroup M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) : comm_semigroup M‚ÇÅ
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} {C‚ÇÅ C‚ÇÇ : homological_complex V c} [category_theory.limits.has_zero_object V] (f : C‚ÇÅ.hom C‚ÇÇ) (j : Œπ) : category_theory.arrow.mk (C‚ÇÅ.d_to j) ‚ü∂ category_theory.arrow.mk (C‚ÇÇ.d_to j)
(env : environment) (dict : name_map (list ‚Ñï)) : expr ‚Üí expr
(tooltip : widget.tc subexpr empty) (e : expr) : tactic (widget.html empty)
{X Y : Top} : Top.of (‚Ü•X √ó ‚Ü•Y) ‚ü∂ X
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : ray_vector R M
{Œ± : Type u} {L‚ÇÅ L‚ÇÇ : list (Œ± √ó bool)} [decidable_eq Œ±] (H : free_group.red (free_group.reduce L‚ÇÅ) L‚ÇÇ) : free_group.reduce L‚ÇÅ = L‚ÇÇ
(is : list ‚Ñ§) : tactic expr
(M : Type u_1) [monoid M] {X : Type u} [mul_action M X] (x : X) : ‚Ü•(mul_action.stabilizer.submonoid M x) ‚âÉ* category_theory.End ‚Üëx
{Œ± : Type u_1} [has_lt Œ±] (a b : Œ±) : Prop
 : tactic unit
{Y : Type u_2} [topological_space Y] [normal_space Y] {s : set Y} (f : C(‚Ü•s, ‚Ñù)) (hs : is_closed s) : ‚àÉ (g : C(Y, ‚Ñù)), continuous_map.restrict s g = f
{n : ‚Ñï} {Œ± : Type u} {Œ≤ : Type v} {m : Type v ‚Üí Type u_1} [monad m] (a : array n Œ±) (f : Œ± ‚Üí m Œ≤) : m (array n Œ≤)
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [add_comm_monoid N] (f : Œ± ‚Üí‚ÇÄ M) (y : Œ±) (g : Œ± ‚Üí M ‚Üí N) (hyf : y ‚àà f.support) : g y (‚áëf y) + (finsupp.erase y f).sum g = f.sum g
{R : Type u_1} [ordered_comm_ring R] (s : subring R) : ordered_comm_ring ‚Ü•s
(cf cg : nat.partrec.code) (a : ‚Ñï) : (cf.prec cg).eval (nat.mkpair a 0) = cf.eval a
{Œ± : Type u_2} {Œ≤ : Type u_3} [non_assoc_ring Œ±] [non_assoc_ring Œ≤] (f : Œ± ‚Üí+* Œ≤) (x : Œ±) : ‚áëf (-x) = -‚áëf x
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) [category_theory.limits.has_colimit (K ‚ãô F)] [category_theory.creates_colimit K F] : category_theory.limits.has_colimit K
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} (t : category_theory.limits.pullback_cone f g) : t.X ‚ü∂ X
{a b : ‚Ñù} : ‚à´ (x : ‚Ñù) in a..b, real.sin x * real.cos x = (real.cos a ^ 2 - real.cos b ^ 2) / 2
{M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] (h : M ‚âÉ* N) : N ‚âÉ* M
{G : Type u_10} [group G] (a : G) : equiv.perm G
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {Œ¥ : Sort u_4} (h : Œ± ‚âÉ Œ≤) (h' : Œ≥ ‚âÉ Œ¥) : (Œ± ‚Ü™ Œ≥) ‚âÉ (Œ≤ ‚Ü™ Œ¥)
{F : Type u ‚Üí Type v} [applicative F] [is_lawful_applicative F] {G : Type u ‚Üí Type w} [applicative G] [is_lawful_applicative G] {H : Type u ‚Üí Type s} [applicative H] [is_lawful_applicative H] (Œ∑' : applicative_transformation G H) (Œ∑ : applicative_transformation F G) : applicative_transformation F H
{R S : Type u} [ring R] [ring S] (f : R ‚Üí+* S) : Ring.of R ‚ü∂ Ring.of S
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {E : Type u‚ÇÉ} {F : Type u‚ÇÑ} [category_theory.category E] [category_theory.category F] {G : C ‚•§ E} {H : D ‚•§ F} {L‚ÇÅ : C ‚•§ D} {R‚ÇÅ : D ‚•§ C} {L‚ÇÇ : E ‚•§ F} {R‚ÇÇ : F ‚•§ E} (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) : (G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) ‚âÉ (R‚ÇÅ ‚ãô G ‚ü∂ H ‚ãô R‚ÇÇ)
{ùïú : Type u} [nondiscrete_normed_field ùïú] (f : local_homeomorph ùïú ùïú) {a f' : ùïú} (ha : a ‚àà f.to_local_equiv.target) (hf' : f' ‚â† 0) (htff' : has_strict_deriv_at ‚áëf f' (‚áë(f.symm) a)) : has_strict_deriv_at ‚áë(f.symm) f'‚Åª¬π a
{R : Type u} [comm_ring R] (r : R) : topological_space.opens (prime_spectrum R)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space F] [complete_space E] (e : E ‚âÉ‚Çó[ùïú] F) (h : continuous ‚áëe) : continuous ‚áë(e.symm)
{n : ‚Ñï} [fact (0 < n)] : fintype.card (quaternion_group n) = 4 * n
{G : Type u_1} [group G] (s : set G) (hsn : s.nonempty) (hs : ‚àÄ (x : G), x ‚àà s ‚Üí ‚àÄ (y : G), y ‚àà s ‚Üí x * y‚Åª¬π ‚àà s) : subgroup G
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ‚äÜ ‚Üë(affine_span k s)
(tac : tactic unit) : tactic (option tactic.proof_state)
{Œ≤ : Type w} {C : Type u} [category_theory.category C] [unique Œ≤] (f : Œ≤ ‚Üí C) : ‚àê f ‚âÖ f inhabited.default
{Œ± : Type u_1} {Œπ : Type u_5} {m0 : measurable_space Œ±} (f : Œπ ‚Üí measure_theory.measure Œ±) : measure_theory.measure Œ±
(Œì : Type u_4) (T : Type u_5) [topological_space T] [has_vadd Œì T] : Prop
(ts : list (tactic unit)) : tactic unit
{Œ± : Type u_1} [semigroup Œ±] [partial_order Œ±] [contravariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] : right_cancel_semigroup Œ±
(s : string) : string
(M : Type u_5) [monoid M] {R : Type u_11} [semiring R] [mul_semiring_action M R] : R ‚Üí+*[M] R
{R : Type u_1} [comm_semiring R] [topological_space R] [topological_semiring R] (X : set R) : subalgebra R C(‚Ü•X, R)
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} [comm_ring R] [lie_ring L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÅ] [lie_algebra R L‚ÇÇ] : has_coe_to_fun (L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) (Œª (_x : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ), L‚ÇÅ ‚Üí L‚ÇÇ)
{n : with_top ‚Ñï} {ùïÇ : Type u_6} [is_R_or_C ùïÇ] {F' : Type u_8} [normed_group F'] [normed_space ùïÇ F'] {f : ùïÇ ‚Üí F'} {f' : F'} {x : ùïÇ} (hf : cont_diff_at ùïÇ n f x) (hf' : has_deriv_at f f' x) (hn : 1 ‚â§ n) : has_strict_deriv_at f f' x
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x y z : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (hz : z ‚â† 0) : o.oangle x y + o.oangle y z = o.oangle x z
{R : Type u} [comm_ring R] {L : Type v} {M : Type w} {N : Type w‚ÇÅ} {P : Type w‚ÇÇ} {Q : Type w‚ÇÉ} [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group N] [module R N] [lie_ring_module L N] [lie_module R L N] [add_comm_group P] [module R P] [lie_ring_module L P] [lie_module R L P] [add_comm_group Q] [module R Q] [lie_ring_module L Q] [lie_module R L Q] (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ P) (g : N ‚Üí‚Çó‚ÅÖR,L‚ÅÜ Q) : tensor_product R M N ‚Üí‚Çó‚ÅÖR,L‚ÅÜ tensor_product R P Q
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] (f : P1 ‚Üí P2) (linear : V1 ‚Üí‚Çó[k] V2) (add : ‚àÄ (p : P1) (v : V1), f (v +·µ• p) = ‚áëlinear v +·µ• f p) : ‚áë{to_fun := f, linear := linear, map_vadd' := add} = f
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (b : category_theory.limits.binary_bicone P Q) : Type (max u v)
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {R : Type u_1} [comm_semiring R] [semiring k] [algebra R k] [add_monoid G] : algebra R (add_monoid_algebra k G)
{Œ± : Type u} [pseudo_emetric_space Œ±] {x y : Œ±} {s : set Œ±} (h : y ‚àà s) : emetric.inf_edist x s ‚â§ has_edist.edist x y
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_le Œ±] [has_le Œ≤] : Œ± √ó Œ≤ ‚âÉo Œ≤ √ó Œ±
{R‚ÇÇ : Type u_5} {M‚ÇÇ : Type u_6} [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {n : Type u_11} (b : n ‚Üí M‚ÇÇ) : bilin_form R‚ÇÇ M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] matrix n n R‚ÇÇ
{V : Type u} {G : simple_graph V} {u v : V} (p : G.walk u v) : Prop
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.limits.has_terminal C] : C
 : expr ‚Üí tactic (list expr √ó expr)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.abelian D] (F : C ‚•§ D) (G : D ‚•§ C) [G.preserves_zero_morphisms] (i : F ‚ãô G ‚âÖ ùü≠ C) (adj : G ‚ä£ F) [category_theory.limits.has_cokernels C] {X Y : C} (f : X ‚ü∂ Y) : G.obj (category_theory.limits.cokernel (F.map f)) ‚âÖ category_theory.limits.cokernel f
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] (z : ‚Ñ§_[p]) : z - ‚Üë(‚áëpadic_int.to_zmod z) ‚àà local_ring.maximal_ideal ‚Ñ§_[p]
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [htwo : invertible 2] {B : bilin_form R M} (hB‚ÇÅ : B ‚â† 0) (hB‚ÇÇ : B.is_symm) : ‚àÉ (x : M), ¬¨B.is_ortho x x
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [finite_dimensional ùïú E] {n : ‚Ñï} (hn : finite_dimensional.finrank ùïú E = n) {Œπ : Type u_4} [fintype Œπ] [decidable_eq Œπ] {V : Œπ ‚Üí submodule ùïú E} (hV : direct_sum.is_internal V) (a : fin n) : ‚áë(direct_sum.is_internal.subordinate_orthonormal_basis hn hV) a ‚àà V (direct_sum.is_internal.subordinate_orthonormal_basis_index hn hV a)
{Œ± : Type u_1} [complete_lattice Œ±] [is_modular_lattice Œ±] [is_compactly_generated Œ±] [is_atomistic Œ±] : is_complemented Œ±
{Œ± : Type u} {Œ≤ : Type v} [emetric_space Œ±] [complete_space Œ±] [emetric_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : isometry f) : closed_embedding f
 : sSet.to_Top ‚ä£ Top.to_sSet
(R : Type u) (M : Type v) [comm_ring R] [add_comm_group M] [module R M] : Prop
(Œ± : Type u_1) : besicovitch.ball_package Œ± Œ±
{C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B)
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] {i : Œπ} : M i ‚Üí* free_product M
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] (f : E ‚ÜíL[ùïú] F ‚ÜíL[ùïú] G) (x : E √ó F) : formal_multilinear_series ùïú (E √ó F) G
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí. Œ≤ ‚äï Œ±} (a : Œ±) {b : Œ≤} (hb : sum.inl b ‚àà f a) : b ‚àà f.fix a
{Œ± : Type u_1} (f g : equiv.perm Œ±) : Prop
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.final] {E : Type u} [category_theory.category E] {G : D ‚•§ E} (t : category_theory.limits.cocone (F ‚ãô G)) : category_theory.limits.is_colimit (category_theory.functor.final.extend_cocone.obj t) ‚âÉ category_theory.limits.is_colimit t
{Œ± : Type u} [emetric_space Œ±] [compact_space Œ±] : compact_space (topological_space.nonempty_compacts Œ±)
(Œ± : Type u_1) [topological_space Œ±] : Œ± ‚âÉ‚Çú Œ±
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] (f : ùïú ‚Üí F) (f' : F) (x : ùïú) : Prop
(R : Type u_1) [ring R] [is_domain R] [decidable_eq R] [fintype R] : division_ring R
{Œ± : Type u_1} (l : filter Œ±) (Œ≤ : Type u_2) : Type (max u_1 u_2)
{M : Type u_1} [comm_monoid_with_zero M] (S : submonoid M) (N : Type u_2) [comm_monoid_with_zero N] : Type (max u_1 u_2)
(M : Type u_1) {Œ± : Type u_6} [monoid M] [mul_action M Œ±] : has_scalar.smul 1 = id
{Œ± : Type u} : list (Œ± √ó bool) ‚Üí list (Œ± √ó bool) ‚Üí Prop
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (h : ¬¨category_theory.limits.is_zero X) : nontrivial (category_theory.subobject X)
(M : Type u_4) [add_zero_class M] : Type u_4
{Œ± : Type u} {Œ≤ : Type v} [linear_ordered_field Œ±] [topological_space Œ±] [order_topology Œ±] {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±} {C : Œ±} (hC : 0 < C) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_top) : filter.tendsto (Œª (x : Œ≤), f x * g x) l filter.at_top
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X ‚Üí Y) (h : ‚àÄ (x : X), ‚àÉ (e : local_homeomorph X Y), x ‚àà e.to_local_equiv.source ‚àß ‚àÄ (x : X), x ‚àà e.to_local_equiv.source ‚Üí f x = ‚áëe x) : is_locally_homeomorph f
{Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) (i : Œπ) : topological_fiber_bundle.trivialization F Z.proj
{X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] (m : ennreal ‚Üí ennreal) (s : set X) : ‚áë(measure_theory.measure.mk_metric m) s = ‚®Ü (r : ennreal) (hr : 0 < r), ‚®Ö (t : ‚Ñï ‚Üí set X) (h : s ‚äÜ set.Union t) (h' : ‚àÄ (n : ‚Ñï), emetric.diam (t n) ‚â§ r), ‚àë' (n : ‚Ñï), ‚®Ü (h : (t n).nonempty), m (emetric.diam (t n))
 : expr ‚Üí ‚Ñï
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] (h : continuous_map.homotopy_equiv X Y) : X ‚Üí Y
{G : Type u_1} [comm_monoid G] (tG : monoid.is_torsion G) : comm_monoid.torsion G = ‚ä§
{Œ± : Type u_1} {G : Type u_2} [group G] [monoid Œ±] [mul_distrib_mul_action Œ± G] : mul_action Œ± (subgroup G)
(C : Type u‚ÇÅ) [category_theory.category C] : category_theory.is_skeleton_of C (category_theory.skeleton C) (category_theory.from_skeleton C)
(X : Type u_2) [topological_space X] [regular_space X] [topological_space.second_countable_topology X] : ‚àÉ (f : X ‚Üí bounded_continuous_function ‚Ñï ‚Ñù), embedding f
(auto_candidates : tactic (list name)) : tactic.eliminate.with_pattern ‚Üí tactic (option (name ‚äï list name))
{R : Type u_1} [non_unital_non_assoc_semiring R] : R ‚Üí+ R ‚Üí+ R
{Œ± : Type u_1} : ordnode Œ± ‚Üí Prop
{Œ± : Sort u} (message : string) : Œ±
(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] : Type u_3
{M : Type u_1} [ordered_add_comm_monoid M] {A : Type u_2} [set_like A M] [add_submonoid_class A M] (S : A) : ordered_add_comm_monoid ‚Ü•S
{R : Type u_1} {S : Type u_2} {M : Type u_3} [monoid R] [add_monoid M] [distrib_mul_action R M] [monoid S] [has_scalar S M] (f : R ‚Üí* S) (hf : function.surjective ‚áëf) (hsmul : ‚àÄ (c : R) (x : M), ‚áëf c ‚Ä¢ x = c ‚Ä¢ x) : distrib_mul_action S M
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] {module_M : module R M} {module_M‚ÇÇ : module R‚ÇÇ M‚ÇÇ} {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} {re‚ÇÅ‚ÇÇ : ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ} {re‚ÇÇ‚ÇÅ : ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ} (e : M ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (p : submodule R M) (q : submodule R‚ÇÇ M‚ÇÇ) (h : submodule.map ‚Üëe p = q) : ‚Ü•p ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] ‚Ü•q
{Œ± : Type u_1} [linear_ordered_ring Œ±] [floor_ring Œ±] : Œ± ‚Üí ‚Ñ§
{T : Type u‚ÇÅ} [category_theory.category T] {X : T} {f g : category_theory.over X} (k : f ‚ü∂ g) [hk : category_theory.epi k.left] : category_theory.epi k
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (i : D ‚•§ C) [category_theory.limits.has_finite_products C] [category_theory.cartesian_closed C] (A : C) [category_theory.reflective i] [category_theory.exponential_ideal i] : i ‚ãô category_theory.exp A ‚ãô category_theory.left_adjoint i ‚ãô i ‚âÖ i ‚ãô category_theory.exp A
{Œ± : Sort u_1} {Œ≤ : Œ± ‚Üí Sort u_2} (x : Œ±) (f : Œ† (x : Œ±), Œ≤ x) : Œ≤ x
{G : Type u_1} [group G] (H : subgroup G) : has_pow ‚Ü•H ‚Ñ§
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) {r : ‚Ñù} (hr : 0 < r) : hb.oangle (r ‚Ä¢ x) y = hb.oangle x y
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] (s : wseq Œ±) : computation (option Œ±)
{P : ‚Ñ§ ‚Üí Prop} (Hbdd : ‚àÉ (b : ‚Ñ§), ‚àÄ (z : ‚Ñ§), P z ‚Üí z ‚â§ b) (Hinh : ‚àÉ (z : ‚Ñ§), P z) : ‚àÉ (ub : ‚Ñ§), P ub ‚àß ‚àÄ (z : ‚Ñ§), P z ‚Üí z ‚â§ ub
(R : Type u_1) [ring R] : polynomial.cyclotomic 0 R = 1
{Œ± : Type u} (l : list Œ±) : list {x // x ‚àà l}
{Œ± : Type u_1} (M : Type u_2) [add_zero_class M] (s : set Œ±) : (Œ± ‚Üí M) ‚Üí+ Œ± ‚Üí M
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : eqv_gen.setoid (eqv_gen.setoid r).rel = eqv_gen.setoid r
{K : Type u} [field K] (s : subfield K) {x y : K} : x ‚àà s ‚Üí y ‚àà s ‚Üí x / y ‚àà s
{Œ± : Type u} {Œ≤ : Type v} [monoid Œ±] [monoid Œ≤] (f : Œ± ‚Üí* Œ≤) : conj_classes Œ± ‚Üí conj_classes Œ≤
 : expr ‚Üí name ‚Üí expr
(M : Type u_1) [mul_one_class M] : M ‚Üí* M
{Œ± : Type u_1} : galois_insertion eqv_gen.setoid setoid.rel
 : lean.parser (option lint_verbosity)
 : Type
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [non_unital_non_assoc_ring Œ≤] : non_unital_non_assoc_ring Œ±
{Œπ : Type u_1} {R : Type u_2} {M : Œπ ‚Üí Type u_4} [dec_Œπ : decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] (i : Œπ) : M i ‚Üí‚Çó[R] Œ†‚ÇÄ (i : Œπ), M i
 : category_theory.limits.walking_parallel_pair ‚âå category_theory.limits.walking_parallel_pair·µí·µñ
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f : M ‚Üí+ N) {g : N ‚Üí M} (h : function.left_inverse g ‚áëf) : M ‚âÉ+ ‚Ü•(f.mrange)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : has_dist.dist p1 p3 * has_dist.dist p1 p3 = has_dist.dist p1 p2 * has_dist.dist p1 p2 + has_dist.dist p3 p2 * has_dist.dist p3 p2 - 2 * has_dist.dist p1 p2 * has_dist.dist p3 p2 * real.cos (euclidean_geometry.angle p1 p2 p3)
{M : Type u_1} [has_mul M] {c d : con M} (h : c = d) : c.quotient ‚âÉ* d.quotient
(R : Type u_1) [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {A : Type u_3} [semiring A] [algebra R A] : (M ‚Üí‚Çó[R] A) ‚âÉ (tensor_algebra R M ‚Üí‚Çê[R] A)
 : tactic unit
{X Y Z : algebraic_geometry.LocallyRingedSpace} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [H : algebraic_geometry.LocallyRingedSpace.is_open_immersion f] (H' : set.range ‚áë(g.val.base) ‚äÜ set.range ‚áë(f.val.base)) : Y ‚ü∂ X
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ (v+1))
{Œ± : Type u_2} {Œ≤ : Type u_3} [decidable_eq Œ≤] [has_scalar Œ± Œ≤] {u : finset Œ≤} {s : set Œ±} {t : set Œ≤} : ‚Üëu ‚äÜ s ‚Ä¢ t ‚Üí (‚àÉ (s' : finset Œ±) (t' : finset Œ≤), ‚Üës' ‚äÜ s ‚àß ‚Üët' ‚äÜ t ‚àß u ‚äÜ s' ‚Ä¢ t')
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : is_irreducible s ‚Üî ‚àÄ (Z : finset (set Œ±)), (‚àÄ (z : set Œ±), z ‚àà Z ‚Üí is_closed z) ‚Üí s ‚äÜ ‚ãÉ‚ÇÄ‚ÜëZ ‚Üí (‚àÉ (z : set Œ±) (H : z ‚àà Z), s ‚äÜ z)
{Œ± : Type u} [hg : add_group Œ±] [is_add_cyclic Œ±] : add_comm_group Œ±
(p : ‚Ñï) [fact (nat.prime p)] : ‚Ñ§ ‚Üí*‚ÇÄ ‚Ñ§
{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b‚Åª¬π
{Œ± : Type u_1} {s t : multiset Œ±} : s ‚â§ t ‚Üí s ‚äÜ t
(R : Type u_2) [semiring R] (M : fin 2 ‚Üí Type u_1) [Œ† (i : fin 2), add_comm_monoid (M i)] [Œ† (i : fin 2), module R (M i)] [Œ† (i : fin 2), topological_space (M i)] : (Œ† (i : fin 2), M i) ‚âÉL[R] M 0 √ó M 1
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (f : M ‚Üí‚Çô* N) (hf : ‚àÄ (x y : M), commute (‚áëf x) (‚áëf y)) : M·µê·µí·µñ ‚Üí‚Çô* N
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] {f : filter Œ±} {a : Œ±} [f.ne_bot] (h : f ‚â§ nhds a) : f.Liminf = a
 : num ‚Üí pos_num
{Œ± : Type u} [topological_space Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù} (hp : function.periodic f c) (hc : c ‚â† 0) (hf : continuous f) : is_compact (set.range f)
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : Prop
{R‚ÇÇ : Type u_5} {M‚ÇÇ : Type u_6} [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {n : Type u_11} [fintype n] [decidable_eq n] (b : basis n R‚ÇÇ M‚ÇÇ) : matrix n n R‚ÇÇ ‚âÉ‚Çó[R‚ÇÇ] bilin_form R‚ÇÇ M‚ÇÇ
(R : Type u_1) [comm_ring R] (m n : ‚Ñï) : polynomial.chebyshev.T R (m * n) = (polynomial.chebyshev.T R m).comp (polynomial.chebyshev.T R n)
{Œ± : Type u_1} [decidable_eq Œ±] : has_insert Œ± (finset Œ±)
(R : Type u) [comm_ring R] (x : ‚Ü•(algebraic_geometry.prime_spectrum.Top R)) : (algebraic_geometry.Spec.structure_sheaf R).val.stalk x ‚ü∂ CommRing.of (localization.at_prime (prime_spectrum.as_ideal x))
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C
{Œ± : Type u} [linear_ordered_field Œ±] [topological_space Œ±] [order_topology Œ±] {n : ‚Ñï} (hn : 1 ‚â§ n) : filter.tendsto (Œª (x : Œ±), x ^ -‚Üën) filter.at_top (nhds 0)
{Œ± : Type u_1} {n : Type u_3} {m : Type u_4} {A : matrix m m Œ±} {B : matrix m n Œ±} {C : matrix n m Œ±} {D : matrix n n Œ±} : (matrix.from_blocks A B C D).is_symm ‚Üî A.is_symm ‚àß B.transpose = C ‚àß C.transpose = B ‚àß D.is_symm
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.monoidal_opposite.mop X ‚ü∂ category_theory.monoidal_opposite.mop Y
{K : Type u} {L : Type v} [field K] [field L] (f : K ‚Üí+* L) : K ‚Üí+* ‚Ü•(f.field_range)
(C : Type u‚ÇÅ) [category_theory.category C] : Prop
{Œ± : Type u_1} [measurable_space Œ±] : measure_theory.vector_measure Œ± ennreal ‚âÉ measure_theory.measure Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] [complete_space E] [complete_space (F √ó G)] (f : E ‚ÜíL[ùïú] F) (g : E ‚ÜíL[ùïú] G) (hf : f.range = ‚ä§) (hg : g.range = ‚ä§) (hfg : is_compl f.ker g.ker) : E ‚âÉL[ùïú] F √ó G
(C : Type u) [category_theory.category C] : Type (max u w v)
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (D : Type w) [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] : ùü≠ (C·µí·µñ ‚•§ D) ‚ü∂ J.sheafification D
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_2} (f : (Œ† (a : Œ±), part (Œ≤ a)) ‚Üío Œ† (a : Œ±), part (Œ≤ a)) : omega_complete_partial_order.chain (Œ† (a : Œ±), part (Œ≤ a))
{F : Type u_3} [field F] [fintype F] (hF : ring_char F ‚â† 2) {a : F} (ha : a ‚â† 0) : a ^ (fintype.card F / 2) = 1 ‚à® a ^ (fintype.card F / 2) = -1
 : tactic.explode.thm ‚Üí string
{Œ± : Type u_1} {Œ≤ : Type u_2} (R : Type u_3) {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] : (Œ± √ó Œ≤ ‚Üí‚ÇÄ M) ‚âÉ‚Çó[R] Œ± ‚Üí‚ÇÄ Œ≤ ‚Üí‚ÇÄ M
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_3} {v : Œπ ‚Üí E} (hz : ‚àÄ (i : Œπ), v i ‚â† 0) (ho : ‚àÄ (i j : Œπ), i ‚â† j ‚Üí has_inner.inner (v i) (v j) = 0) : linear_independent ùïú v
{R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : ¬¨is_left_regular 0
{Œ± : Type u_1} (n : ‚Ñï) (l : list Œ±) : list (list Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.is_equivalence F] : D ‚•§ C
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_group E] [has_scalar ùïú E] (S : convex_cone ùïú E) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.reflects_isomorphisms G] [category_theory.limits.has_limits C] [category_theory.limits.has_limits D] [category_theory.limits.preserves_limits G] {X : Top} (F : Top.presheaf C X) : F.is_sheaf ‚Üî Top.presheaf.is_sheaf (F ‚ãô G)
{Œ± : Type u} (t‚ÇÅ t‚ÇÇ : ordnode Œ±) : Prop
{G : Type u_1} [group G] (H K : subgroup G) : Prop
(cl : tactic.closure) (p : expr) : tactic unit
{Œ≤ : Type v} {Œ≥ : Type u_3} [omega_complete_partial_order Œ≤] [omega_complete_partial_order Œ≥] {Œ± : Type u_1} (f : Œ± ‚Üí Œ≤ ‚ÜíùíÑ Œ≥) : Œ≤ ‚ÜíùíÑ Œ± ‚Üí Œ≥
{X : Type u} (x : X) : punit ‚ü∂ X
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (f : Œ± ‚Üí option Œ±) (x : Œ±) : ordnode Œ± ‚Üí ordnode Œ±
{R : Type u} {S : Type u_1} [ring R] [ring S] [is_principal_ideal_ring R] (f : R ‚Üí+* S) (hf : function.surjective ‚áëf) : is_principal_ideal_ring S
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_mono f] [category_theory.epi f] : category_theory.is_iso f
{C : Type u} [category_theory.category C] {X Y Z : algebraic_geometry.PresheafedSpace C} (f : X ‚ü∂ Z) [hf : algebraic_geometry.PresheafedSpace.is_open_immersion f] (g : Y ‚ü∂ Z) : category_theory.limits.pullback_cone f g
{X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X) : urysohns.CU X
{G : Type u_10} [group G] (a : G) : ‚áë(equiv.symm (equiv.mul_right a)) = Œª (x : G), x * a‚Åª¬π
(Œ± : Type u) [topological_space Œ±] [topological_space.second_countable_topology Œ±] [regular_space Œ±] : normal_space Œ±
{C : Type (max v u)} [category_theory.category C] {D : Type w} [category_theory.category D] [category_theory.abelian D] {F G : C ‚•§ D} (Œ± : F ‚ü∂ G) (X : C) : (category_theory.abelian.coimage Œ±).obj X ‚âÖ category_theory.abelian.coimage (Œ±.app X)
(G : Type w) [group G] : G ‚âÉ (multiplicative ‚Ñ§ ‚Üí* G)
 : Mon_Type_equivalence_Mon.functor ‚ãô category_theory.forget Mon ‚âÖ Mon_.forget (Type u)
(_x : interactive.parse (lean.parser.tk "open_locale")) : lean.parser unit
 : local_context
{C : Type u} [category_theory.category C] (X : C) : Type v
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} {r : ‚Ñù} (hr : 0 ‚â§ r) (H1 : ‚àÄ (x : Œ±), x ‚àà s ‚Üí (‚àÉ (y : Œ±) (H : y ‚àà t), has_dist.dist x y ‚â§ r)) (H2 : ‚àÄ (x : Œ±), x ‚àà t ‚Üí (‚àÉ (y : Œ±) (H : y ‚àà s), has_dist.dist x y ‚â§ r)) : metric.Hausdorff_dist s t ‚â§ r
{E : Type u_2} [add_comm_group E] {F : Type u_3} [add_comm_group F] {R‚ÇÅ : Type u_7} [comm_ring R‚ÇÅ] [module R‚ÇÅ E] [module R‚ÇÅ F] {p q : submodule R‚ÇÅ E} (h : is_compl p q) : ((‚Ü•p ‚Üí‚Çó[R‚ÇÅ] F) √ó (‚Ü•q ‚Üí‚Çó[R‚ÇÅ] F)) ‚âÉ‚Çó[R‚ÇÅ] E ‚Üí‚Çó[R‚ÇÅ] F
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : set P} (ho : euclidean_geometry.orthocentric_system s) : ‚àÉ (r : ‚Ñù), ‚àÄ (t : affine.triangle ‚Ñù P), set.range t.points ‚äÜ s ‚Üí affine.simplex.circumradius t = r
{Œ± : Type u_1} [comm_monoid Œ±] : Œ± ‚Üí* associates Œ±
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [no_min_order Œ±] {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (set.Iic a) ‚Üî ‚àÉ (l : Œ±) (H : l ‚àà set.Iio a), set.Ioc l a ‚äÜ s
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] {J : Type v} [fintype J] {f : J ‚Üí C} [category_theory.limits.preserves_colimit (category_theory.discrete.functor f) F] : category_theory.limits.preserves_biproduct f F
(ccs : cc_state) (e : expr) : tactic expr
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (S R : category_theory.sieve X) : category_theory.sieve X
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_image f] : category_theory.subobject Y
{K : Type u_1} [linear_ordered_field K] (s : subfield K) : linear_ordered_field ‚Ü•s
{Œ± : Sort u} {Œ≤ : Sort v} (f : Œ± ‚âÉ Œ≤) : Œ± ‚Ü™ Œ≤
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : subsingleton (lie_ideal R ‚Ü•‚ä•)
{L : first_order.language} {M : Type w} [L.Structure M] {S : L.substructure M} {s : set M} : ‚áë(first_order.language.substructure.closure L) s ‚â§ S ‚Üî s ‚äÜ ‚ÜëS
{Œ± : Type u} : seq Œ± ‚Üí lazy_list Œ±
(Œ± : Type u_1) : Type u_1
 : pexpr ‚Üí list pexpr
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (f : G ‚Üí+ N) : G ‚Üí+ ‚Ü•(f.range)
(R : Type u) [comm_semiring R] (p : ‚Ñï) [fact (nat.prime p)] [char_p R p] : R ‚Üí+* R
(mi : interactive.decl_meta_info) (_x : interactive.parse (lean.parser.tk "add_decl_doc")) : lean.parser unit
{Œ± : Type u_1} {R : Type u_11} [has_zero R] [is_empty Œ±] : unique (Œ± ‚Üí‚ÇÄ R)
{G : Type u_1} [comm_group G] (K : subgroup G) (g : multiset G) : (‚àÄ (a : G), a ‚àà g ‚Üí a ‚àà K) ‚Üí g.prod ‚àà K
(G : Type u_1) [add_monoid G] : ¬¨add_monoid.is_torsion G ‚Üî ‚àÉ (g : G), ¬¨is_of_fin_add_order g
{C : Type u‚ÇÅ} [category_theory.category C] {Z X Y P : C} (f : Z ‚ü∂ X) (g : Z ‚ü∂ Y) (inl : X ‚ü∂ P) (inr : Y ‚ü∂ P) : Prop
(C : Type u) [category_theory.category C] : Type (max u v)
{Œ± : Type u} (g : set (set Œ±)) : filter Œ±
(R : Type u_1) [semiring R] [topological_space R] : topological_space RÀ£
{n : ‚Ñï} {Œ± : Type u_1} [preorder Œ±] {f : fin (n + 1) ‚Üí Œ±} : monotone f ‚Üî ‚àÄ (i : fin n), f (‚áëfin.cast_succ i) ‚â§ f i.succ
{k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] {Œπ : Type u_3} (s : finset Œπ) {w : Œπ ‚Üí k} {p : Œπ ‚Üí V} (hw : s.sum w = 0) : ‚áë(s.weighted_vsub p) w = s.sum (Œª (i : Œπ), w i ‚Ä¢ p i)
(k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} [nontrivial k] (p : Œπ ‚Üí P) (j : Œπ) (q : P) : q ‚àà affine_span k (set.range p) ‚Üî ‚àÉ (s : finset Œπ) (w : Œπ ‚Üí k), q = ‚áë(s.weighted_vsub_of_point p (p j)) w +·µ• p j
(v : multiset ‚Ñï+) (h : ‚àÄ (p : ‚Ñï+), p ‚àà v ‚Üí p.prime) : prime_multiset
(K : Type u) [field K] (V : Type u) [add_comm_group V] [module K V] [finite_dimensional K V] : FinVect K
{Œ± : Type u} [topological_space Œ±] {Z : set Œ±} (h : is_clopen Z) : (‚ãÉ (x : Œ±) (H : x ‚àà Z), connected_component x) = Z
{K : Type u_1} [field K] [invertible 2] {a b c : K} (ha : a ‚â† 0) (h : discrim a b c = 0) (x : K) : a * x * x + b * x + c = 0 ‚Üî x = -b / (2 * a)
{Œ± : Type u} {Œ≤ : Type v} [semigroup Œ≤] (f : Œ± ‚Üí Œ≤) (x : free_semigroup Œ±) : Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] (F : C ‚•§ D) : Prop
{K : Type u} {L : Type v} [field K] [field L] [fintype K] [decidable_eq L] (f : K ‚Üí+* L) : fintype ‚Ü•(f.field_range)
{R‚ÇÇ : Type u_5} {M‚ÇÇ : Type u_6} [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] : bilin_form R‚ÇÇ M‚ÇÇ ‚âÉ‚Çó[R‚ÇÇ] M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] R‚ÇÇ
(G : out_param (Type u_1)) (P : Type u_2) : Type (max u_1 u_2)
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] (F : J ‚•§ algebraic_geometry.PresheafedSpace C) : algebraic_geometry.PresheafedSpace C
{V : Type u} (G : simple_graph V) (v : V) [fintype ‚Ü•(G.neighbor_set v)] : ‚Ñï
{p : ‚Ñï} [fact (nat.prime p)] : has_sub ‚Ñ§_[p]
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] (P : C·µí·µñ ‚•§ D) (X : C) : (J.cover X)·µí·µñ ‚•§ D
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) (i : fin (n + 1)) : has_dist.dist s.circumcenter (s.points i) = s.circumradius
{Œπ : Type u_1} {Œπ‚ÇÇ : Type u_2} [decidable_eq Œπ] [decidable_eq Œπ‚ÇÇ] (R : Type u_4) [comm_semiring R] (M : Type u_8) [add_comm_monoid M] [module R M] : tensor_product R (pi_tensor_product R (Œª (i : Œπ), M)) (pi_tensor_product R (Œª (i : Œπ‚ÇÇ), M)) ‚âÉ‚Çó[R] pi_tensor_product R (Œª (i : Œπ ‚äï Œπ‚ÇÇ), M)
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (g : G) (p1 p2 : P) : g +·µ• p1 -·µ• p2 = g + (p1 -·µ• p2)
{R : Type u} [comm_ring R] {S : Type v} [comm_ring S] (f : R ‚Üí+* S) : C(prime_spectrum S, prime_spectrum R)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ‚Ñ§] (D : Type u') [category_theory.category D] [category_theory.limits.has_zero_morphisms D] [category_theory.has_shift D ‚Ñ§] (F : C ‚•§ D) (Œ∑ : category_theory.shift_functor C 1 ‚ãô F ‚ü∂ F ‚ãô category_theory.shift_functor D 1) (hF : ‚àÄ (c c' : C), F.map 0 = 0) : category_theory.differential_object C ‚•§ category_theory.differential_object D
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) (i : E ‚âÉL[ùïú] F) (h : p 1 = ‚áë((continuous_multilinear_curry_fin1 ùïú E F).symm) ‚Üëi) (h0 : p 0 = 0) : p.comp (p.right_inv i) = formal_multilinear_series.id ùïú F
(f : name ‚Üí option name) (replace_all trace : bool) (relevant : name_map ‚Ñï) (ignore reorder : name_map (list ‚Ñï)) (src tgt : name) (attrs : list name) : tactic unit
(R : Type u) (M : Type v) (M‚ÇÇ : Type w) (M‚ÇÉ : Type y) (M‚ÇÑ : Type z) (S : Type u_3) [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [add_comm_monoid M‚ÇÑ] [module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] [module R M‚ÇÑ] [module S M‚ÇÉ] [module S M‚ÇÑ] [smul_comm_class R S M‚ÇÉ] [smul_comm_class R S M‚ÇÑ] : (M ‚Üí‚Çó[R] M‚ÇÉ) √ó (M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÑ) ‚Üí‚Çó[S] M √ó M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÉ √ó M‚ÇÑ
 : ‚áëlinear_equiv.det complex.conj_ae.to_linear_equiv = -1
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : local_equiv Œ± Œ≤) (s : set Œ±) (t : set Œ≤) : Prop
(p q n : ‚Ñï) [fact (nat.prime p)] (hq : q ‚â† 0) : padic_val_nat p (q ^ n) = n * padic_val_nat p q
 : tactic unit
{m : Type u} {n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) (B : matrix n m Œ±) [invertible A] : A.mul ((‚Öü A).mul B) = B
(X : algebraic_geometry.Scheme) [algebraic_geometry.is_affine X] : X ‚âÖ algebraic_geometry.Scheme.Spec.obj (opposite.op (algebraic_geometry.Scheme.Œì.obj (opposite.op X)))
{n : ‚Ñï} (a : composition n) (b : composition a.length) (i : fin (a.gather b).length) : composition ((a.gather b).blocks_fun i)
{Œ± : Type u_1} : partial_order (subtype setoid.is_partition)
{Œ± : Type u} [lattice Œ±] [comm_group Œ±] (a : Œ±) (h : 1 ‚â§ a) : a‚Å∫ = a
{K : Type u_1} [linear_ordered_field K] {v : K} [floor_ring K] (terminates : (generalized_continued_fraction.of v).terminates) : ‚àÄ·∂† (n : ‚Ñï) in filter.at_top, v = (generalized_continued_fraction.of v).convergents n
{G : Type u_10} [group G] (a : G) : ‚áë(equiv.symm (equiv.mul_left a)) = has_mul.mul a‚Åª¬π
{B : Type u_3} {S : B} {M : Type u_1} [comm_monoid M] [set_like B M] [submonoid_class B M] (m : multiset M) (hm : ‚àÄ (a : M), a ‚àà m ‚Üí a ‚àà S) : m.prod ‚àà S
{Œì‚ÇÄ : Type u_1} [linear_ordered_comm_group_with_zero Œì‚ÇÄ] : (nhds 0).has_basis (Œª (_x : Œì‚ÇÄÀ£), true) (Œª (Œ≥‚ÇÄ : Œì‚ÇÄÀ£), {Œ≥ : Œì‚ÇÄ | Œ≥ < ‚ÜëŒ≥‚ÇÄ})
(x : ‚ÑÇ) : has_strict_deriv_at complex.sinh (complex.cosh x) x
{Œ±‚ÇÅ : Sort u_1} {Œ≤‚ÇÅ : Sort u_2} {Œ±‚ÇÇ : Sort u_3} {Œ≤‚ÇÇ : Sort u_4} (e‚ÇÅ : Œ±‚ÇÅ ‚âÉ Œ±‚ÇÇ) (e‚ÇÇ : Œ≤‚ÇÅ ‚âÉ Œ≤‚ÇÇ) : (Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ) ‚âÉ (Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ)
{Œ± : Type u} [add_comm_monoid Œ±] (a b : Œ±) (hab : a + b = 0) : add_units Œ±
{Œ± : Type} (transp : tactic.transparency) (e : expr) (mx : tactic.ring_exp.ring_exp_m Œ±) : tactic Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} (t : category_theory.presieve.is_sheaf_for P R) (x : category_theory.presieve.family_of_elements P R) (hx : x.compatible) : P.obj (opposite.op X)
{Œ± : Type u} {Œ≤ : Type v} [has_repr Œ±] [has_repr Œ≤] : slim_check.total_function Œ± Œ≤ ‚Üí string
{Œ± : Type u_1} {Œ≤ : Type u_2} {e : local_equiv Œ± Œ≤} {s : set Œ±} {t : set Œ≤} (h : e.is_image s t) : local_equiv Œ± Œ≤
(J : Type v) : (category_theory.limits.wide_pushout_shape J)·µí·µñ ‚âå category_theory.limits.wide_pullback_shape J
{R : Type u} [ring R] {J : Type v} [category_theory.small_category J] (F : J ‚•§ Module R) (j : J) : (category_theory.limits.types.limit_cone (F ‚ãô category_theory.forget (Module R))).X ‚Üí‚Çó[R] (F ‚ãô category_theory.forget (Module R)).obj j
{Œ± : Type u_1} [topological_space Œ±] {Œ≤ : Type u_2} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) (x : Œ±) : Prop
(K : Type u_3) (V : Type u_6) [field K] [add_comm_group V] [module K V] (x : V) (h : x ‚â† 0) : K ‚âÉ‚Çó[K] ‚Ü•(submodule.span K {x})
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f g : V ‚Üí‚Çó[K] V} : f.comp g = linear_map.id ‚Üî g.comp f = linear_map.id
 : name ‚Üí tactic pexpr
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) [invertible A.det] : (matrix n n Œ±)À£
 : Type
 : tactic unit
{A : Type u} [category_theory.category A] [category_theory.abelian A] {X Y Z : A} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (w : f ‚â´ g = 0) : homology f g w ‚ü∂ category_theory.limits.cokernel f
 : Type
{C : Type u} [category_theory.category C] {A X Y : C} [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] : (Y ‚ü∂ (category_theory.exp A).obj X) ‚Üí (A ‚®Ø Y ‚ü∂ X)
{n : ‚Ñï} (R : Type u_1) [comm_ring R] [is_domain R] : ‚áë(algebra_map (polynomial R) (ratfunc R)) (polynomial.cyclotomic n R) = n.divisors_antidiagonal.prod (Œª (i : ‚Ñï √ó ‚Ñï), ‚áë(algebra_map (polynomial R) (ratfunc R)) (polynomial.X ^ i.snd - 1) ^ ‚áënat.arithmetic_function.moebius i.fst)
{C : Type u} [category_theory.category C] {P Q : C} (f : P ‚ü∂ Q) [category_theory.epi f] [category_theory.strong_mono f] : category_theory.is_iso f
{P : Type u_1} [semilattice_sup P] {x y : P} {s : order.ideal P} (hx : x ‚àà s) (hy : y ‚àà s) : x ‚äî y ‚àà s
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] [topological_space Œ±] (F : Œπ ‚Üí Œ± ‚Üí Œ≤) (f : Œ± ‚Üí Œ≤) (p : filter Œπ) (s : set Œ±) : Prop
{Œ± : Type u_1} : list Œ± ‚Üí option Œ±
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) (j : J) (x : ‚Ü•(F.obj j)) : AddCommGroup.colimits.colimit_type F
{Œ± : Type u_1} [linear_order Œ±] {r : Œ±} {s : finset Œ±} : s.to_colex < {r}.to_colex ‚Üî ‚àÄ (x : Œ±), x ‚àà s ‚Üí x < r
(R : Type u) {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) : set R
(Œ± : Type u_6) [topological_space Œ±] [measurable_space Œ±] : Prop
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] {j j' : C} (f f' : j ‚ü∂ j') : C
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] [category_theory.limits.has_finite_products C] [category_theory.limits.has_finite_products D] (F : C ‚•§ D) [category_theory.cartesian_closed C] [category_theory.cartesian_closed D] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] : Type
{Œ± : Type u} {t : Type u ‚Üí Type u} [traversable t] : t Œ± ‚Üí list Œ±
{X : Top} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) (f : Œ£ (V : topological_space.opens ‚Ü•X), {f // Top.presheaf.presieve_of_covering U f}) : Œπ
(M : Type u) : Type u
{Œ± : Type u_1} {Œ≤ : Type u_2} {e : local_equiv Œ± Œ≤} {s : set Œ±} {t : set Œ≤} : e.source ‚à© ‚áëe ‚Åª¬π' t = e.source ‚à© s ‚Üí e.is_image s t
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] (f : Œ± ‚âÉ Œ≤) (hf : uniform_inducing ‚áëf) : Œ± ‚âÉ·µ§ Œ≤
{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] : has_coe (fractional_ideal S P) (submodule R P)
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] (L : A ‚•§ T) (R : B ‚•§ T) : category_theory.comma.fst L R ‚ãô L ‚ü∂ category_theory.comma.snd L R ‚ãô R
(X : algebraic_geometry.Scheme) : Prop
(n : ‚Ñï) (e : expr) : pexpr
(Œ± : Type u_1) [infinite Œ±] : ‚Ñï ‚Ü™ Œ±
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [has_zero M‚ÇÅ] [has_scalar ‚Ñï M‚ÇÅ] [has_neg M‚ÇÅ] [has_sub M‚ÇÅ] [has_scalar ‚Ñ§ M‚ÇÅ] [sub_neg_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (inv : ‚àÄ (x : M‚ÇÅ), f (-x) = -f x) (div : ‚àÄ (x y : M‚ÇÅ), f (x - y) = f x - f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : sub_neg_monoid M‚ÇÅ
(t : expr) (p : interactive.parse (lean.parser.tk ":=" *> interactive.types.texpr)) : tactic unit
 : local_homeomorph ‚Ñù ‚Ñù
(Œ± : Type u_1) (Œ≤ : Type u_2) [has_add Œ≤] : add_hom Œ≤ (Œ± ‚Üí Œ≤)
{C : Type u} [category_theory.category C] (X : C) : category_theory.presieve.is_sheaf (category_theory.sheaf.canonical_topology C) (category_theory.yoneda.obj X)
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} [category_theory.limits.has_zero_object V] [category_theory.limits.has_image 0] [category_theory.limits.has_cokernel (image_to_kernel 0 0 homology_zero_zero._proof_3)] : homology 0 0 homology_zero_zero._proof_5 ‚âÖ B
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (n : ‚Ñï) (f : E ‚Üí F) : E ‚Üí continuous_multilinear_map ùïú (Œª (i : fin n), E) F
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_group Œ±] [subtraction_monoid Œ≤] (f : Œ± ‚Üí+ Œ≤) (g h : Œ±) : ‚áëf (g + -h) = ‚áëf g + -‚áëf h
(R : Type u_2) [comm_semiring R] {A : Type u_3} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] {A‚ÇÇ : Type u_4} [topological_space A‚ÇÇ] [semiring A‚ÇÇ] [algebra R A‚ÇÇ] [topological_semiring A‚ÇÇ] [has_continuous_const_smul R A] [has_continuous_const_smul R A‚ÇÇ] {Œ± : Type u_1} [topological_space Œ±] (g : A ‚Üí‚Çê[R] A‚ÇÇ) (hg : continuous ‚áëg) : C(Œ±, A) ‚Üí‚Çê[R] C(Œ±, A‚ÇÇ)
{G : Type u} [category_theory.groupoid G] [is_free_groupoid G] (T : wide_subquiver (quiver.symmetrify (is_free_groupoid.generators G))) [quiver.arborescence ‚Ü•T] {a b : is_free_groupoid.generators G} (e : a ‚ü∂ b) (H : e ‚àà quiver.wide_subquiver_symmetrify T a b) : is_free_groupoid.spanning_tree.loop_of_hom T (is_free_groupoid.of e) = ùüô (root' T)
{Œ± : Type u} [add_group Œ±] : has_Inf (add_group_topology Œ±)
{Œ± : Type u} {Œπ : Type x} [pseudo_metric_space Œ±] [fintype Œπ] {f : Œ± ‚Üí Œπ ‚Üí ‚Ñù} {s : set Œ±} {K : nnreal} (hf : lipschitz_on_with K f s) : ‚àÉ (g : Œ± ‚Üí Œπ ‚Üí ‚Ñù), lipschitz_with K g ‚àß set.eq_on f g s
{m : Type u_2} {Œ± : Type u_12} (M : matrix m m Œ±) (p : m ‚Üí Prop) : matrix {a // p a} {a // p a} Œ±
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] (f : S.localization_map N) (z : N) : M √ó ‚Ü•S
 : lean.parser (bool √ó list string √ó simps_cfg)
{M : Type u_1} [has_mul M] (c : con M) : con.mul_ker coe _ = c
(l : list name) : tactic (list (name √ó linter))
{n : ‚Ñï} (P : mvpfunctor (n + 1)) : mvpfunctor n
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤] {f : C(Œ±, Œ≤)} {Œπ : Type u‚ÇÉ} {p : filter Œπ} {F : Œπ ‚Üí C(Œ±, Œ≤)} (h : tendsto_locally_uniformly (Œª (i : Œπ) (a : Œ±), ‚áë(F i) a) ‚áëf p) : filter.tendsto F p (nhds f)
{Œ± : Type u_1} [comm_semiring Œ±] (E : linear_recurrence Œ±) (u : ‚Ñï ‚Üí Œ±) : Prop
{G : Type u} [group G] (N : subgroup G) [nN : N.normal] {H : Type v} [group H] (M : subgroup H) [M.normal] (f : G ‚Üí* H) (h : N ‚â§ subgroup.comap f M) : G ‚ß∏ N ‚Üí* H ‚ß∏ M
(k G : Type u) [field k] [monoid G] : Type (u+1)
{R : Type u_1} [normed_ring R] [complete_space R] (x : RÀ£) : (Œª (t : R), ring.inverse (‚Üëx + t)) =O[nhds 0] Œª (t : R), 1
(Œ± : Type u) {Œ≤ : Type v} [add_monoid Œ±] [add_action Œ± Œ≤] (b : Œ≤) : set Œ≤
{X : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) {Y : algebraic_geometry.Scheme} (f : Œ† (x : ùí∞.J), ùí∞.obj x ‚ü∂ Y) (hf : ‚àÄ (x y : ùí∞.J), category_theory.limits.pullback.fst ‚â´ f x = category_theory.limits.pullback.snd ‚â´ f y) : X ‚ü∂ Y
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) {r : R} (h : 0 < r) : same_ray R (r ‚Ä¢ v) v
(x : ‚ÑÇ) : ‚Ñù
{Œ± Œ≤ : FinPartialOrder} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] (X : C) (Y : D) : ùüô (X, Y) = (ùüô X, ùüô Y)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_3} (l : Œπ ‚Üí‚ÇÄ ùïú) (v : Œπ ‚Üí E) (x : E) : has_inner.inner (l.sum (Œª (i : Œπ) (a : ùïú), a ‚Ä¢ v i)) x = l.sum (Œª (i : Œπ) (a : ùïú), ‚áë(star_ring_end ùïú) a ‚Ä¢ has_inner.inner (v i) x)
(n : ‚Ñï) : ring_char (zmod n) = n
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] (f : M ‚Üí R) (x y : M) : R
(R : Type u_1) (M : Type u_2) [subsingleton R] [semiring R] [add_comm_monoid M] [module R M] : is_noetherian R M
{Œπ : Type u_1} [fintype Œπ] {Œ± : Type u_2} [add_group Œ±] [measure_theory.measure_space Œ±] [measure_theory.sigma_finite measure_theory.measure_space.volume] [has_measurable_neg Œ±] [measure_theory.measure_space.volume.is_neg_invariant] : measure_theory.measure_space.volume.is_neg_invariant
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (C : cochain_complex V ‚Ñï) : (cochain_complex.truncate.obj C).augment (C.d 0 1) _ ‚âÖ C
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (m : measurable_space Œ±) : measurable_space Œ≤
{G : Type u_1} {H : Type u_2} {M : Type u_3} [has_scalar G H] [group G] [group H] [monoid M] [mul_action G M] [smul_comm_class G M M] [mul_action H M] [smul_comm_class H M M] [is_scalar_tower G M M] [is_scalar_tower H M M] [is_scalar_tower G H M] : is_scalar_tower G H MÀ£
(R : Type u_1) [comm_ring R] (p : ‚Ñï) [is_domain R] [char_p R p] : char_p (fraction_ring R) p
(M : Type u_1) [mul_zero_one_class M] : M ‚Üí*‚ÇÄ M
{M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_3} [has_zero M‚ÇÄ'] [has_mul M‚ÇÄ'] [has_one M‚ÇÄ'] [has_pow M‚ÇÄ' ‚Ñï] [monoid_with_zero M‚ÇÄ] (f : M‚ÇÄ' ‚Üí M‚ÇÄ) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÄ'), f (x * y) = f x * f y) (npow : ‚àÄ (x : M‚ÇÄ') (n : ‚Ñï), f (x ^ n) = f x ^ n) : monoid_with_zero M‚ÇÄ'
 : ‚Ñï ‚Üí ‚Ñï √ó ‚Ñï
{Œ± : Type u} (s : set Œ±) [decidable_pred (Œª (_x : Œ±), _x ‚àà s)] : free_comm_ring Œ± ‚Üí+* free_comm_ring ‚Ü•s
 : partial_order ‚ÑÇ
{Œ± : Type u_1} [decidable_eq Œ±] (l : list Œ±) (H : l.nodup) : fin l.length ‚âÉ {x // x ‚àà l}
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (a : Œ±) : Œ± ‚Üí Prop
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} {l : list Œπ} [decidable_eq Œπ] (h : ‚àÄ (i : Œπ), i ‚àà l) (v : list.tprod Œ± l) (i : Œπ) : Œ± i
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] {s : set Œ±} (hs : is_preconnected s) : s ‚àà {set.Icc (has_Inf.Inf s) (has_Sup.Sup s), set.Ico (has_Inf.Inf s) (has_Sup.Sup s), set.Ioc (has_Inf.Inf s) (has_Sup.Sup s), set.Ioo (has_Inf.Inf s) (has_Sup.Sup s), set.Ici (has_Inf.Inf s), set.Ioi (has_Inf.Inf s), set.Iic (has_Sup.Sup s), set.Iio (has_Sup.Sup s), set.univ, ‚àÖ}
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {M : Type w} [add_comm_group M] [lie_ring_module L M] {N : Type w‚ÇÅ} [add_comm_group N] [lie_ring_module L N] [module R N] [lie_module R L N] [module R M] [lie_module R L M] (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (L' : lie_subalgebra R L) : M ‚Üí‚Çó‚ÅÖR,‚Ü•L'‚ÅÜ N
{Œ± : Type u_1} {s : finset Œ±} {f : Œ± ‚Üí ennreal} (hf : ‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚â† ‚ä§) : (s.sum (Œª (a : Œ±), f a)).to_nnreal = s.sum (Œª (a : Œ±), (f a).to_nnreal)
{Œ± : Type u_1} [topological_space Œ±] [baire_space Œ±] {p : Œ± ‚Üí Prop} : (‚àÄ·∂† (x : Œ±) in residual Œ±, p x) ‚Üî ‚àÉ (t : set Œ±), is_GŒ¥ t ‚àß dense t ‚àß ‚àÄ (x : Œ±), x ‚àà t ‚Üí p x
{P : pfunctor} (x : P.W) : P.B x.head ‚Üí P.W
{C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ‚Ñï} {i j : fin (n + 2)} (H : i ‚â§ j) : X.Œ¥ j.succ ‚â´ X.Œ¥ i = X.Œ¥ (‚áëfin.cast_succ i) ‚â´ X.Œ¥ j
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Type (max v u)) : category_theory.limits.cocone F
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.split_epi category_theory.limits.prod.snd
{Œ± : Type u_1} : ordnode Œ± ‚Üí Œ± ‚Üí ordnode Œ± ‚Üí ordnode Œ±
(Œπ : Type u_1) : Type u_1
{T : Type u‚ÇÅ} [category_theory.category T] {X : T} (f : category_theory.over X) : category_theory.over f.left ‚•§ category_theory.over f
{M : Type u_1} [comm_monoid M] (S : submonoid M) : ‚Ñï ‚Üí localization S ‚Üí localization S
{K : Type u} [field K] (self : subfield K) : subring K
{G : Type u_1} [group G] (N H : subgroup G) [N.normal] : ‚Üë(N ‚äî H) = ‚ÜëN * ‚ÜëH
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_cokernel f] {Z : C} (l : Y ‚ü∂ Z) (i : category_theory.limits.cokernel f ‚âÖ Z) (h : category_theory.limits.cokernel.œÄ f ‚â´ i.hom = l) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ l _)
{M' : Type u_4} {Œ± : Type u_5} {Œ≤ : Type u_6} [mul_one_class M'] [has_scalar Œ± Œ≤] [has_scalar M' Œ±] [has_scalar M' Œ≤] [is_scalar_tower M' Œ± Œ≤] (S : submonoid M') : is_scalar_tower ‚Ü•S Œ± Œ≤
{M : Type u_1} [add_monoid M] {s : set M} (hcomm : ‚àÄ (a : M), a ‚àà s ‚Üí ‚àÄ (b : M), b ‚àà s ‚Üí a + b = b + a) : add_comm_monoid ‚Ü•(add_submonoid.closure s)
(Œπ : Type u_1) (ùïú : Type u_2) [is_R_or_C ùïú] (E : Type u_3) [inner_product_space ùïú E] : Type (max u_1 u_2 u_3)
{Œ± : Type u_1} [add_semigroup Œ±] [partial_order Œ±] [contravariant_class Œ± Œ± has_add.add has_le.le] : add_left_cancel_semigroup Œ±
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] (P : C·µí·µñ ‚•§ D) : P ‚ü∂ J.sheafify P
{Œ± : Type u_1} [preorder Œ±] (a : Œ±) : lower_set Œ±
{Œ± : Type u} {Œ≤ : Type v} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [densely_ordered Œ±] {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {s : set Œ±} (hs : dense s) (H : ‚àÄ (a : Œ±), a ‚àà s ‚Üí ‚àÄ (b : Œ±), b ‚àà s ‚Üí a < b ‚Üí ¬¨((‚àÉ·∂† (n : Œ≤) in f, u n < a) ‚àß ‚àÉ·∂† (n : Œ≤) in f, b < u n)) (h : filter.is_bounded_under has_le.le f u . "is_bounded_default") (h' : filter.is_bounded_under ge f u . "is_bounded_default") : ‚àÉ (c : Œ±), filter.tendsto u f (nhds c)
 : category_theory.large_category category_theory.Rel
{Œ± : Type u_1} {m : measurable_space Œ±} {M : Type u_3} [add_comm_monoid M] [topological_space M] {R : Type u_4} [semiring R] [distrib_mul_action R M] [has_continuous_const_smul R M] (r : R) (v : measure_theory.vector_measure Œ± M) : measure_theory.vector_measure Œ± M
{Œ± : Type u_1} {Œ≤ : Type u_2} [semilattice_sup Œ±] (s : finset Œ≤) (H : s.nonempty) (f : Œ≤ ‚Üí Œ±) : Œ±
{R : Type u} [ring R] {J : Type v} [category_theory.small_category J] (F : J ‚•§ Module R) : category_theory.limits.is_limit ((category_theory.forget‚ÇÇ (Module R) AddCommGroup).map_cone (Module.has_limits.limit_cone F))
{Œ± : Type u_1} [linear_ordered_field Œ±] {Œ≤ : Type u_2} [comm_ring Œ≤] {abv : Œ≤ ‚Üí Œ±} [is_absolute_value abv] : cau_seq Œ≤ abv ‚Üí cau_seq.completion.Cauchy
(M : Type u_1) [measurable_space M] [has_sup M] : Prop
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (f : option Œ± ‚Üí option Œ±) (x : Œ±) : ordnode Œ± ‚Üí ordnode Œ±
(J : Type v) : category_theory.limits.wide_pullback_shape_unop J ‚ãô category_theory.limits.wide_pushout_shape_op J ‚âÖ ùü≠ (category_theory.limits.wide_pullback_shape J)·µí·µñ
{X : Type u} {Y : Type v} [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] (f : prod_space_fun X Y) (fA : f ‚àà Gromov_Hausdorff.candidates X Y) : Cb X Y
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (q : trunc Œ±) (f : Œ± ‚Üí trunc Œ≤) : trunc Œ≤
(env : environment) (f : name ‚Üí name) (test : expr ‚Üí bool) (relevant : name_map ‚Ñï) (reorder : name_map (list ‚Ñï)) (tgt : name) (decl : declaration) : declaration
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : r ‚âÉr s) : initial_seg r s
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ùïú] [inner_product_space ùïú E] [inner_product_space ùïú F] [finite_dimensional ùïú E] [finite_dimensional ùïú F] : (E ‚Üí‚Çó[ùïú] F) ‚âÉ‚Çó‚ãÜ[ùïú] F ‚Üí‚Çó[ùïú] E
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} : strict_anti_on f s ‚Üí strict_mono_on (‚áëorder_dual.to_dual ‚àò f) s
(ùïú : Type u_1) {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] (x : E) (s : set E) : Prop
{R : Type u_1} [ring R] (s : subring R) {Œπ : Type u_2} {t : finset Œπ} {f : Œπ ‚Üí R} (h : ‚àÄ (c : Œπ), c ‚àà t ‚Üí f c ‚àà s) : t.sum (Œª (i : Œπ), f i) ‚àà s
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [finite_dimensional ùïú E] {n : ‚Ñï} (hn : finite_dimensional.finrank ùïú E = n) : basis (fin n) ùïú E
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {m : measurable_space Œ±} [topological_space Œ≤] [topological_space.pseudo_metrizable_space Œ≤] [topological_space Œ≥] [topological_space.pseudo_metrizable_space Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : embedding g) : measure_theory.strongly_measurable (Œª (x : Œ±), g (f x)) ‚Üî measure_theory.strongly_measurable f
{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] (x : K) : ‚áë(algebra.norm K) (‚áë(algebra_map K L) x) = x ^ finite_dimensional.finrank K L
{Œ± : Type u} [uniform_space Œ±] (s : set Œ±) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} (A : T.algebra) : A.hom A
{n m : ‚Ñï} (h : fin n = fin m) : cast h = ‚áë(fin.cast _)
(n : string) (p : Prop) : Prop
(Œ± : Type u) : Type u
(A : Type u_1) (R : Type u_2) (B : Type u_3) [comm_ring R] [comm_semiring A] [comm_ring B] [algebra R B] [algebra A B] : Prop
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : category_theory.category (C ‚•§ D)
(n b : ‚Ñï) : (n + 1) / (b + 2) < n + 1
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (connected_fibers : ‚àÄ (t : Œ≤), is_connected (f ‚Åª¬π' {t})) (hcl : ‚àÄ (T : set Œ≤), is_closed T ‚Üî is_closed (f ‚Åª¬π' T)) (t : Œ≤) : is_connected (f ‚Åª¬π' connected_component t)
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (D : Type w) [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] [Œ† (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)·µí·µñ (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] : category_theory.presheaf_to_Sheaf J D ‚ä£ category_theory.Sheaf_to_presheaf J D
(x : nnreal) (y : ‚Ñù) : nnreal
{Œ± : Type u} : tactic Œ± ‚Üí tactic (list Œ±)
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÇ] [has_one M‚ÇÇ] [has_pow M‚ÇÇ ‚Ñï] [has_inv M‚ÇÇ] [has_div M‚ÇÇ] [has_pow M‚ÇÇ ‚Ñ§] [div_inv_monoid M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (inv : ‚àÄ (x : M‚ÇÅ), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : M‚ÇÅ), f (x / y) = f x / f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (x ^ n) = f x ^ n) : div_inv_monoid M‚ÇÇ
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} [char_zero k] {s : finset Œπ} (p : Œπ ‚Üí P) (h : s.card ‚â† 0) : finset.centroid k s p ‚àà affine_span k (set.range p)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_image f] : category_theory.mono_over Y
{Œ± : Type u} {n : ‚Ñï} (h : Œ±) (t : fin n ‚Üí Œ±) : fin n.succ ‚Üí Œ±
{R : Type u_1} {M : Type u_4} {S : Type u_7} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) [semiring S] [has_scalar S R] [module S M] [is_scalar_tower S R M] : submodule.span S ‚Üëp = submodule.restrict_scalars S p
{P : Type u_1} [semilattice_sup P] [is_directed P ge] : has_inf (order.ideal P)
{X : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space X] {g : Œ± ‚Üí Œ≤} (f : X ‚Üí Œ±) (h : locally_constant X Œ≤) (cond : g ‚àò f = ‚áëh) (inj : function.injective g) : locally_constant X Œ±
{n : ‚Ñï} {Œ± Œ≤ : typevec n} (h : Œ± = Œ≤) : Œ±.arrow Œ≤
{G‚ÇÄ : Type u_2} [measurable_space G‚ÇÄ] [group_with_zero G‚ÇÄ] [has_measurable_mul G‚ÇÄ] (g : G‚ÇÄ) (hg : g ‚â† 0) : G‚ÇÄ ‚âÉ·µê G‚ÇÄ
{S : Type u‚ÇÅ} {L : Type u‚ÇÇ} {D : Type u‚ÇÉ} [category_theory.category S] [category_theory.category L] [category_theory.category D] (Œπ : S ‚•§ L) (F : S ‚•§ D) (x : L) : category_theory.costructured_arrow Œπ x ‚•§ D
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {l : list L} : (‚àÄ (x : L), x ‚àà l ‚Üí x ‚àà S) ‚Üí l.sum ‚àà S
{M : Type u_2} {N : Type u_3} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid N] [module R N] {Œπ : Type u_1} {Œ∫ : Type u_4} (e‚ÇÅ : Œπ ‚âÉ Œ∫) (e‚ÇÇ : M ‚âÉ‚Çó[R] N) : (Œπ ‚Üí‚ÇÄ M) ‚âÉ‚Çó[R] Œ∫ ‚Üí‚ÇÄ N
{V : Type u_1} [inner_product_space ‚Ñù V] (x y : V) : inner_product_geometry.angle (-x) (-y) = inner_product_geometry.angle x y
{C : Type u} [category_theory.category C] [category_theory.preadditive C] : C·µí·µñ ‚•§ C ‚•§ AddCommGroup
{R : Type u_7} {S : Type u_8} [has_mul R] [has_add R] [has_mul S] [has_add S] (self : R ‚âÉ+* S) : R ‚âÉ+ S
{L : first_order.language} (r : L.relations 2) : L.sentence
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} : (category_theory.presieve.is_separated_for P R ‚àß ‚àÄ (x : category_theory.presieve.family_of_elements P R), x.compatible ‚Üí (‚àÉ (t : P.obj (opposite.op X)), x.is_amalgamation t)) ‚Üî category_theory.presieve.is_sheaf_for P R
{Œ≤ : Type u_2} [decidable_eq Œ≤] (s : finset Œ≤) (b : Œ≤) : finset.filter (eq b) s = ite (b ‚àà s) {b} ‚àÖ
{G : Type u_1} [add_comm_group G] (B : add_group_filter_basis G) : uniform_add_group G
{Œ± : Sort u_1} {C : trunc Œ± ‚Üí Sort u_3} [‚àÄ (a : Œ±), subsingleton (C (trunc.mk a))] (q : trunc Œ±) (f : Œ† (a : Œ±), C (trunc.mk a)) : C q
{Œ± : Type v} (P : Œ± ‚Üí Prop) : (Œ£ (i : Œ±), ulift (plift (P i))) ‚âÉ subtype P
{f g : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hgc : continuous_on g (set.Icc a b)) (hle : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioc a b ‚Üí f x ‚â§ g x) (hlt : ‚àÉ (c : ‚Ñù) (H : c ‚àà set.Icc a b), f c < g c) : ‚à´ (x : ‚Ñù) in a..b, f x < ‚à´ (x : ‚Ñù) in a..b, g x
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} (f g : c.quotient ‚Üí* P) (h : ‚àÄ (a : M), ‚áëf ‚Üëa = ‚áëg ‚Üëa) : f = g
 : ‚Ñ§ √ó ‚Ñ§ ‚âÉ ‚Ñ§ √ó ‚Ñ§
{T : Type u‚ÇÅ} [category_theory.category T] (X : T) : Type (max u‚ÇÅ v‚ÇÅ)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : ‚Üës ‚à© ‚Üë(affine_subspace.mk' p (s.direction)·óÆ) = {‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p)}
 : environment ‚Üí tactic unit
(q : ‚Ñï+) : Type
 : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [emetric_space Œ±] [pseudo_emetric_space Œ≤] {f : Œ± ‚Üí Œ≤} (h : antilipschitz_with 0 f) : subsingleton Œ±
{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_right_regular a) : is_right_regular (b * a) ‚Üî is_right_regular b
{Œ± : Type u} [uniform_space Œ±] {s : set Œ±} {Œπ : Sort u_1} {c : Œπ ‚Üí set Œ±} (hs : is_compact s) (hc‚ÇÅ : ‚àÄ (i : Œπ), is_open (c i)) (hc‚ÇÇ : s ‚äÜ ‚ãÉ (i : Œπ), c i) : ‚àÉ (n : set (Œ± √ó Œ±)) (H : n ‚àà uniformity Œ±), ‚àÄ (x : Œ±), x ‚àà s ‚Üí (‚àÉ (i : Œπ), {y : Œ± | (x, y) ‚àà n} ‚äÜ c i)
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x y : V} (Œ∏ : real.angle) : hb.oangle x y = Œ∏ ‚Üî (x ‚â† 0 ‚àß y ‚â† 0 ‚àß ‚àÉ (r : ‚Ñù), 0 < r ‚àß y = r ‚Ä¢ ‚áë(hb.rotation Œ∏) x) ‚à® Œ∏ = 0 ‚àß (x = 0 ‚à® y = 0)
{R : Type u} [semiring R] [no_zero_divisors R] [nontrivial R] : polynomial R ‚Üí* multiplicative (with_bot ‚Ñï)
{Œ± : Type u} [group Œ±] : partial_order (group_topology Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : Type w) [category_theory.category J] (F : C ‚•§ D·µí·µñ) [category_theory.limits.preserves_colimits_of_shape J·µí·µñ F] : category_theory.limits.preserves_limits_of_shape J F.left_op
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) [category_theory.limits.has_colimit F] (j : J) : F.obj j ‚ü∂ category_theory.limits.colimit F
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} (X : T.algebra) : T.free.obj X.A ‚ü∂ X
(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_binary_coproducts C] : category_theory.monoidal_category C
(n : ‚Ñï) [fact (0 < n)] [fintype (zmod n)À£] : fintype.card (zmod n)À£ = n.totient
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] : finite_dimensional K ‚Ü•‚ä•
 : tactic unit
(hs : list expr) : tactic (list expr)
{R : Type u} {S : Type v} [ring R] [ring S] {g : S ‚Üí R} {f : R ‚Üí+* S} (h : function.left_inverse g ‚áëf) : R ‚âÉ+* ‚Ü•(f.range)
{n : Type u} [decidable_eq n] [fintype n] {Œ± : Type v} [comm_ring Œ±] (A : matrix n n Œ±) : (n ‚Üí Œ±) ‚Üí‚Çó[Œ±] n ‚Üí Œ±
{Œ± : Type u_1} [decidable_eq Œ±] : multiset Œ± ‚Üí finset (list Œ±)
{M : Type u_1} [has_mul M] (S : subsemigroup M) (s : set M) (hs : s = ‚ÜëS) : subsemigroup M
(C : Type u) [category_theory.category C] : Prop
(l : expr) : tactic ‚Ñï
(o : ordinal) : ‚Ü•(set.Iio o) ‚âÉo (quotient.out o).Œ±
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] (u v : Œ±) : set.inj_on (Œª (x : Œ±), (x ‚äî u)  v) {x : Œ± | disjoint u x ‚àß v ‚â§ x}
{Œ≤ : Type u_4} [linear_order Œ≤] [no_max_order Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : filter.tendsto u filter.at_top filter.at_top) (N : ‚Ñï) : ‚àÉ (n : ‚Ñï) (H : n ‚â• N), ‚àÄ (k : ‚Ñï), k < n ‚Üí u k < u n
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom A (A √ó B)
(Œ± : Type u_1) [topological_space Œ±] [preorder Œ±] : Prop
{R : Type u_1} [comm_ring R] [top : topological_space R] [topological_ring R] {J : ideal R} : is_adic J ‚Üî (‚àÄ (n : ‚Ñï), is_open ‚Üë(J ^ n)) ‚àß ‚àÄ (s : set R), s ‚àà nhds 0 ‚Üí (‚àÉ (n : ‚Ñï), ‚Üë(J ^ n) ‚äÜ s)
{Œ± : Type u_3} {Œ≤ : Type u_4} [lattice Œ±] [lattice Œ≤] [bounded_order Œ±] [bounded_order Œ≤] (f : bounded_lattice_hom Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : bounded_lattice_hom Œ± Œ≤
{V : Type u} {G : simple_graph V} (x y : G.subgraph) : G.subgraph
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚âÉ Œ≤) : free_abelian_group Œ± ‚âÉ+ free_abelian_group Œ≤
{R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} [comm_semiring R] [semiring A‚ÇÅ] [semiring A‚ÇÇ] [algebra R A‚ÇÅ] [algebra R A‚ÇÇ] (f : A‚ÇÅ ‚Üí‚Çê[R] A‚ÇÇ) (hf : function.bijective ‚áëf) : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] : ‚Ñ§_[p] ‚Üí ‚Ñï ‚Üí ‚Ñï
{X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {d‚ÇÅ d‚ÇÇ : ‚Ñù} (h : d‚ÇÅ ‚â§ d‚ÇÇ) (s : set X) : ‚áë(measure_theory.measure.hausdorff_measure d‚ÇÇ) s ‚â§ ‚áë(measure_theory.measure.hausdorff_measure d‚ÇÅ) s
{Œ± : Sort u_1} : is_empty {a // false}
{X : Top} (x : ‚Ü•X) : topological_space.open_nhds x ‚•§ topological_space.opens ‚Ü•X
 : linter
{R : Type x} [non_unital_non_assoc_ring R] {a b : R} (h : commute a b) : a * a - b * b = (a + b) * (a - b)
{R : Type u} {M : Type v} [has_zero M] (r : R) : triv_sq_zero_ext R M
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} (p : Œπ ‚Üí P) (i‚ÇÄ : Œπ) : vector_span k (set.range p) = submodule.span k (set.range (Œª (i : {x // x ‚â† i‚ÇÄ}), p i‚ÇÄ -·µ• p ‚Üëi))
{Œ± : Type u_1} : ‚ä•.realizer
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : Top.presheaf.sheaf_condition_equalizer_products.pi_opens F U ‚ü∂ category_theory.presheaf.first_obj (Top.presheaf.presieve_of_covering U) F
{Œ± : Type} {d : ‚Ñï} {ds : list ‚Ñï} (x : holor Œ± (d :: ds)) (i : ‚Ñï) (h : i < d) : holor Œ± ds
(x : ‚Ñù*) : Prop
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x : V} (hx : x ‚â† 0) : o.oangle (-x) x = ‚Üëreal.pi
(R : Type u_1) [semiring R] (n : ‚Ñï) : power_series R ‚Üí‚Çó[R] R
(d : declaration) : tactic unit
{G : Type u} [group G] {N : subgroup G} [N.normal] (hN : (nat.card ‚Ü•N).coprime N.index) : ‚àÉ (H : subgroup G), N.is_complement' H
{C : Type u‚ÇÅ} [category_theory.category C] (T : category_theory.monad C) : Type (max u‚ÇÅ v‚ÇÅ)
{R S : CommRing} (f : R ‚ü∂ S) : algebraic_geometry.Spec.SheafedSpace_obj S ‚ü∂ algebraic_geometry.Spec.SheafedSpace_obj R
{R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] (p : polynomial R) : R
 : ‚Ñï ‚Üí ‚Ñö
{M : Type u_1} [mul_one_class M] : ‚Ü•‚ä§ ‚âÉ* M
 : fourier_subalgebra.to_submodule = submodule.span ‚ÑÇ (set.range fourier)
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] {B' : Type u_5} [topological_space B'] (e : topological_fiber_bundle.trivialization F proj) (f : B' ‚Üí B) (hf : continuous f) (b' : B') (hb' : f b' ‚àà e.base_set) : topological_fiber_bundle.trivialization F (Œª (x : ‚Ü•{p : B' √ó Z | f p.fst = proj p.snd}), ‚Üëx.fst)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P (n + 2)) (i‚ÇÅ i‚ÇÇ : fin (n + 3)) : s.monge_plane i‚ÇÅ i‚ÇÇ = s.monge_plane i‚ÇÇ i‚ÇÅ
 : algebraic_geometry.Scheme.Œì.right_op ‚ä£ algebraic_geometry.Scheme.Spec
(Œ± : Type u_1) : Œ± √ó pempty ‚âÉ pempty
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] {Œπ : Type u_1} [decidable_eq Œπ] (c : complex_shape Œπ) (j : Œπ) (A : V) : ((homological_complex.single V c j).obj A).X j ‚âÖ A
{Œ± : Type u_1} [preorder Œ±] [pred_order Œ±] {a : Œ±} : ¬¨is_min a ‚Üí order.pred a < a
{G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) (f : G ‚âÉ* N) : subgroup.map f.to_monoid_hom H.normalizer = (subgroup.map f.to_monoid_hom H).normalizer
{G : Type u_1} [group G] : smul_comm_class G ‚Ü•(subgroup.center G) G
{Œ± : Type u_2} {Œ≤ : Type u_3} [decidable_eq Œ≤] [has_scalar Œ± Œ≤] : has_scalar (finset Œ±) (finset Œ≤)
{Œ± : Type u_2} (l‚ÇÅ l‚ÇÇ : filter Œ±) [countable_Inter_filter l‚ÇÅ] [countable_Inter_filter l‚ÇÇ] : countable_Inter_filter (l‚ÇÅ ‚äî l‚ÇÇ)
{x : pgame} (h : 0 ‚â§ x) (j : x.right_moves) : (x.move_right j).left_moves
{R : Type u} [non_assoc_semiring R] (self : subsemiring R) : submonoid R
(L : first_order.language) : Prop
{G : Type u_1} [add_group G] (s : set G) (hsn : s.nonempty) (hs : ‚àÄ (x : G), x ‚àà s ‚Üí ‚àÄ (y : G), y ‚àà s ‚Üí x + -y ‚àà s) : add_subgroup G
{Œ± : Type u_2} {Œ≤ : Type u_3} [decidable_eq Œ≤] [has_vadd Œ± Œ≤] : has_vadd (finset Œ±) (finset Œ≤)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (s : set L) : lie_subalgebra R L
(X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] : Type (max u v)
 : ‚Ñï ‚äï punit ‚âÉ ‚Ñï
(R : Type u) [comm_semiring R] (A : Type v‚ÇÅ) [semiring A] [algebra R A] (B : Type v‚ÇÇ) [semiring B] [algebra R B] (C : Type v‚ÇÉ) [semiring C] [algebra R C] : tensor_product R (tensor_product R A B) C ‚âÉ‚Çê[R] tensor_product R A (tensor_product R B C)
{R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] (K : intermediate_field F E) : ‚Ü•(K.fixing_subgroup) ‚âÉ* E ‚âÉ‚Çê[‚Ü•K] E
{Œ± : Type u_1} [preorder Œ±] {a b : Œ±} (h1 : a ‚â§ b) (h2 : b ‚â§ a) : a ‚©ø b
{n : Type u_1} {ùïú : Type u_3} [field ùïú] [decidable_eq n] [fintype n] (P : matrix n n ùïú ‚Üí Prop) (M : matrix n n ùïú) (hdiag : ‚àÄ (D : n ‚Üí ùïú), (matrix.diagonal D).det = M.det ‚Üí P (matrix.diagonal D)) (htransvec : ‚àÄ (t : matrix.transvection_struct n ùïú), P t.to_matrix) (hmul : ‚àÄ (A B : matrix n n ùïú), P A ‚Üí P B ‚Üí P (A.mul B)) : P M
{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_3} [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] : has_add (normed_group_hom V‚ÇÅ V‚ÇÇ)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) [category_theory.is_iso h.counit] : R ‚ãô L ‚ãô R ‚âÖ R
(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop
{R : Type u} [comm_ring R] {G H : Module R} (f : G ‚ü∂ H) : G ‚ü∂ Module.image f
{Œ± : Type u_1} {Œ≤ : option Œ± ‚Üí Type u_2} : (Œ† (a : option Œ±), Œ≤ a) ‚âÉ Œ≤ option.none √ó Œ† (a : Œ±), Œ≤ (option.some a)
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [topological_space Œ≤] [topological_space.pseudo_metrizable_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] {Œπ : Type u_3} {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (u : filter Œπ) [u.ne_bot] [u.is_countably_generated] (hf : ‚àÄ (i : Œπ), measurable (f i)) (lim : filter.tendsto f u (nhds g)) : measurable g
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] {X : C} (t : category_theory.limits.is_initial X) : 0 ‚âÖ X
{Œ± : Type u} [pseudo_emetric_space Œ±] {x : Œ±} {s : set Œ±} (h : x ‚àà s) : emetric.inf_edist x s = 0
{S : Type u_2} [comm_ring S] {A : Type u_4} [comm_ring A] [algebra A S] {S' : Type u_8} [comm_ring S'] [algebra A S'] [is_domain A] (pb : power_basis A S) (y : S') (hy : ‚áë(polynomial.aeval y) (minpoly A pb.gen) = 0) : S ‚Üí‚Çê[A] S'
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V ‚â§ 1 ‚Üî ‚àÉ (v : V), ‚àÄ (w : V), ‚àÉ (c : K), c ‚Ä¢ v = w
{a : ‚Ñù} {l : filter ‚Ñù} {f g : ‚Ñù ‚Üí ‚Ñù} (hdf : ‚àÄ·∂† (x : ‚Ñù) in nhds a, differentiable_at ‚Ñù f x) (hg' : ‚àÄ·∂† (x : ‚Ñù) in nhds a, deriv g x ‚â† 0) (hfa : filter.tendsto f (nhds a) (nhds 0)) (hga : filter.tendsto g (nhds a) (nhds 0)) (hdiv : filter.tendsto (Œª (x : ‚Ñù), deriv f x / deriv g x) (nhds a) l) : filter.tendsto (Œª (x : ‚Ñù), f x / g x) (nhds_within a (set.univ  {a})) l
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : is_smul_regular M 0 ‚Üî subsingleton M
{Œπ : Type u_1} {R : Œπ ‚Üí Type u_2} {S : Œπ ‚Üí Type u_3} [Œ† (i : Œπ), non_unital_non_assoc_semiring (R i)] [Œ† (i : Œπ), non_unital_non_assoc_semiring (S i)] (e : Œ† (i : Œπ), R i ‚âÉ+* S i) : (Œ† (i : Œπ), R i) ‚âÉ+* Œ† (i : Œπ), S i
(x y : pgame) : Prop
{Œ± : Type u_2} [decidable_eq Œ±] [subtraction_comm_monoid Œ±] : subtraction_comm_monoid (finset Œ±)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : language Œ± ‚Üí+* language Œ≤
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) : Prop
(C : Type u_1) [category_theory.category C] [category_theory.monoidal_category C] : Sort u_3
{G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : fin (add_order_of x) ‚âÉ ‚Ü•‚Üë(add_submonoid.multiples x)
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] (ab : Œ± ‚âÉ·µê Œ≤) : Œ≤ ‚âÉ·µê Œ±
 : environment ‚Üí name ‚Üí bool
 : matrix (fin 7) (fin 7) ‚Ñ§
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D·µí·µñ) [category_theory.limits.preserves_limits F] : category_theory.limits.preserves_colimits F.unop
{Œπ : Type u‚ÇÅ} {k : Type u‚ÇÇ} {V : Type u‚ÇÉ} {P : Type u‚ÇÑ} [add_comm_group V] [add_torsor V P] [ring k] [module k V] (b : affine_basis Œπ k P) {Œπ' : Type u_1} [fintype Œπ'] [fintype Œπ] [decidable_eq Œπ'] (p : Œπ' ‚Üí P) {A : matrix Œπ Œπ' k} (hA : (b.to_matrix p).mul A = 1) : affine_independent k p
{X : Type u} {Œ± : Type v} [topological_space X] [linear_order Œ±] [topological_space Œ±] [order_closed_topology Œ±] [preconnected_space X] {c : Œ±} {f : X ‚Üí Œ±} (hf : continuous f) (h‚ÇÅ : ‚àÉ (a : X), f a ‚â§ c) (h‚ÇÇ : ‚àÉ (b : X), c ‚â§ f b) : c ‚àà set.range f
{Œ± : Type u_1} [pseudo_metric_space Œ±] (C : ‚Ñù) {f : ‚Ñï ‚Üí Œ±} (hu‚ÇÇ : ‚àÄ (n : ‚Ñï), has_dist.dist (f n) (f (n + 1)) ‚â§ C / 2 / 2 ^ n) : cauchy_seq f
{xl xr : Type u_1} {xL : xl ‚Üí pgame} {xR : xr ‚Üí pgame} {yl yr : Type u_1} {yL : yl ‚Üí pgame} {yR : yr ‚Üí pgame} : (pgame.mk xl xr xL xR).lf (pgame.mk yl yr yL yR) ‚Üî (‚àÉ (i : yl), pgame.mk xl xr xL xR ‚â§ yL i) ‚à® ‚àÉ (j : xr), xR j ‚â§ pgame.mk yl yr yL yR
{F : Type u_1} [field F] (p q : polynomial F) (hq : q.nat_degree ‚â† 0) : (p.comp q).gal ‚Üí* p.gal
{G : Type u} {x : G} [monoid G] : 0 < order_of x ‚Üî is_of_fin_order x
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] {S T : convex_cone ùïú E} (h : ‚ÜëS = ‚ÜëT) : S = T
{Œ± : Type u} (s : set (set Œ±)) : cardinal.mk ‚Ü•{t : set Œ± | measurable_space.generate_measurable s t} ‚â§ linear_order.max (cardinal.mk ‚Ü•s) 2 ^ cardinal.aleph_0
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 p3 : P) : p1 -·µ• p3 - (p2 -·µ• p3) = p1 -·µ• p2
(Œ± : Type u_1) (Œ≤ : Type u_2) [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] : Type (max u_1 u_2)
 : adjoin_zero ‚ä£ category_theory.forget‚ÇÇ AddMon AddSemigroup
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {X Z : C} {Y : D} (F : category_theory.over X ‚•§ category_theory.over Y) (G : category_theory.over Y ‚•§ category_theory.over Z) (h‚ÇÅ : ‚àÄ (f : category_theory.mono_over X), category_theory.mono (F.obj ((category_theory.mono_over.forget X).obj f)).hom) (h‚ÇÇ : ‚àÄ (f : category_theory.mono_over Y), category_theory.mono (G.obj ((category_theory.mono_over.forget Y).obj f)).hom) : category_theory.mono_over.lift F h‚ÇÅ ‚ãô category_theory.mono_over.lift G h‚ÇÇ ‚âÖ category_theory.mono_over.lift (F ‚ãô G) _
(p : ‚Ñï) [fact (nat.prime p)] (a : ‚Ñ§) (ha : ‚Üëa ‚â† 0) : zmod.legendre_sym p a ^ 2 = 1
{R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ‚âÉ+* S) : ‚Üëf.to_equiv = ‚Üëf.to_equiv
{Œπ : Type u_1} {Œπ' : Type u_2} {R : Type u_5} {M : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] (e : basis Œπ R M) (v : Œπ' ‚Üí M) : matrix Œπ Œπ' R
(ùïú : Type u_1) (E : Type u_2) (Œπ : Type u_5) [normed_field ùïú] [add_comm_group E] [module ùïú E] : Type (max u_5 u_2)
{C : Type u} [category_theory.category C] (X Y : algebraic_geometry.PresheafedSpace C) : Type v
{Œ± : Type u_2} {Œ≤ : Type u_3} [bornology Œ±] [bornology Œ≤] (f : locally_bounded_map Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : locally_bounded_map Œ± Œ≤
(x : ‚Ñö) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.prod)
(S : set ‚Ñï+) (K : Type w) [field K] (C : Type z) [fintype ‚Ü•S] [comm_ring C] [algebra K C] [is_domain C] [is_cyclotomic_extension S K C] : finite_dimensional K C
(Œ≥ : Type) : Type
{V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] {n : Type w} {B : bilin_form K V} {v : n ‚Üí V} (hv‚ÇÅ : B.is_Ortho v) (hv‚ÇÇ : ‚àÄ (i : n), ¬¨B.is_ortho (v i) (v i)) : linear_independent K v
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {P X Y : C} (f : X ‚ü∂ P) (g : Y ‚ü∂ P) : category_theory.limits.is_colimit (G.map_cocone (category_theory.limits.binary_cofan.mk f g)) ‚âÉ category_theory.limits.is_colimit (category_theory.limits.binary_cofan.mk (G.map f) (G.map g))
{R : Type u_1} [comm_ring R] [is_domain R] (P : cubic R) : multiset R
 : expr ‚Üí bool
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} : b < c ‚Üí a ‚â§ b ‚Üí a < c
 : tactic.itauto.prop ‚Üí tactic.itauto.proof ‚Üí tactic.itauto.context ‚Üí except (tactic.itauto.prop ‚Üí tactic.itauto.proof) tactic.itauto.context
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ D} (H : D ‚•§ C) [category_theory.is_equivalence H] (c : category_theory.limits.cone (F ‚ãô H)) : H.map_cone (H.map_cone_inv c) ‚âÖ c
{R : Type u_1} [mul_zero_class R] (h : is_left_regular 0) : subsingleton R
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] (w : free_product.word M) : option Œπ
{R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ‚Üî group.fg G
(env : environment) (e : expr) : exceptional expr
(Œ± : Type u_2) [cancel_comm_monoid_with_zero Œ±] : Type u_2
{n : ‚Ñï} (Œ± Œ≤ : typevec n) : typevec n
{Œ± : Type u} [topological_space Œ±] [sigma_compact_space Œ±] {f : Œ± ‚Üí set Œ±} (hf : ‚àÄ (x : Œ±), f x ‚àà nhds x) : ‚àÉ (s : set Œ±), s.countable ‚àß (‚ãÉ (x : Œ±) (H : x ‚àà s), f x) = set.univ
{A : Type u_1} [add_comm_monoid A] (a b c : A) : c ‚àà add_submonoid.closure {a, b} ‚Üî ‚àÉ (m n : ‚Ñï), m ‚Ä¢ a + n ‚Ä¢ b = c
 : native.float ‚Üí native.float ‚Üí native.float
{R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] [nontrivial R] {Œπ : Type w} (b : basis Œπ R M) [infinite Œπ] {Œ∫ : Type w} (v : Œ∫ ‚Üí M) (i : linear_independent R v) (m : i.maximal) : cardinal.mk Œπ ‚â§ cardinal.mk Œ∫
{Œπ : Type u_1} {Œ± : Type u_2} {s : Œπ ‚Üí set Œ±} (hs : indexed_partition s) : Type u_2
 : expr ‚Üí tactic omega.int.exprform
{Œ± : Type u_1} [canonically_ordered_add_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b : Œ±} (h : a ‚â§ b) : a - b = 0
(G : Type u_1) [group G] : galois_insertion subgroup.closure coe
{R : Type u_1} [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] : tensor_algebra R M ‚Üí‚Çó[R] M
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) (j : J) : F.obj j ‚ü∂ CommRing.colimits.colimit F
 : interactive.parse (optional interactive.types.ident_) ‚Üí tactic unit
(p : ‚Ñï) [fact (nat.prime p)] : padic_norm p ‚Üëp < 1
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pullbacks C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.epi f] : category_theory.epi category_theory.limits.pullback.snd
(x : ‚Ñù*) : Prop
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {S‚ÇÅ S‚ÇÇ : submodule K V} [finite_dimensional K ‚Ü•S‚ÇÇ] (h : S‚ÇÅ ‚â§ S‚ÇÇ) : finite_dimensional K ‚Ü•S‚ÇÅ
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommSemiRing) : category_theory.limits.is_limit (CommSemiRing.limit_cone F)
{Œì‚ÇÄ : Type u_3} [linear_ordered_add_comm_monoid_with_top Œì‚ÇÄ] [nontrivial Œì‚ÇÄ] {K : Type u_1} [division_ring K] (v : add_valuation K Œì‚ÇÄ) {x : K} : ‚áëv x = ‚ä§ ‚Üî x = 0
(Œ± : Sort u_4) : Prop
{Œ≤ : Type u_1} [add_comm_group Œ≤] (b : Œ≤) (V : Type u_2) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : ùü≠ (category_theory.differential_object (category_theory.graded_object_with_shift b V)) ‚âÖ homological_complex.dgo_to_homological_complex b V ‚ãô homological_complex.homological_complex_to_dgo b V
{Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≥ : Type u_5} [preorder Œ≤] [preorder Œ≥] {f : Œ± ‚Üí Œ≤} {e : Œ≤ ‚Üí Œ≥} {l : filter Œ±} (hm : ‚àÄ (b‚ÇÅ b‚ÇÇ : Œ≤), e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄ (c : Œ≥), ‚àÉ (b : Œ≤), e b ‚â§ c) : filter.tendsto (e ‚àò f) l filter.at_bot ‚Üî filter.tendsto f l filter.at_bot
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] {ùíú : finset (finset Œ±)} {s : finset Œ±} : s ‚àà ùíú.up_shadow ‚Üî ‚àÉ (a : Œ±) (H : a ‚àà s), s.erase a ‚àà ùíú
{M : Type u_3} {N : Type u_4} [has_mul M] [comm_semigroup N] : has_mul (M ‚Üí‚Çô* N)
{R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} [comm_semiring R] [semiring A‚ÇÅ] [semiring A‚ÇÇ] [algebra R A‚ÇÅ] [algebra R A‚ÇÇ] (œï : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ) : (A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÅ) ‚âÉ* A‚ÇÇ ‚âÉ‚Çê[R] A‚ÇÇ
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] {a : Œ±} {f : multiset Œ±} (ha : irreducible a) (pfa : (‚àÄ (b : Œ±), b ‚àà f ‚Üí prime b) ‚àß associated f.prod a) : ‚àÉ (p : Œ±), associated a p ‚àß f = {p}
{Œ± : Type u} {Œ≤ : Type v} [add_semigroup Œ≤] (f : Œ± ‚Üí Œ≤) (x : free_add_semigroup Œ±) : Œ≤
(Œ± : Type u_1) (Œ≤ : Type u_2) : Type u_1
(J : Type v) : category_theory.limits.wide_pushout_shape_op J ‚ãô category_theory.limits.wide_pullback_shape_unop J ‚âÖ ùü≠ (category_theory.limits.wide_pushout_shape J)
{p : ‚Ñï ‚Üí Prop} (x : nat.upto p) (h : ¬¨p x.val) : nat.upto p
{Œ± : Type u} [pseudo_emetric_space Œ±] {Œ¥‚ÇÅ Œ¥‚ÇÇ : ‚Ñù} (hle : Œ¥‚ÇÅ ‚â§ Œ¥‚ÇÇ) (E : set Œ±) : metric.cthickening Œ¥‚ÇÅ E ‚äÜ metric.cthickening Œ¥‚ÇÇ E
{K : Type v} [field K] {p : polynomial K} : polynomial.splits (ring_hom.id K) p ‚Üî ‚áëmultiset.card p.roots = p.nat_degree
{H : Type u} [topological_space H] (G : structure_groupoid H) (M : Type u_5) (M' : Type u_6) [topological_space M] [topological_space M'] [charted_space H M] [charted_space H M'] : Type (max u_5 u_6)
{R : Type u_1} [comm_semiring R] {n : Type u_4} [fintype n] [decidable_eq n] : linear_map.to_matrix (pi.basis_fun R n) (pi.basis_fun R n) = linear_map.to_matrix'
 : Type v
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} : mdifferentiable (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f ‚Üí differentiable ùïú f
{R : Type u_1} [comm_semiring R] {M : submonoid R} (S : Type u_2) [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {T : submonoid P} (Q : Type u_4) [comm_semiring Q] [algebra P Q] [is_localization T Q] (h : R ‚âÉ+* P) (H : submonoid.map h.to_monoid_hom M = T) : S ‚âÉ+* Q
 : ordinal ‚Ü™o pgame
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : category_theory.thin_skeleton C ‚•§ category_theory.thin_skeleton D
(R : Type u) [comm_ring R] : Top.prelocal_predicate (algebraic_geometry.structure_sheaf.localizations R)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {x : E} {s : set E} {t : set F} {y : F} (hs : unique_diff_within_at ùïú s x) (ht : unique_diff_within_at ùïú t y) : unique_diff_within_at ùïú (s √óÀ¢ t) (x, y)
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] {ùíú : ‚Ñï ‚Üí submodule R A} [graded_algebra ùíú] {f : A} {m : ‚Ñï} (f_deg : f ‚àà ùíú m) (x : ‚Ü•(algebraic_geometry.degree_zero_part f_deg)) : A
(p : ‚Ñï) (R : Type u_1) [hp : fact (nat.prime p)] [comm_ring R] [char_p R p] [perfect_ring R p] : witt_vector p R ‚âÉ+* witt_vector p R
(cache_ty : Type) : Type
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) : Type (max u u‚ÇÅ v)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type u} [category_theory.category J] (R : D ‚•§ C) [category_theory.reflective R] [category_theory.limits.has_colimits_of_shape J C] : category_theory.limits.has_colimits_of_shape J D
{M : Type u_1} [add_monoid M] {N : Type u_2} [add_monoid N] {f : M ‚Üí N} (hf : is_add_monoid_hom f) {s : set N} (hs : is_add_submonoid s) : is_add_submonoid (f ‚Åª¬π' s)
 : LinearOrder ‚•§ LinearOrder
(r : interactive.parse interactive.types.texpr) (n : interactive.parse (optional (lean.parser.tk "using" *> lean.parser.small_nat))) : tactic unit
 : omega.eqelim (list omega.ee)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) : Type (max u u‚ÇÅ v)
(A : Type u_2) [comm_ring A] [is_domain A] : Prop
(Œ± : Type u_1) (Œ≤ : Type u_2) [topological_space Œ±] [compact_space Œ±] [metric_space Œ≤] [add_monoid Œ≤] [has_lipschitz_add Œ≤] : C(Œ±, Œ≤) ‚âÉ+ bounded_continuous_function Œ± Œ≤
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] : locally_finite_order Œ±·µí·µà
 : Group ‚•§ CommGroup
(Œ± : fin 2 ‚Üí Type u) [Œ† (i : fin 2), topological_space (Œ± i)] : (Œ† (i : fin 2), Œ± i) ‚âÉ‚Çú Œ± 0 √ó Œ± 1
 : expr ‚Üí expr ‚Üí bool
{R : Type u_1} {M : Type u_3} {M' : Type u_4} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [has_zero M'] [has_scalar R M'] (f : zero_hom M M') (hf : function.surjective ‚áëf) (smul : ‚àÄ (a : R) (b : M), ‚áëf (a ‚Ä¢ b) = a ‚Ä¢ ‚áëf b) : mul_action_with_zero R M'
(g : expr) (t : tactic.tag) : tactic unit
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) [lie_algebra.is_nilpotent R ‚Ü•H] (œá : lie_algebra.lie_character R ‚Ü•H) : Prop
{M : Type u_1} [has_add M] {S T : add_subsemigroup M} (h : S ‚â§ T) : add_hom ‚Ü•S ‚Ü•T
(n : ‚Ñï) : affine.simplex.points_with_circumcenter_index n ‚Üí ‚Ñù
(n : expr) : tactic.norm_fin.eval_fin_m (‚Ñï √ó expr √ó expr)
{Œ± : Type u} : wseq Œ± ‚Üí wseq Œ± ‚Üí wseq Œ±
(Œ± : Type u_4) : Prop
{Œ± : Type u_1} [canonically_ordered_add_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b c : Œ±} [contravariant_class Œ± Œ± has_add.add has_le.le] [contravariant_class Œ± Œ± has_add.add has_lt.lt] (hca : c ‚â§ a) (h : a - b < a - c) : c < b
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] {j j' : C} (f f' : j ‚ü∂ j') : j' ‚ü∂ category_theory.is_filtered.coeq f f'
(e : expr) : expr
{G : Type u_7} [add_group G] (L : list G) : -L.sum = (list.map (Œª (x : G), -x) L).reverse.sum
{n : ‚Ñï} {Œ± : Type u_1} (v : vector Œ± n) (i : fin n) (a : Œ±) : vector Œ± n
(L : first_order.language) {Œ± : Type w} (a : Œ±) : (L.with_constants Œ±).constants
{Œ± : Type u_1} [complete_lattice Œ±] {s : set Œ±} (hs : complete_lattice.set_independent s) : s.pairwise_disjoint id
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (s : set Œ±) (u : set Œ≤) : set C(Œ±, Œ≤)
{R : Type u} [ring R] {Œπ : Type v} [dec_Œπ : decidable_eq Œπ] {M : Type u_1} [add_comm_group M] [module R M] (A : Œπ ‚Üí submodule R M) {i j : Œπ} (hij : i ‚â† j) (h : set.univ = {i, j}) : direct_sum.is_internal A ‚Üî is_compl (A i) (A j)
{Œ± : Type u_1} [metric_space Œ±] {K : nnreal} {f : Œ± ‚Üí Œ±} (hf : contracting_with K f) (g : Œ± ‚Üí Œ±) {x y : Œ±} (hx : function.is_fixed_pt f x) (hy : function.is_fixed_pt g y) {C : ‚Ñù} (hfg : ‚àÄ (z : Œ±), has_dist.dist (f z) (g z) ‚â§ C) : has_dist.dist x y ‚â§ C / (1 - ‚ÜëK)
(X : algebraic_geometry.LocallyRingedSpace) : continuous X.to_Œì_Spec_fun
{G : Type u_10} {H : Type u_11} [add_group G] [subtraction_monoid H] (h : G ‚âÉ+ H) (x : G) : ‚áëh (-x) = -‚áëh x
{a : ‚Ñï} (a1 : 1 < a) (n : ‚Ñï) : ‚Ñ§
{M : Type u_1} {B : Type u_3} [monoid M] [set_like B M] [submonoid_class B M] {S : B} {l : list M} (hl : ‚àÄ (x : M), x ‚àà l ‚Üí x ‚àà S) : l.prod ‚àà S
(p : ‚Ñï ‚Üí Prop) : ‚Ñï ‚Üí ‚Ñï
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] : C
(G : Type u_1) [monoid G] : ¬¨monoid.is_torsion G ‚Üî ‚àÉ (g : G), ¬¨is_of_fin_order g
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : lazy_list Œ± ‚Üí lazy_list Œ≤
{k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k ‚Üí E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : ‚áë(affine_map.line_map (f a) (f b)) r ‚â§ f (‚áë(affine_map.line_map a b) r) ‚Üî slope f (‚áë(affine_map.line_map a b) r) b ‚â§ slope f a b
{M : Type u_1} [mul_one_class M] {c d : con M} (h : c ‚â§ d) (x : c.quotient) : ‚áë(c.map d h) x = ‚áë(c.lift d.mk' _) x
 : vm_decl ‚Üí option pos
{Œ± : Type u} {s : set Œ±} (h : s.finite) : finset Œ±
{Œ± : Type u} [uniform_space Œ±] [(uniformity Œ±).is_countably_generated] (U : ‚Ñï ‚Üí set (Œ± √ó Œ±)) (U_mem : ‚àÄ (n : ‚Ñï), U n ‚àà uniformity Œ±) (HU : ‚àÄ (u : ‚Ñï ‚Üí Œ±), (‚àÄ (N m n : ‚Ñï), N ‚â§ m ‚Üí N ‚â§ n ‚Üí (u m, u n) ‚àà U N) ‚Üí (‚àÉ (a : Œ±), filter.tendsto u filter.at_top (nhds a))) : complete_space Œ±
{C : Type u} [category_theory.category C] [‚àÄ (n : ‚Ñï) (f : category_theory.arrow C), category_theory.limits.has_wide_pushout f.left (Œª (i : ulift (fin (n + 1))), f.right) (Œª (i : ulift (fin (n + 1))), f.hom)] : category_theory.cosimplicial_object.augmented_cech_conerve ‚ä£ category_theory.cosimplicial_object.augmented.to_arrow
 : basis (fin 2) ‚Ñù ‚ÑÇ
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C
{Œ± : Type u} [partial_order Œ±] {a b : Œ±} : a ‚â§ b ‚Üí b ‚â† a ‚Üí a < b
(p : Prop) : Type
(M : Type u_5) (N : Type u_6) [add_zero_class M] [add_zero_class N] : N ‚Üí+ M √ó N
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] (F : Type u_2) (f‚ÇÄ f‚ÇÅ : out_param C(X, Y)) : Type (max u u_2 v)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.is_iso f] : category_theory.split_epi f
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_group Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} : concave_on ùïú s f ‚Üí convex_on ùïú s (-f)
(R : Type u) (M : Type v) (N : Type w) [comm_ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [add_comm_group N] [module R N] [module.free R N] : module.rank R (tensor_product R M N) = (module.rank R M).lift * (module.rank R N).lift
{Œ± : Type v} [linear_order Œ±] [topological_space Œ±] [order_closed_topology Œ±] {s : set Œ±} (hs : is_connected s) {a b : Œ±} (ha : a ‚àà s) (hb : b ‚àà s) : set.Icc a b ‚äÜ s
{k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k ‚Üí E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : f (‚áë(affine_map.line_map a b) r) ‚â§ ‚áë(affine_map.line_map (f a) (f b)) r ‚Üî slope f a b ‚â§ slope f (‚áë(affine_map.line_map a b) r) b
(Œ± : Type u_2) [ordered_semiring Œ±] : Type u_2
{k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] {a : M} {c : k} (hc : c < 0) : a < 0 ‚Üí 0 < c ‚Ä¢ a
{n a : ‚Ñï} (h : a < n + 1) : ‚Üë‚Üëa = a
{Œ± Œ≤ : CompleteLattice} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
{R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (x : A) (r : R) (y : A) : x * ‚áë(algebra_map R A) r * y = x * y * ‚áë(algebra_map R A) r
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_images C] (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.subobject.exists f = category_theory.subobject.map f
{a b : ereal} (h : a ‚â§ -b) : b ‚â§ -a
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (R : D ‚•§ C) (L : C ‚•§ D) (h : L ‚ä£ R) : category_theory.thin_skeleton.map L ‚ä£ category_theory.thin_skeleton.map R
{G : Type u_3} [add_group G] (P : add_subgroup G) : P.fg ‚Üî ‚àÉ (S : set G), add_subgroup.closure S = P ‚àß S.finite
(R : Type u) (Œπ : Type v) [comm_ring R] (L : Œπ ‚Üí Type w) [Œ† (i : Œπ), lie_ring (L i)] [Œ† (i : Œπ), lie_algebra R (L i)] [decidable_eq Œπ] (j : Œπ) : L j ‚Üí‚Çó‚ÅÖR‚ÅÜ direct_sum Œπ (Œª (i : Œπ), L i)
{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] : algebra.is_algebraic R A ‚Üî ‚ä§.is_algebraic
 : tactic unit
{Œ± : Type u} (s : wseq Œ±) (n : ‚Ñï) : computation (list Œ± √ó wseq Œ±)
{Œ± : Type u_1} [decidable_eq Œ±] {s : multiset Œ±} : s.nodup ‚Üí s.dedup = s
 : expr ‚Üí tactic (expr √ó expr)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (S‚ÇÅ S‚ÇÇ : submodule K V) [finite_dimensional K ‚Ü•S‚ÇÇ] : finite_dimensional K ‚Ü•(S‚ÇÅ ‚äì S‚ÇÇ)
{C : Type u} [category_theory.category C] {P Q : C} (f : P ‚ü∂ Q) [category_theory.is_iso f] : category_theory.strong_epi f
{H : Type u_1} [topological_space H] (G : structure_groupoid H) [closed_under_restriction G] : G.local_invariant_prop G G.is_local_structomorph_within_at
{X : Type u} {m‚ÇÅ m‚ÇÇ : X ‚Üí X ‚Üí X} {e‚ÇÅ e‚ÇÇ : X} (h‚ÇÅ : eckmann_hilton.is_unital m‚ÇÅ e‚ÇÅ) (h‚ÇÇ : eckmann_hilton.is_unital m‚ÇÇ e‚ÇÇ) (distrib : ‚àÄ (a b c d : X), m‚ÇÅ (m‚ÇÇ a b) (m‚ÇÇ c d) = m‚ÇÇ (m‚ÇÅ a c) (m‚ÇÅ b d)) : e‚ÇÅ = e‚ÇÇ
{Œ± : Type u_1} [decidable_eq Œ±] (a : option Œ±) : set (equiv.perm Œ±)
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] : group_filter_basis (L ‚âÉ‚Çê[K] L)
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] (s : set Œ±) (t : set Œ≤) : ‚Ü•(s √óÀ¢ t) ‚âÉ·µê ‚Ü•s √ó ‚Ü•t
(p x : ‚Ñù) : Prop
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] : list Œ± ‚Üí list Œ±
(S : set ‚Ñù) (hS : ‚àÄ (x : ‚Ñù), x ‚àà S ‚Üí 0 ‚â§ x) : 0 ‚â§ has_Sup.Sup S
{C : Type u} [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} (F : category_theory.limits.mono_factorisation f) : Type (max u v)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] (T : category_theory.triangulated.triangle C) : (category_theory.triangulated.rotate C).obj ((category_theory.triangulated.inv_rotate C).obj T) ‚ü∂ T
{M : Type u_1} [add_comm_monoid M] [module ‚Ñù M] : module nnreal M
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {s : set E} {f : E ‚Üí F} {n : with_top ‚Ñï} {p : E ‚Üí formal_multilinear_series ùïú E F} (g : F ‚ÜíL[ùïú] G) (hf : has_ftaylor_series_up_to_on n f p s) : has_ftaylor_series_up_to_on n (‚áëg ‚àò f) (Œª (x : E) (k : ‚Ñï), g.comp_continuous_multilinear_map (p x k)) s
(Œ± : Type u_8) : Type u_8
(Œ± : Type u_1) [preorder Œ±] : Preorder
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pushouts C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : Y ‚äû Z ‚ü∂ category_theory.limits.pushout f g
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] {Œπ : Type u_6} [fintype Œπ] (Q : quadratic_form R M) (v : basis Œπ R M) : quadratic_form R (Œπ ‚Üí R)
{Œ± : Type u_1} [linear_ordered_field Œ±] [archimedean Œ±] {x y : Œ±} (hx : 0 < x) (hy : 1 < y) : ‚àÉ (n : ‚Ñ§), x ‚àà set.Ico (y ^ n) (y ^ (n + 1))
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] {Œ± : E} {q : polynomial F} (q_irred : irreducible q) (q_aeval : ‚áë(polynomial.aeval Œ±) q = 0) (hŒ± : is_solvable_by_rad F Œ±) : is_solvable q.gal
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (e : local_homeomorph Œ± Œ≤) {f : Œ≤ ‚Üí Œ≥} {s : set Œ≤} (h : s ‚äÜ e.to_local_equiv.target) : continuous_on f s ‚Üî continuous_on (f ‚àò ‚áëe) (e.to_local_equiv.source ‚à© ‚áëe ‚Åª¬π' s)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) : disjoint K K·óÆ
(R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] : galois_insertion (submodule.span R) coe
{C : Type u} [category_theory.small_category C] [category_theory.limits.has_products C] {X Y : C} : subsingleton (X ‚ü∂ Y)
{C : Type u} [category_theory.category C] {X Y P : C} (œÄ‚ÇÅ : P ‚ü∂ X) (œÄ‚ÇÇ : P ‚ü∂ Y) : category_theory.limits.binary_fan X Y
 : interactive.parse (lean.parser.many interactive.types.ident_) ‚Üí tactic unit
{Œ± : Type} : name ‚Üí widget.html Œ±
{n : ‚Ñï} (m : ‚Ñï) [fin2.is_lt m n] : fin2 n
{Œπ : Type u_1} {ùïú : Type u_3} [is_R_or_C ùïú] {E : Type u_4} [inner_product_space ùïú E] [fintype Œπ] (b : orthonormal_basis Œπ ùïú E) : basis Œπ ùïú E
{Œ± : Type u_1} (h : ¬¨infinite Œ±) : fintype Œ±
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {x : ùïú} {f' : ùïú ‚ÜíL[ùïú] F} : has_fderiv_at f f' x ‚Üî has_deriv_at f (‚áëf' 1) x
(inductive_name : name) (num_params : ‚Ñï) (T : expr) : tactic (list tactic.eliminate.constructor_argument_info)
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), has_zero (Œ± i)] [Œ† (i : Œπ), has_le (Œ± i)] : (Œ†‚ÇÄ (i : Œπ), Œ± i) ‚Ü™o Œ† (i : Œπ), Œ± i
{L : first_order.language} {M : Type w} [L.Structure M] {s : set M} {p : M ‚Üí Prop} {x : M} (h : x ‚àà ‚áë(first_order.language.substructure.closure L) s) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí p x) (Hfun : ‚àÄ {n : ‚Ñï} (f : L.functions n), first_order.language.closed_under f (set_of p)) : p x
{B : Type u} [category_theory.bicategory B] {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : category_theory.bicategory.whisker_right (category_theory.bicategory.left_unitor f).hom g = (category_theory.bicategory.associator (ùüô a) f g).hom ‚â´ (category_theory.bicategory.left_unitor (f ‚â´ g)).hom
{Œ± : Type u_1} [pseudo_emetric_space Œ±] (Œ¥ : ‚Ñù) (E : set Œ±) : Œ± ‚Üí ennreal
{Œ± : Type u} : ordnode Œ± ‚Üí ‚Ñï ‚Üí ordnode Œ± √ó ordnode Œ±
{n : Type u_4} {Œ± : Type u_5} [fintype n] [normed_ring Œ±] [decidable_eq n] : normed_ring (matrix n n Œ±)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p‚ÇÅ p‚ÇÇ : Œπ ‚Üí P) : s.sum (Œª (i : Œπ), w i ‚Ä¢ (p‚ÇÅ i -·µ• p‚ÇÇ i)) = ‚áë(s.affine_combination p‚ÇÅ) w -·µ• ‚áë(s.affine_combination p‚ÇÇ) w
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÇ] [has_one M‚ÇÇ] [mul_one_class M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) : mul_one_class M‚ÇÇ
 : smt_tactic unit
 : Type u ‚•§ Type (max u v)
(X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] (x : X) : Gromov_Hausdorff.optimal_GH_coupling X Y
 : Type
{n : ‚Ñï} (m : ‚Ñï) : fin n ‚Ü™o fin (n + m)
{G : Type u} [add_group G] (H N : add_subgroup G) [N.normal] : ‚Ü•H ‚ß∏ add_subgroup.comap H.subtype (H ‚äì N) ‚âÉ+ ‚Ü•(H ‚äî N) ‚ß∏ add_subgroup.comap (H ‚äî N).subtype N
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {L‚ÇÇ : Type w} [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÇ] (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : L ‚Üí‚Çô‚Çê[R] L‚ÇÇ
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] : equiv.perm {a // p a} √ó equiv.perm {a // ¬¨p a} ‚Üí* equiv.perm Œ±
 : Type v
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : normed_group_hom M (M ‚ß∏ S)
{Œ± : Type u_1} [preorder Œ±] [pred_order Œ±] {a b : Œ±} [no_min_order Œ±] : order.pred a ‚â§ order.pred b ‚Üí a ‚â§ b
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] {J : Type v} [fintype J] [category_theory.limits.preserves_colimits_of_shape (category_theory.discrete J) F] : category_theory.limits.preserves_biproducts_of_shape J F
{T : Type u‚ÇÅ} [category_theory.category T] {X Y : T} (f : X ‚ü∂ Y) : category_theory.under Y ‚•§ category_theory.under X
{Œ± : Type} {rels : set (free_group Œ±)} (x : Œ±) : presented_group rels
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : is_preconnected s ‚Üî ‚àÄ (u v : set Œ±), is_closed u ‚Üí is_closed v ‚Üí s ‚äÜ u ‚à™ v ‚Üí s ‚à© (u ‚à© v) = ‚àÖ ‚Üí s ‚äÜ u ‚à® s ‚äÜ v
{K : Type u} [division_ring K] {K' : Type u_1} [has_zero K'] [has_mul K'] [has_add K'] [has_neg K'] [has_sub K'] [has_one K'] [has_inv K'] [has_div K'] [has_scalar ‚Ñï K'] [has_scalar ‚Ñ§ K'] [has_pow K' ‚Ñï] [has_pow K' ‚Ñ§] (f : K' ‚Üí K) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : K'), f (x + y) = f x + f y) (mul : ‚àÄ (x y : K'), f (x * y) = f x * f y) (neg : ‚àÄ (x : K'), f (-x) = -f x) (sub : ‚àÄ (x y : K'), f (x - y) = f x - f y) (inv : ‚àÄ (x : K'), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : K'), f (x / y) = f x / f y) (nsmul : ‚àÄ (x : K') (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : K') (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : K') (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : K') (n : ‚Ñ§), f (x ^ n) = f x ^ n) : division_ring K'
{Œ± : Type u_2} (l : filter Œ±) : Prop
 : list expr ‚Üí expr ‚Üí tactic expr
{C : Type u} [category_theory.category C] {X Y Z : algebraic_geometry.PresheafedSpace C} (f : X ‚ü∂ Z) [hf : algebraic_geometry.PresheafedSpace.is_open_immersion f] (g : Y ‚ü∂ Z) (H : set.range ‚áë(g.base) ‚äÜ set.range ‚áë(f.base)) : Y ‚ü∂ X
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) {Z : C} (g : Y ‚ü∂ Z) [category_theory.limits.has_equalizers C] [category_theory.limits.has_image g] [category_theory.limits.has_image (f ‚â´ g)] [category_theory.epi f] : category_theory.epi (category_theory.limits.image.pre_comp f g)
(les : list omega.term) : omega.eqelim unit
{Œ± : Type u} [add_group Œ±] (x : free_group Œ±) : Œ±
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (q : Œ† (i : fin (n + 1)), Œ± i) (i : fin n) (y : Œ± i.succ) : fin.tail (function.update q i.succ y) = function.update (fin.tail q) i y
{Œ± : Sort u_1} {ra ra' : Œ± ‚Üí Œ± ‚Üí Prop} (h : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±), ra a‚ÇÅ a‚ÇÇ ‚Üí ra' a‚ÇÅ a‚ÇÇ) : quot ra ‚Üí quot ra'
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (P Q : category_theory.idempotents.karoubi C) : (P ‚ü∂ Q) ‚Üí+ (P.X ‚ü∂ Q.X)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_images C] (f : X ‚ü∂ Y) [category_theory.limits.has_pullbacks C] : category_theory.subobject.exists f ‚ä£ category_theory.subobject.pullback f
(H : Type u_1) [topological_space H] (G : structure_groupoid H) : has_groupoid H G
{n : ‚Ñï} (x y : bitvec n) (b : bool) : bool √ó bitvec n
{L : first_order.language} {L' : first_order.language} {L'' : first_order.language} (e : L ‚âÉ·¥∏ L') (e' : L' ‚âÉ·¥∏ L'') : L ‚âÉ·¥∏ L''
{C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} {f : X ‚ü∂ Y} (H : algebraic_geometry.PresheafedSpace.is_open_immersion f) (U : topological_space.opens ‚Ü•Y) (hU : ‚ÜëU ‚äÜ set.range ‚áë(f.base)) : f.c.app (opposite.op U) ‚â´ H.inv_app ((topological_space.opens.map f.base).obj U) = Y.presheaf.map (category_theory.eq_to_hom _).op
{Œ± : Type u_1} [linear_order Œ±] (s : finset Œ±) {k : ‚Ñï} (h : s.card = k) : fin k ‚Ü™o Œ±
{n : ‚Ñï} (p : fin (n + 1)) (i : fin n) : ‚áë(p.succ_above) i < p ‚Üî ‚áëfin.cast_succ i < p
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) : hb.oangle x (-y) + hb.oangle y (-x) = 0
{Œ± : Type u_3} [semilattice_sup Œ±] (a : Œ±) : filter.at_top = filter.comap coe filter.at_top
{Œ± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {c : ‚Ñù} {f : Œ± ‚Üí E} {g' : Œ± ‚Üí F'} {l : filter Œ±} : asymptotics.is_O_with c l f (Œª (x : Œ±), -g' x) ‚Üí asymptotics.is_O_with c l f g'
(Œ± : Type u) [omega_complete_partial_order Œ±] (s : set Œ±) : Prop
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Œπ] (p : Œπ ‚Üí P) {n : ‚Ñï} (hc : fintype.card Œπ = n + 1) : finite_dimensional.finrank k ‚Ü•(vector_span k (set.range p)) ‚â§ n
{R : Type u_1} {M : Type u_5} [comm_ring R] [add_comm_group M] [module R M] (B : M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R) : submodule R (module.End R M)
(q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) : tactic unit
{M : Type u_1} [add_semigroup M] : stream M ‚Üí set M
{K : Type u} [field K] (s : set K) : subfield K
(Œ± : Type u_1) : list Œ± ‚âÉ lazy_list Œ±
{R : Type u_1} [comm_semiring R] (r : R) : polynomial R ‚Üí‚Çê[R] polynomial R
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) : real.angle
{Œ± : Type u} [decidable_eq Œ±] (L‚ÇÅ : list (Œ± √ó bool)) : list (list (Œ± √ó bool))
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J ‚Üí C) [category_theory.limits.has_biproduct f] (b : J) : ‚®Å f ‚ü∂ f b
{n : ‚Ñï} {p : fin n ‚Üí Prop} [decidable_pred p] : ‚Ü•((fin.find p).is_some) ‚Üî ‚àÉ (i : fin n), p i
{a b : simplex_category} (f : fin (a.len + 1) ‚Üío fin (b.len + 1)) : a.hom b
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : ‚Üë(affine_span k s) = span_points k s
(c : char) : parser unit
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [comm_semiring k] [add_monoid G] {A : Type u‚ÇÉ} [semiring A] [algebra k A] (F : add_monoid_algebra k G ‚Üí‚Çê[k] A) (f : monoid_algebra k G) : ‚áëF f = finsupp.sum f (Œª (a : G) (b : k), b ‚Ä¢ ‚áëF (finsupp.single a 1))
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {n : with_top ‚Ñï} {f g : E ‚Üí ùïú} (hf : cont_diff ùïú n f) (hg : cont_diff ùïú n g) : cont_diff ùïú n (Œª (x : E), f x * g x)
(cl : tactic.closure) : list (expr √ó expr) ‚Üí expr ‚Üí tactic unit
{C : Type u} [category_theory.category C] (T : category_theory.monad C) : category_theory.kleisli T ‚•§ C
{C : Type u} [category_theory.category C] (J‚ÇÅ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : S ‚â§ J‚ÇÅ.close S
(x y : ‚Ñï) : ‚Ñ§
{Œ± : Sort u_1} (h : nonempty Œ±) : Œ±
(n : ‚Ñï) : (finset.range n).sum (Œª (i : ‚Ñï), i) = n * (n - 1) / 2
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {x : E} {n : with_top ‚Ñï} {p : E ‚Üí formal_multilinear_series ùïú E F} (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ‚â§ n) (hx : s ‚àà nhds x) : ‚àÄ·∂† (y : E) in nhds x, has_fderiv_at f (‚áë(continuous_multilinear_curry_fin1 ùïú E F) (p y 1)) y
(x y : ‚Ñï) : ‚Ñ§
{R : Type u_1} {Œπ : Type u_2} {M : Type u_3} [ring R] [add_comm_group M] [module R M] [fintype Œπ] [is_artinian R M] : is_artinian R (Œπ ‚Üí M)
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b : Œ±} : a < -b ‚Üí b < -a
(G : Type u_10) [has_involutive_inv G] : equiv.perm G
 : tactic unit
 : expr ‚Üí bool
(n : Type u_1) (R : Type u‚ÇÇ) [decidable_eq n] [comm_ring R] [fintype n] : lie_subalgebra R (matrix n n R)
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.limits.has_initial C] : C
{K : Type u_1} [is_R_or_C K] : ‚Ñù ‚Üí+* K
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] (f‚ÇÅ : measure_theory.simple_func Œ± Œ≥) (g : Œ± ‚Üí Œ≤) (hg : measurable_embedding g) (f‚ÇÇ : measure_theory.simple_func Œ≤ Œ≥) : measure_theory.simple_func Œ≤ Œ≥
(R : Type u_1) [add_group R] [star_add_monoid R] : add_subgroup R
{Œ≤ : Type w} {C : Type u} [category_theory.category C] {f g : Œ≤ ‚Üí C} [category_theory.limits.has_coproduct f] [category_theory.limits.has_coproduct g] (p : Œ† (b : Œ≤), f b ‚ü∂ g b) : ‚àê f ‚ü∂ ‚àê g
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [comm_ring ùïú] [add_comm_group E] [add_comm_group F] [add_comm_group G] [module ùïú E] [module ùïú F] [module ùïú G] [topological_space E] [topological_space F] [topological_space G] [topological_add_group E] [has_continuous_const_smul ùïú E] [topological_add_group F] [has_continuous_const_smul ùïú F] [topological_add_group G] [has_continuous_const_smul ùïú G] (q : formal_multilinear_series ùïú F G) (p : formal_multilinear_series ùïú E F) (v : fin 1 ‚Üí E) : ‚áë(q.comp p 1) v = ‚áë(q 1) (Œª (i : fin 1), ‚áë(p 1) v)
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [add_comm_monoid Œπ] [Œ† (i : Œπ), add_comm_monoid (A i)] : Type (max u_1 u_2)
 : Type u ‚•§ category_theory.SheafOfTypes category_theory.types_grothendieck_topology
 : lean.parser string
{Œ± : Type u_1} [topological_space Œ±] [non_assoc_ring Œ±] (h : topological_semiring Œ±) : topological_ring Œ±
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [non_unital_semiring Œ≤] : non_unital_semiring Œ±
(ps : expr) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum)
{Œ± : Type u} [partial_order Œ±] {a b : Œ±} (h : a ‚â§ b) : a = b ‚à® a < b
{B : Type u} [category_theory.bicategory B] {a b : B} (f g : a ‚ü∂ b) [category_theory.bicategory.lift_hom f] [category_theory.bicategory.lift_hom g] [category_theory.bicategory.bicategorical_coherence f g] : f ‚âÖ g
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] [t2_space M‚ÇÇ] {s : set M‚ÇÅ} {f g : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (h : set.eq_on ‚áëf ‚áëg s) : set.eq_on ‚áëf ‚áëg (closure ‚Üë(submodule.span R‚ÇÅ s))
(c : tactic.instance_cache) : expr ‚Üí tactic (tactic.instance_cache √ó expr)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (C : homological_complex V c) [category_theory.limits.has_zero_object V] (j : Œπ) : V
(C : Type u‚ÇÅ) [category_theory.category C] : C·µí·µñ √ó (C·µí·µñ ‚•§ Type v‚ÇÅ) ‚•§ Type (max u‚ÇÅ v‚ÇÅ)
 : expr ‚Üí ‚Ñï ‚Üí tactic (list expr √ó expr)
{M : Type u_1} [has_mul M] : has_coe_to_fun (con M) (Œª (_x : con M), M ‚Üí M ‚Üí Prop)
(t : expr) : tactic (list name)
(cache : norm_cast.norm_cast_cache) (e : expr) : tactic norm_cast.norm_cast_cache
{f‚ÇÅ f‚ÇÇ : circle_deg1_lift} (h‚ÇÅ : is_unit f‚ÇÅ) (h‚ÇÇ : is_unit f‚ÇÇ) (h : f‚ÇÅ.translation_number = f‚ÇÇ.translation_number) : ‚àÉ (F : circle_deg1_lift), function.semiconj ‚áëF ‚áëf‚ÇÅ ‚áëf‚ÇÇ
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] {D : Type u‚ÇÉ} [category_theory.bicategory D] (F : category_theory.oplax_functor B C) (G : category_theory.oplax_functor C D) : category_theory.oplax_functor B D
{E : Type u_1} [inner_product_space ‚Ñù E] {n : ‚Ñï} (hn : 0 < n) (h : finite_dimensional.finrank ‚Ñù E = n) (x : orientation ‚Ñù E (fin n)) : basis (fin n) ‚Ñù E
(Œ± : Type u) [metric_space Œ±] [topological_space.separable_space Œ±] : isometry (Kuratowski_embedding Œ±)
{ùïú : Type u_1} {F : Type u_3} [is_R_or_C ùïú] [add_comm_group F] [module ùïú F] [c : inner_product_space.core ùïú F] {x y : F} : has_inner.inner (x + y) (x + y) = has_inner.inner x x + has_inner.inner x y + has_inner.inner y x + has_inner.inner y y
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [metric_space Œ≤] [has_zero Œ≤] {Œπ : Type u_1} {F : Œπ ‚Üí zero_at_infty_continuous_map Œ± Œ≤} {f : zero_at_infty_continuous_map Œ± Œ≤} {l : filter Œπ} : filter.tendsto F l (nhds f) ‚Üî tendsto_uniformly (Œª (i : Œπ), ‚áë(F i)) ‚áëf l
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) (h : is_unit A.det) : invertible A
(F : Type u ‚Üí Type u) [functor F] [q : qpf F] : Type u
{Œ± : Type u_1} [measurable_space Œ±] : function.injective measure_theory.jordan_decomposition.to_signed_measure
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {s : set E} {f : E ‚Üí F} {n : with_top ‚Ñï} (e : F ‚âÉL[ùïú] G) : cont_diff_on ùïú n (‚áëe ‚àò f) s ‚Üî cont_diff_on ùïú n f s
(N i : ‚Ñï) : ‚Ñï
(cache : norm_cast.norm_cast_cache) (e : expr) : tactic norm_cast.norm_cast_cache
{K : Type u_3} [field K] {L : Type u_4} [field L] [algebra K L] {x : L} (hx : is_integral K x) : power_basis K ‚Ü•K‚üÆx‚üØ
{R : Type u} [semiring R] {M : Type u_1} [linear_ordered_add_comm_monoid M] [module R M] (S : submodule R M) : linear_ordered_add_comm_monoid ‚Ü•S
(e : expr) : tactic (expr √ó expr)
 : name ‚Üí vm vm_decl
{Œì : Type u_1} {R : Type u_2} [partial_order Œì] [semiring R] (a : Œì) : R ‚Üí‚Çó[R] hahn_series Œì R
{M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a ‚àà s) : multiples a ‚äÜ s
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} [proper_space Œ±] (hc : is_closed s) (hb : metric.bounded s) : is_compact s
{n : ‚Ñï} {Œ± : Type u_1} (l : list Œ±) (c : composition n) {i : ‚Ñï} (hi : i < (l.split_wrt_composition c).length) : (l.split_wrt_composition c).nth_le i hi = list.drop (c.size_up_to i) (list.take (c.size_up_to (i + 1)) l)
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (O : finset C) (H : finset (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y)) : C
 : category_theory.unbundled_hom uniform_continuous
{R : Type u} [comm_ring R] (s : set R) : set (prime_spectrum R)
(a : ‚Ñ§) : ‚Ñ§ ‚ß∏ ideal.span {a} ‚âÉ+* zmod a.nat_abs
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_images C] [category_theory.limits.has_binary_coproducts C] {A : C} (f g : category_theory.mono_over A) : g ‚ü∂ (category_theory.mono_over.sup.obj f).obj g
(L : first_order.language) (Œ± : Type u') : ‚Ñï ‚Üí Type (max u v u')
{s : ‚ÑÇ} (hs : 0 < s.re) : measure_theory.integrable_on (Œª (x : ‚Ñù), ‚Üë(real.exp (-x)) * ‚Üëx ^ (s - 1)) (set.Ioi 0) measure_theory.measure_space.volume
{C : Type u‚ÇÅ} [category_theory.category C] {B : C} (X Y : category_theory.subobject B) (h : X ‚â§ Y) : ‚ÜëX ‚ü∂ ‚ÜëY
(p : ‚Ñï) [hp : fact (nat.prime p)] : ‚Ñï ‚Üí mv_polynomial (fin 0 √ó ‚Ñï) ‚Ñ§
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) (c : category_theory.limits.cone (K ‚ãô F)) : Type (max u‚ÇÅ v‚ÇÅ v‚ÇÇ w)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring ùïú] [add_comm_group E] [add_comm_group F] [module ùïú E] [module ùïú F] {a b : ùïú} {x y : E} {f : E ‚Üí·µÉ[ùïú] F} (h : a + b = 1) : ‚áëf (a ‚Ä¢ x + b ‚Ä¢ y) = a ‚Ä¢ ‚áëf x + b ‚Ä¢ ‚áëf y
(C : Type u) [category_theory.category C] : C ‚âå category_theory.ulift_hom (ulift C)
{Œ± : Type u} (Œ≤ : Œ± ‚Üí Type v) : Type (max u v)
{M : Type u_1} [monoid M] {s : set M} {a : M} (h : a ‚àà monoid.closure s) : ‚àÉ (l : list M), (‚àÄ (x : M), x ‚àà l ‚Üí x ‚àà s) ‚àß l.prod = a
(R : Type u‚ÇÅ) {L : Type u‚ÇÇ} [comm_ring R] [lie_ring L] [lie_algebra R L] : L ‚Üí‚Çó‚ÅÖR‚ÅÜ universal_enveloping_algebra R L
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} (hab : a < b) (hbc : b = c) : a < c
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} [fintype Œπ] {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (l : Œπ ‚Üí ùïú) (i : Œπ) : has_inner.inner (v i) (finset.univ.sum (Œª (i : Œπ), l i ‚Ä¢ v i)) = l i
{Œ± : Type u_1} [comm_monoid Œ±] [decidable_rel has_dvd.dvd] {a b : Œ±} : a ‚à£ b ‚Üí 0 < multiplicity a b
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) : ‚Ü•N ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M
{Œ± : Type u_2} [decidable_eq Œ±] [has_zero Œ±] [has_add Œ±] [has_neg Œ±] : has_scalar ‚Ñ§ (finset Œ±)
 : tactic unit
{Œ± : Type u_1} [topological_space Œ±] {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] [has_continuous_add Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : upper_semicontinuous f) (hg : upper_semicontinuous g) : upper_semicontinuous (Œª (z : Œ±), f z + g z)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : category_theory.adjunction.core_hom_equiv F G) : F ‚ä£ G
(R : Type u) {B : Type v} [comm_ring R] [decidable_eq B] [fintype B] (A : matrix B B ‚Ñ§) : B √ó B ‚Üí free_lie_algebra R (cartan_matrix.generators B)
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {g : Œ≤ ‚Üí Œ±} (hg : function.injective g) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà set.range g), f i)) = finprod (Œª (j : Œ≤), f (g j))
{R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Œπ : Type u_1} {s : set Œπ} (b : basis ‚Ü•s R M) (h : module.rank R M < cardinal.aleph_0) : s.finite
(v : ‚Ñï ‚Üí ‚Ñï) : omega.nat.preterm ‚Üí ‚Ñï
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (wf : well_founded r) (x : Œ±) : Œ±
(n : ‚Ñï) : list bool
{p : real.angle ‚Üí Prop} (Œ∏ : real.angle) (h : ‚àÄ (x : ‚Ñù), p ‚Üëx) : p Œ∏
(Œ± : Type u_1) [boolean_algebra Œ±] : BoolAlg
{Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] {f : Œπ ‚Üí Œ±} (H : bdd_below (set.range f)) (c : Œπ) : infi f ‚â§ f c
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : Type u_1
{C : Type u‚ÇÅ} [category_theory.category C] {T T' : C} (hT : category_theory.limits.is_terminal T) (hT' : category_theory.limits.is_terminal T') : T ‚âÖ T'
{A : Type u_1} [comm_ring A] [algebra ‚Ñö A] : power_series.exp A * ‚áëpower_series.eval_neg_hom (power_series.exp A) = 1
{Œ± : Type u} (l : list Œ±) (s : stream Œ±) : stream (list Œ±)
{R : Type u} [comm_semiring R] {A : Type v‚ÇÅ} [semiring A] [algebra R A] {B : Type v‚ÇÇ} [semiring B] [algebra R B] : A ‚Üí‚Çê[R] tensor_product R A B
{A : Type u_3} [add_group A] (s : set A) : Prop
(e : expr) : tactic expr
 : parser ‚Ñï
{Œ± : fin 0 ‚Üí Sort u} (x : fin 0) : Œ± x
{K : Type u_1} {n : ‚Ñï} {g : generalized_continued_fraction K} [division_ring K] {m : ‚Ñï} : m ‚â§ n ‚Üí g.continuants_aux m = (g.squash_gcf n).continuants_aux m
(s : finset ‚Ñï) {n : ‚Ñï} (h : ‚àÄ (m : ‚Ñï), m ‚àà s ‚Üí m < n) : finset (fin n)
{n : ‚Ñï} {p : fin n ‚Üí Prop} [decidable_pred p] {i : fin n} (hi : i ‚àà fin.find p) {j : fin n} (hj : j < i) : ¬¨p j
{R : Type u} [ring R] : smul_comm_class ‚Ü•(subring.center R) R R
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [unique_factorization_monoid Œ±] [normalization_monoid Œ±] [decidable_eq Œ±] (n : Œ±) : Œ± ‚Üí‚ÇÄ ‚Ñï
(ùïú : Type u_1) {E : Type u_3} [semi_normed_ring ùïú] [has_scalar ùïú E] (A : set E) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} : has_coe_to_fun (r ‚Üír s) (Œª (_x : r ‚Üír s), Œ± ‚Üí Œ≤)
(curr new : name) : tactic unit
{Œπa : Type u_7} {Œπb : Type u_8} [decidable_eq Œπa] [decidable_eq Œπb] [fintype Œπa] [fintype Œπb] {R' : Type u_9} {M·µ¢ : Type u_10} {N‚ÇÅ : Type u_11} {N‚ÇÇ : Type u_12} [comm_semiring R'] [add_comm_group N‚ÇÅ] [module R' N‚ÇÅ] [add_comm_group N‚ÇÇ] [module R' N‚ÇÇ] [add_comm_monoid M·µ¢] [module R' M·µ¢] (a : multilinear_map R' (Œª (_x : Œπa), M·µ¢) N‚ÇÅ) (b : multilinear_map R' (Œª (_x : Œπb), M·µ¢) N‚ÇÇ) : ‚Üë(‚áëmultilinear_map.alternatization a).dom_coprod ‚Üë(‚áëmultilinear_map.alternatization b) = finset.univ.sum (Œª (œÉa : equiv.perm Œπa), finset.univ.sum (Œª (œÉb : equiv.perm Œπb), ‚áëequiv.perm.sign œÉa ‚Ä¢ ‚áëequiv.perm.sign œÉb ‚Ä¢ (multilinear_map.dom_dom_congr œÉa a).dom_coprod (multilinear_map.dom_dom_congr œÉb b)))
(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : free_algebra R M ‚Üí free_algebra R M ‚Üí Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} (A : set (Œ± ‚Üí Œ≤)) : Prop
(h : expr) : tactic (list expr)
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} : (M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí+ M ‚Üí+ M‚ÇÇ
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] {p p' : submodule R M} (h : p ‚â§ p') : ‚Ü•p ‚Üí‚Çó[R] ‚Ü•p'
{Œ± : Type u_2} [decidable_eq Œ±] [add_monoid Œ±] : finset Œ± ‚Üío ‚Ñï
 : interactive.parse interactive.types.pexpr_list_or_texpr ‚Üí tactic unit
{X : Type u_1} {M : Type u_2} [topological_space X] [monoid M] [topological_space M] [has_continuous_mul M] : C(X, MÀ£) ‚âÉ C(X, M)À£
 : environment ‚Üí name ‚Üí environment
{Œ± : Type u} {l‚ÇÅ l‚ÇÇ : list Œ±} (i : ‚Ñï) : list.take (l‚ÇÅ.length + i) (l‚ÇÅ ++ l‚ÇÇ) = l‚ÇÅ ++ list.take i l‚ÇÇ
 : has_add ordinal
(p : ‚Ñï) [fact (nat.prime p)] : Type
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} [category_theory.limits.has_coequalizer f g] [category_theory.mono (category_theory.limits.coequalizer.œÄ f g)] : f = g
{C : Type u} [category_theory.category C] [category_theory.enough_projectives C] [category_theory.abelian C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.exact (category_theory.projective.d f) f
{C D : Type u} [category_theory.category C] [category_theory.category D] (A : Type w) [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (hG : category_theory.cover_lifting J K G) : category_theory.Sheaf J A ‚•§ category_theory.Sheaf K A
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b c : Œ±} : a + b ‚â§ c ‚Üí a ‚â§ c - b
{C : Type u} [category_theory.category C] {A B : C} (f g : A ‚ü∂ B) [category_theory.is_reflexive_pair f g] : B ‚ü∂ A
(R : Type u_1) (V : Type u_18) (V‚ÇÇ : Type u_19) [semiring R] : (V √ó V‚ÇÇ ‚Üí R) ‚âÉ‚Çó[R] V ‚Üí V‚ÇÇ ‚Üí R
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [decidable_eq Œ±] (lcm : Œ± ‚Üí Œ± ‚Üí Œ±) (dvd_lcm_left : ‚àÄ (a b : Œ±), a ‚à£ lcm a b) (dvd_lcm_right : ‚àÄ (a b : Œ±), b ‚à£ lcm a b) (lcm_dvd : ‚àÄ {a b c : Œ±}, c ‚à£ a ‚Üí b ‚à£ a ‚Üí lcm c b ‚à£ a) : gcd_monoid Œ±
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (f g : G ‚Üí+ N) : add_subgroup G
 : Type
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {p : E √ó F} : cont_diff_at ùïú n prod.snd p
{M : Type u_1} [mul_one_class M] {c : con M} : inhabited c.quotient
{G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : fin (order_of x) ‚âÉ ‚Ü•‚Üë(submonoid.powers x)
{Œπ : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] (A : Œπ ‚Üí S) (a : R) : Prop
 : free_group unit ‚âÉ ‚Ñ§
{V : Type u_1} [quiver V] (H : wide_subquiver V) : quiver ‚Ü•H
{R : Type u} {Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] {Œπ' : Type u_1} {M' : Œπ' ‚Üí Type u_2} [Œ† (i : Œπ'), add_comm_monoid (M' i)] [Œ† (i : Œπ'), topological_space (M' i)] [Œ† (i : Œπ'), module R (M' i)] : (Œ† (i : Œπ'), continuous_multilinear_map R M‚ÇÅ (M' i)) ‚âÉ continuous_multilinear_map R M‚ÇÅ (Œ† (i : Œπ'), M' i)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {T : D} {S : C ‚•§ D} {f f' : category_theory.costructured_arrow S T} (g : f.left ‚âÖ f'.left) (w : S.map g.hom ‚â´ f'.hom = f.hom) : f ‚âÖ f'
(R : Type u) [semiring R] : polynomial R ‚âÉ+* add_monoid_algebra R ‚Ñï
(a : Prop) : Prop
(f : ‚Ñï ‚Üí Type u) : (Œ£ (n : ‚Ñï), f n) ‚âÉ f 0 ‚äï Œ£ (n : ‚Ñï), f (n + 1)
{R : Type u_1} [ring R] (P : cubic R) : R
{K : Type u_1} [is_R_or_C K] : ‚Ñù ‚Üí+* K
{T : Type u} [category_theory.category T] {f g : category_theory.arrow T} {u : f.left ‚ü∂ g.left} {v : f.right ‚ü∂ g.right} (w : u ‚â´ g.hom = f.hom ‚â´ v) : f ‚ü∂ g
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_lt.lt] {a b : Œ±} (ha : a < 1) (hb : b < 1) : a * b < 1
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ‚Ñù P) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : P
{Œ± : Type u_3} {Œ≤ : Type u_4} [has_sup Œ±] [has_bot Œ±] [has_sup Œ≤] [has_bot Œ≤] (f : sup_bot_hom Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : sup_bot_hom Œ± Œ≤
{F : Type u ‚Üí Type u} [functor F] [q : qpf F] {Œ± : Type u} (g : F Œ± ‚Üí Œ±) : (qpf.P F).W ‚Üí Œ±
(n : ‚Ñï) : Type
{Œ± : Type u} [comm_semiring Œ±] (x y : Œ±) (n : ‚Ñï) : (finset.range n).sum (Œª (i : ‚Ñï), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] {G : Type u_4} [add_comm_group G] [module R G] (f : linear_pmap R E G) (g : linear_pmap R F G) : linear_pmap R (E √ó F) G
{Œ± : Type u_2} [decidable_eq Œ±] {ùíú : finset (finset Œ±)} {m n : ‚Ñï} (hùíú : is_antichain has_subset.subset ‚Üëùíú) : disjoint (ùíú.slice m) (finset.falling n ùíú).shadow
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {t : affine.triangle ‚Ñù P} (ho : t.orthocenter ‚àâ set.range t.points) {p : fin 3 ‚Üí P} (hps : set.range p ‚äÜ has_insert.insert t.orthocenter (set.range t.points)) (hpi : function.injective p) : ‚àÉ (c : P) (H : c ‚àà affine_span ‚Ñù (set.range t.points)), ‚àÄ (p‚ÇÅ : P), p‚ÇÅ ‚àà set.range p ‚Üí has_dist.dist p‚ÇÅ c = affine.simplex.circumradius t
{Œ± : Type u} : list (Œ± √ó bool) ‚Üí list (Œ± √ó bool) ‚Üí Prop
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (f : M ‚Üí* N) (hf : ‚àÄ (x y : M), commute (‚áëf x) (‚áëf y)) : M·µê·µí·µñ ‚Üí* N
{gen : Type u} [random_gen gen] (g : gen) (lo hi : ‚Ñï) : ‚Ñï √ó gen
{Œ± : Type u_1} [decidable_eq Œ±] (l : list Œ±) : decidable ‚Üël.nontrivial
{Œ± : Type u} : multiplicative Œ± ‚âÉ Œ±
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) : 1 ‚àà s
{Œ± : Type u} : ordnode Œ± ‚Üí option (ordnode Œ± √ó Œ±)
{S : Type u} [pgame.state S] (s : S) : game
(x y : string) : bool
(n p : ‚Ñï) : polynomial.eval ‚Üën (polynomial.bernoulli p.succ) = bernoulli p.succ + (‚Üëp + 1) * (finset.range n).sum (Œª (k : ‚Ñï), ‚Üëk ^ p)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] {v : E} (hv : v ‚àà K·óÆ) : ‚áë(orthogonal_projection K) v = 0
{Œ± : Type u} {Œ≤ : Type v} {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} [partial_order Œ≤] [preorder Œ±] [order_top Œ±] (gi : galois_insertion l u) : order_top Œ≤
{Œ± : Type u_1} [decidable_eq Œ±] (P : Œ± ‚Üí Prop) (r : Œ± ‚Üí Œ± ‚Üí Prop) (h : ‚àÄ (s : finset Œ±), ‚àÉ (y : Œ±), (‚àÄ (x : Œ±), x ‚àà s ‚Üí P x) ‚Üí (P y ‚àß ‚àÄ (x : Œ±), x ‚àà s ‚Üí r x y)) : ‚Ñï ‚Üí Œ±
(q : interactive.parse interactive.types.texpr) : interactive.parse (optional (lean.parser.tk "with" *> interactive.types.texpr)) ‚Üí interactive.parse interactive.types.location ‚Üí tactic unit
(R : Type u_1) [comm_ring R] (n : ‚Ñï) : (finset.range (n + 1)).sum (Œª (ŒΩ : ‚Ñï), (n ‚Ä¢ polynomial.X - ‚ÜëŒΩ) ^ 2 * bernstein_polynomial R n ŒΩ) = n ‚Ä¢ polynomial.X * (1 - polynomial.X)
{Œ± : Type u_2} [has_involutive_neg Œ±] : has_involutive_neg (filter Œ±)
{Œ± : Sort u_1} (z : bool ‚Üí Œ±) (s : bool ‚Üí snum ‚Üí Œ± ‚Üí Œ±) : snum ‚Üí Œ±
{Œ± : Sort u_1} (h : is_empty Œ±) {p : Œ± ‚Üí Sort u_2} (a : Œ±) : p a
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] {C : Type u} [category_theory.category C] (F : J ‚•§ K ‚•§ C) [category_theory.limits.has_limits_of_shape J C] [category_theory.limits.has_limits_of_shape K C] [category_theory.limits.has_limits_of_shape (J √ó K) C] [category_theory.limits.has_limits_of_shape (K √ó J) C] : category_theory.limits.limit (F.flip ‚ãô category_theory.limits.lim) ‚âÖ category_theory.limits.limit (F ‚ãô category_theory.limits.lim)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] {E : Type u‚ÇÉ} [category_theory.category E] [category_theory.monoidal_category E] (F : category_theory.lax_monoidal_functor C D) (G : category_theory.lax_monoidal_functor C E) : category_theory.lax_monoidal_functor C (D √ó E)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.is_equivalence F] : category_theory.full F
{C : Type u} [category_theory.category C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.is_colimit (category_theory.limits.binary_cofan.mk category_theory.limits.coprod.inl category_theory.limits.coprod.inr)
 : initial_seg has_lt.lt has_lt.lt
{G : Type u_1} [comm_monoid G] (tG : monoid.is_torsion G) : ‚Ü•(comm_monoid.torsion G) ‚âÉ* G
{R : Type u} [comm_ring R] {S : Type u} [comm_ring S] (f : R ‚Üí+* S) (U : topological_space.opens ‚Ü•(algebraic_geometry.prime_spectrum.Top R)) (V : topological_space.opens ‚Ü•(algebraic_geometry.prime_spectrum.Top S)) (hUV : V.val ‚äÜ ‚áë(prime_spectrum.comap f) ‚Åª¬π' U.val) : ‚Ü•((algebraic_geometry.Spec.structure_sheaf R).val.obj (opposite.op U)) ‚Üí+* ‚Ü•((algebraic_geometry.Spec.structure_sheaf S).val.obj (opposite.op V))
{R : Type u} [euclidean_domain R] [decidable_eq R] (a b : R) : euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b
{Œ± : Type u} (max : ‚Ñï) (f : thunk Œ±) : option Œ±
{l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {Œ± : Type u_12} (M : matrix (n ‚äï o) (l ‚äï m) Œ±) : matrix n m Œ±
{Œ± : Type u} [has_mul Œ±] : is_mul_hom id
{G : Type u_1} [ordered_comm_group G] (H : subgroup G) : ordered_comm_group ‚Ü•H
{Œ± : Type u} {Œ≤ : Type v} (f : filter Œ±) (g : filter Œ≤) : filter (Œ± √ó Œ≤)
{p x : ‚Ñù} {r : ‚Ñö} (h : liouville_with p x) (hr : r ‚â† 0) : liouville_with p (x * ‚Üër)
 : environment ‚Üí name ‚Üí name_set
 : CompleteLattice ‚âå CompleteLattice
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (E : D ‚•§ C) [category_theory.is_equivalence E] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size D
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] (w : free_product.word M) : free_product M
{S : Type v} (s : S) {R : Type u_1} [linear_ordered_semiring R] [set_like S R] [subsemiring_class S R] : linear_ordered_semiring ‚Ü•s
{X : Type u_1} {Y : Type u_2} [normed_group X] [normed_group Y] [normed_space ‚Ñù X] [normed_space ‚Ñù Y] (f : X ‚Üí Y) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (R : D ‚•§ C) [category_theory.monadic_right_adjoint R] [category_theory.limits.preserves_colimits_of_size R] : category_theory.creates_colimits_of_size R
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Œπ] (p : Œπ ‚Üí P) {n : ‚Ñï} (hc : fintype.card Œπ = n + 2) : finite_dimensional.finrank k ‚Ü•(vector_span k (set.range p)) ‚â§ n ‚Üî ¬¨affine_independent k p
{H : Type u} [topological_space H] (G : structure_groupoid H) : Prop
(Œ± : Type u_3) {Œ≤ : Type u_4} [has_inf Œ±] [semilattice_inf Œ≤] (b : Œ≤) : inf_hom Œ± Œ≤
{C D : Type u‚ÇÅ} [category_theory.small_category C] [category_theory.small_category D] (E : Type u‚ÇÇ) [category_theory.category E] (F : C ‚•§ D) (X : D) [‚àÄ (X : D), category_theory.limits.has_colimits_of_shape (category_theory.costructured_arrow F X) E] : category_theory.Lan F ‚ãô (category_theory.evaluation D E).obj X ‚âÖ (category_theory.whiskering_left (category_theory.costructured_arrow F X) C E).obj (category_theory.costructured_arrow.proj F X) ‚ãô category_theory.limits.colim
{Œ± : Type u_1} [pseudo_emetric_space Œ±] {f : ‚Ñï ‚Üí Œ±} (d : ‚Ñï ‚Üí nnreal) (hf : ‚àÄ (n : ‚Ñï), has_edist.edist (f n) (f n.succ) ‚â§ ‚Üë(d n)) (hd : summable d) : cauchy_seq f
{Œ± : Type u_1} : list Œ± ‚Üí list ‚Ñï ‚Üí list (list Œ±)
 : name ‚Üí string
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} [category_theory.artinian_object X] (h : ¬¨category_theory.limits.is_zero X) : C
{X : Top} (T : Top) : Top.subpresheaf_to_Types (X.continuous_prelocal T) ‚âÖ X.presheaf_to_Top T
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : chain_complex V ‚Ñï ‚•§ chain_complex V ‚Ñï
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pullbacks C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : category_theory.limits.kernel_fork (category_theory.limits.biprod.desc f (-g))
{C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ‚Ñï} {i : fin (n + 2)} : X.Œ¥ (‚áëfin.cast_succ i) ‚â´ X.Œ¥ i = X.Œ¥ i.succ ‚â´ X.Œ¥ i
{Œ± : Type u} [semiring Œ±] : is_semiring_hom id
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : basis (fin (finite_dimensional.finrank K V)) K V
{Œ± : Type u} {Œ≤ : Type v} [comm_ring Œ±] [has_zero Œ≤] [has_one Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ≤), f (-x) = -f x) (sub : ‚àÄ (x y : Œ≤), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : comm_ring Œ≤
{k : Type u_1} (M : Type u_2) [linear_ordered_field k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] {c : k} (hc : c < 0) : M ‚âÉo M·µí·µà
(s : interactive.parse (optional interactive.types.texpr)) (e : interactive.parse (lean.parser.tk "using" *> interactive.types.texpr)) : tactic.interactive.itactic
{Œπ : Sort u_1} {f : Œπ ‚Üí ennreal} {x : ennreal} (h0 : x ‚â† 0) (h : x ‚â† ‚ä§) : infi f * x = ‚®Ö (i : Œπ), f i * x
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {c : E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ‚Ñù} [interval_integral.FTC_filter a (nhds_within a s) (nhds_within a t)] (hmeas : strongly_measurable_at_filter f (nhds_within a t) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds_within a t ‚äì measure_theory.measure_space.volume.ae) (nhds c)) (hs : unique_diff_within_at ‚Ñù s a . "unique_diff_within_at_Ici_Iic_univ") : deriv_within (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in u..b, f x) s a = -c
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] (D : Type u‚ÇÇ) [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] (F : category_theory.braided_functor C D) : category_theory.lax_braided_functor C D
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [comm_semiring k] [monoid G] {A : Type u‚ÇÉ} [semiring A] [algebra k A] (F : monoid_algebra k G ‚Üí‚Çê[k] A) (f : monoid_algebra k G) : ‚áëF f = finsupp.sum f (Œª (a : G) (b : k), b ‚Ä¢ ‚áëF (finsupp.single a 1))
{Œ± : Type u_1} [comm_semiring Œ±] : fib_rec.is_solution (Œª (x : ‚Ñï), ‚Üë(nat.fib x))
{V : Type u} [category_theory.category V] [category_theory.limits.has_images V] [category_theory.limits.has_zero_object V] [category_theory.preadditive V] [category_theory.limits.has_kernels V] [category_theory.limits.has_cokernels V] {A‚ÇÅ B‚ÇÅ C‚ÇÅ A‚ÇÇ B‚ÇÇ C‚ÇÇ : V} (f‚ÇÅ : A‚ÇÅ ‚ü∂ B‚ÇÅ) (g‚ÇÅ : B‚ÇÅ ‚ü∂ C‚ÇÅ) (f‚ÇÇ : A‚ÇÇ ‚ü∂ B‚ÇÇ) (g‚ÇÇ : B‚ÇÇ ‚ü∂ C‚ÇÇ) (Œ± : A‚ÇÅ ‚âÖ A‚ÇÇ) (Œ≤ : B‚ÇÅ ‚âÖ B‚ÇÇ) (Œ≥ : C‚ÇÅ ‚âÖ C‚ÇÇ) (hsq‚ÇÅ : Œ±.hom ‚â´ f‚ÇÇ = f‚ÇÅ ‚â´ Œ≤.hom) (hsq‚ÇÇ : Œ≤.hom ‚â´ g‚ÇÇ = g‚ÇÅ ‚â´ Œ≥.hom) (h : category_theory.exact f‚ÇÅ g‚ÇÅ) : category_theory.exact f‚ÇÇ g‚ÇÇ
(X : algebraic_geometry.Scheme) [irreducible_space ‚Ü•(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)] : CommRing
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] : module.is_torsion R ‚Ü•(submodule.torsion R M)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] {s : set Œ±} (hs : is_compact s) {t : set Œ≤} (ht : is_compact t) {n : set (Œ± √ó Œ≤)} (hn : is_open n) (hp : s √óÀ¢ t ‚äÜ n) : ‚àÉ (u : set Œ±) (v : set Œ≤), is_open u ‚àß is_open v ‚àß s ‚äÜ u ‚àß t ‚äÜ v ‚àß u √óÀ¢ v ‚äÜ n
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] {F G H : category_theory.oplax_functor B C} (Œ∑ : category_theory.oplax_nat_trans F G) (Œ∏ : category_theory.oplax_nat_trans G H) : category_theory.oplax_nat_trans F H
{T : Type u‚ÇÅ} [category_theory.category T] {X : T} {D : Type u‚ÇÇ} [category_theory.category D] (F : T ‚•§ D) : category_theory.over X ‚•§ category_theory.over (F.obj X)
{Œ≤ : Type w} {C : Type u} [category_theory.category C] {f : Œ≤ ‚Üí C} (P : C) (p : Œ† (b : Œ≤), P ‚ü∂ f b) : category_theory.limits.fan f
{Œ± : Type u_1} [linear_order Œ±] [succ_order Œ±] [is_succ_archimedean Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) {n m : Œ±} (h1 : ‚àÄ (i : Œ±), i ‚àà set.Ico n m ‚Üí r i (order.succ i)) (h2 : ‚àÄ (i : Œ±), i ‚àà set.Ico m n ‚Üí r (order.succ i) i) (hnm : n ‚â† m) : relation.trans_gen r n m
 : native.float ‚Üí native.float
(b c : ‚Ñù) (n : ‚Ñï) (hb : 0 ‚â† b) : filter.tendsto (Œª (x : ‚Ñù), x ^ n / (b * real.exp x + c)) filter.at_top (nhds 0)
(X : Type u_5) (Y : Type u_6) [topological_space X] : Type (max u_5 u_6)
 : name_map expr ‚Üí tactic.itauto.proof ‚Üí tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] [fintype Œ≤] (h : fintype.card Œ≤ < fintype.card Œ±) : is_empty (Œ± ‚Ü™ Œ≤)
(M : Type u_1) (Œ± : Type u_2) [has_scalar M Œ±] [measurable_space M] [measurable_space Œ±] : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} [decidable_eq Œ≤] [fintype Œ±] (f : Œ± ‚Üí Œ≤) (H : function.surjective f) : fintype Œ≤
(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : minpoly A x ‚â† 1
{R : Type u} {M : Type v} {M‚ÇÇ : Type w} {M‚ÇÉ : Type y} [ring R] [add_comm_group M] [add_comm_group M‚ÇÇ] [add_comm_group M‚ÇÉ] [module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] {f : M ‚Üí‚Çó[R] M‚ÇÇ} {g : M ‚Üí‚Çó[R] M‚ÇÉ} (h : f.ker ‚äî g.ker = ‚ä§) : (f.prod g).range = f.range.prod g.range
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {c : E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ‚Ñù} [interval_integral.FTC_filter a (nhds_within a s) (nhds_within a t)] (hmeas : strongly_measurable_at_filter f (nhds_within a t) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds_within a t ‚äì measure_theory.measure_space.volume.ae) (nhds c)) : has_deriv_within_at (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in u..b, f x) (-c) s a
{C : Type u} [category_theory.category C] {F G : C ‚•§ C} (Œ± : F ‚âÖ G) : category_theory.endofunctor.algebra F ‚âå category_theory.endofunctor.algebra G
{M : Type u_1} [has_add M] : ‚Ü•‚ä§ ‚âÉ+ M
{M : Type u_5} {N : Type u_6} {P : Type u_7} [has_add M] [has_add N] [has_add P] (f : add_hom M N) (g : add_hom M P) : add_hom M (N √ó P)
(H : Type u) [inner_product_space ‚ÑÇ H] [complete_space H] : Type u
{Œ± : Type u} {Œ≤ : Type v} [decidable_eq Œ≤] (r : Œ± ‚Üí Œ≤ ‚Üí Prop) [Œ† (a : Œ±), fintype ‚Ü•(rel.image r {a})] (A : finset Œ±) : fintype ‚Ü•(rel.image r ‚ÜëA)
{ùïÇ : Type u_6} [is_R_or_C ùïÇ] {E' : Type u_7} [normed_group E'] [normed_space ùïÇ E'] {F' : Type u_8} [normed_group F'] [normed_space ùïÇ F'] [complete_space E'] {f : E' ‚Üí F'} {f' : E' ‚âÉL[ùïÇ] F'} {a : E'} {n : with_top ‚Ñï} (hf : cont_diff_at ùïÇ n f a) (hf' : has_fderiv_at f ‚Üëf' a) (hn : 1 ‚â§ n) : cont_diff_at ùïÇ n (hf.local_inverse hf' hn) (f a)
{Œ≤ : Type u_2} [topological_space Œ≤] {Œ∫ : Type u_5} {f : Œ∫ ‚Üí Œ≤} (hf : function.surjective f) : dense_range f
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.abelian C] [category_theory.has_injective_resolutions C] [category_theory.abelian D] (F : C ‚•§ D) [F.additive] (n : ‚Ñï) {X Y : C} (f : Y ‚ü∂ X) {P : category_theory.InjectiveResolution X} {Q : category_theory.InjectiveResolution Y} (g : Q.cocomplex ‚ü∂ P.cocomplex) (w : Q.Œπ ‚â´ g = (cochain_complex.single‚ÇÄ C).map f ‚â´ P.Œπ) : (F.right_derived n).map f = (F.right_derived_obj_iso n Q).hom ‚â´ (homology_functor D (complex_shape.up ‚Ñï) n).map ((F.map_homological_complex (complex_shape.up ‚Ñï)).map g) ‚â´ (F.right_derived_obj_iso n P).inv
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] [‚àÄ {X Y : C} (f : X ‚ü∂ Y), category_theory.is_iso (category_theory.abelian.coimage_image_comparison f)] [category_theory.limits.has_finite_products C] : category_theory.abelian C
{R : Type u_1} [ring R] [strong_rank_condition R] (n : ‚Ñï) {m : ‚Ñï} (v : fin m ‚Üí fin n ‚Üí R) : linear_independent R v ‚Üí m ‚â§ n
 : Type
{Œ± : Type u_1} [add_comm_group Œ±] [topological_space Œ±] [topological_add_group Œ±] [t2_space Œ±] (f : ‚Ñï ‚Üí Œ±) : filter.tendsto (Œª (i : ‚Ñï), ‚àë' (k : ‚Ñï), f (k + i)) filter.at_top (nhds 0)
{Œ± : Type u_1} [topological_space Œ±] {x : Œ±} {s : set Œ±} {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : upper_semicontinuous_within_at f s x) (hg : upper_semicontinuous_within_at g s x) (hcont : continuous_at (Œª (p : Œ≥ √ó Œ≥), p.fst + p.snd) (f x, g x)) : upper_semicontinuous_within_at (Œª (z : Œ±), f z + g z) s x
{Œ± : Type u_2} {Œ≤ : Type u_3} [ordered_comm_monoid Œ±] [ordered_comm_monoid Œ≤] : has_mul (Œ± ‚Üí*o Œ≤)
{R : Type u_3} {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] {n : ‚Ñï} (H : ‚àÄ (s : finset A), algebraic_independent R (Œª (i : ‚Ü•s), ‚Üëi) ‚Üí s.card ‚â§ n) (s : set A) : algebraic_independent R coe ‚Üí cardinal.mk ‚Ü•s ‚â§ ‚Üën
{Œ± : Type u} [uniform_space Œ±] [(uniformity Œ±).is_countably_generated] (H' : ‚àÄ (u : ‚Ñï ‚Üí Œ±), cauchy_seq u ‚Üí (‚àÉ (a : Œ±), filter.tendsto u filter.at_top (nhds a))) : complete_space Œ±
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ‚Ñù P) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : ‚áë(euclidean_geometry.reflection s) (‚áë(euclidean_geometry.reflection s) p) = p
{K : Type u_1} [is_R_or_C K] : K ‚Üí‚Çó[‚Ñù] ‚Ñù
(n : ‚Ñï) : ‚Üë(n.succ) ‚Ä¢ polynomial.bernoulli n = ‚áë(polynomial.monomial n) ‚Üë(n.succ) - (finset.range n).sum (Œª (k : ‚Ñï), ‚Üë((n + 1).choose k) ‚Ä¢ polynomial.bernoulli k)
{R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] [no_zero_divisors R] {B : M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R} (v : basis n R M) (hO : B.is_Ortho ‚áëv) (h : ‚àÄ (i : n), ¬¨B.is_ortho (‚áëv i) (‚áëv i)) : B.separating_left
(R : Type u) [ring R] [strong_rank_condition R] (m n : Type v) [fintype m] [fintype n] : module.rank R (matrix m n R) = (cardinal.mk m * cardinal.mk n).lift
{Œπ : Type u_1} (p : ‚Ñù) [fact_one_le_p : fact (1 ‚â§ p)] (ùïú : Type u_2) (Œ≤ : Œπ ‚Üí Type u_4) [fintype Œπ] [normed_field ùïú] [Œ† (i : Œπ), semi_normed_group (Œ≤ i)] [Œ† (i : Œπ), normed_space ùïú (Œ≤ i)] : normed_space ùïú (pi_Lp p Œ≤)
{Œ± : Type u} [has_add Œ±] : Œ± ‚âÉ+ Œ±·µê·µí·µñ
 : num ‚Üí num
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b : Œ±} (ha : 0 ‚â§ a) (hb : 0 ‚â§ b) : 0 ‚â§ a + b
 : list bool ‚Üí num
{M : Type u_1} [semigroup M] [topological_space M] [t2_space M] (continuous_mul_left : ‚àÄ (r : M), continuous (Œª (_x : M), _x * r)) (s : set M) (snemp : s.nonempty) (s_compact : is_compact s) (s_add : ‚àÄ (x : M), x ‚àà s ‚Üí ‚àÄ (y : M), y ‚àà s ‚Üí x * y ‚àà s) : ‚àÉ (m : M) (H : m ‚àà s), m * m = m
{Œ≤ : Type u_1} [add_comm_group Œ≤] (b : Œ≤) (V : Type u_2) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : category_theory.differential_object (category_theory.graded_object_with_shift b V) ‚âå homological_complex V (complex_shape.up' b)
{R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] [finite_dimensional R M] (x : orientation R M Œπ) (f : M ‚âÉ‚Çó[R] M) (h : fintype.card Œπ = finite_dimensional.finrank R M) : ‚áë(orientation.map Œπ f) x = -x ‚Üî ‚áëlinear_map.det ‚Üëf < 0
{Œ≤ : Type w} {C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) (f : Œ≤ ‚Üí C) [category_theory.limits.has_product f] [category_theory.limits.has_product (Œª (b : Œ≤), G.obj (f b))] : G.obj (‚àè f) ‚ü∂ ‚àè Œª (b : Œ≤), G.obj (f b)
{ùïú : Type u_1} {V : Type u_2} [normed_field ùïú] [add_comm_group V] [module ùïú V] (e : enorm ùïú V) : normed_space ùïú ‚Ü•(e.finite_subspace)
{Œ± : Type u} {Œ≤ : Type v} [mul_one_class Œ±] [add_zero_class Œ≤] : (additive Œ± ‚Üí+ Œ≤) ‚âÉ (Œ± ‚Üí* multiplicative Œ≤)
{m : Type u_2} {n : Type u_3} {Œ± : Type v} {Œ≤ : Type w} (M : matrix m n Œ±) (f : Œ± ‚Üí Œ≤) : matrix m n Œ≤
{M : Type u_1} {N : Type u_2} (A : Type u_4) [monoid M] [add_monoid A] [distrib_mul_action M A] [monoid N] (f : N ‚Üí* M) : distrib_mul_action N A
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_2} [Œ† (a : Œ±), fintype (Œ≤ a)] [Œ† (a : Œ±), encodable (Œ≤ a)] [encodable Œ±] : encodable (W_type Œ≤)
 : set upper_half_plane
 : expr ‚Üí option expr
{R : Type u_1} [comm_semiring R] {X : Type u_2} : free_algebra R X ‚Üí‚Çê[R] R
 : pgame ‚Üí pgame
{Œ± : Type u} {P : Œ± ‚Üí Prop} {Œ≤ : Type u_1} (f : Œ† (a : Œ±), P a ‚Üí Œ≤) (t : ordnode Œ±) : ordnode.all P t ‚Üí ordnode Œ≤
(Œ± : Type u_1) [t : topological_space Œ±] [preorder Œ±] : Prop
{Œπ : Type v} [dec_Œπ : decidable_eq Œπ] {Œ± : option Œπ ‚Üí Type w} [Œ† (i : option Œπ), add_comm_monoid (Œ± i)] : direct_sum (option Œπ) (Œª (i : option Œπ), Œ± i) ‚âÉ+ Œ± option.none √ó direct_sum Œπ (Œª (i : Œπ), Œ± (option.some i))
{Œ± : Type u_1} [linear_order Œ±] {r s : Œ±} : {r}.to_colex < {s}.to_colex ‚Üî r < s
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} (f : Y ‚ü∂ Z) (P : category_theory.ProjectiveResolution Y) (Q : category_theory.ProjectiveResolution Z) : P.complex.X 1 ‚ü∂ Q.complex.X 1
{X : Top} (F : Top.presheaf (category_theory.discrete punit) X) : F.is_sheaf
 : hole_command
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí. Œ≤) (a : Œ±) : f.dom a ‚Üí Œ≤
(Œ± : Type u_1) [has_mul Œ±] : Type u_1
(t : interactive.parse (optional interactive.types.texpr)) (lems : interactive.parse (lean.parser.tk "using" *> tactic.simp_arg_list <|> has_pure.pure list.nil)) : tactic unit
(R : Type u_2) (M : Type u_3) (P : Type u_5) (Q : Type u_6) [comm_ring R] [add_comm_group M] [add_comm_group P] [add_comm_group Q] [module R M] [module R P] [module R Q] [module.free R M] [module.finite R M] [nontrivial R] : tensor_product R P (M ‚Üí‚Çó[R] Q) ‚âÉ‚Çó[R] M ‚Üí‚Çó[R] tensor_product R P Q
{n : ‚Ñï} {Œ± : typevec (n + 1)} : Œ±.arrow (Œ±.drop ::: Œ±.last)
{Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (ht : is_compact t) (hs : is_closed s) : is_compact (s ‚à© t)
{n : ‚Ñï} [fact (0 < n)] : fintype.card (dihedral_group n) = 2 * n
 : omega.nat.preform ‚Üí omega.nat.preform
{Œ± : Type u} [topological_space Œ±] [locally_compact_space Œ±] {K : set Œ±} (hK : is_compact K) : ‚àÉ (K' : set Œ±), is_compact K' ‚àß K ‚äÜ interior K'
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [add_comm_monoid E] [module ùïú E] [topological_space E] (s : set E) (x : E) : set E
{Œ± : Type u_1} {G : Type u_4} [division_comm_monoid G] {f g : Œ± ‚Üí G} (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) : finprod (Œª (i : Œ±), f i / g i) = finprod (Œª (i : Œ±), f i) / finprod (Œª (i : Œ±), g i)
{Œ≤ : Type u} {Œ± : Type v} {s : finset Œ±} [add_comm_monoid Œ≤] (f : Œ± ‚Üí Œ≤) {p : Œ± ‚Üí Prop} [decidable_pred p] : (finset.subtype p s).sum (Œª (x : subtype p), f ‚Üëx) = (finset.filter p s).sum (Œª (x : Œ±), f x)
 : ‚Ñ§ ‚Üí znum
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (A : Mon_ C) : Mod A
(C : Type u_1) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.preadditive C] [category_theory.monoidal_preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_cokernels C] [category_theory.limits.has_images C] [category_theory.limits.has_image_maps C] [category_theory.has_projective_resolutions C] (n : ‚Ñï) : C ‚•§ C ‚•§ C
{Œ± : Type u_1} (f : Œ± ‚Üí option Œ±) : list Œ± ‚Üí list Œ±
{Œ± : Type u_3} {Œ≤ : Type u_4} [semilattice_sup Œ±] [semilattice_sup Œ≤] {f : Œ± ‚Üí Œ≤} (g : Œ≤ ‚Üí Œ±) (b' : Œ≤) (hf : monotone f) (gc : ‚àÄ (a : Œ±) (b : Œ≤), b ‚â• b' ‚Üí (f a ‚â§ b ‚Üî a ‚â§ g b)) (hgi : ‚àÄ (b : Œ≤), b ‚â• b' ‚Üí b ‚â§ f (g b)) : filter.map f filter.at_top = filter.at_top
(m k : ‚Ñï+) : ‚Ñï+ √ó ‚Ñï
{Œ± : Type u_1} [decidable_eq Œ±] {s : finset Œ±} (P : finpartition s) : Prop
{Œ± : Type u} [linear_ordered_ring Œ±] (a b c : Œ±) : 0 ‚â§ a * b ‚à® 0 ‚â§ b * c ‚à® 0 ‚â§ c * a
 : ‚Ñï ‚Üí smt_tactic unit ‚Üí smt_tactic unit
{X : Type u_1} [topological_space X] (x : X) : path x x
{R : Type u_1} {S : Type u_2} (L : Type u_4) [euclidean_domain R] [comm_ring S] [is_domain S] [field L] [algRL : algebra R L] [algebra R S] [algebra S L] [ist : is_scalar_tower R S L] [iic : is_integral_closure S R L] {abv : absolute_value R ‚Ñ§} {Œπ : Type u_5} [decidable_eq Œπ] [fintype Œπ] (bS : basis Œπ R S) (adm : abv.is_admissible) [infinite R] [decidable_eq R] (h : algebra.is_algebraic R L) (a : S) {b : S} (hb : b ‚â† 0) : ‚àÉ (q : S) (r : R) (H : r ‚àà class_group.finset_approx bS adm), ‚áëabv (‚áë(algebra.norm R) (r ‚Ä¢ a - q * b)) < ‚áëabv (‚áë(algebra.norm R) b)
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] {Œπ : Type u_1} [nonempty Œπ] (K : Œπ ‚Üí subalgebra R A) (dir : directed has_le.le K) (f : Œ† (i : Œπ), ‚Ü•(K i) ‚Üí‚Çê[R] B) (hf : ‚àÄ (i j : Œπ) (h : K i ‚â§ K j), f i = (f j).comp (subalgebra.inclusion h)) (T : subalgebra R A) (hT : T = supr K) : ‚Ü•T ‚Üí‚Çê[R] B
{Œ± : Type u} [complete_lattice Œ±] (f : Œ± ‚Üío Œ±) (x : Œ±) (hx : ‚áëf x ‚â§ x) : ‚Ü•(function.fixed_points ‚áëf)
{Œ≥ : Type w} [semilattice_sup Œ≥] {s t : set Œ≥} : bdd_above s ‚Üí bdd_above t ‚Üí bdd_above (s ‚à™ t)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.split_mono_category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.split_mono f
(str : name) (proj : string) : tactic (expr √ó list ‚Ñï)
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (M‚ÇÅ : Type u‚ÇÅ) [semi_normed_group M‚ÇÅ] [normed_space ùïú M‚ÇÅ] (M‚ÇÇ : Type u‚ÇÇ) [semi_normed_group M‚ÇÇ] [normed_space ùïú M‚ÇÇ] (M‚ÇÉ : Type u‚ÇÉ) [semi_normed_group M‚ÇÉ] [normed_space ùïú M‚ÇÉ] (M‚ÇÑ : Type u‚ÇÑ) [semi_normed_group M‚ÇÑ] [normed_space ùïú M‚ÇÑ] : (M‚ÇÅ ‚ÜíL[ùïú] M‚ÇÇ) √ó (M‚ÇÉ ‚ÜíL[ùïú] M‚ÇÑ) ‚ÜíL[ùïú] M‚ÇÅ √ó M‚ÇÉ ‚ÜíL[ùïú] M‚ÇÇ √ó M‚ÇÑ
{Œ≥ : Type w} [semilattice_inf Œ≥] {s t : set Œ≥} : bdd_below (s ‚à™ t) ‚Üî bdd_below s ‚àß bdd_below t
(C : Type u‚ÇÅ) [category_theory.category C] {F‚ÇÅ : category_theory.discrete pempty ‚•§ C} {F‚ÇÇ : category_theory.discrete pempty ‚•§ C} {c‚ÇÅ : category_theory.limits.cocone F‚ÇÅ} (hl : category_theory.limits.is_colimit c‚ÇÅ) (c‚ÇÇ : category_theory.limits.cocone F‚ÇÇ) (hi : c‚ÇÅ.X ‚âÖ c‚ÇÇ.X) : category_theory.limits.is_colimit c‚ÇÇ
{T : Type u} [category_theory.category T] {X Y : T} (i : X ‚âÖ Y) (p : category_theory.arrow T) (sq : category_theory.arrow.mk i.hom ‚ü∂ p) : i.inv ‚â´ sq.left ‚â´ p.hom = sq.right
{Œ± : Type u} [monoid_with_zero Œ±] (x : Œ±) [invertible x] : ring.inverse x = ‚Öü x
{Œ± : Type u_1} (l : language Œ±) : language Œ±
{R : Type u_1} [comm_ring R] (f : polynomial R) : set (prime_spectrum R)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} (f g : C ‚ü∂ D) : Type (max u_1 v)
(n : ‚Ñï+) (A : Type w) (B : Type z) [comm_ring A] [comm_ring B] [algebra A B] [is_cyclotomic_extension {n} A B] [is_domain B] [ne_zero ‚Üë‚Üën] : is_primitive_root (is_cyclotomic_extension.zeta n A B) ‚Üën
{E : Type u_3} [semi_normed_group E] (s : add_subgroup E) : semi_normed_group ‚Ü•s
{Œ± : Type u_2} [has_one Œ±] : one_hom Œ± (set Œ±)
{Œ± : Type u_1} [topological_space Œ±] {x : Œ±} {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : lower_semicontinuous_at f x) (hg : lower_semicontinuous_at g x) (hcont : continuous_at (Œª (p : Œ≥ √ó Œ≥), p.fst + p.snd) (f x, g x)) : lower_semicontinuous_at (Œª (z : Œ±), f z + g z) x
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] {J : Type v} {f : J ‚Üí C} (F : C ‚•§ D) [F.preserves_zero_morphisms] [category_theory.limits.preserves_biproduct f F] {b : category_theory.limits.bicone f} (hb : b.is_bilimit) : (F.map_bicone b).is_bilimit
{R : Type u_1} [monoid R] (r : R) : Prop
(R : Type u) [ring R] [strong_rank_condition R] {Œπ : Type v} [fintype Œπ] : finite_dimensional.finrank R (Œπ ‚Üí R) = fintype.card Œπ
{Œ± : Type u} {Œ≤ : Type v} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {n : ‚Ñï} (hn : s.card < t.card * n) : ‚àÉ (y : Œ≤) (H : y ‚àà t), (finset.filter (Œª (x : Œ±), f x = y) s).card < n
 : tactic.ring.ring_m tactic.ring.cache
{Œ± : Type u_1} {M : Type u_5} [has_zero M] (p : Œ± ‚Üí Prop) (f : Œ± ‚Üí‚ÇÄ M) : subtype p ‚Üí‚ÇÄ M
{S : Type u} [pgame.state S] (s : S) : pgame
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limits C
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p‚ÇÇ : Œπ ‚Üí P) (p‚ÇÅ : P) (h : s.sum (Œª (i : Œπ), w i) = 0) : s.sum (Œª (i : Œπ), w i ‚Ä¢ (p‚ÇÅ -·µ• p‚ÇÇ i)) = -‚áë(s.weighted_vsub p‚ÇÇ) w
 : cc_state ‚Üí cc_state
(M : Type u_1) (Œ± : Type u_2) [group M] [mul_action M Œ±] {s t : set Œ±} : fixing_subgroup M (s ‚à™ t) = fixing_subgroup M s ‚äì fixing_subgroup M t
(C : Type u) [category_theory.category C] [‚àÄ {X Y : C}, category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_products C
{X : Type u_1} [tX : topological_space X] {s t : set X} (ts : t ‚äÜ s) : subtype.topological_space = topological_space.induced (set.inclusion ts) subtype.topological_space
 : algebraic_geometry.Scheme ‚•§ algebraic_geometry.LocallyRingedSpace
{p : ‚Ñï} (q : ‚Ñö) : padic_val_rat p (-q) = padic_val_rat p q
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {P : C(X, Y) ‚Üí Prop} {f‚ÇÄ f‚ÇÅ f‚ÇÇ : C(X, Y)} (F : f‚ÇÄ.homotopy_with f‚ÇÅ P) (G : f‚ÇÅ.homotopy_with f‚ÇÇ P) : f‚ÇÄ.homotopy_with f‚ÇÇ P
{Œ± : Type u_1} [has_mul Œ±] [has_le Œ±] (a : Œ±) : Prop
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : ‚Ü•S ‚Üí‚Çê[R] A
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h1 : ‚Üës1.nonempty) (h2 : ‚Üës2.nonempty) (hd : is_compl s1.direction s2.direction) : ‚àÉ (p : P), ‚Üës1 ‚à© ‚Üës2 = {p}
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} : category_theory.creates_limits_of_size T.forget
(R : Type u) [ring R] : Ring
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring ùïú] [add_comm_group E] [add_comm_group F] [module ùïú E] [module ùïú F] {x : E} (f : E ‚Üí·µÉ[ùïú] F) {s : set F} (hs : star_convex ùïú (‚áëf x) s) : star_convex ùïú x (‚áëf ‚Åª¬π' s)
{x y : simplex_category} (f : x ‚ü∂ y) : ‚Ü•(x.to_Top_obj) ‚Üí ‚Ü•(y.to_Top_obj)
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {x‚ÇÄ x‚ÇÅ : X} {p q : path x‚ÇÄ x‚ÇÅ} (F : p.homotopy q) (f : C(X, Y)) : (p.map _).homotopy (q.map _)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) : AddCommGroup
 : Type
{Œ≤ : Type v} [has_zero Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_scalar ‚Ñï Œ≤] {Œ± : Type u} [non_unital_semiring Œ±] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_unital_semiring Œ≤
{f : ‚Ñï ‚Üí ‚Ñù} (hfa : antitone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) : ‚àÉ (l : ‚Ñù), filter.tendsto (Œª (n : ‚Ñï), (finset.range (n + 1)).sum (Œª (i : ‚Ñï), (-1) ^ i * f i)) filter.at_top (nhds l)
{Œπ : Type u} {Œ≥ : Type w} [dec : decidable_eq Œπ] (p : Œπ ‚Üí Prop) [decidable_pred p] [add_comm_monoid Œ≥] (S : Œπ ‚Üí add_submonoid Œ≥) : (‚®Ü (i : Œπ) (h : p i), S i) = ((dfinsupp.sum_add_hom (Œª (i : Œπ), (S i).subtype)).comp (dfinsupp.filter_add_monoid_hom (Œª (i : Œπ), ‚Ü•(S i)) p)).mrange
{Œ± : Type u_2} [decidable_eq Œ±] [mul_one_class Œ±] : mul_one_class (finset Œ±)
(trc : interactive.parse (optional (lean.parser.tk "?"))) (h : interactive.parse (optional lean.parser.ident)) (t : interactive.parse (lean.parser.tk ":" *> interactive.types.texpr)) : tactic unit
{Œ± : Type u_1} {p : Œ± ‚Üí Prop} [decidable_pred p] {s : finset Œ±} (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ¬¨p x) : finset.filter p s = ‚àÖ
{M : Type u_5} [monoid M] {A : Type u_6} [add_monoid A] [distrib_mul_action M A] {B : Type u_8} [add_monoid B] [distrib_mul_action M B] (self : A ‚Üí+[M] B) : A ‚Üí+ B
{A : Type u_1} [semiring A] [algebra ‚Ñù A] : algebra nnreal A
(R : Type u) {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {s : set A} (hcomm : ‚àÄ (a : A), a ‚àà s ‚Üí ‚àÄ (b : A), b ‚àà s ‚Üí a * b = b * a) : comm_semiring ‚Ü•(algebra.adjoin R s)
{Œ± : Type u_2} {Œ≤ : Type u_3} [partial_order Œ±] [partial_order Œ≤] (e : Œ± ‚âÉo Œ≤) : with_top Œ± ‚âÉo with_top Œ≤
(Œ± : Type u_1) : Type u_1
{Œ± : Type u_2} [has_le Œ±] : with_bot Œ±·µí·µà ‚âÉo (with_top Œ±)·µí·µà
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} : F (Œ± ::: mvqpf.cofix F Œ±) ‚Üí mvqpf.cofix F Œ±
{R : Type u} {S : Type v} [non_assoc_semiring R] [set_like S R] [hSR : subsemiring_class S R] (s : S) : non_assoc_semiring ‚Ü•s
{Œ± : Type u_1} {m : measurable_space Œ±} {M : Type u_3} [add_comm_monoid M] [topological_space M] [has_continuous_add M] (v w : measure_theory.vector_measure Œ± M) : measure_theory.vector_measure Œ± M
{A : Type v} [add_monoid A] (a : A) : Prop
{a b : ‚Ñï} (w : a ‚à£ b) (h : b < a) : b = 0
{G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] (p : P) : G ‚âÉ P
{K : Type u_1} {v : K} {n : ‚Ñï} [linear_ordered_field K] [floor_ring K] : (generalized_continued_fraction.of v).denominators n ‚â§ (generalized_continued_fraction.of v).denominators (n + 1)
{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : a + b = b + a
 : pexpr ‚Üí list pexpr
(Œ± : Type u_6) (Œ≤ : Type u_7) [preorder Œ±] [preorder Œ≤] : Type (max u_6 u_7)
{C : Type u‚ÇÅ} (X : C·¥π·µí·µñ) : C
(M : Type u_4) [has_mul M] : Type u_4
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
(pf : expr) : tactic expr
{R : Type u_1} {A : Type u_2} {M : Type u_3} {N : Type u_4} {P : Type u_5} [comm_semiring R] [semiring A] [algebra R A] [add_comm_monoid M] [module R M] [module A M] [is_scalar_tower R A M] [add_comm_monoid N] [module R N] [add_comm_monoid P] [module R P] [module A P] [is_scalar_tower R A P] (f : tensor_product R M N ‚Üí‚Çó[A] P) : M ‚Üí‚Çó[A] N ‚Üí‚Çó[R] P
(G : Type u_10) (P : Type u_11) [add_monoid G] : Type (max u_10 u_11)
{Œ± : Type u_1} [h : inhabited Œ±] (l : list Œ±) (n : ‚Ñï) : Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] : C(Œ≤, C(Œ±, Œ≤))
{p : ennreal} [fact (1 ‚â§ p)] (hp : p ‚â† ‚ä§) : (submodule.span ‚ÑÇ (set.range (fourier_Lp p))).topological_closure = ‚ä§
{Œ± : Type u_1} : ‚Ñï ‚Üí list Œ± ‚Üí list (list Œ±)
{Œ± : Type u_1} [has_le Œ±] {s : set Œ±·µí·µà} : is_lower_set s ‚Üí is_upper_set (‚áëorder_dual.to_dual ‚Åª¬π' s)
{Œ± : Type u} [lattice Œ±] [add_comm_group Œ±] : has_neg_part Œ±
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.is_iso f] : category_theory.limits.is_limit (category_theory.limits.pullback_cone_of_left_iso f g)
(ic qc : tactic.instance_cache) (cz_inst a' : expr) (na' : ‚Ñö) : tactic (tactic.instance_cache √ó tactic.instance_cache √ó expr √ó expr)
{Œ± : Type u} {Œ≥ : Type u_1} [topological_space Œ≥] [t2_space Œ≥] [compact_space Œ≥] {f : Œ± ‚Üí Œ≥} {b : ultrafilter Œ±} {c : Œ≥} : ultrafilter.extend f b = c ‚Üî ‚Üë(ultrafilter.map f b) ‚â§ nhds c
{X : Top} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : category_theory.pairwise Œπ ‚•§ Top.presheaf.sheaf_condition.opens_le_cover U
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} (t : category_theory.limits.fork f g) : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj t.X).obj category_theory.limits.walking_parallel_pair.zero ‚ü∂ (category_theory.limits.parallel_pair f g).obj category_theory.limits.walking_parallel_pair.zero
{Œ± : Type u_1} [measurable_space Œ±] : has_coe (measure_theory.finite_measure Œ±) (measure_theory.measure Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) {J : Type u} [category_theory.category J] {K : J ‚•§ D} (X : C·µí·µñ) (t : (F.op ‚ãô (category_theory.cones J D).obj K).obj X) : ((category_theory.cones J C).obj (K ‚ãô G)).obj X
{n : ‚Ñï} (hpos : 0 < n) {p : ‚Ñï} [fact (nat.prime p)] {a : ‚Ñï} (hroot : (polynomial.cyclotomic n (zmod p)).is_root (‚áë(nat.cast_ring_hom (zmod p)) a)) : order_of (zmod.unit_of_coprime a _) ‚à£ n
 : fib_rec.is_solution (has_pow.pow golden_ratio)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (L' : lie_subalgebra R L) : lie_algebra R ‚Ü•L'
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ‚Ü•X) (R : category_theory.presieve U) : category_theory.presheaf.second_map R F ‚â´ (Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom = (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom ‚â´ Top.presheaf.sheaf_condition_equalizer_products.right_res F (Top.presheaf.covering_of_presieve U R)
{M : Type u_1} {N : Type u_2} [add_monoid M] [add_monoid N] {s : set M} (f : M ‚Üí N) (hs : add_submonoid.closure s = ‚ä§) (h1 : f 0 = 0) (hmul : ‚àÄ (x y : M), y ‚àà s ‚Üí f (x + y) = f x + f y) : M ‚Üí+ N
(X : CompHaus) (Y : Profinite) : (X.to_Profinite_obj ‚ü∂ Y) ‚âÉ (X ‚ü∂ Profinite_to_CompHaus.obj Y)
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} (hs : s.nonempty) {C : ‚Ñù} (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí has_dist.dist x y ‚â§ C) : metric.diam s ‚â§ C
{m : ‚Ñù} {f : ‚Ñï ‚Üí ‚Ñï} (hm : 1 < m) (fi : ‚àÄ (i : ‚Ñï), i ‚â§ f i) : summable (Œª (i : ‚Ñï), 1 / m ^ f i)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] [complete_space ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [finite_dimensional ùïú F] (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ‚ä§) : local_homeomorph E (F √ó ‚Ü•(f'.ker))
(R : Type u) (M : Type v) [field R] [add_comm_group M] [module R M] : Type v
{V : Type u} {G : simple_graph V} (G' : G.subgraph) (v : V) : set V
{Œ± : Type u} {Œ≤ : Type v} {s : set Œ±} {t : set Œ≤} {f : Œ± ‚Üí Œ≤} {f' : Œ≤ ‚Üí Œ±} (h : set.inv_on f' f s t) (hf : set.maps_to f s t) (hf' : set.maps_to f' t s) : set.bij_on f s t
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] {B : C} (F : J ‚•§ category_theory.over B) : F ‚ãô category_theory.over.forget B ‚ü∂ (category_theory.functor.const J).obj B
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J ‚•§ C) {c : category_theory.limits.cocone F} (hc : category_theory.limits.is_colimit c) : category_theory.limits.is_limit c.op
{Œ± : Type u_1} {Œπ : Type u_3} {Œπ' : Type u_4} [distrib_lattice Œ±] [order_bot Œ±] [decidable_eq Œπ] {s : finset Œπ'} {g : Œπ' ‚Üí finset Œπ} {f : Œπ ‚Üí Œ±} (hs : s.sup_indep (Œª (i : Œπ'), (g i).sup f)) (hg : ‚àÄ (i' : Œπ'), i' ‚àà s ‚Üí (g i').sup_indep f) : (s.sup g).sup_indep f
{X Y : AddSemigroup} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ+ ‚Ü•Y
{Œ≤ : Type v} {Œ≥ : Type w} {Œ¥ : Type u_2} [topological_space Œ≤] [topological_space Œ≥] [topological_space Œ¥] [has_zero Œ¥] (f : zero_at_infty_continuous_map Œ≥ Œ¥) (g : cocompact_map Œ≤ Œ≥) : zero_at_infty_continuous_map Œ≤ Œ¥
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] : lazy_list Œ± ‚Üí lazy_list Œ±
(Œ± : Type u_1) [pseudo_metric_space Œ±] [t0_space Œ±] : metric_space Œ±
(a : expr) (na : ‚Ñö) : tactic.instance_cache ‚Üí expr ‚Üí tactic (tactic.instance_cache √ó expr √ó expr)
(R : Type u_1) (n : ‚Ñï) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_2)
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [nondiscrete_normed_field ùïÇ] [normed_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] [char_zero ùïÇ] {x y : ùî∏} (hxy : commute x y) (hx : x ‚àà emetric.ball 0 (exp_series ùïÇ ùî∏).radius) (hy : y ‚àà emetric.ball 0 (exp_series ùïÇ ùî∏).radius) : exp ùïÇ (x + y) = exp ùïÇ x * exp ùïÇ y
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [semi_normed_group E] [normed_space ùïú E] : set E ‚Üí set (normed_space.dual ùïú E)
(n a : ‚Ñï) (p : ‚Ñï ‚Üí Prop) [decidable_pred p] (pp : function.periodic p a) : (finset.filter p (finset.Ico n (n + a))).card = nat.count p a
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e : local_homeomorph Œ± Œ≤} {s : set Œ±} {t : set Œ≤} : e.is_image s t ‚Üí e.to_local_equiv.target ‚à© ‚áë(e.symm) ‚Åª¬π' (e.to_local_equiv.source ‚à© s) = e.to_local_equiv.target ‚à© t
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.limits.preserves_limits_of_size F] : category_theory.limits.preserves_limits_of_size G
{K : Type v} [field K] {P : polynomial K} (hmo : P.monic) (hP : polynomial.splits (ring_hom.id K) P) : P.next_coeff = -P.roots.sum
{Œ± : Type u} [pseudo_metric_space Œ±] {x : Œ±} {r : ‚Ñù} : metric.bounded (metric.ball x r)
(C : Type u) {A : Type u_1} [category_theory.category C] [add_monoid A] [category_theory.has_shift C A] (i j : A) : category_theory.shift_functor C (i + j) ‚âÖ category_theory.shift_functor C i ‚ãô category_theory.shift_functor C j
{Œ± : Type u_1} [has_inf Œ±] (inf_comm : ‚àÄ (a b : Œ±), a ‚äì b = b ‚äì a) (inf_assoc : ‚àÄ (a b c : Œ±), a ‚äì b ‚äì c = a ‚äì (b ‚äì c)) (inf_idem : ‚àÄ (a : Œ±), a ‚äì a = a) : semilattice_inf Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (ùíÆ : set (category_theory.sieve X)) : category_theory.sieve X
{Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [has_zero Œ≤] [has_one Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ≤), f (-x) = -f x) (sub : ‚àÄ (x y : Œ≤), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : ring Œ≤
(L : Type u_1) [topological_space L] [lattice L] : Type
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) : category_theory.mono_over X ‚•§ category_theory.over X
{R : Type u} {M : Type v} [ring R] {N : Type u_3} [add_comm_group M] [module R M] [add_comm_group N] [module R N] (f : M √ó N ‚Üí‚Çó[R] M) (KœÜ : Œ£ (K : submodule R M), ‚Ü•K ‚âÉ‚Çó[R] M) : M √ó N ‚Üí‚Çó[R] M
(R : Type u) [semiring R] (M : fin 2 ‚Üí Type v) [Œ† (i : fin 2), add_comm_monoid (M i)] [Œ† (i : fin 2), module R (M i)] : (Œ† (i : fin 2), M i) ‚âÉ‚Çó[R] M 0 √ó M 1
{Œ± : Type u_1} {Œ≤ : Type u_2} {e : local_equiv Œ± Œ≤} {s : set Œ±} {t : set Œ≤} : e.target ‚à© ‚áë(e.symm) ‚Åª¬π' s = e.target ‚à© t ‚Üí e.is_image s t
{X : Type u_1} {Y : Type u_2} [topological_space X] [non_assoc_semiring Y] : Y ‚Üí+* locally_constant X Y
{X : Type u_1} {Œ± : Type u_2} [topological_space X] {x y : Œ± ‚Üí X} : function.has_uncurry (Œ† (a : Œ±), path (x a) (y a)) (Œ± √ó ‚Ü•unit_interval) X
(R : Type u_1) [comm_ring R] (M : Type u_2) [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [nontrivial R] : (linear_map.trace R M).comp (dual_tensor_hom R M M) = contract_left R M
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] {ùíú : finset (finset Œ±)} {s : finset Œ±} : s ‚àà ùíú.up_shadow ‚Üî ‚àÉ (t : finset Œ±) (H : t ‚àà ùíú) (a : Œ±) (H : a ‚àâ t), has_insert.insert a t = s
{Œ± : Type u_3} [preorder Œ±] : filter Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚âÉ‚Çú Œ≤) (K : topological_space.compacts Œ±) : (‚áë(topological_space.compacts.equiv f) K).carrier = ‚áë(f.symm) ‚Åª¬π' K.carrier
(X : Type u) [group X] : Group
{Œ± : Type u} : ordnode Œ± ‚Üí Œ± ‚Üí Œ±
 : Type
{Œ± : Type u} {Œ≥ : Type w} [comm_semiring Œ±] [has_zero Œ≥] [has_one Œ≥] [has_add Œ≥] [has_mul Œ≥] [has_scalar ‚Ñï Œ≥] [has_pow Œ≥ ‚Ñï] (f : Œ± ‚Üí Œ≥) (hf : function.surjective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ±) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ±) (n : ‚Ñï), f (x ^ n) = f x ^ n) : comm_semiring Œ≥
(F : Type u_1) (E : Type u_2) [field F] [field E] [algebra F E] [finite_dimensional F E] [is_separable F E] : power_basis F E
{L : first_order.language} (T : L.Theory) : Prop
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : out_param (Sort u_3)} [has_coe Œ± Œ≤] [has_coe_to_fun Œ≤ (Œª (_x : Œ≤), Œ≥)] (x : Œ±) : ‚áëx = ‚áë‚Üëx
{a b : ‚Ñï} (ha : a ‚â† 0) (hb : b ‚â† 0) : (a * b).factors.to_finset = a.factors.to_finset ‚à™ b.factors.to_finset
{Œ± : Type u_1} [preorder Œ±] {a b : Œ±} (h : a ‚â§ b) : set.Ioi b ‚äÜ set.Ioi a
{Œ± : Type u_1} {p : set Œ±} (s : finset Œ±) (H : ‚àÄ (x : Œ±), x ‚àà s ‚Üî x ‚àà p) : fintype ‚Ü•p
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [module ùïú E] [module ùïú Œ≤] [linear_order E] {s : set E} {f : E ‚Üí Œ≤} (hs : convex ùïú s) (hf : ‚àÄ ‚¶Éx y : E‚¶Ñ, x ‚àà s ‚Üí y ‚àà s ‚Üí x < y ‚Üí ‚àÄ ‚¶Éa b : ùïú‚¶Ñ, 0 < a ‚Üí 0 < b ‚Üí a + b = 1 ‚Üí f (a ‚Ä¢ x + b ‚Ä¢ y) < a ‚Ä¢ f x + b ‚Ä¢ f y) : strict_convex_on ùïú s f
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] (K : category_theory.grothendieck_topology D) (G : C ‚•§ D) : Prop
(c : tactic.instance_cache) : ‚Ñö ‚Üí tactic (tactic.instance_cache √ó expr)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} : antitone_on f s ‚Üí monotone_on (f ‚àò ‚áëorder_dual.of_dual) s
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) : category_theory.comonad.comparison h ‚ãô h.to_comonad.forget ‚âÖ L
{Œ± : Type u_1} [circular_preorder Œ±] {a b c : Œ±} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw b c a
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] (C : chain_complex V ‚Ñï) (X : V) : (C ‚ü∂ (chain_complex.single‚ÇÄ V).obj X) ‚âÉ {f // C.d 1 0 ‚â´ f = 0}
{A : Type u_1} {Œπ : Type u_2} [ring A] [nonempty Œπ] {B : Œπ ‚Üí add_subgroup A} (hB : ring_subgroups_basis B) (i : Œπ) : open_add_subgroup A
{Œ± : Type} [has_to_tactic_format Œ±] (a : Œ±) : tactic unit
{R' : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [non_assoc_semiring R'] [has_scalar Œ± Œ≤] [has_scalar R' Œ±] [has_scalar R' Œ≤] [is_scalar_tower R' Œ± Œ≤] (S : subsemiring R') : is_scalar_tower ‚Ü•S Œ± Œ≤
(o : ordinal) (f : Œ† (b : ordinal), b < o ‚Üí ordinal ‚Üí ordinal) : ordinal ‚Üí ordinal
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (E : K ‚•§ J) : category_theory.limits.cone F ‚•§ category_theory.limits.cone (E ‚ãô F)
(Œπ : Type u_1) [decidable_eq Œπ] {R : Type u_4} [comm_semiring R] {M : Type u_8} [add_comm_monoid M] [module R M] [is_empty Œπ] : pi_tensor_product R (Œª (i : Œπ), M) ‚âÉ‚Çó[R] R
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {c : E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a ‚äì measure_theory.measure_space.volume.ae) (nhds c)) : has_deriv_at (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in u..b, f x) (-c) a
 : num ‚Üí znum
{Œ± : Type u_1} {R : Type u_2} {l : filter Œ±} {f : Œ± ‚Üí R} {r : R} [linear_ordered_ring R] [archimedean R] (hr : 0 < r) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (Œª (x : Œ±), f x * r) l filter.at_bot
 : num ‚Üí list ‚Ñï
(ùïú : Type u_1) {V : Type u_2} {P : Type u_8} [normed_field ùïú] [semi_normed_group V] [normed_space ùïú V] [pseudo_metric_space P] [normed_add_torsor V P] (x : P) : P ‚âÉ·µÉ‚Å±[ùïú] P
 : Type (u_1+1)
{R : Type u} [add_monoid R] [star_add_monoid R] : R ‚âÉ+ R
(Œ± : Type u_1) : Type u_1
{n : ‚Ñï+} (h1 : n ‚â† 1) : ‚àÉ (k : ‚Ñï+), n = k + 1
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {s : set E} : differentiable_on ùïú f s ‚Üí mdifferentiable_on (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f s
{M : Type u_1} [monoid M] {a : M} (h : is_unit a) : MÀ£
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üío Œ≤) : with_bot Œ± ‚Üío with_bot Œ≤
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (s : submodule K V) : finite_dimensional.finrank K (V ‚ß∏ s) + finite_dimensional.finrank K ‚Ü•s = finite_dimensional.finrank K V
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] (a : R) : multiset R
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (e : local_homeomorph Œ± Œ≤) {f : Œ≤ ‚Üí Œ≥} {s : set Œ≤} {x : Œ≤} (h : x ‚àà e.to_local_equiv.target) : continuous_within_at f s x ‚Üî continuous_within_at (f ‚àò ‚áëe) (‚áëe ‚Åª¬π' s) (‚áë(e.symm) x)
(_x : interactive.parse (lean.parser.tk "#list_linters")) : lean.parser unit
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {T : add_submonoid P} {Q : Type u_4} [add_comm_monoid Q] (k : T.localization_map Q) {j : M ‚âÉ+ P} (H : add_submonoid.map j.to_add_monoid_hom S = T) : N ‚âÉ+ Q
 : local_equiv ‚Ü•circle ‚Ñù
 : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D·µí·µñ} [category_theory.faithful F] : category_theory.faithful F.left_op
{R : Type u} {S : Type v} [ring R] [ring S] (f : R ‚Üí+* S) (s : subring R) : subring S
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F G : J ‚•§ C} [category_theory.limits.has_limit F] [category_theory.limits.has_limit G] (w : F ‚âÖ G) : category_theory.limits.limit F ‚âÖ category_theory.limits.limit G
{C : Type u} : (category_theory.discrete ‚àò category_theory.free_monoidal_category.normal_monoidal_object) C ‚•§ category_theory.free_monoidal_category C
{A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] {x : B} [nontrivial A] (hx : is_integral A x) : minpoly A x ‚â† 0
{A : Type w} {B : Type u‚ÇÅ} {C : Type u_1} {D : Type u_2} [comm_semiring A] [comm_semiring C] [comm_semiring D] [algebra A C] [algebra A D] [comm_semiring B] [algebra A B] [algebra B C] [is_scalar_tower A B C] : (C ‚Üí‚Çê[A] D) ‚âÉ Œ£ (f : B ‚Üí‚Çê[A] D), C ‚Üí‚Çê[B] D
{Œ± : Type u_1} {Œ≤ : Type u_2} {s : set Œ±} {t : Œ± ‚Üí set Œ≤} {x : Œ±} {y : Œ≤} (xs : x ‚àà s) (ytx : y ‚àà t x) : y ‚àà ‚ãÉ (x : Œ±) (H : x ‚àà s), t x
(p : ‚Ñï) {idx : Type u_2} [hp : fact (nat.prime p)] (Œ¶ : mv_polynomial idx ‚Ñö) (n : ‚Ñï) : witt_structure_rat p Œ¶ n = ‚áëmv_polynomial.C (1 / ‚Üëp ^ n) * (‚áë(mv_polynomial.bind‚ÇÅ (Œª (b : idx), ‚áë(mv_polynomial.rename (Œª (i : ‚Ñï), (b, i))) (witt_polynomial p ‚Ñö n))) Œ¶ - (finset.range n).sum (Œª (i : ‚Ñï), ‚áëmv_polynomial.C (‚Üëp ^ i) * witt_structure_rat p Œ¶ i ^ p ^ (n - i)))
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : X
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} (f : J ‚Üí (X ‚ü∂ Y)) : Prop
{E : Type u_2} [normed_group E] [normed_space ‚Ñù E] [strict_convex_space ‚Ñù E] {x y z : E} {a b r : ‚Ñù} (hx : x ‚àà metric.closed_ball z r) (hy : y ‚àà metric.closed_ball z r) (hne : x ‚â† y) (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : a ‚Ä¢ x + b ‚Ä¢ y ‚àà metric.ball z r
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ± ‚Üí Œ≤ √ó Œ≥} {x : Œ±} (hf : continuous_at f x) : continuous_at (Œª (a : Œ±), (f a).snd) x
(M : Type u_1) [add_monoid M] : add_submonoid M
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] (f : P1 ‚Üí·µÉ[k] P2) (p : P1) (v : V1) : ‚áëf (v +·µ• p) = ‚áë(f.linear) v +·µ• ‚áëf p
{Œ± : Type u_1} [semilattice_sup Œ±] (f : ‚Ñï ‚Üí Œ±) : ‚Ñï ‚Üío Œ±
(Œ± : Type u_3) [lattice Œ±] [bounded_order Œ±] : bounded_lattice_hom Œ± Œ±
{Œ± : Type u_1} (Œ¥ : Œ± ‚Üí Type u_2) (a : Œ±) (H : a ‚àà 0) : Œ¥ a
(x : Class) : Class
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : Prop
 : ‚Ü•(set.Icc (-(real.pi / 2)) (real.pi / 2)) ‚âÉo ‚Ü•(set.Icc (-1) 1)
{R : Type u_1} {R‚ÇÅ : Type u_2} {R‚ÇÇ : Type u_3} {M‚ÇÅ : Type u_6} {M‚ÇÇ : Type u_7} [comm_semiring R] [comm_semiring R‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {I‚ÇÅ : R‚ÇÅ ‚Üí+* R} {I‚ÇÇ : R‚ÇÇ ‚Üí+* R} {B : M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ] M‚ÇÇ ‚Üí‚Çõ‚Çó[I‚ÇÇ] R} : B.separating_right ‚Üî B.flip.ker = ‚ä•
(b : ‚Ñï) : ‚Ñï ‚Üí ‚Ñï
(R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A] : A ‚Üí‚Çê[R] A
(p : ‚Ñï) (r : ‚Ñö) : ‚Ñ§
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.regular_mono f] [e : category_theory.epi f] : category_theory.is_iso f
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [is_R_or_C ùïú] [inner_product_space ùïú E] [inner_product_space ùïú F] [inner_product_space ùïú G] [finite_dimensional ùïú E] [finite_dimensional ùïú F] [finite_dimensional ùïú G] (A : F ‚Üí‚Çó[ùïú] G) (B : E ‚Üí‚Çó[ùïú] F) : ‚áëlinear_map.adjoint (A.comp B) = (‚áëlinear_map.adjoint B).comp (‚áëlinear_map.adjoint A)
{Œ± : Type u} {Œ≤ : Type v} (r : rel Œ± Œ≤) (l‚ÇÅ : filter Œ±) (l‚ÇÇ : filter Œ≤) : Prop
(X : CompHaus) : Profinite
(decls : list declaration) (group_by_filename : option ‚Ñï) (where_desc : string) (slow : bool) (verbose : lint_verbosity) (checks : list (name √ó linter)) : tactic (name_set √ó format)
{G : Type u_1} [add_group G] : has_inf (add_subgroup G)
{G : Type u_1} [comm_group G] : group.nilpotency_class G ‚â§ 1
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b : Œ±} : -a < b ‚Üí -b < a
{E : Type u_2} [semi_normed_group E] [normed_space ‚Ñù E] {s : set E} (hs : convex ‚Ñù s) : convex_on ‚Ñù s has_norm.norm
{Œ± : Type u_1} : as_boolring Œ± ‚âÉ Œ±
{Œ± : Type u_1} [has_lt Œ±] {a b : Œ±} : a ‚ãñ b ‚Üí ‚áëorder_dual.to_dual b ‚ãñ ‚áëorder_dual.to_dual a
{Œπ : Type v} (o : category_theory.pairwise Œπ) : o.hom o
{n : ‚Ñï} (Œ± : typevec n) : (Œ±.prod Œ±).arrow (typevec.repeat n Prop)
{R S : Type u} [comm_ring R] [comm_ring S] (M : submonoid R) (S' : Type u) [comm_ring S'] [algebra S S'] [algebra R S] [algebra R S'] [is_scalar_tower R S S'] [is_localization (submonoid.map ‚Üë(algebra_map R S) M) S'] (x : S) (s : finset S') (hx : ‚áë(algebra_map S S') x ‚àà algebra.adjoin R ‚Üës) : ‚àÉ (m : ‚Ü•M), m ‚Ä¢ x ‚àà algebra.adjoin R ‚Üë(is_localization.finset_integer_multiple (submonoid.map ‚Üë(algebra_map R S) M) s)
{Œπ : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [ordered_add_comm_monoid N] (f : M ‚Üí N) (p : M ‚Üí Prop) (h_one : f 0 = 0) (h_mul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí f (x + y) ‚â§ f x + f y) (hp_mul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x + y)) (g : Œπ ‚Üí M) {s : finset Œπ} (hs : ‚àÄ (i : Œπ), i ‚àà s ‚Üí p (g i)) : f (s.sum (Œª (i : Œπ), g i)) ‚â§ s.sum (Œª (i : Œπ), f (g i))
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] (f : S.localization_map N) : f.of_add_equiv_of_dom _ = f
{X Y : Type u} (f g : X ‚ü∂ Y) : category_theory.limits.coequalizer f g ‚âÖ quot (category_theory.limits.types.coequalizer_rel f g)
(n : ‚Ñï) (R : Type u_1) (hpos : 0 < n) [ring R] [nontrivial R] : 0 < (polynomial.cyclotomic n R).degree
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {s t : set Œ±} (hst : disjoint s t) (hs : (s ‚à© function.support f).finite) (ht : (t ‚à© function.support f).finite) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s ‚à™ t), f i)) = finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)) + finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà t), f i))
{ùïú : Type u_3} {E : Type u_4} [normed_field ùïú] [add_comm_group E] [normed_space ‚Ñù ùïú] [module ùïú E] [module ‚Ñù E] [is_scalar_tower ‚Ñù ùïú E] (p : seminorm ùïú E) (x : E) (r : ‚Ñù) : convex ‚Ñù (p.ball x r)
{R : Type u} [ring R] (M N : Module R) : category_theory.limits.limit_cone (category_theory.limits.pair M N)
(_x : interactive.parse (lean.parser.tk "#explode_widget")) : lean.parser unit
{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : submonoid A
{t : Type u ‚Üí Type u ‚Üí Type u} [bitraversable t] (F : Type u ‚Üí Type u) [traversable F] {m : Type u ‚Üí Type u} [applicative m] {Œ± Œ≤ Œ±' Œ≤' : Type u} (f : Œ± ‚Üí m Œ≤) (f' : Œ±' ‚Üí m Œ≤') : function.bicompr F t Œ± Œ±' ‚Üí m (function.bicompr F t Œ≤ Œ≤')
{K : Type u} {L : Type v} (M : Type w) [field K] [field L] [algebra K L] [field M] [algebra K M] [is_alg_closed M] (hL : algebra.is_algebraic K L) : lift.subfield_with_hom K L M hL
(C : Type u‚ÇÅ) [category_theory.category C] : C·µí·µñ·µí·µñ ‚•§ C
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {x y : E} : has_inner.inner (x + y) (x + y) + has_inner.inner (x - y) (x - y) = 2 * (has_inner.inner x x + has_inner.inner y y)
(X : BoundedDistribLattice) : BoundedLattice
{C : Type u} [category_theory.category C] (J‚ÇÅ : category_theory.grothendieck_topology C) {X Y : C} (f : Y ‚ü∂ X) (S : category_theory.sieve X) : J‚ÇÅ.close (category_theory.sieve.pullback f S) = category_theory.sieve.pullback f (J‚ÇÅ.close S)
{Œ± : Type u_2} [bornology Œ±] {s : set Œ±} : bornology.is_cobounded s·∂ú ‚Üí bornology.is_bounded s
{C : Type u‚ÇÅ} [category_theory.category C] (J : category_theory.grothendieck_topology C) : category_theory.SheafOfTypes J ‚•§ C·µí·µñ ‚•§ Type w
{p : ‚Ñï} [hp : fact (nat.prime p)] (x : witt_vector p (zmod p)) : ‚áëwitt_vector.verschiebung x = x * ‚Üëp
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} {s‚ÇÅ s‚ÇÇ : affine.simplex ‚Ñù P n} (h : set.range s‚ÇÅ.points = set.range s‚ÇÇ.points) : s‚ÇÅ.circumcenter = s‚ÇÇ.circumcenter
{C : Type u} [category_theory.category C] {A B : C} (f g : A ‚ü∂ B) : Prop
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± Œ≤ : typevec n} (g : Œ±.arrow Œ≤) : mvqpf.fix F Œ± ‚Üí mvqpf.fix F Œ≤
(C : Type u) [category_theory.category C] : Prop
{Œπ : Type u_1} [decidable_eq Œπ] (R : Type u_4) [comm_semiring R] {s : Œπ ‚Üí Type u_7} [Œ† (i : Œπ), add_comm_monoid (s i)] [Œ† (i : Œπ), module R (s i)] : multilinear_map R s (pi_tensor_product R (Œª (i : Œπ), s i))
(Œ± : Type u) (Œ≤ : Type v) [monoid Œ±] [mul_action Œ± Œ≤] : set Œ≤
{Œ± : Type u_1} [circular_preorder Œ±] (a b : Œ±) : set Œ±
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [is_R_or_C ùïÇ] [normed_comm_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] {x y : ùî∏} : exp ùïÇ (x + y) = exp ùïÇ x * exp ùïÇ y
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : composition_series X
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (x : Œ± 0) (p : Œ† (i : fin n), Œ± i.succ) (z : Œ± 0) : function.update (fin.cons x p) 0 z = fin.cons z p
{M : Type u_1} [has_add M] (s : set M) : add_subsemigroup M
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [fintype Œπ] [decidable_eq Œπ] [Œ† (i : Œπ), decidable_eq (Œ± i)] {p : (Œ† (i : Œπ), finset (Œ± i)) ‚Üí Prop} (f : Œ† (i : Œπ), finset (Œ± i)) (h0 : p (Œª (_x : Œπ), ‚àÖ)) (step : ‚àÄ (g : Œ† (i : Œπ), finset (Œ± i)) (i : Œπ) (x : Œ± i), x ‚àâ g i ‚Üí p g ‚Üí p (function.update g i (has_insert.insert x (g i)))) : p f
{Œ± : Type u_1} {Œ≤ : Type u_2} [decidable_eq Œ±] [decidable_eq Œ≤] (f : Œ± ‚Üí Œ≤) (s : multiset Œ±) (hf : function.injective f) (x : Œ±) : multiset.count (f x) (multiset.map f s) = multiset.count x s
(f : cau_seq ‚ÑÇ complex.abs) : cau_seq ‚Ñù has_abs.abs
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K‚ÇÅ K‚ÇÇ : submodule ùïú E} (h : K‚ÇÅ ‚â§ K‚ÇÇ) : K‚ÇÇ·óÆ ‚â§ K‚ÇÅ·óÆ
{G : Type u_7} [comm_group G] (L : list G) (n : ‚Ñï) (a : G) : (L.update_nth n a).prod = L.prod * dite (n < L.length) (Œª (hn : n < L.length), (L.nth_le n hn)‚Åª¬π * a) (Œª (hn : ¬¨n < L.length), 1)
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] (F : J ‚•§ algebraic_geometry.PresheafedSpace C) : category_theory.limits.is_colimit (algebraic_geometry.PresheafedSpace.colimit_cocone F)
{Œ± : Type u_1} [has_sup Œ±] [has_inf Œ±] (sup_comm : ‚àÄ (a b : Œ±), a ‚äî b = b ‚äî a) (sup_assoc : ‚àÄ (a b c : Œ±), a ‚äî b ‚äî c = a ‚äî (b ‚äî c)) (inf_comm : ‚àÄ (a b : Œ±), a ‚äì b = b ‚äì a) (inf_assoc : ‚àÄ (a b c : Œ±), a ‚äì b ‚äì c = a ‚äì (b ‚äì c)) (sup_inf_self : ‚àÄ (a b : Œ±), a ‚äî a ‚äì b = a) (inf_sup_self : ‚àÄ (a b : Œ±), a ‚äì (a ‚äî b) = a) : lattice Œ±
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± : D·µí·µñ ‚•§ Type v} {‚Ñ±' : category_theory.SheafOfTypes K} (Œ± : G.op ‚ãô ‚Ñ± ‚ü∂ G.op ‚ãô ‚Ñ±'.val) (X : D) : ‚Ñ±.obj (opposite.op X) ‚ü∂ ‚Ñ±'.val.obj (opposite.op X)
{Œ± : Type u_1} {Œπ : Sort u_4} (l : filter Œ±) (p : Œπ ‚Üí Prop) (s : Œπ ‚Üí set Œ±) : Prop
{L : first_order.language} {M : Type u_3} {N : Type u_4} [L.Structure M] (e : M ‚âÉ N) : L.equiv M N
(R : Type u) (M‚ÇÇ : Type v‚ÇÇ) (M' : Type v') [comm_semiring R] [add_comm_monoid M'] [add_comm_monoid M‚ÇÇ] [module R M'] [module R M‚ÇÇ] {k l n : ‚Ñï} {s : finset (fin n)} (hk : s.card = k) (hl : s·∂ú.card = l) : multilinear_map R (Œª (x : fin n), M') M‚ÇÇ ‚âÉ‚Çó[R] multilinear_map R (Œª (x : fin k), M') (multilinear_map R (Œª (x : fin l), M') M‚ÇÇ)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G : J ‚•§ C} (Œ± : F ‚âÖ G) (c : category_theory.limits.cone F) (d : category_theory.limits.cone G) (w : (category_theory.limits.cones.postcompose Œ±.hom).obj c ‚âÖ d) : category_theory.limits.is_limit c ‚âÉ category_theory.limits.is_limit d
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} {p : Œπ ‚Üí P} (hp : affine_independent k p) (j : Œπ) (w : Œπ ‚Üí kÀ£) : affine_independent k (Œª (i : Œπ), ‚áë(affine_map.line_map (p j) (p i)) ‚Üë(w i))
(Œ± : Type u) : Type u
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A ‚ü∂ B) [category_theory.limits.has_image f] (g : B ‚ü∂ C) [category_theory.limits.has_kernel g] (w : f ‚â´ g = 0) : ‚Üë(category_theory.limits.image_subobject f) ‚ü∂ ‚Üë(category_theory.limits.kernel_subobject g)
(f : name ‚Üí option name) : name ‚Üí name
(Œ± : Type u_2) [fintype Œ±] [lattice Œ±] [bounded_order Œ±] : complete_lattice Œ±
(p : ‚Ñï) : ‚Ñï+
 : Type
{Œ± : Type u_1} {Œ≤ : Type u_2} [partial_order Œ±] [preorder Œ≤] [order_top Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : galois_connection l u) : order_top Œ±
{R : Type u} [ring R] {J : Type w} [category_theory.category J] (F : J ‚•§ Module R) : Module R
{Œ± : Type u_2} [decidable_eq Œ±] [has_inv Œ±] {s : finset Œ±} : s‚Åª¬π.nonempty ‚Üí s.nonempty
{C : Type u‚ÇÅ} [category_theory.small_category C] {‚Ñ∞ : Type u‚ÇÇ} [category_theory.category ‚Ñ∞] (A : C ‚•§ ‚Ñ∞) [category_theory.limits.has_colimits ‚Ñ∞] : (C·µí·µñ ‚•§ Type u‚ÇÅ) ‚•§ ‚Ñ∞
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) (a : Œ±) : Prop
{M : Type u_1} [has_add M] : has_le (add_con M)
{H : Type u_1} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] {H' : Type u_3} {M' : Type u_4} [topological_space H'] [topological_space M'] [charted_space H' M'] (P : (H ‚Üí H') ‚Üí set H ‚Üí H ‚Üí Prop) (f : M ‚Üí M') (s : set M) : Prop
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] {E : Type w} [normed_group E] [normed_space ùïú E] {f : ùïú ‚Üí F} {f' : F} (x : ùïú) {s : set ùïú} {l : F ‚Üí E} {l' : F ‚ÜíL[ùïú] E} {t : set F} (hl : has_fderiv_within_at l l' t (f x)) (hf : has_deriv_within_at f f' s x) (hst : set.maps_to f s t) : has_deriv_within_at (l ‚àò f) (‚áël' f') s x
{n : Type u} [decidable_eq n] [fintype n] {K : Type u_1} [field K] (A : matrix n n K) (h : A.det ‚â† 0) : GL n K
 : num ‚Üí list turing.partrec_to_TM2.Œì'
(R : Type u_1) (C : Type u) : Type u
{Œ± : Type u} [pseudo_metric_space Œ±] (x y : Œ±) : has_nndist.nndist x y = (has_edist.edist x y).to_nnreal
{m : Type u_1} (R : Type u_3) {S : Type u_4} [fintype m] [decidable_eq m] [comm_semiring R] [comm_semiring S] [algebra R S] (A : matrix m m S) : ‚áë((mv_polynomial.aeval (Œª (p : m √ó m), A p.fst p.snd)).map_matrix) (matrix.mv_polynomial_X m m R) = A
{M‚ÇÄ : Type u_1} [mul_zero_one_class M‚ÇÄ] : 0 = 1 ‚Üî subsingleton M‚ÇÄ
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} (G : C ‚•§ D) (t : category_theory.limits.cone F) : (G.map_cone t).op ‚âÖ G.op.map_cocone t.op
(Œ± : Type u_5) [T : topological_space Œ±] : Type (max u_5 (u_6+1))
{R : Type u} [ring R] {Œ± : Type u_1} [add_monoid Œ±] [distrib_mul_action R Œ±] (S : subring R) : distrib_mul_action ‚Ü•S Œ±
{c : cardinal} (h : cardinal.aleph_0 ‚â§ c) : c * c = c
{G : Type u_1} [group G] [fintype G] (S : set G) (hS : S.nonempty) : subgroup G
{Œ± : Type u} {Œ≤ : Type v} [group Œ≤] : (Œ± ‚Üí Œ≤) ‚âÉ (free_group Œ± ‚Üí* Œ≤)
(ns : name) : tactic (list name)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : Œ± ‚âÉ‚Çú Œ≤) : C(Œ±, Œ≤)
{R : Type u_1} {M : Type u_9} {M‚ÇÇ : Type u_12} [comm_semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] (p : submodule R M) : (M ‚Üí‚Çó[R] M‚ÇÇ) ‚Üí‚Çó[R] ‚Ü•p ‚Üí‚Çó[R] M‚ÇÇ
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Group) : category_theory.creates_limit F (category_theory.forget‚ÇÇ Group Mon)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (P : submodule R M) : has_scalar R (M ‚ß∏ P)
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : computation Œ± ‚Üí computation Œ≤
(n : ‚Ñï) {m : ‚Ñï} : fin m ‚Ü™o fin (n + m)
(k : Type u) [field k] (m n : ‚Ñï) (h : m ‚â§ n) : algebraic_closure.step k m ‚Üí+* algebraic_closure.step k n
(C : Type u) [category_theory.category C] : Prop
{X Y : algebraic_geometry.LocallyRingedSpace} (f : X.to_SheafedSpace ‚âÖ Y.to_SheafedSpace) : X ‚âÖ Y
{Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ±] [preorder Œ±] [topological_space Œ≤] [preorder Œ≤] (f : esakia_hom Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : esakia_hom Œ± Œ≤
{Œ± : Type u} {Œ≤ : Type v} [has_sup Œ±] [has_inf Œ±] [has_Sup Œ±] [has_Inf Œ±] [has_top Œ±] [has_bot Œ±] [complete_distrib_lattice Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.injective f) (map_sup : ‚àÄ (a b : Œ±), f (a ‚äî b) = f a ‚äî f b) (map_inf : ‚àÄ (a b : Œ±), f (a ‚äì b) = f a ‚äì f b) (map_Sup : ‚àÄ (s : set Œ±), f (has_Sup.Sup s) = ‚®Ü (a : Œ±) (H : a ‚àà s), f a) (map_Inf : ‚àÄ (s : set Œ±), f (has_Inf.Inf s) = ‚®Ö (a : Œ±) (H : a ‚àà s), f a) (map_top : f ‚ä§ = ‚ä§) (map_bot : f ‚ä• = ‚ä•) : complete_distrib_lattice Œ±
{R : Type u_1} (S : Type u_4) [semiring R] [semiring S] {M : Type u_6} [topological_space M] [add_comm_monoid M] [module R M] {N‚ÇÉ : Type u_10} [topological_space N‚ÇÉ] [add_comm_monoid N‚ÇÉ] [module R N‚ÇÉ] [module S N‚ÇÉ] [smul_comm_class R S N‚ÇÉ] [has_continuous_const_smul S N‚ÇÉ] [has_continuous_add N‚ÇÉ] : (M ‚ÜíL[R] N‚ÇÉ) ‚Üí‚Çó[S] M ‚Üí‚Çó[R] N‚ÇÉ
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] (P : C·µí·µñ ‚•§ D) [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] : P ‚ü∂ J.plus_obj P
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} (X : T.algebra) : category_theory.is_split_coequalizer (T.to_functor.map X.a) (T.Œº.app X.A) X.a
{E : Type u_1} [normed_group E] {a : ‚Ñù} {f g : ‚ÑÇ ‚Üí E} {l : filter ‚ÑÇ} (hBf : ‚àÉ (c : ‚Ñù) (H : c < a) (B : ‚Ñù), f =O[filter.comap complex.abs filter.at_top ‚äì l] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)) (hBg : ‚àÉ (c : ‚Ñù) (H : c < a) (B : ‚Ñù), g =O[filter.comap complex.abs filter.at_top ‚äì l] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)) : ‚àÉ (c : ‚Ñù) (H : c < a) (B : ‚Ñù), (f - g) =O[filter.comap complex.abs filter.at_top ‚äì l] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G H : C ‚•§ D} (Œ± : category_theory.nat_trans F G) (Œ≤ : category_theory.nat_trans G H) : category_theory.nat_trans F H
{X Y Z : algebraic_geometry.Scheme} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [H : algebraic_geometry.is_open_immersion f] (H' : set.range ‚áë(g.val.base) ‚äÜ set.range ‚áë(f.val.base)) : Y ‚ü∂ X
 : tactic_state ‚Üí expr ‚Üí format
 : tactic unit
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] : algebraic_geometry.SheafedSpace C ‚•§ algebraic_geometry.PresheafedSpace C
(K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : set V) : ‚Ñï
{Œ± : Type u} {s t : set Œ±} {l : filter Œ±} : (‚àÄ·∂† (x : Œ±) in l, x ‚àà s ‚Üî x ‚àà t) ‚Üí s =·∂†[l] t
{C : Type u} (X Y : C) : category_theory.limits.walking_pair ‚Üí C
(e : environment) (d : declaration) : bool
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : sym2 Œ± ‚Üí sym2 Œ≤
(R : Type u) (A : Type v) (B : Type w) [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B] : Type (max v w)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (r : setoid Œ≤) : setoid Œ±
 : linter
(Œ± : Sort u) (default : Œ±) : Sort u
{Œπ : Type u_1} {Œ± : Type u_2} [has_zero Œ±] [partial_order Œ±] [locally_finite_order Œ±] (f g : Œπ ‚Üí‚ÇÄ Œ±) : Œπ ‚Üí‚ÇÄ finset Œ±
(h : expr) (hs : list expr) : tactic bool
{X Y : CompHaus} (f : X ‚ü∂ Y) : is_closed_map ‚áëf
{G : Type u_10} {H : Type u_11} [group G] [division_monoid H] (h : G ‚âÉ* H) (x y : G) : ‚áëh (x / y) = ‚áëh x / ‚áëh y
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (oi : Œ± ‚âÉo Œ≤) : galois_coinsertion ‚áëoi ‚áë(oi.symm)
{C : Type u‚ÇÅ} [category_theory.category C] (D : category_theory.glue_data C) [category_theory.limits.has_coproduct D.U] : C
{C : Type u‚ÇÅ} [category_theory.category C] {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B) [category_theory.mono f] [category_theory.mono g] (h : category_theory.subobject.mk f ‚â§ category_theory.subobject.mk g) : A‚ÇÅ ‚ü∂ A‚ÇÇ
{Œ± : Type u_1} {Œ≤ : Type u_2} {e e' : local_equiv Œ± Œ≤} (h : e ‚âà e') : e.source = e'.source
{X : Type u} {Œ± : Type v} [topological_space X] [linear_order Œ±] [topological_space Œ±] [order_closed_topology Œ±] {s : set X} (hs : is_preconnected s) {a b : X} (ha : a ‚àà s) (hb : b ‚àà s) {f g : X ‚Üí Œ±} (hf : continuous_on f s) (hg : continuous_on g s) (ha' : f a ‚â§ g a) (hb' : g b ‚â§ f b) : ‚àÉ (x : X) (H : x ‚àà s), f x = g x
{z w : ‚ÑÇ} (hz : 0 ‚â§ z.re ‚à® z.im ‚â† 0) (hw : 0 < w.re) : continuous_at (Œª (x : ‚ÑÇ), x ^ w) z
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} {f' : ‚Ñù ‚Üí E} (hab : a ‚â§ b) (hcont : continuous_on f (set.Icc a b)) (hderiv : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí has_deriv_at f (f' x) x) (hint : interval_integrable f' measure_theory.measure_space.volume a b) : ‚à´ (y : ‚Ñù) in a..b, f' y = f b - f a
{k : Type u_1} {V : Type u_2} (P : Type u_3) [comm_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) : (Œπ ‚Üí P) √ó P ‚Üí·µÉ[k] V
(C : Type u) [category_theory.category C] {X : C} {f : X ‚ü∂ X} (hf : f ‚â´ f = f) [category_theory.limits.has_equalizer (ùüô X) f] : category_theory.split_mono (category_theory.limits.equalizer.Œπ (ùüô X) f)
(n : ‚Ñï) : ‚Ñ§ ‚Üí bitvec n.succ
(Œ± : Type u_1) [complete_lattice Œ±] : Prop
{M : Type u_3} {S : Type u_4} [sub_neg_monoid M] [set_like S M] [hSM : add_subgroup_class S M] {H : S} : has_neg ‚Ü•H
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.has_projective_resolution X] [category_theory.has_projective_resolution Y] : category_theory.projective_resolution X ‚ü∂ category_theory.projective_resolution Y
{M : Type u} [monoid M] {R : Type v} [semiring R] [mul_semiring_action M R] (H : submonoid M) : mul_semiring_action ‚Ü•H R
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {ta1 ta2 : topological_space Œ±} {tb1 tb2 : topological_space Œ≤} {tc1 : topological_space Œ≥} (h : continuous (Œª (p : Œ± √ó Œ≤), f p.fst p.snd)) : continuous (Œª (p : Œ± √ó Œ≤), f p.fst p.snd)
(p : ‚Ñï) [hp : fact (nat.prime p)] : is_absolute_value (padic_norm p)
(e : expr) : tactic expr
(transp : tactic.transparency) (e : expr) : tactic (expr √ó expr)
{C : Type u‚ÇÅ} [category_theory.small_category C] {P‚ÇÅ P‚ÇÇ : C·µí·µñ ‚•§ Type u‚ÇÅ} (Œ± : P‚ÇÅ ‚ü∂ P‚ÇÇ) (j : (P‚ÇÅ.elements)·µí·µñ) : (category_theory.cocone_of_representable P‚ÇÅ).Œπ.app j ‚â´ Œ± = (category_theory.cocone_of_representable P‚ÇÇ).Œπ.app ((category_theory.category_of_elements.map Œ±).op.obj j)
 : lean.parser unit
{M : Type u_1} {N : Type u_2} [unique M] [unique N] [has_add M] [has_mul M] [has_add N] [has_mul N] : M ‚âÉ+* N
(Œ± : Type u) {Œ≤ : Type v} [group Œ±] [mul_action Œ± Œ≤] (x : Œ≤) (g : Œ± ‚ß∏ mul_action.stabilizer Œ± x) : Œ≤
(opt : tactic.solve_by_elim.opt) : tactic (list (tactic expr) √ó tactic (list expr))
{R : Type x} {S : Type u_1} [has_mul R] [has_add R] [distrib S] (f : R ‚Üí S) (hf : function.injective f) (add : ‚àÄ (x y : R), f (x + y) = f x + f y) (mul : ‚àÄ (x y : R), f (x * y) = f x * f y) : distrib R
 : tactic unit
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} (f : Œ≤ ‚Üí Œ≥) : Œ± ‚äï Œ≤ ‚Üí Œ± ‚äï Œ≥
(R : Type u_1) [rack R] : shelf_hom R (quandle.conj (rack.envel_group R))
{Œ± : Type u_1} : measure_theory.outer_measure Œ± ‚Üí+ set Œ± ‚Üí ennreal
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : C(X, ‚Ñù)) (e : X ‚Üí Y) (he : closed_embedding e) : ‚àÉ (g : C(Y, ‚Ñù)), ‚áëg ‚àò e = ‚áëf
{p : ‚Ñï} (hp : nat.prime p) {n b : ‚Ñï} : nat.log p n < b ‚Üí multiplicity p n.factorial = ‚Üë((finset.Ico 1 b).sum (Œª (i : ‚Ñï), n / p ^ i))
(n : ‚Ñï) : list {m // has_well_founded.r m n}
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {Œπ : Type u_3} (e : Œπ ‚Üí M) (l : Œπ ‚Üí‚ÇÄ R) : M
{R : Type u} [semiring R] [no_zero_divisors R] : polynomial R ‚Üí* R
(G : Type u_1) [group G] : group.is_nilpotent G ‚Üî ‚àÉ (n : ‚Ñï) (H : ‚Ñï ‚Üí subgroup G), is_ascending_central_series H ‚àß H n = ‚ä§
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} (r : Œπ ‚Üí Œπ ‚Üí Prop) (s : Œ† (i : Œπ), Œ± i ‚Üí Œ± i ‚Üí Prop) (a b : Œ£ (i : Œπ), Œ± i) : Prop
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f g : Œ± ‚Üí M} {s : set Œ±} (hs : s.finite) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i * g i)) = finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)) * finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), g i))
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [finite_dimensional ùïú E] (T : E ‚Üí‚Çó[ùïú] E) (x : E) : 0 ‚â§ ‚áëis_R_or_C.re (has_inner.inner x (‚áë(‚áëlinear_map.adjoint T * T) x))
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [category_theory.limits.has_pushout f g] : Y ‚ü∂ category_theory.limits.pushout f g
{M : Type u_5} [has_zero M] {Œπ : Type u_1} [unique Œπ] : (Œπ ‚Üí‚ÇÄ M) ‚âÉ M
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} [category_theory.limits.has_equalizer f g] : category_theory.mono (category_theory.limits.equalizer.Œπ f g)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {s : set ùïú} {n : with_top ‚Ñï} (hs : unique_diff_on ùïú s) : cont_diff_on ùïú n f s ‚Üî (‚àÄ (m : ‚Ñï), ‚Üëm ‚â§ n ‚Üí continuous_on (iterated_deriv_within m f s) s) ‚àß ‚àÄ (m : ‚Ñï), ‚Üëm < n ‚Üí differentiable_on ùïú (iterated_deriv_within m f s) s
(Œ± : Type u) : magma.free_semigroup (free_magma Œ±) ‚âÉ free_semigroup Œ±
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {l : filter Œ±} {a : Œ±} : is_min_filter f l a ‚Üí is_max_filter (‚áëorder_dual.to_dual ‚àò f) l a
{Œ± : Type u_1} [has_le Œ±] (a : Œ±) : Prop
{G : Type u_1} [add_group G] {H : add_subgroup G} {S : set G} (hS : S ‚àà add_subgroup.left_transversals ‚ÜëH) : G ‚Üí ‚Ü•S
 : list name ‚Üí option tactic.interactive.case_tag
{Œ± : Type u_1} [measurable_space Œ±] : partial_order (measure_theory.measure Œ±)
{B : Type u_3} {S : B} {M : Type u_1} [add_comm_monoid M] [set_like B M] [add_submonoid_class B M] {Œπ : Type u_2} {t : finset Œπ} {f : Œπ ‚Üí M} (h : ‚àÄ (c : Œπ), c ‚àà t ‚Üí f c ‚àà S) : t.sum (Œª (c : Œπ), f c) ‚àà S
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] {F : Type v} [normed_group F] [normed_space ‚ÑÇ F] [nontrivial E] [finite_dimensional ‚ÑÇ E] {f : E ‚Üí F} {U : set E} (hb : metric.bounded U) (hne : U.nonempty) (hd : diff_cont_on_cl ‚ÑÇ f U) : ‚àÉ (z : E) (H : z ‚àà frontier U), is_max_on (has_norm.norm ‚àò f) (closure U) z
{Œ± : Type u_1} [complete_lattice Œ±] {a : Œ±} {s : set Œ±} : (‚®Ü (b : Œ±) (H : b ‚àà s), b ‚äì a) ‚â§ has_Sup.Sup s ‚äì a
(R : Type u) (L : Type v) (L' : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] : Type (max v w)
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (q : ‚Ñï) : algebraic_topology.alternating_face_map_complex C ‚ü∂ algebraic_topology.alternating_face_map_complex C
{Œ± : Type u_3} [linear_ordered_add_comm_group Œ±] : filter.tendsto has_abs.abs filter.at_top filter.at_top
{Œ± : Type u_1} (s : finset Œ±) : finset.colex Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [add_group Œ±] [uniform_add_group Œ±] {hom : Type u_3} [uniform_space Œ≤] [add_group Œ≤] [uniform_add_group Œ≤] [add_monoid_hom_class hom Œ± Œ≤] (f : hom) (hf : continuous_at ‚áëf 0) : uniform_continuous ‚áëf
{M : Type u_5} [monoid M] {R : Type u_11} [semiring R] [mul_semiring_action M R] {S : Type u_13} [semiring S] [mul_semiring_action M S] (self : R ‚Üí+*[M] S) : R ‚Üí+[M] S
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (G : C ‚•§ D) [G.preserves_zero_morphisms] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] [category_theory.limits.has_kernel (G.map f)] [i : category_theory.is_iso (category_theory.limits.kernel_comparison f G)] : category_theory.limits.preserves_limit (category_theory.limits.parallel_pair f 0) G
{n : ‚Ñï} (F : typevec (n + 1) ‚Üí Type u) [mvfunctor F] [q : mvqpf F] (Œ± : typevec n) : Type u
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [‚Ñ∞ : category_theory.category E] (F : C ‚•§ D) (G : D ‚•§ E) [Fl : category_theory.is_left_adjoint F] [Gl : category_theory.is_left_adjoint G] : category_theory.is_left_adjoint (F ‚ãô G)
{G : Type u} [group G] {A : Type v} [comm_group A] : (G ‚Üí* A) ‚âÉ (abelianization G ‚Üí* A)
(Œ± : Type u_3) : Type u_3
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p : P) (s1 s2 : affine_subspace k P) : p ‚àà s1 ‚äì s2 ‚Üî p ‚àà s1 ‚àß p ‚àà s2
(n : ‚Ñï) {m : ‚Ñù} (m1 : 1 < m) : ‚àë' (i : ‚Ñï), 1 / m ^ (i + (n + 1)).factorial < (1 - 1 / m)‚Åª¬π * (1 / m ^ (n + 1).factorial)
{M : Type u_3} [add_comm_group M] {R‚ÇÅ : Type u_4} [comm_ring R‚ÇÅ] [module R‚ÇÅ M] (f g : M ‚Üí‚Çó[R‚ÇÅ] R‚ÇÅ) : quadratic_form R‚ÇÅ M
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {v : ‚Ñù ‚Üí E ‚Üí E} {K : nnreal} (hv : ‚àÄ (t : ‚Ñù), lipschitz_with K (v t)) {f g : ‚Ñù ‚Üí E} {a b Œ¥ : ‚Ñù} (hf : continuous_on f (set.Icc a b)) (hf' : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_deriv_within_at f (v t (f t)) (set.Ici t) t) (hg : continuous_on g (set.Icc a b)) (hg' : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_deriv_within_at g (v t (g t)) (set.Ici t) t) (ha : has_dist.dist (f a) (g a) ‚â§ Œ¥) (t : ‚Ñù) (H : t ‚àà set.Icc a b) : has_dist.dist (f t) (g t) ‚â§ Œ¥ * real.exp (‚ÜëK * (t - a))
(q : interactive.parse (lean.parser.pexpr std.prec.max)) (cfg : tactic.apply_cfg) : tactic unit
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] : E ‚ÜíL‚ãÜ[ùïú] E ‚ÜíL[ùïú] ùïú
(Œ± : expr) : tactic unit
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) (b : P) {s‚ÇÅ s‚ÇÇ : finset Œπ} (h : s‚ÇÅ ‚äÜ s‚ÇÇ) : ‚áë(s‚ÇÅ.weighted_vsub_of_point p b) w = ‚áë(s‚ÇÇ.weighted_vsub_of_point p b) (‚Üës‚ÇÅ.indicator w)
{G : Type u_1} {H : Type u_2} [group G] [group H] [is_free_group G] [is_free_group H] (e : G ‚âÉ* H) : is_free_group.generators G ‚âÉ is_free_group.generators H
{ùïú : Type u_1} [is_R_or_C ùïú] {E : Type u_2} {E' : Type u_3} [inner_product_space ùïú E] [inner_product_space ùïú E'] (f : E ‚âÉ‚Çó·µ¢[ùïú] E') (K : submodule ùïú E) [complete_space ‚Ü•K] : reflection (submodule.map ‚Üë(f.to_linear_equiv) K) = f.symm.trans ((reflection K).trans f)
{M : Type u_5} {N : Type u_6} [mul_one_class M] [mul_one_class N] : M √ó N ‚âÉ* N √ó M
{X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {Œ≤ : Type u_1} {Œπ : Œ≤ ‚Üí Type u_3} [hŒπ : Œ† (n : Œ≤), encodable (Œπ n)] (d : ‚Ñù) (s : set X) {l : filter Œ≤} (r : Œ≤ ‚Üí ennreal) (hr : filter.tendsto r l (nhds 0)) (t : Œ† (n : Œ≤), Œπ n ‚Üí set X) (ht : ‚àÄ·∂† (n : Œ≤) in l, ‚àÄ (i : Œπ n), emetric.diam (t n i) ‚â§ r n) (hst : ‚àÄ·∂† (n : Œ≤) in l, s ‚äÜ ‚ãÉ (i : Œπ n), t n i) : ‚áë(measure_theory.measure.hausdorff_measure d) s ‚â§ l.liminf (Œª (n : Œ≤), ‚àë' (i : Œπ n), emetric.diam (t n i) ^ d)
(R : CommRing) : Top
 : Type
(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : ‚àÉ (œñ : R), prime œñ
{Œ± : Type u} (a : Œ±) (f : filter Œ±) : topological_space Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [boolean_algebra Œ±] [boolean_algebra Œ≤] (f : bounded_lattice_hom Œ± Œ≤) : as_boolring Œ± ‚Üí+* as_boolring Œ≤
(Œ± : Sort u_1) (Œ≤ : Sort u_2) : {f // function.injective f} ‚âÉ (Œ± ‚Ü™ Œ≤)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ‚ü∂ Q) [category_theory.mono f] : function.injective ‚áëf
{M : Type u_1} [group M] (c : con M) : has_div c.quotient
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A ‚ü∂ B) (g : B ‚ü∂ C) [category_theory.limits.has_kernels V] [category_theory.limits.has_images V] (w : f ‚â´ g = 0) : category_theory.limits.image f ‚ü∂ category_theory.limits.kernel g
{L : first_order.language} {M : Type w} [L.Structure M] (S : L.substructure M) : ‚áë(first_order.language.substructure.closure L) ‚ÜëS = S
{J : Type u} [category_theory.small_category J] [category_theory.is_cofiltered J] {F : J ‚•§ Profinite} (C : category_theory.limits.cone F) (hC : category_theory.limits.is_limit C) {U : set ‚Ü•(C.X)} (hU : is_clopen U) : ‚àÉ (j : J) (V : set ‚Ü•(F.obj j)) (hV : is_clopen V), U = ‚áë(C.œÄ.app j) ‚Åª¬π' V
{R : Type u_1} [monoid R] [star_semigroup R] : ‚Ü•(unitary R) ‚Üí* RÀ£
{R : Type u} {Œπ : Type v} [comm_ring R] {L : Œπ ‚Üí Type w} [Œ† (i : Œπ), lie_ring (L i)] [Œ† (i : Œπ), lie_algebra R (L i)] [decidable_eq Œπ] (L' : Type w‚ÇÅ) [lie_ring L'] [lie_algebra R L'] (f : Œ† (i : Œπ), L i ‚Üí‚Çó‚ÅÖR‚ÅÜ L') (hf : ‚àÄ (i j : Œπ), i ‚â† j ‚Üí ‚àÄ (x : L i) (y : L j), ‚ÅÖ‚áë(f i) x,‚áë(f j) y‚ÅÜ = 0) : direct_sum Œπ (Œª (i : Œπ), L i) ‚Üí‚Çó‚ÅÖR‚ÅÜ L'
{M : Type u_2} [add_comm_group M] {A : Type u_1} [comm_ring A] [module A M] (f : M ‚âÉ‚Çó[A] M) : is_unit (‚áëlinear_map.det ‚Üëf)
(L : first_order.language) (M : Type u_3) [L.Structure M] : Prop
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : has_norm (M ‚ß∏ S)
(F : Type u_1) (R : Type u_2) (Œì‚ÇÄ : Type u_3) [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] [ring R] : Type (max u_1 u_2 u_3)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s -·µ• s ‚äÜ ‚Üë(vector_span k s)
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f : M ‚Üí+ N) (hf : ‚àÄ (x y : M), add_commute (‚áëf x) (‚áëf y)) : M ‚Üí+ N·µÉ·µí·µñ
{M : Type u_1} {R : Type u_4} [non_unital_non_assoc_semiring R] [set_like M R] [mul_mem_class M R] {S : M} {a b : R} (ha : a ‚àà add_submonoid.closure ‚ÜëS) (hb : b ‚àà add_submonoid.closure ‚ÜëS) : a * b ‚àà add_submonoid.closure ‚ÜëS
{Œ± : Type u_1} [decidable_eq Œ±] {ùíú : finset (finset Œ±)} {s : finset Œ±} : s ‚àà ùíú.shadow ‚Üî ‚àÉ (t : finset Œ±) (H : t ‚àà ùíú), s ‚äÜ t ‚àß t.card = s.card + 1
{R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] [nontrivial R] [normalization_monoid R] [decidable_eq R] [dec_dvd : decidable_rel has_dvd.dvd] {a b : R} (ha : irreducible a) (hb : b ‚â† 0) : multiplicity a b = ‚Üë(multiset.count (‚áënormalize a) (unique_factorization_monoid.normalized_factors b))
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] {ps : set P} (hps : ps ‚äÜ ‚Üës) (p : P) : (‚àÉ (r : ‚Ñù), ‚àÄ (p1 : P), p1 ‚àà ps ‚Üí has_dist.dist p1 p = r) ‚Üî ‚àÉ (r : ‚Ñù), ‚àÄ (p1 : P), p1 ‚àà ps ‚Üí has_dist.dist p1 ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p) = r
{X : Type u} {G : Type u_2} [group G] [mul_action G X] {H : Type u_3} [group H] (F : G ‚Üí* (X ‚Üí H) ‚ãä[mul_aut_arrow] G) (sane : ‚àÄ (g : G), (‚áëF g).right = g) : category_theory.action_category G X ‚•§ category_theory.single_obj H
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [is_R_or_C ùïÇ] [normed_comm_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] {Œπ : Type u_3} (s : finset Œπ) (f : Œπ ‚Üí ùî∏) : exp ùïÇ (s.sum (Œª (i : Œπ), f i)) = s.prod (Œª (i : Œπ), exp ùïÇ (f i))
{Œ± : Type u} [pseudo_emetric_space Œ±] {x : Œ±} {s t : set Œ±} : emetric.inf_edist x (s ‚à™ t) = emetric.inf_edist x s ‚äì emetric.inf_edist x t
{et : tactic.ring_exp.ex_type} (ps : tactic.ring_exp.ex et) : option expr ‚Üí option expr ‚Üí tactic.ring_exp.ex et
{n : ‚Ñï} (i : fin2 n) : mvpfunctor n
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : A ‚Üí‚Çó[A] polynomial R ‚Üí‚Çó[R] polynomial A
 : level ‚Üí level
(R : Type u_1) [rack R] : shelf_hom R (quandle.conj (R ‚âÉ R))
{G : Type u_1} [group G] (H : subgroup G) : subgroup G
(Œ± : Type u_2) [has_top Œ±] : top_hom Œ± Œ±
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] : algebraic_geometry.projective_spectrum.structure_sheaf.structure_presheaf_in_CommRing ùíú ‚ãô category_theory.forget CommRing ‚âÖ (algebraic_geometry.projective_spectrum.structure_sheaf.structure_sheaf_in_Type ùíú).val
 : free_ring punit ‚âÉ+* polynomial ‚Ñ§
{R : Type u} {S : Type v} [comm_ring R] [local_ring R] [comm_ring S] [local_ring S] (f : R ‚Üí+* S) [is_local_ring_hom f] : local_ring.residue_field R ‚Üí+* local_ring.residue_field S
(x : ‚Ñù) (h : real.cos x ‚â† 0) : deriv (Œª (y : ‚Ñù), real.tan y - y) x = 1 / real.cos x ^ 2 - 1
{Œ± : Type u_1} : regular_expression Œ± ‚Üí bool
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_coe Œ± Œ≤] : has_coe (generalized_continued_fraction Œ±) (generalized_continued_fraction Œ≤)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {s : set E} {t : set F} {g : F ‚Üí G} {f : E ‚Üí F} (hg : cont_diff_on ùïú n g t) (hf : cont_diff_on ùïú n f s) (st : s ‚äÜ f ‚Åª¬π' t) : cont_diff_on ùïú n (g ‚àò f) s
{n : ‚Ñï} (P : mvpfunctor (n + 1)) : P.last.W ‚Üí fin2 n ‚Üí Type u
 : Type
(R : Type u_1) [comm_ring R] [is_domain R] [char_zero R] : char_zero (fraction_ring R)
(d : declaration) : list level
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] (F : category_theory.lax_monoidal_functor C D) : category_theory.monoidal_nat_trans F F
{m : Type u_2} {n : Type u_3} {Œ± : Type v} [add_monoid Œ±] [star_add_monoid Œ±] : matrix m n Œ± ‚âÉ+ matrix n m Œ±
{Œπ : Type u_1} {Œπ' : Type u_2} {R : Type u_5} {M : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] [fintype Œπ'] [fintype Œπ] [decidable_eq Œπ] [decidable_eq Œπ'] (b : basis Œπ R M) (v : Œπ' ‚Üí M) (e : Œπ ‚âÉ Œπ') : (b.reindex e).to_matrix v = ‚áë(matrix.reindex_alg_equiv R e) (b.to_matrix (v ‚àò ‚áëe))
{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R √ó R
{X : Type u_2} [emetric_space X] (s : finset X) : dimH ‚Üës = 0
(R : Type u_1) [has_one R] [has_neg R] : Type u_1
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (G : D ‚•§ C) {F : C ‚•§ D} (h : F ‚ä£ G) (A : D) : category_theory.limits.is_terminal (category_theory.costructured_arrow.mk (h.counit.app A))
{Œ± : Type u} {f g : Œ± ‚Üí Œ±} {x : Œ±} (hf : function.is_fixed_pt f x) (h : function.left_inverse g f) : function.is_fixed_pt g x
{Œ± : Type u} [topological_space Œ±] [add_group Œ±] [topological_add_group Œ±] : topological_add_group Œ±·µÉ·µí·µñ
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [gcd_monoid R] (a b : R) : ‚àÉ (x y : R), gcd_monoid.gcd a b = a * x + b * y
(R : Type u_1) [comm_ring R] (Œπ : Type u_2) [fintype Œπ] : algebra.finite_presentation R (mv_polynomial Œπ R)
{Œ± : Type u_1} (a : Œ±) : measure_theory.outer_measure Œ±
{n : ‚Ñï} {Œ± : Type u_1} [preorder Œ±] {f : fin (n + 1) ‚Üí Œ±} : strict_anti f ‚Üî ‚àÄ (i : fin n), f i.succ < f (‚áëfin.cast_succ i)
 : bool ‚Üí bool ‚Üí bool
 : native.float ‚Üí native.float
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (œÅ : representation k G V) : G ‚Üí* (V ‚Üí‚Çó[k] V)À£
{R : Type u} [has_zero R] [has_pow R ‚Ñï] (x : R) : Prop
{Œ± : Type u_1} [linear_order Œ±] (a b : Œ±) (h : a ‚â§ b) (x : Œ±) : ‚Ü•(set.Icc a b)
{Œ± : Type u_1} [encodable Œ±] (n : ‚Ñï) : option (multiset Œ±)
{Œ± : Type u} [topological_space Œ±] [fintype Œ±] : compact_space Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {b‚ÇÇ : basis (fin 2) ‚Ñù V} (hb‚ÇÇ : orthonormal ‚Ñù ‚áëb‚ÇÇ) (ho : b.orientation = -b‚ÇÇ.orientation) (x y : V) : hb.oangle x y = -hb‚ÇÇ.oangle x y
 : ordinal ‚Ü™o surreal
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] {J : Type v} [fintype J] [category_theory.limits.preserves_biproducts_of_shape J F] : category_theory.limits.preserves_limits_of_shape (category_theory.discrete J) F
{Œ± : Type u} [linear_ordered_semiring Œ±] {Œ≤ : Type u_1} [has_zero Œ≤] [has_one Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_scalar ‚Ñï Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : linear_ordered_semiring Œ≤
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : setoid Œ±} (h : ‚àÄ (x y : Œ±), r x y ‚Üí s.rel x y) : eqv_gen.setoid r ‚â§ s
{Œì : Type u_1} {R : Type u_2} [ordered_cancel_add_comm_monoid Œì] [non_assoc_semiring R] : R ‚Üí+* hahn_series Œì R
{L : first_order.language} {Œ± : Type u'} : computability.encoding (Œ£ (n : ‚Ñï), L.bounded_formula Œ± n)
{G : Type u_1} [add_group G] (K : add_subgroup G) (s : set G) (hs : s = ‚ÜëK) : add_subgroup G
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] [complete_space F] {f : E ‚Üí F} {p : formal_multilinear_series ùïú E F} {x y : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) (h : y ‚àà emetric.ball x r) : analytic_at ùïú f y
{Œ± : Type u_1} [fintype Œ±] (p : Œ± ‚Üí Prop) [decidable_pred p] (hp : ‚àÉ! (a : Œ±), p a) : {a // p a}
{R : Type u_1} [comm_semiring R] {M : submonoid R} (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] (x : R) (y : ‚Ü•M) : S
{R : Type u_2} [comm_ring R] [is_domain R] {p : R} [decidable_rel has_dvd.dvd] (hp : prime p) : add_valuation R enat
(_x : interactive.parse (lean.parser.tk "#sample")) : lean.parser unit
{n : ‚Ñï} : fin2 n ‚Üí ‚Ñï
(Œ± : Sort u_1) : (false ‚Üí Œ±) ‚âÉ punit
{Œ± : Type u_1} {Œ≤ : Type u_2} : has_set_prod (set Œ±) (set Œ≤) (set (Œ± √ó Œ≤))
(F : Type u_1) (K : Type u_2) [field F] [ring K] [is_domain K] [algebra F K] [finite_dimensional F K] : division_ring K
{C : Type u} [category_theory.category C] {F : category_theory.limits.walking_cospan ‚•§ C} (t : category_theory.limits.cone F) : (category_theory.limits.cones.postcompose (category_theory.limits.diagram_iso_cospan F).hom).obj t ‚âÖ category_theory.limits.pullback_cone.mk (t.œÄ.app category_theory.limits.walking_cospan.left) (t.œÄ.app category_theory.limits.walking_cospan.right) _
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] : uniform_space.core (Œ± ‚äï Œ≤)
{Œ± : Type u} [group Œ±] : free_group Œ± ‚Üí* Œ±
{x : pgame} : x.lf 0 ‚Üî ‚àÉ (j : x.right_moves), ‚àÄ (i : (x.move_right j).left_moves), ((x.move_right j).move_left i).lf 0
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) {r : ‚Ñù} (hr : r < 0) : o.oangle (r ‚Ä¢ x) y = o.oangle (-x) y
{Œπ : Type u_1} {ùïú : Type u_2} [is_R_or_C ùïú] {E : Type u_3} [inner_product_space ùïú E] [cplt : complete_space E] {G : Œπ ‚Üí Type u_4} [Œ† (i : Œπ), inner_product_space ùïú (G i)] {V : Œ† (i : Œπ), G i ‚Üí‚Çó·µ¢[ùïú] E} (hV : orthogonal_family ùïú V) [‚àÄ (i : Œπ), complete_space (G i)] : hV.linear_isometry.to_linear_map.range = (‚®Ü (i : Œπ), (V i).to_linear_map.range).topological_closure
(Œ± : Type u) [topological_space Œ±] : Type u
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) (s : set A) (hs : s = ‚ÜëS) : subalgebra R A
{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A) : subring A
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (Œ∏ : real.angle) : ‚áëlinear_equiv.det (o.rotation Œ∏).to_linear_equiv = 1
{V : Type u} {G : simple_graph V} (G' : G.subgraph) (v : V) (h : v ‚àà G'.verts) : ‚Ü•(G'.verts)
{Œ± : Type u_1} {Œ≤ : Type u_2} [encodable Œ±] [encodable Œ≤] : encodable (Œ± √ó Œ≤)
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± ‚Ñ±' : category_theory.SheafOfTypes K} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) : ‚Ñ±.val ‚âÖ ‚Ñ±'.val
 : linarith.ineq ‚Üí string
{Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {q : Œ† (x : Œ±), p x ‚Üí Prop} : (‚àÄ (x : Œ±) (h : p x), q x h) ‚Üî ‚àÄ (x : {a // p a}), q ‚Üëx _
{G : Type u} [monoid G] : is_of_fin_order 1
{R : Type u} [ring R] {J : Type w} [category_theory.category J] (F : J ‚•§ Module R) (j : J) : F.obj j ‚ü∂ Module.colimits.colimit F
{n : ‚Ñ§} (hn : n ‚â† -1) (c w : ‚ÑÇ) (R : ‚Ñù) : ‚àÆ (z : ‚ÑÇ) in C(c, R), (z - w) ^ n = 0
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_assoc_semiring Œ±} {rŒ≤ : non_assoc_semiring Œ≤} (f : Œ± ‚Üí+* Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : Œ± ‚Üí+* Œ≤
{M : Type u_1} [linear_ordered_comm_monoid M] {A : Type u_2} [set_like A M] [submonoid_class A M] (S : A) : linear_ordered_comm_monoid ‚Ü•S
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R ‚Üí+* S) : Prop
{M : Type u_3} {N : Type u_4} [has_mul M] [has_mul N] {f g : M ‚Üí‚Çô* N} : f = g ‚Üî ‚àÄ (x : M), ‚áëf x = ‚áëg x
{Œ± : Type u} (s : set (set Œ±)) : cardinal.mk ‚Ü•{t : set Œ± | measurable_set t} ‚â§ linear_order.max (cardinal.mk ‚Ü•s) 2 ^ cardinal.aleph_0
{Œ± : Type u_2} [subtraction_monoid Œ±] : subtraction_monoid (filter Œ±)
{Œπ : Type u_1} {R : Type u_2} {M : Œπ ‚Üí Type u_4} [semiring R] [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] (i : Œπ) : (Œ†‚ÇÄ (i : Œπ), M i) ‚Üí‚Çó[R] M i
(f : cau_seq ‚ÑÇ complex.abs) : cau_seq ‚Ñù has_abs.abs
(Œ± : Type u_3) [topological_space Œ±] : Prop
(b : bool) : pos_num ‚Üí pos_num
{R‚ÇÅ : Type u_4} [comm_ring R‚ÇÅ] {n : Type w} [fintype n] [decidable_eq n] [invertible 2] (Q : quadratic_form R‚ÇÅ (n ‚Üí R‚ÇÅ)) : matrix n n R‚ÇÅ
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (f g : M ‚Üí* N) : submonoid M
{X : Top} {Œπ : Type v} {U : Œπ ‚Üí topological_space.opens ‚Ü•X} (V : Top.presheaf.sheaf_condition.opens_le_cover U) : Œπ
{Œ± : Type u_1} (i : Œ±) : poly Œ±
 : binder_info ‚Üí ‚Ñï
{F : Type u ‚Üí Type u} [functor F] (q : qpf F) : Prop
{Œ± : Type u_1} [monoid Œ±] {a b : Œ±} {u : Œ±À£} : a ‚à£ b * ‚Üëu ‚Üî a ‚à£ b
 : (user_attribute unit)
 : orthonormal ‚ÑÇ (fourier_Lp 2)
(S : Type u_4) (M : out_param (Type u_5)) [mul_one_class M] [set_like S M] : Type
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : Œ± ‚Üí Œ≤ ‚Üí Prop) : option Œ± ‚Üí option Œ≤ ‚Üí Prop
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] {A B : matrix n n Œ±} (h : B.mul A = 1) : A‚Åª¬π = B
{G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] [t2_space G] (K‚ÇÄ : topological_space.positive_compacts G) : measure_theory.content G
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : algebraic_geometry.SheafedSpace C} {Y : algebraic_geometry.SheafedSpace C} (f : X ‚ü∂ Y) : Prop
{M‚ÇÄ : Type u_1} [mul_zero_class M‚ÇÄ] : has_mul.mul 0 = function.const M‚ÇÄ 0
(Œπ : Type u‚ÇÅ) (k : Type u‚ÇÇ) {V : Type u‚ÇÉ} (P : Type u‚ÇÑ) [add_comm_group V] [add_torsor V P] [ring k] [module k V] : Type (max u‚ÇÅ u‚ÇÑ)
{C : Type u} [category_theory.category C] [category_theory.enough_projectives C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] : category_theory.projective.syzygies f ‚ü∂ X
{R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] {v : M} (hv : v ‚â† 0) {r : R} (hr : r ‚â† 0) : same_ray R v (r ‚Ä¢ v) ‚Üî 0 < r
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {f : E √ó F ‚Üí G} (h : is_bounded_bilinear_map ùïú f) : is_bounded_linear_map ùïú (Œª (p : E √ó F), h.deriv p)
{R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] [no_zero_divisors R] {B : M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R} (v : basis n R M) (hO : B.is_Ortho ‚áëv) (h : ‚àÄ (i : n), ¬¨B.is_ortho (‚áëv i) (‚áëv i)) : B.separating_right
{Œ± : Type u_1} [metric_space Œ±] {Œ≤ : Type u} [nonempty Œ≤] (p : besicovitch.tau_package Œ≤ Œ±) : ordinal ‚Üí Œ≤
{G : Type u_2} [div_inv_monoid G] : conj_act G ‚âÉ* G
{p x : ‚Ñù} {r : ‚Ñö} (hr : r ‚â† 0) : liouville_with p (‚Üër * x) ‚Üî liouville_with p x
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ≤] (f : Œ± ‚Üí Œ≤) (H : function.injective f) : fintype Œ±
{Œ± : Type u_1} (a : Œ±) (o : part Œ±) : Prop
(R : Type u_1) (M : Type u_2) (Œπ : Type u_3) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : M ‚âÉ‚Çó[R] Œπ ‚Üí‚ÇÄ R
 : environment ‚Üí name ‚Üí option (list name)
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [is_empty Œ±] : measure_theory.simple_func Œ± Œ≤
{Œ± : Type u_1} [has_sup Œ±] [has_inf Œ±] (sup_comm : ‚àÄ (a b : Œ±), a ‚äî b = b ‚äî a) (sup_assoc : ‚àÄ (a b c : Œ±), a ‚äî b ‚äî c = a ‚äî (b ‚äî c)) (sup_idem : ‚àÄ (a : Œ±), a ‚äî a = a) (inf_comm : ‚àÄ (a b : Œ±), a ‚äì b = b ‚äì a) (inf_assoc : ‚àÄ (a b c : Œ±), a ‚äì b ‚äì c = a ‚äì (b ‚äì c)) (inf_idem : ‚àÄ (a : Œ±), a ‚äì a = a) (sup_inf_self : ‚àÄ (a b : Œ±), a ‚äî a ‚äì b = a) (inf_sup_self : ‚àÄ (a b : Œ±), a ‚äì (a ‚äî b) = a) : semilattice_sup.to_partial_order Œ± = semilattice_inf.to_partial_order Œ±
(R : Type u_1) (A : Type u_2) [comm_semiring R] [non_unital_semiring A] [module R A] : A ‚Üí‚Çô‚Çê[R] unitization R A
{X Y : Top} (hequiv : continuous_map.homotopy_equiv ‚Ü•X ‚Ü•Y) : ‚Ü•(fundamental_groupoid.fundamental_groupoid_functor.obj X) ‚âå ‚Ü•(fundamental_groupoid.fundamental_groupoid_functor.obj Y)
{Œ± : Type u_1} {Œ≤ : Type u_2} : setoid (local_equiv Œ± Œ≤)
{Œ± : Type u_1} (f g : Œ± ‚Üí ‚Ñù) (s : set Œ±) : set (Œ± √ó ‚Ñù)
{Œ± : Type u} (s : set Œ±) : is_open {u : ultrafilter Œ± | s ‚àà u}
{C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} {f : X ‚ü∂ Y} (H : algebraic_geometry.PresheafedSpace.is_open_immersion f) : X ‚âÖ Y.restrict algebraic_geometry.PresheafedSpace.is_open_immersion.base_open
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} [comm_ring R] [lie_ring L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÅ] [lie_algebra R L‚ÇÇ] (L‚ÇÅ'' : lie_subalgebra R L‚ÇÅ) (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : ‚Ü•L‚ÇÅ'' ‚âÉ‚Çó‚ÅÖR‚ÅÜ ‚Ü•(lie_subalgebra.map ‚Üëe L‚ÇÅ'')
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_limits C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_limits D] (G : C ‚•§ D) [category_theory.limits.preserves_limits G] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : Top.presheaf.sheaf_condition_equalizer_products.diagram F U ‚ãô G ‚âÖ Top.presheaf.sheaf_condition_equalizer_products.diagram (F ‚ãô G) U
 : Type
 : ‚ä§_ Type u ‚âÖ punit
{L : first_order.language} {G' : ‚Ñï ‚Üí Type w} [Œ† (i : ‚Ñï), L.Structure (G' i)] (f' : Œ† (n : ‚Ñï), L.embedding (G' n) (G' (n + 1))) (m n : ‚Ñï) (h : m ‚â§ n) : L.embedding (G' m) (G' n)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {v : V} (p : P) {direction : submodule k V} (hv : v ‚àà direction) : v +·µ• p ‚àà affine_subspace.mk' p direction
{Œ± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : Œ± ‚Üí F} {f' : Œ± ‚Üí E'} {l : filter Œ±} : f' =o[l] g ‚Üí (Œª (x : Œ±), -f' x) =o[l] g
{Œ± : Type u} [ordered_semiring Œ±] [nontrivial Œ±] : 0 < 1
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} [category_theory.limits.has_images C] : category_theory.over X ‚•§ category_theory.mono_over X
{Œ± : Type u_1} {Œ≤ : Type u_2} [group Œ±] [division_monoid Œ≤] (f : Œ± ‚Üí* Œ≤) (g h : Œ±) : ‚áëf (g * h‚Åª¬π) = ‚áëf g * (‚áëf h)‚Åª¬π
{Œ± : Type u_1} {m : measurable_space Œ±} {R : Type u_3} [semiring R] [module R ‚Ñù] [has_continuous_const_smul R ‚Ñù] [has_continuous_const_smul R ‚ÑÇ] : measure_theory.complex_measure Œ± ‚âÉ‚Çó[R] measure_theory.signed_measure Œ± √ó measure_theory.signed_measure Œ±
 : ‚Ñï ‚Üí ‚Ñï
(b : ‚Ñï) (h : 2 ‚â§ b) : ‚Ñï ‚Üí list ‚Ñï
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [semiring k] [has_mul G] : has_mul (monoid_algebra k G)
(Œ± : Type u_2) : Type u_2
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (b : category_theory.limits.bicone (category_theory.limits.pair_function X Y)) : category_theory.limits.is_colimit b.to_binary_bicone.to_cocone ‚âÉ category_theory.limits.is_colimit b.to_cocone
{M : Type u_1} [mul_one_class M] {s : set M} : s ‚äÜ ‚Üë(submonoid.closure s)
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] : C ‚•§ C ‚•§ C
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X Y : C) : category_theory.is_iso 0 ‚âÉ (X ‚âÖ 0) √ó (Y ‚âÖ 0)
 : lean.parser tactic.rcases_patt
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {s : set ùïú} {n : with_top ‚Ñï} (h : ‚àÄ (m : ‚Ñï), ‚Üëm ‚â§ n ‚Üí differentiable_on ùïú (iterated_deriv_within m f s) s) : cont_diff_on ùïú n f s
{Œ± : Type u_1} {Œ≤ : Type u_2} {f g : Œ± ‚Üí Œ≤} {m : measurable_space Œ±} {mŒ≤ : measurable_space Œ≤} [measurable_singleton_class Œ±] (hf : measurable f) (h : {x : Œ± | f x ‚â† g x}.countable) : measurable g
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (E : Type u_2) [normed_group E] [normed_space ùïú E] : model_with_corners ùïú E E
{M : Type u_2} [add_comm_group M] {Œπ : Type u_4} [decidable_eq Œπ] [fintype Œπ] {A : Type u_5} [comm_ring A] [module A M] : trunc (basis Œπ A M) ‚Üí (M ‚Üí‚Çó[A] M) ‚Üí* A
{Œ± : Type u} {Œ≤ : Type v} [has_mul Œ±] [has_mul Œ≤] {Œ≥ : Type u_1} [has_mul Œ≥] {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hf : is_mul_hom f) (hg : is_mul_hom g) : is_mul_hom (g ‚àò f)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) [category_theory.full R] [category_theory.faithful R] : category_theory.is_iso h.counit
{Œπ : Type u_1} (M : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), monoid (M i)] : Type (max u_1 u_2)
 : expr ‚Üí ‚Ñï ‚Üí list name ‚Üí list ‚Ñï ‚Üí list name √ó list ‚Ñï √ó expr
(M : Type u_5) (N : Type u_6) [add_zero_class M] [add_zero_class N] : M √ó N ‚Üí+ M
{C : Type u} [category_theory.category C] {X Y Z : C} (g : Y ‚ü∂ Z) [category_theory.limits.has_equalizers C] (f : X ‚ü∂ Y) [category_theory.is_iso f] [category_theory.limits.has_image g] : category_theory.is_iso (category_theory.limits.image.pre_comp f g)
{n : ‚Ñï} {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (b : Œ≤) (v : vector Œ± n) : vector Œ≤ (n + 1)
{X : algebraic_geometry.PresheafedSpace CommRing} (Y : algebraic_geometry.Scheme) (f : X ‚ü∂ Y.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace) [H : algebraic_geometry.PresheafedSpace.is_open_immersion f] : algebraic_geometry.Scheme
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.is_iso (category_theory.limits.equalizer.Œπ f f)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {X Y : C} [category_theory.has_right_dual X] [category_theory.has_right_dual Y] (f : X ‚ü∂ Y) : Y·òÅ ‚ü∂ X·òÅ
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] {F G : category_theory.oplax_functor B C} (Œ∑ : F ‚ü∂ G) : category_theory.oplax_nat_trans.modification Œ∑ Œ∑
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_lt Œ±] [has_lt Œ≤] : has_lt (Œ± ‚äï‚Çó Œ≤)
{Œ± : Type u} {Œ≤ : Type v} [mul_one_class Œ±] [mul_one_class Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_monoid_hom f) {Œ≥ : Type u_1} [mul_one_class Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : is_monoid_hom g) : is_monoid_hom (g ‚àò f)
{M : Type u_1} [has_add M] {s : set M} {S : add_subsemigroup M} : add_subsemigroup.closure s ‚â§ S ‚Üî s ‚äÜ ‚ÜëS
{M : Type u_1} [mul_one_class M] {N : Type u_2} [mul_one_class N] (f : M ‚Üí* N) (hf : function.surjective ‚áëf) : f.mrange = ‚ä§
(m : Type u) (n : Type u') [fintype m] [fintype n] (Œ± : m ‚Üí n ‚Üí Type v) : Type (max u u' v)
{A : Type u} [category_theory.category A] [category_theory.abelian A] {X Y Z : A} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (w : f ‚â´ g = 0) : category_theory.limits.kernel g ‚ü∂ homology f g w
(ps_o : expr) (ps' : tactic.ring_exp.ex tactic.ring_exp.ex_type.sum) (pf : expr) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum)
(C : Type u) [ùíû : category_theory.category C] : Type (max u v)
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] {Œ± : ‚Ü•(solvable_by_rad F E)} {n : ‚Ñï} (hn : n ‚â† 0) (hŒ± : solvable_by_rad.P (Œ± ^ n)) : solvable_by_rad.P Œ±
 : option expr ‚Üí expr ‚Üí expr ‚Üí tactic unit
(R : Type u_1) (B : Type u_3) (F : Type u_4) [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] (Œπ : Type u_6) : Type (max u_3 u_4 u_6)
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] : ‚Ñö_[p] ‚Üí with_top ‚Ñ§
{n m : ‚Ñï} (h : n ‚â§ m) : fin n ‚Ü™o fin m
(ntac : name) (ty : expr) : tactic unit
{R : Type u} [comm_ring R] : Algebra R ‚•§ Mon_ (Module R)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : affine_subspace k P
{ùïú : Type u} {Œπ : Type v} {E : Œπ ‚Üí Type wE} {E‚ÇÅ : Œπ ‚Üí Type wE‚ÇÅ} {G : Type wG} [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] [Œ† (i : Œπ), normed_group (E‚ÇÅ i)] [Œ† (i : Œπ), normed_space ùïú (E‚ÇÅ i)] [normed_group G] [normed_space ùïú G] (f : Œ† (i : Œπ), E i ‚ÜíL[ùïú] E‚ÇÅ i) : continuous_multilinear_map ùïú E‚ÇÅ G ‚ÜíL[ùïú] continuous_multilinear_map ùïú E G
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] {f d : ‚Ñï ‚Üí Œ±} (hdisj : pairwise (disjoint on d)) (hsups : partial_sups d = partial_sups f) : d = disjointed f
 : (user_attribute simp_lemmas)
{Œπ : Type u} (Œ≤ : Œπ ‚Üí Type v) [Œ† (i : Œπ), add_zero_class (Œ≤ i)] (p : Œπ ‚Üí Prop) [decidable_pred p] : (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚Üí+ Œ†‚ÇÄ (i : subtype p), Œ≤ ‚Üëi
(Œ± : Type u_1) [cancel_comm_monoid_with_zero Œ±] [unique_factorization_monoid Œ±] [normalization_monoid Œ±] [decidable_eq (associates Œ±)] [decidable_eq Œ±] : normalized_gcd_monoid Œ±
{X : Type u_1} {m : Type u_4} {n : Type u_5} {p : Type u_6} {R : Type u_8} [topological_space X] [topological_space R] [fintype n] [has_mul R] [add_comm_monoid R] [has_continuous_add R] [has_continuous_mul R] {A : X ‚Üí matrix m n R} {B : X ‚Üí matrix n p R} (hA : continuous A) (hB : continuous B) : continuous (Œª (x : X), (A x).mul (B x))
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (c : category_theory.limits.cocone F) : category_theory.limits.is_colimit c ‚âÉ category_theory.limits.is_initial c
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {v : picard_lindelof E} [complete_space E] (f : v.fun_space) : v.fun_space
{Œ± : Type u_2} [decidable_eq Œ±] [add_semigroup Œ±] : add_semigroup (finset Œ±)
 : finset.nat.antidiagonal 0 = {(0, 0)}
 : Type
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [non_assoc_semiring Œ≤] [non_assoc_semiring Œ≥] (g : Œ≤ ‚Üí+* Œ≥) (f : Œ± ‚Üí Œ≤) (s : finset Œ±) : ‚áëg (s.sum (Œª (x : Œ±), f x)) = s.sum (Œª (x : Œ±), ‚áëg (f x))
{Œ± : Type u} {Œ≤ : Type v} (f' : Œ≤ ‚Üí Œ±) (f : Œ± ‚Üí Œ≤) (t : set Œ≤) : Prop
(a : ‚Ñï) : linarith.linarith_monad unit
 : Type (u+1)
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) : o.rotation 0 = linear_isometry_equiv.refl ‚Ñù V
{Œ± : Type u_1} [decidable_eq Œ±] (s : cycle Œ±) (hs : s.nodup) (x : Œ±) (hx : x ‚àà s) : Œ±
(n : Type u_3) (Œ± : Type v) [decidable_eq n] [add_zero_class Œ±] : (n ‚Üí Œ±) ‚Üí+ matrix n n Œ±
{Œ± : Type u_3} [semilattice_inf Œ±] (a : Œ±) : filter.at_bot = filter.comap coe filter.at_bot
{Œ± : Type u} {L : list (Œ± √ó bool)} : free_group.red list.nil L ‚Üî L = list.nil
{R : Type v} [semiring R] {R' : Type u_1} [ring R'] [mul_semiring_action R' R] (H : subring R') : mul_semiring_action ‚Ü•H R
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X : C) : Prop
{Œ± : Type u} {Œ≤ : Type v} [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] (x : Œ≤) : Œ± ‚ÜíùíÑ Œ≤
(tm : turing.fin_tm2) (l : list (tm.Œì tm.k‚ÇÄ)) (l' : option (list (tm.Œì tm.k‚ÇÅ))) (m : ‚Ñï) : Type
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : 0 ‚àà S
 : lie_group (model_with_corners_self ‚Ñù (euclidean_space ‚Ñù (fin 1))) ‚Ü•circle
{Œ± : Type u} [preorder Œ±] (s : set Œ±) : Œ± ‚Üí Prop
(R : Type u_1) [comm_ring R] (n ŒΩ : ‚Ñï) : polynomial R
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D·µí·µñ} (Œ± : F.left_op ‚ü∂ G.left_op) : G ‚ü∂ F
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] {D : J ‚•§ T.algebra} (c : category_theory.limits.cocone (D ‚ãô T.forget)) (t : category_theory.limits.is_colimit c) [category_theory.limits.preserves_colimit (D ‚ãô T.forget) ‚ÜëT] [category_theory.limits.preserves_colimit ((D ‚ãô T.forget) ‚ãô ‚ÜëT) ‚ÜëT] : category_theory.limits.is_colimit (category_theory.monad.forget_creates_colimits.lifted_cocone c t)
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (c : con M) (f : N ‚Üí* M) : (con.comap ‚áëf _ c).quotient ‚âÉ* ‚Ü•((c.mk'.comp f).mrange)
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÇ] [has_zero M‚ÇÇ] [has_scalar ‚Ñï M‚ÇÇ] [add_comm_monoid M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : add_comm_monoid M‚ÇÇ
{Œ± : Type u} [complete_lattice Œ±] {J : Type u} [category_theory.small_category J] (F : J ‚•§ Œ±) : category_theory.limits.limit F = infi F.obj
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [has_zero M‚ÇÅ] [has_scalar ‚Ñï M‚ÇÅ] [add_right_cancel_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : add_right_cancel_monoid M‚ÇÅ
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {Œπ : Type u_1} (c : complex_shape Œπ) {Œπ' : Type u_2} (c' : complex_shape Œπ') : homological_complex (homological_complex V c) c' ‚âå homological_complex (homological_complex V c') c
{Œ± : Type u_1} : list Œ± ‚Üí list Œ± ‚Üí list (list Œ±)
{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] (f : zero_hom M N) {x y : M} (h : x = y) : ‚áëf x = ‚áëf y
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a : Œ±} : 1 ‚â§ a‚Åª¬π ‚Üî a ‚â§ 1
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {Œ± : Type u_3} [monoid Œ±] [distrib_mul_action Œ± R] [smul_comm_class Œ± R R] : has_scalar Œ± (bilin_form R M)
{V : Type (u+1)} [category_theory.large_category V] {G : Mon} {M N : Action V G} (f : M.V ‚âÖ N.V) (comm : ‚àÄ (g : ‚Ü•G), ‚áë(M.œÅ) g ‚â´ f.hom = f.hom ‚â´ ‚áë(N.œÅ) g) : M ‚âÖ N
(x : simplex_category) : set (‚Ü•x ‚Üí nnreal)
 : Type
{X : Type u_1} {Y : Type u_2} (R : Type u_3) [topological_space X] [topological_space Y] [normed_comm_ring R] (f : C(X, Y)) : C(Y, R) ‚Üí‚Çê[R] C(X, R)
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] {ùíú : ‚Ñï ‚Üí submodule R A} [graded_algebra ùíú] {f : A} {m : ‚Ñï} (f_deg : f ‚àà ùíú m) (x : ‚Ü•(algebraic_geometry.degree_zero_part f_deg)) : ‚Ñï
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K
{C : Type u‚ÇÅ} [category_theory.small_category C] {‚Ñ∞ : Type u‚ÇÇ} [category_theory.category ‚Ñ∞] (A : C ‚•§ ‚Ñ∞) [category_theory.limits.has_colimits ‚Ñ∞] (X : C·µí·µñ ‚•§ Type u‚ÇÅ) : (category_theory.colimit_adj.extend_along_yoneda A).obj X ‚âÖ ((category_theory.Lan category_theory.yoneda).obj A).obj X
{Œ± : Type u_1} (l‚ÇÅ l‚ÇÇ : list Œ±) : Prop
{M : Type u_3} {S : Type u_4} [sub_neg_monoid M] [set_like S M] [hSM : add_subgroup_class S M] {H : S} {x y : M} (hx : x ‚àà H) (hy : y ‚àà H) : x - y ‚àà H
{Œπ : Type u_1} : box_integral.box Œπ ‚Ü™o set (Œπ ‚Üí ‚Ñù)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) [category_theory.limits.has_limit F] : category_theory.limits.limit_cone F
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (h : is_bounded_linear_map ùïú f) : E ‚Üí‚Çó[ùïú] F
{Œ± : Type u_1} [measurable_space Œ±] {f g : Œ± ‚Üí ‚Ñù} {s : set Œ±} (hf : measurable f) (hg : measurable g) (hs : measurable_set s) : measurable_set (region_between f g s)
(ps : tactic.ring_exp.ex_info) : tactic.ring_exp.ring_exp_m expr
{Œπ : Type u_1} {Œπ‚ÇÇ : Type u_2} [decidable_eq Œπ] [decidable_eq Œπ‚ÇÇ] (R : Type u_4) [comm_semiring R] (M : Type u_8) [add_comm_monoid M] [module R M] (e : Œπ ‚âÉ Œπ‚ÇÇ) : pi_tensor_product R (Œª (i : Œπ), M) ‚âÉ‚Çó[R] pi_tensor_product R (Œª (i : Œπ‚ÇÇ), M)
 : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) {J : Type u} [category_theory.category J] {K : J ‚•§ C} (Y : D) (t : (G ‚ãô (category_theory.cocones J C).obj (opposite.op K)).obj Y) : ((category_theory.cocones J D).obj (opposite.op (K ‚ãô F))).obj Y
{G : Type u_3} [group G] (self : subgroup G) : submonoid G
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) (x : E) : Prop
{V : Type u} (G : simple_graph V) {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Ü™ Œ≤) : G.coloring Œ± ‚Ü™ G.coloring Œ≤
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a : Œ±} : -a < 0 ‚Üî 0 < a
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommSemiRing) : SemiRing
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : (Œ± ‚äï Œ≤) ‚äï Œ≥ ‚âÉ Œ± ‚äï Œ≤ ‚äï Œ≥
{n m : ‚Ñï} (h : n = m) : ‚áë(fin.cast h) = cast _
{Œ± : Type u} [topological_space Œ±] (s : set Œ±) : Prop
{m : Type u_2} {n : Type u_3} (R : Type u_11) [comm_ring R] [fintype m] [decidable_eq m] [fintype n] [decidable_eq n] (e : m ‚âÉ n) (A : matrix m m R) : (‚áë(matrix.reindex_alg_equiv R e) A).det = A.det
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [compact_space Œ±] [metric_space Œ≤] (x : Œ±) : continuous (Œª (f : C(Œ±, Œ≤)), ‚áëf x)
{Œ± : Sort u_1} {Œ≥ : Sort u_4} {r : Œ± ‚Üí Œ± ‚Üí Prop} (f : Œ± ‚Üí Œ≥) (h : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±), r a‚ÇÅ a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ) (a : Œ±) : quot.lift f h (quot.mk r a) = f a
{Œ± : Type u} [non_unital_non_assoc_ring Œ±] (k : Œ±) (h : ‚àÄ (x : Œ±), k * x = 0 ‚Üí x = 0) : is_left_regular k
{p : bool ‚Üí Prop} [Œ† (b : bool), decidable (p b)] : decidable (‚àÄ (b : bool), p b)
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} (f : Œ† (i : Œπ), filter (Œ± i)) : filter (Œ† (i : Œπ), Œ± i)
{Œ± : Type u_3} {Œ≤ : Type u_4} [group Œ±] (a : Œ±) [mul_action Œ± Œ≤] (b : Œ≤) : ‚Ü•(subgroup.zpowers a) ‚ß∏ mul_action.stabilizer ‚Ü•(subgroup.zpowers a) b ‚âÉ* multiplicative (zmod (function.minimal_period (has_scalar.smul a) b))
{Œ± : Type u} {Œ≤ : Type v} [group Œ±] [mul_action Œ± Œ≤] [has_faithful_smul Œ± Œ≤] : function.injective mul_action.to_perm
(R : Type u_1) {M : Type u_4} (S : Type u_7) [semiring R] [add_comm_monoid M] [module R M] (s : set M) [semiring S] [has_scalar R S] [module S M] [is_scalar_tower R S M] : ‚Üë(submodule.span R s) ‚äÜ ‚Üë(submodule.span S s)
 : ‚ÑÇ ‚âÉ·µê (fin 2 ‚Üí ‚Ñù)
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ‚Ü•X) (R : category_theory.presieve U) (hR : category_theory.sieve.generate R ‚àà ‚áë(opens.grothendieck_topology ‚Ü•X) U) : (category_theory.limits.cones.postcompose (Top.presheaf.covering_of_presieve.diagram_nat_iso F U R).hom).obj (category_theory.limits.fork.of_Œπ (category_theory.presheaf.fork_map R F) _) ‚ü∂ Top.presheaf.sheaf_condition_equalizer_products.fork F (Top.presheaf.covering_of_presieve U R)
{Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚Üí Œ≤} {l‚ÇÅ : filter Œ±} {l‚ÇÇ : filter Œ≤} : filter.tendsto f l‚ÇÅ l‚ÇÇ ‚Üí l‚ÇÅ ‚â§ filter.comap f l‚ÇÇ
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÅ) [category_theory.category D] : D ‚•§ C ‚äï D
{C : Type u} [category_theory.category C] (X : category_theory.simplicial_object.augmented C) : category_theory.cosimplicial_object.augmented C·µí·µñ
{a b : ‚Ñù} {f f' g : ‚Ñù ‚Üí ‚Ñù} (h : ‚àÄ (x : ‚Ñù), x ‚àà set.interval a b ‚Üí has_deriv_at f (f' x) x) (h' : continuous_on f' (set.interval a b)) (hg : continuous g) : ‚à´ (x : ‚Ñù) in a..b, (g ‚àò f) x * f' x = ‚à´ (x : ‚Ñù) in f a..f b, g x
(k : Type u_1) [division_ring k] {Œπ : Type u_4} (s : finset Œπ) [char_zero k] [fintype Œπ] (h : s.nonempty) : finset.univ.sum (Œª (i : Œπ), finset.centroid_weights_indicator k s i) = 1
{F : pfunctor} (x : Œ† (n : ‚Ñï), pfunctor.approx.cofix_a F n) : Prop
(n : simplex_category) : ‚Ñï
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (X Y : C) (F : C ‚•§ D) : category_theory.limits.pair X Y ‚ãô F ‚âÖ category_theory.limits.pair (F.obj X) (F.obj Y)
{M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : add_zero_class M} {mN : add_zero_class N} [add_monoid_hom_class F M N] (f : F) {x : M} (hx : ‚àÉ (y : M), y + x = 0) : ‚àÉ (y : N), y + ‚áëf x = 0
{n m : ‚Ñï} (eq : n = m) : fin n ‚âÉo fin m
{E : Type u_2} {ùïú : Type u_3} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] {s : set E} (hs : convex ùïú s) {a b : ùïú} (ha : 0 < a) (hb : 0 ‚â§ b) (hab : a + b = 1) : a ‚Ä¢ interior s + b ‚Ä¢ s ‚äÜ interior s
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] {J : Type v} [fintype J] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete J) F] : category_theory.limits.preserves_biproducts_of_shape J F
{Œ± : Type u_1} [preorder Œ±] {a b : Œ±} (h : a ‚â§ b) : ¬¨a ‚©ø b ‚Üî ‚àÉ (c : Œ±), a < c ‚àß c < b
 : expr ‚Üí tactic.ring2.csring_expr √ó dlist expr
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : galois_insertion (category_theory.pretopology.to_grothendieck C) (category_theory.pretopology.of_grothendieck C)
{G : Type u_1} [group G] {N : Type u_3} [group N] (f : G ‚Üí* N) {H K : subgroup G} (hH : f.ker ‚â§ H) (hK : f.ker ‚â§ K) (hf : subgroup.map f H = subgroup.map f K) : H = K
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a b c : Œ±} : a < b * c ‚Üí b‚Åª¬π * a < c
(K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] (x : V) : finite_dimensional K ‚Ü•(submodule.span K {x})
 : associates ‚Ñ§ ‚âÉ ‚Ñï
{n : ‚Ñï} {Œ± : typevec n} (p : Œ±.arrow (typevec.repeat n Prop)) : typevec n
{R : Type u_1} [comm_ring R] [is_domain R] [fintype RÀ£] : is_cyclic RÀ£
(K : Type u) [division_ring K] {Œπ : Type v} [fintype Œπ] : finite_dimensional.finrank K (Œπ ‚Üí K) = fintype.card Œπ
(p : omega.nat.preform) : Prop
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] (s : submodule K V) : finite_dimensional.finrank K ‚Ü•s ‚â§ finite_dimensional.finrank K V
{X : Top} (F : Top.presheaf (Type v) X) (x : ‚Ü•X) : F.sheafify.val.stalk x ‚ü∂ F.stalk x
 : Type
{Œ± : Type u} [pseudo_emetric_space Œ±] {x : Œ±} {s t : set Œ±} : emetric.inf_edist x t ‚â§ emetric.inf_edist x s + emetric.Hausdorff_edist s t
{p : ‚Ñï} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R) : ‚áëwitt_vector.frobenius (‚áëwitt_vector.verschiebung x) = x * ‚Üëp
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_5} [normed_group E'] [normed_space ùïú E'] {n : with_top ‚Ñï} {f : E ‚Üí E'} {s : set E} {x : E} : cont_diff_within_at ùïú n f s x ‚Üí cont_mdiff_within_at (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') n f s x
(a b : tactic.ring_exp.atom) : bool
{K : Type u_1} {v : K} {n : ‚Ñï} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ‚â§ ifp_n.fr
(attr_name : name) : tactic (list (tactic expr))
{G : Type u_1} [group G] (K : subgroup G) {l : list G} : (‚àÄ (x : G), x ‚àà l ‚Üí x ‚àà K) ‚Üí l.prod ‚àà K
{G : Type u_1} {A : Type u_2} {B : Type u_3} [group G] [mul_action G A] [monoid B] : mul_distrib_mul_action G (A ‚Üí B)
(Œ± : Type u) : Type u
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [densely_ordered Œ±] {Œ¥ : Type u_1} [linear_order Œ¥] [topological_space Œ¥] [order_closed_topology Œ¥] {f : Œ± ‚Üí Œ¥} {s : set Œ±} [s.ord_connected] (hs : s.nonempty) (hf : continuous_on f s) (hbot : filter.tendsto (Œª (x : ‚Ü•s), f ‚Üëx) filter.at_bot filter.at_top) (htop : filter.tendsto (Œª (x : ‚Ü•s), f ‚Üëx) filter.at_top filter.at_bot) : set.surj_on f s set.univ
(g : format) (n : ‚Ñï) (e : expr) : tactic unit
{T : Type u} [category_theory.category T] {f g : category_theory.arrow T} (l : f.left ‚âÖ g.left) (r : f.right ‚âÖ g.right) (h : l.hom ‚â´ g.hom = f.hom ‚â´ r.hom) : f ‚âÖ g
(L : Type u_1) (M : Type u_2) : Type (max u_1 u_2)
{G A : Type u} [group G] [is_free_group G] [mul_action G A] : is_free_groupoid (category_theory.action_category G A)
{a : ‚Ñï} : ‚Üë(nat.sqrt a) ‚â§ real.sqrt ‚Üëa
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (h : category_theory.presieve.is_sheaf_for P ‚áëS) (t‚ÇÅ t‚ÇÇ : category_theory.yoneda.obj X ‚ü∂ P) (ht : S.functor_inclusion ‚â´ t‚ÇÅ = S.functor_inclusion ‚â´ t‚ÇÇ) : t‚ÇÅ = t‚ÇÇ
{Œ± : Type u} [topological_space Œ±] {x : Œ±} : dense {x}·∂ú ‚Üî ¬¨is_open {x}
{G : Type u_7} [group G] (L : list G) : L.reverse.prod = ((list.map (Œª (x : G), x‚Åª¬π) L).prod)‚Åª¬π
{M : Type u_1} [has_mul M] {c d : con M} {x y : M} : ‚áë(c ‚äì d) x y ‚Üî ‚áëc x y ‚àß ‚áëd x y
{ùïú : Type u} {A : Type v} [field ùïú] [ring A] [algebra ùïú A] [nontrivial A] (k : ùïú) (a : A) (ha : (spectrum ùïú a).nonempty) : spectrum ùïú (k ‚Ä¢ a) = k ‚Ä¢ spectrum ùïú a
{f : ‚Ñï ‚Üí ‚Ñù} (hfa : monotone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) : cauchy_seq (Œª (n : ‚Ñï), (finset.range (n + 1)).sum (Œª (i : ‚Ñï), (-1) ^ i * f i))
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_group E] [has_scalar ùïú E] {S : convex_cone ùïú E} : S.blunt ‚Üí S.salient
{M : Type u_1} [has_mul M] (c : con M) : {d // c ‚â§ d} ‚âÉo con c.quotient
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] [category_theory.limits.has_finite_products C] [category_theory.limits.has_finite_products D] (F : C ‚•§ D) {L : D ‚•§ C} (h : L ‚ä£ F) (A : C) : category_theory.limits.prod.functor.obj (F.obj A) ‚ãô L ‚ü∂ L ‚ãô category_theory.limits.prod.functor.obj A
{C : Type u‚ÇÅ} [category_theory.category C] : C ‚•§ category_theory.as_small C
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {g : Œ≤ ‚Üí Œ±} (hg : set.inj_on g (function.support (f ‚àò g))) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà set.range g), f i)) = finsum (Œª (j : Œ≤), f (g j))
 : tactic.itauto.context ‚Üí tactic.itauto.prop ‚Üí ‚Ñï ‚Üí bool √ó tactic.itauto.proof √ó ‚Ñï
 : has_pure filter
 : name ‚Üí name
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {n : with_top ‚Ñï} (h : ‚àÄ (m : ‚Ñï), ‚Üëm ‚â§ n ‚Üí differentiable ùïú (iterated_deriv m f)) : cont_diff ùïú n f
{c : Type u ‚Üí Type v} (Œ± : Type u) [str : c Œ±] : category_theory.bundled c
(Œ± : Sort u_1) (Œ≤ : Sort u_2) [is_empty Œ±] : (Œ± ‚Üí Œ≤) ‚âÉ punit
{Œ± : Type u_1} [uniform_space Œ±] {Œ≤ : Type u_2} [uniform_space Œ≤] (f : Œ± ‚Üí Œ≤) : uniform_space.completion Œ± ‚Üí uniform_space.completion Œ≤
(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) : s.monge_point = (‚Üë(n + 1) / ‚Üë(n - 1)) ‚Ä¢ (finset.centroid ‚Ñù finset.univ s.points -·µ• s.circumcenter) +·µ• s.circumcenter
(R : Type u) [comm_ring R] [strong_rank_condition R] (M : Type v) (N : Type w) [add_comm_group M] [module R M] [module.free R M] [add_comm_group N] [module R N] [module.free R N] : finite_dimensional.finrank R (tensor_product R M N) = finite_dimensional.finrank R M * finite_dimensional.finrank R N
{G : Type u_1} [add_group G] {H : add_subgroup G} {A : Type u_2} [add_comm_group A] (œï : ‚Ü•H ‚Üí+ A) [fintype (G ‚ß∏ H)] : G ‚Üí+ A
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÅ) [category_theory.category D] : C ‚äï D ‚âå D ‚äï C
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] [category_theory.monoidal_closed C] : C·µí·µñ ‚•§ C ‚•§ C
{Œ± : Type} (gs : list expr) (tac : tactic Œ±) : tactic Œ±
{Œ± : Type u_1} : option Œ± ‚Üí part Œ±
(n a b : ‚Ñ§) : Prop
(n : ‚Ñï) : ‚Ñï ‚Üí bitvec n
(k : Type u_1) [comm_ring k] [is_reduced k] (p : ‚Ñï) [fact (nat.prime p)] [char_p k p] (h : function.surjective ‚áë(frobenius k p)) : perfect_ring k p
{R : Type u} [ring R] (p : polynomial R) {q : polynomial R} : q.monic ‚Üí polynomial R √ó polynomial R
{R : Type u} [comm_ring R] [is_domain R] {p : polynomial R} {a : R} {n : ‚Ñï} (hzero : p ‚â† 0) (h : (polynomial.X - ‚áëpolynomial.C a) ^ n ‚à£ p) : n ‚â§ polynomial.root_multiplicity a p
{Œπ : Type u_1} {Œ± : Type u_2} [fintype Œπ] [decidable_eq Œ±] (t : Œπ ‚Üí finset Œ±) : (‚àÄ (s : finset Œπ), s.card ‚â§ (s.bUnion t).card) ‚Üî ‚àÉ (f : Œπ ‚Üí Œ±), function.injective f ‚àß ‚àÄ (x : Œπ), f x ‚àà t x
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] (e e' : topological_fiber_bundle.trivialization F proj) (s : set B) (Hs : e.base_set ‚à© frontier s = e'.base_set ‚à© frontier s) (Heq : set.eq_on ‚áëe ‚áëe' (proj ‚Åª¬π' (e.base_set ‚à© frontier s))) : topological_fiber_bundle.trivialization F proj
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [add_monoid Œ≤] [has_continuous_add Œ≤] : C(Œ±, Œ≤) ‚Üí+ Œ± ‚Üí Œ≤
(R : Type u) (A : Type v) [comm_semiring R] [semiring A] : Type (max u v)
{Œ± : Type u_1} {Œ≤ : Type u_2} {e e' : local_equiv Œ± Œ≤} (h : e ‚âà e') : set.eq_on ‚áëe ‚áëe' e.source
(X Y : Type u) : category_theory.limits.colimit_cocone (category_theory.limits.pair X Y)
{Œ± : Type u} [emetric_space Œ±] {s : set Œ±} (hs : is_closed s) : is_closed {t : topological_space.closeds Œ± | ‚Üët ‚äÜ s}
{Œ± : Type u_1} {Œπ : Type u_2} {Œ≤ : Type u_3} (S : Œπ ‚Üí set Œ±) (f : Œ† (i : Œπ), ‚Ü•(S i) ‚Üí Œ≤) (hf : ‚àÄ (i j : Œπ) (x : Œ±) (hxi : x ‚àà S i) (hxj : x ‚àà S j), f i ‚ü®x, hxi‚ü© = f j ‚ü®x, hxj‚ü©) (T : set Œ±) (hT : T ‚äÜ set.Union S) (x : ‚Ü•T) : Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : continuous f) (x : Œ±) (y : Œ≤) (h : f x = y) : filter.tendsto f (nhds x) (nhds y)
{Œ± : Type u_1} {Œ¥ : Œ± ‚Üí Type u_2} [decidable_eq Œ±] (s : finset Œ±) (a : Œ±) (b : Œ¥ a) (f : Œ† (a : Œ±), a ‚àà s ‚Üí Œ¥ a) (a' : Œ±) (h : a' ‚àà has_insert.insert a s) : Œ¥ a'
(is_manual : bool) : tactic unit
{X : Type u_1} [topological_space X] {x y : X} (Œ≥ : path x y) (f : ‚Ü•unit_interval ‚Üí ‚Ü•unit_interval) (hfcont : continuous f) (hf‚ÇÄ : f 0 = 0) (hf‚ÇÅ : f 1 = 1) : path x y
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_terminal C] [category_theory.limits.has_terminal D] [i : category_theory.is_iso (category_theory.limits.terminal_comparison G)] : category_theory.limits.preserves_limit (category_theory.functor.empty C) G
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} [category_theory.limits.has_images C] : category_theory.mono_over.forget X ‚ãô category_theory.mono_over.image ‚âÖ ùü≠ (category_theory.mono_over X)
{R : Type u} {M : Type v} [ring R] {N : Type u_3} [add_comm_group M] [module R M] [add_comm_group N] [module R N] (f : M √ó N ‚Üí‚Çó[R] M) (i : function.injective ‚áëf) : ‚Ñï ‚Üío (submodule R M)·µí·µà
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {n : with_top ‚Ñï} (h : ‚àÄ (x : E), x ‚àà s ‚Üí (‚àÉ (u : set E), is_open u ‚àß x ‚àà u ‚àß cont_diff_on ùïú n f (s ‚à© u))) : cont_diff_on ùïú n f s
(G : Mon) : Action AddCommGroup G
{V : SemiNormedGroup} : V ‚ü∂ SemiNormedGroup.Completion.obj V
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {t : category_theory.limits.fork f g} (ht : category_theory.limits.is_limit t) {Z Z' : C} (q : Z' ‚ü∂ Z) (k : Z ‚ü∂ t.X) : ‚Üë(‚áë(category_theory.limits.fork.is_limit.hom_iso ht Z') (q ‚â´ k)) = q ‚â´ ‚Üë(‚áë(category_theory.limits.fork.is_limit.hom_iso ht Z) k)
{ùïú : Type u} [nondiscrete_normed_field ùïú] (f : local_homeomorph ùïú ùïú) {a f' : ùïú} (ha : a ‚àà f.to_local_equiv.target) (hf' : f' ‚â† 0) (htff' : has_deriv_at ‚áëf f' (‚áë(f.symm) a)) : has_deriv_at ‚áë(f.symm) f'‚Åª¬π a
{G : Type u_1} [linear_ordered_comm_group G] (H : subgroup G) : linear_ordered_comm_group ‚Ü•H
(t : Type u ‚Üí Type u) : Type (u+1)
{M : Type uM} {N : Type uN} {P : Type uP} [mul_one_class M] [comm_monoid N] [comm_monoid P] : (N ‚Üí* P) ‚Üí* (M ‚Üí* N) ‚Üí* M ‚Üí* P
{Œ± : Type u} [topological_space Œ±] [t1_space Œ±] {s : set Œ±} (hs : dense s) (x : Œ±) [(nhds_within x {x}·∂ú).ne_bot] : dense (s  {x})
{Œ± : Type u_1} [partial_order Œ±] [order_top Œ±] {a : Œ±} : is_coatom a ‚Üí a ‚ãñ ‚ä§
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [partial_order Œ±] [t : order_topology Œ±] {f g h : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±} (hg : filter.tendsto g b (nhds a)) (hh : filter.tendsto h b (nhds a)) (hgf : ‚àÄ·∂† (b : Œ≤) in b, g b ‚â§ f b) (hfh : ‚àÄ·∂† (b : Œ≤) in b, f b ‚â§ h b) : filter.tendsto f b (nhds a)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (r : setoid Œ≤) : quotient (setoid.comap f r) ‚âÉ ‚Ü•(set.range (quotient.mk ‚àò f))
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : (‚àÄ (f : ‚Ñï ‚Üío (submodule R M)·µí·µà), ‚àÉ (n : ‚Ñï), ‚àÄ (m : ‚Ñï), n ‚â§ m ‚Üí ‚áëf n = ‚áëf m) ‚Üî is_artinian R M
{x y : pgame} : x.relabelling y ‚Üí (-x).relabelling (-y)
(M : Type u) : Type u
{C : Type u_1} [category_theory.category C] (F : C ‚•§ category_theory.Cat) : category_theory.grothendieck F ‚•§ C
{Œ± : Type u_1} {Œ≤ : Type u_2} (x : Œ≤) : Œ± ‚äï‚Çó Œ≤
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F G : J ‚•§ C} (H : C ‚•§ D) {Œ± : F ‚âÖ G} {c : category_theory.limits.cocone G} : H.map_cocone ((category_theory.limits.cocones.precompose_equivalence Œ±).functor.obj c) ‚âÖ (category_theory.limits.cocones.precompose_equivalence (category_theory.iso_whisker_right Œ± H)).functor.obj (H.map_cocone c)
 : Type
{R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R ‚Üí+* P} (hg : ‚àÄ (y : ‚Ü•M), is_unit (‚áëg ‚Üëy)) {x y : R} (h : ‚áë(algebra_map R S) x = ‚áë(algebra_map R S) y) : ‚áëg x = ‚áëg y
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} : category_theory.category (category_theory.limits.cone F)
{R : Type u_1} {a : R} [cancel_monoid_with_zero R] (a0 : a ‚â† 0) : is_regular a
 : tactic std_gen
{Œ± : Type u_2} {Œ≤ : Type u_3} [add_monoid Œ±] [add_action Œ± Œ≤] : add_action Œ± (set Œ≤)
(R : Type u) [ring R] : Module.free R ‚ä£ category_theory.forget (Module R)
{M : Type u_1} {N : Type u_2} {F : Type u_3} [has_mul M] [has_mul N] [mul_hom_class F M N] (f : F) (hf : function.bijective ‚áëf) : M ‚âÉ* N
{m : Type u_3} {n : Type u_4} {Œ± : Type u_5} [fintype m] [fintype n] [semi_normed_group Œ±] : semi_normed_group (matrix m n Œ±)
{m n : ‚Ñï} : (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n
{A : Type u_1} {B : Type u_2} [comm_ring A] [is_domain A] [ring B] [algebra A B] {x : B} [is_domain B] (hx : is_integral A x) : irreducible (minpoly A x)
{Œ± : Type u_1} [decidable_eq Œ±] (s : finset Œ±) (n : ‚Ñï) : finset (sym Œ± n)
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : out_param (Type u_3)) : Type (max u_1 u_2 u_3)
 : tactic.itauto.proof ‚Üí tactic.itauto.proof ‚Üí tactic.itauto.proof
(p : tactic.ring_exp.atom) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.base)
{Œπ : Type u_1} {Œ± : Type u_2} {A : Œπ ‚Üí Type u_3} [add_monoid Œπ] [graded_monoid.gmonoid A] (l : list Œ±) (f : Œ± ‚Üí graded_monoid A) : (list.map f l).prod = graded_monoid.mk (l.dprod_index (Œª (i : Œ±), (f i).fst)) (l.dprod (Œª (i : Œ±), (f i).fst) (Œª (i : Œ±), (f i).snd))
{Œ± : Type u_1} {R : Type u_2} {l : filter Œ±} {f : Œ± ‚Üí R} {r : R} [linear_ordered_semiring R] [archimedean R] (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Œª (x : Œ±), f x * r) l filter.at_top
 : expr ‚Üí expr ‚Üí tactic expr
(S : category_theory.SheafOfTypes category_theory.types_grothendieck_topology) : S ‚âÖ category_theory.yoneda'.obj (S.val.obj (opposite.op punit))
(o : ordinal) (f : Œ† (a : ordinal), a < o ‚Üí ordinal) : ordinal
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] {B : Type u‚ÇÉ} [category_theory.category B] {J : category_theory.grothendieck_topology C} (F : A ‚•§ B) (P : C·µí·µñ ‚•§ A) {X : C} (S : J.cover X) : (S.index (P ‚ãô F)).multicospan ‚âÖ (S.index P).multicospan ‚ãô F
{Œ± : Type u} [has_subset Œ±] {a b : Œ±} [is_refl Œ± has_subset.subset] : a = b ‚Üí b ‚äÜ a
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [no_min_order Œ±] [densely_ordered Œ±] {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (set.Iic a) ‚Üî ‚àÉ (l : Œ±) (H : l ‚àà set.Iio a), set.Icc l a ‚äÜ s
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] (E : Type u‚ÇÉ) [category_theory.category E] : (C ‚•§ D) ‚•§ (D ‚•§ E) ‚•§ C ‚•§ E
{Œ± : Type u} {R : Type v} [ring R] : (Œ± ‚Üí R) ‚âÉ (free_ring Œ± ‚Üí+* R)
(Œì : Type u_1) (R : Type u_2) [partial_order Œì] [has_zero R] : Type (max u_1 u_2)
{J : Type v} [category_theory.small_category J] {F : J ‚•§ Type (max v u)} {c : category_theory.limits.cone F} (t : category_theory.limits.is_limit c) : c.X ‚âÉ ‚Ü•(F.sections)
(R : Type u) [semiring R] (n : with_bot ‚Ñï) : submodule R (polynomial R)
(A : Type u_1) {B : Type u_2} [field A] [ring B] [algebra A B] (x : B) {p : polynomial A} (hp : ‚áë(polynomial.aeval x) p = 0) : minpoly A x ‚à£ p
 : has_neg surreal
{R‚ÇÅ : Type u_1} [semiring R‚ÇÅ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] [has_continuous_add M‚ÇÅ] : module (M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) M‚ÇÅ
(Œ± : Type u_1) [add_comm_group Œ±] : Type u_1
{Œ± : Type u_1} {Œ±' : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_5} {Œ¥ : Type u_7} [decidable_eq Œ±'] [decidable_eq Œ≥] [decidable_eq Œ¥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s : finset Œ±} {t : finset Œ≤} {g : Œ≥ ‚Üí Œ¥} {f' : Œ≤ ‚Üí Œ±' ‚Üí Œ¥} {g' : Œ± ‚Üí Œ±'} (h_antidistrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' b (g' a)) : finset.image g (finset.image‚ÇÇ f s t) = finset.image‚ÇÇ f' t (finset.image g' s)
(G : Type u) : Type u
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) [category_theory.has_projective_resolution Z] : category_theory.projective_resolution Z ‚ü∂ (chain_complex.single‚ÇÄ C).obj Z
{G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {K : Type u_3} [group K] [topological_space K] [nonarchimedean_group K] : nonarchimedean_group (G √ó K)
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.limits.has_pullback f g] : C
{Œ± : Type u} [group Œ±] : is_group_hom id
 : expr ‚Üí tactic expr
{Œ± : Type u_1} : lazy_list Œ± ‚Üí lazy_list Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [topological_space Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : continuous f) (x‚ÇÄ : Œ≤) (h : ‚àÄ·∂† (x : Œ≤) in filter.cocompact Œ≤, f x ‚â§ f x‚ÇÄ) : ‚àÉ (x : Œ≤), ‚àÄ (y : Œ≤), f y ‚â§ f x
{X : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (x y z : ùí∞.J) : category_theory.limits.pullback category_theory.limits.pullback.fst category_theory.limits.pullback.fst ‚ü∂ category_theory.limits.pullback category_theory.limits.pullback.fst category_theory.limits.pullback.fst
{M : Type u_1} [mul_one_class M] : submonoid M ‚âÉo add_submonoid (additive M)
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] {i j : Œπ} (x : M i) (hnotone : x ‚â† 1) (w : free_product.neword M i j) : free_product.neword M i j
(x y : string) : bool
{R : Type u} [comm_ring R] (S T : ideal R) (H : S ‚â§ T) : R ‚ß∏ S ‚Üí+* R ‚ß∏ T
(X : algebraic_geometry.Scheme) : Type (max (u+1) (v+1))
{Œ± : Type u_1} {Œ≤ : Type u_2} {s : set Œ±} {t : Œ± ‚Üí set Œ≤} {y : Œ≤} (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí y ‚àà t x) : y ‚àà ‚ãÇ (x : Œ±) (H : x ‚àà s), t x
{A : Type u_1} {Œπ : Type u_2} [ring A] [nonempty Œπ] {B : Œπ ‚Üí add_subgroup A} (hB : ring_subgroups_basis B) : topological_space A
(X : Profinite) : discrete_quotient ‚Ü•X ‚•§ Fintype
{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] (C r : nnreal) (f : X ‚Üí Y) (s : set X) : Prop
(f : circle_deg1_lift) (P : ‚Ñù ‚Üí Prop) (h : ‚àÄ (x : ‚Ñù), x ‚àà set.Icc 0 1 ‚Üí P (‚áëf x - x)) (x : ‚Ñù) : P (‚áëf x - x)
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : Œπ ‚Üí P) (s : finset Œπ) {n : ‚Ñï} (hc : s.card = n + 1) : finite_dimensional.finrank k ‚Ü•(vector_span k ‚Üë(finset.image p s)) ‚â§ n
{R : Type u_1} {m : Type u_3} {Œ± : Type u_5} [fintype m] [is_R_or_C Œ±] [decidable_eq m] [normed_field R] [normed_algebra R Œ±] : normed_algebra R (matrix m m Œ±)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (e : local_homeomorph Œ± Œ≤) {f : Œ≥ ‚Üí Œ±} {s : set Œ≥} {x : Œ≥} (hx : f x ‚àà e.to_local_equiv.source) (h : f ‚Åª¬π' e.to_local_equiv.source ‚àà nhds_within x s) : continuous_within_at f s x ‚Üî continuous_within_at (‚áëe ‚àò f) s x
{Œ± : Type u_1} {Œπ : Type u_2} {f : Œπ ‚Üí Œ±} : function.injective f ‚Üí pairwise (ne on f)
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] {J : Type v} [category_theory.small_category J] [category_theory.fin_category J] (F : J ‚•§ C) : category_theory.limits.cocone F
{L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] [L.is_algebraic] {f : L.hom M N} (hf : function.injective ‚áëf) : L.embedding M N
{Œ± : Type u_1} {n : ‚Ñï} (s : sym Œ± n) : sym.map (Œª (x : Œ±), x) s = s
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_ring k] [group G] [add_comm_group V] [module k V] (œÅ : representation k G V) [nontrivial k] [module.free k V] [module.finite k V] : œÅ.character 1 = ‚Üë(finite_dimensional.finrank k V)
{Œ± : Type u_1} (B : set (set Œ±)) (empty_mem : ‚àÖ ‚àà B) (subset_mem : ‚àÄ (s‚ÇÅ : set Œ±), s‚ÇÅ ‚àà B ‚Üí ‚àÄ (s‚ÇÇ : set Œ±), s‚ÇÇ ‚äÜ s‚ÇÅ ‚Üí s‚ÇÇ ‚àà B) (union_mem : ‚àÄ (s‚ÇÅ : set Œ±), s‚ÇÅ ‚àà B ‚Üí ‚àÄ (s‚ÇÇ : set Œ±), s‚ÇÇ ‚àà B ‚Üí s‚ÇÅ ‚à™ s‚ÇÇ ‚àà B) (sUnion_univ : ‚ãÉ‚ÇÄB = set.univ) : bornology Œ±
{k : Type u_1} {V1 : Type u_2} {V2 : Type u_4} [ring k] [add_comm_group V1] [module k V1] [add_comm_group V2] [module k V2] (f : V1 ‚Üí·µÉ[k] V2) : ‚áëf = ‚áë(f.linear) + Œª (z : V1), ‚áëf 0
(Œ± : Type u_1) (enum : Œ± ‚Üí ‚Ñï) (n : ‚Ñï) : Type u_1
(n : ‚Ñï) : ‚Ñ§ ‚ß∏ add_subgroup.zmultiples ‚Üën ‚âÉ+ zmod n
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] : subsingleton (category_theory.preadditive C)
{L : first_order.language} {M : Type w} [L.Structure M] {p : M ‚Üí Prop} (x : M) {s : set M} (hs : ‚áë(first_order.language.substructure.closure L) s = ‚ä§) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí p x) (Hfun : ‚àÄ {n : ‚Ñï} (f : L.functions n), first_order.language.closed_under f (set_of p)) : p x
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {s : set E} [complete_space F] (h : analytic_on ùïú f s) (n : ‚Ñï) : analytic_on ùïú (iterated_fderiv ùïú n f) s
(p : ‚Ñï) {idx : Type u_2} [hp : fact (nat.prime p)] (Œ¶ : mv_polynomial idx ‚Ñ§) (n : ‚Ñï) : mv_polynomial (idx √ó ‚Ñï) ‚Ñ§
 : native.float
{Œ± : Type u_1} [fintype Œ±] (p q : Œ± ‚Üí Prop) [fintype {x // p x}] [fintype {x // ¬¨p x}] [fintype {x // q x}] [fintype {x // ¬¨q x}] (h : fintype.card {x // p x} = fintype.card {x // q x}) : fintype.card {x // ¬¨p x} = fintype.card {x // ¬¨q x}
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} {P' : C·µí·µñ ‚•§ Type w} (i : P ‚âÖ P') : category_theory.presieve.is_sheaf_for P R ‚Üí category_theory.presieve.is_sheaf_for P' R
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {a : Œ±} {s : set Œ±} (f : Œ± ‚Üí M) (h : a ‚àâ s) (hs : (s ‚à© function.mul_support f).finite) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà has_insert.insert a s), f i)) = f a * finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i))
{E : Type u} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {a : E} {f' : E ‚ÜíL[‚Ñù] ‚Ñù} {s : set E} (h : is_local_min_on f s a) (hf : has_fderiv_within_at f f' s a) {y : E} (hy : y ‚àà pos_tangent_cone_at s a) : 0 ‚â§ ‚áëf' y
{J : Type u} [preorder J] [is_directed J has_le.le] (F : J·µí·µñ ‚•§ Type v) [Œ† (j : J·µí·µñ), fintype (F.obj j)] [‚àÄ (j : J·µí·µñ), nonempty (F.obj j)] : F.sections.nonempty
{M : Type u_5} {N : Type u_6} [mul_one_class M] [mul_one_class N] {M' : Type u_8} {N' : Type u_9} [mul_one_class M'] [mul_one_class N'] (f : M ‚Üí* M') (g : N ‚Üí* N') : M √ó N ‚Üí* M' √ó N'
(X : Profinite) : category_theory.projective_presentation X
(R : Type u_1) [ring R] [topological_space R] : Prop
{M : Type u_1} [semigroup M] [nonempty M] (s : set (set M)) (sfin : s.finite) (scov : ‚ä§ ‚äÜ ‚ãÉ‚ÇÄs) : ‚àÉ (c : set M) (H : c ‚àà s) (a : stream M), hindman.FP a ‚äÜ c
{M : Type u_1} [has_mul M] : ‚Ü•‚ä§ ‚âÉ* M
{L : first_order.language} {L' : first_order.language} (e : L ‚âÉ·¥∏ L') : L' ‚âÉ·¥∏ L
{Œ± : Type u} [semigroup Œ±] [has_distrib_neg Œ±] (a b : Œ±) : -a ‚à£ b ‚Üî a ‚à£ b
{ùïú : Type u_1} {F : Type u_3} [is_R_or_C ùïú] [add_comm_group F] [module ùïú F] [c : inner_product_space.core ùïú F] : has_inner ùïú F
{Œ± : Type u_1} [preorder Œ±] : ordset Œ±
{E : Type u_1} {PE : Type u_2} [normed_group E] [normed_space ‚Ñù E] [metric_space PE] [normed_add_torsor E PE] {F : Type u_3} {PF : Type u_4} [normed_group F] [normed_space ‚Ñù F] [metric_space PF] [normed_add_torsor F PF] (f : PE ‚âÉ·µ¢ PF) : PE ‚âÉ·µÉ‚Å±[‚Ñù] PF
{M : Type u_12} {N : Type u_13} [has_mul M] [has_mul N] (self : M ‚âÉ* N) : M ‚âÉ N
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_4} [fintype Œπ] [decidable_eq Œπ] (e : basis Œπ R M) (x : orientation R M Œπ) (f : M ‚âÉ‚Çó[R] M) : ‚áë(orientation.map Œπ f) x = (‚áëlinear_equiv.det f)‚Åª¬π ‚Ä¢ x
{d : ‚Ñ§} : ‚Ñ§‚àöd
{Œ± : Type u_1} [decidable_eq Œ±] (s : set Œ±) [fintype ‚Ü•s] : finset Œ±
 : Type
{M : Type u_6} [add_monoid M] (u : add_units M) : equiv.perm M
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] : finset.univ = finset.map equiv.perm.decompose_option.symm.to_embedding finset.univ
(a b : num) : num
{Œ± Œ≤ : Type} (handler : tactic Œ≤) (tac : tactic Œ±) : tactic Œ±
{Œ± : Type u} [boolean_algebra.core Œ±] : has_sdiff Œ±
{C : Type u} [category_theory.category C] (f : category_theory.arrow C) [‚àÄ (n : ‚Ñï), category_theory.limits.has_wide_pushout f.left (Œª (i : ulift (fin (n + 1))), f.right) (Œª (i : ulift (fin (n + 1))), f.hom)] : category_theory.cosimplicial_object C
{Œ± : Type u_1} {s t : set Œ±} (h : s = t) : ‚Ü•s ‚âÉ ‚Ü•t
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {P Q : C} (f : P ‚ü∂ Q) : P ‚ü∂ category_theory.abelian.image f
{Œ± : Type u_8} [comm_group Œ±] : Œ± √ó Œ± ‚Üí* Œ±
(p : ‚Ñï) [hp : fact (nat.prime p)] (n : ‚Ñï) : mv_polynomial (fin 2 √ó ‚Ñï) ‚Ñ§
(e : expr) : tactic.ring_exp.ring_exp_m (expr √ó expr)
 : Type (u_1+1)
{E : Type u_2} [add_comm_group E] [module ‚Ñù E] [topological_space E] [topological_add_group E] [has_continuous_smul ‚Ñù E] [t2_space E] {s : set E} (hs : s.finite) : is_closed (‚áë(convex_hull ‚Ñù) s)
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {a a' : P.A} (h : a = a') : (P.drop.B a).arrow (P.drop.B a')
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) (a : Œ±) : Prop
{Œ± : Type u} : ordnode Œ± ‚Üí ordnode Œ±
{ùïú : Type u_3} [field ùïú] {r : ‚Ñï} (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) (hM : M (sum.inr ()) (sum.inr ()) ‚â† 0) : (((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod).is_two_block_diagonal
(R : Type u_1) {C : Type u} (X : C) : category_theory.Free R C
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (direction : submodule k V) : (affine_subspace.mk' p direction).direction = direction
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} : b = c ‚Üí a ‚â§ b ‚Üí a ‚â§ c
{X : Type u_2} [emetric_space X] (m : set X ‚Üí ennreal) (r : ennreal) : measure_theory.outer_measure X
{Œ± : Type u_1} (e : Œ± ‚âÉ ‚Ñï) : Œ± √ó Œ± ‚âÉ Œ±
{Œ± : Type u} (xs : list Œ±) (x : Œ±) [decidable_eq Œ±] : [x].intercalate (list.split_on x xs) = xs
{R : Type u_1} {M : Type u_2} {N : Type u_3} {Œπ : Type u_4} {Œ∫ : Type u_5} [comm_ring R] [add_comm_group M] [module R M] [add_comm_group N] [module R N] (b : basis Œπ R M) (c : basis Œ∫ R N) : basis (Œπ √ó Œ∫) R (tensor_product R M N)
(Œ± : Type u_1) [fintype Œ±] [category_theory.small_category Œ±] [category_theory.fin_category Œ±] : Type
{Œ± : Type u_1} [linear_ordered_field Œ±] {Œ≤ : Type u_2} [field Œ≤] {abv : Œ≤ ‚Üí Œ±} [is_absolute_value abv] (f : cau_seq Œ≤ abv) (hf : ¬¨f.lim_zero) : cau_seq Œ≤ abv
 : category_theory.full (category_theory.forget‚ÇÇ (Module ‚Ñ§) AddCommGroup)
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} {C : Type u_1} (g : Œ† (a : P.A), (P.drop.B a).arrow Œ± ‚Üí (P.last.B a ‚Üí P.W Œ±) ‚Üí (P.last.B a ‚Üí C) ‚Üí C) : P.W Œ± ‚Üí C
(o : ordinal) : cardinal
{Œ± : Type u} {r : Œ± ‚Üí Œ± ‚Üí Prop} {a b : Œ±} (h : relation.refl_trans_gen r a b) : ‚àÉ (l : list Œ±), list.chain r a l ‚àß (a :: l).last _ = b
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.preadditive C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} (f : Y ‚ü∂ Z) {P : category_theory.ProjectiveResolution Y} {Q : category_theory.ProjectiveResolution Z} (g h : P.complex ‚ü∂ Q.complex) (g_comm : g ‚â´ Q.œÄ = P.œÄ ‚â´ (chain_complex.single‚ÇÄ C).map f) (h_comm : h ‚â´ Q.œÄ = P.œÄ ‚â´ (chain_complex.single‚ÇÄ C).map f) : homotopy g h
(V : Type (u+1)) [category_theory.large_category V] [category_theory.monoidal_category V] (H : Group) [category_theory.rigid_category V] : category_theory.rigid_category (Action V ‚ÜëH)
(Œ± : Type u_8) : Type u_8
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (f : C(Œ± √ó Œ≤, Œ≥)) (a : Œ±) : C(Œ≤, Œ≥)
{K : Type u} [field K] (s : subfield K) : 0 ‚àà s
{A : Type u_1} [comm_monoid A] (a b c : A) : c ‚àà submonoid.closure {a, b} ‚Üî ‚àÉ (m n : ‚Ñï), a ^ m * b ^ n = c
(Œ± : Type u_1) [boolean_algebra Œ±] : as_boolalg (as_boolring Œ±) ‚âÉo Œ±
{S : Type u_2} [comm_ring S] {A : Type u_4} {B : Type u_5} [comm_ring A] [comm_ring B] [is_domain B] [algebra A B] [algebra A S] [is_domain A] (pb : power_basis A S) : (S ‚Üí‚Çê[A] B) ‚âÉ {y // y ‚àà (polynomial.map (algebra_map A B) (minpoly A pb.gen)).roots}
(Œ± : Type) : Type
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) : f ‚Åª¬π'o s ‚Üír s
 : tactic.ring.horner_expr ‚Üí tactic format
{Œ± : Type u_1} [has_Sup Œ±] {Œπ : Sort u_2} (s : Œπ ‚Üí Œ±) : Œ±
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [semiring k] [monoid G] : (monoid_algebra k G)·µê·µí·µñ ‚âÉ+* monoid_algebra k·µê·µí·µñ G·µê·µí·µñ
(A : Type u_4) [monoid A] [topological_space A] : continuous_monoid_hom A (A √ó A)
{n : ‚Ñï} {Œ± : Type u} (a : array (n + 1) Œ±) : array n Œ±
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] [inhabited Œ≤] : inhabited (bounded_continuous_function Œ± Œ≤)
 : Type
(p : ‚Ñï) {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] : R ‚Üí* witt_vector p R
{Œ± : Sort u} {Œ≤ : Sort v} [inhabited Œ≤] (e : Œ± ‚âÉ Œ≤) : inhabited Œ±
{Œ± : Type u_2} {Œπ : Type u_5} [add_comm_monoid Œ±] (t : finset Œπ) (f‚ÇÅ f‚ÇÇ : Œπ ‚Üí set Œ±) (hf : ‚àÄ {i : Œπ}, i ‚àà t ‚Üí f‚ÇÅ i ‚äÜ f‚ÇÇ i) : t.sum (Œª (i : Œπ), f‚ÇÅ i) ‚äÜ t.sum (Œª (i : Œπ), f‚ÇÇ i)
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] (e : topological_fiber_bundle.trivialization F proj) {x : Z} (ex : x ‚àà e.to_local_homeomorph.to_local_equiv.source) : continuous_at proj x
{M N : SemiNormedGroup} (f : M ‚âÖ N) (i : normed_group_hom.norm_noninc f.hom) (i' : normed_group_hom.norm_noninc f.inv) : SemiNormedGroup‚ÇÅ.of ‚Ü•M ‚âÖ SemiNormedGroup‚ÇÅ.of ‚Ü•N
{Œì : Type u_1} {R : Type u_2} [partial_order Œì] [add_monoid R] (g : Œì) : hahn_series Œì R ‚Üí+ R
(old new : name) (e : expr) : tactic unit
 : multiplicative ‚Ñù ‚Üí* circle_deg1_liftÀ£
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] {v : n ‚Üí Œ±} : is_unit (matrix.diagonal v) ‚Üî is_unit v
 : linter
{Œ± : Type u} : partial_order (topological_space Œ±)
(R : Type u) {X : Type v} [comm_ring R] {L : Type w} [lie_ring L] [lie_algebra R L] (f : X ‚Üí L) : free_non_unital_non_assoc_algebra R X ‚Üí‚Çô‚Çê[R] L
(r : ‚Ñù) (h : r ‚â† 0) : r.sign = -1 ‚à® r.sign = 1
{P : Type u_1} [preorder P] {F : order.pfilter P} (h : F.is_prime) : order.ideal.prime_pair P
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [semiring R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] [topological_space (bundle.total_space E)] (e : topological_vector_bundle.trivialization R F E) (b : B) : F ‚Üí‚Çó[R] E b
{C : Type u} [category_theory.category C] [category_theory.enough_injectives C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_cokernel f] : C
{a b c : ‚Ñ§} (h : fermat_42.minimal a b c) : is_coprime a b
(lem : name) (args : list expr) (hs : list tactic.ring_exp.ex_info) : tactic.ring_exp.ring_exp_m expr
{Œ± : Type u_1} [topological_space Œ±] {Œ≤‚ÇÅ : Type u_7} {Œ≤‚ÇÇ : Type u_8} [topological_space Œ≤‚ÇÅ] [topological_space Œ≤‚ÇÇ] (f : C(Œ±, Œ≤‚ÇÅ)) (g : C(Œ±, Œ≤‚ÇÇ)) : C(Œ±, Œ≤‚ÇÅ √ó Œ≤‚ÇÇ)
{Œ± : Type u_1} [has_add Œ±] [has_lt Œ±] [contravariant_class Œ± Œ± has_add.add has_lt.lt] {a b c : Œ±} (bc : a + b < a + c) : b < c
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (f : M ‚Üí* P) : (con.ker f).quotient ‚âÉ* ‚Ü•(f.mrange)
 : tactic.ring.horner_expr ‚Üí expr
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_2} (f : (Œ† (a : Œ±), part (Œ≤ a)) ‚Üí Œ† (a : Œ±), part (Œ≤ a)) (x : Œ±) : part (Œ≤ x)
{B : Type u} [quiver B] {a b c : B} : quiver.path a b ‚Üí category_theory.free_bicategory.hom b c ‚Üí quiver.path a c
{Œ± : Type u} [has_subset Œ±] [has_ssubset Œ±] [is_nonstrict_strict_order Œ± has_subset.subset has_ssubset.ssubset] {a b : Œ±} [is_antisymm Œ± has_subset.subset] (h : a ‚äÜ b) : a = b ‚à® a ‚äÇ b
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} (f : Œ± ‚Üí Œ≤) (g : Œ± ‚Üí Œ≥) (e' : Œ≤ ‚Üí Œ≥) : Œ≤ ‚Üí Œ≥
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] (F : category_theory.oplax_functor B C) (F' : F.pseudo_core) : category_theory.pseudofunctor B C
(F : Sort u_1) (Œ± : out_param (Sort u_2)) (Œ≤ : out_param (Œ± ‚Üí Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3))
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Type (max v u)) (x y : Œ£ (j : J), F.obj j) : Prop
{x y : pgame} : x.lf y ‚Üî (‚àÉ (i : y.left_moves), (‚àÄ (i' : x.left_moves), (x.move_left i').lf (y.move_left i)) ‚àß ‚àÄ (j : (y.move_left i).right_moves), x.lf ((y.move_left i).move_right j)) ‚à® ‚àÉ (j : x.right_moves), (‚àÄ (i : (x.move_right j).left_moves), ((x.move_right j).move_left i).lf y) ‚àß ‚àÄ (j' : y.right_moves), (x.move_right j).lf (y.move_right j')
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {Œπ : Type u_1} (Y : Œπ ‚Üí C) (f : Œ† (i : Œπ), Y i ‚ü∂ X) : category_theory.presieve X
(R : Type u_1) {M : Type u_4} (S : Type u_7) [semiring R] [add_comm_monoid M] [module R M] (s : set M) [semiring S] [has_scalar R S] [module S M] [is_scalar_tower R S M] : submodule.span R s ‚â§ submodule.restrict_scalars R (submodule.span S s)
(n : ‚Ñï) (R : Type u_1) [comm_ring R] [is_domain R] : polynomial R
(R : Type u‚ÇÅ) [comm_ring R] (p : ‚Ñï) [hp : fact (nat.prime p)] [char_p R p] : subring (‚Ñï ‚Üí R)
{G H : AddCommGroup} (f : G ‚ü∂ H) : G ‚ü∂ AddCommGroup.image f
 : has_lt expr
{Œ± : Type u} {L‚ÇÅ : list (Œ± √ó bool)} {x : Œ± √ó bool} : free_group.red [x] L‚ÇÅ ‚Üî L‚ÇÅ = [x]
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) : initial_seg r (sum.lex r s)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C·¥π·µí·µñ} (f : X ‚ü∂ Y) : category_theory.monoidal_opposite.unmop X ‚ü∂ category_theory.monoidal_opposite.unmop Y
(tac : tactic.interactive.itactic) : tactic unit
{M : Type u_3} {G : Type u_6} [mM : add_zero_class M] [add_group G] (f : M ‚Üí G) (map_mul : ‚àÄ (a b : M), f (a + b) = f a + f b) : M ‚Üí+ G
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommGroup) : Group
{R : Type u} [has_involutive_star R] : equiv.perm R
{E : Type u_2} [semi_normed_group E] [normed_space ‚Ñù E] : locally_convex_space ‚Ñù E
{Œ± : Type u_1} [lattice Œ±] [is_modular_lattice Œ±] {Œ≤ : Type u_2} {Œ≥ : Type u_3} [preorder Œ≤] [partial_order Œ≥] (h‚ÇÅ : well_founded gt) (h‚ÇÇ : well_founded gt) (K : Œ±) (f‚ÇÅ : Œ≤ ‚Üí Œ±) (f‚ÇÇ : Œ± ‚Üí Œ≤) (g‚ÇÅ : Œ≥ ‚Üí Œ±) (g‚ÇÇ : Œ± ‚Üí Œ≥) (gci : galois_coinsertion f‚ÇÅ f‚ÇÇ) (gi : galois_insertion g‚ÇÇ g‚ÇÅ) (hf : ‚àÄ (a : Œ±), f‚ÇÅ (f‚ÇÇ a) = a ‚äì K) (hg : ‚àÄ (a : Œ±), g‚ÇÅ (g‚ÇÇ a) = a ‚äî K) : well_founded gt
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] (proj : Z ‚Üí B) : Type (max u_2 u_3 u_4)
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j‚ÇÅ j‚ÇÇ j‚ÇÉ : C) : j‚ÇÉ ‚ü∂ category_theory.is_filtered.max‚ÇÉ j‚ÇÅ j‚ÇÇ j‚ÇÉ
(x : ‚ÑÇ) : has_strict_deriv_at complex.sin (complex.cos x) x
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_vadd Œ± Œ≤] : has_vadd Œ± (filter Œ≤)
{Œ± : Type u} [topological_space Œ±] (s : set Œ±) : Prop
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) : category_theory.limits.is_limit ((category_theory.forget‚ÇÇ CommRing CommSemiRing).map_cone (CommRing.limit_cone F))
{Œ± : Type u_1} {Œπ : Type u_3} [complete_lattice Œ±] {t : Œπ ‚Üí Œ±} (ht : complete_lattice.independent t) : pairwise (disjoint on t)
{Œ± : Type u} : ‚Ñï ‚Üí lazy_list Œ± ‚Üí list Œ±
{Œ± : Type u_1} [measurable_space Œ±] (m : Œ† (s : set Œ±), measurable_set s ‚Üí ennreal) (m0 : m ‚àÖ measurable_set.empty = 0) (mU : ‚àÄ ‚¶Éf : ‚Ñï ‚Üí set Œ±‚¶Ñ (h : ‚àÄ (i : ‚Ñï), measurable_set (f i)), pairwise (disjoint on f) ‚Üí m (‚ãÉ (i : ‚Ñï), f i) _ = ‚àë' (i : ‚Ñï), m (f i) _) : measure_theory.measure Œ±
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [comm_semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] (f : multilinear_map R M‚ÇÅ M‚ÇÇ) [fintype Œπ] (c : Œπ ‚Üí R) (m : Œ† (i : Œπ), M‚ÇÅ i) : ‚áëf (Œª (i : Œπ), c i ‚Ä¢ m i) = finset.univ.prod (Œª (i : Œπ), c i) ‚Ä¢ ‚áëf m
{m n b : ‚Ñï} (hm : m ‚â† 1) (hn : 0 < n) (hb : nat.log m n < b) : multiplicity m n = ‚Üë((finset.filter (Œª (i : ‚Ñï), m ^ i ‚à£ n) (finset.Ico 1 b)).card)
{Œ± : Type u_1} [preorder Œ±] (a : Œ±) : set Œ±
(R : Type u_1) (S : Type u_2) [semiring R] [ordered_semiring S] : Type (max u_1 u_2)
{ùïú : Type u_1} [field ùïú] {M : Type u_2} [add_comm_group M] [module ùïú M] [finite_dimensional ùïú M] (f : M ‚Üí‚Çó[ùïú] M) (hf : ‚áëlinear_map.det f ‚â† 0) : M ‚âÉ‚Çó[ùïú] M
(Œ± : Type u_2) [has_le Œ±] : Prop
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] : has_coe_to_fun (valuation R Œì‚ÇÄ) (Œª (_x : valuation R Œì‚ÇÄ), R ‚Üí Œì‚ÇÄ)
{R : Type u_1} [comm_semiring R] {M : Type u_2} {N : Type u_3} [add_comm_group M] [add_comm_group N] [module R M] [module R N] : tensor_product.compatible_smul R ‚Ñ§ M N
(G : Type u_1) [monoid G] [topological_space G] : Type u_1
{Œ± : Type u_1} (s : set (set Œ±)) : filter_basis Œ±
{Œ≤ Œ± : Type u_1} (f : Œ≤ ‚Üí Œ±) (w : cardinal.mk Œ± < cardinal.mk Œ≤) (w' : infinite Œ±) : ‚àÉ (a : Œ±), infinite ‚Ü•(f ‚Åª¬π' {a})
{R : Type u_1} [semiring R] [topological_space R] [topological_semiring R] (p : polynomial R) (X : set R) : C(‚Ü•X, R)
{n : ‚Ñï} (R : Type u_1) [ring R] [char_p R n] [fintype R] (h : fintype.card R = n) : zmod n ‚âÉ+* R
{Œ± : Type u} {Œ≤ : Type v} [add_comm_group Œ≤] (g h : free_abelian_group Œ± ‚Üí+ Œ≤) (H : ‚àÄ (x : Œ±), ‚áëg (free_abelian_group.of x) = ‚áëh (free_abelian_group.of x)) : g = h
{C : Type u} [category_theory.category_struct C] (X : C) : Type v
{Œπ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Œπ ‚Üí set X} {s : set X} (c : set (shrinking_lemma.partial_refinement u s)) (hc : is_chain has_le.le c) (ne : c.nonempty) (hfin : ‚àÄ (x : X), x ‚àà s ‚Üí {i : Œπ | x ‚àà u i}.finite) (hU : s ‚äÜ ‚ãÉ (i : Œπ), u i) : shrinking_lemma.partial_refinement u s
{Œ± : Sort u} {Œ≤ : Sort v} (e : Œ± ‚âÉ Œ≤) : unique Œ± ‚âÉ unique Œ≤
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ x‚ÇÇ : X} {p‚ÇÄ q‚ÇÄ : path x‚ÇÄ x‚ÇÅ} {p‚ÇÅ q‚ÇÅ : path x‚ÇÅ x‚ÇÇ} (F : p‚ÇÄ.homotopy q‚ÇÄ) (G : p‚ÇÅ.homotopy q‚ÇÅ) : (p‚ÇÄ.trans p‚ÇÅ).homotopy (q‚ÇÄ.trans q‚ÇÅ)
{Œ± : Type u} {Œ≤ : Type u_1} [has_sup Œ±] [has_inf Œ±] [has_bot Œ±] [has_sdiff Œ±] [generalized_boolean_algebra Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.injective f) (map_sup : ‚àÄ (a b : Œ±), f (a ‚äî b) = f a ‚äî f b) (map_inf : ‚àÄ (a b : Œ±), f (a ‚äì b) = f a ‚äì f b) (map_bot : f ‚ä• = ‚ä•) (map_sdiff : ‚àÄ (a b : Œ±), f (a  b) = f a  f b) : generalized_boolean_algebra Œ±
{Œπ : Type u_1} {Œπ' : Type u_2} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Œπ R M) (e : Œπ ‚âÉ Œπ') : set.range (‚áëb ‚àò ‚áë(e.symm)) = set.range ‚áëb
{K : Type u_1} [linear_ordered_field K] {v : K} {n : ‚Ñï} [floor_ring K] (nth_stream_eq_none : generalized_continued_fraction.int_fract_pair.stream v n = option.none) : v = (generalized_continued_fraction.of v).convergents (n - 1)
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] (h : Œ± ‚âÉ·µ¢ Œ≤) : Œ± ‚Üí Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Ü™ Œ≤) : set Œ± ‚Ü™ set Œ≤
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z ‚Üí B) : Type (max u_2 u_3 u_4)
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (E : K ‚•§ J) (c : category_theory.limits.cone F) : category_theory.limits.cone (E ‚ãô F)
(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))
 : znum ‚Üí num
(Œ± : Type u) : Type u
{Œ± : Type u_1} : set_semiring Œ± ‚âÉ set Œ±
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J ‚Üí C) [category_theory.limits.has_biproduct f] (p : J ‚Üí Prop) [category_theory.limits.has_biproduct (subtype.restrict p f)] : ‚®Å f ‚ü∂ ‚®Å subtype.restrict p f
(n : ‚Ñï) : Type
{Œ± : Type u_1} {m : measurable_space Œ±} (s : set Œ±) : nonempty {t // s ‚äÜ t ‚àß measurable_set t}
{Œ± : Type u_2} {Œ≤ : Type u_3} : filter.cofinite.coprod filter.cofinite = filter.cofinite
{Œ± : Type u_1} [uniform_space Œ±] : (uniformity Œ±).has_basis (Œª (V : set (Œ± √ó Œ±)), V ‚àà uniformity Œ± ‚àß is_open V ‚àß symmetric_rel V) id
{Œ± : Type u} [ring Œ±] {a b : Œ±} : a ‚à£ b + a ‚Üî a ‚à£ b
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [preorder Œ≤] {a : Œ±} {f : Œ± ‚Üí Œ≤} (h‚ÇÅ : strict_mono_on f (set.Iic a)) (h‚ÇÇ : strict_mono_on f (set.Ici a)) : strict_mono f
(R : Type u_1) {S : Type u_6} (M : Type u_9) [semiring R] [add_comm_monoid M] [module R M] [monoid S] [distrib_mul_action S M] [smul_comm_class S R M] (s : S) : M ‚Üí‚Çó[R] M
{Œ± : Type u_1} [topological_space Œ±] [ring Œ±] [topological_ring Œ±] [t2_space Œ±] (s : subring Œ±) (hs : ‚àÄ (x y : ‚Ü•s), x * y = y * x) : comm_ring ‚Ü•(s.topological_closure)
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (s : set E) (x : E) : E ‚ÜíL[ùïú] F
 : matrix (fin 6) (fin 6) ‚Ñ§
(red : tactic.transparency) (atoms : tactic.ref (buffer expr)) (e : expr) : tactic (expr √ó expr)
{E : Type u_4} [normed_group E] [normed_space ‚Ñù E] (B : E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] ‚Ñù) : Prop
{Œ± : Type u_1} [fintype Œ±] [decidable_eq Œ±] (h5 : 5 ‚â§ fintype.card Œ±) {f : equiv.perm Œ±} (hf : f.is_three_cycle) : subgroup.normal_closure {‚ü®f, _‚ü©} = ‚ä§
 : tactic.instance_cache ‚Üí expr ‚Üí expr ‚Üí ‚Ñö ‚Üí ‚Ñö ‚Üí tactic (tactic.instance_cache √ó expr)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [linear_ordered_add_comm_group Œ±] [order_topology Œ±] {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±} {C : Œ±} (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_top) : filter.tendsto (Œª (x : Œ≤), f x + g x) l filter.at_top
(Œ± : Type u_2) : Type u_2
{n : Type u_1} (R : Type u‚ÇÇ) [decidable_eq n] [comm_ring R] [fintype n] (i j : n) (h : j ‚â† i) : ‚Ü•(lie_algebra.special_linear.sl n R)
{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ‚â† 2) : finset.univ.sum (Œª (a : F), char.quadratic_char F a) = 0
 : expr ‚Üí expr ‚Üí tactic expr
(n : ‚Ñï) : is_well_order (fin n) has_lt.lt
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (F : C ‚•§ D) [category_theory.is_equivalence F] {X Y : C} {f : X ‚ü∂ Y} (hf : category_theory.normal_mono (F.map f)) : category_theory.normal_mono f
{R‚ÇÇ : Type u_5} [comm_semiring R‚ÇÇ] {n : Type u_11} [fintype n] [decidable_eq n] : bilin_form R‚ÇÇ (n ‚Üí R‚ÇÇ) ‚âÉ‚Çó[R‚ÇÇ] matrix n n R‚ÇÇ
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_assoc_semiring Œ±} {rŒ≤ : non_assoc_semiring Œ≤} (f : Œ± ‚Üí+* Œ≤) : ‚áëf 1 = 1
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : collinear k s ‚Üî module.rank k ‚Ü•(vector_span k s) ‚â§ 1
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] (X Y : C) : category_theory.limits.coprod.functor.obj (X ‚®ø Y) ‚âÖ category_theory.limits.coprod.functor.obj Y ‚ãô category_theory.limits.coprod.functor.obj X
{Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s ‚à© t)
(expected_tp : expr) (h_eqs_names : list expr) (coeffs : list pexpr) : tactic expr
(Œ± : fin 2 ‚Üí Type u_1) [Œ† (i : fin 2), measurable_space (Œ± i)] : (Œ† (i : fin 2), Œ± i) ‚âÉ·µê Œ± 0 √ó Œ± 1
(H : Type u_4) [add_group H] : Prop
{R : Type u_1} {Œπ‚ÇÅ : Type u_2} {Œπ‚ÇÇ : Type u_3} {Œπ‚ÇÉ : Type u_4} {Œπ‚ÇÑ : Type u_5} [comm_semiring R] [decidable_eq Œπ‚ÇÅ] [decidable_eq Œπ‚ÇÇ] [decidable_eq Œπ‚ÇÉ] [decidable_eq Œπ‚ÇÑ] {N‚ÇÅ : Type u_6} [add_comm_monoid N‚ÇÅ] [module R N‚ÇÅ] {N‚ÇÇ : Type u_7} [add_comm_monoid N‚ÇÇ] [module R N‚ÇÇ] {N : Type u_8} [add_comm_monoid N] [module R N] (a : multilinear_map R (Œª (_x : Œπ‚ÇÅ), N) N‚ÇÅ) (b : multilinear_map R (Œª (_x : Œπ‚ÇÇ), N) N‚ÇÇ) (œÉa : Œπ‚ÇÅ ‚âÉ Œπ‚ÇÉ) (œÉb : Œπ‚ÇÇ ‚âÉ Œπ‚ÇÑ) : multilinear_map.dom_dom_congr (œÉa.sum_congr œÉb) (a.dom_coprod b) = (multilinear_map.dom_dom_congr œÉa a).dom_coprod (multilinear_map.dom_dom_congr œÉb b)
(e : expr) : tactic (list expr)
(e : expr) : tactic (expr √ó expr)
(o : onote) [h : onote.NF o] : nonote
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] (x : E) (r : ‚Ñù) : set E
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x : Œ±} (h : s.nonempty) : x ‚àà closure s ‚Üî metric.inf_dist x s = 0
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b : Œ±} (ha : a ‚â§ 0) (hb : b ‚â§ 0) : a + b ‚â§ 0
{œÑ : Type u_1} {Œ± : Type u_2} [canonically_ordered_add_monoid œÑ] {œï : œÑ ‚Üí Œ± ‚Üí Œ±} {s : set Œ±} (h : is_fw_invariant œï s) : is_invariant œï s
(R : Type u) (X : Type v) [comm_ring R] : lie_ring (free_lie_algebra R X)
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddGroup) : category_theory.limits.cocone F
{M : Type u_1} [mul_one_class M] {s : set M} {S : submonoid M} : submonoid.closure s ‚â§ S ‚Üî s ‚äÜ ‚ÜëS
 : category_theory.Quiv ‚•§ category_theory.Cat
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] {X : C} (P : C·µí·µñ ‚•§ D) (S : J.cover X) [category_theory.limits.has_multiequalizer (S.index P)] : ‚Ü•(category_theory.limits.multiequalizer (S.index P)) ‚âÉ category_theory.meq P S
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ±) (a : Œ±) (s : wseq Œ≤) : wseq Œ±
(Œ± : Type u) : Type u
{n : ‚Ñï} {Œ± : typevec n} {Œ±' : typevec n} {Œ≤ : Type u_1} {Œ≤' : Type u_2} (f : Œ±.arrow Œ±') (g : Œ≤ ‚Üí Œ≤') : (Œ± ::: Œ≤).arrow (Œ±' ::: Œ≤')
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M ‚Üí* N} (h : ‚àÄ (y : ‚Ü•S), is_unit (‚áëf ‚Üëy)) {y : ‚Ü•S} {z : N} (H : ‚áëf ‚Üëy * z = 1) : ‚Üë(‚áë(is_unit.lift_right (f.restrict S) h) y)‚Åª¬π = z
{Œ± : Type u_1} [linear_order Œ±] {s : finset Œ±} {k : ‚Ñï} (h : s.card = k) (hz : 0 < k) : ‚áë(s.order_emb_of_fin h) ‚ü®k - 1, _‚ü© = s.max' _
(ns : interactive.parse (lean.parser.many lean.parser.ident)) : tactic unit
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), has_le (Œ± i)] (a b : Œ£ (i : Œπ), Œ± i) : Prop
(x : Set) : Set
{M : Type u} [monoid M] {a : MÀ£} {x y : M} (h : semiconj_by ‚Üëa x y) : semiconj_by ‚Üëa‚Åª¬π y x
(X : algebraic_geometry.LocallyRingedSpace) : algebraic_geometry.to_Spec_Œì (algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X)) ‚â´ X.to_Œì_Spec.val.c.app (opposite.op ‚ä§) = ùüô (algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X))
{M : Type u_1} [has_add M] {S T : add_subsemigroup M} (h : S = T) : ‚Ü•S ‚âÉ+ ‚Ü•T
{Œ± : Type u} {Œ≤ : Type v} {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} [partial_order Œ±] [preorder Œ≤] [order_bot Œ≤] (gi : galois_coinsertion l u) : order_bot Œ±
{H : Type u_1} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] {H' : Type u_3} {M' : Type u_4} [topological_space H'] [topological_space M'] [charted_space H' M'] (P : (H ‚Üí H') ‚Üí set H ‚Üí H ‚Üí Prop) (f : M ‚Üí M') : Prop
{Œ± : Sort u} {Œ≤ : Sort v} {f : Œ± ‚Üí Œ≤} (hf : function.surjective f) [unique Œ±] : unique Œ≤
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) [uniform_space Œ±] [uniform_space Œ≤] [uniform_space Œ≥] : (Œ± √ó Œ≤) √ó Œ≥ ‚âÉ·µ§ Œ± √ó Œ≤ √ó Œ≥
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : category_theory.limits.fork (Top.presheaf.sheaf_condition_equalizer_products.left_res F U) (Top.presheaf.sheaf_condition_equalizer_products.right_res F U)
(R : Type u) [comm_ring R] : Top.sheaf CommRing (algebraic_geometry.prime_spectrum.Top R)
{R : Type u_1} [normed_ring R] {r : ‚Ñù} (hr : 1 < r) : coe =o[filter.at_top] Œª (n : ‚Ñï), r ^ n
{Œ± : Type u_1} {Œ≤ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] {ŒΩ : measure_theory.measure Œ≤} [measure_theory.sigma_finite ŒΩ] {s : set (Œ± √ó Œ≤)} (hs : measurable_set s) : measurable (Œª (x : Œ±), ‚áëŒΩ (prod.mk x ‚Åª¬π' s))
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] : category_theory.limits.is_colimit (category_theory.limits.biprod.inr_cokernel_fork X Y)
(Œì‚ÇÄ Œì‚ÇÅ : Type) : Type 1
{Œ± : Type u} [pseudo_metric_space Œ±] {Œπ : Type u_1} {f‚ÇÅ f‚ÇÇ : Œπ ‚Üí Œ±} {p : filter Œπ} {a : Œ±} (h‚ÇÅ : filter.tendsto f‚ÇÅ p (nhds a)) (h : filter.tendsto (Œª (x : Œπ), has_dist.dist (f‚ÇÅ x) (f‚ÇÇ x)) p (nhds 0)) : filter.tendsto f‚ÇÇ p (nhds a)
{Œ± : Type u_1} (f : Œ± ‚Üí set Œ±) : ¬¨function.surjective f
{L : first_order.language} {Œ± : Type w} {n : ‚Ñï} [L.is_ordered] (t‚ÇÅ t‚ÇÇ : L.term (Œ± ‚äï fin n)) : L.bounded_formula Œ± n
{G : Type u_1} [group G] [h : group.is_nilpotent G] : is_solvable G
 : category_theory.full Compactum_to_CompHaus
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (h : r ‚âÉr s) : Œ≤ ‚Üí Œ±
(Œ± : Type u) [lattice Œ±] [decidable_eq Œ±] [decidable_rel has_le.le] [decidable_rel has_lt.lt] [is_total Œ± has_le.le] : linear_order Œ±
{E : Type u_1} {X : Type u_2} [inner_product_space ‚Ñù E] [normed_group X] [normed_space ‚Ñù X] {n : with_top ‚Ñï} {c g : X ‚Üí E} {f : Œ† (x : X), cont_diff_bump_of_inner (c x)} {x : X} (hc : cont_diff_at ‚Ñù n c x) (hr : cont_diff_at ‚Ñù n (Œª (x : X), (f x).r) x) (hR : cont_diff_at ‚Ñù n (Œª (x : X), (f x).R) x) (hg : cont_diff_at ‚Ñù n g x) : cont_diff_at ‚Ñù n (Œª (x : X), ‚áë(f x) (g x)) x
{Œ± : Type u_1} [linear_ordered_field Œ±] [archimedean Œ±] {x y : Œ±} (xpos : 0 < x) (hx : x ‚â§ 1) (ypos : 0 < y) (hy : y < 1) : ‚àÉ (n : ‚Ñï), y ^ (n + 1) < x ‚àß x ‚â§ y ^ n
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J ‚Üí C) [category_theory.limits.has_biproduct F] : category_theory.limits.limit_bicone F
{R : Type u} [ring R] (s : subring R) {l : list R} : (‚àÄ (x : R), x ‚àà l ‚Üí x ‚àà s) ‚Üí l.prod ‚àà s
{C : Type u} [category_theory.category C] {f g : category_theory.arrow C} (F : category_theory.limits.mono_factorisation f.hom) (sq : f ‚ü∂ g) [category_theory.is_iso sq] : category_theory.limits.mono_factorisation g.hom
 : category_theory.limits.walking_span.zero ‚ü∂ category_theory.limits.walking_span.right
{V : Type u} {G : simple_graph V} {u v : V} : G.walk u v ‚Üí ‚Ñï
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] {module_M : module R M} (p : submodule R M) (h : p = ‚ä§) : ‚Ü•p ‚âÉ‚Çó[R] M
(K : Type u_1) [is_R_or_C K] (E : Type u_2) [normed_group E] [normed_space K E] [finite_dimensional K E] : proper_space E
{J : Type u} [fintype J] (f : J ‚Üí AddCommGroup) : ‚®Å f ‚âÖ AddCommGroup.of (Œ† (j : J), ‚Ü•(f j))
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (p : polynomial S) : polynomial R
{Œπ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (c : complex_shape Œπ) [category_theory.limits.has_zero_object V] [category_theory.limits.has_kernels V] (i : Œπ) : homological_complex V c ‚•§ V
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_comm_monoid Œ±] [topological_space Œ±] (f : Œ≤ ‚Üí Œ±) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] [category_theory.limits.has_products A] [category_theory.limits.has_pullbacks C] (P : C·µí·µñ ‚•§ A) (s : A ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) [Œ† (J : Type (max v‚ÇÅ u‚ÇÅ)), category_theory.limits.preserves_limits_of_shape (category_theory.discrete J) s] (U : C) (R : category_theory.presieve U) : category_theory.limits.is_limit (s.map_cone (category_theory.limits.fork.of_Œπ (category_theory.presheaf.fork_map R P) _)) ‚âÉ category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ (category_theory.equalizer.fork_map (P ‚ãô s) R) _)
{Œπ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Œπ ‚Üí set X} (uo : ‚àÄ (i : Œπ), is_open (u i)) (uf : ‚àÄ (x : X), {i : Œπ | x ‚àà u i}.finite) (uU : (‚ãÉ (i : Œπ), u i) = set.univ) : ‚àÉ (v : Œπ ‚Üí set X), set.Union v = set.univ ‚àß (‚àÄ (i : Œπ), is_open (v i)) ‚àß ‚àÄ (i : Œπ), closure (v i) ‚äÜ u i
{Œ± : Type u} [pseudo_emetric_space Œ±] {s : set Œ±} {d : ennreal} (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí has_edist.edist x y ‚â§ d) : emetric.diam s ‚â§ d
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} (x : category_theory.presieve.family_of_elements P R) : category_theory.presieve.family_of_elements P ‚áë(category_theory.sieve.generate R)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (hash_fn : Œ± ‚Üí ‚Ñï) [decidable_eq Œ±] {n : ‚Ñï+} (bkts : bucket_array Œ± Œ≤ n) (sz : ‚Ñï) : Prop
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) (f : V ‚âÉ‚Çó·µ¢[‚Ñù] V) : (‚áë(orientation.map (fin 2) f.to_linear_equiv) o).oangle x y = o.oangle (‚áë(f.symm) x) (‚áë(f.symm) y)
 : ‚Ñ§ √ó ‚Ñ§ ‚âÉ ‚Ñ§ √ó ‚Ñ§
{C : Type u‚ÇÅ} [category_theory.category C] (F : C·µí·µñ ‚•§ Type v‚ÇÅ) [F.representable] : category_theory.yoneda.obj F.repr_X ‚âÖ F
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : free_ring Œ± ‚Üí+* free_ring Œ≤
{Œ± : Type u} {s : set (set Œ±)} : cardinal.mk ‚Ü•s ‚â§ cardinal.continuum ‚Üí cardinal.mk ‚Ü•{t : set Œ± | measurable_set t} ‚â§ cardinal.continuum
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (d : D) : (category_theory.structured_arrow d F)·µí·µñ ‚•§ category_theory.costructured_arrow F.op (opposite.op d)
{G : Type u_1} [add_group G] {G' : Type u_4} [add_group G'] (f : G ‚Üí+ G') (H : add_subgroup G) : ‚Ü•H ‚Üí+ ‚Ü•(add_subgroup.map f H)
{Œ± : Type u_7} {Œ≤ : Type u_8} [measurable_space Œ±] [measurable_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K‚ÇÅ K‚ÇÇ : J ‚•§ C} (F : C ‚•§ D) (h : K‚ÇÅ ‚âÖ K‚ÇÇ) [category_theory.limits.reflects_limit K‚ÇÅ F] : category_theory.limits.reflects_limit K‚ÇÇ F
(f : format) : format
{G : Type u_3} [add_group G] (self : add_subgroup G) : add_submonoid G
{Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} (h : is_open s) : is_GŒ¥ s
(M : Type u_1) [mul_one_class M] : galois_insertion submonoid.closure coe
(G : Type w) [comm_group G] : G ‚âÉ* (multiplicative ‚Ñ§ ‚Üí* G)
{F : Type u ‚Üí Type u} [functor F] [q : qpf F] : (qpf.P F).M ‚Üí (qpf.P F).M ‚Üí Prop
{Œ± : Type u_1} (s : set Œ±) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{C : Type u} [category_theory.category C] [‚àÄ (n : ‚Ñï) (f : category_theory.arrow C), category_theory.limits.has_wide_pushout f.left (Œª (i : ulift (fin (n + 1))), f.right) (Œª (i : ulift (fin (n + 1))), f.hom)] : category_theory.arrow C ‚•§ category_theory.cosimplicial_object.augmented C
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (K : set (E ‚ÜíL[ùïú] F)) : set E
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [h : lie_algebra.is_simple R L] : lie_algebra.is_semisimple R L
 : ‚Ñï ‚Üí tactic unit ‚Üí tactic unit
{G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) (K : subgroup N) : subgroup (G √ó N)
(C : Type u‚ÇÅ) [category_theory.category C] : Prop
{R : Type u} {M‚ÇÇ : Type v‚ÇÇ} {M' : Type v'} [semiring R] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M'] [module R M‚ÇÇ] [module R M'] {k n : ‚Ñï} (f : multilinear_map R (Œª (i : fin n), M') M‚ÇÇ) (s : finset (fin n)) (hk : s.card = k) (z : M') : multilinear_map R (Œª (i : fin k), M') M‚ÇÇ
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_initial C] : 0 ‚âÖ ‚ä•_ C
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] : category_theory.limits.preserves_binary_biproducts F
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s t : set P} (ha : affine_independent k (Œª (x : ‚Ü•t), ‚Üëx)) (hs : s ‚äÜ t) : affine_independent k (Œª (x : ‚Ü•s), ‚Üëx)
{X : Top} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : category_theory.sieve.generate (Top.presheaf.presieve_of_covering U) ‚àà ‚áë(opens.grothendieck_topology ‚Ü•X) (supr U)
(R : Type u_1) [ring R] {n : ‚Ñï} (m : ‚Ñï) [char_p R m] (h : m ‚à£ n) : algebra (zmod n) R
{Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚Üí Œ≤} {b : Œ≤} {l : list Œ±} : b ‚àà list.map f l ‚Üí (‚àÉ (a : Œ±), a ‚àà l ‚àß f a = b)
{Œ± : Type u_1} {Œπ : Type u_3} [complete_lattice Œ±] [fintype Œπ] {f : Œπ ‚Üí Œ±} : complete_lattice.independent f ‚Üî finset.univ.sup_indep f
{M : Type u_1} [has_add M] : complete_lattice (add_subsemigroup M)
{M : Type u_1} [add_zero_class M] {N : Type u_2} [add_zero_class N] (f : M ‚Üí+ N) : M ‚Üí+ ‚Ü•(f.mrange)
{R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b) : is_add_right_regular (a + b)
{R : Type u} [comm_ring R] : is_localization (submonoid.powers power_series.X) (laurent_series R)
{Œπ : Type u_1} [fintype Œπ] (H : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), topological_space (H i)] (M : Œπ ‚Üí Type u_3) [Œ† (i : Œπ), topological_space (M i)] [Œ† (i : Œπ), charted_space (H i) (M i)] : charted_space (model_pi H) (Œ† (i : Œπ), M i)
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [group G] [semiring k] : distrib_mul_action G (monoid_algebra k G)
 : linter
(D : Type u_1) [category_theory.category D] [category_theory.abelian D] : category_theory.is_idempotent_complete D
{Œ± : Type u_1} (S : set (set Œ±)) : set (set Œ±)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} (f : C ‚ü∂ D) : homotopy f f
{m : Type u ‚Üí Type u} [monad m] [alternative m] {Œ± Œ≤ : Type u} (L : tactic.mllist m Œ±) (f : Œ± ‚Üí m Œ≤) : m Œ≤
{Œ± : Type u_1} (R : Œ± ‚Üí Œ± ‚Üí Prop) [decidable_rel R] : list Œ± ‚Üí list Œ±
(p : ‚Ñï) [hp : fact (nat.prime p)] {k : Type u_1} [field k] [is_alg_closed k] (a‚ÇÅ a‚ÇÇ : witt_vector p k) : k
{Œπ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (c : complex_shape Œπ) [category_theory.limits.has_zero_object V] [category_theory.limits.has_equalizers V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] [category_theory.limits.has_cokernels V] : homological_complex V c ‚•§ category_theory.graded_object Œπ V
{Œπ : Type u_2} [encodable Œπ] {F : Œπ ‚Üí Type u_3} [Œ† (i : Œπ), metric_space (F i)] : metric_space (Œ† (i : Œπ), F i)
(ps : list pexpr) (depth : ‚Ñï) : tactic (tactic.list_Pi tactic.rcases_patt)
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ : X} (p : path x‚ÇÄ x‚ÇÅ) : fundamental_group X x‚ÇÄ ‚âÉ* fundamental_group X x‚ÇÅ
{G : Type u_1} [add_group G] {k : set G} (hcomm : ‚àÄ (x : G), x ‚àà k ‚Üí ‚àÄ (y : G), y ‚àà k ‚Üí x + y = y + x) : add_comm_group ‚Ü•(add_subgroup.closure k)
(en : expr) (n : ‚Ñï) : tactic expr
{A B : CommRing} (f g : A ‚ü∂ B) : category_theory.limits.fork f g
{C : Type u} [category_theory.category C] [‚àÄ (n : ‚Ñï) (f : category_theory.arrow C), category_theory.limits.has_wide_pullback f.right (Œª (i : ulift (fin (n + 1))), f.left) (Œª (i : ulift (fin (n + 1))), f.hom)] (X : category_theory.simplicial_object.augmented C) (F : category_theory.arrow C) : (category_theory.simplicial_object.augmented.to_arrow.obj X ‚ü∂ F) ‚âÉ (X ‚ü∂ F.augmented_cech_nerve)
{Œ± : Type u_1} [uniform_space Œ±] {K U : set Œ±} (hK : is_compact K) (hU : is_open U) (hKU : K ‚äÜ U) : ‚àÉ (V : set (Œ± √ó Œ±)) (H : V ‚àà uniformity Œ±), is_open V ‚àß ‚àÄ (x : Œ±), x ‚àà K ‚Üí uniform_space.ball x V ‚äÜ U
(c : ‚Ñù) (f : ‚Ñï ‚Üí bool) (n : ‚Ñï) : ‚Ñù
 : Type (u+1)
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : subalgebra K L) (inv_mem : ‚àÄ (x : L), x ‚àà S ‚Üí x‚Åª¬π ‚àà S) : intermediate_field K L
{m n : ‚Ñï} : fin m √ó fin n ‚âÉ fin (m * n)
{Œ± : Type u_1} : has_mul (language Œ±)
{Œ± : Type u_2} [group Œ±] {s t : set Œ±} : disjoint s t ‚Üí 1 ‚àâ s / t
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {p : formal_multilinear_series ùïú E F} {x : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) : continuous_on f (emetric.ball x r)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.subobject X ‚•§ category_theory.subobject Y
(l : interactive.parse interactive.types.pexpr_list_or_texpr) : smt_tactic unit
{n : ‚Ñï} (p : fin (n + 1)) (i : fin n) (h : p ‚â§ ‚áëfin.cast_succ i) : ‚áë(p.succ_above) i = i.succ
{R : Type u} [comm_ring R] [is_domain R] (p : polynomial R) : multiset R
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [uniform_space Œ≤] [(uniformity Œ≤).is_countably_generated] (f : Œ± ‚Üí Œ≤) : is_GŒ¥ {x : Œ± | continuous_at f x}
(M : Type u_2) (R : Type u_5) [semiring R] [add_comm_monoid M] [module R M] (X : Type u_7) : (X ‚Üí M) ‚âÉ+ ((X ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] M)
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} {v : V} {p : Œπ ‚Üí P} : v ‚àà vector_span k (set.range p) ‚Üî ‚àÉ (s : finset Œπ) (w : Œπ ‚Üí k) (h : s.sum (Œª (i : Œπ), w i) = 0), v = ‚áë(s.weighted_vsub p) w
 : environment ‚Üí name ‚Üí list name
{Œ± : Type u_1} {Œ≤ : Type u_2} {l : filter Œ±} {f : Œ± ‚Üí Œ≤} {lb : filter Œ≤} : filter.tendsto f l lb ‚Üí ‚Üëf.tendsto lb
(k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} {p0 : P} {s : set Œπ} {p : Œπ ‚Üí P} : (‚àÉ (fs : finset Œπ) (hfs : ‚Üëfs ‚äÜ s) (w : Œπ ‚Üí k) (hw : fs.sum (Œª (i : Œπ), w i) = 1), p0 = ‚áë(fs.affine_combination p) w) ‚Üî ‚àÉ (fs : finset ‚Ü•s) (w : ‚Ü•s ‚Üí k) (hw : fs.sum (Œª (i : ‚Ü•s), w i) = 1), p0 = ‚áë(fs.affine_combination (Œª (i : ‚Ü•s), p ‚Üëi)) w
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ x‚ÇÇ x‚ÇÉ : X} (p : path x‚ÇÄ x‚ÇÅ) (q : path x‚ÇÅ x‚ÇÇ) (r : path x‚ÇÇ x‚ÇÉ) : ((p.trans q).trans r).homotopy (p.trans (q.trans r))
{a : ennreal} : add_le_cancellable a ‚Üî a ‚â† ‚ä§
{R : Type u} [comm_ring R] [is_domain R] {p q : polynomial R} (a : R) (hzero : p + q ‚â† 0) : linear_order.min (polynomial.root_multiplicity a p) (polynomial.root_multiplicity a q) ‚â§ polynomial.root_multiplicity a (p + q)
{M : Type uM} {N : Type uN} {P : Type uP} {Q : Type uQ} [add_zero_class M] [add_zero_class N] [add_comm_monoid P] [add_comm_monoid Q] (f : M ‚Üí+ N ‚Üí+ P) (g : P ‚Üí+ Q) : M ‚Üí+ N ‚Üí+ Q
{E : Type u_2} [normed_group E] [normed_space ‚Ñù E] [strict_convex_space ‚Ñù E] {x y z : E} : has_dist.dist x y + has_dist.dist y z = has_dist.dist x z ‚Üî y ‚àà segment ‚Ñù x z
{ùïú : Type u_1} {E : Type u_2} [normed_linear_ordered_field ùïú] [normed_group E] [normed_space ùïú E] {A : set E} {x : E} : x ‚àà set.exposed_points ùïú A ‚Üî is_exposed ùïú A {x}
{ùïú : Type u_3} [field ùïú] {r : ‚Ñï} (IH : ‚àÄ (M : matrix (fin r) (fin r) ùïú), ‚àÉ (L‚ÇÄ L‚ÇÄ' : list (matrix.transvection_struct (fin r) ùïú)) (D‚ÇÄ : fin r ‚Üí ùïú), ((list.map matrix.transvection_struct.to_matrix L‚ÇÄ).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L‚ÇÄ').prod = matrix.diagonal D‚ÇÄ) (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) : ‚àÉ (L L' : list (matrix.transvection_struct (fin r ‚äï unit) ùïú)) (D : fin r ‚äï unit ‚Üí ùïú), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {L‚ÇÅ L‚ÇÇ : C ‚•§ D} {R‚ÇÅ R‚ÇÇ : D ‚•§ C} (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) : (L‚ÇÇ ‚ü∂ L‚ÇÅ) ‚âÉ (R‚ÇÅ ‚ü∂ R‚ÇÇ)
{Œ± : Type u_1} [ring Œ±] (C : ring.total_positive_cone Œ±) : linear_ordered_ring Œ±
{C : Type u} [category_theory.category C] {X : C} (h : category_theory.limits.is_zero X) (Y : C) : Y ‚ü∂ X
(Œ± : Type u_1) [order.frame Œ±] : Frame
(t : tactic unit) : tactic unit
(f : cau_seq ‚ÑÇ complex.abs) : ‚ÑÇ
{Œ± : Type u_1} (t : topological_space Œ±) (c : uniform_space.core Œ±) (is_open_uniformity : ‚àÄ (s : set Œ±), t.is_open s ‚Üî ‚àÄ (x : Œ±), x ‚àà s ‚Üí {p : Œ± √ó Œ± | p.fst = x ‚Üí p.snd ‚àà s} ‚àà c.uniformity) : uniform_space Œ±
(new_lhs : expr) : conv unit
{Œ± : Type u_1} [preorder Œ±] [has_add Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b : Œ±} : a + b - b ‚â§ a
(Œ± : Type u_1) [finite Œ±] : Œ± ‚âÉ fin (nat.card Œ±)
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ : X} {p‚ÇÄ p‚ÇÅ : path x‚ÇÄ x‚ÇÅ} (F : p‚ÇÄ.homotopy p‚ÇÅ) (t : ‚Ü•unit_interval) : path x‚ÇÄ x‚ÇÅ
 : linarith.comp_source ‚Üí string
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] {S T : intermediate_field F E} (h : S = T) : ‚Ü•S ‚âÉ‚Çê[F] ‚Ü•T
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_products C] : (category_theory.prod_comonad X).coalgebra ‚âå category_theory.over X
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {f : ‚ÑÇ ‚Üí E} (h : differentiable ‚ÑÇ f) (z : ‚ÑÇ) {R : nnreal} (hR : 0 < R) : has_fpower_series_on_ball f (cauchy_power_series f z ‚ÜëR) z ‚ä§
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : r ‚âÉr s) : r ‚Ü™r s
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [has_le Œ≤] {f g : Œ± ‚Üí Œ≤} {a : Œ±} (h : f ‚â§·∂†[nhds a] g) : ‚àÄ·∂† (y : Œ±) in nhds a, f ‚â§·∂†[nhds y] g
{Œ± : Type u} [metric_space Œ±] {x y : topological_space.nonempty_compacts Œ±} : has_dist.dist x y = metric.Hausdorff_dist ‚Üëx ‚Üëy
{M : Type u_1} [comm_monoid_with_zero M] (S : submonoid M) : localization S
{G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) (K : subgroup N) : ‚Ü•(H.prod K) ‚âÉ* ‚Ü•H √ó ‚Ü•K
 : ‚Ü•(number_field.ring_of_integers ‚Ñö) ‚âÉ+* ‚Ñ§
(ids : interactive.parse (lean.parser.many lean.parser.ident)) : tactic unit
{Œ± : Sort u} {f : Œ± ‚Üí Œ±} (h : function.involutive f) (P : Prop) [decidable P] (x : Œ±) : f (ite P x (f x)) = ite (¬¨P) x (f x)
{Œ± : Type u_1} : list (lazy_list Œ±) ‚Üí lazy_list Œ±
{Œπ : Type u_1} {M : Type u_3} [semiring M] (f : add_monoid_algebra M Œπ) : direct_sum Œπ (Œª (i : Œπ), M)
 : Set ‚Üí Set ‚Üí Prop
{E : Type u_1} [add_comm_group E] [star_add_monoid E] [module ‚ÑÇ E] [star_module ‚ÑÇ E] : E ‚Üí‚Çó[‚Ñù] ‚Ü•(self_adjoint E)
{C : Type u} [category_theory.category C] [‚àÄ (n : ‚Ñï) (f : category_theory.arrow C), category_theory.limits.has_wide_pullback f.right (Œª (i : ulift (fin (n + 1))), f.left) (Œª (i : ulift (fin (n + 1))), f.hom)] (X : category_theory.simplicial_object.augmented C) (F : category_theory.arrow C) (G : X ‚ü∂ F.augmented_cech_nerve) : category_theory.simplicial_object.augmented.to_arrow.obj X ‚ü∂ F
{R : Type u} [comm_semigroup R] [star_semigroup R] : mul_aut R
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {mŒ± : measurable_space Œ±} [measurable_space Œ≤] [topological_space Œ≤] [topological_space.pseudo_metrizable_space Œ≤] [topological_space.second_countable_topology Œ≤] [opens_measurable_space Œ≤] (hf : measurable f) : measure_theory.strongly_measurable f
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] (a b : Œ±) : finset Œ±
{n : ‚Ñï} (Œ± : typevec n) (Œ≤ : typevec n) : Type (max u_1 u_2)
{ùïú : Type u_1} {E : Type u_4} [normed_group E] [nondiscrete_normed_field ùïú] [normed_space ùïú E] : normed_ring (E ‚ÜíL[ùïú] E)
 : lean.parser (option pexpr)
{Œ± : Type u_1} [i : topological_space Œ±] (u : uniform_space Œ±) (h : i = uniform_space.to_topological_space) : uniform_space Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.cartesian_closed C] : category_theory.exponential_ideal (ùü≠ C)
(R : Type u_1) [comm_semiring R] (M : Type u_4) (P : Type u_6) (Q : Type u_7) [add_comm_monoid M] [add_comm_monoid P] [add_comm_monoid Q] [module R M] [module R P] [module R Q] : tensor_product R P (M ‚Üí‚Çó[R] Q) ‚Üí‚Çó[R] M ‚Üí‚Çó[R] tensor_product R P Q
{V : Type u} (G : simple_graph V) (s : set (sym2 V)) : simple_graph V
{Œπ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape Œπ) : homological_complex V c ‚•§ homotopy_category V c
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Type (max v u)) : category_theory.limits.is_limit (category_theory.limits.types.limit_cone F)
{R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X
(m : Type u_2) (n : Type u_3) (o : Type u_4) (Œ± : Type u_12) [decidable_eq o] [add_zero_class Œ±] : (o ‚Üí matrix m n Œ±) ‚Üí+ matrix (m √ó o) (n √ó o) Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (F : C ‚•§ D) [category_theory.limits.has_limits_of_shape J D] [category_theory.creates_limits_of_shape J F] : category_theory.limits.has_limits_of_shape J C
(Œ± : Type u_1) [complete_semilattice_Sup Œ±] : complete_lattice Œ±
(M : Type u_1) [measurable_space M] [has_mul M] : Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} : cont_diff ùïú n prod.snd
 : expr ‚Üí expr ‚Üí tactic expr
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] (x : E) : ‚áë(reflection K) x = x ‚Üî x ‚àà K
{Œ± : Type} (m : tactic.instance_cache ‚Üí tactic (tactic.instance_cache √ó Œ±)) : tactic.norm_fin.eval_fin_m Œ±
(C : Type u) [category_theory.category C] : Prop
{n n' m : ‚Ñï} (i : fin n') (h : n' = n) : ‚áë(fin.add_nat m) (‚áë(fin.cast h) i) = ‚áë(fin.cast _) (‚áë(fin.add_nat m) i)
(x : ‚Ñù) : 0 ‚â§ exp_neg_inv_glue x
{Œ± : Type u_1} [canonically_linear_ordered_add_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b c : Œ±} [contravariant_class Œ± Œ± has_add.add has_le.le] (h : b ‚â§ a) : a - b < a - c ‚Üî c < b
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (S T : submodule R M) (h : S ‚â§ T) : ((M ‚ß∏ S) ‚ß∏ submodule.map S.mkq T) ‚âÉ‚Çó[R] M ‚ß∏ T
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_limits C] : category_theory.limits.has_colimits C·µí·µñ
(C : Type u) [quiver C] : category_theory.Quiv
{M : Type u_1} [has_mul M] {p : M ‚Üí Prop} (x : M) {s : set M} (hs : subsemigroup.closure s = ‚ä§) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí p x) (Hmul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x * y)) : p x
{G : Type u_1} [group G] : has_bracket (subgroup G) (subgroup G)
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f1 f2 : Œ± ‚Üí‚ÇÄ M} (hd : disjoint f1.support f2.support) {Œ≤ : Type u_2} [comm_monoid Œ≤] (g : Œ± ‚Üí M ‚Üí Œ≤) : (f1 + f2).prod g = f1.prod g * f2.prod g
(u : tactic.rewrite_search.proof_unit) (rs : list (expr √ó bool)) (explain_using_conv : bool) : tactic string
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} (r : mvqpf.cofix F Œ± ‚Üí mvqpf.cofix F Œ± ‚Üí Prop) (h : ‚àÄ (x y : mvqpf.cofix F Œ±), r x y ‚Üí mvfunctor.map (typevec.id ::: quot.mk r) x.dest = mvfunctor.map (typevec.id ::: quot.mk r) y.dest) (x y : mvqpf.cofix F Œ±) : r x y ‚Üí x = y
{R : Type u_1} {S : Type u_2} [semiring R] [linear_ordered_ring S] (abv : absolute_value R S) [nontrivial R] : R ‚Üí* S
{M : Type u_1} [add_zero_class M] {S T : add_submonoid M} (h : S = T) : ‚Ü•S ‚âÉ+ ‚Ü•T
(x : prime_spectrum punit) : false
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] : has_coe_to_fun (M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (Œª (_x : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ), M‚ÇÅ ‚Üí M‚ÇÇ)
{G : Type u_1} [group G] [fintype G] (p : ‚Ñï) [hp : fact (nat.prime p)] (hdvd : p ‚à£ fintype.card G) : ‚àÉ (x : G), order_of x = p
{ùïú : Type u_1} {E : Type u_4} {F‚Çó : Type u_7} [normed_group E] [normed_group F‚Çó] [nondiscrete_normed_field ùïú] [normed_space ùïú E] [normed_space ùïú F‚Çó] (f : E ‚ÜíL[ùïú] F‚Çó) (hf : uniform_embedding ‚áëf) : ‚àÉ (K : nnreal), antilipschitz_with K ‚áëf
{Œ± : Type u} (s : set Œ±) : cardinal.mk (‚Ü•ùí´s) = 2 ^ cardinal.mk ‚Ü•s
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [module ùïú E] [module ùïú Œ≤] [linear_order E] {s : set E} {f : E ‚Üí Œ≤} (hs : convex ùïú s) (hf : ‚àÄ ‚¶Éx y : E‚¶Ñ, x ‚àà s ‚Üí y ‚àà s ‚Üí x < y ‚Üí ‚àÄ ‚¶Éa b : ùïú‚¶Ñ, 0 < a ‚Üí 0 < b ‚Üí a + b = 1 ‚Üí f (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ a ‚Ä¢ f x + b ‚Ä¢ f y) : convex_on ùïú s f
{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] : even (finset.filter (Œª (v : V), odd (G.degree v)) finset.univ).card
(F : Type u_1) (Œ± : out_param (Type u_2)) (Œ≤ : out_param (Type u_3)) [topological_space Œ±] [topological_space Œ≤] : Type (max u_1 u_2 u_3)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (e : local_homeomorph Œ± Œ≤) {f : Œ≤ ‚Üí Œ≥} {x : Œ≤} (h : x ‚àà e.to_local_equiv.target) : continuous_at f x ‚Üî continuous_at (f ‚àò ‚áëe) (‚áë(e.symm) x)
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {t : category_theory.limits.fork f g} (hs : ‚àÄ (s : category_theory.limits.fork f g), ‚àÉ! (l : s.X ‚ü∂ t.X), l ‚â´ t.Œπ = s.Œπ) : category_theory.limits.is_limit t
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) [complete_space E] [complete_space ‚Ü•K] : continuous_linear_map.id ùïú E = K.subtypeL.comp (orthogonal_projection K) + K·óÆ.subtypeL.comp (orthogonal_projection K·óÆ)
{Œ± : Type u_2} [semigroup Œ±] : semigroup (set Œ±)
{G : Type u_1} [add_group G] {G' : Type u_2} [add_group G'] (e : G ‚âÉ+ G') (H : add_subgroup G) : ‚Ü•H ‚âÉ+ ‚Ü•(add_subgroup.map e.to_add_monoid_hom H)
{M : Type u_1} [add_comm_monoid M] (f s : ‚Ñï ‚Üí M) (h0 : s 0 = 0) (h : ‚àÄ (n : ‚Ñï), s (n + 1) = s n + f n) (n : ‚Ñï) : (finset.range n).sum (Œª (k : ‚Ñï), f k) = s n
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} {Œπ‚ÇÇ : Type u_5} (s‚ÇÇ : finset Œπ‚ÇÇ) (e : Œπ‚ÇÇ ‚Ü™ Œπ) (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) : ‚áë((finset.map e s‚ÇÇ).weighted_vsub p) w = ‚áë(s‚ÇÇ.weighted_vsub (p ‚àò ‚áëe)) (w ‚àò ‚áëe)
(Œ± : Type u) (Œ≤ : Type v) [group Œ±] [mul_action Œ± Œ≤] : setoid Œ≤
(s : string) : name
{R : Type u} [comm_ring R] {G H : Module R} (f : G ‚ü∂ H) : Module.image f ‚ü∂ H
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] : algebraic_geometry.SheafedSpace CommRing
{Œ± : Type u_1} {n : ‚Ñï} (a : Œ±) (v : vector3 Œ± n) (i : fin2 n.succ) : vector3 Œ± n.succ
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.initial] {E : Type u} [category_theory.category E] {G : D ‚•§ E} [category_theory.limits.has_limit (F ‚ãô G)] : category_theory.limits.limit (F ‚ãô G) ‚âÖ category_theory.limits.limit G
{Œ± : Type} (tac : tactic Œ±) : tactic Œ±
(tde : tactic_doc_entry) : tactic unit
(C : Type u) [category_theory.groupoid C] : category_theory.Groupoid
{E : Type u_3} [semi_normed_group E] : uniform_add_group E
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type u_1} [is_empty Œπ] (hV : module.rank K V = 0) : basis Œπ K V
 : enat ‚âÉ with_top ‚Ñï
{Œ± : Type} (F : parser Œ± ‚Üí parser Œ±) : parser Œ±
{X : Type u_1} [topological_space X] (S : discrete_quotient X) : X ‚Üí ‚Ü•S
(p : ‚Ñï) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] : fraction_ring (witt_vector p k) ‚âÉ+* fraction_ring (witt_vector p k)
{R : Type u} [comm_ring R] [is_domain R] (n : ‚Ñï) (a : R) : multiset R
{a b : ‚Ñï} : a ‚ãñ b ‚Üí ‚Üëa ‚ãñ ‚Üëb
{R : Type u} [ring R] {M : Module R} {Œπ : Type u_1} (b : basis Œπ R ‚Ü•M) : category_theory.projective M
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {Œ± : Type u_4} (f : M ‚Üí‚Çó[R] Œ± ‚Üí‚ÇÄ R) (s : function.surjective ‚áëf) : (Œ± ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] M
{Œ± : Type u} [has_repr Œ±] : free_add_magma Œ± ‚Üí string
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b c : Œ±} : a + b < c ‚Üí a < c - b
(n : ‚Ñï) : ‚Ñï
{Œ± : Type u_2} [has_one Œ±] : has_one (filter Œ±)
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] [Œ† (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)·µí·µñ (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] (P : category_theory.Sheaf J D) : P ‚âÖ (category_theory.presheaf_to_Sheaf J D).obj P.val
{K : Type u_1} [field K] {t : ‚Ñï} (not_dvd : ¬¨ring_char K ‚à£ t) : invertible ‚Üët
(p : Prop) : Type
{Œ± : Type u_2} {Œ≤ : Type u_3} [monoid Œ±] [mul_action Œ± Œ≤] : mul_action Œ± (filter Œ≤)
{C : Type u‚ÇÅ} [category_theory.category C] (G : category_theory.comonad C) : C ‚•§ C
(R : Type u) [add_monoid R] [has_one R] (p : ‚Ñï) : Prop
(K : Type u_1) {V : Type u_2} [field K] [add_comm_group V] [module K V] (v : {v // v ‚â† 0}) : ‚Ñô K V
{ùïú : Type u} {Œπ : Type v} {G : Type wG} {G' : Type wG'} [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] {ùïú' : Type u_1} [normed_field ùïú'] [normed_space ùïú' G] [smul_comm_class ùïú ùïú' G] : normed_space ùïú' (continuous_multilinear_map ùïú (Œª (i : Œπ), G') G)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] {E : Type u‚ÇÉ} [category_theory.category E] [category_theory.monoidal_category E] (F : category_theory.monoidal_functor C D) (G : category_theory.monoidal_functor D E) : category_theory.monoidal_functor C E
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f‚ÇÇ : ùïú ‚Üí F} {s‚ÇÇ : set ùïú} {n : ‚Ñï} (hs : is_open s‚ÇÇ) : cont_diff_on ùïú ‚Üë(n + 1) f‚ÇÇ s‚ÇÇ ‚Üî differentiable_on ùïú f‚ÇÇ s‚ÇÇ ‚àß cont_diff_on ùïú ‚Üën (deriv f‚ÇÇ) s‚ÇÇ
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (Œπ : Type u_1) [unique Œπ] (h : finite_dimensional.finrank K V = 1) (v : V) (hv : v ‚â† 0) : basis Œπ K V
(Œ± : Sort u_1) : (pempty ‚Üí Œ±) ‚âÉ punit
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (F : C ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.reflects_colimit (category_theory.limits.span f f) F] [category_theory.epi (F.map f)] : category_theory.epi f
{Œ± : Sort u_1} {p : Œ± ‚Üí Prop} (h : ‚àÉ (a : Œ±), p a) {C : Sort u} (H : Œ† (a : Œ±), p a ‚Üí C) : C
{R : Type u_1} {M : Type u_2} {N : Type u_3} [comm_semiring R] [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : tensor_product R (module.End R M) (module.End R N) ‚Üí‚Çê[R] module.End R (tensor_product R M N)
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ≤] {m0 : measurable_space Œ±} (f : Œ± ‚Üí Œ≤) (Œºa : measure_theory.measure Œ± . "volume_tac") (Œºb : measure_theory.measure Œ≤ . "volume_tac") : Prop
 : bool ‚Üí bool ‚Üí bool
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C·µí·µñ} (c : category_theory.limits.cocone F) : category_theory.limits.cone F.left_op
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} (hs : is_open s) : cont_diff_on ùïú ‚ä§ f s ‚Üî differentiable_on ùïú f s ‚àß cont_diff_on ùïú ‚ä§ (Œª (y : E), fderiv ùïú f y) s
{C : Type u} [category_theory.category C] [category_theory.concrete_category C] {X : Top} (F : Top.presheaf C X) : Prop
 : declaration ‚Üí tactic (list string)
(v w : ‚Ñï ‚Üí ‚Ñï) (t : omega.nat.preterm) : (‚àÄ (x : ‚Ñï), x < t.fresh_index ‚Üí v x = w x) ‚Üí omega.nat.preterm.val v t = omega.nat.preterm.val w t
{Œ± : Type u} [pseudo_metric_space Œ±] (x y : Œ±) : has_dist.dist x y = (has_edist.edist x y).to_real
(L : first_order.language) {M : Type w} [nonempty M] [L.Structure M] (s : set M) (Œ∫ : cardinal) (h1 : cardinal.aleph_0 ‚â§ Œ∫) (h2 : (cardinal.mk ‚Ü•s).lift ‚â§ Œ∫.lift) (h3 : L.card.lift ‚â§ Œ∫.lift) (h4 : Œ∫.lift ‚â§ (cardinal.mk M).lift) : ‚àÉ (S : L.elementary_substructure M), s ‚äÜ ‚ÜëS ‚àß (cardinal.mk ‚Ü•S).lift = Œ∫.lift
{Œ± : Type u} {n : ‚Ñï} (v : fin n.succ ‚Üí Œ±) : fin n ‚Üí Œ±
{S : set ordinal} (f : ordinal ‚Üí ordinal) (hS : set.unbounded has_lt.lt S) : strict_mono f ‚àß set.range f = S ‚Üî f = ordinal.enum_ord S
{Œ± : Type u} [monoid Œ±] : conj_classes Œ± ‚Üí set Œ±
(A : Type u_4) [comm_ring A] [is_domain A] [unique_factorization_monoid A] {K : Type u_5} [field K] [algebra A K] [is_fraction_ring A K] (x : K) : A
{Œ± : Type u_2} {Œ≤ : Type u_3} (f : Œ± ‚Üí Œ≤) : complete_lattice_hom (set Œ≤) (set Œ±)
(ee : list omega.ee) (c : omega.clause) : (omega.eq_elim ee c).unsat ‚Üí c.unsat
{G : Type u_1} [add_group G] {N : Type u_2} [add_group N] (f : G ‚Üí+ N) (hf : function.surjective ‚áëf) : f.range = ‚ä§
{C : Type u} [category_theory.category C] : category_theory.simplicial_object.augmented C ‚•§ category_theory.simplicial_object C
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.shift_functor C i ‚ãô category_theory.shift_functor C (-i) ‚âÖ ùü≠ C
{Œ± : Type u_1} [measurable_space Œ±] {M : Type u_3} [add_comm_monoid M] [topological_space M] (v : measure_theory.vector_measure Œ± M) (i : set Œ±) : measure_theory.vector_measure Œ± M
(k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p : P) : ‚Üë(affine_span k {p}) = {p}
{n : ‚Ñï} (a : composition n) (b : composition a.length) {i j : ‚Ñï} (hi : i < b.length) (hj : j < b.blocks_fun ‚ü®i, hi‚ü©) : a.size_up_to (b.size_up_to i + j) = (a.gather b).size_up_to i + (a.sigma_composition_aux b ‚ü®i, _‚ü©).size_up_to j
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {a‚ÇÅ a‚ÇÇ a‚ÇÉ : X} {b‚ÇÅ b‚ÇÇ b‚ÇÉ : Y} (Œ≥‚ÇÅ : path a‚ÇÅ a‚ÇÇ) (Œ¥‚ÇÅ : path a‚ÇÇ a‚ÇÉ) (Œ≥‚ÇÇ : path b‚ÇÅ b‚ÇÇ) (Œ¥‚ÇÇ : path b‚ÇÇ b‚ÇÉ) : (Œ≥‚ÇÅ.prod Œ≥‚ÇÇ).trans (Œ¥‚ÇÅ.prod Œ¥‚ÇÇ) = (Œ≥‚ÇÅ.trans Œ¥‚ÇÅ).prod (Œ≥‚ÇÇ.trans Œ¥‚ÇÇ)
{C : Type u} {A : Type u_1} [category_theory.category C] {D : Type u_2} [category_theory.category D] [add_monoid A] [category_theory.has_shift D A] (F : C ‚•§ D) [category_theory.full F] [category_theory.faithful F] (s : A ‚Üí C ‚•§ C) (i : Œ† (i : A), s i ‚ãô F ‚âÖ F ‚ãô category_theory.shift_functor D i) : category_theory.has_shift C A
 : turing.to_partrec.cont ‚Üí turing.partrec_to_TM2.cont'
(Œ± : Type u_1) [non_assoc_semiring Œ±] : ‚Ñï ‚Üí+* Œ±
(R : Type u_1) [has_mul R] [has_add R] : ring_aut R ‚Üí* mul_aut R
 : environment ‚Üí name ‚Üí environment
(X : algebraic_geometry.RingedSpace) (U : topological_space.opens ‚Ü•X) (f : ‚Ü•(X.to_PresheafedSpace.presheaf.obj (opposite.op U))) (h : ‚àÄ (x : ‚Ü•U), is_unit (‚áë(X.to_PresheafedSpace.presheaf.germ x) f)) : is_unit f
{R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) ‚àß is_regular (b * a) ‚Üî is_regular a ‚àß is_regular b
{p : ‚Ñï ‚Üí Prop} : nat.upto p
{Œ± : Type u} {Œ≤ : Type v} [uniform_space Œ±] [semilattice_sup Œ≤] {K : set Œ±} (h‚ÇÅ : is_complete K) {u : Œ≤ ‚Üí Œ±} (h‚ÇÇ : ‚àÄ (n : Œ≤), u n ‚àà K) (h‚ÇÉ : cauchy_seq u) : ‚àÉ (v : Œ±) (H : v ‚àà K), filter.tendsto u filter.at_top (nhds v)
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.final] {E : Type u} [category_theory.category E] {G : D ‚•§ E} (t : category_theory.limits.colimit_cocone (F ‚ãô G)) : category_theory.limits.colimit_cocone G
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (a b : Œ±) : Œ±
{Œ± : Type u} [t : topological_space Œ±] {s : set (set Œ±)} (h_open : ‚àÄ (u : set Œ±), u ‚àà s ‚Üí is_open u) (h_nhds : ‚àÄ (a : Œ±) (u : set Œ±), a ‚àà u ‚Üí is_open u ‚Üí (‚àÉ (v : set Œ±) (H : v ‚àà s), a ‚àà v ‚àß v ‚äÜ u)) : topological_space.is_topological_basis s
{Œ± : Type u_1} [preorder Œ±] [order_top Œ±] : category_theory.limits.is_terminal ‚ä§
(B : Type u‚ÇÅ) [category_theory.bicategory B] (C : Type u‚ÇÇ) [category_theory.bicategory C] : category_theory.bicategory (category_theory.oplax_functor B C)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (d : D) : (category_theory.costructured_arrow F d)·µí·µñ ‚âå category_theory.structured_arrow (opposite.op d) F.op
{Œ± : Type u_2} : filter Œ±
(R : Type u_1) {E : Type u_5} [semiring R] [semi_normed_group E] [module R E] : E ‚âÉ‚Çó·µ¢[R] E
{p q : ‚Ñï} [p_prime : fact (nat.prime p)] [q_prime : fact (nat.prime q)] (neq : p ‚â† q) : padic_norm p ‚Üëq = 1
{Œ± : Type u} (l : list Œ±) : ‚Ñï ‚Üí ordnode Œ± √ó {l' // l'.length ‚â§ l.length}
{Œ± : Type u_1} [has_one Œ±] (a : Œ±) : simple_continued_fraction Œ±
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] [category_theory.limits.has_finite_products C] [category_theory.limits.has_finite_products D] (F : C ‚•§ D) [category_theory.cartesian_closed C] [category_theory.cartesian_closed D] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] (A : C) : category_theory.exp A ‚ãô F ‚ü∂ F ‚ãô category_theory.exp (F.obj A)
{Œ± : Type u_1} {Œ≤ : Type u_2} {p : Œ± ‚Üí Prop} (f : Œ† (a : Œ±), p a ‚Üí Œ≤) (x : option Œ±) : (‚àÄ (a : Œ±), a ‚àà x ‚Üí p a) ‚Üí option Œ≤
 : first_order.language
(Œ± : Type u_1) [boolean_algebra Œ±] [fintype Œ±] : FinBoolAlg
{V : Type u} {G : simple_graph V} {u : V} (p : G.walk u u) : Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [semi_normed_group E] [normed_space ùïú E] : normed_space.dual ùïú E ‚ÜíL[ùïú] weak_dual ùïú E
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a b c : Œ±} : b‚Åª¬π * a < c ‚Üí a < b * c
 : first_order.language.order.Theory
 : Type u_1 ‚Üí PartialFun
{Œ± : Type u_1} [ms : measurable_space Œ±] (m : measure_theory.outer_measure Œ±) (h : ms ‚â§ m.caratheodory) : measure_theory.measure Œ±
{m : Type u ‚Üí Type u} [monad m] {Œ± : Type u} : tactic.mllist m Œ± ‚Üí ‚Ñï ‚Üí m (list Œ±)
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] (s : finset Œ±) : finset Œ±
{M : Type u_1} [has_add M] (c : add_con M) : add_con.add_ker coe _ = c
(F : Type u_1) (K : Type u_2) [comm_ring F] [ring K] [algebra F K] : Prop
(C : Type u) [category_theory.category C] (D : Type u) [category_theory.category D] (E : Type u) [category_theory.category E] : (C ‚äï D) ‚äï E ‚âå C ‚äï D ‚äï E
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Group) : Mon
{ùïú : Type u_1} [is_R_or_C ùïú] [decidable_eq ùïú] {n : Type u_2} [fintype n] [decidable_eq n] {A : matrix n n ùïú} (hA : A.is_hermitian) : n ‚Üí ‚Ñù
{Œ± : Type u_1} {Œπ : Type u_3} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} [fintype Œπ] {t : Œπ ‚Üí set Œ±} (h : pairwise (disjoint on t)) (ht : ‚àÄ (i : Œπ), (t i).finite) : finprod (Œª (a : Œ±), finprod (Œª (H : a ‚àà ‚ãÉ (i : Œπ), t i), f a)) = finprod (Œª (i : Œπ), finprod (Œª (a : Œ±), finprod (Œª (H : a ‚àà t i), f a)))
(R : Type u) (S‚ÇÅ : Type v) (S‚ÇÇ : Type w) [comm_semiring R] : mv_polynomial (S‚ÇÅ ‚äï S‚ÇÇ) R ‚âÉ+* mv_polynomial S‚ÇÅ (mv_polynomial S‚ÇÇ R)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {E' : Type u_6} [normed_group E'] [normed_space ùïú E'] {F' : Type u_7} [normed_group F'] [normed_space ùïú F'] {f : E ‚Üí F} {g : E' ‚Üí F'} (hf : cont_diff ùïú n f) (hg : cont_diff ùïú n g) : cont_diff ùïú n (prod.map f g)
(Œ± : Type) : Type
{Œ± : Type u_1} [has_add Œ±] (s : set Œ±) (a b : Œ±) : Prop
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {i : D ‚•§ C} [category_theory.reflective i] {A : C} [category_theory.split_mono ((category_theory.adjunction.of_right_adjoint i).unit.app A)] : A ‚àà i.ess_image
{R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] {abv : absolute_value R ‚Ñ§} {Œπ : Type u_5} [decidable_eq Œπ] [fintype Œπ] (bS : basis Œπ R S) (adm : abv.is_admissible) [infinite R] [decidable_eq R] : finset R
(Œ± : Type u_1) [fintype Œ±] [category_theory.small_category Œ±] [category_theory.fin_category Œ±] : category_theory.fin_category.as_type Œ± ‚âå Œ±
(i : tactic.ring_exp.ex_info) (o pf : option expr) : tactic.ring_exp.ex_info
(C : Type u) [category_theory.category C] : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} {p : filter Œπ} {g : Œπ ‚Üí Œ±} [topological_space Œ±] (h : continuous_within_at f s x) (hg : filter.tendsto g p (nhds_within x s)) (hunif : ‚àÄ (u : set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí (‚àÉ (t : set Œ±) (H : t ‚àà nhds_within x s), ‚àÄ·∂† (n : Œπ) in p, ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F n y) ‚àà u)) : filter.tendsto (Œª (n : Œπ), F n (g n)) p (nhds (f x))
{Œ± : Type u_1} {s : set Œ±} [measurable_space Œ±] (hs : s.infinite) : ‚áëmeasure_theory.measure.count s = ‚ä§
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (x : S.functor ‚ü∂ P) (g : category_theory.yoneda.obj X ‚ü∂ P) : S.functor_inclusion ‚â´ g = x ‚Üî (‚áëcategory_theory.presieve.nat_trans_equiv_compatible_family x).val.is_amalgamation (‚áëcategory_theory.yoneda_equiv g)
(p : ‚Ñï) [hp : fact (nat.prime p)] : ‚Ñï ‚Üí mv_polynomial (fin 2 √ó ‚Ñï) ‚Ñ§
(R : Type u_1) (S : Type u_3) [non_assoc_semiring R] [non_assoc_semiring S] : R √ó S ‚Üí+* S
{F : Type u_1} [field F] {K‚ÇÅ : Type u_3} {K‚ÇÇ : Type u_4} [field K‚ÇÅ] [field K‚ÇÇ] [algebra F K‚ÇÅ] [algebra F K‚ÇÇ] (œï : K‚ÇÅ ‚Üí‚Çê[F] K‚ÇÇ) (E : Type u_6) [field E] [algebra F E] [algebra E K‚ÇÅ] [algebra E K‚ÇÇ] [is_scalar_tower F E K‚ÇÅ] [is_scalar_tower F E K‚ÇÇ] [h : normal F E] : ‚Ü•((is_scalar_tower.to_alg_hom F E K‚ÇÅ).range) ‚Üí‚Çê[F] ‚Ü•((is_scalar_tower.to_alg_hom F E K‚ÇÇ).range)
(mvar : expr) : tactic.unsafe.type_context local_context
{Œ± : Type u} : ‚Ñï ‚Üí tactic Œ± ‚Üí tactic (list Œ±)
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] (f : ùïú ‚Üí F) (f' : F) (x : ùïú) : Prop
{Œ± : Type u} : ordnode Œ± ‚Üí Œ± ‚Üí ordnode Œ±
{L : first_order.language} {M : Type w} [L.Structure M] : has_inf (L.substructure M)
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f g : Œ± ‚Üí M} {s : set Œ±} (hf : (s ‚à© function.mul_support f).finite) (hg : (s ‚à© function.mul_support g).finite) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i * g i)) = finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)) * finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), g i))
{Œ± : Type u_1} (n : ‚Ñï) (v : Œ±) : array n Œ±
{Œ± : Type u_1} {E : Type u_2} (R : Type u_3) [add_comm_group E] [division_ring R] [monoid Œ±] [module R E] [distrib_mul_action Œ± E] (n : ‚Ñ§) (s : Œ±) (x : E) : (‚Üën)‚Åª¬π ‚Ä¢ s ‚Ä¢ x = s ‚Ä¢ (‚Üën)‚Åª¬π ‚Ä¢ x
{Œ± : Type u_1} [has_add Œ±] [linear_order Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] (m : Œ±) : Œ± ‚Ü™o Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : Œ± ‚âÉ Œ≤) : finset Œ± ‚âÉ finset Œ≤
 : algebraic_geometry.Spec.to_LocallyRingedSpace.right_op ‚ãô algebraic_geometry.LocallyRingedSpace.Œì ‚âÖ ùü≠ CommRing
{Œ± : Type u_2} {G : Type u_6} [add_comm_monoid Œ±] [add_comm_group G] {A : set Œ±} {n : ‚Ñï} : has_neg (A ‚Üí+[n] G)
{ùïú : Type u} {Œπ : Type v} {E : Œπ ‚Üí Type wE} {G : Type wG} [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] [normed_group G] [normed_space ùïú G] : normed_group (continuous_multilinear_map ùïú E G)
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} {Œπ : Type u_1} {B : Œπ ‚Üí topological_space.opens ‚Ü•X} (F : Top.presheaf C X) (F' : Top.sheaf C X) (h : topological_space.opens.is_basis (set.range B)) : ((category_theory.induced_functor B).op ‚ãô F ‚ü∂ (category_theory.induced_functor B).op ‚ãô F'.val) ‚âÉ (F ‚ü∂ F'.val)
(Œ± : Type u_2) : Type u_2
(l r : ‚Ñï) : Prop
(Œ± : Type u_5) (Œ≤ : Type u_6) [normed_field Œ±] [semi_normed_group Œ≤] : Type (max u_5 u_6)
(Œ± : expr) : tactic unit
{Œ± : Type u} [add_right_cancel_monoid Œ±] : has_faithful_vadd Œ± Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) {J : Type u} [category_theory.category J] (K : J ‚•§ D) : ùü≠ (category_theory.limits.cone (K ‚ãô G)) ‚ü∂ adj.functoriality_left_adjoint K ‚ãô category_theory.limits.cones.functoriality K G
{Œ± : Type u_1} (s : finset Œ±) : finset (finset Œ±)
 : inhabited (category_theory.limits.walking_parallel_pair_hom category_theory.limits.walking_parallel_pair.zero category_theory.limits.walking_parallel_pair.one)
(Œ± : Type u_1) [topological_space Œ±] : C(Œ±, Œ±)
{Œ± : Type u_1} [measurable_space Œ±] (s : measure_theory.signed_measure Œ±) : set ‚Ñù
(R : Type u_1) [has_one R] [has_neg R] : cardinal.mk ‚Ü•set.univ = cardinal.mk R ^ 4
{R : Type u_1} {S : Type u_2} {F : Type u_3} [has_add R] [has_add S] [has_mul R] [has_mul S] [add_equiv_class F R S] (f : F) (H : ‚àÄ (x y : R), ‚áëf (x * y) = ‚áëf x * ‚áëf y) : R ‚âÉ+* S
(zc nc : tactic.instance_cache) : expr ‚Üí expr ‚Üí tactic (tactic.instance_cache √ó tactic.instance_cache √ó expr √ó expr)
{Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (n : ‚Ñï) : set Œ±
{Œ± : Type u_1} [linear_order Œ±] (s : finset Œ±) (h‚ÇÇ : 1 < s.card) : s.min' _ < s.max' _
{X : Type u_1} [topological_space X] (hX : ‚àÄ {x y : X}, x ‚â† y ‚Üí (‚àÉ (U : set X) (h_clopen : is_clopen U), x ‚àà U ‚àß y ‚àâ U)) : is_totally_disconnected set.univ
{M : Type u_1} [has_mul M] {S T : subsemigroup M} (h : S ‚â§ T) : ‚Ü•S ‚Üí‚Çô* ‚Ü•T
{A : Type u_1} {F : Type u_2} [mul_zero_one_class A] [monoid_with_zero_hom_class F ‚Ñï A] (f g : F) (h_pos : ‚àÄ {n : ‚Ñï}, 0 < n ‚Üí ‚áëf n = ‚áëg n) : f = g
(Œ± : Type u_4) : Type u_4
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] : (M·µê·µí·µñ ‚Üí‚Çô* N·µê·µí·µñ) ‚âÉ (M ‚Üí‚Çô* N)
{R : Type u} [ring R] {X Y : Type v} [add_comm_group X] [module R X] [add_comm_group Y] [module R Y] (f : X ‚Üí‚Çó[R] Y) : Module.of R X ‚ü∂ Module.of R Y
{n : ‚Ñï} (p : fin (n + 1)) (i : fin n) : ‚áëfin.cast_succ i < p ‚à® p ‚â§ ‚áëfin.cast_succ i
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.is_iso g] : category_theory.limits.is_limit (category_theory.limits.pullback_cone_of_right_iso f g)
{n : ‚Ñï} {i : fin (n + 1)} (h : 0 < i) : 0 < ‚áëfin.cast_succ i
{R : Type u} [ring R] : has_top (subring R)
 : expr ‚Üí tactic (expr √ó expr)
(g : expr) : tactic tactic.tag
 : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] [fintype Œ≤] [decidable_eq Œ±] [decidable_eq Œ≤] (h : fintype.card Œ± ‚â§ fintype.card Œ≤) : trunc (Œ± ‚Ü™ Œ≤)
(n : ‚Ñï) (c : composition n) : n.partition
{M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p ‚à£ L.prod ‚Üî ‚àÉ (a : M) (H : a ‚àà L), p ‚à£ a
{X : Type u_1} (C : alexandroff X ‚Üí Sort u_2) (h‚ÇÅ : C alexandroff.infty) (h‚ÇÇ : Œ† (x : X), C ‚Üëx) (z : alexandroff X) : C z
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] {a b : Œ±} (ha : 1 ‚â§ a) (hb : 1 < b) : 1 < a * b
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Ü™ Œ≤) : option Œ± ‚Ü™ option Œ≤
(do_whnf : option (tactic.transparency √ó bool)) (pi_or_lambda : bool) (e : expr) : tactic (option (name √ó binder_info √ó expr √ó expr))
{R‚ÇÉ : Type u_7} [comm_ring R‚ÇÉ] {n : Type u_11} [fintype n] (J : matrix n n R‚ÇÉ) [decidable_eq n] : submodule R‚ÇÉ (matrix n n R‚ÇÉ)
{M : Type u_1} {Œ± : Type u_6} [add_monoid M] [add_action M Œ±] : M ‚Üí+ additive (function.End Œ±)
 : ùü≠ algebraic_geometry.LocallyRingedSpace ‚ü∂ algebraic_geometry.LocallyRingedSpace.Œì.right_op ‚ãô algebraic_geometry.Spec.to_LocallyRingedSpace
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : with_bot Œ± ‚Üí with_bot Œ≤
(X : algebraic_geometry.RingedSpace) (U : topological_space.opens ‚Ü•X) (f : ‚Ü•(X.to_PresheafedSpace.presheaf.obj (opposite.op U))) (x : ‚Ü•U) (h : is_unit (‚áë(X.to_PresheafedSpace.presheaf.germ x) f)) : ‚àÉ (V : topological_space.opens ‚Ü•X) (i : V ‚ü∂ U) (hxV : x.val ‚àà V), is_unit (‚áë(X.to_PresheafedSpace.presheaf.map i.op) f)
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u} [category_theory.category C] {F : J ‚•§ C} (e : K ‚âå J) [category_theory.limits.has_colimit (e.functor ‚ãô F)] : category_theory.limits.has_colimit F
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : F.obj (opposite.op (supr U)) ‚ü∂ Top.presheaf.sheaf_condition_equalizer_products.pi_opens F U
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] : has_zero (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] : X ‚®Ø Y ‚âÖ X ‚®ø Y
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} (hs : s.nonempty) (ht : t.nonempty) (bs : metric.bounded s) (bt : metric.bounded t) : emetric.Hausdorff_edist s t ‚â† ‚ä§
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : differentiable_on ‚Ñù f (interior D)) {C : ‚Ñù} (lt_hf' : ‚àÄ (x : ‚Ñù), x ‚àà interior D ‚Üí deriv f x < C) (x : ‚Ñù) (H : x ‚àà D) (y : ‚Ñù) (H_1 : y ‚àà D) : x < y ‚Üí f y - f x < C * (y - x)
{Œ± : Type u_2} [has_mul Œ±] [has_distrib_neg Œ±] : has_distrib_neg (filter Œ±)
(R : Type u_3) [comm_semiring R] (M : Type u_7) (N‚Çó : Type u_12) (P‚Çó : Type u_13) [add_comm_monoid M] [add_comm_monoid N‚Çó] [add_comm_monoid P‚Çó] [module R M] [module R N‚Çó] [module R P‚Çó] : (N‚Çó ‚Üí‚Çó[R] P‚Çó) ‚Üí‚Çó[R] (M ‚Üí‚Çó[R] N‚Çó) ‚Üí‚Çó[R] M ‚Üí‚Çó[R] P‚Çó
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] : ordnode Œ± ‚Üí ordnode Œ± ‚Üí bool
{R : Type u} [ring R] {M N : Module R} {f : M ‚ü∂ N} : ‚Ü•(linear_map.ker f) ‚Üí‚Çó[R] ‚Ü•(category_theory.limits.kernel_subobject f)
(R : Type u_1) [comm_semiring R] (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization.away 1 S] : R ‚âÉ‚Çê[R] S
(J : Type v) : inhabited (category_theory.limits.walking_parallel_family.hom J category_theory.limits.walking_parallel_family.zero category_theory.limits.walking_parallel_family.zero)
 : interactive.loc ‚Üí string
{X : Type u_1} [topological_space X] {s : set X} (hs : is_seq_closed s) {x : ‚Ñï ‚Üí X} (hmem : ‚àÄ (n : ‚Ñï), x n ‚àà s) {a : X} (ha : filter.tendsto x filter.at_top (nhds a)) : a ‚àà s
{Œ± : Type u_1} (s : cycle Œ±) : multiset Œ±
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {F : C ‚•§ D} {Y Y' : D} (h : Y ‚âÖ Y') (hY : Y ‚àà F.ess_image) : Y' ‚àà F.ess_image
{Œ± : Type u} {Œ≤ : Type v} (r : rel Œ± Œ≤) (l : filter Œ±) : filter Œ≤
{R : Type u} {S : Type v} [ring R] [ring S] {s : subring R} (e : R ‚âÉ+* S) : ‚Ü•s ‚âÉ+* ‚Ü•(subring.map e.to_ring_hom s)
{R : Type u_1} [comm_ring R] {c‚ÇÅ c‚ÇÇ : R} : has_mul (quaternion_algebra R c‚ÇÅ c‚ÇÇ)
{M : Type u_1} [has_add M] {p : M ‚Üí Prop} (x : M) {s : set M} (hs : add_subsemigroup.closure s = ‚ä§) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí p x) (Hmul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x + y)) : p x
{K : Type u_1} [field K] (R : subring K) (hR : ‚àÄ (x : K), x ‚àà R ‚à® x‚Åª¬π ‚àà R) : valuation_subring K
(Œ± : Type u_2) [has_mul Œ±] [has_add Œ±] [has_le Œ±] : Œ± ‚âÉ+*o Œ±
(Œ± : Type u_2) : Type u_2
{Œ± : Type u_2} [subtraction_monoid Œ±] {a : Œ±} (h : is_add_unit a) : add_units Œ±
{M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] {f g : M ‚Üí* N} (h : f = g) (x : M) : ‚áëf x = ‚áëg x
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [has_zero M] [has_zero N] [has_zero P] (f : M ‚Üí N ‚Üí P) (hf : f 0 0 = 0) (g‚ÇÅ : Œ± ‚Üí‚ÇÄ M) (g‚ÇÇ : Œ± ‚Üí‚ÇÄ N) : Œ± ‚Üí‚ÇÄ P
{A : Type u} {B : Type v} {Œπ : Type w} [comm_ring A] [comm_ring B] [algebra A B] [fintype Œπ] [decidable_eq Œπ] (b : Œπ ‚Üí B) (P : matrix Œπ Œπ A) : algebra.discr A ((P.map ‚áë(algebra_map A B)).mul_vec b) = P.det ^ 2 * algebra.discr A b
{V : Type u} [quiver V] (r : V) [quiver.rooted_connected r] (b : V) : quiver.path r b
{Œ± : Sort u} [decidable_eq Œ±] {Œ≤ : Sort u_1} (f : Œ± ‚Üí Œ≤) (a' : Œ±) (b : Œ≤) (a : Œ±) : function.update f a' b a = ite (a = a') b (f a)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] {D : Type u‚ÇÅ} [category_theory.category D] [category_theory.preadditive D] [category_theory.limits.has_finite_biproducts D] (F : C ‚•§ D) [F.additive] (L : category_theory.Mat_ C ‚•§ D) [L.additive] (Œ± : category_theory.Mat_.embedding C ‚ãô L ‚âÖ F) : L ‚âÖ category_theory.Mat_.lift F
{Œ± : Type u} [pseudo_metric_space Œ±] (x : Œ±) (s : set Œ±) : nnreal
{Œ± : Type u_1} {l : filter Œ±} {p : Œ± ‚Üí Prop} : (‚àÄ·∂† (x : Œ±) in l, p x) ‚Üí (‚àÄ·∂† (s : set Œ±) in l.small_sets, ‚àÄ (x : Œ±), x ‚àà s ‚Üí p x)
(P : Type u) : Type u
(ùïú : Type u_1) {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} (v : Œπ ‚Üí E) : Prop
(L : out_param first_order.language) (F : Type u_5) (M : out_param (Type u_6)) (N : out_param (Type u_7)) [fun_like F M (Œª (_x : M), N)] [first_order.language.Structure L M] [first_order.language.Structure L N] : Type
{n n' : ‚Ñï} (i : fin n) (h : n.succ = n'.succ) : ‚áë(fin.cast h) i.succ = (‚áë(fin.cast _) i).succ
(C : Type u) [category_theory.category C] [category_theory.has_shift C ‚Ñ§] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] (X : C) : category_theory.triangulated.triangle C
{Œ± : Type u_1} {M : Type u_5} [has_zero M] (f : Œ± ‚Üí‚ÇÄ M) (a : Œ±) (b : M) : Œ± ‚Üí‚ÇÄ M
{Œπ : Type v} {Œπ' : Type v'} (f : Œπ ‚Üí cardinal) (f' : Œπ' ‚Üí cardinal) (g : Œπ ‚Üí Œπ') (h : ‚àÄ (i : Œπ), (f i).lift ‚â§ (f' (g i)).lift) : (cardinal.sup f).lift ‚â§ (cardinal.sup f').lift
 : ‚ÑÇ ‚âÉ·µê ‚Ñù √ó ‚Ñù
{Œ± : Type u_1} (Œ≤ : Œ± ‚Üí Type u_2) : Type (max u_1 u_2)
{Œ± : Type u} [lattice Œ±] [comm_group Œ±] : has_pos_part Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H : right_commutative f) (b : Œ≤) (s : multiset Œ±) : Œ≤
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (f : M ‚Üí* N) (S : submonoid M) : submonoid N
{V : Type u} [quiver V] : V ‚Üí quiver.weakly_connected_component V
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [decidable_eq Œπ] [Œ† (i : Œπ), decidable_eq (Œ± i)] [Œ† (i : Œπ), has_zero (Œ± i)] (f : Œ†‚ÇÄ (i : Œπ), finset (Œ± i)) : finset (Œ†‚ÇÄ (i : Œπ), Œ± i)
(R : Type u_5) [semiring R] (M : Type u_1) [add_comm_monoid M] [module R M] : function.surjective ‚áë(finsupp.total M M R id)
{Œ± : Type u} [decidable_eq Œ±] (a : Œ±) : wseq Œ± ‚Üí wseq ‚Ñï
 : pgame ‚Üí Type u
{Œ± : Type u_2} [has_div Œ±] : has_div (set Œ±)
{R : Type u_1} [semiring R] {m : Type u_3} {n : Type u_4} [fintype m] [decidable_eq m] [fintype n] [decidable_eq n] {M : matrix m n R} {M' : matrix n m R} (hMM' : M.mul M' = 1) (hM'M : M'.mul M = 1) : (n ‚Üí R) ‚âÉ‚Çó[R] m ‚Üí R
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [metric_space Œ≤] (f : Œ± ‚Üí Œ≤) (h : uniform_embedding f) : metric_space Œ±
{L : first_order.language} {Œ± : Type u'} {m n : ‚Ñï} (h : m ‚â§ n) : L.bounded_formula Œ± m ‚Üí L.bounded_formula Œ± n
{X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra ‚Ñù C(X, ‚Ñù)) (w : A.separates_points) (f : C(X, ‚Ñù)) : f ‚àà A.topological_closure
{Œ± : Type u_2} {Œ≤ : Type u_3} [add_monoid Œ±] [add_action Œ± Œ≤] : add_action Œ± (filter Œ≤)
 : ‚Ñï ‚Üí tactic unit
{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [decidable_eq V] : finset.univ.sum (Œª (v : V), G.degree v) = 2 * G.edge_finset.card
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [non_unital_non_assoc_semiring Œ≤] : non_unital_non_assoc_semiring Œ±
 : algebraic_geometry.LocallyRingedSpace.Œì.right_op ‚ä£ algebraic_geometry.Spec.to_LocallyRingedSpace
{C : Type u‚ÇÅ} [category_theory.category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (S : category_theory.sieve X) (x : category_theory.equalizer.first_obj P ‚áëS) : ((category_theory.equalizer.first_obj_eq_family P ‚áëS).hom x).compatible ‚Üî category_theory.equalizer.sieve.first_map P S x = category_theory.equalizer.sieve.second_map P S x
(Fq F : Type) [field Fq] [fintype Fq] [field F] [algebra (polynomial Fq) F] [algebra (ratfunc Fq) F] [is_scalar_tower (polynomial Fq) (ratfunc Fq) F] [function_field Fq F] [is_separable (ratfunc Fq) F] : function_field.class_number Fq F = 1 ‚Üî is_principal_ideal_ring ‚Ü•(function_field.ring_of_integers Fq F)
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±] {a : Œ±} (h : (set.Iio a).nonempty) : closure (set.Iio a) = set.Iic a
{C : Type u} [category_theory.category C] (P : C) : Prop
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (G : D ‚•§ C) [‚àÄ (A : C), category_theory.limits.has_initial (category_theory.structured_arrow A G)] : category_theory.left_adjoint_of_structured_arrow_initials G ‚ä£ G
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : fin 3 ‚Üí P) : affine_independent k p ‚Üî ¬¨collinear k (set.range p)
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [normed_space ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} {E' : Type u_10} [semi_normed_group E'] [normed_space ùïú E'] [ring_hom_isometric œÉ‚ÇÅ‚ÇÇ] [complete_space F] : complete_space (E' ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F)
{F : Type u_3} [field F] [fintype F] : ring_char F = 2 ‚Üî fintype.card F % 2 = 0
 : linarith.linexp ‚Üí linarith.linexp ‚Üí linarith.linexp
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_coproducts C
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] {F : Type v} [normed_group F] [normed_space ‚ÑÇ F] {f : E ‚Üí F} (hf : differentiable ‚ÑÇ f) (hb : metric.bounded (set.range f)) (z w : E) : f z = f w
{G : Type u_1} [group G] (H K : subgroup G) : subgroup ‚Ü•K
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {X Y : C} (hX : category_theory.closed X) (hY : category_theory.closed Y) : category_theory.closed (X ‚äó Y)
{R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [add_comm_group N] [module R M] [module R N] [lie_ring_module L M] [lie_ring_module L N] [lie_module R L M] [lie_module R L N] : has_zero (M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N)
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} [category_theory.limits.has_equalizer f g] (h : f = g) : category_theory.is_iso (category_theory.limits.equalizer.Œπ f g)
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [densely_ordered Œ±] {Œ¥ : Type u_1} [linear_order Œ¥] [topological_space Œ¥] [order_closed_topology Œ¥] {s : set Œ±} [hs : s.ord_connected] {f : Œ± ‚Üí Œ¥} (hf : continuous_on f s) {a b : Œ±} (ha : a ‚àà s) (hb : b ‚àà s) : set.surj_on f s (set.interval (f a) (f b))
{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} : char.quadratic_char F a = -1 ‚Üî ¬¨is_square a
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Ü™ Œ≤) (hf : function.surjective ‚áëf) : Œ± ‚âÉ Œ≤
{Œ± : Type u_1} [topological_space Œ±] [non_unital_non_assoc_ring Œ±] [topological_ring Œ±] (x : Œ±) : continuous ‚áë(add_monoid_hom.mul_left x)
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] {M : Type u_3} [add_comm_monoid M] [topological_space M] (v : measure_theory.vector_measure Œ± M) (f : Œ± ‚Üí Œ≤) : measure_theory.vector_measure Œ≤ M
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] (X : category_theory.simplicial_object C) (n : ‚Ñï) : ‚Üë(algebraic_topology.normalized_Moore_complex.obj_X X (n + 1)) ‚ü∂ ‚Üë(algebraic_topology.normalized_Moore_complex.obj_X X n)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {X : C} {F : C ‚•§ D} {S : category_theory.presieve X} {Y : D} {f : Y ‚ü∂ F.obj X} (h : category_theory.presieve.functor_pushforward F S f) : category_theory.presieve.functor_pushforward_structure F S f
(p : Prop) [decidable p] : p ‚à® ¬¨p
{J : Type u‚ÇÅ} [category_theory.category J] [nonempty J] {j‚ÇÄ : J} (h : ‚àÄ (p : set J), j‚ÇÄ ‚àà p ‚Üí (‚àÄ {j‚ÇÅ j‚ÇÇ : J}, (j‚ÇÅ ‚ü∂ j‚ÇÇ) ‚Üí (j‚ÇÅ ‚àà p ‚Üî j‚ÇÇ ‚àà p)) ‚Üí ‚àÄ (j : J), j ‚àà p) : category_theory.is_connected J
 : tactic unit
{Œ± : Type u} : can_lift (set Œ±) (finset Œ±)
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop} (f : Œ± ‚Üí Œ≤) (h : ‚àÄ (a : Œ±), p a ‚Üí q (f a)) : subtype p ‚Üí subtype q
{M : Type u_1} [add_monoid M] (s : add_submonoid M) {l : list M} (hl : ‚àÄ (x : M), x ‚àà l ‚Üí x ‚àà s) : l.sum ‚àà s
{Œ± : Type u_1} {Œ≤ : Type u_2} (p : pmf Œ±) (f : Œ± ‚Üí pmf Œ≤) (s : set Œ≤) [measurable_space Œ≤] (hs : measurable_set s) : ‚áë((p.bind f).to_measure) s = ‚àë' (a : Œ±), ‚Üë(‚áëp a) * ‚áë((f a).to_measure) s
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_products C] : C ‚•§ category_theory.over X
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} {n : ‚Ñï+} (data : bucket_array Œ± Œ≤ n) {Œ¥ : Type w} (d : Œ¥) (f : Œ¥ ‚Üí Œ† (a : Œ±), Œ≤ a ‚Üí Œ¥) : Œ¥
{G : Type u_1} [group G] (H : subgroup G) : 1 ‚àà H
(Œ± : Type u_1) [encodable Œ±] : Œ± ‚âÉ ‚Ü•(set.range encodable.encode)
(Œ± : Type u_1) : Type u_1
{Œ± : Type u_1} [semilattice_sup Œ±] : galois_insertion partial_sups coe_fn
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {D : Type u‚ÇÅ} [category_theory.category D] (h : C ‚âå D) : category_theory.is_cofiltered D
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.limits.has_binary_products C] [category_theory.limits.has_binary_products D] (A : C) [‚àÄ (B : C), category_theory.is_iso (category_theory.limits.prod_comparison F A B)] : category_theory.limits.prod.functor.obj A ‚ãô F ‚âÖ F ‚ãô category_theory.limits.prod.functor.obj (F.obj A)
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] (F : C ‚•§ D) [F.preserves_zero_morphisms] (X Y : C) [category_theory.limits.preserves_biproduct (category_theory.limits.pair_function X Y) F] : category_theory.limits.preserves_binary_biproduct X Y F
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (x y : E) : is_R_or_C.abs (has_inner.inner x y) * is_R_or_C.abs (has_inner.inner y x) ‚â§ ‚áëis_R_or_C.re (has_inner.inner x x) * ‚áëis_R_or_C.re (has_inner.inner y y)
{a b c m : ‚Ñï} (hmc : m.gcd c = 1) (h : a * c ‚â° b * c [MOD m]) : a ‚â° b [MOD m]
{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {x : M} {s : set M} {p : M ‚Üí Prop} (h : x ‚àà submodule.span R s) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí p x) (H0 : p 0) (H1 : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x + y)) (H2 : ‚àÄ (a : R) (x : M), p x ‚Üí p (a ‚Ä¢ x)) : p x
{Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_linear_order Œ±] {a : Œ±} [nonempty Œπ] {f : Œπ ‚Üí Œ±} (h : infi f < a) : ‚àÉ (i : Œπ), f i < a
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) {Z : C} (l : X ‚ü∂ Z) (i : Z ‚âÖ Y) (h : l ‚â´ i.hom = f) {s : category_theory.limits.kernel_fork f} (hs : category_theory.limits.is_limit s) : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ (category_theory.limits.fork.Œπ s) _)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {s : set E} {f : E ‚Üí F} {x : E} {n : with_top ‚Ñï} (e : G ‚âÉL[ùïú] E) : cont_diff_within_at ùïú n (f ‚àò ‚áëe) (‚áëe ‚Åª¬π' s) (‚áë(e.symm) x) ‚Üî cont_diff_within_at ùïú n f s x
{R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {Œπ : Type u_6} [decidable_eq Œπ] {N‚ÇÇ : Type u_7} [add_comm_monoid N‚ÇÇ] [module R N‚ÇÇ] (g : N ‚Üí‚Çó[R] N‚ÇÇ) : alternating_map R M N Œπ ‚Üí+ alternating_map R M N‚ÇÇ Œπ
{M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] {f g : M ‚âÉ* N} (h : ‚àÄ (x : M), ‚áëf x = ‚áëg x) : f = g
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] {L : C ‚•§ D} {R : D ‚•§ C} (adj : L ‚ä£ R) : R.final
{Œ± : Type u_1} [fintype Œ±] (e : Œ± ‚Ü™ Œ±) : Œ± ‚âÉ Œ±
(s b : ‚Ñù) (hb : 0 < b) : filter.tendsto (Œª (x : ‚Ñù), real.exp (b * x) / x ^ s) filter.at_top filter.at_top
{C : Type u‚ÇÅ} [category_theory.category C] (T : category_theory.monad C) : C ‚•§ C
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} {F : Top.presheaf C X} {Œπ : Type v} {V : Top} {j : V ‚ü∂ X} (oe : open_embedding ‚áëj) (ùí∞ : Œπ ‚Üí topological_space.opens ‚Ü•V) : Top.presheaf.sheaf_condition_equalizer_products.pi_inters (_.functor.op ‚ãô F) ùí∞ ‚âÖ Top.presheaf.sheaf_condition_equalizer_products.pi_inters F (Top.presheaf.sheaf_condition_equalizer_products.cover.of_open_embedding oe ùí∞)
{R : Type u} {Œπ : Type w} (s : finset Œπ) [comm_semiring R] (f : Œπ ‚Üí polynomial R) (h : s.prod (Œª (i : Œπ), (f i).leading_coeff) ‚â† 0) : (s.prod (Œª (i : Œπ), f i)).leading_coeff = s.prod (Œª (i : Œπ), (f i).leading_coeff)
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} {V3 : Type u_6} {P3 : Type u_7} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] [add_comm_group V3] [module k V3] [add_torsor V3 P3] (f : P2 ‚Üí·µÉ[k] P3) (g : P1 ‚Üí·µÉ[k] P2) : P1 ‚Üí·µÉ[k] P3
(C : Type u_1) [category_theory.category C] : Type (max u_1 u_2)
{R : Type u} [comm_ring R] {X Y : Algebra R} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ‚Çê[R] ‚Ü•Y
{X : Top} {Y : topological_space.opens ‚Ü•X} (R : category_theory.presieve Y) : Top.presheaf.presieve_of_covering_aux (Top.presheaf.covering_of_presieve Y R) Y = R
{Œ± : Type u_2} [division_ring Œ±] : has_coe_t ‚Ñö Œ±
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : set Œ±) (f : ‚Ñï ‚Üí Œ±) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [fintype Œ±] [fintype Œ≤] [add_comm_monoid M] (e : Œ± ‚Üí Œ≤) (he : function.bijective e) (f : Œ± ‚Üí M) (g : Œ≤ ‚Üí M) (h : ‚àÄ (x : Œ±), f x = g (e x)) : finset.univ.sum (Œª (x : Œ±), f x) = finset.univ.sum (Œª (x : Œ≤), g x)
{Œ± : Type u} : lazy_list Œ± ‚Üí seq Œ±
 : Type (u_1+1)
 : user_attribute unit (option name)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {s : set E} {f : E ‚Üí F} {x : E} {n : with_top ‚Ñï} (g : F ‚ÜíL[ùïú] G) (hf : cont_diff_within_at ùïú n f s x) : cont_diff_within_at ùïú n (‚áëg ‚àò f) s x
(a : expr) : expr ‚Üí option tactic.norm_fin.match_fin_result
{R : Type u} [non_assoc_semiring R] {S T : subsemiring R} (h : S ‚â§ T) : ‚Ü•S ‚Üí+* ‚Ü•T
{ùïú : Type u_1} [is_R_or_C ùïú] [dec_ùïú : decidable_eq ùïú] {E : Type u_2} [inner_product_space ùïú E] {T : E ‚Üí‚Çó[ùïú] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional ùïú E] {n : ‚Ñï} (hn : finite_dimensional.finrank ùïú E = n) (i : fin n) : ‚Ñù
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : local_equiv Œ± Œ≤) (s : set Œ±) : local_equiv Œ± Œ≤
{R : Type u_1} [semiring R] (r : R) : polynomial R ‚Üí‚Çó[R] R
{K : Type v} [field K] (f : polynomial K) {R : Type u_1} [comm_semiring R] [algebra R K] : algebra R f.splitting_field
{Œ≥ : Type} (local_c : widget.tc widget_override.local_collection Œ≥) (target_c : widget.tc expr Œ≥) : widget.tc unit Œ≥
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {g1 g2 : G} (p : P) (h : g1 +·µ• p = g2 +·µ• p) : g1 = g2
 : (‚Ñï ‚Üí ‚Ñï) ‚Üí Prop
{Œ± : Type u_1} : finset Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) [is_trichotomous Œ± r] [is_irrefl Œ≤ s] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y : Œ±}, r x y ‚Üí s (f x) (f y)) : function.injective f
{Œ± : Type u} (c : distrib_lattice Œ±) (le : Œ± ‚Üí Œ± ‚Üí Prop) (eq_le : le = distrib_lattice.le) (sup : Œ± ‚Üí Œ± ‚Üí Œ±) (eq_sup : sup = distrib_lattice.sup) (inf : Œ± ‚Üí Œ± ‚Üí Œ±) (eq_inf : inf = distrib_lattice.inf) : distrib_lattice Œ±
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_comm_monoid N] : (Œ± ‚Üí M ‚Üí+ N) ‚âÉ+ ((Œ± ‚Üí‚ÇÄ M) ‚Üí+ N)
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_5} {f f' : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s : set Œ±} {t : set Œ≤} (h : ‚àÄ (a : Œ±) (b : Œ≤), f a b = f' a b) : set.image2 f s t = set.image2 f' s t
{M : Type u_1} [has_add M] {c d : add_con M} (H : c.to_setoid = d.to_setoid) : c = d
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] {Z : C} (h : Y ‚ü∂ Z) [category_theory.limits.has_kernel (f ‚â´ h)] : category_theory.limits.kernel_subobject f ‚â§ category_theory.limits.kernel_subobject (f ‚â´ h)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} (hf : is_bounded_linear_map ùïú f) : E ‚ÜíL[ùïú] F
{Œ≥ : Type w} [emetric_space Œ≥] : separated_space Œ≥
(X : category_theory.limits.walking_span) : X ‚ü∂ X
{R' : Type u_1} {Œ± : Type u_2} [semiring R'] [mul_action R' Œ±] (S : subsemiring R') : mul_action ‚Ü•S Œ±
(K : Type u) : Type u
{R : Type u_1} [comm_semiring R] {m : Type u_3} {n : Type u_4} [fintype n] [fintype m] [decidable_eq n] {M‚ÇÅ : Type u_5} {M‚ÇÇ : Type u_6} [add_comm_monoid M‚ÇÅ] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÅ] [module R M‚ÇÇ] (v‚ÇÅ : basis n R M‚ÇÅ) (v‚ÇÇ : basis m R M‚ÇÇ) [decidable_eq m] {M : matrix m n R} {M' : matrix n m R} (hMM' : M.mul M' = 1) (hM'M : M'.mul M = 1) : M‚ÇÅ ‚âÉ‚Çó[R] M‚ÇÇ
{L : first_order.language} {M : Type w} [L.Structure M] {S T : L.substructure M} (h : S ‚â§ T) : L.embedding ‚Ü•S ‚Ü•T
{Œ± : Type u} [comm_monoid Œ±] (a b : Œ±) (hab : a * b = 1) : Œ±À£
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) : non_assoc_semiring ‚Ü•s
{C : Type u‚ÇÅ} [category_theory.category C] [‚àÄ (X Y : C), subsingleton (X ‚ü∂ Y)] {X Y : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ X) : X ‚âÖ Y
 : algebraic_geometry.Scheme·µí·µñ ‚•§ CommRing
(env : environment) (d : declaration) : exceptional environment
(Œ≤ : Type v) (C : Type u_1) [category_theory.category C] : Prop
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f g : V ‚Üí‚Çó[K] V} : f * g = 1 ‚Üî g * f = 1
{V : Type u_1} [inner_product_space ‚Ñù V] {x : V} (hx : x ‚â† 0) : inner_product_geometry.angle (-x) x = real.pi
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] {p1 p2 : P} (p3 : P) (hp1 : p1 ‚àà s) (hp2 : p2 ‚àà s) : has_dist.dist p1 p3 = has_dist.dist p2 p3 ‚Üî has_dist.dist p1 ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p3) = has_dist.dist p2 ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p3)
{p : ‚Ñï} (n : ‚Ñï) {R : Type u_1} (x : witt_vector p R) : truncated_witt_vector p n R
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) {Œπ : Type u_2} {t : finset Œπ} {f : Œπ ‚Üí M} (h : ‚àÄ (c : Œπ), c ‚àà t ‚Üí f c ‚àà S) : t.sum (Œª (c : Œπ), f c) ‚àà S
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (X‚ÇÄ X‚ÇÅ X‚ÇÇ : V) (d‚ÇÄ : X‚ÇÅ ‚ü∂ X‚ÇÄ) (d‚ÇÅ : X‚ÇÇ ‚ü∂ X‚ÇÅ) (s : d‚ÇÅ ‚â´ d‚ÇÄ = 0) (succ : Œ† (t : Œ£' (X‚ÇÄ X‚ÇÅ X‚ÇÇ : V) (d‚ÇÄ : X‚ÇÅ ‚ü∂ X‚ÇÄ) (d‚ÇÅ : X‚ÇÇ ‚ü∂ X‚ÇÅ), d‚ÇÅ ‚â´ d‚ÇÄ = 0), Œ£' (X‚ÇÉ : V) (d‚ÇÇ : X‚ÇÉ ‚ü∂ t.snd.snd.fst), d‚ÇÇ ‚â´ t.snd.snd.snd.snd.fst = 0) (n : ‚Ñï) : chain_complex.mk_struct V
{J : Type u‚ÇÅ} [category_theory.category J] [category_theory.is_preconnected J] {Œ± : Type u‚ÇÅ} (F : J ‚Üí Œ±) (h : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), (j‚ÇÅ ‚ü∂ j‚ÇÇ) ‚Üí F j‚ÇÅ = F j‚ÇÇ) (j j' : J) : F j = F j'
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) {x : E} : p.radius - ‚Üë‚à•x‚à•‚Çä ‚â§ (p.change_origin x).radius
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {Œπ : Type u_1} (c : complex_shape Œπ) {Œπ' : Type u_2} (c' : complex_shape Œπ') : homological_complex (homological_complex V c) c' ‚•§ homological_complex (homological_complex V c') c
{R : Type u} [ring R] {M N : Module R} (i : ‚Ü•M ‚âÉ‚Çó[R] ‚Ü•N) : M ‚âÖ N
{R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ‚Üî ‚àÉ (p : R) (k : ‚Ñï), prime p ‚àß p ^ (k + 1) = n
(c : ‚ÑÇ) (R : ‚Ñù) : function.periodic (circle_map c R) (2 * real.pi)
{Œ± : Type u} (x : Œ±) : free_abelian_group Œ±
{Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [has_zero Œ≤] [has_one Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ± ‚Üí Œ≤) (hf : function.surjective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ±), f (-x) = -f x) (sub : ‚àÄ (x y : Œ±), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ±) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : Œ±) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ±) (n : ‚Ñï), f (x ^ n) = f x ^ n) : ring Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí. Œ≤) : set Œ±
(R : Type u_1) [comm_ring R] : Prop
{Œ± : Type u} [pseudo_emetric_space Œ±] (x y z : Œ±) : has_edist.edist x y ‚â§ has_edist.edist z x + has_edist.edist z y
(Œ± : Type u_1) : Type u_1
{M : Type u_1} [add_zero_class M] (c : add_con M) : add_zero_class c.quotient
{K : Type u_1} [division_ring K] {Œì‚ÇÄ : Type u_2} [linear_ordered_comm_group_with_zero Œì‚ÇÄ] [valued K Œì‚ÇÄ] : topological_division_ring K
{C : Type u‚ÇÅ} [category_theory.category C] (F : C·µí·µñ ‚•§ Type v‚ÇÅ) [F.representable] : category_theory.yoneda.obj F.repr_X ‚ü∂ F
(S : Type u_1) [shelf S] : shelf_hom S S
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : Œ± √ó (Œ≤ ‚äï Œ≥) ‚âÉ Œ± √ó Œ≤ ‚äï Œ± √ó Œ≥
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s‚ÇÅ s‚ÇÇ : affine_subspace ‚Ñù P) [nonempty ‚Ü•s‚ÇÅ] [nonempty ‚Ü•s‚ÇÇ] [complete_space ‚Ü•(s‚ÇÅ.direction)] [complete_space ‚Ü•(s‚ÇÇ.direction)] (p : P) : ‚áë(euclidean_geometry.reflection s‚ÇÅ) p = ‚áë(euclidean_geometry.reflection s‚ÇÇ) p ‚Üî ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s‚ÇÅ) p) = ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s‚ÇÇ) p)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [finite_dimensional ùïú E] {n : ‚Ñï} (hn : finite_dimensional.finrank ùïú E = n) {Œπ : Type u_4} [fintype Œπ] [decidable_eq Œπ] {V : Œπ ‚Üí submodule ùïú E} (hV : direct_sum.is_internal V) (a : fin n) : Œπ
{A : Type u_1} [comm_ring A] {Œì : Type u_2} [linear_ordered_comm_group_with_zero Œì] (v : valuation A Œì) {S : submonoid A} (hS : S ‚â§ v.supp.prime_compl) (B : Type u_3) [comm_ring B] [algebra A B] [is_localization S B] : valuation B Œì
{n : Type u} [decidable_eq n] [fintype n] {Œ± : Type v} [comm_ring Œ±] (A : matrix n n Œ±) (b : n ‚Üí Œ±) (i : n) : Œ±
(n : ‚Ñ§) : ‚Ñï+ ‚Üí ‚Ñö
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : category_theory.nat_trans F F
 : ‚Ñù ‚Üí ereal
{Œ≥ : Type} (tooltip : widget.tc subexpr Œ≥) : widget.tc expr Œ≥
{E : Type u} [normed_group E] [normed_space ‚Ñù E] [complete_space E] {n : ‚Ñï} (a b : fin (n + 1) ‚Üí ‚Ñù) (hle : a ‚â§ b) (f : (fin (n + 1) ‚Üí ‚Ñù) ‚Üí fin (n + 1) ‚Üí E) (f' : (fin (n + 1) ‚Üí ‚Ñù) ‚Üí ((fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] fin (n + 1) ‚Üí E)) (s : set (fin (n + 1) ‚Üí ‚Ñù)) (hs : s.countable) (Hc : continuous_on f (set.Icc a b)) (Hd : ‚àÄ (x : fin (n + 1) ‚Üí ‚Ñù), x ‚àà set.univ.pi (Œª (i : fin (n + 1)), set.Ioo (a i) (b i))  s ‚Üí has_fderiv_at f (f' x) x) (Hi : measure_theory.integrable_on (Œª (x : fin (n + 1) ‚Üí ‚Ñù), finset.univ.sum (Œª (i : fin (n + 1)), ‚áë(f' x) (pi.single i 1) i)) (set.Icc a b) measure_theory.measure_space.volume) : ‚à´ (x : fin (n + 1) ‚Üí ‚Ñù) in set.Icc a b, finset.univ.sum (Œª (i : fin (n + 1)), ‚áë(f' x) (pi.single i 1) i) = finset.univ.sum (Œª (i : fin (n + 1)), (‚à´ (x : fin n ‚Üí ‚Ñù) in set.Icc (a ‚àò ‚áë(i.succ_above)) (b ‚àò ‚áë(i.succ_above)), f (i.insert_nth (b i) x) i) - ‚à´ (x : fin n ‚Üí ‚Ñù) in set.Icc (a ‚àò ‚áë(i.succ_above)) (b ‚àò ‚áë(i.succ_above)), f (i.insert_nth (a i) x) i)
{Œ± : Type u_1} [has_add Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b c d : Œ±} (h‚ÇÅ : a < b) (h‚ÇÇ : c < d) : a + c < b + d
{A B : Type u} [comm_group A] [comm_group B] (e : A ‚âÉ* B) (n : ‚Ñ§) : A ‚ß∏ (zpow_group_hom n).range ‚âÉ* B ‚ß∏ (zpow_group_hom n).range
{Œ± : Type u_1} [comm_semiring Œ±] (E : linear_recurrence Œ±) (init : fin E.order ‚Üí Œ±) (n : fin E.order) : E.mk_sol init ‚Üën = init n
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] (J : category_theory.grothendieck_topology C) (P : C·µí·µñ ‚•§ A) [category_theory.limits.has_products A] [category_theory.limits.has_pullbacks C] : category_theory.presheaf.is_sheaf J P ‚Üî category_theory.presheaf.is_sheaf' J P
{Œ± : Type u_1} {Œ≤ : Type u_2} (p : Œ± ‚Üí Œ≤ ‚Üí Prop) : {x // p x.fst x.snd} ‚âÉ Œ£ (a : Œ±), {b // p a b}
{Œ± : Type u_1} : ‚Ñï ‚Üí ‚Ñï ‚Üí list Œ± ‚Üí list Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} (H : C ‚•§ D) [category_theory.is_equivalence H] (c : category_theory.limits.cone (F ‚ãô H)) : category_theory.limits.cone F
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} {ps : set P} (h : ps ‚äÜ ‚Üës) [nonempty ‚Ü•s] {n : ‚Ñï} [finite_dimensional ‚Ñù ‚Ü•(s.direction)] (hd : finite_dimensional.finrank ‚Ñù ‚Ü•(s.direction) = n) (hc : euclidean_geometry.cospherical ps) {sx‚ÇÅ sx‚ÇÇ : affine.simplex ‚Ñù P n} (hsx‚ÇÅ : set.range sx‚ÇÅ.points ‚äÜ ps) (hsx‚ÇÇ : set.range sx‚ÇÇ.points ‚äÜ ps) : sx‚ÇÅ.circumcenter = sx‚ÇÇ.circumcenter
{Œ± : Type u_1} {Œ≤ : Type u_2} [complete_lattice Œ±] (a : Œ±) (f : Œ≤ ‚Üí Œ±) : (‚®Ö (o : option Œ≤), option.elim a f o) = a ‚äì ‚®Ö (b : Œ≤), f b
(R : Type u) [comm_semiring R] {M : Type v} [add_comm_monoid M] [module R M] {Œπ : Type w} [decidable_eq Œπ] [fintype Œπ] (b : basis Œπ R M) : (M ‚Üí‚Çó[R] M) ‚Üí‚Çó[R] R
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_images C] [category_theory.limits.has_binary_coproducts C] {A : C} (f g : category_theory.mono_over A) : f ‚ü∂ (category_theory.mono_over.sup.obj f).obj g
{G : Type u} [group G] {A' A B' B : subgroup G} [hAN : (A'.subgroup_of A).normal] [hBN : (B'.subgroup_of B).normal] (h' : A' ‚â§ B') (h : A ‚â§ B) : ‚Ü•A ‚ß∏ A'.subgroup_of A ‚Üí* ‚Ü•B ‚ß∏ B'.subgroup_of B
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (M : Type w) [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [lie_algebra.is_nilpotent R L] (œá : L ‚Üí R) : lie_submodule R L M
{M : Type u_6} {N : Type u_7} [has_add M] [has_add N] (e : M ‚âÉ+ N) (y : N) : ‚áëe (‚áë(e.symm) y) = y
{p : ‚Ñï} {R : Type u_1} [comm_ring R] (x : witt_vector p R) : witt_vector p R
{Œ≤ : Type u_4} [linear_order Œ≤] [no_min_order Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : filter.tendsto u filter.at_top filter.at_bot) (N : ‚Ñï) : ‚àÉ (n : ‚Ñï) (H : n ‚â• N), ‚àÄ (k : ‚Ñï), k < n ‚Üí u n < u k
{M : Type u_1} [ordered_comm_monoid M] {A : Type u_2} [set_like A M] [submonoid_class A M] (S : A) : ordered_comm_monoid ‚Ü•S
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Sort u_2} [has_coe_to_fun Œ± Œ≤] : has_coe_to_fun (additive Œ±) (Œª (a : additive Œ±), Œ≤ (‚áëadditive.to_mul a))
(ùïú : Type u_1) (E : Type u_2) [is_R_or_C ùïú] [inner_product_space ùïú E] [finite_dimensional ùïú E] : set E
(n : ‚Ñï) : sSet
(h : expr) : tactic ‚Ñï
{Œ± : Type u_1} [preorder Œ±] (a b : Œ±) : set Œ±
 : category_theory.yoneda ‚ãô sSet.to_Top ‚âÖ simplex_category.to_Top
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [comm_monoid N] (f : Œ± ‚Üí‚ÇÄ M) (y : Œ±) (g : Œ± ‚Üí M ‚Üí N) (hg : ‚àÄ (i : Œ±), g i 0 = 1) : g y (‚áëf y) * (finsupp.erase y f).prod g = f.prod g
(L : first_order.language) : Prop
{M : Type u_3} {N : Type u_4} {hM : add_zero_class M} {hN : add_zero_class N} (f : M ‚Üí+ N) (f' : M ‚Üí N) (h : f' = ‚áëf) : M ‚Üí+ N
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 p : P} : p1 -·µ• p = p2 -·µ• p ‚Üî p1 = p2
{C : fin2 0 ‚Üí Sort u} (i : fin2 0) : C i
{Œ± : Type u} [linear_ordered_ring Œ±] {x y : Œ±} : x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b : Œ±} (ha : a < 0) (hb : b < 0) : a + b < 0
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) : category_theory.monad C
{Œ± : Type u_1} (s : multiset Œ±) : multiset (multiset Œ± √ó multiset Œ±)
{Œ± : Type u_1} [subsingleton Œ±] (s : finset Œ±) : s.card ‚â§ 1
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí. Œ≤) [D : decidable_pred (Œª (_x : Œ±), _x ‚àà f.dom)] (x : Œ±) : option Œ≤
(p q : omega.int.preform) : Prop
{Œ± : Type u_1} {Œπ'' : Type u_6} [preorder Œπ''] (s'' : Œπ'' ‚Üí set Œ±) : Prop
{R : Type u_1} [semiring R] (k : ‚Ñï) : polynomial R ‚Üí‚Çó[R] polynomial R
 : num ‚Üí option num
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] {X Y : C} [category_theory.simple X] [category_theory.simple Y] {f : X ‚ü∂ Y} (w : f ‚â† 0) : category_theory.is_iso f
{p : ‚Ñï} {G : Type u_1} [group G] (hG : is_p_group p G) [hp : fact (nat.prime p)] (Œ± : Type u_2) [mul_action G Œ±] [fintype Œ±] [fintype ‚Ü•(mul_action.fixed_points G Œ±)] : fintype.card Œ± ‚â° fintype.card ‚Ü•(mul_action.fixed_points G Œ±) [MOD p]
{M : Type u_3} {N : Type u_4} {P : Type u_5} [mul_zero_one_class M] [mul_zero_one_class N] [mul_zero_one_class P] (hnp : N ‚Üí*‚ÇÄ P) (hmn : M ‚Üí*‚ÇÄ N) : M ‚Üí*‚ÇÄ P
(C : Type u) [category_theory.category C] : (category_theory.simplicial_object C)·µí·µñ ‚âå category_theory.cosimplicial_object C·µí·µñ
 : category_theory.limits.preserves_limits_of_size (category_theory.forget CommRing)
{Œ± : Type u_1} [measurable_space Œ±] : measurable_space (measure_theory.measure Œ±)
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] [category_theory.simple 0] : false
{R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0) : is_add_right_regular a
 : ‚Ü•circle ‚âÉ ‚Ü•(set.Ioc (-real.pi) real.pi)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (l : Œ± ‚Üí Œ≤) (u : Œ≤ ‚Üí Œ±) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_group Œ±] [add_comm_group Œ≤] {f g : Œ± ‚Üí Œ≤} (hf : is_add_group_hom f) (hg : is_add_group_hom g) : is_add_group_hom (Œª (a : Œ±), f a + g a)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] (f : bounded_continuous_function Œ± Œ≤) (s : set Œ±) : bounded_continuous_function ‚Ü•s Œ≤
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_binary_biproduct X Y] : X ‚ü∂ X ‚äû Y
 : tactic unit
{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G ‚Üí ¬¨monoid.is_torsion G
(k : Type u) [field k] : Type u
{n : ‚Ñï} {Œ± : fin n ‚Üí Type u} {Œ±' : fin n ‚Üí Type v} (a : d_array n Œ±) (f : Œ† (i : fin n), Œ± i ‚Üí Œ±' i) : d_array n Œ±'
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C·µí·µñ} (c : category_theory.limits.cone F.left_op) : category_theory.limits.cocone F
{Œπ : Type u_1} {R : Type u_2} (S : Type u_3) {M : Œπ ‚Üí Type u_4} {N : Type u_5} [dec_Œπ : decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] [add_comm_monoid N] [module R N] [semiring S] [module S N] [smul_comm_class R S N] (F : Œ† (i : Œπ), M i ‚Üí‚Çó[R] N) (i : Œπ) (x : M i) : ‚áë(‚áë(dfinsupp.lsum S) F) (dfinsupp.single i x) = ‚áë(F i) x
{Œ± : Type u_1} {g g' : generalized_continued_fraction Œ±} : g = g' ‚Üî g.h = g'.h ‚àß g.s = g'.s
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Prop
{Œ≥ : Type} (tooltip_component : widget.tc subexpr (widget_override.interactive_expression.action Œ≥)) (click_address select_address : option expr.address) : subexpr ‚Üí widget_override.interactive_expression.sf ‚Üí tactic (list (widget.html (widget_override.interactive_expression.action Œ≥)))
(V : Type (u+1)) [category_theory.large_category V] [category_theory.monoidal_category V] (H : Group) [category_theory.right_rigid_category V] : category_theory.right_rigid_category (Action V ‚ÜëH)
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) [decidable_rel r] [is_trans Œ± r] [is_antisymm Œ± r] [is_total Œ± r] (s : multiset Œ±) : list Œ±
{X : Top} {Œπ : Type v} {U : Œπ ‚Üí topological_space.opens ‚Ü•X} (V : Top.presheaf.sheaf_condition.opens_le_cover U) : V.val ‚ü∂ U V.index
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (F : C ‚•§ D) (G : D ‚•§ E) : C ‚•§ E
{V : Type u} {G : simple_graph V} {Œ± : Type v} [fintype Œ±] {n : ‚Ñï} (hc : G.colorable n) (hn : n ‚â§ fintype.card Œ±) : G.coloring Œ±
{Œ± : Type} : tactic.unsafe.type_context Œ± ‚Üí tactic.unsafe.type_context (option Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] (F G : category_theory.lax_monoidal_functor C D) : Type (max u‚ÇÅ v‚ÇÇ)
{C : pgame ‚Üí Sort u_2} (x : pgame) (IH : Œ† (y : pgame), (Œ† (i : y.left_moves), C (y.move_left i)) ‚Üí (Œ† (j : y.right_moves), C (y.move_right j)) ‚Üí C y) : C x
 : Type u ‚•§ Group
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (ùíÆ : set (category_theory.sieve X)) : category_theory.sieve X
{a : ‚Ñù} {l : filter ‚Ñù} {f f' g g' : ‚Ñù ‚Üí ‚Ñù} (hff' : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.Ioi a), has_deriv_at f (f' x) x) (hgg' : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.Ioi a), has_deriv_at g (g' x) x) (hg' : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.Ioi a), g' x ‚â† 0) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.Ioi a)) (nhds 0)) (hdiv : filter.tendsto (Œª (x : ‚Ñù), f' x / g' x) (nhds_within a (set.Ioi a)) l) : filter.tendsto (Œª (x : ‚Ñù), f x / g x) (nhds_within a (set.Ioi a)) l
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : filter Œπ} [topological_space Œ±] (h : tendsto_locally_uniformly F f p) (hc : ‚àÄ·∂† (n : Œπ) in p, continuous (F n)) [p.ne_bot] : continuous f
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] {Œπ : Type u_3} (s : finset Œπ) (f : Œπ ‚Üí S) : ‚àÉ (b : ‚Ü•M), ‚àÄ (i : Œπ), i ‚àà s ‚Üí is_localization.is_integer R (‚Üëb ‚Ä¢ f i)
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Ü™o Œ≤) : has_lt.lt ‚Ü™r has_lt.lt
{R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [fintype M] [decidable_eq M‚ÇÇ] [ring_hom_surjective œÑ‚ÇÅ‚ÇÇ] (f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ) : fintype ‚Ü•(f.range)
{R : Type u} [comm_monoid R] [star_semigroup R] : star_module R R
(ùïú : Type u_1) (E : Type u_2) [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] (v : fin 1 ‚Üí E) : ‚áë(formal_multilinear_series.id ùïú E 1) v = v 0
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : algebraic_geometry.PresheafedSpace C} (Œ± Œ≤ : X ‚ü∂ Y) (h‚ÇÅ : Œ± = Œ≤) (x x' : ‚Ü•X) (h‚ÇÇ : x = x') : algebraic_geometry.PresheafedSpace.stalk_map Œ± x ‚â´ category_theory.eq_to_hom _ = category_theory.eq_to_hom _ ‚â´ algebraic_geometry.PresheafedSpace.stalk_map Œ≤ x'
 : simps_cfg
{n : ‚Ñï} (x y : bitvec n) : Prop
(R : Type u_1) (A : Type u_2) [comm_semiring R] [comm_semiring A] [algebra R A] (M : Type u_3) [add_comm_monoid M] [module A M] [module R M] : Type (max u_2 u_3)
{M : Type u_3} {N : Type u_4} {hM : mul_one_class M} {hN : mul_one_class N} (f : M ‚Üí* N) (f' : M ‚Üí N) (h : f' = ‚áëf) : M ‚Üí* N
 : tactic.local_cache.internal.cache_scope
{G : Type u_1} [group G] (H : subgroup G) [H.normal] [h : group.is_nilpotent G] : group.is_nilpotent (G ‚ß∏ H)
(q : interactive.parse interactive.types.texpr) : tactic unit
 : cc_state ‚Üí expr ‚Üí expr ‚Üí tactic bool
 : Type
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F : J ‚•§ C} [category_theory.limits.has_colimit F] (t : category_theory.limits.colimit_cocone F) : category_theory.limits.colimit F ‚âÖ t.cocone.X
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] [preorder Œ±] [preorder Œ≤] {f g : Œ≤ ‚Üí Œ±} [covariant_class Œ± Œ± has_add.add has_le.le] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] (hf : strict_mono f) (hg : monotone g) : strict_mono (Œª (x : Œ≤), f x + g x)
{t : Type u ‚Üí Type u} {Œ± : Type u} {f : Type u ‚Üí Type u} [applicative f] [traversable t] : t (f Œ±) ‚Üí f (t Œ±)
{M : Type uM} {N : Type uN} {P : Type uP} [mul_one_class M] [mul_one_class N] [comm_monoid P] (f : M ‚Üí* N) : (N ‚Üí* P) ‚Üí* M ‚Üí* P
{Œ± : Type u_2} [add_comm_monoid Œ±] : add_comm_monoid (set Œ±)
{k : Type u_1} {P‚ÇÅ : Type u_2} {P‚ÇÇ : Type u_3} {V‚ÇÅ : Type u_6} {V‚ÇÇ : Type u_7} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] (e : P‚ÇÅ ‚Üí P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (p : P‚ÇÅ) (h : ‚àÄ (p' : P‚ÇÅ), e p' = ‚áëe' (p' -·µ• p) +·µ• e p) : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} (t : category_theory.limits.fork f g) (lift : Œ† (s : category_theory.limits.fork f g), s.X ‚ü∂ t.X) (fac : ‚àÄ (s : category_theory.limits.fork f g), lift s ‚â´ t.Œπ = s.Œπ) (uniq : ‚àÄ (s : category_theory.limits.fork f g) (m : s.X ‚ü∂ t.X), m ‚â´ t.Œπ = s.Œπ ‚Üí m = lift s) : category_theory.limits.is_limit t
(ùïú : Type u_1) {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (x : E) : Prop
{Œ± : Type u_1} [complete_lattice Œ±] {s : set Œ±} {b : Œ±} : (‚àÄ (a : Œ±), a ‚àà s ‚Üí b ‚â§ a) ‚Üí (‚àÄ (w : Œ±), b < w ‚Üí (‚àÉ (a : Œ±) (H : a ‚àà s), a < w)) ‚Üí has_Inf.Inf s = b
{C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] {F : J ‚•§ C} {c‚ÇÅ : category_theory.limits.fan F.obj} {c‚ÇÇ : category_theory.limits.fan (Œª (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), F.obj f.fst.snd)} (s t : c‚ÇÅ.X ‚ü∂ c‚ÇÇ.X) (hs : ‚àÄ (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), s ‚â´ c‚ÇÇ.œÄ.app {as := f} = c‚ÇÅ.œÄ.app {as := f.fst.fst} ‚â´ F.map f.snd) (ht : ‚àÄ (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), t ‚â´ c‚ÇÇ.œÄ.app {as := f} = c‚ÇÅ.œÄ.app {as := f.fst.snd}) (i : category_theory.limits.fork s t) : category_theory.limits.cone F
(q : interactive.parse interactive.types.texpr) : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.limits.reflects_limits_of_size F] : category_theory.limits.reflects_limits_of_size G
(Œ± : Type u_2) [complete_lattice Œ±] : complete_lattice_hom Œ± Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] [densely_ordered Œ≤] {f : Œ± ‚Üí Œ≤} (h_mono : monotone f) (h_dense : dense_range f) : continuous f
(p : interactive.parse interactive.types.texpr) : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] (e : C ‚âå C) : ‚Ñï ‚Üí (C ‚âå C)
 : has_one pgame
 : tactic.ring_exp.ex tactic.ring_exp.ex_type.exp ‚Üí tactic.ring_exp.ex tactic.ring_exp.ex_type.prod ‚Üí tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.exp)
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] : (Œ± √ó Œ≤) √ó Œ≥ ‚âÉ‚Çú Œ± √ó Œ≤ √ó Œ≥
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} (h : s ‚äÜ t) (ht : metric.bounded t) : metric.diam s ‚â§ metric.diam t
{Œ± : Type u_1} (s : finset Œ±) : finset {x // x ‚àà s}
{K : Type u} {L : Type v} [field K] [field L] (f g : K ‚Üí+* L) : subfield K
(tm : turing.fin_tm2) : Type
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) (c : category_theory.limits.cocone (K ‚ãô F)) (t : category_theory.limits.is_colimit c) : Type (max u‚ÇÅ v‚ÇÅ v‚ÇÇ w)
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) (k : S.localization_map P) : N ‚âÉ* P
{Œ± : Type u_1} [fintype Œ±] (f : Œ± ‚Üí nnreal) (h : finset.univ.sum (Œª (a : Œ±), f a) = 1) : pmf Œ±
(C : Type u‚ÇÅ) [category_theory.category C] : category_theory.comonad C
{X : Type u_1} [topological_space X] [normal_space X] : ‚Ñï ‚Üí urysohns.CU X ‚Üí X ‚Üí ‚Ñù
{n : ‚Ñï} (F : arity Set n) : pSet.definable n F
{Œπ : Sort u_1} {f : Œπ ‚Üí ennreal} {x : ennreal} (h0 : x ‚â† 0) (h : x ‚â† ‚ä§) : x * infi f = ‚®Ö (i : Œπ), x * f i
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (f : M ‚Üí‚Çô* N) (N' : subsemigroup N) : ‚Ü•(subsemigroup.comap f N') ‚Üí‚Çô* ‚Ü•N'
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [decidable_eq Œ±] (f : associates Œ± ‚Üí* Œ±) (hinv : function.right_inverse ‚áëf associates.mk) : normalization_monoid Œ±
{V : Type u} {G : simple_graph V} (M : G.subgraph) : Prop
{Œ± : Type u_2} [add_comm_semigroup Œ±] : add_comm_semigroup (filter Œ±)
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (h : M ‚âÉ+ N) : is_add_hom ‚áëh
 : ordinal ‚âÉo nat_ordinal
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ±) : ‚Ñï ‚Üí Œ± ‚Üí list Œ≤ ‚Üí Œ±
(C : Type u) [category_theory.category C] (n : ‚Ñï) : Type (max v u)
(n : name) (k : ‚Ñï) : tactic string
{M : Type uM} {N : Type uN} [add_zero_class M] [add_comm_monoid N] : add_comm_monoid (M ‚Üí+ N)
{M : Type u_1} [has_add M] (c : add_con M) {w x y z : M} : ‚áëc w x ‚Üí ‚áëc y z ‚Üí ‚áëc (w + y) (x + z)
{n : ‚Ñï} : group (quaternion_group n)
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.initial] (d : D) : C
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] {Z : D} (F : C ‚•§ D) (M : Œ† (x : C), F.obj x ‚ü∂ Z) (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), F.map f ‚â´ M y = M x) : category_theory.with_terminal.incl ‚ãô category_theory.with_terminal.lift F M hM ‚âÖ F
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {S : Type w} [comm_semiring S] [category_theory.linear S C] (X Y Z : C) : (X ‚ü∂ Y) ‚Üí‚Çó[S] (Y ‚ü∂ Z) ‚Üí‚Çó[S] X ‚ü∂ Z
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} (hs : topological_space.is_separable s) : topological_space.separable_space ‚Ü•s
{R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {n : ‚Ñï} (H : ‚àÄ (s : finset M), linear_independent R (Œª (i : ‚Ü•s), ‚Üëi) ‚Üí s.card ‚â§ n) (s : set M) : linear_independent R coe ‚Üí cardinal.mk ‚Ü•s ‚â§ ‚Üën
{R : Type u} [ring R] {S T : subring R} (h : ‚àÄ (x : R), x ‚àà S ‚Üî x ‚àà T) : S = T
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) (R : Type u_1) [has_scalar R Œ≤] : has_scalar R Œ±
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ‚àà S ‚Üí y ‚àà S ‚Üí x + y ‚àà S
 : pgame ‚Üí ordinal
 : tactic.ring_exp.ring_exp_m tactic.ring_exp.context
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {c‚ÇÅ c‚ÇÇ : Œ± √ó Œ≤} (p : path.homotopic.quotient c‚ÇÅ c‚ÇÇ) : path.homotopic.quotient c‚ÇÅ.snd c‚ÇÇ.snd
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] (D : Type u‚ÇÇ) [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (X : C) : Type (max u v)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí. Œ≤) : set (Œ± √ó Œ≤)
{Œ± : Sort u} : well_founded empty_relation
{n : ‚Ñï} {F : Type u ‚Üí Type u} [applicative F] {Œ± Œ≤ : Type u} (f : Œ± ‚Üí F Œ≤) : vector Œ± n ‚Üí F (vector Œ≤ n)
{Œ± : Type u} {G : Type w} [topological_space G] [has_inv G] [has_continuous_inv G] {f : Œ± ‚Üí G} {l : filter Œ±} {y : G} (h : filter.tendsto f l (nhds y)) : filter.tendsto (Œª (x : Œ±), (f x)‚Åª¬π) l (nhds y‚Åª¬π)
{Œ± : Type u_1} {Œπ : Type u_2} {x : Œπ ‚Üí Œ±} {f : filter Œ±} {l : filter Œπ} [l.is_countably_generated] (hxy : ‚àÄ (ns : ‚Ñï ‚Üí Œπ), filter.tendsto ns filter.at_top l ‚Üí (‚àÉ (ms : ‚Ñï ‚Üí ‚Ñï), filter.tendsto (Œª (n : ‚Ñï), x (ns (ms n))) filter.at_top f)) : filter.tendsto x l f
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Œπ ‚Üí M} [ring R] [add_comm_group M] [module R M] (hv : linear_independent R v) : ‚Ü•(submodule.span R (set.range v)) ‚Üí‚Çó[R] Œπ ‚Üí‚ÇÄ R
{x : pgame} (h : x ‚â§ 0) (i : x.left_moves) : (x.move_left i).right_moves
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (Œ∏ : real.angle) : V ‚âÉ‚Çó·µ¢[‚Ñù] V
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f g : Œ± ‚Üí M} {s : set Œ±} (hf : (s ‚à© function.support f).finite) (hg : (s ‚à© function.support g).finite) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i + g i)) = finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)) + finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), g i))
 : expr ‚Üí tactic expr
{Œ± : Type u} (xs : list Œ±) (pos : 0 < xs.length) : slim_check.gen Œ±
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (G : D ‚•§ C) [category_theory.limits.has_limits D] [category_theory.limits.preserves_limits G] (hG : category_theory.solution_set_condition G) : category_theory.is_right_adjoint G
{ùïú : Type u_3} [field ùïú] {r : ‚Ñï} (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) (i : fin r ‚äï unit) : M.mul (matrix.pivot.list_transvec_row M).prod i (sum.inr ()) = M i (sum.inr ())
{V : Type (u+1)} [category_theory.large_category V] {G : Mon} : (category_theory.single_obj ‚Ü•G ‚•§ V) ‚•§ Action V G
 : linarith.global_branching_preprocessor
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [has_zero N] (f : zero_hom M N) : zero_hom (Œ± ‚Üí‚ÇÄ M) (Œ± ‚Üí‚ÇÄ N)
{Œ≤ : Type w} {C : Type u} [category_theory.category C] {f : Œ≤ ‚Üí C} (p : category_theory.limits.fan f) (j : Œ≤) : p.X ‚ü∂ f j
{Œ± : Type u_1} {n : ‚Ñï} [decidable_eq Œ±] (s : sym Œ± (n + 1)) (a : Œ±) (h : a ‚àà s) : sym Œ± n
{V : Type u} {G : simple_graph V} : G ‚Ü™g G
(Œ± : Type u_1) [group_with_zero Œ±] : GroupWithZero
{Œ± : Type u_2} {Œ≤ : Type u_3} [complete_lattice Œ±] [complete_lattice Œ≤] (f : complete_lattice_hom Œ± Œ≤) : bounded_lattice_hom Œ± Œ≤
(Œ± : Type u) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] {z : ‚ÑÇ} {f : ‚ÑÇ ‚Üí E} (h : differentiable_at ‚ÑÇ f z) (hf' : deriv f z ‚â† 0) : conformal_at f z
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : module.is_torsion_by R M a ‚Üî submodule.torsion_by R M a = ‚ä§
{Œ± : Type u} [linear_ordered_ring Œ±] {Œ≤ : Type u_1} [has_zero Œ≤] [has_one Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ≤), f (-x) = -f x) (sub : ‚àÄ (x y : Œ≤), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : linear_ordered_ring Œ≤
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] (X : Top) : (Top.presheaf.Sheaf_spaces_equiv_sheaf_sites C X).inverse ‚ãô category_theory.Sheaf_to_presheaf (opens.grothendieck_topology ‚Ü•X) C ‚âÖ Top.sheaf.forget C X
 : Type
{R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] (e‚ÇÅ e‚ÇÇ : basis Œπ R M) : e‚ÇÅ.orientation = e‚ÇÇ.orientation ‚Üî 0 < ‚áë(e‚ÇÅ.det) ‚áëe‚ÇÇ
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} (‚Ñ± : Top.presheaf C X) (x : ‚Ü•X) : C
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.cartesian_closed C] [category_theory.limits.has_zero_object C] (X Y : C) : unique (X ‚ü∂ Y)
{Œ± : Type u} {l : list Œ±} : l.attach.nodup ‚Üí l.nodup
{E : Type u} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {a : E} {s : set E} (h : is_local_max_on f s a) {y : E} (hy : y ‚àà pos_tangent_cone_at s a) (hy' : -y ‚àà pos_tangent_cone_at s a) : ‚áë(fderiv_within ‚Ñù f s a) y = 0
{A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ‚áë(polynomial.aeval r) p = 0) : is_fraction_ring.num A r ‚à£ p.coeff 0
{ùïú : Type u} [hnorm : nondiscrete_normed_field ùïú] {E : Type v} [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_smul ùïú E] [complete_space ùïú] [t2_space E] [finite_dimensional ùïú E] (f : E ‚ÜíL[ùïú] E) (hf : f.det ‚â† 0) : E ‚âÉL[ùïú] E
 : omega.int.exprterm ‚Üí list expr
{Œ± : Type u_1} [topological_space Œ±] : inhabited (topological_space.closeds Œ±)
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {X : category_theory.simplicial_object C} (q n m : ‚Ñï) : algebraic_topology.dold_kan.c.rel m n ‚Üí ((algebraic_topology.alternating_face_map_complex.obj X).X n ‚ü∂ (algebraic_topology.alternating_face_map_complex.obj X).X m)
 : native.float
{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_3} {V‚ÇÉ : Type u_4} [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] [semi_normed_group V‚ÇÉ] (g : normed_group_hom V‚ÇÇ V‚ÇÉ) (f : normed_group_hom V‚ÇÅ V‚ÇÇ) : normed_group_hom V‚ÇÅ V‚ÇÉ
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] (F : A ‚•§ B) (G : C ‚•§ D) : A √ó C ‚•§ B √ó D
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) : Prop
{Œ± : Type u} (P : Œ± ‚Üí Prop) : ordnode Œ± ‚Üí Prop
 : omega.int.preform ‚Üí omega.int.preform
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (S : subalgebra R A) (HS : S.to_submodule.fg) (x : A) (hx : x ‚àà S) : is_integral R x
{Œ± : Type u_2} [decidable_eq Œ±] [comm_monoid Œ±] : comm_monoid (finset Œ±)
{A : Type u_1} {B : Type u_2} (R : Type u_3) [semiring R] [add_comm_monoid A] [add_comm_monoid B] [module R B] : (A ‚Üí+ B) ‚âÉ‚Çó[R] A ‚Üí‚Çó[‚Ñï] B
{R : Type u} [comm_ring R] (U V : topological_space.opens ‚Ü•(algebraic_geometry.prime_spectrum.Top R)) (iVU : V ‚ü∂ U) : algebraic_geometry.structure_sheaf.comap (ring_hom.id R) U V _ = (algebraic_geometry.Spec.structure_sheaf R).val.map iVU.op
{M : Type u_1} [add_comm_monoid M] {s t : set M} {x : M} : x ‚àà add_monoid.closure (s ‚à™ t) ‚Üî ‚àÉ (y : M) (H : y ‚àà add_monoid.closure s) (z : M) (H : z ‚àà add_monoid.closure t), y + z = x
{Œ± : Type u_1} (s : cycle Œ±) : Prop
{Œ± : Type u} [pseudo_emetric_space Œ±] {Œ¥ : ‚Ñù} {E : set Œ±} : is_open (metric.thickening Œ¥ E)
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] (a : Œ±) : Œ± ‚âÉo Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) : Œ≤ ‚Üí Œ±
 : list expr ‚Üí tactic (list linarith.branch)
(u : pnat.xgcd_type) (hr : u.r ‚â† 0) : u.step.v = u.v.swap
(c : turing.to_partrec.code) (k : turing.partrec_to_TM2.cont') : finset turing.partrec_to_TM2.Œõ'
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [normalization_monoid Œ±] [decidable_eq Œ±] (lcm : Œ± ‚Üí Œ± ‚Üí Œ±) (dvd_lcm_left : ‚àÄ (a b : Œ±), a ‚à£ lcm a b) (dvd_lcm_right : ‚àÄ (a b : Œ±), b ‚à£ lcm a b) (lcm_dvd : ‚àÄ {a b c : Œ±}, c ‚à£ a ‚Üí b ‚à£ a ‚Üí lcm c b ‚à£ a) (normalize_lcm : ‚àÄ (a b : Œ±), ‚áënormalize (lcm a b) = lcm a b) : normalized_gcd_monoid Œ±
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) (P : Type u_6) [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] : (M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] P) ‚âÉ‚Çó[R] tensor_product R M N ‚Üí‚Çó[R] P
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ‚äÜ span_points k s
{F‚ÇÇ : Type u ‚Üí Type u} [functor F‚ÇÇ] [q‚ÇÇ : qpf F‚ÇÇ] {F‚ÇÅ : Type u ‚Üí Type u} [functor F‚ÇÅ] [q‚ÇÅ : qpf F‚ÇÅ] : qpf (functor.comp F‚ÇÇ F‚ÇÅ)
{Œ± : Type u_1} [preorder Œ±] [succ_order Œ±] {a b : Œ±} [no_max_order Œ±] : order.succ a < order.succ b ‚Üí a < b
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] [decidable_rel disjoint] [decidable_rel has_le.le] {s : finset Œ±} {u v a : Œ±} (ha : a ‚àà uv.compression u v s) (hva : v ‚â§ a) (hvu : v = ‚ä• ‚Üí u = ‚ä•) : a ‚àà s
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_coequalizers C] [category_theory.limits.has_coproducts C] (G : C ‚•§ D) [category_theory.limits.preserves_colimits_of_shape category_theory.limits.walking_parallel_pair G] [Œ† (J : Type v), category_theory.limits.preserves_colimits_of_shape (category_theory.discrete J) G] : category_theory.limits.preserves_colimits G
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] {f : ‚ÑÇ ‚Üí E} (hd : diff_cont_on_cl ‚ÑÇ f (set.Iio 0 √ó‚ÑÇ set.Ioi 0)) (hB : ‚àÉ (c : ‚Ñù) (H : c < 2) (B : ‚Ñù), f =O[filter.comap complex.abs filter.at_top ‚äì filter.principal (set.Iio 0 √ó‚ÑÇ set.Ioi 0)] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)) (hre : ‚àÄ (x : ‚Ñù), x ‚â§ 0 ‚Üí f ‚Üëx = 0) (him : ‚àÄ (x : ‚Ñù), 0 ‚â§ x ‚Üí f (‚Üëx * complex.I) = 0) : set.eq_on f 0 {z : ‚ÑÇ | z.re ‚â§ 0 ‚àß 0 ‚â§ z.im}
{Œ± : Type u_3} {Œ≤ : Type u_4} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : monotone f) (h : ‚àÄ (b : Œ≤), ‚àÉ (a : Œ±), b ‚â§ f a) : filter.tendsto f filter.at_top filter.at_top
{Œì : Type u_1} [inhabited Œì] {Œ± : Sort u_2} (l : turing.list_blank Œì) (f : list Œì ‚Üí Œ±) (H : ‚àÄ (a b : list Œì), turing.blank_extends a b ‚Üí f a = f b) : Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {P Q : C} (f : P ‚ü∂ Q) : category_theory.abelian.coimage f ‚ü∂ category_theory.abelian.image f
{Œ≥ : Type} : expr ‚Üí tactic (list (widget.html (widget_override.interactive_expression.action Œ≥)))
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} : differentiable ùïú f ‚Üí mdifferentiable (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f
{Œ± : Type u_1} [linear_ordered_field Œ±] {a : Œ±} (a2 : 2 ‚â§ a) : (1 - 1 / a)‚Åª¬π ‚â§ 2
{C : Type u} [category_theory.category C] (f : category_theory.arrow C) [category_theory.limits.has_image f.hom] : category_theory.limits.image_map (ùüô f)
 : expr ‚Üí ‚Ñï ‚Üí list expr ‚Üí expr
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (R : D ‚•§ C) [category_theory.limits.has_limits_of_size C] [category_theory.reflective R] : category_theory.limits.has_limits_of_size D
(cfg : linarith.linarith_config) : list expr ‚Üí tactic expr
{R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} {s : S} [has_scalar R M] [has_scalar R S] [has_scalar S M] [is_scalar_tower R S M] (ra : is_smul_regular M a) (rs : is_smul_regular M s) : is_smul_regular M (a ‚Ä¢ s)
(B : Type u) : Type (max u (v+1) (w+1))
{R : Type u_1} [comm_ring R] (S : submonoid R) {P : Type u_2} [comm_ring P] [algebra R P] [loc : is_localization S P] (x : P) (hx : is_integral R x) : fractional_ideal S P
{n : ‚Ñï} (F : typevec (n + 1) ‚Üí Type u_1) [mvfunctor F] [q : mvqpf F] (Œ± : typevec n) : Type u_1
{G : Type u} [group G] (H : subgroup G) (h : subsingleton (G ‚ß∏ H)) : H = ‚ä§
 : CompHaus ‚•§ Profinite
(D : algebraic_geometry.Scheme.glue_data) : algebraic_geometry.Scheme
{Œ± : Type u_1} {n : Type u_3} {m : Type u_4} {A : matrix m m Œ±} {B : matrix m n Œ±} {C : matrix n m Œ±} {D : matrix n n Œ±} (hA : A.is_symm) (hBC : B.transpose = C) (hD : D.is_symm) : (matrix.from_blocks A B C D).is_symm
{Œ± : Type u_1} (f : list Œ± ‚Üí list Œ±) : ‚Ñï ‚Üí list Œ± ‚Üí list Œ±
{X : Type u_1} {Y : Type u_2} [topological_space X] [add_zero_class Y] : locally_constant X Y ‚Üí+ X ‚Üí Y
{M : Type u_1} [semigroup M] {a : stream M} {m : M} (hm : m ‚àà hindman.FP a) : ‚àÉ (n : ‚Ñï), ‚àÄ (m' : M), m' ‚àà hindman.FP (stream.drop n a) ‚Üí m * m' ‚àà hindman.FP a
 : expr ‚Üí list name
(n : ‚Ñï+) (K : Type w) [field K] : Type w
(M : Type u_2) [has_mul M] : group (mul_aut M)
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (Œ∏ : real.angle) : hb.oangle x y = Œ∏ ‚Üî ‚àÉ (r : ‚Ñù), 0 < r ‚àß y = r ‚Ä¢ ‚áë(hb.rotation Œ∏) x
 : tactic unit
{ùïú : Type u_1} {E : Type u_2} [linear_ordered_field ùïú] [ordered_add_comm_group E] [module ùïú E] {s : set E} (hs : convex ùïú s) : is_least {t : convex_cone ùïú E | s ‚äÜ ‚Üët} (convex.to_cone s hs)
{Œ± : Type} (tac : tactic Œ±) : expr ‚Üí tactic (Œ± √ó list (tactic.tactic_script Œ±))
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {n : ‚Ñï} {f : ùïú ‚Üí F} {s : set ùïú} {x : ùïú} {m : fin n ‚Üí ùïú} : ‚áë(iterated_fderiv_within ùïú n f s x) m = finset.univ.prod (Œª (i : fin n), m i) ‚Ä¢ iterated_deriv_within n f s x
(red : tactic.transparency) : list (expr √ó ‚Ñï) ‚Üí expr ‚Üí tactic (list (expr √ó ‚Ñï) √ó linarith.sum)
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : category_theory.limits.walking_cospan ‚•§ C
{F : Type u_3} [inner_product_space ‚Ñù F] : bilin_form ‚Ñù F
(X : Type v) [topological_space X] : Prop
(Œ± : Type u) [ring Œ±] : Prop
{Œ± : Type u_1} [Œ≤ : normed_comm_ring Œ±] : semi_normed_comm_ring Œ±
 : Type (u_1+1)
(c : ‚ÑÇ) : ‚áëclifford_algebra_complex.of_complex (‚áë(star_ring_end ‚ÑÇ) c) = ‚áëclifford_algebra.involute (‚áëclifford_algebra_complex.of_complex c)
(tm : turing.fin_tm2) (s : list (tm.Œì tm.k‚ÇÄ)) : tm.cfg
(R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] (x : M) : R ‚Üí‚Çó[R] M
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (f : V ‚âÉ‚Çó·µ¢[‚Ñù] V) : ‚àÉ (Œ∏ : real.angle), f = hb.rotation Œ∏ ‚à® f = hb.conj_lie.trans (hb.rotation Œ∏)
(e : pexpr) : tactic unit
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] : add_hom M·µÉ·µí·µñ N·µÉ·µí·µñ ‚âÉ add_hom M N
{Œ± : Type u_1} [preorder Œ±] (a b : Œ±) : Prop
{Œπ : Type u} (s : finset Œπ) (w z : Œπ ‚Üí nnreal) (hw' : s.sum (Œª (i : Œπ), w i) = 1) : s.prod (Œª (i : Œπ), z i ^ ‚Üë(w i)) ‚â§ s.sum (Œª (i : Œπ), w i * z i)
(R : Type u) (M : Type v) (M‚ÇÇ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] : M ‚Üí‚Çó[R] M √ó M‚ÇÇ
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (h : is_empty Œ±) (a : Œ±) : Œ≤
{x : ‚Ñù} (lx : liouville x) : transcendental ‚Ñ§ x
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.abelian C] [category_theory.has_injective_resolutions C] [category_theory.abelian D] (F : C ‚•§ D) [F.additive] (X : C) [category_theory.injective X] : (F.right_derived 0).obj X ‚âÖ F.obj X
{f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} (hfi : interval_integrable f measure_theory.measure_space.volume a b) (h : ‚àÄ (x : ‚Ñù), 0 < f x) (hab : a < b) : 0 < ‚à´ (x : ‚Ñù) in a..b, f x
{R : Type u} [ring R] {X‚ÇÅ X‚ÇÇ : Type v} {g‚ÇÅ : add_comm_group X‚ÇÅ} {g‚ÇÇ : add_comm_group X‚ÇÇ} {m‚ÇÅ : module R X‚ÇÅ} {m‚ÇÇ : module R X‚ÇÇ} (e : X‚ÇÅ ‚âÉ‚Çó[R] X‚ÇÇ) : Module.of R X‚ÇÅ ‚âÖ Module.of R X‚ÇÇ
{Œ± : Type u_1} [decidable_eq Œ±] (l : list Œ±) : finset Œ±
{A B C D B' D' : SemiNormedGroup} {fab : A ‚ü∂ B} {fbd : B ‚ü∂ D} {fac : A ‚ü∂ C} {fcd : C ‚ü∂ D} {h : fab ‚â´ fbd = fac ‚â´ fcd} {fbb' : B ‚ü∂ B'} {fdd' : D ‚ü∂ D'} {condb : fab ‚â´ fbb' = 0} {condd : fcd ‚â´ fdd' = 0} {g : B' ‚ü∂ D'} (h' : fbb' ‚â´ g = fbd ‚â´ fdd') : SemiNormedGroup.explicit_cokernel_desc condb ‚â´ g = SemiNormedGroup.explicit_cokernel.map h ‚â´ SemiNormedGroup.explicit_cokernel_desc condd
{R : Type u_1} [semiring R] (p : polynomial R) : ‚áëpolynomial.to_laurent p = finsupp.map_domain coe p.to_finsupp
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] : ùü≠ (category_theory.lax_monoidal_functor (category_theory.discrete punit) C) ‚âÖ Mon_.equiv_lax_monoidal_functor_punit.lax_monoidal_to_Mon C ‚ãô Mon_.equiv_lax_monoidal_functor_punit.Mon_to_lax_monoidal C
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ‚Ñù E] [normed_group F] [normed_space ‚Ñù F] {f : E ‚Üí F} {p : E ‚Üí formal_multilinear_series ‚Ñù E F} {s : set E} {x : E} (hf : has_ftaylor_series_up_to_on 1 f p (has_insert.insert x s)) (hs : convex ‚Ñù s) : ‚àÉ (K : nnreal) (t : set E) (H : t ‚àà nhds_within x s), lipschitz_on_with K f t
{J : Type v} [category_theory.small_category J] {A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] {L : A ‚•§ T} {R : B ‚•§ T} (F : J ‚•§ category_theory.comma L R) (c‚ÇÅ : category_theory.limits.cone (F ‚ãô category_theory.comma.fst L R)) : category_theory.limits.cone ((F ‚ãô category_theory.comma.snd L R) ‚ãô R)
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {m : M} {s : set M} : m ‚àà submodule.span R s ‚Üî ‚àÉ (c : M ‚Üí‚ÇÄ R), ‚Üë(c.support) ‚äÜ s ‚àß c.sum (Œª (mi : M) (r : R), r ‚Ä¢ mi) = m
{X : Type u_1} {Y : Type u_2} {f : X ‚Üí Y} (hf : function.injective f) : topological_space.induced f ‚ä• = ‚ä•
{Œ± : Type u_1} [lattice Œ±] [order_bot Œ±] {a b : Œ±} (P : finpartition a) (h : a = b) : finpartition b
{C : Type u‚ÇÅ} [category_theory.category C] {A B : C} (e : A ‚âÖ B) : category_theory.mono_over A ‚âå category_theory.mono_over B
{M : Type u} [add_monoid M] {N : Type u} [add_monoid N] (F : M ‚Üí+ N) : category_theory.monoidal_functor (category_theory.discrete M) (category_theory.discrete N)
(Œ± : Type u_1) : Type u_1
{Œ± : Type u_1} {f : Œ± ‚Üí ennreal} (hf : ‚àë' (x : Œ±), f x ‚â† ‚ä§) : filter.tendsto (Œª (s : finset Œ±), ‚àë' (b : {x // x ‚àâ s}), f ‚Üëb) filter.at_top (nhds 0)
{B : Type u_3} (E : B ‚Üí Type u_5) {B' : Type u_7} (f : B' ‚Üí B) [topological_space B'] [topological_space (bundle.total_space E)] : topological_space (bundle.total_space (f *·µñ E))
{R : Type u} [semiring R] {Œπ : Type v} [dec_Œπ : decidable_eq Œπ] {M : Type u_1} [add_comm_monoid M] [module R M] (A : Œπ ‚Üí submodule R M) : direct_sum Œπ (Œª (i : Œπ), ‚Ü•(A i)) ‚Üí‚Çó[R] M
(ùïú : Type u_1) (E : Type u_2) [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] {n : ‚Ñï} (h : n ‚â† 1) : formal_multilinear_series.id ùïú E n = 0
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [topological_space Œ±] [pseudo_metric_space Œ≤] [pseudo_metric_space Œ≥] {G : Œ≤ ‚Üí Œ≥} {C : nnreal} (H : lipschitz_with C G) : lipschitz_with C (bounded_continuous_function.comp G H)
{Œ± : Type u_3} [preorder Œ±] (n : ‚Ñï) [grade_min_order (fin n) Œ±] : grade_min_order ‚Ñï Œ±
{Œ± : Type u} (s : wseq Œ±) (n : ‚Ñï) : wseq Œ±
{Œì : Type u_1} [inhabited Œì] (l : turing.list_blank Œì) : turing.list_blank.cons l.head l.tail = l
{ùïú : Type u_1} {E : Type u_3} {F : Type u_4} [comm_ring ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] [add_comm_group F] [module ùïú F] [topological_space F] [topological_add_group F] [has_continuous_const_smul ùïú F] (p : formal_multilinear_series ùïú E F) : formal_multilinear_series ùïú E F
(R : Type u) [comm_ring R] (x : ‚Ü•(algebraic_geometry.prime_spectrum.Top R)) : CommRing.of R ‚ü∂ (algebraic_geometry.Spec.structure_sheaf R).val.stalk x
(Œ± : Type u_1) [uniform_space Œ±] : Type u_1
{G : Type u_1} [add_group G] {H : add_subgroup G} {N : Type u_3} [add_group N] (f : N ‚Üí+ G) : add_subgroup.comap f H.normalizer ‚â§ (add_subgroup.comap f H).normalizer
(R : Type u) [non_assoc_semiring R] : Type u
{R : Type u} [semiring R] (n : ‚Ñï) (a : R) : polynomial R
{X : Top} {x : ‚Ü•X} (p : fundamental_group ‚Ü•X x) : path.homotopic.quotient x x
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (Y Y' : C) [category_theory.exact_pairing Y Y'] : category_theory.monoidal_category.tensor_right Y ‚ä£ category_theory.monoidal_category.tensor_right Y'
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {v : ‚Ñù ‚Üí E ‚Üí E} {s : ‚Ñù ‚Üí set E} {K : ‚Ñù} (hv : ‚àÄ (t : ‚Ñù) (x : E), x ‚àà s t ‚Üí ‚àÄ (y : E), y ‚àà s t ‚Üí has_dist.dist (v t x) (v t y) ‚â§ K * has_dist.dist x y) {f g f' g' : ‚Ñù ‚Üí E} {a b Œµf Œµg Œ¥ : ‚Ñù} (hf : continuous_on f (set.Icc a b)) (hf' : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_deriv_within_at f (f' t) (set.Ici t) t) (f_bound : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_dist.dist (f' t) (v t (f t)) ‚â§ Œµf) (hfs : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí f t ‚àà s t) (hg : continuous_on g (set.Icc a b)) (hg' : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_deriv_within_at g (g' t) (set.Ici t) t) (g_bound : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí has_dist.dist (g' t) (v t (g t)) ‚â§ Œµg) (hgs : ‚àÄ (t : ‚Ñù), t ‚àà set.Ico a b ‚Üí g t ‚àà s t) (ha : has_dist.dist (f a) (g a) ‚â§ Œ¥) (t : ‚Ñù) (H : t ‚àà set.Icc a b) : has_dist.dist (f t) (g t) ‚â§ gronwall_bound Œ¥ K (Œµf + Œµg) (t - a)
 : Bipointed ‚•§ Bipointed
{M : Type u_1} [has_add M] {c d : add_con M} {x y : M} : ‚áë(c ‚äì d) x y ‚Üî ‚áëc x y ‚àß ‚áëd x y
{R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] [comm_ring B] [algebra R B] (hfp : algebra.finite_presentation R A) (e : A ‚âÉ‚Çê[R] B) : algebra.finite_presentation R B
(V : Type (u+1)) [category_theory.large_category V] (G : Mon) [category_theory.monoidal_category V] [category_theory.braided_category V] : category_theory.braided_functor (Action V G) V
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] (w : free_product.word M) (h : w ‚â† free_product.word.empty) : ‚àÉ (i j : Œπ) (w' : free_product.neword M i j), w'.to_word = w
{C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ‚Ñï} {i : fin (n + 2)} {j : fin (n + 1)} (H : i ‚â§ ‚áëfin.cast_succ j) : X.Œ¥ (‚áëfin.cast_succ i) ‚â´ X.œÉ j.succ = X.œÉ j ‚â´ X.Œ¥ i
{G : Type u_1} [add_comm_group G] (sets : set (set G)) (nonempty : sets.nonempty) (inter_sets : ‚àÄ (x y : set G), x ‚àà sets ‚Üí y ‚àà sets ‚Üí (‚àÉ (z : set G) (H : z ‚àà sets), z ‚äÜ x ‚à© y)) (one : ‚àÄ (U : set G), U ‚àà sets ‚Üí 0 ‚àà U) (mul : ‚àÄ (U : set G), U ‚àà sets ‚Üí (‚àÉ (V : set G) (H : V ‚àà sets), V + V ‚äÜ U)) (inv : ‚àÄ (U : set G), U ‚àà sets ‚Üí (‚àÉ (V : set G) (H : V ‚àà sets), V ‚äÜ (Œª (x : G), -x) ‚Åª¬π' U)) : add_group_filter_basis G
{Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) (b : B) : topological_fiber_bundle.trivialization F Z.proj
{M : Type u_5} [monoid M] {A : Type u_6} [add_monoid A] [distrib_mul_action M A] {B : Type u_8} [add_monoid B] [distrib_mul_action M B] {C : Type u_10} [add_monoid C] [distrib_mul_action M C] (g : B ‚Üí+[M] C) (f : A ‚Üí+[M] B) : A ‚Üí+[M] C
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] (e : A ‚âÉ‚Çê[R] B) (S : subalgebra R A) : ‚Ü•S ‚âÉ‚Çê[R] ‚Ü•(S.map e.to_alg_hom)
{K : Type u_1} [is_R_or_C K] : K ‚ÜíL[‚Ñù] ‚Ñù
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_zero_object C] [category_theory.limits.has_kernel f] [category_theory.limits.has_cokernel (category_theory.limits.kernel.Œπ f)] [category_theory.mono f] : category_theory.is_iso (category_theory.limits.cokernel.œÄ (category_theory.limits.kernel.Œπ f))
{Œ± : Type uu} (r : Œ± ‚Üí Œ± ‚Üí Prop) [decidable_rel r] : list Œ± ‚Üí list Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : free_add_monoid Œ± ‚Üí+ free_add_monoid Œ≤
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [finite_dimensional ùïú E] {n : ‚Ñï} (hn : finite_dimensional.finrank ùïú E = n) {Œπ : Type u_4} [fintype Œπ] [decidable_eq Œπ] {V : Œπ ‚Üí submodule ùïú E} (hV : direct_sum.is_internal V) : basis (fin n) ùïú E
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {n : with_top ‚Ñï} (hf : is_bounded_linear_map ùïú f) : cont_diff ùïú n f
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {w : Œ± ‚Üí M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (ht : ‚àÄ (y : Œ≤), y ‚àâ t ‚Üí 0 ‚â§ (finset.filter (Œª (x : Œ±), f x = y) s).sum (Œª (x : Œ±), w x)) (hb : s.sum (Œª (x : Œ±), w x) < t.card ‚Ä¢ b) : ‚àÉ (y : Œ≤) (H : y ‚àà t), (finset.filter (Œª (x : Œ±), f x = y) s).sum (Œª (x : Œ±), w x) < b
{A : Type u_1} [comm_ring A] [algebra ‚Ñö A] (k : ‚Ñï) : power_series.exp A ^ k = ‚áë(power_series.rescale ‚Üëk) (power_series.exp A)
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} {a : P.A} {f : P.last.B a ‚Üí P.last.W} (h : typevec.arrow (P.W_path (W_type.mk a f)) Œ±) (j : P.last.B a) : typevec.arrow (P.W_path (f j)) Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {f' : E ‚âÉL[ùïú] F} {g : F ‚Üí E} {a : F} (hg : continuous_at g a) (hf : has_strict_fderiv_at f ‚Üëf' (g a)) (hfg : ‚àÄ·∂† (y : F) in nhds a, f (g y) = y) : has_strict_fderiv_at g ‚Üë(f'.symm) a
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) : category_theory.limits.is_colimit (AddCommGroup.colimits.colimit_cocone F)
(X : Type u) [metric_space X] [compact_space X] [nonempty X] (Y : Type v) [metric_space Y] [compact_space Y] [nonempty Y] : ‚àÉ (Œ¶ : X ‚Üí ‚Ü•(lp (Œª (n : ‚Ñï), ‚Ñù) ‚ä§)) (Œ® : Y ‚Üí ‚Ü•(lp (Œª (n : ‚Ñï), ‚Ñù) ‚ä§)), isometry Œ¶ ‚àß isometry Œ® ‚àß Gromov_Hausdorff.GH_dist X Y = metric.Hausdorff_dist (set.range Œ¶) (set.range Œ®)
{G : Type u_2} [group G] (H : subgroup G) : category_theory.End (‚áë(category_theory.action_category.obj_equiv G (G ‚ß∏ H)) ‚Üë1) ‚âÉ* ‚Ü•H
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V‚ÇÇ : Type v'} [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] (f : V ‚Üí‚Çó[K] V‚ÇÇ) (w : function.surjective ‚áëf) [finite_dimensional K V] : finite_dimensional K V‚ÇÇ
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ‚Ñù E] [normed_group F] [normed_space ‚Ñù F] {x : E} {f : E ‚Üí F} {f' : E ‚Üí (E ‚ÜíL[‚Ñù] F)} {f'' : E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] F} (hf : ‚àÄ (y : E), has_fderiv_at f (f' y) y) (hx : has_fderiv_at f' f'' x) (v w : E) : ‚áë(‚áëf'' v) w = ‚áë(‚áëf'' w) v
{S : Type v} (s : S) {R : Type u_1} [ordered_comm_semiring R] [set_like S R] [subsemiring_class S R] : ordered_comm_semiring ‚Ü•s
{Œ± : Type u_1} {Œπ' : Sort u_5} [complete_lattice Œ±] (s : Œπ' ‚Üí Œ±) : (‚®Ö (i : Œπ'), s i) = ‚®Ö (t : finset (plift Œπ')) (i : plift Œπ') (H : i ‚àà t), s i.down
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {f : V ‚âÉ‚Çó·µ¢[‚Ñù] V} (hd : ‚áëlinear_map.det ‚Üë(f.to_linear_equiv) < 0) : ‚àÉ (Œ∏ : real.angle), f = hb.conj_lie.trans (hb.rotation Œ∏)
 : list omega.ee ‚Üí omega.clause ‚Üí omega.clause
(R : Type u_1) (S : Type u_2) [comm_ring R] [comm_ring S] [algebra R S] : S ‚Üí‚Çó[R] R
{G : Type u_10} [add_group G] (a : G) : G ‚âÉ G
(major_premise : expr) : tactic.eliminate.generalization_mode ‚Üí tactic name_set
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] {X Y : C} (f g : X ‚ü∂ Y) : category_theory.limits.has_limit (category_theory.limits.parallel_pair f g)
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] {F : intermediate_field K L} (E : intermediate_field K ‚Ü•F) : intermediate_field K L
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [has_add Œπ] [Œ† (i : Œπ), add_comm_monoid (A i)] [direct_sum.gnon_unital_non_assoc_semiring A] {i j : Œπ} : A i ‚Üí+ A j ‚Üí+ A (i + j)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (r : rel Œ± Œ≤) (s : rel Œ≤ Œ≥) : rel Œ± Œ≥
{C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] {F : J ‚•§ C} {c‚ÇÅ : category_theory.limits.cofan (Œª (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), F.obj f.fst.fst)} {c‚ÇÇ : category_theory.limits.cofan F.obj} (s t : c‚ÇÅ.X ‚ü∂ c‚ÇÇ.X) (hs : ‚àÄ (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), c‚ÇÅ.Œπ.app {as := f} ‚â´ s = F.map f.snd ‚â´ c‚ÇÇ.Œπ.app {as := f.fst.snd}) (ht : ‚àÄ (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), c‚ÇÅ.Œπ.app {as := f} ‚â´ t = c‚ÇÇ.Œπ.app {as := f.fst.fst}) (i : category_theory.limits.cofork s t) : category_theory.limits.cocone F
{Œπ : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [monoid R] [add_monoid Œπ] (A : Œπ ‚Üí S) [set_like.graded_monoid A] : graded_monoid.gmonoid (Œª (i : Œπ), ‚Ü•(A i))
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] (f : M ‚Üí‚Çó[R] M) : ‚Ñï ‚Üío (submodule R M)·µí·µà
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [comm_monoid N] {f g : Œ± ‚Üí‚ÇÄ M} {h : Œ± ‚Üí M ‚Üí N} (h_zero : ‚àÄ (a : Œ±), h a 0 = 1) (h_add : ‚àÄ (a : Œ±) (b‚ÇÅ b‚ÇÇ : M), h a (b‚ÇÅ + b‚ÇÇ) = h a b‚ÇÅ * h a b‚ÇÇ) : (f + g).prod h = f.prod h * g.prod h
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
{Œ± : Type u_2} {Œ≤ : Type u_3} [non_assoc_semiring Œ±] [non_assoc_ring Œ≤] (f : Œ± ‚Üí* Œ≤) (map_add : ‚àÄ (a b : Œ±), ‚áëf (a + b) = ‚áëf a + ‚áëf b) : Œ± ‚Üí+* Œ≤
(q : interactive.parse (lean.parser.pexpr std.prec.max)) (cfg : tactic.apply_cfg) : tactic unit
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.is_iso 0 ‚âÉ (X ‚âÖ 0)
 : tactic unit
{R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_4} {M‚ÇÇ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {s : set M} {f g : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (H : set.eq_on ‚áëf ‚áëg s) : set.eq_on ‚áëf ‚áëg ‚Üë(submodule.span R s)
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 p : P} (h : p1 -·µ• p = p2 -·µ• p) : p1 = p2
(u v : binder_info) : bool
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (i : D ‚•§ C) [category_theory.limits.has_finite_products C] [category_theory.reflective i] [category_theory.cartesian_closed C] [category_theory.exponential_ideal i] (A B : C) (X : D) : ((category_theory.left_adjoint i).obj (A ‚®Ø B) ‚ü∂ X) ‚âÉ ((category_theory.left_adjoint i).obj A ‚®Ø (category_theory.left_adjoint i).obj B ‚ü∂ X)
{Œ± : Type u_1} [comm_semiring Œ±] (E : linear_recurrence Œ±) {u : ‚Ñï ‚Üí Œ±} {init : fin E.order ‚Üí Œ±} (h : E.is_solution u) (heq : ‚àÄ (n : fin E.order), u ‚Üën = init n) : u = E.mk_sol init
{M : Type u_1} [monoid M] {s : set M} (h : is_submonoid s) : submonoid M
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : has_dist.dist p1 p3 = has_dist.dist p1 p2 + has_dist.dist p3 p2
(p : ‚Ñï) [hp : fact (nat.prime p)] (R : Type u‚ÇÅ) [comm_semiring R] [char_p R p] [perfect_ring R p] (S : Type u‚ÇÇ) [comm_semiring S] [char_p S p] : (R ‚Üí+* S) ‚âÉ (R ‚Üí+* ring.perfection S p)
{Œ≤ : Type u_2} (Œ± : Type u_1) [encodable Œ±] (e : Œ≤ ‚âÉ Œ±) : encodable Œ≤
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {s : set E} {x : E} : mdifferentiable_within_at (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f s x ‚Üî differentiable_within_at ùïú f s x
{C : Type u‚ÇÅ} [category_theory.small_category C] : category_theory.colimit_adj.extend_along_yoneda category_theory.yoneda ‚âÖ ùü≠ (C·µí·µñ ‚•§ Type u‚ÇÅ)
(b x : ordinal) : ordinal
{M : Type u} [monoid M] (x : M) (n : ‚Ñï) : mul_opposite.op (x ^ n) = mul_opposite.op x ^ n
(q r : ‚Ñï+) : multiset ‚Ñï+
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {s : set Œ±} (h : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)) ‚â† 0) : ‚àÉ (x : Œ±) (H : x ‚àà s), f x ‚â† 0
{Œ± : Type u} [preorder Œ±] (s : set Œ±) : Prop
{S : Type u_4} (H : S) {G : Type u_1} [ordered_comm_group G] [set_like S G] [subgroup_class S G] : ordered_comm_group ‚Ü•H
{L : first_order.language} {Œ± : Type u'} : L.formula Œ± ‚Üí L.formula Œ± ‚Üí L.formula Œ±
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] (E : Type u‚ÇÉ) [category_theory.category E] : (D ‚•§ E) ‚•§ (C ‚•§ D) ‚•§ C ‚•§ E
{E : ‚Ñï ‚Üí Type u_1} (x : Œ† (n : ‚Ñï), E n) (s : set (Œ† (n : ‚Ñï), E n)) : ‚Ñï
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.additive] {X Y : C} : (X ‚ü∂ Y) ‚Üí+ (F.obj X ‚ü∂ F.obj Y)
(a b : Prop) : Prop
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) [category_theory.limits.has_limit F] : category_theory.limits.cone F
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w‚ÇÅ} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] : category_theory.Sheaf J D ‚•§ category_theory.SheafOfTypes J
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C·µí·µñ) (F : C ‚•§ D) [category_theory.limits.preserves_colimit K.left_op F] : category_theory.limits.preserves_limit K F.op
{b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c ‚â§ x ‚Üî c ‚â§ ordinal.log b x
 : expr ‚Üí binder
{A : Type u_3} [add_group A] (s : set A) : Prop
(G : Type u_1) [group G] : group.is_nilpotent G ‚Üî ‚àÉ (n : ‚Ñï) (H : ‚Ñï ‚Üí subgroup G), is_descending_central_series H ‚àß H n = ‚ä•
{Œ≤ : Type u} {Œ± : Type v} {s : finset Œ±} {a : Œ±} {f : Œ± ‚Üí Œ≤} [comm_monoid Œ≤] [decidable_eq Œ±] (h : f a = 1) : (has_insert.insert a s).prod (Œª (x : Œ±), f x) = s.prod (Œª (x : Œ±), f x)
 : function.injective fin
 : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚Ñù
{X Y : Top} {f : X ‚ü∂ Y} (hf : is_open_map ‚áëf) : topological_space.opens ‚Ü•X ‚•§ topological_space.opens ‚Ü•Y
{R : Type u} [comm_semigroup R] [star_semigroup R] (x y : R) : has_star.star (x * y) = has_star.star x * has_star.star y
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (c : add_con M) (d : add_con N) : add_con (M √ó N)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] {f : Œ≤ ‚Üí Œ±} {l : filter Œ≤} {s : set Œ≤} {a : Œ±} (h : ‚àÄ (x : Œ≤), x ‚àâ s ‚Üí f x = a) : filter.tendsto f (l ‚äì filter.principal s) (nhds a) ‚Üî filter.tendsto f l (nhds a)
(C : Type u) [category_theory.category C] {X : C} {f : X ‚ü∂ X} (hf : f ‚â´ f = f) [category_theory.limits.has_coequalizer (ùüô X) f] : category_theory.split_epi (category_theory.limits.coequalizer.œÄ (ùüô X) f)
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : submodule.torsion_by_set R M s = submodule.torsion_by_set R M ‚Üë(ideal.span s)
(C : Type u‚ÇÅ) [category_theory.category C] : category_theory.subterminals C ‚•§ C
 : tactic unit
{X : Top} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : category_theory.pairwise.diagram U ‚âÖ Top.presheaf.sheaf_condition.pairwise_to_opens_le_cover U ‚ãô category_theory.full_subcategory_inclusion (Œª (V : topological_space.opens ‚Ü•X), ‚àÉ (i : Œπ), V ‚â§ U i)
{Œ± : Type u_1} [inhabited Œ±] (n : ‚Ñï) : list Œ± ‚Üí list Œ±
{R : Type u_1} {M : Type u_3} {M' : Type u_4} [has_zero R] [has_zero M] [smul_with_zero R M] [has_zero M'] [has_scalar R M'] (f : zero_hom M M') (hf : function.surjective ‚áëf) (smul : ‚àÄ (a : R) (b : M), ‚áëf (a ‚Ä¢ b) = a ‚Ä¢ ‚áëf b) : smul_with_zero R M'
{X : Top} {x‚ÇÄ x‚ÇÅ : ‚Ü•X} (hx : x‚ÇÄ = x‚ÇÅ) : fundamental_groupoid.from_top x‚ÇÄ ‚ü∂ fundamental_groupoid.from_top x‚ÇÅ
{R K : Type u} [comm_ring R] [field K] [algebra R K] [is_alg_closed K] {Œπ : Type u} (v : Œπ ‚Üí K) [nontrivial R] (hv : is_transcendence_basis R v) (hR : cardinal.mk R ‚â§ cardinal.aleph_0) (hK : cardinal.aleph_0 < cardinal.mk K) : cardinal.mk K = cardinal.mk Œπ
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (s : subsemiring R) (f : R ‚Üí+* S) (hf : function.injective ‚áëf) : ‚Ü•s ‚âÉ+* ‚Ü•(subsemiring.map f s)
{M : Type u_1} [mul_one_class M] (c : con M) : con.ker c.mk' = c
{G : Type u_1} [measurable_space G] [add_group G] [has_measurable_add G] [has_measurable_neg G] (g : G) : G ‚âÉ·µê G
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : submodule k V
{k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] [covariant_class M M has_add.add has_lt.lt] [contravariant_class M M has_add.add has_lt.lt] {a b : k} {c d : M} (hab : a < b) (hcd : c < d) : a ‚Ä¢ d + b ‚Ä¢ c < a ‚Ä¢ c + b ‚Ä¢ d
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {s‚ÇÅ : setoid Œ±} {s‚ÇÇ : setoid Œ≤} {s‚ÇÉ : setoid Œ≥} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (h : (setoid.r ‚áí setoid.r ‚áí setoid.r) f f) : quotient s‚ÇÅ ‚Üí quotient s‚ÇÇ ‚Üí quotient s‚ÇÉ
{Œ± : Type u_1} [uniform_space Œ±] : (‚®Ü (x : Œ±), nhds (x, x)) ‚â§ uniformity Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} : category_theory.subobject X ‚•§ C
 : charted_space (euclidean_space ‚Ñù (fin 1)) ‚Ü•circle
(Œ± : Type u) : Type u
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.regular_epi_category C] (f : X ‚ü∂ Y) [category_theory.epi f] : category_theory.regular_epi f
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : option Œ± ‚âÉ option Œ≤) : Œ± ‚âÉ Œ≤
{X : Type u_2} [emetric_space X] (m : set X ‚Üí ennreal) : (measure_theory.outer_measure.mk_metric' m).is_metric
{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] : ‚Ñï
{et : tactic.ring_exp.ex_type} (ps : tactic.ring_exp.ex et) : tactic.ring_exp.ring_exp_m expr
{Œπ : Type u_1} [decidable_eq Œπ] {R : Type u_4} [comm_semiring R] {M : Type u_8} [add_comm_monoid M] [module R M] [subsingleton Œπ] (i‚ÇÄ : Œπ) : pi_tensor_product R (Œª (i : Œπ), M) ‚âÉ‚Çó[R] M
 : environment ‚Üí declaration ‚Üí exceptional environment
(r : ‚Ñï+) : multiset ‚Ñï+
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M ‚Üí* N} (h : ‚àÄ (y : ‚Ü•S), is_unit (‚áëf ‚Üëy)) {x‚ÇÅ x‚ÇÇ : M} {y‚ÇÅ y‚ÇÇ : ‚Ü•S} : ‚áëf x‚ÇÅ * ‚Üë(‚áë(is_unit.lift_right (f.restrict S) h) y‚ÇÅ)‚Åª¬π = ‚áëf x‚ÇÇ * ‚Üë(‚áë(is_unit.lift_right (f.restrict S) h) y‚ÇÇ)‚Åª¬π ‚Üî ‚áëf (x‚ÇÅ * ‚Üëy‚ÇÇ) = ‚áëf (x‚ÇÇ * ‚Üëy‚ÇÅ)
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (p : set Œ≤) (f : r ‚Ü™r s) (H : ‚àÄ (a : Œ±), ‚áëf a ‚àà p) : r ‚Ü™r subrel s p
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {f : E ‚Üí F} (hf : cont_diff ùïú n f) : cont_diff ùïú n (Œª (x : E), -f x)
{n : Type u_3} {R : Type u_6} [fintype n] [add_comm_monoid R] (A : matrix n n R) : R
{Œ± : Type u} [topological_space Œ±] {Œπ : Type u_1} (x : Œ±) (F : filter Œπ) (u : Œπ ‚Üí Œ±) : Prop
(T : Type u) [topological_space T] : category_theory.grothendieck_topology (topological_space.opens T)
{A : Type u_1} {R : Type u_2} (K : Type u_3) [comm_ring A] [is_domain A] [normalized_gcd_monoid A] [field K] [comm_ring R] [is_domain R] [algebra A K] [is_fraction_ring A K] [algebra K R] [algebra A R] [is_scalar_tower A K R] {x : R} (hx : is_integral A x) {P : polynomial A} (hprim : P.is_primitive) (hroot : ‚áë(polynomial.aeval x) P = 0) : minpoly A x ‚à£ P
 : Type
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [finite_dimensional ‚Ñù ‚Ü•(s.direction)] (hd : finite_dimensional.finrank ‚Ñù ‚Ü•(s.direction) = 2) {c‚ÇÅ c‚ÇÇ p‚ÇÅ p‚ÇÇ p : P} (hc‚ÇÅs : c‚ÇÅ ‚àà s) (hc‚ÇÇs : c‚ÇÇ ‚àà s) (hp‚ÇÅs : p‚ÇÅ ‚àà s) (hp‚ÇÇs : p‚ÇÇ ‚àà s) (hps : p ‚àà s) {r‚ÇÅ r‚ÇÇ : ‚Ñù} (hc : c‚ÇÅ ‚â† c‚ÇÇ) (hp : p‚ÇÅ ‚â† p‚ÇÇ) (hp‚ÇÅc‚ÇÅ : has_dist.dist p‚ÇÅ c‚ÇÅ = r‚ÇÅ) (hp‚ÇÇc‚ÇÅ : has_dist.dist p‚ÇÇ c‚ÇÅ = r‚ÇÅ) (hpc‚ÇÅ : has_dist.dist p c‚ÇÅ = r‚ÇÅ) (hp‚ÇÅc‚ÇÇ : has_dist.dist p‚ÇÅ c‚ÇÇ = r‚ÇÇ) (hp‚ÇÇc‚ÇÇ : has_dist.dist p‚ÇÇ c‚ÇÇ = r‚ÇÇ) (hpc‚ÇÇ : has_dist.dist p c‚ÇÇ = r‚ÇÇ) : p = p‚ÇÅ ‚à® p = p‚ÇÇ
{R : Type u} {M : Type v} [ring R] [add_comm_group M] {module_M : module R M} (p : submodule R M) : add_subgroup M
{G : Type u} [category_theory.groupoid G] [is_free_groupoid G] (T : wide_subquiver (quiver.symmetrify (is_free_groupoid.generators G))) [quiver.arborescence ‚Ü•T] {a : G} : quiver.path (quiver.root ‚Ü•T) a ‚Üí (root' T ‚ü∂ a)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P (n + 2)) (i‚ÇÅ i‚ÇÇ : fin (n + 3)) : s.monge_plane i‚ÇÅ i‚ÇÇ = affine_subspace.mk' (finset.centroid ‚Ñù {i‚ÇÅ, i‚ÇÇ}·∂ú s.points) (submodule.span ‚Ñù {s.points i‚ÇÅ -·µ• s.points i‚ÇÇ})·óÆ ‚äì affine_span ‚Ñù (set.range s.points)
{R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {Œπ : Type u_6} [decidable_eq Œπ] (f : alternating_map R M N Œπ) : f.comp_linear_map linear_map.id = f
(Œ± : Type u_1) [fintype Œ±] [nonempty Œ±] : pmf Œ±
{R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group N] [module R N] [lie_ring_module L N] [lie_module R L N] (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) : ‚Ü•(lie_module.max_triv_submodule R L M) ‚Üí‚Çó‚ÅÖR,L‚ÅÜ ‚Ü•(lie_module.max_triv_submodule R L N)
 : ‚Ñï ‚Üío ‚Ñï
(Œ± : Type u_1) (E : Type u_3) [topological_space Œ±] [compact_space Œ±] [normed_group E] (ùïú : Type u_4) [normed_field ùïú] [normed_space ùïú E] : C(Œ±, E) ‚âÉ‚Çó·µ¢[ùïú] bounded_continuous_function Œ± E
 : category_theory.limits.walking_cospan.right ‚ü∂ category_theory.limits.walking_cospan.one
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {s : set E} {g : F ‚Üí G} {f : E ‚Üí F} (hg : cont_diff ùïú n g) (hf : cont_diff_on ùïú n f s) : cont_diff_on ùïú n (g ‚àò f) s
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X ‚Üí Y) : Prop
(C : Type u‚ÇÅ) [category_theory.category C] [‚àÄ (X Y : C), subsingleton (X ‚ü∂ Y)] : category_theory.thin_skeleton C ‚âå C
{R‚ÇÅ : Type u_3} {A : Type u_5} {B : Type u_6} [comm_semiring R‚ÇÅ] [comm_ring A] [comm_ring B] [algebra R‚ÇÅ A] [algebra R‚ÇÅ B] (f : A ‚Üí‚Çê[R‚ÇÅ] B) : A ‚ß∏ f.to_ring_hom.ker ‚Üí‚Çê[R‚ÇÅ] B
 : interactive.executor tactic
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : quotient (setoid.ker f) ‚âÉ ‚Ü•(set.range f)
 : category_theory.limits.walking_span
{n : ‚Ñï} (u v : Œ£ (c : composition n), Œ† (i : fin c.length), composition (c.blocks_fun i)) : u = v ‚Üî list.of_fn (Œª (i : fin u.fst.length), (u.snd i).blocks) = list.of_fn (Œª (i : fin v.fst.length), (v.snd i).blocks)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} [linear_order Œπ] (u : Œπ ‚Üí Œ± ‚Üí Œ≤) (œÑ : Œ± ‚Üí Œπ) : Œπ ‚Üí Œ± ‚Üí Œ≤
(G : Type u_1) [group G] : subgroup G
{G : Type w} [topological_space G] [has_inv G] [has_continuous_inv G] {Œπ : Type u_1} : has_continuous_inv (Œπ ‚Üí G)
 : parser ‚Ñï
(k : Type u‚ÇÅ) (G : Type u‚ÇÇ) {R : Type u_1} [comm_semiring R] [semiring k] [algebra R k] [monoid G] : monoid_algebra k G ‚âÉ‚Çê[R] add_monoid_algebra k (additive G)
{n : ‚Ñï} {x : ‚Ñï √ó ‚Ñï} : x ‚àà list.nat.antidiagonal n ‚Üî x.fst + x.snd = n
(ùïú : Type u) (Œπ : Type v) (Œπ' : Type v') (G : Type wG) (G' : Type wG') [decidable_eq Œπ] [fintype Œπ] [decidable_eq Œπ'] [fintype Œπ'] [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] [decidable_eq (Œπ ‚äï Œπ')] : continuous_multilinear_map ùïú (Œª (x : Œπ ‚äï Œπ'), G) G' ‚âÉ‚Çó·µ¢[ùïú] continuous_multilinear_map ùïú (Œª (x : Œπ), G) (continuous_multilinear_map ùïú (Œª (x : Œπ'), G) G')
{a b : ‚Ñù} : interval_integrable (Œª (x : ‚Ñù), x‚Åª¬π) measure_theory.measure_space.volume a b ‚Üî a = b ‚à® 0 ‚àâ set.interval a b
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] (x : E) : ext_chart_at (model_with_corners_self ùïú E) x = local_equiv.refl E
{M : Type u_1} {S : Type u_2} [sub_neg_monoid M] [set_like S M] [add_subgroup_class S M] {H : S} : has_scalar ‚Ñ§ ‚Ü•H
{R : Type u_2} {M‚ÇÅ : Type u_5} {M‚ÇÇ : Type u_6} [ring R] [add_comm_group M‚ÇÅ] [add_comm_group M‚ÇÇ] [module R M‚ÇÅ] [module R M‚ÇÇ] {Q‚ÇÅ : quadratic_form R M‚ÇÅ} {Q‚ÇÇ : quadratic_form R M‚ÇÇ} (f : Q‚ÇÅ.isometry Q‚ÇÇ) : Q‚ÇÇ.isometry Q‚ÇÅ
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] : E ‚Üí‚Çó‚ãÜ[ùïú] E ‚Üí‚Çó[ùïú] ùïú
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} [complete_space E] (f : local_homeomorph E F) {f‚ÇÄ' : E ‚âÉL[ùïú] F} {a : F} (ha : a ‚àà f.to_local_equiv.target) (hf‚ÇÄ' : has_fderiv_at ‚áëf ‚Üëf‚ÇÄ' (‚áë(f.symm) a)) (hf : cont_diff_at ùïú n ‚áëf (‚áë(f.symm) a)) : cont_diff_at ùïú n ‚áë(f.symm) a
{Œ± : Type u_1} [complete_lattice Œ±] (k : Œ±) : Prop
(q : interactive.parse interactive.types.texpr) : tactic unit
(Œπ : Type v) : Type v
{Œ± : Type u_1} : has_singleton Œ± (finset Œ±)
(Œ± : Type u_1) [has_zero Œ±] [has_one Œ±] (n : ‚Ñï) : matrix.circulant (Œª (i : fin n), ite (‚Üëi = 0) 1 0) = 1
{m : Type u_1} {R : Type u_2} [fintype m] [comm_ring R] {M : matrix m m R} (hM : M.nondegenerate) {v : m ‚Üí R} (hv : v ‚â† 0) : ‚àÉ (w : m ‚Üí R), matrix.dot_product v (M.mul_vec w) ‚â† 0
{Œì : Type u_1} [inhabited Œì] (T : turing.tape Œì) : turing.list_blank Œì
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [rŒ± : non_assoc_semiring Œ±] [rŒ≤ : non_assoc_semiring Œ≤] {rŒ≥ : non_assoc_semiring Œ≥} {Œ¥ : Type u_1} {rŒ¥ : non_assoc_semiring Œ¥} (f : Œ± ‚Üí+* Œ≤) (g : Œ≤ ‚Üí+* Œ≥) (h : Œ≥ ‚Üí+* Œ¥) : (h.comp g).comp f = h.comp (g.comp f)
 : expr ‚Üí expr ‚Üí tactic expr
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (F : C ‚•§ D) [category_theory.ess_surj F] (Y : D) : F.obj (F.obj_preimage Y) ‚âÖ Y
(s : linarith.sum) : ‚Ñï ‚Üí linarith.sum
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s‚ÇÅ s‚ÇÇ : set P} (h : s‚ÇÅ ‚äÜ s‚ÇÇ) : affine_span k s‚ÇÅ ‚â§ affine_span k s‚ÇÇ
(ùïú : Type v) [is_R_or_C ùïú] {E : Type u} [normed_group E] [normed_space ùïú E] : E ‚Üí‚Çó·µ¢[ùïú] normed_space.dual ùïú (normed_space.dual ùïú E)
(ic : tactic.instance_cache) : expr ‚Üí tactic (tactic.instance_cache √ó expr)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_artinian R M] (f : M ‚Üí‚Çó[R] M) (s : function.injective ‚áëf) : function.bijective ‚áëf
(cfg : tactic.nth_rewrite.cfg) (r : expr √ó bool) (l : expr_lens) (e : expr) : tactic (list tactic.nth_rewrite.tracked_rewrite)
{B : Type u_1} {E : B ‚Üí Type u_2} {B' : Type u_3} (f : B' ‚Üí B) : bundle.total_space (f *·µñ E) ‚Üí B' √ó bundle.total_space E
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {Œπ : Type u_6} (Z : topological_vector_bundle_core R B F Œπ) (i : Œπ) : topological_vector_bundle.trivialization R F Z.fiber
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (D : Type w) [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] : (C·µí·µñ ‚•§ D) ‚•§ C·µí·µñ ‚•§ D
 : Type
{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a
{Œ± : Type u_1} {M : Type u_4} [monoid M] : (Œ± ‚Üí M) ‚âÉ (free_monoid Œ± ‚Üí* M)
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} {R‚ÇÉ : Type u_3} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [semiring R‚ÇÉ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : R‚ÇÅ ‚Üí+* R‚ÇÉ} [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] {M‚ÇÉ : Type u_7} [topological_space M‚ÇÉ] [add_comm_monoid M‚ÇÉ] {M‚ÇÑ : Type u_8} [topological_space M‚ÇÑ] [add_comm_monoid M‚ÇÑ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] [module R‚ÇÉ M‚ÇÉ] {R‚ÇÑ : Type u_9} [semiring R‚ÇÑ] [module R‚ÇÑ M‚ÇÑ] {œÉ‚ÇÉ‚ÇÑ : R‚ÇÉ ‚Üí+* R‚ÇÑ} {œÉ‚ÇÑ‚ÇÉ : R‚ÇÑ ‚Üí+* R‚ÇÉ} [ring_hom_inv_pair œÉ‚ÇÉ‚ÇÑ œÉ‚ÇÑ‚ÇÉ] [ring_hom_inv_pair œÉ‚ÇÑ‚ÇÉ œÉ‚ÇÉ‚ÇÑ] {œÉ‚ÇÇ‚ÇÑ : R‚ÇÇ ‚Üí+* R‚ÇÑ} {œÉ‚ÇÅ‚ÇÑ : R‚ÇÅ ‚Üí+* R‚ÇÑ} [ring_hom_comp_triple œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÑ œÉ‚ÇÇ‚ÇÑ] [ring_hom_comp_triple œÉ‚ÇÇ‚ÇÑ œÉ‚ÇÑ‚ÇÉ œÉ‚ÇÇ‚ÇÉ] [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÉ œÉ‚ÇÉ‚ÇÑ œÉ‚ÇÅ‚ÇÑ] (e‚ÇÅ‚ÇÇ : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (e‚ÇÑ‚ÇÉ : M‚ÇÑ ‚âÉSL[œÉ‚ÇÑ‚ÇÉ] M‚ÇÉ) : (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÑ] M‚ÇÑ) ‚âÉ (M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ)
(Œ± : Type u) : Type u
{M : Type u_1} (S : set M) [semigroup M] : subsemigroup M
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (a : R) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] {P : C·µí·µñ ‚•§ A} {X : C} {S : category_theory.sieve X} {E : A·µí·µñ} {x : category_theory.presieve.family_of_elements (P ‚ãô category_theory.coyoneda.obj E) ‚áëS} (hx : x.sieve_compatible) : category_theory.limits.cone (S.arrows.diagram.op ‚ãô P)
{P : Type u_1} [preorder P] [order_bot P] : order_bot (order.ideal P)
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] : category_theory.limits.has_equalizers C
{ùïú : Type u_3} [is_R_or_C ùïú] {E : Type u_4} [inner_product_space ùïú E] (n : ‚Ñï) [fact (finite_dimensional.finrank ùïú E = n + 1)] {v : E} (hv : v ‚â† 0) : ‚Ü•(submodule.span ùïú {v})·óÆ ‚âÉ‚Çó·µ¢[ùïú] euclidean_space ùïú (fin n)
{Œ± : Type u_1} {E : Type u_2} (R : Type u_3) [add_comm_group E] [division_ring R] [monoid Œ±] [module R E] [distrib_mul_action Œ± E] (n : ‚Ñï) (s : Œ±) (x : E) : (‚Üën)‚Åª¬π ‚Ä¢ s ‚Ä¢ x = s ‚Ä¢ (‚Üën)‚Åª¬π ‚Ä¢ x
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (S : D) (T : C ‚•§ D) : category_theory.structured_arrow S T ‚•§ C
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (A : Type u‚ÇÉ) [category_theory.category A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (hG‚ÇÅ : category_theory.compatible_preserving K G) (hG‚ÇÇ : category_theory.cover_preserving J K G) : category_theory.Sheaf K A ‚•§ category_theory.Sheaf J A
{R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {Œπ : Type u_1} {f : Œπ ‚Üí M} (hf : function.injective f) : linear_independent R coe ‚Üí linear_independent R f
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Œπ] (p : Œπ ‚Üí P) {n : ‚Ñï} (hc : fintype.card Œπ = n + 2) : affine_independent k p ‚Üî ¬¨finite_dimensional.finrank k ‚Ü•(vector_span k (set.range p)) ‚â§ n
{Œπ : Type v} (Œ± : Œπ ‚Üí Top) : category_theory.limits.is_colimit (Top.sigma_cofan Œ±)
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] (F : J ‚•§ algebraic_geometry.PresheafedSpace C) (s : category_theory.limits.cocone F) : algebraic_geometry.PresheafedSpace.colimit F ‚ü∂ s.X
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [regular_space Y] {f : X ‚Üí Y} {A B : set X} (hB : B ‚äÜ closure A) (hf : ‚àÄ (x : X), x ‚àà B ‚Üí (‚àÉ (y : Y), filter.tendsto f (nhds_within x A) (nhds y))) : continuous_on (extend_from A f) B
{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {s : set M} {p : Œ† (x : M), x ‚àà submodule.span R s ‚Üí Prop} (Hs : ‚àÄ (x : M) (h : x ‚àà s), p x _) (H0 : p 0 _) (H1 : ‚àÄ (x : M) (hx : x ‚àà submodule.span R s) (y : M) (hy : y ‚àà submodule.span R s), p x hx ‚Üí p y hy ‚Üí p (x + y) _) (H2 : ‚àÄ (a : R) (x : M) (hx : x ‚àà submodule.span R s), p x hx ‚Üí p (a ‚Ä¢ x) _) {x : M} (hx : x ‚àà submodule.span R s) : p x hx
(F : Type u_12) (A : Type u_13) (B : Type u_14) [has_add A] [has_add B] : Type (max u_12 u_13 u_14)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P (n + 2)) {i‚ÇÅ i‚ÇÇ : fin (n + 3)} : has_inner.inner (s.monge_point -·µ• finset.centroid ‚Ñù {i‚ÇÅ, i‚ÇÇ}·∂ú s.points) (s.points i‚ÇÅ -·µ• s.points i‚ÇÇ) = 0
{Œ± : Type u} {Œ≤ : Sort u_1} (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) : Œ≤ ‚Üí ordnode Œ± ‚Üí Œ≤
 : list expr ‚Üí expr ‚Üí expr
{ùïú : Type u_1} {E : Type u_3} [normed_field ùïú] [add_comm_group E] [module ùïú E] {A : set E} [topological_space E] [has_continuous_smul ùïú E] (hA : A ‚àà nhds 0) : absorbent ùïú A
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{Œ± : Sort u‚ÇÅ} {Œ≤ : Sort u‚ÇÇ} (g : Œ≤ ‚Üí Œ±) (f : Œ± ‚Üí Œ≤) : Prop
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {Œ± : Type u_1} [mul_action A Œ±] (S : subalgebra R A) : mul_action ‚Ü•S Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : Œ± ‚âÉ Œ≤) : local_equiv Œ± Œ≤
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {b : E √ó F ‚Üí G} {n : with_top ‚Ñï} (hb : is_bounded_bilinear_map ùïú b) : cont_diff ùïú n b
{M : Type u_1} [has_add M] {c d : add_con M} (H : setoid.r = setoid.r) : c = d
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits_of_size C] : category_theory.limits.has_colimits_of_size C
{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] {r : RÀ£} {s : R} {a : A} (h : is_unit (r ‚Ä¢ ‚áë(algebra_map R A) s - a)) : AÀ£
(Œ± : Type u) [topological_space Œ±] : Prop
{Œ± : Type u} {s : set Œ±} (h : s.nonempty) : Œ±
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] (h : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ
(n : ‚Ñï) (x : ‚Ñù) : has_deriv_at (exp_neg_inv_glue.f_aux n) (exp_neg_inv_glue.f_aux (n + 1) x) x
(R : Type u_1) {p n : ‚Ñï} [hp : fact (nat.prime p)] [ring R] [char_p R p] (hn : ¬¨p ‚à£ n) : polynomial.cyclotomic (n * p) R = polynomial.cyclotomic n R ^ (p - 1)
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hb : continuous_at f a) : deriv (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in u..b, f x) a = -f a
{Œ± : Type uu} (r : Œ± ‚Üí Œ± ‚Üí Prop) [decidable_rel r] : list Œ± ‚Üí list Œ± ‚Üí list Œ±
(e : ‚ÑÇ ‚âÉ‚Çó·µ¢[‚Ñù] ‚ÑÇ) : ‚Ü•circle
{Œ± : Type u_1} [denumerable Œ±] : denumerable (plift Œ±)
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {x : E} {n : with_top ‚Ñï} {f g : E ‚Üí F} (hf : cont_diff_at ùïú n f x) (hg : cont_diff_at ùïú n g x) : cont_diff_at ùïú n (Œª (x : E), f x - g x) x
(Œ± : Type u_1) : enat
(ùïú : Type u_5) [normed_field ùïú] {E : Type u_1} {F : Type u_2} [semi_normed_ring E] [semi_normed_ring F] [normed_algebra ùïú E] [normed_algebra ùïú F] : normed_algebra ùïú (E √ó F)
 : format
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : S.localization_map (add_localization S)
(o : onote) : Prop
{Œ± : Type u} : seq Œ± ‚Üí wseq Œ±
{F : Type u_1} [field F] (S : set F) : set F
(R : Type u) : Type u
{a b : ‚Ñù} (m n : ‚Ñï) : ‚à´ (x : ‚Ñù) in a..b, real.sin x ^ (2 * m + 1) * real.cos x ^ n = ‚à´ (u : ‚Ñù) in real.cos b..real.cos a, u ^ n * (1 - u ^ 2) ^ m
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] {M : Type u_3} [add_comm_monoid M] [topological_space M] [has_continuous_add M] (f : Œ± ‚Üí Œ≤) : measure_theory.vector_measure Œ± M ‚Üí+ measure_theory.vector_measure Œ≤ M
{Œπ : Type u} {Œ± : Type v} [fintype Œπ] {t : Œπ ‚Üí finset Œ±} [decidable_eq Œ±] {n : ‚Ñï} (hn : fintype.card Œπ = n + 1) (ht : ‚àÄ (s : finset Œπ), s.card ‚â§ (s.bUnion t).card) (ih : ‚àÄ {Œπ' : Type u} [_inst_3 : fintype Œπ'] (t' : Œπ' ‚Üí finset Œ±), fintype.card Œπ' ‚â§ n ‚Üí (‚àÄ (s' : finset Œπ'), s'.card ‚â§ (s'.bUnion t').card) ‚Üí (‚àÉ (f : Œπ' ‚Üí Œ±), function.injective f ‚àß ‚àÄ (x : Œπ'), f x ‚àà t' x)) (s : finset Œπ) (hs : s.nonempty) (hns : s ‚â† finset.univ) (hus : s.card = (s.bUnion t).card) : ‚àÉ (f : Œπ ‚Üí Œ±), function.injective f ‚àß ‚àÄ (x : Œπ), f x ‚àà t x
{G : Type u_1} [group G] {S : Type u_4} (H : S) [set_like S G] [hSG : subgroup_class S G] : ‚Ü•H ‚Üí* G
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a : Œ±} : 0 ‚â§ -a ‚Üí a ‚â§ 0
{Œ± : Type u_1} [t : topological_space Œ±] (s : set Œ±) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {F : C ‚•§ D} [category_theory.creates_limit K F] {c : category_theory.limits.cone (K ‚ãô F)} (t : category_theory.limits.is_limit c) : category_theory.limits.is_limit (category_theory.lift_limit t)
(Œ± : Type u_7) (Œ≤ : Type u_8) [has_inf Œ±] [has_inf Œ≤] [has_top Œ±] [has_top Œ≤] : Type (max u_7 u_8)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X Y : C) : category_theory.limits.image_factorisation 0
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] (f : ùïú ‚Üí F) (x : ùïú) : F
(q : interactive.parse interactive.types.texpr) : tactic unit
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_4} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (p : quot r) (q : quot s) (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (hr : ‚àÄ (a : Œ±) (b‚ÇÅ b‚ÇÇ : Œ≤), s b‚ÇÅ b‚ÇÇ ‚Üí f a b‚ÇÅ = f a b‚ÇÇ) (hs : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±) (b : Œ≤), r a‚ÇÅ a‚ÇÇ ‚Üí f a‚ÇÅ b = f a‚ÇÇ b) : Œ≥
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Type u_3} (a : Œ±) : Œ≤ a ‚Ü™ Œ£ (x : Œ±), Œ≤ x
{n m : ‚Ñï} (h : n = m) (i : fin n) : ‚Üë(‚áë(fin.cast h) i) = ‚Üëi
{Œπ : Type u} {Œ≥ : Type w} {Œ≤ : Œπ ‚Üí Type v} [dec : decidable_eq Œπ] [Œ† (i : Œπ), add_zero_class (Œ≤ i)] [add_comm_monoid Œ≥] (f : Œ† (i : Œπ), Œ≤ i ‚Üí+ Œ≥) (i : Œπ) (x : Œ≤ i) : ‚áë(‚áëdfinsupp.lift_add_hom f) (dfinsupp.single i x) = ‚áë(f i) x
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ùïú] [inner_product_space ùïú E] [inner_product_space ùïú F] [complete_space E] [complete_space F] : (E ‚ÜíL[ùïú] F) ‚âÉ‚Çó·µ¢‚ãÜ[ùïú] F ‚ÜíL[ùïú] E
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} (h_mono : strict_mono_on f s) (hs : s ‚àà nhds_within a (set.Ici a)) (hfs : set.surj_on f s (set.Ioi (f a))) : continuous_within_at f (set.Ici a) a
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_binary_product X Y] : X ‚®Ø Y ‚ü∂ Y
{R : Type u_1} {S : Type u_2} [ring R] [ring S] [algebra ‚Ñö R] [algebra ‚Ñö S] (f : R ‚Üí+* S) : R ‚Üí‚Çê[‚Ñö] S
{R : Type u} [ring R] (s : subring R) : 0 ‚àà s
{K : Type u} [hring : comm_ring K] : ratfunc K
(f : ‚Ñï ‚Üí ‚Ñù) : ‚Ñù*
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommSemiRing) : category_theory.limits.is_colimit (CommSemiRing.filtered_colimits.colimit_cocone F)
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ‚Üë‚ä• = ‚àÖ
(s : simp_lemmas) (a b : expr) : tactic expr
{Œ± : Type u_1} [comm_semigroup Œ±] {a b : Œ±} (c : Œ±) (h : c * a = b) : a ‚à£ b
{R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (S : subsemiring R) : algebra ‚Ü•S A
{R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra A B] [algebra R B] [algebra R A] [is_scalar_tower R A B] (H : function.injective ‚áë(algebra_map A B)) {x : A} (h : is_integral R (‚áë(algebra_map A B) x)) : is_integral R x
{K : Type u_1} [decidable_eq K] {Œì : K ‚Üí Type u_2} : Type (max u_1 u_2)
(R : Type u_3) (A : Type u_4) [semiring R] [add_comm_monoid A] [module R A] : A ‚Üí‚Çó[R] unitization R A
(ùïú : Type u_1) {E : Type u_2} [normed_linear_ordered_field ùïú] [normed_group E] [normed_space ùïú E] (A : set E) : set E
(Œ± : Type u_5) (Œ≤ : Type u_6) [topological_space Œ±] [topological_space Œ≤] : Type (max u_5 u_6)
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] : lazy_list Œ± ‚Üí option Œ±
{M : Type u} [mul_one_class M] (x : M) : semiconj_by 1 x x
{R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (h : function.injective ‚áë(algebra_map R A)) [char_zero R] : char_zero A
 : tactic unit
{Œ± : Type u_1} {f g : filter Œ±} (F : f.realizer) (G : g.realizer) : (f ‚äì g).realizer
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_comm_monoid Œ±] [topological_space Œ±] [t2_space Œ±] [complete_lattice Œ≤] (m : Œ≤ ‚Üí Œ±) (m0 : m ‚ä• = 0) (R : Œ± ‚Üí Œ± ‚Üí Prop) (m_supr : ‚àÄ (s : ‚Ñï ‚Üí Œ≤), R (m (‚®Ü (i : ‚Ñï), s i)) (‚àë' (i : ‚Ñï), m (s i))) (s‚ÇÅ s‚ÇÇ : Œ≤) : R (m (s‚ÇÅ ‚äî s‚ÇÇ)) (m s‚ÇÅ + m s‚ÇÇ)
{C : Type u} [category_theory.category C] {X Y X' : C} (h : X' ‚ü∂ X) (f : X ‚ü∂ Y) [category_theory.limits.has_image f] [category_theory.limits.has_image (h ‚â´ f)] : category_theory.limits.image_subobject (h ‚â´ f) ‚â§ category_theory.limits.image_subobject f
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CompHaus) : category_theory.limits.is_limit (CompHaus.limit_cone F)
(R : Type u_2) (M : Type u_3) [semiring R] [add_comm_monoid M] [module R M] [topological_space M] : (fin 2 ‚Üí M) ‚âÉL[R] M √ó M
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.mul_pos_mono Œ±] (ha : a ‚â§ 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
{R : Type u} [comm_semiring R] (p q : polynomial R) : ‚áëpolynomial.derivative (polynomial.eval‚ÇÇ polynomial.C q p) = polynomial.eval‚ÇÇ polynomial.C q (‚áëpolynomial.derivative p) * ‚áëpolynomial.derivative q
 : tactic unit
{Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
(Œ± : Type u_1) (Œ≤ : Type u_2) [has_le Œ±] [has_le Œ≤] : Type (max u_1 u_2)
{R : Type u} [ring R] {Œì‚ÇÄ : Type v} [linear_ordered_comm_group_with_zero Œì‚ÇÄ] (v : valuation R Œì‚ÇÄ) : ring_subgroups_basis (Œª (Œ≥ : Œì‚ÇÄÀ£), v.lt_add_subgroup Œ≥)
{X : Type u_1} [topological_space X] {x y : X} : inseparable x y ‚Üí nhds x = nhds y
(e l : expr) : expr
{R : Type u_1} [comm_semiring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [fintype n] [fintype m] [decidable_eq n] {M‚ÇÅ : Type u_5} {M‚ÇÇ : Type u_6} [add_comm_monoid M‚ÇÅ] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÅ] [module R M‚ÇÇ] (v‚ÇÅ : basis n R M‚ÇÅ) (v‚ÇÇ : basis m R M‚ÇÇ) {M‚ÇÉ : Type u_7} [add_comm_monoid M‚ÇÉ] [module R M‚ÇÉ] (v‚ÇÉ : basis l R M‚ÇÉ) [fintype l] [decidable_eq m] (A : matrix l m R) (B : matrix m n R) (x : M‚ÇÅ) : ‚áë(‚áë(matrix.to_lin v‚ÇÅ v‚ÇÉ) (A.mul B)) x = ‚áë(‚áë(matrix.to_lin v‚ÇÇ v‚ÇÉ) A) (‚áë(‚áë(matrix.to_lin v‚ÇÅ v‚ÇÇ) B) x)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p‚ÇÅ p‚ÇÇ : Œπ ‚Üí P) : s.sum (Œª (i : Œπ), w i ‚Ä¢ (p‚ÇÅ i -·µ• p‚ÇÇ i)) = ‚áë(s.weighted_vsub p‚ÇÅ) w - ‚áë(s.weighted_vsub p‚ÇÇ) w
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} (M : Type w‚ÇÅ) [comm_ring R] [lie_ring L‚ÇÅ] [lie_algebra R L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÇ] [add_comm_group M] [lie_ring_module L‚ÇÇ M] (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) [module R M] [lie_module R L‚ÇÇ M] : lie_module R L‚ÇÅ M
(A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [h : is_cyclotomic_extension {1} A B] : ‚ä• = ‚ä§
{Œ± : Type u} (s : seq Œ±) (n : ‚Ñï) : decidable (s.terminated_at n)
{M : Type u_1} {A : Type u_4} {B : Type u_5} [monoid M] [monoid A] [mul_distrib_mul_action M A] [monoid B] [has_scalar M B] (f : B ‚Üí* A) (hf : function.injective ‚áëf) (smul : ‚àÄ (c : M) (x : B), ‚áëf (c ‚Ä¢ x) = c ‚Ä¢ ‚áëf x) : mul_distrib_mul_action M B
(n : ‚Ñï) (Œ± : fin n ‚Üí Type u) : Type u
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e e' : local_homeomorph Œ± Œ≤) (s : set Œ±) (t : set Œ≤) [Œ† (x : Œ±), decidable (x ‚àà s)] [Œ† (y : Œ≤), decidable (y ‚àà t)] (H : e.is_image s t) (H' : e'.is_image s t) (Hs : e.to_local_equiv.source ‚à© frontier s = e'.to_local_equiv.source ‚à© frontier s) (Heq : set.eq_on ‚áëe ‚áëe' (e.to_local_equiv.source ‚à© frontier s)) : local_homeomorph Œ± Œ≤
(nm : name) (n : ‚Ñï) : name
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {s : set Œ±} (p : M ‚Üí Prop) (hp‚ÇÄ : p 1) (hp‚ÇÅ : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x * y)) (hp‚ÇÇ : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p (f x)) : p (finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)))
{R : Type u} {Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} {M‚ÇÉ : Type w‚ÇÉ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [module R M‚ÇÉ] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [topological_space M‚ÇÇ] [topological_space M‚ÇÉ] (g : M‚ÇÇ ‚ÜíL[R] M‚ÇÉ) (f : continuous_multilinear_map R M‚ÇÅ M‚ÇÇ) : continuous_multilinear_map R M‚ÇÅ M‚ÇÉ
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {Œ± : Type u_4} [fintype Œ±] (f : M ‚Üí‚Çó[R] Œ± ‚Üí R) (s : function.surjective ‚áëf) : (Œ± ‚Üí R) ‚Üí‚Çó[R] M
{n : ‚Ñï} {Œ± : Type u} {Œ≤ : Type v} (a : array n Œ±) (f : fin n ‚Üí Œ± ‚Üí Œ≤) : array n Œ≤
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ‚Ñù} [interval_integral.FTC_filter a (nhds_within a s) (nhds_within a t)] (hmeas : strongly_measurable_at_filter f (nhds_within a t) measure_theory.measure_space.volume) (ha : continuous_within_at f t a) (hs : unique_diff_within_at ‚Ñù s a . "unique_diff_within_at_Ici_Iic_univ") : deriv_within (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in u..b, f x) s a = -f a
{Œ± : Type u_1} [topological_space Œ±] {x : Œ±} {s : set Œ±} {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : lower_semicontinuous_within_at f s x) (hg : lower_semicontinuous_within_at g s x) (hcont : continuous_at (Œª (p : Œ≥ √ó Œ≥), p.fst + p.snd) (f x, g x)) : lower_semicontinuous_within_at (Œª (z : Œ±), f z + g z) s x
{M : Type u_1} {Œ± : Sort u_2} [add_comm_monoid M] (f : Œ± ‚Üí M) : M
 : lean.parser (tactic.list_Pi tactic.rcases_patt)
 : tactic.interactive.itactic ‚Üí tactic unit
{Œ± : Type u} {Œ≤ : Type v} (R : Œ± ‚Üí Œ≤ ‚Üí Prop) (ca : computation Œ±) (cb : computation Œ≤) : Prop
(s : set cardinal) : bdd_above s ‚Üî small ‚Ü•s
{R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] (P Q : module R M) (w : ‚àÄ (r : R) (m : M), r ‚Ä¢ m = r ‚Ä¢ m) : P = Q
(G : Type u_1) [group G] : ‚Ñï ‚Üí subgroup G
{Œ± : Type u} [partial_order Œ±] [decidable_rel has_le.le] {a b : Œ±} (hab : a ‚â§ b) : a = b ‚à® a < b
{Œ± : Type u_1} [uniform_space Œ±] (pkg pkg' : abstract_completion Œ±) : pkg.space ‚âÉ pkg'.space
{Œ± Œ≤ : Type u} {L : Œ± ‚Üí pgame} {R : Œ≤ ‚Üí pgame} [S : (pgame.mk Œ± Œ≤ L R).short] : fintype Œ≤
{A : Type u_2} [add_monoid A] {x y : A} : y ‚àà add_submonoid.closure {x} ‚Üî ‚àÉ (n : ‚Ñï), n ‚Ä¢ x = y
{Œ± : Type u} {a b : Œ±} [mul_zero_class Œ±] [preorder Œ±] [zero_lt.pos_mul_strict_mono Œ±] (ha : 0 < a) (hb : 0 < b) : 0 < a * b
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : F.op.unop ‚âÖ F
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) : linear_independent ùïú v
(mvar assignment : level) : tactic.unsafe.type_context unit
{m : Type ‚Üí Type} [monad m] (f : name ‚Üí m name) (s : name_set) : m name_set
(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop
(Œ± : Type u) : Type (max 1 u)
(x : ‚Ñù) : ‚Ñù
 : lean.parser (tactic unit)
(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ‚Ñ§] : Type (max u v)
 : nat_ordinal ‚âÉo ordinal
{Œ± : Type u_1} {Œ≤ : Type u_2} {G‚ÇÄ : Type u_3} [group_with_zero G‚ÇÄ] [topological_space G‚ÇÄ] [has_continuous_inv‚ÇÄ G‚ÇÄ] [has_continuous_mul G‚ÇÄ] [topological_space Œ±] [topological_space Œ≤] {a : Œ±} {f g : Œ± ‚Üí G‚ÇÄ} (h : Œ± ‚Üí G‚ÇÄ ‚Üí Œ≤) (hf : continuous_at f a) (hg : continuous_at g a) (hh : g a ‚â† 0 ‚Üí continuous_at ‚Üøh (a, f a / g a)) (h2h : g a = 0 ‚Üí filter.tendsto ‚Üøh ((nhds a).prod ‚ä§) (nhds (h a 0))) : continuous_at (Œª (x : Œ±), h x (f x / g x)) a
{Œ± : Type u_1} (o : part Œ±) : Œ±
{Œπ : Sort u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [complete_lattice Œ±] [complete_lattice Œ≤] (f : Œ± ‚âÉo Œ≤) {a : Œπ ‚Üí Œ±} (ha : complete_lattice.independent a) : complete_lattice.independent (‚áëf ‚àò a)
(M : Type u_1) [add_semigroup M] : add_subsemigroup M
{C : Type u} [category_theory.category C] {F : C ‚•§ C} {A : category_theory.endofunctor.algebra F} (h : category_theory.limits.is_initial A) : category_theory.is_iso A.str
{E : Type u} [normed_group E] [normed_space ‚Ñù E] (s : set E) (x : E) : set E
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] [algebra R S] {Œπ : Type w} [fintype Œπ] (b : basis Œπ R S) (x : R) : ‚áë(algebra.trace R S) (‚áë(algebra_map R S) x) = fintype.card Œπ ‚Ä¢ x
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : alternating_map R (n ‚Üí R) R n
{Œ± : Type u_1} [linear_ordered_field Œ±] {Œ≤ : Type u_2} [comm_ring Œ≤] {abv : Œ≤ ‚Üí Œ±} [is_absolute_value abv] (x : Œ≤) : cau_seq.completion.Cauchy
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) : Prop
{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_semiring R] {S : set M} (hS : submonoid.closure S = ‚ä§) : function.surjective ‚áë(mv_polynomial.aeval (Œª (s : ‚Ü•S), ‚áë(monoid_algebra.of R M) ‚Üës))
{Œ± : Type u_1} [decidable_eq Œ±] (f : equiv.perm Œ±) : Prop
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ùïú] [inner_product_space ùïú E] [inner_product_space ùïú F] [finite_dimensional ùïú E] [finite_dimensional ùïú F] (A : E ‚Üí‚Çó[ùïú] F) (x : E) (y : F) : has_inner.inner (‚áë(‚áëlinear_map.adjoint A) y) x = has_inner.inner y (‚áëA x)
{Œ± : Sort u_1} : level ‚Üí (name ‚Üí Œ± ‚Üí Œ±) ‚Üí Œ± ‚Üí Œ±
{Œ± : Type} : string ‚Üí list (widget.attr Œ±) ‚Üí list (widget.html Œ±) ‚Üí widget.html Œ±
{G‚ÇÅ : Type u_2} {G‚ÇÇ : Type u_3} [group G‚ÇÅ] [group G‚ÇÇ] [group.is_nilpotent G‚ÇÅ] [group.is_nilpotent G‚ÇÇ] : group.nilpotency_class (G‚ÇÅ √ó G‚ÇÇ) = linear_order.max (group.nilpotency_class G‚ÇÅ) (group.nilpotency_class G‚ÇÇ)
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ‚•§ D) [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.enough_projectives C] [category_theory.limits.preserves_finite_colimits F] {X : C} (P : category_theory.ProjectiveResolution X) : (F.left_derived 0).obj X ‚âÖ F.obj X
 : Type
(Œ± : Type u) : Type u
{C : Type u_1} [category_theory.category C] (r : hom_rel C) (s t : category_theory.quotient r) : Type u_2
 : category_theory.limits.is_terminal (CommRing.of punit)
(l : Type u_4) (R : Type u‚ÇÇ) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (unit ‚äï l ‚äï l) (unit ‚äï l ‚äï l) R)
 : tactic unit
{Œ± : Type u_1} : has_coe_t (finset Œ±) (set Œ±)
{Œπ : Type u} (s : finset Œπ) (f g : Œπ ‚Üí ennreal) {p : ‚Ñù} (hp : 1 ‚â§ p) : s.sum (Œª (i : Œπ), (f i + g i) ^ p) ^ (1 / p) ‚â§ s.sum (Œª (i : Œπ), f i ^ p) ^ (1 / p) + s.sum (Œª (i : Œπ), g i ^ p) ^ (1 / p)
{Œ± : Type u} [pseudo_metric_space Œ±] (x y : Œ±) : has_dist.dist x y = ‚Üë(has_nndist.nndist x y)
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] : clifford_algebra 0 ‚âÉ‚Çê[R] exterior_algebra R M
(R : Type u_1) (A : Type u_2) [comm_ring R] [comm_ring A] [algebra R A] : subalgebra R A
{L : first_order.language} {Œ± : Type u'} : list (Œ± ‚äï Œ£ (i : ‚Ñï), L.functions i) ‚Üí list (option (L.term Œ±))
{Œ± : Type u_1} [preorder Œ±] (s : set Œ±) : Prop
{A : Type u_4} {B : Type u_5} [monoid A] [monoid B] [topological_space A] [topological_space B] (f : A ‚Üí* B) (hf : continuous ‚áëf) : continuous_monoid_hom A B
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] : {x : Œ± | ‚àÉ (y : Œ±), x < y ‚àß set.Ioo x y = ‚àÖ}.countable
{Œ± : Type u_1} [partial_order Œ±] : subsingleton (succ_order Œ±)
(M : Type u_1) [has_mul M] : galois_insertion subsemigroup.closure coe
{R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {m : ‚Ñï} (x : M) (v : fin m ‚Üí M) (hli : linear_independent R v) (x_ortho : ‚àÄ (c : R) (y : ‚Ü•(submodule.span R (set.range v))), c ‚Ä¢ x + ‚Üëy = 0 ‚Üí c = 0) : linear_independent R (fin.cons x v)
(Œ± : Type u_1) (Œ≤ : Type u_2) [decidable_eq Œ±] [fintype Œ±] [encodable Œ≤] : trunc (encodable (Œ± ‚Üí Œ≤))
{A : Type u_1} {B : Type u_2} [comm_ring A] [comm_ring B] (f : A ‚Üí+* B) : Prop
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] (r : A) : topological_space.opens (projective_spectrum ùíú)
{R : Type u_1} [comm_ring R] : quaternion R ‚âÉ‚Çó[R] quaternion R
{G : Type u_1} [group G] (T : set G) : set (set G)
{M : Type u_1} [add_zero_class M] {s : set M} : s ‚äÜ ‚Üë(add_submonoid.closure s)
(c : tactic.eliminate.constructor_argument_info) : bool
{Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_action Œ± Œ≤] (x : Œ≤) : add_action.is_pretransitive Œ± ‚Ü•(add_action.orbit Œ± x)
{Œ± : Sort u_1} {s‚ÇÅ : setoid Œ±} (a : Œ±) : quotient s‚ÇÅ
{Œ± : Type u} [topological_space Œ±] (s : set Œ±) : set Œ±
{Œ± : Type u} [monoid Œ±] (f : ‚Ñï ‚Üí Œ±) (n : ‚Ñï) : (list.map f (list.range n.succ)).prod = f 0 * (list.map (Œª (i : ‚Ñï), f i.succ) (list.range n)).prod
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (ùïú' : Type u_2) [normed_ring ùïú'] [normed_algebra ùïú ùïú'] : is_bounded_bilinear_map ùïú (Œª (p : ùïú' √ó ùïú'), ‚áë(‚áë(continuous_linear_map.lmul_left_right ùïú ùïú') p.fst) p.snd)
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (c : add_con M) (f : M ‚Üí N) (H : ‚àÄ (x y : M), f (x + y) = f x + f y) (h : add_con.add_ker f H ‚â§ c) (hf : function.surjective f) : add_con N
{E : Type u_2} {ùïú : Type u_3} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] {s : set E} (hs : convex ùïú s) {a b : ùïú} (ha : 0 < a) (hb : 0 ‚â§ b) (hab : a + b = 1) : a ‚Ä¢ interior s + b ‚Ä¢ closure s ‚äÜ interior s
(A : Type u) [comm_ring A] [is_domain A] [discrete_valuation_ring A] : valuation_ring A
 : setoid Well_order
{s : ‚ÑÇ} (hs : 0 < s.re) : (s + 1).Gamma_integral = s * s.Gamma_integral
 : Type
{Œ± : Type u} [ordered_semiring Œ±] [nontrivial Œ±] : 0 < 2
 : Type
{Œ± : Type u} {l : list Œ±} : l.nodup ‚Üí l.attach.nodup
{R : Type u_2} [comm_semiring R] : has_coe (polynomial R) (power_series R)
{X Y Z : Type u} (f : X ‚ü∂ Y) {g h : Y ‚ü∂ Z} (w : f ‚â´ g = f ‚â´ h) (t : category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ f w)) (y : Y) (hy : g y = h y) : ‚àÉ! (x : X), f x = y
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {n : ‚Ñï} : iterated_fderiv ùïú (n + 1) f = ‚áë(continuous_multilinear_curry_left_equiv ùïú (Œª (i : fin (n + 1)), E) F) ‚àò fderiv ùïú (iterated_fderiv ùïú n f)
 : category_theory.limits.walking_cospan ‚•§ category_theory.limits.walking_cospan
{Œ± : Type u_1} {Œπ : Type u_4} [topological_space Œ±] [encodable Œπ] {s : Œπ ‚Üí set Œ±} (hs : ‚àÄ (i : Œπ), is_GŒ¥ (s i)) : is_GŒ¥ (‚ãÇ (i : Œπ), s i)
(m : Type u_1) (R : Type u_3) [decidable_eq m] [fintype m] [comm_ring R] [nontrivial R] : (matrix.mv_polynomial_X m m R).det ‚â† 0
{Œ± : Type u_1} [decidable_eq Œ±] (s : finset Œ±) : (finset.image quotient.mk s.off_diag).card = s.card.choose 2
{E : Type u_1} [add_comm_group E] [star_add_monoid E] [module ‚ÑÇ E] [star_module ‚ÑÇ E] : ‚Ü•(skew_adjoint E) ‚âÉ‚Çó[‚Ñù] ‚Ü•(self_adjoint E)
{C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] (F : J ‚•§ C) [category_theory.limits.has_colimit (category_theory.discrete.functor F.obj)] [category_theory.limits.has_colimit (category_theory.discrete.functor (Œª (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), F.obj f.fst.fst))] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimit F
{ùïú : Type u_1} {E : Type u_2} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] {p : formal_multilinear_series ùïú ùïú E} {x : ùïú} (h : has_fpower_series_at 0 p x) : p = 0
{M : Type u_1} [monoid M] {s‚ÇÅ s‚ÇÇ : set M} (is‚ÇÅ : is_submonoid s‚ÇÅ) (is‚ÇÇ : is_submonoid s‚ÇÇ) : is_submonoid (s‚ÇÅ ‚à© s‚ÇÇ)
(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) : ‚áë(polynomial.aeval x) (minpoly A x) = 0
{Œ± : Type u} {Œ≤ : Type v} (f : stream (Œ± ‚Üí Œ≤)) (s : stream Œ±) : stream Œ≤
 : ennreal ‚Üí* nnreal
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : set Œ± ‚Üí Prop
(Œ± : Type) : Type
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (x : E) : Prop
 : ‚Ñï ‚Üí W_type W_type.nat_Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ w)
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {s t : set Œ±} (hst : s ‚äÜ t) (ht : t.finite) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)) * finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà t  s), f i)) = finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà t), f i))
{M‚ÇÄ : Type u_1} [cancel_monoid_with_zero M‚ÇÄ] {a b : M‚ÇÄ} (h‚ÇÅ : b ‚â† 1) (h‚ÇÇ : b * a = a) : a = 0
{ùïú : Type u_1} [is_R_or_C ùïú] : inner_product_space ùïú ùïú
(R : Type u_1) [comm_semiring R] (X : Type u_2) : has_add (free_algebra.pre R X)
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] {a : Œ±} : a‚Åª¬π ‚â§ 1 ‚Üî 1 ‚â§ a
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 ‚Üî subsingleton V
{Œ± : Type u_1} (f g : Œ± ‚Üí Œ±) : Prop
{Œ± : Type u_1} (p : Prop) (o : part Œ±) (H : p ‚Üí o.dom) : part Œ±
{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (monoid_algebra R M)] : monoid.fg M
{L : first_order.language} {Œ± : Type w} {n : ‚Ñï} (T : L.Theory) : setoid (L.bounded_formula Œ± n)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') (c : category_theory.limits.cone F) : (category_theory.limits.cones.postcompose (category_theory.whisker_left F Œ±.hom)).obj (H.map_cone c) ‚âÖ H'.map_cone c
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] {c : con M} {d : con N} {C : c.quotient ‚Üí d.quotient ‚Üí Prop} (p : c.quotient) (q : d.quotient) (H : ‚àÄ (x : M) (y : N), C ‚Üëx ‚Üëy) : C p q
{Œ± : Type u_1} [pseudo_metric_space Œ±] {x : Œ±} {E : set Œ±} (hx : x ‚àà E) (Œ¥ : ‚Ñù) : metric.closed_ball x Œ¥ ‚äÜ metric.cthickening Œ¥ E
{V : Type u‚ÇÅ} [quiver V] {C : Type u_1} [category_theory.category C] {F G : category_theory.paths V ‚•§ C} (h_obj : F.obj = G.obj) (h : ‚àÄ (a b : V) (e : a ‚ü∂ b), F.map e.to_path = category_theory.eq_to_hom _ ‚â´ G.map e.to_path ‚â´ category_theory.eq_to_hom _) : F = G
{Œ± : Type u_1} [partial_order Œ±] [bounded_order Œ±] [is_simple_order Œ±] [decidable_eq Œ±] : linear_order Œ±
{Œ± : Type u_1} {E : Œ± ‚Üí Type u_2} [Œ† (i : Œ±), normed_group (E i)] (f : Œ† (i : Œ±), E i) (p : ennreal) : Prop
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : smul_comm_class R L L
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} [category_theory.is_equivalence F] : category_theory.is_left_adjoint F
{Œ± : Type u_2} {Œ≤ : Type u_3} [complete_lattice Œ±] [complete_lattice Œ≤] : has_coe_to_fun (frame_hom Œ± Œ≤) (Œª (_x : frame_hom Œ± Œ≤), Œ± ‚Üí Œ≤)
{Œ± : Type u_1} {Œ≤ : Type u_2} (p : two_pointing Œ±) (q : two_pointing Œ≤) : two_pointing (Œ± ‚äï Œ≤)
{Œ± : Type u} : Œ± ‚Üí ulift Œ±
{Œ± : Type u} (x : Œ±) : ordnode Œ± ‚Üí ordnode Œ±
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ‚Ñù E] [normed_group F] [normed_space ‚Ñù F] {s : set E} (s_conv : convex ‚Ñù s) {f : E ‚Üí F} {f' : E ‚Üí (E ‚ÜíL[‚Ñù] F)} {f'' : E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] F} (hf : ‚àÄ (x : E), x ‚àà interior s ‚Üí has_fderiv_at f (f' x) x) {x : E} (xs : x ‚àà s) (hx : has_fderiv_within_at f' f'' (interior s) x) {v w : E} (h4v : x + 4 ‚Ä¢ v ‚àà interior s) (h4w : x + 4 ‚Ä¢ w ‚àà interior s) : (Œª (h : ‚Ñù), f (x + h ‚Ä¢ (2 ‚Ä¢ v + 2 ‚Ä¢ w)) + f (x + h ‚Ä¢ (v + w)) - f (x + h ‚Ä¢ (2 ‚Ä¢ v + w)) - f (x + h ‚Ä¢ (v + 2 ‚Ä¢ w)) - h ^ 2 ‚Ä¢ ‚áë(‚áëf'' v) w) =o[nhds_within 0 (set.Ioi 0)] Œª (h : ‚Ñù), h ^ 2
{Œ± : Type u_4} {Œ≤ : Type u_5} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) : Type (max u_4 u_5)
(P L : Type u) [has_mem P L] : Type u
{ùïú : Type u_1} {E : Type u_4} {F‚Çó : Type u_7} [normed_group E] [normed_group F‚Çó] [nondiscrete_normed_field ùïú] [normed_space ùïú E] [normed_space ùïú F‚Çó] (c : E ‚ÜíL[ùïú] ùïú) (f : F‚Çó) : ‚à•c.smul_right f‚à•‚Çä = ‚à•c‚à•‚Çä * ‚à•f‚à•‚Çä
(c : cardinal) : Prop
{Œ± : Type u_6} {Œ≤ : Type u_7} [has_mul Œ≤] [has_scalar Œ± Œ≤] [is_scalar_tower Œ± Œ≤ Œ≤] (r : Œ±) (x y : Œ≤) : r ‚Ä¢ x * y = r ‚Ä¢ (x * y)
{Œ± : Type u_3} {Œ≤ : Type u_4} [lattice Œ±] [lattice Œ≤] : has_coe_to_fun (lattice_hom Œ± Œ≤) (Œª (_x : lattice_hom Œ± Œ≤), Œ± ‚Üí Œ≤)
{Œ± : Type u} {s t : set Œ±} (h : s = t) : ‚Ü•s ‚âÉ ‚Ü•t
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] : category_theory.limits.is_colimit (category_theory.limits.biprod.inl_cokernel_fork X Y)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} {c : category_theory.limits.pullback_cone f g} (h : category_theory.limits.is_limit c) : category_theory.is_pullback c.fst c.snd f g
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_coequalizer f g] [category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G] : category_theory.limits.is_colimit (category_theory.limits.cofork.of_œÄ (G.map (category_theory.limits.coequalizer.œÄ f g)) _)
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u} [category_theory.category J] (F : J ‚•§ C) [category_theory.limits.has_initial J] [category_theory.limits.has_limit F] : category_theory.limits.limit F ‚âÖ F.obj (‚ä•_ J)
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_comm_monoid M] {s : set Œ±} {t : set Œ≤} (f : Œ± ‚Üí Œ≤ ‚Üí M) (hs : s.finite) (ht : t.finite) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), finsum (Œª (j : Œ≤), finsum (Œª (H : j ‚àà t), f i j)))) = finsum (Œª (j : Œ≤), finsum (Œª (H : j ‚àà t), finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i j))))
(C : Type u) [category_theory.category C] : C ‚•§ category_theory.cosimplicial_object C
(z : ‚ÑÇ) : ‚ÑÇ
(M : Type u_1) (Œ± : Type u_2) : Type (max u_1 u_2)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (X : C) : Type (max u‚ÇÅ v‚ÇÅ)
(ùïú : Type u) {n : ‚Ñï} (Ei : fin n.succ ‚Üí Type wEi) (G : Type wG) [nondiscrete_normed_field ùïú] [Œ† (i : fin n.succ), normed_group (Ei i)] [Œ† (i : fin n.succ), normed_space ùïú (Ei i)] [normed_group G] [normed_space ùïú G] : (Ei 0 ‚ÜíL[ùïú] continuous_multilinear_map ùïú (Œª (i : fin n), Ei i.succ) G) ‚âÉ‚Çó·µ¢[ùïú] continuous_multilinear_map ùïú Ei G
{Œ± : Type u_1} {Œ≤ : Type u_2} [primcodable Œ±] [primcodable Œ≤] (p : Œ± ‚Üí Prop) (q : Œ≤ ‚Üí Prop) : Prop
(ps : tactic.ring_exp.ex tactic.ring_exp.ex_type.sum) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum)
(F : Type v‚ÇÄ ‚Üí Type v‚ÇÅ) (G : Type (max v‚ÇÄ u‚ÇÄ) ‚Üí Type u‚ÇÅ) [uliftable F G] [monad G] {Œ± : Type v‚ÇÄ} {Œ≤ : Type (max v‚ÇÄ u‚ÇÄ)} (x : F Œ±) (f : Œ± ‚Üí G Œ≤) : G Œ≤
{R : Type u_1} [comm_semiring R] {X : Type u_2} : free_algebra R X ‚âÉ‚Çê[R] (free_algebra R X)·µê·µí·µñ
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] {C : Type u} [category_theory.category C] (F : J √ó K ‚•§ C) [category_theory.limits.has_limits_of_shape J C] [category_theory.limits.has_colimits_of_shape K C] : category_theory.limits.colimit (category_theory.curry.obj (category_theory.prod.swap K J ‚ãô F) ‚ãô category_theory.limits.lim) ‚ü∂ category_theory.limits.limit (category_theory.curry.obj F ‚ãô category_theory.limits.colim)
{V : Type u_2} [semi_normed_group V] : normed_add_torsor V V
{B : Type u} [quiver B] {a b c : B} (p : quiver.path a b) {f g : category_theory.free_bicategory.hom b c} (Œ∑ : f ‚ü∂ g) : category_theory.bicategory.whisker_left ((category_theory.free_bicategory.preinclusion B).map {as := p}) Œ∑ ‚â´ (category_theory.free_bicategory.normalize_iso p g).hom = (category_theory.free_bicategory.normalize_iso p f).hom ‚â´ (category_theory.free_bicategory.preinclusion B).map‚ÇÇ (category_theory.eq_to_hom _)
{R : Type u} [comm_ring R] (U V : topological_space.opens ‚Ü•(algebraic_geometry.prime_spectrum.Top R)) (hUV : U = V) : algebraic_geometry.structure_sheaf.comap (ring_hom.id R) U V _ = category_theory.eq_to_hom _
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b : Œ±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{R : Type u} [comm_ring R] {g : polynomial R} (hg : g.monic) : adjoin_root g ‚Üí‚Çó[R] polynomial R
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : submodule K V) : s.fg ‚Üî finite_dimensional K ‚Ü•s
{Œ± : Type u_2} {M‚ÇÅ : Type u_6} {M‚ÇÇ : Type u_7} [topological_space M‚ÇÇ] [t2_space M‚ÇÇ] [mul_one_class M‚ÇÅ] [mul_one_class M‚ÇÇ] [has_continuous_mul M‚ÇÇ] {F : Type u_8} [monoid_hom_class F M‚ÇÅ M‚ÇÇ] {l : filter Œ±} (f : M‚ÇÅ ‚Üí M‚ÇÇ) (g : Œ± ‚Üí F) [l.ne_bot] (h : filter.tendsto (Œª (a : Œ±) (x : M‚ÇÅ), ‚áë(g a) x) l (nhds f)) : M‚ÇÅ ‚Üí* M‚ÇÇ
{Œ± : Type u_1} [partial_order Œ±] {s : set Œ±} (hs : s.is_wf) (hn : s.nonempty) : Œ±
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) (f : Œ± ‚Üí Œ≤ ‚Üí Prop) (ha : ‚àÄ (a : Œ±) (b‚ÇÅ b‚ÇÇ : Œ≤), s b‚ÇÅ b‚ÇÇ ‚Üí f a b‚ÇÅ = f a b‚ÇÇ) (hb : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±) (b : Œ≤), r a‚ÇÅ a‚ÇÇ ‚Üí f a‚ÇÅ b = f a‚ÇÇ b) [hf : Œ† (a : Œ±), decidable_pred (f a)] (q‚ÇÅ : quot r) : decidable_pred (quot.lift‚ÇÇ f ha hb q‚ÇÅ)
 : ‚ÑÇ ‚âÉ‚Çê[‚Ñù] ‚ÑÇ
(tp : expr) : tactic expr
(R : Type u) (M : Type v) (M‚ÇÇ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] : (M ‚Üí‚Çó[R] M) √ó (M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÇ) ‚Üí+* M √ó M‚ÇÇ ‚Üí‚Çó[R] M √ó M‚ÇÇ
{R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [topological_space M] [topological_space M‚ÇÇ] [semiring R] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] [add_comm_monoid M] [module R M] : (M ‚ÜíL[R] M‚ÇÇ) ‚Üí (M‚ÇÇ ‚ÜíL[R] M)
(J : Type u‚ÇÅ) : Type u‚ÇÅ
{Œ± : Type u_1} [decidable_eq Œ±] {ùíú : finset (finset Œ±)} {s : finset Œ±} : s ‚àà ùíú.shadow ‚Üî ‚àÉ (t : finset Œ±) (H : t ‚àà ùíú) (a : Œ±) (H : a ‚àà t), t.erase a = s
{G : Type u_1} [measurable_space G] [add_group G] [has_measurable_add G] (g : G) : G ‚âÉ·µê G
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x : Œ±} (h : x ‚àà s) : metric.inf_dist x s = 0
{C : Type u} [category_theory.category C] {F : C ‚•§ C} {A‚ÇÄ A‚ÇÅ : category_theory.endofunctor.algebra F} (f : A‚ÇÄ ‚ü∂ A‚ÇÅ) [category_theory.is_iso f.f] : category_theory.is_iso f
{Œ± : Type u} [has_mul Œ±] : Œ± ‚âÉ* Œ±·µÉ·µí·µñ
{G : Type u_1} [group G] {k : set G} {p : G ‚Üí G ‚Üí Prop} {x y : G} (hx : x ‚àà subgroup.closure k) (hy : y ‚àà subgroup.closure k) (Hk : ‚àÄ (x : G), x ‚àà k ‚Üí ‚àÄ (y : G), y ‚àà k ‚Üí p x y) (H1_left : ‚àÄ (x : G), p 1 x) (H1_right : ‚àÄ (x : G), p x 1) (Hmul_left : ‚àÄ (x‚ÇÅ x‚ÇÇ y : G), p x‚ÇÅ y ‚Üí p x‚ÇÇ y ‚Üí p (x‚ÇÅ * x‚ÇÇ) y) (Hmul_right : ‚àÄ (x y‚ÇÅ y‚ÇÇ : G), p x y‚ÇÅ ‚Üí p x y‚ÇÇ ‚Üí p x (y‚ÇÅ * y‚ÇÇ)) (Hinv_left : ‚àÄ (x y : G), p x y ‚Üí p x‚Åª¬π y) (Hinv_right : ‚àÄ (x y : G), p x y ‚Üí p x y‚Åª¬π) : p x y
 : tactic unit
 : tactic (name_map name)
{Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_action Œ± Œ≤] {x y : Œ≤} (h : (add_action.orbit_rel Œ± Œ≤).rel x y) : ‚Ü•(add_action.stabilizer Œ± x) ‚âÉ+ ‚Ü•(add_action.stabilizer Œ± y)
 : expr_lens.dir ‚Üí string
 : expr ‚Üí expr ‚Üí tactic ‚Ñï
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : ùü≠ D ‚ü∂ e.inverse ‚ãô e.functor
(rec : interactive.parse (optional (lean.parser.tk "*"))) (ps : interactive.parse interactive.types.pexpr_list_or_texpr) : tactic unit
 : cc_state ‚Üí expr ‚Üí expr
{Œ∫ : Type w} (A : Type u) {B : Type v} [comm_ring A] [comm_ring B] [algebra A B] (b : Œ∫ ‚Üí B) : matrix Œ∫ Œ∫ A
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) (i j k : D.to_glue_data.J) (U : topological_space.opens ‚Ü•((category_theory.limits.pullback (D.to_glue_data.f i j) (D.to_glue_data.f i k)).carrier)) : ‚àÉ (eq_1 : (topological_space.opens.map (D.to_glue_data.t k i).base).op.obj (opposite.op (_.open_functor.obj U)) = opposite.op (_.open_functor.obj (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U))))), _.inv_app U ‚â´ (D.to_glue_data.t k i).c.app (opposite.op (_.open_functor.obj U)) ‚â´ (D.to_glue_data.V (k, i)).presheaf.map (category_theory.eq_to_hom eq_1) = (D.to_glue_data.t' k i j).c.app (opposite.op U) ‚â´ _.inv_app (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U)))
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : free_abelian_group Œ± ‚âÉ+ free_abelian_group Œ≤) : Œ± ‚âÉ Œ≤
 : Type (u_1+1)
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [regular_space Y] {f : X ‚Üí Y} {A : set X} (hA : dense A) (hf : ‚àÄ (x : X), ‚àÉ (y : Y), filter.tendsto f (nhds_within x A) (nhds y)) : continuous (extend_from A f)
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) (i j k : D.to_glue_data.J) (U : topological_space.opens ‚Ü•((category_theory.limits.pullback (D.to_glue_data.f i j) (D.to_glue_data.f i k)).carrier)) : _.inv_app U ‚â´ (D.to_glue_data.t k i).c.app (opposite.op (_.open_functor.obj U)) = (D.to_glue_data.t' k i j).c.app (opposite.op U) ‚â´ _.inv_app (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U))) ‚â´ (D.to_glue_data.V (k, i)).presheaf.map (category_theory.eq_to_hom _)
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] {f : M ‚Üí* N} (hf : function.injective ‚áëf) : galois_coinsertion (submonoid.map f) (submonoid.comap f)
 : Type (u_1+1)
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± : D·µí·µñ ‚•§ A} {‚Ñ±' : category_theory.Sheaf K A} (Œ± : G.op ‚ãô ‚Ñ± ‚ü∂ G.op ‚ãô ‚Ñ±'.val) : ‚Ñ± ‚ãô category_theory.yoneda ‚ü∂ ‚Ñ±'.val ‚ãô category_theory.yoneda
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (P : C·µí·µñ ‚•§ Type w) {S : category_theory.sieve X} {R : category_theory.presieve X} (h : ‚áëS ‚â§ R) (hS : category_theory.presieve.is_sheaf_for P ‚áëS) (trans : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, R f ‚Üí category_theory.presieve.is_separated_for P ‚áë(category_theory.sieve.pullback f S)) : category_theory.presieve.is_sheaf_for P R
{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_regular (a + b)) (ba : is_add_regular (b + a)) : is_add_regular a ‚àß is_add_regular b
{Œ≤ : Type v} [has_zero Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_scalar ‚Ñï Œ≤] {Œ± : Type u} [non_assoc_semiring Œ±] [has_one Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_assoc_semiring Œ≤
(Œ± : Type u) [topological_space Œ±] : Prop
(cfg : auto.auto_config) : tactic unit
{Œπ : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] [topological_space R] (B : Œπ ‚Üí submodule R M) : Prop
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J ‚Üí C) [category_theory.limits.has_biproduct f] : C
{R : Type u} [semiring R] : polynomial R ‚Üí ‚Ñï ‚Üí R
{Œ± : Type} [preorder Œ±] [bounded_random Œ±] (x y : Œ±) (h : x ‚â§ y) : io (stream ‚Ü•(set.Icc x y))
(R : Type u) [comm_ring R] : category_theory.lax_monoidal (Module.free R).obj
(d : pos_num) (q r : num) : num √ó num
(S : set ‚Ñï+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] : is_cyclotomic_extension S A B ‚Üî (‚àÄ (a : ‚Ñï+), a ‚àà S ‚Üí (‚àÉ (r : B), ‚áë(polynomial.aeval r) (polynomial.cyclotomic ‚Üëa A) = 0)) ‚àß algebra.adjoin A {b : B | ‚àÉ (a : ‚Ñï+), a ‚àà S ‚àß b ^ ‚Üëa = 1} = ‚ä§
{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X ‚Üí Y} {s : set X} (hf : holder_on_with C r f s) (h0 : 0 < r) : uniform_continuous_on f s
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b : Œ±} : -a < -b ‚Üí b < a
 : category_theory.has_forget‚ÇÇ UniformSpace Top
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {S T : category_theory.sieve X} (h : S ‚â§ T) : S.functor ‚ü∂ T.functor
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : set Œ±) : Prop
{Œ± : Type u_1} : well_founded has_lt.lt
(a b c d : list turing.partrec_to_TM2.Œì') : turing.partrec_to_TM2.K' ‚Üí list turing.partrec_to_TM2.Œì'
{m : Type v ‚Üí Type w} [monad m] {Œ± : Type u_1} {Œ≤ : Type v} (f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤ ‚Üí m Œ≤) (b : Œ≤) (as : list Œ±) : m Œ≤
(s : string) : parser unit
{L : first_order.language} {M : Type w} [L.Structure M] (S : L.substructure M) : set M
{M : Type u_1} [has_add M] (c : add_con M) {x y z : M} : ‚áëc x y ‚Üí ‚áëc y z ‚Üí ‚áëc x z
{x : pgame} : x.right_moves ‚âÉ (-x).left_moves
(Œ± : Sort u_1) : (Œ± ‚Üí punit) ‚âÉ punit
(ic : tactic.instance_cache) (a b : expr) (na nb : ‚Ñö) : tactic (tactic.instance_cache √ó expr √ó expr)
{Œ± : Type u_1} [encodable Œ±] : encodable (finset Œ±)
{R : Type u} [comm_semiring R] (r : R) : ‚áëpolynomial.C r = ‚áë(algebra_map R (polynomial R)) r
{Œ± : Type u_2} {Œ≤ : Type u_3} [linear_ordered_field Œ±] [linear_ordered_field Œ≤] [archimedean Œ≤] : subsingleton (Œ± ‚Üí+*o Œ≤)
{x n : ‚Ñï} (h : x.coprime n) : x ^ n.totient ‚â° 1 [MOD n]
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] [complete_space E] {f : ‚Ñù ‚Üí E} {T : ‚Ñù} (hf : function.periodic f T) (t s : ‚Ñù) : ‚à´ (x : ‚Ñù) in t..t + T, f x = ‚à´ (x : ‚Ñù) in s..s + T, f x
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [u : uniform_space Œ≤] (f : Œ± ‚Üí Œ≤) (h : embedding f) : uniform_space Œ±
{Œ± : Type u} [preorder Œ±] {s : set Œ±} : ¬¨bdd_below s ‚Üî ‚àÄ (x : Œ±), ‚àÉ (y : Œ±) (H : y ‚àà s), ¬¨x ‚â§ y
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Ü™ Œ≤) : multiset Œ± ‚Ü™o multiset Œ≤
{Œ± : Type u_2} [add_monoid Œ±] : add_monoid (filter Œ±)
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (i : D ‚•§ C) [category_theory.limits.has_finite_products C] [category_theory.reflective i] [category_theory.cartesian_closed C] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) (category_theory.left_adjoint i)] : category_theory.exponential_ideal i
(q : ‚Ñö) : pexpr
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (F : C ‚•§ D) : set D
{M : Type u} [comm_monoid_with_zero M] {n : ‚Ñï} (hn : 0 < n) : M ‚Üí*‚ÇÄ M
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (a b c p : P) (h : euclidean_geometry.angle b p c = real.pi) : has_dist.dist a b ^ 2 * has_dist.dist c p + has_dist.dist a c ^ 2 * has_dist.dist b p = has_dist.dist b c * (has_dist.dist a p ^ 2 + has_dist.dist b p * has_dist.dist c p)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Group) : subgroup (Œ† (j : J), ‚Ü•(F.obj j))
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_unital_non_assoc_semiring Œ±} {rŒ≤ : non_unital_non_assoc_semiring Œ≤} : has_coe_to_fun (Œ± ‚Üí‚Çô+* Œ≤) (Œª (_x : Œ± ‚Üí‚Çô+* Œ≤), Œ± ‚Üí Œ≤)
{Œ± : Type u_1} {Œ≤ : Type u_2} [complete_lattice Œ±] {f : filter Œ≤} : f.limsup (Œª (x : Œ≤), ‚ä•) = ‚ä•
{m : Type v ‚Üí Type w} [applicative m] {Œ± : Type u_1} (f : ‚Ñï ‚Üí Œ± ‚Üí m punit) : ‚Ñï ‚Üí list Œ± ‚Üí m punit
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] (Q : quadratic_form R M) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] {Z : C} (l : Z ‚ü∂ X) (i : Z ‚âÖ category_theory.limits.kernel f) (h : i.hom ‚â´ category_theory.limits.kernel.Œπ f = l) : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ l _)
{C : Type u} [category_theory.category C] {X Y Z : algebraic_geometry.PresheafedSpace C} (f : X ‚ü∂ Y) [hf : algebraic_geometry.PresheafedSpace.is_open_immersion f] (g : Y ‚ü∂ Z) [hg : algebraic_geometry.PresheafedSpace.is_open_immersion g] : algebraic_geometry.PresheafedSpace.is_open_immersion (f ‚â´ g)
{Œ± : Type v} : ulift Œ± ‚âÉ Œ±
{M : Type u_1} [has_mul M] {c : con M} (x y : M) : ‚Üë(x * y) = ‚Üëx * ‚Üëy
{Œ± : Type u} {Œ≤ : Type v} [comm_semiring Œ≤] (f g : Œ± ‚Üí Œ≤) (s : finset Œ±) : s.prod (Œª (a : Œ±), f a + g a) = s.powerset.sum (Œª (t : finset Œ±), t.prod (Œª (a : Œ±), f a) * (s  t).prod (Œª (a : Œ±), g a))
{Œ± : Type u_1} [has_le Œ±] (s : upper_set Œ±) : lower_set Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≤) (b : Œ≤) (l : list Œ±) : Œ≤
{C : Type v} [category_theory.category C] [category_theory.concrete_category C] {X Y : C} : has_coe_to_fun (X ‚ü∂ Y) (Œª (f : X ‚ü∂ Y), ‚Ü•X ‚Üí ‚Ü•Y)
{Œ± : Type u_1} [lattice Œ±] [bounded_order Œ±] [is_simple_order Œ±] : distrib_lattice Œ±
 : tactic unit
{C : Type u} [category_theory.category C] {F : category_theory.limits.walking_parallel_pair ‚•§ C} (t : category_theory.limits.cofork (F.map category_theory.limits.walking_parallel_pair_hom.left) (F.map category_theory.limits.walking_parallel_pair_hom.right)) : category_theory.limits.cocone F
{n : ‚Ñï} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [Œ† (i : Œπ), has_zero (Œ≤ i)] [fintype Œπ] : (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚âÉ Œ† (i : Œπ), Œ≤ i
{n : ‚Ñï} {x : fin (n + 1)} : function.injective ‚áë(x.succ_above)
(Œ± : Type u_1) : Type u_1
{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {a‚ÇÅ a‚ÇÇ : Œ±} {b‚ÇÅ b‚ÇÇ : Œ≤} (q‚ÇÅ : path.homotopic.quotient a‚ÇÅ a‚ÇÇ) (q‚ÇÇ : path.homotopic.quotient b‚ÇÅ b‚ÇÇ) : path.homotopic.quotient (a‚ÇÅ, b‚ÇÅ) (a‚ÇÇ, b‚ÇÇ)
 : ‚Ñï ‚Üí tree ‚Ñï ‚Üí expr ‚Üí tactic expr
{L : first_order.language} {T : L.Theory} : T.is_satisfiable ‚Üî T.is_finitely_satisfiable
{G : Type u_1} [group G] : ‚Ü•‚ä§ ‚âÉ* G
{E : Type u} [normed_group E] [normed_space ‚Ñù E] [complete_space E] {n : ‚Ñï} (a b : fin (n + 1) ‚Üí ‚Ñù) (hle : a ‚â§ b) (f : fin (n + 1) ‚Üí (fin (n + 1) ‚Üí ‚Ñù) ‚Üí E) (f' : fin (n + 1) ‚Üí (fin (n + 1) ‚Üí ‚Ñù) ‚Üí ((fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E)) (s : set (fin (n + 1) ‚Üí ‚Ñù)) (hs : s.countable) (Hc : ‚àÄ (i : fin (n + 1)), continuous_on (f i) (set.Icc a b)) (Hd : ‚àÄ (x : fin (n + 1) ‚Üí ‚Ñù), x ‚àà set.univ.pi (Œª (i : fin (n + 1)), set.Ioo (a i) (b i))  s ‚Üí ‚àÄ (i : fin (n + 1)), has_fderiv_at (f i) (f' i x) x) (Hi : measure_theory.integrable_on (Œª (x : fin (n + 1) ‚Üí ‚Ñù), finset.univ.sum (Œª (i : fin (n + 1)), ‚áë(f' i x) (pi.single i 1))) (set.Icc a b) measure_theory.measure_space.volume) : ‚à´ (x : fin (n + 1) ‚Üí ‚Ñù) in set.Icc a b, finset.univ.sum (Œª (i : fin (n + 1)), ‚áë(f' i x) (pi.single i 1)) = finset.univ.sum (Œª (i : fin (n + 1)), (‚à´ (x : fin n ‚Üí ‚Ñù) in set.Icc (a ‚àò ‚áë(i.succ_above)) (b ‚àò ‚áë(i.succ_above)), f i (i.insert_nth (b i) x)) - ‚à´ (x : fin n ‚Üí ‚Ñù) in set.Icc (a ‚àò ‚áë(i.succ_above)) (b ‚àò ‚áë(i.succ_above)), f i (i.insert_nth (a i) x))
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : (Œ± ‚äï Œ≤) √ó Œ≥ ‚âÉ Œ± √ó Œ≥ ‚äï Œ≤ √ó Œ≥
{V : Type u} {K : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] [hK : invertible 2] {B : bilin_form K V} (hB‚ÇÇ : B.is_symm) : ‚àÉ (v : basis (fin (finite_dimensional.finrank K V)) K V), B.is_Ortho ‚áëv
{R : Type u} [field R] (p q : polynomial R) : polynomial R
{M : Type u_1} [semigroup M] : stream M ‚Üí set M
(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) : polynomial A
{Œ± : Type u_2} [has_add Œ±] : add_hom Œ± (filter Œ±)
(q : interactive.parse interactive.types.texpr) : tactic unit
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : euclidean_geometry.angle p1 p2 p3 ‚â§ real.pi
{Œ± : Type u_1} [preorder Œ±] [add_comm_semigroup Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b c : Œ±} [covariant_class Œ± Œ± has_add.add has_le.le] : a + b - c ‚â§ a + (b - c)
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) : hb.oangle (-x) y = hb.oangle x y + ‚Üëreal.pi
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b : Œ±} : b < a ‚Üí 0 < a - b
{R : Type u_1} [comm_semiring R] (p : polynomial R) : Prop
 : simps_cfg
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {s : set E} {t : set F} {g : F ‚Üí G} {f : E ‚Üí F} (hg : cont_diff_on ùïú n g t) (hf : cont_diff_on ùïú n f s) : cont_diff_on ùïú n (g ‚àò f) (s ‚à© f ‚Åª¬π' t)
{X Y Z : algebraic_geometry.LocallyRingedSpace} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [H : algebraic_geometry.LocallyRingedSpace.is_open_immersion f] : algebraic_geometry.LocallyRingedSpace.is_open_immersion category_theory.limits.pullback.fst
(M : Type u_1) [monoid M] (X : Type u) [mul_action M X] : Type u
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x : Œ±} : 0 ‚â§ metric.inf_dist x s
{Œ± : Type u_1} [lattice Œ±] [order_bot Œ±] {a b : Œ±} (P : finpartition a) {parts : finset Œ±} (subset : parts ‚äÜ P.parts) (sup_parts : parts.sup id = b) : finpartition b
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] [conditionally_complete_linear_order B] [order_topology B] (h : is_topological_fiber_bundle F proj) (a b : B) : ‚àÉ (e : topological_fiber_bundle.trivialization F proj), set.Icc a b ‚äÜ e.base_set
(R : Type u_1) (A : Type u_2) [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A] [invertible 2] : A ‚âÉ‚Çó[R] ‚Ü•(self_adjoint A) √ó ‚Ü•(skew_adjoint A)
{M : Type u_1} [cancel_comm_monoid_with_zero M] {q : associates M} {n : ‚Ñï} (hn : n ‚â† 0) {c : fin (n + 1) ‚Üí associates M} (h‚ÇÅ : strict_mono c) (h‚ÇÇ : ‚àÄ {r : associates M}, r ‚â§ q ‚Üî ‚àÉ (i : fin (n + 1)), r = c i) (hq : q ‚â† 0) : irreducible (c 1)
(R : Type u_1) [ring R] : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_mul Œ±] [preorder Œ±] [preorder Œ≤] {f g : Œ≤ ‚Üí Œ±} [covariant_class Œ± Œ± has_mul.mul has_le.le] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_lt.lt] (hf : strict_mono f) (hg : monotone g) : strict_mono (Œª (x : Œ≤), f x * g x)
(R : Type u_2) (M : Type u_3) (P : Type u_5) (Q : Type u_6) [comm_ring R] [add_comm_group M] [add_comm_group P] [add_comm_group Q] [module R M] [module R P] [module R Q] [module.free R M] [module.finite R M] [nontrivial R] : tensor_product R (M ‚Üí‚Çó[R] P) Q ‚âÉ‚Çó[R] M ‚Üí‚Çó[R] tensor_product R P Q
 : derive_handler
(Œ± : Type u_1) [topological_space Œ±] [polish_space Œ±] [nonempty Œ±] : ‚àÉ (f : (‚Ñï ‚Üí ‚Ñï) ‚Üí Œ±), continuous f ‚àß function.surjective f
{R : Type u} [semiring R] {p q : polynomial R} : p * q = p.support.sum (Œª (i : ‚Ñï), q.sum (Œª (j : ‚Ñï) (a : R), ‚áë(polynomial.monomial (i + j)) (p.coeff i * a)))
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_vsub Œ± Œ≤] : has_vsub (filter Œ±) (filter Œ≤)
{R : Type u_1} [comm_semiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] {g h : tensor_product R M N ‚Üí‚Çó[R] P} (H : (tensor_product.mk R M N).compr‚ÇÇ g = (tensor_product.mk R M N).compr‚ÇÇ h) : g = h
{X : Type u_1} [topological_space X] (x : X) : set X
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s u : set E} {f : E ‚Üí F} {x : E} {n : ‚Ñï} (hu : is_open u) (hs : unique_diff_on ùïú (s ‚à© u)) (hx : x ‚àà s ‚à© u) : iterated_fderiv_within ùïú n f (s ‚à© u) x = iterated_fderiv_within ùïú n f s x
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [‚àÄ (i : ùí∞.J), category_theory.limits.has_pullback (ùí∞.map i ‚â´ f) g] : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (algebraic_geometry.Scheme.pullback.p1 ùí∞ f g) (algebraic_geometry.Scheme.pullback.p2 ùí∞ f g) _)
(E : Type u_6) : Type u_6
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [topological_space Œ¥] (h‚ÇÅ : Œ± ‚âÉ‚Çú Œ≤) (h‚ÇÇ : Œ≥ ‚âÉ‚Çú Œ¥) : Œ± √ó Œ≥ ‚âÉ‚Çú Œ≤ √ó Œ¥
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (s : list (sigma Œ≤)) : finmap Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} [conditionally_complete_lattice Œ±] (f : filter Œ≤) (u : Œ≤ ‚Üí Œ±) : Œ±
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {ùïú‚ÇÉ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [nondiscrete_normed_field ùïú‚ÇÉ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] [normed_space ùïú‚ÇÉ G] {œÉ‚ÇÇ‚ÇÉ : ùïú‚ÇÇ ‚Üí+* ùïú‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : ùïú ‚Üí+* ùïú‚ÇÉ} {E' : Type u_10} {F' : Type u_11} [semi_normed_group E'] [semi_normed_group F'] {ùïú‚ÇÅ' : Type u_12} {ùïú‚ÇÇ' : Type u_13} [nondiscrete_normed_field ùïú‚ÇÅ'] [nondiscrete_normed_field ùïú‚ÇÇ'] [normed_space ùïú‚ÇÅ' E'] [normed_space ùïú‚ÇÇ' F'] {œÉ‚ÇÅ' : ùïú‚ÇÅ' ‚Üí+* ùïú} {œÉ‚ÇÅ‚ÇÉ' : ùïú‚ÇÅ' ‚Üí+* ùïú‚ÇÉ} {œÉ‚ÇÇ' : ùïú‚ÇÇ' ‚Üí+* ùïú‚ÇÇ} {œÉ‚ÇÇ‚ÇÉ' : ùïú‚ÇÇ' ‚Üí+* ùïú‚ÇÉ} [ring_hom_comp_triple œÉ‚ÇÅ' œÉ‚ÇÅ‚ÇÉ œÉ‚ÇÅ‚ÇÉ'] [ring_hom_comp_triple œÉ‚ÇÇ' œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÇ‚ÇÉ'] [ring_hom_isometric œÉ‚ÇÇ‚ÇÉ] [ring_hom_isometric œÉ‚ÇÅ‚ÇÉ'] [ring_hom_isometric œÉ‚ÇÇ‚ÇÉ'] (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) (gE : E' ‚ÜíSL[œÉ‚ÇÅ'] E) (gF : F' ‚ÜíSL[œÉ‚ÇÇ'] F) : E' ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ'] F' ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ'] G
{X : Type u_1} {Y : Type u_2} (T : Type u_3) [topological_space X] [compact_space X] [topological_space Y] [compact_space Y] [normed_group T] (f : X ‚âÉ‚Çú Y) : C(Y, T) ‚âÉ‚Çú C(X, T)
 : tactic.interactive.instance_tree ‚Üí tactic format
{Œ± : Type u_2} [has_one Œ±] : one_hom Œ± (finset Œ±)
{Œ± : Type u} [topological_space Œ±] (s : set Œ±) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D·µí·µñ) (G : D ‚•§ C) (h : G.op ‚ä£ F) : F.unop ‚ä£ G
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) (q : trunc Œ±) : trunc Œ≤
{Œ± : Type u_1} (x : Œ±) : sym2 Œ±
{Œ± : Type u_1} [ordered_semiring Œ±] [floor_semiring Œ±] : Œ± ‚Üí ‚Ñï
 : conv unit
(k : Type u‚ÇÅ) {G : Type u‚ÇÇ} [semiring k] [has_mul G] {A : Type u‚ÇÉ} [non_unital_non_assoc_semiring A] [module k A] [is_scalar_tower k A A] [smul_comm_class k A A] : (G ‚Üí‚Çô* A) ‚âÉ (monoid_algebra k G ‚Üí‚Çô‚Çê[k] A)
{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {K : nnreal} {s : set Œ±} {f : Œ± ‚Üí Œ≤} : (‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí has_dist.dist (f x) (f y) ‚â§ ‚ÜëK * has_dist.dist x y) ‚Üí lipschitz_on_with K f s
 : ¬¨is_field ‚Ñ§
{Œ± : Type} (p : parser Œ±) : Prop
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [‚àÄ (i : ùí∞.J), category_theory.limits.has_pullback (ùí∞.map i ‚â´ f) g] (s : category_theory.limits.pullback_cone f g) (i j : ùí∞.J) : category_theory.limits.pullback ((ùí∞.pullback_cover s.fst).map i) ((ùí∞.pullback_cover s.fst).map j) ‚ü∂ (algebraic_geometry.Scheme.pullback.gluing ùí∞ f g).to_glue_data.V (i, j)
(f g : turing.to_partrec.code) : turing.to_partrec.code
{S : Type u_1} [ordered_semiring S] {R : Type u_2} [semiring R] (f : R ‚Üí S) : Prop
(val : expr) : tactic (option expr)
{g : Type} [random_gen g] (n : ‚Ñï) : rand_g g (bitvec n)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.limits.preserves_limit (category_theory.limits.cospan f g) G] [category_theory.limits.has_pullback f g] [category_theory.limits.has_pullback (G.map f) (G.map g)] : G.obj (category_theory.limits.pullback f g) ‚âÖ category_theory.limits.pullback (G.map f) (G.map g)
 : environment ‚Üí ‚Ñï
{Œπ : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [ordered_comm_monoid N] (f : M ‚Üí N) (p : M ‚Üí Prop) (h_one : f 1 = 1) (h_mul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí f (x * y) ‚â§ f x * f y) (hp_mul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x * y)) (g : Œπ ‚Üí M) {s : finset Œπ} (hs : ‚àÄ (i : Œπ), i ‚àà s ‚Üí p (g i)) : f (s.prod (Œª (i : Œπ), g i)) ‚â§ s.prod (Œª (i : Œπ), f (g i))
(Œ± : Type u) (n : ‚Ñï) : Type u
{n m : ‚Ñï} {P : mvpfunctor n} {Q : fin2 n ‚Üí mvpfunctor m} {Œ± : typevec m} (x : (P.comp Q).obj Œ±) : P.obj (Œª (i : fin2 n), (Q i).obj Œ±)
{Œ± : Type u} [uniform_space Œ±] (s : set Œ±) : Prop
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : (category_theory.limits.pullback f g).open_cover
 : list expr ‚Üí expr ‚Üí tactic expr
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {f g : X ‚ü∂ Y} {c : category_theory.limits.cofork f g} (i : category_theory.limits.is_colimit c) : category_theory.limits.is_colimit (category_theory.preadditive.cokernel_cofork_of_cofork c)
{E : Type u} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {a : E} (h : is_local_max f a) : fderiv ‚Ñù f a = 0
{Œ± : Type u_1} [preorder Œ±] [bounded_order Œ±] [is_simple_order Œ±] {a b : Œ±} (h : a < b) : a = ‚ä•
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) {Z : C} (l : Y ‚ü∂ Z) {s : category_theory.limits.cokernel_cofork f} (hs : category_theory.limits.is_colimit s) (i : s.X ‚âÖ Z) (h : category_theory.limits.cofork.œÄ s ‚â´ i.hom = l) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ l _)
{Œ± : Type u} {L‚ÇÅ L‚ÇÇ : list (Œ± √ó bool)} {x1 : Œ±} {b1 : bool} {x2 : Œ±} {b2 : bool} (H1 : (x1, b1) ‚â† (x2, b2)) (H2 : free_group.red ((x1, b1) :: L‚ÇÅ) ((x2, b2) :: L‚ÇÇ)) : free_group.red L‚ÇÅ ((x1, !b1) :: (x2, b2) :: L‚ÇÇ)
 : Type
{Œ± : Type u_1} {Œπ : Sort u_4} {l : filter Œ±} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí set Œ±} (h : l.has_basis p s) {q : Œπ ‚Üí Prop} (hq : ‚àÄ (i : Œπ), p i ‚Üí (‚àÉ (j : Œπ), p j ‚àß q j ‚àß s j ‚äÜ s i)) : l.has_basis (Œª (i : Œπ), p i ‚àß q i) s
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) (s : finmap Œ≤) : option (Œ≤ a)
{n m : ‚Ñï} (i : fin (m * n)) : fin n
{Œ± : Type u_2} [has_zero Œ±] [has_add Œ±] [has_neg Œ±] : has_scalar ‚Ñ§ (set Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] (J : category_theory.grothendieck_topology C) (P : C·µí·µñ ‚•§ A) [category_theory.limits.has_pullbacks C] (s : A ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) [category_theory.limits.has_limits A] [category_theory.limits.preserves_limits s] [category_theory.reflects_isomorphisms s] : category_theory.presheaf.is_sheaf J P ‚Üî category_theory.presheaf.is_sheaf J (P ‚ãô s)
{ùïú : Type u_1} {E : Type u_2} [ordered_ring ùïú] [add_comm_group E] [module ùïú E] (K : geometry.simplicial_complex ùïú E) : set E
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [succ_order Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : antitone f) : pairwise (disjoint on Œª (n : Œ±), set.Ico (f (order.succ n)) (f n))
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : algebraic_geometry.PresheafedSpace C} (Œ± : X ‚âÖ Y) (x : ‚Ü•X) : Y.stalk (‚áë(Œ±.hom.base) x) ‚âÖ X.stalk x
{Œ± : Type u_1} {Œ≤ : Type u_2} (p : two_pointing Œ±) (q : two_pointing Œ≤) : two_pointing (Œ± √ó Œ≤)
{K : Type u_1} [field K] : ideal.is_jacobson K
{Œ± : Type u_1} [ordered_semiring Œ±] : {x // 0 ‚â§ x} ‚Üí+* Œ±
{K : Type v} {L : Type w} [field K] [field L] (i : K ‚Üí+* L) {f : polynomial K} (hf : polynomial.splits i f) (hfd : f.degree ‚â† 0) : L
{Œ± : Type u} (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù) (dist_self : ‚àÄ (x : Œ±), dist x x = 0) (dist_comm : ‚àÄ (x y : Œ±), dist x y = dist y x) (dist_triangle : ‚àÄ (x y z : Œ±), dist x z ‚â§ dist x y + dist y z) : uniform_space Œ±
(args : list pexpr) (attrs : list name) (n : ‚Ñï) (opt : tactic.apply_cfg) : tactic unit
{C : Type u} [category_theory.category C] [category_theory.limits.has_strict_initial_objects C] [category_theory.limits.has_initial C] (X : C) [category_theory.limits.has_binary_product (‚ä•_ C) X] : ‚ä•_ C ‚®Ø X ‚âÖ ‚ä•_ C
{C : Type u‚ÇÅ} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A
{n : Type u_1} (p : Type u_2) {R : Type u‚ÇÇ} [decidable_eq n] [decidable_eq p] [comm_ring R] (t : matrix.transvection_struct n R) : matrix.transvection_struct (n ‚äï p) R
(_x : interactive.parse (lean.parser.tk "mk_iff_of_inductive_prop")) : lean.parser unit
{m n : ‚Ñï} {Œ± : Type u_1} {o : ‚Ñï} (ho : o = m + n) (u : fin m ‚Üí Œ±) (v : fin n ‚Üí Œ±) : fin o ‚Üí Œ±
 : fact (1 ‚â§ 1)
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] : category_theory.limits.has_finite_colimits C
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : module.rank K V ‚â§ 1 ‚Üî ‚àÉ (v‚ÇÄ : V), ‚àÄ (v : V), ‚àÉ (r : K), r ‚Ä¢ v‚ÇÄ = v
{key : Type} (base : native.rb_set key) : list key ‚Üí native.rb_map key unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [preorder Œ±] [preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : galois_connection l u) (h : ‚àÄ (a : Œ±), u (l a) ‚â§ a) : galois_coinsertion l u
{Œ± : Type u_2} [preorder Œ±] : Œ± ‚Üío Œ± √ó Œ±
(h : expr) : tactic expr_set
{R : Type u} {L‚ÇÅ : Type v} [comm_ring R] [lie_ring L‚ÇÅ] [lie_algebra R L‚ÇÅ] (L‚ÇÅ' L‚ÇÅ'' : lie_subalgebra R L‚ÇÅ) (h : ‚ÜëL‚ÇÅ' = ‚ÜëL‚ÇÅ'') : ‚Ü•L‚ÇÅ' ‚âÉ‚Çó‚ÅÖR‚ÅÜ ‚Ü•L‚ÇÅ''
{Œ± : Type u_1} {enum : Œ± ‚Üí ‚Ñï} (n : ‚Ñï) (a : Œ±) (h : enum a = n) (s : derive_fintype.finset_above Œ± enum (n + 1)) : derive_fintype.finset_above Œ± enum n
{R : Type u} [ring R] {G H : Module R} (f : G ‚ü∂ H) : category_theory.limits.cokernel f ‚âÖ Module.of R (‚Ü•H ‚ß∏ linear_map.range f)
{Œ± : Type u_1} : multiset (multiset Œ±) ‚Üí multiset Œ±
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) [measurable_space Œ±] [measurable_space Œ≤] [measurable_space Œ≥] : (Œ± ‚äï Œ≤) √ó Œ≥ ‚âÉ·µê Œ± √ó Œ≥ ‚äï Œ≤ √ó Œ≥
{Œ± : Type u} [topological_space Œ±] [locally_compact_space Œ±] (x : Œ±) : ‚àÉ (K : set Œ±), is_compact K ‚àß K ‚àà nhds x
 : omega.nat.exprterm ‚Üí list expr
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {G : D ‚•§ C} [category_theory.is_right_adjoint G] (A : (category_theory.adjunction.of_right_adjoint G).to_monad.algebra) : G.is_split_pair ((category_theory.left_adjoint G).map A.a) ((category_theory.adjunction.of_right_adjoint G).counit.app ((category_theory.left_adjoint G).obj A.A))
 : Type u ‚Üí cardinal
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {ùïú : Type u_3} {G : Type u_4} [is_R_or_C ùïú] [normed_space ùïú E] [normed_group G] [normed_space ùïú G] {f : E ‚Üí G} {s : set E} {C : nnreal} (hf : ‚àÄ (x : E), x ‚àà s ‚Üí differentiable_at ùïú f x) (bound : ‚àÄ (x : E), x ‚àà s ‚Üí ‚à•fderiv ùïú f x‚à•‚Çä ‚â§ C) (hs : convex ‚Ñù s) : lipschitz_on_with C f s
{Œ± : Type u_2} {Œ≤ : Type u_3} [add_comm_monoid Œ±] [add_comm_monoid Œ≤] {A : set Œ±} {n : ‚Ñï} : has_add (A ‚Üí+[n] Œ≤)
{Œ± : Type u_2} {Œ≤ : Type u_3} [non_assoc_semiring Œ±] [preorder Œ±] [non_assoc_semiring Œ≤] [preorder Œ≤] : has_coe_to_fun (Œ± ‚Üí+*o Œ≤) (Œª (_x : Œ± ‚Üí+*o Œ≤), Œ± ‚Üí Œ≤)
(l r : Type u) : bool ‚Üí Type u
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) : Type (max u v)
(ns : list (name ‚äï list name)) (reserved : name_set) : tactic (list expr)
{M : Type u_1} [mul_one_class M] {N : Type u_2} [mul_one_class N] (f : M ‚Üí* N) : M ‚Üí* ‚Ü•(f.mrange)
{Œ± : Type u_2} {Œ≤ : Type u_3} [decidable_eq Œ≤] [monoid Œ±] [mul_action Œ± Œ≤] : mul_action Œ± (finset Œ≤)
{V : Type u} {G : simple_graph V} {u v : V} (p : G.walk u v) : Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {x : E} {n : with_top ‚Ñï} {f g : E ‚Üí F} (hf : cont_diff_at ùïú n f x) (hg : cont_diff_at ùïú n g x) : cont_diff_at ùïú n (Œª (x : E), f x + g x) x
{f : ‚Ñù ‚Üí ‚Ñù} {a b l : ‚Ñù} (hab : a < b) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds l)) (hfb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds l)) : ‚àÉ (c : ‚Ñù) (H : c ‚àà set.Ioo a b), deriv f c = 0
{S : Type u‚ÇÅ} {L : Type u‚ÇÇ} {D : Type u‚ÇÉ} [category_theory.category S] [category_theory.category L] [category_theory.category D] (Œπ : S ‚•§ L) [‚àÄ (X : L), category_theory.limits.has_limits_of_shape (category_theory.structured_arrow X Œπ) D] : (S ‚•§ D) ‚•§ L ‚•§ D
(k : Type u_1) [division_ring k] {Œπ : Type u_4} (s : finset Œπ) [char_zero k] [fintype Œπ] (h : s.card ‚â† 0) : finset.univ.sum (Œª (i : Œπ), finset.centroid_weights_indicator k s i) = 1
{X : Type u} [lattice X] [jordan_holder_lattice X] {s‚ÇÅ s‚ÇÇ : composition_series X} (h : ‚àÄ (x : X), x ‚àà s‚ÇÅ ‚Üî x ‚àà s‚ÇÇ) : s‚ÇÅ = s‚ÇÇ
{Œ± : Type u_1} [decidable_eq Œ±] (s : finset Œ±) (a : Œ±) : finset Œ±
{p : bool ‚Üí Prop} [Œ† (b : bool), decidable (p b)] : decidable (‚àÉ (b : bool), p b)
(M : Type u_1) [has_mul M] : M ‚âÉ* M
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u} [category_theory.category J] (F : J ‚•§ C) [category_theory.limits.has_initial J] [category_theory.limits.has_colimit F] [‚àÄ (i j : J) (f : i ‚ü∂ j), category_theory.is_iso (F.map f)] : category_theory.limits.colimit F ‚âÖ F.obj (‚ä•_ J)
{Œ± : Type u_1} {Œ¥ : Œ± ‚Üí Sort u_2} (s : finset Œ±) (f g : Œ† (i : Œ±), Œ¥ i) [Œ† (j : Œ±), decidable (j ‚àà s)] (i : Œ±) : Œ¥ i
{Œ± : Sort u} [decidable_eq Œ±] (a b : Œ±) : equiv.perm Œ±
{Œπ : Type u_1} (M : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), monoid (M i)] (i : Œπ) : Type (max u_1 u_2)
{Œ± : Type u_1} {M : Type u_5} [has_zero M] [fintype Œ±] : (Œ± ‚Üí‚ÇÄ M) ‚âÉ (Œ± ‚Üí M)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) {s : set Œπ} {i : Œπ} (hi : i ‚àâ s) {l : Œπ ‚Üí‚ÇÄ ùïú} (hl : l ‚àà finsupp.supported ùïú ùïú s) : has_inner.inner (‚áë(finsupp.total Œπ E ùïú v) l) (v i) = 0
{Œ± : Type u} (s : wseq Œ±) (n : ‚Ñï) (a : Œ±) : wseq Œ±
{n : ‚Ñï} {F : typevec n ‚Üí Type u_1} [mvfunctor F] (q : mvqpf F) : Prop
(R : Type u) (X : Type v) [semiring R] : Type (max u v)
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul G] (g : G) : G ‚âÉ·µê G
 : expr ‚Üí tactic (exceptional (option string))
(p : ‚Ñï) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] (V : Type u_2) [add_comm_group V] [witt_vector.isocrystal p k V] (V‚ÇÇ : Type u_3) [add_comm_group V‚ÇÇ] [witt_vector.isocrystal p k V‚ÇÇ] : Type (max u_2 u_3)
{M : Type u_3} [monoid M] (l : list M) : (l.nth 0).get_or_else 1 * l.tail.prod = l.prod
{Œπ : Type v} [dec_Œπ : decidable_eq Œπ] (Œ≤ : Œπ ‚Üí Type w) [Œ† (i : Œπ), add_comm_monoid (Œ≤ i)] (S T : set Œπ) (H : S ‚äÜ T) : direct_sum ‚Ü•S (Œª (i : ‚Ü•S), Œ≤ ‚Üëi) ‚Üí+ direct_sum ‚Ü•T (Œª (i : ‚Ü•T), Œ≤ ‚Üëi)
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] (F : C ‚•§ D) [F.preserves_zero_morphisms] {X Y : C} (b : category_theory.limits.binary_bicone X Y) : category_theory.limits.binary_bicone (F.obj X) (F.obj Y)
{Œ± : Type v} : quotient.out (cardinal.mk Œ±) ‚âÉ Œ±
(Œ± : Type u) {g : Type} [random_gen g] [random Œ±] : rand_g g (stream Œ±)
{Œ± : Type u} {Œ≤ : Type v} [emetric_space Œ±] [pseudo_emetric_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : isometry f) : uniform_embedding f
{Œ± : Type u_1} (R : Œ± ‚Üí Œ± ‚Üí Prop) [decidable_rel R] : list Œ± ‚Üí list Œ±
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} {s t : category_theory.limits.pullback_cone f g} (i : s.X ‚âÖ t.X) (w‚ÇÅ : s.fst = i.hom ‚â´ t.fst) (w‚ÇÇ : s.snd = i.hom ‚â´ t.snd) : s ‚âÖ t
{K : Type u} [hfield : field K] {L : Type u_1} [field L] (f : K ‚Üí+* L) (a : L) {x y : ratfunc K} (hx : polynomial.eval‚ÇÇ f a x.denom ‚â† 0) (hy : polynomial.eval‚ÇÇ f a y.denom ‚â† 0) : ratfunc.eval f a (x * y) = ratfunc.eval f a x * ratfunc.eval f a y
{R : Type u_1} {A : Type u_2} [comm_ring R] [ring A] [algebra R A] {c‚ÇÅ c‚ÇÇ : R} : quaternion_algebra.basis A c‚ÇÅ c‚ÇÇ ‚âÉ (quaternion_algebra R c‚ÇÅ c‚ÇÇ ‚Üí‚Çê[R] A)
{C : Type u‚ÇÅ} [category_theory.category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (R : category_theory.presieve X) : Type (max v‚ÇÅ u‚ÇÅ)
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b : Œ±} (ha : 1 < a) (hb : 1 ‚â§ b) : 1 < a * b
{C : Type u_1} [category_theory.category C] (P : category_theory.idempotents.karoubi C) : ùüô P = P.decomp_id_i ‚â´ P.decomp_id_p
(c : tactic.abel.context) (n x a : expr) : expr
{Œì : Type u_1} [inhabited Œì] (l‚ÇÅ l‚ÇÇ : list Œì) : Prop
{G : Type u_3} [group G] (P : subgroup G) : Prop
{n : ‚Ñï} {Œ± : Type u_1} {v : vector Œ± (n + 1)} : v.last = v.nth (fin.last n)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [topological_space Œ¥] {e‚ÇÅ : Œ± ‚Üí Œ≤} {e‚ÇÇ : Œ≥ ‚Üí Œ¥} (de‚ÇÅ : dense_inducing e‚ÇÅ) (de‚ÇÇ : dense_inducing e‚ÇÇ) : dense_inducing (Œª (p : Œ± √ó Œ≥), (e‚ÇÅ p.fst, e‚ÇÇ p.snd))
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : GL n R ‚Üí* RÀ£
(Œ± : Type u_1) [semilattice_inf Œ±] [order_top Œ±] : SemilatticeInf
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] : is_bounded_bilinear_map ùïú (Œª (p : (E ‚ÜíL[ùïú] ùïú) √ó F), p.fst.smul_right p.snd)
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ x‚ÇÇ : X} (P‚ÇÄ : path.homotopic.quotient x‚ÇÄ x‚ÇÅ) (P‚ÇÅ : path.homotopic.quotient x‚ÇÅ x‚ÇÇ) : path.homotopic.quotient x‚ÇÄ x‚ÇÇ
{ùïú : Type u_2} {E : Type u_5} [comm_semiring ùïú] [topological_space ùïú] [has_continuous_add ùïú] [has_continuous_const_smul ùïú ùïú] [add_comm_monoid E] [module ùïú E] [topological_space E] (M : Type u_1) [monoid M] [distrib_mul_action M ùïú] [smul_comm_class ùïú M ùïú] [has_continuous_const_smul M ùïú] : mul_action M (weak_dual ùïú E)
{X : Type v} [topological_space X] [locally_compact_space X] [sigma_compact_space X] [t2_space X] {Œπ : X ‚Üí Type u} {p : Œ† (x : X), Œπ x ‚Üí Prop} {B : Œ† (x : X), Œπ x ‚Üí set X} {s : set X} (hs : is_closed s) (hB : ‚àÄ (x : X), x ‚àà s ‚Üí (nhds x).has_basis (p x) (B x)) : ‚àÉ (Œ± : Type v) (c : Œ± ‚Üí X) (r : Œ† (a : Œ±), Œπ (c a)), (‚àÄ (a : Œ±), c a ‚àà s ‚àß p (c a) (r a)) ‚àß (s ‚äÜ ‚ãÉ (a : Œ±), B (c a) (r a)) ‚àß locally_finite (Œª (a : Œ±), B (c a) (r a))
{Œ± : Type u_1} {Œ≤ : Type u_2} [infinite Œ≤] (f : Œ± ‚Üí finset Œ≤) (w : (‚ãÉ (a : Œ±), ‚Üë(f a)) = ‚ä§) : cardinal.mk Œ≤ ‚â§ cardinal.mk ‚Ü•(set.range f)
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_Sup Œ±] [has_Sup Œ≤] : has_coe_to_fun (Sup_hom Œ± Œ≤) (Œª (_x : Sup_hom Œ± Œ≤), Œ± ‚Üí Œ≤)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ùïú] [inner_product_space ùïú E] [inner_product_space ùïú F] [finite_dimensional ùïú E] [finite_dimensional ùïú F] (A : E ‚Üí‚Çó[ùïú] F) : ‚áëlinear_map.adjoint (‚áëlinear_map.adjoint A) = A
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {s : set E} : mdifferentiable_on (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f s ‚Üî differentiable_on ùïú f s
(n a b : ‚Ñï) : n < a ‚à® b ‚â§ n ‚à® n ‚àà list.Ico a b
{C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} (H : X.carrier ‚âÖ Y.carrier) (Œ± : H.hom _* X.presheaf ‚âÖ Y.presheaf) : X ‚âÖ Y
(R : Type u_1) {S : Type u_2} [comm_ring R] [comm_ring S] [algebra R S] : S ‚Üí* R
{Œ± : Type u_1} {m m' : pseudo_metric_space Œ±} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'
(Œ± : Type u) [topological_space Œ±] : Prop
 : NonemptyFinLinOrd ‚•§ NonemptyFinLinOrd
{M : Type u_1} [add_monoid M] (a : M) : Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {f : E ‚Üí F √ó G} {x : E} (hf : cont_diff_at ùïú n f x) : cont_diff_at ùïú n (Œª (x : E), (f x).snd) x
(Œ± : Type u) {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] (b : Œ≤) : bounded_continuous_function Œ± Œ≤
{f : ‚Ñï ‚Üí ‚Ñù} (h_nonneg : ‚àÄ (n : ‚Ñï), 0 ‚â§ f n) (h_mono : ‚àÄ ‚¶Ém n : ‚Ñï‚¶Ñ, 0 < m ‚Üí m ‚â§ n ‚Üí f n ‚â§ f m) : summable (Œª (k : ‚Ñï), 2 ^ k * f (2 ^ k)) ‚Üî summable f
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (c : category_theory.limits.cocone F) : category_theory.limits.cone F.op
 : category_theory.Groupoid ‚•§ Type u
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 p4 p5 : P} (hapc : euclidean_geometry.angle p1 p5 p3 = real.pi) (hbpd : euclidean_geometry.angle p2 p5 p4 = real.pi) : euclidean_geometry.angle p1 p5 p2 = euclidean_geometry.angle p3 p5 p4
{K : Type u_1} [decidable_eq K] {Œì : K ‚Üí Type u_2} (L : turing.list_blank (Œ† (k : K), option (Œì k))) : turing.list_blank turing.TM2to1.Œì'
{E : Type u_2} [add_comm_group E] [module ‚Ñù E] (s : convex_cone ‚Ñù E) (f : linear_pmap ‚Ñù E ‚Ñù) (nonneg : ‚àÄ (x : ‚Ü•(f.domain)), ‚Üëx ‚àà s ‚Üí 0 ‚â§ ‚áëf x) (dense : ‚àÄ (y : E), ‚àÉ (x : ‚Ü•(f.domain)), ‚Üëx + y ‚àà s) (hdom : f.domain ‚â† ‚ä§) : ‚àÉ (g : linear_pmap ‚Ñù E ‚Ñù), f < g ‚àß ‚àÄ (x : ‚Ü•(g.domain)), ‚Üëx ‚àà s ‚Üí 0 ‚â§ ‚áëg x
{Œ± : Type u_1} (s : set (set Œ±)) : set Œ± ‚Üí Prop
{M : Type u_1} [hM : comm_monoid M] (h : ‚àÄ (a : M), is_unit a) : comm_group M
{R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ‚âÉ+* S) : ‚Üëf.to_monoid_hom = ‚Üëf.to_monoid_hom
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C} : category_theory.limits.has_finite_products (category_theory.over B)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y Z : C} [category_theory.limits.has_pullbacks C] (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : category_theory.mono_over.pullback (f ‚â´ g) ‚âÖ category_theory.mono_over.pullback g ‚ãô category_theory.mono_over.pullback f
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} {C‚ÇÅ C‚ÇÇ : homological_complex V c} [category_theory.limits.has_zero_object V] (f : C‚ÇÅ.hom C‚ÇÇ) (j : Œπ) : C‚ÇÅ.X_prev j ‚ü∂ C‚ÇÇ.X_prev j
 : snum ‚Üí bool
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (f' : M‚ÇÅ ‚Üí M‚ÇÇ) (h : f' = ‚áëf) : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ
{ùíú : Type u_1} [category_theory.category ùíú] {A B C : ùíú} {f : A ‚ü∂ B} {g : B ‚ü∂ C} [category_theory.limits.has_zero_morphisms ùíú] [category_theory.limits.has_binary_biproducts ùíú] (h : category_theory.splitting f g) : B ‚ü∂ A
{Œ± Œ≤ : Type u} (f : Œ± ‚ü∂ Œ≤) : category_theory.limits.is_image (category_theory.limits.types.mono_factorisation f)
{A : Type u_4} [add_zero_class A] : add_submonoid A ‚âÉo submonoid (multiplicative A)
{X : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space X] (f : locally_constant X (Œ± ‚Üí Œ≤)) (a : Œ±) : locally_constant X Œ≤
(h : expr) : tactic expr_set
{R : Type u} [ring R] : complete_lattice (subring R)
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) (K : add_subgroup N) : ‚Ü•(H.prod K) ‚âÉ+ ‚Ü•H √ó ‚Ü•K
(n : ‚Ñï) (a : fin n) (b : ‚Ñï) : Prop
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] : has_coe (locally_constant X Y) C(X, Y)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ SemiRing) [category_theory.is_filtered J] : category_theory.limits.is_colimit (SemiRing.filtered_colimits.colimit_cocone F)
{A B : Type u} [add_comm_group A] [add_comm_group B] (e : A ‚âÉ+ B) (n : ‚Ñ§) : A ‚ß∏ (zsmul_add_group_hom n).range ‚âÉ+ B ‚ß∏ (zsmul_add_group_hom n).range
{J : Type v} [category_theory.small_category J] (F : J ‚•§ category_theory.Cat) : category_theory.limits.is_limit (category_theory.Cat.has_limits.limit_cone F)
{X : Type u_1} [topological_space X] (x y : X) : Prop
{Œ± : Type u} {g : Type} [random_gen g] [preorder Œ±] [bounded_random Œ±] (x y : Œ±) (h : x ‚â§ y) : rand_g g ‚Ü•(set.Icc x y)
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± : D·µí·µñ ‚•§ A} {‚Ñ±' : category_theory.Sheaf K A} (Œ± : G.op ‚ãô ‚Ñ± ‚ü∂ G.op ‚ãô ‚Ñ±'.val) : ‚Ñ± ‚ü∂ ‚Ñ±'.val
{Œπ : Type u_1} {Œ± : Type u_2} {s : Œπ ‚Üí set Œ±} (hs : indexed_partition s) : hs.quotient ‚Ü™ Œ±
{V : Type (u+1)} [category_theory.large_category V] {G : Mon} : Action V G ‚•§ category_theory.single_obj ‚Ü•G ‚•§ V
(x y : pgame) : Prop
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} : L.bounded_formula Œ± n ‚Üí L.bounded_formula Œ± n ‚Üí L.bounded_formula Œ± n
{Œ± : Type u} [add_monoid Œ±] : add_group (add_units Œ±)
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ‚Ñ§] [category_theory.preadditive C] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] (D : Type u‚ÇÇ) [category_theory.category D] [category_theory.limits.has_zero_object D] [category_theory.has_shift D ‚Ñ§] [category_theory.preadditive D] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor D n).additive] : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {ùïú‚ÇÉ : Type u_3} (E : Type u_4) (F : Type u_6) (G : Type u_8) [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [nondiscrete_normed_field ùïú‚ÇÉ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] [normed_space ùïú‚ÇÉ G] (œÉ‚ÇÇ‚ÇÉ : ùïú‚ÇÇ ‚Üí+* ùïú‚ÇÉ) (œÉ‚ÇÅ‚ÇÉ : ùïú ‚Üí+* ùïú‚ÇÉ) [ring_hom_isometric œÉ‚ÇÇ‚ÇÉ] [ring_hom_isometric œÉ‚ÇÅ‚ÇÉ] : (E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) ‚âÉ‚Çó·µ¢[ùïú‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] G
{K : Type u_4} {V : Type u} [division_ring K] [add_comm_group V] [module K V] {s t : set V} (hs : linear_independent K (Œª (x : ‚Ü•s), ‚Üëx)) (hst : s ‚äÜ t) : set V
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (s : set E) : Prop
(conf : tactic.rewrite_search.config) (rules : list (expr √ó bool)) (eq : expr) : tactic tactic.rewrite_search.graph
{M : Type u_1} (S : set M) [monoid M] : submonoid M
{X : Type u_1} : (X ‚Üí‚ÇÄ ‚Ñ§) ‚Üí+ free_abelian_group X
{Œ± : Type u_1} [pseudo_metric_space Œ±] (C : ‚Ñù) {f : ‚Ñï ‚Üí Œ±} (hu‚ÇÇ : ‚àÄ (n : ‚Ñï), has_dist.dist (f n) (f (n + 1)) ‚â§ C / 2 / 2 ^ n) {a : Œ±} (ha : filter.tendsto f filter.at_top (nhds a)) : has_dist.dist (f 0) a ‚â§ C
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {x : E} {s t : set E} (ht : t ‚àà nhds x) : tangent_cone_at ùïú (s ‚à© t) x = tangent_cone_at ùïú s x
 : tactic unit
{M : Type u_1} [has_add M] (S : add_subsemigroup M) (s : set M) (hs : s = ‚ÜëS) : add_subsemigroup M
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} {y : Œ±} {r : ‚Ñù} (h : y ‚àà t) (H : metric.Hausdorff_dist s t < r) (fin : emetric.Hausdorff_edist s t ‚â† ‚ä§) : ‚àÉ (x : Œ±) (H : x ‚àà s), has_dist.dist x y < r
(t‚ÇÅ t‚ÇÇ : expr ‚Üí tactic (expr √ó expr)) (e : expr) : tactic (expr √ó expr)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (c : category_theory.limits.cone F) : category_theory.limits.is_limit c ‚âÉ category_theory.limits.is_terminal c
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] {X Y : C} [category_theory.simple Y] {f : X ‚ü∂ Y} [category_theory.limits.has_image f] (w : f ‚â† 0) : category_theory.epi f
(md : tactic.transparency) (to_generalize : list (name √ó expr √ó expr)) : tactic (list (expr √ó expr))
{R A B : CommRing} (f : R ‚ü∂ A) (g : R ‚ü∂ B) : category_theory.limits.is_colimit (CommRing.pushout_cocone f g)
{Œ± : Type u} : Group.of (category_theory.Aut Œ±) ‚âÖ Group.of (equiv.perm Œ±)
(Œ± : Type u_2) [comm_monoid_with_zero Œ±] : Prop
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {Œπ : Type u_6} (Z : topological_vector_bundle_core R B F Œπ) : Type u_3
{n : ‚Ñï} [fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.a i) = 2 * n / (2 * n).gcd i.val
{n : ‚Ñï} {fs : finset (fin (n + 1))} (h : fs.nonempty) : finset.univ.sum (Œª (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.centroid_weights_with_circumcenter fs i) = 1
(R : Type u_1) {Œ± : Type u_2} {Œ≤ : Type u_4} {l : Type u_8} {m : Type u_9} {n : Type u_10} {p : Type u_11} [comm_semiring R] [add_comm_monoid Œ±] [add_comm_monoid Œ≤] [module R Œ±] [module R Œ≤] : matrix l m Œ± ‚Üí matrix n p Œ≤ ‚Üí matrix (l √ó n) (m √ó p) (tensor_product R Œ± Œ≤)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [category_theory.mono f] [category_theory.mono g] : category_theory.mono_over.map (f ‚â´ g) ‚âÖ category_theory.mono_over.map f ‚ãô category_theory.mono_over.map g
{M : Type u_1} [has_add M] {c d : add_con M} : c ‚â§ d ‚Üî ‚àÄ {x y : M}, ‚áëc x y ‚Üí ‚áëd x y
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] {X‚ÇÅ X‚ÇÇ : C} (r : X‚ÇÇ ‚ü∂ X‚ÇÅ) : X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ X‚ÇÅ ‚äû X‚ÇÇ
{Œ± : Type u_1} [ring Œ±] [uniform_space Œ±] [topological_ring Œ±] [uniform_add_group Œ±] {Œ≤ : Type u} [uniform_space Œ≤] [ring Œ≤] [uniform_add_group Œ≤] [topological_ring Œ≤] (f : Œ± ‚Üí+* Œ≤) (hf : continuous ‚áëf) : uniform_space.completion Œ± ‚Üí+* uniform_space.completion Œ≤
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) {Z : C} (g : Y ‚ü∂ Z) [category_theory.limits.has_image g] [category_theory.limits.has_image (f ‚â´ g)] : category_theory.mono (category_theory.limits.image.pre_comp f g)
{Œ± : Type u} [mul_one_class Œ±] : is_monoid_hom id
{C : Type u} [category_theory.category C] (X : C) : category_theory.limits.preserves_limits (category_theory.yoneda.obj X)
 : Type (u_1+1)
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí ‚Ñï ‚Üí option ‚Ñï
{n : ‚Ñï} (c : composition_as_set n) : list ‚Ñï
{Œ± : Type u_2} {Œ≤ : Type u_3} [complete_lattice Œ±] [complete_lattice Œ≤] (f : frame_hom Œ± Œ≤) : lattice_hom Œ± Œ≤
{K : Type u_1} [is_R_or_C K] : K ‚Üí‚Çó[‚Ñù] ‚Ñù
 : tactic name
{ùïú : Type u} {n : ‚Ñï} {Ei : fin n.succ ‚Üí Type wEi} {G : Type wG} [nondiscrete_normed_field ùïú] [Œ† (i : fin n.succ), normed_group (Ei i)] [Œ† (i : fin n.succ), normed_space ùïú (Ei i)] [normed_group G] [normed_space ùïú G] (f : continuous_multilinear_map ùïú (Œª (i : fin n), Ei (‚áëfin.cast_succ i)) (Ei (fin.last n) ‚ÜíL[ùïú] G)) : continuous_multilinear_map ùïú Ei G
{n : ‚Ñï} {F : typevec n ‚Üí Type v} [mvfunctor F] {Œ± : typevec n} (p : Œ† (i : fin2 n), Œ± i ‚Üí Prop) (x : F Œ±) : Prop
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [non_unital_ring Œ≤] : non_unital_ring Œ±
{R : Type u_1} [linear_ordered_field R] [floor_ring R] (b : ‚Ñï) (r : R) : ‚Ñ§
 : UniformSpace.completion_functor ‚ä£ category_theory.forget‚ÇÇ CpltSepUniformSpace UniformSpace
(M : Type u_5) (N : Type u_6) [mul_one_class M] [mul_one_class N] : N ‚Üí* M √ó N
(ic : tactic.instance_cache) (a b : expr) (na nb : ‚Ñö) : tactic (tactic.instance_cache √ó expr √ó expr)
(ùïú : Type u) [nondiscrete_normed_field ùïú] {E : Type v} [normed_group E] [normed_space ùïú E] [complete_space ùïú] {r : ‚Ñù} (rpos : 0 < r) (h : is_compact (metric.closed_ball 0 r)) : finite_dimensional ùïú E
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s : set Œ±} {a b : Œ±} (hs : bdd_above s) (ha : a ‚àà s) (h : b < a) : b < has_Sup.Sup s
(Œ± : Type u) [monoid Œ±] : Œ± ‚âÉ* category_theory.End (category_theory.single_obj.star Œ±)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) (s : category_theory.limits.cocone F) : CommRing.colimits.colimit_type F ‚Üí ‚Ü•(s.X)
(e : expr) : tactic (‚Ñï √ó expr)
{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {A : C} : category_theory.over.pullback (ùüô A) ‚âÖ ùü≠ (category_theory.over A)
 : ‚Ñï ‚Üí Type
{Œ± : Type u_1} (y : Œ±) : fintype {x // y = x}
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) (X Y : C) [category_theory.limits.has_binary_coproduct X Y] [category_theory.limits.has_binary_coproduct (G.obj X) (G.obj Y)] [category_theory.limits.preserves_colimit (category_theory.limits.pair X Y) G] : G.obj X ‚®ø G.obj Y ‚âÖ G.obj (X ‚®ø Y)
{Œ± : Type u} [hg : group Œ±] [is_cyclic Œ±] : comm_group Œ±
{Œ± : Type u} : Œ±·µÉ·µí·µñ ‚Üí Œ±
(e : expr) (js ks eqs eq_proofs : list expr) : tactic unit
 : expr ‚Üí option (expr √ó expr √ó name)
{A : Type u_1} {B : Type u_2} {C : Type u_3} [ring A] [ring B] [ring C] (f : A ‚Üí+* B) (hf : function.surjective ‚áëf) : {g // f.ker ‚â§ g.ker} ‚âÉ (B ‚Üí+* C)
(Œ± : Type u_1) : set (Œ± √ó Œ±)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J·µí·µñ ‚•§ C} (c : category_theory.limits.cone F) : category_theory.limits.cocone F.right_op
{Œπa : Type u_7} {Œπb : Type u_8} [decidable_eq Œπa] [decidable_eq Œπb] [fintype Œπa] [fintype Œπb] {R' : Type u_9} {M·µ¢ : Type u_10} {N‚ÇÅ : Type u_11} {N‚ÇÇ : Type u_12} [comm_semiring R'] [add_comm_group N‚ÇÅ] [module R' N‚ÇÅ] [add_comm_group N‚ÇÇ] [module R' N‚ÇÇ] [add_comm_monoid M·µ¢] [module R' M·µ¢] (a : multilinear_map R' (Œª (_x : Œπa), M·µ¢) N‚ÇÅ) (b : multilinear_map R' (Œª (_x : Œπb), M·µ¢) N‚ÇÇ) : ‚áëmultilinear_map.alternatization (a.dom_coprod b) = (‚áëmultilinear_map.alternatization a).dom_coprod (‚áëmultilinear_map.alternatization b)
{Œ± : Type u_1} {Œ≤ : Œ± ‚Üí Sort u_2} [has_coe_to_fun Œ± Œ≤] : has_coe_to_fun (multiplicative Œ±) (Œª (a : multiplicative Œ±), Œ≤ (‚áëmultiplicative.to_add a))
(x : pgame) : (x + 0).equiv x
(R : Type u) [semiring R] : strong_rank_condition R ‚Üî ‚àÄ (n : ‚Ñï) (f : (fin (n + 1) ‚Üí R) ‚Üí‚Çó[R] fin n ‚Üí R), ¬¨function.injective ‚áëf
 : ‚Ñï ‚Üí ‚Ñï ‚Üí tactic unit
{Œ± : Type} (n : name) (r : tactic.decl_reducibility) (body : tactic Œ±) : tactic Œ±
{R : Type u_1} [comm_semiring R] {R' : Type u_2} [monoid R'] {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] [distrib_mul_action R' M] [smul_comm_class R R' M] {R'‚ÇÇ : Type u_9} [monoid R'‚ÇÇ] [distrib_mul_action R'‚ÇÇ M] [smul_comm_class R R'‚ÇÇ M] [has_scalar R'‚ÇÇ R'] [is_scalar_tower R'‚ÇÇ R' M] : is_scalar_tower R'‚ÇÇ R' (tensor_product R M N)
{R : Type u} [semiring R] : polynomial R
{Œ± : Type u_1} {m : measurable_space Œ±} {M : Type u_3} [add_comm_group M] [topological_space M] [topological_add_group M] (v : measure_theory.vector_measure Œ± M) : measure_theory.vector_measure Œ± M
(p : ‚Ñï) [fact (nat.prime p)] : padic_norm p ‚Üëp = 1 / ‚Üëp
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} : tensor_algebra R M ‚Üí‚Çê[R] clifford_algebra Q
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) [invertible A] : A.mul (‚Öü A) = 1
{Œ± : Type u_1} [decidable_eq Œ±] {U V : finset Œ±} (hUV : U.card = V.card) (A : finset Œ±) : (uv.compress U V A).card = A.card
(p : ‚Ñï) (G : Type u_1) [group G] : Type u_1
{R : Type u_1} [comm_semiring R] (r : R) : ‚áëlaurent_polynomial.C r = ‚áë(algebra_map R (laurent_polynomial R)) r
(slow no_dflt : bool) (args : list tactic.simp_arg_type) (tac : bool ‚Üí list tactic.simp_arg_type ‚Üí tactic unit) (mk_suggestion : list tactic.simp_arg_type ‚Üí tactic unit) : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.mono f] : ‚Üë(category_theory.subobject.mk f) ‚âÖ X
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 : P) (g : G) (p2 : P) : p1 = g +·µ• p2 ‚Üî p1 -·µ• p2 = g
{R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra A B] [algebra R B] [algebra R A] [is_scalar_tower R A B] (hA : algebra.is_integral R A) (hB : algebra.is_integral A B) : algebra.is_integral R B
{Œπ : Type u_1} {Œπ' : Type u_2} {Œ± : Type u_3} [fintype Œπ] [preorder Œπ'] [is_directed Œπ' has_le.le] [nonempty Œπ'] {s : Œπ ‚Üí Œπ' ‚Üí set Œ±} (hs : ‚àÄ (i : Œπ), monotone (s i)) : (‚ãÉ (j : Œπ'), ‚ãÇ (i : Œπ), s i j) = ‚ãÇ (i : Œπ), ‚ãÉ (j : Œπ'), s i j
(C : Type u) [category_theory.category C] : Prop
{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : matrix n n (polynomial R)
{n : Type u_1} {R : Type u‚ÇÇ} [decidable_eq n] [comm_ring R] (t : matrix.transvection_struct n R) : matrix n n R
 : Set
{F : Type u_1} [normed_group F] [normed_space ‚Ñù F] (f : ‚Ñù ‚Üí F) (K : set F) : set ‚Ñù
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : (C·µí·µñ ‚•§ D·µí·µñ) ‚•§ (C ‚•§ D)·µí·µñ
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {K : Type u‚ÇÅ} [category_theory.category K] (F : J ‚•§ C) (G : K ‚•§ C) (h : F.cocones ‚âÖ G.cocones) [category_theory.limits.has_colimit F] : category_theory.limits.has_colimit G
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.is_equivalence (category_theory.shift_functor C i)
 : tactic.unify_equations.unification_step
(u : pnat.xgcd_type) : ‚Ñï √ó ‚Ñï
{Œ± : Type u} [infinite Œ±] {s : set Œ±} (hf : s.finite) : s ‚àâ filter.hyperfilter Œ±
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b : Œ±} (ha : a ‚â§ 1) (hb : b ‚â§ 1) : a * b ‚â§ 1
{G : Type u} [monoid G] {H : Type v} [monoid H] (f : G ‚Üí* H) {x : G} (h : is_of_fin_order x) : is_of_fin_order (‚áëf x)
{G : Type u_1} {M : Type u_3} {Œ± : Type u_5} [group G] [monoid M] [mul_action G M] [has_scalar M Œ±] [has_scalar G Œ±] [smul_comm_class G M M] [is_scalar_tower G M M] [is_scalar_tower G M Œ±] : is_scalar_tower G MÀ£ Œ±
 : Type (u_1+1)
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] {l : filter Œ≤} {f : Œ≤ ‚Üí Œ± √ó Œ±} (h : filter.tendsto f l (uniformity Œ±)) : filter.tendsto (Œª (x : Œ≤), ((f x).snd, (f x).fst)) l (uniformity Œ±)
{Œπ : Type u‚ÇÅ} {k : Type u‚ÇÇ} {V : Type u‚ÇÉ} {P : Type u‚ÇÑ} [add_comm_group V] [add_torsor V P] [ring k] [module k V] (b : affine_basis Œπ k P) : P ‚Üí·µÉ[k] Œπ ‚Üí k
(t : expr ‚Üí tactic unit) (x : expr) : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} (x : category_theory.presieve.family_of_elements P R) (t : P.obj (opposite.op X)) : Prop
{J : Type v} [category_theory.small_category J] (F : J ‚•§ SemiRing) : category_theory.limits.is_limit ((category_theory.forget‚ÇÇ SemiRing AddCommMon).map_cone (SemiRing.has_limits.limit_cone F))
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : Prop
 : ordinal
{Œ± : Type u_1} {Œ±' : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_5} {Œ¥ : Type u_7} {f : filter Œ±} {g : filter Œ≤} {m : Œ±' ‚Üí Œ≤ ‚Üí Œ≥} {n : Œ± ‚Üí Œ±'} {m' : Œ≤ ‚Üí Œ± ‚Üí Œ¥} {n' : Œ¥ ‚Üí Œ≥} (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤), m (n a) b = n' (m' b a)) : filter.map‚ÇÇ m (filter.map n f) g = filter.map n' (filter.map‚ÇÇ m' g f)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) : list (sigma Œ≤) ‚Üí list (sigma Œ≤)
(u : ‚Ñ§À£) : u ^ 2 = 1
{G : Type w} [topological_space G] [add_group G] [topological_add_group G] {K U : set G} (hK : is_compact K) (hU : is_open U) (hKU : K ‚äÜ U) : ‚àÉ (V : set G) (H : V ‚àà nhds 0), K + V ‚äÜ U
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± ‚Ñ±' : category_theory.SheafOfTypes K} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) (X : D) : ‚Ñ±.val.obj (opposite.op X) ‚âÖ ‚Ñ±'.val.obj (opposite.op X)
{b x : ordinal} (h : 1 < b) : {o : ordinal | x < b ^ o}.nonempty
{p : ‚Ñï} [fact (nat.prime p)] (hp : p % 4 = 1) : ‚àÉ (a b : ‚Ñï), a ^ 2 + b ^ 2 = p
(n : Type u_3) (Œ± : Type u_5) (R : Type u_6) [fintype n] [add_comm_monoid R] [semiring Œ±] [module Œ± R] : matrix n n R ‚Üí‚Çó[Œ±] R
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [densely_ordered Œ±] {Œ¥ : Type u_1} [linear_order Œ¥] [topological_space Œ¥] [order_closed_topology Œ¥] {f : Œ± ‚Üí Œ¥} (hf : continuous f) (h_top : filter.tendsto f filter.at_top filter.at_top) (h_bot : filter.tendsto f filter.at_bot filter.at_bot) : function.surjective f
{G : Type u_1} [has_add G] : G ‚Üí G ‚Üí G
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] {f g : ‚ÑÇ ‚Üí E} (hdf : diff_cont_on_cl ‚ÑÇ f (set.Iio 0 √ó‚ÑÇ set.Ioi 0)) (hBf : ‚àÉ (c : ‚Ñù) (H : c < 2) (B : ‚Ñù), f =O[filter.comap complex.abs filter.at_top ‚äì filter.principal (set.Iio 0 √ó‚ÑÇ set.Ioi 0)] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)) (hdg : diff_cont_on_cl ‚ÑÇ g (set.Iio 0 √ó‚ÑÇ set.Ioi 0)) (hBg : ‚àÉ (c : ‚Ñù) (H : c < 2) (B : ‚Ñù), g =O[filter.comap complex.abs filter.at_top ‚äì filter.principal (set.Iio 0 √ó‚ÑÇ set.Ioi 0)] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)) (hre : ‚àÄ (x : ‚Ñù), x ‚â§ 0 ‚Üí f ‚Üëx = g ‚Üëx) (him : ‚àÄ (x : ‚Ñù), 0 ‚â§ x ‚Üí f (‚Üëx * complex.I) = g (‚Üëx * complex.I)) : set.eq_on f g {z : ‚ÑÇ | z.re ‚â§ 0 ‚àß 0 ‚â§ z.im}
{A : Type u_1} {B : Type u_2} {C : Type u_3} [ring A] [ring B] [ring C] (f : A ‚Üí+* B) (f_inv : B ‚Üí A) (hf : function.right_inverse f_inv ‚áëf) : {g // f.ker ‚â§ g.ker} ‚âÉ (B ‚Üí+* C)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} (f : homotopy_equiv C D) : (homotopy_category.quotient V c).obj C ‚âÖ (homotopy_category.quotient V c).obj D
(Œ± : Type u) : Type u
{C : Type u} [category_theory.category C] (T : category_theory.monad C) : category_theory.kleisli.adjunction.to_kleisli T ‚ä£ category_theory.kleisli.adjunction.from_kleisli T
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] {D : Type u_1} [category_theory.category D] [category_theory.preadditive D] (F : C ‚•§ D) [F.additive] : category_theory.Mat_ C ‚•§ category_theory.Mat_ D
{Œ± Œ≤ : BoundedLattice} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
{R : Type u_1} {S : Type u_3} [distrib R] [distrib S] : distrib (R √ó S)
{F : Type u ‚Üí Type u} [functor F] {Œ± : Type u} (r : Œ± ‚Üí Œ± ‚Üí Prop) (x y : F Œ±) : Prop
{F : Type u_1} [field F] {p q : polynomial F} (hpq : p ‚à£ q) : q.gal ‚Üí* p.gal
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : C·µí·µñ ‚•§ D·µí·µñ
 : Type
(R : Type u_1) (M : Type u_9) [semiring R] [add_comm_monoid M] [module R M] : linear_map.general_linear_group R M ‚âÉ* M ‚âÉ‚Çó[R] M
{R : Type u} [comm_semiring R] {S : Type v} [semiring S] [algebra R S] (p : polynomial R) : ‚áë(polynomial.map_alg R S) p = polynomial.map (algebra_map R S) p
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p‚ÇÇ : Œπ ‚Üí P) (p‚ÇÅ b : P) : s.sum (Œª (i : Œπ), w i ‚Ä¢ (p‚ÇÅ -·µ• p‚ÇÇ i)) = s.sum (Œª (i : Œπ), w i) ‚Ä¢ (p‚ÇÅ -·µ• b) - ‚áë(s.weighted_vsub_of_point p‚ÇÇ b) w
(Œ± : Type u_5) (Œ≤ : Type u_6) [uniform_space Œ±] [uniform_space Œ≤] : Type (max u_5 u_6)
{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_4} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (hr : ‚àÄ (a : Œ±) (b‚ÇÅ b‚ÇÇ : Œ≤), s b‚ÇÅ b‚ÇÇ ‚Üí f a b‚ÇÅ = f a b‚ÇÇ) (hs : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±) (b : Œ≤), r a‚ÇÅ a‚ÇÇ ‚Üí f a‚ÇÅ b = f a‚ÇÇ b) (q‚ÇÅ : quot r) (q‚ÇÇ : quot s) : Œ≥
{R : Type u} [comm_semiring R] (t : multiset (polynomial R)) (h : (multiset.map polynomial.leading_coeff t).prod ‚â† 0) : t.prod.leading_coeff = (multiset.map polynomial.leading_coeff t).prod
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] {S T : convex_cone ùïú E} : ‚ÜëS = ‚ÜëT ‚Üî S = T
{Œ± : Type u_1} [measurable_space Œ±] : set Œ± ‚Üí Prop
(Œ± : Type u_1) (n : ‚Ñï) : vector Œ± n ‚âÉ (fin n ‚Üí Œ±)
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (F : C ‚•§ D) : F.to_ess_image ‚ãô F.ess_image_inclusion ‚âÖ F
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {F : C ‚•§ D} [category_theory.full F] [category_theory.faithful F] [category_theory.limits.has_limit (K ‚ãô F)] (c : category_theory.limits.cone K) (i : F.map_cone c ‚âÖ category_theory.limits.limit.cone (K ‚ãô F)) : category_theory.creates_limit K F
{Œ≤ : Type w} {C : Type u} [category_theory.category C] [unique Œ≤] (f : Œ≤ ‚Üí C) : category_theory.limits.colimit_cocone (category_theory.discrete.functor f)
{x y z : pgame} (h‚ÇÅ : x.lf y) (h‚ÇÇ : y < z) : x.lf z
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.regular_epi f] [m : category_theory.mono f] : category_theory.is_iso f
{Œ≥ : Type u_3} [tŒ≥ : topological_space Œ≥] [polish_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] {s : set Œ≥} : polish_space.is_clopenable s ‚Üî measurable_set s
(fn : pexpr) : tactic (option string)
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±] (a b : Œ±) : filter.comap coe (nhds_within a (set.Ioi a)) = filter.at_bot
{V : Type u} {G : simple_graph V} (d : G.dart) : V
(n : ‚Ñï+) (S : set ‚Ñï+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [ne_zero ‚Üë‚Üën] [is_cyclotomic_extension S K L] (hS : n ‚àà S) : polynomial.splits (algebra_map K L) (polynomial.cyclotomic ‚Üën K)
(s : simp_lemmas) (hs : list expr) : tactic simp_lemmas
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x y : R) : v.int_valuation_def (x * y) = v.int_valuation_def x * v.int_valuation_def y
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {L' : Type u_3} [field L'] [algebra K L'] (f : L ‚Üí‚Çê[K] L') : intermediate_field K L'
{X : Top} (U : topological_space.opens ‚Ü•X) : (topological_space.opens.to_Top X).obj U ‚ü∂ X
{G : Type u_1} [comm_group G] (sets : set (set G)) (nonempty : sets.nonempty) (inter_sets : ‚àÄ (x y : set G), x ‚àà sets ‚Üí y ‚àà sets ‚Üí (‚àÉ (z : set G) (H : z ‚àà sets), z ‚äÜ x ‚à© y)) (one : ‚àÄ (U : set G), U ‚àà sets ‚Üí 1 ‚àà U) (mul : ‚àÄ (U : set G), U ‚àà sets ‚Üí (‚àÉ (V : set G) (H : V ‚àà sets), V * V ‚äÜ U)) (inv : ‚àÄ (U : set G), U ‚àà sets ‚Üí (‚àÉ (V : set G) (H : V ‚àà sets), V ‚äÜ (Œª (x : G), x‚Åª¬π) ‚Åª¬π' U)) : group_filter_basis G
(Œ± : Type u) : Type u
{G : Type u_1} [add_group G] : has_top (add_subgroup G)
{œÑ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ≤] (f : filter œÑ) (œï : œÑ ‚Üí Œ± ‚Üí Œ≤) (s : set Œ±) (y : Œ≤) : y ‚àà omega_limit f œï s ‚Üî ‚àÄ (n : set Œ≤), n ‚àà nhds y ‚Üí (‚àÉ·∂† (t : œÑ) in f, (s ‚à© œï t ‚Åª¬π' n).nonempty)
{Œ± : Type u_1} [topological_space Œ±] {x : Œ±} {s : set Œ±} {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] [has_continuous_add Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : lower_semicontinuous_within_at f s x) (hg : lower_semicontinuous_within_at g s x) : lower_semicontinuous_within_at (Œª (z : Œ±), f z + g z) s x
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {f : ‚ÑÇ ‚Üí E} {c : ‚ÑÇ} {R : ‚Ñù} {w : ‚ÑÇ} (hf : circle_integrable f c R) (hw : complex.abs w < R) : has_sum (Œª (n : ‚Ñï), ‚áë(cauchy_power_series f c R n) (Œª (_x : fin n), w)) ((2 * ‚Üëreal.pi * complex.I)‚Åª¬π ‚Ä¢ ‚àÆ (z : ‚ÑÇ) in C(c, R), (z - (c + w))‚Åª¬π ‚Ä¢ f z)
 : tactic string
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : set Œ±} [is_refl Œ± r] : s.pairwise r ‚Üí ‚àÄ ‚¶Éa : Œ±‚¶Ñ, a ‚àà s ‚Üí ‚àÄ ‚¶Éb : Œ±‚¶Ñ, b ‚àà s ‚Üí r a b
{J : Type u_1} [category_theory.category J] {C : Type u_3} [category_theory.category C] [category_theory.limits.has_initial C] : category_theory.limits.colimit ((category_theory.functor.const J).obj (‚ä•_ C)) ‚âÖ ‚ä•_ C
{Œ± : Type u} [inhabited Œ±] : ‚Ñï ‚Üí list Œ± ‚Üí Œ±
{Œπ : Type u_1} {Z : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), canonically_ordered_add_monoid (Z i)] : canonically_ordered_add_monoid (Œ† (i : Œπ), Z i)
{Œ± : Sort u‚ÇÅ} (Œ≤ : Sort u‚ÇÇ) (a : Œ±) : Œ≤ ‚Üí Œ±
(e : nonote) (n : ‚Ñï+) (a : nonote) (h : a.below e) : nonote
{G : Type u_1} [group G] (H : subgroup G) : Prop
(R : Type u_3) (A : Type u_4) [semiring R] [add_comm_monoid A] [module R A] : unitization R A ‚Üí‚Çó[R] A
(locat : interactive.loc) : tactic unit
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a : Œ±} : -a < 0 ‚Üí 0 < a
{G : Type u_1} [linear_ordered_add_comm_group G] (H : add_subgroup G) : linear_ordered_add_comm_group ‚Ü•H
{Œ± : Type u_5} {Œ≤ : Type u_6} [non_unital_non_assoc_semiring Œ±] [non_unital_non_assoc_semiring Œ≤] (self : Œ± ‚Üí‚Çô+* Œ≤) : Œ± ‚Üí+ Œ≤
 : tactic.auto_cases.auto_cases_tac
{M : Type u_1} [monoid M] {s : set M} : s ‚äÜ monoid.closure s
{C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimits C
(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Prop
{C : ereal ‚Üí Sort u_1} (h_bot : C ‚ä•) (h_real : Œ† (a : ‚Ñù), C ‚Üëa) (h_top : C ‚ä§) (a : ereal) : C a
{G : Type u_7} [add_comm_group G] (L : list G) (n : ‚Ñï) (a : G) : (L.update_nth n a).sum = L.sum + dite (n < L.length) (Œª (hn : n < L.length), -L.nth_le n hn + a) (Œª (hn : ¬¨n < L.length), 0)
{Œ± : Type u} : has_mem Œ± (stream Œ±)
{ùïú : Type u_1} [linear_ordered_field ùïú] {s : set ùïú} {f : ùïú ‚Üí ùïú} (hs : convex ùïú s) (hf : ‚àÄ {x y z : ùïú}, x ‚àà s ‚Üí z ‚àà s ‚Üí x < y ‚Üí y < z ‚Üí (f y - f x) / (y - x) < (f z - f y) / (z - y)) : strict_convex_on ùïú s f
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] {ùíú : ‚Ñï ‚Üí submodule R A} [graded_algebra ùíú] {f : A} {m : ‚Ñï} (f_deg : f ‚àà ùíú m) : subring (localization.away f)
{Œ± : Type u_1} [subsingleton Œ±] : Œ± √ó Œ± ‚âÉ Œ±
{R : Type u_1} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : has_top (submodule R M)
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] {c : con M} {f : M ‚Üí N} (H : ‚àÄ (x y : M), f (x * y) = f x * f y) (h : con.mul_ker f H ‚â§ c) (hf : function.surjective f) : c.map_gen f = c.map_of_surjective f H h hf
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [topological_space Œ±] [topological_space Œ≤] : Type (max u_6 u_7 u_8)
(M : Type u_1) (Œ± : Type u_2) [group M] [mul_action M Œ±] {Œπ : Sort u_3} {s : Œπ ‚Üí set Œ±} : fixing_subgroup M (‚ãÉ (i : Œπ), s i) = ‚®Ö (i : Œπ), fixing_subgroup M (s i)
{G : Type u_1} [group G] [topological_space G] [topological_group G] [t2_space G] {K‚ÇÄ : topological_space.positive_compacts G} : ‚áë(measure_theory.measure.haar.haar_content K‚ÇÄ) K‚ÇÄ.to_compacts = 1
(M : Type u_1) {Œ± : Type u_2} [monoid M] [mul_action M Œ±] (s : set Œ±) : submonoid M
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) (F : C·µí·µñ ‚•§ Type v‚ÇÅ) : (category_theory.yoneda.obj X ‚ü∂ F) ‚âÖ ulift (F.obj (opposite.op X))
{n : ‚Ñï} (x : bitvec n) : bitvec n
{M : Type u_1} (S : set M) [has_add M] : set M
(e : interactive.parse interactive.types.texpr) (ids : interactive.parse interactive.types.with_ident_list) : tactic unit
{Œ± : Type u_1} : has_add (language Œ±)
(Œ± : Type u_1) [boolean_ring Œ±] : as_boolring (as_boolalg Œ±) ‚âÉ+* Œ±
(X : Type u_4) [topological_space X] : Prop
{Œ≥ : Type w} [semilattice_sup Œ≥] {s t : set Œ≥} : bdd_above (s ‚à™ t) ‚Üî bdd_above s ‚àß bdd_above t
(Œ± : Type u) : Type u
{V : Type u_2} (P : Type u_3) [semi_normed_group V] [pseudo_metric_space P] [normed_add_torsor V P] (x : V) : P ‚âÉ·µ¢ P
{Œ± : Type u} (s : set (set Œ±)) (hs : {u : set Œ± | (topological_space.generate_from s).is_open u} = s) : topological_space Œ±
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a : Œ±} : a‚Åª¬π ‚â§ 1 ‚Üí 1 ‚â§ a
(n p : ‚Ñï) : (finset.range n).sum (Œª (k : ‚Ñï), ‚Üëk ^ p) = (finset.range (p + 1)).sum (Œª (i : ‚Ñï), bernoulli i * ‚Üë((p + 1).choose i) * ‚Üën ^ (p + 1 - i) / (‚Üëp + 1))
{A : Type u_3} [semiring A] [algebra ‚Ñù A] (f : ‚ÑÇ ‚Üí‚Çê[‚Ñù] A) (x : ‚Ñù) : ‚áëf ‚Üëx = ‚áë(algebra_map ‚Ñù A) x
(p : ‚Ñï) [hp : fact (nat.prime p)] : ‚Ñï ‚Üí mv_polynomial (fin 0 √ó ‚Ñï) ‚Ñ§
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] : ‚ä§ ‚àà fixed_by_finite K L
(Œì‚ÇÄ : Type u_1) [linear_ordered_comm_group_with_zero Œì‚ÇÄ] : has_continuous_mul Œì‚ÇÄ
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : category_theory.limits.span f g ‚ãô F ‚âÖ category_theory.limits.walking_span_functor ‚ãô category_theory.limits.span (F.map f) (F.map g)
{Œì : Type u_1} {R : Type u_2} [partial_order Œì] [has_zero R] [has_zero Œì] (x : hahn_series Œì R) : Œì
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [semiring R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] (e : topological_vector_bundle.pretrivialization R F E) (b : B) : F ‚Üí‚Çó[R] E b
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {Œπ : Type u_1} {t : finset Œπ} {f : Œπ ‚Üí R} (h : ‚àÄ (c : Œπ), c ‚àà t ‚Üí f c ‚àà s) : t.sum (Œª (i : Œπ), f i) ‚àà s
 : has_zero pgame
{Œ± : Type u} : seq Œ± ‚Üí seq Œ±
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) : category_theory.limits.preserves_colimits_of_size F
 : Type
(R : Type u_1) [comm_ring R] {c‚ÇÅ c‚ÇÇ : R} : quaternion_algebra.basis (quaternion_algebra R c‚ÇÅ c‚ÇÇ) c‚ÇÅ c‚ÇÇ
{Œ± : Type u_1} {M : Type u_5} [has_zero M] {f g : Œ± ‚Üí‚ÇÄ M} : f = g ‚Üî ‚àÄ (a : Œ±), ‚áëf a = ‚áëg a
{Œ± : Type u} [has_add Œ±] : add_hom Œ± (with_zero Œ±)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {i : Œ± ‚Üí Œ≤} [t2_space Œ≤] (di : dense_inducing i) (hd : dense (set.range i)·∂ú) {s : set Œ±} (hs : is_compact s) : interior s = ‚àÖ
{X : Type u_1} [topological_space X] {x y : X} {f : ‚Ñù ‚Üí X} (hf : continuous_on f unit_interval) (h‚ÇÄ : f 0 = x) (h‚ÇÅ : f 1 = y) : path x y
{C : Type u} [category_theory.category C] {X : Top} [category_theory.limits.has_products C] (F : Top.presheaf C X) : F.is_sheaf ‚Üî F.is_sheaf_opens_le_cover
{Œ± : Type} (m : tactic Œ±) : tactic.ring.ring_m Œ±
{Œ± : Type u_1} (L L' : list (list Œ±)) : L = L' ‚Üî L.join = L'.join ‚àß list.map list.length L = list.map list.length L'
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] (l : finset Œ±) (hp : ‚àÉ! (a : Œ±), a ‚àà l ‚àß p a) : {a // a ‚àà l ‚àß p a}
{Œ± : Type u_1} (r s : setoid Œ±) (h : r ‚â§ s) : quotient (setoid.ker (quot.map_right h)) ‚âÉ quotient s
{m : Type u_2} {Œ± : Type u_12} (M : matrix m m Œ±) (b : m ‚Üí ‚Ñï) (k : ‚Ñï) : matrix {a // b a = k} {a // b a = k} Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {x : E} {n : with_top ‚Ñï} (h : cont_diff_at ùïú n f x) (hn : 1 ‚â§ n) : differentiable_at ùïú f x
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [preorder Œ±] [preorder Œ≤] [mul_zero_one_class Œ±] [mul_zero_one_class Œ≤] : Type (max u_6 u_7 u_8)
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) : J.plus_obj P ‚ü∂ J.plus_obj Q
(C : Type u) [category_theory.category C] : Prop
 : Type
 : Type
{Œ± : Type u} [pseudo_emetric_space Œ±] (Œ¥ : ‚Ñù) : metric.cthickening Œ¥ ‚àÖ = ‚àÖ
{ùïú : Type u_1} {F : Type u_3} [is_R_or_C ùïú] [add_comm_group F] [module ùïú F] [c : inner_product_space.core ùïú F] : has_norm F
(hs : list tactic.simp_arg_type) : tactic (list pexpr √ó list name √ó list name √ó bool)
 : Type (u+1)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} (H : C ‚•§ D) {c c' : category_theory.limits.cone F} (f : c ‚ü∂ c') : H.map_cone c ‚ü∂ H.map_cone c'
{C : Type u} [category_theory.category C] [category_theory.abelian C] (P : C) : Type (max u v)
{C : Type u‚ÇÅ} [category_theory.category C] {M N : category_theory.monad C} (h : M ‚âÖ N) : ‚ÜëM ‚âÖ ‚ÜëN
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.final] {E : Type u} [category_theory.category E] {G : D ‚•§ E} [category_theory.limits.has_colimit (F ‚ãô G)] : category_theory.limits.has_colimit G
(M : Type u_1) [monoid M] (X : Type u) [mul_action M X] : X ‚âÉ category_theory.action_category M X
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] (p : E) : ‚áë(reflection K) p = bit0 ‚Üë(‚áë(orthogonal_projection K) p) - p
 : Type (u+1)
{M : Type u} [has_mul M] (a x y : M) : Prop
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_one M] [has_one N] : Type (max u_10 u_11 u_9)
{Œ± : Type u} {a : Œ±} (s : set Œ±) [fintype ‚Ü•s] (h : a ‚àà s) : fintype ‚Ü•(has_insert.insert a s)
 : tactic.instance_cache ‚Üí expr ‚Üí expr ‚Üí expr ‚Üí tactic (tactic.instance_cache √ó expr)
(F : pfunctor) : ‚Ñï ‚Üí Type u
 : tactic unit ‚Üí list (name √ó list expr) ‚Üí tactic unit
{Œ± : Type u_1} [comm_ring Œ±] (E : linear_recurrence Œ±) : polynomial Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : (category_theory.monoidal.from_transported e).to_lax_monoidal_functor ‚äó‚ãô category_theory.monoidal.lax_to_transported e ‚âÖ category_theory.lax_monoidal_functor.id (category_theory.monoidal.transported e)
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {ca cb : E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a ‚äì measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (nhds b ‚äì measure_theory.measure_space.volume.ae) (nhds cb)) : has_fderiv_at (Œª (p : ‚Ñù √ó ‚Ñù), ‚à´ (x : ‚Ñù) in p.fst..p.snd, f x) ((continuous_linear_map.snd ‚Ñù ‚Ñù ‚Ñù).smul_right cb - (continuous_linear_map.fst ‚Ñù ‚Ñù ‚Ñù).smul_right ca) (a, b)
{E : Type u} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {a : E} {f' : E ‚ÜíL[‚Ñù] ‚Ñù} (h : is_local_min f a) (hf : has_fderiv_at f f' a) : f' = 0
 : compare_reals.Bourbaki‚Ñù ‚âÉ ‚Ñù
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {L‚ÇÇ : Type w} [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÇ] (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) (K : lie_subalgebra R L) : lie_subalgebra R L‚ÇÇ
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) : submodule R (M ‚ß∏ p) ‚âÉo {p' // p ‚â§ p'}
(R : Type u_1) {S : Type u_6} (M : Type u_9) [semiring R] [add_comm_monoid M] [module R M] [semiring S] [module S M] [smul_comm_class S R M] : S ‚Üí+* module.End R M
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} : is_max_on f s a ‚Üí is_min_on (‚áëorder_dual.to_dual ‚àò f) s a
{M : Type u_3} {S : Type u_4} [div_inv_monoid M] [set_like S M] [hSM : subgroup_class S M] {H : S} : has_inv ‚Ü•H
{Œ± : Type u} {p : Œ± ‚Üí Prop} [has_le Œ±] [order_top Œ±] (htop : p ‚ä§) : order_top {x // p x}
{Œπ : Type u_1} {Œπ' : Type u_2} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Œπ R M) (e : Œπ ‚âÉ Œπ') : basis Œπ' R M
{V : Type u} (G : simple_graph V) (n : ‚Ñï) : Prop
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) : K·óÆ = ‚®Ö (v : ‚Ü•K), (‚áëinnerSL ‚Üëv).ker
{ùíú : Type u_1} [category_theory.category ùíú] {A B C : ùíú} {f : A ‚ü∂ B} {g : B ‚ü∂ C} [category_theory.limits.has_zero_morphisms ùíú] [category_theory.limits.has_binary_biproducts ùíú] (h : category_theory.splitting f g) : category_theory.split_epi g
{C : Type u} {A : Type u_1} [category_theory.category C] [add_comm_monoid A] [category_theory.has_shift C A] {X Y : C} (f : X ‚ü∂ Y) (i j : A) : (category_theory.shift_functor C j).map ((category_theory.shift_functor C i).map f) = (category_theory.shift_comm X i j).hom ‚â´ (category_theory.shift_functor C i).map ((category_theory.shift_functor C j).map f) ‚â´ (category_theory.shift_comm Y j i).hom
(b o : ordinal) : list (ordinal √ó ordinal)
{Œ± : Type u_1} [linear_order Œ±] [pred_order Œ±] [is_pred_archimedean Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) {n m : Œ±} (h1 : ‚àÄ (i : Œ±), i ‚àà set.Ioc m n ‚Üí r i (order.pred i)) (h2 : ‚àÄ (i : Œ±), i ‚àà set.Ioc n m ‚Üí r (order.pred i) i) : relation.refl_trans_gen r n m
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} [ring_hom_isometric œÉ‚ÇÅ‚ÇÇ] (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F) : lipschitz_with ‚à•f‚à•‚Çä ‚áëf
(e : expr) : tactic expr
(Œ± : Type u) [has_add Œ±] : Type u
{Œ± : Type u_1} (r : setoid Œ±) : eqv_gen.setoid setoid.r = r
{Œ± : Type u} [pseudo_emetric_space Œ±] (Œ¥ : ‚Ñù) (E : set Œ±) : metric.thickening Œ¥ E ‚äÜ metric.cthickening Œ¥ E
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [semi_normed_group Œ≤] [star_add_monoid Œ≤] [normed_star_group Œ≤] (f : bounded_continuous_function Œ± Œ≤) : ‚áë(has_star.star f) = has_star.star ‚áëf
(x : clifford_algebra clifford_algebra_complex.Q) : ‚áëclifford_algebra.reverse x = x
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : ‚àÄ (x : ‚Ñù), x ‚àà interior D ‚Üí 0 < deriv f x) : strict_mono_on f D
{J : Type v} [category_theory.small_category J] [category_theory.is_cofiltered J] (F : J ‚•§ Top) (C : category_theory.limits.cone F) (hC : category_theory.limits.is_limit C) (T : Œ† (j : J), set (set ‚Ü•(F.obj j))) (hT : ‚àÄ (j : J), topological_space.is_topological_basis (T j)) (univ : ‚àÄ (i : J), set.univ ‚àà T i) (inter : ‚àÄ (i : J) (U1 U2 : set ‚Ü•(F.obj i)), U1 ‚àà T i ‚Üí U2 ‚àà T i ‚Üí U1 ‚à© U2 ‚àà T i) (compat : ‚àÄ (i j : J) (f : i ‚ü∂ j) (V : set ‚Ü•(F.obj j)), V ‚àà T j ‚Üí ‚áë(F.map f) ‚Åª¬π' V ‚àà T i) : topological_space.is_topological_basis {U : set ‚Ü•(C.X) | ‚àÉ (j : J) (V : set ‚Ü•(F.obj j)), V ‚àà T j ‚àß U = ‚áë(C.œÄ.app j) ‚Åª¬π' V}
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {v : set E} [finite_dimensional ùïú E] (hv : orthonormal ùïú coe) : (‚àÄ (u : set E), u ‚äá v ‚Üí orthonormal ùïú coe ‚Üí u = v) ‚Üî ‚àÉ (b : basis ‚Ü•v ùïú E), ‚áëb = coe
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} {f : A ‚ü∂ B} {g : B ‚ü∂ C} (w : f ‚â´ g = 0) {f' : A ‚ü∂ B} {g' : B ‚ü∂ C} (w' : f' ‚â´ g' = 0) [category_theory.limits.has_kernels V] [category_theory.limits.has_cokernels V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] (pf : f = f') (pg : g = g') : homology f g w ‚âÖ homology f' g' w'
 : declaration ‚Üí tactic unit
 : expr ‚Üí expr ‚äï bool
 : nzsnum ‚Üí nzsnum
(R : Type u_1) (S : Type u_2) (M : Type u_3) [semiring S] [add_comm_monoid M] [comm_semiring R] [algebra R S] [module S M] : is_scalar_tower R S (restrict_scalars R S M)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_mono f] : category_theory.mono f
{R : Type u_1} [comm_ring R] [H : topological_space R] (J : ideal R) : Prop
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (hash_fn : Œ± ‚Üí ‚Ñï) {n : ‚Ñï+} (data : bucket_array Œ± Œ≤ n) (a : Œ±) (l : list (Œ£ (a : Œ±), Œ≤ a)) : bucket_array Œ± Œ≤ n
{K : Type u_1} [is_R_or_C K] : K ‚ÜíL[‚Ñù] ‚Ñù
(R : Type u) [semiring R] (n : ‚Ñï) : polynomial R ‚Üí‚Çó[R] R
{a : Type u} : bool ‚Üí a ‚Üí a ‚Üí a
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] [fintype Œ≤] (h : fintype.card Œ± = fintype.card Œ≤) : Œ± ‚âÉ Œ≤
(n : ‚Ñï) : ‚Ñï
{Œì‚ÇÄ : Type u_1} [linear_ordered_comm_group_with_zero Œì‚ÇÄ] (Œ≥ : Œì‚ÇÄ) (h : Œ≥ ‚â† 0) : nhds Œ≥ = has_pure.pure Œ≥
(L : first_order.language) (Œ± : Type u') : Type (max u u')
{Œπ : Type u_1} {R : Type u_2} [comm_ring R] [linear_order Œπ] (s : finset Œπ) (f : Œπ ‚Üí R) : s.prod (Œª (i : Œπ), 1 - f i) = 1 - s.sum (Œª (i : Œπ), f i * (finset.filter (Œª (_x : Œπ), _x < i) s).prod (Œª (j : Œπ), 1 - f j))
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) {X : D} [category_theory.is_iso (h.counit.app X)] : category_theory.inv (R.map (h.counit.app X)) = h.unit.app (R.obj X)
(P : name ‚Üí bool) (s : name_set) : name_set
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ : X} (p : path x‚ÇÄ x‚ÇÅ) : ((path.refl x‚ÇÄ).trans p).homotopy p
 : (user_attribute simp_lemmas)
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {f f' : ‚ÑÇ ‚Üí E} {c : ‚ÑÇ} {R : ‚Ñù} (hR : 0 ‚â§ R) (h : ‚àÄ (z : ‚ÑÇ), z ‚àà metric.sphere c R ‚Üí has_deriv_within_at f (f' z) (metric.sphere c R) z) : ‚àÆ (z : ‚ÑÇ) in C(c, R), f' z = 0
{Œ± : Type u_1} [emetric_space Œ±] [cs : complete_space Œ±] {K : nnreal} (f : Œ± ‚Üí Œ±) (hf : contracting_with K f) (x : Œ±) (hx : has_edist.edist x (f x) ‚â† ‚ä§) : Œ±
{G‚ÇÄ : Type u_2} [group_with_zero G‚ÇÄ] (a : G‚ÇÄ) (ha : a ‚â† 0) : G‚ÇÄÀ£
{R : Type u_3} [semiring R] {S : Type u_4} [semiring S] {R‚ÇÇ : Type u_5} [semiring R‚ÇÇ] {S‚ÇÇ : Type u_6} [semiring S‚ÇÇ] {M : Type u_7} {N : Type u_8} {P : Type u_9} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module S N] [module R‚ÇÇ P] [module S‚ÇÇ P] [smul_comm_class S‚ÇÇ R‚ÇÇ P] {œÅ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÅ‚ÇÇ : S ‚Üí+* S‚ÇÇ} (f : M ‚Üí‚Çõ‚Çó[œÅ‚ÇÅ‚ÇÇ] N ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] P) (p : submodule R M) (q : submodule S N) : ‚Ü•p ‚Üí‚Çõ‚Çó[œÅ‚ÇÅ‚ÇÇ] ‚Ü•q ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] P
(C : Type u) [category_theory.category C] [‚àÄ {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z}, category_theory.limits.has_limit (category_theory.limits.cospan f g)] : category_theory.limits.has_pullbacks C
{n k : ‚Ñï} (h : k ‚â§ n) : n.desc_factorial k = n.factorial / (n - k).factorial
{Œ± : Type u_2} [add_comm_monoid Œ±] (A : set Œ±) (n : ‚Ñï) : A ‚Üí+[n] Œ±
 : ‚Ñï ‚Üí tactic unit ‚Üí tactic unit ‚Üí tactic unit
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) : ennreal
{Œ± : Type u} {Œ≤ : Type v} [decidable_eq Œ±] [add_comm_monoid Œ≤] {s : finset Œ±} {x : Œ±} (h : x ‚àâ s) (f : finset Œ± ‚Üí Œ≤) : (has_insert.insert x s).powerset.sum (Œª (a : finset Œ±), f a) = s.powerset.sum (Œª (a : finset Œ±), f a) + s.powerset.sum (Œª (t : finset Œ±), f (has_insert.insert x t))
{R : Type u} [comm_ring R] {G H : Module R} (f : G ‚ü∂ H) : Module R
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] {Z : D} (F : C ‚•§ D) (hZ : category_theory.limits.is_initial Z) : category_theory.with_initial.incl ‚ãô category_theory.with_initial.lift_to_initial F hZ ‚âÖ F
(Œ± : Type u_1) : Type u_1
{Œ± : Type u_1} [decidable_eq Œ±] {ùíú : finset (finset Œ±)} {s : finset Œ±} : s ‚àà ùíú.shadow ‚Üî ‚àÉ (a : Œ±) (H : a ‚àâ s), has_insert.insert a s ‚àà ùíú
{Œ± : Type u} (x : free_comm_ring Œ±) (s : set Œ±) : Prop
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} {f : D ‚ü∂ D} (h : homotopy f (ùüô D)) (g : C ‚ü∂ D) : homotopy (g ‚â´ f) g
 : ereal ‚Üí ‚Ñù
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ X‚ÇÉ) (g‚ÇÅ : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) (g‚ÇÇ : Y‚ÇÇ ‚ü∂ Y‚ÇÉ) (i‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (i‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (i‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) (h‚ÇÅ : i‚ÇÅ ‚â´ g‚ÇÅ = f‚ÇÅ ‚â´ i‚ÇÇ) (h‚ÇÇ : i‚ÇÇ ‚â´ g‚ÇÇ = f‚ÇÇ ‚â´ i‚ÇÉ) (H : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk i‚ÇÇ f‚ÇÇ h‚ÇÇ)) (H' : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk i‚ÇÅ (f‚ÇÅ ‚â´ f‚ÇÇ) _)) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk i‚ÇÅ f‚ÇÅ h‚ÇÅ)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ‚ü∂ Q) : ‚áëf 0 = 0
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] (a : Œ±) : Œ± ‚âÉo Œ±
{X Y : Type u} [add_comm_group X] [add_comm_group Y] (f : X ‚Üí+ Y) : AddCommGroup.of X ‚ü∂ AddCommGroup.of Y
(R : Type u_1) [has_mul R] [has_add R] : ring_aut R ‚Üí* equiv.perm R
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [semiring R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] [topological_space (bundle.total_space E)] (e : topological_vector_bundle.trivialization R F E) (b : B) : E b ‚Üí‚Çó[R] F
{C : Type u‚ÇÅ} [category_theory.category C] {G : Type u‚ÇÇ} [category_theory.groupoid G] (F : G ‚•§ C) : G ‚•§ category_theory.core C
{M' : Type u_1} {X : Type u_2} [has_scalar M' X] {Y : Type u_3} [has_scalar M' Y] {Z : Type u_4} [has_scalar M' Z] (g : Y ‚Üí[M'] Z) (f : X ‚Üí[M'] Y) : X ‚Üí[M'] Z
{Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) {Œ≥ : Type u_1} [group Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : is_group_hom g) : is_group_hom (g ‚àò f)
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] (f : multilinear_map R M‚ÇÅ M‚ÇÇ) {Œ± : Œπ ‚Üí Type u_1} (g : Œ† (i : Œπ), Œ± i ‚Üí M‚ÇÅ i) (A : Œ† (i : Œπ), finset (Œ± i)) [fintype Œπ] : ‚áëf (Œª (i : Œπ), (A i).sum (Œª (j : Œ± i), g i j)) = (fintype.pi_finset A).sum (Œª (r : Œ† (a : Œπ), Œ± a), ‚áëf (Œª (i : Œπ), g i (r i)))
 : tactic unit
 : category_theory.forget Top ‚ä£ Top.trivial
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : set Œ≤) (h : ‚àÄ (x : Œ±), f x ‚àà s) : Œ± ‚Üí ‚Ü•s
(Œì‚ÇÄ : Type u_1) [linear_ordered_comm_group_with_zero Œì‚ÇÄ] (x : Œì‚ÇÄ) {s : set Œì‚ÇÄ} (s_in : s ‚àà linear_ordered_comm_group_with_zero.nhds_fun Œì‚ÇÄ x) : ‚àÉ (t : set Œì‚ÇÄ) (H : t ‚àà linear_ordered_comm_group_with_zero.nhds_fun Œì‚ÇÄ x), t ‚äÜ s ‚àß ‚àÄ (y : Œì‚ÇÄ), y ‚àà t ‚Üí s ‚àà linear_ordered_comm_group_with_zero.nhds_fun Œì‚ÇÄ y
{X : Top} (F : Top.presheaf (Type v) X) : F ‚ü∂ F.sheafify.val
(G : Type u_1) [topological_space G] [has_involutive_neg G] [has_continuous_neg G] : G ‚âÉ‚Çú G
{C : Type u} [category_theory.category C] {F : C ‚•§ C} {A : category_theory.endofunctor.algebra F} (h : category_theory.limits.is_initial A) : A.A ‚ü∂ F.obj A.A
(Œ± : Type u_1) [lattice Œ±] [order_bot Œ±] : finpartition ‚ä•
(Œ∏ : real.angle) : ‚Ü•circle
{E : Type u_2} {ùïú : Type u_3} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] {s : set E} (hs : convex ùïú s) {x y : E} (hx : x ‚àà closure s) (hy : y ‚àà interior s) {t : ùïú} (ht : t ‚àà set.Ioc 0 1) : x + t ‚Ä¢ (y - x) ‚àà interior s
{Œ± : Sort u} : Œ±·µí·µñ ‚Üí Œ±
{A : Type u_4} {K : Type u_5} {C : Type u_6} [comm_ring A] [is_domain A] [field K] [algebra A K] [is_fraction_ring A K] [comm_ring C] [algebra A C] [algebra K C] [is_scalar_tower A K C] : algebra.is_algebraic A C ‚Üî algebra.is_algebraic K C
(t : expr) (p : interactive.parse (lean.parser.tk ":=" *> interactive.types.texpr)) : tactic unit
(R : Type u) {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (s : set A) : subalgebra R A
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C·µí·µñ} (c : category_theory.limits.cone F) : category_theory.limits.cocone F.left_op
{V : Type u} (G : simple_graph V) [decidable_eq V] (v : V) : ‚Ü•(G.incidence_set v) ‚âÉ ‚Ü•(G.neighbor_set v)
 : category_theory.limits.walking_span ‚Üí category_theory.limits.walking_span ‚Üí Type v
{Œ≥ : Type} : widget_override.interactive_expression.sf ‚Üí tactic (widget_override.interactive_expression.sf √ó list (widget.attr Œ≥))
 : ‚Ñï ‚Üí tactic unit ‚Üí tactic unit
{Œ± : Type u_1} : part Œ±
{K : Type u_1} [comm_ring K] [is_domain K] {p : polynomial K} (hroots : ‚áëmultiset.card p.roots = p.nat_degree) : ‚áëpolynomial.C p.leading_coeff * (multiset.map (Œª (a : K), polynomial.X - ‚áëpolynomial.C a) p.roots).prod = p
(X : Top) (T : Type u) : Top.sheaf (Type u) X
{R : Type u_1} {R‚ÇÅ : Type u_2} {R‚ÇÇ : Type u_3} {M‚ÇÅ : Type u_6} {M‚ÇÇ : Type u_7} [comm_semiring R] [comm_semiring R‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {I‚ÇÅ : R‚ÇÅ ‚Üí+* R} {I‚ÇÇ : R‚ÇÇ ‚Üí+* R} (B : M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ] M‚ÇÇ ‚Üí‚Çõ‚Çó[I‚ÇÇ] R) : Prop
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : Type (max u v)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [semilattice_inf Œ≤] {f g : Œ± ‚Üí Œ≤} (hf : monotone f) (hg : monotone g) : monotone (f ‚äì g)
(R : Type u_1) [has_mul R] [has_add R] : Type u_1
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [add_comm_monoid Œ±] [topological_space Œ±] [t2_space Œ±] [encodable Œ≥] [complete_lattice Œ≤] (m : Œ≤ ‚Üí Œ±) (m0 : m ‚ä• = 0) (R : Œ± ‚Üí Œ± ‚Üí Prop) (m_supr : ‚àÄ (s : ‚Ñï ‚Üí Œ≤), R (m (‚®Ü (i : ‚Ñï), s i)) (‚àë' (i : ‚Ñï), m (s i))) (s : Œ≥ ‚Üí Œ≤) : R (m (‚®Ü (b : Œ≥), s b)) (‚àë' (b : Œ≥), m (s b))
(R : Type u_2) {M : Type u_5} {M‚ÇÇ : Type u_6} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid M‚ÇÇ] [has_scalar R M‚ÇÇ] (f : M ‚Üí+ M‚ÇÇ) (hf : function.surjective ‚áëf) (smul : ‚àÄ (c : R) (x : M), ‚áëf (c ‚Ä¢ x) = c ‚Ä¢ ‚áëf x) : module R M‚ÇÇ
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {s t : category_theory.limits.cocone F} (P : category_theory.limits.is_colimit s) (Q : category_theory.limits.is_colimit t) (f : s ‚ü∂ t) : category_theory.is_iso f
{C : Type u} [category_theory.category C] [category_theory.concrete_category C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) (sf : Œ† (i : Œπ), ‚Ü•(F.obj (opposite.op (U i)))) : Prop
{Œ±‚ÇÅ : Type u_1} {Œ≤‚ÇÅ : Type u_2} {Œ±‚ÇÇ : Type u_3} {Œ≤‚ÇÇ : Type u_4} (ea : Œ±‚ÇÅ ‚âÉ Œ±‚ÇÇ) (eb : Œ≤‚ÇÅ ‚âÉ Œ≤‚ÇÇ) : Œ±‚ÇÅ ‚äï Œ≤‚ÇÅ ‚âÉ Œ±‚ÇÇ ‚äï Œ≤‚ÇÇ
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [semiring k] [mul_one_class G] : k √ó G ‚Üí* monoid_algebra k G
(R : Type u_1) [mul_zero_class R] : smul_with_zero R·µê·µí·µñ R
{R : Type u_3} [semiring R] {S : Type u_4} [semiring S] {R‚ÇÇ : Type u_5} [semiring R‚ÇÇ] {S‚ÇÇ : Type u_6} [semiring S‚ÇÇ] {M : Type u_7} {N : Type u_8} {P : Type u_9} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module S N] [module R‚ÇÇ P] [module S‚ÇÇ P] [smul_comm_class S‚ÇÇ R‚ÇÇ P] (œÅ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ) (œÉ‚ÇÅ‚ÇÇ : S ‚Üí+* S‚ÇÇ) (f : M ‚Üí N ‚Üí P) (H1 : ‚àÄ (m‚ÇÅ m‚ÇÇ : M) (n : N), f (m‚ÇÅ + m‚ÇÇ) n = f m‚ÇÅ n + f m‚ÇÇ n) (H2 : ‚àÄ (c : R) (m : M) (n : N), f (c ‚Ä¢ m) n = ‚áëœÅ‚ÇÅ‚ÇÇ c ‚Ä¢ f m n) (H3 : ‚àÄ (m : M) (n‚ÇÅ n‚ÇÇ : N), f m (n‚ÇÅ + n‚ÇÇ) = f m n‚ÇÅ + f m n‚ÇÇ) (H4 : ‚àÄ (c : S) (m : M) (n : N), f m (c ‚Ä¢ n) = ‚áëœÉ‚ÇÅ‚ÇÇ c ‚Ä¢ f m n) : M ‚Üí‚Çõ‚Çó[œÅ‚ÇÅ‚ÇÇ] N ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] P
(k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s : set P) : affine_span k s = has_Inf.Inf {s' : affine_subspace k P | s ‚äÜ ‚Üës'}
(G H : AddCommGroup) : category_theory.limits.limit_cone (category_theory.limits.pair G H)
 : num ‚Üí num
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (Œ± : Type u_1) [add_right_cancel_semigroup Œ±] [has_one Œ±] : Type (max u u_1 v)
{Œ± : Type u_2} [comm_monoid Œ±] {A : set Œ±} {n : ‚Ñï} {Œ≤ : Type u_1} [comm_group Œ≤] : comm_group (A ‚Üí*[n] Œ≤)
{Œ± : Type u_1} {n : Type u_4} [is_R_or_C Œ±] [fintype n] [decidable_eq n] {A : matrix n n Œ±} : A.is_hermitian ‚Üî inner_product_space.is_self_adjoint (‚áë((pi_Lp.linear_equiv Œ± (Œª (_x : n), Œ±)).symm.conj) (‚áëmatrix.to_lin' A))
{Œ± : Type u} [pseudo_metric_space Œ±] (x y : Œ±) : has_dist.dist ‚Üëx ‚Üëy = has_dist.dist x y
{Œ± : Type u_1} {Œ≤ : Type u_2} {rŒ± : Œ± ‚Üí Œ± ‚Üí Prop} {rŒ≤ : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (hŒ± : well_founded rŒ±) (hŒ≤ : well_founded rŒ≤) : well_founded (relation.game_add rŒ± rŒ≤)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_initial C] [category_theory.limits.initial_mono_class C] (f : X ‚ü∂ Y) [category_theory.mono f] : (category_theory.mono_over.map f).obj ‚ä• ‚âÖ ‚ä•
{Œ≥ : Type u_3} {Œ≥‚ÇÇ : Type u_4} [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [topological_space Œ≥‚ÇÇ] [measurable_space Œ≥‚ÇÇ] [borel_space Œ≥‚ÇÇ] (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : Œ≥ ‚âÉ·µê Œ≥‚ÇÇ
{R : Type u_1} {S : Type u_4} [comm_ring R] [comm_ring S] (p : polynomial R) (x : S) [algebra R S] (h : ‚áë(polynomial.aeval x) p = 0) : is_integral R (p.leading_coeff ‚Ä¢ x)
{n : ‚Ñï} (hpos : 0 < n) (R : Type u_1) [comm_ring R] : n.divisors.prod (Œª (i : ‚Ñï), polynomial.cyclotomic i R) = polynomial.X ^ n - 1
(S : (Type u)·µí·µñ ‚•§ Type u) (hs : category_theory.presieve.is_sheaf category_theory.types_grothendieck_topology S) : S ‚âÖ category_theory.yoneda.obj (S.obj (opposite.op punit))
{ùïú : Type u_3} [field ùïú] {r : ‚Ñï} (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) : ‚àÉ (L L' : list (matrix.transvection_struct (fin r ‚äï unit) ùïú)), (((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod).is_two_block_diagonal
{k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} {s : finset Œπ} (p : Œπ ‚Üí P) (h : ‚Üë(s.card) ‚â† 0) : finset.centroid k s p ‚àà affine_span k (set.range p)
 : linarith.preprocessor
{Œ± : Sort u} {Œ≤ : Sort v} (a : plift Œ±) (f : Œ± ‚Üí plift Œ≤) : plift Œ≤
{Œ± : Type u_1} (f : finpartition set.univ) : setoid.is_partition ‚Üë(f.parts)
 : list ‚Ñï ‚Üí list omega.term ‚Üí omega.term
{n : ‚Ñï} {Œ≤ : Type u_1} (q : fin (n + 2) ‚Üí Œ≤) : fin.tail (fin.init q) = fin.init (fin.tail q)
{k : Type u_1} (M : Type u_2) [linear_ordered_field k] [ordered_add_comm_group M] [mul_action_with_zero k M] [ordered_smul k M] {c : k} (hc : 0 < c) : M ‚âÉo M
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] (l : list Œ±) (f : equiv.perm Œ±) : (‚àÄ {x : Œ±}, ‚áëf x ‚â† x ‚Üí x ‚àà l) ‚Üí {l // l.prod = f ‚àß (‚àÄ (g : equiv.perm Œ±), g ‚àà l ‚Üí g.is_cycle) ‚àß list.pairwise equiv.perm.disjoint l}
{Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ±] [preorder Œ±] [topological_space Œ≤] [preorder Œ≤] (f : Œ± ‚ÜíCo Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : Œ± ‚ÜíCo Œ≤
(K : Type u) [field K] : galois_insertion subfield.closure coe
(ùïú : Type u_1) (E : Type u_4) (F‚Çó : Type u_7) [semi_normed_group E] [semi_normed_group F‚Çó] [nondiscrete_normed_field ùïú] [normed_space ùïú E] [normed_space ùïú F‚Çó] (ùïú' : Type u_10) [nondiscrete_normed_field ùïú'] [normed_algebra ùïú' ùïú] [normed_space ùïú' E] [is_scalar_tower ùïú' ùïú E] [normed_space ùïú' F‚Çó] [is_scalar_tower ùïú' ùïú F‚Çó] (ùïú'' : Type u_11) [ring ùïú''] [module ùïú'' F‚Çó] [has_continuous_const_smul ùïú'' F‚Çó] [smul_comm_class ùïú ùïú'' F‚Çó] [smul_comm_class ùïú' ùïú'' F‚Çó] : (E ‚ÜíL[ùïú] F‚Çó) ‚Üí‚Çó·µ¢[ùïú''] E ‚ÜíL[ùïú'] F‚Çó
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} [category_theory.limits.has_equalizers V] [category_theory.limits.has_cokernels V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] [category_theory.limits.has_zero_object V] (f : homotopy_equiv C D) (i : Œπ) : (homology_functor V c i).obj C ‚âÖ (homology_functor V c i).obj D
(f : circle_deg1_lift) {x : ‚Ñù} {m : ‚Ñ§} (h : ‚áëf x = x + ‚Üëm) : f.translation_number = ‚Üëm
{ùïÇ : Type u_1} [is_R_or_C ùïÇ] : has_deriv_at (exp ùïÇ) 1 0
{Œ± : Type u} {Œ≤ : Type v} [uniform_space Œ±] [semilattice_sup Œ≤] [complete_space Œ±] {u : Œ≤ ‚Üí Œ±} (H : cauchy_seq u) : ‚àÉ (x : Œ±), filter.tendsto u filter.at_top (nhds x)
 : tactic unit
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : ‚Ü•P
{a b r : ‚Ñù} (h : -1 < r) : interval_integrable (Œª (x : ‚Ñù), x ^ r) measure_theory.measure_space.volume a b
(Œ± : Type u_3) [topological_space Œ±] [has_le Œ±] : Type u_3
{Œπ : Type u_1} {Œ± : Type u_2} {s : Œπ ‚Üí set Œ±} (hs : indexed_partition s) : setoid Œ±
{Œ± : Sort u} {Œ≤ : Sort v} (f : plift (Œ± ‚Üí Œ≤)) (x : plift Œ±) : plift Œ≤
{ùïú : Type u_1} [is_R_or_C ùïú] [decidable_eq ùïú] {n : Type u_2} [fintype n] [decidable_eq n] {A : matrix n n ùïú} (hA : A.is_hermitian) : hA.eigenvector_matrix_inv.mul A = (matrix.diagonal (coe ‚àò hA.eigenvalues)).mul hA.eigenvector_matrix_inv
{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] : ‚àÉ (v : V), G.min_degree = G.degree v
{S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {P Q : C} (f : P ‚ü∂ Q) : C
{Œ± : Type u_1} {l l' : list Œ±} : l <+ l' ‚Üî ‚àÉ (f : fin l.length ‚Ü™o fin l'.length), ‚àÄ (ix : fin l.length), l.nth_le ‚Üëix _ = l'.nth_le ‚Üë(‚áëf ix) _
{R : Type u} {S : Type v} [ring R] [ring S] (f : R ‚Üí+* S) (hf : function.surjective ‚áëf) : ideal S ‚Ü™o ideal R
{R : Type u} {A : Type v} {B : Type w} [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B] : has_coe_to_fun (A ‚Üí‚Çô‚Çê[R] B) (Œª (_x : A ‚Üí‚Çô‚Çê[R] B), A ‚Üí B)
{R S : CommRing} (f : R ‚ü∂ S) (p : prime_spectrum ‚Ü•S) : (algebraic_geometry.structure_sheaf.stalk_iso ‚Ü•R (‚áë(prime_spectrum.comap f) p)).hom ‚â´ localization.local_ring_hom (‚áë(prime_spectrum.comap f) p).as_ideal p.as_ideal f rfl ‚â´ (algebraic_geometry.structure_sheaf.stalk_iso ‚Ü•S p).inv = algebraic_geometry.PresheafedSpace.stalk_map (algebraic_geometry.Spec.SheafedSpace_map f) p
(Œ± : Type u_1) (Œ≤ : Type u_2) : Œ± ‚äï Œ≤ ‚âÉ Œ≤ ‚äï Œ±
{R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group N] [module R N] [lie_ring_module L N] [lie_module R L N] : ‚Ü•(lie_module.max_triv_submodule R L (M ‚Üí‚Çó[R] N)) ‚âÉ‚Çó[R] M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N
{C : Type u} [category_theory.category C] {F : C ‚•§ C} : category_theory.endofunctor.algebra.functor_of_nat_trans (ùüô F) ‚âÖ ùü≠ (category_theory.endofunctor.algebra F)
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : C ‚•§ C
{L : first_order.language} {M : Type w} [L.Structure M] : complete_lattice (L.substructure M)
{R : Type u} [comm_semiring R] {S : Type v} [semiring S] [algebra R S] {p : polynomial S} (r : R) (hp : p ‚àà polynomial.lifts (algebra_map R S)) : r ‚Ä¢ p ‚àà polynomial.lifts (algebra_map R S)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C·µí·µñ ‚•§ D} (Œ± : F ‚ü∂ G) : G.right_op ‚ü∂ F.right_op
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (p : X = Y) : X ‚âÖ Y
{R : Type u_1} {k : Type u_2} {V1 : Type u_3} {P1 : Type u_4} {V2 : Type u_5} [ring k] [add_comm_group V1] [add_torsor V1 P1] [add_comm_group V2] [module k V1] [module k V2] [monoid R] [distrib_mul_action R V2] [smul_comm_class k R V2] : distrib_mul_action R (P1 ‚Üí·µÉ[k] V2)
(Œ± : Type u_1) : Type u_1
 : Type
{M : Type u_1} {B : Type u_3} [add_monoid M] [set_like B M] [add_submonoid_class B M] {S : B} {l : list M} (hl : ‚àÄ (x : M), x ‚àà l ‚Üí x ‚àà S) : l.sum ‚àà S
{C : Type u} [category_theory.category C] {X Y : C} (s : category_theory.limits.binary_cofan X Y) : (category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left} ‚ü∂ ((category_theory.functor.const (category_theory.discrete category_theory.limits.walking_pair)).obj s.X).obj {as := category_theory.limits.walking_pair.left}
(L : first_order.language) (M : Type w) [L.Structure M] : galois_insertion ‚áë(first_order.language.substructure.closure L) coe
(R' : Type u) (S' : Type v) [semiring R'] [has_scalar R' S'] : has_scalar (polynomial R') (R' ‚Üí S')
(Œì : Type u_1) [inhabited Œì] : Type u_1
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [semiring R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] [topological_space (bundle.total_space E)] (e e' : topological_vector_bundle.trivialization R F E) {b : B} (hb : b ‚àà e.to_fiber_bundle_trivialization.base_set ‚à© e'.to_fiber_bundle_trivialization.base_set) (y : F) : ‚áë(e.coord_change e' b) y = (‚áëe' (‚áë(e.to_fiber_bundle_trivialization.to_local_homeomorph.symm) (b, y))).snd
(l : linarith.linexp) : list ‚Ñï
 : function.surjective real.sinh
 : ‚ÑÇ ‚Üí*‚ÇÄ ‚Ñù
{Œ± : Type u_1} {M : Type u_5} [has_zero M] (s : finset Œ±) (f : Œ± ‚Üí M) (hf : ‚àÄ (a : Œ±), f a ‚â† 0 ‚Üí a ‚àà s) : Œ± ‚Üí‚ÇÄ M
(Œ± : Type u_4) [bornology Œ±] : Prop
 : category_theory.limits.has_limits_of_size AddMon
{C : Type u‚ÇÅ} [category_theory.category C] {P X Y Z : C} {fst : P ‚ü∂ X} {snd : P ‚ü∂ Y} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} (h : category_theory.is_pullback fst snd f g) [category_theory.limits.has_pullback f g] : P ‚âÖ category_theory.limits.pullback f g
{n : ‚Ñï} {Œ± : Type u} (a : array n Œ±) (v : Œ±) : array (n + 1) Œ±
{Œ± : Type u_1} [topological_space Œ±] [baire_space Œ±] {s : set Œ±} : s ‚àà residual Œ± ‚Üî ‚àÉ (t : set Œ±) (H : t ‚äÜ s), is_GŒ¥ t ‚àß dense t
(C : Type (u+1)) : Type (u+1)
(ic : tactic.instance_cache) (a : expr) : tactic (tactic.instance_cache √ó expr √ó expr)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) [category_theory.full L] [category_theory.faithful L] : category_theory.is_iso h.unit
{Œ± : Type u} [topological_space Œ±] {f : filter Œ±} {a : Œ±} : f ‚â§ nhds a ‚Üî ‚àÄ (s : set Œ±), a ‚àà s ‚Üí is_open s ‚Üí s ‚àà f
{X : Type u_1} [topological_space X] {A B : discrete_quotient X} (h : A ‚â§ B) : ‚Ü•A ‚Üí ‚Ü•B
{R : Type u_1} {Œ∑ : Type u_2} {Œπs : Œ∑ ‚Üí Type u_3} {Ms : Œ∑ ‚Üí Type u_4} [semiring R] [Œ† (i : Œ∑), add_comm_monoid (Ms i)] [Œ† (i : Œ∑), module R (Ms i)] [fintype Œ∑] (s : Œ† (j : Œ∑), basis (Œπs j) R (Ms j)) : basis (Œ£ (j : Œ∑), Œπs j) R (Œ† (j : Œ∑), Ms j)
(ic : tactic.instance_cache) (ea eb ec : expr) (a b c : ‚Ñö) : tactic (tactic.instance_cache √ó expr)
{R : Type u} {Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [topological_space M‚ÇÇ] (L‚ÇÅ : continuous_multilinear_map R M‚ÇÅ M‚ÇÇ) (v : Œ† (i : Œπ), M‚ÇÅ i) : M‚ÇÇ
{R : Type u} [comm_semiring R] {n : ‚Ñï} (hn : 0 < n) : function.injective ‚áë(polynomial.expand R n)
 : tactic.local_cache.internal.cache_scope
(Œ± : Type u_1) [measurable_space Œ±] : Type u_1
{Œ± : Type u} [comm_semiring Œ±] {p p' ps ps' : Œ±} : p = p' ‚Üí ps = ps' ‚Üí p * ps = p' * ps'
{Œ± : Type u_1} {n : Type u_4} [add_group n] {v : n ‚Üí Œ±} : (matrix.circulant v).is_symm ‚Üî ‚àÄ (i : n), v (-i) = v i
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {n : ‚Ñï} {f : ùïú ‚Üí F} {x : ùïú} {m : fin n ‚Üí ùïú} : ‚áë(iterated_fderiv ùïú n f x) m = finset.univ.prod (Œª (i : fin n), m i) ‚Ä¢ iterated_deriv n f x
{K : Type u_1} [field K] (A : valuation_subring K) (P : ideal ‚Ü•A) [P.is_prime] : valuation_subring K
{ùïú : Type u_1} {E : Type u_4} {G : Type u_8} [normed_group E] [normed_group G] [nondiscrete_normed_field ùïú] [normed_space ùïú E] {F : Type u_2} {H : Type u_3} [normed_group F] [normed_group H] [normed_space ùïú F] [normed_space ùïú G] [normed_space ùïú H] (e‚ÇÅ : E ‚âÉL[ùïú] F) (e‚ÇÇ : H ‚âÉL[ùïú] G) : (E ‚ÜíL[ùïú] H) ‚âÉL[ùïú] F ‚ÜíL[ùïú] G
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type w} [category_theory.category J] (F : J ‚•§ C) [category_theory.limits.preserves_limit F G] [category_theory.limits.has_limit F] [category_theory.limits.has_limit (F ‚ãô G)] : G.obj (category_theory.limits.limit F) ‚âÖ category_theory.limits.limit (F ‚ãô G)
{R : Type u} [comm_ring R] {Œπ : Type v} [fintype Œπ] (f : Œπ ‚Üí ideal R) (hf : ‚àÄ (i j : Œπ), i ‚â† j ‚Üí f i ‚äî f j = ‚ä§) : (R ‚ß∏ ‚®Ö (i : Œπ), f i) ‚âÉ+* Œ† (i : Œπ), R ‚ß∏ f i
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] (F : C ‚•§ D) [F.preserves_zero_morphisms] : Type (max u u‚ÇÇ v)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] {b : category_theory.limits.binary_bicone X Y} (hb : b.is_bilimit) : (hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.binary_biproduct.is_limit X Y)).inv = category_theory.limits.biprod.desc b.inl b.inr
(ùïú : Type u_8) (E : Type u_9) [semi_normed_ring ùïú] [add_monoid E] [has_scalar ùïú E] : Type u_9
{M : Type u_1} [has_add M] {c d : add_con M} : setoid.r = setoid.r ‚Üî c = d
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {X Y : category_theory.center C} (f : X ‚ü∂ Y) [category_theory.is_iso f.f] : X ‚âÖ Y
{R : Type u} {n : ‚Ñï} {M : fin n.succ ‚Üí Type v} {M‚ÇÇ : Type v‚ÇÇ} [semiring R] [Œ† (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : fin n.succ), module R (M i)] [module R M‚ÇÇ] (f : multilinear_map R M M‚ÇÇ) (m : Œ† (i : fin n), M i.succ) (c : R) (x : M 0) : ‚áëf (fin.cons (c ‚Ä¢ x) m) = c ‚Ä¢ ‚áëf (fin.cons x m)
{Œπ : Type u_1} {x : ‚Ñï} {s : Œπ ‚Üí ‚Ñï} {t : finset Œπ} : (‚àÄ (i : Œπ), i ‚àà t ‚Üí x.coprime (s i)) ‚Üí x.coprime (t.prod (Œª (i : Œπ), s i))
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [right_cancel_semigroup M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) : right_cancel_semigroup M‚ÇÅ
(Œ± : Type u_8) (Œ≤ : Type u_9) [complete_lattice Œ±] [complete_lattice Œ≤] : Type (max u_8 u_9)
(Œ± : Type u_3) [topological_space Œ±] : Prop
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [add_comm_monoid E] [module ùïú E] [topological_space E] (s : set E) (x : E) : Prop
{K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : ‚Ñï) : ‚Üën ‚â§ (a ^ n - 1) / (a - 1)
 : C(‚Ñù, ‚Ü•circle)
{L : first_order.language} {Œ± : Type u'} (c : L.constants) : L.term Œ±
{Œ± : Type u} {Œ≤ : Type v} [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] (c‚ÇÄ : omega_complete_partial_order.chain (Œ± ‚ÜíùíÑ Œ≤)) (c‚ÇÅ : omega_complete_partial_order.chain Œ±) (z : Œ≤) : (‚àÄ (i j : ‚Ñï), ‚áë(‚áëc‚ÇÄ i) (‚áëc‚ÇÅ j) ‚â§ z) ‚Üî ‚àÄ (i : ‚Ñï), ‚áë(‚áëc‚ÇÄ i) (‚áëc‚ÇÅ i) ‚â§ z
{Œ± : Type u_1} [preorder Œ±] {f : Œ± ‚Üí Œ±} (h : id ‚â§ f) (n : ‚Ñï) : id ‚â§ (f^[n])
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} {Œπ : Type u_5} [linear_ordered_field ùïú] [add_comm_group E] [linear_ordered_add_comm_group Œ≤] [module ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} {t : finset Œπ} {w : Œπ ‚Üí ùïú} {p : Œπ ‚Üí E} (h : concave_on ùïú s f) (hw‚ÇÄ : ‚àÄ (i : Œπ), i ‚àà t ‚Üí 0 ‚â§ w i) (hw‚ÇÅ : 0 < t.sum (Œª (i : Œπ), w i)) (hp : ‚àÄ (i : Œπ), i ‚àà t ‚Üí p i ‚àà s) : ‚àÉ (i : Œπ) (H : i ‚àà t), f (p i) ‚â§ f (t.center_mass w p)
{R : Type u} [comm_semiring R] {A : Type u_1} [ring A] [algebra R A] : has_distrib_neg (submodule R A)
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [add_right_cancel_semigroup M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) : add_right_cancel_semigroup M‚ÇÅ
(h : expr) : tactic expr_set
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] (F : J ‚•§ C) : Type (max u‚ÇÅ u‚ÇÉ v‚ÇÉ)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : D ‚âå C
(b : ‚Ñï) : ‚Ñï ‚Üí ‚Ñï
 : cc_state ‚Üí tactic expr
{m : Type u ‚Üí Type u_1} [monad m] {Œ± : Type u_2} {Œ≤ : Type u} (f : Œ± ‚Üí m Œ≤) {n : ‚Ñï} : vector Œ± n ‚Üí m (vector Œ≤ n)
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b : Œ±} : a ‚â§ b ‚Üí a - b ‚â§ 0
{ùïú : Type u_1} {V : Type u_2} {V‚ÇÇ : Type u_4} {P : Type u_8} {P‚ÇÇ : Type u_9} [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V P] [normed_add_torsor V‚ÇÇ P‚ÇÇ] {f : P ‚Üí·µÉ[ùïú] P‚ÇÇ} : is_open_map ‚áë(f.linear) ‚Üî is_open_map ‚áëf
{n : ‚Ñï} (Œ± : fin n ‚Üí Type u_1) : d_array n Œ± ‚âÉ Œ† (i : fin n), Œ± i
{Œπ : Type uŒπ} {R : Type u_1} {A : Type u_2} [decidable_eq Œπ] [add_monoid Œπ] [comm_semiring R] [semiring A] [algebra R A] : direct_sum.galgebra R (Œª (i : Œπ), A)
{C : Type u} [category_theory.category C] (J‚ÇÅ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : Prop
(f : Type u‚ÇÄ ‚Üí Type u‚ÇÅ) [equiv_functor f] {Œ± Œ≤ : Type u‚ÇÄ} (e : Œ± ‚âÉ Œ≤) : f Œ± ‚âÉ f Œ≤
{Œ± : Type u_4} {Œ≤ : Type u_5} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) : Type (max u_4 u_5)
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_products C] : category_theory.over.forget X ‚ä£ category_theory.star X
{K L : Type} [field K] [field L] [is_alg_closed K] [is_alg_closed L] [char_zero K] [char_zero L] (hK : cardinal.aleph_0 < cardinal.mk K) (hKL : cardinal.mk K = cardinal.mk L) : K ‚âÉ+* L
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C·µí·µñ ‚âå D·µí·µñ) : C ‚âå D
{R : Type u_1} [comm_ring R] {M : submonoid R} {S : Type u_2} [comm_ring S] [algebra R S] {R‚Çò : Type u_4} {S‚Çò : Type u_5} [comm_ring R‚Çò] [comm_ring S‚Çò] [algebra R R‚Çò] [is_localization M R‚Çò] [algebra S S‚Çò] [is_localization (algebra.algebra_map_submonoid S M) S‚Çò] {x : S} (p : polynomial R) (hp : ‚áë(polynomial.aeval x) p = 0) (hM : p.leading_coeff ‚àà M) : (is_localization.map S‚Çò (algebra_map R S) _).is_integral_elem (‚áë(algebra_map S S‚Çò) x)
{Œ± : Type u} [has_subset Œ±] [has_ssubset Œ±] [is_nonstrict_strict_order Œ± has_subset.subset has_ssubset.ssubset] {a b : Œ±} [is_antisymm Œ± has_subset.subset] (h : a ‚äÜ b) : a ‚äÇ b ‚à® a = b
{R : Type u} [semiring R] {M : Type u_1} [linear_ordered_cancel_add_comm_monoid M] [module R M] (S : submodule R M) : linear_ordered_cancel_add_comm_monoid ‚Ü•S
(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C] (X Y : C) [category_theory.limits.has_binary_product X Y] : X ‚®Ø Y ‚âÖ category_theory.limits.pullback (category_theory.limits.terminal.from X) (category_theory.limits.terminal.from Y)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.is_initial 0
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_le Œ±] (s : Œ± ‚Üí set Œ≤) (x : Œ±) : set Œ≤
(Œ± : Type u) (Œ≤ : Type v) [add_group Œ±] [add_action Œ± Œ≤] : (Œ£ (a : Œ±), ‚Ü•(add_action.fixed_by Œ± Œ≤ a)) ‚âÉ quotient (add_action.orbit_rel Œ± Œ≤) √ó Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_limits C] [category_theory.limits.has_colimits C] [category_theory.concrete_category C] [category_theory.reflects_isomorphisms (category_theory.forget C)] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] {X Y : algebraic_geometry.SheafedSpace C} (f : X ‚ü∂ Y) (hf : open_embedding ‚áë(f.base)) [H : ‚àÄ (x : ‚Ü•X), category_theory.is_iso (algebraic_geometry.PresheafedSpace.stalk_map f x)] : algebraic_geometry.SheafedSpace.is_open_immersion f
(V : Type u_1) (P : Type u_2) [semi_normed_group V] [add_torsor V P] : pseudo_metric_space P
{C : Type u} [category_theory.category C] [category_theory.concrete_category C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) (sf : Œ† (i : Œπ), ‚Ü•(F.obj (opposite.op (U i)))) (s : ‚Ü•(F.obj (opposite.op (supr U)))) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] : category_theory.full category_theory.yoneda
(X : Top·µí·µñ) (R : TopCommRing) : CommRing
(f : name ‚Üí option name) (replace_all trace : bool) (relevant : name_map ‚Ñï) (ignore reorder : name_map (list ‚Ñï)) (pre tgt_pre : name) : name ‚Üí tactic unit
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {s : set E} {f g : E ‚Üí F} (hf : cont_diff_on ùïú n f s) (hg : cont_diff_on ùïú n g s) : cont_diff_on ùïú n (Œª (x : E), f x + g x) s
(Œ± : Type u) (Œ≤ : Type v) [monoid Œ±] [mul_action Œ± Œ≤] (g : Œ±) : set Œ≤
{Œπ : Type u_1} {S : Type u_3} {R : Type u_4} [decidable_eq Œπ] [add_monoid Œπ] [comm_semiring S] [semiring R] [algebra S R] (A : Œπ ‚Üí submodule S R) [set_like.graded_monoid A] : direct_sum.galgebra S (Œª (i : Œπ), ‚Ü•(A i))
{n : ‚Ñï} {x y : fin (n + 1)} : x.succ_above = y.succ_above ‚Üî x = y
{Œ± : Type u} : Œ± ‚Üí ordnode Œ± ‚Üí Œ±
(T : Type u_1) : Type u_1
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop} [is_well_order Œ≤ s] [is_trans Œ≥ t] (f : initial_seg r s) (g : principal_seg s t) : principal_seg r t
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : bilin_form R M ‚Üí‚Çó[‚Ñï] M ‚Üí‚Çó[‚Ñï] M ‚Üí‚Çó[R] R
{ùïú : Type u_1} {M : Type u_2} [division_ring ùïú] [add_comm_monoid M] [topological_space M] [t1_space M] [module ùïú M] [has_continuous_const_smul ùïú M] (c : ùïú) : is_closed_map (Œª (x : M), c ‚Ä¢ x)
{Œ± : Type u} {Œ≤ : Type v} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} (hinf : f.liminf u = a) (hsup : f.limsup u = a) (h : filter.is_bounded_under has_le.le f u . "is_bounded_default") (h' : filter.is_bounded_under ge f u . "is_bounded_default") : filter.tendsto u f (nhds a)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) (s : set E) (x : E) : Prop
(R : Type u_1) (M : Type u_2) (N : Type u_3) [semiring R] [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : (M √ó N) ‚âÉ‚Çó[R] N √ó M
(n k : ‚Ñï) : Prop
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K‚ÇÅ K‚ÇÇ : submodule ùïú E) : K‚ÇÅ·óÆ ‚äì K‚ÇÇ·óÆ = (K‚ÇÅ ‚äî K‚ÇÇ)·óÆ
{Œ± : Type u_1} {ix : fin 1} (x : Œ±) : (x::·µ•vector.nil).nth ix = x
{Œ± : Type u} (s : set (set Œ±)) (i : (quotient.out (cardinal.aleph 1).ord).Œ±) : cardinal.mk ‚Ü•(measurable_space.generate_measurable_rec s i) ‚â§ linear_order.max (cardinal.mk ‚Ü•s) 2 ^ cardinal.aleph_0
{L : first_order.language} {Œ± : Type u'} {Œ≤ : Type v'} {n : ‚Ñï} (g : Œ± ‚Üí Œ≤ ‚äï fin n) {k : ‚Ñï} : L.bounded_formula Œ± k ‚Üí L.bounded_formula Œ≤ (n + k)
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {s : set A} {p : ‚Ü•(algebra.adjoin R s) ‚Üí Prop} (Hs : ‚àÄ (x : A) (h : x ‚àà s), p ‚ü®x, _‚ü©) (Halg : ‚àÄ (r : R), p (‚áë(algebra_map R ‚Ü•(algebra.adjoin R s)) r)) (Hadd : ‚àÄ (x y : ‚Ü•(algebra.adjoin R s)), p x ‚Üí p y ‚Üí p (x + y)) (Hmul : ‚àÄ (x y : ‚Ü•(algebra.adjoin R s)), p x ‚Üí p y ‚Üí p (x * y)) (x : ‚Ü•(algebra.adjoin R s)) : p x
(h : expr) (hs : list expr) : tactic bool
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (E : C ‚•§ D) [category_theory.is_equivalence E] [category_theory.limits.has_colimits_of_size D] : category_theory.limits.has_colimits_of_size C
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (Œ∏ : real.angle) : o.oangle x y = Œ∏ ‚Üî ‚àÉ (r : ‚Ñù), 0 < r ‚àß y = r ‚Ä¢ ‚áë(o.rotation Œ∏) x
{R : Type u} [ring R] {J : Type v} (f : J ‚Üí Module R) : category_theory.limits.limit_cone (category_theory.discrete.functor f)
(Œ± : Type u) [preorder Œ±] : Type u
{R : Type u} [ring R] {X‚ÇÅ X‚ÇÇ : Type v} [add_comm_group X‚ÇÅ] [module R X‚ÇÅ] [add_comm_group X‚ÇÇ] [module R X‚ÇÇ] : (X‚ÇÅ ‚Üí‚Çó[R] X‚ÇÇ) ‚Üí (Module.of R X‚ÇÅ ‚ü∂ Module.of R X‚ÇÇ)
{f f' : ‚Ñù ‚Üí ‚Ñù} {a b l : ‚Ñù} (hab : a < b) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds l)) (hfb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds l)) (hff' : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí has_deriv_at f (f' x) x) : ‚àÉ (c : ‚Ñù) (H : c ‚àà set.Ioo a b), f' c = 0
{Œ± : Type u_2} [add_zero_class Œ±] : Œ± ‚Üí+ filter Œ±
{a b c : ‚Ñ§} (h : fermat_42 a b c) : ‚àÉ (a0 b0 c0 : ‚Ñ§), fermat_42.minimal a0 b0 c0 ‚àß a0 % 2 = 1
 : measure_theory.measure_space ‚ÑÇ
{G : Type u_1} [add_group G] (H : add_subgroup G) : has_sub ‚Ü•H
{R : Type u_1} [rack R] {G : Type u_2} [group G] (f : shelf_hom R (quandle.conj G)) {a b : rack.pre_envel_group R} : rack.pre_envel_group_rel' R a b ‚Üí rack.to_envel_group.map_aux f a = rack.to_envel_group.map_aux f b
(R : Type u_1) (B : Type u_3) (F : Type u_4) [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] (e : local_equiv (B √ó F) (B √ó F)) : Prop
 : (user_attribute simp_lemmas)
{Œ± : Type u_1} [is_empty Œ±] : fintype.card Œ± = 0
(Œ± : Type u) : Type u
{n : ‚Ñï} (i : fin2 n) (v : typevec n) : Type u
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) : category_theory.monad.comparison h ‚ãô h.to_monad.forget ‚âÖ R
{Œ± : Type u_1} [has_lt Œ±] : has_lt (finset.colex Œ±)
{J : Type v} {C : Type u} [category_theory.category C] (B : C) (F : category_theory.discrete J ‚•§ category_theory.over B) : category_theory.over.construct_products.cones_equiv_inverse B F ‚ãô category_theory.over.construct_products.cones_equiv_functor B F ‚âÖ ùü≠ (category_theory.limits.cone F)
(G : Type u_1) [has_neg G] [measurable_space G] : Prop
(R : Type u_1) (S : Type u_2) (A : Type u_4) [semiring A] [comm_semiring S] [algebra S A] [comm_semiring R] [algebra R S] : algebra R (restrict_scalars R S A)
{Œ± : Type u_1} (g : generalized_continued_fraction Œ±) : seq Œ±
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) [decidable_eq Œπ] (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) (i : Œπ) : ‚áë((has_insert.insert i s).weighted_vsub_of_point p (p i)) w = ‚áë(s.weighted_vsub_of_point p (p i)) w
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) : Type (max u‚ÇÅ v‚ÇÅ)
{Œ± : Type u_1} {m : multiset Œ±} {p : Œ± ‚Üí Prop} [hp : Œ† (a : Œ±), decidable (p a)] : decidable (‚àÄ (a : Œ±), a ‚àà m ‚Üí p a)
{R : Type u_1} [comm_semiring R] {m : Type u_3} {n : Type u_4} [fintype n] [fintype m] [decidable_eq n] : matrix.to_lin (pi.basis_fun R n) (pi.basis_fun R m) = matrix.to_lin'
{m : Type u ‚Üí Type u} [monad m] [alternative m] {Œ± Œ≤ : Type u} (p : Œ± ‚Üí m Œ≤) : tactic.mllist m Œ± ‚Üí tactic.mllist m Œ±
{X : Top} (F : Top.presheaf (Type v) X) : Top.local_predicate (Œª (x : ‚Ü•X), F.stalk x)
{n : ‚Ñ§} : odd n ‚Üí odd n.nat_abs
(cl : name) : tactic (list name)
{S : Type u_2} [comm_ring S] {K : Type u_4} [field K] [algebra K S] [nontrivial S] (pb : power_basis K S) : ‚áë(algebra.trace K S) pb.gen = -(minpoly K pb.gen).next_coeff
{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype.card (class_group R K) = 1
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : free_monoid Œ± ‚Üí* free_monoid Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} : ‚Ñï ‚Üí list Œ± ‚Üí (list Œ± ‚Üí Œ≤) ‚Üí list Œ≤ ‚Üí list Œ≤
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} (s : finset Œπ) (t : Œ† (i : Œπ), finset (Œ± i)) : finset (Œ£ (i : Œπ), Œ± i)
 : Type
{K : Type u_1} (v : K) [linear_ordered_field K] [floor_ring K] : continued_fraction K
(z : ‚Ñ§) : ‚Ñ§
(R : Type u_1) [ring R] (M : Type u_2) [add_comm_group M] [module R M] : Prop
{x y : pSet} : x.equiv y ‚Üî x.to_set = y.to_set
(n : ‚Ñï) : bitvec n
{Œ± : Type u_1} {s : finset Œ±} {f : Œ± ‚Üí ennreal} : s.sum (Œª (x : Œ±), f x) = ‚ä§ ‚Üî ‚àÉ (a : Œ±) (H : a ‚àà s), f a = ‚ä§
(Œ± Œ≤ : cardinal) : cardinal
{G : Type w} [group G] [topological_space G] [topological_group G] (x : G) : G ‚âÉ‚Çú G
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] : category_theory.lax_braided_functor C C
{Œ± : Type u_1} [pseudo_emetric_space Œ±] : pseudo_emetric_space Œ±·µê·µí·µñ
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_5} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (s : set Œ±) (t : set Œ≤) : set Œ≥
{Œ± : Type u_1} (e : Œ± ‚âÉ ‚Ñï) : denumerable Œ±
{Œ± : Sort u_1} (f : Œ† (x : pgame), x.numeric ‚Üí Œ±) (H : ‚àÄ {x y : pgame} (hx : x.numeric) (hy : y.numeric), x.equiv y ‚Üí f x hx = f y hy) : surreal ‚Üí Œ±
{C : Type u} [category_theory.category C] {F : category_theory.limits.walking_parallel_pair ‚•§ C} (t : category_theory.limits.cocone F) : category_theory.limits.cofork (F.map category_theory.limits.walking_parallel_pair_hom.left) (F.map category_theory.limits.walking_parallel_pair_hom.right)
{M : Type u_1} [comm_monoid M] {S : submonoid M} (x : M) (y : ‚Ü•S) : localization S
{Œ± : Type u} {Œ≤ : Type v} [linear_ordered_field Œ±] [topological_space Œ±] [order_topology Œ±] {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±} {C : Œ±} (hC : C < 0) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_top) : filter.tendsto (Œª (x : Œ≤), f x * g x) l filter.at_bot
{Œ± : Type u} (a : Œ±) : wseq Œ±
{R : Type u_1} [monoid R] (a : RÀ£) : is_regular ‚Üëa
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {n : Type w} (B : bilin_form R M) (v : n ‚Üí M) : Prop
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [add_comm_monoid Œ±] [add_comm_monoid Œ≤] [add_comm_monoid Œ≥] {A : set Œ±} {B : set Œ≤} {n : ‚Ñï} (f : B ‚Üí+[n] Œ≥) (g : A ‚Üí+[n] Œ≤) (hAB : set.maps_to ‚áëg A B) : A ‚Üí+[n] Œ≥
{Œ± : Type u_1} [has_lt Œ±] {a b : Œ±} [densely_ordered Œ±] : ¬¨a ‚ãñ b
 : expr ‚Üí option ‚Ñï
(G : Type u_1) [measurable_space G] [has_involutive_neg G] [has_measurable_neg G] : G ‚âÉ·µê G
{C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ‚Ñï} {i : fin (n + 1)} : X.Œ¥ (‚áëfin.cast_succ i) ‚â´ X.œÉ i = ùüô (X.obj (simplex_category.mk n))
(args : list expr) : tactic.ring_exp.ring_exp_m expr
(R : Type u) {S : Type v} {A : Type w} {B : Type u‚ÇÅ} [comm_semiring R] [comm_semiring S] [semiring A] [semiring B] [algebra R S] [algebra S A] [algebra R A] [algebra S B] [algebra R B] [is_scalar_tower R S A] [is_scalar_tower R S B] (U : subalgebra S A) (f : ‚Ü•U ‚Üí‚Çê[S] B) : ‚Ü•(subalgebra.restrict_scalars R U) ‚Üí‚Çê[R] B
(Œ± : expr) : ‚Ñö ‚Üí tactic expr
{m : Type u ‚Üí Type u} [monad m] {Œ± : Type u} : tactic.mllist m Œ± ‚Üí tactic.mllist m Œ± ‚Üí tactic.mllist m Œ±
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f : M ‚Üí+ N) (S : add_submonoid M) : add_submonoid N
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_mono f] : category_theory.limits.fork (ùüô Y) (category_theory.retraction f ‚â´ f)
(R : Type u) {S : Type v} {A : Type w} [comm_semiring R] [comm_semiring S] [semiring A] [algebra R S] [algebra S A] [algebra R A] [is_scalar_tower R S A] (U : subalgebra S A) : subalgebra R A
{L : first_order.language} (r : L.relations 2) : L.sentence
(C : Type u) : category_theory.free_monoidal_category.tensor_func C ‚âÖ category_theory.free_monoidal_category.normalize' C
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí. Œ≤) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) : category_theory.limits.cone (category_theory.functor.empty C)
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] [Œ† (i : Œπ), decidable_eq (M i)] [decidable_eq Œπ] : free_product M ‚âÉ free_product.word M
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] (P Q R : C) : P ‚®ø Q ‚®ø R ‚âÖ P ‚®ø (Q ‚®ø R)
{C : Type u} [category_theory.category C] {X Y : C} (hX : category_theory.limits.is_zero X) (hY : category_theory.limits.is_terminal Y) : X ‚âÖ Y
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] : (euclidean_geometry.orthogonal_projection s).linear = ‚Üë(orthogonal_projection s.direction)
{Œ± : Type u_1} [pseudo_metric_space Œ±] [proper_space Œ±] (x : Œ±) (r : ‚Ñù) : is_compact (metric.sphere x r)
{R : Type u_1} {S : Type u_2} [comm_semiring R] [semiring S] (i : R ‚Üí+* S) (h : ‚àÄ (c : R) (x : S), ‚áëi c * x = x * ‚áëi c) : algebra R S
(e : expr) : tactic (list (name √ó expr))
{M : Type u_1} [has_add M] {c d : add_con M} : setoid.r = setoid.r ‚äì setoid.r
(Œ± : Type u_3) {Œ≤ : Type u_4} [has_sup Œ±] [semilattice_sup Œ≤] (b : Œ≤) : sup_hom Œ± Œ≤
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) : Prop
{R : Type u_1} [semiring R] (n : ‚Ñ§) : laurent_polynomial R
{R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type u_3} [add_comm_group M] [module R M] [module.finite R M] [no_zero_smul_divisors R M] : Œ£ (n : ‚Ñï), basis (fin n) R M
 : num ‚Üí list bool
{M : Type u_1} [group M] (c : con M) (n : ‚Ñ§) {w x : M} : ‚áëc w x ‚Üí ‚áëc (w ^ n) (x ^ n)
{J : Type v} {C : Type u} [category_theory.category C] {F : category_theory.limits.walking_parallel_family J ‚•§ C} (t : category_theory.limits.trident (Œª (j : J), F.map (category_theory.limits.walking_parallel_family.hom.line j))) : category_theory.limits.cone F
 : Type (u+1)
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [no_max_order Œ±] [densely_ordered Œ±] {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (set.Ioi a) ‚Üî ‚àÉ (u : Œ±) (H : u ‚àà set.Ioi a), set.Ioc a u ‚äÜ s
{Œ± : Type u_1} {s : finset Œ±} {a : Œ±} [decidable_eq Œ±] : (has_insert.insert a s).card = ite (a ‚àà s) s.card (s.card + 1)
{Œ± : Type u_3} (s : set Œ±) : Type u_3
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) : category_theory.limits.is_colimit (CommRing.colimits.colimit_cocone F)
(R : Type u) [comm_ring R] : Type (max u (v+1))
(R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (v : M) (h : v ‚â† 0) : -ray_of_ne_zero R v h = ray_of_ne_zero R (-v) _
{K : Type u} [field K] (s : subfield K) {x y : K} : x ‚àà s ‚Üí y ‚àà s ‚Üí x - y ‚àà s
{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ‚â† 0) : char.quadratic_char F a = 1 ‚Üî is_square a
{Œπ : Type u_1} {f : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), has_add (f i)] (C : Œ† (i : Œπ), add_con (f i)) : add_con (Œ† (i : Œπ), f i)
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] {F G : C ‚•§ D} (Œ± : F ‚ü∂ G) : G.map_presheaf ‚ü∂ F.map_presheaf
{R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a) : is_add_regular a
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {f‚ÇÄ f‚ÇÅ g‚ÇÄ g‚ÇÅ : C(X, Y)} (F : f‚ÇÄ.homotopy f‚ÇÅ) (h‚ÇÄ : f‚ÇÄ = g‚ÇÄ) (h‚ÇÅ : f‚ÇÅ = g‚ÇÅ) : g‚ÇÄ.homotopy g‚ÇÅ
{ùíú : Type u_1} [category_theory.category ùíú] {A B C : ùíú} {f : A ‚ü∂ B} {g : B ‚ü∂ C} [category_theory.abelian ùíú] (h : category_theory.short_exact f g) (i : A ‚äû C ‚ü∂ B) (h1 : category_theory.limits.biprod.inl ‚â´ i = f) (h2 : i ‚â´ g = category_theory.limits.biprod.snd) : category_theory.splitting f g
{Œ± : Type u_1} {Œ≤ : Type u_2} (l‚ÇÅ : list Œ±) (l‚ÇÇ : list Œ≤) : list (Œ± √ó Œ≤)
{Œ± : Type} : widget.html Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) (hf : function.right_inverse g f) : quotient (setoid.ker f) ‚âÉ Œ≤
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : wseq Œ± ‚Üí wseq Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} {m : measurable_space Œ±} [topological_space Œ≤] [topological_space.metrizable_space Œ≤] [mŒ≤ : measurable_space Œ≤] [borel_space Œ≤] [preorder Œπ] (u : Œπ ‚Üí Œ± ‚Üí Œ≤) (hum : ‚àÄ (i : Œπ), measure_theory.strongly_measurable (u i)) : measure_theory.filtration Œπ m
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (X Y Y' Z : C) [category_theory.exact_pairing Y Y'] : (Y' ‚äó X ‚ü∂ Z) ‚âÉ (X ‚ü∂ Y ‚äó Z)
{C : Type u‚ÇÅ} [category_theory.category C] {P Q R S : C} {f : P ‚ü∂ Q} {g : P ‚ü∂ R} {h : Q ‚ü∂ S} {k : R ‚ü∂ S} [gr : category_theory.regular_epi g] (comm : f ‚â´ h = g ‚â´ k) (t : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk h k comm)) : category_theory.regular_epi h
(L : list ‚Ñï) : L.head ‚â§ L.sum
 : TopCommRing ‚•§ Top·µí·µñ ‚•§ CommRing
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [preorder Œ±] [preorder Œ≤] [topological_space Œ±] [topological_space Œ≤] : Type (max u_6 u_7 u_8)
{J : Type u_1} [category_theory.category J] {C : Type u_3} [category_theory.category C] [category_theory.limits.has_terminal C] : category_theory.limits.limit ((category_theory.functor.const J).obj (‚ä§_ C)) ‚âÖ ‚ä§_ C
{Œ± : Type u_1} {M : Type u_2} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (s : set Œ±) : (Œ± ‚Üí‚ÇÄ M) ‚Üí‚Çó[R] ‚Ü•s ‚Üí‚ÇÄ M
 : tactic.simp_arg_type ‚Üí option pexpr
{n m : ‚Ñï} {G : fin2 n ‚Üí typevec m ‚Üí Type u} [fG : Œ† (i : fin2 n), mvfunctor (G i)] {Œ± Œ≤ : typevec m} (f : Œ±.arrow Œ≤) : typevec.arrow (Œª (i : fin2 n), G i Œ±) (Œª (i : fin2 n), G i Œ≤)
(major_premise : expr) (num_params : ‚Ñï) (generate_induction_hyps : bool) : tactic (expr √ó ‚Ñï √ó list name √ó ‚Ñï)
(Œ± : Sort u) [is_empty Œ±] : Œ± ‚âÉ empty
{G : Type u_1} [group G] {Œ± : Type u_4} [mul_action G Œ±] (S : subgroup G) : mul_action ‚Ü•S Œ±
{Œ± : Type u} [e : emetric_space Œ±] (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù) (edist_ne_top : ‚àÄ (x y : Œ±), has_edist.edist x y ‚â† ‚ä§) (h : ‚àÄ (x y : Œ±), dist x y = (has_edist.edist x y).to_real) : metric_space Œ±
{M : Type uM} {N : Type uN} {P : Type uP} [add_zero_class M] [add_comm_monoid N] [add_comm_monoid P] : (N ‚Üí+ P) ‚Üí+ (M ‚Üí+ N) ‚Üí+ M ‚Üí+ P
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] (v : picard_lindelof E) : ‚Ñù
{s : set ‚Ñï} [infinite ‚Ü•s] [decidable_pred (Œª (_x : ‚Ñï), _x ‚àà s)] (x : ‚Ü•s) : ‚Ü•s
(hs : list expr) : tactic (list expr)
{M : Type u_1} [monoid M] {Œπ : Type u_2} [hŒπ : nonempty Œπ] {s : Œπ ‚Üí set M} (hs : ‚àÄ (i : Œπ), is_submonoid (s i)) (directed : ‚àÄ (i j : Œπ), ‚àÉ (k : Œπ), s i ‚äÜ s k ‚àß s j ‚äÜ s k) : is_submonoid (‚ãÉ (i : Œπ), s i)
 : expr ‚Üí expr
{M : Type u_1} {N : Type u_2} (A : Type u_4) [monoid M] [monoid A] [mul_distrib_mul_action M A] [monoid N] (f : N ‚Üí* M) : mul_distrib_mul_action N A
(C : Type u) [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] : category_theory.triangulated.triangle C ‚•§ category_theory.triangulated.triangle C
{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : category_theory.over.pullback (f ‚â´ g) ‚âÖ category_theory.over.pullback g ‚ãô category_theory.over.pullback f
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) (i j k : D.to_glue_data.J) (U : topological_space.opens ‚Ü•((D.to_glue_data.V (i, j)).carrier)) : _.inv_app U ‚â´ (D.to_glue_data.f i k).c.app (opposite.op (_.open_functor.obj U)) = category_theory.limits.pullback.fst.c.app (opposite.op U) ‚â´ _.inv_app (opposite.unop ((topological_space.opens.map category_theory.limits.pullback.fst.base).op.obj (opposite.op U))) ‚â´ (D.to_glue_data.V (i, k)).presheaf.map (category_theory.eq_to_hom _)
 : ordinal ‚Üí cardinal
{M : Type u_1} [add_zero_class M] {s : set M} {S : add_submonoid M} : add_submonoid.closure s ‚â§ S ‚Üî s ‚äÜ ‚ÜëS
{X Y : Type u} [has_add X] [has_add Y] (f : add_hom X Y) : AddMagma.of X ‚ü∂ AddMagma.of Y
{M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_3} [mul_zero_one_class M‚ÇÄ] [has_mul M‚ÇÄ'] [has_zero M‚ÇÄ'] [has_one M‚ÇÄ'] (f : M‚ÇÄ ‚Üí M‚ÇÄ') (hf : function.surjective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ‚àÄ (a b : M‚ÇÄ), f (a * b) = f a * f b) : mul_zero_one_class M‚ÇÄ'
{n m : ‚Ñï} (i : fin (m * n)) : fin m
(n : ‚Ñï) : ‚Ñï+
{S : Type u_1} [ordered_semiring S] {R : Type u_2} [semiring R] (abv : absolute_value R S) : is_absolute_value ‚áëabv
(A : Type u_4) [comm_ring A] [is_domain A] (K : Type u_1) [field K] [algebra A K] [is_fraction_ring A K] : fraction_ring A ‚âÉ‚Çê[A] K
(ùïú : Type u) {Œπ : Type v} (E : Œπ ‚Üí Type wE) (G : Type wG) (G' : Type wG') [decidable_eq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] : continuous_multilinear_map ùïú E G √ó continuous_multilinear_map ùïú E G' ‚âÉ‚Çó·µ¢[ùïú] continuous_multilinear_map ùïú E (G √ó G')
{R‚ÇÅ : Type u_4} [comm_ring R‚ÇÅ] {n : Type u_5} (i j : n) : quadratic_form R‚ÇÅ (n ‚Üí R‚ÇÅ)
 : lean.parser pos
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {x y : M} (e : M ‚âÉ‚Çó[R] N) : same_ray R (‚áëe x) (‚áëe y) ‚Üî same_ray R x y
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] {X Y : C} [category_theory.limits.preserves_colimit (category_theory.limits.pair X Y) F] : category_theory.limits.preserves_binary_biproduct X Y F
{Œπ : Type u_1} {M : Type u_4} [ordered_add_comm_monoid M] {s : finset Œπ} {f : Œπ ‚Üí with_top M} (h : ‚àÄ (i : Œπ), i ‚àà s ‚Üí f i ‚â† ‚ä§) : s.sum (Œª (i : Œπ), f i) < ‚ä§
{l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {Œ± : Type u_12} (M : matrix (n ‚äï o) (l ‚äï m) Œ±) : matrix o l Œ±
{Œ± : Type u_1} [conditionally_complete_linear_order Œ±] {s : set Œ±} {b : Œ±} (hs : s.nonempty) (hb : has_Inf.Inf s < b) : ‚àÉ (a : Œ±) (H : a ‚àà s), a < b
{Œ± : Type u_1} [emetric_space Œ±] {K : nnreal} {f : Œ± ‚Üí Œ±} (hf : contracting_with K f) {s : set Œ±} (hs : set.maps_to f s s) : contracting_with K (set.maps_to.restrict f s s hs)
{Œ± : Type u} : ordnode Œ± ‚Üí ‚Ñï ‚Üí ordnode Œ±
{J : Type u_1} {C : Type u_2} [category_theory.category J] [category_theory.category C] (P : category_theory.idempotents.karoubi (J ‚•§ C)) : J ‚•§ category_theory.idempotents.karoubi C
{E : Type u_2} [add_comm_group E] [module ‚Ñù E] [topological_space E] [topological_add_group E] [has_continuous_smul ‚Ñù E] {s : set E} (hs : s.finite) : is_compact (‚áë(convex_hull ‚Ñù) s)
 : expr ‚Üí tactic expr
{Œ± : Type u} {Œ≤ : Type v} [has_mul Œ±] [mul_one_class Œ≤] : (Œ± ‚Üí‚Çô* Œ≤) ‚âÉ (with_one Œ± ‚Üí* Œ≤)
(C : Type u‚ÇÅ) [category_theory.category C] : C·µí·µñ √ó (C·µí·µñ ‚•§ Type v‚ÇÅ) ‚•§ Type (max u‚ÇÅ v‚ÇÅ)
 : tactic unit
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {ca cb : E} {la lb : filter ‚Ñù} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set ‚Ñù} [interval_integral.FTC_filter a (nhds_within a s) la] [interval_integral.FTC_filter b (nhds_within b t) lb] (hmeas_a : strongly_measurable_at_filter f la measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f lb measure_theory.measure_space.volume) (ha : filter.tendsto f (la ‚äì measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (lb ‚äì measure_theory.measure_space.volume.ae) (nhds cb)) : has_fderiv_within_at (Œª (p : ‚Ñù √ó ‚Ñù), ‚à´ (x : ‚Ñù) in p.fst..p.snd, f x) ((continuous_linear_map.snd ‚Ñù ‚Ñù ‚Ñù).smul_right cb - (continuous_linear_map.fst ‚Ñù ‚Ñù ‚Ñù).smul_right ca) (s √óÀ¢ t) (a, b)
{Œ± : Type u_1} (s : multiset Œ±) : multiset (multiset Œ±)
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} {Œ∫ : Type u_1} [Œ† (i : Œπ), has_zero (Œ≤ i)] (h : Œ∫ ‚Üí Œπ) {h' : Œπ ‚Üí Œ∫} (hh' : function.left_inverse h' h) : (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚Üí (Œ†‚ÇÄ (k : Œ∫), Œ≤ (h k))
(ùïú : Type u_1) (E : Type u_2) [is_R_or_C ùïú] [inner_product_space ùïú E] [finite_dimensional ùïú E] : basis ‚Ü•(orthonormal_basis_index ùïú E) ùïú E
{X : Top} (F : Top.presheaf (Type v) X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : Top.presheaf.sheaf_condition_equalizer_products.pi_opens F U ‚âÖ Œ† (i : Œπ), F.obj (opposite.op (U i))
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} {Œ¥ : Type u_2} (r : Œ± ‚Üí Œ≥ ‚Üí Prop) (s : Œ≤ ‚Üí Œ¥ ‚Üí Prop) : Œ± ‚äï Œ≤ ‚Üí Œ≥ ‚äï Œ¥ ‚Üí Prop
{n : ‚Ñï} {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (b : Œ≤) (v : vector Œ± n) (i : fin n) : (vector.scanl f b v).nth i.succ = f ((vector.scanl f b v).nth (‚áëfin.cast_succ i)) (v.nth i)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [semi_normed_group E] [normed_space ùïú E] : uniform_space.to_topological_space ‚â§ weak_dual.topological_space ùïú E
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} (hs : unique_diff_on ùïú s) : cont_diff_on ùïú ‚ä§ f s ‚Üî differentiable_on ùïú f s ‚àß cont_diff_on ùïú ‚ä§ (Œª (y : E), fderiv_within ùïú f s y) s
{Œ± : Type u_2} {Œ≤ : Type u_3} {hŒ± : ordered_comm_group Œ±} {hŒ≤ : ordered_comm_group Œ≤} (f : Œ± ‚Üí Œ≤) (hf : monotone f) (map_mul : ‚àÄ (a b : Œ±), f (a * b) = f a * f b) : Œ± ‚Üí*o Œ≤
{R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type u_3} [add_comm_group M] [module R M] {Œπ : Type u_1} [fintype Œπ] {N O : submodule R M} (hNO : N ‚â§ O) (b : basis Œπ R ‚Ü•O) : Œ£ (n : ‚Ñï), basis (fin n) R ‚Ü•N
{Œ± : Type u_1} [decidable_eq Œ±] (s t : multiset Œ±) : multiset Œ±
{Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [ring Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_ring_hom f) : f 0 = 0
{G : Type u_1} [group G] {N : Type u_3} [group N] {f g : G ‚Üí* N} {s : set G} (h : set.eq_on ‚áëf ‚áëg s) : set.eq_on ‚áëf ‚áëg ‚Üë(subgroup.closure s)
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] {M' : Type u_2} [add_comm_monoid M'] [module R M'] {O : submodule R M} (œï : ‚Ü•O ‚Üí‚Çó[R] M') (N : submodule R M) : submodule R M'
{R : Type u} {S : Type v} [ring R] [ring S] (f : R ‚Üí+* S) (hf : function.surjective ‚áëf) : ideal S ‚âÉo {p // ideal.comap f ‚ä• ‚â§ p}
(n : ‚Ñï) : ‚Ñ§ ‚ß∏ ideal.span {‚Üën} ‚âÉ+* zmod n
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_pullbacks C] (f : X ‚ü∂ Y) : (category_theory.mono_over.pullback f).obj ‚ä§ ‚âÖ ‚ä§
(R : Type u_1) (a b : R) : Type u_1
{R : Type u} [comm_semiring R] {E : Type u_1} {F : Type u_2} [division_ring E] [semiring F] [nontrivial F] [algebra R E] [algebra R F] (f : E ‚Üí‚Çê[R] F) : E ‚âÉ‚Çê[R] ‚Ü•(f.range)
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.limits.is_image (category_theory.limits.mono_factorisation.self f)
(n : ‚Ñï) : n.partition
{Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] {b : Œ±} [nonempty Œπ] {f : Œπ ‚Üí Œ±} (h‚ÇÅ : ‚àÄ (i : Œπ), b ‚â§ f i) (h‚ÇÇ : ‚àÄ (w : Œ±), b < w ‚Üí (‚àÉ (i : Œπ), f i < w)) : (‚®Ö (i : Œπ), f i) = b
(Œ± : Type u) {Œ≤ : Type v} [group Œ±] [mul_action Œ± Œ≤] (b : Œ≤) [fintype Œ±] [fintype ‚Ü•(mul_action.orbit Œ± b)] [fintype ‚Ü•(mul_action.stabilizer Œ± b)] : fintype.card ‚Ü•(mul_action.orbit Œ± b) * fintype.card ‚Ü•(mul_action.stabilizer Œ± b) = fintype.card Œ±
{Œπ : Sort u_1} [nonempty Œπ] {f : Œπ ‚Üí ennreal} {x : ennreal} (h : x ‚â† ‚ä§) : x * infi f = ‚®Ö (i : Œπ), x * f i
{Œ± : Type u} {m : ‚Ñï} (x : Œ±) (u : fin m.succ ‚Üí Œ±) : matrix.vec_cons x u 1 = matrix.vec_head u
{Œ± : Type u_1} {Œπ : Type u_3} [distrib_lattice Œ±] [order_bot Œ±] {s : finset Œπ} {f : Œπ ‚Üí Œ±} : ‚Üës.pairwise_disjoint f ‚Üí s.sup_indep f
{Œ± : Type u_1} {Œ≤ : Type u_2} [nontrivial Œ±] {f : Œ± ‚Üí Œ≤} (hf : function.injective f) : nontrivial Œ≤
{y : ‚Ñù} (hy : 0 < y) : filter.tendsto (Œª (x : ‚Ñù), x ^ -y) filter.at_top (nhds 0)
{G : Type u_1} {P : Type u_2} [add_comm_group G] [add_torsor G P] (p1 p2 p3 : P) : p3 -·µ• p2 - (p3 -·µ• p1) = p1 -·µ• p2
{G : Type u} [group G] [fintype G] {N : subgroup G} [N.normal] (hN : (fintype.card ‚Ü•N).coprime N.index) : ‚àÉ (H : subgroup G), H.is_complement' N
{f : ‚Ñù ‚Üí ‚Ñù} (hf : differentiable ‚Ñù f) (hf' : ‚àÄ (x : ‚Ñù), 0 ‚â§ deriv f x) : monotone f
(Œ± : Type u_6) (Œ≤ : Type u_7) [bornology Œ±] [bornology Œ≤] : Type (max u_6 u_7)
{Œ± : Type u_1} [has_lt Œ±] [decidable_eq Œ±] (A B : finset Œ±) : (A  B).to_colex < (B  A).to_colex ‚Üî A.to_colex < B.to_colex
(Œ± : Sort u) : Sort (max (imax (v+1) u) (v+2))
(ic : tactic.instance_cache) : expr ‚Üí tactic (tactic.instance_cache √ó expr)
(Œ± : Type u_1) [preorder Œ±] : simple_graph Œ±
(R : Type u_1) (A : Type u_2) (B : Type u_3) [comm_semiring R] [semiring B] [algebra R B] : B ‚Üí‚Çê[R] A ‚Üí B
(r n : ‚Ñï) : n.choose r ‚â§ n.choose (n / 2)
 : name ‚Üí string ‚Üí tactic unit
(n : name) (s e : expr) : expr
 : category_theory.Cat ‚•§ category_theory.Quiv
{R : Type u} [comm_semiring R] [nontrivial R] (h : ‚àÄ (a b : R), a ‚àà nonunits R ‚Üí b ‚àà nonunits R ‚Üí a + b ‚àà nonunits R) : local_ring R
(Œ± : Type u_1) : empty √ó Œ± ‚âÉ empty
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) {p : P} {r : ‚Ñù} (hr : ‚àÄ (i : fin (n + 1)), has_dist.dist (s.points i) p = r) : ‚Üë(‚áë(s.orthogonal_projection_span) p) = s.circumcenter
{C : Type u_1} [category_theory.category C] : category_theory.category (category_theory.idempotents.karoubi C)
(M : Type u_5) (N : Type u_6) [has_mul M] [has_mul N] : M √ó N ‚Üí‚Çô* M
{Œ± : Type u} [add_zero_class Œ±] : is_add_monoid_hom id
{M : Type u_1} [comm_group M] (f : ‚Ñï ‚Üí M) (n : ‚Ñï) : (finset.range n).prod (Œª (i : ‚Ñï), f (i + 1) * (f i)‚Åª¬π) = f n * (f 0)‚Åª¬π
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ‚ü∂ Q) : category_theory.limits.strong_epi_mono_factorisation f
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [linear_order Œ≤] (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) (h : ‚àÄ (a : Œ±) (b : Œ≤), cmp a (g b) = cmp (f a) b) : Œ± ‚âÉo Œ≤
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) : L ‚Üí‚Çó‚ÅÖR‚ÅÜ module.End R (M ‚ß∏ N)
(Œ± : Sort u) (Œ≤ : Œ± ‚Üí Sort v) : Sort (imax u v)
{C : Type u} [category_theory.category C] {X Y : C} (hX : category_theory.limits.is_zero X) (hY : category_theory.limits.is_initial Y) : X ‚âÖ Y
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (e : local_equiv Œ± Œ≤) (e' : local_equiv Œ≤ Œ≥) (h : e.target = e'.source) : local_equiv Œ± Œ≥
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : cardinal
{f : ‚Ñï ‚Üí ‚Ñï} (hf : function.injective f) : filter.tendsto f filter.at_top filter.at_top
{C : Type u} [category_theory.category C] (P : C·µí·µñ ‚•§ Type v) [P.representable] : category_theory.presieve.is_sheaf (category_theory.sheaf.canonical_topology C) P
{M : Type u_2} [add_comm_group M] {A : Type u_5} [comm_ring A] [module A M] : (M ‚Üí‚Çó[A] M) ‚Üí* A
(Œπ : Type u_1) {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) : topological_space (bundle.total_space Z.fiber)
{Œ± : Type u_1} (n : ‚Ñï) (s : finset Œ±) : (finset.powerset_len n s).card = s.card.choose n
{R : Type u_1} [semiring R] : comm_semiring ‚Ü•(subsemiring.center R)
(ic : tactic.instance_cache) : expr ‚Üí expr ‚Üí tactic (tactic.instance_cache √ó expr)
{J : Type u‚ÇÅ} [category_theory.category J] : category_theory.decomposed J ‚âå J
{Œπ : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering Œπ X s) (x : X) (hx : x ‚àà s) : Œπ
{C : Type u‚ÇÅ} [category_theory.category C] (J : category_theory.grothendieck_topology C) : Type (max u‚ÇÅ v‚ÇÅ (w+1))
(R : Type u_1) : Type u_1
(R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] : module.rank R M = cardinal.mk (module.free.choose_basis_index R M)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {s : set ùïú} {n : with_top ‚Ñï} {m : ‚Ñï} (h : cont_diff_on ùïú n f s) (hmn : ‚Üëm < n) (hs : unique_diff_on ùïú s) : differentiable_on ùïú (iterated_deriv_within m f s) s
{k : Type u_1} {V1 : Type u_2} {V2 : Type u_4} [ring k] [add_comm_group V1] [module k V1] [add_comm_group V2] [module k V2] (f : V1 ‚Üí·µÉ[k] V2) : ‚áë(f.linear) = ‚áëf - Œª (z : V1), ‚áëf 0
(in_tag : tactic.tag) (arguments : list name) : tactic.interactive.case_tag
(R‚ÇÅ : Type u_1) [semiring R‚ÇÅ] (M‚ÇÅ : Type u_4) [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] (M‚ÇÇ : Type u_6) [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÅ M‚ÇÇ] : M‚ÇÅ √ó M‚ÇÇ ‚ÜíL[R‚ÇÅ] M‚ÇÇ
{Œ± : Type u_1} (v : vector Œ± 1) : v.tail = vector.nil
{Œπ : Type u_4} {M : Type u_5} {Œ±s : Œπ ‚Üí Type u_13} [has_zero M] (l : (Œ£ (i : Œπ), Œ±s i) ‚Üí‚ÇÄ M) : finset Œπ
{B : Type u} [category_theory.bicategory B] {a b : B} {f g : a ‚ü∂ b} [category_theory.bicategory.lift_hom f] [category_theory.bicategory.lift_hom g] (Œ∑ : f ‚ü∂ g) : Type (max u v)
(e : expr) : tactic (expr √ó expr)
{V : Type u} {G : simple_graph V} {u v : V} (w : G.walk u v) : G.walk v u
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [linear_ordered_field ùïú] [add_comm_monoid E] [add_comm_monoid F] [module ùïú E] [module ùïú F] (f : E ‚Üí‚Çó[ùïú] F) (S : convex_cone ùïú F) : convex_cone ùïú E
{Œ± : Type u_1} (sel : set Œ± ‚Üí option Œ±) : set Œ± ‚Üí ‚Ñï ‚Üí option Œ±
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] {F : Type v} [normed_group F] [normed_space ‚ÑÇ F] {f : E ‚Üí F} (hf : differentiable ‚ÑÇ f) (hb : metric.bounded (set.range f)) : ‚àÉ (c : F), ‚àÄ (z : E), f z = c
{Œ± : Type u_3} {Œ≤ : Type u_4} [lattice Œ±] [bounded_order Œ±] [lattice Œ≤] [bounded_order Œ≤] : bounded_lattice_hom Œ± Œ≤ ‚âÉ bounded_lattice_hom Œ±·µí·µà Œ≤·µí·µà
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s' s : multiset Œ±) : Prop
(J : Type u_1) (C : Type u_2) [category_theory.category J] [category_theory.category C] : category_theory.idempotents.karoubi (J ‚•§ C) ‚•§ J ‚•§ category_theory.idempotents.karoubi C
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (l : Œπ ‚Üí ùïú) {s : finset Œπ} {i : Œπ} (hi : i ‚àà s) : has_inner.inner (v i) (s.sum (Œª (i : Œπ), l i ‚Ä¢ v i)) = l i
{R : Type u_1} [comm_ring R] {Œπ : Type u_2} [fintype Œπ] [ideal.is_jacobson R] : ideal.is_jacobson (mv_polynomial Œπ R)
{Œ± : Type u_1} {Œ≤ : Type u_2} : Œ± √ó Œ≤ ‚Üí Œ≤ √ó Œ±
{Œ± : Type u_1} {M : Type u_2} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (a : Œ±) : M ‚Üí‚Çó[R] Œ± ‚Üí‚ÇÄ M
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} : metric.Hausdorff_dist s (closure t) = metric.Hausdorff_dist s t
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] (J : ideal S) : J.is_prime ‚Üî (ideal.comap (algebra_map R S) J).is_prime ‚àß disjoint ‚ÜëM ‚Üë(ideal.comap (algebra_map R S) J)
(Œ± : Type u) : Type u
{X : Top} (F : Top.presheaf (Type v) X) (Fsh : F.is_sheaf) : F.is_sheaf_unique_gluing
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {w : Œ± ‚Üí M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (ht : ‚àÄ (y : Œ≤), y ‚àâ t ‚Üí (finset.filter (Œª (x : Œ±), f x = y) s).sum (Œª (x : Œ±), w x) ‚â§ 0) (hb : t.card ‚Ä¢ b < s.sum (Œª (x : Œ±), w x)) : ‚àÉ (y : Œ≤) (H : y ‚àà t), b < (finset.filter (Œª (x : Œ±), f x = y) s).sum (Œª (x : Œ±), w x)
{E : Type u_2} {ùïú : Type u_3} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] {s : set E} (hs : convex ùïú s) : convex ùïú (closure s)
 : nnreal ‚Üí*‚ÇÄ nnreal
{Œ± : Type u} : ‚Ñï ‚Üí stream Œ± ‚Üí list Œ±
{V : Type u} {G : simple_graph V} (u : V) : G.walk u u
 : pSet ‚Üí pSet ‚Üí Prop
{Œ± : Type u} (c : conditionally_complete_lattice Œ±) (le : Œ± ‚Üí Œ± ‚Üí Prop) (eq_le : le = conditionally_complete_lattice.le) (sup : Œ± ‚Üí Œ± ‚Üí Œ±) (eq_sup : sup = conditionally_complete_lattice.sup) (inf : Œ± ‚Üí Œ± ‚Üí Œ±) (eq_inf : inf = conditionally_complete_lattice.inf) (Sup : set Œ± ‚Üí Œ±) (eq_Sup : Sup = conditionally_complete_lattice.Sup) (Inf : set Œ± ‚Üí Œ±) (eq_Inf : Inf = conditionally_complete_lattice.Inf) : conditionally_complete_lattice Œ±
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_zero_object C
(Œ± : Type u_3) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] {D : J ‚•§ T.algebra} (c : category_theory.limits.cocone (D ‚ãô T.forget)) : category_theory.limits.cocone ((D ‚ãô T.forget) ‚ãô ‚ÜëT)
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} : clifford_algebra Q ‚Üí‚Çó[R] clifford_algebra Q
{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {Œπ : Sort u_2} (p : Œπ ‚Üí submodule R M) {C : M ‚Üí Prop} {x : M} (hx : x ‚àà ‚®Ü (i : Œπ), p i) (hp : ‚àÄ (i : Œπ) (x : M), x ‚àà p i ‚Üí C x) (h0 : C 0) (hadd : ‚àÄ (x y : M), C x ‚Üí C y ‚Üí C (x + y)) : C x
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} : category_theory.category T.algebra
{Œ± : Type u_1} [linear_order Œ±] (A B : finset Œ±) : (A  B).to_colex ‚â§ (B  A).to_colex ‚Üî A.to_colex ‚â§ B.to_colex
{A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ} [category_theory.category A] [category_theory.category B] [category_theory.category C] {U : B ‚•§ C} {F : C ‚•§ B} (R : A ‚•§ B) (F' : C ‚•§ A) (adj‚ÇÅ : F ‚ä£ U) (adj‚ÇÇ : F' ‚ä£ R ‚ãô U) (X : B) : category_theory.is_reflexive_pair (F'.map (U.map (adj‚ÇÅ.counit.app X))) (category_theory.lift_adjoint.other_map R F' adj‚ÇÅ adj‚ÇÇ X)
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e : local_homeomorph Œ± Œ≤} {s : set Œ±} {t : set Œ≤} : e.is_image s t ‚Üí e.to_local_equiv.source ‚à© ‚áëe ‚Åª¬π' (e.to_local_equiv.target ‚à© t) = e.to_local_equiv.source ‚à© s
{R : Type u_1} {Œπ : Type u_2} {M‚ÇÇ : Type u_4} {M‚ÇÉ : Type u_5} [comm_semiring R] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [module R M‚ÇÇ] [module R M‚ÇÉ] [decidable_eq Œπ] [fintype Œπ] {f g : multilinear_map R (Œª (i : Œπ), M‚ÇÇ) M‚ÇÉ} {Œπ‚ÇÅ : Type u_3} (e : basis Œπ‚ÇÅ R M‚ÇÇ) (h : ‚àÄ (v : Œπ ‚Üí Œπ‚ÇÅ), ‚áëf (Œª (i : Œπ), ‚áëe (v i)) = ‚áëg (Œª (i : Œπ), ‚áëe (v i))) : f = g
{K : Type u} [hfield : field K] {L : Type u_1} [field L] (f : K ‚Üí+* L) (a : L) {x y : ratfunc K} (hx : polynomial.eval‚ÇÇ f a x.denom ‚â† 0) (hy : polynomial.eval‚ÇÇ f a y.denom ‚â† 0) : ratfunc.eval f a (x + y) = ratfunc.eval f a x + ratfunc.eval f a y
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} (hs : is_compact s) {f : filter Œ±} (hf : ‚àÄ (a : Œ±), a ‚àà s ‚Üí s·∂ú ‚àà nhds a ‚äì f) : s·∂ú ‚àà f
(attr_name : name) (attr_names simp_attr_names : list name) : tactic unit
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] (R : B ‚•§ T) {L‚ÇÅ L‚ÇÇ : A ‚•§ T} (l : L‚ÇÅ ‚ü∂ L‚ÇÇ) : category_theory.comma L‚ÇÇ R ‚•§ category_theory.comma L‚ÇÅ R
(Œ± : Type u_1) [fintype Œ±] [encodable Œ±] : list Œ±
{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] (A : C) : A ‚ü∂ category_theory.limits.cokernel (category_theory.limits.diag A)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {L‚ÇÇ : Type w} [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÇ] (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : lie_subalgebra R L‚ÇÇ
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] (F : Top.presheaf C X) (x : ‚Ü•X) (t : ‚Ü•(F.stalk x)) : ‚àÉ (U : topological_space.opens ‚Ü•X) (m : x ‚àà U) (s : ‚Ü•(F.obj (opposite.op U))), ‚áë(F.germ ‚ü®x, m‚ü©) s = t
{Œ± : Type u_1} {A B : finset Œ±} (i : ‚Ñï) (h‚ÇÅ : i + B.card ‚â§ A.card) (h‚ÇÇ : B ‚äÜ A) : ‚àÉ (C : finset Œ±), B ‚äÜ C ‚àß C ‚äÜ A ‚àß C.card = i + B.card
(ùïú : Type u) [nondiscrete_normed_field ùïú] (E : Type v) [normed_group E] [normed_space ùïú E] [proper_space ùïú] [finite_dimensional ùïú E] : proper_space E
 : pexpr ‚Üí bool
(P‚ÇÇ P‚ÇÅ : pfunctor) : pfunctor
 : first_order.language.graph.relations 2
(a : tactic.ring2.horner_expr) (x : pos_num) (n : num) (b : tactic.ring2.horner_expr) : tactic.ring2.horner_expr
 : Fintype ‚•§ Type u_1
(M : Type u_1) [monoid M] : submonoid M
{Œ± : Type u_1} : (Œ± ‚Üí‚ÇÄ ‚Ñï) ‚âÉ+ multiset Œ±
{C : Type u} [category_theory.category C] : C ‚Üí C ‚Üí Prop
 : lattice ‚Ñï
{Œ± : Type u_2} [add_monoid Œ±] (m : Œ±) : (‚àÉ (c : Œ±), m = 2 ‚Ä¢ c) ‚Üí even m
{R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} {P : Type w‚ÇÇ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [add_comm_group N] [add_comm_group P] [module R M] [module R N] [module R P] [lie_ring_module L M] [lie_ring_module L N] [lie_ring_module L P] [lie_module R L M] [lie_module R L N] [lie_module R L P] (e‚ÇÅ : M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N) (e‚ÇÇ : N ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ P) : M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ P
(M : Type u_4) [has_add M] : Type u_4
{M : Type u_1} [has_add M] (c : add_con M) : has_coe_t M c.quotient
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (h : function.injective ‚áë(algebra_map R A)) : ‚Ü•‚ä• ‚âÉ‚Çê[R] R
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [linear_ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : convex_on ùïú s f) {x y : E} (hx : x ‚àà s) (hy : y ‚àà s) {a b : ùïú} (ha : 0 ‚â§ a) (hb : 0 ‚â§ b) (hab : a + b = 1) : f (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ linear_order.max (f x) (f y)
{Œ± : Sort u} {Œ≤ : Sort v} (P : Œ± ‚Üí Sort w) (e : Œ± ‚âÉ Œ≤) : (Œ† (a : Œ±), P a) ‚âÉ Œ† (b : Œ≤), P (‚áë(e.symm) b)
{R : Type u} {A : Type z} [comm_semiring R] [semiring A] [algebra R A] (x : A) : polynomial R ‚Üí‚Çê[R] A
(C : Type u) [category_theory.category C] [category_theory.locally_small C] : C ‚•§ category_theory.shrink_homs C
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} {u v : E} (hu : u ‚àà K) (hv : v ‚àà K·óÆ) : has_inner.inner v u = 0
{B : Type u} [category_theory.bicategory B] {a b : B} {f g h i : a ‚ü∂ b} [category_theory.bicategory.lift_hom g] [category_theory.bicategory.lift_hom h] [category_theory.bicategory.bicategorical_coherence g h] (Œ∑ : f ‚ü∂ g) (Œ∏ : h ‚ü∂ i) : f ‚ü∂ i
(Œ± : Type u) [uniform_space Œ±] : Type u
{X : Type u} {Y : Type v} [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] (f : Cb X Y) : ‚Ñù
{Œ± : Type u_1} {Œπ : Type u_2} {Œ∫ : Sort u_3} (C : (Œπ ‚Üí Œ±) ‚Üí Œ∫) (l : combinatorics.line Œ± Œπ) : Prop
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s : set Œ±} (hb : bdd_below s) (ha : bdd_above s) (ne : s.nonempty) : has_Inf.Inf s ‚â§ has_Sup.Sup s
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (F : C ‚•§ D ‚•§ E) : F.flip ‚âÖ category_theory.curry.obj (category_theory.prod.swap D C ‚ãô category_theory.uncurry.obj F)
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] {D : J ‚•§ T.algebra} (c : category_theory.limits.cocone (D ‚ãô T.forget)) (t : category_theory.limits.is_colimit c) [category_theory.limits.preserves_colimit (D ‚ãô T.forget) ‚ÜëT] : (‚ÜëT.map_cocone c).X ‚ü∂ c.X
(Œ± : Type u) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
 : tactic unit
{L : first_order.language} {T : L.Theory} (M : T.Model) [small ‚Ü•M] : T.Model
{V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {Œπ : Type u_12} [decidable_eq Œπ] [fintype Œπ] (B : bilin_form K V) (hB : B.nondegenerate) (b : basis Œπ K V) : basis Œπ K V
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_terminal C] [category_theory.limits.has_terminal D] [category_theory.limits.preserves_limit (category_theory.functor.empty C) G] : G.obj (‚ä§_ C) ‚âÖ ‚ä§_ D
(ks : list ‚Ñï) (ts : list omega.term) : tactic expr
{C : Type u‚ÇÅ} [category_theory.category C] {P X Y Z : C} {fst : P ‚ü∂ X} {snd : P ‚ü∂ Y} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} (w : category_theory.comm_sq fst snd f g) (h : category_theory.limits.is_limit w.cone) : category_theory.is_pullback fst snd f g
{Œ± : Type u} : ordnode Œ± ‚Üí ‚Ñï ‚Üí ordnode Œ±
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] (a : Œ±) {b : Œ±} : 0 ‚â§ b ‚Üí a - b ‚â§ a
 : category_theory.limits.has_limits_of_size CommMon
 : Type
{n : ‚Ñï+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [is_cyclotomic_extension {n} K L] (hirr : irreducible (polynomial.cyclotomic ‚Üën K)) [ne_zero ‚Üë‚Üën] : finite_dimensional.finrank K L = ‚Üën.totient
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] {N‚ÇÅ : lie_submodule R L M} (h : N‚ÇÅ.centralizer = N‚ÇÅ) (k : ‚Ñï) : lie_submodule.ucs k ‚ä• ‚â§ N‚ÇÅ
(R : Type u) (M : Type v) (M‚ÇÇ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] : M‚ÇÇ ‚Üí‚Çó[R] M √ó M‚ÇÇ
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (m : hash_map Œ± Œ≤) : list Œ±
{Œ± : Type u} [topological_space Œ±] {Œ≤ : Type u_1} [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (h : continuous f) : connected_components Œ± ‚Üí connected_components Œ≤
(X : Compactum) : ultrafilter (ultrafilter ‚Ü•X) ‚Üí ultrafilter ‚Ü•X
{G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) {f : N ‚Üí* G} (hf : function.surjective ‚áëf) : subgroup.comap f H.normalizer = (subgroup.comap f H).normalizer
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M ‚Üí+ P} (H : c ‚â§ add_con.ker f) (x : M) : ‚áë(c.lift f H) (‚áë(c.mk') x) = ‚áëf x
{Œ± : Type u} (s t : set Œ±) [fintype ‚Ü•s] [decidable_pred (Œª (_x : Œ±), _x ‚àà t)] : fintype ‚Ü•(s ‚à© t)
{V : Type u_1} [inner_product_space ‚Ñù V] (x : V) : inner_product_geometry.angle x 0 = real.pi / 2
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (s : add_subsemigroup M) (t : add_subsemigroup N) : ‚Ü•(s.prod t) ‚âÉ+ ‚Ü•s √ó ‚Ü•t
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] (F : J ‚•§ K) {j‚ÇÅ j‚ÇÇ : J} (h : category_theory.zigzag j‚ÇÅ j‚ÇÇ) : category_theory.zigzag (F.obj j‚ÇÅ) (F.obj j‚ÇÇ)
{g : Type} [random_gen g] {n : ‚Ñï} (x y : bitvec n) (h : x ‚â§ y) : rand_g g ‚Ü•(set.Icc x y)
{Œ± : Type u_1} {p : Œ± ‚Üí Prop} (s : finset Œ±) (H : ‚àÄ (x : Œ±), x ‚àà s ‚Üî p x) : fintype {x // p x}
{M : Type u_1} {Œπ : Type u_2} (R : Type u_3) [decidable_eq M] [comm_semiring R] (f : M ‚Üí Œπ) (i : Œπ) : submodule R (add_monoid_algebra R M)
{n : ‚Ñï} (i : fin (n + 1)) : fin (n + 1) ‚âÉ option (fin n)
(Œ± : Type u) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] {Œ¥ : Œ± ‚Üí Type u_4} (t : Œ† (a : Œ±), finset (Œ¥ a)) : finset (Œ† (a : Œ±), Œ¥ a)
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [preorder Œ±] [preorder Œ≤] [add_zero_class Œ±] [add_zero_class Œ≤] : Type (max u_6 u_7 u_8)
(R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {C : module.ray R M ‚Üí Prop} (h : ‚àÄ (v : M) (hv : v ‚â† 0), C (ray_of_ne_zero R v hv)) (x : module.ray R M) : C x
 : tactic.rcases_patt ‚Üí tactic.list_Pi tactic.rcases_patt
(C : Type u) [category_theory.category C] : Prop
{p x : ‚Ñù} (h : liouville_with p x) (hp : 1 < p) : irrational x
{R : Type u_1} [add_zero_class R] : is_add_regular 0
(M : Type u_1) (Œ± : Type u_2) [group M] [mul_action M Œ±] : galois_connection (‚áëorder_dual.to_dual ‚àò fixing_subgroup M) ((Œª (P : subgroup M), mul_action.fixed_points ‚Ü•P Œ±) ‚àò ‚áëorder_dual.of_dual)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} (p : Œπ ‚Üí P) : affine_independent k p ‚Üî ‚àÄ (s : finset Œπ) (w : Œπ ‚Üí k), s.sum (Œª (i : Œπ), w i) = 0 ‚Üí ‚áë(s.weighted_vsub p) w = 0 ‚Üí ‚àÄ (i : Œπ), i ‚àà s ‚Üí w i = 0
{R : Type u} [comm_ring R] (M : Module R) : Module.of R (tensor_product R ‚Ü•M R) ‚âÖ M
{Œ± : Type u_1} (s : finset Œ±) : ‚Ñï
{X : Type u_1} [has_repr X] : has_repr (alexandroff X)
{Œ± : Sort u} {Œ≤ : Sort v} (f : Œ± ‚Üí Œ≤) (a : plift Œ±) : plift Œ≤
{R : Type u_1} {A : Type u_2} [comm_ring R] [ring A] [algebra R A] (S : subring R) : algebra ‚Ü•S A
{V : Type u} (G : simple_graph V) : Type u
{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] {P Q : C} (f : P ‚ü∂ Q) : category_theory.mono (category_theory.abelian.factor_thru_coimage f)
{R : Type u_1} [mul_zero_class R] [nontrivial R] : ¬¨is_regular 0
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {x : E} {n : with_top ‚Ñï} (h : cont_diff_within_at ùïú n f s x) (hn : 1 ‚â§ n) : differentiable_within_at ùïú f (has_insert.insert x s) x
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {p : Sort u} (x y : add_localization S) (f : M ‚Üí ‚Ü•S ‚Üí M ‚Üí ‚Ü•S ‚Üí p) (H : ‚àÄ {a a' : M} {b b' : ‚Ü•S} {c c' : M} {d d' : ‚Ü•S}, ‚áë(add_localization.r S) (a, b) (a', b') ‚Üí ‚áë(add_localization.r S) (c, d) (c', d') ‚Üí f a b c d = f a' b' c' d') : p
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_pullbacks C] {A : C} (f g : category_theory.mono_over A) : (category_theory.mono_over.inf.obj f).obj g ‚ü∂ g
(R : Type u_2) (Œì‚ÇÄ : Type u_3) [linear_ordered_add_comm_monoid_with_top Œì‚ÇÄ] [ring R] : has_coe_to_fun (add_valuation R Œì‚ÇÄ) (Œª (_x : add_valuation R Œì‚ÇÄ), R ‚Üí Œì‚ÇÄ)
{m : Type ‚Üí Type v} [monad m] : list (m bool) ‚Üí m bool
{G : Type u_1} [add_comm_group G] (B : add_group_filter_basis G) : uniform_space G
{Œ± : Type u} [topological_space Œ±] [locally_compact_space Œ±] [t2_space Œ±] {K : set Œ±} (hK : is_compact K) : ‚àÉ (V : set Œ±), is_open V ‚àß K ‚äÜ V ‚àß is_compact (closure V)
{Œ± : Type u_2} {Œ≤ : Type u_3} [linear_order Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (h_mono : strict_mono f) (h_surj : function.surjective f) : Œ± ‚âÉo Œ≤
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) : Type (max u v)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {p : filter Œπ} [p.ne_bot] (hF : uniform_cauchy_seq_on F p s) (hF' : ‚àÄ (x : Œ±), x ‚àà s ‚Üí filter.tendsto (Œª (n : Œπ), F n x) p (nhds (f x))) : tendsto_uniformly_on F f p s
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} : has_emptyc (finmap Œ≤)
{Œ± : Type u} [pseudo_emetric_space Œ±] {x : Œ±} {s : set Œ±} : emetric.inf_edist x (closure s) = emetric.inf_edist x s
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cone F} (lift : Œ† (s : category_theory.limits.cone F), s ‚ü∂ t) (uniq' : ‚àÄ (s : category_theory.limits.cone F) (m : s ‚ü∂ t), m = lift s) : category_theory.limits.is_limit t
 : pSet
{Œ± : Type u_1} {Œπ : Type u_2} (s : Œπ ‚Üí set Œ±) : (‚®Ö (i : Œπ), filter.principal (s i)).has_basis (Œª (t : set Œπ), t.finite) (Œª (t : set Œπ), ‚ãÇ (i : Œπ) (H : i ‚àà t), s i)
 : lean.parser projection_rule
{G : Type u_10} [group G] (a : G) : G ‚âÉ G
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {c : ‚ÑÇ} {R : ‚Ñù} (h0 : 0 < R) {f : ‚ÑÇ ‚Üí E} {y : E} {s : set ‚ÑÇ} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R  {c})) (hd : ‚àÄ (z : ‚ÑÇ), z ‚àà metric.ball c R  {c}  s ‚Üí differentiable_at ‚ÑÇ f z) (hy : filter.tendsto f (nhds_within c {c}·∂ú) (nhds y)) : ‚àÆ (z : ‚ÑÇ) in C(c, R), (z - c)‚Åª¬π ‚Ä¢ f z = (2 * ‚Üëreal.pi * complex.I) ‚Ä¢ y
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.monoidal_category C] [category_theory.monoidal_preadditive C] [category_theory.limits.has_finite_biproducts C] {J : Type u_2} [fintype J] (X : C) (f : J ‚Üí C) : (‚®Å f) ‚äó X ‚âÖ ‚®Å Œª (j : J), f j ‚äó X
{Œ± : Type u_1} (s : finset Œ±) [decidable_eq Œ±] : finset (Œ± √ó Œ±)
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b : Œ±} (ha : 0 ‚â§ a) (hb : 0 < b) : 0 < a + b
{p q r : Prop} (h‚ÇÅ : implies p q) (h‚ÇÇ : implies q r) : implies p r
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [has_lt Œπ] [Œ† (i : Œπ), has_le (Œ± i)] : has_le (Œ£‚Çó (i : Œπ), Œ± i)
{x y : simplex_category} (e : x ‚âÖ y) : fin (x.len + 1) ‚âÉo fin (y.len + 1)
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [‚àÄ (i : ùí∞.J), category_theory.limits.has_pullback (ùí∞.map i ‚â´ f) g] (i j : ùí∞.J) : algebraic_geometry.Scheme.pullback.V ùí∞ f g i j ‚ü∂ algebraic_geometry.Scheme.pullback.V ùí∞ f g j i
{C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} (S : J.cover X) : Type (max u v)
{Œ± : Type u_2} [has_involutive_inv Œ±] : has_involutive_inv (filter Œ±)
{Œ± : Type u_1} [linear_ordered_field Œ±] {Œ≤ : Type u_2} [ring Œ≤] (abv : Œ≤ ‚Üí Œ±) [is_absolute_value abv] (x : Œ≤) : cau_seq Œ≤ abv
{n : ‚Ñï} {Œ± : Type u_1} [linear_order Œ±] (f : fin n ‚Üí Œ±) : fin n ‚âÉo ‚Ü•(tuple.graph f)
{R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra R A] [algebra R B] (f : A ‚âÉ‚Çê[R] B) : (integral_closure R A).map ‚Üëf = integral_closure R B
{Œ± : Type u} [partial_order Œ±] [decidable_rel has_le.le] {a b : Œ±} (hab : a ‚â§ b) : a < b ‚à® a = b
{Œ± : Type u_1} (a : Œ±) (s : multiset Œ±) : Prop
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤] {f : C(Œ±, Œ≤)} {Œπ : Type u‚ÇÉ} {p : filter Œπ} {F : Œπ ‚Üí C(Œ±, Œ≤)} (hŒ± : ‚àÄ (x : Œ±), ‚àÉ (n : set Œ±), is_compact n ‚àß n ‚àà nhds x) (h : filter.tendsto F p (nhds f)) : tendsto_locally_uniformly (Œª (i : Œπ) (a : Œ±), ‚áë(F i) a) ‚áëf p
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÇ] [has_zero M‚ÇÇ] [has_scalar ‚Ñï M‚ÇÇ] [has_neg M‚ÇÇ] [has_sub M‚ÇÇ] [has_scalar ‚Ñ§ M‚ÇÇ] [sub_neg_monoid M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (inv : ‚àÄ (x : M‚ÇÅ), f (-x) = -f x) (div : ‚àÄ (x y : M‚ÇÅ), f (x - y) = f x - f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : sub_neg_monoid M‚ÇÇ
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] {J : Type v} [fintype J] {f : J ‚Üí C} [category_theory.limits.preserves_biproduct f F] : category_theory.limits.preserves_limit (category_theory.discrete.functor f) F
{Œπ : Type u_4} (ùïú : Type u_5) [normed_field ùïú] {E : Œπ ‚Üí Type u_1} [fintype Œπ] [Œ† (i : Œπ), semi_normed_ring (E i)] [Œ† (i : Œπ), normed_algebra ùïú (E i)] : normed_algebra ùïú (Œ† (i : Œπ), E i)
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b : Œ±} : a - b < 0 ‚Üí a < b
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.preadditive C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (P : category_theory.ProjectiveResolution X) (Q : category_theory.ProjectiveResolution Y) (R : category_theory.ProjectiveResolution Z) : homotopy (category_theory.ProjectiveResolution.lift (f ‚â´ g) P R) (category_theory.ProjectiveResolution.lift f P Q ‚â´ category_theory.ProjectiveResolution.lift g Q R)
{Œ± : Type u_1} : sym2 Œ± ‚âÉ sym.sym' Œ± 2
(k : Type u_1) [division_ring k] {Œπ : Type u_4} (s : finset Œπ) (i : Œπ) : finset.centroid_weights k s i = (‚Üë(s.card))‚Åª¬π
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] {P : C·µí·µñ ‚•§ A} {X : C} {S : category_theory.sieve X} {E : A·µí·µñ} {x : category_theory.presieve.family_of_elements (P ‚ãô category_theory.coyoneda.obj E) ‚áëS} (hx : x.sieve_compatible) : (hx.cone ‚ü∂ P.map_cone S.arrows.cocone.op) ‚âÉ {t // x.is_amalgamation t}
{Œ± : Type u} [decidable_eq Œ±] (n m : ‚Ñï) : (Œ£' (xs ys : list Œ±), xs ~ ys ‚àß ys.nodup) ‚Üí (Œ£' (xs ys : list Œ±), xs ~ ys ‚àß ys.nodup)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_5} [normed_group E'] [normed_space ùïú E'] {n : with_top ‚Ñï} {f : E ‚Üí E'} {x : E} : cont_mdiff_at (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') n f x ‚Üí cont_diff_at ùïú n f x
(G : Type u_1) [measurable_space G] [add_group G] [has_measurable_add‚ÇÇ G] [has_measurable_neg G] : G √ó G ‚âÉ·µê G √ó G
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommGroup) : category_theory.limits.is_limit (CommGroup.limit_cone F)
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} (hab : a ‚â§ b) (hbc : b = c) : a ‚â§ c
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {I‚ÇÅ I‚ÇÇ : lie_ideal R L} (h : I‚ÇÅ ‚â§ I‚ÇÇ) : ‚Ü•I‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ ‚Ü•I‚ÇÇ
(str : name) (proj : string) (x : expr) (pos : list ‚Ñï) (args : list expr) : tactic (expr √ó list ‚Ñï)
{B : Type u_1} {B' : Type u_3} (f : B' ‚Üí B) (E : B ‚Üí Type u_2) (x : B') : Type u_2
 : pSet ‚Üí Type u
(p : interactive.parse interactive.types.texpr) : tactic unit
(m : ‚Ñ§) {n : ‚Ñ§} (hn : 0 < n) : (‚àÉ (k : ‚Ñ§), n * k < m ‚àß m < n * (k + 1)) ‚Üî ¬¨n ‚à£ m
 : has_pow cardinal cardinal
{F : Type v} [normed_group F] [normed_space ‚ÑÇ F] [complete_space F] {R : ‚Ñù} {c : ‚ÑÇ} {f : ‚ÑÇ ‚Üí F} (hR : 0 < R) (hf : diff_cont_on_cl ‚ÑÇ f (metric.ball c R)) : deriv f c = (2 * ‚Üëreal.pi * complex.I)‚Åª¬π ‚Ä¢ ‚àÆ (z : ‚ÑÇ) in C(c, R), (z - c) ^ -2 ‚Ä¢ f z
{R : Type u_1} {M : Type u_9} {M‚ÇÇ : Type u_12} {M‚ÇÉ : Type u_13} [comm_semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] (f : M‚ÇÇ ‚âÉ‚Çó[R] M‚ÇÉ) : (M ‚Üí‚Çó[R] M‚ÇÇ) ‚âÉ‚Çó[R] M ‚Üí‚Çó[R] M‚ÇÉ
{R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {Œπ : Type u_6} [decidable_eq Œπ] {M‚ÇÇ : Type u_7} [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] (f : M‚ÇÇ ‚Üí‚Çó[R] M) (hf : function.surjective ‚áëf) : function.injective (Œª (g : alternating_map R M N Œπ), g.comp_linear_map f)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) [category_theory.is_iso h.unit] : category_theory.faithful L
{M‚ÇÅ : Type u_3} {M‚ÇÇ : Type u_4} [add_comm_group M‚ÇÅ] [add_comm_group M‚ÇÇ] {R : Type u_1} [ordered_ring R] [module R M‚ÇÅ] [module R M‚ÇÇ] {Q‚ÇÅ : quadratic_form R M‚ÇÅ} {Q‚ÇÇ : quadratic_form R M‚ÇÇ} (h : (Q‚ÇÅ.prod Q‚ÇÇ).anisotropic) : Q‚ÇÅ.anisotropic ‚àß Q‚ÇÇ.anisotropic
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {A : Type u_3} [topological_space A] {f‚ÇÄ f‚ÇÅ : C(A, Œ±)} {g‚ÇÄ g‚ÇÅ : C(A, Œ≤)} {S : set A} (F : f‚ÇÄ.homotopy_rel f‚ÇÅ S) (G : g‚ÇÄ.homotopy_rel g‚ÇÅ S) : (f‚ÇÄ.prod_mk g‚ÇÄ).homotopy_rel (f‚ÇÅ.prod_mk g‚ÇÅ) S
(m : ‚Ñï+) (p : nat.primes) (k : ‚Ñï) : ‚Üëp ^ k ‚à£ m ‚Üî k ‚â§ multiset.count p m.factor_multiset
{R : Type} [comm_ring R] [char_zero R] {d : ‚Ñ§} (r : {r // r * r = ‚Üëd}) (hd : ‚àÄ (n : ‚Ñ§), d ‚â† n * n) : function.injective ‚áë(‚áëzsqrtd.lift r)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_module R L L
{ùïú : Type u} [nondiscrete_normed_field ùïú] (p : polynomial ùïú) (x : ùïú) : has_strict_deriv_at (Œª (x : ùïú), polynomial.eval x p) (polynomial.eval x (‚áëpolynomial.derivative p)) x
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] {f : G ‚Üí+ N} (hf : function.injective ‚áëf) : G ‚âÉ+ ‚Ü•(f.range)
 : Type
(l : Type u_4) (R : Type u‚ÇÇ) [decidable_eq l] [comm_ring R] : matrix (l ‚äï l) (l ‚äï l) R
(o : ordinal) (f : Œ† (b : ordinal), b < o ‚Üí ordinal ‚Üí ordinal) : ordinal ‚Üí ordinal
{C : Type u} [category_theory.category C] {X Y : C} (hX : category_theory.limits.is_zero X) (hY : category_theory.limits.is_zero Y) : X ‚âÖ Y
(p : tactic.ring_exp.ex tactic.ring_exp.ex_type.base) (ps : tactic.ring_exp.ex tactic.ring_exp.ex_type.prod) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.exp)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] (v : picard_lindelof E) [complete_space E] : ‚àÉ (f : ‚Ñù ‚Üí E), f ‚Üë(v.t‚ÇÄ) = v.x‚ÇÄ ‚àß ‚àÄ (t : ‚Ñù), t ‚àà set.Icc v.t_min v.t_max ‚Üí has_deriv_within_at f (‚áëv t (f t)) (set.Icc v.t_min v.t_max) t
{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} {R‚ÇÉ : Type u_3} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [semiring R‚ÇÉ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : R‚ÇÅ ‚Üí+* R‚ÇÉ} {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] {M‚ÇÉ : Type u_7} [topological_space M‚ÇÉ] [add_comm_monoid M‚ÇÉ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] [module R‚ÇÉ M‚ÇÉ] [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] (g : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ
(Œ± : Type u_2) [preorder Œ±] [pred_order Œ±] : Prop
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [h : category_theory.is_iso f] : X ‚âÖ Y
 : Type (u_1+1)
{m : Type u_2} {n : Type u_3} {Œ± : Type v} [has_star Œ±] (M : matrix m n Œ±) : matrix n m Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) {x : Œ±} (h : x ‚àà e.to_local_equiv.source) : continuous_at ‚áëe x
(X Y : Bipointed) : Type u
{Œ± : Type u} (f : filter Œ±) [h : f.ne_bot] : ‚àÉ (u : ultrafilter Œ±), ‚Üëu ‚â§ f
{R : Type u_1} [comm_semiring R] {n : Type u_4} [fintype n] [decidable_eq n] {M‚ÇÅ : Type u_5} [add_comm_monoid M‚ÇÅ] [module R M‚ÇÅ] (v‚ÇÅ : basis n R M‚ÇÅ) : matrix n n R ‚âÉ‚Çê[R] M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÅ
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [add_semigroup Œ≤] : add_semigroup Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u_1} [category_theory.category E] {F G : C ‚•§ D} (H : D ‚•§ E) [category_theory.full H] [category_theory.faithful H] (Œ± : F ‚ãô H ‚ü∂ G ‚ãô H) : F ‚ü∂ G
(restr_type : expr) (hyps : list expr) : tactic (list expr)
{R : Type u} {M : Type v} {M‚ÇÇ : Type w} {M‚ÇÉ : Type y} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] {f g : M √ó M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÉ} (hl : f.comp (linear_map.inl R M M‚ÇÇ) = g.comp (linear_map.inl R M M‚ÇÇ)) (hr : f.comp (linear_map.inr R M M‚ÇÇ) = g.comp (linear_map.inr R M M‚ÇÇ)) : f = g
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_comm_monoid M] (f : Œ± ‚Üí Œ≤) (v : Œ± ‚Üí‚ÇÄ M) : Œ≤ ‚Üí‚ÇÄ M
(C : Type u) [category_theory.category C] [‚àÄ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_coproducts C
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] {A B : matrix n n R} (c : n ‚Üí R) (k : n) (hk : c k = 0) (A_eq : ‚àÄ (i j : n), A i j = B i j + c i * B k j) : A.det = B.det
{V : Type u} {G : simple_graph V} {u v w : V} : G.walk u v ‚Üí G.walk u w ‚Üí G.walk v w
{n : ‚Ñï} {p q : ‚Ñï √ó ‚Ñï} (hp : p ‚àà finset.nat.antidiagonal n) (hq : q ‚àà finset.nat.antidiagonal n) : p = q ‚Üî p.fst = q.fst
{n : ‚Ñï} [hpos : fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.xa i) = 4
{Œ± : Type u_1} (f : filter Œ±) : f.realizer
(Œ± : Type u) [pseudo_metric_space Œ±] : Prop
(Œ± : Type u) [has_mul Œ±] : Œ± ‚Üí Œ± ‚Üí Prop
{Œ≤ : Type u} {Œ± : Type v} [add_comm_monoid Œ≤] [fintype Œ±] [decidable_eq Œ±] (s : finset Œ±) (f : Œ± ‚Üí Œ≤) : s.sum (Œª (i : Œ±), f i) + s·∂ú.sum (Œª (i : Œ±), f i) = finset.univ.sum (Œª (i : Œ±), f i)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) : category_theory.limits.cone F
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] (E : Type u‚ÇÉ) [category_theory.category E] : (C √ó D) √ó E ‚âå C √ó D √ó E
{Œπ : Type v} (Œ± : Œπ ‚Üí Top) (i : Œπ) : Œ± i ‚ü∂ Top.of (Œ£ (i : Œπ), ‚Ü•(Œ± i))
{M' : Type u_4} {Œ± : Type u_5} [add_monoid M'] [add_action M' Œ±] (S : add_submonoid M') : add_action ‚Ü•S Œ±
 : native.float ‚Üí native.float √ó native.float
{R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) ‚Üî is_add_regular a ‚àß is_add_regular b
 : ‚Ñù
(G : Type u_10) (P : Type u_11) [has_vadd G P] : Prop
{Œ± : Type u} [topological_space Œ±] {s U : set Œ±} (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí U ‚àà nhds x) : ‚àÉ (V : set Œ±), s ‚äÜ V ‚àß is_open V ‚àß V ‚äÜ U
{p : ‚Ñï} [fact (nat.prime p)] : has_neg ‚Ñ§_[p]
{Œ± : Type u_2} [has_one Œ±] [has_mul Œ±] [has_inv Œ±] : has_pow (set Œ±) ‚Ñ§
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : is_compact s ‚Üî ‚àÄ {Œπ : Type u} (U : Œπ ‚Üí set Œ±), (‚àÄ (i : Œπ), is_open (U i)) ‚Üí (s ‚äÜ ‚ãÉ (i : Œπ), U i) ‚Üí (‚àÉ (t : finset Œπ), s ‚äÜ ‚ãÉ (i : Œπ) (H : i ‚àà t), U i)
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] : list Œ± ‚Üí list Œ±
{Œ± : Type u_1} [preorder Œ±] (cmp : Œ± ‚Üí Œ± ‚Üí ordering) (h : ‚àÄ (a b : Œ±), (cmp a b).compares a b) : linear_order Œ±
{M : Type u_1} [monoid M] : smul_comm_class ‚Ü•(submonoid.center M) M M
{Œ± : Type u} [topological_space Œ±] : ulift Œ± ‚âÉ‚Çú Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] (X : C) : unique (X ‚ü∂ 0)
{G : Type u_1} {M : Type u_2} [group G] [monoid M] (f : G ‚Üí* M) : G ‚Üí* MÀ£
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a b : Œ±} (ha : 1 ‚â§ a) (hb : 1 < b) : 1 < a * b
(e : onote) (n : ‚Ñï) (s : string) : string
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (F : C ‚•§ D) : Prop
{Œ± : Type u} {s t : set Œ±} {l : filter Œ±} : s =·∂†[l] t ‚Üí (‚àÄ·∂† (x : Œ±) in l, x ‚àà s ‚Üî x ‚àà t)
{M : Type u_1} [add_comm_semigroup M] (c : add_con M) : add_comm_semigroup c.quotient
{Œ± : Type u} {f g : Œ± ‚Üí Œ±} {x : Œ±} (hfg : function.is_fixed_pt (f ‚àò g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x
{M : Type u_1} [mul_one_class M] (S : submonoid M) : has_one ‚Ü•S
(Œ± : Type u) [random Œ±] : slim_check.gen Œ±
(E : Type u_6) : Type u_6
(G : Type u) : Type u
 : has_mul nonote
(P : ‚Ñï ‚Üí Prop) [decidable_pred P] : enat
{Œ± : Type u_1} [has_star Œ±] : has_star (set Œ±)
{R : Type u_1} {S : Type u_2} (K : Type u_3) (L : Type u_4) [euclidean_domain R] [comm_ring S] [is_domain S] [field K] [field L] [algebra R K] [is_fraction_ring R K] [algebra K L] [finite_dimensional K L] [is_separable K L] [algRL : algebra R L] [is_scalar_tower R K L] [algebra R S] [algebra S L] [ist : is_scalar_tower R S L] [iic : is_integral_closure S R L] {abv : absolute_value R ‚Ñ§} (adm : abv.is_admissible) [infinite R] [decidable_eq R] [is_dedekind_domain R] : fintype (class_group S L)
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [has_zero Œπ] : Type u_2
(R : Type u_1) [has_mul R] [has_add R] : Type
 : linarith.ineq ‚Üí linarith.ineq ‚Üí linarith.ineq
{C : Type u} [category_theory.category C] (c : Œ† (X : C), closure_operator (category_theory.sieve X)) (hc : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Y ‚ü∂ X) (S : category_theory.sieve X), ‚áë(c Y) (category_theory.sieve.pullback f S) = category_theory.sieve.pullback f (‚áë(c X) S)) : category_theory.grothendieck_topology C
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Prop
{Œ± : Type u} [is_empty Œ±] : unique (set Œ±)
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) (Œ∏ : real.angle) : o.oangle (‚áë(o.rotation Œ∏) x) (‚áë(o.rotation Œ∏) y) = o.oangle x y
(K : Type u) [comm_ring K] (p : ‚Ñï) [fact (nat.prime p)] [char_p K p] : Type u
{S : set ordinal} (hS : set.unbounded has_lt.lt S) {o : ordinal} : {x : ordinal | x ‚àà S ‚àß ‚àÄ (c : ordinal), c < o ‚Üí ordinal.enum_ord S c < x}.nonempty
{V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (B : bilin_form K V) (b : B.nondegenerate) : V ‚âÉ‚Çó[K] module.dual K V
{R : Type u_1} {M : Type u_2} {P : Type u_3} {N : Type w} [ring R] [add_comm_group M] [module R M] [add_comm_group N] [module R N] [add_comm_group P] [module R P] [is_noetherian R M] [is_noetherian R P] (f : M ‚Üí‚Çó[R] N) (g : N ‚Üí‚Çó[R] P) (hf : function.injective ‚áëf) (hg : function.surjective ‚áëg) (h : f.range = g.ker) : is_noetherian R N
{R : Type u_1} [comm_ring R] {G : Module R} {x y : category_theory.over G} (h : category_theory.abelian.pseudo_equal G x y) : linear_map.range x.hom = linear_map.range y.hom
{M : Type u_2} [add_comm_group M] {ùïú : Type u_1} [field ùïú] [module ùïú M] (f : M ‚Üí‚Çó[ùïú] M) (hf : ‚áëlinear_map.det f ‚â† 1) : finite_dimensional ùïú M
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) {l : list Œ±} {n : ‚Ñï} (H : n < l.length) : f (l.nth_le n H) = (list.map f l).nth_le n _
(ùïú : Type u_5) (ùïú' : Type u_6) [normed_field ùïú] [semi_normed_ring ùïú'] [normed_algebra ùïú ùïú'] [norm_one_class ùïú'] : isometry ‚áë(algebra_map ùïú ùïú')
(Œ± : Type u_5) [has_norm Œ±] [has_one Œ±] : Prop
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R ‚Üí+* S) : ideal R
(D : algebraic_geometry.Scheme.glue_data) (i j : D.to_glue_data.J) : category_theory.limits.pullback_cone (D.Œπ i) (D.Œπ j)
(x y z : pgame) : (x * (y + z)).equiv (x * y + x * z)
 : has_sub ‚Ñï+
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) : Prop
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ‚ü∂ Q) : category_theory.limits.strong_epi_mono_factorisation f
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (p : set Œ±) : subrel r p ‚Ü™r r
(x y : ‚Ñï) (p : x ‚â§ y) : slim_check.gen ‚Ü•(set.Icc x y)
{Œ± : Type u_1} [has_zero Œ±] [has_one Œ±] [has_neg Œ±] : sign_type ‚Üí Œ±
(s : char_buffer) : parser unit
{ùïú : Type u_2} {E : Type u_3} {F : Type u_4} [field ùïú] [topological_space ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [add_comm_group F] [module ùïú F] [topological_space F] [topological_add_group F] [has_continuous_smul ùïú F] [finite_dimensional ùïú E] [finite_dimensional ùïú F] : finite_dimensional ùïú (E ‚ÜíL[ùïú] F)
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : free_group Œ± ‚âÉ* free_group Œ≤) : Œ± ‚âÉ Œ≤
{Œ± : Type u_1} {Œπ : Sort u_4} {s : set Œ±} {t : Œπ ‚Üí set Œ±} (i : Œπ) (h : s ‚äÜ t i) : s ‚äÜ ‚ãÉ (i : Œπ), t i
{Œ± : Type u_2} {Œ≤ : Type u_3} [monoid Œ±] [add_monoid Œ≤] [distrib_mul_action Œ± Œ≤] : distrib_mul_action Œ± (set Œ≤)
{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] : has_zero (zero_hom M N)
{A B : Fintype} : ‚Ü•A ‚âÉ ‚Ü•B ‚âÉ (A ‚âÖ B)
{G : Type u_1} [group G] [topological_space G] (K‚ÇÄ U : set G) (K : topological_space.compacts G) : ‚Ñù
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (d : D) : (category_theory.structured_arrow (opposite.op d) F.op)·µí·µñ ‚•§ category_theory.costructured_arrow F d
{X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] (d : ‚Ñù) : measure_theory.measure X
{ùïÜ : Type u_1} {Œ± : Type u_3} {Œ≤ : Type u_4} [preorder ùïÜ] [preorder Œ±] [preorder Œ≤] [grade_min_order ùïÜ Œ≤] (f : Œ± ‚Üí Œ≤) (hf : strict_mono f) (hcovby : ‚àÄ (a b : Œ±), a ‚ãñ b ‚Üí f a ‚ãñ f b) (hmin : ‚àÄ (a : Œ±), is_min a ‚Üí is_min (f a)) : grade_min_order ùïÜ Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] {F : C ‚•§ D} {G : D ‚•§ E} {H : C ‚•§ E} [‚Ñã : category_theory.faithful H] (h : F ‚ãô G = H) : category_theory.faithful F
{y : ‚Ñù} (hy : 0 < y) : filter.tendsto (Œª (x : ‚Ñù), x ^ y) filter.at_top filter.at_top
{a b : ‚Ñ§} (w : a ‚à£ b) (h : b.nat_abs < a.nat_abs) : b = 0
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_zero_object C] [category_theory.mono f] : category_theory.limits.is_limit (category_theory.limits.kernel.zero_kernel_fork f)
{Œ± : Type u} {Œ≤ : Type v} {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop} : {c // p c.fst ‚àß q c.snd} ‚âÉ {a // p a} √ó {b // q b}
 : ‚Ñï ‚Üí tactic (list level)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Top) : category_theory.limits.cone F
{C : Type u} [category_theory.category C] : complete_lattice (category_theory.grothendieck_topology C)
 : ‚Ñï ‚Üí num ‚Üí num ‚Üí num
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] (n : ‚Ñï) : ‚Ñ§_[p] ‚Üí+* zmod (p ^ n)
{M : Type u_1} [semigroup M] : comm_semigroup ‚Ü•(subsemigroup.center M)
{C : Type u_1} [category_theory.category C] (P Q : category_theory.idempotents.karoubi C) : Type u_2
{n m : ‚Ñï} (h : m ‚à£ n) (R : Type u_1) [ring R] [char_p R m] : zmod n ‚Üí+* R
(R : Type u) {X : Type v} [comm_ring R] : X ‚Üí free_lie_algebra R X
{K : Type u} {V : Type v} {V' : Type v'} [ring K] [add_comm_group V] [module K V] [add_comm_group V'] [module K V'] (f : V ‚Üí‚Çó[K] V') : cardinal
(f : C(‚Ü•unit_interval, ‚Ñù)) : filter.tendsto (Œª (n : ‚Ñï), bernstein_approximation n f) filter.at_top (nhds f)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {s : set E} {f : E ‚Üí F} {n : with_top ‚Ñï} {p : E ‚Üí formal_multilinear_series ùïú E F} (hf : has_ftaylor_series_up_to_on n f p s) {g : E ‚Üí G} {q : E ‚Üí formal_multilinear_series ùïú E G} (hg : has_ftaylor_series_up_to_on n g q s) : has_ftaylor_series_up_to_on n (Œª (y : E), (f y, g y)) (Œª (y : E) (k : ‚Ñï), (p y k).prod (q y k)) s
 : pgame ‚Üí pgame ‚Üí Type (u+1)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] (F : J ‚•§ C) (e : C ‚âå D) : category_theory.limits.cocone F ‚âå category_theory.limits.cocone (F ‚ãô e.functor)
{C : Type u} [category_theory.category C] (n : ‚Ñï) : category_theory.cosimplicial_object C ‚•§ category_theory.cosimplicial_object.truncated C n
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x : Œ±} : metric.inf_dist x (closure s) = metric.inf_dist x s
{Œ± : Type u} {L‚ÇÅ L‚ÇÇ : list (Œ± √ó bool)} [decidable_eq Œ±] (H : free_group.red L‚ÇÅ L‚ÇÇ) : free_group.reduce L‚ÇÅ = free_group.reduce L‚ÇÇ
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_lt.lt] {a b : Œ±} : a < b‚Åª¬π ‚Üí b < a‚Åª¬π
{Œ± : Type} (tac : tactic Œ±) : list expr ‚Üí list expr ‚Üí tactic (list (tactic.tactic_script Œ±))
{Œ± : Type u} {Œ≤ : Type v} [uniform_space Œ±] [uniform_space Œ≤] (f : Œ± ‚Üí Œ≤) : uniform_space.separation_quotient Œ± ‚Üí uniform_space.separation_quotient Œ≤
(e : environment) : list declaration
(c1 c2 : omega.clause) : omega.clause
{m n : ‚Ñï} : (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] (l : multiset Œ±) (hp : ‚àÉ! (a : Œ±), a ‚àà l ‚àß p a) : Œ±
 : num ‚Üí num
{Œ± : Type u} {Œ≤ : Type v} [omega_complete_partial_order Œ±] [partial_order Œ≤] (f : Œ≤ ‚Üío Œ±) (œâSup‚ÇÄ : omega_complete_partial_order.chain Œ≤ ‚Üí Œ≤) (h : ‚àÄ (x y : Œ≤), ‚áëf x ‚â§ ‚áëf y ‚Üí x ‚â§ y) (h' : ‚àÄ (c : omega_complete_partial_order.chain Œ≤), ‚áëf (œâSup‚ÇÄ c) = omega_complete_partial_order.œâSup (c.map f)) : omega_complete_partial_order Œ≤
{n : ‚Ñï} : (fin.last n).succ_above = fin.cast_succ
{Œ± : Type u} : list Œ± ‚Üí ordnode Œ±
{M : Type u_1} [has_add M] (c : add_con M) : has_add c.quotient
 : convex_on ‚Ñù set.univ real.exp
{Œ± : Type u_1} [decidable_eq Œ±] (s t : multiset Œ±) : multiset Œ±
 : vm_decl ‚Üí list vm_local_info
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.monoidal_category C] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) [category_theory.full F.to_lax_monoidal_functor.to_functor] [category_theory.faithful F.to_lax_monoidal_functor.to_functor] (X Y : C) [category_theory.exact_pairing (F.to_lax_monoidal_functor.to_functor.obj X) (F.to_lax_monoidal_functor.to_functor.obj Y)] : category_theory.exact_pairing X Y
(C : Type u_1) [quiver C] : Sort (max (u_1+1) u_2 1)
{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.metrizable_space Y] {f : X ‚Üí Y} (hf : embedding f) : topological_space.metrizable_space X
{K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {n : ‚Ñï} {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n ‚Üî ‚àÉ (ifp_n : generalized_continued_fraction.int_fract_pair K), generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n ‚àß ifp_n.fr ‚â† 0 ‚àß generalized_continued_fraction.int_fract_pair.of (ifp_n.fr)‚Åª¬π = ifp_succ_n
{n : ‚Ñï} {Œ± : typevec n} (p : Œ±.arrow (typevec.repeat n Prop)) : typevec.arrow (Œª (i : fin2 n), {x // typevec.of_repeat (p i x)}) (typevec.subtype_ p)
 : ‚Ñï ‚Üí format ‚Üí format
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C·µí·µñ) (F : C ‚•§ D·µí·µñ) [category_theory.limits.preserves_colimit K.left_op F] : category_theory.limits.preserves_limit K F.left_op
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [metric_space Œ≤] : metric_space (bounded_continuous_function Œ± Œ≤)
{Œ± : Type u_1} : ((Œ± ‚Üí ‚Ñï) ‚Üí ‚Ñ§) ‚Üí Prop
{F : Type} [field F] (q : ‚Ñï) {f : polynomial F} (hf : polynomial.has_separable_contraction q f) [hF : exp_char F q] (g : polynomial F) (hg : polynomial.is_separable_contraction q f g) : g.nat_degree = hf.degree
{Œ± : Type u_1} [preorder Œ±] (a : Œ±) : set Œ±
{n : ‚Ñï} {Œ± : Type u_1} {v : vector Œ± (n + 1)} : v.reverse.head = v.last
{n : ‚Ñï} {Œ± : Type u_1} (v : vector Œ± n) : vector Œ± n
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x : V) {r‚ÇÅ r‚ÇÇ : ‚Ñù} (hr‚ÇÅ : 0 ‚â§ r‚ÇÅ) (hr‚ÇÇ : 0 ‚â§ r‚ÇÇ) : o.oangle (r‚ÇÅ ‚Ä¢ x) (r‚ÇÇ ‚Ä¢ x) = 0
(G : pgame) [G.impartial] : G.equiv (nim G.grundy_value)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {F : C ‚•§ D} [category_theory.creates_colimit K F] {c : category_theory.limits.cocone (K ‚ãô F)} (t : category_theory.limits.is_colimit c) : F.map_cocone (category_theory.lift_colimit t) ‚âÖ c
{Œ± : Type u} [decidable_eq Œ±] [fintype Œ±] (f : equiv.perm Œ±) {s : multiset Œ±} : (‚àÄ (x : Œ±), x ‚àà s) ‚Üí ‚Ñ§À£
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ D} (H : D ‚•§ C) [category_theory.is_equivalence H] (c : category_theory.limits.cone F) : H.map_cone_inv (H.map_cone c) ‚âÖ c
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) (f : G ‚âÉ+ N) : add_subgroup.map f.to_add_monoid_hom H.normalizer = (add_subgroup.map f.to_add_monoid_hom H).normalizer
{X Y Z : algebraic_geometry.Scheme} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [H : algebraic_geometry.is_open_immersion f] [algebraic_geometry.is_open_immersion g] (e : set.range ‚áë(f.val.base) = set.range ‚áë(g.val.base)) : X ‚âÖ Y
{Œ± : Type u_1} : Œ± ‚Ü™ option Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {Z X Y P : C} {f : Z ‚ü∂ X} {g : Z ‚ü∂ Y} {inl : X ‚ü∂ P} {inr : Y ‚ü∂ P} (w : category_theory.comm_sq f g inl inr) (h : category_theory.limits.is_colimit w.cocone) : category_theory.is_pushout f g inl inr
{V : Type u} {G : simple_graph V} {Œ± : Type v} (color : V ‚Üí Œ±) (valid : ‚àÄ {v w : V}, G.adj v w ‚Üí color v ‚â† color w) : G.coloring Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) [category_theory.has_projective_resolution Z] : chain_complex C ‚Ñï
{H : Type u} [topological_space H] : order_top (structure_groupoid H)
{R : Type u_1} [semiring R] (f : polynomial R) : polynomial R
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Ñ§_[p]À£
{R : Type u_1} (S : Type u_6) {M : Type u_9} {M‚ÇÇ : Type u_12} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] [module S M‚ÇÇ] [smul_comm_class R S M‚ÇÇ] : M ‚Üí+ (M ‚Üí‚Çó[R] M‚ÇÇ) ‚Üí‚Çó[S] M‚ÇÇ
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} : a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c
{R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] {f : R ‚Üí+* S} {p : ideal R} {P : ideal S} (h : p ‚â§ ideal.comap f P) : algebra (R ‚ß∏ p) (S ‚ß∏ P)
{K : Type u_1} {v : K} {n : ‚Ñï} [linear_ordered_field K] [floor_ring K] (not_terminated_at_n : ¬¨(generalized_continued_fraction.of v).terminated_at n) : (generalized_continued_fraction.of v).numerators n * (generalized_continued_fraction.of v).denominators (n + 1) - (generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).numerators (n + 1) = (-1) ^ (n + 1)
{Œ± : Type u} [add_group Œ±] : is_add_group_hom id
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] (f : P1 ‚Üí·µÉ[k] P2) (p1 p2 : P1) : ‚áë(f.linear) (p1 -·µ• p2) = ‚áëf p1 -·µ• ‚áëf p2
{M : Type u_1} [comm_monoid M] {s : set M} (hs : is_submonoid s) (m : multiset M) : (‚àÄ (a : M), a ‚àà m ‚Üí a ‚àà s) ‚Üí m.prod ‚àà s
{p : ‚Ñï+ ‚Üí Prop} [decidable_pred p] (h : ‚àÉ (n : ‚Ñï+), p n) : ‚Ñï+
{X : Top} (x : ‚Ü•X) : ‚Ü•(fundamental_groupoid.fundamental_groupoid_functor.obj X)
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : filter Œ±} {m : Œ± ‚Üí filter Œ≤} (F : f.realizer) (G : Œ† (i : Œ±), (m i).realizer) : (f.bind m).realizer
(n : Type u_3) (R : Type u_7) (Œ± : Type v) [semiring R] [add_comm_monoid Œ±] [module R Œ±] : matrix n n Œ± ‚Üí‚Çó[R] n ‚Üí Œ±
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {f g : X ‚ü∂ Y} {c : category_theory.limits.fork f g} (i : category_theory.limits.is_limit c) : category_theory.limits.is_limit (category_theory.preadditive.kernel_fork_of_fork c)
{Œ± : Type u_1} (s : set (sym2 Œ±)) (x y : Œ±) : Prop
{Œ± : Type u_1} [preorder Œ±] (a : Œ±) : set Œ±
{ùïú : Type u} [hnorm : nondiscrete_normed_field ùïú] {E : Type v} [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_smul ùïú E] (l : E ‚Üí‚Çó[ùïú] ùïú) (hl : is_closed ‚Üë(l.ker)) : continuous ‚áël
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J ‚Üí C) [category_theory.limits.has_biproduct F] : (category_theory.limits.biproduct.bicone F).is_bilimit
(k : Type u) [field k] : k ‚Üí+* algebraic_closure.adjoin_monic k
(p : ‚Ñï) : zmod (2 ^ p - 1)
{a : ‚Ñù} {l : filter ‚Ñù} {f g : ‚Ñù ‚Üí ‚Ñù} (hdf : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.Ioi a), differentiable_at ‚Ñù f x) (hg' : ‚àÄ·∂† (x : ‚Ñù) in nhds_within a (set.Ioi a), deriv g x ‚â† 0) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.Ioi a)) (nhds 0)) (hdiv : filter.tendsto (Œª (x : ‚Ñù), deriv f x / deriv g x) (nhds_within a (set.Ioi a)) l) : filter.tendsto (Œª (x : ‚Ñù), f x / g x) (nhds_within a (set.Ioi a)) l
(p : interactive.parse (optional interactive.types.ident_)) : tactic unit
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] (P : C·µí·µñ ‚•§ D) : C·µí·µñ ‚•§ D
{M : Type u_1} {G : Type u_2} [add_zero_class M] [add_comm_group G] : has_sub (M ‚Üí+ G)
{F : Type u} {K : Type v} (L : Type w) [field K] [field L] [field F] [algebra K L] [algebra K F] (f : polynomial K) [polynomial.is_splitting_field K L f] (hf : polynomial.splits (algebra_map K F) f) : L ‚Üí‚Çê[K] F
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.abelian D] (F : C ‚•§ D) (G : D ‚•§ C) [G.preserves_zero_morphisms] (i : F ‚ãô G ‚âÖ ùü≠ C) (adj : G ‚ä£ F) : category_theory.limits.has_cokernels C
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {F : C ‚•§ D} {Y : D} (h : Y ‚àà F.ess_image) : C
{J : Type u} [category_theory.small_category J] [category_theory.is_cofiltered J] (F : J ‚•§ Type u) [hf : Œ† (j : J), fintype (F.obj j)] [hne : ‚àÄ (j : J), nonempty (F.obj j)] : F.sections.nonempty
 : tactic.instance_cache ‚Üí expr ‚Üí expr ‚Üí tactic (tactic.instance_cache √ó expr)
 : expr ‚Üí expr ‚Üí tactic (expr √ó bool √ó expr)
(Œ± : Type u_1) {Œ≤ : Type u_2} (bs : set Œ≤) : {f // ‚àÄ (a : Œ±), ‚áëf a ‚àà bs} ‚âÉ (Œ± ‚Ü™ ‚Ü•bs)
(G : Type u_1) [group G] [topological_space G] : Type u_1
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : euclidean_geometry.orthogonal_projection_fn s p ‚àà s
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [linear_ordered_add_comm_group Œ±] [order_topology Œ±] {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±} {C : Œ±} (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_bot) : filter.tendsto (Œª (x : Œ≤), f x + g x) l filter.at_bot
{F : Type u ‚Üí Type v} [applicative F] [is_lawful_applicative F] : applicative_transformation F F
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : euclidean_geometry.angle p2 p3 p1 = 0
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommGroup) : CommGroup
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] {C : Type u} [category_theory.category C] (G : J √ó K ‚•§ C) [category_theory.limits.has_limits_of_shape K C] [category_theory.limits.has_limit G] [category_theory.limits.has_limit (category_theory.curry.obj G ‚ãô category_theory.limits.lim)] : category_theory.limits.limit G ‚âÖ category_theory.limits.limit (category_theory.curry.obj G ‚ãô category_theory.limits.lim)
(Œì : tactic.itauto.context) : format
(C : Type u) (A : Type u_2) [category_theory.category C] [add_monoid A] : Type (max u u_2 v)
{R : Type u_1} [ordered_semiring R] [nontrivial R] : char_zero R
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) : category_theory.limits.cone F
{p : ‚Ñï} {G : Type u_1} [group G] (H : subgroup G) [fintype (sylow p G)] : fintype (sylow p ‚Ü•H)
{B : Type u_3} (E : B ‚Üí Type u_5) {B' : Type u_7} (f : B' ‚Üí B) [topological_space B'] [topological_space (bundle.total_space E)] : topological_space (bundle.total_space (f *·µñ E))
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : continuous_at f a) (hb : continuous_at f b) : has_strict_fderiv_at (Œª (p : ‚Ñù √ó ‚Ñù), ‚à´ (x : ‚Ñù) in p.fst..p.snd, f x) ((continuous_linear_map.snd ‚Ñù ‚Ñù ‚Ñù).smul_right (f b) - (continuous_linear_map.fst ‚Ñù ‚Ñù ‚Ñù).smul_right (f a)) (a, b)
{R : Type u_3} {S : Type u_4} {A : Type u_5} [comm_ring R] [comm_ring S] [comm_ring A] [algebra R S] [algebra S A] [algebra R A] [is_scalar_tower R S A] (hinj : function.injective ‚áë(algebra_map R S)) {x : A} (A_alg : is_algebraic R x) : is_algebraic S x
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_products C] : category_theory.comonad C
{Œ± : Type u_1} [add_group Œ±] (s : add_subgroup Œ±) : setoid Œ±
 : Meas ‚•§ Meas
{M : Type u_1} {N : Type u_2} [add_semigroup M] [add_semigroup N] {s : set M} (f : M ‚Üí N) (hs : add_subsemigroup.closure s = ‚ä§) (hmul : ‚àÄ (x y : M), y ‚àà s ‚Üí f (x + y) = f x + f y) : add_hom M N
{K : Type u_1} {v : K} {n : ‚Ñï} [linear_ordered_field K] [floor_ring K] {gp : generalized_continued_fraction.pair K} (nth_s_eq : (generalized_continued_fraction.of v).s.nth n = option.some gp) : gp.a = 1 ‚àß ‚àÉ (z : ‚Ñ§), gp.b = ‚Üëz
(s t : set ‚Ñù) : set ‚ÑÇ
(prf : expr) : tactic expr
{Œ± : Type u} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : set Œ±) : Prop
{Œ± : Type u_1} [preorder Œ±] [order_top Œ±] [locally_finite_order Œ±] (a : Œ±) : finset Œ±
 : two_pointing bool
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] : ordnode Œ± ‚Üí ordnode Œ±
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) : ‚áë(‚àÖ.weighted_vsub p) w = 0
 : expr ‚Üí tactic unit
{A : Type u_5} [comm_ring A] {m : Type u_6} {n : Type u_7} [fintype m] [fintype n] [decidable_eq m] [decidable_eq n] {M : matrix n m A} {N M' : matrix m n A} (hMM' : M.mul M' = 1) (hM'M : M'.mul M = 1) : (M.mul N).det = (N.mul M).det
(L : first_order.language) : cardinal
{R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] [nontrivial R] (e : basis Œπ R M) (i : Œπ) : (e.units_smul (function.update 1 i (-1))).orientation = -e.orientation
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {i : D ‚•§ C} [category_theory.reflective i] {A : C} (h : A ‚àà i.ess_image) : category_theory.is_iso ((category_theory.adjunction.of_right_adjoint i).unit.app A)
{G : Type u_1} [add_group G] (H : add_subgroup G) : add_subgroup G
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type v} (f : J ‚Üí C) {P : C} (g : Œ† (j : J), P ‚ü∂ f j) : category_theory.limits.is_limit (G.map_cone (category_theory.limits.fan.mk P g)) ‚âÉ category_theory.limits.is_limit (category_theory.limits.fan.mk (G.obj P) (Œª (j : J), G.map (g j)))
(H : Type u_1) (H' : Type u_2) : Type (max u_1 u_2)
{Œ≤ : Type u_2} {Œπ : Sort u_4} (s : Œπ ‚Üí set Œ≤) : set Œ≤
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ X‚ÇÉ) (g‚ÇÅ : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) (g‚ÇÇ : Y‚ÇÇ ‚ü∂ Y‚ÇÉ) (i‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (i‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (i‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) (h‚ÇÅ : i‚ÇÅ ‚â´ g‚ÇÅ = f‚ÇÅ ‚â´ i‚ÇÇ) (h‚ÇÇ : i‚ÇÇ ‚â´ g‚ÇÇ = f‚ÇÇ ‚â´ i‚ÇÉ) (H : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk g‚ÇÇ i‚ÇÉ h‚ÇÇ)) (H' : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk g‚ÇÅ i‚ÇÇ h‚ÇÅ)) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (g‚ÇÅ ‚â´ g‚ÇÇ) i‚ÇÉ _)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {P Q : C} (f : P ‚ü∂ Q) : category_theory.abelian.coimage f ‚ü∂ category_theory.abelian.image f
{M‚ÇÄ : Type u_1} [mul_zero_class M‚ÇÄ] [no_zero_divisors M‚ÇÄ] {a b : M‚ÇÄ} : 0 = a * b ‚Üî a = 0 ‚à® b = 0
{Œ± : Type u_1} : vector.nil.tail = vector.nil
{ùïú : Type u_1} {Œ± : Type u_2} [linear_ordered_field ùïú] [decidable_eq Œ±] [fintype Œ±] {ùíú : finset (finset Œ±)} {r : ‚Ñï} (hr : r ‚â† 0) (hùíú : set.sized r ‚Üëùíú) : ‚Üë(ùíú.card) / ‚Üë((fintype.card Œ±).choose r) ‚â§ ‚Üë(ùíú.shadow.card) / ‚Üë((fintype.card Œ±).choose (r - 1))
(ùïú : Type u_1) {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [has_scalar ùïú Œ≤] (s : set E) (f : E ‚Üí Œ≤) : Prop
(R : Type u) [semiring R] : Prop
{Œ± : Type u_8} [comm_semigroup Œ±] : Œ± √ó Œ± ‚Üí‚Çô* Œ±
(C : Type u) [category_theory.category C] : algebraic_geometry.PresheafedSpace C ‚•§ Top
{C : Type u} [category_theory.category C] : ùü≠ (category_theory.monad C) ‚ü∂ category_theory.Monad.Monad_to_Mon C ‚ãô category_theory.Monad.Mon_to_Monad C
{Œ± : Type u} : dense_inducing has_pure.pure
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] {Z : D} (F : C ‚•§ D) (M : Œ† (x : C), F.obj x ‚ü∂ Z) (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), F.map f ‚â´ M y = M x) (G : category_theory.with_terminal C ‚•§ D) (h : category_theory.with_terminal.incl ‚ãô G ‚âÖ F) (hG : G.obj category_theory.with_terminal.star ‚âÖ Z) (hh : ‚àÄ (x : C), G.map (category_theory.with_terminal.star_terminal.from (category_theory.with_terminal.incl.obj x)) ‚â´ hG.hom = h.hom.app x ‚â´ M x) : G ‚âÖ category_theory.with_terminal.lift F M hM
{Œ± : Type u_1} {Œ≤ : Type u_2} [group Œ±] [division_monoid Œ≤] (f : Œ± ‚Üí* Œ≤) (a : Œ±) : ‚áëf a‚Åª¬π = (‚áëf a)‚Åª¬π
{Œ± : Type u_1} [partial_order Œ±] [pred_order Œ±] [is_pred_archimedean Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) {n m : Œ±} (h : ‚àÄ (i : Œ±), i ‚àà set.Ioc m n ‚Üí r i (order.pred i)) (hnm : m ‚â§ n) : relation.refl_trans_gen r n m
 : exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue
(k : ‚Ñï) {b : ‚Ñù} (hb : 0 < b) : (Œª (x : ‚Ñù), x ^ k) =o[filter.at_top] Œª (x : ‚Ñù), real.exp (b * x)
(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] : Type u_3
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (c : category_theory.limits.binary_bicone P Q) : category_theory.limits.cocone (category_theory.limits.pair P Q)
{Œ± : Type u_1} : Œ± ‚âÉ as_boolring Œ±
{Œπ : Type u_1} {R : Type u_2} {M : Œπ ‚Üí Type u_4} [dec_Œπ : decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] (s : finset Œπ) : (Œ† (i : ‚Ü•‚Üës), M ‚Üëi) ‚Üí‚Çó[R] Œ†‚ÇÄ (i : Œπ), M i
{R : Type u_1} [comm_group R] {f g : ‚Ñï ‚Üí R} : (‚àÄ (n : ‚Ñï), 0 < n ‚Üí n.divisors.prod (Œª (i : ‚Ñï), f i) = g n) ‚Üî ‚àÄ (n : ‚Ñï), 0 < n ‚Üí n.divisors_antidiagonal.prod (Œª (x : ‚Ñï √ó ‚Ñï), g x.snd ^ ‚áënat.arithmetic_function.moebius x.fst) = f n
{R‚ÇÇ : Type u_5} {M‚ÇÇ : Type u_6} [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {B‚ÇÇ F‚ÇÇ : bilin_form R‚ÇÇ M‚ÇÇ} {Œπ : Type u_13} (b : basis Œπ R‚ÇÇ M‚ÇÇ) (h : ‚àÄ (i j : Œπ), ‚áëB‚ÇÇ (‚áëb i) (‚áëb j) = ‚áëF‚ÇÇ (‚áëb i) (‚áëb j)) : B‚ÇÇ = F‚ÇÇ
 : vm_obj ‚Üí ‚Ñï
{V : Type u_1} [inner_product_space ‚Ñù V] (x y : V) : inner_product_geometry.angle (-x) y = real.pi - inner_product_geometry.angle x y
{Œ± : Type u_6} [add_monoid Œ±] : distrib_mul_action (add_monoid.End Œ±) Œ±
{Œ± : Sort u} {Œ≤ : Sort v} {Œ≥ : Sort w} (e‚ÇÅ : Œ± ‚âÉ Œ≤) (e‚ÇÇ : Œ≤ ‚âÉ Œ≥) : Œ± ‚âÉ Œ≥
{G : Type u_1} [group G] : has_top (subgroup G)
{R : Type u} [comm_ring R] (M : Algebra R) : Algebra.of R ‚Ü•M ‚âÖ M
 : tactic unit
{X : Type u_1} [topological_space X] {Œ± : Type u_2} (f : locally_constant X Œ±) : discrete_quotient X
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) [category_theory.is_filtered J] : has_one (Mon.filtered_colimits.M F)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (v : V) (n : v ‚â† 0) (h : ‚àÄ (w : V), ‚àÉ (c : K), c ‚Ä¢ v = w) : finite_dimensional.finrank K V = 1
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : fintype ‚Ü•(basis.of_vector_space_index K V)
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] {f g : equiv.perm Œ±} (hf : f.is_cycle) (hg : g.is_cycle) (h : ‚àÄ (x : Œ±), x ‚àà f.support ‚à© g.support ‚Üí ‚áëf x = ‚áëg x) {x : Œ±} (hx : ‚áëf x = ‚áëg x) (hx' : x ‚àà f.support) : f = g
{Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [ring Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} (hf : is_ring_hom f) : f (-x) = -f x
(F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] [fintype F] [finite_dimensional F E] : ‚àÉ (Œ± : E), F‚üÆŒ±‚üØ = ‚ä§
{V : Type u} {G : simple_graph V} : G ‚Üíg G
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type v} (f : J ‚Üí C) [category_theory.limits.has_product f] [category_theory.limits.preserves_limit (category_theory.discrete.functor f) G] : category_theory.limits.is_limit (category_theory.limits.fan.mk (G.obj (‚àè f)) (Œª (j : J), G.map (category_theory.limits.pi.œÄ f j)))
{L R : Type v} {fst snd : L ‚Üí R} (a b : category_theory.limits.walking_multispan fst snd) : Type v
{Œ± : Type u_1} {Œ≤ : Type u_4} [partial_order Œ±] [preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : galois_connection l u) : closure_operator Œ±
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (p1 p2 : P) : euclidean_geometry.angle p1 p1 p2 = real.pi / 2
{Œ± : Type u_1} {A B : set (finset Œ±)} {r : ‚Ñï} : set.sized r A ‚àß set.sized r B ‚Üí set.sized r (A ‚à™ B)
 : num ‚Üí ‚Ñï ‚Üí num
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ (v‚ÇÇ+1))
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (e : local_equiv Œ± Œ≤) (e' : Œ≤ ‚âÉ Œ≥) : local_equiv Œ± Œ≥
{G : Type u_10} [add_group G] (a : G) : equiv.perm G
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {f : M ‚Üí+ P} (x : M) : ‚áë(add_con.ker f) x = ‚áëf ‚Åª¬π' {‚áëf x}
(X T : Top) : inhabited (Top.local_predicate (Œª (x : ‚Ü•X), ‚Ü•T))
{Œ± : Type u_1} [has_zero Œ±] [preorder Œ±] [decidable_rel has_lt.lt] : Œ± ‚Üío sign_type
{n : ‚Ñï} (i : zmod n) : order_of (dihedral_group.sr i) = 2
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [module ùïú E] [has_scalar ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : convex_on ùïú s f) (c : E) : convex_on ùïú ((Œª (z : E), c + z) ‚Åª¬π' s) (f ‚àò Œª (z : E), c + z)
(M : Type u) [topological_space M] [has_add M] : Prop
(Œ± : Type u) : Type u
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} (s : set Œπ) (t : Œ† (i : Œπ), set (Œ± i)) : set (Œ† (i : Œπ), Œ± i)
 : Type (u_1+1)
(n : ‚Ñï) : finset n.partition
{Œ± : Type u} [decidable_eq Œ±] : list Œ± ‚Üí equiv.perm Œ± ‚Üí ‚Ñ§À£
{Œ± : Type u} (s : set (set Œ±)) : {t : set Œ± | measurable_space.generate_measurable s t} = ‚ãÉ (i : (quotient.out (cardinal.aleph 1).ord).Œ±), measurable_space.generate_measurable_rec s i
{Œ± : Type u_1} [primcodable Œ±] (p : Œ± ‚Üí Prop) [decidable_pred p] : Prop
{Œ± : Type u_1} [has_zero Œ±] [has_one Œ±] [has_add Œ±] : ‚Ñï ‚Üí Œ±
(func : pexpr) (tgt : expr) : tactic ‚Ñï
{Œ± : Type u} : Œ± ‚âÉ Œ±·µÉ·µí·µñ
{Œπ : Type u} {Œ≥ : Type w} {Œ≤ : Œπ ‚Üí Type v} [dec : decidable_eq Œπ] [Œ† (i : Œπ), add_zero_class (Œ≤ i)] [add_comm_monoid Œ≥] : (Œ† (i : Œπ), Œ≤ i ‚Üí+ Œ≥) ‚âÉ+ ((Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚Üí+ Œ≥)
{x : ‚Ñù} : (‚àÄ (p : ‚Ñù), liouville_with p x) ‚Üî liouville x
{M : Type u_1} {A : Type u_2} [comm_monoid M] {s : set M} (hs : is_submonoid s) (f : A ‚Üí M) (t : finset A) : (‚àÄ (b : A), b ‚àà t ‚Üí f b ‚àà s) ‚Üí t.prod (Œª (b : A), f b) ‚àà s
{Œ± : Sort u} {Œ≤ : Sort v} : function.injective coe_fn
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) [category_theory.creates_limit K F] (c : category_theory.limits.cone (K ‚ãô F)) (t : category_theory.limits.is_limit c) : inhabited (category_theory.lifts_to_limit K F c t)
(in_tag : tactic.tag) (rs : list (name √ó list expr)) : tactic unit
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x y z : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (hz : z ‚â† 0) : o.oangle x z - o.oangle y z = o.oangle x y
{Œπ : Type u_1} {R : Type u_2} {S : Type u_3} {M : Œπ ‚Üí Type u_4} {N : Type u_5} [semiring R] [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] [add_comm_monoid N] [module R N] [semiring S] [module S N] [smul_comm_class R S N] : module S (Œ†‚ÇÄ (i : Œπ), M i ‚Üí‚Çó[R] N)
 : prime_multiset ‚Üí+ multiset ‚Ñï
{Œ± : Type u} [t : topological_space Œ±] {B : set (set Œ±)} (hB : topological_space.is_topological_basis B) {u : set Œ±} (ou : is_open u) : u = ‚ãÉ‚ÇÄ{s ‚àà B | s ‚äÜ u}
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_coequalizer f g] [category_theory.limits.has_coequalizer (G.map f) (G.map g)] [i : category_theory.is_iso (category_theory.limits.coequalizer_comparison f g G)] : category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (i : D ‚•§ C) [category_theory.limits.has_finite_products C] [category_theory.reflective i] [category_theory.cartesian_closed C] [category_theory.exponential_ideal i] : category_theory.cartesian_closed D
{k : Type u_1} {P‚ÇÅ : Type u_2} {P‚ÇÇ : Type u_3} {V‚ÇÅ : Type u_6} {V‚ÇÇ : Type u_7} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] (e : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí·µÉ[k] P‚ÇÇ
{Œ± : Type u_1} [preorder Œ±] [succ_order Œ±] {a b : Œ±} [no_max_order Œ±] : order.succ a ‚â§ order.succ b ‚Üí a ‚â§ b
(pqr : multiset ‚Ñï+) : Prop
{C : Type u} [category_theory.category C] (X Y : C) : category_theory.discrete category_theory.limits.walking_pair ‚•§ C
(x y : Set) : Set
{Œ± : Type u} {n : ‚Ñï} [has_repr Œ±] : has_repr (fin n ‚Üí Œ±)
{X Y : AddGroup} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ+ ‚Ü•Y
{Œ± : Type u_1} {Œ≤ : Type u_2} [encodable Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.injective f) : encodable Œ±
 : nat.partrec.code ‚Üí ‚Ñï ‚Üí. ‚Ñï
{R : Type u_1} [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] : tensor_algebra R M ‚Üí‚Çê[R] R
 : expr ‚Üí option ‚Ñö
(A : Type u_4) [comm_ring A] [is_domain A] [unique_factorization_monoid A] {K : Type u_5} [field K] [algebra A K] [is_fraction_ring A K] (x : K) : ‚Ü•(non_zero_divisors A)
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_preorder Œ± r] : Œ± ‚Üí antisymmetrization Œ± r
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] : galois_insertion (algebra.adjoin R) coe
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] [subsingleton (subalgebra R A)] : subsingleton (A ‚Üí‚Çê[R] B)
(C : Type u‚ÇÅ) [category_theory.category C] {F‚ÇÅ : category_theory.discrete pempty ‚•§ C} {F‚ÇÇ : category_theory.discrete pempty ‚•§ C} (c‚ÇÅ : category_theory.limits.cone F‚ÇÅ) (c‚ÇÇ : category_theory.limits.cone F‚ÇÇ) (h : c‚ÇÅ.X ‚âÖ c‚ÇÇ.X) : category_theory.limits.is_limit c‚ÇÅ ‚âÉ category_theory.limits.is_limit c‚ÇÇ
{m n : ‚Ñï} : m ‚à£ n + m ‚Üî m ‚à£ n
 : ‚Ñï ‚Üí vm vm_decl
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) : ‚àÉ (f : V ‚Üí K), t.sum (Œª (e : V), f e ‚Ä¢ e) = 0 ‚àß t.sum (Œª (e : V), f e) = 0 ‚àß ‚àÉ (x : V) (H : x ‚àà t), f x ‚â† 0
(V : Type u) : Type (max u v)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ (w+1) (w'+1))
{Œπ : Type w} {Œπ' : Type w'} {R : Type u} [ring R] [invariant_basis_number R] {M : Type v} [add_comm_group M] [module R M] (v : basis Œπ R M) (v' : basis Œπ' R M) : (cardinal.mk Œπ).lift = (cardinal.mk Œπ').lift
{Œ± : Type u_1} [comm_semiring Œ±] (t : tree Œ±) : tactic.ring2.csring_expr ‚Üí Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G : J ‚•§ C} (Œ± : F ‚âÖ G) (c : category_theory.limits.cone G) : category_theory.limits.is_limit ((category_theory.limits.cones.postcompose Œ±.inv).obj c) ‚âÉ category_theory.limits.is_limit c
{V : Type u} {G : simple_graph V} (d : G.dart) : G.dart
{Œ± : Type u} (f : Œ± ‚Üí Œ±) (a : Œ±) : stream Œ±
(Œ± : Type) : Type
(Œ± : Type u_1) (Œ≤ : Type u_2) [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] [has_zero Œ±] [has_zero Œ≤] [has_scalar Œ± Œ≤] : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) (x : Œ±) : Prop
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [fintype Œπ] (e : M ‚âÉ‚Çó[R] Œπ ‚Üí R) : basis Œπ R M
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (C : chain_complex V ‚Ñï) {X : V} (f : C.X 0 ‚ü∂ X) (w : C.d 1 0 ‚â´ f = 0) : chain_complex.truncate.obj (C.augment f w) ‚âÖ C
(e : expr) (n : name) : tactic expr
{M : Type u_1} [add_zero_class M] : has_bot (add_submonoid M)
{A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x)
{G : Type u_2} [group G] : has_inv (submonoid G)
{G : Type u_1} [add_group G] {H K : add_subgroup G} (h : H ‚â§ K) : ‚Ü•(add_subgroup.comap K.subtype H) ‚âÉ+ ‚Ü•H
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : ‚Ñï ‚Üí add_localization S ‚Üí add_localization S
{Œ± : Type u_2} [has_sub Œ±] : has_sub (set Œ±)
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] {f g : L.hom M N} {s : set M} (h : set.eq_on ‚áëf ‚áëg s) : set.eq_on ‚áëf ‚áëg ‚Üë(‚áë(first_order.language.substructure.closure L) s)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J ‚Üí C} (B : category_theory.limits.bicone F) : category_theory.limits.cone (category_theory.discrete.functor F)
{C : Type u} [category_theory.category C] : category_theory.Monad.Mon_to_Monad C ‚ãô category_theory.Monad.Monad_to_Mon C ‚âÖ ùü≠ (Mon_ (C ‚•§ C))
{V : Type u} [quiver V] (r : V) [quiver.rooted_connected r] : wide_subquiver V
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] (f : filter Œ±) : Œ±
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X Y : C) [category_theory.monoidal_category.lift_obj X] [category_theory.monoidal_category.lift_obj Y] [category_theory.monoidal_category.monoidal_coherence X Y] : X ‚âÖ Y
{Œ± : Type u_1} [uniform_space Œ±] : (uniformity Œ±).has_basis (Œª (V : set (Œ± √ó Œ±)), V ‚àà uniformity Œ± ‚àß is_open V) id
(_x : interactive.parse (lean.parser.tk "add_hint_tactic")) : lean.parser unit
(n : name) : tactic unit
{H : Type u} [topological_space H] : partial_order (structure_groupoid H)
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b : Œ±} : 0 ‚â§ a - b ‚Üí b ‚â§ a
{B : Type u_1} {E : B ‚Üí Type u_2} (b : B) (a : E b) : bundle.total_space E
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M ‚Üí* P} {T : submonoid P} (hy : ‚àÄ (y : ‚Ü•S), ‚áëg ‚Üëy ‚àà T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} (z : N) (u : Q) : ‚áë(f.map hy k) z = u ‚Üî ‚áë(k.to_map) (‚áëg (f.sec z).fst) = ‚áë(k.to_map) (‚áëg ‚Üë((f.sec z).snd)) * u
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± : D·µí·µñ ‚•§ Type v} {‚Ñ±' : category_theory.SheafOfTypes K} (Œ± : G.op ‚ãô ‚Ñ± ‚ü∂ G.op ‚ãô ‚Ñ±'.val) {X : D} (x : ‚Ñ±.obj (opposite.op X)) : category_theory.presieve.family_of_elements ‚Ñ±'.val (category_theory.presieve.cover_by_image G X)
{p : ‚Ñï ‚Üí Prop} [decidable_pred p] {n : ‚Ñï} : p n ‚Üí nat.count p (n + 1) = nat.count p n + 1
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.full F] [category_theory.faithful F] [category_theory.ess_surj F] : category_theory.is_equivalence F
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] (t : category_theory.limits.trident f) (lift : Œ† (s : category_theory.limits.trident f), s.X ‚ü∂ t.X) (fac : ‚àÄ (s : category_theory.limits.trident f), lift s ‚â´ t.Œπ = s.Œπ) (uniq : ‚àÄ (s : category_theory.limits.trident f) (m : s.X ‚ü∂ t.X), (‚àÄ (j : category_theory.limits.walking_parallel_family J), m ‚â´ t.œÄ.app j = s.œÄ.app j) ‚Üí m = lift s) : category_theory.limits.is_limit t
{Œ± : Type u_1} [preorder Œ±] {a b : Œ±·µí·µà} : b ‚©ø a ‚Üí ‚áëorder_dual.of_dual a ‚©ø ‚áëorder_dual.of_dual b
 : tactic.explode.entries ‚Üí ‚Ñï ‚Üí tactic.explode.entry
{M : Type u_1} [add_monoid M] {s t : set M} (h : s ‚äÜ t) : add_monoid.closure s ‚äÜ add_monoid.closure t
 : Type
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ≤] [topological_space Œ≥] [t2_space Œ≥] {f : Œ± ‚Üí Œ≤} (hfd : dense_range f) {g h : Œ≤ ‚Üí Œ≥} (hg : continuous g) (hh : continuous h) (H : g ‚àò f = h ‚àò f) : g = h
{M : Type uM} {N : Type uN} [add_zero_class M] [add_comm_monoid N] : M ‚Üí+ (M ‚Üí+ N) ‚Üí+ N
{n : ‚Ñï} {Œ± : Type u} {Œ≤ : Type v} (a : array n Œ±) (b : Œ≤) (f : fin n ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≤) : Œ≤
(K : Type u_1) [field K] [number_field K] : ¬¨is_field ‚Ü•(number_field.ring_of_integers K)
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {R : nnreal} {c : ‚ÑÇ} {f : ‚ÑÇ ‚Üí E} (hf : diff_cont_on_cl ‚ÑÇ f (metric.ball c ‚ÜëR)) (hR : 0 < R) : has_fpower_series_on_ball f (cauchy_power_series f c ‚ÜëR) c ‚ÜëR
{Œ± : Type u_2} {G‚ÇÄ : Type u_4} [topological_space Œ±] [group_with_zero G‚ÇÄ] [mul_action G‚ÇÄ Œ±] [has_continuous_const_smul G‚ÇÄ Œ±] (c : G‚ÇÄ) (hc : c ‚â† 0) : Œ± ‚âÉ‚Çú Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X ‚ü∂ Y) : Type (max u‚ÇÅ v‚ÇÅ)
{S : Type u‚ÇÅ} {L : Type u‚ÇÇ} {D : Type u‚ÇÉ} [category_theory.category S] [category_theory.category L] [category_theory.category D] (Œπ : S ‚•§ L) (F : S ‚•§ D) [‚àÄ (x : L), category_theory.limits.has_limit (category_theory.Ran.diagram Œπ F x)] (G : L ‚•§ D) : (G ‚ü∂ category_theory.Ran.loc Œπ F) ‚âÉ (((category_theory.whiskering_left S L D).obj Œπ).obj G ‚ü∂ F)
(R : Type u_1) [comm_semiring R] (X : Type u_2) : free_algebra.pre R X ‚Üí free_algebra.pre R X ‚Üí Prop
(a b : ‚Ñï) : a - b.succ = a - b - 1
(P : Type u_2) [preorder P] : Type u_2
{Œ± : Type u} (l : ordnode Œ±) (x : Œ±) : ordnode Œ± ‚Üí ordnode Œ±
{X : Type u_1} {Y : Type u_2} [tY : topological_space Y] [discrete_topology Y] {f : X ‚Üí Y} (hf : function.injective f) : discrete_topology X
{ùïú : Type u_3} [field ùïú] {r : ‚Ñï} (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) (hM : M (sum.inr ()) (sum.inr ()) ‚â† 0) (i : fin r) : M.mul (matrix.pivot.list_transvec_row M).prod (sum.inr ()) (sum.inl i) = 0
{A : Type u_1} (K : Type u_2) [comm_ring A] (S : submonoid A) [comm_ring K] [algebra A K] [is_fraction_ring A K] (B : Type u_3) [comm_ring B] [algebra A B] [is_localization S B] (hS : S ‚â§ non_zero_divisors A) : B ‚Üí‚Çê[A] K
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {f : filter Œ±} [is_trans Œ± r] [f.ne_bot] : filter.is_bounded r f ‚Üí filter.is_cobounded (flip r) f
{c : ‚Ñù} (h1 : 0 < c) (h2 : c < 1 / 2) : function.injective (cardinal.cantor_function c)
{K : Type v} {L : Type w} [field K] [field L] (f : polynomial K) [algebra K L] (hb : polynomial.splits (algebra_map K L) f) : f.splitting_field ‚Üí‚Çê[K] L
 : derive_handler
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} (H : C ‚•§ D) [category_theory.is_equivalence H] (c : category_theory.limits.cocone (F ‚ãô H)) : category_theory.limits.cocone F
{H : Type u} [inner_product_space ‚ÑÇ H] [complete_space H] (self : von_neumann_algebra H) : star_subalgebra ‚ÑÇ (H ‚ÜíL[‚ÑÇ] H)
(p : tactic.ring_exp.atom) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum)
{M : Type u_1} [has_mul M] (c : con M) : Type u_1
{n : ‚Ñï} [h : fact (0 < n)] (i : ‚Ñï) : fin n
{Œ± : Type u_1} [preorder Œ±] (a : Œ±) : lower_set Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) : o.rotation ‚Üëreal.pi = linear_isometry_equiv.neg ‚Ñù
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (hC : category_theory.skeletal C) : monoid C
(R : Type u_1) [comm_ring R] (m n : ‚Ñï) : polynomial.dickson 1 1 (m * n) = (polynomial.dickson 1 1 m).comp (polynomial.dickson 1 1 n)
{Œ± : Type u} [linear_order Œ±] (a b : Œ±) : linear_order.max a b = a ‚àß b ‚â§ a ‚à® linear_order.max a b = b ‚àß a < b
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [comm_monoid Œ≤] {s : finset Œ≥} {t : Œ≥ ‚Üí finset Œ±} {t' : finset Œ±} {s' : Œ± ‚Üí finset Œ≥} (h : ‚àÄ (x : Œ≥) (y : Œ±), x ‚àà s ‚àß y ‚àà t x ‚Üî x ‚àà s' y ‚àß y ‚àà t') {f : Œ≥ ‚Üí Œ± ‚Üí Œ≤} : s.prod (Œª (x : Œ≥), (t x).prod (Œª (y : Œ±), f x y)) = t'.prod (Œª (y : Œ±), (s' y).prod (Œª (x : Œ≥), f x y))
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1 ‚â§ s2 ‚Üî ‚àÄ (p : P), p ‚àà s1 ‚Üí p ‚àà s2
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} : mvqpf.cofix F Œ± ‚Üí F (Œ± ::: mvqpf.cofix F Œ±)
(hsum_on_left : expr) : tactic unit
{G : Type u_1} [group G] {p : ‚Ñï} [fact (nat.prime p)] {N : subgroup G} [N.normal] [fintype (sylow p ‚Ü•N)] (P : sylow p ‚Ü•N) : (subgroup.map N.subtype ‚ÜëP).normalizer ‚äî N = ‚ä§
{Œπ : Type u} {Œ∑ : Type v} (R : Type w) (s : Œπ ‚Üí Œ∑) [mul_one_class R] : (Œπ ‚Üí R) ‚Üí* Œ∑ ‚Üí R
 : Type (u+1)
{Œ± : Type u_1} {Œ≤ : Type u_2} [primcodable Œ±] [primcodable Œ≤] (p : Œ± ‚Üí Prop) (q : Œ≤ ‚Üí Prop) : Prop
{Œπ : Type u_1} {R : Type u_2} {N : Type u_5} [dec_Œπ : decidable_eq Œπ] [semiring R] [add_comm_monoid N] [module R N] [Œ† (m : R), decidable (m ‚â† 0)] (p : Œπ ‚Üí submodule R N) {v : Œπ ‚Üí N} (hv : ‚àÄ (i : Œπ), v i ‚àà p i) : (‚áë(dfinsupp.lsum ‚Ñï) (Œª (i : Œπ), (p i).subtype)).comp ((dfinsupp.map_range.linear_map (Œª (i : Œπ), linear_map.to_span_singleton R ‚Ü•(p i) ‚ü®v i, _‚ü©)).comp (finsupp_lequiv_dfinsupp R).to_linear_map) = finsupp.total Œπ N R v
{Œ± : Type u_1} [pseudo_emetric_space Œ±] (r C : ennreal) (hr : r < 1) (hC : C ‚â† ‚ä§) {f : ‚Ñï ‚Üí Œ±} (hu : ‚àÄ (n : ‚Ñï), has_edist.edist (f n) (f (n + 1)) ‚â§ C * r ^ n) : cauchy_seq f
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_pullbacks C] (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.subobject.map f ‚ä£ category_theory.subobject.pullback f
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (q : Œ† (i : fin (n + 1)), Œ± i) (i : fin n) : Œ± (‚áëfin.cast_succ i)
{R : Type u} [ring R] {s : set R} {t : subring R} : subring.closure s ‚â§ t ‚Üî s ‚äÜ ‚Üët
{Œ± : Type u} {Œ≤ : Type v} [non_unital_ring Œ±] [has_zero Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.surjective f) (zero : f 0 = 0) (add : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ±), f (-x) = -f x) (sub : ‚àÄ (x y : Œ±), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ±) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (gsmul : ‚àÄ (x : Œ±) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_unital_ring Œ≤
{Œ± : Type u} [pseudo_metric_space Œ±] [proper_space Œ±] {x : Œ±} {r : ‚Ñù} {s : set Œ±} (hr : 0 < r) (hs : is_closed s) (h : s ‚äÜ metric.ball x r) : ‚àÉ (r' : ‚Ñù) (H : r' ‚àà set.Ioo 0 r), s ‚äÜ metric.ball x r'
(f : nat.arithmetic_function ‚ÑÇ) (z : ‚ÑÇ) : Prop
{Œ≤ : Type u_2} (f : equiv.perm Œ≤) (x y : Œ≤) : Prop
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ùïú] [inner_product_space ùïú E] [inner_product_space ùïú F] [finite_dimensional ùïú E] [finite_dimensional ùïú F] (A : E ‚Üí‚Çó[ùïú] F) (x : E) (y : F) : has_inner.inner x (‚áë(‚áëlinear_map.adjoint A) y) = has_inner.inner (‚áëA x) y
{Œ± : Type u_2} [decidable_eq Œ±] [division_comm_monoid Œ±] : division_comm_monoid (finset Œ±)
{Œ± : Type u_1} {Œ≤ : Type u_4} [preorder Œ±] [preorder Œ≤] {u : Œ≤ ‚Üí Œ±} (l : lower_adjoint u) : Œ± ‚Üí Œ≤
{n : ‚Ñï} (c : composition_as_set n) : fin c.boundaries.card ‚Ü™o fin (n + 1)
(X Y : Type u) : category_theory.limits.cocone (category_theory.limits.pair X Y)
(ùïú : Type u_1) {E : Type u_2} [normed_linear_ordered_field ùïú] [normed_group E] [normed_space ùïú E] [normed_space ‚Ñù E] [linear_map.compatible_smul E E ùïú ‚Ñù] (h : strict_convex ùïú (metric.closed_ball 0 1)) : strict_convex_space ùïú E
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] {Q : quadratic_form R M} : Q.to_fun = ‚áëQ
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] {X Y : C} {f : X ‚ü∂ Y} (h : f = 0) [category_theory.limits.has_image f] : category_theory.limits.image.Œπ f = 0
{Œ± : Type u} (p : Œ± ‚Üí Prop) (f : filter Œ±) : Prop
 : native.float ‚Üí ‚Ñ§
{Œ± : Type u_1} {n : Type u_4} [non_unital_semiring Œ±] [star_ring Œ±] (A : matrix n n Œ±) : Prop
 : expr ‚Üí option expr
{G : Type u_1} [group G] (H N : subgroup G) [N.normal] : ‚Üë(H ‚äî N) = ‚ÜëH * ‚ÜëN
(G : Type u) [comm_group G] : CommGroup
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type u} [category_theory.category J] (R : D ‚•§ C) (K : J ‚•§ D) [category_theory.monadic_right_adjoint R] [category_theory.limits.preserves_colimit (K ‚ãô R) (category_theory.left_adjoint R ‚ãô R)] [category_theory.limits.preserves_colimit ((K ‚ãô R) ‚ãô category_theory.left_adjoint R ‚ãô R) (category_theory.left_adjoint R ‚ãô R)] : category_theory.creates_colimit K R
{K : Type u_1} {n : ‚Ñï} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] (terminated_at_succ_n : s.terminated_at (n + 1)) : generalized_continued_fraction.squash_seq s n = s
(C : Type u) [category_theory.category C] : Type (max u (v+1))
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) (h : s.sum (Œª (i : Œπ), w i) = 1) (b : P) : ‚áë(s.affine_combination p) w = ‚áë(s.weighted_vsub_of_point p b) w +·µ• b
{Œ± : Type u_1} {Œ≤ : Type u_2} {rŒ± : Œ± ‚Üí Œ± ‚Üí Prop} {rŒ≤ : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {a : Œ±} {b : Œ≤} (ha : acc rŒ± a) (hb : acc rŒ≤ b) : acc (relation.game_add rŒ± rŒ≤) (a, b)
{Œ± : Type u} {Œ≤ : Type v} [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] : (Œ± ‚ÜíùíÑ Œ≤) √ó Œ± ‚ÜíùíÑ Œ≤
{Œ± : Type u_1} [preorder Œ±] (Ixx : Œ± ‚Üí Œ± ‚Üí set Œ±) (l‚ÇÅ : filter Œ±) (l‚ÇÇ : out_param (filter Œ±)) : Prop
{Œπ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Œπ ‚Üí set X} (uo : ‚àÄ (i : Œπ), is_open (u i)) (uf : ‚àÄ (x : X), {i : Œπ | x ‚àà u i}.finite) (uU : (‚ãÉ (i : Œπ), u i) = set.univ) : ‚àÉ (v : Œπ ‚Üí set X), set.Union v = set.univ ‚àß (‚àÄ (i : Œπ), is_closed (v i)) ‚àß ‚àÄ (i : Œπ), v i ‚äÜ u i
{Œ±‚ÇÅ : Type u_1} {Œ±‚ÇÇ : Type u_2} {Œ≤‚ÇÅ : Type u_3} {Œ≤‚ÇÇ : Type u_4} {r‚ÇÅ : Œ±‚ÇÅ ‚Üí Œ±‚ÇÅ ‚Üí Prop} {r‚ÇÇ : Œ±‚ÇÇ ‚Üí Œ±‚ÇÇ ‚Üí Prop} {s‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ≤‚ÇÅ ‚Üí Prop} {s‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ≤‚ÇÇ ‚Üí Prop} (e‚ÇÅ : r‚ÇÅ ‚âÉr s‚ÇÅ) (e‚ÇÇ : r‚ÇÇ ‚âÉr s‚ÇÇ) : sum.lex r‚ÇÅ r‚ÇÇ ‚âÉr sum.lex s‚ÇÅ s‚ÇÇ
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (c : category_theory.limits.cocone F) {X : C} (f : c.X ‚ü∂ X) : category_theory.limits.cocone F
(mi : interactive.decl_meta_info) (_x : interactive.parse (lean.parser.tk "library_note")) : lean.parser unit
{n : ‚Ñï} {Œ± : Type u_1} [linear_order Œ±] (f : fin n ‚Üí Œ±) : finset (Œ± √ó‚Çó fin n)
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} (f : J ‚Üí (X ‚ü∂ Y)) [category_theory.limits.has_wide_equalizer f] : C
{Œ± : Type} : expr ‚Üí Œ± ‚Üí (expr ‚Üí ‚Ñï ‚Üí Œ± ‚Üí Œ±) ‚Üí Œ±
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] {Œ¥ : Type u_2} [topological_space Œ¥] [discrete_topology Œ¥] (f : Œ± ‚Ü™ Œ¥) (g : bounded_continuous_function Œ± Œ≤) (h : bounded_continuous_function Œ¥ Œ≤) : bounded_continuous_function Œ¥ Œ≤
{Œ± : Type} (p : parser Œ±) : Prop
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.limits.has_pullback f g] : category_theory.limits.pullback f g ‚âÖ category_theory.limits.pullback g f
(R : Type u) [semiring R] (Œπ : Type v) [dec_Œπ : decidable_eq Œπ] (M : Œπ ‚Üí Type w) [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] (s : finset Œπ) : (Œ† (i : ‚Ü•‚Üës), M i.val) ‚Üí‚Çó[R] direct_sum Œπ (Œª (i : Œπ), M i)
 : first_order.language
 : Type (u_1+1)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} (f : Y ‚ü∂ Z) (P : category_theory.ProjectiveResolution Y) (Q : category_theory.ProjectiveResolution Z) : P.complex.X 0 ‚ü∂ Q.complex.X 0
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] (D : J ‚•§ T.algebra) [category_theory.limits.has_limit (D ‚ãô T.forget)] : category_theory.limits.has_limit D
(t : ‚Ñù) : filter.tendsto (Œª (x : ‚Ñù), (1 + t / x) ^ x) filter.at_top (nhds (real.exp t))
 : expr ‚Üí tactic (list expr √ó expr)
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : differentiable_on ‚Ñù f (interior D)) (hf'_nonpos : ‚àÄ (x : ‚Ñù), x ‚àà interior D ‚Üí deriv f x ‚â§ 0) : antitone_on f D
(Œ± : Type u_1) : {x // ‚Ü•(x.is_some)} ‚âÉ Œ±
{C : Type u‚ÇÅ} [category_theory.category C] (G : category_theory.comonad C) : Type (max u‚ÇÅ v‚ÇÅ)
 : has_dist Gromov_Hausdorff.GH_space
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) : C ‚•§ h.to_comonad.coalgebra
{Œ± : Sort u} {f : Œ± ‚Üí Œ±} (h : function.involutive f) {x y : Œ±} : f x = y ‚Üî x = f y
 : bool ‚Üí lean.parser (tactic.list_Pi tactic.rcases_patt)
{C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] (S : J.cover X) (P : C·µí·µñ ‚•§ D) [category_theory.limits.has_multiequalizer (S.index P)] : P.obj (opposite.op X) ‚ü∂ category_theory.limits.multiequalizer (S.index P)
{L : first_order.language} {Œ± : Type w} {n : ‚Ñï} [L.is_ordered] (t‚ÇÅ t‚ÇÇ : L.term (Œ± ‚äï fin n)) : L.bounded_formula Œ± n
{p : ‚Ñï} {G : Type u_1} [group G] [hp : fact (nat.prime p)] [fintype (sylow p G)] : mul_action.is_pretransitive G (sylow p G)
{n : ‚Ñï} [fact (0 < n)] (a : zmod n) : ‚Üë(a.val) = a
{M : Type u_1} [hM : monoid M] (h : ‚àÄ (a : M), is_unit a) : group M
{M : Type u_1} [monoid M] {A : Type u_2} [set_like A M] [submonoid_class A M] (S : A) : has_pow ‚Ü•S ‚Ñï
{n : ‚Ñï} (h : n ‚â† 0) (d : ‚Ñï) : ‚àÉ·∂† (m : ‚Ñï) in filter.at_top, m ‚â° d [MOD n]
{C : Type u_1} [category_theory.category C] {F : C ‚•§ category_theory.Cat} (X Y : category_theory.grothendieck F) : Type (max u_3 u_5)
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {b‚ÇÅ b‚ÇÇ : basis Œπ R M} (h : ‚àÄ (x : M) (i : Œπ), ‚áë(‚áë(b‚ÇÅ.repr) x) i = ‚áë(‚áë(b‚ÇÇ.repr) x) i) : b‚ÇÅ = b‚ÇÇ
 : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (F : C ‚•§ D) (G : D ‚•§ E) [category_theory.full (F ‚ãô G)] [category_theory.faithful G] : category_theory.full F
{f : ‚Ñù ‚Üí ‚Ñù} {f' a : ‚Ñù} (h : is_local_min f a) (hf : has_deriv_at f f' a) : f' = 0
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {s : set E} [complete_space F] (h : analytic_on ùïú f s) {n : with_top ‚Ñï} : cont_diff_on ùïú n f s
{Œ± : Type u_1} [metric_space Œ±] {Œ≤ : Type u} [nonempty Œ≤] (p : besicovitch.tau_package Œ≤ Œ±) (i : ordinal) : set Œ±
{o : Type u_4} {m' : o ‚Üí Type u_7} {n' : o ‚Üí Type u_8} {Œ± : Type u_12} [decidable_eq o] [has_zero Œ±] (M : Œ† (i : o), matrix (m' i) (n' i) Œ±) : matrix (Œ£ (i : o), m' i) (Œ£ (i : o), n' i) Œ±
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_ideal R L
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] {L : C ‚•§ D} {R : D ‚•§ C} (adj : L ‚ä£ R) : L.initial
{M : Type u_9} {M‚ÇÇ : Type u_11} [add_comm_group M] [module ‚Ñö M] [add_comm_group M‚ÇÇ] [module ‚Ñö M‚ÇÇ] (f : M ‚Üí+ M‚ÇÇ) : M ‚Üí‚Çó[‚Ñö] M‚ÇÇ
 : principal_seg has_lt.lt has_lt.lt
{Œ± : Type u} : ordnode Œ± ‚Üí ordnode Œ±
{ùíú : Type u_1} [category_theory.category ùíú] {A B C : ùíú} {f : A ‚ü∂ B} {g : B ‚ü∂ C} [category_theory.abelian ùíú] (h : category_theory.short_exact f g) (i : B ‚ü∂ A ‚äû C) (h1 : f ‚â´ i = category_theory.limits.biprod.inl) (h2 : i ‚â´ category_theory.limits.biprod.snd = g) : category_theory.splitting f g
 : nat.arithmetic_function ‚Ñï
(p : ‚Ñï) : Prop
{M‚ÇÄ : Type u_6} [monoid_with_zero M‚ÇÄ] [nontrivial M‚ÇÄ] [no_zero_divisors M‚ÇÄ] {L : list M‚ÇÄ} : L.prod = 0 ‚Üî 0 ‚àà L
{G : Type u_1} [add_group G] (tG : add_monoid.is_torsion G) (H : add_subgroup G) : add_monoid.is_torsion ‚Ü•H
(X : algebraic_geometry.LocallyRingedSpace) : X ‚ü∂ algebraic_geometry.Spec.LocallyRingedSpace_obj (algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X))
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Type (max v u)) : category_theory.limits.cone F
{M : Type u_1} [add_monoid M] [distrib_mul_action ennreal M] : distrib_mul_action nnreal M
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] {a b : Œ±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{ùïú : Type u_1} [linear_ordered_field ùïú] {x y : ùïú} (h : x < y) {z : ùïú} : z ‚àà set.Ioo x y ‚Üî ‚àÉ (a b : ùïú), 0 < a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z
{K : Type u_1} {g : generalized_continued_fraction K} {n m : ‚Ñï} (n_le_m : n ‚â§ m) (terminated_at_n : g.terminated_at n) : g.terminated_at m
{M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ‚àà s) {n : ‚Ñï} : a ^ n ‚àà s
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {s : set E} {x : E} {f' : tangent_space (model_with_corners_self ùïú E) x ‚ÜíL[ùïú] tangent_space (model_with_corners_self ùïú E') (f x)} : has_fderiv_within_at f f' s x ‚Üí has_mfderiv_within_at (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f s x f'
{Œ± : Type u_2} {Œ≤ : Type u_3} [add_comm_monoid Œ±] [add_comm_monoid Œ≤] (A : set Œ±) (n : ‚Ñï) (f : Œ± ‚Üí+ Œ≤) : A ‚Üí+[n] Œ≤
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {s1 : affine_subspace k P} (h : s ‚äÜ ‚Üës1) : span_points k s ‚äÜ ‚Üës1
 : expr ‚Üí list name ‚Üí expr
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] [fintype Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) {w : Œ± ‚Üí M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hb : fintype.card Œ≤ ‚Ä¢ b < finset.univ.sum (Œª (x : Œ±), w x)) : ‚àÉ (y : Œ≤), b < (finset.filter (Œª (x : Œ±), f x = y) finset.univ).sum (Œª (x : Œ±), w x)
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_scalar Œ± Œ≤] : has_scalar Œ± (set Œ≤)
(F : Type u) [field F] (E : Type v) [field E] [algebra F E] [finite_dimensional F E] : (E ‚âÉ‚Çê[F] E) ‚âÉ (E ‚Üí‚Çê[F] E)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [compact_space Œ±] [metric_space Œ≤] {f g : C(Œ±, Œ≤)} {C : ‚Ñù} (C0 : 0 ‚â§ C) : has_dist.dist f g ‚â§ C ‚Üî ‚àÄ (x : Œ±), has_dist.dist (‚áëf x) (‚áëg x) ‚â§ C
(P : pfunctor) {Œ± : Type u_2} {Œ≤ : Type u_3} (f : Œ± ‚Üí Œ≤) : P.obj Œ± ‚Üí P.obj Œ≤
{R : Type u_1} [comm_ring R] (u v w : fin 3 ‚Üí R) : ‚áë(‚áëcross_product u) (‚áë(‚áëcross_product v) w) = ‚áë(‚áëcross_product (‚áë(‚áëcross_product u) v)) w + ‚áë(‚áëcross_product v) (‚áë(‚áëcross_product u) w)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] {R‚ÇÇ : Type u_3} {M‚ÇÇ : Type u_4} [ring R‚ÇÇ] [add_comm_group M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} (x : M) (f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ) (h : ‚áëf x = 0) : M ‚ß∏ submodule.span R {x} ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] : has_coe_to_fun (quadratic_form R M) (Œª (_x : quadratic_form R M), M ‚Üí R)
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [has_zero M‚ÇÅ] [has_scalar ‚Ñï M‚ÇÅ] [has_neg M‚ÇÅ] [has_sub M‚ÇÅ] [has_scalar ‚Ñ§ M‚ÇÅ] [add_comm_group M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (inv : ‚àÄ (x : M‚ÇÅ), f (-x) = -f x) (div : ‚àÄ (x y : M‚ÇÅ), f (x - y) = f x - f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : add_comm_group M‚ÇÅ
(M : Type u_1) [monoid M] : Prop
{Œ± : Type u} [pseudo_metric_space Œ±] (p : Œ± ‚Üí Prop) (x : Œ±) (H : ‚àÉ·∂† (R : ‚Ñù) in filter.at_top, ‚àÄ (y : Œ±), y ‚àà metric.ball x R ‚Üí p y) (y : Œ±) : p y
{C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {G : C ‚•§ D} (‚Ñ± : category_theory.Sheaf J A) {X : A} {U : D} (S : category_theory.sieve U) (x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj ‚Ñ±.val ‚ãô category_theory.coyoneda.obj (opposite.op X)) S.arrows) (Y : category_theory.structured_arrow (opposite.op U) G.op) : category_theory.presieve.family_of_elements ((ùü≠ (C·µí·µñ ‚•§ A)).obj ‚Ñ±.val ‚ãô category_theory.coyoneda.obj (opposite.op X)) (category_theory.presieve.functor_pullback G ‚áë(category_theory.sieve.pullback Y.hom.unop S))
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] : ordnode Œ± ‚Üí ordnode Œ± ‚Üí ordnode Œ±
{Œ± : Type u_1} [has_le Œ±] {s : set Œ±·µí·µà} : is_upper_set s ‚Üí is_lower_set (‚áëorder_dual.to_dual ‚Åª¬π' s)
{C : Type u} [category_theory.category C] : category_theory.discrete punit ‚•§ C ‚âå C
{R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (x : A) (r : R) (y : A) : x * (‚áë(algebra_map R A) r * y) = ‚áë(algebra_map R A) r * (x * y)
{R : Type u_5} [comm_ring R] [is_domain R] {k l : ‚Ñï} (h : k ‚â† l) : disjoint (primitive_roots k R) (primitive_roots l R)
 : Profinite ‚•§ CompHaus
{R : Type u_1} [right_cancel_semigroup R] (g : R) : is_right_regular g
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (t : category_theory.limits.is_terminal X) : category_theory.limits.is_initial (opposite.op X)
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} (hs : is_compact s) {e : ‚Ñù} (he : 0 < e) : ‚àÉ (t : set Œ±) (H : t ‚äÜ s), t.finite ‚àß s ‚äÜ ‚ãÉ (x : Œ±) (H : x ‚àà t), metric.ball x e
(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))
(R : Type u) [ring R] [nontrivial R] [is_noetherian_ring R] : strong_rank_condition R
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : has_zero ‚Ü•S
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [decidable_eq Œπ] [Œ† (i : Œπ), linear_order (Œ± i)] (x y x' y' : Œ† (i : Œπ), Œ± i) : set.Icc x y  set.univ.pi (Œª (i : Œπ), set.Ioo (x' i) (y' i)) ‚äÜ (‚ãÉ (i : Œπ), set.Icc x (function.update y i (x' i))) ‚à™ ‚ãÉ (i : Œπ), set.Icc (function.update x i (y' i)) y
{Œπ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape Œπ) [category_theory.limits.has_zero_object V] [category_theory.limits.has_equalizers V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] [category_theory.limits.has_cokernels V] (i : Œπ) : homotopy_category V c ‚•§ V
{Œ± : Type u_1} : complete_lattice (subtype setoid.is_partition)
 : name ‚Üí tactic expr
 : expr ‚Üí option (list name)
{Œ± : Type u_1} : lazy_list Œ± ‚Üí lazy_list Œ± ‚Üí lazy_list Œ±
(p q : tactic.itauto.prop) : ordering
{Œ± : Type u} [uniform_space Œ±] {f : filter Œ±} {x : Œ±} (hf : cauchy f) (adhs : cluster_pt x f) : f ‚â§ nhds x
(F : Type u_5) (Œ± : out_param (Type u_6)) (Œ≤ : out_param (Type u_7)) [non_assoc_semiring Œ±] [non_assoc_semiring Œ≤] : Type (max u_5 u_6 u_7)
{Œ± : Type u} [decidable_eq Œ±] (xs : list Œ±) (h : ‚àÄ (x : Œ±), x ‚àà xs) : fin_enum Œ±
{R : Type u_1} [comm_semiring R] {A : Type u_2} [comm_semiring A] [algebra R A] {M : Type u_3} [add_comm_monoid M] [module A M] [module R M] {N : Type u_4} [add_comm_monoid N] [module A N] [module R N] [is_scalar_tower R A M] [is_scalar_tower R A N] (f : M ‚Üí‚Çó[A] N) : derivation R A M ‚Üí‚Çó[R] derivation R A N
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] : function.injective equiv.perm.cycle_factors_finset
{Œ± : Type u_1} [monoid Œ±] {a : Œ±} {u : Œ±À£} : ‚Üëu ‚à£ a
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] [fintype Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) {b : M} [linear_ordered_comm_ring M] [nonempty Œ≤] (hb : ‚Üë(fintype.card Œ±) ‚â§ fintype.card Œ≤ ‚Ä¢ b) : ‚àÉ (y : Œ≤), ‚Üë((finset.filter (Œª (x : Œ±), f x = y) finset.univ).card) ‚â§ b
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] [complete_space E] (B : E ‚ÜíL‚ãÜ[ùïú] E ‚ÜíL[ùïú] ùïú) : E ‚ÜíL[ùïú] E
{Œ± : Type u_2} [decidable_eq Œ±] {s : finset Œ±} {B : finset (finset Œ±)} {n : ‚Ñï} (h : ‚àÄ (a : Œ±), a ‚àà s ‚Üí (finset.filter (has_mem.mem a) B).card = n) : B.sum (Œª (t : finset Œ±), (s ‚à© t).card) = s.card * n
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {w : Œ± ‚Üí M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : ‚àÄ (y : Œ≤), y ‚àâ t ‚Üí (finset.filter (Œª (x : Œ±), f x = y) s).sum (Œª (x : Œ±), w x) ‚â§ 0) (ht : t.nonempty) (hb : t.card ‚Ä¢ b ‚â§ s.sum (Œª (x : Œ±), w x)) : ‚àÉ (y : Œ≤) (H : y ‚àà t), b ‚â§ (finset.filter (Œª (x : Œ±), f x = y) s).sum (Œª (x : Œ±), w x)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) [complete_space ‚Ü•K] (p : E) : ‚áë(reflection K) (‚áë(reflection K) p) = p
(R : Type u) [comm_ring R] (P : ‚Ü•(algebraic_geometry.prime_spectrum.Top R)) : Type u
{p : ‚Ñï} : summable (Œª (n : ‚Ñï), 1 / ‚Üën ^ p) ‚Üî 1 < p
(ts : interactive.parse interactive.types.pexpr_list_or_texpr) : tactic unit
 : Type
{R‚ÇÅ : Type u_4} [comm_ring R‚ÇÅ] {n : Type w} [fintype n] [decidable_eq n] [invertible 2] (Q : quadratic_form R‚ÇÅ (n ‚Üí R‚ÇÅ)) : R‚ÇÅ
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} (h : ‚àÄ {Œπ : Type u} (Z : Œπ ‚Üí set Œ±), (‚àÄ (i : Œπ), is_closed (Z i)) ‚Üí (s ‚à© ‚ãÇ (i : Œπ), Z i) = ‚àÖ ‚Üí (‚àÉ (t : finset Œπ), (s ‚à© ‚ãÇ (i : Œπ) (H : i ‚àà t), Z i) = ‚àÖ)) : is_compact s
{G : Type w} [topological_space G] [group G] [topological_group G] {K U : set G} (hK : is_compact K) (hU : is_open U) (hKU : K ‚äÜ U) : ‚àÉ (V : set G) (H : V ‚àà nhds 1), V * K ‚äÜ U
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) {J : Type u} [category_theory.category J] {K : J ‚•§ D} (X : C·µí·µñ) (t : ((category_theory.cones J C).obj (K ‚ãô G)).obj X) : (F.op ‚ãô (category_theory.cones J D).obj K).obj X
{Œ± : Type u_1} [preorder Œ±] [nonempty Œ±] [no_min_order Œ±] : infinite Œ±
(Œ± : Type u_1) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{Œì : Type u_1} {R : Type u_2} [partial_order Œì] [add_comm_monoid R] {Œ± : Type u_3} (s : hahn_series.summable_family Œì R Œ±) : hahn_series Œì R
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space ùïú] [finite_dimensional ùïú E] {n : ‚Ñï} {f : E ‚Üí F} : cont_diff ùïú ‚Üë(n + 1) f ‚Üî differentiable ùïú f ‚àß ‚àÄ (y : E), cont_diff ùïú ‚Üën (Œª (x : E), ‚áë(fderiv ùïú f x) y)
{m : Type u} {n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] [fintype m] [decidable_eq m] (A : matrix m m Œ±) (B : matrix m n Œ±) (C : matrix n m Œ±) (D : matrix n n Œ±) [invertible D] : (matrix.from_blocks A B C D).det = D.det * (A - (B.mul (‚Öü D)).mul C).det
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] [finite_dimensional F E] [is_galois F E] : intermediate_field F E ‚âÉo (subgroup (E ‚âÉ‚Çê[F] E))·µí·µà
(M : Type u_5) (N : Type u_6) [add_zero_class M] [add_zero_class N] : M √ó N ‚Üí+ N
(R : Type u_3) [comm_ring R] : mv_polynomial R ‚Ñ§ ‚Üí+* R
(e a0 a : onote) : ‚Ñï ‚Üí ‚Ñï ‚Üí onote
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {Œ± : Type u_2} [add_right_cancel_semigroup Œ±] [has_one Œ±] [decidable_eq Œ±] (X : Œ± ‚Üí V) (d : Œ† (n : Œ±), X n ‚ü∂ X (n + 1)) (sq : ‚àÄ (n : Œ±), d n ‚â´ d (n + 1) = 0) : cochain_complex V Œ±
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [preorder Œ±] [preorder Œ≤] [preorder Œ≥] : (Œ± √ó Œ≤ ‚Üío Œ≥) ‚âÉo (Œ± ‚Üío Œ≤ ‚Üío Œ≥)
{R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M ‚Üí‚Çó[R] M) (p : polynomial R) : ‚áë(polynomial.aeval f) p = ‚áë(polynomial.aeval f) (p %‚Çò f.charpoly)
{X : Top} (F : Top.presheaf (Type v) X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) (sf : Top.presheaf.sheaf_condition_equalizer_products.pi_opens F U) (s : F.obj (opposite.op (supr U))) : F.is_gluing U ((F.pi_opens_iso_sections_family U).hom sf) s ‚Üî Top.presheaf.sheaf_condition_equalizer_products.res F U s = sf
(g : format) (n : ‚Ñï) : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_object C] {B : C} : ‚Üë‚ä• ‚âÖ 0
{C : Type u‚ÇÅ} [category_theory.category C] : C ‚•§ category_theory.ulift_hom C
{Œ± Œ≤ : Type} (ea : computability.fin_encoding Œ±) (eb : computability.fin_encoding Œ≤) (f : Œ± ‚Üí Œ≤) : Type 1
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : differentiable_on ‚Ñù f (interior D)) (hf'_mono : monotone_on (deriv f) (interior D)) : convex_on ‚Ñù D f
{f : ‚Ñï ‚Üí ‚Ñù} (hfa : antitone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) : cauchy_seq (Œª (n : ‚Ñï), (finset.range (n + 1)).sum (Œª (i : ‚Ñï), (-1) ^ i * f i))
(R‚ÇÅ : Type u_1) [semiring R‚ÇÅ] (M‚ÇÅ : Type u_4) [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] : M‚ÇÅ ‚âÉL[R‚ÇÅ] M‚ÇÅ
{Œ± : Type u} [non_unital_comm_ring Œ±] {b c x : Œ±} (h : x * x - b * x + c = 0) : ‚àÉ (y : Œ±), y * y - b * y + c = 0 ‚àß x + y = b ‚àß x * y = c
{Œ≤ : Type u_2} [ordered_add_comm_group Œ≤] [module ‚Ñù Œ≤] [ordered_smul ‚Ñù Œ≤] {f : ‚Ñù ‚Üí Œ≤} {a b : ‚Ñù} (a_lt_b : a < b) (h_local_min : is_local_min_on f (set.Icc a b) a) (h_conv : convex_on ‚Ñù (set.Icc a b) f) : is_min_on f (set.Icc a b) a
{R‚ÇÇ : Type u_5} {M‚ÇÇ : Type u_6} [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] (f : M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] R‚ÇÇ) : bilin_form R‚ÇÇ M‚ÇÇ
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] {N : Type u_3} [monoid N] (f g : free_product M ‚Üí* N) (h : ‚àÄ (i : Œπ), f.comp free_product.of = g.comp free_product.of) : f = g
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} (l : list Œπ) (f : Œ† (i : Œπ), Œ± i) : list.tprod Œ± l
{p : ‚Ñï} {R : Type u_1} [comm_ring R] (P : ‚Ñï ‚Üí Prop) (x : witt_vector p R) : witt_vector p R
{M : Type u_1} [has_mul M] {c d : con M} : (‚àÄ (x y : M), ‚áëc x y ‚Üî ‚áëd x y) ‚Üî c = d
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_3} (l : Œπ ‚Üí‚ÇÄ ùïú) (v : Œπ ‚Üí E) (x : E) : has_inner.inner x (l.sum (Œª (i : Œπ) (a : ùïú), a ‚Ä¢ v i)) = l.sum (Œª (i : Œπ) (a : ùïú), a ‚Ä¢ has_inner.inner x (v i))
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : local_homeomorph E F) {f' : E ‚âÉL[ùïú] F} {a : F} (ha : a ‚àà f.to_local_equiv.target) (htff' : has_fderiv_at ‚áëf ‚Üëf' (‚áë(f.symm) a)) : has_fderiv_at ‚áë(f.symm) ‚Üë(f'.symm) a
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [bornology Œ±] [bornology Œ≤] [bornology Œ≥] (f : locally_bounded_map Œ≤ Œ≥) (g : locally_bounded_map Œ± Œ≤) : locally_bounded_map Œ± Œ≥
(J : Type v) (X Y : category_theory.limits.wide_pullback_shape J) : (X ‚ü∂ Y) ‚Üí (opposite.op X ‚ü∂ opposite.op Y)
{M : Type u_1} (S : set M) [add_monoid M] : add_submonoid M
(p : ‚Ñï) : ‚Ñï
{Œ± : Type u_1} (r : setoid Œ±) : setoid.mk_classes r.classes setoid.classes_eqv_classes = r
{Œ± : Type u_1} [preorder Œ±] (lo : with_bot Œ±) (t : ordnode Œ±) (hi : with_top Œ±) : Prop
{Œ± : Type u_2} [preorder Œ±] : ‚Ü•set.univ ‚âÉo Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (X : category_theory.center C) : X.tensor_obj category_theory.center.tensor_unit ‚âÖ X
{Œ± : Type u_1} {Œ≤ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] {C : set (set Œ±)} {D : set (set Œ≤)} (hC : measurable_space.generate_from C = _inst_1) (hD : measurable_space.generate_from D = _inst_3) (h2C : is_countably_spanning C) (h2D : is_countably_spanning D) : measurable_space.generate_from (set.image2 has_set_prod.prod C D) = prod.measurable_space
(a : ‚Ñù) : cardinal.mk ‚Ü•(set.Ici a) = cardinal.continuum
{R : Type u} {M : Type v} [has_scalar R M] (p : sub_mul_action R M) (s : set M) (hs : s = ‚Üëp) : sub_mul_action R M
 : list expr ‚Üí tactic unit
 : native.rb_set linarith.pcomp
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y) : same_ray R y x
{p : polynomial ‚Ñö} (p_irr : irreducible p) (p_deg : nat.prime p.nat_degree) (p_roots : fintype.card ‚Ü•(p.root_set ‚ÑÇ) = fintype.card ‚Ü•(p.root_set ‚Ñù) + 2) : function.bijective ‚áë(polynomial.gal.gal_action_hom p ‚ÑÇ)
{R : Type u} [comm_ring R] (f : polynomial R) (x y : R) : {k // polynomial.eval (x + y) f = polynomial.eval x f + polynomial.eval x (‚áëpolynomial.derivative f) * y + k * y ^ 2}
{M : Type u_6} {N : Type u_7} [has_add M] [has_add N] (e : M ‚âÉ+ N) (x : M) : ‚áë(e.symm) (‚áëe x) = x
(E : Type u_4) [non_unital_normed_ring E] [star_ring E] : Prop
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) [category_theory.limits.has_colimit F] : category_theory.limits.colimit_cocone F
(G : Type u_1) [add_group G] [topological_space G] : Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_binary_products C] : category_theory.symmetric_category C
{C : Type u} [category_theory.category C] {X Y : C} (J : category_theory.grothendieck_topology C) (f : Y ‚ü∂ X) : J.cover X ‚•§ J.cover Y
{Œ± : Type u} {Œ≤ : Type v} [decidable_eq Œ±] [decidable_eq Œ≤] (a : Œ±) (b : Œ≤) : Œ± ‚âÉ. Œ≤
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] (f : R ‚Üí+* S) : R ‚Üí‚Çê[‚Ñï] S
(Œ± : Type u_2) [bornology Œ±] : locally_bounded_map Œ± Œ±
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÅ) [category_theory.category D] : C ‚äï D ‚•§ D ‚äï C
(Œ± : Type u_3) [measurable_space Œ±] (M : Type u_4) [add_comm_monoid M] [topological_space M] : Type (max u_3 u_4)
 : user_attribute (name_map ‚Ñï) ‚Ñï
{Œ± : Type u} : ‚Ñï ‚Üí seq Œ± ‚Üí list Œ± √ó seq Œ±
{Œ± : Type u_1} [linear_ordered_field Œ±] {a b : Œ±} (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b ‚Üî b < a
 : tactic unit
{n : ‚Ñï} (c : composition_as_set n) : ‚Ñï
{ùïú : Type u_1} {E : Type u_2} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] {s : set E} : convex ùïú s ‚Üî ‚àÄ ‚¶Éx y : E‚¶Ñ, x ‚àà s ‚Üí y ‚àà s ‚Üí ‚àÄ ‚¶Éa b : ùïú‚¶Ñ, 0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí 0 < a + b ‚Üí (a / (a + b)) ‚Ä¢ x + (b / (a + b)) ‚Ä¢ y ‚àà s
{Œ± : Type u_1} (s : set Œ±) (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop
{Œì : Type u_1} [inhabited Œì] {l l‚ÇÅ l‚ÇÇ : list Œì} (h‚ÇÅ : turing.blank_extends l l‚ÇÅ) (h‚ÇÇ : turing.blank_extends l l‚ÇÇ) : {l' // turing.blank_extends l‚ÇÅ l' ‚àß turing.blank_extends l‚ÇÇ l'}
 : onote
{Œ± : Type u_2} [preorder Œ±] [no_max_order Œ±] : filter.at_top ‚â§ filter.cofinite
(x : expr) : tactic unit
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] {R : Type u_1} [non_assoc_semiring R] {f : Œ† (k : ‚Ñï), R ‚Üí+* zmod (p ^ k)} (f_compat : ‚àÄ (k1 k2 : ‚Ñï) (hk : k1 ‚â§ k2), (zmod.cast_hom _ (zmod (p ^ k1))).comp (f k2) = f k1) (n : ‚Ñï) : (padic_int.to_zmod_pow n).comp (padic_int.lift f_compat) = f n
 : linarith.comp_source ‚Üí native.rb_map ‚Ñï ‚Ñï
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)} [nonempty J] {s t : category_theory.limits.trident f} (k : s.X ‚ü∂ t.X) (w : k ‚â´ t.Œπ = s.Œπ) : s ‚ü∂ t
{Œ± : Type u_1} [linear_ordered_field Œ±] {Œ≤ : Type u_2} [comm_ring Œ≤] {abv : Œ≤ ‚Üí Œ±} [is_absolute_value abv] : Type u_2
{Œ± : Type u_1} [metric_space Œ±] {K : nnreal} (f : Œ± ‚Üí Œ±) (hf : contracting_with K f) [nonempty Œ±] [complete_space Œ±] : Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {T : D} {Y : C} {S : C ‚•§ D} (f : S.obj Y ‚ü∂ T) : category_theory.costructured_arrow S T
{Œ± : Type u_2} {G : Type u_6} [comm_monoid Œ±] [comm_group G] {A : set Œ±} {n : ‚Ñï} : has_div (A ‚Üí*[n] G)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_ideal R L
{G‚ÇÅ : Type u_3} {G‚ÇÇ : Type u_4} {G‚ÇÉ : Type u_5} [group G‚ÇÅ] [group G‚ÇÇ] [group G‚ÇÉ] (f : G‚ÇÅ ‚Üí* G‚ÇÇ) (f_inv : G‚ÇÇ ‚Üí G‚ÇÅ) (hf : function.right_inverse f_inv ‚áëf) (g : G‚ÇÅ ‚Üí* G‚ÇÉ) (hg : f.ker ‚â§ g.ker) : G‚ÇÇ ‚Üí* G‚ÇÉ
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} (h : f = g) : category_theory.limits.cofork f g
{Œ± : Type u} [group_with_zero Œ±] {a : Œ±} (h : a ‚â† 0) : invertible a
{Œ≤ : Type u} {Œ± : Type v} [comm_monoid Œ≤] {p : Œ± ‚Üí Prop} {s : finset {x // p x}} {f : {x // p x} ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (h : ‚àÄ (x : {x // p x}), x ‚àà s ‚Üí g ‚Üëx = f x) : (finset.map (function.embedding.subtype (Œª (x : Œ±), p x)) s).prod (Œª (x : Œ±), g x) = s.prod (Œª (x : {x // p x}), f x)
(G : Type u_1) [topological_space G] [has_div G] : Prop
{Œ± : Type u} : ordnode Œ± ‚Üí bool
{Œ± : Type u_2} {Œπ : Type u_5} [add_comm_monoid Œ±] [fintype Œπ] (f : Œπ ‚Üí set Œ±) (a : Œ±) : a ‚àà finset.univ.sum (Œª (i : Œπ), f i) ‚Üî ‚àÉ (g : Œπ ‚Üí Œ±) (hg : ‚àÄ (i : Œπ), g i ‚àà f i), finset.univ.sum (Œª (i : Œπ), g i) = a
{G : Type u_1} [group G] (H K : subgroup G) (q : doset.quotient ‚ÜëH ‚ÜëK) : set G
{Œ≥ : Type} : widget_override.interactive_expression.sf ‚Üí tactic (widget_override.interactive_expression.sf √ó list (widget.attr Œ≥))
{Œ± : Type u} [decidable_eq Œ±] (xs : list (Œ± √ó Œ±)) (x : Œ±) : Œ±
{R : Type u_1} [semiring R] (r : R) (f : polynomial R) (n : ‚Ñï) : (‚áë(polynomial.taylor r) f).coeff n = polynomial.eval r (‚áë(polynomial.hasse_deriv n) f)
{p : ‚Ñï ‚Üí Prop} : (‚àÉ (x : ‚Ñï), p x) ‚Üí well_founded (nat.upto.gt p)
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (g : B ‚ü∂ C) [category_theory.limits.has_kernels V] [category_theory.limits.has_zero_object V] [category_theory.mono g] : category_theory.epi (image_to_kernel 0 g _)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] {X : C} (t : category_theory.limits.is_terminal X) : 0 ‚âÖ X
(R : Type u_1) [ring R] (M : Type u_2) [add_comm_group M] [module R M] : Prop
{Œ± : Type u_1} : cycle Œ±
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] [normed_group F] [normed_space ‚Ñù F] [topological_space.second_countable_topology F] (f : E ‚Üí F) (s : set E) (f' : E ‚Üí (E ‚ÜíL[‚Ñù] F)) (hf' : ‚àÄ (x : E), x ‚àà s ‚Üí has_fderiv_within_at f (f' x) s x) (r : (E ‚ÜíL[‚Ñù] F) ‚Üí nnreal) (rpos : ‚àÄ (A : E ‚ÜíL[‚Ñù] F), r A ‚â† 0) : ‚àÉ (t : ‚Ñï ‚Üí set E) (A : ‚Ñï ‚Üí (E ‚ÜíL[‚Ñù] F)), (‚àÄ (n : ‚Ñï), is_closed (t n)) ‚àß (s ‚äÜ ‚ãÉ (n : ‚Ñï), t n) ‚àß (‚àÄ (n : ‚Ñï), approximates_linear_on f (A n) (s ‚à© t n) (r (A n))) ‚àß (s.nonempty ‚Üí ‚àÄ (n : ‚Ñï), ‚àÉ (y : E) (H : y ‚àà s), A n = f' y)
(print_use : interactive.parse (lean.parser.tk "!" *> has_pure.pure bool.tt <|> has_pure.pure bool.ff)) (n : interactive.parse (optional lean.parser.ident)) (vs : interactive.parse (optional (lean.parser.tk "with" *> lean.parser.many lean.parser.ident))) : tactic unit
(_x : interactive.parse (lean.parser.tk "setup_tactic_parser")) : lean.parser unit
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Top) : category_theory.limits.is_limit (Top.limit_cone F)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (hG : category_theory.compatible_preserving K G) (‚Ñ± : category_theory.SheafOfTypes K) {Z : C} {T : category_theory.presieve Z} {x : category_theory.presieve.family_of_elements (G.op ‚ãô ‚Ñ±.val) T} (h : x.compatible) : (category_theory.presieve.family_of_elements.functor_pushforward G x).compatible
{Œ± : Type u} [preorder Œ±] [order_top Œ±] {a b : Œ±} (h : a < b) : a ‚â† ‚ä§
{X : Type u_1} [topological_space X] (x : X) (F : set X) : set X
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space F] [complete_space E] {g : E ‚Üí‚Çó[ùïú] F} (hg : is_closed ‚Üë(g.graph)) : E ‚ÜíL[ùïú] F
 : list expr ‚Üí expr ‚Üí expr
{Œ± : Type u} {Œ≤ : Type v} [non_unital_non_assoc_ring Œ±] [has_zero Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.surjective f) (zero : f 0 = 0) (add : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ±), f (-x) = -f x) (sub : ‚àÄ (x y : Œ±), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ±) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : Œ±) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_unital_non_assoc_ring Œ≤
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_cokernel f] : Y ‚ü∂ category_theory.limits.cokernel f
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M ‚Üí* P} (h : c ‚â§ con.ker f) (hf : function.surjective ‚áëf) : function.surjective ‚áë(c.lift f h)
{Œ± : Type u_1} {f g : Œ± ‚Üí ‚Ñù} {t‚ÇÄ : filter Œ±} (hf : ‚àÄ·∂† (t : Œ±) in t‚ÇÄ, 0 ‚â§ f t) (hft : ‚àÄ·∂† (t : Œ±) in t‚ÇÄ, f t ‚â§ g t) (g0 : filter.tendsto g t‚ÇÄ (nhds 0)) : filter.tendsto f t‚ÇÄ (nhds 0)
{Œ± : Type u} (s : computation Œ±) (a : Œ±) : Prop
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] : (M·µê·µí·µñ ‚Üí* N·µê·µí·µñ) ‚âÉ (M ‚Üí* N)
(Œ≤ : Type) (C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.graded_object Œ≤ C ‚•§ C
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {A : C} {B : D} {L : category_theory.mono_over A ‚•§ category_theory.mono_over B} {R : category_theory.mono_over B ‚•§ category_theory.mono_over A} (h : L ‚ä£ R) : category_theory.subobject.lower L ‚ä£ category_theory.subobject.lower R
{Œπ : Type u} {f g : Œπ ‚Üí nnreal} {p q : ‚Ñù} (hpq : p.is_conjugate_exponent q) (hf : summable (Œª (i : Œπ), f i ^ p)) (hg : summable (Œª (i : Œπ), g i ^ q)) : summable (Œª (i : Œπ), f i * g i) ‚àß ‚àë' (i : Œπ), f i * g i ‚â§ (‚àë' (i : Œπ), f i ^ p) ^ (1 / p) * (‚àë' (i : Œπ), g i ^ q) ^ (1 / q)
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (S : category_theory.sieve X) : S.functor ‚ü∂ category_theory.yoneda.obj X
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type w} [fintype Œπ] (h : basis Œπ K V) : finite_dimensional K V
(R : Type w) [ring R] (C : Type u) [category_theory.category C] [category_theory.preadditive C] [category_theory.linear R C] : C·µí·µñ ‚•§ C ‚•§ Module R
{R : Type u_1} {A : Type u_3} [comm_ring R] [ring A] (f : R ‚Üí+* A) : Prop
{Œ± : Type u_1} {s : set Œ±} : s.pairwise ‚ä• ‚Üí s.subsingleton
{Œ± : Type u} {l‚ÇÅ l‚ÇÇ : list Œ±} {n : ‚Ñï} : list.drop n (l‚ÇÅ ++ l‚ÇÇ) = list.drop n l‚ÇÅ ++ list.drop (n - l‚ÇÅ.length) l‚ÇÇ
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Œπ ‚Üí M} [semiring R] [add_comm_monoid M] [module R M] [fintype Œπ] : linear_independent R v ‚Üî (‚áë(linear_map.lsum R (Œª (i : Œπ), R) ‚Ñï) (Œª (i : Œπ), linear_map.id.smul_right (v i))).ker = ‚ä•
{C : Type u} {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (X : C) (i : A) : (category_theory.shift_functor C (-i)).obj ((category_theory.shift_functor C i).obj X) ‚âÖ X
{R : Type u_1} [comm_semiring R] {R' : Type u_2} [monoid R'] {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] [distrib_mul_action R' M] [smul_comm_class R R' M] [has_scalar R' R] [is_scalar_tower R' R M] : is_scalar_tower R' R (tensor_product R M N)
{C : Type u} [category_theory.category C] {X : C} {S R : category_theory.sieve X} (J : category_theory.grothendieck_topology C) (rj : R ‚àà ‚áëJ X) (sj : S ‚àà ‚áëJ X) : R ‚äì S ‚àà ‚áëJ X
(X : algebraic_geometry.Scheme) : X.open_cover
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] (h : category_theory.mono (category_theory.limits.initial.to (‚ä§_ C))) : category_theory.limits.initial_mono_class C
(M : Type u) [semi_normed_group M] : SemiNormedGroup
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f : M ‚Üí+ N) (N' : add_submonoid N) : ‚Ü•(add_submonoid.comap f N') ‚Üí+ ‚Ü•N'
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (X : C) : J.diagram P X ‚ü∂ J.diagram Q X
{p : ‚Ñï} [fact (nat.prime p)] : witt_vector.is_poly‚ÇÇ p (Œª (_x : Type u_1) (_x_1 : comm_ring _x), has_add.add)
{Œ± : Type u} [topological_space Œ±] (s : set Œ±) : set Œ±
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {a : Œ±} {s : set Œ±} (h : a ‚àâ s ‚Üí f a = 1) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà has_insert.insert a s), f i)) = finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i))
{G : Type u} [monoid G] (x : G) : Prop
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {l : filter Œ±} {a : Œ±} : is_extr_filter f l a ‚Üí is_extr_filter (‚áëorder_dual.to_dual ‚àò f) l a
(n : name) : tactic unit
(Œ± : Type u_2) [preorder Œ±] [mul_zero_one_class Œ±] : Œ± ‚Üí*‚ÇÄo Œ±
{gen : Type u} [random_gen gen] (g : gen) : bool √ó gen
 : category_theory.limits.walking_span ‚•§ category_theory.limits.walking_span
{Œ± : Type u_1} {P : Œ± ‚Üí Prop} (h : ‚àÉ (x : Œ±), P x) : {x // P x}
{m n : ‚Ñï} {C : fin (m + n) ‚Üí Sort u} (hleft : Œ† (i : fin m), C (‚áë(fin.cast_add n) i)) (hright : Œ† (i : fin n), C (‚áë(fin.nat_add m) i)) (i : fin (m + n)) : C i
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {f g : X ‚ü∂ Y} (c : category_theory.limits.cofork f g) : category_theory.limits.cokernel_cofork (f - g)
(Œ± : Type u_1) [add_right_cancel_semigroup Œ±] [has_one Œ±] : complex_shape Œ±
{Œ± : Type u} (s : seq Œ±) : Prop
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (k : ‚Ñï) : lie_submodule R L M ‚Üí lie_submodule R L M
{Œ± : Type u_1} (M : Type u_2) (R : Type u_5) [semiring R] [add_comm_monoid M] [module R M] {Œ±' : Type u_7} (f : Œ± ‚Üí Œ±') : (Œ± ‚Üí‚ÇÄ M) ‚Üí‚Çó[R] Œ±' ‚Üí‚ÇÄ M
{M : Type u_1} [add_monoid M] (S : add_submonoid M) : add_monoid ‚Ü•S
 : category_theory.limits.walking_span·µí·µñ ‚âå category_theory.limits.walking_cospan
{R : Type u_1} [semiring R] {x y : R} (h : commute x y) (n : ‚Ñï) : (x + y) ^ n = (finset.range (n + 1)).sum (Œª (m : ‚Ñï), x ^ m * y ^ (n - m) * ‚Üë(n.choose m))
(R : Type u_1) [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] : M ‚Üí‚Çó[R] tensor_algebra R M
{Œ± : Type u_1} [partial_order Œ±] [pred_order Œ±] [is_pred_archimedean Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) {n m : Œ±} (h : ‚àÄ (i : Œ±), i ‚àà set.Ioc m n ‚Üí r i (order.pred i)) (hnm : m < n) : relation.trans_gen r n m
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} (f : Œ† (i : Œπ), filter (Œ± i)) : filter (Œ† (i : Œπ), Œ± i)
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] (f : S.localization_map N) (x : M) (y : ‚Ü•S) : ‚àÉ (c : ‚Ü•S), x * ‚Üë((f.sec (f.mk' x y)).snd) * ‚Üëc = (f.sec (f.mk' x y)).fst * ‚Üëy * ‚Üëc
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {v : set E} (hv : orthonormal ùïú coe) : (‚àÄ (u : set E), u ‚äá v ‚Üí orthonormal ùïú coe ‚Üí u = v) ‚Üî (submodule.span ùïú v)·óÆ = ‚ä•
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : Type u_2
{Œ± : Sort u_1} (h : nonempty Œ±) : erased Œ±
 : environment ‚Üí name ‚Üí option name
{C : Type u} [category_theory.category C] {P Q : C} (t : category_theory.limits.binary_fan P Q) : category_theory.limits.binary_fan Q P
{Œ± : Type u} (p : Œ± ‚Üí Prop) (s : stream Œ±) : Prop
(R : Type u_2) (M : Type u_5) [semiring R] [add_comm_group M] : Type (max u_2 u_5)
{p : ‚Ñï} {G : Type u_1} [group G] {Œ± : Type u_2} [group Œ±] [mul_distrib_mul_action Œ± G] : mul_action Œ± (sylow p G)
{Œ± : Type u} (s : stream Œ±) (n : ‚Ñï) : Œ±
{Œ± : Type u} {Œ≤ : Type v} [group Œ≤] (f : Œ± ‚Üí Œ≤) : list (Œ± √ó bool) ‚Üí Œ≤
 : tactic.ring.horner_expr ‚Üí tactic.ring.ring_m (tactic.ring.horner_expr √ó expr)
{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ‚â† 2) : ‚àÉ (a : F), char.quadratic_char F a = -1
{Œ± : Type u_1} [Œ≤ : non_unital_normed_ring Œ±] : non_unital_semi_normed_ring Œ±
(m k : ‚Ñï+) : ‚Ñï
{R : Type u} [comm_ring R] {J : Type v} [category_theory.small_category J] (F : J ‚•§ Algebra R) : subalgebra R (Œ† (j : J), ‚Ü•(F.obj j))
{G : Type u_1} [add_group G] (H : add_subgroup G) : 0 ‚àà H
{Œ± : Type u_1} (A : finset Œ±) (i : ‚Ñï) (h‚ÇÅ : i ‚â§ A.card) : ‚àÉ (B : finset Œ±), B ‚äÜ A ‚àß B.card = i
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (D : Type w) [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] (X : C) : (C·µí·µñ ‚•§ D) ‚•§ (J.cover X)·µí·µñ ‚•§ D
(pp : linarith.global_preprocessor) : linarith.global_branching_preprocessor
{X Y : œâCPO} (f g : X ‚ü∂ Y) : category_theory.limits.fork f g
{Œ± : Type u} [has_sizeof Œ±] (shrink_a : Œ† (x : Œ±), slim_check.shrink_fn {y // slim_check.sizeof_lt y x} ‚Üí list (lazy_list {y // slim_check.sizeof_lt y x})) : slim_check.shrink_fn Œ±
 : expr ‚Üí list expr ‚Üí expr
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ‚•§ D) [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.enough_projectives C] {X Y : C} (f : X ‚ü∂ Y) (P : category_theory.ProjectiveResolution X) (Q : category_theory.ProjectiveResolution Y) : (F.left_derived 0).map f ‚â´ category_theory.abelian.functor.left_derived_zero_to_self_app F Q = category_theory.abelian.functor.left_derived_zero_to_self_app F P ‚â´ F.map f
(key data : Type) : Type
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C ‚•§ D} {‚Ñ± : D·µí·µñ ‚•§ A} {‚Ñ±' : category_theory.Sheaf K A} (Œ± : G.op ‚ãô ‚Ñ± ‚ü∂ G.op ‚ãô ‚Ñ±'.val) (X : A) : G.op ‚ãô ‚Ñ± ‚ãô category_theory.coyoneda.obj (opposite.op X) ‚ü∂ G.op ‚ãô (category_theory.sheaf_over ‚Ñ±' X).val
(Œ± : Type u_8) (Œ≤ : Type u_9) [has_Inf Œ±] [has_Inf Œ≤] : Type (max u_8 u_9)
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [topological_space Œ±] [pseudo_metric_space Œ≤] [pseudo_metric_space Œ≥] {G : Œ≤ ‚Üí Œ≥} {C : nnreal} (H : lipschitz_with C G) : continuous (bounded_continuous_function.comp G H)
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) : Prop
{M : Type u_1} {N : Type u_2} [preorder M] [has_add M] [has_sub M] [has_ordered_sub M] [partial_order N] [has_add N] [has_sub N] [has_ordered_sub N] (e : M ‚âÉo N) (h_add : ‚àÄ (a b : M), ‚áëe (a + b) = ‚áëe a + ‚áëe b) (a b : M) : ‚áëe (a - b) = ‚áëe a - ‚áëe b
{X : Top} (U : topological_space.opens ‚Ü•X) (R : category_theory.presieve U) (hR : category_theory.sieve.generate R ‚àà ‚áë(opens.grothendieck_topology ‚Ü•X) U) : supr (Top.presheaf.covering_of_presieve U R) = U
{Œ± Œ≤ : Type u} (e : Œ± ‚âÉ Œ≤) : cardinal.mk Œ± = cardinal.mk Œ≤
(u : ‚Ñï ‚Üí ‚Ñù) (l : ‚Ñù) (hmono : monotone u) (hlim : ‚àÄ (a : ‚Ñù), 1 < a ‚Üí (‚àÉ (c : ‚Ñï ‚Üí ‚Ñï), (‚àÄ·∂† (n : ‚Ñï) in filter.at_top, ‚Üë(c (n + 1)) ‚â§ a * ‚Üë(c n)) ‚àß filter.tendsto c filter.at_top filter.at_top ‚àß filter.tendsto (Œª (n : ‚Ñï), u (c n) / ‚Üë(c n)) filter.at_top (nhds l))) : filter.tendsto (Œª (n : ‚Ñï), u n / ‚Üën) filter.at_top (nhds l)
{M : Type u} {N : Type v} [add_monoid M] [add_monoid N] (f : M ‚Üí+ N) (g : M ‚Üí add_units N) (h : ‚àÄ (x : M), ‚Üë(g x) = ‚áëf x) : M ‚Üí+ add_units N
{M : Type uM} {N : Type uN} [mul_one_class M] [comm_monoid N] : comm_monoid (M ‚Üí* N)
{E : Type u_3} [semi_normed_group E] (x : E) : E ‚âÉ·µ¢ E
(major_premise : interactive.parse tactic.interactive.cases_arg_p) (with_patterns : interactive.parse tactic.eliminate.with_pattern.clause_parser) : tactic unit
{ùïú : Type u_1} {E : Type u_3} [ordered_semiring ùïú] [topological_space E] [add_cancel_comm_monoid E] [has_continuous_add E] [module ùïú E] {s : set E} (hs : strict_convex ùïú s) (z : E) : strict_convex ùïú ((Œª (x : E), x + z) ‚Åª¬π' s)
(c f‚ÇÅ f‚ÇÇ : Type u) (r‚ÇÅ r‚ÇÇ : Type v) : first_order.language
{Œ± : Type u} [topological_space Œ±] : dense_range stone_cech_unit
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p1 p2 : P} (hp1 : p1 ‚àà s) (hp2 : p2 ‚àà s) : p1 -·µ• p2 ‚àà vector_span k s
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {s‚ÇÅ : setoid Œ±} {s‚ÇÇ : setoid Œ≤} (q‚ÇÅ : quotient s‚ÇÅ) (q‚ÇÇ : quotient s‚ÇÇ) (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (h : ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ≤) (b‚ÇÅ : Œ±) (b‚ÇÇ : Œ≤), setoid.r a‚ÇÅ b‚ÇÅ ‚Üí setoid.r a‚ÇÇ b‚ÇÇ ‚Üí f a‚ÇÅ a‚ÇÇ = f b‚ÇÅ b‚ÇÇ) : Œ≥
{G : Type u_10} [group G] (a : G) : G ‚âÉ G
{x y : pgame} (h : x.fuzzy y) : x.lf y
{Œ± : Type u} [omega_complete_partial_order Œ±] : Œ± ‚ÜíùíÑ Œ±
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p) ‚àà s
{G : Type u_1} [group G] [is_free_group G] {H : Type u_2} [group H] (f : is_free_group.generators G ‚Üí H) : ‚àÉ! (F : G ‚Üí* H), ‚àÄ (a : is_free_group.generators G), ‚áëF (is_free_group.of a) = f a
{Œ± Œ≤ : Type} (tac1 : tactic Œ±) (tac2 : Œ± ‚Üí tactic Œ≤) : tactic (list Œ≤)
(ns : interactive.parse (lean.parser.many lean.parser.ident)) : tactic unit
(p : omega.int.preform) : Prop
 : tactic string
 : format
{C : Type u} [category_theory.category C] (F : C ‚•§ Type w) : F.elements ‚•§ category_theory.structured_arrow punit F
{Œ± : Type u_1} {Œπ : Type u_3} {Œπ' : Type u_4} [distrib_lattice Œ±] [order_bot Œ±] [decidable_eq Œπ] {s : finset Œπ'} {g : Œπ' ‚Üí finset Œπ} {f : Œπ ‚Üí Œ±} (hs : s.sup_indep (Œª (i : Œπ'), (g i).sup f)) (hg : ‚àÄ (i' : Œπ'), i' ‚àà s ‚Üí (g i').sup_indep f) : (s.bUnion g).sup_indep f
{Œ± : Type u_1} [canonically_ordered_add_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b c : Œ±} [contravariant_class Œ± Œ± has_add.add has_le.le] [contravariant_class Œ± Œ± has_add.add has_lt.lt] (h‚ÇÅ : b ‚â§ a) (h‚ÇÇ : c ‚â§ a) : a - b < a - c ‚Üî c < b
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {T : E ‚ÜíL[ùïú] E} (hT : inner_product_space.is_self_adjoint ‚ÜëT) (x : E) : ‚Üë(T.re_apply_inner_self x) = has_inner.inner (‚áëT x) x
{Œ± : Type} : parse_result Œ± ‚Üí ‚Ñï
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] {Z : D} (F : C ‚•§ D) (M : Œ† (x : C), Z ‚ü∂ F.obj x) (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), M x ‚â´ F.map f = M y) : category_theory.with_initial.incl ‚ãô category_theory.with_initial.lift F M hM ‚âÖ F
(n : Type u) [decidable_eq n] [fintype n] (R : Type v) [comm_ring R] : Type (max u v)
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_unital_non_assoc_semiring Œ±} {rŒ≤ : non_unital_non_assoc_semiring Œ≤} (f : Œ± ‚Üí‚Çô+* Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : Œ± ‚Üí‚Çô+* Œ≤
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) (b : Œ≤ a) (l : list (sigma Œ≤)) : list (sigma Œ≤)
{X : Type u} {Y : Type v} {Z : Type w} [nonempty Z] [metric_space Z] [metric_space X] [metric_space Y] {Œ¶ : Z ‚Üí X} {Œ® : Z ‚Üí Y} (hŒ¶ : isometry Œ¶) (hŒ® : isometry Œ®) : pseudo_metric_space (X ‚äï Y)
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] {Z : D} (F : C ‚•§ D) (hZ : category_theory.limits.is_terminal Z) (G : category_theory.with_terminal C ‚•§ D) (h : category_theory.with_terminal.incl ‚ãô G ‚âÖ F) (hG : G.obj category_theory.with_terminal.star ‚âÖ Z) : G ‚âÖ category_theory.with_terminal.lift_to_terminal F hZ
 : bounded_random ‚Ñ§
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A ‚ü∂ B) [category_theory.limits.has_image f] (g : B ‚ü∂ C) [category_theory.limits.has_kernel g] (w : f ‚â´ g = 0) [category_theory.limits.has_cokernel (image_to_kernel f g w)] : V
{ùïú : Type u_1} {X : Type u_2} [is_R_or_C ùïú] [topological_space X] (A : subalgebra ‚Ñù C(X, ùïú)) : Prop
{C : Type u} [category_theory.category C] {X : C} {s : category_theory.limits.cone (category_theory.functor.empty C)} (P : category_theory.limits.is_limit s) {t : category_theory.limits.binary_fan s.X X} (Q : category_theory.limits.is_limit t) : t.X ‚âÖ X
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] : CommMon_ C
{Œ± : Type u_1} {Œ≤ : Type u_2} {e e' : local_equiv Œ± Œ≤} (h : e ‚âà e') : e.target = e'.target
{X : Type u} {Y : Type v} [preorder X] [preorder Y] {l : X ‚Üí Y} {u : Y ‚Üí X} (gc : galois_connection l u) : _.functor ‚ä£ _.functor
{Œ± : Type u_1} (g : generalized_continued_fraction Œ±) (n : ‚Ñï) : decidable (g.terminated_at n)
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M ‚Üí* P} (hg : ‚àÄ (y : ‚Ü•S), is_unit (‚áëg ‚Üëy)) (z : N) (v : P) : ‚áë(f.lift hg) z = v ‚Üî ‚áëg (f.sec z).fst = ‚áëg ‚Üë((f.sec z).snd) * v
(Œπ : Type u_1) [fintype Œπ] : metric.bounded (std_simplex ‚Ñù Œπ)
(e : expr) : tactic expr
{R : Type u} {Œπ : Type u'} {M‚ÇÇ : Type v‚ÇÇ} {M' : Type v'} [decidable_eq Œπ] [comm_semiring R] [add_comm_monoid M'] [add_comm_monoid M‚ÇÇ] [module R M'] [module R M‚ÇÇ] {Œπ' : Type u_1} [decidable_eq Œπ'] [decidable_eq (Œπ ‚äï Œπ')] (f : multilinear_map R (Œª (x : Œπ), M') (multilinear_map R (Œª (x : Œπ'), M') M‚ÇÇ)) : multilinear_map R (Œª (x : Œπ ‚äï Œπ'), M') M‚ÇÇ
 : Preorder ‚•§ category_theory.Cat
(l : Type u_4) (R : Type u‚ÇÇ) [decidable_eq l] [comm_ring R] : matrix (l ‚äï l) (l ‚äï l) R
{Œ± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {s t : set Œ±} (hs : s.finite) (ht : t.finite) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s ‚à™ t), f i)) * finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s ‚à© t), f i)) = finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà s), f i)) * finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà t), f i))
{A : Type u_4} [comm_ring A] [is_domain A] {K : Type u_5} {B : Type u_6} [comm_ring B] [is_domain B] [field K] {L : Type u_7} [field L] [algebra A K] [is_fraction_ring A K] [algebra B L] [is_fraction_ring B L] (h : A ‚âÉ+* B) : K ‚âÉ+* L
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ (v‚ÇÇ+1))
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {P Q : C} (f : P ‚ü∂ Q) : P ‚ü∂ category_theory.abelian.coimage f
 : Type
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} [is_well_order Œ≤ s] (f : initial_seg r s) : principal_seg r s ‚äï (r ‚âÉr s)
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : local_equiv Œ± Œ≤) (f : Œ± ‚Üí Œ≤) (hf : ‚áëe = f) (g : Œ≤ ‚Üí Œ±) (hg : ‚áë(e.symm) = g) (s : set Œ±) (hs : e.source = s) (t : set Œ≤) (ht : e.target = t) : local_equiv Œ± Œ≤
{o : Type u_4} {m' : o ‚Üí Type u_7} {n' : o ‚Üí Type u_8} {Œ± : Type u_12} (M : matrix (Œ£ (i : o), m' i) (Œ£ (i : o), n' i) Œ±) (k : o) : matrix (m' k) (n' k) Œ±
 : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
(Œπ : Type u_1) [decidable_eq Œπ] {R : Type u_2} [add_comm_monoid Œπ] [comm_semiring R] : direct_sum.gcomm_semiring (Œª (i : Œπ), R)
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S : set E) {K : subfield E} (HF : set.range ‚áë(algebra_map F E) ‚äÜ ‚ÜëK) (HS : S ‚äÜ ‚ÜëK) : (intermediate_field.adjoin F S).to_subfield ‚â§ K
{Œ± : Type u_1} [comm_semiring Œ±] (E : linear_recurrence Œ±) (u : ‚Ñï ‚Üí Œ±) : E.is_solution u ‚Üî u ‚àà E.sol_space
(R : Type u) [comm_ring R] [is_domain R] (n : ‚Ñï) : is_domain (mv_polynomial (fin n) R)
{M : Type u_1} [comm_monoid M] {S : submonoid M} {p : Sort u} (x y : localization S) (f : M ‚Üí ‚Ü•S ‚Üí M ‚Üí ‚Ü•S ‚Üí p) (H : ‚àÄ {a a' : M} {b b' : ‚Ü•S} {c c' : M} {d d' : ‚Ü•S}, ‚áë(localization.r S) (a, b) (a', b') ‚Üí ‚áë(localization.r S) (c, d) (c', d') ‚Üí f a b c d = f a' b' c' d') : p
{Œ± : Type u_1} [uniform_space Œ±] {s : set (Œ± √ó Œ±)} (hs : s ‚àà uniformity Œ±) : ‚àÉ (t : set (Œ± √ó Œ±)) (H : t ‚àà uniformity Œ±), symmetric_rel t ‚àß comp_rel t t ‚äÜ s
{Œ± : Type u} : ordnode Œ± ‚Üí ordnode Œ± ‚Üí ordnode Œ±
{Œ± : Type u_1} [decidable_eq Œ±] : has_inter (finset Œ±)
(ùïú : Type u_1) {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] (s : set E) (f : E ‚Üí Œ≤) : Prop
{M : Type u_1} [has_add M] : has_mem (M √ó M) (add_con M)
{Œ± : Type u_1} [decidable_eq Œ±] (l : list Œ±) (x : Œ±) (h : x ‚àà l) : Œ±
(R‚ÇÅ : Type u_1) [semiring R‚ÇÅ] (M‚ÇÅ : Type u_4) [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] (M‚ÇÇ : Type u_6) [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÅ M‚ÇÇ] : M‚ÇÇ ‚ÜíL[R‚ÇÅ] M‚ÇÅ √ó M‚ÇÇ
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_zero M] [has_zero N] : Type (max u_10 u_11 u_9)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} (i : (homotopy_category.quotient V c).obj C ‚âÖ (homotopy_category.quotient V c).obj D) : homotopy_equiv C D
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) : ‚áë(s.affine_combination p) w = ‚áë(s.weighted_vsub_of_point p (classical.choice add_torsor.nonempty)) w +·µ• classical.choice add_torsor.nonempty
(M : Type u_1) (Œ± : Type u_6) [add_monoid M] [add_action M Œ±] : Œ± ‚Ü™ M ‚Üí Œ±
{p : ‚Ñï} [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] {a : kÀ£} {A : witt_vector p k} (hA : A.coeff 0 = ‚Üëa) : (witt_vector p k)À£
{Œ± : Type u_1} [add_right_cancel_semigroup Œ±] (a : Œ±) : complex_shape Œ±
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {P Q : C} (f : P ‚ü∂ Q) : category_theory.abelian.image f ‚ü∂ Q
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (G : D ‚•§ C) {F : C ‚•§ D} (h : F ‚ä£ G) (A : C) : category_theory.limits.is_initial (category_theory.structured_arrow.mk (h.unit.app A))
{n m : ‚Ñï} (h : n = m) : (fin.cast h).to_equiv = equiv.cast _
{Œ± : Type u} [complete_lattice Œ±] : (Œ± ‚Üío Œ±) ‚Üío Œ±
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {C : ‚Ñù} (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí has_dist.dist x y ‚â§ C) : emetric.diam s ‚â§ ennreal.of_real C
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Ring) : category_theory.limits.cocone F
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [linear_ordered_add_comm_monoid_with_top Œì‚ÇÄ] [comm_ring R] (v : add_valuation R Œì‚ÇÄ) {J : ideal R} (hJ : J ‚â§ v.supp) : R ‚ß∏ J ‚Üí Œì‚ÇÄ
{et : tactic.ring_exp.ex_type} : tactic.ring_exp.ex et ‚Üí tactic.ring_exp.ring_exp_m (expr √ó expr)
 : ‚Ñù ‚ÜíL[‚Ñù] ‚ÑÇ
{J : Type u‚ÇÅ} [category_theory.category J] [category_theory.is_connected J] (j‚ÇÅ j‚ÇÇ : J) : category_theory.zigzag j‚ÇÅ j‚ÇÇ
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] : Mon_ C ‚•§ C
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : Œ± ‚âÉ‚Çú Œ≤) {b : Œ≤} {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} : f =o[nhds b] g ‚Üî (f ‚àò ‚áëe) =o[nhds (‚áë(e.symm) b)] (g ‚àò ‚áëe)
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} (h : totally_bounded s) : metric.bounded s
(Œ± : Type u) {Œ≤ : Type v} [add_monoid Œ±] [add_action Œ± Œ≤] (b : Œ≤) : add_submonoid Œ±
{Œ≤ : Type w} {C : Type u} [category_theory.category C] {f g : Œ≤ ‚Üí C} [category_theory.limits.has_product f] [category_theory.limits.has_product g] (p : Œ† (b : Œ≤), f b ‚ü∂ g b) : ‚àè f ‚ü∂ ‚àè g
{Œ± : Type u_1} [topological_space Œ±] [semiring Œ±] [topological_semiring Œ±] [t2_space Œ±] (s : subsemiring Œ±) (hs : ‚àÄ (x y : ‚Ü•s), x * y = y * x) : comm_semiring ‚Ü•(s.topological_closure)
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] {ùíú : ‚Ñï ‚Üí submodule R A} [graded_algebra ùíú] (x : projective_spectrum ùíú) : homogeneous_ideal ùíú
{Œ± : Type u_1} {Œ≤ : Type u_2} {mŒ≤ : measurable_space Œ≤} {m : measurable_space Œ±} {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {p : ‚Ñï ‚Üí Œ± ‚Üí Prop} [Œ† (n : ‚Ñï), decidable_pred (p n)] (hf : ‚àÄ (n : ‚Ñï), measurable (f n)) (hp : ‚àÄ (n : ‚Ñï), measurable_set {x : Œ± | p n x}) (h : ‚àÄ (x : Œ±), ‚àÉ (n : ‚Ñï), p n x) : measurable (Œª (x : Œ±), f (nat.find _) x)
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : matrix.special_linear_group n R ‚Üí* linear_map.general_linear_group R (n ‚Üí R)
{E : Type u_1} {Œ≤ : Type u_2} [add_comm_group E] [topological_space E] [module ‚Ñù E] [topological_add_group E] [has_continuous_smul ‚Ñù E] [ordered_add_comm_group Œ≤] [module ‚Ñù Œ≤] [ordered_smul ‚Ñù Œ≤] {f : E ‚Üí Œ≤} {a : E} (h_local_min : is_local_min f a) (h_conv : convex_on ‚Ñù set.univ f) (x : E) : f a ‚â§ f x
{R : Type u} [ring R] {J : Type w} [category_theory.category J] (F : J ‚•§ Module R) (s : category_theory.limits.cocone F) : Module.colimits.colimit_type F ‚Üí ‚Ü•(s.X)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (Œπ : Type u_1) [unique Œπ] (h : finite_dimensional.finrank K V = 1) : basis Œπ K V
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (Œ± : F ‚ü∂ G) [‚àÄ (X : C), category_theory.is_iso (Œ±.app X)] : category_theory.is_iso Œ±
(red : interactive.parse (optional (lean.parser.tk "!"))) : conv unit
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] {a : Œ±} : 1 ‚â§ a‚Åª¬π ‚Üî a ‚â§ 1
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_equalizer f g] : ‚Üë(category_theory.limits.equalizer_subobject f g) ‚âÖ category_theory.limits.equalizer f g
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x : V) : 2 ‚Ä¢ hb.oangle x (-x) = 0
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] {J : Type v} [fintype J] {f : J ‚Üí C} [category_theory.limits.preserves_limit (category_theory.discrete.functor f) F] : category_theory.limits.preserves_biproduct f F
{Œ± : Type u_1} [linear_ordered_ring Œ±] : subsingleton (floor_ring Œ±)
{ùïú : Type u_1} {V : Type u_2} [normed_field ùïú] [add_comm_group V] [module ùïú V] (e : enorm ùïú V) : metric_space ‚Ü•(e.finite_subspace)
(M : Type u) : Type u
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Œπ ‚Üí M} [ring R] [add_comm_group M] [module R M] (hv : linear_independent R v) : (Œπ ‚Üí‚ÇÄ R) ‚âÉ‚Çó[R] ‚Ü•(submodule.span R (set.range v))
(N : ‚Ñï) {j : ‚Ñù} (hj : 0 < j) {c : ‚Ñù} (hc : 1 < c) : (finset.filter (Œª (i : ‚Ñï), j < c ^ i) (finset.range N)).sum (Œª (i : ‚Ñï), 1 / (c ^ i) ^ 2) ‚â§ c ^ 3 * (c - 1)‚Åª¬π / j ^ 2
(l : multiset ‚Ñï) : l.sum.partition
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (l‚ÇÅ l‚ÇÇ : Œπ ‚Üí‚ÇÄ ùïú) : has_inner.inner (‚áë(finsupp.total Œπ E ùïú v) l‚ÇÅ) (‚áë(finsupp.total Œπ E ùïú v) l‚ÇÇ) = l‚ÇÇ.sum (Œª (i : Œπ) (y : ùïú), ‚áë(star_ring_end ùïú) (‚áël‚ÇÅ i) * y)
(R : Type u) [non_assoc_semiring R] : ‚Ñï
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] {X Y Z : C} (a : X ‚ü∂ Y) (b : X ‚ü∂ Z) [category_theory.epi a] [category_theory.epi b] : category_theory.limits.has_colimit (category_theory.limits.span a b)
{n m : ‚Ñï} (h : ‚àÄ (i : ‚Ñï), n.test_bit i = m.test_bit i) : n = m
{Œ± : Type u} {Œ≤ : Type v} [uniform_space Œ±] [semilattice_sup Œ≤] {u : Œ≤ ‚Üí Œ±} (hu : cauchy_seq u) {Œπ : Type u_1} {f : Œπ ‚Üí Œ≤} {p : filter Œπ} [p.ne_bot] (hf : filter.tendsto f p filter.at_top) {a : Œ±} (ha : filter.tendsto (u ‚àò f) p (nhds a)) : filter.tendsto u filter.at_top (nhds a)
{Œ± : Type u_1} [boolean_ring Œ±] : boolean_algebra Œ±
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) (h : is_unit A.det) : A.mul A‚Åª¬π = 1
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí Œ± ‚Üí Œ±
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_biproducts C] {J : Type v} [fintype J] (F : J ‚Üí category_theory.idempotents.karoubi C) : category_theory.limits.bicone F
{C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] (h : ‚àÄ (A : C) (f : A ‚ü∂ ‚ä•_ C), category_theory.is_iso f) : category_theory.limits.has_strict_initial_objects C
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [has_one M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñï] [comm_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) : comm_monoid M‚ÇÅ
 : tactic unit
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p ‚àà s) (v : V) : v ‚àà s.direction ‚Üî ‚àÉ (p2 : P) (H : p2 ‚àà s), v = p2 -·µ• p
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [has_top Œ±] [has_top Œ≤] [has_top Œ≥] (f : top_hom Œ≤ Œ≥) (g : top_hom Œ± Œ≤) : top_hom Œ± Œ≥
(args : interactive.parse generalizes_args_parser) : tactic unit
(ns : list ‚Ñï) (ts : list omega.term) : Prop
{f : ‚Ñï ‚Üí ‚Ñù} (hf : ‚àÄ (i : ‚Ñï), 0 ‚â§ f i) (r : ‚Ñù) : has_sum f r ‚Üî filter.tendsto (Œª (n : ‚Ñï), (finset.range n).sum (Œª (i : ‚Ñï), f i)) filter.at_top (nhds r)
{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] : ulift M ‚âÉ‚Çó[R] M
(t s : omega.nat.preterm) (k : ‚Ñï) (p : omega.nat.preform) : omega.nat.preform
{Œ± : Type u} {Œ≤ : Type v} [linear_ordered_field Œ±] [topological_space Œ±] [order_topology Œ±] {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±} {C : Œ±} (hC : C < 0) (hf : filter.tendsto f l filter.at_bot) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (Œª (x : Œ≤), f x * g x) l filter.at_top
(H : Type u_5) [topological_space H] (M : Type u_6) [topological_space M] : Type (max u_5 u_6)
{Œπ : Type u_1} {Œ± : Type u_2} [complete_lattice Œ±] {t : Œπ ‚Üí Œ±} (ht : complete_lattice.independent t) {x : Œπ} {y : set Œπ} (hx : x ‚àâ y) : disjoint (t x) (‚®Ü (i : Œπ) (H : i ‚àà y), t i)
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : Œ± ‚Üí Œ≤) [is_antisymm Œ± r] [is_refl Œ≤ s] (hf : ‚àÄ (a b : Œ±), s (f a) (f b) ‚Üî r a b) : r ‚Ü™r s
{Œ± : Type u_1} (h : nat.card Œ± ‚â† 0) : Œ± ‚âÉ fin (nat.card Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (R : category_theory.presieve X) : P.obj (opposite.op X) ‚ü∂ category_theory.equalizer.first_obj P R
{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R ‚ÜëS)
(a : simplex_category) : a.hom a
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) [lie_algebra.is_nilpotent R ‚Ü•H] (M : Type w) [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (œá‚ÇÅ œá‚ÇÇ œá‚ÇÉ : ‚Ü•H ‚Üí R) (hœá : œá‚ÇÅ + œá‚ÇÇ = œá‚ÇÉ) : tensor_product R ‚Ü•(lie_algebra.root_space H œá‚ÇÅ) ‚Ü•(lie_module.weight_space M œá‚ÇÇ) ‚Üí‚Çó‚ÅÖR,‚Ü•H‚ÅÜ ‚Ü•(lie_module.weight_space M œá‚ÇÉ)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : cycle Œ± ‚Üí cycle Œ≤
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.pos_mul_strict_mono Œ±] (ha : a < 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1
(h : interactive.parse (optional lean.parser.ident)) (q‚ÇÅ : interactive.parse (optional (lean.parser.tk ":" *> interactive.types.texpr))) (q‚ÇÇ : interactive.parse (optional (lean.parser.tk ":=" *> interactive.types.texpr))) : tactic unit
{Œ± : Type u_1} [linear_order Œ±] (a : Œ±) (i : fin 1) : ‚áë({a}.order_emb_of_fin _) i = a
{Œ± : Type u} [preorder Œ±] {s : set Œ±} {a : Œ±} (h : is_glb s a) : bdd_below s
 : list ‚Ñï ‚âÉ ‚Ñï
(do_whnf : option (tactic.transparency √ó bool)) (pis_or_lambdas locals_or_metas : bool) : expr ‚Üí tactic (list expr √ó expr)
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {f : filter Œ±} : filter.is_bounded r f ‚Üî ‚àÉ (s : set Œ±) (H : s ‚àà f.sets) (b : Œ±), s ‚äÜ {x : Œ± | r x b}
 : Type
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) (b : Œ≤ a) : list (Œ£ (a : Œ±), Œ≤ a) ‚Üí list (Œ£ (a : Œ±), Œ≤ a)
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] {F : Type v} [normed_group F] [normed_space ‚ÑÇ F] [nontrivial E] {f g : E ‚Üí F} {U : set E} (hU : metric.bounded U) (hf : diff_cont_on_cl ‚ÑÇ f U) (hg : diff_cont_on_cl ‚ÑÇ g U) (hfg : set.eq_on f g (frontier U)) : set.eq_on f g U
(p : ‚Ñï) : padic_norm p 1 = 1
{G : Type u_1} [sub_neg_monoid G] (a b : G) : a - b = a + -b
(R : Type u) [comm_semiring R] (p : ‚Ñï) [fact (nat.prime p)] [char_p R p] : Type u
 : localization.away 2 ‚Üí+ surreal
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) (p : submodule R (clifford_algebra Q)) (n : ‚Ñï) : submodule.map clifford_algebra.reverse (p ^ n) = submodule.map clifford_algebra.reverse p ^ n
(F : Type u_17) (M : out_param (Type u_18)) (R : out_param (Type u_19)) (S : out_param (Type u_20)) [monoid M] [semiring R] [semiring S] [distrib_mul_action M R] [distrib_mul_action M S] : Type (max u_17 u_19 u_20)
{Œ± : Type u_1} [preorder Œ±] [pred_order Œ±] : Œ± ‚Üí Œ±
{L : first_order.language} {Œ± : Type u'} : computability.encoding (L.term Œ±)
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : seq1 (generalized_continued_fraction.int_fract_pair K)
 : widget.component tactic_state empty
(Œπ : Type u_1) [decidable_eq Œπ] {R : Type u_2} [add_monoid Œπ] [semiring R] : direct_sum.gsemiring (Œª (i : Œπ), R)
{Œ± : Type u_1} {Œ≤ : Type u_2} (x : functor.const Œ± Œ≤) : Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : rel Œ± Œ≤) (s : set Œ±) : rel {x // x ‚àà s} Œ≤
{Œ± : Type u} (Œ≤ : Type v) [group Œ±] [monoid Œ≤] [mul_distrib_mul_action Œ± Œ≤] (x : Œ±) : Œ≤ ‚âÉ* Œ≤
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [cs : complete_space E] (f : E ‚Üí F) {f' : E ‚âÉL[ùïú] F} {c : nnreal} (hf : approximates_linear_on f ‚Üëf' set.univ c) (hc : subsingleton E ‚à® c < ‚à•‚Üë(f'.symm)‚à•‚Çä‚Åª¬π) : E ‚âÉ‚Çú F
{Œ± : Type u_1} {Œ≤ : Type u_2} {m : measurable_space Œ±} [measurable_space Œ≤] {M : Type u_3} [add_comm_monoid M] [topological_space M] {R : Type u_4} [semiring R] [module R M] [has_continuous_const_smul R M] [has_continuous_add M] (f : Œ± ‚Üí Œ≤) : measure_theory.vector_measure Œ± M ‚Üí‚Çó[R] measure_theory.vector_measure Œ≤ M
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {p : Œ± ‚Üí Œ≤ ‚Üí Prop} {x‚ÇÄ x‚ÇÅ : Œ£' (a : Œ±), subtype (p a)} : x‚ÇÄ.fst = x‚ÇÅ.fst ‚Üí ‚Üë(x‚ÇÄ.snd) = ‚Üë(x‚ÇÅ.snd) ‚Üí x‚ÇÄ = x‚ÇÅ
{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C} : category_theory.limits.has_binary_products (category_theory.over B)
{R : Type u} [non_assoc_semiring R] (s : set R) (sm : submonoid R) (hm : ‚Üësm = s) (sa : add_submonoid R) (ha : ‚Üësa = s) : subsemiring R
{M : Type u_1} [has_mul M] : has_bot (subsemigroup M)
{G : Type u} [fintype G] [group G] (x : G) : fin (order_of x) ‚âÉ ‚Ü•‚Üë(subgroup.zpowers x)
 : AddSemigroup ‚•§ AddMon
{Œ± : Type u_1} (p : Œ± ‚Üí bool) : list Œ± ‚Üí list Œ± √ó option Œ± √ó list Œ±
{a b c : ‚Ñ§} : fermat_42.minimal a b c ‚Üí fermat_42.minimal a b (-c)
(G : Type u) : Type u
{m‚ÇÅ : Type u‚ÇÄ ‚Üí Type v‚ÇÄ} {m‚ÇÇ : Type u‚ÇÅ ‚Üí Type v‚ÇÅ} {Œ±‚ÇÅ œÉ‚ÇÅ : Type u‚ÇÄ} {Œ±‚ÇÇ œÉ‚ÇÇ : Type u‚ÇÅ} (F : (œÉ‚ÇÅ ‚Üí m‚ÇÅ (Œ±‚ÇÅ √ó œÉ‚ÇÅ)) ‚âÉ (œÉ‚ÇÇ ‚Üí m‚ÇÇ (Œ±‚ÇÇ √ó œÉ‚ÇÇ))) : state_t œÉ‚ÇÅ m‚ÇÅ Œ±‚ÇÅ ‚âÉ state_t œÉ‚ÇÇ m‚ÇÇ Œ±‚ÇÇ
{R : Type u_1} [comm_ring R] (S : submonoid R) {P : Type u_2} [comm_ring P] [algebra R P] [loc : is_localization S P] (x : P) (hx : is_integral R x) : is_fractional S (algebra.adjoin R {x}).to_submodule
(a : expr) : list tactic.ring_exp.atom ‚Üí ‚Ñï ‚Üí tactic.ring_exp.ring_exp_m (tactic.ring_exp.atom √ó list tactic.ring_exp.atom)
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} {V3 : Type u_6} {P3 : Type u_7} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] [add_comm_group V3] [module k V3] [add_torsor V3 P3] (f : P2 ‚Üí·µÉ[k] P3) (g : P1 ‚Üí·µÉ[k] P2) (p : P1) : ‚áë(f.comp g) p = ‚áëf (‚áëg p)
{R : Type u_1} [comm_semiring R] {P : Type u_6} {Q : Type u_7} [add_comm_monoid P] [add_comm_monoid Q] [module R P] [module R Q] (p : submodule R P) (q : submodule R Q) : tensor_product R ‚Ü•p ‚Ü•q ‚Üí‚Çó[R] tensor_product R P Q
{J : Type v} {C : Type u} [category_theory.category C] {B : C} {objs : J ‚Üí C} (arrows : Œ† (j : J), objs j ‚ü∂ B) [category_theory.limits.has_wide_pullback B objs arrows] (j : J) : category_theory.limits.wide_pullback B (Œª (j : J), objs j) arrows ‚ü∂ objs j
{Œ± : Type u_1} [linear_order Œ±] {r : Œ±} {s : finset Œ±} : {r}.to_colex ‚â§ s.to_colex ‚Üî ‚àÉ (x : Œ±) (H : x ‚àà s), r ‚â§ x
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.final] (d : D) : d ‚ü∂ F.obj (category_theory.functor.final.lift F d)
(renames : name_map (name ‚äï list name)) (reserved : name_set) : tactic (list (expr √ó expr))
{k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} (h : affine_independent k (Œª (p : ‚Ü•s), ‚Üëp)) : ‚àÉ (t : set P), s ‚äÜ t ‚àß affine_independent k (Œª (p : ‚Ü•t), ‚Üëp) ‚àß affine_span k t = ‚ä§
(f v : expr) : expr ‚Üí tactic expr
{Œ± : Type u_1} [complete_lattice Œ±] {s : set Œ±} (hs : complete_lattice.set_independent s) {x : Œ±} {y : set Œ±} (hx : x ‚àà s) (hy : y ‚äÜ s) (hxy : x ‚àâ y) : disjoint x (has_Sup.Sup y)
{Œ± : Type u} [group Œ±] (g : group_topology Œ±) : continuous has_inv.inv
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [add_comm_monoid F] [ordered_add_comm_monoid Œ≤] [module ùïú E] [module ùïú F] [has_scalar ùïú Œ≤] {f : F ‚Üí Œ≤} {s : set F} (hf : concave_on ùïú s f) (g : E ‚Üí‚Çó[ùïú] F) : concave_on ùïú (‚áëg ‚Åª¬π' s) (f ‚àò ‚áëg)
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b : Œ±} (ha : 0 < a) (hb : 0 ‚â§ b) : 0 < a + b
(R : Type u_1) {p n : ‚Ñï} [hp : fact (nat.prime p)] [ring R] [char_p R p] (hn : p ‚à£ n) : polynomial.cyclotomic (n * p) R = polynomial.cyclotomic n R ^ p
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) [has_le Œ±] [has_le Œ≤] [has_le Œ≥] : (Œ± ‚äï Œ≤) ‚äï Œ≥ ‚âÉo Œ± ‚äï Œ≤ ‚äï Œ≥
{Œ± : Type u_1} : lex Œ± ‚âÉ Œ±
{Œ± : Type u_1} (m : measurable_space Œ±) : measurable_space.dynkin_system Œ±
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Top) : category_theory.limits.is_limit (Top.limit_cone_infi F)
{R : Type u_1} [comm_ring R] {R‚Çò : Type u_3} {S‚Çò : Type u_4} [comm_ring R‚Çò] [comm_ring S‚Çò] (P : ideal (polynomial R)) (pX : polynomial R) (hpX : pX ‚àà P) [algebra (R ‚ß∏ ideal.comap polynomial.C P) R‚Çò] [is_localization.away (polynomial.map (ideal.quotient.mk (ideal.comap polynomial.C P)) pX).leading_coeff R‚Çò] [algebra (polynomial R ‚ß∏ P) S‚Çò] [is_localization (submonoid.map ‚Üë(P.quotient_map polynomial.C le_rfl) (submonoid.powers (polynomial.map (ideal.quotient.mk (ideal.comap polynomial.C P)) pX).leading_coeff)) S‚Çò] : (is_localization.map S‚Çò (P.quotient_map polynomial.C le_rfl) _).is_integral
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{Œ± : Sort u} {A : Œ± ‚Üí Sort ua} {B : Œ± ‚Üí Sort ub} [Œ† (i : Œ±), has_lift_t (A i) (B i)] : has_lift (Œ† (i : Œ±), A i) (Œ† (i : Œ±), B i)
(e : environment) (test : declaration ‚Üí tactic bool) : tactic (list declaration)
{C : Type u} [category_theory.category C] {X Y Z : C} {f g : X ‚ü∂ Y} (w : f = g) (h : Y ‚ü∂ Z) : f ‚â´ h = g ‚â´ h
 : Type (u_1+1)
(attr : norm_cast.norm_cast_attr_ty) (decl : name) : tactic (option norm_cast.label)
{Œ± : Sort u_1} [h : nonempty Œ±] [subsingleton Œ±] : Œ± ‚âÉ punit
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {f' : F} {x : ùïú} [partial_order ùïú] : has_deriv_within_at f f' (set.Ioi x) x ‚Üí has_deriv_within_at f f' (set.Ici x) x
(e : expr) : tactic expr
{Œ± : Type u_1} {E : Œ± ‚Üí Type u_2} {p : ennreal} [Œ† (i : Œ±), normed_group (E i)] [fact (1 ‚â§ p)] {F : ‚Ñï ‚Üí ‚Ü•(lp E p)} (hF : cauchy_seq F) {f : ‚Ü•(lp E p)} (hf : filter.tendsto (id (Œª (i : ‚Ñï), ‚áë(F i))) filter.at_top (nhds ‚áëf)) : filter.tendsto F filter.at_top (nhds f)
{F : Type u} [decidable_eq F] [field F] (s : finset F) : ‚Ü•(polynomial.degree_lt F s.card) ‚âÉ‚Çó[F] ‚Ü•s ‚Üí F
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] (c : E) : Type
(k : turing.partrec_to_TM2.K') : turing.partrec_to_TM2.stmt' ‚Üí turing.partrec_to_TM2.stmt'
{Œ± : Type u} (l : list Œ±) : wseq Œ±
{C : Type u} [category_theory.category C] [category_theory.has_shift C ‚Ñ§] (T : category_theory.triangulated.triangle C) : category_theory.triangulated.triangle_morphism T T
(h : name) (t v : expr) : tactic expr
{Œ± : Type u_1} [linear_order Œ±] (s : finset Œ±) {k : ‚Ñï} (h : s.card = k) : fin k ‚âÉo ‚Ü•s
(r : ‚Ñù) : ‚Ñù
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : differentiable_on ‚Ñù f (interior D)) (hf'' : differentiable_on ‚Ñù (deriv f) (interior D)) (hf''_nonpos : ‚àÄ (x : ‚Ñù), x ‚àà interior D ‚Üí deriv^[2] f x ‚â§ 0) : concave_on ‚Ñù D f
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M ‚Üí* P} (H : c ‚â§ con.ker f) (x : M) : ‚áë(c.lift f H) (‚áë(c.mk') x) = ‚áëf x
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (s : set Œ±) (t : set Œ≤) : set.image2 f s t = ‚ãÉ (i : Œ±) (H : i ‚àà s) (j : Œ≤) (H : j ‚àà t), {f i j}
{Œ± : Type u_1} [linear_order Œ±] (s : set Œ±) (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí ‚àÄ (z : Œ±), z ‚àà s ‚Üí x ‚â§ y ‚Üí y ‚â§ z ‚Üí x = y ‚à® y = z) : s.finite
{p : ‚Ñï} [fact (nat.prime p)] {f : padic_seq p} (hf : ¬¨f ‚âà 0) (v1 v3 : ‚Ñï) : padic_norm p (‚áëf (padic_seq.stationary_point hf)) = padic_norm p (‚áëf (linear_order.max v1 (linear_order.max (padic_seq.stationary_point hf) v3)))
 : measure_theory.measure_space ‚Ñù
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] (H : subgroup (E ‚âÉ‚Çê[F] E)) : intermediate_field F E
{f f' : ‚Ñù ‚Üí ‚Ñù} {s : set ‚Ñù} (hs : convex ‚Ñù s) (hf : ‚àÄ (x : ‚Ñù), x ‚àà s ‚Üí has_deriv_at f (f' x) x) {m : ‚Ñù} (hf' : ‚àÄ (x : ‚Ñù), x ‚àà s ‚Üí f' x ‚â† m) : (‚àÄ (x : ‚Ñù), x ‚àà s ‚Üí f' x < m) ‚à® ‚àÄ (x : ‚Ñù), x ‚àà s ‚Üí m < f' x
(Œ± : Type u_1) {Œ≤ : Type u_2} [measurable_space Œ±] (b : Œ≤) : measure_theory.simple_func Œ± Œ≤
{A : Type u_5} [comm_ring A] {m : Type u_6} {n : Type u_7} [fintype m] [fintype n] [nontrivial A] [decidable_eq m] [decidable_eq n] {M : matrix m n A} {M' : matrix n m A} (hMM' : M.mul M' = 1) (hM'M : M'.mul M = 1) : m ‚âÉ n
(red : interactive.parse (optional (lean.parser.tk "!"))) : conv unit
(Œ± : Type u_1) [H1 : partial_order Œ±] [H2 : has_Sup Œ±] (is_lub_Sup : ‚àÄ (s : set Œ±), is_lub s (has_Sup.Sup s)) : complete_lattice Œ±
{Œ≤ : Type w} {C : Type u} [category_theory.category C] (f : Œ≤ ‚Üí C) [category_theory.limits.has_product f] : C
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {F : C ‚•§ D} [category_theory.full F] [category_theory.faithful F] [category_theory.limits.has_limit (K ‚ãô F)] (X : C) (i : F.obj X ‚âÖ category_theory.limits.limit (K ‚ãô F)) : category_theory.creates_limit K F
{R : Type u_1} [comm_semiring R] (x : R) (S : Type u_2) [comm_semiring S] [algebra R S] : Prop
{G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ‚Ü•H
{n : ‚Ñï} : finset.univ = finset.map equiv.perm.decompose_fin.symm.to_embedding finset.univ
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {f g : X ‚ü∂ Y} (c : category_theory.limits.fork f g) : category_theory.limits.kernel_fork (f - g)
 : expr ‚Üí bool
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} (r : (mvqpf.P F).M Œ± ‚Üí (mvqpf.P F).M Œ± ‚Üí Prop) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {Y Z : C} (hY : category_theory.limits.is_terminal Y) (i : Y ‚âÖ Z) : category_theory.limits.is_terminal Z
 : znum ‚Üí znum
{Œ± : Type u} [subsingleton Œ±] {s : set Œ±} : subsingleton ‚Ü•s
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} {Œπ : Type u_5} [linear_ordered_field ùïú] [add_comm_group E] [linear_ordered_add_comm_group Œ≤] [module ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} {t : finset Œπ} {w : Œπ ‚Üí ùïú} {p : Œπ ‚Üí E} (h : convex_on ùïú s f) (hw‚ÇÄ : ‚àÄ (i : Œπ), i ‚àà t ‚Üí 0 ‚â§ w i) (hw‚ÇÅ : 0 < t.sum (Œª (i : Œπ), w i)) (hp : ‚àÄ (i : Œπ), i ‚àà t ‚Üí p i ‚àà s) : ‚àÉ (i : Œπ) (H : i ‚àà t), f (t.center_mass w p) ‚â§ f (p i)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) [category_theory.creates_limit K F] [category_theory.limits.has_limit (K ‚ãô F)] : category_theory.limits.preserves_limit K F
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [ring R] [add_comm_group M] [module R M] {G : Type u_2} [group G] [distrib_mul_action G R] [distrib_mul_action G M] [is_scalar_tower G R M] [smul_comm_class G R M] (v : basis Œπ R M) (w : Œπ ‚Üí G) : basis Œπ R M
{a p k : ‚Ñï} (pp : nat.prime p) (h‚ÇÅ : ¬¨a ‚à£ p ^ k) (h‚ÇÇ : a ‚à£ p ^ (k + 1)) : a = p ^ (k + 1)
{Œ± : Type u_2} {Œ≤ : Type u_3} [decidable_eq Œ≤] [decidable_eq Œ±] [add_monoid Œ±] [add_action Œ± Œ≤] : add_action (finset Œ±) (finset Œ≤)
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (p : submodule R‚ÇÇ M‚ÇÇ) (h : ‚àÄ (x : M‚ÇÅ), ‚áëf x ‚àà p) : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] ‚Ü•p
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (m : multiset Œ±) : Prop
{p : Prop} (h : p) : unique p
{G : Type u_1} [group G] (H : subgroup G) [hG : group.is_nilpotent G] : group.nilpotency_class ‚Ü•H ‚â§ group.nilpotency_class G
(C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {L‚ÇÅ L‚ÇÇ : C ‚•§ D} {R‚ÇÅ R‚ÇÇ : D ‚•§ C} (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) (f : L‚ÇÇ ‚ü∂ L‚ÇÅ) [category_theory.is_iso (‚áë(category_theory.transfer_nat_trans_self adj‚ÇÅ adj‚ÇÇ) f)] : category_theory.is_iso f
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} {a : P.A} {f : P.last.B a ‚Üí P.last.W} (h : typevec.arrow (P.W_path (W_type.mk a f)) Œ±) : (P.drop.B a).arrow Œ±
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (O : finset C) (H : finset (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y)) {X : C} (m : X ‚àà O) : X ‚ü∂ category_theory.is_filtered.sup O H
{C : Type u} [category_theory.category C] (F : C·µí·µñ ‚•§ Type v) : (F.elements)·µí·µñ ‚âå category_theory.costructured_arrow category_theory.yoneda F
{C : Type u‚ÇÅ} [category_theory.category C] {B A : C} {X : category_theory.subobject B} (f : A ‚ü∂ B) [category_theory.mono f] (i : A ‚âÖ ‚ÜëX) (w : i.hom ‚â´ X.arrow = f) : category_theory.subobject.mk f = X
{Œ± : Type u_1} [decidable_eq Œ±] [fintype Œ±] [linear_order Œ±] (f : equiv.perm Œ±) : {l // l.prod = f ‚àß (‚àÄ (g : equiv.perm Œ±), g ‚àà l ‚Üí g.is_cycle) ‚àß list.pairwise equiv.perm.disjoint l}
(R : CommRing) : algebraic_geometry.identity_to_Œì_Spec.app (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (opposite.op R)) ‚â´ algebraic_geometry.Spec.to_LocallyRingedSpace.map (algebraic_geometry.Spec_Œì_identity.inv.app R).op = ùüô ((ùü≠ algebraic_geometry.LocallyRingedSpace).obj (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (opposite.op R)))
(S : Type u_3) (G : Type u_4) [has_neg G] [set_like S G] : Type
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} (a : topological_fiber_prebundle F proj) {e : topological_fiber_bundle.pretrivialization F proj} (he : e ‚àà a.pretrivialization_atlas) : topological_fiber_bundle.trivialization F proj
{Œ± : Sort u_1} {Œ≤ : Œ± ‚Üí Type u_2} (p : Œ± ‚Üí Prop) (f : Œ† (x : Œ±), Œ≤ x) (x : subtype p) : Œ≤ x.val
{Œ≤ : Type w} {C : Type u} [category_theory.category C] (f : Œ≤ ‚Üí C) : Type (max w u v)
{Œ± : Type u_1} [preorder Œ±] : ordnode Œ± ‚Üí with_bot Œ± ‚Üí with_top Œ± ‚Üí Prop
(p_p q_p : expr) (p q : tactic.ring_exp.coeff) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.prod)
(Œ± : Type u_1) [uniform_space Œ±] : Œ± √ó punit ‚âÉ·µ§ Œ±
{Œπ : Type u_1} {M : Type u_3} [decidable_eq Œπ] [has_zero M] [Œ† (m : M), decidable (m ‚â† 0)] (f : Œ†‚ÇÄ (i : Œπ), M) : Œπ ‚Üí‚ÇÄ M
{Œ± : Type u_6} : add_action (additive (function.End Œ±)) Œ±
(k : Type u‚ÇÅ) {G : Type u‚ÇÇ} {R : Type u_1} [monoid R] [semiring k] [distrib_mul_action R k] [has_mul G] [smul_comm_class R k k] : smul_comm_class R (monoid_algebra k G) (monoid_algebra k G)
(V : Type u_1) (P : Type u_2) [normed_group V] [add_torsor V P] : metric_space P
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (P : C·µí·µñ ‚•§ Type w) : category_theory.presieve.is_sheaf_for P (category_theory.presieve.singleton (ùüô X))
{Œì : Type u_1} {R : Type u_2} [partial_order Œì] [has_zero R] {Œì' : Type u_3} [partial_order Œì'] (f : Œì ‚Ü™o Œì') : hahn_series Œì R ‚Üí hahn_series Œì' R
(x : ‚ÑÇ) : has_deriv_at complex.cosh (complex.sinh x) x
{r : Type u_1} {r' : Type u_2} {m : Type u_1 ‚Üí Type u_3} {m' : Type u_2 ‚Üí Type u_4} [uliftable m m'] (F : r ‚âÉ r') : uliftable (cont_t r m) (cont_t r' m')
{M : Type u_1} {N : Type u_2} [has_zero M] [has_zero N] (f : zero_hom M N) : zero_hom (with_top M) (with_top N)
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [has_zero M‚ÇÅ] [has_scalar ‚Ñï M‚ÇÅ] [has_neg M‚ÇÅ] [has_sub M‚ÇÅ] [has_scalar ‚Ñ§ M‚ÇÅ] [add_group M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) (inv : ‚àÄ (x : M‚ÇÅ), f (-x) = -f x) (div : ‚àÄ (x y : M‚ÇÅ), f (x - y) = f x - f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : add_group M‚ÇÅ
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] {F G : category_theory.braided_functor C D} (i : F.to_monoidal_functor ‚âÖ G.to_monoidal_functor) : F ‚âÖ G
{C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_colimits_of_shape (category_theory.discrete J) C] [category_theory.limits.has_colimits_of_shape (category_theory.discrete (Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd)) C] [category_theory.limits.has_coequalizers C] (G : C ‚•§ D) [category_theory.limits.preserves_colimits_of_shape category_theory.limits.walking_parallel_pair G] [category_theory.limits.preserves_colimits_of_shape (category_theory.discrete J) G] [category_theory.limits.preserves_colimits_of_shape (category_theory.discrete (Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd)) G] : category_theory.limits.preserves_colimits_of_shape J G
{J : Type v} [category_theory.small_category J] (F : J ‚•§ category_theory.Cat) : category_theory.Cat
{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} (h : f = g) (x : M) : ‚áëf x = ‚áëg x
{Œ± : Type u} [topological_space Œ±] {x : Œ±} : coe ‚Åª¬π' {‚Üëx} = connected_component x
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) [wo : is_well_order Œ± r] {s : set (set Œ±)} (h‚ÇÅ : set.unbounded r (‚ãÉ‚ÇÄs)) (h‚ÇÇ : cardinal.mk ‚Ü•s < strict_order.cof r) : ‚àÉ (x : set Œ±) (H : x ‚àà s), set.unbounded r x
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (f : Œ± ‚Üí option Œ≤ ‚Üí Œ≥) : list Œ± ‚Üí list Œ≤ ‚Üí list Œ≥ √ó list Œ≤
(_x : interactive.parse (lean.parser.tk "reassoc_axiom")) : lean.parser unit
(X Y : Top) : X ‚®Ø Y ‚âÖ Top.of (‚Ü•X √ó ‚Ü•Y)
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] (a : Œ±) : Œ± ‚âÉo Œ±
(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_2)
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {c : category_theory.limits.fork f g} (h : category_theory.limits.is_limit c) [category_theory.epi c.Œπ] : category_theory.is_iso c.Œπ
{Œ± : Type u_1} (S : set (set Œ±)) : Type
(p : ‚Ñï) [p_prime : fact (nat.prime p)] {q r : ‚Ñö} (hq : q ‚â† 0) (hr : r ‚â† 0) : padic_val_rat p (q / r) = padic_val_rat p q - padic_val_rat p r
{R : Type u_1} [ordered_semiring R] (s : subsemiring R) : ordered_semiring ‚Ü•s
(ic : tactic.instance_cache) (a b : expr) (na nb : ‚Ñö) : tactic (tactic.instance_cache √ó expr)
{F : pfunctor} {r : F.M ‚Üí Sort w} (x : F.M) (f : Œ† (x : F.obj F.M), r (pfunctor.M.mk x)) : r x
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [add_comm_monoid Œπ] [graded_monoid.gcomm_monoid A] : comm_monoid (graded_monoid A)
{Œ± : Type u_3} {Œ≤ : Type u_4} [add_group Œ±] (a : Œ±) [add_action Œ± Œ≤] (b : Œ≤) : ‚Ü•(add_subgroup.zmultiples a) ‚ß∏ add_action.stabilizer ‚Ü•(add_subgroup.zmultiples a) b ‚âÉ+ zmod (function.minimal_period (has_vadd.vadd a) b)
(L : Type v) (M : Type w) [has_bracket L M] [has_zero M] : Prop
 : star_ordered_ring ‚ÑÇ
(R : Type u_1) [comm_semiring R] {X : Type u_2} {A : Type u_3} [semiring A] [algebra R A] : (X ‚Üí A) ‚âÉ (free_algebra R X ‚Üí‚Çê[R] A)
(J : Type v) : (category_theory.limits.wide_pullback_shape J)·µí·µñ ‚•§ category_theory.limits.wide_pushout_shape J
{ùïú : Type u} [hnorm : nondiscrete_normed_field ùïú] {E : Type v} [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_smul ùïú E] (l : E ‚Üí‚Çó[ùïú] ùïú) : continuous ‚áël ‚Üî is_closed ‚Üë(l.ker)
(G : Type u_1) [group G] [topological_space G] : Prop
{Œì : Type u_1} {R : Type u_2} [ordered_cancel_add_comm_monoid Œì] [comm_semiring R] {A : Type u_3} [semiring A] [algebra R A] {Œì' : Type u_4} [ordered_cancel_add_comm_monoid Œì'] (f : Œì ‚Üí+ Œì') (hfi : function.injective ‚áëf) (hf : ‚àÄ (g g' : Œì), ‚áëf g ‚â§ ‚áëf g' ‚Üî g ‚â§ g') : hahn_series Œì A ‚Üí‚Çê[R] hahn_series Œì' A
 : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum)
{R : Type v} [comm_ring R] (A : matrix (fin 3) (fin 3) R) : A.det = A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1 - A 0 1 * A 1 0 * A 2 2 + A 0 1 * A 1 2 * A 2 0 + A 0 2 * A 1 0 * A 2 1 - A 0 2 * A 1 1 * A 2 0
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (F : C ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.reflects_limit (category_theory.limits.cospan f f) F] [category_theory.mono (F.map f)] : category_theory.mono f
{V : Type u} {V' : Type v} {G : simple_graph V} {G' : simple_graph V'} (f : G ‚Üíg G') (hinj : function.injective ‚áëf) {u v : V} (p : G.path u v) : G'.path (‚áëf u) (‚áëf v)
{M‚ÇÄ : Type u_1} [mul_zero_one_class M‚ÇÄ] [nontrivial M‚ÇÄ] : 0 ‚â† 1
{Œ± : Type u} {Œ≤ : Type v} [semilattice_inf Œ±] [semilattice_inf Œ≤] (f : Œ± ‚Üí Œ≤) (hf : right_ord_continuous f) (h : function.injective f) : Œ± ‚Ü™o Œ≤
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_coequalizer f g] : category_theory.limits.is_colimit (category_theory.limits.cofork.of_œÄ (category_theory.limits.coequalizer.œÄ f g) _)
{C : Type u} [category_theory.category C] (X Y : C) : Type (max u v)
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} {x : category_theory.presieve.family_of_elements P ‚áë(category_theory.sieve.generate R)} (t : x.compatible) : (category_theory.presieve.family_of_elements.restrict _ x).sieve_extend = x
(R : Type u) (S : Type u_3) [comm_ring R] (L : Type v) (M : Type w) [field L] [field M] [algebra R M] [no_zero_smul_divisors R M] [is_alg_closure R M] [comm_ring S] [algebra S L] [no_zero_smul_divisors S L] [is_alg_closure S L] [algebra R S] [algebra R L] [is_scalar_tower R S L] [nontrivial S] [no_zero_smul_divisors R S] (hRL : algebra.is_algebraic R L) : L ‚âÉ‚Çê[R] M
(Œ± : Type u) : Type u
{C : Type u} [category_theory.category C] {P Q R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R) [category_theory.strong_mono (f ‚â´ g)] : category_theory.strong_mono f
{E : Type u_1} (R : Type u_2) (S : Type u_3) [add_comm_group E] [division_ring R] [division_ring S] [module R E] [module S E] (r : ‚Ñö) (x : E) : ‚Üër ‚Ä¢ x = ‚Üër ‚Ä¢ x
{n : ‚Ñï} (F : typevec n ‚Üí Type u_1) [mvfunctor F] : Type (max (u+1) u_1)
{Œπ : Type u_1} : free_group Œπ ‚âÉ* free_product (Œª (_x : Œπ), free_group unit)
 : Type (u_1+1)
{M : Type u_1} {N : Type u_2} (Œ± : Type u_6) [add_monoid M] [add_action M Œ±] [add_monoid N] (g : N ‚Üí+ M) : add_action N Œ±
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} : (mvqpf.P F).M Œ± ‚Üí mvqpf.cofix F Œ±
{Œ± : Type u_1} [has_le Œ±] (a : Œ±) : Prop
(n : ‚Ñï) (R : Type u_1) [ring R] [nontrivial R] : (polynomial.cyclotomic n R).degree = ‚Üë(n.totient)
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] (h : Œ± ‚âÉ·µ§ Œ≤) : Œ± ‚Üí Œ≤
{a b : ‚Ñù} {g' g : ‚Ñù ‚Üí ‚Ñù} (hcont : continuous_on g (set.interval a b)) (hderiv : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo (linear_order.min a b) (linear_order.max a b) ‚Üí has_deriv_at g (g' x) x) (hpos : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo (linear_order.min a b) (linear_order.max a b) ‚Üí 0 ‚â§ g' x) : interval_integrable g' measure_theory.measure_space.volume a b
(o : ordinal) (f : Œ† (a : ordinal), a < o ‚Üí ordinal) : ordinal
{Œ± : Type u_1} {Œ≤ : Type u_2} [preorder Œ±] [preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : galois_connection l u) (h : ‚àÄ (b : Œ≤), b ‚â§ l (u b)) : galois_insertion l u
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) [measurable_space E] [opens_measurable_space E] {K : set (E ‚ÜíL[ùïú] F)} (hK : is_complete K) : measurable_set {x : E | differentiable_at ùïú f x ‚àß fderiv ùïú f x ‚àà K}
{R : Type u_1} (A : Type u_2) [comm_ring R] [ring A] [algebra R A] (c‚ÇÅ c‚ÇÇ : R) : Type u_2
(n : name) : tactic bool
 : level ‚Üí level ‚Üí bool
 : tactic unit
(R : Type u‚ÇÅ) {L : Type u‚ÇÇ} [comm_ring R] [lie_ring L] [lie_algebra R L] {A : Type u‚ÇÉ} [ring A] [algebra R A] : (L ‚Üí‚Çó‚ÅÖR‚ÅÜ A) ‚âÉ (universal_enveloping_algebra R L ‚Üí‚Çê[R] A)
{R : Type u} [comm_semiring R] [no_zero_divisors R] (t : multiset (polynomial R)) : t.prod.leading_coeff = (multiset.map (Œª (f : polynomial R), f.leading_coeff) t).prod
{G : Type u_1} [add_group G] (H : add_subgroup G) : ‚Ñï
{U : Top} (X : algebraic_geometry.Scheme) {f : U ‚ü∂ Top.of ‚Ü•(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} (h : open_embedding ‚áëf) : algebraic_geometry.Scheme
{œÉ‚ÇÅ : Type u_1} {œÉ‚ÇÇ : Type u_2} (f‚ÇÅ : œÉ‚ÇÅ ‚Üí option œÉ‚ÇÅ) (f‚ÇÇ : œÉ‚ÇÇ ‚Üí option œÉ‚ÇÇ) (tr : œÉ‚ÇÅ ‚Üí œÉ‚ÇÇ ‚Üí Prop) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] (X : C) : category_theory.is_pullback 0 0 (ùüô X) 0
{p n r b : ‚Ñï} (hp : nat.prime p) (hbn : nat.log p n < b) : p ^ r ‚à£ n.factorial ‚Üî r ‚â§ (finset.Ico 1 b).sum (Œª (i : ‚Ñï), n / p ^ i)
(n : ‚Ñï) : (list.nat.antidiagonal n).length = n + 1
{Œ± : Type u_1} [preorder Œ±] {f g : Œ± ‚Üí Œ±} (hf : monotone f) (h : f ‚â§ g) (n : ‚Ñï) : f^[n] ‚â§ (g^[n])
 : tactic unit
{R : Type u_2} [semiring R] : hahn_series ‚Ñï R ‚âÉ+* power_series R
{Œ± : Type u_1} [preorder Œ±] (s : set Œ±) : Prop
(lp : list name) (params : list expr) (fn : expr) (eqns : list (list pexpr √ó expr)) (is_meta : bool) : tactic unit
(x : ‚Ñù*) (r : ‚Ñù) : Prop
(data : Type) : Type
{C : Type u} [category_theory.category C] {X Y : C} {s : category_theory.limits.binary_fan X Y} (P : category_theory.limits.is_limit s) {t : category_theory.limits.binary_fan Y X} (Q : category_theory.limits.is_limit t) : s.X ‚âÖ t.X
{Œ± : Type u_1} : Œ± ‚âÉ as_boolalg Œ±
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [linear_ordered_add_comm_group Œ±] [order_topology Œ±] {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±} {C : Œ±} (hf : filter.tendsto f l filter.at_top) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (Œª (x : Œ≤), f x + g x) l filter.at_top
 : tactic (list (expr √ó bool))
{M : Type u_1} {N : Type u_2} [unique M] [unique N] [has_mul M] [has_mul N] : M ‚âÉ* N
{Œ± : Type u_1} {M : Type u_5} {G : Type u_9} [monoid G] [mul_action G Œ±] [add_comm_monoid M] : mul_action G (Œ± ‚Üí‚ÇÄ M)
 : omega.int.preterm ‚Üí ‚Ñï
{R : Type u_1} [comm_ring R] (p : polynomial R) : polynomial R
{Œ± : Type} (p : lean.parser Œ±) : lean.parser Œ±
(n : interactive.parse lean.parser.ident) : tactic unit
 : ‚Ñù ‚Üí+ real.angle
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (j j' : C) : category_theory.is_cofiltered.min j j' ‚ü∂ j'
 : tactic (name_map declaration)
{Œ± : Type u_1} {s : finset Œ±} (p : Œ± ‚Üí Prop) [decidable_pred p] : finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M ‚Üí+ P} (h : c ‚â§ add_con.ker f) (hf : function.surjective ‚áëf) : function.surjective ‚áë(c.lift f h)
{Œ± : Type u_1} {Œ≤ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] : is_pi_system (set.image2 has_set_prod.prod {s : set Œ± | measurable_set s} {t : set Œ≤ | measurable_set t})
{m : Type u ‚Üí Type v} [monad m] {Œ± : Type w} {Œ≤ : Type u} (f : Œ± ‚Üí m Œ≤) (o : option Œ±) : m (option Œ≤)
{E : Type u_1} [inner_product_space ‚Ñù E] {n : ‚Ñï} (hn : 0 < n) (h : finite_dimensional.finrank ‚Ñù E = n) (x : orientation ‚Ñù E (fin n)) : orthonormal ‚Ñù ‚áë(orientation.fin_orthonormal_basis hn h x)
(C : Type u) [category_theory.category C] [‚àÄ {X Y : C} {f g : X ‚ü∂ Y}, category_theory.limits.has_limit (category_theory.limits.parallel_pair f g)] : category_theory.limits.has_equalizers C
{M : Type u_1} [add_zero_class M] {Œπ : Sort u_2} (S : Œπ ‚Üí add_submonoid M) {C : M ‚Üí Prop} {x : M} (hx : x ‚àà ‚®Ü (i : Œπ), S i) (hp : ‚àÄ (i : Œπ) (x : M), x ‚àà S i ‚Üí C x) (h1 : C 0) (hmul : ‚àÄ (x y : M), C x ‚Üí C y ‚Üí C (x + y)) : C x
{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [monoid.fg M] : algebra.finite_type R (monoid_algebra R M)
{n : ‚Ñ§} (hn : n ‚â† 0) (z : ‚Ü•circle) : ‚áë(fourier n) (‚áëexp_map_circle ((‚Üën)‚Åª¬π * real.pi) * z) = -‚áë(fourier n) z
{Œ≤ : Type u_1} [conditionally_complete_lattice Œ≤] {s : set (with_top Œ≤)} (hs : bdd_below s) : is_glb s (has_Inf.Inf s)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.mono f] : (category_theory.mono_over.map f).obj ‚ä§ ‚âÖ category_theory.mono_over.mk' f
{m : Type u_2} {n : Type u_3} {Œ± : Type v} [has_mul Œ±] (w : m ‚Üí Œ±) (v : n ‚Üí Œ±) : matrix m n Œ±
(ids : list name) : tactic unit
(V : Type v) [category_theory.category V] [category_theory.monoidal_category V] (C : Type u‚ÇÅ) [category_theory.enriched_category V C] (D : Type u‚ÇÇ) [category_theory.enriched_category V D] : Type (max u‚ÇÅ u‚ÇÇ w)
{X Y : algebraic_geometry.LocallyRingedSpace} (f : X ‚ü∂ Y) : Prop
(o : ordinal) (f : Œ† (a : ordinal), a < o ‚Üí ordinal) : ordinal
{n : ‚Ñï} (p : fin (n + 2)) (i : fin (n + 1)) (h : 0 < i) : 0 < ‚áë(p.succ_above) i
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) {g h : Y ‚ü∂ Z} (w : g = h) : f ‚â´ g = f ‚â´ h
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : Top} (f : X ‚ü∂ Y) (F : Top.presheaf C Y) (x : ‚Ü•X) : F.stalk (‚áëf x) ‚ü∂ (Top.presheaf.pullback_obj f F).stalk x
{Œ± : Type u} {Œ≤ : Type v} [semilattice_inf Œ±] {r : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {f : Œ± ‚Üí Œ≤} (hf : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±), a‚ÇÅ ‚â§ a‚ÇÇ ‚Üí r (f a‚ÇÇ) (f a‚ÇÅ)) : directed r f
(R : Type u) [ring R] [strong_rank_condition R] (m : Type v) (n : Type w) [fintype m] [fintype n] : module.rank R (matrix m n R) = (cardinal.mk m).lift * (cardinal.mk n).lift
{Œ± : Type u_1} [decidable_eq Œ±] (s : multiset Œ±) : multiset Œ±
(C : Type u) [category_theory.category C] : Prop
(h : expr) (ns : name_set) : tactic bool
{n : Type u_3} {Œ± : Type v} {Œ≤ : Type w} [has_mul Œ±] [has_mul Œ≤] (f : Œ± ‚Üí Œ≤) (r : Œ±) (A : matrix n n Œ±) (hf : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±), f (a‚ÇÅ * a‚ÇÇ) = f a‚ÇÅ * f a‚ÇÇ) : (mul_opposite.op r ‚Ä¢ A).map f = mul_opposite.op (f r) ‚Ä¢ A.map f
{b : ‚Ñï} (hb : 1 < b) {x y : ‚Ñï} : x ‚â§ b ^ y ‚Üî nat.clog b x ‚â§ y
(p_p q_p : expr) (p q : tactic.ring_exp.coeff) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.prod)
{M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : mul_one_class M} {mN : mul_one_class N} [monoid_hom_class F M N] (f : F) {x : M} (hx : ‚àÉ (y : M), y * x = 1) : ‚àÉ (y : N), y * ‚áëf x = 1
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f g : J ‚Üí C} [category_theory.limits.has_biproduct f] [category_theory.limits.has_biproduct g] (p : Œ† (b : J), f b ‚âÖ g b) : ‚®Å f ‚âÖ ‚®Å g
{K : Type u} [field K] (s : subring K) (hinv : ‚àÄ (x : K), x ‚àà s ‚Üí x‚Åª¬π ‚àà s) : subfield K
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] [algebra R S] {S' : Type u_8} [comm_ring S'] [algebra R S'] (pb : power_basis R S) (e : S ‚âÉ‚Çê[R] S') : power_basis R S'
{Œ± : Type u} [pseudo_emetric_space Œ±] {Œ¥ : ‚Ñù} {E : set Œ±} : is_closed (metric.cthickening Œ¥ E)
{X : Type u_1} [topological_space X] : discrete_topology X ‚Üî nhds = has_pure.pure
{Œπ : Type u_1} {ùïú : Type u_2} [is_R_or_C ùïú] {E : Type u_3} [inner_product_space ùïú E] [cplt : complete_space E] {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (hsp : (submodule.span ùïú (set.range v)).topological_closure = ‚ä§) : hilbert_basis Œπ ùïú E
{Œ± : Type u} {Œ≤ : Type v} [has_mul Œ±] [has_distrib_neg Œ±] [has_neg Œ≤] [has_mul Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.surjective f) (neg : ‚àÄ (a : Œ±), f (-a) = -f a) (mul : ‚àÄ (a b : Œ±), f (a * b) = f a * f b) : has_distrib_neg Œ≤
{R : Type u} [comm_ring R] {g : polynomial R} (hg : g.monic) : basis (fin g.nat_degree) R (adjoin_root g)
(D : algebraic_geometry.Scheme.glue_data) (i j : D.to_glue_data.J) : category_theory.limits.is_limit (D.V_pullback_cone i j)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : Type u‚ÇÇ
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [has_lt Œπ] [Œ† (i : Œπ), has_le (Œ± i)] : has_le (Œ£‚Çó' (i : Œπ), Œ± i)
(Œ± : Type u_1) [fintype Œ±] [category_theory.small_category Œ±] [category_theory.fin_category Œ±] : category_theory.fin_category.obj_as_type Œ± ‚âå Œ±
{K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} (terminates : (generalized_continued_fraction.of v).terminates) : ‚àÉ (q : ‚Ñö), v = ‚Üëq
{Œ± : Type u_1} [preorder Œ±] [order_top Œ±] [locally_finite_order Œ±] (a : Œ±) : multiset Œ±
(X : algebraic_geometry.LocallyRingedSpace) (r : ‚Ü•(algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X))) : X.to_Œì_Spec_fun ‚Åª¬π' (prime_spectrum.basic_open r).val = (X.to_RingedSpace.basic_open r).val
(n : ‚Ñï) : list ‚Ñï
{Œπ : Type w} [fintype Œπ] (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] [is_separable K L] (b : basis Œπ K L) : algebra.discr K ‚áëb ‚â† 0
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [has_le Œ±] [has_le Œ≤] : Type (max u_6 u_7 u_8)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p‚ÇÅ p‚ÇÇ : Œπ ‚Üí P) (b : P) : s.sum (Œª (i : Œπ), w i ‚Ä¢ (p‚ÇÅ i -·µ• p‚ÇÇ i)) = ‚áë(s.weighted_vsub_of_point p‚ÇÅ b) w - ‚áë(s.weighted_vsub_of_point p‚ÇÇ b) w
{G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (a : G) : ‚áëf (-a) = -‚áëf a
(Œ± : Type u_5) : Type u_5
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_pullbacks C] {A : C} (f g : category_theory.mono_over A) : (category_theory.mono_over.inf.obj f).obj g ‚ü∂ f
{ùïú : Type u} [nondiscrete_normed_field ùïú] (x : ùïú) {ùïú' : Type u_1} [nondiscrete_normed_field ùïú'] [normed_algebra ùïú ùïú'] {h : ùïú ‚Üí ùïú'} {h‚ÇÇ : ùïú' ‚Üí ùïú'} {h' h‚ÇÇ' : ùïú'} (hh‚ÇÇ : has_deriv_at h‚ÇÇ h‚ÇÇ' (h x)) (hh : has_deriv_at h h' x) : has_deriv_at (h‚ÇÇ ‚àò h) (h‚ÇÇ' * h') x
{M : Type u_1} [comm_monoid M] (S : submonoid M) {Œπ : Type u_2} {t : finset Œπ} {f : Œπ ‚Üí M} (h : ‚àÄ (c : Œπ), c ‚àà t ‚Üí f c ‚àà S) : t.prod (Œª (c : Œπ), f c) ‚àà S
(a : ‚Ñï) (comps : native.rb_set linarith.pcomp) : native.rb_set linarith.pcomp √ó native.rb_set linarith.pcomp √ó native.rb_set linarith.pcomp
{C : Type u‚ÇÅ} [category_theory.category C] (T : category_theory.monad C) : ùü≠ C ‚ü∂ ‚ÜëT
(Œ± : Type u) (Œ≤ : Type v) [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] : Type (max u v)
(ùïú : Type u) (G : Type wG) {G' : Type wG'} [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] (x : G') : continuous_multilinear_map ùïú (Œª (i : fin 0), G) G'
(G : Type u) [group G] : subgroup G
{J : Type v} {C : Type u} [category_theory.category C] {B : C} (F : category_theory.discrete J ‚•§ category_theory.over B) [category_theory.limits.has_limit (category_theory.over.construct_products.wide_pullback_diagram_of_diagram_over B F)] : category_theory.limits.has_limit F
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : C·µí·µñ ‚•§ Type v‚ÇÅ} : (S.functor ‚ü∂ P) ‚âÉ {x // x.compatible}
(a : tactic.itauto.prop) : tactic.itauto.prop
(K : Type u_7) (M : Type u_9) [field K] [add_comm_group M] [module K M] (a : K) (ha : a ‚â† 0) : M ‚âÉ‚Çó[K] M
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] [separated_space Œ±] {f : Œ± ‚Üí Œ≤} (hf : uniform_inducing f) : uniform_embedding f
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) : setoid M
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [regular_space Œ±] [non_unital_non_assoc_semiring Œ±] [topological_semiring Œ±] {f : Œ≤ ‚Üí Œ±} {g : Œ≥ ‚Üí Œ±} (hf : summable f) (hg : summable g) (hfg : summable (Œª (x : Œ≤ √ó Œ≥), f x.fst * g x.snd)) : (‚àë' (x : Œ≤), f x) * ‚àë' (y : Œ≥), g y = ‚àë' (z : Œ≤ √ó Œ≥), f z.fst * g z.snd
{Œ≥ : Type u_3} [tŒ≥ : topological_space Œ≥] [polish_space Œ≥] {Œ≤ : Type u_1} [topological_space Œ≤] [t2_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] {f : Œ≥ ‚Üí Œ≤} (f_cont : continuous f) (f_inj : function.injective f) : measurable_set (set.range f)
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] : has_inv (matrix n n Œ±)
{Œ± : Type u_1} (x : Œ±) (z : sym2 Œ±) : Prop
{G : Type w} [topological_space G] [group G] [topological_group G] [topological_space.separable_space G] [locally_compact_space G] : sigma_compact_space G
(p : ‚Ñï) [hp : fact (nat.prime p)] (q r : ‚Ñö) : padic_norm p (q + r) ‚â§ padic_norm p q + padic_norm p r
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] (F : J ‚•§ K ‚•§ C) (c : Œ† (k : K), category_theory.limits.limit_cone (F.flip.obj k)) : category_theory.limits.is_limit (category_theory.limits.combine_cones F c)
{Œ± : Type u_1} {Œ≤ : Type u_2} : functor.add_const Œ± Œ≤ ‚Üí Œ±
(x y : pgame) : Prop
{w : Type u_3} {w' : Type u_4} {m : Type u_3 ‚Üí Type u_1} {m' : Type u_4 ‚Üí Type u_2} [uliftable m m'] (F : w ‚âÉ w') : uliftable (writer_t w m) (writer_t w' m')
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {l : filter Œ±} {a : Œ±} : is_max_filter f l a ‚Üí is_min_filter (‚áëorder_dual.to_dual ‚àò f) l a
{C : Type u‚ÇÅ} [category_theory.category C] (F : category_theory.discrete pempty ‚•§ C) (X : C) : category_theory.limits.is_colimit {X := X, Œπ := {app := category_theory.limits.is_initial_equiv_unique._aux_1 F X, naturality' := _}} ‚âÉ Œ† (Y : C), unique (X ‚ü∂ Y)
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : J.pullback (f ‚â´ g) ‚âÖ J.pullback g ‚ãô J.pullback f
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : filter Œ±) (g : set Œ± ‚Üí filter Œ≤) : filter Œ≤
{C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) {Y : topological_space.opens ‚Ü•X} (hY : Y = supr U) : category_theory.limits.cone.whisker (Top.presheaf.generate_equivalence_opens_le U hY).op.functor (category_theory.functor.map_cone F (Top.presheaf.sheaf_condition.opens_le_cover_cocone U).op) ‚âÖ category_theory.functor.map_cone F (category_theory.sieve.generate (Top.presheaf.presieve_of_covering_aux U Y)).arrows.cocone.op
{Œ≤ : typevec 0 ‚Üí Sort u_2} (f : Œ≤ fin2.elim0) (v : typevec 0) : Œ≤ v
 : ‚Ñï ‚Üí Fintype.skeleton
{Œ± : Type u_1} [has_add Œ±] (s : set Œ±) (a : Œ±) : set Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {D : Type u‚ÇÑ} [category_theory.category D] {G : K ‚•§ D} (h : category_theory.limits.cone G ‚âå category_theory.limits.cone F) {c : category_theory.limits.cone G} : category_theory.limits.is_limit (h.functor.obj c) ‚âÉ category_theory.limits.is_limit c
{f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} (h0 : 0 < b) (h1 : continuous_on f (set.Ici a)) (h2 : f =O[filter.at_top] Œª (x : ‚Ñù), real.exp (-b * x)) : measure_theory.integrable_on f (set.Ioi a) measure_theory.measure_space.volume
{C : Type u} [category_theory.category C] [category_theory.abelian C] (Z : C) [category_theory.has_injective_resolution Z] : cochain_complex C ‚Ñï
 : measure_theory.measure.add_haar_measure topological_space.positive_compacts.Icc01 = measure_theory.measure_space.volume
 : abstract_completion compare_reals.Q
(R : Type u_1) [comm_ring R] : algebra.finite_presentation R R
(hs : interactive.parse interactive.types.with_ident_list) : tactic unit
{ùíú : Type u_1} [category_theory.category ùíú] [category_theory.limits.has_zero_morphisms ùíú] [category_theory.limits.has_binary_biproducts ùíú] {X Y Z : ùíú} (f : X ‚ü∂ Y) [category_theory.is_iso f] (hZ : category_theory.limits.is_zero Z) : category_theory.splitting f 0
{C : Type u} [category_theory.category C] {X Y P : C} (Œπ‚ÇÅ : X ‚ü∂ P) (Œπ‚ÇÇ : Y ‚ü∂ P) : category_theory.limits.binary_cofan X Y
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [pred_order Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : antitone f) : pairwise (disjoint on Œª (n : Œ±), set.Ioo (f n) (f (order.pred n)))
(Œ± : Type u_5) (Œ≤ : Type u_6) : Type (max u_5 u_6)
(Œ± : Type u_1) : option Œ± ‚âÉ Œ± ‚äï punit
{Œ± : Type u_1} {p q : Œ± ‚Üí Prop} [decidable_pred p] [decidable_pred q] (e : {x // p x} ‚âÉ {x // q x}) (f : {x // ¬¨p x} ‚âÉ {x // ¬¨q x}) : equiv.perm Œ±
{Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} [decidable_eq Œπ] {R' : Type u_1} {A : Type u_2} [semiring R'] [semiring A] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [Œ† (i : Œπ), module A (M‚ÇÅ i)] {Œπ' : Type u_3} {M' : Œπ' ‚Üí Type u_4} [Œ† (i : Œπ'), add_comm_monoid (M' i)] [Œ† (i : Œπ'), topological_space (M' i)] [‚àÄ (i : Œπ'), has_continuous_add (M' i)] [Œ† (i : Œπ'), module R' (M' i)] [Œ† (i : Œπ'), module A (M' i)] [‚àÄ (i : Œπ'), smul_comm_class A R' (M' i)] [‚àÄ (i : Œπ'), has_continuous_const_smul R' (M' i)] : (Œ† (i : Œπ'), continuous_multilinear_map A M‚ÇÅ (M' i)) ‚âÉ‚Çó[R'] continuous_multilinear_map A M‚ÇÅ (Œ† (i : Œπ'), M' i)
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {s : set Œ±} (hf : set.eq_on f 0 s) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)) = 0
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ‚Ñ§] [category_theory.preadditive C] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] : Type (max u v)
{R' : Type u_1} {Œ± : Type u_2} [semiring R'] [monoid Œ±] [mul_distrib_mul_action R' Œ±] (S : subsemiring R') : mul_distrib_mul_action ‚Ü•S Œ±
{C : Type u} [category_theory.category C] {n : ‚Ñï} (f : ulift (fin (n + 1)) ‚Üí C) {c‚ÇÅ : category_theory.limits.fan (Œª (i : ulift (fin n)), f {down := i.down.succ})} {c‚ÇÇ : category_theory.limits.binary_fan (f {down := 0}) c‚ÇÅ.X} (t‚ÇÅ : category_theory.limits.is_limit c‚ÇÅ) (t‚ÇÇ : category_theory.limits.is_limit c‚ÇÇ) : category_theory.limits.is_limit (category_theory.extend_fan c‚ÇÅ c‚ÇÇ)
 : norm_cast.label ‚Üí string
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] (f : S.localization_map N) (z : N) : f.mk' (f.sec z).fst (f.sec z).snd = z
(Œ± : Type u) [preorder Œ±] [nonempty Œ±] [no_max_order Œ±] : ‚àÉ (f : ‚Ñï ‚Üí Œ±), strict_mono f
{Œ± : Type u} [preorder Œ±] [order_bot Œ±] {a b : Œ±} (h : a < b) : b ‚â† ‚ä•
{Œ± : Type u_1} {Œ≤ : Type u_2} {l : filter Œ±} {f g : Œ± ‚Üí Œ≤} : f =·∂†[l] g ‚Üí ‚Üëf = ‚Üëg
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) : o.oangle x (-y) = o.oangle x y + ‚Üëreal.pi
(G : Type w) [topological_space G] [add_group G] [topological_add_group G] : G √ó G ‚âÉ‚Çú G √ó G
{R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] [fintype R] : function.surjective ‚áë(algebra_map R L)
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [add_comm_monoid Œ≤] {s : finset Œ±} {t : finset Œ≥} {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ≤} (i : Œ† (a : Œ±), a ‚àà s ‚Üí Œ≥) (hi : ‚àÄ (a : Œ±) (ha : a ‚àà s), i a ha ‚àà t) (h : ‚àÄ (a : Œ±) (ha : a ‚àà s), f a = g (i a ha)) (j : Œ† (a : Œ≥), a ‚àà t ‚Üí Œ±) (hj : ‚àÄ (a : Œ≥) (ha : a ‚àà t), j a ha ‚àà s) (left_inv : ‚àÄ (a : Œ±) (ha : a ‚àà s), j (i a ha) _ = a) (right_inv : ‚àÄ (a : Œ≥) (ha : a ‚àà t), i (j a ha) _ = a) : s.sum (Œª (x : Œ±), f x) = t.sum (Œª (x : Œ≥), g x)
{Œ± : Sort u} {C : Œ± ‚Üí Sort v} {r : Œ± ‚Üí Œ± ‚Üí Prop} (hwf : well_founded r) (F : Œ† (x : Œ±), (Œ† (y : Œ±), r y x ‚Üí C y) ‚Üí C x) (x : Œ±) : hwf.fix F x = F x (Œª (y : Œ±) (h : r y x), hwf.fix F y)
{Œ± : Type u_1} {Œπ : Sort u_4} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí set Œ±} (h : filter.is_basis p s) : filter Œ±
(a : ‚Ü•circle) : ‚áë(linear_map.to_matrix complex.basis_one_I complex.basis_one_I) ‚Üë((‚áërotation a).to_linear_equiv) = ‚áë(matrix.plane_conformal_matrix ‚Üëa.re ‚Üëa.im _)
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j‚ÇÅ j‚ÇÇ j‚ÇÉ : C) : C
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : field ‚Ü•S
{Œ± : Type u} {Œ≤ : Type v} [has_add Œ±] [has_add Œ≤] (e : Œ± ‚âÉ+ Œ≤) : with_zero Œ± ‚âÉ+ with_zero Œ≤
(X : UniformSpace) : X ‚ü∂ (category_theory.forget‚ÇÇ CpltSepUniformSpace UniformSpace).obj (UniformSpace.completion_functor.obj X)
{Œ± : Type u_1} {p : Œ± ‚Üí Prop} [pseudo_emetric_space Œ±] : pseudo_emetric_space (subtype p)
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (e : K ‚âå J) : category_theory.limits.cone F ‚âå category_theory.limits.cone (e.functor ‚ãô F)
 : Type (u_1+1)
{Œ± : Type u_1} [has_to_format Œ±] (msg : thunk Œ±) : tactic unit
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] : category_theory.limits.is_limit (category_theory.limits.biprod.fst_kernel_fork X Y)
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : v.int_valuation_def r < 1 ‚Üî v.as_ideal ‚à£ ideal.span {r}
(f : stieltjes_function) (x : ‚Ñù) : ‚Ñù
{X : algebraic_geometry.Scheme} {U : topological_space.opens ‚Ü•(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} (hU : algebraic_geometry.is_affine_open U) (x : ‚Ü•U) : prime_spectrum ‚Ü•(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op U))
{G : Type u} [group G] [fintype G] {N : subgroup G} [N.normal] (hN : (fintype.card ‚Ü•N).coprime N.index) : ‚àÉ (H : subgroup G), N.is_complement' H
(R : Type u_1) [semiring R] (N : Type u_3) [add_comm_monoid N] [module R N] {Œπ : Type u_6} [decidable_eq Œπ] [subsingleton Œπ] (i : Œπ) : alternating_map R N N Œπ
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] (F : C ‚Üí D) [category_theory.functorial F] : Type (max u‚ÇÅ v‚ÇÇ)
{R S : Type u} [comm_semiring R] [comm_semiring S] (f : R ‚Üí+* S) : CommSemiRing.of R ‚ü∂ CommSemiRing.of S
 : pos_num ‚Üí pos_num ‚Üí znum
{R‚ÇÅ : Type u_3} {M‚ÇÅ : Type u_4} [ring R‚ÇÅ] [add_comm_group M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] (B‚ÇÅ : bilin_form R‚ÇÅ M‚ÇÅ) (f : module.End R‚ÇÅ M‚ÇÅ) : Prop
{A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] (a : A) (hf : function.injective ‚áë(algebra_map A B)) : minpoly A (‚áë(algebra_map A B) a) = polynomial.X - ‚áëpolynomial.C a
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ‚Ñï} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : ‚Ñï} (h : fs.card = m + 1) : (s.face h).points = s.points ‚àò ‚áë(fs.order_emb_of_fin h)
{Œ± : Type u_2} [division_monoid Œ±] {a : Œ±} : is_square a ‚Üí is_square a‚Åª¬π
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Ring) : category_theory.limits.cone F
{Œπ : Type u_1} {Œπ' : Type u_2} {R : Type u_3} {M : Type u_5} {M' : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid M'] [module R M'] (b : basis Œπ R M) (b' : basis Œπ' R M') (f : M ‚Üí M') (g : M' ‚Üí M) (hf : ‚àÄ (i : Œπ), f (‚áëb i) ‚àà set.range ‚áëb') (hg : ‚àÄ (i : Œπ'), g (‚áëb' i) ‚àà set.range ‚áëb) (hgf : ‚àÄ (i : Œπ), g (f (‚áëb i)) = ‚áëb i) (hfg : ‚àÄ (i : Œπ'), f (g (‚áëb' i)) = ‚áëb' i) : M ‚âÉ‚Çó[R] M'
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_mul Œ±] [has_add Œ±] [has_le Œ±] [has_mul Œ≤] [has_add Œ≤] [has_le Œ≤] : has_coe_to_fun (Œ± ‚âÉ+*o Œ≤) (Œª (_x : Œ± ‚âÉ+*o Œ≤), Œ± ‚Üí Œ≤)
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [is_R_or_C ùïÇ] [normed_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] {Œπ : Type u_3} (s : finset Œπ) (f : Œπ ‚Üí ùî∏) (h : ‚àÄ (i : Œπ), i ‚àà s ‚Üí ‚àÄ (j : Œπ), j ‚àà s ‚Üí commute (f i) (f j)) : exp ùïÇ (s.sum (Œª (i : Œπ), f i)) = s.noncomm_prod (Œª (i : Œπ), exp ùïÇ (f i)) _
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] {a b : Œ±} {s : set Œ±} [decidable_pred (Œª (_x : Œ±), _x ‚àà s)] (ha : a ‚àà lower_bounds s) (hb : b ‚àà upper_bounds s) : fintype ‚Ü•s
(slow : bool) (extra : list name) (use_only : bool) : tactic (list (name √ó linter))
{Œ± : Type u_1} {ùíú : finset (finset Œ±)} {r : ‚Ñï} : set.sized r ‚Üë(ùíú.slice r)
 : ‚Ñï ‚Üí ‚Ñï ‚Üí list ‚Ñï
{Œ± : Type u_1} {s : finset Œ±} {f : Œ± ‚Üí ennreal} (h : ‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚â† ‚ä§) : s.prod (Œª (a : Œ±), f a) < ‚ä§
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (l : list (Œ£ (a : Œ±), Œ≤ a)) (hash_fn : Œ± ‚Üí ‚Ñï) : hash_map Œ± Œ≤
{Œ± : Type u_1} {R : Type u_5} [semiring R] (l : filter Œ±) : (Œ± ‚Üí R) ‚Üí+* l.germ R
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k ‚Üí PE) (a b c : k) (h : a ‚â† c) : ‚áë(affine_map.line_map (slope f a b) (slope f b c)) ((c - b) / (c - a)) = slope f a c
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_initial C] [category_theory.limits.has_initial D] (f : ‚ä•_ D ‚ü∂ G.obj (‚ä•_ C)) [i : category_theory.is_iso f] : category_theory.limits.preserves_colimit (category_theory.functor.empty C) G
{R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [add_comm_group N] [module R M] [module R N] [lie_ring_module L M] [lie_ring_module L N] [lie_module R L M] [lie_module R L N] : has_coe_to_fun (M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N) (Œª (_x : M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N), M ‚Üí N)
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} {l : list Œπ} [decidable_eq Œπ] (hnd : l.nodup) (h : ‚àÄ (i : Œπ), i ‚àà l) : (Œ† (i : Œπ), Œ± i) ‚âÉ list.tprod Œ± l
(R : Type u) [comm_ring R] (A : Type v) [ring A] [algebra R A] (A' : subalgebra R A) : lie_subalgebra R A
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [normed_comm_ring ùïú] [add_comm_monoid E] [add_comm_monoid F] [module ùïú E] [module ùïú F] (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú) (s : set E) : set F
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [uniform_space Œ±] [uniform_space Œ≤] [uniform_space Œ≥] (h‚ÇÅ : Œ± ‚âÉ·µ§ Œ≤) (h‚ÇÇ : Œ≤ ‚âÉ·µ§ Œ≥) : Œ± ‚âÉ·µ§ Œ≥
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] (f g : linear_pmap R E F) (h : disjoint f.domain g.domain) (x : ‚Ü•(f.domain)) (y : ‚Ü•(g.domain)) (hxy : ‚Üëx = ‚Üëy) : ‚áëf x = ‚áëg y
 : tactic unit
(xs : interactive.parse (lean.parser.many lean.parser.ident)) : tactic unit
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} [char_zero k] {s : finset Œπ} (p : Œπ ‚Üí P) {n : ‚Ñï} (h : s.card = n + 1) : finset.centroid k s p ‚àà affine_span k (set.range p)
(k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p1 p2 : P) : p1 ‚àà affine_span k {p2} ‚Üî p1 = p2
{L : first_order.language} {L' : first_order.language} (œï : L ‚Üí·¥∏ L') : Prop
(n : ‚Ñï) : affine.simplex.points_with_circumcenter_index (n + 2) ‚Üí ‚Ñù
{Œ± : Type u_1} : list Œ± ‚Üí option Œ±
{Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ±] [topological_space Œ≤] : has_coe_to_fun (Œ± ‚ÜíCO Œ≤) (Œª (_x : Œ± ‚ÜíCO Œ≤), Œ± ‚Üí Œ≤)
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] (p : submodule R E) (p' : submodule R F) : linear_pmap R (E √ó F) E
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [Œ† (i : Œπ), has_zero (Œ≤ i)] : has_coe_to_fun (Œ†‚ÇÄ (i : Œπ), Œ≤ i) (Œª (_x : Œ†‚ÇÄ (i : Œπ), Œ≤ i), Œ† (i : Œπ), Œ≤ i)
(R : Type u_1) [ring R] : polynomial.cyclotomic 1 R = polynomial.X - 1
(L : first_order.language) (M : Type w) [L.Structure M] : L.hom M M
{X : Type u} {Y : Type v} {Z : Type w} [topological_space X] [topological_space Y] [topological_space Z] {f‚ÇÄ f‚ÇÅ : C(X, Y)} {g‚ÇÄ g‚ÇÅ : C(Y, Z)} (F : f‚ÇÄ.homotopy f‚ÇÅ) (G : g‚ÇÄ.homotopy g‚ÇÅ) : (g‚ÇÄ.comp f‚ÇÄ).homotopy (g‚ÇÅ.comp f‚ÇÅ)
{Œ± : Type u_1} [decidable_eq Œ±] (l : list Œ±) : equiv.perm Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (M N : Mon_ C) : Type v‚ÇÅ
{Œ± : Type u_1} {Œ≥ : Type u_3} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] {f g : Œ± ‚Üí Œ≥} {s : set Œ±} [Œ† (j : Œ±), decidable (j ‚àà s)] (hf : continuous_on f s) (hg : continuous_on g s·∂ú) (hs : measurable_set s) : measurable (s.piecewise f g)
(es : list pexpr) : lean.parser (tactic_state √ó list (expr √ó expr))
{Œ± : Type u_2} {Œ≤ : Type u_4} [topological_space Œ±] [has_one Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{Œ± Œ≤ : FinBoolAlg} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
{Œ± : Type u_1} : has_le (setoid Œ±)
(d : declaration) : tactic (option string)
{G : Type u_1} {H : Type u_2} [add_group H] (f : G ‚Üí H) : set G
{g : Type} [random_gen g] {n : ‚Ñï} [fact (0 < n)] : rand_g g (fin n)
(C : Type u‚ÇÅ) [category_theory.category C] : category_theory.yoneda_pairing C ‚âÖ category_theory.yoneda_evaluation C
(p : ‚Ñï) : padic_norm p 0 = 0
{Œ± : Type u} (x : Œ±) : free_add_semigroup Œ±
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} {R : Type u_11} [semiring R] [add_comm_monoid M] [add_comm_monoid N] [distrib_mul_action R M] [distrib_mul_action R N] {f g : (Œ± ‚Üí‚ÇÄ M) ‚Üí+[R] N} (h : ‚àÄ (a : Œ±), f.comp (finsupp.distrib_mul_action_hom.single a) = g.comp (finsupp.distrib_mul_action_hom.single a)) : f = g
(xs : list expr) : omega.int.exprterm ‚Üí tactic omega.int.preterm
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} [is_trans Œ≤ s] : has_coe (principal_seg r s) (initial_seg r s)
{n : ‚Ñï} {A : Type u} (F : A ‚Üí typevec n ‚Üí Type u) (v : typevec n) : Type u
(R : Type u_1) {S : Type u_4} [comm_semiring R] [comm_semiring S] [algebra R S] : tensor_product R S S ‚Üí‚Çê[R] S
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (f : M ‚Üí‚Çó[R] M) [hfg : module.finite R M] (f_surj : function.surjective ‚áëf) : function.injective ‚áëf
{Œ± : Type u_1} (Œ≤ : Type u_2) [linear_order Œ±] [linear_order Œ≤] [densely_ordered Œ≤] [no_min_order Œ≤] [no_max_order Œ≤] [nonempty Œ≤] (a : Œ±) : order.cofinal (order.partial_iso Œ± Œ≤)
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {s : category_theory.limits.cone F} (P : category_theory.limits.is_limit s) (e : K ‚âå J) : category_theory.limits.is_limit (category_theory.limits.cone.whisker e.functor s)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] (F : J ‚•§ C) : category_theory.limits.cocone F ‚âå (category_theory.limits.cone F.op)·µí·µñ
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_bot Œ±] [has_bot Œ≤] : has_coe_to_fun (bot_hom Œ± Œ≤) (Œª (_x : bot_hom Œ± Œ≤), Œ± ‚Üí Œ≤)
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (f : G ‚Üí+ N) : add_subgroup N
{Œ± : Type u_1} (s : set Œ±) (q : semiquot Œ±) : semiquot Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.abelian C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (h : category_theory.exact f g) : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ (category_theory.limits.image.Œπ f) _)
{C : Type u‚ÇÅ} [category_theory.small_category C] (P : C·µí·µñ ‚•§ Type u‚ÇÅ) : category_theory.limits.is_colimit (category_theory.cocone_of_representable P)
{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_3} [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] (f : normed_group_hom V‚ÇÅ V‚ÇÇ) (K : add_subgroup V‚ÇÇ) (C : ‚Ñù) : Prop
(tac : tactic.interactive.itactic) : tactic unit
{M : Type u_1} [has_mul M] : subsemigroup M ‚âÉo add_subsemigroup (additive M)
{M : Type u_1} [add_zero_class M] (c : add_con M) : M ‚Üí+ c.quotient
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x : Œ±} (hx : x ‚àà closure s) : metric.inf_dist x s = 0
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {p1 p2 : P} (h : p1 ‚â† p2) : euclidean_geometry.angle p1 p2 p1 = 0
(hs : name_set) : tactic (list expr)
{R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] {M‚ÇÅ : Type v} [add_comm_group M‚ÇÅ] [module R M‚ÇÅ] (f : M ‚âÉ‚Çó[R] M‚ÇÅ) : module.rank R M = module.rank R M‚ÇÅ
{Œ± : Type u_1} [linear_order Œ±] {a b c d : Œ±} (h‚ÇÅ : linear_order.min a b < linear_order.max c d) (h‚ÇÇ : linear_order.min c d < linear_order.max a b) : set.Icc a b ‚à™ set.Icc c d = set.Icc (linear_order.min a c) (linear_order.max b d)
(n : ‚Ñï) : fintype n.partition
{Œ± : Type u} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] : {s : set Œ± | is_preconnected s} ‚äÜ set.range (function.uncurry set.Icc) ‚à™ set.range (function.uncurry set.Ico) ‚à™ set.range (function.uncurry set.Ioc) ‚à™ set.range (function.uncurry set.Ioo) ‚à™ (set.range set.Ici ‚à™ set.range set.Ioi ‚à™ set.range set.Iic ‚à™ set.range set.Iio ‚à™ {set.univ, ‚àÖ})
 : unit
{R : Type u_1} [semiring R] (P : cubic R) : polynomial R
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÇ} [category_theory.category C] (X : C·µí·µñ) : (category_theory.functor.const J·µí·µñ).obj (opposite.unop X) ‚âÖ ((category_theory.functor.const J).obj X).left_op
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : cardinal
(P : pfunctor) : Type u_1
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ‚•§ D) [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.enough_projectives C] {X : C} (P : category_theory.ProjectiveResolution X) : (F.left_derived 0).obj X ‚ü∂ F.obj X
(u : level) (Œ± : expr) : tree expr ‚Üí expr
(l : expr) : tactic widget_override.local_collection
 : tactic.ring_exp.ex tactic.ring_exp.ex_type.prod ‚Üí tactic.ring_exp.ex tactic.ring_exp.ex_type.prod ‚Üí tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.prod)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (f : Œ± ‚Üí Œ≤ ‚äï Œ≥) : list Œ± ‚Üí list Œ≤ √ó list Œ≥
{R : Type v} [comm_ring R] {n : ‚Ñï} {A B : matrix (fin (n + 1)) (fin (n + 1)) R} (c : fin n ‚Üí R) (A_zero : ‚àÄ (i : fin (n + 1)), A i 0 = B i 0) (A_succ : ‚àÄ (i : fin (n + 1)) (j : fin n), A i j.succ = B i j.succ + c j * A i (‚áëfin.cast_succ j)) : A.det = B.det
{Œπ : Type u} {f g : Œπ ‚Üí ‚Ñù} {p : ‚Ñù} (hp : 1 ‚â§ p) (hf : ‚àÄ (i : Œπ), 0 ‚â§ f i) (hg : ‚àÄ (i : Œπ), 0 ‚â§ g i) (hf_sum : summable (Œª (i : Œπ), f i ^ p)) (hg_sum : summable (Œª (i : Œπ), g i ^ p)) : summable (Œª (i : Œπ), (f i + g i) ^ p) ‚àß (‚àë' (i : Œπ), (f i + g i) ^ p) ^ (1 / p) ‚â§ (‚àë' (i : Œπ), f i ^ p) ^ (1 / p) + (‚àë' (i : Œπ), g i ^ p) ^ (1 / p)
{R : Type u_1} (c‚ÇÅ c‚ÇÇ : R) : quaternion_algebra R c‚ÇÅ c‚ÇÇ ‚âÉ R √ó R √ó R √ó R
 : list (name √ó expr) ‚Üí option expr
{Œ± : Type u} [pseudo_metric_space Œ±] {x : Œ±} {r : ‚Ñù} (h : 0 ‚â§ r) : metric.diam (metric.ball x r) ‚â§ 2 * r
{n : ‚Ñï} : function.injective fin.succ_above
{R : Type u_1} [semiring R] (f : laurent_polynomial R) (m n : ‚Ñ§) : f * laurent_polynomial.T m * laurent_polynomial.T n = f * laurent_polynomial.T (m + n)
(cache : norm_cast.norm_cast_cache) (e : expr) : tactic norm_cast.norm_cast_cache
{Œ± : Type u_1} [linear_order Œ±] {s : finset Œ±} {k : ‚Ñï} (h : s.card = k) {f : fin k ‚Ü™o Œ±} (hfs : ‚àÄ (x : fin k), ‚áëf x ‚àà s) : f = s.order_emb_of_fin h
{Œ± : Type u_2} [has_one Œ±] [has_mul Œ±] : has_pow (set Œ±) ‚Ñï
{Œ± : Type u_1} [circular_preorder Œ±] {a b c : Œ±} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw c a b
(Œ± : Sort u) (tac_name : name) : Sort u
(n : ‚Ñï) : linarith.linexp ‚Üí bool
{E : Type u_1} [add_comm_group E] [module ‚Ñù E] {s : set E} (hs‚ÇÄ : ‚àÄ (x : E), x ‚àà s ‚Üí -x ‚àà s) (hs‚ÇÅ : convex ‚Ñù s) (hs‚ÇÇ : absorbent ‚Ñù s) : seminorm ‚Ñù E
(f : name ‚Üí name) (test : expr ‚Üí bool) (relevant : name_map ‚Ñï) (reorder : name_map (list ‚Ñï)) : expr ‚Üí expr
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [semi_normed_group Œ≤] : has_neg (bounded_continuous_function Œ± Œ≤)
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÇ] [comm_semigroup M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) : comm_semigroup M‚ÇÇ
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : Prop
{G : Type u_1} [group G] (H : subgroup G) [H.normal] [h : group.is_nilpotent G] : group.nilpotency_class (G ‚ß∏ H) ‚â§ group.nilpotency_class G
{Œ≤ : Type w} {C : Type u} [category_theory.category C] [unique Œ≤] (f : Œ≤ ‚Üí C) : category_theory.limits.limit_cone (category_theory.discrete.functor f)
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} (F : Top.presheaf C X) {x : ‚Ü•X} {Y : C} {f‚ÇÅ f‚ÇÇ : F.stalk x ‚ü∂ Y} (ih : ‚àÄ (U : topological_space.opens ‚Ü•X) (hxU : x ‚àà U), F.germ ‚ü®x, hxU‚ü© ‚â´ f‚ÇÅ = F.germ ‚ü®x, hxU‚ü© ‚â´ f‚ÇÇ) : f‚ÇÅ = f‚ÇÇ
{Œ± : Type u_1} {Œ≤ : Type u_2} : Œ≤ ‚Ü™ Œ± ‚äï Œ≤
{ùïú : Type u_1} {E : Type u_2} [ordered_ring ùïú] [add_comm_group E] [module ùïú E] {K : geometry.simplicial_complex ùïú E} {s t : finset E} (hs : s ‚àà K.faces) (ht : t ‚àà K.faces) : disjoint (‚áë(convex_hull ùïú) ‚Üës) (‚áë(convex_hull ùïú) ‚Üët) ‚à® ‚àÉ (u : finset E) (H : u ‚àà K.faces), ‚áë(convex_hull ùïú) ‚Üës ‚à© ‚áë(convex_hull ùïú) ‚Üët = ‚áë(convex_hull ùïú) ‚Üëu
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] (f : L.embedding M N) (s : L.substructure M) : L.equiv ‚Ü•s ‚Ü•(first_order.language.substructure.map f.to_hom s)
{G : Type u} [group G] [fintype G] (p : ‚Ñï) {n m : ‚Ñï} [hp : fact (nat.prime p)] (hdvd : p ^ m ‚à£ fintype.card G) (H : subgroup G) (hH : fintype.card ‚Ü•H = p ^ n) (hnm : n ‚â§ m) : ‚àÉ (K : subgroup G), fintype.card ‚Ü•K = p ^ m ‚àß H ‚â§ K
{A : Type u_4} (K : Type u_5) [comm_ring A] [is_domain A] (L : Type u_6) [field K] [field L] [algebra A K] [is_fraction_ring A K] [algebra A L] [algebra K L] [is_scalar_tower A K L] [finite_dimensional K L] : is_fraction_ring ‚Ü•(integral_closure A L) L
{Œ± : Type u_1} {Œ≤ : Type u_2} {m : measurable_space Œ±} [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : ‚àÄ (x y : Œ±), f x = f y) : measure_theory.strongly_measurable f
{f : ‚Ñù ‚Üí ‚Ñù} (hf : differentiable ‚Ñù f) (hf'_anti : antitone (deriv f)) : concave_on ‚Ñù set.univ f
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {r t : category_theory.limits.cone F} (i : r ‚âÖ t) : category_theory.limits.is_limit r ‚âÉ category_theory.limits.is_limit t
{Œ± : Type} (m : tactic Œ±) : tactic.norm_fin.eval_fin_m Œ±
{Œ± : Type u_1} {Œ≤ : lex Œ± ‚Üí Sort u_2} (h : Œ† (a : Œ±), Œ≤ (‚áëto_lex a)) (a : lex Œ±) : Œ≤ a
(h : expr) (hs : list expr) : tactic bool
 : expr.coord ‚Üí ‚Ñï
{Œ± : Type u_1} : has_Inf (setoid Œ±)
(C : Type u) [category_theory.category C] : Type u
{R : Type u_1} {S : Type u_3} [non_assoc_semiring R] [non_assoc_semiring S] : non_assoc_semiring (R √ó S)
(j : ‚Ñï) : ¬¨algebraic_topology.dold_kan.c.rel 0 j
{Œ± : Type u} {Œ≤ : Type v} (s : wseq Œ±) (f : Œ± ‚Üí wseq Œ≤) : wseq Œ≤
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Œπ] (p : Œπ ‚Üí P) : finite_dimensional k ‚Ü•((affine_span k (set.range p)).direction)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : ‚Ñï} (s : affine.simplex k P n) {fs‚ÇÅ fs‚ÇÇ : finset (fin (n + 1))} {m‚ÇÅ m‚ÇÇ : ‚Ñï} (h‚ÇÅ : fs‚ÇÅ.card = m‚ÇÅ + 1) (h‚ÇÇ : fs‚ÇÇ.card = m‚ÇÇ + 1) : finset.centroid k fs‚ÇÅ s.points = finset.centroid k fs‚ÇÇ s.points ‚Üî fs‚ÇÅ = fs‚ÇÇ
{F : Type u_1} [field F] [fintype F] [decidable_eq F] (a b : F) : char.quadratic_char F (a * b) = char.quadratic_char F a * char.quadratic_char F b
 : format ‚Üí format
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] [category_theory.limits.has_equalizers V] [category_theory.limits.has_cokernels V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] : chain_complex.single‚ÇÄ V ‚ãô homology_functor V (complex_shape.down ‚Ñï) 0 ‚âÖ ùü≠ V
{Œ± : Type u_2} {Œ≤ : Type u_3} [monoid Œ±] [monoid Œ≤] [mul_distrib_mul_action Œ± Œ≤] : mul_distrib_mul_action Œ± (set Œ≤)
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M ‚Üí+ P} {T : add_submonoid P} (hy : ‚àÄ (y : ‚Ü•S), ‚áëg ‚Üëy ‚àà T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} (z : N) : ‚áë(f.map hy k) z + ‚áë(k.to_map) (‚áëg ‚Üë((f.sec z).snd)) = ‚áë(k.to_map) (‚áëg (f.sec z).fst)
 : Type
{A B C D : SemiNormedGroup} {fab : A ‚ü∂ B} {fbd : B ‚ü∂ D} {fac : A ‚ü∂ C} {fcd : C ‚ü∂ D} (h : fab ‚â´ fbd = fac ‚â´ fcd) : SemiNormedGroup.explicit_cokernel fab ‚ü∂ SemiNormedGroup.explicit_cokernel fcd
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} (p : Œπ ‚Üí P) (i0 : Œπ) : vector_span k (set.range p) = submodule.span k (set.range (Œª (i : Œπ), p i -·µ• p i0))
{Œ± : Type u} [pseudo_emetric_space Œ±] {s : set Œ±} : isometry coe
{Œ± : Type u_1} {R : Type u_2} [comm_semiring R] (a b : R) (s : finset Œ±) : s.powerset.sum (Œª (t : finset Œ±), a ^ t.card * b ^ (s.card - t.card)) = (a + b) ^ s.card
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {A : C} {B : D} (e : category_theory.mono_over A ‚âå category_theory.mono_over B) : category_theory.subobject A ‚âå category_theory.subobject B
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {Y : C} {T : C ‚•§ D} [category_theory.full T] [category_theory.faithful T] : category_theory.limits.is_initial (category_theory.structured_arrow.mk (ùüô (T.obj Y)))
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} (F : C ‚•§ D) {c : category_theory.limits.cone K} (t : category_theory.limits.is_limit c) [category_theory.limits.preserves_limit K F] : category_theory.limits.is_limit (F.map_cone c)
(X Y : Type u) : X ‚®ø Y ‚âÖ X ‚äï Y
{K : Type u} [field K] (s : subfield K) {x y : K} : x ‚àà s ‚Üí y ‚àà s ‚Üí x * y ‚àà s
{C : Type u} [category_theory.category C] {F‚ÇÄ F‚ÇÅ F‚ÇÇ : C ‚•§ C} (Œ± : F‚ÇÄ ‚ü∂ F‚ÇÅ) (Œ≤ : F‚ÇÅ ‚ü∂ F‚ÇÇ) : category_theory.endofunctor.algebra.functor_of_nat_trans (Œ± ‚â´ Œ≤) ‚âÖ category_theory.endofunctor.algebra.functor_of_nat_trans Œ≤ ‚ãô category_theory.endofunctor.algebra.functor_of_nat_trans Œ±
{Œ± : Type u_1} [has_add Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b c d : Œ±} (h‚ÇÅ : a < b) (h‚ÇÇ : c < d) : a + c < b + d
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [category_theory.limits.has_pullback f g] [category_theory.mono f] : category_theory.mono category_theory.limits.pullback.snd
(M : Type u_1) (Œ± : Type u_2) [has_vadd M Œ±] [measurable_space M] [measurable_space Œ±] : Prop
{Œ± : Type u} [has_ssubset Œ±] [is_irrefl Œ± has_ssubset.ssubset] {a b : Œ±} : a ‚äÇ b ‚Üí a ‚â† b
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ‚ä§.direction = ‚ä§
 : (user_attribute (expr ‚Üí tactic (expr √ó expr)))
{R : Type u_1} {a b : R} [monoid R] (h : a * b = 1) : is_right_regular a
{G : Type u_10} [group_with_zero G] (a : G) (ha : a ‚â† 0) : equiv.perm G
{Œ± : Type u_1} {Œ≤ : Type u_2} {m‚ÇÅ : measurable_space Œ±} {m‚ÇÇ : measurable_space Œ≤} {f : Œ± ‚Üí Œ≤} : measurable f ‚Üí m‚ÇÇ ‚â§ measurable_space.map f m‚ÇÅ
(n : interactive.parse lean.parser.ident) (p : interactive.parse (lean.parser.tk ":" *> interactive.types.texpr)) : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] (m : measure_theory.measure Œ±) (f : Œ± ‚Üí measure_theory.measure Œ≤) : measure_theory.measure Œ≤
(x y z : pgame) : (x + y + z).relabelling (x + (y + z))
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚âÉ‚Çú Œ≤) : topological_space.opens Œ± ‚âÉ topological_space.opens Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} [decidable_eq Œ±] [fintype (Œ± √ó Œ≤)] [nonempty Œ≤] : fintype Œ±
{V : Type u} (G : simple_graph V) : Prop
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [module ùïú E] {x z : E} {s : set E} (hs : star_convex ùïú (x + z) s) : star_convex ùïú x ((Œª (x : E), x + z) ‚Åª¬π' s)
{E : Type u_1} [add_comm_group E] [module ‚Ñù E] (s : set E) (x : E) : ‚Ñù
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [is_strict_order Œ± r] (f : ‚Ñï ‚Üí Œ±) (H : ‚àÄ (n : ‚Ñï), r (f n) (f (n + 1))) : has_lt.lt ‚Ü™r r
{F : Type u ‚Üí Type w} {G : Type v ‚Üí Type u} {Œ± : Type v} (x : F (G Œ±)) : functor.comp F G Œ±
(L : first_order.language) {Œ± : Type u'} (s : set Œ±) : (L.with_constants Œ±).Theory
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] (f : ‚ÑÇ ‚Üí E) (c : ‚ÑÇ) (R : ‚Ñù) : E
(M : Type u_10) (Œ± : Type u_11) [has_scalar M Œ±] [has_scalar M·µê·µí·µñ Œ±] : Prop
{F : Type u_1} [field F] {p : polynomial F} {E : Type u_2} [field E] [algebra F E] [fact (polynomial.splits (algebra_map F E) p)] (œï : E ‚âÉ‚Çê[F] E) (x : ‚Ü•(p.root_set E)) : ‚Üë(‚áë(polynomial.gal.restrict p E) œï ‚Ä¢ x) = ‚áëœï ‚Üëx
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type u_1} [fintype Œπ] {b : Œπ ‚Üí V} : linear_independent K b ‚Üî fintype.card Œπ = set.finrank K (set.range b)
{R : Type u_2} {M‚ÇÅ : Type u_5} {M‚ÇÇ : Type u_6} [ring R] [add_comm_group M‚ÇÅ] [add_comm_group M‚ÇÇ] [module R M‚ÇÅ] [module R M‚ÇÇ] (Q‚ÇÅ : quadratic_form R M‚ÇÅ) (Q‚ÇÇ : quadratic_form R M‚ÇÇ) : Prop
(env : environment) (mod_info : module_info) (decl_name : name) : environment
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ Y‚ÇÇ) (f‚ÇÇ‚ÇÅ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) : X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ
{V : Type u_1} [inner_product_space ‚Ñù V] {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) : real.sin (inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = real.sin (inner_product_geometry.angle x y)
{K : Type u_1} [is_R_or_C K] : ‚Ñù ‚ÜíL[‚Ñù] K
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type u} [category_theory.category J] (R : D ‚•§ C) [category_theory.monadic_right_adjoint R] [category_theory.limits.preserves_colimits_of_shape J R] : category_theory.creates_colimits_of_shape J R
{R : Type u_1} [has_mul R] {a : R} : is_right_regular a ‚Üî is_smul_regular R (mul_opposite.op a)
{G : Type u_1} [add_group G] {s : set G} (h : is_add_subgroup s) : add_subgroup G
(p : ‚Ñï) (R : Type u_1) : Type u_1
{Œπ : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] [nonempty Œπ] (BR : ring_filter_basis R) {B : Œπ ‚Üí submodule R M} (hB : BR.submodules_basis B) : module_filter_basis R M
{Œπ : Type u_1} {E : Type u_2} [fintype Œπ] [normed_group E] [normed_space ‚Ñù E] (b : affine_basis Œπ ‚Ñù E) : interior (‚áë(convex_hull ‚Ñù) (set.range b.points)) = {x : E | ‚àÄ (i : Œπ), 0 < ‚áë(b.coord i) x}
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] (s : set A) : set (projective_spectrum ùíú)
(Œ± : Type u_1) [encodable Œ±] : Œ± ‚Ü™ ‚Ñï
{R : Type v} [ring R] {Œπ : Type u_1} {c : complex_shape Œπ} {C : homological_complex (Module R) c} {i : Œπ} (x : ‚Ü•(linear_map.ker (C.d_from i))) : ‚Ü•(C.homology i)
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [preorder Œπ] [Œ† (i : Œπ), preorder (Œ± i)] : preorder (Œ£‚Çó (i : Œπ), Œ± i)
{Œ± : Type u_1} {Œ≤ : Type u_2} {s : set Œ±} {u : Œ± ‚Üí set Œ≤} {x : Œ±} (xs : x ‚àà s) : u x ‚äÜ ‚ãÉ (x : Œ±) (H : x ‚àà s), u x
{Œ± : Type u_1} {C : Œ±·µí·µà ‚Üí Sort u_2} (h‚ÇÇ : Œ† (a : Œ±), C (‚áëorder_dual.to_dual a)) (a : Œ±·µí·µà) : C a
{Œ± : Type u_1} (s t : multiset Œ±) : Prop
{Œπ : Type u} (f : Œπ ‚Üí ordinal) : ordinal
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) (v : E) : v ‚àà K·óÆ ‚Üî ‚àÄ (u : E), u ‚àà K ‚Üí has_inner.inner u v = 0
{M : Type u_1} [has_add M] (c : add_con M) {a b : M} : ‚Üëa = ‚Üëb ‚Üî ‚áëc a b
{Œ± : Type u_1} (l : list Œ±) (nd : l.nodup) (h : ‚àÄ (x : Œ±), x ‚àà l) : {f // function.bijective f}
{Œ± : Type u_1} (o : part Œ±) [decidable o.dom] : finset Œ±
{G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : 0 < order_of x
{M : Type u} {N : Type v} [add_monoid M] [add_monoid N] (f : M ‚Üí+ N) : add_units M ‚Üí+ add_units N
 : ‚Ñï ‚Üí expr ‚Üí expr ‚Üí expr
{Œ± : Type u_1} {Œπ : Sort u_4} {s : Œπ ‚Üí set Œ±} {t : set Œ±} (i : Œπ) (h : s i ‚äÜ t) : (‚ãÇ (i : Œπ), s i) ‚äÜ t
{Œ± : Type u} (s : set Œ±) : subsingleton ‚Ü•s ‚Üî s.subsingleton
(R : Type u_2) {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (n : ‚Ñï) (b : M) : n ‚Ä¢ b = ‚Üën ‚Ä¢ b
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {f : E ‚Üí F √ó G} {x : E} (hf : cont_diff_at ùïú n f x) : cont_diff_at ùïú n (Œª (x : E), (f x).fst) x
 : ‚Ü•{‚ä•, ‚ä§}·∂ú ‚âÉ‚Çú ‚Ñù
(n : interactive.parse lean.parser.ident) (p : interactive.parse (lean.parser.tk ":" *> interactive.types.texpr)) : tactic unit
{Œ± : Type u_1} [measurable_space Œ±] (m‚ÇÅ m‚ÇÇ : measure_theory.outer_measure Œ±) : (m‚ÇÅ ‚äî m‚ÇÇ).trim = m‚ÇÅ.trim ‚äî m‚ÇÇ.trim
{P : ‚Ñ§ ‚Üí Prop} (Hbdd : ‚àÉ (b : ‚Ñ§), ‚àÄ (z : ‚Ñ§), P z ‚Üí b ‚â§ z) (Hinh : ‚àÉ (z : ‚Ñ§), P z) : ‚àÉ (lb : ‚Ñ§), P lb ‚àß ‚àÄ (z : ‚Ñ§), P z ‚Üí lb ‚â§ z
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÇ] [has_one M‚ÇÇ] [has_pow M‚ÇÇ ‚Ñï] [comm_monoid M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) : comm_monoid M‚ÇÇ
{M : Type u_1} {N : Type u_2} (Œ± : Type u_6) [has_scalar M Œ±] (g : N ‚Üí M) : has_scalar N Œ±
(Œ± : Type u_1) (Œ≤ : Type u_2) [uniform_space Œ≤] (ùîñ : set (set Œ±)) : topological_space (Œ± ‚Üí Œ≤)
 : list bool ‚Üí pos_num
 : cc_state ‚Üí expr ‚Üí tactic cc_state
{f : polynomial ‚ÑÇ} (hf : 0 < f.degree) : ‚àÉ (z : ‚ÑÇ), f.is_root z
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [ring R] [is_domain R] [add_comm_group M] [module R M] (b : basis Œπ R M) (P : submodule R M ‚Üí Sort u_2) (ih : Œ† (N : submodule R M), (Œ† (N' : submodule R M), N' ‚â§ N ‚Üí Œ† (x : M), x ‚àà N ‚Üí (‚àÄ (c : R) (y : M), y ‚àà N' ‚Üí c ‚Ä¢ x + y = 0 ‚Üí c = 0) ‚Üí P N') ‚Üí P N) (n : ‚Ñï) (N : submodule R M) (rank_le : ‚àÄ {m : ‚Ñï} (v : fin m ‚Üí ‚Ü•N), linear_independent R (coe ‚àò v) ‚Üí m ‚â§ n) : P N
{Œ± : Type u} (c : computation Œ±) : computation Œ±
{X : Type u} [topological_space X] (x‚ÇÄ x‚ÇÅ : X) [path_connected_space X] : fundamental_group X x‚ÇÄ ‚âÉ* fundamental_group X x‚ÇÅ
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (a : Œ±) : Prop
(R : Type u) (M : Type v) (N : Type z) [semiring R] [add_comm_monoid M] [module R M] [module.free R M] [add_comm_monoid N] [module R N] {S : Type z} [semiring S] [module S N] [smul_comm_class R S N] : (module.free.choose_basis_index R M ‚Üí N) ‚âÉ‚Çó[S] M ‚Üí‚Çó[R] N
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) : tensor_algebra R M ‚Üí tensor_algebra R M ‚Üí Prop
{R : Type u} [ring R] {X‚ÇÅ : Type v} {g‚ÇÅ : add_comm_group X‚ÇÅ} {m‚ÇÅ : module R X‚ÇÅ} {X‚ÇÇ : Module R} (e : X‚ÇÅ ‚âÉ‚Çó[R] ‚Ü•X‚ÇÇ) : Module.of R X‚ÇÅ ‚âÖ X‚ÇÇ
{B : Type u} [category_theory.bicategory B] {a b : B} {f g h i : a ‚ü∂ b} [category_theory.bicategory.lift_hom g] [category_theory.bicategory.lift_hom h] [category_theory.bicategory.bicategorical_coherence g h] (Œ∑ : f ‚âÖ g) (Œ∏ : h ‚âÖ i) : f ‚âÖ i
(Œ± : Type u_1) [complete_lattice Œ±] : Prop
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : set P
{R : Type u_4} {S : Type u_5} [has_mul R] [has_add R] [has_mul S] [has_add S] (e : R ‚âÉ+* S) : S ‚âÉ+* R
{M : Type u_5} [monoid M] {R : Type u_11} [semiring R] [mul_semiring_action M R] {S : Type u_13} [semiring S] [mul_semiring_action M S] (self : R ‚Üí+*[M] S) : R ‚Üí+* S
(R : Type u) (M : Type v) [has_scalar R M] : Type v
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : Œπ ‚Üí P} (hi : affine_independent k p) {s : finset Œπ} {n : ‚Ñï} (hc : s.card = n + 1) : finite_dimensional.finrank k ‚Ü•(vector_span k ‚Üë(finset.image p s)) = n
{Œ± : Type u_1} {ùïú : Type u_14} [normed_field ùïú] {l : filter Œ±} {u v : Œ± ‚Üí ùïú} (h : u =O[l] v) : u / v * v =·∂†[l] u
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} [discrete_topology ‚Ü•s] {x : Œ±} (hx : x ‚àà s) : ‚àÉ (U : set Œ±) (H : U ‚àà nhds_within x {x}·∂ú), disjoint U s
(G : Type u_3) [group G] : Type u_3
{Œ± : Type u} [semilattice_inf Œ±] [nonempty Œ±] (s : finset Œ±) : bdd_below ‚Üës
{M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_3} [cancel_comm_monoid_with_zero M‚ÇÄ] [has_zero M‚ÇÄ'] [has_mul M‚ÇÄ'] [has_one M‚ÇÄ'] [has_pow M‚ÇÄ' ‚Ñï] (f : M‚ÇÄ' ‚Üí M‚ÇÄ) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÄ'), f (x * y) = f x * f y) (npow : ‚àÄ (x : M‚ÇÄ') (n : ‚Ñï), f (x ^ n) = f x ^ n) : cancel_comm_monoid_with_zero M‚ÇÄ'
{M : Type u_3} {S : Type u_4} [div_inv_monoid M] [set_like S M] [hSM : subgroup_class S M] {H : S} : has_pow ‚Ü•H ‚Ñ§
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 : P} : p1 -·µ• p2 = 0 ‚Üî p1 = p2
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) (a : erased Œ±) : erased Œ≤
{Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [ring Œ≤] {f : Œ± ‚Üí Œ≤} {x y : Œ±} (hf : is_ring_hom f) : f (x - y) = f x - f y
(f : circle_deg1_lift) : ‚Ñù
(E : Type u_8) [comm_group E] [topological_space E] [topological_group E] : continuous_monoid_hom E E
{Œ± : Sort u} {Œ±' : Sort w} [decidable_eq Œ±] [decidable_eq Œ±'] {Œ≤ : Sort u_1} (g : Œ±' ‚Üí Œ≤) {f : Œ± ‚Üí Œ±'} (hf : function.injective f) (i : Œ±) (a : Œ≤) : function.update g (f i) a ‚àò f = function.update (g ‚àò f) i a
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} (h_mono : monotone_on f s) (hs : s ‚àà nhds_within a (set.Ici a)) (hfs : ‚àÄ (b : Œ≤), b > f a ‚Üí (‚àÉ (c : Œ±) (H : c ‚àà s), f c ‚àà set.Ioo (f a) b)) : continuous_within_at f (set.Ici a) a
{J : Type v} : category_theory.limits.wide_pullback_shape J ‚Üí category_theory.limits.wide_pullback_shape J ‚Üí Type v
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J ‚Üí C) [category_theory.limits.has_biproduct f] {b : category_theory.limits.bicone f} (hb : b.is_bilimit) : (hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.biproduct.is_limit f)).hom = category_theory.limits.biproduct.lift b.œÄ
 : expr ‚Üí expr
(Œ± : Type u) [t : topological_space Œ±] [topological_space.separable_space Œ±] [nonempty Œ±] : ‚Ñï ‚Üí Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (J : Type w) [category_theory.category J] (F : C·µí·µñ ‚•§ D·µí·µñ) [category_theory.limits.preserves_colimits_of_shape J·µí·µñ F] : category_theory.limits.preserves_limits_of_shape J F.unop
{X Y : algebraic_geometry.LocallyRingedSpace} (f g : X ‚ü∂ Y) : category_theory.limits.is_colimit (algebraic_geometry.LocallyRingedSpace.coequalizer_cofork f g)
(Œ± : Type u) (Œ≤ : Type v) (ùïú : Type u_2) [pseudo_metric_space ùïú] [topological_space Œ±] [pseudo_metric_space Œ≤] [semiring ùïú] [add_comm_monoid Œ≤] [module ùïú Œ≤] [has_bounded_smul ùïú Œ≤] [has_lipschitz_add Œ≤] : bounded_continuous_function Œ± Œ≤ ‚Üí‚Çó[ùïú] C(Œ±, Œ≤)
{Œ± : Type u_2} {Œ≤ : Type u_3} [bornology Œ±] [bornology Œ≤] : has_coe_to_fun (locally_bounded_map Œ± Œ≤) (Œª (_x : locally_bounded_map Œ± Œ≤), Œ± ‚Üí Œ≤)
 : tactic unit
{Œ± : Type u_1} : option Œ± ‚Üí list Œ±
{C : Type u} [category_theory.category C] {f g : category_theory.arrow C} {F : category_theory.limits.mono_factorisation f.hom} (hF : category_theory.limits.is_image F) (sq : f ‚ü∂ g) [category_theory.is_iso sq] : category_theory.limits.is_image (F.of_arrow_iso sq)
{Œ± : Type u} {Œ≤ : Type v} (s : seq (Œ± √ó Œ≤)) : seq Œ± √ó seq Œ≤
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] {f g : ‚ÑÇ ‚Üí E} (hdf : diff_cont_on_cl ‚ÑÇ f (set.Iio 0 √ó‚ÑÇ set.Iio 0)) (hBf : ‚àÉ (c : ‚Ñù) (H : c < 2) (B : ‚Ñù), f =O[filter.comap complex.abs filter.at_top ‚äì filter.principal (set.Iio 0 √ó‚ÑÇ set.Iio 0)] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)) (hdg : diff_cont_on_cl ‚ÑÇ g (set.Iio 0 √ó‚ÑÇ set.Iio 0)) (hBg : ‚àÉ (c : ‚Ñù) (H : c < 2) (B : ‚Ñù), g =O[filter.comap complex.abs filter.at_top ‚äì filter.principal (set.Iio 0 √ó‚ÑÇ set.Iio 0)] Œª (z : ‚ÑÇ), real.exp (B * complex.abs z ^ c)) (hre : ‚àÄ (x : ‚Ñù), x ‚â§ 0 ‚Üí f ‚Üëx = g ‚Üëx) (him : ‚àÄ (x : ‚Ñù), x ‚â§ 0 ‚Üí f (‚Üëx * complex.I) = g (‚Üëx * complex.I)) : set.eq_on f g {z : ‚ÑÇ | z.re ‚â§ 0 ‚àß z.im ‚â§ 0}
{F : Type u_2} [normed_group F] {f : ‚Ñù ‚Üí F} {a b c : ‚Ñù} (hf : (Œª (x : ‚Ñù), (x - c)‚Åª¬π) =O[nhds_within c {c}·∂ú] f) (hne : a ‚â† b) (hc : c ‚àà set.interval a b) : ¬¨interval_integrable f measure_theory.measure_space.volume a b
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] : add_valuation ‚Ñö_[p] (with_top ‚Ñ§)
(J : Type v) : category_theory.limits.wide_pushout_shape_unop J ‚ãô category_theory.limits.wide_pullback_shape_op J ‚âÖ ùü≠ (category_theory.limits.wide_pushout_shape J)·µí·µñ
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {c : category_theory.limits.fork f g} (i : category_theory.limits.is_limit c) : category_theory.mono c.Œπ
{F : pfunctor} {n : ‚Ñï} : pfunctor.approx.cofix_a F n.succ ‚Üí F.A
{M : Type u_1} [topological_space M] : M ‚âÉ‚Çú M·µê·µí·µñ
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] {D : J ‚•§ T.algebra} (c : category_theory.limits.cocone (D ‚ãô T.forget)) (t : category_theory.limits.is_colimit c) [category_theory.limits.preserves_colimit (D ‚ãô T.forget) ‚ÜëT] [category_theory.limits.preserves_colimit ((D ‚ãô T.forget) ‚ãô ‚ÜëT) ‚ÜëT] : category_theory.limits.cocone D
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M ‚Üí+ P} (H : c ‚â§ add_con.ker f) : (c.lift f H).comp c.mk' = f
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [has_zero M] [add_comm_monoid N] [add_comm_monoid P] (h : N ‚Üí+ P) (f : Œ± ‚Üí‚ÇÄ M) (g : Œ± ‚Üí M ‚Üí N) : ‚áëh (f.sum g) = f.sum (Œª (a : Œ±) (b : M), ‚áëh (g a b))
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J·µí·µñ ‚•§ C·µí·µñ} (c : category_theory.limits.cone F) : category_theory.limits.cocone F.unop
(ùïú : Type u_1) {E : Type u_3} [semi_normed_ring ùïú] [has_scalar ùïú E] (A : set E) : Prop
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_bot Œ±] [has_bot Œ≤] (f : bot_hom Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : bot_hom Œ± Œ≤
{Œπ : Type u_1} {R : Type u_2} {M : Œπ ‚Üí Type u_4} [semiring R] [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] {Œ∑ : Œπ ‚Üí Type u_3} (b : Œ† (i : Œπ), basis (Œ∑ i) R (M i)) : basis (Œ£ (i : Œπ), Œ∑ i) R (Œ†‚ÇÄ (i : Œπ), M i)
{Œ± : Type u} [comm_ring Œ±] [no_zero_divisors Œ±] : cancel_comm_monoid_with_zero Œ±
(ns : list name) (t : tactic.interactive.case_tag) : tactic.interactive.case_tag.match_result
{G‚ÇÄ : Type u_2} {G‚ÇÄ' : Type u_4} [comm_group_with_zero G‚ÇÄ] [has_zero G‚ÇÄ'] [has_mul G‚ÇÄ'] [has_one G‚ÇÄ'] [has_inv G‚ÇÄ'] [has_div G‚ÇÄ'] [has_pow G‚ÇÄ' ‚Ñï] [has_pow G‚ÇÄ' ‚Ñ§] (h01 : 0 ‚â† 1) (f : G‚ÇÄ ‚Üí G‚ÇÄ') (hf : function.surjective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ‚àÄ (x y : G‚ÇÄ), f (x * y) = f x * f y) (inv : ‚àÄ (x : G‚ÇÄ), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : G‚ÇÄ), f (x / y) = f x / f y) (npow : ‚àÄ (x : G‚ÇÄ) (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : G‚ÇÄ) (n : ‚Ñ§), f (x ^ n) = f x ^ n) : comm_group_with_zero G‚ÇÄ'
(a : zmod 8) : ‚áëzmod.œá‚Çà' a = ‚áëzmod.œá‚ÇÑ ‚Üëa * ‚áëzmod.œá‚Çà a
(M : Type u) [semigroup M] : Semigroup
{C : Type u} [category_theory.category C] (X : category_theory.simplicial_object.augmented C) : X.right_op.left_op ‚âÖ X
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a b : Œ±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{C : Type u‚ÇÅ} [category_theory.small_category C] {D : Type u‚ÇÅ} [category_theory.small_category D] (F : C ‚•§ D) : category_theory.colimit_adj.extend_along_yoneda (F ‚ãô category_theory.yoneda) ‚âÖ category_theory.Lan F.op
{Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≥ : Type u_5} [has_sup Œ±] [has_bot Œ±] [has_sup Œ≤] [has_bot Œ≤] [has_sup Œ≥] [has_bot Œ≥] (f : sup_bot_hom Œ≤ Œ≥) (g : sup_bot_hom Œ± Œ≤) : sup_bot_hom Œ± Œ≥
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {Œπ : Type u_6} (Z : topological_vector_bundle_core R B F Œπ) : continuous Z.proj
{Œπ : Type u} {Œ≤‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {Œ≤‚ÇÇ : Œπ ‚Üí Type v‚ÇÇ} [Œ† (i : Œπ), add_zero_class (Œ≤‚ÇÅ i)] [Œ† (i : Œπ), add_zero_class (Œ≤‚ÇÇ i)] (f : Œ† (i : Œπ), Œ≤‚ÇÅ i ‚Üí+ Œ≤‚ÇÇ i) : (Œ†‚ÇÄ (i : Œπ), Œ≤‚ÇÅ i) ‚Üí+ Œ†‚ÇÄ (i : Œπ), Œ≤‚ÇÇ i
(x : pgame) : (0 + x).relabelling x
{R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Œπ : Type u_1} (b : basis Œπ R M) (h : module.rank R M < cardinal.aleph_0) : fintype Œπ
{Œ± : Type u_1} {Œ≤ : Type u_2} [infinite Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) : ‚àÉ (x y : Œ±), x ‚â† y ‚àß f x = f y
(Œ± : Type v) : Prop
{F : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [non_assoc_semiring Œ±] [non_assoc_semiring Œ≤] [ring_hom_class F Œ± Œ≤] (f : F) (a : Œ±) : ‚áëf (bit1 a) = bit1 (‚áëf a)
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] (P : C·µí·µñ ‚•§ A) {X : C} (S : category_theory.sieve X) (E : A·µí·µñ) : (S.arrows.diagram.op ‚ãô P).cones.obj E ‚âÉ {x // x.sieve_compatible}
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} {x : Œ±} {r : ‚Ñù} (h : x ‚àà s) (H : metric.Hausdorff_dist s t < r) (fin : emetric.Hausdorff_edist s t ‚â† ‚ä§) : ‚àÉ (y : Œ±) (H : y ‚àà t), has_dist.dist x y < r
{Œ± : Type u_1} [comm_semiring Œ±] (E : linear_recurrence Œ±) : (fin E.order ‚Üí Œ±) ‚Üí‚Çó[Œ±] fin E.order ‚Üí Œ±
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [invertible 2] : quadratic_form R M ‚Üí‚Çó[‚Ñ§] bilin_form R M
(Œ± : Type u) : free_ring Œ± ‚Üí+* free_comm_ring Œ±
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [unique_factorization_monoid Œ±] {a p : associates Œ±} (hp : irreducible p) [Œ† (n : ‚Ñï), decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n) : a = p ^ nat.find _
(x : enat) [decidable x.dom] : with_top ‚Ñï
{R : Type u_1} [semiring R] (s : subsemiring R) {l : list R} : (‚àÄ (x : R), x ‚àà l ‚Üí x ‚àà s) ‚Üí l.prod ‚àà s
(p : ‚Ñï) [hp : fact (nat.prime p)] (n : ‚Ñ§) : ‚Ñï ‚Üí mv_polynomial (fin 1 √ó ‚Ñï) ‚Ñ§
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] (f : S.localization_map N) : add_localization S ‚âÉ+ N
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) [category_theory.is_filtered J] (x y : Œ£ (j : J), ‚Ü•(F.obj j)) (k : J) (f : x.fst ‚ü∂ k) (g : y.fst ‚ü∂ k) : AddMon.filtered_colimits.M.mk F x + AddMon.filtered_colimits.M.mk F y = AddMon.filtered_colimits.M.mk F ‚ü®k, ‚áë(F.map f) x.snd + ‚áë(F.map g) y.snd‚ü©
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {s t : category_theory.limits.cofork f g} (i : s.X ‚âÖ t.X) (w : s.œÄ ‚â´ i.hom = t.œÄ) : s ‚âÖ t
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : C √ó C √ó C ‚•§ C
(R : Type u) (A : Type v) (B : Type w) [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] : Type (max v w)
{G : Type u_1} [add_group G] [hN : nontrivial G] : add_monoid.is_torsion_free G ‚Üí ¬¨add_monoid.is_torsion G
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) (s : set Œ≤) : e.to_local_equiv.source ‚à© ‚áëe ‚Åª¬π' interior s = e.to_local_equiv.source ‚à© interior (‚áëe ‚Åª¬π' s)
(T : Type u_1) [unique T] : free_abelian_group T ‚âÉ+ ‚Ñ§
(a b : tactic.itauto.prop) : tactic.itauto.prop
{G : Type u_10} {H : Type u_11} [group G] [division_monoid H] (h : G ‚âÉ* H) (x : G) : ‚áëh x‚Åª¬π = (‚áëh x)‚Åª¬π
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {r : R} (h : same_ray R x y) (hr : 0 ‚â§ r) : same_ray R (r ‚Ä¢ x) y
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) : o.oangle (‚áë(o.rotation (o.oangle x y)) x) y = 0
 : DistribLattice ‚•§ DistribLattice
{Œ± : Type u_1} [uniform_space Œ±] : (uniformity Œ±).has_basis (Œª (V : set (Œ± √ó Œ±)), V ‚àà uniformity Œ±) closure
{M : Type w} {Œ± : Type u'} (f : Œ± ‚Üí M) : (first_order.language.constants_on Œ±).Structure M
{Œπ : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [monoid R] [add_monoid Œπ] (A : Œπ ‚Üí S) : Prop
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {Œπ : Type w} (h : basis Œπ K V) : ‚Üë(finite_dimensional.finrank K V) = cardinal.mk Œπ
(V : Type (u+1)) [category_theory.large_category V] (G : Mon) : Action V G ‚âå category_theory.single_obj ‚Ü•G ‚•§ V
(ùïú : Type u_4) (F : Type u_5) [is_R_or_C ùïú] [add_comm_group F] [module ùïú F] : Type (max u_4 u_5)
{Œ≥ : Type} (local_c : widget.tc widget.local_collection Œ≥) (target_c : widget.tc expr Œ≥) : widget.tc unit Œ≥
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] [fintype G] [decidable_eq N] (f : G ‚Üí+ N) : fintype ‚Ü•(f.range)
{Œ± : Type u_1} {M : Type u_5} [has_zero M] : function.injective coe_fn
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (Œ± : Type u_1) [add_right_cancel_semigroup Œ±] [has_one Œ±] : Type (max u u_1 v)
{m‚ÇÅ : Type u‚ÇÄ ‚Üí Type v‚ÇÄ} {m‚ÇÇ : Type u‚ÇÅ ‚Üí Type v‚ÇÅ} {Œ±‚ÇÅ œÅ‚ÇÅ : Type u‚ÇÄ} {Œ±‚ÇÇ œÅ‚ÇÇ : Type u‚ÇÅ} (F : (œÅ‚ÇÅ ‚Üí m‚ÇÅ Œ±‚ÇÅ) ‚âÉ (œÅ‚ÇÇ ‚Üí m‚ÇÇ Œ±‚ÇÇ)) : reader_t œÅ‚ÇÅ m‚ÇÅ Œ±‚ÇÅ ‚âÉ reader_t œÅ‚ÇÇ m‚ÇÇ Œ±‚ÇÇ
 : zero_hom cardinal ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] (f : Œ± ‚Üí Œ≤) (hf : uniform_embedding f) : Œ± ‚âÉ·µ§ ‚Ü•(set.range f)
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] {œÉR : Type u_1} [set_like œÉR R] [subsemiring_class œÉR R] (f : R ‚Üí+* S) (s : œÉR) : ‚Ü•s ‚Üí+* S
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (x : Œ± (fin.last n)) (p : Œ† (i : fin n), Œ± (‚áëfin.cast_succ i)) (z : Œ± (fin.last n)) : function.update (fin.snoc p x) (fin.last n) z = fin.snoc p z
(R : Type u_1) {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (vw : A √ó A) : A ‚Üí‚Çó[R] A
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_image f] : C
{Œ± : Type u} [topological_space Œ±] [locally_compact_space Œ±] [regular_space Œ±] {K U : set Œ±} (hK : is_compact K) (hU : is_open U) (hKU : K ‚äÜ U) : ‚àÉ (V : set Œ±), is_open V ‚àß K ‚äÜ V ‚àß closure V ‚äÜ U ‚àß is_compact (closure V)
{Œ± : Type u} {Œ≤ : Type v} [slim_check.sampleable Œ±] [slim_check.sampleable Œ≤] : slim_check.total_function Œ± Œ≤ ‚Üí ‚Ñï
 : turing.to_partrec.cont ‚Üí turing.to_partrec.cont ‚Üí turing.to_partrec.cont
{Œ± : Type u_1} [lattice Œ±] [order_bot Œ±] (a : Œ±) : Type u_1
(K : Type u_1) [field K] [is_alg_closed K] (S : set ‚Ñï+) : is_cyclotomic_extension S K K
{Œ± : Type u} [has_subset Œ±] [is_trans Œ± has_subset.subset] {a b c : Œ±} : a ‚äÜ b ‚Üí b ‚äÜ c ‚Üí a ‚äÜ c
(f : circle_deg1_lift) (x : ‚Ñù) : filter.tendsto (Œª (n : ‚Ñï), (‚áë(f ^ n) x - x) / ‚Üën) filter.at_top (nhds f.translation_number)
(e : pexpr) : tactic format
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (x : E) : formal_multilinear_series ùïú E F
{V : Type u} {G : simple_graph V} (P : G.partition) (v : V) : set V
{Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] {b : Œ±} [nonempty Œπ] {f : Œπ ‚Üí Œ±} (h‚ÇÅ : ‚àÄ (i : Œπ), f i ‚â§ b) (h‚ÇÇ : ‚àÄ (w : Œ±), w < b ‚Üí (‚àÉ (i : Œπ), w < f i)) : (‚®Ü (i : Œπ), f i) = b
 : user_attribute unit to_additive.value_type
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [linear_ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f g : E ‚Üí Œ≤} (hf : concave_on ùïú s f) (hg : concave_on ùïú s g) : concave_on ùïú s (f ‚äì g)
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [add_comm_monoid N] (f : Œ± ‚Üí‚ÇÄ M) (y : Œ±) (g : Œ± ‚Üí M ‚Üí N) (hg : ‚àÄ (i : Œ±), g i 0 = 0) : g y (‚áëf y) + (finsupp.erase y f).sum g = f.sum g
{Œ± : Type} : io Œ± ‚Üí tactic Œ±
{G : Type u} {x y : G} [fintype G] [add_left_cancel_monoid G] (h : add_order_of x = add_order_of y) : ‚Ü•‚Üë(add_submonoid.multiples x) ‚âÉ ‚Ü•‚Üë(add_submonoid.multiples y)
{V : Type u_2} {P : Type u_3} [semi_normed_group V] [pseudo_metric_space P] [normed_add_torsor V P] (x : P) : P ‚âÉ·µ¢ V
{C : Type u} [category_theory.category C] {P Q R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R) [category_theory.strong_mono f] [category_theory.strong_mono g] : category_theory.strong_mono (f ‚â´ g)
 : expr ‚Üí ‚Ñï ‚Üí tactic (list expr √ó expr)
{X : Type u_2} [emetric_space X] {m‚ÇÅ m‚ÇÇ : ennreal ‚Üí ennreal} {c : ennreal} (hc : c ‚â† ‚ä§) (h0 : c ‚â† 0) (hle : m‚ÇÅ ‚â§·∂†[nhds_within 0 (set.Ici 0)] c ‚Ä¢ m‚ÇÇ) : measure_theory.outer_measure.mk_metric m‚ÇÅ ‚â§ c ‚Ä¢ measure_theory.outer_measure.mk_metric m‚ÇÇ
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) : ‚Ü•(e.to_local_equiv.source) ‚âÉ‚Çú ‚Ü•(e.to_local_equiv.target)
{Œ± : Type u_1} [measurable_space Œ±] {Œπ : Type u_2} {f : Œπ ‚Üí Œ± ‚Üí ennreal} {g : Œ± ‚Üí ennreal} (u : filter Œπ) [u.ne_bot] [u.is_countably_generated] (hf : ‚àÄ (i : Œπ), measurable (f i)) (lim : filter.tendsto f u (nhds g)) : measurable g
{Œ± : Type u} [monoid Œ±] : invertible 1
{A : Type u} [category_theory.category A] [category_theory.abelian A] {X Y Z : A} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (w : f ‚â´ g = 0) : category_theory.abelian.homology_c f g w ‚ü∂ category_theory.abelian.homology_k f g w
(e : expr) : name_set
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f : J ‚Üí C} [category_theory.limits.has_biproduct f] {P : C} (p : Œ† (b : J), f b ‚ü∂ P) : ‚®Å f ‚ü∂ P
{R : Type u_1} [comm_ring R] (a1 a2 a3 a4 a6 : R) : R
{M : Type u} [monoid M] {F : Type v} [division_ring F] [mul_semiring_action M F] (x : M) (m : F) : x ‚Ä¢ m‚Åª¬π = (x ‚Ä¢ m)‚Åª¬π
{Œ± : Type u_1} [pseudo_emetric_space Œ±] {f : ‚Ñï ‚Üí Œ±} (d : ‚Ñï ‚Üí ennreal) (hf : ‚àÄ (n : ‚Ñï), has_edist.edist (f n) (f n.succ) ‚â§ d n) {a : Œ±} (ha : filter.tendsto f filter.at_top (nhds a)) (n : ‚Ñï) : has_edist.edist (f n) a ‚â§ ‚àë' (m : ‚Ñï), d (n + m)
(D : algebraic_geometry.Scheme.glue_data) : algebraic_geometry.Scheme
{T : Type u‚ÇÅ} [category_theory.category T] {X Y : T} (f : Y ‚ü∂ X) : category_theory.over X
{C : Type u‚ÇÅ} [category_theory.category C] (F : C ‚•§ Type v‚ÇÅ) [F.corepresentable] : C
{n : ‚Ñï} {Œ± : Type u} {Œ≤ : Type v} (a : array n Œ±) (f : Œ± ‚Üí Œ≤) : array n Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (R : category_theory.presieve X) [category_theory.limits.has_pullbacks C] : category_theory.equalizer.first_obj P R ‚ü∂ category_theory.equalizer.presieve.second_obj P R
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} (b : Œ≤) : Œ± ‚äï Œ≤ ‚äï Œ≥
(G : Type u) : Type u
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {J : Type v} (f : J ‚Üí C) [category_theory.limits.reflects_colimit (category_theory.discrete.functor f) G] {P : C} (g : Œ† (j : J), f j ‚ü∂ P) (t : category_theory.limits.is_colimit (category_theory.limits.cofan.mk (G.obj P) (Œª (j : J), G.map (g j)))) : category_theory.limits.is_colimit (category_theory.limits.cofan.mk P g)
(M : Type u_5) [monoid M] (R : Type u_11) [semiring R] [mul_semiring_action M R] (S : Type u_13) [semiring S] [mul_semiring_action M S] : Type (max u_11 u_13)
{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] : has_coe_t (ideal R) (fractional_ideal S P)
{C : Type u} [category_theory.category C] (F : C·µí·µñ ‚•§ Type v) : (category_theory.category_of_elements.from_costructured_arrow F).right_op ‚ãô category_theory.category_of_elements.to_costructured_arrow F = ùü≠ (category_theory.costructured_arrow category_theory.yoneda F)
 : Type
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x : V) : 2 ‚Ä¢ o.oangle x (-x) = 0
{M : Type u_1} [monoid_with_zero M] {f g : ‚Ñ§ ‚Üí*‚ÇÄ M} (h_neg_one : ‚áëf (-1) = ‚áëg (-1)) (h_nat : f.comp int.of_nat_hom.to_monoid_with_zero_hom = g.comp int.of_nat_hom.to_monoid_with_zero_hom) : f = g
{V : Type u_1} [inner_product_space ‚Ñù V] (x : V) : inner_product_geometry.angle 0 x = real.pi / 2
{n : ‚Ñï} {Œ± : Type u_1} [preorder Œ±] {f g : fin n ‚Üí Œ±} (hf : strict_mono f) (hg : strict_mono g) (h : set.range f = set.range g) : f = g
{R : Type u_1} [fintype R] [comm_ring R] [is_reduced R] [char_p R 2] (a : R) : is_square a
 : Pointed ‚•§ Bipointed
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.split_epi category_theory.limits.prod.fst
(Œ± : Type u) : Type u
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (s : alist Œ≤) : finmap Œ≤
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] (T : category_theory.triangulated.triangle C) : T ‚ü∂ (category_theory.triangulated.rotate C).obj ((category_theory.triangulated.inv_rotate C).obj T)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_3} (K : Œπ ‚Üí submodule ùïú E) : (‚®Ö (i : Œπ), (K i)·óÆ) = (supr K)·óÆ
{R : Type u} {K : Type v} {L : Type z} {p : R} [comm_ring R] [field K] [field L] [algebra K L] [algebra R L] [algebra R K] [is_scalar_tower R K L] [is_separable K L] [is_domain R] [normalized_gcd_monoid R] [is_fraction_ring R K] [is_integrally_closed R] {B : power_basis K L} (hp : prime p) (hBint : is_integral R B.gen) {n : ‚Ñï} {z : L} (hzint : is_integral R z) (hz : p ^ n ‚Ä¢ z ‚àà algebra.adjoin R {B.gen}) (hei : (minpoly R B.gen).is_eisenstein_at (submodule.span R {p})) : z ‚àà algebra.adjoin R {B.gen}
{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] {f : Œ≤ ‚Üí Œ±} : metric.bounded (set.range f) ‚Üî ‚àÉ (C : ‚Ñù), ‚àÄ (x y : Œ≤), has_dist.dist (f x) (f y) ‚â§ C
{C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) {Y : topological_space.opens ‚Ü•X} (hY : Y = supr U) : category_theory.limits.is_limit (category_theory.functor.map_cone F (Top.presheaf.sheaf_condition.opens_le_cover_cocone U).op) ‚âÉ category_theory.limits.is_limit (category_theory.functor.map_cone F (category_theory.sieve.generate (Top.presheaf.presieve_of_covering_aux U Y)).arrows.cocone.op)
{R : Type u} [comm_ring R] {n : Type v} [decidable_eq n] [fintype n] (M : matrix n n R) (k : ‚Ñï) : M ^ k = ‚áë(polynomial.aeval M) (polynomial.X ^ k %‚Çò M.charpoly)
{V : Type u} [quiver V] (a : V) : V ‚Üí Sort (max (u+1) v)
{Œ± : Type u_1} [linear_order Œ±] [decidable_eq Œ±] {p : finset Œ± ‚Üí Prop} (s : finset Œ±) (h0 : p ‚àÖ) (step : ‚àÄ (a : Œ±) (s : finset Œ±), (‚àÄ (x : Œ±), x ‚àà s ‚Üí a < x) ‚Üí p s ‚Üí p (has_insert.insert a s)) : p s
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] {X Y : C} (f g : X ‚ü∂ Y) : category_theory.limits.has_colimit (category_theory.limits.parallel_pair f g)
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [finite_dimensional k V] [fintype Œπ] {p : Œπ ‚Üí P} (hi : affine_independent k p) : affine_span k (set.range p) = ‚ä§ ‚Üî fintype.card Œπ = finite_dimensional.finrank k V + 1
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] (e : E ‚âÉL[ùïú] E') : diffeomorph (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') E E' ‚ä§
(c : tactic.instance_cache) : ‚Ñ§ ‚Üí tactic (tactic.instance_cache √ó expr)
{Œ± : Type u_1} [measurable_space Œ±] : has_sub (measure_theory.measure Œ±)
 : pSet
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {C : Type u‚ÇÉ} [category_theory.category C] (F : A ‚•§ B) (G : A ‚•§ C) : A ‚•§ B √ó C
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (p1 p2 : P) (hp1p2 : p1 ‚â† p2) : euclidean_geometry.angle p1 (midpoint ‚Ñù p1 p2) p2 = real.pi
(M : Type u_1) (Œ± : Type u_2) [monoid M] [mul_action M Œ±] {P Q : submonoid M} : mul_action.fixed_points ‚Ü•(P ‚äî Q) Œ± = mul_action.fixed_points ‚Ü•P Œ± ‚à© mul_action.fixed_points ‚Ü•Q Œ±
{M : Type u_1} [group_with_zero M] : set.center MÀ£ = coe ‚Åª¬π' set.center M
(C : Type u) [category_theory.category C] : category_theory.discrete pempty ‚•§ C
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : Y.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : (category_theory.limits.pullback f g).open_cover
(C : Type u) [category_theory.category C] (D : Type u') [category_theory.category D] : (C ‚•§ D) ‚•§ category_theory.simplicial_object.augmented C ‚•§ category_theory.simplicial_object.augmented D
(x : format) : list format ‚Üí format
{Œ± : Type u} {n : ‚Ñï} (f : fin n ‚Üí Œ±) (i : ‚Ñï) : (list.of_fn f).nth i = list.of_fn_nth_val f i
(R : Type u) {B : Type v} [comm_ring R] [decidable_eq B] [fintype B] (A : matrix B B ‚Ñ§) : B √ó B ‚Üí free_lie_algebra R (cartan_matrix.generators B)
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] {B : Œπ ‚Üí submodule R A} [nonempty Œπ] (hB : submodules_ring_basis B) : topological_space A
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.limits.has_terminal C] : category_theory.subterminals C ‚âå category_theory.mono_over (‚ä§_ C)
{K : Type u_1} [field K] (A : valuation_subring K) : valuation K A.value_group
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cocone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_colimit t) : category_theory.limits.binary_bicone X Y
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] {X' : C} (f : X' ‚ü∂ X) [category_theory.is_iso f] (g : X ‚ü∂ Y) [category_theory.limits.has_kernel g] : ‚Üë(category_theory.limits.kernel_subobject (f ‚â´ g)) ‚âÖ ‚Üë(category_theory.limits.kernel_subobject g)
{Œ± : Type u_2} [mul_one_class Œ±] : mul_one_class (filter Œ±)
(ùïú : Type u_1) {E : Type u_3} [ordered_semiring ùïú] [topological_space E] [add_comm_monoid E] [has_scalar ùïú E] (s : set E) : Prop
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] {J : Type v} (F : C ‚•§ D) [F.preserves_zero_morphisms] (f : J ‚Üí C) [category_theory.limits.has_biproduct f] [category_theory.limits.preserves_biproduct f F] : F.obj (‚®Å f) ‚âÖ ‚®Å F.obj ‚àò f
{R‚ÇÉ : Type u_7} [comm_ring R‚ÇÉ] {n : Type u_11} [fintype n] (J A : matrix n n R‚ÇÉ) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] : category_theory.limits.kernel f ‚ü∂ X
{Œ± : Type u_2} [decidable_eq Œ±] [monoid Œ±] : finset Œ± ‚Üío ‚Ñï
 : ordinal ‚Üí ordinal ‚Üí ordinal
 : ‚Ñ§ ‚âÉ ‚Ñï ‚äï ‚Ñï
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f : X ‚ü∂ Y) : category_theory.split_mono f
{Œπ : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] [paracompact_space X] (p : (X ‚Üí ‚Ñù) ‚Üí Prop) (h01 : ‚àÄ (s t : set X), is_closed s ‚Üí is_closed t ‚Üí disjoint s t ‚Üí (‚àÉ (f : C(X, ‚Ñù)), p ‚áëf ‚àß set.eq_on ‚áëf 0 s ‚àß set.eq_on ‚áëf 1 t ‚àß ‚àÄ (x : X), ‚áëf x ‚àà set.Icc 0 1)) (hs : is_closed s) (U : Œπ ‚Üí set X) (ho : ‚àÄ (i : Œπ), is_open (U i)) (hU : s ‚äÜ ‚ãÉ (i : Œπ), U i) : ‚àÉ (f : bump_covering Œπ X s), (‚àÄ (i : Œπ), p ‚áë(‚áëf i)) ‚àß f.is_subordinate U
 : bool ‚Üí string ‚Üí string
{P : Type u_1} [preorder P] : has_coe (order.pfilter P) (set P)
{M : Type u_1} [has_add M] : complete_lattice (add_con M)
(L : first_order.language) (M : Type u_3) [L.Structure M] : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí. Œ≤ ‚äï Œ±} (a a' : Œ±) (ha' : sum.inr a' ‚àà f a) : f.fix a = f.fix a'
{Œ± : Type u_1} [topological_space Œ±] [t2_space Œ±] {f : Œ± ‚Üí Œ±} (hf : continuous f) : is_closed (function.fixed_points f)
{Œ± : Type u} (n : pos_num) (t : tree Œ±) (v : Œ±) : Œ±
(c : ‚Ñù) (f : ‚Ñï ‚Üí bool) : ‚Ñù
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [category_theory.limits.has_pushout f g] : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk category_theory.limits.pushout.inl category_theory.limits.pushout.inr category_theory.limits.pushout.condition)
{s : set ‚Ñù} : is_preconnected s ‚Üí convex ‚Ñù s
{M : Type u_1} [add_zero_class M] : has_top (add_submonoid M)
{f‚ÇÅ f‚ÇÇ : circle_deg1_liftÀ£} (h : ‚Üëf‚ÇÅ.translation_number = ‚Üëf‚ÇÇ.translation_number) : ‚àÉ (F : circle_deg1_lift), function.semiconj ‚áëF ‚áëf‚ÇÅ ‚áëf‚ÇÇ
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (f : M ‚Üí+ P) {x y : M} : ‚áë(add_con.ker f) x y ‚Üî ‚áëf x = ‚áëf y
(Œ± : Type u_1) (Œ≤ : Type u_2) [add_zero_class Œ±] [add_comm_monoid Œ≤] : (Œ± ‚Üí+ Œ≤) ‚Üí+ Œ± ‚Üí Œ≤
(n : ‚Ñï) : bool
 : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) {X Y : C} (p : X = Y) : F.map (category_theory.eq_to_hom p) = category_theory.eq_to_hom _
{F : Type u‚ÇÄ ‚Üí Type u‚ÇÅ ‚Üí Type u‚ÇÇ} [bifunctor F] {Œ± : Type u‚ÇÄ} {Œ≤ Œ≤' : Type u‚ÇÅ} (f : Œ≤ ‚Üí Œ≤') : F Œ± Œ≤ ‚Üí F Œ± Œ≤'
{Œ± : Type u} [has_add Œ±] : Œ± ‚Üí add_magma.free_add_semigroup Œ±
{B : Type u} [quiver B] : prefunctor B (category_theory.free_bicategory B)
(id : module_info.module_id) : environment
{Œπ : Type u_1} {M : Type u_3} [decidable_eq Œπ] [semiring M] [Œ† (m : M), decidable (m ‚â† 0)] : add_monoid_algebra M Œπ ‚âÉ direct_sum Œπ (Œª (i : Œπ), M)
(R : Type u_1) (S : Type u_2) (M : Type u_3) [add_comm_monoid M] : restrict_scalars R S M ‚âÉ+ M
(X Y : Type u) : X ‚®Ø Y ‚âÖ X √ó Y
(Œ± : Type u_1) [encodable Œ±] [infinite Œ±] : denumerable Œ±
{X Y : Type u} [semigroup X] [semigroup Y] (f : X ‚Üí‚Çô* Y) : Semigroup.of X ‚ü∂ Semigroup.of Y
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {E : Type u‚ÇÉ} [‚Ñ∞ : category_theory.category E] (F : C ‚•§ D) (G : D ‚•§ E) [category_theory.limits.preserves_colimits_of_shape J (F ‚ãô G)] [category_theory.limits.reflects_colimits_of_shape J G] : category_theory.limits.preserves_colimits_of_shape J F
 : pgame ‚Üí Prop
(M : Type u_5) [monoid M] (A : Type u_6) [add_monoid A] [distrib_mul_action M A] (B : Type u_8) [add_monoid B] [distrib_mul_action M B] : Type (max u_6 u_8)
(c : tactic.abel.context) (eval : expr ‚Üí tactic (tactic.abel.normal_expr √ó expr)) (is_smulg : bool) (orig e‚ÇÅ e‚ÇÇ : expr) : tactic (tactic.abel.normal_expr √ó expr)
(Œ± : Type u_1) : Type u_1
{Œ± : Type u_3} [semilattice_sup Œ±] (a : Œ±) : filter.at_top = filter.comap coe filter.at_top
 : initial_seg has_lt.lt has_lt.lt
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (R‚ÇÇ : Type u_5) [comm_semiring R‚ÇÇ] [algebra R‚ÇÇ R] : bilin_form R M ‚âÉ‚Çó[R‚ÇÇ] bilin_form R M
 : znum ‚Üí option pos_num
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.limits.preserves_limits_of_shape J F] : category_theory.limits.preserves_limits_of_shape J G
(f : Set ‚Üí Set) [H : pSet.definable 1 f] : Set ‚Üí Set
(n : ‚Ñï) (i : fin (n + 1)) : sSet
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] : ‚Ü•‚ä§ ‚âÉ‚Çê[R] A
 : filter.tendsto (Œª (n : ‚Ñï), (finset.range n).sum (Œª (i : ‚Ñï), 1 / (‚Üëi + 1))) filter.at_top filter.at_top
(Œ≤ : Type u_1) (Œ± : Type u_2) : Type (max u_1 u_2)
{M : Type u_1} [cancel_comm_monoid_with_zero M] [decidable_eq M] [unique_factorization_monoid M] [unique MÀ£] (x : M) : unique_factorization_monoid.factors x = unique_factorization_monoid.normalized_factors x
{Œ± : Type u_1} {n : Type u_4} [has_zero Œ±] (A : matrix n n Œ±) : Prop
(R‚ÇÅ : Type u_1) [semiring R‚ÇÅ] (M‚ÇÅ : Type u_4) [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] (M‚ÇÇ : Type u_6) [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÅ M‚ÇÇ] : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ √ó M‚ÇÇ
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üío Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : Œ± ‚Üío Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {E : Type u‚ÇÉ} [‚Ñ∞ : category_theory.category E] (F : C ‚•§ D) (G : D ‚•§ E) [category_theory.limits.preserves_limits_of_shape J (F ‚ãô G)] [category_theory.limits.reflects_limits_of_shape J G] : category_theory.limits.preserves_limits_of_shape J F
 : tactic name
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_equalizers C] (f : X ‚ü∂ Y) [category_theory.limits.has_image f] {Y' : C} (h : Y ‚ü∂ Y') [category_theory.is_iso h] : ‚Üë(category_theory.limits.image_subobject (f ‚â´ h)) ‚âÖ ‚Üë(category_theory.limits.image_subobject f)
{Œ± : Sort u_1} {Œ≤ : Type u_2} {Œ≥ : Sort u_3} [decidable_eq Œ≤] (g : Œ≤ ‚Üí Œ≥) {f : Œ± ‚Üí Œ≤} {i : Œ≤} (a : Œ≥) (h : i ‚àâ set.range f) : function.update g i a ‚àò f = g ‚àò f
{R : Type u} [semiring R] (p : polynomial R) : with_bot ‚Ñï
{R : Type u_1} [ring R] (M : Module R) [category_theory.simple M] : is_simple_module R ‚Ü•M
{Œ± : Type u} {Œ≤ : Type v} : lazy_list Œ± ‚Üí lazy_list Œ≤ ‚Üí lazy_list (Œ± √ó Œ≤)
{ùïÇ : Type u_1} {ùî∏ : Type u_2} {ùîπ : Type u_3} [nondiscrete_normed_field ùïÇ] [normed_ring ùî∏] [normed_ring ùîπ] [normed_algebra ùïÇ ùî∏] [normed_algebra ùïÇ ùîπ] [complete_space ùî∏] {F : Type u_4} [ring_hom_class F ùî∏ ùîπ] (f : F) (hf : continuous ‚áëf) (x : ùî∏) (hx : x ‚àà emetric.ball 0 (exp_series ùïÇ ùî∏).radius) : ‚áëf (exp ùïÇ x) = exp ùïÇ (‚áëf x)
{b : ordinal} (b0 : b ‚â† 0) {C : ordinal ‚Üí Sort u_2} (H0 : C 0) (H : Œ† (o : ordinal), o ‚â† 0 ‚Üí C (o % b ^ ordinal.log b o) ‚Üí C o) (o : ordinal) : C o
{n : ‚Ñï} (x : bitvec n) (i : ‚Ñï) : bitvec n
(Œ± : Type u_1) [f : denumerable Œ±] (n : ‚Ñï) : Œ±
{s : set ‚Ñù} : convex ‚Ñù s ‚Üí is_preconnected s
{Œ± : Type u_3} {Œ≤ : Type u_4} [nonempty Œ±] [semilattice_sup Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} : filter.tendsto f filter.at_top filter.at_top ‚Üî ‚àÄ (b : Œ≤), ‚àÉ (i : Œ±), ‚àÄ (a : Œ±), i ‚â§ a ‚Üí b ‚â§ f a
{R : Type u} [non_assoc_semiring R] {S T : subsemiring R} (h : ‚àÄ (x : R), x ‚àà S ‚Üî x ‚àà T) : S = T
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (s : finmap Œ≤) : finset Œ±
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : submodule R A
(V : Type (u+1)) [category_theory.large_category V] (G : Mon) [category_theory.monoidal_category V] : category_theory.monoidal_functor (Action V G) (category_theory.single_obj ‚Ü•G ‚•§ V)
{s : set ‚Ñù} (h : metric.bounded s) : metric.diam s = has_Sup.Sup s - has_Inf.Inf s
(p : interactive.parse interactive.types.texpr) : tactic unit
{C : Type u} [category_theory.category C] (B : C) {J : Type v} (F : category_theory.discrete J ‚•§ category_theory.over B) (c : category_theory.limits.cone F) : category_theory.limits.cone (category_theory.over.construct_products.wide_pullback_diagram_of_diagram_over B F)
{B : Type u} [category_theory.bicategory B] {a b : B} (f g : a ‚ü∂ b) [category_theory.bicategory.lift_hom f] [category_theory.bicategory.lift_hom g] : Type w
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_cokernel f] {X' Y' : C} (f' : X' ‚ü∂ Y') [category_theory.limits.has_cokernel f'] (p : X ‚âÖ X') (q : Y ‚âÖ Y') (w : f ‚â´ q.hom = p.hom ‚â´ f') : category_theory.limits.cokernel f ‚âÖ category_theory.limits.cokernel f'
{V : Type u} (G : simple_graph V) [G.locally_finite] (d : ‚Ñï) : Prop
(C : Type u‚ÇÅ) [category_theory.category C] {F‚ÇÅ : category_theory.discrete pempty ‚•§ C} {F‚ÇÇ : category_theory.discrete pempty ‚•§ C} {c‚ÇÅ : category_theory.limits.cone F‚ÇÅ} (hl : category_theory.limits.is_limit c‚ÇÅ) (c‚ÇÇ : category_theory.limits.cone F‚ÇÇ) (hi : c‚ÇÅ.X ‚âÖ c‚ÇÇ.X) : category_theory.limits.is_limit c‚ÇÇ
{F : Type} [comm_semiring F] {q : ‚Ñï} {f : polynomial F} (hf : polynomial.has_separable_contraction q f) : polynomial F
 : list expr ‚Üí tactic ‚Ñï
{d : ‚Ñ§} : ‚Ñ§‚àöd ‚Üí* ‚Ñ§
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) (s : alist Œ≤) : option (Œ≤ a)
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] {j‚ÇÅ j‚ÇÇ j‚ÇÉ k‚ÇÅ k‚ÇÇ l : C} (f‚ÇÅ : j‚ÇÅ ‚ü∂ k‚ÇÅ) (f‚ÇÇ : j‚ÇÇ ‚ü∂ k‚ÇÅ) (f‚ÇÉ : j‚ÇÇ ‚ü∂ k‚ÇÇ) (f‚ÇÑ : j‚ÇÉ ‚ü∂ k‚ÇÇ) (g‚ÇÅ : j‚ÇÅ ‚ü∂ l) (g‚ÇÇ : j‚ÇÉ ‚ü∂ l) : ‚àÉ (s : C) (Œ± : k‚ÇÅ ‚ü∂ s) (Œ≤ : l ‚ü∂ s) (Œ≥ : k‚ÇÇ ‚ü∂ s), f‚ÇÅ ‚â´ Œ± = g‚ÇÅ ‚â´ Œ≤ ‚àß f‚ÇÇ ‚â´ Œ± = f‚ÇÉ ‚â´ Œ≥ ‚àß f‚ÇÑ ‚â´ Œ≥ = g‚ÇÇ ‚â´ Œ≤
{Œ± : Type u_1} (a : Œ±) (s : cycle Œ±) : Prop
{Œπ : Type u} (F : category_theory.discrete Œπ ‚•§ algebraic_geometry.LocallyRingedSpace) : category_theory.limits.is_colimit (algebraic_geometry.LocallyRingedSpace.coproduct_cofan F)
(Œ± : Type u) : Type u
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {f‚ÇÄ f‚ÇÅ : C(X, Y)} {S : set X} (F : f‚ÇÄ.homotopy_rel f‚ÇÅ S) : f‚ÇÅ.homotopy_rel f‚ÇÄ S
{ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_5} [normed_field ùïú] [add_comm_group E] [module ùïú E] [nonempty Œπ] (p : seminorm_family ùïú E Œπ) [t : topological_space E] : Prop
{Œ≤ : Type u} {Œ± : Type v} [comm_monoid Œ≤] [decidable_eq Œ±] (s : finset Œ±) (f : Œ± ‚Üí Œ≤) {a : Œ±} (h : a ‚àà s) : f a * (s.erase a).prod (Œª (x : Œ±), f x) = s.prod (Œª (x : Œ±), f x)
 : ‚Ñï ‚Üí expr ‚Üí expr ‚Üí expr
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) : F.to_lax_monoidal_functor.to_functor.prod F.to_lax_monoidal_functor.to_functor ‚ãô category_theory.monoidal_category.tensor D ‚âÖ category_theory.monoidal_category.tensor C ‚ãô F.to_lax_monoidal_functor.to_functor
{Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) : is_topological_fiber_bundle F Z.proj
{Œ± : Type u_1} [has_le Œ±] {a b : Œ±} : b ‚â§ a ‚Üí ‚áëorder_dual.to_dual a ‚â§ ‚áëorder_dual.to_dual b
 : eformat ‚Üí widget_override.interactive_expression.sf
 : ‚Ñù ‚Üí‚Çó·µ¢[‚Ñù] ‚ÑÇ
(M : Type u_1) [add_zero_class M] : M ‚Üí+ M
{Œ± : Type u} [pseudo_metric_space Œ±] (x y : uniform_space.completion Œ±) (h : has_dist.dist x y = 0) : x = y
{Œ≤ : Type v} {Œ¥ : Type u_2} [topological_space Œ≤] [topological_space Œ¥] {Œ± : Type u_1} {Œ≥ : Type u_3} (f : Œ± ‚Üí Œ≤) (g : Œ≥ ‚Üí Œ¥) : prod.topological_space = topological_space.induced (Œª (p : Œ± √ó Œ≥), (f p.fst, g p.snd)) prod.topological_space
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] (K : category_theory.grothendieck_topology D) (G : C ‚•§ D) : Prop
(R : Type u_1) [comm_ring R] : ‚Ñï ‚Üí polynomial R
(x : pgame) : (0 * x).equiv 0
{Œ± : Type u_1} [distrib_lattice Œ±] [order_bot Œ±] [decidable_eq Œ±] {a : Œ±} (P : finpartition a) (Q : Œ† (i : Œ±), i ‚àà P.parts ‚Üí finpartition i) : finpartition a
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type u} [Œ† (a : Œ±), fintype (Œ≤ a)] : cardinal.mk (W_type Œ≤) ‚â§ linear_order.max (cardinal.mk Œ±) cardinal.aleph_0
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Ü™ Œ≤) (a : Œ±) (b : Œ≤) [Œ† (a' : Œ±), decidable (a' = a)] [Œ† (a' : Œ±), decidable (‚áëf a' = b)] : Œ± ‚Ü™ Œ≤
{R : Type u_1} [semiring R] (f : nat.arithmetic_function R) (k : ‚Ñï) : nat.arithmetic_function R
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] {x : E} {s : set E} (hs : s ‚àà nhds x) : ‚àÉ (f : E ‚Üí ‚Ñù), f =·∂†[nhds x] 1 ‚àß (‚àÄ (y : E), f y ‚àà set.Icc 0 1) ‚àß cont_diff ‚Ñù ‚ä§ f ‚àß has_compact_support f ‚àß tsupport f ‚äÜ s
{X : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) : algebraic_geometry.Scheme.glue_data
{M : Type uM} {N : Type uN} {P : Type uP} {mM : add_zero_class M} {mN : add_zero_class N} {mP : add_comm_monoid P} (f : M ‚Üí+ N ‚Üí+ P) : N ‚Üí+ M ‚Üí+ P
(C : Type u‚ÇÅ) [category_theory.category C] : Type u‚ÇÅ
(R : Type u_1) [semiring R] : subsemiring R
{F : Type u ‚Üí Type u} [functor F] [q : qpf F] : qpf.fix F ‚Üí F (qpf.fix F)
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {v : M} (h : v ‚â† 0) {r : R} (hr : 0 < r) (hrv : r ‚Ä¢ v ‚â† 0) : ray_of_ne_zero R (r ‚Ä¢ v) hrv = ray_of_ne_zero R v h
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± : D·µí·µñ ‚•§ Type v} {‚Ñ±' : category_theory.SheafOfTypes K} (Œ± : G.op ‚ãô ‚Ñ± ‚ü∂ G.op ‚ãô ‚Ñ±'.val) {X : D} (x : ‚Ñ±.obj (opposite.op X)) : (category_theory.cover_dense.types.pushforward_family H Œ± x).compatible
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [no_max_order Œ±] {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (set.Ioi a) ‚Üî ‚àÉ (u : Œ±) (H : u ‚àà set.Ioi a), set.Ioo a u ‚äÜ s
{Œπ : Type u_1} {R : Type u_8} [canonically_ordered_comm_semiring R] [nontrivial R] [decidable_eq R] {s : finset Œπ} {f : Œπ ‚Üí with_top R} (h : ‚àÄ (i : Œπ), i ‚àà s ‚Üí f i ‚â† ‚ä§) : s.prod (Œª (i : Œπ), f i) < ‚ä§
(X : algebraic_geometry.LocallyRingedSpace) : X.to_Top ‚ü∂ algebraic_geometry.Spec.Top_obj (algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X))
{X : Type u_1} [topological_space X] (S : discrete_quotient X) {Y : Type u_2} [topological_space Y] {f : Y ‚Üí X} (cont : continuous f) : discrete_quotient Y
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_4} [decidable_eq Œπ] [fintype Œπ] (e : basis Œπ R M) (w : Œπ ‚Üí RÀ£) : ‚áë(e.det) ‚áë(e.units_smul w) = finset.univ.prod (Œª (i : Œπ), ‚Üë(w i))
(H : Type u) (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] [locally_compact_space H] : locally_compact_space M
{C : Type u} [category_theory.category C] [‚àÄ (n : ‚Ñï) (f : category_theory.arrow C), category_theory.limits.has_wide_pullback f.right (Œª (i : ulift (fin (n + 1))), f.left) (Œª (i : ulift (fin (n + 1))), f.hom)] (X : category_theory.simplicial_object.augmented C) (F : category_theory.arrow C) (G : category_theory.simplicial_object.augmented.to_arrow.obj X ‚ü∂ F) : X ‚ü∂ F.augmented_cech_nerve
{Œ± : Type u_1} [topological_space Œ±] {Œ≤ : Type u_2} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) : Prop
{k : Type u_1} {P‚ÇÅ : Type u_2} {P‚ÇÇ : Type u_3} {V‚ÇÅ : Type u_6} {V‚ÇÇ : Type u_7} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] (e : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÇ ‚âÉ·µÉ[k] P‚ÇÅ
{p : ‚Ñï} [hp : fact (nat.prime p)] : witt_vector.is_poly p (Œª (_x : Type u_1) (_x_1 : comm_ring _x) (_x_2 : witt_vector p _x), 0)
{a b : Prop} : ¬¨(a ‚à® b) ‚Üî ¬¨a ‚àß ¬¨b
 : Type
{g : matrix.special_linear_group (fin 2) ‚Ñ§} {z : upper_half_plane} (hz : z ‚àà modular_group.fdo) (hg : g ‚Ä¢ z ‚àà modular_group.fdo) : z = g ‚Ä¢ z
{Œ≤ : Type u} {Œ± : Type v} [comm_monoid Œ≤] [decidable_eq Œ±] (s : finset Œ±) (a : Œ±) (b : Œ± ‚Üí Œ≤) : s.prod (Œª (x : Œ±), ite (x = a) (b x) 1) = ite (a ‚àà s) (b a) 1
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X : C) : C ‚•§ C
{m : Type ‚Üí Type v} [monad m] : list (m bool) ‚Üí m bool
(R : Type u_1) [add_monoid R] [has_one R] : Prop
{G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {Œì : subgroup G} [measurable_space (G ‚ß∏ Œì)] [borel_space (G ‚ß∏ Œì)] : has_measurable_smul G (G ‚ß∏ Œì)
{R : Type u_1} [comm_semiring R] {A : Type u} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] [t2_space A] (s : subalgebra R A) (hs : ‚àÄ (x y : ‚Ü•s), x * y = y * x) : comm_semiring ‚Ü•(s.topological_closure)
(n : ‚Ñï) : ‚Ñï ‚Üí ‚Ñï
{R : Type u} [comm_ring R] : category_theory.limits.preserves_limits_of_size (category_theory.forget (Algebra R))
{F : pfunctor} (x : F.obj F.M) : F.M
{G : Type u_1} [add_group G] : add_action.is_pretransitive G·µÉ·µí·µñ G
{R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] [no_zero_divisors A] (h : function.injective ‚áë(algebra_map R A)) : no_zero_smul_divisors R A
{Œπ : Type v} (f : Œπ ‚Üí cardinal) : (cardinal.sup f).lift = cardinal.sup (Œª (i : Œπ), (f i).lift)
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [‚àÄ (i : ùí∞.J), category_theory.limits.has_pullback (ùí∞.map i ‚â´ f) g] (i : ùí∞.J) : category_theory.limits.pullback.lift category_theory.limits.pullback.snd (category_theory.limits.pullback.fst ‚â´ algebraic_geometry.Scheme.pullback.p2 ùí∞ f g) _ ‚â´ (algebraic_geometry.Scheme.pullback.gluing ùí∞ f g).Œπ i = category_theory.limits.pullback.fst
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.preadditive C] {D : Type u‚ÇÅ} [category_theory.category D] [category_theory.preadditive D] [category_theory.limits.has_finite_biproducts D] {F G : category_theory.Mat_ C ‚•§ D} [F.additive] [G.additive] (Œ± : category_theory.Mat_.embedding C ‚ãô F ‚âÖ category_theory.Mat_.embedding C ‚ãô G) : F ‚âÖ G
{Œ± : Type u_1} [topological_space Œ±] {Œ≤ : Type u_2} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) : Prop
{Œ± : Type u_1} (L : list (list Œ±)) {i j : ‚Ñï} (hi : i < L.length) (hj : j < (L.nth_le i hi).length) : L.join.nth_le ((list.take i (list.map list.length L)).sum + j) _ = (L.nth_le i hi).nth_le j hj
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] : Type (max u v)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.split_epi f] : category_theory.epi f
{Œ± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : Œ± ‚Üí F} {f' : Œ± ‚Üí E'} {l : filter Œ±} : (Œª (x : Œ±), -f' x) =O[l] g ‚Üí f' =O[l] g
(Œ≥ : Type u) : Type u
(R : Type u_1) (S : Type u_6) (M : Type u_9) [semiring R] [semiring S] [add_comm_monoid M] [module R M] [module S M] [smul_comm_class R S M] : (R ‚Üí‚Çó[R] M) ‚âÉ‚Çó[S] M
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {L‚ÇÅ L‚ÇÇ : C ‚•§ D} {R‚ÇÅ R‚ÇÇ : D ‚•§ C} (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) (f : R‚ÇÅ ‚ü∂ R‚ÇÇ) [category_theory.is_iso (‚áë((category_theory.transfer_nat_trans_self adj‚ÇÅ adj‚ÇÇ).symm) f)] : category_theory.is_iso f
{x y : game} : ¬¨x.lf y ‚Üî y ‚â§ x
{M : Type u_1} [add_comm_monoid M] (x : M) : add_localization.away x
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u_1} [decidable_eq Œ±] {ùíú : finset (finset Œ±)} {r : ‚Ñï} (hùíú : set.sized r ‚Üëùíú) : set.sized (r - 1) ‚Üë(ùíú.shadow)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] {K' : submodule ùïú E} [complete_space ‚Ü•K'] (h : K = K') (u : E) : ‚Üë(‚áë(orthogonal_projection K) u) = ‚Üë(‚áë(orthogonal_projection K') u)
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.limits.mono_factorisation f
{M : Type u_1} [add_monoid M] {s : set M} (hs : is_add_submonoid s) {l : list M} : (‚àÄ (x : M), x ‚àà l ‚Üí x ‚àà s) ‚Üí l.sum ‚àà s
{p : ‚Ñï} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] : witt_vector p R ‚Üí+ witt_vector p R
{H : Type u} [topological_space H] : structure_groupoid H
{R : Type u_1} {S : Type u_2} [euclidean_domain R] [ordered_semiring S] (abv : absolute_value R S) : Prop
{Œ± : Type u_1} [group Œ±] (H : subgroup Œ±) {K L : subgroup Œ±} (h : K ‚â§ L) : ‚Ü•K ‚ß∏ H.subgroup_of K ‚Ü™ ‚Ü•L ‚ß∏ H.subgroup_of L
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (ps : set P) : affine_span k (has_insert.insert p ‚Üë(affine_span k ps)) = affine_span k (has_insert.insert p ps)
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] (e : Œ± ‚âÉ·µ§ Œ≤) : Œ± ‚âÉ‚Çú Œ≤
{Œ± : Type u_1} (Œ≤ : Œ± ‚Üí Type u_2) : (Œ† (a : Œ±), equiv.perm (Œ≤ a)) ‚Üí* equiv.perm (Œ£ (a : Œ±), Œ≤ a)
{C : Type u‚ÇÅ} [category_theory.category C] {B A : C} (X : category_theory.subobject B) (f : A ‚ü∂ B) [category_theory.mono f] (h : X ‚â§ category_theory.subobject.mk f) : ‚ÜëX ‚ü∂ A
 : BoundedDistribLattice ‚âå BoundedDistribLattice
{Œ± : Type u_1} {Œ≤ : Type u_2} [nonempty Œ±] (f : Œ± ‚Üí Œ≤) (s : set Œ±) (t : set Œ≤) (hf : set.bij_on f s t) : local_equiv Œ± Œ≤
{R : Type u_1} (K : Type u_2) [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_dedekind_domain R] : ‚Ü•(non_zero_divisors (ideal R)) ‚Üí* (fractional_ideal (non_zero_divisors R) K)À£
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_ring k] [group G] [add_comm_group V] [module k V] (œÅ : representation k G V) (g h : G) : œÅ.character (h * g * h‚Åª¬π) = œÅ.character g
{Œ± : Type u_1} [decidable_eq Œ±] : list Œ± ‚Üí list Œ± ‚Üí option (list Œ±)
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.sheaf C X) {U : topological_space.opens ‚Ü•X} (h : U = ‚àÖ) : category_theory.limits.is_terminal (F.val.obj (opposite.op U))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} (h : s.finite) : finite_dimensional k ‚Ü•(vector_span k s)
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [add_comm_monoid N] (f : Œ± ‚Üí‚ÇÄ M) (g : Œ± ‚Üí M ‚Üí N) : N
{Œ± : Type u_1} [group Œ±] {s t : subgroup Œ±} (h_le : s ‚â§ t) : Œ± ‚ß∏ s ‚âÉ (Œ± ‚ß∏ t) √ó ‚Ü•t ‚ß∏ s.subgroup_of t
{Œ± : Type u} {Œ≤ : Type v} (e : equiv.perm Œ±) (Œπ : Œ± ‚Ü™ Œ≤) : equiv.perm Œ≤
(R : Type u_1) (A : Type u_2) : Type (max u_1 u_2)
(Œ± : Type u_1) : Type u_1
{B : Type u‚ÇÅ} [quiver B] {C : Type u‚ÇÇ} [category_theory.category_struct C] (F : prefunctor B C) {a b : B} : category_theory.free_bicategory.hom a b ‚Üí (F.obj a ‚ü∂ F.obj b)
{R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [ring R] [add_comm_group M] [add_comm_group M‚ÇÇ] [module R M] [module R M‚ÇÇ] (f : M ‚Üí‚Çó[R] M‚ÇÇ) : (M ‚ß∏ f.ker) ‚âÉ‚Çó[R] ‚Ü•(f.range)
{R‚ÇÇ : Type u_5} {M‚ÇÇ : Type u_6} [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] (B‚ÇÇ F‚ÇÇ : bilin_form R‚ÇÇ M‚ÇÇ) : submodule R‚ÇÇ (module.End R‚ÇÇ M‚ÇÇ)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [non_unital_non_assoc_semiring Œ±] [non_unital_non_assoc_semiring Œ≤] [topological_semiring Œ±] [topological_semiring Œ≤] : topological_semiring (Œ± √ó Œ≤)
{Œ± : Type u_1} [measurable_space Œ±] (m‚ÇÅ m‚ÇÇ : measure_theory.outer_measure Œ±) : (m‚ÇÅ + m‚ÇÇ).trim = m‚ÇÅ.trim + m‚ÇÇ.trim
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ‚ü∂ Y} [category_theory.epi f] (h : f = 0) : Y ‚âÖ 0
{Œ± : Type u_1} {Œ≤ : Type u_2} {s : finset Œ±} {t : finset Œ≤} (hc : t.card < s.card) {f : Œ± ‚Üí Œ≤} (hf : ‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚àà t) : ‚àÉ (x : Œ±) (H : x ‚àà s) (y : Œ±) (H : y ‚àà s), x ‚â† y ‚àß f x = f y
(t s : omega.nat.preterm) (p : omega.nat.preform) : omega.nat.preform
(R : Type u) (A : Type v) (B : Type w) [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B] : A ‚Üí‚Çô‚Çê[R] A √ó B
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_artinian R M] (f : M ‚Üí‚Çó[R] M) (s : function.injective ‚áëf) : function.surjective ‚áëf
 : ‚Ñö ‚Üí+* ‚Ñù
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {X : category_theory.simplicial_object C} (q : ‚Ñï) : (algebraic_topology.dold_kan.HœÉ q).f 0 = 0
(X : algebraic_geometry.LocallyRingedSpace) (h : ‚àÄ (x : ‚Ü•X), ‚àÉ (R : CommRing) (f : algebraic_geometry.Spec.to_LocallyRingedSpace.obj (opposite.op R) ‚ü∂ X), x ‚àà set.range ‚áë(f.val.base) ‚àß algebraic_geometry.LocallyRingedSpace.is_open_immersion f) : algebraic_geometry.Scheme
{Œ± : Type u_1} {Œ≤ : Type u_2} {s s‚ÇÅ : set Œ±} {t t‚ÇÅ : set Œ≤} : s √óÀ¢ t ‚äÜ s‚ÇÅ √óÀ¢ t‚ÇÅ ‚Üî s ‚äÜ s‚ÇÅ ‚àß t ‚äÜ t‚ÇÅ ‚à® s = ‚àÖ ‚à® t = ‚àÖ
{Œ± : Type u} [ordered_comm_semiring Œ±] {Œ≤ : Type u_1} [has_zero Œ≤] [has_one Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_scalar ‚Ñï Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : ordered_comm_semiring Œ≤
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] (X : Top) : Type (max u v)
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [linear_order Œπ] [Œ† (i : Œπ), linear_order (Œ± i)] : linear_order (Œ£‚Çó' (i : Œπ), Œ± i)
(Œ± : Type u_4) : Type u_4
{R : Type u_1} {S : Type u_2} [comm_semiring R] [comm_semiring S] [H : local_ring S] (f : R ‚Üí+* S) [is_local_ring_hom f] : local_ring R
{f : ‚Ñï ‚Üí‚ÇÄ ‚Ñï} (hf : 0 ‚àâ f.support) : 0 < f.prod has_pow.pow
{R : Type u_1} {R‚ÇÇ : Type u_2} {R‚ÇÉ : Type u_3} {E : Type u_5} {E‚ÇÇ : Type u_6} {E‚ÇÉ : Type u_7} [semiring R] [semiring R‚ÇÇ] [semiring R‚ÇÉ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÅ‚ÇÉ : R ‚Üí+* R‚ÇÉ} {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] [semi_normed_group E] [semi_normed_group E‚ÇÇ] [semi_normed_group E‚ÇÉ] [module R E] [module R‚ÇÇ E‚ÇÇ] [module R‚ÇÉ E‚ÇÉ] (g : E‚ÇÇ ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÇ‚ÇÉ] E‚ÇÉ) (f : E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) : E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÉ] E‚ÇÉ
 : Type
{R : Type u_1} [ordered_comm_semiring R] (s : subsemiring R) : ordered_comm_semiring ‚Ü•s
(l r : expr) : tactic (bool √ó expr)
 : tactic unit
(m : Type u_1) (n : Type u_2) (R : Type u_3) [comm_semiring R] : matrix m n (mv_polynomial (m √ó n) R)
{J : Type v} [category_theory.small_category J] {F : J ‚•§ category_theory.discrete punit} : category_theory.limits.cocone F
(R : Type u_1) (A : Type u_2) (B : Type u_3) [comm_ring R] [comm_ring A] [comm_ring B] [algebra R B] [algebra A B] [is_integral_closure A R B] (A' : Type u_4) [comm_ring A'] [algebra A' B] [is_integral_closure A' R B] [algebra R A] [algebra R A'] [is_scalar_tower R A B] [is_scalar_tower R A' B] : A ‚âÉ‚Çê[R] A'
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [add_comm_monoid Œ≤] {s : finset Œ≥} {t : finset Œ±} {f : Œ≥ ‚Üí Œ± ‚Üí Œ≤} : (s.product t).sum (Œª (x : Œ≥ √ó Œ±), f x.fst x.snd) = t.sum (Œª (y : Œ±), s.sum (Œª (x : Œ≥), f x y))
{Œ± : Sort u_1} (a : Œ±) : erased Œ±
{z : upper_half_plane} (h : 1 < ‚áëcomplex.norm_sq ‚Üëz) : ‚áëcomplex.norm_sq ‚Üë(modular_group.S ‚Ä¢ z) < 1
{A : Type u_1} [normed_ring A] [normed_algebra ‚ÑÇ A] [complete_space A] [star_ring A] [cstar_ring A] [star_module ‚ÑÇ A] [nontrivial A] {a : A} (ha : a ‚àà self_adjoint A) {z : ‚ÑÇ} (hz : z ‚àà spectrum ‚ÑÇ a) : z = ‚Üë(z.re)
{R : Type u_1} {M : Type u_9} {Œπ : Type u_17} [semiring R] [add_comm_monoid M] [module R M] [fintype Œπ] [decidable_eq Œπ] (f : (Œπ ‚Üí R) ‚Üí‚Çó[R] M) (x : Œπ ‚Üí R) : ‚áëf x = finset.univ.sum (Œª (i : Œπ), x i ‚Ä¢ ‚áëf (Œª (j : Œπ), ite (i = j) 1 0))
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} [topological_space Œ±] (L : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (u : set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí (‚àÉ (t : set Œ±) (H : t ‚àà nhds_within x s) (F : Œ± ‚Üí Œ≤), continuous_within_at F s x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u)) : continuous_on f s
{C : Type u} [category_theory.category C] : has_Inf (category_theory.grothendieck_topology C)
{Œ± : Type u_1} [topological_space Œ±] [baire_space Œ±] {S : set (set Œ±)} (ho : ‚àÄ (s : set Œ±), s ‚àà S ‚Üí is_GŒ¥ s) (hS : S.countable) (hd : ‚àÄ (s : set Œ±), s ‚àà S ‚Üí dense s) : dense (‚ãÇ‚ÇÄ S)
(p : ‚Ñï) [fact (nat.prime p)] : Type
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí. Œ≤) (s : ‚Ü•(f.dom)) : Œ≤
{M : Type u_3} {G : Type u_6} [mM : mul_one_class M] [group G] (f : M ‚Üí G) (map_mul : ‚àÄ (a b : M), f (a * b) = f a * f b) : M ‚Üí* G
{R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] [nontrivial R] [normalization_monoid R] [decidable_eq R] {p x : R} (hp : irreducible p) (hnorm : ‚áënormalize p = p) {n : ‚Ñï} (hle : p ^ n ‚à£ x) (hlt : ¬¨p ^ (n + 1) ‚à£ x) : multiset.count p (unique_factorization_monoid.normalized_factors x) = n
(C : Type u) [category_theory.category C] : sSet
{Œπ : Type u_1} {ùïú : Type u_2} [is_R_or_C ùïú] {E : Type u_3} [inner_product_space ùïú E] [cplt : complete_space E] {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (hsp : (submodule.span ùïú (set.range v))·óÆ = ‚ä•) : hilbert_basis Œπ ùïú E
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_image f] : category_theory.limits.image f ‚ü∂ Y
{Œ± : Type u_1} [partial_order Œ±] {f : Œ± ‚Üí Œ±} {p : Œ± ‚Üí Prop} {hf : ‚àÄ (x : Œ±), x ‚â§ f x} {hfp : ‚àÄ (x : Œ±), p (f x)} {hmin : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, x ‚â§ y ‚Üí p y ‚Üí f x ‚â§ y} (x : Œ±) : p (‚áë(closure_operator.mk‚ÇÉ f p hf hfp hmin) x)
{Œ± : Type u_1} [topological_space Œ±] [inhabited Œ±] : inhabited (topological_space.nonempty_compacts Œ±)
{m : Type u_1} {n : Type u_2} [decidable_eq n] [fintype n] [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (e : n ‚âÉ m) (A : matrix m m R) : (A.minor ‚áëe ‚áëe).det = A.det
{X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {Œ≤ : Type u_1} {Œπ : Œ≤ ‚Üí Type u_3} [hŒπ : Œ† (n : Œ≤), fintype (Œπ n)] (s : set X) {l : filter Œ≤} (r : Œ≤ ‚Üí ennreal) (hr : filter.tendsto r l (nhds 0)) (t : Œ† (n : Œ≤), Œπ n ‚Üí set X) (ht : ‚àÄ·∂† (n : Œ≤) in l, ‚àÄ (i : Œπ n), emetric.diam (t n i) ‚â§ r n) (hst : ‚àÄ·∂† (n : Œ≤) in l, s ‚äÜ ‚ãÉ (i : Œπ n), t n i) (m : ennreal ‚Üí ennreal) : ‚áë(measure_theory.measure.mk_metric m) s ‚â§ l.liminf (Œª (n : Œ≤), finset.univ.sum (Œª (i : Œπ n), m (emetric.diam (t n i))))
{X Y : Type u} (i : X ‚âÖ Y) : X ‚âÉ Y
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (Œ± : F.op ‚ü∂ G.op) : G ‚ü∂ F
{K : Type u} {L : Type v} [field K] [field L] (f : K ‚Üí+* L) (s : subfield L) : subfield K
{Œ± : Type u} [ordered_comm_ring Œ±] {Œ≤ : Type u_1} [has_zero Œ≤] [has_one Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ≤), f (-x) = -f x) (sub : ‚àÄ (x y : Œ≤), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (zsmul : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : ordered_comm_ring Œ≤
 : Type
(H : Type u_1) [topological_space H] : charted_space H H
{C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : ‚Ñï} {i : fin (n + 2)} {j : fin (n + 1)} (H : ‚áëfin.cast_succ j < i) : X.œÉ (‚áëfin.cast_succ j) ‚â´ X.Œ¥ i.succ = X.Œ¥ i ‚â´ X.œÉ j
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {R : Type u_1} [semiring k] [add_monoid G] [semiring R] {f g : add_monoid_algebra k G ‚Üí+* R} (h‚ÇÅ : f.comp add_monoid_algebra.single_zero_ring_hom = g.comp add_monoid_algebra.single_zero_ring_hom) (h_of : ‚Üëf.comp (add_monoid_algebra.of k G) = ‚Üëg.comp (add_monoid_algebra.of k G)) : f = g
{C : Type u‚ÇÅ} [category_theory.category C] {G : Type u‚ÇÇ} [category_theory.groupoid G] : (G ‚•§ category_theory.core C) ‚•§ G ‚•§ C
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {f : X ‚ü∂ Y} [category_theory.split_mono f] {c : category_theory.limits.cokernel_cofork f} (i : category_theory.limits.is_colimit c) : category_theory.limits.binary_bicone X c.X
{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_left_regular a) : a ‚â† 0
{Œ± : Type u_1} [linear_order Œ±] (succ : Œ± ‚Üí Œ±) (hn : ‚àÄ {a : Œ±}, ¬¨is_max a ‚Üí ‚àÄ (b : Œ±), a < b ‚Üî succ a ‚â§ b) (hm : ‚àÄ (a : Œ±), is_max a ‚Üí succ a = a) : succ_order Œ±
 : tactic.ring_exp.ex tactic.ring_exp.ex_type.prod ‚Üí tactic.ring_exp.ex tactic.ring_exp.ex_type.prod ‚Üí tactic.ring_exp.ring_exp_m tactic.ring_exp.overlap
(s : linarith.sum) (m : native.rb_map linarith.monom ‚Ñï) : native.rb_map linarith.monom ‚Ñï √ó native.rb_map ‚Ñï ‚Ñ§
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s t : set Œ±} (hs : bdd_below s) (sne : s.nonempty) (ht : bdd_below t) (tne : t.nonempty) : has_Inf.Inf (s ‚à™ t) = has_Inf.Inf s ‚äì has_Inf.Inf t
{Œ± : Type u_1} [measurable_space Œ±] [topological_space Œ±] [opens_measurable_space Œ±] : topological_space (measure_theory.finite_measure Œ±)
{C : Type u_1} [category_theory.category C] (r : hom_rel C) : Type u_1
(Œ± : Type u_2) : Type u_2
{Œπ : Type v} (Œ± : Œπ ‚Üí Top) : category_theory.limits.fan Œ±
{Œπ : Type u_1} {R : Type u_2} {N : Type u_5} [dec_Œπ : decidable_eq Œπ] [semiring R] [add_comm_monoid N] [module R N] (p : Œπ ‚Üí Prop) [decidable_pred p] (S : Œπ ‚Üí submodule R N) : (‚®Ü (i : Œπ) (h : p i), S i) = ((‚áë(dfinsupp.lsum ‚Ñï) (Œª (i : Œπ), (S i).subtype)).comp (dfinsupp.filter_linear_map R (Œª (i : Œπ), ‚Ü•(S i)) p)).range
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {a‚ÇÅ a‚ÇÇ : Œ±} {b‚ÇÅ b‚ÇÇ : Œ≤} (q‚ÇÅ : path.homotopic.quotient a‚ÇÅ a‚ÇÇ) (q‚ÇÇ : path.homotopic.quotient b‚ÇÅ b‚ÇÇ) : path.homotopic.proj_left (path.homotopic.prod q‚ÇÅ q‚ÇÇ) = q‚ÇÅ
(G : Type u_1) [comm_group G] : subgroup G
{Œπ : Type u_1} {N : Type u_5} [dec_Œπ : decidable_eq Œπ] [add_comm_group N] (p : Œπ ‚Üí add_subgroup N) : complete_lattice.independent p ‚Üî function.injective ‚áë(dfinsupp.sum_add_hom (Œª (i : Œπ), (p i).subtype))
{G : Type u_1} [group G] {S : Type u_4} (H : S) [set_like S G] [hSG : subgroup_class S G] : group ‚Ü•H
{S : Type u_4} (H : S) {G : Type u_1} [add_comm_group G] [set_like S G] [add_subgroup_class S G] : add_comm_group ‚Ü•H
{G : Type u_7} [comm_group G] (L : list G) : (L.prod)‚Åª¬π = (list.map (Œª (x : G), x‚Åª¬π) L).prod
{C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ‚Ñï} (i : fin (n + 2)) : X.obj (simplex_category.mk n) ‚ü∂ X.obj (simplex_category.mk (n + 1))
(Œ± : Type u_1) : subsingleton Œ± ‚à® nontrivial Œ±
 : environment ‚Üí name ‚Üí bool
(R : Type u) [comm_semiring R] : CommSemiRing
(q : interactive.parse interactive.types.texpr) : tactic unit
{L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] (hnp : L.hom N P) (hmn : L.hom M N) : L.hom M P
(Œ± : Type u_2) [preorder Œ±] [add_zero_class Œ±] : Œ± ‚Üí+o Œ±
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s1 s2 : affine_subspace k P} {p1 p2 : P} (hp1 : p1 ‚àà s1) (hp2 : p2 ‚àà s2) : (s1 ‚äî s2).direction = s1.direction ‚äî s2.direction ‚äî submodule.span k {p2 -·µ• p1}
(V : Type u) : Type u
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {X : C} (h : category_theory.yoneda.obj X ‚ãô category_theory.ulift_functor ‚âÖ F.cones) (s : category_theory.limits.cone F) : (category_theory.limits.is_limit.of_nat_iso.limit_cone h).extend (category_theory.limits.is_limit.of_nat_iso.hom_of_cone h s) = s
{Fq : Type u_1} [fintype Fq] [ring Fq] {d m : ‚Ñï} (hm : fintype.card Fq ^ d ‚â§ m) (b : polynomial Fq) (A : fin m.succ ‚Üí polynomial Fq) (hA : ‚àÄ (i : fin m.succ), (A i).degree < b.degree) : ‚àÉ (i‚ÇÄ i‚ÇÅ : fin m.succ), i‚ÇÄ ‚â† i‚ÇÅ ‚àß (A i‚ÇÅ - A i‚ÇÄ).degree < ‚Üë(b.nat_degree - d)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s u : set E} {f : E ‚Üí F} {x : E} {n : ‚Ñï} (hu : u ‚àà nhds x) (hs : unique_diff_on ùïú s) (xs : x ‚àà s) : iterated_fderiv_within ùïú n f (s ‚à© u) x = iterated_fderiv_within ùïú n f s x
 : cont_mdiff (model_with_corners_self ‚Ñù ‚Ñù) (model_with_corners_self ‚Ñù (euclidean_space ‚Ñù (fin 1))) ‚ä§ ‚áëexp_map_circle
 : expr √ó binder_info √ó list name ‚Üí tactic string
(K : Type u) [comm_ring K] (p : ‚Ñï) [fact (nat.prime p)] [char_p K p] (x : ‚Ñï √ó K) : perfect_closure K p
(ùïÜ : Type u_1) {Œ± : Type u_3} [preorder ùïÜ] [preorder Œ±] [grade_order ùïÜ Œ±] : Œ± ‚Üí ùïÜ
(n : ‚Ñï) (q : tactic.interactive.rw_rules_t) (e : expr) : tactic tactic.nth_rewrite.tracked_rewrite
{G : Type u_10} {H : Type u_11} [add_zero_class G] [mul_one_class H] : multiplicative G ‚âÉ* H ‚âÉ (G ‚âÉ+ additive H)
(R : Type u) [ring R] : Type (max u (v+1))
(R : Type u_1) {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (r : A) : A ‚Üí‚Çó[R] A
{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ‚â† 2) {a : F} (ha : a ‚â† 0) : char.quadratic_char F a = ite (a ^ (fintype.card F / 2) = 1) 1 (-1)
(Œ± : Type u_2) [topological_space Œ±] : Œ± ‚ÜíCO Œ±
(R : Type u_2) {M : Type u_5} [ring R] [add_comm_monoid M] [module R M] : add_comm_group M
 : first_order.language.order.sentence
(p : ‚Ñï) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] (V : Type u_2) [add_comm_group V] [witt_vector.isocrystal p k V] (V‚ÇÇ : Type u_3) [add_comm_group V‚ÇÇ] [witt_vector.isocrystal p k V‚ÇÇ] : Type (max u_2 u_3)
{Œ± : Type u} (m : measure_theory.outer_measure Œ±) : measurable_space.dynkin_system Œ±
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} (t : category_theory.limits.pullback_cone f g) : t.X ‚ü∂ Y
{M : Type u_1} [add_zero_class M] {A : Type u_2} [set_like A M] [add_submonoid_class A M] (S : A) : add_zero_class ‚Ü•S
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {x : E} {n : with_top ‚Ñï} {f : E ‚Üí ùïú} {g : E ‚Üí F} (hf : cont_diff_at ùïú n f x) (hg : cont_diff_at ùïú n g x) : cont_diff_at ùïú n (Œª (x : E), f x ‚Ä¢ g x) x
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ‚Üí+* S) (hf : function.surjective ‚áëf) : f.srange = ‚ä§
{R : Type u_1} [mul_zero_class R] (f g : nat.arithmetic_function R) : nat.arithmetic_function R
 : level ‚Üí tactic level
(ùïÇ : Type u_1) (ùïÇ' : Type u_2) (ùî∏ : Type u_3) [field ùïÇ] [field ùïÇ'] [ring ùî∏] [algebra ùïÇ ùî∏] [algebra ùïÇ' ùî∏] [topological_space ùî∏] [topological_ring ùî∏] (n : ‚Ñï) (x : ùî∏) : ‚áë(exp_series ùïÇ ùî∏ n) (Œª (_x : fin n), x) = ‚áë(exp_series ùïÇ' ùî∏ n) (Œª (_x : fin n), x)
{E : Type u_1} {F : Type u_2} [inner_product_space ‚Ñù E] [inner_product_space ‚Ñù F] (f : E ‚ÜíL[‚Ñù] F) : is_conformal_map f ‚Üî ‚àÉ (c : ‚Ñù), 0 < c ‚àß ‚àÄ (u v : E), has_inner.inner (‚áëf u) (‚áëf v) = c * has_inner.inner u v
{Œ± : Type u_1} {Œ≤ : Type u_2} [monoid_with_zero Œ±] [mul_zero_one_class Œ≤] [mul_action_with_zero Œ± Œ≤] [is_scalar_tower Œ± Œ≤ Œ≤] [smul_comm_class Œ± Œ≤ Œ≤] : Œ± √ó Œ≤ ‚Üí*‚ÇÄ Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} [primcodable Œ±] [primcodable Œ≤] (p : Œ± ‚Üí Prop) (q : Œ≤ ‚Üí Prop) : Prop
(x y : ‚Ñï) (p : x < y) : slim_check.gen ‚Ü•(set.Ico x y)
{Œ± : Type u_1} {Œ±' : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_5} {Œ¥ : Type u_7} {m : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {f : filter Œ±} {g : filter Œ≤} {n : Œ≥ ‚Üí Œ¥} {m' : Œ≤ ‚Üí Œ±' ‚Üí Œ¥} {n' : Œ± ‚Üí Œ±'} (h_antidistrib : ‚àÄ (a : Œ±) (b : Œ≤), n (m a b) = m' b (n' a)) : filter.map n (filter.map‚ÇÇ m f g) = filter.map‚ÇÇ m' g (filter.map n' f)
{Œ± : Type u} : seq1 (seq1 Œ±) ‚Üí seq1 Œ±
(R : Type u_1) [comm_ring R] (c‚ÇÅ c‚ÇÇ : R) : quaternion_algebra R c‚ÇÅ c‚ÇÇ ‚Üí‚Çó[R] R
{R : Type u_1} [comm_semiring R] {n : Type u_4} [fintype n] [decidable_eq n] : matrix n n R ‚âÉ‚Çê[R] (n ‚Üí R) ‚Üí‚Çó[R] n ‚Üí R
(E : Type u_3) [semi_normed_group E] : E ‚âÉ·µ¢ E
{C : Type u} [category_theory.category C] [category_theory.limits.has_strict_initial_objects C] [category_theory.limits.has_initial C] (X : C) [category_theory.limits.has_binary_product X (‚ä•_ C)] : X ‚®Ø ‚ä•_ C ‚âÖ ‚ä•_ C
{Œ± : Type u} [topological_space Œ±] [group Œ±] [topological_group Œ±] : topological_group Œ±·µê·µí·µñ
{Œπ : Type u_1} {M : Type u_3} [decidable_eq Œπ] [semiring M] [Œ† (m : M), decidable (m ‚â† 0)] : add_monoid_algebra M Œπ ‚âÉ+ direct_sum Œπ (Œª (i : Œπ), M)
(h : expr) (hs : expr_set) : tactic bool
{p n : ‚Ñï} (n_big : 2 < n) (p_le_n : p ‚â§ n) (big : 2 * n < 3 * p) : ‚áë(n.central_binom.factorization) p = 0
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [decidable_eq Œπ] [Œ† (i : Œπ), linear_order (Œ± i)] (x y z : Œ† (i : Œπ), Œ± i) : set.Icc x z  set.univ.pi (Œª (i : Œπ), set.Ioc (y i) (z i)) ‚äÜ ‚ãÉ (i : Œπ), set.Icc x (function.update z i (y i))
(Œ± : Type u_1) : option Œ±
(R : Type u_1) [ring R] (C : Type u_2) [category_theory.category C] [category_theory.abelian C] [category_theory.linear R C] [category_theory.enough_projectives C] (n : ‚Ñï) : C·µí·µñ ‚•§ C ‚•§ Module R
{Œ± : Type u_8} [comm_monoid Œ±] : Œ± √ó Œ± ‚Üí* Œ±
(Œ± : Type u) : Type u
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} : monotone f ‚Üí antitone (‚áëorder_dual.to_dual ‚àò f)
(p : omega.nat.preform) : Prop
{n : ‚Ñï} (s : arity Set n) [pSet.definable n s] : pSet.resp n
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] : graded_algebra (has_pow.pow (tensor_algebra.Œπ R).range)
{R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (u : RÀ£) (v : module.ray R M) : u‚Åª¬π ‚Ä¢ v = u ‚Ä¢ v
{Œ± : Type u_1} {Œ≤ : Type u_2} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [topological_space Œ≤] {s : set Œ≤} : is_compact s ‚Üí s.nonempty ‚Üí ‚àÄ {f : Œ≤ ‚Üí Œ±}, continuous_on f s ‚Üí (‚àÉ (x : Œ≤) (H : x ‚àà s), ‚àÄ (y : Œ≤), y ‚àà s ‚Üí f y ‚â§ f x)
{C : Type u} {A : Type u_1} [category_theory.category C] [add_comm_monoid A] [category_theory.has_shift C A] (X : C) (i j : A) : (category_theory.shift_functor C j).obj ((category_theory.shift_functor C i).obj X) ‚âÖ (category_theory.shift_functor C i).obj ((category_theory.shift_functor C j).obj X)
{Œ± : Type u_1} [topological_space Œ±] [polish_space Œ±] {s : set Œ±} (hs : is_open s) : polish_space ‚Ü•s
{Œ± : Type u} {Œ≤ : Type v} [decidable_eq Œ±] : slim_check.total_function Œ± Œ≤ ‚Üí Œ± ‚Üí Œ≤
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) [‚àÄ (X : C), category_theory.is_iso (adj.unit.app X)] [‚àÄ (Y : D), category_theory.is_iso (adj.counit.app Y)] : C ‚âå D
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (b : category_theory.limits.binary_bicone X Y) : b.to_bicone.is_bilimit ‚âÉ b.is_bilimit
(decide_eq : expr ‚Üí expr ‚Üí tactic (bool √ó expr)) : expr ‚Üí list expr ‚Üí tactic (bool √ó expr)
{ùïú : Type u_1} {V : Type u_2} {V‚ÇÇ : Type u_4} {P : Type u_8} {P‚ÇÇ : Type u_9} [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V P] [normed_add_torsor V‚ÇÇ P‚ÇÇ] (f : P ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ) : V ‚Üí‚Çó·µ¢[ùïú] V‚ÇÇ
(p : Prop) : decidable p
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] {X : C} (f : 0 ‚ü∂ X) : f = 0
{V : Type u_1} {Œ± : Type u_2} {A : matrix V V Œ±} [mul_zero_one_class Œ±] [nontrivial Œ±] (h : A.is_adj_matrix) : simple_graph V
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} {Œ≤ : Type u} (g : Œ≤ ‚Üí F (Œ± ::: Œ≤)) : Œ≤ ‚Üí mvqpf.cofix F Œ±
(ùïú : Type u_4) (E : Type u_5) : Type (max u_4 u_5)
{X Y : AddMagma} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ+ ‚Ü•Y
{R : Type u_1} [comm_ring R] {c‚ÇÅ c‚ÇÇ : R} (c : clifford_algebra (clifford_algebra_quaternion.Q c‚ÇÅ c‚ÇÇ)) : ‚áëclifford_algebra_quaternion.to_quaternion (‚áëclifford_algebra.involute (‚áëclifford_algebra.reverse c)) = ‚áëquaternion_algebra.conj (‚áëclifford_algebra_quaternion.to_quaternion c)
{M : Type u_6} [add_monoid M] (u : add_units M) : equiv.perm M
{Œπ : Type u_1} [fintype Œπ] {E : Type u_2} [normed_group E] [normed_space ‚Ñù E] : box_integral.box_additive_map Œπ (E ‚ÜíL[‚Ñù] E) ‚ä§
{X : Top} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) (Y : topological_space.opens ‚Ü•X) : category_theory.presieve Y
(M : Type u) : Type u
(p : ‚Ñï) (a : zmod p) (ha : a ^ (p - 1) = 1) (hd : ‚àÄ (q : ‚Ñï), nat.prime q ‚Üí q ‚à£ p - 1 ‚Üí a ^ ((p - 1) / q) ‚â† 1) : nat.prime p
{F : Type u‚ÇÄ ‚Üí Type u‚ÇÅ} {G : Type (max u‚ÇÄ v‚ÇÄ) ‚Üí Type v‚ÇÅ} [inst : uliftable F G] [functor G] {Œ± : Type u‚ÇÄ} {Œ≤ : Type (max u‚ÇÄ v‚ÇÄ)} (f : Œ± ‚Üí Œ≤) (x : F Œ±) : G Œ≤
(C : Type u) [category_theory.category C] : Prop
 : category_theory.Cat ‚•§ Type u
{Œ± : Type u} [has_add Œ±] : with_zero (multiplicative Œ±) ‚âÉ* multiplicative (with_bot Œ±)
{G : Type u} [add_group G] {A' A B' B : add_subgroup G} [hAN : (A'.add_subgroup_of A).normal] [hBN : (B'.add_subgroup_of B).normal] (h' : A' = B') (h : A = B) : ‚Ü•A ‚ß∏ A'.add_subgroup_of A ‚âÉ+ ‚Ü•B ‚ß∏ B'.add_subgroup_of B
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {Œ± : Type u_1} [has_scalar A Œ±] (S : subalgebra R A) : has_scalar ‚Ü•S Œ±
(d : declaration) : tactic (option string)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (X Y Y' Z : C) [category_theory.exact_pairing Y Y'] : (X ‚äó Y ‚ü∂ Z) ‚âÉ (X ‚ü∂ Z ‚äó Y')
{X Y : Profinite} (f : X ‚ü∂ Y) : is_closed_map ‚áëf
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} (f : J ‚Üí (X ‚ü∂ Y)) [category_theory.limits.has_wide_equalizer f] : category_theory.limits.wide_equalizer f ‚ü∂ X
{R : Type u} [ring R] {J : Type w} [category_theory.category J] (F : J ‚•§ Module R) : category_theory.limits.is_colimit (Module.colimits.colimit_cocone F)
{Œπ : Type u_1} {G : Œπ ‚Üí Type u_4} [Œ† (i : Œπ), group (G i)] {i j : Œπ} (w : free_product.neword G i j) : free_product.neword G j i
{Œ± : Type u_2} [decidable_eq Œ±] [has_zero Œ±] [has_add Œ±] : has_scalar ‚Ñï (finset Œ±)
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} (h : ¬¨metric.bounded s) : metric.diam s = 0
{Œ± : Type u_1} [complete_lattice Œ±] [is_modular_lattice Œ±] [is_compactly_generated Œ±] [is_complemented Œ±] : is_atomistic Œ±
(M : Type u_1) [has_mul M] : Type u_1
{R : Type u_1} {S : Type u_2} [comm_ring R] [is_domain R] [comm_ring S] {L : Type u_3} [field L] [algebra R S] [algebra S L] [algebra R L] [is_scalar_tower R S L] [is_integral_closure S R L] (h : algebra.is_algebraic R L) (inj : function.injective ‚áë(algebra_map R L)) (a : S) {b : S} (hb : b ‚â† 0) : ‚àÉ (c : S) (d : R) (H : d ‚â† 0), d ‚Ä¢ a = b * c
{Œ± : Type u_2} (A : set Œ±) (Œ≤ : Type u_7) [comm_monoid Œ±] [comm_monoid Œ≤] (n : ‚Ñï) : Type (max u_2 u_7)
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] {i j : Œπ} (w : free_product.neword M i j) : free_product M
{Œ± : Type u_2} [bornology Œ±] {s : set Œ±} : bornology.is_bounded s ‚Üí bornology.is_cobounded s·∂ú
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A √ó B) (B √ó A)
{Œ± : Type u} (U : filter (Œ± √ó Œ±)) (refl : ‚àÄ (r : set (Œ± √ó Œ±)), r ‚àà U ‚Üí ‚àÄ (x : Œ±), (x, x) ‚àà r) (symm : ‚àÄ (r : set (Œ± √ó Œ±)), r ‚àà U ‚Üí prod.swap ‚Åª¬π' r ‚àà U) (comp : ‚àÄ (r : set (Œ± √ó Œ±)), r ‚àà U ‚Üí (‚àÉ (t : set (Œ± √ó Œ±)) (H : t ‚àà U), comp_rel t t ‚äÜ r)) : uniform_space.core Œ±
{R : Type u_1} [ring R] {M : Type u_3} [topological_space M] [add_comm_group M] [module R M] [topological_add_group M] (f : (M ‚ÜíL[R] M)À£) : M ‚âÉL[R] M
{Œ± : Type u_1} [measurable_space Œ±] (s t : set Œ±) : Prop
 : ‚Ñï ‚Üí ‚Ñï
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±] {a : Œ±} (h : (set.Ioi a).nonempty) : closure (set.Ioi a) = set.Ici a
{Œ± : Type u_3} {Œ≤ : Type u_4} [lattice Œ±] [lattice Œ≤] (f : lattice_hom Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : lattice_hom Œ± Œ≤
{Œ± : Type u} [linear_ordered_cancel_add_comm_monoid Œ±] {Œ≤ : Type u_1} [has_zero Œ≤] [has_add Œ≤] [has_scalar ‚Ñï Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : linear_ordered_cancel_add_comm_monoid Œ≤
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.limits.preserves_colimits_of_shape J F] : category_theory.limits.preserves_colimits_of_shape J G
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [linear_ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : strict_convex_on ùïú s f) {x y : E} (hx : x ‚àà s) (hy : y ‚àà s) (hxy : x ‚â† y) {a b : ùïú} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : f (a ‚Ä¢ x + b ‚Ä¢ y) < linear_order.max (f x) (f y)
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : setoid Œ±) (f : Œ± ‚Üí Œ≤) : setoid Œ≤
{M : Type u_1} [mul_one_class M] {A : Type u_2} [set_like A M] [submonoid_class A M] (S : A) : mul_one_class ‚Ü•S
(Œ± : Type u_1) [uniform_space Œ±] : Type u_1
{M : Type u_1} {N : Type u_2} {mM : add_zero_class M} [add_comm_monoid N] : has_add (M ‚Üí+ N)
{Œ± : Type v} {s : finset Œ±} {M : Type u_1} [comm_monoid M] (f : Œ± ‚Üí M) (p : M ‚Üí Prop) (p_mul : ‚àÄ (a b : M), p a ‚Üí p b ‚Üí p (a * b)) (p_one : p 1) (p_s : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p (f x)) : p (s.prod (Œª (x : Œ±), f x))
(v : ‚Ñï ‚Üí ‚Ñ§) (as : list ‚Ñ§) : ‚Ñ§
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} {Œπ : Type u_5} [linear_ordered_field ùïú] [add_comm_group E] [ordered_add_comm_group Œ≤] [module ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} {t : finset Œπ} {w : Œπ ‚Üí ùïú} {p : Œπ ‚Üí E} (hf : concave_on ùïú s f) (h‚ÇÄ : ‚àÄ (i : Œπ), i ‚àà t ‚Üí 0 ‚â§ w i) (h‚ÇÅ : 0 < t.sum (Œª (i : Œπ), w i)) (hmem : ‚àÄ (i : Œπ), i ‚àà t ‚Üí p i ‚àà s) : t.center_mass w (f ‚àò p) ‚â§ f (t.center_mass w p)
(p : Prop) : Prop
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (C : cochain_complex V ‚Ñï) {X : V} (f : X ‚ü∂ C.X 0) (w : f ‚â´ C.d 0 1 = 0) : cochain_complex.truncate.obj (C.augment f w) ‚âÖ C
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} : strict_anti f ‚Üí strict_mono (‚áëorder_dual.to_dual ‚àò f)
{l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {Œ± : Type u_12} (M : matrix (n ‚äï o) (l ‚äï m) Œ±) : matrix n l Œ±
{Œ± : Type u_1} {n : ‚Ñï} (a : Œ±) (s : sym Œ± n) : sym Œ± n.succ
{G : Type u_3} [add_group G] : add_group.fg G ‚Üî add_monoid.fg G
{J : Type u} [category_theory.small_category J] (F : J ‚•§ Top) {G : finset J} (H : finset (finite_diagram_arrow G)) : set (Œ† (j : J), ‚Ü•(F.obj j))
{n : ‚Ñï} {m : simplex_category·µí·µñ} (Œ± : (sSet.standard_simplex.obj (simplex_category.mk n)).obj m) : fin ((opposite.unop m).len + 1) ‚Üío fin (n + 1)
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u} [category_theory.category C] {F : J ‚•§ C} [category_theory.limits.has_limit F] {E : K ‚•§ J} [category_theory.limits.has_limit (E ‚ãô F)] (s : category_theory.limits.limit_cone (E ‚ãô F)) (t : category_theory.limits.limit_cone F) : category_theory.limits.limit.pre F E = (category_theory.limits.limit.iso_limit_cone t).hom ‚â´ s.is_limit.lift (category_theory.limits.cone.whisker E t.cone) ‚â´ (category_theory.limits.limit.iso_limit_cone s).inv
(G : Type u_2) [group G] : Prop
(n : ‚Ñï) (l : linarith.linexp) : ‚Ñ§
{G : Type w} [topological_space G] [group G] [topological_group G] {M : Type u_1} {hom : Type u_2} [mul_one_class M] [topological_space M] [has_continuous_mul M] [monoid_hom_class hom G M] (f : hom) (hf : continuous_at ‚áëf 1) : continuous ‚áëf
(R : Type u) [semiring R] (Œπ : Type v) (M : Œπ ‚Üí Type w) [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] [fintype Œπ] : direct_sum Œπ (Œª (i : Œπ), M i) ‚âÉ‚Çó[R] Œ† (i : Œπ), M i
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : free_add_semigroup Œ± ‚Üí free_add_semigroup Œ≤
(R : Type u) [comm_ring R] [local_ring R] : R ‚Üí+* local_ring.residue_field R
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : ‚áë(S.normed_mk) m = ‚áë(quotient_add_group.mk' S) m
{R‚ÇÅ : Type u_1} [semiring R‚ÇÅ] {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] (p : submodule R‚ÇÅ M‚ÇÅ) : ‚Ü•p ‚ÜíL[R‚ÇÅ] M‚ÇÅ
{V : Type u} {G : simple_graph V} (d : G.dart) : V
{Œ± : Type u_1} {n : Type u_4} {m : Type u_5} [mul_zero_class Œ±] {A : matrix m m Œ±} {B : matrix n n Œ±} (hA : A.is_diag) (hB : B.is_diag) : (matrix.kronecker_map has_mul.mul A B).is_diag
(V : Type u‚ÇÅ) : Type u‚ÇÅ
(R : Type u) [topological_space R] [has_star R] : Prop
{Œ±‚ÇÅ : Type u_1} {Œ±‚ÇÇ : Type u_2} {Œ≤ : Œ±‚ÇÇ ‚Üí Type u_3} (e : Œ±‚ÇÅ ‚âÉ Œ±‚ÇÇ) : (Œ£ (a : Œ±‚ÇÅ), Œ≤ (‚áëe a)) ‚âÉ Œ£ (a : Œ±‚ÇÇ), Œ≤ a
 : enat ‚âÉo with_top ‚Ñï
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (X : category_theory.center C) : category_theory.center.tensor_unit.tensor_obj X ‚âÖ X
(_x : interactive.parse (lean.parser.tk "open_all_locales")) : lean.parser unit
{R : Type u_1} {M : Type u_2} [comm_ring R] [topological_space R] [add_comm_group M] [module R M] (B : module_filter_basis R M) : topological_space M
(Œ± : Type u_2) [fintype Œ±] [boolean_algebra Œ±] : complete_boolean_algebra Œ±
{Œ± : Type u_1} {Œπ : Type u} (r : Œπ ‚Üí Œπ ‚Üí Prop) [is_well_order Œπ r] (f : Œπ ‚Üí Œ±) (a : ordinal) (H : a < ordinal.type r) : Œ±
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [has_lt Œπ] [Œ† (i : Œπ), has_lt (Œ± i)] : has_lt (Œ£‚Çó' (i : Œπ), Œ± i)
(R : Type u) (X : Type v) [comm_ring R] : universal_enveloping_algebra R (free_lie_algebra R X) ‚âÉ‚Çê[R] free_algebra R X
{Œ± : Type u_1} {s t : set Œ±} [decidable_pred (Œª (x : Œ±), x ‚àà s)] (H : s ‚à© t ‚äÜ ‚àÖ) : ‚Ü•(s ‚à™ t) ‚âÉ ‚Ü•s ‚äï ‚Ü•t
(Œ± : Type u_2) [has_zero Œ±] [has_one Œ±] [has_le Œ±] : Type
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] (m : M) : quadratic_form R M ‚Üí+ R
{K : Type v} [field K] (f : polynomial K) : Type v
{Œ± : Type u_1} : finset (option Œ±) ‚Üío finset Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {Y : C} [category_theory.limits.has_terminal C] (f : ‚ä§_ C ‚ü∂ Y) : category_theory.split_mono f
{ùïÇ : Type u_1} [nondiscrete_normed_field ùïÇ] [complete_space ùïÇ] (h : 0 < (exp_series ùïÇ ùïÇ).radius) : has_deriv_at (exp ùïÇ) 1 0
{Œπ : Type u_1} {Œπ' : Type u_2} {Œ± : Type u_3} [fintype Œπ] [preorder Œπ'] [is_directed Œπ' (function.swap has_le.le)] [nonempty Œπ'] {s : Œπ ‚Üí Œπ' ‚Üí set Œ±} (hs : ‚àÄ (i : Œπ), antitone (s i)) : (‚ãÉ (j : Œπ'), ‚ãÇ (i : Œπ), s i j) = ‚ãÇ (i : Œπ), ‚ãÉ (j : Œπ'), s i j
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) : category_theory.limits.cone F
{Œ± : Type u} {Œ≤ : Type v} {m : Œ± ‚Üí Œ≤} (u : ultrafilter Œ≤) (inj : function.injective m) (large : set.range m ‚àà u) : ultrafilter Œ±
{G : Type u_1} [add_group G] {Œπ : Sort u_2} (S : Œπ ‚Üí add_subgroup G) {C : Œ† (x : G), (x ‚àà ‚®Ü (i : Œπ), S i) ‚Üí Prop} (hp : ‚àÄ (i : Œπ) (x : G) (H : x ‚àà S i), C x _) (h1 : C 0 _) (hmul : ‚àÄ (x y : G) (hx : x ‚àà ‚®Ü (i : Œπ), S i) (hy : y ‚àà ‚®Ü (i : Œπ), S i), C x hx ‚Üí C y hy ‚Üí C (x + y) _) {x : G} (hx : x ‚àà ‚®Ü (i : Œπ), S i) : C x hx
{Œ± : Type u} {Œ≤ : Type v} {t : set Œ≤} {f : Œ± ‚Üí Œ≤} (h : ‚àÄ (x : Œ±), f x ‚àà t) : function.injective f ‚Üí function.injective (set.cod_restrict f t h)
 : interactive.parse (lean.parser.many interactive.types.ident_) ‚Üí tactic unit
{V : Type u} {G : simple_graph V} [decidable_eq V] {u v w : V} (p : G.walk v w) (h : u ‚àà p.support) : (p.take_until u h).append (p.drop_until u h) = p
{C : Type u} [category_theory.category C] (F G : C ‚•§ category_theory.discrete punit) : F ‚âÖ G
{Œ± : Type u} (c : complete_distrib_lattice Œ±) (le : Œ± ‚Üí Œ± ‚Üí Prop) (eq_le : le = complete_distrib_lattice.le) (top : Œ±) (eq_top : top = complete_distrib_lattice.top) (bot : Œ±) (eq_bot : bot = complete_distrib_lattice.bot) (sup : Œ± ‚Üí Œ± ‚Üí Œ±) (eq_sup : sup = complete_distrib_lattice.sup) (inf : Œ± ‚Üí Œ± ‚Üí Œ±) (eq_inf : inf = complete_distrib_lattice.inf) (Sup : set Œ± ‚Üí Œ±) (eq_Sup : Sup = complete_distrib_lattice.Sup) (Inf : set Œ± ‚Üí Œ±) (eq_Inf : Inf = complete_distrib_lattice.Inf) : complete_distrib_lattice Œ±
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_scalar Œ± Œ≤] : has_scalar Œ± (filter Œ≤)
{G : Type u_1} [group G] {Œπ : Type u_2} (s : finset Œπ) (f : Œπ ‚Üí G) (comm : ‚àÄ (x : Œπ), x ‚àà s ‚Üí ‚àÄ (y : Œπ), y ‚àà s ‚Üí commute (f x) (f y)) (K : Œπ ‚Üí subgroup G) (hind : complete_lattice.independent K) (hmem : ‚àÄ (x : Œπ), x ‚àà s ‚Üí f x ‚àà K x) (heq1 : s.noncomm_prod f comm = 1) (i : Œπ) (H : i ‚àà s) : f i = 1
{R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} {A‚ÇÉ : Type u‚ÇÅ} [comm_semiring R] [semiring A‚ÇÅ] [semiring A‚ÇÇ] [semiring A‚ÇÉ] [algebra R A‚ÇÅ] [algebra R A‚ÇÇ] [algebra R A‚ÇÉ] (e‚ÇÅ : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ) (e‚ÇÇ : A‚ÇÇ ‚âÉ‚Çê[R] A‚ÇÉ) : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÉ
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {G : Type u_5} [group G] [distrib_mul_action G M] [smul_comm_class R G M] : mul_action G (module.ray R M)
(u : pnat.xgcd_type) : u.r + (u.bp + 1) * u.q = u.ap + 1
{Œ± : Type u_1} [uniform_space Œ±] (pkg : abstract_completion Œ±) {Œ≤ : Type u_2} [uniform_space Œ≤] (pkg' : abstract_completion Œ≤) (f : Œ± ‚Üí Œ≤) : pkg.space ‚Üí pkg'.space
{Œ≤ Œ± : Type u} (f : Œ≤ ‚Üí Œ±) (h‚ÇÅ : cardinal.aleph_0 ‚â§ cardinal.mk Œ≤) (h‚ÇÇ : cardinal.mk Œ± < (cardinal.mk Œ≤).ord.cof) : ‚àÉ (a : Œ±), cardinal.mk ‚Ü•(f ‚Åª¬π' {a}) = cardinal.mk Œ≤
{Œπ : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [ordered_comm_monoid N] (f : M ‚Üí N) (p : M ‚Üí Prop) (h_mul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí f (x * y) ‚â§ f x * f y) (hp_mul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x * y)) (g : Œπ ‚Üí M) (s : finset Œπ) (hs_nonempty : s.nonempty) (hs : ‚àÄ (i : Œπ), i ‚àà s ‚Üí p (g i)) : f (s.prod (Œª (i : Œπ), g i)) ‚â§ s.prod (Œª (i : Œπ), f (g i))
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (C : homological_complex V c) [category_theory.limits.has_zero_object V] {i j : Œπ} (r : c.rel i j) : C.X_next i ‚âÖ C.X j
(M : Type u_1) (Œ± : Type u_2) [has_scalar M Œ±] [measurable_space M] [measurable_space Œ±] : Prop
{Œ± : Type u} [e : pseudo_emetric_space Œ±] (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù) (edist_ne_top : ‚àÄ (x y : Œ±), has_edist.edist x y ‚â† ‚ä§) (h : ‚àÄ (x y : Œ±), dist x y = (has_edist.edist x y).to_real) : pseudo_metric_space Œ±
{Œ± : Type u} (m : measure_theory.outer_measure Œ±) (s : set Œ±) : Prop
 : Type
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} (h : s.finite) : metric.bounded s
{R : Type u} [semiring R] [no_zero_divisors R] [nontrivial R] (l : list (polynomial R)) : l.prod.degree = (list.map polynomial.degree l).sum
{Œ± : Type u_1} {Œ≤ : Type u_2} [partial_order Œ±] [partial_order Œ≤] [topological_space Œ±] [topological_space Œ≤] [order_topology Œ±] [order_topology Œ≤] (e : Œ± ‚âÉo Œ≤) : Œ± ‚âÉ‚Çú Œ≤
{Œ± : Type} (p : tactic.rewrite_search.dir_pair Œ±) : list Œ±
 : linter
(Œ± : Type u_6) (Œ≤ : Type u_7) [topological_space Œ±] [topological_space Œ≤] : Type (max u_6 u_7)
{Œ± : Type u_1} [fintype Œ±] [decidable_eq Œ±] (p : equiv.perm Œ±) (x : Œ±) : list Œ±
{Œ± : Type u_1} {f g : filter Œ±} (F : f.realizer) (G : g.realizer) : (f ‚äî g).realizer
(r : interactive.parse interactive.types.texpr) (n : interactive.parse (optional (lean.parser.tk "using" *> lean.parser.small_nat))) : tactic unit
(f : Type u‚ÇÄ ‚Üí Type u‚ÇÅ) [equiv_functor f] {Œ± Œ≤ Œ≥ : Type u‚ÇÄ} (ab : Œ± ‚âÉ Œ≤) (bc : Œ≤ ‚âÉ Œ≥) : (equiv_functor.map_equiv f ab).trans (equiv_functor.map_equiv f bc) = equiv_functor.map_equiv f (ab.trans bc)
(L : first_order.language) : L.Theory
(Œ± : Type u_1) {Œ≤ : Type u_2} [has_one Œ≤] (h : function.surjective 1) : unique Œ≤
(R : Type u) {B : Type v} [comm_ring R] [decidable_eq B] [fintype B] (A : matrix B B ‚Ñ§) : lie_ideal R (free_lie_algebra R (cartan_matrix.generators B))
(Œ± : Type v) : Type u
{R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] : is_smul_regular M 1
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] (F : J ‚•§ C) : category_theory.limits.cone F ‚âÖ Œ£ (X : C·µí·µñ), F.cones.obj X
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : Type (max u v)
 : tactic.unify_equations.unification_step
{C : Type u} [category_theory.category C] (s : set (category_theory.grothendieck_topology C)) : is_glb s (has_Inf.Inf s)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {m n : with_top ‚Ñï} {f : E ‚Üí F} (hf : cont_diff ùïú n f) (hmn : m + 1 ‚â§ n) : cont_diff ùïú m (Œª (p : E √ó E), ‚áë(fderiv ùïú f p.fst) p.snd)
 : category_theory.coyoneda.obj (opposite.op punit) ‚âÖ ùü≠ (Type v‚ÇÅ)
{p : ‚Ñï} [fact (nat.prime p)] : has_one ‚Ñ§_[p]
{V : Type u‚ÇÅ} [quiver V] : prefunctor V (category_theory.paths V)
 : Type
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] (F : J ‚•§ K ‚•§ C) (c : Œ† (k : K), category_theory.limits.colimit_cocone (F.flip.obj k)) : category_theory.limits.is_colimit (category_theory.limits.combine_cocones F c)
 : pos_num ‚Üí list bool
(R : Type u_1) (A : Type u_2) [semiring R] [non_unital_semiring A] [module R A] : R ‚Üí+* unitization R A
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [has_zero M] [comm_monoid N] [comm_monoid P] (h : N ‚Üí* P) (f : Œ± ‚Üí‚ÇÄ M) (g : Œ± ‚Üí M ‚Üí N) : ‚áëh (f.prod g) = f.prod (Œª (a : Œ±) (b : M), ‚áëh (g a b))
{Œ± : Type u} (s : set Œ±) (t : Œ± ‚Üí Prop) : ‚Ü•{x ‚àà s | t x} ‚âÉ ‚Ü•{x : ‚Ü•s | t ‚Üëx}
{C : Type u‚ÇÇ} [category_theory.category C] [category_theory.limits.has_binary_products C] {J : Type v‚ÇÇ} [category_theory.small_category J] {X : C} {K : J ‚•§ C} (s : category_theory.limits.cone (K ‚ãô category_theory.limits.prod.functor.obj X)) : category_theory.limits.cone K
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (c : category_theory.limits.binary_bicone P Q) : category_theory.limits.cone (category_theory.limits.pair P Q)
{Œ± : Type u_1} {l : filter Œ±} {f : Œ± ‚Üí ‚Ñù} : ((Œª (x : Œ±), 1) =O[l] Œª (x : Œ±), real.exp (f x)) ‚Üî filter.is_bounded_under ge l f
 : expr ‚Üí option unsigned
{L : first_order.language} (T : L.Theory) (Œ∫ : cardinal) (M : Type w') [L.Structure M] [M ‚ä® T] [infinite M] : ‚àÉ (N : T.Model), Œ∫.lift ‚â§ cardinal.mk ‚Ü•N
 : Fintype ‚•§ FinBoolAlg·µí·µñ
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {f : X ‚ü∂ Y} [category_theory.split_mono f] {c : category_theory.limits.cokernel_cofork f} (i : category_theory.limits.is_colimit c) : (category_theory.limits.binary_bicone_of_split_mono_of_cokernel i).is_bilimit
 : native.float ‚Üí ‚Ñ§
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (H : well_founded r) (p : set Œ±) (h : p.nonempty) : Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : Y ‚ü∂ X) [category_theory.split_epi f] : galois_insertion (category_theory.sieve.pushforward f) (category_theory.sieve.pullback f)
 : lean.parser (tactic.list_Pi tactic.rcases_patt)
{m : Type u ‚Üí Type u} [monad m] [alternative m] {Œ± Œ≤ : Type u} (f : Œ± ‚Üí m Œ≤) : tactic.mllist m Œ± ‚Üí tactic.mllist m Œ≤
(ns : list name) (reserved : name_set) : tactic expr
(R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] : Prop
(Œ± : Type u_2) : Type u_2
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_le Œ±] [has_le Œ≤] : has_le (Œ± ‚äï‚Çó Œ≤)
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [category_theory.is_iso g] : category_theory.limits.pushout_cocone f g
 : BoundedOrder ‚âå BoundedOrder
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : setoid Œ±} (f : Œ± ‚Üí Œ≤) (H : ‚àÄ (x y : Œ±), r.rel x y ‚Üí f x = f y) (h : function.injective (quotient.lift f H)) : setoid.ker f = r
{Œ± : Type u} [pseudo_emetric_space Œ±] {s t : set Œ±} (hs : is_closed s) (ht : is_closed t) : emetric.Hausdorff_edist s t = 0 ‚Üî s = t
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [is_refl Œ± r] {x y : Œ±} : x ‚â† y ‚Üí r x y ‚Üî r x y
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : has_quotient M (submodule R M)
(Œì‚ÇÄ : Type u_1) [linear_ordered_comm_group_with_zero Œì‚ÇÄ] : has_pure.pure ‚â§ linear_ordered_comm_group_with_zero.nhds_fun Œì‚ÇÄ
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} : function.injective2 fin.cons
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x y z : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (hz : z ‚â† 0) : o.oangle (-x) y + o.oangle (-y) z + o.oangle (-z) x = ‚Üëreal.pi
 : conv unit
 : expr ‚Üí expr ‚Üí bool
(F : Type u_2) (Œ± : out_param (Type u_3)) (Œ≤ : out_param (Type u_4)) [topological_space Œ±] [has_zero Œ≤] [topological_space Œ≤] : Type (max u_2 u_3 u_4)
{G : Type u_2} [group G] {a b : G} : a = b ‚Üí a / b = 1
(s : string) : char
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} : a ‚â§ b ‚Üí b < c ‚Üí a < c
 : stieltjes_function
{Œ± : Type u} [add_comm_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b c : Œ±} : a - b < c ‚Üí a < b + c
{S : Type u_2} [comm_ring S] {K : Type u_4} [field K] {F : Type u_6} [field F] [algebra K S] [algebra K F] [nontrivial S] (pb : power_basis K S) (hf : polynomial.splits (algebra_map K F) (minpoly K pb.gen)) : ‚áë(algebra_map K F) (‚áë(algebra.trace K S) pb.gen) = (polynomial.map (algebra_map K F) (minpoly K pb.gen)).roots.sum
(G‚ÇÄ : Type u) : Type u
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : S = ‚ä• ‚à® ‚àÉ (x : M) (H : x ‚àà S), x ‚â† 0
 : pgame
{Œ± : Type u} (x : with_top Œ±) : x ‚â† ‚ä§ ‚Üí Œ±
{M : Type u_1} [mul_one_class M] (s : set M) {p : Œ† (x : M), x ‚àà submonoid.closure s ‚Üí Prop} (Hs : ‚àÄ (x : M) (h : x ‚àà s), p x _) (H1 : p 1 _) (Hmul : ‚àÄ (x : M) (hx : x ‚àà submonoid.closure s) (y : M) (hy : y ‚àà submonoid.closure s), p x hx ‚Üí p y hy ‚Üí p (x * y) _) {x : M} (hx : x ‚àà submonoid.closure s) : p x hx
{B : Type u‚ÇÅ} [comm_ring B] (r : B ‚Üí B ‚Üí Prop) : ring_quot r ‚Üí+* B ‚ß∏ ideal.of_rel r
(R : Type u) [ring R] [strong_rank_condition R] {Œπ : Type v} [fintype Œπ] : finite_dimensional.finrank R (Œπ ‚Üí‚ÇÄ R) = fintype.card Œπ
(M : Type u_10) (N : Type u_11) (Œ± : Type u_12) [has_scalar M N] [has_scalar N Œ±] [has_scalar M Œ±] : Prop
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} (h‚ÇÄ : f = g) {c : category_theory.limits.fork f g} (h : category_theory.limits.is_limit c) : category_theory.is_iso c.Œπ
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : Type (max u v)
(Œπ : Type u_1) (R : Type u_2) [unique Œπ] [semiring R] : basis Œπ R R
{T : Type u‚ÇÅ} [category_theory.category T] {X Y : T} (f : X ‚ü∂ Y) : category_theory.under X
{R : Type u} [semiring R] [no_zero_divisors R] {p‚ÇÅ p‚ÇÇ q‚ÇÅ q‚ÇÇ : polynomial R} (hp‚ÇÅ : p‚ÇÅ ‚â† 0) (hq‚ÇÅ : q‚ÇÅ ‚â† 0) (hp‚ÇÇ : p‚ÇÇ ‚â† 0) (hq‚ÇÇ : q‚ÇÇ ‚â† 0) (h_eq : p‚ÇÅ * q‚ÇÇ = p‚ÇÇ * q‚ÇÅ) : ‚Üë(p‚ÇÅ.nat_degree) - ‚Üë(q‚ÇÅ.nat_degree) = ‚Üë(p‚ÇÇ.nat_degree) - ‚Üë(q‚ÇÇ.nat_degree)
{Œπ : Type v} (f : Œπ ‚Üí cardinal) (t : cardinal) (w : ‚àÄ (i : Œπ), (f i).lift ‚â§ t) : (cardinal.sup f).lift ‚â§ t
{Œ± : Type u} [topological_space Œ±] {x : Œ±} {s : set Œ±} : cluster_pt x (filter.principal s) ‚Üî ‚àÄ (U : set Œ±), U ‚àà nhds x ‚Üí (U ‚à© s).nonempty
(u : level) (Œ± nonemp p : expr) : list expr ‚Üí expr √ó expr ‚Üí tactic (expr √ó expr)
 : tactic unit
 : bool ‚Üí list pexpr ‚Üí pexpr ‚Üí list (pexpr √ó pexpr)
(x : pgame) [is_empty x.left_moves] [is_empty x.right_moves] : x.relabelling 0
{Œ± : Type u} {Œ≤ : Type v} [decidable_eq Œ≤] [fintype Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) {n : ‚Ñï} (hn : fintype.card Œ± < fintype.card Œ≤ * n) : ‚àÉ (y : Œ≤), (finset.filter (Œª (x : Œ±), f x = y) finset.univ).card < n
{R : Type u‚ÇÅ} [semiring R] (r : R ‚Üí R ‚Üí Prop) : R ‚Üí+* ring_quot r
(h : expr) : tactic name_set
{n : ‚Ñï} (P : mvpfunctor n) {Œ± Œ≤ : typevec n} (f : Œ±.arrow Œ≤) : P.obj Œ± ‚Üí P.obj Œ≤
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [Œ† (i : Œπ), has_zero (Œ≤ i)] : function.injective coe_fn
{M : Type u_1} {G : Type u_2} [mul_one_class M] [comm_group G] : has_div (M ‚Üí* G)
(C : Type u) : Type u
(R : Type u_1) (A : Type u_2) (M : Type u_3) (N : Type u_4) (P : Type u_5) [comm_semiring R] [comm_semiring A] [algebra R A] [add_comm_monoid M] [module R M] [module A M] [is_scalar_tower R A M] [add_comm_monoid N] [module R N] [add_comm_monoid P] [module R P] [module A P] [is_scalar_tower R A P] : (M ‚Üí‚Çó[A] N ‚Üí‚Çó[R] P) ‚âÉ‚Çó[A] tensor_product R M N ‚Üí‚Çó[A] P
{G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {U : set (G √ó G)} (hU : U ‚àà nhds 1) : ‚àÉ (V : open_subgroup G), ‚ÜëV √óÀ¢ ‚ÜëV ‚äÜ U
 : vm_obj ‚Üí environment
{M : Type u_1} [add_zero_class M] {Œπ : Sort u_2} (S : Œπ ‚Üí add_submonoid M) {C : Œ† (x : M), (x ‚àà ‚®Ü (i : Œπ), S i) ‚Üí Prop} (hp : ‚àÄ (i : Œπ) (x : M) (H : x ‚àà S i), C x _) (h1 : C 0 _) (hmul : ‚àÄ (x y : M) (hx : x ‚àà ‚®Ü (i : Œπ), S i) (hy : y ‚àà ‚®Ü (i : Œπ), S i), C x hx ‚Üí C y hy ‚Üí C (x + y) _) {x : M} (hx : x ‚àà ‚®Ü (i : Œπ), S i) : C x hx
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {i : D ‚•§ C} [category_theory.reflective i] : D ‚âå ‚Ü•(i.ess_image)
{ùïÜ : Type u_1} {Œ± : Type u_3} {Œ≤ : Type u_4} [preorder ùïÜ] [preorder Œ±] [preorder Œ≤] [grade_bounded_order ùïÜ Œ≤] (f : Œ± ‚Üí Œ≤) (hf : strict_mono f) (hcovby : ‚àÄ (a b : Œ±), a ‚ãñ b ‚Üí f a ‚ãñ f b) (hmin : ‚àÄ (a : Œ±), is_min a ‚Üí is_min (f a)) (hmax : ‚àÄ (a : Œ±), is_max a ‚Üí is_max (f a)) : grade_bounded_order ùïÜ Œ±
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [mul_one_class Œ±] [mul_one_class Œ≤] : has_coe_to_fun (Œ± ‚Üí*o Œ≤) (Œª (_x : Œ± ‚Üí*o Œ≤), Œ± ‚Üí Œ≤)
(R : Type u) (A : Type v) [has_star R] [has_star A] [has_scalar R A] : Prop
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {Œπ : Type u_3} {p : Œπ ‚Üí submodule R M} {m : M} : (m ‚àà ‚®Ü (i : Œπ), p i) ‚Üî ‚àÉ (s : finset Œπ), m ‚àà ‚®Ü (i : Œπ) (H : i ‚àà s), p i
{ùïú : Type u_1} {E : Type u_2} [normed_linear_ordered_field ùïú] [normed_group E] [normed_space ùïú E] (l : E ‚ÜíL[ùïú] ùïú) (A : set E) : set E
(Œ≤ ef : expr) (xs : list expr) : tactic (expr √ó expr)
{M‚ÇÄ : Type u_6} [monoid_with_zero M‚ÇÄ] {L : list M‚ÇÄ} (h : 0 ‚àà L) : L.prod = 0
(h_equality : expr) (coeff : pexpr) : tactic expr
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_4} [decidable_eq Œπ] [fintype Œπ] (e : basis Œπ R M) (f : alternating_map R M R Œπ) : f = ‚áëf ‚áëe ‚Ä¢ e.det
{P : Type u_1} [semilattice_inf P] {x y : P} {F : order.pfilter P} (hx : x ‚àà F) (hy : y ‚àà F) : x ‚äì y ‚àà F
 : ‚Ñï ‚Üí environment
{M : Type u_1} [add_comm_monoid M] {N : Type u_2} [add_comm_monoid N] (x : M) (f : add_submonoid.localization_map.away_map x N) : add_localization.away x ‚âÉ+ N
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.creates_colimit K F] : category_theory.creates_colimit K G
(Œ± : Type u_1) : Type u_1
{M : Type u_1} [has_mul M] (c : con M) {x y : M} : ‚áëc x y ‚Üí ‚áëc y x
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] (X : C) : unique (0 ‚ü∂ X)
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ‚Ñù E] [normed_group F] [normed_space ‚Ñù F] {s : set E} (s_conv : convex ‚Ñù s) (hne : (interior s).nonempty) {f : E ‚Üí F} {f' : E ‚Üí (E ‚ÜíL[‚Ñù] F)} {f'' : E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] F} (hf : ‚àÄ (x : E), x ‚àà interior s ‚Üí has_fderiv_at f (f' x) x) {x : E} (xs : x ‚àà s) (hx : has_fderiv_within_at f' f'' (interior s) x) (v w : E) : ‚áë(‚áëf'' v) w = ‚áë(‚áëf'' w) v
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) : set.bij_on g (function.fixed_points (f ‚àò g)) (function.fixed_points (g ‚àò f))
{G‚ÇÄ : Type u_2} {Œ± : Type u_3} [measurable_space G‚ÇÄ] [measurable_space Œ±] [group_with_zero G‚ÇÄ] [mul_action G‚ÇÄ Œ±] [has_measurable_smul G‚ÇÄ Œ±] (c : G‚ÇÄ) (hc : c ‚â† 0) : Œ± ‚âÉ·µê Œ±
{R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [topological_space M] [topological_space M‚ÇÇ] [ring R] [add_comm_group M] [topological_add_group M] [module R M] [add_comm_group M‚ÇÇ] [module R M‚ÇÇ] (e : M ‚âÉL[R] M‚ÇÇ) (f : M ‚ÜíL[R] M‚ÇÇ) : f.inverse = (ring.inverse (‚Üë(e.symm).comp f)).comp ‚Üë(e.symm)
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (Œ∏ : real.angle) : (o.rotation Œ∏).symm = o.rotation (-Œ∏)
(h : option pexpr) (old_tp new_tp inst e : expr) (s : simp_lemmas) (to_unfold : list name) : tactic expr
(Œ± : Type u_8) : Type u_8
(Œ± : Type u_1) : Type u_1
(ùïú : Type u_1) {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] (A B : set E) : Prop
{e : ‚ÑÇ ‚Üí ‚ÑÇ} {e' : ‚ÑÇ} {z : ‚Ñù} (h : has_strict_deriv_at e e' ‚Üëz) : has_strict_deriv_at (Œª (x : ‚Ñù), (e ‚Üëx).re) e'.re z
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] : cont_diff ùïú ‚ä§ ‚áë(equiv.prod_assoc E F G)
{M : Type u_3} {N : Type u_4} {P : Type u_5} [add_zero_class M] [add_zero_class N] [add_zero_class P] (hnp : N ‚Üí+ P) (hmn : M ‚Üí+ N) : M ‚Üí+ P
{Œ± : Type u_1} [topological_space Œ±] [has_le Œ±] (s : clopen_upper_set Œ±) : upper_set Œ±
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (R‚ÇÇ : Type u_5) [comm_semiring R‚ÇÇ] [algebra R‚ÇÇ R] : bilin_form R M ‚Üí‚Çó[R‚ÇÇ] bilin_form R M
 : ‚Ñï+ ‚âÉ prime_multiset
(C : Type u_1) (D : Type u_2) [category_theory.category C] [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] : Type (max u_3 u_4 u_1 u_2)
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (C : cochain_complex V ‚Ñï) {X : V} (f : X ‚ü∂ C.X 0) (w : f ‚â´ C.d 0 1 = 0) : cochain_complex V ‚Ñï
(G : Type u_1) [topological_space G] [has_involutive_inv G] [has_continuous_inv G] : G ‚âÉ‚Çú G
{R : Type u_4} {S : Type u_5} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S] (f : R ‚âÉ+* S) : ‚áëf 0 = 0
{R : Type u} [comm_ring R] : comm_ring ‚Ü•(ùüô_ (Module R))
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) : free_magma Œ± ‚Üí free_magma Œ≤
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) (f : G ‚Üí+ N) (hf : function.injective ‚áëf) : ‚Ü•H ‚âÉ+ ‚Ü•(add_subgroup.map f H)
 : category_theory.reflects_isomorphisms (category_theory.forget‚ÇÇ TopCommRing Top)
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) : M ‚Üí‚Çó[R] clifford_algebra Q
{n : ‚Ñï} : fin_succ_equiv' 0 = fin_succ_equiv n
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [has_lt Œπ] [Œ† (i : Œπ), has_lt (Œ± i)] : has_lt (Œ£‚Çó (i : Œπ), Œ± i)
{G : Type u} [add_group G] : inhabited (add_group_filter_basis G)
{R : Type u_1} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : has_bot (submodule R M)
{Œ± Œ≤ : Type u} (f : Œ± ‚ü∂ Œ≤) : category_theory.limits.types.image f ‚ü∂ Œ≤
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] : E ‚Üí‚Çó[ùïú] E ‚Üí‚Çó‚ãÜ[ùïú] ùïú
{R : Type u} [comm_semiring R] [star_ring R] (x : R) : ‚áë(star_ring_end R) (‚áë(star_ring_end R) x) = x
{R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type u_3} [add_comm_group M] [module R M] {Œπ : Type u_1} [fintype Œπ] (b : basis Œπ R M) (N : submodule R M) : Œ£ (n : ‚Ñï), basis (fin n) R ‚Ü•N
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M ‚Üí* P} {T : submonoid P} (hy : ‚àÄ (y : ‚Ü•S), ‚áëg ‚Üëy ‚àà T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} (z : N) : ‚áë(k.to_map) (‚áëg ‚Üë((f.sec z).snd)) * ‚áë(f.map hy k) z = ‚áë(k.to_map) (‚áëg (f.sec z).fst)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P (n + 1)) (i : fin (n + 2)) : finite_dimensional ‚Ñù ‚Ü•((s.altitude i).direction)
(args : interactive.parse tactic.interactive.case_parser) (tac : tactic.interactive.itactic) : tactic unit
{C : Type u} [category_theory.category C] {X : C} {S R : category_theory.sieve X} (J : category_theory.grothendieck_topology C) (Hss : S ‚â§ R) (sjx : S ‚àà ‚áëJ X) : R ‚àà ‚áëJ X
{Œ± : Type u_1} [linear_order Œ±] : finset Œ± ‚Üí option Œ±
{K : Type u} [field K] (s : subfield K) {l : list K} : (‚àÄ (x : K), x ‚àà l ‚Üí x ‚àà s) ‚Üí l.prod ‚àà s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ‚Ñï} {s1 s2 : affine.simplex k P n} (h : ‚àÄ (i : fin (n + 1)), s1.points i = s2.points i) : s1 = s2
{R : Type u} [ring R] (p q : polynomial R) : polynomial R
 : Set ‚Üí Set ‚Üí Set
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : fintype ‚Ü•(basis.of_vector_space_index K V)
 : Set
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) [finite_dimensional K ‚Ü•E] : is_closed ‚Üë(E.fixing_subgroup)
(R : Type u) (S‚ÇÅ : Type v) (S‚ÇÇ : Type w) (S‚ÇÉ : Type x) [comm_semiring R] [comm_semiring S‚ÇÉ] (f : mv_polynomial S‚ÇÅ R ‚Üí+* mv_polynomial S‚ÇÇ S‚ÇÉ) (g : mv_polynomial S‚ÇÇ S‚ÇÉ ‚Üí+* mv_polynomial S‚ÇÅ R) (hfgC : (f.comp g).comp mv_polynomial.C = mv_polynomial.C) (hfgX : ‚àÄ (n : S‚ÇÇ), ‚áëf (‚áëg (mv_polynomial.X n)) = mv_polynomial.X n) (hgfC : (g.comp f).comp mv_polynomial.C = mv_polynomial.C) (hgfX : ‚àÄ (n : S‚ÇÅ), ‚áëg (‚áëf (mv_polynomial.X n)) = mv_polynomial.X n) : mv_polynomial S‚ÇÅ R ‚âÉ+* mv_polynomial S‚ÇÇ S‚ÇÉ
{Œ± : Type u} (s : stream Œ±) : stream (list Œ±)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p b : P) : ‚áë(s.weighted_vsub_of_point (Œª (_x : Œπ), p) b) w = s.sum (Œª (i : Œπ), w i) ‚Ä¢ (p -·µ• b)
{M : Type u_1} [monoid M] : has_faithful_smul (mul_aut M) M
{G : Type w} [topological_space G] [add_group G] [topological_add_group G] (s : add_subgroup G) : add_subgroup G
(ns : interactive.parse (lean.parser.many interactive.types.ident_)) : tactic unit
(B : Type v) [decidable_eq B] [fintype B] : Type v
(k n : ‚Ñï) : (list.nat.antidiagonal_tuple k n).nodup
{Œ± : Type u_1} [linear_order Œ±] {s : finset Œ±} {k : ‚Ñï} (h : s.card = k) (hz : 0 < k) : ‚áë(s.order_emb_of_fin h) ‚ü®0, hz‚ü© = s.min' _
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} (fin : emetric.Hausdorff_edist s t ‚â† ‚ä§) : metric.Hausdorff_dist s t = 0 ‚Üî closure s = closure t
{Œ± : Type u} : function.injective free_group.of
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} (f : J ‚Üí (X ‚ü∂ Y)) : Prop
{M‚ÇÄ : Type u_1} [mul_zero_class M‚ÇÄ] [no_zero_divisors M‚ÇÄ] {a b : M‚ÇÄ} : a * b = 0 ‚Üî b * a = 0
{K : Type u} [field K] (s : subfield K) : ‚Ü•s ‚Üí+* K
(n : name) (appl_inst cl f v e : expr) : tactic (expr ‚äï expr)
{Œ± : Type u_1} [linear_order Œ±] {A B : finset Œ±} (h : A ‚äÜ B) : A.to_colex ‚â§ B.to_colex
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [linear_ordered_ring Œ±] [floor_ring Œ±] [topological_space Œ±] [order_topology Œ±] [topological_add_group Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ≤ ‚Üí Œ± ‚Üí Œ≥} (h : continuous_on (function.uncurry f) (set.univ √óÀ¢ set.Icc 0 1)) (hf : ‚àÄ (s : Œ≤), f s 0 = f s 1) : continuous (Œª (st : Œ≤ √ó Œ±), f st.fst (int.fract st.snd))
{R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] {abv : absolute_value R ‚Ñ§} {Œπ : Type u_5} [decidable_eq Œπ] [fintype Œπ] (bS : basis Œπ R S) (adm : abv.is_admissible) [infinite R] [decidable_eq R] (a : S) {b : R} (hb : b ‚â† 0) : ‚àÉ (q : S) (r : R) (H : r ‚àà class_group.finset_approx bS adm), ‚áëabv (‚áë(algebra.norm R) (r ‚Ä¢ a - b ‚Ä¢ q)) < ‚áëabv (‚áë(algebra.norm R) (‚áë(algebra_map R S) b))
{Œ± : Type u_1} [monoid Œ±] {a b u : Œ±} (hu : is_unit u) : a * u ‚à£ b ‚Üî a ‚à£ b
{p : ‚Ñï} (hp : 1 < p) : padic_norm p ‚Üëp < 1
{R : Type u} [comm_ring R] [hdomain : is_domain R] (r : R) : ratfunc R ‚Üí‚Çê[R] ratfunc R
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] {L : A ‚•§ T} {R : B ‚•§ T} (X Y : category_theory.comma L R) : Type (max v‚ÇÅ v‚ÇÇ)
(h : expr) (ns : name_set) : tactic bool
{p : ‚Ñï+ ‚Üí Sort u_1} (n : ‚Ñï+) (h : Œ† (k : ‚Ñï+), (Œ† (m : ‚Ñï+), m < k ‚Üí p m) ‚Üí p k) : p n
{R : Type u} {A' : Type u_1} {B' : Type u_2} [comm_semiring A'] [semiring B'] [comm_semiring R] [algebra R A'] [algebra R B'] {f g : polynomial A' ‚Üí‚Çê[R] B'} (h‚ÇÅ : f.comp (is_scalar_tower.to_alg_hom R A' (polynomial A')) = g.comp (is_scalar_tower.to_alg_hom R A' (polynomial A'))) (h‚ÇÇ : ‚áëf polynomial.X = ‚áëg polynomial.X) : f = g
{Œπ : Type u_1} {ùïú : Type u_2} [is_R_or_C ùïú] {E : Type u_3} [inner_product_space ùïú E] [cplt : complete_space E] {G : Œπ ‚Üí Type u_4} [Œ† (i : Œπ), inner_product_space ùïú (G i)] {V : Œ† (i : Œπ), G i ‚Üí‚Çó·µ¢[ùïú] E} (hV : orthogonal_family ùïú V) [‚àÄ (i : Œπ), complete_space (G i)] (hV' : (‚®Ü (i : Œπ), (V i).to_linear_map.range).topological_closure = ‚ä§) : E ‚âÉ‚Çó·µ¢[ùïú] ‚Ü•(lp G 2)
 : Type
{Œ± : Type u} [semilattice_sup Œ±] {Œ≤ : Type u_1} [preorder Œ≤] {f g : Œ± ‚Üí Œ≤} (hf : monotone f) (hg : antitone g) (h : f ‚â§ g) (m n : Œ±) : f m ‚â§ g n
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ‚Ñ§] (n : ‚Ñ§) : category_theory.differential_object C ‚•§ category_theory.differential_object C
{R : Type u_1} [comm_ring R] {p : ‚Ñï} (hp : nat.prime p) : polynomial.cyclotomic p R = (finset.range p).sum (Œª (i : ‚Ñï), polynomial.X ^ i)
{R : Type u} [comm_ring R] {G H : Module R} (f : G ‚ü∂ H) : category_theory.limits.mono_factorisation f
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {Œπ : Type u_6} (Z : topological_vector_bundle_core R B F Œπ) (i j : Œπ) : local_homeomorph (B √ó F) (B √ó F)
(Œ± : Type u_1) : Type u_1
{q : ‚Ñï+} : lucas_lehmer.X q
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ‚Ñ§] (X : category_theory.differential_object C) : X.hom X
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [cs : complete_space E] {f : E ‚Üí F} {f' : E ‚âÉL[ùïú] F} {a : E} (hf : has_strict_fderiv_at f ‚Üëf' a) {g : F ‚Üí E} (hg : ‚àÄ·∂† (x : E) in nhds a, g (f x) = x) : has_strict_fderiv_at g ‚Üë(f'.symm) (f a)
 : conv unit
{C : Type u} [category_theory.category C] {P Q : C} (f : P ‚ü∂ Q) [category_theory.mono f] [category_theory.strong_epi f] : category_theory.is_iso f
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] [‚àÄ (n : ‚Ñ§), (category_theory.shift_functor C n).additive] : ùü≠ (category_theory.triangulated.triangle C) ‚ü∂ category_theory.triangulated.inv_rotate C ‚ãô category_theory.triangulated.rotate C
 : submonoid ‚ÑÇ
{Œπ : Type u_1} {Œπ' : Type u_2} {R : Type u_5} {M : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] (b : basis Œπ R M) (b' : basis Œπ' R M) {Œπ'' : Type u_3} [fintype Œπ'] (b'' : Œπ'' ‚Üí M) : (b.to_matrix ‚áëb').mul (b'.to_matrix b'') = b.to_matrix b''
{G : Type u_1} [add_group G] {k : set G} {p : Œ† (x : G), x ‚àà add_subgroup.closure k ‚Üí Prop} (Hs : ‚àÄ (x : G) (h : x ‚àà k), p x _) (H1 : p 0 _) (Hmul : ‚àÄ (x : G) (hx : x ‚àà add_subgroup.closure k) (y : G) (hy : y ‚àà add_subgroup.closure k), p x hx ‚Üí p y hy ‚Üí p (x + y) _) (Hinv : ‚àÄ (x : G) (hx : x ‚àà add_subgroup.closure k), p x hx ‚Üí p (-x) _) {x : G} (hx : x ‚àà add_subgroup.closure k) : p x hx
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (C : homological_complex V c) {i i' j : Œπ} (rij : c.rel i j) (rij' : c.rel i' j) : category_theory.eq_to_hom _ ‚â´ C.d i' j = C.d i j
{Œ± : Type u_2} [monoid Œ±] : monoid (filter Œ±)
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) (n : ‚Ñï) : ‚àÉ (q : ‚Ñö), (generalized_continued_fraction.of v).convergents n = ‚Üëq
{Œπ : Type u} (s : finset Œπ) (f g : Œπ ‚Üí ennreal) {p q : ‚Ñù} (hpq : p.is_conjugate_exponent q) : s.sum (Œª (i : Œπ), f i * g i) ‚â§ s.sum (Œª (i : Œπ), f i ^ p) ^ (1 / p) * s.sum (Œª (i : Œπ), g i ^ q) ^ (1 / q)
{M : Type u_2} [add_comm_group M] {R : Type u_1} : has_involutive_neg (ray_vector R M)
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : Top.presheaf.sheaf_condition_equalizer_products.pi_opens F U ‚ü∂ Top.presheaf.sheaf_condition_equalizer_products.pi_inters F U
(Œ± : Type u) : Type
{R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] (n : ‚Ñï) (ra : is_smul_regular M a) : is_smul_regular M (a ^ n)
(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : valued (ratfunc Fq) (with_zero (multiplicative ‚Ñ§))
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : R ‚Üí+* triv_sq_zero_ext R M
{R : Type u‚ÇÅ} {L : Type u‚ÇÇ} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_nilpotent R L ‚Üî ‚àÄ (x : L), is_nilpotent (‚áë(lie_algebra.ad R L) x)
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x : V} (hx : x ‚â† 0) : hb.oangle (-x) x = ‚Üëreal.pi
{J : Type v} [category_theory.small_category J] (F : J ‚•§ SemiRing) (j : J) : (category_theory.limits.types.limit_cone (F ‚ãô category_theory.forget SemiRing)).X ‚Üí+* (F ‚ãô category_theory.forget SemiRing).obj j
(ùïú : Type u_1) (E : Type u_2) [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] {n : ‚Ñï} (h : n = 1) (v : fin n ‚Üí E) : ‚áë(formal_multilinear_series.id ùïú E n) v = v ‚ü®0, _‚ü©
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} (h : ‚Üës.nonempty) (v : V) : v ‚àà s.direction ‚Üî ‚àÉ (p1 : P) (H : p1 ‚àà s) (p2 : P) (H : p2 ‚àà s), v = p1 -·µ• p2
{Œ± : Type u_1} {Œ≤ : Type u_2} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {K : nnreal} {f : Œ± ‚Üí Œ≤} : (‚àÄ (x y : Œ±), has_nndist.nndist x y ‚â§ K * has_nndist.nndist (f x) (f y)) ‚Üí antilipschitz_with K f
(R : Type u) [semiring R] [nontrivial R] (p q : ‚Ñï) [char_p R p] [exp_char R q] : q = 1 ‚Üî p = 0
{T : Type u‚ÇÅ} [category_theory.category T] {X : T} {U V : category_theory.under X} (f : U.right ‚ü∂ V.right) (w : U.hom ‚â´ f = V.hom . "obviously") : U ‚ü∂ V
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s : set P} (hs : s.nonempty) : affine_span k s = ‚ä§ ‚Üî vector_span k s = ‚ä§
(env : environment) (mi : module_info) : environment
(Œ± : Type u) : Type u
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {c : set Œ±} (hc : is_chain r c) : ‚àÉ (M : set Œ±), is_max_chain r M ‚àß c ‚äÜ M
(K : Type u_1) : Type u_1
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [comm_semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] (f : multilinear_map R M‚ÇÅ M‚ÇÇ) (c : Œπ ‚Üí R) (m : Œ† (i : Œπ), M‚ÇÅ i) (s : finset Œπ) : ‚áëf (s.piecewise (Œª (i : Œπ), c i ‚Ä¢ m i) m) = s.prod (Œª (i : Œπ), c i) ‚Ä¢ ‚áëf m
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (C : homological_complex V c) [category_theory.limits.has_zero_object V] {i : Œπ} (h : c.next i = option.none) : C.X_next i ‚âÖ 0
{E : Type u_1} [add_comm_group E] [module ‚Ñù E] {s : set E} (x : E) : 0 ‚â§ gauge s x
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cone F.op} (P : category_theory.limits.is_limit t) : category_theory.limits.is_colimit t.unop
{K : Type u_1} [field K] (R S : valuation_subring K) (h : R ‚â§ S) : ideal ‚Ü•R
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : category_theory.presieve X} {x : category_theory.presieve.family_of_elements P R} (hx : x.compatible) : x.sieve_extend.compatible
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {F G : C ‚•§ D} (h : F ‚âÖ G) [category_theory.limits.reflects_colimits_of_shape J F] : category_theory.limits.reflects_colimits_of_shape J G
(R‚ÇÅ : Type u_1) [semiring R‚ÇÅ] (M‚ÇÅ : Type u_4) [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] (M‚ÇÇ : Type u_6) [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÅ M‚ÇÇ] : M‚ÇÅ √ó M‚ÇÇ ‚ÜíL[R‚ÇÅ] M‚ÇÅ
{B : Type u_1} {E : B ‚Üí Type u_2} : bundle.total_space E ‚Üí B
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} (h : is_closed s) : interior (frontier s) = ‚àÖ
{R : Type u_1} [comm_ring R] (s : subring R) (m : multiset R) : (‚àÄ (a : R), a ‚àà m ‚Üí a ‚àà s) ‚Üí m.prod ‚àà s
{Œ± : Type u} (s : wseq Œ±) : computation (list Œ±)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) [lie_algebra.is_nilpotent R ‚Ü•H] (M : Type w) [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (œá : lie_algebra.lie_character R ‚Ü•H) : Prop
(Œ± : Type u_2) [preorder Œ±] [mul_one_class Œ±] : Œ± ‚Üí*o Œ±
{Œπ : Type v} [dec_Œπ : decidable_eq Œπ] {Œ≤ : Œπ ‚Üí Type w} [Œ† (i : Œπ), add_comm_monoid (Œ≤ i)] {Œ≥ : Type u‚ÇÅ} [add_comm_monoid Œ≥] : direct_sum Œπ (Œª (i : Œπ), Œ≥ ‚Üí+ Œ≤ i) ‚Üí+ Œ≥ ‚Üí+ direct_sum Œπ (Œª (i : Œπ), Œ≤ i)
(Œ± : Type u) : free_comm_ring Œ± ‚âÉ+* mv_polynomial Œ± ‚Ñ§
{L : first_order.language} {M : Type u_3} [L.Structure M] : first_order.language.Structure.cg L M ‚Üî ‚àÉ (S : set M), S.countable ‚àß ‚áë(first_order.language.substructure.closure L) S = ‚ä§
(Œ± : Type u_8) : Type u_8
 : doc_category ‚Üí string
{s : ‚ÑÇ} (hs : 1 < s.re) : measure_theory.integrable_on (Œª (x : ‚Ñù), ‚Üë(real.exp (-x)) * ‚Üë(real.log x) * ‚Üëx ^ (s - 1)) (set.Ioi 0) measure_theory.measure_space.volume ‚àß has_deriv_at complex.Gamma_integral (‚à´ (x : ‚Ñù) in set.Ioi 0, ‚Üë(real.exp (-x)) * ‚Üë(real.log x) * ‚Üëx ^ (s - 1)) s
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [category_theory.limits.has_pushout f g] : category_theory.limits.has_pushout g f
{R : Type u} {M : Type v} {M‚ÇÇ : Type w} {M‚ÇÉ : Type y} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] (f : M ‚Üí‚Çó[R] M‚ÇÉ) (g : M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÉ) : M √ó M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÉ
{Œ± : Type u} {Œ≤ : Type v} [emetric_space Œ±] [pseudo_emetric_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : isometry f) : embedding f
{M : Type u_3} {N : Type u_4} [monoid M] [monoid N] (f : M ‚Üí* N·µê·µí·µñ) (l : list M) : mul_opposite.unop (‚áëf l.prod) = (list.map (mul_opposite.unop ‚àò ‚áëf) l).reverse.prod
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C] (F : category_theory.limits.walking_parallel_pair ‚•§ C) : category_theory.limits.cone F
 : tactic.ring.horner_expr ‚Üí expr √ó ‚Ñï ‚Üí expr √ó ‚Ñï ‚Üí tactic.ring.horner_expr ‚Üí tactic.ring.ring_m (tactic.ring.horner_expr √ó expr)
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ùïú] [inner_product_space ùïú E] [inner_product_space ùïú F] [complete_space E] [complete_space F] (A : E ‚ÜíL[ùïú] F) (x : E) (y : F) : has_inner.inner x (‚áë(‚áëcontinuous_linear_map.adjoint A) y) = has_inner.inner (‚áëA x) y
{X Y : SemiNormedGroup} (f : X ‚ü∂ Y) : SemiNormedGroup.explicit_cokernel f ‚âÖ category_theory.limits.cokernel f
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [comm_ring R] [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] (v : valuation R Œì‚ÇÄ) {J : ideal R} (hJ : J ‚â§ v.supp) : (v.on_quot hJ).supp = ideal.map (ideal.quotient.mk J) v.supp
{Œ± : Type u_1} [linear_order Œ±] {k l : ‚Ñï} {s : finset Œ±} {i : fin k} {j : fin l} {h : s.card = k} {h' : s.card = l} : ‚áë(s.order_emb_of_fin h) i = ‚áë(s.order_emb_of_fin h') j ‚Üî ‚Üëi = ‚Üëj
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {x : E} {n : with_top ‚Ñï} {s : set E} {f : E ‚Üí F} {g : E ‚Üí G} (hf : cont_diff_within_at ùïú n f s x) (hg : cont_diff_within_at ùïú n g s x) : cont_diff_within_at ùïú n (Œª (x : E), (f x, g x)) s x
{V : Type u} {G : simple_graph V} {u v : V} : G.walk u v ‚Üí list V
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] [category_theory.braided_category C] : CommMon_.equiv_lax_braided_functor_punit.CommMon_to_lax_braided C ‚ãô CommMon_.equiv_lax_braided_functor_punit.lax_braided_to_CommMon C ‚âÖ ùü≠ (CommMon_ C)
 : (submodule.span ‚ÑÇ (set.range fourier)).topological_closure = ‚ä§
{Œπ : Type u_1} (R : Type u_3) {A : Type u_5} (x : Œπ ‚Üí A) [comm_ring R] [comm_ring A] [algebra R A] : Prop
{F : Type u_1} {E : Type u_2} {K : Type u_3} [field F] [field E] [field K] [algebra F E] [algebra F K] {c : set (intermediate_field.lifts F E K)} (hc : is_chain has_le.le c) : ‚Ü•(intermediate_field.lifts.upper_bound_intermediate_field hc) ‚Üí‚Çê[F] K
(R : Type u) [comm_semiring R] (A : Type v‚ÇÅ) [semiring A] [algebra R A] : tensor_product R A R ‚âÉ‚Çê[R] A
{G : Type u_1} [group G] (H : subgroup G) : has_mul ‚Ü•H
{Œ± : Type u_2} [bornology Œ±] (s : set Œ±) : Prop
(R : Type u_1) (E : Type u_5) [semiring R] [semi_normed_group E] [module R E] : E ‚âÉ‚Çó·µ¢[R] E
{G : Type u_1} [group G] : has_bracket G G
{R : Type u} [ring R] {S : Type v} [ring S] (f : R ‚Üí+* S) : subring (polynomial S)
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [add_monoid Œπ] : Type (max u_1 u_2)
{Œ± : Type u} {Œ≤ : Type v} {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} [partial_order Œ≤] [lattice Œ±] (gi : galois_insertion l u) : lattice Œ≤
{Œ± : Type u} [has_zero Œ±] [has_add Œ±] : list Œ± ‚Üí list Œ± ‚Üí list Œ±
{M : Type u_1} [monoid M] (P : submonoid M) : Prop
 : ‚Ñö ‚Üí ‚Ñ§
{Œ± : Type u} {Œ≤ : Type v} [linear_ordered_field Œ±] [topological_space Œ±] [order_topology Œ±] {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±} {C : Œ±} (hC : 0 < C) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_bot) : filter.tendsto (Œª (x : Œ≤), f x * g x) l filter.at_bot
{p : ‚Ñï} [fact (nat.prime p)] : ‚Ñ§_[p] ‚Üí ‚Ñ§_[p]
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] : category_theory.limits.has_finite_biproducts C
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (A B : homological_complex V c) : Type (max u_1 v)
{C : Type u} : category_theory.free_monoidal_category C ‚Üí category_theory.free_monoidal_category.normal_monoidal_object C ‚Üí (category_theory.discrete ‚àò category_theory.free_monoidal_category.normal_monoidal_object) C
{G : Type u} {n : ‚Ñï} [fintype G] [add_group G] (h : (fintype.card G).coprime n) : G ‚âÉ G
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : category_theory.lax_monoidal_functor C (category_theory.monoidal.transported e)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [cs : complete_space E] (f : E ‚Üí F) {f' : E ‚âÉL[ùïú] F} {a : E} (hf : has_strict_fderiv_at f ‚Üëf' a) : local_homeomorph E F
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M ‚Üí+ P} (hg : ‚àÄ (y : ‚Ü•S), is_add_unit (‚áëg ‚Üëy)) (z : N) (w v : P) : ‚áë(f.lift hg) z + w = v ‚Üî ‚áëg (f.sec z).fst + w = ‚áëg ‚Üë((f.sec z).snd) + v
{R : Type u_1} {M : Type u_3} {a b : R} [has_scalar R M] [has_mul R] [is_scalar_tower R R M] : is_smul_regular M (a * b) ‚àß is_smul_regular M (b * a) ‚Üî is_smul_regular M a ‚àß is_smul_regular M b
{n : Type u_1} {R : Type u‚ÇÇ} [decidable_eq n] [comm_ring R] (i j : n) (c : R) : matrix n n R
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : differentiable_on ‚Ñù f (interior D)) (hf'' : ‚àÄ (x : ‚Ñù), x ‚àà interior D ‚Üí deriv^[2] f x < 0) : strict_concave_on ‚Ñù D f
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (m : hash_map Œ± Œ≤) (a : Œ±) : bool
 : first_order.language.order.Theory
(R : Type u) [comm_semiring R] (A : Type v) [semiring A] [algebra R A] (n : Type w) [decidable_eq n] [fintype n] (M : matrix n n A) : tensor_product R A (matrix n n R)
{Œ± : Type u_1} (xs : lazy_list Œ±) : lazy_list Œ±
{Œ± : Type u_1} {m : Type u_3} {n : Type u_4} [non_unital_semiring Œ±] [star_ring Œ±] {A : matrix m m Œ±} {B : matrix m n Œ±} {C : matrix n m Œ±} {D : matrix n n Œ±} (hA : A.is_hermitian) (hBC : B.conj_transpose = C) (hD : D.is_hermitian) : (matrix.from_blocks A B C D).is_hermitian
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [has_inv Œ≤] : has_inv Œ±
{Œ± Œ≤ : Type} {ea : computability.fin_encoding Œ±} {eb : computability.fin_encoding Œ≤} {f : Œ± ‚Üí Œ≤} (h : turing.tm2_computable_in_poly_time ea eb f) : turing.tm2_computable_in_time ea eb f
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f : M ‚Üí+ N) : add_submonoid N
(C : Type u) [category_theory.category C] : Type (max u v)
(K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] {V‚ÇÇ : Type v'} [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] (f : V ‚Üí‚Çó[K] V‚ÇÇ) (p : submodule K V) [finite_dimensional K ‚Ü•p] : finite_dimensional.finrank K ‚Ü•(submodule.map f p) ‚â§ finite_dimensional.finrank K ‚Ü•p
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] : can_lift (Œ± ‚Üí Œ≤) (Œ± ‚Üío Œ≤)
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] (ùíú : Œπ ‚Üí submodule R A) [decidable_eq Œπ] [add_monoid Œπ] [graded_algebra ùíú] : Type u_3
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 p : P} : p -·µ• p1 = p -·µ• p2 ‚Üî p1 = p2
(Œ± : Sort u_1) : Œ± ‚âÉ Œ±
 : expr ‚Üí tactic tactic.interactive.instance_tree
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥} (e : Œ† (c : Œ≥), {a // f a = c} ‚âÉ {b // g b = c}) : Œ± ‚âÉ Œ≤
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] (F : C ‚•§ D) [F.preserves_zero_morphisms] {J : Type v} {f : J ‚Üí C} (b : category_theory.limits.bicone f) : category_theory.limits.bicone (F.obj ‚àò f)
(p : ‚Ñï) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] : fraction_ring (witt_vector p k) ‚Üí+* fraction_ring (witt_vector p k)
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {i : D ‚•§ C} [category_theory.is_right_adjoint i] (A : C) [category_theory.is_iso ((category_theory.adjunction.of_right_adjoint i).unit.app A)] : A ‚àà i.ess_image
{Œ± : Type u} [semilattice_inf Œ±] [order_top Œ±] (x y : Œ±) : (x ‚®Ø y) = x ‚äì y
(ùïú : Type u) {n : ‚Ñï} (Ei : fin n.succ ‚Üí Type wEi) (G : Type wG) [nondiscrete_normed_field ùïú] [Œ† (i : fin n.succ), normed_group (Ei i)] [Œ† (i : fin n.succ), normed_space ùïú (Ei i)] [normed_group G] [normed_space ùïú G] : continuous_multilinear_map ùïú (Œª (i : fin n), Ei (‚áëfin.cast_succ i)) (Ei (fin.last n) ‚ÜíL[ùïú] G) ‚âÉ‚Çó·µ¢[ùïú] continuous_multilinear_map ùïú Ei G
 : tactic unit
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [add_monoid Œπ] [graded_monoid.gmonoid A] : monoid (graded_monoid A)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) [category_theory.is_iso h.unit] : L ‚ãô R ‚ãô L ‚âÖ L
{ùïú : Type u_2} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} {B' : Type u_7} [topological_space B'] [topological_space (bundle.total_space E)] [nondiscrete_normed_field ùïú] [normed_group F] [normed_space ùïú F] [topological_space B] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module ùïú (E x)] {K : Type u_8} [continuous_map_class K B' B] (e : topological_vector_bundle.trivialization ùïú F E) (f : K) : topological_vector_bundle.trivialization ùïú F (‚áëf *·µñ E)
(C : Type u) : Type (u+1)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {X Y Y' : C} [category_theory.exact_pairing X Y'] (i : Y ‚âÖ Y') : category_theory.exact_pairing X Y
{Œ± : Type u_1} (L : list (list Œ±)) (c : composition L.join.length) (h : list.map list.length L = c.blocks) : L.join.split_wrt_composition c = L
{Œ± : Type u_1} {n : Type u_4} {R : Type u_5} [has_sub n] [has_scalar R Œ±] (k : R) (v : n ‚Üí Œ±) : matrix.circulant (k ‚Ä¢ v) = k ‚Ä¢ matrix.circulant v
{Œ± : Type u_1} (m : set Œ± ‚Üí ennreal) : measure_theory.outer_measure Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) (s : set Œ±) (hs : is_open s) : local_homeomorph Œ± Œ≤
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} (v : V) {p : P} (hp : p ‚àà s) : v +·µ• p ‚àà s ‚Üî v ‚àà s.direction
(Œ± : Type u) : add_magma.free_add_semigroup (free_add_magma Œ±) ‚âÉ free_add_semigroup Œ±
 : expr ‚Üí tactic (expr √ó expr)
{Œ± : Type u_2} {Œ≤ : Type u_3} [add_monoid Œ±] [add_action Œ± Œ≤] : add_action (set Œ±) (set Œ≤)
(R : Type u_1) {S : Type u_2} {M : Type u_3} [semiring R] [semiring S] [add_comm_monoid M] [has_scalar R S] [module S M] [module R M] [is_scalar_tower R S M] (h : is_noetherian R M) : is_noetherian S M
{J : Type u‚ÇÅ} [category_theory.category J] [nonempty J] (h : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), ‚àÉ (l : list J), list.chain category_theory.zag j‚ÇÅ l ‚àß (j‚ÇÅ :: l).last _ = j‚ÇÇ) : category_theory.is_connected J
{Œ± : Type u_1} {Œ≤ : Type u_2} [decidable_eq Œ≤] (f : Œ± ‚Üí Œ≤) (s : finset Œ±) : finset Œ≤
{P : Type u_1} [preorder P] [order_bot P] : order_top (order.pfilter P)
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] (L : A ‚•§ T) (R : B ‚•§ T) : category_theory.comma.map_right L (ùüô R) ‚âÖ ùü≠ (category_theory.comma L R)
(R : Type u‚ÇÅ) [comm_semiring R] (p : ‚Ñï) : Type u‚ÇÅ
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] [has_mul Œ±] [has_add Œ≤] [has_mul Œ≤] : Œ± ‚âÉ+* Œ≤ ‚âÉ (Œ±·µê·µí·µñ ‚âÉ+* Œ≤·µê·µí·µñ)
 : turing.to_partrec.cfg ‚Üí option turing.to_partrec.cfg
{R : Type u_1} [comm_semiring R] {m : Type u_3} {n : Type u_4} [fintype n] [decidable_eq n] : ((n ‚Üí R) ‚Üí‚Çó[R] m ‚Üí R) ‚âÉ‚Çó[R] matrix m n R
{Œ± : Type u_1} [has_repr Œ±] : has_repr (generalized_continued_fraction.pair Œ±)
{ùïú : Type u_1} {X : Type u_2} [is_R_or_C ùïú] [topological_space X] [compact_space X] (A : subalgebra ùïú C(X, ùïú)) (hA : A.separates_points) (hA' : continuous_map.conj_invariant_subalgebra (subalgebra.restrict_scalars ‚Ñù A)) : A.topological_closure = ‚ä§
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) (k l : ‚Ñï) (s : finset (fin (k + l))) (hs : s.card = l) : continuous_multilinear_map ùïú (Œª (i : fin l), E) (continuous_multilinear_map ùïú (Œª (i : fin k), E) F)
{Œ± : Type u_1} [uniform_space Œ±] {s : set Œ±} : is_open s ‚Üî ‚àÄ (x : Œ±), x ‚àà s ‚Üí (‚àÉ (V : set (Œ± √ó Œ±)) (H : V ‚àà uniformity Œ±), uniform_space.ball x V ‚äÜ s)
(s : ‚Ñù) : ‚Ñù
{ùïú : Type u_3} [field ùïú] (n : Type) [fintype n] [decidable_eq n] (M : matrix n n ùïú) : ‚àÉ (L L' : list (matrix.transvection_struct n ùïú)) (D : n ‚Üí ùïú), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
(M : Type u) [monoid M] {R : Type v} [ring R] [mul_semiring_action M R] (S : subring R) : Prop
(l : Type u_4) (R : Type u‚ÇÇ) [decidable_eq l] [comm_ring R] [fintype l] [invertible 2] : ‚Ü•(lie_algebra.orthogonal.type_D l R) ‚âÉ‚Çó‚ÅÖR‚ÅÜ ‚Ü•(lie_algebra.orthogonal.so' l l R)
{C : Type u} [category_theory.category C] {R X Y : C} (f : X ‚ü∂ Y) (a b : R ‚ü∂ X) : Type (max u v)
{Œ± : Type u_1} : Œ± ‚âÉ Œ±À¢ ∏·µê
{k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : ‚Ñï} (s : affine.simplex k P n) {fs‚ÇÅ fs‚ÇÇ : finset (fin (n + 1))} {m‚ÇÅ m‚ÇÇ : ‚Ñï} (h‚ÇÅ : fs‚ÇÅ.card = m‚ÇÅ + 1) (h‚ÇÇ : fs‚ÇÇ.card = m‚ÇÇ + 1) : finset.centroid k finset.univ (s.face h‚ÇÅ).points = finset.centroid k finset.univ (s.face h‚ÇÇ).points ‚Üî fs‚ÇÅ = fs‚ÇÇ
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M ‚Üí* P} (H : c ‚â§ con.ker f) : (c.lift f H).mrange = f.mrange
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} [nonempty ‚Ü•s] : nonempty ‚Ü•(affine_span k s)
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J ‚•§ C·µí·µñ) {c : category_theory.limits.cone F.left_op} (hc : category_theory.limits.is_limit c) : category_theory.limits.is_colimit (category_theory.limits.cocone_of_cone_left_op c)
{Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : uniform_continuous (Œª (x : Œ±), metric.inf_dist x s)
{R : Type u_1} (S : Type u_2) [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] (J : ideal S) : J.is_maximal ‚Üî (ideal.comap (algebra_map R S) J).is_maximal ‚àß y ‚àâ ideal.comap (algebra_map R S) J
(s : simp_lemmas √ó list name) (ps : list pexpr) (cfg : auto.auto_config) : auto.case_option ‚Üí tactic unit
{Œ± : Type u_1} (G : simple_graph Œ±) [fintype Œ±] [decidable_eq Œ±] [decidable_rel G.adj] (n : ‚Ñï) : finset (finset Œ±)
 : expr ‚Üí ‚Ñï
{X‚ÇÅ X‚ÇÇ Y : Top} {f : C(‚Ü•X‚ÇÅ, ‚Ü•Y)} {g : C(‚Ü•X‚ÇÇ, ‚Ü•Y)} {x‚ÇÄ x‚ÇÅ : ‚Ü•X‚ÇÅ} {x‚ÇÇ x‚ÇÉ : ‚Ü•X‚ÇÇ} {p : path x‚ÇÄ x‚ÇÅ} {q : path x‚ÇÇ x‚ÇÉ} (hfg : ‚àÄ (t : ‚Ü•unit_interval), ‚áëf (‚áëp t) = ‚áëg (‚áëq t)) : (fundamental_groupoid.fundamental_groupoid_functor.map f).map ‚ü¶p‚üß == (fundamental_groupoid.fundamental_groupoid_functor.map g).map ‚ü¶q‚üß
{Œ± : Type u_1} {c : set (set Œ±)} (H : ‚àÄ (a : Œ±), ‚àÉ! (b : set Œ±) (H : b ‚àà c), a ‚àà b) {s : set Œ±} {y : Œ±} (hs : s ‚àà c) (hy : y ‚àà s) : s = {x : Œ± | (setoid.mk_classes c H).rel x y}
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C·µí·µñ} (f : X ‚âÖ Y) : opposite.unop Y ‚âÖ opposite.unop X
{Œ± : Type u} [inhabited Œ±] : lazy_list Œ± ‚Üí Œ±
 : Pointed ‚•§ Twop
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) [decidable_rel r] [is_trans Œ± r] [is_antisymm Œ± r] [is_total Œ± r] (s : finset Œ±) : list Œ±
{F : Type u_1} [normed_group F] [normed_space ‚Ñù F] (f : ‚Ñù ‚Üí F) {K : set F} (hK : is_complete K) : measurable_set {x : ‚Ñù | differentiable_within_at ‚Ñù f (set.Ici x) x ‚àß deriv_within f (set.Ici x) x ‚àà K}
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_pullbacks C] {X Y : C} (g : X ‚ü∂ Y) (f‚ÇÅ f‚ÇÇ : category_theory.subobject Y) : (category_theory.subobject.pullback g).obj (f‚ÇÅ ‚äì f‚ÇÇ) = (category_theory.subobject.pullback g).obj f‚ÇÅ ‚äì (category_theory.subobject.pullback g).obj f‚ÇÇ
{Œ≤ : Type u} {Œ≥ : Type w} [semiring Œ≤] [semiring Œ≥] (f : Œ≤ ‚Üí+* Œ≥·µê·µí·µñ) (l : list Œ≤) : mul_opposite.unop (‚áëf l.prod) = (list.map (mul_opposite.unop ‚àò ‚áëf) l).reverse.prod
{o : ordinal} : ordinal.principal has_mul.mul o ‚Üî o ‚â§ 2 ‚à® ‚àÉ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a
{K : Type u_1} [field K] [uniform_space K] : uniform_space.completion K ‚Üí uniform_space.completion K
{C : Type u} [category_theory.category C] [category_theory.preadditive C] : C ‚•§ C·µí·µñ ‚•§ AddCommGroup
{R : Type u} {L‚ÇÅ : Type v} {L‚ÇÇ : Type w} (M : Type w‚ÇÅ) [comm_ring R] [lie_ring L‚ÇÅ] [lie_algebra R L‚ÇÅ] [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÇ] [add_comm_group M] [lie_ring_module L‚ÇÇ M] (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : lie_ring_module L‚ÇÅ M
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommMon) : CommMon
(Œ± : expr) : list expr ‚Üí tactic (expr √ó expr)
{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (v : V) : G.degree v ‚â§ G.max_degree
{R : Type u} [ring R] (s : set R) : subring R
(F : Type u_7) (Œ± : out_param (Type u_8)) (Œ≤ : out_param (Type u_9)) [has_inf Œ±] [has_inf Œ≤] : Type (max u_7 u_8 u_9)
(R : Type u_1) [comm_semiring R] (X : Type u_2) : Type (max u_1 u_2)
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (h : b.orientation = o) (Œ∏ : ‚Ñù) : o.rotation ‚ÜëŒ∏ = hb.rotation ‚ÜëŒ∏
{Œ± : Type u_1} {s t : set Œ±} (h : s ‚äÜ t) [decidable_pred (Œª (_x : Œ±), _x ‚àà s)] : ‚Ü•s ‚äï ‚Ü•(t  s) ‚âÉ ‚Ü•t
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [locally_compact_space Œ≤] (f : C(Œ±, C(Œ≤, Œ≥))) : C(Œ± √ó Œ≤, Œ≥)
{Œ± : Type u_2} [add_zero_class Œ±] : Œ± ‚Üí+ set Œ±
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (m : multiset L) : (‚àÄ (a : L), a ‚àà m ‚Üí a ‚àà S) ‚Üí m.prod ‚àà S
{R : Type u} [comm_ring R] [is_domain R] [unique_factorization_monoid R] (h‚ÇÅ : ‚àÉ (p : R), irreducible p) (h‚ÇÇ : ‚àÄ ‚¶Ép q : R‚¶Ñ, irreducible p ‚Üí irreducible q ‚Üí associated p q) : discrete_valuation_ring R
(nondep : interactive.parse (optional (lean.parser.tk "!"))) (first : interactive.parse lean.parser.ident) (names : interactive.parse (lean.parser.many lean.parser.ident)) (tgt : interactive.parse (optional (lean.parser.tk "using" *> interactive.types.texpr))) : tactic unit
{Œ± : Type u} {Œ≤ : Type v} {fa : Œ± ‚Üí Œ±} {fb : Œ≤ ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (h : function.semiconj g fa fb) : set.maps_to g (function.fixed_points fa) (function.fixed_points fb)
{R : Type u} {L : Type v} {M : Type w} {M' : Type w‚ÇÅ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group M'] [module R M'] [lie_ring_module L M'] [lie_module R L M'] (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M') (N' : lie_submodule R L M') : lie_submodule R L M
{Œ± : Type u_1} [linear_ordered_comm_monoid_with_zero Œ±] {Œ≤ : Type u_2} [has_zero Œ≤] [has_one Œ≤] [has_mul Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : linear_ordered_comm_monoid_with_zero Œ≤
(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : ‚àÉ (œñ : R), irreducible œñ
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_binary_coproduct X Y] : X ‚ü∂ X ‚®ø Y
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (left : C ‚•§ D) [category_theory.is_left_adjoint left] : left ‚ä£ category_theory.right_adjoint left
(Œ± : Type u_1) [add_right_cancel_semigroup Œ±] [has_one Œ±] : complex_shape Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : r ‚Ü™r s) (H : function.surjective ‚áëf) : r ‚âÉr s
{Œ± : Type u_1} [measurable_space Œ±] [topological_space Œ±] [opens_measurable_space Œ±] : topological_space (measure_theory.probability_measure Œ±)
(R : Type u) {M : Type v} {M‚ÇÇ : Type w} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] (f : M ‚Üí M‚ÇÇ) : Prop
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (j j' : C) : category_theory.is_cofiltered.min j j' ‚ü∂ j
(R : Type u_1) [comm_semiring R] : ideal R
(n : ‚Ñï) [has_mod ‚Ñï] : tactic unit
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] {a b : Œ±} (ha : 1 ‚â§ a) (hb : 1 ‚â§ b) : 1 ‚â§ a * b
{Œ± : Type u_1} [topological_space Œ±] [t0_space Œ±] [compact_space Œ±] {S : set Œ±} (hS : is_closed S) (hne : S.nonempty) : ‚àÉ (x : Œ±), x ‚àà S ‚àß is_closed {x}
(N : ‚Ñï) {j : ‚Ñù} (hj : 0 < j) {c : ‚Ñù} (hc : 1 < c) : (finset.filter (Œª (i : ‚Ñï), j < ‚Üë‚åäc ^ i‚åã‚Çä) (finset.range N)).sum (Œª (i : ‚Ñï), 1 / ‚Üë‚åäc ^ i‚åã‚Çä ^ 2) ‚â§ c ^ 5 * (c - 1)‚Åª¬π ^ 3 / j ^ 2
(C : Type u_1) [category_theory.category C] [category_theory.monoidal_category C] : category_theory.monoidal_functor (category_theory.End_monoidal (category_theory.monoidal_single_obj.star C)) C
{R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Œπ : Type u_1} (v : Œπ ‚Üí M) (i : linear_independent R v) (w : set M) [fintype ‚Ü•w] (s : submodule.span R w = ‚ä§) : cardinal.mk Œπ ‚â§ ‚Üë(fintype.card ‚Ü•w)
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] {a b : Œ±} : a‚Åª¬π ‚â§ b ‚Üí b‚Åª¬π ‚â§ a
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (f : M ‚Üí‚Çô* N) (hf : ‚àÄ (x y : M), commute (‚áëf x) (‚áëf y)) : M ‚Üí‚Çô* N·µê·µí·µñ
{M : Type u_1} [comm_semigroup M] (c : con M) : comm_semigroup c.quotient
{Œπ : Type u} (s : finset Œπ) {f g : Œπ ‚Üí ‚Ñù} {p q : ‚Ñù} (hpq : p.is_conjugate_exponent q) (hf : ‚àÄ (i : Œπ), i ‚àà s ‚Üí 0 ‚â§ f i) (hg : ‚àÄ (i : Œπ), i ‚àà s ‚Üí 0 ‚â§ g i) : s.sum (Œª (i : Œπ), f i * g i) ‚â§ s.sum (Œª (i : Œπ), f i ^ p) ^ (1 / p) * s.sum (Œª (i : Œπ), g i ^ q) ^ (1 / q)
(F : Type u_6) (Œ± : out_param (Type u_7)) (Œ≤ : out_param (Type u_8)) [bornology Œ±] [bornology Œ≤] : Type (max u_6 u_7 u_8)
{M : Type u_2} [add_comm_group M] {R : Type u_1} : has_neg (ray_vector R M)
{ùïú : Type u_1} [is_R_or_C ùïú] [dec_ùïú : decidable_eq ùïú] {E : Type u_2} [inner_product_space ùïú E] {T : E ‚Üí‚Çó[ùïú] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional ùïú E] {n : ‚Ñï} (hn : finite_dimensional.finrank ùïú E = n) : basis (fin n) ùïú E
 : ‚Ñï ‚Üí list bool
{q : ‚Ñï+} : lucas_lehmer.X q
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : vector_span k {p} = ‚ä•
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Œπ R M) : basis ‚Ü•(set.range ‚áëb) R M
{Œ± : Type u} {a b : Œ±} [mul_zero_one_class Œ±] [partial_order Œ±] [zero_lt.pos_mul_mono Œ±] (ha : a ‚â§ 1) (hb : b ‚â§ 1) (a0 : 0 ‚â§ a) : a * b ‚â§ 1
(R : Type u_1) [comm_ring R] [is_domain R] [is_dedekind_domain R] : Type u_1
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) : Type (max u_1 u_2)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] (F : J ‚•§ C) : category_theory.limits.cocone F ‚âÖ Œ£ (X : C), F.cocones.obj X
(e : expr) (n a : ‚Ñï) : tactic expr
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (p : Œ≤ ‚Üí Prop) (h : ‚àÄ (x : Œ±), p (f x)) : (Œ£ (y : subtype p), {x // f x = ‚Üëy}) ‚âÉ Œ±
{M : Type u_1} [topological_space M] : M ‚âÉ‚Çú M·µÉ·µí·µñ
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_comm_monoid Œ±] [topological_space Œ±] {f : Œ≤ ‚Üí Œ±} {s : finset Œ≤} (hf : ‚àÄ (b : Œ≤), b ‚àâ s ‚Üí f b = 0) : has_sum f (s.sum (Œª (b : Œ≤), f b))
 : tactic bool
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {x : E} {n : with_top ‚Ñï} {p : E ‚Üí formal_multilinear_series ùïú E F} (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ‚â§ n) (hx : s ‚àà nhds x) : differentiable_at ùïú f x
{Œ± : Type u_1} {n : Type u_4} [semiring Œ±] [fintype n] [add_group n] (v w : n ‚Üí Œ±) : (matrix.circulant v).mul (matrix.circulant w) = matrix.circulant ((matrix.circulant v).mul_vec w)
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M ‚Üí+ P} (hg : ‚àÄ (y : ‚Ü•S), is_add_unit (‚áëg ‚Üëy)) (z : N) (v : P) : ‚áë(f.lift hg) z = v ‚Üî ‚áëg (f.sec z).fst = ‚áëg ‚Üë((f.sec z).snd) + v
{X : Top} (U : topological_space.opens ‚Ü•X) : U ‚ü∂ ‚ä§
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : list Œ± ‚Üí Œ± ‚Üí list Œ± ‚Üí Œ≤) : list Œ± ‚Üí list Œ± ‚Üí list Œ≤
{Œ≤ : Type v} {Œ≥ : Type w} {Œ¥ : Type u_2} [topological_space Œ≤] [topological_space Œ≥] [topological_space Œ¥] {R : Type u_1} [semiring R] [non_unital_non_assoc_semiring Œ¥] [topological_semiring Œ¥] [module R Œ¥] [has_continuous_const_smul R Œ¥] (g : cocompact_map Œ≤ Œ≥) : zero_at_infty_continuous_map Œ≥ Œ¥ ‚Üí‚Çô‚Çê[R] zero_at_infty_continuous_map Œ≤ Œ¥
(Œ± : Type u_2) : Type u_2
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_zero_class Œ±] [add_zero_class Œ≤] (f g : Œ±·µê·µí·µñ ‚Üí+ Œ≤) (h : f.comp mul_opposite.op_add_equiv.to_add_monoid_hom = g.comp mul_opposite.op_add_equiv.to_add_monoid_hom) : f = g
{Œπ : Type u} (Œ≤ : Œπ ‚Üí Type v) [Œ† (i : Œπ), has_zero (Œ≤ i)] : Type (max u v)
(hs : expr_set) : tactic (list expr)
 : ‚Ñï ‚Üí name √ó ‚Ñï
(C : Type u) [category_theory.category C] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (P : C·µí·µñ ‚•§ Type w) (R : category_theory.presieve X) : Prop
{Œ± : Type u} (l l' : list Œ±) : Prop
(L : out_param first_order.language) (F : Type u_5) (M : out_param (Type u_6)) (N : out_param (Type u_7)) [fun_like F M (Œª (_x : M), N)] [first_order.language.Structure L M] [first_order.language.Structure L N] : Type
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A ‚ü∂ B) [category_theory.limits.has_images V] [category_theory.epi f] : category_theory.epi (image_to_kernel f 0 _)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : Type (max u‚ÇÅ v‚ÇÅ)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] : continuous (Œª (p : bounded_continuous_function Œ± Œ≤ √ó Œ±), ‚áë(p.fst) p.snd)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] {u v : E} (hv : v ‚àà K) (hvo : u - v ‚àà K·óÆ) : ‚Üë(‚áë(orthogonal_projection K) u) = v
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (i : zmod 2) : submodule R (clifford_algebra Q)
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] [category_theory.monoidal_category C] (F : J ‚•§ Mon_ C) : category_theory.limits.cone F
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : Œπ ‚Üí M} [semiring R] [add_comm_monoid M] [add_comm_monoid M'] [module R M] [module R M'] (hv : linear_independent R v) (f : M ‚Üí‚Çó[R] M') (hf_inj : f.ker = ‚ä•) : linear_independent R (‚áëf ‚àò v)
 : ‚Ü•algebraic_geometry.AffineScheme ‚•§ algebraic_geometry.Scheme
{Œ± : Type u} (xs ys : list Œ±) (h : xs ~ ys) (h' : ys.nodup) : slim_check.injective_function Œ±
{G‚ÇÄ : Type u_2} [measurable_space G‚ÇÄ] [group_with_zero G‚ÇÄ] [has_measurable_mul G‚ÇÄ] (g : G‚ÇÄ) (hg : g ‚â† 0) : G‚ÇÄ ‚âÉ·µê G‚ÇÄ
{m : Type u ‚Üí Type u} [applicative m] {Œ± Œ≤ : Type u} (F : Œ± ‚Üí m Œ≤) : free_magma Œ± ‚Üí m (free_magma Œ≤)
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] {A B : C·µí·µñ} (g : A ‚ü∂ B) : category_theory.limits.kernel g.unop ‚âÖ opposite.unop (category_theory.limits.cokernel g)
(m : Type u ‚Üí Type v) [functor m] [is_lawful_functor m] : Type u ‚•§ Type v
{Œπ : Type u_1} {S : Type u_3} {R : Type u_4} [decidable_eq Œπ] [add_monoid Œπ] [comm_semiring S] [semiring R] [algebra S R] (A : Œπ ‚Üí submodule S R) [set_like.graded_monoid A] : (‚®Ü (i : Œπ), A i) = (direct_sum.coe_alg_hom A).range.to_submodule
{Œ± : Type u_1} {Œ≤ : Type u_2} [preorder Œ≤] [decidable_rel has_lt.lt] (f : Œ± ‚Üí Œ≤) (l : list Œ±) : option Œ±
{Œ± : Type u} [pseudo_metric_space Œ±] (s t : set Œ±) : ‚Ñù
{Œ± : Type u_1} [measurable_space Œ±] : (fin 2 ‚Üí Œ±) ‚âÉ·µê Œ± √ó Œ±
{R : Type u} [comm_ring R] : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ (Algebra R) Ring)
(A : Type y) [add_group A] : A ‚âÉ (‚Ñ§ ‚Üí+ A)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (G : D ‚•§ C) (h : G ‚ä£ F) : F.op ‚ä£ G.op
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : C √ó D ‚•§ D √ó C
{Œ± : Type u_3} {Œ≤ : Type u_4} (r : Œ± ‚Üí Œ≤ ‚Üí Prop) [Œ† (a : Œ±), decidable_pred (r a)] (s : finset Œ±) (t : finset Œ≤) : finset (Œ± √ó Œ≤)
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {s : category_theory.limits.cone F} {G : K ‚•§ C} {t : category_theory.limits.cone G} (P : category_theory.limits.is_limit s) (Q : category_theory.limits.is_limit t) (e : J ‚âå K) (w : e.functor ‚ãô G ‚âÖ F) : s.X ‚âÖ t.X
{R : Type u} [semiring R] {Œπ : Type v} [dec_Œπ : decidable_eq Œπ] {M : Type u_1} [add_comm_monoid M] [module R M] {A : Œπ ‚Üí submodule R M} {i j : Œπ} (hij : i ‚â† j) (h : set.univ = {i, j}) (hi : direct_sum.is_internal A) : is_compl (A i) (A j)
{ùïú : Type u_1} {V : Type u_2} [normed_field ùïú] [add_comm_group V] [module ùïú V] (e : enorm ùïú V) : subspace ùïú V
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [preorder Œ±] [preorder Œ≤] [preorder Œ≥] [mul_one_class Œ±] [mul_one_class Œ≤] [mul_one_class Œ≥] (f : Œ≤ ‚Üí*o Œ≥) (g : Œ± ‚Üí*o Œ≤) : Œ± ‚Üí*o Œ≥
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} [category_theory.limits.has_coequalizer f g] (h : f = g) : category_theory.is_iso (category_theory.limits.coequalizer.œÄ f g)
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : continuous_at f a) (hb : continuous_at f b) : fderiv ‚Ñù (Œª (p : ‚Ñù √ó ‚Ñù), ‚à´ (x : ‚Ñù) in p.fst..p.snd, f x) (a, b) = (continuous_linear_map.snd ‚Ñù ‚Ñù ‚Ñù).smul_right (f b) - (continuous_linear_map.fst ‚Ñù ‚Ñù ‚Ñù).smul_right (f a)
(a : ‚Ñù) {b : ‚Ñù} (h : 0 < b) : measure_theory.integrable_on (Œª (x : ‚Ñù), real.exp (-b * x)) (set.Ioi a) measure_theory.measure_space.volume
{Œ± : Type u_1} {M : Type u_5} [add_zero_class M] : (Œ± ‚Üí‚ÇÄ M) ‚Üí+ Œ± ‚Üí M
{R S : Type u} [semiring R] [semiring S] (f : R ‚Üí+* S) : SemiRing.of R ‚ü∂ SemiRing.of S
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] (S : subalgebra R A) (S‚ÇÅ : subalgebra R B) : subalgebra R (A √ó B)
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] : category_theory.preadditive (category_theory.idempotents.karoubi C)
{E : Type u_5} [semi_normed_group E] {R' : Type u_10} [ring R'] [module R' E] (p : submodule R' E) : ‚Ü•p ‚Üí‚Çó·µ¢[R'] E
{V : Type u} (G : simple_graph V) : Type u
{Œ± : Type u} {Œ≤ : Type v} {C : Œ≤ ‚Üí Sort u_1} (l : list Œ±) (op : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (b : Œ≤) (hb : C b) (hl : Œ† (b : Œ≤), C b ‚Üí Œ† (a : Œ±), a ‚àà l ‚Üí C (op b a)) : C (list.foldl op b l)
{K : Type u_1} [field K] (n : ‚Ñï) : polynomial.splits (ring_hom.id K) (polynomial.cyclotomic' n K)
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] : add_comm_group (P1 ‚Üí·µÉ[k] V2)
 : declaration ‚Üí reducibility_hints
{Œ± : Type u_2} [monoid Œ±] (s : set Œ±) : Prop
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} [category_theory.limits.has_coequalizer f g] : category_theory.epi (category_theory.limits.coequalizer.œÄ f g)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} {R : category_theory.presieve X} (f : Y ‚ü∂ X) [category_theory.split_epi f] (hf : R f) : category_theory.sieve.generate R = ‚ä§
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {r t : category_theory.limits.cocone F} (i : r ‚âÖ t) : category_theory.limits.is_colimit r ‚âÉ category_theory.limits.is_colimit t
{Œ± : Type u} (u : uniform_space.core Œ±) (t : topological_space Œ±) (h : t = u.to_topological_space) : uniform_space Œ±
{Œ± : Type u_1} {Œπ' : Sort u_5} (s : Œπ' ‚Üí set Œ±) : (‚ãÇ (i : Œπ'), s i) = ‚ãÇ (t : finset (plift Œπ')) (i : plift Œπ') (H : i ‚àà t), s i.down
{Œ± : Type u_2} {Œ≤ : Type u_3} [comm_monoid Œ±] [comm_monoid Œ≤] {A : set Œ±} {n : ‚Ñï} : comm_monoid (A ‚Üí*[n] Œ≤)
{R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {Œπ : Type u_6} [decidable_eq Œπ] {M‚ÇÇ : Type u_7} [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] (f : alternating_map R M N Œπ) (g : M‚ÇÇ ‚Üí‚Çó[R] M) : alternating_map R M‚ÇÇ N Œπ
(Œ± : Type u) [uniform_space Œ±] : UniformSpace
{Œ± : Type u} : dlist Œ± ‚Üí dlist Œ± ‚Üí dlist Œ±
(G : Type u_1) [add_group G] : add_torsor G G
{Œ± : Type u_1} {n : ‚Ñï} (v : vector Œ± n) : vector.map id v = v
{R : Type u} {A : Type v} {B : Type w} {C : Type w‚ÇÅ} [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B] [non_unital_non_assoc_semiring C] [distrib_mul_action R C] (f : B ‚Üí‚Çô‚Çê[R] C) (g : A ‚Üí‚Çô‚Çê[R] B) : A ‚Üí‚Çô‚Çê[R] C
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (hfp : algebra.finite_presentation R A) (Œπ : Type u_3) [fintype Œπ] : algebra.finite_presentation R (mv_polynomial Œπ A)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÇ} [category_theory.category C] (X : C) : (category_theory.functor.const J·µí·µñ).obj (opposite.op X) ‚âÖ ((category_theory.functor.const J).obj X).op
{m n k : ‚Ñï} (H : k ‚à£ m * n) : {d // k = ‚Üë(d.fst) * ‚Üë(d.snd)}
[Œ† (P : Prop), decidable P] : functor finset
(M : Type u_3) [mul_one_class M] : Type u_3
 : tactic.interactive.itactic ‚Üí tactic unit
(X : algebraic_geometry.LocallyRingedSpace) : X.restrict _ ‚âÖ X
{Œ± : Type u} (s : set Œ±) [h : fintype ‚Ü•s] : s.finite
{Œ± : Type} [has_to_string Œ±] (p : tactic.rewrite_search.dir_pair Œ±) : string
(p : ‚Ñï) [p_prime : fact (nat.prime p)] {q : ‚Ñö} {n d : ‚Ñ§} (hqz : q ‚â† 0) (qdf : q = rat.mk n d) : padic_val_rat p q = ‚Üë((multiplicity ‚Üëp n).get _) - ‚Üë((multiplicity ‚Üëp d).get _)
(R : Type u_1) [comm_ring R] [nontrivial R] : strong_rank_condition R
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ‚Ü•X) (R : category_theory.presieve U) (f : Œ£ (V : topological_space.opens ‚Ü•X), {f // R f}) : (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom ‚â´ category_theory.limits.pi.œÄ (Œª (i : Œ£ (V : topological_space.opens ‚Ü•X), {f // R f}), F.obj (opposite.op (Top.presheaf.covering_of_presieve U R i))) f = category_theory.limits.pi.œÄ (Œª (f : Œ£ (V : topological_space.opens ‚Ü•X), {f // R f}), F.obj (opposite.op f.fst)) f
{m : Type u_3} {n : Type u_4} {Œ± : Type v} [decidable_eq n] [has_zero Œ±] [has_one Œ±] (f : m ‚âÉ. n) : matrix m n Œ±
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z ‚Üí B) : Prop
{a : Type u} : has_coe_t a (option a)
{Œ± : Type u_1} [normed_field Œ±] {F : Type u_6} [normed_group F] [normed_space Œ± F] : module Œ± F
 : ‚Ü•{‚ä•, ‚ä§}·∂ú ‚âÉ ‚Ñù
(Œ± : Type u_1) : list Œ± ‚âÉ buffer Œ±
{C : Type u} [category_theory.category C] [‚àÄ (n : ‚Ñï) (f : category_theory.arrow C), category_theory.limits.has_wide_pushout f.left (Œª (i : ulift (fin (n + 1))), f.right) (Œª (i : ulift (fin (n + 1))), f.hom)] (F : category_theory.arrow C) (X : category_theory.cosimplicial_object.augmented C) (G : F.augmented_cech_conerve ‚ü∂ X) : F ‚ü∂ category_theory.cosimplicial_object.augmented.to_arrow.obj X
{Œ± : Type u} [linear_ordered_ring Œ±] : Œ± ‚Üí*‚ÇÄ Œ±
(Œ± : Type u) [monoid Œ±] : category_theory.category (category_theory.single_obj Œ±)
{M : Type u_1} {N : Type u_2} [unique M] [unique N] [has_mul M] [has_mul N] : unique (M ‚âÉ* N)
 : expr ‚Üí tactic unit
{R : Type u_1} [comm_semiring R] {R' : Type u_2} [monoid R'] {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] [distrib_mul_action R' M] [has_scalar R' R] [is_scalar_tower R' R M] [distrib_mul_action R' N] [is_scalar_tower R' R N] : tensor_product.compatible_smul R R' M N
(B : Type u) [quiver B] : category_theory.pseudofunctor (category_theory.free_bicategory B) (category_theory.locally_discrete (category_theory.paths B))
(K : Type u) [field K] : Type u
{G : Type u_1} [group G] [hG : group.is_nilpotent G] : nat.find _ = group.nilpotency_class G
{E : Type u} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {a : E} {f' : E ‚ÜíL[‚Ñù] ‚Ñù} {s : set E} (h : is_local_min_on f s a) (hf : has_fderiv_within_at f f' s a) {y : E} (hy : y ‚àà pos_tangent_cone_at s a) (hy' : -y ‚àà pos_tangent_cone_at s a) : ‚áëf' y = 0
{R : Type u_1} {R' : Type u_2} (M : Type u_3) [monoid_with_zero R] [monoid_with_zero R'] [has_zero M] [mul_action_with_zero R M] (f : R' ‚Üí*‚ÇÄ R) : mul_action_with_zero R' M
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {y : L} : y ‚àà S ‚Üí ‚àÄ {x : K}, x ‚Ä¢ y ‚àà S
(J : Type u_1) (C : Type u_2) [category_theory.category J] [category_theory.category C] : category_theory.idempotents.to_karoubi (J ‚•§ C) ‚ãô category_theory.idempotents.karoubi_functor_category_embedding J C = (category_theory.whiskering_right J C (category_theory.idempotents.karoubi C)).obj (category_theory.idempotents.to_karoubi C)
{Œ± : Type u_1} [comm_semiring Œ±] (t : tree Œ±) (r : tactic.ring2.csring_expr) : (tactic.ring2.horner_expr.of_csexpr r).is_cs ‚àß tactic.ring2.horner_expr.cseval t (tactic.ring2.horner_expr.of_csexpr r) = tactic.ring2.csring_expr.eval t r
{C : Type u‚ÇÅ} [category_theory.small_category C] : category_theory.yoneda.op ‚ãô category_theory.coyoneda ‚âÖ category_theory.evaluation C·µí·µñ (Type u‚ÇÅ)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w‚ÇÅ w‚ÇÇ : Œπ ‚Üí k) (p : Œπ ‚Üí P) : ‚áë(s.weighted_vsub p) w‚ÇÅ +·µ• ‚áë(s.affine_combination p) w‚ÇÇ = ‚áë(s.affine_combination p) (w‚ÇÅ + w‚ÇÇ)
(red : interactive.parse (optional (lean.parser.tk "!"))) (loc : interactive.parse interactive.types.location) : tactic unit
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p1 p2 : P} (hp1 : p1 ‚àà s) : (affine_span k (has_insert.insert p2 ‚Üës)).direction = submodule.span k {p2 -·µ• p1} ‚äî s.direction
{Œ± : Type u_1} [has_to_tactic_format Œ±] (x : Œ±) : tactic.pformat
(n : ‚Ñï) : fin (n + 1) ‚âÉ option (fin n)
{Œ± : Type u} {Œ≤ : Type v} [linear_ordered_field Œ±] [topological_space Œ±] [order_topology Œ±] {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±} {C : Œ±} (hC : C < 0) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_bot) : filter.tendsto (Œª (x : Œ≤), f x * g x) l filter.at_top
{Œ± : Type u_2} [division_monoid Œ±] {a : Œ±} (h : is_unit a) : Œ±À£
{s : set ‚ÑÇ} : s.countable ‚Üí (complex.exp ‚Åª¬π' s).countable
{R : Type u} [ring R] {M N : Module R} (f : M ‚ü∂ N) (hf : category_theory.mono f) : category_theory.normal_mono f
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [add_comm_monoid Œπ] [decidable_eq Œπ] [comm_ring R] [comm_ring A] [algebra R A] (ùíú : Œπ ‚Üí submodule R A) [graded_algebra ùíú] (x : ideal A) [x.is_prime] (p : homogeneous_localization.num_denom_same_deg ùíú x) : localization.at_prime x
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ‚ü∂ Q) : category_theory.mono (category_theory.abelian.factor_thru_coimage f)
{Œ± : Type u_1} {n : Type u_4} [has_zero Œ±] [decidable_eq n] (A : matrix n n Œ±) : A.is_diag ‚Üî matrix.diagonal A.diag = A
{ùïú : Type u} {Œπ : Type v} {Œπ' : Type v'} {G : Type wG} {G' : Type wG'} [decidable_eq Œπ] [fintype Œπ] [decidable_eq Œπ'] [fintype Œπ'] [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] [decidable_eq (Œπ ‚äï Œπ')] (f : continuous_multilinear_map ùïú (Œª (x : Œπ ‚äï Œπ'), G) G') : continuous_multilinear_map ùïú (Œª (x : Œπ), G) (continuous_multilinear_map ùïú (Œª (x : Œπ'), G) G')
{Œπ : Type u_1} {Œ± : Type u_2} [has_zero Œ±] (f : Œπ ‚Üí‚ÇÄ Œ±) : Œπ ‚Üí‚ÇÄ finset Œ±
{M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] (f : M ‚Üí+ N) : ‚áëf 0 = 0
{E : Type u_1} [inner_product_space ‚Ñù E] {n : ‚Ñï} [fact (finite_dimensional.finrank ‚Ñù E = n + 1)] : cont_mdiff (model_with_corners_self ‚Ñù (euclidean_space ‚Ñù (fin n))) (model_with_corners_self ‚Ñù (euclidean_space ‚Ñù (fin n))) ‚ä§ (Œª (x : ‚Ü•(metric.sphere 0 1)), -x)
 : omega.int.exprform ‚Üí list expr
{M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M} : (‚àÄ (x : M), x ‚àà l ‚Üí x ‚àà s) ‚Üí l.prod ‚àà s
{G : Type u_7} [add_group G] (L : list G) : L.reverse.sum = -(list.map (Œª (x : G), -x) L).sum
{Œπ : Type u_1} (M : Œπ ‚Üí Type u_2) [Œ† (i : Œπ), monoid (M i)] : Type (max u_1 u_2)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) (a : Œ±) : Prop
{M : Type w} {c f‚ÇÅ f‚ÇÇ : Type u} {r‚ÇÅ r‚ÇÇ : Type v} (r‚ÇÅ' : r‚ÇÅ ‚Üí set M) (r‚ÇÇ' : r‚ÇÇ ‚Üí M ‚Üí M ‚Üí Prop) {n : ‚Ñï} : (first_order.language.mk‚ÇÇ c f‚ÇÅ f‚ÇÇ r‚ÇÅ r‚ÇÇ).relations n ‚Üí (fin n ‚Üí M) ‚Üí Prop
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {n : ‚Ñï} {f : ùïú ‚Üí F} : iterated_deriv (n + 1) f = deriv (iterated_deriv n f)
{X : Type u} [preorder X] {x y : X} (h : x ‚â§ y) : x ‚ü∂ y
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [add_comm_monoid Œ±] [topological_space Œ±] [t2_space Œ±] [encodable Œ≥] [complete_lattice Œ≤] (m : Œ≤ ‚Üí Œ±) (m0 : m ‚ä• = 0) (s : Œ≥ ‚Üí Œ≤) : ‚àë' (i : ‚Ñï), m (‚®Ü (b : Œ≥) (H : b ‚àà encodable.decode‚ÇÇ Œ≥ i), s b) = ‚àë' (b : Œ≥), m (s b)
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [semigroup Œ≤] : semigroup Œ±
{C : Type u} [category_theory.category C] (X Y : C) [category_theory.limits.has_binary_product X Y] : C
{Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : f 1 = 1
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {p : E ‚Üí formal_multilinear_series ùïú E F} {n : ‚Ñï} : has_ftaylor_series_up_to_on ‚Üë(n + 1) f p s ‚Üî (‚àÄ (x : E), x ‚àà s ‚Üí (p x 0).uncurry0 = f x) ‚àß (‚àÄ (x : E), x ‚àà s ‚Üí has_fderiv_within_at (Œª (y : E), p y 0) (p x 1).curry_left s x) ‚àß has_ftaylor_series_up_to_on ‚Üën (Œª (x : E), ‚áë(continuous_multilinear_curry_fin1 ùïú E F) (p x 1)) (Œª (x : E), (p x).shift) s
{L : first_order.language} {Œ± : Type u'} [decidable_eq Œ±] {n : ‚Ñï} : L.bounded_formula Œ± n ‚Üí finset Œ±
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.monoidal_category C] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) [category_theory.is_equivalence F.to_lax_monoidal_functor.to_functor] (X : C) [category_theory.has_right_dual (F.to_lax_monoidal_functor.to_functor.obj X)] : category_theory.has_right_dual X
{C : Type u} [category_theory.category C] [category_theory.preadditive C] (Y : C) : C·µí·µñ ‚•§ Module (category_theory.End Y)
{Œ± : Type u_4} {Œ≤ : Type u_5} [monoid Œ±] [has_mul Œ≤] [mul_action Œ± Œ≤] [is_scalar_tower Œ± Œ≤ Œ≤] [smul_comm_class Œ± Œ≤ Œ≤] : Œ± √ó Œ≤ ‚Üí‚Çô* Œ≤
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÇ] [add_comm_semigroup M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) : add_comm_semigroup M‚ÇÇ
(J : Type v) : (category_theory.limits.wide_pullback_shape J)·µí·µñ ‚âå category_theory.limits.wide_pushout_shape J
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (G : C ‚•§ D) [G.preserves_zero_morphisms] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_cokernel f] [category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f 0) G] : category_theory.limits.is_colimit (category_theory.limits.cofork.of_œÄ (G.map (category_theory.limits.cokernel.œÄ f)) _)
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} : (mvqpf.P F).M Œ± ‚Üí (mvqpf.P F).M Œ±
(Œ≥ : Type u) : list Œ≥ ‚Üí W_type (W_type.list_Œ≤ Œ≥)
(R : Type u_1) {A : Type u_2} [comm_ring R] [star_ring R] [semiring A] [star_ring A] [module R A] [star_module R A] : A ‚âÉ‚Çó‚ãÜ[R] A
(M : Type u_1) [has_one M] : one_hom M M
{Œ± : Type u} {Œ≤ : Type v} [has_add Œ±] [has_add Œ≤] (f : add_hom Œ± Œ≤) : with_zero Œ± ‚Üí+ with_zero Œ≤
{Œ± : Type u} [subsingleton Œ±] (l : filter Œ±) [l.ne_bot] : l = ‚ä§
 : tactic unit
(t : ‚Ñù) : filter.tendsto (Œª (x : ‚Ñù), x * real.log (1 + t / x)) filter.at_top (nhds t)
(h : expr) : tactic expr_set
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ± ‚Üí Œ≤ √ó Œ≥} (hf : continuous f) : continuous (Œª (a : Œ±), (f a).snd)
{Œπ : Type u_1} (p : ‚Ñù) [fact_one_le_p : fact (1 ‚â§ p)] (Œ± : Œπ ‚Üí Type u_3) [fintype Œπ] [Œ† (i : Œπ), metric_space (Œ± i)] : metric_space (pi_Lp p Œ±)
(œÅ : Type u) (m : Type u ‚Üí Type v) (Œ± : Type u) : Type (max u v)
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a : Œ±} : -a ‚â§ 0 ‚Üí 0 ‚â§ a
{G : Type u_1} [group G] {x y : G} : y ‚àà subgroup.closure {x} ‚Üî ‚àÉ (n : ‚Ñ§), x ^ n = y
(M : Type u_1) [fintype M] [has_mul M] : ‚Ñö
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : eqv_gen.setoid r = has_Inf.Inf {s : setoid Œ± | ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, r x y ‚Üí s.rel x y}
{G : Type u_1} [add_group G] (K : add_subgroup G) {l : list G} : (‚àÄ (x : G), x ‚àà l ‚Üí x ‚àà K) ‚Üí l.sum ‚àà K
(ic : tactic.instance_cache) (a b : expr) : tactic (expr √ó expr)
(M‚ÇÄ : Type u_4) : Type u_4
(Œ± : Type u_1) [encodable Œ±] : decidable_pred (Œª (_x : ‚Ñï), _x ‚àà set.range encodable.encode)
(R : Type u_1) [comm_ring R] (c‚ÇÅ c‚ÇÇ : R) : quaternion_algebra R c‚ÇÅ c‚ÇÇ ‚Üí‚Çó[R] R
{Œ± : Type u_1} [has_sizeof Œ±] (s : multiset Œ±) : ‚Ñï
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [wf_dvd_monoid Œ±] [gcd_monoid Œ±] : unique_factorization_monoid Œ±
(C : Type u) [category_theory.category C] : category_theory.essentially_small C ‚Üî small (category_theory.skeleton C) ‚àß category_theory.locally_small C
{T : Type u‚ÇÅ} [category_theory.category T] {Y : T} : category_theory.under.map (ùüô Y) ‚âÖ ùü≠ (category_theory.under Y)
{Œ± : Type u} (xs : list (‚Ñï+ √ó slim_check.gen Œ±)) (pos : 0 < xs.length) : slim_check.gen Œ±
{a b c : ‚Ñ§} (h1 : a % b = c) (h2 : (a - c).nat_abs < b.nat_abs) : a = c
{R : Type u_1} [semiring R] [nontrivial R] : power_series.X.order = 1
{M : Type u_2} [add_comm_group M] {A : Type u_1} [comm_ring A] [module A M] (f : M ‚âÉ‚Çó[A] M) : ‚áëlinear_map.det ‚Üë(f.symm) * ‚áëlinear_map.det ‚Üëf = 1
(R : Type u) [comm_ring R] (X : Type v) [ring X] [algebra R X] : Algebra R
{n : ‚Ñï} {i : fin (n + 1)} : simplex_category.Œ¥ (‚áëfin.cast_succ i) ‚â´ simplex_category.œÉ i = ùüô (simplex_category.mk n)
{C : Type u‚ÇÅ} [category_theory.category C] (e : C ‚âå C) : ‚Ñ§ ‚Üí (C ‚âå C)
{F : Type u_1} [field F] [fintype F] [decidable_eq F] : F ‚Üí*‚ÇÄ ‚Ñ§
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÇ] [has_zero M‚ÇÇ] [add_zero_class M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (one : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) : add_zero_class M‚ÇÇ
(in_tag : tactic.tag) (num_arguments : ‚Ñï) : tactic.interactive.case_tag
(major_premise : expr) : tactic tactic.eliminate.major_premise_info
{C : Type u‚ÇÅ} [category_theory.category C] {P : C·µí·µñ ‚•§ Type w} (J : category_theory.grothendieck_topology C) {P' : C·µí·µñ ‚•§ Type w} (i : P ‚âÖ P') (h : category_theory.presieve.is_sheaf J P) : category_theory.presieve.is_sheaf J P'
 : linter
{Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≥ : Type u_5} [lattice Œ±] [lattice Œ≤] [lattice Œ≥] (f : lattice_hom Œ≤ Œ≥) (g : lattice_hom Œ± Œ≤) : lattice_hom Œ± Œ≥
{K : Type u_1} [is_R_or_C K] : K ‚âÉ‚Çê[‚Ñù] K
{X : Type u_1} [topological_space X] (F : set X) (x y : X) : Prop
{T : Type u} [category_theory.category T] (i : category_theory.arrow T) {X Y : T} (p : X ‚âÖ Y) (sq : i ‚ü∂ category_theory.arrow.mk p.hom) : i.hom ‚â´ sq.right ‚â´ p.inv = sq.left
{n : ‚Ñï} {a : cardinal} (h : n ‚â† 0) : n ‚Ä¢ a < cardinal.aleph_0 ‚Üî a < cardinal.aleph_0
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] {f g : Œ± ‚Üí Œ≤} {a : Œ±} (h : f =·∂†[nhds a] g) : ‚àÄ·∂† (y : Œ±) in nhds a, f =·∂†[nhds y] g
{R : Type u_3} [semiring R] {S : Type u_4} [semiring S] {R‚ÇÇ : Type u_5} [semiring R‚ÇÇ] {S‚ÇÇ : Type u_6} [semiring S‚ÇÇ] {M : Type u_7} {N : Type u_8} {P : Type u_9} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module S N] [module R‚ÇÇ P] [module S‚ÇÇ P] [smul_comm_class S‚ÇÇ R‚ÇÇ P] {œÅ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÅ‚ÇÇ : S ‚Üí+* S‚ÇÇ} (f : M ‚Üí‚Çõ‚Çó[œÅ‚ÇÅ‚ÇÇ] N ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] P) (q : submodule S N) : M ‚Üí‚Çõ‚Çó[œÅ‚ÇÅ‚ÇÇ] ‚Ü•q ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] P
{Œ± : Type u} (cmd : ‚Ñï ‚Üí slim_check.gen Œ±) : slim_check.gen Œ±
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] (K : nnreal) (f : Œ± ‚Üí Œ≤) (s : set Œ±) : Prop
(env : environment) (mi : module_info) (decl_name : name) : environment
(X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] : isometry (Gromov_Hausdorff.optimal_GH_injl X Y)
(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] (n : ‚Ñï) : Type u_3
{Œ± : Type u_1} {Œ≤ : Type u_2} : list Œ± ‚Üí list Œ≤ ‚Üí list (Œ± √ó option Œ≤)
{Œ± : Type u_2} {Œπ : Type u_5} [add_comm_monoid Œ±] (t : finset Œπ) (f : Œπ ‚Üí set Œ±) (g : Œπ ‚Üí Œ±) (hg : ‚àÄ (i : Œπ), i ‚àà t ‚Üí g i ‚àà f i) : t.sum (Œª (i : Œπ), g i) ‚àà t.sum (Œª (i : Œπ), f i)
(pre : name) (e : expr) : name_set
{C : Type u} [category_theory.category C] {O : C} (hO : category_theory.limits.is_zero O) : category_theory.limits.has_zero_morphisms C
(Œ± : Type u) [decidable_eq Œ±] (Œ≤ : Œ± ‚Üí Type v) : Type (max u v)
(R : Type u_1) (M : Type u_2) [ring R] [add_comm_group M] [module R M] (x : M) : (R ‚ß∏ ideal.torsion_of R M x) ‚âÉ‚Çó[R] ‚Ü•(submodule.span R {x})
{C : Type u} [category_theory.category C] (T : category_theory.monad C) : category_theory.category (category_theory.kleisli T)
(c : tactic.ring.cache) (a : tactic.ring.horner_expr) (x n : expr √ó ‚Ñï) (b : tactic.ring.horner_expr) : tactic.ring.horner_expr
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b c : Œ±} : a + b < c ‚Üí b < -a + c
{F : Type u ‚Üí Type u} [functor F] [q : qpf F] (x : F (qpf.fix F)) : qpf.fix F
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C·µí·µñ ‚•§ D·µí·µñ} (Œ± : F.unop ‚ü∂ G.unop) : G ‚ü∂ F
(R : Type u‚ÇÅ) [comm_semiring R] (p : ‚Ñï) [hp : fact (nat.prime p)] [char_p R p] : subsemiring (‚Ñï ‚Üí R)
{Œπ : Type u_1} {R : Type u_3} {K : Type u_4} {M : Type u_5} {v : Œπ ‚Üí M} [semiring R] [add_comm_monoid M] [module R M] [semiring K] [smul_with_zero R K] [module K M] [is_scalar_tower R K M] (hinj : function.injective (Œª (r : R), r ‚Ä¢ 1)) (li : linear_independent K v) : linear_independent R v
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] (J : category_theory.grothendieck_topology C) [category_theory.limits.has_products A] [category_theory.limits.has_pullbacks C] (P : C·µí·µñ ‚•§ A) : Prop
{k : Type u_2} {V1 : Type u_3} {P1 : Type u_4} [comm_ring k] [add_comm_group V1] [add_torsor V1 P1] [module k V1] (c : P1) : k ‚Üí·µÉ[k] P1 ‚Üí·µÉ[k] P1
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] {x : E} {s : set E} : star_convex ùïú x s ‚Üî ‚àÄ ‚¶Éa b : ùïú‚¶Ñ, 0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí a + b = 1 ‚Üí a ‚Ä¢ {x} + b ‚Ä¢ s ‚äÜ s
{R' : Type u_1} [semiring R'] {s : set R'} (hcomm : ‚àÄ (a : R'), a ‚àà s ‚Üí ‚àÄ (b : R'), b ‚àà s ‚Üí a * b = b * a) : comm_semiring ‚Ü•(subsemiring.closure s)
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí Œ± ‚Üí Œ±
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {L‚ÇÇ : Type w} [lie_ring L‚ÇÇ] [lie_algebra R L‚ÇÇ] (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : L ‚Üí‚Çó‚ÅÖR‚ÅÜ ‚Ü•(f.range)
{Œ± : Type} (t : tactic Œ±) : tactic Œ±
{E : Type u_1} {F : Type u_2} [inner_product_space ‚Ñù E] [inner_product_space ‚Ñù F] {f : E ‚Üí F} {x : E} : conformal_at f x ‚Üî ‚àÉ (c : ‚Ñù), 0 < c ‚àß ‚àÄ (u v : E), has_inner.inner (‚áë(fderiv ‚Ñù f x) u) (‚áë(fderiv ‚Ñù f x) v) = c * has_inner.inner u v
{E : Type u} [normed_group E] [normed_space ‚Ñù E] [complete_space E] (f f' : ‚Ñù ‚Üí E) {a b : ‚Ñù} (hle : a ‚â§ b) {s : set ‚Ñù} (hs : s.countable) (Hc : continuous_on f (set.Icc a b)) (Hd : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b  s ‚Üí has_deriv_at f (f' x) x) (Hi : interval_integrable f' measure_theory.measure_space.volume a b) : ‚à´ (x : ‚Ñù) in a..b, f' x = f b - f a
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] (proj : Z ‚Üí B) : Type (max u_2 u_3 u_4)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [cs : complete_space E] (f : E ‚Üí F) {f' : E ‚âÉL[ùïú] F} (s : set E) {c : nnreal} (hf : approximates_linear_on f ‚Üëf' s c) (hc : subsingleton E ‚à® c < ‚à•‚Üë(f'.symm)‚à•‚Çä‚Åª¬π) (hs : is_open s) : local_homeomorph E F
{Œ± : Type u_2} [preorder Œ±] (p : Œ± ‚Üí Prop) : subtype p ‚Ü™o Œ±
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddCommGroup) : AddCommGroup
{R : Type u} [ring R] {J : Type w} [category_theory.category J] (F : J ‚•§ Module R) : category_theory.limits.cocone F
{V : Type u_1} [inner_product_space ‚Ñù V] {x y : V} : inner_product_geometry.angle x y = real.pi ‚Üî x ‚â† 0 ‚àß ‚àÉ (r : ‚Ñù), r < 0 ‚àß y = r ‚Ä¢ x
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] {D : J ‚•§ T.algebra} (c : category_theory.limits.cocone (D ‚ãô T.forget)) (t : category_theory.limits.is_colimit c) [category_theory.limits.preserves_colimit (D ‚ãô T.forget) ‚ÜëT] (j : J) : ‚ÜëT.map (c.Œπ.app j) ‚â´ category_theory.monad.forget_creates_colimits.lambda c t = (D.obj j).a ‚â´ c.Œπ.app j
{Œ± : Type u_1} (M : Type u_2) (R : Type u_5) [semiring R] [add_comm_monoid M] [module R M] (s : set Œ±) : (Œ± ‚Üí‚ÇÄ M) ‚Üí‚Çó[R] ‚Ü•(finsupp.supported M R s)
(Œ± : Type u_1) (R : Type u_2) [topological_space Œ±] [topological_space R] [semiring R] [topological_semiring R] : subsemiring (Œ± ‚Üí R)
 : onote ‚Üí string
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (a : S) : ‚àÉ (b : ‚Ü•M), is_localization.is_integer R (a * ‚áë(algebra_map R S) ‚Üëb)
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : is_scalar_tower K ‚Ü•S L
{n : ‚Ñï} {A : Type u} (F : A ‚Üí typevec n ‚Üí Type u) [Œ† (Œ± : A), mvfunctor (F Œ±)] [Œ† (Œ± : A), mvqpf (F Œ±)] : mvpfunctor n
{Œ± : Type u_1} [circular_preorder Œ±] {a b c : Œ±} : has_btw.btw a b c ‚Üî has_btw.btw c a b
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : function.surjective ‚áë(S.normed_mk)
(ùïú : Type u_1) {E : Type u_2} [semi_normed_ring ùïú] [has_scalar ùïú E] (s : set E) : set E
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.preadditive C] : Type (max (v‚ÇÅ+1) u‚ÇÅ)
(n : ‚Ñï) [has_zero (fin n)] : model_with_corners ‚Ñù (euclidean_space ‚Ñù (fin n)) (euclidean_half_space n)
{n : ‚Ñï} : order_of (dihedral_group.r 1) = n
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] (P : C) : ‚ä•_ C ‚®ø P ‚âÖ P
{Œ± : Type u_1} {Œ≤ : Type u_2} [nontrivial Œ≤] {f : Œ± ‚Üí Œ≤} (hf : function.surjective f) : nontrivial Œ±
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [gcd_monoid Œ±] {m n k : Œ±} (H : k ‚à£ m * n) : ‚àÉ (d‚ÇÅ : Œ±) (hd‚ÇÅ : d‚ÇÅ ‚à£ m) (d‚ÇÇ : Œ±) (hd‚ÇÇ : d‚ÇÇ ‚à£ n), k = d‚ÇÅ * d‚ÇÇ
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : dense s ‚Üí dense (closure s)
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : category_theory.category (C √ó D)
 : declaration ‚Üí tactic format
{Œ± : Type u_1} (s : finset Œ±) : s.powerset.card = 2 ^ s.card
(J : Type v‚ÇÅ) [category_theory.small_category J] {C : Type u‚ÇÅ} [category_theory.category C] {F : J ‚•§ C} (c‚ÇÅ c‚ÇÇ : category_theory.limits.cone F) : category_theory.bicone J ‚•§ C
(x y c : bool) : bool
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ‚Ü•X) (R : category_theory.presieve U) (hR : category_theory.sieve.generate R ‚àà ‚áë(opens.grothendieck_topology ‚Ü•X) U) : (category_theory.limits.cones.postcompose (Top.presheaf.covering_of_presieve.diagram_nat_iso F U R).hom).obj (category_theory.limits.fork.of_Œπ (category_theory.presheaf.fork_map R F) _) ‚âÖ Top.presheaf.sheaf_condition_equalizer_products.fork F (Top.presheaf.covering_of_presieve U R)
 : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {G : category_theory.comonad C} {A B : G.coalgebra} (h : A.A ‚âÖ B.A) (w : A.a ‚â´ ‚ÜëG.map h.hom = h.hom ‚â´ B.a) : A ‚âÖ B
{ùïÇ : Type u_1} {ùî∏ : Type u_2} [nondiscrete_normed_field ùïÇ] [normed_comm_ring ùî∏] [normed_algebra ùïÇ ùî∏] [complete_space ùî∏] [char_zero ùïÇ] {x : ùî∏} (hx : x ‚àà emetric.ball 0 (exp_series ùïÇ ùî∏).radius) : has_strict_fderiv_at (exp ùïÇ) (exp ùïÇ x ‚Ä¢ 1) x
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_zero_object C] [category_theory.limits.has_kernel f] [category_theory.mono f] : category_theory.limits.kernel.Œπ f = 0
{Œ± : Type u_1} [monoid Œ±] {a u : Œ±} (hu : is_unit u) : u ‚à£ a
{Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} {Œπ' : Type u_3} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : filter Œπ} (hf : ‚àÄ (i : Œπ), measurable (f i)) {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí set Œπ} (hu : u.has_countable_basis p s) (hs : ‚àÄ (i : Œπ'), (s i).countable) : measurable (Œª (x : Œ¥), u.limsup (Œª (i : Œπ), f i x))
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : C √ó C √ó C ‚•§ C
(S : set ‚Ñï+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [h : number_field K] [fintype ‚Ü•S] [is_cyclotomic_extension S K L] : number_field L
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_semiring A] [algebra R A] (S T : subalgebra R A) : S.to_submodule * T.to_submodule = (S ‚äî T).to_submodule
{G : Type u_1} [add_group G] : ‚Ü•‚ä§ ‚âÉ+ G
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x : M} [no_zero_smul_divisors R M] (h : same_ray R x (-x)) : x = 0
(hs : expr_set) : tactic (list expr)
{Œ± : Type u_1} {Œπ : Type u_4} (p : Œπ ‚Üí Prop) (s : Œπ ‚Üí set Œ±) : Prop
{n : ‚Ñï} {Œ± : Type u_1} [preorder Œ±] {f : fin (n + 1) ‚Üí Œ±} : antitone f ‚Üî ‚àÄ (i : fin n), f i.succ ‚â§ f (‚áëfin.cast_succ i)
{Œ≤ : Type w} {C : Type u} [category_theory.category C] (f : Œ≤ ‚Üí C) : Prop
 : Type (u_1+1)
(M : Type u_1) [monoid_with_zero M] : is_square 0
{Œ± : Type} (msg : thunk string) (p : parser Œ±) : parser Œ±
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : module.rank K V < cardinal.aleph_0) : (basis.of_vector_space_index K V).finite
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÉ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÑ : X‚ÇÉ ‚ü∂ Y‚ÇÇ) [category_theory.limits.has_pullback f‚ÇÅ f‚ÇÇ] [category_theory.limits.has_pullback f‚ÇÉ f‚ÇÑ] [category_theory.limits.has_pullback (category_theory.limits.pullback.snd ‚â´ f‚ÇÉ) f‚ÇÑ] : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk category_theory.limits.pullback.fst (category_theory.limits.pullback.lift (category_theory.limits.pullback.fst ‚â´ category_theory.limits.pullback.snd) category_theory.limits.pullback.snd _) _)
{M : Type u_1} [comm_monoid M] (S : submonoid M) : ‚Ü•(S.left_inv) ‚Üí* ‚Ü•S
{Œ± : Type u} [linear_ordered_add_comm_monoid Œ±] {Œ≤ : Type u_1} [has_zero Œ≤] [has_add Œ≤] [has_scalar ‚Ñï Œ≤] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (one : f 0 = 0) (mul : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : linear_ordered_add_comm_monoid Œ≤
{R : Type u_1} {a : R} [monoid R] {n : ‚Ñï} (n0 : 0 < n) : is_regular (a ^ n) ‚Üî is_regular a
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (P : category_theory.mono_over Y) (f : X ‚ü∂ Y) : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] [category_theory.braided_category D] : ùü≠ (CommMon_ (C ‚•§ D)) ‚âÖ category_theory.monoidal.CommMon_functor_category_equivalence.functor ‚ãô category_theory.monoidal.CommMon_functor_category_equivalence.inverse
(R : Type u‚ÇÅ) (L : Type u‚ÇÇ) [comm_ring R] [lie_ring L] [lie_algebra R L] : tensor_algebra R L ‚Üí tensor_algebra R L ‚Üí Prop
{C : Type u‚ÇÅ} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A
{X : Top} {T : ‚Ü•X ‚Üí Type v} (P : Top.local_predicate T) (x : ‚Ü•X) (w : ‚àÄ (t : T x), ‚àÉ (U : topological_space.open_nhds x) (f : Œ† (y : ‚Ü•(U.val)), T ‚Üëy) (h : P.to_prelocal_predicate.pred f), f ‚ü®x, _‚ü© = t) : function.surjective (Top.stalk_to_fiber P x)
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [fintype Œπ] [decidable_eq Œπ] [Œ† (i : Œπ), decidable_eq (Œ± i)] (r : Œ† (i : Œπ), Œ± i ‚Üí finset (Œ± i) ‚Üí Prop) (H_ex : ‚àÄ (i : Œπ) (s : finset (Œ± i)), s.nonempty ‚Üí (‚àÉ (x : Œ± i) (H : x ‚àà s), r i x (s.erase x))) {p : (Œ† (i : Œπ), finset (Œ± i)) ‚Üí Prop} (f : Œ† (i : Œπ), finset (Œ± i)) (h0 : p (Œª (_x : Œπ), ‚àÖ)) (step : ‚àÄ (g : Œ† (i : Œπ), finset (Œ± i)) (i : Œπ) (x : Œ± i), r i x (g i) ‚Üí p g ‚Üí p (function.update g i (has_insert.insert x (g i)))) : p f
{E : Type u} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {a : E} {f' : E ‚ÜíL[‚Ñù] ‚Ñù} {s : set E} (h : is_local_max_on f s a) (hf : has_fderiv_within_at f f' s a) {y : E} (hy : y ‚àà pos_tangent_cone_at s a) : ‚áëf' y ‚â§ 0
{J : Type u‚ÇÅ} [category_theory.category J] [nonempty J] (h : ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚•§ category_theory.discrete Œ±) (j j' : J), F.obj j = F.obj j') : category_theory.is_connected J
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {A B : C} (f : A ‚ü∂ B) (F : C ‚•§ D) [category_theory.is_iso (F.map f)] [category_theory.reflects_isomorphisms F] : category_theory.is_iso f
 : Set ‚Üí Set ‚Üí Set
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} {V‚ÇÇ : Type u_5} {P‚ÇÇ : Type u_6} [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] {p : Œπ ‚Üí P} (f : P ‚Üí·µÉ[k] P‚ÇÇ) (hai : affine_independent k (‚áëf ‚àò p)) : affine_independent k p
(u : level) : name_set
{J : Type v} {C : Type u} [category_theory.category C] (B : C) (objs : J ‚Üí C) (arrows : Œ† (j : J), B ‚ü∂ objs j) [category_theory.limits.has_wide_pushout B objs arrows] : C
{G : Type u_1} {H : Type u_2} {M : Type u_3} [group G] [group H] [monoid M] [mul_action G M] [smul_comm_class G M M] [mul_action H M] [smul_comm_class H M M] [is_scalar_tower G M M] [is_scalar_tower H M M] [smul_comm_class G H M] : smul_comm_class G H MÀ£
{R : Type u} [non_assoc_semiring R] {s : set R} {t : subsemiring R} : subsemiring.closure s ‚â§ t ‚Üî s ‚äÜ ‚Üët
{E : Type u_2} [normed_group E] [normed_space ‚Ñù E] {s t : set E} (hs‚ÇÅ : convex ‚Ñù s) (hs‚ÇÇ : is_open s) (ht : convex ‚Ñù t) (disj : disjoint s t) : ‚àÉ (f : E ‚ÜíL[‚Ñù] ‚Ñù) (u : ‚Ñù), (‚àÄ (a : E), a ‚àà s ‚Üí ‚áëf a < u) ‚àß ‚àÄ (b : E), b ‚àà t ‚Üí u ‚â§ ‚áëf b
{Œ± : Sort u} {Œ≤ : Sort v} [decidable_eq Œ±] (f : Œ± ‚âÉ Œ≤) (a : Œ±) (b : Œ≤) : Œ± ‚âÉ Œ≤
{ùïú : Type u_1} {E : Type u_2} [normed_field ùïú] [semi_normed_group E] [normed_space ùïú E] {x : E} {s : set E} (hs : metric.bounded s) {u : set E} (hu : u ‚àà nhds x) : ‚àÄ·∂† (r : ùïú) in nhds 0, {x} + r ‚Ä¢ s ‚äÜ u
{R : Type u_1} [normed_ring R] [complete_space R] (x : RÀ£) (n : ‚Ñï) : ‚àÄ·∂† (t : R) in nhds 0, ring.inverse (‚Üëx + t) = (finset.range n).sum (Œª (i : ‚Ñï), (-‚Üëx‚Åª¬π * t) ^ i) * ‚Üëx‚Åª¬π + (-‚Üëx‚Åª¬π * t) ^ n * ring.inverse (‚Üëx + t)
{Œ± : Type u} [topological_space Œ±] [t1_space Œ±] [‚àÄ (x : Œ±), (nhds_within x {x}·∂ú).ne_bot] {s : set Œ±} (hs : dense s) (t : finset Œ±) : dense (s  ‚Üët)
{ùïú : Type u_1} [field ùïú] {M : Type u_2} [add_comm_group M] [module ùïú M] : ‚áëlinear_map.det 0 = 0 ^ finite_dimensional.finrank ùïú M
(C : Type u_1) (D : Type u_2) [category_theory.category C] [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] : (C ‚•§+ D) ‚•§ C ‚•§ D
{Œ± : Type u_1} {m : set Œ± ‚Üí ennreal} {m_empty : m ‚àÖ = 0} {s t : set Œ±} (h : ‚àÄ (u : set Œ±), (s ‚à© u).nonempty ‚Üí (t ‚à© u).nonempty ‚Üí m u = ‚ä§) : ‚áë(measure_theory.outer_measure.of_function m m_empty) (s ‚à™ t) = ‚áë(measure_theory.outer_measure.of_function m m_empty) s + ‚áë(measure_theory.outer_measure.of_function m m_empty) t
{G : Type u_1} [group G] (s : set G) : set G
{E : Type u_1} {F : Type u_2} {ùïú : Type u_3} {ùïú‚ÇÇ : Type u_4} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} [ring_hom_isometric œÉ‚ÇÅ‚ÇÇ] [complete_space E] [t2_space F] (g : ‚Ñï ‚Üí (E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F)) {f : E ‚Üí F} (h : filter.tendsto (Œª (n : ‚Ñï) (x : E), ‚áë(g n) x) filter.at_top (nhds f)) : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_initial C] [category_theory.limits.preserves_colimit (category_theory.functor.empty C) G] : category_theory.limits.has_initial D
{m : Type u_6} {n : Type u_7} [fintype m] [fintype n] {R : Type u_1} [comm_ring R] [nontrivial R] (e : (m ‚Üí R) ‚âÉ‚Çó[R] n ‚Üí R) : m ‚âÉ n
(Œ± : Type u_1) [monoid Œ±] : Œ±À£ ‚âÉ {p // p.fst * p.snd = 1 ‚àß p.snd * p.fst = 1}
{M : Type u_1} [add_zero_class M] {c : add_con M} : function.surjective ‚áë(c.mk')
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] [category_theory.normal_mono_category C] (f : X ‚ü∂ Y) [category_theory.mono f] : category_theory.normal_mono f
(R : Type u_1) (V : Type u_2) [semiring R] [add_comm_group V] [module R V] : ‚Ñï
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ‚•§ D) [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.enough_injectives C] {X Y : C} (f : X ‚ü∂ Y) (P : category_theory.InjectiveResolution X) (Q : category_theory.InjectiveResolution Y) : F.map f ‚â´ category_theory.abelian.functor.right_derived_zero_to_self_app_inv F Q = category_theory.abelian.functor.right_derived_zero_to_self_app_inv F P ‚â´ (F.right_derived 0).map f
{R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} [comm_semiring R] [semiring A‚ÇÅ] [semiring A‚ÇÇ] [algebra R A‚ÇÅ] [algebra R A‚ÇÇ] (e : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ) : A‚ÇÅ ‚Üí‚Çó[R] A‚ÇÇ
{m : Type u ‚Üí Type u} [applicative m] {Œ± Œ≤ : Type u} (F : Œ± ‚Üí m Œ≤) (x : free_semigroup Œ±) : m (free_semigroup Œ≤)
{Œ± : Type u_1} [B : bornology Œ±] (m : metric_space Œ±) (H : ‚àÄ (s : set Œ±), bornology.is_bounded s ‚Üî bornology.is_bounded s) : metric_space Œ±
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s t : set Œ±} (ht : is_antichain r t) (h : minimals r s ‚äÜ t) (hs : ‚àÄ ‚¶Éa : Œ±‚¶Ñ, a ‚àà t ‚Üí (‚àÉ (b : Œ±) (H : b ‚àà minimals r s), r a b)) : minimals r s = t
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] {D : J ‚•§ T.algebra} : (D ‚ãô T.forget) ‚ãô ‚ÜëT ‚ü∂ D ‚ãô T.forget
{Œπ : Type u_1} (p : ‚Ñù) [fact_one_le_p : fact (1 ‚â§ p)] (Œ≤ : Œπ ‚Üí Type u_4) [Œ† (i : Œπ), pseudo_emetric_space (Œ≤ i)] [fintype Œπ] : pseudo_emetric_space (pi_Lp p Œ≤)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} (C : homological_complex V c) [category_theory.limits.has_zero_object V] (i : Œπ) : C.X i ‚ü∂ C.X_next i
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí ordnode Œ± √ó ordnode Œ±
{G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s)
{K : Type u_1} [field K] (A : valuation_subring K) : Type u_1
{Œ± : Type u} {Œ≤ : Type v} {fa : Œ± ‚Üí Œ±} {fb : Œ≤ ‚Üí Œ≤} {x : Œ±} (hx : function.is_fixed_pt fa x) {g : Œ± ‚Üí Œ≤} (h : function.semiconj g fa fb) : function.is_fixed_pt fb (g x)
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} (h : f = g) : category_theory.limits.is_colimit (category_theory.limits.id_cofork h)
(F : Type u ‚Üí Type v) [functor F] : Type (max (u+1) v)
{K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : ‚Ñï) : ‚Üën ‚â§ a ^ n / (a - 1)
(C : Type u) [category_theory.category C] : Prop
{Œ± : Type u_1} {Œ±' : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_5} {Œ¥ : Type u_7} [decidable_eq Œ±'] [decidable_eq Œ≥] [decidable_eq Œ¥] {s : finset Œ±} {t : finset Œ≤} {f : Œ±' ‚Üí Œ≤ ‚Üí Œ≥} {g : Œ± ‚Üí Œ±'} {f' : Œ≤ ‚Üí Œ± ‚Üí Œ¥} {g' : Œ¥ ‚Üí Œ≥} (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤), f (g a) b = g' (f' b a)) : finset.image‚ÇÇ f (finset.image g s) t = finset.image g' (finset.image‚ÇÇ f' t s)
{C : Type u‚ÇÅ} [category_theory.category C] {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B) [category_theory.mono f] [category_theory.mono g] (i : A‚ÇÅ ‚âÖ A‚ÇÇ) (w : i.hom ‚â´ g = f) : category_theory.subobject.mk f = category_theory.subobject.mk g
{Œ± : Type u_1} [order.frame Œ±] {s : set Œ±} : s.pairwise_disjoint id ‚Üí complete_lattice.set_independent s
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {ps : set P} {n : ‚Ñï} [finite_dimensional ‚Ñù V] (hd : finite_dimensional.finrank ‚Ñù V = n) (hc : euclidean_geometry.cospherical ps) : ‚àÉ (c : P), ‚àÄ (sx : affine.simplex ‚Ñù P n), set.range sx.points ‚äÜ ps ‚Üí sx.circumcenter = c
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≤‚ÇÅ : Œ± ‚Üí Type u_3} (F : Œ† (a : Œ±), Œ≤‚ÇÅ a ‚âÉ Œ≤) : sigma Œ≤‚ÇÅ ‚âÉ Œ± √ó Œ≤
{œÑ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ≤] (f : filter œÑ) (œï : œÑ ‚Üí Œ± ‚Üí Œ≤) (s : set Œ±) [t2_space Œ≤] {c : set Œ≤} (hc‚ÇÅ : is_compact c) (hc‚ÇÇ : ‚àÄ·∂† (t : œÑ) in f, set.maps_to (œï t) s c) {n : set Œ≤} (hn‚ÇÅ : is_open n) (hn‚ÇÇ : omega_limit f œï s ‚äÜ n) : ‚àÉ (u : set œÑ) (H : u ‚àà f), closure (set.image2 œï u s) ‚äÜ n
 : tactic.unify_equations.unification_step
{Œ± Œ≤ : Type} (ea : computability.fin_encoding Œ±) (eb : computability.fin_encoding Œ≤) (f : Œ± ‚Üí Œ≤) : Type 1
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] [decidable_rel disjoint] [decidable_rel has_le.le] {s : finset Œ±} {u v a : Œ±} : a ‚àà uv.compression u v s ‚Üî a ‚àà s ‚àß uv.compress u v a ‚àà s ‚à® a ‚àâ s ‚àß ‚àÉ (b : Œ±) (H : b ‚àà s), uv.compress u v b = a
{Œ± : Type u_1} : list Œ± ‚Üí rbmap ‚Ñï Œ± has_lt.lt
(R : Type u_1) (M : Type u_9) [semiring R] [add_comm_monoid M] [module R M] : Type u_9
{F : pfunctor} {X : Type w} (f : X ‚Üí F.obj X) (i : X) (n : ‚Ñï) : pfunctor.approx.cofix_a F n
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [semi_normed_group E] [normed_space ùïú E] (s : set E) : set (weak_dual ùïú E)
(R : Type u_1) (A : Type u_2) (M : Type u_3) (N : Type u_4) (P : Type u_5) [comm_semiring R] [comm_semiring A] [algebra R A] [add_comm_monoid M] [module R M] [module A M] [is_scalar_tower R A M] [add_comm_monoid N] [module R N] [add_comm_monoid P] [module R P] [module A P] [is_scalar_tower R A P] : tensor_product R (tensor_product A M P) N ‚âÉ‚Çó[A] tensor_product A M (tensor_product R P N)
{E : Type u} [normed_group E] [normed_space ‚Ñù E] {f : E ‚Üí ‚Ñù} {a : E} {s : set E} (h : is_local_min_on f s a) {y : E} (hy : y ‚àà pos_tangent_cone_at s a) (hy' : -y ‚àà pos_tangent_cone_at s a) : ‚áë(fderiv_within ‚Ñù f s a) y = 0
{Œ≤ : Type w} {C : Type u} [category_theory.category C] (f : Œ≤ ‚Üí C) : Type (max w u v)
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} {Œ≤ : Type u_1} (Q : Œ≤ ‚Üí Prop) (u v : Œ≤ ‚Üí mvqpf.cofix F Œ±) (h : ‚àÄ (x : Œ≤), Q x ‚Üí (‚àÉ (a : (mvqpf.P F).A) (f' : ((mvqpf.P F).drop.B a).arrow Œ±) (f‚ÇÄ f‚ÇÅ : (mvqpf.P F).last.B a ‚Üí mvqpf.cofix F Œ±), (u x).dest = mvqpf.abs ‚ü®a, (mvqpf.P F).append_contents f' f‚ÇÄ‚ü© ‚àß (v x).dest = mvqpf.abs ‚ü®a, (mvqpf.P F).append_contents f' f‚ÇÅ‚ü© ‚àß ‚àÄ (i : (mvqpf.P F).last.B a), ‚àÉ (x' : Œ≤), Q x' ‚àß f‚ÇÄ i = u x' ‚àß f‚ÇÅ i = v x')) (x : Œ≤) : Q x ‚Üí u x = v x
{Œ± : Type u_1} (f : Œ± ‚Üí Œ±) : list Œ± ‚Üí list Œ±
{R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (s : set M) (li : linear_independent R coe) (t : finset ‚Ü•s) : linear_independent R coe
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w‚ÇÅ w‚ÇÇ : Œπ ‚Üí k) (p : Œπ ‚Üí P) : ‚áë(s.affine_combination p) w‚ÇÅ -·µ• ‚áë(s.affine_combination p) w‚ÇÇ = ‚áë(s.weighted_vsub p) (w‚ÇÅ - w‚ÇÇ)
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] : ‚Ü•(set.range sum.inl) ‚âÉ·µê Œ±
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] (s : wseq Œ±) : wseq ‚Ñï
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Type (max u‚ÇÅ v‚ÇÅ)
{C : Type u} [category_theory.category C] {P Q R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R) [category_theory.strong_epi (f ‚â´ g)] : category_theory.strong_epi g
(Œ± : Type u_1) : ‚Ñï
{p : ‚ÑÇ √ó ‚ÑÇ} (hp_fst : 0 < p.fst.re ‚à® p.fst.im ‚â† 0) : continuous_at (Œª (x : ‚ÑÇ √ó ‚ÑÇ), x.fst ^ x.snd) p
(Œ± : Type u) [topological_space Œ±] : Prop
 : real.cos (real.pi / 3) = 1 / 2
{Œ± : Type u_1} (R : Œ± ‚Üí Œ± ‚Üí Prop) : list Œ± ‚Üí Prop
{S : Type v} (s : S) {R : Type u_1} [ring R] [is_domain R] [set_like S R] [subring_class S R] : is_domain ‚Ü•s
(n : ‚Ñï) (p : fin (n + 1)) : finset.univ = finset.cons p (finset.map p.succ_above.to_embedding finset.univ) _
{E : Type u_1} {F : Type u_2} [inner_product_space ‚Ñù E] [inner_product_space ‚Ñù F] {f : E ‚Üí F} {x : E} {f' : E ‚ÜíL[‚Ñù] F} (h : has_fderiv_at f f' x) (H : conformal_at f x) (u v : E) : inner_product_geometry.angle (‚áëf' u) (‚áëf' v) = inner_product_geometry.angle u v
{A : Type u_1} [comm_ring A] [algebra ‚Ñö A] (a b : A) : ‚áë(power_series.rescale a) (power_series.exp A) * ‚áë(power_series.rescale b) (power_series.exp A) = ‚áë(power_series.rescale (a + b)) (power_series.exp A)
{Œ± : Type u_2} {Œ≤ : Type u_3} [add_monoid Œ±] [add_monoid Œ≤] [topological_space Œ±] [topological_space Œ≤] (f : continuous_add_monoid_hom Œ± Œ≤) : C(Œ±, Œ≤)
(a b : ‚Ñï) : a ^ 2 - b ^ 2 = (a + b) * (a - b)
{k : Type u_1} {l : Type u_2} {m : Type u_3} {n : Type u_4} {Œ± : Type v} [fintype n] [fintype k] [decidable_eq n] [decidable_eq k] [decidable_eq m] [semiring Œ±] (a : m) (b : n) (c : k) (M : matrix k l Œ±) : (pequiv.single a b).to_matrix.mul ((pequiv.single b c).to_matrix.mul M) = (pequiv.single a c).to_matrix.mul M
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] (e : M ‚âÉ‚Çó[R] N) : ray_vector R M ‚âÉ ray_vector R N
 : expr ‚Üí tactic (expr √ó expr)
{Œ± : Type u} (f : (Œ± ‚Üí ‚Ñï) ‚Üí. ‚Ñï) : Prop
{Œ± : Type u} {Œπ : Type v} [metric_space Œ±] [proper_space Œ±] {c : Œπ ‚Üí Œ±} {s : set Œ±} {r : Œπ ‚Üí ‚Ñù} (hr : ‚àÄ (i : Œπ), 0 < r i) (hs : is_closed s) (uf : ‚àÄ (x : Œ±), x ‚àà s ‚Üí {i : Œπ | x ‚àà metric.ball (c i) (r i)}.finite) (us : s ‚äÜ ‚ãÉ (i : Œπ), metric.ball (c i) (r i)) : ‚àÉ (r' : Œπ ‚Üí ‚Ñù), (s ‚äÜ ‚ãÉ (i : Œπ), metric.ball (c i) (r' i)) ‚àß ‚àÄ (i : Œπ), r' i ‚àà set.Ioo 0 (r i)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {F : C ‚•§ D} [category_theory.creates_colimit K F] {c : category_theory.limits.cocone (K ‚ãô F)} (t : category_theory.limits.is_colimit c) : category_theory.limits.is_colimit (category_theory.lift_colimit t)
{Œ± : Type u} : tactic.ref Œ± ‚Üí Œ± ‚Üí tactic unit
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [field Œ≤] : field Œ±
{G : Type u_1} [group G] (h : subgroup.center G = ‚ä§) : comm_group G
{Œπ : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] [topological_space R] [nonempty Œπ] {B : Œπ ‚Üí submodule R M} (hB : submodules_basis B) : topological_space M
{G : Type u_1} [group G] (f‚ÇÅ f‚ÇÇ : G ‚Üí* circle_deg1_lift) (h : ‚àÄ (g : G), (‚áëf‚ÇÅ g).translation_number = (‚áëf‚ÇÇ g).translation_number) : ‚àÉ (F : circle_deg1_lift), ‚àÄ (g : G), function.semiconj ‚áëF ‚áë(‚áëf‚ÇÅ g) ‚áë(‚áëf‚ÇÇ g)
(q : interactive.parse interactive.types.texpr) : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_comm_monoid M] [decidable_eq Œ±] [decidable_eq Œ≤] (s : finset (Œ± √ó Œ≤)) (f : Œ± √ó Œ≤ ‚Üí M) : finsum (Œª (ab : Œ± √ó Œ≤), finsum (Œª (h : ab ‚àà s), f ab)) = finsum (Œª (a : Œ±), finsum (Œª (b : Œ≤), finsum (Œª (h : b ‚àà finset.image prod.snd (finset.filter (Œª (ab : Œ± √ó Œ≤), ab.fst = a) s)), f (a, b))))
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) : setoid (Mon.colimits.prequotient F)
{a : Prop} {b : Sort v} (h‚ÇÅ : a) (h‚ÇÇ : ¬¨a) : b
{Œ± : Type u_1} [topological_space Œ±] [t2_space Œ±] (s : topological_space.compact_opens Œ±) : topological_space.clopens Œ±
{G : Type u_1} [add_group G] {H : add_subgroup G} {N : Type u_3} [add_group N] (f : G ‚Üí+ N) : add_subgroup.map f H.normalizer ‚â§ (add_subgroup.map f H).normalizer
(ùïú : Type u_1) {E : Type u_2} [semi_normed_ring ùïú] [has_scalar ùïú E] (s : set E) : set E
{Œ± : Type u_2} {Œ≤ : Type u_3} {f : Œ± ‚Üí Œ≤} (hf : function.injective f) : filter.comap f filter.cofinite = filter.cofinite
{Œ± : Type u_1} {Œ≤ : Type u_2} {l : filter Œ±} (p : Œ≤ ‚Üí Prop) (f : l.germ Œ≤) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [fintype Œ±] [fintype Œ≤] [comm_monoid M] (e : Œ± ‚Üí Œ≤) (he : function.bijective e) (f : Œ± ‚Üí M) (g : Œ≤ ‚Üí M) (h : ‚àÄ (x : Œ±), f x = g (e x)) : finset.univ.prod (Œª (x : Œ±), f x) = finset.univ.prod (Œª (x : Œ≤), g x)
{Œ± : Type u_1} {m0 : measurable_space Œ±} (s : set Œ±) : measure_theory.measure Œ± ‚Üí‚Çó[ennreal] measure_theory.measure Œ±
{R : Type u} {F : tropical R ‚Üí Sort v} (h : Œ† (X : R), F (tropical.trop X)) (X : tropical R) : F X
 : expr ‚Üí binder_info
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] (f : P1 ‚Üí·µÉ[k] P2) : f.to_fun = ‚áëf
{Œ± : Type u_1} (C : set (set Œ±)) : Prop
 : snum ‚Üí snum
{Œ± : Type u_1} [pseudo_metric_space Œ±] (r C : ‚Ñù) (hr : r < 1) {f : ‚Ñï ‚Üí Œ±} (hu : ‚àÄ (n : ‚Ñï), has_dist.dist (f n) (f (n + 1)) ‚â§ C * r ^ n) {a : Œ±} (ha : filter.tendsto f filter.at_top (nhds a)) : has_dist.dist (f 0) a ‚â§ C / (1 - r)
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {R : Type u_1} [semiring k] [monoid G] [semiring R] (f : k ‚Üí+* R) (g : G ‚Üí* R) (h_comm : ‚àÄ (x : k) (y : G), commute (‚áëf x) (‚áëg y)) : monoid_algebra k G ‚Üí+* R
{Œ± : Type u_1} (d : measurable_space.dynkin_system Œ±) (h_inter : ‚àÄ (s‚ÇÅ s‚ÇÇ : set Œ±), d.has s‚ÇÅ ‚Üí d.has s‚ÇÇ ‚Üí d.has (s‚ÇÅ ‚à© s‚ÇÇ)) : measurable_space Œ±
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] [category_theory.faithful G] : category_theory.compatible_preserving K G
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] {A B C : matrix n n Œ±} (h : B.mul A = 1) (g : C.mul A = 1) : B = C
{E : Type u_3} [semi_normed_group E] (x : E) : E ‚âÉ·µ¢ E
{Œπ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (c : complex_shape Œπ) (i : Œπ) : homological_complex V c ‚•§ V
{C : Type u_1} [category_theory.category C] {F : C ‚•§ category_theory.Cat} (X : category_theory.grothendieck F) : X.hom X
(k : Type u‚ÇÅ) {G : Type u‚ÇÇ} [semiring k] [has_add G] {A : Type u‚ÇÉ} [non_unital_non_assoc_semiring A] [distrib_mul_action k A] {œÜ‚ÇÅ œÜ‚ÇÇ : add_monoid_algebra k G ‚Üí‚Çô‚Çê[k] A} (h : ‚àÄ (x : G), ‚áëœÜ‚ÇÅ (finsupp.single x 1) = ‚áëœÜ‚ÇÇ (finsupp.single x 1)) : œÜ‚ÇÅ = œÜ‚ÇÇ
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {Œπ : Type u_2} [decidable_eq Œπ] {E : Œπ ‚Üí Type u_3} [Œ† (i : Œπ), normed_group (E i)] [Œ† (i : Œπ), normed_space ùïú (E i)] {s : Œ† (i : Œπ), set (E i)} {x : Œ† (i : Œπ), E i} {i : Œπ} (hi : ‚àÄ (j : Œπ), j ‚â† i ‚Üí x j ‚àà closure (s j)) : set.maps_to ‚áë(linear_map.single i) (tangent_cone_at ùïú (s i) (x i)) (tangent_cone_at ùïú (set.univ.pi s) x)
{R : Type u_1} [comm_semiring R] {m : Type u_3} {n : Type u_4} [fintype n] [decidable_eq n] [fintype m] [decidable_eq m] {M : matrix m n R} {M' : matrix n m R} (hMM' : M.mul M' = 1) (hM'M : M'.mul M = 1) : (m ‚Üí R) ‚âÉ‚Çó[R] n ‚Üí R
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} {C‚ÇÅ C‚ÇÇ : homological_complex V c} [category_theory.limits.has_zero_object V] (f : C‚ÇÅ.hom C‚ÇÇ) (i : Œπ) : category_theory.arrow.mk (C‚ÇÅ.d_from i) ‚ü∂ category_theory.arrow.mk (C‚ÇÇ.d_from i)
(R : Type u_1) (M : Type u_2) [ring R] [topological_space R] [topological_space M] [add_comm_group M] [has_continuous_add M] [module R M] [has_continuous_smul R M] [nontrivial M] [(nhds_within 0 {0}·∂ú).ne_bot] [no_zero_smul_divisors R M] (x : M) : (nhds_within x {x}·∂ú).ne_bot
(X : Top) : topological_space.opens ‚Ü•X ‚•§ Top
 : tactic.eliminate.constructor_argument_naming_rule
{Œ± : Sort u} {Œ≤ : Sort v} [unique Œ≤] (e : Œ± ‚âÉ Œ≤) : unique Œ±
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} {Œ≤ : Type u} (g : Œ≤ ‚Üí P.obj (Œ± ::: Œ≤)) : Œ≤ ‚Üí P.M Œ±
(_x : interactive.parse (lean.parser.tk "#explode")) : lean.parser unit
{Œπ : Type u_1} {ùïú : Type u_2} [is_R_or_C ùïú] {E : Type u_3} [inner_product_space ùïú E] [cplt : complete_space E] {G : Œπ ‚Üí Type u_4} [Œ† (i : Œπ), inner_product_space ùïú (G i)] {V : Œ† (i : Œπ), G i ‚Üí‚Çó·µ¢[ùïú] E} (hV : orthogonal_family ùïú V) [‚àÄ (i : Œπ), complete_space (G i)] (hV' : (‚®Ü (i : Œπ), (V i).to_linear_map.range).topological_closure = ‚ä§) {i : Œπ} (x : G i) : ‚áë((hV.linear_isometry_equiv hV').symm) (lp.single 2 i x) = ‚áë(V i) x
{Œ± : Type u_1} (q : semiquot Œ±) {s : set Œ±} (h : q.s ‚äÜ s) : semiquot Œ±
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] [Œ† (i : Œπ), decidable_eq (M i)] [decidable_eq Œπ] (i : Œπ) : free_product.word M ‚âÉ free_product.word.pair M i
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Œπ ‚Üí M} [ring R] [add_comm_group M] [module R M] {hli : linear_independent R v} {hsp : submodule.span R (set.range v) = ‚ä§} {i j : Œπ} (h : j ‚â† i) : ‚áë((basis.mk hli hsp).coord i) (v j) = 0
 : user_attribute unit (bool √ó option name)
{X Y : Top} {f g : C(‚Ü•X, ‚Ü•Y)} (H : f.homotopy g) (x : ‚Ü•X) : ‚ü¶H.eval_at x‚üß = continuous_map.homotopy.hcast _ ‚â´ (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I unit_interval.uhpath01 (ùüô x)) ‚â´ continuous_map.homotopy.hcast _
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) (a : Œ±) : Prop
(X : Type u) [topological_space X] (x : X) : Type u
 : snum ‚Üí bool
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] (h : Œ± ‚âÉ·µ§ Œ≤) : Œ≤ ‚Üí Œ±
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : add_submonoid.closure ‚ÜëS = S
{Œ± : Type u_1} [inhabited Œ±] : semiquot Œ±
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_limits C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_limits D] (G : C ‚•§ D) [category_theory.limits.preserves_limits G] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) : G.map_cone (Top.presheaf.sheaf_condition_equalizer_products.fork F U) ‚âÖ (category_theory.limits.cones.postcompose (Top.presheaf.sheaf_condition.diagram_comp_preserves_limits G F U).inv).obj (Top.presheaf.sheaf_condition_equalizer_products.fork (F ‚ãô G) U)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_equalizer f g] [category_theory.limits.preserves_limit (category_theory.limits.parallel_pair f g) G] : category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ (G.map (category_theory.limits.equalizer.Œπ f g)) _)
{C : Type u} [category_theory.category C] {Œπ : Type u_1} {s : Œπ ‚Üí C} [category_theory.preadditive C] [category_theory.limits.has_finite_biproducts C] {R : Type u_2} [semiring R] [category_theory.linear R C] (o : category_theory.hom_orthogonal s) {Œ± Œ≤ : Type v} [fintype Œ±] [fintype Œ≤] {f : Œ± ‚Üí Œπ} {g : Œ≤ ‚Üí Œπ} : ((‚®Å Œª (a : Œ±), s (f a)) ‚ü∂ ‚®Å Œª (b : Œ≤), s (g b)) ‚âÉ‚Çó[R] Œ† (i : Œπ), matrix ‚Ü•(g ‚Åª¬π' {i}) ‚Ü•(f ‚Åª¬π' {i}) (category_theory.End (s i))
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.abelian C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (ex : category_theory.exact f g) [category_theory.epi g] : category_theory.is_iso (category_theory.limits.cokernel.desc f g _)
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_neg M‚ÇÇ] [has_involutive_neg M‚ÇÅ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.surjective f) (inv : ‚àÄ (x : M‚ÇÅ), f (-x) = -f x) : has_involutive_neg M‚ÇÇ
{Œπ : Type w} [fintype Œπ] (K : Type u) {L : Type v} (E : Type z) [field K] [field L] [field E] [algebra K L] [algebra K E] [module.finite K L] [is_alg_closed E] (b : Œπ ‚Üí L) [decidable_eq Œπ] [is_separable K L] (e : Œπ ‚âÉ (L ‚Üí‚Çê[K] E)) : ‚áë(algebra_map K E) (algebra.discr K b) = (algebra.embeddings_matrix_reindex K E b e).det ^ 2
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] : category_theory.lax_monoidal_functor (category_theory.discrete punit) C ‚âå Mon_ C
(C : Type u) [ùíû : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_pullbacks C
{H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s}
{V : Type u} [quiver V] {a b c : V} : quiver.path a b ‚Üí quiver.path b c ‚Üí quiver.path a c
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] {f g : bounded_continuous_function Œ± Œ≤} (x : Œ±) : has_dist.dist (‚áëf x) (‚áëg x) ‚â§ has_dist.dist f g
{Œ± : Type u} {Œ≤ : Type v} (f : filter Œ±) (g : filter Œ≤) : filter (Œ± √ó Œ≤)
(a : expr) : tactic.ring_exp.ring_exp_m tactic.ring_exp.atom
{R : Type v} [comm_ring R] {M‚ÇÅ : Type u_3} {M‚ÇÇ : Type u_4} [add_comm_group M‚ÇÅ] [module R M‚ÇÅ] [add_comm_group M‚ÇÇ] [module R M‚ÇÇ] (e : M‚ÇÅ ‚âÉ‚Çó[R] M‚ÇÇ) : module.End R M‚ÇÅ ‚âÉ‚Çê[R] module.End R M‚ÇÇ
{Œπ : Type u_1} {R : Type u_2} (S : Type u_3) {M : Œπ ‚Üí Type u_4} {N : Type u_5} [dec_Œπ : decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M i)] [Œ† (i : Œπ), module R (M i)] [add_comm_monoid N] [module R N] [semiring S] [module S N] [smul_comm_class R S N] : (Œ† (i : Œπ), M i ‚Üí‚Çó[R] N) ‚âÉ‚Çó[S] (Œ†‚ÇÄ (i : Œπ), M i) ‚Üí‚Çó[R] N
(M : Type u_1) (N : Type u_2) [monoid M] [monoid N] : Type (max u_2 u_1)
(C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size C
(K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : finset V) : finite_dimensional K ‚Ü•(submodule.span K ‚Üës)
{K : Type u_4} {V : Type u} [division_ring K] [add_comm_group V] [module K V] {s : set V} (hs : linear_independent K coe) : basis ‚Ü•(hs.extend _) K V
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] {c : add_con M} {f : N ‚Üí+ M} : add_con.comap ‚áëf _ c = add_con.ker (c.mk'.comp f)
{G : Type u} [group G] (B : group_filter_basis G) : G ‚Üí filter G
(R : Type u_1) [linear_ordered_field R] [floor_ring R] {b : ‚Ñï} (hb : 1 < b) : galois_insertion (Œª (r : ‚Ü•(set.Ioi 0)), int.clog b ‚Üër) (Œª (z : ‚Ñ§), ‚ü®‚Üëb ^ z, _‚ü©)
 : turing.to_partrec.cont ‚Üí list ‚Ñï ‚Üí. list ‚Ñï
(Œ± : Type u) : category_theory.presieve Œ±
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] (f : A ‚Üí‚Çê[R] B) (hf : function.injective ‚áëf) : A ‚âÉ‚Çê[R] ‚Ü•(f.range)
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (alg : algebra.is_algebraic K L) : subalgebra K L ‚âÉo intermediate_field K L
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : v.int_valuation_def 0 = 0
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ (v‚ÇÇ+1))
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {s t : set Œ±} (hst : disjoint s t) (hs : s.finite) (ht : t.finite) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s ‚à™ t), f i)) = finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)) + finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà t), f i))
{Œ± : Type} (p : lean.parser Œ±) [p.reflectable] : Type
{R : Type u_1} {m : Type u_3} {n : Type u_4} {Œ± : Type u_5} [fintype m] [fintype n] [normed_field R] [semi_normed_group Œ±] [normed_space R Œ±] : normed_space R (matrix m n Œ±)
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (f : spectral_map Œ≤ Œ≥) (g : spectral_map Œ± Œ≤) : spectral_map Œ± Œ≥
{Œ± : Type u_1} {a b c : Œ±} [linear_order Œ±] [add_comm_semigroup Œ±] [has_sub Œ±] [has_ordered_sub Œ±] : a < b - c ‚Üî a + c < b
{Œ± : Type u} (Œ≤ : Œ± ‚Üí Type (max u v)) [fin_enum Œ±] [Œ† (a : Œ±), fin_enum (Œ≤ a)] : list (Œ† (a : Œ±), Œ≤ a)
 : ‚Ñï √ó ‚Ñï ‚âÉ ‚Ñï
 : Type
(n : name) (fr : option name) : tactic name
(M : Type u) [monoid M] (F : Type v) [field F] [mul_semiring_action M F] : subfield F
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space F] (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ‚ä§) (hker : f'.ker.closed_complemented) : F ‚Üí ‚Ü•(f'.ker) ‚Üí E
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {Œπ : Type w} {p : Œπ ‚Üí submodule K V} (hp : complete_lattice.independent p) : fintype {i // p i ‚â† ‚ä•}
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (X : category_theory.simplicial_object C) (n : ‚Ñï) : X.obj (opposite.op (simplex_category.mk (n + 1))) ‚ü∂ X.obj (opposite.op (simplex_category.mk n))
{Œ± : Type u} : Œ± ‚Üí Œ±·µÉ·µí·µñ
{G : Type u_1} [add_group G] {H : add_subgroup G} {A : Type u_2} [add_comm_group A] (œï : ‚Ü•H ‚Üí+ A) (S T : ‚Ü•(add_subgroup.left_transversals ‚ÜëH)) [fintype (G ‚ß∏ H)] : A
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ‚Ñù P) : t.orthocenter ‚àà affine_span ‚Ñù (set.range t.points)
{Œ≤ : Type u_1} [add_comm_group Œ≤] (b : Œ≤) (V : Type u_2) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : homological_complex.homological_complex_to_dgo b V ‚ãô homological_complex.dgo_to_homological_complex b V ‚âÖ ùü≠ (homological_complex V (complex_shape.up' b))
(a : ‚Ñù) : cardinal.mk ‚Ü•(set.Iic a) = cardinal.continuum
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {f‚ÇÄ f‚ÇÅ : C(X, Y)} {P : C(X, Y) ‚Üí Prop} (F : f‚ÇÄ.homotopy_with f‚ÇÅ P) : ‚Ü•unit_interval √ó X ‚Üí Y
(L : first_order.language) (M : Type w) [L.Structure M] : Type w
 : simp_lemmas
(r : ‚Ñï+) : multiset ‚Ñï+
 : tactic unit
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [linear_ordered_add_comm_monoid_with_top Œì‚ÇÄ] [comm_ring R] (v : add_valuation R Œì‚ÇÄ) : ideal R
(Œ± : Type u_2) : Type u_2
{K : Type u_1} {n : ‚Ñï} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] {gp_n gp_succ_n : generalized_continued_fraction.pair K} (s_nth_eq : s.nth n = option.some gp_n) (s_succ_nth_eq : s.nth (n + 1) = option.some gp_succ_n) : (generalized_continued_fraction.squash_seq s n).nth n = option.some {a := gp_n.a, b := gp_n.b + gp_succ_n.a / gp_succ_n.b}
{Œ± : Type u} {Œ≤ : Type v} [has_le Œ±] [has_bot Œ±] [has_le Œ≤] [order_bot Œ≤] (f : Œ± ‚Üí Œ≤) (map_le : ‚àÄ (a b : Œ±), f a ‚â§ f b ‚Üí a ‚â§ b) (map_bot : f ‚ä• = ‚ä•) : order_bot Œ±
(m : Type u ‚Üí Type v) (n : Type u ‚Üí Type w) : Type (max (u+1) v w)
(old new : interactive.parse lean.parser.ident) (l : interactive.parse interactive.types.location) : tactic unit
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ‚•§ C} {F : C ‚•§ D} [category_theory.full F] [category_theory.faithful F] [category_theory.limits.has_colimit (K ‚ãô F)] (X : C) (i : F.obj X ‚âÖ category_theory.limits.colimit (K ‚ãô F)) : category_theory.creates_colimit K F
(p : fin 2 ‚Üí ‚Ñ§) : matrix (fin 2) (fin 2) ‚Ñù ‚Üí‚Çó[‚Ñù] ‚Ñù
 : category_theory.faithful algebraic_geometry.Spec.to_LocallyRingedSpace
{R : Type u} [ring R] {S : set R} (hs : is_subring S) : subring R
{C : Type u} [category_theory.category C] (X : C) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (e : local_equiv Œ± Œ≤) (e' : local_equiv Œ≤ Œ≥) : local_equiv Œ± Œ≥
(T : Type u) [topological_space T] : category_theory.pretopology.to_grothendieck (topological_space.opens T) (opens.pretopology T) = opens.grothendieck_topology T
(Œ± : Sort u_1) (Œ≤ : Sort u_2) : Sort (max 1 (imax u_1 u_2) (imax u_2 u_1))
{B : Type u} [quiver B] (a b : B) : category_theory.free_bicategory.hom a b ‚âå category_theory.discrete (quiver.path a b)
{K : Type u_1} [has_repr K] : has_repr (generalized_continued_fraction.int_fract_pair K)
(n : Type u_1) (R : Type u‚ÇÇ) [decidable_eq n] [comm_ring R] [fintype n] : lie_subalgebra R (matrix n n R)
(t : smt_tactic.interactive.itactic) : smt_tactic unit
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : category_theory.pretopology C
(no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) : tactic unit
 : native.float ‚Üí ‚Ñ§
 : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [topological_space Œ≤] {s : set Œ≤} (hs : is_compact s) (ne_s : s.nonempty) {f : Œ≤ ‚Üí Œ±} (hf : continuous_on f s) : ‚àÉ (x : Œ≤) (H : x ‚àà s), ‚àÄ (y : Œ≤), y ‚àà s ‚Üí f x ‚â§ f y
(n : ‚Ñï) : ennreal
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] {X : C} (f : X ‚ü∂ 0) : f = 0
{n : ‚Ñï} {l : multiset ‚Ñï} (hl : l.sum = n) {i : ‚Ñï} (hi : i ‚â† 0) : multiset.count i (nat.partition.of_sums n l hl).parts = multiset.count i l
{Œ± : Type u_1} [fintype Œ±] (s : set Œ±) [decidable_pred (Œª (_x : Œ±), _x ‚àà s)] : fintype ‚Ü•s
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (h : ‚àÄ (X : C), category_theory.presieve.is_sheaf J (category_theory.yoneda.obj X)) : category_theory.sheaf.subcanonical J
 : category_theory.has_forget‚ÇÇ TopCommRing Top
(Œ± : Type u_6) (Œ≤ : Type u_7) [preorder Œ±] [preorder Œ≤] [add_zero_class Œ±] [add_zero_class Œ≤] : Type (max u_6 u_7)
(C : Type u) [category_theory.category C] (D : Type u_1) [category_theory.category D] : (C ‚•§ D) ‚•§ category_theory.simplicial_object C ‚•§ category_theory.simplicial_object D
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} {Œπ2 : Type u_5} (f : Œπ2 ‚Ü™ Œπ) {p : Œπ ‚Üí P} (ha : affine_independent k p) : affine_independent k (p ‚àò ‚áëf)
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {c : E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds b ‚äì measure_theory.measure_space.volume.ae) (nhds c)) : deriv (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in a..u, f x) b = c
 : num ‚Üí ‚Ñï ‚Üí num
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [has_zero M] [add_comm_monoid N] [add_comm_monoid P] (h : N ‚âÉ+ P) (f : Œ± ‚Üí‚ÇÄ M) (g : Œ± ‚Üí M ‚Üí N) : ‚áëh (f.sum g) = f.sum (Œª (a : Œ±) (b : M), ‚áëh (g a b))
(Œ± : Type u_1) {Œ≤ : Type u_2} (b : Œ≤) (h : function.surjective (function.const Œ± b)) : unique Œ≤
{M : Type u_1} [has_mul M] (c : con M) (x : M) : ‚áëc x x
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [decidable_eq Œ≤] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (h‚ÇÅ : strict_mono f) (A B : finset Œ±) : (finset.image f A).to_colex < (finset.image f B).to_colex ‚Üî A.to_colex < B.to_colex
(P : pfunctor) (Œ± : Type u_2) : Type (max u_1 u_2)
{ùïú : Type u_3} {E : Type u_4} [normed_field ùïú] [add_comm_group E] [module ùïú E] (p : seminorm ùïú E) {r : ‚Ñù} {x : E} (hpr : ‚áëp x < r) : absorbent ùïú (p.ball x r)
{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (n : ‚Ñï) [fact (finite_dimensional.finrank K V = n + 1)] : finite_dimensional K V
{Œ± : Type u} [preorder Œ±] {a b : Œ±} : a < b ‚Üí a ‚â§ b
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Ring) : category_theory.limits.is_limit (Ring.limit_cone F)
(C : Type u) [category_theory.category C] : category_theory.cosimplicial_object.augmented C·µí·µñ ‚•§ (category_theory.simplicial_object.augmented C)·µí·µñ
{Œ± : Type u_2} [has_div Œ±] : has_div (filter Œ±)
(Œ± : Type u) [complete_lattice Œ±] : omega_complete_partial_order Œ±
 : Type
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [has_zero Œ≥] : (Œ± ‚äï Œ≤ ‚Üí‚ÇÄ Œ≥) ‚âÉ (Œ± ‚Üí‚ÇÄ Œ≥) √ó (Œ≤ ‚Üí‚ÇÄ Œ≥)
(e : expr) : list binder √ó expr
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [decidable_eq Œπ] [Œ† (i : Œπ), decidable_eq (Œ± i)] [Œ† (i : Œπ), has_zero (Œ± i)] [Œ† (i : Œπ), partial_order (Œ± i)] [Œ† (i : Œπ), locally_finite_order (Œ± i)] (f g : Œ†‚ÇÄ (i : Œπ), Œ± i) : Œ†‚ÇÄ (i : Œπ), finset (Œ± i)
(Œ± : Type u) [topological_space Œ±] : Prop
{C : Type u} [category_theory.category C] (P : C·µí·µñ ‚•§ Type v) : category_theory.grothendieck_topology C
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [comm_monoid Œ≤] [comm_monoid Œ≥] (g : Œ≤ ‚âÉ* Œ≥) (f : Œ± ‚Üí Œ≤) (s : finset Œ±) : ‚áëg (s.prod (Œª (x : Œ±), f x)) = s.prod (Œª (x : Œ±), ‚áëg (f x))
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] (h : Œ± ‚âÉ·µ¢ Œ≤) : Œ≤ ‚âÉ·µ¢ Œ±
{l : filter ‚Ñù} {f f' g g' : ‚Ñù ‚Üí ‚Ñù} (hff' : ‚àÄ·∂† (x : ‚Ñù) in filter.at_bot, has_deriv_at f (f' x) x) (hgg' : ‚àÄ·∂† (x : ‚Ñù) in filter.at_bot, has_deriv_at g (g' x) x) (hg' : ‚àÄ·∂† (x : ‚Ñù) in filter.at_bot, g' x ‚â† 0) (hfbot : filter.tendsto f filter.at_bot (nhds 0)) (hgbot : filter.tendsto g filter.at_bot (nhds 0)) (hdiv : filter.tendsto (Œª (x : ‚Ñù), f' x / g' x) filter.at_bot l) : filter.tendsto (Œª (x : ‚Ñù), f x / g x) filter.at_bot l
{M : Type u_4} [add_comm_monoid M] {Œπ : Type u_1} [subsingleton Œπ] {s : finset Œπ} {f : Œπ ‚Üí M} {b : M} (h : s.sum (Œª (i : Œπ), f i) = b) (i : Œπ) (H : i ‚àà s) : f i = b
{Œ± : Type u_1} (o : ordinal) (f : Œ† (a : ordinal), a < o ‚Üí Œ±) : set Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] [complete_space ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [finite_dimensional ùïú F] {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ‚ä§) : ‚àÄ·∂† (p : F √ó ‚Ü•(f'.ker)) in nhds (f a, 0), f (has_strict_fderiv_at.implicit_function f f' hf hf' p.fst p.snd) = p.fst
{T : Type u} [category_theory.category T] {f g : category_theory.arrow T} (sq : f ‚ü∂ g) : Prop
{x : ‚Ñù} (h : 0 < x) : real.sin x < x
{Œ± : Type u} (n : Œ± ‚Üí filter Œ±) : topological_space Œ±
{R : Type u_1} [add_cancel_monoid R] (g : R) : is_add_regular g
{R : Type u} [comm_semiring R] {A : Type v‚ÇÅ} [semiring A] [algebra R A] {B : Type v‚ÇÇ} [semiring B] [algebra R B] {C : Type v‚ÇÉ} [semiring C] [algebra R C] (f : tensor_product R A B ‚Üí‚Çó[R] C) (w‚ÇÅ : ‚àÄ (a‚ÇÅ a‚ÇÇ : A) (b‚ÇÅ b‚ÇÇ : B), ‚áëf ((a‚ÇÅ * a‚ÇÇ) ‚äó‚Çú[R] (b‚ÇÅ * b‚ÇÇ)) = ‚áëf (a‚ÇÅ ‚äó‚Çú[R] b‚ÇÅ) * ‚áëf (a‚ÇÇ ‚äó‚Çú[R] b‚ÇÇ)) (w‚ÇÇ : ‚àÄ (r : R), ‚áëf (‚áë(algebra_map R A) r ‚äó‚Çú[R] 1) = ‚áë(algebra_map R C) r) : tensor_product R A B ‚Üí‚Çê[R] C
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] {p q : submodule R M} (hpq : p ‚â§ q) : ‚Ü•(submodule.comap q.subtype p) ‚âÉ‚Çó[R] ‚Ü•p
(ic : tactic.instance_cache) : expr ‚Üí expr ‚Üí tactic (tactic.instance_cache √ó expr)
{R : Type u_1} (A : Type u_2) (B : Type u_3) [comm_ring R] [comm_ring A] [comm_ring B] [algebra R B] [algebra A B] [is_integral_closure A R B] {S : Type u_4} [comm_ring S] [algebra R S] [algebra S B] [is_scalar_tower R S B] [algebra R A] [is_scalar_tower R A B] (h : algebra.is_integral R S) : S ‚Üí‚Çê[R] A
{G : Type u_1} [add_group G] [topological_space G] (K‚ÇÄ : set G) (V : topological_space.open_nhds_of 0) : set (topological_space.compacts G ‚Üí ‚Ñù)
{K : Type u_1} [field K] (R : Type u_2) [comm_ring R] [algebra R K] [is_integral_closure R ‚Ñ§ K] : ‚Ü•(number_field.ring_of_integers K) ‚âÉ+* R
{ùïú : Type u_4} {E : Type u_5} [linear_ordered_field ùïú] [topological_space E] [add_comm_monoid E] [module ùïú E] {s : set E} (hs‚ÇÄ : is_closed s) (hs‚ÇÅ : strict_convex ùïú s) : add_salem_spencer (frontier s)
(p : expr) : tactic (expr √ó expr)
{n : ‚Ñï} : simplex_category.truncated n ‚•§ simplex_category
{X Y : Type u} [add_comm_monoid X] [add_comm_monoid Y] (e : X ‚âÉ+ Y) : AddCommMon.of X ‚âÖ AddCommMon.of Y
(p : turing.partrec_to_TM2.Œì' ‚Üí bool) (k‚ÇÅ k‚ÇÇ : turing.partrec_to_TM2.K') (q : turing.partrec_to_TM2.Œõ') : turing.partrec_to_TM2.Œõ'
(n : pos_num) : Prop
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x ‚àà s ‚Üí y ‚àà s ‚Üí x * y ‚àà s
{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {S : set M} {x : M} (hx : x ‚àà submodule.span R S) : ‚àÉ (T : finset M), ‚ÜëT ‚äÜ S ‚àß x ‚àà submodule.span R ‚ÜëT
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) (a : Œ±) : Prop
(q : interactive.parse (optional interactive.types.texpr)) : tactic unit
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ‚ü∂ Q) [category_theory.epi f] : function.surjective ‚áëf
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1 ‚â§ s2 ‚Üî ‚Üës1 ‚äÜ ‚Üës2
{X : Top} {T : ‚Ü•X ‚Üí Type v} (P : Top.prelocal_predicate T) : Top.subpresheaf_to_Types P ‚ü∂ X.presheaf_to_Types T
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : galois_insertion (affine_span k) coe
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] (n : ‚Ñï) (f : ùïú ‚Üí F) (s : set ùïú) (x : ùïú) : F
{A : Type u_1} [add_monoid A] {f g : ‚Ñ§ ‚Üí+ A} (h1 : ‚áëf 1 = ‚áëg 1) : f = g
 : expr ‚Üí expr ‚Üí expr
(X : Top) (T : ‚Ü•X ‚Üí Type u) : Top.sheaf (Type u) X
{et : tactic.ring_exp.ex_type} : tactic.ring_exp.ex et ‚Üí tactic.ring_exp.ex et ‚Üí bool
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [semiring R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] [topological_space (bundle.total_space E)] (e : topological_vector_bundle.trivialization R F E) : topological_vector_bundle.pretrivialization R F E
{Œ± : Type u_1} [linear_ordered_add_comm_group Œ±] {n : ‚Ñ§} (hn : n ‚â† 0) : function.injective (Œª (_x : Œ±), n ‚Ä¢ _x)
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_image f] : category_theory.limits.mono_factorisation f
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b : Œ±} (ha : a ‚â§ 0) (hb : b < 0) : a + b < 0
{G : Type u_2} [group G] {n : ‚Ñï} (v : ‚Ü•(equiv.perm.vectors_prod_eq_one G n)) (k : ‚Ñï) : ‚Ü•(equiv.perm.vectors_prod_eq_one G n)
{Œ± : Type u} [pseudo_metric_space Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù} (hp : function.periodic f c) (hc : c ‚â† 0) (hf : continuous f) : metric.bounded (set.range f)
{Œ± : Type u_1} : Œ±À¢ ∏·µê ‚Üí Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x y z : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (hz : z ‚â† 0) : hb.oangle x y + hb.oangle y z = hb.oangle x z
{R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] (s : set E) : ‚áë(convex_hull R) s = {x : E | ‚àÉ (Œπ : Type u') (t : finset Œπ) (w : Œπ ‚Üí R) (z : Œπ ‚Üí E) (hw‚ÇÄ : ‚àÄ (i : Œπ), i ‚àà t ‚Üí 0 ‚â§ w i) (hw‚ÇÅ : t.sum (Œª (i : Œπ), w i) = 1) (hz : ‚àÄ (i : Œπ), i ‚àà t ‚Üí z i ‚àà s), t.center_mass w z = x}
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a : Œ±} : 1 < a‚Åª¬π ‚Üí a < 1
{T : Type u‚ÇÅ} [category_theory.category T] (X : T) : Type (max u‚ÇÅ v‚ÇÅ)
{G : Type u_1} [group G] {s : set G} {N : subgroup G} [N.normal] (h : s ‚äÜ ‚ÜëN) : subgroup.normal_closure s ‚â§ N
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {s t : category_theory.limits.cocone F} (P : category_theory.limits.is_colimit s) (Q : category_theory.limits.is_colimit t) : s.X ‚âÖ t.X
(n : ‚Ñï) (R : Type u_1) [ring R] [nontrivial R] : (polynomial.cyclotomic n R).nat_degree = n.totient
(a : ‚Ñù) : cardinal.mk ‚Ü•(set.Iio a) = cardinal.continuum
{Œ± : Type u} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : set Œ±} : directed_on r s ‚Üí directed r coe
{Œ± : Sort u_1} {Œ≤‚ÇÅ : Œ± ‚Üí Sort u_2} {Œ≤‚ÇÇ : Œ± ‚Üí Sort u_3} (F : Œ† (a : Œ±), Œ≤‚ÇÅ a ‚âÉ Œ≤‚ÇÇ a) : (Œ£' (a : Œ±), Œ≤‚ÇÅ a) ‚âÉ Œ£' (a : Œ±), Œ≤‚ÇÇ a
{X : Type u_1} [topological_space X] {x y : X} (Œ≥ : path x y) {x' y' : X} (hx : x' = x) (hy : y' = y) : path x' y'
(R : Type u) [ring R] [strong_rank_condition R] (m n : Type v) [fintype m] [fintype n] : finite_dimensional.finrank R (matrix m n R) = fintype.card m * fintype.card n
{R‚ÇÇ : Type u_5} {M‚ÇÇ : Type u_6} [comm_semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] : (M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] R‚ÇÇ) ‚âÉ‚Çó[R‚ÇÇ] bilin_form R‚ÇÇ M‚ÇÇ
{Œ± : Type u_1} (t : set (set Œ±)) (Œ¥ : set Œ± ‚Üí ‚Ñù) (œÑ : ‚Ñù) (hœÑ : 1 < œÑ) (Œ¥nonneg : ‚àÄ (a : set Œ±), a ‚àà t ‚Üí 0 ‚â§ Œ¥ a) (R : ‚Ñù) (Œ¥le : ‚àÄ (a : set Œ±), a ‚àà t ‚Üí Œ¥ a ‚â§ R) (hne : ‚àÄ (a : set Œ±), a ‚àà t ‚Üí a.nonempty) : ‚àÉ (u : set (set Œ±)) (H : u ‚äÜ t), u.pairwise_disjoint id ‚àß ‚àÄ (a : set Œ±), a ‚àà t ‚Üí (‚àÉ (b : set Œ±) (H : b ‚àà u), (a ‚à© b).nonempty ‚àß Œ¥ a ‚â§ œÑ * Œ¥ b)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C D : homological_complex V c} (f : homotopy_equiv C D) : homotopy_equiv D C
 : Type (u+1)
{R : Type u} [comm_semiring R] (s : multiset (polynomial R)) (x : R) : polynomial.eval x s.prod = (multiset.map (polynomial.eval x) s).prod
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.enough_injectives C] (Z : C) : category_theory.InjectiveResolution Z
{Œ± : Type u_1} {Œ≤ : Type u_2} [preorder Œ±] [preorder Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (hu : monotone u) (hl : monotone l) (hul : ‚àÄ (a : Œ±), a ‚â§ u (l a)) (hlu : ‚àÄ (b : Œ≤), l (u b) = b) : galois_insertion l u
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : setoid Œ±} {f : Œ± ‚Üí Œ≤} (H : r ‚â§ setoid.ker f) (g : quotient r ‚Üí Œ≤) (Hg : f = g ‚àò quotient.mk) : quotient.lift f H = g
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.monoidal_category C] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) [category_theory.is_equivalence F.to_lax_monoidal_functor.to_functor] [category_theory.right_rigid_category D] : category_theory.right_rigid_category C
(C : Type u‚ÇÅ) [category_theory.category C] : category_theory.skeleton C ‚âå C
{M : Type u_3} {N : Type u_4} {hM : has_mul M} {hN : has_mul N} (f : M ‚Üí‚Çô* N) (f' : M ‚Üí N) (h : f' = ‚áëf) : M ‚Üí‚Çô* N
{m : Type u_2} {n : Type u_3} (R : Type u_11) [comm_ring R] [fintype m] [decidable_eq m] [fintype n] [decidable_eq n] (e : m ‚âÉ n) (M : matrix m m R) : (‚áë(matrix.reindex_linear_equiv R R e e) M).det = M.det
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ‚•§ D) [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.enough_injectives C] {X : C} (P : category_theory.InjectiveResolution X) : F.obj X ‚ü∂ (F.right_derived 0).obj X
{ùïú : Type u_1} {E : Type u_3} [ordered_semiring ùïú] [topological_space E] [add_comm_monoid E] [module ùïú E] {s : set E} (h : is_open s) (hs : convex ùïú s) : strict_convex ùïú s
{R : Type u_1} [mul_zero_class R] : is_right_regular 0 ‚Üî subsingleton R
(M : Type u) : Type u
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_5} [normed_group E'] [normed_space ùïú E'] {n : with_top ‚Ñï} {f : E ‚Üí E'} : cont_mdiff (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') n f ‚Üí cont_diff ùïú n f
(E : Type u_6) [add_comm_group E] [has_norm E] : Prop
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] : Top.local_predicate (Œª (x : ‚Ü•(projective_spectrum.Top ùíú)), homogeneous_localization ùíú (projective_spectrum.as_homogeneous_ideal x).to_ideal)
(R : Type u) (M : Type v) [comm_semiring R] [add_comm_monoid M] [module R M] : triv_sq_zero_ext R M ‚Üí‚Çê[R] R
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} : category_theory.is_iso (category_theory.limits.cokernel.œÄ 0)
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] {P X Y Z : C} {fst : P ‚ü∂ X} {snd : P ‚ü∂ Y} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} (h : category_theory.is_pullback fst snd f g) : category_theory.limits.pullback_cone f g
{Œ± : Type u_1} {Œ≤ : Type u_2} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [topological_space Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : continuous f) (x‚ÇÄ : Œ≤) (h : ‚àÄ·∂† (x : Œ≤) in filter.cocompact Œ≤, f x‚ÇÄ ‚â§ f x) : ‚àÉ (x : Œ≤), ‚àÄ (y : Œ≤), f x ‚â§ f y
 : list pexpr ‚Üí pexpr
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± : D·µí·µñ ‚•§ A} {‚Ñ±' : category_theory.Sheaf K A} (Œ± : ‚Ñ± ‚ü∂ ‚Ñ±'.val) : H.sheaf_hom (category_theory.whisker_left G.op Œ±) = Œ±
(p : tactic.ring_exp.ex tactic.ring_exp.ex_type.prod) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum)
{G : Type u_1} [measurable_space G] [add_group G] [has_measurable_add G] (g : G) : G ‚âÉ·µê G
{Œ± : Type u_1} (E : Œ± ‚Üí Type u_2) [Œ† (i : Œ±), normed_group (E i)] : Type (max u_1 u_2)
{C : Type u‚ÇÅ} [category_theory.category C] (F : C ‚•§ Type v‚ÇÅ) : Prop
{m : Type ‚Üí Type u_1} [monad m] (R : expr ‚Üí ‚Ñï ‚Üí m (option expr)) : expr ‚Üí ‚Ñï ‚Üí m expr
{Œ± : Type u_1} (f : filter Œ±) : Prop
{xl xr : Type u_1} {xL : xl ‚Üí pgame} {xR : xr ‚Üí pgame} {yl yr : Type u_1} {yL : yl ‚Üí pgame} {yR : yr ‚Üí pgame} : pgame.mk xl xr xL xR ‚â§ pgame.mk yl yr yL yR ‚Üî (‚àÄ (i : xl), (xL i).lf (pgame.mk yl yr yL yR)) ‚àß ‚àÄ (j : yr), (pgame.mk xl xr xL xR).lf (yR j)
{C : Type u} [category_theory.category C] (F : category_theory.limits.walking_span ‚•§ C) : F ‚âÖ category_theory.limits.span (F.map category_theory.limits.walking_span.hom.fst) (F.map category_theory.limits.walking_span.hom.snd)
{F : Type u ‚Üí Type u} [functor F] [q : qpf F] : qpf.fix F ‚Üí (qpf.P F).W
{C : Type u‚ÇÅ} [category_theory.category_struct C] [‚àÄ (X Y : C), subsingleton (X ‚ü∂ Y)] : category_theory.category C
{Œ± : Type u_1} [complete_lattice Œ±] [is_modular_lattice Œ±] [is_compactly_generated Œ±] (h : has_Sup.Sup {a : Œ± | is_atom a} = ‚ä§) : is_complemented Œ±
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] (s : set Œ≤) (f : bounded_continuous_function Œ± Œ≤) (H : ‚àÄ (x : Œ±), ‚áëf x ‚àà s) : bounded_continuous_function Œ± ‚Ü•s
{Œ± : Type u} (p : Œ± ‚Üí Type v) (q : Œ± ‚Üí Prop) : {y // q y.fst} ‚âÉ Œ£ (x : subtype q), p x.val
{Œ± : Sort u} {r r' : setoid Œ±} (eq : ‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±), setoid.r a‚ÇÅ a‚ÇÇ ‚Üî setoid.r a‚ÇÅ a‚ÇÇ) : quotient r ‚âÉ quotient r'
{Œ≥ : Type} (tooltip : widget.tc subexpr Œ≥) : widget.tc expr Œ≥
{x : pgame} {xl' xr' : Type u_1} (el : x.left_moves ‚âÉ xl') (er : x.right_moves ‚âÉ xr') : pgame
{Œ± : Type u_1} (s : set Œ±·µí·µñ) : set Œ±
 : expr.address ‚Üí expr ‚Üí option expr
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : M ‚Üí‚Çó[R] direct_sum ‚Ñï (Œª (i : ‚Ñï), ‚Ü•((tensor_algebra.Œπ R).range ^ i))
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) : s.points_with_circumcenter affine.simplex.points_with_circumcenter_index.circumcenter_index = s.circumcenter
{Œ± Œ≤ : Type u} {m : Type u ‚Üí Type u} [monad m] [alternative m] (f : Œ± ‚Üí m (Œ± √ó list Œ≤)) (s : Œ±) : tactic.mllist m Œ≤
(e : expr) : tactic.ring.ring_m (tactic.ring.horner_expr √ó expr)
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) (m : multiset R) : (‚àÄ (a : R), a ‚àà m ‚Üí a ‚àà s) ‚Üí m.sum ‚àà s
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F F' : C ‚•§ D} {G : D ‚•§ C} (adj1 : F ‚ä£ G) (adj2 : F' ‚ä£ G) : F.op ‚ãô category_theory.coyoneda ‚âÖ F'.op ‚ãô category_theory.coyoneda
 : W_type.nat_Œ± ‚Üí Type
{M : Type u_1} {Œπ : Type u_2} {R : Type u_3} [decidable_eq M] [add_monoid M] [decidable_eq Œπ] [add_monoid Œπ] [comm_semiring R] (f : M ‚Üí+ Œπ) : add_monoid_algebra R M ‚Üí‚Çê[R] direct_sum Œπ (Œª (i : Œπ), ‚Ü•(add_monoid_algebra.grade_by R ‚áëf i))
{G : Type u_1} [group G] {Œ± : Type u_4} {Œ≤ : Type u_5} [has_scalar Œ± Œ≤] [mul_action G Œ±] [mul_action G Œ≤] [is_scalar_tower G Œ± Œ≤] (S : subgroup G) : is_scalar_tower ‚Ü•S Œ± Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_comm_monoid M] (e : Œ± ‚âÉ Œ≤) : (Œ± ‚Üí‚ÇÄ M) ‚âÉ+ (Œ≤ ‚Üí‚ÇÄ M)
{R : Type u} {Œπ : Type u'} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [comm_semiring R] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] [fintype Œπ] : M‚ÇÇ ‚âÉ‚Çó[R] multilinear_map R (Œª (i : Œπ), R) M‚ÇÇ
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] {F G : category_theory.oplax_functor B C} (Œ∑ : F ‚ü∂ G) : ùüô F ‚â´ Œ∑ ‚âÖ Œ∑
{p : ‚Ñï} (hp : nat.prime p) {n : ‚Ñ§} (hpn : is_coprime n ‚Üëp) : n ^ (p - 1) ‚â° 1 [ZMOD ‚Üëp]
{Œ± : Type v} {s : finset Œ±} {M : Type u_1} [add_comm_monoid M] (f : Œ± ‚Üí M) (p : M ‚Üí Prop) (p_mul : ‚àÄ (a b : M), p a ‚Üí p b ‚Üí p (a + b)) (p_one : p 0) (p_s : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p (f x)) : p (s.sum (Œª (x : Œ±), f x))
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b : Œ±} (ha : a < 0) (hb : b < 0) : a + b < 0
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Œπ] (p : Œπ ‚Üí P) {n : ‚Ñï} (hc : fintype.card Œπ = n + 1) : affine_independent k p ‚Üî n ‚â§ finite_dimensional.finrank k ‚Ü•(vector_span k (set.range p))
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} : mvqpf.fix F Œ± ‚Üí F (Œ± ::: mvqpf.fix F Œ±)
(R : Type u_1) (A : Type u_2) (M : Type u_3) [comm_semiring R] [semiring A] [algebra R A] [add_comm_monoid M] [module R M] [module A M] [is_scalar_tower R A M] (X : set M) (hsur : function.surjective ‚áë(algebra_map R A)) : submodule.span R X = submodule.restrict_scalars R (submodule.span A X)
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (A : matrix n n R) : (-A).det = (-1) ^ fintype.card n ‚Ä¢ A.det
{V : Type u_1} [inner_product_space ‚Ñù V] (x y : V) : 0 ‚â§ inner_product_geometry.angle x y
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (f : option Œ± ‚Üí Œ≤ ‚Üí Œ≥) (as : list Œ±) (bs : list Œ≤) : list Œ≥
{Œ± : Type u_2} {M‚ÇÅ : Type u_6} {M‚ÇÇ : Type u_7} [topological_space M‚ÇÇ] [t2_space M‚ÇÇ] [add_zero_class M‚ÇÅ] [add_zero_class M‚ÇÇ] [has_continuous_add M‚ÇÇ] {F : Type u_8} [add_monoid_hom_class F M‚ÇÅ M‚ÇÇ] {l : filter Œ±} (f : M‚ÇÅ ‚Üí M‚ÇÇ) (g : Œ± ‚Üí F) [l.ne_bot] (h : filter.tendsto (Œª (a : Œ±) (x : M‚ÇÅ), ‚áë(g a) x) l (nhds f)) : M‚ÇÅ ‚Üí+ M‚ÇÇ
(M : Type u‚ÇÅ) [comm_monoid M] (p : ‚Ñï) : submonoid (‚Ñï ‚Üí M)
(M : Type u_1) [measurable_space M] [has_mul M] : Prop
{X : Top} (T : ‚Ü•X ‚Üí Type v) : Type v
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [division_ring Œ≤] : division_ring Œ±
 : CommMon ‚•§ CommMon_ (Type u)
{G : Type w} [topological_space G] [comm_group G] [topological_group G] : G ‚Üí‚Çô* filter G
{G : Type u_1} [group G] {N : Type u_3} [group N] (f : G ‚Üí* N) : subgroup N
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] (X Y : category_theory.center C) : Type v‚ÇÅ
(n : ‚Ñï) {A : Type u} (x : A) {Œ± : typevec n} : (mvpfunctor.const n A).obj Œ±
{M : Type u_1} [add_zero_class M] {S T : add_submonoid M} (h : S ‚â§ T) : ‚Ü•S ‚Üí+ ‚Ü•T
{C : Type u‚ÇÅ} [category_theory.small_category C] (P : C·µí·µñ ‚•§ Type u‚ÇÅ) : category_theory.limits.cocone (category_theory.functor_to_representables P)
{Œ± : Type u} [non_unital_non_assoc_ring Œ±] {a b c d e : Œ±} : a * e + c = b * e + d ‚Üí (a - b) * e + c = d
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {n : ‚Ñï} (hs : unique_diff_on ùïú s) : cont_diff_on ùïú ‚Üë(n + 1) f s ‚Üî differentiable_on ùïú f s ‚àß cont_diff_on ùïú ‚Üën (Œª (y : E), fderiv_within ùïú f s y) s
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] [category_theory.has_projective_resolutions C] [category_theory.preadditive D] [category_theory.limits.has_zero_object D] [category_theory.limits.has_equalizers D] [category_theory.limits.has_cokernels D] [category_theory.limits.has_images D] [category_theory.limits.has_image_maps D] {F G : C ‚•§ D} [F.additive] [G.additive] (Œ± : F ‚ü∂ G) (n : ‚Ñï) : F.left_derived n ‚ü∂ G.left_derived n
(k : Type u_1) {V1 : Type u_2} (P1 : Type u_3) [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] : P1 ‚Üí·µÉ[k] P1
{K : Type v} [field K] (f : polynomial K) : polynomial K
 : tactic.instance_cache ‚Üí expr ‚Üí expr ‚Üí expr ‚Üí tactic (tactic.instance_cache √ó expr)
(p : ‚Ñï) [fact (nat.prime p)] (n : ‚Ñï) : Type
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (T : Type u_4) [comm_ring T] [algebra R T] [algebra S T] [is_scalar_tower R S T] [is_localization M S] (p : ideal S) [Hp : p.is_prime] [is_localization.at_prime T p] : is_localization.at_prime T (ideal.comap (algebra_map R S) p)
(Œ± : Type u) (Œ≤ : Type v) [group Œ±] [mul_action Œ± Œ≤] : (Œ£ (a : Œ±), ‚Ü•(mul_action.fixed_by Œ± Œ≤ a)) ‚âÉ quotient (mul_action.orbit_rel Œ± Œ≤) √ó Œ±
(K : Type u) [hring : comm_ring K] [hdomain : is_domain K] : is_fraction_ring (polynomial K) (ratfunc K)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {p : formal_multilinear_series ùïú E F} {r : ennreal} {f : E ‚Üí F} {x : E} [complete_space F] (h : has_fpower_series_on_ball f p x r) : has_fpower_series_on_ball (fderiv ùïú f) (‚Üë(continuous_multilinear_curry_fin1 ùïú E F).comp_formal_multilinear_series (p.change_origin_series 1)) x r
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D·µí·µñ) (G : D·µí·µñ ‚•§ C·µí·µñ) (h : G ‚ä£ F) : F.unop ‚ä£ G.unop
{Œ± : Type u_1} [conditionally_complete_linear_order Œ±] {s : set Œ±} {b : Œ±} (hs : s.nonempty) (hb : b < has_Sup.Sup s) : ‚àÉ (a : Œ±) (H : a ‚àà s), b < a
 : Type
{G : Type w} [add_group G] [topological_space G] [topological_add_group G] (x : G) : G ‚âÉ‚Çú G
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {c : E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds b ‚äì measure_theory.measure_space.volume.ae) (nhds c)) : has_strict_deriv_at (Œª (u : ‚Ñù), ‚à´ (x : ‚Ñù) in a..u, f x) c b
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {A X Y : C} [category_theory.closed A] : (Y ‚ü∂ (category_theory.ihom A).obj X) ‚Üí (A ‚äó Y ‚ü∂ X)
{G : Type u_1} [monoid G] (tG : monoid.is_torsion G) : group G
(P L : Type u) [has_mem P L] : Type u
(k : Type u_1) {V : Type u_2} (P : Type u_3) [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] : collinear k ‚àÖ
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.limits.cokernel f.op ‚âÖ opposite.op (category_theory.limits.kernel f)
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (x : Œ± 0) (p : Œ† (i : fin n), Œ± i.succ) (i : fin (n + 1)) : Œ± i
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {x : E} {n : ‚Ñï} (hs : unique_diff_on ùïú s) (hx : x ‚àà s) : iterated_fderiv_within ùïú (n + 1) f s x = (‚áë(continuous_multilinear_curry_right_equiv' ùïú n E F) ‚àò iterated_fderiv_within ùïú n (Œª (y : E), fderiv_within ùïú f s y) s) x
(n : ‚Ñï) : list turing.partrec_to_TM2.Œì'
{M : Type u_1} [add_monoid M] (c : add_con M) : add_monoid c.quotient
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [topological_space.second_countable_topology X] {f : X ‚Üí Y} (hf : ‚àÄ (x : X), ‚àÉ (C : nnreal) (s : set X) (H : s ‚àà nhds x), lipschitz_on_with C f s) : dimH (set.range f) ‚â§ dimH set.univ
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (G : D·µí·µñ ‚•§ C·µí·µñ) (h : G ‚ä£ F.op) : F ‚ä£ G.unop
 : has_inv pgame
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {s : set E} : unique_mdiff_on (model_with_corners_self ùïú E) s ‚Üí unique_diff_on ùïú s
(Œ± : Type u_1) {Œ≤ : Type u_2} [has_zero Œ≤] (h : function.surjective 0) : unique Œ≤
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [normalized_gcd_monoid Œ±] (s : multiset Œ±) : Œ±
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_lt.lt] {a b : Œ±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{Œ± : Type} (tactics : list (tactic Œ±)) : tactic (list Œ±)
{Œ± : Type u_1} [encodable Œ±] {n : ‚Ñï} : encodable (vector Œ± n)
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.preserves_zero_morphisms] {J : Type v} [fintype J] {f : J ‚Üí C} [category_theory.limits.preserves_biproduct f F] : category_theory.limits.preserves_colimit (category_theory.discrete.functor f) F
{R : Type u_1} [comm_ring R] {x‚ÇÅ x‚ÇÇ x‚ÇÉ x‚ÇÑ x‚ÇÖ x‚ÇÜ x‚Çá x‚Çà y‚ÇÅ y‚ÇÇ y‚ÇÉ y‚ÇÑ y‚ÇÖ y‚ÇÜ y‚Çá y‚Çà : R} : (x‚ÇÅ ^ 2 + x‚ÇÇ ^ 2 + x‚ÇÉ ^ 2 + x‚ÇÑ ^ 2 + x‚ÇÖ ^ 2 + x‚ÇÜ ^ 2 + x‚Çá ^ 2 + x‚Çà ^ 2) * (y‚ÇÅ ^ 2 + y‚ÇÇ ^ 2 + y‚ÇÉ ^ 2 + y‚ÇÑ ^ 2 + y‚ÇÖ ^ 2 + y‚ÇÜ ^ 2 + y‚Çá ^ 2 + y‚Çà ^ 2) = (x‚ÇÅ * y‚ÇÅ - x‚ÇÇ * y‚ÇÇ - x‚ÇÉ * y‚ÇÉ - x‚ÇÑ * y‚ÇÑ - x‚ÇÖ * y‚ÇÖ - x‚ÇÜ * y‚ÇÜ - x‚Çá * y‚Çá - x‚Çà * y‚Çà) ^ 2 + (x‚ÇÅ * y‚ÇÇ + x‚ÇÇ * y‚ÇÅ + x‚ÇÉ * y‚ÇÑ - x‚ÇÑ * y‚ÇÉ + x‚ÇÖ * y‚ÇÜ - x‚ÇÜ * y‚ÇÖ - x‚Çá * y‚Çà + x‚Çà * y‚Çá) ^ 2 + (x‚ÇÅ * y‚ÇÉ - x‚ÇÇ * y‚ÇÑ + x‚ÇÉ * y‚ÇÅ + x‚ÇÑ * y‚ÇÇ + x‚ÇÖ * y‚Çá + x‚ÇÜ * y‚Çà - x‚Çá * y‚ÇÖ - x‚Çà * y‚ÇÜ) ^ 2 + (x‚ÇÅ * y‚ÇÑ + x‚ÇÇ * y‚ÇÉ - x‚ÇÉ * y‚ÇÇ + x‚ÇÑ * y‚ÇÅ + x‚ÇÖ * y‚Çà - x‚ÇÜ * y‚Çá + x‚Çá * y‚ÇÜ - x‚Çà * y‚ÇÖ) ^ 2 + (x‚ÇÅ * y‚ÇÖ - x‚ÇÇ * y‚ÇÜ - x‚ÇÉ * y‚Çá - x‚ÇÑ * y‚Çà + x‚ÇÖ * y‚ÇÅ + x‚ÇÜ * y‚ÇÇ + x‚Çá * y‚ÇÉ + x‚Çà * y‚ÇÑ) ^ 2 + (x‚ÇÅ * y‚ÇÜ + x‚ÇÇ * y‚ÇÖ - x‚ÇÉ * y‚Çà + x‚ÇÑ * y‚Çá - x‚ÇÖ * y‚ÇÇ + x‚ÇÜ * y‚ÇÅ - x‚Çá * y‚ÇÑ + x‚Çà * y‚ÇÉ) ^ 2 + (x‚ÇÅ * y‚Çá + x‚ÇÇ * y‚Çà + x‚ÇÉ * y‚ÇÖ - x‚ÇÑ * y‚ÇÜ - x‚ÇÖ * y‚ÇÉ + x‚ÇÜ * y‚ÇÑ + x‚Çá * y‚ÇÅ - x‚Çà * y‚ÇÇ) ^ 2 + (x‚ÇÅ * y‚Çà - x‚ÇÇ * y‚Çá + x‚ÇÉ * y‚ÇÜ + x‚ÇÑ * y‚ÇÖ - x‚ÇÖ * y‚ÇÑ - x‚ÇÜ * y‚ÇÉ + x‚Çá * y‚ÇÇ + x‚Çà * y‚ÇÅ) ^ 2
(R : Type u_2) (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] [has_one M] [char_zero M] : char_zero R
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b : Œ±} (ha : a < 0) (hb : b ‚â§ 0) : a + b < 0
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] {X : C} {P : C·µí·µñ ‚•§ D} (S : J.cover X) (x : ‚Ü•(P.obj (opposite.op X))) : category_theory.meq P S
{M : Type u_1} [add_monoid M] (P : add_submonoid M) : P.fg ‚Üî ‚àÉ (S : set M), add_submonoid.closure S = P ‚àß S.finite
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {P : C} (Œπ : P ‚ü∂ X) (w : Œπ ‚â´ f = Œπ ‚â´ g) : category_theory.limits.fork f g
{Œ± : Type u_1} [has_repr Œ±] : ordnode Œ± ‚Üí string
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.sheaf C X) (U V : topological_space.opens ‚Ü•X) : category_theory.limits.pullback_cone (F.val.map (category_theory.hom_of_le _).op) (F.val.map (category_theory.hom_of_le _).op)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí. Œ≤ ‚äï Œ±) : Œ± ‚Üí. Œ≤
{Œπ : Type u_6} [decidable_eq Œπ] {Œπ‚ÇÅ : Type u_7} [fintype Œπ] {R' : Type u_8} {N‚ÇÅ : Type u_9} {N‚ÇÇ : Type u_10} [comm_semiring R'] [add_comm_monoid N‚ÇÅ] [add_comm_monoid N‚ÇÇ] [module R' N‚ÇÅ] [module R' N‚ÇÇ] {f g : alternating_map R' N‚ÇÅ N‚ÇÇ Œπ} (e : basis Œπ‚ÇÅ R' N‚ÇÅ) (h : ‚àÄ (v : Œπ ‚Üí Œπ‚ÇÅ), function.injective v ‚Üí ‚áëf (Œª (i : Œπ), ‚áëe (v i)) = ‚áëg (Œª (i : Œπ), ‚áëe (v i))) : f = g
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddGroup) : add_subgroup (Œ† (j : J), ‚Ü•(F.obj j))
(R : Type u) [non_unital_semiring R] [partial_order R] : Type u
{V‚ÇÅ : Type u_1} {V‚ÇÇ : Type u_2} [normed_group V‚ÇÅ] [normed_group V‚ÇÇ] : normed_group (normed_group_hom V‚ÇÅ V‚ÇÇ)
{Œ± : Type u} [is_empty Œ±] : unique (filter Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] (X : C) : Type (max u‚ÇÅ v‚ÇÅ)
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (F : C ‚•§ D) [category_theory.full F] : category_theory.full F.to_ess_image
{V : Type u} {V' : Type v} {G : simple_graph V} {G' : simple_graph V'} (f : G ‚Üíg G') {u v : V} : G.walk u v ‚Üí G'.walk (‚áëf u) (‚áëf v)
{Œ± : Type u} {r : Œ± ‚Üí Œ± ‚Üí Prop} {a b : Œ±} (p : Œ± ‚Üí Prop) (l : list Œ±) (h : list.chain r a l) (hb : (a :: l).last _ = b) (carries : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, r x y ‚Üí p y ‚Üí p x) (final : p b) (i : Œ±) (H : i ‚àà a :: l) : p i
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {G : K ‚•§ C} (e : K ‚âå J) (Œ± : e.functor ‚ãô F ‚âÖ G) : category_theory.limits.cocone F ‚âå category_theory.limits.cocone G
(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_binary_products C] : category_theory.monoidal_category C
{Œ± : Type u} [topological_space Œ±] (x : Œ±) : set Œ±
(R : Type u) [comm_semiring R] [star_ring R] : R ‚Üí+* R
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] {F G : category_theory.oplax_functor B C} {Œ∑ Œ∏ : F ‚ü∂ G} (app : Œ† (a : B), Œ∑.app a ‚âÖ Œ∏.app a) (naturality : ‚àÄ {a b : B} (f : a ‚ü∂ b), category_theory.bicategory.whisker_left (F.map f) (app b).hom ‚â´ Œ∏.naturality f = Œ∑.naturality f ‚â´ category_theory.bicategory.whisker_right (app a).hom (G.map f)) : Œ∑ ‚âÖ Œ∏
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ‚Ñ§] : category_theory.differential_object C ‚•§ C
{C : Type u} [category_theory.category C] (X Y : C) : Prop
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] : ‚Üë(category_theory.limits.kernel_subobject f) ‚âÖ category_theory.limits.kernel f
{V : Type u} [category_theory.category V] [category_theory.limits.has_images V] [category_theory.limits.has_zero_object V] [category_theory.preadditive V] [category_theory.limits.has_kernels V] [category_theory.limits.has_cokernels V] {A B C : V} (f : A ‚ü∂ B) (g : B ‚ü∂ C) : category_theory.exact f g ‚Üî ‚àÉ (w : f ‚â´ g = 0), nonempty (homology f g w ‚âÖ 0)
{C : Type u‚ÇÅ} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)] : category_theory.is_subterminal A
{Œπ : Type u_1} (p : ‚Ñù) [fact_one_le_p : fact (1 ‚â§ p)] (Œ± : Œπ ‚Üí Type u_3) [fintype Œπ] [Œ† (i : Œπ), normed_group (Œ± i)] : normed_group (pi_Lp p Œ±)
 : Type (u+1)
{C : Type u‚ÇÅ} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : category_theory.is_iso (category_theory.limits.diag A)
{C : Type u} [category_theory.category C] : category_theory.with_terminal C ‚Üí category_theory.with_terminal C ‚Üí Type v
(G : Type u) (F : Type v) [group G] [field F] [fintype G] [mul_semiring_action G F] [has_faithful_smul G F] : function.bijective (mul_semiring_action.to_alg_hom ‚Ü•(fixed_points.subfield G F) F)
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {Œ± : Type u_2} [add_right_cancel_semigroup Œ±] [has_one Œ±] [decidable_eq Œ±] (X : Œ± ‚Üí V) (d_X : Œ† (n : Œ±), X n ‚ü∂ X (n + 1)) (sq_X : ‚àÄ (n : Œ±), d_X n ‚â´ d_X (n + 1) = 0) (Y : Œ± ‚Üí V) (d_Y : Œ† (n : Œ±), Y n ‚ü∂ Y (n + 1)) (sq_Y : ‚àÄ (n : Œ±), d_Y n ‚â´ d_Y (n + 1) = 0) (f : Œ† (i : Œ±), X i ‚ü∂ Y i) (comm : ‚àÄ (i : Œ±), f i ‚â´ d_Y i = d_X i ‚â´ f (i + 1)) : cochain_complex.of X d_X sq_X ‚ü∂ cochain_complex.of Y d_Y sq_Y
{ùïú : Type u_1} {R : Type u_2} [has_scalar ùïú R] [normed_field ùïú] [ring R] {E : Type u_3} [semi_normed_group E] [normed_space ùïú E] [module R E] [is_scalar_tower ùïú R E] (s : submodule R E) : normed_space ùïú ‚Ü•s
(p : ‚Ñï) [fact (nat.prime p)] (R : Type u‚ÇÅ) [comm_semiring R] [char_p R p] [perfect_ring R p] : perfection_map p (ring_hom.id R)
{C : Type u} [category_theory.category C] [‚àÄ (n : ‚Ñï) (f : category_theory.arrow C), category_theory.limits.has_wide_pushout f.left (Œª (i : ulift (fin (n + 1))), f.right) (Œª (i : ulift (fin (n + 1))), f.hom)] (F : category_theory.arrow C) (X : category_theory.cosimplicial_object.augmented C) : (F.augmented_cech_conerve ‚ü∂ X) ‚âÉ (F ‚ü∂ category_theory.cosimplicial_object.augmented.to_arrow.obj X)
{C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] (i j : D.to_glue_data.J) : category_theory.limits.is_limit (D.to_glue_data.V_pullback_cone i j)
(R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] (e : Œ± ‚âÉ Œ≤) (h‚ÇÅ : monotone ‚áëe) (h‚ÇÇ : monotone ‚áë(e.symm)) : Œ± ‚âÉo Œ≤
{V : Type u} (G : simple_graph V) (v : V) : set V
{p : ‚Ñï} [fact (nat.prime p)] : has_mul ‚Ñ§_[p]
{key value : Type} (default : value) (m : native.rb_map key value) (k : key) : value
{key : Type} (s : native.rb_set key) (P : key ‚Üí bool) : native.rb_set key
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_binary_biproduct X Y] (hY : category_theory.limits.is_zero X) : Y ‚âÖ X ‚äû Y
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {K : submodule ùïú E} [complete_space ‚Ü•K] {u v z : E} (hv : v ‚àà K) (hz : z ‚àà K·óÆ) (hu : u = v + z) : ‚Üë(‚áë(orthogonal_projection K) u) = v
{Œ± : Type u} [pseudo_metric_space Œ±] {s t u : set Œ±} (fin : emetric.Hausdorff_edist t u ‚â† ‚ä§) : metric.Hausdorff_dist s u ‚â§ metric.Hausdorff_dist s t + metric.Hausdorff_dist t u
{Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : lower_semicontinuous_on f s) (hg : lower_semicontinuous_on g s) (hcont : ‚àÄ (x : Œ±), x ‚àà s ‚Üí continuous_at (Œª (p : Œ≥ √ó Œ≥), p.fst + p.snd) (f x, g x)) : lower_semicontinuous_on (Œª (z : Œ±), f z + g z) s
(R : Type u) (M : Type v) (A : Type w) [comm_semiring R] [add_comm_monoid M] [module R M] [comm_ring A] [algebra R A] : (M ‚Üí‚Çó[R] A) ‚Üí‚Çó[A] M ‚Üí A
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {K : J ‚•§ C} {F G : C ‚•§ D} (h : F ‚âÖ G) {c : category_theory.limits.cocone K} (t : category_theory.limits.is_colimit (F.map_cocone c)) : category_theory.limits.is_colimit (G.map_cocone c)
(s : ‚ÑÇ) (h2 : s ‚â† 0) : (s + 1).Gamma = s * s.Gamma
{C : Type u} [category_theory.category C] {U : Top} (X : algebraic_geometry.PresheafedSpace C) {f : U ‚ü∂ ‚ÜëX} (h : open_embedding ‚áëf) : algebraic_geometry.PresheafedSpace C
{n : ‚Ñï} (f : pSet.resp (n + 1)) (x : pSet) : pSet.resp n
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {f : M ‚Üí* P} (x : M) : ‚áë(con.ker f) x = ‚áëf ‚Åª¬π' {‚áëf x}
(R : Type u) [ring R] [strong_rank_condition R] {Œπ : Type v} [fintype Œπ] {M : Œπ ‚Üí Type w} [Œ† (i : Œπ), add_comm_group (M i)] [Œ† (i : Œπ), module R (M i)] [‚àÄ (i : Œπ), module.free R (M i)] [‚àÄ (i : Œπ), module.finite R (M i)] : finite_dimensional.finrank R (Œ† (i : Œπ), M i) = finset.univ.sum (Œª (i : Œπ), finite_dimensional.finrank R (M i))
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_group E] [module ùïú E] {s : set E} : convex_independent ùïú (Œª (x : ‚Ü•s), ‚Üëx) ‚Üî ‚àÄ (x : E), x ‚àà s ‚Üí x ‚àâ ‚áë(convex_hull ùïú) (s  {x})
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a : Œ±} : 1 < a‚Åª¬π ‚Üî a < 1
{T : Type u} [category_theory.category T] {f g : category_theory.arrow T} (sq : f ‚ü∂ g) : Type v
(Œ± : Type u) [infinite Œ±] : ultrafilter Œ±
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} (t : category_theory.limits.cofork f g) (desc : Œ† (s : category_theory.limits.cofork f g), t.X ‚ü∂ s.X) (fac : ‚àÄ (s : category_theory.limits.cofork f g), t.œÄ ‚â´ desc s = s.œÄ) (uniq : ‚àÄ (s : category_theory.limits.cofork f g) (m : t.X ‚ü∂ s.X), t.œÄ ‚â´ m = s.œÄ ‚Üí m = desc s) : category_theory.limits.is_colimit t
(C : Type u‚ÇÅ) [category_theory.category C] : C ‚•§ category_theory.quotient (category_theory.paths_hom_rel C)
(n : ‚Ñï) : finset (‚Ñï √ó ‚Ñï)
(e t : expr) : tactic.unsafe.type_context bool
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [semilattice_sup Œ≤] {f g : Œ± ‚Üí Œ≤} (hf : antitone f) (hg : antitone g) : antitone (f ‚äî g)
{V : Type u_1} {Œ± : Type u_2} [has_zero Œ±] [has_one Œ±] [decidable_eq Œ±] [decidable_eq V] (A : matrix V V Œ±) : matrix V V Œ±
{Œ± : Type u_1} [uniform_space Œ±] {s : set Œ±} {U : set (Œ± √ó Œ±)} (hs : dense s) (hU : U ‚àà uniformity Œ±) : (‚ãÉ (x : Œ±) (H : x ‚àà s), uniform_space.ball x U) = set.univ
{U : Top} (X : algebraic_geometry.Scheme) {f : U ‚ü∂ Top.of ‚Ü•(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} (h : open_embedding ‚áëf) : X.restrict h ‚ü∂ X
{R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_4} {M‚ÇÇ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {s : set M} {f g : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (hv : submodule.span R s = ‚ä§) (h : set.eq_on ‚áëf ‚áëg s) : f = g
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {s t : category_theory.limits.fork f g} (i : s.X ‚âÖ t.X) (w : i.hom ‚â´ t.Œπ = s.Œπ) : s ‚âÖ t
 : irrational (real.sqrt 2)
 : num ‚Üí ‚Ñï ‚Üí bool
{Œ± : Type} (tac : tactic Œ±) : tactic (list (option Œ±))
(c : cardinal) : ordinal
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] (C : chain_complex V ‚Ñï) (X : V) (f : C ‚ü∂ (chain_complex.single‚ÇÄ V).obj X) : chain_complex V ‚Ñï
 : onote ‚Üí onote ‚Üí onote
(ns : list name) : tactic (list expr)
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] : ordnode Œ± ‚Üí ordnode Œ±
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) (P : Type u_6) (Q : Type u_7) [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [add_comm_monoid Q] [module R M] [module R N] [module R P] [module R Q] : tensor_product R (M ‚Üí‚Çó[R] P) (N ‚Üí‚Çó[R] Q) ‚Üí‚Çó[R] tensor_product R M N ‚Üí‚Çó[R] tensor_product R P Q
(n : name) : tactic tactic.decl_reducibility
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (f : M ‚Üí* N) (N' : submonoid N) : ‚Ü•(submonoid.comap f N') ‚Üí* ‚Ü•N'
{A : Type v} [ring A] : has_bracket A A
{A : Type u} [category_theory.category A] [category_theory.abelian A] {X Y Z : A} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (w : f ‚â´ g = 0) : A
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [fintype Œπ] : filter.Coprod (Œª (i : Œπ), filter.cofinite) = filter.cofinite
{R : Type u} {S : Type v} [ring R] [ring S] (f : R ‚Üí+* S) (hf : function.surjective ‚áëf) : f.range = ‚ä§
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] [complete_lattice Œ≤] (f : Œ± ‚Üí Œ≤) : finset.univ.inf f = infi f
 : omega.nat.preform ‚Üí Prop
{Œ± : Type u_1} {A : Type u_3} [add_group A] [monoid Œ±] [distrib_mul_action Œ± A] : mul_action Œ± (add_subgroup A)
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] [category_theory.limits.has_limits_of_shape J·µí·µñ C] : category_theory.limits.has_colimits_of_shape J C·µí·µñ
 : Fintype ‚•§ Profinite
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤] : continuous_map.compact_open = continuous_map.compact_convergence_topology
{Œ± : Type u} [preorder Œ±] {f : ‚Ñ§ ‚Üí Œ±} (hf : monotone f) (n : ‚Ñ§) {x : Œ±} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ‚Ñ§) : f a ‚â† x
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [decidable_eq Œπ] [Œ† (i : Œπ), decidable_eq (Œ± i)] [Œ† (i : Œπ), has_zero (Œ± i)] (f : Œ†‚ÇÄ (i : Œπ), Œ± i) : Œ†‚ÇÄ (i : Œπ), finset (Œ± i)
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k ‚Üí PE) (a b : k) : E
 : linarith.preprocessor
{Œ± : Type u_1} [topological_space Œ±] {Œπ : Type u_2} [encodable Œπ] {s : Œπ ‚Üí set Œ±} (hs : ‚àÄ (n : Œπ), measure_theory.analytic_set (s n)) : measure_theory.analytic_set (‚ãÉ (n : Œπ), s n)
{A : Type u_5} [comm_ring A] {m : Type u_6} {n : Type u_7} [fintype m] [fintype n] [decidable_eq m] [decidable_eq n] {M : matrix m n A} {M' : matrix n m A} {N : matrix n n A} (hMM' : M.mul M' = 1) (hM'M : M'.mul M = 1) : ((M.mul N).mul M').det = N.det
(R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) (h : v ‚â† 0) : module.ray R M
{ùïú : Type u_2} {E : Type u_5} {F : Type u_6} [comm_semiring ùïú] [add_comm_monoid E] [module ùïú E] [add_comm_monoid F] [module ùïú F] (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú) : Type u_5
 : turing.to_partrec.code
(z : ‚ÑÇ) : ‚ÑÇ
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_equalizer f g] [category_theory.limits.has_equalizer (G.map f) (G.map g)] [i : category_theory.is_iso (category_theory.limits.equalizer_comparison f g G)] : category_theory.limits.preserves_limit (category_theory.limits.parallel_pair f g) G
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] (g : R ‚âÉ+* S) : R ‚âÉ‚Çó[R] S
{G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] (K‚ÇÄ : topological_space.positive_compacts G) (K : topological_space.compacts G) : ‚Ñù
{o : ordinal} {f : Œ† (b : ordinal), b < o ‚Üí ordinal ‚Üí ordinal} (H : ‚àÄ (i : ordinal) (hi : i < o), ordinal.is_normal (f i hi)) : set.unbounded has_lt.lt (‚ãÇ (i : ordinal) (hi : i < o), function.fixed_points (f i hi))
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (n : zmod 2) {P : Œ† (x : clifford_algebra Q), x ‚àà clifford_algebra.even_odd Q n ‚Üí Prop} (hr : ‚àÄ (v : clifford_algebra Q) (h : v ‚àà (clifford_algebra.Œπ Q).range ^ n.val), P v _) (hadd : ‚àÄ {x y : clifford_algebra Q} {hx : x ‚àà clifford_algebra.even_odd Q n} {hy : y ‚àà clifford_algebra.even_odd Q n}, P x hx ‚Üí P y hy ‚Üí P (x + y) _) (hŒπŒπ_mul : ‚àÄ (m‚ÇÅ m‚ÇÇ : M) {x : clifford_algebra Q} {hx : x ‚àà clifford_algebra.even_odd Q n}, P x hx ‚Üí P (‚áë(clifford_algebra.Œπ Q) m‚ÇÅ * ‚áë(clifford_algebra.Œπ Q) m‚ÇÇ * x) _) (x : clifford_algebra Q) (hx : x ‚àà clifford_algebra.even_odd Q n) : P x hx
{Œ± : Type u} (c : computation Œ±) : computation Œ±
{M : Type u_1} [has_mul M] (S : subsemigroup M) : set M
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± ‚Ñ±' : category_theory.Sheaf K A} (Œ± : ‚Ñ± ‚ü∂ ‚Ñ±') (i : category_theory.is_iso (category_theory.whisker_left G.op Œ±.val)) : category_theory.is_iso Œ±
{R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] [is_noetherian R M] {s : set M} (hi : linear_independent R coe) : s.finite
{Œ± : Type u_2} {G : Type u_6} [add_comm_monoid Œ±] [add_comm_group G] {A : set Œ±} {n : ‚Ñï} : has_sub (A ‚Üí+[n] G)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ (w+1) (w'+1))
{ùïú : Type u_1} {F : Type u_3} [is_R_or_C ùïú] [add_comm_group F] [module ùïú F] [c : inner_product_space.core ùïú F] (x : F) : ‚Ñù
{Œ± : Type u} {f : ultrafilter Œ±} {p : Œ± ‚Üí Prop} : (‚àÉ·∂† (x : Œ±) in ‚Üëf, p x) ‚Üí (‚àÄ·∂† (x : Œ±) in ‚Üëf, p x)
{Œπ : Type u‚ÇÅ} {k : Type u‚ÇÇ} {V : Type u‚ÇÉ} {P : Type u‚ÇÑ} [add_comm_group V] [add_torsor V P] [comm_ring k] [module k V] [decidable_eq Œπ] [fintype Œπ] (b b‚ÇÇ : affine_basis Œπ k P) (x : P) : matrix.vec_mul (‚áë(b.coords) x) (b.to_matrix b‚ÇÇ.points)‚Åª¬π = ‚áë(b‚ÇÇ.coords) x
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} [dec_Œπ : decidable_eq Œπ] {v : Œπ ‚Üí E} : orthonormal ùïú v ‚Üî ‚àÄ (i j : Œπ), has_inner.inner (v i) (v j) = ite (i = j) 1 0
{C : Type u‚ÇÅ} [category_theory.category C] : C ‚âå ulift C
 : Type
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] (f : E ‚ÜíL[ùïú] F ‚ÜíL[ùïú] G) : continuous (function.uncurry (Œª (x : E) (y : F), ‚áë(‚áëf x) y))
(R : Type u_1) [semiring R] : R·µê·µí·µñ ‚âÉ+* module.End R R
{Œ≤ : Type v} [has_zero Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_scalar ‚Ñï Œ≤] {Œ± : Type u} [semiring Œ±] [has_one Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ± ‚Üí Œ≤) (hf : function.surjective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ±) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ±) (n : ‚Ñï), f (x ^ n) = f x ^ n) : semiring Œ≤
{q : ‚Ñö} (q_pos : 0 < q) : (generalized_continued_fraction.int_fract_pair.of q‚Åª¬π).fr.num < q.num
{Œ± : Type u_1} [has_lt Œ±] {a b : Œ±} (h : a < b) : ¬¨a ‚ãñ b ‚Üí (‚àÉ (c : Œ±), a < c ‚àß c < b)
{R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (e : R ‚âÉ+* S) : R ‚Üí* S
 : Type (u+1)
 : category_theory.limits.walking_cospan
{G : Type u_1} [measurable_space G] [add_group G] [has_measurable_add G] (g : G) : G ‚âÉ·µê G
{Œ± : Type u_1} [linear_ordered_field Œ±] {a b : Œ±} (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b ‚Üî b < a
(G : Type u_1) [comm_group G] [topological_space G] [topological_group G] : uniform_space G
{X Y : Top} (f : X ‚ü∂ Y) : topological_space.opens ‚Ü•Y ‚•§ topological_space.opens ‚Ü•X
(G : Type u_1) [add_group G] : set G
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (f : M ‚Üí+ P) : add_con M
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [dec_irr : Œ† (p : associates Œ±), decidable (irreducible p)] [decidable_eq (associates Œ±)] (p : associates Œ±) : associates.factor_set Œ± ‚Üí ‚Ñï
(R : Type u) {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] {A : Type u_1} [semiring A] [has_scalar R A] [Œ† (i : Œπ), module A (M‚ÇÅ i)] [module A M‚ÇÇ] [‚àÄ (i : Œπ), is_scalar_tower R A (M‚ÇÅ i)] [is_scalar_tower R A M‚ÇÇ] (f : multilinear_map A M‚ÇÅ M‚ÇÇ) : multilinear_map R M‚ÇÅ M‚ÇÇ
{Œ± : Type u_1} [lattice Œ±] [is_modular_lattice Œ±] (a b : Œ±) : ‚Ü•(set.Icc (a ‚äì b) a) ‚âÉo ‚Ü•(set.Icc b (a ‚äî b))
 : Mon ‚•§ Mon_ (Type u)
{M : Type u_1} [add_comm_semigroup M] {A : Type u_2} [set_like A M] [add_mem_class A M] (S : A) : add_comm_semigroup ‚Ü•S
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {T : Type u‚ÇÉ} [category_theory.category T] (L : A ‚•§ T) {R‚ÇÅ R‚ÇÇ R‚ÇÉ : B ‚•§ T} (r : R‚ÇÅ ‚ü∂ R‚ÇÇ) (r' : R‚ÇÇ ‚ü∂ R‚ÇÉ) : category_theory.comma.map_right L (r ‚â´ r') ‚âÖ category_theory.comma.map_right L r ‚ãô category_theory.comma.map_right L r'
{R : Type u_1} [normed_ring R] (k : ‚Ñï) {r : ‚Ñù} (hr : 1 < r) : (Œª (n : ‚Ñï), ‚Üën ^ k) =o[filter.at_top] Œª (n : ‚Ñï), r ^ n
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) : Prop
(l : list (name √ó binder_info √ó expr)) : tactic string
(k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s t : set P) : affine_span k (s ‚à™ t) = affine_span k s ‚äî affine_span k t
(Œ± : Type u) : Type u
(R : Type u) [comm_semiring R] : polynomial R ‚âÉ‚Çê[R] add_monoid_algebra R ‚Ñï
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {P Q : C} (f : P ‚ü∂ Q) : category_theory.abelian.coimage.œÄ f ‚â´ category_theory.abelian.factor_thru_coimage f = f
{Œπ : Type v} {Œ≤ : Œπ ‚Üí Type w} [Œ† (i : Œπ), add_comm_monoid (Œ≤ i)] {Œ∫ : Type u_1} (h : Œπ ‚âÉ Œ∫) : direct_sum Œπ (Œª (i : Œπ), Œ≤ i) ‚âÉ+ direct_sum Œ∫ (Œª (k : Œ∫), Œ≤ (‚áë(h.symm) k))
{Œ± : Type u} [emetric_space Œ±] [complete_space Œ±] : is_closed (set.range topological_space.nonempty_compacts.to_closeds)
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x : V) (Œ∏ : real.angle) : x = ‚áë(o.rotation Œ∏) x ‚Üî x = 0 ‚à® Œ∏ = 0
{C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] [category_theory.limits.has_colimits C] (F : J ‚•§ C) : (‚àê Œª (j : J), F.obj j) ‚ü∂ category_theory.limits.colimit F
{Œπ : Type w} [fintype Œπ] (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] {R : Type z} [comm_ring R] [algebra R K] [algebra R L] [is_scalar_tower R K L] {b : Œπ ‚Üí L} (h : ‚àÄ (i : Œπ), is_integral R (b i)) : is_integral R (algebra.discr K b)
{ùïú : Type u_3} [is_R_or_C ùïú] {G : Type u_4} [normed_group G] [normed_space ùïú G] {H : Type u_5} [normed_group H] [normed_space ùïú H] {f : G ‚Üí H} {f' : G ‚Üí (G ‚ÜíL[ùïú] H)} {x : G} (hder : ‚àÄ·∂† (y : G) in nhds x, has_fderiv_at f (f' y) y) (hcont : continuous_at f' x) : has_strict_fderiv_at f (f' x) x
{R : Type u} [ring R] (s : subring R) : ‚Ü•s ‚Üí+* R
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_assoc_semiring Œ±} {rŒ≤ : non_assoc_semiring Œ≤} (f : Œ± ‚Üí+* Œ≤) [nontrivial Œ≤] : nontrivial Œ±
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] [compact_space Œ±] [compact_space Œ≤] : compact_space (Œ± √ó Œ≤)
{K : Type u_1} [field K] {p : ‚Ñï} [char_p K p] {t : ‚Ñï} (not_dvd : ¬¨p ‚à£ t) : invertible ‚Üët
{ùïú : Type u_3} {E : Type u_4} [semi_normed_ring ùïú] [add_comm_group E] [module ùïú E] (p : seminorm ùïú E) (x y : E) : ‚áëp x ‚â§ ‚áëp y + ‚áëp (x - y)
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} [is_trichotomous Œ± r] [is_asymm Œ≤ s] (f : Œ± ‚Üí Œ≤) (H : ‚àÄ (a b : Œ±), r a b ‚Üí s (f a) (f b)) : r ‚Ü™r s
{Œ± : Type u_2} {Œ≤ : Type u_3} {r : Œ± ‚Üí Œ≤ ‚Üí Prop} : (concept Œ± Œ≤ r)·µí·µà ‚âÉo concept Œ≤ Œ± (function.swap r)
{n : ‚Ñï} : bitvec n ‚Üí bitvec n ‚Üí bool
{Œ≤ Œ± : Type u} (f : Œ≤ ‚Üí Œ±) (w : cardinal.mk Œ± < cardinal.mk Œ≤) (w' : cardinal.aleph_0 ‚â§ cardinal.mk Œ±) : ‚àÉ (a : Œ±), cardinal.mk Œ± < cardinal.mk ‚Ü•(f ‚Åª¬π' {a})
{R : Type u_1} {S : Type u_3} [non_unital_comm_ring R] [non_unital_comm_ring S] : non_unital_comm_ring (R √ó S)
(L : first_order.language) : Prop
{Œ± : Sort u_1} (hh : Œ±) {Œ≤ : Prop} (x : tactic.calculated_Prop Œ≤ hh . "derive_elementwise_proof") : Œ≤
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} {F : Top.presheaf C X} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) {G : Top.presheaf C X} (Œ± : F ‚âÖ G) : Top.presheaf.sheaf_condition_equalizer_products.pi_inters F U ‚âÖ Top.presheaf.sheaf_condition_equalizer_products.pi_inters G U
(o : ordinal) : ordinal
{R : Type u} [semiring R] {p : polynomial R} {n : ‚Ñï} : p.degree ‚â§ ‚Üën ‚Üí p.nat_degree ‚â§ n
 : tactic.rcases_patt ‚Üí expr ‚Üí tactic (list tactic.uncleared_goal)
{ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_3} [ordered_semiring ùïú] [add_comm_group E] [module ùïú E] {p : Œπ ‚Üí E} (hc : convex_independent ùïú p) : function.injective p
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop
{Œ± : Type u} [complete_lattice Œ±] {J : Type u} [category_theory.small_category J] (F : J ‚•§ Œ±) : category_theory.limits.colimit F = supr F.obj
(p : interactive.parse (lean.parser.many interactive.types.ident_)) : tactic unit
{Œ± : Type u_1} (x : Œ±) : list Œ± ‚Üí Prop
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f g : Œ± ‚Üí M} {s : set Œ±} (hs : s.finite) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i + g i)) = finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)) + finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), g i))
{R : Type u_1} [ring R] {M : Type u_3} [topological_space M] [add_comm_group M] [module R M] [topological_add_group M] (f : M ‚âÉL[R] M) : (M ‚ÜíL[R] M)À£
(s : ‚ÑÇ) (X : ‚Ñù) : ‚ÑÇ
(red : tactic.transparency) {v : Type} (m : list (expr √ó v)) (e : expr) : tactic (expr √ó v)
{m : Type u_2} {n : Type u_3} {o : Type u_4} {Œ± : Type u_12} (M : matrix (m √ó o) (n √ó o) Œ±) (k : o) : matrix m n Œ±
{Œ± : Type u} [lattice Œ±] [bounded_order Œ±] (x y : Œ±) : Prop
{Œ± : Type u_1} [ring Œ±] (t : ring_topology Œ±) : add_group_topology Œ±
(Œ± : Type u_1) [fintype Œ±] : finite Œ±
{m : Type u} {Œ± : Type v} [comm_ring Œ±] [fintype m] [decidable_eq m] (u v : m ‚Üí Œ±) : (1 + (matrix.col u).mul (matrix.row v)).det = 1 + matrix.dot_product v u
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.pos_mul_strict_mono Œ±] (ha : a ‚â§ 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1
 : list expr ‚Üí tactic bool
 : expr ‚Üí bool
{R S : CommRing} (f : R ‚ü∂ S) : algebraic_geometry.Spec.Top_obj S ‚ü∂ algebraic_geometry.Spec.Top_obj R
{K : Type u_1} [field K] (R : valuation_subring K) : ‚Ü•R ‚Üí+* K
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) : 0 ‚â§ s.circumradius
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [comm_monoid Œ≤] [comm_monoid Œ≥] (g : Œ≤ ‚Üí* Œ≥) (f : Œ± ‚Üí Œ≤) (s : finset Œ±) : ‚áëg (s.prod (Œª (x : Œ±), f x)) = s.prod (Œª (x : Œ±), ‚áëg (f x))
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) {A A' B B' : C} [category_theory.limits.has_binary_product A B] [category_theory.limits.has_binary_product A' B'] [category_theory.limits.has_binary_product (F.obj A) (F.obj B)] [category_theory.limits.has_binary_product (F.obj A') (F.obj B')] (f : A ‚ü∂ A') (g : B ‚ü∂ B') [category_theory.is_iso (category_theory.limits.prod_comparison F A B)] [category_theory.is_iso (category_theory.limits.prod_comparison F A' B')] : category_theory.inv (category_theory.limits.prod_comparison F A B) ‚â´ F.map (category_theory.limits.prod.map f g) = category_theory.limits.prod.map (F.map f) (F.map g) ‚â´ category_theory.inv (category_theory.limits.prod_comparison F A' B')
{M : Type u_1} {Œ± : Type u_6} [monoid M] (f : M ‚Üí* function.End Œ±) : mul_action M Œ±
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s : set P} (h : affine_span k s = ‚ä§) : vector_span k s = ‚ä§
{K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] {x : S} (hx : is_integral K x) : power_basis K ‚Ü•(algebra.adjoin K {x})
{Œ± : Type u_1} [pseudo_emetric_space Œ±] {Œ¥seq : ‚Ñï ‚Üí ‚Ñù} (Œ¥seq_pos : ‚àÄ (n : ‚Ñï), 0 < Œ¥seq n) (Œ¥seq_lim : filter.tendsto Œ¥seq filter.at_top (nhds 0)) (E : set Œ±) : filter.tendsto (Œª (n : ‚Ñï), ‚áë(thickened_indicator _ E)) filter.at_top (nhds ((closure E).indicator (Œª (x : Œ±), 1)))
(K : Type u_3) (V : Type u_6) [field K] [add_comm_group V] [module K V] (x : V) (h : x ‚â† 0) : ‚Ü•(submodule.span K {x}) ‚âÉ‚Çó[K] K
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ‚Ñù P) (i : fin 3) : affine_span ‚Ñù {t.orthocenter, t.points i} ‚â§ affine.simplex.altitude t i
{C : Type u} [category_theory.category C] {F‚ÇÅ F‚ÇÇ : C ‚•§ Type w} (Œ± : F‚ÇÅ ‚ü∂ F‚ÇÇ) : F‚ÇÅ.elements ‚•§ F‚ÇÇ.elements
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {E' : Type u_4} [normed_group E'] [normed_space ùïú E'] {F' : Type u_5} [normed_group F'] [normed_space ùïú F'] {s : set E} {t : set E'} {f : E ‚Üí F} {g : E' ‚Üí F'} (hf : cont_diff_on ùïú n f s) (hg : cont_diff_on ùïú n g t) : cont_diff_on ùïú n (prod.map f g) (s √óÀ¢ t)
{K : Type u_1} [is_R_or_C K] : K ‚âÉ‚Çó·µ¢[‚Ñù] K
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (e : M ‚âÉ+ N) (S : add_submonoid M) : ‚Ü•S ‚âÉ+ ‚Ü•(add_submonoid.map e.to_add_monoid_hom S)
(n : name) : tactic pexpr
(e : pexpr) : name
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {f : F ‚Üí G} (hf : cont_diff ùïú n f) : cont_diff ùïú n (Œª (x : E √ó F), f x.snd)
{Œ± : Type u_1} [decidable_eq Œ±] {s : finset Œ±} : s.nonempty ‚Üí s.sym2.nonempty
 : FinBoolAlg ‚âå FinBoolAlg
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [decidable_eq Œπ] [add_monoid Œπ] [comm_semiring R] [semiring A] [algebra R A] (ùíú : Œπ ‚Üí submodule R A) [graded_algebra ùíú] : A ‚âÉ‚Çê[R] direct_sum Œπ (Œª (i : Œπ), ‚Ü•(ùíú i))
(M : Type u_1) [has_add M] : add_hom M M
(m : Type u_2) (o : Type u_4) (Œ± : Type u_12) [decidable_eq o] [decidable_eq m] [fintype o] [fintype m] [non_assoc_semiring Œ±] : (o ‚Üí matrix m m Œ±) ‚Üí+* matrix (m √ó o) (m √ó o) Œ±
{X : UniformSpace} {Y : CpltSepUniformSpace} (f : X ‚ü∂ (category_theory.forget‚ÇÇ CpltSepUniformSpace UniformSpace).obj Y) : UniformSpace.completion_functor.obj X ‚ü∂ Y
{M : Type u_4} [topological_space M] [monoid M] [has_continuous_mul M] {U : set M} (hU : U ‚àà nhds 1) : ‚àÉ (V : set M), is_open V ‚àß 1 ‚àà V ‚àß V * V ‚äÜ U
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] {p : formal_multilinear_series ùïú E F} {x : E} (h : has_fpower_series_at 0 p x) (n : ‚Ñï) (y : E) : ‚áë(p n) (Œª (i : fin n), y) = 0
(Œ± : Type u) {Œ≤ : Type v} [group Œ±] [mul_action Œ± Œ≤] (b : Œ≤) : ‚Ü•(mul_action.orbit Œ± b) ‚âÉ Œ± ‚ß∏ mul_action.stabilizer Œ± b
(J : Type v) : category_theory.limits.wide_pullback_shape_op J ‚ãô category_theory.limits.wide_pushout_shape_unop J ‚âÖ ùü≠ (category_theory.limits.wide_pullback_shape J)
{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {K : nnreal} {f : Œ± ‚Üí Œ≤} : lipschitz_with K f ‚Üí ‚àÄ (x y : Œ±), has_dist.dist (f x) (f y) ‚â§ ‚ÜëK * has_dist.dist x y
(R : Type u) [ring R] [strong_rank_condition R] {Œπ : Type v} [fintype Œπ] (M : Œπ ‚Üí Type w) [Œ† (i : Œπ), add_comm_group (M i)] [Œ† (i : Œπ), module R (M i)] [‚àÄ (i : Œπ), module.free R (M i)] [‚àÄ (i : Œπ), module.finite R (M i)] : finite_dimensional.finrank R (direct_sum Œπ (Œª (i : Œπ), M i)) = finset.univ.sum (Œª (i : Œπ), finite_dimensional.finrank R (M i))
(L : first_order.language) (M : Type w) (N : Type w') [L.Structure M] [L.Structure N] : Type (max w w')
{Œ± : Type} (p : parser Œ±) : Prop
{R : Type u} [comm_semiring R] {A : Type v‚ÇÅ} [semiring A] [algebra R A] {B : Type v‚ÇÇ} [semiring B] [algebra R B] : B ‚Üí‚Çê[R] tensor_product R A B
{Œ± : Type u_1} [has_le Œ±] (s : set Œ±) : Prop
 : nat.partrec.code
(t : omega.term) : omega.eqelim (‚Ñ§ √ó ‚Ñï √ó omega.term)
(dict : name_map name) (replace_all trace : bool) (relevant : name_map ‚Ñï) (ignore reorder : name_map (list ‚Ñï)) (src tgt : name) (attrs : list name) : tactic unit
(M : Type u_12) (N : Type u_13) [has_mul M] [has_mul N] : Type (max u_12 u_13)
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [partial_order Œπ] [order_top Œπ] [Œ† (i : Œπ), preorder (Œ± i)] [order_top (Œ± ‚ä§)] : order_top (Œ£‚Çó (i : Œπ), Œ± i)
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [module ùïú E] [has_scalar ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} (hf : concave_on ùïú s f) (c : E) : concave_on ùïú ((Œª (z : E), c + z) ‚Åª¬π' s) (f ‚àò Œª (z : E), z + c)
{n : ‚Ñï} (Œ± : typevec n) {Œ≤ : Type u_1} (p : Œ≤ ‚Üí Œ≤ ‚Üí Prop) : ((Œ± ::: Œ≤).prod (Œ± ::: Œ≤)).arrow (typevec.repeat (n + 1) Prop)
{Œπ : Type u_1} (A : Œπ ‚Üí Type u_2) [add_comm_monoid Œπ] : Type (max u_1 u_2)
(R : Type u_1) (m : Type u_2) (n : Type u_3) [fintype m] [fintype n] [semiring R] : basis (m √ó n) R (matrix m n R)
{Œ± : Type u_1} [monoid Œ±] (a : Œ±) : conj_classes Œ±
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [no_min_order Œ±] [densely_ordered Œ±] {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (set.Iic a) ‚Üî ‚àÉ (l : Œ±), l < a ‚àß set.Icc l a ‚äÜ s
{m : Type u_2} {n : Type u_3} (R : Type u_11) [comm_semiring R] [fintype n] [fintype m] [decidable_eq m] [decidable_eq n] (e : m ‚âÉ n) : matrix m m R ‚âÉ‚Çê[R] matrix n n R
{p a b : ‚Ñï} (hab : a.coprime b) (hpb : p ‚àà b.factors) : ‚áë((a * b).factorization) p = ‚áë(b.factorization) p
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : with_zero (multiplicative ‚Ñ§)
{Œ± : Type u_1} {n : ‚Ñï} (i : fin2 n) (v : vector3 Œ± n) : Œ±
{n : ‚Ñï+} {K : Type u_1} [field K] (L : Type u_2) [field L] [algebra K L] [is_cyclotomic_extension {n} K L] (h : irreducible (polynomial.cyclotomic ‚Üën K)) [ne_zero ‚Üë‚Üën] : (L ‚âÉ‚Çê[K] L) ‚âÉ* (zmod ‚Üën)À£
{A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] {x : B} (hx : is_integral A x) : 0 < (minpoly A x).degree
(n : ‚Ñï) (q : tactic.interactive.rw_rules_t) (path : list expr_lens.dir) (h : option expr) : tactic tactic.nth_rewrite.tracked_rewrite
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Z‚ÇÅ Z‚ÇÇ : C} (g‚ÇÅ : Z‚ÇÅ ‚ü∂ X‚ÇÅ) (g‚ÇÇ : Z‚ÇÅ ‚ü∂ X‚ÇÇ) (g‚ÇÉ : Z‚ÇÇ ‚ü∂ X‚ÇÇ) (g‚ÇÑ : Z‚ÇÇ ‚ü∂ X‚ÇÉ) [category_theory.limits.has_pushout g‚ÇÅ g‚ÇÇ] [category_theory.limits.has_pushout g‚ÇÉ g‚ÇÑ] [category_theory.limits.has_pushout g‚ÇÅ (g‚ÇÇ ‚â´ category_theory.limits.pushout.inl)] : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (category_theory.limits.pushout.desc category_theory.limits.pushout.inl (category_theory.limits.pushout.inl ‚â´ category_theory.limits.pushout.inr) _) (category_theory.limits.pushout.inr ‚â´ category_theory.limits.pushout.inr) _)
(G : Type u) : Type u
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [Œ† (i : Œπ), add_zero_class (Œ≤ i)] : (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚Üí+ Œ† (i : Œπ), Œ≤ i
{Œ± : Type u_1} [fintype Œ±] (h : 0 < fintype.card Œ±) : trunc Œ±
{g : ‚ÑÇ ‚ÜíL[‚Ñù] ‚ÑÇ} : is_conformal_map g ‚Üî ((‚àÉ (map : ‚ÑÇ ‚ÜíL[‚ÑÇ] ‚ÑÇ), continuous_linear_map.restrict_scalars ‚Ñù map = g) ‚à® ‚àÉ (map : ‚ÑÇ ‚ÜíL[‚ÑÇ] ‚ÑÇ), continuous_linear_map.restrict_scalars ‚Ñù map = g.comp ‚Üëcomplex.conj_cle) ‚àß g ‚â† 0
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [semiring R‚ÇÅ] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : submodule R‚ÇÅ M‚ÇÅ
{Œ± : Type u_1} [has_le Œ±] {a : Œ±} : is_min a ‚Üí is_max (‚áëorder_dual.to_dual a)
{Œ± : Type} (ts : list (tactic Œ±)) : tactic Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {x y z : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (hz : z ‚â† 0) : hb.oangle (-x) y + hb.oangle (-y) z + hb.oangle (-z) x = ‚Üëreal.pi
(k : Type u_1) {V1 : Type u_2} (P1 : Type u_3) {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] (p : P2) : P1 ‚Üí·µÉ[k] P2
{V : Type u_1} [inner_product_space ‚Ñù V] {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) : real.sin (inner_product_geometry.angle x y + inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = 0
(m n : ‚Ñï) : nat.fib (m.gcd n) = (nat.fib m).gcd (nat.fib n)
 : Compactum ‚•§ CompHaus
(Œ∏ : real.angle) : ‚Ñù
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : matrix n n R ‚Üí* R
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) : list Œ± ‚Üí Prop
{p : ‚Ñï+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero ‚Üë‚Üëp] [hpri : fact (nat.prime ‚Üëp)] [hcyc : is_cyclotomic_extension {p} K L] (hirr : irreducible (polynomial.cyclotomic ‚Üëp K)) (h : p ‚â† 2) : ‚áë(algebra.norm K) (is_cyclotomic_extension.zeta p K L - 1) = ‚Üëp
{Œ± Œ≤ : Type u_1} [decidable_eq Œ≤] (s : set Œ±) [fintype ‚Ü•s] (f : Œ± ‚Üí set Œ≤) (H : Œ† (a : Œ±), a ‚àà s ‚Üí fintype ‚Ü•(f a)) : fintype ‚Ü•(s >>= f)
{Œ± : Type u} {a : Œ±} (s : set Œ±) [fintype ‚Ü•s] (h : a ‚àâ s) : fintype ‚Ü•(has_insert.insert a s)
{Œ± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Œ± ‚Üí E} {g' : Œ± ‚Üí F'} {l : filter Œ±} : f =o[l] g' ‚Üí (f =o[l] Œª (x : Œ±), -g' x)
(x : ‚Ñù) : real.sqrt (1 + real.sinh x ^ 2) = real.cosh x
{C : Type v} [category_theory.small_category C] (X : C·µí·µñ) : category_theory.limits.is_colimit (category_theory.coyoneda.colimit_cocone X)
{Œ± : Type u_1} [semilattice_inf Œ±] [order_top Œ±] (s : multiset Œ±) : Œ±
{ùïú : Type u_1} {V : Type u_2} {V‚ÇÇ : Type u_4} {P : Type u_8} {P‚ÇÇ : Type u_9} [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V P] [normed_add_torsor V‚ÇÇ P‚ÇÇ] (e : P ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÇ) : P‚ÇÇ ‚âÉ·µÉ‚Å±[ùïú] P
{Œ± : Type u_1} [complete_lattice Œ±] {a : Œ±} {s : set Œ±} : (‚®Ü (b : Œ±) (H : b ‚àà s), a ‚äì b) ‚â§ a ‚äì has_Sup.Sup s
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : Œ± ‚Üí Œ≤ ‚Üí Prop) : multiset Œ± ‚Üí multiset Œ≤ ‚Üí Prop
 : free ‚ä£ category_theory.forget Mon
{Œ± : Type u_1} [topological_space Œ±] [group_with_zero Œ±] [has_continuous_mul Œ±] (c : Œ±) (hc : c ‚â† 0) : Œ± ‚âÉ‚Çú Œ±
{G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] (K‚ÇÄ : topological_space.positive_compacts G) : measure_theory.measure G
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] (F : Œπ ‚Üí Œ± ‚Üí Œ≤) (f : Œ± ‚Üí Œ≤) (p : filter Œπ) (s : set Œ±) : Prop
{Œ± : Type u} {f g : Œ± ‚Üí Œ±} (h : function.commute f g) : set.bij_on g (function.fixed_points (f ‚àò g)) (function.fixed_points (f ‚àò g))
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.limits.preserves_limit (category_theory.limits.cospan f g) G] [category_theory.limits.has_pullback f g] : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (G.map category_theory.limits.pullback.fst) (G.map category_theory.limits.pullback.snd) _)
{C : Type u‚ÇÅ} [category_theory.category C] (M N : category_theory.comonad C) : Type (max u‚ÇÅ v‚ÇÅ)
(n : ‚Ñï) : finset (fin n)
{Œ± : Type u_2} [has_mul Œ±] : has_mul (set Œ±)
{i : ‚Ñï} {f g : ‚Ñï ‚Üí ‚Ñù} (h0 : ‚àÄ (b : ‚Ñï), 0 ‚â§ f b) (h : ‚àÄ (b : ‚Ñï), f b ‚â§ g b) (hi : f i < g i) (hg : summable g) : ‚àë' (n : ‚Ñï), f n < ‚àë' (n : ‚Ñï), g n
{Œ± : Type u} [topological_space Œ±] {S U Z : set Œ±} (hZ : is_preirreducible Z) (hU : U.nonempty) (hU' : is_open U) (h‚ÇÅ : U ‚äÜ S) (h‚ÇÇ : S ‚äÜ Z) : is_irreducible S
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.monoidal_category C] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) [category_theory.is_equivalence F.to_lax_monoidal_functor.to_functor] [category_theory.left_rigid_category D] : category_theory.left_rigid_category C
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : add_localization S
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] [t1_space Œ≤] {f : Œ± ‚Üí Œ≤} {a : Œ±} {b : Œ≤} (h : filter.tendsto f (nhds a) (nhds b)) : continuous_at f a
{n : Type u} [decidable_eq n] [fintype n] {Œ± : Type v} [comm_ring Œ±] (A : matrix n n Œ±) {Œ≤ : Type u_1} (s : finset Œ≤) (f : Œ≤ ‚Üí n ‚Üí Œ±) : s.sum (Œª (x : Œ≤), ‚áë(A.cramer) (f x)) = ‚áë(A.cramer) (s.sum (Œª (x : Œ≤), f x))
(k : ‚Ñï) : nat.arithmetic_function ‚Ñï
{Œ≤ : Type u} {Œ± : Type v} [comm_monoid Œ≤] (s : finset Œ±) (f : Œ± ‚Üí Œ≤) : Œ≤
{M : Type u_5} {N : Type u_6} {P : Type u_7} [has_add M] [has_add N] [add_comm_semigroup P] (f : add_hom M P) (g : add_hom N P) : add_hom (M √ó N) P
 : has_add pgame
(Œ± : Type u_1) (Œ≤ : Type u_2) : Type (max u_1 u_2)
{Œ≤ : Type w} {C : Type u} [category_theory.category C] {f : Œ≤ ‚Üí C} (t : category_theory.limits.fan f) (lift : Œ† (s : category_theory.limits.fan f), s.X ‚ü∂ t.X) (fac : ‚àÄ (s : category_theory.limits.fan f) (j : Œ≤), lift s ‚â´ t.proj j = s.proj j) (uniq : ‚àÄ (s : category_theory.limits.fan f) (m : s.X ‚ü∂ t.X), (‚àÄ (j : Œ≤), m ‚â´ t.proj j = s.proj j) ‚Üí m = lift s) : category_theory.limits.is_limit t
{M : Type u_3} {N : Type u_4} [has_add M] [has_add N] (f : add_hom M N) {x y : M} (h : x = y) : ‚áëf x = ‚áëf y
(p : ‚Ñï) [fact (nat.prime p)] (hp : p ‚â† 2) : zmod.legendre_sym p (-1) = ‚áëzmod.œá‚ÇÑ ‚Üëp
(e : expr) (n d‚ÇÅ : ‚Ñï) : tactic expr
{J : Type u‚ÇÅ} [category_theory.category J] [category_theory.is_preconnected J] (p : set J) {j‚ÇÄ : J} (h0 : j‚ÇÄ ‚àà p) (h1 : ‚àÄ {j‚ÇÅ j‚ÇÇ : J}, (j‚ÇÅ ‚ü∂ j‚ÇÇ) ‚Üí (j‚ÇÅ ‚àà p ‚Üî j‚ÇÇ ‚àà p)) (j : J) : j ‚àà p
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [nondiscrete_normed_field R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [normed_group F] [normed_space R F] [topological_space B] (a : topological_vector_prebundle R F E) {e : topological_vector_bundle.pretrivialization R F E} (he : e ‚àà a.pretrivialization_atlas) : topological_vector_bundle.trivialization R F E
{S : Type u‚ÇÅ} {L : Type u‚ÇÇ} {D : Type u‚ÇÉ} [category_theory.category S] [category_theory.category L] [category_theory.category D] (Œπ : S ‚•§ L) (F : S ‚•§ D) (x : L) : category_theory.structured_arrow x Œπ ‚•§ D
{Œ± : Type u} [mul_one_class Œ±] [has_distrib_neg Œ±] (a : Œ±) : a * -1 = -a
{C : Type u} [category_theory.category C] (J‚ÇÅ : category_theory.grothendieck_topology C) : C·µí·µñ ‚•§ Type (max v u)
 : first_order.language.order.sentence
{R : Type u_1} [linear_ordered_comm_ring R] (s : subring R) : linear_ordered_comm_ring ‚Ü•s
{G : Type u_1} [group G] [topological_space G] [topological_group G] [t2_space G] {K‚ÇÄ : topological_space.positive_compacts G} (g : G) (K : topological_space.compacts G) : ‚áë(measure_theory.measure.haar.haar_content K‚ÇÄ) (topological_space.compacts.map (Œª (b : G), g * b) _ K) = ‚áë(measure_theory.measure.haar.haar_content K‚ÇÄ) K
{R : Type u_1} [comm_semiring R] {S : Type u_2} [comm_semiring S] [algebra R S] (x : R) [is_localization.away x S] : S
{Œ± : Type u} [ordered_semiring Œ±] [nontrivial Œ±] : 0 < 3
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] : Top.prelocal_predicate (Œª (x : ‚Ü•(projective_spectrum.Top ùíú)), homogeneous_localization ùíú (projective_spectrum.as_homogeneous_ideal x).to_ideal)
{A : Type u_1} {Œπ : Type u_2} [ring A] [nonempty Œπ] {B : Œπ ‚Üí add_subgroup A} (hB : ring_subgroups_basis B) : ring_filter_basis A
{Œπ : Type u_1} {Œ± : Type u_2} {s : Œπ ‚Üí set Œ±} (hs : indexed_partition s) (x : hs.quotient) : hs.index (quotient.out' x) = hs.index (‚áë(hs.out) x)
{R : Type u_1} {n : Type u_4} {Œ± : Type u_5} [fintype n] [normed_field R] [semi_normed_ring Œ±] [normed_algebra R Œ±] [decidable_eq n] : normed_algebra R (matrix n n Œ±)
{n : ‚Ñï} {i‚ÇÅ i‚ÇÇ : fin (n + 3)} (h : i‚ÇÅ ‚â† i‚ÇÇ) : affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter i‚ÇÅ i‚ÇÇ = affine.simplex.monge_point_weights_with_circumcenter n - affine.simplex.centroid_weights_with_circumcenter {i‚ÇÅ, i‚ÇÇ}·∂ú
{Œ± : Type u_1} [linear_order Œ±] (a : Œ±) : {a}.max' _ = a
{f : ‚Ñï ‚Üí. ‚Ñï} : nat.partrec f ‚Üî ‚àÉ (c : nat.partrec.code), c.eval = f
{R : Type u} [ring R] {J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Module R) : has_scalar R ‚Ü•(Module.filtered_colimits.M F)
{Œ± : Type u} (a : Œ±) : wseq Œ± ‚Üí wseq Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {a‚ÇÅ a‚ÇÇ a‚ÇÉ : Œ±} {b‚ÇÅ b‚ÇÇ b‚ÇÉ : Œ≤} (q‚ÇÅ : path.homotopic.quotient a‚ÇÅ a‚ÇÇ) (q‚ÇÇ : path.homotopic.quotient b‚ÇÅ b‚ÇÇ) (r‚ÇÅ : path.homotopic.quotient a‚ÇÇ a‚ÇÉ) (r‚ÇÇ : path.homotopic.quotient b‚ÇÇ b‚ÇÉ) : (path.homotopic.prod q‚ÇÅ q‚ÇÇ).comp (path.homotopic.prod r‚ÇÅ r‚ÇÇ) = path.homotopic.prod (q‚ÇÅ.comp r‚ÇÅ) (q‚ÇÇ.comp r‚ÇÇ)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y Z : C} {c : category_theory.limits.binary_fan X Y} (h : category_theory.limits.is_limit c) (t : category_theory.limits.is_terminal Z) : category_theory.is_pullback c.fst c.snd (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left})) (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right}))
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [locally_compact_space Œ±] : continuous (Œª (p : C(Œ±, Œ≤) √ó Œ±), ‚áë(p.fst) p.snd)
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [unique_factorization_monoid Œ±] [dec : decidable_eq Œ±] [dec' : decidable_eq (associates Œ±)] (a : associates Œ±) : associates.factor_set Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) : real.cos (inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = -real.cos (inner_product_geometry.angle x y)
{C : Type u_1} [category_theory.category C] (G : C ‚•§ Type w) : G.elements ‚•§ category_theory.grothendieck (G ‚ãô category_theory.Type_to_Cat)
{n : ‚Ñï} {Œ± Œ≤ : typevec n} : (Œ±.prod Œ≤).arrow Œ≤
{R : Type u} [ring R] {M : Type u_1} [ordered_add_comm_group M] [module R M] (S : submodule R M) : ordered_add_comm_group ‚Ü•S
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [nondiscrete_normed_field R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [normed_group F] [normed_space R F] [topological_space B] (a : topological_vector_prebundle R F E) : topological_space (bundle.total_space E)
{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a) : is_add_left_regular (a + b) ‚Üî is_add_left_regular b
{n : ‚Ñï} (P : mvpfunctor (n + 1)) (Œ± : typevec n) : Type u
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [invertible 2] : can_lift (bilin_form R M) (quadratic_form R M)
{Œ± : Type u} [pseudo_metric_space Œ±] (B : ‚Ñï ‚Üí ‚Ñù) (hB : ‚àÄ (n : ‚Ñï), 0 < B n) (H : ‚àÄ (u : ‚Ñï ‚Üí Œ±), (‚àÄ (N n m : ‚Ñï), N ‚â§ n ‚Üí N ‚â§ m ‚Üí has_dist.dist (u n) (u m) < B N) ‚Üí (‚àÉ (x : Œ±), filter.tendsto u filter.at_top (nhds x))) : complete_space Œ±
{E : Type u_2} [semi_normed_group E] [normed_space ‚Ñù E] {s : set E} {x : E} (hx : x ‚àà ‚áë(convex_hull ‚Ñù) s) (y : E) : ‚àÉ (x' : E) (H : x' ‚àà s), has_dist.dist x y ‚â§ has_dist.dist x' y
{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] (g : G) : continuous (Œª (h : G), g * h * g‚Åª¬π)
{Œ± : Type u_1} [metric_space Œ±] (t : set (set Œ±)) (R : ‚Ñù) (ht : ‚àÄ (s : set Œ±), s ‚àà t ‚Üí (‚àÉ (x : Œ±) (r : ‚Ñù), s = metric.closed_ball x r ‚àß r ‚â§ R)) : ‚àÉ (u : set (set Œ±)) (H : u ‚äÜ t), u.pairwise_disjoint id ‚àß ‚àÄ (a : set Œ±), a ‚àà t ‚Üí (‚àÉ (x : Œ±) (r : ‚Ñù), metric.closed_ball x r ‚àà u ‚àß a ‚äÜ metric.closed_ball x (5 * r))
{V : Type v} [category_theory.category V] [category_theory.monoidal_category V] {C : Type u‚ÇÅ} [category_theory.enriched_category V C] {D : Type u‚ÇÇ} [category_theory.enriched_category V D] [category_theory.braided_category V] (F G : category_theory.enriched_functor V C D) : V·µí·µñ ‚•§ Type (max u‚ÇÅ w)
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (f : M ‚Üí* P) (g : P ‚Üí M) (hf : function.right_inverse g ‚áëf) : (con.ker f).quotient ‚âÉ* P
{Œ± : Type u} [complete_lattice Œ±] {J : Type u} [category_theory.small_category J] (F : J ‚•§ Œ±) : category_theory.limits.limit_cone F
(Œ± : Type u_1) [measurable_space Œ±] : Type u_1
 : num ‚Üí num ‚Üí znum
{ùïú : Type u_1} [linear_ordered_field ùïú] {x y : ùïú} (h : x < y) {z : ùïú} : z ‚àà set.Ico x y ‚Üî ‚àÉ (a b : ùïú), 0 < a ‚àß 0 ‚â§ b ‚àß a + b = 1 ‚àß a * x + b * y = z
{R : Type u} {A : Type v} {B : Type w} [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B] (f : A ‚Üí‚Çô‚Çê[R] B) (g : B ‚Üí A) (h‚ÇÅ : function.left_inverse g ‚áëf) (h‚ÇÇ : function.right_inverse g ‚áëf) : B ‚Üí‚Çô‚Çê[R] A
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [ring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [nonempty Œπ] (f : multilinear_map R M‚ÇÅ M‚ÇÇ) (p : Œ† (i : Œπ), submodule R (M‚ÇÅ i)) : sub_mul_action R M‚ÇÇ
(Œ± : Sort u) [has_variable_names Œ±] {Œ≤ : Sort v} : has_variable_names Œ≤
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (s : multiset Œ±) (comm : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí ‚àÄ (b : Œ≤), f x (f y b) = f y (f x b)) (b : Œ≤) : Œ≤
(C : Type u) [category_theory.category C] : Prop
(M : Type u_1) (Œ± : Type u_2) [monoid M] [topological_space Œ±] [mul_action M Œ±] : Prop
{R : Type u‚ÇÅ} [monoid R] [has_distrib_neg R] (a : R) : (-a) ^ 2 = a ^ 2
{R‚ÇÅ : Type u_2} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_11} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R‚ÇÅ M] [module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} : add_comm_monoid (M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] [no_zero_divisors R] [nontrivial R] : no_zero_smul_divisors R M ‚Üî submodule.torsion R M = ‚ä•
{E : ‚Ñï ‚Üí Type u_1} [Œ† (n : ‚Ñï), topological_space (E n)] [‚àÄ (n : ‚Ñï), discrete_topology (E n)] {x y : Œ† (n : ‚Ñï), E n} {s : set (Œ† (n : ‚Ñï), E n)} (hs : is_closed s) (hne : s.nonempty) (H : pi_nat.longest_prefix x s < pi_nat.first_diff x y) (xs : x ‚àâ s) (ys : y ‚àâ s) : pi_nat.cylinder x (pi_nat.longest_prefix x s) = pi_nat.cylinder y (pi_nat.longest_prefix y s)
(R : CommRing) : algebraic_geometry.Scheme
 : simps_cfg
{Œ± : Type u_1} {Œ≤ : Type u_2} {e e' : local_equiv Œ± Œ≤} (he : e ‚âà e') (s : set Œ±) : e.restr s ‚âà e'.restr s
(Œ± : Type u) : Type u
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u} [category_theory.category C] (F : J ‚•§ C) [category_theory.limits.has_colimit F] (E : K ‚•§ J) [category_theory.limits.has_colimit (E ‚ãô F)] : category_theory.limits.colimit (E ‚ãô F) ‚ü∂ category_theory.limits.colimit F
{X Y : algebraic_geometry.LocallyRingedSpace} (f g : X ‚ü∂ Y) (U : topological_space.opens ‚Ü•((category_theory.limits.coequalizer f.val g.val).to_PresheafedSpace.carrier)) (s : ‚Ü•((category_theory.limits.coequalizer f.val g.val).to_PresheafedSpace.presheaf.obj (opposite.op U))) : topological_space.opens ‚Ü•Y
{Œπ : Type u_1} [decidable_eq Œπ] {A : Œπ ‚Üí Type u_2} {R : Type u_3} [Œ† (i : Œπ), add_comm_monoid (A i)] [add_monoid Œπ] [direct_sum.gsemiring A] [semiring R] : {f // ‚áëf graded_monoid.ghas_one.one = 1 ‚àß ‚àÄ {i j : Œπ} (ai : A i) (aj : A j), ‚áëf (graded_monoid.ghas_mul.mul ai aj) = ‚áëf ai * ‚áëf aj} ‚âÉ (direct_sum Œπ (Œª (i : Œπ), A i) ‚Üí+* R)
{M : Type u_5} {N : Type u_6} {P : Type u_7} [mul_one_class M] [mul_one_class N] [mul_one_class P] (f : M ‚Üí* N) (g : M ‚Üí* P) : M ‚Üí* N √ó P
(n : ‚Ñï) : Type
{R : Type x} [comm_ring R] (a b : R) : a * a - b * b = (a + b) * (a - b)
{M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_3} [has_mul M‚ÇÄ] [has_zero M‚ÇÄ] [has_mul M‚ÇÄ'] [has_zero M‚ÇÄ'] [no_zero_divisors M‚ÇÄ'] (f : M‚ÇÄ ‚Üí M‚ÇÄ') (hf : function.injective f) (zero : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÄ), f (x * y) = f x * f y) : no_zero_divisors M‚ÇÄ
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [locally_compact_space Œ±] [locally_compact_space Œ≤] : continuous continuous_map.uncurry
{Œ± : Type u_1} {n : Type u_4} [add_group n] {v : n ‚Üí Œ±} (h : (matrix.circulant v).is_symm) (i : n) : v (-i) = v i
{Œ± : Type u} {a : set Œ±} (h : a.finite) : {b : set Œ± | b ‚äÜ a}.finite
(R : Type u) {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (s : set A) : subalgebra R A
{V : Type u} (G : simple_graph V) : ‚Ñï
{Œ± : Type u_1} {Œπ : Sort u_2} [nonempty Œπ] (m : Œπ ‚Üí measure_theory.outer_measure Œ±) (s : set Œ±) : (‚áë‚®Ö (i : Œπ), m i) s = ‚®Ö (t : ‚Ñï ‚Üí set Œ±) (h2 : s ‚äÜ set.Union t), ‚àë' (n : ‚Ñï), ‚®Ö (i : Œπ), ‚áë(m i) (t n)
{L : first_order.language} {M : Type u_3} [L.Structure M] (S : L.elementary_substructure M) : L.elementary_embedding ‚Ü•S M
{X Y : Type u} [add_semigroup X] [add_semigroup Y] : X ‚âÉ+ Y ‚âÖ AddSemigroup.of X ‚âÖ AddSemigroup.of Y
(X : Type u) [lattice X] : Type u
{Œ± : Type u} {Œ≤ : Type v} {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} [partial_order Œ±] [complete_lattice Œ≤] (gi : galois_coinsertion l u) : complete_lattice Œ±
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] : equiv.perm (subtype p) ‚âÉ {f // ‚àÄ (a : Œ±), ¬¨p a ‚Üí ‚áëf a = a}
{R : Type u_1} [comm_ring R] {c‚ÇÅ c‚ÇÇ : R} : quaternion_algebra R c‚ÇÅ c‚ÇÇ ‚Üí‚Çê[R] clifford_algebra (clifford_algebra_quaternion.Q c‚ÇÅ c‚ÇÇ)
{R : Type u_1} [comm_semiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} {Q : Type u_7} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [add_comm_monoid Q] [module R M] [module R N] [module R P] [module R Q] (f : M ‚Üí‚Çó[R] P) (g : N ‚Üí‚Çó[R] Q) : tensor_product R M N ‚Üí‚Çó[R] tensor_product R P Q
(M : Type u_5) [monoid M] {R' : Type u_12} [ring R'] [mul_semiring_action M R'] (U : subring R') [is_invariant_subring M U] : ‚Ü•U ‚Üí+*[M] R'
(G : Type u_1) [topological_space G] [add_group G] [topological_add_group G] : add_subgroup G
{ùïú : Type u_1} {E : Type u_2} [linear_ordered_field ùïú] [ordered_add_comm_group E] [module ùïú E] (s : set E) (hs : convex ùïú s) : convex_cone ùïú E
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (c : add_con M) (f : M ‚Üí+ P) (H : c ‚â§ add_con.ker f) (h : function.injective ‚áë(c.lift f H)) : add_con.ker f = c
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] {A B C : matrix n n Œ±} (h : A.mul B = 1) (g : A.mul C = 1) : B = C
{Œ± : Type u} (f : filter Œ±) [h : f.ne_bot] : ‚àÉ (u : ultrafilter Œ±), ‚Üëu ‚â§ f
{K : Type u} {V‚ÇÅ V‚ÇÇ : Type v} [field K] [add_comm_group V‚ÇÅ] [module K V‚ÇÅ] [add_comm_group V‚ÇÇ] [module K V‚ÇÇ] (h : module.rank K V‚ÇÅ = module.rank K V‚ÇÇ) : V‚ÇÅ ‚âÉ‚Çó[K] V‚ÇÇ
(e : expr) : tactic (expr √ó expr)
{G : Type u_1} [topological_space G] [group G] [topological_group G] (N : subgroup G) [N.normal] : N.topological_closure.normal
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) (s : set M) (hs : s = ‚ÜëN) : lie_submodule R L M
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Œπ ‚Üí M} [ring R] [add_comm_group M] [module R M] : linear_independent R v ‚Üí function.injective ‚áë(finsupp.total Œπ M R v)
{Œ± : Sort u} {Œ≤ : Sort v} {Œ≥ : Sort w} [inhabited Œ≥] (e : Œ± ‚Ü™ Œ≤) : (Œ± ‚Üí Œ≥) ‚Ü™ Œ≤ ‚Üí Œ≥
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (F : C ‚•§ D) {G H : D ‚•§ E} (Œ± : G ‚ü∂ H) : F ‚ãô G ‚ü∂ F ‚ãô H
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) : Prop
(k : turing.partrec_to_TM2.K') (q : turing.partrec_to_TM2.Œõ') : turing.partrec_to_TM2.Œõ'
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h : s1 < s2) : ‚àÉ (p : P) (H : p ‚àà s2), p ‚àâ s1
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} : monotone_on f s ‚Üí antitone_on (‚áëorder_dual.to_dual ‚àò f) s
(K : Type u) [division_ring K] {n : ‚Ñï} : finite_dimensional.finrank K (fin n ‚Üí K) = n
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : p -·µ• p = 0
{V : Type u} {G : simple_graph V} (P : G.partition) (n : ‚Ñï) : Prop
{C : Type u} [category_theory.category C] {A B : C} (f g : A ‚ü∂ B) : Prop
{R : Type u} [semiring R] (n : ‚Ñï) : polynomial R ‚Üí polynomial R
(bang : interactive.parse (optional (lean.parser.tk "!"))) : tactic unit
{Œ± : Type u_1} [has_mul Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_lt.lt] {a b c d : Œ±} (h‚ÇÅ : a < b) (h‚ÇÇ : c < d) : a * c < b * d
{Œ± : Type u} [pseudo_metric_space Œ±] [preorder Œ±] [compact_Icc_space Œ±] {s : set Œ±} (h‚ÇÅ : bdd_above s) (h‚ÇÇ : bdd_below s) : metric.bounded s
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] {F : C ‚•§ D} {G : D ‚•§ E} {H : C ‚•§ E} [category_theory.full H] [category_theory.faithful G] (h : F ‚ãô G ‚âÖ H) : category_theory.full F
(f : Set ‚Üí Set) [H : pSet.definable 1 f] : Set ‚Üí Set
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (rk : Œ± ‚Üí ‚Ñï) (s : set Œ±) (n : ‚Ñï) (f : ‚Ñï ‚Üí Œ±) (hf : set.partially_well_ordered_on.is_bad_seq r s f) : {g // (‚àÄ (m : ‚Ñï), m < n ‚Üí f m = g m) ‚àß set.partially_well_ordered_on.is_bad_seq r s g ‚àß set.partially_well_ordered_on.is_min_bad_seq r rk s n g}
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] (h : Œ± ‚âÉ·µ¢ Œ≤) : Œ± ‚âÉ‚Çú Œ≤
{M : Type u_1} [add_monoid M] {x : M} (m : ‚Ñï) {n : ‚Ñï} (h : n ‚Ä¢ x = 0) : m ‚Ä¢ x = (m % n) ‚Ä¢ x
{F : Type u_3} [inner_product_space ‚Ñù F] {x y : F} : has_inner.inner (x - y) (x - y) = has_inner.inner x x - 2 * has_inner.inner x y + has_inner.inner y y
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] (f : L.embedding M N) (p : L.substructure M) : L.embedding ‚Ü•p N
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space F] [complete_space E] (g : E ‚Üí‚Çó[ùïú] F) (hg : ‚àÄ (u : ‚Ñï ‚Üí E) (x : E) (y : F), filter.tendsto u filter.at_top (nhds x) ‚Üí filter.tendsto (‚áëg ‚àò u) filter.at_top (nhds y) ‚Üí y = ‚áëg x) : continuous ‚áëg
{C : Type u} [category_theory.category C] {X : C} (P : C·µí·µñ ‚•§ Type v) (R S : category_theory.sieve X) (hR : category_theory.presieve.is_sheaf_for P ‚áëR) (hR' : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, ‚áëS f ‚Üí category_theory.presieve.is_separated_for P ‚áë(category_theory.sieve.pullback f R)) (hS : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, ‚áëR f ‚Üí category_theory.presieve.is_sheaf_for P ‚áë(category_theory.sieve.pullback f S)) : category_theory.presieve.is_sheaf_for P ‚áëS
 : Type
{Œ± : Type u} (g : set (set Œ±)) : set Œ± ‚Üí Prop
 : list linarith.global_branching_preprocessor
{Œ± : Type u} [preorder Œ±] (s : set Œ±) (a : Œ±) : Prop
{Œ± : Type u_1} {P : set Œ± ‚Üí Prop} (m : Œ† (s : set Œ±), P s ‚Üí ennreal) (P0 : P ‚àÖ) (m0 : m ‚àÖ P0 = 0) : measure_theory.outer_measure Œ±
{V : Type u} {G : simple_graph V} [decidable_eq V] {u v : V} : G.walk u v ‚Üí G.walk u v
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] [add_monoid Œ≤] [has_lipschitz_add Œ≤] : bounded_continuous_function Œ± Œ≤ ‚Üí+ Œ± ‚Üí Œ≤
 : expr ‚Üí tactic expr
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] : category_theory.exponentiable (‚ä§_ C)
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] (f : multilinear_map R M‚ÇÅ M‚ÇÇ) {Œ± : Œπ ‚Üí Type u_1} (g : Œ† (i : Œπ), Œ± i ‚Üí M‚ÇÅ i) (A : Œ† (i : Œπ), finset (Œ± i)) [fintype Œπ] {n : ‚Ñï} (h : finset.univ.sum (Œª (i : Œπ), (A i).card) = n) : ‚áëf (Œª (i : Œπ), (A i).sum (Œª (j : Œ± i), g i j)) = (fintype.pi_finset A).sum (Œª (r : Œ† (a : Œπ), Œ± a), ‚áëf (Œª (i : Œπ), g i (r i)))
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} {c : category_theory.limits.cofork f g} (h : category_theory.limits.is_colimit c) [category_theory.mono c.œÄ] : category_theory.is_iso c.œÄ
{M : Type u_3} {N : Type u_4} [add_monoid M] [add_monoid N] (f : M ‚Üí+ N) (l : list M) : ‚áëf l.sum = (list.map ‚áëf l).sum
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [semiring k] [add_monoid G] : k ‚Üí+* add_monoid_algebra k G
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (G : D ‚•§ C) [‚àÄ (A : C), category_theory.limits.has_terminal (category_theory.costructured_arrow G A)] : C ‚•§ D
{Œ± : Type v} {m l r : ‚Ñï} (A : matrix (fin m) (fin (l + r)) Œ±) : matrix (fin m) (fin l) Œ±
{Œ± : Type u_1} (P : Œ± ‚Üí Prop) (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_symm Œ± r] (h : ‚àÄ (s : finset Œ±), (‚àÄ (x : Œ±), x ‚àà s ‚Üí P x) ‚Üí (‚àÉ (y : Œ±), P y ‚àß ‚àÄ (x : Œ±), x ‚àà s ‚Üí r x y)) : ‚àÉ (f : ‚Ñï ‚Üí Œ±), (‚àÄ (n : ‚Ñï), P (f n)) ‚àß ‚àÄ (m n : ‚Ñï), m ‚â† n ‚Üí r (f m) (f n)
(p : ‚Ñï) [fact (nat.prime p)] (x : (zmod p)À£) : (‚àÉ (y : (zmod p)À£), y ^ 2 = x) ‚Üî x ^ (p / 2) = 1
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (q : trunc Œ±) (f : Œ± ‚Üí Œ≤) (c : ‚àÄ (a b : Œ±), f a = f b) : Œ≤
{X : Top} {x‚ÇÄ x‚ÇÅ : ‚Ü•X} (p : path.homotopic.quotient x‚ÇÄ x‚ÇÅ) : x‚ÇÄ ‚ü∂ x‚ÇÅ
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : M ‚Üí‚Çó[R] module.dual R (module.dual R M)
{p : Prop} (n : ‚Ñï) : slim_check.test_result p ‚Üí slim_check.test_result p
{B : Type u} [quiver B] {a b c : B} (p : quiver.path a b) {f g : category_theory.free_bicategory.hom b c} (Œ∑ : f ‚ü∂ g) : category_theory.free_bicategory.normalize_aux p f = category_theory.free_bicategory.normalize_aux p g
 : category_theory.large_category category_theory.Quiv
{r : ‚Ñù} (tr : transcendental ‚Ñö r) : irrational r
(Œ± : Type u) [monoid Œ±] : Type u
{E : Type u_2} [add_comm_group E] [module ‚Ñù E] (s : convex_cone ‚Ñù E) (f : linear_pmap ‚Ñù E ‚Ñù) (nonneg : ‚àÄ (x : ‚Ü•(f.domain)), ‚Üëx ‚àà s ‚Üí 0 ‚â§ ‚áëf x) (dense : ‚àÄ (y : E), ‚àÉ (x : ‚Ü•(f.domain)), ‚Üëx + y ‚àà s) : ‚àÉ (g : E ‚Üí‚Çó[‚Ñù] ‚Ñù), (‚àÄ (x : ‚Ü•(f.domain)), ‚áëg ‚Üëx = ‚áëf x) ‚àß ‚àÄ (x : E), x ‚àà s ‚Üí 0 ‚â§ ‚áëg x
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] (S : subalgebra R A) (f : A ‚Üí‚Çê[R] B) : subalgebra R B
{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {s : set Œ±} (p : M ‚Üí Prop) (hp‚ÇÄ : p 0) (hp‚ÇÅ : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x + y)) (hp‚ÇÇ : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p (f x)) : p (finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)))
 : snum ‚Üí snum
{M : Type u_1} [add_monoid M] {x y z : M} : y ‚àà multiples x ‚Üí z ‚àà multiples x ‚Üí y + z ‚àà multiples x
{n : ‚Ñï} {E : Type u_1} [normed_group E] (a : E) (c : fin n ‚Üí ‚ÑÇ) (R : fin n ‚Üí ‚Ñù) : torus_integrable (Œª (_x : fin n ‚Üí ‚ÑÇ), a) c R
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) (Œ∏ : real.angle) : hb.oangle (‚áë(hb.rotation Œ∏) x) (‚áë(hb.rotation Œ∏) y) = hb.oangle x y
{M : Type u} [comm_monoid M] (n : ‚Ñï) : M ‚Üí* M
{J : Type v} [category_theory.small_category J] (F : J ‚•§ category_theory.Cat) : category_theory.limits.cone F
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) : P ‚Üí·µÉ[‚Ñù] ‚Ü•(affine_span ‚Ñù (set.range s.points))
{C : Type u} [category_theory.category C] {X Y : C} (Œ± : X ‚âÖ Y) : category_theory.Aut X ‚âÉ* category_theory.Aut Y
{C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X) : Prop
(R : Type u_1) (S : Type u_3) [non_assoc_semiring R] [non_assoc_semiring S] : R √ó S ‚Üí+* R
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (A : C) [category_theory.closed A] : ùü≠ C ‚ü∂ category_theory.monoidal_category.tensor_left A ‚ãô category_theory.ihom A
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (L' : lie_subalgebra R L) : ‚Ü•L' ‚Üí‚Çó‚ÅÖR,‚Ü•L'‚ÅÜ L
(T : Type u_1) : Type u_1
{Œ± : Type u} (x : Œ±) : free_ring Œ±
{K : Type u} [field K] : has_top (subfield K)
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [add_comm_monoid N] [decidable_eq Œ±] (f : Œ± ‚Üí‚ÇÄ M) (a : Œ±) (b : Œ± ‚Üí M ‚Üí N) : f.sum (Œª (x : Œ±) (v : M), ite (x = a) (b x v) 0) = ite (a ‚àà f.support) (b a (‚áëf a)) 0
(p_p q_p : expr) (p q : tactic.ring_exp.coeff) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.prod)
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : Prop
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (i : D ‚•§ C) [category_theory.limits.has_finite_products C] [category_theory.reflective i] [category_theory.cartesian_closed C] [category_theory.exponential_ideal i] (J : Type v‚ÇÅ) [fintype J] : category_theory.limits.preserves_limits_of_shape (category_theory.discrete J) (category_theory.left_adjoint i)
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.has_split_coequalizer f g] : Y ‚ü∂ category_theory.has_split_coequalizer.coequalizer_of_split f g
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x : V) {r : ‚Ñù} (hr : 0 ‚â§ r) : hb.oangle x (r ‚Ä¢ x) = 0
{Œ∫ : Type w} (A : Type u) {B : Type v} (C : Type z) [comm_ring A] [comm_ring B] [algebra A B] [comm_ring C] [algebra A C] (b : Œ∫ ‚Üí B) (e : Œ∫ ‚âÉ (B ‚Üí‚Çê[A] C)) : matrix Œ∫ Œ∫ C
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a : Œ±} : 1 ‚â§ a‚Åª¬π ‚Üî a ‚â§ 1
{R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} (h : same_ray R x y) (hx : x ‚â† 0) : ‚àÉ (r : R), 0 ‚â§ r ‚àß r ‚Ä¢ x = y
{L : first_order.language} (M : Type w') [L.Structure M] [iM : infinite M] (Œ∫ : cardinal) (h1 : L.card.lift ‚â§ Œ∫.lift) (h2 : (cardinal.mk M).lift ‚â§ Œ∫.lift) : ‚àÉ (N : category_theory.bundled L.Structure), nonempty (L.elementary_embedding M ‚Ü•N) ‚àß cardinal.mk ‚Ü•N = Œ∫.lift
{Œ± : Type u_1} [linear_order Œ±] (s : finset Œ±) {k : ‚Ñï} (h : k ‚â§ s.card) : fin k ‚Ü™o Œ±
{Œ± : Type u} {Œ≤ : Type v} : (cardinal.mk Œ±).lift ‚â§ (cardinal.mk Œ≤).lift ‚Üî nonempty (Œ± ‚Ü™ Œ≤)
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} : metric.Hausdorff_dist ‚àÖ s = 0
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) : complete_lattice.independent f.eigenspace
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] (P : C·µí·µñ ‚•§ A) {X : C} (S : category_theory.sieve X) : (‚àÄ (c : category_theory.limits.cone (S.arrows.diagram.op ‚ãô P)), subsingleton (c ‚ü∂ P.map_cone S.arrows.cocone.op)) ‚Üî ‚àÄ (E : A·µí·µñ), category_theory.presieve.is_separated_for (P ‚ãô category_theory.coyoneda.obj E) ‚áëS
(L : list ‚Ñï) : L.head + L.tail.sum = L.sum
{C : Type u} [category_theory.category C] {n : ‚Ñï} {f : ulift (fin (n + 1)) ‚Üí C} (c‚ÇÅ : category_theory.limits.cofan (Œª (i : ulift (fin n)), f {down := i.down.succ})) (c‚ÇÇ : category_theory.limits.binary_cofan (f {down := 0}) c‚ÇÅ.X) : category_theory.limits.cofan f
{a b : ‚Ñï} (ha : a ‚â† 0) (hb : b ‚â† 0) : (a * b).factors ~ a.factors ++ b.factors
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] [category_theory.limits.has_colimits_of_shape J C] (F : K ‚•§ J ‚•§ C) : category_theory.limits.colimit F.flip ‚âÖ F ‚ãô category_theory.limits.colim
{M : Type u_1} {G : Type u_2} [mul_one_class M] [comm_group G] : has_inv (M ‚Üí* G)
{Œ± : Type u} [topological_space Œ±] [t2_space Œ±] [compact_space Œ±] : t2_space (connected_components Œ±)
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.pos_mul_strict_mono Œ±] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
{F : Type u_1} [field F] (p q : polynomial F) : (p * q).gal ‚Üí* p.gal √ó q.gal
{Œπ : Type u} (s : finset Œπ) {f : Œπ ‚Üí ‚Ñù} {p : ‚Ñù} (hp : 1 ‚â§ p) (hf : ‚àÄ (i : Œπ), i ‚àà s ‚Üí 0 ‚â§ f i) : s.sum (Œª (i : Œπ), f i) ^ p ‚â§ ‚Üë(s.card) ^ (p - 1) * s.sum (Œª (i : Œπ), f i ^ p)
{C : Type u‚ÇÅ} [category_theory.small_category C] {‚Ñ∞ : Type u‚ÇÇ} [category_theory.category ‚Ñ∞] [category_theory.limits.has_colimits ‚Ñ∞] (L : (C·µí·µñ ‚•§ Type u‚ÇÅ) ‚•§ ‚Ñ∞) [category_theory.limits.preserves_colimits L] : category_theory.is_left_adjoint L
{X Y : SemiNormedGroup‚ÇÅ} (f : X ‚ü∂ Y) (s : category_theory.limits.cokernel_cofork f) : (SemiNormedGroup‚ÇÅ.cokernel_cocone f).X ‚ü∂ s.X
{Œπ : Type u_1} [decidable_eq Œπ] [fintype Œπ] {Œ± : Œπ ‚Üí Type u_2} [S : Œ† (i : Œπ), setoid (Œ± i)] (f : Œ† (i : Œπ), quotient (S i)) : quotient pi_setoid
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (D : Type w) [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] [Œ† (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)·µí·µñ (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] : (C·µí·µñ ‚•§ D) ‚•§ category_theory.Sheaf J D
{M : Type u_2} [add_comm_group M] {Œπ : Type u_4} [decidable_eq Œπ] [fintype Œπ] {A : Type u_5} [comm_ring A] [module A M] {Œ∫ : Type u_6} [fintype Œ∫] [decidable_eq Œ∫] (b : basis Œπ A M) (c : basis Œ∫ A M) (f : M ‚Üí‚Çó[A] M) : (‚áë(linear_map.to_matrix b b) f).det = (‚áë(linear_map.to_matrix c c) f).det
{R : Type u_1} [comm_ring R] (E : EllipticCurve R) : R
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (t : chain_complex.mk_struct V) : Œ£' (X‚ÇÄ X‚ÇÅ X‚ÇÇ : V) (d‚ÇÄ : X‚ÇÅ ‚ü∂ X‚ÇÄ) (d‚ÇÅ : X‚ÇÇ ‚ü∂ X‚ÇÅ), d‚ÇÅ ‚â´ d‚ÇÄ = 0
(G : Type u_1) [has_inv G] [measurable_space G] : Prop
(Œ± : Type u_2) : Type u_2
(C : Type u_1) [category_theory.category C] [category_theory.preadditive C] : category_theory.simplicial_object C ‚•§ chain_complex C ‚Ñï
 : omega.nat.preterm ‚Üí ‚Ñï
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) : Prop
(Œ± : Type u_4) [has_le Œ±] : Type u_4
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_refl Œ± r] [is_trans Œ± r] {s : set Œ±} (h : s.partially_well_ordered_on r) : {l : list Œ± | ‚àÄ (x : Œ±), x ‚àà l ‚Üí x ‚àà s}.partially_well_ordered_on (list.sublist_forall‚ÇÇ r)
{K : Type u_1} [field K] (A : valuation_subring K) : subgroup KÀ£
{Œ± : Type u_1} (f : Œ± ‚Üí nnreal) (hf0 : tsum f ‚â† 0) : pmf Œ±
(X : Type u) [nonempty X] : category_theory.injective X
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] [category_theory.has_projective_resolutions C] [category_theory.preadditive D] [category_theory.limits.has_zero_object D] [category_theory.limits.has_equalizers D] [category_theory.limits.has_cokernels D] [category_theory.limits.has_images D] [category_theory.limits.has_image_maps D] (F : C ‚•§ D) [F.additive] (n : ‚Ñï) {X Y : C} (f : X ‚ü∂ Y) {P : category_theory.ProjectiveResolution X} {Q : category_theory.ProjectiveResolution Y} (g : P.complex ‚ü∂ Q.complex) (w : g ‚â´ Q.œÄ = P.œÄ ‚â´ (chain_complex.single‚ÇÄ C).map f) : (F.left_derived n).map f = (F.left_derived_obj_iso n P).hom ‚â´ (homology_functor D (complex_shape.down ‚Ñï) n).map ((F.map_homological_complex (complex_shape.down ‚Ñï)).map g) ‚â´ (F.left_derived_obj_iso n Q).inv
{R : Type u_1} {R‚ÇÇ : Type u_2} [semiring R] [semiring R‚ÇÇ] (œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ) (E : Type u_10) (E‚ÇÇ : Type u_11) [semi_normed_group E] [semi_normed_group E‚ÇÇ] [module R E] [module R‚ÇÇ E‚ÇÇ] : Type (max u_10 u_11)
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] (P : C·µí·µñ ‚•§ D) [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] : C·µí·µñ ‚•§ D
(k : Type u_1) (P‚ÇÅ : Type u_2) (P‚ÇÇ : Type u_3) {V‚ÇÅ : Type u_4} {V‚ÇÇ : Type u_5} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] : Type (max u_2 u_3 u_4 u_5)
{Œπ : Type u_2} [encodable Œπ] {F : Œπ ‚Üí Type u_3} [Œ† (i : Œπ), metric_space (F i)] : has_dist (Œ† (i : Œπ), F i)
{C : Type u‚ÇÅ} [category_theory.category C] {G : category_theory.comonad C} : category_theory.category G.coalgebra
{Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [topological_space Œ±] [preorder Œ±] [topological_space Œ≤] [preorder Œ≤] [topological_space Œ≥] [preorder Œ≥] (g : esakia_hom Œ≤ Œ≥) (f : esakia_hom Œ± Œ≤) : esakia_hom Œ± Œ≥
(R : Type u) [semigroup R] : Type u
(X : Type u) [metric_space X] [compact_space X] [nonempty X] : Gromov_Hausdorff.GH_space
{C : Type u} [category_theory.category C] (T : category_theory.monad C) : Type u
{n : ‚Ñï} {Œ≤ : Type u_1} (a : Œ≤) (q : fin n ‚Üí Œ≤) (b : Œ≤) : fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b
{Œ± : Type u} [monoid Œ±] (a : Œ±) (u : Œ±À£) : Œ±
{R : Type u_1} [semiring R] (S : subsemiring R) : subalgebra ‚Ñï R
 : category_theory.reflective Profinite_to_CompHaus
(C : Type u‚ÇÅ) [ùíû : category_theory.enriched_category (Type v) C] : category_theory.category C
(J : Type v) : Type v
{m n : ‚Ñï} (hmn : m.coprime n) : squarefree (m * n) ‚Üî squarefree m ‚àß squarefree n
(Œ± : Type u) [preorder Œ±] : category_theory.small_category Œ±
{Œ± : Type u_1} (a : uchange Œ±) : Œ±
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (p1 : P) {p2 p3 p4 : P} (h : euclidean_geometry.angle p2 p3 p4 = real.pi) : euclidean_geometry.angle p1 p3 p2 + euclidean_geometry.angle p1 p3 p4 = real.pi
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u} [category_theory.category C] {F : J ‚•§ C} [category_theory.limits.has_colimit F] {E : K ‚•§ J} [category_theory.limits.has_colimit (E ‚ãô F)] (s : category_theory.limits.colimit_cocone (E ‚ãô F)) (t : category_theory.limits.colimit_cocone F) : category_theory.limits.colimit.pre F E = (category_theory.limits.colimit.iso_colimit_cocone s).hom ‚â´ s.is_colimit.desc (category_theory.limits.cocone.whisker E t.cocone) ‚â´ (category_theory.limits.colimit.iso_colimit_cocone t).inv
{Œ± : Type u_1} [has_add Œ±] (s : set Œ±) (a b : Œ±) : Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C
{Œ± : Type u} : has_coe_to_sort (finset Œ±) (Type u)
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] (f : Œ± ‚Üí Œ≤) : Prop
 : tactic.ring_exp.ex tactic.ring_exp.ex_type.sum ‚Üí tactic.ring_exp.ex tactic.ring_exp.ex_type.prod ‚Üí tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.sum)
(icf : tactic.ring.cache ‚Üí tactic.ref tactic.instance_cache) {Œ± : Type} (f : tactic.instance_cache ‚Üí tactic (tactic.instance_cache √ó Œ±)) : tactic.ring.ring_m Œ±
{R : Type u_4} {S : Type u_5} [has_mul R] [has_add R] [has_mul S] [has_add S] (e : R ‚âÉ+* S) (x y : R) : ‚áëe (x * y) = ‚áëe x * ‚áëe y
{p : ‚Ñï} [fact (nat.prime p)] : field ‚Ñö_[p]
{M : Type u_1} [monoid M] : comm_monoid ‚Ü•(submonoid.center M)
{Œ± : Type u} (s : seq Œ±) {a‚Çô : Œ±} {n m : ‚Ñï} (m_le_n : m ‚â§ n) (s_nth_eq_some : s.nth n = option.some a‚Çô) : ‚àÉ (a‚Çò : Œ±), s.nth m = option.some a‚Çò
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {f : Œ± ‚Üí ‚Ñù} (K : ‚Ñù) (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí f x ‚â§ f y + K * has_dist.dist x y) : lipschitz_on_with K.to_nnreal f s
{n m : ‚Ñï} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬¨‚àÉ (t : ‚Ñï), t * t = n
{n : ‚Ñï} {Œ± : Type u_1} (l : list Œ±) (c : composition n) : list (list Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (f : category_theory.mono_over X) : category_theory.mono_over.mk' f.arrow ‚âÖ f
(X : Type u) (Y : Type v) [metric_space X] [nonempty X] [compact_space X] [metric_space Y] [nonempty Y] [compact_space Y] : ‚Ñù
{R : Type u_1} [non_unital_non_assoc_semiring R] (r : R) : R ‚Üí+ R
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pullbacks C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.epi g] : category_theory.epi category_theory.limits.pullback.fst
{Œ± : Type u} [uniform_space Œ±] (h : is_complete set.univ) : complete_space Œ±
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Ring) : category_theory.limits.is_colimit (Ring.filtered_colimits.colimit_cocone F)
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] {a b : Œ±} : ¬¨a < b ‚Üí multiset.Ico a b = 0
{R : Type u} {Œπ : Type u'} {M‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] (f : multilinear_map R M‚ÇÅ M‚ÇÇ) (m m' : Œ† (i : Œπ), M‚ÇÅ i) (t : finset Œπ) : ‚áëf (t.piecewise (m + m') m') = t.powerset.sum (Œª (s : finset Œπ), ‚áëf (s.piecewise m m'))
(c n : name) (appl_inst f Œ± Œ≤ : expr) (args‚ÇÄ : list expr) (args‚ÇÅ : list (bool √ó expr)) (rec_call : list expr) : tactic expr
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ± ‚Üí Œ≥} {x : Œ± √ó Œ≤} (hf : continuous_at f x.fst) : continuous_at (Œª (x : Œ± √ó Œ≤), f x.fst) x
{p : ‚Ñï} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n m : ‚Ñï} (hmn : m ‚â§ n) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic (p ^ m) R)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ‚Üî ‚àÉ (x : V), x ‚â† 0
{Œ± : Type u_3} {Œ≤ : Type u_4} [has_inf Œ±] [has_top Œ±] [has_inf Œ≤] [has_top Œ≤] (f : inf_top_hom Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : inf_top_hom Œ± Œ≤
{Œπ : Type u_1} {R : Type u_3} [ring R] {M : Type u_2} [add_comm_group M] [module R M] {v : Œπ ‚Üí M} (li : linear_independent R v) (c d : R) (i j : Œπ) (hc : c ‚â† 0) (h : c ‚Ä¢ v i = d ‚Ä¢ v j) : i = j
{Œ± : Type u} [semilattice_inf Œ±] [order_top Œ±] {x y z : Œ±} (f : x ‚ü∂ z) (g : y ‚ü∂ z) : category_theory.limits.pullback f g = x ‚äì y
{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_add M] [has_add N] [has_add P] (hnp : add_hom N P) (hmn : add_hom M N) : add_hom M P
(X : algebraic_geometry.Scheme) (i : X.affine_basis_cover.J) : CommRing
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [baire_space Œ±] {S : set Œ≤} {f : Œ† (x : Œ≤), x ‚àà S ‚Üí set Œ±} (ho : ‚àÄ (s : Œ≤) (H : s ‚àà S), is_GŒ¥ (f s H)) (hS : S.countable) (hd : ‚àÄ (s : Œ≤) (H : s ‚àà S), dense (f s H)) : dense (‚ãÇ (s : Œ≤) (H : s ‚àà S), f s H)
{Œ± : Type u_1} [metric_space Œ±] {Œ≤ : Type u} [nonempty Œ≤] (p : besicovitch.tau_package Œ≤ Œ±) {i : ordinal} (hi : i < p.last_step) {N : ‚Ñï} (hN : is_empty (besicovitch.satellite_config Œ± N p.œÑ)) : p.color i < N
{X : Type u} {m‚ÇÅ : X ‚Üí X ‚Üí X} {e‚ÇÅ : X} (h‚ÇÅ : eckmann_hilton.is_unital m‚ÇÅ e‚ÇÅ) [h : add_zero_class X] (distrib : ‚àÄ (a b c d : X), m‚ÇÅ (a + b) (c + d) = m‚ÇÅ a c + m‚ÇÅ b d) : add_comm_monoid X
(p : ‚Ñï) : witt_vector.is_poly p (Œª (_x : Type u_1) (_x_1 : comm_ring _x), id)
{R : Type u} {S : Type v} [comm_ring R] (f : polynomial R) [comm_ring S] [algebra R S] (x : S) (hfx : ‚áë(polynomial.aeval x) f = 0) : adjoin_root f ‚Üí‚Çê[R] S
{m : Type u_2} {Œ± : Type v} (w : m ‚Üí Œ±) : matrix m unit Œ±
{R : Type u_7} {S : Type u_8} [has_mul R] [has_add R] [has_mul S] [has_add S] (self : R ‚âÉ+* S) : R ‚âÉ S
{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} {a : X} : a ‚àà closure s ‚Üî ‚àÉ (x : ‚Ñï ‚Üí X), (‚àÄ (n : ‚Ñï), x n ‚àà s) ‚àß filter.tendsto x filter.at_top (nhds a)
{X Y : Top} {f g : C(‚Ü•X, ‚Ü•Y)} (H : f.homotopy g) : fundamental_groupoid.fundamental_groupoid_functor.map f ‚ü∂ fundamental_groupoid.fundamental_groupoid_functor.map g
 : tactic.itauto.prop ‚Üí tactic.itauto.prop ‚Üí tactic.itauto.prop
{G : Type u} [group G] (N : subgroup G) [nN : N.normal] (M : subgroup G) [nM : M.normal] (h : N ‚â§ M) : (G ‚ß∏ N) ‚ß∏ subgroup.map (quotient_group.mk' N) M ‚Üí* G ‚ß∏ M
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (R : Type u_3) [comm_semiring R] [semiring Y] [algebra R Y] [topological_semiring Y] : locally_constant X Y ‚Üí‚Çê[R] C(X, Y)
{Œ± : Type u} {Œ≤ : Type v} [has_mul Œ±] [has_mul Œ≤] (e : Œ± ‚âÉ* Œ≤) : with_one Œ± ‚âÉ* with_one Œ≤
(t e : expr) : bool
{p : Prop} : slim_check.test_result p ‚Üí string
{Œ± : Type u_1} [pseudo_emetric_space Œ±] [complete_space Œ±] : baire_space Œ±
{G : Type u_1} {H : Type u_2} [add_group G] [add_group H] [is_add_cyclic H] (f : G ‚Üí+ H) (hf : f.ker ‚â§ add_subgroup.center G) : add_comm_group G
{R : Type u} {S : Type v} [ring R] [ring S] {f g : R ‚Üí+* S} {s : set R} (h : set.eq_on ‚áëf ‚áëg s) : set.eq_on ‚áëf ‚áëg ‚Üë(subring.closure s)
{Œ± : Type u} {Œ≤ : Type v} (c : computation Œ±) (f : Œ± ‚Üí computation Œ≤) : computation Œ≤
 : Profinite ‚•§ Top
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {s : category_theory.limits.cocone F} {G : K ‚•§ C} {t : category_theory.limits.cocone G} (P : category_theory.limits.is_colimit s) (Q : category_theory.limits.is_colimit t) (e : J ‚âå K) (w : e.functor ‚ãô G ‚âÖ F) : s.X ‚âÖ t.X
(X : BoolAlg) : BoundedDistribLattice
(R : Type u) [comm_semiring R] (A : Type v) [semiring A] [algebra R A] (n : Type w) [fintype n] [decidable_eq n] : matrix n n A ‚âÉ‚Çê[R] tensor_product R A (matrix n n R)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) {i : Œπ} (his : i ‚àà s) (hwi : w i = 1) (hw0 : ‚àÄ (i2 : Œπ), i2 ‚àà s ‚Üí i2 ‚â† i ‚Üí w i2 = 0) : ‚áë(s.affine_combination p) w = p i
(Œ≤ : Type) (C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_zero_morphisms C] : category_theory.faithful (category_theory.graded_object.total Œ≤ C)
{Œ± : Type u} [pseudo_emetric_space Œ±] {f : ‚Ñï ‚Üí Œ±} (n : ‚Ñï) {d : ‚Ñï ‚Üí ennreal} (hd : ‚àÄ {k : ‚Ñï}, k < n ‚Üí has_edist.edist (f k) (f (k + 1)) ‚â§ d k) : has_edist.edist (f 0) (f n) ‚â§ (finset.range n).sum (Œª (i : ‚Ñï), d i)
{T : ‚Ñù} {g : ‚Ñù ‚Üí ‚Ñù} (hg : function.periodic g T) (h_int : ‚àÄ (t‚ÇÅ t‚ÇÇ : ‚Ñù), interval_integrable g measure_theory.measure_space.volume t‚ÇÅ t‚ÇÇ) (h‚ÇÄ : 0 < ‚à´ (x : ‚Ñù) in 0..T, g x) (hT : 0 < T) : filter.tendsto (Œª (t : ‚Ñù), ‚à´ (x : ‚Ñù) in 0..t, g x) filter.at_top filter.at_top
{p : ‚Ñï} [p_prime : fact (nat.prime p)] {a : ‚Ñ§} : multiplicity.finite ‚Üëp a ‚Üî a ‚â† 0
{Œ± : Type u_1} [decidable_eq Œ±] (a : Œ±) : multiset Œ± ‚Üí+ ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (p : set Œ≤) (f : principal_seg r s) (H : ‚àÄ (a : Œ±), ‚áëf a ‚àà p) (H‚ÇÇ : f.top ‚àà p) : principal_seg r (subrel s p)
{L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] : L.embedding M N ‚Üí L.hom M N
 : omega.eqelim omega.term
{Œ± : Sort u} {Œ≤ : Sort v} (p : Œ± ‚Üí Prop) [decidable_pred p] (x‚ÇÄ : {a // p a} ‚Üí Œ≤) : {x // x ‚àò coe = x‚ÇÄ} ‚âÉ ({a // ¬¨p a} ‚Üí Œ≤)
{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ‚â† 0) : char.quadratic_char F a ^ 2 = 1
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {Œπ : Type u_5} [decidable_eq Œπ] [fintype Œπ] (g : G ‚ÜíL[ùïú] E) : is_bounded_linear_map ùïú (Œª (f : continuous_multilinear_map ùïú (Œª (i : Œπ), E) F), f.comp_continuous_linear_map (Œª (_x : Œπ), g))
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [mul_one_class Œ±] [mul_one_class Œ≤] (f : Œ± ‚Üí*o Œ≤) : Œ± ‚Üío Œ≤
(R : Type u) [comm_ring R] (f g : R) (U : topological_space.opens ‚Ü•(algebraic_geometry.prime_spectrum.Top R)) (hu : ‚àÄ (x : ‚Ü•(algebraic_geometry.prime_spectrum.Top R)), x ‚àà U ‚Üí g ‚àà (prime_spectrum.as_ideal x).prime_compl) : ‚Ü•((algebraic_geometry.Spec.structure_sheaf R).val.obj (opposite.op U))
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [semiring R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] (e : topological_vector_bundle.pretrivialization R F E) (b : B) : E b ‚Üí‚Çó[R] F
{Œ± : Sort u} {Œ≤ : Sort v} {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop} (e : Œ± ‚âÉ Œ≤) (h : ‚àÄ (a : Œ±), p a ‚Üî q (‚áëe a)) : {a // p a} ‚âÉ {b // q b}
 : expr ‚Üí expr
(push : interactive.parse (optional (lean.parser.tk "!"))) : interactive.parse (optional name_with_opt) ‚Üí tactic unit
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) [lie_algebra.is_nilpotent R ‚Ü•H] (M : Type w) [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] {œá‚ÇÅ œá‚ÇÇ œá‚ÇÉ : ‚Ü•H ‚Üí R} (hœá : œá‚ÇÅ + œá‚ÇÇ = œá‚ÇÉ) : ‚Ü•(lie_algebra.root_space H œá‚ÇÅ) ‚Üí‚Çó[R] ‚Ü•(lie_module.weight_space M œá‚ÇÇ) ‚Üí‚Çó[R] ‚Ü•(lie_module.weight_space M œá‚ÇÉ)
{K : Type u_1} {v : K} {n : ‚Ñï} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ‚â§ ifp_n.fr ‚àß ifp_n.fr < 1
{Œ± : Sort u_1} [has_sizeof Œ±] (x y : Œ±) : Prop
 : linter
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) : is_unit A ‚Üî is_unit A.det
{Œ≤ : Type w} {C : Type u} [category_theory.category C] {f : Œ≤ ‚Üí C} [category_theory.limits.has_coproduct f] {P : C} (p : Œ† (b : Œ≤), f b ‚ü∂ P) : ‚àê f ‚ü∂ P
(max_steps : ‚Ñï) (d : declaration) : tactic (option string)
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] (p : L.substructure N) (f : L.embedding M N) (h : ‚àÄ (c : M), ‚áëf c ‚àà p) : L.embedding M ‚Ü•p
{G : Type u_1} [group G] (H : subgroup G) [H.normal] : subgroup G
{Œ± : Type u_1} (f : set Œ± ‚Üí Œ±) : ¬¨function.injective f
{R : Type u_2} [comm_ring R] [is_domain R] [fintype R] {f g : polynomial R} (hf2 : f.degree = 2) (hg2 : g.degree = 2) (hR : fintype.card R % 2 = 1) : ‚àÉ (a b : R), polynomial.eval a f + polynomial.eval b g = 0
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) : list (sigma Œ≤) ‚Üí option (Œ≤ a) √ó list (sigma Œ≤)
(C : Type u) [category_theory.category C] : Prop
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} {s‚ÇÅ s‚ÇÇ : affine.simplex ‚Ñù P n} (h : set.range s‚ÇÅ.points = set.range s‚ÇÇ.points) : s‚ÇÅ.monge_point = s‚ÇÇ.monge_point
(Œ± : Type u_1) : Type u_1
 : tactic (list expr)
{C : Type u} [category_theory.category C] [category_theory.limits.has_strong_epi_mono_factorisations C] : category_theory.limits.has_strong_epi_images C
 : tactic unit
{K : Type u_1} [field K] (R S : valuation_subring K) (h : R ‚â§ S) : ‚Ü•R ‚Üí+* ‚Ü•S
(C : Type u) [category_theory.category C] : category_theory.Cat
{Œ± : Type u_1} [preorder Œ±] [succ_order Œ±] {a : Œ±} : ¬¨is_max a ‚Üí a < order.succ a
{R : Type u_4} {S : Type u_5} [semiring R] [semiring S] (f : R ‚âÉ+* S·µê·µí·µñ) (l : list R) : mul_opposite.unop (‚áëf l.prod) = (list.map (mul_opposite.unop ‚àò ‚áëf) l).reverse.prod
(M : Type u_1) [has_add M] : Type u_1
{G : Type u} [group G] (B : group_filter_basis G) : topological_group G
{Œ± : Type u} [has_one Œ±] [has_mul Œ±] {a : Œ±} [invertible a] : invertible (‚Öü a)
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X ‚Üí Y} [sequential_space X] : seq_continuous f ‚Üí continuous f
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {m n : with_top ‚Ñï} {s : set E} {f : E ‚Üí F} (hf : cont_diff_on ùïú n f s) (hs : unique_diff_on ùïú s) (hmn : m + 1 ‚â§ n) : cont_diff_on ùïú m (Œª (p : E √ó E), ‚áë(fderiv_within ùïú f s p.fst) p.snd) (s √óÀ¢ set.univ)
{K : Type u} [hring : comm_ring K] {P : Sort v} (x : ratfunc K) (f : polynomial K ‚Üí polynomial K ‚Üí P) (H : ‚àÄ {p q p' q' : polynomial K}, q ‚àà non_zero_divisors (polynomial K) ‚Üí q' ‚àà non_zero_divisors (polynomial K) ‚Üí p * q' = p' * q ‚Üí f p q = f p' q') : P
(G : Type u_1) [add_monoid G] : ¬¨add_monoid.is_torsion_free G ‚Üî ‚àÉ (g : G), g ‚â† 0 ‚àß is_of_fin_add_order g
{Œ± : Type u} [topological_space Œ±] {Œπ : Type u_1} [compact_space Œ±] {f : Œπ ‚Üí set Œ±} (hf : locally_finite f) (hne : ‚àÄ (i : Œπ), (f i).nonempty) : fintype Œπ
(M : Type u) [comm_monoid M] : CommMon
{G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : 0 < add_order_of x
{E : ‚Ñï ‚Üí Type u_1} (x : Œ† (n : ‚Ñï), E n) (s : set (Œ† (n : ‚Ñï), E n)) : ‚Ñï
{M : Type u_1} [has_mul M] : has_inf (subsemigroup M)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) : ‚áë(s.weighted_vsub p) w = s.sum (Œª (i : Œπ), w i ‚Ä¢ (p i -·µ• classical.choice add_torsor.nonempty))
(X T : Top) : Top.local_predicate (Œª (x : ‚Ü•X), ‚Ü•T)
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (s : add_submonoid M) (t : add_submonoid N) : add_submonoid (M √ó N)
{M : Type u_1} [has_mul M] (s : set M) {p : Œ† (x : M), x ‚àà subsemigroup.closure s ‚Üí Prop} (Hs : ‚àÄ (x : M) (h : x ‚àà s), p x _) (Hmul : ‚àÄ (x : M) (hx : x ‚àà subsemigroup.closure s) (y : M) (hy : y ‚àà subsemigroup.closure s), p x hx ‚Üí p y hy ‚Üí p (x * y) _) {x : M} (hx : x ‚àà subsemigroup.closure s) : p x hx
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} (hs : s.nonempty) (bs : metric.bounded s) (ht : t.nonempty) (bt : metric.bounded t) : metric.Hausdorff_dist s t ‚â§ metric.diam (s ‚à™ t)
{Œ± : Type u} (r : Œ± ‚Üí Œ± ‚Üí Prop) : list Œ± ‚Üí list Œ± ‚Üí Prop
{R : Type u_1} [field R] (a b : R) (hab : a ^ 2 + b ^ 2 ‚â† 0) : GL (fin 2) R
{L R : list pgame} : fin R.length ‚âÉ (pgame.of_lists L R).right_moves
{Œ± : Type u_2} [has_mul Œ±] : Œ± ‚Üí‚Çô* filter Œ±
{Œπ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape Œπ) [category_theory.limits.has_zero_object V] [category_theory.limits.has_equalizers V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] [category_theory.limits.has_cokernels V] (i : Œπ) : homotopy_category.quotient V c ‚ãô homotopy_category.homology_functor V c i ‚âÖ homology_functor V c i
{Œ± : Type u_2} [mul_one_class Œ±] : mul_one_class (set Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {X‚ÇÅ X‚ÇÇ Y : C} (p‚ÇÅ : category_theory.exact_pairing X‚ÇÅ Y) (p‚ÇÇ : category_theory.exact_pairing X‚ÇÇ Y) : X‚ÇÅ ‚âÖ X‚ÇÇ
{œÑ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ≤] (f : filter œÑ) (œï : œÑ ‚Üí Œ± ‚Üí Œ≤) (x : Œ±) (y : Œ≤) : y ‚àà omega_limit f œï {x} ‚Üî map_cluster_pt y f (Œª (t : œÑ), œï t x)
{Œπ : Type u_1} {Œ∑ : Œπ ‚Üí Type u_4} {N : Type u_5} [has_zero N] : ((Œ£ (i : Œπ), Œ∑ i) ‚Üí‚ÇÄ N) ‚âÉ Œ†‚ÇÄ (i : Œπ), Œ∑ i ‚Üí‚ÇÄ N
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b : Œ±} (ha : a ‚â§ 0) (hb : b ‚â§ 0) : a + b ‚â§ 0
{M : Type u_1} [has_mul M] {s : set M} : s ‚äÜ ‚Üë(subsemigroup.closure s)
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (f : M ‚Üí‚Çó[R] M) : module (polynomial R) M
 : ‚Ñï ‚Üí tactic unit ‚Üí tactic unit
{V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (B‚ÇÅ B‚ÇÇ : bilin_form K V) (b‚ÇÇ : B‚ÇÇ.nondegenerate) : V ‚Üí‚Çó[K] V
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [linear_ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] [ordered_smul ùïú Œ≤] {s : set E} {f g : E ‚Üí Œ≤} (hf : convex_on ùïú s f) (hg : convex_on ùïú s g) : convex_on ùïú s (f ‚äî g)
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {Œπ : Type u_6} (Z : topological_vector_bundle_core R B F Œπ) : Type (max u_3 u_4)
 : expr_lens ‚Üí expr ‚Üí tactic expr
{T : Type u‚ÇÅ} [category_theory.category T] {X Y : T} (f : X ‚ü∂ Y) : category_theory.over X ‚•§ category_theory.over Y
{Œ± : Type u} (xs : list (slim_check.gen Œ±)) (pos : 0 < xs.length) : slim_check.gen Œ±
{p : ‚Ñï} {R : Type u_1} [non_assoc_semiring R] (f : Œ† (k : ‚Ñï), R ‚Üí+* zmod (p ^ k)) (r : R) : ‚Ñï ‚Üí ‚Ñ§
(m : ‚Ñï) : padic_val_rat m 0 = 0
{R‚ÇÅ : Type u_1} [semiring R‚ÇÅ] (M‚ÇÅ : Type u_4) [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ] [module R‚ÇÅ M‚ÇÅ] : group (M‚ÇÅ ‚âÉL[R‚ÇÅ] M‚ÇÅ)
{M : Type u_1} [has_add M] {c : add_con M} (x y : M) : ‚Üë(x + y) = ‚Üëx + ‚Üëy
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (f : C(Œ± √ó Œ≤, Œ≥)) : continuous f.curry'
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : ‚Ü•(S.to_submodule) ‚âÉ‚Çó[R] ‚Ü•S
{E : Type u_1} [add_comm_group E] [module ‚Ñù E] {s : set E} : gauge s 0 = 0
{R : Type u_1} {Œπ‚ÇÅ : Type u_2} {Œπ‚ÇÇ : Type u_3} [comm_semiring R] [decidable_eq Œπ‚ÇÅ] [decidable_eq Œπ‚ÇÇ] {N‚ÇÅ : Type u_6} [add_comm_monoid N‚ÇÅ] [module R N‚ÇÅ] {N‚ÇÇ : Type u_7} [add_comm_monoid N‚ÇÇ] [module R N‚ÇÇ] {N : Type u_8} [add_comm_monoid N] [module R N] (a : multilinear_map R (Œª (_x : Œπ‚ÇÅ), N) N‚ÇÅ) (b : multilinear_map R (Œª (_x : Œπ‚ÇÇ), N) N‚ÇÇ) : multilinear_map R (Œª (_x : Œπ‚ÇÅ ‚äï Œπ‚ÇÇ), N) (tensor_product R N‚ÇÅ N‚ÇÇ)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] [category_theory.limits.has_equalizers V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] [category_theory.limits.has_cokernels V] {c : complex_shape Œπ} {C D : homological_complex V c} (f : C ‚ü∂ D) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (ga : Œ± ‚Üí Œ± ‚Üí Œ±) (gb : Œ≤ ‚Üí Œ≤ ‚Üí Œ≤) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ¥ : Type u_4} [add_comm_monoid Œ±] [topological_space Œ±] [t2_space Œ±] [complete_lattice Œ≤] (m : Œ≤ ‚Üí Œ±) (m0 : m ‚ä• = 0) (R : Œ± ‚Üí Œ± ‚Üí Prop) (m_supr : ‚àÄ (s : ‚Ñï ‚Üí Œ≤), R (m (‚®Ü (i : ‚Ñï), s i)) (‚àë' (i : ‚Ñï), m (s i))) (s : Œ¥ ‚Üí Œ≤) (t : finset Œ¥) : R (m (‚®Ü (d : Œ¥) (H : d ‚àà t), s d)) (t.sum (Œª (d : Œ¥), m (s d)))
{Œ± : Type u} {Œ≤ : Type v} : (cardinal.mk Œ±).lift = (cardinal.mk Œ≤).lift ‚Üî nonempty (Œ± ‚âÉ Œ≤)
{Œ± Œ≤ : SemilatticeInf} (e : ‚Ü•Œ± ‚âÉo ‚Ü•Œ≤) : Œ± ‚âÖ Œ≤
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [unique_factorization_monoid Œ±] [normalization_monoid Œ±] [decidable_eq Œ±] {n : Œ±} : (factorization n).support = (unique_factorization_monoid.normalized_factors n).to_finset
{p : ‚Ñï} {G : Type u_1} [group G] (P : sylow p G) (g : G) : ‚Ü•P ‚âÉ* ‚Ü•(g ‚Ä¢ P)
(A : Type u_4) [monoid A] [topological_space A] : continuous_monoid_hom A A
{Œ± : Type u_2} [decidable_eq Œ±] [has_div Œ±] {u : finset Œ±} {s t : set Œ±} : ‚Üëu ‚äÜ s / t ‚Üí (‚àÉ (s' t' : finset Œ±), ‚Üës' ‚äÜ s ‚àß ‚Üët' ‚äÜ t ‚àß u ‚äÜ s' / t')
{C : Type u} [category_theory.category C] {X Y Z : algebraic_geometry.PresheafedSpace C} (f : X ‚ü∂ Z) [hf : algebraic_geometry.PresheafedSpace.is_open_immersion f] (g : Y ‚ü∂ Z) : algebraic_geometry.PresheafedSpace.is_open_immersion category_theory.limits.pullback.fst
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) [category_theory.limits.has_binary_biproduct P Q] : category_theory.limits.binary_bicone P Q
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} (t : category_theory.limits.pushout_cocone f g) (desc : Œ† (s : category_theory.limits.pushout_cocone f g), t.X ‚ü∂ s.X) (fac_left : ‚àÄ (s : category_theory.limits.pushout_cocone f g), t.inl ‚â´ desc s = s.inl) (fac_right : ‚àÄ (s : category_theory.limits.pushout_cocone f g), t.inr ‚â´ desc s = s.inr) (uniq : ‚àÄ (s : category_theory.limits.pushout_cocone f g) (m : t.X ‚ü∂ s.X), (‚àÄ (j : category_theory.limits.walking_span), t.Œπ.app j ‚â´ m = s.Œπ.app j) ‚Üí m = desc s) : category_theory.limits.is_colimit t
(x : expr) : tactic (omega.int.preform √ó ‚Ñï)
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] : ‚Ü•(derangements (subtype p)) ‚âÉ {f // ‚àÄ (a : Œ±), ¬¨p a ‚Üî a ‚àà function.fixed_points ‚áëf}
(l : list ‚Ñö) : tactic unit
{R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] (U : submodule R M) (x y : M) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} {F : Top.presheaf C X} {Œπ : Type v} {V : Top} {j : V ‚ü∂ X} (oe : open_embedding ‚áëj) (ùí∞ : Œπ ‚Üí topological_space.opens ‚Ü•V) : Top.presheaf.sheaf_condition_equalizer_products.pi_opens (_.functor.op ‚ãô F) ùí∞ ‚âÖ Top.presheaf.sheaf_condition_equalizer_products.pi_opens F (Top.presheaf.sheaf_condition_equalizer_products.cover.of_open_embedding oe ùí∞)
(C : Type u‚ÇÅ) [category_theory.category C] : Type (max u‚ÇÅ v‚ÇÅ)
{Œ± : Type u_2} [has_add Œ±] : has_add (set Œ±)
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S T : set E) : ‚Üë(intermediate_field.adjoin ‚Ü•(intermediate_field.adjoin F S) T) = intermediate_field.adjoin F (S ‚à™ T)
{R : Type u_1} [semiring R] {x y : R} (h : commute x y) (n : ‚Ñï) : (x + y) ^ n = (finset.nat.antidiagonal n).sum (Œª (m : ‚Ñï √ó ‚Ñï), n.choose m.fst ‚Ä¢ (x ^ m.fst * y ^ m.snd))
(x : ‚Ñù) : Prop
{R : Type u} [ring R] {X Y : Module R} (i : X ‚âÖ Y) : ‚Ü•X ‚âÉ‚Çó[R] ‚Ü•Y
(k : Type u‚ÇÅ) (G : Type u‚ÇÇ) [semiring k] : G ‚Üí add_monoid_algebra k G
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] : topological_space (L ‚âÉ‚Çê[K] L)
{Œ± : Sort u_1} {s‚ÇÅ : setoid Œ±} {p : quotient s‚ÇÅ ‚Üí Prop} (q : quotient s‚ÇÅ) (h : ‚àÄ (a : Œ±), p (quotient.mk' a)) : p q
(n : ‚Ñï) : ‚Ñï ‚Üí ‚Ñï
{R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} [comm_semiring R] [semiring A‚ÇÅ] [semiring A‚ÇÇ] [algebra R A‚ÇÅ] [algebra R A‚ÇÇ] : has_coe_to_fun (A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ) (Œª (_x : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ), A‚ÇÅ ‚Üí A‚ÇÇ)
{Œπ : Type u_1} {R : Type u_2} {N : Type u_5} [dec_Œπ : decidable_eq Œπ] [ring R] [add_comm_group N] [module R N] {p : Œπ ‚Üí submodule R N} (h : complete_lattice.independent p) : function.injective ‚áë(‚áë(dfinsupp.lsum ‚Ñï) (Œª (i : Œπ), (p i).subtype))
{R : Type u_1} [comm_ring R] (E : EllipticCurve R) : R
{C : Type u} [category_theory.category C] {X Y Z : C} (Œ± : X ‚âÖ Y) (Œ≤ : Y ‚âÖ Z) : X ‚âÖ Z
 : tactic (list tactic_doc_entry)
{Œ± : Type u_2} {Œ≤ : Type u_3} {rŒ± : non_assoc_semiring Œ±} {rŒ≤ : non_assoc_semiring Œ≤} (f : Œ± ‚Üí+* Œ≤) (a b : Œ±) : ‚áëf (a * b) = ‚áëf a * ‚áëf b
{Œ± : Type u_1} (L : list (list Œ±)) {i j : ‚Ñï} (hi : i < L.length) (hj : j < (L.nth_le i hi).length) : (list.take i (list.map list.length L)).sum + j < (list.take (i + 1) (list.map list.length L)).sum
{Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {q : Œ† (x : Œ±), p x ‚Üí Prop} : (‚àÉ (x : Œ±) (h : p x), q x h) ‚Üî ‚àÉ (x : {a // p a}), q ‚Üëx _
 : DistribLattice ‚âå DistribLattice
(R : Type u_2) (Œì‚ÇÄ : Type u_3) [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] [ring R] : Type (max u_2 u_3)
{M : Type u_1} [comm_monoid M] (S : submonoid M) : con (M √ó ‚Ü•S)
{C D : Type u} [category_theory.category C] [category_theory.category D] (A : Type w) [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (Hp : category_theory.cover_preserving J K G) (Hl : category_theory.cover_lifting J K G) (Hc : category_theory.compatible_preserving K G) : category_theory.sites.pullback A Hc Hp ‚ä£ category_theory.sites.copullback A Hl
 : pgame
(ùïú : Type u_1) (E : Type u_2) [ordered_semiring ùïú] [add_comm_monoid E] [has_scalar ùïú E] : Type u_2
(Œ± : Type u) : Type u
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommGroup) : category_theory.limits.is_limit ((category_theory.forget‚ÇÇ CommGroup CommMon).map_cone (CommGroup.limit_cone F))
{Œ± : Type u_1} [metric_space Œ±] {Œ≤ : Type u} [nonempty Œ≤] (p : besicovitch.tau_package Œ≤ Œ±) (i : ordinal) : ‚Ñù
{X : Type u} {Y : Type v} {Z : Type w} [nonempty Z] [metric_space Z] [metric_space X] [metric_space Y] {Œ¶ : Z ‚Üí X} {Œ® : Z ‚Üí Y} (hŒ¶ : isometry Œ¶) (hŒ® : isometry Œ®) : Type (max u v)
{Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±) : cycle Œ±
{Œ± : Type u_1} (a : Œ±) : part Œ±
{p : ‚Ñï} {G : Type u_1} [group G] (P : sylow p G) {N : subgroup G} (h : ‚ÜëP ‚â§ N) : sylow p ‚Ü•N
{p : ‚Ñï} [fact (nat.prime p)] (x : zmod p) : x ^ p = x
{R : Type u} [ring R] {G H : Module R} (f : G ‚ü∂ H) : category_theory.limits.kernel f ‚âÖ Module.of R ‚Ü•(linear_map.ker f)
{X : Type u} {Y : Type v} [metric_space X] [metric_space Y] : metric_space (X ‚äï Y)
 : tactic unit
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] {c : add_con M} {d : add_con N} {C : c.quotient ‚Üí d.quotient ‚Üí Prop} (p : c.quotient) (q : d.quotient) (H : ‚àÄ (x : M) (y : N), C ‚Üëx ‚Üëy) : C p q
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} {m : measurable_space Œ±} [topological_space Œ≤] [topological_space.pseudo_metrizable_space Œ≤] (u : filter Œπ) [u.ne_bot] [u.is_countably_generated] {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (hf : ‚àÄ (i : Œπ), measure_theory.strongly_measurable (f i)) (lim : filter.tendsto f u (nhds g)) : measure_theory.strongly_measurable g
{M : Type u_1} [comm_monoid M] (S : submonoid M) (N : Type u_2) [comm_monoid N] : Type (max u_1 u_2)
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] (f : R ‚Üí+* S) (hf : ‚àÄ (x y : R), commute (‚áëf x) (‚áëf y)) : R·µê·µí·µñ ‚Üí+* S
{Œ±‚ÇÅ : Type u_1} {Œ±‚ÇÇ : Type u_2} {Œ≤‚ÇÅ : Œ±‚ÇÅ ‚Üí Type u_3} {Œ≤‚ÇÇ : Œ±‚ÇÇ ‚Üí Type u_4} (f : Œ±‚ÇÅ ‚âÉ Œ±‚ÇÇ) (F : Œ† (a : Œ±‚ÇÅ), Œ≤‚ÇÅ a ‚âÉ Œ≤‚ÇÇ (‚áëf a)) : sigma Œ≤‚ÇÅ ‚âÉ sigma Œ≤‚ÇÇ
{Œ± : Type u} (p : Œ± ‚Üí Prop) [decidable_pred p] (as : list Œ±) : (list.zip_with has_append.append (list.split_on_p p as) (list.map (Œª (x : Œ±), [x]) (list.filter p as) ++ [list.nil])).join = as
{Œ± : Type u_1} [topological_space Œ±] (s : topological_space.clopens Œ±) : topological_space.opens Œ±
{M : Type u_1} [has_add M] (c : add_con M) (x : M) : ‚áëc x x
{Œ± : Type u_1} [canonically_ordered_add_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b c : Œ±} (h : c ‚â§ b) (h2 : a - c < b - c) : a < b
(S : set ‚Ñù) (hS : ‚àÄ (x : ‚Ñù), x ‚àà S ‚Üí x ‚â§ 0) : has_Sup.Sup S ‚â§ 0
(p : Set ‚Üí Prop) : Set ‚Üí Set
{Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (H : is_preconnected s) (Kst : s ‚äÜ t) (Ktcs : t ‚äÜ closure s) : is_preconnected t
{Œ± : Type u_1} [topological_space Œ±] {R : Type u_2} [comm_semiring R] {A : Type u_3} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] : R ‚Üí+* C(Œ±, A)
{X : Type u_2} [emetric_space X] [topological_space.second_countable_topology X] (s : set X) : (‚®Ü (x : X), (nhds_within x s).small_sets.limsup dimH) = dimH s
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {S : Type u_3} [monoid S] [distrib_mul_action S M] [smul_comm_class R S M] (h : same_ray R x y) (s : S) : same_ray R (s ‚Ä¢ x) (s ‚Ä¢ y)
{R : Type u} {S : Type u_3} [comm_ring R] (L : Type v) (M : Type w) [field L] [field M] [algebra R M] [no_zero_smul_divisors R M] [is_alg_closure R M] [comm_ring S] [algebra S L] [no_zero_smul_divisors S L] [is_alg_closure S L] (hSR : S ‚âÉ+* R) : L ‚âÉ+* M
{G : Type u_2} [group G] : submonoid G ‚âÉo submonoid G
{G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (a b : G) : ‚áëf (a - b) = ‚áëf a - ‚áëf b
{Œ± : Type u} {Œπ : Type v} [metric_space Œ±] [proper_space Œ±] {c : Œπ ‚Üí Œ±} {s : set Œ±} {r : Œπ ‚Üí ‚Ñù} (hs : is_closed s) (uf : ‚àÄ (x : Œ±), x ‚àà s ‚Üí {i : Œπ | x ‚àà metric.ball (c i) (r i)}.finite) (us : s ‚äÜ ‚ãÉ (i : Œπ), metric.ball (c i) (r i)) : ‚àÉ (r' : Œπ ‚Üí ‚Ñù), (s ‚äÜ ‚ãÉ (i : Œπ), metric.ball (c i) (r' i)) ‚àß ‚àÄ (i : Œπ), r' i < r i
{Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_group_hom f) : is_add_monoid_hom f
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P ‚ü∂ Q) : (‚àÄ (a : ‚Ü•P), ‚áëf a = 0 ‚Üí a = 0) ‚Üí category_theory.mono f
{C : Type u‚ÇÅ} [category_theory.category C] {P Q R S : C} {f : P ‚ü∂ Q} {g : P ‚ü∂ R} {h : Q ‚ü∂ S} {k : R ‚ü∂ S} [fr : category_theory.regular_epi f] (comm : f ‚â´ h = g ‚â´ k) (t : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk h k comm)) : category_theory.regular_epi k
{Œ± : Type u_8} [add_comm_semigroup Œ±] : add_hom (Œ± √ó Œ±) Œ±
{C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.abelian C] [category_theory.has_injective_resolutions C] [category_theory.abelian D] (F : C ‚•§ D) [F.additive] (n : ‚Ñï) {X : C} (P : category_theory.InjectiveResolution X) : (F.right_derived n).obj X ‚âÖ (homology_functor D (complex_shape.up ‚Ñï) n).obj ((F.map_homological_complex (complex_shape.up ‚Ñï)).obj P.cocomplex)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.is_iso (category_theory.yoneda.map f)] : category_theory.is_iso f
(H : Type u_5) [topological_space H] (M : Type u_6) : Type (max u_5 u_6)
{Œ± : Type u_1} (s : set Œ±) [decidable_pred (Œª (_x : Œ±), _x ‚àà s)] : ‚Ü•s ‚äï ‚Ü•s·∂ú ‚âÉ Œ±
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom A B
{Œ± : Type u} (s : wseq Œ±) : computation ‚Ñï
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± : typevec n} {Œ≤ : Type u} (g : Œ≤ ‚Üí F (Œ± ::: (mvqpf.cofix F Œ± ‚äï Œ≤))) (x : Œ≤) : mvqpf.cofix F Œ±
{Œ± : Type u_1} [decidable_eq Œ±] (s : set Œ±) [fintype ‚Ü•s] (a : Œ±) : decidable (a ‚àà s)
(hs : name_set) : tactic (list tactic.suggest.decl_data)
{Œ± : Type u_1} (op : Œ± ‚Üí Œ± ‚Üí Œ±) [assoc : is_associative Œ± op] (s : multiset Œ±) (comm : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (y : Œ±), y ‚àà s ‚Üí op x y = op y x) (a : Œ±) : Œ±
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h : s1 ‚â§ s2) : s1.direction ‚â§ s2.direction
{X Y Z : Top} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : Top.of {p // ‚áëf p.fst = ‚áëg p.snd} ‚ü∂ X
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [decidable_eq Œ±] (gcd : Œ± ‚Üí Œ± ‚Üí Œ±) (gcd_dvd_left : ‚àÄ (a b : Œ±), gcd a b ‚à£ a) (gcd_dvd_right : ‚àÄ (a b : Œ±), gcd a b ‚à£ b) (dvd_gcd : ‚àÄ {a b c : Œ±}, a ‚à£ c ‚Üí a ‚à£ b ‚Üí a ‚à£ gcd c b) : gcd_monoid Œ±
{Œ± : Type} : tactic Œ±
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) {b‚ÇÇ : basis (fin 2) ‚Ñù V} (hb‚ÇÇ : orthonormal ‚Ñù ‚áëb‚ÇÇ) (ho : b.orientation = -b‚ÇÇ.orientation) (Œ∏ : real.angle) : hb.rotation Œ∏ = hb‚ÇÇ.rotation (-Œ∏)
(Œ± : Type u_5) : Type u_5
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} (X : T.algebra) : category_theory.limits.is_colimit (category_theory.monad.beck_algebra_cofork X)
{Œ± : Type u_1} {a : Œ±} {s : set Œ±} (h : a ‚àà s) : semiquot Œ±
 : Type
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : differentiable_on ‚Ñù f (interior D)) (h_anti : antitone_on (deriv f) (interior D)) : concave_on ‚Ñù D f
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] [linear_order B] [order_topology B] (e e' : topological_fiber_bundle.trivialization F proj) (a : B) (He : a ‚àà e.base_set) (He' : a ‚àà e'.base_set) : topological_fiber_bundle.trivialization F proj
{M : Type u_1} [has_add M] (c : add_con M) : {d // c ‚â§ d} ‚âÉo add_con c.quotient
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape (category_theory.limits.wide_pullback_shape J) C] {B : C} : category_theory.limits.has_limits_of_shape (category_theory.discrete J) (category_theory.over B)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (a : Œ±) (b : Œ≤ a) : list (sigma Œ≤) ‚Üí list (sigma Œ≤)
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [unique_factorization_monoid Œ±] [dec : decidable_eq Œ±] (a : Œ±) : multiset {a // irreducible a}
{R : Type u} : tropical R ‚Üí R
{Œ± : Type} (gs : list expr) (tac : tactic Œ±) : tactic (Œ± √ó list expr)
{Œ± : Type u_1} [complete_lattice Œ±] : conditionally_complete_lattice Œ±
 : list binder ‚Üí expr ‚Üí list binder √ó expr
{a : ‚Ñï} (a1 : 1 < a) : ‚Ñï ‚Üí ‚Ñï √ó ‚Ñï
(g : Type) [random_gen g] : rand_g g g
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] {X : C} (hX : category_theory.limits.is_zero X) : X ‚âÖ 0
(L : Type v) [lie_ring L] : non_unital_non_assoc_semiring L
{Œ± : Type u} {Œ≤ : Type v} [non_assoc_ring Œ±] [has_zero Œ≤] [has_one Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_neg Œ≤] [has_sub Œ≤] [has_scalar ‚Ñï Œ≤] [has_scalar ‚Ñ§ Œ≤] (f : Œ± ‚Üí Œ≤) (hf : function.surjective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) (neg : ‚àÄ (x : Œ±), f (-x) = -f x) (sub : ‚àÄ (x y : Œ±), f (x - y) = f x - f y) (nsmul : ‚àÄ (x : Œ±) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (gsmul : ‚àÄ (x : Œ±) (n : ‚Ñ§), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_assoc_ring Œ≤
{Œ± : Type u_1} (n : ‚Ñï) (a : Œ±) : list Œ± ‚Üí list Œ±
{C : Type u} [category_theory.category C] {F : category_theory.limits.walking_span ‚•§ C} (t : category_theory.limits.pushout_cocone (F.map category_theory.limits.walking_span.hom.fst) (F.map category_theory.limits.walking_span.hom.snd)) : category_theory.limits.cocone F
(X : Type u_1) [normed_group X] {M : Type} [ring M] [module M X] (P : M) : Prop
 : turing.partrec_to_TM2.Œõ' ‚Üí finset turing.partrec_to_TM2.Œõ'
 : continuous_map.conj_invariant_subalgebra (subalgebra.restrict_scalars ‚Ñù fourier_subalgebra)
 : environment ‚Üí name ‚Üí option name
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] [algebra R S] {m : Type u_4} [fintype m] [decidable_eq m] (b : basis m R S) : S ‚Üí‚Çê[R] matrix m m R
(R : Type u1) [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] (n : ‚Ñï) : alternating_map R M (exterior_algebra R M) (fin n)
(Œ± : Type u_7) (Œ≤ : Type u_8) [measurable_space Œ±] [measurable_space Œ≤] : Type (max u_7 u_8)
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : stream (option (generalized_continued_fraction.int_fract_pair K))
{Œ± : Type u_1} [topological_space Œ±] {S : set (set Œ±)} (h : ‚àÄ (s : set Œ±), s ‚àà S ‚Üí is_GŒ¥ s) (hS : S.countable) : is_GŒ¥ (‚ãÇ‚ÇÄ S)
(F : Type u ‚Üí Type v ‚Üí Type w) [bifunctor F] : Type (max (u+1) (v+1) w)
(p : ‚Ñï) [hp : fact (nat.prime p)] {k : Type u_1} [field k] [char_p k p] [is_alg_closed k] (n : ‚Ñï) (a‚ÇÅ a‚ÇÇ : witt_vector p k) (bs : fin (n + 1) ‚Üí k) (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0) (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) : k
 : omega.int.preform ‚Üí ‚Ñï
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí bool
{M : Type u_1} [comm_monoid M] {N : Type u_2} [comm_monoid N] (x : M) (F : submonoid.localization_map.away_map x N) : N
{n : ‚Ñï} (c : composition_as_set n) : composition n
{Œπ : Type u_3} {œá : Œπ ‚Üí Type u_4} [Œ† (i : Œπ), topological_space (œá i)] {as bs cs : Œ† (i : Œπ), œá i} (Œ≥‚ÇÄ : Œ† (i : Œπ), path (as i) (bs i)) (Œ≥‚ÇÅ : Œ† (i : Œπ), path (bs i) (cs i)) : (path.pi Œ≥‚ÇÄ).trans (path.pi Œ≥‚ÇÅ) = path.pi (Œª (i : Œπ), (Œ≥‚ÇÄ i).trans (Œ≥‚ÇÅ i))
{Œ± : Type u_1} {n : Type u_3} {A : matrix n n Œ±} : A.is_symm ‚Üî ‚àÄ (i j : n), A j i = A i j
{Œ± J : Type u} [category_theory.small_category J] [category_theory.fin_category J] [semilattice_sup Œ±] [order_bot Œ±] (F : J ‚•§ Œ±) : category_theory.limits.colimit F = finset.univ.sup F.obj
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y Z X' Y' Z' : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [category_theory.limits.has_kernel g] (w : f ‚â´ g = 0) (f' : X' ‚ü∂ Y') (g' : Y' ‚ü∂ Z') [category_theory.limits.has_kernel g'] (w' : f' ‚â´ g' = 0) (p : X ‚ü∂ X') (q : Y ‚ü∂ Y') (r : Z ‚ü∂ Z') (h‚ÇÅ : f ‚â´ q = p ‚â´ f') (h‚ÇÇ : g ‚â´ r = q ‚â´ g') : category_theory.limits.kernel.lift g f w ‚â´ category_theory.limits.kernel.map g g' q r h‚ÇÇ = p ‚â´ category_theory.limits.kernel.lift g' f' w'
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (P : category_theory.subobject Y) (f : X ‚ü∂ Y) : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} {m‚ÇÅ : measurable_space Œ±} {m‚ÇÇ : measurable_space Œ≤} {f : Œ± ‚Üí Œ≤} : m‚ÇÇ ‚â§ measurable_space.map f m‚ÇÅ ‚Üí measurable f
 : interactive.parse interactive.types.location ‚Üí tactic unit
 : category_theory.limits.has_limits_of_size (Type (max v u))
(Œ± : Type u_2) : Type u_2
{M : Type u_1} (A : Type u_4) [monoid M] [monoid A] [mul_distrib_mul_action M A] (r : M) : A ‚Üí* A
(tag : unit) {p : Prop} (h : p) : p
(n : ‚Ñï) : model_with_corners ‚Ñù (euclidean_space ‚Ñù (fin n)) (euclidean_quadrant n)
{m : Type u_2} {n : Type u_3} [fintype m] [fintype n] {Œ± : m ‚Üí n ‚Üí Type v} (M : dmatrix m n Œ±) : dmatrix n m (Œª (j : n) (i : m), Œ± i j)
(ic qc : tactic.instance_cache) (cz_inst a' : expr) (na' : ‚Ñö) : tactic (tactic.instance_cache √ó tactic.instance_cache √ó expr √ó expr)
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [pseudo_emetric_space Œ±] [topological_space Œ≤] [pseudo_emetric_space Œ≥] (f : Œ± √ó Œ≤ ‚Üí Œ≥) (K : nnreal) (ha : ‚àÄ (a : Œ±), continuous (Œª (y : Œ≤), f (a, y))) (hb : ‚àÄ (b : Œ≤), lipschitz_with K (Œª (x : Œ±), f (x, b))) : continuous f
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [comm_group Œ≤] : comm_group Œ±
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] (K : category_theory.pretopology C) : category_theory.grothendieck_topology C
{R : Type u_1} {R‚ÇÇ : Type u_2} [semiring R] [semiring R‚ÇÇ] (œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ) {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] (E : Type u_10) (E‚ÇÇ : Type u_11) [semi_normed_group E] [semi_normed_group E‚ÇÇ] [module R E] [module R‚ÇÇ E‚ÇÇ] : Type (max u_10 u_11)
{G : Type u} [add_monoid G] (x : G) : ‚Ñï
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {R : nnreal} {c : ‚ÑÇ} {f : ‚ÑÇ ‚Üí E} (hd : differentiable_on ‚ÑÇ f (metric.closed_ball c ‚ÜëR)) (hR : 0 < R) : has_fpower_series_on_ball f (cauchy_power_series f c ‚ÜëR) c ‚ÜëR
 : Type u ‚•§ Top
{L : first_order.language} {T : L.Theory} (M : T.Model) : T.Model
{k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] (p : submodule k V) : affine_subspace k V
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {i : D ‚•§ C} [category_theory.reflective i] (A : C) {B : C} (hB : B ‚àà i.ess_image) : (A ‚ü∂ B) ‚âÉ (i.obj ((category_theory.left_adjoint i).obj A) ‚ü∂ B)
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] (e : topological_fiber_bundle.trivialization F proj) : topological_fiber_bundle.pretrivialization F proj
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.is_iso f.op] : category_theory.is_iso f
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} {F G : Top.presheaf C X} (Œ± : F ‚âÖ G) (h : F.is_sheaf) : G.is_sheaf
{Œπ : Type u_1} {ùïú : Type u_2} {F : Type u_3} [fintype Œπ] [semiring ùïú] [topological_space ùïú] [add_comm_monoid F] [module ùïú F] [topological_space F] [has_continuous_add F] [has_continuous_smul ùïú F] (f : (Œπ ‚Üí ùïú) ‚Üí‚Çó[ùïú] F) : continuous ‚áëf
(M : Type u_5) (N : Type u_6) [has_mul M] [has_mul N] : M √ó N ‚Üí‚Çô* N
(l : Type u_4) (R : Type u‚ÇÇ) [decidable_eq l] [comm_ring R] : matrix (l ‚äï l) (l ‚äï l) R
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] {s : set E} {f : E ‚Üí E} {f' : E ‚Üí (E ‚ÜíL[‚Ñù] E)} [measurable_space E] [borel_space E] (hs : measurable_set s) (hf' : ‚àÄ (x : E), x ‚àà s ‚Üí has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : measurable_embedding (s.restrict f)
(R : Type u_1) {B : Type u_3} (F : Type u_4) (E : B ‚Üí Type u_5) [semiring R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] : Type (max u_3 u_4 u_5)
(C : Type u‚ÇÅ) [category_theory.category C] (D : Type u‚ÇÇ) [category_theory.category D] : C √ó D ‚•§ D
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) : category_theory.is_iso (category_theory.limits.kernel.Œπ 0)
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b : Œ±} : a - b ‚â§ 0 ‚Üí a ‚â§ b
 : list (expr √ó ‚Ñï) ‚Üí tactic expr
{M : Type u_3} {N : Type u_4} {hM : has_one M} {hN : has_one N} (f : one_hom M N) (f' : M ‚Üí N) (h : f' = ‚áëf) : one_hom M N
 : Type
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [polish_space Œ±] [topological_space Œ≤] [polish_space Œ≤] : polish_space (Œ± ‚äï Œ≤)
(l : Type u_4) (R : Type u‚ÇÇ) [decidable_eq l] [comm_ring R] : matrix (unit ‚äï l ‚äï l) (unit ‚äï l ‚äï l) R
{Œ± : Type u_1} [partial_order Œ±] [succ_order Œ±] [is_succ_archimedean Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) {n m : Œ±} (h : ‚àÄ (i : Œ±), i ‚àà set.Ico m n ‚Üí r (order.succ i) i) (hmn : m < n) : relation.trans_gen r n m
{R : Type u} [comm_semiring R] {A : Type v‚ÇÅ} [semiring A] [algebra R A] {B : Type v‚ÇÇ} [semiring B] [algebra R B] {C : Type v‚ÇÉ} [semiring C] [algebra R C] {D : Type v‚ÇÑ} [semiring D] [algebra R D] (f : A ‚âÉ‚Çê[R] B) (g : C ‚âÉ‚Çê[R] D) : tensor_product R A C ‚âÉ‚Çê[R] tensor_product R B D
{A : Type u_2} [normed_division_ring A] [normed_algebra ‚ÑÇ A] [complete_space A] : ‚ÑÇ ‚âÉ‚Çê[‚ÑÇ] A
 : Type
(R : Type u_1) (M : Type u_2) (N : Type u_3) (Œπ : Type u_4) (Œ∫ : Type u_5) [comm_ring R] [add_comm_group M] [module R M] [add_comm_group N] [module R N] : tensor_product R (Œπ ‚Üí‚ÇÄ M) (Œ∫ ‚Üí‚ÇÄ N) ‚âÉ‚Çó[R] Œπ √ó Œ∫ ‚Üí‚ÇÄ tensor_product R M N
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) [category_theory.is_iso h.counit] : category_theory.full R
{R : Type u} {S : Type v} [ring R] [set_like S R] [hSR : subring_class S R] (s : S) : ‚Ü•s ‚Üí+* R
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (t : category_theory.limits.cocone F) : Type (max u‚ÇÅ u‚ÇÉ v‚ÇÉ)
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] (f : M ‚Üí+ N) (H1 : ‚àÄ (y : ‚Ü•S), is_add_unit (‚áëf ‚Üëy)) (H2 : ‚àÄ (z : N), ‚àÉ (x : M √ó ‚Ü•S), z + ‚áëf ‚Üë(x.snd) = ‚áëf x.fst) (H3 : ‚àÄ (x y : M), ‚áëf x = ‚áëf y ‚Üî ‚àÉ (c : ‚Ü•S), x + ‚Üëc = y + ‚Üëc) : S.localization_map N
(n : ‚Ñï) (n_pos : 0 < n) : 4 ^ n ‚â§ 2 * n * n.central_binom
(Œ± : Type u_1) [linear_order Œ±] : circular_order Œ±
 : monoid ordinal
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u_1} [category_theory.category E] (F : C ‚•§ D) (G : D ‚•§ E) (hF : category_theory.is_equivalence F) (hGF : category_theory.is_equivalence (F ‚ãô G)) : category_theory.is_equivalence G
 : Type (u_1+1)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommMon) : category_theory.creates_limit F (category_theory.forget‚ÇÇ AddCommMon AddMon)
{d : ‚Ñ§} : has_mul (‚Ñ§‚àöd)
{R : Type u} {Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [decidable_eq Œπ] [semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [topological_space M‚ÇÇ] (f : continuous_multilinear_map R M‚ÇÅ M‚ÇÇ) [fintype Œπ] (m m' : Œ† (i : Œπ), M‚ÇÅ i) : ‚áëf (m + m') = finset.univ.sum (Œª (s : finset Œπ), ‚áëf (s.piecewise m m'))
 : tactic.alias.target ‚Üí name
{X : Type u_1} [topological_space X] {U : set X} [Œ† (x : X), decidable (x ‚àà U)] (hU : is_clopen U) : locally_constant X (fin 2)
{Œ± : Type u} [topological_space Œ±] (x : Œ±) [(nhds_within x {x}·∂ú).ne_bot] : closure {x}·∂ú = set.univ
{K : Type u_1} [field K] (R S : valuation_subring K) (h : R ‚â§ S) : R.value_group ‚Üí*‚ÇÄ S.value_group
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {Œ≤ : Type u_4} [linear_ordered_field ùïú] [add_comm_group E] [add_comm_group F] [ordered_add_comm_monoid Œ≤] [module ùïú E] [module ùïú F] [has_scalar ùïú Œ≤] {f : F ‚Üí Œ≤} (g : E ‚Üí·µÉ[ùïú] F) {s : set F} (hf : concave_on ùïú s f) : concave_on ùïú (‚áëg ‚Åª¬π' s) (f ‚àò ‚áëg)
(e l : expr) : expr
{p : ‚Ñï} : padic_val_rat p 1 = 0
(a : snum) : snum ‚Üí snum
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A ‚ü∂ B) [category_theory.limits.has_image f] (g : B ‚ü∂ C) [category_theory.limits.has_kernel g] (w : f ‚â´ g = 0) (h : category_theory.limits.image_subobject f ‚â§ category_theory.limits.kernel_subobject g) : (category_theory.limits.image_subobject f).of_le (category_theory.limits.kernel_subobject g) h = image_to_kernel f g w
(Œ± : Type u_1) [fintype Œ±] : Œ± ‚âÉ fin (fintype.card Œ±)
{Œ± : Type u} : ordnode Œ± ‚Üí Œ± ‚Üí ordnode Œ± ‚Üí Œ± √ó ordnode Œ±
(p n : ‚Ñï) : ‚Ñï
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (hf : function.injective2 f) (a : Œ±) : function.injective (f a)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} {C‚ÇÅ C‚ÇÇ : homological_complex V c} (f : Œ† (i : Œπ), C‚ÇÅ.X i ‚âÖ C‚ÇÇ.X i) (hf : ‚àÄ (i j : Œπ), c.rel i j ‚Üí (f i).hom ‚â´ C‚ÇÇ.d i j = C‚ÇÅ.d i j ‚â´ (f j).hom) : C‚ÇÅ ‚âÖ C‚ÇÇ
{Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : is_monoid_hom f
{Œπ : Type u_1} [decidable_eq Œπ] (A : Œπ ‚Üí Type u_2) [has_add Œπ] [Œ† (i : Œπ), add_comm_monoid (A i)] : Type (max u_1 u_2)
{Œ± : Type u_2} {Œ≤ : Type u_3} (r : Œ± ‚Üí Œ≤ ‚Üí Prop) (t : set Œ≤) : set Œ±
{n : ‚Ñï} (hn : even n) (h : n ‚â† 0) : strict_convex_on ‚Ñù set.univ (Œª (x : ‚Ñù), x ^ n)
{R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R)
{Œ± : Type u_1} {Œ≤ : Type u_2} (m : Œ± ‚Üí Œ≤) {f : filter Œ≤} (F : f.realizer) : (filter.comap m f).realizer
(X : Profinite) : category_theory.limits.limit_cone X.diagram
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_finite_products D] (e : C ‚âå D) [h : category_theory.cartesian_closed C] : category_theory.cartesian_closed D
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] {p : submodule R M} : M ‚Üí M ‚ß∏ p
(Œ± : Type u_7) : Type u_7
{a : ‚Ñï} (a1 : 1 < a) (n : ‚Ñï) : ‚Ñï
{Œ± : Type u_2} [has_inv Œ±] : has_inv (set Œ±)
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} (t : category_theory.limits.pushout_cocone f g) (create : Œ† (s : category_theory.limits.pushout_cocone f g), {l // t.inl ‚â´ l = s.inl ‚àß t.inr ‚â´ l = s.inr ‚àß ‚àÄ {m : t.X ‚ü∂ s.X}, t.inl ‚â´ m = s.inl ‚Üí t.inr ‚â´ m = s.inr ‚Üí m = l}) : category_theory.limits.is_colimit t
{D : set ‚Ñù} (hD : convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù} (hf : continuous_on f D) (hf' : differentiable_on ‚Ñù f (interior D)) {C : ‚Ñù} (le_hf' : ‚àÄ (x : ‚Ñù), x ‚àà interior D ‚Üí deriv f x ‚â§ C) (x : ‚Ñù) (H : x ‚àà D) (y : ‚Ñù) (H_1 : y ‚àà D) : x ‚â§ y ‚Üí f y - f x ‚â§ C * (y - x)
{Œ± : Type u_1} [add_group Œ±] (s : add_subgroup Œ±) : quotient (quotient_add_group.right_rel s) ‚âÉ Œ± ‚ß∏ s
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] (f : Œ≤ ‚Üí set Œ±) : Prop
 : tactic.interactive.case_tag ‚Üí list name
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (P : C·µí·µñ ‚•§ Type v‚ÇÅ) (S : category_theory.sieve X) : Prop
(R : Type u) (S : Type v) [semiring R] [semiring S] (p q : ‚Ñï) [char_p R p] [char_p S q] : char_p (R √ó S) (p.lcm q)
(E : Type u_1) [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] : ‚Ñù
{Œ± : Type u_1} [uniform_space Œ±] [add_group Œ±] [uniform_add_group Œ±] : Œ± ‚Üí+ uniform_space.completion Œ±
{K : Type u_1} [field K] [fintype K] {K' : Type u_2} [field K'] [fintype K'] (hKK' : fintype.card K = fintype.card K') : K ‚âÉ+* K'
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} [category_theory.limits.has_pullbacks C] : category_theory.mono_over.pullback (ùüô X) ‚âÖ ùü≠ (category_theory.mono_over X)
{Œ± : Type u} (c‚ÇÅ c‚ÇÇ : computation Œ±) : computation Œ±
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (X‚ÇÄ X‚ÇÅ X‚ÇÇ : V) (d‚ÇÄ : X‚ÇÅ ‚ü∂ X‚ÇÄ) (d‚ÇÅ : X‚ÇÇ ‚ü∂ X‚ÇÅ) (s : d‚ÇÅ ‚â´ d‚ÇÄ = 0) (succ : Œ† (t : Œ£' (X‚ÇÄ X‚ÇÅ X‚ÇÇ : V) (d‚ÇÄ : X‚ÇÅ ‚ü∂ X‚ÇÄ) (d‚ÇÅ : X‚ÇÇ ‚ü∂ X‚ÇÅ), d‚ÇÅ ‚â´ d‚ÇÄ = 0), Œ£' (X‚ÇÉ : V) (d‚ÇÇ : X‚ÇÉ ‚ü∂ t.snd.snd.fst), d‚ÇÇ ‚â´ t.snd.snd.snd.snd.fst = 0) : chain_complex V ‚Ñï
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] (l : Œ± ‚Üí Œ≤) (u : Œ≤ ‚Üí Œ±) : Type (max u_2 u_3)
{R : Type u} {M : Type v} (x : triv_sq_zero_ext R M) : M
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommRing) : category_theory.limits.cocone F
{Œ± : Sort u_1} {Œ≤‚ÇÅ : Œ± ‚Üí Sort u_2} {Œ≤‚ÇÇ : Œ± ‚Üí Sort u_3} (F : Œ† (a : Œ±), Œ≤‚ÇÅ a ‚âÉ Œ≤‚ÇÇ a) : (Œ† (a : Œ±), Œ≤‚ÇÅ a) ‚âÉ Œ† (a : Œ±), Œ≤‚ÇÇ a
{R : Type u_1} [has_mul R] {a : R} : is_left_regular a ‚Üî is_smul_regular R a
{R : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_4} {Œ≥ : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10} {l' : Type u_14} {m' : Type u_15} {n' : Type u_16} [comm_semiring R] [fintype m] [fintype m'] [non_unital_non_assoc_semiring Œ±] [non_unital_non_assoc_semiring Œ≤] [non_unital_non_assoc_semiring Œ≥] [module R Œ±] [module R Œ≤] [module R Œ≥] (f : Œ± ‚Üí‚Çó[R] Œ≤ ‚Üí‚Çó[R] Œ≥) (h_comm : ‚àÄ (a b : Œ±) (a' b' : Œ≤), ‚áë(‚áëf (a * b)) (a' * b') = ‚áë(‚áëf a) a' * ‚áë(‚áëf b) b') (A : matrix l m Œ±) (B : matrix m n Œ±) (A' : matrix l' m' Œ≤) (B' : matrix m' n' Œ≤) : ‚áë(‚áë(matrix.kronecker_map_bilinear f) (A.mul B)) (A'.mul B') = (‚áë(‚áë(matrix.kronecker_map_bilinear f) A) A').mul (‚áë(‚áë(matrix.kronecker_map_bilinear f) B) B')
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [semilattice_sup Œ±] [order_bot Œ±] (s : finset Œ≤) (t : finset Œ≥) (f : Œ≤ √ó Œ≥ ‚Üí Œ±) : (s.product t).sup f = s.sup (Œª (i : Œ≤), t.sup (Œª (i' : Œ≥), f (i, i')))
{A : Type u_2} [comm_ring A] [is_domain A] (h : is_dedekind_domain_inv A) : is_dedekind_domain A
{Œπ : Type u_1} {Œ± : Type u_3} [preorder Œπ] [preorder Œ±] {l : filter Œπ} {u : Œπ ‚Üí Œ±} (h : monotone u) [l.ne_bot] (hu : filter.tendsto u l filter.at_bot) : filter.tendsto u filter.at_bot filter.at_bot
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {v‚ÇÅ v‚ÇÇ : ray_vector R M} : v‚ÇÅ ‚âà v‚ÇÇ ‚Üî same_ray R ‚Üëv‚ÇÅ ‚Üëv‚ÇÇ
{Œ± : Type u_2} [has_zero Œ±] [has_add Œ±] [has_neg Œ±] : has_scalar ‚Ñ§ (filter Œ±)
(attr_name : name) : tactic simp_lemmas
(tooltip : widget.tc subexpr empty) (e : expr) : tactic (widget.html empty)
(c : omega.clause) : tactic expr
{Œ± : Type u} [ordered_semiring Œ±] [nontrivial Œ±] : 0 < 4
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [add_comm_monoid M] {g : Œ≤ ‚Üí M} (e : Œ± ‚Üí Œ≤) (he‚ÇÄ : function.bijective e) : finsum (Œª (i : Œ±), g (e i)) = finsum (Œª (j : Œ≤), g j)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : 0 ‚â§ euclidean_geometry.angle p1 p2 p3
{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] {m : Type w‚ÇÅ} [decidable_eq m] [fintype m] (e : n ‚âÉ m) : matrix n n R ‚âÉ‚Çó‚ÅÖR‚ÅÜ matrix m m R
(n : ‚Ñï) : n.choose 2 = n * (n - 1) / 2
 : tactic (list expr)
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) [complete_space E] [complete_space ‚Ü•K] (w : E) : w = ‚Üë(‚áë(orthogonal_projection K) w) + ‚Üë(‚áë(orthogonal_projection K·óÆ) w)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h1 : ‚Üës1.nonempty) (h2 : ‚Üës2.nonempty) (he : ‚Üës1 ‚à© ‚Üës2 = ‚àÖ) : s1.direction ‚äî s2.direction < (s1 ‚äî s2).direction
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) (Y : D) : e.unit.app (e.inverse.obj Y) ‚â´ e.inverse.map (e.counit.app Y) = ùüô (e.inverse.obj Y)
{M : Type u_1} [linear_ordered_cancel_add_comm_monoid M] {A : Type u_2} [set_like A M] [add_submonoid_class A M] (S : A) : linear_ordered_cancel_add_comm_monoid ‚Ü•S
{Œ± : Type u} [preorder Œ±] {a b c : Œ±} : b = c ‚Üí a < b ‚Üí a < c
(R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] : ‚Üë(finite_dimensional.finrank R M) = module.rank R M
{Y : Type u_2} [topological_space Y] [normal_space Y] {s : set Y} (f : C(‚Ü•s, ‚Ñù)) {t : set ‚Ñù} [t.ord_connected] (ht : ‚àÄ (x : ‚Ü•s), ‚áëf x ‚àà t) (hne : t.nonempty) (hs : is_closed s) : ‚àÉ (g : C(Y, ‚Ñù)), (‚àÄ (y : Y), ‚áëg y ‚àà t) ‚àß continuous_map.restrict s g = f
(X : Type u_1) : Type u_1
{p : ereal √ó ereal} (h : p.fst ‚â† ‚ä§ ‚à® p.snd ‚â† ‚ä•) (h' : p.fst ‚â† ‚ä• ‚à® p.snd ‚â† ‚ä§) : continuous_at (Œª (p : ereal √ó ereal), p.fst + p.snd) p
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) [category_theory.is_filtered J] : Mon
(G : Type u_2) [group G] [fintype G] (R : Type u_3) [comm_ring R] [mul_semiring_action G R] (x : R) : polynomial R
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {p : filter Œπ} (h : tendsto_uniformly_on F f p s) (g : Œ≥ ‚Üí Œ±) : tendsto_uniformly_on (Œª (n : Œπ), F n ‚àò g) (f ‚àò g) p (g ‚Åª¬π' s)
{C : Type u} [category_theory.category C] : category_theory.with_initial C ‚Üí category_theory.with_initial C ‚Üí Type v
{Œπ : Type u_1} (R : Type u_2) {Œ∑ : Œπ ‚Üí Type u_4} {N : Type u_5} [semiring R] [add_comm_monoid N] [module R N] : ((Œ£ (i : Œπ), Œ∑ i) ‚Üí‚ÇÄ N) ‚âÉ‚Çó[R] Œ†‚ÇÄ (i : Œπ), Œ∑ i ‚Üí‚ÇÄ N
(Œ± : Type u_1) [add_comm_group Œ±] : Type u_1
{Œ± : Type u} [topological_space Œ±] (x : Œ±) [(nhds_within x {x}·∂ú).ne_bot] : dense {x}·∂ú
{n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type u} (q : Œ† (i : fin (n + 1)), Œ± i) : fin.snoc (fin.init q) (q (fin.last n)) = q
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí. Œ≤) (l : filter Œ≤) : filter Œ±
{R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (r : R) (x y : A) : r ‚Ä¢ x * y = r ‚Ä¢ (x * y)
 : ¬¨small ordinal
{L : first_order.language} {n : ‚Ñï} (f : L.functions n) : L.formula (fin (n + 1))
{Œ± : Type u} [pseudo_emetric_space Œ±] (E : set Œ±) : closure E = ‚ãÇ (Œ¥ : ‚Ñù) (h : 0 < Œ¥), metric.cthickening Œ¥ E
(R : Type u_1) (S : Type u_2) (M : Type u_3) : Type u_3
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_group Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} : strict_convex_on ùïú s f ‚Üí strict_concave_on ùïú s (-f)
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {s : submodule K V} (h : s < ‚ä§) : finite_dimensional.finrank K ‚Ü•s < finite_dimensional.finrank K V
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (L : C ‚•§ D) [category_theory.is_left_adjoint L] : D ‚•§ C
 : metric_space (‚Ñï ‚Üí ‚Ñï)
(ùïú : Type u_1) {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_monoid Œ≤] [has_scalar ùïú E] [has_scalar ùïú Œ≤] (s : set E) (f : E ‚Üí Œ≤) : Prop
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J·µí·µñ ‚•§ C} (c : category_theory.limits.cocone F) : category_theory.limits.cone F.right_op
{C : Type u‚ÇÅ} [category_theory.category C] {G : category_theory.comonad C} (A : G.coalgebra) : A.hom A
{Œ± : Type u_1} {Œ≤ : Type u_2} (q : pmf (Œ± ‚Üí Œ≤)) (p : pmf Œ±) : pmf Œ≤
(f : format) : format
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} {f' g : ‚Ñù ‚Üí E} (derivf : ‚àÄ (x : ‚Ñù), x ‚àà set.Ico a b ‚Üí has_deriv_within_at f (f' x) (set.Ici x) x) (derivg : ‚àÄ (x : ‚Ñù), x ‚àà set.Ico a b ‚Üí has_deriv_within_at g (f' x) (set.Ici x) x) (fcont : continuous_on f (set.Icc a b)) (gcont : continuous_on g (set.Icc a b)) (hi : f a = g a) (y : ‚Ñù) (H : y ‚àà set.Icc a b) : f y = g y
{Œ± : Type u_2} {Œ≤ : Type u_3} [monoid Œ±] [mul_action Œ± Œ≤] : mul_action Œ± (set Œ≤)
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f : M ‚Üí+ N) : with_top M ‚Üí+ with_top N
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {f‚ÇÄ f‚ÇÅ : C(X, Y)} (F : f‚ÇÄ.homotopy f‚ÇÅ) : C(‚Ñù, C(X, Y))
{Œ± : Type u_3} [preorder Œ±] (n : ‚Ñï) [grade_order (fin n) Œ±] : grade_order ‚Ñï Œ±
{Œ± : Type u_1} [decidable_eq Œ±] : list Œ± ‚Üí list (equiv.perm Œ±)
(e : expr) : tactic ‚Ñï
 : tactic unit
{C : Type u_1} [category_theory.category C] (G : C ‚•§ Type w) : category_theory.grothendieck (G ‚ãô category_theory.Type_to_Cat) ‚•§ G.elements
{X Y : Profinite} (f : X ‚ü∂ Y) (bij : function.bijective ‚áëf) : X ‚âÖ Y
{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_right_regular a) : is_add_right_regular (b + a) ‚Üî is_add_right_regular b
{l r : Type u_1} (L : l ‚Üí pgame) (R : r ‚Üí pgame) (IHl : l ‚Üí pgame) (IHr : r ‚Üí pgame) {b : bool} : pgame.inv_ty l r b ‚Üí pgame
{X Y : Top} {f g : C(‚Ü•X, ‚Ü•Y)} (H : f.homotopy g) {x‚ÇÄ x‚ÇÅ : ‚Ü•X} (p : fundamental_groupoid.from_top x‚ÇÄ ‚ü∂ fundamental_groupoid.from_top x‚ÇÅ) : fundamental_groupoid.from_top (‚áëf x‚ÇÄ) ‚ü∂ fundamental_groupoid.from_top (‚áëg x‚ÇÅ)
{Œ± : Type u_1} {G : Type u_5} [topological_space G] [add_comm_group G] [topological_add_group G] {f : Œ± ‚Üí G} (hf : summable f) : filter.tendsto f filter.cofinite (nhds 0)
(R : Type u_1) (M : Type u_9) [semiring R] [add_comm_monoid M] [module R M] {m : Type u_20} {n : Type u_21} (f : m ‚Üí n) : (n ‚Üí M) ‚Üí‚Çó[R] m ‚Üí M
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] (f : ‚ÑÇ ‚Üí E) (z w : ‚ÑÇ) (Hd : differentiable_on ‚Ñù f (set.interval z.re w.re √ó‚ÑÇ set.interval z.im w.im)) (Hi : measure_theory.integrable_on (Œª (z : ‚ÑÇ), complex.I ‚Ä¢ ‚áë(fderiv ‚Ñù f z) 1 - ‚áë(fderiv ‚Ñù f z) complex.I) (set.interval z.re w.re √ó‚ÑÇ set.interval z.im w.im) measure_theory.measure_space.volume) : (((‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üë(z.im) * complex.I)) - ‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üë(w.im) * complex.I)) + complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üë(w.re) + ‚Üëy * complex.I)) - complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üë(z.re) + ‚Üëy * complex.I) = ‚à´ (x : ‚Ñù) in z.re..w.re, ‚à´ (y : ‚Ñù) in z.im..w.im, complex.I ‚Ä¢ ‚áë(fderiv ‚Ñù f (‚Üëx + ‚Üëy * complex.I)) 1 - ‚áë(fderiv ‚Ñù f (‚Üëx + ‚Üëy * complex.I)) complex.I
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.shift_functor C (-i) ‚ãô category_theory.shift_functor C i ‚âÖ ùü≠ C
(ùïú : Type u) [nondiscrete_normed_field ùïú] {E : Type v} [normed_group E] [normed_space ùïú E] [complete_space ùïú] {r : ‚Ñù} (rpos : 0 < r) {c : E} (h : is_compact (metric.closed_ball c r)) : finite_dimensional ùïú E
{Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_group_hom f) : function.injective f ‚Üî ‚àÄ (a : Œ±), f a = 0 ‚Üí a = 0
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (rk : Œ± ‚Üí ‚Ñï) (s : set Œ±) (n : ‚Ñï) (f : ‚Ñï ‚Üí Œ±) : Prop
(m : ‚Ñï) {n : ‚Ñï} (hn : 0 < n) : (‚àÉ (k : ‚Ñï), n * k < m ‚àß m < n * (k + 1)) ‚Üî ¬¨n ‚à£ m
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {n : ‚Ñï} {f : ùïú ‚Üí F} {s : set ùïú} : iterated_deriv_within n f s = ‚áë((continuous_multilinear_map.pi_field_equiv ùïú (fin n) F).symm) ‚àò iterated_fderiv_within ùïú n f s
(x y : Set) : Set
{ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_5} [normed_field ùïú] [add_comm_group E] [module ùïú E] (p : seminorm_family ùïú E Œπ) [nonempty Œπ] : module_filter_basis ùïú E
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ≤} (hf : continuous f) : f ‚Åª¬π' interior s ‚äÜ interior (f ‚Åª¬π' s)
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} {f : A ‚ü∂ B} [category_theory.limits.has_image f] {g : B ‚ü∂ C} [category_theory.limits.has_kernel g] (w : f ‚â´ g = 0) {A' B' C' : V} {f' : A' ‚ü∂ B'} [category_theory.limits.has_image f'] {g' : B' ‚ü∂ C'} [category_theory.limits.has_kernel g'] (w' : f' ‚â´ g' = 0) (Œ± : category_theory.arrow.mk f ‚ü∂ category_theory.arrow.mk f') [category_theory.limits.has_image_map Œ±] (Œ≤ : category_theory.arrow.mk g ‚ü∂ category_theory.arrow.mk g') [category_theory.limits.has_cokernel (image_to_kernel f g w)] [category_theory.limits.has_cokernel (image_to_kernel f' g' w')] (p : Œ±.right = Œ≤.left) : homology f g w ‚ü∂ homology f' g' w'
 : Type (u+1)
{Œ± : Type u_1} (s : set Œ±) : set Œ±·µí·µñ
 : tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [add_comm_group Œ±] [topological_space Œ±] [topological_add_group Œ±] {f : Œ≤ ‚Üí Œ±} [t2_space Œ±] [decidable_eq Œ≤] (hf : summable f) (b : Œ≤) : ‚àë' (n : Œ≤), f n = f b + ‚àë' (n : Œ≤), ite (n = b) 0 (f n)
 : expr ‚Üí name √ó binder_info √ó expr
{R : Type u} [ring R] (a : R) {n : ‚Ñï} (h : n ‚â† 0) : (polynomial.X ^ n - ‚áëpolynomial.C a).monic
{K : Type u_1} {v : K} {n : ‚Ñï} [linear_ordered_field K] [floor_ring K] (hyp : n = 0 ‚à® ¬¨(generalized_continued_fraction.of v).terminated_at (n - 1)) : ‚Üë(nat.fib (n + 1)) ‚â§ (generalized_continued_fraction.of v).denominators n
(Œ± : Type u_6) : Type u_6
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (G : D ‚•§ C) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
(p : tactic.ring_exp.ex tactic.ring_exp.ex_type.exp) (ps : tactic.ring_exp.ex tactic.ring_exp.ex_type.prod) : tactic.ring_exp.ring_exp_m (tactic.ring_exp.ex tactic.ring_exp.ex_type.prod)
{Œ± : Type u} {Œ≤ : Type v} [complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [complete_linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] {Œπ : Sort u_1} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±} (Cf : continuous_at f (supr g)) (Mf : monotone f) (fbot : f ‚ä• = ‚ä•) : f (‚®Ü (i : Œπ), g i) = ‚®Ü (i : Œπ), f (g i)
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± : D·µí·µñ ‚•§ A} {‚Ñ±' : category_theory.Sheaf K A} (Œ± : G.op ‚ãô ‚Ñ± ‚ü∂ G.op ‚ãô ‚Ñ±'.val) : category_theory.coyoneda ‚ãô (category_theory.whiskering_left D·µí·µñ A (Type u_8)).obj ‚Ñ± ‚ü∂ category_theory.coyoneda ‚ãô (category_theory.whiskering_left D·µí·µñ A (Type u_8)).obj ‚Ñ±'.val
{Œ± : Type} (p : parser Œ±) : Prop
(p q : omega.nat.preform) : Prop
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] {f : add_hom M N} (hf : function.surjective ‚áëf) : galois_insertion (add_subsemigroup.map f) (add_subsemigroup.comap f)
{R : Type u} {Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [decidable_eq Œπ] [comm_semiring R] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), module R (M‚ÇÅ i)] [module R M‚ÇÇ] [topological_space R] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [topological_space M‚ÇÇ] [has_continuous_smul R M‚ÇÇ] (f : continuous_multilinear_map R M‚ÇÅ R) (z : M‚ÇÇ) : continuous_multilinear_map R M‚ÇÅ M‚ÇÇ
(Œ± : Type u_1) (Œ≤ : Type u_2) [linear_order Œ±] [linear_order Œ≤] : linear_order (Œ± √ó‚Çó Œ≤)
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : set P) : Prop
(F : Type u ‚Üí Type u) [functor F] [q : qpf F] : Type u
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [‚àÄ (X Y : C), subsingleton (X ‚ü∂ Y)] (hC : category_theory.skeletal C) : category_theory.skeletal (D ‚•§ C)
{Œ± : Type u} [has_mul Œ±] [has_one Œ±] [has_distrib_neg Œ±] (a : Œ±) [invertible a] : invertible (-a)
{Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [partial_order Œπ] [bounded_order Œπ] [Œ† (i : Œπ), preorder (Œ± i)] [order_bot (Œ± ‚ä•)] [order_top (Œ± ‚ä§)] : bounded_order (Œ£‚Çó (i : Œπ), Œ± i)
{G : Type u_1} [group G] [topological_space G] (K‚ÇÄ : set G) (V : topological_space.open_nhds_of 1) : set (topological_space.compacts G ‚Üí ‚Ñù)
{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] {P : ratfunc K ‚Üí Prop} (x : ratfunc K) (f : ‚àÄ (p q : polynomial K), q ‚â† 0 ‚Üí P (ratfunc.mk p q)) : P x
{Œπ : Type u_1} {R : Type u_2} {N : Type u_5} [dec_Œπ : decidable_eq Œπ] [semiring R] [add_comm_monoid N] [module R N] (p : Œπ ‚Üí submodule R N) : supr p = (‚áë(dfinsupp.lsum ‚Ñï) (Œª (i : Œπ), (p i).subtype)).range
(C : Type u‚ÇÅ) [category_theory.category C] : category_theory.paths C ‚•§ C
{M : Type w} [field M] [is_alg_closed M] {R : Type u} [comm_ring R] {S : Type v} [comm_ring S] [is_domain S] [algebra R S] [algebra R M] [no_zero_smul_divisors R S] [no_zero_smul_divisors R M] (hS : algebra.is_algebraic R S) : S ‚Üí‚Çê[R] M
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] : Top
(n : ‚Ñï) (A : Type u) : mvpfunctor n
{Œ± : Type u_1} [partial_order Œ±] [succ_order Œ±] [is_succ_archimedean Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) {n m : Œ±} (h : ‚àÄ (i : Œ±), i ‚àà set.Ico m n ‚Üí r (order.succ i) i) (hmn : m ‚â§ n) : relation.refl_trans_gen r n m
{t t' : Type u ‚Üí Type u} (eqv : Œ† (Œ± : Type u), t Œ± ‚âÉ t' Œ±) [traversable t] {m : Type u ‚Üí Type u} [applicative m] {Œ± Œ≤ : Type u} (f : Œ± ‚Üí m Œ≤) (x : t' Œ±) : m (t' Œ≤)
{M : Type u_1} [has_add M] : has_bot (add_subsemigroup M)
{X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X) : continuous c.lim
{Œ± : Type u} {Œ≤ : Type v} [decidable_eq Œ≤] [fintype Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) {n : ‚Ñï} [nonempty Œ≤] (hn : fintype.card Œ≤ * n ‚â§ fintype.card Œ±) : ‚àÉ (y : Œ≤), n ‚â§ (finset.filter (Œª (x : Œ±), f x = y) finset.univ).card
 : (Œª (n : ‚Ñï), ‚Üë(nat.fib n)) = Œª (n : ‚Ñï), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5
{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) {M' : Type u_8} [add_comm_monoid M'] [module R M'] (q‚ÇÅ : submodule R M') : submodule R (M √ó M')
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) (k : N ‚âÉ* P) : S.localization_map P
{G : Type u_1} [group G] [group.is_nilpotent G] (h : group.nilpotency_class G ‚â§ 1) : comm_group G
(ùïú : Type u) (G : Type wG) (G' : Type wG') [nondiscrete_normed_field ùïú] [normed_group G] [normed_space ùïú G] [normed_group G'] [normed_space ùïú G'] : continuous_multilinear_map ùïú (Œª (i : fin 0), G) G' ‚âÉ‚Çó·µ¢[ùïú] G'
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f
{Œ± : Type u_3} [semilattice_inf Œ±] [no_min_order Œ±] (a : Œ±) : filter.map coe filter.at_bot = filter.at_bot
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (left : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
 : pseudo_metric_space ‚Ñù
{M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] : has_zero (M ‚Üí+ N)
{G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G ‚âÉ* G') : group.is_nilpotent G'
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) (h : e.to_local_equiv.source = set.univ) (h' : e.to_local_equiv.target = set.univ) : Œ± ‚âÉ‚Çú Œ≤
{A : Type u_1} (B : Type u_2) [field A] [ring B] [algebra A B] [nontrivial B] (a : A) : minpoly A (‚áë(algebra_map A B) a) = polynomial.X - ‚áëpolynomial.C a
{Œ± : Type u} [pseudo_emetric_space Œ±] {s t : set Œ±} {r : ennreal} (H1 : ‚àÄ (x : Œ±), x ‚àà s ‚Üí (‚àÉ (y : Œ±) (H : y ‚àà t), has_edist.edist x y ‚â§ r)) (H2 : ‚àÄ (x : Œ±), x ‚àà t ‚Üí (‚àÉ (y : Œ±) (H : y ‚àà s), has_edist.edist x y ‚â§ r)) : emetric.Hausdorff_edist s t ‚â§ r
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_Inf Œ±] [has_Inf Œ≤] (f : Inf_hom Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : Inf_hom Œ± Œ≤
(n : ‚Ñï) : comm_semigroup (fin (n + 1))
(n : ‚Ñï) : Type
{R : Type u} [comm_semiring R] (l : list (polynomial R)) (x : R) : polynomial.eval x l.prod = (list.map (polynomial.eval x) l).prod
{F : Type v} [normed_group F] [normed_space ‚ÑÇ F] {f : ‚ÑÇ ‚Üí F} (hf : differentiable ‚ÑÇ f) (hb : metric.bounded (set.range f)) (z w : ‚ÑÇ) : f z = f w
{M : Type uM} {N : Type uN} [mul_one_class M] [comm_monoid N] : M ‚Üí* (M ‚Üí* N) ‚Üí* N
(n : name) : tactic name
 : option pexpr ‚Üí tactic (tactic.dsimp_config √ó format)
{n : Type u_4} [decidable_eq n] (v : n ‚Üí ‚Ñù) : (matrix.diagonal v).is_hermitian
(hs : interactive.parse tactic.simp_arg_list) : tactic unit
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {E : Type u_5} [category_theory.category E] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {L : category_theory.grothendieck_topology E} {F : C ‚•§ D} (hu : category_theory.cover_lifting J K F) {G : D ‚•§ E} (hv : category_theory.cover_lifting K L G) : category_theory.cover_lifting J L (F ‚ãô G)
{Œ± : Type u_2} (l‚ÇÅ l‚ÇÇ : filter Œ±) [countable_Inter_filter l‚ÇÅ] [countable_Inter_filter l‚ÇÇ] : countable_Inter_filter (l‚ÇÅ ‚äì l‚ÇÇ)
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : r ‚Ü™r r
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) (P : Type u_6) [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] : (M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] P) ‚Üí‚Çó[R] tensor_product R M N ‚Üí‚Çó[R] P
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] (f : measure_theory.simple_func Œ± Œ≤) : measurable ‚áëf
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] [category_theory.limits.has_finite_products C] [category_theory.limits.has_finite_products D] (F : C ‚•§ D) {L : D ‚•§ C} [category_theory.cartesian_closed C] [category_theory.cartesian_closed D] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] (h : L ‚ä£ F) (A : C) [i : category_theory.is_iso (category_theory.exp_comparison F A)] : category_theory.is_iso (category_theory.frobenius_morphism F h A)
 : strict_mono (Œª (n : ‚Ñï), nat.fib (n + 2))
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] : ‚Ñ§_[p] ‚Üí+* zmod p
{Œ± : Type u_1} [fintype Œ±] [decidable_eq Œ±] : {f // f.is_cycle} ‚âÉ {s // s.nodup ‚àß s.nontrivial}
{M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] (f : M ‚âÉ* N) (x y : M) : ‚áëf (x * y) = ‚áëf x * ‚áëf y
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (Œ± : E) : ‚Ü•F‚üÆŒ±‚üØ
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] (h : continuous_map.homotopy_equiv X Y) : continuous_map.homotopy_equiv Y X
 : tactic unit
(x : expr) : tactic (omega.nat.preform √ó ‚Ñï)
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (i : D ‚•§ C) [category_theory.limits.has_finite_products C] [category_theory.reflective i] [category_theory.cartesian_closed C] [category_theory.exponential_ideal i] : category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) (category_theory.left_adjoint i)
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (œÅ : representation k G V) [fintype G] [invertible ‚Üë(fintype.card G)] (v : V) : ‚áë(œÅ.average_map) v ‚àà œÅ.invariants
{Œ≤ : Type u} {Œ± : Type v} [comm_semiring Œ≤] {s : finset Œ±} {i : Œ±} {f g h : Œ± ‚Üí Œ≤} (hi : i ‚àà s) (h1 : g i + h i = f i) (h2 : ‚àÄ (j : Œ±), j ‚àà s ‚Üí j ‚â† i ‚Üí g j = f j) (h3 : ‚àÄ (j : Œ±), j ‚àà s ‚Üí j ‚â† i ‚Üí h j = f j) : s.prod (Œª (i : Œ±), g i) + s.prod (Œª (i : Œ±), h i) = s.prod (Œª (i : Œ±), f i)
{Œ± : Type u_1} {n : ‚Ñï} {s t : finset Œ±} : s ‚àà finset.powerset_len n t ‚Üî s ‚äÜ t ‚àß s.card = n
{Œ± : Type u_1} {Œπ : Type u_4} (s : Œπ ‚Üí set Œ±) : (‚ãÉ (i : Œπ), s i) = ‚ãÉ (t : finset Œπ) (i : Œπ) (H : i ‚àà t), s i
{G : Type u_1} [add_group G] (h : add_monoid.exponent_exists G) : add_monoid.is_torsion G
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e : local_homeomorph Œ± Œ≤) (s : set Œ±) (t : set Œ≤) : Prop
{Œ± : Type u_1} [comm_monoid_with_zero Œ±] (a b : Œ±) : Prop
{Œπ : Type v} {M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [decidable_eq Œπ] {R' : Type u_1} {A : Type u_2} [semiring R'] [semiring A] [Œ† (i : Œπ), add_comm_monoid (M‚ÇÅ i)] [add_comm_monoid M‚ÇÇ] [Œ† (i : Œπ), topological_space (M‚ÇÅ i)] [topological_space M‚ÇÇ] [has_continuous_add M‚ÇÇ] [Œ† (i : Œπ), module A (M‚ÇÅ i)] [module A M‚ÇÇ] [module R' M‚ÇÇ] [has_continuous_const_smul R' M‚ÇÇ] [smul_comm_class A R' M‚ÇÇ] : module R' (continuous_multilinear_map A M‚ÇÅ M‚ÇÇ)
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {s‚ÇÅ : setoid Œ±} {s‚ÇÇ : setoid Œ≤} {s‚ÇÉ : setoid Œ≥} {p : quotient s‚ÇÅ ‚Üí quotient s‚ÇÇ ‚Üí quotient s‚ÇÉ ‚Üí Prop} (q‚ÇÅ : quotient s‚ÇÅ) (q‚ÇÇ : quotient s‚ÇÇ) (q‚ÇÉ : quotient s‚ÇÉ) (h : ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ≤) (a‚ÇÉ : Œ≥), p (quotient.mk' a‚ÇÅ) (quotient.mk' a‚ÇÇ) (quotient.mk' a‚ÇÉ)) : p q‚ÇÅ q‚ÇÇ q‚ÇÉ
(R : Type u_1) [ring R] (M : Type u_3) [topological_space M] [add_comm_group M] [module R M] [topological_add_group M] : (M ‚ÜíL[R] M)À£ ‚âÉ* M ‚âÉL[R] M
{R : Type u} {S : Type v} {A : Type w} [comm_semiring R] [comm_semiring S] [semiring A] [algebra R S] [algebra S A] [algebra R A] (h : algebra_map R A = (algebra_map S A).comp (algebra_map R S)) : is_scalar_tower R S A
 : ‚Ñï ‚Üí list ‚Ñï
{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ‚Ñï} (hb : 1 < b) {x : ‚Ñ§} {r : R} (hr : 0 < r) : ‚Üëb ^ x ‚â§ r ‚Üî x ‚â§ int.log b r
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] (K : submodule ùïú E) [complete_space ‚Ü•K] (v : E) : ‚àÉ (y : E) (H : y ‚àà K) (z : E) (H : z ‚àà K·óÆ), v = y + z
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} {S : category_theory.sieve X} : category_theory.mono S.functor_inclusion
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_initial C] [category_theory.limits.has_initial D] [category_theory.limits.preserves_colimit (category_theory.functor.empty C) G] : G.obj (‚ä•_ C) ‚âÖ ‚ä•_ D
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] {f g : M ‚Üí‚Çô* N} {s : set M} (h : set.eq_on ‚áëf ‚áëg s) : set.eq_on ‚áëf ‚áëg ‚Üë(subsemigroup.closure s)
{F : Type u ‚Üí Type u} [functor F] [q : qpf F] : (qpf.P F).W ‚Üí (qpf.P F).W ‚Üí Prop
(F : Type u_9) (Œ± : Type u_10) (Œ≤ : Type u_11) [monoid Œ±] [monoid Œ≤] [topological_space Œ±] [topological_space Œ≤] : Type (max u_10 u_11 u_9)
 : Sort u
{X : Top} {x : ‚Ü•X} (p : x ‚ü∂ x) : fundamental_group ‚Ü•X x
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (e : C ‚âå D) : C·µí·µñ ‚âå D·µí·µñ
{Œ± : Type u_1} (s : multiset Œ±) (hs : s ‚â† 0) : pmf Œ±
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Ü™ Œ≤) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) : ‚áëf ‚Åª¬π'o s ‚Ü™r s
 : Type
{R : Type u} [comm_ring R] {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group N] [module R N] [lie_ring_module L N] [lie_module R L N] : lie_ring_module L (tensor_product R M N)
 : cc_state ‚Üí expr ‚Üí expr ‚Üí tactic bool
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : local_homeomorph E F) {f' : E ‚âÉL[ùïú] F} {a : F} (ha : a ‚àà f.to_local_equiv.target) (htff' : has_strict_fderiv_at ‚áëf ‚Üëf' (‚áë(f.symm) a)) : has_strict_fderiv_at ‚áë(f.symm) ‚Üë(f'.symm) a
{Œ± : Type u} (s : set Œ±) : Prop
{n : ‚Ñï} (h : 0 < n) : random (fin n)
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_group E] [module ùïú E] {s t : set E} (hc : convex_independent ùïú (Œª (x : ‚Ü•t), ‚Üëx)) (hs : s ‚äÜ t) : convex_independent ùïú (Œª (x : ‚Ü•s), ‚Üëx)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms D] (G : C ‚•§ D) [G.preserves_zero_morphisms] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_kernel f] [category_theory.limits.has_kernel (G.map f)] [category_theory.limits.preserves_limit (category_theory.limits.parallel_pair f 0) G] : G.obj (category_theory.limits.kernel f) ‚âÖ category_theory.limits.kernel (G.map f)
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [has_one M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñï] [monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) : monoid M‚ÇÅ
(R : Type u) (S‚ÇÅ : Type v) [comm_semiring R] : mv_polynomial (option S‚ÇÅ) R ‚âÉ‚Çê[R] mv_polynomial S‚ÇÅ (polynomial R)
{Œ± : Type} [has_mul Œ±] {ds : list ‚Ñï} : holor Œ± ds ‚Üí Prop
{Œ± : Type u} [topological_space Œ±] [t0_space Œ±] {s : set Œ±} (hfin : s.finite) (hne : s.nonempty) (ho : is_open s) : ‚àÉ (x : Œ±) (H : x ‚àà s), is_open {x}
{Œ± : Type u} [decidable_eq Œ±] [fintype Œ±] {P : equiv.perm Œ± ‚Üí Prop} (f : equiv.perm Œ±) : P 1 ‚Üí (‚àÄ (f : equiv.perm Œ±) (x y : Œ±), x ‚â† y ‚Üí P f ‚Üí P (f * equiv.swap x y)) ‚Üí P f
{Œ± : Type u_1} [measurable_space Œ±] : has_coe_to_fun (measure_theory.measure Œ±) (Œª (_x : measure_theory.measure Œ±), set Œ± ‚Üí ennreal)
(p : ‚Ñï) (q : ‚Ñö) : ‚Ñ§
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {e : local_homeomorph Œ± Œ≤} {s : set Œ±} {t : set Œ≤} : e.to_local_equiv.source ‚à© ‚áëe ‚Åª¬π' (e.to_local_equiv.target ‚à© t) = e.to_local_equiv.source ‚à© s ‚Üí e.is_image s t
(p : ‚Ñï ‚Üí Prop) [decidable_pred p] (n : ‚Ñï) : ‚Ñï
{Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ±] [preorder Œ±] [topological_space Œ≤] [preorder Œ≤] : has_coe_to_fun (esakia_hom Œ± Œ≤) (Œª (_x : esakia_hom Œ± Œ≤), Œ± ‚Üí Œ≤)
{Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : set Œ±) (t : set Œ≤) : Prop
{Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} [has_coe Œ± Œ≤] [has_coe_t Œ≤ Œ≥] (a : Œ±) : ‚Üëa = ‚Üë‚Üëa
{Œ± : Type u} [pseudo_metric_space Œ±] {x : Œ±} : metric.inf_dist x ‚àÖ = 0
{Œ± : Type u_1} [linear_ordered_ring Œ±] [archimedean Œ±] {x y : Œ±} (hx : 1 ‚â§ x) (hy : 1 < y) : ‚àÉ (n : ‚Ñï), y ^ n ‚â§ x ‚àß x < y ^ (n + 1)
(p : omega.int.preform) : list omega.clause
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [comm_monoid M] {f : Œ± ‚Üí M} {g : Œ≤ ‚Üí Œ±} (hg : set.inj_on g (function.mul_support (f ‚àò g))) : finprod (Œª (i : Œ±), finprod (Œª (H : i ‚àà set.range g), f i)) = finprod (Œª (j : Œ≤), f (g j))
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : module.rank K V < cardinal.aleph_0
{a b c : ‚Ñ§} : fermat_42.minimal a b c ‚Üí fermat_42.minimal b a c
{V : Type u} {G : simple_graph V} (G' : G.subgraph) (s : set (sym2 V)) : G.subgraph
{Œ± : Type u_1} [linear_ordered_field Œ±] (Œ≤ : Type u_2) [ring Œ≤] (abv : Œ≤ ‚Üí Œ±) [is_absolute_value abv] : Prop
(Œ± : Type u) (Œ≤ : Type v) [add_group Œ±] [add_action Œ± Œ≤] : setoid Œ≤
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j j' : C) : j ‚ü∂ category_theory.is_filtered.max j j'
(n : ‚Ñï) (z : ‚ÑÇ) : (complex.cos z + complex.sin z * complex.I) ^ n = complex.cos (‚Üën * z) + complex.sin (‚Üën * z) * complex.I
 : user_attribute unit (option name)
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {f‚ÇÄ f‚ÇÅ f‚ÇÇ : C(X, Y)} {S : set X} (F : f‚ÇÄ.homotopy_rel f‚ÇÅ S) (G : f‚ÇÅ.homotopy_rel f‚ÇÇ S) : f‚ÇÄ.homotopy_rel f‚ÇÇ S
{C : Type u‚ÇÅ} [category_theory.small_category C] {‚Ñ∞ : Type u‚ÇÇ} [category_theory.category ‚Ñ∞] (A : C ‚•§ ‚Ñ∞) (P : C·µí·µñ ‚•§ Type u‚ÇÅ) (E‚ÇÅ E‚ÇÇ : ‚Ñ∞) (g : E‚ÇÅ ‚ü∂ E‚ÇÇ) {c : category_theory.limits.cocone ((category_theory.category_of_elements.œÄ P).left_op ‚ãô A)} (t : category_theory.limits.is_colimit c) (k : c.X ‚ü∂ E‚ÇÅ) : ‚áë(category_theory.colimit_adj.restrict_yoneda_hom_equiv A P E‚ÇÇ t) (k ‚â´ g) = ‚áë(category_theory.colimit_adj.restrict_yoneda_hom_equiv A P E‚ÇÅ t) k ‚â´ (category_theory.colimit_adj.restricted_yoneda A).map g
{R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {T : submonoid P} (Q : Type u_4) [comm_semiring Q] [algebra P Q] [is_localization T Q] (g : R ‚Üí+* P) (hy : M ‚â§ submonoid.comap ‚Üëg T) : S ‚Üí+* Q
 : CommMon_Type_equivalence_CommMon.functor ‚ãô category_theory.forget‚ÇÇ CommMon Mon ‚âÖ CommMon_.forget‚ÇÇ_Mon_ (Type u) ‚ãô Mon_Type_equivalence_Mon.functor
{Œ± : Type u_1} {Œ≤ : Type u_2} : (Œ± ‚Üí. Œ≤) ‚âÉ Œ£ (p : Œ± ‚Üí Prop), subtype p ‚Üí Œ≤
{L : first_order.language} {M : Type u_3} {N : Type u_4} {P : Type u_5} {Q : Type u_6} [L.Structure M] [L.Structure N] [L.Structure P] [L.Structure Q] (f : L.elementary_embedding M N) (g : L.elementary_embedding N P) (h : L.elementary_embedding P Q) : (h.comp g).comp f = h.comp (g.comp f)
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] [category_theory.monoidal_category C] : category_theory.lax_monoidal_functor (J ‚•§ C) C
(Œ± : Type u_1) : galois_insertion topological_space.generate_from (Œª (t : topological_space Œ±), {s : set Œ± | t.is_open s})
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p p' : submodule R M) (h : p = p') : (M ‚ß∏ p) ‚âÉ‚Çó[R] M ‚ß∏ p'
{M : Type u_2} [add_comm_group M] {A : Type u_1} [comm_ring A] [module A M] (f : M ‚Üí‚Çó[A] M) (hf : is_unit f) : is_unit (‚áëlinear_map.det f)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : (affine_span k s).direction = vector_span k s
{Œ± : Type u} [partial_order Œ±] [order_top Œ±] {a : Œ±} : is_max a ‚Üí a = ‚ä§
 : topological_space ennreal
(n : pos_num) : ‚Ñï ‚Üí pos_num ‚Üí pos_num
(Œ± : Type u_1) (Œ≤ : Type u_2) [topological_space Œ±] [topological_space Œ≤] : Type (max u_1 u_2)
{Œ± : Type u_1} [pseudo_emetric_space Œ±] {f : ‚Ñï ‚Üí Œ±} (d : ‚Ñï ‚Üí ennreal) (hf : ‚àÄ (n : ‚Ñï), has_edist.edist (f n) (f n.succ) ‚â§ d n) {a : Œ±} (ha : filter.tendsto f filter.at_top (nhds a)) : has_edist.edist (f 0) a ‚â§ ‚àë' (m : ‚Ñï), d m
{Œ± : Type u_1} [lattice Œ±] [bounded_order Œ±] [is_modular_lattice Œ±] {a b : Œ±} (h : is_compl a b) : ‚Ü•(set.Iic a) ‚âÉo ‚Ü•(set.Ici b)
{p : ‚Ñï} {G : Type u_1} [group G] [fact (nat.prime p)] [fintype (sylow p G)] (P : sylow p G) : sylow p G ‚âÉ G ‚ß∏ ‚ÜëP.normalizer
{Œ± : Type u_1} (E : Œ± ‚Üí Type u_2) [Œ† (i : Œ±), normed_group (E i)] (p : ennreal) : add_subgroup (pre_lp E)
{T : Type u‚ÇÅ} [category_theory.category T] {X : T} {f g : category_theory.over X} (hl : f.left ‚âÖ g.left) (hw : hl.hom ‚â´ g.hom = f.hom . "obviously") : f ‚âÖ g
(M : Type u_5) (N : Type u_6) [has_add M] [has_add N] : add_hom (M √ó N) M
{Œ≤ : Type u_1} [add_comm_group Œ≤] {b : Œ≤} {V : Type u_2} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (X : category_theory.differential_object (category_theory.graded_object_with_shift b V)) {i j : Œ≤} (h : i = j) : X.X i ‚ü∂ X.X j
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} (h : ‚àÄ {Œπ : Type u} (U : Œπ ‚Üí set Œ±), (‚àÄ (i : Œπ), is_open (U i)) ‚Üí (s ‚äÜ ‚ãÉ (i : Œπ), U i) ‚Üí (‚àÉ (t : finset Œπ), s ‚äÜ ‚ãÉ (i : Œπ) (H : i ‚àà t), U i)) : is_compact s
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] (F : category_theory.oplax_functor B C) (a b : B) : (a ‚ü∂ b) ‚•§ (F.obj a ‚ü∂ F.obj b)
{V : Type u} (r : V ‚Üí V ‚Üí Prop) : simple_graph V
{C : Type u‚ÇÅ} [category_theory.category C] {M N : category_theory.monad C} (f : ‚ÜëM ‚âÖ ‚ÜëN) (f_Œ∑ : ‚àÄ (X : C), M.Œ∑.app X ‚â´ f.hom.app X = N.Œ∑.app X) (f_Œº : ‚àÄ (X : C), M.Œº.app X ‚â´ f.hom.app X = (‚ÜëM.map (f.hom.app X) ‚â´ f.hom.app (‚ÜëN.obj X)) ‚â´ N.Œº.app X) : M ‚âÖ N
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ‚àà S ‚Üí y ‚àà S ‚Üí x - y ‚àà S
(F : Type u_1) (E : Type u_2) (K : Type u_3) [field F] [field E] [field K] [algebra F E] [algebra F K] : Type (max u_2 u_3)
{Œ± : Type} (e : environment) (f : declaration ‚Üí Œ±) : list Œ±
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] [complete_space E] {f : ‚Ñù ‚Üí E} {T : ‚Ñù} (hf : function.periodic f T) (hT : 0 < T) (t s : ‚Ñù) : ‚à´ (x : ‚Ñù) in t..t + T, f x = ‚à´ (x : ‚Ñù) in s..s + T, f x
{Œ± : Type u} [has_mul Œ±] {Œ≤ : Type v} [has_mul Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) : magma.free_semigroup Œ± ‚Üí magma.free_semigroup Œ≤
{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} (hx : x ‚àà H) (hy : y ‚àà H) : x - y ‚àà H
(e : expr) : smt_tactic expr
(k : Type u) [field k] : ideal (mv_polynomial (algebraic_closure.monic_irreducible k) k)
{u : ‚Ñï ‚Üí ‚Ñù} (h : subadditive u) (hbdd : bdd_below (set.range (Œª (n : ‚Ñï), u n / ‚Üën))) : filter.tendsto (Œª (n : ‚Ñï), u n / ‚Üën) filter.at_top (nhds h.lim)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.abelian C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [category_theory.mono f] (h : category_theory.exact f g) : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ f _)
{R‚ÇÅ : Type u_2} {R‚ÇÇ : Type u_3} {R‚ÇÉ : Type u_4} {M‚ÇÅ : Type u_8} {M‚ÇÇ : Type u_9} {M‚ÇÉ : Type u_10} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [semiring R‚ÇÉ] [add_comm_monoid M‚ÇÅ] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] {module_M‚ÇÅ : module R‚ÇÅ M‚ÇÅ} {module_M‚ÇÇ : module R‚ÇÇ M‚ÇÇ} {module_M‚ÇÉ : module R‚ÇÉ M‚ÇÉ} {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : R‚ÇÅ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} {œÉ‚ÇÉ‚ÇÇ : R‚ÇÉ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÉ‚ÇÅ : R‚ÇÉ ‚Üí+* R‚ÇÅ} [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] [ring_hom_comp_triple œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÉ‚ÇÅ] {re‚ÇÅ‚ÇÇ : ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ} {re‚ÇÇ‚ÇÉ : ring_hom_inv_pair œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÉ‚ÇÇ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÉ œÉ‚ÇÉ‚ÇÅ] {re‚ÇÇ‚ÇÅ : ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ} {re‚ÇÉ‚ÇÇ : ring_hom_inv_pair œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÇ‚ÇÉ} [ring_hom_inv_pair œÉ‚ÇÉ‚ÇÅ œÉ‚ÇÅ‚ÇÉ] (e‚ÇÅ‚ÇÇ : M‚ÇÅ ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (e‚ÇÇ‚ÇÉ : M‚ÇÇ ‚âÉ‚Çõ‚Çó[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) : M‚ÇÅ ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ
{Œ± : Type} (add_msg : string) (tac : tactic Œ±) : tactic Œ±
{Œ± : Type u_1} {M : Type u_5} {N : Type u_6} [add_comm_monoid M] [add_comm_monoid N] {s : set Œ±} {f : Œ± ‚Üí M} (g : M ‚Üí+ N) (h‚ÇÄ : (s ‚à© function.support f).finite) : ‚áëg (finsum (Œª (j : Œ±), finsum (Œª (H : j ‚àà s), f j))) = finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), ‚áëg (f i)))
{R : Type u_1} [comm_semiring R] {X : Type u_2} : star_ring (free_algebra R X)
(R : Type u) [add_monoid R] : Type u
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) : real.angle
{R : Type u} [ring R] {J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Module R) : (Œ£ (j : J), ‚Ü•(F.obj j)) ‚Üí ‚Ü•(Module.filtered_colimits.M F)
{Œ≥ : Type w} [preorder Œ≥] [order_bot Œ≥] (s : set Œ≥) : bdd_below s
{Œ± : Type u} [pseudo_metric_space Œ±] {s t u : set Œ±} (fin : emetric.Hausdorff_edist s t ‚â† ‚ä§) : metric.Hausdorff_dist s u ‚â§ metric.Hausdorff_dist s t + metric.Hausdorff_dist t u
(Œ± : expr) : tactic tactic.instance_cache
{Œ± : Type u_1} (l : ordnode Œ±) (x : Œ±) (m : ordnode Œ±) (y : Œ±) (r : ordnode Œ±) : ordnode Œ±
{Œ±' : Type u_1} {Œ≤' : Type u_2} (e : Œ±' ‚âÉ Œ≤') : equiv.perm Œ±' ‚âÉ equiv.perm Œ≤'
{L : first_order.language} {Œ± : Type u'} {n : ‚Ñï} : L.bounded_formula Œ± n ‚Üí L.formula Œ±
(k : Type u_1) [linear_ordered_field k] : k ‚âÉo ‚Ü•(set.Ioo (-1) 1)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C·µí·µñ} (f : X ‚ü∂ Y) (m : category_theory.normal_mono f.unop) : category_theory.normal_epi f
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} : category_theory.subobject X ‚•§ category_theory.mono_over X
(ùïú : Type u_1) {E : Type u_3} [semi_normed_ring ùïú] [has_scalar ùïú E] (A B : set E) : Prop
(R : Type w) [semiring R] (C : Type u) [category_theory.category C] [category_theory.preadditive C] : Type (max u v w)
{R‚ÇÅ : Type u_3} {A : Type u_5} {B : Type u_6} [comm_semiring R‚ÇÅ] [comm_ring A] [comm_ring B] [algebra R‚ÇÅ A] [algebra R‚ÇÅ B] {f : A ‚Üí‚Çê[R‚ÇÅ] B} (hf : function.surjective ‚áëf) : (A ‚ß∏ f.to_ring_hom.ker) ‚âÉ‚Çê[R‚ÇÅ] B
{Œ± : Type u_2} [decidable_eq Œ±] {B : finset (finset Œ±)} {n : ‚Ñï} [fintype Œ±] (h : ‚àÄ (a : Œ±), n ‚â§ (finset.filter (has_mem.mem a) B).card) : fintype.card Œ± * n ‚â§ B.sum (Œª (s : finset Œ±), s.card)
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {x y z : V} (hx : x ‚â† 0) (hy : y ‚â† 0) (hz : z ‚â† 0) : o.oangle y z + o.oangle x y = o.oangle x z
 : ‚Ñï
{R : Type u} [non_unital_semiring R] [star_ring R] : R ‚âÉ+* R·µê·µí·µñ
{X Y : CompHaus} (f : X ‚ü∂ Y) (bij : function.bijective ‚áëf) : X ‚âÖ Y
(n : ‚Ñï) : fin n ‚Ü™o fin (n + 1)
{T : ‚Ñù} {g : ‚Ñù ‚Üí ‚Ñù} (hg : function.periodic g T) (h_int : ‚àÄ (t‚ÇÅ t‚ÇÇ : ‚Ñù), interval_integrable g measure_theory.measure_space.volume t‚ÇÅ t‚ÇÇ) (h‚ÇÄ : ‚àÄ (x : ‚Ñù), 0 < g x) (hT : 0 < T) : filter.tendsto (Œª (t : ‚Ñù), ‚à´ (x : ‚Ñù) in 0..t, g x) filter.at_top filter.at_top
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {B : Type u‚ÇÑ} [category_theory.category B] (S : C) (F : B ‚•§ C) (G : C ‚•§ D) : category_theory.structured_arrow S F ‚•§ category_theory.structured_arrow (G.obj S) (F ‚ãô G)
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] (n : ‚Ñï) (hn : module.rank K V = ‚Üën) : V ‚âÉ‚Çó[K] fin n ‚Üí K
(n : name) : bool
{C : Type u} {D : Type u'} [category_theory.category D] [category_theory.monoidal_category D] (f : C ‚Üí D) (X Y : category_theory.free_monoidal_category C) : (X ‚ü∂ Y) ‚Üí (category_theory.free_monoidal_category.project_obj f X ‚ü∂ category_theory.free_monoidal_category.project_obj f Y)
(R : Type u_3) [comm_semiring R] {R‚ÇÇ : Type u_4} [comm_semiring R‚ÇÇ] {R‚ÇÉ : Type u_5} [comm_semiring R‚ÇÉ] (M : Type u_7) (N : Type u_8) (P : Type u_9) [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R‚ÇÇ N] [module R‚ÇÉ P] {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : R ‚Üí+* R‚ÇÉ} : (M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÉ] N ‚Üí‚Çõ‚Çó[œÉ‚ÇÇ‚ÇÉ] P) ‚Üí‚Çó[R‚ÇÉ] N ‚Üí‚Çõ‚Çó[œÉ‚ÇÇ‚ÇÉ] M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÉ] P
(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] (x : M) : ideal R
{p : Prop} {Œ± : Type u_1} {Œ≤ : Type u_2} [has_repr Œ±] (tracing_enabled : bool) (var : string) (val : Œ±) : slim_check.test_result p ‚Üí thunk Œ≤ ‚Üí Œ≤
{Œ± Œ≤ Œ≥ : Type} (l : list Œ±) (p : Œ± ‚Üí Œ≤ √ó Œ≥) [decidable_eq Œ≤] : list (Œ≤ √ó list Œ≥)
{R : Type u} [ring R] {X Y : Type u} [add_comm_group X] [add_comm_group Y] [module R X] [module R Y] : (X ‚âÉ‚Çó[R] Y) ‚âÖ Module.of R X ‚âÖ Module.of R Y
{Œ± : Type u} (s : finset Œ±) : ‚Üës.finite
(M : Type u) : Type u
{M : Type u_3} {N : Type u_4} [monoid M] [monoid N] {F : Type u_1} [monoid_hom_class F M N·µê·µí·µñ] (f : F) (l : list M) : mul_opposite.unop (‚áëf l.prod) = (list.map (mul_opposite.unop ‚àò ‚áëf) l).reverse.prod
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : category_theory.monoidal_category.tensor_unit_left C ‚âÖ ùü≠ C
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q R S : C} {f : P ‚ü∂ Q} {g : P ‚ü∂ R} {h : Q ‚ü∂ S} {k : R ‚ü∂ S} [hn : category_theory.normal_mono h] (comm : f ‚â´ h = g ‚â´ k) (t : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk f g comm)) : category_theory.normal_mono g
{m : Type v ‚Üí Type w} [applicative m] {Œ± : Type u_1} {Œ≤ : Type v} (f : ‚Ñï ‚Üí Œ± ‚Üí m Œ≤) : ‚Ñï ‚Üí list Œ± ‚Üí m (list Œ≤)
 : Type
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] (F : J ‚•§ algebraic_geometry.PresheafedSpace C) (U : topological_space.opens ‚Ü•((category_theory.limits.colimit F).carrier)) : (category_theory.limits.colimit F).presheaf.obj (opposite.op U) ‚âÖ category_theory.limits.limit (algebraic_geometry.PresheafedSpace.componentwise_diagram F U)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {X : C} (h : category_theory.coyoneda.obj (opposite.op X) ‚ãô category_theory.ulift_functor ‚âÖ F.cocones) {Y : C} (f : X ‚ü∂ Y) : category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom h f = (category_theory.limits.is_colimit.of_nat_iso.colimit_cocone h).extend f
{M : Type u_2} (R : Type u_5) [semiring R] [add_comm_monoid M] [module R M] (s : set M) : submodule.span R s = (finsupp.total ‚Ü•s M R coe).range
{R : Type u} {S : Type v} [comm_semiring R] [local_ring R] [comm_semiring S] [local_ring S] (f : R ‚Üí+* S) [is_local_ring_hom f] (a : R) (h : a ‚àà local_ring.maximal_ideal R) : ‚áëf a ‚àà local_ring.maximal_ideal S
(Œ± : Type u_5) (Œ≤ : out_param (Type u_6)) (Œ≥ : out_param (Type u_7)) : Type (max u_5 u_6 u_7)
(Œ± : Type u_1) [topological_space Œ±] : filter Œ±
(h : expr) (hs : expr_set) : tactic bool
{M‚ÇÄ : Type u_1} [mul_zero_one_class M‚ÇÄ] : 0 = 1 ‚Üí subsingleton M‚ÇÄ
 : ‚Ñù ‚âÉ cau_seq.completion.Cauchy
{Œ± : Type u} (f : filter Œ±) (h : ‚àÄ (s : set Œ±), s·∂ú ‚àâ f ‚Üî s ‚àà f) : ultrafilter Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} {l : filter Œ±} {lc : filter Œ≥} (F : (Œ± ‚Üí Œ≤) ‚Üí Œ≥ ‚Üí Œ¥) (hF : (l.eventually_eq ‚áí lc.eventually_eq) F F) : l.germ Œ≤ ‚Üí lc.germ Œ¥
{Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] (h : Œ± ‚âÉ·µê Œ≤) : Œ± ‚Üí Œ≤
{X : Type u_1} {Y : Type u_2} [topological_space X] [mul_one_class Y] : Y ‚Üí* locally_constant X Y
{Œ± : Type u} (L : list Œ±) {i j : ‚Ñï} (h : i + j < L.length) : L.nth_le (i + j) h = (list.drop i L).nth_le j _
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J ‚Üí C) [category_theory.limits.has_biproduct F] : category_theory.limits.is_colimit (category_theory.limits.biproduct.bicone F).to_cocone
{Œ± : Type u} : wseq Œ± ‚Üí wseq Œ± ‚Üí Prop
 : Type
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {n : with_top ‚Ñï} {s : set (E √ó F)} {p : E √ó F} : cont_diff_within_at ùïú n prod.fst s p
(k : Type u‚ÇÅ) (G : Type u‚ÇÇ) [semiring k] [has_mul G] : monoid_algebra k G ‚âÉ+* add_monoid_algebra k (additive G)
(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop
{Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) (x : B) : Type u_3
(C : Type u‚ÇÅ) [category_theory.category C] : C ‚•§ C·µí·µñ·µí·µñ
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j‚ÇÅ j‚ÇÇ j‚ÇÉ : C) : j‚ÇÅ ‚ü∂ category_theory.is_filtered.max‚ÇÉ j‚ÇÅ j‚ÇÇ j‚ÇÉ
{G : Type u_3} [group G] : group.fg G ‚Üî ‚àÉ (S : set G), subgroup.closure S = ‚ä§ ‚àß S.finite
{Œ± : Sort u‚ÇÅ} {Œ≤ : Sort u‚ÇÇ} (g : Œ≤ ‚Üí Œ±) (f : Œ± ‚Üí Œ≤) : Prop
{Œ± : Type u_1} [has_le Œ±] (s : set Œ±) : Prop
{Œ± : Type u} [has_mul Œ±] : ulift Œ± ‚âÉ* Œ±
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {x : E} : differentiable_at ùïú f x ‚Üí mdifferentiable_at (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f x
{Œ± : Type u} {Œ≤ : Type v} [add_zero_class Œ±] [mul_one_class Œ≤] : (Œ± ‚Üí+ additive Œ≤) ‚âÉ (multiplicative Œ± ‚Üí* Œ≤)
{M : Type u_1} [ordered_cancel_comm_monoid M] {A : Type u_2} [set_like A M] [submonoid_class A M] (S : A) : ordered_cancel_comm_monoid ‚Ü•S
(R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] (x : M) : submodule.span R {x} = (linear_map.to_span_singleton R M x).range
{H : Type u} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] (s : topological_space.opens M) : charted_space H ‚Ü•s
(G : Type u) (F : Type v) [group G] [field F] [fintype G] [mul_semiring_action G F] [has_faithful_smul G F] : G ‚âÉ (F ‚Üí‚Çê[‚Ü•(fixed_points.subfield G F)] F)
 : lean.parser (bool √ó list name)
{K : Type u_1} {Œ≤ : Type u_2} (f : K ‚Üí Œ≤) (gp : generalized_continued_fraction.int_fract_pair K) : generalized_continued_fraction.int_fract_pair Œ≤
{m n : ‚Ñï} : even (m ^ n) ‚Üî even m ‚àß n ‚â† 0
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.has_split_coequalizer f g] : category_theory.is_split_coequalizer f g (category_theory.has_split_coequalizer.coequalizer_œÄ f g)
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] (f : linear_pmap R E F) (p : submodule R F) (H : ‚àÄ (x : ‚Ü•(f.domain)), ‚áëf x ‚àà p) : linear_pmap R E ‚Ü•p
{F : Type u_3} [inner_product_space ‚Ñù F] [finite_dimensional ‚Ñù F] : subgroup.closure (set.range (Œª (v : F), reflection (submodule.span ‚Ñù {v})·óÆ)) = ‚ä§
{Œ± : Type u_1} (s : multiset Œ±) : (‚àÉ (x : Œ±), x ‚àà s) ‚Üí trunc Œ±
{Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≥ : Type u_5} [has_inf Œ±] [has_top Œ±] [has_inf Œ≤] [has_top Œ≤] [has_inf Œ≥] [has_top Œ≥] (f : inf_top_hom Œ≤ Œ≥) (g : inf_top_hom Œ± Œ≤) : inf_top_hom Œ± Œ≥
{R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ‚â† 2) : -1 ‚â† 1
{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] : associates.factor_set Œ± ‚Üí associates Œ±
{E : Type u_1} [add_comm_group E] [star_add_monoid E] [module ‚ÑÇ E] [star_module ‚ÑÇ E] (x : E) : ‚Üë(‚áëstar_module.re x) + complex.I ‚Ä¢ ‚Üë(‚áëstar_module.im x) = x
(C : Type u) [category_theory.category C] [category_theory.essentially_small C] : C ‚âå category_theory.small_model C
(R : CommRing) : R ‚ü∂ algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (opposite.op R)))
{Œ± : Type u} [group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_mul.mul has_le.le] {a : Œ±} : a‚Åª¬π ‚â§ 1 ‚Üî 1 ‚â§ a
{G : Type u_1} [add_group G] {S : Type u_4} (H : S) [set_like S G] [hSG : add_subgroup_class S G] : add_group ‚Ü•H
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] (C : cochain_complex V ‚Ñï) (X : V) (f : (cochain_complex.single‚ÇÄ V).obj X ‚ü∂ C) : cochain_complex V ‚Ñï
{Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] {f g : Œπ ‚Üí Œ±} (B : bdd_below (set.range f)) (H : ‚àÄ (x : Œπ), f x ‚â§ g x) : infi f ‚â§ infi g
{Œ± : Type u_2} {Œ≤ : Type u_3} [has_Sup Œ±] [has_Sup Œ≤] : Sup_hom Œ± Œ≤ ‚âÉ Inf_hom Œ±·µí·µà Œ≤·µí·µà
{Œ± : Type u_2} [decidable_eq Œ±] {B : finset (finset Œ±)} {n : ‚Ñï} [fintype Œ±] (h : ‚àÄ (a : Œ±), (finset.filter (has_mem.mem a) B).card = n) : B.sum (Œª (s : finset Œ±), s.card) = fintype.card Œ± * n
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [nondiscrete_normed_field R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [normed_group F] [normed_space R F] [topological_space B] (a : topological_vector_prebundle R F E) : topological_fiber_prebundle F bundle.total_space.proj
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {e e' : local_equiv Œ± Œ≤} {f f' : local_equiv Œ≤ Œ≥} (he : e ‚âà e') (hf : f ‚âà f') : e.trans f ‚âà e'.trans f'
{Œ± : Type u_1} [canonically_ordered_add_monoid Œ±] [has_sub Œ±] [has_ordered_sub Œ±] {a b c : Œ±} [contravariant_class Œ± Œ± has_add.add has_le.le] (h : c ‚â§ b) : a < b - c ‚Üî c + a < b
{Œ± : Type u_1} [add_group Œ±] {s t : add_subgroup Œ±} (h_le : s ‚â§ t) (f : Œ± ‚ß∏ t ‚Üí Œ±) (hf : function.right_inverse f quotient_add_group.mk) : Œ± ‚ß∏ s ‚âÉ (Œ± ‚ß∏ t) √ó ‚Ü•t ‚ß∏ s.add_subgroup_of t
{Œ± : Type u} [topological_space Œ±] [t1_space Œ±] [‚àÄ (x : Œ±), (nhds_within x {x}·∂ú).ne_bot] {s : set Œ±} (hs : dense s) {t : set Œ±} (ht : t.finite) : dense (s  t)
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} [topological_space Œ±] (hx : x ‚àà s) (L : ‚àÄ (u : set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí (‚àÉ (t : set Œ±) (H : t ‚àà nhds_within x s) (F : Œ± ‚Üí Œ≤), continuous_within_at F s x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u)) : continuous_within_at f s x
{Œ± : Type u_2} [has_add Œ±] (a : Œ±) : Prop
{Œ± : Type u_1} [preorder Œ±] (t : ordnode Œ±) : Prop
(p : set pSet) : pSet ‚Üí pSet
(ns : list name) : tactic (list expr)
 : tactic unit
{C : Type u} [category_theory.category C] {R X Y Z : C} {a b : R ‚ü∂ X} {f‚ÇÅ : X ‚ü∂ Y} {f‚ÇÇ : Y ‚ü∂ Z} [category_theory.mono f‚ÇÇ] (big_k : category_theory.is_kernel_pair (f‚ÇÅ ‚â´ f‚ÇÇ) a b) : category_theory.is_kernel_pair f‚ÇÅ a b
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} {s : finset Œπ} {w : Œπ ‚Üí k} (h : s.sum (Œª (i : Œπ), w i) = 0) (p : Œπ ‚Üí P) : ‚áë(s.weighted_vsub p) w ‚àà vector_span k (set.range p)
{ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [ordered_semiring ùïú] [add_comm_monoid E] [ordered_add_comm_group Œ≤] [has_scalar ùïú E] [module ùïú Œ≤] {s : set E} {f : E ‚Üí Œ≤} : strict_concave_on ùïú s (-f) ‚Üî strict_convex_on ùïú s f
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ‚Ñù E] {f : ‚Ñù ‚Üí E} {ca cb : E} {a b : ‚Ñù} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a ‚äì measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (nhds b ‚äì measure_theory.measure_space.volume.ae) (nhds cb)) : fderiv ‚Ñù (Œª (p : ‚Ñù √ó ‚Ñù), ‚à´ (x : ‚Ñù) in p.fst..p.snd, f x) (a, b) = (continuous_linear_map.snd ‚Ñù ‚Ñù ‚Ñù).smul_right cb - (continuous_linear_map.fst ‚Ñù ‚Ñù ‚Ñù).smul_right ca
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} (S R : category_theory.sieve X) : category_theory.sieve X
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] (p : polynomial A) : tensor_product R A (polynomial R)
{Œ± : Type u} (t : tactic Œ±) : tactic (Œ± ‚äï string)
(C : Type u) : Type (u+1)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ‚ü∂ Y) [category_theory.limits.has_zero_object C] [category_theory.limits.has_cokernel f] [category_theory.epi f] : category_theory.limits.cokernel f ‚âÖ 0
 : Top·µí·µñ ‚•§ Frame
{Œ± : Type u_1} [has_le Œ±] [bounded_order Œ±] [is_simple_order Œ±] : preorder Œ±
{Œ± : Type u} {a b : Œ±} [mul_zero_class Œ±] [preorder Œ±] [zero_lt.mul_pos_strict_mono Œ±] (ha : 0 < a) (hb : 0 < b) : 0 < a * b
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) [category_theory.full F] [category_theory.faithful F] (X : C) : galois_coinsertion (category_theory.sieve.functor_pushforward F) (category_theory.sieve.functor_pullback F)
 : tactic ‚Ñï
{k : Type u_1} {P‚ÇÅ : Type u_2} {P‚ÇÇ : Type u_3} {V‚ÇÅ : Type u_6} {V‚ÇÇ : Type u_7} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] (e : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ
 : list expr ‚Üí tactic unit
{Œ± : Type u_1} {Œ≤ : Type u_2} [fintype Œ±] [decidable_eq Œ≤] (f : Œ± ‚Ü™ Œ≤) (b : ‚Ü•(set.range ‚áëf)) : Œ±
{Œ± : Type u_1} [add_zero_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b : Œ±} (ha : a ‚â§ 0) (hb : b < 0) : a + b < 0
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] (a : Œ±) : has_Sup.Sup {a} = a
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] [fintype Œ±] [fintype Œ≤] (f : Œ± ‚Üí Œ≤) {w : Œ± ‚Üí M} {b : M} [linear_ordered_cancel_add_comm_monoid M] [nonempty Œ≤] (hb : finset.univ.sum (Œª (x : Œ±), w x) ‚â§ fintype.card Œ≤ ‚Ä¢ b) : ‚àÉ (y : Œ≤), (finset.filter (Œª (x : Œ±), f x = y) finset.univ).sum (Œª (x : Œ±), w x) ‚â§ b
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (f : M ‚Üí* P) : (con.ker f).quotient ‚Üí* P
 : Type
(G : Type u) [group G] : Type u
{V : Type u} {G : simple_graph V} (G' : G.subgraph) : simple_graph V
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [no_max_order Œ±] [densely_ordered Œ±] {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (set.Ici a) ‚Üî ‚àÉ (u : Œ±), a < u ‚àß set.Icc a u ‚äÜ s
{ùïú : Type u_1} {F : Type u_3} [is_R_or_C ùïú] [add_comm_group F] [module ùïú F] [c : inner_product_space.core ùïú F] (x y : F) : is_R_or_C.abs (has_inner.inner x y) * is_R_or_C.abs (has_inner.inner y x) ‚â§ ‚áëis_R_or_C.re (has_inner.inner x x) * ‚áëis_R_or_C.re (has_inner.inner y y)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} (e‚ÇÅ : Œ± ‚Ü™ Œ≤) (e‚ÇÇ : Œ≥ ‚Ü™ Œ¥) : Œ± ‚äï Œ≥ ‚Ü™ Œ≤ ‚äï Œ¥
{Œ± : Type u_1} [linear_order Œ±] [pred_order Œ±] [is_pred_archimedean Œ±] (r : Œ± ‚Üí Œ± ‚Üí Prop) {n m : Œ±} (hr : reflexive r) (h1 : ‚àÄ (i : Œ±), i ‚àà set.Ioc m n ‚Üí r i (order.pred i)) (h2 : ‚àÄ (i : Œ±), i ‚àà set.Ioc n m ‚Üí r (order.pred i) i) : relation.trans_gen r n m
{Œ± : Type u_2} [has_neg Œ±] : has_neg (filter Œ±)
{R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) : A.det = A inhabited.default inhabited.default
 : ‚Ñù* ‚Üí ‚Ñù
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} (h‚ÇÄ : f = g) {c : category_theory.limits.cofork f g} (h : category_theory.limits.is_colimit c) : category_theory.is_iso c.œÄ
{M : Type u_1} [mul_one_class M] : has_bot (submonoid M)
{x : ‚Ñù} (hx : 0 ‚â§ x) : x + 1 ‚â§ real.exp x
(X : Type u_5) [t : topological_space X] : Prop
(env : environment) (n : name) : environment
(p : ‚Ñï) [hp : fact (nat.prime p)] {q r : ‚Ñö} (hne : padic_norm p q ‚â† padic_norm p r) : padic_norm p (q + r) = linear_order.max (padic_norm p q) (padic_norm p r)
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Prop
{K : Type u} [hring : comm_ring K] : ratfunc K ‚Üí ratfunc K ‚Üí ratfunc K
{G‚ÇÄ : Type u_2} {G‚ÇÄ' : Type u_4} [group_with_zero G‚ÇÄ] [has_zero G‚ÇÄ'] [has_mul G‚ÇÄ'] [has_one G‚ÇÄ'] [has_inv G‚ÇÄ'] [has_div G‚ÇÄ'] [has_pow G‚ÇÄ' ‚Ñï] [has_pow G‚ÇÄ' ‚Ñ§] (h01 : 0 ‚â† 1) (f : G‚ÇÄ ‚Üí G‚ÇÄ') (hf : function.surjective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ‚àÄ (x y : G‚ÇÄ), f (x * y) = f x * f y) (inv : ‚àÄ (x : G‚ÇÄ), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : G‚ÇÄ), f (x / y) = f x / f y) (npow : ‚àÄ (x : G‚ÇÄ) (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : G‚ÇÄ) (n : ‚Ñ§), f (x ^ n) = f x ^ n) : group_with_zero G‚ÇÄ'
 : fib_rec.is_solution (has_pow.pow golden_conj)
(m M N : ‚Ñï) (i : Œ£ (n : ‚Ñï), fin n ‚Üí ‚Ñï) (hi : i ‚àà formal_multilinear_series.comp_partial_sum_source m M N) : Œ£ (n : ‚Ñï), composition n
{a b : simplex_category} (f : a.hom b) : fin (a.len + 1) ‚Üío fin (b.len + 1)
{Œ± : Type u} [has_mul Œ±] [has_one Œ±] (a : Œ±) : Type u
{G : Type u_1} [group G] (H : ‚Ñï ‚Üí subgroup G) (hH : is_ascending_central_series H) (n : ‚Ñï) : H n ‚â§ upper_central_series G n
{G : Type w} [topological_space G] [add_group G] [topological_add_group G] {M : Type u_1} {hom : Type u_2} [add_zero_class M] [topological_space M] [has_continuous_add M] [add_monoid_hom_class hom G M] (f : hom) (hf : continuous_at ‚áëf 0) : continuous ‚áëf
{d : ‚Ñ§} (z : ‚Ñ§‚àöd) : ‚Ñ§‚àöd
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [locally_compact_space Œ±] [t2_space Œ±] [t2_space Œ≤] {Œπ : Type u_3} {l : filter Œπ} [l.ne_bot] (F : Œπ ‚Üí C(Œ±, Œ≤)) : (‚àÉ (f : C(Œ±, Œ≤)), filter.tendsto F l (nhds f)) ‚Üî ‚àÄ (s : set Œ±), is_compact s ‚Üí (‚àÉ (f : C(‚Ü•s, Œ≤)), filter.tendsto (Œª (i : Œπ), continuous_map.restrict s (F i)) l (nhds f))
{Œ± : Type u_1} [preorder Œ±] [order_bot Œ±] [locally_finite_order Œ±] (b : Œ±) : multiset Œ±
{M : Type u_1} [add_zero_class M] : ‚Ü•‚ä§ ‚âÉ+ M
{R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] [is_localization M S] : ‚Ü•M ‚Üí* ‚Ü•(is_localization.inv_submonoid M S)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {s : set E} (hscomp : is_compact s) (hAconv : convex ‚Ñù s) : closure (‚áë(convex_hull ‚Ñù) (set.extreme_points ‚Ñù s)) = s
(Œ± : Type u_1) : Type u_1
{Œ± : Type u_1} {Œ≤ : Type u_2} : list Œ± ‚Üí list Œ≤ ‚Üí list (option Œ± √ó Œ≤) √ó list Œ±
 : Type
{Œ± : Type u} {Œ≤ : Type v} [linear_ordered_field Œ±] [topological_space Œ±] [order_topology Œ±] {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±} {C : Œ±} (hC : 0 < C) (hf : filter.tendsto f l filter.at_top) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (Œª (x : Œ≤), f x * g x) l filter.at_top
{Œ± : Type u} {Œ≤ : Type v} (f‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤) (s : set Œ±) : Prop
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (P : C ‚Üí Prop) [category_theory.monoidal_category.monoidal_predicate P] [category_theory.braided_category C] : category_theory.braided_functor {X // P X} C
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (S‚ÇÅ S‚ÇÇ : submodule K V) [finite_dimensional K ‚Ü•S‚ÇÅ] : finite_dimensional K ‚Ü•(S‚ÇÅ ‚äì S‚ÇÇ)
{X : Type u} [topological_space X] {x‚ÇÄ x‚ÇÅ : X} (p : path x‚ÇÄ x‚ÇÅ) : p.homotopy p
{R : Type u} [comm_semiring R] {A : Type v‚ÇÅ} [semiring A] [algebra R A] {B : Type v‚ÇÇ} [semiring B] [algebra R B] {C : Type v‚ÇÉ} [semiring C] [algebra R C] (f : tensor_product R A B ‚âÉ‚Çó[R] C) (w‚ÇÅ : ‚àÄ (a‚ÇÅ a‚ÇÇ : A) (b‚ÇÅ b‚ÇÇ : B), ‚áëf ((a‚ÇÅ * a‚ÇÇ) ‚äó‚Çú[R] (b‚ÇÅ * b‚ÇÇ)) = ‚áëf (a‚ÇÅ ‚äó‚Çú[R] b‚ÇÅ) * ‚áëf (a‚ÇÇ ‚äó‚Çú[R] b‚ÇÇ)) (w‚ÇÇ : ‚àÄ (r : R), ‚áëf (‚áë(algebra_map R A) r ‚äó‚Çú[R] 1) = ‚áë(algebra_map R C) r) : tensor_product R A B ‚âÉ‚Çê[R] C
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) : hb.conj_lie.symm = hb.conj_lie
{Œπ : Type u} {f g : Œπ ‚Üí ‚Ñù} {p q : ‚Ñù} (hpq : p.is_conjugate_exponent q) {A B : ‚Ñù} (hA : 0 ‚â§ A) (hB : 0 ‚â§ B) (hf : ‚àÄ (i : Œπ), 0 ‚â§ f i) (hg : ‚àÄ (i : Œπ), 0 ‚â§ g i) (hf_sum : has_sum (Œª (i : Œπ), f i ^ p) (A ^ p)) (hg_sum : has_sum (Œª (i : Œπ), g i ^ q) (B ^ q)) : ‚àÉ (C : ‚Ñù), 0 ‚â§ C ‚àß C ‚â§ A * B ‚àß has_sum (Œª (i : Œπ), f i * g i) C
 : ‚Ñï ‚Üí+ enat
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.faithful (category_theory.shift_functor C i)
 : widget_override.interactive_expression.sf ‚Üí format
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : transitive (category_theory.abelian.pseudo_equal P)
{M : Type uM} {N : Type uN} {P : Type uP} {mM : mul_one_class M} {mN : mul_one_class N} {mP : comm_monoid P} : (M ‚Üí* N ‚Üí* P) ‚Üí* N ‚Üí* M ‚Üí* P
(Œ± : Sort u) (Œ≤ : Œ± ‚Üí Sort v) : setoid (Œ† (x : Œ±), Œ≤ x)
(Œ± : Type u_1) [topological_space Œ±] : punit √ó Œ± ‚âÉ‚Çú Œ±
{L : first_order.language} {M : Type w} [L.Structure M] {s : set M} : s ‚äÜ ‚Üë(‚áë(first_order.language.substructure.closure L) s)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cocone F} (P : category_theory.limits.is_colimit t) : category_theory.limits.is_limit t.op
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [has_one M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñï] [cancel_comm_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) : cancel_comm_monoid M‚ÇÅ
(g : pgame) : g.left_moves ‚Üí pgame
{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_pullbacks C
(Œ± : Type u_1) : Type u_1
{R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [add_comm_group N] [module R M] [module R N] [lie_ring_module L M] [lie_ring_module L N] [lie_module R L M] [lie_module R L N] (e : M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N) : N ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ M
(s : ‚ÑÇ) : ‚ÑÇ
(Œ± : Type u) [add_group Œ±] : Type u
(Œ± : Type u_5) : Type u_5
(e : expr) : tactic (list name)
{g : matrix.special_linear_group (fin 2) ‚Ñ§} (z : upper_half_plane) {p : fin 2 ‚Üí ‚Ñ§} (hp : is_coprime (p 0) (p 1)) (hg : ‚Üëg 1 = p) : ‚Üë(g ‚Ä¢ z) = ‚Üë(‚áë(modular_group.lc_row0 p) ‚Üë‚Üëg) / (‚Üë(p 0) ^ 2 + ‚Üë(p 1) ^ 2) + (‚Üë(p 1) * ‚Üëz - ‚Üë(p 0)) / ((‚Üë(p 0) ^ 2 + ‚Üë(p 1) ^ 2) * (‚Üë(p 0) * ‚Üëz + ‚Üë(p 1)))
{J : Type u} [category_theory.small_category J] (F : J ‚•§ Profinite) : category_theory.limits.cone F
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] (g : R ‚Üí+* S) : R ‚Üí‚Çó[R] S
{Œ± : Type u_1} : has_coe_to_fun (poly Œ±) (Œª (_x : poly Œ±), (Œ± ‚Üí ‚Ñï) ‚Üí ‚Ñ§)
{B : Type u_3} {S : B} {M : Type u_1} [comm_monoid M] [set_like B M] [submonoid_class B M] {Œπ : Type u_2} {t : finset Œπ} {f : Œπ ‚Üí M} (h : ‚àÄ (c : Œπ), c ‚àà t ‚Üí f c ‚àà S) : t.prod (Œª (c : Œπ), f c) ‚àà S
(f : ‚Ñù ‚Üí ‚Ñù) {a b : ‚Ñù} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfd : differentiable_on ‚Ñù f (set.Ioo a b)) (g : ‚Ñù ‚Üí ‚Ñù) (hgc : continuous_on g (set.Icc a b)) (hgd : differentiable_on ‚Ñù g (set.Ioo a b)) : ‚àÉ (c : ‚Ñù) (H : c ‚àà set.Ioo a b), (g b - g a) * deriv f c = (f b - f a) * deriv g c
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) (i : E ‚âÉL[ùïú] F) (hp : 0 < p.radius) : 0 < (p.right_inv i).radius
{A : Type u_2} [comm_ring A] [is_domain A] : is_dedekind_domain A ‚Üî is_dedekind_domain_inv A
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) [lie_algebra.is_nilpotent R ‚Ü•H] : lie_subalgebra R L
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ CommMon) : category_theory.limits.is_colimit (CommMon.filtered_colimits.colimit_cocone F)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (v : V) (nz : v ‚â† 0) : finite_dimensional.finrank K V = 1 ‚Üî submodule.span K {v} = ‚ä§
(pre : option name) (n : name) (vs : list expr) (tgt : expr) : tactic unit
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [nondiscrete_normed_field R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [normed_group F] [normed_space R F] [topological_space B] (a : topological_vector_prebundle R F E) (b : B) : topological_space (E b)
{M : Type u_1} [has_mul M] {r s : M ‚Üí M ‚Üí Prop} (h : ‚àÄ (x y : M), r x y ‚Üí s x y) : con_gen r ‚â§ con_gen s
{R : Type v} [comm_ring R] {n : Type u_1} [decidable_eq n] {M : Type u_2} [add_comm_group M] [module R M] [fintype n] (h : basis n R M) : module.End R M ‚âÉ‚Çê[R] matrix n n R
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {X : C} (h : category_theory.coyoneda.obj (opposite.op X) ‚ãô category_theory.ulift_functor ‚âÖ F.cocones) (s : category_theory.limits.cocone F) : X ‚ü∂ s.X
{A : Type u_2} [comm_ring A] : power_series A ‚Üí+* power_series A
{Œ± : Type u} {Œ≤ : Type v} {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} [partial_order Œ≤] [semilattice_inf Œ±] (gi : galois_insertion l u) : semilattice_inf Œ≤
(X : algebraic_geometry.LocallyRingedSpace) (r : ‚Ü•(algebraic_geometry.LocallyRingedSpace.Œì.obj (opposite.op X))) : X.to_Œì_Spec_map_basic_open r = X.to_RingedSpace.basic_open r
{Œ± : Type u} {a b : Œ±} [mul_zero_one_class Œ±] [partial_order Œ±] [zero_lt.mul_pos_mono Œ±] (ha : 1 ‚â§ a) (hb : 1 ‚â§ b) (b0 : 0 ‚â§ b) : 1 ‚â§ a * b
{Œ± : Type u} [has_le Œ±] [decidable_rel has_le.le] (x : Œ±) : ordnode Œ± ‚Üí option Œ±
{n : ‚Ñï} (hn : even n) : convex_on ‚Ñù set.univ (Œª (x : ‚Ñù), x ^ n)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {n : ‚Ñï} (hs : is_open s) : cont_diff_on ùïú ‚Üë(n + 1) f s ‚Üî differentiable_on ùïú f s ‚àß cont_diff_on ùïú ‚Üën (Œª (y : E), fderiv ùïú f y) s
{Œ± : Type u_1} [decidable_eq Œ±] {s t u : multiset Œ±} : s - t ‚â§ u ‚Üî s ‚â§ u + t
{Œπ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (c : complex_shape Œπ) [category_theory.limits.has_zero_object V] [category_theory.limits.has_equalizers V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] (i : Œπ) : boundaries_functor V c i ‚ü∂ cycles_functor V c i
{Œ± : Type u_1} (R : Œ± ‚Üí Œ± ‚Üí Prop) : Œ± ‚Üí list Œ± ‚Üí Prop
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [locally_compact_space Œ±] : continuous coe_fn
{Œ± : Type u} [topological_space Œ±] [regular_space Œ±] {x y : Œ±} (h : x ‚â† y) : ‚àÉ (U‚ÇÅ : set Œ±) (H : U‚ÇÅ ‚àà nhds x) (V‚ÇÅ : set Œ±) (H : V‚ÇÅ ‚àà nhds x) (U‚ÇÇ : set Œ±) (H : U‚ÇÇ ‚àà nhds y) (V‚ÇÇ : set Œ±) (H : V‚ÇÇ ‚àà nhds y), is_closed V‚ÇÅ ‚àß is_closed V‚ÇÇ ‚àß is_open U‚ÇÅ ‚àß is_open U‚ÇÇ ‚àß V‚ÇÅ ‚äÜ U‚ÇÅ ‚àß V‚ÇÇ ‚äÜ U‚ÇÇ ‚àß U‚ÇÅ ‚à© U‚ÇÇ = ‚àÖ
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop
{Œ± : Type u_1} [comm_semigroup Œ±] {a b : Œ±} (h : a ‚à£ b) (c : Œ±) : a ‚à£ c * b
{G‚ÇÄ : Type u_1} {G‚ÇÄ' : Type u_2} [group_with_zero G‚ÇÄ] [group_with_zero G‚ÇÄ'] (f : G‚ÇÄ ‚Üí*‚ÇÄ G‚ÇÄ') (x : G‚ÇÄ) (n : ‚Ñ§) : ‚áëf (x ^ n) = ‚áëf x ^ n
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [preorder Œ±] [preorder Œ≤] [preorder Œ≥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s : set Œ±} {t : set Œ≤} (h‚ÇÄ : ‚àÄ (b : Œ≤), monotone (function.swap f b)) (h‚ÇÅ : ‚àÄ (a : Œ±), monotone (f a)) : bdd_below s ‚Üí bdd_below t ‚Üí bdd_below (set.image2 f s t)
{p : ‚Ñï ‚Üí Prop} [decidable_pred p] {n : ‚Ñï} : ¬¨p n ‚Üí nat.count p (n + 1) = nat.count p n
{C : Type u} [category_theory.category C] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] [category_theory.limits.has_colimits_of_shape J C] (F : J ‚•§ K ‚•§ C) : category_theory.limits.colimit F ‚âÖ F.flip ‚ãô category_theory.limits.colim
(p : omega.nat.preform) : (‚Ñï ‚Üí ‚Ñï) ‚Üí ‚Ñï ‚Üí Prop
{M : Type u_1} [group M] (c : con M) {w x y z : M} : ‚áëc w x ‚Üí ‚áëc y z ‚Üí ‚áëc (w / y) (x / z)
(ùïú : Type u_1) (E : Type u_2) [comm_semiring ùïú] [topological_space ùïú] [has_continuous_add ùïú] [has_continuous_const_smul ùïú ùïú] [add_comm_monoid E] [module ùïú E] [topological_space E] : Type u_2
{Œ± : Type u} [add_comm_group Œ±] : is_add_group_hom has_neg.neg
{K : Type u_1} (v : K) [linear_ordered_field K] [floor_ring K] : simple_continued_fraction K
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k ‚Üí PE) (a b r : k) : ‚áë(affine_map.line_map (slope f (‚áë(affine_map.line_map a b) r) b) (slope f a (‚áë(affine_map.line_map a b) r))) r = slope f a b
 : ‚àÉ (f : nat.partrec.code ‚Üí ‚Ñï ‚Üí nat.partrec.code), computable‚ÇÇ f ‚àß ‚àÄ (c : nat.partrec.code) (n x : ‚Ñï), (f c n).eval x = c.eval (nat.mkpair n x)
{C : Type u} [category_theory.category C] (A : C) [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] : ùü≠ C ‚ü∂ category_theory.limits.prod.functor.obj A ‚ãô category_theory.exp A
(t : interactive.parse (optional (interactive.with_desc ‚Üë"{...}" lean.parser.itactic))) : tactic unit
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Œπ] {p : Œπ ‚Üí P} (hi : affine_independent k p) {n : ‚Ñï} (hc : fintype.card Œπ = n + 1) : finite_dimensional.finrank k ‚Ü•(vector_span k (set.range p)) = n
{Œ± : Type u_2} {Œ≤ : Type u_3} [topological_space Œ±] [preorder Œ±] [topological_space Œ≤] [preorder Œ≤] (f : esakia_hom Œ± Œ≤) : pseudo_epimorphism Œ± Œ≤
 : declaration ‚Üí list level ‚Üí option expr
{Œ± : Type u} {L‚ÇÅ L‚ÇÇ : list (Œ± √ó bool)} : free_group.red L‚ÇÅ L‚ÇÇ ‚Üí L‚ÇÇ <+ L‚ÇÅ
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {s : category_theory.limits.cone F} (e : K ‚âå J) (P : category_theory.limits.is_limit (category_theory.limits.cone.whisker e.functor s)) : category_theory.limits.is_limit s
{p : ‚Ñï} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] : witt_vector p R ‚Üí+* R
(p q : ‚Ñï) [fact (nat.prime p)] [fact (nat.prime q)] (hp1 : p ‚â† 2) (hq1 : q ‚â† 2) (hpq : p ‚â† q) : zmod.legendre_sym q ‚Üëp * zmod.legendre_sym p ‚Üëq = (-1) ^ (p / 2 * (q / 2))
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : C(X, ‚Ñù)) {t : set ‚Ñù} {e : X ‚Üí Y} [hs : t.ord_connected] (hf : ‚àÄ (x : X), ‚áëf x ‚àà t) (hne : t.nonempty) (he : closed_embedding e) : ‚àÉ (g : C(Y, ‚Ñù)), (‚àÄ (y : Y), ‚áëg y ‚àà t) ‚àß ‚áëg ‚àò e = ‚áëf
{K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x ‚Üî is_integral K x
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_sizeof Œ±] [has_sizeof Œ≤] (shr_a : slim_check.shrink_fn Œ±) (shr_b : slim_check.shrink_fn Œ≤) : slim_check.shrink_fn (Œ± √ó Œ≤)
 : onote ‚Üí onote ‚Üí ordering
{Œ± : Type u_1} [measurable_space Œ±] [measurable_singleton_class Œ±] {s : set Œ±} (u t : set Œ±) (hs : s.finite) : ‚áë(probability_theory.cond_count (s ‚à© u)) t * ‚áë(probability_theory.cond_count s) u + ‚áë(probability_theory.cond_count (s ‚à© u·∂ú)) t * ‚áë(probability_theory.cond_count s) u·∂ú = ‚áë(probability_theory.cond_count s) t
{Œ± : Type u_1} [semigroup Œ±] {a b : Œ±} (h : a ‚à£ b) (c : Œ±) : a ‚à£ b * c
{Œ± : Type u} [linear_order Œ±] : Œ± ‚Üí Œ± ‚Üí set Œ±
{Œπ : Type u_1} {E : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), metric_space (E i)] : has_dist (Œ£ (i : Œπ), E i)
{R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {v‚ÇÅ v‚ÇÇ : M} (h : same_ray R v‚ÇÅ v‚ÇÇ) : ‚àÉ (u : M) (a b : R), 0 ‚â§ a ‚àß 0 ‚â§ b ‚àß a + b = 1 ‚àß v‚ÇÅ = a ‚Ä¢ u ‚àß v‚ÇÇ = b ‚Ä¢ u
{Œ± : Type u} {Œ≤ : Type v} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {n : ‚Ñï} (hf : ‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚àà t) (hn : t.card * n < s.card) : ‚àÉ (y : Œ≤) (H : y ‚àà t), n < (finset.filter (Œª (x : Œ±), f x = y) s).card
{Œ± : Type u} [preorder Œ±] {a : Œ±} {s t p : set Œ±} (hs : is_lub s a) (hp : is_lub p a) (hst : s ‚äÜ t) (htp : t ‚äÜ p) : is_lub t a
{C : Type u_1} [category_theory.category C] (r : hom_rel C) : Prop
{Œ≥ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} (f : Œ± ‚Üí Œ≤) (x : functor.const Œ≥ Œ≤) : functor.const Œ≥ Œ±
(revert_deps : interactive.parse (optional (lean.parser.tk "!"))) : tactic unit
(n : ‚Ñï) (R : Type u_1) [ring R] : polynomial.map (int.cast_ring_hom R) (polynomial.cyclotomic n ‚Ñ§) = polynomial.cyclotomic n R
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (f : M ‚Üí* N) (hf : ‚àÄ (x y : M), commute (‚áëf x) (‚áëf y)) : M ‚Üí* N·µê·µí·µñ
{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F = 2) {a : F} (ha : a ‚â† 0) : char.quadratic_char F a = 1
{R : Type u} {Œπ : Type w} (s : finset Œπ) [comm_semiring R] [no_zero_divisors R] (f : Œπ ‚Üí polynomial R) (h : ‚àÄ (i : Œπ), i ‚àà s ‚Üí f i ‚â† 0) : (s.prod (Œª (i : Œπ), f i)).nat_degree = s.sum (Œª (i : Œπ), (f i).nat_degree)
(m n : ‚Ñ§) : list ‚Ñ§
 : Type u ‚Üí Type u
 : category_theory.limits.has_limits_of_size Group
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {f g : ‚Ñù ‚Üí E} {x : ‚Ñù} (f_diff : ‚àÄ (y : ‚Ñù), y ‚â† x ‚Üí has_deriv_at f (g y) y) (hf : continuous_at f x) (hg : continuous_at g x) : has_deriv_at f (g x) x
{Œ± : Type u} (u : uniform_space.core Œ±) : topological_space Œ±
{E : Type u_2} [normed_group E] [normed_space ‚Ñù E] {r : ‚Ñù} (hr : 0 ‚â§ r) (x : E) : x +·µ• r ‚Ä¢ metric.closed_ball 0 1 = metric.closed_ball x r
{M : Type u_3} [add_comm_group M] {R‚ÇÇ : Type u} [ordered_ring R‚ÇÇ] [module R‚ÇÇ M] (Q‚ÇÇ : quadratic_form R‚ÇÇ M) : Prop
{C : Type u} [category_theory.category C] {X Y Z X' Y' Z' : C} (iX : X ‚âÖ X') (iY : Y ‚âÖ Y') (iZ : Z ‚âÖ Z') {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} {f' : X' ‚ü∂ Z'} {g' : Y' ‚ü∂ Z'} (wf : iX.hom ‚â´ f' = f ‚â´ iZ.hom) (wg : iY.hom ‚â´ g' = g ‚â´ iZ.hom) : category_theory.limits.cospan f g ‚âÖ category_theory.limits.cospan f' g'
(n k : ‚Ñï) : n.asc_factorial k = (n + k).factorial / n.factorial
(e : expr) : tactic expr
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x : V) {r‚ÇÅ r‚ÇÇ : ‚Ñù} : 2 ‚Ä¢ hb.oangle (r‚ÇÅ ‚Ä¢ x) (r‚ÇÇ ‚Ä¢ x) = 0
(Œ± : Type u_3) [has_sup Œ±] [has_bot Œ±] : sup_bot_hom Œ± Œ±
 : snum ‚Üí ‚Ñ§
{Œ± : Type u_2} {Œ≤ : Type u_3} [complete_lattice Œ±] [complete_lattice Œ≤] (f : complete_lattice_hom Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : complete_lattice_hom Œ± Œ≤
 : onote ‚Üí onote ‚Üí onote
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] (C : cochain_complex V ‚Ñï) (X : V) : ((cochain_complex.single‚ÇÄ V).obj X ‚ü∂ C) ‚âÉ {f // f ‚â´ C.d 0 1 = 0}
{V : Type u} [fintype V] {G : simple_graph V} [decidable_rel G.adj] {v w : V} (h : G.adj v w) : fintype.card ‚Ü•(G.common_neighbors v w) < G.degree v
 : expr.address ‚Üí expr.address ‚Üí option expr.address
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] : M ‚Üí‚Çó[R] M
(R : Type u) {B : Type v} [comm_ring R] [decidable_eq B] [fintype B] (A : matrix B B ‚Ñ§) : set (free_lie_algebra R (cartan_matrix.generators B))
{Œ± : Type u_1} [group Œ±] : has_quotient Œ± (subgroup Œ±)
{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : ‚áë(polynomial.aeval M) M.charpoly = 0
 : Type (u_1+1)
(Œ± : Type u) : Type u
{C : Type u} [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C] (F : category_theory.discrete category_theory.limits.walking_pair ‚•§ C) : category_theory.limits.limit_cone F
(C : Type u_1) [category_theory.category C] : category_theory.is_idempotent_complete C ‚Üî ‚àÄ (X : C) (p : X ‚ü∂ X), p ‚â´ p = p ‚Üí category_theory.limits.has_equalizer (ùüô X) p
(ùïú : Type u_5) (ùïú' : Type u_6) [normed_field ùïú] [normed_field ùïú'] [normed_algebra ùïú ùïú'] (E : Type u_7) [semi_normed_group E] [normed_space ùïú' E] : normed_space ùïú (restrict_scalars ùïú ùïú' E)
{X Y : SemiNormedGroup} (f : X ‚ü∂ Y) (s : category_theory.limits.cokernel_cofork f) : (SemiNormedGroup.cokernel_cocone f).X ‚ü∂ s.X
(q : interactive.parse interactive.types.texpr) : tactic unit
{R : Type u} {A‚ÇÅ : Type v} [comm_semiring R] [semiring A‚ÇÅ] [algebra R A‚ÇÅ] : mul_semiring_action (A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÅ) A‚ÇÅ
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y Z : C} {f g : X ‚ü∂ Y} {h : Z ‚ü∂ X} (w : h ‚â´ f = h ‚â´ g) [category_theory.limits.preserves_limit (category_theory.limits.parallel_pair f g) G] (l : category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ h w)) : category_theory.limits.is_limit (category_theory.limits.fork.of_Œπ (G.map h) _)
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type v‚ÇÅ} [category_theory.small_category J] {K : J ‚•§ C} (c : category_theory.limits.cone K) : J ‚•§ category_theory.structured_arrow c.X K
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) {G : D ‚•§ C} (h : F.to_lax_monoidal_functor.to_functor ‚ä£ G) : category_theory.lax_monoidal_functor D C
{ùïú : Type u_1} {E : Type u_2} [ordered_semiring ùïú] [add_comm_group E] [has_scalar ùïú E] (S : convex_cone ùïú E) (h‚ÇÅ : S.pointed) (h‚ÇÇ : S.salient) : ordered_add_comm_group E
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [add_left_cancel_semigroup M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) : add_left_cancel_semigroup M‚ÇÅ
{V : Type u} {G : simple_graph V} {u v : V} : G.walk u v ‚Üí list G.dart
{Œ± : Type u} [pseudo_emetric_space Œ±] (E : set Œ±) : closure E = ‚ãÇ (Œ¥ : ‚Ñù) (h : 0 < Œ¥), metric.thickening Œ¥ E
{R : Type u} [semiring R] {a b : add_monoid_algebra R ‚Ñï} : {to_finsupp := a} = {to_finsupp := b} ‚Üî a = b
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {n : with_top ‚Ñï} {f : F ‚Üí G} {x : E √ó F} (hf : cont_diff_at ùïú n f x.snd) : cont_diff_at ùïú n (Œª (x : E √ó F), f x.snd) x
{R : Type u_1} [comm_ring R] {M‚ÇÅ : Type u_4} {M‚ÇÇ : Type u_5} [add_comm_group M‚ÇÅ] [add_comm_group M‚ÇÇ] [module R M‚ÇÅ] [module R M‚ÇÇ] (Q‚ÇÅ : quadratic_form R M‚ÇÅ) (Q‚ÇÇ : quadratic_form R M‚ÇÇ) (f : M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ) (hf : ‚àÄ (m : M‚ÇÅ), ‚áëQ‚ÇÇ (‚áëf m) = ‚áëQ‚ÇÅ m) : clifford_algebra Q‚ÇÅ ‚Üí‚Çê[R] clifford_algebra Q‚ÇÇ
{Œ± : Type u_1} [preorder Œ±] {a : Œ±} : nonempty ‚Ü•(set.Ici a)
 : CommRing·µí·µñ ‚•§ algebraic_geometry.SheafedSpace CommRing
 : ‚Ñï ‚Üí ‚Ñï
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_terminal C
{M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_3} [has_zero M‚ÇÄ'] [has_mul M‚ÇÄ'] [semigroup_with_zero M‚ÇÄ] (f : M‚ÇÄ' ‚Üí M‚ÇÄ) (hf : function.injective f) (zero : f 0 = 0) (mul : ‚àÄ (x y : M‚ÇÄ'), f (x * y) = f x * f y) : semigroup_with_zero M‚ÇÄ'
(n : ‚Ñï) : finset.univ = finset.cons 0 (finset.map {to_fun := fin.succ n, inj' := _} finset.univ) _
{M : Type u_1} [group M] (c : con M) : group c.quotient
{n : ‚Ñï} {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (b : Œ≤) (v : vector Œ± n) : (vector.scanl f b v).head = b
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : M ‚Üí‚Çó[R] direct_sum ‚Ñï (Œª (i : ‚Ñï), ‚Ü•((exterior_algebra.Œπ R).range ^ i))
{R : Type u_3} [comm_semiring R] {R‚ÇÇ : Type u_4} [comm_semiring R‚ÇÇ] {R‚ÇÉ : Type u_5} [comm_semiring R‚ÇÉ] {M : Type u_7} {N : Type u_8} (P : Type u_9) [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R‚ÇÇ N] [module R‚ÇÉ P] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} (œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ) {œÉ‚ÇÅ‚ÇÉ : R ‚Üí+* R‚ÇÉ} [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] N) : (N ‚Üí‚Çõ‚Çó[œÉ‚ÇÇ‚ÇÉ] P) ‚Üí‚Çó[R‚ÇÉ] M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÉ] P
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [linear_ordered_add_comm_group Œ≤] [order_topology Œ≤] (f : C(Œ±, Œ≤)) : C(Œ±, Œ≤)
{V : Type u} {G : simple_graph V} (x : G.subgraph) : x.coe ‚Üíg G
(f : circle_deg1_lift) (n : ‚Ñï) : ‚Ñù
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [succ_order Œ±] [is_succ_archimedean Œ±] [linear_order Œ≤] {f : Œ± ‚Üí Œ≤} (hf : monotone f) (m n : Œ±) : (‚ãÉ (i : Œ±) (H : i ‚àà set.Ico m n), set.Ioc (f i) (f (order.succ i))) = set.Ioc (f m) (f n)
(C : Type u‚ÇÅ) [category_theory.category C] : Type (max u‚ÇÅ v‚ÇÅ)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : (Œ£ (y : Œ≤), {x // f x = y}) ‚âÉ Œ±
 : linter
{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.over Y ‚•§ category_theory.over X
{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_3} [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] : has_neg (normed_group_hom V‚ÇÅ V‚ÇÇ)
{n m : ‚Ñï} (h : n ‚â† m) : is_coprime (polynomial.cyclotomic n ‚Ñö) (polynomial.cyclotomic m ‚Ñö)
{Œ≥ : Type} (local_c : widget.tc widget_override.local_collection Œ≥) (target_c : widget.tc expr Œ≥) : widget.tc unit Œ≥
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F G : J ‚•§ C} (Œ± : F ‚âÖ G) (c : category_theory.limits.cocone G) : category_theory.limits.is_colimit ((category_theory.limits.cocones.precompose Œ±.hom).obj c) ‚âÉ category_theory.limits.is_colimit c
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) (A B : C) [category_theory.limits.has_binary_coproduct A B] [category_theory.limits.has_binary_coproduct (F.obj A) (F.obj B)] : F.obj A ‚®ø F.obj B ‚ü∂ F.obj (A ‚®ø B)
{Œπ : Type u} (s : finset Œπ) (w z : Œπ ‚Üí nnreal) (hw' : s.sum (Œª (i : Œπ), w i) = 1) (n : ‚Ñï) : s.sum (Œª (i : Œπ), w i * z i) ^ n ‚â§ s.sum (Œª (i : Œπ), w i * z i ^ n)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [locally_compact_space Œ±] [locally_compact_space Œ≤] : C(Œ± √ó Œ≤, Œ≥) ‚âÉ‚Çú C(Œ±, C(Œ≤, Œ≥))
{R : Type u_1} {S : Type u_6} {M : Type u_9} {M‚ÇÅ : Type u_11} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÅ] [module R M] [module R M‚ÇÅ] [semiring S] [module R S] [module S M] [is_scalar_tower R S M] (f : M‚ÇÅ ‚Üí‚Çó[R] S) (x : M) : M‚ÇÅ ‚Üí‚Çó[R] M
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [preorder Œ≤] {l : Œ±·µí·µà ‚Üí Œ≤·µí·µà} {u : Œ≤·µí·µà ‚Üí Œ±·µí·µà} : galois_coinsertion l u ‚Üí galois_insertion (‚áëorder_dual.of_dual ‚àò u ‚àò ‚áëorder_dual.to_dual) (‚áëorder_dual.of_dual ‚àò l ‚àò ‚áëorder_dual.to_dual)
(ns : list name) (reserved : name_set) : tactic name
{ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {ùïú‚ÇÉ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [normed_group E] [normed_group F] [normed_group G] [nondiscrete_normed_field ùïú] [nondiscrete_normed_field ùïú‚ÇÇ] [nondiscrete_normed_field ùïú‚ÇÉ] [normed_space ùïú E] [normed_space ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : ùïú‚ÇÇ ‚Üí+* ùïú} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] [ring_hom_isometric œÉ‚ÇÇ‚ÇÅ] {ùïú‚ÇÑ : Type u_10} [nondiscrete_normed_field ùïú‚ÇÑ] {H : Type u_11} [normed_group H] [normed_space ùïú‚ÇÑ H] [normed_space ùïú‚ÇÉ G] {œÉ‚ÇÇ‚ÇÉ : ùïú‚ÇÇ ‚Üí+* ùïú‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : ùïú ‚Üí+* ùïú‚ÇÉ} {œÉ‚ÇÉ‚ÇÑ : ùïú‚ÇÉ ‚Üí+* ùïú‚ÇÑ} {œÉ‚ÇÑ‚ÇÉ : ùïú‚ÇÑ ‚Üí+* ùïú‚ÇÉ} {œÉ‚ÇÇ‚ÇÑ : ùïú‚ÇÇ ‚Üí+* ùïú‚ÇÑ} {œÉ‚ÇÅ‚ÇÑ : ùïú ‚Üí+* ùïú‚ÇÑ} [ring_hom_inv_pair œÉ‚ÇÉ‚ÇÑ œÉ‚ÇÑ‚ÇÉ] [ring_hom_inv_pair œÉ‚ÇÑ‚ÇÉ œÉ‚ÇÉ‚ÇÑ] [ring_hom_comp_triple œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÑ œÉ‚ÇÇ‚ÇÑ] [ring_hom_comp_triple œÉ‚ÇÇ‚ÇÑ œÉ‚ÇÑ‚ÇÉ œÉ‚ÇÇ‚ÇÉ] [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÉ œÉ‚ÇÉ‚ÇÑ œÉ‚ÇÅ‚ÇÑ] [ring_hom_isometric œÉ‚ÇÅ‚ÇÑ] [ring_hom_isometric œÉ‚ÇÇ‚ÇÉ] [ring_hom_isometric œÉ‚ÇÑ‚ÇÉ] [ring_hom_isometric œÉ‚ÇÇ‚ÇÑ] [ring_hom_isometric œÉ‚ÇÅ‚ÇÉ] [ring_hom_isometric œÉ‚ÇÅ‚ÇÇ] [ring_hom_isometric œÉ‚ÇÉ‚ÇÑ] (e‚ÇÅ‚ÇÇ : E ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] F) (e‚ÇÑ‚ÇÉ : H ‚âÉSL[œÉ‚ÇÑ‚ÇÉ] G) : (E ‚ÜíSL[œÉ‚ÇÅ‚ÇÑ] H) ‚âÉSL[œÉ‚ÇÑ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G
{R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ‚âÉ+* S) : ‚Üëf.to_add_monoid_hom = ‚Üëf.to_add_monoid_hom
{Œ± : Type u_1} {m : measurable_space Œ±} : measure_theory.measure Œ± ‚Üí+ set Œ± ‚Üí ennreal
{Œ± : Type v} {d u l r : ‚Ñï} (A : matrix (fin (u + d)) (fin (l + r)) Œ±) : matrix (fin d) (fin r) Œ±
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) (h : is_unit A.det) : A‚Åª¬π.mul A = 1
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [semiring R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] [topological_space (bundle.total_space E)] (e : topological_vector_bundle.trivialization R F E) (b : B) (y : F) : E b
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x : Œ±} {r : ‚Ñù} (hs : s.nonempty) : metric.inf_dist x s < r ‚Üî ‚àÉ (y : Œ±) (H : y ‚àà s), has_dist.dist x y < r
{M : Type u_1} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (m : multiset M) : (‚àÄ (a : M), a ‚àà m ‚Üí a ‚àà s) ‚Üí m.sum ‚àà s
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] : normed_space ‚Ñù E
(G : Type u_1) [group G] : set G
{Œπ : Type u_1} {R : Type u_3} {A : Type u_5} {x : Œπ ‚Üí A} [comm_ring R] [comm_ring A] [algebra R A] (hx : algebraic_independent R x) : mv_polynomial Œπ R ‚âÉ‚Çê[R] ‚Ü•(algebra.adjoin R (set.range x))
 : tactic unit
{C : Type u} [category_theory.category C] [category_theory.has_shift C ‚Ñ§] {T‚ÇÅ T‚ÇÇ T‚ÇÉ : category_theory.triangulated.triangle C} (f : category_theory.triangulated.triangle_morphism T‚ÇÅ T‚ÇÇ) (g : category_theory.triangulated.triangle_morphism T‚ÇÇ T‚ÇÉ) : category_theory.triangulated.triangle_morphism T‚ÇÅ T‚ÇÉ
{R : Type u} [semiring R] {S : Type v} [semiring S] {f : R ‚Üí+* S} {s : S} (h : s ‚àà set.range ‚áëf) : ‚áëpolynomial.C s ‚àà polynomial.lifts f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : (s1 ‚äì s2).direction ‚â§ s1.direction ‚äì s2.direction
(c : tactic.instance_cache) (ex ey : expr) : tactic (tactic.instance_cache √ó expr √ó expr)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) : M ‚Üí‚Çó[R] M ‚ß∏ p
{G : Type u_10} [group_with_zero G] (a : G) (ha : a ‚â† 0) : equiv.perm G
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F : J ‚•§ C} (H : C ‚•§ D) (c : category_theory.limits.cocone F) : category_theory.limits.cocone (F ‚ãô H)
{p : ‚Ñï} (hp : 1 < p) : padic_val_rat p ‚Üëp = 1
{Œ± : Type u} {l‚ÇÅ l‚ÇÇ : list Œ±} {n : ‚Ñï} : list.take n (l‚ÇÅ ++ l‚ÇÇ) = list.take n l‚ÇÅ ++ list.take (n - l‚ÇÅ.length) l‚ÇÇ
 : set.inj_on nat.factorization {x : ‚Ñï | x ‚â† 0}
{R : Type u_1} [non_unital_non_assoc_semiring R] : R ‚Üí+ add_monoid.End R
{Œπ : Type u_1} {M : Œπ ‚Üí Type u_2} [Œ† (i : Œπ), monoid (M i)] : free_product.word M
{w x y z : pgame} (h‚ÇÅ : w.relabelling x) (h‚ÇÇ : y.relabelling z) : (w - y).relabelling (x - z)
(_x : interactive.parse (lean.parser.tk "import_private")) : lean.parser unit
(J : Type u) (f : J ‚Üí category_theory.Groupoid) : category_theory.Groupoid.of (Œ† (j : J), ‚Ü•(f j)) ‚âÖ ‚àè f
 : first_order.language.order.Theory
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : S = ‚ä• ‚à® nontrivial ‚Ü•S
(V : Type (u+1)) [category_theory.large_category V] {G H K : Mon} (f : G ‚ü∂ H) (g : H ‚ü∂ K) : Action.res V g ‚ãô Action.res V f ‚âÖ Action.res V (f ‚â´ g)
{Œ± : Type u_1} {Œ≤ : Type u_2} (e : Œ± ‚âÉ Œ≤) : ‚Ü•(derangements Œ±) ‚âÉ ‚Ü•(derangements Œ≤)
(struct_n : name) : tactic (list (name √ó name))
{ùïú : Type u_1} {E : Type u_2} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] {x : E} {s : set E} : star_convex ùïú x s ‚Üî ‚àÄ ‚¶Éy : E‚¶Ñ, y ‚àà s ‚Üí ‚àÄ ‚¶Éa b : ùïú‚¶Ñ, 0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí 0 < a + b ‚Üí (a / (a + b)) ‚Ä¢ x + (b / (a + b)) ‚Ä¢ y ‚àà s
{Œ± : Type u} [ordered_cancel_comm_monoid Œ±] {Œ≤ : Type u_1} [has_one Œ≤] [has_mul Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : ordered_cancel_comm_monoid Œ≤
{Œ≤ : Type u} {Œ± : Type v} [comm_monoid Œ≤] [fintype Œ±] [decidable_eq Œ±] (s : finset Œ±) (f : Œ± ‚Üí Œ≤) : s.prod (Œª (i : Œ±), f i) * s·∂ú.prod (Œª (i : Œ±), f i) = finset.univ.prod (Œª (i : Œ±), f i)
{E : Type u_1} [inner_product_space ‚Ñù E] (v w : E) : E
 : category_theory.limits.preserves_limits_of_size (category_theory.forget Group)
{Œ± : Type uu} {r : Œ± ‚Üí Œ± ‚Üí Prop} [decidable_rel r] {l : list Œ±} (h : list.sorted r l) : list.insertion_sort r l = l
{Œ± : Type u} [has_subset Œ±] {a b : Œ±} [is_antisymm Œ± has_subset.subset] (h : a ‚äÜ b) (h' : b ‚äÜ a) : b = a
{x k l : ‚Ñï} (w : 1 < x) : x ^ k ‚à£ x ^ l ‚Üî k ‚â§ l
{Œ± : Type u_1} [is_empty Œ±] : finset.univ = ‚àÖ
{R : Type u_1} {M : Type u_2} {Œπ : Type u_5} [comm_semiring R] [add_comm_monoid M] [module R M] [decidable_eq Œπ] (b : basis Œπ R M) (m : M) : M ‚Üí‚Çó[R] R
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : function.surjective proj
{Œ± : Type u_1} [emetric_space Œ±] {K : nnreal} (f : Œ± ‚Üí Œ±) {s : set Œ±} (hsc : is_complete s) (hsf : set.maps_to f s s) (hf : contracting_with K (set.maps_to.restrict f s s hsf)) (x : Œ±) (hxs : x ‚àà s) (hx : has_edist.edist x (f x) ‚â† ‚ä§) : Œ±
{m : Type u_1} [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (M N P : matrix m m R) : ((M.mul N).mul P).det = ((M.mul P).mul N).det
(J : Type v) : Type v
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (f g : M ‚Üí‚Çô* N) : subsemigroup M
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} {x : Œ±} {xs : list Œ±} (f : Œ† (a : Œ±), a ‚àà x :: xs ‚Üí Œ≤ a) (a : Œ±) : a ‚àà xs ‚Üí Œ≤ a
{Œ± : Sort u_1} [s : setoid Œ±] : quotient s ‚Üí Œ±
{Œ± : Type u} {Œ≤ : Type v} [group Œ±] [mul_action Œ± Œ≤] (g : Œ±) (x : Œ≤) : mul_action.stabilizer Œ± (g ‚Ä¢ x) = subgroup.map (mul_equiv.to_monoid_hom (‚áëmul_aut.conj g)) (mul_action.stabilizer Œ± x)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.has_shift C ‚Ñ§] {T‚ÇÅ T‚ÇÇ : category_theory.triangulated.triangle C} (f : category_theory.triangulated.triangle_morphism T‚ÇÅ T‚ÇÇ) : category_theory.triangulated.triangle_morphism T‚ÇÅ.inv_rotate T‚ÇÇ.inv_rotate
(L : first_order.language) (M : Type u_3) [L.Structure M] : Type u_3
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ‚ü∂ Y} (t : category_theory.limits.cokernel_cofork f) (desc : Œ† (s : category_theory.limits.cokernel_cofork f), t.X ‚ü∂ s.X) (fac : ‚àÄ (s : category_theory.limits.cokernel_cofork f), category_theory.limits.cofork.œÄ t ‚â´ desc s = category_theory.limits.cofork.œÄ s) (uniq : ‚àÄ (s : category_theory.limits.cokernel_cofork f) (m : t.X ‚ü∂ s.X), category_theory.limits.cofork.œÄ t ‚â´ m = category_theory.limits.cofork.œÄ s ‚Üí m = desc s) : category_theory.limits.is_colimit t
 : interactive.parse (lean.parser.many lean.parser.ident) ‚Üí interactive.parse interactive.types.location ‚Üí tactic unit
{M : Type u_1} [monoid M] (S : submonoid M) : submonoid M
(t : tree expr) : tactic.ring2.csring_expr ‚Üí state_t (list expr) option tactic.ring2.csring_expr
{n : ‚Ñï} {i : fin (n + 2)} {j : fin (n + 1)} (H : ‚áëfin.cast_succ j < i) : simplex_category.Œ¥ i.succ ‚â´ simplex_category.œÉ (‚áëfin.cast_succ j) = simplex_category.œÉ j ‚â´ simplex_category.Œ¥ i
 : category_theory.Groupoid ‚•§ category_theory.Cat
(R : Type u_1) (S : Type u_2) [comm_ring R] [comm_ring S] [algebra R S] : bilin_form R S
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (G : D ‚•§ C) : Prop
{L : first_order.language} {Œ± : Type u'} (t‚ÇÅ t‚ÇÇ : L.term Œ±) : L.formula Œ±
{ùïú : Type u_1} {E : Type u_2} [ordered_ring ùïú] [add_comm_group E] [module ùïú E] (K : geometry.simplicial_complex ùïú E) (faces : set (finset E)) (subset : faces ‚äÜ K.faces) (down_closed : ‚àÄ {s t : finset E}, s ‚àà faces ‚Üí t ‚äÜ s ‚Üí t ‚àà faces) : geometry.simplicial_complex ùïú E
 : tactic (list expr)
{F : pfunctor} [decidable_eq F.A] [inhabited F.M] (ps : pfunctor.approx.path F) : F.M ‚Üí F.A
{R : Type u_1} {S : Type u_2} (L : Type u_4) [euclidean_domain R] [comm_ring S] [is_domain S] [field L] [algebra R S] [algebra S L] {abv : absolute_value R ‚Ñ§} {Œπ : Type u_5} [decidable_eq Œπ] [fintype Œπ] (bS : basis Œπ R S) (adm : abv.is_admissible) [infinite R] [decidable_eq R] [is_fraction_ring S L] [is_dedekind_domain S] (J : {J // ‚áë(algebra_map R S) ((class_group.finset_approx bS adm).prod (Œª (m : R), m)) ‚àà J}) : class_group S L
 : name ‚Üí string
 : tactic.unsafe.type_context local_context
{R : Type u_1} [comm_semiring R] {R' : Type u_2} [monoid R'] {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] [distrib_mul_action R' M] [smul_comm_class R R' M] {R'‚ÇÇ : Type u_9} [monoid R'‚ÇÇ] [distrib_mul_action R'‚ÇÇ M] [smul_comm_class R R'‚ÇÇ M] [has_scalar R'‚ÇÇ R'] [distrib_mul_action R'‚ÇÇ N] [distrib_mul_action R' N] [tensor_product.compatible_smul R R'‚ÇÇ M N] [tensor_product.compatible_smul R R' M N] [is_scalar_tower R'‚ÇÇ R' N] : is_scalar_tower R'‚ÇÇ R' (tensor_product R M N)
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (e : M ‚âÉ* N) (S : submonoid M) : ‚Ü•S ‚âÉ* ‚Ü•(submonoid.map e.to_monoid_hom S)
{Œ± Œ≤ : Type} {ea : computability.fin_encoding Œ±} {eb : computability.fin_encoding Œ≤} {f : Œ± ‚Üí Œ≤} (h : turing.tm2_computable_in_time ea eb f) : turing.tm2_computable ea eb f
{ùïú : Type u_3} {E : Type u_4} [normed_field ùïú] [semi_normed_group E] [normed_space ùïú E] {r : ‚Ñù} : balanced ùïú (metric.ball 0 r)
{C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] (F : J ‚•§ C) [category_theory.limits.has_colimit (category_theory.discrete.functor F.obj)] [category_theory.limits.has_colimit (category_theory.discrete.functor (Œª (f : Œ£ (p : J √ó J), p.fst ‚ü∂ p.snd), F.obj f.fst.fst))] [category_theory.limits.has_coequalizers C] : category_theory.limits.colimit_cocone F
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [ring ùïú] [add_comm_group E] [add_comm_group F] [module ùïú E] [module ùïú F] [topological_space E] [topological_space F] [topological_add_group E] [topological_add_group F] [has_continuous_const_smul ùïú E] [has_continuous_const_smul ùïú F] (p : formal_multilinear_series ùïú E F) (x : E) : F
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : filter Œπ} (h : tendsto_uniformly F f p) (x : Œ±) : filter.tendsto (Œª (n : Œπ), F n x) p (nhds (f x))
{G : Type u_1} [add_group G] {H : add_subgroup G} (hH : H.index ‚â† 0) : fintype (G ‚ß∏ H)
(_x : interactive.parse (lean.parser.tk "#lint_mathlib")) : lean.parser unit
(C : Type u‚ÇÅ) [category_theory.category C] : Type (max u‚ÇÅ v‚ÇÅ)
{R : Type u} [comm_ring R] {q : polynomial R} (p : polynomial R) (hq : q.monic) : decidable (q ‚à£ p)
(p : ‚Ñï) [hp : fact (nat.prime p)] (n : ‚Ñï) : zmod (p ^ n) ‚âÉ+* truncated_witt_vector p n (zmod p)
{K : Type u} [field K] {S T : subfield K} (h : ‚àÄ (x : K), x ‚àà S ‚Üî x ‚àà T) : S = T
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s t : set Œ±) : Prop
{R : Type u} {M : Type v} {M‚ÇÇ : Type w} {M‚ÇÉ : Type y} (S : Type u_3) [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [add_comm_monoid M‚ÇÉ] [module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] [module S M‚ÇÉ] [smul_comm_class R S M‚ÇÉ] : ((M ‚Üí‚Çó[R] M‚ÇÉ) √ó (M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÉ)) ‚âÉ‚Çó[S] M √ó M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÉ
{Œ± : Type u_3} {Œ≤ : Type u_4} [linear_ordered_field Œ±] {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±} {r : Œ±} (hr : 0 < r) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (Œª (x : Œ≤), f x * r) l filter.at_bot
(n : ‚Ñï) : sSet ‚•§ sSet.truncated n
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {P X Y : C} (f : P ‚ü∂ X) (g : P ‚ü∂ Y) : category_theory.limits.is_limit (G.map_cone (category_theory.limits.binary_fan.mk f g)) ‚âÉ category_theory.limits.is_limit (category_theory.limits.binary_fan.mk (G.map f) (G.map g))
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] [‚àÄ {X Y : C} (f : X ‚ü∂ Y), category_theory.is_iso (category_theory.abelian.coimage_image_comparison f)] : category_theory.limits.has_images C
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] {C : Type u} [category_theory.category C] {F : J ‚•§ K ‚•§ C} {D : category_theory.limits.diagram_of_cones F} (Q : Œ† (j : J), category_theory.limits.is_limit (D.obj j)) {c : category_theory.limits.cone (category_theory.uncurry.obj F)} (P : category_theory.limits.is_limit c) : category_theory.limits.is_limit (category_theory.limits.cone_of_cone_uncurry Q c)
{Œ± : Type u_2} [decidable_eq Œ±] [has_one Œ±] [has_mul Œ±] [has_inv Œ±] : has_pow (finset Œ±) ‚Ñ§
{R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} [comm_semiring R] [semiring A‚ÇÅ] [semiring A‚ÇÇ] [algebra R A‚ÇÅ] [algebra R A‚ÇÇ] (e : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ) : ‚Üë‚Üëe = ‚Üë‚Üëe
{R : Type u} [ring R] {J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Module R) (j : J) : F.obj j ‚ü∂ Module.filtered_colimits.colimit F
{L : first_order.language} {Œ± : Type u'} {Œ≤ : Type v'} : L.term Œ± ‚Üí (Œ± ‚Üí L.term Œ≤) ‚Üí L.term Œ≤
{J : Type u‚ÇÅ} [category_theory.category J] : J ‚Üí J ‚Üí Prop
{T : Type u‚ÇÅ} [category_theory.category T] (X : T) : category_theory.limits.cocone (category_theory.over.forget X)
{M : Type u_1} [add_zero_class M] (c : add_con M) : add_con.ker c.mk' = c
 : CommRing·µí·µñ ‚•§ ‚Ü•algebraic_geometry.AffineScheme
{A : Type u_4} {B : Type u_5} {C : Type u_6} {D : Type u_7} [add_monoid A] [add_monoid B] [add_monoid C] [add_monoid D] [topological_space A] [topological_space B] [topological_space C] [topological_space D] (f : continuous_add_monoid_hom A C) (g : continuous_add_monoid_hom B D) : continuous_add_monoid_hom (A √ó B) (C √ó D)
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} (C D : homological_complex V c) : Type (max u_1 v)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C·µí·µñ ‚•§ D) : F.right_op.left_op ‚âÖ F
{Œ± : Type u_1} [normed_lattice_add_comm_group Œ±] : topological_lattice Œ±
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) [category_theory.is_filtered J] (x y : Œ£ (j : J), ‚Ü•(F.obj j)) (k : J) (f : x.fst ‚ü∂ k) (g : y.fst ‚ü∂ k) : Mon.filtered_colimits.M.mk F x * Mon.filtered_colimits.M.mk F y = Mon.filtered_colimits.M.mk F ‚ü®k, ‚áë(F.map f) x.snd * ‚áë(F.map g) y.snd‚ü©
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x : Œ±} (h : is_closed s) (hs : s.nonempty) : x ‚àâ s ‚Üî 0 < metric.inf_dist x s
(cf cg : nat.partrec.code) (a k : ‚Ñï) : (cf.prec cg).eval (nat.mkpair a k.succ) = (cf.prec cg).eval (nat.mkpair a k) >>= Œª (ih : ‚Ñï), cg.eval (nat.mkpair a (nat.mkpair k ih))
{Œ± : Type u_1} [group Œ±] (s : subgroup Œ±) : setoid Œ±
{elab‚ÇÅ elab‚ÇÇ : bool} : expr elab‚ÇÅ ‚Üí expr elab‚ÇÇ
{Œ± : Type} (ea : computability.fin_encoding Œ±) : turing.tm2_computable_in_time ea ea id
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {F : Type u_2} [normed_group F] [normed_space ùïú F] {n : ‚Ñï} {f : ùïú ‚Üí F} : iterated_deriv n f = ‚áë((continuous_multilinear_map.pi_field_equiv ùïú (fin n) F).symm) ‚àò iterated_fderiv ùïú n f
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ± ‚Üí Œ≤ √ó Œ≥} {x : Œ±} (hf : continuous_at f x) : continuous_at (Œª (a : Œ±), (f a).fst) x
(ns : name) : tactic string
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : quotient_map proj
 : ‚Ñï ‚Üí onote
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (e e' : local_homeomorph Œ± Œ≤) : Prop
{R : Type u} [comm_ring R] (f : polynomial R) (x y : R) : {z // polynomial.eval x f - polynomial.eval y f = z * (x - y)}
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_add M‚ÇÅ] [add_semigroup M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (mul : ‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) : add_semigroup M‚ÇÅ
(Œ± : Type u_2) [has_lt Œ±] : Prop
(Œ± : Type u_1) : Type u_1
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (K : category_theory.grothendieck_topology D) (G : C ‚•§ D) : Prop
{Œ± : Type u} (x : with_bot Œ±) : x ‚â† ‚ä• ‚Üí Œ±
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±] {a b : Œ±} (hab : a ‚â† b) : closure (set.Ioo a b) = set.Icc a b
(x : simplex_category) (i : fin (x.len + 1)) : simplex_category.mk 0 ‚ü∂ x
(Œ± : Type u) [topological_space Œ±] : Prop
(Œ± : Type u_1) : setoid (list Œ±)
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] : ‚Ü•‚ä§ ‚âÉ‚Çê[F] E
{M : Type u_3} {N : Type u_4} [mul_zero_one_class M] [mul_zero_one_class N] {f g : M ‚Üí*‚ÇÄ N} : f = g ‚Üî ‚àÄ (x : M), ‚áëf x = ‚áëg x
{Œ± : Type u_1} [has_lt Œ±] {a b : Œ±} {o : ordering} : o.compares b a ‚Üí o.swap.compares a b
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] (G : D ‚•§ C) [‚àÄ (A : C), category_theory.limits.has_initial (category_theory.structured_arrow A G)] (A : C) (B : D) : ((‚ä•_ category_theory.structured_arrow A G).right ‚ü∂ B) ‚âÉ (A ‚ü∂ G.obj B)
{Œ± : Type u} [group Œ±] (g : group_topology Œ±) : continuous (Œª (p : Œ± √ó Œ±), p.fst * p.snd)
{Œ± : Type u} (t : tactic Œ±) (msg : string) : tactic unit
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : tensor_product R A (polynomial R) ‚Üí‚Çó[R] polynomial A
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} : metric.bounded (s ‚à™ t) ‚Üî metric.bounded s ‚àß metric.bounded t
{X : Type u} [preorder X] {x y : X} (h : x ‚ü∂ y) : x ‚â§ y
(F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] : ‚Ü•‚ä• ‚âÉ‚Çê[F] F
{V : Type u} [quiver V] (r : V) [quiver.rooted_connected r] {a : V} (p : quiver.path r a) : (quiver.shortest_path r a).length ‚â§ p.length
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (a : R) : module (R ‚ß∏ submodule.span R {a}) ‚Ü•(submodule.torsion_by R M a)
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] {X Y : C} (f : X ‚ü∂ Y) : opposite.unop (category_theory.limits.kernel f.op) ‚âÖ category_theory.limits.cokernel f
 : multiset ‚Ñï+
{ùïú : Type u_1} [is_R_or_C ùïú] {m : Type u_5} {n : Type u_6} [fintype m] [decidable_eq m] [fintype n] [decidable_eq n] (A : matrix m n ùïú) : ‚áëmatrix.to_lin' A.conj_transpose = ‚áëlinear_map.adjoint (‚áëmatrix.to_lin' A)
{Œ± : Sort u} {Œ≤ : Sort v} {f : Œ± ‚Üí Œ≤} [inhabited Œ±] [subsingleton Œ≤] (hf : function.injective f) : unique Œ±
{n : ‚Ñï} {F : typevec (n + 1) ‚Üí Type u} [mvfunctor F] [q : mvqpf F] {Œ± Œ≤ : typevec n} (g : Œ±.arrow Œ≤) : mvqpf.cofix F Œ± ‚Üí mvqpf.cofix F Œ≤
{Œ± : Type u} [pseudo_metric_space Œ±] {x y : Œ±} : metric.inf_dist x {y} = has_dist.dist x y
 : tactic unit
{R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a)) : is_regular a ‚àß is_regular b
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {X : category_theory.simplicial_object C} (q n : ‚Ñï) : X.obj (opposite.op (simplex_category.mk n)) ‚ü∂ X.obj (opposite.op (simplex_category.mk (n + 1)))
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : has_quotient M (lie_submodule R L M)
{Œì : Type u_1} {Œì' : Type u_2} [inhabited Œì] [inhabited Œì'] (f : turing.pointed_map Œì Œì') (l : turing.list_blank Œì) : turing.list_blank Œì'
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [succ_order Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : monotone f) : pairwise (disjoint on Œª (n : Œ±), set.Ico (f n) (f (order.succ n)))
{R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (e : R ‚âÉ+* S) : R ‚Üí+ S
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.mul_pos_strict_mono Œ±] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b
(L : Type v) : Type v
{R : Type} [comm_ring R] {d : ‚Ñ§} : {r // r * r = ‚Üëd} ‚âÉ (‚Ñ§‚àöd ‚Üí+* R)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) : Type v
(L : first_order.language) : Type (max u v)
{Œ± : Type u_1} [has_lt Œ±] {a b : Œ±} : b < a ‚Üí ‚áëorder_dual.to_dual a < ‚áëorder_dual.to_dual b
(Œ± : Type u_1) [topological_space Œ±] (R : Type u_2) [semiring R] (M : Type u_3) [topological_space M] [add_comm_group M] [module R M] [has_continuous_const_smul R M] [topological_add_group M] : submodule R (Œ± ‚Üí M)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] (P : C) {Q R : C} (g : Q ‚ü∂ R) : (P ‚ü∂ Q) ‚Üí+ (P ‚ü∂ R)
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : K ‚Üí+* ratfunc K
{Œ± : Type u} [add_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_lt.lt] {a b : Œ±} : a < b ‚Üí a - b < 0
(R : Type u_1) [has_one R] [has_neg R] : cardinal.mk (quaternion R) = cardinal.mk R ^ 4
{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≤' : Type u_4} {Œ≥ : Type u_5} {Œ¥ : Type u_7} [decidable_eq Œ≤'] [decidable_eq Œ≥] [decidable_eq Œ¥] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤' ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≤'} {f' : Œ± ‚Üí Œ≤ ‚Üí Œ¥} {g' : Œ¥ ‚Üí Œ≥} (h_right_comm : ‚àÄ (a : Œ±) (b : Œ≤), f a (g b) = g' (f' a b)) : finset.image‚ÇÇ f s (finset.image g t) = finset.image g' (finset.image‚ÇÇ f' s t)
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) : hb.oangle y x = -hb.oangle x y
{Œ± : Type u} (s : string) (f : thunk Œ±) : Œ±
{f : ‚Ñù ‚Üí ‚Ñù} {a : ‚Ñù} (h : is_local_min f a) : deriv f a = 0
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {n : Type w} [nontrivial R] {B : bilin_form R M} {v : basis n R M} (h : B.is_Ortho ‚áëv) (hB : B.nondegenerate) (i : n) : ¬¨B.is_ortho (‚áëv i) (‚áëv i)
 : Type
(Œ± : Type u) : Type u
{Œπ : Type u_1} {R‚ÇÇ : Type u_7} {M‚ÇÇ : Type u_8} [comm_ring R‚ÇÇ] [add_comm_group M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ] [decidable_eq Œπ] (e : basis Œπ R‚ÇÇ M‚ÇÇ) {w : Œπ ‚Üí R‚ÇÇ} (hw : ‚àÄ (i : Œπ), is_unit (w i)) : e.to_matrix ‚áë(e.is_unit_smul hw) = matrix.diagonal w
(hs : list expr) : tactic (list (list expr))
 : category_theory.limits.preserves_limits_of_size (category_theory.forget CommGroup)
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] {F G : category_theory.oplax_functor B C} (Œ∑ : F ‚ü∂ G) : Œ∑ ‚â´ ùüô G ‚âÖ Œ∑
{Œ± : Type u_1} {Œπ : Type u_4} [normed_field Œ±] {E : Œπ ‚Üí Type u_2} [fintype Œπ] [Œ† (i : Œπ), semi_normed_group (E i)] [Œ† (i : Œπ), normed_space Œ± (E i)] : normed_space Œ± (Œ† (i : Œπ), E i)
(ùïú : Type u_1) {ùïú' : Type u_2} {E : Type u_3} {F : Type u_4} [comm_ring ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ùïú E] [add_comm_group F] [module ùïú F] [topological_space F] [topological_add_group F] [has_continuous_const_smul ùïú F] [comm_ring ùïú'] [has_scalar ùïú ùïú'] [module ùïú' E] [has_continuous_const_smul ùïú' E] [is_scalar_tower ùïú ùïú' E] [module ùïú' F] [has_continuous_const_smul ùïú' F] [is_scalar_tower ùïú ùïú' F] (p : formal_multilinear_series ùïú' E F) : formal_multilinear_series ùïú E F
(Œ± : Type u_1) (Œ≤ : Type u_2) : Type (max u_1 u_2)
{Œ± Œ≤ : Type} (tac : tactic Œ±) (finalizer : tactic Œ≤) : tactic Œ±
{R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [semiring R] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] [semi_normed_group E] [semi_normed_group E‚ÇÇ] [module R E] [module R‚ÇÇ E‚ÇÇ] (e : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) : E‚ÇÇ ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÇ‚ÇÅ] E
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L} : x ‚àà S ‚Üí -x ‚àà S
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_le Œ≤] [decidable_rel has_le.le] (f : Œ± ‚Üí Œ≤) (t : ordnode Œ±) : ordnode Œ≤
{a b : Prop} (h‚ÇÅ : a ‚Üí b) (h‚ÇÇ : ¬¨b) : ¬¨a
 : tactic unit
{Œ± : Type u_2} [bornology Œ±] {s : set Œ±} : bornology.is_cobounded s ‚Üí bornology.is_bounded s·∂ú
(Œ± : Type u) [has_add Œ±] [has_le Œ±] : Prop
 : Type
{k : Type u_1} {P‚ÇÅ : Type u_2} {P‚ÇÇ : Type u_3} {V‚ÇÅ : Type u_6} {V‚ÇÇ : Type u_7} [ring k] [add_comm_group V‚ÇÅ] [module k V‚ÇÅ] [add_torsor V‚ÇÅ P‚ÇÅ] [add_comm_group V‚ÇÇ] [module k V‚ÇÇ] [add_torsor V‚ÇÇ P‚ÇÇ] (e : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÇ ‚Üí P‚ÇÅ
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {L‚ÇÅ L‚ÇÇ : C ‚•§ D} {R‚ÇÅ R‚ÇÇ : D ‚•§ C} (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) (f : L‚ÇÇ ‚ü∂ L‚ÇÅ) [category_theory.is_iso f] : category_theory.is_iso (‚áë(category_theory.transfer_nat_trans_self adj‚ÇÅ adj‚ÇÇ) f)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {ùïú : Type u_3} {G : Type u_4} [is_R_or_C ùïú] [normed_space ùïú E] [normed_group G] [normed_space ùïú G] {f : E ‚Üí G} {s : set E} {C : nnreal} (hf : differentiable_on ùïú f s) (bound : ‚àÄ (x : E), x ‚àà s ‚Üí ‚à•fderiv_within ùïú f s x‚à•‚Çä ‚â§ C) (hs : convex ‚Ñù s) : lipschitz_on_with C f s
 : category_theory.abelian AddCommGroup
{Œ± : Type u_1} {m : measurable_space Œ±} {M : Type u_3} [add_comm_group M] [topological_space M] [topological_add_group M] (v w : measure_theory.vector_measure Œ± M) : measure_theory.vector_measure Œ± M
{p : ‚Ñï} [hp : fact (nat.prime p)] {n : ‚Ñï} {R : Type u_1} [comm_ring R] {m : ‚Ñï} (hm : n ‚â§ m) : truncated_witt_vector p m R ‚Üí+* truncated_witt_vector p n R
{M : Type u} [mul_one_class M] (a : M) : semiconj_by a 1 1
(ic : tactic.instance_cache) (a b c : expr) (na nb nc : ‚Ñö) : tactic (tactic.instance_cache √ó expr)
{X Y Z : Type u} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : category_theory.limits.pullback f g ‚âÖ category_theory.limits.types.pullback_obj f g
{Œ± : Type u} {Œ≤ : Type v} {Œ¥ : Type w} (f : Œ± ‚Üí Œ≤ ‚Üí Œ¥) : lazy_list Œ± ‚Üí lazy_list Œ≤ ‚Üí lazy_list Œ¥
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {F G : C ‚•§ D} (Œ± : F ‚ü∂ G) [‚àÄ (X : C), category_theory.mono (Œ±.app X)] : category_theory.mono Œ±
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M ‚Üí* N} (h : ‚àÄ (y : ‚Ü•S), is_unit (‚áëf ‚Üëy)) (y : ‚Ü•S) (w z : N) : w * ‚Üë(‚áë(is_unit.lift_right (f.restrict S) h) y)‚Åª¬π = z ‚Üî w = ‚áëf ‚Üëy * z
{Œ± : Type u_1} {Œ≤ : Type u_2} (m : Œ± ‚Üí Œ≤) {f : filter Œ±} (F : f.realizer) : (filter.map m f).realizer
(Œ± : Type) [has_zero Œ±] [has_one Œ±] [has_add Œ±] : parser Œ±
{K : Type u} [field K] (s : subfield K) : 1 ‚àà s
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (O : finset C) : ‚àÉ (S : C), ‚àÄ {X : C}, X ‚àà O ‚Üí nonempty (S ‚ü∂ X)
 : tactic.ring_exp.ex_type ‚Üí Type
{Œ± : Type u_1} {Œ≤ : Type u_2} {op : Œ≤ ‚Üí Œ≤ ‚Üí Œ≤} [hc : is_commutative Œ≤ op] [ha : is_associative Œ≤ op] {f : Œ± ‚Üí Œ≤} {b : Œ≤} {s : finset Œ±} {g : Œ± ‚Üí Œ≤} (hb : op b b = b) (p : Œ± ‚Üí Prop) [decidable_pred p] : finset.fold op b (Œª (i : Œ±), ite (p i) (f i) (g i)) s = op (finset.fold op b f (finset.filter p s)) (finset.fold op b g (finset.filter (Œª (i : Œ±), ¬¨p i) s))
{Œ± : Type u_2} [decidable_eq Œ±] [add_comm_monoid Œ±] : add_comm_monoid (finset Œ±)
{X : Type u_1} (to_two_pointing : two_pointing X) : Twop
{d : ‚Ñ§} (n : ‚Ñ§‚àöd) : ‚Ñ§
{K : Type u_1} [decidable_eq K] {Œì : K ‚Üí Type u_2} (k : K) (L : list (Œì k)) : list turing.TM2to1.Œì'
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] (E : Type u_2) [semi_normed_group E] [normed_space ùïú E] : E ‚ÜíL[ùïú] normed_space.dual ùïú (normed_space.dual ùïú E)
(F : Type u_5) (Œ± : out_param (Type u_6)) (Œ≤ : out_param (Type u_7)) [non_unital_non_assoc_semiring Œ±] [non_unital_non_assoc_semiring Œ≤] : Type (max u_5 u_6 u_7)
{Œ± : Type u} [omega_complete_partial_order Œ±] {Œ≤ Œ≥ : Type v} (f : Œ± ‚ÜíùíÑ part Œ≤) (g : Œ± ‚ÜíùíÑ Œ≤ ‚Üí part Œ≥) : Œ± ‚ÜíùíÑ part Œ≥
(Œ± : Sort u_1) : (true ‚Üí Œ±) ‚âÉ Œ±
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] (e‚ÇÅ e‚ÇÇ : topological_fiber_bundle.trivialization F proj) (b : B) (x : F) : F
{F : Type u_1} [field F] [fintype F] : is_square (-1) ‚Üî fintype.card F % 4 ‚â† 3
(f : ‚Ü•(measure_theory.Lp ‚ÑÇ 2 haar_circle)) : has_sum (Œª (i : ‚Ñ§), ‚áë(‚áë(fourier_series.repr) f) i ‚Ä¢ fourier_Lp 2 i) f
{K : Type u_1} {n : ‚Ñï} {g : generalized_continued_fraction K} [division_ring K] : g.convergents' (n + 1) = (g.squash_gcf n).convergents' n
{R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Œπ : Type u_1} (b : basis Œπ R M) (h : module.rank R M < cardinal.aleph_0) : nonempty (fintype Œπ)
(eval_fin : expr ‚Üí tactic.norm_fin.eval_fin_m (expr √ó expr)) : expr ‚Üí expr ‚Üí tactic.norm_fin.eval_fin_m (expr √ó expr)
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} (P : category_theory.mono_over Y) (f : X ‚ü∂ Y) (h : P.factors f) : X ‚ü∂ ‚ÜëP
{E : Type u} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {c : ‚ÑÇ} {r R : ‚Ñù} (h0 : 0 < r) (hle : r ‚â§ R) {f : ‚ÑÇ ‚Üí E} {s : set ‚ÑÇ} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R  metric.ball c r)) (hd : ‚àÄ (z : ‚ÑÇ), z ‚àà metric.ball c R  metric.closed_ball c r  s ‚Üí differentiable_at ‚ÑÇ f z) : ‚àÆ (z : ‚ÑÇ) in C(c, R), (z - c)‚Åª¬π ‚Ä¢ f z = ‚àÆ (z : ‚ÑÇ) in C(c, r), (z - c)‚Åª¬π ‚Ä¢ f z
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) (i : fin (n + 1)) : s.points_with_circumcenter (affine.simplex.points_with_circumcenter_index.point_index i) = s.points i
(Œ± : Type u) [topological_space Œ±] : Prop
{C : Type u‚ÇÅ} [category_theory.category C] (X : Type v‚ÇÅ) [category_theory.limits.has_products_of_shape X C] : category_theory.limits.has_coproducts_of_shape X C·µí·µñ
{Œ± : Type u_1} [topological_space Œ±] {Œ≥ : Type u_4} [linear_ordered_add_comm_monoid Œ≥] [topological_space Œ≥] [order_topology Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : lower_semicontinuous f) (hg : lower_semicontinuous g) (hcont : ‚àÄ (x : Œ±), continuous_at (Œª (p : Œ≥ √ó Œ≥), p.fst + p.snd) (f x, g x)) : lower_semicontinuous (Œª (z : Œ±), f z + g z)
{Œ≤ : Type u_2} [emetric_space Œ≤] {a : Œ≤} {r : ennreal} (x y : ‚Ü•(emetric.ball a r)) : has_edist.edist x.val y.val ‚â† ‚ä§
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {Œπ : Type u_1} [is_empty Œπ] (hV : finite_dimensional.finrank K V = 0) : basis Œπ K V
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) : P
{Œ± : Type u} [ordered_semiring Œ±] {Œ≤ : Type u_1} [has_zero Œ≤] [has_one Œ≤] [has_add Œ≤] [has_mul Œ≤] [has_scalar ‚Ñï Œ≤] [has_pow Œ≤ ‚Ñï] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ‚àÄ (x y : Œ≤), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) : ordered_semiring Œ≤
(n m : expr) : expr ‚Üí option (expr √ó expr)
(ùïú : Type u_1) {V : Type u_2} {V‚ÇÇ : Type u_4} (P : Type u_8) (P‚ÇÇ : Type u_9) [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V P] [normed_add_torsor V‚ÇÇ P‚ÇÇ] : Type (max u_2 u_4 u_8 u_9)
{M : Type u_5} {N : Type u_6} [add_zero_class M] [add_zero_class N] : M √ó N ‚âÉ+ N √ó M
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a b c : Œ±} : a + b ‚â§ c ‚Üí b ‚â§ -a + c
{C : Type u‚ÇÅ} [category_theory.category C] (G : category_theory.comonad C) : C ‚•§ G.coalgebra
{A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ} [category_theory.category A] [category_theory.category B] [category_theory.category C] {U : B ‚•§ C} {F : C ‚•§ B} (R : A ‚•§ B) (F' : C ‚•§ A) (adj‚ÇÅ : F ‚ä£ U) (adj‚ÇÇ : F' ‚ä£ R ‚ãô U) [category_theory.limits.has_reflexive_coequalizers A] (Y : B) : A
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} (H : is_totally_separated s) : is_totally_disconnected s
{Œ± : Type u_4} {Œ≤ : Type u_5} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) : Type (max u_4 u_5)
 : expr ‚Üí expr ‚Üí tactic (expr √ó bool √ó expr)
{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] {P Q : C} (f : P ‚ü∂ Q) : category_theory.epi (category_theory.abelian.factor_thru_image f)
(C : Type u) [category_theory.category C] : Type (max u v (w+1))
{ùïú : Type u_1} {E : Type u_2} [normed_field ùïú] [add_comm_group E] [module ùïú E] [topological_space E] [has_continuous_smul ùïú E] (x : E) : bornology.is_vonN_bounded ùïú {x}
{Œ± : Type u_1} [linear_ordered_field Œ±] {a b : Œ±} (ha : a < 0) (hb : b < 0) : 1 / a ‚â§ 1 / b ‚Üî b ‚â§ a
(h : expr) (hs : list expr) : tactic bool
(V : Type u) [quiver V] : setoid V
{Œ± : Type u_3} {Œ≤ : Type u_4} [has_sup Œ±] [has_bot Œ±] [has_sup Œ≤] [has_bot Œ≤] : has_coe_to_fun (sup_bot_hom Œ± Œ≤) (Œª (_x : sup_bot_hom Œ± Œ≤), Œ± ‚Üí Œ≤)
{C : Type u‚ÇÅ} [category_theory.category C] {P Q R S : C} {f : P ‚ü∂ Q} {g : P ‚ü∂ R} {h : Q ‚ü∂ S} {k : R ‚ü∂ S} [hr : category_theory.regular_mono k] (comm : f ‚â´ h = g ‚â´ k) (t : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk f g comm)) : category_theory.regular_mono f
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} [category_theory.limits.has_images C] : category_theory.mono_over.image ‚ä£ category_theory.mono_over.forget X
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Prop
{Œ± : Type u_1} (M : Type u_2) (R : Type u_5) [semiring R] [add_comm_monoid M] [module R M] (s : set Œ±) : submodule R (Œ± ‚Üí‚ÇÄ M)
 : tactic.transparency ‚Üí expr ‚Üí bool ‚Üí tactic hinst_lemma
 : simplex_category ‚•§ sSet
{A : Type u_3} [category_theory.category A] [category_theory.abelian A] (X : category_theory.simplicial_object A) : (algebraic_topology.normalized_Moore_complex A).obj X ‚ü∂ (algebraic_topology.alternating_face_map_complex A).obj X
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddGroup) (x : Œ£ (j : J), ‚Ü•(F.obj j)) : ‚Ü•(AddGroup.filtered_colimits.G F)
{Œ± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [add_comm_monoid N] {s : finset Œ±} {f : Œ± ‚Üí M} {g : Œ± ‚Üí M ‚Üí N} (hf : ‚àÄ (a : Œ±), f a ‚â† 0 ‚Üí a ‚àà s) (hg : ‚àÄ (a : Œ±), g a 0 = 0) : (finsupp.on_finset s f hf).sum g = s.sum (Œª (a : Œ±), g a (f a))
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ‚Ñù P) : P
 : pos_num ‚Üí ‚Ñï ‚Üí list ‚Ñï
{Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [add_group Œ±] (h : function.periodic f c) (x : Œ± ‚ß∏ add_subgroup.zmultiples c) : Œ≤
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] (F : J ‚•§ algebraic_geometry.PresheafedSpace C) : J ‚•§ (Top.presheaf C (category_theory.limits.colimit (F ‚ãô algebraic_geometry.PresheafedSpace.forget C)))·µí·µñ
{Œ± : Type u_1} [fintype Œ±] [decidable_eq Œ±] (f : equiv.perm Œ±) (hf : f.is_cycle) : cycle Œ±
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (c : category_theory.limits.cocone F.op) : category_theory.limits.cone F
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] {s : set Œ±} {t : set Œ≤} : is_open (s √óÀ¢ t) ‚Üî is_open s ‚àß is_open t ‚à® s = ‚àÖ ‚à® t = ‚àÖ
(p : ‚Ñï) : Prop
(R : Type u) [comm_ring R] : Top.sheaf (Type u) (algebraic_geometry.prime_spectrum.Top R)
{Œ± : Type u_1} {Œπ : Type u_2} {Œ≤ : Type u_3} {S : Œπ ‚Üí set Œ±} {f : Œ† (i : Œπ), ‚Ü•(S i) ‚Üí Œ≤} {hf : ‚àÄ (i j : Œπ) (x : Œ±) (hxi : x ‚àà S i) (hxj : x ‚àà S j), f i ‚ü®x, hxi‚ü© = f j ‚ü®x, hxj‚ü©} {T : set Œ±} {hT : T ‚äÜ set.Union S} (c : ‚Ü•T) (ci : Œ† (i : Œπ), ‚Ü•(S i)) (hci : ‚àÄ (i : Œπ), ‚Üë(ci i) = ‚Üëc) (cŒ≤ : Œ≤) (h : ‚àÄ (i : Œπ), f i (ci i) = cŒ≤) : set.Union_lift S f hf T hT c = cŒ≤
{G : Type u_1} [add_group G] {k : set G} {p : G ‚Üí Prop} {x : G} (h : x ‚àà add_subgroup.closure k) (Hk : ‚àÄ (x : G), x ‚àà k ‚Üí p x) (H1 : p 0) (Hmul : ‚àÄ (x y : G), p x ‚Üí p y ‚Üí p (x + y)) (Hinv : ‚àÄ (x : G), p x ‚Üí p (-x)) : p x
(R : Type u_1) {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (r : A) : A ‚Üí‚Çó[R] A
{X : Top} (F : Top.presheaf (Type v) X) : F.is_sheaf ‚Üî F.is_sheaf_unique_gluing
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.monoidal_category C] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) [category_theory.is_equivalence F.to_lax_monoidal_functor.to_functor] [category_theory.rigid_category D] : category_theory.rigid_category C
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) : category_theory.is_iso (category_theory.limits.cokernel.œÄ 0)
{Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≥ : Type u_5} [has_sup Œ±] [has_sup Œ≤] [has_sup Œ≥] (f : sup_hom Œ≤ Œ≥) (g : sup_hom Œ± Œ≤) : sup_hom Œ± Œ≥
 : level ‚Üí bool
{Œ± : Type u_1} {Œπ : Type u_4} (s : Œπ ‚Üí set Œ±) : (‚ãÇ (i : Œπ), s i) = ‚ãÇ (t : finset Œπ) (i : Œπ) (H : i ‚àà t), s i
{Œ± : Type u_1} [fintype Œ±] {P : Œ± ‚Üí Prop} [decidable_pred P] (h : ‚àÉ (a : Œ±), P a) : trunc (Œ£' (a : Œ±), P a)
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] {K : nnreal} {f : Œ± ‚Üí Œ≤} (hf : lipschitz_with K f) : uniform_continuous f
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] {F : Type u_2} [normed_group F] [normed_space ‚Ñù F] [finite_dimensional ‚Ñù F] {s : set E} {f : E ‚Üí F} {f' : E ‚âÉL[‚Ñù] F} {c : nnreal} (hf : approximates_linear_on f ‚Üëf' s c) (hc : subsingleton E ‚à® lipschitz_extension_constant F * c < ‚à•‚Üë(f'.symm)‚à•‚Çä‚Åª¬π) : ‚àÉ (g : E ‚âÉ‚Çú F), set.eq_on f ‚áëg s
(Œ± : Type u) (r : Œ± ‚Üí Œ± ‚Üí Prop) [s : is_total_preorder Œ± r] : is_preorder Œ± r
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {A : Type u_1} [comm_semiring k] [semiring A] [algebra k A] [monoid G] : A ‚Üí‚Çê[k] monoid_algebra A G
{G : Type u_1} [category_theory.groupoid G] [category_theory.is_connected G] [is_free_groupoid G] (r : G) : is_free_group (category_theory.End r)
{R : Type u_1} [comm_ring R] (v w : fin 3 ‚Üí R) : -‚áë(‚áëcross_product v) w = ‚áë(‚áëcross_product w) v
(p : ‚Ñï) [p_prime : fact (nat.prime p)] {n‚ÇÅ n‚ÇÇ d‚ÇÅ d‚ÇÇ : ‚Ñ§} (hn‚ÇÅ : n‚ÇÅ ‚â† 0) (hn‚ÇÇ : n‚ÇÇ ‚â† 0) (hd‚ÇÅ : d‚ÇÅ ‚â† 0) (hd‚ÇÇ : d‚ÇÇ ‚â† 0) : padic_val_rat p (rat.mk n‚ÇÅ d‚ÇÅ) ‚â§ padic_val_rat p (rat.mk n‚ÇÇ d‚ÇÇ) ‚Üî ‚àÄ (n : ‚Ñï), ‚Üëp ^ n ‚à£ n‚ÇÅ * d‚ÇÇ ‚Üí ‚Üëp ^ n ‚à£ n‚ÇÇ * d‚ÇÅ
{R : Type u} [comm_semiring R] [star_ring R] (x : R) : ‚áë(star_ring_end R) (‚áë(star_ring_end R) x) = x
{X Y Z : algebraic_geometry.Scheme} (ùí∞ : X.open_cover) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [‚àÄ (i : ùí∞.J), category_theory.limits.has_pullback (ùí∞.map i ‚â´ f) g] (i j : ùí∞.J) : algebraic_geometry.Scheme
{G : Type u_1} [group G] (s : set G) : set G
{P : Type u_2} [metric_space P] (ps : set P) : Prop
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommRing) : setoid (CommRing.colimits.prequotient F)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {M N : Mon_ C} (f : M.X ‚âÖ N.X) (one_f : M.one ‚â´ f.hom = N.one) (mul_f : M.mul ‚â´ f.hom = (f.hom ‚äó f.hom) ‚â´ N.mul) : M ‚âÖ N
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [finite_dimensional k V] {p : Œπ ‚Üí P} (hi : affine_independent k p) : fintype Œπ
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {s : set E} {c : nnreal} : approximates_linear_on f f' s c ‚Üí lipschitz_on_with c (f - ‚áëf') s
{Œπ : Type u_1} (n : ‚Ñï) (w : ‚àÄ (s : finset Œπ), s.card ‚â§ n) : fintype Œπ
(R : Type u_2) {M : Type u_5} {M‚ÇÇ : Type u_6} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid M‚ÇÇ] [has_scalar R M‚ÇÇ] (f : M‚ÇÇ ‚Üí+ M) (hf : function.injective ‚áëf) (smul : ‚àÄ (c : R) (x : M‚ÇÇ), ‚áëf (c ‚Ä¢ x) = c ‚Ä¢ ‚áëf x) : module R M‚ÇÇ
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {n : with_top ‚Ñï} (h : cont_diff_on ùïú n f s) (hs : unique_diff_on ùïú s) : has_ftaylor_series_up_to_on n f (ftaylor_series_within ùïú f s) s
(R : Type u_1) [comm_ring R] {C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] [category_theory.preadditive D] [category_theory.linear R D] (F : C ‚•§ D) : category_theory.Free.embedding R C ‚ãô category_theory.Free.lift R F ‚âÖ F
{Œ± : Type u_1} (L : list (list Œ±)) {i j : ‚Ñï} (hi : i < L.length) (hj : j < (L.nth_le i hi).length) : (list.take i (list.map list.length L)).sum + j < L.join.length
(p : ‚Ñï) [p_prime : fact (nat.prime p)] {q r : ‚Ñö} (hq : q ‚â† 0) (hr : r ‚â† 0) : padic_val_rat p (q * r) = padic_val_rat p q + padic_val_rat p r
(p : ‚Ñï) {n : ‚Ñï} {R : Type u_1} (x : fin n ‚Üí R) : truncated_witt_vector p n R
(k : Type u_1) {V1 : Type u_2} (P1 : Type u_3) {V2 : Type u_4} (P2 : Type u_5) [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] : Type (max u_2 u_3 u_4 u_5)
(R : Type u_3) [comm_semiring R] {M : Type u_7} {N‚Çó : Type u_12} (P‚Çó : Type u_13) [add_comm_monoid M] [add_comm_monoid N‚Çó] [add_comm_monoid P‚Çó] [module R M] [module R N‚Çó] [module R P‚Çó] (f : M ‚Üí‚Çó[R] N‚Çó) : (N‚Çó ‚Üí‚Çó[R] P‚Çó) ‚Üí‚Çó[R] M ‚Üí‚Çó[R] P‚Çó
(Œ± : expr) : ‚Ñï ‚Üí tactic expr
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} {Œ≤ : Type u} (g‚ÇÄ : Œ≤ ‚Üí P.A) (g‚ÇÅ : Œ† (b : Œ≤), (P.drop.B (g‚ÇÄ b)).arrow Œ±) (g‚ÇÇ : Œ† (b : Œ≤), P.last.B (g‚ÇÄ b) ‚Üí Œ≤) : Œ≤ ‚Üí P.M Œ±
{Œì‚ÇÄ : Type u_1} [linear_ordered_comm_group_with_zero Œì‚ÇÄ] (Œ≥ : Œì‚ÇÄ) (h : Œ≥ ‚â† 0) : {Œ≥} ‚àà nhds Œ≥
 : expr_map expr_set ‚Üí expr ‚Üí tactic (expr_set √ó expr_map expr_set)
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [is_alg_closed K] [finite_dimensional K V] [nontrivial V] (f : module.End K V) : ‚àÉ (c : K), f.has_eigenvalue c
 : tactic.itauto.prop ‚Üí format
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [category_theory.limits.has_pushout f g] : category_theory.limits.pushout f g ‚âÖ category_theory.limits.pushout g f
{X : Type u} [metric_space X] [compact_space X] [nonempty X] {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] : Gromov_Hausdorff.to_GH_space X = Gromov_Hausdorff.to_GH_space Y ‚Üî nonempty (X ‚âÉ·µ¢ Y)
(Œ± : Type u_1) [fintype Œ±] : ‚Ñï
{Œ± : Type u} : topological_space.induced has_pure.pure ultrafilter.topological_space = ‚ä•
(Œ± : Type u_2) [fintype Œ±] [distrib_lattice Œ±] [bounded_order Œ±] : complete_distrib_lattice Œ±
{n : Type u} [decidable_eq n] [fintype n] {Œ± : Type v} [comm_ring Œ±] [star_ring Œ±] (A : ‚Ü•(matrix.unitary_group n Œ±)) : (n ‚Üí Œ±) ‚Üí‚Çó[Œ±] n ‚Üí Œ±
{Œ± : Type u} {Œ≤ : Type v} [add_semigroup Œ≤] (f : Œ± ‚Üí Œ≤) : Œ± ‚Üí list Œ± ‚Üí Œ≤
{key value : Type} [inhabited value] (m : native.rb_map key value) (k : key) : value
(p : ‚Ñï) : ‚Üë(mersenne p) = 0
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {X Y Z : C} [category_theory.has_right_dual X] [category_theory.has_right_dual Y] [category_theory.has_right_dual Z] {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g)·òÅ = g·òÅ ‚â´ f·òÅ
{R : Type u} [semiring R] (p : polynomial R) : R
(L : first_order.language) (Œ± : Type u') : Type (max u v u')
(red : interactive.parse (optional (lean.parser.tk "!"))) (SOP : interactive.parse tactic.interactive.ring.mode) : conv unit
{Œ± : Type u} [has_mul Œ±] : Œ± ‚Üí‚Çô* with_one Œ±
{Œ± : Type u} [pseudo_emetric_space Œ±] : isometry id
{Œ± : Type u_1} : list (lists Œ±) ‚Üí lists' Œ± bool.tt
{Œ± : Type u_1} [partial_order Œ±] (c : closure_operator Œ±) : set Œ±
{C : Type u} [category_theory.category C] (T : category_theory.monad C) : C ‚•§ category_theory.kleisli T
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [comm_monoid Œ≤] {s : finset Œ±} {t : finset Œ≥} {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ≤} (i : Œ† (a : Œ±), a ‚àà s ‚Üí Œ≥) (hi : ‚àÄ (a : Œ±) (ha : a ‚àà s), i a ha ‚àà t) (h : ‚àÄ (a : Œ±) (ha : a ‚àà s), f a = g (i a ha)) (j : Œ† (a : Œ≥), a ‚àà t ‚Üí Œ±) (hj : ‚àÄ (a : Œ≥) (ha : a ‚àà t), j a ha ‚àà s) (left_inv : ‚àÄ (a : Œ±) (ha : a ‚àà s), j (i a ha) _ = a) (right_inv : ‚àÄ (a : Œ≥) (ha : a ‚àà t), i (j a ha) _ = a) : s.prod (Œª (x : Œ±), f x) = t.prod (Œª (x : Œ≥), g x)
{K : Type u_1} {V : Type u_2} [field K] [ring V] [algebra K V] {s : subalgebra K V} (h : finite_dimensional K ‚Ü•(s.to_submodule)) : finite_dimensional K ‚Ü•s
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {E : Type u‚ÇÉ} [category_theory.category E] (F : C ‚•§ D ‚•§ E) : category_theory.thin_skeleton C ‚•§ category_theory.thin_skeleton D ‚•§ category_theory.thin_skeleton E
{Œ± : Type u_1} (l : list Œ±) (c : composition l.length) : list.map list.length (l.split_wrt_composition c) = c.blocks
{Œ≤ : Type u_1} [add_comm_group Œ≤] (b : Œ≤) (V : Type u_2) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : homological_complex V (complex_shape.up' b) ‚•§ category_theory.differential_object (category_theory.graded_object_with_shift b V)
(u : pnat.xgcd_type) (hr : u.r ‚â† 0) : sizeof u.step < sizeof u
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : Œ± ‚Üí Œ± ‚Üí Prop) (f : filter Œ≤) (u : Œ≤ ‚Üí Œ±) : Prop
(A : Type u_4) (K : Type u_5) (C : Type u_6) [comm_ring A] [is_domain A] [field K] [algebra A K] [is_fraction_ring A K] [comm_ring C] [algebra A C] [algebra K C] [is_scalar_tower A K C] {x : C} : is_algebraic A x ‚Üî is_algebraic K x
{k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k ‚Üí E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : ‚áë(affine_map.line_map (f a) (f b)) r < f (‚áë(affine_map.line_map a b) r) ‚Üî slope f (‚áë(affine_map.line_map a b) r) b < slope f a b
(D : algebraic_geometry.LocallyRingedSpace.glue_data) : D.to_glue_data.glued.to_SheafedSpace ‚âÖ D.to_SheafedSpace_glue_data.to_glue_data.glued
{H : Type u} {M : Type u_2} [topological_space H] (c : charted_space_core H M) : topological_space M
(Œ± : Type) [has_zero Œ±] [has_one Œ±] [has_add Œ±] : parser Œ±
 : vm_obj ‚Üí expr
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) (X Y : C) [category_theory.limits.has_binary_coproduct X Y] [category_theory.limits.preserves_colimit (category_theory.limits.pair X Y) G] : category_theory.limits.is_colimit (category_theory.limits.binary_cofan.mk (G.map category_theory.limits.coprod.inl) (G.map category_theory.limits.coprod.inr))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} {Œπ‚ÇÇ : Type u_5} (s‚ÇÇ : finset Œπ‚ÇÇ) (e : Œπ‚ÇÇ ‚Ü™ Œπ) (p : Œπ ‚Üí P) : finset.centroid k (finset.map e s‚ÇÇ) p = finset.centroid k s‚ÇÇ (p ‚àò ‚áëe)
{G : Type u} [monoid G] (H : submonoid G) (x : ‚Ü•H) : is_of_fin_order x ‚Üî is_of_fin_order ‚Üëx
{Œ± : Type u_1} {Œ≤ : Type u_2} [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±] [topological_space Œ≤] {s : set Œ≤} {f : Œ≤ ‚Üí Œ±} (hf : continuous_on f s) (hsc : is_closed s) {x‚ÇÄ : Œ≤} (h‚ÇÄ : x‚ÇÄ ‚àà s) (hc : ‚àÄ·∂† (x : Œ≤) in filter.cocompact Œ≤ ‚äì filter.principal s, f x‚ÇÄ ‚â§ f x) : ‚àÉ (x : Œ≤) (H : x ‚àà s), ‚àÄ (y : Œ≤), y ‚àà s ‚Üí f x ‚â§ f y
{C : Type u} [category_theory.category C] (A : C) [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] : C ‚•§ C
 : Type
(c : name) (type val : expr) (is_lemma : bool) : tactic expr
{Œ± : Type u_1} {c : set (set Œ±)} (hu : ‚ãÉ‚ÇÄc = set.univ) (H : c.pairwise_disjoint id) (a : Œ±) : ‚àÉ! (b : set Œ±) (H : b ‚àà c), a ‚àà b
{R : Type u_1} [comm_semiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] (f : M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] P) : tensor_product R M N ‚Üí‚Çó[R] P
{G : Type u} {x y : G} [fintype G] [group G] (h : order_of x = order_of y) : ‚Ü•‚Üë(subgroup.zpowers x) ‚âÉ ‚Ü•‚Üë(subgroup.zpowers y)
{G : Type u_4} [normed_group G] [normed_space ‚Ñù G] {s : set G} (conv : convex ‚Ñù s) (hs : (interior s).nonempty) {x : G} (hx : x ‚àà closure s) : unique_diff_within_at ‚Ñù s x
{a k : ‚Ñï} (h0 : 0 < a) (h1 : a < k) (n : ‚Ñï) : (k + n).prime_counting' ‚â§ k.prime_counting' + a.totient * (n / a + 1)
{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_3} [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] (f : normed_group_hom V‚ÇÅ V‚ÇÇ) : ‚Ñù
{n : Type u_4} {Œ± : Type u_5} [fintype n] [semi_normed_ring Œ±] [norm_one_class Œ±] [decidable_eq n] [nonempty n] : norm_one_class (matrix n n Œ±)
(x y : ‚Ñù) [fact (x < y)] : local_homeomorph ‚Ü•(set.Icc x y) (euclidean_half_space 1)
{R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} [comm_semiring R] [semiring A‚ÇÅ] [semiring A‚ÇÇ] [algebra R A‚ÇÅ] [algebra R A‚ÇÇ] (l : A‚ÇÅ ‚âÉ‚Çó[R] A‚ÇÇ) (map_mul : ‚àÄ (x y : A‚ÇÅ), ‚áël (x * y) = ‚áël x * ‚áël y) (commutes : ‚àÄ (r : R), ‚áël (‚áë(algebra_map R A‚ÇÅ) r) = ‚áë(algebra_map R A‚ÇÇ) r) : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ
{n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) : invertible A ‚âÉ invertible A.det
{cb : char_buffer} {n n' val : ‚Ñï} (h : parser.nat cb n = parse_result.done n' val) (hn : n' ‚â§ buffer.size cb) (k : ‚Ñï) (hk : k < n') : n ‚â§ k ‚Üí '0' ‚â§ buffer.read cb ‚ü®k, _‚ü© ‚àß buffer.read cb ‚ü®k, _‚ü© ‚â§ '9'
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C·µí·µñ) (F : C ‚•§ D) [category_theory.limits.preserves_limit K.left_op F] : category_theory.limits.preserves_colimit K F.op
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.monoidal_category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) : ùüô_ D ‚âÖ F.to_lax_monoidal_functor.to_functor.obj (ùüô_ C)
(hs : name_set) : tactic (‚Ñï √ó list expr)
{C : Type u} [category_theory.category C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÉ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÑ : X‚ÇÉ ‚ü∂ Y‚ÇÇ) [category_theory.limits.has_pullback f‚ÇÅ f‚ÇÇ] [category_theory.limits.has_pullback f‚ÇÉ f‚ÇÑ] [category_theory.limits.has_pullback f‚ÇÅ (category_theory.limits.pullback.fst ‚â´ f‚ÇÇ)] : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (category_theory.limits.pullback.lift category_theory.limits.pullback.fst (category_theory.limits.pullback.snd ‚â´ category_theory.limits.pullback.fst) _) category_theory.limits.pullback.snd _)
{o : Type u_4} (m' : o ‚Üí Type u_7) (n' : o ‚Üí Type u_8) (Œ± : Type u_12) [add_zero_class Œ±] : matrix (Œ£ (i : o), m' i) (Œ£ (i : o), n' i) Œ± ‚Üí+ Œ† (i : o), matrix (m' i) (n' i) Œ±
{Œ± : Type u_1} {r‚ÇÅ r‚ÇÇ : setoid Œ±} : r‚ÇÅ = r‚ÇÇ ‚Üî ‚àÄ (x : Œ±), {y : Œ± | r‚ÇÅ.rel x y} = {y : Œ± | r‚ÇÇ.rel x y}
(R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] : module.rank R M < cardinal.aleph_0
{Œ± : Type u} : computation (wseq Œ±) ‚Üí wseq Œ±
{Œ± : Type u_3} [ordered_semiring Œ±] {n : ‚Ñï} (hn : 1 ‚â§ n) : filter.tendsto (Œª (x : Œ±), x ^ n) filter.at_top filter.at_top
{R : Type u} [ring R] {Œ± : Type u_1} [has_zero Œ±] [smul_with_zero R Œ±] (S : subring R) : smul_with_zero ‚Ü•S Œ±
{p : ‚Ñï} [fact (nat.prime p)] {f : padic_seq p} (hf : ¬¨f ‚âà 0) : ‚Ñï
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : ‚Ñï
{p : ‚Ñï} [hp : fact (nat.prime p)] : ‚Ñö_[p] ‚Üí ‚Ñö
(R : Type u) {M : Type v} [semiring R] [add_comm_monoid M] [module R M] : M ‚âÉ‚Çó[R] M·µê·µí·µñ
(F : Type u ‚Üí Type u) [applicative F] [is_lawful_applicative F] : applicative_transformation id F
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ‚Ñ§] (X Y : category_theory.differential_object C) : Type v
{Œ± : Type u_1} {Œπ' : Sort u_5} (s : Œπ' ‚Üí set Œ±) : (‚ãÉ (i : Œπ'), s i) = ‚ãÉ (t : finset (plift Œπ')) (i : plift Œπ') (H : i ‚àà t), s i.down
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ‚ü∂ Y} (h : f = g) : category_theory.limits.is_limit (category_theory.limits.id_fork h)
{Œ± : Type u} [decidable_eq Œ±] (i j : Œ±) : setoid (equiv.perm Œ±)
{Œ± : Type u_1} [topological_space Œ±] : (fin 2 ‚Üí Œ±) ‚âÉ‚Çú Œ± √ó Œ±
{R : Type u_2} {Œì‚ÇÄ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] {S : Type u_1} [ring S] (f : S ‚Üí+* R) (v : valuation R Œì‚ÇÄ) : valuation S Œì‚ÇÄ
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [has_one M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñï] [has_inv M‚ÇÅ] [has_div M‚ÇÅ] [has_pow M‚ÇÅ ‚Ñ§] [div_inv_monoid M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) (inv : ‚àÄ (x : M‚ÇÅ), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : M‚ÇÅ), f (x / y) = f x / f y) (npow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : M‚ÇÅ) (n : ‚Ñ§), f (x ^ n) = f x ^ n) : div_inv_monoid M‚ÇÅ
{R : Type u_1} [add_comm_group R] {f g : ‚Ñï ‚Üí R} : (‚àÄ (n : ‚Ñï), 0 < n ‚Üí n.divisors.sum (Œª (i : ‚Ñï), f i) = g n) ‚Üî ‚àÄ (n : ‚Ñï), 0 < n ‚Üí n.divisors_antidiagonal.sum (Œª (x : ‚Ñï √ó ‚Ñï), ‚áënat.arithmetic_function.moebius x.fst ‚Ä¢ g x.snd) = f n
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] (P Q : C) : (category_theory.limits.biprod.braiding P Q).hom ‚â´ (category_theory.limits.biprod.braiding Q P).hom = ùüô (P ‚äû Q)
{R : Type u} [semiring R] {M : Type u_1} [ordered_cancel_add_comm_monoid M] [module R M] (S : submodule R M) : ordered_cancel_add_comm_monoid ‚Ü•S
 : vm_obj ‚Üí vm string
{f : ‚ÑÇ ‚Üí ‚ÑÇ} {c : ‚ÑÇ} {R : ‚Ñù} (hd : differentiable_on ‚ÑÇ f (metric.ball c R)) (h_maps : set.maps_to f (metric.ball c R) (metric.ball c R)) (hc : f c = c) (h‚ÇÄ : 0 < R) : complex.abs (deriv f c) ‚â§ 1
{R : Type u} [semiring R] {S : Type v} [semiring S] (f : R ‚Üí+* S) (n : ‚Ñï) : polynomial.X ^ n ‚àà polynomial.lifts f
{S : Type u_1} [linear_ordered_comm_ring S] {R : Type u_2} [semiring R] (abv : R ‚Üí S) [is_absolute_value abv] [nontrivial R] : R ‚Üí*‚ÇÄ S
{C : Type u‚ÇÅ} [category_theory.category C] (T : category_theory.monad C) {A B : T.algebra} (f : A ‚ü∂ B) [category_theory.is_iso f.f] : category_theory.is_iso f
{R : Type u} [comm_ring R] {p q : polynomial R} (hmonic : q.monic) (hdegree : q.degree ‚â§ p.degree) : (p /‚Çò q).leading_coeff = p.leading_coeff
(R : Type u_2) (M : Type u_3) (N : Type u_4) [comm_semiring R] [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : tensor_product R (module.dual R M) N ‚Üí‚Çó[R] M ‚Üí‚Çó[R] N
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} (f : J ‚Üí (X ‚ü∂ Y)) [category_theory.limits.has_wide_coequalizer f] [nonempty J] : category_theory.limits.is_colimit (category_theory.limits.cotrident.of_œÄ (category_theory.limits.wide_coequalizer.œÄ f) _)
{R : Type u} [non_assoc_semiring R] {s : set R} : s ‚äÜ ‚Üë(subsemiring.closure s)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) [category_theory.is_filtered J] : AddMon
(z : ‚Ñ§) : linarith.sum
 : Type
{Œπ : Type u_1} {ùïú : Type u_3} [is_R_or_C ùïú] {E : Type u_4} [inner_product_space ùïú E] [fintype Œπ] (v : basis Œπ ùïú E) (hv : orthonormal ùïú ‚áëv) : orthonormal_basis Œπ ùïú E
{V : Type u} {G : simple_graph V} {G' : G.subgraph} (v : ‚Ü•(G'.verts)) [decidable_rel G'.adj] [fintype ‚Ü•(G.neighbor_set ‚Üëv)] : fintype ‚Ü•(G'.neighbor_set ‚Üëv)
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] (F : J ‚•§ algebraic_geometry.PresheafedSpace C) (U : topological_space.opens ‚Ü•((category_theory.limits.colimit F).carrier)) : J·µí·µñ ‚•§ C
(Œ± : Type u) : bool ‚Üí Type u
{p a b : ‚Ñï} (hab : a.coprime b) (hpa : p ‚àà a.factors) : ‚áë((a * b).factorization) p = ‚áë(a.factorization) p
{m n : ‚Ñï+} : m.factor_multiset ‚â§ n.factor_multiset ‚Üî m ‚à£ n
 : ennreal ‚âÉ·µê nnreal ‚äï unit
{M‚ÇÄ : Type u_1} [mul_zero_class M‚ÇÄ] [no_zero_divisors M‚ÇÄ] {a b : M‚ÇÄ} : a * b = 0 ‚Üî a = 0 ‚à® b = 0
{ùïú : Type u_3} {E : Type u_4} [semi_normed_ring ùïú] [add_comm_group E] [module ùïú E] (p : seminorm ùïú E) (x y : E) : ‚áëp y ‚â§ ‚áëp x + ‚áëp (x - y)
(n : expr) : tactic expr
{Œ± : Type u_1} [decidable_eq Œ±] [has_le Œ±] [bounded_order Œ±] [is_simple_order Œ±] : Œ± ‚âÉ bool
{G : Type u_1} [group G] (s : set G) : Prop
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x : V) {r‚ÇÅ r‚ÇÇ : ‚Ñù} (hr‚ÇÅ : 0 ‚â§ r‚ÇÅ) (hr‚ÇÇ : 0 ‚â§ r‚ÇÇ) : hb.oangle (r‚ÇÅ ‚Ä¢ x) (r‚ÇÇ ‚Ä¢ x) = 0
(n : ‚Ñï) : Type
(p : ‚Ñï) [hp : fact (nat.prime p)] (n : ‚Ñï) : mv_polynomial (fin 2 √ó ‚Ñï) ‚Ñ§
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {G : Type u_4} [normed_group G] [normed_space ùïú G] {s : set E} {f : E ‚Üí F} {x : E} {n : with_top ‚Ñï} (e : F ‚âÉL[ùïú] G) : cont_diff_within_at ùïú n (‚áëe ‚àò f) s x ‚Üî cont_diff_within_at ùïú n f s x
 : linter
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] (J : category_theory.grothendieck_topology C) (P : C·µí·µñ ‚•§ A) {X : C} (S : J.cover X) (hP : category_theory.presheaf.is_sheaf J P) : category_theory.limits.is_limit (S.multifork P)
(x : ‚Ñù) : real.sinh (real.arsinh x) = x
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F G : J ‚•§ C} [category_theory.limits.has_limit F] [category_theory.limits.has_limit G] (Œ± : F ‚ü∂ G) : category_theory.limits.limit F ‚ü∂ category_theory.limits.limit G
{G : Type u_1} [group G] (H K : subgroup G) (a : G) : doset.quotient ‚ÜëH ‚ÜëK
{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {V : Œπ ‚Üí submodule ùïú E} (hV : orthogonal_family ùïú (Œª (i : Œπ), (V i).subtype‚Çó·µ¢)) : complete_lattice.independent V
(p : ‚Ñï) : ‚Ñï ‚Üí ‚Ñ§
(D : algebraic_geometry.Scheme.glue_data) (i : D.to_glue_data.J) : D.to_glue_data.U i ‚ü∂ D.glued
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_3} (s : finset Œπ) (f : Œπ ‚Üí E) (x : E) : has_inner.inner (s.sum (Œª (i : Œπ), f i)) x = s.sum (Œª (i : Œπ), has_inner.inner (f i) x)
{Œ± : Type u} (B : filter_basis (Œ± √ó Œ±)) (refl : ‚àÄ (r : set (Œ± √ó Œ±)), r ‚àà B ‚Üí ‚àÄ (x : Œ±), (x, x) ‚àà r) (symm : ‚àÄ (r : set (Œ± √ó Œ±)), r ‚àà B ‚Üí (‚àÉ (t : set (Œ± √ó Œ±)) (H : t ‚àà B), t ‚äÜ prod.swap ‚Åª¬π' r)) (comp : ‚àÄ (r : set (Œ± √ó Œ±)), r ‚àà B ‚Üí (‚àÉ (t : set (Œ± √ó Œ±)) (H : t ‚àà B), comp_rel t t ‚äÜ r)) : uniform_space.core Œ±
 : tactic unit
{G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {H : Type u_2} [group H] [topological_space H] [topological_group H] (f : G ‚Üí* H) (emb : open_embedding ‚áëf) : nonarchimedean_group H
{R : Type u_1} {S : Type u_2} {M : Type u_3} [add_monoid R] [add_action R M] [add_monoid S] [has_vadd S M] (f : R ‚Üí+ S) (hf : function.surjective ‚áëf) (hsmul : ‚àÄ (c : R) (x : M), ‚áëf c +·µ• x = c +·µ• x) : add_action S M
(_x : interactive.parse (lean.parser.tk "fail!")) (s : string) : lean.parser pexpr
{p : ‚Ñï} {z : ‚Ñ§} : padic_val_rat p ‚Üëz = ‚Üë(padic_val_int p z)
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (s : submodule R M) : s.fg ‚Üî complete_lattice.is_compact_element s
(G : Type u_1) [group G] : Prop
{S : Type u_4} (H : S) {G : Type u_1} [linear_ordered_comm_group G] [set_like S G] [subgroup_class S G] : linear_ordered_comm_group ‚Ü•H
{Œ± : Type u_1} [add_right_cancel_semigroup Œ±] (a : Œ±) : complex_shape Œ±
{Œ± : Type u_1} [mul_one_class Œ±] [preorder Œ±] [covariant_class Œ± Œ± (function.swap has_mul.mul) has_le.le] {a b : Œ±} (ha : a < 1) (hb : b < 1) : a * b < 1
{Œπ : Type u} {Œ≤ : Œπ ‚Üí Type v} [dec : decidable_eq Œπ] [Œ† (i : Œπ), add_comm_monoid (Œ≤ i)] : ‚áëdfinsupp.lift_add_hom (dfinsupp.single_add_hom Œ≤) = add_monoid_hom.id (Œ†‚ÇÄ (i : Œπ), Œ≤ i)
 : ‚ÑÇ ‚Üí‚Çê[‚Ñù] quaternion ‚Ñù
{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X ‚Üí Y} {s : set X} : lipschitz_on_with C f s ‚Üí holder_on_with C 1 f s
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} {s : finset Œ±} [add_comm_monoid Œ≤] [decidable_eq Œ≥] (f : Œ≥ ‚Üí Œ≤) (g : Œ± ‚Üí Œ≥) : s.sum (Œª (a : Œ±), f (g a)) = (finset.image g s).sum (Œª (b : Œ≥), (finset.filter (Œª (a : Œ±), g a = b) s).card ‚Ä¢ f b)
{Œ± : Type u_1} [decidable_eq Œ±] : list Œ± ‚Üí list Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : C(Œ±, Œ≤)) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : C(Œ±, Œ≤)
{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_3} [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] : semi_normed_group (normed_group_hom V‚ÇÅ V‚ÇÇ)
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.mul_pos_mono Œ±] (ha : a ‚â§ 1) (hb : b ‚â§ 1) (b0 : 0 < b) : a * b ‚â§ 1
{C : Type u} [category_theory.category C] {f g : category_theory.arrow C} [category_theory.limits.has_image f.hom] [category_theory.limits.has_image g.hom] (sq : f ‚ü∂ g) (F : category_theory.limits.mono_factorisation f.hom) {F' : category_theory.limits.mono_factorisation g.hom} (hF' : category_theory.limits.is_image F') {map : F.I ‚ü∂ F'.I} (map_Œπ : map ‚â´ F'.m = F.m ‚â´ sq.right) : category_theory.limits.image_map sq
{G‚ÇÄ : Type u_2} {G‚ÇÄ' : Type u_4} [group_with_zero G‚ÇÄ] [group_with_zero G‚ÇÄ'] (f : G‚ÇÄ ‚Üí*‚ÇÄ G‚ÇÄ') (a : G‚ÇÄ) : ‚áëf a‚Åª¬π = (‚áëf a)‚Åª¬π
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤] : topological_space C(Œ±, Œ≤)
{J : Type u} (f : J ‚Üí AddCommGroup) (s : category_theory.limits.fan f) : s.X ‚ü∂ AddCommGroup.of (Œ† (j : J), ‚Ü•(f j))
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] (P Q : C) : (category_theory.limits.coprod.braiding P Q).hom ‚â´ (category_theory.limits.coprod.braiding Q P).hom = ùüô (P ‚®ø Q)
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (Œ∏ : real.angle) : ‚áëlinear_map.det ‚Üë((o.rotation Œ∏).to_linear_equiv) = 1
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {K : J ‚•§ C} {c d : category_theory.limits.cone K} (f : c ‚ü∂ d) [i : category_theory.is_iso f.hom] : category_theory.is_iso f
 : environment ‚Üí name ‚Üí bool
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (pb : power_basis K L) : ‚Ü•K‚üÆpb.gen‚üØ ‚âÉ‚Çê[K] L
{C : Type u‚ÇÅ} [category_theory.category C] (J : category_theory.grothendieck_topology C) (A : Type u‚ÇÇ) [category_theory.category A] : Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ)
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] : setoid (local_homeomorph Œ± Œ≤)
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C ‚•§ D} (H : category_theory.cover_dense K G) [category_theory.full G] {‚Ñ± : D·µí·µñ ‚•§ Type v} {‚Ñ±' : category_theory.SheafOfTypes K} (Œ± : G.op ‚ãô ‚Ñ± ‚ü∂ G.op ‚ãô ‚Ñ±'.val) : ‚Ñ± ‚ü∂ ‚Ñ±'.val
{Œ± : Type u} {Œ≤ : Type v} [preorder Œ±] [partial_order Œ≤] {l : Œ± ‚Üí Œ≤} {u : Œ≤ ‚Üí Œ±} (gc : galois_connection l u) (b : Œ≤) : (‚àÉ (a : Œ±), b = l a) ‚Üî b = l (u b)
(f : ordinal ‚Üí ordinal) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (h : category_theory.epi 0) : Y ‚âÖ 0
 : pexpr ‚Üí string
{Œπ : Type u_1} {Œπ' : Type u_2} {Œ± : Type u_3} [fintype Œπ] [preorder Œπ'] [is_directed Œπ' (function.swap has_le.le)] [nonempty Œπ'] {s : Œπ ‚Üí Œπ' ‚Üí set Œ±} (hs : ‚àÄ (i : Œπ), monotone (s i)) : (‚ãÇ (j : Œπ'), ‚ãÉ (i : Œπ), s i j) = ‚ãÉ (i : Œπ), ‚ãÇ (j : Œπ'), s i j
(Œ± : Type u_1) (Œ≤ : Type u_2) [linear_order Œ±] [linear_order Œ≤] : Type (max u_1 u_2)
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] [has_add Œ≤] : Œ± ‚âÉ+ Œ≤ ‚âÉ (Œ±·µê·µí·µñ ‚âÉ+ Œ≤·µê·µí·µñ)
 : cc_state ‚Üí expr ‚Üí expr ‚Üí tactic expr
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (p : Œπ ‚Üí P) : (Œπ ‚Üí k) ‚Üí‚Çó[k] V
{p : Prop} (x : ‚Ñï) : slim_check.test_result p ‚Üí slim_check.test_result p
{Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), add_group (Gs i)] (tfGs : ‚àÄ (i : Œ∑), add_monoid.is_torsion_free (Gs i)) : add_monoid.is_torsion_free (Œ† (i : Œ∑), Gs i)
{V : Type u_1} (Œ± : Type u_2) (G : simple_graph V) [decidable_rel G.adj] [has_zero Œ±] [has_one Œ±] : (simple_graph.adj_matrix Œ± G).is_adj_matrix
{Œ± : Type u_1} [omega_complete_partial_order Œ±] (y : Scott Œ±) : set (Scott Œ±)
(n : name) : name
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} {f : X ‚ü∂ Y} [category_theory.split_epi f] [category_theory.epi (category_theory.section_ f)] : category_theory.is_iso f
{F : Type u_1} [field F] [fintype F] [decidable_eq F] (a : F) : char.quadratic_char F a = 0 ‚Üî a = 0
{R : Type u‚ÇÅ} [non_unital_non_assoc_semiring R] : smul_comm_class ‚Ñï R R
{J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {s : category_theory.limits.cone F} (e : K ‚âå J) : category_theory.limits.is_limit s ‚âÉ category_theory.limits.is_limit (category_theory.limits.cone.whisker e.functor s)
 : Type u ‚•§ AddCommGroup
{C : Type u} [category_theory.category C] {X Y : C} (f : X ‚ü∂ Y) : category_theory.limits.coequalizer f f ‚âÖ Y
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p ‚àà s) (p2 : P) : p -·µ• p2 ‚àà s.direction ‚Üî p2 ‚àà s
{Œ± : Type u_1} [semigroup Œ±] {a b : Œ±} (c : Œ±) (h : a * c = b) : a ‚à£ b
{ùïú : Type u} [nondiscrete_normed_field ùïú] {F : Type v} [normed_group F] [normed_space ùïú F] (f : ùïú ‚Üí F) (f' : F) (s : set ùïú) (x : ùïú) : Prop
{Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : is_compact s) (ht : is_closed t) (h : t ‚äÜ s) : is_compact t
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} (a : Œ±) (b : Œ≤ a) : alist Œ≤
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.initial] (d : D) : F.obj (category_theory.functor.initial.lift F d) ‚ü∂ d
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {ta1 ta2 : topological_space Œ±} {tb1 tb2 : topological_space Œ≤} {tc1 : topological_space Œ≥} (h : continuous (Œª (p : Œ± √ó Œ≤), f p.fst p.snd)) : continuous (Œª (p : Œ± √ó Œ≤), f p.fst p.snd)
{R : Type u_1} [semiring R] (s : set R) : subsemiring R
(x y f : Set) : Prop
(Œ± : Type u_1) : Œ± ‚Üí. Œ±
{M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] (f : M ‚Üí* N) : ‚áëf 1 = 1
 : Type (u+1)
{Œ± : Type u_1} : part Œ± ‚âÉ option Œ±
 : Type (u_1+1)
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 : P) : p1 -·µ• p2 +·µ• p2 = p1
{X Y : Top} (f g : X ‚ü∂ Y) (h : f = g) : topological_space.opens.map f ‚âÖ topological_space.opens.map g
{Œ± : Type u_1} (a : Œ±) (s : multiset Œ±) : multiset Œ±
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) (P : Type u_6) [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] : tensor_product R M (tensor_product R N P) ‚âÉ‚Çó[R] tensor_product R N (tensor_product R M P)
(k : Type u) [field k] : Type u
 : Type
(P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] : fintype.card P ‚â§ fintype.card L
{n : ‚Ñï} (a : composition n) (b : composition a.length) : composition n
{M‚ÇÅ : Type u_1} {M‚ÇÇ : Type u_2} [has_mul M‚ÇÅ] [has_one M‚ÇÅ] [mul_one_class M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÅ), f (x * y) = f x * f y) : mul_one_class M‚ÇÅ
{Œ± : Type u_1} [preorder Œ±] {a : Œ±} : nonempty ‚Ü•(set.Iic a)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Œπ : Type u_4} (s : finset Œπ) (w : Œπ ‚Üí k) (p‚ÇÅ : Œπ ‚Üí P) (p‚ÇÇ b : P) : s.sum (Œª (i : Œπ), w i ‚Ä¢ (p‚ÇÅ i -·µ• p‚ÇÇ)) = ‚áë(s.weighted_vsub_of_point p‚ÇÅ b) w - s.sum (Œª (i : Œπ), w i) ‚Ä¢ (p‚ÇÇ -·µ• b)
{Œ± : Type u} {s : set Œ±} (hs : s.nonempty) : s.countable ‚Üî ‚àÉ (f : ‚Ñï ‚Üí ‚Ü•s), function.surjective f
{M : Type u_1} (S : set M) [add_semigroup M] : add_subsemigroup M
{ùïÇ : Type u_1} [nondiscrete_normed_field ùïÇ] [complete_space ùïÇ] [char_zero ùïÇ] {x : ùïÇ} (hx : x ‚àà emetric.ball 0 (exp_series ùïÇ ùïÇ).radius) : has_strict_deriv_at (exp ùïÇ) (exp ùïÇ x) x
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [baire_space Œ±] {S : set Œ≤} {f : Œ≤ ‚Üí set Œ±} (hc : ‚àÄ (s : Œ≤), s ‚àà S ‚Üí is_closed (f s)) (hS : S.countable) (hU : (‚ãÉ (s : Œ≤) (H : s ‚àà S), f s) = set.univ) : dense (‚ãÉ (s : Œ≤) (H : s ‚àà S), interior (f s))
(e : expr) : list name
 : simplex_category ‚•§ category_theory.Cat
{n : ‚Ñï} {p : fin n} {i : fin (n + 1)} (h : i ‚â† ‚áëfin.cast_succ p) : ‚áë((‚áëfin.cast_succ p).succ_above) (p.pred_above i) = i
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] (p : P) : ‚áë(euclidean_geometry.reflection s) p = p ‚Üî p ‚àà s
{R : Type u‚ÇÅ} [semiring R] {T : Type u‚ÇÑ} [semiring T] {r : R ‚Üí R ‚Üí Prop} : {f // ‚àÄ ‚¶Éx y : R‚¶Ñ, r x y ‚Üí ‚áëf x = ‚áëf y} ‚âÉ (ring_quot r ‚Üí+* T)
{R : Type u} [comm_ring R] [nontrivial R] : invariant_basis_number R
(R : Type u_2) (M : Type u_3) (N : Type u_4) [comm_ring R] [add_comm_group M] [add_comm_group N] [module R M] [module R N] [module.free R M] [module.finite R M] [nontrivial R] : tensor_product R (module.dual R M) N ‚âÉ‚Çó[R] M ‚Üí‚Çó[R] N
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (f : V ‚Üí‚Çó[K] V) (h_inj : function.injective ‚áëf) : V ‚âÉ‚Çó[K] V
{Œ± : Type u_1} (a : Œ±) [subsingleton Œ±] : fintype.card Œ± = 1
{M : Type u_1} [comm_monoid_with_zero M] : M ‚Üí*‚ÇÄ M
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_initial C] [category_theory.limits.has_initial D] : ‚ä•_ D ‚ü∂ G.obj (‚ä•_ C)
{R : Type u} [ring R] {Œ± : Type u_1} {Œ≤ : Type u_2} [has_scalar Œ± Œ≤] [has_scalar R Œ±] [has_scalar R Œ≤] [is_scalar_tower R Œ± Œ≤] (S : subring R) : is_scalar_tower ‚Ü•S Œ± Œ≤
{X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {P : C(X, Y) ‚Üí Prop} {f‚ÇÄ f‚ÇÅ g‚ÇÄ g‚ÇÅ : C(X, Y)} (F : f‚ÇÄ.homotopy_with f‚ÇÅ P) (h‚ÇÄ : f‚ÇÄ = g‚ÇÄ) (h‚ÇÅ : f‚ÇÅ = g‚ÇÅ) : g‚ÇÄ.homotopy_with g‚ÇÅ P
{C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C} : category_theory.limits.has_products (category_theory.over B)
 : Type
{Œ± : Type u} (l : list Œ±) : dlist Œ±
{Œ± : Type u} {Œ≤ : Type v} (R : Type u_1) [monoid R] (e : Œ± ‚âÉ Œ≤) [mul_action R Œ≤] : mul_action R Œ±
{R : Type u_1} [has_zero R] [has_one R] [has_add R] [has_neg R] {n : ‚Ñï} : zmod n ‚Üí R
{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cocone F} : category_theory.limits.is_colimit t ‚âÉ category_theory.limits.is_limit t.op
 : category_theory.limits.preserves_limits_of_size (category_theory.forget‚ÇÇ AddCommMon AddMon)
{R‚ÇÇ : Type u_5} [comm_semiring R‚ÇÇ] {n : Type u_11} [fintype n] (M : matrix n n R‚ÇÇ) : bilin_form R‚ÇÇ (n ‚Üí R‚ÇÇ)
{Œ± : Sort u_1} {p : Œ± ‚Üí Prop} (x : subtype p) : Œ±
(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : ¬¨is_unit (minpoly A x)
{Œ± : Type u} {Œπ : Sort x} {f : Œπ ‚Üí filter Œ±} [nonempty Œπ] (hd : directed ge f) (hb : ‚àÄ (i : Œπ), (f i).ne_bot) : (infi f).ne_bot
{M : Type u_5} [add_comm_group M] (h : module ‚Ñ§ M) (n : ‚Ñ§) (x : M) : n ‚Ä¢ x = n ‚Ä¢ x
{R : Type u_1} {E : Type u_2} {Œπ : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] (s : finset Œπ) (hs : s.nonempty) (p : Œπ ‚Üí E) : finset.centroid R s p = s.center_mass (finset.centroid_weights R s) p
{Œ± : Type u_1} [preorder Œ±] {a b : Œ±} (h : b < a) : ¬¨is_min a
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J·µí·µñ ‚•§ C) {c : category_theory.limits.cocone F} (hc : category_theory.limits.is_colimit c) : category_theory.limits.is_limit (category_theory.limits.cone_right_op_of_cocone c)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] (e : local_homeomorph Œ± Œ≤) {f : Œ≥ ‚Üí Œ±} {x : Œ≥} (h : f ‚Åª¬π' e.to_local_equiv.source ‚àà nhds x) : continuous_at f x ‚Üî continuous_at (‚áëe ‚àò f) x
{Œ± : Type u_1} [has_zero Œ±] [has_one Œ±] [has_add Œ±] (n : ‚Ñï) : Œ±
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b : Œ±} : b ‚â§ a ‚Üí 0 ‚â§ a - b
 : box_integral.integration_params ‚âÉ bool √ó bool·µí·µà √ó bool·µí·µà
{Œ± : Type u_2} [comm_semigroup Œ±] : comm_semigroup (set Œ±)
{n : ‚Ñï} {Œ± Œ≤ : typevec n} : (Œ±.prod Œ≤).arrow Œ±
{Œ≥ : Type u_1} [U : uniform_space Œ≥] (m : emetric_space Œ≥) (H : uniformity Œ≥ = uniformity Œ≥) : emetric_space Œ≥
{R : Type u} [comm_ring R] {U : topological_space.opens ‚Ü•(algebraic_geometry.prime_spectrum.Top R)} (f : Œ† (x : ‚Ü•U), algebraic_geometry.structure_sheaf.localizations R ‚Üëx) : Prop
 : omega.nat.preform ‚Üí Prop
{Œ± : Type u_2} {Œ≤ : Type u_3} [comm_ring Œ±] [is_domain Œ±] [comm_ring Œ≤] (f : Œ≤ ‚Üí+ Œ±) (h : ‚àÄ (x : Œ≤), ‚áëf (x * x) = ‚áëf x * ‚áëf x) (h_two : 2 ‚â† 0) (h_one : ‚áëf 1 = 1) : Œ≤ ‚Üí+* Œ±
{X : Top} {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) (i : Œπ) : Œ£ (V : topological_space.opens ‚Ü•X), {f // Top.presheaf.presieve_of_covering U f}
{C D : Type u} [category_theory.category C] [category_theory.category D] {G : C ‚•§ D} [category_theory.full G] [category_theory.faithful G] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] (Hd : category_theory.cover_dense K G) (Hp : category_theory.cover_preserving J K G) (Hl : category_theory.cover_lifting J K G) : category_theory.Sheaf J A ‚âå category_theory.Sheaf K A
{X : Type u_1} [topological_space X] {a b : X} (Œ≥ : path a b) : continuous (Œª (x : ‚Ñù √ó ‚Ñù √ó ‚Ü•unit_interval), ‚áë(Œ≥.truncate x.fst x.snd.fst) x.snd.snd)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] [complete_space F] [complete_space E] (f : E ‚ÜíL[ùïú] F) {G : submodule ùïú F} (h : is_compl f.range G) [complete_space ‚Ü•G] (hker : f.ker = ‚ä•) : (E √ó ‚Ü•G) ‚âÉL[ùïú] F
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {x : E} : mfderiv (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f x = fderiv ùïú f x
{Œ± : Type u} [pseudo_metric_space Œ±] {s : ‚Ñï ‚Üí set Œ±} (h0 : is_complete (s 0)) (hs : ‚àÄ (n : ‚Ñï), is_closed (s n)) (h's : ‚àÄ (n : ‚Ñï), metric.bounded (s n)) (h : ‚àÄ (N : ‚Ñï), (‚ãÇ (n : ‚Ñï) (H : n ‚â§ N), s n).nonempty) (h' : filter.tendsto (Œª (n : ‚Ñï), metric.diam (s n)) filter.at_top (nhds 0)) : (‚ãÇ (n : ‚Ñï), s n).nonempty
(Œ± : Type u) : Type u
{G : Type w} [topological_space G] [group G] [topological_group G] {K U : set G} (hK : is_compact K) (hU : is_open U) (hKU : K ‚äÜ U) : ‚àÉ (V : set G) (H : V ‚àà nhds 1), K * V ‚äÜ U
 : tactic expr
(out : out_param (Type u ‚Üí Type v)) (m : Type u ‚Üí Type v) : Type (max (u+1) v)
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (x : K) : ‚áë(algebra_map K L) x ‚àà S
{C : Type u‚ÇÅ} [category_theory.category C] {M N : category_theory.comonad C} (h : M ‚âÖ N) : ‚ÜëM ‚âÖ ‚ÜëN
{Œ± : Type u_1} [decidable_eq Œ±] (xs : list Œ±) (x d d' : Œ±) (x_mem : x ‚àà xs) (x_ne : x ‚â† xs.last _) : xs.next_or x d = xs.next_or x d'
{C : Type u‚ÇÅ} [category_theory.category C] {J : category_theory.grothendieck_topology C} (X Y : category_theory.SheafOfTypes J) : Type (max u_1 u‚ÇÅ)
{Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [decidable_eq Œ±] (x : Œ±) (xs : list Œ±) (y : Œ≤ x) (f : Œ† (a : Œ±), a ‚àà xs ‚Üí Œ≤ a) (a : Œ±) : a ‚àà x :: xs ‚Üí Œ≤ a
{Œ± : Type u_1} {Œ≤ : Type u_2} [omega_complete_partial_order Œ±] [omega_complete_partial_order Œ≤] (c : omega_complete_partial_order.chain (Œ± √ó Œ≤)) : Œ± √ó Œ≤
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Type (max v u)) : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone F)
(vs : list expr) : tactic (list (list expr))
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Œπ ‚Üí M} [ring R] [add_comm_group M] [module R M] {hli : linear_independent R v} {hsp : submodule.span R (set.range v) = ‚ä§} (i : Œπ) : ‚áë((basis.mk hli hsp).coord i) (v i) = 1
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] {a b : Œ±} : ¬¨a ‚â§ b ‚Üí multiset.Icc a b = 0
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] (F : J ‚•§ C) : category_theory.limits.cone F ‚•§ C
{M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] {f g : M ‚Üí+ N} (h : f = g) (x : M) : ‚áëf x = ‚áëg x
{V : Type u_1} [inner_product_space ‚Ñù V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b c d p : P} (h : euclidean_geometry.cospherical {a, b, c, d}) (hab : a ‚â† b) (hcd : c ‚â† d) (hapb : euclidean_geometry.angle a p b = 0) (hcpd : euclidean_geometry.angle c p d = 0) : has_dist.dist a p * has_dist.dist b p = has_dist.dist c p * has_dist.dist d p
{Œ± : Type u_1} : list Œ± ‚Üí list (list Œ±)
{A : Type u‚ÇÅ} [category_theory.category A] {B : Type u‚ÇÇ} [category_theory.category B] {C : Type u‚ÇÉ} [category_theory.category C] (F : A ‚•§ B ‚•§ C) (a : A) : F.flip ‚ãô (category_theory.evaluation A C).obj a ‚âÖ F.obj a
{F G : Type u} [group F] [group G] [fintype F] (f : F ‚Üí* G) [f.range.normal] [fintype (G ‚ß∏ f.range)] : fintype G
 : inhabited box_integral.integration_params
{x y : pgame} : x.left_moves ‚äï y.left_moves ‚âÉ (x + y).left_moves
(o : ordinal) : pgame
(pps : list linarith.global_branching_preprocessor) (l : list expr) : tactic (list linarith.branch)
(F A : Class) : Class
(M : Type u_10) (N : Type u_11) (Œ± : Type u_12) [has_scalar M Œ±] [has_scalar N Œ±] : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X Y : C} (f : X ‚ü∂ Y) (hf : ‚àÄ (Z : C) (g : Z ‚ü∂ X), g ‚â´ f = 0 ‚Üí g = 0) : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Œπ 0 _)
{R : Type u_1} {M : Type u_9} [comm_semiring R] [add_comm_monoid M] [module R M] (a : RÀ£) : M ‚âÉ‚Çó[R] M
(Œ± : Type u_7) [measurable_space Œ±] : Prop
{R : Type u_1} [semiring R] {m : Type u_3} {n : Type u_4} [fintype m] [decidable_eq m] : matrix m n R ‚âÉ‚Çó[R·µê·µí·µñ] (m ‚Üí R) ‚Üí‚Çó[R] n ‚Üí R
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [succ_order Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : antitone f) : pairwise (disjoint on Œª (n : Œ±), set.Ioo (f (order.succ n)) (f n))
{M : Type u_1} (R : Type u_3) [decidable_eq M] [comm_semiring R] (m : M) : submodule R (add_monoid_algebra R M)
(p : nat.primes) : ‚Üëp.factor_multiset = prime_multiset.of_prime p
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ‚Ñù P) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] : P ‚âÉ·µÉ‚Å±[‚Ñù] P
{M : Type u_1} [has_mul M] (r : M ‚Üí M ‚Üí Prop) : con_gen ‚áë(con_gen r) = con_gen r
{Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} (c : Œ≥) : Œ± ‚äï Œ≤ ‚äï Œ≥
{ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) (k : ‚Ñï) : formal_multilinear_series ùïú E (continuous_multilinear_map ùïú (Œª (i : fin k), E) F)
 : Type
(K : Type u) {L : Type v} (E : Type z) [field K] [field L] [field E] [algebra K L] [algebra K E] [module.finite K L] [is_alg_closed E] (pb : power_basis K L) [is_separable K L] (e : fin pb.dim ‚âÉ (L ‚Üí‚Çê[K] E)) : ‚áë(algebra_map K E) (algebra.discr K ‚áë(pb.basis)) = finset.univ.prod (Œª (i : fin pb.dim), (finset.filter (Œª (j : fin pb.dim), i < j) finset.univ).prod (Œª (j : fin pb.dim), -((‚áë(‚áëe j) pb.gen - ‚áë(‚áëe i) pb.gen) * (‚áë(‚áëe i) pb.gen - ‚áë(‚áëe j) pb.gen))))
(Œ≥ : Type) : Type
{Œ± : Type u} : wseq Œ± ‚Üí wseq Œ±
{C : Type u‚ÇÅ} [category_theory.category C] {Z X Y P : C} {f : Z ‚ü∂ X} {g : Z ‚ü∂ Y} {inl : X ‚ü∂ P} {inr : Y ‚ü∂ P} (h : category_theory.is_pushout f g inl inr) : category_theory.limits.is_colimit h.cocone
{Œ∑ : Type u_1} {Ms : Œ∑ ‚Üí Type u_2} {Ns : Œ∑ ‚Üí Type u_3} [Œ† (j : Œ∑), has_add (Ms j)] [Œ† (j : Œ∑), has_add (Ns j)] (es : Œ† (j : Œ∑), Ms j ‚âÉ+ Ns j) : (Œ† (j : Œ∑), Ms j) ‚âÉ+ Œ† (j : Œ∑), Ns j
 : vm_obj ‚Üí tactic_state
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddGroup) : AddGroup
(g : tactic.impl_graph) : expr ‚Üí tactic unit
{Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [has_div Œ≤] : has_div Œ±
{S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] (pb : power_basis K S) : finite_dimensional K S
{C : Type u‚ÇÅ} [category_theory.category C] {T : category_theory.monad C} {A B : T.algebra} (h : A.A ‚âÖ B.A) (w : ‚ÜëT.map h.hom ‚â´ B.a = A.a ‚â´ h.hom) : A ‚âÖ B
(L : first_order.language) [L.is_ordered] : first_order.language.order ‚Üí·¥∏ L
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] {J : Type v} (f : J ‚Üí C) (F : C ‚•§ D) [F.preserves_zero_morphisms] : Type (max u u‚ÇÇ v)
(op : ordinal ‚Üí ordinal ‚Üí ordinal) (o : ordinal) : ordinal
{Œ± : Type u} [add_comm_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b c : Œ±} : b < c - a ‚Üí a + b < c
(ùïú : Type u_1) {E : Type u_2} [comm_semiring ùïú] [star_ring ùïú] [normed_ring E] [star_ring E] [normed_star_group E] [module ùïú E] [star_module ùïú E] : E ‚âÉ‚Çó·µ¢‚ãÜ[ùïú] E
{Œ± : Type u} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_strict_order Œ± r] : partial_order Œ±
{Œ± : Type u_1} [denumerable Œ±] : denumerable (option Œ±)
{n : ‚Ñï} : has_well_founded (fin n)
{Œ± : Type u} [ordered_comm_monoid Œ±] : ordered_comm_group Œ±À£
{V‚ÇÅ : Type u_3} {V‚ÇÇ : Type u_4} {V‚ÇÉ : Type u_5} [semi_normed_group V‚ÇÅ] [semi_normed_group V‚ÇÇ] [semi_normed_group V‚ÇÉ] (f : normed_group_hom V‚ÇÅ V‚ÇÇ) (g : normed_group_hom V‚ÇÇ V‚ÇÉ) (h : g.comp f = 0) : normed_group_hom V‚ÇÅ ‚Ü•(g.ker)
{M : Type u_1} [add_monoid M] {s : set M} {a : M} (h : a ‚àà add_monoid.closure s) : ‚àÉ (l : list M), (‚àÄ (x : M), x ‚àà l ‚Üí x ‚àà s) ‚àß l.sum = a
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±] [nontrivial Œ±] {s : set Œ±} : dense s ‚Üî ‚àÄ (a b : Œ±), a < b ‚Üí (‚àÉ (c : Œ±) (H : c ‚àà s), a < c ‚àß c < b)
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ‚ü∂ Y) [category_theory.limits.has_equalizer f g] : category_theory.limits.equalizer f g ‚ü∂ X
 : Type (u+1)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J ‚Üí C) : Type (max u v)
{C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} (f : X ‚ü∂ Y) : Prop
{ùïú : Type u_1} {E : Type u} [linear_ordered_field ùïú] [add_comm_group E] [module ùïú E] [decidable_eq E] {t : finset E} (h : ¬¨affine_independent ùïú coe) {x : E} (m : x ‚àà ‚áë(convex_hull ùïú) ‚Üët) : ‚àÉ (y : ‚Ü•‚Üët), x ‚àà ‚áë(convex_hull ùïú) ‚Üë(t.erase ‚Üëy)
{K : Type u_1} [is_R_or_C K] (f : cau_seq K is_R_or_C.abs) : cau_seq ‚Ñù has_abs.abs
(R : Type u_1) (M : Type u_9) (Œ± : Type u_20) [fintype Œ±] [add_comm_monoid M] [semiring R] [module R M] : (Œ± ‚Üí‚ÇÄ M) ‚âÉ‚Çó[R] Œ± ‚Üí M
{Œ± : Type u_1} [linear_ordered_field Œ±] {a b : Œ±} (ha : 0 < a) (hb : 0 < b) : a‚Åª¬π < b ‚Üî b‚Åª¬π < a
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ AddGroup) : category_theory.limits.is_colimit (AddGroup.filtered_colimits.colimit_cocone F)
{R : Type u} {S : Type v} [ring R] [ring S] (s : subring R) (f : R ‚Üí+* S) (hf : function.injective ‚áëf) : ‚Ü•s ‚âÉ+* ‚Ü•(subring.map f s)
(Œ± : Type u) [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] : Œ± ‚âÉo Œ±·µí·µà
{Œì : Type u_1} [inhabited Œì] (T : turing.tape Œì) : ‚Ñ§ ‚Üí Œì
{Œì : Type u_1} {R : Type u_2} [partial_order Œì] [semiring R] {Œì' : Type u_4} [partial_order Œì'] (f : Œì ‚Ü™o Œì') : hahn_series Œì R ‚Üí‚Çó[R] hahn_series Œì' R
{E : Type u_4} {F : Type u_5} [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E] [normed_group F] [normed_space ‚Ñù F] {f : E ‚Üí F} (h : cont_diff ‚Ñù 1 f) : dimH (set.range f) ‚â§ ‚Üë(finite_dimensional.finrank ‚Ñù E)
{M : Type u_1} [monoid M] (s : set M) : set M
{G : Type u_1} [group G] (s : set G) : subgroup G
(l : interactive.parse interactive.types.pexpr_list) (at_ : interactive.parse interactive.types.location) : tactic unit
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] {J : Type u‚ÇÅ} [category_theory.category J] {K : Type u‚ÇÇ} [category_theory.category K] (F : D ‚•§ K ‚•§ C) (G : J ‚•§ D) (H : Œ† (k : K), category_theory.limits.preserves_colimit G (F ‚ãô (category_theory.evaluation K C).obj k)) : category_theory.limits.preserves_colimit G F
{p a b : ‚Ñï} (hpa : p ‚àà a.factors) (hb : b ‚â† 0) : p ‚àà (a * b).factors
{p : ‚Ñï} [hp_prime : fact (nat.prime p)] {R : Type u_1} [non_assoc_semiring R] {f : Œ† (k : ‚Ñï), R ‚Üí+* zmod (p ^ k)} (f_compat : ‚àÄ (k1 k2 : ‚Ñï) (hk : k1 ‚â§ k2), (zmod.cast_hom _ (zmod (p ^ k1))).comp (f k2) = f k1) (r : R) : ‚Ñ§_[p]
{n : ‚Ñï} (i‚ÇÅ i‚ÇÇ : fin (n + 3)) : affine.simplex.points_with_circumcenter_index (n + 2) ‚Üí ‚Ñù
(e : expr) : tactic expr
{Œ± : Type u_1} [group Œ±] [fintype Œ±] (s : subgroup Œ±) [fintype ‚Ü•s] : fintype.card ‚Ü•s ‚à£ fintype.card Œ±
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] (X : Top) : category_theory.Sheaf (opens.grothendieck_topology ‚Ü•X) C ‚âå Top.sheaf C X
{Œ± : Type u} [decidable_eq Œ±] : free_group Œ± ‚Üí list (Œ± √ó bool)
{R : Type u} [ring R] {M N : Module R} (f : M ‚ü∂ N) : category_theory.limits.cokernel_cofork f
{R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [add_comm_group N] [module R M] [module R N] [lie_ring_module L M] [lie_ring_module L N] [lie_module R L M] [lie_module R L N] (e : M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N) : M ‚âÉ N
(Œ∏ : real.angle) : ‚Ñù
 : string ‚Üí ‚Ñï ‚Üí lean.parser unit
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {n : Type u_3} [fintype n] (b : basis n R M) [decidable_eq n] (A : matrix n n R) (hA : is_unit A.det) : M ‚âÉ‚Çó[R] M
{C : Type u} {D : Type u'} [category_theory.category D] [category_theory.monoidal_category D] (f : C ‚Üí D) : category_theory.monoidal_functor (category_theory.free_monoidal_category C) D
{A : Type v} [ring A] {R : Type u} [comm_ring R] [algebra R A] : lie_algebra R A
(p : ‚Ñï) [hp : fact (nat.prime p)] : witt_vector p (zmod p) ‚Üí+* ‚Ñ§_[p]
(X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] (y : Y) : Gromov_Hausdorff.optimal_GH_coupling X Y
{M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_3} [has_zero M‚ÇÄ'] [has_mul M‚ÇÄ'] [has_one M‚ÇÄ'] [has_pow M‚ÇÄ' ‚Ñï] [monoid_with_zero M‚ÇÄ] (f : M‚ÇÄ ‚Üí M‚ÇÄ') (hf : function.surjective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ‚àÄ (x y : M‚ÇÄ), f (x * y) = f x * f y) (npow : ‚àÄ (x : M‚ÇÄ) (n : ‚Ñï), f (x ^ n) = f x ^ n) : monoid_with_zero M‚ÇÄ'
{Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} (h : category_theory.discrete Œ± ‚âå category_theory.discrete Œ≤) : Œ± ‚âÉ Œ≤
{Œ± : Type u_2} [add_comm_monoid Œ±] : multiset Œ± ‚Üí+ Œ±
{R : Type u_1} {S : Type u_2} (L : Type u_4) [euclidean_domain R] [comm_ring S] [is_domain S] [field L] [algRL : algebra R L] [algebra R S] [algebra S L] [ist : is_scalar_tower R S L] [iic : is_integral_closure S R L] {abv : absolute_value R ‚Ñ§} {Œπ : Type u_5} [decidable_eq Œπ] [fintype Œπ] (bS : basis Œπ R S) (adm : abv.is_admissible) [infinite R] [decidable_eq R] [is_fraction_ring S L] [is_dedekind_domain S] (h : algebra.is_algebraic R L) : fintype (class_group S L)
{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] {P' : Type u_3} [comm_ring P'] [algebra R P'] (g : P ‚Üí‚Çê[R] P') : fractional_ideal S P ‚Üí fractional_ideal S P'
{Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [add_comm_monoid Œπ] [decidable_eq Œπ] [comm_ring R] [comm_ring A] [algebra R A] (ùíú : Œπ ‚Üí submodule R A) [graded_algebra ùíú] (x : ideal A) [x.is_prime] : Type (max u_1 u_3)
(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] (z : K) : K
(Œ± : Type u_2) [has_le Œ±] [bounded_order Œ±] : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ‚Ü•X) (R : category_theory.presieve U) : category_theory.presheaf.first_map R F ‚â´ (Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom = (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom ‚â´ Top.presheaf.sheaf_condition_equalizer_products.left_res F (Top.presheaf.covering_of_presieve U R)
 : ‚Ñï ‚Üí expr ‚Üí expr
{Œ± : Type u} {Œπ : Type v} [metric_space Œ±] [proper_space Œ±] {c : Œπ ‚Üí Œ±} {r : Œπ ‚Üí ‚Ñù} (uf : ‚àÄ (x : Œ±), {i : Œπ | x ‚àà metric.ball (c i) (r i)}.finite) (uU : (‚ãÉ (i : Œπ), metric.ball (c i) (r i)) = set.univ) : ‚àÉ (r' : Œπ ‚Üí ‚Ñù), (‚ãÉ (i : Œπ), metric.ball (c i) (r' i)) = set.univ ‚àß ‚àÄ (i : Œπ), r' i < r i
{X Y : Top} (H : X ‚âÖ Y) : topological_space.opens ‚Ü•Y ‚âå topological_space.opens ‚Ü•X
{Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) [is_irrefl Œ± r] : {c : cardinal | ‚àÉ (S : set Œ±), set.unbounded r S ‚àß cardinal.mk ‚Ü•S = c}.nonempty
{Œ± : Type v} {d u n : ‚Ñï} (A : matrix (fin (u + d)) (fin n) Œ±) : matrix (fin u) (fin n) Œ±
(p : pexpr) : tactic tactic.pattern
 : expr ‚Üí expr ‚Üí bool
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.final] {E : Type u} [category_theory.category E] {G : D ‚•§ E} [category_theory.limits.has_colimit (F ‚ãô G)] : category_theory.limits.colimit (F ‚ãô G) ‚âÖ category_theory.limits.colimit G
(R : Type u_2) {M : Type u_5} [ring R] [add_comm_group M] [module R M] (n : ‚Ñ§) (b : M) : n ‚Ä¢ b = ‚Üën ‚Ä¢ b
{Œ± : Type u_1} {Œ≥ : Type u_3} {Œπ : Sort u_2} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí set Œ±} {f : filter Œ±} (hf : f.has_basis p s) {Œ≤ : Œπ ‚Üí Type u_4} {pg : Œ† (i : Œπ), Œ≤ i ‚Üí Prop} {sg : Œ† (i : Œπ), Œ≤ i ‚Üí set Œ≥} {g : set Œ± ‚Üí filter Œ≥} (hg : ‚àÄ (i : Œπ), (g (s i)).has_basis (pg i) (sg i)) (gm : monotone g) {s_1 : set Œ≥} : s_1 ‚àà f.lift g ‚Üî ‚àÉ (i : Œπ) (hi : p i) (x : Œ≤ i) (hx : pg i x), sg i x ‚äÜ s_1
{C : Type u} {X Y X' Y' : C} [category_theory.category C] [category_theory.monoidal_category C] (f : X ‚âÖ Y) (g : X' ‚âÖ Y') : X ‚äó X' ‚âÖ Y ‚äó Y'
(Œ± : Type u_2) : Type u_2
(R : Type u) [ring R] [strong_rank_condition R] {Œπ : Type u} : module.rank R (Œπ ‚Üí‚ÇÄ R) = cardinal.mk Œπ
{Œ± : Type u_1} [complete_lattice Œ±] {k : Œ±} (h : complete_lattice.is_compact_element k) : is_coatomic ‚Ü•(set.Iic k)
{K : Type u_1} [field K] (A : valuation_subring K) : (prime_spectrum ‚Ü•A)·µí·µà ‚âÉo ‚Ü•{S : valuation_subring K | A ‚â§ S}
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.monoidal_category D] {F G F' G' : C ‚•§ D} (Œ± : F ‚ü∂ G) (Œ≤ : F' ‚ü∂ G') : category_theory.monoidal.functor_category.tensor_obj F F' ‚ü∂ category_theory.monoidal.functor_category.tensor_obj G G'
{X : Type u} {m‚ÇÅ : X ‚Üí X ‚Üí X} {e‚ÇÅ : X} (h‚ÇÅ : eckmann_hilton.is_unital m‚ÇÅ e‚ÇÅ) [h : mul_one_class X] (distrib : ‚àÄ (a b c d : X), m‚ÇÅ (a * b) (c * d) = m‚ÇÅ a c * m‚ÇÅ b d) : comm_monoid X
{R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] [finite_dimensional R M] [nonempty Œπ] (x : orientation R M Œπ) (h : fintype.card Œπ = finite_dimensional.finrank R M) : basis Œπ R M
{Œ± : Type u_1} [fintype Œ±] {ùíú : finset (finset Œ±)} {r : ‚Ñï} : set.sized r ‚Üëùíú ‚Üí ùíú ‚äÜ finset.powerset_len r finset.univ
{M : Type u_1} [has_mul M] {s : set M} {p : M ‚Üí M ‚Üí Prop} {x y : M} (hx : x ‚àà subsemigroup.closure s) (hy : y ‚àà subsemigroup.closure s) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí ‚àÄ (y : M), y ‚àà s ‚Üí p x y) (Hmul_left : ‚àÄ (x y z : M), p x z ‚Üí p y z ‚Üí p (x * y) z) (Hmul_right : ‚àÄ (x y z : M), p z x ‚Üí p z y ‚Üí p z (x * y)) : p x y
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : affine_span k ‚àÖ = ‚ä•
{Œ± : Type u} (xs : list Œ±) : slim_check.gen (subtype xs.perm)
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_4} [decidable_eq Œπ] [fintype Œπ] (e : basis Œπ R M) : alternating_map R M R Œπ
{Œπ : Type u_1} {Œπ' : Type u_2} {Œ± : Type u_3} [fintype Œπ] [preorder Œπ'] [is_directed Œπ' has_le.le] [nonempty Œπ'] {s : Œπ ‚Üí Œπ' ‚Üí set Œ±} (hs : ‚àÄ (i : Œπ), antitone (s i)) : (‚ãÇ (j : Œπ'), ‚ãÉ (i : Œπ), s i j) = ‚ãÉ (i : Œπ), ‚ãÇ (j : Œπ'), s i j
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : set P} (hs : euclidean_geometry.cospherical s) {p : fin 3 ‚Üí P} (hps : set.range p ‚äÜ s) (hpi : function.injective p) : affine_independent ‚Ñù p
{R : Type u_1} [mul_zero_class R] : ¬¨is_left_regular 0 ‚Üî nontrivial R
{Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} (h : is_compact s) : metric.bounded s
{Œ± : Type} {d : ‚Ñï} {ds : list ‚Ñï} [ring Œ±] (x : holor Œ± (d :: ds)) : (finset.range d).attach.sum (Œª (i : {x // x ‚àà finset.range d}), (holor.unit_vec d ‚Üëi).mul (x.slice ‚Üëi _)) = x
{C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : ‚Ñï} {i : fin (n + 1)} : X.Œ¥ i.succ ‚â´ X.œÉ i = ùüô (X.obj (simplex_category.mk n))
 : Type
{F : Type u} [decidable_eq F] [field F] (s : finset F) (f : F ‚Üí F) : polynomial F
 : environment ‚Üí name ‚Üí environment
 : expr ‚Üí tactic (list expr √ó expr)
 : expr ‚Üí smt_tactic (expr √ó expr)
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [measurable_space Œ±] (f : measure_theory.simple_func Œ± Œ≤) (g : Œ≤ ‚Üí measure_theory.simple_func Œ± Œ≥) : measure_theory.simple_func Œ± Œ≥
{C : Type u‚ÇÅ} [category_theory.category C] (J : category_theory.grothendieck_topology C) : category_theory.cover_preserving J J (ùü≠ C)
{Œ± Œ≤ : Type} [reflected Œ≤] (attr : user_attribute Œ± Œ≤) (n : name) : tactic Œ≤
{Œ± : Type u} [semilattice_sup Œ±] [nonempty Œ±] {s : set Œ±} (hs : s.finite) : bdd_above s
{R : Type u} [comm_semiring R] [no_zero_divisors R] (t : multiset (polynomial R)) [nontrivial R] : t.prod.degree = (multiset.map (Œª (f : polynomial R), f.degree) t).sum
(R : Type u_1) (A : Type u_2) (M : Type u_3) (N : Type u_4) (P : Type u_5) [comm_semiring R] [comm_semiring A] [algebra R A] [add_comm_monoid M] [module R M] [module A M] [is_scalar_tower R A M] [add_comm_monoid N] [module R N] [add_comm_monoid P] [module R P] [module A P] [is_scalar_tower R A P] : (tensor_product R M N ‚Üí‚Çó[A] P) ‚Üí‚Çó[A] M ‚Üí‚Çó[A] N ‚Üí‚Çó[R] P
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {E' : Type u_7} [inner_product_space ùïú E'] (f : E ‚âÉ‚Çó[ùïú] E') {v : basis Œπ ùïú E} (hv : orthonormal ùïú ‚áëv) (hf : orthonormal ùïú (‚áëf ‚àò ‚áëv)) : E ‚âÉ‚Çó·µ¢[ùïú] E'
 : smt_state ‚Üí bool
{C : Type u} [category_theory.category C] [‚àÄ (X Y : C), subsingleton (X ‚ü∂ Y)] : category_theory.essentially_small C ‚Üî small (category_theory.skeleton C)
 : tactic unit
{C : Type u} : category_theory.free_monoidal_category C ‚Üí category_theory.free_monoidal_category C ‚Üí Type u
(e : expr) (p : name ‚Üí Prop) [decidable_pred p] : bool
{K : Type u} [field K] (S : Type u_1) [set_like S K] [h : subfield_class S K] (s : S) : field ‚Ü•s
{Œ± : Type u_1} {Œ≤ : Type u_2} {l : filter Œ±} {Œ≥ : Sort u_3} (f : l.germ Œ≤) (F : (Œ± ‚Üí Œ≤) ‚Üí Œ≥) (hF : (l.eventually_eq ‚áí eq) F F) : Œ≥
(Œπ : Type u_4) (B : Type u_5) [topological_space B] (F : Type u_6) [topological_space F] : Type (max u_4 u_5 u_6)
{G : Type u_10} [group G] (a : G) : equiv.perm G
 : has_mod ordinal
{Œ± : Sort u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (f_inv : Œ≤ ‚Üí Œ±) (hf : function.left_inverse f_inv f) : Œ± ‚âÉ ‚Ü•(set.range f)
{M : Type u_4} [mul_one_class M] (self : submonoid M) : subsemigroup M
{M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] (e : M ‚âÉ* N) : N ‚Üí M
{Œ± : Sort u_1} (P : Prop) [decidable P] (x : ¬¨P ‚Üí Œ±) (y : ¬¨¬¨P ‚Üí Œ±) : dite (¬¨P) x y = dite P (Œª (h : P), y _) x
{Œ± : Type u_1} {Œ≤ : Type u_2} [normed_ring Œ±] [normed_ring Œ≤] : normed_ring (Œ± √ó Œ≤)
{G : Type u_3} [add_group G] : G ‚Üí+ additive (add_aut G)
{R : Type u} [ring R] (s : subring R) : subring.closure ‚Üës = s
{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] {X Y : C} : has_neg (X ‚ü∂ Y)
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (f : M ‚Üí‚Çó[R] M) : bilin_form R M
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {s : set A} {p : A ‚Üí A ‚Üí Prop} {a b : A} (ha : a ‚àà algebra.adjoin R s) (hb : b ‚àà algebra.adjoin R s) (Hs : ‚àÄ (x : A), x ‚àà s ‚Üí ‚àÄ (y : A), y ‚àà s ‚Üí p x y) (Halg : ‚àÄ (r‚ÇÅ r‚ÇÇ : R), p (‚áë(algebra_map R A) r‚ÇÅ) (‚áë(algebra_map R A) r‚ÇÇ)) (Halg_left : ‚àÄ (r : R) (x : A), x ‚àà s ‚Üí p (‚áë(algebra_map R A) r) x) (Halg_right : ‚àÄ (r : R) (x : A), x ‚àà s ‚Üí p x (‚áë(algebra_map R A) r)) (Hadd_left : ‚àÄ (x‚ÇÅ x‚ÇÇ y : A), p x‚ÇÅ y ‚Üí p x‚ÇÇ y ‚Üí p (x‚ÇÅ + x‚ÇÇ) y) (Hadd_right : ‚àÄ (x y‚ÇÅ y‚ÇÇ : A), p x y‚ÇÅ ‚Üí p x y‚ÇÇ ‚Üí p x (y‚ÇÅ + y‚ÇÇ)) (Hmul_left : ‚àÄ (x‚ÇÅ x‚ÇÇ y : A), p x‚ÇÅ y ‚Üí p x‚ÇÇ y ‚Üí p (x‚ÇÅ * x‚ÇÇ) y) (Hmul_right : ‚àÄ (x y‚ÇÅ y‚ÇÇ : A), p x y‚ÇÅ ‚Üí p x y‚ÇÇ ‚Üí p x (y‚ÇÅ * y‚ÇÇ)) : p a b
{l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {Œ± : Type v} (e‚Çò : m ‚âÉ l) (e‚Çô : n ‚âÉ o) : matrix m n Œ± ‚âÉ matrix l o Œ±
{x y : pgame} (R : x.relabelling y) (S : x.short) : y.short
{Œ± : Type u} (f : filter Œ±) : (‚®Ü (g : ultrafilter Œ±) (hg : ‚Üëg ‚â§ f), ‚Üëg) = f
{Œ± : Type u} [lattice Œ±] [comm_group Œ±] : has_neg_part Œ±
{Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : cocompact_map Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : cocompact_map Œ± Œ≤
{R S : Type u} [comm_ring R] [comm_ring S] (M : submonoid R) (R' : Type u) [comm_ring R'] [algebra R R'] [algebra R' S] [algebra R S] [is_scalar_tower R R' S] [is_localization M R'] (s : set S) (x : S) (hx : x ‚àà submodule.span R' s) : ‚àÉ (t : ‚Ü•M), t ‚Ä¢ x ‚àà submodule.span R s
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {j j' : C} (f f' : j ‚ü∂ j') : category_theory.is_cofiltered.eq f f' ‚ü∂ j
{X : Type u_1} [topological_space X] {Y : Type u_2} [topological_space Y] {f : Y ‚Üí X} (cont : continuous f) (A : discrete_quotient Y) (B : discrete_quotient X) : Prop
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] : cochain_complex.single‚ÇÄ V ‚âÖ homological_complex.single V (complex_shape.up ‚Ñï) 0
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [‚àÄ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)·µí·µñ D] [‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [Œ† (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)·µí·µñ (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] (P : C·µí·µñ ‚•§ D) : category_theory.presheaf.is_sheaf J (J.plus_obj (J.plus_obj P))
{R : Type u} [ring R] {Œπ : Type v} (Z : Œπ ‚Üí Module R) : category_theory.limits.fan Z
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (p : formal_multilinear_series ùïú E F) (i : E ‚âÉL[ùïú] F) : p.remove_zero.left_inv i = p.left_inv i
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí topological_space.opens ‚Ü•X) (s : category_theory.limits.fork (Top.presheaf.sheaf_condition_equalizer_products.left_res F U) (Top.presheaf.sheaf_condition_equalizer_products.right_res F U)) : s.Œπ ‚â´ Top.presheaf.presieve_of_covering.pi_opens_to_first_obj F U ‚â´ Top.presheaf.presieve_of_covering.first_obj_to_pi_opens F U = s.Œπ
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_terminal C] : category_theory.limits.is_terminal (‚ä§_ C)
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] (f : M ‚âÉ‚Çó[R] M) : linear_map.general_linear_group R M
(R' : Type u) (S' : Type v) (T' : Type w) [comm_semiring R'] [comm_semiring S'] [comm_semiring T'] [algebra R' S'] [algebra S' T'] : algebra (polynomial R') (S' ‚Üí T')
{C : Type u} [category_theory.category C] : has_le (category_theory.grothendieck_topology C)
(C : Type u) [category_theory.category C] : Prop
 : Type
(f : nat.arithmetic_function ‚ÑÇ) (z : ‚ÑÇ) : ‚ÑÇ
{C : Type u} (A : Type u_1) [category_theory.category C] [add_monoid A] [category_theory.has_shift C A] (X : C) : (category_theory.shift_functor C 0).obj X ‚âÖ X
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {R : Type u_1} [semiring k] [mul_one_class G] [semiring R] {f g : monoid_algebra k G ‚Üí+* R} (h‚ÇÅ : ‚àÄ (b : k), ‚áëf (finsupp.single 1 b) = ‚áëg (finsupp.single 1 b)) (h_of : ‚àÄ (a : G), ‚áëf (finsupp.single a 1) = ‚áëg (finsupp.single a 1)) : f = g
(Œ± : Type u_4) : Type u_4
{L : first_order.language} (T : L.Theory) (M : Type w) [L.Structure M] [M ‚ä® T] [nonempty M] : T.Model
 : Type
{Œ± : Type u_1} (s : set Œ±) [has_Inf Œ±] [inhabited ‚Ü•s] : has_Inf ‚Ü•s
 : user_attribute norm_cast.norm_cast_cache (option norm_cast.label)
{Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] {f g : Œπ ‚Üí Œ±} (B : bdd_above (set.range g)) (H : ‚àÄ (x : Œπ), f x ‚â§ g x) : supr f ‚â§ supr g
{M : Type u_1} [add_group M] (c : add_con M) (n : ‚Ñ§) {w x : M} : ‚áëc w x ‚Üí ‚áëc (n ‚Ä¢ w) (n ‚Ä¢ x)
(P : Type u_2) [has_le P] : Type u_2
(ùïú : Type u_1) {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E] [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (s : set E) : Prop
{Œì : Type u_1} [inhabited Œì] (l : list Œì) : turing.tape Œì
(n : ‚Ñï) : mv_polynomial ‚Ñï ‚Ñ§
{n : ‚Ñï} (a b : pSet.resp n) : Prop
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (b : category_theory.limits.binary_bicone X Y) (total : b.fst ‚â´ b.inl + b.snd ‚â´ b.inr = ùüô b.X) : b.is_bilimit
{Œ± : Type u_1} (l : list Œ±) : array l.length Œ±
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type v
 : has_reflect name
{L : first_order.language} {Œ± : Type u'} (r : L.relations 1) (t : L.term Œ±) : L.formula Œ±
{Œ± : Type u_1} [decidable_eq Œ±] [monoid Œ±] {s : finset Œ±} : decidable (mul_salem_spencer ‚Üës)
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_5} [normed_group E'] [normed_space ùïú E'] {n : with_top ‚Ñï} {f : E ‚Üí E'} {s : set E} : cont_diff_on ùïú n f s ‚Üí cont_mdiff_on (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') n f s
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] {f : X ‚ü∂ Y} [category_theory.limits.has_kernel f] {X' Y' : C} {f' : X' ‚ü∂ Y'} [category_theory.limits.has_kernel f'] (sq : category_theory.arrow.mk f ‚ü∂ category_theory.arrow.mk f') : ‚Üë(category_theory.limits.kernel_subobject f) ‚ü∂ ‚Üë(category_theory.limits.kernel_subobject f')
{Œ± : Type u_6} {Œ≤ : Type u_7} [has_mul Œ≤] [has_scalar Œ± Œ≤] [smul_comm_class Œ± Œ≤ Œ≤] (s : Œ±) (x y : Œ≤) : x * s ‚Ä¢ y = s ‚Ä¢ (x * y)
{Œ± : Type u_1} [partial_order Œ±] (c : closure_operator Œ±) : _.closure_operator = c
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ‚•§ D) [F.final] {E : Type u} [category_theory.category E] (G : D ‚•§ E) [category_theory.limits.has_colimit G] : category_theory.limits.colimit (F ‚ãô G) ‚âÖ category_theory.limits.colimit G
{X Y Z : Top} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : topological_space.opens.map (f ‚â´ g) ‚âÖ topological_space.opens.map g ‚ãô topological_space.opens.map f
(S : Type u_4) (M : out_param (Type u_5)) [has_mul M] [set_like S M] : Type
{Œ± : Type u_1} (x : Œ±) : slim_check.small Œ±
(p : ‚Ñï) [hp : fact (nat.prime p)] : ‚Ñï ‚Üí mv_polynomial (fin 1 √ó ‚Ñï) ‚Ñ§
(Œ± : Type u_1) [complete_lattice Œ±] : well_founded gt ‚Üí complete_lattice.is_sup_closed_compact Œ±
{G : Type u_1} [group G] (H K : subgroup G) : Prop
 : lean.parser (tactic.list_Sigma tactic.rcases_patt)
{B : Type u‚ÇÅ} [category_theory.bicategory B] {C : Type u‚ÇÇ} [category_theory.bicategory C] (F : category_theory.oplax_functor B C) [‚àÄ (a : B), category_theory.is_iso (F.map_id a)] [‚àÄ {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c), category_theory.is_iso (F.map_comp f g)] : category_theory.pseudofunctor B C
{M : Type u_4} [topological_space M] [add_monoid M] [has_continuous_add M] [t2_space M] (s : add_submonoid M) (hs : ‚àÄ (x y : ‚Ü•s), x + y = y + x) : add_comm_monoid ‚Ü•(s.topological_closure)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V
{C : Type u} [category_theory.category C] {A X Y : C} [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] : (A ‚®Ø Y ‚ü∂ X) ‚Üí (Y ‚ü∂ (category_theory.exp A).obj X)
(Œ± : Type u_1) [nonempty_fin_lin_ord Œ±] : NonemptyFinLinOrd
 : tactic unit
{R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] : submonoid S
(R : Type u) [ring R] : category_theory.Mat R ‚âå category_theory.Mat_ (category_theory.single_obj R·µê·µí·µñ)
{M : Type u_5} [add_monoid M] {Œ± : Type u_1} {Œ≤ : Type u_2} : (Œ± ‚äï Œ≤ ‚Üí‚ÇÄ M) ‚âÉ+ (Œ± ‚Üí‚ÇÄ M) √ó (Œ≤ ‚Üí‚ÇÄ M)
{X : Type u_2} [emetric_space X] {s : set X} (h : s.subsingleton) : dimH s = 0
{ùïú : Type u_1} {_x : ring ùïú} {E : Type u_2} [semi_normed_group E] {_x_1 : module ùïú E} (s : submodule ùïú E) : semi_normed_group ‚Ü•s
{Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] {a b : Œ±} (hab : a < b) (s : set Œ±) : [s ‚àà nhds_within a (set.Ioi a), s ‚àà nhds_within a (set.Ioc a b), s ‚àà nhds_within a (set.Ioo a b), ‚àÉ (u : Œ±) (H : u ‚àà set.Ioc a b), set.Ioo a u ‚äÜ s, ‚àÉ (u : Œ±) (H : u ‚àà set.Ioi a), set.Ioo a u ‚äÜ s].tfae
{C : Type u} [category_theory.category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [category_theory.is_iso f] : category_theory.limits.pullback_cone f g
{R : Type u} [semiring R] (p : polynomial R) : ‚Ñï
{Œπ : Type w} [fintype Œπ] (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] [is_separable K L] (b : basis Œπ K L) : is_unit (algebra.discr K ‚áëb)
(C : Type u‚ÇÉ) [category_theory.category C] : C ‚•§ C √ó C
(Œ± : Type u) : Type u
{R : Type u} [comm_ring R] {S : Type u} [comm_ring S] (f : R ‚Üí+* S) (U : topological_space.opens ‚Ü•(algebraic_geometry.prime_spectrum.Top R)) (V : topological_space.opens ‚Ü•(algebraic_geometry.prime_spectrum.Top S)) (hUV : V.val ‚äÜ ‚áë(prime_spectrum.comap f) ‚Åª¬π' U.val) (s : Œ† (x : ‚Ü•U), algebraic_geometry.structure_sheaf.localizations R ‚Üëx) (y : ‚Ü•V) : algebraic_geometry.structure_sheaf.localizations S ‚Üëy
{J : Type v} [category_theory.small_category J] (F : J ‚•§ CommGroup) : category_theory.creates_limit F (category_theory.forget‚ÇÇ CommGroup Group)
(eqs : interactive.parse (lean.parser.many lean.parser.ident)) : tactic unit
{E : Type u_2} [semi_normed_group E] [normed_space ‚Ñù E] {r : ‚Ñù} (hr : 0 < r) : r ‚Ä¢ metric.ball 0 1 = metric.ball 0 r
{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_4} {v : Œπ ‚Üí E} (hv : orthonormal ùïú v) (l : Œπ ‚Üí‚ÇÄ ùïú) (i : Œπ) : has_inner.inner (v i) (‚áë(finsupp.total Œπ E ùïú v) l) = ‚áël i
{Œ± : Sort u_1} (P : Prop) [decidable P] (a b : Œ±) : ite (¬¨P) a b = ite P b a
 : lean.parser pexpr
{Œ≥ : Type u_1} [U : topological_space Œ≥] (m : metric_space Œ≥) (H : U = uniform_space.to_topological_space) : metric_space Œ≥
{C : Type u‚ÇÅ} [category_theory.category C] {X : C} : inhabited (category_theory.sieve X)
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : set Œ±} (h : is_chain r s) : is_chain (flip r) s
{Œ± : Type u} [pseudo_emetric_space Œ±] {s t : set Œ±} {r : ennreal} (H1 : ‚àÄ (x : Œ±), x ‚àà s ‚Üí emetric.inf_edist x t ‚â§ r) (H2 : ‚àÄ (x : Œ±), x ‚àà t ‚Üí emetric.inf_edist x s ‚â§ r) : emetric.Hausdorff_edist s t ‚â§ r
{Œ± : Type u_1} {p : finset Œ± ‚Üí Sort u_2} (H : Œ† (s : finset Œ±), (Œ† (t : finset Œ±), t ‚äÇ s ‚Üí p t) ‚Üí p s) (s : finset Œ±) : p s
 : list expr ‚Üí tactic (list (list name √ó binder_info √ó expr))
{L : first_order.language} (K : set (category_theory.bundled L.Structure)) (M : Type w) [L.Structure M] [L.countable_functions] : Prop
{Œ± : Type} (tac : tactic Œ±) : list expr ‚Üí tactic (list (tactic.tactic_script Œ±))
{n : Type u} [decidable_eq n] [fintype n] {Œ± : Type v} [comm_ring Œ±] [star_ring Œ±] (A : ‚Ü•(matrix.unitary_group n Œ±)) : (n ‚Üí Œ±) ‚âÉ‚Çó[Œ±] n ‚Üí Œ±
{R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N' : Type u_5} [add_comm_group N'] [module R N'] {Œπ : Type u_6} [decidable_eq Œπ] {N'‚ÇÇ : Type u_7} [add_comm_group N'‚ÇÇ] [module R N'‚ÇÇ] [fintype Œπ] (g : N' ‚Üí‚Çó[R] N'‚ÇÇ) (f : multilinear_map R (Œª (_x : Œπ), M) N') : ‚áëmultilinear_map.alternatization (g.comp_multilinear_map f) = ‚áë(g.comp_alternating_map) (‚áëmultilinear_map.alternatization f)
{Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [metric_space Œ≤] {f : Œ± ‚Üí Œ≤} (h : uniform_embedding f) : isometry f
{Œ± : Type u_1} {ùïú : Type u_14} [normed_field ùïú] {l : filter Œ±} {f g : Œ± ‚Üí ùïú} (hgf : ‚àÄ·∂† (x : Œ±) in l, g x = 0 ‚Üí f x = 0) : filter.tendsto (Œª (x : Œ±), f x / g x) l (nhds 0) ‚Üí f =o[l] g
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] (F : C ‚•§ D) [F.additive] : C ‚•§+ D
 : category_theory.has_forget‚ÇÇ CommSemiRing CommMon
{L R : Type v} {fst snd : R ‚Üí L} {A B C : category_theory.limits.walking_multicospan fst snd} (f : A.hom B) (g : B.hom C) : A.hom C
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] (f : S.localization_map N) : localization S ‚âÉ* N
{Œ± : Type u_1} [has_sup Œ±] (sup_comm : ‚àÄ (a b : Œ±), a ‚äî b = b ‚äî a) (sup_assoc : ‚àÄ (a b c : Œ±), a ‚äî b ‚äî c = a ‚äî (b ‚äî c)) (sup_idem : ‚àÄ (a : Œ±), a ‚äî a = a) : semilattice_sup Œ±
{A : Type u_5} [has_add A] : add_subsemigroup A ‚âÉo subsemigroup (multiplicative A)
{Œ± : Type u_2} [fintype Œ±] {ùíú : finset (finset Œ±)} (hùíú : is_antichain has_subset.subset ‚Üëùíú) : ùíú.card ‚â§ (fintype.card Œ±).choose (fintype.card Œ± / 2)
(Œ± : Type u_3) [omega_complete_partial_order Œ±] : Type u_3
(h : expr) : tactic (list expr)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {t : category_theory.limits.cocone F} {D : Type u‚ÇÑ} [category_theory.category D] (G : C ‚•§ D) [category_theory.faithful G] (ht : category_theory.limits.is_colimit (G.map_cocone t)) (desc : Œ† (s : category_theory.limits.cocone F), t.X ‚ü∂ s.X) (h : ‚àÄ (s : category_theory.limits.cocone F), G.map (desc s) = ht.desc (G.map_cocone s)) : category_theory.limits.is_colimit t
(C : Type u_1) [category_theory.category C] [category_theory.monoidal_category C] : category_theory.monoidal_single_obj C
{Œ± : Type u_2} [decidable_eq Œ±] [fintype Œ±] {ùíú : finset (finset Œ±)} {r : ‚Ñï} (hùíú : set.sized r ‚Üëùíú) : ùíú.card * r ‚â§ ùíú.shadow.card * (fintype.card Œ± - r + 1)
{C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_pullbacks C] {A : C} : category_theory.mono_over A ‚•§ category_theory.mono_over A ‚•§ category_theory.mono_over A
{X : Type u_1} [topological_space X] {A : set X} (h : is_clopen A) : discrete_quotient X
 : interactive.parse (lean.parser.many interactive.types.ident_) ‚Üí interactive.parse interactive.types.location ‚Üí tactic unit
{Œπ : Type u_1} {R : Type u_3} (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] [subsingleton M] [is_empty Œπ] : basis Œπ R M
{a : ennreal} : a - ‚ä§ = 0
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} {v : V} (hp : p ‚àà span_points k s) (hv : v ‚àà vector_span k s) : v +·µ• p ‚àà span_points k s
{Œ± : Type u} {Œ≥ : Type w} [non_unital_comm_semiring Œ±] [has_zero Œ≥] [has_add Œ≥] [has_mul Œ≥] [has_scalar ‚Ñï Œ≥] (f : Œ± ‚Üí Œ≥) (hf : function.surjective f) (zero : f 0 = 0) (add : ‚àÄ (x y : Œ±), f (x + y) = f x + f y) (mul : ‚àÄ (x y : Œ±), f (x * y) = f x * f y) (nsmul : ‚àÄ (x : Œ±) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) : non_unital_comm_semiring Œ≥
(Œ± : Type u_1) [linear_ordered_ring Œ±] [archimedean Œ±] : floor_ring Œ±
(S : Type u_3) (G : Type u_4) [div_inv_monoid G] [set_like S G] : Type
{Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) {p : Œ≤ ‚Üí Prop} (h : ‚àÄ (a : Œ±), p (f a)) : Œ± ‚Üí subtype p
{Œπ : Type u_1} {R : Type u_2} {M·µ¢ : Œπ ‚Üí Type u_7} {N·µ¢ : Œπ ‚Üí Type u_8} [ring R] [Œ† (i : Œπ), add_comm_group (M·µ¢ i)] [Œ† (i : Œπ), add_comm_group (N·µ¢ i)] [Œ† (i : Œπ), module R (M·µ¢ i)] [Œ† (i : Œπ), module R (N·µ¢ i)] [fintype Œπ] {Q : Œ† (i : Œπ), quadratic_form R (M·µ¢ i)} {Q' : Œ† (i : Œπ), quadratic_form R (N·µ¢ i)} (e : Œ† (i : Œπ), (Q i).isometry (Q' i)) : (quadratic_form.pi Q).isometry (quadratic_form.pi Q')
 : ‚ÑÇ ‚Üí*‚ÇÄ ‚Ñù
{ùïú : Type u_5} [normed_field ùïú] {ùïú' : Type u_1} [normed_ring ùïú'] [normed_algebra ùïú ùïú'] : normed_space ùïú ùïú'
{Œ± : Type u} [t : topological_space Œ±] [topological_space.separable_space Œ±] {Œπ : Type u_1} {s : Œπ ‚Üí set Œ±} {a : set Œπ} (h : a.pairwise_disjoint s) (ha : ‚àÄ (i : Œπ), i ‚àà a ‚Üí (interior (s i)).nonempty) : a.countable
(p : ‚Ñï) [hp : fact (nat.prime p)] (n : ‚Ñï) : mv_polynomial ‚Ñï ‚Ñö
{R : Type u_1} {M : Type u_7} {M‚ÇÇ : Type u_9} [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] (e : M ‚âÉ+ M‚ÇÇ) (h : ‚àÄ (c : R) (x : M), ‚áëe (c ‚Ä¢ x) = c ‚Ä¢ ‚áëe x) : M ‚âÉ‚Çó[R] M‚ÇÇ
{C : Type v} [category_theory.category C] [category_theory.concrete_category C] {X Y : C} (f : X ‚ü∂ Y) (i : function.injective ‚áëf) : category_theory.mono f
 : tactic bool
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] : function.injective coe
{R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G ‚Üí* R) (hf : function.injective ‚áëf) : is_cyclic G
(env : environment) (emit_workflow_commands : bool) (linter_name : name) (results : native.rb_map name string) : format
{C : Type u‚ÇÅ} [category_theory.category C] (J : category_theory.grothendieck_topology C) (P : C·µí·µñ ‚•§ Type w) : Prop
 : tactic (list (option name √ó string))
(K : Type u‚ÇÅ) [field K] (v : valuation K nnreal) (O : Type u‚ÇÇ) [comm_ring O] [algebra O K] (hv : v.integers O) (p : ‚Ñï) (x : mod_p K v O hv p) : nnreal
(C : Type u) [category_theory.category C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_coreflexive_equalizers C
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {w : Œ± ‚Üí M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : ‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚àà t) (ht : t.nonempty) (hb : s.sum (Œª (x : Œ±), w x) ‚â§ t.card ‚Ä¢ b) : ‚àÉ (y : Œ≤) (H : y ‚àà t), (finset.filter (Œª (x : Œ±), f x = y) s).sum (Œª (x : Œ±), w x) ‚â§ b
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace ‚Ñù P) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] : function.involutive ‚áë(euclidean_geometry.reflection s)
{V : Type u_1} [inner_product_space ‚Ñù V] {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) : inner_product_geometry.angle x y + inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x) = real.pi
(Œ± : Type u_1) : psum (fintype Œ±) (infinite Œ±)
{A : Type u_4} [add_comm_monoid A] (x : A) {B : Type u_5} [add_comm_monoid B] (F : add_submonoid.localization_map.away_map x B) : B
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) [category_theory.is_filtered J] (t : category_theory.limits.cocone F) : AddMon.filtered_colimits.colimit F ‚ü∂ t.X
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P n) (fs : finset (fin (n + 1))) : finset.centroid ‚Ñù fs s.points = ‚áë(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.centroid_weights_with_circumcenter fs)
{ùïú : Type u_1} {Œ± : Type u_2} [linear_ordered_field ùïú] {ùíú : finset (finset Œ±)} [fintype Œ±] (hùíú : is_antichain has_subset.subset ‚Üëùíú) : (finset.range (fintype.card Œ± + 1)).sum (Œª (r : ‚Ñï), ‚Üë((ùíú.slice r).card) / ‚Üë((fintype.card Œ±).choose r)) ‚â§ 1
 : ‚Ñï ‚Üí list (list ‚Ñï √ó omega.term) ‚Üí tactic (list ‚Ñï)
{Œ± : Type u_1} {l : list Œ±} {x : Œ±} : list.duplicate x l ‚Üî ‚àÉ (n : ‚Ñï) (hn : n < l.length) (m : ‚Ñï) (hm : m < l.length) (h : n < m), x = l.nth_le n hn ‚àß x = l.nth_le m hm
 : expr ‚Üí expr
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.monoidal_category C] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) [category_theory.faithful F.to_lax_monoidal_functor.to_functor] {X Y : C} (eval : Y ‚äó X ‚ü∂ ùüô_ C) (coeval : ùüô_ C ‚ü∂ X ‚äó Y) [category_theory.exact_pairing (F.to_lax_monoidal_functor.to_functor.obj X) (F.to_lax_monoidal_functor.to_functor.obj Y)] (map_eval : F.to_lax_monoidal_functor.to_functor.map eval = category_theory.inv (F.to_lax_monoidal_functor.Œº Y X) ‚â´ Œµ_ (F.to_lax_monoidal_functor.to_functor.obj X) (F.to_lax_monoidal_functor.to_functor.obj Y) ‚â´ F.to_lax_monoidal_functor.Œµ) (map_coeval : F.to_lax_monoidal_functor.to_functor.map coeval = category_theory.inv F.to_lax_monoidal_functor.Œµ ‚â´ Œ∑_ (F.to_lax_monoidal_functor.to_functor.obj X) (F.to_lax_monoidal_functor.to_functor.obj Y) ‚â´ F.to_lax_monoidal_functor.Œº X Y) : category_theory.exact_pairing X Y
{Œ± : Type u} [group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_mul.mul has_lt.lt] {a b c : Œ±} : b‚Åª¬π * a < c ‚Üí a < b * c
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} [is_trichotomous Œ± r] [is_irrefl Œ≤ s] (f : r ‚Üír s) : function.injective ‚áëf
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] {A B : C·µí·µñ} (g : A ‚ü∂ B) : category_theory.limits.cokernel g.unop ‚âÖ opposite.unop (category_theory.limits.kernel g)
(Œ± : Type u) : Type u
{C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [category_theory.category C] [category_theory.category D] {G : D ‚•§ C} [category_theory.is_right_adjoint G] (A : (category_theory.adjunction.of_right_adjoint G).to_monad.algebra) [category_theory.limits.has_coequalizer ((category_theory.left_adjoint G).map A.a) ((category_theory.adjunction.of_right_adjoint G).counit.app ((category_theory.left_adjoint G).obj A.A))] : category_theory.limits.cofork (G.map ((category_theory.left_adjoint G).map A.a)) (G.map ((category_theory.adjunction.of_right_adjoint G).counit.app ((category_theory.left_adjoint G).obj A.A)))
{R : Type u_1} {A : Type u_2} [comm_ring R] [ring A] [algebra R A] {c‚ÇÅ c‚ÇÇ : R} (q : quaternion_algebra.basis A c‚ÇÅ c‚ÇÇ) (x : quaternion_algebra R c‚ÇÅ c‚ÇÇ) : A
(Œ± : Type u_6) (Œ≤ : Type u_7) [topological_space Œ±] [preorder Œ±] [topological_space Œ≤] [preorder Œ≤] : Type (max u_6 u_7)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type u} [category_theory.category J] (E : C ‚•§ D) [category_theory.is_equivalence E] [category_theory.limits.has_colimits_of_shape J D] : category_theory.limits.has_colimits_of_shape J C
(R : Type u_5) [semiring R] {Œ∑ : Type u_7} [fintype Œ∑] {M : Type u_1} {Œπs : Œ∑ ‚Üí Type u_2} [add_comm_monoid M] [module R M] : ((Œ£ (j : Œ∑), Œπs j) ‚Üí‚ÇÄ M) ‚âÉ‚Çó[R] Œ† (j : Œ∑), Œπs j ‚Üí‚ÇÄ M
{Œ± : Type u_1} {Œ≤ : Type u_4} [partial_order Œ±] [partial_order Œ≤] {u : Œ≤ ‚Üí Œ±} (l : lower_adjoint u) (x : Œ±) : ‚Ü•(l.closed)
{K : Type u_1} {g : generalized_continued_fraction K} {n : ‚Ñï} [division_ring K] {gp : generalized_continued_fraction.pair K} {ppredA predA : K} (succ_nth_s_eq : g.s.nth (n + 1) = option.some gp) (nth_num_eq : g.numerators n = ppredA) (succ_nth_num_eq : g.numerators (n + 1) = predA) : g.numerators (n + 2) = gp.b * predA + gp.a * ppredA
{ùïú : Type u_1} [is_R_or_C ùïú] {F : Type u_2} [semi_normed_group F] [normed_space ùïú F] (fr : restrict_scalars ‚Ñù ùïú F ‚ÜíL[‚Ñù] ‚Ñù) : F ‚ÜíL[ùïú] ùïú
{K : Type u} [field K] (s : subfield K) (m : multiset K) : (‚àÄ (a : K), a ‚àà m ‚Üí a ‚àà s) ‚Üí m.sum ‚àà s
{R : Type u} {S : Type v} [ring R] [ring S] (f g : R ‚Üí+* S) : subring R
{Œ± : Type u_2} [add_group Œ±] {s t : set Œ±} : disjoint s t ‚Üí 0 ‚àâ s - t
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (c : category_theory.limits.cone F) : category_theory.yoneda.obj c.X ‚ãô category_theory.ulift_functor ‚ü∂ F.cones
{C : Type u} {A : Type u_1} [category_theory.category C] [add_monoid A] [category_theory.has_shift C A] (X : C) (i j : A) : (category_theory.shift_functor C (i + j)).obj X ‚âÖ (category_theory.shift_functor C j).obj ((category_theory.shift_functor C i).obj X)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} (A B : category_theory.limits.cone F) : Type v‚ÇÉ
{et : tactic.ring_exp.ex_type} (ps : tactic.ring_exp.ex et) : expr
{R : Type u} [comm_ring R] (f : polynomial R) : Type u
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (k : ‚Ñï) : lie_submodule R L M
{Œ± : Type u_1} (f : filter Œ±) : filter_basis Œ±
 : (user_attribute simp_lemmas)
 : Pointed_to_Bipointed_fst ‚ä£ Bipointed_to_Pointed_fst
{X Y : AddCommGroup} (f : X ‚ü∂ Y) (hf : category_theory.epi f) : category_theory.normal_epi f
(all_decls non_auto_decls : list declaration) (checks : list (name √ó linter)) : tactic (list (name √ó linter √ó native.rb_map name string))
{C : Type u} {X Y : category_theory.free_monoidal_category C} : X.hom Y ‚Üí Y.hom X
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : A ‚Üí‚Çê[R] module.End R A
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí. Œ≤) (s : set Œ≤) : set Œ±
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Mon) (j : J) (x : ‚Ü•(F.obj j)) : Mon.colimits.colimit_type F
(e : expr) : tactic (list (name √ó expr))
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ‚•§ C) [category_theory.limits.has_limit F] (c : category_theory.limits.cone F) : c.X ‚ü∂ category_theory.limits.limit F
(Œ± : Type u_1) [preorder Œ±] : topological_space Œ±
(f : ‚Ñù ‚Üí ‚Ñù) {a b : ‚Ñù} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfd : differentiable_on ‚Ñù f (set.Ioo a b)) : ‚àÉ (c : ‚Ñù) (H : c ‚àà set.Ioo a b), deriv f c = (f b - f a) / (b - a)
{Œπ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Œπ ‚Üí M} [ring R] [add_comm_group M] [module R M] (hli : linear_independent R v) (hsp : submodule.span R (set.range v) = ‚ä§) : basis Œπ R M
{R' : Type u_1} {Œ± : Type u_2} [non_assoc_semiring R'] [has_zero Œ±] [smul_with_zero R' Œ±] (S : subsemiring R') : smul_with_zero ‚Ü•S Œ±
(n : num) : Prop
{J : Type u‚ÇÅ} [category_theory.category J] (j : category_theory.connected_components J) : Type u‚ÇÅ
(c n : name) (f Œ± Œ≤ : expr) (args‚ÇÄ : list expr) (args‚ÇÅ : list (bool √ó expr)) (rec_call : list expr) : tactic expr
 : pSet ‚Üí Set
{Œ± : Type u_1} [conditionally_complete_lattice Œ±] {s : set Œ±} {a b : Œ±} : bdd_below s ‚Üí a ‚àà s ‚Üí a < b ‚Üí has_Inf.Inf s < b
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : tensor_product R A (polynomial R) ‚âÉ polynomial A
(Œ± : Type u) : Type u
{M : Type u_1} [add_zero_class M] : has_coe (add_con M) (add_submonoid (M √ó M))
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] (a b : Œ±) : finset Œ±
{Œ± : Type u} {R : Type u_1} [monoid Œ±] [ring R] : (Œ± ‚Üí* R) ‚âÉ (free_abelian_group Œ± ‚Üí+* R)
{Œ± : Type u_1} : as_boolalg Œ± ‚âÉ Œ±
{C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C ‚•§ D) {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.limits.preserves_finite_limits F] [category_theory.mono f] (ex : category_theory.exact f g) : category_theory.exact (F.map f) (F.map g)
{Œ± : Type u} [group Œ±] (H : subgroup Œ±) : Œ± ‚Üí[Œ±] Œ± ‚ß∏ H
 : lean.parser (list tactic.eliminate.with_pattern)
 : num ‚Üí pos_num
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} {ps : set P} (h : ps ‚äÜ ‚Üës) [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] : euclidean_geometry.cospherical ps ‚Üî ‚àÉ (center : P) (H : center ‚àà s) (radius : ‚Ñù), ‚àÄ (p : P), p ‚àà ps ‚Üí has_dist.dist p center = radius
{Œ± : Type u} {a b : Œ±} [mul_one_class Œ±] [has_zero Œ±] [preorder Œ±] [zero_lt.mul_pos_strict_mono Œ±] (ha : a < 1) (hb : b ‚â§ 1) (b0 : 0 < b) : a * b < 1
{Œ± : Type u_1} {P : Œ± ‚Üí Prop} [encA : encodable Œ±] [decP : decidable_pred P] (v : ‚Ñï) : option {a // P a}
(R : Type u) {Œπ Œ∑ : Type x} [semiring R] (s : Œπ ‚Üí Œ∑) : (Œπ ‚Üí R) ‚Üí‚Çó[R] Œ∑ ‚Üí R
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddCommGroup) : Type v
 : tactic unit
{C : Type u} [category_theory.groupoid C] (X : C) : group (category_theory.End X)
{Œ± : Type u_1} [partial_order Œ±] (c : closure_operator Œ±) : c = closure_operator.mk‚ÇÉ ‚áëc c.closed _ _ _
{Œ± : Type u_1} {Œ≤ : Type u_2} (t : Œ±) (ts : list Œ±) (r : list Œ≤) (ys : list Œ±) (f : list Œ± ‚Üí Œ≤) : (list.permutations_aux2 t ts list.nil ys f).snd ++ r = (list.permutations_aux2 t ts r ys f).snd
 : lean.parser (tactic.list_Pi tactic.rcases_patt)
{Œ± : Type u_1} [has_one Œ±] [has_zero Œ±] [has_lt Œ±] : has_coe (continued_fraction Œ±) (simple_continued_fraction Œ±)
(ef : expr) : list expr ‚Üí tactic (list expr √ó expr)
{J : Type v} [category_theory.small_category J] (F : J ‚•§ AddMon) [category_theory.is_filtered J] : has_zero (AddMon.filtered_colimits.M F)
(ns : name) : lean.parser string
(e h : expr) : tactic unit
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ‚Ñù P} [nonempty ‚Ü•s] [complete_space ‚Ü•(s.direction)] {p‚ÇÅ : P} (p‚ÇÇ : P) (r : ‚Ñù) (hp‚ÇÅ : p‚ÇÅ ‚àà s) : ‚áë(euclidean_geometry.reflection s) (r ‚Ä¢ (p‚ÇÇ -·µ• ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p‚ÇÇ)) +·µ• p‚ÇÅ) = -(r ‚Ä¢ (p‚ÇÇ -·µ• ‚Üë(‚áë(euclidean_geometry.orthogonal_projection s) p‚ÇÇ))) +·µ• p‚ÇÅ
{E : Type u_1} [normed_group E] [normed_space ‚ÑÇ E] [complete_space E] {f : ‚ÑÇ ‚Üí E} {c : ‚ÑÇ} {R : ‚Ñù} {w : ‚ÑÇ} (hf : circle_integrable f c R) (hw : complex.abs w < R) : (cauchy_power_series f c R).sum w = (2 * ‚Üëreal.pi * complex.I)‚Åª¬π ‚Ä¢ ‚àÆ (z : ‚ÑÇ) in C(c, R), (z - (c + w))‚Åª¬π ‚Ä¢ f z
{G : Type u} [fintype G] [add_group G] (x : G) : fin (add_order_of x) ‚âÉ ‚Ü•‚Üë(add_subgroup.zmultiples x)
 : native.rb_set (expr √ó bool) ‚Üí expr ‚Üí tactic (native.rb_set (expr √ó‚Çó bool))
{F : Type u ‚Üí Type u} [functor F] [q : qpf F] {Œ± : Type u} (g : Œ± ‚Üí F Œ±) (x : Œ±) : qpf.cofix F
{n : ‚Ñï} {Œ± : typevec n} : Œ±.arrow (typevec.subtype_ Œ±.repeat_eq)
 : computability.fin_encoding bool
{R : Type u_1} {S : Type u_2} {M : Type u_3} {Œπ : Type u_4} [comm_semiring R] [semiring S] [add_comm_monoid M] [algebra R S] [module R M] [module S M] [is_scalar_tower R S M] (hinj : function.injective ‚áë(algebra_map R S)) {v : Œπ ‚Üí M} (li : linear_independent S v) : linear_independent R v
{n : ‚Ñï} [fact (0 < n)] (i : zmod n) : order_of (dihedral_group.r i) = n / n.gcd i.val
{Œ± : Type u_2} {G‚ÇÄ : Type u_6} [group_with_zero G‚ÇÄ] [mul_action G‚ÇÄ Œ±] [topological_space Œ±] [has_continuous_const_smul G‚ÇÄ Œ±] {c : G‚ÇÄ} {s : set Œ±} {x : Œ±} (hs : s ‚àà nhds x) (hc : c ‚â† 0) : c ‚Ä¢ s ‚àà nhds (c ‚Ä¢ x)
{M : Type u_1} [monoid M] {N : Type u_2} [monoid N] {f : M ‚Üí N} (hf : is_monoid_hom f) {s : set N} (hs : is_submonoid s) : is_submonoid (f ‚Åª¬π' s)
(f f' : ‚Ñù ‚Üí ‚Ñù) {a b : ‚Ñù} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hff' : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí has_deriv_at f (f' x) x) (g g' : ‚Ñù ‚Üí ‚Ñù) (hgc : continuous_on g (set.Icc a b)) (hgg' : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí has_deriv_at g (g' x) x) : ‚àÉ (c : ‚Ñù) (H : c ‚àà set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Type (max u v)
{g : Type} [random_gen g] : rand_g g ‚Ñï
{G : Type u_1} [add_group G] (H : add_subgroup G) : has_add ‚Ü•H
{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] : ‚Ñï
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {Œπ : Type u_3} {s : finset Œπ} {w‚ÇÅ w‚ÇÇ : Œπ ‚Üí ‚Ñù} (p : Œπ ‚Üí P) (h‚ÇÅ : s.sum (Œª (i : Œπ), w‚ÇÅ i) = 1) (h‚ÇÇ : s.sum (Œª (i : Œπ), w‚ÇÇ i) = 1) : has_dist.dist (‚áë(s.affine_combination p) w‚ÇÅ) (‚áë(s.affine_combination p) w‚ÇÇ) * has_dist.dist (‚áë(s.affine_combination p) w‚ÇÅ) (‚áë(s.affine_combination p) w‚ÇÇ) = -s.sum (Œª (i‚ÇÅ : Œπ), s.sum (Œª (i‚ÇÇ : Œπ), (w‚ÇÅ - w‚ÇÇ) i‚ÇÅ * (w‚ÇÅ - w‚ÇÇ) i‚ÇÇ * (has_dist.dist (p i‚ÇÅ) (p i‚ÇÇ) * has_dist.dist (p i‚ÇÅ) (p i‚ÇÇ)))) / 2
 : Pointed_to_Twop_snd ‚ä£ category_theory.forget‚ÇÇ Twop Bipointed ‚ãô Bipointed_to_Pointed_snd
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} (x : M) (y : ‚Ü•S) : add_localization S
{Œ± : Type u_1} [linear_ordered_field Œ±] {a b c d : Œ±} (hc : c ‚â† 0) (hd : d ‚â† 0) : (a * d - b * c) / (c * d) < 0 ‚Üí a / c < b / d
{Œπ : Type u_1} {Œ± : Type u_2} [has_zero Œ±] [has_le Œ±] : (Œπ ‚Üí‚ÇÄ Œ±) ‚Ü™o (Œπ ‚Üí Œ±)
{Œ± : Type u_1} {s : finset Œ±} {p : finset Œ± ‚Üí Prop} (hu : Œ† (t : finset Œ±), t ‚äÜ s ‚Üí decidable (p t)) : decidable (‚àÉ (t : finset Œ±) (h : t ‚äÜ s), p t)
{Œ± : Sort u_1} {Œ≤ : Œ± ‚Üí Sort u_2} {Œ≥ : Œ± ‚Üí Sort u_3} (e : Œ† (a : Œ±), Œ≤ a ‚Ü™ Œ≥ a) : (Œ† (a : Œ±), Œ≤ a) ‚Ü™ Œ† (a : Œ±), Œ≥ a
 : measure_theory.measure ‚Ü•circle
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] {g : B ‚Üí A} {f : A ‚Üí‚Çê[R] B} (h : function.left_inverse g ‚áëf) : A ‚âÉ‚Çê[R] ‚Ü•(f.range)
{C : Type u‚ÇÅ} [category_theory.category C] {T‚ÇÅ T‚ÇÇ : category_theory.monad C} {f g : T‚ÇÅ ‚ü∂ T‚ÇÇ} (h : f = g) : category_theory.monad.algebra_functor_of_monad_hom f ‚âÖ category_theory.monad.algebra_functor_of_monad_hom g
{J : Type u‚ÇÅ} [category_theory.category J] (j : category_theory.connected_components J) : category_theory.is_connected (category_theory.component j)
{K : Type u_1} {n : ‚Ñï} {g : generalized_continued_fraction K} [linear_ordered_field K] (s_pos : ‚àÄ {gp : generalized_continued_fraction.pair K} {m : ‚Ñï}, m < n ‚Üí g.s.nth m = option.some gp ‚Üí 0 < gp.a ‚àß 0 < gp.b) : g.convergents n = g.convergents' n
 : lean.parser name
(R : Type u_1) [has_zero R] : Type u_1
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C] : category_theory.limits.has_binary_biproducts C
{L : first_order.language} {M : Type w} [L.Structure M] (S : L.substructure M) {A : set M} (h : A ‚äÜ ‚ÜëS) : (L.with_constants ‚Ü•A).substructure M
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Œπ} {C‚ÇÅ C‚ÇÇ C‚ÇÉ : homological_complex V c} {f‚ÇÅ g‚ÇÅ : C‚ÇÅ ‚ü∂ C‚ÇÇ} {f‚ÇÇ g‚ÇÇ : C‚ÇÇ ‚ü∂ C‚ÇÉ} (h‚ÇÅ : homotopy f‚ÇÅ g‚ÇÅ) (h‚ÇÇ : homotopy f‚ÇÇ g‚ÇÇ) : homotopy (f‚ÇÅ ‚â´ f‚ÇÇ) (g‚ÇÅ ‚â´ g‚ÇÇ)
{Œ± : Type u} {Œπ : Sort x} {f : Œπ ‚Üí Œ±} : function.surjective f ‚Üí set.range f = set.univ
{M : Type u_1} [has_mul M] {s : set M} {p : M ‚Üí Prop} {x : M} (h : x ‚àà subsemigroup.closure s) (Hs : ‚àÄ (x : M), x ‚àà s ‚Üí p x) (Hmul : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x * y)) : p x
(deps : bool) (d : name) : tactic (list name)
{P : ‚Ñï ‚Üí Sort u_1} (h : Œ† (n : ‚Ñï), P (n + 1) ‚Üí P n) {m n : ‚Ñï} (mn : m ‚â§ n) (hP : P n) : P m
(R : Type u_1) [monoid_with_zero R] : mul_action_with_zero R R
{Œ± : Type u_1} [fintype Œ±] [encodable Œ±] : Œ± ‚âÉ fin (fintype.card Œ±)
{R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] : exterior_algebra R M ‚Üí‚Çê[R] R
(p : ‚Ñï) [p_prime : fact (nat.prime p)] {q r : ‚Ñö} (hqr : q + r ‚â† 0) : linear_order.min (padic_val_rat p q) (padic_val_rat p r) ‚â§ padic_val_rat p (q + r)
{R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Œπ : Type u_3} [decidable_eq Œπ] [fintype Œπ] [nontrivial R] [nonempty Œπ] (e : basis Œπ R M) (x : orientation R M Œπ) : (e.adjust_to_orientation x).orientation = x
(G : Type u_2) : Type u_2
(Œ± : Type u) : Type u
{K : Type u} [hring : comm_ring K] {R : Type u_1} [has_scalar R (fraction_ring (polynomial K))] : R ‚Üí ratfunc K ‚Üí ratfunc K
{Œ± : Type u_1} [has_le Œ±] (s : lower_set Œ±) : upper_set Œ±
{M : Type u_1} [add_zero_class M] {A : Type u_4} [set_like A M] [hA : add_submonoid_class A M] (S' : A) : has_zero ‚Ü•S'
{R : Type u_1} [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] : p ‚à£ ring_char R ‚Üî p ‚à£ fintype.card R
{ùïú : Type u_1} [linear_ordered_field ùïú] {R : Type u_2} [comm_ring R] (abv : R ‚Üí ùïú) [is_absolute_value abv] : uniform_space R
{Œ± : Type u} {Œ≤ : Type v} {s : set Œ±} {t : set Œ≤} [decidable_pred (Œª (_x : Œ±), _x ‚àà s)] [decidable_pred (Œª (_x : Œ≤), _x ‚àà t)] (e‚ÇÄ : ‚Ü•s ‚âÉ ‚Ü•t) : {e // ‚àÄ (x : ‚Ü•s), ‚áëe ‚Üëx = ‚Üë(‚áëe‚ÇÄ x)} ‚âÉ (‚Ü•s·∂ú ‚âÉ ‚Ü•t·∂ú)
{Œ± : Type u} [topological_space Œ±] [locally_compact_space Œ±] {x : Œ±} {U : set Œ±} (hU : is_open U) (hx : x ‚àà U) : ‚àÉ (K : set Œ±), is_compact K ‚àß x ‚àà interior K ‚àß K ‚äÜ U
 : tactic unit
{Œ± : Type u} [has_sizeof Œ±] (shrink_a : slim_check.shrink_fn Œ±) : slim_check.shrink_fn (tree Œ±)
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (F : C ‚•§ D) : Type (max u‚ÇÅ u‚ÇÇ (v+1))
{R : Type u} {A : Type v} {B : Type w} {C : Type u‚ÇÅ} [comm_semiring R] [semiring A] [semiring B] [semiring C] [algebra R A] [algebra R B] [algebra R C] (œÜ‚ÇÅ : B ‚Üí‚Çê[R] C) (œÜ‚ÇÇ : A ‚Üí‚Çê[R] B) : A ‚Üí‚Çê[R] C
{C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] [category_theory.limits.has_finite_products C] [category_theory.limits.has_finite_products D] (F : C ‚•§ D) {L : D ‚•§ C} [category_theory.cartesian_closed C] [category_theory.cartesian_closed D] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] (h : L ‚ä£ F) (A : C) [i : category_theory.is_iso (category_theory.frobenius_morphism F h A)] : category_theory.is_iso (category_theory.exp_comparison F A)
{Œ± : Type u_1} {Œ≤ : Type u_2} {op : Œ≤ ‚Üí Œ≤ ‚Üí Œ≤} [hc : is_commutative Œ≤ op] [ha : is_associative Œ≤ op] {f : Œ± ‚Üí Œ≤} {b : Œ≤} {s : finset Œ±} [is_idempotent Œ≤ op] {g : Œ± ‚Üí Œ≤} (p : Œ± ‚Üí Prop) [decidable_pred p] : finset.fold op b (Œª (i : Œ±), ite (p i) (f i) (g i)) s = op (finset.fold op b f (finset.filter p s)) (finset.fold op b g (finset.filter (Œª (i : Œ±), ¬¨p i) s))
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {D : Type u‚ÇÑ} [category_theory.category D] {F G : J ‚•§ C} (H : C ‚•§ D) {Œ± : F ‚ü∂ G} {c : category_theory.limits.cocone G} : H.map_cocone ((category_theory.limits.cocones.precompose Œ±).obj c) ‚âÖ (category_theory.limits.cocones.precompose (category_theory.whisker_right Œ± H)).obj (H.map_cocone c)
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] : (Œ± ‚Üío Œ≤) ‚Üío Œ± ‚Üí Œ≤
(Œ± : Type u_1) (Œ≤ : Type u_2) [topological_space Œ±] [topological_space Œ≤] : Prop
(Œ± : Type u_1) : Type u_1
(n : ‚Ñï) : Type
(R : Type u) [comm_semiring R] {S : Type v} [semiring S] [algebra R S] (p : polynomial S) : p ‚àà polynomial.lifts (algebra_map R S) ‚Üî p ‚àà (polynomial.map_alg R S).range
(P L : Type u) [has_mem P L] [configuration.projective_plane P L] : ‚Ñï
(R : Type u_1) (A : Type u_2) (M : Type u_3) (N : Type u_4) [comm_semiring R] [comm_semiring A] [algebra R A] [add_comm_monoid M] [module R M] [module A M] [is_scalar_tower R A M] [add_comm_monoid N] [module R N] : M ‚Üí‚Çó[A] N ‚Üí‚Çó[R] tensor_product R M N
(ùïú : Type u_1) (E : Type u_2) [ordered_ring ùïú] [add_comm_group E] [module ùïú E] : has_inf (geometry.simplicial_complex ùïú E)
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R x y ‚Üí same_ray R (-x) (-y)
{X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] (m : set X ‚Üí ennreal) : measure_theory.measure X
(M : Type u) [monoid M] {F : Type v} [field F] [mul_semiring_action M F] (S : subfield F) : Prop
{Œ± : Type u_1} [decidable_eq Œ±] [partial_order Œ±] [bounded_order Œ±] [is_simple_order Œ±] : Œ± ‚âÉo bool
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : lie_ideal R L
{R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [semiring R] [semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [semi_normed_group E] [semi_normed_group E‚ÇÇ] [module R E] [module R‚ÇÇ E‚ÇÇ] (f : E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ
{Œ± : Type u_1} {Œ≥ : Œ± ‚Üí Type u_3} [encodable Œ±] [Œ† (a : Œ±), encodable (Œ≥ a)] : sigma Œ≥ ‚Üí ‚Ñï
{R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ‚â† 0) : (‚àÄ {d : R}, d ‚à£ a ‚Üí d ‚à£ c ‚Üí ¬¨prime d) ‚Üí a ‚à£ b * c ‚Üí a ‚à£ b
(ùïú : Type u_1) {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {Œπ : Type u_3} [linear_order Œπ] [order_bot Œπ] [locally_finite_order Œπ] [is_well_order Œπ has_lt.lt] [succ_order Œπ] [is_succ_archimedean Œπ] (f : Œπ ‚Üí E) (n : Œπ) (h‚ÇÄ : linear_independent ùïú f) : gram_schmidt ùïú f n ‚â† 0
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (h : b.orientation = o) (x y : V) : o.oangle x y = hb.oangle x y
{Œ± : Type u_1} [decidable_eq Œ±] (s : finset Œ±) : has_bot (finpartition s)
{ùïú : Type u} [nondiscrete_normed_field ùïú] {f g : ùïú ‚Üí ùïú} {f' a : ùïú} (hg : continuous_at g a) (hf : has_deriv_at f f' (g a)) (hf' : f' ‚â† 0) (hfg : ‚àÄ·∂† (y : ùïú) in nhds a, f (g y) = y) : has_deriv_at g f'‚Åª¬π a
{ùïú : Type u_1} {V : Type u_2} [normed_field ùïú] [add_comm_group V] [module ùïú V] : has_top (enorm ùïú V)
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] [algebra R S] {Œπ : Type w} [fintype Œπ] (b : basis Œπ R S) (x : R) : ‚áë(algebra.norm R) (‚áë(algebra_map R S) x) = x ^ fintype.card Œπ
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J ‚•§ C) (F : C ‚•§ D) (c : category_theory.limits.cocone (K ‚ãô F)) : Type (max u‚ÇÅ v‚ÇÅ v‚ÇÇ w)
{Œ± : Type u_1} (s : multiset (multiset Œ±)) : multiset (multiset Œ±)
{Œ± : Type u_2} {Œ≤ : Type u_3} [preorder Œ±] [preorder Œ≤] [bounded_order Œ±] [bounded_order Œ≤] (f : bounded_order_hom Œ± Œ≤) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : bounded_order_hom Œ± Œ≤
{R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} {R‚ÇÉ : Type u_3} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [semiring R‚ÇÉ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : R‚ÇÅ ‚Üí+* R‚ÇÉ} [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] [ring_hom_surjective œÉ‚ÇÅ‚ÇÇ] [ring_hom_surjective œÉ‚ÇÇ‚ÇÉ] : ring_hom_surjective œÉ‚ÇÅ‚ÇÉ
{G‚ÇÄ : Type u_2} [group_with_zero G‚ÇÄ] (a : G‚ÇÄ) : a‚Åª¬π * a * a = a
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] {a : Œ±} : 0 ‚â§ -a ‚Üî a ‚â§ 0
{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (e' : local_equiv Œ≤ Œ≥) (e : Œ± ‚âÉ Œ≤) : local_equiv Œ± Œ≥
{Œ± : Type u_1} {M : Type u_5} {N : Type u_6} [add_comm_monoid M] [add_comm_monoid N] {s : set Œ±} (f : Œ± ‚Üí M) (g : M ‚Üí+ N) (hs : s.finite) : ‚áëg (finsum (Œª (j : Œ±), finsum (Œª (H : j ‚àà s), f j))) = finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), ‚áëg (f i)))
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {X Y : C} (f g : X ‚ü∂ Y) [category_theory.has_split_coequalizer f g] : category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G
{Œ± : Type u} {Œ≤ : Type v} (m : Œ± ‚Üí Œ≤) (f : filter Œ≤) : filter Œ±
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Ring) : category_theory.creates_limit F (category_theory.forget‚ÇÇ Ring SemiRing)
{J : Type v} [category_theory.small_category J] [category_theory.fin_category J] {k : Type v} [field k] (F : J ‚•§ FinVect k) : finite_dimensional k ‚Ü•(category_theory.limits.limit (F ‚ãô category_theory.forget‚ÇÇ (FinVect k) (Module k)))
{R : Type u_1} [comm_ring R] : clifford_algebra 0 ‚âÉ‚Çê[R] dual_number R
{R : Type u_1} [comm_semiring R] {n : Type u_4} [fintype n] [decidable_eq n] : ((n ‚Üí R) ‚Üí‚Çó[R] n ‚Üí R) ‚âÉ‚Çê[R] matrix n n R
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_add Œ±] [add_comm_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_hom f) : is_add_hom (Œª (a : Œ±), -f a)
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [comm_monoid M] (s : finset (Œ± √ó Œ≤)) (f : Œ± √ó Œ≤ ‚Üí M) : finprod (Œª (ab : Œ± √ó Œ≤), finprod (Œª (h : ab ‚àà s), f ab)) = finprod (Œª (a : Œ±), finprod (Œª (b : Œ≤), finprod (Œª (h : (a, b) ‚àà s), f (a, b))))
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : module.is_torsion_by R ‚Ü•(submodule.torsion_by R M a) a
{Œπ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Œπ} {C‚ÇÅ C‚ÇÇ : homological_complex V c} [category_theory.limits.has_zero_object V] (f : C‚ÇÅ.hom C‚ÇÇ) (i : Œπ) : C‚ÇÅ.X_next i ‚ü∂ C‚ÇÇ.X_next i
{Œ± : Type u} (l : list Œ±) (n k : ‚Ñï) (hk : k < l.length) : (l.rotate n).nth_le ((l.length - n % l.length + k) % l.length) _ = l.nth_le k hk
(M : Type u) [add_monoid M] : add_units M ‚Üí+ M
{Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} {x : Œ±} (h : s ‚äÜ t) (hs : s.nonempty) : metric.inf_dist x t ‚â§ metric.inf_dist x s
{Œπ : Type v} (Œ± : Œπ ‚Üí Top) (i : Œπ) : Top.of (Œ† (i : Œπ), ‚Ü•(Œ± i)) ‚ü∂ Œ± i
{p : ‚Ñï} [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : ‚Ñï) (a : kÀ£) (A : witt_vector p k) (bs : fin (n + 1) ‚Üí k) : k
 : tactic ‚Ñï
{G : Type u_1} [comm_group G] (K : subgroup G) {Œπ : Type u_2} {t : finset Œπ} {f : Œπ ‚Üí G} (h : ‚àÄ (c : Œπ), c ‚àà t ‚Üí f c ‚àà K) : t.prod (Œª (c : Œπ), f c) ‚àà K
(G : Type u) [group G] : Type u
{M : Type u_1} [has_mul M] (c : con M) {x y z : M} : ‚áëc x y ‚Üí ‚áëc y z ‚Üí ‚áëc x z
 : Pointed ‚•§ Bipointed
{Œ± : Type u_1} [encodable Œ±] (s : multiset Œ±) : ‚Ñï
{Œ∑ : Type u_1} {Ms : Œ∑ ‚Üí Type u_2} {Ns : Œ∑ ‚Üí Type u_3} [Œ† (j : Œ∑), has_mul (Ms j)] [Œ† (j : Œ∑), has_mul (Ns j)] (es : Œ† (j : Œ∑), Ms j ‚âÉ* Ns j) : (Œ† (j : Œ∑), Ms j) ‚âÉ* Œ† (j : Œ∑), Ns j
{M : Type u_1} [monoid M] [decidable_eq M] {n : M} (p : ‚Ü•(submonoid.powers n)) : ‚Ñï
{F : Type u_1} {E : Type u_2} {K : Type u_3} [field F] [field E] [field K] [algebra F E] [algebra F K] {c : set (intermediate_field.lifts F E K)} (hc : is_chain has_le.le c) : intermediate_field.lifts F E K
(R : Type u) [comm_ring R] (f : R) : (algebraic_geometry.Spec.structure_sheaf R).val.obj (opposite.op (prime_spectrum.basic_open f)) ‚âÖ CommRing.of (localization.away f)
(n : ‚Ñï) : (finset.nat.antidiagonal n).card = n + 1
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] [nonempty Œ±] [topological_space Œ≤] [has_one Œ±] {f : Œ≤ ‚Üí Œ±} (hf : continuous f) (h : has_compact_mul_support f) : bdd_above (set.range f)
{Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] {K : nnreal} {f : Œ± ‚Üí Œ≤} (hf : lipschitz_with K f) : continuous f
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] (p q : polynomial K) : ratfunc K
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {E' : Type u_3} [normed_group E'] [normed_space ùïú E'] {f : E ‚Üí E'} {x : E} {f' : tangent_space (model_with_corners_self ùïú E) x ‚ÜíL[ùïú] tangent_space (model_with_corners_self ùïú E') (f x)} : has_fderiv_at f f' x ‚Üí has_mfderiv_at (model_with_corners_self ùïú E) (model_with_corners_self ùïú E') f x f'
{Œ± : Type u_1} [partial_order Œ±] [pred_order Œ±] {a b : Œ±} [no_min_order Œ±] : a ‚â† b ‚Üí order.pred a ‚â† order.pred b
{X : Type u_1} [topological_space X] [t0_space X] : t0_space (alexandroff X)
{Œ≤ : Type w} {C : Type u} [category_theory.category C] (f : Œ≤ ‚Üí C) [category_theory.limits.has_coproduct f] : C
 : free_comm_ring punit ‚âÉ+* polynomial ‚Ñ§
{Œ± : Type u_1} [normed_division_ring Œ±] : Œ± ‚Üí*‚ÇÄ ‚Ñù
{X Y : Type u} [add_semigroup X] [add_semigroup Y] (e : X ‚âÉ+ Y) : AddSemigroup.of X ‚âÖ AddSemigroup.of Y
{C D : category_theory.Cat} (Œ≥ : C ‚âÖ D) : ‚Ü•C ‚âå ‚Ü•D
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {n : with_top ‚Ñï} [complete_space ùïú] (f : local_homeomorph ùïú ùïú) {f‚ÇÄ' a : ùïú} (h‚ÇÄ : f‚ÇÄ' ‚â† 0) (ha : a ‚àà f.to_local_equiv.target) (hf‚ÇÄ' : has_deriv_at ‚áëf f‚ÇÄ' (‚áë(f.symm) a)) (hf : cont_diff_at ùïú n ‚áëf (‚áë(f.symm) a)) : cont_diff_at ùïú n ‚áë(f.symm) a
{G : Type u_1} [add_group G] (H : add_subgroup G) : add_group ‚Ü•H
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_zero_object V] [category_theory.limits.has_equalizers V] [category_theory.limits.has_cokernels V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] (n : ‚Ñï) : chain_complex.single‚ÇÄ V ‚ãô homology_functor V (complex_shape.down ‚Ñï) (n + 1) ‚âÖ 0
{Œ± : Type u_1} {P : set Œ± ‚Üí Prop} {m : Œ† (s : set Œ±), P s ‚Üí ennreal} {P0 : P ‚àÖ} {m0 : m ‚àÖ P0 = 0} (PU : ‚àÄ ‚¶Éf : ‚Ñï ‚Üí set Œ±‚¶Ñ, (‚àÄ (i : ‚Ñï), P (f i)) ‚Üí P (‚ãÉ (i : ‚Ñï), f i)) (msU : ‚àÄ ‚¶Éf : ‚Ñï ‚Üí set Œ±‚¶Ñ (hm : ‚àÄ (i : ‚Ñï), P (f i)), m (‚ãÉ (i : ‚Ñï), f i) _ ‚â§ ‚àë' (i : ‚Ñï), m (f i) _) (m_mono : ‚àÄ ‚¶És‚ÇÅ s‚ÇÇ : set Œ±‚¶Ñ (hs‚ÇÅ : P s‚ÇÅ) (hs‚ÇÇ : P s‚ÇÇ), s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí m s‚ÇÅ hs‚ÇÅ ‚â§ m s‚ÇÇ hs‚ÇÇ) (s : set Œ±) : measurable_set s ‚Üî ‚àÄ (t : set Œ±), P t ‚Üí ‚áë(measure_theory.induced_outer_measure m P0 m0) (t ‚à© s) + ‚áë(measure_theory.induced_outer_measure m P0 m0) (t  s) ‚â§ ‚áë(measure_theory.induced_outer_measure m P0 m0) t
{Œ± : Type u_1} {Œ≤ : Type u_2} [has_le Œ±] [order_bot Œ±] [has_le Œ≤] : order_bot (Œ± ‚äï‚Çó Œ≤)
 : omega.nat.preform ‚Üí tactic expr
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x : V) : hb.oangle x x = 0
{R : Type u_1} {M : Type u_2} {Œπ : Type u_5} [comm_ring R] [add_comm_group M] [module R M] [decidable_eq Œπ] (b : basis Œπ R M) [fintype Œπ] : basis Œπ R (module.dual R M)
{Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} [is_well_order Œ≤ s] (f : r ‚Ü™r s) : initial_seg r s
{Œ± : Type u} (r s : Œ± ‚Üí Œ± ‚Üí Prop) [is_nonstrict_strict_order Œ± r s] {a b : Œ±} : s a b ‚Üî r a b ‚àß ¬¨r b a
{V : Type u} (G : simple_graph V) (v : V) [fintype ‚Ü•(G.neighbor_set v)] : finset V
{M : Type u_5} [monoid M] {R : Type u_11} [semiring R] [mul_semiring_action M R] {S : Type u_13} [semiring S] [mul_semiring_action M S] {T : Type u_15} [semiring T] [mul_semiring_action M T] (g : S ‚Üí+*[M] T) (f : R ‚Üí+*[M] S) : R ‚Üí+*[M] T
 : Type
{Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : is_preconnected s) (ht : is_clopen t) (hne : (s ‚à© t).nonempty) : s ‚äÜ t
{Œ± : Type u} [add_comm_group Œ±] [has_lt Œ±] [covariant_class Œ± Œ± has_add.add has_lt.lt] {a b c : Œ±} : a + b < c ‚Üí b < c - a
{Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [comm_semiring Œ≤] [comm_semiring Œ≥] (g : Œ≤ ‚Üí+* Œ≥) (f : Œ± ‚Üí Œ≤) (s : finset Œ±) : ‚áëg (s.prod (Œª (x : Œ±), f x)) = s.prod (Œª (x : Œ±), ‚áëg (f x))
{Œ± : Type u} [add_monoid Œ±] (f : ‚Ñï ‚Üí Œ±) (n : ‚Ñï) : (list.map f (list.range n.succ)).sum = f 0 + (list.map (Œª (i : ‚Ñï), f i.succ) (list.range n)).sum
{Œ± : Type u_1} {m : measurable_space Œ±} : measure_theory.simple_func Œ± ennreal ‚Üí‚Çó[ennreal] measure_theory.measure Œ± ‚Üí‚Çó[ennreal] ennreal
{Œ± : Type u_1} {Œ≤ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] {ŒΩ : measure_theory.measure Œ≤} [measure_theory.sigma_finite ŒΩ] {f : Œ± ‚Üí Œ≤ ‚Üí ennreal} (hf : measurable (function.uncurry f)) : measurable (Œª (x : Œ±), ‚à´‚Åª (y : Œ≤), f x y ‚àÇŒΩ)
(K : Type u) {L : Type v} (E : Type z) [field K] [field L] [field E] [algebra K L] [algebra K E] [module.finite K L] [is_alg_closed E] (pb : power_basis K L) [is_separable K L] (e : fin pb.dim ‚âÉ (L ‚Üí‚Çê[K] E)) : ‚áë(algebra_map K E) (algebra.discr K ‚áë(pb.basis)) = (-1) ^ (finite_dimensional.finrank K L * (finite_dimensional.finrank K L - 1) / 2) * finset.univ.prod (Œª (i : fin pb.dim), (finset.filter (Œª (j : fin pb.dim), i < j) finset.univ).prod (Œª (j : fin pb.dim), (‚áë(‚áëe j) pb.gen - ‚áë(‚áëe i) pb.gen) * (‚áë(‚áëe i) pb.gen - ‚áë(‚áëe j) pb.gen)))
{R : Type u‚ÇÅ} [ordered_semiring R] {a : R} (Hsq : 0 ‚â§ a * a) (Hsq' : 0 ‚â§ (1 + a) * (1 + a)) (H : 0 ‚â§ 2 + a) (n : ‚Ñï) : 1 + ‚Üën * a ‚â§ (1 + a) ^ n
(M : Type u_1) (Œ± : Type u_2) [group M] [mul_action M Œ±] {Œπ : Sort u_3} {P : Œπ ‚Üí subgroup M} : mul_action.fixed_points ‚Ü•(supr P) Œ± = ‚ãÇ (i : Œπ), mul_action.fixed_points ‚Ü•(P i) Œ±
{C : Type u‚ÇÅ} [category_theory.category C] (F : C ‚•§ Type v‚ÇÅ) [F.corepresentable] : F.obj F.corepr_X
{R : Type u} [comm_ring R] : compact_space (prime_spectrum R)
{R : Type u} [ring R] (s : subring R) {x y : R} : x ‚àà s ‚Üí y ‚àà s ‚Üí x + y ‚àà s
{L R : Type v} (fst snd : R ‚Üí L) : Type v
(G : Type u) : Type u
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B ‚Üí Type u_5} [nondiscrete_normed_field R] [Œ† (x : B), add_comm_monoid (E x)] [Œ† (x : B), module R (E x)] [normed_group F] [normed_space R F] [topological_space B] (a : topological_vector_prebundle R F E) : topological_vector_bundle R F E
 : ‚áëmeasure_theory.measure_space.volume (‚ãÉ (p : ‚Ñù) (hp : 2 < p), {x : ‚Ñù | liouville_with p x}) = 0
{V : Type u_1} [inner_product_space ‚Ñù V] {x y : V} (hx : x ‚â† 0) (hy : y ‚â† 0) : real.cos (inner_product_geometry.angle x y + inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = -1
{C : Type u‚ÇÅ} [category_theory.category C] {X Y : C} [category_theory.limits.has_pullbacks C] (f : X ‚ü∂ Y) : category_theory.mono_over Y ‚•§ category_theory.mono_over X
{C : Type u‚ÇÅ} [category_theory.category C] {A : Type u‚ÇÇ} [category_theory.category A] (J : category_theory.grothendieck_topology C) (P : C·µí·µñ ‚•§ A) : category_theory.presheaf.is_sheaf J P ‚Üî ‚àÄ ‚¶ÉX : C‚¶Ñ (S : category_theory.sieve X), S ‚àà ‚áëJ X ‚Üí nonempty (category_theory.limits.is_limit (P.map_cone S.arrows.cocone.op))
{Œ± : Type u} [add_group Œ±] [has_le Œ±] [covariant_class Œ± Œ± has_add.add has_le.le] [covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a b : Œ±} : -a ‚â§ b ‚Üí -b ‚â§ a
{Œ± : Type u_1} [generalized_boolean_algebra Œ±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : Œ±) (s : finset Œ±) : finset Œ±
(G : Type u_1) [add_monoid G] : Prop
{J : Type v} [category_theory.small_category J] (F : J ‚•§ Type (max v u)) : category_theory.limits.limit F ‚âÉ ‚Ü•(F.sections)
{C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} {f : X ‚ü∂ Y} (H : algebraic_geometry.PresheafedSpace.is_open_immersion f) (U : topological_space.opens ‚Ü•X) : X.presheaf.obj (opposite.op U) ‚ü∂ Y.presheaf.obj (opposite.op (H.open_functor.obj U))
{X Y Z : Top} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : category_theory.limits.pullback_cone f g
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {f : E ‚Üí F} (K : set (E ‚ÜíL[ùïú] F)) : {x : E | differentiable_at ùïú f x ‚àß fderiv ùïú f x ‚àà K} ‚äÜ fderiv_measurable_aux.D f K
(Œ± : Type u_8) (Œ≤ : Type u_9) [complete_lattice Œ±] [complete_lattice Œ≤] : Type (max u_8 u_9)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X
(x : pgame) : (1 * x).equiv x
(ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] (f : E ‚Üí F) (x : E) : E ‚ÜíL[ùïú] F
 : expr_set ‚Üí expr ‚Üí name_set ‚Üí tactic (bool √ó expr_set)
{Œ± : Type} (cmd : rand Œ±) : io Œ±
{M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} (f : c.quotient ‚Üí* P) : c.lift (f.comp c.mk') _ = f
{Œ± : Type u_1} {r‚ÇÅ r‚ÇÇ : setoid Œ±} : r‚ÇÅ = r‚ÇÇ ‚Üî r‚ÇÅ.rel = r‚ÇÇ.rel
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : list X
{ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_3} [ordered_semiring ùïú] [add_comm_group E] [module ùïú E] {p : Œπ ‚Üí E} (hc : convex_independent ùïú p) : convex_independent ùïú (Œª (x : ‚Ü•(set.range p)), ‚Üëx)
(x y z : ‚Ñ§) : Prop
{R : Type u_1} [add_right_cancel_semigroup R] (g : R) : is_add_right_regular g
(Œπ : Type u_1) (Œ± : Type u_2) [unique Œπ] [uniform_space Œ±] : (Œπ ‚Üí Œ±) ‚âÉ·µ§ Œ±
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : bilin_form R M ‚âÉ‚Çó[‚Ñï] bilin_form R M
{k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {R : Type u_1} [semiring k] [non_unital_non_assoc_semiring R] (f : k ‚Üí+ R) (g : multiplicative G ‚Üí R) : add_monoid_algebra k G ‚Üí+ R
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x y : V) : o.oangle x (-y) + o.oangle y (-x) = 0
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M ‚Üí* P} {T : submonoid P} (hy : ‚àÄ (y : ‚Ü•S), ‚áëg ‚Üëy ‚àà T) {Q : Type u_4} [comm_monoid Q] (k : T.localization_map Q) : N ‚Üí* Q
{Œ± : Type u} (c : computation (computation Œ±)) : computation Œ±
{C : Type u} [category_theory.category C] (X : C·µí·µñ) : category_theory.limits.preserves_limits (category_theory.coyoneda.obj X)
{Œ± : Type u_1} {Œ≤ : Type u_2} [bornology Œ≤] (f : Œ± ‚Üí Œ≤) : bornology Œ±
(C : Type u‚ÇÅ) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u‚ÇÅ v‚ÇÅ)
{A : Type w} (B : Type u‚ÇÅ) {C : Type u_1} {D : Type u_2} [comm_semiring A] [comm_semiring C] [comm_semiring D] [algebra A C] [algebra A D] (f : C ‚Üí‚Çê[A] D) [comm_semiring B] [algebra A B] [algebra B C] [is_scalar_tower A B C] : B ‚Üí‚Çê[A] D
{Œ≤ : Type w} {C : Type u} [category_theory.category C] {f : Œ≤ ‚Üí C} (P : C) (p : Œ† (b : Œ≤), f b ‚ü∂ P) : category_theory.limits.cofan f
 : expr_lens ‚Üí expr ‚Üí expr
{X Y : Type u} [group X] [group Y] (f : X ‚Üí* Y) : Group.of X ‚ü∂ Group.of Y
{Œ± : Type u_1} {E : Œ± ‚Üí Type u_2} {p : ennreal} [Œ† (i : Œ±), normed_group (E i)] [fact (1 ‚â§ p)] : uniform_continuous coe
{Œ± G : Type} [group G] {f : Œ± ‚Üí G} {rels : set (free_group Œ±)} (h : ‚àÄ (r : free_group Œ±), r ‚àà rels ‚Üí ‚áë(‚áëfree_group.lift f) r = 1) : presented_group rels ‚Üí* G
{R : Type u_1} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : ‚Ü•‚ä• ‚âÉ‚Çó[R] punit
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J ‚Üí C) [category_theory.limits.has_biproduct f] (b : J) : f b ‚ü∂ ‚®Å f
{Œ± : Type u} [lattice Œ±] [add_comm_group Œ±] : has_pos_part Œ±
(R : Type u) (Œπ : Type v) [decidable_eq Œπ] (A : Type u_1) [fintype Œπ] [comm_semiring R] [comm_semiring A] [algebra R A] [topological_space A] [has_continuous_mul A] : continuous_multilinear_map R (Œª (i : Œπ), A) A
 : adjoin_one ‚ä£ category_theory.forget‚ÇÇ Mon Semigroup
(t : option expr) (v : expr) : tactic expr
{Œ± : Type u} {Œ≤ : Type v} {M : Type w} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {w : Œ± ‚Üí M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : ‚àÄ (y : Œ≤), y ‚àâ t ‚Üí 0 ‚â§ (finset.filter (Œª (x : Œ±), f x = y) s).sum (Œª (x : Œ±), w x)) (ht : t.nonempty) (hb : s.sum (Œª (x : Œ±), w x) ‚â§ t.card ‚Ä¢ b) : ‚àÉ (y : Œ≤) (H : y ‚àà t), (finset.filter (Œª (x : Œ±), f x = y) s).sum (Œª (x : Œ±), w x) ‚â§ b
{Œ≤ : Type u_2} [topological_space Œ≤] {Œ∫ : Type u_5} {f : Œ∫ ‚Üí Œ≤} (hf : dense_range f) (b : Œ≤) : Œ∫
(R : Type u) (M : Type v) (M‚ÇÇ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M‚ÇÇ] [module R M] [module R M‚ÇÇ] : M √ó M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÇ
(R : Type u) [comm_ring R] (L : Type v) (M : Type w) (N : Type w‚ÇÅ) (P : Type w‚ÇÇ) [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group N] [module R N] [lie_ring_module L N] [lie_module R L N] [add_comm_group P] [module R P] [lie_ring_module L P] [lie_module R L P] : (M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N ‚Üí‚Çó[R] P) ‚âÉ‚Çó[R] tensor_product R M N ‚Üí‚Çó‚ÅÖR,L‚ÅÜ P
{Œ± : Type u_1} {m : multiset Œ±} {Œ≤ : Œ± ‚Üí Type u_2} [h : Œ† (a : Œ±), decidable_eq (Œ≤ a)] : decidable_eq (Œ† (a : Œ±), a ‚àà m ‚Üí Œ≤ a)
{Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] [nonempty Œ±] [topological_space Œ≤] [has_zero Œ±] {f : Œ≤ ‚Üí Œ±} (hf : continuous f) (h : has_compact_support f) : bdd_below (set.range f)
{Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [is_strict_order Œ± r] (f : ‚Ñï ‚Üí Œ±) (H : ‚àÄ (n : ‚Ñï), r (f (n + 1)) (f n)) : gt ‚Ü™r r
(Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) [measurable_space Œ±] [measurable_space Œ≤] [measurable_space Œ≥] : Œ± √ó (Œ≤ ‚äï Œ≥) ‚âÉ·µê Œ± √ó Œ≤ ‚äï Œ± √ó Œ≥
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ùíú : ‚Ñï ‚Üí submodule R A) [graded_algebra ùíú] (x : ‚Ü•(projective_spectrum.Top ùíú)) : ‚Ü•((algebraic_geometry.projective_spectrum.Proj.structure_sheaf ùíú).val.stalk x) ‚âÉ+* ‚Ü•(CommRing.of (homogeneous_localization ùíú (projective_spectrum.as_homogeneous_ideal x).to_ideal))
{Œ± Œ≤ Œ≥ : Type} (p : Œ± ‚Üí Œ≤ √ó Œ≥) [decidable_eq Œ≤] (b' : Œ≤) : list Œ± ‚Üí list Œ≥ √ó list Œ±
{R : Type u_1} {Œπ : Type u_2} {A‚ÇÅ : Œπ ‚Üí Type u_3} {A‚ÇÇ : Œπ ‚Üí Type u_4} [comm_semiring R] [Œ† (i : Œπ), semiring (A‚ÇÅ i)] [Œ† (i : Œπ), semiring (A‚ÇÇ i)] [Œ† (i : Œπ), algebra R (A‚ÇÅ i)] [Œ† (i : Œπ), algebra R (A‚ÇÇ i)] (e : Œ† (i : Œπ), A‚ÇÅ i ‚âÉ‚Çê[R] A‚ÇÇ i) : (Œ† (i : Œπ), A‚ÇÅ i) ‚âÉ‚Çê[R] Œ† (i : Œπ), A‚ÇÇ i
{Œ± : Type u_1} {Œ≤ : Type u_2} (r : Œ± ‚Üí Œ± ‚Üí Prop) (f : filter Œ≤) (u : Œ≤ ‚Üí Œ±) : Prop
{Œ≤ : nat_ordinal ‚Üí Sort u_2} (h : Œ† (a : ordinal), Œ≤ (‚áëordinal.to_nat_ordinal a)) (a : nat_ordinal) : Œ≤ a
{C : Type u‚ÇÅ} [category_theory.category C] {J : Type u‚ÇÇ} [category_theory.category J] (F : J·µí·µñ ‚•§ C·µí·µñ) {c : category_theory.limits.cocone F.unop} (hc : category_theory.limits.is_colimit c) : category_theory.limits.is_limit (category_theory.limits.cone_of_cocone_unop c)
(Œ± : Sort u_1) : (empty ‚Üí Œ±) ‚âÉ punit
{L : first_order.language} {Œ± : Type u'} {Œ≤ : Type v'} (g : Œ± ‚Üí Œ≤) : L.term Œ± ‚Üí L.term Œ≤
 : Meas.Giry.algebra
{ùïú : Type u_1} [nondiscrete_normed_field ùïú] {E : Type u_2} [normed_group E] [normed_space ùïú E] {F : Type u_3} [normed_group F] [normed_space ùïú F] {s : set E} {f : E ‚Üí F} {x : E} {n : with_top ‚Ñï} {p : E ‚Üí formal_multilinear_series ùïú E F} (h : has_ftaylor_series_up_to_on n f p s) {m : ‚Ñï} (hmn : ‚Üëm ‚â§ n) (hs : unique_diff_on ùïú s) (hx : x ‚àà s) : p x m = iterated_fderiv_within ùïú m f s x
{Œ± : Type u_1} [linear_ordered_field Œ±] {a b c : Œ±} (hb : 0 ‚â§ b) (hc : 0 ‚â§ c) (h : a ‚â§ c * b) : a / b ‚â§ c
{ùíú : Type u_1} [category_theory.category ùíú] {A B C : ùíú} [category_theory.abelian ùíú] {f : A ‚ü∂ B} {g : B ‚ü∂ C} (h : category_theory.left_split f g) : category_theory.splitting f g
(t s : expr) : tactic bool
{n : ‚Ñï} (P : mvpfunctor (n + 1)) {Œ± : typevec n} {Œ≤ : Type u} (a : P.A) (f' : (P.drop.B a).arrow Œ±) (f : P.last.B a ‚Üí Œ≤) : P.obj (Œ± ::: Œ≤)
{Œ± : Type u_1} [topological_space Œ±] (R : Type u_3) {M : Type u_5} [topological_space M] [semiring R] [add_comm_monoid M] [has_continuous_add M] [module R M] [has_continuous_const_smul R M] : C(Œ±, M) ‚Üí‚Çó[R] Œ± ‚Üí M
 : expr ‚Üí ‚Ñï √ó tree ‚Ñï
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (X‚ÇÄ X‚ÇÅ : V) (d : X‚ÇÄ ‚ü∂ X‚ÇÅ) (succ' : Œ† (t : Œ£ (X‚ÇÄ X‚ÇÅ : V), X‚ÇÄ ‚ü∂ X‚ÇÅ), Œ£' (X‚ÇÇ : V) (d : t.snd.fst ‚ü∂ X‚ÇÇ), t.snd.snd ‚â´ d = 0) : cochain_complex V ‚Ñï
(Œ± : Type u_1) (Œ≤ : Type u_2) : (option Œ± ‚Ü™ Œ≤) ‚âÉ Œ£ (f : Œ± ‚Ü™ Œ≤), ‚Ü•(set.range ‚áëf)·∂ú
{œÑ : Type u_1} [add_monoid œÑ] [topological_space œÑ] [has_continuous_add œÑ] {Œ± : Type u_2} [topological_space Œ±] (œï : flow œÑ Œ±) {Œ≤ : Type u_3} [topological_space Œ≤] {t : Œ≤ ‚Üí œÑ} (ht : continuous t) {f : Œ≤ ‚Üí Œ±} (hf : continuous f) : continuous (Œª (x : Œ≤), ‚áëœï (t x) (f x))
{Œ± : Type u} {Œ≤ : Type v} [decidable_eq Œ≤] {s : finset Œ±} {t : finset Œ≤} {f : Œ± ‚Üí Œ≤} {n : ‚Ñï} (hf : ‚àÄ (a : Œ±), a ‚àà s ‚Üí f a ‚àà t) (ht : t.nonempty) (hn : t.card * n ‚â§ s.card) : ‚àÉ (y : Œ≤) (H : y ‚àà t), n ‚â§ (finset.filter (Œª (x : Œ±), f x = y) s).card
{R : Type u_2} {M : Type u_3} {N : Type u_4} [comm_semiring R] [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] {m : Type u_1} {n : Type u_5} [fintype m] [fintype n] [decidable_eq m] [decidable_eq n] (bM : basis m R M) (bN : basis n R N) (j : m) (i : n) : ‚áë(linear_map.to_matrix bM bN) (‚áë(dual_tensor_hom R M N) (bM.coord j ‚äó‚Çú[R] ‚áëbN i)) = matrix.std_basis_matrix i j 1
(n : ‚Ñï) (Œ∏ : ‚ÑÇ) : complex.sin ((‚Üën + 1) * Œ∏) = polynomial.eval (complex.cos Œ∏) (polynomial.chebyshev.U ‚ÑÇ n) * complex.sin Œ∏
{L : first_order.language} {F : Type u_1} {M : Type u_2} {N : Type u_3} [L.Structure M] [L.Structure N] [equiv_like F M N] [first_order.language.strong_hom_class L F M N] : F ‚Üí L.equiv M N
(Œ± : Type u_2) [fintype Œ±] [nonempty Œ±] [lattice Œ±] : complete_lattice Œ±
 : ‚Ü•{a : ennreal | a ‚â† ‚ä§} ‚âÉ nnreal
{Œ± : Type u_1} {Œπ : Type u_2} {Œ∫ : Type u_3} (C : (Œπ ‚Üí option Œ±) ‚Üí Œ∫) : Type (max u_1 u_2 u_3)
{E : Type u_1} [normed_group E] [normed_space ‚Ñù E] (v : picard_lindelof E) : ‚Ñù ‚Üí ‚Ü•(set.Icc v.t_min v.t_max)
{n : ‚Ñï} (m : ‚Ñï) (i : fin (n + m)) (h : m ‚â§ ‚Üëi) : fin n
{Œ± : Type u} [ordered_comm_group Œ±] {Œ≤ : Type u_1} [has_one Œ≤] [has_mul Œ≤] [has_inv Œ≤] [has_div Œ≤] [has_pow Œ≤ ‚Ñï] [has_pow Œ≤ ‚Ñ§] (f : Œ≤ ‚Üí Œ±) (hf : function.injective f) (one : f 1 = 1) (mul : ‚àÄ (x y : Œ≤), f (x * y) = f x * f y) (inv : ‚àÄ (x : Œ≤), f x‚Åª¬π = (f x)‚Åª¬π) (div : ‚àÄ (x y : Œ≤), f (x / y) = f x / f y) (npow : ‚àÄ (x : Œ≤) (n : ‚Ñï), f (x ^ n) = f x ^ n) (zpow : ‚àÄ (x : Œ≤) (n : ‚Ñ§), f (x ^ n) = f x ^ n) : ordered_comm_group Œ≤
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (C : chain_complex V ‚Ñï) {X : V} (f : C.X 0 ‚ü∂ X) (w : C.d 1 0 ‚â´ f = 0) : chain_complex V ‚Ñï
{L : first_order.language} {L' : first_order.language} {Œ± : Type u'} (g : L ‚Üí·¥∏ L') : L.formula Œ± ‚Üí L'.formula Œ±
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {S T : subalgebra R A} (h : S ‚â§ T) : ‚Ü•S ‚Üí‚Çê[R] ‚Ü•T
{Œ± : Type u} [topological_space Œ±] [t2_space Œ±] [compact_space Œ±] (x : Œ±) : connected_component x = ‚ãÇ (Z : {Z // is_clopen Z ‚àß x ‚àà Z}), ‚ÜëZ
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Œπ : Type u_4} [invertible 2] (p : Œπ ‚Üí P) (i‚ÇÅ i‚ÇÇ : Œπ) : finset.centroid k {i‚ÇÅ, i‚ÇÇ} p = 2‚Åª¬π ‚Ä¢ (p i‚ÇÇ -·µ• p i‚ÇÅ) +·µ• p i‚ÇÅ
{G : Type u_1} [add_group G] (K : add_subgroup G) {k : set G} : add_subgroup.closure k ‚â§ K ‚Üî k ‚äÜ ‚ÜëK
{R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] [no_zero_divisors R] {B : M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R} (v : basis n R M) (hO : B.is_Ortho ‚áëv) (h : ‚àÄ (i : n), ¬¨B.is_ortho (‚áëv i) (‚áëv i)) : B.nondegenerate
(K : Type u) [field K] : valuation_ring K
{V : Type u_1} [inner_product_space ‚Ñù V] {b : basis (fin 2) ‚Ñù V} (hb : orthonormal ‚Ñù ‚áëb) (x y : V) {r : ‚Ñù} (hr : r < 0) : hb.oangle x (r ‚Ä¢ y) = hb.oangle x (-y)
{R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] {A : Type u_1} [semiring A] [algebra R A] {f g : exterior_algebra R M ‚Üí‚Çê[R] A} (h : f.to_linear_map.comp (exterior_algebra.Œπ R) = g.to_linear_map.comp (exterior_algebra.Œπ R)) : f = g
{C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) {P X Y : C} (f : X ‚ü∂ P) (g : Y ‚ü∂ P) [category_theory.limits.preserves_colimit (category_theory.limits.pair X Y) G] (l : category_theory.limits.is_colimit (category_theory.limits.binary_cofan.mk f g)) : category_theory.limits.is_colimit (category_theory.limits.binary_cofan.mk (G.map f) (G.map g))
(info : tactic.eliminate.constructor_argument_naming_info) : tactic (list name)
{Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚âÉ Œ≤) : Œ± ‚âÉ. Œ≤
 : ‚Ñï ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ
(Œ± : Type u_1) : Type u_1
(x : ‚Ñù*) : Prop
 : expr ‚Üí list name
{Œ≥ : Type u_3} [tŒ≥ : topological_space Œ≥] [polish_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] {Œ≤ : Type u_4} [tŒ≤ : topological_space Œ≤] [t2_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] {f : Œ≥ ‚Üí Œ≤} [topological_space.second_countable_topology Œ≤] (f_meas : measurable f) (f_inj : function.injective f) : measurable_embedding f
 : cardinal.mk ‚Ü•set.univ = cardinal.continuum
{R : Type x} [has_mul R] [has_add R] [left_distrib_class R] (a b c : R) : a * (b + c) = a * b + a * c
{P : Type u_1} [semilattice_sup P] [is_directed P ge] : has_sup (order.ideal P)
(type : expr) : tactic ‚Ñï
{Œ± : Type u_1} [linear_ordered_field Œ±] {m n : ‚Ñï} : ‚Üë(m / n) ‚â§ ‚Üëm / ‚Üën
{V : Type u_1} [inner_product_space ‚Ñù V] [hd2 : fact (finite_dimensional.finrank ‚Ñù V = 2)] (o : orientation ‚Ñù V (fin 2)) (x : V) {r : ‚Ñù} (hr : 0 ‚â§ r) : o.oangle (r ‚Ä¢ x) x = 0
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] {ùíú : ‚Ñï ‚Üí submodule R A} [graded_algebra ùíú] (U : (topological_space.opens ‚Ü•(projective_spectrum.Top ùíú))·µí·µñ) : subring (Œ† (x : ‚Ü•(opposite.unop U)), homogeneous_localization ùíú (projective_spectrum.as_homogeneous_ideal x.val).to_ideal)
{œÑ : Type u_1} [add_comm_group œÑ] [topological_space œÑ] [topological_add_group œÑ] {Œ± : Type u_2} [topological_space Œ±] (œï : flow œÑ Œ±) : flow œÑ Œ±
(tde : tactic_doc_entry) (inh_id : name) : tactic tactic_doc_entry
{Œ± : Type u_1} {Œ≤ : Type u_2} [linear_order Œ±] [pred_order Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : monotone f) : pairwise (disjoint on Œª (n : Œ±), set.Ioc (f (order.pred n)) (f n))
{V : Type u_1} {P : Type u_2} [inner_product_space ‚Ñù V] [metric_space P] [normed_add_torsor V P] {n : ‚Ñï} (s : affine.simplex ‚Ñù P (n + 2)) {i‚ÇÅ i‚ÇÇ : fin (n + 3)} : (s.monge_plane i‚ÇÅ i‚ÇÇ).direction = (submodule.span ‚Ñù {s.points i‚ÇÅ -·µ• s.points i‚ÇÇ})·óÆ ‚äì vector_span ‚Ñù (set.range s.points)
{C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} {f : X ‚ü∂ Y} (H : algebraic_geometry.PresheafedSpace.is_open_immersion f) : topological_space.opens ‚Ü•‚ÜëX ‚•§ topological_space.opens ‚Ü•‚ÜëY
(R : Type u) {Œπ : Type u'} (M‚ÇÇ : Type v‚ÇÇ) [decidable_eq Œπ] [semiring R] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ] [subsingleton Œπ] (i' : Œπ) : multilinear_map R (Œª (_x : Œπ), M‚ÇÇ) M‚ÇÇ
{Œ± : Sort u‚ÇÅ} {Œ≤ : Sort u‚ÇÇ} (f : Œ± ‚Üí Œ≤) : Prop
{M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (f : M ‚Üí+ P) : function.injective ‚áë(add_con.ker_lift f)
{Œ± : Type u_1} (p : Œ± ‚Üí Prop) [decidable_pred p] (l : finset Œ±) (hp : ‚àÉ! (a : Œ±), a ‚àà l ‚àß p a) : Œ±
{Œ± : Type u} [topological_space Œ±] {s : set Œ±} : s.nonempty ‚Üí (closure s).nonempty
{Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [comm_monoid M] [decidable_eq Œ±] [decidable_eq Œ≤] (s : finset (Œ± √ó Œ≤)) (f : Œ± √ó Œ≤ ‚Üí M) : finprod (Œª (ab : Œ± √ó Œ≤), finprod (Œª (h : ab ‚àà s), f ab)) = finprod (Œª (a : Œ±), finprod (Œª (b : Œ≤), finprod (Œª (h : b ‚àà finset.image prod.snd (finset.filter (Œª (ab : Œ± √ó Œ≤), ab.fst = a) s)), f (a, b))))
{Œ± : Sort u} {Œ≤ : Sort v} {p : Œ≤ ‚Üí Prop} (e : Œ± ‚âÉ subtype p) : Œ± ‚Ü™ Œ≤
 : name ‚Üí tactic bool
(R : Type u_1) [comm_ring R] : Prop
{X : Type u_1} {Y : Type u_2} [topological_space X] {f : X ‚Üí Y} (hf : is_locally_constant f) {s : set X} (hs : is_preconnected s) {x y : X} (hx : x ‚àà s) (hy : y ‚àà s) : f x = f y
{V : Type u} {G : simple_graph V} : G.subgraph
 : list name ‚Üí tactic bool
{Œ± : Type u_3} (G : simple_graph Œ±) [decidable_rel G.adj] (s t : finset Œ±) : finset (Œ± √ó Œ±)
{J : Type u‚ÇÅ} [category_theory.category J] {C : Type u‚ÇÉ} [category_theory.category C] {F : J ‚•§ C} {X : C} (h : category_theory.yoneda.obj X ‚ãô category_theory.ulift_functor ‚âÖ F.cones) : category_theory.limits.cone F
{Œπ : Type u_1} {R : Type u_8} [canonically_ordered_comm_semiring R] {f g h : Œπ ‚Üí R} {s : finset Œπ} {i : Œπ} (hi : i ‚àà s) (h2i : g i + h i ‚â§ f i) (hgf : ‚àÄ (j : Œπ), j ‚àà s ‚Üí j ‚â† i ‚Üí g j ‚â§ f j) (hhf : ‚àÄ (j : Œπ), j ‚àà s ‚Üí j ‚â† i ‚Üí h j ‚â§ f j) : s.prod (Œª (i : Œπ), g i) + s.prod (Œª (i : Œπ), h i) ‚â§ s.prod (Œª (i : Œπ), f i)
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {x y : M} (f : M ‚Üí‚Çó[R] N) (h : same_ray R x y) : same_ray R (‚áëf x) (‚áëf y)
(P : pfunctor) : Type u_1
(R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A] : subalgebra R A
{M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] (f : M ‚Üí* N) (H1 : ‚àÄ (y : ‚Ü•S), is_unit (‚áëf ‚Üëy)) (H2 : ‚àÄ (z : N), ‚àÉ (x : M √ó ‚Ü•S), z * ‚áëf ‚Üë(x.snd) = ‚áëf x.fst) (H3 : ‚àÄ (x y : M), ‚áëf x = ‚áëf y ‚Üî ‚àÉ (c : ‚Ü•S), x * ‚Üëc = y * ‚Üëc) : S.localization_map N
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} {F : Top.presheaf C X} {Œπ : Type v} {V : Top} {j : V ‚ü∂ X} (oe : open_embedding ‚áëj) (ùí∞ : Œπ ‚Üí topological_space.opens ‚Ü•V) : Top.presheaf.sheaf_condition_equalizer_products.fork (_.functor.op ‚ãô F) ùí∞ ‚âÖ (category_theory.limits.cones.postcompose (Top.presheaf.sheaf_condition_equalizer_products.diagram.iso_of_open_embedding oe ùí∞).inv).obj (Top.presheaf.sheaf_condition_equalizer_products.fork F (Top.presheaf.sheaf_condition_equalizer_products.cover.of_open_embedding oe ùí∞))
(p : ‚Ñï) : decidable (nat.prime p)
{J K : Type v} [category_theory.small_category J] [category_theory.small_category K] {C : Type u} [category_theory.category C] (F : J ‚•§ K ‚•§ C) [category_theory.limits.has_limits_of_shape K C] [category_theory.limits.has_limit (category_theory.uncurry.obj F)] [category_theory.limits.has_limit (F ‚ãô category_theory.limits.lim)] : category_theory.limits.limit (category_theory.uncurry.obj F) ‚âÖ category_theory.limits.limit (F ‚ãô category_theory.limits.lim)
{R : Type u} [semiring R] (f : polynomial R) (n : ‚Ñï) : polynomial R
{F : Type u_1} [field F] (p : polynomial F) : Type u_1
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {p‚ÇÅ p‚ÇÇ : P} (h : p‚ÇÅ ‚â† p‚ÇÇ) : affine_independent k ![p‚ÇÅ, p‚ÇÇ]
{R : Type u} {A : Type z} [comm_semiring R] [semiring A] [algebra R A] : algebra R (polynomial A)
{G : Type u_1} [add_group G] : complete_lattice (add_subgroup G)
{J : Type v} [category_theory.small_category J] [category_theory.is_filtered J] (F : J ‚•§ Group) : has_inv ‚Ü•(Group.filtered_colimits.G F)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J ‚Üí C) (i : J) [category_theory.limits.has_biproduct f] [category_theory.limits.has_biproduct (subtype.restrict (Œª (j : J), i ‚â† j) f)] : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_œÄ (category_theory.limits.biproduct.to_subtype f (Œª (j : J), i ‚â† j)) _)
{R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra R A] [algebra R B] (f : A ‚Üí‚Çê[R] B) : Prop
{Œ± : Type u_1} [preorder Œ±] [locally_finite_order Œ±] {a b : Œ±} : ¬¨a < b ‚Üí finset.Ico a b = ‚àÖ
{C : Type u} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_morphisms D] (F : C ‚•§ D) [F.preserves_zero_morphisms] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] [category_theory.limits.preserves_binary_biproduct X Y F] : F.obj (X ‚äû Y) ‚âÖ F.obj X ‚äû F.obj Y
{M : Type u_1} [monoid M] (a : M) (u : MÀ£) : is_unit (a * ‚Üëu) ‚Üî is_unit a
(S : Type u_1) (K : out_param (Type u_2)) [field K] [set_like S K] : Type
{Œ± : Type u} {Œ≤ : Type v} [decidable_eq Œ±] [comm_monoid Œ≤] {s : finset Œ±} {x : Œ±} (h : x ‚àâ s) (f : finset Œ± ‚Üí Œ≤) : (has_insert.insert x s).powerset.prod (Œª (a : finset Œ±), f a) = s.powerset.prod (Œª (a : finset Œ±), f a) * s.powerset.prod (Œª (t : finset Œ±), f (has_insert.insert x t))
 : linarith.preprocessor
{Œ± : Type u} [topological_space Œ±] {Œπ : Type v} [hŒπ : nonempty Œπ] (Z : Œπ ‚Üí set Œ±) (hZd : directed superset Z) (hZn : ‚àÄ (i : Œπ), (Z i).nonempty) (hZc : ‚àÄ (i : Œπ), is_compact (Z i)) (hZcl : ‚àÄ (i : Œπ), is_closed (Z i)) : (‚ãÇ (i : Œπ), Z i).nonempty
 : cardinal
{Œπ : Type u‚ÇÅ} {k : Type u‚ÇÇ} {V : Type u‚ÇÉ} {P : Type u‚ÇÑ} [add_comm_group V] [add_torsor V P] [comm_ring k] [module k V] [decidable_eq Œπ] [fintype Œπ] (b b‚ÇÇ : affine_basis Œπ k P) (x : P) : (b.to_matrix b‚ÇÇ.points).det ‚Ä¢ ‚áë(b‚ÇÇ.coords) x = ‚áë((b.to_matrix b‚ÇÇ.points).transpose.cramer) (‚áë(b.coords) x)
{Œ≤ : Type u_2} [emetric_space Œ≤] (a : Œ≤) (r : ennreal) : metric_space ‚Ü•(emetric.ball a r)
{Œ± : Type u_1} {G : Type u_9} [add_group G] : has_scalar ‚Ñ§ (Œ± ‚Üí‚ÇÄ G)
