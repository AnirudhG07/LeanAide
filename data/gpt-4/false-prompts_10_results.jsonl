{"docString": "Every ring is a field.", "choices": ["∀ {R : Type u} [inst : Semiring R], IsField R → Field R ", "Sorry, the statement \"Every ring is a field\" is incorrect and cannot be proven as there are rings that are not fields. A field is a ring with additional properties such as having multiplicative inverses for all non-zero elements.", "∀ (R : Type u) [inst : Semiring R], IsField R ", "∀ {R : Type u} [inst : Semiring R], IsField R → Field R ", "∀ (R : Type u) [inst : Semiring R], IsField R ", "∀ (R : Type u) [inst : Semiring R], IsField R ", "∀ {R : Type u} [inst : Semiring R], IsField R → Field R ", "∀ (R : Type u) [inst : CommRing R], IsField R ", "∀ (R : Type u) [inst : Semiring R], IsField R ", "This statement is false and cannot be proven in Lean. A ring is not necessarily a field."]}
{"docString": "Every vector space is finite dimensional.", "choices": ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V "]}
{"docString": "Every group is a torsion monoid.", "choices": ["∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "/-- Every group is a torsion monoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "forall {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "theorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "forall {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G "]}
{"docString": "Every finite simple group has prime order.", "choices": ["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → ∃ p, Nat.Prime p ∧ Fintype.card α = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [self : IsSimpleGroup G], IsPrime (Fintype.card G) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p [hp : Fact (Nat.Prime p)], Fintype.card G = p ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → ∃ p, Fact (Nat.Prime p) ∧ Fintype.card α = p ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [is_simple : IsSimpleGroup α],\n  ∃ {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → IsPrime (Fintype.card α) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p [hp : Fact (Nat.Prime p)], Fintype.card G = p ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [is_simple : IsSimpleGroup α],\n  ∃ p : ℕ, Nat.Prime p ∧ Fintype.card α = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p [hp : Fact (Nat.Prime p)], Fintype.card G = p "]}
{"docString": "Every finite group is simple.", "choices": ["This statement is incorrect, as not every finite group is simple. Please provide a correct statement to be translated into Lean code.", "This statement is incorrect and cannot be translated to Lean Theorem Prover code. Not every finite group is simple. A simple group is a non-trivial group whose only normal subgroups are the trivial group and the group itself. There exist finite groups that are not simple, such as the symmetric group S4.", "This statement is incorrect and cannot be translated into Lean code. Not every finite group is simple. A simple group is a nontrivial group whose only normal subgroups are the trivial group and the group itself. There are many finite groups that are not simple, such as the symmetric group S_n for n ≥ 3 or any non-abelian finite group with a nontrivial center.", "This statement is incorrect, as not every finite group is simple. Please provide a correct statement to translate.", "This statement is incorrect, as not every finite group is simple. Please provide a correct statement for me to translate into Lean Theorem Prover code.", "This statement is incorrect, as not every finite group is simple. Please provide a correct statement to translate.", "This statement is incorrect and cannot be translated to Lean Theorem Prover code. Not every finite group is simple. Only finite groups of prime order are simple, as stated in the earlier examples.", "This statement is incorrect, as not every finite group is simple. A simple group is a nontrivial group whose only normal subgroups are the trivial group and the group itself. There are many examples of finite groups that are not simple, such as the symmetric group S₃ or the dihedral group D₄. Therefore, I cannot provide a theorem for this statement.", "This statement is incorrect and cannot be proven. Not every finite group is simple. A simple group is a non-trivial group whose only normal subgroups are the trivial group and the group itself. There are many examples of finite groups that are not simple, such as the symmetric group S4 or the dihedral group D4.", "This statement is incorrect and cannot be proven. Not every finite group is simple. For example, the symmetric group S3 is a finite group that is not simple."]}
{"docString": "Every finite group has prime order.", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ", ": ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p [hp : Fact (Nat.Prime p)], Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ", "This statement is incorrect and cannot be translated into Lean Theorem Prover code since there are finite groups that do not have prime order. For example, a group with four elements has order 4, which is not a prime number.", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p "]}
{"docString": "Every set has Lebesgue measure zero.", "choices": ["I can't provide a theorem that states \"every set has Lebesgue measure zero\" as it is incorrect. Some sets, like the entire real line or an interval, do not have measure zero. Please provide a different statement or concept you'd like a theorem for.", "forall {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ↑↑MeasureTheory.volume s = 0 ", "I'm sorry, but that statement is not true.", "∀ (s : Set ℝ), ↑↑MeasureTheory.volume s = 0 ", "forall {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α), ↑↑μ s = 0 ", "∀ (s : Set ℝ), ↑↑MeasureTheory.volume s = 0 ", "I cannot produce a theorem stating that every set has Lebesgue measure zero, as this is not true. The Lebesgue measure of a set depends on its size and properties. Some sets may have Lebesgue measure zero, while others may have a positive measure.", "Sorry, I cannot prove that every set has Lebesgue measure zero as it is not a true statement. Lebesgue measure is a measure that assigns a non-negative \"size\" or \"volume\" to subsets of Euclidean space, and there exist sets with non-zero Lebesgue measure.", "We cannot prove this statement, as it contradicts the properties of the Lebesgue measure.", "∀ (s : Set ℝ), ↑↑MeasureTheory.volume s = 0 "]}
{"docString": "If a topological space is compact, then every subset is compact.", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s "]}
{"docString": "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.", "choices": ["∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  [inst_3 : MeasureTheory.Measure.IsLebesgueMeasure α] {s : Set α},\n  MeasurableSet s → ¬ BorelMeasurable s → ↑↑MeasureTheory.volume s = 0 ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : BorelSpace α] {s : Set α} (μ : MeasureTheory.Measure α),\n  MeasurableSet s → ¬ BorelMeasurableSpace.MeasurableSet' α s → ↑↑μ s = 0 ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : BorelSpace α] (μ : MeasureTheory.Measure α) [inst_2 : MeasureTheory.Measure.IsLebesgueMeasure μ]\n  (s : Set α), MeasurableSet s → BorelMeasurable s → ↑↑μ s ≠ 0 → BorelMeasurable (sᶜ) → ↑↑μ s = 0 ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α] (s : Set α),\n  MeasureTheory.volume s ≠ 0 → BorelMeasurable s ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α] {s : Set α}\n  (μ : MeasureTheory.Measure α), MeasurableSet s → ¬Borel.Set s → ↑↑μ s = 0 ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\n  {s : Set α} (hs : MeasureTheory.LebesgueMeasurable s) (h : ¬MeasurableSet s),\n  ↑↑MeasureTheory.volume s = 0 ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] (s : Set α),\n  MeasureTheory.IsLebesgueMeasurable s ∧ ¬MeasureTheory.IsBorelMeasurable s → MeasureTheory.volume s = 0 ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α),\n  MeasurableSet s → (¬ BorelMeasurable s) → ↑↑μ s = 0 ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : OpensMeasurableSpace α] (h : BorelSpace α) (μ : MeasureTheory.Measure α)\n  (s : Set α), MeasurableSet s → ¬ BorelSet s → ↑↑μ s = 0 ", "forall {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  [inst_3 : TopologicalSpace.SecondCountableTopology α] (m : MeasureTheory.Measure α) (s : Set α),\n  MeasurableSet s → ¬BorelSpace.isBorel s → ↑↑m s = 0 "]}
{"docString": "A finitely-presented group containing a torsion element is finite.", "choices": ["∀ {G : Type u_1} [inst : Group G], (∃ x : G, x ≠ 1 ∧ ∀ n : ℕ, n > 0 → x ^ n = 1 → ∃ m : ℕ, m < n ∧ x ^ m = 1) → Group.FinitePresentation G → Finite G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → Group.FinitePresentation G → Finite G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsFinitelyPresented G → ∃ g, orderOf g > 1 → Finite G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → Group.FinitePresentation G → ∃ (n : ℕ), Fintype.card G = n ", "∀ {G : Type u_1} [inst : Group G], (∃ g, g ≠ 1 ∧ Monoid.IsTorsion G) → Group.FinitelyPresented G → Finite G ", "∀ {G : Type u_1} [inst : Group G],\n  Group.FinitePresentation G → (∃ g, g ≠ 1 ∧ ∃ n, n > 0 ∧ g ^ n = 1) → Finite G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Group.FinitePresentation G],\n  (∃ g, orderOf g ≠ 0) → Finite G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → Monoid.HasFiniteTorsionElement G → Group.FinitelyPresented G → Finite G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Group.FinitelyPresented G],\n  Exists (λ x : G, orderOf x ≠ 0 ∧ orderOf x ≠ 1) → Finite G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → (∃ (x : G), x ≠ 1 ∧ orderOf x ≠ 0) → Group.FinitePresentation G → Finite G "]}
{"docString": "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ t, ∃ u, IsClosed u ∧ x ∈ u ∧ u ⊆ s) → t ⊆ s → IsClosed t ", "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ t, ∃ u, IsClosed u ∧ x ∈ u ∧ u ⊆ s) → t ⊆ s → IsClosed t ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s "]}
{"docString": "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsOpenMap fun (x : α) => (x, x) ", "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsOpenMap (λ x : α, (x, x)) ", "∀ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap (@Prod.mk X X) ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsOpenMap (Function.Diagonal α) ", "∀ {X : Type u_1} [inst : TopologicalSpace X],\n  T2Space X ↔ IsOpenMap (prod.diag X) ", "∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α], IsOpenMap (Function.Diagonal α) ↔ T2Space α ", "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsOpenMap fun (x : α) => (x, x) ", "∀ {X : Type u} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap (λ (x : X), (x, x)) ", "∀ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap (λ (x : X), (x, x)) ", "∀ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap (λ x : X, (x, x)) "]}
{"docString": "Any finite order element in a group is equal to the identity.", "choices": ["∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → orderOf x ≠ 0 → x ^ (orderOf x) = 1 ", "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {x : G}, IsOfFinOrder x → x ^ Fintype.card G = 1 ", "∀ {G : Type u_1} [inst : Monoid G] {x : G} (n : ℕ), n > 0 → x ^ n = 1 → x ^ orderOf x = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {x : G}, IsOfFinOrder x → x ^ Fintype.card G = 1 ", "∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → x ^ Fintype.card G = 1 ", "∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 ", "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 ", "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 ", "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n : ℕ, 0 < n ∧ x ^ n = 1 "]}
{"docString": "If a subgroup of a group is torsion-free, then the group itself is torsion free.", "choices": ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G], (∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree { x // x ∈ H } → H : Subgroup G → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ", "forall {G : Type u_1} [inst : Group G], (∃ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) -> Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G "]}
{"docString": "Every injective homomorphism from a finitely generated free group to itself is surjective.", "choices": ["forall {α : Type u} [inst : Group α] {n : ℕ} (G : FreeGroup α) (h : G →* G),\n  Fintype.card α = n → Function.Injective h → Function.Surjective h ", "∀ {α : Type u} [inst : Group α] [inst_1 : FgFree α] {f : α →* α},\n  Function.Injective ↑f → Function.Surjective ↑f ", "∀ {α : Type u} [inst : Group α] [inst_1 : FgFree α] {f : α →* α},\n  Function.Injective ↑f → Function.Surjective ↑f ", "∀ {G : Type u} [inst : Group G] [inst_1 : IsFinitelyGeneratedFree G] (f : G →* G),\n  Function.Injective ↑f → Function.Surjective ↑f ", "∀ {G : Type u} [inst : Group G] [inst_1 : FgFree G],\n  ∀ (f : G →* G), Function.Injective ↑f → Function.Surjective ↑f ", "∀ {ι : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype ι] {f : FreeGroup ι → G},\n  IsGroupHom f → Function.Injective f → Function.Surjective f ", "∀ {ι : Type u} {G : Type v} [inst : Group G] [inst_1 : Fintype ι] [inst_2 : FreeGroup G ι]\n  (f : G → G) [IsGroupHom f], Function.Injective f → Function.Surjective f ", "∀ {α : Type u} [inst : Group α] [inst_1 : IsFinitelyGenerated α] (f : α →* α),\n  Function.Injective ↑f → Function.Surjective ↑f ", "∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α] [inst_2 : Fintype α] (f : α →* α),\n  Function.Injective ↑f → Function.Surjective ↑f ", "∀ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] {f : G →* G}, Function.Injective ↑f → Function.Surjective ↑f "]}
{"docString": "Every division ring is either a field or finite.", "choices": ["∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ Finite K ", "∀ (K : Type u) [inst : DivisionRing K], IsField K ∨ FiniteDimensional K K ", "∀ {K : Type u} [inst : DivisionRing K], IsField K ∨ FiniteDimensional K K ", "∀ {K : Type u} [inst : DivisionRing K], IsField K ∨ Fintype K ", "∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Finite K ", "∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ FiniteDimensional ℕ K ", "∀ {R : Type u} [inst : DivisionRing R], IsField R ∨ Fintype R ", "∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ IsFinite K ", "∀ {K : Type u} [inst : DivisionRing K], IsField K ∨ ∃ n : ℕ, Fintype.card K = n ", "∀ {K : Type u} [inst : DivisionRing K], IsField K ∨ FiniteDimensional K K "]}
{"docString": "Every natural number is the product of two primes.", "choices": ["∀ (n : ℕ), n > 0 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), 2 ≤ n → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p * q = n ", "∀ (n : ℕ), n > 1 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), n > 1 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), 2 ≤ n → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), n > 0 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), n > 0 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), n > 1 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), 1 < n → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), n > 0 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q "]}
{"docString": "Every even number is the square of a natural number.", "choices": ["This statement is incorrect. There is no theorem that states every even number is the square of a natural number.", "This statement is incorrect. An even number can only be the square of a natural number if it is also a perfect square. For example, 6 is an even number but it is not the square of any natural number.", "This statement is incorrect and cannot be proven in Lean. An example that disproves the statement is the number 2, which is an even number but not the square of a natural number.", "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ", "This statement is incorrect. Not every even number is the square of a natural number.", "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ", "∀ (n : ℕ), Even n → ∃ m, n = m ^ 2 ", "∀ (n : ℕ), Even n → ∃ k, n = 2 * k ^ 2 ", "That statement is incorrect. An even number is not necessarily the square of a natural number. For example, 6 is an even number, but it is not the square of any natural number.", "∀ {n : ℕ}, Even n → ∃ k : ℕ, n = k ^ 2 "]}
{"docString": "Every normal subgroup of a group has finite index.", "choices": ["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0 ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0 ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H → Subgroup.FiniteIndex H → Fintype.card (G ⧸ H) < Cardinal.aleph0 ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Fintype (G ⧸ H) ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.Normal H → Subgroup.FiniteIndex H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0 ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H → Fintype (G ⧸ H) ", "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [self : Subgroup.Normal N], Subgroup.FiniteIndex N ", "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [self : Subgroup.Normal N], Subgroup.FiniteIndex N → Fintype (G ⧸ N) "]}
{"docString": "The characteristic polynomial of every matrix has real roots.", "choices": ["∀ {α : Type u_2} {n : Type u_1} [inst : CommRing α] [inst_1 : Algebra ℝ α] [inst_2 : Fintype n] (A : Matrix n n α),\n  ∃ p : Polynomial ℝ, p ≠ 0 ∧ Polynomial.map (algebraMap ℝ α) p = A.charpoly ", "∀ {n : Type u_1} {R : Type u_2} [inst : CommRing R] [inst_1 : Algebra R ℝ] (M : Matrix n n R),\n  ∃ r : ℝ, r ∈ Polynomial.roots (Matrix.charpoly M) ", "∀ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {α : Type u_2} [inst_2 : CommRing α] [inst_3 : Algebra α ℝ] (M : Matrix n n α),\n  ∃ p : Polynomial ℝ, Polynomial.Monic p ∧ Polynomial.eval₂ (algebraMap α ℝ) M p = 0 ", "∀ {α : Type u_1} {n : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing α] {A : Matrix n n α},\n  ∀ {R : Type u_3} [inst_3 : CommRing R] [inst_4 : Algebra R α], Fintype.card ↑(Polynomial.rootSet (Matrix.charpoly A) R) = Fintype.card n ", "∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra A ℝ] {n : Type u_2} [inst_2 : DecidableEq n] [inst_3 : Fintype n]\n  {M : Matrix n n A}, ∃ p : Polynomial A, p = Matrix.charpoly M ∧ ∀ a : A, Polynomial.IsRoot p a → ↑a ∈ ℝ ", "∀ {n : Type u_1} {R : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing R] [inst_3 : Algebra R ℝ] (A : Matrix n n R),\n  Fintype.card (Matrix.rootSet (Matrix.charpoly A) ℝ) = Fintype.card n ", "∀ {m : Type u_1} [inst : Fintype m] {R : Type u_2} [inst_1 : CommRing R] [inst_2 : Algebra R ℝ] (M : Matrix m m R),\n  Fintype.card ↑(Polynomial.rootSet (Matrix.charpoly M) ℝ) = Fintype.card m ", "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {n : Type u_2} [inst_1 : DecidableEq n] [inst_2 : Fintype n] {A : Matrix n n 𝕜},\n  ∃ p : Polynomial ℝ, Polynomial.Monic p ∧ Polynomial.Eval₂ (algebraMap ℝ 𝕜) (Matrix.charpoly A) p = 0 ", "∀ {α : Type u_2} {n : Type u_1} [inst : CommRing α] [inst_1 : Algebra α ℝ] (A : Matrix n n ℝ),\n  ∃ p : Polynomial α, (↑p.map (algebraMap α ℝ) = A.charpoly) ∧ p.roots = (A.charpoly).roots ", "∀ {α : Type u_1} {n : Type u_2} [inst : CommRing α] [inst_1 : IsDomain α] [inst_2 : ToMatrix α] {A : Matrix n n α},\n  ∃ p : Polynomial ℝ, Polynomial.map (algebraMap α ℝ) (Matrix.charPoly A) = p ∧ ∀ z, Polynomial.IsRoot p z → z = z.re "]}
{"docString": "In a commutative ring, every prime ideal is contained in a unique maximal ideal.", "choices": ["∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P],\n  ∃! M, Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] (I : Ideal R) [hI : Ideal.IsPrime I], ∃! M, Ideal.IsMaximal M ∧ I ≤ M ", "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P], ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P], ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P],\n  ∃! M : Ideal R, Ideal.IsMaximal M ∧ P ≤ M "]}
{"docString": "Every continuous function is uniformly continuous.", "choices": ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α]\n  (f : α → β), Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f "]}
{"docString": "Every uniformly continuous function is bounded above.", "choices": ["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : TopologicalSpace α] [inst_2 : LinearOrder β] [inst_3 : OrderClosedTopology β] \n  [inst_4 : TopologicalSpace β] [inst_5 : Nonempty α] {f : α → β}, \n  UniformContinuous f → BddAbove (Set.range f) ", "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) ", "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] [inst_2 : Nonempty β] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) ", "∀ {α : Type u_1} {β : Type u_2} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] [inst_2 : Nonempty α] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) ", "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : Nonempty α] [inst_3 : BddAbove (Set.range β)] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) ", "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f) ", "∀ {α : Type u_1} {β : Type u_2} [inst : PseudoMetricSpace α] [inst_1 : LinearOrder β] [inst_2 : TopologicalSpace β] [inst_3 : OrderClosedTopology β]\n  {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f) ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : Nonempty α] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : Nonempty α] [inst_2 : SemilatticeSup β] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : PseudoMetricSpace β] [inst_2 : BoundedSpace α] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) "]}
{"docString": "If every compact subset of a topological space is closed, then the space is compact.", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : ∀ (s : Set α), IsCompact s → IsClosed s], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\n  (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : ∀ K : Set α, IsCompact K → IsClosed K], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : ∀ {K : Set α}, IsCompact K → IsClosed K], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : ∀ (s : Set α), IsCompact s → IsClosed s],\n  CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : ∀ (K : Set α), IsCompact K → IsClosed K], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : ∀ {s : Set α}, IsCompact s → IsClosed s], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : ∀ (K : Set α), IsCompact K → IsClosed K], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [h : ∀ s : Set α, IsCompact s → IsClosed s], CompactSpace α "]}
{"docString": "In a commutative ring, the sum of idempotent elements is idempotent.", "choices": ["∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ", "∀ {α : Type u_1} [self : CommRing α] (x y : α), IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y) ", "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ", "∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y) ", "∀ {R : Type u_1} [inst : CommRing R] (e₁ e₂ : R), IsIdempotentElem e₁ → IsIdempotentElem e₂ → IsIdempotentElem (e₁ + e₂) ", "∀ {R : Type u_1} [inst : CommRing R] (e₁ e₂ : R), IsIdempotentElem e₁ → IsIdempotentElem e₂ → IsIdempotentElem (e₁ + e₂) ", "∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y) ", "∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y) ", "∀ {R : Type u_1} [self : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ", "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) "]}
{"docString": "The number of partitions of a finite set is a prime number.", "choices": ["∀ {α : Type u} [inst : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card (Partition α) = p → IsPrime p ", "∀ {α : Type u} [inst : Fintype α] {p : ℕ} [Fact (Nat.Prime p)], Fintype.card {s : Set α} → IsPrimePow (Set.card s) ", "∀ {α : Type u} [inst : Fintype α], Nat.Prime (Part.card (Set α)) ", "∀ {α : Type u} [inst : Fintype α] {p : ℕ}, (Set.Finite {a | a ⊆ (Set.univ : Set α)}) → Nat.Prime (Fintype.card {a | a ⊆ (Set.univ : Set α)}) → IsPrimePow (Fintype.card {a | a ⊆ (Set.univ : Set α)}) ", "∀ {α : Type u} [inst : Fintype α], IsPrime (Partitions α).card ", "∀ {α : Type u} [inst : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card (Partition α) = p ", "∀ {α : Type u} [inst : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card (Set α) = p → IsPrime (Fintype.card (Set (Set α))) ", "∀ {α : Type u} [inst : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card (Partition α) = p → Prime (Fintype.card (Partition α)) ", "∀ {α : Type u} [inst : Fintype α], IsPrime (Fintype.card (SetPart α)) ", "∀ {α : Type u} [inst : Fintype α], Nat.Prime (partitions α) "]}
{"docString": "If a poset has a maximal element, then it has a unique minimal element.", "choices": ["∀ {α : Type u_1} [inst : PartialOrder α] (a : α) (H : ∀ b, a ≤ b → b ≤ a),\n  ∃! c, (∀ d, c ≤ d) ∧ (∀ d, d ≤ c → c = d) ", "∀ {α : Type u_1} [self : PartialOrder α] (s : Set α),\n  (∃ m, IsMaximal s m) → ∃! m, IsMinimal s m ", "∀ {α : Type u_1} [inst : PartialOrder α] {a : α}, (∃ m, ∀ (x : α), x ≤ m) → (∀ (x y : α), x ≤ y ∨ y ≤ x) → ∃! a, ∀ (x : α), x ≤ a ", "∀ {α : Type u_1} [inst : PartialOrder α] {a : α}, IsMaximal a → ∃! b, IsMinimal b ", "∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (a b : α), r a b ∨ r b a) →\n  (∃ m, ∀ (a : α), r m a → r a m) →\n    (∃! m, ∀ (a : α), r a m → r m a) ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : IsStrictTotalOrder α r],\n  (∃ max, ∀ a, r a max) → ∃! min, ∀ a, r min a ", "∀ {α : Type u_1} [inst : PartialOrder α] {s : Set α},\n  (∃ m, ∀ (x : α), x ∈ s → x ≤ m) →\n  (∃! a, a ∈ s ∧ ∀ (x : α), x ∈ s → a ≤ x) ", "∀ {α : Type u_1} [self : PartialOrder α], (∃ m, ∀ (a : α), a ≤ m) → Unique {a : α // ∀ (b : α), b ≤ a} ", "∀ {α : Type u_1} [inst : PartialOrder α] (p : α → Prop),\n  (∃ m, p m ∧ ∀ (a : α), p a → a ≤ m) →\n  (∃! m, p m ∧ ∀ (a : α), p a → m ≤ a) ", "∀ {α : Type u_1} [inst : PartialOrder α] {a : α},\n  (∀ (b : α), a ≤ b → b = a) → (∃! m : α, ∀ (b : α), m ≤ b) "]}
{"docString": "The automorphism group of an Abelian group is cyclic.", "choices": ["∀ {G : Type u_1} [inst : CommGroup G], IsCyclic (Aut G) ", "∀ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G], IsAddCyclic (AddAut G) ", "∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : Fintype (Aut G)], IsCyclic (Aut G) ", "∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : Fintype G], IsCyclic (Aut G) ", "∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : Fintype G], IsCyclic (Aut G) ", "∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : Fintype G], IsCyclic (Aut G) ", "∀ {α : Type u} [inst : CommGroup α], IsCyclic (Aut α) ", "∀ {G : Type u_1} [inst : CommGroup G], IsCyclic (Aut G) ", "∀ {G : Type u_1} [inst : AddCommGroup G] [h : Fintype (Additive G)], IsAddCyclic (AddAut G) ", "∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : Fintype G], IsCyclic (Aut G) "]}
{"docString": "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.", "choices": ["∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : BoundedOrder α] {f : α → α} {x : α},\n  x ∈ Set.Icc (BoundedOrder.min α) (BoundedOrder.max α) → Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} {f : α → α} {x : α} (hf : 0 < Set.card (Function.fixedPoints f)),\n  Function.IsFixedPt f x → ∀ (n : ℕ), n ≠ 0 → ∃ y, Function.IsPeriodicPt f n y ", "∀ {α : Type u_1} {f : α → α} {x : α} (hf : Function.IsFixedPt f x) (n : ℕ),\n  0 < n → Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} [inst : LinearOrder α] {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} {f : α → α} {x : α} (hx : Function.IsFixedPt f x) (n : ℕ) (hn : 0 < n),\n  ∃ y, Function.IsPeriodicPt f n y ", "∀ {α : Type u_1} {f : α → α} {x : α}, (0 < α → Function.IsFixedPt f x) → ∀ (n : ℕ), (0 < n) → ∃ y, Function.IsPeriodicPt f n y ", "∀ {α : Type u_1} {f : α → α} {x : α} (h : Function.IsFixedPt f x) (n : ℕ),\n  0 < n → Function.IsPeriodicPt f n x "]}
{"docString": "The complement of the union of two sets contains the union of their complements.", "choices": ["∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊇ sᶜ ∪ tᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊇ sᶜ ∪ tᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ ⊆ (s ∪ t)ᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ ⊆ (s ∪ t)ᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ ⊆ (s ∪ t)ᶜ "]}
{"docString": "The square root of an rational number is rational.", "choices": ["∀ (q : ℚ), ∃ p : ℚ, p * p = q → Real.sqrt ↑q = ↑p ", "∀ (x : ℚ), ∃ y, Real.sqrt (x.cast ℝ) = y.cast ℝ ", "∀ (q : ℚ), ∃ r, Real.sqrt q = ↑r ", "∀ (q : ℚ), ∃ r, Real.sqrt q = ↑r ", "∀ (q : ℚ), ∃ r : ℚ, r * r = q ", "∀ (q : ℚ), ∃ r, Real.sqrt q = ↑r ", "∀ (q : ℚ), ∃ r : ℚ, r ^ 2 = q ", "∀ (q : ℚ), ∃ r, Real.sqrt q = ↑r ", "∀ (q : ℚ), ∃ r : ℚ, (q = 0 ∧ r = 0) ∨ (0 ≤ q ∧ Real.sqrt (q : ℝ) = r) ", "∀ (q : ℚ), ∃ r, Real.sqrt (Rat.cast q) = Rat.cast r "]}
{"docString": "If a module over a ring is free, then the ring is commutative.", "choices": ["∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R Add.add ", "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [self : Module.Free R M],\n  IsCommutative R (*) ", "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) "]}
{"docString": "If the set of units of a ring forms a group then the ring is commutative.", "choices": ["∀ {R : Type u} [inst : Ring R],\n  (∀ (x y : R), IsUnit x → IsUnit y → IsUnit (x * y)) → (∀ (x y : R), x * y = y * x) ", "∀ {R : Type u} [inst : Ring R] [self : Group (Units R)], ∀ (x y : R), x * y = y * x ", "∀ {R : Type u} [inst : Ring R] [inst_1 : Group (Unit R)], IsCommutative R (*) ", "∀ {α : Type u_1} [inst : Ring α] [inst_1 : IsGroup (α)ˣ], (∀ (x y : α), x * y = y * x) ", "∀ {R : Type u} [inst : Ring R], IsGroup (Units R) → ∀ (x y : R), x * y = y * x ", "∀ {R : Type u} [inst : Semiring R] [inst_1 : Group (Units R)], IsCommutative R (*) ", "∀ {R : Type u} [inst : Ring R] [inst_1 : IsGroup (Units R)], ∀ (x y : R), x * y = y * x ", "∀ {R : Type u} [inst : Ring R], (∀ (a b : R), IsUnit a → IsUnit b → a * b = b * a) → ∀ (x y : R), x * y = y * x ", "∀ {R : Type u} [inst : Ring R], IsGroup (Units R) → ∀ (x y : R), x * y = y * x ", "∀ {R : Type u} [inst : Ring R], (∀ (x : R), IsGroupHom (Ring.units x)) → ∀ (x y : R), x * y = y * x "]}
{"docString": "Every natural number larger than `10` is the sum of a square and a prime.", "choices": ["∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ", "∀ (n : ℕ), 10 < n → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y ", "∀ (n : ℕ), n > 10 → ∃ x y p, n = x ^ 2 + p ∧ Nat.Prime p ", "∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ", "∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ", "∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ", "∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ", "∀ (n : ℕ), n > 10 → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y ", "∀ (n : ℕ), n > 10 → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y ", "∀ (n : ℕ), n > 10 → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y "]}
{"docString": "The initial object of a category is isomorphic to its terminal object.", "choices": ["∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], ⊥_ C ≅ ⊤_ C ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], (⊥_ C) ≅ (⊤_ C) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.Initial.obj ≅ CategoryTheory.Limits.Terminal.obj ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], I ≅ ⊤_ C ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C) "]}
{"docString": "If the composition of two functions is continuous, then each of them is continuous.", "choices": ["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {g : β → γ} {f : α → β},\n  Continuous (g ∘ f) → Continuous f → Continuous g ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ},\n  Continuous (g ∘ f) → Continuous f → Continuous g ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {g : β → γ} {f : α → β},\n  Continuous (g ∘ f) → Continuous f ∧ Continuous g ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f ∧ Continuous g ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ},\n  Continuous (g ∘ f) → Continuous f → Continuous g ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g "]}
{"docString": "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.", "choices": ["∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "forall {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c "]}
{"docString": "If an element maps to zero under a ring homomorphism, then it is zero.", "choices": ["∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S} {r : R},\n  ↑f r = 0 → r = 0 "]}
{"docString": "Implication `→` is symmetric. If `P → Q` then `Q → P`.", "choices": ["This statement is incorrect. Implication `→` is NOT symmetric. Implication is only transitive, but not symmetric. So, I can't provide a theorem for this statement.", "This statement is incorrect, implication is not symmetric. So, there is no theorem for this statement.", "This statement is incorrect, as the implication `→` is NOT symmetric. Implication is only transitive and reflexive, but not symmetric. You might be confusing it with equivalence relations, which are symmetric, reflexive, and transitive.", "This statement is incorrect. Implication `→` is not symmetric. The correct statement is \"implication `→` is contrapositive. If `P → Q`, then `¬Q → ¬P`.\" Here's the theorem for the correct statement:\n\n/-- Implication `→` is contrapositive. If `P → Q`, then `¬Q → ¬P`. -/\ntheorem ∀ {p q : Prop}, (p → q) → (¬q → ¬p) ", "This statement is incorrect, as implication `→` is not symmetric. Implication is only transitive and reflexive, but not symmetric.", "This statement is incorrect. Implication `→` is not symmetric. It means that if `P → Q` is true, it doesn't necessarily mean that `Q → P` is also true.", "This statement is incorrect. Implication `→` is not symmetric.", "This statement is incorrect, as implication is not symmetric. Implication is only transitive and reflexive. You can have cases where P → Q is true, but Q → P is not true.", "This statement is incorrect. Implication `→` is not symmetric. If `P → Q`, it does not imply `Q → P`.", "This statement is incorrect, as implication `→` is not symmetric. A correct statement would be that implication `→` is transitive, which you provided at the beginning. \n\nHere is the Lean code for the transitive property of implication:\n\n```\n/-- Implication `→` is transitive. If `P → Q` and `Q → R` then `P → R`. -/\ntheorem imp_trans {p q r : Prop} (h₁ : p → q) (h₂ : q → r) : p → r "]}
{"docString": "Two natural numbers are equal if and only if they are both divisible by some prime number.", "choices": ["∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ) [Fact (Nat.Prime p)], p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ) [inst : Fact (Nat.Prime p)], p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ (p ∣ m ↔ p ∣ n)) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ (p ∣ m ↔ p ∣ n)) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ) [inst : Fact (Nat.Prime p)], p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n "]}
