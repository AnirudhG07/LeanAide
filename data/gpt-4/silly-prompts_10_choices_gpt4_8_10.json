[{"stmt": "Every prime number is `2` or odd.", "prompts": "[{\"theorem\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"}]\n", "prompt_cons": "/-- `2` is not a factor of an odd natural number. -/\ntheorem ∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2 :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\n  Irreducible p →\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n) :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem ∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- Every prime number is `2` or odd. -/\ntheorem", "choices": ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ", "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ", "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ", "∀ {p : ℕ}, Nat.Prime p → (p = 2 ∨ Odd p) ", "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ", "∀ (p : ℕ), Nat.Prime p → p = 2 ∨ Odd p "]}, {"stmt": "There are infinitely many odd natural numbers.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ (a : α), a ∈ s → f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of finite numbers is still finite \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : ι → WithTop R},\\n  (∀ (i : ι), i ∈ s → f i ≠ ⊤) → (Finset.prod s fun i => f i) < ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A product of finite numbers is still finite \"},\n {\"theorem\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b ∧ Ordinal.omega ≤ b}\",\n  \"isProp\": true,\n  \"docString\": \"Infinite ordinals that are cardinals are unbounded. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem ∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤ :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n] :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem ∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- A sum of finite numbers is still finite -/\ntheorem ∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ (a : α), a ∈ s → f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤ :=\n\n/-- A product of finite numbers is still finite -/\ntheorem ∀ {ι : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : ι → WithTop R},\n  (∀ (i : ι), i ∈ s → f i ≠ ⊤) → (Finset.prod s fun i => f i) < ⊤ :=\n\n/-- Infinite ordinals that are cardinals are unbounded. -/\ntheorem Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b ∧ Ordinal.omega ≤ b} :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q :=\n\n/-- A transcendental real number is irrational. -/\ntheorem ∀ {r : ℝ}, Transcendental ℚ r → Irrational r :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R :=\n\n/-- There are infinitely many odd natural numbers. -/\ntheorem", "choices": ["Filter.frequently (fun m => m % 2 = 1) Filter.atTop ", "Filter.frequently (fun n => n % 2 = 1) Filter.atTop ", "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ", "Filter.frequently (fun x => x % 2 = 1) Filter.atTop ", "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ", "Filter.frequently_of_forall (fun n : ℕ => Nat.odd (2 * n + 1)) ", "Filter.frequently (fun m => m % 2 = 1) Filter.atTop ", "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 ", "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ", "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 "]}, {"stmt": "The smallest odd prime is `3`.", "prompts": "[{\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"}]\n", "prompt_cons": "/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem ∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → Prime (minpoly A x) :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem ∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem ∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q :=\n\n/-- The smallest odd prime is `3`. -/\ntheorem", "choices": ["Nat.min_odd_prime : Nat.minFac 2 + 1 = 3 ", "Nat.min_odd_prime_is_3 : Nat.minFac 9 = 3 ", "Nat.min_odd_prime_is_3 : Nat.min_fac 9 = 3 ", "Nat.min_odd_prime = 3 ", "Nat.min_odd_prime = 3 ", "Nat.min_odd_prime_is_3 : Nat.minFac 9 = 3 ", "Nat.min_odd_prime_is_3 : Nat.min_odd_prime = 3 ", "Nat.min_odd_prime : ℕ ", "Nat.min_odd_prime = 3 ", "Nat.min_odd_prime_is_three : Fact (Nat.min_fac 9 = 3) "]}, {"stmt": "There are infinitely many odd prime numbers.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"theorem\": \"∀ (n : ℕ), ∃ p, n ≤ p ∧ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euclid's theorem on the **infinitude of primes**.\\nHere given in the form: for every `n`, there exists a prime number `p ≥ n`. \"},\n {\"theorem\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : ι → WithTop R},\\n  (∀ (i : ι), i ∈ s → f i ≠ ⊤) → (Finset.prod s fun i => f i) < ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A product of finite numbers is still finite \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\n  Irreducible p →\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n) :=\n\n/-- For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. -/\ntheorem ∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]} :=\n\n/-- Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem ∀ (n : ℕ), ∃ p, n ≤ p ∧ Nat.Prime p :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1 :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem ∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤ :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A product of finite numbers is still finite -/\ntheorem ∀ {ι : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : ι → WithTop R},\n  (∀ (i : ι), i ∈ s → f i ≠ ⊤) → (Finset.prod s fun i => f i) < ⊤ :=\n\n/-- There are infinitely many odd prime numbers. -/\ntheorem", "choices": ["Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p ∧ Odd p} ", "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p ∧ Odd p} ", "Set.Infinite {p | Nat.Prime p ∧ Odd p} ", "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p ∧ Odd p} ", "Set.Infinite {p | Nat.Prime p ∧ Odd p} "]}, {"stmt": "If a vector space has dimension `2` then it is finite dimensional.", "prompts": "[{\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {ι : Type w} [inst_4 : Fintype ι], Basis ι R M → Module.rank R M = ↑(Fintype.card ι)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s → FiniteDimensional k { x // x ∈ vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : StrongRankCondition K] {ι : Type w} [inst_4 : Fintype ι],\\n  Basis ι K V → FiniteDimensional.finrank K V = Fintype.card ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V ≤ 1 ↔ ∃ v₀, ∀ (v : V), ∃ r, r • v₀ = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A vector space has dimension at most `1` if and only if there is a\\nsingle vector of which all vectors are multiples. \"}]\n", "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V :=\n\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem ∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {ι : Type w} [inst_4 : Fintype ι], Basis ι R M → Module.rank R M = ↑(Fintype.card ι) :=\n\n/-- If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- The `vectorSpan` of a finite set is finite-dimensional. -/\ntheorem ∀ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s → FiniteDimensional k { x // x ∈ vectorSpan k s } :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S } :=\n\n/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : StrongRankCondition K] {ι : Type w} [inst_4 : Fintype ι],\n  Basis ι K V → FiniteDimensional.finrank K V = Fintype.card ι :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s :=\n\n/-- A vector space has dimension at most `1` if and only if there is a\nsingle vector of which all vectors are multiples. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V ≤ 1 ↔ ∃ v₀, ∀ (v : V), ∃ r, r • v₀ = v :=\n\n/-- If a vector space has dimension `2` then it is finite dimensional. -/\ntheorem", "choices": ["forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ", "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V "]}, {"stmt": "Every field is a division ring.", "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\\n  [inst_2 : Valued K Γ₀], SeparatedSpace K\",\n  \"isProp\": true,\n  \"docString\": \"A valued division ring is separated. \"},\n {\"theorem\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] [inst_1 : FloorSemiring α] (m n : ℕ), ⌊↑m / ↑n⌋₊ = m / n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is the floor of field division. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\",\n  \"isProp\": true,\n  \"docString\": \"A normed division ring is a topological division ring. \"},\n {\"theorem\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\": \"∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"theorem\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x / y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under division. \"}]\n", "prompt_cons": "/-- A valued division ring is separated. -/\ntheorem ∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\n  [inst_2 : Valued K Γ₀], SeparatedSpace K :=\n\n/-- A field is a valuation ring. -/\ntheorem ∀ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 ∈ S :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 ∈ S :=\n\n/-- An intermediate field is closed under division. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S :=\n\n/-- Natural division is the floor of field division. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedSemifield α] [inst_1 : FloorSemiring α] (m n : ℕ), ⌊↑m / ↑n⌋₊ = m / n :=\n\n/-- A normed division ring is a topological division ring. -/\ntheorem ∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem ∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤ :=\n\n/-- For a semiring to be a field, it must have two distinct elements. -/\ntheorem ∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y :=\n\n/-- A subfield is closed under division. -/\ntheorem ∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x / y ∈ s :=\n\n/-- Every field is a division ring. -/\ntheorem", "choices": ["∀ (K : Type u) [inst : Field K], DivisionRing K ", "∀ (K : Type u) [inst : Field K], DivisionRing K ", "∀ (K : Type u) [inst : Field K], DivisionRing K ", "∀ (K : Type u) [inst : Field K], DivisionRing K ", "∀ (K : Type u) [inst : Field K], DivisionRing K ", "∀ (K : Type u) [inst : Field K], DivisionRing K ", "∀ (K : Type u) [inst : Field K], DivisionRing K ", "∀ {K : Type u_1} [inst : Field K], DivisionRing K ", "∀ (K : Type u) [inst : Field K], DivisionRing K ", "∀ {K : Type u} [inst : Field K], DivisionRing K "]}, {"stmt": "If a space has dimension `2` then it is finite dimensional.", "prompts": "[{\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {M : Type u_2} [inst : AddCommGroup M] {𝕜 : Type u_1} [inst_1 : Field 𝕜] [inst_2 : Module 𝕜 M] (f : M →ₗ[𝕜] M),\\n  ↑LinearMap.det f ≠ 1 → FiniteDimensional 𝕜 M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a linear map has determinant different from `1`, then the space is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst : DiscreteTopology α], Finite α\",\n  \"isProp\": true,\n  \"docString\": \"A compact discrete space is finite. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module 𝕜 E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul 𝕜 F]\\n  [inst_10 : FiniteDimensional 𝕜 E] [inst_11 : FiniteDimensional 𝕜 F], FiniteDimensional 𝕜 (E →L[𝕜] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"}]\n", "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem ∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S } :=\n\n/-- A quotient of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S) :=\n\n/-- If a linear map has determinant different from `1`, then the space is finite-dimensional. -/\ntheorem ∀ {M : Type u_2} [inst : AddCommGroup M] {𝕜 : Type u_1} [inst_1 : Field 𝕜] [inst_2 : Module 𝕜 M] (f : M →ₗ[𝕜] M),\n  ↑LinearMap.det f ≠ 1 → FiniteDimensional 𝕜 M :=\n\n/-- A compact discrete space is finite. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst : DiscreteTopology α], Finite α :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s :=\n\n/-- The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : AddCommGroup E]\n  [inst_3 : Module 𝕜 E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F]\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul 𝕜 F]\n  [inst_10 : FiniteDimensional 𝕜 E] [inst_11 : FiniteDimensional 𝕜 F], FiniteDimensional 𝕜 (E →L[𝕜] F) :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V :=\n\n/-- If a space has dimension `2` then it is finite dimensional. -/\ntheorem", "choices": ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (h : Module.rank K V = 2), FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], \n  findim K V = 2 → FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  (Module.rank K V = 2) → FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  (findim K V = 2) → FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : HasDimension (fin 2) V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], dim K V = 2 → FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι] (h_dim : Fintype.card ι = 2), FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : Findim K V = 2], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], findim K V = 2 → FiniteDimensional K V "]}, {"stmt": "Every natural number has a successor.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"∀ (a : Ordinal.{u}), ∃ f, Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f\",\n  \"isProp\": true,\n  \"docString\": \"Every ordinal has a fundamental sequence. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : AddMonoid ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\\n  [self : DirectSum.GSemiring A] (n : ℕ),\\n  DirectSum.GSemiring.natCast (n + 1) = DirectSum.GSemiring.natCast n + GradedMonoid.GOne.one\",\n  \"isProp\": true,\n  \"docString\":\n  \"The canonical map from ℕ to a graded semiring respects successors.\"},\n {\"theorem\": \"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- Every ordinal has a fundamental sequence. -/\ntheorem ∀ (a : Ordinal.{u}), ∃ f, Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1) :=\n\n/-- The canonical map from ℕ to a graded semiring respects successors. -/\ntheorem ∀ {ι : Type u_1} {A : ι → Type u_2} [inst : AddMonoid ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\n  [self : DirectSum.GSemiring A] (n : ℕ),\n  DirectSum.GSemiring.natCast (n + 1) = DirectSum.GSemiring.natCast n + GradedMonoid.GOne.one :=\n\n/-- If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. -/\ntheorem ∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1 :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Every natural number has a successor. -/\ntheorem", "choices": ["∀ (n : ℕ), ∃ k, n + 1 = k ", "∀ (n : ℕ), ∃ k, n + 1 = k ", "∀ (n : ℕ), ∃ k, n + 1 = k ", "∀ (n : ℕ), ∃ m, n + 1 = m ", "∀ (n : ℕ), ∃ m, m = n + 1 ", "∀ (n : ℕ), ∃ m, m = n + 1 ", "∀ (n : ℕ), ∃ (k : ℕ), k = n + 1 ", "∀ (n : ℕ), ∃ m, m = n + 1 ", "∀ (n : ℕ), ∃ k, n + 1 = k ", "∀ (n : ℕ), ∃ m, m = n + 1 "]}, {"stmt": "Every natural number is less than its successor.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), a ∈ s → a ≤ sSup s\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is less than the set supremum. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ sInf s\",\n  \"isProp\": true,\n  \"docString\": \"Any lower bound is less than the set infimum. \"},\n {\"theorem\": \"∀ {α : Type u_1} [self : CompleteLattice α] (x : α), x ≤ ⊤\",\n  \"isProp\": true,\n  \"docString\": \"Any element is less than the top one. \"},\n {\"theorem\": \"∀ {b m d : ℕ}, 1 < b → d ∈ Nat.digits b m → d < b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b expansion of n are all less than b, if b ≥ 2 \"},\n {\"theorem\": \"∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m n : ℕ}, ↑(m / n) ≤ ↑m / ↑n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is always less than division in the field. \"},\n {\"theorem\": \"∀ {a b : ℕ}, a ∣ b → b < a → b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [self : ZeroLEOneClass α], 0 ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Zero is less than or equal to one. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : Nonempty α] {s : Set α}, Set.Finite s → BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded below.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"}]\n", "prompt_cons": "/-- Any element of a set is less than the set supremum. -/\ntheorem ∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), a ∈ s → a ≤ sSup s :=\n\n/-- Any lower bound is less than the set infimum. -/\ntheorem ∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ sInf s :=\n\n/-- Any element is less than the top one. -/\ntheorem ∀ {α : Type u_1} [self : CompleteLattice α] (x : α), x ≤ ⊤ :=\n\n/-- The digits in the base b expansion of n are all less than b, if b ≥ 2 -/\ntheorem ∀ {b m d : ℕ}, 1 < b → d ∈ Nat.digits b m → d < b :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem ∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2 :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m n : ℕ}, ↑(m / n) ≤ ↑m / ↑n :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem ∀ {a b : ℕ}, a ∣ b → b < a → b = 0 :=\n\n/-- Zero is less than or equal to one. -/\ntheorem ∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [self : ZeroLEOneClass α], 0 ≤ 1 :=\n\n/-- A finite set is bounded below. -/\ntheorem ∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : Nonempty α] {s : Set α}, Set.Finite s → BddBelow s :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R :=\n\n/-- Every natural number is less than its successor. -/\ntheorem", "choices": ["∀ {n : ℕ}, n < Nat.succ n ", "∀ (n : ℕ), n < n.succ ", "∀ {n : ℕ}, n < n.succ ", "∀ {n : ℕ}, n < n.succ ", "∀ (n : ℕ), n < n.succ ", "∀ (n : ℕ), n < n.succ ", "∀ {n : ℕ}, n < n.succ ", "∀ (n : ℕ), n < n + 1 ", "∀ (n : ℕ), n < n + 1 ", "∀ (n : ℕ), n < n.succ "]}, {"stmt": "Every set is Lebesgue measurable.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"theorem\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\\n  ∃ t, s ⊆ t ∧ MeasurableSet t ∧ ↑↑μ t = ↑↑μ s\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every set there exists a measurable superset of the same measure. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\\n  OpensMeasurableSpace α\",\n  \"isProp\": true,\n  \"docString\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  [inst_3 : LinearOrder α] [inst_4 : OrderTopology α] [inst_5 : TopologicalSpace.SecondCountableTopology α] {s : Set α},\\n  (∀ (x : α), x ∈ s → s ∈ nhdsWithin x (Set.Ioi x)) → MeasurableSet s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {f : α → ℝ}, Measurable f → MeasurableSet {p | p.snd = f p.fst}\",\n  \"isProp\": true,\n  \"docString\": \"The graph of a measurable function is a measurable set. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {γ : Type u_1} [tγ : TopologicalSpace γ] [inst : PolishSpace γ] [inst : MeasurableSpace γ]\\n  {β : Type u_3} [inst_1 : MeasurableSpace β] [hγ : OpensMeasurableSpace γ] [inst_2 : Countable ι] {l : Filter ι}\\n  [inst_3 : Filter.IsCountablyGenerated l] {f : ι → β → γ},\\n  (∀ (i : ι), Measurable (f i)) → MeasurableSet {x | ∃ c, Filter.Tendsto (fun n => f n x) l (nhds c)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of points for which a measurable sequence of functions converges is measurable. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E → F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableAt 𝕜 f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ℝ F] (f : ℝ → F) [inst_2 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableWithinAt ℝ f (Set.Ici x) x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of right differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_3) [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E → F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] {K : Set (E →L[𝕜] F)},\\n  IsComplete K → MeasurableSet {x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function, with derivative in a given complete set,\\nis Borel-measurable. \"}]\n", "prompt_cons": "/-- For the outer measure coming from a content, all Borel sets are measurable. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ) :=\n\n/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem ↑↑MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- For every set there exists a measurable superset of the same measure. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\n  ∃ t, s ⊆ t ∧ MeasurableSet t ∧ ↑↑μ t = ↑↑μ s :=\n\n/-- In a `BorelSpace` all open sets are measurable. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\n  OpensMeasurableSpace α :=\n\n/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  [inst_3 : LinearOrder α] [inst_4 : OrderTopology α] [inst_5 : TopologicalSpace.SecondCountableTopology α] {s : Set α},\n  (∀ (x : α), x ∈ s → s ∈ nhdsWithin x (Set.Ioi x)) → MeasurableSet s :=\n\n/-- The graph of a measurable function is a measurable set. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {f : α → ℝ}, Measurable f → MeasurableSet {p | p.snd = f p.fst} :=\n\n/-- The set of points for which a measurable sequence of functions converges is measurable. -/\ntheorem ∀ {ι : Type u_2} {γ : Type u_1} [tγ : TopologicalSpace γ] [inst : PolishSpace γ] [inst : MeasurableSpace γ]\n  {β : Type u_3} [inst_1 : MeasurableSpace β] [hγ : OpensMeasurableSpace γ] [inst_2 : Countable ι] {l : Filter ι}\n  [inst_3 : Filter.IsCountablyGenerated l] {f : ι → β → γ},\n  (∀ (i : ι), Measurable (f i)) → MeasurableSet {x | ∃ c, Filter.Tendsto (fun n => f n x) l (nhds c)} :=\n\n/-- The set of differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem ∀ (𝕜 : Type u_2) [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E → F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableAt 𝕜 f x} :=\n\n/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ℝ F] (f : ℝ → F) [inst_2 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableWithinAt ℝ f (Set.Ici x) x} :=\n\n/-- The set of differentiability points of a function, with derivative in a given complete set,\nis Borel-measurable. -/\ntheorem ∀ (𝕜 : Type u_3) [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E → F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] {K : Set (E →L[𝕜] F)},\n  IsComplete K → MeasurableSet {x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K} :=\n\n/-- Every set is Lebesgue measurable. -/\ntheorem", "choices": ["∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α] [inst_3 : LebesgueMeasurableSpace α],\n  ∀ (s : Set α), MeasurableSet s ", "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.Measure.subsingleton α], ∀ (s : Set α), MeasurableSet s ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α] [inst_3 : OpensMeasurableSpace α], \n  ∀ (s : Set α), MeasurableSet s ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α], LebesgueMeasurable α ", "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α], OpensMeasurableSpace α ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α],\n  LebesgueMeasurableSpace α ", "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s "]}, {"stmt": "Every set of Borel measure zero is Lebesgue measurable.", "prompts": "[{\"theorem\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ν],\\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\\n  Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\\n  OpensMeasurableSpace α\",\n  \"isProp\": true,\n  \"docString\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α]\\n  (m : MeasureTheory.OuterMeasure α) (s : Set α), (∀ (x : α), x ∈ s → ∃ u, u ∈ nhdsWithin x s ∧ ↑m u = 0) → ↑m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant ν],\\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\\n  Metric.Bounded s →\\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ℝ F] (f : ℝ → F) [inst_2 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableWithinAt ℝ f (Set.Ici x) x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of right differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E → F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableAt 𝕜 f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"}]\n", "prompt_cons": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem ↑↑MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- For the outer measure coming from a content, all Borel sets are measurable. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ) :=\n\n/-- Left invariant Borel measures on a measurable group are unique (up to a scalar). -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant μ]\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ν],\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\n  Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0 :=\n\n/-- In a `BorelSpace` all open sets are measurable. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\n  OpensMeasurableSpace α :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α]\n  (m : MeasureTheory.OuterMeasure α) (s : Set α), (∀ (x : α), x ∈ s → ∃ u, u ∈ nhdsWithin x s ∧ ↑m u = 0) → ↑m s = 0 :=\n\n/-- Left invariant Borel measures on an additive measurable group are unique (up to a scalar). -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd₂ G]\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant μ]\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant ν],\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\n  Metric.Bounded s →\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0 :=\n\n/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ℝ F] (f : ℝ → F) [inst_2 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableWithinAt ℝ f (Set.Ici x) x} :=\n\n/-- The set of differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem ∀ (𝕜 : Type u_2) [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E → F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableAt 𝕜 f x} :=\n\n/-- Every set of Borel measure zero is Lebesgue measurable. -/\ntheorem", "choices": ["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) {s : Set α}, ↑↑μ s = 0 → MeasurableSet s ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), ↑↑μ s = 0 → MeasurableSet s ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) {s : Set α}, ↑↑μ s = 0 → MeasurableSet s ", "forall {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) {s : Set α},\n  MeasureTheory.volume s = 0 → MeasurableSet s ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) {s : Set α}, ↑↑μ s = 0 → MeasurableSet s ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α]\n  (μ : MeasureTheory.Measure α) {s : Set α}, ↑↑μ s = 0 → MeasurableSet s ", "∀ {α : Type u_1} [inst : MeasureTheory.MeasureSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\n  MeasureTheory.Measure.ZeroLebesgueMeasurableSpace α ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α] (μ : MeasureTheory.Measure α)\n  {s : Set α}, ↑↑μ s = 0 → MeasurableSet s ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), ↑↑μ s = 0 → MeasurableSet s ", "∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) {s : Set α},\n  ↑↑μ s = 0 → MeasurableSet s "]}, {"stmt": "No prime number is a perfect square.", "prompts": "[{\"theorem\": \"∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between m² and (m+1)² \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I], I ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\": \"The prime ideal is not the entire ring. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"}]\n", "prompt_cons": "/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem ∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem ∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2 :=\n\n/-- The prime ideal is not the entire ring. -/\ntheorem ∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I], I ≠ ⊤ :=\n\n/-- No zero divisors. -/\ntheorem ∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\n  Irreducible p →\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n) :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem ∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1 :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem ∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n :=\n\n/-- No prime number is a perfect square. -/\ntheorem", "choices": ["∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ", "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ", "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ", "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ", "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ", "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ", "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ", "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ", "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ", "∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p "]}, {"stmt": "Every odd prime number is greater than `2`.", "prompts": "[{\"theorem\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\": \"∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"∀ (n : ℕ), n ≠ 0 → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\\nit, but no more than twice as large.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"}]\n", "prompt_cons": "/-- `2` is not a factor of an odd natural number. -/\ntheorem ∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\n  Irreducible p →\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n) :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem ∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem ∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2) :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- **Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large. -/\ntheorem ∀ (n : ℕ), n ≠ 0 → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1) :=\n\n/-- Every odd prime number is greater than `2`. -/\ntheorem", "choices": ["∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p > 2 ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ", "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Odd p → p > 2 ", "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Odd p → p > 2 ", "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Odd p → p > 2 ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 "]}, {"stmt": "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.", "prompts": "[{\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Euler's four-square identity**. \"},\n {\"theorem\": \"∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\",\n  \"isProp\": true,\n  \"docString\": \"**Four squares theorem** \"},\n {\"theorem\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (m k : ℕ),\\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\\n  p * q =\\n    Finset.sum (Polynomial.support p) fun i =>\\n      Polynomial.sum q fun j a => ↑(Polynomial.monomial (i + j)) (Polynomial.coeff p i * a)\",\n  \"isProp\": true,\n  \"docString\": \"Expressing the product of two polynomials as a double sum. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"}]\n", "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem ∀ (a b c d x y z w : ℕ),\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- **Euler's four-square identity**. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\n      (a * w + b * z - c * y + d * x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- **Four squares theorem** -/\ntheorem ∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] (m k : ℕ),\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k :=\n\n/-- Expressing the product of two polynomials as a double sum. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\n  p * q =\n    Finset.sum (Polynomial.support p) fun i =>\n      Polynomial.sum q fun j a => ↑(Polynomial.monomial (i + j)) (Polynomial.coeff p i * a) :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0 :=\n\n/-- The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares. -/\ntheorem", "choices": ["∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 →\n  ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 ", "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "∀ {a b x y u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n  b = r ^ 2 + s ^ 2 + x ^ 2 + y ^ 2 →\n  ∃ p q t z, a * b = p ^ 2 + q ^ 2 + t ^ 2 + z ^ 2 ", "∀ {a b x y u v r s : ℕ}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 → b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ", "∀ {a b x y u v r s : ℕ}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 → b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q m n, a * b = p ^ 2 + q ^ 2 + m ^ 2 + n ^ 2 ", "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "∀ {a b x y u v r s : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = r ^ 2 + s ^ 2 + x ^ 2 + y ^ 2 → ∃ p q l m, a * b = p ^ 2 + q ^ 2 + l ^ 2 + m ^ 2 ", "∀ {a b x y u v r s t w : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 →\n  b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2 →\n  ∃ m n o p, a * b = m ^ 2 + n ^ 2 + o ^ 2 + p ^ 2 ", "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "∀ {a b x y u v r s : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = r ^ 2 + s ^ 2 + x ^ 2 + y ^ 2 → ∃ w t z p, a * b = w ^ 2 + t ^ 2 + z ^ 2 + p ^ 2 "]}, {"stmt": "Every compact topological space is locally compact.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"∀ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological space admits an atlas with locally compact charts, then the space itself\\nis locally compact. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G → LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty\\ninterior is locally compact.\"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G → LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty interior\\nis locally compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\\n  (∀ (x : α), ∃ s, s ∈ nhds x ∧ IsCompact s) → LocallyCompactSpace α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.\\n\"}]\n", "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x :=\n\n/-- The underlying topological space is compact. -/\ntheorem ∀ (self : CompHaus), CompactSpace ↑self.toTop :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K' :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s :=\n\n/-- If a topological space admits an atlas with locally compact charts, then the space itself\nis locally compact. -/\ntheorem ∀ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty\ninterior is locally compact. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G → LocallyCompactSpace G :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty interior\nis locally compact. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G → LocallyCompactSpace G :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\n  (∀ (x : α), ∃ s, s ∈ nhds x ∧ IsCompact s) → LocallyCompactSpace α :=\n\n/-- In a locally compact T₂ space, every compact set has an open neighborhood with compact closure. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V) :=\n\n/-- Every compact topological space is locally compact. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α "]}, {"stmt": "Every continuous function is uniformly continuous.", "prompts": "[{\"theorem\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α) (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UniformIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {X : Type u_2} {α : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α},\\n  Equicontinuous F → ∀ (i : ι), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {ι : Type u_1} {F : ι → β → α}\\n  [inst_2 : CompactSpace β], Equicontinuous F → UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"}]\n", "prompt_cons": "/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i) :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (x : α) (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    Continuous f :=\n\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UniformIntegrable (fun x => g) p μ :=\n\n/-- Uniform continuity of the function -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem ∀ {ι : Type u_1} {X : Type u_2} {α : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α},\n  Equicontinuous F → ∀ (i : ι), Continuous (F i) :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {ι : Type u_1} {F : ι → β → α}\n  [inst_2 : CompactSpace β], Equicontinuous F → UniformEquicontinuous F :=\n\n/-- Every continuous function is uniformly continuous. -/\ntheorem", "choices": ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f "]}, {"stmt": "`6` is not the sum of two distinct prime numbers.", "prompts": "[{\"theorem\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {M : ι → Type u_2} [inst : (i : ι) → Monoid (M i)] (self : FreeProduct.Word M),\\n  List.Chain' (fun l l' => l.fst ≠ l'.fst) self.toList\",\n  \"isProp\": true,\n  \"docString\": \"Adjacent letters are not from the same summand. \"},\n {\"theorem\":\n  \"∀ {p n : ℕ}, 2 < n → p ≤ n → 2 * n < 3 * p → ↑(Nat.factorization (Nat.centralBinom n)) p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\\n`centralBinom n`. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n R` is different from `0`. \"},\n {\"theorem\": \"¬Summable fun n => 1 / ↑n\",\n  \"isProp\": true,\n  \"docString\": \"Harmonic series is not unconditionally summable. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic' n R` is different from `0`. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) → p₁ ≠ p₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `π / 2`, the first two points are not equal. \"}]\n", "prompt_cons": "/-- `2` is not a factor of an odd natural number. -/\ntheorem ∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2 :=\n\n/-- Adjacent letters are not from the same summand. -/\ntheorem ∀ {ι : Type u_1} {M : ι → Type u_2} [inst : (i : ι) → Monoid (M i)] (self : FreeProduct.Word M),\n  List.Chain' (fun l l' => l.fst ≠ l'.fst) self.toList :=\n\n/-- Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\n`centralBinom n`. -/\ntheorem ∀ {p n : ℕ}, 2 < n → p ≤ n → 2 * n < 3 * p → ↑(Nat.factorization (Nat.centralBinom n)) p = 0 :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem ∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K } :=\n\n/-- `cyclotomic n R` is different from `0`. -/\ntheorem ∀ (n : ℕ) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R ≠ 0 :=\n\n/-- Harmonic series is not unconditionally summable. -/\ntheorem ¬Summable fun n => 1 / ↑n :=\n\n/-- `cyclotomic' n R` is different from `0`. -/\ntheorem ∀ (n : ℕ) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R ≠ 0 :=\n\n/-- If the angle between three points is `π / 2`, the first two points are not equal. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) → p₁ ≠ p₂ :=\n\n/-- `6` is not the sum of two distinct prime numbers. -/\ntheorem", "choices": ["¬∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6 ", "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6 ", "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6 ", "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6 ", "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6 ", "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6 ", "¬ ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6 ", "∀ {a b : ℕ}, Nat.Prime a → Nat.Prime b → a ≠ b → a + b ≠ 6 ", "¬∃ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ a ≠ b ∧ a + b = 6 ", "¬∃ (p q : ℕ), Nat.Prime p → Nat.Prime q → p ≠ q → p + q = 6 "]}, {"stmt": "No integer is irrational.", "prompts": "[{\"theorem\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero fractional ideals contain a nonzero integer. \"},\n {\"theorem\": \"∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) → ∃ q, v = ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\": \"∀ {a b : ℤ}, a ∣ b → Int.natAbs b < Int.natAbs a → b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer with larger absolute value divides an integer, it is\\nzero. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜]\\n  [inst_3 : Archimedean 𝕜], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"}]\n", "prompt_cons": "/-- A transcendental real number is irrational. -/\ntheorem ∀ {r : ℝ}, Transcendental ℚ r → Irrational r :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q :=\n\n/-- Nonzero fractional ideals contain a nonzero integer. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I :=\n\n/-- A rational number has only finitely many good rational approximations. -/\ntheorem ∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2} :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- Every terminating continued fraction corresponds to a rational number. -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) → ∃ q, v = ↑q :=\n\n/-- No zero divisors. -/\ntheorem ∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem ∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y :=\n\n/-- If an integer with larger absolute value divides an integer, it is\nzero. -/\ntheorem ∀ {a b : ℤ}, a ∣ b → Int.natAbs b < Int.natAbs a → b = 0 :=\n\n/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜]\n  [inst_3 : Archimedean 𝕜], DenseRange Rat.cast :=\n\n/-- No integer is irrational. -/\ntheorem", "choices": ["∀ (z : ℤ), ¬Irrational (↑z) ", "∀ (n : ℤ), ¬Irrational (↑n : ℝ) ", "∀ (n : ℤ), ¬Irrational (↑n : ℝ) ", "∀ (n : ℤ), ¬Irrational (↑n : ℝ) ", "∀ (n : ℤ), ¬Irrational (↑n : ℝ) ", "∀ (n : ℤ), ¬Irrational (↑n) ", "∀ (n : ℤ), ¬Irrational ↑n ", "∀ (z : ℤ), ¬Irrational (↑z) ", "∀ (n : ℤ), ¬Irrational (↑n : ℝ) ", "∀ (n : ℤ), ¬Irrational (↑n : ℝ) "]}, {"stmt": "The identity element in a ring is a unit.", "prompts": "[{\"theorem\": \"∀ {α : Type u} [inst : Ring α], IsRingHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a ring homomorphism. \"},\n {\"theorem\": \"∀ {R : Type u} [inst : Ring R] (s : Subring R), 1 ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 1. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), a * -1 = -a\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element of a ring multiplied by the additive inverse of one is the element's additive\\ninverse. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : NonAssocRing R] (p : ℕ) [inst : CharP R p] [inst : Finite R], p ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {S : Type u_1} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ≃+* S), ↑f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends one to one. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is a group homomorphism. \"},\n {\"theorem\": \"∀ {R : Type u} [inst : Ring R] (s : Subring R), 0 ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 0. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x ∈ I → ‖1 - x‖ < 1 → I = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal which contains an element within `1` of `1 : R` is the unit ideal. \"},\n {\"theorem\": \"∀ {M : Type u_1} [inst : Monoid M] {x : M}, x ∈ powers x\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element of a monoid is in the set of that element's natural number powers. \"}]\n", "prompt_cons": "/-- The identity map is a ring homomorphism. -/\ntheorem ∀ {α : Type u} [inst : Ring α], IsRingHom id :=\n\n/-- A subring contains the ring's 1. -/\ntheorem ∀ {R : Type u} [inst : Ring R] (s : Subring R), 1 ∈ s :=\n\n/-- The group of units of a complete normed ring is an open subset of the ring. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x} :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive\ninverse. -/\ntheorem ∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), a * -1 = -a :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem ∀ (R : Type u_1) [inst : NonAssocRing R] (p : ℕ) [inst : CharP R p] [inst : Finite R], p ≠ 0 :=\n\n/-- A ring isomorphism sends one to one. -/\ntheorem ∀ {R : Type u_2} {S : Type u_1} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ≃+* S), ↑f 1 = 1 :=\n\n/-- The identity is a group homomorphism. -/\ntheorem ∀ {α : Type u} [inst : Group α], IsGroupHom id :=\n\n/-- A subring contains the ring's 0. -/\ntheorem ∀ {R : Type u} [inst : Ring R] (s : Subring R), 0 ∈ s :=\n\n/-- An ideal which contains an element within `1` of `1 : R` is the unit ideal. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x ∈ I → ‖1 - x‖ < 1 → I = ⊤ :=\n\n/-- An element of a monoid is in the set of that element's natural number powers. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] {x : M}, x ∈ powers x :=\n\n/-- The identity element in a ring is a unit. -/\ntheorem", "choices": ["∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) "]}, {"stmt": "Every subgroup of a group is a group.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k)\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup generated by a set includes the set. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup contains the group's 1. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x ∈ H → x⁻¹ ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under inverse. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (∀ (x : G), x ∈ H ↔ x ∈ K) → H = K\",\n  \"isProp\": true,\n  \"docString\": \"Two subgroups are equal if they have the same elements. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x y : G}, y ∈ Subgroup.closure {x} ↔ ∃ n, x ^ n = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subgroup generated by an element of a group equals the set of integer number powers of\\nthe element. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"}]\n", "prompt_cons": "/-- A subgroup is closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H :=\n\n/-- A subgroup is closed under division. -/\ntheorem ∀ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H :=\n\n/-- The subgroup generated by a set includes the set. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k) :=\n\n/-- A subgroup contains the group's 1. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 ∈ H :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H } :=\n\n/-- A subgroup is closed under inverse. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x ∈ H → x⁻¹ ∈ H :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid :=\n\n/-- Two subgroups are equal if they have the same elements. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (∀ (x : G), x ∈ H ↔ x ∈ K) → H = K :=\n\n/-- The subgroup generated by an element of a group equals the set of integer number powers of\nthe element. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x y : G}, y ∈ Subgroup.closure {x} ↔ ∃ n, x ^ n = y :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H } :=\n\n/-- Every subgroup of a group is a group. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group {x // x ∈ H} ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ", "forall {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ", "forall {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } "]}, {"stmt": "The sum of two natural numbers is a natural number.", "prompts": "[{\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ (a : α), a ∈ s → f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of finite numbers is still finite \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x →\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y → DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two finite adèles is a finite adèle. \"},\n {\"theorem\": \"∀ (n : ℕ), PGame.Numeric ↑n\",\n  \"isProp\": true,\n  \"docString\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {n : ℕ∞}\\n  {f g : E → F}, ContDiff 𝕜 n f → ContDiff 𝕜 n g → ContDiff 𝕜 n fun x => f x + g x\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two `C^n`functions is `C^n`. \"},\n {\"theorem\":\n  \"∀ (a b : Ordinal.{u}), Ordinal.toPGame a + Ordinal.toPGame b ≈ Ordinal.toPGame (Ordinal.nadd a b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of ordinals as games corresponds to natural addition of ordinals. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"}]\n", "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- A sum of finite numbers is still finite -/\ntheorem ∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ (a : α), a ∈ s → f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤ :=\n\n/-- The sum of two finite adèles is a finite adèle. -/\ntheorem ∀ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\n  {x y : DedekindDomain.ProdAdicCompletions R K},\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x →\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y → DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y) :=\n\n/-- Pre-games defined by natural numbers are numeric. -/\ntheorem ∀ (n : ℕ), PGame.Numeric ↑n :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem ∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤ :=\n\n/-- The sum of two `C^n`functions is `C^n`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {n : ℕ∞}\n  {f g : E → F}, ContDiff 𝕜 n f → ContDiff 𝕜 n g → ContDiff 𝕜 n fun x => f x + g x :=\n\n/-- The sum of ordinals as games corresponds to natural addition of ordinals. -/\ntheorem ∀ (a b : Ordinal.{u}), Ordinal.toPGame a + Ordinal.toPGame b ≈ Ordinal.toPGame (Ordinal.nadd a b) :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- The sum of two natural numbers is a natural number. -/\ntheorem", "choices": ["∀ (m n : ℕ), ∃ k, m + n = k ", "∀ (m n : ℕ), ∃ k, m + n = k ", "∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ", "∀ (m n : ℕ), ∃ k, m + n = k ", "∀ (m n : ℕ), ∃ k, m + n = k ", "∀ (m n : ℕ), ∃ r, m + n = r ", "∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ", "∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ", "∀ (a b : ℕ), ∃ (c : ℕ), a + b = c ", "∀ (m n : ℕ), ∃ (k : ℕ), m + n = k "]}, {"stmt": "The identity element of a group has finite order.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\\n  IsOfFinAddOrder x → IsOfFinAddOrder (↑f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is a group homomorphism. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"}]\n", "prompt_cons": "/-- A group element has finite order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem ∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\n  IsOfFinOrder x → IsOfFinOrder (↑f x) :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem ∀ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\n  IsOfFinAddOrder x → IsOfFinAddOrder (↑f x) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x :=\n\n/-- The identity is a group homomorphism. -/\ntheorem ∀ {α : Type u} [inst : Group α], IsGroupHom id :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- The identity element of a group has finite order. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "forall {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) "]}, {"stmt": "`7` is a prime number.", "prompts": "[{\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\": \"∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"}]\n", "prompt_cons": "/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\n  Irreducible p →\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n) :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem ∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → Prime (minpoly A x) :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem ∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2 :=\n\n/-- `7` is a prime number. -/\ntheorem", "choices": ["Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) "]}, {"stmt": "There are `3` prime numbers below `8`.", "prompts": "[{\"theorem\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\":\n  \"∀ (n : ℕ), List.toFinset (Nat.factors n) = Finset.filter Nat.Prime (Nat.divisors n)\",\n  \"isProp\": true,\n  \"docString\": \"The factors of `n` are the prime divisors \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"∀ {p n : ℕ}, 2 < n → p ≤ n → 2 * n < 3 * p → ↑(Nat.factorization (Nat.centralBinom n)) p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\\n`centralBinom n`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"}]\n", "prompt_cons": "/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem ∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n :=\n\n/-- The factors of `n` are the prime divisors -/\ntheorem ∀ (n : ℕ), List.toFinset (Nat.factors n) = Finset.filter Nat.Prime (Nat.divisors n) :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\n  Irreducible p →\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n) :=\n\n/-- Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\n`centralBinom n`. -/\ntheorem ∀ {p n : ℕ}, 2 < n → p ≤ n → 2 * n < 3 * p → ↑(Nat.factorization (Nat.centralBinom n)) p = 0 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7) :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem ∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2 :=\n\n/-- There are `3` prime numbers below `8`. -/\ntheorem", "choices": ["prime_counting_function 8 = 3 ", "Nat.count_primes_below_8 : Nat.count 8 Nat.Prime = 3 ", "Nat.prime_counting_function 8 = 3 ", "Nat.card_prime_lt 8 = 3 ", "Nat.card_prime_below_8 : Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 ", "Nat.card_primes_below_8 : Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 ", "Fact (∃ (primes_below_eight : List ℕ), primes_below_eight = [2, 3, 5, 7] ∧ List.length primes_below_eight = 3) ", "Nat.prime_counting_function 8 = 3 ", "Nat.card_primes_below_8 : Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 ", "Prime.card (Finset.filter (λ p, p < 8) (Finset.range 8)) = 3 "]}, {"stmt": "The empty set is contained in every finite set.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P], EuclideanGeometry.Concyclic ∅\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is concyclic. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ (a : α), ↑(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι},\\n  TendstoUniformlyOn F f p ∅\",\n  \"isProp\": true,\n  \"docString\": \"Uniform convergence on the empty set is vacuously true \"},\n {\"theorem\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"theorem\": \"∀ {α : Type u_1} [inst : DecidableEq α], Finset.shadow ∅ = ∅\",\n  \"isProp\": true,\n  \"docString\": \"The shadow of the empty set is empty. \"}]\n", "prompt_cons": "/-- The set of finite subsets of a countable set is countable. -/\ntheorem ∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s} :=\n\n/-- The empty set is concyclic. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P], EuclideanGeometry.Concyclic ∅ :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem ∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C :=\n\n/-- A finite union of finsets is finite. -/\ntheorem ∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ (a : α), ↑(f a)) :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem ∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem ∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a} :=\n\n/-- Uniform convergence on the empty set is vacuously true -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι},\n  TendstoUniformlyOn F f p ∅ :=\n\n/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ntheorem ∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K) :=\n\n/-- The shadow of the empty set is empty. -/\ntheorem ∀ {α : Type u_1} [inst : DecidableEq α], Finset.shadow ∅ = ∅ :=\n\n/-- The empty set is contained in every finite set. -/\ntheorem", "choices": ["∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ", "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ", "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ", "∀ {α : Type u} {a : Set α}, Set.Finite a → ∅ ⊆ a ", "∀ {α : Type u} {a : Set α}, Set.Finite a → ∅ ⊆ a ", "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ", "∀ {α : Type u} {s : Set α}, Set.Finite s → HasSubset.Subset ∅ s ", "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ", "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ", "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s "]}, {"stmt": "Every infinite set contains a finite set.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ (a : α), ↑(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Set.Finite s → Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded \"},\n {\"theorem\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"theorem\":\n  \"∀ {δ : Type u_1} [inst : Finite δ] {κ : δ → Type u_2} {t : (d : δ) → Set (κ d)},\\n  (∀ (d : δ), Set.Finite (t d)) → Set.Finite (Set.pi Set.univ t)\",\n  \"isProp\": true,\n  \"docString\": \"Finite product of finite sets is finite \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : Nonempty α] {s : Set α}, Set.Finite s → BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded below.\"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\\n  IsCompact s →\\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"}]\n", "prompt_cons": "/-- The set of finite subsets of a countable set is countable. -/\ntheorem ∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s} :=\n\n/-- A finite union of finsets is finite. -/\ntheorem ∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ (a : α), ↑(f a)) :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem ∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a} :=\n\n/-- A finite set is bounded -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Set.Finite s → Metric.Bounded s :=\n\n/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ntheorem ∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K) :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem ∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val :=\n\n/-- Finite product of finite sets is finite -/\ntheorem ∀ {δ : Type u_1} [inst : Finite δ] {κ : δ → Type u_2} {t : (d : δ) → Set (κ d)},\n  (∀ (d : δ), Set.Finite (t d)) → Set.Finite (Set.pi Set.univ t) :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem ∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val :=\n\n/-- A finite set is bounded below. -/\ntheorem ∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : Nonempty α] {s : Set α}, Set.Finite s → BddBelow s :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\n  IsCompact s →\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i :=\n\n/-- Every infinite set contains a finite set. -/\ntheorem", "choices": ["∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ", "∀ {α : Type u} {s : Set α} [inst : Infinite α], ∃ t : Finset α, t ⊆ s ∧ Set.Finite t ", "∀ {α : Type u} {s : Set α} [inst : Infinite α], ∃ (t : Finset α), t ⊆ s ", "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∀ (n : ℕ), ∃ t : Finset α, ↑t ⊆ s ∧ Finset.card t = n ", "∀ {α : Type u} {s : Set α} [inst : Infinite α], ∃ t : Set α, Set.Finite t ∧ t ⊆ s ", "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ", "∀ {α : Type u} {s : Set α} [inst : Infinite α], ∃ t : Set α, Set.Finite t ∧ t ⊆ s ", "∀ {α : Type u} {s : Set α} [inst : Infinite α], ∃ t : Set α, Set.Finite t ∧ t ⊆ s ", "∀ {α : Type u} {s : Set α} [inst : Infinite α], ∃ t : Set α, Set.Finite t ∧ t ⊆ s ", "∀ {α : Type u} {s : Set α} [inst : Infinite α], ∃ t : Set α, Set.Finite t ∧ t ⊆ s "]}, {"stmt": "Every commutative ring is a monoid.", "prompts": "[{\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\": \"∀ {M : Type u_1} [inst : Monoid M], IsSubmonoid Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"A monoid is a submonoid of itself. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : MulOneClass α] [inst_1 : MulOneClass β] {f : α → β},\\n  IsMonoidHom f → ∀ {γ : Type u_1} [inst_2 : MulOneClass γ] {g : β → γ}, IsMonoidHom g → IsMonoidHom (g ∘ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composite of two monoid homomorphisms is a monoid homomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommMonCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of commutative monoids has all limits. \"},\n {\"theorem\":\n  \"∀ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : One M] [inst_1 : One N] [inst_2 : One P]\\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of monoid homomorphisms is associative. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1\",\n  \"isProp\": true,\n  \"docString\": \"1 is of finite order in any monoid. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of commutative rings has all limits. \"},\n {\"theorem\":\n  \"∀ {γ : Type u_1} [inst : NonUnitalNonAssocSemiring γ] (x : γ), IsAddMonoidHom fun y => x * y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left multiplication in a ring is an additive monoid morphism. \"}]\n", "prompt_cons": "/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M :=\n\n/-- A monoid is a submonoid of itself. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M], IsSubmonoid Set.univ :=\n\n/-- The composite of two monoid homomorphisms is a monoid homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : MulOneClass α] [inst_1 : MulOneClass β] {f : α → β},\n  IsMonoidHom f → ∀ {γ : Type u_1} [inst_2 : MulOneClass γ] {g : β → γ}, IsMonoidHom g → IsMonoidHom (g ∘ f) :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f :=\n\n/-- The category of commutative monoids has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommMonCatMax :=\n\n/-- Composition of monoid homomorphisms is associative. -/\ntheorem ∀ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : One M] [inst_1 : One N] [inst_2 : One P]\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f) :=\n\n/-- 1 is of finite order in any monoid. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1 :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem ∀ {R : Type u} [inst : CommRing R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R :=\n\n/-- The category of commutative rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem ∀ {γ : Type u_1} [inst : NonUnitalNonAssocSemiring γ] (x : γ), IsAddMonoidHom fun y => x * y :=\n\n/-- Every commutative ring is a monoid. -/\ntheorem", "choices": ["∀ {R : Type u} [inst : CommRing R], Monoid R ", "∀ {R : Type u} [inst : CommRing R], Monoid R ", "∀ {R : Type u} [inst : CommRing R], Monoid R ", "∀ {R : Type u} [inst : CommRing R], Monoid R ", "∀ {R : Type u} [inst : CommRing R], Monoid R ", "∀ {R : Type u} [inst : CommRing R], Monoid R ", "∀ {R : Type u} [inst : CommRing R], Monoid R ", "∀ {R : Type u} [inst : CommRing R], Monoid R ", "∀ {R : Type u} [inst : CommRing R], Monoid R ", "∀ {R : Type u} [inst : CommRing R], Monoid R "]}, {"stmt": "There is no field of order `10`.", "prompts": "[{\"theorem\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b}\",\n  \"isProp\": true,\n  \"docString\": \"Ordinals that are cardinals are unbounded. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b ∧ Ordinal.omega ≤ b}\",\n  \"isProp\": true,\n  \"docString\": \"Infinite ordinals that are cardinals are unbounded. \"},\n {\"theorem\": \"¬IsField ℤ\",\n  \"isProp\": true,\n  \"docString\": \"`ℤ` with its usual ring structure is not a field. \"},\n {\"theorem\":\n  \"∀ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (p : P), ¬p ∈ ⊥\",\n  \"isProp\": true,\n  \"docString\": \"No points are in `⊥`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\": \"∀ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"The order of the `0` power series is infinite.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LT α] {a b : α} [inst_1 : DenselyOrdered α], ¬a ⋖ b\",\n  \"isProp\": true,\n  \"docString\": \"In a dense order, nothing covers anything. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semiring R] [inst_1 : Nontrivial R], PowerSeries.order 1 = 0\",\n  \"isProp\": true,\n  \"docString\": \"The order of the formal power series `1` is `0`.\"}]\n", "prompt_cons": "/-- Ordinals that are cardinals are unbounded. -/\ntheorem Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b} :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem ∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K } :=\n\n/-- Fields are commutative. -/\ntheorem ∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x :=\n\n/-- Infinite ordinals that are cardinals are unbounded. -/\ntheorem Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b ∧ Ordinal.omega ≤ b} :=\n\n/-- `ℤ` with its usual ring structure is not a field. -/\ntheorem ¬IsField ℤ :=\n\n/-- No points are in `⊥`. -/\ntheorem ∀ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (p : P), ¬p ∈ ⊥ :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 ∈ S :=\n\n/-- The order of the `0` power series is infinite. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = ⊤ :=\n\n/-- In a dense order, nothing covers anything. -/\ntheorem ∀ {α : Type u_1} [inst : LT α] {a b : α} [inst_1 : DenselyOrdered α], ¬a ⋖ b :=\n\n/-- The order of the formal power series `1` is `0`. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R] [inst_1 : Nontrivial R], PowerSeries.order 1 = 0 :=\n\n/-- There is no field of order `10`. -/\ntheorem", "choices": ["¬∃ (F : Type u_1) [inst : Field F], Fintype.card F = 10 ", "¬∃ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "¬∃ (F : Type u_1) [inst : Field F], Fintype.card F = 10 ", "¬∃ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "¬∃ (K : Type u) [inst : Field K], Fintype.card K = 10 ", "¬∃ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "¬∃ (K : Type) [inst : Field K], Fintype.card K = 10 ", "¬∃ {F : Type u_1} [inst : Field F], Fintype.card F = 10 ", "¬∃ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "¬∃ (F : Type u) [inst : Field F], Fintype.card F = 10 "]}, {"stmt": "Every odd natural number is the sum of two distinct natural numbers.", "prompts": "[{\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x →\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y → DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two finite adèles is a finite adèle. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ (a : α), a ∈ s → f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of finite numbers is still finite \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"}]\n", "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1) :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem ∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2 :=\n\n/-- The sum of two finite adèles is a finite adèle. -/\ntheorem ∀ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\n  {x y : DedekindDomain.ProdAdicCompletions R K},\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x →\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y → DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y) :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q :=\n\n/-- A sum of finite numbers is still finite -/\ntheorem ∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ (a : α), a ∈ s → f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤ :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem ∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- Every odd natural number is the sum of two distinct natural numbers. -/\ntheorem", "choices": ["∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ", "∀ {n : ℕ}, Odd n → ∃ m k : ℕ, m ≠ k ∧ n = m + k ", "∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ", "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ", "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, n = a + b ∧ a ≠ b ", "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ", "∀ {n : ℕ}, Odd n → ∃ (a b : ℕ), a ≠ b ∧ n = a + b ", "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ", "∀ {n : ℕ}, Odd n → ∃ x y : ℕ, x ≠ y ∧ n = x + y ", "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b "]}, {"stmt": "Every element in the trivial group has finite order.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"}]\n", "prompt_cons": "/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem ∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\n  IsOfFinOrder x → IsOfFinOrder (↑f x) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y) :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x :=\n\n/-- Every element in the trivial group has finite order. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ", "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ", "∀ {G : Type u_1} [inst : GroupWithZero G], IsOfFinOrder (0 : G) ", "∀ {G : Type u_1} [inst : One G] (x : G), IsOfFinOrder x ", "forall {G : Type u_1} [inst : GroupWithZero G] (x : G), IsOfFinOrder x ", "∀ {G : Type u_1} [inst : GroupWithZero G], IsOfFinOrder (0 : G) ", "∀ {G : Type u_1} [inst : GroupWithZero G], IsOfFinOrder (0 : G) ", "∀ {G : Type u_1} [inst : Group G] [Subsingleton G] (x : G), IsOfFinOrder x ", "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Unique G], ∀ (x : G), IsOfFinOrder x ", "∀ {G : Type u_1} [inst : GroupWithZero G] {x : G}, IsOfFinOrder x "]}, {"stmt": "The square of an even number is even.", "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\":\n  \"∀ {C : Type u_1} [inst : CategoryTheory.Category C] {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z},\\n  CategoryTheory.CommSq f g h i → CategoryTheory.CategoryStruct.comp f h = CategoryTheory.CategoryStruct.comp g i\",\n  \"isProp\": true,\n  \"docString\": \"The square commutes. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ≤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ≤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ↔ Fintype.card F % 2 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 ↔ Fintype.card F % 8 ≠ 3 ∧ Fintype.card F % 8 ≠ 5\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. \"}]\n", "prompt_cons": "/-- The convolution of two even functions is also even. -/\ntheorem ∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a :=\n\n/-- The square commutes. -/\ntheorem ∀ {C : Type u_1} [inst : CategoryTheory.Category C] {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z},\n  CategoryTheory.CommSq f g h i → CategoryTheory.CategoryStruct.comp f h = CategoryTheory.CategoryStruct.comp g i :=\n\n/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap g (Ideal.comap f' I));\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ≤ Ideal.comap g' I))\n      (Ideal.quotientMap (Ideal.comap g' I) f\n        (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap f (Ideal.comap g' I))) =\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ≤ Ideal.comap f' I))\n      (Ideal.quotientMap (Ideal.comap f' I) g leq) :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7) :=\n\n/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ↔ Fintype.card F % 2 = 0 :=\n\n/-- `2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 ↔ Fintype.card F % 8 ≠ 3 ∧ Fintype.card F % 8 ≠ 5 :=\n\n/-- The square of an even number is even. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : CommRing α] {x : α}, x % 2 = 0 → (x * x) % 2 = 0 ", "∀ {α : Type u} [inst : CommSemiring α] {x : α}, IsEven x → IsEven (x * x) ", "∀ {α : Type u} [inst : CommRing α] {x : α}, x % 2 = 0 → (x * x) % 2 = 0 ", "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, Even x → Even (x * x) ", "∀ {n : ℕ}, Even (n ^ 2) ↔ Even n ", "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x % 2 = 0 → (x * x) % 2 = 0 ", "∀ {α : Type u} [inst : Semiring α] {x : α}, Even x → Even (x * x) ", "∀ {n : ℕ}, Even (n ^ 2) ↔ Even n ", "∀ {n : ℕ}, Even (n ^ 2) ↔ Even n ", "∀ {α : Type u} [inst : Semiring α] {a : α}, Even a → Even (a * a) "]}, {"stmt": "Every commutative division ring is a field.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of commutative rings has all limits. \"},\n {\"theorem\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"∀ (S : Set ℕ+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite ↑S] [inst : IsCyclotomicExtension S K L], NumberField L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A cyclotomic finite extension of a number field is a number field. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {σ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial σ R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multivariate polynomial ring over an integral domain is an integral domain. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\\n  p ∣ ringChar R ↔ p ∣ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"}]\n", "prompt_cons": "/-- Fields are commutative. -/\ntheorem ∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- The category of commutative rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax :=\n\n/-- A field is a valuation ring. -/\ntheorem ∀ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- A cyclotomic finite extension of a number field is a number field. -/\ntheorem ∀ (S : Set ℕ+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\n  [inst_3 : Finite ↑S] [inst : IsCyclotomicExtension S K L], NumberField L :=\n\n/-- An intermediate field is closed under division. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S :=\n\n/-- The multivariate polynomial ring over an integral domain is an integral domain. -/\ntheorem ∀ {R : Type u} {σ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial σ R) :=\n\n/-- Every nonarchimedean ring is naturally a nonarchimedean additive group. -/\ntheorem ∀ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem ∀ {R : Type u} [inst : CommRing R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\n  p ∣ ringChar R ↔ p ∣ Fintype.card R :=\n\n/-- Every commutative division ring is a field. -/\ntheorem", "choices": ["∀ (A : Type u) [inst : CommRing A] [inst_1 : Nontrivial A] [inst_2 : DivisionRing A], IsField A ", "∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "∀ {K : Type u} [inst : CommRing K] [inst_1 : IsDivisionRing K], IsField K ", "∀ {R : Type u} [inst : CommRing R] [IsDivisionRing R], IsField R ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DivisionRing R], IsField R "]}, {"stmt": "The image of the identity element under the identity map is the identity element.", "prompts": "[{\"theorem\": \"∀ {α : Type u} [inst : Ring α], IsRingHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a ring homomorphism. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : MulOneClass α], IsMonoidHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a monoid homomorphism. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : Mul α], IsMulHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map preserves multiplication. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : Semiring α], IsSemiringHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a semiring homomorphism. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : AddZeroClass α], IsAddMonoidHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is an additive monoid homomorphism.\"},\n {\"theorem\":\n  \"∀ (k : Type u_3) {V1 : Type u_2} (P1 : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\\n  [inst_3 : AddTorsor V1 P1], ↑(AffineMap.id k P1) = id\",\n  \"isProp\": true,\n  \"docString\": \"The identity affine map acts as the identity. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : PseudoEMetricSpace α], Isometry id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is an isometry \"},\n {\"theorem\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is a group homomorphism. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : Add α], IsAddHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map preserves addition\"},\n {\"theorem\": \"∀ {α : Type u} [inst : AddGroup α], IsAddGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is an additive group homomorphism.\"}]\n", "prompt_cons": "/-- The identity map is a ring homomorphism. -/\ntheorem ∀ {α : Type u} [inst : Ring α], IsRingHom id :=\n\n/-- The identity map is a monoid homomorphism. -/\ntheorem ∀ {α : Type u} [inst : MulOneClass α], IsMonoidHom id :=\n\n/-- The identity map preserves multiplication. -/\ntheorem ∀ {α : Type u} [inst : Mul α], IsMulHom id :=\n\n/-- The identity map is a semiring homomorphism. -/\ntheorem ∀ {α : Type u} [inst : Semiring α], IsSemiringHom id :=\n\n/-- The identity map is an additive monoid homomorphism. -/\ntheorem ∀ {α : Type u} [inst : AddZeroClass α], IsAddMonoidHom id :=\n\n/-- The identity affine map acts as the identity. -/\ntheorem ∀ (k : Type u_3) {V1 : Type u_2} (P1 : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\n  [inst_3 : AddTorsor V1 P1], ↑(AffineMap.id k P1) = id :=\n\n/-- The identity is an isometry -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α], Isometry id :=\n\n/-- The identity is a group homomorphism. -/\ntheorem ∀ {α : Type u} [inst : Group α], IsGroupHom id :=\n\n/-- The identity map preserves addition -/\ntheorem ∀ {α : Type u} [inst : Add α], IsAddHom id :=\n\n/-- The identity is an additive group homomorphism. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α], IsAddGroupHom id :=\n\n/-- The image of the identity element under the identity map is the identity element. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : HasOne α], id 1 = 1 ", "∀ {α : Type u} [inst : HasOne α], id 1 = 1 ", "∀ {α : Type u} [inst : HasOne α], id 1 = 1 ", "∀ {α : Type u} [inst : HasOne α], id 1 = 1 ", "∀ {α : Type u} [inst : HasOne α], id 1 = 1 ", "∀ {α : Type u} [inst : HasOne α], id 1 = 1 ", "∀ {α : Type u} [inst : HasOne α], id 1 = 1 ", "∀ {α : Type u} [inst : HasOne α], id 1 = 1 ", "∀ {α : Type u} [inst : HasOne α], id 1 = 1 ", "∀ {α : Type u} [inst : HasOne α], id 1 = 1 "]}, {"stmt": "Every point is a fixed point of the identity function on a space.", "prompts": "[{\"theorem\": \"∀ {α : Type u} (x : α), Function.IsFixedPt id x\",\n  \"isProp\": true,\n  \"docString\": \"Every point is a fixed point of `id`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {p : ι → P},\\n  AffineIndependent k p → Finite ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent family of points in a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"∀ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] {p₁ p₂ : P}, p₁ ∈ affineSpan k {p₂} ↔ p₁ = p₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"A point is in the affine span of a single point if and only if they are equal. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T0Space α] ⦃x y : α⦄, Inseparable x y → x = y\",\n  \"isProp\": true,\n  \"docString\": \"Two inseparable points in a T₀ space are equal. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\\n  AffineIndependent k f → Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\": \"∀ {α : Type u_1} (n : ℕ) (x : α), Function.IsPeriodicPt id n x\",\n  \"isProp\": true,\n  \"docString\": \"For the identity map, all points are periodic. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (u v : ℙ K V),\\n  Projectivization.Dependent ![u, v] ↔ u = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two points in a projective space are dependent if and only if they are equal. \"},\n {\"theorem\":\n  \"∀ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P},\\n  (AffineIndependent k fun p => ↑p) → ∃ t, s ⊆ t ∧ (AffineIndependent k fun p => ↑p) ∧ affineSpan k t = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affinely independent set of points can be extended to such a\\nset that spans the whole space. \"}]\n", "prompt_cons": "/-- Every point is a fixed point of `id`. -/\ntheorem ∀ {α : Type u} (x : α), Function.IsFixedPt id x :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\n  Continuous f → IsClosed (Function.fixedPoints f) :=\n\n/-- An affine-independent family of points in a finite-dimensional affine space is finite. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {p : ι → P},\n  AffineIndependent k p → Finite ι :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem ∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W) :=\n\n/-- A point is in the affine span of a single point if and only if they are equal. -/\ntheorem ∀ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {p₁ p₂ : P}, p₁ ∈ affineSpan k {p₂} ↔ p₁ = p₂ :=\n\n/-- Two inseparable points in a T₀ space are equal. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T0Space α] ⦃x y : α⦄, Inseparable x y → x = y :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\n  AffineIndependent k f → Set.Finite s :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem ∀ {α : Type u_1} (n : ℕ) (x : α), Function.IsPeriodicPt id n x :=\n\n/-- Two points in a projective space are dependent if and only if they are equal. -/\ntheorem ∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (u v : ℙ K V),\n  Projectivization.Dependent ![u, v] ↔ u = v :=\n\n/-- An affinely independent set of points can be extended to such a\nset that spans the whole space. -/\ntheorem ∀ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P},\n  (AffineIndependent k fun p => ↑p) → ∃ t, s ⊆ t ∧ (AffineIndependent k fun p => ↑p) ∧ affineSpan k t = ⊤ :=\n\n/-- Every point is a fixed point of the identity function on a space. -/\ntheorem", "choices": ["∀ {α : Type u} (x : α), Function.IsFixedPt id x ", "∀ {α : Type u} (x : α), Function.IsFixedPt id x ", "∀ {α : Type u} (x : α), Function.IsFixedPt id x ", "∀ {α : Type u} (x : α), Function.IsFixedPt id x ", "∀ {α : Type u} (x : α), Function.IsFixedPt id x ", "∀ {α : Type u} (x : α), Function.IsFixedPt id x ", "∀ {α : Type u} (x : α), Function.IsFixedPt id x ", "∀ {α : Type u} (x : α), Function.IsFixedPt id x ", "∀ {α : Type u} (x : α), Function.IsFixedPt id x ", "∀ {α : Type u} (x : α), Function.IsFixedPt id x "]}, {"stmt": "The diameter of a singleton space is `0`.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"A singleton has zero diameter \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The diameter of a singleton vanishes \"},\n {\"theorem\": \"∀ {α : Type u} [inst : PseudoMetricSpace α], Metric.diam ∅ = 0\",\n  \"isProp\": true,\n  \"docString\": \"The empty set has zero diameter \"},\n {\"theorem\": \"∀ {α : Type u} [inst : PseudoEMetricSpace α], EMetric.diam ∅ = 0\",\n  \"isProp\": true,\n  \"docString\": \"The diameter of the empty set vanishes \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\\n  [inst_4 : NoZeroSMulDivisors K V] [h : Subsingleton V], FiniteDimensional.finrank K V = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (finite dimensional) space that is a subsingleton has zero `finrank`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {β : Type u_1} [inst_1 : TopologicalSpace β]\\n  [inst_2 : TotallyDisconnectedSpace β] {f : α → β}, Continuous f → ∀ (a : α), f '' connectedComponent a = {f a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a connected component in a totally disconnected space is a singleton. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α], TotallyDisconnectedSpace α ↔ ∀ (x : α), connectedComponent x = {x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : Zero α] [inst_1 : Zero β] [inst_2 : SMulWithZero α β] [inst_3 : DecidableEq β]\\n  {s : Finset β}, Finset.Nonempty s → 0 • s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T1Space α] (x : α), IsClosed {x}\",\n  \"isProp\": true,\n  \"docString\": \"A singleton in a T₁ space is a closed set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X], T0Space (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a `T0Space` space is a `T0Space`. \"}]\n", "prompt_cons": "/-- A singleton has zero diameter -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 :=\n\n/-- The diameter of a singleton vanishes -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0 :=\n\n/-- The empty set has zero diameter -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α], Metric.diam ∅ = 0 :=\n\n/-- The diameter of the empty set vanishes -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α], EMetric.diam ∅ = 0 :=\n\n/-- A (finite dimensional) space that is a subsingleton has zero `finrank`. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\n  [inst_4 : NoZeroSMulDivisors K V] [h : Subsingleton V], FiniteDimensional.finrank K V = 0 :=\n\n/-- The image of a connected component in a totally disconnected space is a singleton. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {β : Type u_1} [inst_1 : TopologicalSpace β]\n  [inst_2 : TotallyDisconnectedSpace β] {f : α → β}, Continuous f → ∀ (a : α), f '' connectedComponent a = {f a} :=\n\n/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α], TotallyDisconnectedSpace α ↔ ∀ (x : α), connectedComponent x = {x} :=\n\n/-- A nonempty set is scaled by zero to the singleton set containing 0. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : Zero α] [inst_1 : Zero β] [inst_2 : SMulWithZero α β] [inst_3 : DecidableEq β]\n  {s : Finset β}, Finset.Nonempty s → 0 • s = 0 :=\n\n/-- A singleton in a T₁ space is a closed set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T1Space α] (x : α), IsClosed {x} :=\n\n/-- The one point compactification of a `T0Space` space is a `T0Space`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X], T0Space (OnePoint X) :=\n\n/-- The diameter of a singleton space is `0`. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ", "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ", "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ", "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ", "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ", "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ", "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ", "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ", "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ", "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 "]}, {"stmt": "Every group is non-empty.", "prompts": "[{\"theorem\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\",\n  \"isProp\": true,\n  \"docString\": \"Each connected component of the category is nonempty. \"},\n {\"theorem\":\n  \"∀ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"The ideal is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"∀ {a b : Ordinal.{u_1}}, b ≠ 0 → Set.Nonempty {o | a < b * Order.succ o}\",\n  \"isProp\": true,\n  \"docString\": \"The set in the definition of division is nonempty. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ↑s], Nonempty { x // x ∈ affineSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The affine span of a nonempty set is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : FiniteDimensional ℝ V] {s : Set V},\\n  Convex ℝ s → Set.Nonempty s → Set.Nonempty (intrinsicInterior ℝ s)\",\n  \"isProp\": true,\n  \"docString\": \"The intrinsic interior of a nonempty convex set is nonempty. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G → LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty interior\\nis locally compact. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"theorem\": \"∀ {α : Type u_1} (self : FilterBasis α), Set.Nonempty self.sets\",\n  \"isProp\": true,\n  \"docString\": \"The set of filter basis sets is nonempty. \"}]\n", "prompt_cons": "/-- Each connected component of the category is nonempty. -/\ntheorem ∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  Nonempty (CategoryTheory.Component j) :=\n\n/-- The ideal is nonempty. -/\ntheorem ∀ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier :=\n\n/-- A connected space is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α :=\n\n/-- The set in the definition of division is nonempty. -/\ntheorem ∀ {a b : Ordinal.{u_1}}, b ≠ 0 → Set.Nonempty {o | a < b * Order.succ o} :=\n\n/-- The affine span of a nonempty set is nonempty. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ↑s], Nonempty { x // x ∈ affineSpan k s } :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- The intrinsic interior of a nonempty convex set is nonempty. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : FiniteDimensional ℝ V] {s : Set V},\n  Convex ℝ s → Set.Nonempty s → Set.Nonempty (intrinsicInterior ℝ s) :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty interior\nis locally compact. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G → LocallyCompactSpace G :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K) :=\n\n/-- The set of filter basis sets is nonempty. -/\ntheorem ∀ {α : Type u_1} (self : FilterBasis α), Set.Nonempty self.sets :=\n\n/-- Every group is non-empty. -/\ntheorem", "choices": ["∀ {G : Type u} [inst : Group G], Nonempty G ", "∀ {G : Type u} [inst : Group G], Nonempty G ", "∀ {G : Type u} [inst : Group G], Nonempty G ", "∀ {G : Type u} [inst : Group G], Nonempty G ", "∀ {G : Type u} [inst : Group G], Nonempty G ", "∀ {G : Type u} [inst : Group G], Nonempty G ", "∀ (G : Type u_1) [inst : Group G], Nonempty G ", "∀ {G : Type u} [inst : Group G], Nonempty G ", "∀ {G : Type u} [inst : Group G], Nonempty G ", "∀ {G : Type u} [inst : Group G], Nonempty G "]}, {"stmt": "All connected components of a topological space are connected.", "prompts": "[{\"theorem\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\",\n  \"isProp\": true,\n  \"docString\": \"Each connected component of the category is connected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : DiscreteTopology α], LocallyConnectedSpace α\",\n  \"isProp\": true,\n  \"docString\": \"A space with discrete topology is a locally connected space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α], TotallyDisconnectedSpace α ↔ ∀ (x : α), connectedComponent x = {x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α],\\n  TotallyDisconnectedSpace α ↔ ∀ (x : α), Set.Subsingleton (connectedComponent x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is totally disconnected iff its connected components are subsingletons. \"},\n {\"theorem\":\n  \"∀ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\\n  [inst : LocallyConnectedSpace H], LocallyConnectedSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological space admits an atlas with locally connected charts, then the space itself is\\nlocally connected. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two points in a path-connected space must be joined by a continuous path. \"},\n {\"theorem\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\",\n  \"isProp\": true,\n  \"docString\": \"Each connected component of the category is nonempty. \"}]\n", "prompt_cons": "/-- The underlying topological space is compact. -/\ntheorem ∀ (self : CompHaus), CompactSpace ↑self.toTop :=\n\n/-- Each connected component of the category is connected. -/\ntheorem ∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  CategoryTheory.IsConnected (CategoryTheory.Component j) :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- A connected space is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α :=\n\n/-- A space with discrete topology is a locally connected space. -/\ntheorem ∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : DiscreteTopology α], LocallyConnectedSpace α :=\n\n/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α], TotallyDisconnectedSpace α ↔ ∀ (x : α), connectedComponent x = {x} :=\n\n/-- A space is totally disconnected iff its connected components are subsingletons. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α],\n  TotallyDisconnectedSpace α ↔ ∀ (x : α), Set.Subsingleton (connectedComponent x) :=\n\n/-- If a topological space admits an atlas with locally connected charts, then the space itself is\nlocally connected. -/\ntheorem ∀ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyConnectedSpace H], LocallyConnectedSpace M :=\n\n/-- Any two points in a path-connected space must be joined by a continuous path. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y :=\n\n/-- Each connected component of the category is nonempty. -/\ntheorem ∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  Nonempty (CategoryTheory.Component j) :=\n\n/-- All connected components of a topological space are connected. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] (x : α),\n  ConnectedSpace.connected (ConnectedComponents.connectedComponent x) ", "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), Connected (ConnectedComponent x) ", "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), ConnectedSpace (connectedComponent x) ", "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x) ", "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x) ", "∀ {α : Type u} [inst : TopologicalSpace α] (x : α),\n  IsConnected (connectedComponent x) ", "∀ {α : Type u} [inst : TopologicalSpace α] (x : α),\n  ConnectedSpace (coe (connectedComponent x)) ", "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), ConnectedSpace (connectedComponent x) ", "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), Connected (connectedComponent x) ", "forall {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x) "]}, {"stmt": "The ring of integers has a maximal ideal.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {p : ℕ+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] [hp : Fact (Nat.Prime ↑p)]\\n  [inst_2 : IsCyclotomicExtension {p} ℚ K], IsCyclotomicExtension {p} ℤ { x // x ∈ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The ring of integers of a `p`-th cyclotomic extension of `ℚ` is a cyclotomic extension. \"},\n {\"theorem\":\n  \"∀ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ⦃J : Order.Ideal P⦄,\\n  I < J → ↑J = Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsMaximal I], IsCoatom I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\\nand there are no other proper ideals strictly containing it. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 ↔ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The class number is `1` iff the ring of integers is a principal ideal domain. \"}]\n", "prompt_cons": "/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem ∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥ :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem ∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M :=\n\n/-- Maximal ideals in complete normed rings are closed. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem ∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I :=\n\n/-- The ring of integers of a `p`-th cyclotomic extension of `ℚ` is a cyclotomic extension. -/\ntheorem ∀ {p : ℕ+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] [hp : Fact (Nat.Prime ↑p)]\n  [inst_2 : IsCyclotomicExtension {p} ℚ K], IsCyclotomicExtension {p} ℤ { x // x ∈ NumberField.ringOfIntegers K } :=\n\n/-- This ideal is maximal in the collection of proper ideals. -/\ntheorem ∀ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ⦃J : Order.Ideal P⦄,\n  I < J → ↑J = Set.univ :=\n\n/-- The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\nand there are no other proper ideals strictly containing it. -/\ntheorem ∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsMaximal I], IsCoatom I :=\n\n/-- The class number is `1` iff the ring of integers is a principal ideal domain. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 ↔ IsPrincipalIdealRing R :=\n\n/-- The ring of integers has a maximal ideal. -/\ntheorem", "choices": ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M ", "∀ {K : Type u} [inst : Field K] [inst_1 : NumberField K], ∃ M, Ideal.IsMaximal M ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M ", "∀ (K : Type u) [inst : Field K] [inst_1 : CharZero K], ∃ M, @Ideal.IsMaximal (@NumberField.ringOfIntegers K inst_1) M ", "∀ {O : Type u_1} [inst : CommRing O] [inst_1 : IsDomain O] [inst_2 : IsDedekindDomain O], ∃ M, Ideal.IsMaximal M ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M ", "forall {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], ∃ M, Ideal.IsMaximal M ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M "]}, {"stmt": "The numbers `3`, `4` and `5` form a Pythagorean triple.", "prompts": "[{\"theorem\":\n  \"∀ {x y z : ℤ},\\n  PythagoreanTriple x y z →\\n    (PythagoreanTriple x y z ↔\\n      ∃ k m n,\\n        (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨ x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧\\n          (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2)))\",\n  \"isProp\": true,\n  \"docString\": \"**Formula for Pythagorean Triples** \"},\n {\"theorem\": \"PythagoreanTriple 0 0 0\",\n  \"isProp\": true,\n  \"docString\": \"The zeroth Pythagorean triple is all zeros. \"},\n {\"theorem\": \"∀ {x y z : ℤ}, PythagoreanTriple x y z ↔ PythagoreanTriple y x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean triples are interchangeable, i.e `x * x + y * y = y * y + x * x = z * z`.\\nThis comes from additive commutativity. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  InnerProductGeometry.angle x y = Real.pi / 2 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, vector angle form. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  (x y : E), inner x y = 0 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, vector inner product form. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ InnerProductGeometry.angle x y = Real.pi / 2\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, if-and-only-if vector angle form. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  InnerProductGeometry.angle x y = Real.pi / 2 → ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, subtracting vectors, vector angle form. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-only-if vector inner product form. \"},\n {\"theorem\":\n  \"∀ {x y z : ℤ} (k : ℤ), k ≠ 0 → (PythagoreanTriple (k * x) (k * y) (k * z) ↔ PythagoreanTriple x y z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`(k*x, k*y, k*z)` is a Pythagorean triple if and only if\\n`(x, y, z)` is also a triple. \"}]\n", "prompt_cons": "/-- **Formula for Pythagorean Triples** -/\ntheorem ∀ {x y z : ℤ},\n  PythagoreanTriple x y z →\n    (PythagoreanTriple x y z ↔\n      ∃ k m n,\n        (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨ x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧\n          (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2))) :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem PythagoreanTriple 0 0 0 :=\n\n/-- Pythagorean triples are interchangeable, i.e `x * x + y * y = y * y + x * x = z * z`.\nThis comes from additive commutativity. -/\ntheorem ∀ {x y z : ℤ}, PythagoreanTriple x y z ↔ PythagoreanTriple y x z :=\n\n/-- Pythagorean theorem, vector angle form. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\n  InnerProductGeometry.angle x y = Real.pi / 2 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ :=\n\n/-- Pythagorean theorem, vector inner product form. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (x y : E), inner x y = 0 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ :=\n\n/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0 :=\n\n/-- Pythagorean theorem, if-and-only-if vector angle form. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ InnerProductGeometry.angle x y = Real.pi / 2 :=\n\n/-- Pythagorean theorem, subtracting vectors, vector angle form. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\n  InnerProductGeometry.angle x y = Real.pi / 2 → ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ :=\n\n/-- Pythagorean theorem, if-and-only-if vector inner product form. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ inner x y = 0 :=\n\n/-- `(k*x, k*y, k*z)` is a Pythagorean triple if and only if\n`(x, y, z)` is also a triple. -/\ntheorem ∀ {x y z : ℤ} (k : ℤ), k ≠ 0 → (PythagoreanTriple (k * x) (k * y) (k * z) ↔ PythagoreanTriple x y z) :=\n\n/-- The numbers `3`, `4` and `5` form a Pythagorean triple. -/\ntheorem", "choices": ["PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 "]}, {"stmt": "A vector space with the empty set as basis is trivial.", "prompts": "[{\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {ι : Type w} [inst_4 : Fintype ι], Basis ι R M → Module.rank R M = ↑(Fintype.card ι)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : StrongRankCondition K] {ι : Type w} [inst_4 : Fintype ι],\\n  Basis ι K V → FiniteDimensional.finrank K V = Fintype.card ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T → ∀ [inst_3 : FiniteDimensional 𝕜 E], (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\\nfinite-dimensional inner product space is trivial. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Collinear k ∅\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is collinear. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"theorem\":\n  \"∀ (k : Type u_2) {V : Type u_1} (P : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], vectorSpan k ∅ = ⊥\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of the empty set is `⊥`. \"}]\n", "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V :=\n\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem ∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {ι : Type w} [inst_4 : Fintype ι], Basis ι R M → Module.rank R M = ↑(Fintype.card ι) :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : StrongRankCondition K] {ι : Type w} [inst_4 : Fintype ι],\n  Basis ι K V → FiniteDimensional.finrank K V = Fintype.card ι :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\nfinite-dimensional inner product space is trivial. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T → ∀ [inst_3 : FiniteDimensional 𝕜 E], (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ = ⊥ :=\n\n/-- The empty set is collinear. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], Collinear k ∅ :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem ∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁ :=\n\n/-- If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V) :=\n\n/-- The `vectorSpan` of the empty set is `⊥`. -/\ntheorem ∀ (k : Type u_2) {V : Type u_1} (P : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], vectorSpan k ∅ = ⊥ :=\n\n/-- A vector space with the empty set as basis is trivial. -/\ntheorem", "choices": ["forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → V = 0 ", "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → V ≃ₗ[K] ↥⊥ ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → V ≃ₗ[K] ⊥ ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → V ≅ₐ[K] Module.Pi K ∅ ", "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (finset ∅) K V → V ≃ₗ[K] K ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : IsEmpty ι], Basis ι K V → V = Trivialₓ ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → V ≃ₗ[K] ↥⊥ ", "forall {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {ι : Type w}\n  [inst_3 : IsEmpty ι], Basis ι R M → M = ⊥ ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → V ≃ₗ[K] 0 ", "∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → V = {0} "]}]