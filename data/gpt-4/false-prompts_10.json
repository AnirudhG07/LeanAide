[
  {
    "stmt": "Every ring is a field.",
    "prompts": "[{\"theorem\": \"\u2200 (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"\u2200 {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 \u2208 S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"\u2200 {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 \u2208 S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"\u2200 (K : Type u_1) [inst : Field K] [nf : NumberField K], \u00acIsField { x // x \u2208 NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} [inst : Semiring R], IsField R \u2192 \u2200 (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"\u2200 (\u03b1 : Type u_1) [inst : LinearOrderedField \u03b1] [inst_1 : FloorRing \u03b1], Archimedean \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M \u2192 \u00acIsField R \u2192 M \u2260 \u22a5\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\": \"\u2200 {R : Type u} [inst : Semiring R], IsField R \u2192 \u2203 x y, x \u2260 y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"theorem\": \"\u2200 {\u03b1 : Type u} [inst : Infinite \u03b1], Nonempty (Field \u03b1)\",\n  \"isProp\": true,\n  \"docString\": \"Any infinite type can be endowed a field structure. \"},\n {\"theorem\":\n  \"\u2200 {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (\u2191f (MulOpposite.unop (\u2191f x))) = x\",\n  \"isProp\": true,\n  \"docString\": \"Every ring involution must be its own inverse \"}]\n"
  },
  {
    "stmt": "Every vector space is finite dimensional.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {\u03b9 : Type w}\\n  [inst_3 : Finite \u03b9], Basis \u03b9 K V \u2192 FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"\u2200 {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V \u27f6 W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {\u03b9 : Type w}\\n  {s : Set \u03b9}, Basis (\u2191s) K V \u2192 Set.Finite s \u2192 FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x \u2208 S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field \ud835\udd5c] [inst_1 : TopologicalSpace \ud835\udd5c] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module \ud835\udd5c E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module \ud835\udd5c F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul \ud835\udd5c F]\\n  [inst_10 : FiniteDimensional \ud835\udd5c E] [inst_11 : FiniteDimensional \ud835\udd5c F], FiniteDimensional \ud835\udd5c (E \u2192L[\ud835\udd5c] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"\u2200 {\ud835\udd5c : Type u} [inst : NontriviallyNormedField \ud835\udd5c] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace \ud835\udd5c E] [inst_3 : CompleteSpace \ud835\udd5c] (s : Submodule \ud835\udd5c E)\\n  [inst_4 : FiniteDimensional \ud835\udd5c { x // x \u2208 s }], IsComplete \u2191s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {\u03b9 : Type w} [inst_4 : Fintype \u03b9], Basis \u03b9 R M \u2192 Module.rank R M = \u2191(Fintype.card \u03b9)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"\u2200 {\ud835\udd5c : Type u} [inst : NontriviallyNormedField \ud835\udd5c] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace \ud835\udd5c E] [inst_3 : CompleteSpace \ud835\udd5c] (s : Submodule \ud835\udd5c E)\\n  [inst_4 : FiniteDimensional \ud835\udd5c { x // x \u2208 s }], IsClosed \u2191s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"\u2200 {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\\n  FiniteDimensional k\\n    \u2191(CategoryTheory.Limits.limit\\n        (CategoryTheory.Functor.comp F (CategoryTheory.forget\u2082 (FGModuleCat k) (ModuleCat k))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Finite limits of finite dimensional vectors spaces are finite dimensional,\\nbecause we can realise them as subobjects of a finite product. \"},\n {\"theorem\":\n  \"\u2200 (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s \u2192 FiniteDimensional k { x // x \u2208 vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of a finite set is finite-dimensional. \"}]\n"
  },
  {
    "stmt": "Every group is a torsion monoid.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G], Monoid.IsTorsion G \u2192 \u2200 (H : Subgroup G), Monoid.IsTorsion { x // x \u2208 H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G \u2192 \u2200 (H : AddSubgroup G), AddMonoid.IsTorsion { x // x \u2208 H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G \u2192 \u2200 (H : Subgroup G), Monoid.IsTorsionFree { x // x \u2208 H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x \u2208 CommMonoid.torsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Torsion submonoids are torsion. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G \u2192 \u2200 (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x \u2208 H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G \u2192* H},\\n  N = MonoidHom.ker f \u2192 Monoid.IsTorsion H \u2192 Monoid.IsTorsion { x // x \u2208 N } \u2192 Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"\u2200 (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion G \u2192 CommMonoid.torsion G = \u22a4\",\n  \"isProp\": true,\n  \"docString\": \"The torsion submonoid of a torsion monoid is `\u22a4`. \"}]\n"
  },
  {
    "stmt": "Every finite simple group has prime order.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : AddGroup \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsSimpleAddGroup \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : Group \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsSimpleGroup \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : AddGroup \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsAddCyclic \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : Group \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)], Fintype.card \u03b1 = p \u2192 IsCyclic \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : Fintype \u03b1] [inst_1 : Field \u03b1], IsPrimePow (Fintype.card \u03b1)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x\u207b\u00b9 \u2194 IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x \u2194 IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : \u2115) [hp : Fact (Nat.Prime p)],\\n  p \u2223 Fintype.card G \u2192 \u2203 x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I \u2192 Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x \u2194 IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"}]\n"
  },
  {
    "stmt": "Every finite group is simple.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : AddGroup \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsSimpleAddGroup \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : Group \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsSimpleGroup \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : AddGroup \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsAddCyclic \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : Group \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)], Fintype.card \u03b1 = p \u2192 IsCyclic \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [self : LinearOrderedCommGroupWithZero \u03b1] (a : \u03b1), a \u2260 0 \u2192 a * a\u207b\u00b9 = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val \u2192 \u2200 (t : Finset \u2191s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\": \"\u2200 {G : Type u_1} [inst : Group G], Group.FG G \u2194 Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x \u2208 (Nat.factorization (Fintype.card G)).support }) \u2192 (P : Sylow (\u2191p) G) \u2192 { x // x \u2208 \u2191P }) \u2243* G \u2192\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val \u2192 \u2200 (t : Finset \u2191s), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"}]\n"
  },
  {
    "stmt": "Every finite group has prime order.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : AddGroup \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsAddCyclic \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : Group \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)], Fintype.card \u03b1 = p \u2192 IsCyclic \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : Group \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsSimpleGroup \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : AddGroup \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsSimpleAddGroup \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : Fintype \u03b1] [inst_1 : Field \u03b1], IsPrimePow (Fintype.card \u03b1)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x\u207b\u00b9 \u2194 IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x \u2194 IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I \u2192 Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : \u2115) [hp : Fact (Nat.Prime p)],\\n  p \u2223 Fintype.card G \u2192 \u2203 x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_2} [inst : Group G] {G\u2082 : Type u_1} [inst_1 : Group G\u2082] (p\u2081 p\u2082 : \u2115) [hp\u2081 : Fact (Nat.Prime p\u2081)]\\n  [hp\u2082 : Fact (Nat.Prime p\u2082)],\\n  p\u2081 \u2260 p\u2082 \u2192\\n    \u2200 (H\u2081 : Subgroup G) (H\u2082 : Subgroup G\u2082) [inst_2 : Fintype { x // x \u2208 H\u2081 }] [inst_3 : Fintype { x // x \u2208 H\u2082 }],\\n      IsPGroup p\u2081 { x // x \u2208 H\u2081 } \u2192\\n        IsPGroup p\u2082 { x // x \u2208 H\u2082 } \u2192 Nat.coprime (Fintype.card { x // x \u2208 H\u2081 }) (Fintype.card { x // x \u2208 H\u2082 })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"}]\n"
  },
  {
    "stmt": "Every set has Lebesgue measure zero.",
    "prompts": "[{\"theorem\": \"\u2191\u2191MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"\u2200 {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace \u211d E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional \u211d E] (\u03bc : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure \u03bc] {s : Set E} (u : \u2115 \u2192 E),\\n  Metric.Bounded (Set.range u) \u2192 Pairwise (Disjoint on fun n => {u n} + s) \u2192 MeasurableSet s \u2192 \u2191\u2191\u03bc s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : TopologicalSpace \u03b1] [inst_1 : TopologicalSpace.SecondCountableTopology \u03b1]\\n  (m : MeasureTheory.OuterMeasure \u03b1) (s : Set \u03b1), (\u2200 (x : \u03b1), x \u2208 s \u2192 \u2203 u, u \u2208 nhdsWithin x s \u2227 \u2191m u = 0) \u2192 \u2191m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"\u2200 {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace \u211d E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional \u211d E] (\u03bc : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure \u03bc] (s : AffineSubspace \u211d E), s \u2260 \u22a4 \u2192 \u2191\u2191\u03bc \u2191s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict affine subspace has measure zero. \"},\n {\"theorem\":\n  \"\u2200 {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace \u211d E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional \u211d E] (\u03bc : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure \u03bc] (s : Submodule \u211d E), s \u2260 \u22a4 \u2192 \u2191\u2191\u03bc \u2191s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"\u2200 {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace \u211d E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional \u211d E] (\u03bc : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure \u03bc] {s : Set E} (u : \u2115 \u2192 E),\\n  Metric.Bounded s \u2192\\n    Metric.Bounded (Set.range u) \u2192 Pairwise (Disjoint on fun n => {u n} + s) \u2192 MeasurableSet s \u2192 \u2191\u2191\u03bc s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] {\u03bc : MeasureTheory.Measure \u03b1} [inst_1 : MeasureTheory.SigmaFinite \u03bc]\\n  (s : Set \u03b1), (\u2200 (n : \u2115), \u2191\u2191\u03bc (s \u2229 MeasureTheory.spanningSets \u03bc n) = 0) \u2194 \u2191\u2191\u03bc s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set in a \u03c3-finite space has zero measure if and only if its intersection with\\nall members of the countable family of finite measure spanning sets has zero measure. \"},\n {\"theorem\":\n  \"\u2200 {\u03a9 : Type u_2} [inst : MeasurableSpace \u03a9] [inst_1 : TopologicalSpace \u03a9] [inst_2 : OpensMeasurableSpace \u03a9]\\n  {\u03b3 : Type u_1} {F : Filter \u03b3} {\u03bcs : \u03b3 \u2192 MeasureTheory.FiniteMeasure \u03a9},\\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (\u03bcs i)) F (nhds 0) \u2192 Filter.Tendsto \u03bcs F (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the total masses of finite measures tend to zero, then the measures tend to zero. \"},\n {\"theorem\":\n  \"\u2191\u2191MeasureTheory.volume (\u22c3 (p : \u211d) (_ : 2 < p), {x | LiouvilleWith p x}) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\\nmeasure zero. \"},\n {\"theorem\": \"\u2200 (n : \u2115), Real.convergent 0 n = 0\",\n  \"isProp\": true,\n  \"docString\": \"All convergents of `0` are zero. \"}]\n"
  },
  {
    "stmt": "If a topological space is compact, then every subset is compact.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : Finite \u03b1], CompactSpace \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\": \"\u2200 (self : CompHaus), CompactSpace \u2191self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : EMetricSpace \u03b1] [inst_1 : CompactSpace \u03b1], CompactSpace (TopologicalSpace.Closeds \u03b1)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : LocallyCompactSpace \u03b1] {K : Set \u03b1},\\n  IsCompact K \u2192 \u2203 K', IsCompact K' \u2227 K \u2286 interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : TopologicalSpace \u03b1] [inst_1 : TopologicalSpace.NoetherianSpace \u03b1] (s : Set \u03b1), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] {s t : Set \u03b1}, IsCompact s \u2192 IsClosed t \u2192 t \u2286 s \u2192 IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"\u2200 {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : TopologicalSpace \u03b1] [self : LocallyCompactSpace \u03b1] (x : \u03b1) (n : Set \u03b1),\\n  n \u2208 nhds x \u2192 \u2203 s, s \u2208 nhds x \u2227 s \u2286 n \u2227 IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : LocallyCompactSpace \u03b1] (x : \u03b1), \u2203 K, IsCompact K \u2227 K \u2208 nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : EMetricSpace \u03b1] [inst_1 : CompactSpace \u03b1], CompactSpace (TopologicalSpace.NonemptyCompacts \u03b1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact space, the type of nonempty compact subsets is compact. This follows from\\nthe same statement for closed subsets \"}]\n"
  },
  {
    "stmt": "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.",
    "prompts": "[{\"theorem\": \"\u2191\u2191MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"\u2200 {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace \u211d E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional \u211d E] (\u03bc : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure \u03bc] {s : Set E} (u : \u2115 \u2192 E),\\n  Metric.Bounded (Set.range u) \u2192 Pairwise (Disjoint on fun n => {u n} + s) \u2192 MeasurableSet s \u2192 \u2191\u2191\u03bc s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : TopologicalSpace \u03b1] [inst_1 : TopologicalSpace.SecondCountableTopology \u03b1]\\n  (m : MeasureTheory.OuterMeasure \u03b1) (s : Set \u03b1), (\u2200 (x : \u03b1), x \u2208 s \u2192 \u2203 u, u \u2208 nhdsWithin x s \u2227 \u2191m u = 0) \u2192 \u2191m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"\u2200 {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace \u211d E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional \u211d E] (\u03bc : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure \u03bc] {s : Set E} (u : \u2115 \u2192 E),\\n  Metric.Bounded s \u2192\\n    Metric.Bounded (Set.range u) \u2192 Pairwise (Disjoint on fun n => {u n} + s) \u2192 MeasurableSet s \u2192 \u2191\u2191\u03bc s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"\u2200 {G : Type w} [inst : TopologicalSpace G] (\u03bc : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S \u2264 MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure \u03bc)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul\u2082 G]\\n  (\u03bc \u03bd : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite \u03bd] [inst_4 : MeasureTheory.SigmaFinite \u03bc]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant \u03bc]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant \u03bd],\\n  MeasurableSet s \u2192 \u2191\u2191\u03bd s \u2260 0 \u2192 \u2191\u2191\u03bd s \u2260 \u22a4 \u2192 \u03bc = (\u2191\u2191\u03bc s / \u2191\u2191\u03bd s) \u2022 \u03bd\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : TopologicalSpace \u03b1] [inst_1 : MeasurableSpace \u03b1] [inst_2 : BorelSpace \u03b1],\\n  OpensMeasurableSpace \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] {\u03bc : MeasureTheory.Measure \u03b1} [inst_1 : MeasureTheory.SigmaFinite \u03bc]\\n  (s : Set \u03b1), (\u2200 (n : \u2115), \u2191\u2191\u03bc (s \u2229 MeasureTheory.spanningSets \u03bc n) = 0) \u2194 \u2191\u2191\u03bc s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set in a \u03c3-finite space has zero measure if and only if its intersection with\\nall members of the countable family of finite measure spanning sets has zero measure. \"},\n {\"theorem\":\n  \"\u2200 {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace \u211d E] [inst_2 : FiniteDimensional \u211d E] {s : Set E}\\n  {f : E \u2192 E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (\u03bc : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure \u03bc], DifferentiableOn \u211d f s \u2192 \u2191\u2191\u03bc s = 0 \u2192 \u2191\u2191\u03bc (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd\u2082 G]\\n  (\u03bc \u03bd : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite \u03bd] [inst_4 : MeasureTheory.SigmaFinite \u03bc]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant \u03bc]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant \u03bd],\\n  MeasurableSet s \u2192 \u2191\u2191\u03bd s \u2260 0 \u2192 \u2191\u2191\u03bd s \u2260 \u22a4 \u2192 \u03bc = (\u2191\u2191\u03bc s / \u2191\u2191\u03bd s) \u2022 \u03bd\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"}]\n"
  },
  {
    "stmt": "A finitely-presented group containing a torsion element is finite.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"\u2200 {R : Type w\u2081} {A : Type w\u2082} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\\n  Algebra.FinitePresentation R A \u2192 Algebra.FiniteType R A\",\n  \"isProp\": true,\n  \"docString\": \"A finitely presented algebra is of finite type. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G \u2192* H},\\n  N = MonoidHom.ker f \u2192 Monoid.IsTorsion H \u2192 Monoid.IsTorsion { x // x \u2208 N } \u2192 Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G \u2192 \u2200 (H : Subgroup G), Monoid.IsTorsionFree { x // x \u2208 H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G \u2192+ H},\\n  N = AddMonoidHom.ker f \u2192 AddMonoid.IsTorsion H \u2192 AddMonoid.IsTorsion { x // x \u2208 N } \u2192 AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G], Monoid.ExponentExists G \u2192 Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"If a group exponent exists, the group is torsion. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G], Monoid.IsTorsion G \u2192 \u2200 (H : Subgroup G), Monoid.IsTorsion { x // x \u2208 H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G \u2192 \u2200 (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x \u2208 H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G \u2192 Set.Finite (Set.range fun g => orderOf g) \u2192 Monoid.ExponentExists G\",\n  \"isProp\": true,\n  \"docString\": \"The group exponent exists for any bounded torsion group. \"}]\n"
  },
  {
    "stmt": "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] {s t : Set \u03b1}, IsCompact s \u2192 IsClosed t \u2192 t \u2286 s \u2192 IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : EMetricSpace \u03b1] {s : Set \u03b1}, IsClosed s \u2192 IsClosed {t | \u2191t \u2286 s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : EMetricSpace \u03b1] [inst_1 : CompactSpace \u03b1], CompactSpace (TopologicalSpace.Closeds \u03b1)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : LocallyCompactSpace \u03b1] {K : Set \u03b1},\\n  IsCompact K \u2192 \u2203 K', IsCompact K' \u2227 K \u2286 interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"\u2200 {\ud835\udd5c : Type u_2} {E : Type u_1} [inst : LinearOrderedField \ud835\udd5c] [inst_1 : AddCommGroup E] [inst_2 : Module \ud835\udd5c E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul \ud835\udd5c E] {s : Set E},\\n  Convex \ud835\udd5c s \u2192 Convex \ud835\udd5c (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] {s t : Set \u03b1}, IsCompact s \u2192 IsClosed t \u2192 IsCompact (s \u2229 t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense \u2191s \u2194 Submodule.topologicalClosure s = \u22a4\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"\u2200 {\ud835\udd5c : Type u} [inst : NontriviallyNormedField \ud835\udd5c] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace \ud835\udd5c E] [inst_3 : CompleteSpace \ud835\udd5c] (s : Submodule \ud835\udd5c E)\\n  [inst_4 : FiniteDimensional \ud835\udd5c { x // x \u2208 s }], IsClosed \u2191s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : Finite \u03b1], CompactSpace \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] {s t : Set \u03b1}, IsCompact t \u2192 IsClosed s \u2192 IsCompact (s \u2229 t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"}]\n"
  },
  {
    "stmt": "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X \u00d7 X$.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [inst : TopologicalSpace \u03b1] [inst_1 : TopologicalSpace \u03b2] [inst_2 : CompactSpace \u03b1]\\n  [inst_3 : T2Space \u03b2] {f : \u03b1 \u2192 \u03b2}, Continuous f \u2192 IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [inst : TopologicalSpace \u03b1] [inst_1 : TopologicalSpace \u03b2] [inst_2 : CompactSpace \u03b1]\\n  [inst_3 : T2Space \u03b2] {f : \u03b1 \u2192 \u03b2}, Function.Surjective f \u2192 Continuous f \u2192 QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [self : T2Space \u03b1] (x y : \u03b1),\\n  x \u2260 y \u2192 \u2203 u v, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\": \"\u2200 {X Y : CompHaus} (f : X \u27f6 Y), IsClosedMap \u2191f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [inst : TopologicalSpace \u03b1] [inst_1 : TopologicalSpace \u03b2] [inst_2 : CompactSpace \u03b1]\\n  [inst_3 : T2Space \u03b2] {f : \u03b1 \u2192 \u03b2}, Continuous f \u2192 Function.Injective f \u2192 ClosedEmbedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"theorem\":\n  \"\u2200 {X Y : CompHaus} (f : X \u27f6 Y), Function.Bijective \u2191f \u2192 CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"\u2200 {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"\u2200 {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X] {Y : Type v}\\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y] {\u03b3 : Type w} [inst_6 : MetricSpace \u03b3]\\n  {\u03a6 : X \u2192 \u03b3} {\u03a8 : Y \u2192 \u03b3},\\n  Isometry \u03a6 \u2192 Isometry \u03a8 \u2192 GromovHausdorff.ghDist X Y \u2264 Metric.hausdorffDist (Set.range \u03a6) (Set.range \u03a8)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\\nof isometric copies of the spaces, in any metric space. \"},\n {\"theorem\":\n  \"\u2200 {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"theorem\":\n  \"\u2200 {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H \u2194 TotallySeparatedSpace H\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"}]\n"
  },
  {
    "stmt": "Any finite order element in a group is equal to the identity.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [self : LinearOrderedCommGroupWithZero \u03b1] (a : \u03b1), a \u2260 0 \u2192 a * a\u207b\u00b9 = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x \u2194 IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x\u207b\u00b9 \u2194 IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x \u2192 IsOfFinOrder y \u2192 IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x \u2194 IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"\u2200 {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G \u2192* H) {x : G},\\n  IsOfFinOrder x \u2192 IsOfFinOrder (\u2191f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G \u2192+ H) {x : G},\\n  IsOfFinAddOrder x \u2192 IsOfFinAddOrder (\u2191f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x \u2192 IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x \u2208 H }), IsOfFinAddOrder x \u2194 IsOfFinAddOrder \u2191x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : AddGroup \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsAddCyclic \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"}]\n"
  },
  {
    "stmt": "If a subgroup of a group is torsion-free, then the group itself is torsion free.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G \u2192 \u2200 (H : Subgroup G), Monoid.IsTorsionFree { x // x \u2208 H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"\u2200 (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G \u29f8 CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G \u2192 \u2200 (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x \u2208 H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"\u2200 {\u03b7 : Type u_1} {Gs : \u03b7 \u2192 Type u_2} [inst : (i : \u03b7) \u2192 Group (Gs i)],\\n  (\u2200 (i : \u03b7), Monoid.IsTorsionFree (Gs i)) \u2192 Monoid.IsTorsionFree ((i : \u03b7) \u2192 Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G], Monoid.IsTorsion G \u2192 \u2200 (H : Subgroup G), Monoid.IsTorsion { x // x \u2208 H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"\u2200 (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G \u29f8 AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"\u2200 {\u03b7 : Type u_1} {Gs : \u03b7 \u2192 Type u_2} [inst : (i : \u03b7) \u2192 AddGroup (Gs i)],\\n  (\u2200 (i : \u03b7), AddMonoid.IsTorsionFree (Gs i)) \u2192 AddMonoid.IsTorsionFree ((i : \u03b7) \u2192 Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"\u2200 (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G \u2192 \u2200 (H : AddSubgroup G), AddMonoid.IsTorsion { x // x \u2208 H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"}]\n"
  },
  {
    "stmt": "Every injective homomorphism from a finitely generated free group to itself is surjective.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M \u2192\u2097[R] M), Function.Injective \u2191f \u2192 Function.Surjective \u2191f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [inst : Group \u03b1] [inst_1 : Group \u03b2] {f : \u03b1 \u2192 \u03b2},\\n  IsGroupHom f \u2192 (Function.Injective f \u2194 \u2200 (a : \u03b1), f a = 1 \u2192 a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"\u2200 {\u03b9 : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite \u03b9] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R \u2192\\n    \u2200 (ps : \u03b9 \u2192 MvPolynomial \u03b9 R),\\n      (Function.Injective fun v i => \u2191(MvPolynomial.eval v) (ps i)) \u2192\\n        Function.Surjective fun v i => \u2191(MvPolynomial.eval v) (ps i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M \u2192\u2097[R] M), Function.Surjective \u2191f \u2192 Function.Injective \u2191f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"\u2200 {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : \u22a4 \u2192g G'), Function.Injective \u2191f\",\n  \"isProp\": true,\n  \"docString\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"theorem\":\n  \"\u2200 {R\u2081 : Type u_1} {R\u2082 : Type u_2} [inst : Semiring R\u2081] [inst_1 : Semiring R\u2082] {\u03c3 : R\u2081 \u2192+* R\u2082}\\n  [self : RingHomSurjective \u03c3], Function.Surjective \u2191\u03c3\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [inst : AddGroup \u03b1] [inst_1 : AddGroup \u03b2] {f : \u03b1 \u2192 \u03b2},\\n  IsAddGroupHom f \u2192 (Function.Injective f \u2194 \u2200 (a : \u03b1), f a = 0 \u2192 a = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M \u2192\u2097[R] M), Function.Injective \u2191f \u2192 Function.Bijective \u2191f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"theorem\":\n  \"\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V \u2192\u2097[K] V}, Function.Injective \u2191f \u2192 Function.Surjective \u2191f\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), \u2191f a\u207b\u00b9 = (\u2191f a)\u207b\u00b9\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"}]\n"
  },
  {
    "stmt": "Every division ring is either a field or finite.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {K : Type u_1} [inst : DivisionRing K] {\u0393\u2080 : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero \u0393\u2080]\\n  [inst_2 : Valued K \u0393\u2080], SeparatedSpace K\",\n  \"isProp\": true,\n  \"docString\": \"A valued division ring is separated. \"},\n {\"theorem\": \"\u2200 (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"\u2200 {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x \u2208 S \u2192 y \u2208 S \u2192 x / y \u2208 S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\":\n  \"\u2200 {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 \u2208 S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"\u2200 (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is integral if it is finite. \"},\n {\"theorem\":\n  \"\u2200 {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 \u2208 S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : LinearOrderedSemifield \u03b1] [inst_1 : FloorSemiring \u03b1] (m n : \u2115), \u230a\u2191m / \u2191n\u230b\u208a = m / n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is the floor of field division. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of rings has all limits. \"},\n {\"theorem\":\n  \"\u2200 {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = \u22a5 \u2228 I = \u22a4\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\": \"\u2200 {R : Type u} [inst : Semiring R], IsField R \u2192 \u2203 x y, x \u2260 y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"}]\n"
  },
  {
    "stmt": "Every natural number is the product of two primes.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x \u2260 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"\u2200 {a b x y u v : \u2115}, a = x ^ 2 + y ^ 2 \u2192 b = u ^ 2 + v ^ 2 \u2192 \u2203 r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"\u2200 {m n : \u2115}, (\u2200 (a : \u2115), a \u2223 m \u2194 a \u2223 n) \u2194 m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"\u2200 {m n : \u2115}, (\u2200 (a : \u2115), m \u2223 a \u2194 n \u2223 a) \u2194 m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : CancelCommMonoidWithZero \u03b1] [dec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid \u03b1] [dec : DecidableEq \u03b1] [dec' : DecidableEq (Associates \u03b1)] {a p : Associates \u03b1},\\n  Irreducible p \u2192\\n    \u2200 [inst_2 : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)] {n : \u2115} (h : a \u2223 p ^ n),\\n      a = p ^ Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : Semiring \u03b1] {I : Ideal \u03b1} [self : Ideal.IsPrime I] {x y : \u03b1}, x * y \u2208 I \u2192 x \u2208 I \u2228 y \u2208 I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"\u2200 (a b : \u2115), a \u2260 0 \u2192 b \u2260 0 \u2192 (a = b \u2194 \u2200 (p : \u2115), Nat.Prime p \u2192 padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : LinearOrderedRing \u03b1] [inst_1 : Archimedean \u03b1] {x y : \u03b1},\\n  1 \u2264 x \u2192 1 < y \u2192 \u2203 n, y ^ n \u2264 x \u2227 x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"\u2200 (p : \u2115) [inst : Fact (Nat.Prime p)], Prime \u2191p \u2194 p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `\u2124[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {\u03b9 : Type u_1} (s : Finset \u03b9)\\n  (f : \u03b9 \u2192 Ideal R) (e : \u03b9 \u2192 \u2115),\\n  (\u2200 (i : \u03b9), i \u2208 s \u2192 Prime (f i)) \u2192\\n    (\u2200 (i : \u03b9), i \u2208 s \u2192 \u2200 (j : \u03b9), j \u2208 s \u2192 i \u2260 j \u2192 f i \u2260 f j) \u2192\\n      (Finset.inf s fun i => f i ^ e i) = Finset.prod s fun i => f i ^ e i\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of distinct prime powers in a Dedekind domain is the product of these\\nprime powers. \"}]\n"
  },
  {
    "stmt": "Every even number is the square of a natural number.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {a b x y u v : \u2115}, a = x ^ 2 + y ^ 2 \u2192 b = u ^ 2 + v ^ 2 \u2192 \u2203 r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"\u2200 {m n : \u2115}, (\u2200 (a : \u2115), m \u2223 a \u2194 n \u2223 a) \u2194 m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"\u2200 {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 \u2192 \u2200 (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"\u2200 (a b c d x y z w : \u2115),\\n  Int.natAbs (\u2191a * \u2191x - \u2191b * \u2191y - \u2191c * \u2191z - \u2191d * \u2191w) ^ 2 + Int.natAbs (\u2191a * \u2191y + \u2191b * \u2191x + \u2191c * \u2191w - \u2191d * \u2191z) ^ 2 +\\n        Int.natAbs (\u2191a * \u2191z - \u2191b * \u2191w + \u2191c * \u2191x + \u2191d * \u2191y) ^ 2 +\\n      Int.natAbs (\u2191a * \u2191w + \u2191b * \u2191z - \u2191c * \u2191y + \u2191d * \u2191x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x \u2260 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"\u2200 {\ud835\udd5c : Type u\ud835\udd5c} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G \u2192 E} {g : G \u2192 E'} {x : G}\\n  [inst_3 : NontriviallyNormedField \ud835\udd5c] [inst_4 : NormedSpace \ud835\udd5c E] [inst_5 : NormedSpace \ud835\udd5c E'] [inst_6 : NormedSpace \ud835\udd5c F]\\n  (L : E \u2192L[\ud835\udd5c] E' \u2192L[\ud835\udd5c] F) [inst_7 : MeasurableSpace G] {\u03bc : MeasureTheory.Measure G} [inst_8 : NormedSpace \u211d F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant \u03bc]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant \u03bc] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (\u2200\u1d50 (x : G) \u2202\u03bc, f (-x) = f x) \u2192 (\u2200\u1d50 (x : G) \u2202\u03bc, g (-x) = g x) \u2192 convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\": \"\u2200 {n : \u2115}, IsSquare (-1) \u2192 \u2203 x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"\u2200 {m n : \u2115}, (\u2200 (a : \u2115), a \u2223 m \u2194 a \u2223 n) \u2194 m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"\u2200 {n : \u2115}, (\u2203 x y, n = x ^ 2 + y ^ 2) \u2194 \u2200 {q : \u2115}, Nat.Prime q \u2192 q % 4 = 3 \u2192 Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : LinearOrderedRing \u03b1] [inst_1 : Archimedean \u03b1] {x y : \u03b1},\\n  1 \u2264 x \u2192 1 < y \u2192 \u2203 n, y ^ n \u2264 x \u2227 x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"}]\n"
  },
  {
    "stmt": "Every normal subgroup of a group has finite index.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H \u2260 0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H \u2260 0\",\n  \"isProp\": true,\n  \"docString\": \"The additive subgroup has finite index \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x \u2208 H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P \u2194 Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {\u03b9 : Type u_1} {s : Set \u03b9}, Basis (\u2191s) R M \u2192 Module.rank R M < Cardinal.aleph0 \u2192 Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a module has a finite dimension, all bases are indexed by a finite set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : Group \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsSimpleGroup \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"\u2200 (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\\n  Set.Finite A \u2192 FiniteDimensional K { x // x \u2208 Submodule.span K A }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The submodule generated by a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"{G : Type u_1} \u2192 [inst : Group G] \u2192 (H : Subgroup G) \u2192 [inst_1 : Subgroup.FiniteIndex H] \u2192 Fintype (G \u29f8 H)\",\n  \"isProp\": false,\n  \"docString\": \"A finite index subgroup has finite quotient. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G \u2192* R), Function.Injective \u2191f \u2192 IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G] (H\u2081 H\u2082 : Subgroup G),\\n  Subgroup.Normal H\u2081 \u2192 Subgroup.Normal H\u2082 \u2192 Disjoint H\u2081 H\u2082 \u2192 \u2200 (x y : G), x \u2208 H\u2081 \u2192 y \u2208 H\u2082 \u2192 Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"}]\n"
  },
  {
    "stmt": "The characteristic polynomial of every matrix has real roots.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u_2} {n : Type u_1} [inst : IsROrC \u03b1] {A : Matrix n n \u03b1},\\n  Matrix.IsHermitian A \u2192 (fun i => \u2191(\u2191IsROrC.re (Matrix.diag A i))) = Matrix.diag A\",\n  \"isProp\": true,\n  \"docString\":\n  \"The diagonal elements of a complex hermitian matrix are real. \"},\n {\"theorem\":\n  \"\u2200 {f : Polynomial \u2102}, 0 < Polynomial.degree f \u2192 \u2203 z, Polynomial.IsRoot f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of algebra**: every non constant complex polynomial\\nhas a root \"},\n {\"theorem\":\n  \"\u2200 {\ud835\udd5c : Type u_1} [inst : IsROrC \ud835\udd5c] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace \ud835\udd5c E]\\n  {T : E \u2192\u2097[\ud835\udd5c] E}, LinearMap.IsSymmetric T \u2192 \u2200 {\u03bc : \ud835\udd5c}, Module.End.HasEigenvalue T \u03bc \u2192 \u2191(starRingEnd \ud835\udd5c) \u03bc = \u03bc\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"\u2200 (p : Polynomial \u211d),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) \u2264\\n    Finset.card (Multiset.toFinset (Polynomial.roots (\u2191Polynomial.derivative p))) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"\u2200 {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x \u2192 x \u2260 0 \u2192 Polynomial.coeff (minpoly A x) 0 \u2260 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"theorem\":\n  \"\u2200 {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F \u211d] (p : Polynomial F),\\n  Fintype.card \u2191(Polynomial.rootSet p \u211d) \u2264 Fintype.card \u2191(Polynomial.rootSet (\u2191Polynomial.derivative p) \u211d) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of real roots of a polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"\u2200 {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra \u2102 A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule \u2102 A] (a : { x // x \u2208 selfAdjoint A }) {z : \u2102},\\n  z \u2208 spectrum \u2102 \u2191a \u2192 z = \u2191z.re\",\n  \"isProp\": true,\n  \"docString\": \"Any element of the spectrum of a selfadjoint is real. \"},\n {\"theorem\":\n  \"\u2200 {\u03c3 : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial \u03c3 R),\\n  \u2203 n f _hf q, p = \u2191(MvPolynomial.rename f) q\",\n  \"isProp\": true,\n  \"docString\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"theorem\":\n  \"\u2200 {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x \u2192 0 < Polynomial.degree (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"The degree of a minimal polynomial is positive. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero \u03b1] [inst_2 : One \u03b1], Matrix.IsDiag 1\",\n  \"isProp\": true,\n  \"docString\": \"Every identity matrix is diagonal. \"}]\n"
  },
  {
    "stmt": "In a commutative ring, every prime ideal is contained in a unique maximal ideal.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {R : Type u} [inst : CommRing R],\\n  (\u2200 (P : Ideal R), Ideal.IsPrime P \u2192 Submodule.IsPrincipal P) \u2192 IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I \u2194 IsField (R \u29f8 I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} [inst : CommRing R],\\n  Set.Finite {I | Ideal.IsMaximal I} \u2192 \u2200 {I : Ideal R}, IsUnit \u2191I \u2192 Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R \u29f8 I) \u2192 Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"\u2200 (\u03b1 : Type u) [inst : Semiring \u03b1] [inst_1 : Nontrivial \u03b1], \u2203 M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : Semiring \u03b1] {I : Ideal \u03b1} [self : Ideal.IsMaximal I], IsCoatom I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\\nand there are no other proper ideals strictly containing it. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed \u2191I\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\\n  [inst_3 : IsLocalization S A],\\n  S \u2264 nonZeroDivisors R \u2192\\n    Set.Finite {I | Ideal.IsMaximal I} \u2192 \u2200 (I I' : FractionalIdeal S A), I * I' = 1 \u2192 Submodule.IsPrincipal \u2191I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I \u2192 Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"}]\n"
  },
  {
    "stmt": "Every continuous function is uniformly continuous.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b9 : Type u_1} {\u03b1 : Type u_2} {\u03b2 : Type u_3} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2] {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1},\\n  UniformEquicontinuous F \u2192 \u2200 (i : \u03b9), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type x} [inst : UniformSpace \u03b2] {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {p : Filter \u03b9}\\n  [inst_1 : TopologicalSpace \u03b1],\\n  TendstoUniformly F f p \u2192 (\u2200\u1da0 (n : \u03b9) in p, Continuous (F n)) \u2192 \u2200 [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_2} {\u03b2 : Type u_1} {\u03b9 : Type u_3} {m : MeasurableSpace \u03b1} (\u03bc : MeasureTheory.Measure \u03b1)\\n  [inst : NormedAddCommGroup \u03b2] {p : ENNReal} {g : \u03b1 \u2192 \u03b2},\\n  1 \u2264 p \u2192 p \u2260 \u22a4 \u2192 MeasureTheory.Mem\u2112p g p \u2192 MeasureTheory.UnifIntegrable (fun x => g) p \u03bc\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [inst : UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2} [inst_1 : TopologicalSpace \u03b1],\\n  (\u2200 (u : Set (\u03b2 \u00d7 \u03b2)), u \u2208 uniformity \u03b2 \u2192 \u2203 F, Continuous F \u2227 \u2200 (y : \u03b1), (f y, F y) \u2208 u) \u2192 Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type x} [inst : UniformSpace \u03b2] {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {p : Filter \u03b9}\\n  [inst_1 : TopologicalSpace \u03b1],\\n  TendstoLocallyUniformly F f p \u2192 (\u2200\u1da0 (n : \u03b9) in p, Continuous (F n)) \u2192 \u2200 [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [inst : UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2} [inst_1 : TopologicalSpace \u03b1],\\n  (\u2200 (x : \u03b1) (u : Set (\u03b2 \u00d7 \u03b2)),\\n      u \u2208 uniformity \u03b2 \u2192 \u2203 t, t \u2208 nhds x \u2227 \u2203 F, ContinuousAt F x \u2227 \u2200 (y : \u03b1), y \u2208 t \u2192 (f y, F y) \u2208 u) \u2192\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_2} {\u03b2 : Type u_1} {\u03b9 : Type u_3} {m : MeasurableSpace \u03b1} {\u03bc : MeasureTheory.Measure \u03b1}\\n  [inst : NormedAddCommGroup \u03b2] {p : ENNReal} {g : \u03b1 \u2192 \u03b2},\\n  1 \u2264 p \u2192 p \u2260 \u22a4 \u2192 MeasureTheory.Mem\u2112p g p \u2192 MeasureTheory.UniformIntegrable (fun x => g) p \u03bc\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2] (self : \u03b1 \u2243\u1d64 \u03b2),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"\u2200 {\u03b9 : Type u_1} {X : Type u_2} {\u03b1 : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace \u03b1] {F : \u03b9 \u2192 X \u2192 \u03b1},\\n  Equicontinuous F \u2192 \u2200 (i : \u03b9), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_3} {\u03b2 : Type u_2} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2] {\u03b9 : Type u_1} {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1}\\n  [inst_2 : CompactSpace \u03b2], Equicontinuous F \u2192 UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"}]\n"
  },
  {
    "stmt": "Every uniformly continuous function is bounded above.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : LinearOrder \u03b1] [inst_1 : TopologicalSpace \u03b1] [inst_2 : OrderClosedTopology \u03b1]\\n  [inst_3 : TopologicalSpace \u03b2] [inst_4 : Nonempty \u03b1] {f : \u03b2 \u2192 \u03b1} {K : Set \u03b2},\\n  IsCompact K \u2192 ContinuousOn f K \u2192 BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : LinearOrder \u03b1] [inst_1 : TopologicalSpace \u03b1] [inst_2 : OrderClosedTopology \u03b1]\\n  [inst_3 : TopologicalSpace \u03b2] [inst_4 : Zero \u03b1] {f : \u03b2 \u2192 \u03b1},\\n  Continuous f \u2192 HasCompactSupport f \u2192 BddAbove (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded above. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type x} [inst : UniformSpace \u03b2] {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {p : Filter \u03b9}\\n  [inst_1 : TopologicalSpace \u03b1],\\n  TendstoUniformly F f p \u2192 (\u2200\u1da0 (n : \u03b9) in p, Continuous (F n)) \u2192 \u2200 [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : LinearOrder \u03b1] [inst_1 : TopologicalSpace \u03b1] [inst_2 : OrderClosedTopology \u03b1]\\n  [inst_3 : TopologicalSpace \u03b2] [inst_4 : Nonempty \u03b1] {f : \u03b2 \u2192 \u03b1} {K : Set \u03b2},\\n  IsCompact K \u2192 ContinuousOn f K \u2192 BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type x} [inst : UniformSpace \u03b2] {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {p : Filter \u03b9}\\n  [inst_1 : TopologicalSpace \u03b1],\\n  TendstoLocallyUniformly F f p \u2192 (\u2200\u1da0 (n : \u03b9) in p, Continuous (F n)) \u2192 \u2200 [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_2} {\u03b9 : Sort u_1} [inst : ConditionallyCompleteLattice \u03b1] [inst_1 : Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} {c : \u03b1},\\n  (\u2200 (x : \u03b9), f x \u2264 c) \u2192 iSup f \u2264 c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indexed supremum of a function is bounded above by a uniform bound\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : SemilatticeSup \u03b1] [inst_1 : Nonempty \u03b1] {s : Set \u03b1}, Set.Finite s \u2192 BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded above.\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : LinearOrder \u03b1] [inst_1 : TopologicalSpace \u03b1] [inst_2 : OrderClosedTopology \u03b1]\\n  [inst_3 : TopologicalSpace \u03b2] [inst_4 : Zero \u03b1] {f : \u03b2 \u2192 \u03b1},\\n  Continuous f \u2192 HasCompactSupport f \u2192 BddBelow (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded below. \"},\n {\"theorem\":\n  \"\u2200 {\u03b9 : Type u_1} {\u03b1 : Type u_2} {\u03b2 : Type u_3} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2] {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1},\\n  UniformEquicontinuous F \u2192 \u2200 (i : \u03b9), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : PseudoMetricSpace \u03b1] {f : \u211d \u2192 \u03b1} {c : \u211d},\\n  Function.Periodic f c \u2192 c \u2260 0 \u2192 Continuous f \u2192 Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"}]\n"
  },
  {
    "stmt": "If every compact subset of a topological space is closed, then the space is compact.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : Finite \u03b1], CompactSpace \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : EMetricSpace \u03b1] [inst_1 : CompactSpace \u03b1], CompactSpace (TopologicalSpace.Closeds \u03b1)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\": \"\u2200 (self : CompHaus), CompactSpace \u2191self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] {s t : Set \u03b1}, IsCompact s \u2192 IsClosed t \u2192 t \u2286 s \u2192 IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : LocallyCompactSpace \u03b1] {K : Set \u03b1},\\n  IsCompact K \u2192 \u2203 K', IsCompact K' \u2227 K \u2286 interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : T2Space \u03b1] {s : Set \u03b1}, IsCompact s \u2192 IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : LocallyCompactSpace \u03b1] [inst_2 : T2Space \u03b1] {K : Set \u03b1},\\n  IsCompact K \u2192 \u2203 V, IsOpen V \u2227 K \u2286 V \u2227 IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T\u2082 space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] {s t : Set \u03b1}, IsCompact t \u2192 IsClosed s \u2192 IsCompact (s \u2229 t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] {s t : Set \u03b1}, IsCompact s \u2192 IsClosed t \u2192 IsCompact (s \u2229 t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense \u2191s \u2194 Submodule.topologicalClosure s = \u22a4\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"}]\n"
  },
  {
    "stmt": "In a commutative ring, the sum of idempotent elements is idempotent.",
    "prompts": "[{\"theorem\": \"\u2200 {\u03b1 : Type u_1} [self : BooleanRing \u03b1] (a : \u03b1), a * a = a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R \u2243+* S)\\n  (x y : R), \u2191e (x + y) = \u2191e x + \u2191e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"},\n {\"theorem\":\n  \"\u2200 (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I \u2192 (IsIdempotentElem I \u2194 \u2203 e, IsIdempotentElem e \u2227 I = Submodule.span R {e})\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [self : StrictOrderedCommRing \u03b1] (a b : \u03b1), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R \u2243+* S)\\n  (x y : R), \u2191e (x * y) = \u2191e x * \u2191e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"\u2200 {\u03b2 : Type u} {\u03b1 : Type v} [inst : AddCommMonoid \u03b2] {s : Finset \u03b1} (f : \u03b1 \u2192 \u03b2),\\n  MulOpposite.op (Finset.sum s fun x => f x) = Finset.sum s fun x => MulOpposite.op (f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Moving to the opposite additive commutative monoid commutes with summing. \"},\n {\"theorem\":\n  \"\u2200 {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), \u2191f (a + b) = \u2191f a + \u2191f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"},\n {\"theorem\":\n  \"\u2200 (R : Type u) [inst : Semiring R] {\u03b9 : Type v} [dec_\u03b9 : DecidableEq \u03b9] {M : \u03b9 \u2192 Type w}\\n  [inst_1 : (i : \u03b9) \u2192 AddCommMonoid (M i)] [inst_2 : (i : \u03b9) \u2192 Module R (M i)] (s : Finset \u03b9) (c : R)\\n  (x : (i : \u2191\u2191s) \u2192 M \u2191i), \u2191(DirectSum.mk M s) (c \u2022 x) = c \u2022 \u2191(DirectSum.mk M s) x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication commutes with direct sums. \"},\n {\"theorem\": \"\u2200 {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"}]\n"
  },
  {
    "stmt": "The number of partitions of a finite set is a prime number.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : Fintype \u03b1] [inst_1 : Field \u03b1], IsPrimePow (Fintype.card \u03b1)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x \u2260 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : Group \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsSimpleGroup \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : AddGroup \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsSimpleAddGroup \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : Group \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)], Fintype.card \u03b1 = p \u2192 IsCyclic \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : AddGroup \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsAddCyclic \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"The variable of the power series ring over an integral domain is prime.\"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : \u2115) [inst_2 : Fact (Nat.Prime p)],\\n  p \u2223 ringChar R \u2194 p \u2223 Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {a : Set \u03b1}, Set.Finite a \u2192 Set.Finite {b | b \u2286 a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"\u2200 {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x \u2192 Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"}]\n"
  },
  {
    "stmt": "If a poset has a maximal element, then it has a unique minimal element.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {L : List (\u03b1 \u00d7 Bool)} [inst : DecidableEq \u03b1], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A word and its maximal reduction correspond to the same element of the free group. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [self : CompleteSemilatticeSup \u03b1] (s : Set \u03b1) (a : \u03b1), a \u2208 s \u2192 a \u2264 sSup s\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is less than the set supremum. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {a : \u03b1}, IsGreatest s a \u2192 sSup s = a\",\n  \"isProp\": true,\n  \"docString\": \"A greatest element of a set is the supremum of this set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {a : \u03b1}, IsLeast s a \u2192 sInf s = a\",\n  \"isProp\": true,\n  \"docString\": \"A least element of a set is the infimum of this set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop},\\n  (\u2200 (c : Set \u03b1), IsChain r c \u2192 \u2203 ub, \u2200 (a : \u03b1), a \u2208 c \u2192 r a ub) \u2192\\n    (\u2200 {a b c : \u03b1}, r a b \u2192 r b c \u2192 r a c) \u2192 \u2203 m, \u2200 (a : \u03b1), r m a \u2192 r a m\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {L\u2081 L\u2082 : List (\u03b1 \u00d7 Bool)} [inst : DecidableEq \u03b1],\\n  FreeAddGroup.Red L\u2081 L\u2082 \u2192 FreeAddGroup.reduce L\u2081 = FreeAddGroup.reduce L\u2082\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a word reduces to another word, then they have a common maximal reduction.\"},\n {\"theorem\":\n  \"\u2200 {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R \u2124) (I : { x // x \u2208 nonZeroDivisors (Ideal S) }),\\n  \u2203 b, b \u2208 \u2191I \u2227 b \u2260 0 \u2227 \u2200 (c : S), c \u2208 \u2191I \u2192 \u2191abv (\u2191(Algebra.norm R) c) < \u2191abv (\u2191(Algebra.norm R) b) \u2192 c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {L\u2081 L\u2082 : List (\u03b1 \u00d7 Bool)} [inst : DecidableEq \u03b1],\\n  FreeGroup.reduce L\u2081 = FreeGroup.reduce L\u2082 \u2192 FreeGroup.mk L\u2081 = FreeGroup.mk L\u2082\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words have a common maximal reduction, then they correspond to the same element in the\\nfree group. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {L\u2081 L\u2082 : List (\u03b1 \u00d7 Bool)} [inst : DecidableEq \u03b1],\\n  FreeGroup.Red L\u2081 L\u2082 \u2192 FreeGroup.reduce L\u2081 = FreeGroup.reduce L\u2082\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a word reduces to another word, then they have a common maximal reduction. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {L\u2081 L\u2082 : List (\u03b1 \u00d7 Bool)} [inst : DecidableEq \u03b1],\\n  FreeGroup.mk L\u2081 = FreeGroup.mk L\u2082 \u2192 FreeGroup.reduce L\u2081 = FreeGroup.reduce L\u2082\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words correspond to the same element in the free group, then they\\nhave a common maximal reduction. This is the proof that the function that sends\\nan element of the free group to its maximal reduction is well-defined. \"}]\n"
  },
  {
    "stmt": "The automorphism group of an Abelian group is cyclic.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : AddGroup \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)],\\n  Fintype.card \u03b1 = p \u2192 IsAddCyclic \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : Group \u03b1] [inst_1 : Fintype \u03b1] {p : \u2115} [hp : Fact (Nat.Prime p)], Fintype.card \u03b1 = p \u2192 IsCyclic \u03b1\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G \u2192* R), Function.Injective \u2191f \u2192 IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup R\u02e3) [inst_2 : Finite { x // x \u2208 S }],\\n  IsCyclic { x // x \u2208 S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\": \"\u2200 (H : AddSubgroup \u2124), \u2203 a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `\u2124` is cyclic. \"},\n {\"theorem\":\n  \"\u2200 {p : \u2115} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 \u2192 IsCyclic (G \u29f8 Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\": \"\u2200 {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive G\u1d43\u1d52\u1d56 G\",\n  \"isProp\": true,\n  \"docString\":\n  \"The right regular action of an additive group on itself is transitive.\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : Group \u03b1] [inst_1 : CommGroup \u03b2] {f g : \u03b1 \u2192 \u03b2},\\n  IsGroupHom f \u2192 IsGroupHom g \u2192 IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"\u2200 (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"}]\n"
  },
  {
    "stmt": "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {x : \u03b1}, Function.IsFixedPt f x \u2192 \u2200 (n : \u2115), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"theorem\":\n  \"\u2200 {f : Ordinal.{u} \u2192 Ordinal.{u}}, Ordinal.IsNormal f \u2192 Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The fixed point lemma for normal functions: any normal function has an unbounded set of\\nfixed points. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} (f : \u03b1 \u2192 \u03b1) (x : \u03b1), Function.IsPeriodicPt f 0 x\",\n  \"isProp\": true,\n  \"docString\": \"Any point is a periodic point of period `0`. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : TopologicalSpace \u03b1] [inst_1 : T2Space \u03b1] {f : \u03b1 \u2192 \u03b1},\\n  Continuous f \u2192 IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] {f : \u211d \u2192 \u03b1} {c : \u211d},\\n  Function.Periodic f c \u2192 c \u2260 0 \u2192 Continuous f \u2192 IsCompact (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function has compact range. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} {c : \u03b1} [inst : LinearOrderedAddCommGroup \u03b1] [inst_1 : Archimedean \u03b1],\\n  Function.Periodic f c \u2192 0 < c \u2192 \u2200 (x : \u03b1), \u2203 y, y \u2208 Set.Ico 0 c \u2227 f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y \u2208 Ico 0 c` such that `f x = f y`. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_2} {\u03b2 : Type u_1} {\u03b9 : Type u_3} {m : MeasurableSpace \u03b1} (\u03bc : MeasureTheory.Measure \u03b1)\\n  [inst : NormedAddCommGroup \u03b2] {p : ENNReal} {g : \u03b1 \u2192 \u03b2},\\n  1 \u2264 p \u2192 p \u2260 \u22a4 \u2192 MeasureTheory.Mem\u2112p g p \u2192 MeasureTheory.UnifIntegrable (fun x => g) p \u03bc\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\": \"\u2200 {\u03b1 : Type u_1} (n : \u2115) (x : \u03b1), Function.IsPeriodicPt id n x\",\n  \"isProp\": true,\n  \"docString\": \"For the identity map, all points are periodic. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : PseudoMetricSpace \u03b1] {f : \u211d \u2192 \u03b1} {c : \u211d},\\n  Function.Periodic f c \u2192 c \u2260 0 \u2192 Continuous f \u2192 Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} {c : \u03b1} [inst : LinearOrderedAddCommGroup \u03b1] [inst_1 : Archimedean \u03b1],\\n  Function.Periodic f c \u2192 0 < c \u2192 \u2200 (x a : \u03b1), \u2203 y, y \u2208 Set.Ico a (a + c) \u2227 f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y \u2208 Ico a (a + c)` such that `f x = f y`. \"}]\n"
  },
  {
    "stmt": "The complement of the union of two sets contains the union of their complements.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] {s : Set \u03b1} [self : IsClosed s], IsOpen s\u1d9c\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] (s : Set \u03b1), frontier s\u1d9c = frontier s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : PseudoMetricSpace \u03b1] {s t : Set \u03b1}, Metric.Bounded s \u2192 Metric.Bounded t \u2192 Metric.Bounded (s \u222a t)\",\n  \"isProp\": true,\n  \"docString\": \"The union of two bounded sets is bounded. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {E : Type u_2} {m0 : MeasurableSpace \u03b1} {p : ENNReal} {\u03bc : MeasureTheory.Measure \u03b1}\\n  [inst : NormedAddCommGroup E] {s t : Set \u03b1} (hs : MeasurableSet s) (ht : MeasurableSet t) (h\u03bcs : \u2191\u2191\u03bc s \u2260 \u22a4)\\n  (h\u03bct : \u2191\u2191\u03bc t \u2260 \u22a4),\\n  s \u2229 t = \u2205 \u2192\\n    \u2200 (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s \u222a t)) (_ : \u2191\u2191\u03bc (s \u222a t) \u2260 \u22a4) c =\\n        MeasureTheory.indicatorConstLp p hs h\u03bcs c + MeasureTheory.indicatorConstLp p ht h\u03bct c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} [inst : PseudoMetricSpace \u03b1] {s t : Set \u03b1}, Metric.Bounded (s \u222a t) \u2194 Metric.Bounded s \u2227 Metric.Bounded t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [inst : TopologicalSpace \u03b1] [inst_1 : TopologicalSpace \u03b2] [inst_2 : CompactSpace \u03b1]\\n  [inst_3 : CompactSpace \u03b2], CompactSpace (\u03b1 \u2295 \u03b2)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} (S T : Set \u03b1), Cardinal.mk \u2191(S \u222a T) \u2264 Cardinal.mk \u2191S + Cardinal.mk \u2191T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type ua} {\u03b2 : Type ub} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2] {a : Set (\u03b1 \u00d7 \u03b1)},\\n  a \u2208 uniformity \u03b1 \u2192\\n    \u2200 {b : Set (\u03b2 \u00d7 \u03b2)},\\n      b \u2208 uniformity \u03b2 \u2192\\n        (fun p => (Sum.inl p.fst, Sum.inl p.snd)) '' a \u222a (fun p => (Sum.inr p.fst, Sum.inr p.snd)) '' b \u2208\\n          UniformSpace.Core.sum.uniformity\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\\nof the diagonal. \"},\n {\"theorem\":\n  \"\u2200 (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s \u222a t) = affineSpan k s \u2294 affineSpan k t\",\n  \"isProp\": true,\n  \"docString\": \"The span of a union of sets is the sup of their spans. \"},\n {\"theorem\":\n  \"\u2200 {\u03b3 : Type w} [inst : SemilatticeSup \u03b3] {s t : Set \u03b3}, BddAbove (s \u222a t) \u2194 BddAbove s \u2227 BddAbove t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"}]\n"
  },
  {
    "stmt": "The square root of an rational number is rational.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : \u2115),\\n  \u2203 q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = \u2191q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"\u2200 {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) \u2192 \u2203 q, v = \u2191q\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"theorem\":\n  \"\u2200 (q : \u211a), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\": \"\u2200 (\u03be : \u211a), Set.Finite {q | |\u03be - q| < 1 / \u2191q.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"theorem\": \"\u2200 {r : \u211d}, Transcendental \u211a r \u2192 Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"\u2200 {a : \u2115}, \u2191(Nat.sqrt a) \u2264 Real.sqrt \u2191a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\":\n  \"\u2200 {\ud835\udd5c : Type u_1} [inst : LinearOrderedField \ud835\udd5c] [inst_1 : TopologicalSpace \ud835\udd5c] [inst_2 : OrderTopology \ud835\udd5c]\\n  [inst_3 : Archimedean \ud835\udd5c], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\": \"\u2200 {x y : \u211d}, x < y \u2192 \u2203 r, Irrational r \u2227 x < r \u2227 r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\": \"\u2200 {a : \u2115}, Real.sqrt \u2191a \u2264 \u2191(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\":\n  \"\u2200 (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra \u211a A] {x : K},\\n  IsIntegral \u2124 x \u2192 (\u2200 (\u03c6 : K \u2192+* A), \u2016\u2191\u03c6 x\u2016 = 1) \u2192 \u2203 n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"}]\n"
  },
  {
    "stmt": "If a module over a ring is free, then the ring is commutative.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V \u2194 Module.Finite K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"theorem\":\n  \"\u2200 {\u03b9 : Type u_1} (R : Type u) [inst : Semiring R] (M : \u03b9 \u2192 Type u_2) [inst_1 : Finite \u03b9]\\n  [inst_2 : (i : \u03b9) \u2192 AddCommMonoid (M i)] [inst_3 : (i : \u03b9) \u2192 Module R (M i)]\\n  [inst_4 : \u2200 (i : \u03b9), Module.Free R (M i)], Module.Free R ((i : \u03b9) \u2192 M i)\",\n  \"isProp\": true,\n  \"docString\": \"The product of finitely many free modules is free. \"},\n {\"theorem\":\n  \"\u2200 {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsAtomistic (Submodule K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The lattice of submodules of a module over a division ring is atomistic. \"},\n {\"theorem\":\n  \"\u2200 (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\\n  [inst_2 : Module R M], IsNoetherian R M\",\n  \"isProp\": true,\n  \"docString\": \"Modules over the trivial ring are Noetherian. \"},\n {\"theorem\":\n  \"\u2200 (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module with a finite ring of scalars is additively torsion. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\\n  Nonempty (M \u2243\u2097[R] N) \u2194 FiniteDimensional.finrank R M = FiniteDimensional.finrank R N\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite and free modules are isomorphic if and only if they have the same (finite) rank. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [self : Module.Finite R M], Submodule.FG \u22a4\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a semiring is `Finite` if it is finitely generated as a module. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} [inst : Ring R], CategoryTheory.EnoughProjectives (ModuleCat R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The category of modules has enough projectives, since every module is a quotient of a free\\nmodule. \"},\n {\"theorem\":\n  \"\u2200 {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Submodule K V), IsAtom W \u2194 \u2203 v x, W = Submodule.span K {v}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The atoms of the lattice of submodules of a module over a division ring are the\\nsubmodules equal to the span of a nonzero element of the module. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M \u29f8 Submodule.torsion R M) = \u22a5\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"}]\n"
  },
  {
    "stmt": "If the set of units of a ring forms a group then the ring is commutative.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {G : Type u_1} [inst : Group G], SMulCommClass G { x // x \u2208 Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : Group \u03b1] [inst_1 : CommGroup \u03b2] {f g : \u03b1 \u2192 \u03b2},\\n  IsGroupHom f \u2192 IsGroupHom g \u2192 IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"\u2200 {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x \u2208 Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [self : StrictOrderedCommRing \u03b1] (a b : \u03b1), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : Group \u03b1] [inst_1 : CommGroup \u03b2] {f : \u03b1 \u2192 \u03b2},\\n  IsGroupHom f \u2192 IsGroupHom fun a => (f a)\u207b\u00b9\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} [inst : Semiring R], IsField R \u2192 \u2200 (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_2} {\u03b2 : Type u_3} {\u03b3 : Type u_4} [inst : NonUnitalNonAssocSemiring \u03b1]\\n  [inst_1 : NonUnitalNonAssocSemiring \u03b2] [inst_2 : NonUnitalNonAssocSemiring \u03b3] {\u03b4 : Type u_1}\\n  {x : NonUnitalNonAssocSemiring \u03b4} (f : \u03b1 \u2192\u2099+* \u03b2) (g : \u03b2 \u2192\u2099+* \u03b3) (h : \u03b3 \u2192\u2099+* \u03b4),\\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of non-unital ring homomorphisms is associative. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [inst : Group \u03b1] [inst_1 : Group \u03b2] {f : \u03b1 \u2192 \u03b2}, IsGroupHom f \u2192 IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} [inst : CommRing R],\\n  (\u2200 (P : Ideal R), Ideal.IsPrime P \u2192 Submodule.IsPrincipal P) \u2192 IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"}]\n"
  },
  {
    "stmt": "Every natural number larger than `10` is the sum of a square and a prime.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x \u2260 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"\u2200 {a b x y u v : \u2115}, a = x ^ 2 + y ^ 2 \u2192 b = u ^ 2 + v ^ 2 \u2192 \u2203 r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"\u2200 {n : \u2115}, 0 < n \u2192 \u00acNat.Prime n \u2192 Nat.minFac n ^ 2 \u2264 n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\": \"\u2200 {n : \u2115}, IsSquare (-1) \u2192 \u2203 x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"\u2200 {a : \u2115}, Real.sqrt \u2191a \u2264 \u2191(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"\u2200 (p : \u2115) [inst : Fact (Nat.Prime p)], Prime \u2191p \u2194 p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `\u2124[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"\u2200 (R : Type u) [inst : Semiring R] (q : \u2115) [hq : ExpChar R q], Nat.Prime q \u2228 q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\": \"\u2200 (n : \u2115), n \u2260 0 \u2192 \u2203 p, Nat.Prime p \u2227 n < p \u2227 p \u2264 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\\nit, but no more than twice as large.\\n\"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : CancelCommMonoidWithZero \u03b1] [dec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid \u03b1] [dec : DecidableEq \u03b1] [dec' : DecidableEq (Associates \u03b1)] {a p : Associates \u03b1},\\n  Irreducible p \u2192\\n    \u2200 [inst_2 : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)] {n : \u2115} (h : a \u2223 p ^ n),\\n      a = p ^ Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"\u2200 {n : \u2115}, (\u2203 x y, n = x ^ 2 + y ^ 2) \u2194 \u2200 {q : \u2115}, Nat.Prime q \u2192 q % 4 = 3 \u2192 Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"}]\n"
  },
  {
    "stmt": "The initial object of a category is isomorphic to its terminal object.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {C : Type u\u2081} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) \u2192 Unique (Y \u27f6 X)],\\n  CategoryTheory.Limits.HasTerminal C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has a terminal object by specifying the object,\\nand showing there is a unique morphism to it from any other object. \"},\n {\"theorem\":\n  \"\u2200 {C : Type u\u2081} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X \u2192 \u2200 (f g : Y \u27f6 X), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms to a terminal object are equal. \"},\n {\"theorem\":\n  \"\u2200 {C : Type u\u2081} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) \u2192 Unique (X \u27f6 Y)],\\n  CategoryTheory.Limits.HasInitial C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has an initial object by specifying the object,\\nand showing there is a unique morphism from it to any other object. \"},\n {\"theorem\":\n  \"\u2200 {C : Type u\u2081} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"theorem\":\n  \"\u2200 {C : Type u\u2081} [inst : CategoryTheory.Category C] {D : Type u\u2082} [inst_1 : CategoryTheory.Category D]\\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F \u2192 CategoryTheory.Skeletal D\",\n  \"isProp\": true,\n  \"docString\": \"The category `D` has isomorphic objects equal \"},\n {\"theorem\":\n  \"\u2200 {C : Type u\u2081} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X \u2192 \u2200 (f : X \u27f6 Y), CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is mono. \"},\n {\"theorem\":\n  \"\u2200 {C : Type u\u2081} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\\n  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (\u22a4_ C)) \u2192 CategoryTheory.Limits.InitialMonoClass C\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\\ninitial object to a terminal object is a monomorphism. \"},\n {\"theorem\":\n  \"\u2200 {C : Type u\u2081} [inst : CategoryTheory.Category C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\\n  CategoryTheory.Limits.IsTerminal T \u2192\\n    CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI T) \u2192 CategoryTheory.Limits.InitialMonoClass C\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from an\\ninitial object to a terminal object is a monomorphism. \"},\n {\"theorem\":\n  \"\u2200 {C : Type u\u2081} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsInitial X \u2192 \u2200 (f g : X \u27f6 Y), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms from an initial object are equal. \"},\n {\"theorem\":\n  \"\u2200 {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"}]\n"
  },
  {
    "stmt": "If the composition of two functions is continuous, then each of them is continuous.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {\u03bc : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure \u03bc] {f g : X \u2192 Y},\\n  f =\u1da0[MeasureTheory.Measure.ae \u03bc] g \u2192 Continuous f \u2192 Continuous g \u2192 f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"\u2200 {\ud835\udd5c : Type u\ud835\udd5c} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G \u2192 E} {g : G \u2192 E'}\\n  [inst_3 : NontriviallyNormedField \ud835\udd5c] [inst_4 : NormedSpace \ud835\udd5c E] [inst_5 : NormedSpace \ud835\udd5c E'] [inst_6 : NormedSpace \ud835\udd5c F]\\n  (L : E \u2192L[\ud835\udd5c] E' \u2192L[\ud835\udd5c] F) [inst_7 : MeasurableSpace G] {\u03bc : MeasureTheory.Measure G} [inst_8 : NormedSpace \u211d F]\\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\\n  [inst_13 : TopologicalSpace.FirstCountableTopology G] [inst_14 : TopologicalSpace.SecondCountableTopology G],\\n  BddAbove (Set.range fun x => \u2016g x\u2016) \u2192 MeasureTheory.Integrable f \u2192 Continuous g \u2192 Continuous (convolution f g L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The convolution is continuous if one function is integrable and the other is bounded and\\ncontinuous. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_2} {\u03b2 : Type u_1} {\u03b3 : Type u_3} [inst : TopologicalSpace \u03b1] [inst_1 : TopologicalSpace \u03b2]\\n  [inst_2 : TopologicalSpace \u03b3] (e : LocalHomeomorph \u03b1 \u03b2) {f : \u03b2 \u2192 \u03b3} {s : Set \u03b2},\\n  s \u2286 e.target \u2192 (ContinuousOn f s \u2194 ContinuousOn (f \u2218 \u2191e) (e.source \u2229 \u2191e \u207b\u00b9' s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the right is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [inst : TopologicalSpace \u03b1] [inst_1 : TopologicalSpace \u03b2] [inst_2 : T2Space \u03b1] {s : Set \u03b2},\\n  Dense s \u2192 \u2200 {f g : \u03b2 \u2192 \u03b1}, Continuous f \u2192 Continuous g \u2192 Set.EqOn f g s \u2192 f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type x} [inst : UniformSpace \u03b2] {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {p : Filter \u03b9}\\n  [inst_1 : TopologicalSpace \u03b1],\\n  TendstoUniformly F f p \u2192 (\u2200\u1da0 (n : \u03b9) in p, Continuous (F n)) \u2192 \u2200 [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"\u2200 {\u03b9 : Type u_1} {X : Type u_2} {\u03b1 : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace \u03b1] {F : \u03b9 \u2192 X \u2192 \u03b1},\\n  Equicontinuous F \u2192 \u2200 (i : \u03b9), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_2} {\u03b2 : Type u_3} {\u03b3 : Type u_1} [inst : TopologicalSpace \u03b1] [inst_1 : TopologicalSpace \u03b2]\\n  [inst_2 : TopologicalSpace \u03b3] (e : LocalHomeomorph \u03b1 \u03b2) {f : \u03b3 \u2192 \u03b1} {s : Set \u03b3},\\n  s \u2286 f \u207b\u00b9' e.source \u2192 (ContinuousOn f s \u2194 ContinuousOn (\u2191e \u2218 f) s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the left is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"\u2200 {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {\u03bc : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure \u03bc] {U : Set X}\\n  {f g : X \u2192 Y},\\n  f =\u1da0[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict \u03bc U)] g \u2192\\n    IsOpen U \u2192 ContinuousOn f U \u2192 ContinuousOn g U \u2192 Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [inst : UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2} [inst_1 : TopologicalSpace \u03b1],\\n  (\u2200 (u : Set (\u03b2 \u00d7 \u03b2)), u \u2208 uniformity \u03b2 \u2192 \u2203 F, Continuous F \u2227 \u2200 (y : \u03b1), (f y, F y) \u2208 u) \u2192 Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_2} {\u03b2 : Type u_3} {\u03b3 : Type u_1} [inst : TopologicalSpace \u03b1] [inst_1 : TopologicalSpace \u03b2]\\n  [inst_2 : TopologicalSpace \u03b3] (e : LocalHomeomorph \u03b1 \u03b2) {f : \u03b3 \u2192 \u03b1},\\n  f \u207b\u00b9' e.source = Set.univ \u2192 (Continuous f \u2194 Continuous (\u2191e \u2218 f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous if and only if its composition with a local homeomorphism\\non the left is continuous and its image is contained in the source. \"}]\n"
  },
  {
    "stmt": "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b \u2192 AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"\u2200 {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b \u2192 Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"\u2200 {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b \u2192 Commute a c \u2192 Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"\u2200 {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b \u2192 AddCommute a c \u2192 AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"theorem\":\n  \"\u2200 {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c \u2192 Commute b c \u2192 Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"\u2200 {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c \u2192 AddCommute b c \u2192 AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\": \"\u2200 {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\": \"\u2200 {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\\n  [self : OrderedSMul R M] {a b : M} {c : R}, c \u2022 a < c \u2022 b \u2192 0 < c \u2192 a < b\",\n  \"isProp\": true,\n  \"docString\": \"If `c \u2022 a < c \u2022 b` for some positive `c`, then `a < b`. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [self : IsDirected \u03b1 r] (a b : \u03b1), \u2203 c, r a c \u2227 r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"}]\n"
  },
  {
    "stmt": "If an element maps to zero under a ring homomorphism, then it is zero.",
    "prompts": "[{\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {x : NonAssocSemiring \u03b1} {x_1 : NonAssocSemiring \u03b2} (f : \u03b1 \u2192+* \u03b2), \u2191f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms map zero to zero. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R \u2243+* S), \u2191f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends zero to zero. \"},\n {\"theorem\":\n  \"\u2200 {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P \u27f6 Q),\\n  (\u2200 (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 \u2192 a = 0) \u2192\\n    CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism that only maps the zero pseudoelement to zero is a monomorphism. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [inst : AddGroup \u03b1] [inst_1 : AddGroup \u03b2] {f : \u03b1 \u2192 \u03b2}, IsAddGroupHom f \u2192 f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"An additive group homomorphism sends 0 to 0.\"},\n {\"theorem\":\n  \"\u2200 {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P \u27f6 Q),\\n  Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f) \u2192\\n    \u2200 (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 \u2192 a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism that is injective on pseudoelements only maps the zero element to zero. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\\n  {r : R}, r \u2208 RingHom.ker f \u2194 \u2191f r = 0\",\n  \"isProp\": true,\n  \"docString\": \"An element is in the kernel if and only if it maps to zero.\"},\n {\"theorem\":\n  \"\u2200 {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} (Q : C)\\n  (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a = 0\",\n  \"isProp\": true,\n  \"docString\": \"The zero morphism maps every pseudoelement to 0. \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x \u2208 s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"\u2200 {M\u2080 : Type u_1} [inst : MulZeroOneClass M\u2080], 0 = 1 \u2192 \u2200 (a : M\u2080), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"theorem\":\n  \"\u2200 {R\u2081 : Type u_1} {R\u2082 : Type u_2} [inst : Semiring R\u2081] [inst_1 : Semiring R\u2082] [inst_2 : Norm R\u2081] [inst_3 : Norm R\u2082]\\n  {\u03c3 : R\u2081 \u2192+* R\u2082} [self : RingHomIsometric \u03c3] {x : R\u2081}, \u2016\u2191\u03c3 x\u2016 = \u2016x\u2016\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is an isometry. \"}]\n"
  },
  {
    "stmt": "Implication `\u2192` is symmetric. If `P \u2192 Q` then `Q \u2192 P`.",
    "prompts": "[{\"theorem\": \"\u2200 {p q r : Prop}, (p \u2192 q) \u2192 (q \u2192 r) \u2192 p \u2192 r\",\n  \"isProp\": true,\n  \"docString\":\n  \"Implication `\u2192` is transitive. If `P \u2192 Q` and `Q \u2192 R` then `P \u2192 R`. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Sort u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}, Equivalence r \u2192 \u2200 {x y : \u03b1}, r x y \u2192 r y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` \"},\n {\"theorem\":\n  \"\u2200 {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\\n  [inst_1 : CategoryTheory.Category D]\\n  [inst_2 :\\n    \u2200 (P : CategoryTheory.Functor C\u1d52\u1d56 D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\\n  (P : CategoryTheory.Functor C\u1d52\u1d56 D)\\n  [inst_3 : \u2200 (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)\u1d52\u1d56 D],\\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P)\",\n  \"isProp\": true,\n  \"docString\": \"`(P \u27f6 P\u207a)\u207a = P\u207a \u27f6 P\u207a\u207a` \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : Monoid \u03b1] {p q : \u03b1}, Irreducible p \u2192 Irreducible q \u2192 p \u2223 q \u2192 q \u2223 p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p \u2223 q` implies `q \u2223 p`. \"},\n {\"theorem\":\n  \"\u2200 {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P \u2192 CategoryTheory.MorphismProperty.RespectsIso P\",\n  \"isProp\": true,\n  \"docString\": \"`P` respects isomorphisms. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Sort u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}, Equivalence r \u2192 \u2200 {x y z : \u03b1}, r x y \u2192 r y z \u2192 r x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Sort u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}, Equivalence r \u2192 \u2200 (x : \u03b1), r x x\",\n  \"isProp\": true,\n  \"docString\": \"An equivalence relation is reflexive: `x ~ x` \"},\n {\"theorem\":\n  \"\u2200 {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] {P : Submodule R M \u2192 Prop},\\n  (\u2200 (I : Submodule R M), (\u2200 (J : Submodule R M), J > I \u2192 P J) \u2192 P I) \u2192 \u2200 (I : Submodule R M), P I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `\u2200 I > J, P I` implies `P J`, then `P` holds for all submodules. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u} {a b c d : \u03b1} [inst : Preorder \u03b1], c \u2264 a \u2192 b \u2264 d \u2192 a \u2264 b \u2192 c \u2264 d\",\n  \"isProp\": true,\n  \"docString\": \"monotonicity of `\u2264` with respect to `\u2192` \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Sort u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [self : Antisymm r] {a b : \u03b1}, r a b \u2192 r b a \u2192 a = b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An antisymmetric relation `(\u00b7\u2264\u00b7)` satisfies `a \u2264 b \u2192 b \u2264 a \u2192 a = b`. \"}]\n"
  },
  {
    "stmt": "Two natural numbers are equal if and only if they are both divisible by some prime number.",
    "prompts": "[{\"theorem\": \"\u2200 {m n : \u2115}, (\u2200 (a : \u2115), a \u2223 m \u2194 a \u2223 n) \u2194 m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"\u2200 {m n : \u2115}, (\u2200 (a : \u2115), m \u2223 a \u2194 n \u2223 a) \u2194 m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"\u2200 {a b : \u2115}, a \u2223 b \u2192 b < a \u2192 b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\": \"\u2200 {m n : \u2115}, m \u2223 m + n \u2194 m \u2223 n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x \u2260 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"\u2200 {m n : \u2115}, m \u2223 n + m \u2194 m \u2223 n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"theorem\": \"\u2200 (p : \u2115) [inst : Fact (Nat.Prime p)], Prime \u2191p \u2194 p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `\u2124[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : CancelCommMonoidWithZero \u03b1] [dec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid \u03b1] [dec : DecidableEq \u03b1] [dec' : DecidableEq (Associates \u03b1)] {a p : Associates \u03b1},\\n  Irreducible p \u2192\\n    \u2200 [inst_2 : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)] {n : \u2115} (h : a \u2223 p ^ n),\\n      a = p ^ Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"\u2200 {a b c : \u2124}, a % b = c \u2192 Int.natAbs (a - c) < Int.natAbs b \u2192 a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"\u2200 {\u03b1 : Type u_1} [inst : CancelCommMonoidWithZero \u03b1] [self : GCDMonoid \u03b1] {a b c : \u03b1}, a \u2223 c \u2192 a \u2223 b \u2192 a \u2223 gcd c b\",\n  \"isProp\": true,\n  \"docString\": \"Any common divisor of both elements is a divisor of the GCD. \"}]\n"
  }
]