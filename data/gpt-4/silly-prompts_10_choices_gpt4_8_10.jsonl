{"docString": "Every prime number is `2` or odd.", "choices": ["\u2200 {p : \u2115} [inst : Fact (Nat.Prime p)], p = 2 \u2228 Odd p ", "\u2200 (p : \u2115) [inst : Fact (Nat.Prime p)], p = 2 \u2228 Odd p ", "\u2200 {p : \u2115} [inst : Fact (Nat.Prime p)], p = 2 \u2228 Odd p ", "\u2200 {p : \u2115} [inst : Fact (Nat.Prime p)], p = 2 \u2228 Odd p ", "\u2200 {p : \u2115} [inst : Fact (Nat.Prime p)], p = 2 \u2228 Odd p ", "\u2200 (p : \u2115) [inst : Fact (Nat.Prime p)], p = 2 \u2228 Odd p ", "\u2200 {p : \u2115} [inst : Fact (Nat.Prime p)], p = 2 \u2228 Odd p ", "\u2200 {p : \u2115}, Nat.Prime p \u2192 (p = 2 \u2228 Odd p) ", "\u2200 (p : \u2115) [inst : Fact (Nat.Prime p)], p = 2 \u2228 Odd p ", "\u2200 (p : \u2115), Nat.Prime p \u2192 p = 2 \u2228 Odd p "]}
{"docString": "There are infinitely many odd natural numbers.", "choices": ["Filter.frequently (fun m => m % 2 = 1) Filter.atTop ", "Filter.frequently (fun n => n % 2 = 1) Filter.atTop ", "\u2203\u1da0 (m : \u2115) in Filter.atTop, m % 2 = 1 ", "Filter.frequently (fun x => x % 2 = 1) Filter.atTop ", "\u2203\u1da0 (m : \u2115) in Filter.atTop, m % 2 = 1 ", "Filter.frequently_of_forall (fun n : \u2115 => Nat.odd (2 * n + 1)) ", "Filter.frequently (fun m => m % 2 = 1) Filter.atTop ", "\u2203\u1da0 (n : \u2115) in Filter.atTop, n % 2 = 1 ", "\u2203\u1da0 (m : \u2115) in Filter.atTop, m % 2 = 1 ", "\u2203\u1da0 (n : \u2115) in Filter.atTop, n % 2 = 1 "]}
{"docString": "The smallest odd prime is `3`.", "choices": ["Nat.min_odd_prime : Nat.minFac 2 + 1 = 3 ", "Nat.min_odd_prime_is_3 : Nat.minFac 9 = 3 ", "Nat.min_odd_prime_is_3 : Nat.min_fac 9 = 3 ", "Nat.min_odd_prime = 3 ", "Nat.min_odd_prime = 3 ", "Nat.min_odd_prime_is_3 : Nat.minFac 9 = 3 ", "Nat.min_odd_prime_is_3 : Nat.min_odd_prime = 3 ", "Nat.min_odd_prime : \u2115 ", "Nat.min_odd_prime = 3 ", "Nat.min_odd_prime_is_three : Fact (Nat.min_fac 9 = 3) "]}
{"docString": "There are infinitely many odd prime numbers.", "choices": ["Set.Infinite {p | Nat.Prime p \u2227 p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p \u2227 Odd p} ", "Set.Infinite {p | Nat.Prime p \u2227 p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p \u2227 p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p \u2227 p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p \u2227 Odd p} ", "Set.Infinite {p | Nat.Prime p \u2227 Odd p} ", "Set.Infinite {p | Nat.Prime p \u2227 p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p \u2227 Odd p} ", "Set.Infinite {p | Nat.Prime p \u2227 Odd p} "]}
{"docString": "If a vector space has dimension `2` then it is finite dimensional.", "choices": ["forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 \u2192 FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 \u2192 FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 \u2192 FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 \u2192 FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 \u2192 FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 \u2192 FiniteDimensional K V ", "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 \u2192 FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 \u2192 FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 \u2192 FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 \u2192 FiniteDimensional K V "]}
{"docString": "Every field is a division ring.", "choices": ["\u2200 (K : Type u) [inst : Field K], DivisionRing K ", "\u2200 (K : Type u) [inst : Field K], DivisionRing K ", "\u2200 (K : Type u) [inst : Field K], DivisionRing K ", "\u2200 (K : Type u) [inst : Field K], DivisionRing K ", "\u2200 (K : Type u) [inst : Field K], DivisionRing K ", "\u2200 (K : Type u) [inst : Field K], DivisionRing K ", "\u2200 (K : Type u) [inst : Field K], DivisionRing K ", "\u2200 {K : Type u_1} [inst : Field K], DivisionRing K ", "\u2200 (K : Type u) [inst : Field K], DivisionRing K ", "\u2200 {K : Type u} [inst : Field K], DivisionRing K "]}
{"docString": "If a space has dimension `2` then it is finite dimensional.", "choices": ["\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (h : Module.rank K V = 2), FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], \n  findim K V = 2 \u2192 FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  (Module.rank K V = 2) \u2192 FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  (findim K V = 2) \u2192 FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 \u2192 FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : HasDimension (fin 2) V], FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], dim K V = 2 \u2192 FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {\u03b9 : Type w}\n  [inst_3 : Fintype \u03b9] (h_dim : Fintype.card \u03b9 = 2), FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : Findim K V = 2], FiniteDimensional K V ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], findim K V = 2 \u2192 FiniteDimensional K V "]}
{"docString": "Every natural number has a successor.", "choices": ["\u2200 (n : \u2115), \u2203 k, n + 1 = k ", "\u2200 (n : \u2115), \u2203 k, n + 1 = k ", "\u2200 (n : \u2115), \u2203 k, n + 1 = k ", "\u2200 (n : \u2115), \u2203 m, n + 1 = m ", "\u2200 (n : \u2115), \u2203 m, m = n + 1 ", "\u2200 (n : \u2115), \u2203 m, m = n + 1 ", "\u2200 (n : \u2115), \u2203 (k : \u2115), k = n + 1 ", "\u2200 (n : \u2115), \u2203 m, m = n + 1 ", "\u2200 (n : \u2115), \u2203 k, n + 1 = k ", "\u2200 (n : \u2115), \u2203 m, m = n + 1 "]}
{"docString": "Every natural number is less than its successor.", "choices": ["\u2200 {n : \u2115}, n < Nat.succ n ", "\u2200 (n : \u2115), n < n.succ ", "\u2200 {n : \u2115}, n < n.succ ", "\u2200 {n : \u2115}, n < n.succ ", "\u2200 (n : \u2115), n < n.succ ", "\u2200 (n : \u2115), n < n.succ ", "\u2200 {n : \u2115}, n < n.succ ", "\u2200 (n : \u2115), n < n + 1 ", "\u2200 (n : \u2115), n < n + 1 ", "\u2200 (n : \u2115), n < n.succ "]}
{"docString": "Every set is Lebesgue measurable.", "choices": ["\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] (s : Set \u03b1), MeasurableSet s ", "\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] [inst_1 : TopologicalSpace \u03b1] [inst_2 : BorelSpace \u03b1] [inst_3 : LebesgueMeasurableSpace \u03b1],\n  \u2200 (s : Set \u03b1), MeasurableSet s ", "\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] (s : Set \u03b1), MeasurableSet s ", "\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] [inst_1 : MeasureTheory.Measure.subsingleton \u03b1], \u2200 (s : Set \u03b1), MeasurableSet s ", "\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] [inst_1 : TopologicalSpace \u03b1] [inst_2 : BorelSpace \u03b1] [inst_3 : OpensMeasurableSpace \u03b1], \n  \u2200 (s : Set \u03b1), MeasurableSet s ", "\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] [inst_1 : TopologicalSpace \u03b1] [inst_2 : BorelSpace \u03b1], LebesgueMeasurable \u03b1 ", "\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] (s : Set \u03b1), MeasurableSet s ", "\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] [inst_1 : TopologicalSpace \u03b1] [inst_2 : BorelSpace \u03b1], OpensMeasurableSpace \u03b1 ", "\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] [inst_1 : TopologicalSpace \u03b1] [inst_2 : BorelSpace \u03b1],\n  LebesgueMeasurableSpace \u03b1 ", "\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] (s : Set \u03b1), MeasurableSet s "]}
{"docString": "Every set of Borel measure zero is Lebesgue measurable.", "choices": ["\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] [inst_1 : TopologicalSpace \u03b1] [inst_2 : BorelSpace \u03b1]\n  (\u03bc : MeasureTheory.Measure \u03b1) {s : Set \u03b1}, \u2191\u2191\u03bc s = 0 \u2192 MeasurableSet s ", "\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] [inst_1 : TopologicalSpace \u03b1] [inst_2 : BorelSpace \u03b1]\n  (\u03bc : MeasureTheory.Measure \u03b1) (s : Set \u03b1), \u2191\u2191\u03bc s = 0 \u2192 MeasurableSet s ", "\u2200 {\u03b1 : Type u_1} [inst : TopologicalSpace \u03b1] [inst_1 : MeasurableSpace \u03b1] [inst_2 : BorelSpace \u03b1]\n  (\u03bc : MeasureTheory.Measure \u03b1) {s : Set \u03b1}, \u2191\u2191\u03bc s = 0 \u2192 MeasurableSet s ", "forall {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] [inst_1 : TopologicalSpace \u03b1] [inst_2 : BorelSpace \u03b1]\n  (\u03bc : MeasureTheory.Measure \u03b1) {s : Set \u03b1},\n  MeasureTheory.volume s = 0 \u2192 MeasurableSet s ", "\u2200 {\u03b1 : Type u_1} [inst : TopologicalSpace \u03b1] [inst_1 : MeasurableSpace \u03b1] [inst_2 : BorelSpace \u03b1]\n  (\u03bc : MeasureTheory.Measure \u03b1) {s : Set \u03b1}, \u2191\u2191\u03bc s = 0 \u2192 MeasurableSet s ", "\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] [inst_1 : TopologicalSpace.SecondCountableTopology \u03b1]\n  (\u03bc : MeasureTheory.Measure \u03b1) {s : Set \u03b1}, \u2191\u2191\u03bc s = 0 \u2192 MeasurableSet s ", "\u2200 {\u03b1 : Type u_1} [inst : MeasureTheory.MeasureSpace \u03b1] [inst_1 : MeasurableSpace \u03b1] [inst_2 : BorelSpace \u03b1],\n  MeasureTheory.Measure.ZeroLebesgueMeasurableSpace \u03b1 ", "\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] [inst_1 : TopologicalSpace \u03b1] [inst_2 : BorelSpace \u03b1] (\u03bc : MeasureTheory.Measure \u03b1)\n  {s : Set \u03b1}, \u2191\u2191\u03bc s = 0 \u2192 MeasurableSet s ", "\u2200 {\u03b1 : Type u_1} [inst : TopologicalSpace \u03b1] [inst_1 : MeasurableSpace \u03b1] [inst_2 : BorelSpace \u03b1]\n  (\u03bc : MeasureTheory.Measure \u03b1) (s : Set \u03b1), \u2191\u2191\u03bc s = 0 \u2192 MeasurableSet s ", "\u2200 {\u03b1 : Type u_1} [inst : MeasurableSpace \u03b1] (\u03bc : MeasureTheory.Measure \u03b1) {s : Set \u03b1},\n  \u2191\u2191\u03bc s = 0 \u2192 MeasurableSet s "]}
{"docString": "No prime number is a perfect square.", "choices": ["\u2200 {p : \u2115}, Nat.Prime p \u2192 \u00ac\u2203 t, t * t = p ", "\u2200 {p : \u2115}, Nat.Prime p \u2192 \u00ac\u2203 t, t * t = p ", "\u2200 {p : \u2115}, Nat.Prime p \u2192 \u00ac\u2203 t, t * t = p ", "\u2200 {p : \u2115}, Nat.Prime p \u2192 \u00ac\u2203 t, t * t = p ", "\u2200 {p : \u2115}, Nat.Prime p \u2192 \u00ac\u2203 t, t * t = p ", "\u2200 {p : \u2115}, Nat.Prime p \u2192 \u00ac\u2203 t, t * t = p ", "\u2200 {p : \u2115}, Nat.Prime p \u2192 \u00ac\u2203 t, t * t = p ", "\u2200 {p : \u2115}, Nat.Prime p \u2192 \u00ac\u2203 t, t * t = p ", "\u2200 {p : \u2115}, Nat.Prime p \u2192 \u00ac\u2203 t, t * t = p ", "\u2200 {p : \u2115}, Nat.Prime p \u2192 \u00ac\u2203 n, n * n = p "]}
{"docString": "Every odd prime number is greater than `2`.", "choices": ["\u2200 (p : \u2115) [inst : Fact (Nat.Prime p)], p % 2 = 1 \u2192 p > 2 ", "\u2200 {p : \u2115} [inst : Fact (Nat.Prime p)], Odd p \u2192 p > 2 ", "\u2200 {p : \u2115} [inst : Fact (Nat.Prime p)], Odd p \u2192 p > 2 ", "\u2200 {p : \u2115} [inst : Fact (Nat.Prime p)], Odd p \u2192 p > 2 ", "\u2200 (p : \u2115) [inst : Fact (Nat.Prime p)], Odd p \u2192 p > 2 ", "\u2200 (p : \u2115) [inst : Fact (Nat.Prime p)], Odd p \u2192 p > 2 ", "\u2200 (p : \u2115) [inst : Fact (Nat.Prime p)], Odd p \u2192 p > 2 ", "\u2200 {p : \u2115} [inst : Fact (Nat.Prime p)], Odd p \u2192 p > 2 ", "\u2200 {p : \u2115} [inst : Fact (Nat.Prime p)], Odd p \u2192 p > 2 ", "\u2200 {p : \u2115} [inst : Fact (Nat.Prime p)], Odd p \u2192 p > 2 "]}
{"docString": "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.", "choices": ["\u2200 {a b x y z w u v : \u2115},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 \u2192 b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 \u2192\n  \u2203 r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 ", "\u2200 {a b x y u v : \u2115}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 \u2192 b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 \u2192 \u2203 r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "\u2200 {a b x y u v r s : \u2115},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 \u2192\n  b = r ^ 2 + s ^ 2 + x ^ 2 + y ^ 2 \u2192\n  \u2203 p q t z, a * b = p ^ 2 + q ^ 2 + t ^ 2 + z ^ 2 ", "\u2200 {a b x y u v r s : \u2115}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 \u2192 b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 \u2192 \u2203 p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ", "\u2200 {a b x y u v r s : \u2115}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 \u2192 b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 \u2192 \u2203 p q m n, a * b = p ^ 2 + q ^ 2 + m ^ 2 + n ^ 2 ", "\u2200 {a b x y u v : \u2115}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 \u2192 b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 \u2192 \u2203 r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "\u2200 {a b x y u v r s : \u2115}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 \u2192 b = r ^ 2 + s ^ 2 + x ^ 2 + y ^ 2 \u2192 \u2203 p q l m, a * b = p ^ 2 + q ^ 2 + l ^ 2 + m ^ 2 ", "\u2200 {a b x y u v r s t w : \u2115},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 \u2192\n  b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2 \u2192\n  \u2203 m n o p, a * b = m ^ 2 + n ^ 2 + o ^ 2 + p ^ 2 ", "\u2200 {a b x y u v : \u2115}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 \u2192 b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 \u2192 \u2203 r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "\u2200 {a b x y u v r s : \u2115}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 \u2192 b = r ^ 2 + s ^ 2 + x ^ 2 + y ^ 2 \u2192 \u2203 w t z p, a * b = w ^ 2 + t ^ 2 + z ^ 2 + p ^ 2 "]}
{"docString": "Every compact topological space is locally compact.", "choices": ["\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : CompactSpace \u03b1], LocallyCompactSpace \u03b1 ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : CompactSpace \u03b1], LocallyCompactSpace \u03b1 ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : CompactSpace \u03b1], LocallyCompactSpace \u03b1 ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : CompactSpace \u03b1], LocallyCompactSpace \u03b1 ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : CompactSpace \u03b1], LocallyCompactSpace \u03b1 ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : CompactSpace \u03b1], LocallyCompactSpace \u03b1 ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : CompactSpace \u03b1], LocallyCompactSpace \u03b1 ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : CompactSpace \u03b1], LocallyCompactSpace \u03b1 ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : CompactSpace \u03b1], LocallyCompactSpace \u03b1 ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] [inst_1 : CompactSpace \u03b1], LocallyCompactSpace \u03b1 "]}
{"docString": "Every continuous function is uniformly continuous.", "choices": ["\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2},\n  Continuous f \u2192 UniformContinuous f ", "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2] (f : \u03b1 \u2192 \u03b2),\n  Continuous f \u2192 UniformContinuous f ", "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2},\n  Continuous f \u2192 UniformContinuous f ", "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2},\n  Continuous f \u2192 UniformContinuous f ", "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : TopologicalSpace \u03b1] [inst_1 : UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2},\n  Continuous f \u2192 UniformContinuous f ", "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2] (f : \u03b1 \u2192 \u03b2),\n  Continuous f \u2192 UniformContinuous f ", "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : TopologicalSpace \u03b1] [inst_1 : UniformSpace \u03b2] (f : \u03b1 \u2192 \u03b2),\n  Continuous f \u2192 UniformContinuous f ", "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2] (f : \u03b1 \u2192 \u03b2),\n  Continuous f \u2192 UniformContinuous f ", "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2] (f : \u03b1 \u2192 \u03b2),\n  Continuous f \u2192 UniformContinuous f ", "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2},\n  Continuous f \u2192 UniformContinuous f "]}
{"docString": "`6` is not the sum of two distinct prime numbers.", "choices": ["\u00ac\u2203 p q : \u2115, Nat.Prime p \u2227 Nat.Prime q \u2227 p \u2260 q \u2227 p + q = 6 ", "\u00ac\u2203 (p q : \u2115), Nat.Prime p \u2227 Nat.Prime q \u2227 p \u2260 q \u2227 p + q = 6 ", "\u00ac\u2203 (p q : \u2115), Nat.Prime p \u2227 Nat.Prime q \u2227 p \u2260 q \u2227 p + q = 6 ", "\u00ac\u2203 (p q : \u2115), Nat.Prime p \u2227 Nat.Prime q \u2227 p \u2260 q \u2227 p + q = 6 ", "\u00ac\u2203 (p q : \u2115), Nat.Prime p \u2227 Nat.Prime q \u2227 p \u2260 q \u2227 p + q = 6 ", "\u00ac\u2203 (p q : \u2115), Nat.Prime p \u2227 Nat.Prime q \u2227 p \u2260 q \u2227 p + q = 6 ", "\u00ac \u2203 p q : \u2115, Nat.Prime p \u2227 Nat.Prime q \u2227 p \u2260 q \u2227 p + q = 6 ", "\u2200 {a b : \u2115}, Nat.Prime a \u2192 Nat.Prime b \u2192 a \u2260 b \u2192 a + b \u2260 6 ", "\u00ac\u2203 (a b : \u2115), Nat.Prime a \u2227 Nat.Prime b \u2227 a \u2260 b \u2227 a + b = 6 ", "\u00ac\u2203 (p q : \u2115), Nat.Prime p \u2192 Nat.Prime q \u2192 p \u2260 q \u2192 p + q = 6 "]}
{"docString": "No integer is irrational.", "choices": ["\u2200 (z : \u2124), \u00acIrrational (\u2191z) ", "\u2200 (n : \u2124), \u00acIrrational (\u2191n : \u211d) ", "\u2200 (n : \u2124), \u00acIrrational (\u2191n : \u211d) ", "\u2200 (n : \u2124), \u00acIrrational (\u2191n : \u211d) ", "\u2200 (n : \u2124), \u00acIrrational (\u2191n : \u211d) ", "\u2200 (n : \u2124), \u00acIrrational (\u2191n) ", "\u2200 (n : \u2124), \u00acIrrational \u2191n ", "\u2200 (z : \u2124), \u00acIrrational (\u2191z) ", "\u2200 (n : \u2124), \u00acIrrational (\u2191n : \u211d) ", "\u2200 (n : \u2124), \u00acIrrational (\u2191n : \u211d) "]}
{"docString": "The identity element in a ring is a unit.", "choices": ["\u2200 {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "\u2200 {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "\u2200 {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "\u2200 {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "\u2200 {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "\u2200 {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "\u2200 {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "\u2200 {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "\u2200 {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "\u2200 {R : Type u} [inst : Ring R], IsUnit (1 : R) "]}
{"docString": "Every subgroup of a group is a group.", "choices": ["\u2200 {G : Type u_1} [inst : Group G] (H : Subgroup G), Group {x // x \u2208 H} ", "\u2200 {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x \u2208 H } ", "\u2200 {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x \u2208 H } ", "\u2200 {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x \u2208 H } ", "\u2200 {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x \u2208 H } ", "\u2200 {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x \u2208 H } ", "forall {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x \u2208 H } ", "forall {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x \u2208 H } ", "\u2200 {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x \u2208 H } ", "\u2200 {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x \u2208 H } "]}
{"docString": "The sum of two natural numbers is a natural number.", "choices": ["\u2200 (m n : \u2115), \u2203 k, m + n = k ", "\u2200 (m n : \u2115), \u2203 k, m + n = k ", "\u2200 (m n : \u2115), \u2203 (k : \u2115), m + n = k ", "\u2200 (m n : \u2115), \u2203 k, m + n = k ", "\u2200 (m n : \u2115), \u2203 k, m + n = k ", "\u2200 (m n : \u2115), \u2203 r, m + n = r ", "\u2200 (m n : \u2115), \u2203 (k : \u2115), m + n = k ", "\u2200 (m n : \u2115), \u2203 (k : \u2115), m + n = k ", "\u2200 (a b : \u2115), \u2203 (c : \u2115), a + b = c ", "\u2200 (m n : \u2115), \u2203 (k : \u2115), m + n = k "]}
{"docString": "The identity element of a group has finite order.", "choices": ["\u2200 {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "forall {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "\u2200 {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "\u2200 {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "\u2200 {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "\u2200 {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "\u2200 {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "\u2200 {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "\u2200 {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "\u2200 {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) "]}
{"docString": "`7` is a prime number.", "choices": ["Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) "]}
{"docString": "There are `3` prime numbers below `8`.", "choices": ["prime_counting_function 8 = 3 ", "Nat.count_primes_below_8 : Nat.count 8 Nat.Prime = 3 ", "Nat.prime_counting_function 8 = 3 ", "Nat.card_prime_lt 8 = 3 ", "Nat.card_prime_below_8 : Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 ", "Nat.card_primes_below_8 : Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 ", "Fact (\u2203 (primes_below_eight : List \u2115), primes_below_eight = [2, 3, 5, 7] \u2227 List.length primes_below_eight = 3) ", "Nat.prime_counting_function 8 = 3 ", "Nat.card_primes_below_8 : Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 ", "Prime.card (Finset.filter (\u03bb p, p < 8) (Finset.range 8)) = 3 "]}
{"docString": "The empty set is contained in every finite set.", "choices": ["\u2200 {\u03b1 : Type u} {s : Set \u03b1}, Set.Finite s \u2192 \u2205 \u2286 s ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1}, Set.Finite s \u2192 \u2205 \u2286 s ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1}, Set.Finite s \u2192 \u2205 \u2286 s ", "\u2200 {\u03b1 : Type u} {a : Set \u03b1}, Set.Finite a \u2192 \u2205 \u2286 a ", "\u2200 {\u03b1 : Type u} {a : Set \u03b1}, Set.Finite a \u2192 \u2205 \u2286 a ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1}, Set.Finite s \u2192 \u2205 \u2286 s ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1}, Set.Finite s \u2192 HasSubset.Subset \u2205 s ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1}, Set.Finite s \u2192 \u2205 \u2286 s ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1}, Set.Finite s \u2192 \u2205 \u2286 s ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1}, Set.Finite s \u2192 \u2205 \u2286 s "]}
{"docString": "Every infinite set contains a finite set.", "choices": ["\u2200 {\u03b1 : Type u} {s : Set \u03b1}, \u00acSet.Finite s \u2192 \u2203 t : Set \u03b1, Set.Finite t \u2227 t \u2286 s ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1} [inst : Infinite \u03b1], \u2203 t : Finset \u03b1, t \u2286 s \u2227 Set.Finite t ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1} [inst : Infinite \u03b1], \u2203 (t : Finset \u03b1), t \u2286 s ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1}, Set.Infinite s \u2192 \u2200 (n : \u2115), \u2203 t : Finset \u03b1, \u2191t \u2286 s \u2227 Finset.card t = n ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1} [inst : Infinite \u03b1], \u2203 t : Set \u03b1, Set.Finite t \u2227 t \u2286 s ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1}, \u00acSet.Finite s \u2192 \u2203 t : Set \u03b1, Set.Finite t \u2227 t \u2286 s ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1} [inst : Infinite \u03b1], \u2203 t : Set \u03b1, Set.Finite t \u2227 t \u2286 s ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1} [inst : Infinite \u03b1], \u2203 t : Set \u03b1, Set.Finite t \u2227 t \u2286 s ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1} [inst : Infinite \u03b1], \u2203 t : Set \u03b1, Set.Finite t \u2227 t \u2286 s ", "\u2200 {\u03b1 : Type u} {s : Set \u03b1} [inst : Infinite \u03b1], \u2203 t : Set \u03b1, Set.Finite t \u2227 t \u2286 s "]}
{"docString": "Every commutative ring is a monoid.", "choices": ["\u2200 {R : Type u} [inst : CommRing R], Monoid R ", "\u2200 {R : Type u} [inst : CommRing R], Monoid R ", "\u2200 {R : Type u} [inst : CommRing R], Monoid R ", "\u2200 {R : Type u} [inst : CommRing R], Monoid R ", "\u2200 {R : Type u} [inst : CommRing R], Monoid R ", "\u2200 {R : Type u} [inst : CommRing R], Monoid R ", "\u2200 {R : Type u} [inst : CommRing R], Monoid R ", "\u2200 {R : Type u} [inst : CommRing R], Monoid R ", "\u2200 {R : Type u} [inst : CommRing R], Monoid R ", "\u2200 {R : Type u} [inst : CommRing R], Monoid R "]}
{"docString": "There is no field of order `10`.", "choices": ["\u00ac\u2203 (F : Type u_1) [inst : Field F], Fintype.card F = 10 ", "\u00ac\u2203 (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "\u00ac\u2203 (F : Type u_1) [inst : Field F], Fintype.card F = 10 ", "\u00ac\u2203 (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "\u00ac\u2203 (K : Type u) [inst : Field K], Fintype.card K = 10 ", "\u00ac\u2203 (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "\u00ac\u2203 (K : Type) [inst : Field K], Fintype.card K = 10 ", "\u00ac\u2203 {F : Type u_1} [inst : Field F], Fintype.card F = 10 ", "\u00ac\u2203 (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "\u00ac\u2203 (F : Type u) [inst : Field F], Fintype.card F = 10 "]}
{"docString": "Every odd natural number is the sum of two distinct natural numbers.", "choices": ["\u2200 {n : \u2115}, Odd n \u2192 \u2203 a b : \u2115, a \u2260 b \u2227 n = a + b ", "\u2200 {n : \u2115}, Odd n \u2192 \u2203 m k : \u2115, m \u2260 k \u2227 n = m + k ", "\u2200 (n : \u2115), Odd n \u2192 \u2203 a b : \u2115, a \u2260 b \u2227 n = a + b ", "\u2200 {n : \u2115}, Odd n \u2192 \u2203 a b : \u2115, a \u2260 b \u2227 n = a + b ", "\u2200 {n : \u2115}, Odd n \u2192 \u2203 a b : \u2115, n = a + b \u2227 a \u2260 b ", "\u2200 {n : \u2115}, Odd n \u2192 \u2203 a b : \u2115, a \u2260 b \u2227 n = a + b ", "\u2200 {n : \u2115}, Odd n \u2192 \u2203 (a b : \u2115), a \u2260 b \u2227 n = a + b ", "\u2200 {n : \u2115}, Odd n \u2192 \u2203 a b : \u2115, a \u2260 b \u2227 n = a + b ", "\u2200 {n : \u2115}, Odd n \u2192 \u2203 x y : \u2115, x \u2260 y \u2227 n = x + y ", "\u2200 {n : \u2115}, Odd n \u2192 \u2203 a b : \u2115, a \u2260 b \u2227 n = a + b "]}
{"docString": "Every element in the trivial group has finite order.", "choices": ["\u2200 {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ", "\u2200 {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ", "\u2200 {G : Type u_1} [inst : GroupWithZero G], IsOfFinOrder (0 : G) ", "\u2200 {G : Type u_1} [inst : One G] (x : G), IsOfFinOrder x ", "forall {G : Type u_1} [inst : GroupWithZero G] (x : G), IsOfFinOrder x ", "\u2200 {G : Type u_1} [inst : GroupWithZero G], IsOfFinOrder (0 : G) ", "\u2200 {G : Type u_1} [inst : GroupWithZero G], IsOfFinOrder (0 : G) ", "\u2200 {G : Type u_1} [inst : Group G] [Subsingleton G] (x : G), IsOfFinOrder x ", "\u2200 {G : Type u_1} [inst : Monoid G] [inst_1 : Unique G], \u2200 (x : G), IsOfFinOrder x ", "\u2200 {G : Type u_1} [inst : GroupWithZero G] {x : G}, IsOfFinOrder x "]}
{"docString": "The square of an even number is even.", "choices": ["\u2200 {\u03b1 : Type u} [inst : CommRing \u03b1] {x : \u03b1}, x % 2 = 0 \u2192 (x * x) % 2 = 0 ", "\u2200 {\u03b1 : Type u} [inst : CommSemiring \u03b1] {x : \u03b1}, IsEven x \u2192 IsEven (x * x) ", "\u2200 {\u03b1 : Type u} [inst : CommRing \u03b1] {x : \u03b1}, x % 2 = 0 \u2192 (x * x) % 2 = 0 ", "\u2200 {\u03b1 : Type u} [inst : LinearOrderedRing \u03b1] {x : \u03b1}, Even x \u2192 Even (x * x) ", "\u2200 {n : \u2115}, Even (n ^ 2) \u2194 Even n ", "\u2200 {\u03b1 : Type u} [inst : LinearOrderedRing \u03b1] {x : \u03b1}, x % 2 = 0 \u2192 (x * x) % 2 = 0 ", "\u2200 {\u03b1 : Type u} [inst : Semiring \u03b1] {x : \u03b1}, Even x \u2192 Even (x * x) ", "\u2200 {n : \u2115}, Even (n ^ 2) \u2194 Even n ", "\u2200 {n : \u2115}, Even (n ^ 2) \u2194 Even n ", "\u2200 {\u03b1 : Type u} [inst : Semiring \u03b1] {a : \u03b1}, Even a \u2192 Even (a * a) "]}
{"docString": "Every commutative division ring is a field.", "choices": ["\u2200 (A : Type u) [inst : CommRing A] [inst_1 : Nontrivial A] [inst_2 : DivisionRing A], IsField A ", "\u2200 (R : Type u) [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "\u2200 {R : Type u} [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "\u2200 (R : Type u) [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "\u2200 {K : Type u} [inst : CommRing K] [inst_1 : IsDivisionRing K], IsField K ", "\u2200 {R : Type u} [inst : CommRing R] [IsDivisionRing R], IsField R ", "\u2200 {R : Type u} [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "\u2200 {R : Type u} [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "\u2200 {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R ", "\u2200 {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DivisionRing R], IsField R "]}
{"docString": "The image of the identity element under the identity map is the identity element.", "choices": ["\u2200 {\u03b1 : Type u} [inst : HasOne \u03b1], id 1 = 1 ", "\u2200 {\u03b1 : Type u} [inst : HasOne \u03b1], id 1 = 1 ", "\u2200 {\u03b1 : Type u} [inst : HasOne \u03b1], id 1 = 1 ", "\u2200 {\u03b1 : Type u} [inst : HasOne \u03b1], id 1 = 1 ", "\u2200 {\u03b1 : Type u} [inst : HasOne \u03b1], id 1 = 1 ", "\u2200 {\u03b1 : Type u} [inst : HasOne \u03b1], id 1 = 1 ", "\u2200 {\u03b1 : Type u} [inst : HasOne \u03b1], id 1 = 1 ", "\u2200 {\u03b1 : Type u} [inst : HasOne \u03b1], id 1 = 1 ", "\u2200 {\u03b1 : Type u} [inst : HasOne \u03b1], id 1 = 1 ", "\u2200 {\u03b1 : Type u} [inst : HasOne \u03b1], id 1 = 1 "]}
{"docString": "Every point is a fixed point of the identity function on a space.", "choices": ["\u2200 {\u03b1 : Type u} (x : \u03b1), Function.IsFixedPt id x ", "\u2200 {\u03b1 : Type u} (x : \u03b1), Function.IsFixedPt id x ", "\u2200 {\u03b1 : Type u} (x : \u03b1), Function.IsFixedPt id x ", "\u2200 {\u03b1 : Type u} (x : \u03b1), Function.IsFixedPt id x ", "\u2200 {\u03b1 : Type u} (x : \u03b1), Function.IsFixedPt id x ", "\u2200 {\u03b1 : Type u} (x : \u03b1), Function.IsFixedPt id x ", "\u2200 {\u03b1 : Type u} (x : \u03b1), Function.IsFixedPt id x ", "\u2200 {\u03b1 : Type u} (x : \u03b1), Function.IsFixedPt id x ", "\u2200 {\u03b1 : Type u} (x : \u03b1), Function.IsFixedPt id x ", "\u2200 {\u03b1 : Type u} (x : \u03b1), Function.IsFixedPt id x "]}
{"docString": "The diameter of a singleton space is `0`.", "choices": ["\u2200 {\u03b1 : Type u} [inst : PseudoMetricSpace \u03b1] {x : \u03b1}, Metric.diam {x} = 0 ", "\u2200 {\u03b1 : Type u} [inst : PseudoMetricSpace \u03b1] {x : \u03b1}, Metric.diam {x} = 0 ", "\u2200 {\u03b1 : Type u} [inst : PseudoMetricSpace \u03b1] {x : \u03b1}, Metric.diam {x} = 0 ", "\u2200 {\u03b1 : Type u} [inst : PseudoMetricSpace \u03b1] {x : \u03b1}, Metric.diam {x} = 0 ", "\u2200 {\u03b1 : Type u} [inst : PseudoMetricSpace \u03b1] {x : \u03b1}, Metric.diam {x} = 0 ", "\u2200 {\u03b1 : Type u} [inst : PseudoMetricSpace \u03b1] {x : \u03b1}, Metric.diam {x} = 0 ", "\u2200 {\u03b1 : Type u} [inst : PseudoMetricSpace \u03b1] {x : \u03b1}, Metric.diam {x} = 0 ", "\u2200 {\u03b1 : Type u} [inst : PseudoMetricSpace \u03b1] {x : \u03b1}, Metric.diam {x} = 0 ", "\u2200 {\u03b1 : Type u} [inst : PseudoMetricSpace \u03b1] {x : \u03b1}, Metric.diam {x} = 0 ", "\u2200 {\u03b1 : Type u} [inst : PseudoMetricSpace \u03b1] {x : \u03b1}, Metric.diam {x} = 0 "]}
{"docString": "Every group is non-empty.", "choices": ["\u2200 {G : Type u} [inst : Group G], Nonempty G ", "\u2200 {G : Type u} [inst : Group G], Nonempty G ", "\u2200 {G : Type u} [inst : Group G], Nonempty G ", "\u2200 {G : Type u} [inst : Group G], Nonempty G ", "\u2200 {G : Type u} [inst : Group G], Nonempty G ", "\u2200 {G : Type u} [inst : Group G], Nonempty G ", "\u2200 (G : Type u_1) [inst : Group G], Nonempty G ", "\u2200 {G : Type u} [inst : Group G], Nonempty G ", "\u2200 {G : Type u} [inst : Group G], Nonempty G ", "\u2200 {G : Type u} [inst : Group G], Nonempty G "]}
{"docString": "All connected components of a topological space are connected.", "choices": ["\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] (x : \u03b1),\n  ConnectedSpace.connected (ConnectedComponents.connectedComponent x) ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] (x : \u03b1), Connected (ConnectedComponent x) ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] (x : \u03b1), ConnectedSpace (connectedComponent x) ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] (x : \u03b1), IsConnected (connectedComponent x) ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] (x : \u03b1), IsConnected (connectedComponent x) ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] (x : \u03b1),\n  IsConnected (connectedComponent x) ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] (x : \u03b1),\n  ConnectedSpace (coe (connectedComponent x)) ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] (x : \u03b1), ConnectedSpace (connectedComponent x) ", "\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] (x : \u03b1), Connected (connectedComponent x) ", "forall {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] (x : \u03b1), IsConnected (connectedComponent x) "]}
{"docString": "The ring of integers has a maximal ideal.", "choices": ["\u2200 {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], \u2203 M, Ideal.IsMaximal M ", "\u2200 {K : Type u} [inst : Field K] [inst_1 : NumberField K], \u2203 M, Ideal.IsMaximal M ", "\u2200 {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], \u2203 M, Ideal.IsMaximal M ", "\u2200 (K : Type u) [inst : Field K] [inst_1 : CharZero K], \u2203 M, @Ideal.IsMaximal (@NumberField.ringOfIntegers K inst_1) M ", "\u2200 {O : Type u_1} [inst : CommRing O] [inst_1 : IsDomain O] [inst_2 : IsDedekindDomain O], \u2203 M, Ideal.IsMaximal M ", "\u2200 {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], \u2203 M, Ideal.IsMaximal M ", "forall {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], \u2203 M, Ideal.IsMaximal M ", "\u2200 {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], \u2203 M, Ideal.IsMaximal M ", "\u2200 {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], \u2203 M, Ideal.IsMaximal M ", "\u2200 {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], \u2203 M, Ideal.IsMaximal M "]}
{"docString": "The numbers `3`, `4` and `5` form a Pythagorean triple.", "choices": ["PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 "]}
{"docString": "A vector space with the empty set as basis is trivial.", "choices": ["forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis \u2205 K V \u2192 V = 0 ", "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis \u2205 K V \u2192 V \u2243\u2097[K] \u21a5\u22a5 ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis \u2205 K V \u2192 V \u2243\u2097[K] \u22a5 ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis \u2205 K V \u2192 V \u2245\u2090[K] Module.Pi K \u2205 ", "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (finset \u2205) K V \u2192 V \u2243\u2097[K] K ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {\u03b9 : Type w}\n  [inst_3 : IsEmpty \u03b9], Basis \u03b9 K V \u2192 V = Trivial\u2093 ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis \u2205 K V \u2192 V \u2243\u2097[K] \u21a5\u22a5 ", "forall {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {\u03b9 : Type w}\n  [inst_3 : IsEmpty \u03b9], Basis \u03b9 R M \u2192 M = \u22a5 ", "\u2200 {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (\u2205 : Set V) K V \u2192 V \u2243\u2097[K] 0 ", "\u2200 {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis \u2205 K V \u2192 V = {0} "]}
