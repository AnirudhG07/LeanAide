{"docString": "If every proper closed set of a topological space is compact, then the space itself is compact.", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ s, IsClosed s → s ≠ univ → IsCompact s), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ s : Set α, IsClosed s → s ≠ Set.Univ → IsCompact s), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (F : Set α), IsClosed F → F ≠ univ → IsCompact F), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (s : Set α), IsClosed s → s ≠ univ → IsCompact s), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (s : Set α), IsClosed s → s ≠ univ → IsCompact s), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (K : Set α), IsProper K ∧ IsClosed K → IsCompact K), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (K : Set α), IsClosed K → K ≠ univ → IsCompact K), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (K : Set α), IsClosed K → K ≠ univ → IsCompact K), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (s : Set α), IsClosed s → (s ≠ univ) → IsCompact s), IsCompact univ ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (s : Set α), IsClosed s → s ≠ univ → IsCompact s), CompactSpace α "]}
{"docString": "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.", "choices": ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p "]}
{"docString": "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.", "choices": ["∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t k, a * b = r ^ 2 + s ^ 2 + t ^ 2 + k ^ 2 ", "∀ {a b x y u v r s : ℕ}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 → b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ", "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "∀ (a₀ a₁ a₂ a₃ b₀ b₁ b₂ b₃ : ℕ),\n  ∃ c₀ c₁ c₂ c₃, a₀ ^ 2 + a₁ ^ 2 + a₂ ^ 2 + a₃ ^ 2 = (b₀ ^ 2 + b₁ ^ 2 + b₂ ^ 2 + b₃ ^ 2) * (c₀ ^ 2 + c₁ ^ 2 + c₂ ^ 2 + c₃ ^ 2) ", "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t p, a * b = r ^ 2 + s ^ 2 + t ^ 2 + p ^ 2 ", "∀ {a b x y u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 →\n  b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 →\n  ∃ w x y z, a * b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 ", "∀ {a b x y u v r s : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = r ^ 2 + s ^ 2 + x ^ 2 + y ^ 2 → ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ", "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n  ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 "]}
{"docString": "A ring with all elements idempotent is commutative.", "choices": ["∀ {α : Type u_1} [self : BooleanRing α] (a b : α), a * b = b * a ", "∀ {α : Type u_1} [self : BooleanRing α] (a b : α), a * b = b * a ", "∀ {α : Type u_1} [self : CommRing α] (h : ∀ (a : α), a * a = a) (a b : α), a * b = b * a ", "∀ {α : Type u_1} [self : MulZeroClass α] (h : ∀ (a : α), a * a = a) (a b : α), a * b = b * a ", "∀ {α : Type u_1} [self : Mul α] [self_1 : Add α] [self_2 : Idempotent α], IsCommutative α Mul.mul ", "∀ {α : Type u_1} [self : BooleanRing α] (a b : α), a * b = b * a ", "∀ {α : Type u_1} [self : BooleanRing α] (a b : α), a * b = b * a ", "∀ {α : Type u_1} [self : BooleanRing α] (a b : α), a * b = b * a ", "∀ {α : Type u_1} [self : BooleanRing α] (a b : α), a * b = b * a ", "∀ {α : Type u_1} [self : BooleanRing α] (a b : α), a * b = b * a "]}
{"docString": "There are infinitely many pairs of primes that differ exactly by `2`.", "choices": ["∃ (f : ℕ → ℕ × ℕ), (∀ (n : ℕ), Nat.Prime (f n).fst ∧ Nat.Prime (f n).snd ∧ (f n).snd - (f n).fst = 2) ∧ Function.Injective f ", "∃ f : ℕ → ℕ × ℕ, (∀ (n : ℕ), Nat.Prime (f n).fst ∧ Nat.Prime (f n).snd ∧ (f n).fst < (f n).snd ∧ (f n).snd - (f n).fst = 2) ∧ ∀ (m n : ℕ), m ≠ n → f m ≠ f n ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], CharP F 2 → ∀ (a : F), IsSquare a ", "Infinite (∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ q - p = 2) ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a ", "∃ (f : ℕ → ℕ × ℕ), ∀ (n : ℕ), IsPrime (f n).1 ∧ IsPrime (f n).2 ∧ (f n).2 - (f n).1 = 2 ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a ", "∃ f : ℕ → ℕ, (∀ n, Nat.Prime (f n) ∧ Nat.Prime (f n + 2)) ∧ Set.Infinite {x : ℕ | Prime x ∧ Prime (x + 2)} ", "Exists (λ n : ℕ, ∃ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ a - b = 2 * n) "]}
{"docString": "Every finite division ring is a field.", "choices": ["∀ (D : Type u) [inst : DivisionRing D] [inst_1 : Fintype D], Field D ", "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ", "∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ", "∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ", "∀ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K ", "∀ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Fintype D], Field D ", "∀ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], Field K "]}
{"docString": "If each of two types can be mapped injectively into the other, then there is a bijection between them.", "choices": ["∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β) ", "∀ {α : Type u_1} {β : Type u_2} {e₁ : α → β} {e₂ : β → α},\n  Function.Injective e₁ → Function.Injective e₂ → ∃ (e : α ≃ β), True ", "∀ {X Y : Type u}, (∃ (f : X → Y), Function.Injective f) → (∃ (g : Y → X), Function.Injective g) → Nonempty (X ≃ Y) ", "∀ {α : Type u_1} {β : Type u_2} (e₁ : α → β) (e₂ : β → α),\n  Function.Injective e₁ → Function.Injective e₂ → ∃ (f : α ≃ β), True ", "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β) ", "∀ {α : Type u_1} {β : Type u_2} (f : α → β), Function.Injective f → (∃ (g : β → α), Function.Injective g) →\n  Nonempty (α ≃ β) ", "∀ {α : Type u_1} {β : Type u_2} {e₁ : α → β} {e₂ : β → α},\n  Function.Injective e₁ → Function.Injective e₂ → Nonempty (α ≃ β) ", "∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β) ", "∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → (∃ (h : α ≃ β), ∀ (x : α), f x = h x) ", "∀ {α : Type u_1} {β : Type u_2} (e : α → β) (f : β → α),\n  Function.Injective e → Function.Injective f → Nonempty (α ≃ β) "]}
{"docString": "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.", "choices": ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃ x, SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w ∧ ∀ (y : V), SimpleGraph.Adj G y v ∧ SimpleGraph.Adj G y w → y = x) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ", "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) → ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ", "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (u : V), SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ", "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), ∃! u, SimpleGraph.Adj G u v ∧ SimpleGraph.Adj G u w) → ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ", "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (u : V), u ≠ v ∧ u ≠ w ∧ SimpleGraph.Adj G u v ∧ SimpleGraph.Adj G u w) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ", "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ v w, v ≠ w → ExistsUnique (λ x, SimpleGraph.Adj G v x ∧ SimpleGraph.Adj G x w)) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ", "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (u : V), SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G u w) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ", "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), ∃! (x : V), SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w) → ∃ (x : V), ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v ", "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (u : V), SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ", "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (u : V), SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w "]}
{"docString": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.", "choices": ["Nnreal.sum_partition_odd_eq_distinct : ∀ (n : ℕ), (Finset.sum (Finset.ico 1 n) (fun k => odd_part_powers k)) = (Finset.sum (Finset.ico 1 n) (fun k => distinct_part_powers k)) ", "∀ {n : ℕ}, partition_odd n = partition_distinct n ", "∀ {n : ℕ}, Nat.partitions_with_odd_parts n = Nat.partitions_with_distinct_parts n ", "∀ (n : ℕ), partition_odd n = partition_distinct n ", "∀ (n : ℕ), odd_part_pn n = distinct_part_pn n ", "∀ {α : Type u_1} [inst : Fintype α] {π : Partition α},\n  Finset.card (Finset.filter (λ b : Finset (Finset α), Finset.card b = 1) π.parts) =\n    Finset.card (Finset.filter (λ b : Finset (Finset α), ↑(Finset.card b) ≠ 0 ∧ ∀ (a : Finset α), a ∈ b → Finset.card a = 1) π.parts) ", "∀ {n : ℕ}, partition_odd_part_count n = partition_distinct_part_count n ", "∀ {n : ℕ}, partitions_distinct n = partitions_odd n ", "∀ (n : ℕ), \n  Partition.distinct_parts_partition n = Partition.odd_parts_partition n ", "∀ {n : ℕ}, (Finset.card (Finset.filter (fun x => Finset.card x.parts = n) (oddPartitions Nat.odd))) =\n  (Finset.card (Finset.filter (fun x => Finset.card x.parts = n) (distinctPartitions Nat.distinct))) "]}
{"docString": "Every non-empty poset in which every chain has an upper bound contains a maximal element.", "choices": ["∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain (≤) c → ∃ ub, ∀ (a : α), a ∈ c → a ≤ ub) →\n    ∃ m, ∀ (a : α), m ≤ a → a ≤ m ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain (fun a b => a ≤ b) c → ∃ ub, ∀ (a : α), a ∈ c → a ≤ ub) →\n    ∃ m, ∀ (a : α), m ≤ a → a ≤ m ", "forall {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "forall {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m "]}
{"docString": "A group whose automorphism group is cyclic is Abelian.", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], AddCommGroup G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G ", "∀ {G : Type u_1} [inst : Group G], IsCyclic (Aut G) → IsAbelian G ", "∀ {G : Type u_1} [inst : Group G] (hG : IsCyclic (Aut G)), CommGroup G ", "forall {α : Type u} [inst : Group α] (h : IsCyclic (Aut α)), IsAbelian α ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype (Aut α)], IsCyclic (Aut α) → IsAbelian α ", "∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype (End α)], IsCyclic (End α) → IsAbelian α ", "∀ {G : Type u_1} [inst : Group G], IsCyclic (Aut G) → IsAbelian G ", "∀ {G : Type u_1} [inst : Group G], IsCyclic (Aut G) → AddCommGroup G "]}
{"docString": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.", "choices": ["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α →ᵤ β) (g : β →ᵤ γ), UniformContinuous (g.toFun ∘ f.toFun) "]}
{"docString": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.", "choices": ["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "]}
{"docString": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ f s ⊆ (0 : Set ℝ) ∧ f t ⊆ (1 : Set ℝ) ", "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t →\n  ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1) ", "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t →\n  ∃ (f : α → ℝ), Continuous f ∧ (∀ (x : α), x ∈ s → f x = 0) ∧ (∀ (x : α), x ∈ t → f x = 1) ", "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ y ∈ t, f y = 1) ", "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔ ∀ (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → ∃ f, ContinuousOn f (s ∪ t) ∧ ∀ x ∈ s, f x = 0 ∧ ∀ x ∈ t, f x = 1 ", "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ (s t : Set α), Disjoint s t → IsClosed s → IsClosed t →\n  ∃ (f : α → ℝ), Continuous f ∧ ∀ (x : α), HasMem.Mem x s → f x = 0 ∧ ∀ (x : α), HasMem.Mem x t → f x = 1 ", "forall {α : Type u} [t : TopologicalSpace α],\n  NormalSpace α ↔ ∀ {s t : Set α}, IsClosed s → IsClosed t → Disjoint s t → ∃f : α → ℝ, Continuous f ∧ ∀ x ∈ s, f x = 0 ∧ ∀ x ∈ t, f x = 1 ", "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, ContinuousOn f s ∧ ContinuousOn f t ∧ ∀ x, f x ∈ [0, 1] ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ f '' s ⊆ (0:ℝ) ∧ f '' t ⊆ (1:ℝ) ", "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ f =ᶠ[𝓟 s] 0 ∧ f =ᶠ[𝓟 t] 1 "]}
{"docString": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.", "choices": ["/-- Any point is a periodic point of period `0`. -/\ntheorem is_periodic_pt_zero {α : Type u_1} (f : α → α) (x : α) : Function.IsPeriodicPt f 0 x ", "forall {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] {f : α → α},\n  ContinuousOn f (Set.Icc 0 1) →\n  (∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f 3 x) →\n  ∀ n, ∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} {f : α → α} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : MeasurableSpace α] [inst_4 : OpensMeasurableSpace α], IsUnitInterval α →\n    (∃ x, Function.IsPeriodicPt f 3 x) → ∀ (n : ℕ), n > 0 → ∃ x, Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} (f : α → α) [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α],\n  0 < α → 1 < α → (∃ x, Function.IsPeriodicPt f 3 x) → ∀ n : ℕ, 0 < n → ∃ x, Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : ConditionallyCompleteLinearOrder α] [inst_2 : Archimedean α]\n  {f : ℝ → α} (hf : ContinuousOn f (Set.Icc 0 1)) (h₀ : ∀ x, HasMem.Mem x (Set.Icc 0 1) → HasMem.Mem (f x) (Set.Icc 0 1))\n  {x : ℝ} (hx : HasMem.Mem x (Set.Icc 0 1)) (h3 : Function.IsPeriodicPt f 3 x),\n  ∀ (n : ℕ), n > 0 → ∃ y, HasMem.Mem y (Set.Icc 0 1) ∧ Function.IsPeriodicPt f n y ", "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderConnectedTopology α]\n  [inst_3 : DenselyOrdered α] {f : α → α} [inst_4 : HasForallOrdCont f],\n  α = Set.Icc (0 : α) 1 → (∃ x, Function.IsPeriodicPt f 3 x) → ∀ n, ∃ x, Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] [inst_3 : DenseOrder α] {f : α → α},\n  (∃ x ∈ Set.Icc (0 : α) 1, Function.IsPeriodicPt f 3 x) → ∀ n, ∃ x ∈ Set.Icc (0 : α) 1, Function.IsPeriodicPt f n x ", "forall {α : Type u_1} (f : α → α) (x : α), \n  Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y ", "forall {α : Type u_1} {f : α → α} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] [inst_3 : DenselyOrdered α],\n  Function.IsPeriodicPt f 3 (0 : α) → ∀ n : ℕ, 0 < n → ∃ x, Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] [inst_3 : FloorRing α],\n  0 ≤ α → α ≤ 1 →\n    (∃ x : α, Function.IsPeriodicPt (λ x, 3 * x) 3 x) →\n      ∀ (n : ℕ), n > 0 → ∃ x, Function.IsPeriodicPt (λ x, 3 * x) n x "]}
{"docString": "A terminal object in a category is unique up to unique isomorphism.", "choices": ["∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C}\n  (hX : CategoryTheory.Limits.IsTerminal X) (hY : CategoryTheory.Limits.IsTerminal Y),\n  Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C]\n  {X Y : C} (hX : CategoryTheory.Limits.IsTerminal X) (hY : CategoryTheory.Limits.IsTerminal Y),\n  Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C} (hX : CategoryTheory.Limits.IsTerminal X)\n  (hY : CategoryTheory.Limits.IsTerminal Y), Unique (X ≅ Y) "]}
{"docString": "The complement of the union of two sets is the intersection of their complements.", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ = (s ∩ t)ᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ = (s ∩ t)ᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ "]}
{"docString": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.", "choices": ["∀ {a b c : ℕ}, 0 < a → 0 < b → a ^ 3 + b ^ 3 ≠ c ^ 3 ", "∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3 ", "∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3 ", "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ", "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ", "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ", "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ", "∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3 ", "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ", "∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3 "]}
{"docString": "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.", "choices": ["∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y ", "∀ {G : Type u_1} [inst : Group G], (∀ (a : G), a * a = 1) → ∀ (a b : G), Commute a b ", "∀ {G : Type u_1} [inst : Group G], (∀ g : G, g ^ 2 = 1) → ∀ a b : G, Commute a b ", "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (a b : G), Commute a b ", "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y ", "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (a b : G), Commute a b ", "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (a b : G), Commute a b ", "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y ", "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y ", "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (a b : G), Commute a b "]}
{"docString": "The product of two consecutive natural numbers is even.", "choices": ["∀ (n : ℕ), Even (n * (n + 1)) ", "∀ {n : ℕ}, Even (n * (n + 1)) ", "∀ {n : ℕ}, Even (n * (n + 1)) ", "∀ {m : ℕ}, Even (m * (m + 1)) ", "∀ {m : ℕ}, Even (m * (m + 1)) ", "∀ {m : ℕ}, Even (m * (m + 1)) ", "∀ {n : ℕ}, Even (n * (n + 1)) ", "∀ (n : ℕ), Even (n * (n + 1)) ", "∀ {m n : ℕ}, n = m + 1 → Even (m * n) ", "∀ {n : ℕ}, Even (n * (n + 1)) "]}
{"docString": "Every index 2 subgroup of a group is normal.", "choices": ["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "forall {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H "]}
{"docString": "Every free group is torsion free.", "choices": ["∀ {ι : Type u_1} (M : ι → Type u_2) [inst : (i : ι) → Group (M i)], Monoid.IsTorsionFree (FreeGroup (((i : ι) → M i))) ", "forall {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype α], IsFreeGroup G → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G], Group.IsFree G → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G] [hF : FreeGroup G], Monoid.IsTorsionFree G ", "∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Nonempty α], Monoid.IsTorsionFree (FreeGroup α) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ", "forall {ι : Type u_1} {G : ι → Type u_2} [inst : (i : ι) → Group (G i)],\n  (∀ (F : FreeGroup (ι, G)), Monoid.IsTorsionFree F) ", "forall {ι : Type u_1} {G : ι → Type u_2} [inst : (i : ι) → Group (G i)] (F : FreeGroup G),\n  Monoid.IsTorsionFree (FreeGroup G) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ", "∀ {α : Type u_1} {G : Type u_2} [inst : Group G] (f : α → G), Monoid.IsTorsionFree (FreeGroup α) "]}
{"docString": "Every natural number greater than `1` is divisible by a prime number.", "choices": ["∀ n : ℕ, 1 < n → ∃ (p : ℕ) [inst : Fact (Nat.Prime p)], p ∣ n ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ) [inst : Fact (Nat.Prime p)], p ∣ n ", "∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ) [inst : Fact (Nat.Prime p)], p ∣ n ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ", "∀ {n : ℕ}, n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n "]}
{"docString": "A finite torsion-free group is trivial", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Trivial G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Trivial G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Trivial G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Trivial G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Trivial G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Trivial G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G],\n  Monoid.IsTorsionFree G → IsTrivial G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Trivial G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Trivial G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Trivial G "]}
{"docString": "Every finite division ring is a field.", "choices": ["∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "∀ (D : Type u) [inst : DivisionRing D] [inst_1 : Fintype D], Field D ", "∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], IsField R ", "∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], IsField R ", "∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ", "∀ (R : Type u) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R "]}
{"docString": "Every finite topological space is compact.", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "Finite.toCompactSpace : ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α "]}
{"docString": "Every surjective homomorphism from a finitely generated free group to itself is injective.", "choices": ["∀ {ι : Type u_1} {F : Type u_2} [inst : Group F] [inst_1 : FreeGroup ι] [inst_2 : Fintype ι] (f : F →* F),\n  Function.Surjective ↑f → Function.Injective ↑f ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [inst_2 : Group.IsFree α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f ", "∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α] [inst_2 : Fintype α] (f : α →* α),\n  Function.Surjective ↑f → Function.Injective ↑f ", "forall {α : Type u} [inst : Group α] [inst_1 : FinitelyGenerated α] [inst_2 : Free α],\n  ∀ (f : α →* α), Function.Surjective f → Function.Injective f ", "∀ {α : Type u} {G : Type v} [inst : Group G] [inst_1 : FreeGroup α] [inst_2 : FinitelyGenerated G]\n  (f : G → G), Function.Surjective f → Function.Injective f ", "∀ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] [inst_2 : IsFinitelyGenerated G]\n  (f : G →* G), Function.Surjective ↑f → Function.Injective ↑f ", "∀ {α : Type u} (f : FreeGroup α → FreeGroup α),\n  Function.Surjective f → (∀ (G H : Set α), Subgroup.Fg (Subgroup.mk G) → Subgroup.Fg (Subgroup.mk H)) → Function.Injective f ", "∀ {α : Type u} [inst : Fintype α] {F : FreeGroup α} {f : FreeGroup α →* FreeGroup α},\n  Function.Surjective ↑f → Function.Injective ↑f ", "∀ {α : Type u} [inst_1 : Fintype α] {G : FreeGroup α} (f : G →* G), Function.Surjective ↑f → Function.Injective ↑f ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α →* α},\n  Function.Surjective ↑f → Function.Injective ↑f "]}
{"docString": "Every positive even integer can be written as the sum of two primes.", "choices": ["Goldbach's_conjecture : ∀ (n : ℕ), 2 ≤ n → n.even → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "∀ (n : ℕ), n > 2 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "∀ (n : ℕ), n > 2 → Even n → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "∀ {n : ℕ}, n > 0 → Even n → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ n = a + b ", "∀ n : ℕ, 2 ≤ n → Even n → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "Goldbach's_conjecture : ∀ n : ℕ, 2 < n → n % 2 = 0 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "∀ (n : ℕ), n > 2 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "∀ {n : ℕ}, n > 2 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "goldbach_conjecture : ∀ {n : ℕ}, 2 ≤ n → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q "]}
{"docString": "Every matrix satisfies its own characteristic polynomial.", "choices": ["∀ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "∀ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "∀ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "forall {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Matrix.charpoly M = 0 ", "∀ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "∀ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "∀ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "∀ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "∀ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "∀ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 "]}
{"docString": "The square root of an irrational number is irrational.", "choices": ["∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ", "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ", "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ", "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ", "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ", "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ", "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ", "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ", "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ", "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) "]}
{"docString": "If the square of a number is even, the number itself is even.", "choices": ["∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 → x % 2 = 0 ", "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 → x % 2 = 0 ", "∀ {α : Type u} [inst : LinearOrderedRing α] {a : α}, a * a % 2 = 0 → a % 2 = 0 ", "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 → x % 2 = 0 ", "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ", "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ", "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 → x % 2 = 0 ", "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ", "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ", "∀ {n : ℕ}, (n * n) % 2 = 0 → n % 2 = 0 "]}
{"docString": "In a finite commutative ring, all prime ideals are maximal.", "choices": ["∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P ", "∀ {R : Type u} [inst : CommRing R] [hR : Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ", "∀ {R : Type u} [inst : CommRing R] [Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P ", "∀ {R : Type u} [inst : CommRing R] [hR : Fintype R], ∀ (I : Ideal R) [Ideal.IsPrime I], Ideal.IsMaximal I ", "∀ {R : Type u} [inst : CommRing R] [hR : Fintype R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ", "∀ {R : Type u} [inst : CommRing R] [hR : Fintype R], \n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ", "∀ {R : Type u} [inst : CommRing R] [F : Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsFinite R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) "]}
{"docString": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.", "choices": ["∀ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X ↔ IsClosed (TopologicalSpace.Diagonal X) ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsClosed {p : α × α | p.fst = p.snd} ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsClosed (Set.Diagonal α) ", "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed (Diagonal α) ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsClosed (Set.Diagonal α) ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsClosed (Set.Diagonal α) ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsClosed (Set.Diagonal α) ", "∀ {X : Type u_1} [inst : TopologicalSpace X],\n  T2Space X ↔ IsClosed (Diagonal X) ", "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed (Set.Diagonal α) ", "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed (Diagonal α) "]}
{"docString": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ (U : Set α), IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s "]}
{"docString": "Every non-identity element of a free group is of infinite order.", "choices": ["∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α] {x : α}, x ≠ 1 → ¬IsOfFinOrder x ", "∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α] {x : α}, x ≠ 1 → ¬IsOfFinOrder x ", "∀ {α : Type u} [inst : Semigroup α] (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x ", "∀ {α : Type u_1} [inst : FreeGroup α] (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x ", "∀ {α : Type u} [self : FreeGroup α] (x : α), x ≠ 1 → ¬IsOfFinOrder x ", "∀ {α : Type u} (x : FreeGroup α), x ≠ FreeGroup.of [] → ¬IsOfFinOrder x ", "∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α] (x : α), x ≠ 1 → ¬IsOfFinOrder x ", "∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α] (a : α), a ≠ 1 → ¬IsOfFinOrder a ", "∀ {α : Type u_1} (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x "]}
{"docString": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.", "choices": ["∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (v : DiscreteValuationRing.Valuation R)\n  (u : R), IsUnit u ↔ v u = 0 ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (u : R),\n  u ∈ DiscreteValuationRing.unitsOf R ↔ DiscreteValuationRing.valuationOf u = 0 ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] {u : R},\n  IsUnit u ↔ DiscreteValuationRing.valuation u = 0 ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  x ∈ DiscreteValuationRing.unitsValuationZero R ↔ IsUnit x ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (ϖ : R) (hϖ : Irreducible ϖ) (x : R), IsUnit x ↔ ∀ (v : DiscreteValuationRing.Aux R ϖ hϖ), v x = 0 ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (u : R), IsUnit u ↔ DiscreteValuationRing.has_valuation.zero R u ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (u : R), IsUnit u ↔ DiscreteValuationRing.valuation u = 0 ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] {x : R},\n  IsUnit x ↔ DiscreteValuationRing.valuation x = 0 ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (ϖ : R) (hr : Irreducible ϖ), ϖ ≠ 0 → (∀ (u : Rˣ), (DiscreteValuationRing.valuation R ϖ u).1 = 0 ↔ ↑u = 1) ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (u : R),\n  IsUnit u ↔ DiscreteValuationRing.hasUnit u = 0 "]}
{"docString": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.", "choices": ["∀ {a b N : ℕ}, Nat.coprime a b → a ≠ 0 → b ≠ 0 → ∃ (x y : ℕ), N ≤ a * x + b * y ", "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ", "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ", "∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ (x y : ℕ), N ≤ a * x + b * y ", "∀ {a b : ℕ}, Nat.coprime a b → ∃ N : ℕ, ∀ n : ℕ, N ≤ n → ∃ x y : ℕ, n = a * x + b * y ", "∀ {a b N : ℕ}, Nat.gcd a b = 1 → N ≥ a * b - a - b → ∃ x y : ℕ, N = a * x + b * y ", "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, a * x + b * y ≥ N ", "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ", "∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ (x y : ℕ), N ≤ a * x + b * y ", "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, a * x + b * y ≥ N "]}
{"docString": "Every field is a ring.", "choices": ["forall (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K "]}
{"docString": "The set of units in a ring forms a group.", "choices": ["∀ {R : Type u_1} [inst : Ring R], IsGroup {x : R | IsUnit x} ", "Group {R : Type u_1} [inst : Ring R] : Type u_1 ", "∀ {R : Type u_1} [inst : Ring R], Group Rˣ ", "∀ {R : Type u} [inst : Ring R], Group Rˣ ", "∀ {R : Type u_1} [inst : Ring R], Group (Units R) ", "∀ {R : Type u_1} [inst : Ring R], Group Rˣ ", "∀ {R : Type u_1} [inst : Ring R], Group Rˣ ", "∀ {R : Type u_1} [inst : Monoid R], Group (Units R) ", "∀ {R : Type u} [inst : Monoid R], Group (Units R) ", "∀ {R : Type u} [inst : Ring R], Group (Units R) "]}
{"docString": "If the direct product of two groups is torsion free then each of the groups is torsion free.", "choices": ["∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\n  Monoid.IsTorsionFree ((i : η) → Gs i) → ∀ (i : η), Monoid.IsTorsionFree (Gs i) ", "forall {G H : Type u_1} [inst : Group G] [inst_1 : Group H], Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H ", "forall {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H ", "forall {G : Type u_1} {H : Type u_2} [inst_1 : Group G] [inst_2 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H ", "forall {A B : Type u_1} [inst : Group A] [inst_1 : Group B],\n  Monoid.IsTorsionFree (A × B) → Monoid.IsTorsionFree A ∧ Monoid.IsTorsionFree B ", "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H ", "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ", "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ", "∀ {G₁ G₂ : Type u_1} [inst : Group G₁] [inst_1 : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ", "∀ {G₁ G₂ : Type u_1} [inst : Group G₁] [inst_1 : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ "]}
